head	1.366;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.362
	gdb_7_6-2013-04-26-release:1.362
	gdb_7_6-branch:1.362.0.2
	gdb_7_6-2013-03-12-branchpoint:1.362
	gdb_7_5_1-2012-11-29-release:1.358
	gdb_7_5-2012-08-17-release:1.358
	gdb_7_5-branch:1.358.0.2
	gdb_7_5-2012-07-18-branchpoint:1.358
	gdb_7_4_1-2012-04-26-release:1.353.2.1
	gdb_7_4-2012-01-24-release:1.353.2.1
	gdb_7_4-branch:1.353.0.2
	gdb_7_4-2011-12-13-branchpoint:1.353
	gdb_7_3_1-2011-09-04-release:1.352
	gdb_7_3-2011-07-26-release:1.352
	gdb_7_3-branch:1.352.0.2
	gdb_7_3-2011-04-01-branchpoint:1.352
	gdb_7_2-2010-09-02-release:1.340
	gdb_7_2-branch:1.340.0.4
	gdb_7_2-2010-07-07-branchpoint:1.340
	gdb_7_1-2010-03-18-release:1.340
	gdb_7_1-branch:1.340.0.2
	gdb_7_1-2010-02-18-branchpoint:1.340
	gdb_7_0_1-2009-12-22-release:1.336.2.2
	gdb_7_0-2009-10-06-release:1.336.2.2
	gdb_7_0-branch:1.336.0.2
	gdb_7_0-2009-09-16-branchpoint:1.336
	arc-sim-20090309:1.307
	msnyder-checkpoint-072509-branch:1.335.0.2
	msnyder-checkpoint-072509-branchpoint:1.335
	arc-insight_6_8-branch:1.307.0.6
	arc-insight_6_8-branchpoint:1.307
	insight_6_8-branch:1.307.0.4
	insight_6_8-branchpoint:1.307
	reverse-20081226-branch:1.326.0.6
	reverse-20081226-branchpoint:1.326
	multiprocess-20081120-branch:1.326.0.4
	multiprocess-20081120-branchpoint:1.326
	reverse-20080930-branch:1.326.0.2
	reverse-20080930-branchpoint:1.326
	reverse-20080717-branch:1.318.0.2
	reverse-20080717-branchpoint:1.318
	msnyder-reverse-20080609-branch:1.315.0.2
	msnyder-reverse-20080609-branchpoint:1.315
	drow-reverse-20070409-branch:1.269.0.2
	drow-reverse-20070409-branchpoint:1.269
	gdb_6_8-2008-03-27-release:1.307
	gdb_6_8-branch:1.307.0.2
	gdb_6_8-2008-02-26-branchpoint:1.307
	gdb_6_7_1-2007-10-29-release:1.288.2.1
	gdb_6_7-2007-10-10-release:1.288
	gdb_6_7-branch:1.288.0.2
	gdb_6_7-2007-09-07-branchpoint:1.288
	insight_6_6-20070208-release:1.258
	gdb_6_6-2006-12-18-release:1.258
	gdb_6_6-branch:1.258.0.8
	gdb_6_6-2006-11-15-branchpoint:1.258
	insight_6_5-20061003-release:1.258
	gdb-csl-symbian-6_4_50_20060226-12:1.256.8.1
	gdb-csl-sourcerygxx-3_4_4-25:1.248
	nickrob-async-20060828-mergepoint:1.258
	gdb-csl-symbian-6_4_50_20060226-11:1.256.8.1
	gdb-csl-sourcerygxx-4_1-17:1.256
	gdb-csl-20060226-branch-local-2:1.256
	gdb-csl-sourcerygxx-4_1-14:1.256
	gdb-csl-sourcerygxx-4_1-13:1.256
	gdb-csl-sourcerygxx-4_1-12:1.256
	gdb-csl-sourcerygxx-3_4_4-21:1.256
	gdb_6_5-20060621-release:1.258
	gdb-csl-sourcerygxx-4_1-9:1.256
	gdb-csl-sourcerygxx-4_1-8:1.256
	gdb-csl-sourcerygxx-4_1-7:1.256
	gdb-csl-arm-2006q1-6:1.256
	gdb-csl-sourcerygxx-4_1-6:1.256
	gdb-csl-symbian-6_4_50_20060226-10:1.256.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.256.8.1
	gdb-csl-symbian-6_4_50_20060226-8:1.256.8.1
	gdb-csl-coldfire-4_1-11:1.256
	gdb-csl-sourcerygxx-3_4_4-19:1.256
	gdb-csl-coldfire-4_1-10:1.256
	gdb_6_5-branch:1.258.0.6
	gdb_6_5-2006-05-14-branchpoint:1.258
	gdb-csl-sourcerygxx-4_1-5:1.256
	nickrob-async-20060513-branch:1.258.0.4
	nickrob-async-20060513-branchpoint:1.258
	gdb-csl-sourcerygxx-4_1-4:1.256
	msnyder-reverse-20060502-branch:1.258.0.2
	msnyder-reverse-20060502-branchpoint:1.258
	gdb-csl-morpho-4_1-4:1.256
	gdb-csl-sourcerygxx-3_4_4-17:1.256
	readline_5_1-import-branch:1.257.0.2
	readline_5_1-import-branchpoint:1.257
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.256
	gdb-csl-symbian-20060226-branch:1.256.0.8
	gdb-csl-symbian-20060226-branchpoint:1.256
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.256
	msnyder-reverse-20060331-branch:1.256.0.6
	msnyder-reverse-20060331-branchpoint:1.256
	gdb-csl-available-20060303-branch:1.256.0.4
	gdb-csl-available-20060303-branchpoint:1.256
	gdb-csl-20060226-branch:1.256.0.2
	gdb-csl-20060226-branchpoint:1.256
	gdb_6_4-20051202-release:1.248
	msnyder-fork-checkpoint-branch:1.248.0.6
	msnyder-fork-checkpoint-branchpoint:1.248
	gdb-csl-gxxpro-6_3-branch:1.248.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.248
	gdb_6_4-branch:1.248.0.2
	gdb_6_4-2005-11-01-branchpoint:1.248
	gdb-csl-arm-20051020-branch:1.246.0.2
	gdb-csl-arm-20051020-branchpoint:1.246
	msnyder-tracepoint-checkpoint-branch:1.241.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.241
	gdb-csl-arm-20050325-2005-q1b:1.238
	gdb-csl-arm-20050325-2005-q1a:1.238
	csl-arm-20050325-branch:1.238.0.2
	csl-arm-20050325-branchpoint:1.238
	gdb-post-i18n-errorwarning-20050211:1.236
	gdb-pre-i18n-errorwarning-20050211:1.236
	gdb_6_3-20041109-release:1.230
	gdb_6_3-branch:1.230.0.2
	gdb_6_3-20041019-branchpoint:1.230
	drow_intercu-merge-20040921:1.229
	drow_intercu-merge-20040915:1.229
	jimb-gdb_6_2-e500-branch:1.216.4.3.0.2
	jimb-gdb_6_2-e500-branchpoint:1.216
	gdb_6_2-20040730-release:1.216
	gdb_6_2-branch:1.216.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.216
	gdb_6_1_1-20040616-release:1.181
	gdb_6_1-2004-04-05-release:1.181
	drow_intercu-merge-20040402:1.191
	drow_intercu-merge-20040327:1.189
	ezannoni_pie-20040323-branch:1.189.0.2
	ezannoni_pie-20040323-branchpoint:1.189
	cagney_tramp-20040321-mergepoint:1.187
	cagney_tramp-20040309-branch:1.183.0.2
	cagney_tramp-20040309-branchpoint:1.183
	gdb_6_1-branch:1.181.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.181
	drow_intercu-20040221-branch:1.181.0.2
	drow_intercu-20040221-branchpoint:1.181
	cagney_bfdfile-20040213-branch:1.178.0.2
	cagney_bfdfile-20040213-branchpoint:1.178
	drow-cplus-merge-20040208:1.177
	carlton_dictionary-20040126-merge:1.176
	cagney_bigcore-20040122-branch:1.176.0.2
	cagney_bigcore-20040122-branchpoint:1.176
	drow-cplus-merge-20040113:1.173
	drow-cplus-merge-20031224:1.173
	drow-cplus-merge-20031220:1.173
	carlton_dictionary-20031215-merge:1.173
	drow-cplus-merge-20031214:1.173
	carlton-dictionary-20031111-merge:1.173
	gdb_6_0-2003-10-04-release:1.145.2.3
	kettenis_sparc-20030918-branch:1.161.0.2
	kettenis_sparc-20030918-branchpoint:1.161
	carlton_dictionary-20030917-merge:1.161
	ezannoni_pie-20030916-branchpoint:1.159
	ezannoni_pie-20030916-branch:1.159.0.2
	cagney_x86i386-20030821-branch:1.148.0.2
	cagney_x86i386-20030821-branchpoint:1.148
	carlton_dictionary-20030805-merge:1.147
	carlton_dictionary-20030627-merge:1.147
	gdb_6_0-branch:1.145.0.2
	gdb_6_0-2003-06-23-branchpoint:1.145
	jimb-ppc64-linux-20030613-branch:1.144.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.144
	cagney_convert-20030606-branch:1.136.0.2
	cagney_convert-20030606-branchpoint:1.136
	cagney_writestrings-20030508-branch:1.131.0.4
	cagney_writestrings-20030508-branchpoint:1.131
	jimb-ppc64-linux-20030528-branch:1.134.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.134
	carlton_dictionary-20030523-merge:1.134
	cagney_fileio-20030521-branch:1.134.0.2
	cagney_fileio-20030521-branchpoint:1.134
	kettenis_i386newframe-20030517-mergepoint:1.134
	jimb-ppc64-linux-20030509-branch:1.131.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.131
	kettenis_i386newframe-20030504-mergepoint:1.129
	carlton_dictionary-20030430-merge:1.129
	kettenis_i386newframe-20030419-branch:1.128.0.2
	kettenis_i386newframe-20030419-branchpoint:1.128
	carlton_dictionary-20030416-merge:1.127
	cagney_frameaddr-20030409-mergepoint:1.126
	kettenis_i386newframe-20030406-branch:1.124.0.2
	kettenis_i386newframe-20030406-branchpoint:1.124
	cagney_frameaddr-20030403-branchpoint:1.122
	cagney_frameaddr-20030403-branch:1.122.0.2
	cagney_framebase-20030330-mergepoint:1.118
	cagney_framebase-20030326-branch:1.115.0.2
	cagney_framebase-20030326-branchpoint:1.115
	cagney_lazyid-20030317-branch:1.111.0.2
	cagney_lazyid-20030317-branchpoint:1.111
	kettenis-i386newframe-20030316-mergepoint:1.111
	offbyone-20030313-branch:1.110.0.2
	offbyone-20030313-branchpoint:1.110
	kettenis-i386newframe-20030308-branch:1.109.0.4
	kettenis-i386newframe-20030308-branchpoint:1.109
	carlton_dictionary-20030305-merge:1.109
	cagney_offbyone-20030303-branch:1.109.0.2
	cagney_offbyone-20030303-branchpoint:1.109
	carlton_dictionary-20030207-merge:1.103
	interps-20030203-mergepoint:1.103
	interps-20030202-branch:1.103.0.4
	interps-20030202-branchpoint:1.103
	cagney-unwind-20030108-branch:1.103.0.2
	cagney-unwind-20030108-branchpoint:1.103
	carlton_dictionary-20021223-merge:1.100
	gdb_5_3-2002-12-12-release:1.81.2.1
	carlton_dictionary-20021115-merge:1.91
	kseitz_interps-20021105-merge:1.89
	kseitz_interps-20021103-merge:1.89
	drow-cplus-merge-20021020:1.88
	drow-cplus-merge-20021025:1.88
	carlton_dictionary-20021025-merge:1.88
	carlton_dictionary-20021011-merge:1.88
	drow-cplus-branch:1.88.0.2
	drow-cplus-branchpoint:1.88
	kseitz_interps-20020930-merge:1.85
	carlton_dictionary-20020927-merge:1.85
	carlton_dictionary-branch:1.82.0.2
	carlton_dictionary-20020920-branchpoint:1.82
	gdb_5_3-branch:1.81.0.2
	gdb_5_3-2002-09-04-branchpoint:1.81
	kseitz_interps-20020829-merge:1.81
	cagney_sysregs-20020825-branch:1.80.0.2
	cagney_sysregs-20020825-branchpoint:1.80
	readline_4_3-import-branch:1.78.0.2
	readline_4_3-import-branchpoint:1.78
	gdb_5_2_1-2002-07-23-release:1.38.2.1
	kseitz_interps-20020528-branch:1.65.0.2
	kseitz_interps-20020528-branchpoint:1.65
	cagney_regbuf-20020515-branch:1.64.0.2
	cagney_regbuf-20020515-branchpoint:1.64
	jimb-macro-020506-branch:1.63.0.2
	jimb-macro-020506-branchpoint:1.63
	gdb_5_2-2002-04-29-release:1.38.2.1
	gdb_5_2-branch:1.38.0.2
	gdb_5_2-2002-03-03-branchpoint:1.38
	gdb_5_1_1-2002-01-24-release:1.25
	gdb_5_1_0_1-2002-01-03-release:1.25
	cygnus_cvs_20020108_pre:1.35
	gdb_5_1_0_1-2002-01-03-branchpoint:1.25
	gdb_5_1_0_1-2002-01-03-branch:1.25.0.6
	gdb_5_1-2001-11-21-release:1.25
	gdb_s390-2001-09-26-branch:1.25.0.4
	gdb_s390-2001-09-26-branchpoint:1.25
	gdb_5_1-2001-07-29-branch:1.25.0.2
	gdb_5_1-2001-07-29-branchpoint:1.25
	dberlin-typesystem-branch:1.23.0.2
	dberlin-typesystem-branchpoint:1.23
	gdb-post-ptid_t-2001-05-03:1.22
	gdb-pre-ptid_t-2001-05-03:1.22
	insight-precleanup-2001-01-01:1.17
	gdb-post-protoization-2000-07-29:1.11
	gdb-pre-protoization-2000-07-29:1.10
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb-post-params-removal-2000-06-04:1.7
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.6
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.9
	insight-2000-02-04:1.1.1.9
	gdb-2000-02-04:1.1.1.9
	gdb-2000-02-02:1.1.1.9
	gdb-2000-02-01:1.1.1.9
	gdb-2000-01-31:1.1.1.9
	gdb-2000-01-26:1.1.1.9
	gdb-2000-01-24:1.1.1.9
	gdb-2000-01-17:1.1.1.9
	gdb-2000-01-10:1.1.1.9
	gdb-2000-01-05:1.1.1.9
	gdb-1999-12-21:1.1.1.9
	gdb-1999-12-13:1.1.1.9
	gdb-1999-12-07:1.1.1.9
	gdb-1999-12-06:1.1.1.9
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.9
	gdb-1999-11-01:1.1.1.9
	gdb-1999-10-25:1.1.1.9
	gdb-1999-10-18:1.1.1.9
	gdb-1999-10-11:1.1.1.9
	gdb-1999-10-04:1.1.1.9
	gdb-1999-09-28:1.1.1.8
	gdb-1999-09-21:1.1.1.8
	gdb-1999-09-13:1.1.1.8
	gdb-1999-09-08:1.1.1.8
	gdb-1999-08-30:1.1.1.7
	gdb-1999-08-23:1.1.1.7
	gdb-1999-08-16:1.1.1.7
	gdb-1999-08-09:1.1.1.7
	gdb-1999-08-02:1.1.1.7
	gdb-1999-07-26:1.1.1.7
	gdb-1999-07-19:1.1.1.7
	gdb-1999-07-12:1.1.1.7
	gdb-post-reformat-19990707:1.1.1.7
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.7
	gdb-pre-reformat-19990707:1.1.1.6
	gdb-1999-07-07:1.1.1.6
	gdb-1999-07-05:1.1.1.6
	gdb-1999-06-28:1.1.1.6
	gdb-1999-06-21:1.1.1.6
	gdb-1999-06-14:1.1.1.6
	gdb-1999-06-07:1.1.1.5
	gdb-1999-06-01:1.1.1.4
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.4
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.366
date	2013.07.06.02.46.00;	author luisgpm;	state Exp;
branches;
next	1.365;

1.365
date	2013.07.01.19.50.10;	author tromey;	state Exp;
branches;
next	1.364;

1.364
date	2013.06.04.02.44.35;	author amodra;	state Exp;
branches;
next	1.363;

1.363
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.362;

1.362
date	2013.02.01.20.54.18;	author andreast;	state Exp;
branches;
next	1.361;

1.361
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.360;

1.360
date	2012.12.15.14.30.18;	author brobecke;	state Exp;
branches;
next	1.359;

1.359
date	2012.11.28.20.07.19;	author emachado;	state Exp;
branches;
next	1.358;

1.358
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.357;

1.357
date	2012.03.13.16.15.35;	author brobecke;	state Exp;
branches;
next	1.356;

1.356
date	2012.02.02.20.19.16;	author devans;	state Exp;
branches;
next	1.355;

1.355
date	2012.01.28.18.08.19;	author jkratoch;	state Exp;
branches;
next	1.354;

1.354
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.353;

1.353
date	2011.11.22.08.19.16;	author amodra;	state Exp;
branches
	1.353.2.1;
next	1.352;

1.352
date	2011.03.18.18.52.31;	author palves;	state Exp;
branches;
next	1.351;

1.351
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.350;

1.350
date	2011.03.18.18.38.43;	author palves;	state Exp;
branches;
next	1.349;

1.349
date	2011.02.15.13.35.20;	author bauermann;	state Exp;
branches;
next	1.348;

1.348
date	2011.01.18.16.18.26;	author brobecke;	state Exp;
branches;
next	1.347;

1.347
date	2011.01.11.19.23.02;	author bauermann;	state Exp;
branches;
next	1.346;

1.346
date	2011.01.11.15.10.01;	author msnyder;	state Exp;
branches;
next	1.345;

1.345
date	2011.01.10.20.38.51;	author msnyder;	state Exp;
branches;
next	1.344;

1.344
date	2011.01.01.15.33.14;	author brobecke;	state Exp;
branches;
next	1.343;

1.343
date	2010.11.25.00.23.39;	author brobecke;	state Exp;
branches;
next	1.342;

1.342
date	2010.11.12.21.54.31;	author froydnj;	state Exp;
branches;
next	1.341;

1.341
date	2010.11.12.21.53.10;	author froydnj;	state Exp;
branches;
next	1.340;

1.340
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.339;

1.339
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.338;

1.338
date	2009.09.29.00.53.04;	author uweigand;	state Exp;
branches;
next	1.337;

1.337
date	2009.09.18.15.48.23;	author uweigand;	state Exp;
branches;
next	1.336;

1.336
date	2009.07.31.15.23.20;	author uweigand;	state Exp;
branches
	1.336.2.1;
next	1.335;

1.335
date	2009.07.21.20.21.20;	author msnyder;	state Exp;
branches;
next	1.334;

1.334
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.333;

1.333
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.332;

1.332
date	2009.07.02.17.12.27;	author uweigand;	state Exp;
branches;
next	1.331;

1.331
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.330;

1.330
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.329;

1.329
date	2009.06.17.18.43.24;	author uweigand;	state Exp;
branches;
next	1.328;

1.328
date	2009.02.22.01.02.19;	author palves;	state Exp;
branches;
next	1.327;

1.327
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.326;

1.326
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.325;

1.325
date	2008.09.08.16.18.24;	author guitton;	state Exp;
branches;
next	1.324;

1.324
date	2008.09.05.11.58.30;	author uweigand;	state Exp;
branches;
next	1.323;

1.323
date	2008.08.24.18.01.15;	author tromey;	state Exp;
branches;
next	1.322;

1.322
date	2008.08.24.16.39.57;	author tromey;	state Exp;
branches;
next	1.321;

1.321
date	2008.08.18.12.32.47;	author drow;	state Exp;
branches;
next	1.320;

1.320
date	2008.08.15.15.18.33;	author luisgpm;	state Exp;
branches;
next	1.319;

1.319
date	2008.08.12.00.29.35;	author kevinb;	state Exp;
branches;
next	1.318;

1.318
date	2008.07.15.18.32.06;	author drow;	state Exp;
branches;
next	1.317;

1.317
date	2008.07.10.19.40.43;	author kevinb;	state Exp;
branches;
next	1.316;

1.316
date	2008.06.30.14.11.48;	author luisgpm;	state Exp;
branches;
next	1.315;

1.315
date	2008.05.11.15.29.47;	author uweigand;	state Exp;
branches;
next	1.314;

1.314
date	2008.05.04.00.41.44;	author uweigand;	state Exp;
branches;
next	1.313;

1.313
date	2008.05.03.23.50.43;	author uweigand;	state Exp;
branches;
next	1.312;

1.312
date	2008.05.03.17.16.43;	author uweigand;	state Exp;
branches;
next	1.311;

1.311
date	2008.05.01.00.40.39;	author uweigand;	state Exp;
branches;
next	1.310;

1.310
date	2008.04.30.21.18.28;	author drow;	state Exp;
branches;
next	1.309;

1.309
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.308;

1.308
date	2008.04.17.21.00.53;	author brobecke;	state Exp;
branches;
next	1.307;

1.307
date	2008.02.20.14.34.43;	author deuling;	state Exp;
branches;
next	1.306;

1.306
date	2008.01.31.13.37.21;	author bauermann;	state Exp;
branches;
next	1.305;

1.305
date	2008.01.31.13.22.40;	author bauermann;	state Exp;
branches;
next	1.304;

1.304
date	2008.01.11.14.43.14;	author deuling;	state Exp;
branches;
next	1.303;

1.303
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.302;

1.302
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.301;

1.301
date	2007.12.06.16.33.00;	author deuling;	state Exp;
branches;
next	1.300;

1.300
date	2007.11.19.05.06.24;	author deuling;	state Exp;
branches;
next	1.299;

1.299
date	2007.11.16.04.53.46;	author deuling;	state Exp;
branches;
next	1.298;

1.298
date	2007.11.09.05.32.19;	author deuling;	state Exp;
branches;
next	1.297;

1.297
date	2007.11.07.06.33.00;	author deuling;	state Exp;
branches;
next	1.296;

1.296
date	2007.11.02.14.27.14;	author uweigand;	state Exp;
branches;
next	1.295;

1.295
date	2007.10.30.19.35.35;	author drow;	state Exp;
branches;
next	1.294;

1.294
date	2007.10.29.20.26.42;	author cseo;	state Exp;
branches;
next	1.293;

1.293
date	2007.10.21.20.04.47;	author luisgpm;	state Exp;
branches;
next	1.292;

1.292
date	2007.10.19.12.26.34;	author uweigand;	state Exp;
branches;
next	1.291;

1.291
date	2007.10.15.20.20.08;	author bauermann;	state Exp;
branches;
next	1.290;

1.290
date	2007.10.15.19.45.30;	author drow;	state Exp;
branches;
next	1.289;

1.289
date	2007.10.10.17.06.30;	author uweigand;	state Exp;
branches;
next	1.288;

1.288
date	2007.08.30.13.13.59;	author amodra;	state Exp;
branches
	1.288.2.1;
next	1.287;

1.287
date	2007.08.23.18.08.37;	author brobecke;	state Exp;
branches;
next	1.286;

1.286
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.285;

1.285
date	2007.06.16.17.25.59;	author uweigand;	state Exp;
branches;
next	1.284;

1.284
date	2007.06.15.22.44.56;	author uweigand;	state Exp;
branches;
next	1.283;

1.283
date	2007.06.15.22.39.52;	author uweigand;	state Exp;
branches;
next	1.282;

1.282
date	2007.06.15.22.37.34;	author uweigand;	state Exp;
branches;
next	1.281;

1.281
date	2007.06.09.14.20.24;	author uweigand;	state Exp;
branches;
next	1.280;

1.280
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.279;

1.279
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.278;

1.278
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.277;

1.277
date	2007.05.13.12.27.30;	author uweigand;	state Exp;
branches;
next	1.276;

1.276
date	2007.05.10.20.29.03;	author uweigand;	state Exp;
branches;
next	1.275;

1.275
date	2007.05.08.12.49.12;	author uweigand;	state Exp;
branches;
next	1.274;

1.274
date	2007.05.07.01.25.07;	author drow;	state Exp;
branches;
next	1.273;

1.273
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.272;

1.272
date	2007.04.14.18.10.54;	author uweigand;	state Exp;
branches;
next	1.271;

1.271
date	2007.04.12.14.52.20;	author uweigand;	state Exp;
branches;
next	1.270;

1.270
date	2007.04.10.16.02.41;	author schwab;	state Exp;
branches;
next	1.269;

1.269
date	2007.04.01.18.24.59;	author schwab;	state Exp;
branches;
next	1.268;

1.268
date	2007.03.27.19.04.37;	author drow;	state Exp;
branches;
next	1.267;

1.267
date	2007.03.27.19.02.42;	author drow;	state Exp;
branches;
next	1.266;

1.266
date	2007.03.13.17.34.22;	author drow;	state Exp;
branches;
next	1.265;

1.265
date	2007.02.27.23.04.28;	author uweigand;	state Exp;
branches;
next	1.264;

1.264
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.263;

1.263
date	2007.02.27.17.29.51;	author fnf;	state Exp;
branches;
next	1.262;

1.262
date	2007.02.08.18.05.23;	author drow;	state Exp;
branches;
next	1.261;

1.261
date	2007.02.08.14.22.53;	author drow;	state Exp;
branches;
next	1.260;

1.260
date	2007.01.09.17.58.57;	author drow;	state Exp;
branches;
next	1.259;

1.259
date	2007.01.02.19.21.13;	author kettenis;	state Exp;
branches;
next	1.258;

1.258
date	2006.04.23.14.15.01;	author schwab;	state Exp;
branches;
next	1.257;

1.257
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.256;

1.256
date	2006.02.10.20.56.14;	author brobecke;	state Exp;
branches
	1.256.8.1;
next	1.255;

1.255
date	2006.02.08.05.41.06;	author woodzltc;	state Exp;
branches;
next	1.254;

1.254
date	2006.01.23.01.49.43;	author drow;	state Exp;
branches;
next	1.253;

1.253
date	2006.01.17.22.21.13;	author pgilliam;	state Exp;
branches;
next	1.252;

1.252
date	2005.12.20.19.36.21;	author jimb;	state Exp;
branches;
next	1.251;

1.251
date	2005.12.20.17.57.44;	author brobecke;	state Exp;
branches;
next	1.250;

1.250
date	2005.12.20.14.04.20;	author brobecke;	state Exp;
branches;
next	1.249;

1.249
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.248;

1.248
date	2005.11.01.19.32.36;	author pgilliam;	state Exp;
branches;
next	1.247;

1.247
date	2005.10.22.15.12.36;	author kettenis;	state Exp;
branches;
next	1.246;

1.246
date	2005.10.14.20.17.11;	author pgilliam;	state Exp;
branches;
next	1.245;

1.245
date	2005.10.06.00.22.57;	author amodra;	state Exp;
branches;
next	1.244;

1.244
date	2005.09.29.15.37.44;	author drow;	state Exp;
branches;
next	1.243;

1.243
date	2005.09.19.17.38.03;	author pgilliam;	state Exp;
branches;
next	1.242;

1.242
date	2005.09.01.18.09.41;	author pgilliam;	state Exp;
branches;
next	1.241;

1.241
date	2005.05.25.03.12.13;	author cagney;	state Exp;
branches;
next	1.240;

1.240
date	2005.05.01.19.58.55;	author cagney;	state Exp;
branches;
next	1.239;

1.239
date	2005.04.10.21.14.37;	author kettenis;	state Exp;
branches;
next	1.238;

1.238
date	2005.02.15.15.49.18;	author cagney;	state Exp;
branches;
next	1.237;

1.237
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.236;

1.236
date	2005.02.07.00.09.55;	author cagney;	state Exp;
branches;
next	1.235;

1.235
date	2005.01.26.21.53.06;	author cagney;	state Exp;
branches;
next	1.234;

1.234
date	2005.01.14.01.54.49;	author msnyder;	state Exp;
branches;
next	1.233;

1.233
date	2004.11.25.02.48.27;	author fnf;	state Exp;
branches;
next	1.232;

1.232
date	2004.11.12.21.45.07;	author cagney;	state Exp;
branches;
next	1.231;

1.231
date	2004.11.11.19.21.01;	author msnyder;	state Exp;
branches;
next	1.230;

1.230
date	2004.10.13.16.38.22;	author kevinb;	state Exp;
branches;
next	1.229;

1.229
date	2004.08.09.18.43.21;	author jimb;	state Exp;
branches;
next	1.228;

1.228
date	2004.08.04.17.45.30;	author jimb;	state Exp;
branches;
next	1.227;

1.227
date	2004.08.04.17.17.55;	author jimb;	state Exp;
branches;
next	1.226;

1.226
date	2004.08.04.17.04.35;	author jimb;	state Exp;
branches;
next	1.225;

1.225
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.224;

1.224
date	2004.07.31.21.53.17;	author cagney;	state Exp;
branches;
next	1.223;

1.223
date	2004.07.20.22.09.53;	author jimb;	state Exp;
branches;
next	1.222;

1.222
date	2004.07.20.22.08.37;	author jimb;	state Exp;
branches;
next	1.221;

1.221
date	2004.07.20.22.06.05;	author jimb;	state Exp;
branches;
next	1.220;

1.220
date	2004.07.16.20.53.06;	author jimb;	state Exp;
branches;
next	1.219;

1.219
date	2004.07.15.08.02.36;	author jimb;	state Exp;
branches;
next	1.218;

1.218
date	2004.07.14.23.58.04;	author jimb;	state Exp;
branches;
next	1.217;

1.217
date	2004.07.14.23.00.59;	author jimb;	state Exp;
branches;
next	1.216;

1.216
date	2004.07.08.23.43.47;	author jimb;	state Exp;
branches
	1.216.4.1;
next	1.215;

1.215
date	2004.06.20.17.18.06;	author cagney;	state Exp;
branches;
next	1.214;

1.214
date	2004.06.07.23.37.20;	author jimb;	state Exp;
branches;
next	1.213;

1.213
date	2004.06.07.02.02.53;	author tausq;	state Exp;
branches;
next	1.212;

1.212
date	2004.06.05.00.11.49;	author jimb;	state Exp;
branches;
next	1.211;

1.211
date	2004.06.02.03.06.23;	author jimb;	state Exp;
branches;
next	1.210;

1.210
date	2004.05.28.21.59.37;	author jimb;	state Exp;
branches;
next	1.209;

1.209
date	2004.05.28.18.56.36;	author jimb;	state Exp;
branches;
next	1.208;

1.208
date	2004.05.22.06.03.26;	author jimb;	state Exp;
branches;
next	1.207;

1.207
date	2004.05.20.18.49.37;	author jimb;	state Exp;
branches;
next	1.206;

1.206
date	2004.05.19.04.18.42;	author jimb;	state Exp;
branches;
next	1.205;

1.205
date	2004.05.15.05.57.16;	author brobecke;	state Exp;
branches;
next	1.204;

1.204
date	2004.05.13.19.36.05;	author jimb;	state Exp;
branches;
next	1.203;

1.203
date	2004.05.13.19.27.07;	author jimb;	state Exp;
branches;
next	1.202;

1.202
date	2004.05.11.04.55.32;	author jimb;	state Exp;
branches;
next	1.201;

1.201
date	2004.05.10.18.58.44;	author jimb;	state Exp;
branches;
next	1.200;

1.200
date	2004.05.10.17.07.02;	author jimb;	state Exp;
branches;
next	1.199;

1.199
date	2004.05.10.16.53.56;	author jimb;	state Exp;
branches;
next	1.198;

1.198
date	2004.05.10.16.52.39;	author jimb;	state Exp;
branches;
next	1.197;

1.197
date	2004.05.08.22.19.30;	author cagney;	state Exp;
branches;
next	1.196;

1.196
date	2004.05.05.01.46.55;	author jimb;	state Exp;
branches;
next	1.195;

1.195
date	2004.05.04.17.58.31;	author jimb;	state Exp;
branches;
next	1.194;

1.194
date	2004.04.23.16.21.34;	author guitton;	state Exp;
branches;
next	1.193;

1.193
date	2004.04.22.21.13.06;	author kettenis;	state Exp;
branches;
next	1.192;

1.192
date	2004.04.21.16.38.07;	author jimb;	state Exp;
branches;
next	1.191;

1.191
date	2004.04.01.21.00.59;	author jimb;	state Exp;
branches;
next	1.190;

1.190
date	2004.03.29.03.41.56;	author jimb;	state Exp;
branches;
next	1.189;

1.189
date	2004.03.23.16.32.39;	author cagney;	state Exp;
branches;
next	1.188;

1.188
date	2004.03.22.17.07.08;	author cagney;	state Exp;
branches;
next	1.187;

1.187
date	2004.03.20.04.58.13;	author kevinb;	state Exp;
branches;
next	1.186;

1.186
date	2004.03.20.04.51.21;	author kevinb;	state Exp;
branches;
next	1.185;

1.185
date	2004.03.18.20.30.08;	author cagney;	state Exp;
branches;
next	1.184;

1.184
date	2004.03.15.21.21.01;	author cagney;	state Exp;
branches;
next	1.183;

1.183
date	2004.03.02.02.20.25;	author cagney;	state Exp;
branches
	1.183.2.1;
next	1.182;

1.182
date	2004.03.01.00.50.56;	author cagney;	state Exp;
branches;
next	1.181;

1.181
date	2004.02.17.15.21.22;	author cagney;	state Exp;
branches
	1.181.2.1;
next	1.180;

1.180
date	2004.02.16.21.49.22;	author cagney;	state Exp;
branches;
next	1.179;

1.179
date	2004.02.14.15.46.33;	author ezannoni;	state Exp;
branches;
next	1.178;

1.178
date	2004.02.12.18.43.09;	author cagney;	state Exp;
branches;
next	1.177;

1.177
date	2004.01.26.20.52.11;	author cagney;	state Exp;
branches;
next	1.176;

1.176
date	2004.01.17.15.34.12;	author cagney;	state Exp;
branches;
next	1.175;

1.175
date	2004.01.17.00.00.48;	author cagney;	state Exp;
branches;
next	1.174;

1.174
date	2004.01.13.21.38.47;	author cagney;	state Exp;
branches;
next	1.173;

1.173
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.172;

1.172
date	2003.11.07.20.44.51;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2003.10.31.16.37.03;	author cagney;	state Exp;
branches;
next	1.170;

1.170
date	2003.10.22.23.54.11;	author cagney;	state Exp;
branches;
next	1.169;

1.169
date	2003.10.10.21.32.47;	author cagney;	state Exp;
branches;
next	1.168;

1.168
date	2003.10.10.18.29.13;	author cagney;	state Exp;
branches;
next	1.167;

1.167
date	2003.10.10.02.40.19;	author cagney;	state Exp;
branches;
next	1.166;

1.166
date	2003.10.03.21.11.39;	author cagney;	state Exp;
branches;
next	1.165;

1.165
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.164;

1.164
date	2003.09.30.21.16.39;	author cagney;	state Exp;
branches;
next	1.163;

1.163
date	2003.09.28.22.32.19;	author cagney;	state Exp;
branches;
next	1.162;

1.162
date	2003.09.25.20.44.01;	author cagney;	state Exp;
branches;
next	1.161;

1.161
date	2003.09.17.14.24.30;	author cagney;	state Exp;
branches;
next	1.160;

1.160
date	2003.09.16.23.33.17;	author cagney;	state Exp;
branches;
next	1.159;

1.159
date	2003.09.14.22.35.33;	author cagney;	state Exp;
branches;
next	1.158;

1.158
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.157;

1.157
date	2003.09.12.18.40.18;	author cagney;	state Exp;
branches;
next	1.156;

1.156
date	2003.09.11.19.27.25;	author cagney;	state Exp;
branches;
next	1.155;

1.155
date	2003.09.09.22.41.47;	author cagney;	state Exp;
branches;
next	1.154;

1.154
date	2003.09.09.22.21.36;	author cagney;	state Exp;
branches;
next	1.153;

1.153
date	2003.09.09.22.10.57;	author cagney;	state Exp;
branches;
next	1.152;

1.152
date	2003.09.09.20.22.37;	author cagney;	state Exp;
branches;
next	1.151;

1.151
date	2003.09.09.18.29.27;	author cagney;	state Exp;
branches;
next	1.150;

1.150
date	2003.09.09.04.41.32;	author cagney;	state Exp;
branches;
next	1.149;

1.149
date	2003.09.09.03.58.18;	author cagney;	state Exp;
branches;
next	1.148;

1.148
date	2003.08.18.20.04.55;	author cagney;	state Exp;
branches;
next	1.147;

1.147
date	2003.06.26.17.18.42;	author cagney;	state Exp;
branches;
next	1.146;

1.146
date	2003.06.23.21.05.40;	author cagney;	state Exp;
branches;
next	1.145;

1.145
date	2003.06.16.16.47.42;	author cagney;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2003.06.13.04.40.33;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2003.06.11.19.38.26;	author cagney;	state Exp;
branches;
next	1.142;

1.142
date	2003.06.11.13.16.28;	author cagney;	state Exp;
branches;
next	1.141;

1.141
date	2003.06.09.17.35.58;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2003.06.08.18.27.14;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2003.06.07.22.38.55;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2003.06.07.18.08.24;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2003.06.07.16.23.12;	author cagney;	state Exp;
branches;
next	1.136;

1.136
date	2003.06.02.02.54.35;	author fedor;	state Exp;
branches;
next	1.135;

1.135
date	2003.05.29.19.47.14;	author kevinb;	state Exp;
branches;
next	1.134;

1.134
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches
	1.134.4.1;
next	1.133;

1.133
date	2003.05.15.22.58.38;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2003.05.13.19.27.28;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2003.05.08.20.52.48;	author cagney;	state Exp;
branches
	1.131.2.1
	1.131.4.1;
next	1.130;

1.130
date	2003.05.05.17.56.55;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2003.04.16.20.41.46;	author kevinb;	state Exp;
branches
	1.128.2.1;
next	1.127;

1.127
date	2003.04.11.18.15.39;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2003.04.09.22.44.24;	author kevinb;	state Exp;
branches;
next	1.125;

1.125
date	2003.04.09.15.08.26;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2003.04.03.17.56.25;	author kevinb;	state Exp;
branches;
next	1.122;

1.122
date	2003.04.01.17.17.29;	author cagney;	state Exp;
branches
	1.122.2.1;
next	1.121;

1.121
date	2003.04.01.14.38.50;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.03.31.21.58.22;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2003.03.31.19.01.20;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.03.30.14.59.01;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2003.03.30.14.32.09;	author cagney;	state Exp;
branches;
next	1.116;

1.116
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2003.03.25.20.38.46;	author cagney;	state Exp;
branches
	1.115.2.1;
next	1.114;

1.114
date	2003.03.25.18.54.15;	author cagney;	state Exp;
branches;
next	1.113;

1.113
date	2003.03.24.03.54.48;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2003.03.17.18.27.07;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2003.03.13.21.45.41;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2003.03.12.16.50.45;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2003.03.03.20.50.19;	author cagney;	state Exp;
branches
	1.109.4.1;
next	1.108;

1.108
date	2003.03.02.04.02.24;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2003.03.02.00.11.42;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.02.25.21.36.19;	author carlton;	state Exp;
branches;
next	1.104;

1.104
date	2003.02.19.18.57.30;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.01.05.01.39.55;	author drow;	state Exp;
branches;
next	1.102;

1.102
date	2003.01.04.23.38.45;	author drow;	state Exp;
branches;
next	1.101;

1.101
date	2003.01.04.22.37.47;	author drow;	state Exp;
branches;
next	1.100;

1.100
date	2002.12.18.15.23.22;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2002.12.09.03.30.44;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2002.12.09.01.40.25;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2002.12.09.00.32.08;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2002.11.28.18.15.58;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2002.11.24.19.48.13;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2002.11.18.22.19.29;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2002.11.16.01.00.06;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2002.11.14.20.37.29;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2002.10.02.21.21.47;	author cagney;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2002.10.02.21.18.57;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2002.10.01.14.57.55;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2002.09.26.22.34.07;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2002.09.26.22.29.09;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2002.09.25.13.34.53;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2002.09.17.20.42.01;	author cagney;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2002.08.26.23.20.53;	author kevinb;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2002.08.25.15.18.41;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2002.08.25.13.15.50;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2002.08.24.00.21.35;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2002.08.22.22.26.41;	author ezannoni;	state Exp;
branches;
next	1.76;

1.76
date	2002.08.21.22.56.02;	author ezannoni;	state Exp;
branches;
next	1.75;

1.75
date	2002.08.20.22.24.29;	author ezannoni;	state Exp;
branches;
next	1.74;

1.74
date	2002.08.20.22.11.48;	author ezannoni;	state Exp;
branches;
next	1.73;

1.73
date	2002.08.20.17.33.51;	author ezannoni;	state Exp;
branches;
next	1.72;

1.72
date	2002.08.19.23.21.16;	author ezannoni;	state Exp;
branches;
next	1.71;

1.71
date	2002.08.19.17.57.59;	author ezannoni;	state Exp;
branches;
next	1.70;

1.70
date	2002.07.15.15.09.55;	author ezannoni;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.28.16.15.07;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.17.23.32.33;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.14.22.55.40;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.30.01.21.51;	author thorpej;	state Exp;
branches;
next	1.65;

1.65
date	2002.05.20.17.45.43;	author ezannoni;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2002.05.12.02.16.04;	author cagney;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2002.04.30.23.36.11;	author kevinb;	state Exp;
branches;
next	1.62;

1.62
date	2002.04.30.00.26.43;	author kevinb;	state Exp;
branches;
next	1.61;

1.61
date	2002.04.29.15.10.06;	author ezannoni;	state Exp;
branches;
next	1.60;

1.60
date	2002.04.26.04.31.47;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2002.04.20.03.09.28;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.04.18.18.09.06;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2002.04.18.15.10.15;	author ezannoni;	state Exp;
branches;
next	1.56;

1.56
date	2002.04.17.23.28.38;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2002.04.12.19.48.36;	author kevinb;	state Exp;
branches;
next	1.54;

1.54
date	2002.04.12.18.18.57;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.12.17.12.24;	author kevinb;	state Exp;
branches;
next	1.52;

1.52
date	2002.04.12.07.37.18;	author kevinb;	state Exp;
branches;
next	1.51;

1.51
date	2002.04.12.07.20.32;	author kevinb;	state Exp;
branches;
next	1.50;

1.50
date	2002.04.11.19.08.56;	author kevinb;	state Exp;
branches;
next	1.49;

1.49
date	2002.04.09.02.26.10;	author kevinb;	state Exp;
branches;
next	1.48;

1.48
date	2002.04.09.01.41.46;	author kevinb;	state Exp;
branches;
next	1.47;

1.47
date	2002.04.09.00.53.28;	author kevinb;	state Exp;
branches;
next	1.46;

1.46
date	2002.04.09.00.10.09;	author kevinb;	state Exp;
branches;
next	1.45;

1.45
date	2002.04.08.22.56.46;	author kevinb;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2002.04.05.22.36.32;	author kevinb;	state Exp;
branches;
next	1.42;

1.42
date	2002.04.01.05.58.45;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.28.00.48.41;	author ezannoni;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.22.21.58.15;	author ezannoni;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.22.00.19.02;	author ezannoni;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.14.15.13.53;	author ezannoni;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2002.01.29.03.08.25;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.15.19.38.19;	author ezannoni;	state Exp;
branches;
next	1.35;

1.35
date	2002.01.06.04.50.56;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.05.04.30.19;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.30.00.14.50;	author ezannoni;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.20.03.26.08;	author jimb;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.11.22.16.48;	author msnyder;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.09.21.39.53;	author ezannoni;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.01.00.23.37;	author kevinb;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.21.17.19.37;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.29.21.32.01;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.01.18.39.23;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.07.17.19.50;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.14.16.43.35;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.01.19.36.11;	author nsd;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.21.18.31.47;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.06.08.21.16;	author kevinb;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.18.05.50.11;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.09.09.49.00;	author schauer;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.26.07.41.25;	author schauer;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.05.01.13.53;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.24.09.58.16;	author schauer;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.31.20.56.43;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.14.22.17.32;	author nsd;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.07.22.00.09;	author nsd;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.16.21.02.21;	author nsd;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.26.09.30.30;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.24.23.06.48;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.22.01.20.32;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.15.21.17.04;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.353.2.1
date	2012.01.06.04.43.27;	author brobecke;	state Exp;
branches;
next	;

1.336.2.1
date	2009.09.18.15.50.14;	author uweigand;	state Exp;
branches;
next	1.336.2.2;

1.336.2.2
date	2009.09.29.12.09.19;	author uweigand;	state Exp;
branches;
next	;

1.288.2.1
date	2007.10.25.13.52.48;	author drow;	state Exp;
branches;
next	;

1.256.8.1
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	;

1.216.4.1
date	2004.09.01.17.39.05;	author jimb;	state Exp;
branches;
next	1.216.4.2;

1.216.4.2
date	2004.09.07.15.53.50;	author jimb;	state Exp;
branches;
next	1.216.4.3;

1.216.4.3
date	2004.09.07.16.16.01;	author jimb;	state Exp;
branches;
next	;

1.183.2.1
date	2004.03.09.22.59.01;	author cagney;	state Exp;
branches;
next	1.183.2.2;

1.183.2.2
date	2004.03.16.16.05.56;	author cagney;	state Exp;
branches;
next	1.183.2.3;

1.183.2.3
date	2004.03.21.23.57.34;	author cagney;	state Exp;
branches;
next	;

1.181.2.1
date	2004.03.27.17.37.51;	author drow;	state Exp;
branches;
next	1.181.2.2;

1.181.2.2
date	2004.04.02.16.47.47;	author drow;	state Exp;
branches;
next	1.181.2.3;

1.181.2.3
date	2004.09.16.17.01.18;	author drow;	state Exp;
branches;
next	;

1.145.2.1
date	2003.06.23.21.11.33;	author cagney;	state Exp;
branches;
next	1.145.2.2;

1.145.2.2
date	2003.08.18.20.12.31;	author cagney;	state Exp;
branches;
next	1.145.2.3;

1.145.2.3
date	2003.09.30.21.10.20;	author cagney;	state Exp;
branches;
next	;

1.134.4.1
date	2003.06.06.07.00.48;	author jimb;	state Exp;
branches;
next	;

1.131.2.1
date	2003.05.13.00.08.58;	author jimb;	state Exp;
branches;
next	;

1.131.4.1
date	2003.06.03.20.54.39;	author cagney;	state Exp;
branches;
next	;

1.128.2.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	1.128.2.2;

1.128.2.2
date	2003.05.18.09.44.20;	author kettenis;	state Exp;
branches;
next	;

1.122.2.1
date	2003.04.10.21.33.49;	author cagney;	state Exp;
branches;
next	;

1.115.2.1
date	2003.03.30.16.35.22;	author cagney;	state Exp;
branches;
next	;

1.109.4.1
date	2003.03.16.14.01.50;	author kettenis;	state Exp;
branches;
next	;

1.88.2.1
date	2003.12.14.20.27.29;	author drow;	state Exp;
branches;
next	1.88.2.2;

1.88.2.2
date	2004.02.09.19.43.47;	author drow;	state Exp;
branches;
next	;

1.82.2.1
date	2002.09.27.20.03.07;	author carlton;	state Exp;
branches;
next	1.82.2.2;

1.82.2.2
date	2002.10.11.22.22.56;	author carlton;	state Exp;
branches;
next	1.82.2.3;

1.82.2.3
date	2002.11.15.19.18.55;	author carlton;	state Exp;
branches;
next	1.82.2.4;

1.82.2.4
date	2002.12.23.19.38.40;	author carlton;	state Exp;
branches;
next	1.82.2.5;

1.82.2.5
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.82.2.6;

1.82.2.6
date	2003.03.06.00.56.31;	author carlton;	state Exp;
branches;
next	1.82.2.7;

1.82.2.7
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.82.2.8;

1.82.2.8
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.82.2.9;

1.82.2.9
date	2003.05.23.18.40.44;	author carlton;	state Exp;
branches;
next	1.82.2.10;

1.82.2.10
date	2003.06.27.21.50.08;	author carlton;	state Exp;
branches;
next	1.82.2.11;

1.82.2.11
date	2003.09.17.21.28.30;	author carlton;	state Exp;
branches;
next	1.82.2.12;

1.82.2.12
date	2003.11.11.23.50.53;	author carlton;	state Exp;
branches;
next	1.82.2.13;

1.82.2.13
date	2004.01.26.19.11.30;	author carlton;	state Exp;
branches;
next	;

1.81.2.1
date	2002.10.01.15.00.49;	author cagney;	state Exp;
branches;
next	;

1.65.2.1
date	2002.06.20.01.32.59;	author kseitz;	state Exp;
branches;
next	1.65.2.2;

1.65.2.2
date	2002.07.22.21.47.02;	author kseitz;	state Exp;
branches;
next	1.65.2.3;

1.65.2.3
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	1.65.2.4;

1.65.2.4
date	2002.10.01.00.46.14;	author kseitz;	state Exp;
branches;
next	1.65.2.5;

1.65.2.5
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.64.2.1
date	2002.05.16.00.54.56;	author cagney;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2002.05.16.19.08.01;	author cagney;	state Exp;
branches;
next	1.64.2.3;

1.64.2.3
date	2002.05.23.18.03.25;	author cagney;	state Exp;
branches;
next	1.64.2.4;

1.64.2.4
date	2002.06.15.16.42.54;	author cagney;	state Exp;
branches;
next	1.64.2.5;

1.64.2.5
date	2002.06.15.19.32.43;	author cagney;	state Exp;
branches;
next	1.64.2.6;

1.64.2.6
date	2002.06.21.16.19.29;	author cagney;	state Exp;
branches;
next	1.64.2.7;

1.64.2.7
date	2002.06.28.23.19.26;	author cagney;	state Exp;
branches;
next	1.64.2.8;

1.64.2.8
date	2002.07.03.18.43.57;	author cagney;	state Exp;
branches;
next	;

1.38.2.1
date	2002.04.01.06.01.46;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.11;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.51;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.25.18.03.12;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.06.07.19.17.49;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.06.14.18.08.00;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.07.07.20.09.36;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.09.08.23.59.29;	author shebs;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.10.05.23.08.45;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.366
log
@	* rs6000-tdep.c	(rs6000_stab_reg_to_regnum): Return the real
	register number instead of the pseudo register one.
	(rs6000_dwarf2_reg_to_regnum): Likewise.
@
text
@/* Target-dependent code for GDB, the GNU debugger.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "symtab.h"
#include "target.h"
#include "gdbcore.h"
#include "gdbcmd.h"
#include "objfiles.h"
#include "arch-utils.h"
#include "regcache.h"
#include "regset.h"
#include "doublest.h"
#include "value.h"
#include "parser-defs.h"
#include "osabi.h"
#include "infcall.h"
#include "sim-regno.h"
#include "gdb/sim-ppc.h"
#include "reggroups.h"
#include "dwarf2-frame.h"
#include "target-descriptions.h"
#include "user-regs.h"

#include "libbfd.h"		/* for bfd_default_set_arch_mach */
#include "coff/internal.h"	/* for libcoff.h */
#include "libcoff.h"		/* for xcoff_data */
#include "coff/xcoff.h"
#include "libxcoff.h"

#include "elf-bfd.h"
#include "elf/ppc.h"

#include "solib-svr4.h"
#include "ppc-tdep.h"
#include "ppc-ravenscar-thread.h"

#include "gdb_assert.h"
#include "dis-asm.h"

#include "trad-frame.h"
#include "frame-unwind.h"
#include "frame-base.h"

#include "features/rs6000/powerpc-32.c"
#include "features/rs6000/powerpc-altivec32.c"
#include "features/rs6000/powerpc-vsx32.c"
#include "features/rs6000/powerpc-403.c"
#include "features/rs6000/powerpc-403gc.c"
#include "features/rs6000/powerpc-405.c"
#include "features/rs6000/powerpc-505.c"
#include "features/rs6000/powerpc-601.c"
#include "features/rs6000/powerpc-602.c"
#include "features/rs6000/powerpc-603.c"
#include "features/rs6000/powerpc-604.c"
#include "features/rs6000/powerpc-64.c"
#include "features/rs6000/powerpc-altivec64.c"
#include "features/rs6000/powerpc-vsx64.c"
#include "features/rs6000/powerpc-7400.c"
#include "features/rs6000/powerpc-750.c"
#include "features/rs6000/powerpc-860.c"
#include "features/rs6000/powerpc-e500.c"
#include "features/rs6000/rs6000.c"

/* Determine if regnum is an SPE pseudo-register.  */
#define IS_SPE_PSEUDOREG(tdep, regnum) ((tdep)->ppc_ev0_regnum >= 0 \
    && (regnum) >= (tdep)->ppc_ev0_regnum \
    && (regnum) < (tdep)->ppc_ev0_regnum + 32)

/* Determine if regnum is a decimal float pseudo-register.  */
#define IS_DFP_PSEUDOREG(tdep, regnum) ((tdep)->ppc_dl0_regnum >= 0 \
    && (regnum) >= (tdep)->ppc_dl0_regnum \
    && (regnum) < (tdep)->ppc_dl0_regnum + 16)

/* Determine if regnum is a POWER7 VSX register.  */
#define IS_VSX_PSEUDOREG(tdep, regnum) ((tdep)->ppc_vsr0_regnum >= 0 \
    && (regnum) >= (tdep)->ppc_vsr0_regnum \
    && (regnum) < (tdep)->ppc_vsr0_regnum + ppc_num_vsrs)

/* Determine if regnum is a POWER7 Extended FP register.  */
#define IS_EFP_PSEUDOREG(tdep, regnum) ((tdep)->ppc_efpr0_regnum >= 0 \
    && (regnum) >= (tdep)->ppc_efpr0_regnum \
    && (regnum) < (tdep)->ppc_efpr0_regnum + ppc_num_efprs)

/* The list of available "set powerpc ..." and "show powerpc ..."
   commands.  */
static struct cmd_list_element *setpowerpccmdlist = NULL;
static struct cmd_list_element *showpowerpccmdlist = NULL;

static enum auto_boolean powerpc_soft_float_global = AUTO_BOOLEAN_AUTO;

/* The vector ABI to use.  Keep this in sync with powerpc_vector_abi.  */
static const char *const powerpc_vector_strings[] =
{
  "auto",
  "generic",
  "altivec",
  "spe",
  NULL
};

/* A variable that can be configured by the user.  */
static enum powerpc_vector_abi powerpc_vector_abi_global = POWERPC_VEC_AUTO;
static const char *powerpc_vector_abi_string = "auto";

/* To be used by skip_prologue.  */

struct rs6000_framedata
  {
    int offset;			/* total size of frame --- the distance
				   by which we decrement sp to allocate
				   the frame */
    int saved_gpr;		/* smallest # of saved gpr */
    unsigned int gpr_mask;	/* Each bit is an individual saved GPR.  */
    int saved_fpr;		/* smallest # of saved fpr */
    int saved_vr;               /* smallest # of saved vr */
    int saved_ev;               /* smallest # of saved ev */
    int alloca_reg;		/* alloca register number (frame ptr) */
    char frameless;		/* true if frameless functions.  */
    char nosavedpc;		/* true if pc not saved.  */
    char used_bl;		/* true if link register clobbered */
    int gpr_offset;		/* offset of saved gprs from prev sp */
    int fpr_offset;		/* offset of saved fprs from prev sp */
    int vr_offset;              /* offset of saved vrs from prev sp */
    int ev_offset;              /* offset of saved evs from prev sp */
    int lr_offset;		/* offset of saved lr */
    int lr_register;		/* register of saved lr, if trustworthy */
    int cr_offset;		/* offset of saved cr */
    int vrsave_offset;          /* offset of saved vrsave register */
  };


/* Is REGNO a VSX register? Return 1 if so, 0 otherwise.  */
int
vsx_register_p (struct gdbarch *gdbarch, int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  if (tdep->ppc_vsr0_regnum < 0)
    return 0;
  else
    return (regno >= tdep->ppc_vsr0_upper_regnum && regno
	    <= tdep->ppc_vsr0_upper_regnum + 31);
}

/* Is REGNO an AltiVec register?  Return 1 if so, 0 otherwise.  */
int
altivec_register_p (struct gdbarch *gdbarch, int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  if (tdep->ppc_vr0_regnum < 0 || tdep->ppc_vrsave_regnum < 0)
    return 0;
  else
    return (regno >= tdep->ppc_vr0_regnum && regno <= tdep->ppc_vrsave_regnum);
}


/* Return true if REGNO is an SPE register, false otherwise.  */
int
spe_register_p (struct gdbarch *gdbarch, int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  
  /* Is it a reference to EV0 -- EV31, and do we have those?  */
  if (IS_SPE_PSEUDOREG (tdep, regno))
    return 1;

  /* Is it a reference to one of the raw upper GPR halves?  */
  if (tdep->ppc_ev0_upper_regnum >= 0
      && tdep->ppc_ev0_upper_regnum <= regno
      && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    return 1;

  /* Is it a reference to the 64-bit accumulator, and do we have that?  */
  if (tdep->ppc_acc_regnum >= 0
      && tdep->ppc_acc_regnum == regno)
    return 1;

  /* Is it a reference to the SPE floating-point status and control register,
     and do we have that?  */
  if (tdep->ppc_spefscr_regnum >= 0
      && tdep->ppc_spefscr_regnum == regno)
    return 1;

  return 0;
}


/* Return non-zero if the architecture described by GDBARCH has
   floating-point registers (f0 --- f31 and fpscr).  */
int
ppc_floating_point_unit_p (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  return (tdep->ppc_fp0_regnum >= 0
          && tdep->ppc_fpscr_regnum >= 0);
}

/* Return non-zero if the architecture described by GDBARCH has
   VSX registers (vsr0 --- vsr63).  */
static int
ppc_vsx_support_p (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  return tdep->ppc_vsr0_regnum >= 0;
}

/* Return non-zero if the architecture described by GDBARCH has
   Altivec registers (vr0 --- vr31, vrsave and vscr).  */
int
ppc_altivec_support_p (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  return (tdep->ppc_vr0_regnum >= 0
          && tdep->ppc_vrsave_regnum >= 0);
}

/* Check that TABLE[GDB_REGNO] is not already initialized, and then
   set it to SIM_REGNO.

   This is a helper function for init_sim_regno_table, constructing
   the table mapping GDB register numbers to sim register numbers; we
   initialize every element in that table to -1 before we start
   filling it in.  */
static void
set_sim_regno (int *table, int gdb_regno, int sim_regno)
{
  /* Make sure we don't try to assign any given GDB register a sim
     register number more than once.  */
  gdb_assert (table[gdb_regno] == -1);
  table[gdb_regno] = sim_regno;
}


/* Initialize ARCH->tdep->sim_regno, the table mapping GDB register
   numbers to simulator register numbers, based on the values placed
   in the ARCH->tdep->ppc_foo_regnum members.  */
static void
init_sim_regno_table (struct gdbarch *arch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
  int total_regs = gdbarch_num_regs (arch);
  int *sim_regno = GDBARCH_OBSTACK_CALLOC (arch, total_regs, int);
  int i;
  static const char *const segment_regs[] = {
    "sr0", "sr1", "sr2", "sr3", "sr4", "sr5", "sr6", "sr7",
    "sr8", "sr9", "sr10", "sr11", "sr12", "sr13", "sr14", "sr15"
  };

  /* Presume that all registers not explicitly mentioned below are
     unavailable from the sim.  */
  for (i = 0; i < total_regs; i++)
    sim_regno[i] = -1;

  /* General-purpose registers.  */
  for (i = 0; i < ppc_num_gprs; i++)
    set_sim_regno (sim_regno, tdep->ppc_gp0_regnum + i, sim_ppc_r0_regnum + i);
  
  /* Floating-point registers.  */
  if (tdep->ppc_fp0_regnum >= 0)
    for (i = 0; i < ppc_num_fprs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_fp0_regnum + i,
                     sim_ppc_f0_regnum + i);
  if (tdep->ppc_fpscr_regnum >= 0)
    set_sim_regno (sim_regno, tdep->ppc_fpscr_regnum, sim_ppc_fpscr_regnum);

  set_sim_regno (sim_regno, gdbarch_pc_regnum (arch), sim_ppc_pc_regnum);
  set_sim_regno (sim_regno, tdep->ppc_ps_regnum, sim_ppc_ps_regnum);
  set_sim_regno (sim_regno, tdep->ppc_cr_regnum, sim_ppc_cr_regnum);

  /* Segment registers.  */
  for (i = 0; i < ppc_num_srs; i++)
    {
      int gdb_regno;

      gdb_regno = user_reg_map_name_to_regnum (arch, segment_regs[i], -1);
      if (gdb_regno >= 0)
	set_sim_regno (sim_regno, gdb_regno, sim_ppc_sr0_regnum + i);
    }

  /* Altivec registers.  */
  if (tdep->ppc_vr0_regnum >= 0)
    {
      for (i = 0; i < ppc_num_vrs; i++)
        set_sim_regno (sim_regno,
                       tdep->ppc_vr0_regnum + i,
                       sim_ppc_vr0_regnum + i);

      /* FIXME: jimb/2004-07-15: when we have tdep->ppc_vscr_regnum,
         we can treat this more like the other cases.  */
      set_sim_regno (sim_regno,
                     tdep->ppc_vr0_regnum + ppc_num_vrs,
                     sim_ppc_vscr_regnum);
    }
  /* vsave is a special-purpose register, so the code below handles it.  */

  /* SPE APU (E500) registers.  */
  if (tdep->ppc_ev0_upper_regnum >= 0)
    for (i = 0; i < ppc_num_gprs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_ev0_upper_regnum + i,
                     sim_ppc_rh0_regnum + i);
  if (tdep->ppc_acc_regnum >= 0)
    set_sim_regno (sim_regno, tdep->ppc_acc_regnum, sim_ppc_acc_regnum);
  /* spefscr is a special-purpose register, so the code below handles it.  */

#ifdef WITH_SIM
  /* Now handle all special-purpose registers.  Verify that they
     haven't mistakenly been assigned numbers by any of the above
     code.  */
  for (i = 0; i < sim_ppc_num_sprs; i++)
    {
      const char *spr_name = sim_spr_register_name (i);
      int gdb_regno = -1;

      if (spr_name != NULL)
	gdb_regno = user_reg_map_name_to_regnum (arch, spr_name, -1);

      if (gdb_regno != -1)
	set_sim_regno (sim_regno, gdb_regno, sim_ppc_spr0_regnum + i);
    }
#endif

  /* Drop the initialized array into place.  */
  tdep->sim_regno = sim_regno;
}


/* Given a GDB register number REG, return the corresponding SIM
   register number.  */
static int
rs6000_register_sim_regno (struct gdbarch *gdbarch, int reg)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int sim_regno;

  if (tdep->sim_regno == NULL)
    init_sim_regno_table (gdbarch);

  gdb_assert (0 <= reg 
	      && reg <= gdbarch_num_regs (gdbarch)
			+ gdbarch_num_pseudo_regs (gdbarch));
  sim_regno = tdep->sim_regno[reg];

  if (sim_regno >= 0)
    return sim_regno;
  else
    return LEGACY_SIM_REGNO_IGNORE;
}



/* Register set support functions.  */

/* REGS + OFFSET contains register REGNUM in a field REGSIZE wide.
   Write the register to REGCACHE.  */

void
ppc_supply_reg (struct regcache *regcache, int regnum, 
		const gdb_byte *regs, size_t offset, int regsize)
{
  if (regnum != -1 && offset != -1)
    {
      if (regsize > 4)
	{
	  struct gdbarch *gdbarch = get_regcache_arch (regcache);
	  int gdb_regsize = register_size (gdbarch, regnum);
	  if (gdb_regsize < regsize
	      && gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	    offset += regsize - gdb_regsize;
	}
      regcache_raw_supply (regcache, regnum, regs + offset);
    }
}

/* Read register REGNUM from REGCACHE and store to REGS + OFFSET
   in a field REGSIZE wide.  Zero pad as necessary.  */

void
ppc_collect_reg (const struct regcache *regcache, int regnum,
		 gdb_byte *regs, size_t offset, int regsize)
{
  if (regnum != -1 && offset != -1)
    {
      if (regsize > 4)
	{
	  struct gdbarch *gdbarch = get_regcache_arch (regcache);
	  int gdb_regsize = register_size (gdbarch, regnum);
	  if (gdb_regsize < regsize)
	    {
	      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
		{
		  memset (regs + offset, 0, regsize - gdb_regsize);
		  offset += regsize - gdb_regsize;
		}
	      else
		memset (regs + offset + regsize - gdb_regsize, 0,
			regsize - gdb_regsize);
	    }
	}
      regcache_raw_collect (regcache, regnum, regs + offset);
    }
}
    
static int
ppc_greg_offset (struct gdbarch *gdbarch,
		 struct gdbarch_tdep *tdep,
		 const struct ppc_reg_offsets *offsets,
		 int regnum,
		 int *regsize)
{
  *regsize = offsets->gpr_size;
  if (regnum >= tdep->ppc_gp0_regnum
      && regnum < tdep->ppc_gp0_regnum + ppc_num_gprs)
    return (offsets->r0_offset
	    + (regnum - tdep->ppc_gp0_regnum) * offsets->gpr_size);

  if (regnum == gdbarch_pc_regnum (gdbarch))
    return offsets->pc_offset;

  if (regnum == tdep->ppc_ps_regnum)
    return offsets->ps_offset;

  if (regnum == tdep->ppc_lr_regnum)
    return offsets->lr_offset;

  if (regnum == tdep->ppc_ctr_regnum)
    return offsets->ctr_offset;

  *regsize = offsets->xr_size;
  if (regnum == tdep->ppc_cr_regnum)
    return offsets->cr_offset;

  if (regnum == tdep->ppc_xer_regnum)
    return offsets->xer_offset;

  if (regnum == tdep->ppc_mq_regnum)
    return offsets->mq_offset;

  return -1;
}

static int
ppc_fpreg_offset (struct gdbarch_tdep *tdep,
		  const struct ppc_reg_offsets *offsets,
		  int regnum)
{
  if (regnum >= tdep->ppc_fp0_regnum
      && regnum < tdep->ppc_fp0_regnum + ppc_num_fprs)
    return offsets->f0_offset + (regnum - tdep->ppc_fp0_regnum) * 8;

  if (regnum == tdep->ppc_fpscr_regnum)
    return offsets->fpscr_offset;

  return -1;
}

static int
ppc_vrreg_offset (struct gdbarch_tdep *tdep,
		  const struct ppc_reg_offsets *offsets,
		  int regnum)
{
  if (regnum >= tdep->ppc_vr0_regnum
      && regnum < tdep->ppc_vr0_regnum + ppc_num_vrs)
    return offsets->vr0_offset + (regnum - tdep->ppc_vr0_regnum) * 16;

  if (regnum == tdep->ppc_vrsave_regnum - 1)
    return offsets->vscr_offset;

  if (regnum == tdep->ppc_vrsave_regnum)
    return offsets->vrsave_offset;

  return -1;
}

/* Supply register REGNUM in the general-purpose register set REGSET
   from the buffer specified by GREGS and LEN to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

void
ppc_supply_gregset (const struct regset *regset, struct regcache *regcache,
		    int regnum, const void *gregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct ppc_reg_offsets *offsets = regset->descr;
  size_t offset;
  int regsize;

  if (regnum == -1)
    {
      int i;
      int gpr_size = offsets->gpr_size;

      for (i = tdep->ppc_gp0_regnum, offset = offsets->r0_offset;
	   i < tdep->ppc_gp0_regnum + ppc_num_gprs;
	   i++, offset += gpr_size)
	ppc_supply_reg (regcache, i, gregs, offset, gpr_size);

      ppc_supply_reg (regcache, gdbarch_pc_regnum (gdbarch),
		      gregs, offsets->pc_offset, gpr_size);
      ppc_supply_reg (regcache, tdep->ppc_ps_regnum,
		      gregs, offsets->ps_offset, gpr_size);
      ppc_supply_reg (regcache, tdep->ppc_lr_regnum,
		      gregs, offsets->lr_offset, gpr_size);
      ppc_supply_reg (regcache, tdep->ppc_ctr_regnum,
		      gregs, offsets->ctr_offset, gpr_size);
      ppc_supply_reg (regcache, tdep->ppc_cr_regnum,
		      gregs, offsets->cr_offset, offsets->xr_size);
      ppc_supply_reg (regcache, tdep->ppc_xer_regnum,
		      gregs, offsets->xer_offset, offsets->xr_size);
      ppc_supply_reg (regcache, tdep->ppc_mq_regnum,
		      gregs, offsets->mq_offset, offsets->xr_size);
      return;
    }

  offset = ppc_greg_offset (gdbarch, tdep, offsets, regnum, &regsize);
  ppc_supply_reg (regcache, regnum, gregs, offset, regsize);
}

/* Supply register REGNUM in the floating-point register set REGSET
   from the buffer specified by FPREGS and LEN to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

void
ppc_supply_fpregset (const struct regset *regset, struct regcache *regcache,
		     int regnum, const void *fpregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep;
  const struct ppc_reg_offsets *offsets;
  size_t offset;

  if (!ppc_floating_point_unit_p (gdbarch))
    return;

  tdep = gdbarch_tdep (gdbarch);
  offsets = regset->descr;
  if (regnum == -1)
    {
      int i;

      for (i = tdep->ppc_fp0_regnum, offset = offsets->f0_offset;
	   i < tdep->ppc_fp0_regnum + ppc_num_fprs;
	   i++, offset += 8)
	ppc_supply_reg (regcache, i, fpregs, offset, 8);

      ppc_supply_reg (regcache, tdep->ppc_fpscr_regnum,
		      fpregs, offsets->fpscr_offset, offsets->fpscr_size);
      return;
    }

  offset = ppc_fpreg_offset (tdep, offsets, regnum);
  ppc_supply_reg (regcache, regnum, fpregs, offset,
		  regnum == tdep->ppc_fpscr_regnum ? offsets->fpscr_size : 8);
}

/* Supply register REGNUM in the VSX register set REGSET
   from the buffer specified by VSXREGS and LEN to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

void
ppc_supply_vsxregset (const struct regset *regset, struct regcache *regcache,
		     int regnum, const void *vsxregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep;

  if (!ppc_vsx_support_p (gdbarch))
    return;

  tdep = gdbarch_tdep (gdbarch);

  if (regnum == -1)
    {
      int i;

      for (i = tdep->ppc_vsr0_upper_regnum;
	   i < tdep->ppc_vsr0_upper_regnum + 32;
	   i++)
	ppc_supply_reg (regcache, i, vsxregs, 0, 8);

      return;
    }
  else
    ppc_supply_reg (regcache, regnum, vsxregs, 0, 8);
}

/* Supply register REGNUM in the Altivec register set REGSET
   from the buffer specified by VRREGS and LEN to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

void
ppc_supply_vrregset (const struct regset *regset, struct regcache *regcache,
		     int regnum, const void *vrregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep;
  const struct ppc_reg_offsets *offsets;
  size_t offset;

  if (!ppc_altivec_support_p (gdbarch))
    return;

  tdep = gdbarch_tdep (gdbarch);
  offsets = regset->descr;
  if (regnum == -1)
    {
      int i;

      for (i = tdep->ppc_vr0_regnum, offset = offsets->vr0_offset;
	   i < tdep->ppc_vr0_regnum + ppc_num_vrs;
	   i++, offset += 16)
        ppc_supply_reg (regcache, i, vrregs, offset, 16);

      ppc_supply_reg (regcache, (tdep->ppc_vrsave_regnum - 1),
		      vrregs, offsets->vscr_offset, 4);

      ppc_supply_reg (regcache, tdep->ppc_vrsave_regnum,
		      vrregs, offsets->vrsave_offset, 4);
      return;
    }

  offset = ppc_vrreg_offset (tdep, offsets, regnum);
  if (regnum != tdep->ppc_vrsave_regnum
      && regnum != tdep->ppc_vrsave_regnum - 1)
    ppc_supply_reg (regcache, regnum, vrregs, offset, 16);
  else
    ppc_supply_reg (regcache, regnum,
		    vrregs, offset, 4);
}

/* Collect register REGNUM in the general-purpose register set
   REGSET from register cache REGCACHE into the buffer specified by
   GREGS and LEN.  If REGNUM is -1, do this for all registers in
   REGSET.  */

void
ppc_collect_gregset (const struct regset *regset,
		     const struct regcache *regcache,
		     int regnum, void *gregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct ppc_reg_offsets *offsets = regset->descr;
  size_t offset;
  int regsize;

  if (regnum == -1)
    {
      int i;
      int gpr_size = offsets->gpr_size;

      for (i = tdep->ppc_gp0_regnum, offset = offsets->r0_offset;
	   i < tdep->ppc_gp0_regnum + ppc_num_gprs;
	   i++, offset += gpr_size)
	ppc_collect_reg (regcache, i, gregs, offset, gpr_size);

      ppc_collect_reg (regcache, gdbarch_pc_regnum (gdbarch),
		       gregs, offsets->pc_offset, gpr_size);
      ppc_collect_reg (regcache, tdep->ppc_ps_regnum,
		       gregs, offsets->ps_offset, gpr_size);
      ppc_collect_reg (regcache, tdep->ppc_lr_regnum,
		       gregs, offsets->lr_offset, gpr_size);
      ppc_collect_reg (regcache, tdep->ppc_ctr_regnum,
		       gregs, offsets->ctr_offset, gpr_size);
      ppc_collect_reg (regcache, tdep->ppc_cr_regnum,
		       gregs, offsets->cr_offset, offsets->xr_size);
      ppc_collect_reg (regcache, tdep->ppc_xer_regnum,
		       gregs, offsets->xer_offset, offsets->xr_size);
      ppc_collect_reg (regcache, tdep->ppc_mq_regnum,
		       gregs, offsets->mq_offset, offsets->xr_size);
      return;
    }

  offset = ppc_greg_offset (gdbarch, tdep, offsets, regnum, &regsize);
  ppc_collect_reg (regcache, regnum, gregs, offset, regsize);
}

/* Collect register REGNUM in the floating-point register set
   REGSET from register cache REGCACHE into the buffer specified by
   FPREGS and LEN.  If REGNUM is -1, do this for all registers in
   REGSET.  */

void
ppc_collect_fpregset (const struct regset *regset,
		      const struct regcache *regcache,
		      int regnum, void *fpregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep;
  const struct ppc_reg_offsets *offsets;
  size_t offset;

  if (!ppc_floating_point_unit_p (gdbarch))
    return;

  tdep = gdbarch_tdep (gdbarch);
  offsets = regset->descr;
  if (regnum == -1)
    {
      int i;

      for (i = tdep->ppc_fp0_regnum, offset = offsets->f0_offset;
	   i < tdep->ppc_fp0_regnum + ppc_num_fprs;
	   i++, offset += 8)
	ppc_collect_reg (regcache, i, fpregs, offset, 8);

      ppc_collect_reg (regcache, tdep->ppc_fpscr_regnum,
		       fpregs, offsets->fpscr_offset, offsets->fpscr_size);
      return;
    }

  offset = ppc_fpreg_offset (tdep, offsets, regnum);
  ppc_collect_reg (regcache, regnum, fpregs, offset,
		   regnum == tdep->ppc_fpscr_regnum ? offsets->fpscr_size : 8);
}

/* Collect register REGNUM in the VSX register set
   REGSET from register cache REGCACHE into the buffer specified by
   VSXREGS and LEN.  If REGNUM is -1, do this for all registers in
   REGSET.  */

void
ppc_collect_vsxregset (const struct regset *regset,
		      const struct regcache *regcache,
		      int regnum, void *vsxregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep;

  if (!ppc_vsx_support_p (gdbarch))
    return;

  tdep = gdbarch_tdep (gdbarch);

  if (regnum == -1)
    {
      int i;

      for (i = tdep->ppc_vsr0_upper_regnum;
	   i < tdep->ppc_vsr0_upper_regnum + 32;
	   i++)
	ppc_collect_reg (regcache, i, vsxregs, 0, 8);

      return;
    }
  else
    ppc_collect_reg (regcache, regnum, vsxregs, 0, 8);
}


/* Collect register REGNUM in the Altivec register set
   REGSET from register cache REGCACHE into the buffer specified by
   VRREGS and LEN.  If REGNUM is -1, do this for all registers in
   REGSET.  */

void
ppc_collect_vrregset (const struct regset *regset,
		      const struct regcache *regcache,
		      int regnum, void *vrregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep;
  const struct ppc_reg_offsets *offsets;
  size_t offset;

  if (!ppc_altivec_support_p (gdbarch))
    return;

  tdep = gdbarch_tdep (gdbarch);
  offsets = regset->descr;
  if (regnum == -1)
    {
      int i;

      for (i = tdep->ppc_vr0_regnum, offset = offsets->vr0_offset;
	   i < tdep->ppc_vr0_regnum + ppc_num_vrs;
	   i++, offset += 16)
	ppc_collect_reg (regcache, i, vrregs, offset, 16);

      ppc_collect_reg (regcache, (tdep->ppc_vrsave_regnum - 1),
		       vrregs, offsets->vscr_offset, 4);

      ppc_collect_reg (regcache, tdep->ppc_vrsave_regnum,
		       vrregs, offsets->vrsave_offset, 4);
      return;
    }

  offset = ppc_vrreg_offset (tdep, offsets, regnum);
  if (regnum != tdep->ppc_vrsave_regnum
      && regnum != tdep->ppc_vrsave_regnum - 1)
    ppc_collect_reg (regcache, regnum, vrregs, offset, 16);
  else
    ppc_collect_reg (regcache, regnum,
		    vrregs, offset, 4);
}


static int
insn_changes_sp_or_jumps (unsigned long insn)
{
  int opcode = (insn >> 26) & 0x03f;
  int sd = (insn >> 21) & 0x01f;
  int a = (insn >> 16) & 0x01f;
  int subcode = (insn >> 1) & 0x3ff;

  /* Changes the stack pointer.  */

  /* NOTE: There are many ways to change the value of a given register.
           The ways below are those used when the register is R1, the SP,
           in a funtion's epilogue.  */

  if (opcode == 31 && subcode == 444 && a == 1)
    return 1;  /* mr R1,Rn */
  if (opcode == 14 && sd == 1)
    return 1;  /* addi R1,Rn,simm */
  if (opcode == 58 && sd == 1)
    return 1;  /* ld R1,ds(Rn) */

  /* Transfers control.  */

  if (opcode == 18)
    return 1;  /* b */
  if (opcode == 16)
    return 1;  /* bc */
  if (opcode == 19 && subcode == 16)
    return 1;  /* bclr */
  if (opcode == 19 && subcode == 528)
    return 1;  /* bcctr */

  return 0;
}

/* Return true if we are in the function's epilogue, i.e. after the
   instruction that destroyed the function's stack frame.

   1) scan forward from the point of execution:
       a) If you find an instruction that modifies the stack pointer
          or transfers control (except a return), execution is not in
          an epilogue, return.
       b) Stop scanning if you find a return instruction or reach the
          end of the function or reach the hard limit for the size of
          an epilogue.
   2) scan backward from the point of execution:
        a) If you find an instruction that modifies the stack pointer,
            execution *is* in an epilogue, return.
        b) Stop scanning if you reach an instruction that transfers
           control or the beginning of the function or reach the hard
           limit for the size of an epilogue.  */

static int
rs6000_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  bfd_byte insn_buf[PPC_INSN_SIZE];
  CORE_ADDR scan_pc, func_start, func_end, epilogue_start, epilogue_end;
  unsigned long insn;
  struct frame_info *curfrm;

  /* Find the search limits based on function boundaries and hard limit.  */

  if (!find_pc_partial_function (pc, NULL, &func_start, &func_end))
    return 0;

  epilogue_start = pc - PPC_MAX_EPILOGUE_INSTRUCTIONS * PPC_INSN_SIZE;
  if (epilogue_start < func_start) epilogue_start = func_start;

  epilogue_end = pc + PPC_MAX_EPILOGUE_INSTRUCTIONS * PPC_INSN_SIZE;
  if (epilogue_end > func_end) epilogue_end = func_end;

  curfrm = get_current_frame ();

  /* Scan forward until next 'blr'.  */

  for (scan_pc = pc; scan_pc < epilogue_end; scan_pc += PPC_INSN_SIZE)
    {
      if (!safe_frame_unwind_memory (curfrm, scan_pc, insn_buf, PPC_INSN_SIZE))
        return 0;
      insn = extract_unsigned_integer (insn_buf, PPC_INSN_SIZE, byte_order);
      if (insn == 0x4e800020)
        break;
      /* Assume a bctr is a tail call unless it points strictly within
	 this function.  */
      if (insn == 0x4e800420)
	{
	  CORE_ADDR ctr = get_frame_register_unsigned (curfrm,
						       tdep->ppc_ctr_regnum);
	  if (ctr > func_start && ctr < func_end)
	    return 0;
	  else
	    break;
	}
      if (insn_changes_sp_or_jumps (insn))
        return 0;
    }

  /* Scan backward until adjustment to stack pointer (R1).  */

  for (scan_pc = pc - PPC_INSN_SIZE;
       scan_pc >= epilogue_start;
       scan_pc -= PPC_INSN_SIZE)
    {
      if (!safe_frame_unwind_memory (curfrm, scan_pc, insn_buf, PPC_INSN_SIZE))
        return 0;
      insn = extract_unsigned_integer (insn_buf, PPC_INSN_SIZE, byte_order);
      if (insn_changes_sp_or_jumps (insn))
        return 1;
    }

  return 0;
}

/* Get the ith function argument for the current function.  */
static CORE_ADDR
rs6000_fetch_pointer_argument (struct frame_info *frame, int argi, 
			       struct type *type)
{
  return get_frame_register_unsigned (frame, 3 + argi);
}

/* Sequence of bytes for breakpoint instruction.  */

static const unsigned char *
rs6000_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *bp_addr,
			   int *bp_size)
{
  static unsigned char big_breakpoint[] = { 0x7d, 0x82, 0x10, 0x08 };
  static unsigned char little_breakpoint[] = { 0x08, 0x10, 0x82, 0x7d };
  *bp_size = 4;
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    return big_breakpoint;
  else
    return little_breakpoint;
}

/* Instruction masks for displaced stepping.  */
#define BRANCH_MASK 0xfc000000
#define BP_MASK 0xFC0007FE
#define B_INSN 0x48000000
#define BC_INSN 0x40000000
#define BXL_INSN 0x4c000000
#define BP_INSN 0x7C000008

/* Fix up the state of registers and memory after having single-stepped
   a displaced instruction.  */
static void
ppc_displaced_step_fixup (struct gdbarch *gdbarch,
			  struct displaced_step_closure *closure,
			  CORE_ADDR from, CORE_ADDR to,
			  struct regcache *regs)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  /* Since we use simple_displaced_step_copy_insn, our closure is a
     copy of the instruction.  */
  ULONGEST insn  = extract_unsigned_integer ((gdb_byte *) closure,
					      PPC_INSN_SIZE, byte_order);
  ULONGEST opcode = 0;
  /* Offset for non PC-relative instructions.  */
  LONGEST offset = PPC_INSN_SIZE;

  opcode = insn & BRANCH_MASK;

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: (ppc) fixup (%s, %s)\n",
			paddress (gdbarch, from), paddress (gdbarch, to));


  /* Handle PC-relative branch instructions.  */
  if (opcode == B_INSN || opcode == BC_INSN || opcode == BXL_INSN)
    {
      ULONGEST current_pc;

      /* Read the current PC value after the instruction has been executed
	 in a displaced location.  Calculate the offset to be applied to the
	 original PC value before the displaced stepping.  */
      regcache_cooked_read_unsigned (regs, gdbarch_pc_regnum (gdbarch),
				      &current_pc);
      offset = current_pc - to;

      if (opcode != BXL_INSN)
	{
	  /* Check for AA bit indicating whether this is an absolute
	     addressing or PC-relative (1: absolute, 0: relative).  */
	  if (!(insn & 0x2))
	    {
	      /* PC-relative addressing is being used in the branch.  */
	      if (debug_displaced)
		fprintf_unfiltered
		  (gdb_stdlog,
		   "displaced: (ppc) branch instruction: %s\n"
		   "displaced: (ppc) adjusted PC from %s to %s\n",
		   paddress (gdbarch, insn), paddress (gdbarch, current_pc),
		   paddress (gdbarch, from + offset));

	      regcache_cooked_write_unsigned (regs,
					      gdbarch_pc_regnum (gdbarch),
					      from + offset);
	    }
	}
      else
	{
	  /* If we're here, it means we have a branch to LR or CTR.  If the
	     branch was taken, the offset is probably greater than 4 (the next
	     instruction), so it's safe to assume that an offset of 4 means we
	     did not take the branch.  */
	  if (offset == PPC_INSN_SIZE)
	    regcache_cooked_write_unsigned (regs, gdbarch_pc_regnum (gdbarch),
					    from + PPC_INSN_SIZE);
	}

      /* Check for LK bit indicating whether we should set the link
	 register to point to the next instruction
	 (1: Set, 0: Don't set).  */
      if (insn & 0x1)
	{
	  /* Link register needs to be set to the next instruction's PC.  */
	  regcache_cooked_write_unsigned (regs,
					  gdbarch_tdep (gdbarch)->ppc_lr_regnum,
					  from + PPC_INSN_SIZE);
	  if (debug_displaced)
		fprintf_unfiltered (gdb_stdlog,
				    "displaced: (ppc) adjusted LR to %s\n",
				    paddress (gdbarch, from + PPC_INSN_SIZE));

	}
    }
  /* Check for breakpoints in the inferior.  If we've found one, place the PC
     right at the breakpoint instruction.  */
  else if ((insn & BP_MASK) == BP_INSN)
    regcache_cooked_write_unsigned (regs, gdbarch_pc_regnum (gdbarch), from);
  else
  /* Handle any other instructions that do not fit in the categories above.  */
    regcache_cooked_write_unsigned (regs, gdbarch_pc_regnum (gdbarch),
				    from + offset);
}

/* Always use hardware single-stepping to execute the
   displaced instruction.  */
static int
ppc_displaced_step_hw_singlestep (struct gdbarch *gdbarch,
				  struct displaced_step_closure *closure)
{
  return 1;
}

/* Instruction masks used during single-stepping of atomic sequences.  */
#define LWARX_MASK 0xfc0007fe
#define LWARX_INSTRUCTION 0x7c000028
#define LDARX_INSTRUCTION 0x7c0000A8
#define STWCX_MASK 0xfc0007ff
#define STWCX_INSTRUCTION 0x7c00012d
#define STDCX_INSTRUCTION 0x7c0001ad

/* Checks for an atomic sequence of instructions beginning with a LWARX/LDARX
   instruction and ending with a STWCX/STDCX instruction.  If such a sequence
   is found, attempt to step through it.  A breakpoint is placed at the end of 
   the sequence.  */

int 
ppc_deal_with_atomic_sequence (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct address_space *aspace = get_frame_address_space (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR pc = get_frame_pc (frame);
  CORE_ADDR breaks[2] = {-1, -1};
  CORE_ADDR loc = pc;
  CORE_ADDR closing_insn; /* Instruction that closes the atomic sequence.  */
  int insn = read_memory_integer (loc, PPC_INSN_SIZE, byte_order);
  int insn_count;
  int index;
  int last_breakpoint = 0; /* Defaults to 0 (no breakpoints placed).  */  
  const int atomic_sequence_length = 16; /* Instruction sequence length.  */
  int opcode; /* Branch instruction's OPcode.  */
  int bc_insn_count = 0; /* Conditional branch instruction count.  */

  /* Assume all atomic sequences start with a lwarx/ldarx instruction.  */
  if ((insn & LWARX_MASK) != LWARX_INSTRUCTION
      && (insn & LWARX_MASK) != LDARX_INSTRUCTION)
    return 0;

  /* Assume that no atomic sequence is longer than "atomic_sequence_length" 
     instructions.  */
  for (insn_count = 0; insn_count < atomic_sequence_length; ++insn_count)
    {
      loc += PPC_INSN_SIZE;
      insn = read_memory_integer (loc, PPC_INSN_SIZE, byte_order);

      /* Assume that there is at most one conditional branch in the atomic
         sequence.  If a conditional branch is found, put a breakpoint in 
         its destination address.  */
      if ((insn & BRANCH_MASK) == BC_INSN)
        {
          int immediate = ((insn & 0xfffc) ^ 0x8000) - 0x8000;
          int absolute = insn & 2;

          if (bc_insn_count >= 1)
            return 0; /* More than one conditional branch found, fallback 
                         to the standard single-step code.  */
 
	  if (absolute)
	    breaks[1] = immediate;
	  else
	    breaks[1] = loc + immediate;

	  bc_insn_count++;
	  last_breakpoint++;
        }

      if ((insn & STWCX_MASK) == STWCX_INSTRUCTION
          || (insn & STWCX_MASK) == STDCX_INSTRUCTION)
        break;
    }

  /* Assume that the atomic sequence ends with a stwcx/stdcx instruction.  */
  if ((insn & STWCX_MASK) != STWCX_INSTRUCTION
      && (insn & STWCX_MASK) != STDCX_INSTRUCTION)
    return 0;

  closing_insn = loc;
  loc += PPC_INSN_SIZE;
  insn = read_memory_integer (loc, PPC_INSN_SIZE, byte_order);

  /* Insert a breakpoint right after the end of the atomic sequence.  */
  breaks[0] = loc;

  /* Check for duplicated breakpoints.  Check also for a breakpoint
     placed (branch instruction's destination) anywhere in sequence.  */
  if (last_breakpoint
      && (breaks[1] == breaks[0]
	  || (breaks[1] >= pc && breaks[1] <= closing_insn)))
    last_breakpoint = 0;

  /* Effectively inserts the breakpoints.  */
  for (index = 0; index <= last_breakpoint; index++)
    insert_single_step_breakpoint (gdbarch, aspace, breaks[index]);

  return 1;
}


#define SIGNED_SHORT(x) 						\
  ((sizeof (short) == 2)						\
   ? ((int)(short)(x))							\
   : ((int)((((x) & 0xffff) ^ 0x8000) - 0x8000)))

#define GET_SRC_REG(x) (((x) >> 21) & 0x1f)

/* Limit the number of skipped non-prologue instructions, as the examining
   of the prologue is expensive.  */
static int max_skip_non_prologue_insns = 10;

/* Return nonzero if the given instruction OP can be part of the prologue
   of a function and saves a parameter on the stack.  FRAMEP should be
   set if one of the previous instructions in the function has set the
   Frame Pointer.  */

static int
store_param_on_stack_p (unsigned long op, int framep, int *r0_contains_arg)
{
  /* Move parameters from argument registers to temporary register.  */
  if ((op & 0xfc0007fe) == 0x7c000378)         /* mr(.)  Rx,Ry */
    {
      /* Rx must be scratch register r0.  */
      const int rx_regno = (op >> 16) & 31;
      /* Ry: Only r3 - r10 are used for parameter passing.  */
      const int ry_regno = GET_SRC_REG (op);

      if (rx_regno == 0 && ry_regno >= 3 && ry_regno <= 10)
        {
          *r0_contains_arg = 1;
          return 1;
        }
      else
        return 0;
    }

  /* Save a General Purpose Register on stack.  */

  if ((op & 0xfc1f0003) == 0xf8010000 ||       /* std  Rx,NUM(r1) */
      (op & 0xfc1f0000) == 0xd8010000)         /* stfd Rx,NUM(r1) */
    {
      /* Rx: Only r3 - r10 are used for parameter passing.  */
      const int rx_regno = GET_SRC_REG (op);

      return (rx_regno >= 3 && rx_regno <= 10);
    }
           
  /* Save a General Purpose Register on stack via the Frame Pointer.  */

  if (framep &&
      ((op & 0xfc1f0000) == 0x901f0000 ||     /* st rx,NUM(r31) */
       (op & 0xfc1f0000) == 0x981f0000 ||     /* stb Rx,NUM(r31) */
       (op & 0xfc1f0000) == 0xd81f0000))      /* stfd Rx,NUM(r31) */
    {
      /* Rx: Usually, only r3 - r10 are used for parameter passing.
         However, the compiler sometimes uses r0 to hold an argument.  */
      const int rx_regno = GET_SRC_REG (op);

      return ((rx_regno >= 3 && rx_regno <= 10)
              || (rx_regno == 0 && *r0_contains_arg));
    }

  if ((op & 0xfc1f0000) == 0xfc010000)         /* frsp, fp?,NUM(r1) */
    {
      /* Only f2 - f8 are used for parameter passing.  */
      const int src_regno = GET_SRC_REG (op);

      return (src_regno >= 2 && src_regno <= 8);
    }

  if (framep && ((op & 0xfc1f0000) == 0xfc1f0000))  /* frsp, fp?,NUM(r31) */
    {
      /* Only f2 - f8 are used for parameter passing.  */
      const int src_regno = GET_SRC_REG (op);

      return (src_regno >= 2 && src_regno <= 8);
    }

  /* Not an insn that saves a parameter on stack.  */
  return 0;
}

/* Assuming that INSN is a "bl" instruction located at PC, return
   nonzero if the destination of the branch is a "blrl" instruction.
   
   This sequence is sometimes found in certain function prologues.
   It allows the function to load the LR register with a value that
   they can use to access PIC data using PC-relative offsets.  */

static int
bl_to_blrl_insn_p (CORE_ADDR pc, int insn, enum bfd_endian byte_order)
{
  CORE_ADDR dest;
  int immediate;
  int absolute;
  int dest_insn;

  absolute = (int) ((insn >> 1) & 1);
  immediate = ((insn & ~3) << 6) >> 6;
  if (absolute)
    dest = immediate;
  else
    dest = pc + immediate;

  dest_insn = read_memory_integer (dest, 4, byte_order);
  if ((dest_insn & 0xfc00ffff) == 0x4c000021) /* blrl */
    return 1;

  return 0;
}

/* Masks for decoding a branch-and-link (bl) instruction.

   BL_MASK and BL_INSTRUCTION are used in combination with each other.
   The former is anded with the opcode in question; if the result of
   this masking operation is equal to BL_INSTRUCTION, then the opcode in
   question is a ``bl'' instruction.
   
   BL_DISPLACMENT_MASK is anded with the opcode in order to extract
   the branch displacement.  */

#define BL_MASK 0xfc000001
#define BL_INSTRUCTION 0x48000001
#define BL_DISPLACEMENT_MASK 0x03fffffc

static unsigned long
rs6000_fetch_instruction (struct gdbarch *gdbarch, const CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  unsigned long op;

  /* Fetch the instruction and convert it to an integer.  */
  if (target_read_memory (pc, buf, 4))
    return 0;
  op = extract_unsigned_integer (buf, 4, byte_order);

  return op;
}

/* GCC generates several well-known sequences of instructions at the begining
   of each function prologue when compiling with -fstack-check.  If one of
   such sequences starts at START_PC, then return the address of the
   instruction immediately past this sequence.  Otherwise, return START_PC.  */
   
static CORE_ADDR
rs6000_skip_stack_check (struct gdbarch *gdbarch, const CORE_ADDR start_pc)
{
  CORE_ADDR pc = start_pc;
  unsigned long op = rs6000_fetch_instruction (gdbarch, pc);

  /* First possible sequence: A small number of probes.
         stw 0, -<some immediate>(1)
         [repeat this instruction any (small) number of times].  */
  
  if ((op & 0xffff0000) == 0x90010000)
    {
      while ((op & 0xffff0000) == 0x90010000)
        {
          pc = pc + 4;
          op = rs6000_fetch_instruction (gdbarch, pc);
        }
      return pc;
    }

  /* Second sequence: A probing loop.
         addi 12,1,-<some immediate>
         lis 0,-<some immediate>
         [possibly ori 0,0,<some immediate>]
         add 0,12,0
         cmpw 0,12,0
         beq 0,<disp>
         addi 12,12,-<some immediate>
         stw 0,0(12)
         b <disp>
         [possibly one last probe: stw 0,<some immediate>(12)].  */

  while (1)
    {
      /* addi 12,1,-<some immediate> */
      if ((op & 0xffff0000) != 0x39810000)
        break;

      /* lis 0,-<some immediate> */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if ((op & 0xffff0000) != 0x3c000000)
        break;

      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      /* [possibly ori 0,0,<some immediate>] */
      if ((op & 0xffff0000) == 0x60000000)
        {
          pc = pc + 4;
          op = rs6000_fetch_instruction (gdbarch, pc);
        }
      /* add 0,12,0 */
      if (op != 0x7c0c0214)
        break;

      /* cmpw 0,12,0 */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if (op != 0x7c0c0000)
        break;

      /* beq 0,<disp> */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if ((op & 0xff9f0001) != 0x41820000)
        break;

      /* addi 12,12,-<some immediate> */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if ((op & 0xffff0000) != 0x398c0000)
        break;

      /* stw 0,0(12) */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if (op != 0x900c0000)
        break;

      /* b <disp> */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if ((op & 0xfc000001) != 0x48000000)
        break;

      /* [possibly one last probe: stw 0,<some immediate>(12)].  */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if ((op & 0xffff0000) == 0x900c0000)
        {
          pc = pc + 4;
          op = rs6000_fetch_instruction (gdbarch, pc);
        }

      /* We found a valid stack-check sequence, return the new PC.  */
      return pc;
    }

  /* Third sequence: No probe; instead, a comparizon between the stack size
     limit (saved in a run-time global variable) and the current stack
     pointer:

        addi 0,1,-<some immediate>
        lis 12,__gnat_stack_limit@@ha
        lwz 12,__gnat_stack_limit@@l(12)
        twllt 0,12

     or, with a small variant in the case of a bigger stack frame:
        addis 0,1,<some immediate>
        addic 0,0,-<some immediate>
        lis 12,__gnat_stack_limit@@ha
        lwz 12,__gnat_stack_limit@@l(12)
        twllt 0,12
  */
  while (1)
    {
      /* addi 0,1,-<some immediate> */
      if ((op & 0xffff0000) != 0x38010000)
        {
          /* small stack frame variant not recognized; try the
             big stack frame variant: */

          /* addis 0,1,<some immediate> */
          if ((op & 0xffff0000) != 0x3c010000)
            break;

          /* addic 0,0,-<some immediate> */
          pc = pc + 4;
          op = rs6000_fetch_instruction (gdbarch, pc);
          if ((op & 0xffff0000) != 0x30000000)
            break;
        }

      /* lis 12,<some immediate> */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if ((op & 0xffff0000) != 0x3d800000)
        break;
      
      /* lwz 12,<some immediate>(12) */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if ((op & 0xffff0000) != 0x818c0000)
        break;

      /* twllt 0,12 */
      pc = pc + 4;
      op = rs6000_fetch_instruction (gdbarch, pc);
      if ((op & 0xfffffffe) != 0x7c406008)
        break;

      /* We found a valid stack-check sequence, return the new PC.  */
      return pc;
    }

  /* No stack check code in our prologue, return the start_pc.  */
  return start_pc;
}

/* return pc value after skipping a function prologue and also return
   information about a function frame.

   in struct rs6000_framedata fdata:
   - frameless is TRUE, if function does not have a frame.
   - nosavedpc is TRUE, if function does not save %pc value in its frame.
   - offset is the initial size of this stack frame --- the amount by
   which we decrement the sp to allocate the frame.
   - saved_gpr is the number of the first saved gpr.
   - saved_fpr is the number of the first saved fpr.
   - saved_vr is the number of the first saved vr.
   - saved_ev is the number of the first saved ev.
   - alloca_reg is the number of the register used for alloca() handling.
   Otherwise -1.
   - gpr_offset is the offset of the first saved gpr from the previous frame.
   - fpr_offset is the offset of the first saved fpr from the previous frame.
   - vr_offset is the offset of the first saved vr from the previous frame.
   - ev_offset is the offset of the first saved ev from the previous frame.
   - lr_offset is the offset of the saved lr
   - cr_offset is the offset of the saved cr
   - vrsave_offset is the offset of the saved vrsave register.  */

static CORE_ADDR
skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc, CORE_ADDR lim_pc,
	       struct rs6000_framedata *fdata)
{
  CORE_ADDR orig_pc = pc;
  CORE_ADDR last_prologue_pc = pc;
  CORE_ADDR li_found_pc = 0;
  gdb_byte buf[4];
  unsigned long op;
  long offset = 0;
  long vr_saved_offset = 0;
  int lr_reg = -1;
  int cr_reg = -1;
  int vr_reg = -1;
  int ev_reg = -1;
  long ev_offset = 0;
  int vrsave_reg = -1;
  int reg;
  int framep = 0;
  int minimal_toc_loaded = 0;
  int prev_insn_was_prologue_insn = 1;
  int num_skip_non_prologue_insns = 0;
  int r0_contains_arg = 0;
  const struct bfd_arch_info *arch_info = gdbarch_bfd_arch_info (gdbarch);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  memset (fdata, 0, sizeof (struct rs6000_framedata));
  fdata->saved_gpr = -1;
  fdata->saved_fpr = -1;
  fdata->saved_vr = -1;
  fdata->saved_ev = -1;
  fdata->alloca_reg = -1;
  fdata->frameless = 1;
  fdata->nosavedpc = 1;
  fdata->lr_register = -1;

  pc = rs6000_skip_stack_check (gdbarch, pc);
  if (pc >= lim_pc)
    pc = lim_pc;

  for (;; pc += 4)
    {
      /* Sometimes it isn't clear if an instruction is a prologue
         instruction or not.  When we encounter one of these ambiguous
	 cases, we'll set prev_insn_was_prologue_insn to 0 (false).
	 Otherwise, we'll assume that it really is a prologue instruction.  */
      if (prev_insn_was_prologue_insn)
	last_prologue_pc = pc;

      /* Stop scanning if we've hit the limit.  */
      if (pc >= lim_pc)
	break;

      prev_insn_was_prologue_insn = 1;

      /* Fetch the instruction and convert it to an integer.  */
      if (target_read_memory (pc, buf, 4))
	break;
      op = extract_unsigned_integer (buf, 4, byte_order);

      if ((op & 0xfc1fffff) == 0x7c0802a6)
	{			/* mflr Rx */
	  /* Since shared library / PIC code, which needs to get its
	     address at runtime, can appear to save more than one link
	     register vis:

	     *INDENT-OFF*
	     stwu r1,-304(r1)
	     mflr r3
	     bl 0xff570d0 (blrl)
	     stw r30,296(r1)
	     mflr r30
	     stw r31,300(r1)
	     stw r3,308(r1);
	     ...
	     *INDENT-ON*

	     remember just the first one, but skip over additional
	     ones.  */
	  if (lr_reg == -1)
	    lr_reg = (op & 0x03e00000) >> 21;
          if (lr_reg == 0)
            r0_contains_arg = 0;
	  continue;
	}
      else if ((op & 0xfc1fffff) == 0x7c000026)
	{			/* mfcr Rx */
	  cr_reg = (op & 0x03e00000);
          if (cr_reg == 0)
            r0_contains_arg = 0;
	  continue;

	}
      else if ((op & 0xfc1f0000) == 0xd8010000)
	{			/* stfd Rx,NUM(r1) */
	  reg = GET_SRC_REG (op);
	  if (fdata->saved_fpr == -1 || fdata->saved_fpr > reg)
	    {
	      fdata->saved_fpr = reg;
	      fdata->fpr_offset = SIGNED_SHORT (op) + offset;
	    }
	  continue;

	}
      else if (((op & 0xfc1f0000) == 0xbc010000) ||	/* stm Rx, NUM(r1) */
	       (((op & 0xfc1f0000) == 0x90010000 ||	/* st rx,NUM(r1) */
		 (op & 0xfc1f0003) == 0xf8010000) &&	/* std rx,NUM(r1) */
		(op & 0x03e00000) >= 0x01a00000))	/* rx >= r13 */
	{

	  reg = GET_SRC_REG (op);
	  if ((op & 0xfc1f0000) == 0xbc010000)
	    fdata->gpr_mask |= ~((1U << reg) - 1);
	  else
	    fdata->gpr_mask |= 1U << reg;
	  if (fdata->saved_gpr == -1 || fdata->saved_gpr > reg)
	    {
	      fdata->saved_gpr = reg;
	      if ((op & 0xfc1f0003) == 0xf8010000)
		op &= ~3UL;
	      fdata->gpr_offset = SIGNED_SHORT (op) + offset;
	    }
	  continue;

	}
      else if ((op & 0xffff0000) == 0x60000000)
        {
	  /* nop */
	  /* Allow nops in the prologue, but do not consider them to
	     be part of the prologue unless followed by other prologue
	     instructions.  */
	  prev_insn_was_prologue_insn = 0;
	  continue;

	}
      else if ((op & 0xffff0000) == 0x3c000000)
	{			/* addis 0,0,NUM, used
				   for >= 32k frames */
	  fdata->offset = (op & 0x0000ffff) << 16;
	  fdata->frameless = 0;
          r0_contains_arg = 0;
	  continue;

	}
      else if ((op & 0xffff0000) == 0x60000000)
	{			/* ori 0,0,NUM, 2nd ha
				   lf of >= 32k frames */
	  fdata->offset |= (op & 0x0000ffff);
	  fdata->frameless = 0;
          r0_contains_arg = 0;
	  continue;

	}
      else if (lr_reg >= 0 &&
	       /* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
	       (((op & 0xffff0000) == (lr_reg | 0xf8010000)) ||
		/* stw Rx, NUM(r1) */
		((op & 0xffff0000) == (lr_reg | 0x90010000)) ||
		/* stwu Rx, NUM(r1) */
		((op & 0xffff0000) == (lr_reg | 0x94010000))))
	{	/* where Rx == lr */
	  fdata->lr_offset = offset;
	  fdata->nosavedpc = 0;
	  /* Invalidate lr_reg, but don't set it to -1.
	     That would mean that it had never been set.  */
	  lr_reg = -2;
	  if ((op & 0xfc000003) == 0xf8000000 ||	/* std */
	      (op & 0xfc000000) == 0x90000000)		/* stw */
	    {
	      /* Does not update r1, so add displacement to lr_offset.  */
	      fdata->lr_offset += SIGNED_SHORT (op);
	    }
	  continue;

	}
      else if (cr_reg >= 0 &&
	       /* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
	       (((op & 0xffff0000) == (cr_reg | 0xf8010000)) ||
		/* stw Rx, NUM(r1) */
		((op & 0xffff0000) == (cr_reg | 0x90010000)) ||
		/* stwu Rx, NUM(r1) */
		((op & 0xffff0000) == (cr_reg | 0x94010000))))
	{	/* where Rx == cr */
	  fdata->cr_offset = offset;
	  /* Invalidate cr_reg, but don't set it to -1.
	     That would mean that it had never been set.  */
	  cr_reg = -2;
	  if ((op & 0xfc000003) == 0xf8000000 ||
	      (op & 0xfc000000) == 0x90000000)
	    {
	      /* Does not update r1, so add displacement to cr_offset.  */
	      fdata->cr_offset += SIGNED_SHORT (op);
	    }
	  continue;

	}
      else if ((op & 0xfe80ffff) == 0x42800005 && lr_reg != -1)
	{
	  /* bcl 20,xx,.+4 is used to get the current PC, with or without
	     prediction bits.  If the LR has already been saved, we can
	     skip it.  */
	  continue;
	}
      else if (op == 0x48000005)
	{			/* bl .+4 used in 
				   -mrelocatable */
	  fdata->used_bl = 1;
	  continue;

	}
      else if (op == 0x48000004)
	{			/* b .+4 (xlc) */
	  break;

	}
      else if ((op & 0xffff0000) == 0x3fc00000 ||  /* addis 30,0,foo@@ha, used
						      in V.4 -mminimal-toc */
	       (op & 0xffff0000) == 0x3bde0000)
	{			/* addi 30,30,foo@@l */
	  continue;

	}
      else if ((op & 0xfc000001) == 0x48000001)
	{			/* bl foo, 
				   to save fprs???  */

	  fdata->frameless = 0;

	  /* If the return address has already been saved, we can skip
	     calls to blrl (for PIC).  */
          if (lr_reg != -1 && bl_to_blrl_insn_p (pc, op, byte_order))
	    {
	      fdata->used_bl = 1;
	      continue;
	    }

	  /* Don't skip over the subroutine call if it is not within
	     the first three instructions of the prologue and either
	     we have no line table information or the line info tells
	     us that the subroutine call is not part of the line
	     associated with the prologue.  */
	  if ((pc - orig_pc) > 8)
	    {
	      struct symtab_and_line prologue_sal = find_pc_line (orig_pc, 0);
	      struct symtab_and_line this_sal = find_pc_line (pc, 0);

	      if ((prologue_sal.line == 0)
		  || (prologue_sal.line != this_sal.line))
		break;
	    }

	  op = read_memory_integer (pc + 4, 4, byte_order);

	  /* At this point, make sure this is not a trampoline
	     function (a function that simply calls another functions,
	     and nothing else).  If the next is not a nop, this branch
	     was part of the function prologue.  */

	  if (op == 0x4def7b82 || op == 0)	/* crorc 15, 15, 15 */
	    break;		/* Don't skip over 
				   this branch.  */

	  fdata->used_bl = 1;
	  continue;
	}
      /* update stack pointer */
      else if ((op & 0xfc1f0000) == 0x94010000)
	{		/* stu rX,NUM(r1) ||  stwu rX,NUM(r1) */
	  fdata->frameless = 0;
	  fdata->offset = SIGNED_SHORT (op);
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xfc1f016a) == 0x7c01016e)
	{			/* stwux rX,r1,rY */
	  /* No way to figure out what r1 is going to be.  */
	  fdata->frameless = 0;
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xfc1f0003) == 0xf8010001)
	{			/* stdu rX,NUM(r1) */
	  fdata->frameless = 0;
	  fdata->offset = SIGNED_SHORT (op & ~3UL);
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xfc1f016a) == 0x7c01016a)
	{			/* stdux rX,r1,rY */
	  /* No way to figure out what r1 is going to be.  */
	  fdata->frameless = 0;
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xffff0000) == 0x38210000)
 	{			/* addi r1,r1,SIMM */
 	  fdata->frameless = 0;
 	  fdata->offset += SIGNED_SHORT (op);
 	  offset = fdata->offset;
 	  continue;
 	}
      /* Load up minimal toc pointer.  Do not treat an epilogue restore
	 of r31 as a minimal TOC load.  */
      else if (((op >> 22) == 0x20f	||	/* l r31,... or l r30,...  */
	       (op >> 22) == 0x3af)		/* ld r31,... or ld r30,...  */
	       && !framep
	       && !minimal_toc_loaded)
	{
	  minimal_toc_loaded = 1;
	  continue;

	  /* move parameters from argument registers to local variable
             registers */
 	}
      else if ((op & 0xfc0007fe) == 0x7c000378 &&	/* mr(.)  Rx,Ry */
               (((op >> 21) & 31) >= 3) &&              /* R3 >= Ry >= R10 */
               (((op >> 21) & 31) <= 10) &&
               ((long) ((op >> 16) & 31)
		>= fdata->saved_gpr)) /* Rx: local var reg */
	{
	  continue;

	  /* store parameters in stack */
	}
      /* Move parameters from argument registers to temporary register.  */
      else if (store_param_on_stack_p (op, framep, &r0_contains_arg))
        {
	  continue;

	  /* Set up frame pointer */
	}
      else if (op == 0x603d0000)       /* oril r29, r1, 0x0 */
	{
	  fdata->frameless = 0;
	  framep = 1;
	  fdata->alloca_reg = (tdep->ppc_gp0_regnum + 29);
	  continue;

	  /* Another way to set up the frame pointer.  */
	}
      else if (op == 0x603f0000	/* oril r31, r1, 0x0 */
	       || op == 0x7c3f0b78)
	{			/* mr r31, r1 */
	  fdata->frameless = 0;
	  framep = 1;
	  fdata->alloca_reg = (tdep->ppc_gp0_regnum + 31);
	  continue;

	  /* Another way to set up the frame pointer.  */
	}
      else if ((op & 0xfc1fffff) == 0x38010000)
	{			/* addi rX, r1, 0x0 */
	  fdata->frameless = 0;
	  framep = 1;
	  fdata->alloca_reg = (tdep->ppc_gp0_regnum
			       + ((op & ~0x38010000) >> 21));
	  continue;
	}
      /* AltiVec related instructions.  */
      /* Store the vrsave register (spr 256) in another register for
	 later manipulation, or load a register into the vrsave
	 register.  2 instructions are used: mfvrsave and
	 mtvrsave.  They are shorthand notation for mfspr Rn, SPR256
	 and mtspr SPR256, Rn.  */
      /* mfspr Rn SPR256 == 011111 nnnnn 0000001000 01010100110
	 mtspr SPR256 Rn == 011111 nnnnn 0000001000 01110100110  */
      else if ((op & 0xfc1fffff) == 0x7c0042a6)    /* mfvrsave Rn */
	{
          vrsave_reg = GET_SRC_REG (op);
	  continue;
	}
      else if ((op & 0xfc1fffff) == 0x7c0043a6)     /* mtvrsave Rn */
        {
          continue;
        }
      /* Store the register where vrsave was saved to onto the stack:
         rS is the register where vrsave was stored in a previous
	 instruction.  */
      /* 100100 sssss 00001 dddddddd dddddddd */
      else if ((op & 0xfc1f0000) == 0x90010000)     /* stw rS, d(r1) */
        {
          if (vrsave_reg == GET_SRC_REG (op))
	    {
	      fdata->vrsave_offset = SIGNED_SHORT (op) + offset;
	      vrsave_reg = -1;
	    }
          continue;
        }
      /* Compute the new value of vrsave, by modifying the register
         where vrsave was saved to.  */
      else if (((op & 0xfc000000) == 0x64000000)    /* oris Ra, Rs, UIMM */
	       || ((op & 0xfc000000) == 0x60000000))/* ori Ra, Rs, UIMM */
	{
	  continue;
	}
      /* li r0, SIMM (short for addi r0, 0, SIMM).  This is the first
	 in a pair of insns to save the vector registers on the
	 stack.  */
      /* 001110 00000 00000 iiii iiii iiii iiii  */
      /* 001110 01110 00000 iiii iiii iiii iiii  */
      else if ((op & 0xffff0000) == 0x38000000         /* li r0, SIMM */
               || (op & 0xffff0000) == 0x39c00000)     /* li r14, SIMM */
	{
          if ((op & 0xffff0000) == 0x38000000)
            r0_contains_arg = 0;
	  li_found_pc = pc;
	  vr_saved_offset = SIGNED_SHORT (op);

          /* This insn by itself is not part of the prologue, unless
             if part of the pair of insns mentioned above.  So do not
             record this insn as part of the prologue yet.  */
          prev_insn_was_prologue_insn = 0;
	}
      /* Store vector register S at (r31+r0) aligned to 16 bytes.  */      
      /* 011111 sssss 11111 00000 00111001110 */
      else if ((op & 0xfc1fffff) == 0x7c1f01ce)   /* stvx Vs, R31, R0 */
        {
	  if (pc == (li_found_pc + 4))
	    {
	      vr_reg = GET_SRC_REG (op);
	      /* If this is the first vector reg to be saved, or if
		 it has a lower number than others previously seen,
		 reupdate the frame info.  */
	      if (fdata->saved_vr == -1 || fdata->saved_vr > vr_reg)
		{
		  fdata->saved_vr = vr_reg;
		  fdata->vr_offset = vr_saved_offset + offset;
		}
	      vr_saved_offset = -1;
	      vr_reg = -1;
	      li_found_pc = 0;
	    }
	}
      /* End AltiVec related instructions.  */

      /* Start BookE related instructions.  */
      /* Store gen register S at (r31+uimm).
         Any register less than r13 is volatile, so we don't care.  */
      /* 000100 sssss 11111 iiiii 01100100001 */
      else if (arch_info->mach == bfd_mach_ppc_e500
	       && (op & 0xfc1f07ff) == 0x101f0321)    /* evstdd Rs,uimm(R31) */
	{
          if ((op & 0x03e00000) >= 0x01a00000)	/* Rs >= r13 */
	    {
              unsigned int imm;
	      ev_reg = GET_SRC_REG (op);
              imm = (op >> 11) & 0x1f;
	      ev_offset = imm * 8;
	      /* If this is the first vector reg to be saved, or if
		 it has a lower number than others previously seen,
		 reupdate the frame info.  */
	      if (fdata->saved_ev == -1 || fdata->saved_ev > ev_reg)
		{
		  fdata->saved_ev = ev_reg;
		  fdata->ev_offset = ev_offset + offset;
		}
	    }
          continue;
        }
      /* Store gen register rS at (r1+rB).  */
      /* 000100 sssss 00001 bbbbb 01100100000 */
      else if (arch_info->mach == bfd_mach_ppc_e500
	       && (op & 0xffe007ff) == 0x13e00320)     /* evstddx RS,R1,Rb */
	{
          if (pc == (li_found_pc + 4))
            {
              ev_reg = GET_SRC_REG (op);
	      /* If this is the first vector reg to be saved, or if
                 it has a lower number than others previously seen,
                 reupdate the frame info.  */
              /* We know the contents of rB from the previous instruction.  */
	      if (fdata->saved_ev == -1 || fdata->saved_ev > ev_reg)
		{
                  fdata->saved_ev = ev_reg;
                  fdata->ev_offset = vr_saved_offset + offset;
		}
	      vr_saved_offset = -1;
	      ev_reg = -1;
	      li_found_pc = 0;
            }
          continue;
        }
      /* Store gen register r31 at (rA+uimm).  */
      /* 000100 11111 aaaaa iiiii 01100100001 */
      else if (arch_info->mach == bfd_mach_ppc_e500
	       && (op & 0xffe007ff) == 0x13e00321)   /* evstdd R31,Ra,UIMM */
        {
          /* Wwe know that the source register is 31 already, but
             it can't hurt to compute it.  */
	  ev_reg = GET_SRC_REG (op);
          ev_offset = ((op >> 11) & 0x1f) * 8;
	  /* If this is the first vector reg to be saved, or if
	     it has a lower number than others previously seen,
	     reupdate the frame info.  */
	  if (fdata->saved_ev == -1 || fdata->saved_ev > ev_reg)
	    {
	      fdata->saved_ev = ev_reg;
	      fdata->ev_offset = ev_offset + offset;
	    }

	  continue;
      	}
      /* Store gen register S at (r31+r0).
         Store param on stack when offset from SP bigger than 4 bytes.  */
      /* 000100 sssss 11111 00000 01100100000 */
      else if (arch_info->mach == bfd_mach_ppc_e500
	       && (op & 0xfc1fffff) == 0x101f0320)     /* evstddx Rs,R31,R0 */
	{
          if (pc == (li_found_pc + 4))
            {
              if ((op & 0x03e00000) >= 0x01a00000)
		{
		  ev_reg = GET_SRC_REG (op);
		  /* If this is the first vector reg to be saved, or if
		     it has a lower number than others previously seen,
		     reupdate the frame info.  */
                  /* We know the contents of r0 from the previous
                     instruction.  */
		  if (fdata->saved_ev == -1 || fdata->saved_ev > ev_reg)
		    {
		      fdata->saved_ev = ev_reg;
		      fdata->ev_offset = vr_saved_offset + offset;
		    }
		  ev_reg = -1;
		}
	      vr_saved_offset = -1;
	      li_found_pc = 0;
	      continue;
            }
	}
      /* End BookE related instructions.  */

      else
	{
	  unsigned int all_mask = ~((1U << fdata->saved_gpr) - 1);

	  /* Not a recognized prologue instruction.
	     Handle optimizer code motions into the prologue by continuing
	     the search if we have no valid frame yet or if the return
	     address is not yet saved in the frame.  Also skip instructions
	     if some of the GPRs expected to be saved are not yet saved.  */
	  if (fdata->frameless == 0 && fdata->nosavedpc == 0
	      && (fdata->gpr_mask & all_mask) == all_mask)
	    break;

	  if (op == 0x4e800020		/* blr */
	      || op == 0x4e800420)	/* bctr */
	    /* Do not scan past epilogue in frameless functions or
	       trampolines.  */
	    break;
	  if ((op & 0xf4000000) == 0x40000000) /* bxx */
	    /* Never skip branches.  */
	    break;

	  if (num_skip_non_prologue_insns++ > max_skip_non_prologue_insns)
	    /* Do not scan too many insns, scanning insns is expensive with
	       remote targets.  */
	    break;

	  /* Continue scanning.  */
	  prev_insn_was_prologue_insn = 0;
	  continue;
	}
    }

#if 0
/* I have problems with skipping over __main() that I need to address
 * sometime.  Previously, I used to use misc_function_vector which
 * didn't work as well as I wanted to be.  -MGO */

  /* If the first thing after skipping a prolog is a branch to a function,
     this might be a call to an initializer in main(), introduced by gcc2.
     We'd like to skip over it as well.  Fortunately, xlc does some extra
     work before calling a function right after a prologue, thus we can
     single out such gcc2 behaviour.  */


  if ((op & 0xfc000001) == 0x48000001)
    {				/* bl foo, an initializer function?  */
      op = read_memory_integer (pc + 4, 4, byte_order);

      if (op == 0x4def7b82)
	{			/* cror 0xf, 0xf, 0xf (nop) */

	  /* Check and see if we are in main.  If so, skip over this
	     initializer function as well.  */

	  tmp = find_pc_misc_function (pc);
	  if (tmp >= 0
	      && strcmp (misc_function_vector[tmp].name, main_name ()) == 0)
	    return pc + 8;
	}
    }
#endif /* 0 */

  if (pc == lim_pc && lr_reg >= 0)
    fdata->lr_register = lr_reg;

  fdata->offset = -fdata->offset;
  return last_prologue_pc;
}

static CORE_ADDR
rs6000_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  struct rs6000_framedata frame;
  CORE_ADDR limit_pc, func_addr, func_end_addr = 0;

  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end_addr))
    {
      CORE_ADDR post_prologue_pc
	= skip_prologue_using_sal (gdbarch, func_addr);
      if (post_prologue_pc != 0)
	return max (pc, post_prologue_pc);
    }

  /* Can't determine prologue from the symbol table, need to examine
     instructions.  */

  /* Find an upper limit on the function prologue using the debug
     information.  If the debug information could not be used to provide
     that bound, then use an arbitrary large number as the upper bound.  */
  limit_pc = skip_prologue_using_sal (gdbarch, pc);
  if (limit_pc == 0)
    limit_pc = pc + 100;          /* Magic.  */

  /* Do not allow limit_pc to be past the function end, if we know
     where that end is...  */
  if (func_end_addr && limit_pc > func_end_addr)
    limit_pc = func_end_addr;

  pc = skip_prologue (gdbarch, pc, limit_pc, &frame);
  return pc;
}

/* When compiling for EABI, some versions of GCC emit a call to __eabi
   in the prologue of main().

   The function below examines the code pointed at by PC and checks to
   see if it corresponds to a call to __eabi.  If so, it returns the
   address of the instruction following that call.  Otherwise, it simply
   returns PC.  */

static CORE_ADDR
rs6000_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  unsigned long op;

  if (target_read_memory (pc, buf, 4))
    return pc;
  op = extract_unsigned_integer (buf, 4, byte_order);

  if ((op & BL_MASK) == BL_INSTRUCTION)
    {
      CORE_ADDR displ = op & BL_DISPLACEMENT_MASK;
      CORE_ADDR call_dest = pc + 4 + displ;
      struct bound_minimal_symbol s = lookup_minimal_symbol_by_pc (call_dest);

      /* We check for ___eabi (three leading underscores) in addition
         to __eabi in case the GCC option "-fleading-underscore" was
	 used to compile the program.  */
      if (s.minsym != NULL
          && SYMBOL_LINKAGE_NAME (s.minsym) != NULL
	  && (strcmp (SYMBOL_LINKAGE_NAME (s.minsym), "__eabi") == 0
	      || strcmp (SYMBOL_LINKAGE_NAME (s.minsym), "___eabi") == 0))
	pc += 4;
    }
  return pc;
}

/* All the ABI's require 16 byte alignment.  */
static CORE_ADDR
rs6000_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return (addr & -16);
}

/* Return whether handle_inferior_event() should proceed through code
   starting at PC in function NAME when stepping.

   The AIX -bbigtoc linker option generates functions @@FIX0, @@FIX1, etc. to
   handle memory references that are too distant to fit in instructions
   generated by the compiler.  For example, if 'foo' in the following
   instruction:

     lwz r9,foo(r2)

   is greater than 32767, the linker might replace the lwz with a branch to
   somewhere in @@FIX1 that does the load in 2 instructions and then branches
   back to where execution should continue.

   GDB should silently step over @@FIX code, just like AIX dbx does.
   Unfortunately, the linker uses the "b" instruction for the
   branches, meaning that the link register doesn't get set.
   Therefore, GDB's usual step_over_function () mechanism won't work.

   Instead, use the gdbarch_skip_trampoline_code and
   gdbarch_skip_trampoline_code hooks in handle_inferior_event() to skip past
   @@FIX code.  */

static int
rs6000_in_solib_return_trampoline (struct gdbarch *gdbarch,
				   CORE_ADDR pc, const char *name)
{
  return name && !strncmp (name, "@@FIX", 4);
}

/* Skip code that the user doesn't want to see when stepping:

   1. Indirect function calls use a piece of trampoline code to do context
   switching, i.e. to set the new TOC table.  Skip such code if we are on
   its first instruction (as when we have single-stepped to here).

   2. Skip shared library trampoline code (which is different from
   indirect function call trampolines).

   3. Skip bigtoc fixup code.

   Result is desired PC to step until, or NULL if we are not in
   code that should be skipped.  */

static CORE_ADDR
rs6000_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  unsigned int ii, op;
  int rel;
  CORE_ADDR solib_target_pc;
  struct bound_minimal_symbol msymbol;

  static unsigned trampoline_code[] =
  {
    0x800b0000,			/*     l   r0,0x0(r11)  */
    0x90410014,			/*    st   r2,0x14(r1)  */
    0x7c0903a6,			/* mtctr   r0           */
    0x804b0004,			/*     l   r2,0x4(r11)  */
    0x816b0008,			/*     l  r11,0x8(r11)  */
    0x4e800420,			/*  bctr                */
    0x4e800020,			/*    br                */
    0
  };

  /* Check for bigtoc fixup code.  */
  msymbol = lookup_minimal_symbol_by_pc (pc);
  if (msymbol.minsym
      && rs6000_in_solib_return_trampoline (gdbarch, pc,
					    SYMBOL_LINKAGE_NAME (msymbol.minsym)))
    {
      /* Double-check that the third instruction from PC is relative "b".  */
      op = read_memory_integer (pc + 8, 4, byte_order);
      if ((op & 0xfc000003) == 0x48000000)
	{
	  /* Extract bits 6-29 as a signed 24-bit relative word address and
	     add it to the containing PC.  */
	  rel = ((int)(op << 6) >> 6);
	  return pc + 8 + rel;
	}
    }

  /* If pc is in a shared library trampoline, return its target.  */
  solib_target_pc = find_solib_trampoline_target (frame, pc);
  if (solib_target_pc)
    return solib_target_pc;

  for (ii = 0; trampoline_code[ii]; ++ii)
    {
      op = read_memory_integer (pc + (ii * 4), 4, byte_order);
      if (op != trampoline_code[ii])
	return 0;
    }
  ii = get_frame_register_unsigned (frame, 11);	/* r11 holds destination
						   addr.  */
  pc = read_memory_unsigned_integer (ii, tdep->wordsize, byte_order);
  return pc;
}

/* ISA-specific vector types.  */

static struct type *
rs6000_builtin_type_vec64 (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->ppc_builtin_type_vec64)
    {
      const struct builtin_type *bt = builtin_type (gdbarch);

      /* The type we're building is this: */
#if 0
      union __gdb_builtin_type_vec64
	{
	  int64_t uint64;
	  float v2_float[2];
	  int32_t v2_int32[2];
	  int16_t v4_int16[4];
	  int8_t v8_int8[8];
	};
#endif

      struct type *t;

      t = arch_composite_type (gdbarch,
			       "__ppc_builtin_type_vec64", TYPE_CODE_UNION);
      append_composite_type_field (t, "uint64", bt->builtin_int64);
      append_composite_type_field (t, "v2_float",
				   init_vector_type (bt->builtin_float, 2));
      append_composite_type_field (t, "v2_int32",
				   init_vector_type (bt->builtin_int32, 2));
      append_composite_type_field (t, "v4_int16",
				   init_vector_type (bt->builtin_int16, 4));
      append_composite_type_field (t, "v8_int8",
				   init_vector_type (bt->builtin_int8, 8));

      TYPE_VECTOR (t) = 1;
      TYPE_NAME (t) = "ppc_builtin_type_vec64";
      tdep->ppc_builtin_type_vec64 = t;
    }

  return tdep->ppc_builtin_type_vec64;
}

/* Vector 128 type.  */

static struct type *
rs6000_builtin_type_vec128 (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->ppc_builtin_type_vec128)
    {
      const struct builtin_type *bt = builtin_type (gdbarch);

      /* The type we're building is this

	 type = union __ppc_builtin_type_vec128 {
	     uint128_t uint128;
	     double v2_double[2];
	     float v4_float[4];
	     int32_t v4_int32[4];
	     int16_t v8_int16[8];
	     int8_t v16_int8[16];
	 }
      */

      struct type *t;

      t = arch_composite_type (gdbarch,
			       "__ppc_builtin_type_vec128", TYPE_CODE_UNION);
      append_composite_type_field (t, "uint128", bt->builtin_uint128);
      append_composite_type_field (t, "v2_double",
				   init_vector_type (bt->builtin_double, 2));
      append_composite_type_field (t, "v4_float",
				   init_vector_type (bt->builtin_float, 4));
      append_composite_type_field (t, "v4_int32",
				   init_vector_type (bt->builtin_int32, 4));
      append_composite_type_field (t, "v8_int16",
				   init_vector_type (bt->builtin_int16, 8));
      append_composite_type_field (t, "v16_int8",
				   init_vector_type (bt->builtin_int8, 16));

      TYPE_VECTOR (t) = 1;
      TYPE_NAME (t) = "ppc_builtin_type_vec128";
      tdep->ppc_builtin_type_vec128 = t;
    }

  return tdep->ppc_builtin_type_vec128;
}

/* Return the name of register number REGNO, or the empty string if it
   is an anonymous register.  */

static const char *
rs6000_register_name (struct gdbarch *gdbarch, int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* The upper half "registers" have names in the XML description,
     but we present only the low GPRs and the full 64-bit registers
     to the user.  */
  if (tdep->ppc_ev0_upper_regnum >= 0
      && tdep->ppc_ev0_upper_regnum <= regno
      && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    return "";

  /* Hide the upper halves of the vs0~vs31 registers.  */
  if (tdep->ppc_vsr0_regnum >= 0
      && tdep->ppc_vsr0_upper_regnum <= regno
      && regno < tdep->ppc_vsr0_upper_regnum + ppc_num_gprs)
    return "";

  /* Check if the SPE pseudo registers are available.  */
  if (IS_SPE_PSEUDOREG (tdep, regno))
    {
      static const char *const spe_regnames[] = {
	"ev0", "ev1", "ev2", "ev3", "ev4", "ev5", "ev6", "ev7",
	"ev8", "ev9", "ev10", "ev11", "ev12", "ev13", "ev14", "ev15",
	"ev16", "ev17", "ev18", "ev19", "ev20", "ev21", "ev22", "ev23",
	"ev24", "ev25", "ev26", "ev27", "ev28", "ev29", "ev30", "ev31",
      };
      return spe_regnames[regno - tdep->ppc_ev0_regnum];
    }

  /* Check if the decimal128 pseudo-registers are available.  */
  if (IS_DFP_PSEUDOREG (tdep, regno))
    {
      static const char *const dfp128_regnames[] = {
	"dl0", "dl1", "dl2", "dl3",
	"dl4", "dl5", "dl6", "dl7",
	"dl8", "dl9", "dl10", "dl11",
	"dl12", "dl13", "dl14", "dl15"
      };
      return dfp128_regnames[regno - tdep->ppc_dl0_regnum];
    }

  /* Check if this is a VSX pseudo-register.  */
  if (IS_VSX_PSEUDOREG (tdep, regno))
    {
      static const char *const vsx_regnames[] = {
	"vs0", "vs1", "vs2", "vs3", "vs4", "vs5", "vs6", "vs7",
	"vs8", "vs9", "vs10", "vs11", "vs12", "vs13", "vs14",
	"vs15", "vs16", "vs17", "vs18", "vs19", "vs20", "vs21",
	"vs22", "vs23", "vs24", "vs25", "vs26", "vs27", "vs28",
	"vs29", "vs30", "vs31", "vs32", "vs33", "vs34", "vs35",
	"vs36", "vs37", "vs38", "vs39", "vs40", "vs41", "vs42",
	"vs43", "vs44", "vs45", "vs46", "vs47", "vs48", "vs49",
	"vs50", "vs51", "vs52", "vs53", "vs54", "vs55", "vs56",
	"vs57", "vs58", "vs59", "vs60", "vs61", "vs62", "vs63"
      };
      return vsx_regnames[regno - tdep->ppc_vsr0_regnum];
    }

  /* Check if the this is a Extended FP pseudo-register.  */
  if (IS_EFP_PSEUDOREG (tdep, regno))
    {
      static const char *const efpr_regnames[] = {
	"f32", "f33", "f34", "f35", "f36", "f37", "f38",
	"f39", "f40", "f41", "f42", "f43", "f44", "f45",
	"f46", "f47", "f48", "f49", "f50", "f51",
	"f52", "f53", "f54", "f55", "f56", "f57",
	"f58", "f59", "f60", "f61", "f62", "f63"
      };
      return efpr_regnames[regno - tdep->ppc_efpr0_regnum];
    }

  return tdesc_register_name (gdbarch, regno);
}

/* Return the GDB type object for the "standard" data type of data in
   register N.  */

static struct type *
rs6000_pseudo_register_type (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* These are the only pseudo-registers we support.  */
  gdb_assert (IS_SPE_PSEUDOREG (tdep, regnum)
	      || IS_DFP_PSEUDOREG (tdep, regnum)
	      || IS_VSX_PSEUDOREG (tdep, regnum)
	      || IS_EFP_PSEUDOREG (tdep, regnum));

  /* These are the e500 pseudo-registers.  */
  if (IS_SPE_PSEUDOREG (tdep, regnum))
    return rs6000_builtin_type_vec64 (gdbarch);
  else if (IS_DFP_PSEUDOREG (tdep, regnum))
    /* PPC decimal128 pseudo-registers.  */
    return builtin_type (gdbarch)->builtin_declong;
  else if (IS_VSX_PSEUDOREG (tdep, regnum))
    /* POWER7 VSX pseudo-registers.  */
    return rs6000_builtin_type_vec128 (gdbarch);
  else
    /* POWER7 Extended FP pseudo-registers.  */
    return builtin_type (gdbarch)->builtin_double;
}

/* Is REGNUM a member of REGGROUP?  */
static int
rs6000_pseudo_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
				   struct reggroup *group)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* These are the only pseudo-registers we support.  */
  gdb_assert (IS_SPE_PSEUDOREG (tdep, regnum)
	      || IS_DFP_PSEUDOREG (tdep, regnum)
	      || IS_VSX_PSEUDOREG (tdep, regnum)
	      || IS_EFP_PSEUDOREG (tdep, regnum));

  /* These are the e500 pseudo-registers or the POWER7 VSX registers.  */
  if (IS_SPE_PSEUDOREG (tdep, regnum) || IS_VSX_PSEUDOREG (tdep, regnum))
    return group == all_reggroup || group == vector_reggroup;
  else
    /* PPC decimal128 or Extended FP pseudo-registers.  */
    return group == all_reggroup || group == float_reggroup;
}

/* The register format for RS/6000 floating point registers is always
   double, we need a conversion if the memory format is float.  */

static int
rs6000_convert_register_p (struct gdbarch *gdbarch, int regnum,
			   struct type *type)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  return (tdep->ppc_fp0_regnum >= 0
	  && regnum >= tdep->ppc_fp0_regnum
	  && regnum < tdep->ppc_fp0_regnum + ppc_num_fprs
	  && TYPE_CODE (type) == TYPE_CODE_FLT
	  && TYPE_LENGTH (type)
	     != TYPE_LENGTH (builtin_type (gdbarch)->builtin_double));
}

static int
rs6000_register_to_value (struct frame_info *frame,
                          int regnum,
                          struct type *type,
                          gdb_byte *to,
			  int *optimizedp, int *unavailablep)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  gdb_byte from[MAX_REGISTER_SIZE];
  
  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);

  if (!get_frame_register_bytes (frame, regnum, 0,
				 register_size (gdbarch, regnum),
				 from, optimizedp, unavailablep))
    return 0;

  convert_typed_floating (from, builtin_type (gdbarch)->builtin_double,
			  to, type);
  *optimizedp = *unavailablep = 0;
  return 1;
}

static void
rs6000_value_to_register (struct frame_info *frame,
                          int regnum,
                          struct type *type,
                          const gdb_byte *from)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  gdb_byte to[MAX_REGISTER_SIZE];

  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);

  convert_typed_floating (from, type,
			  to, builtin_type (gdbarch)->builtin_double);
  put_frame_register (frame, regnum, to);
}

 /* The type of a function that moves the value of REG between CACHE
    or BUF --- in either direction.  */
typedef enum register_status (*move_ev_register_func) (struct regcache *,
						       int, void *);

/* Move SPE vector register values between a 64-bit buffer and the two
   32-bit raw register halves in a regcache.  This function handles
   both splitting a 64-bit value into two 32-bit halves, and joining
   two halves into a whole 64-bit value, depending on the function
   passed as the MOVE argument.

   EV_REG must be the number of an SPE evN vector register --- a
   pseudoregister.  REGCACHE must be a regcache, and BUFFER must be a
   64-bit buffer.

   Call MOVE once for each 32-bit half of that register, passing
   REGCACHE, the number of the raw register corresponding to that
   half, and the address of the appropriate half of BUFFER.

   For example, passing 'regcache_raw_read' as the MOVE function will
   fill BUFFER with the full 64-bit contents of EV_REG.  Or, passing
   'regcache_raw_supply' will supply the contents of BUFFER to the
   appropriate pair of raw registers in REGCACHE.

   You may need to cast away some 'const' qualifiers when passing
   MOVE, since this function can't tell at compile-time which of
   REGCACHE or BUFFER is acting as the source of the data.  If C had
   co-variant type qualifiers, ...  */

static enum register_status
e500_move_ev_register (move_ev_register_func move,
		       struct regcache *regcache, int ev_reg, void *buffer)
{
  struct gdbarch *arch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch); 
  int reg_index;
  gdb_byte *byte_buffer = buffer;
  enum register_status status;

  gdb_assert (IS_SPE_PSEUDOREG (tdep, ev_reg));

  reg_index = ev_reg - tdep->ppc_ev0_regnum;

  if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG)
    {
      status = move (regcache, tdep->ppc_ev0_upper_regnum + reg_index,
		     byte_buffer);
      if (status == REG_VALID)
	status = move (regcache, tdep->ppc_gp0_regnum + reg_index,
		       byte_buffer + 4);
    }
  else
    {
      status = move (regcache, tdep->ppc_gp0_regnum + reg_index, byte_buffer);
      if (status == REG_VALID)
	status = move (regcache, tdep->ppc_ev0_upper_regnum + reg_index,
		       byte_buffer + 4);
    }

  return status;
}

static enum register_status
do_regcache_raw_read (struct regcache *regcache, int regnum, void *buffer)
{
  return regcache_raw_read (regcache, regnum, buffer);
}

static enum register_status
do_regcache_raw_write (struct regcache *regcache, int regnum, void *buffer)
{
  regcache_raw_write (regcache, regnum, buffer);

  return REG_VALID;
}

static enum register_status
e500_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int reg_nr, gdb_byte *buffer)
{
  return e500_move_ev_register (do_regcache_raw_read, regcache, reg_nr, buffer);
}

static void
e500_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int reg_nr, const gdb_byte *buffer)
{
  e500_move_ev_register (do_regcache_raw_write, regcache,
			 reg_nr, (void *) buffer);
}

/* Read method for DFP pseudo-registers.  */
static enum register_status
dfp_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int reg_nr, gdb_byte *buffer)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int reg_index = reg_nr - tdep->ppc_dl0_regnum;
  enum register_status status;

  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    {
      /* Read two FP registers to form a whole dl register.  */
      status = regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
				  2 * reg_index, buffer);
      if (status == REG_VALID)
	status = regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
				    2 * reg_index + 1, buffer + 8);
    }
  else
    {
      status = regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
				  2 * reg_index + 1, buffer + 8);
      if (status == REG_VALID)
	status = regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
				    2 * reg_index, buffer);
    }

  return status;
}

/* Write method for DFP pseudo-registers.  */
static void
dfp_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int reg_nr, const gdb_byte *buffer)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int reg_index = reg_nr - tdep->ppc_dl0_regnum;

  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    {
      /* Write each half of the dl register into a separate
      FP register.  */
      regcache_raw_write (regcache, tdep->ppc_fp0_regnum +
			  2 * reg_index, buffer);
      regcache_raw_write (regcache, tdep->ppc_fp0_regnum +
			  2 * reg_index + 1, buffer + 8);
    }
  else
    {
      regcache_raw_write (regcache, tdep->ppc_fp0_regnum +
			  2 * reg_index + 1, buffer + 8);
      regcache_raw_write (regcache, tdep->ppc_fp0_regnum +
			  2 * reg_index, buffer);
    }
}

/* Read method for POWER7 VSX pseudo-registers.  */
static enum register_status
vsx_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int reg_nr, gdb_byte *buffer)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int reg_index = reg_nr - tdep->ppc_vsr0_regnum;
  enum register_status status;

  /* Read the portion that overlaps the VMX registers.  */
  if (reg_index > 31)
    status = regcache_raw_read (regcache, tdep->ppc_vr0_regnum +
				reg_index - 32, buffer);
  else
    /* Read the portion that overlaps the FPR registers.  */
    if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
      {
	status = regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
				    reg_index, buffer);
	if (status == REG_VALID)
	  status = regcache_raw_read (regcache, tdep->ppc_vsr0_upper_regnum +
				      reg_index, buffer + 8);
      }
    else
      {
	status = regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
				    reg_index, buffer + 8);
	if (status == REG_VALID)
	  status = regcache_raw_read (regcache, tdep->ppc_vsr0_upper_regnum +
				      reg_index, buffer);
      }

  return status;
}

/* Write method for POWER7 VSX pseudo-registers.  */
static void
vsx_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int reg_nr, const gdb_byte *buffer)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int reg_index = reg_nr - tdep->ppc_vsr0_regnum;

  /* Write the portion that overlaps the VMX registers.  */
  if (reg_index > 31)
    regcache_raw_write (regcache, tdep->ppc_vr0_regnum +
			reg_index - 32, buffer);
  else
    /* Write the portion that overlaps the FPR registers.  */
    if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
      {
	regcache_raw_write (regcache, tdep->ppc_fp0_regnum +
			reg_index, buffer);
	regcache_raw_write (regcache, tdep->ppc_vsr0_upper_regnum +
			reg_index, buffer + 8);
      }
    else
      {
	regcache_raw_write (regcache, tdep->ppc_fp0_regnum +
			reg_index, buffer + 8);
	regcache_raw_write (regcache, tdep->ppc_vsr0_upper_regnum +
			reg_index, buffer);
      }
}

/* Read method for POWER7 Extended FP pseudo-registers.  */
static enum register_status
efpr_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int reg_nr, gdb_byte *buffer)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int reg_index = reg_nr - tdep->ppc_efpr0_regnum;

  /* Read the portion that overlaps the VMX register.  */
  return regcache_raw_read_part (regcache, tdep->ppc_vr0_regnum + reg_index, 0,
				 register_size (gdbarch, reg_nr), buffer);
}

/* Write method for POWER7 Extended FP pseudo-registers.  */
static void
efpr_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int reg_nr, const gdb_byte *buffer)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int reg_index = reg_nr - tdep->ppc_efpr0_regnum;

  /* Write the portion that overlaps the VMX register.  */
  regcache_raw_write_part (regcache, tdep->ppc_vr0_regnum + reg_index, 0,
			   register_size (gdbarch, reg_nr), buffer);
}

static enum register_status
rs6000_pseudo_register_read (struct gdbarch *gdbarch,
			     struct regcache *regcache,
			     int reg_nr, gdb_byte *buffer)
{
  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 

  gdb_assert (regcache_arch == gdbarch);

  if (IS_SPE_PSEUDOREG (tdep, reg_nr))
    return e500_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);
  else if (IS_DFP_PSEUDOREG (tdep, reg_nr))
    return dfp_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);
  else if (IS_VSX_PSEUDOREG (tdep, reg_nr))
    return vsx_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);
  else if (IS_EFP_PSEUDOREG (tdep, reg_nr))
    return efpr_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);
  else
    internal_error (__FILE__, __LINE__,
		    _("rs6000_pseudo_register_read: "
		    "called on unexpected register '%s' (%d)"),
		    gdbarch_register_name (gdbarch, reg_nr), reg_nr);
}

static void
rs6000_pseudo_register_write (struct gdbarch *gdbarch,
			      struct regcache *regcache,
			      int reg_nr, const gdb_byte *buffer)
{
  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 

  gdb_assert (regcache_arch == gdbarch);

  if (IS_SPE_PSEUDOREG (tdep, reg_nr))
    e500_pseudo_register_write (gdbarch, regcache, reg_nr, buffer);
  else if (IS_DFP_PSEUDOREG (tdep, reg_nr))
    dfp_pseudo_register_write (gdbarch, regcache, reg_nr, buffer);
  else if (IS_VSX_PSEUDOREG (tdep, reg_nr))
    vsx_pseudo_register_write (gdbarch, regcache, reg_nr, buffer);
  else if (IS_EFP_PSEUDOREG (tdep, reg_nr))
    efpr_pseudo_register_write (gdbarch, regcache, reg_nr, buffer);
  else
    internal_error (__FILE__, __LINE__,
		    _("rs6000_pseudo_register_write: "
		    "called on unexpected register '%s' (%d)"),
		    gdbarch_register_name (gdbarch, reg_nr), reg_nr);
}

/* Convert a DBX STABS register number to a GDB register number.  */
static int
rs6000_stab_reg_to_regnum (struct gdbarch *gdbarch, int num)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (0 <= num && num <= 31)
    return tdep->ppc_gp0_regnum + num;
  else if (32 <= num && num <= 63)
    /* FIXME: jimb/2004-05-05: What should we do when the debug info
       specifies registers the architecture doesn't have?  Our
       callers don't check the value we return.  */
    return tdep->ppc_fp0_regnum + (num - 32);
  else if (77 <= num && num <= 108)
    return tdep->ppc_vr0_regnum + (num - 77);
  else if (1200 <= num && num < 1200 + 32)
    return tdep->ppc_ev0_upper_regnum + (num - 1200);
  else
    switch (num)
      {
      case 64: 
        return tdep->ppc_mq_regnum;
      case 65:
        return tdep->ppc_lr_regnum;
      case 66: 
        return tdep->ppc_ctr_regnum;
      case 76: 
        return tdep->ppc_xer_regnum;
      case 109:
        return tdep->ppc_vrsave_regnum;
      case 110:
        return tdep->ppc_vrsave_regnum - 1; /* vscr */
      case 111:
        return tdep->ppc_acc_regnum;
      case 112:
        return tdep->ppc_spefscr_regnum;
      default: 
        return num;
      }
}


/* Convert a Dwarf 2 register number to a GDB register number.  */
static int
rs6000_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int num)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (0 <= num && num <= 31)
    return tdep->ppc_gp0_regnum + num;
  else if (32 <= num && num <= 63)
    /* FIXME: jimb/2004-05-05: What should we do when the debug info
       specifies registers the architecture doesn't have?  Our
       callers don't check the value we return.  */
    return tdep->ppc_fp0_regnum + (num - 32);
  else if (1124 <= num && num < 1124 + 32)
    return tdep->ppc_vr0_regnum + (num - 1124);
  else if (1200 <= num && num < 1200 + 32)
    return tdep->ppc_ev0_upper_regnum + (num - 1200);
  else
    switch (num)
      {
      case 64:
	return tdep->ppc_cr_regnum;
      case 67:
        return tdep->ppc_vrsave_regnum - 1; /* vscr */
      case 99:
        return tdep->ppc_acc_regnum;
      case 100:
        return tdep->ppc_mq_regnum;
      case 101:
        return tdep->ppc_xer_regnum;
      case 108:
        return tdep->ppc_lr_regnum;
      case 109:
        return tdep->ppc_ctr_regnum;
      case 356:
        return tdep->ppc_vrsave_regnum;
      case 612:
        return tdep->ppc_spefscr_regnum;
      default:
        return num;
      }
}

/* Translate a .eh_frame register to DWARF register, or adjust a
   .debug_frame register.  */

static int
rs6000_adjust_frame_regnum (struct gdbarch *gdbarch, int num, int eh_frame_p)
{
  /* GCC releases before 3.4 use GCC internal register numbering in
     .debug_frame (and .debug_info, et cetera).  The numbering is
     different from the standard SysV numbering for everything except
     for GPRs and FPRs.  We can not detect this problem in most cases
     - to get accurate debug info for variables living in lr, ctr, v0,
     et cetera, use a newer version of GCC.  But we must detect
     one important case - lr is in column 65 in .debug_frame output,
     instead of 108.

     GCC 3.4, and the "hammer" branch, have a related problem.  They
     record lr register saves in .debug_frame as 108, but still record
     the return column as 65.  We fix that up too.

     We can do this because 65 is assigned to fpsr, and GCC never
     generates debug info referring to it.  To add support for
     handwritten debug info that restores fpsr, we would need to add a
     producer version check to this.  */
  if (!eh_frame_p)
    {
      if (num == 65)
	return 108;
      else
	return num;
    }

  /* .eh_frame is GCC specific.  For binary compatibility, it uses GCC
     internal register numbering; translate that to the standard DWARF2
     register numbering.  */
  if (0 <= num && num <= 63)	/* r0-r31,fp0-fp31 */
    return num;
  else if (68 <= num && num <= 75) /* cr0-cr8 */
    return num - 68 + 86;
  else if (77 <= num && num <= 108) /* vr0-vr31 */
    return num - 77 + 1124;
  else
    switch (num)
      {
      case 64: /* mq */
	return 100;
      case 65: /* lr */
	return 108;
      case 66: /* ctr */
	return 109;
      case 76: /* xer */
	return 101;
      case 109: /* vrsave */
	return 356;
      case 110: /* vscr */
	return 67;
      case 111: /* spe_acc */
	return 99;
      case 112: /* spefscr */
	return 612;
      default:
	return num;
      }
}


/* Handling the various POWER/PowerPC variants.  */

/* Information about a particular processor variant.  */

struct variant
  {
    /* Name of this variant.  */
    char *name;

    /* English description of the variant.  */
    char *description;

    /* bfd_arch_info.arch corresponding to variant.  */
    enum bfd_architecture arch;

    /* bfd_arch_info.mach corresponding to variant.  */
    unsigned long mach;

    /* Target description for this variant.  */
    struct target_desc **tdesc;
  };

static struct variant variants[] =
{
  {"powerpc", "PowerPC user-level", bfd_arch_powerpc,
   bfd_mach_ppc, &tdesc_powerpc_altivec32},
  {"power", "POWER user-level", bfd_arch_rs6000,
   bfd_mach_rs6k, &tdesc_rs6000},
  {"403", "IBM PowerPC 403", bfd_arch_powerpc,
   bfd_mach_ppc_403, &tdesc_powerpc_403},
  {"405", "IBM PowerPC 405", bfd_arch_powerpc,
   bfd_mach_ppc_405, &tdesc_powerpc_405},
  {"601", "Motorola PowerPC 601", bfd_arch_powerpc,
   bfd_mach_ppc_601, &tdesc_powerpc_601},
  {"602", "Motorola PowerPC 602", bfd_arch_powerpc,
   bfd_mach_ppc_602, &tdesc_powerpc_602},
  {"603", "Motorola/IBM PowerPC 603 or 603e", bfd_arch_powerpc,
   bfd_mach_ppc_603, &tdesc_powerpc_603},
  {"604", "Motorola PowerPC 604 or 604e", bfd_arch_powerpc,
   604, &tdesc_powerpc_604},
  {"403GC", "IBM PowerPC 403GC", bfd_arch_powerpc,
   bfd_mach_ppc_403gc, &tdesc_powerpc_403gc},
  {"505", "Motorola PowerPC 505", bfd_arch_powerpc,
   bfd_mach_ppc_505, &tdesc_powerpc_505},
  {"860", "Motorola PowerPC 860 or 850", bfd_arch_powerpc,
   bfd_mach_ppc_860, &tdesc_powerpc_860},
  {"750", "Motorola/IBM PowerPC 750 or 740", bfd_arch_powerpc,
   bfd_mach_ppc_750, &tdesc_powerpc_750},
  {"7400", "Motorola/IBM PowerPC 7400 (G4)", bfd_arch_powerpc,
   bfd_mach_ppc_7400, &tdesc_powerpc_7400},
  {"e500", "Motorola PowerPC e500", bfd_arch_powerpc,
   bfd_mach_ppc_e500, &tdesc_powerpc_e500},

  /* 64-bit */
  {"powerpc64", "PowerPC 64-bit user-level", bfd_arch_powerpc,
   bfd_mach_ppc64, &tdesc_powerpc_altivec64},
  {"620", "Motorola PowerPC 620", bfd_arch_powerpc,
   bfd_mach_ppc_620, &tdesc_powerpc_64},
  {"630", "Motorola PowerPC 630", bfd_arch_powerpc,
   bfd_mach_ppc_630, &tdesc_powerpc_64},
  {"a35", "PowerPC A35", bfd_arch_powerpc,
   bfd_mach_ppc_a35, &tdesc_powerpc_64},
  {"rs64ii", "PowerPC rs64ii", bfd_arch_powerpc,
   bfd_mach_ppc_rs64ii, &tdesc_powerpc_64},
  {"rs64iii", "PowerPC rs64iii", bfd_arch_powerpc,
   bfd_mach_ppc_rs64iii, &tdesc_powerpc_64},

  /* FIXME: I haven't checked the register sets of the following.  */
  {"rs1", "IBM POWER RS1", bfd_arch_rs6000,
   bfd_mach_rs6k_rs1, &tdesc_rs6000},
  {"rsc", "IBM POWER RSC", bfd_arch_rs6000,
   bfd_mach_rs6k_rsc, &tdesc_rs6000},
  {"rs2", "IBM POWER RS2", bfd_arch_rs6000,
   bfd_mach_rs6k_rs2, &tdesc_rs6000},

  {0, 0, 0, 0, 0}
};

/* Return the variant corresponding to architecture ARCH and machine number
   MACH.  If no such variant exists, return null.  */

static const struct variant *
find_variant_by_arch (enum bfd_architecture arch, unsigned long mach)
{
  const struct variant *v;

  for (v = variants; v->name; v++)
    if (arch == v->arch && mach == v->mach)
      return v;

  return NULL;
}

static int
gdb_print_insn_powerpc (bfd_vma memaddr, disassemble_info *info)
{
  if (info->endian == BFD_ENDIAN_BIG)
    return print_insn_big_powerpc (memaddr, info);
  else
    return print_insn_little_powerpc (memaddr, info);
}

static CORE_ADDR
rs6000_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame,
					 gdbarch_pc_regnum (gdbarch));
}

static struct frame_id
rs6000_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  return frame_id_build (get_frame_register_unsigned
			  (this_frame, gdbarch_sp_regnum (gdbarch)),
			 get_frame_pc (this_frame));
}

struct rs6000_frame_cache
{
  CORE_ADDR base;
  CORE_ADDR initial_sp;
  struct trad_frame_saved_reg *saved_regs;
};

static struct rs6000_frame_cache *
rs6000_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct rs6000_frame_cache *cache;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct rs6000_framedata fdata;
  int wordsize = tdep->wordsize;
  CORE_ADDR func, pc;

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct rs6000_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  func = get_frame_func (this_frame);
  pc = get_frame_pc (this_frame);
  skip_prologue (gdbarch, func, pc, &fdata);

  /* Figure out the parent's stack pointer.  */

  /* NOTE: cagney/2002-04-14: The ->frame points to the inner-most
     address of the current frame.  Things might be easier if the
     ->frame pointed to the outer-most address of the frame.  In
     the mean time, the address of the prev frame is used as the
     base address of this frame.  */
  cache->base = get_frame_register_unsigned
		(this_frame, gdbarch_sp_regnum (gdbarch));

  /* If the function appears to be frameless, check a couple of likely
     indicators that we have simply failed to find the frame setup.
     Two common cases of this are missing symbols (i.e.
     get_frame_func returns the wrong address or 0), and assembly
     stubs which have a fast exit path but set up a frame on the slow
     path.

     If the LR appears to return to this function, then presume that
     we have an ABI compliant frame that we failed to find.  */
  if (fdata.frameless && fdata.lr_offset == 0)
    {
      CORE_ADDR saved_lr;
      int make_frame = 0;

      saved_lr = get_frame_register_unsigned (this_frame, tdep->ppc_lr_regnum);
      if (func == 0 && saved_lr == pc)
	make_frame = 1;
      else if (func != 0)
	{
	  CORE_ADDR saved_func = get_pc_function_start (saved_lr);
	  if (func == saved_func)
	    make_frame = 1;
	}

      if (make_frame)
	{
	  fdata.frameless = 0;
	  fdata.lr_offset = tdep->lr_frame_offset;
	}
    }

  if (!fdata.frameless)
    /* Frameless really means stackless.  */
    cache->base
      = read_memory_unsigned_integer (cache->base, wordsize, byte_order);

  trad_frame_set_value (cache->saved_regs,
			gdbarch_sp_regnum (gdbarch), cache->base);

  /* if != -1, fdata.saved_fpr is the smallest number of saved_fpr.
     All fpr's from saved_fpr to fp31 are saved.  */

  if (fdata.saved_fpr >= 0)
    {
      int i;
      CORE_ADDR fpr_addr = cache->base + fdata.fpr_offset;

      /* If skip_prologue says floating-point registers were saved,
         but the current architecture has no floating-point registers,
         then that's strange.  But we have no indices to even record
         the addresses under, so we just ignore it.  */
      if (ppc_floating_point_unit_p (gdbarch))
        for (i = fdata.saved_fpr; i < ppc_num_fprs; i++)
          {
            cache->saved_regs[tdep->ppc_fp0_regnum + i].addr = fpr_addr;
            fpr_addr += 8;
          }
    }

  /* if != -1, fdata.saved_gpr is the smallest number of saved_gpr.
     All gpr's from saved_gpr to gpr31 are saved (except during the
     prologue).  */

  if (fdata.saved_gpr >= 0)
    {
      int i;
      CORE_ADDR gpr_addr = cache->base + fdata.gpr_offset;
      for (i = fdata.saved_gpr; i < ppc_num_gprs; i++)
	{
	  if (fdata.gpr_mask & (1U << i))
	    cache->saved_regs[tdep->ppc_gp0_regnum + i].addr = gpr_addr;
	  gpr_addr += wordsize;
	}
    }

  /* if != -1, fdata.saved_vr is the smallest number of saved_vr.
     All vr's from saved_vr to vr31 are saved.  */
  if (tdep->ppc_vr0_regnum != -1 && tdep->ppc_vrsave_regnum != -1)
    {
      if (fdata.saved_vr >= 0)
	{
	  int i;
	  CORE_ADDR vr_addr = cache->base + fdata.vr_offset;
	  for (i = fdata.saved_vr; i < 32; i++)
	    {
	      cache->saved_regs[tdep->ppc_vr0_regnum + i].addr = vr_addr;
	      vr_addr += register_size (gdbarch, tdep->ppc_vr0_regnum);
	    }
	}
    }

  /* if != -1, fdata.saved_ev is the smallest number of saved_ev.
     All vr's from saved_ev to ev31 are saved. ?????  */
  if (tdep->ppc_ev0_regnum != -1)
    {
      if (fdata.saved_ev >= 0)
	{
	  int i;
	  CORE_ADDR ev_addr = cache->base + fdata.ev_offset;
	  for (i = fdata.saved_ev; i < ppc_num_gprs; i++)
	    {
	      cache->saved_regs[tdep->ppc_ev0_regnum + i].addr = ev_addr;
              cache->saved_regs[tdep->ppc_gp0_regnum + i].addr = ev_addr + 4;
	      ev_addr += register_size (gdbarch, tdep->ppc_ev0_regnum);
            }
	}
    }

  /* If != 0, fdata.cr_offset is the offset from the frame that
     holds the CR.  */
  if (fdata.cr_offset != 0)
    cache->saved_regs[tdep->ppc_cr_regnum].addr
      = cache->base + fdata.cr_offset;

  /* If != 0, fdata.lr_offset is the offset from the frame that
     holds the LR.  */
  if (fdata.lr_offset != 0)
    cache->saved_regs[tdep->ppc_lr_regnum].addr
      = cache->base + fdata.lr_offset;
  else if (fdata.lr_register != -1)
    cache->saved_regs[tdep->ppc_lr_regnum].realreg = fdata.lr_register;
  /* The PC is found in the link register.  */
  cache->saved_regs[gdbarch_pc_regnum (gdbarch)] =
    cache->saved_regs[tdep->ppc_lr_regnum];

  /* If != 0, fdata.vrsave_offset is the offset from the frame that
     holds the VRSAVE.  */
  if (fdata.vrsave_offset != 0)
    cache->saved_regs[tdep->ppc_vrsave_regnum].addr
      = cache->base + fdata.vrsave_offset;

  if (fdata.alloca_reg < 0)
    /* If no alloca register used, then fi->frame is the value of the
       %sp for this frame, and it is good enough.  */
    cache->initial_sp
      = get_frame_register_unsigned (this_frame, gdbarch_sp_regnum (gdbarch));
  else
    cache->initial_sp
      = get_frame_register_unsigned (this_frame, fdata.alloca_reg);

  return cache;
}

static void
rs6000_frame_this_id (struct frame_info *this_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct rs6000_frame_cache *info = rs6000_frame_cache (this_frame,
							this_cache);
  /* This marks the outermost frame.  */
  if (info->base == 0)
    return;

  (*this_id) = frame_id_build (info->base, get_frame_func (this_frame));
}

static struct value *
rs6000_frame_prev_register (struct frame_info *this_frame,
			    void **this_cache, int regnum)
{
  struct rs6000_frame_cache *info = rs6000_frame_cache (this_frame,
							this_cache);
  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
}

static const struct frame_unwind rs6000_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  rs6000_frame_this_id,
  rs6000_frame_prev_register,
  NULL,
  default_frame_sniffer
};


static CORE_ADDR
rs6000_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct rs6000_frame_cache *info = rs6000_frame_cache (this_frame,
							this_cache);
  return info->initial_sp;
}

static const struct frame_base rs6000_frame_base = {
  &rs6000_frame_unwind,
  rs6000_frame_base_address,
  rs6000_frame_base_address,
  rs6000_frame_base_address
};

static const struct frame_base *
rs6000_frame_base_sniffer (struct frame_info *this_frame)
{
  return &rs6000_frame_base;
}

/* DWARF-2 frame support.  Used to handle the detection of
  clobbered registers during function calls.  */

static void
ppc_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
			    struct dwarf2_frame_state_reg *reg,
			    struct frame_info *this_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* PPC32 and PPC64 ABI's are the same regarding volatile and
     non-volatile registers.  We will use the same code for both.  */

  /* Call-saved GP registers.  */
  if ((regnum >= tdep->ppc_gp0_regnum + 14
      && regnum <= tdep->ppc_gp0_regnum + 31)
      || (regnum == tdep->ppc_gp0_regnum + 1))
    reg->how = DWARF2_FRAME_REG_SAME_VALUE;

  /* Call-clobbered GP registers.  */
  if ((regnum >= tdep->ppc_gp0_regnum + 3
      && regnum <= tdep->ppc_gp0_regnum + 12)
      || (regnum == tdep->ppc_gp0_regnum))
    reg->how = DWARF2_FRAME_REG_UNDEFINED;

  /* Deal with FP registers, if supported.  */
  if (tdep->ppc_fp0_regnum >= 0)
    {
      /* Call-saved FP registers.  */
      if ((regnum >= tdep->ppc_fp0_regnum + 14
	  && regnum <= tdep->ppc_fp0_regnum + 31))
	reg->how = DWARF2_FRAME_REG_SAME_VALUE;

      /* Call-clobbered FP registers.  */
      if ((regnum >= tdep->ppc_fp0_regnum
	  && regnum <= tdep->ppc_fp0_regnum + 13))
	reg->how = DWARF2_FRAME_REG_UNDEFINED;
    }

  /* Deal with ALTIVEC registers, if supported.  */
  if (tdep->ppc_vr0_regnum > 0 && tdep->ppc_vrsave_regnum > 0)
    {
      /* Call-saved Altivec registers.  */
      if ((regnum >= tdep->ppc_vr0_regnum + 20
	  && regnum <= tdep->ppc_vr0_regnum + 31)
	  || regnum == tdep->ppc_vrsave_regnum)
	reg->how = DWARF2_FRAME_REG_SAME_VALUE;

      /* Call-clobbered Altivec registers.  */
      if ((regnum >= tdep->ppc_vr0_regnum
	  && regnum <= tdep->ppc_vr0_regnum + 19))
	reg->how = DWARF2_FRAME_REG_UNDEFINED;
    }

  /* Handle PC register and Stack Pointer correctly.  */
  if (regnum == gdbarch_pc_regnum (gdbarch))
    reg->how = DWARF2_FRAME_REG_RA;
  else if (regnum == gdbarch_sp_regnum (gdbarch))
    reg->how = DWARF2_FRAME_REG_CFA;
}


/* Return true if a .gnu_attributes section exists in BFD and it
   indicates we are using SPE extensions OR if a .PPC.EMB.apuinfo
   section exists in BFD and it indicates that SPE extensions are in
   use.  Check the .gnu.attributes section first, as the binary might be
   compiled for SPE, but not actually using SPE instructions.  */

static int
bfd_uses_spe_extensions (bfd *abfd)
{
  asection *sect;
  gdb_byte *contents = NULL;
  bfd_size_type size;
  gdb_byte *ptr;
  int success = 0;
  int vector_abi;

  if (!abfd)
    return 0;

#ifdef HAVE_ELF
  /* Using Tag_GNU_Power_ABI_Vector here is a bit of a hack, as the user
     could be using the SPE vector abi without actually using any spe
     bits whatsoever.  But it's close enough for now.  */
  vector_abi = bfd_elf_get_obj_attr_int (abfd, OBJ_ATTR_GNU,
					 Tag_GNU_Power_ABI_Vector);
  if (vector_abi == 3)
    return 1;
#endif

  sect = bfd_get_section_by_name (abfd, ".PPC.EMB.apuinfo");
  if (!sect)
    return 0;

  size = bfd_get_section_size (sect);
  contents = xmalloc (size);
  if (!bfd_get_section_contents (abfd, sect, contents, 0, size))
    {
      xfree (contents);
      return 0;
    }

  /* Parse the .PPC.EMB.apuinfo section.  The layout is as follows:

     struct {
       uint32 name_len;
       uint32 data_len;
       uint32 type;
       char name[name_len rounded up to 4-byte alignment];
       char data[data_len];
     };

     Technically, there's only supposed to be one such structure in a
     given apuinfo section, but the linker is not always vigilant about
     merging apuinfo sections from input files.  Just go ahead and parse
     them all, exiting early when we discover the binary uses SPE
     insns.

     It's not specified in what endianness the information in this
     section is stored.  Assume that it's the endianness of the BFD.  */
  ptr = contents;
  while (1)
    {
      unsigned int name_len;
      unsigned int data_len;
      unsigned int type;

      /* If we can't read the first three fields, we're done.  */
      if (size < 12)
	break;

      name_len = bfd_get_32 (abfd, ptr);
      name_len = (name_len + 3) & ~3U; /* Round to 4 bytes.  */
      data_len = bfd_get_32 (abfd, ptr + 4);
      type = bfd_get_32 (abfd, ptr + 8);
      ptr += 12;

      /* The name must be "APUinfo\0".  */
      if (name_len != 8
	  && strcmp ((const char *) ptr, "APUinfo") != 0)
	break;
      ptr += name_len;

      /* The type must be 2.  */
      if (type != 2)
	break;

      /* The data is stored as a series of uint32.  The upper half of
	 each uint32 indicates the particular APU used and the lower
	 half indicates the revision of that APU.  We just care about
	 the upper half.  */

      /* Not 4-byte quantities.  */
      if (data_len & 3U)
	break;

      while (data_len)
	{
	  unsigned int apuinfo = bfd_get_32 (abfd, ptr);
	  unsigned int apu = apuinfo >> 16;
	  ptr += 4;
	  data_len -= 4;

	  /* The SPE APU is 0x100; the SPEFP APU is 0x101.  Accept
	     either.  */
	  if (apu == 0x100 || apu == 0x101)
	    {
	      success = 1;
	      data_len = 0;
	    }
	}

      if (success)
	break;
    }

  xfree (contents);
  return success;
}

/* Initialize the current architecture based on INFO.  If possible, re-use an
   architecture from ARCHES, which is a list of architectures already created
   during this debugging session.

   Called e.g. at program startup, when reading a core file, and when reading
   a binary file.  */

static struct gdbarch *
rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;
  int wordsize, from_xcoff_exec, from_elf_exec;
  enum bfd_architecture arch;
  unsigned long mach;
  bfd abfd;
  enum auto_boolean soft_float_flag = powerpc_soft_float_global;
  int soft_float;
  enum powerpc_vector_abi vector_abi = powerpc_vector_abi_global;
  int have_fpu = 1, have_spe = 0, have_mq = 0, have_altivec = 0, have_dfp = 0,
      have_vsx = 0;
  int tdesc_wordsize = -1;
  const struct target_desc *tdesc = info.target_desc;
  struct tdesc_arch_data *tdesc_data = NULL;
  int num_pseudoregs = 0;
  int cur_reg;

  /* INFO may refer to a binary that is not of the PowerPC architecture,
     e.g. when debugging a stand-alone SPE executable on a Cell/B.E. system.
     In this case, we must not attempt to infer properties of the (PowerPC
     side) of the target system from properties of that executable.  Trust
     the target description instead.  */
  if (info.abfd
      && bfd_get_arch (info.abfd) != bfd_arch_powerpc
      && bfd_get_arch (info.abfd) != bfd_arch_rs6000)
    info.abfd = NULL;

  from_xcoff_exec = info.abfd && info.abfd->format == bfd_object &&
    bfd_get_flavour (info.abfd) == bfd_target_xcoff_flavour;

  from_elf_exec = info.abfd && info.abfd->format == bfd_object &&
    bfd_get_flavour (info.abfd) == bfd_target_elf_flavour;

  /* Check word size.  If INFO is from a binary file, infer it from
     that, else choose a likely default.  */
  if (from_xcoff_exec)
    {
      if (bfd_xcoff_is_xcoff64 (info.abfd))
	wordsize = 8;
      else
	wordsize = 4;
    }
  else if (from_elf_exec)
    {
      if (elf_elfheader (info.abfd)->e_ident[EI_CLASS] == ELFCLASS64)
	wordsize = 8;
      else
	wordsize = 4;
    }
  else if (tdesc_has_registers (tdesc))
    wordsize = -1;
  else
    {
      if (info.bfd_arch_info != NULL && info.bfd_arch_info->bits_per_word != 0)
	wordsize = info.bfd_arch_info->bits_per_word /
	  info.bfd_arch_info->bits_per_byte;
      else
	wordsize = 4;
    }

  /* Get the architecture and machine from the BFD.  */
  arch = info.bfd_arch_info->arch;
  mach = info.bfd_arch_info->mach;

  /* For e500 executables, the apuinfo section is of help here.  Such
     section contains the identifier and revision number of each
     Application-specific Processing Unit that is present on the
     chip.  The content of the section is determined by the assembler
     which looks at each instruction and determines which unit (and
     which version of it) can execute it.  Grovel through the section
     looking for relevant e500 APUs.  */

  if (bfd_uses_spe_extensions (info.abfd))
    {
      arch = info.bfd_arch_info->arch;
      mach = bfd_mach_ppc_e500;
      bfd_default_set_arch_mach (&abfd, arch, mach);
      info.bfd_arch_info = bfd_get_arch_info (&abfd);
    }

  /* Find a default target description which describes our register
     layout, if we do not already have one.  */
  if (! tdesc_has_registers (tdesc))
    {
      const struct variant *v;

      /* Choose variant.  */
      v = find_variant_by_arch (arch, mach);
      if (!v)
	return NULL;

      tdesc = *v->tdesc;
    }

  gdb_assert (tdesc_has_registers (tdesc));

  /* Check any target description for validity.  */
  if (tdesc_has_registers (tdesc))
    {
      static const char *const gprs[] = {
	"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
	"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
	"r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
	"r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31"
      };
      static const char *const segment_regs[] = {
	"sr0", "sr1", "sr2", "sr3", "sr4", "sr5", "sr6", "sr7",
	"sr8", "sr9", "sr10", "sr11", "sr12", "sr13", "sr14", "sr15"
      };
      const struct tdesc_feature *feature;
      int i, valid_p;
      static const char *const msr_names[] = { "msr", "ps" };
      static const char *const cr_names[] = { "cr", "cnd" };
      static const char *const ctr_names[] = { "ctr", "cnt" };

      feature = tdesc_find_feature (tdesc,
				    "org.gnu.gdb.power.core");
      if (feature == NULL)
	return NULL;

      tdesc_data = tdesc_data_alloc ();

      valid_p = 1;
      for (i = 0; i < ppc_num_gprs; i++)
	valid_p &= tdesc_numbered_register (feature, tdesc_data, i, gprs[i]);
      valid_p &= tdesc_numbered_register (feature, tdesc_data, PPC_PC_REGNUM,
					  "pc");
      valid_p &= tdesc_numbered_register (feature, tdesc_data, PPC_LR_REGNUM,
					  "lr");
      valid_p &= tdesc_numbered_register (feature, tdesc_data, PPC_XER_REGNUM,
					  "xer");

      /* Allow alternate names for these registers, to accomodate GDB's
	 historic naming.  */
      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,
						  PPC_MSR_REGNUM, msr_names);
      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,
						  PPC_CR_REGNUM, cr_names);
      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,
						  PPC_CTR_REGNUM, ctr_names);

      if (!valid_p)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      have_mq = tdesc_numbered_register (feature, tdesc_data, PPC_MQ_REGNUM,
					 "mq");

      tdesc_wordsize = tdesc_register_size (feature, "pc") / 8;
      if (wordsize == -1)
	wordsize = tdesc_wordsize;

      feature = tdesc_find_feature (tdesc,
				    "org.gnu.gdb.power.fpu");
      if (feature != NULL)
	{
	  static const char *const fprs[] = {
	    "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
	    "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
	    "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
	    "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31"
	  };
	  valid_p = 1;
	  for (i = 0; i < ppc_num_fprs; i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data,
						PPC_F0_REGNUM + i, fprs[i]);
	  valid_p &= tdesc_numbered_register (feature, tdesc_data,
					      PPC_FPSCR_REGNUM, "fpscr");

	  if (!valid_p)
	    {
	      tdesc_data_cleanup (tdesc_data);
	      return NULL;
	    }
	  have_fpu = 1;
	}
      else
	have_fpu = 0;

      /* The DFP pseudo-registers will be available when there are floating
         point registers.  */
      have_dfp = have_fpu;

      feature = tdesc_find_feature (tdesc,
				    "org.gnu.gdb.power.altivec");
      if (feature != NULL)
	{
	  static const char *const vector_regs[] = {
	    "vr0", "vr1", "vr2", "vr3", "vr4", "vr5", "vr6", "vr7",
	    "vr8", "vr9", "vr10", "vr11", "vr12", "vr13", "vr14", "vr15",
	    "vr16", "vr17", "vr18", "vr19", "vr20", "vr21", "vr22", "vr23",
	    "vr24", "vr25", "vr26", "vr27", "vr28", "vr29", "vr30", "vr31"
	  };

	  valid_p = 1;
	  for (i = 0; i < ppc_num_gprs; i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data,
						PPC_VR0_REGNUM + i,
						vector_regs[i]);
	  valid_p &= tdesc_numbered_register (feature, tdesc_data,
					      PPC_VSCR_REGNUM, "vscr");
	  valid_p &= tdesc_numbered_register (feature, tdesc_data,
					      PPC_VRSAVE_REGNUM, "vrsave");

	  if (have_spe || !valid_p)
	    {
	      tdesc_data_cleanup (tdesc_data);
	      return NULL;
	    }
	  have_altivec = 1;
	}
      else
	have_altivec = 0;

      /* Check for POWER7 VSX registers support.  */
      feature = tdesc_find_feature (tdesc,
				    "org.gnu.gdb.power.vsx");

      if (feature != NULL)
	{
	  static const char *const vsx_regs[] = {
	    "vs0h", "vs1h", "vs2h", "vs3h", "vs4h", "vs5h",
	    "vs6h", "vs7h", "vs8h", "vs9h", "vs10h", "vs11h",
	    "vs12h", "vs13h", "vs14h", "vs15h", "vs16h", "vs17h",
	    "vs18h", "vs19h", "vs20h", "vs21h", "vs22h", "vs23h",
	    "vs24h", "vs25h", "vs26h", "vs27h", "vs28h", "vs29h",
	    "vs30h", "vs31h"
	  };

	  valid_p = 1;

	  for (i = 0; i < ppc_num_vshrs; i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data,
						PPC_VSR0_UPPER_REGNUM + i,
						vsx_regs[i]);
	  if (!valid_p)
	    {
	      tdesc_data_cleanup (tdesc_data);
	      return NULL;
	    }

	  have_vsx = 1;
	}
      else
	have_vsx = 0;

      /* On machines supporting the SPE APU, the general-purpose registers
	 are 64 bits long.  There are SIMD vector instructions to treat them
	 as pairs of floats, but the rest of the instruction set treats them
	 as 32-bit registers, and only operates on their lower halves.

	 In the GDB regcache, we treat their high and low halves as separate
	 registers.  The low halves we present as the general-purpose
	 registers, and then we have pseudo-registers that stitch together
	 the upper and lower halves and present them as pseudo-registers.

	 Thus, the target description is expected to supply the upper
	 halves separately.  */

      feature = tdesc_find_feature (tdesc,
				    "org.gnu.gdb.power.spe");
      if (feature != NULL)
	{
	  static const char *const upper_spe[] = {
	    "ev0h", "ev1h", "ev2h", "ev3h",
	    "ev4h", "ev5h", "ev6h", "ev7h",
	    "ev8h", "ev9h", "ev10h", "ev11h",
	    "ev12h", "ev13h", "ev14h", "ev15h",
	    "ev16h", "ev17h", "ev18h", "ev19h",
	    "ev20h", "ev21h", "ev22h", "ev23h",
	    "ev24h", "ev25h", "ev26h", "ev27h",
	    "ev28h", "ev29h", "ev30h", "ev31h"
	  };

	  valid_p = 1;
	  for (i = 0; i < ppc_num_gprs; i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data,
						PPC_SPE_UPPER_GP0_REGNUM + i,
						upper_spe[i]);
	  valid_p &= tdesc_numbered_register (feature, tdesc_data,
					      PPC_SPE_ACC_REGNUM, "acc");
	  valid_p &= tdesc_numbered_register (feature, tdesc_data,
					      PPC_SPE_FSCR_REGNUM, "spefscr");

	  if (have_mq || have_fpu || !valid_p)
	    {
	      tdesc_data_cleanup (tdesc_data);
	      return NULL;
	    }
	  have_spe = 1;
	}
      else
	have_spe = 0;
    }

  /* If we have a 64-bit binary on a 32-bit target, complain.  Also
     complain for a 32-bit binary on a 64-bit target; we do not yet
     support that.  For instance, the 32-bit ABI routines expect
     32-bit GPRs.

     As long as there isn't an explicit target description, we'll
     choose one based on the BFD architecture and get a word size
     matching the binary (probably powerpc:common or
     powerpc:common64).  So there is only trouble if a 64-bit target
     supplies a 64-bit description while debugging a 32-bit
     binary.  */
  if (tdesc_wordsize != -1 && tdesc_wordsize != wordsize)
    {
      tdesc_data_cleanup (tdesc_data);
      return NULL;
    }

#ifdef HAVE_ELF
  if (soft_float_flag == AUTO_BOOLEAN_AUTO && from_elf_exec)
    {
      switch (bfd_elf_get_obj_attr_int (info.abfd, OBJ_ATTR_GNU,
					Tag_GNU_Power_ABI_FP))
	{
	case 1:
	  soft_float_flag = AUTO_BOOLEAN_FALSE;
	  break;
	case 2:
	  soft_float_flag = AUTO_BOOLEAN_TRUE;
	  break;
	default:
	  break;
	}
    }

  if (vector_abi == POWERPC_VEC_AUTO && from_elf_exec)
    {
      switch (bfd_elf_get_obj_attr_int (info.abfd, OBJ_ATTR_GNU,
					Tag_GNU_Power_ABI_Vector))
	{
	case 1:
	  vector_abi = POWERPC_VEC_GENERIC;
	  break;
	case 2:
	  vector_abi = POWERPC_VEC_ALTIVEC;
	  break;
	case 3:
	  vector_abi = POWERPC_VEC_SPE;
	  break;
	default:
	  break;
	}
    }
#endif

  if (soft_float_flag == AUTO_BOOLEAN_TRUE)
    soft_float = 1;
  else if (soft_float_flag == AUTO_BOOLEAN_FALSE)
    soft_float = 0;
  else
    soft_float = !have_fpu;

  /* If we have a hard float binary or setting but no floating point
     registers, downgrade to soft float anyway.  We're still somewhat
     useful in this scenario.  */
  if (!soft_float && !have_fpu)
    soft_float = 1;

  /* Similarly for vector registers.  */
  if (vector_abi == POWERPC_VEC_ALTIVEC && !have_altivec)
    vector_abi = POWERPC_VEC_GENERIC;

  if (vector_abi == POWERPC_VEC_SPE && !have_spe)
    vector_abi = POWERPC_VEC_GENERIC;

  if (vector_abi == POWERPC_VEC_AUTO)
    {
      if (have_altivec)
	vector_abi = POWERPC_VEC_ALTIVEC;
      else if (have_spe)
	vector_abi = POWERPC_VEC_SPE;
      else
	vector_abi = POWERPC_VEC_GENERIC;
    }

  /* Do not limit the vector ABI based on available hardware, since we
     do not yet know what hardware we'll decide we have.  Yuck!  FIXME!  */

  /* Find a candidate among extant architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Word size in the various PowerPC bfd_arch_info structs isn't
         meaningful, because 64-bit CPUs can run in 32-bit mode.  So, perform
         separate word size check.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->soft_float != soft_float)
	continue;
      if (tdep && tdep->vector_abi != vector_abi)
	continue;
      if (tdep && tdep->wordsize == wordsize)
	{
	  if (tdesc_data != NULL)
	    tdesc_data_cleanup (tdesc_data);
	  return arches->gdbarch;
	}
    }

  /* None found, create a new architecture from INFO, whose bfd_arch_info
     validity depends on the source:
       - executable		useless
       - rs6000_host_arch()	good
       - core file		good
       - "set arch"		trust blindly
       - GDB startup		useless but harmless */

  tdep = XCALLOC (1, struct gdbarch_tdep);
  tdep->wordsize = wordsize;
  tdep->soft_float = soft_float;
  tdep->vector_abi = vector_abi;

  gdbarch = gdbarch_alloc (&info, tdep);

  tdep->ppc_gp0_regnum = PPC_R0_REGNUM;
  tdep->ppc_toc_regnum = PPC_R0_REGNUM + 2;
  tdep->ppc_ps_regnum = PPC_MSR_REGNUM;
  tdep->ppc_cr_regnum = PPC_CR_REGNUM;
  tdep->ppc_lr_regnum = PPC_LR_REGNUM;
  tdep->ppc_ctr_regnum = PPC_CTR_REGNUM;
  tdep->ppc_xer_regnum = PPC_XER_REGNUM;
  tdep->ppc_mq_regnum = have_mq ? PPC_MQ_REGNUM : -1;

  tdep->ppc_fp0_regnum = have_fpu ? PPC_F0_REGNUM : -1;
  tdep->ppc_fpscr_regnum = have_fpu ? PPC_FPSCR_REGNUM : -1;
  tdep->ppc_vsr0_upper_regnum = have_vsx ? PPC_VSR0_UPPER_REGNUM : -1;
  tdep->ppc_vr0_regnum = have_altivec ? PPC_VR0_REGNUM : -1;
  tdep->ppc_vrsave_regnum = have_altivec ? PPC_VRSAVE_REGNUM : -1;
  tdep->ppc_ev0_upper_regnum = have_spe ? PPC_SPE_UPPER_GP0_REGNUM : -1;
  tdep->ppc_acc_regnum = have_spe ? PPC_SPE_ACC_REGNUM : -1;
  tdep->ppc_spefscr_regnum = have_spe ? PPC_SPE_FSCR_REGNUM : -1;

  set_gdbarch_pc_regnum (gdbarch, PPC_PC_REGNUM);
  set_gdbarch_sp_regnum (gdbarch, PPC_R0_REGNUM + 1);
  set_gdbarch_deprecated_fp_regnum (gdbarch, PPC_R0_REGNUM + 1);
  set_gdbarch_fp0_regnum (gdbarch, tdep->ppc_fp0_regnum);
  set_gdbarch_register_sim_regno (gdbarch, rs6000_register_sim_regno);

  /* The XML specification for PowerPC sensibly calls the MSR "msr".
     GDB traditionally called it "ps", though, so let GDB add an
     alias.  */
  set_gdbarch_ps_regnum (gdbarch, tdep->ppc_ps_regnum);

  if (wordsize == 8)
    set_gdbarch_return_value (gdbarch, ppc64_sysv_abi_return_value);
  else
    set_gdbarch_return_value (gdbarch, ppc_sysv_abi_return_value);

  /* Set lr_frame_offset.  */
  if (wordsize == 8)
    tdep->lr_frame_offset = 16;
  else
    tdep->lr_frame_offset = 4;

  if (have_spe || have_dfp || have_vsx)
    {
      set_gdbarch_pseudo_register_read (gdbarch, rs6000_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch,
					 rs6000_pseudo_register_write);
    }

  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);

  /* Select instruction printer.  */
  if (arch == bfd_arch_rs6000)
    set_gdbarch_print_insn (gdbarch, print_insn_rs6000);
  else
    set_gdbarch_print_insn (gdbarch, gdb_print_insn_powerpc);

  set_gdbarch_num_regs (gdbarch, PPC_NUM_REGS);

  if (have_spe)
    num_pseudoregs += 32;
  if (have_dfp)
    num_pseudoregs += 16;
  if (have_vsx)
    /* Include both VSX and Extended FP registers.  */
    num_pseudoregs += 96;

  set_gdbarch_num_pseudo_regs (gdbarch, num_pseudoregs);

  set_gdbarch_ptr_bit (gdbarch, wordsize * TARGET_CHAR_BIT);
  set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_int_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_bit (gdbarch, wordsize * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_bit (gdbarch, 16 * TARGET_CHAR_BIT);
  set_gdbarch_char_signed (gdbarch, 0);

  set_gdbarch_frame_align (gdbarch, rs6000_frame_align);
  if (wordsize == 8)
    /* PPC64 SYSV.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 288);

  set_gdbarch_convert_register_p (gdbarch, rs6000_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, rs6000_register_to_value);
  set_gdbarch_value_to_register (gdbarch, rs6000_value_to_register);

  set_gdbarch_stab_reg_to_regnum (gdbarch, rs6000_stab_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, rs6000_dwarf2_reg_to_regnum);

  if (wordsize == 4)
    set_gdbarch_push_dummy_call (gdbarch, ppc_sysv_abi_push_dummy_call);
  else if (wordsize == 8)
    set_gdbarch_push_dummy_call (gdbarch, ppc64_sysv_abi_push_dummy_call);

  set_gdbarch_skip_prologue (gdbarch, rs6000_skip_prologue);
  set_gdbarch_in_function_epilogue_p (gdbarch, rs6000_in_function_epilogue_p);
  set_gdbarch_skip_main_prologue (gdbarch, rs6000_skip_main_prologue);

  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_breakpoint_from_pc (gdbarch, rs6000_breakpoint_from_pc);

  /* The value of symbols of type N_SO and N_FUN maybe null when
     it shouldn't be.  */
  set_gdbarch_sofun_address_maybe_missing (gdbarch, 1);

  /* Handles single stepping of atomic sequences.  */
  set_gdbarch_software_single_step (gdbarch, ppc_deal_with_atomic_sequence);
  
  /* Not sure on this.  FIXMEmgo */
  set_gdbarch_frame_args_skip (gdbarch, 8);

  /* Helpers for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, rs6000_fetch_pointer_argument);

  /* Trampoline.  */
  set_gdbarch_in_solib_return_trampoline
    (gdbarch, rs6000_in_solib_return_trampoline);
  set_gdbarch_skip_trampoline_code (gdbarch, rs6000_skip_trampoline_code);

  /* Hook in the DWARF CFI frame unwinder.  */
  dwarf2_append_unwinders (gdbarch);
  dwarf2_frame_set_adjust_regnum (gdbarch, rs6000_adjust_frame_regnum);

  /* Frame handling.  */
  dwarf2_frame_set_init_reg (gdbarch, ppc_dwarf2_frame_init_reg);

  /* Setup displaced stepping.  */
  set_gdbarch_displaced_step_copy_insn (gdbarch,
					simple_displaced_step_copy_insn);
  set_gdbarch_displaced_step_hw_singlestep (gdbarch,
					    ppc_displaced_step_hw_singlestep);
  set_gdbarch_displaced_step_fixup (gdbarch, ppc_displaced_step_fixup);
  set_gdbarch_displaced_step_free_closure (gdbarch,
					   simple_displaced_step_free_closure);
  set_gdbarch_displaced_step_location (gdbarch,
				       displaced_step_at_entry_point);

  set_gdbarch_max_insn_length (gdbarch, PPC_INSN_SIZE);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  info.target_desc = tdesc;
  info.tdep_info = (void *) tdesc_data;
  gdbarch_init_osabi (info, gdbarch);

  switch (info.osabi)
    {
    case GDB_OSABI_LINUX:
    case GDB_OSABI_NETBSD_AOUT:
    case GDB_OSABI_NETBSD_ELF:
    case GDB_OSABI_UNKNOWN:
      set_gdbarch_unwind_pc (gdbarch, rs6000_unwind_pc);
      frame_unwind_append_unwinder (gdbarch, &rs6000_frame_unwind);
      set_gdbarch_dummy_id (gdbarch, rs6000_dummy_id);
      frame_base_append_sniffer (gdbarch, rs6000_frame_base_sniffer);
      break;
    default:
      set_gdbarch_believe_pcc_promotion (gdbarch, 1);

      set_gdbarch_unwind_pc (gdbarch, rs6000_unwind_pc);
      frame_unwind_append_unwinder (gdbarch, &rs6000_frame_unwind);
      set_gdbarch_dummy_id (gdbarch, rs6000_dummy_id);
      frame_base_append_sniffer (gdbarch, rs6000_frame_base_sniffer);
    }

  set_tdesc_pseudo_register_type (gdbarch, rs6000_pseudo_register_type);
  set_tdesc_pseudo_register_reggroup_p (gdbarch,
					rs6000_pseudo_register_reggroup_p);
  tdesc_use_registers (gdbarch, tdesc, tdesc_data);

  /* Override the normal target description method to make the SPE upper
     halves anonymous.  */
  set_gdbarch_register_name (gdbarch, rs6000_register_name);

  /* Choose register numbers for all supported pseudo-registers.  */
  tdep->ppc_ev0_regnum = -1;
  tdep->ppc_dl0_regnum = -1;
  tdep->ppc_vsr0_regnum = -1;
  tdep->ppc_efpr0_regnum = -1;

  cur_reg = gdbarch_num_regs (gdbarch);

  if (have_spe)
    {
      tdep->ppc_ev0_regnum = cur_reg;
      cur_reg += 32;
    }
  if (have_dfp)
    {
      tdep->ppc_dl0_regnum = cur_reg;
      cur_reg += 16;
    }
  if (have_vsx)
    {
      tdep->ppc_vsr0_regnum = cur_reg;
      cur_reg += 64;
      tdep->ppc_efpr0_regnum = cur_reg;
      cur_reg += 32;
    }

  gdb_assert (gdbarch_num_regs (gdbarch)
	      + gdbarch_num_pseudo_regs (gdbarch) == cur_reg);

  /* Register the ravenscar_arch_ops.  */
  if (mach == bfd_mach_ppc_e500)
    register_e500_ravenscar_ops (gdbarch);
  else
    register_ppc_ravenscar_ops (gdbarch);

  return gdbarch;
}

static void
rs6000_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep == NULL)
    return;

  /* FIXME: Dump gdbarch_tdep.  */
}

/* PowerPC-specific commands.  */

static void
set_powerpc_command (char *args, int from_tty)
{
  printf_unfiltered (_("\
\"set powerpc\" must be followed by an appropriate subcommand.\n"));
  help_list (setpowerpccmdlist, "set powerpc ", all_commands, gdb_stdout);
}

static void
show_powerpc_command (char *args, int from_tty)
{
  cmd_show_list (showpowerpccmdlist, from_tty, "");
}

static void
powerpc_set_soft_float (char *args, int from_tty,
			struct cmd_list_element *c)
{
  struct gdbarch_info info;

  /* Update the architecture.  */
  gdbarch_info_init (&info);
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, _("could not update architecture"));
}

static void
powerpc_set_vector_abi (char *args, int from_tty,
			struct cmd_list_element *c)
{
  struct gdbarch_info info;
  enum powerpc_vector_abi vector_abi;

  for (vector_abi = POWERPC_VEC_AUTO;
       vector_abi != POWERPC_VEC_LAST;
       vector_abi++)
    if (strcmp (powerpc_vector_abi_string,
		powerpc_vector_strings[vector_abi]) == 0)
      {
	powerpc_vector_abi_global = vector_abi;
	break;
      }

  if (vector_abi == POWERPC_VEC_LAST)
    internal_error (__FILE__, __LINE__, _("Invalid vector ABI accepted: %s."),
		    powerpc_vector_abi_string);

  /* Update the architecture.  */
  gdbarch_info_init (&info);
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, _("could not update architecture"));
}

/* Show the current setting of the exact watchpoints flag.  */

static void
show_powerpc_exact_watchpoints (struct ui_file *file, int from_tty,
				struct cmd_list_element *c,
				const char *value)
{
  fprintf_filtered (file, _("Use of exact watchpoints is %s.\n"), value);
}

/* Read a PPC instruction from memory.  */

static unsigned int
read_insn (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  return read_memory_unsigned_integer (pc, 4, byte_order);
}

/* Return non-zero if the instructions at PC match the series
   described in PATTERN, or zero otherwise.  PATTERN is an array of
   'struct ppc_insn_pattern' objects, terminated by an entry whose
   mask is zero.

   When the match is successful, fill INSN[i] with what PATTERN[i]
   matched.  If PATTERN[i] is optional, and the instruction wasn't
   present, set INSN[i] to 0 (which is not a valid PPC instruction).
   INSN should have as many elements as PATTERN.  Note that, if
   PATTERN contains optional instructions which aren't present in
   memory, then INSN will have holes, so INSN[i] isn't necessarily the
   i'th instruction in memory.  */

int
ppc_insns_match_pattern (struct frame_info *frame, CORE_ADDR pc,
			 struct ppc_insn_pattern *pattern,
			 unsigned int *insns)
{
  int i;
  unsigned int insn;

  for (i = 0, insn = 0; pattern[i].mask; i++)
    {
      if (insn == 0)
	insn = read_insn (frame, pc);
      insns[i] = 0;
      if ((insn & pattern[i].mask) == pattern[i].data)
	{
	  insns[i] = insn;
	  pc += 4;
	  insn = 0;
	}
      else if (!pattern[i].optional)
	return 0;
    }

  return 1;
}

/* Return the 'd' field of the d-form instruction INSN, properly
   sign-extended.  */

CORE_ADDR
ppc_insn_d_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xffff) ^ 0x8000) - 0x8000);
}

/* Return the 'ds' field of the ds-form instruction INSN, with the two
   zero bits concatenated at the right, and properly
   sign-extended.  */

CORE_ADDR
ppc_insn_ds_field (unsigned int insn)
{
  return ((((CORE_ADDR) insn & 0xfffc) ^ 0x8000) - 0x8000);
}

/* Initialization code.  */

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_rs6000_tdep;

void
_initialize_rs6000_tdep (void)
{
  gdbarch_register (bfd_arch_rs6000, rs6000_gdbarch_init, rs6000_dump_tdep);
  gdbarch_register (bfd_arch_powerpc, rs6000_gdbarch_init, rs6000_dump_tdep);

  /* Initialize the standard target descriptions.  */
  initialize_tdesc_powerpc_32 ();
  initialize_tdesc_powerpc_altivec32 ();
  initialize_tdesc_powerpc_vsx32 ();
  initialize_tdesc_powerpc_403 ();
  initialize_tdesc_powerpc_403gc ();
  initialize_tdesc_powerpc_405 ();
  initialize_tdesc_powerpc_505 ();
  initialize_tdesc_powerpc_601 ();
  initialize_tdesc_powerpc_602 ();
  initialize_tdesc_powerpc_603 ();
  initialize_tdesc_powerpc_604 ();
  initialize_tdesc_powerpc_64 ();
  initialize_tdesc_powerpc_altivec64 ();
  initialize_tdesc_powerpc_vsx64 ();
  initialize_tdesc_powerpc_7400 ();
  initialize_tdesc_powerpc_750 ();
  initialize_tdesc_powerpc_860 ();
  initialize_tdesc_powerpc_e500 ();
  initialize_tdesc_rs6000 ();

  /* Add root prefix command for all "set powerpc"/"show powerpc"
     commands.  */
  add_prefix_cmd ("powerpc", no_class, set_powerpc_command,
		  _("Various PowerPC-specific commands."),
		  &setpowerpccmdlist, "set powerpc ", 0, &setlist);

  add_prefix_cmd ("powerpc", no_class, show_powerpc_command,
		  _("Various PowerPC-specific commands."),
		  &showpowerpccmdlist, "show powerpc ", 0, &showlist);

  /* Add a command to allow the user to force the ABI.  */
  add_setshow_auto_boolean_cmd ("soft-float", class_support,
				&powerpc_soft_float_global,
				_("Set whether to use a soft-float ABI."),
				_("Show whether to use a soft-float ABI."),
				NULL,
				powerpc_set_soft_float, NULL,
				&setpowerpccmdlist, &showpowerpccmdlist);

  add_setshow_enum_cmd ("vector-abi", class_support, powerpc_vector_strings,
			&powerpc_vector_abi_string,
			_("Set the vector ABI."),
			_("Show the vector ABI."),
			NULL, powerpc_set_vector_abi, NULL,
			&setpowerpccmdlist, &showpowerpccmdlist);

  add_setshow_boolean_cmd ("exact-watchpoints", class_support,
			   &target_exact_watchpoints,
			   _("\
Set whether to use just one debug register for watchpoints on scalars."),
			   _("\
Show whether to use just one debug register for watchpoints on scalars."),
			   _("\
If true, GDB will use only one debug register when watching a variable of\n\
scalar type, thus assuming that the variable is accessed through the address\n\
of its first byte."),
			   NULL, show_powerpc_exact_watchpoints,
			   &setpowerpccmdlist, &showpowerpccmdlist);
}
@


1.365
log
@add -Wold-style-declaration

This adds -Wold-style-declaration to gdb's list of warnings.

It turns out that a few places use "const static" rather than
"static const".  The former is deprecated according to the C standard.

Tested by rebuilding with --enable-targets=all on x86-64 Fedora 18.

	* configure.ac (build_warnings): Add -Wold-style-declaration.
	* configure: Rebuild.
	* dsrec.c (make_srec): Use "static const", not "const static".
	* h8300-tdep.c (h8300_breakpoint_from_pc): Use "static const",
	not "const static".
	* mi/mi-parse.c (mi_no_values, mi_simple_values, mi_all_values):
	Use "static const", not "const static".
	* mn10300-tdep.c (mn10300_breakpoint_from_pc): Use "static const",
	not "const static".
	* moxie-tdep.c (moxie_breakpoint_from_pc): Use "static const",
	not "const static".
	* rs6000-tdep.c (rs6000_breakpoint_from_pc): Use "static const",
	not "const static".
	* v850-tdep.c (v850_breakpoint_from_pc): Use "static const",
	not "const static".
	(v850_dbtrap_breakpoint_from_pc): Likewise.
	* xstormy16-tdep.c (xstormy16_breakpoint_from_pc): Use "static const",
	not "const static".
@
text
@d2857 1
a2857 1
    return tdep->ppc_ev0_regnum + (num - 1200);
d2899 1
a2899 1
    return tdep->ppc_ev0_regnum + (num - 1200);
@


1.364
log
@	* ppc-tdep.h (ppc_insns_match_pattern): Update prototype.
	* rs6000-tdep.c (read_insn): Add frame param, don't assume big-endian.
	(ppc_insns_match_pattern): Add frame param.  Avoid multiple
	target mem reads on optional insns.
	* ppc-linux-tdep.c (ppc_skip_trampoline_code): Update
	ppc_insns_match_pattern calls.
	* ppc64-tdep.c (ppc64_standard_linkage2, ppc64_standard_linkage3):
	Add match for power7 thread safety insns, and new order of
	std 2,40(1) insn.  Correct code shown for _dl_runtime_resolve
	invocation in comment, and update rest of comment.
	(PPC64_STANDARD_LINKAGE1_LEN, PPC64_STANDARD_LINKAGE2_LEN,
	PPC64_STANDARD_LINKAGE3_LEN): Delete.
	(ppc64_standard_linkage2_target): Update insn offsets.
	(ppc64_skip_trampoline_code): Use a single insn buffer.  Match newer
	stubs first.  Update calls.
@
text
@d946 1
a946 1
const static unsigned char *
@


1.363
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d4241 1
a4241 3
/* Read a PPC instruction from memory.  PPC instructions are always
   big-endian, no matter what endianness the program is running in, so
   we can hardcode BFD_ENDIAN_BIG for read_memory_unsigned_integer.  */
d4244 1
a4244 1
read_insn (CORE_ADDR pc)
d4246 4
a4249 1
  return read_memory_unsigned_integer (pc, 4, BFD_ENDIAN_BIG);
d4266 3
a4268 2
ppc_insns_match_pattern (CORE_ADDR pc, struct ppc_insn_pattern *pattern,
			 unsigned int *insn)
d4271 1
d4273 1
a4273 1
  for (i = 0; pattern[i].mask; i++)
d4275 10
a4284 6
      insn[i] = read_insn (pc);
      if ((insn[i] & pattern[i].mask) == pattern[i].data)
	pc += 4;
      else if (pattern[i].optional)
	insn[i] = 0;
      else
@


1.362
log
@2013-02-01  Andreas Tobler  <andreast@@fgznet.ch>

	* Makefile.in (ALL_TARGET_OBS): Add ppc64-tdep.o.
	(HFILES_NO_SRCDIR): Add ppc64-tdep.h.
	(ALLDEPFILES): Add ppc64-tdep.c.
	* configure.tgt (powerpc-*-linux* | powerpc64-*-linux*): Add
	ppc64-tdep.o to gdb_target_obs.
	* ppc64-tdep.h: New file.
	* ppc64-tdep.c: New file.
	(insn_d, insn_ds, insn_xfx, ppc64_desc_entry_point): Move from
	ppc-linux-tdep.c to here.
	(PPC64_STANDARD_LINKAGE1_LEN, PPC64_STANDARD_LINKAGE2_LEN)
	(PPC64_STANDARD_LINKAGE2_LEN): Likewise and use ARRAY_SIZE macro.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target)
	(ppc64_standard_linkage3_target, ppc64_skip_trampoline_code): Move
	from ppc-linux-tdep.c to here.
	(ppc64_convert_from_func_ptr_addr): Rename from
	ppc64_linux_convert_from_func_ptr_addr to
	ppc64_convert_from_func_ptr_addr and move from ppc-linux-tdep.c to
	here.
	* rs6000-tdep.c:
	(read_insn): Move from ppc-linux-tdep.c to here.
	(insns_match_pattern, insn_d_field, insn_ds_field): Move
	from ppc-linux-tdep.c to here and rename them with the ppc_ prefix.
	* ppc-linux-tdep.c: Include ppc64-tdep.h.
	Removed above functions.
	(ppc_linux_init_abi): Adjust.
@
text
@d2155 1
a2155 1
      struct minimal_symbol *s = lookup_minimal_symbol_by_pc (call_dest);
d2160 4
a2163 4
      if (s != NULL
          && SYMBOL_LINKAGE_NAME (s) != NULL
	  && (strcmp (SYMBOL_LINKAGE_NAME (s), "__eabi") == 0
	      || strcmp (SYMBOL_LINKAGE_NAME (s), "___eabi") == 0))
d2229 1
a2229 1
  struct minimal_symbol *msymbol;
d2245 1
a2245 1
  if (msymbol 
d2247 1
a2247 1
					    SYMBOL_LINKAGE_NAME (msymbol)))
@


1.361
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d4241 62
@


1.360
log
@Add ravenscar-thread support for powerpc.

gdb/ChangeLog:

        * ppc-ravenscar-thread.h, ppc-ravenscar-thread.c: New files.
        * Makefile.in (ALL_TARGET_OBS): Add ppc-ravenscar-thread.o.
        (HFILES_NO_SRCDIR): Add ppc-ravenscar-thread.h.
        (ALLDEPFILES): Add ppc-ravenscar-thread.c.
        * configure.tgt: Add ravenscar-thread.o and ppc-ravenscar-thread.o
        to gdb_target_obs for every target that uses rs6000-tdep.o.
        * rs6000-tdep.c: #include "ppc-ravenscar-thread.h".
        (rs6000_gdbarch_init): Call register_e500_ravenscar_ops
        or register_ppc_ravenscar_ops.
@
text
@d3 1
a3 2
   Copyright (C) 1986-1987, 1989, 1991-2012 Free Software Foundation,
   Inc.
@


1.359
log
@2012-11-28  Edjunior Machado  <emachado@@linux.vnet.ibm.com>

* rs6000-tdep.c (gdb_print_insn_powerpc): Remove info->mach checking,
since now it is being done by binutils' powerpc_init_dialect().
@
text
@d55 1
d4157 6
@


1.358
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@a3086 15
  if (!info->disassembler_options)
    {
      /* When debugging E500 binaries and disassembling code containing
	 E500-specific (SPE) instructions, one sometimes sees AltiVec
	 instructions instead.  The opcode spaces for SPE instructions
	 and AltiVec instructions overlap, and specifiying the "any" cpu
	 looks for AltiVec instructions first.  If we know we're
	 debugging an E500 binary, however, we can specify the "e500x2"
	 cpu and get much more sane disassembly output.  */
      if (info->mach == bfd_mach_ppc_e500)
	info->disassembler_options = "e500x2";
      else
	info->disassembler_options = "any";
    }

@


1.357
log
@[ppc/prologue] Support the "oril r29, r1, 0x0" insn.

gdb/
2012-03-13  Chris January  <chris.january@@allinea.com>

	* rs6000-tdep.c (skip_prologue): Support the oril r29, r1, 0x0
	instruction.
@
text
@a3554 1
  asection *sect;
@


1.356
log
@	* blockframe.c (find_pc_partial_function_gnu_ifunc): Change type of
	"name" parameter to const char ** from char **.  All callers updated.
	(find_pc_partial_function): Ditto.
	(cache_pc_function_name): Change type to const char * from char *.
	* symtab.h ((find_pc_partial_function_gnu_ifunc): Update.
	(find_pc_partial_function): Update.
	* alpha-tdep.h (struct gdbarch_tdep, member pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	All uses updated.
	* arch-utils.c (generic_in_solib_return_trampoline): Change
	type of "name" parameter to const char * from char *.
	* arch-utils.h (generic_in_solib_return_trampoline): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* gdbarch.sh (in_solib_return_trampoline): Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Update.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Update.
	* m32r-linux-tdep.c (m32r_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* skip.c (skip_function_pc): Ditto.
	* sparc-sol2-tdep.c (sparc_sol2_pc_in_sigtramp): Ditto.
	* sparc-tdep.h (sparc_sol2_pc_in_sigtramp): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_pc_in_sigtramp): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_pc_in_sigtramp): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_pc_in_sigtramp): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_pc_in_sigtramp): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_pc_in_sigtramp): Ditto.
	* nbsd-tdep.c (nbsd_pc_in_sigtramp): Similary for "func_name".
	* nbsd-tdep.h (nbsd_pc_in_sigtramp): Update.
@
text
@d1825 9
@


1.355
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d2192 1
a2192 1
				   CORE_ADDR pc, char *name)
@


1.354
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d111 1
a111 1
static const char *powerpc_vector_strings[] =
@


1.353
log
@	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Correct branch
	destination calculation.  Don't expect >> to sign extend.  Don't
	add a break if branch lands inside the sequence anywhere.
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.353.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1986-1987, 1989, 1991-2012 Free Software Foundation,
   Inc.
@


1.352
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d1119 2
a1120 2
          int immediate = ((insn & ~3) << 16) >> 16;
          int absolute = ((insn >> 1) & 1);
d1129 1
a1129 1
	    breaks[1] = pc + immediate;
d1153 4
a1156 5
     placed (branch instruction's destination) at the stwcx/stdcx 
     instruction, this resets the reservation and take us back to the 
     lwarx/ldarx instruction at the beginning of the atomic sequence.  */
  if (last_breakpoint && ((breaks[1] == breaks[0]) 
      || (breaks[1] == closing_insn)))
@


1.351
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d3322 1
@


1.350
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d2507 1
a2507 1
static void
d2511 2
a2512 1
                          gdb_byte *to)
d2519 5
a2523 1
  get_frame_register (frame, regnum, from);
d2526 2
@


1.349
log
@gdb/
	* rs6000-tdep.c (IS_EFP_PSEUDOREG): Use correct constant for
	the EFP register set size.
	(efpr_pseudo_register_read): Use regcache_raw_read_part to read
	data from the VMX register.
	(efpr_pseudo_register_write): Use regcache_raw_write_part to read
	and write data from/to the VMX register.

gdb/testsuite/
	* gdb.arch/vsx-regs.exp: Add "vector_register1_vr" and
	"vector_register2_vr" test strings.  Test the extended floating
	point registers (F32~F63).
	* lib/gdb.exp (skip_vsx_tests): Update compile flags for the
	IBM XL C compiler.  Make the test program use a register provided
	by the compiler for the lxvd2x instruction.
@
text
@d2539 5
d2567 4
a2570 5
static void
e500_move_ev_register (void (*move) (struct regcache *regcache,
                                     int regnum, gdb_byte *buf),
                       struct regcache *regcache, int ev_reg,
                       gdb_byte *buffer)
d2576 1
d2584 5
a2588 2
      move (regcache, tdep->ppc_ev0_upper_regnum + reg_index, byte_buffer);
      move (regcache, tdep->ppc_gp0_regnum + reg_index, byte_buffer + 4);
d2592 4
a2595 2
      move (regcache, tdep->ppc_gp0_regnum + reg_index, byte_buffer);
      move (regcache, tdep->ppc_ev0_upper_regnum + reg_index, byte_buffer + 4);
d2597 16
d2615 1
a2615 1
static void
d2619 1
a2619 1
  e500_move_ev_register (regcache_raw_read, regcache, reg_nr, buffer);
d2626 2
a2627 3
  e500_move_ev_register ((void (*) (struct regcache *, int, gdb_byte *))
			 regcache_raw_write,
			 regcache, reg_nr, (gdb_byte *) buffer);
d2631 1
a2631 1
static void
d2637 1
d2642 5
a2646 4
      regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
			 2 * reg_index, buffer);
      regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
			 2 * reg_index + 1, buffer + 8);
d2650 5
a2654 4
      regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
			 2 * reg_index + 1, buffer + 8);
      regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
			 2 * reg_index, buffer);
d2656 2
d2687 1
a2687 1
static void
d2693 1
d2697 2
a2698 2
    regcache_raw_read (regcache, tdep->ppc_vr0_regnum +
			reg_index - 32, buffer);
d2703 5
a2707 4
	regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
			reg_index, buffer);
	regcache_raw_read (regcache, tdep->ppc_vsr0_upper_regnum +
			reg_index, buffer + 8);
d2711 5
a2715 4
	regcache_raw_read (regcache, tdep->ppc_fp0_regnum +
			reg_index, buffer + 8);
	regcache_raw_read (regcache, tdep->ppc_vsr0_upper_regnum +
			reg_index, buffer);
d2717 2
d2752 1
a2752 1
static void
d2760 2
a2761 2
  regcache_raw_read_part (regcache, tdep->ppc_vr0_regnum + reg_index, 0,
			  register_size (gdbarch, reg_nr), buffer);
d2777 1
a2777 1
static void
d2788 1
a2788 1
    e500_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);
d2790 1
a2790 1
    dfp_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);
d2792 1
a2792 1
    vsx_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);
d2794 1
a2794 1
    efpr_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);
@


1.348
log
@[powerpc] breakpoint inserted past function end

On powerpc, the prologue scanner reads instruction after instruction,
and just skips instructions that do not affect a frame.  This means
that it does not stop if if finds and unexpected instruction (which
could possibly happen with optimization, I presume). To avoid scanning
too many instructions, it tries to establish an upper limit.

The upper limit is first computed using the debugging (line) info,
but if that fails, it falls back on an arbitrary 100 bytes (or 25
instructions).  The problem is that, if the function is shorter than
those 25 instructions, we run the risk of skipping the entire function
and returning a PC that's outside our function.

In the event where we can find a symbol for a given PC (and therefore
can determine function start and end addresses), but cannot find an
upper limit using skip_prologue_using_sal, then we can at least limit
make sure that the 25 instructions do not put us beyour our function.
If it does, then further reduce the upper-limit to the end of the function.

gdb/ChangeLog:

        * rs6000-tdep.c (rs6000_skip_prologue): Make sure that the prologue
        upper limit address is not greater than the function end address
        when the upper limit could not be computed using the debugging
        info.
@
text
@d102 1
a102 1
    && (regnum) < (tdep)->ppc_efpr0_regnum + ppc_num_fprs)
d2724 3
a2726 3
  /* Read the portion that overlaps the VMX registers.  */
  regcache_raw_read (regcache, tdep->ppc_vr0_regnum +
		     reg_index, buffer);
d2737 3
a2739 3
  /* Write the portion that overlaps the VMX registers.  */
  regcache_raw_write (regcache, tdep->ppc_vr0_regnum +
		      reg_index, buffer);
@


1.347
log
@2011-01-11  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Implement support for PowerPC BookE ranged watchpoints.

gdb/
	* breakpoint.h
	(struct breakpoint_ops) <resources_needed>: New method.
	Initialize to NULL in all existing breakpoint_ops instances.
	(struct breakpoint) <exact>: New field.
	(target_exact_watchpoints): Declare external global.
	* breakpoint.c (target_exact_watchpoints): New global flag.
	(update_watchpoint): Set b->type to bp_hardware_watchpoint and
	b->enable_state to bp_enabled before calling
	hw_watchpoint_used_count.
	(hw_watchpoint_used_count): Iterate over all bp_locations in a
	watchpoint.  Call breakpoint's breakpoint_ops.resources_needed
	if available.
	(insert_watchpoint, remove_watchpoint): Use fixed length of 1 byte
	if the watchpoint is exact.
	(resources_needed_watchpoint): New function.
	(watchpoint_breakpoint_ops): Add resources_needed_watchpoint.
	(watch_command_1): Set b->exact if the user asked for an exact
	watchpoint and one can be set.
	(can_use_hardware_watchpoint): Add exact_watchpoints argument.
	Pass fixed length of 1 to target_region_ok_for_hw_watchpoint if
	the user asks for an exact watchpoint and one can be set.  Return
	number of needed debug registers to watch the expression.
	* gdbtypes.c (is_scalar_type): New function, based on
	valprint.c:scalar_type_p.
	(is_scalar_type_recursive): New function.
	* gdbtypes.h (is_scalar_type_recursive): Declare.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint): Always
	handle regions when ranged watchpoints are available.
	(create_watchpoint_request): New function.
	(ppc_linux_insert_watchpoint, ppc_linux_remove_watchpoint): Use
	create_watchpoint_request.
	* rs6000-tdep.c (show_powerpc_exact_watchpoints): New function.
	(_initialize_rs6000_tdep): Add `exact-watchpoints' boolean to the
	`set powerpc' and `show powerpc' commands.
	* target.h (struct target_ops) <to_region_ok_for_hw_watchpoint>:
	Mention documentation comment in the target macro.
	(target_region_ok_for_hw_watchpoint): Document return value.

gdb/doc/
	* gdb.texinfo (PowerPC Embedded): Document ranged watchpoints and
	the "set powerpc exact-watchpoints" flag.
@
text
@d2093 1
a2093 1
  CORE_ADDR limit_pc, func_addr;
d2098 1
a2098 1
  if (find_pc_partial_function (pc, NULL, &func_addr, NULL))
d2116 5
@


1.346
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d4186 10
d4253 13
@


1.345
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d4156 1
a4156 1
    internal_error (__FILE__, __LINE__, "could not update architecture");
d4183 1
a4183 1
    internal_error (__FILE__, __LINE__, "could not update architecture");
@


1.344
log
@run copyright.sh for 2011.
@
text
@d125 1
a125 1
/* To be used by skip_prologue. */
d138 2
a139 2
    char frameless;		/* true if frameless functions. */
    char nosavedpc;		/* true if pc not saved. */
d1020 2
a1021 1
	      regcache_cooked_write_unsigned (regs, gdbarch_pc_regnum (gdbarch),
d1279 1
a1279 1
/* Masks for decoding a branch-and-link (bl) instruction.  
d1321 1
a1321 2
         [repeat this instruction any (small) number of times]
  */
d1343 1
a1343 2
         [possibly one last probe: stw 0,<some immediate>(12)]
  */
d1399 1
a1399 1
      /* [possibly one last probe: stw 0,<some immediate>(12)] */
d1493 1
a1493 2
   - vrsave_offset is the offset of the saved vrsave register
 */
d1541 1
a1541 1
	 Otherwise, we'll assume that it really is a prologue instruction. */
d1626 1
a1626 1
	     instructions. */
d1720 1
a1720 1
				   to save fprs??? */
d1742 2
a1743 1
	      if ((prologue_sal.line == 0) || (prologue_sal.line != this_sal.line))
d1752 1
a1752 1
	     was part of the function prologue. */
d1755 2
a1756 2
	    break;		/* don't skip over 
				   this branch */
d1771 1
a1771 1
	  /* no way to figure out what r1 is going to be */
d1785 1
a1785 1
	  /* no way to figure out what r1 is going to be */
d1799 2
a1800 2
      else if (((op >> 22) == 0x20f	||	/* l r31,... or l r30,... */
	       (op >> 22) == 0x3af)		/* ld r31,... or ld r30,... */
d1813 2
a1814 1
               ((long) ((op >> 16) & 31) >= fdata->saved_gpr)) /* Rx: local var reg */
d1896 1
a1896 1
             if part of the pair of insns mentioned above. So do not
d2054 1
a2054 1
 * sometime. Previously, I used to use misc_function_vector which
d2065 1
a2065 1
    {				/* bl foo, an initializer function? */
d2259 2
a2260 1
  ii = get_frame_register_unsigned (frame, 11);	/* r11 holds destination addr   */
d2738 2
a2739 1
rs6000_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
d3199 1
a3199 1
     All vr's from saved_ev to ev31 are saved. ????? */
d3218 2
a3219 1
    cache->saved_regs[tdep->ppc_cr_regnum].addr = cache->base + fdata.cr_offset;
d3224 2
a3225 1
    cache->saved_regs[tdep->ppc_lr_regnum].addr = cache->base + fdata.lr_offset;
d3235 2
a3236 1
    cache->saved_regs[tdep->ppc_vrsave_regnum].addr = cache->base + fdata.vrsave_offset;
d3958 2
a3959 1
      set_gdbarch_pseudo_register_write (gdbarch, rs6000_pseudo_register_write);
d4017 1
a4017 1
     it shouldn't be. */
d4023 1
a4023 1
  /* Not sure on this. FIXMEmgo */
d4188 2
a4189 1
extern initialize_file_ftype _initialize_rs6000_tdep; /* -Wmissing-prototypes */
@


1.343
log
@Build failure on ppc-aix (bfd_elf_get_obj_attr_int is undefined)

bfd_uses_spe_extensions should only be used when BFD has been built
with ELF support.  The typical way of checking that in GDB is to use
the HAVE_ELF macro.

gdb/ChangeLog:

        * rs6000-tdep.c (bfd_uses_spe_extensions): Use bfd_elf_get_obj_attr_int
        only if HAVE_ELF is defined.
@
text
@d5 1
a5 1
   2010 Free Software Foundation, Inc.
@


1.342
log
@gdb/
	* rs6000-tdep.c (bfd_uses_spe_extensions): New function.
	(rs6000_gdbarch_init): Call it.
@
text
@d3379 1
d3387 1
@


1.341
log
@gdb/
	* rs6000-tdep.c (gdb_print_insn_powerpc): Disassemble e500
	instructions if debugging an E500 binary.
@
text
@d3360 117
d3557 2
a3558 2
     which version of it) can execute it. In our case we just look for
     the existance of the section.  */
d3560 1
a3560 1
  if (info.abfd)
d3562 4
a3565 8
      sect = bfd_get_section_by_name (info.abfd, ".PPC.EMB.apuinfo");
      if (sect)
	{
	  arch = info.bfd_arch_info->arch;
	  mach = bfd_mach_ppc_e500;
	  bfd_default_set_arch_mach (&abfd, arch, mach);
	  info.bfd_arch_info = bfd_get_arch_info (&abfd);
	}
@


1.340
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d3032 13
a3044 1
    info->disassembler_options = "any";
@


1.339
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d4 2
a5 2
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.338
log
@	* gdbarch.sh (displaced_step_hw_singlestep): New callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (default_displaced_step_hw_singlestep): New function.
	* arch-utils.h (default_displaced_step_hw_singlestep): Add prototype.

	* ppc-linux-tdep.c (ppc_displaced_step_hw_singlestep): New function.
	(rs6000_gdbarch_init): Install it.

	* infrun.c (displaced_step_fixup): Use new callback to determine
	whether to "step" or "continue" displaced copy.
	(resume): Likewise.  Do not call maybe_software_singlestep
	for displaced stepping.
	(maybe_software_singlestep): Do not handle displaced stepping.
@
text
@d1087 1
d1161 1
a1161 1
    insert_single_step_breakpoint (gdbarch, breaks[index]);
@


1.337
log
@	* rs6000-tdep.c (rs6000_builtin_type_vec128): Add v2_double
	union member.
@
text
@d1061 9
d3910 2
@


1.336
log
@ChangeLog:

	* features/Makefile: Allow sub-platform specific expedite settings.
	(WHICH): Add rs6000/powerpc-cell32l and rs6000/powerpc-cell64l.
	(rs6000/powerpc-cell32l-expedite): Define.
	(rs6000/powerpc-cell64l-expedite): Likewise.
	* features/rs6000/powerpc-cell32l.xml: New file.
	* features/rs6000/powerpc-cell64l.xml: New file.
	* features/rs6000/powerpc-cell32l.c: New generated file.
	* features/rs6000/powerpc-cell64l.c: New generated file.

	* regformats/rs6000/powerpc-cell32l.dat: New generated file.
	* regformats/rs6000/powerpc-cell64l.dat: New generated file.

	* config/djgpp/fnchange.lst: Add mappings for new files.

	* ppc-linux-tdep.h (tdesc_powerpc_cell32l): Add prototype.
	(tdesc_powerpc_cell64l): Likewise.
	* ppc-linux-tdep.c: Include "features/rs6000/powerpc-cell32l.c"
	and "features/rs6000/powerpc-cell64l.c".
	(_initialize_ppc_linux_tdep): Initialize target descriptions.
	(ppc_linux_spu_section): New function.
	(ppc_linux_core_read_description): Detect Cell/B.E. core files.
	* ppc-linux-nat.c (PPC_FEATURE_CELL): Define.
	(ppc_linux_read_description): Detect Cell/B.E. architecture.

	* rs6000-tdep.c (rs6000_gdbarch_init): Do not trust BFD wordsize
	if exec file is not PowerPC architecture.

gdbserver/ChangeLog:

	* configure.srv (powerpc*-*-linux*): Add powerpc-cell32l.o
	and powerpc-cell64l.o to srv_regobj.  Add rs6000/powerpc-cell32l.xml
	and rs6000/powerpc-cell64l.xml to srv_xmlfiles.
	* Makefile.in (powerpc-cell32l.o, powerpc-cell32l.c): New rules.
	(powerpc-cell64l.o, powerpc-cell64l.c): Likewise.
	(clean): Handle powerpc-cell32l.c and powerpc-cell64l.c.
	* linux-ppc-low.c (PPC_FEATURE_CELL): Define.
	(init_registers_powerpc_cell32l): Add prototype.
	(init_registers_powerpc_cell64l): Likewise.
	(ppc_arch_setup): Detect Cell/B.E. architecture.
@
text
@d2314 1
d2327 2
@


1.336.2.1
log
@	* rs6000-tdep.c (rs6000_builtin_type_vec128): Add v2_double
	union member.
@
text
@a2313 1
	     double v2_double[2];
a2325 2
      append_composite_type_field (t, "v2_double",
				   init_vector_type (bt->builtin_double, 2));
@


1.336.2.2
log
@	* gdbarch.sh (displaced_step_hw_singlestep): New callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (default_displaced_step_hw_singlestep): New function.
	* arch-utils.h (default_displaced_step_hw_singlestep): Add prototype.

	* ppc-linux-tdep.c (ppc_displaced_step_hw_singlestep): New function.
	(rs6000_gdbarch_init): Install it.

	* infrun.c (displaced_step_fixup): Use new callback to determine
	whether to "step" or "continue" displaced copy.
	(resume): Likewise.  Do not call maybe_software_singlestep
	for displaced stepping.
	(maybe_software_singlestep): Do not handle displaced stepping.
@
text
@a1060 9
/* Always use hardware single-stepping to execute the
   displaced instruction.  */
static int
ppc_displaced_step_hw_singlestep (struct gdbarch *gdbarch,
				  struct displaced_step_closure *closure)
{
  return 1;
}

a3900 2
  set_gdbarch_displaced_step_hw_singlestep (gdbarch,
					    ppc_displaced_step_hw_singlestep);
@


1.335
log
@2009-06-26 Michael Eager <eager@@eagercon.com>

	* features/rs6000/powerpc-405.xml: New.
	* rs6000-tdep.c: Add include & initialize for
	powerpc-405.c, add 405 to variants.
	* features/rs6000/powerpc-405.c: Generate.
@
text
@d3363 10
@


1.334
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d69 1
d2952 2
d4044 1
@


1.333
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d877 1
d902 1
a902 1
      insn = extract_unsigned_integer (insn_buf, PPC_INSN_SIZE);
d928 1
a928 1
      insn = extract_unsigned_integer (insn_buf, PPC_INSN_SIZE);
d975 1
d979 1
a979 1
					      PPC_INSN_SIZE);
d1077 1
d1082 1
a1082 1
  int insn = read_memory_integer (loc, PPC_INSN_SIZE);
d1100 1
a1100 1
      insn = read_memory_integer (loc, PPC_INSN_SIZE);
d1135 1
a1135 1
  insn = read_memory_integer (loc, PPC_INSN_SIZE);
d1246 1
a1246 1
bl_to_blrl_insn_p (CORE_ADDR pc, int insn)
d1260 1
a1260 1
  dest_insn = read_memory_integer (dest, 4);
d1282 1
a1282 1
rs6000_fetch_instruction (const CORE_ADDR pc)
d1284 1
d1291 1
a1291 1
  op = extract_unsigned_integer (buf, 4);
d1302 1
a1302 1
rs6000_skip_stack_check (const CORE_ADDR start_pc)
d1305 1
a1305 1
  unsigned long op = rs6000_fetch_instruction (pc);
d1317 1
a1317 1
          op = rs6000_fetch_instruction (pc);
d1343 1
a1343 1
      op = rs6000_fetch_instruction (pc);
d1348 1
a1348 1
      op = rs6000_fetch_instruction (pc);
d1353 1
a1353 1
          op = rs6000_fetch_instruction (pc);
d1361 1
a1361 1
      op = rs6000_fetch_instruction (pc);
d1367 1
a1367 1
      op = rs6000_fetch_instruction (pc);
d1373 1
a1373 1
      op = rs6000_fetch_instruction (pc);
d1379 1
a1379 1
      op = rs6000_fetch_instruction (pc);
d1385 1
a1385 1
      op = rs6000_fetch_instruction (pc);
d1391 1
a1391 1
      op = rs6000_fetch_instruction (pc);
d1395 1
a1395 1
          op = rs6000_fetch_instruction (pc);
d1432 1
a1432 1
          op = rs6000_fetch_instruction (pc);
d1439 1
a1439 1
      op = rs6000_fetch_instruction (pc);
d1445 1
a1445 1
      op = rs6000_fetch_instruction (pc);
d1451 1
a1451 1
      op = rs6000_fetch_instruction (pc);
d1511 1
d1523 1
a1523 1
  pc = rs6000_skip_stack_check (pc);
d1545 1
a1545 1
      op = extract_unsigned_integer (buf, 4);
d1717 1
a1717 1
          if (lr_reg != -1 && bl_to_blrl_insn_p (pc, op))
d1737 1
a1737 1
	  op = read_memory_integer (pc + 4, 4);
d2055 1
a2055 1
      op = read_memory_integer (pc + 4, 4);
d2120 1
d2126 1
a2126 1
  op = extract_unsigned_integer (buf, 4);
d2177 2
a2178 1
rs6000_in_solib_return_trampoline (CORE_ADDR pc, char *name)
d2200 3
a2202 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
d2223 2
a2224 1
      && rs6000_in_solib_return_trampoline (pc, SYMBOL_LINKAGE_NAME (msymbol)))
d2227 1
a2227 1
      op = read_memory_integer (pc + 8, 4);
d2244 1
a2244 1
      op = read_memory_integer (pc + (ii * 4), 4);
d2249 1
a2249 1
  pc = read_memory_unsigned_integer (ii, tdep->wordsize); /* (r11) value */
d3052 1
d3110 2
a3111 1
    cache->base = read_memory_unsigned_integer (cache->base, wordsize);
@


1.332
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d986 2
a987 2
			"displaced: (ppc) fixup (0x%s, 0x%s)\n",
			paddr_nz (from), paddr_nz (to));
d1012 4
a1015 4
		   "displaced: (ppc) branch instruction: 0x%s\n"
		   "displaced: (ppc) adjusted PC from 0x%s to 0x%s\n",
		   paddr_nz (insn), paddr_nz (current_pc),
		   paddr_nz (from + offset));
d1043 2
a1044 2
				    "displaced: (ppc) adjusted LR to 0x%s\n",
				    paddr_nz (from + PPC_INSN_SIZE));
@


1.331
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d1074 1
d1147 1
a1147 1
    insert_single_step_breakpoint (breaks[index]);
@


1.330
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d2267 2
a2268 1
      t = init_composite_type ("__ppc_builtin_type_vec64", TYPE_CODE_UNION);
d2311 2
a2312 1
      t = init_composite_type ("__ppc_builtin_type_vec128", TYPE_CODE_UNION);
@


1.329
log
@	* dummy-frame.c (deprecated_pc_in_call_dummy): Add GDBARCH parameter,
	use it instead of current_gdbarch.
	* frame.h (deprecated_pc_in_call_dummy): Add GDBARCH parameter.
	* arm-tdep.c (arm_skip_prologue): Pass architecture to
	deprecated_pc_in_call_dummy.

	* symtab.c (skip_prologue_using_sal): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	* symtab.h (skip_prologue_using_sal): Add GDBARCH parameter.
	* breakpoint.c (expand_line_sal_maybe): Pass architecture to
	skip_prologue_using_sal.
	* arm-tdep.c (skip_prologue_using_sal): Likewise.
	* lm32-tdep.c (lm32_skip_prologue): Likewise.
	* m32-tdep.c (m32c_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* moxie-tdep.c (moxie_skip_prologue): Likewise.
	* mt-tdep.c (mt_frame_unwind_cache): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* frv-tdep.c (frv_analyze_prologue): Add GDBARCH parameter, pass
	it to skip_prologue_using_sal.  Update call sites ...
	(frv_skip_prologue, frv_frame_unwind_cache): ... here.

	* mn10300-tdep.c (struct mn10300_prologue): Add GDBARCH member.
	(check_for_saved): Use it instead of current_gdbarch.
	(mn10300_analyze_prologue): Set it.

	* value.c (using_struct_return): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.
	* value.h (using_struct_return): Add GDBARCH parameter.
	* eval.c (evaluate_subexp_standard): Pass architecture to
	using_struct_return.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* symtab.c (in_prologue): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.
	* symtab.h (in_prologue): Add GDBARCH parameter.
	* infrun.c (handle_inferior_event): Pass architecture to in_prologue.

	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* c-lang.c (evaluate_subexp_c): Use expression architecture and
	language instead of current_gdbarch and current_language.

	* printcmd.c (do_one_display): Use expression architecture instead
	of current_gdbarch.

	* infcmd.c (print_return_value): Use architecture of stop_regcache
	instead of current_gdbarch.
	(print_vector_info, print_float_info): Remove GDBARCH argument,
	use frame architecture instead.
	(vector_info, float_info): Update calls.

	* objc-lang.c (objc_skip_trampoline): Use frame architecture
	instead of current_gdbarch.

	* parse.c (write_dollar_variable): Use parse architecture instead
	of current_gdbarch.

	* source.c (line_info): Use objfile architecture instead of
	current_gdbarch.

	* symtab.c (find_function_start_sal): Use gdbarch instead of
	current_gdbarch.
	(print_msymbol_info): Use objfile architecture instead of
	current_gdbarch.

	* valops.c (value_assign): Use frame architecture instead of
	current_gdbarch.
@
text
@d2251 2
d2268 1
a2268 1
      append_composite_type_field (t, "uint64", builtin_type_int64);
d2270 1
a2270 2
				   init_vector_type (builtin_type (gdbarch)
						     ->builtin_float, 2));
d2272 1
a2272 1
				   init_vector_type (builtin_type_int32, 2));
d2274 1
a2274 1
				   init_vector_type (builtin_type_int16, 4));
d2276 1
a2276 1
				   init_vector_type (builtin_type_int8, 8));
d2295 2
d2311 1
a2311 1
      append_composite_type_field (t, "uint128", builtin_type_uint128);
d2313 1
a2313 1
				   init_vector_type (builtin_type (gdbarch)->builtin_float, 4));
d2315 1
a2315 1
				   init_vector_type (builtin_type_int32, 4));
d2317 1
a2317 1
				   init_vector_type (builtin_type_int16, 8));
d2319 1
a2319 1
				   init_vector_type (builtin_type_int8, 16));
@


1.328
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d2083 2
a2084 1
      CORE_ADDR post_prologue_pc = skip_prologue_using_sal (func_addr);
d2095 1
a2095 1
  limit_pc = skip_prologue_using_sal (pc);
@


1.327
log
@        Updated copyright notices for most files.
@
text
@d219 1
a219 1
int
d968 1
a968 1
void
d970 3
a972 3
			   struct displaced_step_closure *closure,
			   CORE_ADDR from, CORE_ADDR to,
			   struct regcache *regs)
d2110 1
a2110 1
CORE_ADDR
d2168 1
a2168 1
int
d2188 1
a2188 1
CORE_ADDR
@


1.326
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.325
log
@	* rs6000-tdep.c (rs6000_fetch_instruction)
	(rs6000_skip_stack_check): New functions.
	(skip_prologue): Skip stack check sequence.
@
text
@d2267 2
a2268 1
				   init_vector_type (builtin_type_float, 2));
d2466 2
a2467 1
	  && TYPE_LENGTH (type) != TYPE_LENGTH (builtin_type_double));
d2476 1
d2482 2
a2483 1
  convert_typed_floating (from, builtin_type_double, to, type);
d2492 1
d2497 2
a2498 1
  convert_typed_floating (from, type, to, builtin_type_double);
@


1.324
log
@	* rs6000-tdep.c (rs6000_gdbarch_init): Setup displaced stepping
	*before* calling gdbarch_init_osabi.
	(rs6000_aix_init_osabi): Disable displaced stepping.
@
text
@d1277 181
d1517 4
@


1.323
log
@	* rs6000-tdep.c (rs6000_builtin_type_vec128): Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-vsx32l.c
	(initialize_tdesc_powerpc_vsx32l): Update.
	* features/rs6000/powerpc-vsx32.c
	(initialize_tdesc_powerpc_vsx32): Update.
	* features/rs6000/powerpc-vsx64.c
	(initialize_tdesc_powerpc_vsx64): Update.
	* features/rs6000/powerpc-vsx64l.c
	(initialize_tdesc_powerpc_vsx64l): Update.
	* target-descriptions.c (maint_print_c_tdesc_cmd): Emit
	TYPE_VECTOR, not TYPE_FLAGS.
@
text
@d3672 11
a3745 11
  /* Setup displaced stepping.  */
  set_gdbarch_displaced_step_copy_insn (gdbarch,
					simple_displaced_step_copy_insn);
  set_gdbarch_displaced_step_fixup (gdbarch, ppc_displaced_step_fixup);
  set_gdbarch_displaced_step_free_closure (gdbarch,
					   simple_displaced_step_free_closure);
  set_gdbarch_displaced_step_location (gdbarch,
				       displaced_step_at_entry_point);

  set_gdbarch_max_insn_length (gdbarch, PPC_INSN_SIZE);

@


1.322
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d2131 1
a2131 1
      TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
@


1.321
log
@	* rs6000-tdep.c (struct rs6000_framedata): Add gpr_mask, used_bl,
	lr_register.
	(rs6000_in_function_epilogue_p): Check for bctr.
	(skip_prologue): Initialize lr_register.  Set lr_reg to a register
	number.  Set gpr_mask and used_bl.  Continue scanning while some
	expected registers are not saved.  Set lr_register if LR is not
	stored.
	(rs6000_frame_cache): Handle gpr_mask and lr_register.

	* gdb.arch/powerpc-prologue.exp: Correct saved registers.
@
text
@d2090 1
a2090 1
      TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
@


1.320
log
@	* rs6000-tdep: Include "features/rs6000/powerpc-vsx32.c".
	Include "features/rs6000/powerpc-vsx64.c".
	(ppc_supply_vsxregset): New function.
	(ppc_collect_vsxregset): New function.
	(IS_VSX_PSEUDOREG): New macro.
	(IS_EFP_PSEUDOREG): New macro.
	(vsx_register_p): New function.
	(ppc_vsx_support_p): New function.
	(rs6000_builtin_type_vec128): New function.
	(rs6000_register_name): Hide upper halves of vs0~vs31.  Return
	correct names for VSX registers and EFPR registers.
	(rs6000_pseudo_register_type): Return correct types for VSX
	and EFPR registers.
	(rs6000_pseudo_register_reggroup_p): Return correct group for
	VSX and EFPR registers.
	(ppc_pseudo_register_read): Rename to dfp_pseudo_register_read.
	(ppc_pseudo_register_write): Rename to dfp_pseudo_register_write.
	(vsx_pseudo_register_read): New function.
	(vsx_pseudo_register_write): New function.
	(efpr_pseudo_register_read): New function.
	(efpr_pseudo_register_write): New function.
	(rs6000_pseudo_register_read): Call new VSX and EFPR read functions.
	(rs6000_pseudo_register_write): Call new VSX and EFPR write functions.
	(rs6000_gdbarch_init): Declare have_vsx.
	Initialize new upper half VSX registers.
	Initialize VSX-related and EFPR-related pseudo-registers variables.
	Adjust the number of pseudo registers accordingly.

	* ppc-linux-nat.c: Define PTRACE_GETVSXREGS, PTRACE_SETVSXREGS
	and SIZEOF_VSRREGS.
	(gdb_vsxregset_t): New type.
	(have_ptrace_getsetvsxregs): New variable.
	(fetch_vsx_register): New function.
	(fetch_register): Handle VSX registers.
	(fetch_vsx_registers): New function.
	(fetch_ppc_registers): Handle VSX registers.
	(store_ppc_registers): Handle VSX registers.
	(store_vsx_register): New function.
	(store_register): Handle VSX registers.
	(store_vsx_registers): New function.
	(ppc_linux_read_description): Handle VSX-enabled inferiors.
	(gdb_vsxregset_t): New type.
	(supply_vsxregset): New function.
	(fill_vsxregset): New function.

	* ppc-tdep.h (vsx_register_p): New prototype.
	(vsx_support_p): New prototype.
	(ppc_vsr0_regnum): New variable.
	(ppc_vsr0_upper_regnum): Likewise.
	(ppc_efpr0_regnum): Likewise.
	(ppc_builtin_type_vec128): New type.
	(ppc_num_vsrs): New constant.
	(ppc_num_vshrs): New constant.
	(ppc_num_efprs): Likewise.
	Define POWERPC_VEC_VSX PPC_VSR0_UPPER_REGNUM and PPC_VSR31_UPPER_REGNUM.
	(ppc_supply_vsxregset): New prototype.
	(ppc_collect_vsxregset): New prototype.

	* ppc-linux-tdep.c: Include "features/rs6000/powerpc-vsx32l.c"
	Include "features/rs6000/powerpc-vsx64l.c".
	(_initialize_ppc_linux_tdep): Initialize VSX-enabled targets.
	(ppc_linux_regset_sections): Add new ".reg-ppc-vsx" field.
	(ppc32_linux_vsxregset): New 32-bit VSX-enabled regset.
	(ppc_linux_regset_from_core_section): Handle VSX core section.
	(ppc_linux_core_read_description): Support VSX-enabled core files.

	* ppc-linux-tdep.h: Declare *tdesc_powerpc_vsx32l
	Declare tdesc_powerpc_vsx64l

	* corelow.c (get_core_register_section): Support VSX-enabled
	core files.

	* features/rs6000/power-vsx.xml: New VSX descriptions.
	* features/rs6000/powerpc-vsx32.xml: New file.
	* features/rs6000/powerpc-vsx32l.xml: New file.
	* features/rs6000/powerpc-vsx64.xml: New file.
	* features/rs6000/powerpc-vsx64l.xml: New file.
	* features/rs6000/powerpc-vsx32.c: New file (generated).
	* features/rs6000/powerpc-vsx32l.c: New file (generated).
	* features/rs6000/powerpc-vsx64.c: New file (generated).
	* features/rs6000/powerpc-vsx64l.c: New file (generated).
	* features/Makefile: Updated with new descriptions.
	* regformats/rs6000/powerpc-vsx32l.dat: New file (generated).
	* regformats/rs6000/powerpc-vsx64l.dat: New file (generated).

	* testsuite/gdb.arch/vsx-regs.c: New source file.
	* testsuite/gdb.arch/vsx-regs.exp: New testcase.
	* testsuite/lib/gdb.exp (skip_vsx_tests): New function.
@
text
@d132 1
d139 1
d145 1
d876 1
d904 11
d1334 1
d1376 1
a1376 1
	    lr_reg = (op & 0x03e00000);
d1407 4
d1502 1
d1527 4
a1530 1
	    continue;
d1556 2
a1558 1

d1819 2
d1824 4
a1827 2
	     address is not yet saved in the frame.  */
	  if (fdata->frameless == 0 && fdata->nosavedpc == 0)
d1880 3
d2927 2
a2928 1
     All gpr's from saved_gpr to gpr31 are saved.  */
d2936 2
a2937 1
	  cache->saved_regs[tdep->ppc_gp0_regnum + i].addr = gpr_addr;
d2984 2
@


1.319
log
@ 	* rs6000-tdep.c (BL_MASK, BL_INSTRUCTION, BL_DISPLACEMENT_MASK):
 	New macros.
 	(rs6000_skip_main_prologue): New function.
 	(rs6000_gdb_arch_init): Register rs6000_skip_main_prologue.
@
text
@d66 1
d76 1
d93 10
d148 12
d215 10
d576 31
d737 34
d2066 41
d2123 6
d2153 30
d2196 3
a2198 1
	      || IS_DFP_PSEUDOREG (tdep, regnum));
d2203 6
d2210 2
a2211 2
    /* Could only be the ppc decimal128 pseudo-registers.  */
    return builtin_type (gdbarch)->builtin_declong;
d2223 3
a2225 1
	      || IS_DFP_PSEUDOREG (tdep, regnum));
d2227 2
a2228 2
  /* These are the e500 pseudo-registers.  */
  if (IS_SPE_PSEUDOREG (tdep, regnum))
d2231 1
a2231 1
    /* Could only be the ppc decimal128 pseudo-registers.  */
d2345 1
a2345 2
/* Read method for PPC pseudo-registers. Currently this is handling the
   16 decimal128 registers that map into 16 pairs of FP registers.  */
d2347 1
a2347 1
ppc_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
d2370 1
a2370 2
/* Write method for PPC pseudo-registers. Currently this is handling the
   16 decimal128 registers that map into 16 pairs of FP registers.  */
d2372 1
a2372 1
ppc_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
d2396 86
d2494 5
a2498 1
    ppc_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);
d2519 5
a2523 1
    ppc_pseudo_register_write (gdbarch, regcache, reg_nr, buffer);
d3106 2
a3107 1
  int have_fpu = 1, have_spe = 0, have_mq = 0, have_altivec = 0, have_dfp = 0;
d3112 1
d3307 32
d3522 1
d3551 1
a3551 1
  if (have_spe || have_dfp)
d3571 3
d3670 5
a3674 2
  /* Recording the numbering of pseudo registers.  */
  tdep->ppc_ev0_regnum = have_spe ? gdbarch_num_regs (gdbarch) : -1;
d3676 19
a3694 2
  /* Set the register number for _Decimal128 pseudo-registers.  */
  tdep->ppc_dl0_regnum = have_dfp? gdbarch_num_regs (gdbarch) : -1;
d3696 2
a3697 3
  if (have_dfp && have_spe)
    /* Put the _Decimal128 pseudo-registers after the SPE registers.  */
    tdep->ppc_dl0_regnum += 32;
d3792 1
d3802 1
@


1.318
log
@* frame.c (frame_func_unwind): Delete.

(get_frame_func): Do not use it.
* frame.h (frame_func_unwind): Delete prototype.
* hppa-tdep.c (hppa_frame_cache): Update comment.
* rs6000-tdep.c (rs6000_frame_cache): Update comment.
@
text
@d1149 14
d1786 35
d3290 1
@


1.317
log
@	* rs6000-tdep.c (ppc_displaced_step_fixup): Change type of
	`current_pc' from CORE_ADDR to ULONGEST.
@
text
@d2512 1
a2512 1
     frame_func_unwind returns the wrong address or 0), and assembly
@


1.316
log
@	* rs6000-tdep.c (ppc_displaced_step_fixup): New function.
	(deal_with_atomic_sequence): Update BC masks.
	(rs6000_gdbarch_init): Init displaced stepping infra-structure.
	Define BRANCH_MASK, B_INSN, BC_INSN, BXL_INSN, BP_MASK and BP_INSN.
@
text
@d879 1
a879 1
      CORE_ADDR current_pc;
@


1.315
log
@	* rs6000-tdep.c (rs6000_gdbarch_init): Set up info.target_desc
	and info.tdep_info before calling gdbarch_init_osabi.
@
text
@d844 99
a950 2
#define BC_MASK 0xfc000000
#define BC_INSTRUCTION 0x40000000
d987 1
a987 1
      if ((insn & BC_MASK) == BC_INSTRUCTION)
d3314 11
@


1.314
log
@	* rs6000-tdep.c (rs6000_frame_this_id): If info->base is 0,
	return the null frame ID to terminate the backtrace.
@
text
@d3174 2
@


1.313
log
@	* rs6000-tdep.c: Do not include "rs6000-tdep.h".
	(rs6000_find_toc_address_hook): Move to rs6000-aix-tdep.c.
	(SIG_FRAME_PC_OFFSET): Likewise.
	(SIG_FRAME_LR_OFFSET): Likewise.
	(SIG_FRAME_FP_OFFSET): Likewise.
	(rs6000_push_dummy_call): Likewise.
	(rs6000_return_value): Likewise.
	(rs6000_convert_from_func_ptr_addr): Likewise.
	(branch_dest, rs6000_software_single_step): Likewise.
	(deal_with_atomic_sequence): Rename to ...
	(ppc_deal_with_atomic_sequence): ... this.  Adapt all callers.
	Do not call branch_dest; inline required parts of that function.
	(rs6000_skip_trampoline_code): Replace DEPRECATED_SYMBOL_NAME
	with SYMBOL_LINKAGE_NAME.
	(struct reg, regsize): Delete.
	(read_memory_addr): Delete; inline into callers.
	(rs6000_skip_prologue): Move after skip_prologue.
	(skip_prologue): Remove prototype.
	(rs6000_gdbarch_init): Remove sysv_abi variable; perform all
	initialization as if this variable were true.  Do not install
	ppc64_sysv_abi_adjust_breakpoint_address.

	* rs6000-aix-tdep.c: Include "gdb_assert.h", "gdbtypes.h",
	"gdbcore.h", "target.h", "value.h", "infcall.h", "objfiles.h",
	and "breakpoint.h".
	(rs6000_find_toc_address_hook): Move here from rs6000-tdep.c.
	(SIG_FRAME_PC_OFFSET): Likewise.
	(SIG_FRAME_LR_OFFSET): Likewise.
	(SIG_FRAME_FP_OFFSET): Likewise.
	(rs6000_push_dummy_call): Likewise.
	(rs6000_return_value): Likewise.
	(rs6000_convert_from_func_ptr_addr): Likewise.
	(branch_dest, rs6000_software_single_step): Likewise.  Replace
	tdep->text_segment_base by AIX_TEXT_SEGMENT_BASE.
	(rs6000_aix_init_osabi): Install rs6000_push_dummy_call,
	rs6000_return_value, and rs6000_convert_from_func_ptr_addr.
	Call set_gdbarch_long_double_bit and set_gdbarch_frame_red_zone_size.
	Set tdep->lr_frame_offset.  Do not set tdep->text_segment_base.

	* rs6000-tdep.h (rs6000_software_single_step): Remove prototype.
	(AIX_TEXT_SEGMENT_BASE): New macro.
	* rs6000-nat.c (exec_one_dummy_insn): Replace tdep->text_segment_base
	by AIX_TEXT_SEGMENT_BASE.

	* ppc-tdep.h (ppc_deal_with_atomic_sequence): Add prototype.
	(struct gdbarch_tdep): Remove text_segment_base member.
	* ppc-linux-tdep.c (ppc_linux_init_abi): On 64-bit, install
	ppc64_sysv_abi_adjust_breakpoint_address.

	* Makefile.in (rs6000-tdep.o): Update dependencies.
	(rs6000-aix-tdep.o): Likewise.
@
text
@d2553 4
@


1.312
log
@ChangeLog:

	* Makefile.in (ppc_linux_tdep_h): New macro.
	(powerpc_32l_c, powerpc_altivec32_c, powerpc_altivec32l_c): Likewise.
	(powerpc_64l_c, powerpc_altivec64_c, powerpc_altivec64l_c): Likewise.
	(powerpc_e500l_c): Likewise.
	(ppc-linux-nat.o): Update dependencies.
	(ppc-linux-tdep.o): Update dependencies.
	(rs6000-tdep.o): Update dependencies.

	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Remove.
	(ppc_linux_svr4_fetch_link_map_offsets): Remove.
	(ppc_linux_gregset, ppc_linux_fpregset): Move to ppc-linux-tdep.h
	(ppc_supply_reg, ppc_collect_reg): Add prototypes.
	(tdesc_powerpc_e500): Remove.

	* rs6000.c: Include "features/rs6000/powerpc-altivec32.c"
	and "features/rs6000/powerpc-altivec64.c".
	(ppc_supply_reg, ppc_collect_reg): Make global.
	(variants): Use tdesc_powerpc_32 for "powerpc" and
	tdesc_powerpc_altivec64 for "powerpc64".
	(_initialize_rs6000_tdep): Initialize AltiVec descriptions.

	* ppc-linux-tdep.h: New file.

	* ppc-linux-tdep.c: Include "ppc-linux-tdep.c".
	Include "features/rs6000/powerpc-32l.c".
	Include "features/rs6000/powerpc-altivec32l.c".
	Include "features/rs6000/powerpc-64l.c".
	Include "features/rs6000/powerpc-altivec64l.c".
	Include "features/rs6000/powerpc-e500l.c".
	(ppc_linux_supply_gregset): New function.
	(ppc_linux_collect_gregset): Handle orig_r3 and trap registers.
	(ppc32_linux_gregset): Use ppc_linux_supply_gregset.
	(ppc64_linux_gregset): Likewise.
	(ppc_linux_sigtramp_cache): Handle orig_r3 and trap registers.
	(ppc_linux_trap_reg_p): New function.
	(ppc_linux_write_pc): New function.
	(ppc_linux_core_read_description): New function.
	(ppc_linux_init_abi): Install ppc_linux_write_pc and
	ppc_linux_core_read_description.  Install orig_r3 and trap
	registers if present in the target description.
	(_initialize_ppc_linux_tdep): Initialize Linux target descriptions.

	* ppc-linux-nat.c: Include "ppc-linux-tdep.h".
	(PT_ORIG_R3, PT_TRAP): Define if necessary.
	(ppc_register_u_addr): Handle orig_r3 and trap registers.
	(fetch_ppc_registers): Likewise.
	(store_ppc_registers): Likewise.
	(store_register): Likewise.
	(ppc_linux_read_description): Check whether AltiVec is supported.
	Check whether inferior is 32-bit or 64-bit.  Return the appropriate
	Linux target description.

	* features/Makefile (WHICH): Use rs6000/powerpc-32l and
	rs6000/powerpc-altivec32l instead of rs6000/powerpc-32.
	Use rs6000/powerpc-64l and rs6000/powerpc-altivec64l instead
	of rs6000/powerpc-64.  Use rs6000/powerpc-e500l instead of
	rs6000/powerpc-e500.  Update -expedite variables accordingly.

	* features/rs6000/power-spe.xml: Use regnum 73 for "acc".
	* features/rs6000/powerpc-32.xml: Do not include power-altivec.xml.
	* features/rs6000/powerpc-64.xml: Do not include power-altivec.xml.
	* features/rs6000/powerpc-e500.c: Regenerate.
	* features/rs6000/powerpc-32.c: Regenerate.
	* features/rs6000/powerpc-64.c: Regenerate.

	* features/rs6000/power-linux.xml: New file.
	* features/rs6000/power64-linux.xml: New file.
	* features/rs6000/powerpc-32l.xml: New file.
	* features/rs6000/powerpc-altivec32l.xml: New file.
	* features/rs6000/powerpc-64l.xml: New file.
	* features/rs6000/powerpc-altivec64l.xml: New file.
	* features/rs6000/powerpc-e500l.xml: New file.
	* features/rs6000/powerpc-32l.c: New (generated) file.
	* features/rs6000/powerpc-altivec32l.c: New (generated) file.
	* features/rs6000/powerpc-64l.c: New (generated) file.
	* features/rs6000/powerpc-altivec64l.c: New (generated) file.
	* features/rs6000/powerpc-e500l.xml: New (generated) file.

	* regformats/reg-ppc.dat: Remove.
	* regformats/reg-ppc64.dat: Remove.
	* regformats/rs6000/powerpc-32.dat: Remove.
	* regformats/rs6000/powerpc-64.dat: Remove.
	* regformats/rs6000/powerpc-e500.dat: Remove.
	* regformats/rs6000/powerpc-32l.dat: New (generated) file.
	* regformats/rs6000/powerpc-altivec32l.dat: New (generated) file.
	* regformats/rs6000/powerpc-64l.dat: New (generated) file.
	* regformats/rs6000/powerpc-altivec64l.dat: New (generated) file.
	* regformats/rs6000/powerpc-e500l.dat: New (generated) file.

gdbserver/ChangeLog:

	* configure.srv (powerpc*-*-linux*): Set srv_regobj to
	powerpc-32l.o, powerpc-altivec32l.o, powerpc-e500l.o,
	powerpc-64l.o, and powerpc-altivec64l.o.
	Remove rs6000/powerpc-32.xml, rs6000/powerpc-64.xml, and
	rs6000/powerpc-e500.xml; add rs6000/powerpc-32l.xml,
	rs6000/powerpc-altivec32l.xml, rs6000/powerpc-e500l.xml,
	rs6000/powerpc-64l.xml, rs6000/powerpc-altivec64l.xml,
	rs6000/power-linux.xml, and rs6000/power64-linux.xml
	to srv_xmlfiles.

	* Makefile.in (reg-ppc.o, reg-ppc.c): Remove, replace by ...
	(powerpc-32l.o, powerpc-32l.c): ... these new rules.
	(powerpc-32.o, powerpc-32.c): Remove, replace by ...
	(powerpc-altivec32l.o, powerpc-altivec32l.c): ... these new rules.
	(powerpc-e500.o, powerpc-e500.c): Remove, replace by ...
	(powerpc-e500l.o, powerpc-e500l.c): ... these new rules.
	(reg-ppc64.o, reg-ppc64.c): Remove, replace by ...
	(powerpc-64l.o, powerpc-64l.c): ... these new rules.
	(powerpc-64.o, powerpc-64.c): Remove, replace by ...
	(powerpc-altivec64l.o, powerpc-altivec64l.c): ... these new rules.
	(clean): Update.

	* linux-ppc-low.c (init_registers_ppc): Remove, replace by ...
	(init_registers_powerpc_32l): ... this new prototype.
	(init_registers_powerpc_32): Remove, replace by ...
	(init_registers_powerpc_altivec32l): ... this new prototype.
	(init_registers_powerpc_e500): Remove, replace by ...
	(init_registers_powerpc_e500l): ... this new prototype.
	(init_registers_ppc64): Remove, replace by ...
	(init_registers_powerpc_64l): ... this new prototype.
	(init_registers_powerpc_64): Remove, replace by ...
	(init_registers_powerpc_altivec64l): ... this new prototype.
	(ppc_num_regs): Set to 73.
	(PT_ORIG_R3, PT_TRAP): Define if necessary.
	(ppc_regmap, ppc_regmap_e500): Add values for orig_r3 and trap.
	(ppc_cannot_store_register): Handle orig_r3 and trap.
	(ppc_arch_setup): Update init_registers_... calls.
	(ppc_fill_gregset): Handle orig_r3 and trap.

	* inferiors.c (clear_inferiors): Reset current_inferior.
@
text
@a63 2
#include "rs6000-tdep.h"

a111 11
/* If the kernel has to deliver a signal, it pushes a sigcontext
   structure on the stack and then calls the signal handler, passing
   the address of the sigcontext in an argument register. Usually
   the signal handler doesn't save this register, so we have to
   access the sigcontext structure via an offset from the signal handler
   frame.
   The following constants were determined by experimentation on AIX 3.2.  */
#define SIG_FRAME_PC_OFFSET 96
#define SIG_FRAME_LR_OFFSET 108
#define SIG_FRAME_FP_OFFSET 284

a134 26
/* Description of a single register. */

struct reg
  {
    char *name;			/* name of register */
    unsigned char sz32;		/* size on 32-bit arch, 0 if nonexistent */
    unsigned char sz64;		/* size on 64-bit arch, 0 if nonexistent */
    unsigned char fpr;		/* whether register is floating-point */
    unsigned char pseudo;       /* whether register is pseudo */
    int spr_num;                /* PowerPC SPR number, or -1 if not an SPR.
                                   This is an ISA SPR number, not a GDB
                                   register number.  */
  };

/* Hook for determining the TOC address when calling functions in the
   inferior under AIX. The initialization code in rs6000-nat.c sets
   this hook to point to find_toc_address.  */

CORE_ADDR (*rs6000_find_toc_address_hook) (CORE_ADDR) = NULL;

/* Static function prototypes */

static CORE_ADDR branch_dest (struct frame_info *frame, int opcode,
			      int instr, CORE_ADDR pc, CORE_ADDR safety);
static CORE_ADDR skip_prologue (struct gdbarch *, CORE_ADDR, CORE_ADDR,
                                struct rs6000_framedata *);
a718 38
/* Read a LEN-byte address from debugged memory address MEMADDR. */

static CORE_ADDR
read_memory_addr (CORE_ADDR memaddr, int len)
{
  return read_memory_unsigned_integer (memaddr, len);
}

static CORE_ADDR
rs6000_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  struct rs6000_framedata frame;
  CORE_ADDR limit_pc, func_addr;

  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
  if (find_pc_partial_function (pc, NULL, &func_addr, NULL))
    {
      CORE_ADDR post_prologue_pc = skip_prologue_using_sal (func_addr);
      if (post_prologue_pc != 0)
	return max (pc, post_prologue_pc);
    }

  /* Can't determine prologue from the symbol table, need to examine
     instructions.  */

  /* Find an upper limit on the function prologue using the debug
     information.  If the debug information could not be used to provide
     that bound, then use an arbitrary large number as the upper bound.  */
  limit_pc = skip_prologue_using_sal (pc);
  if (limit_pc == 0)
    limit_pc = pc + 100;          /* Magic.  */

  pc = skip_prologue (gdbarch, pc, limit_pc, &frame);
  return pc;
}

a828 69
/* Calculate the destination of a branch/jump.  Return -1 if not a branch.  */

static CORE_ADDR
branch_dest (struct frame_info *frame, int opcode, int instr,
	     CORE_ADDR pc, CORE_ADDR safety)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
  CORE_ADDR dest;
  int immediate;
  int absolute;
  int ext_op;

  absolute = (int) ((instr >> 1) & 1);

  switch (opcode)
    {
    case 18:
      immediate = ((instr & ~3) << 6) >> 6;	/* br unconditional */
      if (absolute)
	dest = immediate;
      else
	dest = pc + immediate;
      break;

    case 16:
      immediate = ((instr & ~3) << 16) >> 16;	/* br conditional */
      if (absolute)
	dest = immediate;
      else
	dest = pc + immediate;
      break;

    case 19:
      ext_op = (instr >> 1) & 0x3ff;

      if (ext_op == 16)		/* br conditional register */
	{
          dest = get_frame_register_unsigned (frame, tdep->ppc_lr_regnum) & ~3;

	  /* If we are about to return from a signal handler, dest is
	     something like 0x3c90.  The current frame is a signal handler
	     caller frame, upon completion of the sigreturn system call
	     execution will return to the saved PC in the frame.  */
	  if (dest < tdep->text_segment_base)
	    dest = read_memory_addr (get_frame_base (frame) + SIG_FRAME_PC_OFFSET,
				     tdep->wordsize);
	}

      else if (ext_op == 528)	/* br cond to count reg */
	{
          dest = get_frame_register_unsigned (frame, tdep->ppc_ctr_regnum) & ~3;

	  /* If we are about to execute a system call, dest is something
	     like 0x22fc or 0x3b00.  Upon completion the system call
	     will return to the address in the link register.  */
	  if (dest < tdep->text_segment_base)
            dest = get_frame_register_unsigned (frame, tdep->ppc_lr_regnum) & ~3;
	}
      else
	return -1;
      break;

    default:
      return -1;
    }
  return (dest < tdep->text_segment_base) ? safety : dest;
}


d860 2
a861 2
static int 
deal_with_atomic_sequence (struct frame_info *frame)
a865 1
  CORE_ADDR branch_bp; /* Breakpoint at branch instruction's destination.  */
d892 3
d898 8
a905 10
          
          opcode = insn >> 26;
          branch_bp = branch_dest (frame, opcode, insn, pc, breaks[0]);
          
          if (branch_bp != -1)
            {
              breaks[1] = branch_bp;
              bc_insn_count++;
              last_breakpoint++;
            }
a939 42
/* AIX does not support PT_STEP.  Simulate it.  */

int
rs6000_software_single_step (struct frame_info *frame)
{
  CORE_ADDR dummy;
  int breakp_sz;
  const gdb_byte *breakp
    = rs6000_breakpoint_from_pc (get_frame_arch (frame), &dummy, &breakp_sz);
  int ii, insn;
  CORE_ADDR loc;
  CORE_ADDR breaks[2];
  int opcode;

  loc = get_frame_pc (frame);

  insn = read_memory_integer (loc, 4);

  if (deal_with_atomic_sequence (frame))
    return 1;
  
  breaks[0] = loc + breakp_sz;
  opcode = insn >> 26;
  breaks[1] = branch_dest (frame, opcode, insn, loc, breaks[0]);

  /* Don't put two breakpoints on the same address. */
  if (breaks[1] == breaks[0])
    breaks[1] = -1;

  for (ii = 0; ii < 2; ++ii)
    {
      /* ignore invalid breakpoint. */
      if (breaks[ii] == -1)
	continue;
      insert_single_step_breakpoint (breaks[ii]);
    }

  errno = 0;			/* FIXME, don't ignore errors! */
  /* What errors?  {read,write}_memory call error().  */
  return 1;
}

a1644 30

/*************************************************************************
  Support for creating pushing a dummy frame into the stack, and popping
  frames, etc. 
*************************************************************************/


/* All the ABI's require 16 byte alignment.  */
static CORE_ADDR
rs6000_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return (addr & -16);
}

/* Pass the arguments in either registers, or in the stack. In RS/6000,
   the first eight words of the argument list (that might be less than
   eight parameters if some parameters occupy more than one word) are
   passed in r3..r10 registers.  float and double parameters are
   passed in fpr's, in addition to that.  Rest of the parameters if any
   are passed in user stack.  There might be cases in which half of the
   parameter is copied into registers, the other half is pushed into
   stack.

   Stack must be aligned on 64-bit boundaries when synthesizing
   function calls.

   If the function is returning a structure, then the return address is passed
   in r3, then the first 7 words of the parameters can be passed in registers,
   starting from r4.  */

d1646 1
a1646 4
rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
d1648 2
a1649 53
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int ii;
  int len = 0;
  int argno;			/* current argument number */
  int argbytes;			/* current argument byte */
  gdb_byte tmp_buffer[50];
  int f_argno = 0;		/* current floating point argno */
  int wordsize = gdbarch_tdep (gdbarch)->wordsize;
  CORE_ADDR func_addr = find_function_addr (function, NULL);

  struct value *arg = 0;
  struct type *type;

  ULONGEST saved_sp;

  /* The calling convention this function implements assumes the
     processor has floating-point registers.  We shouldn't be using it
     on PPC variants that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

  /* The first eight words of ther arguments are passed in registers.
     Copy them appropriately.  */
  ii = 0;

  /* If the function is returning a `struct', then the first word
     (which will be passed in r3) is used for struct return address.
     In that case we should advance one word and start from r4
     register to copy parameters.  */
  if (struct_return)
    {
      regcache_raw_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
				   struct_addr);
      ii++;
    }

/* 
   effectively indirect call... gcc does...

   return_val example( float, int);

   eabi: 
   float in fp0, int in r3
   offset of stack on overflow 8/16
   for varargs, must go by type.
   power open:
   float in r3&r4, int in r5
   offset of stack on overflow different 
   both: 
   return in r3 or f0.  If no float, must study how gcc emulates floats;
   pay attention to arg promotion.  
   User may have to cast\args to handle promotion correctly 
   since gdb won't know if prototype supplied or not.
 */
d1651 4
a1654 1
  for (argno = 0, argbytes = 0; argno < nargs && ii < 8; ++ii)
d1656 3
a1658 56
      int reg_size = register_size (gdbarch, ii + 3);

      arg = args[argno];
      type = check_typedef (value_type (arg));
      len = TYPE_LENGTH (type);

      if (TYPE_CODE (type) == TYPE_CODE_FLT)
	{

	  /* Floating point arguments are passed in fpr's, as well as gpr's.
	     There are 13 fpr's reserved for passing parameters. At this point
	     there is no way we would run out of them.  */

	  gdb_assert (len <= 8);

	  regcache_cooked_write (regcache,
	                         tdep->ppc_fp0_regnum + 1 + f_argno,
	                         value_contents (arg));
	  ++f_argno;
	}

      if (len > reg_size)
	{

	  /* Argument takes more than one register.  */
	  while (argbytes < len)
	    {
	      gdb_byte word[MAX_REGISTER_SIZE];
	      memset (word, 0, reg_size);
	      memcpy (word,
		      ((char *) value_contents (arg)) + argbytes,
		      (len - argbytes) > reg_size
		        ? reg_size : len - argbytes);
	      regcache_cooked_write (regcache,
	                            tdep->ppc_gp0_regnum + 3 + ii,
				    word);
	      ++ii, argbytes += reg_size;

	      if (ii >= 8)
		goto ran_out_of_registers_for_arguments;
	    }
	  argbytes = 0;
	  --ii;
	}
      else
	{
	  /* Argument can fit in one register.  No problem.  */
	  int adj = gdbarch_byte_order (gdbarch)
		    == BFD_ENDIAN_BIG ? reg_size - len : 0;
	  gdb_byte word[MAX_REGISTER_SIZE];

	  memset (word, 0, reg_size);
	  memcpy (word, value_contents (arg), len);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3 +ii, word);
	}
      ++argno;
d1661 2
a1662 1
ran_out_of_registers_for_arguments:
d1664 6
a1669 3
  regcache_cooked_read_unsigned (regcache,
				 gdbarch_sp_regnum (gdbarch),
				 &saved_sp);
d1671 3
a1673 2
  /* Location for 8 parameters are always reserved.  */
  sp -= wordsize * 8;
a1674 2
  /* Another six words for back chain, TOC register, link register, etc.  */
  sp -= wordsize * 6;
d1676 3
a1678 108
  /* Stack pointer must be quadword aligned.  */
  sp &= -16;

  /* If there are more arguments, allocate space for them in 
     the stack, then push them starting from the ninth one.  */

  if ((argno < nargs) || argbytes)
    {
      int space = 0, jj;

      if (argbytes)
	{
	  space += ((len - argbytes + 3) & -4);
	  jj = argno + 1;
	}
      else
	jj = argno;

      for (; jj < nargs; ++jj)
	{
	  struct value *val = args[jj];
	  space += ((TYPE_LENGTH (value_type (val))) + 3) & -4;
	}

      /* Add location required for the rest of the parameters.  */
      space = (space + 15) & -16;
      sp -= space;

      /* This is another instance we need to be concerned about
         securing our stack space. If we write anything underneath %sp
         (r1), we might conflict with the kernel who thinks he is free
         to use this area.  So, update %sp first before doing anything
         else.  */

      regcache_raw_write_signed (regcache,
				 gdbarch_sp_regnum (gdbarch), sp);

      /* If the last argument copied into the registers didn't fit there 
         completely, push the rest of it into stack.  */

      if (argbytes)
	{
	  write_memory (sp + 24 + (ii * 4),
			value_contents (arg) + argbytes,
			len - argbytes);
	  ++argno;
	  ii += ((len - argbytes + 3) & -4) / 4;
	}

      /* Push the rest of the arguments into stack.  */
      for (; argno < nargs; ++argno)
	{

	  arg = args[argno];
	  type = check_typedef (value_type (arg));
	  len = TYPE_LENGTH (type);


	  /* Float types should be passed in fpr's, as well as in the
             stack.  */
	  if (TYPE_CODE (type) == TYPE_CODE_FLT && f_argno < 13)
	    {

	      gdb_assert (len <= 8);

	      regcache_cooked_write (regcache,
				     tdep->ppc_fp0_regnum + 1 + f_argno,
				     value_contents (arg));
	      ++f_argno;
	    }

	  write_memory (sp + 24 + (ii * 4), value_contents (arg), len);
	  ii += ((len + 3) & -4) / 4;
	}
    }

  /* Set the stack pointer.  According to the ABI, the SP is meant to
     be set _before_ the corresponding stack space is used.  On AIX,
     this even applies when the target has been completely stopped!
     Not doing this can lead to conflicts with the kernel which thinks
     that it still has control over this not-yet-allocated stack
     region.  */
  regcache_raw_write_signed (regcache, gdbarch_sp_regnum (gdbarch), sp);

  /* Set back chain properly.  */
  store_unsigned_integer (tmp_buffer, wordsize, saved_sp);
  write_memory (sp, tmp_buffer, wordsize);

  /* Point the inferior function call's return address at the dummy's
     breakpoint.  */
  regcache_raw_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);

  /* Set the TOC register, get the value from the objfile reader
     which, in turn, gets it from the VMAP table.  */
  if (rs6000_find_toc_address_hook != NULL)
    {
      CORE_ADDR tocvalue = (*rs6000_find_toc_address_hook) (func_addr);
      regcache_raw_write_signed (regcache, tdep->ppc_toc_regnum, tocvalue);
    }

  target_store_registers (regcache, -1);
  return sp;
}

static enum return_value_convention
rs6000_return_value (struct gdbarch *gdbarch, struct type *func_type,
		     struct type *valtype, struct regcache *regcache,
		     gdb_byte *readbuf, const gdb_byte *writebuf)
d1680 1
a1680 113
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  gdb_byte buf[8];

  /* The calling convention this function implements assumes the
     processor has floating-point registers.  We shouldn't be using it
     on PowerPC variants that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

  /* AltiVec extension: Functions that declare a vector data type as a
     return value place that return value in VR2.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)
      && TYPE_LENGTH (valtype) == 16)
    {
      if (readbuf)
	regcache_cooked_read (regcache, tdep->ppc_vr0_regnum + 2, readbuf);
      if (writebuf)
	regcache_cooked_write (regcache, tdep->ppc_vr0_regnum + 2, writebuf);

      return RETURN_VALUE_REGISTER_CONVENTION;
    }

  /* If the called subprogram returns an aggregate, there exists an
     implicit first argument, whose value is the address of a caller-
     allocated buffer into which the callee is assumed to store its
     return value. All explicit parameters are appropriately
     relabeled.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_STRUCT
      || TYPE_CODE (valtype) == TYPE_CODE_UNION
      || TYPE_CODE (valtype) == TYPE_CODE_ARRAY)
    return RETURN_VALUE_STRUCT_CONVENTION;

  /* Scalar floating-point values are returned in FPR1 for float or
     double, and in FPR1:FPR2 for quadword precision.  Fortran
     complex*8 and complex*16 are returned in FPR1:FPR2, and
     complex*32 is returned in FPR1:FPR4.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && (TYPE_LENGTH (valtype) == 4 || TYPE_LENGTH (valtype) == 8))
    {
      struct type *regtype = register_type (gdbarch, tdep->ppc_fp0_regnum);
      gdb_byte regval[8];

      /* FIXME: kettenis/2007-01-01: Add support for quadword
	 precision and complex.  */

      if (readbuf)
	{
	  regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1, regval);
	  convert_typed_floating (regval, regtype, readbuf, valtype);
	}
      if (writebuf)
	{
	  convert_typed_floating (writebuf, valtype, regval, regtype);
	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1, regval);
	}

      return RETURN_VALUE_REGISTER_CONVENTION;
  }

  /* Values of the types int, long, short, pointer, and char (length
     is less than or equal to four bytes), as well as bit values of
     lengths less than or equal to 32 bits, must be returned right
     justified in GPR3 with signed values sign extended and unsigned
     values zero extended, as necessary.  */
  if (TYPE_LENGTH (valtype) <= tdep->wordsize)
    {
      if (readbuf)
	{
	  ULONGEST regval;

	  /* For reading we don't have to worry about sign extension.  */
	  regcache_cooked_read_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (valtype), regval);
	}
      if (writebuf)
	{
	  /* For writing, use unpack_long since that should handle any
	     required sign extension.  */
	  regcache_cooked_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					  unpack_long (valtype, writebuf));
	}

      return RETURN_VALUE_REGISTER_CONVENTION;
    }

  /* Eight-byte non-floating-point scalar values must be returned in
     GPR3:GPR4.  */

  if (TYPE_LENGTH (valtype) == 8)
    {
      gdb_assert (TYPE_CODE (valtype) != TYPE_CODE_FLT);
      gdb_assert (tdep->wordsize == 4);

      if (readbuf)
	{
	  gdb_byte regval[8];

	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3, regval);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				regval + 4);
	  memcpy (readbuf, regval, 8);
	}
      if (writebuf)
	{
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3, writebuf);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				 writebuf + 4);
	}

      return RETURN_VALUE_REGISTER_CONVENTION;
    }

  return RETURN_VALUE_STRUCT_CONVENTION;
d1729 1
d1750 1
a1750 2
      && rs6000_in_solib_return_trampoline (pc, 
					    DEPRECATED_SYMBOL_NAME (msymbol)))
d1775 1
a1775 2
  pc = read_memory_addr (ii,
			 gdbarch_tdep (get_frame_arch (frame))->wordsize); /* (r11) value */
a1820 9
/* Return the size of register REG when words are WORDSIZE bytes long.  If REG
   isn't available with that word size, return 0.  */

static int
regsize (const struct reg *reg, int wordsize)
{
  return wordsize == 8 ? reg->sz64 : reg->sz32;
}

a2255 34
/* Support for CONVERT_FROM_FUNC_PTR_ADDR (ARCH, ADDR, TARG).

   Usually a function pointer's representation is simply the address
   of the function. On the RS/6000 however, a function pointer is
   represented by a pointer to an OPD entry. This OPD entry contains
   three words, the first word is the address of the function, the
   second word is the TOC pointer (r2), and the third word is the
   static chain value.  Throughout GDB it is currently assumed that a
   function pointer contains the address of the function, which is not
   easy to fix.  In addition, the conversion of a function address to
   a function pointer would require allocation of an OPD entry in the
   inferior's memory space, with all its drawbacks.  To be able to
   call C++ virtual methods in the inferior (which are called via
   function pointers), find_function_addr uses this function to get the
   function address from a function pointer.  */

/* Return real function address if ADDR (a function pointer) is in the data
   space and is therefore a special function pointer.  */

static CORE_ADDR
rs6000_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
				   CORE_ADDR addr,
				   struct target_ops *targ)
{
  struct obj_section *s;

  s = find_pc_section (addr);
  if (s && s->the_bfd_section->flags & SEC_CODE)
    return addr;

  /* ADDR is in the data space, so it's a special function pointer. */
  return read_memory_addr (addr, gdbarch_tdep (gdbarch)->wordsize);
}

d2445 1
a2445 1
    cache->base = read_memory_addr (cache->base, wordsize);
a2673 1
  int sysv_abi;
a2689 2
  sysv_abi = info.abfd && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour;

d3077 1
a3077 1
  if (sysv_abi && wordsize == 8)
d3079 1
a3079 1
  else if (sysv_abi && wordsize == 4)
a3080 2
  else
    set_gdbarch_return_value (gdbarch, rs6000_return_value);
d3085 1
a3085 1
  else if (sysv_abi)
a3086 2
  else
    tdep->lr_frame_offset = 8;
d3118 1
a3118 4
  if (sysv_abi)
    set_gdbarch_long_double_bit (gdbarch, 16 * TARGET_CHAR_BIT);
  else
    set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
d3122 1
a3122 1
  if (sysv_abi && wordsize == 8)
a3124 6
  else if (!sysv_abi && wordsize == 4)
    /* PowerOpen / AIX 32 bit.  The saved area or red zone consists of
       19 4 byte GPRS + 18 8 byte FPRs giving a total of 220 bytes.
       Problem is, 220 isn't frame (16 byte) aligned.  Round it up to
       224.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 224);
d3133 1
a3133 1
  if (sysv_abi && wordsize == 4)
d3135 1
a3135 1
  else if (sysv_abi && wordsize == 8)
a3136 2
  else
    set_gdbarch_push_dummy_call (gdbarch, rs6000_push_dummy_call);
d3149 1
a3149 1
  set_gdbarch_software_single_step (gdbarch, deal_with_atomic_sequence);
a3150 9
  /* Handle the 64-bit SVR4 minimal-symbol convention of using "FN"
     for the descriptor and ".FN" for the entry-point -- a user
     specifying "break FN" will unexpectedly end up with a breakpoint
     on the descriptor and not the function.  This architecture method
     transforms any breakpoints on descriptors into breakpoints on the
     corresponding entry point.  */
  if (sysv_abi && wordsize == 8)
    set_gdbarch_adjust_breakpoint_address (gdbarch, ppc64_sysv_abi_adjust_breakpoint_address);

a3153 8
  if (!sysv_abi)
    {
      /* Handle RS/6000 function pointers (which are really function
         descriptors).  */
      set_gdbarch_convert_from_func_ptr_addr (gdbarch,
	rs6000_convert_from_func_ptr_addr);
    }

@


1.311
log
@	* rs6000-tdep.c: Update for unwinder changes.
	* ppcobsd-tdep.c: Likewise.
@
text
@d67 1
d76 1
d381 1
a381 1
static void
d402 1
a402 1
static void
d2862 1
a2862 1
   bfd_mach_ppc, &tdesc_powerpc_32},
d2890 1
a2890 1
   bfd_mach_ppc64, &tdesc_powerpc_64},
d3907 1
d3916 1
@


1.310
log
@	* dwarf2-frame.c (read_reg): Expect this_frame in the baton.
	(execute_stack_op): Put this_frame in the baton.
	(execute_cfa_program): Take this_frame.
	(struct dwarf2_frame_ops): Update comment for signal_frame_p.
	(dwarf2_frame_default_init_reg, dwarf2_frame_init_reg)
	(dwarf2_frame_signal_frame_p, dwarf2_frame_cache)
	(dwarf2_frame_this_id): Adjust to work on this_frame.
	(dwarf2_signal_frame_this_id): Delete.
	(dwarf2_frame_prev_register): Update signature.  Use new frame
	unwind methods.
	(dwarf2_frame_sniffer): Update signature.  Expect this_frame.
	(dwarf2_frame_unwind, dwarf2_signal_frame_unwind): Add
	dwarf2_frame_sniffer.
	(dwarf2_append_unwinders): New.
	(dwarf2_frame_base_address, dwarf2_frame_base_sniffer): Expect
	this_frame.
	* sparc-tdep.c (sparc32_dwarf2_struct_return_p)
	(sparc32_dwarf2_frame_init_reg): Expect this_frame.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* dwarf2-frame.h (dwarf2_frame_sniffer): Delete declaration.
	(dwarf2_append_unwinders): Declare.
	(dwarf2_frame_base_sniffer): Update declaration.
	* i386-linux-tdep.c (i386_linux_dwarf_signal_frame_p): Expect
	this_frame.
@
text
@d2946 1
a2946 1
rs6000_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d2948 3
a2950 3
  return frame_id_build (frame_unwind_register_unsigned
			 (next_frame, gdbarch_sp_regnum (gdbarch)),
			frame_pc_unwind (next_frame));
d2961 1
a2961 1
rs6000_frame_cache (struct frame_info *next_frame, void **this_cache)
d2964 1
a2964 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d2974 1
a2974 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d2976 2
a2977 2
  func = frame_func_unwind (next_frame, NORMAL_FRAME);
  pc = frame_pc_unwind (next_frame);
d2987 2
a2988 2
  cache->base = frame_unwind_register_unsigned
		(next_frame, gdbarch_sp_regnum (gdbarch));
d3004 1
a3004 2
      saved_lr = frame_unwind_register_unsigned (next_frame,
						 tdep->ppc_lr_regnum);
d3116 2
a3117 2
    cache->initial_sp = frame_unwind_register_unsigned
			(next_frame, gdbarch_sp_regnum (gdbarch));
d3119 2
a3120 2
    cache->initial_sp = frame_unwind_register_unsigned (next_frame,
							fdata.alloca_reg);
d3126 1
a3126 1
rs6000_frame_this_id (struct frame_info *next_frame, void **this_cache,
d3129 1
a3129 1
  struct rs6000_frame_cache *info = rs6000_frame_cache (next_frame,
d3131 1
a3131 2
  (*this_id) = frame_id_build (info->base,
			       frame_func_unwind (next_frame, NORMAL_FRAME));
d3134 3
a3136 6
static void
rs6000_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, gdb_byte *valuep)
d3138 1
a3138 1
  struct rs6000_frame_cache *info = rs6000_frame_cache (next_frame,
d3140 1
a3140 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d3147 3
a3149 1
  rs6000_frame_prev_register
a3150 7

static const struct frame_unwind *
rs6000_frame_sniffer (struct frame_info *next_frame)
{
  return &rs6000_frame_unwind;
}

d3154 1
a3154 2
rs6000_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
d3156 1
a3156 1
  struct rs6000_frame_cache *info = rs6000_frame_cache (next_frame,
d3169 1
a3169 1
rs6000_frame_base_sniffer (struct frame_info *next_frame)
d3776 1
a3776 1
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
d3792 2
a3793 2
      frame_unwind_append_sniffer (gdbarch, rs6000_frame_sniffer);
      set_gdbarch_unwind_dummy_id (gdbarch, rs6000_unwind_dummy_id);
d3800 2
a3801 2
      frame_unwind_append_sniffer (gdbarch, rs6000_frame_sniffer);
      set_gdbarch_unwind_dummy_id (gdbarch, rs6000_unwind_dummy_id);
@


1.309
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d3192 1
a3192 1
			    struct frame_info *next_frame)
@


1.308
log
@        * rs6000-tdep.c (rs6000_gdbarch_init): Use the BFD architecture,
        rather than a hard-coded architecture, for xcoff executables.
@
text
@d2098 3
a2100 3
rs6000_return_value (struct gdbarch *gdbarch, struct type *valtype,
		     struct regcache *regcache, gdb_byte *readbuf,
		     const gdb_byte *writebuf)
@


1.307
log
@
	* rs6000-tdep.c (gdb_print_insn_powerpc): Get the current endianess
	from disassemble_info instead of gdbarch_byte_order.

	* mips-tdep.c (gdb_print_insn_mips): Likewise.
	* arm-tdep.c (gdb_print_insn_arm): Likewise.
@
text
@d3310 3
a3312 12
  if (!from_xcoff_exec)
    {
      arch = info.bfd_arch_info->arch;
      mach = info.bfd_arch_info->mach;
    }
  else
    {
      arch = bfd_arch_powerpc;
      bfd_default_set_arch_mach (&abfd, arch, 0);
      info.bfd_arch_info = bfd_get_arch_info (&abfd);
      mach = info.bfd_arch_info->mach;
    }
@


1.306
log
@2008-01-30  Luis Machado  <luisgpm@@br.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* infcmd.c (default_print_registers_info): Also print hex
	raw contents for TYPE_CODE_DECFLOAT registers.
	* ppc-tdep.h (gdbarch_tdep): Add ppc_dl0_regnum member.
	* rs6000-tdep.c (IS_DFP_PSEUDOREG): New macro.
	(rs6000_register_name): Add support for DFP pseudo-registers.
	(rs6000_pseudo_register_type): Likewise.
	rs6000_pseudo_register_reggroup_p): Likewise.
	(ppc_pseudo_register_read): New function.
	(ppc_pseudo_register_write): Likewise.
	(rs6000_pseudo_register_read): Likewise.
	(rs6000_pseudo_register_write): Likewise.
	(e500_pseudo_register_read): Move checks to
	rs6000_pseudo_register_read.
	(e500_pseudo_register_write): Move checks to
	rs6000_pseudo_register_write.
	(rs6000_gdbarch_init): Initialize tdep->ppc_dl0_regnum.  Install
	rs6000_pseudo_register_read and rs6000_pseudo_register_write
	in gdbarch if SPE or DFP is available.  Adjust gdbarch's
	num_pseudo_regs to account for DFP pseudo regs.
@
text
@d2932 1
a2932 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
@


1.305
log
@	* ppc-tdep.h (struct gdbarch_tdep): Remove ppc_ev31_regnum member.
	* rs6000-tdep.c (IS_SPE_PSEUDOREG): New macro.
	(spe_register_p, rs6000_register_name, rs6000_pseudo_register_type,
	rs6000_pseudo_register_reggroup_p, e500_move_ev_register,
	e500_pseudo_register_read, e500_pseudo_register_write): Use
	IS_SPE_PSEUDOREG macro.
	(rs6000_frame_cache): Remove use of tdep->ppc_ev31_regnum.
	(rs6000_gdbarch_init): Remove unnecessary num_sprs local variable.
	Remove initialization of tdep->ppc_ev31_regnum.
@
text
@d86 5
d2393 12
d2417 2
a2418 1
  gdb_assert (IS_SPE_PSEUDOREG (tdep, regnum));
d2420 6
a2425 1
  return rs6000_builtin_type_vec64 (gdbarch);
d2436 2
a2437 1
  gdb_assert (IS_SPE_PSEUDOREG (tdep, regnum));
d2439 3
a2441 2
  if (group == all_reggroup || group == vector_reggroup)
    return 1;
d2443 2
a2444 1
    return 0;
d2545 69
d2618 1
a2618 1
 
d2620 3
a2622 1
    e500_move_ev_register (regcache_raw_read, regcache, reg_nr, buffer);
d2625 3
a2627 3
                    _("e500_pseudo_register_read: "
                    "called on unexpected register '%s' (%d)"),
                    gdbarch_register_name (gdbarch, reg_nr), reg_nr);
d2631 3
a2633 2
e500_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int reg_nr, const gdb_byte *buffer)
d2639 1
a2639 1
 
d2641 3
a2643 3
    e500_move_ev_register ((void (*) (struct regcache *, int, gdb_byte *))
                           regcache_raw_write,
                           regcache, reg_nr, (gdb_byte *) buffer);
d2646 3
a2648 3
                    _("e500_pseudo_register_read: "
                    "called on unexpected register '%s' (%d)"),
                    gdbarch_register_name (gdbarch, reg_nr), reg_nr);
d3269 1
a3269 1
  int have_fpu = 1, have_spe = 0, have_mq = 0, have_altivec = 0;
d3273 1
d3444 4
d3694 1
a3694 1
  if (have_spe)
d3696 2
a3697 2
      set_gdbarch_pseudo_register_read (gdbarch, e500_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, e500_pseudo_register_write);
d3709 7
a3715 1
  set_gdbarch_num_pseudo_regs (gdbarch, have_spe ? 32 : 0);
d3838 7
@


1.304
log
@	* alpha-tdep.c (alpha_heuristic_proc_start)
	(alpha_sigtramp_register_address): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.

	(alpha_heuristic_frame_unwind_cache): Use get_frame_arch to get at the
	current architecture by frame_info. Update alpha_heuristic_proc_start
	call.

	(alpha_sigtramp_frame_this_id, alpha_sigtramp_frame_prev_register): Use
	get_frame_arch to get at the current architecture by frame_info. Update
	alpha_sigtramp_register_address call.

	* arm-tdep.c (thumb_scan_prologue): Add gdbarch as parameter and replace
	current_gdbarch by gdbarch. Update caller.
	(convert_to_extended, convert_from_extended): Add endianess parameter
	for comparison. Update caller.
	(arm_extract_return_value, arm_store_return_value): Use
	get_regcache_arch to get at the current	architecture.

	* cris-tdep.c (cris_register_size): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.
	(cris_gdb_func, move_to_preg_op, none_reg_mode_move_from_preg_op): Add
	gdbarch as parameter. Update caller. Replace current_gdbarch by gdbarch.

	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM, E_PSEUDO_EXR_REGNUM, BINWORD): Add
	gdbarch	as parameter. Update caller.
	(h8300_init_frame_cache): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* hppa-tdep.c (skip_prologue_hard_way): Add gdbarch as parameter and
	update caller. Replace current_gdbarch by gdbarch.

	* m32c-tdep.c (m32c_skip_trampoline_code): Use get_frame_arch to get at
	the current architecture. Replace current_gdbarch by gdbarch.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Likewise.
	(STACK_CORRECTION, USE_PAGE_REGISTER): Replace M6811_TDEP by its
	expression. Add gdbarch as parameter and replace current_gdbarch with
	it. Update caller.
	(M6811_TDEP): Remove.
	(m68hc11_frame_prev_register): Use get_frame_arch to get at the current
	architecture.
	(m68hc11_scan_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* m68k-tdep.c (m68k_analyze_prologue): Add gdbarch as parameter and
	update caller.
	(m68k_analyze_register_saves): Likewise. Also replace current_gdbarch
	by gdbarch.

	* rs6000-tdep.c (skip_prologue): Add gdbarch as parameter and update
	caller. Relace current_gdbarch by gdbarch.
	(altivec_register_p, spe_register_p): Likewise.
	* ppc-tdep.h (altivec_register_p, spe_register_p): Add gdbarch as
	parameter.
	* ppc-linux-nat.c (fetch_register, store_register): Update caller of
	altivec_register_p and spe_register_p.

	* score-tdep.c (score_fetch_inst): Add gdbarch as parameter. Update
	caller. Replace current_gdbarch by gdbarch.
	(score_analyze_prologue): use get_frame_arch to get at the current
	architecture.

	* sparc-tdep.h (sparc_analyze_prologue): Add gdbarch as parameter.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise. Replace
	current_gdbarch by gdbarch. Update caller.
	(sparc_frame_cache): Use get_frame_arch to get at the current
	architecture.
	* sparce64-tdep.c (sparc64_skip_prologue): Update call of
	sparc_analyze_prologue.

	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Add gdbarch as
	parameter.
@
text
@d81 5
d187 1
a187 3
  if (tdep->ppc_ev0_regnum >= 0
      && tdep->ppc_ev31_regnum >= 0
      && tdep->ppc_ev0_regnum <= regno && regno <= tdep->ppc_ev31_regnum)
d2377 1
a2377 3
  if (tdep->ppc_ev0_regnum >= 0
      && tdep->ppc_ev0_regnum <= regno
      && regno < tdep->ppc_ev0_regnum + ppc_num_gprs)
d2400 1
a2400 3
  gdb_assert (tdep->ppc_ev0_regnum >= 0
	      && regnum >= tdep->ppc_ev0_regnum
	      && regnum < tdep->ppc_ev0_regnum + 32);
d2413 1
a2413 3
  gdb_assert (tdep->ppc_ev0_regnum >= 0
	      && regnum >= tdep->ppc_ev0_regnum
	      && regnum < tdep->ppc_ev0_regnum + 32);
d2499 1
a2499 2
  gdb_assert (tdep->ppc_ev0_regnum <= ev_reg
              && ev_reg < tdep->ppc_ev0_regnum + ppc_num_gprs);
d2524 1
a2524 2
  if (tdep->ppc_ev0_regnum <= reg_nr
      && reg_nr < tdep->ppc_ev0_regnum + ppc_num_gprs)
d2542 1
a2542 2
  if (tdep->ppc_ev0_regnum <= reg_nr
      && reg_nr < tdep->ppc_ev0_regnum + ppc_num_gprs)
d2983 1
a2983 1
  if (tdep->ppc_ev0_regnum != -1 && tdep->ppc_ev31_regnum != -1)
a3174 1
  int num_sprs = 0;
d3605 1
a3605 1
  set_gdbarch_num_regs (gdbarch, PPC_NUM_REGS + num_sprs);
a3727 1
  tdep->ppc_ev31_regnum = have_spe ? tdep->ppc_ev0_regnum + 31 : -1;
@


1.303
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d160 1
a160 1
static CORE_ADDR skip_prologue (CORE_ADDR, CORE_ADDR,
d165 1
a165 1
altivec_register_p (int regno)
d167 1
a167 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d177 1
a177 1
spe_register_p (int regno)
d179 1
a179 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d782 1
a782 1
  pc = skip_prologue (pc, limit_pc, &frame);
d1254 2
a1255 1
skip_prologue (CORE_ADDR pc, CORE_ADDR lim_pc, struct rs6000_framedata *fdata)
d1276 2
a1277 2
  const struct bfd_arch_info *arch_info = gdbarch_bfd_arch_info (current_gdbarch);
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2886 1
a2886 1
  skip_prologue (func, pc, &fdata);
@


1.302
log
@	Updated copyright notices for most files.
@
text
@d757 1
a757 1
rs6000_skip_prologue (CORE_ADDR pc)
@


1.301
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.300
log
@2007-11-19  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_sim_regno): Add gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* arch-utils.h (legacy_register_sim_regno): Add gdbarch as parameter.
	* score-tdep.c (score_register_sim_regno): Likewise.
	* sim-regno.h (one2one_register_sim_regno): Likewise.

	* arch-utils.c (legacy_register_sim_regno): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* sh-tdep.c (sh_sh2a_register_sim_regno)
	(sh_dsp_register_sim_regno): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* mips-tdep.c (mips_register_sim_regno): Likewise.
	* m32c-tdep.c (m32c_register_sim_regno): Likewise.
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* arm-tdep.c (arm_register_sim_regno): Likewise.
	* remote-sim.c (one2one_register_sim_regno): Likewise.
@
text
@d2560 1
a2560 1
rs6000_stab_reg_to_regnum (int num)
d2562 1
a2562 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2602 1
a2602 1
rs6000_dwarf2_reg_to_regnum (int num)
d2604 1
a2604 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.299
log
@2007-11-16  Markus Deuling  <deuling@@de.ibm.com>

	* m32r-rom.c (m32r_supply_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	* ppcnbsd-nat.c (ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, fetch_ppc_registers)
	(store_altivec_register, store_spe_register, store_register)
	(fill_vrregset, store_ppc_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Likewise.

	* trad-frame.c (trad_frame_alloc_saved_regs): Replace current_gdbarch by
	gdbarch.
	* user-regs.c (user_reg_map_name_to_regnum): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_return_value): Likewise.
	* m32c-tdep.c (m32c_register_reggroup_p): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.

	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Use get_frame_arch to
	get at the current architecture by frame_info.
	* gcore.c (derive_stack_segment): Likewise.

	* shnbsd-nat.c (GETREGS_SUPPLIES): Add gdbarch parameter.
	(shnbsd_fetch_inferior_registers, shnbsd_store_inferior_registers): Add
	gdbarch to GETREGS_SUPPLIES call.
@
text
@d345 1
a345 1
rs6000_register_sim_regno (int reg)
d347 1
a347 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d351 1
a351 1
    init_sim_regno_table (current_gdbarch);
d354 2
a355 2
	      && reg <= gdbarch_num_regs (current_gdbarch)
			+ gdbarch_num_pseudo_regs (current_gdbarch));
@


1.298
log
@	* gdbarch.sh (convert_register_p): Add gdbarch as parameter.
	* ia64-tdep.c (ia64_convert_register_p): Likewise.
	* i387-tdep.c (i387_convert_register_p): Likewise.
	* i387-tdep.h (i387_convert_register_p): Likewise.
	* alpha-tdep.c (alpha_convert_register_p): Likewise.
	* gdbarch.{c,h}: Regenerate.

	* rs6000-tdep.c (rs6000_convert_register_p): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* mips-tdep.c (mips_convert_register_p): Likewise.
	* m68k-tdep.c (m68k_convert_register_p): Likewise.
	* i386-tdep.c (i386_convert_register_p): Likewise.
@
text
@d3148 1
a3148 1
  if (regnum == gdbarch_pc_regnum (current_gdbarch))
d3150 1
a3150 1
  else if (regnum == gdbarch_sp_regnum (current_gdbarch))
@


1.297
log
@*** empty log message ***
@
text
@d2427 2
a2428 1
rs6000_convert_register_p (int regnum, struct type *type)
d2430 1
a2430 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.296
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d968 2
a969 1
rs6000_breakpoint_from_pc (CORE_ADDR *bp_addr, int *bp_size)
d974 1
a974 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1083 2
a1084 1
  const gdb_byte *breakp = rs6000_breakpoint_from_pc (&dummy, &breakp_sz);
@


1.295
log
@	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Check the selected
	soft float and vector ABIs.  Support the generic vector ABI for
	AltiVec types.
	(do_ppc_sysv_return_value): Likewise.  Correct argument types and
	casts.
	(ppc64_sysv_abi_push_dummy_call): Assert that floating point is
	supported.
	* ppc-tdep.h (enum powerpc_vector_abi): New.
	(struct gdbarch_tdep): Add soft_float and vector_abi.
	* rs6000-tdep.c (setpowerpccmdlist, showpowerpccmdlist)
	(powerpc_soft_float_global, powerpc_vector_strings)
	(powerpc_vector_abi_global, powerpc_vector_abi_string): New.
	(rs6000_gdbarch_init): Check for soft-float and vector ABI markings.
	(set_powerpc_command, show_powerpc_command, powerpc_set_soft_float)
	(powerpc_set_vector_abi): New.
	(_initialize_rs6000_tdep): Register "set powerpc" and "show powerpc"
	commands.
	* Makefile.in (elf_ppc_h): New.
	(rs6000-tdep.o): Update.

	* gdb.texinfo (PowerPC): Document "set powerpc vector-abi" and "set
	powerpc soft-float".

	* gdb.arch/altivec-abi.exp: Run multiple times for GCC on GNU/Linux.
	Test "set powerpc vector-abi".  Skip auto-detection tests for old
	toolchains.
@
text
@d2358 1
a2358 1
rs6000_register_name (int regno)
d2360 1
a2360 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2384 1
a2384 1
  return tdesc_register_name (regno);
@


1.294
log
@	* ppc-linux-tdep.c (ppc32_linux_reg_offsets): Corrected
	swapped offsets and VRSAVE offset.
	(ppc64_linux_reg_offsets): Corrected swapped offsets.
	(ppc32_linux_vrregset): Added.
	(ppc_linux_regset_from_core_section): Added support for
	.reg-ppc-vmx section.
	* ppc-tdep.h (ppc_altivec_support_p): Declare.
	(ppc_supply_vrregset): Declare.
	(ppc_collect_vrregset): Declare.
	* rs6000-tdep.c (ppc_altivec_support_p): Added.
	(ppc_supply_vrregset): Added.
	(ppc_collect_vrregset): Added.
	* corelow.c (get_core_registers): Added support for
	.reg-ppc-vmx section.
@
text
@d52 1
d81 21
d3170 3
d3445 70
d3524 4
d3546 2
d3747 55
d3827 26
@


1.293
log
@    * rs6000-tdep.c (ppc_dwarf2_frame_init_reg): New function.
      (rs6000_gdbarch_init): Install ppc_dwarf2_frame_init_reg as
      default dwarf2_frame_set_init_reg function.
@
text
@d197 10
d449 18
d549 44
d678 46
@


1.292
log
@
	* gdbarch.sh (sofun_address_maybe_missing): New gdbarch variable.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (find_stab_function_addr): Define unconditionally.
	(read_dbx_symtab): Use gdbarch_sofun_address_maybe_missing
	instead of SOFUN_ADDRESS_MAYBE_MISSING.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.
	* mdebugread.c (parse_partial_symbols): Likewise.

	* symtab.h (struct minimal_symbol): Always define "filename" member.
	* elfread.c (elf_symtab_read): Use msym->filename unconditionally.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* symmisc.c (dump_msymbols): Likewise.

	* config/i386/i386sol2.mt (DEPRECATED_TM_FILE): Remove.
	* config/i386/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/i386/tm-i386sol2.h: Remove file.
	* config/i386/tm-linux.h: Remove file.
	* i386-linux-tdep.c (i386_linux_init_abi): Add call to
	set_gdbarch_sofun_address_maybe_missing.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.

	* config/powerpc/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/nbsd.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/obsd.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/ppc-eabi.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/ppc-sim.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/tm-ppc-eabi.h: Remove file.
	* rs6000-tdep.c (rs6000_gdbarch_init): Add call to
	set_gdbarch_sofun_address_maybe_missing.

	* config/sparc/sol2-64.mt (DEPRECATED_TM_FILE): Remove.
	* config/sparc/sol2.mt (DEPRECATED_TM_FILE): Remove.
	* config/sparc/tm-sol2.h: Remove file.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Add call to
	set_gdbarch_sofun_address_maybe_missing.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Likewise.

doc/ChangeLog:

	* gdbarch.texi (Target Conditionals): Remove documentation of
	SOFUN_ADDRESS_MAYBE_MISSING, replaced by ...
	(Compiler Characteristics): ... documentation of
	set_gdbarch_sofun_address_maybe_missing.
@
text
@d2950 62
d3475 3
@


1.291
log
@	* rs6000-tdep.c (skip_prologue): Restore comment with
	function description to its proper place.
@
text
@d3374 4
@


1.290
log
@	* NEWS: Document target described register support for PowerPC.
	* ppc-tdep.h: Remove ppc_spr constants.
	(struct gdbarch_tdep): Remove regs, ppc_sr0_regnum, and
	ppc_builtin_type_vec128 members.
	(PPC_R0_REGNUM, PPC_F0_REGNUM, PPC_PC_REGNUM, PPC_MSR_REGNUM)
	(PPC_CR_REGNUM, PPC_LR_REGNUM, PPC_CTR_REGNUM, PPC_XER_REGNUM)
	(PPC_FPSCR_REGNUM, PPC_MQ_REGNUM, PPC_SPE_UPPER_GP0_REGNUM)
	(PPC_SPE_ACC_REGNUM, PPC_SPE_FSCR_REGNUM, PPC_VR0_REGNUM)
	(PPC_VSCR_REGNUM, PPC_VRSAVE_REGNUM, PPC_NUM_REGS): New constants.
	* rs6000-tdep.c: Include preparsed descriptions.
	(init_sim_regno_table): Do not iterate over pseudo registers.
	Look up segment registers by name.  Use sim_spr_register_name
	for SPRs.
	(rs6000_register_sim_regno): Call init_sim_regno_table here.
	(rs6000_builtin_type_vec128): Delete.
	(rs6000_register_name): Only handle SPE pseudo registers and upper
	halves.  Call tdesc_register_name for everything else.
	(rs6000_register_type): Delete.  Replace with...
	(rs6000_pseudo_register_type): ...this new function.  Only handle
	SPE pseudo registers.
	(rs6000_register_reggroup_p): Delete.  Replace with...
	(rs6000_pseudo_register_reggroup_p): ...this new function.  Only
	handle SPE pseudo registers.
	(rs6000_convert_register_p): Use ppc_fp0_regnum instead of
	"struct reg".
	(rs6000_register_to_value, rs6000_value_to_register): Remove check
	of reg->fpr.
	(e500_register_reggroup_p): Delete.
	(STR, R, R4, R8, R16, F, P8, R32, R64, R0, A4, S, S4, SN4, S64)
	(COMMON_UISA_REGS, PPC_UISA_SPRS, PPC_UISA_NOFP_SPRS)
	(PPC_SEGMENT_REGS, PPC_OEA_SPRS, PPC_ALTIVEC_REGS, PPC_SPE_GP_REGS)
	(PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): Delete macros.
	(registers_powerpc, registers_403, registers_403GC, registers_505)
	(registers_860, registers_601, registers_602, registers_603)
	(registers_604, registers_750, registers_7400, registers_e500): Delete
	variables.
	(struct variant): Delete nregs, npregs, num_tot_regs, and regs.  Add
	tdesc.
	(tot_num_registers, num_registers, num_pseudo_registers): Delete.
	(variants): Delete outdated comment.  Use standard target descriptions
	instead of "struct reg" arrays.
	(init_variants): Delete.
	(rs6000_gdbarch_init): Do not guess word size from the BFD
	architecture if we have a target description.  Select a variant
	before creating a new architecture.  Use the variant's target
	description if the target did not define a register layout.
	Validate target-supplied registers.  Reject mismatches.  Use
	fixed register numbers and new constants instead of magic
	numbers.  Call set_gdbarch_ps_regnum.  Call tdesc_use_registers.
	(_initialize_rs6000_tdep): Initialize the preparsed target
	descriptions.
	* target-descriptions.c (tdesc_predefined_types): Add int128 and
	uint128.
	(tdesc_find_register_early): New function.
	(tdesc_numbered_register): Use it.
	(tdesc_register_size): New function.
	(tdesc_use_registers): Take a target_desc argument.  Do not use
	gdbarch_target_desc.
	* target-descriptions.h (tdesc_use_registers): Update prototype
	and comment.
	(tdesc_register_size): New prototype.
	* Makefile.in (powerpc_32_c, powerpc_403_c, powerpc_403gc_c)
	(powerpc_505_c, powerpc_601_c, powerpc_602_c, powerpc_603_c)
	(powerpc_604_c, powerpc_64_c, powerpc_7400_c, powerpc_750_c)
	(powerpc_860_c, powerpc_e500_c, rs6000_c): New macros.
	(rs6000-tdep.o): Update.
	* arm-tdep.c (arm_gdbarch_init): Update call to tdesc_use_registers.
	* m68k-tdep.c (m68k_gdbarch_init): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.

	* gdb.texinfo (Predefined Target Types): Add int128
	and uint128.
	(Standard Target Features): Add PowerPC features.

	* gdb.xml/tdesc-regs.exp: Add PowerPC support.

	* sim-ppc.h (sim_spr_register_name): New prototype.

	* gdb-sim.c (regnum2spr): Rename to...
	(sim_spr_register_name): ... this.  Make global.
@
text
@a976 23
/* return pc value after skipping a function prologue and also return
   information about a function frame.

   in struct rs6000_framedata fdata:
   - frameless is TRUE, if function does not have a frame.
   - nosavedpc is TRUE, if function does not save %pc value in its frame.
   - offset is the initial size of this stack frame --- the amount by
   which we decrement the sp to allocate the frame.
   - saved_gpr is the number of the first saved gpr.
   - saved_fpr is the number of the first saved fpr.
   - saved_vr is the number of the first saved vr.
   - saved_ev is the number of the first saved ev.
   - alloca_reg is the number of the register used for alloca() handling.
   Otherwise -1.
   - gpr_offset is the offset of the first saved gpr from the previous frame.
   - fpr_offset is the offset of the first saved fpr from the previous frame.
   - vr_offset is the offset of the first saved vr from the previous frame.
   - ev_offset is the offset of the first saved ev from the previous frame.
   - lr_offset is the offset of the saved lr
   - cr_offset is the offset of the saved cr
   - vrsave_offset is the offset of the saved vrsave register
 */

d1088 23
@


1.289
log
@2007-10-10  Markus Deuling  <deuling@@de.ibm.com>

	* rs6000-nat.c (fetch_register, store_register)
	(rs6000_fetch_inferior_registers, rs6000_store_inferior_registers): Use
	get_regcache_arch to get at the current architecture by regcache.

	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_return_value)
	(rs6000_register_reggroup_p, e500_move_ev_registe, rs6000_unwind_pc)
	(rs6000_unwind_dummy_id, rs6000_frame_cache, rs6000_dump_tdep): Replace
	current_gdbarch by gdbarch.
	(rs6000_skip_trampoline_code, rs6000_register_to_value)
	(rs6000_value_to_register): Use get_frame_arch to get at the current
	architecture by frame_info.
@
text
@d42 2
d65 15
d222 1
a222 2
  int total_regs = gdbarch_num_regs (arch) + gdbarch_num_pseudo_regs (arch);
  const struct reg *regs = tdep->regs;
d225 4
d253 8
a260 5
  if (tdep->ppc_sr0_regnum >= 0)
    for (i = 0; i < ppc_num_srs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_sr0_regnum + i,
                     sim_ppc_sr0_regnum + i);
a278 5
  if (tdep->ppc_ev0_regnum >= 0)
    for (i = 0; i < ppc_num_gprs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_ev0_regnum + i,
                     sim_ppc_ev0_regnum + i);
d288 1
d291 13
a303 4
     code).  */
  for (i = 0; i < total_regs; i++)
    if (regs[i].spr_num >= 0)
      set_sim_regno (sim_regno, i, regs[i].spr_num + sim_ppc_spr0_regnum);
d318 3
a2204 40
static struct type *
rs6000_builtin_type_vec128 (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->ppc_builtin_type_vec128)
    {
      /* The type we're building is this: */
#if 0
      union __gdb_builtin_type_vec128
	{
	  int128_t uint128;
	  float v4_float[4];
	  int32_t v4_int32[4];
	  int16_t v8_int16[8];
	  int8_t v16_int8[16];
	};
#endif

      struct type *t;

      t = init_composite_type ("__ppc_builtin_type_vec128", TYPE_CODE_UNION);
      append_composite_type_field (t, "uint128", builtin_type_int128);
      append_composite_type_field (t, "v4_float",
				   init_vector_type (builtin_type_float, 4));
      append_composite_type_field (t, "v4_int32",
				   init_vector_type (builtin_type_int32, 4));
      append_composite_type_field (t, "v8_int16",
				   init_vector_type (builtin_type_int16, 8));
      append_composite_type_field (t, "v16_int8",
				   init_vector_type (builtin_type_int8, 16));

      TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
      TYPE_NAME (t) = "ppc_builtin_type_vec128";
      tdep->ppc_builtin_type_vec128 = t;
    }

  return tdep->ppc_builtin_type_vec128;
}

d2214 2
a2215 2
/* Return the name of register number N, or null if no such register exists
   in the current architecture.  */
d2218 1
a2218 1
rs6000_register_name (int n)
a2220 1
  const struct reg *reg = tdep->regs + n;
d2222 23
a2244 3
  if (!regsize (reg, tdep->wordsize))
    return NULL;
  return reg->name;
d2247 2
a2248 2
/* Return the GDB type object for the "standard" data type
   of data in register N.  */
d2251 1
a2251 1
rs6000_register_type (struct gdbarch *gdbarch, int n)
a2253 1
  const struct reg *reg = tdep->regs + n;
d2255 6
a2260 25
  if (reg->fpr)
    return builtin_type_double;
  else
    {
      int size = regsize (reg, tdep->wordsize);
      switch (size)
	{
	case 0:
	  return builtin_type_int0;
	case 4:
	  return builtin_type_uint32;
	case 8:
	  if (tdep->ppc_ev0_regnum <= n && n <= tdep->ppc_ev31_regnum)
	    return rs6000_builtin_type_vec64 (gdbarch);
	  else
	    return builtin_type_uint64;
	  break;
	case 16:
	  return rs6000_builtin_type_vec128 (gdbarch);
	  break;
	default:
	  internal_error (__FILE__, __LINE__, _("Register %d size %d unknown"),
			  n, size);
	}
    }
d2265 2
a2266 2
rs6000_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			    struct reggroup *group)
a2268 3
  int float_p;
  int vector_p;
  int general_p;
d2270 8
a2277 2
  if (gdbarch_register_name (gdbarch, regnum) == NULL
      || *gdbarch_register_name (gdbarch, regnum) == '\0')
a2278 40
  if (group == all_reggroup)
    return 1;

  float_p = (regnum == tdep->ppc_fpscr_regnum
	     || (regnum >= tdep->ppc_fp0_regnum
		 && regnum < tdep->ppc_fp0_regnum + 32));
  if (group == float_reggroup)
    return float_p;

  vector_p = ((tdep->ppc_vr0_regnum >= 0
	       && regnum >= tdep->ppc_vr0_regnum
	       && regnum < tdep->ppc_vr0_regnum + 32)
	      || (tdep->ppc_ev0_regnum >= 0
		  && regnum >= tdep->ppc_ev0_regnum
		  && regnum < tdep->ppc_ev0_regnum + 32)
	      || regnum == tdep->ppc_vrsave_regnum - 1 /* vscr */
	      || regnum == tdep->ppc_vrsave_regnum
	      || regnum == tdep->ppc_acc_regnum
	      || regnum == tdep->ppc_spefscr_regnum);
  if (group == vector_reggroup)
    return vector_p;

  /* Note that PS aka MSR isn't included - it's a system register (and
     besides, due to GCC's CFI foobar you do not want to restore
     it).  */
  general_p = ((regnum >= tdep->ppc_gp0_regnum
		&& regnum < tdep->ppc_gp0_regnum + 32)
	       || regnum == tdep->ppc_toc_regnum
	       || regnum == tdep->ppc_cr_regnum
	       || regnum == tdep->ppc_lr_regnum
	       || regnum == tdep->ppc_ctr_regnum
	       || regnum == tdep->ppc_xer_regnum
	       || regnum == gdbarch_pc_regnum (gdbarch));
  if (group == general_reggroup)
    return general_p;

  if (group == save_reggroup || group == restore_reggroup)
    return general_p || vector_p || float_p;

  return 0;   
d2287 7
a2293 5
  const struct reg *reg = gdbarch_tdep (current_gdbarch)->regs + regnum;
  
  return (reg->fpr
          && TYPE_CODE (type) == TYPE_CODE_FLT
          && TYPE_LENGTH (type) != TYPE_LENGTH (builtin_type_double));
a2301 1
  const struct reg *reg = gdbarch_tdep (get_frame_arch (frame))->regs + regnum;
a2303 1
  gdb_assert (reg->fpr);
a2315 1
  const struct reg *reg = gdbarch_tdep (get_frame_arch (frame))->regs + regnum;
a2317 1
  gdb_assert (reg->fpr);
a2414 22
/* The E500 needs a custom reggroup function: it has anonymous raw
   registers, and default_register_reggroup_p assumes that anonymous
   registers are not members of any reggroup.  */
static int
e500_register_reggroup_p (struct gdbarch *gdbarch,
                          int regnum,
                          struct reggroup *group)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* The save and restore register groups need to include the
     upper-half registers, even though they're anonymous.  */
  if ((group == save_reggroup
       || group == restore_reggroup)
      && (tdep->ppc_ev0_upper_regnum <= regnum
          && regnum < tdep->ppc_ev0_upper_regnum + ppc_num_gprs))
    return 1;

  /* In all other regards, the default reggroup definition is fine.  */
  return default_register_reggroup_p (gdbarch, regnum, group);
}

a2600 364

/* The arrays here called registers_MUMBLE hold information about available
   registers.

   For each family of PPC variants, I've tried to isolate out the
   common registers and put them up front, so that as long as you get
   the general family right, GDB will correctly identify the registers
   common to that family.  The common register sets are:

   For the 60x family: hid0 hid1 iabr dabr pir

   For the 505 and 860 family: eie eid nri

   For the 403 and 403GC: icdbdr esr dear evpr cdbcr tsr tcr pit tbhi
   tblo srr2 srr3 dbsr dbcr iac1 iac2 dac1 dac2 dccr iccr pbl1
   pbu1 pbl2 pbu2

   Most of these register groups aren't anything formal.  I arrived at
   them by looking at the registers that occurred in more than one
   processor.
   
   Note: kevinb/2002-04-30: Support for the fpscr register was added
   during April, 2002.  Slot 70 is being used for PowerPC and slot 71
   for Power.  For PowerPC, slot 70 was unused and was already in the
   PPC_UISA_SPRS which is ideally where fpscr should go.  For Power,
   slot 70 was being used for "mq", so the next available slot (71)
   was chosen.  It would have been nice to be able to make the
   register numbers the same across processor cores, but this wasn't
   possible without either 1) renumbering some registers for some
   processors or 2) assigning fpscr to a really high slot that's
   larger than any current register number.  Doing (1) is bad because
   existing stubs would break.  Doing (2) is undesirable because it
   would introduce a really large gap between fpscr and the rest of
   the registers for most processors.  */

/* Convenience macros for populating register arrays.  */

/* Within another macro, convert S to a string.  */

#define STR(s)	#s

/* Return a struct reg defining register NAME that's 32 bits on 32-bit systems
   and 64 bits on 64-bit systems.  */
#define R(name)		{ STR(name), 4, 8, 0, 0, -1 }

/* Return a struct reg defining register NAME that's 32 bits on all
   systems.  */
#define R4(name)	{ STR(name), 4, 4, 0, 0, -1 }

/* Return a struct reg defining register NAME that's 64 bits on all
   systems.  */
#define R8(name)	{ STR(name), 8, 8, 0, 0, -1 }

/* Return a struct reg defining register NAME that's 128 bits on all
   systems.  */
#define R16(name)       { STR(name), 16, 16, 0, 0, -1 }

/* Return a struct reg defining floating-point register NAME.  */
#define F(name)		{ STR(name), 8, 8, 1, 0, -1 }

/* Return a struct reg defining a pseudo register NAME that is 64 bits
   long on all systems.  */
#define P8(name)	{ STR(name), 8, 8, 0, 1, -1 }

/* Return a struct reg defining register NAME that's 32 bits on 32-bit
   systems and that doesn't exist on 64-bit systems.  */
#define R32(name)	{ STR(name), 4, 0, 0, 0, -1 }

/* Return a struct reg defining register NAME that's 64 bits on 64-bit
   systems and that doesn't exist on 32-bit systems.  */
#define R64(name)	{ STR(name), 0, 8, 0, 0, -1 }

/* Return a struct reg placeholder for a register that doesn't exist.  */
#define R0		{ 0, 0, 0, 0, 0, -1 }

/* Return a struct reg defining an anonymous raw register that's 32
   bits on all systems.  */
#define A4              { 0, 4, 4, 0, 0, -1 }

/* Return a struct reg defining an SPR named NAME that is 32 bits on
   32-bit systems and 64 bits on 64-bit systems.  */
#define S(name)         { STR(name), 4, 8, 0, 0, ppc_spr_ ## name }
  
/* Return a struct reg defining an SPR named NAME that is 32 bits on
   all systems.  */
#define S4(name)        { STR(name), 4, 4, 0, 0, ppc_spr_ ## name }
  
/* Return a struct reg defining an SPR named NAME that is 32 bits on
   all systems, and whose SPR number is NUMBER.  */
#define SN4(name, number) { STR(name), 4, 4, 0, 0, (number) }
  
/* Return a struct reg defining an SPR named NAME that's 64 bits on
   64-bit systems and that doesn't exist on 32-bit systems.  */
#define S64(name)       { STR(name), 0, 8, 0, 0, ppc_spr_ ## name }
  
/* UISA registers common across all architectures, including POWER.  */

#define COMMON_UISA_REGS \
  /*  0 */ R(r0), R(r1), R(r2), R(r3), R(r4), R(r5), R(r6), R(r7),  \
  /*  8 */ R(r8), R(r9), R(r10),R(r11),R(r12),R(r13),R(r14),R(r15), \
  /* 16 */ R(r16),R(r17),R(r18),R(r19),R(r20),R(r21),R(r22),R(r23), \
  /* 24 */ R(r24),R(r25),R(r26),R(r27),R(r28),R(r29),R(r30),R(r31), \
  /* 32 */ F(f0), F(f1), F(f2), F(f3), F(f4), F(f5), F(f6), F(f7),  \
  /* 40 */ F(f8), F(f9), F(f10),F(f11),F(f12),F(f13),F(f14),F(f15), \
  /* 48 */ F(f16),F(f17),F(f18),F(f19),F(f20),F(f21),F(f22),F(f23), \
  /* 56 */ F(f24),F(f25),F(f26),F(f27),F(f28),F(f29),F(f30),F(f31), \
  /* 64 */ R(pc), R(ps)

/* UISA-level SPRs for PowerPC.  */
#define PPC_UISA_SPRS \
  /* 66 */ R4(cr),  S(lr), S(ctr), S4(xer), R4(fpscr)

/* UISA-level SPRs for PowerPC without floating point support.  */
#define PPC_UISA_NOFP_SPRS \
  /* 66 */ R4(cr),  S(lr), S(ctr), S4(xer), R0

/* Segment registers, for PowerPC.  */
#define PPC_SEGMENT_REGS \
  /* 71 */ R32(sr0),  R32(sr1),  R32(sr2),  R32(sr3),  \
  /* 75 */ R32(sr4),  R32(sr5),  R32(sr6),  R32(sr7),  \
  /* 79 */ R32(sr8),  R32(sr9),  R32(sr10), R32(sr11), \
  /* 83 */ R32(sr12), R32(sr13), R32(sr14), R32(sr15)

/* OEA SPRs for PowerPC.  */
#define PPC_OEA_SPRS \
  /*  87 */ S4(pvr), \
  /*  88 */ S(ibat0u), S(ibat0l), S(ibat1u), S(ibat1l), \
  /*  92 */ S(ibat2u), S(ibat2l), S(ibat3u), S(ibat3l), \
  /*  96 */ S(dbat0u), S(dbat0l), S(dbat1u), S(dbat1l), \
  /* 100 */ S(dbat2u), S(dbat2l), S(dbat3u), S(dbat3l), \
  /* 104 */ S(sdr1),   S64(asr),  S(dar),    S4(dsisr), \
  /* 108 */ S(sprg0),  S(sprg1),  S(sprg2),  S(sprg3),  \
  /* 112 */ S(srr0),   S(srr1),   S(tbl),    S(tbu),    \
  /* 116 */ S4(dec),   S(dabr),   S4(ear)

/* AltiVec registers.  */
#define PPC_ALTIVEC_REGS \
  /*119*/R16(vr0), R16(vr1), R16(vr2), R16(vr3), R16(vr4), R16(vr5), R16(vr6), R16(vr7),  \
  /*127*/R16(vr8), R16(vr9), R16(vr10),R16(vr11),R16(vr12),R16(vr13),R16(vr14),R16(vr15), \
  /*135*/R16(vr16),R16(vr17),R16(vr18),R16(vr19),R16(vr20),R16(vr21),R16(vr22),R16(vr23), \
  /*143*/R16(vr24),R16(vr25),R16(vr26),R16(vr27),R16(vr28),R16(vr29),R16(vr30),R16(vr31), \
  /*151*/R4(vscr), R4(vrsave)


/* On machines supporting the SPE APU, the general-purpose registers
   are 64 bits long.  There are SIMD vector instructions to treat them
   as pairs of floats, but the rest of the instruction set treats them
   as 32-bit registers, and only operates on their lower halves.

   In the GDB regcache, we treat their high and low halves as separate
   registers.  The low halves we present as the general-purpose
   registers, and then we have pseudo-registers that stitch together
   the upper and lower halves and present them as pseudo-registers.  */

/* SPE GPR lower halves --- raw registers.  */
#define PPC_SPE_GP_REGS \
  /*  0 */ R4(r0), R4(r1), R4(r2), R4(r3), R4(r4), R4(r5), R4(r6), R4(r7),  \
  /*  8 */ R4(r8), R4(r9), R4(r10),R4(r11),R4(r12),R4(r13),R4(r14),R4(r15), \
  /* 16 */ R4(r16),R4(r17),R4(r18),R4(r19),R4(r20),R4(r21),R4(r22),R4(r23), \
  /* 24 */ R4(r24),R4(r25),R4(r26),R4(r27),R4(r28),R4(r29),R4(r30),R4(r31)

/* SPE GPR upper halves --- anonymous raw registers.  */
#define PPC_SPE_UPPER_GP_REGS                   \
  /*  0 */ A4, A4, A4, A4, A4, A4, A4, A4,      \
  /*  8 */ A4, A4, A4, A4, A4, A4, A4, A4,      \
  /* 16 */ A4, A4, A4, A4, A4, A4, A4, A4,      \
  /* 24 */ A4, A4, A4, A4, A4, A4, A4, A4

/* SPE GPR vector registers --- pseudo registers based on underlying
   gprs and the anonymous upper half raw registers.  */
#define PPC_EV_PSEUDO_REGS \
/* 0*/P8(ev0), P8(ev1), P8(ev2), P8(ev3), P8(ev4), P8(ev5), P8(ev6), P8(ev7), \
/* 8*/P8(ev8), P8(ev9), P8(ev10),P8(ev11),P8(ev12),P8(ev13),P8(ev14),P8(ev15),\
/*16*/P8(ev16),P8(ev17),P8(ev18),P8(ev19),P8(ev20),P8(ev21),P8(ev22),P8(ev23),\
/*24*/P8(ev24),P8(ev25),P8(ev26),P8(ev27),P8(ev28),P8(ev29),P8(ev30),P8(ev31)

/* IBM POWER (pre-PowerPC) architecture, user-level view.  We only cover
   user-level SPR's.  */
static const struct reg registers_power[] =
{
  COMMON_UISA_REGS,
  /* 66 */ R4(cnd), S(lr), S(cnt), S4(xer), S4(mq),
  /* 71 */ R4(fpscr)
};

/* PowerPC UISA - a PPC processor as viewed by user-level code.  A UISA-only
   view of the PowerPC.  */
static const struct reg registers_powerpc[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_ALTIVEC_REGS
};

/* IBM PowerPC 403.

   Some notes about the "tcr" special-purpose register:
   - On the 403 and 403GC, SPR 986 is named "tcr", and it controls the
     403's programmable interval timer, fixed interval timer, and
     watchdog timer.
   - On the 602, SPR 984 is named "tcr", and it controls the 602's
     watchdog timer, and nothing else.

   Some of the fields are similar between the two, but they're not
   compatible with each other.  Since the two variants have different
   registers, with different numbers, but the same name, we can't
   splice the register name to get the SPR number.  */
static const struct reg registers_403[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* 119 */ S(icdbdr), S(esr),  S(dear), S(evpr),
  /* 123 */ S(cdbcr),  S(tsr),  SN4(tcr, ppc_spr_403_tcr), S(pit),
  /* 127 */ S(tbhi),   S(tblo), S(srr2), S(srr3),
  /* 131 */ S(dbsr),   S(dbcr), S(iac1), S(iac2),
  /* 135 */ S(dac1),   S(dac2), S(dccr), S(iccr),
  /* 139 */ S(pbl1),   S(pbu1), S(pbl2), S(pbu2)
};

/* IBM PowerPC 403GC.
   See the comments about 'tcr' for the 403, above.  */
static const struct reg registers_403GC[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* 119 */ S(icdbdr), S(esr),  S(dear), S(evpr),
  /* 123 */ S(cdbcr),  S(tsr),  SN4(tcr, ppc_spr_403_tcr), S(pit),
  /* 127 */ S(tbhi),   S(tblo), S(srr2), S(srr3),
  /* 131 */ S(dbsr),   S(dbcr), S(iac1), S(iac2),
  /* 135 */ S(dac1),   S(dac2), S(dccr), S(iccr),
  /* 139 */ S(pbl1),   S(pbu1), S(pbl2), S(pbu2),
  /* 143 */ S(zpr),    S(pid),  S(sgr),  S(dcwr),
  /* 147 */ S(tbhu),   S(tblu)
};

/* Motorola PowerPC 505.  */
static const struct reg registers_505[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* 119 */ S(eie), S(eid), S(nri)
};

/* Motorola PowerPC 860 or 850.  */
static const struct reg registers_860[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* 119 */ S(eie), S(eid), S(nri), S(cmpa),
  /* 123 */ S(cmpb), S(cmpc), S(cmpd), S(icr),
  /* 127 */ S(der), S(counta), S(countb), S(cmpe),
  /* 131 */ S(cmpf), S(cmpg), S(cmph), S(lctrl1),
  /* 135 */ S(lctrl2), S(ictrl), S(bar), S(ic_cst),
  /* 139 */ S(ic_adr), S(ic_dat), S(dc_cst), S(dc_adr),
  /* 143 */ S(dc_dat), S(dpdr), S(dpir), S(immr),
  /* 147 */ S(mi_ctr), S(mi_ap), S(mi_epn), S(mi_twc),
  /* 151 */ S(mi_rpn), S(md_ctr), S(m_casid), S(md_ap),
  /* 155 */ S(md_epn), S(m_twb), S(md_twc), S(md_rpn),
  /* 159 */ S(m_tw), S(mi_dbcam), S(mi_dbram0), S(mi_dbram1),
  /* 163 */ S(md_dbcam), S(md_dbram0), S(md_dbram1)
};

/* Motorola PowerPC 601.  Note that the 601 has different register numbers
   for reading and writing RTCU and RTCL.  However, how one reads and writes a
   register is the stub's problem.  */
static const struct reg registers_601[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* 119 */ S(hid0), S(hid1), S(iabr), S(dabr),
  /* 123 */ S(pir), S(mq), S(rtcu), S(rtcl)
};

/* Motorola PowerPC 602.
   See the notes under the 403 about 'tcr'.  */
static const struct reg registers_602[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* 119 */ S(hid0), S(hid1), S(iabr), R0,
  /* 123 */ R0, SN4(tcr, ppc_spr_602_tcr), S(ibr), S(esasrr),
  /* 127 */ S(sebr), S(ser), S(sp), S(lt)
};

/* Motorola/IBM PowerPC 603 or 603e.  */
static const struct reg registers_603[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* 119 */ S(hid0), S(hid1), S(iabr), R0,
  /* 123 */ R0, S(dmiss), S(dcmp), S(hash1),
  /* 127 */ S(hash2), S(imiss), S(icmp), S(rpa)
};

/* Motorola PowerPC 604 or 604e.  */
static const struct reg registers_604[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* 119 */ S(hid0), S(hid1), S(iabr), S(dabr),
  /* 123 */ S(pir), S(mmcr0), S(pmc1), S(pmc2),
  /* 127 */ S(sia), S(sda)
};

/* Motorola/IBM PowerPC 750 or 740.  */
static const struct reg registers_750[] =
{
  COMMON_UISA_REGS,
  PPC_UISA_SPRS,
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* 119 */ S(hid0), S(hid1), S(iabr), S(dabr),
  /* 123 */ R0, S(ummcr0), S(upmc1), S(upmc2),
  /* 127 */ S(usia), S(ummcr1), S(upmc3), S(upmc4),
  /* 131 */ S(mmcr0), S(pmc1), S(pmc2), S(sia),
  /* 135 */ S(mmcr1), S(pmc3), S(pmc4), S(l2cr),
  /* 139 */ S(ictc), S(thrm1), S(thrm2), S(thrm3)
};


/* Motorola PowerPC 7400.  */
static const struct reg registers_7400[] =
{
  /* gpr0-gpr31, fpr0-fpr31 */
  COMMON_UISA_REGS,
  /* cr, lr, ctr, xer, fpscr */
  PPC_UISA_SPRS,
  /* sr0-sr15 */
  PPC_SEGMENT_REGS,
  PPC_OEA_SPRS,
  /* vr0-vr31, vrsave, vscr */
  PPC_ALTIVEC_REGS
  /* FIXME? Add more registers? */
};

/* Motorola e500.  */
static const struct reg registers_e500[] =
{
  /*   0 ..  31 */ PPC_SPE_GP_REGS,
  /*  32 ..  63 */ PPC_SPE_UPPER_GP_REGS,
  /*  64 ..  65 */ R(pc), R(ps),
  /*  66 ..  70 */ PPC_UISA_NOFP_SPRS,
  /*  71 ..  72 */ R8(acc), S4(spefscr),
  /* NOTE: Add new registers here the end of the raw register
     list and just before the first pseudo register.  */
  /*  73 .. 104 */ PPC_EV_PSEUDO_REGS
};

d2617 2
a2618 12
    /* Number of real registers.  */
    int nregs;

    /* Number of pseudo registers.  */
    int npregs;

    /* Number of total registers (the sum of nregs and npregs).  */
    int num_tot_regs;

    /* Table of register names; registers[R] is the name of the register
       number R.  */
    const struct reg *regs;
a2620 38
#define tot_num_registers(list) (sizeof (list) / sizeof((list)[0]))

static int
num_registers (const struct reg *reg_list, int num_tot_regs)
{
  int i;
  int nregs = 0;

  for (i = 0; i < num_tot_regs; i++)
    if (!reg_list[i].pseudo)
      nregs++;
       
  return nregs;
}

static int
num_pseudo_registers (const struct reg *reg_list, int num_tot_regs)
{
  int i;
  int npregs = 0;

  for (i = 0; i < num_tot_regs; i++)
    if (reg_list[i].pseudo)
      npregs ++; 

  return npregs;
}

/* Information in this table comes from the following web sites:
   IBM:       http://www.chips.ibm.com:80/products/embedded/
   Motorola:  http://www.mot.com/SPS/PowerPC/

   I'm sure I've got some of the variant descriptions not quite right.
   Please report any inaccuracies you find to GDB's maintainer.

   If you add entries to this table, please be sure to allow the new
   value as an argument to the --with-cpu flag, in configure.in.  */

a2622 1

d2624 1
a2624 2
   bfd_mach_ppc, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2626 1
a2626 2
   bfd_mach_rs6k, -1, -1, tot_num_registers (registers_power),
   registers_power},
d2628 1
a2628 2
   bfd_mach_ppc_403, -1, -1, tot_num_registers (registers_403),
   registers_403},
d2630 1
a2630 2
   bfd_mach_ppc_601, -1, -1, tot_num_registers (registers_601),
   registers_601},
d2632 1
a2632 2
   bfd_mach_ppc_602, -1, -1, tot_num_registers (registers_602),
   registers_602},
d2634 1
a2634 2
   bfd_mach_ppc_603, -1, -1, tot_num_registers (registers_603),
   registers_603},
d2636 1
a2636 2
   604, -1, -1, tot_num_registers (registers_604),
   registers_604},
d2638 1
a2638 2
   bfd_mach_ppc_403gc, -1, -1, tot_num_registers (registers_403GC),
   registers_403GC},
d2640 1
a2640 2
   bfd_mach_ppc_505, -1, -1, tot_num_registers (registers_505),
   registers_505},
d2642 1
a2642 2
   bfd_mach_ppc_860, -1, -1, tot_num_registers (registers_860),
   registers_860},
d2644 1
a2644 2
   bfd_mach_ppc_750, -1, -1, tot_num_registers (registers_750),
   registers_750},
d2646 1
a2646 2
   bfd_mach_ppc_7400, -1, -1, tot_num_registers (registers_7400),
   registers_7400},
d2648 1
a2648 2
   bfd_mach_ppc_e500, -1, -1, tot_num_registers (registers_e500),
   registers_e500},
d2652 1
a2652 2
   bfd_mach_ppc64, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2654 1
a2654 2
   bfd_mach_ppc_620, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2656 1
a2656 2
   bfd_mach_ppc_630, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2658 1
a2658 2
   bfd_mach_ppc_a35, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2660 1
a2660 2
   bfd_mach_ppc_rs64ii, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2662 1
a2662 2
   bfd_mach_ppc_rs64iii, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2666 1
a2666 2
   bfd_mach_rs6k_rs1, -1, -1, tot_num_registers (registers_power),
   registers_power},
d2668 1
a2668 2
   bfd_mach_rs6k_rsc, -1, -1, tot_num_registers (registers_power),
   registers_power},
d2670 1
a2670 2
   bfd_mach_rs6k_rs2, -1, -1, tot_num_registers (registers_power),
   registers_power},
d2672 1
a2672 1
  {0, 0, 0, 0, 0, 0, 0, 0}
a2674 16
/* Initialize the number of registers and pseudo registers in each variant.  */

static void
init_variants (void)
{
  struct variant *v;

  for (v = variants; v->name; v++)
    {
      if (v->nregs == -1)
        v->nregs = num_registers (v->regs, v->num_tot_regs);
      if (v->npregs == -1)
        v->npregs = num_pseudo_registers (v->regs, v->num_tot_regs);
    }  
}

d2962 1
a2962 3
  int wordsize, from_xcoff_exec, from_elf_exec, i, off;
  struct reg *regs;
  const struct variant *v;
d2968 5
d2998 2
a3008 21
  /* Find a candidate among extant architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Word size in the various PowerPC bfd_arch_info structs isn't
         meaningful, because 64-bit CPUs can run in 32-bit mode.  So, perform
         separate word size check.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->wordsize == wordsize)
	return arches->gdbarch;
    }

  /* None found, create a new architecture from INFO, whose bfd_arch_info
     validity depends on the source:
       - executable		useless
       - rs6000_host_arch()	good
       - core file		good
       - "set arch"		trust blindly
       - GDB startup		useless but harmless */

a3020 2
  tdep = XCALLOC (1, struct gdbarch_tdep);
  tdep->wordsize = wordsize;
d3042 226
d3270 27
a3296 2
  /* Initialize the number of real and pseudo registers in each variant.  */
  init_variants ();
a3297 36
  /* Choose variant.  */
  v = find_variant_by_arch (arch, mach);
  if (!v)
    return NULL;

  tdep->regs = v->regs;

  tdep->ppc_gp0_regnum = 0;
  tdep->ppc_toc_regnum = 2;
  tdep->ppc_ps_regnum = 65;
  tdep->ppc_cr_regnum = 66;
  tdep->ppc_lr_regnum = 67;
  tdep->ppc_ctr_regnum = 68;
  tdep->ppc_xer_regnum = 69;
  if (v->mach == bfd_mach_ppc_601)
    tdep->ppc_mq_regnum = 124;
  else if (arch == bfd_arch_rs6000)
    tdep->ppc_mq_regnum = 70;
  else
    tdep->ppc_mq_regnum = -1;
  tdep->ppc_fp0_regnum = 32;
  tdep->ppc_fpscr_regnum = (arch == bfd_arch_rs6000) ? 71 : 70;
  tdep->ppc_sr0_regnum = 71;
  tdep->ppc_vr0_regnum = -1;
  tdep->ppc_vrsave_regnum = -1;
  tdep->ppc_ev0_upper_regnum = -1;
  tdep->ppc_ev0_regnum = -1;
  tdep->ppc_ev31_regnum = -1;
  tdep->ppc_acc_regnum = -1;
  tdep->ppc_spefscr_regnum = -1;

  set_gdbarch_pc_regnum (gdbarch, 64);
  set_gdbarch_sp_regnum (gdbarch, 1);
  set_gdbarch_deprecated_fp_regnum (gdbarch, 1);
  set_gdbarch_fp0_regnum (gdbarch, 32);
  set_gdbarch_register_sim_regno (gdbarch, rs6000_register_sim_regno);
d3313 5
a3317 43
  if (v->arch == bfd_arch_rs6000)
    tdep->ppc_sr0_regnum = -1;
  else if (v->arch == bfd_arch_powerpc)
    switch (v->mach)
      {
      case bfd_mach_ppc: 
        tdep->ppc_sr0_regnum = -1;
	tdep->ppc_vr0_regnum = 71;
	tdep->ppc_vrsave_regnum = 104;
	break;
      case bfd_mach_ppc_7400:
	tdep->ppc_vr0_regnum = 119;
	tdep->ppc_vrsave_regnum = 152;
	break;
      case bfd_mach_ppc_e500:
        tdep->ppc_toc_regnum = -1;
        tdep->ppc_ev0_upper_regnum = 32;
	tdep->ppc_ev0_regnum = 73;
	tdep->ppc_ev31_regnum = 104;
        tdep->ppc_acc_regnum = 71;
        tdep->ppc_spefscr_regnum = 72;
        tdep->ppc_fp0_regnum = -1;
        tdep->ppc_fpscr_regnum = -1;
        tdep->ppc_sr0_regnum = -1;
        set_gdbarch_pseudo_register_read (gdbarch, e500_pseudo_register_read);
        set_gdbarch_pseudo_register_write (gdbarch, e500_pseudo_register_write);
        set_gdbarch_register_reggroup_p (gdbarch, e500_register_reggroup_p);
	break;

      case bfd_mach_ppc64:
      case bfd_mach_ppc_620:
      case bfd_mach_ppc_630:
      case bfd_mach_ppc_a35:
      case bfd_mach_ppc_rs64ii:
      case bfd_mach_ppc_rs64iii:
        /* These processor's register sets don't have segment registers.  */
        tdep->ppc_sr0_regnum = -1;
        break;
      }   
  else
    internal_error (__FILE__, __LINE__,
                    _("rs6000_gdbarch_init: "
                    "received unexpected BFD 'arch' value"));
a3320 3
  /* Sanity check on registers.  */
  gdb_assert (strcmp (tdep->regs[tdep->ppc_gp0_regnum].name, "r0") == 0);

d3327 2
a3328 5
  set_gdbarch_num_regs (gdbarch, v->nregs);
  set_gdbarch_num_pseudo_regs (gdbarch, v->npregs);
  set_gdbarch_register_name (gdbarch, rs6000_register_name);
  set_gdbarch_register_type (gdbarch, rs6000_register_type);
  set_gdbarch_register_reggroup_p (gdbarch, rs6000_register_reggroup_p);
a3414 11
      /* FIXME: pgilliam/2005-10-21: Assume all PowerPC 64-bit linux systems
         have altivec registers.  If not, ptrace will fail the first time it's
         called to access one and will not be called again.  This wart will
         be removed when Daniel Jacobowitz's proposal for autodetecting target
         registers is implemented. */
      if ((v->arch == bfd_arch_powerpc) && ((v->mach)== bfd_mach_ppc64))
        {
          tdep->ppc_vr0_regnum = 71;
          tdep->ppc_vrsave_regnum = 104;
        }
      /* Fall Thru */
d3432 12
a3443 1
  init_sim_regno_table (gdbarch);
d3468 16
@


1.288
log
@	* ppc-linux-nat.c (right_fill_reg): Delete.
	(supply_gregset): Use ppc_supply_gregset.
	(supply_fpregset): Use ppc_supply_fpregset.
	(fill_gregset): Use ppc_collect_gregset.
	(fill_fpregset): Use ppc_collect_fpregset.
	* ppc-linux-tdep.c (PPC_LINUX_PT_*): Don't define.
	(right_supply_register, ppc_linux_supply_gregset): Delete.
	(ppc32_linux_supply_gregset, ppc64_linux_supply_gregset): Delete.
	(ppc_linux_supply_fpregset): Delete.
	(ppc_linux_collect_gregset): New function.
	(ppc32_linux_reg_offsets, ppc64_linux_reg_offsets): New.
	(ppc32_linux_gregset, ppc64_linux_gregset): Update to use reg offsets,
	ppc_linux_supply_gregset, and ppc_collect_gregset.
	(ppc_linux_fpregset): Rename to ppc32_linux_fpregset and update.
	(ppc_linux_gregset, ppc_linux_fpregset): New functions.
	(ppc_linux_regset_from_core_section): Update.
	* ppc-tdep.h (ppc_linux_gregset, ppc_linux_fpregset): Declare.
	(ppc_linux_supply_gregset, ppc_linux_supply_fpregset): Delete.
	(struct ppc_reg_offsets): Add gpr_size, xr_size, fpscr_size fields.
	* ppcobsd-tdep.c (ppcobsd_supply_gregset): Delete FIXME and assert.
	(ppcobsd_collect_gregset): Likewise.
	(_initialize_ppcnbsd_tdep): Init gpr_size, xr_size, fpscr_size.
	* ppcnbsd-tdep.c (_initialize_ppcobsd_tdep): Likewise.
	* ppcobsd-nat.c (_initialize_ppcobsd_nat): Likewise.
	* rs6000-aix-tdep.c (rs6000_aix32_reg_offsets): Likewise.
	(rs6000_aix64_reg_offsets): Likewise.
	(rs6000_aix_supply_regset): Call ppc_supply_fpregset without testing
	ppc_floating_point_unit_p.
	(rs6000_aix_collect_regset): Similarly.
	* rs6000-tdep.c (ppc_supply_reg): Add regsize param.  Adjust offset
	when regsize is larger than regcache register size.
	(ppc_collect_reg): Similarly zero pad when regsize is larger than
	regcache register size.
	(ppc_greg_offset): New function, split out from..
	(ppc_supply_gregset): ..here.  Separate code handling all regs from
	single reg case.  Correct xer offset.
	(ppc_fpreg_offset): New function, split out from..
	(ppc_supply_fpregset): ..here.  Separate code handling all regs from
	single reg case.
	(ppc_collect_gregset, ppc_collect_fpregset): Likewise.
	(ppc_supply_fpregset, ppc_collect_fpregset): Don't assert we have
	a fp unit, instead return if no fp.
@
text
@d1685 1
a1685 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1692 1
a1692 1
  int wordsize = gdbarch_tdep (current_gdbarch)->wordsize;
d1703 1
a1703 1
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));
d1741 1
a1741 1
      int reg_size = register_size (current_gdbarch, ii + 3);
d1788 1
a1788 1
	  int adj = gdbarch_byte_order (current_gdbarch)
d1802 1
a1802 1
				 gdbarch_sp_regnum (current_gdbarch),
d1846 1
a1846 1
				 gdbarch_sp_regnum (current_gdbarch), sp);
d1893 1
a1893 1
  regcache_raw_write_signed (regcache, gdbarch_sp_regnum (current_gdbarch), sp);
d1920 1
a1920 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1926 1
a1926 1
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));
d2127 2
a2128 1
  pc = read_memory_addr (ii, gdbarch_tdep (current_gdbarch)->wordsize); /* (r11) value */
d2283 2
a2284 2
  if (gdbarch_register_name (current_gdbarch, regnum) == NULL
      || *gdbarch_register_name (current_gdbarch, regnum) == '\0')
d2318 1
a2318 1
	       || regnum == gdbarch_pc_regnum (current_gdbarch));
d2347 1
a2347 1
  const struct reg *reg = gdbarch_tdep (current_gdbarch)->regs + regnum;
d2363 1
a2363 1
  const struct reg *reg = gdbarch_tdep (current_gdbarch)->regs + regnum;
d2412 1
a2412 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d3228 1
a3228 1
					 gdbarch_pc_regnum (current_gdbarch));
d3235 1
a3235 1
			 (next_frame, gdbarch_sp_regnum (current_gdbarch)),
d3274 1
a3274 1
		(next_frame, gdbarch_sp_regnum (current_gdbarch));
d3313 1
a3313 1
			gdbarch_sp_regnum (current_gdbarch), cache->base);
d3392 1
a3392 1
  cache->saved_regs[gdbarch_pc_regnum (current_gdbarch)] =
d3404 1
a3404 1
			(next_frame, gdbarch_sp_regnum (current_gdbarch));
d3818 1
a3818 1
rs6000_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
d3820 1
a3820 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.288.2.1
log
@2007-10-21  Luis Machado  <luisgpm@@br.ibm.com>

	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): New function.
	* (rs6000_gdbarch_init): Install ppc_dwarf2_frame_init_reg as
	default dwarf2_frame_set_init_reg function.
@
text
@a3470 62
/* DWARF-2 frame support.  Used to handle the detection of
  clobbered registers during function calls.  */

static void
ppc_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
			    struct dwarf2_frame_state_reg *reg,
			    struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* PPC32 and PPC64 ABI's are the same regarding volatile and
     non-volatile registers.  We will use the same code for both.  */

  /* Call-saved GP registers.  */
  if ((regnum >= tdep->ppc_gp0_regnum + 14
      && regnum <= tdep->ppc_gp0_regnum + 31)
      || (regnum == tdep->ppc_gp0_regnum + 1))
    reg->how = DWARF2_FRAME_REG_SAME_VALUE;

  /* Call-clobbered GP registers.  */
  if ((regnum >= tdep->ppc_gp0_regnum + 3
      && regnum <= tdep->ppc_gp0_regnum + 12)
      || (regnum == tdep->ppc_gp0_regnum))
    reg->how = DWARF2_FRAME_REG_UNDEFINED;

  /* Deal with FP registers, if supported.  */
  if (tdep->ppc_fp0_regnum >= 0)
    {
      /* Call-saved FP registers.  */
      if ((regnum >= tdep->ppc_fp0_regnum + 14
	  && regnum <= tdep->ppc_fp0_regnum + 31))
	reg->how = DWARF2_FRAME_REG_SAME_VALUE;

      /* Call-clobbered FP registers.  */
      if ((regnum >= tdep->ppc_fp0_regnum
	  && regnum <= tdep->ppc_fp0_regnum + 13))
	reg->how = DWARF2_FRAME_REG_UNDEFINED;
    }

  /* Deal with ALTIVEC registers, if supported.  */
  if (tdep->ppc_vr0_regnum > 0 && tdep->ppc_vrsave_regnum > 0)
    {
      /* Call-saved Altivec registers.  */
      if ((regnum >= tdep->ppc_vr0_regnum + 20
	  && regnum <= tdep->ppc_vr0_regnum + 31)
	  || regnum == tdep->ppc_vrsave_regnum)
	reg->how = DWARF2_FRAME_REG_SAME_VALUE;

      /* Call-clobbered Altivec registers.  */
      if ((regnum >= tdep->ppc_vr0_regnum
	  && regnum <= tdep->ppc_vr0_regnum + 19))
	reg->how = DWARF2_FRAME_REG_UNDEFINED;
    }

  /* Handle PC register and Stack Pointer correctly.  */
  if (regnum == gdbarch_pc_regnum (current_gdbarch))
    reg->how = DWARF2_FRAME_REG_RA;
  else if (regnum == gdbarch_sp_regnum (current_gdbarch))
    reg->how = DWARF2_FRAME_REG_CFA;
}


a3776 3
  /* Frame handling.  */
  dwarf2_frame_set_init_reg (gdbarch, ppc_dwarf2_frame_init_reg);

@


1.287
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d305 3
d310 1
a310 1
		const gdb_byte *regs, size_t offset)
d313 11
a323 1
    regcache_raw_supply (regcache, regnum, regs + offset);
d326 3
d331 1
a331 1
		 gdb_byte *regs, size_t offset)
d334 19
a352 1
    regcache_raw_collect (regcache, regnum, regs + offset);
d355 53
d420 28
a447 1
  int i;
d449 2
a450 28
  for (i = tdep->ppc_gp0_regnum, offset = offsets->r0_offset;
       i < tdep->ppc_gp0_regnum + ppc_num_gprs;
       i++, offset += 4)
    {
      if (regnum == -1 || regnum == i)
	ppc_supply_reg (regcache, i, gregs, offset);
    }

  if (regnum == -1 || regnum == gdbarch_pc_regnum (current_gdbarch))
    ppc_supply_reg (regcache, gdbarch_pc_regnum (current_gdbarch),
		    gregs, offsets->pc_offset);
  if (regnum == -1 || regnum == tdep->ppc_ps_regnum)
    ppc_supply_reg (regcache, tdep->ppc_ps_regnum,
		    gregs, offsets->ps_offset);
  if (regnum == -1 || regnum == tdep->ppc_cr_regnum)
    ppc_supply_reg (regcache, tdep->ppc_cr_regnum,
		    gregs, offsets->cr_offset);
  if (regnum == -1 || regnum == tdep->ppc_lr_regnum)
    ppc_supply_reg (regcache, tdep->ppc_lr_regnum,
		    gregs, offsets->lr_offset);
  if (regnum == -1 || regnum == tdep->ppc_ctr_regnum)
    ppc_supply_reg (regcache, tdep->ppc_ctr_regnum,
		    gregs, offsets->ctr_offset);
  if (regnum == -1 || regnum == tdep->ppc_xer_regnum)
    ppc_supply_reg (regcache, tdep->ppc_xer_regnum,
		    gregs, offsets->cr_offset);
  if (regnum == -1 || regnum == tdep->ppc_mq_regnum)
    ppc_supply_reg (regcache, tdep->ppc_mq_regnum, gregs, offsets->mq_offset);
d462 2
a463 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct ppc_reg_offsets *offsets = regset->descr;
a464 1
  int i;
d466 2
a467 1
  gdb_assert (ppc_floating_point_unit_p (gdbarch));
d469 3
a471 4
  offset = offsets->f0_offset;
  for (i = tdep->ppc_fp0_regnum;
       i < tdep->ppc_fp0_regnum + ppc_num_fprs;
       i++, offset += 8)
d473 10
a482 2
      if (regnum == -1 || regnum == i)
	ppc_supply_reg (regcache, i, fpregs, offset);
d485 3
a487 3
  if (regnum == -1 || regnum == tdep->ppc_fpscr_regnum)
    ppc_supply_reg (regcache, tdep->ppc_fpscr_regnum,
		    fpregs, offsets->fpscr_offset);
d491 1
a491 1
   REGSET. from register cache REGCACHE into the buffer specified by
d504 28
a531 1
  int i;
d533 2
a534 30
  offset = offsets->r0_offset;
  for (i = tdep->ppc_gp0_regnum;
       i < tdep->ppc_gp0_regnum + ppc_num_gprs;
       i++, offset += 4)
    {
      if (regnum == -1 || regnum == i)
	ppc_collect_reg (regcache, i, gregs, offset);
    }

  if (regnum == -1 || regnum == gdbarch_pc_regnum (current_gdbarch))
    ppc_collect_reg (regcache, gdbarch_pc_regnum (current_gdbarch),
		     gregs, offsets->pc_offset);
  if (regnum == -1 || regnum == tdep->ppc_ps_regnum)
    ppc_collect_reg (regcache, tdep->ppc_ps_regnum,
		     gregs, offsets->ps_offset);
  if (regnum == -1 || regnum == tdep->ppc_cr_regnum)
    ppc_collect_reg (regcache, tdep->ppc_cr_regnum,
		     gregs, offsets->cr_offset);
  if (regnum == -1 || regnum == tdep->ppc_lr_regnum)
    ppc_collect_reg (regcache, tdep->ppc_lr_regnum,
		     gregs, offsets->lr_offset);
  if (regnum == -1 || regnum == tdep->ppc_ctr_regnum)
    ppc_collect_reg (regcache, tdep->ppc_ctr_regnum,
		     gregs, offsets->ctr_offset);
  if (regnum == -1 || regnum == tdep->ppc_xer_regnum)
    ppc_collect_reg (regcache, tdep->ppc_xer_regnum,
		     gregs, offsets->xer_offset);
  if (regnum == -1 || regnum == tdep->ppc_mq_regnum)
    ppc_collect_reg (regcache, tdep->ppc_mq_regnum,
		     gregs, offsets->mq_offset);
d538 1
a538 1
   REGSET. from register cache REGCACHE into the buffer specified by
d548 2
a549 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct ppc_reg_offsets *offsets = regset->descr;
a550 1
  int i;
d552 2
a553 1
  gdb_assert (ppc_floating_point_unit_p (gdbarch));
d555 3
a557 4
  offset = offsets->f0_offset;
  for (i = tdep->ppc_fp0_regnum;
       i <= tdep->ppc_fp0_regnum + ppc_num_fprs;
       i++, offset += 8)
d559 10
a568 2
      if (regnum == -1 || regnum == i)
	ppc_collect_reg (regcache, i, fpregs, offset);
d571 3
a573 3
  if (regnum == -1 || regnum == tdep->ppc_fpscr_regnum)
    ppc_collect_reg (regcache, tdep->ppc_fpscr_regnum,
		     fpregs, offsets->fpscr_offset);
@


1.286
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.285
log
@	* gdbtypes.c (builtin_type_v2_double, builtin_type_v4_float,
	builtin_type_v2_int64, builtin_type_v4_int32, builtin_type_v8_int16,
	builtin_type_v16_int8, builtin_type_v2_float, builtin_type_v2_int32,
	builtin_type_v4_int16, builtin_type_v8_int8, builtin_type_v4sf,
	builtin_type_v4si, builtin_type_v16qi, builtin_type_v8qi,
	builtin_type_v8hi, builtin_type_v4hi, builtin_type_v2si,
	builtin_type_vec64, builtin_type_vec128): Remove.
	(init_simd_type): Remove.
	(init_vector_type): Make global.
	(build_builtin_type_vec64, build_builtin_type_vec128): Remove.
	(build_gdbtypes): Do not build vector types.
	(_initialize_gdbtypes): Do not swap vector types.
	* gdbtypes.h (builtin_type_v2_double, builtin_type_v4_float,
	builtin_type_v2_int64, builtin_type_v4_int32, builtin_type_v8_int16,
	builtin_type_v16_int8, builtin_type_v2_float, builtin_type_v2_int32,
	builtin_type_v4_int16, builtin_type_v8_int8, builtin_type_v4sf,
	builtin_type_v4si, builtin_type_v16qi, builtin_type_v8qi,
	builtin_type_v8hi, builtin_type_v4hi, builtin_type_v2si,
	builtin_type_vec64, builtin_type_vec128): Remove declarations.
	(init_vector_type): Add prototype.

	* i386-tdep.h (struct gdbarch_tdep): Add i386_mmx_type and
	i386_sse_type members.
	(i386_mmx_type, i386_sse_type): Change from variables to functions.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Remove variables.
	(i386_init_types): Do not build vector types.
	(i386_mmx_type, i386_sse_type): New functions.
	(i386_register_type): Call them instead of using global variables.
	(i386_gdbarch_init): Use XCALLOC to allocate tdep structure.
	* amd64-tdep.c (amd64_register_type): Call i386_sse_type instead
	of using global variable.

	* rs6000-tdep.h (struct gdbarch_tdep): Add ppc_builtin_type_vec64
	and ppc_builtin_type_vec128 members.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): New function.
	(rs6000_builtin_type_vec128): Likewise.
	(rs6000_register_type): Call them instead of using builtin_type_vec64
	and builtin_type_vec128.
	(rs6000_gdbarch_init): Use XCALLOC to allocate tdep structure.

	* spu-tdep.c (struct gdbarch_tdep): New data type.
	(spu_builtin_type_vec128): Remove variable.
	(spu_builtin_type_vec128): New function.
	(spu_register_type): Call it instead of using global variable.
	(spu_gdbarch_init): Allocate tdep structure.
	(spu_init_vector_type): Remove function.
	(_initialize_spu_tdep): Do not call it.
@
text
@d345 3
a347 2
  if (regnum == -1 || regnum == PC_REGNUM)
    ppc_supply_reg (regcache, PC_REGNUM, gregs, offsets->pc_offset);
d422 3
a424 2
  if (regnum == -1 || regnum == PC_REGNUM)
    ppc_collect_reg (regcache, PC_REGNUM, gregs, offsets->pc_offset);
d1702 3
a1704 1
  regcache_cooked_read_unsigned (regcache, SP_REGNUM, &saved_sp);
d1746 2
a1747 1
      regcache_raw_write_signed (regcache, SP_REGNUM, sp);
d1794 1
a1794 1
  regcache_raw_write_signed (regcache, SP_REGNUM, sp);
d2218 1
a2218 1
	       || regnum == PC_REGNUM);
d3127 2
a3128 1
  return frame_unwind_register_unsigned (next_frame, PC_REGNUM);
d3134 3
a3136 3
  return frame_id_build (frame_unwind_register_unsigned (next_frame,
							 SP_REGNUM),
			 frame_pc_unwind (next_frame));
d3173 2
a3174 1
  cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d3212 2
a3213 1
  trad_frame_set_value (cache->saved_regs, SP_REGNUM, cache->base);
d3292 2
a3293 1
  cache->saved_regs[PC_REGNUM] = cache->saved_regs[tdep->ppc_lr_regnum];
d3303 2
a3304 1
    cache->initial_sp = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
@


1.284
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d2027 82
d2154 1
a2154 1
	    return builtin_type_vec64;
d2159 1
a2159 1
	  return builtin_type_vec128;
d3449 1
a3449 1
  tdep = xmalloc (sizeof (struct gdbarch_tdep));
@


1.283
log
@	* gdbarch.sh (skip_trampoline_code): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (generic_skip_trampoline_code): Add FRAME argument.
	* arch-utils.h (generic_skip_trampoline_code): Likewise.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_skip_trampoline_code and skip_language_trampoline.

	* language.c (unk_lang_trampoline): Add FRAME argument.
	(skip_language_trampoline): Add FRAME argument.  Pass it to
	skip_trampoline callback.
	* language.h: Add forward declaration of struct frame_info.
	(struct language_defn): Add FRAME argument to skip_trampoline.
	(skip_language_trampoline): Add FRAME argument.
	* cp-abi.c (cplus_skip_trampoline): Add FRAME argument.  Pass it
	to skip_trampoline callback.
	* cp-abi.h: Add forward declaration of struct frame_info.
	(cplus_skip_trampoline): Add FRAME argument.
	(struct cp_abi_ops): Add FRAME argument to skip_trampoline callback.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.
	* objc-lang.c (objc_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.

	* minsyms.c (find_solib_trampoline_target): Add FRAME argument.
	* symtab.h (find_solib_trampoline_target): Likewise.
	* obsd-tdep.c (obsd_skip_solib_resolver): Pass current frame to
	find_solib_trampoline_target.

	* arm-tdep.c (arm_skip_stub): Add FRAME argument.  Read registers
	from FRAME instead of calling read_register.

	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Add FRAME
	argument.  Read registers from FRAME instead of using read_register.
	* hppa-tdep.c (hppa_skip_trampoline_code): Likewise.
	* hppa-tdep.h (hppa_skip_trampoline_code): Add FRAME argument.

	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Add FRAME
	argument.

	* m32c-tdep.c (m32c_skip_trampoline_code): Add FRAME argument.

	* mips-tdep.c (mips_skip_trampoline_code): Add FRAME argument.  Read
	registers from FRAME instead of using read_signed_register.

	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Add FRAME
	argument.
	(ppc64_standard_linkage_target): Likewise.  Read registers from FRAME
	instead of using read_register.
	(ppc64_skip_trampoline_code): Add FRAME argument.  Pass it to
	ppc64_standard_linkage_target.
	* rs6000-tdep.c (rs6000_skip_trampoline_code): Add FRAME argument.
	Pass it to find_solib_trampoline_target.  Read registers from FRAME
	instead of using read_register.

	* xstormy16-tdep.c (xstormy16_skip_trampoline_code): Add FRAME
	argument.
@
text
@a3500 2
  set_gdbarch_write_pc (gdbarch, generic_target_write_pc);

@


1.282
log
@	* gdbarch.sh (software_single_step): Replace REGCACHE argument by
	FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (resume): Pass current frame to SOFTWARE_SINGLE_STEP.

	* alpha-tdep.c (alpha_next_pc): Add FRAME argument.  Retrieve
	registers from FRAME instead of using read_register.
	(alpha_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to alpha_next_pc.  Use get_frame_pc instead of read_pc.
	* alpha-tdep.h (alpha_software_single_step): Replace REGCACHE
	argument by FRAME.

	* arm-tdep.c (shifted_reg_val): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.
	(arm_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to arm_get_next_pc.  Use get_frame_pc instead of read_register.
	* arm-tdep.h (arm_software_single_step): Replace REGCACHE
	argument by FRAME.

	* cris-tdep.c (find_step_target): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(cris_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to find_step_target.

	* mips-tdep.c (mips32_next_pc): Add FRAME argument.  Read registers
	from FRAME instead of using read_register / read_signed_register.
	(extended_mips16_next_pc): Likewise.
	(mips16_next_pc): Likewise.
	(mips_next_pc): Likewise.
	(mips_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to mips_next_pc.  Use get_frame_pc instead of read_pc.
	* mips-tdep.h (mips_software_single_step): Replace REGCACHE
	argument by FRAME.

	* rs6000-tdep.c (branch_dest): Add FRAME argument.  Use it instead
	of current frame.  Read registers from FRAME.
	(deal_with_atomic_sequence): Add FRAME argument.  Pass it to
	branch_dest.  Use get_frame_pc instead of read_pc.
	(rs6000_software_single_step): Likewise.
	(bl_to_blrl_insn_p): Do not call branch_dest.
	* rs6000-tdep.h (rs6000_software_single_step): Replace REGCACHE
	argument by FRAME.

	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Add FRAME argument.
	Read registers from FRAME instead of current regcache.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Likewise.
	* sparcnbsd-tdep.c (sparcnbsd_step_trap): Likewise.
	* sparc-tdep.c (sparc_address_from_register): Remove.
	(sparc_analyze_control_transfer): Pass FRAME argument instead of
	GDBARCH.  Pass FRAME to step_trap callback.
	(sparc_step_trap): Add FRAME argument.
	(space_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to sparc_analyze_control_transfer.  Read registers from FRAME instead
	of calling sparc_address_from_register.
	* sparc-tdep.h (struct gdbarch_tdep): Add FRAME argument to
	step_trap callback.
	(sparc_address_from_register): Remove prototype.
	(sparc_software_single_step): Replace REGCACHE argument by FRAME.
	(sparcnbsd_step_trap): Add FRAME argument.

	* spu-tdep.c (spu_software_single_step): Replace REGCACHE argument
	by FRAME.  Read registers from FRAME instead of REGCACHE.
@
text
@d1975 1
a1975 1
rs6000_skip_trampoline_code (CORE_ADDR pc)
d2012 1
a2012 1
  solib_target_pc = find_solib_trampoline_target (pc);
d2022 1
a2022 1
  ii = read_register (11);	/* r11 holds destination addr   */
@


1.281
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SKIP_TRAMPOLINE_CODE): Replace by
	gdbarch_skip_trampoline_code.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise (comment).
	* objc-lang.c (objc_skip_trampoline)
	(objc_submethod_helper_data): Likewise.
	* m32c-lang.c (m32c_skip_trampoline_code): Likewise (comment).
	* infrun.c (handle_inferior_event): Likewise.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Likewise.
	* gdbarch.sh (IN_SOLIB_RETURN_TRAMPOLINE): Replace by
	gdbarch_in_solib_return_trampoline.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise (comment).
	* infrun.c (handle_inferior_event): Likewise.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d121 2
a122 2
static CORE_ADDR branch_dest (int opcode, int instr, CORE_ADDR pc,
			      CORE_ADDR safety);
d627 2
a628 1
branch_dest (int opcode, int instr, CORE_ADDR pc, CORE_ADDR safety)
d630 1
d661 1
a661 1
          dest = read_register (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum) & ~3;
d667 3
a669 9
	  if (dest < gdbarch_tdep (current_gdbarch)->text_segment_base)
	    {
	      struct frame_info *fi;

	      fi = get_current_frame ();
	      if (fi != NULL)
		dest = read_memory_addr (get_frame_base (fi) + SIG_FRAME_PC_OFFSET,
					 gdbarch_tdep (current_gdbarch)->wordsize);
	    }
d674 1
a674 1
          dest = read_register (gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum) & ~3;
d679 2
a680 2
	  if (dest < gdbarch_tdep (current_gdbarch)->text_segment_base)
            dest = read_register (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum) & ~3;
d689 1
a689 1
  return (dest < gdbarch_tdep (current_gdbarch)->text_segment_base) ? safety : dest;
d724 1
a724 1
deal_with_atomic_sequence (struct regcache *regcache)
d726 1
a726 1
  CORE_ADDR pc = read_pc ();
d761 1
a761 1
          branch_bp = branch_dest (opcode, insn, pc, breaks[0]);
d806 1
a806 1
rs6000_software_single_step (struct regcache *regcache)
d816 1
a816 1
  loc = read_pc ();
d820 1
a820 1
  if (deal_with_atomic_sequence (regcache))
d825 1
a825 1
  breaks[1] = branch_dest (opcode, insn, loc, breaks[0]);
d960 3
a962 2
  const int opcode = 18;
  const CORE_ADDR dest = branch_dest (opcode, insn, pc, -1);
d965 7
a971 3
  if (dest == -1)
    return 0;  /* Should never happen, but just return zero to be safe.  */
  
@


1.280
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1949 2
a1950 2
   Instead, use the IN_SOLIB_RETURN_TRAMPOLINE and
   SKIP_TRAMPOLINE_CODE hooks in handle_inferior_event() to skip past
@


1.279
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d2095 2
a2096 2
  if (REGISTER_NAME (regnum) == NULL
      || *REGISTER_NAME (regnum) == '\0')
@


1.278
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d705 1
a705 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1686 2
a1687 1
	  int adj = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? reg_size - len : 0;
d2224 1
a2224 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d3030 1
a3030 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
@


1.277
log
@	* inferior.h (read_sp): Remove prototype.
	* regcache.c (read_sp): Remove.
	* gcore.c (derive_stack_segment): Use get_frame_sp instead of read_sp.
	* infcall.c (call_function_by_hand): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use regcache instead
	of calling read_sp.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
@
text
@d292 3
a294 1
  gdb_assert (0 <= reg && reg <= NUM_REGS + NUM_PSEUDO_REGS);
@


1.276
log
@2007-05-10  Luis Machado  <luisgpm@@br.ibm.com>

	* rs6000-tdep.c: (deal_with_atomic_sequence) Stores branch instruction's
	opcode in the "opcode" variable and declares new variable "closing_insn".
@
text
@d1594 1
a1594 1
  CORE_ADDR saved_sp;
d1696 1
a1696 1
  saved_sp = read_sp ();
@


1.275
log
@2007-05-08  Paul Gilliam  <pgilliam@@us.ibm.com>
	    Luis Machado  <luisgpm@@br.ibm.com>

	* rs6000-tdep.c: (LWARX_MASK, LWARX_INSTRUCTION, LDARX_INSTRUCTION,
	STWCX_MASK, STWCX_INSTRUCTION, STDCX_INSTRUCTION, BC_MASK,
	BC_INSTRUCTION): Define.
	(deal_with_atomic_sequence): New function.
	(rs6000_software_single_step): Call deal_with_atomic_sequence.
	(rs6000_gdbarch_init): Install deal_with_atomic_sequence as
	gdbarch_software_single_step routine.
@
text
@d732 1
d738 1
a738 1
  const int opcode = BC_INSTRUCTION; /* Branch instruction's OPcode.  */
d762 1
d783 1
d790 6
a795 2
  /* Check for duplicated breakpoints.  */
  if (last_breakpoint && (breaks[1] == breaks[0]))
@


1.274
log
@	* rs6000-tdep.c (struct frame_extra_info): Delete.
@
text
@d710 89
a798 1
/* AIX does not support PT_STEP. Simulate it. */
d815 3
d3542 3
@


1.273
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@a613 13

/* Fill in fi->saved_regs */

struct frame_extra_info
{
  /* Functions calling alloca() change the value of the stack
     pointer. We need to use initial stack pointer (which is saved in
     r31 by gcc) in such cases. If a compiler emits traceback table,
     then we should use the alloca register specified in traceback
     table. FIXME. */
  CORE_ADDR initial_sp;		/* initial stack pointer. */
};

@


1.272
log
@	* gdbarch.sh (software_single_step): Remove "insert_breakpoints_p" and
	"sig" arguments, add "regcache" argument.
	* gdbarch.c, gdbarch.h: Regenerate.

	* infrun.c (resume): Update SOFTWARE_SINGLE_STEP call arguments.
	(handle_inferior_event): Call remove_single_step_breakpoints directly
	instead of calling SOFTWARE_SINGLE_STEP to remove breakpoints.

	* alpha-tdep.c (alpha_software_single_step): Update argument list.
	Remove handling of !insert_breakpoints_p case.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.

	* alpha-tdep.h (alpha_software_single_step): Update prototype.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
@
text
@d1718 1
a1718 1
  target_store_registers (-1);
@


1.271
log
@2007-04-12  Luis Machado  <luisgpm@@br.ibm.com>

	* gdbarch.sh (software_single_step): Change the return type
	from void to int and reformatted some comments to <= 80
	columns.
	* gdbarch.c, gdbarch.h: Regenerated.
	* alpha-tdep.c (alpha_software_single_step): Likewise.
	* alpha-tdep.h (alpha_software_single_step): Likewise.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.
	* infrun.c (resume): Check the return value from SOFTWARE_SINGLE_STEP
	and act accordingly.
@
text
@d726 1
a726 2
rs6000_software_single_step (enum target_signal signal,
			     int insert_breakpoints_p)
d736 1
a736 3
  if (insert_breakpoints_p)
    {
      loc = read_pc ();
d738 1
a738 1
      insn = read_memory_integer (loc, 4);
d740 3
a742 3
      breaks[0] = loc + breakp_sz;
      opcode = insn >> 26;
      breaks[1] = branch_dest (opcode, insn, loc, breaks[0]);
d744 3
a746 3
      /* Don't put two breakpoints on the same address. */
      if (breaks[1] == breaks[0])
	breaks[1] = -1;
d748 6
a753 7
      for (ii = 0; ii < 2; ++ii)
	{
	  /* ignore invalid breakpoint. */
	  if (breaks[ii] == -1)
	    continue;
	  insert_single_step_breakpoint (breaks[ii]);
	}
a754 2
  else
    remove_single_step_breakpoints ();
@


1.270
log
@	* rs6000-tdep.c (rs6000_dwarf2_reg_to_regnum): Decode 64 as CR
	register.
@
text
@d725 1
a725 1
void
d764 1
@


1.269
log
@	* rs6000-tdep.c (rs6000_convert_from_func_ptr_addr): Use parameter
	gdbarch instead of current_gdbarch.
@
text
@d2277 2
@


1.268
log
@2007-03-27  Anton Blanchard  <anton@@samba.org>

	* rs6000-tdep.c (rs6000_frame_cache): Use tdep->lr_frame_offset
	instead of wordsize when looking for the LR in a stack frame.
@
text
@d2393 1
a2393 1
  return read_memory_addr (addr, gdbarch_tdep (current_gdbarch)->wordsize);
@


1.267
log
@	* dwarf2-frame.c (dwarf2_frame_eh_frame_regnum): Rename to...
	(dwarf2_frame_adjust_regnum): ...this.  Make static.  Add eh_frame_p
	argument.  Update all callers.
	(struct dwarf2_frame_ops): Replace eh_frame_regnum with adjust_regnum.
	(dwarf2_frame_set_eh_frame_regnum): Rename to...
	(dwarf2_frame_set_adjust_regnum): ...this.  Update argument type.
	* dwarf2frame.h (dwarf2_frame_set_eh_frame_regnum): Rename to...
	(dwarf2_frame_set_adjust_regnum): ...this.
	(dwarf2_frame_eh_frame_regnum): Delete prototype.
	* rs6000-tdep.c: Include "dwarf2-frame.h".
	(rs6000_adjust_frame_regnum): Define.
	(rs6000_gdbarch_init): Enable use of DWARF CFI frame unwinder.
	Register rs6000_adjust_frame_regnum.

	* Makefile.in (rs6000-tdep.o): Update dependencies.
@
text
@d3029 1
a3029 1
	  fdata.lr_offset = wordsize;
@


1.266
log
@	* rs6000-tdep.c (rs6000_skip_prologue): Use skip_prologue_using_sal.
	(rs6000_in_function_epilogue_p): Use extract_unsigned_integer.
	(refine_prologue_limit): Delete.
	(skip_prologue): Don't call it.  Use extract_unsigned_integer.
	Assume lim_pc is set.  Correct check for incomplete prologues.
	Do not skip clobbers of the frame pointer.
	* symtab.c (skip_prologue_using_sal): Fail if there is only one
	sal.

	* gdb.arch/powerpc-prologue.c (optimized_1_marker, gdb2029_marker)
	(optimized_1): New.
	(main): Call optimized_1.
	(gdb2029): Correct typos.  Call gdb2029_marker.
	* gdb.arch/powerpc-prologue.exp: Run new test.  Use a breakpoint
	for gdb2029.
@
text
@d43 1
d2298 63
d3495 4
@


1.265
log
@	* config/powerpc/linux.mt (DEPRECATED_TM_FILE): Set to tm-ppc-eabi.h.
	* config/powerpc/tm-linux.h: Delete file.
	* config/powerpc/tm-ppc-eabi.h: Do not include "rs6000/tm-rs6000.h".
	(PROCESS_LINENUMBER_HOOK): Do not undefine.
	(TEXT_SEGMENT_BASE): Do not redefine.
	* config/rs6000/nm-rs6000.h (CHILD_SPECIAL_WAITSTATUS): Move here
	from config/rs6000/tm-rs6000.h.
	(TARGET_CREATE_INFERIOR_HOOK, rs6000_create_inferior): Likewise.
	* config/rs6000/tm-rs6000.h (struct frame_info): Remove declaration.
	(TEXT_SEGMENT_BASE): Remove.
	(IN_SOLIB_RETURN_TRAMPOLINE): Remove.
	(rs6000_in_solib_return_trampoline): Remove.
	(SKIP_TRAMPOLINE_CODE): Remove.
	(rs6000_skip_trampoline_code): Remove.
	(CHILD_SPECIAL_WAITSTATUS): Move to config/rs6000/nm-rs6000.h.
	(TARGET_CREATE_INFERIOR_HOOK, rs6000_create_inferior): Likewise.
	(FP0_REGNUM): Remove.
	(rs6000_find_toc_address_hook): Move to rs6000-tdep.h.
	(rs6000_set_host_arch_hook): Remove.
	* Makefile.in (rs6000-nat.o): Add dependency on $(rs6000_tdep_h).
	(rs6000-aix-tdep.o): Add dependency on $(ppc_tdep_h).
	* ppc-tdep.h (struct gdbarch_tdep): Add field text_segment_base.
	* rs6000-aix-tdep.c: Include "ppc-tdep.h".
	(rs6000_aix_init_osabi): Set text_segment_base tdep field.
	* rs6000-nat.c: Include "rs6000-tdep.h".
	(exec_one_dummy_insn): Replace TEXT_SEGMENT_BASE by tdep field.
	(set_host_arch): Rename to ...
	(rs6000_create_inferior): ... this.  Make public.
	(_initialize_core_rs6000): Do not set rs6000_set_host_arch_hook.
	* rs6000-tdep.c (rs6000_set_host_arch_hook): Remove.
	(rs6000_create_inferior): Remove.
	(branch_dest): Replace TEXT_SEGMENT_BASE by tdep field.
	(rs6000_gdbarch_init): Call set_gdbarch_fp0_regnum,
	set_gdbarch_in_solib_return_trampoline, and
	set_gdbarch_skip_trampoline_code.
	* rs6000-tdep.h (rs6000_find_toc_address_hook): Move here
	from config/rs6000/tm-rs6000.h.
@
text
@d485 23
a507 1
  pc = skip_prologue (pc, 0, &frame);
d590 1
a590 1
      insn = extract_signed_integer (insn_buf, PPC_INSN_SIZE);
d605 1
a605 1
      insn = extract_signed_integer (insn_buf, PPC_INSN_SIZE);
a799 51
/* Given PC representing the starting address of a function, and
   LIM_PC which is the (sloppy) limit to which to scan when looking
   for a prologue, attempt to further refine this limit by using
   the line data in the symbol table.  If successful, a better guess
   on where the prologue ends is returned, otherwise the previous
   value of lim_pc is returned.  */

/* FIXME: cagney/2004-02-14: This function and logic have largely been
   superseded by skip_prologue_using_sal.  */

static CORE_ADDR
refine_prologue_limit (CORE_ADDR pc, CORE_ADDR lim_pc)
{
  struct symtab_and_line prologue_sal;

  prologue_sal = find_pc_line (pc, 0);
  if (prologue_sal.line != 0)
    {
      int i;
      CORE_ADDR addr = prologue_sal.end;

      /* Handle the case in which compiler's optimizer/scheduler
         has moved instructions into the prologue.  We scan ahead
	 in the function looking for address ranges whose corresponding
	 line number is less than or equal to the first one that we
	 found for the function.  (It can be less than when the
	 scheduler puts a body instruction before the first prologue
	 instruction.)  */
      for (i = 2 * max_skip_non_prologue_insns; 
           i > 0 && (lim_pc == 0 || addr < lim_pc);
	   i--)
        {
	  struct symtab_and_line sal;

	  sal = find_pc_line (addr, 0);
	  if (sal.line == 0)
	    break;
	  if (sal.line <= prologue_sal.line 
	      && sal.symtab == prologue_sal.symtab)
	    {
	      prologue_sal = sal;
	    }
	  addr = sal.end;
	}

      if (lim_pc == 0 || prologue_sal.end < lim_pc)
	lim_pc = prologue_sal.end;
    }
  return lim_pc;
}

a918 15
  
  /* Attempt to find the end of the prologue when no limit is specified.
     Note that refine_prologue_limit() has been written so that it may
     be used to "refine" the limits of non-zero PC values too, but this
     is only safe if we 1) trust the line information provided by the
     compiler and 2) iterate enough to actually find the end of the
     prologue.  
     
     It may become a good idea at some point (for both performance and
     accuracy) to unconditionally call refine_prologue_limit().  But,
     until we can make a clear determination that this is beneficial,
     we'll play it safe and only use it to obtain a limit when none
     has been specified.  */
  if (lim_pc == 0)
    lim_pc = refine_prologue_limit (pc, lim_pc);
d939 1
a939 1
      if (lim_pc != 0 && pc >= lim_pc)
d947 1
a947 1
      op = extract_signed_integer (buf, 4);
d1180 2
a1181 1
      /* Load up minimal toc pointer */
d1184 1
d1407 1
a1407 2
	  if (fdata->frameless == 0
	      && (lr_reg == -1 || fdata->nosavedpc == 0))
@


1.264
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@a117 5
/* Hook to set the current architecture when starting a child process. 
   rs6000-nat.c sets this. */

void (*rs6000_set_host_arch_hook) (int) = NULL;

d653 1
a653 1
	  if (dest < TEXT_SEGMENT_BASE)
d671 1
a671 1
	  if (dest < TEXT_SEGMENT_BASE)
d681 1
a681 1
  return (dest < TEXT_SEGMENT_BASE) ? safety : dest;
a2339 8
/* Hook called when a new child process is started.  */

void
rs6000_create_inferior (int pid)
{
  if (rs6000_set_host_arch_hook)
    rs6000_set_host_arch_hook (pid);
}
d3322 1
d3469 5
@


1.263
log
@Reviewed by Mark Kettenis <mark.kettenis@@xs4all.nl>

	2007-02-27  Fred Fish  <fnf@@specifix.com>
	* rs6000-tdep.c (skip_prologue): Recognize addi instructions that
	directly decrement the stack pointer, accumulate their operand into
	the stack offset, and mark the function as not being frameless.
@
text
@d2980 1
a2980 1
  func = frame_func_unwind (next_frame);
d3132 2
a3133 1
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
@


1.262
log
@2007-02-08  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* rs6000-tdep.c (gdb_print_insn_powerpc): Set
	info->disassembler_options to "any".
@
text
@d1222 7
@


1.261
log
@	* rs6000-tdep.c (bl_to_blrl_insn_p): New function.
	(skip_prologue): Allow bl->blrl used by PIC code.
@
text
@d2927 3
@


1.260
log
@Copyright updates for 2007.
@
text
@d905 24
d1160 6
@


1.259
log
@* rs6000-tdep.c (rs6000_use_struct_convention)
(rs6000_extract_return_value, rs6000_store_return_value)
(rs6000_extract_struct_value_address): Remove.
(rs6000_return_value): New function.
(rs6000_gdbarch_init): Don't set deprecated_extract_return_value,
store_return_value, deprecated_extract_struct_value_address and
deprecated_use_struct_convention.  Use rs6000_return_value
instead.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.258
log
@	* rs6000-tdep.c: Include "reggroups.h" only once.
	* Makefile.in (rs6000-tdep.o): Update dependencies.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d1737 4
a1740 15
/* PowerOpen always puts structures in memory.  Vectors, which were
   added later, do get returned in a register though.  */

static int     
rs6000_use_struct_convention (int gcc_p, struct type *value_type)
{  
  if ((TYPE_LENGTH (value_type) == 16 || TYPE_LENGTH (value_type) == 8)
      && TYPE_VECTOR (value_type))
    return 0;                            
  return 1;
}

static void
rs6000_extract_return_value (struct type *valtype, gdb_byte *regbuf,
			     gdb_byte *valbuf)
a1741 1
  int offset = 0;
d1743 1
d1747 1
a1747 1
     on PPC variants that lack them.  */
d1750 29
a1778 1
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT)
d1780 2
d1783 2
a1784 3
      /* floats and doubles are returned in fpr1. fpr's have a size of 8 bytes.
         We need to truncate the return value into float size (4 byte) if
         necessary.  */
d1786 20
a1805 9
      convert_typed_floating (&regbuf[DEPRECATED_REGISTER_BYTE
                                      (tdep->ppc_fp0_regnum + 1)],
                              builtin_type_double,
                              valbuf,
                              valtype);
    }
  else if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY
           && TYPE_LENGTH (valtype) == 16
           && TYPE_VECTOR (valtype))
d1807 18
a1824 2
      memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
	      TYPE_LENGTH (valtype));
d1826 5
a1830 1
  else
d1832 2
a1833 4
      /* return value is copied starting from r3. */
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && TYPE_LENGTH (valtype) < register_size (current_gdbarch, 3))
	offset = register_size (current_gdbarch, 3) - TYPE_LENGTH (valtype);
d1835 17
a1851 3
      memcpy (valbuf,
	      regbuf + DEPRECATED_REGISTER_BYTE (3) + offset,
	      TYPE_LENGTH (valtype));
d1853 2
a2307 73

static void
rs6000_store_return_value (struct type *type,
                           struct regcache *regcache,
                           const gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int regnum = -1;

  /* The calling convention this function implements assumes the
     processor has floating-point registers.  We shouldn't be using it
     on PPC variants that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    /* Floating point values are returned starting from FPR1 and up.
       Say a double_double_double type could be returned in
       FPR1/FPR2/FPR3 triple.  */
    regnum = tdep->ppc_fp0_regnum + 1;
  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      if (TYPE_LENGTH (type) == 16
          && TYPE_VECTOR (type))
        regnum = tdep->ppc_vr0_regnum + 2;
      else
        internal_error (__FILE__, __LINE__,
                        _("rs6000_store_return_value: "
                        "unexpected array return type"));
    }
  else
    /* Everything else is returned in GPR3 and up.  */
    regnum = tdep->ppc_gp0_regnum + 3;

  {
    size_t bytes_written = 0;

    while (bytes_written < TYPE_LENGTH (type))
      {
        /* How much of this value can we write to this register?  */
        size_t bytes_to_write = min (TYPE_LENGTH (type) - bytes_written,
                                     register_size (gdbarch, regnum));
        regcache_cooked_write_part (regcache, regnum,
                                    0, bytes_to_write,
                                    valbuf + bytes_written);
        regnum++;
        bytes_written += bytes_to_write;
      }
  }
}


/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */

static CORE_ADDR
rs6000_extract_struct_value_address (struct regcache *regcache)
{
  /* FIXME: cagney/2002-09-26: PR gdb/724: When making an inferior
     function call GDB knows the address of the struct return value
     and hence, should not need to call this function.  Unfortunately,
     the current call_function_by_hand() code only saves the most
     recent struct address leading to occasional calls.  The code
     should instead maintain a stack of such addresses (in the dummy
     frame object).  */
  /* NOTE: cagney/2002-09-26: Return 0 which indicates that we've
     really got no idea where the return value is being stored.  While
     r3, on function entry, contained the address it will have since
     been reused (scratch) and hence wouldn't be valid */
  return 0;
}

d3300 1
a3300 4
    {
      set_gdbarch_deprecated_extract_return_value (gdbarch, rs6000_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, rs6000_store_return_value);
    }
d3403 1
a3403 7
  /* Note: kevinb/2002-04-12: I'm not convinced that rs6000_push_arguments()
     is correct for the SysV ABI when the wordsize is 8, but I'm also
     fairly certain that ppc_sysv_abi_push_arguments() will give even
     worse results since it only works for 32-bit code.  So, for the moment,
     we're better off calling rs6000_push_arguments() since it works for
     64-bit code.  At some point in the future, this matter needs to be
     revisited.  */
a3410 2
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);

a3429 3
    set_gdbarch_deprecated_use_struct_convention (gdbarch, rs6000_use_struct_convention);

  if (!sysv_abi)
@


1.257
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@a61 1
#include "reggroups.h"
@


1.256
log
@        * defs.h (gdb_osabi): New enum value GDB_OSABI_AIX.
        * osabi.c (gdb_osabi_name): Add name of new value GDB_OSABI_AIX.
        * rs6000-tdep.h: New file.
        * rs6000-tdep.c: Include "rs6000-tdep.h".
        (rs6000_gdbarch_init): Remove enabling of software single step.
        Will be done in the AIX-specific initialization routine.
        * rs6000-aix-tdep.c: New file.
        * config/powerpc/aix.mt (TDEPFILES): Add rs6000-aix-tdep.o.
        * Makefile.in (rs6000_tdep_h): New variable.
        (rs6000-tdep.o): Update dependencies.
        (rs6000-aix-tdep.o): New rule.
@
text
@a112 11
/* Breakpoint shadows for the single step instructions will be kept here. */

static struct sstep_breaks
{
  /* Address, or 0 if this is not in use.  */
  CORE_ADDR address;
  /* Shadow contents.  */
  gdb_byte data[4];
}
stepBreaks[2];

a721 1

a733 2
      stepBreaks[1].address = 0;

a735 1

d739 1
a739 2
	  target_insert_breakpoint (breaks[ii], stepBreaks[ii].data);
	  stepBreaks[ii].address = breaks[ii];
a740 1

d743 1
a743 1
    {
a744 6
      /* remove step breakpoints. */
      for (ii = 0; ii < 2; ++ii)
	if (stepBreaks[ii].address != 0)
	  target_remove_breakpoint (stepBreaks[ii].address,
				    stepBreaks[ii].data);
    }
@


1.256.8.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d113 11
d733 1
d746 2
d750 1
d754 2
a755 1
	  insert_single_step_breakpoint (breaks[ii]);
d757 1
d760 1
a760 1
    remove_single_step_breakpoints ();
d762 6
@


1.255
log
@	* ppc-linux-nat.c (PTRACE_GET_DEBUGREG, PTRACE_SET_DEBUGREG,
	PTRACE_GETSIGINFO): Define.
	(last_stopped_data_address): New.
	(ppc_linux_check_watch_resources): New function.
	(ppc_linux_region_ok_for_hw_watchpoint): New function.
	(ppc_linux_insert_watchpoint): New function.
	(ppc_linux_remove_watchpoint): New function.
	(ppc_linux_stopped_data_address): New function.
	(ppc_linux_stopped_by_watchpoint): New function.
	(_initialize_ppc_linux_nat): Set the above hardware watchpoint
	related target vectors.
	* rs6000-tdep.c (rs6000_gdbarch_init): Set PPC architectures
	to have nonsteppable watchpoint.
	* target.c (default_region_ok_for_hw_watchpoint,
	debug_to_region_ok_for_hw_watchpoint): New prototypes.
	(update_current_target): Inherit to_region_ok_for_hw_watchpoint
	and set default to_region_ok_for_hw_watchpoint.
	(default_region_ok_for_hw_watchpoint): New function.
	(debug_to_region_ok_for_hw_watchpoint): New function.
	(setup_target_debug): Set to_region_ok_for_hw_watchpoint of
	debug_target.
	* target.h (struct target_ops): Add a new target vector
	to_region_ok_for_hw_watchpoint.
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT): Define this if it is not
	defined anyplace else.
@
text
@d63 1
a3521 10
  if (from_xcoff_exec)
    {
      /* NOTE: jimix/2003-06-09: This test should really check for
	 GDB_OSABI_AIX when that is defined and becomes
	 available. (Actually, once things are properly split apart,
	 the test goes away.) */
       /* RS6000/AIX does not support PT_STEP.  Has to be simulated.  */
       set_gdbarch_software_single_step (gdbarch, rs6000_software_single_step);
    }

@


1.254
log
@	PR tdep/2029
	Suggested by Till Straumann <strauman@@slac.stanford.edu>:
	* rs6000-tdep.c (skip_prologue): Update check for later mtlr
	instructions.  Handle PIC bcl.
@
text
@d3390 2
@


1.253
log
@2006-01-16  Paul Gilliam  <pgilliam@@us.ibm.com>

	* ppc-tdep.h (PPC_MAX_EPILOGUE_INSTRUCTIONS): New define.
	* rs6000-tdep.c (insn_changes_sp_or_jumps)
	(rs6000_in_function_epilogue_p): New functions.
	(rs6000_gdbarch_init): Set in_function_epilogue_p.
@
text
@d4 2
a5 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software
   Foundation, Inc.
d1016 1
a1016 1
	  if (lr_reg < 0)
d1129 7
@


1.252
log
@gdb/ChangeLog:
2005-12-20  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): Doc fix.
@
text
@d505 102
d3447 2
@


1.251
log
@        * rs6000-tdep.c: Use proper spelling for existent.
@
text
@d3123 1
a3123 1
  /* Find a candidate among existent architectures.  */
@


1.250
log
@        * rs6000-tdep.c: Fix spelling errors.
@
text
@d103 2
a104 2
    unsigned char sz32;		/* size on 32-bit arch, 0 if nonexistant */
    unsigned char sz64;		/* size on 64-bit arch, 0 if nonexistant */
d3123 1
a3123 1
  /* Find a candidate among existant architectures.  */
@


1.249
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d103 2
a104 2
    unsigned char sz32;		/* size on 32-bit arch, 0 if nonextant */
    unsigned char sz64;		/* size on 64-bit arch, 0 if nonextant */
d3123 1
a3123 1
  /* Find a candidate among extant architectures.  */
@


1.248
log
@        * rs6000-tdep.c (rs6000_gdbarch_init): On GNU/Linux, assume that
         bfd_mach_ppc64 has altivec unit, just like bfd_mach_ppc.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.247
log
@* rs6000-tdep.c (info_powerpc_cmdlist): Remove variable.
(rs6000_info_powerpc_command): Remove function.
@
text
@d3379 12
a3393 1
    case GDB_OSABI_LINUX:
@


1.246
log
@2005-10-14  Paul Gilliam  <pgilliam@@us.ibm.com>

        * rs6000-tdep.c (rs6000_register_reggroup_p): Add vscr to test for
        vector registers.
@
text
@a3422 8
static struct cmd_list_element *info_powerpc_cmdlist = NULL;

static void
rs6000_info_powerpc_command (char *args, int from_tty)
{
  help_list (info_powerpc_cmdlist, "info powerpc ", class_info, gdb_stdout);
}

@


1.245
log
@	PR 1659
	* rs6000-tdep.c (rs6000_push_dummy_call): Correct size of
	backchain write.
	(rs6000_convert_from_func_ptr_addr): Correct comment.
@
text
@d1891 1
@


1.244
log
@	* rs6000-tdep.c (rs6000_frame_cache): Handle misdetected frameless
	functions.
@
text
@d1632 2
a1633 2
  store_unsigned_integer (tmp_buffer, 4, saved_sp);
  write_memory (sp, tmp_buffer, 4);
d2244 1
a2244 1
   represented by a pointer to a TOC entry. This TOC entry contains
d2250 1
a2250 1
   a function pointer would require allocation of a TOC entry in the
@


1.243
log
@* rs6000-tdep.c (_initialize_rs6000_tdep): Get rid of the unused
  'info powerpc' command prefix.
* gdb.arch/altivec-regs.exp (info powerpc altivec): Replace the 'info
  powerpc altivec' test with an almost identical 'info vector' test.
@
text
@d2855 1
d2863 37
a2899 2
  skip_prologue (frame_func_unwind (next_frame), frame_pc_unwind (next_frame),
		 &fdata);
d2901 5
a2905 25
  /* If there were any saved registers, figure out parent's stack
     pointer.  */
  /* The following is true only if the frame doesn't have a call to
     alloca(), FIXME.  */

  if (fdata.saved_fpr == 0
      && fdata.saved_gpr == 0
      && fdata.saved_vr == 0
      && fdata.saved_ev == 0
      && fdata.lr_offset == 0
      && fdata.cr_offset == 0
      && fdata.vr_offset == 0
      && fdata.ev_offset == 0)
    cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
  else
    {
      /* NOTE: cagney/2002-04-14: The ->frame points to the inner-most
	 address of the current frame.  Things might be easier if the
	 ->frame pointed to the outer-most address of the frame.  In
	 the mean time, the address of the prev frame is used as the
	 base address of this frame.  */
      cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
      if (!fdata.frameless)
	/* Frameless really means stackless.  */
	cache->base = read_memory_addr (cache->base, wordsize);
d2907 5
@


1.242
log
@20050901  Paul Gilliam  <pgilliam@@us.ibm.com>

        * ppc-tdep.h (struct gdbarch_tdep): Better explanation of using
        -1 for nonexistant registers.
        * rs6000-tdep.c (rs6000_register_reggroup_p): Don't assume that
        tdep->ppc_vr0_regnum and tdep->ppc_ev0_regnum are not -1.
@
text
@a3417 5

  /* Add root prefix command for "info powerpc" commands */
  add_prefix_cmd ("powerpc", class_info, rs6000_info_powerpc_command,
		  _("Various POWERPC info specific commands."),
		  &info_powerpc_cmdlist, "info powerpc ", 0, &infolist);
@


1.241
log
@2005-05-24  Andrew Cagney  <cagney@@gnu.org>

	* rs6000-tdep.c (ppc_supply_reg, ppc_collect_reg): Use gdb_byte
	for byte buffers.
	(rs6000_fetch_pointer_argument): Use get_frame_register_unsigned.
	(rs6000_software_single_step, sstep_breaks, skip_prologue)
	(rs6000_push_dummy_call, rs6000_push_dummy_call)
	(rs6000_push_dummy_call, rs6000_push_dummy_call)
	(rs6000_register_to_value, e500_pseudo_register_read)
	(rs6000_store_return_value, e500_pseudo_register_write)
	(rs6000_frame_prev_register, rs6000_extract_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc_sysv_abi_push_dummy_call, do_ppc_sysv_return_value)
	(do_ppc_sysv_return_value, ppc_sysv_abi_return_value)
	(ppc_sysv_abi_broken_return_value)
	(ppc64_sysv_abi_push_dummy_call, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call, ppc64_sysv_abi_return_value)
	(ppc64_sysv_abi_return_value, ppc64_sysv_abi_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_in_sigtramp)
	(ppc_linux_at_sigtramp_return_path)
	(ppc_linux_skip_trampoline_code)
	(ppc_linux_memory_remove_breakpoint, ppc_linux_return_value):
	* rs6000-tdep.c (rs6000_value_to_register)
	(rs6000_register_to_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value)
	(ppc64_sysv_abi_return_value, ppc_sysv_abi_broken_return_value)
	(ppc_linux_memory_remove_breakpoint): Ditto.
@
text
@d1885 2
a1886 1
  vector_p = ((regnum >= tdep->ppc_vr0_regnum
d1888 2
a1889 1
	      || (regnum >= tdep->ppc_ev0_regnum
@


1.240
log
@2005-05-01  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_extract_return_value)
	(breakpoint_from_pc, deprecated_store_return_value)
	(memory_insert_breakpoint, memory_remove_breakpoint): Change type
	of buffer to a bfd_byte pointer.
	* gdbarch.h, gdbarch.c: Re-generate.
	* mem-break.c (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update.
	* target.h (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update declarations.
	(struct target_ops): Update to_insert_breakpoint and
	to_remove_breakpoint.
	* target.c (debug_to_remove_breakpoint)
	(debug_to_insert_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_remove_breakpoint)
	(m32r_insert_breakpoint): Update.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Update.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Update.
	* remote-rdi.c (arm_rdi_insert_breakpoint)
	(arm_rdi_remove_breakpoint): Update.
	* remote-sim.c (gdbsim_insert_breakpoint)
	(gdbsim_remove_breakpoint): Update.
	* exec.c (ignore): Update.
	* rs6000-tdep.c (rs6000_extract_return_value): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Update.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Update.
@
text
@d115 6
a120 6
  {
    /* Address, or 0 if this is not in use.  */
    CORE_ADDR address;
    /* Shadow contents.  */
    char data[4];
  }
d322 1
a322 1
		const char *regs, size_t offset)
d330 1
a330 1
		 char *regs, size_t offset)
d523 1
a523 3
  CORE_ADDR addr;
  get_frame_register (frame, 3 + argi, &addr);
  return addr;
d622 1
a622 1
  const char *breakp = rs6000_breakpoint_from_pc (&dummy, &breakp_sz);
d832 1
a832 1
  char buf[4];
d1430 1
a1430 1
  char tmp_buffer[50];
d1508 1
a1508 1
	      char word[MAX_REGISTER_SIZE];
d1529 1
a1529 1
	  char word[MAX_REGISTER_SIZE];
d1590 1
a1590 1
			((char *) value_contents (arg)) + argbytes,
d1618 1
a1618 3
	  write_memory (sp + 24 + (ii * 4),
                        (char *) value_contents (arg),
                        len);
d1664 2
a1665 2
rs6000_extract_return_value (struct type *valtype, bfd_byte *regbuf,
			     bfd_byte *valbuf)
d1932 1
a1932 1
                          void *to)
d1935 1
a1935 1
  char from[MAX_REGISTER_SIZE];
d1948 1
a1948 1
                          const void *from)
d1951 1
a1951 1
  char to[MAX_REGISTER_SIZE];
d1985 1
a1985 1
                                     int regnum, void *buf),
d1987 1
a1987 1
                       void *buffer)
d1992 1
a1992 1
  char *byte_buffer = buffer;
d2013 1
a2013 1
			   int reg_nr, void *buffer)
d2032 1
a2032 1
			    int reg_nr, const void *buffer)
d2041 1
a2041 1
    e500_move_ev_register ((void (*) (struct regcache *, int, void *))
d2043 1
a2043 1
                           regcache, reg_nr, (void *) buffer);
d2160 1
a2160 1
                           const void *valbuf)
d2200 1
a2200 1
                                    (char *) valbuf + bytes_written);
d3000 1
a3000 1
				 int *realnump, void *valuep)
@


1.239
log
@* rs6000-tdep.c (ppc_supply_fpregset): Increment offset by 8 for
floating-point registers.
(ppc_collect_fpregset): Likewise.  Fix collection of registers.
@
text
@d1668 2
a1669 1
rs6000_extract_return_value (struct type *valtype, char *regbuf, char *valbuf)
@


1.238
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d398 1
a398 1
       i++, offset += 4)
d477 1
a477 1
       i++, offset += 4)
d480 1
a480 1
	ppc_collect_reg (regcache, regnum, fpregs, offset);
@


1.237
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d3422 1
a3422 1
		  "Various POWERPC info specific commands.",
@


1.236
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d1860 1
a1860 1
	  internal_error (__FILE__, __LINE__, "Register %d size %d unknown",
d2028 2
a2029 2
                    "e500_pseudo_register_read: "
                    "called on unexpected register '%s' (%d)",
d2049 2
a2050 2
                    "e500_pseudo_register_read: "
                    "called on unexpected register '%s' (%d)",
d2186 2
a2187 2
                        "rs6000_store_return_value: "
                        "unexpected array return type");
d3257 2
a3258 2
                    "rs6000_gdbarch_init: "
                    "received unexpected BFD 'arch' value");
@


1.235
log
@2005-01-26  Andrew Cagney  <cagney@@gnu.org>

	* rs6000-tdep.c: Include "reggroups.h".
	(rs6000_gdbarch_init): Set register_reggroup_p.
	(rs6000_register_reggroup_p): New function.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d1500 1
a1500 1
	                         VALUE_CONTENTS (arg));
d1513 1
a1513 1
		      ((char *) VALUE_CONTENTS (arg)) + argbytes,
d1534 1
a1534 1
	  memcpy (word, VALUE_CONTENTS (arg), len);
d1592 1
a1592 1
			((char *) VALUE_CONTENTS (arg)) + argbytes,
d1616 1
a1616 1
				     VALUE_CONTENTS (arg));
d1621 1
a1621 1
                        (char *) VALUE_CONTENTS (arg),
@


1.234
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* rs6000-nat.c: Whitespace tweaks.
@
text
@d62 2
d1866 52
d3275 1
@


1.233
log
@Approved by Kevin Buettner <kevinb@@redhat.com>

	2004-11-24  Fred Fish  <fnf@@specifixinc.com>
	* rs6000-tdep.c (skip_prologue): Use line table info to skip over
	compiler generated function calls made as part of a prologue.
@
text
@d1724 7
a1730 6
   Unfortunately, the linker uses the "b" instruction for the branches,
   meaning that the link register doesn't get set.  Therefore, GDB's usual
   step_over_function() mechanism won't work.

   Instead, use the IN_SOLIB_RETURN_TRAMPOLINE and SKIP_TRAMPOLINE_CODE hooks
   in handle_inferior_event() to skip past @@FIX code.  */
d1774 3
a1776 1
  if (msymbol && rs6000_in_solib_return_trampoline (pc, DEPRECATED_SYMBOL_NAME (msymbol)))
@


1.232
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d1051 4
a1054 1
	     the first three instructions of the prologue.  */
d1056 7
a1062 1
	    break;
@


1.231
log
@2004-11-10  msnyder  <msnyder@@redhat.com>

	* rs6000-tdep.c (skip_prologue): After saving lr_offset,
	must invalidate lr_reg (so we don't try to save it again).
	Ditto for cr_offset and cr_reg.
@
text
@d1475 1
a1475 1
      type = check_typedef (VALUE_TYPE (arg));
d1560 1
a1560 1
	  space += ((TYPE_LENGTH (VALUE_TYPE (val))) + 3) & -4;
d1592 1
a1592 1
	  type = check_typedef (VALUE_TYPE (arg));
@


1.230
log
@	* rs6000-tdep.c (rs6000_push_dummy_call): Replace references to
	``deprecated_registers'' with equivalent code.  Use gdb_assert()
	instead of explicit test and print statement.
@
text
@d984 1
a984 1
      else if (lr_reg != -1 &&
d994 3
a996 1
	  lr_reg = 0;
d1006 1
a1006 1
      else if (cr_reg != -1 &&
d1015 3
a1017 1
	  cr_reg = 0;
@


1.229
log
@* rs6000-tdep.c (set_sim_regno, init_sim_regno_table,
rs6000_register_sim_regno): Doc fixes.
@
text
@d1481 5
a1485 8
	  if (len > 8)
	    printf_unfiltered ("Fatal Error: a floating point parameter "
                               "#%d with a size > 8 is found!\n", argno);

	  memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE
                                        (tdep->ppc_fp0_regnum + 1 + f_argno)],
		  VALUE_CONTENTS (arg),
		  len);
d1495 3
a1497 3
	      memset (&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)], 0,
		      reg_size);
	      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)],
d1501 3
d1516 5
a1520 3
	  memset (&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)], 0, reg_size);
	  memcpy ((char *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)] + adj, 
	          VALUE_CONTENTS (arg), len);
d1597 5
a1601 9
	      if (len > 8)
		printf_unfiltered ("Fatal Error: a floating point parameter"
                                   " #%d with a size > 8 is found!\n", argno);

	      memcpy (&(deprecated_registers
                        [DEPRECATED_REGISTER_BYTE
                         (tdep->ppc_fp0_regnum + 1 + f_argno)]),
		      VALUE_CONTENTS (arg),
		      len);
@


1.228
log
@* ppc-linux-nat.c (fetch_register): Replace 'gdb_assert (0)' with
a call to 'internal_error', with a more helpful error message.
* rs6000-tdep.c (e500_pseudo_register_read,
e500_pseudo_register_write): Same.
@
text
@d195 8
d212 4
d296 3
@


1.227
log
@Change the layout of the PowerPC E500 raw register cache to allow
the lower 32-bit halves of the GPRS to be their own raw registers,
not pseudoregisters.
* ppc-tdep.h (struct gdbarch_tdep): Remove ppc_gprs_pseudo_p flag;
add ppc_ev0_upper_regnum flag.
* rs6000-tdep.c: #include "reggroups.h".
(spe_register_p): Recognize the ev upper half registers as SPE
registers.
(init_sim_regno_table): Build gdb->sim mappings for the upper-half
registers.
(e500_move_ev_register): New function.
(e500_pseudo_register_read, e500_pseudo_register_write): The 'ev'
vector registers are the pseudo-registers now, formed by splicing
together the gprs and the upper-half registers.
(e500_register_reggroup_p): New function.
(P): Macro deleted.
(P8, A4): New macro.
(PPC_EV_REGS, PPC_GPRS_PSEUDO_REGS): Macros deleted.
(PPC_SPE_GP_REGS, PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): New
macros.
(registers_e500): Rearrange register set so that the raw register
set contains 32-bit GPRs and upper-half registers, and the SPE
vector registers become pseudo-registers.
(rs6000_gdbarch_init): Don't initialize tdep->ppc_gprs_pseudo_p;
it has been deleted.  Initialize ppc_ev0_upper_regnum.  Many other
register numbers are now the same for the E500 as they are for
other PowerPC variants.  Register e500_register_reggroup_p as the
register group function for the E500.
* Makefile.in (rs6000-tdep.o): Update dependencies.

Adapt PPC E500 native support to the new raw regcache layout.
* ppc-linux-nat.c (struct gdb_evrregset_t): Doc fixes.
(read_spliced_spe_reg, write_spliced_spe_reg): Deleted.
(fetch_spe_register, store_spe_register): Handle fetching/storing
all the SPE registers at once, if regno == -1.  These now take
over the job of fetch_spe_registers and store_spe_registers.
(fetch_spe_registers, store_spe_registers): Deleted.
(fetch_ppc_registers, store_ppc_registers): Fetch/store gprs
unconditionally; they're always raw.  Fetch/store SPE upper half
registers, if present, instead of ev registers.
(fetch_register, store_register): Remove sanity checks: gprs are
never pseudo-registers now, so we never need to even mention any
registers that are ever pseudoregisters.
@
text
@d1944 4
a1947 2
    /* We should only be called on pseudo-registers.  */
    gdb_assert (0);
d1965 4
a1968 2
    /* We should only be called on pseudo-registers.  */
    gdb_assert (0);
d2102 3
a2104 1
        gdb_assert (0);
@


1.226
log
@gdb/ChangeLog:
2004-07-20  Jim Blandy  <jimb@@redhat.com>

	Use a fixed register numbering when communicating with the PowerPC
	simulator.
	* ppc-tdep.h (struct gdbarch_tdep): New member: 'sim_regno'.
	* rs6000-tdep.c: #include "sim-regno.h" and "gdb/sim-ppc.h".
	(set_sim_regno, init_sim_regno_table, rs6000_register_sim_regno):
	New functions.
	(rs6000_gdbarch_init): Register rs6000_register_sim_regno.  Call
	init_sim_regno_table.
	* Makefile.in (gdb_sim_ppc_h): New variable.
	(rs6000-tdep.o): Update dependencies.

include/gdb/ChangeLog:
2004-07-20  Jim Blandy  <jimb@@redhat.com>

	* sim-ppc.h: New file.

sim/ppc/ChangeLog:
2004-07-20  Jim Blandy  <jimb@@redhat.com>

	Use a fixed register numbering when communicating with the PowerPC
	simulator.
	* sim_calls.c: #include "registers.h" and "gdb/sim-ppc.h"; do not
	include GDB's "defs.h".
	(gdb_register_name_table): New variable.
	(gdb_register_name_table_size): New enum constant.
	(gdb_register_name): New function.
	(sim_fetch_register, sim_store_register): Use gdb_register_name,
	instead of calling gdbarch_register_name.
	* Makefile.in (GDB_SIM_PPC_H): New variable.
	(DEFS_H): Delete variable.
	(sim_calls.o): Update dependencies.
@
text
@d42 1
d163 6
d264 5
d1880 51
d1935 1
a1935 3
  int base_regnum;
  int offset = 0;
  char temp_buffer[MAX_REGISTER_SIZE];
d1938 8
a1945 12
  if (reg_nr >= tdep->ppc_gp0_regnum 
      && reg_nr < tdep->ppc_gp0_regnum + ppc_num_gprs)
    {
      base_regnum = reg_nr - tdep->ppc_gp0_regnum + tdep->ppc_ev0_regnum;

      /* Build the value in the provided buffer.  */ 
      /* Read the raw register of which this one is the lower portion.  */
      regcache_raw_read (regcache, base_regnum, temp_buffer);
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = 4;
      memcpy ((char *) buffer, temp_buffer + offset, 4);
    }
d1952 1
a1952 3
  int base_regnum;
  int offset = 0;
  char temp_buffer[MAX_REGISTER_SIZE];
d1955 32
a1986 17
  if (reg_nr >= tdep->ppc_gp0_regnum 
      && reg_nr < tdep->ppc_gp0_regnum + ppc_num_gprs)
    {
      base_regnum = reg_nr - tdep->ppc_gp0_regnum + tdep->ppc_ev0_regnum;
      /* reg_nr is 32 bit here, and base_regnum is 64 bits.  */
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = 4;

      /* Let's read the value of the base register into a temporary
	 buffer, so that overwriting the last four bytes with the new
	 value of the pseudo will leave the upper 4 bytes unchanged.  */
      regcache_raw_read (regcache, base_regnum, temp_buffer);

      /* Write as an 8 byte quantity.  */
      memcpy (temp_buffer + offset, (char *) buffer, 4);
      regcache_raw_write (regcache, base_regnum, temp_buffer);
    }
d2249 3
a2251 2
/* Return a struct reg defining a pseudo register NAME.  */
#define P(name)		{ STR(name), 4, 8, 0, 1, -1 }
d2264 4
d2332 32
a2363 13
/* Vectors of hi-lo general purpose registers.  */
#define PPC_EV_REGS \
  /* 0*/R8(ev0), R8(ev1), R8(ev2), R8(ev3), R8(ev4), R8(ev5), R8(ev6), R8(ev7),  \
  /* 8*/R8(ev8), R8(ev9), R8(ev10),R8(ev11),R8(ev12),R8(ev13),R8(ev14),R8(ev15), \
  /*16*/R8(ev16),R8(ev17),R8(ev18),R8(ev19),R8(ev20),R8(ev21),R8(ev22),R8(ev23), \
  /*24*/R8(ev24),R8(ev25),R8(ev26),R8(ev27),R8(ev28),R8(ev29),R8(ev30),R8(ev31)

/* Lower half of the EV registers.  */
#define PPC_GPRS_PSEUDO_REGS \
  /*  0 */ P(r0), P(r1), P(r2), P(r3), P(r4), P(r5), P(r6), P(r7),  \
  /*  8 */ P(r8), P(r9), P(r10),P(r11),P(r12),P(r13),P(r14),P(r15), \
  /* 16 */ P(r16),P(r17),P(r18),P(r19),P(r20),P(r21),P(r22),P(r23), \
  /* 24 */ P(r24),P(r25),P(r26),P(r27),P(r28),P(r29),P(r30),P(r31)
d2543 5
a2547 6
  R(pc), R(ps),
  /* cr, lr, ctr, xer, "" */
  PPC_UISA_NOFP_SPRS,
  /* 7...38 */
  PPC_EV_REGS,
  R8(acc), S4(spefscr),
d2550 1
a2550 2
  /* 41...72 */
  PPC_GPRS_PSEUDO_REGS
a3081 1
  tdep->ppc_gprs_pseudo_p = 0;
d3099 1
a3141 2
        tdep->ppc_gp0_regnum = 41;
        tdep->ppc_gprs_pseudo_p = 1;
d3143 5
a3147 7
        tdep->ppc_ps_regnum = 1;
        tdep->ppc_cr_regnum = 2;
        tdep->ppc_lr_regnum = 3;
        tdep->ppc_ctr_regnum = 4;
        tdep->ppc_xer_regnum = 5;
	tdep->ppc_ev0_regnum = 7;
	tdep->ppc_ev31_regnum = 38;
a3150 5
        tdep->ppc_acc_regnum = 39;
        tdep->ppc_spefscr_regnum = 40;
        set_gdbarch_pc_regnum (gdbarch, 0);
        set_gdbarch_sp_regnum (gdbarch, tdep->ppc_gp0_regnum + 1);
        set_gdbarch_deprecated_fp_regnum (gdbarch, tdep->ppc_gp0_regnum + 1);
d3153 1
@


1.225
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d40 2
d187 100
d3016 1
d3212 2
@


1.224
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Rename
	trad_frame_get_prev_register.
	* vax-tdep.c (vax_frame_prev_register): Update.
	* trad-frame.h: Update.
	* trad-frame.c (trad_frame_get_register): Update.
	* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
	Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_prev_register):
	Update.
	* s390-tdep.c (s390_frame_prev_register)
	(s390_stub_frame_prev_register)
	(s390_sigtramp_frame_prev_register): Update.
	* rs6000-tdep.c (rs6000_frame_prev_register): Update.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_prev_register): Update.
	* mips-tdep.c (mips_mdebug_frame_prev_register): Update.
	* m88k-tdep.c (m88k_frame_prev_register)
	* m68hc11-tdep.c (m68hc11_frame_prev_register)
	* m32r-tdep.c (m32r_frame_prev_register): Update.
	* hppa-tdep.c (hppa_frame_prev_register_helper)
	* frv-tdep.c (frv_frame_prev_register): Update.
	* d10v-tdep.c (d10v_frame_prev_register): Update.
	* cris-tdep.c (cris_frame_prev_register): Update.
	* avr-tdep.c (avr_frame_prev_register): Update.
	* arm-tdep.c (arm_prologue_prev_register)
	(arm_sigtramp_prev_register): Update.
@
text
@d1339 1
a1339 1
      int reg_size = DEPRECATED_REGISTER_RAW_SIZE (ii + 3);
d1560 2
a1561 2
	  && TYPE_LENGTH (valtype) < DEPRECATED_REGISTER_RAW_SIZE (3))
	offset = DEPRECATED_REGISTER_RAW_SIZE (3) - TYPE_LENGTH (valtype);
@


1.223
log
@* rs6000-tdep.c (rs6000_gdbarch_init): The register set used for
bfd_mach_ppc has no segment registers.
@
text
@d2724 2
a2725 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
@


1.222
log
@Include PowerPC SPR numbers for special-purpose registers.
* rs6000-tdep.c (struct reg): Add new member, 'spr_num'.
(R, R4, R8, R16, F, P, R32, R64, R0): Include value for
new member in initializer.
(S, S4, SN4, S64): New macros for defining special-purpose
registers.
(PPC_UISA_SPRS, PPC_UISA_NOFP_SPRS, PPC_OEA_SPRS, registers_power,
registers_403, registers_403GC, registers_505, registers_860,
registers_601, registers_602, registers_603, registers_604,
registers_750, registers_e500): Use them.
@
text
@d2938 1
@


1.221
log
@* rs6000-tdep.c (rs6000_gdbarch_init): Delete variable 'power';
replace references with expression used to initialize variable.
@
text
@d102 3
d2060 1
a2060 1
#define R(name)		{ STR(name), 4, 8, 0, 0 }
d2064 1
a2064 1
#define R4(name)	{ STR(name), 4, 4, 0, 0 }
d2068 1
a2068 1
#define R8(name)	{ STR(name), 8, 8, 0, 0 }
d2072 1
a2072 1
#define R16(name)       { STR(name), 16, 16, 0, 0 }
d2075 1
a2075 1
#define F(name)		{ STR(name), 8, 8, 1, 0 }
d2078 1
a2078 1
#define P(name)		{ STR(name), 4, 8, 0, 1}
d2082 1
a2082 1
#define R32(name)	{ STR(name), 4, 0, 0, 0 }
d2086 1
a2086 1
#define R64(name)	{ STR(name), 0, 8, 0, 0 }
d2089 1
a2089 1
#define R0		{ 0, 0, 0, 0, 0 }
d2091 16
d2122 1
a2122 1
  /* 66 */ R4(cr),  R(lr), R(ctr), R4(xer), R4(fpscr)
d2126 1
a2126 1
  /* 66 */ R4(cr),  R(lr), R(ctr), R4(xer), R0
d2137 9
a2145 9
  /*  87 */ R4(pvr), \
  /*  88 */ R(ibat0u), R(ibat0l), R(ibat1u), R(ibat1l), \
  /*  92 */ R(ibat2u), R(ibat2l), R(ibat3u), R(ibat3l), \
  /*  96 */ R(dbat0u), R(dbat0l), R(dbat1u), R(dbat1l), \
  /* 100 */ R(dbat2u), R(dbat2l), R(dbat3u), R(dbat3l), \
  /* 104 */ R(sdr1),   R64(asr),  R(dar),    R4(dsisr), \
  /* 108 */ R(sprg0),  R(sprg1),  R(sprg2),  R(sprg3),  \
  /* 112 */ R(srr0),   R(srr1),   R(tbl),    R(tbu),    \
  /* 116 */ R4(dec),   R(dabr),   R4(ear)
d2174 1
a2174 1
  /* 66 */ R4(cnd), R(lr), R(cnt), R4(xer), R4(mq),
d2187 13
a2199 1
/* IBM PowerPC 403.  */
d2206 6
a2211 6
  /* 119 */ R(icdbdr), R(esr),  R(dear), R(evpr),
  /* 123 */ R(cdbcr),  R(tsr),  R(tcr),  R(pit),
  /* 127 */ R(tbhi),   R(tblo), R(srr2), R(srr3),
  /* 131 */ R(dbsr),   R(dbcr), R(iac1), R(iac2),
  /* 135 */ R(dac1),   R(dac2), R(dccr), R(iccr),
  /* 139 */ R(pbl1),   R(pbu1), R(pbl2), R(pbu2)
d2214 2
a2215 1
/* IBM PowerPC 403GC.  */
d2222 8
a2229 8
  /* 119 */ R(icdbdr), R(esr),  R(dear), R(evpr),
  /* 123 */ R(cdbcr),  R(tsr),  R(tcr),  R(pit),
  /* 127 */ R(tbhi),   R(tblo), R(srr2), R(srr3),
  /* 131 */ R(dbsr),   R(dbcr), R(iac1), R(iac2),
  /* 135 */ R(dac1),   R(dac2), R(dccr), R(iccr),
  /* 139 */ R(pbl1),   R(pbu1), R(pbl2), R(pbu2),
  /* 143 */ R(zpr),    R(pid),  R(sgr),  R(dcwr),
  /* 147 */ R(tbhu),   R(tblu)
d2239 1
a2239 1
  /* 119 */ R(eie), R(eid), R(nri)
d2249 12
a2260 12
  /* 119 */ R(eie), R(eid), R(nri), R(cmpa),
  /* 123 */ R(cmpb), R(cmpc), R(cmpd), R(icr),
  /* 127 */ R(der), R(counta), R(countb), R(cmpe),
  /* 131 */ R(cmpf), R(cmpg), R(cmph), R(lctrl1),
  /* 135 */ R(lctrl2), R(ictrl), R(bar), R(ic_cst),
  /* 139 */ R(ic_adr), R(ic_dat), R(dc_cst), R(dc_adr),
  /* 143 */ R(dc_dat), R(dpdr), R(dpir), R(immr),
  /* 147 */ R(mi_ctr), R(mi_ap), R(mi_epn), R(mi_twc),
  /* 151 */ R(mi_rpn), R(md_ctr), R(m_casid), R(md_ap),
  /* 155 */ R(md_epn), R(m_twb), R(md_twc), R(md_rpn),
  /* 159 */ R(m_tw), R(mi_dbcam), R(mi_dbram0), R(mi_dbram1),
  /* 163 */ R(md_dbcam), R(md_dbram0), R(md_dbram1)
d2272 2
a2273 2
  /* 119 */ R(hid0), R(hid1), R(iabr), R(dabr),
  /* 123 */ R(pir), R(mq), R(rtcu), R(rtcl)
d2276 2
a2277 1
/* Motorola PowerPC 602.  */
d2284 3
a2286 3
  /* 119 */ R(hid0), R(hid1), R(iabr), R0,
  /* 123 */ R0, R(tcr), R(ibr), R(esasrr),
  /* 127 */ R(sebr), R(ser), R(sp), R(lt)
d2296 3
a2298 3
  /* 119 */ R(hid0), R(hid1), R(iabr), R0,
  /* 123 */ R0, R(dmiss), R(dcmp), R(hash1),
  /* 127 */ R(hash2), R(imiss), R(icmp), R(rpa)
d2308 3
a2310 3
  /* 119 */ R(hid0), R(hid1), R(iabr), R(dabr),
  /* 123 */ R(pir), R(mmcr0), R(pmc1), R(pmc2),
  /* 127 */ R(sia), R(sda)
d2320 6
a2325 6
  /* 119 */ R(hid0), R(hid1), R(iabr), R(dabr),
  /* 123 */ R0, R(ummcr0), R(upmc1), R(upmc2),
  /* 127 */ R(usia), R(ummcr1), R(upmc3), R(upmc4),
  /* 131 */ R(mmcr0), R(pmc1), R(pmc2), R(sia),
  /* 135 */ R(mmcr1), R(pmc3), R(pmc4), R(l2cr),
  /* 139 */ R(ictc), R(thrm1), R(thrm2), R(thrm3)
d2352 1
a2352 1
  R8(acc), R(spefscr),
@


1.220
log
@* rs6000-tdep.c (registers_602): Correct register name: "esassr"
should be "esasrr" ("ESA Save and Restore Register").
@
text
@d2744 1
a2744 1
  int wordsize, from_xcoff_exec, from_elf_exec, power, i, off;
a2842 1
  power = arch == bfd_arch_rs6000;
d2864 1
a2864 1
  else if (power)
d2869 1
a2869 1
  tdep->ppc_fpscr_regnum = power ? 71 : 70;
d2954 1
a2954 1
  if (arch == power)
@


1.219
log
@* ppc-tdep.h (struct gdbarch_tdep): New member: ppc_sr0_regnum.
* rs6000-tdep.c (rs6000_gdbarch_init): Initialize it.
@
text
@d2252 1
a2252 1
  /* 123 */ R0, R(tcr), R(ibr), R(esassr),
@


1.218
log
@* rs6000-tdep.c (COMMON_UISA_NOFP_REGS): Delete; unused.
@
text
@d2871 1
d2900 3
a2902 1
  if (v->arch == bfd_arch_powerpc)
d2926 1
d2935 10
d2946 4
@


1.217
log
@* rs6000-tdep.c (registers_860): Correct register name.  (No PPC
manual mentions 'md_twb', but many mention 'm_twb', and at that
point in the register list.)
@
text
@a2100 11
#define COMMON_UISA_NOFP_REGS \
  /*  0 */ R(r0), R(r1), R(r2), R(r3), R(r4), R(r5), R(r6), R(r7),  \
  /*  8 */ R(r8), R(r9), R(r10),R(r11),R(r12),R(r13),R(r14),R(r15), \
  /* 16 */ R(r16),R(r17),R(r18),R(r19),R(r20),R(r21),R(r22),R(r23), \
  /* 24 */ R(r24),R(r25),R(r26),R(r27),R(r28),R(r29),R(r30),R(r31), \
  /* 32 */ R0,    R0,    R0,    R0,    R0,    R0,    R0,    R0,     \
  /* 40 */ R0,    R0,    R0,    R0,    R0,    R0,    R0,    R0,     \
  /* 48 */ R0,    R0,    R0,    R0,    R0,    R0,    R0,    R0,     \
  /* 56 */ R0,    R0,    R0,    R0,    R0,    R0,    R0,    R0,     \
  /* 64 */ R(pc), R(ps)

@


1.216
log
@* rs6000-tdep.c (registers_powerpc_nofp): Unused; deleted.
@
text
@d2237 1
a2237 1
  /* 155 */ R(md_epn), R(md_twb), R(md_twc), R(md_rpn),
@


1.216.4.1
log
@gdb/ChangeLog:
2004-08-25  Jim Blandy  <jimb@@redhat.com>

	Merge changes from trunk:

	2004-08-09  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (set_sim_regno, init_sim_regno_table,
	rs6000_register_sim_regno): Doc fixes.

	2004-08-04  Jim Blandy  <jimb@@redhat.com>

	* ppc-linux-nat.c (fetch_register): Replace 'gdb_assert (0)' with
	a call to 'internal_error', with a more helpful error message.
	* rs6000-tdep.c (e500_pseudo_register_read,
	e500_pseudo_register_write, rs6000_store_return_value): Same.

	Change the layout of the PowerPC E500 raw register cache to allow
	the lower 32-bit halves of the GPRS to be their own raw registers,
	not pseudoregisters.
	* ppc-tdep.h (struct gdbarch_tdep): Remove ppc_gprs_pseudo_p flag;
	add ppc_ev0_upper_regnum flag.
	* rs6000-tdep.c: #include "reggroups.h".
	(spe_register_p): Recognize the ev upper half registers as SPE
	registers.
	(init_sim_regno_table): Build gdb->sim mappings for the upper-half
	registers.
	(e500_move_ev_register): New function.
	(e500_pseudo_register_read, e500_pseudo_register_write): The 'ev'
	vector registers are the pseudo-registers now, formed by splicing
	together the gprs and the upper-half registers.
	(e500_register_reggroup_p): New function.
	(P): Macro deleted.
	(P8, A4): New macro.
	(PPC_EV_REGS, PPC_GPRS_PSEUDO_REGS): Macros deleted.
	(PPC_SPE_GP_REGS, PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): New
	macros.
	(registers_e500): Rearrange register set so that the raw register
	set contains 32-bit GPRs and upper-half registers, and the SPE
	vector registers become pseudo-registers.
	(rs6000_gdbarch_init): Don't initialize tdep->ppc_gprs_pseudo_p;
	it has been deleted.  Initialize ppc_ev0_upper_regnum.  Many other
	register numbers are now the same for the E500 as they are for
	other PowerPC variants.  Register e500_register_reggroup_p as the
	register group function for the E500.
	* Makefile.in (rs6000-tdep.o): Update dependencies.

	Adapt PPC E500 native support to the new raw regcache layout.
	* ppc-linux-nat.c (struct gdb_evrregset_t): Doc fixes.
	(read_spliced_spe_reg, write_spliced_spe_reg): Deleted.
	(fetch_spe_register, store_spe_register): Handle fetching/storing
	all the SPE registers at once, if regno == -1.  These now take
	over the job of fetch_spe_registers and store_spe_registers.
	(fetch_spe_registers, store_spe_registers): Deleted.
	(fetch_ppc_registers, store_ppc_registers): Fetch/store gprs
	unconditionally; they're always raw.  Fetch/store SPE upper half
	registers, if present, instead of ev registers.
	(fetch_register, store_register): Remove sanity checks: gprs are
	never pseudo-registers now, so we never need to even mention any
	registers that are ever pseudoregisters.

	Use a fixed register numbering when communicating with the PowerPC
	simulator.
	* ppc-tdep.h (struct gdbarch_tdep): New member: 'sim_regno'.
	* rs6000-tdep.c: #include "sim-regno.h" and "gdb/sim-ppc.h".
	(set_sim_regno, init_sim_regno_table, rs6000_register_sim_regno):
	New functions.
	(rs6000_gdbarch_init): Register rs6000_register_sim_regno.  Call
	init_sim_regno_table.
	* Makefile.in (gdb_sim_ppc_h): New variable.
	(rs6000-tdep.o): Update dependencies.

	2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	...
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.

	2004-07-20  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): The register set used for
	bfd_mach_ppc has no segment registers.

	Include PowerPC SPR numbers for special-purpose registers.
	* rs6000-tdep.c (struct reg): Add new member, 'spr_num'.
	(R, R4, R8, R16, F, P, R32, R64, R0): Include value for
	new member in initializer.
	(S, S4, SN4, S64): New macros for defining special-purpose
	registers.
	(PPC_UISA_SPRS, PPC_UISA_NOFP_SPRS, PPC_OEA_SPRS, registers_power,
	registers_403, registers_403GC, registers_505, registers_860,
	registers_601, registers_602, registers_603, registers_604,
	registers_750, registers_e500): Use them.

	* rs6000-tdep.c (rs6000_gdbarch_init): Delete variable 'power';
	replace references with expression used to initialize variable.

	2004-07-16  Jim Blandy  <jimb@@redhat.com>

	* ppc-tdep.h (ppc_spr_asr): Add missing OEA SPR.
        (ppc_spr_mi_dbcam, ppc_spr_mi_dbram0, ppc_spr_mi_dbram1)
	(ppc_spr_md_cam, ppc_spr_md_ram0, ppc_spr_md_ram1): Add
	missing MPC823 SPRs.
	(ppc_spr_m_twb): Renamed from ppc_spr_md_twb; the old name was
	incorrect.  (This was corrected in GDB's register name tables on
	2004-07-14.)

	* rs6000-tdep.c (registers_602): Correct register name: "esassr"
	should be "esasrr" ("ESA Save and Restore Register").

	2004-07-15  Jim Blandy  <jimb@@redhat.com>

	* ppc-tdep.h (struct gdbarch_tdep): New member: ppc_sr0_regnum.
	* rs6000-tdep.c (rs6000_gdbarch_init): Initialize it.

	2004-07-14  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (COMMON_UISA_NOFP_REGS): Delete; unused.

	* ppc-tdep.h (ppc_num_vrs): New enum constant.

	* ppc-tdep.h (ppc_num_srs): New enum constant.

	* ppc-tdep.h (ppc_spr_mq, ppc_spr_xer, ppc_spr_rtcu, ppc_spr_rtcl)
	(ppc_spr_lr, ppc_spr_ctr, ppc_spr_cnt, ppc_spr_dsisr, ppc_spr_dar)
	(ppc_spr_dec, ppc_spr_sdr1, ppc_spr_srr0, ppc_spr_srr1)
	(ppc_spr_eie, ppc_spr_eid, ppc_spr_nri, ppc_spr_sp, ppc_spr_cmpa)
	(ppc_spr_cmpb, ppc_spr_cmpc, ppc_spr_cmpd, ppc_spr_icr)
	(ppc_spr_der, ppc_spr_counta, ppc_spr_countb, ppc_spr_cmpe)
	(ppc_spr_cmpf, ppc_spr_cmpg, ppc_spr_cmph, ppc_spr_lctrl1)
	(ppc_spr_lctrl2, ppc_spr_ictrl, ppc_spr_bar, ppc_spr_vrsave)
	(ppc_spr_sprg0, ppc_spr_sprg1, ppc_spr_sprg2, ppc_spr_sprg3)
	(ppc_spr_ear, ppc_spr_tbl, ppc_spr_tbu, ppc_spr_pvr)
	(ppc_spr_spefscr, ppc_spr_ibat0u, ppc_spr_ibat0l, ppc_spr_ibat1u)
	(ppc_spr_ibat1l, ppc_spr_ibat2u, ppc_spr_ibat2l, ppc_spr_ibat3u)
	(ppc_spr_ibat3l, ppc_spr_dbat0u, ppc_spr_dbat0l, ppc_spr_dbat1u)
	(ppc_spr_dbat1l, ppc_spr_dbat2u, ppc_spr_dbat2l, ppc_spr_dbat3u)
	(ppc_spr_dbat3l, ppc_spr_ic_cst, ppc_spr_ic_adr, ppc_spr_ic_dat)
	(ppc_spr_dc_cst, ppc_spr_dc_adr, ppc_spr_dc_dat, ppc_spr_dpdr)
	(ppc_spr_dpir, ppc_spr_immr, ppc_spr_mi_ctr, ppc_spr_mi_ap)
	(ppc_spr_mi_epn, ppc_spr_mi_twc, ppc_spr_mi_rpn, ppc_spr_mi_cam)
	(ppc_spr_mi_ram0, ppc_spr_mi_ram1, ppc_spr_md_ctr, ppc_spr_m_casid)
	(ppc_spr_md_ap, ppc_spr_md_epn, ppc_spr_md_twb, ppc_spr_md_twc)
	(ppc_spr_md_rpn, ppc_spr_m_tw, ppc_spr_md_dbcam, ppc_spr_md_dbram0)
	(ppc_spr_md_dbram1, ppc_spr_ummcr0, ppc_spr_upmc1, ppc_spr_upmc2)
	(ppc_spr_usia, ppc_spr_ummcr1, ppc_spr_upmc3, ppc_spr_upmc4)
	(ppc_spr_zpr, ppc_spr_pid, ppc_spr_mmcr0, ppc_spr_pmc1)
	(ppc_spr_sgr, ppc_spr_pmc2, ppc_spr_dcwr, ppc_spr_sia)
	(ppc_spr_mmcr1, ppc_spr_pmc3, ppc_spr_pmc4, ppc_spr_sda)
	(ppc_spr_tbhu, ppc_spr_tblu, ppc_spr_dmiss, ppc_spr_dcmp)
	(ppc_spr_hash1, ppc_spr_hash2, ppc_spr_icdbdr, ppc_spr_imiss)
	(ppc_spr_esr, ppc_spr_icmp, ppc_spr_dear, ppc_spr_rpa)
	(ppc_spr_evpr, ppc_spr_cdbcr, ppc_spr_tsr, ppc_spr_602_tcr)
	(ppc_spr_403_tcr, ppc_spr_ibr, ppc_spr_pit, ppc_spr_esasrr)
	(ppc_spr_tbhi, ppc_spr_tblo, ppc_spr_srr2, ppc_spr_sebr)
	(ppc_spr_srr3, ppc_spr_ser, ppc_spr_hid0, ppc_spr_dbsr)
	(ppc_spr_hid1, ppc_spr_iabr, ppc_spr_dbcr, ppc_spr_iac1)
	(ppc_spr_dabr, ppc_spr_iac2, ppc_spr_dac1, ppc_spr_dac2)
	(ppc_spr_l2cr, ppc_spr_dccr, ppc_spr_ictc, ppc_spr_iccr)
	(ppc_spr_thrm1, ppc_spr_pbl1, ppc_spr_thrm2, ppc_spr_pbu1)
	(ppc_spr_thrm3, ppc_spr_pbl2, ppc_spr_fpecr, ppc_spr_lt)
	(ppc_spr_pir, ppc_spr_pbu2): New enum constants for PowerPC
	special-purpose register numbers.

	* rs6000-tdep.c (registers_860): Correct register name.  (No PPC
	manual mentions 'md_twb', but many mention 'm_twb', and at that
	point in the register list.)

include/gdb/ChangeLog:
2004-08-04  Andrew Cagney  <cagney@@gnu.org>

	* sim-ppc.h: Add extern "C" wrapper.
	(enum sim_ppc_regnum): Add full list of SPRs.

2004-08-04  Jim Blandy  <jimb@@redhat.com>

	* sim-ppc.h: New file.

sim/ppc/ChangeLog:
2004-08-04  Andrew Cagney  <cagney@@gnu.org>
	    Jim Blandy <jimb@@redhat.com>

	* sim_callbacks.h (simulator): Declare.
	* Makefile.in (gdb-sim.o): New rule.
	(MAIN_SRC, GDB_OBJ): Add gdb-sim.o, gdb-sim.c.
	(DEFS_H): Delete.
	(GDB_SIM_PPC_H): Define.
	* gdb-sim.c: New file.
	* sim_calls.c: Do not include "defs.h".
	(simulator): Drop static.
	(sim_store_register, sim_fetch_register): Delete.
@
text
@a39 3
#include "sim-regno.h"
#include "gdb/sim-ppc.h"
#include "reggroups.h"
a101 3
    int spr_num;                /* PowerPC SPR number, or -1 if not an SPR.
                                   This is an ISA SPR number, not a GDB
                                   register number.  */
a156 6
  /* Is it a reference to one of the raw upper GPR halves?  */
  if (tdep->ppc_ev0_upper_regnum >= 0
      && tdep->ppc_ev0_upper_regnum <= regno
      && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    return 1;

a181 120


/* Check that TABLE[GDB_REGNO] is not already initialized, and then
   set it to SIM_REGNO.

   This is a helper function for init_sim_regno_table, constructing
   the table mapping GDB register numbers to sim register numbers; we
   initialize every element in that table to -1 before we start
   filling it in.  */
static void
set_sim_regno (int *table, int gdb_regno, int sim_regno)
{
  /* Make sure we don't try to assign any given GDB register a sim
     register number more than once.  */
  gdb_assert (table[gdb_regno] == -1);
  table[gdb_regno] = sim_regno;
}


/* Initialize ARCH->tdep->sim_regno, the table mapping GDB register
   numbers to simulator register numbers, based on the values placed
   in the ARCH->tdep->ppc_foo_regnum members.  */
static void
init_sim_regno_table (struct gdbarch *arch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
  int total_regs = gdbarch_num_regs (arch) + gdbarch_num_pseudo_regs (arch);
  const struct reg *regs = tdep->regs;
  int *sim_regno = GDBARCH_OBSTACK_CALLOC (arch, total_regs, int);
  int i;

  /* Presume that all registers not explicitly mentioned below are
     unavailable from the sim.  */
  for (i = 0; i < total_regs; i++)
    sim_regno[i] = -1;

  /* General-purpose registers.  */
  for (i = 0; i < ppc_num_gprs; i++)
    set_sim_regno (sim_regno, tdep->ppc_gp0_regnum + i, sim_ppc_r0_regnum + i);
  
  /* Floating-point registers.  */
  if (tdep->ppc_fp0_regnum >= 0)
    for (i = 0; i < ppc_num_fprs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_fp0_regnum + i,
                     sim_ppc_f0_regnum + i);
  if (tdep->ppc_fpscr_regnum >= 0)
    set_sim_regno (sim_regno, tdep->ppc_fpscr_regnum, sim_ppc_fpscr_regnum);

  set_sim_regno (sim_regno, gdbarch_pc_regnum (arch), sim_ppc_pc_regnum);
  set_sim_regno (sim_regno, tdep->ppc_ps_regnum, sim_ppc_ps_regnum);
  set_sim_regno (sim_regno, tdep->ppc_cr_regnum, sim_ppc_cr_regnum);

  /* Segment registers.  */
  if (tdep->ppc_sr0_regnum >= 0)
    for (i = 0; i < ppc_num_srs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_sr0_regnum + i,
                     sim_ppc_sr0_regnum + i);

  /* Altivec registers.  */
  if (tdep->ppc_vr0_regnum >= 0)
    {
      for (i = 0; i < ppc_num_vrs; i++)
        set_sim_regno (sim_regno,
                       tdep->ppc_vr0_regnum + i,
                       sim_ppc_vr0_regnum + i);

      /* FIXME: jimb/2004-07-15: when we have tdep->ppc_vscr_regnum,
         we can treat this more like the other cases.  */
      set_sim_regno (sim_regno,
                     tdep->ppc_vr0_regnum + ppc_num_vrs,
                     sim_ppc_vscr_regnum);
    }
  /* vsave is a special-purpose register, so the code below handles it.  */

  /* SPE APU (E500) registers.  */
  if (tdep->ppc_ev0_regnum >= 0)
    for (i = 0; i < ppc_num_gprs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_ev0_regnum + i,
                     sim_ppc_ev0_regnum + i);
  if (tdep->ppc_ev0_upper_regnum >= 0)
    for (i = 0; i < ppc_num_gprs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_ev0_upper_regnum + i,
                     sim_ppc_rh0_regnum + i);
  if (tdep->ppc_acc_regnum >= 0)
    set_sim_regno (sim_regno, tdep->ppc_acc_regnum, sim_ppc_acc_regnum);
  /* spefscr is a special-purpose register, so the code below handles it.  */

  /* Now handle all special-purpose registers.  Verify that they
     haven't mistakenly been assigned numbers by any of the above
     code).  */
  for (i = 0; i < total_regs; i++)
    if (regs[i].spr_num >= 0)
      set_sim_regno (sim_regno, i, regs[i].spr_num + sim_ppc_spr0_regnum);

  /* Drop the initialized array into place.  */
  tdep->sim_regno = sim_regno;
}


/* Given a GDB register number REG, return the corresponding SIM
   register number.  */
static int
rs6000_register_sim_regno (int reg)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  int sim_regno;

  gdb_assert (0 <= reg && reg <= NUM_REGS + NUM_PSEUDO_REGS);
  sim_regno = tdep->sim_regno[reg];

  if (sim_regno >= 0)
    return sim_regno;
  else
    return LEGACY_SIM_REGNO_IGNORE;
}

d1336 1
a1336 1
      int reg_size = register_size (current_gdbarch, ii + 3);
d1557 2
a1558 2
	  && TYPE_LENGTH (valtype) < register_size (current_gdbarch, 3))
	offset = register_size (current_gdbarch, 3) - TYPE_LENGTH (valtype);
a1762 51
/* Move SPE vector register values between a 64-bit buffer and the two
   32-bit raw register halves in a regcache.  This function handles
   both splitting a 64-bit value into two 32-bit halves, and joining
   two halves into a whole 64-bit value, depending on the function
   passed as the MOVE argument.

   EV_REG must be the number of an SPE evN vector register --- a
   pseudoregister.  REGCACHE must be a regcache, and BUFFER must be a
   64-bit buffer.

   Call MOVE once for each 32-bit half of that register, passing
   REGCACHE, the number of the raw register corresponding to that
   half, and the address of the appropriate half of BUFFER.

   For example, passing 'regcache_raw_read' as the MOVE function will
   fill BUFFER with the full 64-bit contents of EV_REG.  Or, passing
   'regcache_raw_supply' will supply the contents of BUFFER to the
   appropriate pair of raw registers in REGCACHE.

   You may need to cast away some 'const' qualifiers when passing
   MOVE, since this function can't tell at compile-time which of
   REGCACHE or BUFFER is acting as the source of the data.  If C had
   co-variant type qualifiers, ...  */
static void
e500_move_ev_register (void (*move) (struct regcache *regcache,
                                     int regnum, void *buf),
                       struct regcache *regcache, int ev_reg,
                       void *buffer)
{
  struct gdbarch *arch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch); 
  int reg_index;
  char *byte_buffer = buffer;

  gdb_assert (tdep->ppc_ev0_regnum <= ev_reg
              && ev_reg < tdep->ppc_ev0_regnum + ppc_num_gprs);

  reg_index = ev_reg - tdep->ppc_ev0_regnum;

  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      move (regcache, tdep->ppc_ev0_upper_regnum + reg_index, byte_buffer);
      move (regcache, tdep->ppc_gp0_regnum + reg_index, byte_buffer + 4);
    }
  else
    {
      move (regcache, tdep->ppc_gp0_regnum + reg_index, byte_buffer);
      move (regcache, tdep->ppc_ev0_upper_regnum + reg_index, byte_buffer + 4);
    }
}

d1767 3
a1769 1
  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
d1772 12
a1783 10
  gdb_assert (regcache_arch == gdbarch);
 
  if (tdep->ppc_ev0_regnum <= reg_nr
      && reg_nr < tdep->ppc_ev0_regnum + ppc_num_gprs)
    e500_move_ev_register (regcache_raw_read, regcache, reg_nr, buffer);
  else
    internal_error (__FILE__, __LINE__,
                    "e500_pseudo_register_read: "
                    "called on unexpected register '%s' (%d)",
                    gdbarch_register_name (gdbarch, reg_nr), reg_nr);
d1790 3
a1792 1
  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
d1795 17
a1811 34
  gdb_assert (regcache_arch == gdbarch);
 
  if (tdep->ppc_ev0_regnum <= reg_nr
      && reg_nr < tdep->ppc_ev0_regnum + ppc_num_gprs)
    e500_move_ev_register ((void (*) (struct regcache *, int, void *))
                           regcache_raw_write,
                           regcache, reg_nr, (void *) buffer);
  else
    internal_error (__FILE__, __LINE__,
                    "e500_pseudo_register_read: "
                    "called on unexpected register '%s' (%d)",
                    gdbarch_register_name (gdbarch, reg_nr), reg_nr);
}

/* The E500 needs a custom reggroup function: it has anonymous raw
   registers, and default_register_reggroup_p assumes that anonymous
   registers are not members of any reggroup.  */
static int
e500_register_reggroup_p (struct gdbarch *gdbarch,
                          int regnum,
                          struct reggroup *group)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* The save and restore register groups need to include the
     upper-half registers, even though they're anonymous.  */
  if ((group == save_reggroup
       || group == restore_reggroup)
      && (tdep->ppc_ev0_upper_regnum <= regnum
          && regnum < tdep->ppc_ev0_upper_regnum + ppc_num_gprs))
    return 1;

  /* In all other regards, the default reggroup definition is fine.  */
  return default_register_reggroup_p (gdbarch, regnum, group);
d1923 1
a1923 3
        internal_error (__FILE__, __LINE__,
                        "rs6000_store_return_value: "
                        "unexpected array return type");
d2057 1
a2057 1
#define R(name)		{ STR(name), 4, 8, 0, 0, -1 }
d2061 1
a2061 1
#define R4(name)	{ STR(name), 4, 4, 0, 0, -1 }
d2065 1
a2065 1
#define R8(name)	{ STR(name), 8, 8, 0, 0, -1 }
d2069 1
a2069 1
#define R16(name)       { STR(name), 16, 16, 0, 0, -1 }
d2072 1
a2072 1
#define F(name)		{ STR(name), 8, 8, 1, 0, -1 }
d2074 2
a2075 3
/* Return a struct reg defining a pseudo register NAME that is 64 bits
   long on all systems.  */
#define P8(name)	{ STR(name), 8, 8, 0, 1, -1 }
d2079 1
a2079 1
#define R32(name)	{ STR(name), 4, 0, 0, 0, -1 }
d2083 1
a2083 1
#define R64(name)	{ STR(name), 0, 8, 0, 0, -1 }
d2086 1
a2086 1
#define R0		{ 0, 0, 0, 0, 0, -1 }
a2087 20
/* Return a struct reg defining an anonymous raw register that's 32
   bits on all systems.  */
#define A4              { 0, 4, 4, 0, 0, -1 }

/* Return a struct reg defining an SPR named NAME that is 32 bits on
   32-bit systems and 64 bits on 64-bit systems.  */
#define S(name)         { STR(name), 4, 8, 0, 0, ppc_spr_ ## name }
  
/* Return a struct reg defining an SPR named NAME that is 32 bits on
   all systems.  */
#define S4(name)        { STR(name), 4, 4, 0, 0, ppc_spr_ ## name }
  
/* Return a struct reg defining an SPR named NAME that is 32 bits on
   all systems, and whose SPR number is NUMBER.  */
#define SN4(name, number) { STR(name), 4, 4, 0, 0, (number) }
  
/* Return a struct reg defining an SPR named NAME that's 64 bits on
   64-bit systems and that doesn't exist on 32-bit systems.  */
#define S64(name)       { STR(name), 0, 8, 0, 0, ppc_spr_ ## name }
  
d2101 11
d2114 1
a2114 1
  /* 66 */ R4(cr),  S(lr), S(ctr), S4(xer), R4(fpscr)
d2118 1
a2118 1
  /* 66 */ R4(cr),  S(lr), S(ctr), S4(xer), R0
d2129 9
a2137 9
  /*  87 */ S4(pvr), \
  /*  88 */ S(ibat0u), S(ibat0l), S(ibat1u), S(ibat1l), \
  /*  92 */ S(ibat2u), S(ibat2l), S(ibat3u), S(ibat3l), \
  /*  96 */ S(dbat0u), S(dbat0l), S(dbat1u), S(dbat1l), \
  /* 100 */ S(dbat2u), S(dbat2l), S(dbat3u), S(dbat3l), \
  /* 104 */ S(sdr1),   S64(asr),  S(dar),    S4(dsisr), \
  /* 108 */ S(sprg0),  S(sprg1),  S(sprg2),  S(sprg3),  \
  /* 112 */ S(srr0),   S(srr1),   S(tbl),    S(tbu),    \
  /* 116 */ S4(dec),   S(dabr),   S4(ear)
d2147 13
a2159 32

/* On machines supporting the SPE APU, the general-purpose registers
   are 64 bits long.  There are SIMD vector instructions to treat them
   as pairs of floats, but the rest of the instruction set treats them
   as 32-bit registers, and only operates on their lower halves.

   In the GDB regcache, we treat their high and low halves as separate
   registers.  The low halves we present as the general-purpose
   registers, and then we have pseudo-registers that stitch together
   the upper and lower halves and present them as pseudo-registers.  */

/* SPE GPR lower halves --- raw registers.  */
#define PPC_SPE_GP_REGS \
  /*  0 */ R4(r0), R4(r1), R4(r2), R4(r3), R4(r4), R4(r5), R4(r6), R4(r7),  \
  /*  8 */ R4(r8), R4(r9), R4(r10),R4(r11),R4(r12),R4(r13),R4(r14),R4(r15), \
  /* 16 */ R4(r16),R4(r17),R4(r18),R4(r19),R4(r20),R4(r21),R4(r22),R4(r23), \
  /* 24 */ R4(r24),R4(r25),R4(r26),R4(r27),R4(r28),R4(r29),R4(r30),R4(r31)

/* SPE GPR upper halves --- anonymous raw registers.  */
#define PPC_SPE_UPPER_GP_REGS                   \
  /*  0 */ A4, A4, A4, A4, A4, A4, A4, A4,      \
  /*  8 */ A4, A4, A4, A4, A4, A4, A4, A4,      \
  /* 16 */ A4, A4, A4, A4, A4, A4, A4, A4,      \
  /* 24 */ A4, A4, A4, A4, A4, A4, A4, A4

/* SPE GPR vector registers --- pseudo registers based on underlying
   gprs and the anonymous upper half raw registers.  */
#define PPC_EV_PSEUDO_REGS \
/* 0*/P8(ev0), P8(ev1), P8(ev2), P8(ev3), P8(ev4), P8(ev5), P8(ev6), P8(ev7), \
/* 8*/P8(ev8), P8(ev9), P8(ev10),P8(ev11),P8(ev12),P8(ev13),P8(ev14),P8(ev15),\
/*16*/P8(ev16),P8(ev17),P8(ev18),P8(ev19),P8(ev20),P8(ev21),P8(ev22),P8(ev23),\
/*24*/P8(ev24),P8(ev25),P8(ev26),P8(ev27),P8(ev28),P8(ev29),P8(ev30),P8(ev31)
d2166 1
a2166 1
  /* 66 */ R4(cnd), S(lr), S(cnt), S4(xer), S4(mq),
d2179 1
a2179 13
/* IBM PowerPC 403.

   Some notes about the "tcr" special-purpose register:
   - On the 403 and 403GC, SPR 986 is named "tcr", and it controls the
     403's programmable interval timer, fixed interval timer, and
     watchdog timer.
   - On the 602, SPR 984 is named "tcr", and it controls the 602's
     watchdog timer, and nothing else.

   Some of the fields are similar between the two, but they're not
   compatible with each other.  Since the two variants have different
   registers, with different numbers, but the same name, we can't
   splice the register name to get the SPR number.  */
d2186 6
a2191 6
  /* 119 */ S(icdbdr), S(esr),  S(dear), S(evpr),
  /* 123 */ S(cdbcr),  S(tsr),  SN4(tcr, ppc_spr_403_tcr), S(pit),
  /* 127 */ S(tbhi),   S(tblo), S(srr2), S(srr3),
  /* 131 */ S(dbsr),   S(dbcr), S(iac1), S(iac2),
  /* 135 */ S(dac1),   S(dac2), S(dccr), S(iccr),
  /* 139 */ S(pbl1),   S(pbu1), S(pbl2), S(pbu2)
d2194 1
a2194 2
/* IBM PowerPC 403GC.
   See the comments about 'tcr' for the 403, above.  */
d2201 8
a2208 8
  /* 119 */ S(icdbdr), S(esr),  S(dear), S(evpr),
  /* 123 */ S(cdbcr),  S(tsr),  SN4(tcr, ppc_spr_403_tcr), S(pit),
  /* 127 */ S(tbhi),   S(tblo), S(srr2), S(srr3),
  /* 131 */ S(dbsr),   S(dbcr), S(iac1), S(iac2),
  /* 135 */ S(dac1),   S(dac2), S(dccr), S(iccr),
  /* 139 */ S(pbl1),   S(pbu1), S(pbl2), S(pbu2),
  /* 143 */ S(zpr),    S(pid),  S(sgr),  S(dcwr),
  /* 147 */ S(tbhu),   S(tblu)
d2218 1
a2218 1
  /* 119 */ S(eie), S(eid), S(nri)
d2228 12
a2239 12
  /* 119 */ S(eie), S(eid), S(nri), S(cmpa),
  /* 123 */ S(cmpb), S(cmpc), S(cmpd), S(icr),
  /* 127 */ S(der), S(counta), S(countb), S(cmpe),
  /* 131 */ S(cmpf), S(cmpg), S(cmph), S(lctrl1),
  /* 135 */ S(lctrl2), S(ictrl), S(bar), S(ic_cst),
  /* 139 */ S(ic_adr), S(ic_dat), S(dc_cst), S(dc_adr),
  /* 143 */ S(dc_dat), S(dpdr), S(dpir), S(immr),
  /* 147 */ S(mi_ctr), S(mi_ap), S(mi_epn), S(mi_twc),
  /* 151 */ S(mi_rpn), S(md_ctr), S(m_casid), S(md_ap),
  /* 155 */ S(md_epn), S(m_twb), S(md_twc), S(md_rpn),
  /* 159 */ S(m_tw), S(mi_dbcam), S(mi_dbram0), S(mi_dbram1),
  /* 163 */ S(md_dbcam), S(md_dbram0), S(md_dbram1)
d2251 2
a2252 2
  /* 119 */ S(hid0), S(hid1), S(iabr), S(dabr),
  /* 123 */ S(pir), S(mq), S(rtcu), S(rtcl)
d2255 1
a2255 2
/* Motorola PowerPC 602.
   See the notes under the 403 about 'tcr'.  */
d2262 3
a2264 3
  /* 119 */ S(hid0), S(hid1), S(iabr), R0,
  /* 123 */ R0, SN4(tcr, ppc_spr_602_tcr), S(ibr), S(esasrr),
  /* 127 */ S(sebr), S(ser), S(sp), S(lt)
d2274 3
a2276 3
  /* 119 */ S(hid0), S(hid1), S(iabr), R0,
  /* 123 */ R0, S(dmiss), S(dcmp), S(hash1),
  /* 127 */ S(hash2), S(imiss), S(icmp), S(rpa)
d2286 3
a2288 3
  /* 119 */ S(hid0), S(hid1), S(iabr), S(dabr),
  /* 123 */ S(pir), S(mmcr0), S(pmc1), S(pmc2),
  /* 127 */ S(sia), S(sda)
d2298 6
a2303 6
  /* 119 */ S(hid0), S(hid1), S(iabr), S(dabr),
  /* 123 */ R0, S(ummcr0), S(upmc1), S(upmc2),
  /* 127 */ S(usia), S(ummcr1), S(upmc3), S(upmc4),
  /* 131 */ S(mmcr0), S(pmc1), S(pmc2), S(sia),
  /* 135 */ S(mmcr1), S(pmc3), S(pmc4), S(l2cr),
  /* 139 */ S(ictc), S(thrm1), S(thrm2), S(thrm3)
d2325 6
a2330 5
  /*   0 ..  31 */ PPC_SPE_GP_REGS,
  /*  32 ..  63 */ PPC_SPE_UPPER_GP_REGS,
  /*  64 ..  65 */ R(pc), R(ps),
  /*  66 ..  70 */ PPC_UISA_NOFP_SPRS,
  /*  71 ..  72 */ R8(acc), S4(spefscr),
d2333 2
a2334 1
  /*  73 .. 104 */ PPC_EV_PSEUDO_REGS
d2755 1
a2755 1
  int wordsize, from_xcoff_exec, from_elf_exec, i, off;
d2854 1
d2867 1
d2876 1
a2876 1
  else if (arch == bfd_arch_rs6000)
d2881 1
a2881 2
  tdep->ppc_fpscr_regnum = (arch == bfd_arch_rs6000) ? 71 : 70;
  tdep->ppc_sr0_regnum = 71;
a2883 1
  tdep->ppc_ev0_upper_regnum = -1;
a2891 1
  set_gdbarch_register_sim_regno (gdbarch, rs6000_register_sim_regno);
d2910 1
a2910 3
  if (v->arch == bfd_arch_rs6000)
    tdep->ppc_sr0_regnum = -1;
  else if (v->arch == bfd_arch_powerpc)
a2913 1
        tdep->ppc_sr0_regnum = -1;
d2922 2
d2925 7
a2931 5
        tdep->ppc_ev0_upper_regnum = 32;
	tdep->ppc_ev0_regnum = 73;
	tdep->ppc_ev31_regnum = 104;
        tdep->ppc_acc_regnum = 71;
        tdep->ppc_spefscr_regnum = 72;
d2934 5
a2938 1
        tdep->ppc_sr0_regnum = -1;
a2940 1
        set_gdbarch_register_reggroup_p (gdbarch, e500_register_reggroup_p);
a2941 10

      case bfd_mach_ppc64:
      case bfd_mach_ppc_620:
      case bfd_mach_ppc_630:
      case bfd_mach_ppc_a35:
      case bfd_mach_ppc_rs64ii:
      case bfd_mach_ppc_rs64iii:
        /* These processor's register sets don't have segment registers.  */
        tdep->ppc_sr0_regnum = -1;
        break;
a2942 4
  else
    internal_error (__FILE__, __LINE__,
                    "rs6000_gdbarch_init: "
                    "received unexpected BFD 'arch' value");
d2948 1
a2948 1
  if (arch == bfd_arch_rs6000)
a3068 2
  init_sim_regno_table (gdbarch);

@


1.216.4.2
log
@* rs6000-tdep.c: #include "dwarf2-frame.h".
(rs6000_dwarf2_reg_to_regnum): Recognize 65 as another number for lr.
(rs6000_gdbarch_init): Hook in dwarf2_frame_sniffer.
* Makefile.in (rs6000-tdep.o): Update dependencies.
@
text
@a42 1
#include "dwarf2-frame.h"
a2069 4
        /* FIXME: jimb/2004-09-02: I think it's a bug that GCC ever
           emits this.  But GCC 3.4 does use it in .debug_frame.  */
      case 65:
        return tdep->ppc_lr_regnum;
a3283 3
  /* Hook in the DWARF CFI frame unwinder.  */
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);

@


1.216.4.3
log
@* rs6000-tdep.c: #include "dwarf2expr.h".
(dwarf_piece_is_ev_upper_reg, dwarf_piece_is_gpr)
(e500_dwarf_simplify_register_pieces): New functions.
(rs6000_gdbarch_init): If the architecture is E500, register
e500_dwarf_simplify_register_pieces.
* Makefile.in (rs6000-tdep.o): Update dependencies.

* gdbarch.sh (dwarf_simplify_register_pieces): New method.
Add forward declaration for 'struct dwarf_expr_piece'.
* gdbarch.c, gdbarch.h: Regenerated.
* dwarf2loc.c (dwarf2_evaluate_loc_desc): Try to simplify
multi-piece expression results before giving up.
* arch-utils.c (dwarf_never_simplify_pieces): New function.
* arch-utils.h (struct dwarf_expr_piece): Forward decl for struct
type, used in ...
(dwarf_never_simplify_pieces): New declaration.
@
text
@a42 1
#include "dwarf2expr.h"
a2008 78
/* Return true if PIECE is a SPE upper-half register for ARCH.
   Remember that pieces use the Dwarf register numbering.  */
static int
dwarf_piece_is_ev_upper_reg (struct gdbarch *arch,
                       struct dwarf_expr_piece *piece)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);

  return (piece->in_reg
          && 1200 <= piece->value
          && piece->value < 1200 + ppc_num_gprs
          && piece->size == register_size (arch, 
                                           (piece->value - 1200
                                            + tdep->ppc_ev0_upper_regnum)));
}

/* Return true if PIECE is a full GPR in ARCH.
   Remember that pieces use the Dwarf register numbering.  */
static int
dwarf_piece_is_gpr (struct gdbarch *arch,
                       struct dwarf_expr_piece *piece)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);

  return (piece->in_reg
          && 0 <= piece->value
          && piece->value < ppc_num_gprs
          && (piece->size
              == register_size (arch, piece->value + tdep->ppc_gp0_regnum)));
}

static int
e500_dwarf_simplify_register_pieces (struct gdbarch *gdbarch,
                                     int num_pieces,
                                     struct dwarf_expr_piece *pieces)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (num_pieces == 2)
    {
      int low, high;

      /* Pieces are listed in order of increasing addresses, so the
         endianness affects the order of the most- and least-
         significant halves.  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
        high = 0, low = 1;
      else if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
        low = 0, high = 1;
      else
        internal_error (__FILE__, __LINE__,
                        "fetch_register: unexpected byte order: %d",
                        gdbarch_byte_order (gdbarch));

      /* An SPE vector register is the concatenation of an "upper
         half" register with a GPR, each four bytes long.  */
      if (dwarf_piece_is_ev_upper_reg (gdbarch, &pieces[high])
          && dwarf_piece_is_gpr (gdbarch, &pieces[low])
          && (pieces[high].value - 1200 == pieces[low].value))
        /* Return the corresponding 64-bit 'ev' pseudo-register.  */
        return tdep->ppc_ev0_regnum + pieces[low].value;
      
      /* long long values are sometimes placed in pairs of consecutive
         registers.  The lower-addressed end of the value is always
         assigned the lower-numbered register, so we don't need to
         worry about endianness here.  */
      else if (dwarf_piece_is_gpr (gdbarch, &pieces[0])
               && dwarf_piece_is_gpr (gdbarch, &pieces[1])
               && pieces[0].value + 1 == pieces[1].value)
        return tdep->ppc_gp0_regnum + pieces[0].value;

      else
        return -1;
    }
  else
    return -1;
}

a3179 2
        set_gdbarch_dwarf_simplify_register_pieces
          (gdbarch, e500_dwarf_simplify_register_pieces);
@


1.215
log
@2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_USE_STRUCT_CONVENTION): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* values.c (using_struct_return): Update call.
	* mcore-tdep.c: Update comment.
	* infcall.c (call_function_by_hand): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* arch-utils.h (always_use_struct_convention): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	USE_STRUCT_CONVENTION.
@
text
@a2178 8
/* PowerPC UISA - a PPC processor as viewed by user-level
   code, but without floating point registers.  */
static const struct reg registers_powerpc_nofp[] =
{
  COMMON_UISA_NOFP_REGS,
  PPC_UISA_SPRS
};

@


1.214
log
@Add native Linux support for the PowerPC E500.
* ppc-tdep.h (struct gdbarch_tdep): New member: 'ppc_gprs_pseudo_p'.
* rs6000-tdep.c (rs6000_gdbarch_init): Initialize it to false on
all architectures except the E500.
* ppc-linux-nat.c: (PTRACE_GETEVRREGS, PTRACE_SETEVRREGS): New
#definitions.
(struct gdb_evrregset_t): New type.
(have_ptrace_getsetevrregs): New variable.
(get_spe_registers, read_spliced_spe_reg, fetch_spe_register,
fetch_spe_registers): New functions.
(fetch_register): Call fetch_spe_register as appropriate.
Assert that we're only passed raw register numbers.
(fetch_ppc_registers): Call fetch_spe_registers as appropriate.
Don't fetch gprs if they're pseudoregisters.
(set_spe_registers, write_spliced_spe_reg, store_spe_register,
store_spe_registers): New functions.
(store_register): Call store_spe_register as appropriate.
Assert that we're only passed raw register numbers.
(store_ppc_registers): Call store_spe_registers as appropriate.
Don't store gprs if they're pseudoregisters.
@
text
@d3031 1
a3031 2
    set_gdbarch_use_struct_convention (gdbarch,
				       rs6000_use_struct_convention);
@


1.213
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d2875 1
d2931 1
@


1.212
log
@* rs6000-tdep.c (rs6000_store_return_value): Use
regcache_cooked_write_part instead of
deprecated_write_register_bytes.
(rs6000_gdbarch_init): Register it for gdbarch_store_return_value,
not gdbarch_deprecated_store_return_value.
@
text
@d39 1
d1275 1
a1275 1
rs6000_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
d1288 1
@


1.211
log
@* ppc-tdep.h: Delete unused 'regoff' member.
* rs6000-tdep.c (rs6000_gdbarch_init): Don't initialize it.
@
text
@d1897 3
a1899 1
rs6000_store_return_value (struct type *type, char *valbuf)
d1901 3
a1903 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1908 1
a1908 1
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));
a1910 1

d1914 1
a1914 5

    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (tdep->ppc_fp0_regnum + 1),
       valbuf,
       TYPE_LENGTH (type));
d1919 3
a1921 2
	deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
					 valbuf, TYPE_LENGTH (type));
d1925 17
a1941 2
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + 3),
				     valbuf, TYPE_LENGTH (type));
d1944 1
d2904 1
a2904 1
      set_gdbarch_deprecated_store_return_value (gdbarch, rs6000_store_return_value);
@


1.210
log
@* rs6000-tdep.c: Use the modern gdbarch methods for handling the
register set, so our regcache isn't declared "legacy" and our E500
pseudoregister read and write functions aren't ignored.
(rs6000_register_byte, rs6000_register_raw_size,
rs6000_register_virtual_type, rs6000_register_convertible,
rs6000_register_convert_to_virtual,
rs6000_register_convert_to_raw): Deleted.
(rs6000_register_type, rs6000_convert_register_p,
rs6000_register_to_value, rs6000_value_to_register): New
functions.
(rs6000_gdbarch_init): Don't register
gdbarch_deprecated_register_size,
gdbarch_deprecated_register_bytes,
gdbarch_deprecated_register_byte,
gdbarch_deprecated_register_raw_size,
gdbarch_deprecated_register_virtual_type,
gdbarch_deprecated_register_convertible,
gdbarch_deprecated_register_convert_to_virtual, or
gdbarch_deprecated_register_convert_to_raw methods.  Instead,
register gdbarch_register_type, gdbarch_convert_register_p,
gdbarch_register_to_value, and gdbarch_value_to_register methods.
@
text
@a2898 8
  /* Calculate byte offsets in raw register array.  */
  tdep->regoff = xmalloc (v->num_tot_regs * sizeof (int));
  for (i = off = 0; i < v->num_tot_regs; i++)
    {
      tdep->regoff[i] = off;
      off += regsize (v->regs + i, wordsize);
    }

@


1.209
log
@* rs6000-tdep.c (rs6000_dwarf2_stab_reg_to_regnum): Deleted.
(rs6000_stab_reg_to_regnum, rs6000_dwarf2_reg_to_regnum): New
functions, updated to match the register numberings used in GCC.
(rs6000_gdbarch_init): Register rs6000_stab_reg_to_regnum and
rs6000_dwarf2_reg_to_regnum as register number conversions
functions for STABS and Dwarf2.
@
text
@a1679 20
/* Index within `registers' of the first byte of the space for
   register N.  */

static int
rs6000_register_byte (int n)
{
  return gdbarch_tdep (current_gdbarch)->regoff[n];
}

/* Return the number of bytes of storage in the actual machine representation
   for register N if that register is available, else return 0.  */

static int
rs6000_register_raw_size (int n)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  const struct reg *reg = tdep->regs + n;
  return regsize (reg, tdep->wordsize);
}

d1684 1
a1684 1
rs6000_register_virtual_type (int n)
d1686 1
a1686 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1716 1
a1716 4
/* Return whether register N requires conversion when moving from raw format
   to virtual format.

   The register format for RS/6000 floating point registers is always
d1720 1
a1720 1
rs6000_register_convertible (int n)
d1722 5
a1726 2
  const struct reg *reg = gdbarch_tdep (current_gdbarch)->regs + n;
  return reg->fpr;
d1729 15
a1743 2
/* Convert data from raw format for register N in buffer FROM
   to virtual format with type TYPE in buffer TO.  */
d1746 4
a1749 2
rs6000_register_convert_to_virtual (int n, struct type *type,
				    char *from, char *to)
d1751 2
a1752 8
  if (TYPE_LENGTH (type) != DEPRECATED_REGISTER_RAW_SIZE (n))
    {
      double val = deprecated_extract_floating (from, DEPRECATED_REGISTER_RAW_SIZE (n));
      deprecated_store_floating (to, TYPE_LENGTH (type), val);
    }
  else
    memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (n));
}
d1754 2
a1755 2
/* Convert data from virtual format with type TYPE in buffer FROM
   to raw format for register N in buffer TO.  */
d1757 2
a1758 11
static void
rs6000_register_convert_to_raw (struct type *type, int n,
				const char *from, char *to)
{
  if (TYPE_LENGTH (type) != DEPRECATED_REGISTER_RAW_SIZE (n))
    {
      double val = deprecated_extract_floating (from, TYPE_LENGTH (type));
      deprecated_store_floating (to, DEPRECATED_REGISTER_RAW_SIZE (n), val);
    }
  else
    memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (n));
d2954 1
a2954 5
  set_gdbarch_deprecated_register_size (gdbarch, wordsize);
  set_gdbarch_deprecated_register_bytes (gdbarch, off);
  set_gdbarch_deprecated_register_byte (gdbarch, rs6000_register_byte);
  set_gdbarch_deprecated_register_raw_size (gdbarch, rs6000_register_raw_size);
  set_gdbarch_deprecated_register_virtual_type (gdbarch, rs6000_register_virtual_type);
d2980 4
a2983 3
  set_gdbarch_deprecated_register_convertible (gdbarch, rs6000_register_convertible);
  set_gdbarch_deprecated_register_convert_to_virtual (gdbarch, rs6000_register_convert_to_virtual);
  set_gdbarch_deprecated_register_convert_to_raw (gdbarch, rs6000_register_convert_to_raw);
@


1.208
log
@* ppc-tdep.h (spe_register_p): New declaration.
(struct gdbarch_tdep): New members: ppc_acc_regnum and
ppc_spefscr_regnum.
* rs6000-tdep.c (spe_register_p): New function.
(rs6000_dwarf2_stab_reg_to_regnum): Recognize numbers for acc and
spefscr.
(rs6000_gdbarch_init): Initialize the new members of the tdep
structure.
@
text
@d1832 1
a1832 2
/* Convert a dbx stab or Dwarf 2 register number (from `r'
   declaration) to a gdb REGNUM.  */
d1834 1
a1834 1
rs6000_dwarf2_stab_reg_to_regnum (int num)
d1845 2
d1862 2
d1865 1
a1865 1
        return gdbarch_tdep (current_gdbarch)->ppc_acc_regnum;
d1867 1
a1867 1
        return gdbarch_tdep (current_gdbarch)->ppc_spefscr_regnum;
d1871 1
a1872 2
  /* FIXME: jimb/2004-03-28: Doesn't something need to be done here
     for the Altivec registers, too?
d1874 5
a1878 5
     Looking at GCC, the headers in config/rs6000 never define a
     DBX_REGISTER_NUMBER macro, so the debug info uses the same
     numbers GCC does internally.  Then, looking at the REGISTER_NAMES
     macro defined in config/rs6000/rs6000.h, it seems that GCC gives
     v0 -- v31 the numbers 77 -- 108.  But we number them 119 -- 150.
d1880 33
a1912 2
     I don't have a way to test this ready to hand, but I noticed it
     and thought I should include a note.  */
d1915 1
d3007 2
a3008 2
  set_gdbarch_stab_reg_to_regnum (gdbarch, rs6000_dwarf2_stab_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, rs6000_dwarf2_stab_reg_to_regnum);
@


1.207
log
@* rs6000-tdep.c (rs6000_push_dummy_call): Formatting fixes.
@
text
@d144 27
d1861 4
d2861 2
d2916 2
@


1.206
log
@* rs6000-tdep.c (rs6000_gdbarch_init): Initialize tdep fields
before the mach-specific switch, and then let the individual cases
override the defaults, rather than leaving them uninitialized
until the switch and then setting them in each case.
@
text
@d1321 2
a1322 2
	    printf_unfiltered (
				"Fatal Error: a floating point parameter #%d with a size > 8 is found!\n", argno);
d1435 2
a1436 2
		printf_unfiltered (
				    "Fatal Error: a floating point parameter #%d with a size > 8 is found!\n", argno);
d1446 3
a1448 1
	  write_memory (sp + 24 + (ii * 4), (char *) VALUE_CONTENTS (arg), len);
@


1.205
log
@        * rs6000-tdep.c (store_param_on_stack_p): New function,
        an improved version of some code extracted from skip_prologue().
        (skip_prologue): Use store_param_on_stack_p() to detect
        instructions saving a parameter on the stack. Detect when r0
        is used to save a parameter.
        Do not mark "li rx, SIMM" instructions as part of the prologue,
        unless the following instruction is also part of the prologue.
@
text
@d2824 4
d2842 16
a2863 2
	tdep->ppc_ev0_regnum = -1;
	tdep->ppc_ev31_regnum = -1;
a2867 2
	tdep->ppc_ev0_regnum = -1;
	tdep->ppc_ev31_regnum = -1;
a2886 6
      default:
	tdep->ppc_vr0_regnum = -1;
	tdep->ppc_vrsave_regnum = -1;
	tdep->ppc_ev0_regnum = -1;
	tdep->ppc_ev31_regnum = -1;
	break;
a2890 16

  /* Set lr_frame_offset.  */
  if (wordsize == 8)
    tdep->lr_frame_offset = 16;
  else if (sysv_abi)
    tdep->lr_frame_offset = 4;
  else
    tdep->lr_frame_offset = 8;

  /* Calculate byte offsets in raw register array.  */
  tdep->regoff = xmalloc (v->num_tot_regs * sizeof (int));
  for (i = off = 0; i < v->num_tot_regs; i++)
    {
      tdep->regoff[i] = off;
      off += regsize (v->regs + i, wordsize);
    }
@


1.204
log
@* aix-thread.c (pdc_read_regs, supply_gprs64, supply_fprs)
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Use
ppc_num_gprs and ppc_num_fprs instead of '32' and '31'.
* ppc-linux-nat.c (fill_gregset): Same.
* ppc-linux-tdep.c (ppc_linux_supply_gregset)
(ppc_linux_sigtramp_cache): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_fill_reg)
(ppcnbsd_sigtramp_cache_init): Same.
* rs6000-nat.c (fetch_core_registers): Same.
* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
(rs6000_frame_cache): Same.
@
text
@d595 70
d687 1
d756 2
d763 2
d811 1
d820 1
d954 1
a954 20
      else if ((op & 0xfc0007fe) == 0x7c000378 &&	/* mr(.)  Rx,Ry */
               (((op >> 21) & 31) >= 3) &&              /* R3 >= Ry >= R10 */
               (((op >> 21) & 31) <= 10) &&
               (((op >> 16) & 31) == 0)) /* Rx: scratch register r0 */
        {
          continue;
        }
      else if ((op & 0xfc1f0003) == 0xf8010000 ||	/* std rx,NUM(r1) */
	       (op & 0xfc1f0000) == 0xd8010000 ||	/* stfd Rx,NUM(r1) */
	       (op & 0xfc1f0000) == 0xfc010000)		/* frsp, fp?,NUM(r1) */
	{
	  continue;

	  /* store parameters in stack via frame pointer */
	}
      else if (framep &&
	       ((op & 0xfc1f0000) == 0x901f0000 ||     /* st rx,NUM(r31) */
                (op & 0xfc1f0000) == 0x981f0000 ||     /* stb Rx,NUM(r31) */
		(op & 0xfc1f0000) == 0xd81f0000 ||     /* stfd Rx,NUM(r31) */
		(op & 0xfc1f0000) == 0xfc1f0000))      /* frsp, fp?,NUM(r31) */
d1023 2
d1027 5
@


1.203
log
@* aix-thread.c (supply_gprs64, fetch_regs_user_thread)
(store_regs_user_thread): Use tdep->ppc_gp0_regnum, instead
of assuming that the gprs are numbered starting with zero.
* ppc-linux-nat.c (fill_gregset): Same.
* ppc-linux-tdep.c (ppc_linux_supply_gregset): Same.
* ppcnbsd-nat.c (getregs_supplies): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_fill_reg): Same.
* rs6000-nat.c (fetch_core_registers): Same.
* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset): Same.
@
text
@d189 1
a189 1
       i < tdep->ppc_gp0_regnum + 32;
d265 1
a265 1
       i < tdep->ppc_gp0_regnum + 32;
d2480 1
a2480 1
        for (i = fdata.saved_fpr; i < 32; i++)
d2494 1
a2494 1
      for (i = fdata.saved_gpr; i < 32; i++)
d2525 1
a2525 1
	  for (i = fdata.saved_ev; i < 32; i++)
@


1.202
log
@* ppc-tdep.h (struct gdbarch_tdep): Change definition of
ppc_fp0_regnum and ppc_fpscr_regnum: if they are -1, then this
processor variant lacks those registers.
(ppc_floating_point_unit_p): Change description to make it clear
that this returns info about the ISA, not the ABI.
* rs6000-tdep.c (ppc_floating_point_unit_p): Decide whether to
return true or false by checking tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum.  The original code replicated the BFD
arch/mach switching done in rs6000_gdbarch_init; it's better to
keep that logic there, and just check the results here.
(rs6000_gdbarch_init): On the E500, set tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum to -1 to indicate that we have no
floating-point registers.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_store_return_value): Assert that we have floating-point
registers.
(rs6000_dwarf2_stab_reg_to_regnum): Add FIXME.
(rs6000_frame_cache): Don't note the locations at which
floating-point registers were saved if we have no fprs.
* aix-thread.c (supply_fprs, fill_fprs): Assert that we have FP
registers.
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Only call
supply_fprs / fill_fprs if we actually have floating-point
registers.
(special_register_p): Check ppc_fpscr_regnum before matching
against it.
(supply_sprs64, supply_sprs32, fill_sprs64, fill_sprs32): Don't
supply / collect fpscr if we don't have it.
* ppc-bdm.c: #include "gdb_assert.h".
(bdm_ppc_fetch_registers, bdm_ppc_store_registers): Assert that we
have floating-point registers, since I can't test this code on
FP-free systems to adapt it.
* ppc-linux-nat.c (ppc_register_u_addr): Don't match against the
fpscr and floating point register numbers if they don't exist.
(fetch_register): Assert that we have floating-point registers
before we reach the code that handles them.
(store_register): Same.  And use tdep instead of calling
gdbarch_tdep again.
(fill_fpregset): Don't try to collect FP registers and fpscr if we
don't have them.
(ppc_linux_sigtramp_cache): Don't record the saved locations of
fprs and fpscr if we don't have them.
(ppc_linux_supply_fpregset): Don't supply fp regs and fpscr if we
don't have them.
* ppcnbsd-nat.c: #include "gdb_assert.h".
(getfpregs_supplies): Assert that we have floating-point registers.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg): Same.
* ppcobsd-tdep.c: #include "gdb_assert.h".
(ppcobsd_supply_gregset, ppcobsd_collect_gregset): Assert that we
have floating-point registers.
* rs6000-nat.c (regmap): Don't match against the fpscr and
floating point register numbers if they don't exist.
(fetch_inferior_registers, store_inferior_registers,
fetch_core_registers): Only fetch / store / supply the
floating-point registers and the fpscr if we have them.
* Makefile.in (ppc-bdm.o, ppc-linux-nat.o, ppcnbsd-nat.o)
(ppcobsd-tdep.o): Update dependencies.
@
text
@d188 3
a190 1
  for (i = 0, offset = offsets->r0_offset; i < 32; i++, offset += 4)
d264 3
a266 1
  for (i = 0; i < 32; i++, offset += 4)
@


1.201
log
@Back out change.  The NetBSD changes need Jason Thorpe's approval, but
he hasn't reviewed it yet.
@
text
@d143 3
a145 1
/* Use the architectures FP registers?  */
d149 4
a152 6
  const struct bfd_arch_info *info = gdbarch_bfd_arch_info (gdbarch);
  if (info->arch == bfd_arch_powerpc)
    return (info->mach != bfd_mach_ppc_e500);
  if (info->arch == bfd_arch_rs6000)
    return 1;
  return 0;
d229 2
d306 2
d1197 5
d1428 5
d1744 3
d1785 5
d2470 11
a2480 5
      for (i = fdata.saved_fpr; i < 32; i++)
	{
	  cache->saved_regs[tdep->ppc_fp0_regnum + i].addr = fpr_addr;
	  fpr_addr += 8;
	}
d2794 2
@


1.200
log
@* ppc-tdep.h (struct gdbarch_tdep): Change definition of
ppc_fp0_regnum and ppc_fpscr_regnum: if they are -1, then this
processor variant lacks those registers.
(ppc_floating_point_unit_p): Change description to make it clear
that this returns info about the ISA, not the ABI.
* rs6000-tdep.c (ppc_floating_point_unit_p): Decide whether to
return true or false by checking tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum.  The original code replicated the BFD
arch/mach switching done in rs6000_gdbarch_init; it's better to
keep that logic there, and just check the results here.
(rs6000_gdbarch_init): On the E500, set tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum to -1 to indicate that we have no
floating-point registers.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_store_return_value): Assert that we have floating-point
registers.
(rs6000_dwarf2_stab_reg_to_regnum): Add FIXME.
(rs6000_frame_cache): Don't note the locations at which
floating-point registers were saved if we have no fprs.
* aix-thread.c (supply_fprs, fill_fprs): Assert that we have FP
registers.
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Only call
supply_fprs / fill_fprs if we actually have floating-point
registers.
(special_register_p): Check ppc_fpscr_regnum before matching
against it.
(supply_sprs64, supply_sprs32, fill_sprs64, fill_sprs32): Don't
supply / collect fpscr if we don't have it.
* ppc-bdm.c: #include "gdb_assert.h".
(bdm_ppc_fetch_registers, bdm_ppc_store_registers): Assert that we
have floating-point registers, since I can't test this code on
FP-free systems to adapt it.
* ppc-linux-nat.c (ppc_register_u_addr): Don't match against the
fpscr and floating point register numbers if they don't exist.
(fetch_register): Assert that we have floating-point registers
before we reach the code that handles them.
(store_register): Same.  And use tdep instead of calling
gdbarch_tdep again.
(fill_fpregset): Don't try to collect FP registers and fpscr if we
don't have them.
(ppc_linux_sigtramp_cache): Don't record the saved locations of
fprs and fpscr if we don't have them.
(ppc_linux_supply_fpregset): Don't supply fp regs and fpscr if we
don't have them.
* ppcnbsd-nat.c: #include "gdb_assert.h".
(getfpregs_supplies): Assert that we have floating-point registers.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg): Same.
* ppcobsd-tdep.c: #include "gdb_assert.h".
(ppcobsd_supply_gregset, ppcobsd_collect_gregset): Assert that we
have floating-point registers.
* rs6000-nat.c (regmap): Don't match against the fpscr and
floating point register numbers if they don't exist.
(fetch_inferior_registers, store_inferior_registers,
fetch_core_registers): Only fetch / store / supply the
floating-point registers and the fpscr if we have them.
* Makefile.in (ppc-bdm.o, ppc-linux-nat.o, ppcnbsd-nat.o)
(ppcobsd-tdep.o): Update dependencies.
@
text
@d143 1
a143 3

/* Return non-zero if the architecture described by GDBARCH has
   floating-point registers (f0 --- f31 and fpscr).  */
d147 6
a152 4
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  return (tdep->ppc_fp0_regnum >= 0
          && tdep->ppc_fpscr_regnum >= 0);
a228 2
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

a303 2
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

a1192 5
  /* The calling convention this function implements assumes the
     processor has floating-point registers.  We shouldn't be using it
     on PPC variants that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

a1418 5
  /* The calling convention this function implements assumes the
     processor has floating-point registers.  We shouldn't be using it
     on PPC variants that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

a1729 3
    /* FIXME: jimb/2004-05-05: What should we do when the debug info
       specifies registers the architecture doesn't have?  Our
       callers don't check the value we return.  */
a1767 5
  /* The calling convention this function implements assumes the
     processor has floating-point registers.  We shouldn't be using it
     on PPC variants that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

d2448 5
a2452 11

      /* If skip_prologue says floating-point registers were saved,
         but the current architecture has no floating-point registers,
         then that's strange.  But we have no indices to even record
         the addresses under, so we just ignore it.  */
      if (ppc_floating_point_unit_p (gdbarch))
        for (i = fdata.saved_fpr; i < 32; i++)
          {
            cache->saved_regs[tdep->ppc_fp0_regnum + i].addr = fpr_addr;
            fpr_addr += 8;
          }
a2765 2
        tdep->ppc_fp0_regnum = -1;
        tdep->ppc_fpscr_regnum = -1;
@


1.199
log
@* rs6000-tdep.c (ppc_collect_gregset): When regnum == -1, do
collect all the gprs.
@
text
@d143 3
a145 1
/* Use the architectures FP registers?  */
d149 4
a152 6
  const struct bfd_arch_info *info = gdbarch_bfd_arch_info (gdbarch);
  if (info->arch == bfd_arch_powerpc)
    return (info->mach != bfd_mach_ppc_e500);
  if (info->arch == bfd_arch_rs6000)
    return 1;
  return 0;
d229 2
d306 2
d1197 5
d1428 5
d1744 3
d1785 5
d2470 11
a2480 5
      for (i = fdata.saved_fpr; i < 32; i++)
	{
	  cache->saved_regs[tdep->ppc_fp0_regnum + i].addr = fpr_addr;
	  fpr_addr += 8;
	}
d2794 2
@


1.198
log
@* rs6000-tdep.c (ppc_collect_gregset): Correct off-by-one error in
loop collecting gprs.
@
text
@d263 1
a263 1
	ppc_collect_reg (regcache, regnum, gregs, offset);
@


1.197
log
@2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c (call_function_by_hand): When no
	DEPRECATED_SAVE_DUMMY_FRAME_TOS call generic_save_dummy_frame_tos.
	* rs6000-tdep.c (rs6000_gdbarch_init): Do not set
	DEPRECATED_SAVE_DUMMY_FRAME_TOS.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
@
text
@d260 1
a260 1
  for (i = 0; i <= 32; i++, offset += 4)
@


1.196
log
@* config/rs6000/tm-rs6000.h (FP0_REGNUM): Document that this
should no longer be used in code specific to the RS6000 and its
derivatives.
* ppc-tdep.h (struct gdbarch_tdep): Add 'ppc_fp0_regnum' member.
* rs6000-tdep.c (rs6000_gdbarch_init): Initialize
tdep->ppc_fp0_regnum.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_dwarf2_stab_reg_to_regnum, rs6000_store_return_value)
(rs6000_frame_cache): Use tdep->ppc_fp0_regnum instead of
FP0_REGNUM.
* aix-thread.c (supply_fprs, fetch_regs_kernel_thread)
(fill_gprs64, fill_gprs32, fill_fprs, store_regs_kernel_thread):
Same.
* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_fetch_registers,
bdm_ppc_store_registers): Same.
* ppc-linux-nat.c (ppc_register_u_addr, fetch_register)
(store_register, fill_fpregset): Same.
* ppc-linux-tdep.c (ppc_linux_sigtramp_cache)
(ppc_linux_supply_fpregset): Same.
* ppcnbsd-nat.c (getfpregs_supplies): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg):
Same.
* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
ppc64_sysv_abi_return_value): Same.
* rs6000-nat.c (regmap, fetch_inferior_registers)
(store_inferior_registers, fetch_core_registers): Same.
@
text
@a2906 1
      set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
@


1.195
log
@* config/ppc-tdep.h (struct gdbarch_tdep): Delete
'ppc_gplast_regnum' member.
(ppc_num_gprs): New enum constant.
* ppc-linux-nat.c (ppc_register_u_addr): Use tdep->ppc_gp0_regnum
and ppc_num_gprs instead of tdep->ppc_gplast_regnum.
* rs6000-nat.c (regmap, fetch_inferior_registers,
store_inferior_registers): Same.
* rs6000-tdep.c (e500_pseudo_register_read)
(e500_pseudo_register_write): Same.
(rs6000_gdbarch_init): Don't initialize tdep->ppc_gplast_regnum.
@
text
@d230 3
a232 1
  for (i = FP0_REGNUM; i < FP0_REGNUM + 32; i++, offset += 4)
d305 3
a307 1
  for (i = FP0_REGNUM; i <= FP0_REGNUM + 32; i++, offset += 4)
d1246 2
a1247 1
	  memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1360 3
a1362 1
	      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1427 1
a1427 1
                                      (FP0_REGNUM + 1)],
d1730 1
a1730 1
    return FP0_REGNUM + (num - 32);
d1774 4
a1777 2
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1), valbuf,
				     TYPE_LENGTH (type));
d2450 1
a2450 1
	  cache->saved_regs[FP0_REGNUM + i].addr = fpr_addr;
d2725 1
@


1.194
log
@	* rs6000-tdep.c (rs6000_extract_return_value): When extracting a float,
	use convert_typed_floating to get the appropriate format.
@
text
@d1672 1
a1672 1
      && reg_nr <= tdep->ppc_gplast_regnum)
d1695 1
a1695 1
      && reg_nr <= tdep->ppc_gplast_regnum)
a2703 1
  tdep->ppc_gplast_regnum = 31;
a2747 1
        tdep->ppc_gplast_regnum = tdep->ppc_gp0_regnum + 32 - 1;
@


1.193
log
@Add OpenBSD/powerpc support.
* NEWS (New native configurations): Mention OpenBSD/powerpc.
* ppc-tdep.h (struct ppc_reg_offsets): New structure.
(ppc_supply_gregset, ppc_supply_fpregset, ppc_collect_gregset)
(ppc_collect_fpregset): New prototypes.
* ppcobsd-nat.c: New file.
* ppcobsd-tdep.c: New file.
* ppcobsd-tdep.h: New file.
* rs6000-tdep.c: Include "regset.h".
(ppc_supply_reg, ppc_collect_reg, ppc_supply_gregset)
(ppc_supply_fpregset, ppc_collect_gregset, ppc_collect_fpregset):
New functions.
* Makefile.in (ALLDEPFILES): Add pccobsd-nat.c and ppcobsd-tdep.c.
(ppcobsd-nat.o, ppcobsd-tdep.o): New dependencies.
(rs6000-tdep.o): Update dependencies.
* configure.host: Add powerpc-*-openbsd.
* configure.tgt: Add powerpc-*-openbsd.
* config/powerpc/obsd.mh: New file.
* config/powerpc/nm-obsd.h: New file.
* config/powerpc/obsd.mt: New file.
@
text
@a1414 2
      double dd;
      float ff;
d1419 5
a1423 10
      if (TYPE_LENGTH (valtype) > 4)	/* this is a double */
	memcpy (valbuf,
		&regbuf[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1)],
		TYPE_LENGTH (valtype));
      else
	{			/* float */
	  memcpy (&dd, &regbuf[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1)], 8);
	  ff = (float) dd;
	  memcpy (valbuf, &ff, sizeof (float));
	}
@


1.192
log
@* rs6000-tdep.c (registers_e500, registers_7400): Doc fixes.
@
text
@d34 1
d154 160
@


1.191
log
@* rs6000-tdep.c (rs6000_dwarf2_stab_reg_to_regnum): New, unified
function for register numbers on all the rs6000-derived targets.
(rs6000_gdbarch_init): Don't register a separate
gdbarch_dwarf2_reg_to_regnum function for the E500.  Use
rs6000_dwarf2_stab_reg_to_regnum for both Dwarf 2 and stabs on all
variants.
@
text
@d2001 1
a2001 1
  /* ctr, xre, lr, cr */
d2022 1
a2022 1
  /* 39...70 */
@


1.190
log
@* rs6000-tdep.c (skip_prologue): Recognize moves from argument
registers to temp register r0 and byte stores as prologue
instructions.
@
text
@d1559 2
a1560 1
/* Convert a dwarf2 register number to a gdb REGNUM.  */
d1562 1
a1562 1
e500_dwarf2_reg_to_regnum (int num)
d1564 2
a1565 1
  int regnum;
d1567 30
a1596 4
    return num + gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum;
  else 
    return num;
}
d1598 2
a1599 25
/* Convert a dbx stab register number (from `r' declaration) to a gdb
   REGNUM.  */
static int
rs6000_stab_reg_to_regnum (int num)
{
  int regnum;
  switch (num)
    {
    case 64: 
      regnum = gdbarch_tdep (current_gdbarch)->ppc_mq_regnum;
      break;
    case 65: 
      regnum = gdbarch_tdep (current_gdbarch)->ppc_lr_regnum;
      break;
    case 66: 
      regnum = gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum;
      break;
    case 76: 
      regnum = gdbarch_tdep (current_gdbarch)->ppc_xer_regnum;
      break;
    default: 
      regnum = num;
      break;
    }
  return regnum;
a2606 1
        set_gdbarch_dwarf2_reg_to_regnum (gdbarch, e500_dwarf2_reg_to_regnum);
d2681 2
a2682 1
  set_gdbarch_stab_reg_to_regnum (gdbarch, rs6000_stab_reg_to_regnum);
@


1.189
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (frame_get_saved_regs): Delete unused function.
@
text
@d703 8
d720 5
a724 4
	       ((op & 0xfc1f0000) == 0x901f0000 ||	/* st rx,NUM(r1) */
		(op & 0xfc1f0000) == 0xd81f0000 ||	/* stfd Rx,NUM(r1) */
		(op & 0xfc1f0000) == 0xfc1f0000))
	{			/* frsp, fp?,NUM(r1) */
@


1.188
log
@2004-03-22  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (frame_initial_stack_address): Delete unused
	function.
@
text
@a129 2
static void frame_get_saved_regs (struct frame_info * fi,
				  struct rs6000_framedata * fdatap);
a1372 122
}

/* If saved registers of frame FI are not known yet, read and cache them.
   &FDATAP contains rs6000_framedata; TDATAP can be NULL,
   in which case the framedata are read.  */

static void
frame_get_saved_regs (struct frame_info *fi, struct rs6000_framedata *fdatap)
{
  CORE_ADDR frame_addr;
  struct rs6000_framedata work_fdata;
  struct gdbarch_tdep * tdep = gdbarch_tdep (current_gdbarch);
  int wordsize = tdep->wordsize;

  if (deprecated_get_frame_saved_regs (fi))
    return;

  if (fdatap == NULL)
    {
      fdatap = &work_fdata;
      (void) skip_prologue (get_frame_func (fi), get_frame_pc (fi), fdatap);
    }

  frame_saved_regs_zalloc (fi);

  /* If there were any saved registers, figure out parent's stack
     pointer.  */
  /* The following is true only if the frame doesn't have a call to
     alloca(), FIXME.  */

  if (fdatap->saved_fpr == 0
      && fdatap->saved_gpr == 0
      && fdatap->saved_vr == 0
      && fdatap->saved_ev == 0
      && fdatap->lr_offset == 0
      && fdatap->cr_offset == 0
      && fdatap->vr_offset == 0
      && fdatap->ev_offset == 0)
    frame_addr = 0;
  else
    /* NOTE: cagney/2002-04-14: The ->frame points to the inner-most
       address of the current frame.  Things might be easier if the
       ->frame pointed to the outer-most address of the frame.  In the
       mean time, the address of the prev frame is used as the base
       address of this frame.  */
    frame_addr = DEPRECATED_FRAME_CHAIN (fi);

  /* if != -1, fdatap->saved_fpr is the smallest number of saved_fpr.
     All fpr's from saved_fpr to fp31 are saved.  */

  if (fdatap->saved_fpr >= 0)
    {
      int i;
      CORE_ADDR fpr_addr = frame_addr + fdatap->fpr_offset;
      for (i = fdatap->saved_fpr; i < 32; i++)
	{
	  deprecated_get_frame_saved_regs (fi)[FP0_REGNUM + i] = fpr_addr;
	  fpr_addr += 8;
	}
    }

  /* if != -1, fdatap->saved_gpr is the smallest number of saved_gpr.
     All gpr's from saved_gpr to gpr31 are saved.  */

  if (fdatap->saved_gpr >= 0)
    {
      int i;
      CORE_ADDR gpr_addr = frame_addr + fdatap->gpr_offset;
      for (i = fdatap->saved_gpr; i < 32; i++)
	{
	  deprecated_get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = gpr_addr;
	  gpr_addr += wordsize;
	}
    }

  /* if != -1, fdatap->saved_vr is the smallest number of saved_vr.
     All vr's from saved_vr to vr31 are saved.  */
  if (tdep->ppc_vr0_regnum != -1 && tdep->ppc_vrsave_regnum != -1)
    {
      if (fdatap->saved_vr >= 0)
	{
	  int i;
	  CORE_ADDR vr_addr = frame_addr + fdatap->vr_offset;
	  for (i = fdatap->saved_vr; i < 32; i++)
	    {
	      deprecated_get_frame_saved_regs (fi)[tdep->ppc_vr0_regnum + i] = vr_addr;
	      vr_addr += DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
	    }
	}
    }

  /* if != -1, fdatap->saved_ev is the smallest number of saved_ev.
	All vr's from saved_ev to ev31 are saved. ?????	*/
  if (tdep->ppc_ev0_regnum != -1 && tdep->ppc_ev31_regnum != -1)
    {
      if (fdatap->saved_ev >= 0)
	{
	  int i;
	  CORE_ADDR ev_addr = frame_addr + fdatap->ev_offset;
	  for (i = fdatap->saved_ev; i < 32; i++)
	    {
	      deprecated_get_frame_saved_regs (fi)[tdep->ppc_ev0_regnum + i] = ev_addr;
              deprecated_get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = ev_addr + 4;
	      ev_addr += DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_ev0_regnum);
            }
	}
    }

  /* If != 0, fdatap->cr_offset is the offset from the frame that holds
     the CR.  */
  if (fdatap->cr_offset != 0)
    deprecated_get_frame_saved_regs (fi)[tdep->ppc_cr_regnum] = frame_addr + fdatap->cr_offset;

  /* If != 0, fdatap->lr_offset is the offset from the frame that holds
     the LR.  */
  if (fdatap->lr_offset != 0)
    deprecated_get_frame_saved_regs (fi)[tdep->ppc_lr_regnum] = frame_addr + fdatap->lr_offset;

  /* If != 0, fdatap->vrsave_offset is the offset from the frame that holds
     the VRSAVE.  */
  if (fdatap->vrsave_offset != 0)
    deprecated_get_frame_saved_regs (fi)[tdep->ppc_vrsave_regnum] = frame_addr + fdatap->vrsave_offset;
@


1.187
log
@Remove old frame code.  Enable new frame code for AIX.
@
text
@a131 1
static CORE_ADDR frame_initial_stack_address (struct frame_info *);
a1496 55
}

/* Return the address of a frame. This is the inital %sp value when the frame
   was first allocated.  For functions calling alloca(), it might be saved in
   an alloca register.  */

static CORE_ADDR
frame_initial_stack_address (struct frame_info *fi)
{
  CORE_ADDR tmpaddr;
  struct rs6000_framedata fdata;
  struct frame_info *callee_fi;

  /* If the initial stack pointer (frame address) of this frame is known,
     just return it.  */

  if (get_frame_extra_info (fi)->initial_sp)
    return get_frame_extra_info (fi)->initial_sp;

  /* Find out if this function is using an alloca register.  */

  (void) skip_prologue (get_frame_func (fi), get_frame_pc (fi), &fdata);

  /* If saved registers of this frame are not known yet, read and
     cache them.  */

  if (!deprecated_get_frame_saved_regs (fi))
    frame_get_saved_regs (fi, &fdata);

  /* If no alloca register used, then fi->frame is the value of the %sp for
     this frame, and it is good enough.  */

  if (fdata.alloca_reg < 0)
    {
      get_frame_extra_info (fi)->initial_sp = get_frame_base (fi);
      return get_frame_extra_info (fi)->initial_sp;
    }

  /* There is an alloca register, use its value, in the current frame,
     as the initial stack pointer.  */
  {
    char tmpbuf[MAX_REGISTER_SIZE];
    if (frame_register_read (fi, fdata.alloca_reg, tmpbuf))
      {
	get_frame_extra_info (fi)->initial_sp
	  = extract_unsigned_integer (tmpbuf,
				      DEPRECATED_REGISTER_RAW_SIZE (fdata.alloca_reg));
      }
    else
      /* NOTE: cagney/2002-04-17: At present the only time
         frame_register_read will fail is when the register isn't
         available.  If that does happen, use the frame.  */
      get_frame_extra_info (fi)->initial_sp = get_frame_base (fi);
  }
  return get_frame_extra_info (fi)->initial_sp;
@


1.186
log
@Commit Andrew Cagney's rs6000 / PPC framification patch.
@
text
@a185 62
void
rs6000_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  struct frame_extra_info *extra_info =
    frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
  extra_info->initial_sp = 0;
  if (get_next_frame (fi) != NULL
      && get_frame_pc (fi) < TEXT_SEGMENT_BASE)
    /* We're in get_prev_frame */
    /* and this is a special signal frame.  */
    /* (fi->pc will be some low address in the kernel, */
    /*  to which the signal handler returns).  */
    deprecated_set_frame_type (fi, SIGTRAMP_FRAME);
}

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */

/* In this implementation for RS/6000, we do *not* save sp. I am
   not sure if it will be needed. The following function takes care of gpr's
   and fpr's only. */

void
rs6000_frame_init_saved_regs (struct frame_info *fi)
{
  frame_get_saved_regs (fi, NULL);
}

static CORE_ADDR
rs6000_init_frame_pc_first (int fromleaf, struct frame_info *prev)
{
  return (fromleaf
	  ? DEPRECATED_SAVED_PC_AFTER_CALL (get_next_frame (prev))
	  : frame_relative_level (prev) > 0
	  ? DEPRECATED_FRAME_SAVED_PC (get_next_frame (prev))
	  : read_pc ());
}

static CORE_ADDR
rs6000_frame_args_address (struct frame_info *fi)
{
  struct frame_extra_info *extra_info = get_frame_extra_info (fi);
  if (extra_info->initial_sp != 0)
    return extra_info->initial_sp;
  else
    return frame_initial_stack_address (fi);
}

/* Immediately after a function call, return the saved pc.
   Can't go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */

static CORE_ADDR
rs6000_saved_pc_after_call (struct frame_info *fi)
{
  return read_register (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum);
}

a978 73
/* Pop the innermost frame, go back to the caller.  */

static void
rs6000_pop_frame (void)
{
  CORE_ADDR pc, lr, sp, prev_sp, addr;	/* %pc, %lr, %sp */
  struct rs6000_framedata fdata;
  struct frame_info *frame = get_current_frame ();
  int ii, wordsize;

  pc = read_pc ();
  sp = get_frame_base (frame);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    {
      generic_pop_dummy_frame ();
      flush_cached_frames ();
      return;
    }

  /* Make sure that all registers are valid.  */
  deprecated_read_register_bytes (0, NULL, DEPRECATED_REGISTER_BYTES);

  /* Figure out previous %pc value.  If the function is frameless, it is 
     still in the link register, otherwise walk the frames and retrieve the
     saved %pc value in the previous frame.  */

  addr = get_frame_func (frame);
  (void) skip_prologue (addr, get_frame_pc (frame), &fdata);

  wordsize = gdbarch_tdep (current_gdbarch)->wordsize;
  if (fdata.frameless)
    prev_sp = sp;
  else
    prev_sp = read_memory_addr (sp, wordsize);
  if (fdata.lr_offset == 0)
     lr = read_register (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum);
  else
    lr = read_memory_addr (prev_sp + fdata.lr_offset, wordsize);

  /* reset %pc value. */
  write_register (PC_REGNUM, lr);

  /* reset register values if any was saved earlier.  */

  if (fdata.saved_gpr != -1)
    {
      addr = prev_sp + fdata.gpr_offset;
      for (ii = fdata.saved_gpr; ii <= 31; ++ii)
	{
	  read_memory (addr, &deprecated_registers[DEPRECATED_REGISTER_BYTE (ii)],
		       wordsize);
	  addr += wordsize;
	}
    }

  if (fdata.saved_fpr != -1)
    {
      addr = prev_sp + fdata.fpr_offset;
      for (ii = fdata.saved_fpr; ii <= 31; ++ii)
	{
	  read_memory (addr, &deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + FP0_REGNUM)], 8);
	  addr += 8;
	}
    }

  write_register (SP_REGNUM, prev_sp);
  target_store_registers (-1);
  flush_cached_frames ();
}

a1377 93
/* Determines whether the function FI has a frame on the stack or not.  */

int
rs6000_frameless_function_invocation (struct frame_info *fi)
{
  CORE_ADDR func_start;
  struct rs6000_framedata fdata;

  /* Don't even think about framelessness except on the innermost frame
     or if the function was interrupted by a signal.  */
  if (get_next_frame (fi) != NULL
      && !(get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
    return 0;

  func_start = get_frame_func (fi);

  /* If we failed to find the start of the function, it is a mistake
     to inspect the instructions.  */

  if (!func_start)
    {
      /* A frame with a zero PC is usually created by dereferencing a NULL
         function pointer, normally causing an immediate core dump of the
         inferior.  Mark function as frameless, as the inferior has no chance
         of setting up a stack frame.  */
      if (get_frame_pc (fi) == 0)
	return 1;
      else
	return 0;
    }

  (void) skip_prologue (func_start, get_frame_pc (fi), &fdata);
  return fdata.frameless;
}

/* Return the PC saved in a frame.  */

CORE_ADDR
rs6000_frame_saved_pc (struct frame_info *fi)
{
  CORE_ADDR func_start;
  struct rs6000_framedata fdata;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  int wordsize = tdep->wordsize;

  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
    return read_memory_addr (get_frame_base (fi) + SIG_FRAME_PC_OFFSET,
			     wordsize);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi),
				   get_frame_base (fi),
				   get_frame_base (fi)))
    return deprecated_read_register_dummy (get_frame_pc (fi),
					   get_frame_base (fi), PC_REGNUM);

  func_start = get_frame_func (fi);

  /* If we failed to find the start of the function, it is a mistake
     to inspect the instructions.  */
  if (!func_start)
    return 0;

  (void) skip_prologue (func_start, get_frame_pc (fi), &fdata);

  if (fdata.lr_offset == 0 && get_next_frame (fi) != NULL)
    {
      if ((get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
	return read_memory_addr ((get_frame_base (get_next_frame (fi))
				  + SIG_FRAME_LR_OFFSET),
				 wordsize);
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (fi)), 0, 0))
	/* The link register wasn't saved by this frame and the next
           (inner, newer) frame is a dummy.  Get the link register
           value by unwinding it from that [dummy] frame.  */
	{
	  ULONGEST lr;
	  frame_unwind_unsigned_register (get_next_frame (fi),
					  tdep->ppc_lr_regnum, &lr);
	  return lr;
	}
      else
	return read_memory_addr (DEPRECATED_FRAME_CHAIN (fi)
				 + tdep->lr_frame_offset,
				 wordsize);
    }

  if (fdata.lr_offset == 0)
    return read_register (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum);

  return read_memory_addr (DEPRECATED_FRAME_CHAIN (fi) + fdata.lr_offset,
			   wordsize);
}

a1554 41
/* Describe the pointer in each stack frame to the previous stack frame
   (its caller).  */

/* DEPRECATED_FRAME_CHAIN takes a frame's nominal address and produces
   the frame's chain-pointer.  */

/* In the case of the RS/6000, the frame's nominal address
   is the address of a 4-byte word containing the calling frame's address.  */

CORE_ADDR
rs6000_frame_chain (struct frame_info *thisframe)
{
  CORE_ADDR fp, fpp, lr;
  int wordsize = gdbarch_tdep (current_gdbarch)->wordsize;

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (thisframe),
				   get_frame_base (thisframe),
				   get_frame_base (thisframe)))
    /* A dummy frame always correctly chains back to the previous
       frame.  */
    return read_memory_addr (get_frame_base (thisframe), wordsize);

  if (deprecated_inside_entry_file (get_frame_pc (thisframe))
      || get_frame_pc (thisframe) == entry_point_address ())
    return 0;

  if ((get_frame_type (thisframe) == SIGTRAMP_FRAME))
    fp = read_memory_addr (get_frame_base (thisframe) + SIG_FRAME_FP_OFFSET,
			   wordsize);
  else if (get_next_frame (thisframe) != NULL
	   && (get_frame_type (get_next_frame (thisframe)) == SIGTRAMP_FRAME)
	   && (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION_P ()
	       && DEPRECATED_FRAMELESS_FUNCTION_INVOCATION (thisframe)))
    /* A frameless function interrupted by a signal did not change the
       frame pointer.  */
    fp = get_frame_base (thisframe);
  else
    fp = read_memory_addr (get_frame_base (thisframe), wordsize);
  return fp;
}

d2913 5
a2917 10
      set_gdbarch_deprecated_pop_frame (gdbarch, rs6000_pop_frame);
      set_gdbarch_deprecated_frame_args_address (gdbarch, rs6000_frame_args_address);
      set_gdbarch_deprecated_frame_locals_address (gdbarch, rs6000_frame_args_address);
      set_gdbarch_deprecated_saved_pc_after_call (gdbarch, rs6000_saved_pc_after_call);
      set_gdbarch_deprecated_frameless_function_invocation (gdbarch, rs6000_frameless_function_invocation);
      set_gdbarch_deprecated_frame_chain (gdbarch, rs6000_frame_chain);
      set_gdbarch_deprecated_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
      set_gdbarch_deprecated_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);
      set_gdbarch_deprecated_init_frame_pc_first (gdbarch, rs6000_init_frame_pc_first);
@


1.185
log
@2004-03-18  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (skip_prologue): Record only the first LR save.
@
text
@d53 4
d2646 215
a3112 2
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
a3132 1
  set_gdbarch_deprecated_pop_frame (gdbarch, rs6000_pop_frame);
a3153 8
  set_gdbarch_deprecated_frameless_function_invocation (gdbarch, rs6000_frameless_function_invocation);
  set_gdbarch_deprecated_frame_chain (gdbarch, rs6000_frame_chain);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);

  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch, rs6000_init_frame_pc_first);

a3160 3
  set_gdbarch_deprecated_frame_args_address (gdbarch, rs6000_frame_args_address);
  set_gdbarch_deprecated_frame_locals_address (gdbarch, rs6000_frame_args_address);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, rs6000_saved_pc_after_call);
d3167 26
@


1.184
log
@2004-03-15  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_register_virtual_type): Make registers
	unsigned.
@
text
@d554 19
a572 1
	  lr_reg = (op & 0x03e00000);
a573 1

@


1.183
log
@2004-03-01  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_init_frame_pc_first): Fix compiler error,
	use frame_relative_level and get_next_frame.
@
text
@d1865 1
a1865 1
	  return builtin_type_int32;
d1870 1
a1870 1
	    return builtin_type_int64;
@


1.183.2.1
log
@Jumbo patch.  Experiments with tramp-frame.
@
text
@a52 4
#include "trad-frame.h"
#include "frame-unwind.h"
#include "frame-base.h"

a67 1
    CORE_ADDR func_start;	/* true function start */
a504 1
  int num_skip_syscall_insn = 0;
a523 1
  fdata->func_start = pc;
a551 38
      /* A PPC64 GNU/Linux system call function starts with a
	 non-threaded fast-path, only when that fails is a stack frame
	 created, treat it as several functions:

	 *INDENT-OFF*
	 NAME:
	 	SINGLE_THREAD_P
	 	bne- .Lpseudo_cancel
	 __NAME_nocancel:
	 	li r0,162
	 	sc
	 	bnslr+
	 	b 0x7fe014ef64 <.__syscall_error>
	 Lpseudo_cancel:
	 	stdu r1,-128(r1)
	 	...
	 *INDENT-ON* */
      if (((op & 0xffff0000) == 0x38000000 /* li r0,N */
	   && pc == fdata->func + 0)
	  || (op == 0x44000002 /* sc */
	      && pc == fdata->func + 4
	      && num_skip_syscall_insn == 1)
	  || (op == 0x4ca30020 /* bnslr+ */
	      && pc == fdata->func + 8
	      && num_skip_syscall_insn == 2))
	{
	  num_skip_syscall_insn++;
	  continue;
	}
      else if ((op & 0xfc000003) == 0x48000000 /* b __syscall_error */
	       && pc == fdata->func + 12
	       && num_skip_syscall_insn == 3)
	{
	  num_skip_syscall_insn++;
	  fdata->func_start = pc;
	  continue;
	}

d554 1
a554 19
	  /* Since shared library / PIC code, which needs to get its
	     address at runtime, can appear to save more than one link
	     register vis:

	     *INDENT-OFF*
	     stwu r1,-304(r1)
	     mflr r3
	     bl 0xff570d0 (blrl)
	     stw r30,296(r1)
	     mflr r30
	     stw r31,300(r1)
	     stw r3,308(r1);
	     ...
	     *INDENT-ON*

	     remember just the first one, but skip over additional
	     ones.  */
	  if (lr_reg < 0)
	    lr_reg = (op & 0x03e00000);
d1865 1
a1865 1
	  return builtin_type_uint32;
d1870 1
a1870 1
	    return builtin_type_uint64;
a2624 158
static CORE_ADDR
rs6000_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, PC_REGNUM);
}

static struct frame_id
rs6000_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (frame_unwind_register_unsigned (next_frame,
							 SP_REGNUM),
			 frame_pc_unwind (next_frame));
}

static void
rs6000_trad_frame_init (const struct trad_frame *self,
			struct frame_info *next_frame,
			struct trad_frame_cache *this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  struct rs6000_framedata fdata;
  CORE_ADDR base;
  int wordsize = tdep->wordsize;

  skip_prologue (frame_unwind_func_by_symtab (next_frame),
		 frame_pc_unwind (next_frame), &fdata);

  /* If there were any saved registers, figure out parent's stack
     pointer.  */
  /* The following is true only if the frame doesn't have a call to
     alloca(), FIXME.  */

  if (fdata.saved_fpr == 0
      && fdata.saved_gpr == 0
      && fdata.saved_vr == 0
      && fdata.saved_ev == 0
      && fdata.lr_offset == 0
      && fdata.cr_offset == 0
      && fdata.vr_offset == 0
      && fdata.ev_offset == 0)
    base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
  else
    {
      /* NOTE: cagney/2002-04-14: The ->frame points to the inner-most
	 address of the current frame.  Things might be easier if the
	 ->frame pointed to the outer-most address of the frame.  In
	 the mean time, the address of the prev frame is used as the
	 base address of this frame.  */
      base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
      if (!fdata.frameless)
	/* Frameless really means stackless.  */
	base = read_memory_addr (base, wordsize);
    }
  trad_frame_set_value (this_cache, SP_REGNUM, base);

  /* if != -1, fdata.saved_fpr is the smallest number of saved_fpr.
     All fpr's from saved_fpr to fp31 are saved.  */

  if (fdata.saved_fpr >= 0)
    {
      int i;
      CORE_ADDR fpr_addr = base + fdata.fpr_offset;
      for (i = fdata.saved_fpr; i < 32; i++)
	{
	  this_cache->prev_regs[FP0_REGNUM + i].addr = fpr_addr;
	  fpr_addr += 8;
	}
    }

  /* if != -1, fdata.saved_gpr is the smallest number of saved_gpr.
     All gpr's from saved_gpr to gpr31 are saved.  */

  if (fdata.saved_gpr >= 0)
    {
      int i;
      CORE_ADDR gpr_addr = base + fdata.gpr_offset;
      for (i = fdata.saved_gpr; i < 32; i++)
	{
	  this_cache->prev_regs[tdep->ppc_gp0_regnum + i].addr = gpr_addr;
	  gpr_addr += wordsize;
	}
    }

  /* if != -1, fdata.saved_vr is the smallest number of saved_vr.
     All vr's from saved_vr to vr31 are saved.  */
  if (tdep->ppc_vr0_regnum != -1 && tdep->ppc_vrsave_regnum != -1)
    {
      if (fdata.saved_vr >= 0)
	{
	  int i;
	  CORE_ADDR vr_addr = base + fdata.vr_offset;
	  for (i = fdata.saved_vr; i < 32; i++)
	    {
	      this_cache->prev_regs[tdep->ppc_vr0_regnum + i].addr = vr_addr;
	      vr_addr += register_size (gdbarch, tdep->ppc_vr0_regnum);
	    }
	}
    }

  /* if != -1, fdata.saved_ev is the smallest number of saved_ev.
     All vr's from saved_ev to ev31 are saved. ????? */
  if (tdep->ppc_ev0_regnum != -1 && tdep->ppc_ev31_regnum != -1)
    {
      if (fdata.saved_ev >= 0)
	{
	  int i;
	  CORE_ADDR ev_addr = base + fdata.ev_offset;
	  for (i = fdata.saved_ev; i < 32; i++)
	    {
	      this_cache->prev_regs[tdep->ppc_ev0_regnum + i].addr = ev_addr;
              this_cache->prev_regs[tdep->ppc_gp0_regnum + i].addr = ev_addr + 4;
	      ev_addr += register_size (gdbarch, tdep->ppc_ev0_regnum);
            }
	}
    }

  /* If != 0, fdata.cr_offset is the offset from the frame that
     holds the CR.  */
  if (fdata.cr_offset != 0)
    this_cache->prev_regs[tdep->ppc_cr_regnum].addr = base + fdata.cr_offset;

  /* If != 0, fdata.lr_offset is the offset from the frame that
     holds the LR.  */
  if (fdata.lr_offset != 0)
    this_cache->prev_regs[tdep->ppc_lr_regnum].addr = base + fdata.lr_offset;
  /* The PC is found in the link register.  */
  this_cache->prev_regs[PC_REGNUM] = this_cache->prev_regs[tdep->ppc_lr_regnum];

  /* If != 0, fdata.vrsave_offset is the offset from the frame that
     holds the VRSAVE.  */
  if (fdata.vrsave_offset != 0)
    this_cache->prev_regs[tdep->ppc_vrsave_regnum].addr = base + fdata.vrsave_offset;

  if (fdata.alloca_reg < 0)
    /* If no alloca register used, then fi->frame is the value of the
       %sp for this frame, and it is good enough.  */
    this_cache->this_base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
  else
    this_cache->this_base = frame_unwind_register_unsigned (next_frame,
						       fdata.alloca_reg);
  this_cache->this_id = frame_id_build (base, fdata.func);
}

static int
rs6000_trad_frame_sniffer (const struct trad_frame *self,
			   struct frame_info *next_frame)
{
  return 1;
}

struct trad_frame rs6000_trad_frame = {
  NORMAL_FRAME,
  rs6000_trad_frame_sniffer,
  rs6000_trad_frame_init,
};


d2877 2
d2899 1
d2921 8
d2936 3
a2944 25

  switch (info.osabi)
    {
    case GDB_OSABI_NETBSD_AOUT:
    case GDB_OSABI_NETBSD_ELF:
    case GDB_OSABI_UNKNOWN:
    case GDB_OSABI_LINUX:
      set_gdbarch_unwind_pc (gdbarch, rs6000_unwind_pc);
      trad_frame_append (gdbarch, &rs6000_trad_frame);
      set_gdbarch_unwind_dummy_id (gdbarch, rs6000_unwind_dummy_id);
      break;
    default:
      set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
      set_gdbarch_believe_pcc_promotion (gdbarch, 1);
      set_gdbarch_deprecated_pop_frame (gdbarch, rs6000_pop_frame);
      set_gdbarch_deprecated_frame_args_address (gdbarch, rs6000_frame_args_address);
      set_gdbarch_deprecated_frame_locals_address (gdbarch, rs6000_frame_args_address);
      set_gdbarch_deprecated_saved_pc_after_call (gdbarch, rs6000_saved_pc_after_call);
      set_gdbarch_deprecated_frameless_function_invocation (gdbarch, rs6000_frameless_function_invocation);
      set_gdbarch_deprecated_frame_chain (gdbarch, rs6000_frame_chain);
      set_gdbarch_deprecated_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
      set_gdbarch_deprecated_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);
      set_gdbarch_deprecated_init_frame_pc_first (gdbarch, rs6000_init_frame_pc_first);
    }
@


1.183.2.2
log
@Dump of tramp-frame stuff.
@
text
@d72 1
d510 1
d530 1
d559 38
d599 19
a617 1
	  lr_reg = (op & 0x03e00000);
d1928 1
a1928 1
	  return builtin_type_int32;
d1933 1
a1933 1
	    return builtin_type_int64;
d2702 4
a2705 2
static struct trad_frame_cache *
rs6000_frame_cache (struct frame_info *next_frame, void **this_cache)
a2706 1
  struct trad_frame_cache *cache;
d2710 1
a2711 6
  CORE_ADDR base;

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = trad_frame_cache_zalloc (next_frame);
  (*this_cache) = cache;
d2713 2
a2714 2
  skip_prologue (frame_func_unwind (next_frame), frame_pc_unwind (next_frame),
		 &fdata);
d2742 1
a2742 1
  trad_frame_set_reg_value (cache, SP_REGNUM, base);
d2753 1
a2753 1
	  cache->saved_regs[FP0_REGNUM + i].addr = fpr_addr;
d2767 1
a2767 1
	  cache->saved_regs[tdep->ppc_gp0_regnum + i].addr = gpr_addr;
d2782 1
a2782 1
	      cache->saved_regs[tdep->ppc_vr0_regnum + i].addr = vr_addr;
d2798 2
a2799 2
	      cache->saved_regs[tdep->ppc_ev0_regnum + i].addr = ev_addr;
              cache->saved_regs[tdep->ppc_gp0_regnum + i].addr = ev_addr + 4;
d2808 1
a2808 1
    cache->saved_regs[tdep->ppc_cr_regnum].addr = base + fdata.cr_offset;
d2813 1
a2813 1
    cache->saved_regs[tdep->ppc_lr_regnum].addr = base + fdata.lr_offset;
d2815 1
a2815 1
  cache->saved_regs[PC_REGNUM] = cache->saved_regs[tdep->ppc_lr_regnum];
d2820 1
a2820 1
    cache->saved_regs[tdep->ppc_vrsave_regnum].addr = base + fdata.vrsave_offset;
d2825 1
a2825 1
    cache->this_base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d2827 1
a2827 1
    cache->this_base = frame_unwind_register_unsigned (next_frame,
d2829 1
a2829 4

  cache->this_id = frame_id_build (base, frame_func_unwind (next_frame));

  return cache;
d2832 5
a2836 22
static void
rs6000_frame_this_id (const struct frame_unwind *self,
		      struct frame_info *next_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct trad_frame_cache *trad_cache = rs6000_frame_cache (next_frame,
							    this_cache);
  trad_frame_this_id (trad_cache, next_frame, this_id);
}

static void
rs6000_frame_prev_register (const struct frame_unwind *self,
			    struct frame_info *next_frame,
			    void **this_cache,
			    int regnum, int *optimizedp,
			    enum lval_type *lvalp, CORE_ADDR *addrp,
			    int *realnump, void *valuep)
{
  struct trad_frame_cache *trad_cache = rs6000_frame_cache (next_frame,
							    this_cache);
  trad_frame_prev_register (trad_cache, next_frame, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
d2839 1
a2839 2
static const struct frame_unwind rs6000_frame_unwind =
{
d2841 2
a2842 27
  rs6000_frame_this_id,
  rs6000_frame_prev_register
};

static const struct frame_unwind *
rs6000_frame_sniffer (struct frame_info *next_frame)
{
  return &rs6000_frame_unwind;
}



static CORE_ADDR
rs6000_frame_base_address (const struct frame_base *self,
			   struct frame_info *next_frame,
			   void **this_cache)
{
  struct trad_frame_cache *trad_cache = rs6000_frame_cache (next_frame,
							    this_cache);
  return trad_cache->this_base;
}

static const struct frame_base rs6000_frame_base = {
  &rs6000_frame_unwind,
  rs6000_frame_base_address,
  rs6000_frame_base_address,
  rs6000_frame_base_address
a2844 6
static const struct frame_base *
rs6000_frame_base_sniffer (const struct frame_base_sniffer *self,
			   struct frame_info *next_frame)
{
  return &rs6000_frame_base;
}
d3160 1
a3160 1
      frame_unwind_append_sniffer (gdbarch, rs6000_frame_sniffer);
a3161 1
      frame_base_append_sniffer (gdbarch, rs6000_frame_base_sniffer);
@


1.183.2.3
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d186 62
d558 1
a558 19
	  /* Since shared library / PIC code, which needs to get its
	     address at runtime, can appear to save more than one link
	     register vis:

	     *INDENT-OFF*
	     stwu r1,-304(r1)
	     mflr r3
	     bl 0xff570d0 (blrl)
	     stw r30,296(r1)
	     mflr r30
	     stw r31,300(r1)
	     stw r3,308(r1);
	     ...
	     *INDENT-ON*

	     remember just the first one, but skip over additional
	     ones.  */
	  if (lr_reg < 0)
	    lr_reg = (op & 0x03e00000);
d560 1
d1024 73
d1496 93
d1766 41
d1869 1
a1869 1
	  return builtin_type_uint32;
d1874 1
a1874 1
	    return builtin_type_uint64;
d2643 1
a2643 8
struct rs6000_frame_cache
{
  CORE_ADDR base;
  CORE_ADDR initial_sp;
  struct trad_frame_saved_reg *saved_regs;
};

static struct rs6000_frame_cache *
d2646 1
a2646 1
  struct rs6000_frame_cache *cache;
d2651 1
d2655 1
a2655 1
  cache = FRAME_OBSTACK_ZALLOC (struct rs6000_frame_cache);
a2656 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d2674 1
a2674 1
    cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d2682 1
a2682 1
      cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d2685 1
a2685 1
	cache->base = read_memory_addr (cache->base, wordsize);
d2687 1
a2687 1
  trad_frame_set_value (cache->saved_regs, SP_REGNUM, cache->base);
d2695 1
a2695 1
      CORE_ADDR fpr_addr = cache->base + fdata.fpr_offset;
d2709 1
a2709 1
      CORE_ADDR gpr_addr = cache->base + fdata.gpr_offset;
d2724 1
a2724 1
	  CORE_ADDR vr_addr = cache->base + fdata.vr_offset;
d2740 1
a2740 1
	  CORE_ADDR ev_addr = cache->base + fdata.ev_offset;
d2753 1
a2753 1
    cache->saved_regs[tdep->ppc_cr_regnum].addr = cache->base + fdata.cr_offset;
d2758 1
a2758 1
    cache->saved_regs[tdep->ppc_lr_regnum].addr = cache->base + fdata.lr_offset;
d2765 1
a2765 1
    cache->saved_regs[tdep->ppc_vrsave_regnum].addr = cache->base + fdata.vrsave_offset;
d2770 1
a2770 1
    cache->initial_sp = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d2772 4
a2775 2
    cache->initial_sp = frame_unwind_register_unsigned (next_frame,
							fdata.alloca_reg);
d2781 2
a2782 1
rs6000_frame_this_id (struct frame_info *next_frame, void **this_cache,
d2785 3
a2787 3
  struct rs6000_frame_cache *info = rs6000_frame_cache (next_frame,
							this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
d2791 10
a2800 9
rs6000_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
{
  struct rs6000_frame_cache *info = rs6000_frame_cache (next_frame,
							this_cache);
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
d2820 7
a2826 6
rs6000_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
{
  struct rs6000_frame_cache *info = rs6000_frame_cache (next_frame,
							this_cache);
  return info->initial_sp;
d2837 2
a2838 1
rs6000_frame_base_sniffer (struct frame_info *next_frame)
d3164 10
a3173 5

      set_gdbarch_unwind_pc (gdbarch, rs6000_unwind_pc);
      frame_unwind_append_sniffer (gdbarch, rs6000_frame_sniffer);
      set_gdbarch_unwind_dummy_id (gdbarch, rs6000_unwind_dummy_id);
      frame_base_append_sniffer (gdbarch, rs6000_frame_base_sniffer);
@


1.182
log
@2004-02-29  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_init_frame_pc_first): New function.
	(rs6000_gdbarch_init): Set deprecated_init_frame_pc_first.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST):
	Delete macro.
@
text
@d216 5
a220 2
  return (fromleaf ? DEPRECATED_SAVED_PC_AFTER_CALL (prev->next)
	  : prev->next ? DEPRECATED_FRAME_SAVED_PC (prev->next) : read_pc ());
@


1.181
log
@2004-02-17  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c (skip_prologue_using_sal): New function.
	* symtab.h (skip_prologue_using_sal): Declare.
	* frv-tdep.c: Include "symtab.h".
	(skip_prologue_using_sal): Delete function.
	* mips-tdep.c (skip_prologue_using_sal): Delete function.
	* rs6000-tdep.c (refine_prologue_limit): Mention
	skip_prologue_using_sal.
	* ia64-tdep.c (refine_prologue_limit): Ditto.
	* Makefile.in: Update dependencies.
@
text
@d214 7
d2924 1
@


1.181.2.1
log
@Merge mainline to intercu branch.
@
text
@a52 4
#include "trad-frame.h"
#include "frame-unwind.h"
#include "frame-base.h"

d126 3
d182 52
d544 1
a544 19
	  /* Since shared library / PIC code, which needs to get its
	     address at runtime, can appear to save more than one link
	     register vis:

	     *INDENT-OFF*
	     stwu r1,-304(r1)
	     mflr r3
	     bl 0xff570d0 (blrl)
	     stw r30,296(r1)
	     mflr r30
	     stw r31,300(r1)
	     stw r3,308(r1);
	     ...
	     *INDENT-ON*

	     remember just the first one, but skip over additional
	     ones.  */
	  if (lr_reg < 0)
	    lr_reg = (op & 0x03e00000);
d546 1
d1010 73
d1482 311
d1855 1
a1855 1
	  return builtin_type_uint32;
d1860 1
a1860 1
	    return builtin_type_uint64;
a2614 215
static CORE_ADDR
rs6000_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, PC_REGNUM);
}

static struct frame_id
rs6000_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (frame_unwind_register_unsigned (next_frame,
							 SP_REGNUM),
			 frame_pc_unwind (next_frame));
}

struct rs6000_frame_cache
{
  CORE_ADDR base;
  CORE_ADDR initial_sp;
  struct trad_frame_saved_reg *saved_regs;
};

static struct rs6000_frame_cache *
rs6000_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct rs6000_frame_cache *cache;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  struct rs6000_framedata fdata;
  int wordsize = tdep->wordsize;

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct rs6000_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  skip_prologue (frame_func_unwind (next_frame), frame_pc_unwind (next_frame),
		 &fdata);

  /* If there were any saved registers, figure out parent's stack
     pointer.  */
  /* The following is true only if the frame doesn't have a call to
     alloca(), FIXME.  */

  if (fdata.saved_fpr == 0
      && fdata.saved_gpr == 0
      && fdata.saved_vr == 0
      && fdata.saved_ev == 0
      && fdata.lr_offset == 0
      && fdata.cr_offset == 0
      && fdata.vr_offset == 0
      && fdata.ev_offset == 0)
    cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
  else
    {
      /* NOTE: cagney/2002-04-14: The ->frame points to the inner-most
	 address of the current frame.  Things might be easier if the
	 ->frame pointed to the outer-most address of the frame.  In
	 the mean time, the address of the prev frame is used as the
	 base address of this frame.  */
      cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
      if (!fdata.frameless)
	/* Frameless really means stackless.  */
	cache->base = read_memory_addr (cache->base, wordsize);
    }
  trad_frame_set_value (cache->saved_regs, SP_REGNUM, cache->base);

  /* if != -1, fdata.saved_fpr is the smallest number of saved_fpr.
     All fpr's from saved_fpr to fp31 are saved.  */

  if (fdata.saved_fpr >= 0)
    {
      int i;
      CORE_ADDR fpr_addr = cache->base + fdata.fpr_offset;
      for (i = fdata.saved_fpr; i < 32; i++)
	{
	  cache->saved_regs[FP0_REGNUM + i].addr = fpr_addr;
	  fpr_addr += 8;
	}
    }

  /* if != -1, fdata.saved_gpr is the smallest number of saved_gpr.
     All gpr's from saved_gpr to gpr31 are saved.  */

  if (fdata.saved_gpr >= 0)
    {
      int i;
      CORE_ADDR gpr_addr = cache->base + fdata.gpr_offset;
      for (i = fdata.saved_gpr; i < 32; i++)
	{
	  cache->saved_regs[tdep->ppc_gp0_regnum + i].addr = gpr_addr;
	  gpr_addr += wordsize;
	}
    }

  /* if != -1, fdata.saved_vr is the smallest number of saved_vr.
     All vr's from saved_vr to vr31 are saved.  */
  if (tdep->ppc_vr0_regnum != -1 && tdep->ppc_vrsave_regnum != -1)
    {
      if (fdata.saved_vr >= 0)
	{
	  int i;
	  CORE_ADDR vr_addr = cache->base + fdata.vr_offset;
	  for (i = fdata.saved_vr; i < 32; i++)
	    {
	      cache->saved_regs[tdep->ppc_vr0_regnum + i].addr = vr_addr;
	      vr_addr += register_size (gdbarch, tdep->ppc_vr0_regnum);
	    }
	}
    }

  /* if != -1, fdata.saved_ev is the smallest number of saved_ev.
     All vr's from saved_ev to ev31 are saved. ????? */
  if (tdep->ppc_ev0_regnum != -1 && tdep->ppc_ev31_regnum != -1)
    {
      if (fdata.saved_ev >= 0)
	{
	  int i;
	  CORE_ADDR ev_addr = cache->base + fdata.ev_offset;
	  for (i = fdata.saved_ev; i < 32; i++)
	    {
	      cache->saved_regs[tdep->ppc_ev0_regnum + i].addr = ev_addr;
              cache->saved_regs[tdep->ppc_gp0_regnum + i].addr = ev_addr + 4;
	      ev_addr += register_size (gdbarch, tdep->ppc_ev0_regnum);
            }
	}
    }

  /* If != 0, fdata.cr_offset is the offset from the frame that
     holds the CR.  */
  if (fdata.cr_offset != 0)
    cache->saved_regs[tdep->ppc_cr_regnum].addr = cache->base + fdata.cr_offset;

  /* If != 0, fdata.lr_offset is the offset from the frame that
     holds the LR.  */
  if (fdata.lr_offset != 0)
    cache->saved_regs[tdep->ppc_lr_regnum].addr = cache->base + fdata.lr_offset;
  /* The PC is found in the link register.  */
  cache->saved_regs[PC_REGNUM] = cache->saved_regs[tdep->ppc_lr_regnum];

  /* If != 0, fdata.vrsave_offset is the offset from the frame that
     holds the VRSAVE.  */
  if (fdata.vrsave_offset != 0)
    cache->saved_regs[tdep->ppc_vrsave_regnum].addr = cache->base + fdata.vrsave_offset;

  if (fdata.alloca_reg < 0)
    /* If no alloca register used, then fi->frame is the value of the
       %sp for this frame, and it is good enough.  */
    cache->initial_sp = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
  else
    cache->initial_sp = frame_unwind_register_unsigned (next_frame,
							fdata.alloca_reg);

  return cache;
}

static void
rs6000_frame_this_id (struct frame_info *next_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct rs6000_frame_cache *info = rs6000_frame_cache (next_frame,
							this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
}

static void
rs6000_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
{
  struct rs6000_frame_cache *info = rs6000_frame_cache (next_frame,
							this_cache);
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind rs6000_frame_unwind =
{
  NORMAL_FRAME,
  rs6000_frame_this_id,
  rs6000_frame_prev_register
};

static const struct frame_unwind *
rs6000_frame_sniffer (struct frame_info *next_frame)
{
  return &rs6000_frame_unwind;
}



static CORE_ADDR
rs6000_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
{
  struct rs6000_frame_cache *info = rs6000_frame_cache (next_frame,
							this_cache);
  return info->initial_sp;
}

static const struct frame_base rs6000_frame_base = {
  &rs6000_frame_unwind,
  rs6000_frame_base_address,
  rs6000_frame_base_address,
  rs6000_frame_base_address
};

static const struct frame_base *
rs6000_frame_base_sniffer (struct frame_info *next_frame)
{
  return &rs6000_frame_base;
}

d2867 2
d2889 1
d2911 7
d2925 3
a2933 21

  switch (info.osabi)
    {
    case GDB_OSABI_NETBSD_AOUT:
    case GDB_OSABI_NETBSD_ELF:
    case GDB_OSABI_UNKNOWN:
    case GDB_OSABI_LINUX:
      set_gdbarch_unwind_pc (gdbarch, rs6000_unwind_pc);
      frame_unwind_append_sniffer (gdbarch, rs6000_frame_sniffer);
      set_gdbarch_unwind_dummy_id (gdbarch, rs6000_unwind_dummy_id);
      frame_base_append_sniffer (gdbarch, rs6000_frame_base_sniffer);
      break;
    default:
      set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
      set_gdbarch_believe_pcc_promotion (gdbarch, 1);

      set_gdbarch_unwind_pc (gdbarch, rs6000_unwind_pc);
      frame_unwind_append_sniffer (gdbarch, rs6000_frame_sniffer);
      set_gdbarch_unwind_dummy_id (gdbarch, rs6000_unwind_dummy_id);
      frame_base_append_sniffer (gdbarch, rs6000_frame_base_sniffer);
    }
@


1.181.2.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@a702 8
      /* Move parameters from argument registers to temporary register.  */
      else if ((op & 0xfc0007fe) == 0x7c000378 &&	/* mr(.)  Rx,Ry */
               (((op >> 21) & 31) >= 3) &&              /* R3 >= Ry >= R10 */
               (((op >> 21) & 31) <= 10) &&
               (((op >> 16) & 31) == 0)) /* Rx: scratch register r0 */
        {
          continue;
        }
d712 4
a715 5
	       ((op & 0xfc1f0000) == 0x901f0000 ||     /* st rx,NUM(r31) */
                (op & 0xfc1f0000) == 0x981f0000 ||     /* stb Rx,NUM(r31) */
		(op & 0xfc1f0000) == 0xd81f0000 ||     /* stfd Rx,NUM(r31) */
		(op & 0xfc1f0000) == 0xfc1f0000))      /* frsp, fp?,NUM(r31) */
        {
d1550 1
a1550 2
/* Convert a dbx stab or Dwarf 2 register number (from `r'
   declaration) to a gdb REGNUM.  */
d1552 1
a1552 1
rs6000_dwarf2_stab_reg_to_regnum (int num)
d1554 1
a1554 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

d1556 4
a1559 30
    return tdep->ppc_gp0_regnum + num;
  else if (32 <= num && num <= 63)
    return FP0_REGNUM + (num - 32);
  else if (1200 <= num && num < 1200 + 32)
    return tdep->ppc_ev0_regnum + (num - 1200);
  else
    switch (num)
      {
      case 64: 
        return tdep->ppc_mq_regnum;
      case 65:
        return tdep->ppc_lr_regnum;
      case 66: 
        return tdep->ppc_ctr_regnum;
      case 76: 
        return tdep->ppc_xer_regnum;
      case 109:
        return tdep->ppc_vrsave_regnum;
      default: 
        return num;
      }

  /* FIXME: jimb/2004-03-28: Doesn't something need to be done here
     for the Altivec registers, too?

     Looking at GCC, the headers in config/rs6000 never define a
     DBX_REGISTER_NUMBER macro, so the debug info uses the same
     numbers GCC does internally.  Then, looking at the REGISTER_NAMES
     macro defined in config/rs6000/rs6000.h, it seems that GCC gives
     v0 -- v31 the numbers 77 -- 108.  But we number them 119 -- 150.
d1561 25
a1585 2
     I don't have a way to test this ready to hand, but I noticed it
     and thought I should include a note.  */
d2593 1
d2668 1
a2668 2
  set_gdbarch_stab_reg_to_regnum (gdbarch, rs6000_dwarf2_stab_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, rs6000_dwarf2_stab_reg_to_regnum);
@


1.181.2.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a33 1
#include "regset.h"
a37 4
#include "infcall.h"
#include "sim-regno.h"
#include "gdb/sim-ppc.h"
#include "reggroups.h"
a99 3
    int spr_num;                /* PowerPC SPR number, or -1 if not an SPR.
                                   This is an ISA SPR number, not a GDB
                                   register number.  */
d142 1
a142 2

/* Return true if REGNO is an SPE register, false otherwise.  */
d144 1
a144 1
spe_register_p (int regno)
d146 4
a149 6
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  
  /* Is it a reference to EV0 -- EV31, and do we have those?  */
  if (tdep->ppc_ev0_regnum >= 0
      && tdep->ppc_ev31_regnum >= 0
      && tdep->ppc_ev0_regnum <= regno && regno <= tdep->ppc_ev31_regnum)
a150 18

  /* Is it a reference to one of the raw upper GPR halves?  */
  if (tdep->ppc_ev0_upper_regnum >= 0
      && tdep->ppc_ev0_upper_regnum <= regno
      && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    return 1;

  /* Is it a reference to the 64-bit accumulator, and do we have that?  */
  if (tdep->ppc_acc_regnum >= 0
      && tdep->ppc_acc_regnum == regno)
    return 1;

  /* Is it a reference to the SPE floating-point status and control register,
     and do we have that?  */
  if (tdep->ppc_spefscr_regnum >= 0
      && tdep->ppc_spefscr_regnum == regno)
    return 1;

a153 304

/* Return non-zero if the architecture described by GDBARCH has
   floating-point registers (f0 --- f31 and fpscr).  */
int
ppc_floating_point_unit_p (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  return (tdep->ppc_fp0_regnum >= 0
          && tdep->ppc_fpscr_regnum >= 0);
}


/* Check that TABLE[GDB_REGNO] is not already initialized, and then
   set it to SIM_REGNO.

   This is a helper function for init_sim_regno_table, constructing
   the table mapping GDB register numbers to sim register numbers; we
   initialize every element in that table to -1 before we start
   filling it in.  */
static void
set_sim_regno (int *table, int gdb_regno, int sim_regno)
{
  /* Make sure we don't try to assign any given GDB register a sim
     register number more than once.  */
  gdb_assert (table[gdb_regno] == -1);
  table[gdb_regno] = sim_regno;
}


/* Initialize ARCH->tdep->sim_regno, the table mapping GDB register
   numbers to simulator register numbers, based on the values placed
   in the ARCH->tdep->ppc_foo_regnum members.  */
static void
init_sim_regno_table (struct gdbarch *arch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
  int total_regs = gdbarch_num_regs (arch) + gdbarch_num_pseudo_regs (arch);
  const struct reg *regs = tdep->regs;
  int *sim_regno = GDBARCH_OBSTACK_CALLOC (arch, total_regs, int);
  int i;

  /* Presume that all registers not explicitly mentioned below are
     unavailable from the sim.  */
  for (i = 0; i < total_regs; i++)
    sim_regno[i] = -1;

  /* General-purpose registers.  */
  for (i = 0; i < ppc_num_gprs; i++)
    set_sim_regno (sim_regno, tdep->ppc_gp0_regnum + i, sim_ppc_r0_regnum + i);
  
  /* Floating-point registers.  */
  if (tdep->ppc_fp0_regnum >= 0)
    for (i = 0; i < ppc_num_fprs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_fp0_regnum + i,
                     sim_ppc_f0_regnum + i);
  if (tdep->ppc_fpscr_regnum >= 0)
    set_sim_regno (sim_regno, tdep->ppc_fpscr_regnum, sim_ppc_fpscr_regnum);

  set_sim_regno (sim_regno, gdbarch_pc_regnum (arch), sim_ppc_pc_regnum);
  set_sim_regno (sim_regno, tdep->ppc_ps_regnum, sim_ppc_ps_regnum);
  set_sim_regno (sim_regno, tdep->ppc_cr_regnum, sim_ppc_cr_regnum);

  /* Segment registers.  */
  if (tdep->ppc_sr0_regnum >= 0)
    for (i = 0; i < ppc_num_srs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_sr0_regnum + i,
                     sim_ppc_sr0_regnum + i);

  /* Altivec registers.  */
  if (tdep->ppc_vr0_regnum >= 0)
    {
      for (i = 0; i < ppc_num_vrs; i++)
        set_sim_regno (sim_regno,
                       tdep->ppc_vr0_regnum + i,
                       sim_ppc_vr0_regnum + i);

      /* FIXME: jimb/2004-07-15: when we have tdep->ppc_vscr_regnum,
         we can treat this more like the other cases.  */
      set_sim_regno (sim_regno,
                     tdep->ppc_vr0_regnum + ppc_num_vrs,
                     sim_ppc_vscr_regnum);
    }
  /* vsave is a special-purpose register, so the code below handles it.  */

  /* SPE APU (E500) registers.  */
  if (tdep->ppc_ev0_regnum >= 0)
    for (i = 0; i < ppc_num_gprs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_ev0_regnum + i,
                     sim_ppc_ev0_regnum + i);
  if (tdep->ppc_ev0_upper_regnum >= 0)
    for (i = 0; i < ppc_num_gprs; i++)
      set_sim_regno (sim_regno,
                     tdep->ppc_ev0_upper_regnum + i,
                     sim_ppc_rh0_regnum + i);
  if (tdep->ppc_acc_regnum >= 0)
    set_sim_regno (sim_regno, tdep->ppc_acc_regnum, sim_ppc_acc_regnum);
  /* spefscr is a special-purpose register, so the code below handles it.  */

  /* Now handle all special-purpose registers.  Verify that they
     haven't mistakenly been assigned numbers by any of the above
     code).  */
  for (i = 0; i < total_regs; i++)
    if (regs[i].spr_num >= 0)
      set_sim_regno (sim_regno, i, regs[i].spr_num + sim_ppc_spr0_regnum);

  /* Drop the initialized array into place.  */
  tdep->sim_regno = sim_regno;
}


/* Given a GDB register number REG, return the corresponding SIM
   register number.  */
static int
rs6000_register_sim_regno (int reg)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  int sim_regno;

  gdb_assert (0 <= reg && reg <= NUM_REGS + NUM_PSEUDO_REGS);
  sim_regno = tdep->sim_regno[reg];

  if (sim_regno >= 0)
    return sim_regno;
  else
    return LEGACY_SIM_REGNO_IGNORE;
}



/* Register set support functions.  */

static void
ppc_supply_reg (struct regcache *regcache, int regnum, 
		const char *regs, size_t offset)
{
  if (regnum != -1 && offset != -1)
    regcache_raw_supply (regcache, regnum, regs + offset);
}

static void
ppc_collect_reg (const struct regcache *regcache, int regnum,
		 char *regs, size_t offset)
{
  if (regnum != -1 && offset != -1)
    regcache_raw_collect (regcache, regnum, regs + offset);
}
    
/* Supply register REGNUM in the general-purpose register set REGSET
   from the buffer specified by GREGS and LEN to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

void
ppc_supply_gregset (const struct regset *regset, struct regcache *regcache,
		    int regnum, const void *gregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct ppc_reg_offsets *offsets = regset->descr;
  size_t offset;
  int i;

  for (i = tdep->ppc_gp0_regnum, offset = offsets->r0_offset;
       i < tdep->ppc_gp0_regnum + ppc_num_gprs;
       i++, offset += 4)
    {
      if (regnum == -1 || regnum == i)
	ppc_supply_reg (regcache, i, gregs, offset);
    }

  if (regnum == -1 || regnum == PC_REGNUM)
    ppc_supply_reg (regcache, PC_REGNUM, gregs, offsets->pc_offset);
  if (regnum == -1 || regnum == tdep->ppc_ps_regnum)
    ppc_supply_reg (regcache, tdep->ppc_ps_regnum,
		    gregs, offsets->ps_offset);
  if (regnum == -1 || regnum == tdep->ppc_cr_regnum)
    ppc_supply_reg (regcache, tdep->ppc_cr_regnum,
		    gregs, offsets->cr_offset);
  if (regnum == -1 || regnum == tdep->ppc_lr_regnum)
    ppc_supply_reg (regcache, tdep->ppc_lr_regnum,
		    gregs, offsets->lr_offset);
  if (regnum == -1 || regnum == tdep->ppc_ctr_regnum)
    ppc_supply_reg (regcache, tdep->ppc_ctr_regnum,
		    gregs, offsets->ctr_offset);
  if (regnum == -1 || regnum == tdep->ppc_xer_regnum)
    ppc_supply_reg (regcache, tdep->ppc_xer_regnum,
		    gregs, offsets->cr_offset);
  if (regnum == -1 || regnum == tdep->ppc_mq_regnum)
    ppc_supply_reg (regcache, tdep->ppc_mq_regnum, gregs, offsets->mq_offset);
}

/* Supply register REGNUM in the floating-point register set REGSET
   from the buffer specified by FPREGS and LEN to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

void
ppc_supply_fpregset (const struct regset *regset, struct regcache *regcache,
		     int regnum, const void *fpregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct ppc_reg_offsets *offsets = regset->descr;
  size_t offset;
  int i;

  gdb_assert (ppc_floating_point_unit_p (gdbarch));

  offset = offsets->f0_offset;
  for (i = tdep->ppc_fp0_regnum;
       i < tdep->ppc_fp0_regnum + ppc_num_fprs;
       i++, offset += 4)
    {
      if (regnum == -1 || regnum == i)
	ppc_supply_reg (regcache, i, fpregs, offset);
    }

  if (regnum == -1 || regnum == tdep->ppc_fpscr_regnum)
    ppc_supply_reg (regcache, tdep->ppc_fpscr_regnum,
		    fpregs, offsets->fpscr_offset);
}

/* Collect register REGNUM in the general-purpose register set
   REGSET. from register cache REGCACHE into the buffer specified by
   GREGS and LEN.  If REGNUM is -1, do this for all registers in
   REGSET.  */

void
ppc_collect_gregset (const struct regset *regset,
		     const struct regcache *regcache,
		     int regnum, void *gregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct ppc_reg_offsets *offsets = regset->descr;
  size_t offset;
  int i;

  offset = offsets->r0_offset;
  for (i = tdep->ppc_gp0_regnum;
       i < tdep->ppc_gp0_regnum + ppc_num_gprs;
       i++, offset += 4)
    {
      if (regnum == -1 || regnum == i)
	ppc_collect_reg (regcache, i, gregs, offset);
    }

  if (regnum == -1 || regnum == PC_REGNUM)
    ppc_collect_reg (regcache, PC_REGNUM, gregs, offsets->pc_offset);
  if (regnum == -1 || regnum == tdep->ppc_ps_regnum)
    ppc_collect_reg (regcache, tdep->ppc_ps_regnum,
		     gregs, offsets->ps_offset);
  if (regnum == -1 || regnum == tdep->ppc_cr_regnum)
    ppc_collect_reg (regcache, tdep->ppc_cr_regnum,
		     gregs, offsets->cr_offset);
  if (regnum == -1 || regnum == tdep->ppc_lr_regnum)
    ppc_collect_reg (regcache, tdep->ppc_lr_regnum,
		     gregs, offsets->lr_offset);
  if (regnum == -1 || regnum == tdep->ppc_ctr_regnum)
    ppc_collect_reg (regcache, tdep->ppc_ctr_regnum,
		     gregs, offsets->ctr_offset);
  if (regnum == -1 || regnum == tdep->ppc_xer_regnum)
    ppc_collect_reg (regcache, tdep->ppc_xer_regnum,
		     gregs, offsets->xer_offset);
  if (regnum == -1 || regnum == tdep->ppc_mq_regnum)
    ppc_collect_reg (regcache, tdep->ppc_mq_regnum,
		     gregs, offsets->mq_offset);
}

/* Collect register REGNUM in the floating-point register set
   REGSET. from register cache REGCACHE into the buffer specified by
   FPREGS and LEN.  If REGNUM is -1, do this for all registers in
   REGSET.  */

void
ppc_collect_fpregset (const struct regset *regset,
		      const struct regcache *regcache,
		      int regnum, void *fpregs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct ppc_reg_offsets *offsets = regset->descr;
  size_t offset;
  int i;

  gdb_assert (ppc_floating_point_unit_p (gdbarch));

  offset = offsets->f0_offset;
  for (i = tdep->ppc_fp0_regnum;
       i <= tdep->ppc_fp0_regnum + ppc_num_fprs;
       i++, offset += 4)
    {
      if (regnum == -1 || regnum == i)
	ppc_collect_reg (regcache, regnum, fpregs, offset);
    }

  if (regnum == -1 || regnum == tdep->ppc_fpscr_regnum)
    ppc_collect_reg (regcache, tdep->ppc_fpscr_regnum,
		     fpregs, offsets->fpscr_offset);
}


a421 70
/* Return nonzero if the given instruction OP can be part of the prologue
   of a function and saves a parameter on the stack.  FRAMEP should be
   set if one of the previous instructions in the function has set the
   Frame Pointer.  */

static int
store_param_on_stack_p (unsigned long op, int framep, int *r0_contains_arg)
{
  /* Move parameters from argument registers to temporary register.  */
  if ((op & 0xfc0007fe) == 0x7c000378)         /* mr(.)  Rx,Ry */
    {
      /* Rx must be scratch register r0.  */
      const int rx_regno = (op >> 16) & 31;
      /* Ry: Only r3 - r10 are used for parameter passing.  */
      const int ry_regno = GET_SRC_REG (op);

      if (rx_regno == 0 && ry_regno >= 3 && ry_regno <= 10)
        {
          *r0_contains_arg = 1;
          return 1;
        }
      else
        return 0;
    }

  /* Save a General Purpose Register on stack.  */

  if ((op & 0xfc1f0003) == 0xf8010000 ||       /* std  Rx,NUM(r1) */
      (op & 0xfc1f0000) == 0xd8010000)         /* stfd Rx,NUM(r1) */
    {
      /* Rx: Only r3 - r10 are used for parameter passing.  */
      const int rx_regno = GET_SRC_REG (op);

      return (rx_regno >= 3 && rx_regno <= 10);
    }
           
  /* Save a General Purpose Register on stack via the Frame Pointer.  */

  if (framep &&
      ((op & 0xfc1f0000) == 0x901f0000 ||     /* st rx,NUM(r31) */
       (op & 0xfc1f0000) == 0x981f0000 ||     /* stb Rx,NUM(r31) */
       (op & 0xfc1f0000) == 0xd81f0000))      /* stfd Rx,NUM(r31) */
    {
      /* Rx: Usually, only r3 - r10 are used for parameter passing.
         However, the compiler sometimes uses r0 to hold an argument.  */
      const int rx_regno = GET_SRC_REG (op);

      return ((rx_regno >= 3 && rx_regno <= 10)
              || (rx_regno == 0 && *r0_contains_arg));
    }

  if ((op & 0xfc1f0000) == 0xfc010000)         /* frsp, fp?,NUM(r1) */
    {
      /* Only f2 - f8 are used for parameter passing.  */
      const int src_regno = GET_SRC_REG (op);

      return (src_regno >= 2 && src_regno <= 8);
    }

  if (framep && ((op & 0xfc1f0000) == 0xfc1f0000))  /* frsp, fp?,NUM(r31) */
    {
      /* Only f2 - f8 are used for parameter passing.  */
      const int src_regno = GET_SRC_REG (op);

      return (src_regno >= 2 && src_regno <= 8);
    }

  /* Not an insn that saves a parameter on stack.  */
  return 0;
}
a443 1
  int r0_contains_arg = 0;
a511 2
          if (lr_reg == 0)
            r0_contains_arg = 0;
a516 2
          if (cr_reg == 0)
            r0_contains_arg = 0;
a562 1
          r0_contains_arg = 0;
a570 1
          r0_contains_arg = 0;
d704 20
a723 1
      else if (store_param_on_stack_p (op, framep, &r0_contains_arg))
a791 2
          if ((op & 0xffff0000) == 0x38000000)
            r0_contains_arg = 0;
a793 5

          /* This insn by itself is not part of the prologue, unless
             if part of the pair of insns mentioned above. So do not
             record this insn as part of the prologue yet.  */
          prev_insn_was_prologue_insn = 0;
d1009 1
a1009 1
rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
a1021 1
  CORE_ADDR func_addr = find_function_addr (function, NULL);
a1027 5
  /* The calling convention this function implements assumes the
     processor has floating-point registers.  We shouldn't be using it
     on PPC variants that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

d1064 1
a1064 1
      int reg_size = register_size (current_gdbarch, ii + 3);
d1078 2
a1079 2
	    printf_unfiltered ("Fatal Error: a floating point parameter "
                               "#%d with a size > 8 is found!\n", argno);
d1081 1
a1081 2
	  memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE
                                        (tdep->ppc_fp0_regnum + 1 + f_argno)],
d1191 2
a1192 2
		printf_unfiltered ("Fatal Error: a floating point parameter"
                                   " #%d with a size > 8 is found!\n", argno);
d1194 1
a1194 3
	      memcpy (&(deprecated_registers
                        [DEPRECATED_REGISTER_BYTE
                         (tdep->ppc_fp0_regnum + 1 + f_argno)]),
d1200 1
a1200 3
	  write_memory (sp + 24 + (ii * 4),
                        (char *) VALUE_CONTENTS (arg),
                        len);
a1250 5
  /* The calling convention this function implements assumes the
     processor has floating-point registers.  We shouldn't be using it
     on PPC variants that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

d1254 2
d1260 10
a1269 5
      convert_typed_floating (&regbuf[DEPRECATED_REGISTER_BYTE
                                      (tdep->ppc_fp0_regnum + 1)],
                              builtin_type_double,
                              valbuf,
                              valtype);
d1282 2
a1283 2
	  && TYPE_LENGTH (valtype) < register_size (current_gdbarch, 3))
	offset = register_size (current_gdbarch, 3) - TYPE_LENGTH (valtype);
d1407 20
d1431 1
a1431 1
rs6000_register_type (struct gdbarch *gdbarch, int n)
d1433 1
a1433 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1463 4
a1466 1
/* The register format for RS/6000 floating point registers is always
d1470 1
a1470 1
rs6000_convert_register_p (int regnum, struct type *type)
d1472 2
a1473 5
  const struct reg *reg = gdbarch_tdep (current_gdbarch)->regs + regnum;
  
  return (reg->fpr
          && TYPE_CODE (type) == TYPE_CODE_FLT
          && TYPE_LENGTH (type) != TYPE_LENGTH (builtin_type_double));
d1476 3
d1480 2
a1481 4
rs6000_register_to_value (struct frame_info *frame,
                          int regnum,
                          struct type *type,
                          void *to)
d1483 8
a1490 5
  const struct reg *reg = gdbarch_tdep (current_gdbarch)->regs + regnum;
  char from[MAX_REGISTER_SIZE];
  
  gdb_assert (reg->fpr);
  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);
d1492 2
a1493 3
  get_frame_register (frame, regnum, from);
  convert_typed_floating (from, builtin_type_double, to, type);
}
d1496 4
a1499 55
rs6000_value_to_register (struct frame_info *frame,
                          int regnum,
                          struct type *type,
                          const void *from)
{
  const struct reg *reg = gdbarch_tdep (current_gdbarch)->regs + regnum;
  char to[MAX_REGISTER_SIZE];

  gdb_assert (reg->fpr);
  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);

  convert_typed_floating (from, type, to, builtin_type_double);
  put_frame_register (frame, regnum, to);
}

/* Move SPE vector register values between a 64-bit buffer and the two
   32-bit raw register halves in a regcache.  This function handles
   both splitting a 64-bit value into two 32-bit halves, and joining
   two halves into a whole 64-bit value, depending on the function
   passed as the MOVE argument.

   EV_REG must be the number of an SPE evN vector register --- a
   pseudoregister.  REGCACHE must be a regcache, and BUFFER must be a
   64-bit buffer.

   Call MOVE once for each 32-bit half of that register, passing
   REGCACHE, the number of the raw register corresponding to that
   half, and the address of the appropriate half of BUFFER.

   For example, passing 'regcache_raw_read' as the MOVE function will
   fill BUFFER with the full 64-bit contents of EV_REG.  Or, passing
   'regcache_raw_supply' will supply the contents of BUFFER to the
   appropriate pair of raw registers in REGCACHE.

   You may need to cast away some 'const' qualifiers when passing
   MOVE, since this function can't tell at compile-time which of
   REGCACHE or BUFFER is acting as the source of the data.  If C had
   co-variant type qualifiers, ...  */
static void
e500_move_ev_register (void (*move) (struct regcache *regcache,
                                     int regnum, void *buf),
                       struct regcache *regcache, int ev_reg,
                       void *buffer)
{
  struct gdbarch *arch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (arch); 
  int reg_index;
  char *byte_buffer = buffer;

  gdb_assert (tdep->ppc_ev0_regnum <= ev_reg
              && ev_reg < tdep->ppc_ev0_regnum + ppc_num_gprs);

  reg_index = ev_reg - tdep->ppc_ev0_regnum;

  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1501 2
a1502 2
      move (regcache, tdep->ppc_ev0_upper_regnum + reg_index, byte_buffer);
      move (regcache, tdep->ppc_gp0_regnum + reg_index, byte_buffer + 4);
d1505 1
a1505 4
    {
      move (regcache, tdep->ppc_gp0_regnum + reg_index, byte_buffer);
      move (regcache, tdep->ppc_ev0_upper_regnum + reg_index, byte_buffer + 4);
    }
d1512 3
a1514 1
  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
d1517 12
a1528 10
  gdb_assert (regcache_arch == gdbarch);
 
  if (tdep->ppc_ev0_regnum <= reg_nr
      && reg_nr < tdep->ppc_ev0_regnum + ppc_num_gprs)
    e500_move_ev_register (regcache_raw_read, regcache, reg_nr, buffer);
  else
    internal_error (__FILE__, __LINE__,
                    "e500_pseudo_register_read: "
                    "called on unexpected register '%s' (%d)",
                    gdbarch_register_name (gdbarch, reg_nr), reg_nr);
d1535 3
a1537 1
  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
d1540 7
a1546 23
  gdb_assert (regcache_arch == gdbarch);
 
  if (tdep->ppc_ev0_regnum <= reg_nr
      && reg_nr < tdep->ppc_ev0_regnum + ppc_num_gprs)
    e500_move_ev_register ((void (*) (struct regcache *, int, void *))
                           regcache_raw_write,
                           regcache, reg_nr, (void *) buffer);
  else
    internal_error (__FILE__, __LINE__,
                    "e500_pseudo_register_read: "
                    "called on unexpected register '%s' (%d)",
                    gdbarch_register_name (gdbarch, reg_nr), reg_nr);
}

/* The E500 needs a custom reggroup function: it has anonymous raw
   registers, and default_register_reggroup_p assumes that anonymous
   registers are not members of any reggroup.  */
static int
e500_register_reggroup_p (struct gdbarch *gdbarch,
                          int regnum,
                          struct reggroup *group)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1548 4
a1551 7
  /* The save and restore register groups need to include the
     upper-half registers, even though they're anonymous.  */
  if ((group == save_reggroup
       || group == restore_reggroup)
      && (tdep->ppc_ev0_upper_regnum <= regnum
          && regnum < tdep->ppc_ev0_upper_regnum + ppc_num_gprs))
    return 1;
d1553 4
a1556 2
  /* In all other regards, the default reggroup definition is fine.  */
  return default_register_reggroup_p (gdbarch, regnum, group);
d1559 2
a1560 1
/* Convert a DBX STABS register number to a GDB register number.  */
d1562 1
a1562 1
rs6000_stab_reg_to_regnum (int num)
d1569 1
a1569 6
    /* FIXME: jimb/2004-05-05: What should we do when the debug info
       specifies registers the architecture doesn't have?  Our
       callers don't check the value we return.  */
    return tdep->ppc_fp0_regnum + (num - 32);
  else if (77 <= num && num <= 108)
    return tdep->ppc_vr0_regnum + (num - 77);
a1584 6
      case 110:
        return tdep->ppc_vrsave_regnum - 1; /* vscr */
      case 111:
        return tdep->ppc_acc_regnum;
      case 112:
        return tdep->ppc_spefscr_regnum;
a1587 1
}
d1589 2
d1592 5
a1596 5
/* Convert a Dwarf 2 register number to a GDB register number.  */
static int
rs6000_dwarf2_reg_to_regnum (int num)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1598 2
a1599 33
  if (0 <= num && num <= 31)
    return tdep->ppc_gp0_regnum + num;
  else if (32 <= num && num <= 63)
    /* FIXME: jimb/2004-05-05: What should we do when the debug info
       specifies registers the architecture doesn't have?  Our
       callers don't check the value we return.  */
    return tdep->ppc_fp0_regnum + (num - 32);
  else if (1124 <= num && num < 1124 + 32)
    return tdep->ppc_vr0_regnum + (num - 1124);
  else if (1200 <= num && num < 1200 + 32)
    return tdep->ppc_ev0_regnum + (num - 1200);
  else
    switch (num)
      {
      case 67:
        return tdep->ppc_vrsave_regnum - 1; /* vscr */
      case 99:
        return tdep->ppc_acc_regnum;
      case 100:
        return tdep->ppc_mq_regnum;
      case 101:
        return tdep->ppc_xer_regnum;
      case 108:
        return tdep->ppc_lr_regnum;
      case 109:
        return tdep->ppc_ctr_regnum;
      case 356:
        return tdep->ppc_vrsave_regnum;
      case 612:
        return tdep->ppc_spefscr_regnum;
      default:
        return num;
      }
a1601 1

d1603 1
a1603 3
rs6000_store_return_value (struct type *type,
                           struct regcache *regcache,
                           const void *valbuf)
d1605 1
a1605 3
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int regnum = -1;
d1607 1
a1607 4
  /* The calling convention this function implements assumes the
     processor has floating-point registers.  We shouldn't be using it
     on PPC variants that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (gdbarch));
a1608 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d1612 3
a1614 1
    regnum = tdep->ppc_fp0_regnum + 1;
d1619 2
a1620 5
        regnum = tdep->ppc_vr0_regnum + 2;
      else
        internal_error (__FILE__, __LINE__,
                        "rs6000_store_return_value: "
                        "unexpected array return type");
d1624 2
a1625 17
    regnum = tdep->ppc_gp0_regnum + 3;

  {
    size_t bytes_written = 0;

    while (bytes_written < TYPE_LENGTH (type))
      {
        /* How much of this value can we write to this register?  */
        size_t bytes_to_write = min (TYPE_LENGTH (type) - bytes_written,
                                     register_size (gdbarch, regnum));
        regcache_cooked_write_part (regcache, regnum,
                                    0, bytes_to_write,
                                    (char *) valbuf + bytes_written);
        regnum++;
        bytes_written += bytes_to_write;
      }
  }
a1627 1

d1738 1
a1738 1
#define R(name)		{ STR(name), 4, 8, 0, 0, -1 }
d1742 1
a1742 1
#define R4(name)	{ STR(name), 4, 4, 0, 0, -1 }
d1746 1
a1746 1
#define R8(name)	{ STR(name), 8, 8, 0, 0, -1 }
d1750 1
a1750 1
#define R16(name)       { STR(name), 16, 16, 0, 0, -1 }
d1753 1
a1753 1
#define F(name)		{ STR(name), 8, 8, 1, 0, -1 }
d1755 2
a1756 3
/* Return a struct reg defining a pseudo register NAME that is 64 bits
   long on all systems.  */
#define P8(name)	{ STR(name), 8, 8, 0, 1, -1 }
d1760 1
a1760 1
#define R32(name)	{ STR(name), 4, 0, 0, 0, -1 }
d1764 1
a1764 1
#define R64(name)	{ STR(name), 0, 8, 0, 0, -1 }
d1767 1
a1767 1
#define R0		{ 0, 0, 0, 0, 0, -1 }
a1768 20
/* Return a struct reg defining an anonymous raw register that's 32
   bits on all systems.  */
#define A4              { 0, 4, 4, 0, 0, -1 }

/* Return a struct reg defining an SPR named NAME that is 32 bits on
   32-bit systems and 64 bits on 64-bit systems.  */
#define S(name)         { STR(name), 4, 8, 0, 0, ppc_spr_ ## name }
  
/* Return a struct reg defining an SPR named NAME that is 32 bits on
   all systems.  */
#define S4(name)        { STR(name), 4, 4, 0, 0, ppc_spr_ ## name }
  
/* Return a struct reg defining an SPR named NAME that is 32 bits on
   all systems, and whose SPR number is NUMBER.  */
#define SN4(name, number) { STR(name), 4, 4, 0, 0, (number) }
  
/* Return a struct reg defining an SPR named NAME that's 64 bits on
   64-bit systems and that doesn't exist on 32-bit systems.  */
#define S64(name)       { STR(name), 0, 8, 0, 0, ppc_spr_ ## name }
  
d1782 11
d1795 1
a1795 1
  /* 66 */ R4(cr),  S(lr), S(ctr), S4(xer), R4(fpscr)
d1799 1
a1799 1
  /* 66 */ R4(cr),  S(lr), S(ctr), S4(xer), R0
d1810 9
a1818 9
  /*  87 */ S4(pvr), \
  /*  88 */ S(ibat0u), S(ibat0l), S(ibat1u), S(ibat1l), \
  /*  92 */ S(ibat2u), S(ibat2l), S(ibat3u), S(ibat3l), \
  /*  96 */ S(dbat0u), S(dbat0l), S(dbat1u), S(dbat1l), \
  /* 100 */ S(dbat2u), S(dbat2l), S(dbat3u), S(dbat3l), \
  /* 104 */ S(sdr1),   S64(asr),  S(dar),    S4(dsisr), \
  /* 108 */ S(sprg0),  S(sprg1),  S(sprg2),  S(sprg3),  \
  /* 112 */ S(srr0),   S(srr1),   S(tbl),    S(tbu),    \
  /* 116 */ S4(dec),   S(dabr),   S4(ear)
d1828 13
a1840 32

/* On machines supporting the SPE APU, the general-purpose registers
   are 64 bits long.  There are SIMD vector instructions to treat them
   as pairs of floats, but the rest of the instruction set treats them
   as 32-bit registers, and only operates on their lower halves.

   In the GDB regcache, we treat their high and low halves as separate
   registers.  The low halves we present as the general-purpose
   registers, and then we have pseudo-registers that stitch together
   the upper and lower halves and present them as pseudo-registers.  */

/* SPE GPR lower halves --- raw registers.  */
#define PPC_SPE_GP_REGS \
  /*  0 */ R4(r0), R4(r1), R4(r2), R4(r3), R4(r4), R4(r5), R4(r6), R4(r7),  \
  /*  8 */ R4(r8), R4(r9), R4(r10),R4(r11),R4(r12),R4(r13),R4(r14),R4(r15), \
  /* 16 */ R4(r16),R4(r17),R4(r18),R4(r19),R4(r20),R4(r21),R4(r22),R4(r23), \
  /* 24 */ R4(r24),R4(r25),R4(r26),R4(r27),R4(r28),R4(r29),R4(r30),R4(r31)

/* SPE GPR upper halves --- anonymous raw registers.  */
#define PPC_SPE_UPPER_GP_REGS                   \
  /*  0 */ A4, A4, A4, A4, A4, A4, A4, A4,      \
  /*  8 */ A4, A4, A4, A4, A4, A4, A4, A4,      \
  /* 16 */ A4, A4, A4, A4, A4, A4, A4, A4,      \
  /* 24 */ A4, A4, A4, A4, A4, A4, A4, A4

/* SPE GPR vector registers --- pseudo registers based on underlying
   gprs and the anonymous upper half raw registers.  */
#define PPC_EV_PSEUDO_REGS \
/* 0*/P8(ev0), P8(ev1), P8(ev2), P8(ev3), P8(ev4), P8(ev5), P8(ev6), P8(ev7), \
/* 8*/P8(ev8), P8(ev9), P8(ev10),P8(ev11),P8(ev12),P8(ev13),P8(ev14),P8(ev15),\
/*16*/P8(ev16),P8(ev17),P8(ev18),P8(ev19),P8(ev20),P8(ev21),P8(ev22),P8(ev23),\
/*24*/P8(ev24),P8(ev25),P8(ev26),P8(ev27),P8(ev28),P8(ev29),P8(ev30),P8(ev31)
d1847 1
a1847 1
  /* 66 */ R4(cnd), S(lr), S(cnt), S4(xer), S4(mq),
d1860 7
a1866 1
/* IBM PowerPC 403.
d1868 1
a1868 11
   Some notes about the "tcr" special-purpose register:
   - On the 403 and 403GC, SPR 986 is named "tcr", and it controls the
     403's programmable interval timer, fixed interval timer, and
     watchdog timer.
   - On the 602, SPR 984 is named "tcr", and it controls the 602's
     watchdog timer, and nothing else.

   Some of the fields are similar between the two, but they're not
   compatible with each other.  Since the two variants have different
   registers, with different numbers, but the same name, we can't
   splice the register name to get the SPR number.  */
d1875 6
a1880 6
  /* 119 */ S(icdbdr), S(esr),  S(dear), S(evpr),
  /* 123 */ S(cdbcr),  S(tsr),  SN4(tcr, ppc_spr_403_tcr), S(pit),
  /* 127 */ S(tbhi),   S(tblo), S(srr2), S(srr3),
  /* 131 */ S(dbsr),   S(dbcr), S(iac1), S(iac2),
  /* 135 */ S(dac1),   S(dac2), S(dccr), S(iccr),
  /* 139 */ S(pbl1),   S(pbu1), S(pbl2), S(pbu2)
d1883 1
a1883 2
/* IBM PowerPC 403GC.
   See the comments about 'tcr' for the 403, above.  */
d1890 8
a1897 8
  /* 119 */ S(icdbdr), S(esr),  S(dear), S(evpr),
  /* 123 */ S(cdbcr),  S(tsr),  SN4(tcr, ppc_spr_403_tcr), S(pit),
  /* 127 */ S(tbhi),   S(tblo), S(srr2), S(srr3),
  /* 131 */ S(dbsr),   S(dbcr), S(iac1), S(iac2),
  /* 135 */ S(dac1),   S(dac2), S(dccr), S(iccr),
  /* 139 */ S(pbl1),   S(pbu1), S(pbl2), S(pbu2),
  /* 143 */ S(zpr),    S(pid),  S(sgr),  S(dcwr),
  /* 147 */ S(tbhu),   S(tblu)
d1907 1
a1907 1
  /* 119 */ S(eie), S(eid), S(nri)
d1917 12
a1928 12
  /* 119 */ S(eie), S(eid), S(nri), S(cmpa),
  /* 123 */ S(cmpb), S(cmpc), S(cmpd), S(icr),
  /* 127 */ S(der), S(counta), S(countb), S(cmpe),
  /* 131 */ S(cmpf), S(cmpg), S(cmph), S(lctrl1),
  /* 135 */ S(lctrl2), S(ictrl), S(bar), S(ic_cst),
  /* 139 */ S(ic_adr), S(ic_dat), S(dc_cst), S(dc_adr),
  /* 143 */ S(dc_dat), S(dpdr), S(dpir), S(immr),
  /* 147 */ S(mi_ctr), S(mi_ap), S(mi_epn), S(mi_twc),
  /* 151 */ S(mi_rpn), S(md_ctr), S(m_casid), S(md_ap),
  /* 155 */ S(md_epn), S(m_twb), S(md_twc), S(md_rpn),
  /* 159 */ S(m_tw), S(mi_dbcam), S(mi_dbram0), S(mi_dbram1),
  /* 163 */ S(md_dbcam), S(md_dbram0), S(md_dbram1)
d1940 2
a1941 2
  /* 119 */ S(hid0), S(hid1), S(iabr), S(dabr),
  /* 123 */ S(pir), S(mq), S(rtcu), S(rtcl)
d1944 1
a1944 2
/* Motorola PowerPC 602.
   See the notes under the 403 about 'tcr'.  */
d1951 3
a1953 3
  /* 119 */ S(hid0), S(hid1), S(iabr), R0,
  /* 123 */ R0, SN4(tcr, ppc_spr_602_tcr), S(ibr), S(esasrr),
  /* 127 */ S(sebr), S(ser), S(sp), S(lt)
d1963 3
a1965 3
  /* 119 */ S(hid0), S(hid1), S(iabr), R0,
  /* 123 */ R0, S(dmiss), S(dcmp), S(hash1),
  /* 127 */ S(hash2), S(imiss), S(icmp), S(rpa)
d1975 3
a1977 3
  /* 119 */ S(hid0), S(hid1), S(iabr), S(dabr),
  /* 123 */ S(pir), S(mmcr0), S(pmc1), S(pmc2),
  /* 127 */ S(sia), S(sda)
d1987 6
a1992 6
  /* 119 */ S(hid0), S(hid1), S(iabr), S(dabr),
  /* 123 */ R0, S(ummcr0), S(upmc1), S(upmc2),
  /* 127 */ S(usia), S(ummcr1), S(upmc3), S(upmc4),
  /* 131 */ S(mmcr0), S(pmc1), S(pmc2), S(sia),
  /* 135 */ S(mmcr1), S(pmc3), S(pmc4), S(l2cr),
  /* 139 */ S(ictc), S(thrm1), S(thrm2), S(thrm3)
d2001 1
a2001 1
  /* cr, lr, ctr, xer, fpscr */
d2014 6
a2019 5
  /*   0 ..  31 */ PPC_SPE_GP_REGS,
  /*  32 ..  63 */ PPC_SPE_UPPER_GP_REGS,
  /*  64 ..  65 */ R(pc), R(ps),
  /*  66 ..  70 */ PPC_UISA_NOFP_SPRS,
  /*  71 ..  72 */ R8(acc), S4(spefscr),
d2022 2
a2023 1
  /*  73 .. 104 */ PPC_EV_PSEUDO_REGS
d2285 5
a2289 11

      /* If skip_prologue says floating-point registers were saved,
         but the current architecture has no floating-point registers,
         then that's strange.  But we have no indices to even record
         the addresses under, so we just ignore it.  */
      if (ppc_floating_point_unit_p (gdbarch))
        for (i = fdata.saved_fpr; i < ppc_num_fprs; i++)
          {
            cache->saved_regs[tdep->ppc_fp0_regnum + i].addr = fpr_addr;
            fpr_addr += 8;
          }
d2299 1
a2299 1
      for (i = fdata.saved_gpr; i < ppc_num_gprs; i++)
d2330 1
a2330 1
	  for (i = fdata.saved_ev; i < ppc_num_gprs; i++)
d2385 2
a2386 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d2438 1
a2438 1
  int wordsize, from_xcoff_exec, from_elf_exec, i, off;
d2537 1
d2550 1
d2559 1
a2559 1
  else if (arch == bfd_arch_rs6000)
d2563 1
a2563 10
  tdep->ppc_fp0_regnum = 32;
  tdep->ppc_fpscr_regnum = (arch == bfd_arch_rs6000) ? 71 : 70;
  tdep->ppc_sr0_regnum = 71;
  tdep->ppc_vr0_regnum = -1;
  tdep->ppc_vrsave_regnum = -1;
  tdep->ppc_ev0_upper_regnum = -1;
  tdep->ppc_ev0_regnum = -1;
  tdep->ppc_ev31_regnum = -1;
  tdep->ppc_acc_regnum = -1;
  tdep->ppc_spefscr_regnum = -1;
a2567 1
  set_gdbarch_register_sim_regno (gdbarch, rs6000_register_sim_regno);
d2575 1
a2575 1
      set_gdbarch_store_return_value (gdbarch, rs6000_store_return_value);
d2578 1
a2578 11
  /* Set lr_frame_offset.  */
  if (wordsize == 8)
    tdep->lr_frame_offset = 16;
  else if (sysv_abi)
    tdep->lr_frame_offset = 4;
  else
    tdep->lr_frame_offset = 8;

  if (v->arch == bfd_arch_rs6000)
    tdep->ppc_sr0_regnum = -1;
  else if (v->arch == bfd_arch_powerpc)
a2581 1
        tdep->ppc_sr0_regnum = -1;
d2584 2
d2590 2
d2594 2
d2597 10
a2606 8
        tdep->ppc_ev0_upper_regnum = 32;
	tdep->ppc_ev0_regnum = 73;
	tdep->ppc_ev31_regnum = 104;
        tdep->ppc_acc_regnum = 71;
        tdep->ppc_spefscr_regnum = 72;
        tdep->ppc_fp0_regnum = -1;
        tdep->ppc_fpscr_regnum = -1;
        tdep->ppc_sr0_regnum = -1;
a2608 1
        set_gdbarch_register_reggroup_p (gdbarch, e500_register_reggroup_p);
d2610 6
a2615 10

      case bfd_mach_ppc64:
      case bfd_mach_ppc_620:
      case bfd_mach_ppc_630:
      case bfd_mach_ppc_a35:
      case bfd_mach_ppc_rs64ii:
      case bfd_mach_ppc_rs64iii:
        /* These processor's register sets don't have segment registers.  */
        tdep->ppc_sr0_regnum = -1;
        break;
a2616 4
  else
    internal_error (__FILE__, __LINE__,
                    "rs6000_gdbarch_init: "
                    "received unexpected BFD 'arch' value");
d2621 16
d2638 1
a2638 1
  if (arch == bfd_arch_rs6000)
d2648 5
a2652 1
  set_gdbarch_register_type (gdbarch, rs6000_register_type);
d2678 5
a2682 6
  set_gdbarch_convert_register_p (gdbarch, rs6000_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, rs6000_register_to_value);
  set_gdbarch_value_to_register (gdbarch, rs6000_value_to_register);

  set_gdbarch_stab_reg_to_regnum (gdbarch, rs6000_stab_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, rs6000_dwarf2_reg_to_regnum);
d2716 2
a2717 1
    set_gdbarch_deprecated_use_struct_convention (gdbarch, rs6000_use_struct_convention);
d2745 1
a2763 2
  init_sim_regno_table (gdbarch);

@


1.180
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d428 4
@


1.179
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@d1779 2
a1780 1
	   && FRAMELESS_FUNCTION_INVOCATION (thisframe))
d2907 1
a2907 2
  set_gdbarch_frameless_function_invocation (gdbarch,
                                         rs6000_frameless_function_invocation);
@


1.178
log
@2004-02-12  Andrew Cagney  <cagney@@redhat.com>

	* remote-rdi.c (arm_rdi_start_remote): Delete unused function.
	(arm_rdi_interrupt, arm_rdi_interrupt_twice): Ditto.
	(interrupt_query): Ditto.
	(ofunc): Delete unused variable.
	* cris-tdep.c (cris_abi): Delete unused function.
	(reg_pop_op, move_reg_to_mem_index_inc_op): Ditto.
	(cris_get_wide_opcode, cris_get_short_size): Ditto.
	(cris_get_asr_quick_shift_steps): Ditto.
	(cris_skip_prologue_frameless_p): Ditto.
	* arm-tdep.c (arm_push_return_address): Delete unused function.
	(arm_push_dummy_frame, arm_fix_call_dummy): Ditto.
	* rs6000-tdep.c (rs6000_pc_in_call_dummy): Delete unused function.
	* s390-tdep.c (s390_function_start): Delete unused function.
@
text
@a30 1
#include "symfile.h"
@


1.177
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@a2048 11
/* Return whether PC is in a dummy function call.

   FIXME: This just checks for the end of the stack, which is broken
   for things like stepping through gcc nested function stubs.  */

static int
rs6000_pc_in_call_dummy (CORE_ADDR pc, CORE_ADDR sp, CORE_ADDR fp)
{
  return sp < pc && pc < fp;
}

@


1.176
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	DECR_PC_AFTER_BREAK to zero.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Add comment.
@
text
@d2895 1
a2895 1
  set_gdbarch_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
@


1.175
log
@2004-01-16  Andrew Cagney  <cagney@@redhat.com>

	Changes from Peter Schauer.
	* rs6000-tdep.c: Update copyright year.
	(rs6000_push_dummy_call): Update the stack pointer before
	accessing the corresponding stack region.
	* rs6000-nat.c: Update copyright year.
	(set_host_arch): Set "info.abfd" to "exec_bfd".
@
text
@a2899 1
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
@


1.174
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d2 4
a5 3
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d1251 8
d1300 9
a1308 1
  /* set back chain properly */
a1310 6

  /* Set the stack pointer.  According to the ABI, the SP is meant to
     be set _before_ the corresponding stack space is used.  No need
     for that here though - the target has been completely stopped -
     it isn't possible for an exception handler to stomp on the stack.  */
  regcache_raw_write_signed (regcache, SP_REGNUM, sp);
@


1.173
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@a2889 1
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.172
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc_linux_init_abi): When 32-bit GNU/Linux,
	set "return_value" instead of "use_struct_convention".
	(ppc_linux_use_struct_convention): Delete function.
	(ppc_linux_return_value): New function.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): New function.
	(ppc_sysv_abi_broken_return_value): New function.
	(do_ppc_sysv_return_value): Add "gdbarch" parameter.
	(ppc64_sysv_abi_push_dummy_call): Add "gdbarch" parameter, drop
	static.
	(ppc_sysv_abi_extract_return_value): Delete function.
	(ppc_sysv_abi_broken_extract_return_value): Delete function.
	(ppc_sysv_abi_store_return_value): Delete function.
	(ppc_sysv_abi_broken_store_return_value): Delete function.
	(ppc_sysv_abi_use_struct_convention): Delete function.
	(ppc64_sysv_abi_use_struct_convention): Delete function.
	(ppc64_sysv_abi_extract_return_value): Delete function.
	(ppc64_sysv_abi_store_return_value): Delete function.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): New function.
	(ppcnbsd_init_abi): Set "return_value", instead of
	"use_struct_convention", "extract_return_value", and
	"store_return_value".
	(ppcnbsd_use_struct_convention): Delete function.
	* ppc-tdep.h (ppc64_sysv_abi_return_value): Declare.
	(ppc_sysv_abi_return_value): Declare.
	(ppc_sysv_abi_broken_return_value): Declare.
	(ppc_sysv_abi_use_struct_convention): Delete.
	(ppc_sysv_abi_store_return_value): Delete.
	(ppc_sysv_abi_extract_return_value): Delete.
	(ppc_sysv_abi_broken_store_return_value): Delete.
	(ppc_sysv_abi_broken_extract_return_value): Delete.
	(ppc64_sysv_abi_use_struct_convention): Delete.
	(ppc64_sysv_abi_extract_return_value): Delete.
	(ppc64_sysv_abi_store_return_value): Delete.
	* rs6000-tdep.c (rs6000_gdbarch_init): For 32-bit and 64-bit SYSV,
	set "return_value" instead of "extract_return_value",
	"store_return_value", and "use_struct_convention".
@
text
@d988 2
a989 1
	  if (tmp >= 0 && STREQ (misc_function_vector[tmp].name, main_name ()))
@


1.171
log
@2003-10-31  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): For 64-bit ABI, set
	adjust_breakpoint_address.
	* Makefile.in (ppc-sysv-tdep.o): Add $(target_h).
	* ppc-tdep.h (ppc64_sysv_abi_adjust_breakpoint_address): Declare.
	* ppc-sysv-tdep.c: Include "target.h".  Update copyright.
	(ppc64_sysv_abi_adjust_breakpoint_address): New function.
@
text
@d2753 1
a2753 4
    {
      set_gdbarch_extract_return_value (gdbarch, ppc64_sysv_abi_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, ppc64_sysv_abi_store_return_value);
    }
d2755 1
a2755 4
    {
      set_gdbarch_extract_return_value (gdbarch, ppc_sysv_abi_extract_return_value);
      set_gdbarch_store_return_value (gdbarch, ppc_sysv_abi_store_return_value);
    }
d2904 1
a2904 6
  if (sysv_abi && wordsize == 4)
    set_gdbarch_use_struct_convention (gdbarch,
    				       ppc_sysv_abi_use_struct_convention);
  else if (sysv_abi && wordsize == 8)
    set_gdbarch_use_struct_convention (gdbarch, ppc64_sysv_abi_use_struct_convention);
  else
@


1.170
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (convert_from_func_ptr_addr): Convert to a pure
	multi-arch method, add "targ" parameter.
	(struct target_ops): Declare.
	* gdbarch.h, gdbarch.c: Re-generate.
	* Makefile.in (c-valprint.o): Update dependencies.
	* arch-utils.h: Update copyright.
	(convert_from_func_ptr_addr_identity): Declare.
	* arch-utils.c (convert_from_func_ptr_addr_identity): New function.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Update.
	* rs6000-tdep.c (rs6000_convert_from_func_ptr_addr): Upate.
	* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): Update.
	* infcall.c (find_function_addr, call_function_by_hand): Update.
	* c-valprint.c: Include "target.h".
	(print_function_pointer_address): Update.
@
text
@d2898 9
@


1.169
log
@2003-10-10  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (e500_store_return_value): Delete function.
	(e500_extract_return_value): Delete function.
	(rs6000_gdbarch_init): When SYSV, set "extract_return_value" and
	"restore_return_value" to "ppc_sysv_abi_extract_return_value" and
	"ppc_sysv_abi_restore_return_value" where applicable.
	* ppc-tdep.h: (ppc_sysv_abi_store_return_value): Declare.
	(ppc_sysv_abi_extract_return_value): Declare.
	(ppc_sysv_abi_broken_store_return_value): Declare.
	(ppc_sysv_abi_broken_extract_return_value): Declare.
	(ppc_sysv_abi_broken_use_struct_convention:) Delete declaration.
	* ppc-sysv-tdep.c (return_value_convention): Move definition to
	start of file.
	(do_ppc_sysv_return_value): New function.
	(ppc_sysv_abi_extract_return_value): New function.
	(ppc_sysv_abi_store_return_value): New function.
	(ppc_sysv_abi_broken_extract_return_value): New function.
	(ppc_sysv_abi_broken_store_return_value): New function.
	(ppc_sysv_abi_use_struct_convention): Call
	do_ppc_sysv_return_value.
@
text
@d2057 1
a2057 1
/* Support for CONVERT_FROM_FUNC_PTR_ADDR(ADDR).
d2077 3
a2079 1
rs6000_convert_from_func_ptr_addr (CORE_ADDR addr)
@


1.168
log
@2003-10-10  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (ppc-sysv-tdep.o): Add $(gdb_assert_h).
	* rs6000-tdep.c (rs6000_gdbarch_init): When 64 bit SysV ABI, set
	push_dummy_call to ppc64_sysv_abi_push_dummy_call.
	* ppc-sysv-tdep.c: Include "gdb_assert.h".
	(ppc64_sysv_abi_push_dummy_call): New function.
	(ppc64_sysv_abi_broken_push_dummy_call): New function.
	* ppc-tdep.h (ppc64_sysv_abi_push_dummy_call): Declare.
	(ppc64_sysv_abi_broken_push_dummy_call): Declare.
@
text
@a1315 59
/* Extract a function return value of type TYPE from raw register array
   REGBUF, and copy that return value into VALBUF in virtual format.  */
static void
e500_extract_return_value (struct type *valtype, struct regcache *regbuf, void *valbuf)
{
  int offset = 0;
  int vallen = TYPE_LENGTH (valtype);
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY
      && vallen == 8
      && TYPE_VECTOR (valtype))
    {
      regcache_raw_read (regbuf, tdep->ppc_ev0_regnum + 3, valbuf);
    }
  else
    {
      /* Return value is copied starting from r3.  Note that r3 for us
         is a pseudo register.  */
      int offset = 0;
      int return_regnum = tdep->ppc_gp0_regnum + 3;
      int reg_size = DEPRECATED_REGISTER_RAW_SIZE (return_regnum);
      int reg_part_size;
      char *val_buffer;
      int copied = 0;
      int i = 0;

      /* Compute where we will start storing the value from.  */ 
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
        {
	  if (vallen <= reg_size)
	    offset = reg_size - vallen;
	  else
	    offset = reg_size + (reg_size - vallen);
        }

      /* How big does the local buffer need to be?  */
      if (vallen <= reg_size)
	val_buffer = alloca (reg_size);
      else
	val_buffer = alloca (vallen);

      /* Read all we need into our private buffer.  We copy it in
         chunks that are as long as one register, never shorter, even
         if the value is smaller than the register.  */
      while (copied < vallen)
        {
          reg_part_size = DEPRECATED_REGISTER_RAW_SIZE (return_regnum + i);
	  /* It is a pseudo/cooked register.  */
          regcache_cooked_read (regbuf, return_regnum + i,
				val_buffer + copied);
          copied += reg_part_size;
          i++;
        }
      /* Put the stuff in the return buffer.  */
      memcpy (valbuf, val_buffer + offset, vallen);
    }
}

a1989 24
/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  */
static void
e500_store_return_value (struct type *type, char *valbuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* Everything is returned in GPR3 and up.  */
  int copied = 0;
  int i = 0;
  int len = TYPE_LENGTH (type);
  while (copied < len)
    {
      int regnum = gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + 3 + i;
      int reg_size = DEPRECATED_REGISTER_RAW_SIZE (regnum);
      char *reg_val_buf = alloca (reg_size);

      memcpy (reg_val_buf, valbuf + copied, reg_size);
      copied += reg_size;
      deprecated_write_register_gen (regnum, reg_val_buf);
      i++;
    }
}

d2755 5
a2797 2
        set_gdbarch_extract_return_value (gdbarch, e500_extract_return_value);
        set_gdbarch_deprecated_store_return_value (gdbarch, e500_store_return_value);
@


1.167
log
@2003-10-09  Andrew Cagney  <cagney@@redhat.com>

	Changes from 2003-09-09 Jimi Xenidis <jimix@@watson.ibm.com>:
	* config/rs6000/tm-rs6000.h (SOFTWARE_SINGLE_STEP): Delete macro.
	(SOFTWARE_SINGLE_STEP_P): Ditto.
	* config/powerpc/tm-ppc-eabi.h (SOFTWARE_SINGLE_STEP_P): Ditto.
	* config/powerpc/tm-linux.h (SOFTWARE_SINGLE_STEP): Ditto.
	(SOFTWARE_SINGLE_STEP_P): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): When AIX, set
	software_single_step to rs6000_software_single_step.
@
text
@d2962 2
@


1.166
log
@2003-10-03  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): When the 64 bit SysV ABI,
	set extract_return_value, store_return_value and
	use_struct_convention to ppc64_sysv_abi_extract_return_value,
	ppc64_sysv_abi_store_return_value and
	ppc64_sysv_abi_use_struct_convention.
	* ppc-tdep.h (ppc64_sysv_abi_extract_return_value): Declare.
	(ppc64_sysv_abi_store_return_value): Declare.
	(ppc64_sysv_abi_use_struct_convention): Declare.
	* ppc-sysv-tdep.c (enum return_value_convention): Define.
	(ppc64_sysv_abi_extract_return_value): New function.
	(ppc64_sysv_abi_store_return_value): New function.
	(ppc64_sysv_abi_use_struct_convention): New function.
	(ppc64_sysv_abi_return_value): New function.
@
text
@d3011 10
@


1.165
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d2833 10
a2842 3
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       rs6000_extract_return_value);
  set_gdbarch_deprecated_store_return_value (gdbarch, rs6000_store_return_value);
d2977 1
a2977 1
  if (sysv_abi)
d2980 2
@


1.164
log
@2003-09-29  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): Set the PowerOpen red zone
	to 224, not 220.
@
text
@d1157 1
a1157 1
      int reg_size = REGISTER_RAW_SIZE (ii + 3);
d1337 1
a1337 1
      int reg_size = REGISTER_RAW_SIZE (return_regnum);
d1363 1
a1363 1
          reg_part_size = REGISTER_RAW_SIZE (return_regnum + i);
d1424 2
a1425 2
	  && TYPE_LENGTH (valtype) < REGISTER_RAW_SIZE (3))
	offset = REGISTER_RAW_SIZE (3) - TYPE_LENGTH (valtype);
d1703 1
a1703 1
	      vr_addr += REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d1720 1
a1720 1
	      ev_addr += REGISTER_RAW_SIZE (tdep->ppc_ev0_regnum);
d1785 1
a1785 1
				      REGISTER_RAW_SIZE (fdata.alloca_reg));
d1935 1
a1935 1
  if (TYPE_LENGTH (type) != REGISTER_RAW_SIZE (n))
d1937 1
a1937 1
      double val = deprecated_extract_floating (from, REGISTER_RAW_SIZE (n));
d1941 1
a1941 1
    memcpy (to, from, REGISTER_RAW_SIZE (n));
d1951 1
a1951 1
  if (TYPE_LENGTH (type) != REGISTER_RAW_SIZE (n))
d1954 1
a1954 1
      deprecated_store_floating (to, REGISTER_RAW_SIZE (n), val);
d1957 1
a1957 1
    memcpy (to, from, REGISTER_RAW_SIZE (n));
d2063 1
a2063 1
      int reg_size = REGISTER_RAW_SIZE (regnum);
@


1.163
log
@2003-09-28  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_read_unsigned_register): Delete function.
	* frame.h (frame_read_unsigned_register): Delete declaration.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	get_frame_register_unsigned.
	(sparc_frame_saved_pc, sparc_pop_frame): Ditto.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.h (frame_read_register): Delete declaration.
	* frame.c (frame_read_register): Delete function.
	* arch-utils.c (legacy_register_to_value): Use get_frame_register.
	* sparc-tdep.c (sparc_fetch_pointer_argument): Ditto.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* hppa-tdep.c (hppa_fetch_pointer_argument): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.c (frame_read_signed_register): Delete function.
	(frame_read_unsigned_register): Update comments.
	* frame.h (frame_read_signed_register): Delete declaration.
	* h8300-tdep.c (h8300_print_register): Use
	get_frame_register_signed.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
@
text
@d2934 5
a2938 2
    /* PowerOpen / AIX 32 bit.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 220);
@


1.162
log
@2003-09-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_frame_saved_regs): Rename
	get_frame_saved_regs.
	* cris-tdep.c, frame.c, h8300-tdep.c, hppa-tdep.c: Update.
	* mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, ppc-linux-tdep.c, rs6000-tdep.c: Update.
	* s390-tdep.c, sh64-tdep.c, stack.c: Update.
	* v850-tdep.c, vax-tdep.c, xstormy16-tdep.c: Update.
@
text
@d240 1
a240 1
  frame_read_register (frame, 3 + argi, &addr);
@


1.161
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@d1631 1
a1631 1
  if (get_frame_saved_regs (fi))
d1673 1
a1673 1
	  get_frame_saved_regs (fi)[FP0_REGNUM + i] = fpr_addr;
d1687 1
a1687 1
	  get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = gpr_addr;
d1702 1
a1702 1
	      get_frame_saved_regs (fi)[tdep->ppc_vr0_regnum + i] = vr_addr;
d1718 2
a1719 2
	      get_frame_saved_regs (fi)[tdep->ppc_ev0_regnum + i] = ev_addr;
              get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = ev_addr + 4;
d1728 1
a1728 1
    get_frame_saved_regs (fi)[tdep->ppc_cr_regnum] = frame_addr + fdatap->cr_offset;
d1733 1
a1733 1
    get_frame_saved_regs (fi)[tdep->ppc_lr_regnum] = frame_addr + fdatap->lr_offset;
d1738 1
a1738 1
    get_frame_saved_regs (fi)[tdep->ppc_vrsave_regnum] = frame_addr + fdatap->vrsave_offset;
d1765 1
a1765 1
  if (!get_frame_saved_regs (fi))
@


1.160
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Set the 32 bit
	"use_struct_convention" to "ppc_linux_use_struct_convention".
	(ppc_linux_use_struct_convention): New function.
	* rs6000-tdep.c (rs6000_use_struct_convention): New function.
	(rs6000_gdbarch_init): For AIX, set "use_struct_convention" to
	"rs6000_use_struct_convention".
	* ppc-tdep.h (ppc_sysv_abi_broken_use_struct_convention): Delete
	declaration.
	* ppc-sysv-tdep.c (ppc_sysv_abi_broken_use_struct_convention):
	Delete function.
@
text
@d1057 1
a1057 1
	  read_memory (addr, &deprecated_registers[REGISTER_BYTE (ii)],
d1068 1
a1068 1
	  read_memory (addr, &deprecated_registers[REGISTER_BYTE (ii + FP0_REGNUM)], 8);
d1174 1
a1174 1
	  memcpy (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1186 1
a1186 1
	      memset (&deprecated_registers[REGISTER_BYTE (ii + 3)], 0,
d1188 1
a1188 1
	      memcpy (&deprecated_registers[REGISTER_BYTE (ii + 3)],
d1204 2
a1205 2
	  memset (&deprecated_registers[REGISTER_BYTE (ii + 3)], 0, reg_size);
	  memcpy ((char *)&deprecated_registers[REGISTER_BYTE (ii + 3)] + adj, 
d1279 1
a1279 1
	      memcpy (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1404 1
a1404 1
		&regbuf[REGISTER_BYTE (FP0_REGNUM + 1)],
d1408 1
a1408 1
	  memcpy (&dd, &regbuf[REGISTER_BYTE (FP0_REGNUM + 1)], 8);
d1417 1
a1417 1
      memcpy (valbuf, regbuf + REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
d1428 1
a1428 1
	      regbuf + REGISTER_BYTE (3) + offset,
d2084 1
a2084 1
    deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM + 1), valbuf,
d2090 1
a2090 1
	deprecated_write_register_bytes (REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
d2095 1
a2095 1
    deprecated_write_register_bytes (REGISTER_BYTE (gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + 3),
@


1.159
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_push_dummy_call): Fix typos.
	* dcache.c: Update copyrights and descriptions.
	* scm-exp.c, ia64-aix-nat.c, hppam3-nat.c: environ.c: Ditto.
@
text
@d1375 12
d2972 1
a2972 1
				       generic_use_struct_convention);
@


1.158
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d1294 1
a1294 1
  /* Set the stack pointer.  According to the ABI, the SP is ment to
d1296 2
a1297 2
     for that here though - the target has been completly stopped - it
     isn't possible for an exception handler to stomp on the stack.  */
@


1.157
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d1466 1
a1466 1
  register unsigned int ii, op;
@


1.156
log
@2003-09-11  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_push_dummy_call): Use
	regcache_raw_write_signed to set SP_REGNUM, move the operation to
	near the function's end.
	(rs6000_gdbarch_init): Do not set "deprecated_dummy_write_sp".
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use
	regcache_raw_write_signed to set SP_REGNUM.
@
text
@d1806 1
a1806 1
  if (inside_entry_file (get_frame_pc (thisframe))
@


1.155
log
@2003-09-09  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (ppc_push_return_address): Delete function.
	(rs6000_push_dummy_call): Set LR to BP_ADDR.
	(rs6000_gdbarch_init): Do not set deprecated_push_return_address.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Ditto.
@
text
@a1248 8
      /* This is another instance we need to be concerned about
         securing our stack space. If we write anything underneath %sp
         (r1), we might conflict with the kernel who thinks he is free
         to use this area. So, update %sp first before doing anything
         else.  */

      write_register (SP_REGNUM, sp);

a1288 3
  else
    /* Secure stack areas first, before doing anything else.  */
    write_register (SP_REGNUM, sp);
d1294 6
a2893 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
@


1.154
log
@2003-09-09  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_fix_call_dummy): Delete function.
	(rs6000_push_dummy_call): Set the "TOC" register.
@
text
@d1305 4
a1320 11
/* Function: ppc_push_return_address (pc, sp)
   Set up the return address for the inferior function call.  */

static CORE_ADDR
ppc_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  write_register (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum,
		  entry_point_address ());
  return sp;
}

a2930 1
  set_gdbarch_deprecated_push_return_address (gdbarch, ppc_push_return_address);
@


1.153
log
@2003-09-09  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): Do not set the deprecated
	methods "max_register_raw_size", "max_register_virtual_size" or
	"register_virtual_size".
@
text
@a1077 19
/* Fixup the call sequence of a dummy function, with the real function
   address.  Its arguments will be passed by gdb.  */

static void
rs6000_fix_call_dummy (char *dummyname, CORE_ADDR pc, CORE_ADDR fun,
		       int nargs, struct value **args, struct type *type,
		       int gcc_p)
{
  int ii;
  CORE_ADDR target_addr;

  if (rs6000_find_toc_address_hook != NULL)
    {
      CORE_ADDR tocvalue = (*rs6000_find_toc_address_hook) (fun);
      write_register (gdbarch_tdep (current_gdbarch)->ppc_toc_regnum,
		      tocvalue);
    }
}

d1305 8
a2929 1
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, rs6000_fix_call_dummy);
@


1.152
log
@2003-09-09  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_store_struct_return): Delete function.
	(rs6000_push_dummy_call): Store the struct return address.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Ditto.
@
text
@a2925 3
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 16);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, generic_register_size);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 16);
@


1.151
log
@2003-09-09  Andrew Cagney  <cagney@@redhat.com>

	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call): Replace
	"ppc_sysv_abi_push_arguments".
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Replace
	"ppc_sysv_abi_push_arguments".
	* rs6000-tdep.c (rs6000_gdbarch_init): Set "push_dummy_call"
	instead of "push_arguments".
	(rs6000_push_dummy_call): Replace "rs6000_push_arguments".
@
text
@d1126 1
d1141 2
a1142 1
     Copy them appropriately.
d1144 10
a1153 6
     If the function is returning a `struct', then the first word (which 
     will be passed in r3) is used for struct return address.  In that
     case we should advance one word and start from r4 register to copy 
     parameters.  */

  ii = struct_return ? 1 : 0;
a2059 10
/* Store the address of the place in which to copy the structure the
   subroutine will return.  */

static void
rs6000_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  write_register (tdep->ppc_gp0_regnum + 3, addr);
}

a2971 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, rs6000_store_struct_return);
@


1.150
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c: Include "dis-asm.h".
	* cris-tdep.c: Include "dis-asm.h".
	(cris_delayed_get_disassembler): Use "struct disassemble_info"
	instead of corresponding typedef.
	* h8300-tdep.c: Include "dis-asm.h".
	* ia64-tdep.c: Include "dis-asm.h".
	* i386-tdep.c: Include "dis-asm.h".
	(i386_print_insn): Use "struct disassemble_info" instead of
	corresponding typedef.
	* m68k-tdep.c: Include "dis-asm.h".
	* mcore-tdep.c: Include "dis-asm.h".
	* mips-tdep.c: Include "dis-asm.h".
	(gdb_print_insn_mips): Make static, use "struct disassemble_info"
	instead of corresponding typedef.
	* ns32k-tdep.c: Include "dis-asm.h".
	* s390-tdep.c: Include "dis-asm.h".
	* sparc-tdep.c: Include "dis-asm.h".
	* vax-tdep.c: Include "dis-asm.h".
	* v850-tdep.c: Include "dis-asm.h".
	* mn10300-tdep.c: Include "dis-asm.h".
	* rs6000-tdep.c: Include "dis-asm.h".
	* xstormy16-tdep.c: Include "dis-asm.h".
	(_initialize_xstormy16_tdep): Delete "extern" declaration of
	print_insn_xstormy16.
	* Makefile.in (v850-tdep.o): Update dependencies.
	(vax-tdep.o, sparc-tdep.o, s390-tdep.o): Ditto.
	(ns32k-tdep.o, mips-tdep.o, mcore-tdep.o): Ditto.
	(m68k-tdep.o, ia64-tdep.o, i386-tdep.o): Ditto.
	(h8300-tdep.o, cris-tdep.o, avr-tdep.o): Ditto.
	(mn10300-tdep.o, xstormy16-tdep.o, disasm.o): Ditto.
	(gdbarch_h): Remove $(dis_asm_h).
	* disasm.c: Include "dis-asm.h".
	(dis_asm_read_memory): Use "struct disassemble_info" instead of
	corresponding typedef.
	(dis_asm_memory_error, dump_insns, do_assembly_only): Ditto.
	(gdb_disassemble_info, gdb_disassembly, gdb_print_insn): Ditto.
	* gdbarch.sh: Do not include "dis-asm.h".
	(struct disassemble_info): Declare opaque.
	(TARGET_PRINT_INSN): Update declaration.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d1121 4
a1124 2
rs6000_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
d2972 1
a2972 1
    set_gdbarch_deprecated_push_arguments (gdbarch, ppc_sysv_abi_push_arguments);
d2974 1
a2974 1
    set_gdbarch_deprecated_push_arguments (gdbarch, rs6000_push_arguments);
@


1.149
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_CALL_DUMMY_ADDRESS): Rename
	CALL_DUMMY_ADDRESS, change to a predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* blockframe.c (deprecated_pc_in_call_dummy_at_entry_point):
	Use either DEPRECATED_CALL_DUMMY_ADDRESS or entry_point_address.
	* infcall.c (call_function_by_hand): Ditto.
	* sparc-tdep.c (sparc_push_return_address): Ditto.
	(sparc_gdbarch_init): Set deprecated_call_dummy_address.
	* xstormy16-tdep.c (xstormy16_push_return_address): Replace
	CALL_DUMMY_ADDRESS with entry_point_address.
	* v850-tdep.c (v850_push_return_address): Ditto.
	* s390-tdep.c (s390_push_return_address): Ditto.
	* rs6000-tdep.c (ppc_push_return_address): Ditto.
	* mn10300-tdep.c (mn10300_push_return_address): Ditto.
	* mcore-tdep.c (mcore_push_return_address): Ditto.
	* cris-tdep.c (cris_push_return_address): Ditto.
	* arm-tdep.c (arm_push_return_address): Ditto.
@
text
@d51 1
@


1.148
log
@Index: ChangeLog
2003-08-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_RED_ZONE_SIZE): New architecture method.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Adjust the SP by
	frame_red_zone_size before allocating any stack space.
	* rs6000-tdep.c (rs6000_gdbarch_init): Set "frame_red_zone_size".
	* x86-64-tdep.c (x86_64_frame_align): New function.
	(x86_64_init_abi): Set "frame_red_zone_size" and "frame_align".

	* x86-64-tdep.c (x86_64_push_arguments): Revert 2003-08-07 change.
	Remove code adjusting SP so that it skips over the Red Zone.

Index: doc/ChangeLog
2003-08-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	"frame_red_zone_size".
@
text
@d1326 1
a1326 1
		  CALL_DUMMY_ADDRESS ());
@


1.147
log
@2003-06-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS): Add predicate.  Deprecate.
	(FRAME_LOCALS_ADDRESS): Add predicate.  Deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame-base.c (default_frame_args_address): Update.  Use
	default_frame_base_address when DEPRECATED_FRAME_ARGS_ADDRESS is
	not available.
	(default_frame_locals_address): Ditto for
	DEPRECATED_FRAME_LOCALS_ADDRESS.
	* vax-tdep.c (vax_sigtramp_saved_pc): Update.
	(vax_frame_num_args): Update.
	(vax_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* symtab.h (address_class): Update comments.
	* ns32k-tdep.c (ns32k_sigtramp_saved_pc): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_ARGS_ADDRESS): Update.
	(DEPRECATED_FRAME_LOCALS_ADDRESS): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_FRAME_ARGS_ADDRESS): Update.
	(DEPRECATED_FRAME_LOCALS_ADDRESS): Update.
	(DEPRECATED_FRAME_LOCALS_ADDRESS): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_ARGS_ADDRESS): Update.
	* alpha-mdebug-tdep.c: Update.
	* ada-lang.c (add_symbols_from_enclosing_procs): Update.
@
text
@d2947 6
@


1.146
log
@2003-06-23  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_register_virtual_type): Add explict cases
	for 0 "int0" and 4 "int32" sized registers.
	* gdbtypes.c (builtin_type_int0): Define.
	(build_gdbtypes): Initialize builtin_type_int0.
	* gdbtypes.h (builtin_type_int0): Declare.
@
text
@d3002 2
a3003 2
  set_gdbarch_frame_args_address (gdbarch, rs6000_frame_args_address);
  set_gdbarch_frame_locals_address (gdbarch, rs6000_frame_args_address);
@


1.145
log
@2003-06-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (SAVE_DUMMY_FRAME_TOS): Deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* infcall.c (call_function_by_hand): Update.
	* ia64-tdep.c (ia64_push_arguments): Update comment.
	* frame.c (legacy_get_prev_frame): Do not assume
	SAVE_DUMMY_FRAME_TOS_P.
	* dummy-frame.c (find_dummy_frame): Update comment.
@
text
@d1897 4
d1911 2
a1912 2
	  return builtin_type_int32;
	  break;
@


1.145.2.1
log
@2003-06-23  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_register_virtual_type): Add explict cases
	for 0 "int0" and 4 "int32" sized registers.
	* gdbtypes.c (builtin_type_int0): Define.
	(build_gdbtypes): Initialize builtin_type_int0.
	* gdbtypes.h (builtin_type_int0): Declare.
@
text
@a1896 4
	case 0:
	  return builtin_type_int0;
	case 4:
	  return builtin_type_int32;
d1907 2
a1908 2
	  internal_error (__FILE__, __LINE__, "Register %d size %d unknown",
			  n, size);
@


1.145.2.2
log
@Index: ChangeLog
2003-08-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_RED_ZONE_SIZE): New architecture method.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Adjust the SP by
	frame_red_zone_size before allocating any stack space.
	* rs6000-tdep.c (rs6000_gdbarch_init): Set "frame_red_zone_size".
	* x86-64-tdep.c (x86_64_frame_align): New function.
	(x86_64_init_abi): Set "frame_red_zone_size" and "frame_align".

	* x86-64-tdep.c (x86_64_push_arguments): Revert 2003-08-07 change.
	Remove code adjusting SP so that it skips over the Red Zone.

Index: doc/ChangeLog
2003-08-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	"frame_red_zone_size".
@
text
@a2946 6
  if (sysv_abi && wordsize == 8)
    /* PPC64 SYSV.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 288);
  else if (!sysv_abi && wordsize == 4)
    /* PowerOpen / AIX 32 bit.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 220);
@


1.145.2.3
log
@2003-09-29  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): Set the PowerOpen red zone
	to 224, not 220.
@
text
@d2951 2
a2952 5
    /* PowerOpen / AIX 32 bit.  The saved area or red zone consists of
       19 4 byte GPRS + 18 8 byte FPRs giving a total of 220 bytes.
       Problem is, 220 isn't frame (16 byte) aligned.  Round it up to
       224.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 224);
@


1.144
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Update comments on registers, re-order.
	(deprecated_register_byte): Rename register_byte.
	(deprecated_register_raw_size): Rename register_raw_size.
	(deprecated_register_virtual_size): Rename register_virtual_size.
	(deprecated_register_virtual_type): Rename register_virtual_type.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c: Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d2943 1
a2943 1
  set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
@


1.143
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_CONVERTIBLE): Deprecate
	REGISTER_CONVERTIBLE.
	(DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL): Same.
	(DEPRECATED_REGISTER_CONVERT_TO_RAW): Same, make "from" constant.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (deprecated_register_convertible_not): Rename
	generic_register_convertible_not.
	* arch-utils.c (deprecated_register_convertible_not): Rename
	generic_register_convertible.
	(legacy_convert_register_p, legacy_register_to_value): Update.
	* sh-tdep.c (sh64_push_arguments): Update.
	* m68klinux-tdep.c (m68k_linux_extract_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_EXTRACT_RETURN_VALUE): Update.
	* m68klinux-tdep.c (m68k_linux_store_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Update.
	* arch-utils.c (legacy_value_to_register): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	(rs6000_register_convert_to_raw): Make parameter "from" const.
	* mips-tdep.c (mips_gdbarch_init): Update.
	(mips_register_convert_to_raw): Make  parameter"virt_buf" const.
	* infcmd.c (default_print_registers_info): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_register_convert_to_raw): Make parameter "from" const.
	* i386-tdep.c (i386_gdbarch_init): Update.
	(i386_register_convert_to_raw): Update.
@
text
@d2921 2
a2922 2
  set_gdbarch_register_byte (gdbarch, rs6000_register_byte);
  set_gdbarch_register_raw_size (gdbarch, rs6000_register_raw_size);
d2924 1
a2924 1
  set_gdbarch_register_virtual_size (gdbarch, generic_register_size);
d2926 1
a2926 1
  set_gdbarch_register_virtual_type (gdbarch, rs6000_register_virtual_type);
@


1.142
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d1947 1
a1947 1
				char *from, char *to)
d2947 3
a2949 3
  set_gdbarch_register_convertible (gdbarch, rs6000_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch, rs6000_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch, rs6000_register_convert_to_raw);
@


1.141
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d3032 1
a3032 1
extern initialize_file_ftype _initialize_rs6000_tdep; /* -Wmissing-protypes */
@


1.140
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@a3004 4
  /* We can't tell how many args there are
     now that the C compiler delays popping them.  */
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);

@


1.139
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* inferior.h (deprecated_write_sp): Replace
	generic_target_write_sp.
	* regcache.c (deprecated_write_sp): Replace
	generic_target_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Update.
@
text
@d234 1
a234 1
CORE_ADDR
d2167 1
a2167 1
CORE_ADDR
d3035 2
@


1.138
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (TARGET_READ_SP): Add predicate, delete default.
	* gdbarch.h, gdbarch.c: Regenerate.
	* mn10300-tdep.c: Include "gdb_assert.h".
	(mn10300_read_fp): New function.
	(mn10300_gdbarch_init): Set deprecated_target_read_fp to
	mn10300_read_fp.  Do not set read_sp to generic_target_read_sp.
	* ia64-tdep.c: Include "gdb_assert.h".
	(ia64_read_fp): New function.
	(ia64_gdbarch_init): Set deprecated_target_read_fp to
	ia64_read_sp.  Do not set read_sp to generic_target_read_sp.
	* regcache.c (generic_target_read_sp): Delete function.
	(read_sp): Try TARGET_READ_SP and SP_REGNUM for the SP register.
	* inferior.h (generic_target_read_sp): Delete declaration.
	* frv-tdep.c (frv_gdbarch_init): Do not set read_sp to
	generic_target_read_sp.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* Makefile.in (mn10300-tdep.o, ia64-tdep.o): Update dependencies.
@
text
@d2914 1
a2914 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.137
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (TARGET_READ_PC): Add predicate, remove default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c: Update comments on read_pc et.al.
	(generic_target_read_pc): Delete function.
	(read_pc_pid): Try TARGET_READ_PC and PC_REGNUM for a PC register.
	* inferior.h (generic_target_read_pc): Delete declaration.
	* frv-tdep.c (frv_gdbarch_init): Do not set read_pc to
	generic_target_read_pc.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
@
text
@a2913 1
  set_gdbarch_read_sp (gdbarch, generic_target_read_sp);
@


1.136
log
@* gdbarch.sh (function_list): Add FETCH_POINTER_ARGUMENT.
* gdbarch.[ch]: Regenerate.
* hppa-tdep.c (hppa_fetch_pointer_argument): New function.
(hppa_gdbarch_init): Set it in the gdbarch vector.
* i386-tdep.c (i386_fetch_pointer_argument): New
(i386_gdbarch_init): Set it into gdbarch.
* rs6000-tdep.c (rs6000_fetch_pointer_argument): New.
(rs6000_gdbarch_init): Set it in gdbarch.
* sparc-tdep.c (sparc_fetch_pointer_argument): New
(sparc_gdbarch_init): Set it in gdbarch.
@
text
@a2912 1
  set_gdbarch_read_pc (gdbarch, generic_target_read_pc);
@


1.135
log
@	From Jimi X <jimix@@watson.ibm.com>:
	* rs6000-tdep.c (skip_prologue): Improve support for 64-bit code.
@
text
@d233 10
d3003 3
@


1.134
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d529 1
a529 1
	  lr_reg = (op & 0x03e00000) | 0x90010000;
d535 1
a535 1
	  cr_reg = (op & 0x03e00000) | 0x90010000;
d561 1
a561 1
		op = (op >> 1) << 1;
d593 9
a601 4
      else if (lr_reg != -1 && (op & 0xffff0000) == lr_reg)
	{			/* st Rx,NUM(r1) 
				   where Rx == lr */
	  fdata->lr_offset = SIGNED_SHORT (op) + offset;
d604 6
d613 9
a621 4
      else if (cr_reg != -1 && (op & 0xffff0000) == cr_reg)
	{			/* st Rx,NUM(r1) 
				   where Rx == cr */
	  fdata->cr_offset = SIGNED_SHORT (op) + offset;
d623 6
a671 1
	  /* update stack pointer */
d673 3
a675 3
      else if ((op & 0xffff0000) == 0x94210000 ||	/* stu r1,NUM(r1) */
	       (op & 0xffff0003) == 0xf8210001)		/* stdu r1,NUM(r1) */
	{
a676 2
	  if ((op & 0xffff0003) == 0xf8210001)
	    op = (op >> 1) << 1;
a679 1

d681 17
a697 2
      else if (op == 0x7c21016e)
	{			/* stwux 1,1,0 */
a700 2

	  /* Load up minimal toc pointer */
d702 3
a704 1
      else if ((op >> 22) == 0x20f
d706 1
a706 1
	{			/* l r31,... or l r30,... */
@


1.134.4.1
log
@Merged from trunk:

2003-05-29  Kevin Buettner  <kevinb@@redhat.com>

From Jimi X <jimix@@watson.ibm.com>:
* rs6000-tdep.c (skip_prologue): Improve support for 64-bit code.
@
text
@d529 1
a529 1
	  lr_reg = (op & 0x03e00000);
d535 1
a535 1
	  cr_reg = (op & 0x03e00000);
d561 1
a561 1
		op &= ~3UL;
d593 4
a596 9
      else if (lr_reg != -1 &&
	       /* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
	       (((op & 0xffff0000) == (lr_reg | 0xf8010000)) ||
		/* stw Rx, NUM(r1) */
		((op & 0xffff0000) == (lr_reg | 0x90010000)) ||
		/* stwu Rx, NUM(r1) */
		((op & 0xffff0000) == (lr_reg | 0x94010000))))
	{	/* where Rx == lr */
	  fdata->lr_offset = offset;
a598 6
	  if ((op & 0xfc000003) == 0xf8000000 ||	/* std */
	      (op & 0xfc000000) == 0x90000000)		/* stw */
	    {
	      /* Does not update r1, so add displacement to lr_offset.  */
	      fdata->lr_offset += SIGNED_SHORT (op);
	    }
d602 4
a605 9
      else if (cr_reg != -1 &&
	       /* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
	       (((op & 0xffff0000) == (cr_reg | 0xf8010000)) ||
		/* stw Rx, NUM(r1) */
		((op & 0xffff0000) == (cr_reg | 0x90010000)) ||
		/* stwu Rx, NUM(r1) */
		((op & 0xffff0000) == (cr_reg | 0x94010000))))
	{	/* where Rx == cr */
	  fdata->cr_offset = offset;
a606 6
	  if ((op & 0xfc000003) == 0xf8000000 ||
	      (op & 0xfc000000) == 0x90000000)
	    {
	      /* Does not update r1, so add displacement to cr_offset.  */
	      fdata->cr_offset += SIGNED_SHORT (op);
	    }
d650 1
d652 3
a654 3
      /* update stack pointer */
      else if ((op & 0xfc1f0000) == 0x94010000)
	{		/* stu rX,NUM(r1) ||  stwu rX,NUM(r1) */
d656 2
d661 1
d663 2
a664 17
      else if ((op & 0xfc1f016a) == 0x7c01016e)
	{			/* stwux rX,r1,rY */
	  /* no way to figure out what r1 is going to be */
	  fdata->frameless = 0;
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xfc1f0003) == 0xf8010001)
	{			/* stdu rX,NUM(r1) */
	  fdata->frameless = 0;
	  fdata->offset = SIGNED_SHORT (op & ~3UL);
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xfc1f016a) == 0x7c01016a)
	{			/* stdux rX,r1,rY */
	  /* no way to figure out what r1 is going to be */
d668 2
d671 1
a671 3
      /* Load up minimal toc pointer */
      else if (((op >> 22) == 0x20f	||	/* l r31,... or l r30,... */
	       (op >> 22) == 0x3af)		/* ld r31,... or ld r30,... */
d673 1
a673 1
	{
@


1.133
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.h (legacy_breakpoint_from_pc): Delete declaration.
	* target.h (memory_breakpoint_from_pc): Delete declaration.
	* mem-break.c (memory_breakpoint_from_pc): Delete function.
	* arch-utils.c (legacy_breakpoint_from_pc): Delete function.
	* monitor.c (monitor_insert_breakpoint): Use
	gdbarch_breakpoint_from_pc instead of memory_breakpoint_from_pc.
	* gdbarch.sh (BREAKPOINT_FROM_PC): Do not provide a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sparc-tdep.c (sparc_breakpoint_from_pc): New function.
	(sparc_gdbarch_init): Set breakpoint_from_pc to
	sparc_breakpoint_from_pc.
	* config/sparc/tm-sparc.h (BREAKPOINT): Delete macro.
	(BREAKPOINT_FROM_PC): Define.
	(sparc_breakpoint_from_pc): Declare.
	* hppa-tdep.c (hppa_breakpoint_from_pc): New function.
	* config/pa/tm-hppa.h (hppa_breakpoint_from_pc): Declare.
	(BREAKPOINT_FROM_PC): Define.
	(BREAKPOINT): Delete macro.
	* target.h: Update comment.
	* s390-tdep.c (s390_gdbarch_init): Update comments.
	* remote.c: Update comments.
	* remote-mips.c: Update comments.
	* proc-api.c (write_with_trace): Do not check for a breakpoint.
	* mem-break.c: Update comment.
	* ia64-tdep.c (IA64_BREAKPOINT): Rename BREAKPOINT.
	(ia64_memory_insert_breakpoint): Update.
	* config/sparc/tm-sparc.h: Update comment.
	* config/pa/tm-hppa64.h: Update comment.
	* rs6000-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(rs6000_breakpoint_from_pc): Update.
	* mips-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(PMON_BIG_BREAKPOINT, PMON_LITTLE_BREAKPOINT): Delete macro.
	(IDT_LITTLE_BREAKPOINT, IDT_LITTLE_BREAKPOINT): Delete macro.
	(MIPS16_LITTLE_BREAKPOINT, MIPS16_BIG_BREAKPOINT): Delete macro.
	(mips_breakpoint_from_pc): Update.
	(mips_dump_tdep): Update.
@
text
@d984 1
a984 1
  deprecated_read_register_bytes (0, NULL, REGISTER_BYTES);
d2879 1
a2879 1
  set_gdbarch_register_bytes (gdbarch, off);
@


1.132
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@a307 3
#define BIG_BREAKPOINT { 0x7d, 0x82, 0x10, 0x08 }
#define LITTLE_BREAKPOINT { 0x08, 0x10, 0x82, 0x7d }

d311 2
a312 2
  static unsigned char big_breakpoint[] = BIG_BREAKPOINT;
  static unsigned char little_breakpoint[] = LITTLE_BREAKPOINT;
@


1.131
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d1272 1
a1272 1
  store_address (tmp_buffer, 4, saved_sp);
@


1.131.4.1
log
@Snap const char * mess.
@
text
@d1272 1
a1272 1
  store_unsigned_integer (tmp_buffer, 4, saved_sp);
d1418 1
a1418 1
rs6000_in_solib_return_trampoline (CORE_ADDR pc, const char *name)
d2988 1
a2988 1
rs6000_info_powerpc_command (const char *args, int from_tty)
@


1.131.2.1
log
@Patch from Will Schmidt <willschm@@us.ibm.com>:

These changes enable support of PPC64 architecture.
* config/powerpc/ppc64linux.mh: New file.
* config/powerpc/ppc64linux.mt: New file.
* config/powerpc/tm-ppc64linux.h: New file.
* ppc64-linux-tdep.c: New file.
* configure.host: Add clause for powerpc64-*-linux*
* configure.tgt: Add clause for powerpc64-*-linux*
* elfread.c (record_minimal_symbol_and_info): If
DROP_TEXT_NAME_PREFIX_CHAR is #defined, then drop a leading
instance of that char from the names of text symbols.
(elf_symtab_read): If SKIP_DATA_IN_OPD is #defined, ignore data
symbols in the .opd section.
* ppc-linux-nat.c (PTRACE_XFER_TYPE): Change the default for this
to 'long'.
(PPC_PTRACE_POKEUSR_3264, PPC_PTRACE_PEEKUSR_3264,
PPC_PTRACE_POKEDATA_3264, PPC_PTRACE_PEEKDATA_3264): Provide
default definitions for these.
(ARCH64): New macro.
(ppc_wordsize_pid): New function.
(kernel_u_size): Handle 64-bit case.
(ppc_register_u_addr): Same.
(fetch_register): Use the *_3264 requests when
debugging a 64-bit process from a 32-bit GDB.
(store_register): Same.
(GDB_MAX_ALLOCA, child_xfer_memory, udot_info): Copied from
infptrace.c.
(_initialize_ppc_linux_nat): New function, to register our copy of
the udot_info command.
* ppc-linux-tdep.c (TDEP): New macro.
(ppc64_linux_svr4_fetch_link_map_offsets): New function.
(read_memory_addr): Copied from rs6000-tdep.c.
(ppc64_linux_convert_from_func_ptr_addr): New function.
* rs6000-tdep.c (skip_prologue): Recognize more instructions for
saving the 'lr' and 'cr' registers; don't just pre-emptively mask
in the 'st' opcode as soon as we see an 'mflr' or 'mfcr' opcode.
Recognize more instructions for updating the stack pointer, and
loading the TOC pointer.
(registers_powerpc64, registers_a35): New register tables.
(rs6000_gdbarch_init): Register the 64-bit solib functions.
* solib-svr4.c (solib_break_names): If SOLIB_BREAK_NAME is
#defined, include an entry for it.
(enable_break): Call CONVERT_FROM_FUNC_PTR_ADDR when trying to
guess the linker's base address.
* config/powerpc/tm-linux.h
(ppc64_linux_svr4_fetch_link_map_offsets,
ppc64_linux_convert_from_func_ptr_addr): New declarations.
@
text
@d532 1
a532 1
	  lr_reg = (op & 0x03e00000);
d538 1
a538 1
	  cr_reg = (op & 0x03e00000);
d564 1
a564 1
		op &= ~3UL;
d596 4
a599 9
      else if (lr_reg != -1 &&
	       /* std Rx || stdu Rx */
	       (((op & 0xffff0000) == (lr_reg | 0xf8010000)) ||
		/* stw Rx */
		((op & 0xffff0000) == (lr_reg | 0x90010000)) ||
		/* stwu Rx */
		((op & 0xffff0000) == (lr_reg | 0x94010000))))
	{	/* where Rx == lr */
	  fdata->lr_offset = offset;
a601 25
	  if ((op & 0xfc000003) == 0xf8000000 ||	/* std Rx */
	      (op & 0xfc000000) == 0x90000000)		/* stw Rx */
	    {
	      /* does not update r1 add d to lr_offset */
	      fdata->lr_offset = SIGNED_SHORT (op);
	    }
	  continue;

	}
      else if (cr_reg != -1 &&
	       /* std Rx || stdu Rx */
	       (((op & 0xffff0000) == (cr_reg | 0xf8010000)) ||
		/* stw Rx */
		((op & 0xffff0000) == (cr_reg | 0x90010000)) ||
		/* stwu Rx */
		((op & 0xffff0000) == (cr_reg | 0x94010000))))
	{	/* where Rx == cr */
	  fdata->cr_offset = offset;
	  cr_reg = 0;
	  if ((op & 0xfc000003) == 0xf8000000 ||
	      (op & 0xfc000000) == 0x90000000)
	    {
	      /* does not update r1 add d to cr_offset */
	      fdata->cr_offset += SIGNED_SHORT (op);
	    }
d605 2
a606 2
      else if (cr_reg != -1 && (op & 0xffff0003) == cr_reg)
	{			/* std Rx,NUM(r1) || stdu Rx,NUM(r1) 
d608 1
a608 1
	  fdata->cr_offset = SIGNED_SHORT (op & ~3UL) + offset;
d653 1
d655 3
a657 3
      /* update stack pointer */
      else if ((op & 0xfc1f0000) == 0x94010000)
	{		/* stu rX,NUM(r1) ||  stwu rX,NUM(r1) */
d659 2
d664 1
d666 2
a667 17
      else if ((op & 0xfc1f016a) == 0x7c01016e)
	{			/* stwux rX,r1,rY */
	  /* no way to figure out what r1 is going to be */
	  fdata->frameless = 0;
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xfc1f0003) == 0xf8010001)
	{			/* stdu rX,NUM(r1) */
	  fdata->frameless = 0;
	  fdata->offset = SIGNED_SHORT (op & ~3UL);
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xfc1f016a) == 0x7c01016a)
	{			/* stdux rX,r1,rY */
	  /* no way to figure out what r1 is going to be */
d671 2
d674 1
a674 3
      /* Load up minimal toc pointer */
      else if (((op >> 22) == 0x20f	||	/* l r31,... or l r30,... */
	       (op >> 22) == 0x3af)		/* ld r31,... or ld r30,... */
d676 1
a676 1
	{
a2458 38

/* PowerPC UISA - a PPC64 processor as viewed by user-level code. */
/* Should be able to use the common registers_powerpc[] here, however
   it does not define an fpscr, though both linux and aix get one from
   ptrace(). Can only assume that there is a 32-bit core our there
   that does not have an fpscr.  I think we can assert that all 64-bit
   cores do. */
static const struct reg registers_powerpc64[] =
{
  COMMON_UISA_REGS,
  /* SPRs */
  /*  66 */ R4(cr), R(lr), R(ctr), R4(xer),
  /*  70 */ R4(fpscr), R0 /* mq? */
};

static const struct reg registers_a35[] =
{
  COMMON_UISA_REGS,
  /* SPRs */
  /*  66 */ R4(cr), R(lr), R(ctr), R4(xer),
  /*  70 */ R4(fpscr), R0 /* mq? */,
  /*  72 */ R(dabr), R(iabr), R4(dsisr),
  /*  75 */ R(dar), R4(dec), R(sdr1), R(srr0), R(srr1),
  /*  80 */ R(sprg0), R(sprg1), R(sprg2), R(sprg3),
  /*  84 */ R64(asr), R4(ear), R4(tbl), R4(tbu),
  /*  88 */ R(ibat0u), R(ibat0l), R(ibat1u), R(ibat1l),
  /*  92 */ R(ibat2u), R(ibat2l), R(ibat3u), R(ibat3l),
  /*  96 */ R(dbat0u), R(dbat0l), R(dbat1u), R(dbat1l),
  /* 100 */ R(dbat2u), R(dbat2l), R(dbat3u), R(dbat3l),
  /* 104 */ R(pir), R4(mmcr0),
  /* 106..121 segment regs 0..15 */ 
  /* 106 */ R(sr0), R(sr1), R(sr2), R(sr3),
  /* 110 */ R(sr4), R(sr5), R(sr6), R(sr7),
  /* 114 */ R(sr8), R(sr9), R(sr10), R(sr11),
  /* 118 */ R(sr12), R(sr13), R(sr14), R(sr15),
  /* 122 */ R4(pvr) /* processor version register */
};

a2958 9

      /* wordsize 8, ppc64 linux  functions */
      if (osabi == ELFOSABI_LINUX)
      {
	  set_solib_svr4_fetch_link_map_offsets
	    (gdbarch, ppc64_linux_svr4_fetch_link_map_offsets);
	  set_gdbarch_convert_from_func_ptr_addr
            (gdbarch, ppc64_linux_convert_from_func_ptr_addr);
      }
@


1.130
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d1742 1
a1742 1
    char *tmpbuf = alloca (MAX_REGISTER_RAW_SIZE);
d1924 1
a1924 1
  char *temp_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d1947 1
a1947 1
  char *temp_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
@


1.129
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d2881 1
a2881 1
  set_gdbarch_register_size (gdbarch, wordsize);
d2903 1
a2903 1
  set_gdbarch_fix_call_dummy (gdbarch, rs6000_fix_call_dummy);
@


1.128
log
@	* rs6000-tdep.c (rs6000_gdbarch_init): For the SVR4 ABI, set
	the size of ``long double'' to 16, instead of 8.
@
text
@d2800 1
a2800 1
  set_gdbarch_fp_regnum (gdbarch, 1);
d2833 1
a2833 1
        set_gdbarch_fp_regnum (gdbarch, tdep->ppc_gp0_regnum + 1);
a2874 1
  set_gdbarch_read_fp (gdbarch, generic_target_read_fp);
@


1.128.2.1
log
@Merge from mainline.
@
text
@d2800 1
a2800 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 1);
d2833 1
a2833 1
        set_gdbarch_deprecated_fp_regnum (gdbarch, tdep->ppc_gp0_regnum + 1);
d2875 1
@


1.128.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d308 3
d314 2
a315 2
  static unsigned char big_breakpoint[] = { 0x7d, 0x82, 0x10, 0x08 };
  static unsigned char little_breakpoint[] = { 0x08, 0x10, 0x82, 0x7d };
d987 1
a987 1
  deprecated_read_register_bytes (0, NULL, DEPRECATED_REGISTER_BYTES);
d1272 1
a1272 1
  store_unsigned_integer (tmp_buffer, 4, saved_sp);
d1742 1
a1742 1
    char tmpbuf[MAX_REGISTER_SIZE];
d1924 1
a1924 1
  char temp_buffer[MAX_REGISTER_SIZE];
d1947 1
a1947 1
  char temp_buffer[MAX_REGISTER_SIZE];
d2881 2
a2882 2
  set_gdbarch_deprecated_register_size (gdbarch, wordsize);
  set_gdbarch_deprecated_register_bytes (gdbarch, off);
d2903 1
a2903 1
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, rs6000_fix_call_dummy);
@


1.127
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d2898 4
a2901 1
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
@


1.126
log
@	* rs6000-tdep.c (frame_get_saved_regs): Don't assume that the
	register number for R0 is 0.
@
text
@d2960 1
a2960 1
  set_gdbarch_saved_pc_after_call (gdbarch, rs6000_saved_pc_after_call);
@


1.125
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	* doublest.h: Update copyright.
	(deprecated_store_floating, deprecated_extract_floating): Rename
	store_floating and extract_floating.  Update comments.
	* doublest.c: Update copyright.
	(extract_floating_by_length): Replace extract_floating.
	(store_floating_by_length): Replace store_floating.
	(deprecated_extract_floating): New function.
	(deprecated_store_floating): New function.
	(extract_typed_floating): Call extract_floating_by_length.
	(store_typed_floating): Call store_floating_by_length.
	* x86-64-tdep.c (x86_64_store_return_value): Update.
	* sh-tdep.c (sh3e_sh4_extract_return_value): Update.
	(sh64_extract_return_value): Update.
	(sh_sh4_register_convert_to_virtual): Update.
	(sh_sh64_register_convert_to_virtual): Update.
	(sh_sh4_register_convert_to_raw): Update.
	(sh_sh64_register_convert_to_raw): Update.
	* rs6000-tdep.c (rs6000_register_convert_to_virtual): Update.
	(rs6000_register_convert_to_raw): Update.
	* ia64-tdep.c (ia64_register_convert_to_virtual): Update.
	(ia64_register_convert_to_raw): Update.
	* config/i386/tm-symmetry.h (REGISTER_CONVERT_TO_RAW): Update.
	(REGISTER_CONVERT_TO_VIRTUAL): Update.
	* arm-linux-tdep.c (arm_linux_push_arguments): Update.
	* alpha-tdep.c (alpha_register_convert_to_virtual): Update.
	(alpha_register_convert_to_raw): Update.
@
text
@d1649 1
a1649 1
	  get_frame_saved_regs (fi)[i] = gpr_addr;
@


1.124
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@d1895 2
a1896 2
      double val = extract_floating (from, REGISTER_RAW_SIZE (n));
      store_floating (to, TYPE_LENGTH (type), val);
d1911 2
a1912 2
      double val = extract_floating (from, TYPE_LENGTH (type));
      store_floating (to, REGISTER_RAW_SIZE (n), val);
@


1.123
log
@	* rs6000-tdep.c (rs6000_gdbarch_init): For xcoff executables, set
	``mach'' to the value determined by bfd_default_set_arch_mach().
@
text
@d993 1
a993 1
  addr = get_pc_function_start (get_frame_pc (frame));
d1502 1
a1502 1
  func_start = get_pc_function_start (get_frame_pc (fi));
d1543 1
a1543 1
  func_start = get_pc_function_start (get_frame_pc (fi));
d1599 1
a1599 2
      (void) skip_prologue (get_pc_function_start (get_frame_pc (fi)),
			    get_frame_pc (fi), fdatap);
d1722 1
a1722 2
  (void) skip_prologue (get_pc_function_start (get_frame_pc (fi)),
			get_frame_pc (fi), &fdata);
@


1.122
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d2744 1
a2744 2
      mach = 0;
      bfd_default_set_arch_mach (&abfd, arch, mach);
d2746 1
@


1.122.2.1
log
@Merge with mainline.
@
text
@d993 1
a993 1
  addr = get_frame_func (frame);
d1502 1
a1502 1
  func_start = get_frame_func (fi);
d1543 1
a1543 1
  func_start = get_frame_func (fi);
d1599 2
a1600 1
      (void) skip_prologue (get_frame_func (fi), get_frame_pc (fi), fdatap);
d1650 1
a1650 1
	  get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = gpr_addr;
d1723 2
a1724 1
  (void) skip_prologue (get_frame_func (fi), get_frame_pc (fi), &fdata);
d1897 2
a1898 2
      double val = deprecated_extract_floating (from, REGISTER_RAW_SIZE (n));
      deprecated_store_floating (to, TYPE_LENGTH (type), val);
d1913 2
a1914 2
      double val = deprecated_extract_floating (from, TYPE_LENGTH (type));
      deprecated_store_floating (to, REGISTER_RAW_SIZE (n), val);
d2744 2
a2745 1
      bfd_default_set_arch_mach (&abfd, arch, 0);
a2746 1
      mach = info.bfd_arch_info->mach;
@


1.121
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@a2902 2
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
@


1.120
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Include "symfile.h".
	(CALL_DUMMY_ADDRESS): Default to entry_point_address.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_ADDRESS): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_address, the default is at entry_point_address.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a2903 2
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
@


1.119
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a2903 1
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
@


1.118
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@d2079 4
a2082 4
     the current hand_function_call() code only saves the most recent
     struct address leading to occasional calls.  The code should
     instead maintain a stack of such addresses (in the dummy frame
     object).  */
a2907 1
  set_gdbarch_call_dummy_p (gdbarch, 1);
@


1.117
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@d2879 1
a2879 1
  set_gdbarch_write_sp (gdbarch, generic_target_write_sp);
@


1.116
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@d2912 1
a2912 1
  set_gdbarch_push_return_address (gdbarch, ppc_push_return_address);
@


1.115
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d2927 1
a2927 1
    set_gdbarch_push_arguments (gdbarch, ppc_sysv_abi_push_arguments);
d2929 1
a2929 1
    set_gdbarch_push_arguments (gdbarch, rs6000_push_arguments);
@


1.115.2.1
log
@Merge with mainline.
@
text
@d2879 1
a2879 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
d2912 1
a2912 1
  set_gdbarch_deprecated_push_return_address (gdbarch, ppc_push_return_address);
d2927 1
a2927 1
    set_gdbarch_deprecated_push_arguments (gdbarch, ppc_sysv_abi_push_arguments);
d2929 1
a2929 1
    set_gdbarch_deprecated_push_arguments (gdbarch, rs6000_push_arguments);
@


1.114
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@d2931 1
a2931 1
  set_gdbarch_store_struct_return (gdbarch, rs6000_store_struct_return);
@


1.113
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@a2908 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
@


1.112
log
@2003-03-17  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (ppc_floating_point_unit_p): New function.
	* ppc-tdep.h (ppc_floating_point_unit_p): Declare.

	From Elena Zannoni  <ezannoni@@redhat.com>
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Handle e500
	vector and floating-point parameters.
	(ppc_sysv_abi_use_struct_convention): Handle e500 struct return
	convention.
	(ppc_sysv_abi_broken_use_struct_convention): Ditto.
@
text
@d1569 2
a1570 1
	return read_memory_addr (FRAME_CHAIN (fi) + tdep->lr_frame_offset,
d1577 2
a1578 1
  return read_memory_addr (FRAME_CHAIN (fi) + fdata.lr_offset, wordsize);
d1625 1
a1625 1
    frame_addr = FRAME_CHAIN (fi);
d1763 2
a1764 2
/* FRAME_CHAIN takes a frame's nominal address
   and produces the frame's chain-pointer.  */
d2954 1
a2954 1
  set_gdbarch_frame_chain (gdbarch, rs6000_frame_chain);
@


1.111
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d140 12
@


1.110
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d2920 1
a2920 1
  set_gdbarch_pop_frame (gdbarch, rs6000_pop_frame);
@


1.109
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d2941 1
a2941 1
  set_gdbarch_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);
@


1.109.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d2920 1
a2920 1
  set_gdbarch_deprecated_pop_frame (gdbarch, rs6000_pop_frame);
d2941 1
a2941 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);
@


1.108
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d2874 1
a2874 1
  set_gdbarch_max_register_raw_size (gdbarch, 16);
d2876 1
a2876 1
  set_gdbarch_max_register_virtual_size (gdbarch, 16);
@


1.107
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d2943 1
a2943 1
  set_gdbarch_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
@


1.106
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d2944 1
a2944 1
  set_gdbarch_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);
@


1.105
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@a2897 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
@


1.104
log
@2003-02-19  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c: Include "gdb_assert.h".
	(registers_e500): Add "acc" and "spefscr".
	(PPC_GPRS_PSEUDO_REGS): Remove trailing comma.
	(rs6000_gdbarch_init): Update initialization of ppc_gp0_regnum,
	ppc_gplast_regnum, sp_regnum and fp_regnum.  Check that gp0_regnum
	really is "r0".
	(registers_e500): Mark the "acc" as a 64 bit (from Jim Willson).
@
text
@d1447 1
a1447 1
  if (msymbol && rs6000_in_solib_return_trampoline (pc, SYMBOL_NAME (msymbol)))
@


1.103
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d50 2
d2276 1
a2276 1
  /* 24 */ P(r24),P(r25),P(r26),P(r27),P(r28),P(r29),P(r30),P(r31), \
d2455 3
d2809 2
a2810 2
        tdep->ppc_gp0_regnum = 39;
        tdep->ppc_gplast_regnum = 70;
d2820 2
a2821 2
        set_gdbarch_sp_regnum (gdbarch, 40);
        set_gdbarch_fp_regnum (gdbarch, 40);
d2835 3
@


1.102
log
@	* arch-utils.c (gdbarch_info_init): Set osabi to
	GDB_OSABI_UNINITIALIZED.
	* gdbarch.sh: Add osabi to struct gdbarch and to struct
	gdbarch_info.  Include "osabi.h" in gdbarch.c.  Check osabi
	in gdbarch_list_lookup_by_info and in gdbarch_update_p.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* osabi.c (gdbarch_lookup_osabi): Return GDB_OSABI_UNINITIALIZED if
	there's no BFD.
	(gdbarch_init_osabi): Remove osabi argument; use info.osabi.
	* osabi.h (enum gdb_osabi): Move to defs.h.
	(gdbarch_init_osabi): Update prototype.
	* defs.h (enum gdb_osabi): Moved here.
	* Makefile.in: Update dependencies.

Plus updates to alpha, arm, hppa, i386, mips, ns32k, ppc, sh, sparc, and vax
ports to match.
@
text
@a2930 2
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);

@


1.101
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@d37 1
a2660 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
a2670 3
  if (info.abfd)
    osabi = gdbarch_lookup_osabi (info.abfd);

d2705 1
a2705 1
      if (tdep && tdep->wordsize == wordsize && tdep->osabi == osabi)
a2730 1
  tdep->osabi = osabi;
d2957 1
a2957 1
  gdbarch_init_osabi (info, gdbarch, osabi);
d2970 1
a2970 2
  fprintf_unfiltered (file, "rs6000_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
@


1.100
log
@2002-12-18  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (rs6000_init_extra_frame_info): Use
	frame_extra_info_zalloc.
	(rs6000_frame_args_address): Use get_frame_extra_info.
	(frame_get_saved_regs): Use get_frame_saved_regs.
	(frame_initial_stack_address): Use get_frame_saved_regs and
	get_frame_extra_info.
	(frame_initial_stack_address): Use get_frame_extra_info.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002
a1857 11
/* For the PowerPC, it appears that the debug info marks float parameters as
   floats regardless of whether the function is prototyped, but the actual
   values are always passed in as doubles.  Tell gdb to always assume that
   floats are passed as doubles and then converted in the callee.  */

static int
rs6000_coerce_float_to_double (struct type *formal, struct type *actual)
{
  return 1;
}

a2897 1
  set_gdbarch_coerce_float_to_double (gdbarch, rs6000_coerce_float_to_double);
@


1.99
log
@2002-12-07  Andrew Cagney  <ac131313@@redhat.com>

	* f-valprint.c (info_common_command): Use get_frame_pc.
	* std-regs.c (value_of_builtin_frame_pc_reg): Ditto.
	* ax-gdb.c (agent_command): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	(rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc, frame_get_saved_regs): Ditto.
	(frame_initial_stack_address, rs6000_frame_chain): Ditto.
	* macroscope.c (default_macro_scope): Ditto.
	* stack.c (print_frame_info_base): Ditto.
	(print_frame, frame_info, print_frame_label_vars): Ditto.
	(return_command, func_command, get_frame_language): Ditto.
	* infcmd.c (finish_command): Ditto.
	* dummy-frame.c (cached_find_dummy_frame): Ditto.
	* breakpoint.c (deprecated_frame_in_dummy): Ditto.
	(break_at_finish_at_depth_command_1): Ditto.
	(break_at_finish_command_1): Ditto.
	(until_break_command, get_catch_sals): Ditto.
	* blockframe.c (func_frame_chain_valid): Ditto.
	(frameless_look_for_prologue): Ditto.
	(frame_address_in_block, generic_func_frame_chain_valid): Ditto.
@
text
@d169 3
a171 3
  fi->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));
  fi->extra_info->initial_sp = 0;
d200 3
a202 2
  if (fi->extra_info->initial_sp != 0)
    return fi->extra_info->initial_sp;
d1576 1
a1576 1
  if (fi->saved_regs)
d1619 1
a1619 1
	  fi->saved_regs[FP0_REGNUM + i] = fpr_addr;
d1633 1
a1633 1
	  fi->saved_regs[i] = gpr_addr;
d1648 1
a1648 1
	      fi->saved_regs[tdep->ppc_vr0_regnum + i] = vr_addr;
d1664 2
a1665 2
	      fi->saved_regs[tdep->ppc_ev0_regnum + i] = ev_addr;
              fi->saved_regs[tdep->ppc_gp0_regnum + i] = ev_addr + 4;
d1674 1
a1674 1
    fi->saved_regs[tdep->ppc_cr_regnum] = frame_addr + fdatap->cr_offset;
d1679 1
a1679 1
    fi->saved_regs[tdep->ppc_lr_regnum] = frame_addr + fdatap->lr_offset;
d1684 1
a1684 1
    fi->saved_regs[tdep->ppc_vrsave_regnum] = frame_addr + fdatap->vrsave_offset;
d1701 2
a1702 2
  if (fi->extra_info->initial_sp)
    return fi->extra_info->initial_sp;
d1712 1
a1712 1
  if (!fi->saved_regs)
d1720 2
a1721 2
      fi->extra_info->initial_sp = get_frame_base (fi);
      return fi->extra_info->initial_sp;
d1730 1
a1730 1
	fi->extra_info->initial_sp
d1738 1
a1738 1
      fi->extra_info->initial_sp = get_frame_base (fi);
d1740 1
a1740 1
  return fi->extra_info->initial_sp;
@


1.98
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* blockframe.c: Use get_frame_base instead of directly accessing
	the `struct frame_info' member frame.
	* f-valprint.c, std-regs.c, rs6000-tdep.c: Ditto.
	* stack.c, dummy-frame.c, breakpoint.c: Ditto.
@
text
@d172 2
a173 2
  if (get_next_frame (fi) != (CORE_ADDR) 0
      && fi->pc < TEXT_SEGMENT_BASE)
d961 1
a961 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc,
d977 2
a978 2
  addr = get_pc_function_start (frame->pc);
  (void) skip_prologue (addr, frame->pc, &fdata);
d1486 1
a1486 1
  func_start = get_pc_function_start (fi->pc);
d1497 1
a1497 1
      if (fi->pc == 0)
d1503 1
a1503 1
  (void) skip_prologue (func_start, fi->pc, &fdata);
d1521 1
a1521 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc,
d1524 1
a1524 1
    return deprecated_read_register_dummy (fi->pc,
d1527 1
a1527 1
  func_start = get_pc_function_start (fi->pc);
d1534 1
a1534 1
  (void) skip_prologue (func_start, fi->pc, &fdata);
d1542 1
a1542 1
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_next_frame (fi)->pc, 0, 0))
d1581 2
a1582 1
      (void) skip_prologue (get_pc_function_start (fi->pc), fi->pc, fdatap);
d1705 2
a1706 1
  (void) skip_prologue (get_pc_function_start (fi->pc), fi->pc, &fdata);
d1757 1
a1757 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (thisframe->pc,
d1764 2
a1765 2
  if (inside_entry_file (thisframe->pc) ||
      thisframe->pc == entry_point_address ())
@


1.97
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (frame_info): Use get_prev_frame.
	* blockframe.c (frame_address_in_block): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	(rs6000_frame_chain): Ditto.
	* arch-utils.c (init_frame_pc_default): Ditto.
@
text
@d264 1
a264 1
		dest = read_memory_addr (fi->frame + SIG_FRAME_PC_OFFSET,
d961 3
a963 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1518 2
a1519 1
    return read_memory_addr (fi->frame + SIG_FRAME_PC_OFFSET, wordsize);
d1521 5
a1525 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return deprecated_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
d1539 2
a1540 2
	return read_memory_addr (get_next_frame (fi)->frame
				 + SIG_FRAME_LR_OFFSET,
d1717 1
a1717 1
      fi->extra_info->initial_sp = fi->frame;
d1735 1
a1735 1
      fi->extra_info->initial_sp = fi->frame;
d1755 3
a1757 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (thisframe->pc, thisframe->frame, thisframe->frame))
d1760 1
a1760 1
    return read_memory_addr ((thisframe)->frame, wordsize);
d1767 2
a1768 2
    fp = read_memory_addr (thisframe->frame + SIG_FRAME_FP_OFFSET,
			      wordsize);
d1776 1
a1776 1
    fp = read_memory_addr ((thisframe)->frame, wordsize);
@


1.96
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d172 1
a172 1
  if (fi->next != (CORE_ADDR) 0
d1480 2
a1481 1
  if (fi->next != NULL && !(get_frame_type (fi->next) == SIGTRAMP_FRAME))
d1530 1
a1530 1
  if (fdata.lr_offset == 0 && fi->next != NULL)
d1532 3
a1534 2
      if ((get_frame_type (fi->next) == SIGTRAMP_FRAME))
	return read_memory_addr (fi->next->frame + SIG_FRAME_LR_OFFSET,
d1761 2
a1762 2
  else if (thisframe->next != NULL
	   && (get_frame_type (thisframe->next) == SIGTRAMP_FRAME)
@


1.95
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d961 1
a961 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1517 1
a1517 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1534 1
a1534 1
      else if (PC_IN_CALL_DUMMY (get_next_frame (fi)->pc, 0, 0))
d1747 1
a1747 1
  if (PC_IN_CALL_DUMMY (thisframe->pc, thisframe->frame, thisframe->frame))
@


1.94
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@a2882 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
a2883 1
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
a2887 1
  set_gdbarch_pc_in_call_dummy (gdbarch, generic_pc_in_call_dummy);
@


1.93
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@d959 1
a959 1
  sp = FRAME_FP (frame);
d1764 1
a1764 1
    fp = FRAME_FP (thisframe);
@


1.92
log
@2002-11-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (generic_unwind_get_saved_register): Make static.
	* frame.h (generic_unwind_get_saved_register): Delete declaration.
	* avr-tdep.c (avr_gdbarch_init): Do not set get_saved_register,
	defaults to generic_unwind_get_saved_register.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* config/mn10200/tm-mn10200.h (GET_SAVED_REGISTER): Delete macro.
@
text
@d178 1
a178 1
    fi->signal_handler_caller = 1;
d1480 1
a1480 1
  if (fi->next != NULL && !fi->next->signal_handler_caller)
d1514 1
a1514 1
  if (fi->signal_handler_caller)
d1531 1
a1531 1
      if (fi->next->signal_handler_caller)
d1756 1
a1756 1
  if (thisframe->signal_handler_caller)
d1760 1
a1760 1
	   && thisframe->next->signal_handler_caller
@


1.91
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@a2892 1
  set_gdbarch_get_saved_register (gdbarch, generic_unwind_get_saved_register);
@


1.90
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d998 2
a999 1
	  read_memory (addr, &registers[REGISTER_BYTE (ii)], wordsize);
d1009 1
a1009 1
	  read_memory (addr, &registers[REGISTER_BYTE (ii + FP0_REGNUM)], 8);
d1126 1
a1126 1
	  memcpy (&registers[REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1138 3
a1140 2
	      memset (&registers[REGISTER_BYTE (ii + 3)], 0, reg_size);
	      memcpy (&registers[REGISTER_BYTE (ii + 3)],
d1156 2
a1157 2
	  memset (&registers[REGISTER_BYTE (ii + 3)], 0, reg_size);
	  memcpy ((char *)&registers[REGISTER_BYTE (ii + 3)] + adj, 
d1239 1
a1239 1
	      memcpy (&registers[REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
@


1.89
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d969 1
a969 1
  read_register_bytes (0, NULL, REGISTER_BYTES);
d2033 2
a2034 2
    write_register_bytes (REGISTER_BYTE (FP0_REGNUM + 1), valbuf,
			  TYPE_LENGTH (type));
d2039 2
a2040 2
	write_register_bytes (REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
			      valbuf, TYPE_LENGTH (type));
d2044 2
a2045 2
    write_register_bytes (REGISTER_BYTE (gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + 3),
			  valbuf, TYPE_LENGTH (type));
@


1.88
log
@2002-10-02  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (rs6000_store_struct_return): Store struct_return
	value in register 3 adjusted by ppc_gp0_regnum.
@
text
@d2017 1
a2017 1
      write_register_gen (regnum, reg_val_buf);
@


1.88.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003
a36 1
#include "osabi.h"
a48 3
#include "gdb_assert.h"
#include "dis-asm.h"

a136 12
/* Use the architectures FP registers?  */
int
ppc_floating_point_unit_p (struct gdbarch *gdbarch)
{
  const struct bfd_arch_info *info = gdbarch_bfd_arch_info (gdbarch);
  if (info->arch == bfd_arch_powerpc)
    return (info->mach != bfd_mach_ppc_e500);
  if (info->arch == bfd_arch_rs6000)
    return 1;
  return 0;
}

d169 5
a173 5
  struct frame_extra_info *extra_info =
    frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
  extra_info->initial_sp = 0;
  if (get_next_frame (fi) != NULL
      && get_frame_pc (fi) < TEXT_SEGMENT_BASE)
d178 1
a178 1
    deprecated_set_frame_type (fi, SIGTRAMP_FRAME);
d200 2
a201 3
  struct frame_extra_info *extra_info = get_frame_extra_info (fi);
  if (extra_info->initial_sp != 0)
    return extra_info->initial_sp;
a216 10
/* Get the ith function argument for the current function.  */
static CORE_ADDR
rs6000_fetch_pointer_argument (struct frame_info *frame, int argi, 
			       struct type *type)
{
  CORE_ADDR addr;
  get_frame_register (frame, 3 + argi, &addr);
  return addr;
}

d264 1
a264 1
		dest = read_memory_addr (get_frame_base (fi) + SIG_FRAME_PC_OFFSET,
d292 3
d298 2
a299 2
  static unsigned char big_breakpoint[] = { 0x7d, 0x82, 0x10, 0x08 };
  static unsigned char little_breakpoint[] = { 0x08, 0x10, 0x82, 0x7d };
d516 1
a516 1
	  lr_reg = (op & 0x03e00000);
d522 1
a522 1
	  cr_reg = (op & 0x03e00000);
d548 1
a548 1
		op &= ~3UL;
d580 4
a583 9
      else if (lr_reg != -1 &&
	       /* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
	       (((op & 0xffff0000) == (lr_reg | 0xf8010000)) ||
		/* stw Rx, NUM(r1) */
		((op & 0xffff0000) == (lr_reg | 0x90010000)) ||
		/* stwu Rx, NUM(r1) */
		((op & 0xffff0000) == (lr_reg | 0x94010000))))
	{	/* where Rx == lr */
	  fdata->lr_offset = offset;
a585 6
	  if ((op & 0xfc000003) == 0xf8000000 ||	/* std */
	      (op & 0xfc000000) == 0x90000000)		/* stw */
	    {
	      /* Does not update r1, so add displacement to lr_offset.  */
	      fdata->lr_offset += SIGNED_SHORT (op);
	    }
d589 4
a592 9
      else if (cr_reg != -1 &&
	       /* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
	       (((op & 0xffff0000) == (cr_reg | 0xf8010000)) ||
		/* stw Rx, NUM(r1) */
		((op & 0xffff0000) == (cr_reg | 0x90010000)) ||
		/* stwu Rx, NUM(r1) */
		((op & 0xffff0000) == (cr_reg | 0x94010000))))
	{	/* where Rx == cr */
	  fdata->cr_offset = offset;
a593 6
	  if ((op & 0xfc000003) == 0xf8000000 ||
	      (op & 0xfc000000) == 0x90000000)
	    {
	      /* Does not update r1, so add displacement to cr_offset.  */
	      fdata->cr_offset += SIGNED_SHORT (op);
	    }
d637 1
d639 3
a641 3
      /* update stack pointer */
      else if ((op & 0xfc1f0000) == 0x94010000)
	{		/* stu rX,NUM(r1) ||  stwu rX,NUM(r1) */
d643 2
d648 1
d650 2
a651 3
      else if ((op & 0xfc1f016a) == 0x7c01016e)
	{			/* stwux rX,r1,rY */
	  /* no way to figure out what r1 is going to be */
d655 2
d658 1
a658 17
      else if ((op & 0xfc1f0003) == 0xf8010001)
	{			/* stdu rX,NUM(r1) */
	  fdata->frameless = 0;
	  fdata->offset = SIGNED_SHORT (op & ~3UL);
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xfc1f016a) == 0x7c01016a)
	{			/* stdux rX,r1,rY */
	  /* no way to figure out what r1 is going to be */
	  fdata->frameless = 0;
	  offset = fdata->offset;
	  continue;
	}
      /* Load up minimal toc pointer */
      else if (((op >> 22) == 0x20f	||	/* l r31,... or l r30,... */
	       (op >> 22) == 0x3af)		/* ld r31,... or ld r30,... */
d660 1
a660 1
	{
d931 1
a931 2
	  if (tmp >= 0
	      && strcmp (misc_function_vector[tmp].name, main_name ()) == 0)
d959 1
a959 1
  sp = get_frame_base (frame);
d961 1
a961 3
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
d969 1
a969 1
  deprecated_read_register_bytes (0, NULL, DEPRECATED_REGISTER_BYTES);
d975 2
a976 2
  addr = get_frame_func (frame);
  (void) skip_prologue (addr, get_frame_pc (frame), &fdata);
d998 1
a998 2
	  read_memory (addr, &deprecated_registers[DEPRECATED_REGISTER_BYTE (ii)],
		       wordsize);
d1008 1
a1008 1
	  read_memory (addr, &deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + FP0_REGNUM)], 8);
d1018 19
d1061 2
a1062 4
rs6000_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
a1063 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1078 1
a1078 2
     Copy them appropriately.  */
  ii = 0;
d1080 6
a1085 10
  /* If the function is returning a `struct', then the first word
     (which will be passed in r3) is used for struct return address.
     In that case we should advance one word and start from r4
     register to copy parameters.  */
  if (struct_return)
    {
      regcache_raw_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
				   struct_addr);
      ii++;
    }
d1108 1
a1108 1
      int reg_size = DEPRECATED_REGISTER_RAW_SIZE (ii + 3);
d1125 1
a1125 1
	  memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1137 2
a1138 3
	      memset (&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)], 0,
		      reg_size);
	      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)],
d1154 2
a1155 2
	  memset (&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)], 0, reg_size);
	  memcpy ((char *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)] + adj, 
d1199 8
d1237 1
a1237 1
	      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1247 3
d1252 1
a1252 1
  store_unsigned_integer (tmp_buffer, 4, saved_sp);
d1255 14
a1268 9
  /* Set the stack pointer.  According to the ABI, the SP is meant to
     be set _before_ the corresponding stack space is used.  No need
     for that here though - the target has been completely stopped -
     it isn't possible for an exception handler to stomp on the stack.  */
  regcache_raw_write_signed (regcache, SP_REGNUM, sp);

  /* Point the inferior function call's return address at the dummy's
     breakpoint.  */
  regcache_raw_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);
d1270 12
a1281 3
  /* Set the TOC register, get the value from the objfile reader
     which, in turn, gets it from the VMAP table.  */
  if (rs6000_find_toc_address_hook != NULL)
d1283 1
a1283 2
      CORE_ADDR tocvalue = (*rs6000_find_toc_address_hook) (func_addr);
      regcache_raw_write_signed (regcache, tdep->ppc_toc_regnum, tocvalue);
d1285 11
d1297 8
a1304 3
  target_store_registers (-1);
  return sp;
}
d1306 5
a1310 2
/* PowerOpen always puts structures in memory.  Vectors, which were
   added later, do get returned in a register though.  */
d1312 15
a1326 7
static int     
rs6000_use_struct_convention (int gcc_p, struct type *value_type)
{  
  if ((TYPE_LENGTH (value_type) == 16 || TYPE_LENGTH (value_type) == 8)
      && TYPE_VECTOR (value_type))
    return 0;                            
  return 1;
d1346 1
a1346 1
		&regbuf[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1)],
d1350 1
a1350 1
	  memcpy (&dd, &regbuf[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1)], 8);
d1359 1
a1359 1
      memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
d1366 2
a1367 2
	  && TYPE_LENGTH (valtype) < DEPRECATED_REGISTER_RAW_SIZE (3))
	offset = DEPRECATED_REGISTER_RAW_SIZE (3) - TYPE_LENGTH (valtype);
d1370 1
a1370 1
	      regbuf + DEPRECATED_REGISTER_BYTE (3) + offset,
d1420 1
a1420 1
  unsigned int ii, op;
d1439 1
a1439 1
  if (msymbol && rs6000_in_solib_return_trampoline (pc, DEPRECATED_SYMBOL_NAME (msymbol)))
d1478 1
a1478 2
  if (get_next_frame (fi) != NULL
      && !(get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
d1481 1
a1481 1
  func_start = get_frame_func (fi);
d1492 1
a1492 1
      if (get_frame_pc (fi) == 0)
d1498 1
a1498 1
  (void) skip_prologue (func_start, get_frame_pc (fi), &fdata);
d1512 5
a1516 9
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
    return read_memory_addr (get_frame_base (fi) + SIG_FRAME_PC_OFFSET,
			     wordsize);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi),
				   get_frame_base (fi),
				   get_frame_base (fi)))
    return deprecated_read_register_dummy (get_frame_pc (fi),
					   get_frame_base (fi), PC_REGNUM);
d1518 1
a1518 1
  func_start = get_frame_func (fi);
d1525 1
a1525 1
  (void) skip_prologue (func_start, get_frame_pc (fi), &fdata);
d1527 1
a1527 1
  if (fdata.lr_offset == 0 && get_next_frame (fi) != NULL)
d1529 2
a1530 3
      if ((get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
	return read_memory_addr ((get_frame_base (get_next_frame (fi))
				  + SIG_FRAME_LR_OFFSET),
d1532 1
a1532 1
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (fi)), 0, 0))
d1543 1
a1543 2
	return read_memory_addr (DEPRECATED_FRAME_CHAIN (fi)
				 + tdep->lr_frame_offset,
d1550 1
a1550 2
  return read_memory_addr (DEPRECATED_FRAME_CHAIN (fi) + fdata.lr_offset,
			   wordsize);
d1565 1
a1565 1
  if (deprecated_get_frame_saved_regs (fi))
d1571 1
a1571 1
      (void) skip_prologue (get_frame_func (fi), get_frame_pc (fi), fdatap);
d1596 1
a1596 1
    frame_addr = DEPRECATED_FRAME_CHAIN (fi);
d1607 1
a1607 1
	  deprecated_get_frame_saved_regs (fi)[FP0_REGNUM + i] = fpr_addr;
d1621 1
a1621 1
	  deprecated_get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = gpr_addr;
d1636 2
a1637 2
	      deprecated_get_frame_saved_regs (fi)[tdep->ppc_vr0_regnum + i] = vr_addr;
	      vr_addr += DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d1652 3
a1654 3
	      deprecated_get_frame_saved_regs (fi)[tdep->ppc_ev0_regnum + i] = ev_addr;
              deprecated_get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = ev_addr + 4;
	      ev_addr += DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_ev0_regnum);
d1662 1
a1662 1
    deprecated_get_frame_saved_regs (fi)[tdep->ppc_cr_regnum] = frame_addr + fdatap->cr_offset;
d1667 1
a1667 1
    deprecated_get_frame_saved_regs (fi)[tdep->ppc_lr_regnum] = frame_addr + fdatap->lr_offset;
d1672 1
a1672 1
    deprecated_get_frame_saved_regs (fi)[tdep->ppc_vrsave_regnum] = frame_addr + fdatap->vrsave_offset;
d1689 2
a1690 2
  if (get_frame_extra_info (fi)->initial_sp)
    return get_frame_extra_info (fi)->initial_sp;
d1694 1
a1694 1
  (void) skip_prologue (get_frame_func (fi), get_frame_pc (fi), &fdata);
d1699 1
a1699 1
  if (!deprecated_get_frame_saved_regs (fi))
d1707 2
a1708 2
      get_frame_extra_info (fi)->initial_sp = get_frame_base (fi);
      return get_frame_extra_info (fi)->initial_sp;
d1714 1
a1714 1
    char tmpbuf[MAX_REGISTER_SIZE];
d1717 1
a1717 1
	get_frame_extra_info (fi)->initial_sp
d1719 1
a1719 1
				      DEPRECATED_REGISTER_RAW_SIZE (fdata.alloca_reg));
d1725 1
a1725 1
      get_frame_extra_info (fi)->initial_sp = get_frame_base (fi);
d1727 1
a1727 1
  return get_frame_extra_info (fi)->initial_sp;
d1733 2
a1734 2
/* DEPRECATED_FRAME_CHAIN takes a frame's nominal address and produces
   the frame's chain-pointer.  */
d1745 1
a1745 3
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (thisframe),
				   get_frame_base (thisframe),
				   get_frame_base (thisframe)))
d1748 1
a1748 1
    return read_memory_addr (get_frame_base (thisframe), wordsize);
d1750 2
a1751 2
  if (deprecated_inside_entry_file (get_frame_pc (thisframe))
      || get_frame_pc (thisframe) == entry_point_address ())
d1754 5
a1758 5
  if ((get_frame_type (thisframe) == SIGTRAMP_FRAME))
    fp = read_memory_addr (get_frame_base (thisframe) + SIG_FRAME_FP_OFFSET,
			   wordsize);
  else if (get_next_frame (thisframe) != NULL
	   && (get_frame_type (get_next_frame (thisframe)) == SIGTRAMP_FRAME)
d1762 1
a1762 1
    fp = get_frame_base (thisframe);
d1764 1
a1764 1
    fp = read_memory_addr (get_frame_base (thisframe), wordsize);
a1826 4
	case 0:
	  return builtin_type_int0;
	case 4:
	  return builtin_type_int32;
d1837 2
a1838 2
	  internal_error (__FILE__, __LINE__, "Register %d size %d unknown",
			  n, size);
d1843 11
d1874 1
a1874 1
  if (TYPE_LENGTH (type) != DEPRECATED_REGISTER_RAW_SIZE (n))
d1876 2
a1877 2
      double val = deprecated_extract_floating (from, DEPRECATED_REGISTER_RAW_SIZE (n));
      deprecated_store_floating (to, TYPE_LENGTH (type), val);
d1880 1
a1880 1
    memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (n));
d1888 1
a1888 1
				const char *from, char *to)
d1890 1
a1890 1
  if (TYPE_LENGTH (type) != DEPRECATED_REGISTER_RAW_SIZE (n))
d1892 2
a1893 2
      double val = deprecated_extract_floating (from, TYPE_LENGTH (type));
      deprecated_store_floating (to, DEPRECATED_REGISTER_RAW_SIZE (n), val);
d1896 1
a1896 1
    memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (n));
d1905 1
a1905 1
  char temp_buffer[MAX_REGISTER_SIZE];
d1928 1
a1928 1
  char temp_buffer[MAX_REGISTER_SIZE];
d1988 34
d2033 2
a2034 2
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1), valbuf,
				     TYPE_LENGTH (type));
d2039 2
a2040 2
	deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
					 valbuf, TYPE_LENGTH (type));
d2044 2
a2045 2
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + 3),
				     valbuf, TYPE_LENGTH (type));
d2058 4
a2061 4
     the current call_function_by_hand() code only saves the most
     recent struct address leading to occasional calls.  The code
     should instead maintain a stack of such addresses (in the dummy
     frame object).  */
d2089 1
a2089 1
/* Support for CONVERT_FROM_FUNC_PTR_ADDR (ARCH, ADDR, TARG).
d2108 2
a2109 4
static CORE_ADDR
rs6000_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
				   CORE_ADDR addr,
				   struct target_ops *targ)
d2269 1
a2269 1
  /* 24 */ P(r24),P(r25),P(r26),P(r27),P(r28),P(r29),P(r30),P(r31)
a2447 3
  R8(acc), R(spefscr),
  /* NOTE: Add new registers here the end of the raw register
     list and just before the first pseudo register.  */
d2656 1
d2667 3
d2704 1
a2704 1
      if (tdep && tdep->wordsize == wordsize)
d2724 2
a2725 1
      bfd_default_set_arch_mach (&abfd, arch, 0);
a2726 1
      mach = info.bfd_arch_info->mach;
d2730 1
d2783 4
a2786 10
  set_gdbarch_deprecated_fp_regnum (gdbarch, 1);
  if (sysv_abi && wordsize == 8)
    set_gdbarch_return_value (gdbarch, ppc64_sysv_abi_return_value);
  else if (sysv_abi && wordsize == 4)
    set_gdbarch_return_value (gdbarch, ppc_sysv_abi_return_value);
  else
    {
      set_gdbarch_deprecated_extract_return_value (gdbarch, rs6000_extract_return_value);
      set_gdbarch_deprecated_store_return_value (gdbarch, rs6000_store_return_value);
    }
d2804 2
a2805 2
        tdep->ppc_gp0_regnum = 41;
        tdep->ppc_gplast_regnum = tdep->ppc_gp0_regnum + 32 - 1;
d2815 2
a2816 2
        set_gdbarch_sp_regnum (gdbarch, tdep->ppc_gp0_regnum + 1);
        set_gdbarch_deprecated_fp_regnum (gdbarch, tdep->ppc_gp0_regnum + 1);
d2820 2
a2830 3
  /* Sanity check on registers.  */
  gdb_assert (strcmp (tdep->regs[tdep->ppc_gp0_regnum].name, "r0") == 0);

d2853 1
d2855 3
d2862 8
a2869 5
  set_gdbarch_deprecated_register_size (gdbarch, wordsize);
  set_gdbarch_deprecated_register_bytes (gdbarch, off);
  set_gdbarch_deprecated_register_byte (gdbarch, rs6000_register_byte);
  set_gdbarch_deprecated_register_raw_size (gdbarch, rs6000_register_raw_size);
  set_gdbarch_deprecated_register_virtual_type (gdbarch, rs6000_register_virtual_type);
d2878 1
a2878 4
  if (sysv_abi)
    set_gdbarch_long_double_bit (gdbarch, 16 * TARGET_CHAR_BIT);
  else
    set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
d2881 12
d2894 3
a2896 10
  if (sysv_abi && wordsize == 8)
    /* PPC64 SYSV.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 288);
  else if (!sysv_abi && wordsize == 4)
    /* PowerOpen / AIX 32 bit.  The saved area or red zone consists of
       19 4 byte GPRS + 18 8 byte FPRs giving a total of 220 bytes.
       Problem is, 220 isn't frame (16 byte) aligned.  Round it up to
       224.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 224);
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
d2898 1
d2900 3
a2902 3
  set_gdbarch_deprecated_register_convertible (gdbarch, rs6000_register_convertible);
  set_gdbarch_deprecated_register_convert_to_virtual (gdbarch, rs6000_register_convert_to_virtual);
  set_gdbarch_deprecated_register_convert_to_raw (gdbarch, rs6000_register_convert_to_raw);
d2912 1
a2912 3
    set_gdbarch_push_dummy_call (gdbarch, ppc_sysv_abi_push_dummy_call);
  else if (sysv_abi && wordsize == 8)
    set_gdbarch_push_dummy_call (gdbarch, ppc64_sysv_abi_push_dummy_call);
d2914 1
a2914 1
    set_gdbarch_push_dummy_call (gdbarch, rs6000_push_dummy_call);
d2916 1
d2918 1
a2918 1
  set_gdbarch_deprecated_pop_frame (gdbarch, rs6000_pop_frame);
a2925 9
  /* Handle the 64-bit SVR4 minimal-symbol convention of using "FN"
     for the descriptor and ".FN" for the entry-point -- a user
     specifying "break FN" will unexpectedly end up with a breakpoint
     on the descriptor and not the function.  This architecture method
     transforms any breakpoints on descriptors into breakpoints on the
     corresponding entry point.  */
  if (sysv_abi && wordsize == 8)
    set_gdbarch_adjust_breakpoint_address (gdbarch, ppc64_sysv_abi_adjust_breakpoint_address);

d2929 4
a2932 1
  if (!sysv_abi)
d2934 3
a2936 1
				       rs6000_use_struct_convention);
d2940 2
a2941 2
  set_gdbarch_deprecated_frame_chain (gdbarch, rs6000_frame_chain);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);
d2943 2
a2944 2
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);
d2953 7
a2959 6
  set_gdbarch_deprecated_frame_args_address (gdbarch, rs6000_frame_args_address);
  set_gdbarch_deprecated_frame_locals_address (gdbarch, rs6000_frame_args_address);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, rs6000_saved_pc_after_call);

  /* Helpers for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, rs6000_fetch_pointer_argument);
d2962 1
a2962 11
  gdbarch_init_osabi (info, gdbarch);

  if (from_xcoff_exec)
    {
      /* NOTE: jimix/2003-06-09: This test should really check for
	 GDB_OSABI_AIX when that is defined and becomes
	 available. (Actually, once things are properly split apart,
	 the test goes away.) */
       /* RS6000/AIX does not support PT_STEP.  Has to be simulated.  */
       set_gdbarch_software_single_step (gdbarch, rs6000_software_single_step);
    }
d2975 2
a2976 1
  /* FIXME: Dump gdbarch_tdep.  */
a2987 2

extern initialize_file_ftype _initialize_rs6000_tdep; /* -Wmissing-prototypes */
@


1.88.2.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 3
a4 4

   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
a1249 8
      /* This is another instance we need to be concerned about
         securing our stack space. If we write anything underneath %sp
         (r1), we might conflict with the kernel who thinks he is free
         to use this area.  So, update %sp first before doing anything
         else.  */

      regcache_raw_write_signed (regcache, SP_REGNUM, sp);

d1291 4
d1296 3
a1298 5
     be set _before_ the corresponding stack space is used.  On AIX,
     this even applies when the target has been completely stopped!
     Not doing this can lead to conflicts with the kernel which thinks
     that it still has control over this not-yet-allocated stack
     region.  */
a1300 4
  /* Set back chain properly.  */
  store_unsigned_integer (tmp_buffer, 4, saved_sp);
  write_memory (sp, tmp_buffer, 4);

d2884 1
a2884 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
d2889 2
@


1.87
log
@2002-10-02  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (skip_prologue): Bias alloca_reg by ppc_gp0_regnum.
@
text
@d1994 2
a1995 1
  write_register (3, addr);
@


1.86
log
@2002-10-01  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): For powerpc:7400, fix
	"vrsave"'s register number.
@
text
@d468 1
d698 1
a698 1
	  fdata->alloca_reg = 31;
d707 2
a708 1
	  fdata->alloca_reg = (op & ~0x38010000) >> 21;
@


1.85
log
@2002-09-26  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (rs6000_frame_chain): Don't chain past the dummy
	frame.
@
text
@d2796 1
a2796 1
	tdep->ppc_vrsave_regnum = 153;
@


1.84
log
@2002-09-26  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (rs6000_extract_struct_value_address): Return 0.
	(rs6000_struct_return_address): Delete variable.
	(rs6000_store_struct_return): Update.
	(rs6000_gdbarch_init): Set extract_struct_value_address instead of
	deprecated_extract_struct_value_address.
	(rs6000_frame_align): New function.
	(rs6000_gdbarch_init): Set frame_align.
@
text
@d1744 3
a1746 1
    return thisframe->frame;	/* dummy frame same as caller's frame */
a1762 7

  lr = read_register (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum);
  if (lr == entry_point_address ())
    if (fp != 0 && (fpp = read_memory_addr (fp, wordsize)) != 0)
      if (PC_IN_CALL_DUMMY (lr, fpp, fpp))
	return fpp;

@


1.83
log
@2002-09-25  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (rs6000_frame_saved_pc): If the link register
	wasn't saved, and the next innermost frame is a dummy, return the
	dummy frame's link register.
@
text
@d1035 7
a1372 7
/* Keep structure return address in this variable.
   FIXME:  This is a horrid kludge which should not be allowed to continue
   living.  This only allows a single nested call to a structure-returning
   function.  Come on, guys!  -- gnu@@cygnus.com, Aug 92  */

static CORE_ADDR rs6000_struct_return_address;

d1992 1
a1992 6
   subroutine will return.  This is called from call_function.

   In RS/6000, struct return addresses are passed as an extra parameter in r3.
   In function return, callee is not responsible of returning this address
   back.  Since gdb needs to find it, we will store in a designated variable
   `rs6000_struct_return_address'.  */
a1997 1
  rs6000_struct_return_address = addr;
d2055 1
a2055 1
rs6000_extract_struct_value_address (char *regbuf)
d2057 12
a2068 1
  return rs6000_struct_return_address;
d2895 1
d2919 1
a2919 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
@


1.82
log
@2002-09-17  Andrew Cagney  <cagney@@redhat.com>

	* h8300-tdep.c (h8300_frame_chain):
	(h8300_frame_saved_pc):

	* blockframe.c (deprecated_read_register_dummy): Rename
	generic_read_register_dummy.
	* frame.c (frame_unwind_signed_register): New function.
	(frame_unwind_unsigned_register): New function.
	* frame.h (frame_unwind_signed_register): Declare.
	(frame_unwind_unsigned_register): Declare.
	(deprecated_read_register_dummy): Rename
	generic_read_register_dummy.

	* xstormy16-tdep.c (xstormy16_frame_saved_pc): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	* s390-tdep.c (s390_frame_saved_pc_nofix): Update.
	(s390_frame_chain): Update.
	* v850-tdep.c (v850_find_callers_reg): Update.
	(v850_frame_saved_pc): Update.
	* m32r-tdep.c (m32r_init_extra_frame_info): Update.
	(m32r_find_callers_reg): Update.
	(m32r_frame_saved_pc): Update.
	* sh-tdep.c (sh_find_callers_reg): Update.
	(sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info): Update.
	(sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* mcore-tdep.c (mcore_find_callers_reg): Update.
	(mcore_frame_saved_pc): Update.
	(mcore_init_extra_frame_info): Update.
	* i386-tdep.c (i386_frame_saved_pc): Update.
	* ia64-tdep.c (ia64_frame_saved_pc): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_init_extra_frame_info): Update.
	* d10v-tdep.c (d10v_frame_saved_pc): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_frame_chain): Update.
	(avr_init_extra_frame_info): Update.
	(avr_frame_saved_pc): Update.
	* arm-tdep.c (arm_find_callers_reg): Update.
	(arm_init_extra_frame_info): Update.
	(arm_frame_saved_pc): Update.
@
text
@d1530 10
@


1.82.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@a1034 7
/* All the ABI's require 16 byte alignment.  */
static CORE_ADDR
rs6000_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return (addr & -16);
}

d1366 7
a1529 10
      else if (PC_IN_CALL_DUMMY (get_next_frame (fi)->pc, 0, 0))
	/* The link register wasn't saved by this frame and the next
           (inner, newer) frame is a dummy.  Get the link register
           value by unwinding it from that [dummy] frame.  */
	{
	  ULONGEST lr;
	  frame_unwind_unsigned_register (get_next_frame (fi),
					  tdep->ppc_lr_regnum, &lr);
	  return lr;
	}
d1734 1
a1734 3
    /* A dummy frame always correctly chains back to the previous
       frame.  */
    return read_memory_addr ((thisframe)->frame, wordsize);
d1751 7
d1982 6
a1987 1
   subroutine will return.  */
d1993 1
d2051 1
a2051 1
rs6000_extract_struct_value_address (struct regcache *regcache)
d2053 1
a2053 12
  /* FIXME: cagney/2002-09-26: PR gdb/724: When making an inferior
     function call GDB knows the address of the struct return value
     and hence, should not need to call this function.  Unfortunately,
     the current hand_function_call() code only saves the most recent
     struct address leading to occasional calls.  The code should
     instead maintain a stack of such addresses (in the dummy frame
     object).  */
  /* NOTE: cagney/2002-09-26: Return 0 which indicates that we've
     really got no idea where the return value is being stored.  While
     r3, on function entry, contained the address it will have since
     been reused (scratch) and hence wouldn't be valid */
  return 0;
a2879 1
  set_gdbarch_frame_align (gdbarch, rs6000_frame_align);
d2903 1
a2903 1
  set_gdbarch_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
@


1.82.2.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a467 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d697 1
a697 1
	  fdata->alloca_reg = (tdep->ppc_gp0_regnum + 31);
d706 1
a706 2
	  fdata->alloca_reg = (tdep->ppc_gp0_regnum
			       + ((op & ~0x38010000) >> 21));
d1992 1
a1992 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  write_register (tdep->ppc_gp0_regnum + 3, addr);
d2796 1
a2796 1
	tdep->ppc_vrsave_regnum = 152;
@


1.82.2.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d969 1
a969 1
  deprecated_read_register_bytes (0, NULL, REGISTER_BYTES);
d998 1
a998 2
	  read_memory (addr, &deprecated_registers[REGISTER_BYTE (ii)],
		       wordsize);
d1008 1
a1008 1
	  read_memory (addr, &deprecated_registers[REGISTER_BYTE (ii + FP0_REGNUM)], 8);
d1125 1
a1125 1
	  memcpy (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1137 2
a1138 3
	      memset (&deprecated_registers[REGISTER_BYTE (ii + 3)], 0,
		      reg_size);
	      memcpy (&deprecated_registers[REGISTER_BYTE (ii + 3)],
d1154 2
a1155 2
	  memset (&deprecated_registers[REGISTER_BYTE (ii + 3)], 0, reg_size);
	  memcpy ((char *)&deprecated_registers[REGISTER_BYTE (ii + 3)] + adj, 
d1237 1
a1237 1
	      memcpy (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d2017 1
a2017 1
      deprecated_write_register_gen (regnum, reg_val_buf);
d2033 2
a2034 2
    deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM + 1), valbuf,
				     TYPE_LENGTH (type));
d2039 2
a2040 2
	deprecated_write_register_bytes (REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
					 valbuf, TYPE_LENGTH (type));
d2044 2
a2045 2
    deprecated_write_register_bytes (REGISTER_BYTE (gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + 3),
				     valbuf, TYPE_LENGTH (type));
@


1.82.2.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d169 5
a173 5
  struct frame_extra_info *extra_info =
    frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
  extra_info->initial_sp = 0;
  if (get_next_frame (fi) != NULL
      && get_frame_pc (fi) < TEXT_SEGMENT_BASE)
d178 1
a178 1
    deprecated_set_frame_type (fi, SIGTRAMP_FRAME);
d200 2
a201 3
  struct frame_extra_info *extra_info = get_frame_extra_info (fi);
  if (extra_info->initial_sp != 0)
    return extra_info->initial_sp;
d264 1
a264 1
		dest = read_memory_addr (get_frame_base (fi) + SIG_FRAME_PC_OFFSET,
d959 1
a959 1
  sp = get_frame_base (frame);
d961 1
a961 3
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
d975 2
a976 2
  addr = get_pc_function_start (get_frame_pc (frame));
  (void) skip_prologue (addr, get_frame_pc (frame), &fdata);
d1480 1
a1480 2
  if (get_next_frame (fi) != NULL
      && !(get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
d1483 1
a1483 1
  func_start = get_pc_function_start (get_frame_pc (fi));
d1494 1
a1494 1
      if (get_frame_pc (fi) == 0)
d1500 1
a1500 1
  (void) skip_prologue (func_start, get_frame_pc (fi), &fdata);
d1514 2
a1515 9
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
    return read_memory_addr (get_frame_base (fi) + SIG_FRAME_PC_OFFSET,
			     wordsize);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi),
				   get_frame_base (fi),
				   get_frame_base (fi)))
    return deprecated_read_register_dummy (get_frame_pc (fi),
					   get_frame_base (fi), PC_REGNUM);
d1517 4
a1520 1
  func_start = get_pc_function_start (get_frame_pc (fi));
d1527 1
a1527 1
  (void) skip_prologue (func_start, get_frame_pc (fi), &fdata);
d1529 1
a1529 1
  if (fdata.lr_offset == 0 && get_next_frame (fi) != NULL)
d1531 2
a1532 3
      if ((get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
	return read_memory_addr ((get_frame_base (get_next_frame (fi))
				  + SIG_FRAME_LR_OFFSET),
d1534 1
a1534 1
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (fi)), 0, 0))
d1567 1
a1567 1
  if (get_frame_saved_regs (fi))
d1573 1
a1573 2
      (void) skip_prologue (get_pc_function_start (get_frame_pc (fi)),
			    get_frame_pc (fi), fdatap);
d1609 1
a1609 1
	  get_frame_saved_regs (fi)[FP0_REGNUM + i] = fpr_addr;
d1623 1
a1623 1
	  get_frame_saved_regs (fi)[i] = gpr_addr;
d1638 1
a1638 1
	      get_frame_saved_regs (fi)[tdep->ppc_vr0_regnum + i] = vr_addr;
d1654 2
a1655 2
	      get_frame_saved_regs (fi)[tdep->ppc_ev0_regnum + i] = ev_addr;
              get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = ev_addr + 4;
d1664 1
a1664 1
    get_frame_saved_regs (fi)[tdep->ppc_cr_regnum] = frame_addr + fdatap->cr_offset;
d1669 1
a1669 1
    get_frame_saved_regs (fi)[tdep->ppc_lr_regnum] = frame_addr + fdatap->lr_offset;
d1674 1
a1674 1
    get_frame_saved_regs (fi)[tdep->ppc_vrsave_regnum] = frame_addr + fdatap->vrsave_offset;
d1691 2
a1692 2
  if (get_frame_extra_info (fi)->initial_sp)
    return get_frame_extra_info (fi)->initial_sp;
d1696 1
a1696 2
  (void) skip_prologue (get_pc_function_start (get_frame_pc (fi)),
			get_frame_pc (fi), &fdata);
d1701 1
a1701 1
  if (!get_frame_saved_regs (fi))
d1709 2
a1710 2
      get_frame_extra_info (fi)->initial_sp = get_frame_base (fi);
      return get_frame_extra_info (fi)->initial_sp;
d1719 1
a1719 1
	get_frame_extra_info (fi)->initial_sp
d1727 1
a1727 1
      get_frame_extra_info (fi)->initial_sp = get_frame_base (fi);
d1729 1
a1729 1
  return get_frame_extra_info (fi)->initial_sp;
d1747 1
a1747 3
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (thisframe),
				   get_frame_base (thisframe),
				   get_frame_base (thisframe)))
d1750 1
a1750 1
    return read_memory_addr (get_frame_base (thisframe), wordsize);
d1752 2
a1753 2
  if (inside_entry_file (get_frame_pc (thisframe))
      || get_frame_pc (thisframe) == entry_point_address ())
d1756 5
a1760 5
  if ((get_frame_type (thisframe) == SIGTRAMP_FRAME))
    fp = read_memory_addr (get_frame_base (thisframe) + SIG_FRAME_FP_OFFSET,
			   wordsize);
  else if (get_next_frame (thisframe) != NULL
	   && (get_frame_type (get_next_frame (thisframe)) == SIGTRAMP_FRAME)
d1764 1
a1764 1
    fp = get_frame_base (thisframe);
d1766 1
a1766 1
    fp = read_memory_addr (get_frame_base (thisframe), wordsize);
d2883 1
d2885 1
d2890 1
d2893 1
@


1.82.2.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003
a36 1
#include "osabi.h"
d1858 11
d2671 1
d2682 3
d2719 1
a2719 1
      if (tdep && tdep->wordsize == wordsize)
d2745 1
d2909 1
d2947 2
d2973 1
a2973 1
  gdbarch_init_osabi (info, gdbarch);
d2986 2
a2987 1
  /* FIXME: Dump gdbarch_tdep.  */
@


1.82.2.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@a49 2
#include "gdb_assert.h"

d1445 1
a1445 1
  if (msymbol && rs6000_in_solib_return_trampoline (pc, DEPRECATED_SYMBOL_NAME (msymbol)))
d2274 1
a2274 1
  /* 24 */ P(r24),P(r25),P(r26),P(r27),P(r28),P(r29),P(r30),P(r31)
a2452 3
  R8(acc), R(spefscr),
  /* NOTE: Add new registers here the end of the raw register
     list and just before the first pseudo register.  */
d2804 2
a2805 2
        tdep->ppc_gp0_regnum = 41;
        tdep->ppc_gplast_regnum = tdep->ppc_gp0_regnum + 32 - 1;
d2815 2
a2816 2
        set_gdbarch_sp_regnum (gdbarch, tdep->ppc_gp0_regnum + 1);
        set_gdbarch_fp_regnum (gdbarch, tdep->ppc_gp0_regnum + 1);
a2830 3
  /* Sanity check on registers.  */
  gdb_assert (strcmp (tdep->regs[tdep->ppc_gp0_regnum].name, "r0") == 0);

d2866 1
a2866 1
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 16);
d2868 1
a2868 1
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 16);
d2890 1
d2936 2
a2937 2
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);
@


1.82.2.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a139 12
/* Use the architectures FP registers?  */
int
ppc_floating_point_unit_p (struct gdbarch *gdbarch)
{
  const struct bfd_arch_info *info = gdbarch_bfd_arch_info (gdbarch);
  if (info->arch == bfd_arch_powerpc)
    return (info->mach != bfd_mach_ppc_e500);
  if (info->arch == bfd_arch_rs6000)
    return 1;
  return 0;
}

d981 1
a981 1
  addr = get_frame_func (frame);
d1490 1
a1490 1
  func_start = get_frame_func (fi);
d1531 1
a1531 1
  func_start = get_frame_func (fi);
d1557 1
a1557 2
	return read_memory_addr (DEPRECATED_FRAME_CHAIN (fi)
				 + tdep->lr_frame_offset,
d1564 1
a1564 2
  return read_memory_addr (DEPRECATED_FRAME_CHAIN (fi) + fdata.lr_offset,
			   wordsize);
d1585 2
a1586 1
      (void) skip_prologue (get_frame_func (fi), get_frame_pc (fi), fdatap);
d1611 1
a1611 1
    frame_addr = DEPRECATED_FRAME_CHAIN (fi);
d1636 1
a1636 1
	  get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = gpr_addr;
d1709 2
a1710 1
  (void) skip_prologue (get_frame_func (fi), get_frame_pc (fi), &fdata);
d1749 2
a1750 2
/* DEPRECATED_FRAME_CHAIN takes a frame's nominal address and produces
   the frame's chain-pointer.  */
d1883 2
a1884 2
      double val = deprecated_extract_floating (from, REGISTER_RAW_SIZE (n));
      deprecated_store_floating (to, TYPE_LENGTH (type), val);
d1899 2
a1900 2
      double val = deprecated_extract_floating (from, TYPE_LENGTH (type));
      deprecated_store_floating (to, REGISTER_RAW_SIZE (n), val);
d2065 4
a2068 4
     the current call_function_by_hand() code only saves the most
     recent struct address leading to occasional calls.  The code
     should instead maintain a stack of such addresses (in the dummy
     frame object).  */
d2730 2
a2731 1
      bfd_default_set_arch_mach (&abfd, arch, 0);
a2732 1
      mach = info.bfd_arch_info->mach;
d2865 1
a2865 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
d2889 7
d2899 1
a2899 1
  set_gdbarch_deprecated_push_return_address (gdbarch, ppc_push_return_address);
d2914 1
a2914 1
    set_gdbarch_deprecated_push_arguments (gdbarch, ppc_sysv_abi_push_arguments);
d2916 1
a2916 1
    set_gdbarch_deprecated_push_arguments (gdbarch, rs6000_push_arguments);
d2918 1
a2918 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, rs6000_store_struct_return);
d2920 1
a2920 1
  set_gdbarch_deprecated_pop_frame (gdbarch, rs6000_pop_frame);
d2940 2
a2941 2
  set_gdbarch_deprecated_frame_chain (gdbarch, rs6000_frame_chain);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);
d2955 1
a2955 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, rs6000_saved_pc_after_call);
@


1.82.2.8
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d2800 1
a2800 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 1);
d2833 1
a2833 1
        set_gdbarch_deprecated_fp_regnum (gdbarch, tdep->ppc_gp0_regnum + 1);
d2875 1
d2898 1
a2898 4
  if (sysv_abi)
    set_gdbarch_long_double_bit (gdbarch, 16 * TARGET_CHAR_BIT);
  else
    set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
@


1.82.2.9
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d308 3
d314 2
a315 2
  static unsigned char big_breakpoint[] = { 0x7d, 0x82, 0x10, 0x08 };
  static unsigned char little_breakpoint[] = { 0x08, 0x10, 0x82, 0x7d };
d987 1
a987 1
  deprecated_read_register_bytes (0, NULL, DEPRECATED_REGISTER_BYTES);
d1272 1
a1272 1
  store_unsigned_integer (tmp_buffer, 4, saved_sp);
d1742 1
a1742 1
    char tmpbuf[MAX_REGISTER_SIZE];
d1924 1
a1924 1
  char temp_buffer[MAX_REGISTER_SIZE];
d1947 1
a1947 1
  char temp_buffer[MAX_REGISTER_SIZE];
d2881 2
a2882 2
  set_gdbarch_deprecated_register_size (gdbarch, wordsize);
  set_gdbarch_deprecated_register_bytes (gdbarch, off);
d2903 1
a2903 1
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, rs6000_fix_call_dummy);
@


1.82.2.10
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a232 10
/* Get the ith function argument for the current function.  */
static CORE_ADDR
rs6000_fetch_pointer_argument (struct frame_info *frame, int argi, 
			       struct type *type)
{
  CORE_ADDR addr;
  frame_read_register (frame, 3 + argi, &addr);
  return addr;
}

d529 1
a529 1
	  lr_reg = (op & 0x03e00000);
d535 1
a535 1
	  cr_reg = (op & 0x03e00000);
d561 1
a561 1
		op &= ~3UL;
d593 4
a596 9
      else if (lr_reg != -1 &&
	       /* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
	       (((op & 0xffff0000) == (lr_reg | 0xf8010000)) ||
		/* stw Rx, NUM(r1) */
		((op & 0xffff0000) == (lr_reg | 0x90010000)) ||
		/* stwu Rx, NUM(r1) */
		((op & 0xffff0000) == (lr_reg | 0x94010000))))
	{	/* where Rx == lr */
	  fdata->lr_offset = offset;
a598 6
	  if ((op & 0xfc000003) == 0xf8000000 ||	/* std */
	      (op & 0xfc000000) == 0x90000000)		/* stw */
	    {
	      /* Does not update r1, so add displacement to lr_offset.  */
	      fdata->lr_offset += SIGNED_SHORT (op);
	    }
d602 4
a605 9
      else if (cr_reg != -1 &&
	       /* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
	       (((op & 0xffff0000) == (cr_reg | 0xf8010000)) ||
		/* stw Rx, NUM(r1) */
		((op & 0xffff0000) == (cr_reg | 0x90010000)) ||
		/* stwu Rx, NUM(r1) */
		((op & 0xffff0000) == (cr_reg | 0x94010000))))
	{	/* where Rx == cr */
	  fdata->cr_offset = offset;
a606 6
	  if ((op & 0xfc000003) == 0xf8000000 ||
	      (op & 0xfc000000) == 0x90000000)
	    {
	      /* Does not update r1, so add displacement to cr_offset.  */
	      fdata->cr_offset += SIGNED_SHORT (op);
	    }
d650 1
d652 3
a654 3
      /* update stack pointer */
      else if ((op & 0xfc1f0000) == 0x94010000)
	{		/* stu rX,NUM(r1) ||  stwu rX,NUM(r1) */
d656 2
d661 1
d663 2
a664 3
      else if ((op & 0xfc1f016a) == 0x7c01016e)
	{			/* stwux rX,r1,rY */
	  /* no way to figure out what r1 is going to be */
d668 2
d671 1
a671 17
      else if ((op & 0xfc1f0003) == 0xf8010001)
	{			/* stdu rX,NUM(r1) */
	  fdata->frameless = 0;
	  fdata->offset = SIGNED_SHORT (op & ~3UL);
	  offset = fdata->offset;
	  continue;
	}
      else if ((op & 0xfc1f016a) == 0x7c01016a)
	{			/* stdux rX,r1,rY */
	  /* no way to figure out what r1 is going to be */
	  fdata->frameless = 0;
	  offset = fdata->offset;
	  continue;
	}
      /* Load up minimal toc pointer */
      else if (((op >> 22) == 0x20f	||	/* l r31,... or l r30,... */
	       (op >> 22) == 0x3af)		/* ld r31,... or ld r30,... */
d673 1
a673 1
	{
a1853 4
	case 0:
	  return builtin_type_int0;
	case 4:
	  return builtin_type_int32;
d1864 2
a1865 2
	  internal_error (__FILE__, __LINE__, "Register %d size %d unknown",
			  n, size);
d1904 1
a1904 1
				const char *from, char *to)
d2124 1
a2124 1
static CORE_ADDR
d2870 1
d2872 2
a2873 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
d2880 2
a2881 2
  set_gdbarch_deprecated_register_byte (gdbarch, rs6000_register_byte);
  set_gdbarch_deprecated_register_raw_size (gdbarch, rs6000_register_raw_size);
d2883 1
a2883 1
  set_gdbarch_deprecated_register_virtual_size (gdbarch, generic_register_size);
d2885 1
a2885 1
  set_gdbarch_deprecated_register_virtual_type (gdbarch, rs6000_register_virtual_type);
d2902 1
a2902 1
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
d2906 3
a2908 3
  set_gdbarch_deprecated_register_convertible (gdbarch, rs6000_register_convertible);
  set_gdbarch_deprecated_register_convert_to_virtual (gdbarch, rs6000_register_convert_to_virtual);
  set_gdbarch_deprecated_register_convert_to_raw (gdbarch, rs6000_register_convert_to_raw);
d2957 2
a2958 2
  set_gdbarch_deprecated_frame_args_address (gdbarch, rs6000_frame_args_address);
  set_gdbarch_deprecated_frame_locals_address (gdbarch, rs6000_frame_args_address);
d2961 3
a2963 2
  /* Helpers for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, rs6000_fetch_pointer_argument);
a2990 2

extern initialize_file_ftype _initialize_rs6000_tdep; /* -Wmissing-prototypes */
@


1.82.2.11
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a50 1
#include "dis-asm.h"
d1056 1
a1056 1
	  read_memory (addr, &deprecated_registers[DEPRECATED_REGISTER_BYTE (ii)],
d1067 1
a1067 1
	  read_memory (addr, &deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + FP0_REGNUM)], 8);
d1077 19
d1120 2
a1121 4
rs6000_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
a1122 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1137 1
a1137 2
     Copy them appropriately.  */
  ii = 0;
d1139 6
a1144 10
  /* If the function is returning a `struct', then the first word
     (which will be passed in r3) is used for struct return address.
     In that case we should advance one word and start from r4
     register to copy parameters.  */
  if (struct_return)
    {
      regcache_raw_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
				   struct_addr);
      ii++;
    }
d1184 1
a1184 1
	  memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1196 1
a1196 1
	      memset (&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)], 0,
d1198 1
a1198 1
	      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)],
d1214 2
a1215 2
	  memset (&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)], 0, reg_size);
	  memcpy ((char *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (ii + 3)] + adj, 
d1259 8
d1297 1
a1297 1
	      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
d1307 3
d1315 3
a1317 9
  /* Set the stack pointer.  According to the ABI, the SP is meant to
     be set _before_ the corresponding stack space is used.  No need
     for that here though - the target has been completely stopped -
     it isn't possible for an exception handler to stomp on the stack.  */
  regcache_raw_write_signed (regcache, SP_REGNUM, sp);

  /* Point the inferior function call's return address at the dummy's
     breakpoint.  */
  regcache_raw_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);
d1319 2
a1320 7
  /* Set the TOC register, get the value from the objfile reader
     which, in turn, gets it from the VMAP table.  */
  if (rs6000_find_toc_address_hook != NULL)
    {
      CORE_ADDR tocvalue = (*rs6000_find_toc_address_hook) (func_addr);
      regcache_raw_write_signed (regcache, tdep->ppc_toc_regnum, tocvalue);
    }
d1322 5
a1326 1
  target_store_registers (-1);
a1388 12
/* PowerOpen always puts structures in memory.  Vectors, which were
   added later, do get returned in a register though.  */

static int     
rs6000_use_struct_convention (int gcc_p, struct type *value_type)
{  
  if ((TYPE_LENGTH (value_type) == 16 || TYPE_LENGTH (value_type) == 8)
      && TYPE_VECTOR (value_type))
    return 0;                            
  return 1;
}

d1406 1
a1406 1
		&regbuf[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1)],
d1410 1
a1410 1
	  memcpy (&dd, &regbuf[DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1)], 8);
d1419 1
a1419 1
      memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
d1430 1
a1430 1
	      regbuf + DEPRECATED_REGISTER_BYTE (3) + offset,
d1480 1
a1480 1
  unsigned int ii, op;
d1820 1
a1820 1
  if (deprecated_inside_entry_file (get_frame_pc (thisframe))
d2051 10
d2096 1
a2096 1
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (FP0_REGNUM + 1), valbuf,
d2102 1
a2102 1
	deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (tdep->ppc_vr0_regnum + 2),
d2107 1
a2107 1
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + 3),
d2918 1
d2927 3
d2945 1
a2946 6
  if (sysv_abi && wordsize == 8)
    /* PPC64 SYSV.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 288);
  else if (!sysv_abi && wordsize == 4)
    /* PowerOpen / AIX 32 bit.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 220);
d2948 1
d2963 1
a2963 1
    set_gdbarch_push_dummy_call (gdbarch, ppc_sysv_abi_push_dummy_call);
d2965 1
a2965 1
    set_gdbarch_push_dummy_call (gdbarch, rs6000_push_dummy_call);
d2967 1
d2985 1
a2985 1
				       rs6000_use_struct_convention);
@


1.82.2.12
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d240 1
a240 1
  get_frame_register (frame, 3 + argi, &addr);
d988 1
a988 2
	  if (tmp >= 0
	      && strcmp (misc_function_vector[tmp].name, main_name ()) == 0)
d1157 1
a1157 1
      int reg_size = DEPRECATED_REGISTER_RAW_SIZE (ii + 3);
d1316 59
d1424 2
a1425 2
	  && TYPE_LENGTH (valtype) < DEPRECATED_REGISTER_RAW_SIZE (3))
	offset = DEPRECATED_REGISTER_RAW_SIZE (3) - TYPE_LENGTH (valtype);
d1631 1
a1631 1
  if (deprecated_get_frame_saved_regs (fi))
d1673 1
a1673 1
	  deprecated_get_frame_saved_regs (fi)[FP0_REGNUM + i] = fpr_addr;
d1687 1
a1687 1
	  deprecated_get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = gpr_addr;
d1702 2
a1703 2
	      deprecated_get_frame_saved_regs (fi)[tdep->ppc_vr0_regnum + i] = vr_addr;
	      vr_addr += DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d1718 3
a1720 3
	      deprecated_get_frame_saved_regs (fi)[tdep->ppc_ev0_regnum + i] = ev_addr;
              deprecated_get_frame_saved_regs (fi)[tdep->ppc_gp0_regnum + i] = ev_addr + 4;
	      ev_addr += DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_ev0_regnum);
d1728 1
a1728 1
    deprecated_get_frame_saved_regs (fi)[tdep->ppc_cr_regnum] = frame_addr + fdatap->cr_offset;
d1733 1
a1733 1
    deprecated_get_frame_saved_regs (fi)[tdep->ppc_lr_regnum] = frame_addr + fdatap->lr_offset;
d1738 1
a1738 1
    deprecated_get_frame_saved_regs (fi)[tdep->ppc_vrsave_regnum] = frame_addr + fdatap->vrsave_offset;
d1765 1
a1765 1
  if (!deprecated_get_frame_saved_regs (fi))
d1785 1
a1785 1
				      DEPRECATED_REGISTER_RAW_SIZE (fdata.alloca_reg));
d1935 1
a1935 1
  if (TYPE_LENGTH (type) != DEPRECATED_REGISTER_RAW_SIZE (n))
d1937 1
a1937 1
      double val = deprecated_extract_floating (from, DEPRECATED_REGISTER_RAW_SIZE (n));
d1941 1
a1941 1
    memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (n));
d1951 1
a1951 1
  if (TYPE_LENGTH (type) != DEPRECATED_REGISTER_RAW_SIZE (n))
d1954 1
a1954 1
      deprecated_store_floating (to, DEPRECATED_REGISTER_RAW_SIZE (n), val);
d1957 1
a1957 1
    memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (n));
d2049 24
d2140 1
a2140 1
/* Support for CONVERT_FROM_FUNC_PTR_ADDR (ARCH, ADDR, TARG).
d2160 1
a2160 3
rs6000_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
				   CORE_ADDR addr,
				   struct target_ops *targ)
d2833 3
a2835 9
  if (sysv_abi && wordsize == 8)
    set_gdbarch_return_value (gdbarch, ppc64_sysv_abi_return_value);
  else if (sysv_abi && wordsize == 4)
    set_gdbarch_return_value (gdbarch, ppc_sysv_abi_return_value);
  else
    {
      set_gdbarch_deprecated_extract_return_value (gdbarch, rs6000_extract_return_value);
      set_gdbarch_deprecated_store_return_value (gdbarch, rs6000_store_return_value);
    }
d2869 2
d2934 2
a2935 5
    /* PowerOpen / AIX 32 bit.  The saved area or red zone consists of
       19 4 byte GPRS + 18 8 byte FPRs giving a total of 220 bytes.
       Problem is, 220 isn't frame (16 byte) aligned.  Round it up to
       224.  */
    set_gdbarch_frame_red_zone_size (gdbarch, 224);
a2951 2
  else if (sysv_abi && wordsize == 8)
    set_gdbarch_push_dummy_call (gdbarch, ppc64_sysv_abi_push_dummy_call);
a2963 9
  /* Handle the 64-bit SVR4 minimal-symbol convention of using "FN"
     for the descriptor and ".FN" for the entry-point -- a user
     specifying "break FN" will unexpectedly end up with a breakpoint
     on the descriptor and not the function.  This architecture method
     transforms any breakpoints on descriptors into breakpoints on the
     corresponding entry point.  */
  if (sysv_abi && wordsize == 8)
    set_gdbarch_adjust_breakpoint_address (gdbarch, ppc64_sysv_abi_adjust_breakpoint_address);

d2967 4
a2970 1
  if (!sysv_abi)
a2997 10

  if (from_xcoff_exec)
    {
      /* NOTE: jimix/2003-06-09: This test should really check for
	 GDB_OSABI_AIX when that is defined and becomes
	 available. (Actually, once things are properly split apart,
	 the test goes away.) */
       /* RS6000/AIX does not support PT_STEP.  Has to be simulated.  */
       set_gdbarch_software_single_step (gdbarch, rs6000_software_single_step);
    }
@


1.82.2.13
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 3
a4 4

   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
a1249 8
      /* This is another instance we need to be concerned about
         securing our stack space. If we write anything underneath %sp
         (r1), we might conflict with the kernel who thinks he is free
         to use this area.  So, update %sp first before doing anything
         else.  */

      regcache_raw_write_signed (regcache, SP_REGNUM, sp);

d1291 4
d1296 3
a1298 5
     be set _before_ the corresponding stack space is used.  On AIX,
     this even applies when the target has been completely stopped!
     Not doing this can lead to conflicts with the kernel which thinks
     that it still has control over this not-yet-allocated stack
     region.  */
a1300 4
  /* Set back chain properly.  */
  store_unsigned_integer (tmp_buffer, 4, saved_sp);
  write_memory (sp, tmp_buffer, 4);

d2889 2
@


1.81
log
@	* rs6000-tdep.c (altivec_register_p): Restore function inadvertently
	deleted in 2002-08-20 commit.  This function is still used by
	ppc-linux-nat.c.
@
text
@d1514 1
a1514 1
    return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
@


1.81.2.1
log
@2002-10-01  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): For powerpc:7400, fix
	"vrsave"'s register number.
@
text
@d2786 1
a2786 1
	tdep->ppc_vrsave_regnum = 152;
@


1.80
log
@2002-08-25  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): Set store_struct_return
	instead of deprecated_store_return_value.  Fix fallout from
	2002-08-23 Andrew Cagney <cagney@@redhat.com>.
@
text
@d126 11
@


1.79
log
@2002-08-24  Andrew Cagney  <ac131313@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): Use deprecated version of
	store_return_value.
	(e500_extract_return_value): Change type of valbuf pointer to
	void.
@
text
@d2891 1
a2891 1
  set_gdbarch_deprecated_store_return_value (gdbarch, rs6000_store_return_value);
@


1.78
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d1253 1
a1253 1
e500_extract_return_value (struct type *valtype, struct regcache *regbuf, char *valbuf)
d2762 1
a2762 1
  set_gdbarch_store_return_value (gdbarch, rs6000_store_return_value);
d2797 1
a2797 1
        set_gdbarch_store_return_value (gdbarch, e500_store_return_value);
@


1.77
log
@2002-08-22  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (struct rs6000_framedata): Add saved_ev and
	ev_offset fields.
	(skip_prologue): Add support for BookE/e500 instructions.
	(e500_extract_return_value): New function.
	(frame_get_saved_regs): Add support for saving ev registers and
	pseudo gpr's.
	(e500_store_return_value): New function.
	(rs6000_gdbarch_init): Move up default intializations of
	deprecated_extract_return_value and store_return_value.  Overwrite
	init of store_return_value with e500 specific version.
	Set extract_return_value for e500.
@
text
@d2891 1
a2891 1
  set_gdbarch_store_struct_return (gdbarch, rs6000_store_struct_return);
@


1.76
log
@2002-08-21  Elena Zannoni  <ezannoni@@redhat.com>

        * rs6000-tdep.c (rs6000_gdbarch_init): Figure out whether we have
        an e500 executable.
@
text
@d70 1
d77 1
d364 1
d370 1
d448 2
d456 2
a457 1

d477 1
d544 1
a544 1
	  			/* nop */
d658 1
a658 1
               (((op >> 16) & 31) >= fdata->saved_gpr)) /* Rx: local var reg */
d739 3
a741 1
      else if ((op & 0xffff0000) == 0x38000000)    /* li r0, SIMM */
d767 98
d1252 56
d1561 1
d1564 2
a1565 1
      && fdatap->vr_offset == 0)
d1619 17
d1987 21
d2760 3
d2796 2
a2878 3

  set_gdbarch_deprecated_extract_return_value (gdbarch, rs6000_extract_return_value);
  
a2891 1
  set_gdbarch_store_return_value (gdbarch, rs6000_store_return_value);
@


1.75
log
@2002-08-20  Elena Zannoni  <ezannoni@@redhat.com>

	* ppc-tdep.h (struct gdbarch_tdep): Add ev registers.

	* rs6000-tdep.c (rs6000_register_virtual_type): Return 64 bit
	vector type for ev registers.
	(e500_pseudo_register_read): New function.
	(e500_pseudo_register_write): New function.
	(e500_dwarf2_reg_to_regnum): New function.
	(PPC_UISA_NOFP_SPRS): New macro.
	(PPC_EV_REGS): New macro.
	(PPC_GPRS_PSEUDO_REGS): New macro.
	(registers_e500): New register set for e500.
	(variants): Add e500 variant.
	(rs6000_gdbarch_init): Move setting of pc, sp, fp regnums to
	before setting architectural dependent variations.  Initialize ev
	registers numbers.  Add case for e500 architecture.  Set the
	number of pseudo registers.
@
text
@d2429 1
d2503 21
@


1.74
log
@2002-08-20  Elena Zannoni  <ezannoni@@redhat.com>

        * rs6000-tdep.c: Clean up comments.
@
text
@d1627 4
a1630 1
	  return builtin_type_int64;
d1698 62
d1998 4
d2029 14
d2212 12
d2331 3
d2531 4
d2541 2
d2547 20
d2571 2
d2605 1
a2605 3
  set_gdbarch_sp_regnum (gdbarch, 1);
  set_gdbarch_fp_regnum (gdbarch, 1);
  set_gdbarch_pc_regnum (gdbarch, 64);
@


1.73
log
@2002-08-20  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (altivec_register_p): Delete.
	(rs6000_do_altivec_registers): Delete.
	(rs6000_altivec_registers_info): Delete.
	(rs6000_do_registers_info): Delete.
	(_initialize_rs6000_tdep): Remove command 'info powerpc altivec'.
	(rs6000_gdbarch_init): Remove setting of do_registers_info.
@
text
@d773 1
a773 1
	    /* Never skip branches. */
d794 1
a794 1
     We'd like to skip over it as well. Fortunately, xlc does some extra
d796 1
a796 1
     single out such gcc2 behaviour. */
d806 2
a807 2
	  /* check and see if we are in main. If so, skip over this initializer
	     function as well. */
d827 1
a827 1
/* Pop the innermost frame, go back to the caller. */
d850 1
a850 1
  /* figure out previous %pc value. If the function is frameless, it is 
d852 1
a852 1
     saved %pc value in the previous frame. */
d870 1
a870 1
  /* reset register values if any was saved earlier. */
d898 1
a898 1
   address.  Its arguments will be passed by gdb. */
d920 2
a921 2
   passed in fpr's, in addition to that. Rest of the parameters if any
   are passed in user stack. There might be cases in which half of the
d930 1
a930 1
   starting from r4. */
d949 2
a950 2
  /* The first eight words of ther arguments are passed in registers. Copy
     them appropriately.
d953 1
a953 1
     will be passed in r3) is used for struct return address. In that
d955 1
a955 1
     parameters. */
d989 1
a989 1
	  /* floating point arguments are passed in fpr's, as well as gpr's.
d991 1
a991 1
	     there is no way we would run out of them. */
d1006 1
a1006 1
	  /* Argument takes more than one register. */
d1023 2
a1024 1
	{			/* Argument can fit in one register. No problem. */
d1037 1
a1037 1
  /* location for 8 parameters are always reserved. */
d1040 1
a1040 1
  /* another six words for back chain, TOC register, link register, etc. */
d1043 1
a1043 1
  /* stack pointer must be quadword aligned */
d1046 2
a1047 2
  /* if there are more arguments, allocate space for them in 
     the stack, then push them starting from the ninth one. */
d1067 1
a1067 1
      /* add location required for the rest of the parameters */
d1071 5
a1075 4
      /* This is another instance we need to be concerned about securing our
         stack space. If we write anything underneath %sp (r1), we might conflict
         with the kernel who thinks he is free to use this area. So, update %sp
         first before doing anything else. */
d1079 2
a1080 2
      /* if the last argument copied into the registers didn't fit there 
         completely, push the rest of it into stack. */
d1091 1
a1091 1
      /* push the rest of the arguments into stack. */
d1100 2
a1101 1
	  /* float types should be passed in fpr's, as well as in the stack. */
d1120 1
a1120 1
    /* Secure stack areas first, before doing anything else. */
d1132 1
a1132 1
   Set up the return address for the inferior function call. */
d1143 1
a1143 1
   REGBUF, and copy that return value into VALBUF in virtual format. */
d1158 1
a1158 1
         necessary. */
d1307 1
a1307 1
     to inspect the instructions. */
d1313 1
a1313 1
         inferior. Mark function as frameless, as the inferior has no chance
d1325 1
a1325 1
/* Return the PC saved in a frame */
d1344 1
a1344 1
     to inspect the instructions. */
d1390 1
a1390 1
     pointer. */
d1392 1
a1392 1
     alloca(), FIXME. */
d1470 2
a1471 2
   was first allocated. For functions calling alloca(), it might be saved in
   an alloca register. */
d1480 2
a1481 2
  /* if the initial stack pointer (frame address) of this frame is known,
     just return it. */
d1486 1
a1486 1
  /* find out if this function is using an alloca register.. */
d1490 2
a1491 1
  /* if saved registers of this frame are not known yet, read and cache them. */
d1497 1
a1497 1
     this frame, and it is good enough. */
d1528 1
a1528 1
   and produces the frame's chain-pointer. */
d1568 1
a1568 1
   isn't available with that word size, return 0. */
d1577 1
a1577 1
   in the current architecture. */
d1600 1
a1600 1
   for register N if that register is available, else return 0. */
d1642 1
a1642 1
   floats are passed as doubles and then converted in the callee. */
d1654 1
a1654 1
   double, we need a conversion if the memory format is float. */
d1664 1
a1664 1
   to virtual format with type TYPE in buffer TO. */
d1680 1
a1680 1
   to raw format for register N in buffer TO. */
d1696 1
a1696 1
   REGNUM. */
d1728 1
a1728 1
   `rs6000_struct_return_address'. */
d1749 1
a1749 1
       FPR1/FPR2/FPR3 triple. */
d1761 1
a1761 1
    /* Everything else is returned in GPR3 and up. */
d1779 1
a1779 1
   for things like stepping through gcc nested function stubs. */
d1787 1
a1787 1
/* Hook called when a new child process is started. */
d1866 1
a1866 1
/* Convenience macros for populating register arrays. */
d1868 1
a1868 1
/* Within another macro, convert S to a string. */
d1873 1
a1873 1
   and 64 bits on 64-bit systems. */
d1877 1
a1877 1
   systems. */
d1881 1
a1881 1
   systems. */
d1885 1
a1885 1
   systems. */
d1888 1
a1888 1
/* Return a struct reg defining floating-point register NAME. */
d1891 1
a1891 1
/* Return a struct reg defining a pseudo register NAME. */
d1895 1
a1895 1
   systems and that doesn't exist on 64-bit systems. */
d1899 1
a1899 1
   systems and that doesn't exist on 32-bit systems. */
d1902 1
a1902 1
/* Return a struct reg placeholder for a register that doesn't exist. */
d1952 1
a1952 1
/* AltiVec registers */
d1961 1
a1961 1
   user-level SPR's. */
d1970 1
a1970 1
   view of the PowerPC. */
d1986 1
a1986 1
/* IBM PowerPC 403. */
d2001 1
a2001 1
/* IBM PowerPC 403GC. */
d2018 1
a2018 1
/* Motorola PowerPC 505. */
d2028 1
a2028 1
/* Motorola PowerPC 860 or 850. */
d2062 1
a2062 1
/* Motorola PowerPC 602. */
d2074 1
a2074 1
/* Motorola/IBM PowerPC 603 or 603e. */
d2086 1
a2086 1
/* Motorola PowerPC 604 or 604e. */
d2098 1
a2098 1
/* Motorola/IBM PowerPC 750 or 740. */
d2114 1
a2114 1
/* Motorola PowerPC 7400. */
d2139 1
a2139 1
    /* bfd_arch_info.arch corresponding to variant. */
d2142 1
a2142 1
    /* bfd_arch_info.mach corresponding to variant. */
d2257 1
a2257 1
  /* FIXME: I haven't checked the register sets of the following. */
d2271 1
a2271 1
/* Initialize the number of registers and pseudo registers in each variant. */
d2288 1
a2288 1
   MACH.  If no such variant exists, return null. */
d2316 1
a2316 1
   a binary file. */
d2344 1
a2344 1
     that, else choose a likely default. */
d2368 1
a2368 1
  /* Find a candidate among extant architectures. */
d2375 1
a2375 1
         separate word size check. */
d2410 1
a2410 1
  /* Choose variant. */
@


1.72
log
@2002-08-19  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (struct reg): Add field to indicate a pseudo
	register.
	(P): New macro to define a register as a pseudo register.
	(R, R4, R8, R16, FR32, R64, R0): Updated.
	(struct variant): Add new fields for number of pseudo registers
	and number of total registers.
	(tot_num_registers): New macro replacing....
	(num_registers): ...deleted macro.
	(num_registers): New function.
	(num_pseudo_registers): New function.
	(variants): Update all variants to intialize new fields correctly.
	Postpone initialization of number of pseudo regs and real regs.
	(init_variants): New function.
	(rs6000_gdbarch_init): Initialize variants.  Update calculation of
	registers offsets.
@
text
@a1690 177
int
altivec_register_p (int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (tdep->ppc_vr0_regnum < 0 || tdep->ppc_vrsave_regnum < 0)
    return 0;
  else
    return (regno >= tdep->ppc_vr0_regnum && regno <= tdep->ppc_vrsave_regnum);
}

static void
rs6000_do_altivec_registers (int regnum)
{
  int i;
  char *raw_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = (char*) alloca (MAX_REGISTER_VIRTUAL_SIZE);
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  for (i = tdep->ppc_vr0_regnum; i <= tdep->ppc_vrsave_regnum; i++)
    {
      /* If we want just one reg, check that this is the one we want. */
      if (regnum != -1 && i != regnum)
	continue;

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
        continue;

      fputs_filtered (REGISTER_NAME (i), gdb_stdout);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), gdb_stdout);

      /* Get the data in raw format.  */
      if (!frame_register_read (selected_frame, i, raw_buffer))
        {
          printf_filtered ("*value not available*\n");
          continue;
        }

      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
	REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				     raw_buffer, virtual_buffer);
      else
	memcpy (virtual_buffer, raw_buffer, REGISTER_VIRTUAL_SIZE (i));

      /* Print as integer in hex only.  */
      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
                 gdb_stdout, 'x', 1, 0, Val_pretty_default);
      printf_filtered ("\n");
    }
}

static void
rs6000_altivec_registers_info (char *addr_exp, int from_tty)
{
  int regnum, numregs;
  register char *end;

  if (!target_has_registers)
    error ("The program has no registers now.");
  if (selected_frame == NULL)
    error ("No selected frame.");

  if (!addr_exp)
    {
      rs6000_do_altivec_registers (-1);
      return;
    }

  numregs = NUM_REGS + NUM_PSEUDO_REGS;
  do
    {
      if (addr_exp[0] == '$')
	addr_exp++;
      end = addr_exp;
      while (*end != '\0' && *end != ' ' && *end != '\t')
	++end;

      regnum = target_map_name_to_register (addr_exp, end - addr_exp);
      if (regnum < 0)
        {
          regnum = numregs;
          if (*addr_exp >= '0' && *addr_exp <= '9')
	    regnum = atoi (addr_exp);	/* Take a number */
          if (regnum >= numregs)	/* Bad name, or bad number */
	    error ("%.*s: invalid register", end - addr_exp, addr_exp);
	}

      rs6000_do_altivec_registers (regnum);

      addr_exp = end;
      while (*addr_exp == ' ' || *addr_exp == '\t')
	++addr_exp;
    }
  while (*addr_exp != '\0');
}

static void
rs6000_do_registers_info (int regnum, int fpregs)
{
  register int i;
  int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char *raw_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = (char*) alloca (MAX_REGISTER_VIRTUAL_SIZE);

  for (i = 0; i < numregs; i++)
    {
      /* Decide between printing all regs, nonfloat regs, or specific reg.  */
      if (regnum == -1)
        {
          if ((TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT && !fpregs)
	      || (altivec_register_p (i) && !fpregs))
            continue;
        }
      else
        {
          if (i != regnum)
            continue;
        }

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
        continue;

      fputs_filtered (REGISTER_NAME (i), gdb_stdout);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), gdb_stdout);

      /* Get the data in raw format.  */
      if (!frame_register_read (selected_frame, i, raw_buffer))
        {
          printf_filtered ("*value not available*\n");
          continue;
        }

      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
        REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				     raw_buffer, virtual_buffer);
      else
	memcpy (virtual_buffer, raw_buffer, REGISTER_VIRTUAL_SIZE (i));

      /* If virtual format is floating, print it that way, and in raw hex.  */
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
        {
          register int j;

	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     gdb_stdout, 0, 1, 0, Val_pretty_default);

          printf_filtered ("\t(raw 0x");
          for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
            {
              register int idx = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? j
		: REGISTER_RAW_SIZE (i) - 1 - j;
              printf_filtered ("%02x", (unsigned char) raw_buffer[idx]);
            }
          printf_filtered (")");
        }
      else
	{
	  /* Print the register in hex.  */
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     gdb_stdout, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also in decimal.  */
	  if (!altivec_register_p (i))
	    {
	      printf_filtered ("\t");
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 gdb_stdout, 0, 1, 0, Val_pretty_default);
	    }
	}
      printf_filtered ("\n");
    }
}

a2182 1

a2486 1
  set_gdbarch_do_registers_info (gdbarch, rs6000_do_registers_info);
a2618 4

  add_cmd ("altivec", class_info, rs6000_altivec_registers_info,
	   "Display the contents of the AltiVec registers.",
	   &info_powerpc_cmdlist);
@


1.71
log
@2002-08-19  Elena Zannoni  <ezannoni@@redhat.com>

        * rs6000-tdep.c (TDEP): Delete macro.
        (branch_dest): Replace use of TDEP macro with its body.
        (rs6000_pop_frame): Ditto.
        (rs6000_push_arguments): Ditto.
        (rs6000_skip_trampoline_code): Ditto.
        (rs6000_frame_saved_pc): Ditto.
        (rs6000_frame_chain): Ditto.
        (rs6000_register_name): Ditto.
        (rs6000_register_byte): Ditto.
        (rs6000_register_raw_size): Ditto.
        (rs6000_register_virtual_type): Ditto.
        (rs6000_register_convertible): Ditto.
        (rs6000_convert_from_func_ptr_addr): Ditto.
@
text
@d89 1
d2047 1
a2047 1
#define R(name)		{ STR(name), 4, 8, 0 }
d2051 1
a2051 1
#define R4(name)	{ STR(name), 4, 4, 0 }
d2055 1
a2055 1
#define R8(name)	{ STR(name), 8, 8, 0 }
d2059 1
a2059 1
#define R16(name)       { STR(name), 16, 16, 0 }
d2062 4
a2065 1
#define F(name)		{ STR(name), 8, 8, 1 }
d2069 1
a2069 1
#define R32(name)	{ STR(name), 4, 0, 0 }
d2073 1
a2073 1
#define R64(name)	{ STR(name), 0, 8, 0 }
d2076 1
a2076 1
#define R0		{ 0, 0, 0, 0 }
d2318 9
a2328 1
    int nregs;
d2332 27
a2358 1
#define num_registers(list) (sizeof (list) / sizeof((list)[0]))
d2371 1
a2371 1
static const struct variant variants[] =
d2373 1
d2375 2
a2376 1
   bfd_mach_ppc, num_registers (registers_powerpc), registers_powerpc},
d2378 2
a2379 1
   bfd_mach_rs6k, num_registers (registers_power), registers_power},
d2381 2
a2382 1
   bfd_mach_ppc_403, num_registers (registers_403), registers_403},
d2384 2
a2385 1
   bfd_mach_ppc_601, num_registers (registers_601), registers_601},
d2387 2
a2388 1
   bfd_mach_ppc_602, num_registers (registers_602), registers_602},
d2390 2
a2391 1
   bfd_mach_ppc_603, num_registers (registers_603), registers_603},
d2393 2
a2394 1
   604, num_registers (registers_604), registers_604},
d2396 2
a2397 1
   bfd_mach_ppc_403gc, num_registers (registers_403GC), registers_403GC},
d2399 2
a2400 1
   bfd_mach_ppc_505, num_registers (registers_505), registers_505},
d2402 2
a2403 1
   bfd_mach_ppc_860, num_registers (registers_860), registers_860},
d2405 2
a2406 1
   bfd_mach_ppc_750, num_registers (registers_750), registers_750},
d2408 2
a2409 1
   bfd_mach_ppc_7400, num_registers (registers_7400), registers_7400},
d2413 2
a2414 1
   bfd_mach_ppc64, num_registers (registers_powerpc), registers_powerpc},
d2416 2
a2417 1
   bfd_mach_ppc_620, num_registers (registers_powerpc), registers_powerpc},
d2419 2
a2420 1
   bfd_mach_ppc_630, num_registers (registers_powerpc), registers_powerpc},
d2422 2
a2423 1
   bfd_mach_ppc_a35, num_registers (registers_powerpc), registers_powerpc},
d2425 2
a2426 1
   bfd_mach_ppc_rs64ii, num_registers (registers_powerpc), registers_powerpc},
d2428 2
a2429 1
   bfd_mach_ppc_rs64iii, num_registers (registers_powerpc), registers_powerpc},
d2433 2
a2434 1
   bfd_mach_rs6k_rs1, num_registers (registers_power), registers_power},
d2436 2
a2437 1
   bfd_mach_rs6k_rsc, num_registers (registers_power), registers_power},
d2439 2
a2440 1
   bfd_mach_rs6k_rs2, num_registers (registers_power), registers_power},
d2442 1
a2442 1
  {0, 0, 0, 0}
d2445 15
a2459 1
#undef num_registers
d2581 3
d2633 2
a2634 2
  tdep->regoff = xmalloc (v->nregs * sizeof (int));
  for (i = off = 0; i < v->nregs; i++)
@


1.70
log
@2002-07-15  Elena Zannoni  <ezannoni@@redhat.com>

        * rs6000-tdep.c (rs6000_gdbarch_init): Remove variable print_insn
        and its setting.  Set gdbarch instruction printing functions
        directly.  For non-rs6000 case use new function
        gdb_print_insn_powerpc.
        (gdb_print_insn_powerpc): New function.
@
text
@a90 4
/* Return the current architecture's gdbarch_tdep structure. */

#define TDEP	gdbarch_tdep (current_gdbarch)

d251 1
a251 1
					 TDEP->wordsize);
d856 1
a856 1
  wordsize = TDEP->wordsize;
d941 1
a941 1
  int wordsize = TDEP->wordsize;
d1283 1
a1283 1
  pc = read_memory_addr (ii, TDEP->wordsize); /* (r11) value */
d1328 1
a1328 1
  struct gdbarch_tdep *tdep = TDEP;
d1532 1
a1532 1
  int wordsize = TDEP->wordsize;
d1577 1
a1577 1
  struct gdbarch_tdep *tdep = TDEP;
d1591 1
a1591 1
  return TDEP->regoff[n];
d1600 1
a1600 1
  struct gdbarch_tdep *tdep = TDEP;
d1611 1
a1611 1
  struct gdbarch_tdep *tdep = TDEP;
d1654 1
a1654 1
  const struct reg *reg = TDEP->regs + n;
d1997 1
a1997 1
  return read_memory_addr (addr, TDEP->wordsize);
@


1.69
log
@* rs6000-tdep.c (rs6000_gdbarch_init): Use
generic_unwind_get_saved_register.
@
text
@d2405 9
a2434 1
  gdbarch_print_insn_ftype *print_insn;
d2569 1
a2569 3
    print_insn = print_insn_rs6000;
  else if (info.byte_order == BFD_ENDIAN_BIG)
    print_insn = print_insn_big_powerpc;
d2571 1
a2571 2
    print_insn = print_insn_little_powerpc;
  set_gdbarch_print_insn (gdbarch, print_insn);
@


1.68
log
@* gdbarch.sh (REGISTER_NAME): Change return type a constant string
pointer.
* gdbarch.h, gdbarch.c: Regenerate.
* config/mips/tm-mips.h (mips_register_name): Update.
* i386-tdep.h (i386_register_name): Update.
* mips-tdep.c (mips_register_name): Update
* alpha-tdep.c (alpha_register_name): Update.
* arch-utils.c (legacy_register_name): Update.
* arch-utils.h (legacy_register_name): Update.
* avr-tdep.c (avr_register_name): Update.
* ia64-tdep.c (ia64_register_name): Update.
* i386-tdep.c (i386_register_name): Update.
* sparc-tdep.c (sparc32_register_name): Update.
(sparc64_register_name): Update.
(sparclite_register_name): Update.
(sparclet_register_name):
* sh-tdep.c (sh_generic_register_name): Update.
(sh_sh_register_name): Update.
(sh_sh3_register_name): Update.
(sh_sh3e_register_name): Update.
(sh_sh_dsp_register_name): Update.
(sh_sh3_dsp_register_name): Update.
(sh_sh4_register_name): Update.
(sh_sh64_register_name): Update.
* s390-tdep.c (s390_register_name): Update.
* rs6000-tdep.c (rs6000_register_name): Update.
* ns32k-tdep.c (ns32k_register_name_32082): Update.
(ns32k_register_name_32382): Update.
* d10v-tdep.c (d10v_ts2_register_name): Update.
(d10v_ts3_register_name): Update.
* xstormy16-tdep.c (xstormy16_register_name): Update.
* vax-tdep.c (vax_register_name): Update.
* v850-tdep.c (v850_register_name): Update.
* m68hc11-tdep.c (m68hc11_register_name): Update.
* mn10300-tdep.c (mn10300_generic_register_name): Update.
(am33_register_name): Update.
@
text
@d2609 1
a2609 1
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
@


1.67
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d1578 1
a1578 1
static char *
@


1.66
log
@* Makefile.in (ppc_tdep_h): Define.
(ppc-linux-nat.o)
(ppc-linux-tdep.o)
(rs6000-tdep.o): Use $(ppc_tdep_h).
(ppc-sysv-tdep.o)
(ppcnbsd-nat.o)
(ppcnbsd-tdep.o): New dependency lists.
* ppc-tdep.h: Use generic OS ABI framework.
* ppc-linux-tdep.c (_initialize_ppc_linux_tdep,
ppc_linux_init_abi): New functions.
(ppc_sysv_abi_broken_use_struct_convention)
(ppc_sysv_abi_use_struct_convention)
(ppc_sysv_abi_push_arguments): Move to...
* ppc-sysv-tdep.c: ...here.
* ppcnbsd-nat.c: Don't include gdbcore.h and regcache.h.
* rs6000-tdep.c (process_note_abi_tag_sections)
(get_elfosabi): Remove.
(rs6000_gdbarch_init): Use generic OS ABI framework.
(rs6000_dump_tdep): New function.
(_initialize_rs6000_tdep): Use gdbarch_register.
* config/powerpc/linux.mt (TDEPFILES): Add ppc-sysv-tdep.o.
* config/powerpc/nbsd.mh (NATDEPFILES): Remove solib-legacy.o.
* config/powerpc/aix.mt (TDEPFILES): Use ppc-sysv-tdep.o instead
of ppc-linux-tdep.o.
* config/powerpc/nbsd.mt (TDEPFILES): Likewise.
* config/powerpc/ppc-eabi.mt (TDEPFILES): Likewise.
* config/powerpc/ppc-sim.mt (TDEPFILES): Likewise.
* config/powerpc/ppcle-eabi.mt (TDEPFILES): Likewise.
* config/powerpc/ppcle-sim.mt (TDEPFILES): Likewise.
* config/powerpc/vxworks.mt (TDEPFILES): Likewise.
@
text
@d2622 1
a2622 1
  set_gdbarch_extract_return_value (gdbarch, rs6000_extract_return_value);
d2638 1
a2638 1
  set_gdbarch_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
@


1.65
log
@2002-05-20  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (rs6000_do_registers_info): Simplify code for
	printing vector registers.
@
text
@a2404 80




static void
process_note_abi_tag_sections (bfd *abfd, asection *sect, void *obj)
{
  int *os_ident_ptr = obj;
  const char *name;
  unsigned int sectsize;

  name = bfd_get_section_name (abfd, sect);
  sectsize = bfd_section_size (abfd, sect);
  if (strcmp (name, ".note.ABI-tag") == 0 && sectsize > 0)
    {
      unsigned int name_length, data_length, note_type;
      char *note = alloca (sectsize);

      bfd_get_section_contents (abfd, sect, note,
                                (file_ptr) 0, (bfd_size_type) sectsize);

      name_length = bfd_h_get_32 (abfd, note);
      data_length = bfd_h_get_32 (abfd, note + 4);
      note_type   = bfd_h_get_32 (abfd, note + 8);

      if (name_length == 4 && data_length == 16 && note_type == 1
          && strcmp (note + 12, "GNU") == 0)
	{
	  int os_number = bfd_h_get_32 (abfd, note + 16);

	  /* The case numbers are from abi-tags in glibc */
	  switch (os_number)
	    {
	    case 0 :
	      *os_ident_ptr = ELFOSABI_LINUX;
	      break;
	    case 1 :
	      *os_ident_ptr = ELFOSABI_HURD;
	      break;
	    case 2 :
	      *os_ident_ptr = ELFOSABI_SOLARIS;
	      break;
	    default :
	      internal_error (__FILE__, __LINE__,
			      "process_note_abi_sections: unknown OS number %d",
			      os_number);
	      break;
	    }
	}
    }
}

/* Return one of the ELFOSABI_ constants for BFDs representing ELF
   executables.  If it's not an ELF executable or if the OS/ABI couldn't
   be determined, simply return -1. */

static int
get_elfosabi (bfd *abfd)
{
  int elfosabi = -1;

  if (abfd != NULL && bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    {
      elfosabi = elf_elfheader (abfd)->e_ident[EI_OSABI];

      /* When elfosabi is 0 (ELFOSABI_NONE), this is supposed to indicate
         that we're on a SYSV system.  However, GNU/Linux uses a note section
	 to record OS/ABI info, but leaves e_ident[EI_OSABI] zero.  So we
	 have to check the note sections too. */
      if (elfosabi == 0)
	{
	  bfd_map_over_sections (abfd,
	                         process_note_abi_tag_sections,
				 &elfosabi);
	}
    }

  return elfosabi;
}

a2405 1

d2424 2
a2425 1
  int osabi, sysv_abi;
d2436 2
a2437 1
  osabi = get_elfosabi (info.abfd);
a2649 4
  /* Until November 2001, gcc was not complying to the SYSV ABI for
     returning structures less than or equal to 8 bytes in size. It was
     returning everything in memory. When this was corrected, it wasn't
     fixed for native platforms. */
d2651 2
a2652 10
    {
      if (osabi == ELFOSABI_LINUX
          || osabi == ELFOSABI_NETBSD
          || osabi == ELFOSABI_FREEBSD)
	set_gdbarch_use_struct_convention (gdbarch,
					   ppc_sysv_abi_broken_use_struct_convention);
      else
	set_gdbarch_use_struct_convention (gdbarch,
					   ppc_sysv_abi_use_struct_convention);
    }
d2654 2
a2655 4
    {
      set_gdbarch_use_struct_convention (gdbarch,
					 generic_use_struct_convention);
    }
a2657 25
  /* Note: kevinb/2002-04-12: See note above regarding *_push_arguments().
     The same remarks hold for the methods below.  */
  if (osabi == ELFOSABI_LINUX && wordsize == 4)
    {
      set_gdbarch_frameless_function_invocation (gdbarch,
	ppc_linux_frameless_function_invocation);
      set_gdbarch_frame_chain (gdbarch, ppc_linux_frame_chain);
      set_gdbarch_frame_saved_pc (gdbarch, ppc_linux_frame_saved_pc);

      set_gdbarch_frame_init_saved_regs (gdbarch,
	                                 ppc_linux_frame_init_saved_regs);
      set_gdbarch_init_extra_frame_info (gdbarch,
	                                 ppc_linux_init_extra_frame_info);

      set_gdbarch_memory_remove_breakpoint (gdbarch,
	                                    ppc_linux_memory_remove_breakpoint);
      set_solib_svr4_fetch_link_map_offsets 
	(gdbarch, ppc_linux_svr4_fetch_link_map_offsets);
    }
  else
    {
      set_gdbarch_frameless_function_invocation (gdbarch,
	rs6000_frameless_function_invocation);
      set_gdbarch_frame_chain (gdbarch, rs6000_frame_chain);
      set_gdbarch_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);
d2659 8
a2666 3
      set_gdbarch_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
      set_gdbarch_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);
    }
d2682 3
d2688 12
d2713 2
a2714 2
  register_gdbarch_init (bfd_arch_rs6000, rs6000_gdbarch_init);
  register_gdbarch_init (bfd_arch_powerpc, rs6000_gdbarch_init);
a2723 1

@


1.65.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1578 1
a1578 1
static const char *
d2405 80
d2486 1
d2505 1
a2505 2
  int sysv_abi;
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d2516 1
a2516 2
  if (info.abfd)
    osabi = gdbarch_lookup_osabi (info.abfd);
d2701 1
a2701 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, rs6000_extract_return_value);
d2717 1
a2717 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
d2729 4
d2734 10
a2743 2
    set_gdbarch_use_struct_convention (gdbarch,
    				       ppc_sysv_abi_use_struct_convention);
d2745 4
a2748 2
    set_gdbarch_use_struct_convention (gdbarch,
				       generic_use_struct_convention);
d2751 25
d2777 3
a2779 8
  set_gdbarch_frameless_function_invocation (gdbarch,
                                         rs6000_frameless_function_invocation);
  set_gdbarch_frame_chain (gdbarch, rs6000_frame_chain);
  set_gdbarch_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);

  set_gdbarch_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
  set_gdbarch_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);

a2794 3
  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch, osabi);

a2797 12
static void
rs6000_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (tdep == NULL)
    return;

  fprintf_unfiltered (file, "rs6000_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
}

d2811 2
a2812 2
  gdbarch_register (bfd_arch_rs6000, rs6000_gdbarch_init, rs6000_dump_tdep);
  gdbarch_register (bfd_arch_powerpc, rs6000_gdbarch_init, rs6000_dump_tdep);
d2822 1
@


1.65.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a2404 9

static int
gdb_print_insn_powerpc (bfd_vma memaddr, disassemble_info *info)
{
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    return print_insn_big_powerpc (memaddr, info);
  else
    return print_insn_little_powerpc (memaddr, info);
}
d2426 1
d2561 3
a2563 1
    set_gdbarch_print_insn (gdbarch, print_insn_rs6000);
d2565 2
a2566 1
    set_gdbarch_print_insn (gdbarch, gdb_print_insn_powerpc);
d2609 1
a2609 1
  set_gdbarch_get_saved_register (gdbarch, generic_unwind_get_saved_register);
@


1.65.2.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a69 1
    int saved_ev;               /* smallest # of saved ev */
a75 1
    int ev_offset;              /* offset of saved evs from prev sp */
a88 1
    unsigned char pseudo;       /* whether register is pseudo */
d91 4
a126 11
/* Is REGNO an AltiVec register?  Return 1 if so, 0 otherwise.  */
int
altivec_register_p (int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (tdep->ppc_vr0_regnum < 0 || tdep->ppc_vrsave_regnum < 0)
    return 0;
  else
    return (regno >= tdep->ppc_vr0_regnum && regno <= tdep->ppc_vrsave_regnum);
}

d255 1
a255 1
					 gdbarch_tdep (current_gdbarch)->wordsize);
a364 1
   - saved_ev is the number of the first saved ev.
a369 1
   - ev_offset is the offset of the first saved ev from the previous frame.
a446 2
  int ev_reg = -1;
  long ev_offset = 0;
d453 1
a453 2
  const struct bfd_arch_info *arch_info = gdbarch_bfd_arch_info (current_gdbarch);
  
a472 1
  fdata->saved_ev = -1;
d539 1
a539 1
	  /* nop */
d653 1
a653 1
               ((long) ((op >> 16) & 31) >= fdata->saved_gpr)) /* Rx: local var reg */
d734 1
a734 3
      /* 001110 01110 00000 iiii iiii iiii iiii  */
      else if ((op & 0xffff0000) == 0x38000000         /* li r0, SIMM */
               || (op & 0xffff0000) == 0x39c00000)     /* li r14, SIMM */
a759 98

      /* Start BookE related instructions.  */
      /* Store gen register S at (r31+uimm).
         Any register less than r13 is volatile, so we don't care.  */
      /* 000100 sssss 11111 iiiii 01100100001 */
      else if (arch_info->mach == bfd_mach_ppc_e500
	       && (op & 0xfc1f07ff) == 0x101f0321)    /* evstdd Rs,uimm(R31) */
	{
          if ((op & 0x03e00000) >= 0x01a00000)	/* Rs >= r13 */
	    {
              unsigned int imm;
	      ev_reg = GET_SRC_REG (op);
              imm = (op >> 11) & 0x1f;
	      ev_offset = imm * 8;
	      /* If this is the first vector reg to be saved, or if
		 it has a lower number than others previously seen,
		 reupdate the frame info.  */
	      if (fdata->saved_ev == -1 || fdata->saved_ev > ev_reg)
		{
		  fdata->saved_ev = ev_reg;
		  fdata->ev_offset = ev_offset + offset;
		}
	    }
          continue;
        }
      /* Store gen register rS at (r1+rB).  */
      /* 000100 sssss 00001 bbbbb 01100100000 */
      else if (arch_info->mach == bfd_mach_ppc_e500
	       && (op & 0xffe007ff) == 0x13e00320)     /* evstddx RS,R1,Rb */
	{
          if (pc == (li_found_pc + 4))
            {
              ev_reg = GET_SRC_REG (op);
	      /* If this is the first vector reg to be saved, or if
                 it has a lower number than others previously seen,
                 reupdate the frame info.  */
              /* We know the contents of rB from the previous instruction.  */
	      if (fdata->saved_ev == -1 || fdata->saved_ev > ev_reg)
		{
                  fdata->saved_ev = ev_reg;
                  fdata->ev_offset = vr_saved_offset + offset;
		}
	      vr_saved_offset = -1;
	      ev_reg = -1;
	      li_found_pc = 0;
            }
          continue;
        }
      /* Store gen register r31 at (rA+uimm).  */
      /* 000100 11111 aaaaa iiiii 01100100001 */
      else if (arch_info->mach == bfd_mach_ppc_e500
	       && (op & 0xffe007ff) == 0x13e00321)   /* evstdd R31,Ra,UIMM */
        {
          /* Wwe know that the source register is 31 already, but
             it can't hurt to compute it.  */
	  ev_reg = GET_SRC_REG (op);
          ev_offset = ((op >> 11) & 0x1f) * 8;
	  /* If this is the first vector reg to be saved, or if
	     it has a lower number than others previously seen,
	     reupdate the frame info.  */
	  if (fdata->saved_ev == -1 || fdata->saved_ev > ev_reg)
	    {
	      fdata->saved_ev = ev_reg;
	      fdata->ev_offset = ev_offset + offset;
	    }

	  continue;
      	}
      /* Store gen register S at (r31+r0).
         Store param on stack when offset from SP bigger than 4 bytes.  */
      /* 000100 sssss 11111 00000 01100100000 */
      else if (arch_info->mach == bfd_mach_ppc_e500
	       && (op & 0xfc1fffff) == 0x101f0320)     /* evstddx Rs,R31,R0 */
	{
          if (pc == (li_found_pc + 4))
            {
              if ((op & 0x03e00000) >= 0x01a00000)
		{
		  ev_reg = GET_SRC_REG (op);
		  /* If this is the first vector reg to be saved, or if
		     it has a lower number than others previously seen,
		     reupdate the frame info.  */
                  /* We know the contents of r0 from the previous
                     instruction.  */
		  if (fdata->saved_ev == -1 || fdata->saved_ev > ev_reg)
		    {
		      fdata->saved_ev = ev_reg;
		      fdata->ev_offset = vr_saved_offset + offset;
		    }
		  ev_reg = -1;
		}
	      vr_saved_offset = -1;
	      li_found_pc = 0;
	      continue;
            }
	}
      /* End BookE related instructions.  */

d776 1
a776 1
	    /* Never skip branches.  */
d797 1
a797 1
     We'd like to skip over it as well.  Fortunately, xlc does some extra
d799 1
a799 1
     single out such gcc2 behaviour.  */
d809 2
a810 2
	  /* Check and see if we are in main.  If so, skip over this
	     initializer function as well.  */
d830 1
a830 1
/* Pop the innermost frame, go back to the caller.  */
d853 1
a853 1
  /* Figure out previous %pc value.  If the function is frameless, it is 
d855 1
a855 1
     saved %pc value in the previous frame.  */
d860 1
a860 1
  wordsize = gdbarch_tdep (current_gdbarch)->wordsize;
d873 1
a873 1
  /* reset register values if any was saved earlier.  */
d901 1
a901 1
   address.  Its arguments will be passed by gdb.  */
d923 2
a924 2
   passed in fpr's, in addition to that.  Rest of the parameters if any
   are passed in user stack.  There might be cases in which half of the
d933 1
a933 1
   starting from r4.  */
d945 1
a945 1
  int wordsize = gdbarch_tdep (current_gdbarch)->wordsize;
d952 2
a953 2
  /* The first eight words of ther arguments are passed in registers.
     Copy them appropriately.
d956 1
a956 1
     will be passed in r3) is used for struct return address.  In that
d958 1
a958 1
     parameters.  */
d992 1
a992 1
	  /* Floating point arguments are passed in fpr's, as well as gpr's.
d994 1
a994 1
	     there is no way we would run out of them.  */
d1009 1
a1009 1
	  /* Argument takes more than one register.  */
d1026 1
a1026 2
	{
	  /* Argument can fit in one register.  No problem.  */
d1039 1
a1039 1
  /* Location for 8 parameters are always reserved.  */
d1042 1
a1042 1
  /* Another six words for back chain, TOC register, link register, etc.  */
d1045 1
a1045 1
  /* Stack pointer must be quadword aligned.  */
d1048 2
a1049 2
  /* If there are more arguments, allocate space for them in 
     the stack, then push them starting from the ninth one.  */
d1069 1
a1069 1
      /* Add location required for the rest of the parameters.  */
d1073 4
a1076 5
      /* This is another instance we need to be concerned about
         securing our stack space. If we write anything underneath %sp
         (r1), we might conflict with the kernel who thinks he is free
         to use this area. So, update %sp first before doing anything
         else.  */
d1080 2
a1081 2
      /* If the last argument copied into the registers didn't fit there 
         completely, push the rest of it into stack.  */
d1092 1
a1092 1
      /* Push the rest of the arguments into stack.  */
d1101 1
a1101 2
	  /* Float types should be passed in fpr's, as well as in the
             stack.  */
d1120 1
a1120 1
    /* Secure stack areas first, before doing anything else.  */
d1132 1
a1132 1
   Set up the return address for the inferior function call.  */
d1143 1
a1143 57
   REGBUF, and copy that return value into VALBUF in virtual format.  */
static void
e500_extract_return_value (struct type *valtype, struct regcache *regbuf, void *valbuf)
{
  int offset = 0;
  int vallen = TYPE_LENGTH (valtype);
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY
      && vallen == 8
      && TYPE_VECTOR (valtype))
    {
      regcache_raw_read (regbuf, tdep->ppc_ev0_regnum + 3, valbuf);
    }
  else
    {
      /* Return value is copied starting from r3.  Note that r3 for us
         is a pseudo register.  */
      int offset = 0;
      int return_regnum = tdep->ppc_gp0_regnum + 3;
      int reg_size = REGISTER_RAW_SIZE (return_regnum);
      int reg_part_size;
      char *val_buffer;
      int copied = 0;
      int i = 0;

      /* Compute where we will start storing the value from.  */ 
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
        {
	  if (vallen <= reg_size)
	    offset = reg_size - vallen;
	  else
	    offset = reg_size + (reg_size - vallen);
        }

      /* How big does the local buffer need to be?  */
      if (vallen <= reg_size)
	val_buffer = alloca (reg_size);
      else
	val_buffer = alloca (vallen);

      /* Read all we need into our private buffer.  We copy it in
         chunks that are as long as one register, never shorter, even
         if the value is smaller than the register.  */
      while (copied < vallen)
        {
          reg_part_size = REGISTER_RAW_SIZE (return_regnum + i);
	  /* It is a pseudo/cooked register.  */
          regcache_cooked_read (regbuf, return_regnum + i,
				val_buffer + copied);
          copied += reg_part_size;
          i++;
        }
      /* Put the stuff in the return buffer.  */
      memcpy (valbuf, val_buffer + offset, vallen);
    }
}
d1158 1
a1158 1
         necessary.  */
d1287 1
a1287 1
  pc = read_memory_addr (ii, gdbarch_tdep (current_gdbarch)->wordsize); /* (r11) value */
d1307 1
a1307 1
     to inspect the instructions.  */
d1313 1
a1313 1
         inferior.  Mark function as frameless, as the inferior has no chance
d1325 1
a1325 1
/* Return the PC saved in a frame.  */
d1332 1
a1332 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1344 1
a1344 1
     to inspect the instructions.  */
d1390 1
a1390 1
     pointer.  */
d1392 1
a1392 1
     alloca(), FIXME.  */
a1396 1
      && fdatap->saved_ev == 0
d1399 1
a1399 2
      && fdatap->vr_offset == 0
      && fdatap->ev_offset == 0)
a1452 17
  /* if != -1, fdatap->saved_ev is the smallest number of saved_ev.
	All vr's from saved_ev to ev31 are saved. ?????	*/
  if (tdep->ppc_ev0_regnum != -1 && tdep->ppc_ev31_regnum != -1)
    {
      if (fdatap->saved_ev >= 0)
	{
	  int i;
	  CORE_ADDR ev_addr = frame_addr + fdatap->ev_offset;
	  for (i = fdatap->saved_ev; i < 32; i++)
	    {
	      fi->saved_regs[tdep->ppc_ev0_regnum + i] = ev_addr;
              fi->saved_regs[tdep->ppc_gp0_regnum + i] = ev_addr + 4;
	      ev_addr += REGISTER_RAW_SIZE (tdep->ppc_ev0_regnum);
            }
	}
    }

d1470 2
a1471 2
   was first allocated.  For functions calling alloca(), it might be saved in
   an alloca register.  */
d1480 2
a1481 2
  /* If the initial stack pointer (frame address) of this frame is known,
     just return it.  */
d1486 1
a1486 1
  /* Find out if this function is using an alloca register.  */
d1490 1
a1490 2
  /* If saved registers of this frame are not known yet, read and
     cache them.  */
d1496 1
a1496 1
     this frame, and it is good enough.  */
d1527 1
a1527 1
   and produces the frame's chain-pointer.  */
d1536 1
a1536 1
  int wordsize = gdbarch_tdep (current_gdbarch)->wordsize;
d1567 1
a1567 1
   isn't available with that word size, return 0.  */
d1576 1
a1576 1
   in the current architecture.  */
d1581 1
a1581 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1595 1
a1595 1
  return gdbarch_tdep (current_gdbarch)->regoff[n];
d1599 1
a1599 1
   for register N if that register is available, else return 0.  */
d1604 1
a1604 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1615 1
a1615 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1626 1
a1626 4
	  if (tdep->ppc_ev0_regnum <= n && n <= tdep->ppc_ev31_regnum)
	    return builtin_type_vec64;
	  else
	    return builtin_type_int64;
d1641 1
a1641 1
   floats are passed as doubles and then converted in the callee.  */
d1653 1
a1653 1
   double, we need a conversion if the memory format is float.  */
d1658 1
a1658 1
  const struct reg *reg = gdbarch_tdep (current_gdbarch)->regs + n;
d1663 1
a1663 1
   to virtual format with type TYPE in buffer TO.  */
d1679 1
a1679 1
   to raw format for register N in buffer TO.  */
d1694 10
d1705 1
a1705 2
e500_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int reg_nr, void *buffer)
d1707 4
a1710 4
  int base_regnum;
  int offset = 0;
  char *temp_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d1712 1
a1712 2
  if (reg_nr >= tdep->ppc_gp0_regnum 
      && reg_nr <= tdep->ppc_gplast_regnum)
d1714 8
a1721 1
      base_regnum = reg_nr - tdep->ppc_gp0_regnum + tdep->ppc_ev0_regnum;
d1723 21
a1743 6
      /* Build the value in the provided buffer.  */ 
      /* Read the raw register of which this one is the lower portion.  */
      regcache_raw_read (regcache, base_regnum, temp_buffer);
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = 4;
      memcpy ((char *) buffer, temp_buffer + offset, 4);
d1748 1
a1748 2
e500_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int reg_nr, const void *buffer)
d1750 7
a1756 4
  int base_regnum;
  int offset = 0;
  char *temp_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d1758 1
a1758 2
  if (reg_nr >= tdep->ppc_gp0_regnum 
      && reg_nr <= tdep->ppc_gplast_regnum)
d1760 3
a1762 4
      base_regnum = reg_nr - tdep->ppc_gp0_regnum + tdep->ppc_ev0_regnum;
      /* reg_nr is 32 bit here, and base_regnum is 64 bits.  */
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = 4;
d1764 8
a1771 4
      /* Let's read the value of the base register into a temporary
	 buffer, so that overwriting the last four bytes with the new
	 value of the pseudo will leave the upper 4 bytes unchanged.  */
      regcache_raw_read (regcache, base_regnum, temp_buffer);
d1773 15
a1787 3
      /* Write as an 8 byte quantity.  */
      memcpy (temp_buffer + offset, (char *) buffer, 4);
      regcache_raw_write (regcache, base_regnum, temp_buffer);
d1789 1
d1792 2
a1793 3
/* Convert a dwarf2 register number to a gdb REGNUM.  */
static int
e500_dwarf2_reg_to_regnum (int num)
d1795 74
a1868 5
  int regnum;
  if (0 <= num && num <= 31)
    return num + gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum;
  else 
    return num;
d1872 1
a1872 1
   REGNUM.  */
d1904 1
a1904 1
   `rs6000_struct_return_address'.  */
a1914 21
static void
e500_store_return_value (struct type *type, char *valbuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* Everything is returned in GPR3 and up.  */
  int copied = 0;
  int i = 0;
  int len = TYPE_LENGTH (type);
  while (copied < len)
    {
      int regnum = gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum + 3 + i;
      int reg_size = REGISTER_RAW_SIZE (regnum);
      char *reg_val_buf = alloca (reg_size);

      memcpy (reg_val_buf, valbuf + copied, reg_size);
      copied += reg_size;
      write_register_gen (regnum, reg_val_buf);
      i++;
    }
}
d1925 1
a1925 1
       FPR1/FPR2/FPR3 triple.  */
d1937 1
a1937 1
    /* Everything else is returned in GPR3 and up.  */
d1955 1
a1955 1
   for things like stepping through gcc nested function stubs.  */
d1963 1
a1963 1
/* Hook called when a new child process is started.  */
d2001 1
a2001 1
  return read_memory_addr (addr, gdbarch_tdep (current_gdbarch)->wordsize);
d2042 1
a2042 1
/* Convenience macros for populating register arrays.  */
d2044 1
a2044 1
/* Within another macro, convert S to a string.  */
d2049 2
a2050 2
   and 64 bits on 64-bit systems.  */
#define R(name)		{ STR(name), 4, 8, 0, 0 }
d2053 2
a2054 2
   systems.  */
#define R4(name)	{ STR(name), 4, 4, 0, 0 }
d2057 2
a2058 2
   systems.  */
#define R8(name)	{ STR(name), 8, 8, 0, 0 }
d2061 2
a2062 5
   systems.  */
#define R16(name)       { STR(name), 16, 16, 0, 0 }

/* Return a struct reg defining floating-point register NAME.  */
#define F(name)		{ STR(name), 8, 8, 1, 0 }
d2064 2
a2065 2
/* Return a struct reg defining a pseudo register NAME.  */
#define P(name)		{ STR(name), 4, 8, 0, 1}
d2068 2
a2069 2
   systems and that doesn't exist on 64-bit systems.  */
#define R32(name)	{ STR(name), 4, 0, 0, 0 }
d2072 2
a2073 2
   systems and that doesn't exist on 32-bit systems.  */
#define R64(name)	{ STR(name), 0, 8, 0, 0 }
d2075 2
a2076 2
/* Return a struct reg placeholder for a register that doesn't exist.  */
#define R0		{ 0, 0, 0, 0, 0 }
a2105 4
/* UISA-level SPRs for PowerPC without floating point support.  */
#define PPC_UISA_NOFP_SPRS \
  /* 66 */ R4(cr),  R(lr), R(ctr), R4(xer), R0

d2125 1
a2125 1
/* AltiVec registers.  */
a2132 14
/* Vectors of hi-lo general purpose registers.  */
#define PPC_EV_REGS \
  /* 0*/R8(ev0), R8(ev1), R8(ev2), R8(ev3), R8(ev4), R8(ev5), R8(ev6), R8(ev7),  \
  /* 8*/R8(ev8), R8(ev9), R8(ev10),R8(ev11),R8(ev12),R8(ev13),R8(ev14),R8(ev15), \
  /*16*/R8(ev16),R8(ev17),R8(ev18),R8(ev19),R8(ev20),R8(ev21),R8(ev22),R8(ev23), \
  /*24*/R8(ev24),R8(ev25),R8(ev26),R8(ev27),R8(ev28),R8(ev29),R8(ev30),R8(ev31)

/* Lower half of the EV registers.  */
#define PPC_GPRS_PSEUDO_REGS \
  /*  0 */ P(r0), P(r1), P(r2), P(r3), P(r4), P(r5), P(r6), P(r7),  \
  /*  8 */ P(r8), P(r9), P(r10),P(r11),P(r12),P(r13),P(r14),P(r15), \
  /* 16 */ P(r16),P(r17),P(r18),P(r19),P(r20),P(r21),P(r22),P(r23), \
  /* 24 */ P(r24),P(r25),P(r26),P(r27),P(r28),P(r29),P(r30),P(r31), \

d2134 1
a2134 1
   user-level SPR's.  */
d2143 1
a2143 1
   view of the PowerPC.  */
d2159 1
a2159 1
/* IBM PowerPC 403.  */
d2174 1
a2174 1
/* IBM PowerPC 403GC.  */
d2191 1
a2191 1
/* Motorola PowerPC 505.  */
d2201 1
a2201 1
/* Motorola PowerPC 860 or 850.  */
d2235 1
a2235 1
/* Motorola PowerPC 602.  */
d2247 1
a2247 1
/* Motorola/IBM PowerPC 603 or 603e.  */
d2259 1
a2259 1
/* Motorola PowerPC 604 or 604e.  */
d2271 1
a2271 1
/* Motorola/IBM PowerPC 750 or 740.  */
d2287 1
a2287 1
/* Motorola PowerPC 7400.  */
a2301 12
/* Motorola e500.  */
static const struct reg registers_e500[] =
{
  R(pc), R(ps),
  /* cr, lr, ctr, xer, "" */
  PPC_UISA_NOFP_SPRS,
  /* 7...38 */
  PPC_EV_REGS,
  /* 39...70 */
  PPC_GPRS_PSEUDO_REGS
};

d2312 1
a2312 1
    /* bfd_arch_info.arch corresponding to variant.  */
d2315 1
a2315 1
    /* bfd_arch_info.mach corresponding to variant.  */
a2317 9
    /* Number of real registers.  */
    int nregs;

    /* Number of pseudo registers.  */
    int npregs;

    /* Number of total registers (the sum of nregs and npregs).  */
    int num_tot_regs;

d2320 1
d2324 1
a2324 1
#define tot_num_registers(list) (sizeof (list) / sizeof((list)[0]))
a2325 25
static int
num_registers (const struct reg *reg_list, int num_tot_regs)
{
  int i;
  int nregs = 0;

  for (i = 0; i < num_tot_regs; i++)
    if (!reg_list[i].pseudo)
      nregs++;
       
  return nregs;
}

static int
num_pseudo_registers (const struct reg *reg_list, int num_tot_regs)
{
  int i;
  int npregs = 0;

  for (i = 0; i < num_tot_regs; i++)
    if (reg_list[i].pseudo)
      npregs ++; 

  return npregs;
}
d2337 1
a2337 1
static struct variant variants[] =
a2338 1

d2340 1
a2340 2
   bfd_mach_ppc, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2342 1
a2342 2
   bfd_mach_rs6k, -1, -1, tot_num_registers (registers_power),
   registers_power},
d2344 1
a2344 2
   bfd_mach_ppc_403, -1, -1, tot_num_registers (registers_403),
   registers_403},
d2346 1
a2346 2
   bfd_mach_ppc_601, -1, -1, tot_num_registers (registers_601),
   registers_601},
d2348 1
a2348 2
   bfd_mach_ppc_602, -1, -1, tot_num_registers (registers_602),
   registers_602},
d2350 1
a2350 2
   bfd_mach_ppc_603, -1, -1, tot_num_registers (registers_603),
   registers_603},
d2352 1
a2352 2
   604, -1, -1, tot_num_registers (registers_604),
   registers_604},
d2354 1
a2354 2
   bfd_mach_ppc_403gc, -1, -1, tot_num_registers (registers_403GC),
   registers_403GC},
d2356 1
a2356 2
   bfd_mach_ppc_505, -1, -1, tot_num_registers (registers_505),
   registers_505},
d2358 1
a2358 2
   bfd_mach_ppc_860, -1, -1, tot_num_registers (registers_860),
   registers_860},
d2360 1
a2360 2
   bfd_mach_ppc_750, -1, -1, tot_num_registers (registers_750),
   registers_750},
d2362 1
a2362 5
   bfd_mach_ppc_7400, -1, -1, tot_num_registers (registers_7400),
   registers_7400},
  {"e500", "Motorola PowerPC e500", bfd_arch_powerpc,
   bfd_mach_ppc_e500, -1, -1, tot_num_registers (registers_e500),
   registers_e500},
d2366 1
a2366 2
   bfd_mach_ppc64, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2368 1
a2368 2
   bfd_mach_ppc_620, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2370 1
a2370 2
   bfd_mach_ppc_630, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2372 1
a2372 2
   bfd_mach_ppc_a35, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2374 1
a2374 2
   bfd_mach_ppc_rs64ii, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2376 1
a2376 2
   bfd_mach_ppc_rs64iii, -1, -1, tot_num_registers (registers_powerpc),
   registers_powerpc},
d2378 1
a2378 1
  /* FIXME: I haven't checked the register sets of the following.  */
d2380 1
a2380 2
   bfd_mach_rs6k_rs1, -1, -1, tot_num_registers (registers_power),
   registers_power},
d2382 1
a2382 2
   bfd_mach_rs6k_rsc, -1, -1, tot_num_registers (registers_power),
   registers_power},
d2384 1
a2384 2
   bfd_mach_rs6k_rs2, -1, -1, tot_num_registers (registers_power),
   registers_power},
d2386 1
a2386 1
  {0, 0, 0, 0, 0, 0, 0, 0}
d2389 1
a2389 15
/* Initialize the number of registers and pseudo registers in each variant.  */

static void
init_variants (void)
{
  struct variant *v;

  for (v = variants; v->name; v++)
    {
      if (v->nregs == -1)
        v->nregs = num_registers (v->regs, v->num_tot_regs);
      if (v->npregs == -1)
        v->npregs = num_pseudo_registers (v->regs, v->num_tot_regs);
    }  
}
d2392 1
a2392 1
   MACH.  If no such variant exists, return null.  */
d2420 1
a2420 1
   a binary file.  */
a2434 1
  asection *sect;
d2448 1
a2448 1
     that, else choose a likely default.  */
d2472 1
a2472 1
  /* Find a candidate among extant architectures.  */
d2479 1
a2479 1
         separate word size check.  */
a2507 21

  /* For e500 executables, the apuinfo section is of help here.  Such
     section contains the identifier and revision number of each
     Application-specific Processing Unit that is present on the
     chip.  The content of the section is determined by the assembler
     which looks at each instruction and determines which unit (and
     which version of it) can execute it. In our case we just look for
     the existance of the section.  */

  if (info.abfd)
    {
      sect = bfd_get_section_by_name (info.abfd, ".PPC.EMB.apuinfo");
      if (sect)
	{
	  arch = info.bfd_arch_info->arch;
	  mach = bfd_mach_ppc_e500;
	  bfd_default_set_arch_mach (&abfd, arch, mach);
	  info.bfd_arch_info = bfd_get_arch_info (&abfd);
	}
    }

d2511 1
a2511 4
  /* Initialize the number of real and pseudo registers in each variant.  */
  init_variants ();

  /* Choose variant.  */
a2533 7
  set_gdbarch_pc_regnum (gdbarch, 64);
  set_gdbarch_sp_regnum (gdbarch, 1);
  set_gdbarch_fp_regnum (gdbarch, 1);
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       rs6000_extract_return_value);
  set_gdbarch_deprecated_store_return_value (gdbarch, rs6000_store_return_value);

a2539 2
	tdep->ppc_ev0_regnum = -1;
	tdep->ppc_ev31_regnum = -1;
a2543 22
	tdep->ppc_ev0_regnum = -1;
	tdep->ppc_ev31_regnum = -1;
	break;
      case bfd_mach_ppc_e500:
        tdep->ppc_gp0_regnum = 39;
        tdep->ppc_gplast_regnum = 70;
        tdep->ppc_toc_regnum = -1;
        tdep->ppc_ps_regnum = 1;
        tdep->ppc_cr_regnum = 2;
        tdep->ppc_lr_regnum = 3;
        tdep->ppc_ctr_regnum = 4;
        tdep->ppc_xer_regnum = 5;
	tdep->ppc_ev0_regnum = 7;
	tdep->ppc_ev31_regnum = 38;
        set_gdbarch_pc_regnum (gdbarch, 0);
        set_gdbarch_sp_regnum (gdbarch, 40);
        set_gdbarch_fp_regnum (gdbarch, 40);
        set_gdbarch_dwarf2_reg_to_regnum (gdbarch, e500_dwarf2_reg_to_regnum);
        set_gdbarch_pseudo_register_read (gdbarch, e500_pseudo_register_read);
        set_gdbarch_pseudo_register_write (gdbarch, e500_pseudo_register_write);
        set_gdbarch_extract_return_value (gdbarch, e500_extract_return_value);
        set_gdbarch_deprecated_store_return_value (gdbarch, e500_store_return_value);
a2547 2
	tdep->ppc_ev0_regnum = -1;
	tdep->ppc_ev31_regnum = -1;
d2560 2
a2561 2
  tdep->regoff = xmalloc (v->num_tot_regs * sizeof (int));
  for (i = off = 0; i < v->num_tot_regs; i++)
d2580 3
a2582 1
  set_gdbarch_num_pseudo_regs (gdbarch, v->npregs);
d2592 1
d2626 3
d2642 1
d2725 4
@


1.65.2.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a1034 7
/* All the ABI's require 16 byte alignment.  */
static CORE_ADDR
rs6000_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return (addr & -16);
}

d1366 7
d1514 1
a1514 1
    return deprecated_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
a1529 10
      else if (PC_IN_CALL_DUMMY (get_next_frame (fi)->pc, 0, 0))
	/* The link register wasn't saved by this frame and the next
           (inner, newer) frame is a dummy.  Get the link register
           value by unwinding it from that [dummy] frame.  */
	{
	  ULONGEST lr;
	  frame_unwind_unsigned_register (get_next_frame (fi),
					  tdep->ppc_lr_regnum, &lr);
	  return lr;
	}
d1734 1
a1734 3
    /* A dummy frame always correctly chains back to the previous
       frame.  */
    return read_memory_addr ((thisframe)->frame, wordsize);
d1751 7
d1982 6
a1987 1
   subroutine will return.  */
d1993 1
d2051 1
a2051 1
rs6000_extract_struct_value_address (struct regcache *regcache)
d2053 1
a2053 12
  /* FIXME: cagney/2002-09-26: PR gdb/724: When making an inferior
     function call GDB knows the address of the struct return value
     and hence, should not need to call this function.  Unfortunately,
     the current hand_function_call() code only saves the most recent
     struct address leading to occasional calls.  The code should
     instead maintain a stack of such addresses (in the dummy frame
     object).  */
  /* NOTE: cagney/2002-09-26: Return 0 which indicates that we've
     really got no idea where the return value is being stored.  While
     r3, on function entry, contained the address it will have since
     been reused (scratch) and hence wouldn't be valid */
  return 0;
a2879 1
  set_gdbarch_frame_align (gdbarch, rs6000_frame_align);
d2903 1
a2903 1
  set_gdbarch_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
@


1.65.2.5
log
@merge from mainline
@
text
@a467 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d697 1
a697 1
	  fdata->alloca_reg = (tdep->ppc_gp0_regnum + 31);
d706 1
a706 2
	  fdata->alloca_reg = (tdep->ppc_gp0_regnum
			       + ((op & ~0x38010000) >> 21));
d1992 1
a1992 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  write_register (tdep->ppc_gp0_regnum + 3, addr);
d2014 1
a2014 1
      deprecated_write_register_gen (regnum, reg_val_buf);
d2796 1
a2796 1
	tdep->ppc_vrsave_regnum = 152;
@


1.64
log
@* arch-utils.h (generic_register_size): Declare.
(generic_register_raw_size, generic_register_virtual_size): Delete
declarations.
* arch-utils.c (generic_register_raw_size): Delete.
(generic_register_size): New function.
(generic_register_virtual_size): Delete.

* gdbarch.sh (REGISTER_RAW_SIZE, REGISTER_VIRTUAL_SIZE): Make
default generic_register_size.
* gdbarch.h, gdbarch.c: Re-generate.

* d10v-tdep.c (d10v_gdbarch_init): Use generic_register_size for
register_virtual_size.
* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

* gdbint.texinfo (Target Architecture Definition): Mention
defaults for REGISTER_VIRTUAL_SIZE and REGISTER_RAW_SIZE.
(Target Architecture Definition): Mention same.  Add references to
web pages.
@
text
@d1856 4
a1859 1
	  /* Print as integer in hex and in decimal.  */
a1861 2
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 gdb_stdout, 'x', 1, 0, Val_pretty_default);
a1865 4
	  else
	    /* Print as integer in hex only.  */
	    val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		       gdb_stdout, 'x', 1, 0, Val_pretty_default);
@


1.64.2.1
log
@regbuf
@
text
@a48 2
#include "regbuf.h"		/* For grub_around_regbuf_for_registers.  */

d1146 1
a1146 2
rs6000_extract_return_value (struct type *valtype, struct regbuf *regs,
			     char *valbuf)
a1149 1
  char *regbuf = grub_around_regbuf_for_registers (regs);
d1950 1
a1950 1
rs6000_extract_struct_value_address (struct regbuf *regs)
a1951 1
  /* FIXME: cagney/2002-05-11: This global variable is just a hack!  */
@


1.64.2.2
log
@regbuf->regcache
@
text
@d49 1
a49 1
#include "regcache.h"		/* For grub_around_regcache_for_registers.  */
d1148 1
a1148 1
rs6000_extract_return_value (struct type *valtype, struct regcache *regs,
d1153 1
a1153 1
  char *regbuf = grub_around_regcache_for_registers (regs);
d1954 1
a1954 1
rs6000_extract_struct_value_address (struct regcache *regs)
@


1.64.2.3
log
@* regcache.c (register_buffer): Add regcache parameter.  Update
callers.
(struct regcache_descr): Add nr_raw_registers and
max_register_size.  Add legacy_p.  Change registers to
raw_registers, register_valid_p to raw_register_valid_p.  Update
all callers.
(legacy_regcache_descr): New function handle legacy case.
(regcache_descr): Use legacy function.  For non-legacy case,
restrict the register cache to just NUM_REGS.
(regcache_read, regcache_write): When non-legacy case, implement
regcache read and write directly.
(regcache_write): Use regcache_valid_p.

* regcache.h (deprecated_grub_regcache_for_registers): Rename
grub_around_regcache_for_registers
(deprecated_grub_regcache_for_register_valid): Rename
grub_around_regcache_for_register_valid.
* regcache.c (deprecated_grub_around_regcache_for_registers)
(deprecated_grub_regcache_for_register_valid): Rename.
* rs6000-tdep.c (rs6000_extract_return_value): Update.
* regcache.c (build_regcache): Update.
@
text
@d1153 1
a1153 1
  char *regbuf = deprecated_grub_regcache_for_registers (regs);
@


1.64.2.4
log
@merge from trunk
@
text
@d1860 1
a1860 4
	  /* Print the register in hex.  */
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     gdb_stdout, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also in decimal.  */
d1863 2
d1869 4
d2413 80
d2494 1
d2513 1
a2513 2
  int sysv_abi;
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d2524 1
a2524 2
  if (info.abfd)
    osabi = gdbarch_lookup_osabi (info.abfd);
d2709 1
a2709 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, rs6000_extract_return_value);
d2725 1
a2725 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
d2737 4
d2742 10
a2751 2
    set_gdbarch_use_struct_convention (gdbarch,
    				       ppc_sysv_abi_use_struct_convention);
d2753 4
a2756 2
    set_gdbarch_use_struct_convention (gdbarch,
				       generic_use_struct_convention);
d2759 25
d2785 3
a2787 8
  set_gdbarch_frameless_function_invocation (gdbarch,
                                         rs6000_frameless_function_invocation);
  set_gdbarch_frame_chain (gdbarch, rs6000_frame_chain);
  set_gdbarch_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);

  set_gdbarch_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
  set_gdbarch_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);

a2802 3
  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch, osabi);

a2805 12
static void
rs6000_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (tdep == NULL)
    return;

  fprintf_unfiltered (file, "rs6000_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
}

d2819 2
a2820 2
  gdbarch_register (bfd_arch_rs6000, rs6000_gdbarch_init, rs6000_dump_tdep);
  gdbarch_register (bfd_arch_powerpc, rs6000_gdbarch_init, rs6000_dump_tdep);
d2830 1
@


1.64.2.5
log
@fixes for HEAD->branch merge.
@
text
@d2627 1
a2627 1
  set_gdbarch_extract_return_value (gdbarch, rs6000_extract_return_value);
d2643 1
a2643 1
  set_gdbarch_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
@


1.64.2.6
log
@Merge with trunk.
@
text
@d1582 1
a1582 1
static const char *
d2627 1
a2627 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, rs6000_extract_return_value);
d2643 1
a2643 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
@


1.64.2.7
log
@merge with trunk
@
text
@d49 2
d1148 2
a1149 1
rs6000_extract_return_value (struct type *valtype, char *regbuf, char *valbuf)
d1153 1
d1951 1
a1951 1
rs6000_extract_struct_value_address (char *regbuf)
d1953 1
d2614 1
a2614 1
  set_gdbarch_get_saved_register (gdbarch, generic_unwind_get_saved_register);
@


1.64.2.8
log
@merge with trunk.
@
text
@d2622 1
a2622 1
  set_gdbarch_extract_return_value (gdbarch, rs6000_extract_return_value);
d2638 1
a2638 1
  set_gdbarch_extract_struct_value_address (gdbarch, rs6000_extract_struct_value_address);
@


1.63
log
@	* rs6000-tdep.c: Added comment describing how fpscr register
	numbers were chosen.
@
text
@d2666 1
a2666 1
  set_gdbarch_register_virtual_size (gdbarch, generic_register_virtual_size);
@


1.62
log
@Don't use BFD-private data to determine that an object file is 64-bit xcoff.
@
text
@d2029 15
a2043 1
   processor. */
@


1.61
log
@2002-04-29  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (rs6000_extract_return_value,
	rs6000_store_return_value): Handle returning vectors.
	(rs6000_gdbarch_init): Use
	ppc_sysv_abi_broken_use_struct_convention for native sysv cases.
	* ppc-linux-tdep.c (ppc_sysv_abi_broken_use_struct_convention):
	New function.
	(ppc_sysv_abi_use_struct_convention): Deal with functions returning
	vectors.
	(ppc_sysv_abi_push_arguments): Handle vector parameters.
	* ppc-tdep.h (ppc_sysv_abi_broken_use_struct_convention): Export.
@
text
@d41 2
d2511 1
a2511 1
      if (xcoff_data (info.abfd)->xcoff64)
@


1.60
log
@* rs6000-tdep.c (rs6000_gdbarch_init): Only set
convert_from_func_ptr-addr when AIX / PowerOpen.
@
text
@d1147 1
d1169 7
d1920 2
d1930 7
d2726 1
a2726 1
					   generic_use_struct_convention);
@


1.59
log
@* sparc-tdep.c (sparc_get_saved_register): Use get_prev_frame
instead of ->prev.
* z8k-tdep.c (z8k_frame_chain): Do not use ->prev.
* s390-tdep.c (s390_frame_chain): Do not use ->prev.
* rs6000-tdep.c (frame_get_saved_regs): Use rs6000_frame_chain()
instead of ->prev.
@
text
@d2749 5
a2753 2

      /* Handle RS/6000 function pointers.  */
@


1.58
log
@* gdbarch.sh (BREAKPOINT_FROM_PC): Return a const buffer.
* gdbarch.h, gdbarch.c: Regenerate.

* defs.h (breakpoint_from_pc_fn): Delete type definition.
* target.h (memory_breakpoint_from_pc): Update declaration.
* config/mcore/tm-mcore.h (mcore_breakpoint_from_p): Ditto.

* arch-utils.c (legacy_breakpoint_from_pc): Update return type.
* mcore-tdep.c (mcore_breakpoint_from_pc): Ditto.
* mem-break.c (memory_breakpoint_from_pc): Ditto.
* rs6000-tdep.c (rs6000_breakpoint_from_pc): Ditto.
* s390-tdep.c (s390_breakpoint_from_pc): Ditto
* xstormy16-tdep.c (xstormy16_breakpoint_from_pc): Ditto.
* mn10300-tdep.c (mn10300_breakpoint_from_pc): Ditto.
* mips-tdep.c (mips_breakpoint_from_pc): Ditto.
* m68hc11-tdep.c (m68hc11_breakpoint_from_pc): Ditto.
* ia64-tdep.c (ia64_breakpoint_from_pc): Ditto.
* d10v-tdep.c (d10v_breakpoint_from_pc): Ditto.
* arch-utils.c (legacy_breakpoint_from_pc): Ditto..

* mem-break.c (default_memory_insert_breakpoint): Make `bp' a
const pointer.
* monitor.c (monitor_insert_breakpoint): Ditto.
* rs6000-tdep.c (rs6000_software_single_step): Ditto for `breakp'.

* config/mcore/tm-mcore.h: Update copyright.
* mem-break.c: Ditto.
* xstormy16-tdep.c: Ditto.
@
text
@a1390 2
  else if (fi->prev && fi->prev->frame)
    frame_addr = fi->prev->frame;
d1392 6
a1397 1
    frame_addr = read_memory_addr (fi->frame, wordsize);
@


1.57
log
@2002-04-17  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (COMMON_UISA_NOFP_REGS): New macro.
	(registers_powerpc_nofp): New register set for processors
	without floating point unit.
@
text
@d283 1
a283 1
static unsigned char *
d304 1
a304 1
  char *breakp = rs6000_breakpoint_from_pc (&dummy, &breakp_sz);
@


1.56
log
@* rs6000-tdep.c (frame_initial_stack_address): Use
frame_register_read to read the alloca_reg.
@
text
@d2058 11
d2116 8
@


1.55
log
@Delete DEFAULT_LR_SAVE.
@
text
@d1491 16
a1506 35
  /* This function has an alloca register. If this is the top-most frame
     (with the lowest address), the value in alloca register is good. */

  if (!fi->next)
    return fi->extra_info->initial_sp = read_register (fdata.alloca_reg);

  /* Otherwise, this is a caller frame. Callee has usually already saved
     registers, but there are exceptions (such as when the callee
     has no parameters). Find the address in which caller's alloca
     register is saved. */

  for (callee_fi = fi->next; callee_fi; callee_fi = callee_fi->next)
    {

      if (!callee_fi->saved_regs)
	frame_get_saved_regs (callee_fi, NULL);

      /* this is the address in which alloca register is saved. */

      tmpaddr = callee_fi->saved_regs[fdata.alloca_reg];
      if (tmpaddr)
	{
	  fi->extra_info->initial_sp =
	    read_memory_addr (tmpaddr, TDEP->wordsize);
	  return fi->extra_info->initial_sp;
	}

      /* Go look into deeper levels of the frame chain to see if any one of
         the callees has saved alloca register. */
    }

  /* If alloca register was not saved, by the callee (or any of its callees)
     then the value in the register is still good. */

  fi->extra_info->initial_sp = read_register (fdata.alloca_reg);
@


1.54
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@d1322 2
a1323 1
  int wordsize = TDEP->wordsize;
d1346 1
a1346 1
	return read_memory_addr (FRAME_CHAIN (fi) + DEFAULT_LR_SAVE,
d2589 9
a2597 1
  /* Calculate byte offsets in raw register array. */
@


1.53
log
@	From Jimi X <jimix@@watson.ibm.com>:
	* rs6000-tdep.c (rs6000_gdbarch_init): Use rs6000_* methods for
	64-bit SysV ABI.
@
text
@d1732 1
a1732 1
      if (read_relative_register_raw_bytes (i, raw_buffer))
d1829 1
a1829 1
      if (read_relative_register_raw_bytes (i, raw_buffer))
@


1.52
log
@	From Jimi X <jimix@@watson.ibm.com>:
	* rs6000-tdep.c (rs6000_gdbarch_init): Compute ``wordsize'' from
	bfd info.
@
text
@d2661 8
a2668 1
  if (sysv_abi)
d2709 3
a2711 1
  if (osabi == ELFOSABI_LINUX)
@


1.51
log
@	From Jimi X <jimix@@watson.ibm.com>:
	* rs6000-tdep.c (powerpc64, 630, rs64ii, rs64iii): Define
	register sets for these processor variants.
@
text
@d2502 5
a2506 1
      wordsize = 4;
@


1.50
log
@Add support for the fpscr register for Power / PowerPC targets.
@
text
@d2330 3
a2332 1
  /* FIXME: I haven't checked the register sets of the following. */
d2335 2
d2339 6
@


1.49
log
@	* rs6000-tdep.c (rs6000_gdbarch_init): Don't set tm_print_insn;
	it's no longer required.
@
text
@d2078 1
a2078 1
  /* 66 */ R4(cr),  R(lr), R(ctr), R4(xer), R0
d2112 2
a2113 1
  /* 66 */ R4(cnd), R(lr), R(cnt), R4(xer), R4(mq)
d2551 2
d2554 2
a2555 1
    tdep->ppc_mq_regnum = 70;
@


1.48
log
@	* rs6000-tdep.c (rs6000_software_single_step): Use
	rs6000_breakpoint_from_pc() to fetch breakpoint instruction
	and size.  Use target_insert_breakpoint() and
	target_remove_breakpoint() to insert and remove breakpoints
	instead of explicit memory reads and writes.
@
text
@d2461 1
d2578 8
a2585 7
  /* Select instruction printer.  Note: tm_print_insn is still used by
     gdbtk (insight), so we set both tm_print_insn and the gdbarch
     method.  */
  tm_print_insn = arch == power ? print_insn_rs6000 :
    info.byte_order == BFD_ENDIAN_BIG ? print_insn_big_powerpc :
      print_insn_little_powerpc;
  set_gdbarch_print_insn (gdbarch, tm_print_insn);
@


1.47
log
@	* config/powerpc/tm-ppc-eabi.h (ELF_OBJECT_FORMAT): Delete.
	* rs6000-tdep.c (rs6000_push_arguments): Eliminate
	ELF_OBJECT_FORMAT ifdef.
@
text
@d302 3
a304 5
#define	INSNLEN(OPCODE)	 4

  static char le_breakp[] = LITTLE_BREAKPOINT;
  static char be_breakp[] = BIG_BREAKPOINT;
  char *breakp = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? be_breakp : le_breakp;
d317 1
a317 1
      breaks[0] = loc + INSNLEN (insn);
d333 1
a333 4

	  read_memory (breaks[ii], stepBreaks[ii].data, 4);

	  write_memory (breaks[ii], breakp, 4);
d344 2
a345 3
	  write_memory
	    (stepBreaks[ii].address, stepBreaks[ii].data, 4);

@


1.46
log
@	From Jimi X <jimix@@watson.ibm.com>:
	* rs6000-tdep.c (rs6000_gdbarch_init): Use set_gdbarch_print_insn().
@
text
@d1042 1
a1042 1
#ifndef ELF_OBJECT_FORMAT
a1050 1
#endif
@


1.45
log
@	From Jimi X <jimix@@watson.ibm.com>:
	* rs6000-tdep.c (rs6000_fix_call_dummy): Delete unused macro
	definitions for TOC_ADDR_OFFSET and TARGET_ADDR_OFFSET.
@
text
@a2538 5
  /* Select instruction printer. */
  tm_print_insn = arch == power ? print_insn_rs6000 :
    info.byte_order == BFD_ENDIAN_BIG ? print_insn_big_powerpc :
      print_insn_little_powerpc;

d2583 8
@


1.44
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@a911 3
#define	TOC_ADDR_OFFSET		20
#define	TARGET_ADDR_OFFSET	28

@


1.43
log
@	* rs6000-tdep.c (skip_prologue): Eliminate unused/unreachable
	clause.
@
text
@a2594 1
  set_gdbarch_write_fp (gdbarch, generic_target_write_fp);
@


1.42
log
@2002-04-01  Daniel Jacobowitz  <drow@@mvista.com>

        * rs6000-tdep.c: Change #include of "bfd/libcoff.h"
        and "bfd/libbfd.h" to "libcoff.h" and "libbfd.h".
@
text
@a594 9
      else if (((op & 0xffff0000) == 0x801e0000 ||   /* lwz 0,NUM(r30), used
						        in V.4 -mrelocatable */
		op == 0x7fc0f214) &&	/* add r30,r0,r30, used
					   in V.4 -mrelocatable */
	       lr_reg == 0x901e0000)
	{
	  continue;

	}
@


1.41
log
@2002-03-27  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (struct rs6000_framedata): Add fields for AltiVec
	vector registers handling.
	(skip_prologue): Handle new AltiVec instructions.  Fill in new
	fields of frame data.
	(frame_get_saved_regs): Fill in information for AltiVec registers.
@
text
@d38 1
a38 1
#include "bfd/libbfd.h"		/* for bfd_default_set_arch_mach */
d40 1
a40 1
#include "bfd/libcoff.h"	/* for xcoff_data */
@


1.40
log
@2002-03-22  Elena Zannoni  <ezannoni@@redhat.com>

        * ppc-linux-tdep.c (ppc_sysv_abi_use_struct_convention): New
        function.
	* ppc-tdep.h (ppc_sysv_abi_use_struct_convention): Export.
        * rs6000-tdep.c (rs6000_gdbarch_init): Use different
        structure returning convention for SYSV ABI case, but not
        for GNU/Linux, FreeBSD, or NetBSD.
@
text
@d67 1
d73 1
d76 1
d368 1
d373 1
d376 1
d443 1
d447 1
d450 2
d476 1
d595 2
a596 2
      else if (((op & 0xffff0000) == 0x801e0000 ||	/* lwz 0,NUM(r30), used
							   in V.4 -mrelocatable */
d604 2
a605 2
      else if ((op & 0xffff0000) == 0x3fc00000 ||	/* addis 30,0,foo@@ha, used
							   in V.4 -mminimal-toc */
d616 2
a617 2
	  /* Don't skip over the subroutine call if it is not within the first
	     three instructions of the prologue.  */
d623 4
a626 4
	  /* At this point, make sure this is not a trampoline function
	     (a function that simply calls another functions, and nothing else).
	     If the next is not a nop, this branch was part of the function
	     prologue. */
d672 1
a672 2
      else if ((op & 0xfc1f0000) == 0x90010000 ||	/* st rx,NUM(r1) */
	       (op & 0xfc1f0003) == 0xf8010000 ||	/* std rx,NUM(r1) */
a704 1

d706 67
d1383 2
a1384 1
  int wordsize = TDEP->wordsize;
d1402 6
a1407 2
  if (fdatap->saved_fpr == 0 && fdatap->saved_gpr == 0
      && fdatap->lr_offset == 0 && fdatap->cr_offset == 0)
d1442 16
d1461 1
a1461 2
    fi->saved_regs[gdbarch_tdep (current_gdbarch)->ppc_cr_regnum] =
      frame_addr + fdatap->cr_offset;
d1466 6
a1471 2
    fi->saved_regs[gdbarch_tdep (current_gdbarch)->ppc_lr_regnum] =
      frame_addr + fdatap->lr_offset;
@


1.39
log
@2002-03-21  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): Use correct max size value
	for gdbarch_max_register_raw_size and max_register_virtual_size.
	Adjust copyright year.
@
text
@a2565 2
  set_gdbarch_use_struct_convention (gdbarch, generic_use_struct_convention);

d2576 21
@


1.38
log
@2002-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): Don't call
	find_variant_by_name, because it confuses the multiarch
	framework. Return NULL if there isn't an architecture with the
	user supplied name, instead of forcing a different one without
	recording the change with the multiarch machinery.
	(find_variant_by_name): Delete.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001
d2517 1
a2517 1
  set_gdbarch_max_register_raw_size (gdbarch, 8);
d2519 1
a2519 1
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
@


1.38.2.1
log
@2002-04-01  Daniel Jacobowitz  <drow@@mvista.com>

        * rs6000-tdep.c: Change #include of "bfd/libcoff.h"
        and "bfd/libbfd.h" to "libcoff.h" and "libbfd.h".
@
text
@d38 1
a38 1
#include "libbfd.h"		/* for bfd_default_set_arch_mach */
d40 1
a40 1
#include "libcoff.h"		/* for xcoff_data */
@


1.37
log
@* config/vax/tm-vax.h (INVALID_FLOAT): Move macro from here...
* vax-tdep.c (INVALID_FLOAT): To here.  Document why it is broken.

* rs6000-tdep.c (rs6000_do_registers_info): Delete code wrapped in
#ifdef INVALID_FLOAT.
* infcmd.c (do_registers_info): Ditto.
* values.c (unpack_double): Ditto.  Add comment.

* config/ns32k/tm-umax.h (INVALID_FLOAT): Delete macro that was
already commented out.
@
text
@a2264 15
/* Look up the variant named NAME in the `variants' table.  Return a
   pointer to the struct variant, or null if we couldn't find it.  */

static const struct variant *
find_variant_by_name (char *name)
{
  const struct variant *v;

  for (v = variants; v->name; v++)
    if (!strcmp (name, v->name))
      return v;

  return NULL;
}

d2459 2
a2460 1
    v = find_variant_by_name (power ? "power" : "powerpc");
@


1.36
log
@2002-01-15  Elena Zannoni  <ezannoni@@redhat.com>

	[Based on work by Jim Blandy]

	* gdbtypes.h (builtin_type_v16qi, builtin_type_v8hi): Export.
	(builtin_type_vec128): Export.

	* gdbtypes.c (builtin_type_v16qi, builtin_type_v8hi): New SIMD
	types.
	(builtin_type_vec128): New builtin type for 128 bit vector
	registers.
	(build_gdbtypes): Initialize builtin_type_v16qi and
	builtin_type_v8hi. Create the vec128 register builtin type
	structure.
	(build_builtin_type_vec128): New function.
 	(_initialize_gdbtypes): Register builtin_type_v16qi and
	builtin_type_v8hi with gdbarch. Same for builtin_type_vec128.

	* rs6000-tdep.c (rs6000_register_virtual_type): Change type of
	AltiVec register to new builtin type.
@
text
@d1766 2
a1767 7
#ifdef INVALID_FLOAT
          if (INVALID_FLOAT (virtual_buffer, REGISTER_VIRTUAL_SIZE (i)))
            printf_filtered ("<invalid float>");
          else
#endif
            val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
                       gdb_stdout, 0, 1, 0, Val_pretty_default);
@


1.35
log
@last? remaining BIG_ENDIAN switch
@
text
@d1553 1
a1553 1
	  return builtin_type_int128;
@


1.34
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d1777 1
a1777 1
              register int idx = TARGET_BYTE_ORDER == BIG_ENDIAN ? j
@


1.33
log
@2001-12-29  Elena Zannoni  <ezannoni@@redhat.com>

	* Makefile.in (rs6000-tdep.o): Add dependency on parser-defs.h.

	* rs6000-tdep.c: Include parser-defs.h.
	(rs6000_register_virtual_type): Rewrite, including handling of
	AltiVec regs type.
	(altivec_register_p): New function.
	(rs6000_do_altivec_registers): New function.
	(rs6000_altivec_registers_info): New function.
	(rs6000_do_registers_info): New function.
	(R16): Define.
	(PPC_ALTIVEC_REGS): Define.
	(registers_powerpc): Add AltiVec registers.
	(registers_7400): Define.
	(variants): Add 7400 machine.
	(rs6000_gdbarch_init): Set the numbers of AltiVec registers.
	Initialize gdbarch_do)_registers_info.
	(rs6000_info_power_command): New function.
	(info_power_cmdlist): New static variable.
	(_initialize_rs6000_tdep): Add new 'info powerpc altivec' command.

	* ppc-tdep.h (struct gdbarch_tdep): Add altivec regnum fields.
	(altivec_register_p): Export.
@
text
@d286 1
a286 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d303 1
a303 1
  char *breakp = TARGET_BYTE_ORDER == BIG_ENDIAN ? be_breakp : le_breakp;
d967 1
a967 1
	  int adj = TARGET_BYTE_ORDER == BIG_ENDIAN ? reg_size - len : 0;
d1114 1
a1114 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN
d2473 1
a2473 1
    info.byte_order == BIG_ENDIAN ? print_insn_big_powerpc :
@


1.32
log
@* gdbarch.sh (TARGET_CHAR_SIGNED): New macro.
* gdbarch.c, gdbarch.h: Regenerated.
* gdbtypes.c (build_gdbtypes): If TARGET_CHAR_SIGNED is zero,
set the TYPE_FLAG_UNSIGNED bit on the type.
* s390-tdep.c (s390_gdbarch_init): On the S/390, characters
are unsigned by default.
* rs6000-tdep.c (rs6000_gdbarch_init): Same for PowerPC and
RS6000.
@
text
@d36 1
d1542 18
a1559 3
  return reg->fpr ? builtin_type_double :
    regsize (reg, tdep->wordsize) == 8 ? builtin_type_int64 :
      builtin_type_int32;
d1618 185
d1969 4
d2023 8
d2044 2
a2045 1
  PPC_UISA_SPRS
d2176 15
d2250 2
d2495 17
d2540 1
d2641 8
d2656 10
@


1.31
log
@2001-12-11  Michael Snyder  <msnyder@@redhat.com>

	* d10v-tdep.c (d10v_register_virtual_size): Delete.
	(d10v_gdbarch_init): Use generic_register_virtual_size.
	* rs6000-tdep.c (rs6000_register_virtual_size): Delete.
	(rs6000_gdbarch_init): Use generic_register_virtual_size.
	* x86-64-tdep.c (x86_64_register_virtual_size): Delete.
	(i386_gdbarch_init): Use generic_register_virtual_size.
@
text
@d2301 1
@


1.30
log
@2001-12-09  Elena Zannoni  <ezannoni@@redhat.com>

	* config/rs6000/tm-rs6000.h (STAB_REG_TO_REGNUM): Remove
	definition, it is now multiarched.
	* ppc-tdep.h (struct gdbarch_tdep): Move from rs6000-tdep.c.  Add
	fields for special register numbers.
	* rs6000-tdep.c (rs6000_gdbarch_init): Initialize new tdep special
	regnum fields.
	(rs6000_saved_pc_after_call): Use gdbarch_tdep registers fields
	instead of hardcoded macros.
	(branch_dest, rs6000_pop_frame, rs6000_fix_call_dummy,
	ppc_push_return_address, rs6000_frame_saved_pc,
	frame_get_saved_regs, rs6000_frame_chain,
	rs6000_store_return_value): Ditto.
	(rs6000_stab_reg_to_regnum): New function.
	* ppcnbsd-nat.c (fetch_inferior_registers,
	store_inferior_registers, fetch_core_registers): Ditto.
	* ppc-linux-tdep.c (ppc_linux_in_sigtramp,
	ppc_linux_frame_init_saved_regs): Ditto.
	* ppc-linux-nat.c (ppc_register_u_addr, supply_gregset,
	fill_gregset): Ditto.
	* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_store_registers):
	Ditto.
@
text
@a1531 9
/* Number of bytes of storage in the program's representation
   for register N.  */

static int
rs6000_register_virtual_size (int n)
{
  return TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (n));
}

d2289 1
a2289 1
  set_gdbarch_register_virtual_size (gdbarch, rs6000_register_virtual_size);
@


1.29
log
@Add cross platform SVR4 shared library support for PowerPC.
@
text
@a84 10
/* Private data that this module attaches to struct gdbarch. */

struct gdbarch_tdep
  {
    int wordsize;		/* size in bytes of fixed-point word */
    int osabi;			/* OS / ABI from ELF header */
    int *regoff;		/* byte offsets in register arrays */
    const struct reg *regs;	/* from current variant */
  };

d198 1
a198 1
  return read_register (PPC_LR_REGNUM);
d236 1
a236 1
	  dest = read_register (PPC_LR_REGNUM) & ~3;
d255 1
a255 1
	  dest = read_register (PPC_CTR_REGNUM) & ~3;
d261 1
a261 1
	    dest = read_register (PPC_LR_REGNUM) & ~3;
d802 1
a802 1
    lr = read_register (PPC_LR_REGNUM);
d853 2
a854 1
      write_register (PPC_TOC_REGNUM, tocvalue);
d1077 2
a1078 1
  write_register (PPC_LR_REGNUM, CALL_DUMMY_ADDRESS ());
d1292 1
a1292 1
    return read_register (PPC_LR_REGNUM);
d1363 2
a1364 1
    fi->saved_regs[PPC_CR_REGNUM] = frame_addr + fdatap->cr_offset;
d1369 2
a1370 1
    fi->saved_regs[PPC_LR_REGNUM] = frame_addr + fdatap->lr_offset;
d1480 1
a1480 1
  lr = read_register (PPC_LR_REGNUM);
d1611 27
d1669 2
a1670 2
    write_register_bytes (REGISTER_BYTE (PPC_GP0_REGNUM + 3), valbuf,
			  TYPE_LENGTH (type));
d2260 13
d2332 1
@


1.28
log
@Add explicit #include of "value.h".
@
text
@d43 1
d2337 2
@


1.27
log
@* rs6000-tdep.c (rs6000_gdbarch_init): Don't use the previous
architecture to infer the wordsize.  Previous architecture may not
be a PowerPC.
@
text
@d35 1
@


1.26
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@d2166 2
a2167 2
  /* Check word size.  If INFO is from a binary file, infer it from that,
     else use the previously-inferred size. */
d2184 1
a2184 5
      tdep = TDEP;
      if (tdep)
	wordsize = tdep->wordsize;
      else
	wordsize = 4;
@


1.25
log
@s/value_ptr/struct value */
@
text
@d34 1
@


1.24
log
@* symtab.c (main_name): New function.
(set_main_name): New function.
* symtab.h: Declare.
* TODO: Update

From 2000-03-05 Anthony Green <green@@redhat.com>:
* dbxread.c (process_one_symbol): Handle the N_MAIN stab by
setting main_name.
* blockframe.c (inside_main_func): Use main_name instead of
"main".
* symtab.c (find_main_psymtab): Ditto.
* source.c (select_source_symtab): Ditto.
* nlmread.c (nlm_symfile_read): Ditto.
* rs6000-tdep.c (skip_prologue): Ditto.
@
text
@d848 1
a848 1
		       int nargs, value_ptr *args, struct type *type,
d881 1
a881 1
rs6000_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d892 1
a892 1
  value_ptr arg = 0;
d1011 1
a1011 1
	  value_ptr val = args[jj];
@


1.23
log
@Fix logic selecting a new architecture.  Use the sequence:
	o	provided by INFO
	o	hard-wired by (gdb) set ...
	o	reversed engineered from INFO.abfd
	o	default to previous architecture
@
text
@d756 1
a756 1
	  if (tmp >= 0 && STREQ (misc_function_vector[tmp].name, "main"))
@


1.22
log
@	* config/rs6000/tm-rs6000.h (IN_SOLIB_RETURN_TRAMPOLINE): Define.
	(rs6000_in_solib_return_trampoline): Declare.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): New
	function.
	(rs6000_skip_trampoline_code): Skip bigtoc fixup code.
	* xcoffread.c (read_xcoff_symtab): Perform the ISFCN function
	check after the CSECT check rather than before it.  Allocate
	separate symtabs for CSECTs whose names begin with '@@'.
	(scan_xcoff_symtab): Don't ignore symbols beginning with '@@'.
	Activate the misc_func_recorded mechanism for whose names begin
	with '@@'.
@
text
@d2213 1
a2213 1
      arch = info.bfd_architecture;
@


1.21
log
@* target.h (enum target_signal): Move definition from here.
* defs.h (enum target_signal): To here.

* config/arc/tm-arc.h (arc_software_single_step): Change type of
first parameter to enum target_signal.
* config/rs6000/tm-rs6000.h (rs6000_software_single_step): Ditto.
* config/sparc/tm-sparc.h (sparc_software_single_step): Ditto.
* rs6000-tdep.c (rs6000_software_single_step): Update.
@
text
@d1135 35
a1169 4
/* Indirect function calls use a piece of trampoline code to do context
   switching, i.e. to set the new TOC table. Skip such code if we are on
   its first instruction (as when we have single-stepped to here). 
   Also skip shared library trampoline code (which is different from
d1171 3
d1175 1
a1175 1
   trampoline code.  */
d1181 1
d1183 1
d1196 15
@


1.20
log
@Update/correct copyright notices.
@
text
@d302 2
a303 1
rs6000_software_single_step (unsigned int signal, int insert_breakpoints_p)
@


1.19
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 2000, 2001
@


1.18
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d33 1
@


1.17
log
@Handle optimizer code motions into the prologue.
@
text
@d2 2
a3 1
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000
d2043 3
a2045 2
	      internal_error (
		"process_note_abi_sections: unknown OS number %d", os_number);
@


1.16
log
@	Add auto-solib-add support for AIX, remove obsolete and unused
	SOLIB_SYMBOLS_MANUAL code, cleanup of AIX shared library handling code.
	* rs6000-nat.c (vmap_symtab):  Do not try to modify offsets
	if symbols are not yet loaded.
	(vmap_add_symbols):  New function to add symbols for a vmap entry.
	(add_vmap):  Turn errors into warnings, return NULL vmap upon
	failure. Add symbols via vmap_add_symbols only if requested.
	(xcoff_relocate_core):  Allow debugging of core files without an
	executable file. Handle NULL returns from add_vmap gracefully.
	* xcoffsolib.c (solib_add):  Remove, no longer needed.
	(solib_info):  Do not check for new shared libraries if there is no
	inferior process.
	(sharedlibrary_command):  Made static.
	Do not check for new shared libraries if there is no inferior process.
	Add symbols for requested shared libraries via vmap_add_symbols.
	(_initialize_solib):  Add `set auto-solib-add' command.
	* xcoffsolib.h (vmap_add_symbols):  Add prototype declaration.

	* config/rs6000/tm-rs6000.h (PC_LOAD_SEGMENT):  Move from here ...
	* config/rs6000/nm-rs6000.h:  ... to here, this is an AIX native
	feature.
	* config/powerpc/tm-macos.h, config/powerpc/tm-ppc-eabi.h,
	config/powerpc/tm-ppc-nw.h, config/rs6000/tm-rs6000ly.h:
	Remove #undef PC_LOAD_SEGMENT.
	* config/powerpc/aix.mt, config/rs6000/aix4.mt, config/rs6000/rs6000.mt
	(TDEPFILES):  Move xcoffsolib.o from here ...
	* config/powerpc/aix.mh, config/rs6000/aix4.mh, config/rs6000/rs6000.mh
	(NATDEPFILES):  ... to here, xcoffsolib.o contains AIX native code
	only.
	* rs6000-tdep.c:  Remove #include xcoffsolib.h, no longer needed.
	* xcoffsolib.h (xcoff_relocate_symtab_hook):  Remove declaration.
	* rs6000-nat.c (_initialize_core_rs6000):  Remove setting of
	xcoff_relocate_symtab_hook, no longer needed.
	* xcoffsolib.c (solib_info, sharedlibrary_command):  Remove
	xcoff_relocate_symtab_hook indirection, call xcoff_relocate_symtab
	directly, as xcoffsolib.c is now compiled in native AIX configurations
	only.
	* Makefile.in:  Update dependencies for rs6000-tdep.o, rs6000-nat.o
	and xcoffsolib.o.
@
text
@d383 52
d439 1
a439 1
  CORE_ADDR last_prologue_pc;
d449 16
d473 1
a473 2
  pc -= 4;
  while (lim_pc == 0 || pc < lim_pc - 4)
a474 2
      pc += 4;

d481 5
d488 1
d702 25
a726 1
	  break;
@


1.15
log
@	* arch-utils.c, arch-utils.h (default_convert_from_func_ptr_addr):
	New function.
	* gdbarch.sh (CONVERT_FROM_FUNC_PTR_ADDR):  Add.
	* gdbarch.c, gdbarch.h:  Regenerate.
	* valops.c (find_function_addr):  Use CONVERT_FROM_FUNC_PTR_ADDR
	unconditionally.

	* config/rs6000/tm-rs6000.h (CONVERT_FROM_FUNC_PTR_ADDR):  Delete
	definition.
	* config/powerpc/tm-linux.h (CONVERT_FROM_FUNC_PTR_ADDR):  Remove
	undef.
	* rs6000-tdep.c (rs6000_convert_from_func_ptr_addr):  Fix comment.
	(rs6000_gdbarch_init):  Register rs6000_convert_from_func_ptr_addr
	if not ELFOSABI_LINUX.
@
text
@a30 1
#include "xcoffsolib.h"
@


1.14
log
@Add a limit parameter for scanning the prologue.
@
text
@d1544 1
a1544 1
   function pointers), find_function_addr uses this macro to get the
d1547 2
a1548 2
/* Return nonzero if ADDR (a function pointer) is in the data space and
   is therefore a special function pointer.  */
d2199 4
@


1.13
log
@	* rs6000-tdep.c (rs6000_pop_frame):  Use PC_IN_CALL_DUMMY to test
	for call dummy instead of accessing stop_stack_dummy, which does
	not work if we `return' from a stop in a call dummy.
	(rs6000_gdbarch_init):  Use generic_save_dummy_frame_tos for
	dummy_frame_tos function to make PC_IN_CALL_DUMMY work.
@
text
@d121 2
a122 1
static CORE_ADDR skip_prologue (CORE_ADDR, struct rs6000_framedata *);
d139 1
a139 1
  pc = skip_prologue (pc, &frame);
d385 1
a385 1
skip_prologue (CORE_ADDR pc, struct rs6000_framedata *fdata)
d407 1
a407 1
  for (;;)
d704 1
a704 1
  (void) skip_prologue (addr, &fdata);
d1110 1
a1110 1
  (void) skip_prologue (func_start, &fdata);
d1136 1
a1136 1
  (void) skip_prologue (func_start, &fdata);
d1171 1
a1171 1
      (void) skip_prologue (get_pc_function_start (fi->pc), fdatap);
d1247 1
a1247 1
  (void) skip_prologue (get_pc_function_start (fi->pc), &fdata);
@


1.12
log
@Make GNU/Linux/PPC work again.
@
text
@a673 2
extern int stop_stack_dummy;

d688 1
a688 1
  if (stop_stack_dummy)
d2141 1
@


1.11
log
@Protoization.
@
text
@d38 1
a38 2
/* Some important register numbers.  Keep these in the same order as in
   /usr/mstsave.h `mstsave' structure, for easier processing. */
d40 1
a40 6
#define	GP0_REGNUM 0		/* GPR register 0 */
#define	TOC_REGNUM 2		/* TOC register */
#define PS_REGNUM 65		/* Processor (or machine) status (%msr) */
#define	CR_REGNUM 66		/* Condition register */
#define	LR_REGNUM 67		/* Link register */
#define	CTR_REGNUM 68		/* Count register */
d86 1
d155 1
a155 1
static void
d180 1
a180 1
static void
d203 1
a203 1
  return read_register (LR_REGNUM);
d241 1
a241 1
	  dest = read_register (LR_REGNUM) & ~3;
d260 1
a260 1
	  dest = read_register (CTR_REGNUM) & ~3;
d266 1
a266 1
	    dest = read_register (LR_REGNUM) & ~3;
d713 1
a713 1
    lr = read_register (LR_REGNUM);
d764 1
a764 1
      write_register (TOC_REGNUM, tocvalue);
d987 1
a987 1
  write_register (LR_REGNUM, CALL_DUMMY_ADDRESS ());
d1083 1
a1083 1
static int
d1117 1
a1117 1
static CORE_ADDR
d1150 1
a1150 1
    return read_register (LR_REGNUM);
d1221 1
a1221 1
    fi->saved_regs[CR_REGNUM] = frame_addr + fdatap->cr_offset;
d1226 1
a1226 1
    fi->saved_regs[LR_REGNUM] = frame_addr + fdatap->lr_offset;
d1311 1
a1311 1
static CORE_ADDR
d1336 1
a1336 1
  lr = read_register (LR_REGNUM);
d1498 1
a1498 1
    write_register_bytes (REGISTER_BYTE (GP0_REGNUM + 3), valbuf,
d1907 78
d1999 1
a1999 1
  int wordsize, fromexec, power, i, off;
d2005 1
d2007 1
a2007 1
  fromexec = info.abfd && info.abfd->format == bfd_object &&
d2010 7
d2019 1
a2019 1
  if (fromexec)
d2026 7
d2051 1
a2051 1
      if (tdep && tdep->wordsize == wordsize)
d2063 1
a2063 1
  if (!fromexec)
d2077 1
d2152 5
a2156 1
  set_gdbarch_push_arguments (gdbarch, rs6000_push_arguments);
a2162 3
  set_gdbarch_frame_init_saved_regs (gdbarch, rs6000_frame_init_saved_regs);
  set_gdbarch_init_extra_frame_info (gdbarch, rs6000_init_extra_frame_info);

a2173 2
  set_gdbarch_frameless_function_invocation (gdbarch, rs6000_frameless_function_invocation);
  set_gdbarch_frame_chain (gdbarch, rs6000_frame_chain);
d2175 25
a2199 1
  set_gdbarch_frame_saved_pc (gdbarch, rs6000_frame_saved_pc);
@


1.10
log
@	* ppcbug-rom.c (ppcbug_regnames[]): Make array size implicit.
	* rs6000-tdep.c (DEFAULT_LR_SAVE): Move to config/*/tm-*.h.
	(rs6000_gdbarch_init): Use generic_pc_in_call_dummy instead of
	rs6000_pc_in_call_dummy.
	* config/rs6000/tm-rs6000.h (DEFAULT_LR_SAVE): Move here from
	rs6000-tdep.c.
	* config/powerpc/tm-ppc-eabi.h: Remove various definitions
	handled by multi-arched rs6000-tdep.c.
@
text
@d1406 1
a1406 1
rs6000_register_virtual_type (n)
d2102 1
a2102 1
_initialize_rs6000_tdep ()
@


1.9
log
@	* xcoffread.c (read_symbol_nvalue): Return CORE_ADDR.
	* rs6000-tdep.c (rs6000_pop_frame): Make addr CORE_ADDR type.
@
text
@a58 3
/* Default offset from SP where the LR is stored */
#define	DEFAULT_LR_SAVE 8

d2048 1
a2048 1
  set_gdbarch_pc_in_call_dummy (gdbarch, rs6000_pc_in_call_dummy);
@


1.8
log
@	* rs6000-tdep.c: Changes throughout for multi-arch 64-bit
	support.  Incorporate most of tm-rs6000.h.
	(find_toc_address_hook): Rename to rs6000_find_toc_address_hook.
	(rs6000_set_host_arch_hook): Declare.
	(read_memory_addr): Define.
	(pop_frame): Rename to rs6000_pop_frame.
	(rs6000_pop_frame, rs6000_fix_call_dummy, rs6000_push_arguments,
	rs6000_frame_saved_pc, rs6000_frame_chain): Remove non-generic
	dummy frame handling.
	(branch_dest, rs6000_pop_frame, rs6000_skip_trampoline_code,
	rs6000_frame_saved_pc, frame_get_saved_regs,
	frame_initial_stack_address, rs6000_frame_chain,
	rs6000_convert_from_func_ptr_addr): Call read_memory_addr instead
	of read_memory_integer.
	(branch_dest, rs6000_pop_frame, rs6000_push_arguments,
	rs6000_skip_trampoline_code, rs6000_frame_saved_pc,
	frame_get_saved_regs, frame_initial_stack_address,
	rs6000_frame_chain): Replace 4 with TDEP->wordsize.
	(skip_prologue): Recognize some 64-bit stack adjustments.
	(push_dummy_frame, pop_dummy_frame, set_processor,
	show_processor): Delete.
	(frame_get_saved_regs): Manipulate saved register addresses using
	CORE_ADDR instead of int.
	(rs6000_create_inferior): New function.
	(register_names_*[]): Change to struct reg registers_*[].
	(variants[]): Assimilate into multi-arch approach.
	(register_names_*[], variants[]): Refer to pre-PowerPC
	architectures as POWER instead of RS6000.
	* rs6000-nat.c: Ubiquitous changes for 64-bit support.
	(vmap_secs, xcoff_relocate_symtab): Cast addresses
	to unsigned long to avoid sign-extension errors.
	(set_host_arch): New function.
	(xcoff_relocate_symtab): Try disabling usleep(36000) workaround.
	(rs6000_core_fns): Use new bfd_target_xcoff_flavour.
	(_initialize_core_rs6000): Initialize rs6000_set_host_arch_hook.
	* symfile.c (find_sym_fns): Remove special xcoff kludge.
	* xcoffread.c (secnum_to_bfd_section): Initialize args.objfile.
	(process_linenos): Query line struct size from coff
	backend instead of using compile-time constant.
	(enter_line_range): Likewise.
	(read_xcoff_symtab): Pass "XCOFF64" instead of "XCOFF" to
	record_debugformat() if appropriate.
	(process_xcoff_symbol): Access symbol addresses using
	SYMBOL_VALUE_ADDRESS instead of SYMBOL_VALUE.
	(read_symbol_lineno): Retrieve XCOFF64 symbol names from strtbl.
	(scan_xcoff_symtab): Likewise.  Query syment struct size from
	coff backend instead of using compile-time constant.
	(xcoff_sym_fns): Set flavour to bfd_target_xcoff_flavour.
	* Makefile.in (INTERNAL_LDFLAGS): Add $(MH_LDFLAGS) to list of flags
	that this Makefile variable get set to.  (From Kevin Buettner.)
	* config/powerpc/aix.mh (MH_LDFLAGS): Add linker flags so that
	the TOC doesn't overflow.  (From Kevin Buettner.)
	* config/powerpc/tm-ppc-aix.h: Move config decisions to
	multi-arched rs6000-tdep.c.
	* config/rs6000/tm-rs6000.h: Likewise.
	(GDB_MULTI_ARCH): Define.
	(skip_trampoline_code): Rename to rs6000_skip_trampoline_code.
	(is_magic_function_pointer): Replace with
	rs6000_convert_from_func_ptr_addr.
	(TARGET_CREATE_INFERIOR_HOOK): Define.
	(find_toc_address_hook): Rename to rs6000_find_toc_address_hook.
	(rs6000_set_host_arch_hook): Declare.
	* config/rs6000/nm-rs6000.h (CHILD_XFER_MEMORY): Define.
@
text
@d690 1
a690 1
  CORE_ADDR pc, lr, sp, prev_sp;	/* %pc, %lr, %sp */
d693 1
a693 1
  int addr, ii, wordsize;
@


1.7
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d32 1
d34 68
a101 1
extern int errno;
d118 6
a123 1
CORE_ADDR (*find_toc_address_hook) (CORE_ADDR) = NULL;
d129 4
d134 1
a134 2
static void frame_get_saved_regs (struct frame_info *fi,
				  struct rs6000_framedata *fdatap);
d136 5
a140 1
static void pop_dummy_frame (void);
d142 2
a143 5
static CORE_ADDR frame_initial_stack_address (struct frame_info *);

CORE_ADDR
rs6000_skip_prologue (pc)
     CORE_ADDR pc;
d163 2
a164 4
void
rs6000_init_extra_frame_info (fromleaf, fi)
     int fromleaf;
     struct frame_info *fi;
d178 9
d188 2
a189 3
void
rs6000_frame_init_saved_regs (fi)
     struct frame_info *fi;
d194 2
a195 3
CORE_ADDR
rs6000_frame_args_address (fi)
     struct frame_info *fi;
d203 10
d217 1
a217 5
branch_dest (opcode, instr, pc, safety)
     int opcode;
     int instr;
     CORE_ADDR pc;
     CORE_ADDR safety;
d261 2
a262 2
		dest = read_memory_integer (fi->frame + SIG_FRAME_PC_OFFSET,
					    4);
d292 2
a293 4
unsigned char *
rs6000_breakpoint_from_pc (bp_addr, bp_size)
     CORE_ADDR *bp_addr;
     int *bp_size;
d308 1
a308 3
rs6000_software_single_step (signal, insert_breakpoints_p)
     unsigned int signal;
     int insert_breakpoints_p;
d391 1
a391 1
CORE_ADDR
d454 3
a456 3
	       ((op & 0xfc1f0000) == 0x90010000 &&	/* st rx,NUM(r1), 
							   rx >= r13 */
		(op & 0x03e00000) >= 0x01a00000))
d463 2
d564 3
a566 2
      else if ((op & 0xffff0000) == 0x94210000)
	{			/* stu r1,NUM(r1) */
d568 2
d602 1
d604 2
a605 2
	       (op & 0xfc1f0000) == 0xfc010000)
	{			/* frsp, fp?,NUM(r1) */
a681 22
/* The total size of dummy frame is 436, which is;

   32 gpr's           - 128 bytes
   32 fpr's           - 256 bytes
   7  the rest        -  28 bytes
   callee's link area -  24 bytes
   padding            -  12 bytes

   Note that the last 24 bytes for the link area might not be necessary,
   since it will be taken care of by push_arguments(). */

#define DUMMY_FRAME_SIZE 448

#define	DUMMY_FRAME_ADDR_SIZE 10

/* Make sure you initialize these in somewhere, in case gdb gives up what it
   was debugging and starts debugging something else. FIXMEibm */

static int dummy_frame_count = 0;
static int dummy_frame_size = 0;
static CORE_ADDR *dummy_frame_addr = 0;

a683 91
/* push a dummy frame into stack, save all register. Currently we are saving
   only gpr's and fpr's, which is not good enough! FIXMEmgo */

void
push_dummy_frame ()
{
  /* stack pointer.  */
  CORE_ADDR sp;
  /* Same thing, target byte order.  */
  char sp_targ[4];

  /* link register.  */
  CORE_ADDR pc;
  /* Same thing, target byte order.  */
  char pc_targ[4];

  /* Needed to figure out where to save the dummy link area.
     FIXME: There should be an easier way to do this, no?  tiemann 9/9/95.  */
  struct rs6000_framedata fdata;

  int ii;

  target_fetch_registers (-1);

  if (dummy_frame_count >= dummy_frame_size)
    {
      dummy_frame_size += DUMMY_FRAME_ADDR_SIZE;
      if (dummy_frame_addr)
	dummy_frame_addr = (CORE_ADDR *) xrealloc
	  (dummy_frame_addr, sizeof (CORE_ADDR) * (dummy_frame_size));
      else
	dummy_frame_addr = (CORE_ADDR *)
	  xmalloc (sizeof (CORE_ADDR) * (dummy_frame_size));
    }

  sp = read_register (SP_REGNUM);
  pc = read_register (PC_REGNUM);
  store_address (pc_targ, 4, pc);

  skip_prologue (get_pc_function_start (pc), &fdata);

  dummy_frame_addr[dummy_frame_count++] = sp;

  /* Be careful! If the stack pointer is not decremented first, then kernel 
     thinks he is free to use the space underneath it. And kernel actually 
     uses that area for IPC purposes when executing ptrace(2) calls. So 
     before writing register values into the new frame, decrement and update
     %sp first in order to secure your frame. */

  /* FIXME: We don't check if the stack really has this much space.
     This is a problem on the ppc simulator (which only grants one page
     (4096 bytes) by default.  */

  write_register (SP_REGNUM, sp - DUMMY_FRAME_SIZE);

  /* gdb relies on the state of current_frame. We'd better update it,
     otherwise things like do_registers_info() wouldn't work properly! */

  flush_cached_frames ();

  /* save program counter in link register's space. */
  write_memory (sp + (fdata.lr_offset ? fdata.lr_offset : DEFAULT_LR_SAVE),
		pc_targ, 4);

  /* save all floating point and general purpose registers here. */

  /* fpr's, f0..f31 */
  for (ii = 0; ii < 32; ++ii)
    write_memory (sp - 8 - (ii * 8), &registers[REGISTER_BYTE (31 - ii + FP0_REGNUM)], 8);

  /* gpr's r0..r31 */
  for (ii = 1; ii <= 32; ++ii)
    write_memory (sp - 256 - (ii * 4), &registers[REGISTER_BYTE (32 - ii)], 4);

  /* so far, 32*2 + 32 words = 384 bytes have been written. 
     7 extra registers in our register set: pc, ps, cnd, lr, cnt, xer, mq */

  for (ii = 1; ii <= (LAST_UISA_SP_REGNUM - FIRST_UISA_SP_REGNUM + 1); ++ii)
    {
      write_memory (sp - 384 - (ii * 4),
		    &registers[REGISTER_BYTE (FPLAST_REGNUM + ii)], 4);
    }

  /* Save sp or so called back chain right here. */
  store_address (sp_targ, 4, sp);
  write_memory (sp - DUMMY_FRAME_SIZE, sp_targ, 4);
  sp -= DUMMY_FRAME_SIZE;

  /* And finally, this is the back chain. */
  write_memory (sp + 8, pc_targ, 4);
}
d685 1
a685 20

/* Pop a dummy frame.

   In rs6000 when we push a dummy frame, we save all of the registers. This
   is usually done before user calls a function explicitly.

   After a dummy frame is pushed, some instructions are copied into stack,
   and stack pointer is decremented even more.  Since we don't have a frame
   pointer to get back to the parent frame of the dummy, we start having
   trouble poping it.  Therefore, we keep a dummy frame stack, keeping
   addresses of dummy frames as such.  When poping happens and when we
   detect that was a dummy frame, we pop it back to its parent by using
   dummy frame stack (`dummy_frame_addr' array). 

   FIXME:  This whole concept is broken.  You should be able to detect
   a dummy stack frame *on the user's stack itself*.  When you do,
   then you know the format of that stack frame -- including its
   saved SP register!  There should *not* be a separate stack in the
   GDB process that keeps track of these dummy frames!  -- gnu@@cygnus.com Aug92
 */
d688 1
a688 42
pop_dummy_frame ()
{
  CORE_ADDR sp, pc;
  int ii;
  sp = dummy_frame_addr[--dummy_frame_count];

  /* restore all fpr's. */
  for (ii = 1; ii <= 32; ++ii)
    read_memory (sp - (ii * 8), &registers[REGISTER_BYTE (32 - ii + FP0_REGNUM)], 8);

  /* restore all gpr's */
  for (ii = 1; ii <= 32; ++ii)
    {
      read_memory (sp - 256 - (ii * 4), &registers[REGISTER_BYTE (32 - ii)], 4);
    }

  /* restore the rest of the registers. */
  for (ii = 1; ii <= (LAST_UISA_SP_REGNUM - FIRST_UISA_SP_REGNUM + 1); ++ii)
    read_memory (sp - 384 - (ii * 4),
		 &registers[REGISTER_BYTE (FPLAST_REGNUM + ii)], 4);

  read_memory (sp - (DUMMY_FRAME_SIZE - 8),
	       &registers[REGISTER_BYTE (PC_REGNUM)], 4);

  /* when a dummy frame was being pushed, we had to decrement %sp first, in 
     order to secure astack space. Thus, saved %sp (or %r1) value, is not the
     one we should restore. Change it with the one we need. */

  memcpy (&registers[REGISTER_BYTE (FP_REGNUM)], (char *) &sp, sizeof (int));

  /* Now we can restore all registers. */

  target_store_registers (-1);
  pc = read_pc ();
  flush_cached_frames ();
}


/* pop the innermost frame, go back to the caller. */

void
pop_frame ()
d693 1
a693 1
  int addr, ii;
d700 3
a702 12
      if (USE_GENERIC_DUMMY_FRAMES)
	{
	  generic_pop_dummy_frame ();
	  flush_cached_frames ();
	  return;
	}
      else
	{
	  if (dummy_frame_count)
	    pop_dummy_frame ();
	  return;
	}
d715 1
d719 1
a719 1
    prev_sp = read_memory_integer (sp, 4);
d723 1
a723 1
    lr = read_memory_integer (prev_sp + fdata.lr_offset, 4);
d735 2
a736 2
	  read_memory (addr, &registers[REGISTER_BYTE (ii)], 4);
	  addr += 4;
d755 2
a756 2
/* fixup the call sequence of a dummy function, with the real function address.
   its argumets will be passed by gdb. */
d758 4
a761 9
void
rs6000_fix_call_dummy (dummyname, pc, fun, nargs, args, type, gcc_p)
     char *dummyname;
     CORE_ADDR pc;
     CORE_ADDR fun;
     int nargs;
     value_ptr *args;
     struct type *type;
     int gcc_p;
d769 1
a769 1
  if (USE_GENERIC_DUMMY_FRAMES)
d771 2
a772 30
      if (find_toc_address_hook != NULL)
	{
	  CORE_ADDR tocvalue = (*find_toc_address_hook) (fun);
	  write_register (TOC_REGNUM, tocvalue);
	}
    }
  else
    {
      if (find_toc_address_hook != NULL)
	{
	  CORE_ADDR tocvalue;

	  tocvalue = (*find_toc_address_hook) (fun);
	  ii = *(int *) ((char *) dummyname + TOC_ADDR_OFFSET);
	  ii = (ii & 0xffff0000) | (tocvalue >> 16);
	  *(int *) ((char *) dummyname + TOC_ADDR_OFFSET) = ii;

	  ii = *(int *) ((char *) dummyname + TOC_ADDR_OFFSET + 4);
	  ii = (ii & 0xffff0000) | (tocvalue & 0x0000ffff);
	  *(int *) ((char *) dummyname + TOC_ADDR_OFFSET + 4) = ii;
	}

      target_addr = fun;
      ii = *(int *) ((char *) dummyname + TARGET_ADDR_OFFSET);
      ii = (ii & 0xffff0000) | (target_addr >> 16);
      *(int *) ((char *) dummyname + TARGET_ADDR_OFFSET) = ii;

      ii = *(int *) ((char *) dummyname + TARGET_ADDR_OFFSET + 4);
      ii = (ii & 0xffff0000) | (target_addr & 0x0000ffff);
      *(int *) ((char *) dummyname + TARGET_ADDR_OFFSET + 4) = ii;
d776 1
a776 1
/* Pass the arguments in either registers, or in the stack. In RS6000,
d779 1
a779 1
   passed in r3..r11 registers.  float and double parameters are
d785 3
d792 3
a794 7
CORE_ADDR
rs6000_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
d802 1
a808 6
  if (!USE_GENERIC_DUMMY_FRAMES)
    {
      if (dummy_frame_count <= 0)
	printf_unfiltered ("FATAL ERROR -push_arguments()! frame not found!!\n");
    }

d894 1
a894 3
  if (USE_GENERIC_DUMMY_FRAMES)
    {
      saved_sp = read_sp ();
d896 2
a897 2
      /* location for 8 parameters are always reserved. */
      sp -= 4 * 8;
d899 2
a900 2
      /* another six words for back chain, TOC register, link register, etc. */
      sp -= 24;
d902 2
a903 2
      /* stack pointer must be quadword aligned */
      sp &= -16;
a904 12
    }
  else
    {
      /* location for 8 parameters are always reserved. */
      sp -= 4 * 8;

      /* another six words for back chain, TOC register, link register, etc. */
      sp -= 24;

      /* stack pointer must be quadword aligned */
      sp &= -16;
    }
a980 10
  if (!USE_GENERIC_DUMMY_FRAMES)
    {
      /* we want to copy 24 bytes of target's frame to dummy's frame,
         then set back chain to point to new frame. */

      saved_sp = dummy_frame_addr[dummy_frame_count - 1];
      read_memory (saved_sp, tmp_buffer, 24);
      write_memory (sp, tmp_buffer, 24);
    }

a987 1
/* #ifdef ELF_OBJECT_FORMAT */
d992 2
a993 4
CORE_ADDR
ppc_push_return_address (pc, sp)
     CORE_ADDR pc;
     CORE_ADDR sp;
d999 2
a1000 1
/* #endif */
d1002 2
a1003 8
/* a given return value in `regbuf' with a type `valtype', extract and copy its
   value into `valbuf' */

void
extract_return_value (valtype, regbuf, valbuf)
     struct type *valtype;
     char regbuf[REGISTER_BYTES];
     char *valbuf;
d1040 1
a1040 2

/* keep structure return address in this variable.
d1045 1
a1045 2
CORE_ADDR rs6000_struct_return_address;

d1056 1
a1056 2
skip_trampoline_code (pc)
     CORE_ADDR pc;
d1085 1
a1085 1
  pc = read_memory_integer (ii, 4);	/* (r11) value                  */
d1091 1
a1091 1
int
d1125 1
a1125 1
unsigned long
d1130 1
d1133 1
a1133 1
    return read_memory_integer (fi->frame + SIG_FRAME_PC_OFFSET, 4);
d1135 2
a1136 5
  if (USE_GENERIC_DUMMY_FRAMES)
    {
      if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
	return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
    }
d1150 2
a1151 1
	return read_memory_integer (fi->next->frame + SIG_FRAME_LR_OFFSET, 4);
d1153 2
a1154 1
	return read_memory_integer (FRAME_CHAIN (fi) + DEFAULT_LR_SAVE, 4);
d1160 1
a1160 1
  return read_memory_integer (FRAME_CHAIN (fi) + fdata.lr_offset, 4);
d1168 1
a1168 3
frame_get_saved_regs (fi, fdatap)
     struct frame_info *fi;
     struct rs6000_framedata *fdatap;
d1172 1
d1196 1
a1196 1
    frame_addr = read_memory_integer (fi->frame, 4);
d1204 1
a1204 1
      int fpr_offset = frame_addr + fdatap->fpr_offset;
d1207 2
a1208 2
	  fi->saved_regs[FP0_REGNUM + i] = fpr_offset;
	  fpr_offset += 8;
d1218 1
a1218 1
      int gpr_offset = frame_addr + fdatap->gpr_offset;
d1221 2
a1222 2
	  fi->saved_regs[i] = gpr_offset;
	  gpr_offset += 4;
d1242 1
a1242 2
frame_initial_stack_address (fi)
     struct frame_info *fi;
d1294 2
a1295 1
	  fi->extra_info->initial_sp = read_memory_integer (tmpaddr, 4);
d1310 11
a1320 3
CORE_ADDR
rs6000_frame_chain (thisframe)
     struct frame_info *thisframe;
d1322 2
a1323 1
  CORE_ADDR fp;
d1325 2
a1326 5
  if (USE_GENERIC_DUMMY_FRAMES)
    {
      if (PC_IN_CALL_DUMMY (thisframe->pc, thisframe->frame, thisframe->frame))
	return thisframe->frame;	/* dummy frame same as caller's frame */
    }
d1333 2
a1334 1
    fp = read_memory_integer (thisframe->frame + SIG_FRAME_FP_OFFSET, 4);
d1342 103
a1444 1
    fp = read_memory_integer ((thisframe)->frame, 4);
d1446 5
a1450 1
  if (USE_GENERIC_DUMMY_FRAMES)
d1452 6
a1457 1
      CORE_ADDR fpp, lr;
d1459 11
a1469 5
      lr = read_register (LR_REGNUM);
      if (lr == entry_point_address ())
	if (fp != 0 && (fpp = read_memory_integer (fp, 4)) != 0)
	  if (PC_IN_CALL_DUMMY (lr, fpp, fpp))
	    return fpp;
d1471 50
d1522 16
a1537 1
  return fp;
d1540 16
d1559 2
a1560 3
int
is_magic_function_pointer (addr)
     CORE_ADDR addr;
d1566 1
a1566 4
    return 0;
  else
    return 1;
}
d1568 2
a1569 10
#ifdef GDB_TARGET_POWERPC
int
gdb_print_insn_powerpc (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
{
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
    return print_insn_big_powerpc (memaddr, info);
  else
    return print_insn_little_powerpc (memaddr, info);
a1570 1
#endif
d1573 1
a1573 1
/* Handling the various PowerPC/RS6000 variants.  */
d1576 2
a1577 2
/* The arrays here called register_names_MUMBLE hold names that 
   the rs6000_register_name function returns.
d1594 3
a1596 1
   processor.  */
d1598 1
a1598 1
/* UISA register names common across all architectures, including POWER.  */
d1600 1
a1600 31
#define COMMON_UISA_REG_NAMES \
  /*  0 */ "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",  \
  /*  8 */ "r8", "r9", "r10","r11","r12","r13","r14","r15", \
  /* 16 */ "r16","r17","r18","r19","r20","r21","r22","r23", \
  /* 24 */ "r24","r25","r26","r27","r28","r29","r30","r31", \
  /* 32 */ "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",  \
  /* 40 */ "f8", "f9", "f10","f11","f12","f13","f14","f15", \
  /* 48 */ "f16","f17","f18","f19","f20","f21","f22","f23", \
  /* 56 */ "f24","f25","f26","f27","f28","f29","f30","f31", \
  /* 64 */ "pc", "ps"

/* UISA-level SPR names for PowerPC.  */
#define PPC_UISA_SPR_NAMES \
  /* 66 */ "cr",  "lr", "ctr", "xer", ""

/* Segment register names, for PowerPC.  */
#define PPC_SEGMENT_REG_NAMES \
  /* 71 */ "sr0", "sr1", "sr2",  "sr3",  "sr4",  "sr5",  "sr6",  "sr7", \
  /* 79 */ "sr8", "sr9", "sr10", "sr11", "sr12", "sr13", "sr14", "sr15"

/* OEA SPR names for 32-bit PowerPC implementations.
   The blank space is for "asr", which is only present on 64-bit
   implementations.  */
#define PPC_32_OEA_SPR_NAMES \
  /*  87 */ "pvr", \
  /*  88 */ "ibat0u", "ibat0l", "ibat1u", "ibat1l", \
  /*  92 */ "ibat2u", "ibat2l", "ibat3u", "ibat3l", \
  /*  96 */ "dbat0u", "dbat0l", "dbat1u", "dbat1l", \
  /* 100 */ "dbat2u", "dbat2l", "dbat3u", "dbat3l", \
  /* 104 */ "sdr1", "", "dar", "dsisr", "sprg0", "sprg1", "sprg2", "sprg3",\
  /* 112 */ "srr0", "srr1", "tbl", "tbu", "dec", "dabr", "ear"
d1602 65
a1666 2
/* For the RS6000, we only cover user-level SPR's.  */
char *register_names_rs6000[] =
d1668 2
a1669 2
  COMMON_UISA_REG_NAMES,
  /* 66 */ "cnd", "lr", "cnt", "xer", "mq"
d1672 3
a1674 2
/* a UISA-only view of the PowerPC.  */
char *register_names_uisa[] =
d1676 2
a1677 2
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES
d1680 2
a1681 1
char *register_names_403[] =
d1683 10
a1692 7
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES,
  PPC_SEGMENT_REG_NAMES,
  PPC_32_OEA_SPR_NAMES,
  /* 119 */ "icdbdr", "esr", "dear", "evpr", "cdbcr", "tsr", "tcr", "pit",
  /* 127 */ "tbhi", "tblo", "srr2", "srr3", "dbsr", "dbcr", "iac1", "iac2",
  /* 135 */ "dac1", "dac2", "dccr", "iccr", "pbl1", "pbu1", "pbl2", "pbu2"
d1695 2
a1696 1
char *register_names_403GC[] =
d1698 12
a1709 8
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES,
  PPC_SEGMENT_REG_NAMES,
  PPC_32_OEA_SPR_NAMES,
  /* 119 */ "icdbdr", "esr", "dear", "evpr", "cdbcr", "tsr", "tcr", "pit",
  /* 127 */ "tbhi", "tblo", "srr2", "srr3", "dbsr", "dbcr", "iac1", "iac2",
  /* 135 */ "dac1", "dac2", "dccr", "iccr", "pbl1", "pbu1", "pbl2", "pbu2",
  /* 143 */ "zpr", "pid", "sgr", "dcwr", "tbhu", "tblu"
d1712 2
a1713 1
char *register_names_505[] =
d1715 5
a1719 5
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES,
  PPC_SEGMENT_REG_NAMES,
  PPC_32_OEA_SPR_NAMES,
  /* 119 */ "eie", "eid", "nri"
d1722 2
a1723 1
char *register_names_860[] =
d1725 16
a1740 12
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES,
  PPC_SEGMENT_REG_NAMES,
  PPC_32_OEA_SPR_NAMES,
  /* 119 */ "eie", "eid", "nri", "cmpa", "cmpb", "cmpc", "cmpd", "icr",
  /* 127 */ "der", "counta", "countb", "cmpe", "cmpf", "cmpg", "cmph",
  /* 134 */ "lctrl1", "lctrl2", "ictrl", "bar", "ic_cst", "ic_adr", "ic_dat",
  /* 141 */ "dc_cst", "dc_adr", "dc_dat", "dpdr", "dpir", "immr", "mi_ctr",
  /* 148 */ "mi_ap", "mi_epn", "mi_twc", "mi_rpn", "md_ctr", "m_casid",
  /* 154 */ "md_ap", "md_epn", "md_twb", "md_twc", "md_rpn", "m_tw",
  /* 160 */ "mi_dbcam", "mi_dbram0", "mi_dbram1", "md_dbcam", "md_dbram0",
  /* 165 */ "md_dbram1"
d1743 2
a1744 2
/* Note that the 601 has different register numbers for reading and
   writing RTCU and RTCL.  However, how one reads and writes a
d1746 1
a1746 1
char *register_names_601[] =
d1748 6
a1753 6
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES,
  PPC_SEGMENT_REG_NAMES,
  PPC_32_OEA_SPR_NAMES,
  /* 119 */ "hid0", "hid1", "iabr", "dabr", "pir", "mq", "rtcu",
  /* 126 */ "rtcl"
d1756 2
a1757 1
char *register_names_602[] =
d1759 7
a1765 6
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES,
  PPC_SEGMENT_REG_NAMES,
  PPC_32_OEA_SPR_NAMES,
  /* 119 */ "hid0", "hid1", "iabr", "", "", "tcr", "ibr", "esassr", "sebr",
  /* 128 */ "ser", "sp", "lt"
d1768 2
a1769 1
char *register_names_603[] =
d1771 7
a1777 6
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES,
  PPC_SEGMENT_REG_NAMES,
  PPC_32_OEA_SPR_NAMES,
  /* 119 */ "hid0", "hid1", "iabr", "", "", "dmiss", "dcmp", "hash1",
  /* 127 */ "hash2", "imiss", "icmp", "rpa"
d1780 2
a1781 1
char *register_names_604[] =
d1783 7
a1789 6
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES,
  PPC_SEGMENT_REG_NAMES,
  PPC_32_OEA_SPR_NAMES,
  /* 119 */ "hid0", "hid1", "iabr", "dabr", "pir", "mmcr0", "pmc1", "pmc2",
  /* 127 */ "sia", "sda"
d1792 2
a1793 1
char *register_names_750[] =
d1795 10
a1804 8
  COMMON_UISA_REG_NAMES,
  PPC_UISA_SPR_NAMES,
  PPC_SEGMENT_REG_NAMES,
  PPC_32_OEA_SPR_NAMES,
  /* 119 */ "hid0", "hid1", "iabr", "dabr", "", "ummcr0", "upmc1", "upmc2",
  /* 127 */ "usia", "ummcr1", "upmc3", "upmc4", "mmcr0", "pmc1", "pmc2",
  /* 134 */ "sia", "mmcr1", "pmc3", "pmc4", "l2cr", "ictc", "thrm1", "thrm2",
  /* 142 */ "thrm3"
d1809 1
d1818 6
d1826 2
a1827 2
    int num_registers;
    char **registers;
d1843 1
a1843 2
static struct variant
  variants[] =
d1845 35
a1879 22
  {"ppc-uisa", "PowerPC UISA - a PPC processor as viewed by user-level code",
   num_registers (register_names_uisa), register_names_uisa},
  {"rs6000", "IBM RS6000 (\"POWER\") architecture, user-level view",
   num_registers (register_names_rs6000), register_names_rs6000},
  {"403", "IBM PowerPC 403",
   num_registers (register_names_403), register_names_403},
  {"403GC", "IBM PowerPC 403GC",
   num_registers (register_names_403GC), register_names_403GC},
  {"505", "Motorola PowerPC 505",
   num_registers (register_names_505), register_names_505},
  {"860", "Motorola PowerPC 860 or 850",
   num_registers (register_names_860), register_names_860},
  {"601", "Motorola PowerPC 601",
   num_registers (register_names_601), register_names_601},
  {"602", "Motorola PowerPC 602",
   num_registers (register_names_602), register_names_602},
  {"603", "Motorola/IBM PowerPC 603 or 603e",
   num_registers (register_names_603), register_names_603},
  {"604", "Motorola PowerPC 604 or 604e",
   num_registers (register_names_604), register_names_604},
  {"750", "Motorola/IBM PowerPC 750 or 740",
   num_registers (register_names_750), register_names_750},
d1883 1
d1885 2
a1886 1
static struct variant *current_variant;
d1888 2
a1889 2
char *
rs6000_register_name (int i)
d1891 1
a1891 2
  if (i < 0 || i >= NUM_REGS)
    error ("GDB bug: rs6000-tdep.c (rs6000_register_name): strange register number");
d1893 3
a1895 4
  return ((i < current_variant->num_registers)
	  ? current_variant->registers[i]
	  : "");
}
d1897 1
a1897 5

static void
install_variant (struct variant *v)
{
  current_variant = v;
d1900 2
d1903 2
a1904 4
/* Look up the variant named NAME in the `variants' table.  Return a
   pointer to the struct variant, or null if we couldn't find it.  */
static struct variant *
find_variant_by_name (char *name)
d1906 1
a1906 1
  int i;
d1908 3
a1910 3
  for (i = 0; variants[i].name; i++)
    if (!strcmp (name, variants[i].name))
      return &variants[i];
d1912 1
a1912 1
  return 0;
d1915 1
d1917 25
a1941 13
/* Install the PPC/RS6000 variant named NAME in the `variants' table.
   Return zero if we installed it successfully, or a non-zero value if
   we couldn't do it.

   This might be useful to code outside this file, which doesn't want
   to depend on the exact indices of the entries in the `variants'
   table.  Just make it non-static if you want that.  */
static int
install_variant_by_name (char *name)
{
  struct variant *v = find_variant_by_name (name);

  if (v)
d1943 4
a1946 2
      install_variant (v);
      return 0;
d1949 7
a1955 23
    return 1;
}


static void
list_variants ()
{
  int i;

  printf_filtered ("GDB knows about the following PowerPC and RS6000 variants:\n");

  for (i = 0; variants[i].name; i++)
    printf_filtered ("  %-8s  %s\n",
		     variants[i].name, variants[i].description);
}


static void
show_current_variant ()
{
  printf_filtered ("PowerPC / RS6000 processor variant is set to `%s'.\n",
		   current_variant->name);
}
d1957 20
d1978 1
a1978 4
static void
set_processor (char *arg, int from_tty)
{
  if (!arg || arg[0] == '\0')
d1980 2
a1981 2
      list_variants ();
      return;
d1983 1
a1983 2

  if (install_variant_by_name (arg))
d1985 113
a2097 9
      error_begin ();
      fprintf_filtered (gdb_stderr,
	"`%s' is not a recognized PowerPC / RS6000 variant name.\n\n", arg);
      list_variants ();
      return_to_top_level (RETURN_ERROR);
    }

  show_current_variant ();
}
d2099 1
a2099 4
static void
show_processor (char *arg, int from_tty)
{
  show_current_variant ();
a2101 3



d2107 2
a2108 39
  /* FIXME, this should not be decided via ifdef. */
#ifdef GDB_TARGET_POWERPC
  tm_print_insn = gdb_print_insn_powerpc;
#else
  tm_print_insn = print_insn_rs6000;
#endif

  /* I don't think we should use the set/show command arrangement
     here, because the way that's implemented makes it hard to do the
     error checking we want in a reasonable way.  So we just add them
     as two separate commands.  */
  add_cmd ("processor", class_support, set_processor,
	   "`set processor NAME' sets the PowerPC/RS6000 variant to NAME.\n\
If you set this, GDB will know about the special-purpose registers that are\n\
available on the given variant.\n\
Type `set processor' alone for a list of recognized variant names.",
	   &setlist);
  add_cmd ("processor", class_support, show_processor,
	   "Show the variant of the PowerPC or RS6000 processor in use.\n\
Use `set processor' to change this.",
	   &showlist);

  /* Set the current PPC processor variant.  */
  {
    int status = 1;

#ifdef TARGET_CPU_DEFAULT
    status = install_variant_by_name (TARGET_CPU_DEFAULT);
#endif

    if (status)
      {
#ifdef GDB_TARGET_POWERPC
	install_variant_by_name ("ppc-uisa");
#else
	install_variant_by_name ("rs6000");
#endif
      }
  }
@


1.6
log
@PARAMS removal.
@
text
@d50 1
a50 1
CORE_ADDR (*find_toc_address_hook) PARAMS ((CORE_ADDR)) = NULL;
@


1.5
log
@Changes to skip_prologue for PPC architecture.
@
text
@d54 2
a55 2
     static CORE_ADDR branch_dest PARAMS ((int opcode, int instr, CORE_ADDR pc,
					   CORE_ADDR safety));
d57 2
a58 2
     static void frame_get_saved_regs PARAMS ((struct frame_info * fi,
					 struct rs6000_framedata * fdatap));
d60 1
a60 1
     static void pop_dummy_frame PARAMS ((void));
d62 1
a62 1
     static CORE_ADDR frame_initial_stack_address PARAMS ((struct frame_info *));
@


1.4
log
@Shared library, function calling fixes for GNU/Linux PPC port.
@
text
@d308 1
a308 3
skip_prologue (pc, fdata)
     CORE_ADDR pc;
     struct rs6000_framedata *fdata;
d311 1
d320 1
a320 1
  static struct rs6000_framedata zero_frame;
d322 1
a322 1
  *fdata = zero_frame;
a328 4
  if (target_read_memory (pc, buf, 4))
    return pc;			/* Can't access it -- assume no prologue. */

  /* Assume that subsequent fetches can fail with low probability.  */
d333 12
a344 1
      op = read_memory_integer (pc, 4);
d384 10
d583 1
a583 1
  return pc;
@


1.3
log
@Changes for GNU/Linux PPC native port of gdb.
@
text
@d316 2
a317 2
  int lr_reg = 0;
  int cr_reg = 0;
d394 1
a394 1
      else if ((op & 0xffff0000) == lr_reg)
d403 1
a403 1
      else if ((op & 0xffff0000) == cr_reg)
@


1.2
log
@AIX 4.3 changes.
@
text
@d2 1
a2 1
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997
d1241 1
a1241 2
frameless_function_invocation (fi)
     struct frame_info *fi;
d1275 1
a1275 2
frame_saved_pc (fi)
     struct frame_info *fi;
d1303 1
a1303 2
	return read_memory_integer (rs6000_frame_chain (fi) + DEFAULT_LR_SAVE,
				    4);
d1309 1
a1309 1
  return read_memory_integer (rs6000_frame_chain (fi) + fdata.lr_offset, 4);
d1480 1
a1480 1
	   && frameless_function_invocation (thisframe))
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d37 8
a44 6
static struct sstep_breaks {
  /* Address, or 0 if this is not in use.  */
  CORE_ADDR address;
  /* Shadow contents.  */
  char data[4];
} stepBreaks[2];
d54 2
a55 2
static CORE_ADDR branch_dest PARAMS ((int opcode, int instr, CORE_ADDR pc,
				      CORE_ADDR safety));
d57 2
a58 2
static void frame_get_saved_regs PARAMS ((struct frame_info *fi,
					  struct rs6000_framedata *fdatap));
d60 12
a71 1
static void pop_dummy_frame PARAMS ((void));
a72 1
static CORE_ADDR frame_initial_stack_address PARAMS ((struct frame_info *));
d83 1
a83 1
  CORE_ADDR initial_sp;			/* initial stack pointer. */
d91 1
a91 1
  fi->extra_info = (struct frame_extra_info*)
d96 1
a96 1
    /* We're in get_prev_frame_info */
d138 9
a146 16
  switch (opcode) {
     case 18	:
	immediate = ((instr & ~3) << 6) >> 6;	/* br unconditional */
	if (absolute)
	  dest = immediate;	
	else
	  dest = pc + immediate;
	break;

     case 16	:  
        immediate = ((instr & ~3) << 16) >> 16;	/* br conditional */
	if (absolute)
	  dest = immediate;	
	else
	  dest = pc + immediate;
	break;
d148 14
a161 2
      case 19	:
	ext_op = (instr>>1) & 0x3ff;
d163 23
a185 2
	if (ext_op == 16)			/* br conditional register */
	  {
d187 4
d192 3
a194 30
	    /* If we are about to return from a signal handler, dest is
	       something like 0x3c90.  The current frame is a signal handler
	       caller frame, upon completion of the sigreturn system call
	       execution will return to the saved PC in the frame.  */
	    if (dest < TEXT_SEGMENT_BASE)
	      {
		struct frame_info *fi;

		fi = get_current_frame ();
		if (fi != NULL)
		  dest = read_memory_integer (fi->frame + SIG_FRAME_PC_OFFSET,
					      4);
	      }
	  }

	else if (ext_op == 528)			/* br cond to count reg */
	  {
	    dest = read_register (CTR_REGNUM) & ~3;

	    /* If we are about to execute a system call, dest is something
	       like 0x22fc or 0x3b00.  Upon completion the system call
	       will return to the address in the link register.  */
	    if (dest < TEXT_SEGMENT_BASE)
	      dest = read_register (LR_REGNUM) & ~3;
	  }
	else return -1; 
	break;
	
       default: return -1;
  }
d236 2
a237 1
  if (insert_breakpoints_p) {
d239 1
a239 1
    loc = read_pc ();
d241 1
a241 1
    insn = read_memory_integer (loc, 4);
d243 3
a245 3
    breaks[0] = loc + INSNLEN(insn);
    opcode = insn >> 26;
    breaks[1] = branch_dest (opcode, insn, loc, breaks[0]);
d247 3
a249 3
    /* Don't put two breakpoints on the same address. */
    if (breaks[1] == breaks[0])
      breaks[1] = -1;
d251 1
a251 1
    stepBreaks[1].address = 0;
d253 2
a254 1
    for (ii=0; ii < 2; ++ii) {
d256 3
a258 3
      /* ignore invalid breakpoint. */
      if ( breaks[ii] == -1)
        continue;
d260 1
a260 1
      read_memory (breaks[ii], stepBreaks[ii].data, 4);
d262 3
a264 3
      write_memory (breaks[ii], breakp, 4);
      stepBreaks[ii].address = breaks[ii];
    }  
d266 3
a268 1
  } else {
d270 5
a274 5
    /* remove step breakpoints. */
    for (ii=0; ii < 2; ++ii)
      if (stepBreaks[ii].address != 0)
        write_memory 
           (stepBreaks[ii].address, stepBreaks[ii].data, 4);
d276 1
a276 1
  }
d278 1
a278 1
			/* What errors?  {read,write}_memory call error().  */
d286 13
a298 13
    - frameless is TRUE, if function does not have a frame.
    - nosavedpc is TRUE, if function does not save %pc value in its frame.
    - offset is the initial size of this stack frame --- the amount by
      which we decrement the sp to allocate the frame.
    - saved_gpr is the number of the first saved gpr.
    - saved_fpr is the number of the first saved fpr.
    - alloca_reg is the number of the register used for alloca() handling.
      Otherwise -1.
    - gpr_offset is the offset of the first saved gpr from the previous frame.
    - fpr_offset is the offset of the first saved fpr from the previous frame.
    - lr_offset is the offset of the saved lr
    - cr_offset is the offset of the saved cr
*/
d310 1
a310 1
     struct rs6000_framedata *fdata; 
d340 5
a344 13
      if ((op & 0xfc1fffff) == 0x7c0802a6) {		/* mflr Rx */
	lr_reg = (op & 0x03e00000) | 0x90010000;
	continue;

      } else if ((op & 0xfc1fffff) == 0x7c000026) {	/* mfcr Rx */
	cr_reg = (op & 0x03e00000) | 0x90010000;
	continue;

      } else if ((op & 0xfc1f0000) == 0xd8010000) {	/* stfd Rx,NUM(r1) */
	reg = GET_SRC_REG (op);
	if (fdata->saved_fpr == -1 || fdata->saved_fpr > reg) {
	  fdata->saved_fpr = reg;
	  fdata->fpr_offset = SIGNED_SHORT (op) + offset;
d346 4
a349 1
	continue;
d351 14
a364 2
      } else if (((op & 0xfc1f0000) == 0xbc010000) || 	/* stm Rx, NUM(r1) */
		 ((op & 0xfc1f0000) == 0x90010000 &&	/* st rx,NUM(r1), 
d366 2
a367 1
		  (op & 0x03e00000) >= 0x01a00000)) {
d369 7
a375 35
	reg = GET_SRC_REG (op);
	if (fdata->saved_gpr == -1 || fdata->saved_gpr > reg) {
	  fdata->saved_gpr = reg;
	  fdata->gpr_offset = SIGNED_SHORT (op) + offset;
	}
	continue;

      } else if ((op & 0xffff0000) == 0x3c000000) {	/* addis 0,0,NUM, used
							   for >= 32k frames */
	fdata->offset = (op & 0x0000ffff) << 16;
	fdata->frameless = 0;
	continue;

      } else if ((op & 0xffff0000) == 0x60000000) {	/* ori 0,0,NUM, 2nd ha
							   lf of >= 32k frames */
	fdata->offset |= (op & 0x0000ffff);
	fdata->frameless = 0;
	continue;

      } else if ((op & 0xffff0000) == lr_reg) {		/* st Rx,NUM(r1) 
							   where Rx == lr */
	fdata->lr_offset = SIGNED_SHORT (op) + offset;
	fdata->nosavedpc = 0;
	lr_reg = 0;
	continue;

      } else if ((op & 0xffff0000) == cr_reg) {		/* st Rx,NUM(r1) 
							   where Rx == cr */
	fdata->cr_offset = SIGNED_SHORT (op) + offset;
	cr_reg = 0;
	continue;

      } else if (op == 0x48000005) {			/* bl .+4 used in 
							   -mrelocatable */
	continue;
d377 32
a408 2
      } else if (op == 0x48000004) {			/* b .+4 (xlc) */
	break;
d410 13
a422 1
      } else if (((op & 0xffff0000) == 0x801e0000 ||	/* lwz 0,NUM(r30), used
d424 5
a428 4
		  op == 0x7fc0f214) &&			/* add r30,r0,r30, used
							   in V.4 -mrelocatable */
		 lr_reg == 0x901e0000) {
	continue;
d430 2
a431 1
      } else if ((op & 0xffff0000) == 0x3fc00000 ||	/* addis 30,0,foo@@ha, used
d433 60
a492 2
		 (op & 0xffff0000) == 0x3bde0000) {	/* addi 30,30,foo@@l */
	continue;
d494 16
a509 2
      } else if ((op & 0xfc000000) == 0x48000000) {	/* bl foo, 
							   to save fprs??? */
d511 9
a519 5
	fdata->frameless = 0;
	/* Don't skip over the subroutine call if it is not within the first
	   three instructions of the prologue.  */
	if ((pc - orig_pc) > 8)
	  break;
d521 8
a528 1
	op = read_memory_integer (pc+4, 4);
d530 5
a534 59
	/* At this point, make sure this is not a trampoline function
	   (a function that simply calls another functions, and nothing else).
	   If the next is not a nop, this branch was part of the function
	   prologue. */

	if (op == 0x4def7b82 || op == 0)		/* crorc 15, 15, 15 */
	  break;					/* don't skip over 
							   this branch */
	continue;

      /* update stack pointer */
      } else if ((op & 0xffff0000) == 0x94210000) {	/* stu r1,NUM(r1) */
	fdata->frameless = 0;
	fdata->offset = SIGNED_SHORT (op);
	offset = fdata->offset;
	continue;

      } else if (op == 0x7c21016e) {			/* stwux 1,1,0 */
	fdata->frameless = 0;
	offset = fdata->offset;
	continue;

      /* Load up minimal toc pointer */
      } else if ((op >> 22) == 0x20f
	         && ! minimal_toc_loaded) {	/* l r31,... or l r30,... */
	minimal_toc_loaded = 1;
	continue;

      /* store parameters in stack */
      } else if ((op & 0xfc1f0000) == 0x90010000 ||	/* st rx,NUM(r1) */
		 (op & 0xfc1f0000) == 0xd8010000 ||	/* stfd Rx,NUM(r1) */
		 (op & 0xfc1f0000) == 0xfc010000) {	/* frsp, fp?,NUM(r1) */
	continue;

      /* store parameters in stack via frame pointer */
      } else if (framep &&
		 ((op & 0xfc1f0000) == 0x901f0000 ||	/* st rx,NUM(r1) */
		 (op & 0xfc1f0000) == 0xd81f0000 ||	/* stfd Rx,NUM(r1) */
		 (op & 0xfc1f0000) == 0xfc1f0000)) {	/* frsp, fp?,NUM(r1) */
	continue;

      /* Set up frame pointer */
      } else if (op == 0x603f0000			/* oril r31, r1, 0x0 */
		 || op == 0x7c3f0b78) {			/* mr r31, r1 */
	fdata->frameless = 0;
	framep = 1;
	fdata->alloca_reg = 31;
	continue;

      /* Another way to set up the frame pointer.  */
      } else if ((op & 0xfc1fffff) == 0x38010000) {	/* addi rX, r1, 0x0 */
	fdata->frameless = 0;
	framep = 1;
	fdata->alloca_reg = (op & ~0x38010000) >> 21;
	continue;

      } else {
	break;
      }
a546 1
     
a547 2
  if ((op & 0xfc000001) == 0x48000001) { /* bl foo, an initializer function? */
    op = read_memory_integer (pc+4, 4);
d549 14
a562 8
    if (op == 0x4def7b82) {		/* cror 0xf, 0xf, 0xf (nop) */

      /* check and see if we are in main. If so, skip over this initializer
         function as well. */

      tmp = find_pc_misc_function (pc);
      if (tmp >= 0 && STREQ (misc_function_vector [tmp].name, "main"))
        return pc + 8;
a563 1
  }
d565 2
a566 2
 
  fdata->offset = - fdata->offset;
d572 1
a572 1
  Support for creating pushind a dummy frame into the stack, and popping
d578 8
a585 6
	32 gpr's	- 128 bytes
	32 fpr's	- 256   "
	7  the rest	- 28    "
	and 24 extra bytes for the callee's link area. The last 24 bytes
	for the link area might not be necessary, since it will be taken
	care of by push_arguments(). */
d587 1
a587 1
#define DUMMY_FRAME_SIZE 436
d602 1
a602 1
   
d615 1
a615 1
  
d624 13
a636 12
  if (dummy_frame_count >= dummy_frame_size) {
    dummy_frame_size += DUMMY_FRAME_ADDR_SIZE;
    if (dummy_frame_addr)
      dummy_frame_addr = (CORE_ADDR*) xrealloc 
        (dummy_frame_addr, sizeof(CORE_ADDR) * (dummy_frame_size));
    else
      dummy_frame_addr = (CORE_ADDR*) 
	xmalloc (sizeof(CORE_ADDR) * (dummy_frame_size));
  }
  
  sp = read_register(SP_REGNUM);
  pc = read_register(PC_REGNUM);
d641 1
a641 1
  dummy_frame_addr [dummy_frame_count++] = sp;
d653 1
a653 1
  write_register (SP_REGNUM, sp-DUMMY_FRAME_SIZE);
d662 1
a662 1
	        pc_targ, 4);
d668 1
a668 1
    write_memory (sp-8-(ii*8), &registers[REGISTER_BYTE (31-ii+FP0_REGNUM)], 8);
d671 2
a672 2
  for (ii=1; ii <=32; ++ii)
    write_memory (sp-256-(ii*4), &registers[REGISTER_BYTE (32-ii)], 4);
d677 5
a681 4
  for (ii=1; ii <= (LAST_UISA_SP_REGNUM-FIRST_UISA_SP_REGNUM+1); ++ii) {
    write_memory (sp-384-(ii*4), 
		  &registers[REGISTER_BYTE (FPLAST_REGNUM + ii)], 4);
  }
d685 1
a685 1
  write_memory (sp-DUMMY_FRAME_SIZE, sp_targ, 4);
d689 1
a689 1
  write_memory (sp+8, pc_targ, 4);
d706 5
a710 5
FIXME:  This whole concept is broken.  You should be able to detect
a dummy stack frame *on the user's stack itself*.  When you do,
then you know the format of that stack frame -- including its
saved SP register!  There should *not* be a separate stack in the
GDB process that keeps track of these dummy frames!  -- gnu@@cygnus.com Aug92
d712 1
a712 1
   
d718 1
a718 1
  sp = dummy_frame_addr [--dummy_frame_count];
d722 1
a722 1
    read_memory (sp-(ii*8), &registers[REGISTER_BYTE (32-ii+FP0_REGNUM)], 8);
d725 4
a728 3
  for (ii=1; ii <= 32; ++ii) {
    read_memory (sp-256-(ii*4), &registers[REGISTER_BYTE (32-ii)], 4);
  }
d731 3
a733 3
  for (ii=1; ii <=(LAST_UISA_SP_REGNUM-FIRST_UISA_SP_REGNUM+1); ++ii)
    read_memory (sp-384-(ii*4),
    		&registers[REGISTER_BYTE (FPLAST_REGNUM + ii)], 4);
d735 2
a736 2
  read_memory (sp-(DUMMY_FRAME_SIZE-8), 
	       &registers [REGISTER_BYTE(PC_REGNUM)], 4);
d742 1
a742 1
  memcpy (&registers [REGISTER_BYTE(FP_REGNUM)], (char *) &sp, sizeof (int));
d757 1
a757 1
  CORE_ADDR pc, lr, sp, prev_sp;		/* %pc, %lr, %sp */
d767 12
a778 9
#ifdef USE_GENERIC_DUMMY_FRAMES
      generic_pop_dummy_frame ();
      flush_cached_frames ();
      return;
#else
      if (dummy_frame_count) 
	pop_dummy_frame ();
      return;
#endif
d808 5
a812 4
      for (ii = fdata.saved_gpr; ii <= 31; ++ii) {
	read_memory (addr, &registers [REGISTER_BYTE (ii)], 4);
	addr += 4;
      }
d818 5
a822 4
      for (ii = fdata.saved_fpr; ii <= 31; ++ii) {
	read_memory (addr, &registers [REGISTER_BYTE (ii+FP0_REGNUM)], 8);
	addr += 8;
      }
d849 9
a857 1
  if (find_toc_address_hook != NULL)
d859 3
a861 1
      CORE_ADDR tocvalue;
d863 9
a871 4
      tocvalue = (*find_toc_address_hook) (fun);
      ii  = *(int*)((char*)dummyname + TOC_ADDR_OFFSET);
      ii = (ii & 0xffff0000) | (tocvalue >> 16);
      *(int*)((char*)dummyname + TOC_ADDR_OFFSET) = ii;
d873 8
a880 3
      ii  = *(int*)((char*)dummyname + TOC_ADDR_OFFSET+4);
      ii = (ii & 0xffff0000) | (tocvalue & 0x0000ffff);
      *(int*)((char*)dummyname + TOC_ADDR_OFFSET+4) = ii;
a881 9

  target_addr = fun;
  ii  = *(int*)((char*)dummyname + TARGET_ADDR_OFFSET);
  ii = (ii & 0xffff0000) | (target_addr >> 16);
  *(int*)((char*)dummyname + TARGET_ADDR_OFFSET) = ii;

  ii  = *(int*)((char*)dummyname + TARGET_ADDR_OFFSET+4);
  ii = (ii & 0xffff0000) | (target_addr & 0x0000ffff);
  *(int*)((char*)dummyname + TARGET_ADDR_OFFSET+4) = ii;
d898 1
a898 1
push_arguments (nargs, args, sp, struct_return, struct_addr)
d907 4
a910 4
  int argno;					/* current argument number */
  int argbytes;					/* current argument byte */
  char tmp_buffer [50];
  int f_argno = 0;				/* current floating point argno */
d917 5
a921 4
#ifndef USE_GENERIC_DUMMY_FRAMES
  if ( dummy_frame_count <= 0)
    printf_unfiltered ("FATAL ERROR -push_arguments()! frame not found!!\n");
#endif	/* GENERIC_DUMMY_FRAMES */
d931 1
a931 1
  ii =  struct_return ? 1 : 0;
d934 17
a950 1
effectively indirect call... gcc does...
d952 3
a954 1
return_val example( float, int);
d956 48
a1003 55
eabi: 
    float in fp0, int in r3
    offset of stack on overflow 8/16
    for varargs, must go by type.
power open:
    float in r3&r4, int in r5
    offset of stack on overflow different 
both: 
    return in r3 or f0.  If no float, must study how gcc emulates floats;
    pay attention to arg promotion.  
    User may have to cast\args to handle promotion correctly 
    since gdb won't know if prototype supplied or not.
*/

  for (argno=0, argbytes=0; argno < nargs && ii<8; ++ii) {

    arg = args[argno];
    type = check_typedef (VALUE_TYPE (arg));
    len = TYPE_LENGTH (type);

    if (TYPE_CODE (type) == TYPE_CODE_FLT) {

      /* floating point arguments are passed in fpr's, as well as gpr's.
         There are 13 fpr's reserved for passing parameters. At this point
         there is no way we would run out of them. */

      if (len > 8)
        printf_unfiltered (
"Fatal Error: a floating point parameter #%d with a size > 8 is found!\n", argno);

      memcpy (&registers[REGISTER_BYTE(FP0_REGNUM + 1 + f_argno)], 
	      VALUE_CONTENTS (arg), 
	      len);
      ++f_argno;
    }

    if (len > 4) {

      /* Argument takes more than one register. */
      while (argbytes < len) {
	memset (&registers[REGISTER_BYTE(ii+3)], 0, sizeof(int));
	memcpy (&registers[REGISTER_BYTE(ii+3)], 
		((char*)VALUE_CONTENTS (arg))+argbytes, 
		(len - argbytes) > 4 ? 4 : len - argbytes);
	++ii, argbytes += 4;

	if (ii >= 8)
	  goto ran_out_of_registers_for_arguments;
      }
      argbytes = 0;
      --ii;
    }
    else {        /* Argument can fit in one register. No problem. */
      memset (&registers[REGISTER_BYTE(ii+3)], 0, sizeof(int));
      memcpy (&registers[REGISTER_BYTE(ii+3)], VALUE_CONTENTS (arg), len);
a1004 2
    ++argno;
  }
d1008 6
a1013 11
#ifdef USE_GENERIC_DUMMY_FRAMES
  saved_sp = read_sp ();
#else
  /* location for 8 parameters are always reserved. */
  sp -= 4 * 8;

  /* another six words for back chain, TOC register, link register, etc. */
  sp -= 24;
#endif	/* GENERIC_DUMMY_FRAMES */
  /* if there are more arguments, allocate space for them in 
     the stack, then push them starting from the ninth one. */
d1015 2
a1016 2
  if ((argno < nargs) || argbytes) {
    int space = 0, jj;
d1018 3
a1020 3
    if (argbytes) {
      space += ((len - argbytes + 3) & -4);
      jj = argno + 1;
d1022 7
a1028 2
    else
      jj = argno;
d1030 2
a1031 3
    for (; jj < nargs; ++jj) {
      value_ptr val = args[jj];
      space += ((TYPE_LENGTH (VALUE_TYPE (val))) + 3) & -4;
d1034 6
a1039 3
    /* add location required for the rest of the parameters */
    space = (space + 7) & -8;
    sp -= space;
d1041 7
a1047 4
    /* This is another instance we need to be concerned about securing our
	stack space. If we write anything underneath %sp (r1), we might conflict
	with the kernel who thinks he is free to use this area. So, update %sp
	first before doing anything else. */
d1049 5
a1053 1
    write_register (SP_REGNUM, sp);
d1055 3
a1057 2
    /* if the last argument copied into the registers didn't fit there 
       completely, push the rest of it into stack. */
d1059 4
a1062 7
    if (argbytes) {
      write_memory (sp+24+(ii*4), 
		    ((char*)VALUE_CONTENTS (arg))+argbytes, 
		    len - argbytes);
      ++argno;
      ii += ((len - argbytes + 3) & -4) / 4;
    }
d1064 1
a1064 2
    /* push the rest of the arguments into stack. */
    for (; argno < nargs; ++argno) {
d1066 2
a1067 3
      arg = args[argno];
      type = check_typedef (VALUE_TYPE (arg));
      len = TYPE_LENGTH (type);
d1069 8
d1078 3
a1080 2
      /* float types should be passed in fpr's, as well as in the stack. */
      if (TYPE_CODE (type) == TYPE_CODE_FLT && f_argno < 13) {
d1082 18
a1099 9
        if (len > 8)
          printf_unfiltered (
"Fatal Error: a floating point parameter #%d with a size > 8 is found!\n", argno);

        memcpy (&registers[REGISTER_BYTE(FP0_REGNUM + 1 + f_argno)], 
		VALUE_CONTENTS (arg), 
		len);
        ++f_argno;
      }
d1101 3
a1103 2
      write_memory (sp+24+(ii*4), (char *) VALUE_CONTENTS (arg), len);
      ii += ((len + 3) & -4) / 4;
a1104 1
  }
d1109 9
a1117 8
#ifndef USE_GENERIC_DUMMY_FRAMES
/* we want to copy 24 bytes of target's frame to dummy's frame,
   then set back chain to point to new frame. */

  saved_sp = dummy_frame_addr [dummy_frame_count - 1];
  read_memory (saved_sp, tmp_buffer, 24);
  write_memory (sp, tmp_buffer, 24);
#endif	/* GENERIC_DUMMY_FRAMES */
d1126 1
a1126 1
#ifdef ELF_OBJECT_FORMAT
d1131 1
a1131 1
CORE_ADDR                                      
d1140 1
a1140 1
#endif
d1153 2
a1154 1
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT) {
d1156 26
a1181 8
    double dd; float ff;
    /* floats and doubles are returned in fpr1. fpr's have a size of 8 bytes.
       We need to truncate the return value into float size (4 byte) if
       necessary. */

    if (TYPE_LENGTH (valtype) > 4) 		/* this is a double */
      memcpy (valbuf, 
	      &regbuf[REGISTER_BYTE (FP0_REGNUM + 1)],
a1182 4
    else {		/* float */
      memcpy (&dd, &regbuf[REGISTER_BYTE (FP0_REGNUM + 1)], 8);
      ff = (float)dd;
      memcpy (valbuf, &ff, sizeof(float));
a1183 11
  }
  else {
    /* return value is copied starting from r3. */
    if (TARGET_BYTE_ORDER == BIG_ENDIAN
	&& TYPE_LENGTH (valtype) < REGISTER_RAW_SIZE (3))
      offset = REGISTER_RAW_SIZE (3) - TYPE_LENGTH (valtype);

    memcpy (valbuf, 
	    regbuf + REGISTER_BYTE (3) + offset,
	    TYPE_LENGTH (valtype));
  }
d1210 10
a1219 9
  static unsigned trampoline_code[] = {
	0x800b0000,			/*     l   r0,0x0(r11)	*/
	0x90410014,			/*    st   r2,0x14(r1)	*/
	0x7c0903a6,			/* mtctr   r0		*/
	0x804b0004,			/*     l   r2,0x4(r11)	*/
	0x816b0008,			/*     l  r11,0x8(r11)	*/
	0x4e800420,			/*  bctr		*/
	0x4e800020,			/*    br		*/
	0
d1227 8
a1234 7
  for (ii=0; trampoline_code[ii]; ++ii) {
    op  = read_memory_integer (pc + (ii*4), 4);
    if (op != trampoline_code [ii])
      return 0;
  }
  ii = read_register (11);		/* r11 holds destination addr	*/
  pc = read_memory_integer (ii, 4);	/* (r11) value			*/
d1251 1
a1251 1
  
d1260 3
a1262 3
	 function pointer, normally causing an immediate core dump of the
	 inferior. Mark function as frameless, as the inferior has no chance
	 of setting up a stack frame.  */
d1285 5
a1289 4
#ifdef USE_GENERIC_DUMMY_FRAMES
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return generic_read_register_dummy(fi->pc, fi->frame, PC_REGNUM);
#endif	/* GENERIC_DUMMY_FRAMES */
d1324 1
a1324 2
  int ii;
  CORE_ADDR frame_addr; 
d1329 1
a1329 1
  
d1350 1
a1350 1
  
d1360 1
a1360 1
	  fi->saved_regs [FP0_REGNUM + i] = fpr_offset;
d1374 1
a1374 1
	  fi->saved_regs [i] = gpr_offset;
d1382 1
a1382 1
    fi->saved_regs [CR_REGNUM] = frame_addr + fdatap->cr_offset;
d1387 1
a1387 1
    fi->saved_regs [LR_REGNUM] = frame_addr + fdatap->lr_offset;
d1430 1
a1430 1
    return fi->extra_info->initial_sp = read_register (fdata.alloca_reg);     
d1437 2
a1438 1
  for (callee_fi = fi->next; callee_fi; callee_fi = callee_fi->next) {
d1440 2
a1441 2
    if (!callee_fi->saved_regs)
      frame_get_saved_regs (callee_fi, NULL);
d1443 1
a1443 1
    /* this is the address in which alloca register is saved. */
d1445 9
a1453 4
    tmpaddr = callee_fi->saved_regs [fdata.alloca_reg];
    if (tmpaddr) {
      fi->extra_info->initial_sp = read_memory_integer (tmpaddr, 4); 
      return fi->extra_info->initial_sp;
a1455 4
    /* Go look into deeper levels of the frame chain to see if any one of
       the callees has saved alloca register. */
  }

d1469 5
a1473 4
#ifdef USE_GENERIC_DUMMY_FRAMES
  if (PC_IN_CALL_DUMMY (thisframe->pc, thisframe->frame, thisframe->frame))
    return thisframe->frame;	/* dummy frame same as caller's frame */
#endif	/* GENERIC_DUMMY_FRAMES */
d1475 1
a1475 1
  if (inside_entry_file (thisframe->pc) || 
d1490 10
a1499 3
#ifdef USE_GENERIC_DUMMY_FRAMES
  {
    CORE_ADDR fpp, lr;
a1500 7
    lr = read_register (LR_REGNUM);
    if (lr == entry_point_address ())
      if (fp != 0 && (fpp = read_memory_integer (fp, 4)) != 0)
	if (PC_IN_CALL_DUMMY (lr, fpp, fpp))
	  return fpp;
  }
#endif	/* GENERIC_DUMMY_FRAMES */
d1532 1
a1533 20
/* Function: get_saved_register
   Just call the generic_get_saved_register function.  */

#ifdef USE_GENERIC_DUMMY_FRAMES
void
get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lval;
{
  generic_get_saved_register (raw_buffer, optimized, addrp, 
			      frame, regnum, lval);
}
#endif



d1550 2
a1551 2
	tblo srr2 srr3 dbsr dbcr iac1 iac2 dac1 dac2 dccr iccr pbl1
	pbu1 pbl2 pbu2
d1606 1
a1606 1
{ 
d1611 2
a1612 2
  /* 119 */ "icdbdr", "esr", "dear", "evpr", "cdbcr", "tsr", "tcr", "pit", 
  /* 127 */ "tbhi", "tblo", "srr2", "srr3", "dbsr", "dbcr", "iac1", "iac2", 
d1617 1
a1617 1
{ 
d1622 3
a1624 3
  /* 119 */ "icdbdr", "esr", "dear", "evpr", "cdbcr", "tsr", "tcr", "pit", 
  /* 127 */ "tbhi", "tblo", "srr2", "srr3", "dbsr", "dbcr", "iac1", "iac2", 
  /* 135 */ "dac1", "dac2", "dccr", "iccr", "pbl1", "pbu1", "pbl2", "pbu2", 
d1629 1
a1629 1
{ 
d1638 1
a1638 1
{ 
d1643 7
a1649 7
  /* 119 */ "eie", "eid", "nri", "cmpa", "cmpb", "cmpc", "cmpd", "icr", 
  /* 127 */ "der", "counta", "countb", "cmpe", "cmpf", "cmpg", "cmph", 
  /* 134 */ "lctrl1", "lctrl2", "ictrl", "bar", "ic_cst", "ic_adr", "ic_dat", 
  /* 141 */ "dc_cst", "dc_adr", "dc_dat", "dpdr", "dpir", "immr", "mi_ctr", 
  /* 148 */ "mi_ap", "mi_epn", "mi_twc", "mi_rpn", "md_ctr", "m_casid", 
  /* 154 */ "md_ap", "md_epn", "md_twb", "md_twc", "md_rpn", "m_tw", 
  /* 160 */ "mi_dbcam", "mi_dbram0", "mi_dbram1", "md_dbcam", "md_dbram0", 
d1657 1
a1657 1
{ 
d1662 1
a1662 1
  /* 119 */ "hid0", "hid1", "iabr", "dabr", "pir", "mq", "rtcu", 
d1667 1
a1667 1
{ 
d1672 1
a1672 1
  /* 119 */ "hid0", "hid1", "iabr", "", "", "tcr", "ibr", "esassr", "sebr", 
d1677 1
a1677 1
{ 
d1682 1
a1682 1
  /* 119 */ "hid0", "hid1", "iabr", "", "", "dmiss", "dcmp", "hash1", 
d1687 1
a1687 1
{ 
d1692 1
a1692 1
  /* 119 */ "hid0", "hid1", "iabr", "dabr", "pir", "mmcr0", "pmc1", "pmc2", 
d1697 1
a1697 1
{ 
d1702 3
a1704 3
  /* 119 */ "hid0", "hid1", "iabr", "dabr", "", "ummcr0", "upmc1", "upmc2", 
  /* 127 */ "usia", "ummcr1", "upmc3", "upmc4", "mmcr0", "pmc1", "pmc2", 
  /* 134 */ "sia", "mmcr1", "pmc3", "pmc4", "l2cr", "ictc", "thrm1", "thrm2", 
d1711 3
a1713 3
{
  /* Name of this variant.  */
  char *name;
d1715 2
a1716 2
  /* English description of the variant.  */
  char *description;
d1718 5
a1722 5
  /* Table of register names; registers[R] is the name of the register
     number R.  */
  int num_registers;
  char **registers;
};
d1738 1
a1738 1
variants[] =
d1740 23
a1762 23
  { "ppc-uisa", "PowerPC UISA - a PPC processor as viewed by user-level code",
    num_registers (register_names_uisa),   register_names_uisa },
  { "rs6000", "IBM RS6000 (\"POWER\") architecture, user-level view",
    num_registers (register_names_rs6000), register_names_rs6000 },
  { "403", "IBM PowerPC 403",
    num_registers (register_names_403),   register_names_403 },
  { "403GC", "IBM PowerPC 403GC",
    num_registers (register_names_403GC), register_names_403GC },
  { "505", "Motorola PowerPC 505",
    num_registers (register_names_505),   register_names_505 },
  { "860", "Motorola PowerPC 860 or 850",
    num_registers (register_names_860),   register_names_860 },
  { "601", "Motorola PowerPC 601",
    num_registers (register_names_601),   register_names_601 },
  { "602", "Motorola PowerPC 602",
    num_registers (register_names_602),   register_names_602 },
  { "603", "Motorola/IBM PowerPC 603 or 603e",
    num_registers (register_names_603),   register_names_603 },
  { "604", "Motorola PowerPC 604 or 604e",
    num_registers (register_names_604),   register_names_604 },
  { "750", "Motorola/IBM PowerPC 750 or 750",
    num_registers (register_names_750),   register_names_750 },
  { 0, 0, 0, 0 }
d1793 1
a1793 1
  
d1795 1
a1795 1
    if (! strcmp (name, variants[i].name))
d1848 1
a1848 3
  int i;

  if (! arg || arg[0] == '\0')
d1858 1
a1858 1
			"`%s' is not a recognized PowerPC / RS6000 variant name.\n\n", arg);
d1874 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d83 1
a83 1
    /* We're in get_prev_frame */
d687 9
a695 12
      if (USE_GENERIC_DUMMY_FRAMES)
	{
	  generic_pop_dummy_frame ();
	  flush_cached_frames ();
	  return;
	}
      else
	{
	  if (dummy_frame_count) 
	    pop_dummy_frame ();
	  return;
	}
d821 4
a824 5
  if (!USE_GENERIC_DUMMY_FRAMES)
    {
      if (dummy_frame_count <= 0)
	printf_unfiltered ("FATAL ERROR -push_arguments()! frame not found!!\n");
    }
d902 9
a910 13
  if (USE_GENERIC_DUMMY_FRAMES)
    {
      saved_sp = read_sp ();
    }
  else
    {
      /* location for 8 parameters are always reserved. */
      sp -= 4 * 8;

      /* another six words for back chain, TOC register, link register, etc. */
      sp -= 24;
    }

d980 8
a987 9
  if (!USE_GENERIC_DUMMY_FRAMES)
    {
      /* we want to copy 24 bytes of target's frame to dummy's frame,
	 then set back chain to point to new frame. */
      
      saved_sp = dummy_frame_addr [dummy_frame_count - 1];
      read_memory (saved_sp, tmp_buffer, 24);
      write_memory (sp, tmp_buffer, 24);
    }
d1149 4
a1152 5
  if (USE_GENERIC_DUMMY_FRAMES)
    {
      if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
	return generic_read_register_dummy(fi->pc, fi->frame, PC_REGNUM);
    }
d1331 4
a1334 5
  if (USE_GENERIC_DUMMY_FRAMES)
    {
      if (PC_IN_CALL_DUMMY (thisframe->pc, thisframe->frame, thisframe->frame))
	return thisframe->frame;	/* dummy frame same as caller's frame */
    }
d1351 3
a1353 10
  if (USE_GENERIC_DUMMY_FRAMES)
    {
      CORE_ADDR fpp, lr;

      lr = read_register (LR_REGNUM);
      if (lr == entry_point_address ())
	if (fp != 0 && (fpp = read_memory_integer (fp, 4)) != 0)
	  if (PC_IN_CALL_DUMMY (lr, fpp, fpp))
	    return fpp;
    }
d1355 7
d1393 19
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@a60 10
CORE_ADDR
rs6000_skip_prologue (pc)
     CORE_ADDR pc;
{
  struct rs6000_framedata frame;
  pc = skip_prologue (pc, &frame);
  return pc;
}


@


1.1.1.4
log
@import gdb-1999-05-25 snapshot
@
text
@d815 1
a815 1
rs6000_push_arguments (nargs, args, sp, struct_return, struct_addr)
@


1.1.1.5
log
@import gdb-1999-06-07 snapshot
@
text
@d1642 1
a1642 1
  { "750", "Motorola/IBM PowerPC 750 or 740",
@


1.1.1.6
log
@import gdb-1999-06-14 snapshot
@
text
@d402 1
a402 1
      } else if ((op & 0xfc000001) == 0x48000001) {	/* bl foo, 
@


1.1.1.7
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d36 6
a41 8
static struct sstep_breaks
  {
    /* Address, or 0 if this is not in use.  */
    CORE_ADDR address;
    /* Shadow contents.  */
    char data[4];
  }
stepBreaks[2];
d51 2
a52 2
     static CORE_ADDR branch_dest PARAMS ((int opcode, int instr, CORE_ADDR pc,
					   CORE_ADDR safety));
d54 2
a55 2
     static void frame_get_saved_regs PARAMS ((struct frame_info * fi,
					 struct rs6000_framedata * fdatap));
d57 1
a57 1
     static void pop_dummy_frame PARAMS ((void));
d59 1
a59 1
     static CORE_ADDR frame_initial_stack_address PARAMS ((struct frame_info *));
d80 1
a80 1
  CORE_ADDR initial_sp;		/* initial stack pointer. */
d88 1
a88 1
  fi->extra_info = (struct frame_extra_info *)
d135 16
a150 20
  switch (opcode)
    {
    case 18:
      immediate = ((instr & ~3) << 6) >> 6;	/* br unconditional */
      if (absolute)
	dest = immediate;
      else
	dest = pc + immediate;
      break;

    case 16:
      immediate = ((instr & ~3) << 16) >> 16;	/* br conditional */
      if (absolute)
	dest = immediate;
      else
	dest = pc + immediate;
      break;

    case 19:
      ext_op = (instr >> 1) & 0x3ff;
d152 2
a153 22
      if (ext_op == 16)		/* br conditional register */
	{
	  dest = read_register (LR_REGNUM) & ~3;

	  /* If we are about to return from a signal handler, dest is
	     something like 0x3c90.  The current frame is a signal handler
	     caller frame, upon completion of the sigreturn system call
	     execution will return to the saved PC in the frame.  */
	  if (dest < TEXT_SEGMENT_BASE)
	    {
	      struct frame_info *fi;

	      fi = get_current_frame ();
	      if (fi != NULL)
		dest = read_memory_integer (fi->frame + SIG_FRAME_PC_OFFSET,
					    4);
	    }
	}

      else if (ext_op == 528)	/* br cond to count reg */
	{
	  dest = read_register (CTR_REGNUM) & ~3;
d155 2
a156 4
	  /* If we are about to execute a system call, dest is something
	     like 0x22fc or 0x3b00.  Upon completion the system call
	     will return to the address in the link register.  */
	  if (dest < TEXT_SEGMENT_BASE)
a157 4
	}
      else
	return -1;
      break;
d159 30
a188 3
    default:
      return -1;
    }
d230 1
a230 2
  if (insert_breakpoints_p)
    {
d232 1
a232 1
      loc = read_pc ();
d234 1
a234 1
      insn = read_memory_integer (loc, 4);
d236 3
a238 3
      breaks[0] = loc + INSNLEN (insn);
      opcode = insn >> 26;
      breaks[1] = branch_dest (opcode, insn, loc, breaks[0]);
d240 3
a242 3
      /* Don't put two breakpoints on the same address. */
      if (breaks[1] == breaks[0])
	breaks[1] = -1;
d244 1
a244 1
      stepBreaks[1].address = 0;
d246 1
a246 2
      for (ii = 0; ii < 2; ++ii)
	{
d248 3
a250 3
	  /* ignore invalid breakpoint. */
	  if (breaks[ii] == -1)
	    continue;
d252 1
a252 1
	  read_memory (breaks[ii], stepBreaks[ii].data, 4);
d254 3
a256 3
	  write_memory (breaks[ii], breakp, 4);
	  stepBreaks[ii].address = breaks[ii];
	}
d258 1
a258 3
    }
  else
    {
d260 5
a264 5
      /* remove step breakpoints. */
      for (ii = 0; ii < 2; ++ii)
	if (stepBreaks[ii].address != 0)
	  write_memory
	    (stepBreaks[ii].address, stepBreaks[ii].data, 4);
d266 1
a266 1
    }
d268 1
a268 1
  /* What errors?  {read,write}_memory call error().  */
d276 13
a288 13
   - frameless is TRUE, if function does not have a frame.
   - nosavedpc is TRUE, if function does not save %pc value in its frame.
   - offset is the initial size of this stack frame --- the amount by
   which we decrement the sp to allocate the frame.
   - saved_gpr is the number of the first saved gpr.
   - saved_fpr is the number of the first saved fpr.
   - alloca_reg is the number of the register used for alloca() handling.
   Otherwise -1.
   - gpr_offset is the offset of the first saved gpr from the previous frame.
   - fpr_offset is the offset of the first saved fpr from the previous frame.
   - lr_offset is the offset of the saved lr
   - cr_offset is the offset of the saved cr
 */
d300 1
a300 1
     struct rs6000_framedata *fdata;
d330 13
a342 5
      if ((op & 0xfc1fffff) == 0x7c0802a6)
	{			/* mflr Rx */
	  lr_reg = (op & 0x03e00000) | 0x90010000;
	  continue;

d344 1
a344 4
      else if ((op & 0xfc1fffff) == 0x7c000026)
	{			/* mfcr Rx */
	  cr_reg = (op & 0x03e00000) | 0x90010000;
	  continue;
d346 2
a347 14
	}
      else if ((op & 0xfc1f0000) == 0xd8010000)
	{			/* stfd Rx,NUM(r1) */
	  reg = GET_SRC_REG (op);
	  if (fdata->saved_fpr == -1 || fdata->saved_fpr > reg)
	    {
	      fdata->saved_fpr = reg;
	      fdata->fpr_offset = SIGNED_SHORT (op) + offset;
	    }
	  continue;

	}
      else if (((op & 0xfc1f0000) == 0xbc010000) ||	/* stm Rx, NUM(r1) */
	       ((op & 0xfc1f0000) == 0x90010000 &&	/* st rx,NUM(r1), 
d349 1
a349 2
		(op & 0x03e00000) >= 0x01a00000))
	{
d351 35
a385 7
	  reg = GET_SRC_REG (op);
	  if (fdata->saved_gpr == -1 || fdata->saved_gpr > reg)
	    {
	      fdata->saved_gpr = reg;
	      fdata->gpr_offset = SIGNED_SHORT (op) + offset;
	    }
	  continue;
d387 2
a388 7
	}
      else if ((op & 0xffff0000) == 0x3c000000)
	{			/* addis 0,0,NUM, used
				   for >= 32k frames */
	  fdata->offset = (op & 0x0000ffff) << 16;
	  fdata->frameless = 0;
	  continue;
d390 3
a392 38
	}
      else if ((op & 0xffff0000) == 0x60000000)
	{			/* ori 0,0,NUM, 2nd ha
				   lf of >= 32k frames */
	  fdata->offset |= (op & 0x0000ffff);
	  fdata->frameless = 0;
	  continue;

	}
      else if ((op & 0xffff0000) == lr_reg)
	{			/* st Rx,NUM(r1) 
				   where Rx == lr */
	  fdata->lr_offset = SIGNED_SHORT (op) + offset;
	  fdata->nosavedpc = 0;
	  lr_reg = 0;
	  continue;

	}
      else if ((op & 0xffff0000) == cr_reg)
	{			/* st Rx,NUM(r1) 
				   where Rx == cr */
	  fdata->cr_offset = SIGNED_SHORT (op) + offset;
	  cr_reg = 0;
	  continue;

	}
      else if (op == 0x48000005)
	{			/* bl .+4 used in 
				   -mrelocatable */
	  continue;

	}
      else if (op == 0x48000004)
	{			/* b .+4 (xlc) */
	  break;

	}
      else if (((op & 0xffff0000) == 0x801e0000 ||	/* lwz 0,NUM(r30), used
d394 2
a395 5
		op == 0x7fc0f214) &&	/* add r30,r0,r30, used
					   in V.4 -mrelocatable */
	       lr_reg == 0x901e0000)
	{
	  continue;
d397 1
a397 2
	}
      else if ((op & 0xffff0000) == 0x3fc00000 ||	/* addis 30,0,foo@@ha, used
d399 2
a400 3
	       (op & 0xffff0000) == 0x3bde0000)
	{			/* addi 30,30,foo@@l */
	  continue;
d402 2
a403 22
	}
      else if ((op & 0xfc000001) == 0x48000001)
	{			/* bl foo, 
				   to save fprs??? */

	  fdata->frameless = 0;
	  /* Don't skip over the subroutine call if it is not within the first
	     three instructions of the prologue.  */
	  if ((pc - orig_pc) > 8)
	    break;

	  op = read_memory_integer (pc + 4, 4);

	  /* At this point, make sure this is not a trampoline function
	     (a function that simply calls another functions, and nothing else).
	     If the next is not a nop, this branch was part of the function
	     prologue. */

	  if (op == 0x4def7b82 || op == 0)	/* crorc 15, 15, 15 */
	    break;		/* don't skip over 
				   this branch */
	  continue;
d405 5
a409 50
	  /* update stack pointer */
	}
      else if ((op & 0xffff0000) == 0x94210000)
	{			/* stu r1,NUM(r1) */
	  fdata->frameless = 0;
	  fdata->offset = SIGNED_SHORT (op);
	  offset = fdata->offset;
	  continue;

	}
      else if (op == 0x7c21016e)
	{			/* stwux 1,1,0 */
	  fdata->frameless = 0;
	  offset = fdata->offset;
	  continue;

	  /* Load up minimal toc pointer */
	}
      else if ((op >> 22) == 0x20f
	       && !minimal_toc_loaded)
	{			/* l r31,... or l r30,... */
	  minimal_toc_loaded = 1;
	  continue;

	  /* store parameters in stack */
	}
      else if ((op & 0xfc1f0000) == 0x90010000 ||	/* st rx,NUM(r1) */
	       (op & 0xfc1f0000) == 0xd8010000 ||	/* stfd Rx,NUM(r1) */
	       (op & 0xfc1f0000) == 0xfc010000)
	{			/* frsp, fp?,NUM(r1) */
	  continue;

	  /* store parameters in stack via frame pointer */
	}
      else if (framep &&
	       ((op & 0xfc1f0000) == 0x901f0000 ||	/* st rx,NUM(r1) */
		(op & 0xfc1f0000) == 0xd81f0000 ||	/* stfd Rx,NUM(r1) */
		(op & 0xfc1f0000) == 0xfc1f0000))
	{			/* frsp, fp?,NUM(r1) */
	  continue;

	  /* Set up frame pointer */
	}
      else if (op == 0x603f0000	/* oril r31, r1, 0x0 */
	       || op == 0x7c3f0b78)
	{			/* mr r31, r1 */
	  fdata->frameless = 0;
	  framep = 1;
	  fdata->alloca_reg = 31;
	  continue;
d411 1
a411 8
	  /* Another way to set up the frame pointer.  */
	}
      else if ((op & 0xfc1fffff) == 0x38010000)
	{			/* addi rX, r1, 0x0 */
	  fdata->frameless = 0;
	  framep = 1;
	  fdata->alloca_reg = (op & ~0x38010000) >> 21;
	  continue;
d413 59
a471 5
	}
      else
	{
	  break;
	}
d484 6
d491 2
d494 3
a496 14
  if ((op & 0xfc000001) == 0x48000001)
    {				/* bl foo, an initializer function? */
      op = read_memory_integer (pc + 4, 4);

      if (op == 0x4def7b82)
	{			/* cror 0xf, 0xf, 0xf (nop) */

	  /* check and see if we are in main. If so, skip over this initializer
	     function as well. */

	  tmp = find_pc_misc_function (pc);
	  if (tmp >= 0 && STREQ (misc_function_vector[tmp].name, "main"))
	    return pc + 8;
	}
d498 1
d500 2
a501 2

  fdata->offset = -fdata->offset;
d513 6
a518 6
   32 gpr's     - 128 bytes
   32 fpr's     - 256   "
   7  the rest  - 28    "
   and 24 extra bytes for the callee's link area. The last 24 bytes
   for the link area might not be necessary, since it will be taken
   care of by push_arguments(). */
d535 1
a535 1

d548 1
a548 1

d557 12
a568 13
  if (dummy_frame_count >= dummy_frame_size)
    {
      dummy_frame_size += DUMMY_FRAME_ADDR_SIZE;
      if (dummy_frame_addr)
	dummy_frame_addr = (CORE_ADDR *) xrealloc
	  (dummy_frame_addr, sizeof (CORE_ADDR) * (dummy_frame_size));
      else
	dummy_frame_addr = (CORE_ADDR *)
	  xmalloc (sizeof (CORE_ADDR) * (dummy_frame_size));
    }

  sp = read_register (SP_REGNUM);
  pc = read_register (PC_REGNUM);
d573 1
a573 1
  dummy_frame_addr[dummy_frame_count++] = sp;
d585 1
a585 1
  write_register (SP_REGNUM, sp - DUMMY_FRAME_SIZE);
d594 1
a594 1
		pc_targ, 4);
d600 1
a600 1
    write_memory (sp - 8 - (ii * 8), &registers[REGISTER_BYTE (31 - ii + FP0_REGNUM)], 8);
d603 2
a604 2
  for (ii = 1; ii <= 32; ++ii)
    write_memory (sp - 256 - (ii * 4), &registers[REGISTER_BYTE (32 - ii)], 4);
d609 4
a612 5
  for (ii = 1; ii <= (LAST_UISA_SP_REGNUM - FIRST_UISA_SP_REGNUM + 1); ++ii)
    {
      write_memory (sp - 384 - (ii * 4),
		    &registers[REGISTER_BYTE (FPLAST_REGNUM + ii)], 4);
    }
d616 1
a616 1
  write_memory (sp - DUMMY_FRAME_SIZE, sp_targ, 4);
d620 1
a620 1
  write_memory (sp + 8, pc_targ, 4);
d637 5
a641 5
   FIXME:  This whole concept is broken.  You should be able to detect
   a dummy stack frame *on the user's stack itself*.  When you do,
   then you know the format of that stack frame -- including its
   saved SP register!  There should *not* be a separate stack in the
   GDB process that keeps track of these dummy frames!  -- gnu@@cygnus.com Aug92
d643 1
a643 1

d649 1
a649 1
  sp = dummy_frame_addr[--dummy_frame_count];
d653 1
a653 1
    read_memory (sp - (ii * 8), &registers[REGISTER_BYTE (32 - ii + FP0_REGNUM)], 8);
d656 3
a658 4
  for (ii = 1; ii <= 32; ++ii)
    {
      read_memory (sp - 256 - (ii * 4), &registers[REGISTER_BYTE (32 - ii)], 4);
    }
d661 3
a663 3
  for (ii = 1; ii <= (LAST_UISA_SP_REGNUM - FIRST_UISA_SP_REGNUM + 1); ++ii)
    read_memory (sp - 384 - (ii * 4),
		 &registers[REGISTER_BYTE (FPLAST_REGNUM + ii)], 4);
d665 2
a666 2
  read_memory (sp - (DUMMY_FRAME_SIZE - 8),
	       &registers[REGISTER_BYTE (PC_REGNUM)], 4);
d672 1
a672 1
  memcpy (&registers[REGISTER_BYTE (FP_REGNUM)], (char *) &sp, sizeof (int));
d687 1
a687 1
  CORE_ADDR pc, lr, sp, prev_sp;	/* %pc, %lr, %sp */
d705 1
a705 1
	  if (dummy_frame_count)
d738 4
a741 5
      for (ii = fdata.saved_gpr; ii <= 31; ++ii)
	{
	  read_memory (addr, &registers[REGISTER_BYTE (ii)], 4);
	  addr += 4;
	}
d747 4
a750 5
      for (ii = fdata.saved_fpr; ii <= 31; ++ii)
	{
	  read_memory (addr, &registers[REGISTER_BYTE (ii + FP0_REGNUM)], 8);
	  addr += 8;
	}
d782 1
a782 1
      ii = *(int *) ((char *) dummyname + TOC_ADDR_OFFSET);
d784 1
a784 1
      *(int *) ((char *) dummyname + TOC_ADDR_OFFSET) = ii;
d786 1
a786 1
      ii = *(int *) ((char *) dummyname + TOC_ADDR_OFFSET + 4);
d788 1
a788 1
      *(int *) ((char *) dummyname + TOC_ADDR_OFFSET + 4) = ii;
d792 1
a792 1
  ii = *(int *) ((char *) dummyname + TARGET_ADDR_OFFSET);
d794 1
a794 1
  *(int *) ((char *) dummyname + TARGET_ADDR_OFFSET) = ii;
d796 1
a796 1
  ii = *(int *) ((char *) dummyname + TARGET_ADDR_OFFSET + 4);
d798 1
a798 1
  *(int *) ((char *) dummyname + TARGET_ADDR_OFFSET + 4) = ii;
d824 4
a827 4
  int argno;			/* current argument number */
  int argbytes;			/* current argument byte */
  char tmp_buffer[50];
  int f_argno = 0;		/* current floating point argno */
d848 1
a848 1
  ii = struct_return ? 1 : 0;
d851 1
a851 41
   effectively indirect call... gcc does...

   return_val example( float, int);

   eabi: 
   float in fp0, int in r3
   offset of stack on overflow 8/16
   for varargs, must go by type.
   power open:
   float in r3&r4, int in r5
   offset of stack on overflow different 
   both: 
   return in r3 or f0.  If no float, must study how gcc emulates floats;
   pay attention to arg promotion.  
   User may have to cast\args to handle promotion correctly 
   since gdb won't know if prototype supplied or not.
 */

  for (argno = 0, argbytes = 0; argno < nargs && ii < 8; ++ii)
    {

      arg = args[argno];
      type = check_typedef (VALUE_TYPE (arg));
      len = TYPE_LENGTH (type);

      if (TYPE_CODE (type) == TYPE_CODE_FLT)
	{

	  /* floating point arguments are passed in fpr's, as well as gpr's.
	     There are 13 fpr's reserved for passing parameters. At this point
	     there is no way we would run out of them. */

	  if (len > 8)
	    printf_unfiltered (
				"Fatal Error: a floating point parameter #%d with a size > 8 is found!\n", argno);

	  memcpy (&registers[REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
		  VALUE_CONTENTS (arg),
		  len);
	  ++f_argno;
	}
d853 1
a853 2
      if (len > 4)
	{
d855 55
a909 21
	  /* Argument takes more than one register. */
	  while (argbytes < len)
	    {
	      memset (&registers[REGISTER_BYTE (ii + 3)], 0, sizeof (int));
	      memcpy (&registers[REGISTER_BYTE (ii + 3)],
		      ((char *) VALUE_CONTENTS (arg)) + argbytes,
		      (len - argbytes) > 4 ? 4 : len - argbytes);
	      ++ii, argbytes += 4;

	      if (ii >= 8)
		goto ran_out_of_registers_for_arguments;
	    }
	  argbytes = 0;
	  --ii;
	}
      else
	{			/* Argument can fit in one register. No problem. */
	  memset (&registers[REGISTER_BYTE (ii + 3)], 0, sizeof (int));
	  memcpy (&registers[REGISTER_BYTE (ii + 3)], VALUE_CONTENTS (arg), len);
	}
      ++argno;
d911 2
d932 18
a949 3
  if ((argno < nargs) || argbytes)
    {
      int space = 0, jj;
d951 4
a954 7
      if (argbytes)
	{
	  space += ((len - argbytes + 3) & -4);
	  jj = argno + 1;
	}
      else
	jj = argno;
d956 1
a956 5
      for (; jj < nargs; ++jj)
	{
	  value_ptr val = args[jj];
	  space += ((TYPE_LENGTH (VALUE_TYPE (val))) + 3) & -4;
	}
d958 2
a959 3
      /* add location required for the rest of the parameters */
      space = (space + 7) & -8;
      sp -= space;
d961 7
a967 4
      /* This is another instance we need to be concerned about securing our
         stack space. If we write anything underneath %sp (r1), we might conflict
         with the kernel who thinks he is free to use this area. So, update %sp
         first before doing anything else. */
d969 2
a970 1
      write_register (SP_REGNUM, sp);
d972 3
a974 2
      /* if the last argument copied into the registers didn't fit there 
         completely, push the rest of it into stack. */
a975 8
      if (argbytes)
	{
	  write_memory (sp + 24 + (ii * 4),
			((char *) VALUE_CONTENTS (arg)) + argbytes,
			len - argbytes);
	  ++argno;
	  ii += ((len - argbytes + 3) & -4) / 4;
	}
d977 2
a978 3
      /* push the rest of the arguments into stack. */
      for (; argno < nargs; ++argno)
	{
d980 9
a988 18
	  arg = args[argno];
	  type = check_typedef (VALUE_TYPE (arg));
	  len = TYPE_LENGTH (type);


	  /* float types should be passed in fpr's, as well as in the stack. */
	  if (TYPE_CODE (type) == TYPE_CODE_FLT && f_argno < 13)
	    {

	      if (len > 8)
		printf_unfiltered (
				    "Fatal Error: a floating point parameter #%d with a size > 8 is found!\n", argno);

	      memcpy (&registers[REGISTER_BYTE (FP0_REGNUM + 1 + f_argno)],
		      VALUE_CONTENTS (arg),
		      len);
	      ++f_argno;
	    }
d990 2
a991 3
	  write_memory (sp + 24 + (ii * 4), (char *) VALUE_CONTENTS (arg), len);
	  ii += ((len + 3) & -4) / 4;
	}
d993 1
d1001 3
a1003 3
         then set back chain to point to new frame. */

      saved_sp = dummy_frame_addr[dummy_frame_count - 1];
d1020 1
a1020 1
CORE_ADDR
d1042 1
a1042 2
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT)
    {
d1044 8
a1051 26
      double dd;
      float ff;
      /* floats and doubles are returned in fpr1. fpr's have a size of 8 bytes.
         We need to truncate the return value into float size (4 byte) if
         necessary. */

      if (TYPE_LENGTH (valtype) > 4)	/* this is a double */
	memcpy (valbuf,
		&regbuf[REGISTER_BYTE (FP0_REGNUM + 1)],
		TYPE_LENGTH (valtype));
      else
	{			/* float */
	  memcpy (&dd, &regbuf[REGISTER_BYTE (FP0_REGNUM + 1)], 8);
	  ff = (float) dd;
	  memcpy (valbuf, &ff, sizeof (float));
	}
    }
  else
    {
      /* return value is copied starting from r3. */
      if (TARGET_BYTE_ORDER == BIG_ENDIAN
	  && TYPE_LENGTH (valtype) < REGISTER_RAW_SIZE (3))
	offset = REGISTER_RAW_SIZE (3) - TYPE_LENGTH (valtype);

      memcpy (valbuf,
	      regbuf + REGISTER_BYTE (3) + offset,
d1053 4
d1058 11
d1095 9
a1103 10
  static unsigned trampoline_code[] =
  {
    0x800b0000,			/*     l   r0,0x0(r11)  */
    0x90410014,			/*    st   r2,0x14(r1)  */
    0x7c0903a6,			/* mtctr   r0           */
    0x804b0004,			/*     l   r2,0x4(r11)  */
    0x816b0008,			/*     l  r11,0x8(r11)  */
    0x4e800420,			/*  bctr                */
    0x4e800020,			/*    br                */
    0
d1111 7
a1117 8
  for (ii = 0; trampoline_code[ii]; ++ii)
    {
      op = read_memory_integer (pc + (ii * 4), 4);
      if (op != trampoline_code[ii])
	return 0;
    }
  ii = read_register (11);	/* r11 holds destination addr   */
  pc = read_memory_integer (ii, 4);	/* (r11) value                  */
d1134 1
a1134 1

d1143 3
a1145 3
         function pointer, normally causing an immediate core dump of the
         inferior. Mark function as frameless, as the inferior has no chance
         of setting up a stack frame.  */
d1171 1
a1171 1
	return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
d1208 1
a1208 1
  CORE_ADDR frame_addr;
d1213 1
a1213 1

d1234 1
a1234 1

d1244 1
a1244 1
	  fi->saved_regs[FP0_REGNUM + i] = fpr_offset;
d1258 1
a1258 1
	  fi->saved_regs[i] = gpr_offset;
d1266 1
a1266 1
    fi->saved_regs[CR_REGNUM] = frame_addr + fdatap->cr_offset;
d1271 1
a1271 1
    fi->saved_regs[LR_REGNUM] = frame_addr + fdatap->lr_offset;
d1314 1
a1314 1
    return fi->extra_info->initial_sp = read_register (fdata.alloca_reg);
d1321 1
a1321 2
  for (callee_fi = fi->next; callee_fi; callee_fi = callee_fi->next)
    {
d1323 2
a1324 2
      if (!callee_fi->saved_regs)
	frame_get_saved_regs (callee_fi, NULL);
d1326 1
a1326 1
      /* this is the address in which alloca register is saved. */
d1328 5
a1332 6
      tmpaddr = callee_fi->saved_regs[fdata.alloca_reg];
      if (tmpaddr)
	{
	  fi->extra_info->initial_sp = read_memory_integer (tmpaddr, 4);
	  return fi->extra_info->initial_sp;
	}
d1334 3
a1336 3
      /* Go look into deeper levels of the frame chain to see if any one of
         the callees has saved alloca register. */
    }
d1357 1
a1357 1
  if (inside_entry_file (thisframe->pc) ||
d1414 1
a1415 1

d1432 2
a1433 2
   tblo srr2 srr3 dbsr dbcr iac1 iac2 dac1 dac2 dccr iccr pbl1
   pbu1 pbl2 pbu2
d1488 1
a1488 1
{
d1493 2
a1494 2
  /* 119 */ "icdbdr", "esr", "dear", "evpr", "cdbcr", "tsr", "tcr", "pit",
  /* 127 */ "tbhi", "tblo", "srr2", "srr3", "dbsr", "dbcr", "iac1", "iac2",
d1499 1
a1499 1
{
d1504 3
a1506 3
  /* 119 */ "icdbdr", "esr", "dear", "evpr", "cdbcr", "tsr", "tcr", "pit",
  /* 127 */ "tbhi", "tblo", "srr2", "srr3", "dbsr", "dbcr", "iac1", "iac2",
  /* 135 */ "dac1", "dac2", "dccr", "iccr", "pbl1", "pbu1", "pbl2", "pbu2",
d1511 1
a1511 1
{
d1520 1
a1520 1
{
d1525 7
a1531 7
  /* 119 */ "eie", "eid", "nri", "cmpa", "cmpb", "cmpc", "cmpd", "icr",
  /* 127 */ "der", "counta", "countb", "cmpe", "cmpf", "cmpg", "cmph",
  /* 134 */ "lctrl1", "lctrl2", "ictrl", "bar", "ic_cst", "ic_adr", "ic_dat",
  /* 141 */ "dc_cst", "dc_adr", "dc_dat", "dpdr", "dpir", "immr", "mi_ctr",
  /* 148 */ "mi_ap", "mi_epn", "mi_twc", "mi_rpn", "md_ctr", "m_casid",
  /* 154 */ "md_ap", "md_epn", "md_twb", "md_twc", "md_rpn", "m_tw",
  /* 160 */ "mi_dbcam", "mi_dbram0", "mi_dbram1", "md_dbcam", "md_dbram0",
d1539 1
a1539 1
{
d1544 1
a1544 1
  /* 119 */ "hid0", "hid1", "iabr", "dabr", "pir", "mq", "rtcu",
d1549 1
a1549 1
{
d1554 1
a1554 1
  /* 119 */ "hid0", "hid1", "iabr", "", "", "tcr", "ibr", "esassr", "sebr",
d1559 1
a1559 1
{
d1564 1
a1564 1
  /* 119 */ "hid0", "hid1", "iabr", "", "", "dmiss", "dcmp", "hash1",
d1569 1
a1569 1
{
d1574 1
a1574 1
  /* 119 */ "hid0", "hid1", "iabr", "dabr", "pir", "mmcr0", "pmc1", "pmc2",
d1579 1
a1579 1
{
d1584 3
a1586 3
  /* 119 */ "hid0", "hid1", "iabr", "dabr", "", "ummcr0", "upmc1", "upmc2",
  /* 127 */ "usia", "ummcr1", "upmc3", "upmc4", "mmcr0", "pmc1", "pmc2",
  /* 134 */ "sia", "mmcr1", "pmc3", "pmc4", "l2cr", "ictc", "thrm1", "thrm2",
d1593 12
a1604 12
  {
    /* Name of this variant.  */
    char *name;

    /* English description of the variant.  */
    char *description;

    /* Table of register names; registers[R] is the name of the register
       number R.  */
    int num_registers;
    char **registers;
  };
d1620 1
a1620 1
  variants[] =
d1622 23
a1644 23
  {"ppc-uisa", "PowerPC UISA - a PPC processor as viewed by user-level code",
   num_registers (register_names_uisa), register_names_uisa},
  {"rs6000", "IBM RS6000 (\"POWER\") architecture, user-level view",
   num_registers (register_names_rs6000), register_names_rs6000},
  {"403", "IBM PowerPC 403",
   num_registers (register_names_403), register_names_403},
  {"403GC", "IBM PowerPC 403GC",
   num_registers (register_names_403GC), register_names_403GC},
  {"505", "Motorola PowerPC 505",
   num_registers (register_names_505), register_names_505},
  {"860", "Motorola PowerPC 860 or 850",
   num_registers (register_names_860), register_names_860},
  {"601", "Motorola PowerPC 601",
   num_registers (register_names_601), register_names_601},
  {"602", "Motorola PowerPC 602",
   num_registers (register_names_602), register_names_602},
  {"603", "Motorola/IBM PowerPC 603 or 603e",
   num_registers (register_names_603), register_names_603},
  {"604", "Motorola PowerPC 604 or 604e",
   num_registers (register_names_604), register_names_604},
  {"750", "Motorola/IBM PowerPC 750 or 740",
   num_registers (register_names_750), register_names_750},
  {0, 0, 0, 0}
d1675 1
a1675 1

d1677 1
a1677 1
    if (!strcmp (name, variants[i].name))
d1732 1
a1732 1
  if (!arg || arg[0] == '\0')
d1742 1
a1742 1
	"`%s' is not a recognized PowerPC / RS6000 variant name.\n\n", arg);
a1754 1

d1757 1
@


1.1.1.8
log
@import gdb-1999-09-08 snapshot
@
text
@d1284 1
d1809 2
@


1.1.1.9
log
@import gdb-1999-10-04 snapshot
@
text
@d1831 1
a1832 2


@
