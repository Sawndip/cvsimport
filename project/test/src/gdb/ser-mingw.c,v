head	1.33;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.33
	gdb_7_6-2013-04-26-release:1.33
	gdb_7_6-branch:1.33.0.2
	gdb_7_6-2013-03-12-branchpoint:1.33
	gdb_7_5_1-2012-11-29-release:1.32
	gdb_7_5-2012-08-17-release:1.32
	gdb_7_5-branch:1.32.0.2
	gdb_7_5-2012-07-18-branchpoint:1.32
	gdb_7_4_1-2012-04-26-release:1.30.4.1
	gdb_7_4-2012-01-24-release:1.30.4.1
	gdb_7_4-branch:1.30.0.4
	gdb_7_4-2011-12-13-branchpoint:1.30
	gdb_7_3_1-2011-09-04-release:1.30
	gdb_7_3-2011-07-26-release:1.30
	gdb_7_3-branch:1.30.0.2
	gdb_7_3-2011-04-01-branchpoint:1.30
	gdb_7_2-2010-09-02-release:1.21
	gdb_7_2-branch:1.21.0.2
	gdb_7_2-2010-07-07-branchpoint:1.21
	gdb_7_1-2010-03-18-release:1.20
	gdb_7_1-branch:1.20.0.2
	gdb_7_1-2010-02-18-branchpoint:1.20
	gdb_7_0_1-2009-12-22-release:1.19
	gdb_7_0-2009-10-06-release:1.19
	gdb_7_0-branch:1.19.0.4
	gdb_7_0-2009-09-16-branchpoint:1.19
	arc-sim-20090309:1.12
	msnyder-checkpoint-072509-branch:1.19.0.2
	msnyder-checkpoint-072509-branchpoint:1.19
	arc-insight_6_8-branch:1.12.0.6
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.4
	insight_6_8-branchpoint:1.12
	reverse-20081226-branch:1.16.0.4
	reverse-20081226-branchpoint:1.16
	multiprocess-20081120-branch:1.16.0.2
	multiprocess-20081120-branchpoint:1.16
	reverse-20080930-branch:1.14.0.2
	reverse-20080930-branchpoint:1.14
	reverse-20080717-branch:1.13.0.4
	reverse-20080717-branchpoint:1.13
	msnyder-reverse-20080609-branch:1.13.0.2
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.8.0.2
	drow-reverse-20070409-branchpoint:1.8
	gdb_6_8-2008-03-27-release:1.12
	gdb_6_8-branch:1.12.0.2
	gdb_6_8-2008-02-26-branchpoint:1.12
	gdb_6_7_1-2007-10-29-release:1.10
	gdb_6_7-2007-10-10-release:1.10
	gdb_6_7-branch:1.10.0.2
	gdb_6_7-2007-09-07-branchpoint:1.10
	insight_6_6-20070208-release:1.4
	gdb_6_6-2006-12-18-release:1.4
	gdb_6_6-branch:1.4.0.2
	gdb_6_6-2006-11-15-branchpoint:1.4
	insight_6_5-20061003-release:1.3
	gdb-csl-symbian-6_4_50_20060226-12:1.1.2.3
	nickrob-async-20060828-mergepoint:1.3
	gdb-csl-symbian-6_4_50_20060226-11:1.1.2.3
	gdb-csl-sourcerygxx-4_1-17:1.1.2.3
	gdb-csl-20060226-branch-local-2:1.1.2.3
	gdb-csl-sourcerygxx-4_1-14:1.1.2.3
	gdb-csl-sourcerygxx-4_1-13:1.1.2.3
	gdb-csl-sourcerygxx-4_1-12:1.1.2.3
	gdb-csl-sourcerygxx-3_4_4-21:1.1.2.3
	gdb_6_5-20060621-release:1.3
	gdb-csl-sourcerygxx-4_1-9:1.1.2.3
	gdb-csl-sourcerygxx-4_1-8:1.1.2.3
	gdb-csl-sourcerygxx-4_1-7:1.1.2.3
	gdb-csl-arm-2006q1-6:1.1.2.3
	gdb-csl-sourcerygxx-4_1-6:1.1.2.3
	gdb-csl-symbian-6_4_50_20060226-10:1.1.2.3
	gdb-csl-symbian-6_4_50_20060226-9:1.1.2.3
	gdb-csl-symbian-6_4_50_20060226-8:1.1.2.3
	gdb-csl-coldfire-4_1-11:1.1.2.3
	gdb-csl-sourcerygxx-3_4_4-19:1.1.2.3
	gdb-csl-coldfire-4_1-10:1.1.2.3
	gdb_6_5-branch:1.3.0.6
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-5:1.1.2.3
	nickrob-async-20060513-branch:1.3.0.4
	nickrob-async-20060513-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-4:1.1.2.3
	msnyder-reverse-20060502-branch:1.3.0.2
	msnyder-reverse-20060502-branchpoint:1.3
	gdb-csl-morpho-4_1-4:1.1.2.3
	gdb-csl-sourcerygxx-3_4_4-17:1.1.2.3
	readline_5_1-import-branch:1.1.0.8
	readline_5_1-import-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1.2.3
	gdb-csl-symbian-20060226-branch:1.1.2.3.0.2
	gdb-csl-symbian-20060226-branchpoint:1.1.2.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1.2.3
	msnyder-reverse-20060331-branch:1.1.0.6
	msnyder-reverse-20060331-branchpoint:1.1
	gdb-csl-available-20060303-branch:1.1.0.4
	gdb-csl-available-20060303-branchpoint:1.1
	gdb-csl-20060226-branch:1.1.0.2
	gdb-csl-20060226-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.33
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2012.03.02.12.56.50;	author qiyao;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2011.03.16.17.59.03;	author muller;	state Exp;
branches
	1.30.4.1;
next	1.29;

1.29
date	2011.03.04.19.23.42;	author uweigand;	state Exp;
branches;
next	1.28;

1.28
date	2011.02.21.13.40.31;	author muller;	state Exp;
branches;
next	1.27;

1.27
date	2011.02.21.11.47.12;	author muller;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.11.21.53.23;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2011.01.10.17.14.13;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.01.15.33.14;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.20.18.49.20;	author palves;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.14.20.21.09;	author ktietz;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.09.10.32.34;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.09.01.14.26;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.03.16.36.10;	author ppluzhnikov;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.03.23.54.19;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.28.17.30.45;	author carlos;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.02.16.09.53;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.23.18.08.37;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.19.13.04.30;	author guitton;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.08.15.20.07;	author vprus;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.08.16.24.11;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.30.09.12.43;	author vprus;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.10.14.23.11;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.25.18.02.13;	author jimb;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.24.21.00.13;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.10.22.01.43;	author drow;	state Exp;
branches
	1.1.2.1;
next	;

1.30.4.1
date	2012.01.06.04.43.29;	author brobecke;	state Exp;
branches;
next	;

1.1.2.1
date	2006.03.17.20.36.12;	author jimb;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.03.20.04.05.24;	author mmitchel;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.03.22.01.22.28;	author mmitchel;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Serial interface for local (hardwired) serial ports on Windows systems

   Copyright (C) 2006-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "serial.h"
#include "ser-base.h"
#include "ser-tcp.h"

#include <windows.h>
#include <conio.h>

#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>

#include "gdb_assert.h"
#include "gdb_string.h"

#include "command.h"

void _initialize_ser_windows (void);

struct ser_windows_state
{
  int in_progress;
  OVERLAPPED ov;
  DWORD lastCommMask;
  HANDLE except_event;
};

/* CancelIo is not available for Windows 95 OS, so we need to use
   LoadLibrary/GetProcAddress to avoid a startup failure.  */
#define CancelIo dyn_CancelIo
static BOOL WINAPI (*CancelIo) (HANDLE);

/* Open up a real live device for serial I/O.  */

static int
ser_windows_open (struct serial *scb, const char *name)
{
  HANDLE h;
  struct ser_windows_state *state;
  COMMTIMEOUTS timeouts;

  h = CreateFile (name, GENERIC_READ | GENERIC_WRITE, 0, NULL,
		  OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
  if (h == INVALID_HANDLE_VALUE)
    {
      errno = ENOENT;
      return -1;
    }

  scb->fd = _open_osfhandle ((intptr_t) h, O_RDWR);
  if (scb->fd < 0)
    {
      errno = ENOENT;
      return -1;
    }

  if (!SetCommMask (h, EV_RXCHAR))
    {
      errno = EINVAL;
      return -1;
    }

  timeouts.ReadIntervalTimeout = MAXDWORD;
  timeouts.ReadTotalTimeoutConstant = 0;
  timeouts.ReadTotalTimeoutMultiplier = 0;
  timeouts.WriteTotalTimeoutConstant = 0;
  timeouts.WriteTotalTimeoutMultiplier = 0;
  if (!SetCommTimeouts (h, &timeouts))
    {
      errno = EINVAL;
      return -1;
    }

  state = xmalloc (sizeof (struct ser_windows_state));
  memset (state, 0, sizeof (struct ser_windows_state));
  scb->state = state;

  /* Create a manual reset event to watch the input buffer.  */
  state->ov.hEvent = CreateEvent (0, TRUE, FALSE, 0);

  /* Create a (currently unused) handle to record exceptions.  */
  state->except_event = CreateEvent (0, TRUE, FALSE, 0);

  return 0;
}

/* Wait for the output to drain away, as opposed to flushing (discarding)
   it.  */

static int
ser_windows_drain_output (struct serial *scb)
{
  HANDLE h = (HANDLE) _get_osfhandle (scb->fd);

  return (FlushFileBuffers (h) != 0) ? 0 : -1;
}

static int
ser_windows_flush_output (struct serial *scb)
{
  HANDLE h = (HANDLE) _get_osfhandle (scb->fd);

  return (PurgeComm (h, PURGE_TXCLEAR) != 0) ? 0 : -1;
}

static int
ser_windows_flush_input (struct serial *scb)
{
  HANDLE h = (HANDLE) _get_osfhandle (scb->fd);

  return (PurgeComm (h, PURGE_RXCLEAR) != 0) ? 0 : -1;
}

static int
ser_windows_send_break (struct serial *scb)
{
  HANDLE h = (HANDLE) _get_osfhandle (scb->fd);

  if (SetCommBreak (h) == 0)
    return -1;

  /* Delay for 250 milliseconds.  */
  Sleep (250);

  if (ClearCommBreak (h))
    return -1;

  return 0;
}

static void
ser_windows_raw (struct serial *scb)
{
  HANDLE h = (HANDLE) _get_osfhandle (scb->fd);
  DCB state;

  if (GetCommState (h, &state) == 0)
    return;

  state.fParity = FALSE;
  state.fOutxCtsFlow = FALSE;
  state.fOutxDsrFlow = FALSE;
  state.fDtrControl = DTR_CONTROL_ENABLE;
  state.fDsrSensitivity = FALSE;
  state.fOutX = FALSE;
  state.fInX = FALSE;
  state.fNull = FALSE;
  state.fAbortOnError = FALSE;
  state.ByteSize = 8;
  state.Parity = NOPARITY;

  scb->current_timeout = 0;

  if (SetCommState (h, &state) == 0)
    warning (_("SetCommState failed"));
}

static int
ser_windows_setstopbits (struct serial *scb, int num)
{
  HANDLE h = (HANDLE) _get_osfhandle (scb->fd);
  DCB state;

  if (GetCommState (h, &state) == 0)
    return -1;

  switch (num)
    {
    case SERIAL_1_STOPBITS:
      state.StopBits = ONESTOPBIT;
      break;
    case SERIAL_1_AND_A_HALF_STOPBITS:
      state.StopBits = ONE5STOPBITS;
      break;
    case SERIAL_2_STOPBITS:
      state.StopBits = TWOSTOPBITS;
      break;
    default:
      return 1;
    }

  return (SetCommState (h, &state) != 0) ? 0 : -1;
}

static int
ser_windows_setbaudrate (struct serial *scb, int rate)
{
  HANDLE h = (HANDLE) _get_osfhandle (scb->fd);
  DCB state;

  if (GetCommState (h, &state) == 0)
    return -1;

  state.BaudRate = rate;

  return (SetCommState (h, &state) != 0) ? 0 : -1;
}

static void
ser_windows_close (struct serial *scb)
{
  struct ser_windows_state *state;

  /* Stop any pending selects.  On Windows 95 OS, CancelIo function does
     not exist.  In that case, it can be replaced by a call to CloseHandle,
     but this is not necessary here as we do close the Windows handle
     by calling close (scb->fd) below.  */
  if (CancelIo)
    CancelIo ((HANDLE) _get_osfhandle (scb->fd));
  state = scb->state;
  CloseHandle (state->ov.hEvent);
  CloseHandle (state->except_event);

  if (scb->fd < 0)
    return;

  close (scb->fd);
  scb->fd = -1;

  xfree (scb->state);
}

static void
ser_windows_wait_handle (struct serial *scb, HANDLE *read, HANDLE *except)
{
  struct ser_windows_state *state;
  COMSTAT status;
  DWORD errors;
  HANDLE h = (HANDLE) _get_osfhandle (scb->fd);

  state = scb->state;

  *except = state->except_event;
  *read = state->ov.hEvent;

  if (state->in_progress)
    return;

  /* Reset the mask - we are only interested in any characters which
     arrive after this point, not characters which might have arrived
     and already been read.  */

  /* This really, really shouldn't be necessary - just the second one.
     But otherwise an internal flag for EV_RXCHAR does not get
     cleared, and we get a duplicated event, if the last batch
     of characters included at least two arriving close together.  */
  if (!SetCommMask (h, 0))
    warning (_("ser_windows_wait_handle: reseting mask failed"));

  if (!SetCommMask (h, EV_RXCHAR))
    warning (_("ser_windows_wait_handle: reseting mask failed (2)"));

  /* There's a potential race condition here; we must check cbInQue
     and not wait if that's nonzero.  */

  ClearCommError (h, &errors, &status);
  if (status.cbInQue > 0)
    {
      SetEvent (state->ov.hEvent);
      return;
    }

  state->in_progress = 1;
  ResetEvent (state->ov.hEvent);
  state->lastCommMask = -2;
  if (WaitCommEvent (h, &state->lastCommMask, &state->ov))
    {
      gdb_assert (state->lastCommMask & EV_RXCHAR);
      SetEvent (state->ov.hEvent);
    }
  else
    gdb_assert (GetLastError () == ERROR_IO_PENDING);
}

static int
ser_windows_read_prim (struct serial *scb, size_t count)
{
  struct ser_windows_state *state;
  OVERLAPPED ov;
  DWORD bytes_read, bytes_read_tmp;
  HANDLE h;
  gdb_byte *p;

  state = scb->state;
  if (state->in_progress)
    {
      WaitForSingleObject (state->ov.hEvent, INFINITE);
      state->in_progress = 0;
      ResetEvent (state->ov.hEvent);
    }

  memset (&ov, 0, sizeof (OVERLAPPED));
  ov.hEvent = CreateEvent (0, FALSE, FALSE, 0);
  h = (HANDLE) _get_osfhandle (scb->fd);

  if (!ReadFile (h, scb->buf, /* count */ 1, &bytes_read, &ov))
    {
      if (GetLastError () != ERROR_IO_PENDING
	  || !GetOverlappedResult (h, &ov, &bytes_read, TRUE))
	bytes_read = -1;
    }

  CloseHandle (ov.hEvent);
  return bytes_read;
}

static int
ser_windows_write_prim (struct serial *scb, const void *buf, size_t len)
{
  struct ser_windows_state *state;
  OVERLAPPED ov;
  DWORD bytes_written;
  HANDLE h;

  memset (&ov, 0, sizeof (OVERLAPPED));
  ov.hEvent = CreateEvent (0, FALSE, FALSE, 0);
  h = (HANDLE) _get_osfhandle (scb->fd);
  if (!WriteFile (h, buf, len, &bytes_written, &ov))
    {
      if (GetLastError () != ERROR_IO_PENDING
	  || !GetOverlappedResult (h, &ov, &bytes_written, TRUE))
	bytes_written = -1;
    }

  CloseHandle (ov.hEvent);
  return bytes_written;
}

/* On Windows, gdb_select is implemented using WaitForMulpleObjects.
   A "select thread" is created for each file descriptor.  These
   threads looks for activity on the corresponding descriptor, using
   whatever techniques are appropriate for the descriptor type.  When
   that activity occurs, the thread signals an appropriate event,
   which wakes up WaitForMultipleObjects.

   Each select thread is in one of two states: stopped or started.
   Select threads begin in the stopped state.  When gdb_select is
   called, threads corresponding to the descriptors of interest are
   started by calling a wait_handle function.  Each thread that
   notices activity signals the appropriate event and then reenters
   the stopped state.  Before gdb_select returns it calls the
   wait_handle_done functions, which return the threads to the stopped
   state.  */

enum select_thread_state {
  STS_STARTED,
  STS_STOPPED
};

struct ser_console_state
{
  /* Signaled by the select thread to indicate that data is available
     on the file descriptor.  */
  HANDLE read_event;
  /* Signaled by the select thread to indicate that an exception has
     occurred on the file descriptor.  */
  HANDLE except_event;
  /* Signaled by the select thread to indicate that it has entered the
     started state.  HAVE_STARTED and HAVE_STOPPED are never signaled
     simultaneously.  */
  HANDLE have_started;
  /* Signaled by the select thread to indicate that it has stopped,
     either because data is available (and READ_EVENT is signaled),
     because an exception has occurred (and EXCEPT_EVENT is signaled),
     or because STOP_SELECT was signaled.  */
  HANDLE have_stopped;

  /* Signaled by the main program to tell the select thread to enter
     the started state.  */
  HANDLE start_select;
  /* Signaled by the main program to tell the select thread to enter
     the stopped state.  */
  HANDLE stop_select;
  /* Signaled by the main program to tell the select thread to
     exit.  */
  HANDLE exit_select;

  /* The handle for the select thread.  */
  HANDLE thread;
  /* The state of the select thread.  This field is only accessed in
     the main program, never by the select thread itself.  */
  enum select_thread_state thread_state;
};

/* Called by a select thread to enter the stopped state.  This
   function does not return until the thread has re-entered the
   started state.  */
static void
select_thread_wait (struct ser_console_state *state)
{
  HANDLE wait_events[2];

  /* There are two things that can wake us up: a request that we enter
     the started state, or that we exit this thread.  */
  wait_events[0] = state->start_select;
  wait_events[1] = state->exit_select;
  if (WaitForMultipleObjects (2, wait_events, FALSE, INFINITE) 
      != WAIT_OBJECT_0)
    /* Either the EXIT_SELECT event was signaled (requesting that the
       thread exit) or an error has occurred.  In either case, we exit
       the thread.  */
    ExitThread (0);
  
  /* We are now in the started state.  */
  SetEvent (state->have_started);
}

typedef DWORD WINAPI (*thread_fn_type)(void *);

/* Create a new select thread for SCB executing THREAD_FN.  The STATE
   will be filled in by this function before return.  */
static void
create_select_thread (thread_fn_type thread_fn,
		      struct serial *scb,
		      struct ser_console_state *state)
{
  DWORD threadId;

  /* Create all of the events.  These are all auto-reset events.  */
  state->read_event = CreateEvent (NULL, FALSE, FALSE, NULL);
  state->except_event = CreateEvent (NULL, FALSE, FALSE, NULL);
  state->have_started = CreateEvent (NULL, FALSE, FALSE, NULL);
  state->have_stopped = CreateEvent (NULL, FALSE, FALSE, NULL);
  state->start_select = CreateEvent (NULL, FALSE, FALSE, NULL);
  state->stop_select = CreateEvent (NULL, FALSE, FALSE, NULL);
  state->exit_select = CreateEvent (NULL, FALSE, FALSE, NULL);

  state->thread = CreateThread (NULL, 0, thread_fn, scb, 0, &threadId);
  /* The thread begins in the stopped state.  */
  state->thread_state = STS_STOPPED;
}

/* Destroy the select thread indicated by STATE.  */
static void
destroy_select_thread (struct ser_console_state *state)
{
  /* Ask the thread to exit.  */
  SetEvent (state->exit_select);
  /* Wait until it does.  */
  WaitForSingleObject (state->thread, INFINITE);

  /* Destroy the events.  */
  CloseHandle (state->read_event);
  CloseHandle (state->except_event);
  CloseHandle (state->have_started);
  CloseHandle (state->have_stopped);
  CloseHandle (state->start_select);
  CloseHandle (state->stop_select);
  CloseHandle (state->exit_select);
}

/* Called by gdb_select to start the select thread indicated by STATE.
   This function does not return until the thread has started.  */
static void
start_select_thread (struct ser_console_state *state)
{
  /* Ask the thread to start.  */
  SetEvent (state->start_select);
  /* Wait until it does.  */
  WaitForSingleObject (state->have_started, INFINITE);
  /* The thread is now started.  */
  state->thread_state = STS_STARTED;
}

/* Called by gdb_select to stop the select thread indicated by STATE.
   This function does not return until the thread has stopped.  */
static void
stop_select_thread (struct ser_console_state *state)
{
  /* If the thread is already in the stopped state, we have nothing to
     do.  Some of the wait_handle functions avoid calling
     start_select_thread if they notice activity on the relevant file
     descriptors.  The wait_handle_done functions still call
     stop_select_thread -- but it is already stopped.  */
  if (state->thread_state != STS_STARTED)
    return;
  /* Ask the thread to stop.  */
  SetEvent (state->stop_select);
  /* Wait until it does.  */
  WaitForSingleObject (state->have_stopped, INFINITE);
  /* The thread is now stopped.  */
  state->thread_state = STS_STOPPED;
}

static DWORD WINAPI
console_select_thread (void *arg)
{
  struct serial *scb = arg;
  struct ser_console_state *state;
  int event_index;
  HANDLE h;

  state = scb->state;
  h = (HANDLE) _get_osfhandle (scb->fd);

  while (1)
    {
      HANDLE wait_events[2];
      INPUT_RECORD record;
      DWORD n_records;

      select_thread_wait (state);

      while (1)
	{
	  wait_events[0] = state->stop_select;
	  wait_events[1] = h;

	  event_index = WaitForMultipleObjects (2, wait_events,
						FALSE, INFINITE);

	  if (event_index == WAIT_OBJECT_0
	      || WaitForSingleObject (state->stop_select, 0) == WAIT_OBJECT_0)
	    break;

	  if (event_index != WAIT_OBJECT_0 + 1)
	    {
	      /* Wait must have failed; assume an error has occured, e.g.
		 the handle has been closed.  */
	      SetEvent (state->except_event);
	      break;
	    }

	  /* We've got a pending event on the console.  See if it's
	     of interest.  */
	  if (!PeekConsoleInput (h, &record, 1, &n_records) || n_records != 1)
	    {
	      /* Something went wrong.  Maybe the console is gone.  */
	      SetEvent (state->except_event);
	      break;
	    }

	  if (record.EventType == KEY_EVENT && record.Event.KeyEvent.bKeyDown)
	    {
	      WORD keycode = record.Event.KeyEvent.wVirtualKeyCode;

	      /* Ignore events containing only control keys.  We must
		 recognize "enhanced" keys which we are interested in
		 reading via getch, if they do not map to ASCII.  But we
		 do not want to report input available for e.g. the
		 control key alone.  */

	      if (record.Event.KeyEvent.uChar.AsciiChar != 0
		  || keycode == VK_PRIOR
		  || keycode == VK_NEXT
		  || keycode == VK_END
		  || keycode == VK_HOME
		  || keycode == VK_LEFT
		  || keycode == VK_UP
		  || keycode == VK_RIGHT
		  || keycode == VK_DOWN
		  || keycode == VK_INSERT
		  || keycode == VK_DELETE)
		{
		  /* This is really a keypress.  */
		  SetEvent (state->read_event);
		  break;
		}
	    }

	  /* Otherwise discard it and wait again.  */
	  ReadConsoleInput (h, &record, 1, &n_records);
	}

      SetEvent(state->have_stopped);
    }
  return 0;
}

static int
fd_is_pipe (int fd)
{
  if (PeekNamedPipe ((HANDLE) _get_osfhandle (fd), NULL, 0, NULL, NULL, NULL))
    return 1;
  else
    return 0;
}

static int
fd_is_file (int fd)
{
  if (GetFileType ((HANDLE) _get_osfhandle (fd)) == FILE_TYPE_DISK)
    return 1;
  else
    return 0;
}

static DWORD WINAPI
pipe_select_thread (void *arg)
{
  struct serial *scb = arg;
  struct ser_console_state *state;
  int event_index;
  HANDLE h;

  state = scb->state;
  h = (HANDLE) _get_osfhandle (scb->fd);

  while (1)
    {
      DWORD n_avail;

      select_thread_wait (state);

      /* Wait for something to happen on the pipe.  */
      while (1)
	{
	  if (!PeekNamedPipe (h, NULL, 0, NULL, &n_avail, NULL))
	    {
	      SetEvent (state->except_event);
	      break;
	    }

	  if (n_avail > 0)
	    {
	      SetEvent (state->read_event);
	      break;
	    }

	  /* Delay 10ms before checking again, but allow the stop
	     event to wake us.  */
	  if (WaitForSingleObject (state->stop_select, 10) == WAIT_OBJECT_0)
	    break;
	}

      SetEvent (state->have_stopped);
    }
  return 0;
}

static DWORD WINAPI
file_select_thread (void *arg)
{
  struct serial *scb = arg;
  struct ser_console_state *state;
  int event_index;
  HANDLE h;

  state = scb->state;
  h = (HANDLE) _get_osfhandle (scb->fd);

  while (1)
    {
      select_thread_wait (state);

      if (SetFilePointer (h, 0, NULL, FILE_CURRENT)
	  == INVALID_SET_FILE_POINTER)
	SetEvent (state->except_event);
      else
	SetEvent (state->read_event);

      SetEvent (state->have_stopped);
    }
  return 0;
}

static void
ser_console_wait_handle (struct serial *scb, HANDLE *read, HANDLE *except)
{
  struct ser_console_state *state = scb->state;

  if (state == NULL)
    {
      thread_fn_type thread_fn;
      int is_tty;

      is_tty = isatty (scb->fd);
      if (!is_tty && !fd_is_file (scb->fd) && !fd_is_pipe (scb->fd))
	{
	  *read = NULL;
	  *except = NULL;
	  return;
	}

      state = xmalloc (sizeof (struct ser_console_state));
      memset (state, 0, sizeof (struct ser_console_state));
      scb->state = state;

      if (is_tty)
	thread_fn = console_select_thread;
      else if (fd_is_pipe (scb->fd))
	thread_fn = pipe_select_thread;
      else
	thread_fn = file_select_thread;

      create_select_thread (thread_fn, scb, state);
    }

  *read = state->read_event;
  *except = state->except_event;

  /* Start from a blank state.  */
  ResetEvent (state->read_event);
  ResetEvent (state->except_event);
  ResetEvent (state->stop_select);

  /* First check for a key already in the buffer.  If there is one,
     we don't need a thread.  This also catches the second key of
     multi-character returns from getch, for instance for arrow
     keys.  The second half is in a C library internal buffer,
     and PeekConsoleInput will not find it.  */
  if (_kbhit ())
    {
      SetEvent (state->read_event);
      return;
    }

  /* Otherwise, start the select thread.  */
  start_select_thread (state);
}

static void
ser_console_done_wait_handle (struct serial *scb)
{
  struct ser_console_state *state = scb->state;

  if (state == NULL)
    return;

  stop_select_thread (state);
}

static void
ser_console_close (struct serial *scb)
{
  struct ser_console_state *state = scb->state;

  if (scb->state)
    {
      destroy_select_thread (state);
      xfree (scb->state);
    }
}

struct ser_console_ttystate
{
  int is_a_tty;
};

static serial_ttystate
ser_console_get_tty_state (struct serial *scb)
{
  if (isatty (scb->fd))
    {
      struct ser_console_ttystate *state;

      state = (struct ser_console_ttystate *) xmalloc (sizeof *state);
      state->is_a_tty = 1;
      return state;
    }
  else
    return NULL;
}

struct pipe_state
{
  /* Since we use the pipe_select_thread for our select emulation,
     we need to place the state structure it requires at the front
     of our state.  */
  struct ser_console_state wait;

  /* The pex obj for our (one-stage) pipeline.  */
  struct pex_obj *pex;

  /* Streams for the pipeline's input and output.  */
  FILE *input, *output;
};

static struct pipe_state *
make_pipe_state (void)
{
  struct pipe_state *ps = XMALLOC (struct pipe_state);

  memset (ps, 0, sizeof (*ps));
  ps->wait.read_event = INVALID_HANDLE_VALUE;
  ps->wait.except_event = INVALID_HANDLE_VALUE;
  ps->wait.start_select = INVALID_HANDLE_VALUE;
  ps->wait.stop_select = INVALID_HANDLE_VALUE;

  return ps;
}

static void
free_pipe_state (struct pipe_state *ps)
{
  int saved_errno = errno;

  if (ps->wait.read_event != INVALID_HANDLE_VALUE)
    destroy_select_thread (&ps->wait);

  /* Close the pipe to the child.  We must close the pipe before
     calling pex_free because pex_free will wait for the child to exit
     and the child will not exit until the pipe is closed.  */
  if (ps->input)
    fclose (ps->input);
  if (ps->pex)
    {
      pex_free (ps->pex);
      /* pex_free closes ps->output.  */
    }
  else if (ps->output)
    fclose (ps->output);

  xfree (ps);

  errno = saved_errno;
}

static void
cleanup_pipe_state (void *untyped)
{
  struct pipe_state *ps = untyped;

  free_pipe_state (ps);
}

static int
pipe_windows_open (struct serial *scb, const char *name)
{
  struct pipe_state *ps;
  FILE *pex_stderr;
  char **argv;
  struct cleanup *back_to;

  if (name == NULL)
    error_no_arg (_("child command"));

  argv = gdb_buildargv (name);
  back_to = make_cleanup_freeargv (argv);

  if (! argv[0] || argv[0][0] == '\0')
    error (_("missing child command"));

  ps = make_pipe_state ();
  make_cleanup (cleanup_pipe_state, ps);

  ps->pex = pex_init (PEX_USE_PIPES, "target remote pipe", NULL);
  if (! ps->pex)
    goto fail;
  ps->input = pex_input_pipe (ps->pex, 1);
  if (! ps->input)
    goto fail;

  {
    int err;
    const char *err_msg
      = pex_run (ps->pex, PEX_SEARCH | PEX_BINARY_INPUT | PEX_BINARY_OUTPUT
		 | PEX_STDERR_TO_PIPE,
                 argv[0], argv, NULL, NULL,
                 &err);

    if (err_msg)
      {
        /* Our caller expects us to return -1, but all they'll do with
           it generally is print the message based on errno.  We have
           all the same information here, plus err_msg provided by
           pex_run, so we just raise the error here.  */
        if (err)
          error (_("error starting child process '%s': %s: %s"),
                 name, err_msg, safe_strerror (err));
        else
          error (_("error starting child process '%s': %s"),
                 name, err_msg);
      }
  }

  ps->output = pex_read_output (ps->pex, 1);
  if (! ps->output)
    goto fail;
  scb->fd = fileno (ps->output);

  pex_stderr = pex_read_err (ps->pex, 1);
  if (! pex_stderr)
    goto fail;
  scb->error_fd = fileno (pex_stderr);

  scb->state = (void *) ps;

  discard_cleanups (back_to);
  return 0;

 fail:
  do_cleanups (back_to);
  return -1;
}

static int
pipe_windows_fdopen (struct serial *scb, int fd)
{
  struct pipe_state *ps;

  ps = make_pipe_state ();

  ps->input = fdopen (fd, "r+");
  if (! ps->input)
    goto fail;

  ps->output = fdopen (fd, "r+");
  if (! ps->output)
    goto fail;

  scb->fd = fd;
  scb->state = (void *) ps;

  return 0;

 fail:
  free_pipe_state (ps);
  return -1;
}

static void
pipe_windows_close (struct serial *scb)
{
  struct pipe_state *ps = scb->state;

  /* In theory, we should try to kill the subprocess here, but the pex
     interface doesn't give us enough information to do that.  Usually
     closing the input pipe will get the message across.  */

  free_pipe_state (ps);
}


static int
pipe_windows_read (struct serial *scb, size_t count)
{
  HANDLE pipeline_out = (HANDLE) _get_osfhandle (scb->fd);
  DWORD available;
  DWORD bytes_read;

  if (pipeline_out == INVALID_HANDLE_VALUE)
    return -1;

  if (! PeekNamedPipe (pipeline_out, NULL, 0, NULL, &available, NULL))
    return -1;

  if (count > available)
    count = available;

  if (! ReadFile (pipeline_out, scb->buf, count, &bytes_read, NULL))
    return -1;

  return bytes_read;
}


static int
pipe_windows_write (struct serial *scb, const void *buf, size_t count)
{
  struct pipe_state *ps = scb->state;
  HANDLE pipeline_in;
  DWORD written;

  int pipeline_in_fd = fileno (ps->input);
  if (pipeline_in_fd < 0)
    return -1;

  pipeline_in = (HANDLE) _get_osfhandle (pipeline_in_fd);
  if (pipeline_in == INVALID_HANDLE_VALUE)
    return -1;

  if (! WriteFile (pipeline_in, buf, count, &written, NULL))
    return -1;

  return written;
}


static void
pipe_wait_handle (struct serial *scb, HANDLE *read, HANDLE *except)
{
  struct pipe_state *ps = scb->state;

  /* Have we allocated our events yet?  */
  if (ps->wait.read_event == INVALID_HANDLE_VALUE)
    /* Start the thread.  */
    create_select_thread (pipe_select_thread, scb, &ps->wait);

  *read = ps->wait.read_event;
  *except = ps->wait.except_event;

  /* Start from a blank state.  */
  ResetEvent (ps->wait.read_event);
  ResetEvent (ps->wait.except_event);
  ResetEvent (ps->wait.stop_select);

  start_select_thread (&ps->wait);
}

static void
pipe_done_wait_handle (struct serial *scb)
{
  struct pipe_state *ps = scb->state;

  /* Have we allocated our events yet?  */
  if (ps->wait.read_event == INVALID_HANDLE_VALUE)
    return;

  stop_select_thread (&ps->wait);
}

static int
pipe_avail (struct serial *scb, int fd)
{
  HANDLE h = (HANDLE) _get_osfhandle (fd);
  DWORD numBytes;
  BOOL r = PeekNamedPipe (h, NULL, 0, NULL, &numBytes, NULL);

  if (r == FALSE)
    numBytes = 0;
  return numBytes;
}

int
gdb_pipe (int pdes[2])
{
  if (_pipe (pdes, 512, _O_BINARY | _O_NOINHERIT) == -1)
    return -1;
  return 0;
}

struct net_windows_state
{
  struct ser_console_state base;
  
  HANDLE sock_event;
};

static DWORD WINAPI
net_windows_select_thread (void *arg)
{
  struct serial *scb = arg;
  struct net_windows_state *state;
  int event_index;

  state = scb->state;

  while (1)
    {
      HANDLE wait_events[2];
      WSANETWORKEVENTS events;

      select_thread_wait (&state->base);

      wait_events[0] = state->base.stop_select;
      wait_events[1] = state->sock_event;

      event_index = WaitForMultipleObjects (2, wait_events, FALSE, INFINITE);

      if (event_index == WAIT_OBJECT_0
	  || WaitForSingleObject (state->base.stop_select, 0) == WAIT_OBJECT_0)
	/* We have been requested to stop.  */
	;
      else if (event_index != WAIT_OBJECT_0 + 1)
	/* Some error has occured.  Assume that this is an error
	   condition.  */
	SetEvent (state->base.except_event);
      else
	{
	  /* Enumerate the internal network events, and reset the
	     object that signalled us to catch the next event.  */
	  WSAEnumNetworkEvents (scb->fd, state->sock_event, &events);
	  
	  gdb_assert (events.lNetworkEvents & (FD_READ | FD_CLOSE));
	  
	  if (events.lNetworkEvents & FD_READ)
	    SetEvent (state->base.read_event);
	  
	  if (events.lNetworkEvents & FD_CLOSE)
	    SetEvent (state->base.except_event);
	}

      SetEvent (state->base.have_stopped);
    }
}

static void
net_windows_wait_handle (struct serial *scb, HANDLE *read, HANDLE *except)
{
  struct net_windows_state *state = scb->state;

  /* Start from a clean slate.  */
  ResetEvent (state->base.read_event);
  ResetEvent (state->base.except_event);
  ResetEvent (state->base.stop_select);

  *read = state->base.read_event;
  *except = state->base.except_event;

  /* Check any pending events.  This both avoids starting the thread
     unnecessarily, and handles stray FD_READ events (see below).  */
  if (WaitForSingleObject (state->sock_event, 0) == WAIT_OBJECT_0)
    {
      WSANETWORKEVENTS events;
      int any = 0;

      /* Enumerate the internal network events, and reset the object that
	 signalled us to catch the next event.  */
      WSAEnumNetworkEvents (scb->fd, state->sock_event, &events);

      /* You'd think that FD_READ or FD_CLOSE would be set here.  But,
	 sometimes, neither is.  I suspect that the FD_READ is set and
	 the corresponding event signalled while recv is running, and
	 the FD_READ is then lowered when recv consumes all the data,
	 but there's no way to un-signal the event.  This isn't a
	 problem for the call in net_select_thread, since any new
	 events after this point will not have been drained by recv.
	 It just means that we can't have the obvious assert here.  */

      /* If there is a read event, it might be still valid, or it might
	 not be - it may have been signalled before we last called
	 recv.  Double-check that there is data.  */
      if (events.lNetworkEvents & FD_READ)
	{
	  unsigned long available;

	  if (ioctlsocket (scb->fd, FIONREAD, &available) == 0
	      && available > 0)
	    {
	      SetEvent (state->base.read_event);
	      any = 1;
	    }
	  else
	    /* Oops, no data.  This call to recv will cause future
	       data to retrigger the event, e.g. while we are
	       in net_select_thread.  */
	    recv (scb->fd, NULL, 0, 0);
	}

      /* If there's a close event, then record it - it is obviously
	 still valid, and it will not be resignalled.  */
      if (events.lNetworkEvents & FD_CLOSE)
	{
	  SetEvent (state->base.except_event);
	  any = 1;
	}

      /* If we set either handle, there's no need to wake the thread.  */
      if (any)
	return;
    }

  start_select_thread (&state->base);
}

static void
net_windows_done_wait_handle (struct serial *scb)
{
  struct net_windows_state *state = scb->state;

  stop_select_thread (&state->base);
}

static int
net_windows_open (struct serial *scb, const char *name)
{
  struct net_windows_state *state;
  int ret;
  DWORD threadId;

  ret = net_open (scb, name);
  if (ret != 0)
    return ret;

  state = xmalloc (sizeof (struct net_windows_state));
  memset (state, 0, sizeof (struct net_windows_state));
  scb->state = state;

  /* Associate an event with the socket.  */
  state->sock_event = CreateEvent (0, TRUE, FALSE, 0);
  WSAEventSelect (scb->fd, state->sock_event, FD_READ | FD_CLOSE);

  /* Start the thread.  */
  create_select_thread (net_windows_select_thread, scb, &state->base);

  return 0;
}


static void
net_windows_close (struct serial *scb)
{
  struct net_windows_state *state = scb->state;

  destroy_select_thread (&state->base);
  CloseHandle (state->sock_event);

  xfree (scb->state);

  net_close (scb);
}

void
_initialize_ser_windows (void)
{
  WSADATA wsa_data;
  struct serial_ops *ops;

  HMODULE hm = NULL;

  /* First find out if kernel32 exports CancelIo function.  */
  hm = LoadLibrary ("kernel32.dll");
  if (hm)
    {
      CancelIo = (void *) GetProcAddress (hm, "CancelIo");
      FreeLibrary (hm);
    }
  else
    CancelIo = NULL;

  /* Now register the serial port driver.  */
  ops = XMALLOC (struct serial_ops);
  memset (ops, 0, sizeof (struct serial_ops));
  ops->name = "hardwire";
  ops->next = 0;
  ops->open = ser_windows_open;
  ops->close = ser_windows_close;

  ops->flush_output = ser_windows_flush_output;
  ops->flush_input = ser_windows_flush_input;
  ops->send_break = ser_windows_send_break;

  /* These are only used for stdin; we do not need them for serial
     ports, so supply the standard dummies.  */
  ops->get_tty_state = ser_base_get_tty_state;
  ops->copy_tty_state = ser_base_copy_tty_state;
  ops->set_tty_state = ser_base_set_tty_state;
  ops->print_tty_state = ser_base_print_tty_state;
  ops->noflush_set_tty_state = ser_base_noflush_set_tty_state;

  ops->go_raw = ser_windows_raw;
  ops->setbaudrate = ser_windows_setbaudrate;
  ops->setstopbits = ser_windows_setstopbits;
  ops->drain_output = ser_windows_drain_output;
  ops->readchar = ser_base_readchar;
  ops->write = ser_base_write;
  ops->async = ser_base_async;
  ops->read_prim = ser_windows_read_prim;
  ops->write_prim = ser_windows_write_prim;
  ops->wait_handle = ser_windows_wait_handle;

  serial_add_interface (ops);

  /* Next create the dummy serial driver used for terminals.  We only
     provide the TTY-related methods.  */

  ops = XMALLOC (struct serial_ops);
  memset (ops, 0, sizeof (struct serial_ops));

  ops->name = "terminal";
  ops->next = 0;

  ops->close = ser_console_close;
  ops->get_tty_state = ser_console_get_tty_state;
  ops->copy_tty_state = ser_base_copy_tty_state;
  ops->set_tty_state = ser_base_set_tty_state;
  ops->print_tty_state = ser_base_print_tty_state;
  ops->noflush_set_tty_state = ser_base_noflush_set_tty_state;
  ops->drain_output = ser_base_drain_output;
  ops->wait_handle = ser_console_wait_handle;
  ops->done_wait_handle = ser_console_done_wait_handle;

  serial_add_interface (ops);

  /* The pipe interface.  */

  ops = XMALLOC (struct serial_ops);
  memset (ops, 0, sizeof (struct serial_ops));
  ops->name = "pipe";
  ops->next = 0;
  ops->open = pipe_windows_open;
  ops->close = pipe_windows_close;
  ops->fdopen = pipe_windows_fdopen;
  ops->readchar = ser_base_readchar;
  ops->write = ser_base_write;
  ops->flush_output = ser_base_flush_output;
  ops->flush_input = ser_base_flush_input;
  ops->send_break = ser_base_send_break;
  ops->go_raw = ser_base_raw;
  ops->get_tty_state = ser_base_get_tty_state;
  ops->copy_tty_state = ser_base_copy_tty_state;
  ops->set_tty_state = ser_base_set_tty_state;
  ops->print_tty_state = ser_base_print_tty_state;
  ops->noflush_set_tty_state = ser_base_noflush_set_tty_state;
  ops->setbaudrate = ser_base_setbaudrate;
  ops->setstopbits = ser_base_setstopbits;
  ops->drain_output = ser_base_drain_output;
  ops->async = ser_base_async;
  ops->read_prim = pipe_windows_read;
  ops->write_prim = pipe_windows_write;
  ops->wait_handle = pipe_wait_handle;
  ops->done_wait_handle = pipe_done_wait_handle;
  ops->avail = pipe_avail;

  serial_add_interface (ops);

  /* If WinSock works, register the TCP/UDP socket driver.  */

  if (WSAStartup (MAKEWORD (1, 0), &wsa_data) != 0)
    /* WinSock is unavailable.  */
    return;

  ops = XMALLOC (struct serial_ops);
  memset (ops, 0, sizeof (struct serial_ops));
  ops->name = "tcp";
  ops->next = 0;
  ops->open = net_windows_open;
  ops->close = net_windows_close;
  ops->readchar = ser_base_readchar;
  ops->write = ser_base_write;
  ops->flush_output = ser_base_flush_output;
  ops->flush_input = ser_base_flush_input;
  ops->send_break = ser_tcp_send_break;
  ops->go_raw = ser_base_raw;
  ops->get_tty_state = ser_base_get_tty_state;
  ops->copy_tty_state = ser_base_copy_tty_state;
  ops->set_tty_state = ser_base_set_tty_state;
  ops->print_tty_state = ser_base_print_tty_state;
  ops->noflush_set_tty_state = ser_base_noflush_set_tty_state;
  ops->setbaudrate = ser_base_setbaudrate;
  ops->setstopbits = ser_base_setstopbits;
  ops->drain_output = ser_base_drain_output;
  ops->async = ser_base_async;
  ops->read_prim = net_read_prim;
  ops->write_prim = net_write_prim;
  ops->wait_handle = net_windows_wait_handle;
  ops->done_wait_handle = net_windows_done_wait_handle;
  serial_add_interface (ops);
}
@


1.32
log
@gdb/
	Fix -Wmissing-prototypes build.
	* charset.c (phony_iconv_open): Make static.
	(phony_iconv_close, phony_iconv): Likewise.
	* i386-linux-nat.c (_initialize_i386_linux_nat): New prototype.
	* i386-windows-nat.c (_initialize_i386_windows_nat): New
	prototype.
	* mingw-hdep.c (_initialize_mingw_hdep): New prototype.
	* ser-mingw.c (create_select_thread): Make static.
	* windows-termcap.c (tgetent): New prototype.
	(tgetnum, tgetflag, tgetstr, tputs, tgoto): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.31
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d431 1
a431 1
void
@


1.30
log
@	Fix ARI warnings about new lines at the end of messages, which
	are unneeded as there is a new line added at the end of the message
	automatically.
	* darwin-nat.c (darwin_stop_inferior): Ditto.
	* dec-thread.c (dec_thread_get_ada_task_ptid): Ditto.
	* dfp.c (decimal_to_number): Ditto.
	* exec.c (print_section_info): Ditto.
	* i386-darwin-nat.c (darwin_set_sstep): Ditto.
	* osdata.c (get_osdata): Ditto.
	* record.c (bfdcore_write): Ditto.
	* remote-mips.c (mips_readchar): Ditto.
	* remote.c (read_ptid): Ditto.
	* ser-mingw.c (ser_windows_raw): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	* windows-nat.c (fake_create_process): Ditto.
@
text
@d3 1
a3 2
   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.30.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.29
log
@	* inflow.c (terminal_init_inferior_with_pgrp): Copy ttystate.
	(terminal_save_ours): Remove misleading comment.
	(inflow_inferior_data_cleanup): Free ttystate.
	(inflow_inferior_exit): Likewise.
	(copy_terminal_info): Copy ttystate.

	* serial.c (serial_copy_tty_state): New function.
	* serial.h (serial_copy_tty_state): Add prototype.
	(struct serial_ops): Add copy_tty_state callback.
	* ser-base.c (ser_base_copy_tty_state): New function.
	* ser-base.h (ser_base_copy_tty_state): Add prototype.
	* ser-go32.c (dos_copy_tty_state): New function.
	(dos_ops): Install copy_tty_state callback.
	* ser-mingw.c (_initialize_ser_windows): Likewise.
	* ser-pipe.c (_initialize_ser_pipe): Likewise.
	* ser-unix.c (hardwire_copy_tty_state): New function.
	(_initialize_ser_hardwire): Install it.
@
text
@d175 1
a175 1
    warning (_("SetCommState failed\n"));
@


1.28
log
@	* ser-mingw.c (ser_windows_close): Reformat comment to better conform
	to GNU coding standards.
@
text
@d1247 1
d1276 1
d1302 1
d1337 1
@


1.27
log
@	Allow use of mingw native on Windows 95 OS.
	* src/gdb/ser-mingw.c (CancelIo): New macro for dynamically loaded
	DLL entry.
	(ser_windows_close): Only call CancelIo if function exists.
	(_initialize_ser_windows): Use LoadLirary/GetProcAddress
	to check for existence of CancelIo function in kernel32 DLL.
@
text
@d224 4
a227 4
  /* Stop any pending selects. On Windows 95 OS, CancelIo function does not
     exist. In that case, it can be replaced by a call to CloseHandle, but
     this is not necessary here as we do close the Windows handle by calling
     close (scb->fd) below.  */
@


1.26
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d48 5
d224 6
a229 2
  /* Stop any pending selects.  */
  CancelIo ((HANDLE) _get_osfhandle (scb->fd));
d1220 11
a1230 1
  /* First register the serial port driver.  */
d1232 1
@


1.25
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* charset.c (validate): Internationalization.
	* coffread.c (read_one_sym): Ditto.
	* dwarf2read.c (dwarf2_attach_fields_to_type): Ditto.
	* h8300-tdep.c (H8300_extract_return_value): Ditto.
	* inflow.c (new_tty): Ditto.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* mep-tdep.c (mep_store_return_value): Ditto.
	* score-tdep.c (score7_fetch_insn): Ditto.
	* ser-mingw.c (pipe_windows_open): Ditto.
	* sh64-tdep.c (sh64_extract_return_value): Ditto.
	* spu-tdep.c (spu_register_type): Ditto.
	* tracepoint.c (trace_find_command): Ditto.
	* valarith.c (value_pos): Ditto.
@
text
@d383 1
a383 1
     the stopped state. */
@


1.24
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d843 1
a843 1
    error ("missing child command");
d870 1
a870 1
          error ("error starting child process '%s': %s: %s",
d873 1
a873 1
          error ("error starting child process '%s': %s",
@


1.23
log
@run copyright.sh for 2011.
@
text
@d520 2
a521 1
	  event_index = WaitForMultipleObjects (2, wait_events, FALSE, INFINITE);
d657 2
a658 1
      if (SetFilePointer (h, 0, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER)
@


1.22
log
@	* serial.h (gdb_pipe, serial_pipe): Declare.
	* serial.c (serial_interface_lookup): Take a const char pointer.
	(serial_fdopen): Rename to ...
	(serial_fdopen_ops): ... this.  Add an OPS parameter and use it.
	Call the OPS' fdopen function if there is one.
	(serial_fdopen): Rewrite as wrapper to serial_fdopen_ops.
	(serial_pipe): New.
	(struct serial_ops) <fdopen>: New field.

	* ser-mingw.c (free_pipe_state):
	(free_pipe_state): Close output on non-pex pipes.
	(pipe_windows_fdopen): New.
	(gdb_pipe): New.
	(_initialize_ser_windows): Register pipe_windows_fdopen.
	* ser-go32.c (gdb_pipe): New.
	* ser-pipe.c (pipe_close): Close file descriptor even if there's
	no state pointer.
	(pipe_ops): Delete.
	(gdb_pipe): New.
@
text
@d3 2
a4 1
   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.21
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d805 6
a810 2
    pex_free (ps->pex);
  /* pex_free closes ps->output.  */
d895 24
d1023 8
d1269 1
@


1.20
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d754 1
d989 1
@


1.19
log
@2009-01-14  Kai Tietz  <kai.tietz@@onevision.com>

	* mingw-ser.c (console_select_thread): Add return to make
	compiler happy.
	(pipe_select_thread): Likewise.
	(file_select_thread): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.18
log
@        * ser-mingw.c (ser_windows_open): Use proper type when casting
        in call to _open_osfhandle.
@
text
@d576 1
d637 1
d662 1
@


1.17
log
@        Updated copyright notices for most files.
@
text
@d64 1
a64 1
  scb->fd = _open_osfhandle ((long) h, O_RDWR);
@


1.16
log
@	* ser-mingw.c: Include "command.h".
	(pipe_windows_open): Declare locals at the beginning of the scope.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.15
log
@2008-10-03  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* utils.c, defs.h (gdb_buildargv): New fn. Wrap buildargv
	and check for out-of-memory condition.
	* exec.c (exec_file_command): Call it.
	* infrun.c (handle_command, xdb_handle_command): Likewise.
	* interps.c (interpreter_exec_cmd): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* procfs.c (info_proc_cmd): Likewise.
	* remote-mips.c (common_open): Likewise.
	* remote-sim.c (gdbsim_kill, gdbsim_create_inferior)
	(gdbsim_open): Likewise.
	* remote.c (extended_remote_run, remote_put_command)
	(remote_get_command, remote_delete_command): Likewise.
	* ser-mingw.c (pipe_windows_open): Likesise.
	* source.c (add_path, show_substitute_path_command)
	(unset_substitute_path_command, set_substitute_path_command):
	Likewise.
	* stack.c (backtrace_command): Likewise.
	* symfile.c (symbol_file_command, generic_load)
	(add_symbol_file_command): Likesise.
	* symmisc.c (maintenance_print_symbols, maintenance_print_psymbols)
	(maintenance_print_msymbols): Likewise.
@
text
@d35 2
d822 2
d828 2
a829 2
  char **argv = gdb_buildargv (name);
  struct cleanup *back_to = make_cleanup_freeargv (argv);
@


1.14
log
@2008-09-03  Angela Marie Thomas <angela@@releasedominatrix.com>

	* ser-tcp.c (ser_tcp_send_break): New function.
	(_initialize_ser_tcp): Use ser_tcp_send_break.
	* ser-tcp.h (ser_tcp_send_break): New prototype.

2008-09-03  Angela Marie Thomas <angela@@releasedominatrix.com>

	* gdb.texinfo (Interrupts): Mention TCP interface for
	sending BREAK.
@
text
@d821 4
a824 1
  char **argv = buildargv (name);
d826 1
a829 1

@


1.13
log
@
gdb/

2008-03-28  Carlos O'Donell  <carlos@@codesourcery.com>

	* ser-mingw.c (ser_windows_open): Open requested name.
@
text
@d1259 1
a1259 1
  ops->send_break = ser_base_send_break;
@


1.12
log
@	Updated copyright notices for most files.
@
text
@a53 7
  /* Only allow COM ports.  */
  if (strncmp (name, "COM", 3) != 0)
    {
      errno = ENOENT;
      return -1;
    }

@


1.11
log
@2007-10-02  Mark Mitchell  <mark@@codesourcery.com>

	* mingw-hdep.c (gdb_select): Stop helper threads before returning.
	* ser-mingw.c (enum select_thread_state): New type.
	(struct ser_console_state): Add have_started and thread_state.
	(select_thread_wait): New function.
	(thread_fn_type): New type.
	(create_select_thread): New function.
	(destroy_select_thread): Likewise.
	(start_select_thread): Likewise.
	(stop_select_thread): Likewise.
	(console_select_thread): Use new functions.
	(pipe_select_thread): Likewise.
	(file_select_thread): Likewise.
	(ser_console_wait_handle): Likewise.
	(ser_console_done_wait_handle): Likewise.
	(ser_console_close): Likewise.
	(free_pipe_state): Likewise.
	(pipe_wait_handle): Likewise.
	(pipe_done_wait_handle): Likewise.
	(struct net_windows_state): Derive from ser_console_state.
	(net_windows_select_thread): Use new functions.
	(net_windows_wait_handle): Likewise.
	(net_windows_done_wait_handle): Likewise.
	(net_windows_close): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
@


1.10
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d344 21
d367 2
d370 2
d373 9
d383 2
d386 2
d389 2
a391 1
  HANDLE have_stopped;
d393 1
d395 3
d400 100
d517 1
a517 1
      SetEvent (state->have_stopped);
d519 4
a522 2
      wait_events[0] = state->start_select;
      wait_events[1] = state->exit_select;
d524 1
a524 2
      if (WaitForMultipleObjects (2, wait_events, FALSE, INFINITE) != WAIT_OBJECT_0)
	return 0;
d526 3
a528 1
      ResetEvent (state->have_stopped);
d530 7
a536 3
    retry:
      wait_events[0] = state->stop_select;
      wait_events[1] = h;
d538 8
a545 1
      event_index = WaitForMultipleObjects (2, wait_events, FALSE, INFINITE);
d547 3
a549 3
      if (event_index == WAIT_OBJECT_0
	  || WaitForSingleObject (state->stop_select, 0) == WAIT_OBJECT_0)
	continue;
d551 23
a573 7
      if (event_index != WAIT_OBJECT_0 + 1)
	{
	  /* Wait must have failed; assume an error has occured, e.g.
	     the handle has been closed.  */
	  SetEvent (state->except_event);
	  continue;
	}
d575 2
a576 7
      /* We've got a pending event on the console.  See if it's
	 of interest.  */
      if (!PeekConsoleInput (h, &record, 1, &n_records) || n_records != 1)
	{
	  /* Something went wrong.  Maybe the console is gone.  */
	  SetEvent (state->except_event);
	  continue;
d579 1
a579 31
      if (record.EventType == KEY_EVENT && record.Event.KeyEvent.bKeyDown)
	{
	  WORD keycode = record.Event.KeyEvent.wVirtualKeyCode;

	  /* Ignore events containing only control keys.  We must
	     recognize "enhanced" keys which we are interested in
	     reading via getch, if they do not map to ASCII.  But we
	     do not want to report input available for e.g. the
	     control key alone.  */

	  if (record.Event.KeyEvent.uChar.AsciiChar != 0
	      || keycode == VK_PRIOR
	      || keycode == VK_NEXT
	      || keycode == VK_END
	      || keycode == VK_HOME
	      || keycode == VK_LEFT
	      || keycode == VK_UP
	      || keycode == VK_RIGHT
	      || keycode == VK_DOWN
	      || keycode == VK_INSERT
	      || keycode == VK_DELETE)
	    {
	      /* This is really a keypress.  */
	      SetEvent (state->read_event);
	      continue;
	    }
	}

      /* Otherwise discard it and wait again.  */
      ReadConsoleInput (h, &record, 1, &n_records);
      goto retry;
a613 1
      HANDLE wait_events[2];
d616 1
a616 1
      SetEvent (state->have_stopped);
d618 8
a625 2
      wait_events[0] = state->start_select;
      wait_events[1] = state->exit_select;
d627 5
a631 4
      if (WaitForMultipleObjects (2, wait_events, FALSE, INFINITE) != WAIT_OBJECT_0)
	return 0;

      ResetEvent (state->have_stopped);
d633 4
a636 5
    retry:
      if (!PeekNamedPipe (h, NULL, 0, NULL, &n_avail, NULL))
	{
	  SetEvent (state->except_event);
	  continue;
d639 1
a639 12
      if (n_avail > 0)
	{
	  SetEvent (state->read_event);
	  continue;
	}

      /* Delay 10ms before checking again, but allow the stop event
	 to wake us.  */
      if (WaitForSingleObject (state->stop_select, 10) == WAIT_OBJECT_0)
	continue;

      goto retry;
d656 1
a656 12
      HANDLE wait_events[2];
      DWORD n_avail;

      SetEvent (state->have_stopped);

      wait_events[0] = state->start_select;
      wait_events[1] = state->exit_select;

      if (WaitForMultipleObjects (2, wait_events, FALSE, INFINITE) != WAIT_OBJECT_0)
	return 0;

      ResetEvent (state->have_stopped);
d659 3
a661 4
	{
	  SetEvent (state->except_event);
	  continue;
	}
d663 1
a663 1
      SetEvent (state->read_event);
d674 1
a674 1
      DWORD threadId;
a688 15
      /* Create auto reset events to wake, stop, and exit the select
	 thread.  */
      state->start_select = CreateEvent (0, FALSE, FALSE, 0);
      state->stop_select = CreateEvent (0, FALSE, FALSE, 0);
      state->exit_select = CreateEvent (0, FALSE, FALSE, 0);

      /* Create a manual reset event to signal whether the thread is
	 stopped.  This must be manual reset, because we may wait on
	 it multiple times without ever starting the thread.  */
      state->have_stopped = CreateEvent (0, TRUE, FALSE, 0);

      /* Create our own events to report read and exceptions separately.  */
      state->read_event = CreateEvent (0, FALSE, FALSE, 0);
      state->except_event = CreateEvent (0, FALSE, FALSE, 0);

d690 1
a690 2
	state->thread = CreateThread (NULL, 0, console_select_thread, scb, 0,
				      &threadId);
d692 1
a692 2
	state->thread = CreateThread (NULL, 0, pipe_select_thread, scb, 0,
				      &threadId);
d694 3
a696 2
	state->thread = CreateThread (NULL, 0, file_select_thread, scb, 0,
				      &threadId);
d719 1
a719 1
  SetEvent (state->start_select);
d730 1
a730 2
  SetEvent (state->stop_select);
  WaitForSingleObject (state->have_stopped, INFINITE);
d740 1
a740 12
      SetEvent (state->exit_select);

      WaitForSingleObject (state->thread, INFINITE);

      CloseHandle (state->start_select);
      CloseHandle (state->stop_select);
      CloseHandle (state->exit_select);
      CloseHandle (state->have_stopped);

      CloseHandle (state->read_event);
      CloseHandle (state->except_event);

d798 1
a798 13
    {
      SetEvent (ps->wait.exit_select);

      WaitForSingleObject (ps->wait.thread, INFINITE);

      CloseHandle (ps->wait.start_select);
      CloseHandle (ps->wait.stop_select);
      CloseHandle (ps->wait.exit_select);
      CloseHandle (ps->wait.have_stopped);

      CloseHandle (ps->wait.read_event);
      CloseHandle (ps->wait.except_event);
    }
d953 2
a954 22
    {
      DWORD threadId;

      /* Create auto reset events to wake, stop, and exit the select
	 thread.  */
      ps->wait.start_select = CreateEvent (0, FALSE, FALSE, 0);
      ps->wait.stop_select = CreateEvent (0, FALSE, FALSE, 0);
      ps->wait.exit_select = CreateEvent (0, FALSE, FALSE, 0);

      /* Create a manual reset event to signal whether the thread is
	 stopped.  This must be manual reset, because we may wait on
	 it multiple times without ever starting the thread.  */
      ps->wait.have_stopped = CreateEvent (0, TRUE, FALSE, 0);

      /* Create our own events to report read and exceptions separately.
	 The exception event is currently never used.  */
      ps->wait.read_event = CreateEvent (0, FALSE, FALSE, 0);
      ps->wait.except_event = CreateEvent (0, FALSE, FALSE, 0);

      /* Start the select thread.  */
      CreateThread (NULL, 0, pipe_select_thread, scb, 0, &threadId);
    }
d964 1
a964 2
  /* Start the select thread.  */
  SetEvent (ps->wait.start_select);
d976 1
a976 2
  SetEvent (ps->wait.stop_select);
  WaitForSingleObject (ps->wait.have_stopped, INFINITE);
d992 2
a993 8
  HANDLE read_event;
  HANDLE except_event;

  HANDLE start_select;
  HANDLE stop_select;
  HANDLE exit_select;
  HANDLE have_stopped;

a994 2

  HANDLE thread;
d1001 1
a1001 1
  struct net_windows_state *state, state_copy;
d1011 1
a1011 7
      SetEvent (state->have_stopped);

      wait_events[0] = state->start_select;
      wait_events[1] = state->exit_select;

      if (WaitForMultipleObjects (2, wait_events, FALSE, INFINITE) != WAIT_OBJECT_0)
	return 0;
d1013 1
a1013 3
      ResetEvent (state->have_stopped);

      wait_events[0] = state->stop_select;
d1019 8
a1026 4
	  || WaitForSingleObject (state->stop_select, 0) == WAIT_OBJECT_0)
	continue;

      if (event_index != WAIT_OBJECT_0 + 1)
d1028 11
a1038 4
	  /* Some error has occured.  Assume that this is an error
	     condition.  */
	  SetEvent (state->except_event);
	  continue;
d1041 1
a1041 11
      /* Enumerate the internal network events, and reset the object that
	 signalled us to catch the next event.  */
      WSAEnumNetworkEvents (scb->fd, state->sock_event, &events);

      gdb_assert (events.lNetworkEvents & (FD_READ | FD_CLOSE));

      if (events.lNetworkEvents & FD_READ)
	SetEvent (state->read_event);

      if (events.lNetworkEvents & FD_CLOSE)
	SetEvent (state->except_event);
d1051 3
a1053 3
  ResetEvent (state->read_event);
  ResetEvent (state->except_event);
  ResetEvent (state->stop_select);
d1055 2
a1056 2
  *read = state->read_event;
  *except = state->except_event;
d1088 1
a1088 1
	      SetEvent (state->read_event);
d1102 1
a1102 1
	  SetEvent (state->except_event);
d1111 1
a1111 2
  /* Start the select thread.  */
  SetEvent (state->start_select);
d1119 1
a1119 2
  SetEvent (state->stop_select);
  WaitForSingleObject (state->have_stopped, INFINITE);
a1136 11
  /* Create auto reset events to wake, stop, and exit the select
     thread.  */
  state->start_select = CreateEvent (0, FALSE, FALSE, 0);
  state->stop_select = CreateEvent (0, FALSE, FALSE, 0);
  state->exit_select = CreateEvent (0, FALSE, FALSE, 0);

  /* Create a manual reset event to signal whether the thread is
     stopped.  This must be manual reset, because we may wait on
     it multiple times without ever starting the thread.  */
  state->have_stopped = CreateEvent (0, TRUE, FALSE, 0);

d1141 2
a1142 7
  /* Create our own events to report read and close separately.  */
  state->read_event = CreateEvent (0, FALSE, FALSE, 0);
  state->except_event = CreateEvent (0, FALSE, FALSE, 0);

  /* And finally start the select thread.  */
  state->thread = CreateThread (NULL, 0, net_windows_select_thread, scb, 0,
				&threadId);
d1153 1
a1153 11
  SetEvent (state->exit_select);
  WaitForSingleObject (state->thread, INFINITE);

  CloseHandle (state->read_event);
  CloseHandle (state->except_event);

  CloseHandle (state->start_select);
  CloseHandle (state->stop_select);
  CloseHandle (state->exit_select);
  CloseHandle (state->have_stopped);

@


1.9
log
@	* ser-mingw.c (fd_is_file): New function.
	(file_select_thread): New function.
	(ser_console_wait_handle): Add special handling for files.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.8
log
@        Pass stderr of program run with "target remote |"
        via gdb_stderr.
        * serial.c (serial_open): Set error_fd to -1.
        * serial.h (struct serial): New field error_fd.
        (struct serial_opts): New field avail.
        * ser-pipe.c (pipe_open): Create another pair
        of sockets.  Pass stderr to gdb.
        * ser-mingw.c (pipe_windows_open): Pass
        PEX_STDERR_TO_PIPE to pex_run.  Initialize
        sd->error_fd.
        (pipe_avail): New.
        (_initialize_ser_windows): Hook pipe_avail.
        * ser-base.c (generic_readchar): Check if there's
        anything in stderr channel and route that to gdb_stderr.
@
text
@d456 9
d513 36
d560 1
a560 1
      if (!is_tty && !fd_is_pipe (scb->fd))
d589 3
d593 1
a593 1
	state->thread = CreateThread (NULL, 0, pipe_select_thread, scb, 0,
@


1.7
log
@	* ser-mingw.c (pipe_windows_close): Move variable initialization back
	up.
@
text
@d700 1
d721 2
a722 1
      = pex_run (ps->pex, PEX_SEARCH | PEX_BINARY_INPUT | PEX_BINARY_OUTPUT,
d744 6
a750 1
  scb->fd = fileno (ps->output);
d875 11
d1185 1
@


1.6
log
@        * ser-mingw.c (pipe_windows_open)
        (pipe_windows_read, pipe_windows_write): Declare
        variables at the top of the function.
@
text
@d771 1
a771 1
  HANDLE pipeline_out;
a774 1
  pipeline_out = (HANDLE) _get_osfhandle (scb->fd);
@


1.5
log
@Copyright updates for 2007.
@
text
@d699 2
d706 2
a707 1
  struct pipe_state *ps = make_pipe_state ();
d771 5
a775 1
  HANDLE pipeline_out = (HANDLE) _get_osfhandle (scb->fd);
a778 1
  DWORD available;
a784 1
  DWORD bytes_read;
d796 3
d803 1
a803 1
  HANDLE pipeline_in = (HANDLE) _get_osfhandle (pipeline_in_fd);
a806 1
  DWORD written;
@


1.4
log
@	* ser-mingw.c (free_pipe_state, pipe_wait_handle): Update
	for changes to pipe_select_thread.
	(pipe_done_wait_handle): New.
	(_initialize_ser_windows): Reference it.
@
text
@d3 1
a3 2
   Copyright (C) 2006
   Free Software Foundation, Inc.
@


1.3
log
@2006-04-11  Jim Blandy  <jimb@@codesourcery.com>

	Add support for 'target remote |' on MinGW.
	* ser-mingw.c (struct pipe_state): New structure.
	(make_pipe_state, free_pipe_state, cleanup_pipe_state)
	(pipe_windows_open, pipe_windows_close, pipe_windows_read)
	(pipe_windows_write, pipe_wait_handle): New functions.
	(_initialize_ser_windows): Register a "pipe" interface based on
	them.
@
text
@d661 13
a673 10
    CloseHandle (ps->wait.read_event);
  if (ps->wait.except_event != INVALID_HANDLE_VALUE)
    CloseHandle (ps->wait.except_event);
  if (ps->wait.start_select != INVALID_HANDLE_VALUE)
    CloseHandle (ps->wait.start_select);

  /* If we have a select thread running, let the select thread free
     the stop event.  */
  if (ps->wait.stop_select != INVALID_HANDLE_VALUE)
    SetEvent (ps->wait.stop_select);
d818 2
a819 1
      /* Create auto reset events to wake and terminate the select thread.  */
d822 6
d838 4
d844 1
d846 1
d848 1
d850 11
a860 2
  *read = ps->wait.read_event;
  *except = ps->wait.except_event;
a862 1

d1161 1
@


1.2
log
@	* ser-mingw.c: Include <conio.h>.
	(struct ser_console_state, struct net_windows_state): Add exit_select,
	have_stopped, thread.
	(pipe_select_thread, console_select_thread)
	(net_windows_select_thread): Don't create a local state copy or
	close stop_select.  Exit on exit_select instead of stop_select.  Set
	have_stopped.
	(console_select_thread): Don't report control keypresses as pending
	input.
	(pipe_select_thread): Allow stop_select to interrupt sleeping.
	(set_console_wait_handle): Create exit_select and have_stopped.
	Save the thread handle.  Check _kbhit before starting a thread.
	(ser_console_done_wait_handle): New.
	(ser_console_close): Close new handles.  Wait for the thread to
	exit.
	(new_windows_select_thread): Assert that an event occurred.
	(net_windows_wait_handle): Check for pending input before starting
	a thread.
	(net_windows_done_wait_handle): New.
	(net_windows_open): Create exit_select and have_stopped.
	Save the thread handle.
	(net_windows_close): Close new handles.  Wait for the thread to
	exit.
	(_intiialize_ser_windows): Register done_wait_handle methods.

	* serial.c [USE_WIN32API] (serial_done_wait_handle): New.
	* serial.h [USE_WIN32API] (struct serial_ops): Add done_wait_handle.
	[USE_WIN32API] (serial_done_wait_handle): New prototype.
	* mingw-hdep.c (gdb_select): Use serial_done_wait_handle.
@
text
@d627 211
d1111 28
@


1.1
log
@	* NEWS: Mention native Windows support.
	* Makefile.in (gdb_select_h, ser_tcp_h): New.
	(ALLDEPFILES): Add ser-mingw.c.
	(event-loop.o, inflow.o, mingw-hdep.o, posix-hdep.o, ser-base.o)
	(ser-tcp.o, ser-unix.o): Update.
	(ser-mingw.o): New rule.
	* configure: Regenerated.
	* configure.ac: Add ser-mingw.o for mingw32.
	* ser-mingw.c: New file.
	* event-loop.c: Include "gdb_select.h".
	(gdb_select): Remove, moved to mingw-hdep.c and posix-hdep.c.
	* ser-base.c: Include "gdb_select.h".
	(ser_base_wait_for): Use gdb_select.
	* serial.c (serial_for_fd): New function.
	(serial_fdopen): Try "terminal" before "hardwire".  Initialize
	the allocated struct serial.
	(serial_wait_handle): New function.
	* serial.h (serial_for_fd, serial_wait_handle): New prototypes.
	(struct serial_ops) [USE_WIN32API]: Add wait_handle.
	* gdb_select.h: New file.
	* ser-tcp.c: Include "ser-tcp.h".  Remove unused "ser-unix.h" include.
	(net_close, net_read_prim, net_write_prim): Make global.
	(net_open): Likewise.  Pass an exception set to select.  Whitespace fix.
	Document why we can not use gdb_select.
	(_initialize_ser_tcp) [USE_WIN32API]: Do not register TCP support here.
	* ser-tcp.h: New file.
	* inflow.c (gdb_has_a_terminal): Don't initialize stdin_serial here.
	(handle_sigio): Use gdb_select.
	(initialize_stdin_serial): New function.
	* terminal.h (initialize_stdin_serial): New prototype.
	* top.c (gdb_init): Call initialize_stdin_serial.
	* mingw-hdep.c (gdb_select): New function, moved from gdb_select in
	event-loop.c.  Add exception condition support.  Use serial_for_fd
	and serial_wait_handle.  Fix timeout handling.
	* posix-hdep.c: Include "gdb_select.h".
	(gdb_select): New function.
	* remote-st.c (connect_command): Use gdb_select.
	* ser-unix.c: Include "gdb_select.h".
	(hardwire_send_break, wait_for): Use gdb_select.
@
text
@d29 1
d354 4
d364 2
a365 2
  struct ser_console_state *state, state_copy;
  int event_index, fd;
d368 2
a369 7
  /* Copy useful information out of the control block, to make sure
     that we do not race with freeing it.  */
  state_copy = *(struct ser_console_state *) scb->state;
  state = &state_copy;
  fd = scb->fd;

  h = (HANDLE) _get_osfhandle (fd);
d377 2
d380 1
a380 1
      wait_events[1] = state->stop_select;
d383 3
a385 4
	{
	  CloseHandle (state->stop_select);
	  return 0;
	}
d395 1
a395 4
	{
	  CloseHandle (state->stop_select);
	  return 0;
	}
d416 24
a439 3
	  /* This is really a keypress.  */
	  SetEvent (state->read_event);
	  continue;
d461 2
a462 2
  struct ser_console_state *state, state_copy;
  int event_index, fd;
d465 2
a466 7
  /* Copy useful information out of the control block, to make sure
     that we do not race with freeing it.  */
  state_copy = *(struct ser_console_state *) scb->state;
  state = &state_copy;
  fd = scb->fd;

  h = (HANDLE) _get_osfhandle (fd);
d473 2
d476 1
a476 1
      wait_events[1] = state->stop_select;
d479 3
a481 4
	{
	  CloseHandle (state->stop_select);
	  return 0;
	}
d496 4
a499 5
      if (WaitForSingleObject (state->stop_select, 0) == WAIT_OBJECT_0)
	{
	  CloseHandle (state->stop_select);
	  return 0;
	}
a500 1
      Sleep (10);
d527 2
a528 1
      /* Create auto reset events to wake and terminate the select thread.  */
d531 1
d533 6
a538 2
      /* Create our own events to report read and exceptions separately.
	 The exception event is currently never used.  */
a541 1
      /* And finally start the select thread.  */
d543 2
a544 1
	CreateThread (NULL, 0, console_select_thread, scb, 0, &threadId);
d546 2
a547 1
	CreateThread (NULL, 0, pipe_select_thread, scb, 0, &threadId);
d550 4
d556 1
d558 12
d571 1
d573 10
a582 2
  *read = state->read_event;
  *except = state->except_event;
d592 8
a599 1
      SetEvent (state->stop_select);
d634 3
d638 2
d647 1
a647 1
  int event_index, fd;
d649 1
a649 5
  /* Copy useful information out of the control block, to make sure
     that we do not race with freeing it.  */
  state_copy = *(struct net_windows_state *) scb->state;
  state = &state_copy;
  fd = scb->fd;
d656 2
d659 1
a659 1
      wait_events[1] = state->stop_select;
d662 3
a664 4
	{
	  CloseHandle (state->stop_select);
	  return 0;
	}
d673 1
a673 4
	{
	  CloseHandle (state->stop_select);
	  return 0;
	}
d685 3
a687 1
      WSAEnumNetworkEvents (fd, state->sock_event, &events);
d702 1
d705 31
d737 27
d765 1
d767 7
a773 2
  *read = state->read_event;
  *except = state->except_event;
d791 2
a792 1
  /* Create auto reset events to wake and terminate the select thread.  */
d795 6
d811 2
a812 1
  CreateThread (NULL, 0, net_windows_select_thread, scb, 0, &threadId);
d823 2
a824 1
  SetEvent (state->stop_select);
d828 1
d830 4
d896 1
d929 1
@


1.1.2.1
log
@gdb/ChangeLog:
2006-03-17  Jim Blandy  <jimb@@codesourcery.com>

	Add support for 'target remote |' on MinGW.
	* ser-mingw.c (struct pipe_state): New structure.
	(make_pipe_state, free_pipe_state, cleanup_pipe_state)
	(pipe_windows_open, pipe_windows_close, pipe_windows_read)
	(pipe_windows_write, pipe_wait_handle): New functions.
	(_initialize_ser_windows): Register a "pipe" interface based on
	them.

include/ChangeLog:
2006-03-15  Jim Blandy  <jimb@@codesourcery.com>

	* libiberty.h (pex_write_input): New declaration.

libiberty/ChangeLog:
2006-03-15  Jim Blandy  <jimb@@codesourcery.com>

	* pex-common.c (pex_write_input): New function.
	* pexecute.txh (pex_write_input): Document it.
	* pex-common.h (struct pex_funcs): New function ptr fdopenw.
	* pex-unix.c (pex_unix_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* pex-win32.c (pex_win32_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* pex-djgpp.c (funcs): Leave fdopenw null.
	* pex-msdos (funcs): Same.
	* functions.texi: Regenerated.

2006-03-12  Jim Blandy  <jimb@@red-bean.com>

	* pex-common.h (struct pex_obj): Doc fixes.

2006-03-11  Jim Blandy  <jimb@@red-bean.com>

	* functions.texi: Regenerate.
@
text
@a573 208
struct pipe_state
{
  /* Since we use the pipe_select_thread for our select emulation,
     we need to place the state structure it requires at the front
     of our state.  */
  struct ser_console_state wait;

  /* The pex obj for our (one-stage) pipeline.  */
  struct pex_obj *pex;

  /* Streams for the pipeline's input and output.  */
  FILE *input, *output;
};

static struct pipe_state *
make_pipe_state (void)
{
  struct pipe_state *ps = XMALLOC (struct pipe_state);

  memset (ps, 0, sizeof (*ps));
  ps->wait.read_event = INVALID_HANDLE_VALUE;
  ps->wait.except_event = INVALID_HANDLE_VALUE;
  ps->wait.start_select = INVALID_HANDLE_VALUE;
  ps->wait.stop_select = INVALID_HANDLE_VALUE;

  return ps;
}

static void
free_pipe_state (struct pipe_state *ps)
{
  int saved_errno = errno;

  if (ps->wait.read_event != INVALID_HANDLE_VALUE)
    CloseHandle (ps->wait.read_event);
  if (ps->wait.except_event != INVALID_HANDLE_VALUE)
    CloseHandle (ps->wait.except_event);
  if (ps->wait.start_select != INVALID_HANDLE_VALUE)
    CloseHandle (ps->wait.start_select);

  /* If we have a select thread running, let the select thread free
     the stop event.  */
  if (ps->wait.stop_select != INVALID_HANDLE_VALUE)
    SetEvent (ps->wait.stop_select);

  if (ps->pex)
    pex_free (ps->pex);
  if (ps->input)
    fclose (ps->input);
  /* pex_free closes ps->output.  */

  xfree (ps);

  errno = saved_errno;
}

static void
cleanup_pipe_state (void *untyped)
{
  struct pipe_state *ps = untyped;

  free_pipe_state (ps);
}

static int
pipe_windows_open (struct serial *scb, const char *name)
{
  char **argv = buildargv (name);
  struct cleanup *back_to = make_cleanup_freeargv (argv);
  if (! argv[0] || argv[0][0] == '\0')
    error ("missing child command");

  struct pipe_state *ps = make_pipe_state ();
  make_cleanup (cleanup_pipe_state, ps);

  ps->pex = pex_init (PEX_USE_PIPES, "target remote pipe", NULL);
  if (! ps->pex)
    goto fail;
  ps->input = pex_write_input (ps->pex, 1);
  if (! ps->input)
    goto fail;

  {
    int err;
    const char *err_msg
      = pex_run (ps->pex, PEX_SEARCH | PEX_BINARY_INPUT | PEX_BINARY_OUTPUT,
                 argv[0], argv, NULL, NULL,
                 &err);

    if (err_msg)
      {
        /* Our caller expects us to return -1, but all they'll do with
           it generally is print the message based on errno.  We have
           all the same information here, plus err_msg provided by
           pex_run, so we just raise the error here.  */
        if (err)
          error ("error starting child process '%s': %s: %s",
                 name, err_msg, safe_strerror (err));
        else
          error ("error starting child process '%s': %s",
                 name, err_msg);
      }
  }

  ps->output = pex_read_output (ps->pex, 1);
  if (! ps->output)
    goto fail;

  scb->fd = fileno (ps->output);
  scb->state = (void *) ps;

  discard_cleanups (back_to);
  return 0;

 fail:
  do_cleanups (back_to);
  return -1;
}


static void
pipe_windows_close (struct serial *scb)
{
  struct pipe_state *ps = scb->state;

  /* In theory, we should try to kill the subprocess here, but the pex
     interface doesn't give us enough information to do that.  Usually
     closing the input pipe will get the message across.  */

  free_pipe_state (ps);
}


static int
pipe_windows_read (struct serial *scb, size_t count)
{
  HANDLE pipeline_out = (HANDLE) _get_osfhandle (scb->fd);
  if (pipeline_out == INVALID_HANDLE_VALUE)
    return -1;

  DWORD available;
  if (! PeekNamedPipe (pipeline_out, NULL, 0, NULL, &available, NULL))
    return -1;

  if (count > available)
    count = available;

  DWORD bytes_read;
  if (! ReadFile (pipeline_out, scb->buf, count, &bytes_read, NULL))
    return -1;

  return bytes_read;
}


static int
pipe_windows_write (struct serial *scb, const void *buf, size_t count)
{
  struct pipe_state *ps = scb->state;
  int pipeline_in_fd = fileno (ps->input);
  if (pipeline_in_fd < 0)
    return -1;

  HANDLE pipeline_in = (HANDLE) _get_osfhandle (pipeline_in_fd);
  if (pipeline_in == INVALID_HANDLE_VALUE)
    return -1;

  DWORD written;
  if (! WriteFile (pipeline_in, buf, count, &written, NULL))
    return -1;

  return written;
}


static void
pipe_wait_handle (struct serial *scb, HANDLE *read, HANDLE *except)
{
  struct pipe_state *ps = scb->state;

  /* Have we allocated our events yet?  */
  if (ps->wait.read_event == INVALID_HANDLE_VALUE)
    {
      DWORD threadId;

      /* Create auto reset events to wake and terminate the select thread.  */
      ps->wait.start_select = CreateEvent (0, FALSE, FALSE, 0);
      ps->wait.stop_select = CreateEvent (0, FALSE, FALSE, 0);

      /* Create our own events to report read and exceptions separately.
	 The exception event is currently never used.  */
      ps->wait.read_event = CreateEvent (0, FALSE, FALSE, 0);
      ps->wait.except_event = CreateEvent (0, FALSE, FALSE, 0);

      /* Start the select thread.  */
      CreateThread (NULL, 0, pipe_select_thread, scb, 0, &threadId);
    }

  ResetEvent (ps->wait.read_event);
  ResetEvent (ps->wait.except_event);

  SetEvent (ps->wait.start_select);

  *read = ps->wait.read_event;
  *except = ps->wait.except_event;
}


a765 28
  /* The pipe interface.  */

  ops = XMALLOC (struct serial_ops);
  memset (ops, 0, sizeof (struct serial_ops));
  ops->name = "pipe";
  ops->next = 0;
  ops->open = pipe_windows_open;
  ops->close = pipe_windows_close;
  ops->readchar = ser_base_readchar;
  ops->write = ser_base_write;
  ops->flush_output = ser_base_flush_output;
  ops->flush_input = ser_base_flush_input;
  ops->send_break = ser_base_send_break;
  ops->go_raw = ser_base_raw;
  ops->get_tty_state = ser_base_get_tty_state;
  ops->set_tty_state = ser_base_set_tty_state;
  ops->print_tty_state = ser_base_print_tty_state;
  ops->noflush_set_tty_state = ser_base_noflush_set_tty_state;
  ops->setbaudrate = ser_base_setbaudrate;
  ops->setstopbits = ser_base_setstopbits;
  ops->drain_output = ser_base_drain_output;
  ops->async = ser_base_async;
  ops->read_prim = pipe_windows_read;
  ops->write_prim = pipe_windows_write;
  ops->wait_handle = pipe_wait_handle;

  serial_add_interface (ops);

@


1.1.2.2
log
@	* gdb/ser-mingw.c (free_pipe_state): Close pipe before calling
	pex_free.
@
text
@d619 2
a620 3
  /* Close the pipe to the child.  We must close the pipe before
     calling pex_free because pex_free will wait for the child to exit
     and the child will not exit until the pipe is closed.  */
a622 2
  if (ps->pex)
    pex_free (ps->pex);
@


1.1.2.3
log
@	* gdb/ser-mingw.c (net_windows_state): Add mutex.
	(net_windows_select_thread): Grab lock around access to
	read_event.
	(net_windows_wait_handle): Do not reset the read_event.
	(net_windows_open): Create a mutex.
	(net_windows_read_prim): New function.
	(_initialize_ser_windows): Use it.
@
text
@a786 2
  /* Every access to read_event is guarded by this mutex.  */
  HANDLE mutex;
a843 1
      WaitForSingleObject (state->mutex, INFINITE);
d845 1
a847 1
      ReleaseMutex (state->mutex);
d859 1
a894 3
  /* Guard access to the read_event.  */
  state->mutex = CreateMutex (NULL, FALSE, NULL);

a918 21
static int
net_windows_read_prim (struct serial *scb, size_t count)
{
  struct net_windows_state *state = scb->state;
  int ret;

  /* We're about to call recv.  If any bytes appear after this point,
     we need to be told about them.  So, we must reset the read event.
     However, if we reset the event, then read, we could read all the
     bytes -- and leave the event signaled if the thread notices new
     bytes arriving between the reset and the read.  Similarly, if we
     read, then reset, we could miss new bytes arriving between the
     read and the reset.  So, we must make the read and reset atomic.  */
  WaitForSingleObject (state->mutex, INFINITE);
  ResetEvent (state->read_event);
  ret = net_read_prim (scb, count);
  ReleaseMutex (state->mutex);

  return ret;
}

d1031 1
a1031 1
  ops->read_prim = net_windows_read_prim;
@


