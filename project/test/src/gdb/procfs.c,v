head	1.169;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.167
	gdb_7_6-2013-04-26-release:1.167
	gdb_7_6-branch:1.167.0.2
	gdb_7_6-2013-03-12-branchpoint:1.167
	gdb_7_5_1-2012-11-29-release:1.156
	gdb_7_5-2012-08-17-release:1.156
	gdb_7_5-branch:1.156.0.2
	gdb_7_5-2012-07-18-branchpoint:1.156
	gdb_7_4_1-2012-04-26-release:1.148.2.1
	gdb_7_4-2012-01-24-release:1.148.2.1
	gdb_7_4-branch:1.148.0.2
	gdb_7_4-2011-12-13-branchpoint:1.148
	gdb_7_3_1-2011-09-04-release:1.143
	gdb_7_3-2011-07-26-release:1.143
	gdb_7_3-branch:1.143.0.2
	gdb_7_3-2011-04-01-branchpoint:1.143
	gdb_7_2-2010-09-02-release:1.136
	gdb_7_2-branch:1.136.0.2
	gdb_7_2-2010-07-07-branchpoint:1.136
	gdb_7_1-2010-03-18-release:1.127
	gdb_7_1-branch:1.127.0.2
	gdb_7_1-2010-02-18-branchpoint:1.127
	gdb_7_0_1-2009-12-22-release:1.115
	gdb_7_0-2009-10-06-release:1.115
	gdb_7_0-branch:1.115.0.2
	gdb_7_0-2009-09-16-branchpoint:1.115
	arc-sim-20090309:1.85.2.1
	msnyder-checkpoint-072509-branch:1.114.0.2
	msnyder-checkpoint-072509-branchpoint:1.114
	arc-insight_6_8-branch:1.85.2.1.0.4
	arc-insight_6_8-branchpoint:1.85.2.1
	insight_6_8-branch:1.85.2.1.0.2
	insight_6_8-branchpoint:1.85.2.1
	reverse-20081226-branch:1.97.0.4
	reverse-20081226-branchpoint:1.97
	multiprocess-20081120-branch:1.97.0.2
	multiprocess-20081120-branchpoint:1.97
	reverse-20080930-branch:1.94.0.2
	reverse-20080930-branchpoint:1.94
	reverse-20080717-branch:1.89.0.2
	reverse-20080717-branchpoint:1.89
	msnyder-reverse-20080609-branch:1.88.0.2
	msnyder-reverse-20080609-branchpoint:1.88
	drow-reverse-20070409-branch:1.71.0.2
	drow-reverse-20070409-branchpoint:1.71
	gdb_6_8-2008-03-27-release:1.85.2.1
	gdb_6_8-branch:1.85.0.2
	gdb_6_8-2008-02-26-branchpoint:1.85
	gdb_6_7_1-2007-10-29-release:1.80
	gdb_6_7-2007-10-10-release:1.80
	gdb_6_7-branch:1.80.0.2
	gdb_6_7-2007-09-07-branchpoint:1.80
	insight_6_6-20070208-release:1.70
	gdb_6_6-2006-12-18-release:1.70
	gdb_6_6-branch:1.70.0.2
	gdb_6_6-2006-11-15-branchpoint:1.70
	insight_6_5-20061003-release:1.69
	gdb-csl-symbian-6_4_50_20060226-12:1.68.2.1.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.66.10.1
	nickrob-async-20060828-mergepoint:1.70
	gdb-csl-symbian-6_4_50_20060226-11:1.68.2.1.2.1
	gdb-csl-sourcerygxx-4_1-17:1.68.2.1
	gdb-csl-20060226-branch-local-2:1.68.2.1
	gdb-csl-sourcerygxx-4_1-14:1.68.2.1
	gdb-csl-sourcerygxx-4_1-13:1.68.2.1
	gdb-csl-sourcerygxx-4_1-12:1.68.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.68.2.1
	gdb_6_5-20060621-release:1.69
	gdb-csl-sourcerygxx-4_1-9:1.68.2.1
	gdb-csl-sourcerygxx-4_1-8:1.68.2.1
	gdb-csl-sourcerygxx-4_1-7:1.68.2.1
	gdb-csl-arm-2006q1-6:1.68.2.1
	gdb-csl-sourcerygxx-4_1-6:1.68.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.68.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.68.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.68.2.1.2.1
	gdb-csl-coldfire-4_1-11:1.68.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.68.2.1
	gdb-csl-coldfire-4_1-10:1.68.2.1
	gdb_6_5-branch:1.69.0.8
	gdb_6_5-2006-05-14-branchpoint:1.69
	gdb-csl-sourcerygxx-4_1-5:1.68.2.1
	nickrob-async-20060513-branch:1.69.0.6
	nickrob-async-20060513-branchpoint:1.69
	gdb-csl-sourcerygxx-4_1-4:1.68.2.1
	msnyder-reverse-20060502-branch:1.69.0.4
	msnyder-reverse-20060502-branchpoint:1.69
	gdb-csl-morpho-4_1-4:1.68.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.68.2.1
	readline_5_1-import-branch:1.69.0.2
	readline_5_1-import-branchpoint:1.69
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.68.2.1
	gdb-csl-symbian-20060226-branch:1.68.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.68.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.68.2.1
	msnyder-reverse-20060331-branch:1.68.0.6
	msnyder-reverse-20060331-branchpoint:1.68
	gdb-csl-available-20060303-branch:1.68.0.4
	gdb-csl-available-20060303-branchpoint:1.68
	gdb-csl-20060226-branch:1.68.0.2
	gdb-csl-20060226-branchpoint:1.68
	gdb_6_4-20051202-release:1.66
	msnyder-fork-checkpoint-branch:1.66.0.12
	msnyder-fork-checkpoint-branchpoint:1.66
	gdb-csl-gxxpro-6_3-branch:1.66.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.66
	gdb_6_4-branch:1.66.0.8
	gdb_6_4-2005-11-01-branchpoint:1.66
	gdb-csl-arm-20051020-branch:1.66.0.6
	gdb-csl-arm-20051020-branchpoint:1.66
	msnyder-tracepoint-checkpoint-branch:1.66.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.66
	gdb-csl-arm-20050325-2005-q1b:1.66
	gdb-csl-arm-20050325-2005-q1a:1.66
	csl-arm-20050325-branch:1.66.0.2
	csl-arm-20050325-branchpoint:1.66
	gdb-post-i18n-errorwarning-20050211:1.63
	gdb-pre-i18n-errorwarning-20050211:1.62
	gdb_6_3-20041109-release:1.60
	gdb_6_3-branch:1.60.0.2
	gdb_6_3-20041019-branchpoint:1.60
	drow_intercu-merge-20040921:1.58
	drow_intercu-merge-20040915:1.58
	jimb-gdb_6_2-e500-branch:1.54.0.6
	jimb-gdb_6_2-e500-branchpoint:1.54
	gdb_6_2-20040730-release:1.54
	gdb_6_2-branch:1.54.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.54
	gdb_6_1_1-20040616-release:1.53
	gdb_6_1-2004-04-05-release:1.53
	drow_intercu-merge-20040402:1.53
	drow_intercu-merge-20040327:1.53
	ezannoni_pie-20040323-branch:1.53.0.8
	ezannoni_pie-20040323-branchpoint:1.53
	cagney_tramp-20040321-mergepoint:1.53
	cagney_tramp-20040309-branch:1.53.0.6
	cagney_tramp-20040309-branchpoint:1.53
	gdb_6_1-branch:1.53.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.53
	drow_intercu-20040221-branch:1.53.0.2
	drow_intercu-20040221-branchpoint:1.53
	cagney_bfdfile-20040213-branch:1.52.0.2
	cagney_bfdfile-20040213-branchpoint:1.52
	drow-cplus-merge-20040208:1.52
	carlton_dictionary-20040126-merge:1.50
	cagney_bigcore-20040122-branch:1.50.0.2
	cagney_bigcore-20040122-branchpoint:1.50
	drow-cplus-merge-20040113:1.49
	drow-cplus-merge-20031224:1.49
	drow-cplus-merge-20031220:1.49
	carlton_dictionary-20031215-merge:1.49
	drow-cplus-merge-20031214:1.49
	carlton-dictionary-20031111-merge:1.48
	gdb_6_0-2003-10-04-release:1.46
	kettenis_sparc-20030918-branch:1.47.0.2
	kettenis_sparc-20030918-branchpoint:1.47
	carlton_dictionary-20030917-merge:1.47
	ezannoni_pie-20030916-branchpoint:1.46
	ezannoni_pie-20030916-branch:1.46.0.18
	cagney_x86i386-20030821-branch:1.46.0.16
	cagney_x86i386-20030821-branchpoint:1.46
	carlton_dictionary-20030805-merge:1.46
	carlton_dictionary-20030627-merge:1.46
	gdb_6_0-branch:1.46.0.14
	gdb_6_0-2003-06-23-branchpoint:1.46
	jimb-ppc64-linux-20030613-branch:1.46.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.46
	cagney_convert-20030606-branch:1.46.0.10
	cagney_convert-20030606-branchpoint:1.46
	cagney_writestrings-20030508-branch:1.46.0.8
	cagney_writestrings-20030508-branchpoint:1.46
	jimb-ppc64-linux-20030528-branch:1.46.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.46
	carlton_dictionary-20030523-merge:1.46
	cagney_fileio-20030521-branch:1.46.0.4
	cagney_fileio-20030521-branchpoint:1.46
	kettenis_i386newframe-20030517-mergepoint:1.46
	jimb-ppc64-linux-20030509-branch:1.46.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.46
	kettenis_i386newframe-20030504-mergepoint:1.46
	carlton_dictionary-20030430-merge:1.46
	kettenis_i386newframe-20030419-branch:1.45.0.16
	kettenis_i386newframe-20030419-branchpoint:1.45
	carlton_dictionary-20030416-merge:1.45
	cagney_frameaddr-20030409-mergepoint:1.45
	kettenis_i386newframe-20030406-branch:1.45.0.14
	kettenis_i386newframe-20030406-branchpoint:1.45
	cagney_frameaddr-20030403-branchpoint:1.45
	cagney_frameaddr-20030403-branch:1.45.0.12
	cagney_framebase-20030330-mergepoint:1.45
	cagney_framebase-20030326-branch:1.45.0.10
	cagney_framebase-20030326-branchpoint:1.45
	cagney_lazyid-20030317-branch:1.45.0.8
	cagney_lazyid-20030317-branchpoint:1.45
	kettenis-i386newframe-20030316-mergepoint:1.45
	offbyone-20030313-branch:1.45.0.6
	offbyone-20030313-branchpoint:1.45
	kettenis-i386newframe-20030308-branch:1.45.0.4
	kettenis-i386newframe-20030308-branchpoint:1.45
	carlton_dictionary-20030305-merge:1.45
	cagney_offbyone-20030303-branch:1.45.0.2
	cagney_offbyone-20030303-branchpoint:1.45
	carlton_dictionary-20030207-merge:1.45
	interps-20030203-mergepoint:1.42
	interps-20030202-branch:1.42.0.2
	interps-20030202-branchpoint:1.42
	cagney-unwind-20030108-branch:1.41.0.6
	cagney-unwind-20030108-branchpoint:1.41
	carlton_dictionary-20021223-merge:1.41
	gdb_5_3-2002-12-12-release:1.40
	carlton_dictionary-20021115-merge:1.41
	kseitz_interps-20021105-merge:1.41
	kseitz_interps-20021103-merge:1.41
	drow-cplus-merge-20021020:1.41
	drow-cplus-merge-20021025:1.41
	carlton_dictionary-20021025-merge:1.41
	carlton_dictionary-20021011-merge:1.41
	drow-cplus-branch:1.41.0.4
	drow-cplus-branchpoint:1.41
	kseitz_interps-20020930-merge:1.41
	carlton_dictionary-20020927-merge:1.41
	carlton_dictionary-branch:1.41.0.2
	carlton_dictionary-20020920-branchpoint:1.41
	gdb_5_3-branch:1.40.0.2
	gdb_5_3-2002-09-04-branchpoint:1.40
	kseitz_interps-20020829-merge:1.40
	cagney_sysregs-20020825-branch:1.39.0.4
	cagney_sysregs-20020825-branchpoint:1.39
	readline_4_3-import-branch:1.39.0.2
	readline_4_3-import-branchpoint:1.39
	gdb_5_2_1-2002-07-23-release:1.37
	kseitz_interps-20020528-branch:1.37.0.8
	kseitz_interps-20020528-branchpoint:1.37
	cagney_regbuf-20020515-branch:1.37.0.6
	cagney_regbuf-20020515-branchpoint:1.37
	jimb-macro-020506-branch:1.37.0.4
	jimb-macro-020506-branchpoint:1.37
	gdb_5_2-2002-04-29-release:1.37
	gdb_5_2-branch:1.37.0.2
	gdb_5_2-2002-03-03-branchpoint:1.37
	gdb_5_1_1-2002-01-24-release:1.32
	gdb_5_1_0_1-2002-01-03-release:1.32
	cygnus_cvs_20020108_pre:1.34
	gdb_5_1_0_1-2002-01-03-branchpoint:1.32
	gdb_5_1_0_1-2002-01-03-branch:1.32.0.6
	gdb_5_1-2001-11-21-release:1.32
	gdb_s390-2001-09-26-branch:1.32.0.4
	gdb_s390-2001-09-26-branchpoint:1.32
	gdb_5_1-2001-07-29-branch:1.32.0.2
	gdb_5_1-2001-07-29-branchpoint:1.32
	dberlin-typesystem-branch:1.30.0.2
	dberlin-typesystem-branchpoint:1.30
	gdb-post-ptid_t-2001-05-03:1.29
	gdb-pre-ptid_t-2001-05-03:1.28
	insight-precleanup-2001-01-01:1.21
	gdb-post-protoization-2000-07-29:1.19
	gdb-pre-protoization-2000-07-29:1.18
	gdb-premipsmulti-2000-06-06-branch:1.17.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.17
	gdb-post-params-removal-2000-06-04:1.16
	gdb-pre-params-removal-2000-06-04:1.15
	gdb-post-params-removal-2000-05-28:1.15
	gdb-pre-params-removal-2000-05-28:1.14
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.12
	insight-2000-02-04:1.1.1.12
	gdb-2000-02-04:1.1.1.12
	gdb-2000-02-02:1.1.1.12
	gdb-2000-02-01:1.1.1.12
	gdb-2000-01-31:1.1.1.12
	gdb-2000-01-26:1.1.1.12
	gdb-2000-01-24:1.1.1.12
	gdb-2000-01-17:1.1.1.11
	gdb-2000-01-10:1.1.1.11
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.9
	gdb-1999-12-13:1.1.1.8
	gdb-1999-12-07:1.1.1.8
	gdb-1999-12-06:1.1.1.8
	gdb-1999-11-16:1.1.1.8
	gdb-1999-11-08:1.1.1.8
	gdb-1999-11-01:1.1.1.7
	gdb-1999-10-25:1.1.1.7
	gdb-1999-10-18:1.1.1.7
	gdb-1999-10-11:1.1.1.7
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.169
date	2013.10.04.08.53.27;	author brobecke;	state Exp;
branches;
next	1.168;

1.168
date	2013.09.30.11.50.12;	author luisgpm;	state Exp;
branches;
next	1.167;

1.167
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.166;

1.166
date	2012.12.11.15.23.14;	author palves;	state Exp;
branches;
next	1.165;

1.165
date	2012.12.11.11.32.39;	author palves;	state Exp;
branches;
next	1.164;

1.164
date	2012.11.09.19.58.00;	author tromey;	state Exp;
branches;
next	1.163;

1.163
date	2012.09.27.12.51.57;	author brobecke;	state Exp;
branches;
next	1.162;

1.162
date	2012.09.27.12.51.40;	author brobecke;	state Exp;
branches;
next	1.161;

1.161
date	2012.09.26.21.23.10;	author muller;	state Exp;
branches;
next	1.160;

1.160
date	2012.08.07.13.26.32;	author jkratoch;	state Exp;
branches;
next	1.159;

1.159
date	2012.07.23.14.57.54;	author tromey;	state Exp;
branches;
next	1.158;

1.158
date	2012.07.23.14.56.10;	author tromey;	state Exp;
branches;
next	1.157;

1.157
date	2012.07.18.19.33.34;	author tromey;	state Exp;
branches;
next	1.156;

1.156
date	2012.05.24.16.51.35;	author palves;	state Exp;
branches;
next	1.155;

1.155
date	2012.05.24.16.39.11;	author palves;	state Exp;
branches;
next	1.154;

1.154
date	2012.05.17.17.27.07;	author brobecke;	state Exp;
branches;
next	1.153;

1.153
date	2012.04.27.18.32.33;	author macro;	state Exp;
branches;
next	1.152;

1.152
date	2012.04.25.08.16.42;	author meyering;	state Exp;
branches;
next	1.151;

1.151
date	2012.03.21.13.43.54;	author tschwinge;	state Exp;
branches;
next	1.150;

1.150
date	2012.01.20.09.49.01;	author uweigand;	state Exp;
branches;
next	1.149;

1.149
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.148;

1.148
date	2011.11.10.16.36.28;	author brobecke;	state Exp;
branches
	1.148.2.1;
next	1.147;

1.147
date	2011.11.10.16.36.18;	author brobecke;	state Exp;
branches;
next	1.146;

1.146
date	2011.09.22.10.22.28;	author gingold;	state Exp;
branches;
next	1.145;

1.145
date	2011.04.27.14.28.35;	author brobecke;	state Exp;
branches;
next	1.144;

1.144
date	2011.04.27.13.29.14;	author uweigand;	state Exp;
branches;
next	1.143;

1.143
date	2011.03.09.12.48.55;	author palves;	state Exp;
branches;
next	1.142;

1.142
date	2011.01.11.15.10.01;	author msnyder;	state Exp;
branches;
next	1.141;

1.141
date	2011.01.10.20.38.50;	author msnyder;	state Exp;
branches;
next	1.140;

1.140
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.139;

1.139
date	2011.01.01.15.33.13;	author brobecke;	state Exp;
branches;
next	1.138;

1.138
date	2010.11.28.04.31.24;	author jkratoch;	state Exp;
branches;
next	1.137;

1.137
date	2010.08.31.18.08.43;	author jkratoch;	state Exp;
branches;
next	1.136;

1.136
date	2010.07.07.16.15.16;	author bauermann;	state Exp;
branches;
next	1.135;

1.135
date	2010.07.01.15.36.17;	author palves;	state Exp;
branches;
next	1.134;

1.134
date	2010.05.17.21.47.01;	author msnyder;	state Exp;
branches;
next	1.133;

1.133
date	2010.05.17.10.42.27;	author palves;	state Exp;
branches;
next	1.132;

1.132
date	2010.05.11.21.55.47;	author muller;	state Exp;
branches;
next	1.131;

1.131
date	2010.04.20.22.36.35;	author brobecke;	state Exp;
branches;
next	1.130;

1.130
date	2010.04.20.22.35.57;	author brobecke;	state Exp;
branches;
next	1.129;

1.129
date	2010.04.20.22.35.03;	author brobecke;	state Exp;
branches;
next	1.128;

1.128
date	2010.04.20.22.34.09;	author brobecke;	state Exp;
branches;
next	1.127;

1.127
date	2010.02.15.17.35.49;	author jkratoch;	state Exp;
branches;
next	1.126;

1.126
date	2010.01.28.08.19.29;	author brobecke;	state Exp;
branches;
next	1.125;

1.125
date	2010.01.14.21.15.00;	author jkratoch;	state Exp;
branches;
next	1.124;

1.124
date	2010.01.09.04.44.02;	author brobecke;	state Exp;
branches;
next	1.123;

1.123
date	2010.01.09.04.37.12;	author brobecke;	state Exp;
branches;
next	1.122;

1.122
date	2010.01.09.04.32.51;	author brobecke;	state Exp;
branches;
next	1.121;

1.121
date	2010.01.01.07.31.38;	author brobecke;	state Exp;
branches;
next	1.120;

1.120
date	2009.11.10.21.00.41;	author drow;	state Exp;
branches;
next	1.119;

1.119
date	2009.10.21.08.27.25;	author muller;	state Exp;
branches;
next	1.118;

1.118
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.117;

1.117
date	2009.10.11.22.50.08;	author palves;	state Exp;
branches;
next	1.116;

1.116
date	2009.10.09.01.28.02;	author palves;	state Exp;
branches;
next	1.115;

1.115
date	2009.08.01.00.02.04;	author kazu;	state Exp;
branches;
next	1.114;

1.114
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.113;

1.113
date	2009.07.02.17.12.25;	author uweigand;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.17.18.44.23;	author uweigand;	state Exp;
branches;
next	1.111;

1.111
date	2009.06.07.22.33.24;	author palves;	state Exp;
branches;
next	1.110;

1.110
date	2009.06.07.17.58.24;	author palves;	state Exp;
branches;
next	1.109;

1.109
date	2009.05.25.12.28.57;	author muller;	state Exp;
branches;
next	1.108;

1.108
date	2009.05.18.00.58.38;	author palves;	state Exp;
branches;
next	1.107;

1.107
date	2009.05.11.11.13.08;	author muller;	state Exp;
branches;
next	1.106;

1.106
date	2009.05.06.17.18.52;	author palves;	state Exp;
branches;
next	1.105;

1.105
date	2009.05.05.13.24.49;	author uweigand;	state Exp;
branches;
next	1.104;

1.104
date	2009.04.16.18.41.40;	author brobecke;	state Exp;
branches;
next	1.103;

1.103
date	2009.04.16.17.25.38;	author brobecke;	state Exp;
branches;
next	1.102;

1.102
date	2009.03.17.19.28.09;	author brobecke;	state Exp;
branches;
next	1.101;

1.101
date	2009.02.23.00.03.50;	author palves;	state Exp;
branches;
next	1.100;

1.100
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.99;

1.99
date	2009.01.21.01.20.15;	author kazu;	state Exp;
branches;
next	1.98;

1.98
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.97;

1.97
date	2008.11.09.11.27.17;	author vprus;	state Exp;
branches;
next	1.96;

1.96
date	2008.10.09.13.49.13;	author palves;	state Exp;
branches;
next	1.95;

1.95
date	2008.10.03.16.36.10;	author ppluzhnikov;	state Exp;
branches;
next	1.94;

1.94
date	2008.09.22.15.21.30;	author palves;	state Exp;
branches;
next	1.93;

1.93
date	2008.09.22.15.16.51;	author palves;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.11.14.29.53;	author uweigand;	state Exp;
branches;
next	1.91;

1.91
date	2008.09.08.21.51.18;	author palves;	state Exp;
branches;
next	1.90;

1.90
date	2008.09.08.21.31.53;	author palves;	state Exp;
branches;
next	1.89;

1.89
date	2008.07.09.22.49.56;	author palves;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.04.09.28.27;	author vprus;	state Exp;
branches;
next	1.87;

1.87
date	2008.03.21.15.44.53;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2008.03.12.20.00.21;	author brobecke;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.25.00.09.49;	author msnyder;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2008.01.23.11.26.28;	author vprus;	state Exp;
branches;
next	1.83;

1.83
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2007.12.16.22.19.20;	author jsm28;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.16.04.53.46;	author deuling;	state Exp;
branches;
next	1.80;

1.80
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.13.17.59.50;	author uweigand;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.13.17.30.01;	author uweigand;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.06.15.23.06;	author uweigand;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.06.14.32.30;	author uweigand;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.09.17.58.56;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.12.18.13.45;	author drow;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches
	1.69.6.1;
next	1.68;

1.68
date	2006.01.24.22.09.28;	author drow;	state Exp;
branches
	1.68.2.1
	1.68.4.1;
next	1.67;

1.67
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.66;

1.66
date	2005.02.15.15.49.14;	author cagney;	state Exp;
branches
	1.66.6.1
	1.66.10.1;
next	1.65;

1.65
date	2005.02.12.00.39.20;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2005.02.11.04.06.01;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2004.10.30.21.30.58;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2004.10.30.18.01.11;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2004.10.08.20.29.47;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.05.11.24.21;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2004.08.27.13.37.42;	author brobecke;	state Exp;
branches;
next	1.57;

1.57
date	2004.08.11.06.55.15;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2004.08.10.16.05.38;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2004.08.08.01.00.55;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2004.05.25.14.58.30;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.15.22.38.40;	author cagney;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2004.02.01.22.35.13;	author roland;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.29.21.54.22;	author roland;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.17.18.24.15;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2003.11.22.22.43.05;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.17.15.42.19;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches
	1.46.18.1;
next	1.45;

1.45
date	2003.02.07.04.49.34;	author cagney;	state Exp;
branches
	1.45.16.1;
next	1.44;

1.44
date	2003.02.07.04.21.34;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2003.02.07.03.23.20;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.01.23.34.05;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.11.00.13.58;	author msnyder;	state Exp;
branches
	1.41.2.1
	1.41.4.1;
next	1.40;

1.40
date	2002.08.26.19.18.33;	author ciceron;	state Exp;
branches;
next	1.39;

1.39
date	2002.08.13.18.03.37;	author kevinb;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.14.01.57.36;	author msnyder;	state Exp;
branches
	1.37.8.1;
next	1.36;

1.36
date	2002.02.13.22.03.46;	author msnyder;	state Exp;
branches;
next	1.35;

1.35
date	2002.01.09.00.36.58;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.03.20.50.25;	author msnyder;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.28.19.47.08;	author msnyder;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.07.21.55.28;	author kevinb;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.06.21.31.04;	author msnyder;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.15.00.03.36;	author kevinb;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.17.01.24.49;	author kevinb;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.13.13.51.54;	author fnasser;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.27.02.01.11;	author kevinb;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.20.01.37.09;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.15.16.55.14;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.16.17.41.51;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.30.02.39.10;	author kevinb;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.12.01.33.49;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.04.13.46.37;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.26.23.22.40;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.25.06.49.01;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.22.06.17.35;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.10.17.38.16;	author msnyder;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.07.23.09.45;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.05.20.56.10;	author msnyder;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.05.18.29.33;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.02.09.36.56;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.27.01.04.52;	author msnyder;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.07.04.33.21;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.28.19.02.47;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.29.13.53.59;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.16.08.02.57;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.148.2.1
date	2012.01.06.04.43.25;	author brobecke;	state Exp;
branches;
next	;

1.85.2.1
date	2008.03.12.20.03.12;	author brobecke;	state Exp;
branches;
next	;

1.69.6.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.68.2.1
date	2006.04.03.00.47.40;	author drow;	state Exp;
branches
	1.68.2.1.2.1;
next	;

1.68.2.1.2.1
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	;

1.68.4.1
date	2006.03.03.20.46.37;	author drow;	state Exp;
branches;
next	;

1.66.6.1
date	2006.01.26.18.05.55;	author drow;	state Exp;
branches;
next	;

1.66.10.1
date	2006.01.26.18.10.22;	author drow;	state Exp;
branches;
next	;

1.53.2.1
date	2004.09.16.17.01.17;	author drow;	state Exp;
branches;
next	;

1.46.18.1
date	2003.09.29.22.40.19;	author ezannoni;	state Exp;
branches;
next	;

1.45.16.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	;

1.41.2.1
date	2003.02.07.19.17.51;	author carlton;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2003.05.01.00.46.51;	author carlton;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2003.09.17.21.28.28;	author carlton;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2003.11.11.23.50.52;	author carlton;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2003.12.16.00.00.46;	author carlton;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2004.01.26.19.11.29;	author carlton;	state Exp;
branches;
next	;

1.41.4.1
date	2003.12.14.20.27.28;	author drow;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	2004.02.09.19.43.46;	author drow;	state Exp;
branches;
next	;

1.37.8.1
date	2002.07.22.21.47.01;	author kseitz;	state Exp;
branches;
next	1.37.8.2;

1.37.8.2
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	1.37.8.3;

1.37.8.3
date	2002.10.01.00.46.13;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.58;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.46;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.08.47;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.31.01.05.41;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.28.21.52.24;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.10.05.23.08.37;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.11.09.01.23.06;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.12.22.21.45.08;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2000.01.06.03.06.41;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2000.01.11.03.07.23;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2000.01.25.02.39.50;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.169
log
@Fix build failure in procfs.c after MERGEPID -> ptid_build conversion.

gdb/ChangeLog:

        * procfs.c (procfs_init_inferior): Fix typo causing the build
        to fail.
@
text
@/* Machine independent support for SVR4 /proc (process file system) for GDB.

   Copyright (C) 1999-2013 Free Software Foundation, Inc.

   Written by Michael Snyder at Cygnus Solutions.
   Based on work by Fred Fish, Stu Grossman, Geoff Noer, and others.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "inferior.h"
#include "target.h"
#include "gdbcore.h"
#include "elf-bfd.h"		/* for elfcore_write_* */
#include "gdbcmd.h"
#include "gdbthread.h"
#include "regcache.h"
#include "inf-child.h"

#if defined (NEW_PROC_API)
#define _STRUCTURED_PROC 1	/* Should be done by configure script.  */
#endif

#include <sys/procfs.h>
#ifdef HAVE_SYS_FAULT_H
#include <sys/fault.h>
#endif
#ifdef HAVE_SYS_SYSCALL_H
#include <sys/syscall.h>
#endif
#include <sys/errno.h>
#include "gdb_wait.h"
#include <signal.h>
#include <ctype.h>
#include "gdb_bfd.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "inflow.h"
#include "auxv.h"
#include "procfs.h"
#include "observer.h"

/* This module provides the interface between GDB and the
   /proc file system, which is used on many versions of Unix
   as a means for debuggers to control other processes.

   Examples of the systems that use this interface are:

     Irix
     Solaris
     OSF
     AIX5

   /proc works by imitating a file system: you open a simulated file
   that represents the process you wish to interact with, and perform
   operations on that "file" in order to examine or change the state
   of the other process.

   The most important thing to know about /proc and this module is
   that there are two very different interfaces to /proc:

     One that uses the ioctl system call, and another that uses read
     and write system calls.

   This module has to support both /proc interfaces.  This means that
   there are two different ways of doing every basic operation.

   In order to keep most of the code simple and clean, I have defined
   an interface "layer" which hides all these system calls.  An ifdef
   (NEW_PROC_API) determines which interface we are using, and most or
   all occurrances of this ifdef should be confined to this interface
   layer.  */

/* Determine which /proc API we are using: The ioctl API defines
   PIOCSTATUS, while the read/write (multiple fd) API never does.  */

#ifdef NEW_PROC_API
#include <sys/types.h>
#include "gdb_dirent.h"	/* opendir/readdir, for listing the LWP's */
#endif

#include <fcntl.h>	/* for O_RDONLY */
#include <unistd.h>	/* for "X_OK" */
#include "gdb_stat.h"	/* for struct stat */

/* Note: procfs-utils.h must be included after the above system header
   files, because it redefines various system calls using macros.
   This may be incompatible with the prototype declarations.  */

#include "proc-utils.h"

/* Prototypes for supply_gregset etc.  */
#include "gregset.h"

/* =================== TARGET_OPS "MODULE" =================== */

/* This module defines the GDB target vector and its methods.  */

static void procfs_attach (struct target_ops *, char *, int);
static void procfs_detach (struct target_ops *, char *, int);
static void procfs_resume (struct target_ops *,
			   ptid_t, int, enum gdb_signal);
static void procfs_stop (ptid_t);
static void procfs_files_info (struct target_ops *);
static void procfs_fetch_registers (struct target_ops *,
				    struct regcache *, int);
static void procfs_store_registers (struct target_ops *,
				    struct regcache *, int);
static void procfs_pass_signals (int, unsigned char *);
static void procfs_kill_inferior (struct target_ops *ops);
static void procfs_mourn_inferior (struct target_ops *ops);
static void procfs_create_inferior (struct target_ops *, char *,
				    char *, char **, int);
static ptid_t procfs_wait (struct target_ops *,
			   ptid_t, struct target_waitstatus *, int);
static int procfs_xfer_memory (CORE_ADDR, gdb_byte *, int, int,
			       struct mem_attrib *attrib,
			       struct target_ops *);
static LONGEST procfs_xfer_partial (struct target_ops *ops,
				    enum target_object object,
				    const char *annex,
				    gdb_byte *readbuf,
				    const gdb_byte *writebuf,
				    ULONGEST offset, LONGEST len);

static int procfs_thread_alive (struct target_ops *ops, ptid_t);

static void procfs_find_new_threads (struct target_ops *ops);
static char *procfs_pid_to_str (struct target_ops *, ptid_t);

static int proc_find_memory_regions (find_memory_region_ftype, void *);

static char * procfs_make_note_section (bfd *, int *);

static int procfs_can_use_hw_breakpoint (int, int, int);

static void procfs_info_proc (struct target_ops *, char *,
			      enum info_proc_what);

#if defined (PR_MODEL_NATIVE) && (PR_MODEL_NATIVE == PR_MODEL_LP64)
/* When GDB is built as 64-bit application on Solaris, the auxv data
   is presented in 64-bit format.  We need to provide a custom parser
   to handle that.  */
static int
procfs_auxv_parse (struct target_ops *ops, gdb_byte **readptr,
		   gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp)
{
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
  gdb_byte *ptr = *readptr;

  if (endptr == ptr)
    return 0;

  if (endptr - ptr < 8 * 2)
    return -1;

  *typep = extract_unsigned_integer (ptr, 4, byte_order);
  ptr += 8;
  /* The size of data is always 64-bit.  If the application is 32-bit,
     it will be zero extended, as expected.  */
  *valp = extract_unsigned_integer (ptr, 8, byte_order);
  ptr += 8;

  *readptr = ptr;
  return 1;
}
#endif

struct target_ops *
procfs_target (void)
{
  struct target_ops *t = inf_child_target ();

  t->to_shortname = "procfs";
  t->to_longname = "Unix /proc child process";
  t->to_doc =
    "Unix /proc child process (started by the \"run\" command).";
  t->to_create_inferior = procfs_create_inferior;
  t->to_kill = procfs_kill_inferior;
  t->to_mourn_inferior = procfs_mourn_inferior;
  t->to_attach = procfs_attach;
  t->to_detach = procfs_detach;
  t->to_wait = procfs_wait;
  t->to_resume = procfs_resume;
  t->to_fetch_registers = procfs_fetch_registers;
  t->to_store_registers = procfs_store_registers;
  t->to_xfer_partial = procfs_xfer_partial;
  t->deprecated_xfer_memory = procfs_xfer_memory;
  t->to_pass_signals = procfs_pass_signals;
  t->to_files_info = procfs_files_info;
  t->to_stop = procfs_stop;

  t->to_find_new_threads = procfs_find_new_threads;
  t->to_thread_alive = procfs_thread_alive;
  t->to_pid_to_str = procfs_pid_to_str;

  t->to_has_thread_control = tc_schedlock;
  t->to_find_memory_regions = proc_find_memory_regions;
  t->to_make_corefile_notes = procfs_make_note_section;
  t->to_info_proc = procfs_info_proc;

#if defined(PR_MODEL_NATIVE) && (PR_MODEL_NATIVE == PR_MODEL_LP64)
  t->to_auxv_parse = procfs_auxv_parse;
#endif

  t->to_magic = OPS_MAGIC;

  return t;
}

/* =================== END, TARGET_OPS "MODULE" =================== */

/* World Unification:

   Put any typedefs, defines etc. here that are required for the
   unification of code that handles different versions of /proc.  */

#ifdef NEW_PROC_API		/* Solaris 7 && 8 method for watchpoints */
#ifdef WA_READ
     enum { READ_WATCHFLAG  = WA_READ,
	    WRITE_WATCHFLAG = WA_WRITE,
	    EXEC_WATCHFLAG  = WA_EXEC,
	    AFTER_WATCHFLAG = WA_TRAPAFTER
     };
#endif
#else				/* Irix method for watchpoints */
     enum { READ_WATCHFLAG  = MA_READ,
	    WRITE_WATCHFLAG = MA_WRITE,
	    EXEC_WATCHFLAG  = MA_EXEC,
	    AFTER_WATCHFLAG = 0		/* trapafter not implemented */
     };
#endif

/* gdb_sigset_t */
#ifdef HAVE_PR_SIGSET_T
typedef pr_sigset_t gdb_sigset_t;
#else
typedef sigset_t gdb_sigset_t;
#endif

/* sigaction */
#ifdef HAVE_PR_SIGACTION64_T
typedef pr_sigaction64_t gdb_sigaction_t;
#else
typedef struct sigaction gdb_sigaction_t;
#endif

/* siginfo */
#ifdef HAVE_PR_SIGINFO64_T
typedef pr_siginfo64_t gdb_siginfo_t;
#else
typedef siginfo_t gdb_siginfo_t;
#endif

/* On mips-irix, praddset and prdelset are defined in such a way that
   they return a value, which causes GCC to emit a -Wunused error
   because the returned value is not used.  Prevent this warning
   by casting the return value to void.  On sparc-solaris, this issue
   does not exist because the definition of these macros already include
   that cast to void.  */
#define gdb_praddset(sp, flag) ((void) praddset (sp, flag))
#define gdb_prdelset(sp, flag) ((void) prdelset (sp, flag))

/* gdb_premptysysset */
#ifdef premptysysset
#define gdb_premptysysset premptysysset
#else
#define gdb_premptysysset premptyset
#endif

/* praddsysset */
#ifdef praddsysset
#define gdb_praddsysset praddsysset
#else
#define gdb_praddsysset gdb_praddset
#endif

/* prdelsysset */
#ifdef prdelsysset
#define gdb_prdelsysset prdelsysset
#else
#define gdb_prdelsysset gdb_prdelset
#endif

/* prissyssetmember */
#ifdef prissyssetmember
#define gdb_pr_issyssetmember prissyssetmember
#else
#define gdb_pr_issyssetmember prismember
#endif

/* As a feature test, saying ``#if HAVE_PRSYSENT_T'' everywhere isn't
   as intuitively descriptive as it could be, so we'll define
   DYNAMIC_SYSCALLS to mean the same thing.  Anyway, at the time of
   this writing, this feature is only found on AIX5 systems and
   basically means that the set of syscalls is not fixed.  I.e,
   there's no nice table that one can #include to get all of the
   syscall numbers.  Instead, they're stored in /proc/PID/sysent
   for each process.  We are at least guaranteed that they won't
   change over the lifetime of the process.  But each process could
   (in theory) have different syscall numbers.  */
#ifdef HAVE_PRSYSENT_T
#define DYNAMIC_SYSCALLS
#endif



/* =================== STRUCT PROCINFO "MODULE" =================== */

     /* FIXME: this comment will soon be out of date W.R.T. threads.  */

/* The procinfo struct is a wrapper to hold all the state information
   concerning a /proc process.  There should be exactly one procinfo
   for each process, and since GDB currently can debug only one
   process at a time, that means there should be only one procinfo.
   All of the LWP's of a process can be accessed indirectly thru the
   single process procinfo.

   However, against the day when GDB may debug more than one process,
   this data structure is kept in a list (which for now will hold no
   more than one member), and many functions will have a pointer to a
   procinfo as an argument.

   There will be a separate procinfo structure for use by the (not yet
   implemented) "info proc" command, so that we can print useful
   information about any random process without interfering with the
   inferior's procinfo information.  */

#ifdef NEW_PROC_API
/* format strings for /proc paths */
# ifndef CTL_PROC_NAME_FMT
#  define MAIN_PROC_NAME_FMT   "/proc/%d"
#  define CTL_PROC_NAME_FMT    "/proc/%d/ctl"
#  define AS_PROC_NAME_FMT     "/proc/%d/as"
#  define MAP_PROC_NAME_FMT    "/proc/%d/map"
#  define STATUS_PROC_NAME_FMT "/proc/%d/status"
#  define MAX_PROC_NAME_SIZE sizeof("/proc/99999/lwp/8096/lstatus")
# endif
/* the name of the proc status struct depends on the implementation */
typedef pstatus_t   gdb_prstatus_t;
typedef lwpstatus_t gdb_lwpstatus_t;
#else /* ! NEW_PROC_API */
/* format strings for /proc paths */
# ifndef CTL_PROC_NAME_FMT
#  define MAIN_PROC_NAME_FMT   "/proc/%05d"
#  define CTL_PROC_NAME_FMT    "/proc/%05d"
#  define AS_PROC_NAME_FMT     "/proc/%05d"
#  define MAP_PROC_NAME_FMT    "/proc/%05d"
#  define STATUS_PROC_NAME_FMT "/proc/%05d"
#  define MAX_PROC_NAME_SIZE sizeof("/proc/ttttppppp")
# endif
/* The name of the proc status struct depends on the implementation.  */
typedef prstatus_t gdb_prstatus_t;
typedef prstatus_t gdb_lwpstatus_t;
#endif /* NEW_PROC_API */

typedef struct procinfo {
  struct procinfo *next;
  int pid;			/* Process ID    */
  int tid;			/* Thread/LWP id */

  /* process state */
  int was_stopped;
  int ignore_next_sigstop;

  /* The following four fd fields may be identical, or may contain
     several different fd's, depending on the version of /proc
     (old ioctl or new read/write).  */

  int ctl_fd;			/* File descriptor for /proc control file */

  /* The next three file descriptors are actually only needed in the
     read/write, multiple-file-descriptor implemenation
     (NEW_PROC_API).  However, to avoid a bunch of #ifdefs in the
     code, we will use them uniformly by (in the case of the ioctl
     single-file-descriptor implementation) filling them with copies
     of the control fd.  */
  int status_fd;		/* File descriptor for /proc status file */
  int as_fd;			/* File descriptor for /proc as file */

  char pathname[MAX_PROC_NAME_SIZE];	/* Pathname to /proc entry */

  fltset_t saved_fltset;	/* Saved traced hardware fault set */
  gdb_sigset_t saved_sigset;	/* Saved traced signal set */
  gdb_sigset_t saved_sighold;	/* Saved held signal set */
  sysset_t *saved_exitset;	/* Saved traced system call exit set */
  sysset_t *saved_entryset;	/* Saved traced system call entry set */

  gdb_prstatus_t prstatus;	/* Current process status info */

#ifndef NEW_PROC_API
  gdb_fpregset_t fpregset;	/* Current floating point registers */
#endif

#ifdef DYNAMIC_SYSCALLS
  int num_syscalls;		/* Total number of syscalls */
  char **syscall_names;		/* Syscall number to name map */
#endif

  struct procinfo *thread_list;

  int status_valid : 1;
  int gregs_valid  : 1;
  int fpregs_valid : 1;
  int threads_valid: 1;
} procinfo;

static char errmsg[128];	/* shared error msg buffer */

/* Function prototypes for procinfo module: */

static procinfo *find_procinfo_or_die (int pid, int tid);
static procinfo *find_procinfo (int pid, int tid);
static procinfo *create_procinfo (int pid, int tid);
static void destroy_procinfo (procinfo * p);
static void do_destroy_procinfo_cleanup (void *);
static void dead_procinfo (procinfo * p, char *msg, int killp);
static int open_procinfo_files (procinfo * p, int which);
static void close_procinfo_files (procinfo * p);
static int sysset_t_size (procinfo *p);
static sysset_t *sysset_t_alloc (procinfo * pi);
#ifdef DYNAMIC_SYSCALLS
static void load_syscalls (procinfo *pi);
static void free_syscalls (procinfo *pi);
static int find_syscall (procinfo *pi, char *name);
#endif /* DYNAMIC_SYSCALLS */

static int iterate_over_mappings
  (procinfo *pi, find_memory_region_ftype child_func, void *data,
   int (*func) (struct prmap *map, find_memory_region_ftype child_func,
		void *data));

/* The head of the procinfo list: */
static procinfo * procinfo_list;

/* Search the procinfo list.  Return a pointer to procinfo, or NULL if
   not found.  */

static procinfo *
find_procinfo (int pid, int tid)
{
  procinfo *pi;

  for (pi = procinfo_list; pi; pi = pi->next)
    if (pi->pid == pid)
      break;

  if (pi)
    if (tid)
      {
	/* Don't check threads_valid.  If we're updating the
	   thread_list, we want to find whatever threads are already
	   here.  This means that in general it is the caller's
	   responsibility to check threads_valid and update before
	   calling find_procinfo, if the caller wants to find a new
	   thread.  */

	for (pi = pi->thread_list; pi; pi = pi->next)
	  if (pi->tid == tid)
	    break;
      }

  return pi;
}

/* Calls find_procinfo, but errors on failure.  */

static procinfo *
find_procinfo_or_die (int pid, int tid)
{
  procinfo *pi = find_procinfo (pid, tid);

  if (pi == NULL)
    {
      if (tid)
	error (_("procfs: couldn't find pid %d "
		 "(kernel thread %d) in procinfo list."),
	       pid, tid);
      else
	error (_("procfs: couldn't find pid %d in procinfo list."), pid);
    }
  return pi;
}

/* Wrapper for `open'.  The appropriate open call is attempted; if
   unsuccessful, it will be retried as many times as needed for the
   EAGAIN and EINTR conditions.

   For other conditions, retry the open a limited number of times.  In
   addition, a short sleep is imposed prior to retrying the open.  The
   reason for this sleep is to give the kernel a chance to catch up
   and create the file in question in the event that GDB "wins" the
   race to open a file before the kernel has created it.  */

static int
open_with_retry (const char *pathname, int flags)
{
  int retries_remaining, status;

  retries_remaining = 2;

  while (1)
    {
      status = open (pathname, flags);

      if (status >= 0 || retries_remaining == 0)
	break;
      else if (errno != EINTR && errno != EAGAIN)
	{
	  retries_remaining--;
	  sleep (1);
	}
    }

  return status;
}

/* Open the file descriptor for the process or LWP.  If NEW_PROC_API
   is defined, we only open the control file descriptor; the others
   are opened lazily as needed.  Otherwise (if not NEW_PROC_API),
   there is only one real file descriptor, but we keep multiple copies
   of it so that the code that uses them does not have to be #ifdef'd.
   Returns the file descriptor, or zero for failure.  */

enum { FD_CTL, FD_STATUS, FD_AS };

static int
open_procinfo_files (procinfo *pi, int which)
{
#ifdef NEW_PROC_API
  char tmp[MAX_PROC_NAME_SIZE];
#endif
  int  fd;

  /* This function is getting ALMOST long enough to break up into
     several.  Here is some rationale:

     NEW_PROC_API (Solaris 2.6, Solaris 2.7):
     There are several file descriptors that may need to be open
       for any given process or LWP.  The ones we're intereted in are:
	 - control	 (ctl)	  write-only	change the state
	 - status	 (status) read-only	query the state
	 - address space (as)	  read/write	access memory
	 - map		 (map)	  read-only	virtual addr map
       Most of these are opened lazily as they are needed.
       The pathnames for the 'files' for an LWP look slightly
       different from those of a first-class process:
	 Pathnames for a process (<proc-id>):
	   /proc/<proc-id>/ctl
	   /proc/<proc-id>/status
	   /proc/<proc-id>/as
	   /proc/<proc-id>/map
	 Pathnames for an LWP (lwp-id):
	   /proc/<proc-id>/lwp/<lwp-id>/lwpctl
	   /proc/<proc-id>/lwp/<lwp-id>/lwpstatus
       An LWP has no map or address space file descriptor, since
       the memory map and address space are shared by all LWPs.

     Everyone else (Solaris 2.5, Irix, OSF)
       There is only one file descriptor for each process or LWP.
       For convenience, we copy the same file descriptor into all
       three fields of the procinfo struct (ctl_fd, status_fd, and
       as_fd, see NEW_PROC_API above) so that code that uses them
       doesn't need any #ifdef's.
	 Pathname for all:
	   /proc/<proc-id>

       Solaris 2.5 LWP's:
	 Each LWP has an independent file descriptor, but these
	 are not obtained via the 'open' system call like the rest:
	 instead, they're obtained thru an ioctl call (PIOCOPENLWP)
	 to the file descriptor of the parent process.

       OSF threads:
	 These do not even have their own independent file descriptor.
	 All operations are carried out on the file descriptor of the
	 parent process.  Therefore we just call open again for each
	 thread, getting a new handle for the same 'file'.  */

#ifdef NEW_PROC_API
  /* In this case, there are several different file descriptors that
     we might be asked to open.  The control file descriptor will be
     opened early, but the others will be opened lazily as they are
     needed.  */

  strcpy (tmp, pi->pathname);
  switch (which) {	/* Which file descriptor to open?  */
  case FD_CTL:
    if (pi->tid)
      strcat (tmp, "/lwpctl");
    else
      strcat (tmp, "/ctl");
    fd = open_with_retry (tmp, O_WRONLY);
    if (fd < 0)
      return 0;		/* fail */
    pi->ctl_fd = fd;
    break;
  case FD_AS:
    if (pi->tid)
      return 0;		/* There is no 'as' file descriptor for an lwp.  */
    strcat (tmp, "/as");
    fd = open_with_retry (tmp, O_RDWR);
    if (fd < 0)
      return 0;		/* fail */
    pi->as_fd = fd;
    break;
  case FD_STATUS:
    if (pi->tid)
      strcat (tmp, "/lwpstatus");
    else
      strcat (tmp, "/status");
    fd = open_with_retry (tmp, O_RDONLY);
    if (fd < 0)
      return 0;		/* fail */
    pi->status_fd = fd;
    break;
  default:
    return 0;		/* unknown file descriptor */
  }
#else  /* not NEW_PROC_API */
  /* In this case, there is only one file descriptor for each procinfo
     (ie. each process or LWP).  In fact, only the file descriptor for
     the process can actually be opened by an 'open' system call.  The
     ones for the LWPs have to be obtained thru an IOCTL call on the
     process's file descriptor.

     For convenience, we copy each procinfo's single file descriptor
     into all of the fields occupied by the several file descriptors
     of the NEW_PROC_API implementation.  That way, the code that uses
     them can be written without ifdefs.  */


#ifdef PIOCTSTATUS	/* OSF */
  /* Only one FD; just open it.  */
  if ((fd = open_with_retry (pi->pathname, O_RDWR)) < 0)
    return 0;
#else			/* Sol 2.5, Irix, other?  */
  if (pi->tid == 0)	/* Master procinfo for the process */
    {
      fd = open_with_retry (pi->pathname, O_RDWR);
      if (fd < 0)
	return 0;	/* fail */
    }
  else			/* LWP thread procinfo */
    {
#ifdef PIOCOPENLWP	/* Sol 2.5, thread/LWP */
      procinfo *process;
      int lwpid = pi->tid;

      /* Find the procinfo for the entire process.  */
      if ((process = find_procinfo (pi->pid, 0)) == NULL)
	return 0;	/* fail */

      /* Now obtain the file descriptor for the LWP.  */
      if ((fd = ioctl (process->ctl_fd, PIOCOPENLWP, &lwpid)) < 0)
	return 0;	/* fail */
#else			/* Irix, other?  */
      return 0;		/* Don't know how to open threads.  */
#endif	/* Sol 2.5 PIOCOPENLWP */
    }
#endif	/* OSF     PIOCTSTATUS */
  pi->ctl_fd = pi->as_fd = pi->status_fd = fd;
#endif	/* NEW_PROC_API */

  return 1;		/* success */
}

/* Allocate a data structure and link it into the procinfo list.
   First tries to find a pre-existing one (FIXME: why?).  Returns the
   pointer to new procinfo struct.  */

static procinfo *
create_procinfo (int pid, int tid)
{
  procinfo *pi, *parent = NULL;

  if ((pi = find_procinfo (pid, tid)))
    return pi;			/* Already exists, nothing to do.  */

  /* Find parent before doing malloc, to save having to cleanup.  */
  if (tid != 0)
    parent = find_procinfo_or_die (pid, 0);	/* FIXME: should I
						   create it if it
						   doesn't exist yet?  */

  pi = (procinfo *) xmalloc (sizeof (procinfo));
  memset (pi, 0, sizeof (procinfo));
  pi->pid = pid;
  pi->tid = tid;

#ifdef DYNAMIC_SYSCALLS
  load_syscalls (pi);
#endif

  pi->saved_entryset = sysset_t_alloc (pi);
  pi->saved_exitset = sysset_t_alloc (pi);

  /* Chain into list.  */
  if (tid == 0)
    {
      sprintf (pi->pathname, MAIN_PROC_NAME_FMT, pid);
      pi->next = procinfo_list;
      procinfo_list = pi;
    }
  else
    {
#ifdef NEW_PROC_API
      sprintf (pi->pathname, "/proc/%05d/lwp/%d", pid, tid);
#else
      sprintf (pi->pathname, MAIN_PROC_NAME_FMT, pid);
#endif
      pi->next = parent->thread_list;
      parent->thread_list = pi;
    }
  return pi;
}

/* Close all file descriptors associated with the procinfo.  */

static void
close_procinfo_files (procinfo *pi)
{
  if (pi->ctl_fd > 0)
    close (pi->ctl_fd);
#ifdef NEW_PROC_API
  if (pi->as_fd > 0)
    close (pi->as_fd);
  if (pi->status_fd > 0)
    close (pi->status_fd);
#endif
  pi->ctl_fd = pi->as_fd = pi->status_fd = 0;
}

/* Destructor function.  Close, unlink and deallocate the object.  */

static void
destroy_one_procinfo (procinfo **list, procinfo *pi)
{
  procinfo *ptr;

  /* Step one: unlink the procinfo from its list.  */
  if (pi == *list)
    *list = pi->next;
  else
    for (ptr = *list; ptr; ptr = ptr->next)
      if (ptr->next == pi)
	{
	  ptr->next =  pi->next;
	  break;
	}

  /* Step two: close any open file descriptors.  */
  close_procinfo_files (pi);

  /* Step three: free the memory.  */
#ifdef DYNAMIC_SYSCALLS
  free_syscalls (pi);
#endif
  xfree (pi->saved_entryset);
  xfree (pi->saved_exitset);
  xfree (pi);
}

static void
destroy_procinfo (procinfo *pi)
{
  procinfo *tmp;

  if (pi->tid != 0)	/* Destroy a thread procinfo.  */
    {
      tmp = find_procinfo (pi->pid, 0);	/* Find the parent process.  */
      destroy_one_procinfo (&tmp->thread_list, pi);
    }
  else			/* Destroy a process procinfo and all its threads.  */
    {
      /* First destroy the children, if any; */
      while (pi->thread_list != NULL)
	destroy_one_procinfo (&pi->thread_list, pi->thread_list);
      /* Then destroy the parent.  Genocide!!!  */
      destroy_one_procinfo (&procinfo_list, pi);
    }
}

static void
do_destroy_procinfo_cleanup (void *pi)
{
  destroy_procinfo (pi);
}

enum { NOKILL, KILL };

/* To be called on a non_recoverable error for a procinfo.  Prints
   error messages, optionally sends a SIGKILL to the process, then
   destroys the data structure.  */

static void
dead_procinfo (procinfo *pi, char *msg, int kill_p)
{
  char procfile[80];

  if (pi->pathname)
    {
      print_sys_errmsg (pi->pathname, errno);
    }
  else
    {
      sprintf (procfile, "process %d", pi->pid);
      print_sys_errmsg (procfile, errno);
    }
  if (kill_p == KILL)
    kill (pi->pid, SIGKILL);

  destroy_procinfo (pi);
  error ("%s", msg);
}

/* Returns the (complete) size of a sysset_t struct.  Normally, this
   is just sizeof (sysset_t), but in the case of Monterey/64, the
   actual size of sysset_t isn't known until runtime.  */

static int
sysset_t_size (procinfo * pi)
{
#ifndef DYNAMIC_SYSCALLS
  return sizeof (sysset_t);
#else
  return sizeof (sysset_t) - sizeof (uint64_t)
    + sizeof (uint64_t) * ((pi->num_syscalls + (8 * sizeof (uint64_t) - 1))
			   / (8 * sizeof (uint64_t)));
#endif
}

/* Allocate and (partially) initialize a sysset_t struct.  */

static sysset_t *
sysset_t_alloc (procinfo * pi)
{
  sysset_t *ret;
  int size = sysset_t_size (pi);

  ret = xmalloc (size);
#ifdef DYNAMIC_SYSCALLS
  ret->pr_size = ((pi->num_syscalls + (8 * sizeof (uint64_t) - 1))
		  / (8 * sizeof (uint64_t)));
#endif
  return ret;
}

#ifdef DYNAMIC_SYSCALLS

/* Extract syscall numbers and names from /proc/<pid>/sysent.  Initialize
   pi->num_syscalls with the number of syscalls and pi->syscall_names
   with the names.  (Certain numbers may be skipped in which case the
   names for these numbers will be left as NULL.)  */

#define MAX_SYSCALL_NAME_LENGTH 256
#define MAX_SYSCALLS 65536

static void
load_syscalls (procinfo *pi)
{
  char pathname[MAX_PROC_NAME_SIZE];
  int sysent_fd;
  prsysent_t header;
  prsyscall_t *syscalls;
  int i, size, maxcall;
  struct cleanup *cleanups;

  pi->num_syscalls = 0;
  pi->syscall_names = 0;

  /* Open the file descriptor for the sysent file.  */
  sprintf (pathname, "/proc/%d/sysent", pi->pid);
  sysent_fd = open_with_retry (pathname, O_RDONLY);
  if (sysent_fd < 0)
    {
      error (_("load_syscalls: Can't open /proc/%d/sysent"), pi->pid);
    }
  cleanups = make_cleanup_close (sysent_fd);

  size = sizeof header - sizeof (prsyscall_t);
  if (read (sysent_fd, &header, size) != size)
    {
      error (_("load_syscalls: Error reading /proc/%d/sysent"), pi->pid);
    }

  if (header.pr_nsyscalls == 0)
    {
      error (_("load_syscalls: /proc/%d/sysent contains no syscalls!"),
	     pi->pid);
    }

  size = header.pr_nsyscalls * sizeof (prsyscall_t);
  syscalls = xmalloc (size);
  make_cleanup (free_current_contents, &syscalls);

  if (read (sysent_fd, syscalls, size) != size)
    error (_("load_syscalls: Error reading /proc/%d/sysent"), pi->pid);

  /* Find maximum syscall number.  This may not be the same as
     pr_nsyscalls since that value refers to the number of entries
     in the table.  (Also, the docs indicate that some system
     call numbers may be skipped.)  */

  maxcall = syscalls[0].pr_number;

  for (i = 1; i <  header.pr_nsyscalls; i++)
    if (syscalls[i].pr_number > maxcall
	&& syscalls[i].pr_nameoff > 0
	&& syscalls[i].pr_number < MAX_SYSCALLS)
      maxcall = syscalls[i].pr_number;

  pi->num_syscalls = maxcall+1;
  pi->syscall_names = xmalloc (pi->num_syscalls * sizeof (char *));

  for (i = 0; i < pi->num_syscalls; i++)
    pi->syscall_names[i] = NULL;

  /* Read the syscall names in.  */
  for (i = 0; i < header.pr_nsyscalls; i++)
    {
      char namebuf[MAX_SYSCALL_NAME_LENGTH];
      int nread;
      int callnum;

      if (syscalls[i].pr_number >= MAX_SYSCALLS
	  || syscalls[i].pr_number < 0
	  || syscalls[i].pr_nameoff <= 0
	  || (lseek (sysent_fd, (off_t) syscalls[i].pr_nameoff, SEEK_SET)
				       != (off_t) syscalls[i].pr_nameoff))
	continue;

      nread = read (sysent_fd, namebuf, sizeof namebuf);
      if (nread <= 0)
	continue;

      callnum = syscalls[i].pr_number;

      if (pi->syscall_names[callnum] != NULL)
	{
	  /* FIXME: Generate warning.  */
	  continue;
	}

      namebuf[nread-1] = '\0';
      size = strlen (namebuf) + 1;
      pi->syscall_names[callnum] = xmalloc (size);
      strncpy (pi->syscall_names[callnum], namebuf, size-1);
      pi->syscall_names[callnum][size-1] = '\0';
    }

  do_cleanups (cleanups);
}

/* Free the space allocated for the syscall names from the procinfo
   structure.  */

static void
free_syscalls (procinfo *pi)
{
  if (pi->syscall_names)
    {
      int i;

      for (i = 0; i < pi->num_syscalls; i++)
	if (pi->syscall_names[i] != NULL)
	  xfree (pi->syscall_names[i]);

      xfree (pi->syscall_names);
      pi->syscall_names = 0;
    }
}

/* Given a name, look up (and return) the corresponding syscall number.
   If no match is found, return -1.  */

static int
find_syscall (procinfo *pi, char *name)
{
  int i;

  for (i = 0; i < pi->num_syscalls; i++)
    {
      if (pi->syscall_names[i] && strcmp (name, pi->syscall_names[i]) == 0)
	return i;
    }
  return -1;
}
#endif

/* =================== END, STRUCT PROCINFO "MODULE" =================== */

/* ===================  /proc  "MODULE" =================== */

/* This "module" is the interface layer between the /proc system API
   and the gdb target vector functions.  This layer consists of access
   functions that encapsulate each of the basic operations that we
   need to use from the /proc API.

   The main motivation for this layer is to hide the fact that there
   are two very different implementations of the /proc API.  Rather
   than have a bunch of #ifdefs all thru the gdb target vector
   functions, we do our best to hide them all in here.  */

static long proc_flags (procinfo * pi);
static int proc_why (procinfo * pi);
static int proc_what (procinfo * pi);
static int proc_set_current_signal (procinfo * pi, int signo);
static int proc_get_current_thread (procinfo * pi);
static int proc_iterate_over_threads
  (procinfo * pi,
   int (*func) (procinfo *, procinfo *, void *),
   void *ptr);

static void
proc_warn (procinfo *pi, char *func, int line)
{
  sprintf (errmsg, "procfs: %s line %d, %s", func, line, pi->pathname);
  print_sys_errmsg (errmsg, errno);
}

static void
proc_error (procinfo *pi, char *func, int line)
{
  sprintf (errmsg, "procfs: %s line %d, %s", func, line, pi->pathname);
  perror_with_name (errmsg);
}

/* Updates the status struct in the procinfo.  There is a 'valid'
   flag, to let other functions know when this function needs to be
   called (so the status is only read when it is needed).  The status
   file descriptor is also only opened when it is needed.  Returns
   non-zero for success, zero for failure.  */

static int
proc_get_status (procinfo *pi)
{
  /* Status file descriptor is opened "lazily".  */
  if (pi->status_fd == 0 &&
      open_procinfo_files (pi, FD_STATUS) == 0)
    {
      pi->status_valid = 0;
      return 0;
    }

#ifdef NEW_PROC_API
  if (lseek (pi->status_fd, 0, SEEK_SET) < 0)
    pi->status_valid = 0;			/* fail */
  else
    {
      /* Sigh... I have to read a different data structure,
	 depending on whether this is a main process or an LWP.  */
      if (pi->tid)
	pi->status_valid = (read (pi->status_fd,
				  (char *) &pi->prstatus.pr_lwp,
				  sizeof (lwpstatus_t))
			    == sizeof (lwpstatus_t));
      else
	{
	  pi->status_valid = (read (pi->status_fd,
				    (char *) &pi->prstatus,
				    sizeof (gdb_prstatus_t))
			      == sizeof (gdb_prstatus_t));
	}
    }
#else	/* ioctl method */
#ifdef PIOCTSTATUS	/* osf */
  if (pi->tid == 0)	/* main process */
    {
      /* Just read the danged status.  Now isn't that simple?  */
      pi->status_valid =
	(ioctl (pi->status_fd, PIOCSTATUS, &pi->prstatus) >= 0);
    }
  else
    {
      int win;
      struct {
	long pr_count;
	tid_t pr_error_thread;
	struct prstatus status;
      } thread_status;

      thread_status.pr_count = 1;
      thread_status.status.pr_tid = pi->tid;
      win = (ioctl (pi->status_fd, PIOCTSTATUS, &thread_status) >= 0);
      if (win)
	{
	  memcpy (&pi->prstatus, &thread_status.status,
		  sizeof (pi->prstatus));
	  pi->status_valid = 1;
	}
    }
#else
  /* Just read the danged status.  Now isn't that simple?  */
  pi->status_valid = (ioctl (pi->status_fd, PIOCSTATUS, &pi->prstatus) >= 0);
#endif
#endif

  if (pi->status_valid)
    {
      PROC_PRETTYFPRINT_STATUS (proc_flags (pi),
				proc_why (pi),
				proc_what (pi),
				proc_get_current_thread (pi));
    }

  /* The status struct includes general regs, so mark them valid too.  */
  pi->gregs_valid  = pi->status_valid;
#ifdef NEW_PROC_API
  /* In the read/write multiple-fd model, the status struct includes
     the fp regs too, so mark them valid too.  */
  pi->fpregs_valid = pi->status_valid;
#endif
  return pi->status_valid;	/* True if success, false if failure.  */
}

/* Returns the process flags (pr_flags field).  */

static long
proc_flags (procinfo *pi)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;	/* FIXME: not a good failure value (but what is?)  */

#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_flags;
#else
  return pi->prstatus.pr_flags;
#endif
}

/* Returns the pr_why field (why the process stopped).  */

static int
proc_why (procinfo *pi)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;	/* FIXME: not a good failure value (but what is?)  */

#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_why;
#else
  return pi->prstatus.pr_why;
#endif
}

/* Returns the pr_what field (details of why the process stopped).  */

static int
proc_what (procinfo *pi)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;	/* FIXME: not a good failure value (but what is?)  */

#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_what;
#else
  return pi->prstatus.pr_what;
#endif
}

/* This function is only called when PI is stopped by a watchpoint.
   Assuming the OS supports it, write to *ADDR the data address which
   triggered it and return 1.  Return 0 if it is not possible to know
   the address.  */

static int
proc_watchpoint_address (procinfo *pi, CORE_ADDR *addr)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;

#ifdef NEW_PROC_API
  *addr = (CORE_ADDR) gdbarch_pointer_to_address (target_gdbarch (),
	    builtin_type (target_gdbarch ())->builtin_data_ptr,
	    (gdb_byte *) &pi->prstatus.pr_lwp.pr_info.si_addr);
#else
  *addr = (CORE_ADDR) gdbarch_pointer_to_address (target_gdbarch (),
	    builtin_type (target_gdbarch ())->builtin_data_ptr,
	    (gdb_byte *) &pi->prstatus.pr_info.si_addr);
#endif
  return 1;
}

#ifndef PIOCSSPCACT	/* The following is not supported on OSF.  */

/* Returns the pr_nsysarg field (number of args to the current
   syscall).  */

static int
proc_nsysarg (procinfo *pi)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;

#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_nsysarg;
#else
  return pi->prstatus.pr_nsysarg;
#endif
}

/* Returns the pr_sysarg field (pointer to the arguments of current
   syscall).  */

static long *
proc_sysargs (procinfo *pi)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

#ifdef NEW_PROC_API
  return (long *) &pi->prstatus.pr_lwp.pr_sysarg;
#else
  return (long *) &pi->prstatus.pr_sysarg;
#endif
}
#endif /* PIOCSSPCACT */

#ifdef PROCFS_DONT_PIOCSSIG_CURSIG
/* Returns the pr_cursig field (current signal).  */

static long
proc_cursig (struct procinfo *pi)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;	/* FIXME: not a good failure value (but what is?)  */

#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_cursig;
#else
  return pi->prstatus.pr_cursig;
#endif
}
#endif /* PROCFS_DONT_PIOCSSIG_CURSIG */

/* === I appologize for the messiness of this function.
   === This is an area where the different versions of
   === /proc are more inconsistent than usual.

   Set or reset any of the following process flags:
      PR_FORK	-- forked child will inherit trace flags
      PR_RLC	-- traced process runs when last /proc file closed.
      PR_KLC    -- traced process is killed when last /proc file closed.
      PR_ASYNC	-- LWP's get to run/stop independently.

   There are three methods for doing this function:
   1) Newest: read/write [PCSET/PCRESET/PCUNSET]
      [Sol6, Sol7, UW]
   2) Middle: PIOCSET/PIOCRESET
      [Irix, Sol5]
   3) Oldest: PIOCSFORK/PIOCRFORK/PIOCSRLC/PIOCRRLC
      [OSF, Sol5]

   Note: Irix does not define PR_ASYNC.
   Note: OSF  does not define PR_KLC.
   Note: OSF  is the only one that can ONLY use the oldest method.

   Arguments:
      pi   -- the procinfo
      flag -- one of PR_FORK, PR_RLC, or PR_ASYNC
      mode -- 1 for set, 0 for reset.

   Returns non-zero for success, zero for failure.  */

enum { FLAG_RESET, FLAG_SET };

static int
proc_modify_flag (procinfo *pi, long flag, long mode)
{
  long win = 0;		/* default to fail */

  /* These operations affect the process as a whole, and applying them
     to an individual LWP has the same meaning as applying them to the
     main process.  Therefore, if we're ever called with a pointer to
     an LWP's procinfo, let's substitute the process's procinfo and
     avoid opening the LWP's file descriptor unnecessarily.  */

  if (pi->pid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API	/* Newest method: Newer Solarii.  */
  /* First normalize the PCUNSET/PCRESET command opcode
     (which for no obvious reason has a different definition
     from one operating system to the next...)  */
#ifdef  PCUNSET
#define GDBRESET PCUNSET
#else
#ifdef  PCRESET
#define GDBRESET PCRESET
#endif
#endif
  {
    procfs_ctl_t arg[2];

    if (mode == FLAG_SET)	/* Set the flag (RLC, FORK, or ASYNC).  */
      arg[0] = PCSET;
    else			/* Reset the flag.  */
      arg[0] = GDBRESET;

    arg[1] = flag;
    win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else
#ifdef PIOCSET		/* Irix/Sol5 method */
  if (mode == FLAG_SET)	/* Set the flag (hopefully RLC, FORK, or ASYNC).  */
    {
      win = (ioctl (pi->ctl_fd, PIOCSET, &flag)   >= 0);
    }
  else			/* Reset the flag.  */
    {
      win = (ioctl (pi->ctl_fd, PIOCRESET, &flag) >= 0);
    }

#else
#ifdef PIOCSRLC		/* Oldest method: OSF */
  switch (flag) {
  case PR_RLC:
    if (mode == FLAG_SET)	/* Set run-on-last-close */
      {
	win = (ioctl (pi->ctl_fd, PIOCSRLC, NULL) >= 0);
      }
    else			/* Clear run-on-last-close */
      {
	win = (ioctl (pi->ctl_fd, PIOCRRLC, NULL) >= 0);
      }
    break;
  case PR_FORK:
    if (mode == FLAG_SET)	/* Set inherit-on-fork */
      {
	win = (ioctl (pi->ctl_fd, PIOCSFORK, NULL) >= 0);
      }
    else			/* Clear inherit-on-fork */
      {
	win = (ioctl (pi->ctl_fd, PIOCRFORK, NULL) >= 0);
      }
    break;
  default:
    win = 0;		/* Fail -- unknown flag (can't do PR_ASYNC).  */
    break;
  }
#endif
#endif
#endif
#undef GDBRESET
  /* The above operation renders the procinfo's cached pstatus
     obsolete.  */
  pi->status_valid = 0;

  if (!win)
    warning (_("procfs: modify_flag failed to turn %s %s"),
	     flag == PR_FORK  ? "PR_FORK"  :
	     flag == PR_RLC   ? "PR_RLC"   :
#ifdef PR_ASYNC
	     flag == PR_ASYNC ? "PR_ASYNC" :
#endif
#ifdef PR_KLC
	     flag == PR_KLC   ? "PR_KLC"   :
#endif
	     "<unknown flag>",
	     mode == FLAG_RESET ? "off" : "on");

  return win;
}

/* Set the run_on_last_close flag.  Process with all threads will
   become runnable when debugger closes all /proc fds.  Returns
   non-zero for success, zero for failure.  */

static int
proc_set_run_on_last_close (procinfo *pi)
{
  return proc_modify_flag (pi, PR_RLC, FLAG_SET);
}

/* Reset the run_on_last_close flag.  The process will NOT become
   runnable when debugger closes its file handles.  Returns non-zero
   for success, zero for failure.  */

static int
proc_unset_run_on_last_close (procinfo *pi)
{
  return proc_modify_flag (pi, PR_RLC, FLAG_RESET);
}

/* Reset inherit_on_fork flag.  If the process forks a child while we
   are registered for events in the parent, then we will NOT recieve
   events from the child.  Returns non-zero for success, zero for
   failure.  */

static int
proc_unset_inherit_on_fork (procinfo *pi)
{
  return proc_modify_flag (pi, PR_FORK, FLAG_RESET);
}

#ifdef PR_ASYNC
/* Set PR_ASYNC flag.  If one LWP stops because of a debug event
   (signal etc.), the remaining LWPs will continue to run.  Returns
   non-zero for success, zero for failure.  */

static int
proc_set_async (procinfo *pi)
{
  return proc_modify_flag (pi, PR_ASYNC, FLAG_SET);
}

/* Reset PR_ASYNC flag.  If one LWP stops because of a debug event
   (signal etc.), then all other LWPs will stop as well.  Returns
   non-zero for success, zero for failure.  */

static int
proc_unset_async (procinfo *pi)
{
  return proc_modify_flag (pi, PR_ASYNC, FLAG_RESET);
}
#endif /* PR_ASYNC */

/* Request the process/LWP to stop.  Does not wait.  Returns non-zero
   for success, zero for failure.  */

static int
proc_stop_process (procinfo *pi)
{
  int win;

  /* We might conceivably apply this operation to an LWP, and the
     LWP's ctl file descriptor might not be open.  */

  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
    return 0;
  else
    {
#ifdef NEW_PROC_API
      procfs_ctl_t cmd = PCSTOP;

      win = (write (pi->ctl_fd, (char *) &cmd, sizeof (cmd)) == sizeof (cmd));
#else	/* ioctl method */
      win = (ioctl (pi->ctl_fd, PIOCSTOP, &pi->prstatus) >= 0);
      /* Note: the call also reads the prstatus.  */
      if (win)
	{
	  pi->status_valid = 1;
	  PROC_PRETTYFPRINT_STATUS (proc_flags (pi),
				    proc_why (pi),
				    proc_what (pi),
				    proc_get_current_thread (pi));
	}
#endif
    }

  return win;
}

/* Wait for the process or LWP to stop (block until it does).  Returns
   non-zero for success, zero for failure.  */

static int
proc_wait_for_stop (procinfo *pi)
{
  int win;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    procfs_ctl_t cmd = PCWSTOP;

    win = (write (pi->ctl_fd, (char *) &cmd, sizeof (cmd)) == sizeof (cmd));
    /* We been runnin' and we stopped -- need to update status.  */
    pi->status_valid = 0;
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCWSTOP, &pi->prstatus) >= 0);
  /* Above call also refreshes the prstatus.  */
  if (win)
    {
      pi->status_valid = 1;
      PROC_PRETTYFPRINT_STATUS (proc_flags (pi),
				proc_why (pi),
				proc_what (pi),
				proc_get_current_thread (pi));
    }
#endif

  return win;
}

/* Make the process or LWP runnable.

   Options (not all are implemented):
     - single-step
     - clear current fault
     - clear current signal
     - abort the current system call
     - stop as soon as finished with system call
     - (ioctl): set traced signal set
     - (ioctl): set held   signal set
     - (ioctl): set traced fault  set
     - (ioctl): set start pc (vaddr)

   Always clears the current fault.  PI is the process or LWP to
   operate on.  If STEP is true, set the process or LWP to trap after
   one instruction.  If SIGNO is zero, clear the current signal if
   any; if non-zero, set the current signal to this one.  Returns
   non-zero for success, zero for failure.  */

static int
proc_run_process (procinfo *pi, int step, int signo)
{
  int win;
  int runflags;

  /* We will probably have to apply this operation to individual
     threads, so make sure the control file descriptor is open.  */

  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
    {
      return 0;
    }

  runflags    = PRCFAULT;	/* Always clear current fault.  */
  if (step)
    runflags |= PRSTEP;
  if (signo == 0)
    runflags |= PRCSIG;
  else if (signo != -1)		/* -1 means do nothing W.R.T. signals.  */
    proc_set_current_signal (pi, signo);

#ifdef NEW_PROC_API
  {
    procfs_ctl_t cmd[2];

    cmd[0]  = PCRUN;
    cmd[1]  = runflags;
    win = (write (pi->ctl_fd, (char *) &cmd, sizeof (cmd)) == sizeof (cmd));
  }
#else	/* ioctl method */
  {
    prrun_t prrun;

    memset (&prrun, 0, sizeof (prrun));
    prrun.pr_flags  = runflags;
    win = (ioctl (pi->ctl_fd, PIOCRUN, &prrun) >= 0);
  }
#endif

  return win;
}

/* Register to trace signals in the process or LWP.  Returns non-zero
   for success, zero for failure.  */

static int
proc_set_traced_signals (procinfo *pi, gdb_sigset_t *sigset)
{
  int win;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    struct {
      procfs_ctl_t cmd;
      /* Use char array to avoid alignment issues.  */
      char sigset[sizeof (gdb_sigset_t)];
    } arg;

    arg.cmd = PCSTRACE;
    memcpy (&arg.sigset, sigset, sizeof (gdb_sigset_t));

    win = (write (pi->ctl_fd, (char *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCSTRACE, sigset) >= 0);
#endif
  /* The above operation renders the procinfo's cached pstatus obsolete.  */
  pi->status_valid = 0;

  if (!win)
    warning (_("procfs: set_traced_signals failed"));
  return win;
}

/* Register to trace hardware faults in the process or LWP.  Returns
   non-zero for success, zero for failure.  */

static int
proc_set_traced_faults (procinfo *pi, fltset_t *fltset)
{
  int win;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    struct {
      procfs_ctl_t cmd;
      /* Use char array to avoid alignment issues.  */
      char fltset[sizeof (fltset_t)];
    } arg;

    arg.cmd = PCSFAULT;
    memcpy (&arg.fltset, fltset, sizeof (fltset_t));

    win = (write (pi->ctl_fd, (char *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCSFAULT, fltset) >= 0);
#endif
  /* The above operation renders the procinfo's cached pstatus obsolete.  */
  pi->status_valid = 0;

  return win;
}

/* Register to trace entry to system calls in the process or LWP.
   Returns non-zero for success, zero for failure.  */

static int
proc_set_traced_sysentry (procinfo *pi, sysset_t *sysset)
{
  int win;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    struct gdb_proc_ctl_pcsentry {
      procfs_ctl_t cmd;
      /* Use char array to avoid alignment issues.  */
      char sysset[sizeof (sysset_t)];
    } *argp;
    int argp_size = sizeof (struct gdb_proc_ctl_pcsentry)
		  - sizeof (sysset_t)
		  + sysset_t_size (pi);

    argp = xmalloc (argp_size);

    argp->cmd = PCSENTRY;
    memcpy (&argp->sysset, sysset, sysset_t_size (pi));

    win = (write (pi->ctl_fd, (char *) argp, argp_size) == argp_size);
    xfree (argp);
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCSENTRY, sysset) >= 0);
#endif
  /* The above operation renders the procinfo's cached pstatus
     obsolete.  */
  pi->status_valid = 0;

  return win;
}

/* Register to trace exit from system calls in the process or LWP.
   Returns non-zero for success, zero for failure.  */

static int
proc_set_traced_sysexit (procinfo *pi, sysset_t *sysset)
{
  int win;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    struct gdb_proc_ctl_pcsexit {
      procfs_ctl_t cmd;
      /* Use char array to avoid alignment issues.  */
      char sysset[sizeof (sysset_t)];
    } *argp;
    int argp_size = sizeof (struct gdb_proc_ctl_pcsexit)
		  - sizeof (sysset_t)
		  + sysset_t_size (pi);

    argp = xmalloc (argp_size);

    argp->cmd = PCSEXIT;
    memcpy (&argp->sysset, sysset, sysset_t_size (pi));

    win = (write (pi->ctl_fd, (char *) argp, argp_size) == argp_size);
    xfree (argp);
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCSEXIT, sysset) >= 0);
#endif
  /* The above operation renders the procinfo's cached pstatus
     obsolete.  */
  pi->status_valid = 0;

  return win;
}

/* Specify the set of blocked / held signals in the process or LWP.
   Returns non-zero for success, zero for failure.  */

static int
proc_set_held_signals (procinfo *pi, gdb_sigset_t *sighold)
{
  int win;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    struct {
      procfs_ctl_t cmd;
      /* Use char array to avoid alignment issues.  */
      char hold[sizeof (gdb_sigset_t)];
    } arg;

    arg.cmd  = PCSHOLD;
    memcpy (&arg.hold, sighold, sizeof (gdb_sigset_t));
    win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else
  win = (ioctl (pi->ctl_fd, PIOCSHOLD, sighold) >= 0);
#endif
  /* The above operation renders the procinfo's cached pstatus
     obsolete.  */
  pi->status_valid = 0;

  return win;
}

/* Returns the set of signals that are held / blocked.  Will also copy
   the sigset if SAVE is non-zero.  */

static gdb_sigset_t *
proc_get_held_signals (procinfo *pi, gdb_sigset_t *save)
{
  gdb_sigset_t *ret = NULL;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

  ret = &pi->prstatus.pr_lwp.pr_lwphold;
#else  /* not NEW_PROC_API */
  {
    static gdb_sigset_t sigheld;

    if (ioctl (pi->ctl_fd, PIOCGHOLD, &sigheld) >= 0)
      ret = &sigheld;
  }
#endif /* NEW_PROC_API */
  if (save && ret)
    memcpy (save, ret, sizeof (gdb_sigset_t));

  return ret;
}

/* Returns the set of signals that are traced / debugged.  Will also
   copy the sigset if SAVE is non-zero.  */

static gdb_sigset_t *
proc_get_traced_signals (procinfo *pi, gdb_sigset_t *save)
{
  gdb_sigset_t *ret = NULL;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

  ret = &pi->prstatus.pr_sigtrace;
#else
  {
    static gdb_sigset_t sigtrace;

    if (ioctl (pi->ctl_fd, PIOCGTRACE, &sigtrace) >= 0)
      ret = &sigtrace;
  }
#endif
  if (save && ret)
    memcpy (save, ret, sizeof (gdb_sigset_t));

  return ret;
}

/* Returns the set of hardware faults that are traced /debugged.  Will
   also copy the faultset if SAVE is non-zero.  */

static fltset_t *
proc_get_traced_faults (procinfo *pi, fltset_t *save)
{
  fltset_t *ret = NULL;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

  ret = &pi->prstatus.pr_flttrace;
#else
  {
    static fltset_t flttrace;

    if (ioctl (pi->ctl_fd, PIOCGFAULT, &flttrace) >= 0)
      ret = &flttrace;
  }
#endif
  if (save && ret)
    memcpy (save, ret, sizeof (fltset_t));

  return ret;
}

/* Returns the set of syscalls that are traced /debugged on entry.
   Will also copy the syscall set if SAVE is non-zero.  */

static sysset_t *
proc_get_traced_sysentry (procinfo *pi, sysset_t *save)
{
  sysset_t *ret = NULL;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

#ifndef DYNAMIC_SYSCALLS
  ret = &pi->prstatus.pr_sysentry;
#else /* DYNAMIC_SYSCALLS */
  {
    static sysset_t *sysentry;
    size_t size;

    if (!sysentry)
      sysentry = sysset_t_alloc (pi);
    ret = sysentry;
    if (pi->status_fd == 0 && open_procinfo_files (pi, FD_STATUS) == 0)
      return NULL;
    if (pi->prstatus.pr_sysentry_offset == 0)
      {
	gdb_premptysysset (sysentry);
      }
    else
      {
	int rsize;

	if (lseek (pi->status_fd, (off_t) pi->prstatus.pr_sysentry_offset,
		   SEEK_SET)
	    != (off_t) pi->prstatus.pr_sysentry_offset)
	  return NULL;
	size = sysset_t_size (pi);
	gdb_premptysysset (sysentry);
	rsize = read (pi->status_fd, sysentry, size);
	if (rsize < 0)
	  return NULL;
      }
  }
#endif /* DYNAMIC_SYSCALLS */
#else /* !NEW_PROC_API */
  {
    static sysset_t sysentry;

    if (ioctl (pi->ctl_fd, PIOCGENTRY, &sysentry) >= 0)
      ret = &sysentry;
  }
#endif /* NEW_PROC_API */
  if (save && ret)
    memcpy (save, ret, sysset_t_size (pi));

  return ret;
}

/* Returns the set of syscalls that are traced /debugged on exit.
   Will also copy the syscall set if SAVE is non-zero.  */

static sysset_t *
proc_get_traced_sysexit (procinfo *pi, sysset_t *save)
{
  sysset_t * ret = NULL;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

#ifndef DYNAMIC_SYSCALLS
  ret = &pi->prstatus.pr_sysexit;
#else /* DYNAMIC_SYSCALLS */
  {
    static sysset_t *sysexit;
    size_t size;

    if (!sysexit)
      sysexit = sysset_t_alloc (pi);
    ret = sysexit;
    if (pi->status_fd == 0 && open_procinfo_files (pi, FD_STATUS) == 0)
      return NULL;
    if (pi->prstatus.pr_sysexit_offset == 0)
      {
	gdb_premptysysset (sysexit);
      }
    else
      {
	int rsize;

	if (lseek (pi->status_fd, (off_t) pi->prstatus.pr_sysexit_offset,
		   SEEK_SET)
	    != (off_t) pi->prstatus.pr_sysexit_offset)
	  return NULL;
	size = sysset_t_size (pi);
	gdb_premptysysset (sysexit);
	rsize = read (pi->status_fd, sysexit, size);
	if (rsize < 0)
	  return NULL;
      }
  }
#endif /* DYNAMIC_SYSCALLS */
#else
  {
    static sysset_t sysexit;

    if (ioctl (pi->ctl_fd, PIOCGEXIT, &sysexit) >= 0)
      ret = &sysexit;
  }
#endif
  if (save && ret)
    memcpy (save, ret, sysset_t_size (pi));

  return ret;
}

/* The current fault (if any) is cleared; the associated signal will
   not be sent to the process or LWP when it resumes.  Returns
   non-zero for success, zero for failure.  */

static int
proc_clear_current_fault (procinfo *pi)
{
  int win;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    procfs_ctl_t cmd = PCCFAULT;

    win = (write (pi->ctl_fd, (void *) &cmd, sizeof (cmd)) == sizeof (cmd));
  }
#else
  win = (ioctl (pi->ctl_fd, PIOCCFAULT, 0) >= 0);
#endif

  return win;
}

/* Set the "current signal" that will be delivered next to the
   process.  NOTE: semantics are different from those of KILL.  This
   signal will be delivered to the process or LWP immediately when it
   is resumed (even if the signal is held/blocked); it will NOT
   immediately cause another event of interest, and will NOT first
   trap back to the debugger.  Returns non-zero for success, zero for
   failure.  */

static int
proc_set_current_signal (procinfo *pi, int signo)
{
  int win;
  struct {
    procfs_ctl_t cmd;
    /* Use char array to avoid alignment issues.  */
    char sinfo[sizeof (gdb_siginfo_t)];
  } arg;
  gdb_siginfo_t mysinfo;
  ptid_t wait_ptid;
  struct target_waitstatus wait_status;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef PROCFS_DONT_PIOCSSIG_CURSIG
  /* With Alpha OSF/1 procfs, the kernel gets really confused if it
     receives a PIOCSSIG with a signal identical to the current
     signal, it messes up the current signal.  Work around the kernel
     bug.  */
  if (signo > 0 &&
      signo == proc_cursig (pi))
    return 1;           /* I assume this is a success?  */
#endif

  /* The pointer is just a type alias.  */
  get_last_target_status (&wait_ptid, &wait_status);
  if (ptid_equal (wait_ptid, inferior_ptid)
      && wait_status.kind == TARGET_WAITKIND_STOPPED
      && wait_status.value.sig == gdb_signal_from_host (signo)
      && proc_get_status (pi)
#ifdef NEW_PROC_API
      && pi->prstatus.pr_lwp.pr_info.si_signo == signo
#else
      && pi->prstatus.pr_info.si_signo == signo
#endif
      )
    /* Use the siginfo associated with the signal being
       redelivered.  */
#ifdef NEW_PROC_API
    memcpy (arg.sinfo, &pi->prstatus.pr_lwp.pr_info, sizeof (gdb_siginfo_t));
#else
    memcpy (arg.sinfo, &pi->prstatus.pr_info, sizeof (gdb_siginfo_t));
#endif
  else
    {
      mysinfo.si_signo = signo;
      mysinfo.si_code  = 0;
      mysinfo.si_pid   = getpid ();       /* ?why? */
      mysinfo.si_uid   = getuid ();       /* ?why? */
      memcpy (arg.sinfo, &mysinfo, sizeof (gdb_siginfo_t));
    }

#ifdef NEW_PROC_API
  arg.cmd = PCSSIG;
  win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg))  == sizeof (arg));
#else
  win = (ioctl (pi->ctl_fd, PIOCSSIG, (void *) &arg.sinfo) >= 0);
#endif

  return win;
}

/* The current signal (if any) is cleared, and is not sent to the
   process or LWP when it resumes.  Returns non-zero for success, zero
   for failure.  */

static int
proc_clear_current_signal (procinfo *pi)
{
  int win;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    struct {
      procfs_ctl_t cmd;
      /* Use char array to avoid alignment issues.  */
      char sinfo[sizeof (gdb_siginfo_t)];
    } arg;
    gdb_siginfo_t mysinfo;

    arg.cmd = PCSSIG;
    /* The pointer is just a type alias.  */
    mysinfo.si_signo = 0;
    mysinfo.si_code  = 0;
    mysinfo.si_errno = 0;
    mysinfo.si_pid   = getpid ();       /* ?why? */
    mysinfo.si_uid   = getuid ();       /* ?why? */
    memcpy (arg.sinfo, &mysinfo, sizeof (gdb_siginfo_t));

    win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else
  win = (ioctl (pi->ctl_fd, PIOCSSIG, 0) >= 0);
#endif

  return win;
}

/* Return the general-purpose registers for the process or LWP
   corresponding to PI.  Upon failure, return NULL.  */

static gdb_gregset_t *
proc_get_gregs (procinfo *pi)
{
  if (!pi->status_valid || !pi->gregs_valid)
    if (!proc_get_status (pi))
      return NULL;

#ifdef NEW_PROC_API
  return &pi->prstatus.pr_lwp.pr_reg;
#else
  return &pi->prstatus.pr_reg;
#endif
}

/* Return the general-purpose registers for the process or LWP
   corresponding to PI.  Upon failure, return NULL.  */

static gdb_fpregset_t *
proc_get_fpregs (procinfo *pi)
{
#ifdef NEW_PROC_API
  if (!pi->status_valid || !pi->fpregs_valid)
    if (!proc_get_status (pi))
      return NULL;

  return &pi->prstatus.pr_lwp.pr_fpreg;

#else  /* not NEW_PROC_API */
  if (pi->fpregs_valid)
    return &pi->fpregset;	/* Already got 'em.  */
  else
    {
      if (pi->ctl_fd == 0 && open_procinfo_files (pi, FD_CTL) == 0)
	{
	  return NULL;
	}
      else
	{
# ifdef PIOCTGFPREG
	  struct {
	    long pr_count;
	    tid_t pr_error_thread;
	    tfpregset_t thread_1;
	  } thread_fpregs;

	  thread_fpregs.pr_count = 1;
	  thread_fpregs.thread_1.tid = pi->tid;

	  if (pi->tid == 0
	      && ioctl (pi->ctl_fd, PIOCGFPREG, &pi->fpregset) >= 0)
	    {
	      pi->fpregs_valid = 1;
	      return &pi->fpregset; /* Got 'em now!  */
	    }
	  else if (pi->tid != 0
		   && ioctl (pi->ctl_fd, PIOCTGFPREG, &thread_fpregs) >= 0)
	    {
	      memcpy (&pi->fpregset, &thread_fpregs.thread_1.pr_fpregs,
		      sizeof (pi->fpregset));
	      pi->fpregs_valid = 1;
	      return &pi->fpregset; /* Got 'em now!  */
	    }
	  else
	    {
	      return NULL;
	    }
# else
	  if (ioctl (pi->ctl_fd, PIOCGFPREG, &pi->fpregset) >= 0)
	    {
	      pi->fpregs_valid = 1;
	      return &pi->fpregset; /* Got 'em now!  */
	    }
	  else
	    {
	      return NULL;
	    }
# endif
	}
    }
#endif /* NEW_PROC_API */
}

/* Write the general-purpose registers back to the process or LWP
   corresponding to PI.  Return non-zero for success, zero for
   failure.  */

static int
proc_set_gregs (procinfo *pi)
{
  gdb_gregset_t *gregs;
  int win;

  gregs = proc_get_gregs (pi);
  if (gregs == NULL)
    return 0;			/* proc_get_regs has already warned.  */

  if (pi->ctl_fd == 0 && open_procinfo_files (pi, FD_CTL) == 0)
    {
      return 0;
    }
  else
    {
#ifdef NEW_PROC_API
      struct {
	procfs_ctl_t cmd;
	/* Use char array to avoid alignment issues.  */
	char gregs[sizeof (gdb_gregset_t)];
      } arg;

      arg.cmd = PCSREG;
      memcpy (&arg.gregs, gregs, sizeof (arg.gregs));
      win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
#else
      win = (ioctl (pi->ctl_fd, PIOCSREG, gregs) >= 0);
#endif
    }

  /* Policy: writing the registers invalidates our cache.  */
  pi->gregs_valid = 0;
  return win;
}

/* Write the floating-pointer registers back to the process or LWP
   corresponding to PI.  Return non-zero for success, zero for
   failure.  */

static int
proc_set_fpregs (procinfo *pi)
{
  gdb_fpregset_t *fpregs;
  int win;

  fpregs = proc_get_fpregs (pi);
  if (fpregs == NULL)
    return 0;			/* proc_get_fpregs has already warned.  */

  if (pi->ctl_fd == 0 && open_procinfo_files (pi, FD_CTL) == 0)
    {
      return 0;
    }
  else
    {
#ifdef NEW_PROC_API
      struct {
	procfs_ctl_t cmd;
	/* Use char array to avoid alignment issues.  */
	char fpregs[sizeof (gdb_fpregset_t)];
      } arg;

      arg.cmd = PCSFPREG;
      memcpy (&arg.fpregs, fpregs, sizeof (arg.fpregs));
      win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
#else
# ifdef PIOCTSFPREG
      if (pi->tid == 0)
	win = (ioctl (pi->ctl_fd, PIOCSFPREG, fpregs) >= 0);
      else
	{
	  struct {
	    long pr_count;
	    tid_t pr_error_thread;
	    tfpregset_t thread_1;
	  } thread_fpregs;

	  thread_fpregs.pr_count = 1;
	  thread_fpregs.thread_1.tid = pi->tid;
	  memcpy (&thread_fpregs.thread_1.pr_fpregs, fpregs,
		  sizeof (*fpregs));
	  win = (ioctl (pi->ctl_fd, PIOCTSFPREG, &thread_fpregs) >= 0);
	}
# else
      win = (ioctl (pi->ctl_fd, PIOCSFPREG, fpregs) >= 0);
# endif
#endif /* NEW_PROC_API */
    }

  /* Policy: writing the registers invalidates our cache.  */
  pi->fpregs_valid = 0;
  return win;
}

/* Send a signal to the proc or lwp with the semantics of "kill()".
   Returns non-zero for success, zero for failure.  */

static int
proc_kill (procinfo *pi, int signo)
{
  int win;

  /* We might conceivably apply this operation to an LWP, and the
     LWP's ctl file descriptor might not be open.  */

  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
    {
      return 0;
    }
  else
    {
#ifdef NEW_PROC_API
      procfs_ctl_t cmd[2];

      cmd[0] = PCKILL;
      cmd[1] = signo;
      win = (write (pi->ctl_fd, (char *) &cmd, sizeof (cmd)) == sizeof (cmd));
#else   /* ioctl method */
      /* FIXME: do I need the Alpha OSF fixups present in
	 procfs.c/unconditionally_kill_inferior?  Perhaps only for SIGKILL?  */
      win = (ioctl (pi->ctl_fd, PIOCKILL, &signo) >= 0);
#endif
  }

  return win;
}

/* Find the pid of the process that started this one.  Returns the
   parent process pid, or zero.  */

static int
proc_parent_pid (procinfo *pi)
{
  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;

  return pi->prstatus.pr_ppid;
}

/* Convert a target address (a.k.a. CORE_ADDR) into a host address
   (a.k.a void pointer)!  */

#if (defined (PCWATCH) || defined (PIOCSWATCH)) \
    && !(defined (PIOCOPENLWP))
static void *
procfs_address_to_host_pointer (CORE_ADDR addr)
{
  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;
  void *ptr;

  gdb_assert (sizeof (ptr) == TYPE_LENGTH (ptr_type));
  gdbarch_address_to_pointer (target_gdbarch (), ptr_type,
			      (gdb_byte *) &ptr, addr);
  return ptr;
}
#endif

static int
proc_set_watchpoint (procinfo *pi, CORE_ADDR addr, int len, int wflags)
{
#if !defined (PCWATCH) && !defined (PIOCSWATCH)
  /* If neither or these is defined, we can't support watchpoints.
     This just avoids possibly failing to compile the below on such
     systems.  */
  return 0;
#else
/* Horrible hack!  Detect Solaris 2.5, because this doesn't work on 2.5.  */
#if defined (PIOCOPENLWP)	/* Solaris 2.5: bail out.  */
  return 0;
#else
  struct {
    procfs_ctl_t cmd;
    char watch[sizeof (prwatch_t)];
  } arg;
  prwatch_t pwatch;

  /* NOTE: cagney/2003-02-01: Even more horrible hack.  Need to
     convert a target address into something that can be stored in a
     native data structure.  */
#ifdef PCAGENT	/* Horrible hack: only defined on Solaris 2.6+ */
  pwatch.pr_vaddr  = (uintptr_t) procfs_address_to_host_pointer (addr);
#else
  pwatch.pr_vaddr  = (caddr_t) procfs_address_to_host_pointer (addr);
#endif
  pwatch.pr_size   = len;
  pwatch.pr_wflags = wflags;
#if defined(NEW_PROC_API) && defined (PCWATCH)
  arg.cmd = PCWATCH;
  memcpy (arg.watch, &pwatch, sizeof (prwatch_t));
  return (write (pi->ctl_fd, &arg, sizeof (arg)) == sizeof (arg));
#else
#if defined (PIOCSWATCH)
  return (ioctl (pi->ctl_fd, PIOCSWATCH, &pwatch) >= 0);
#else
  return 0;	/* Fail */
#endif
#endif
#endif
#endif
}

#if (defined(__i386__) || defined(__x86_64__)) && defined (sun)

#include <sys/sysi86.h>

/* The KEY is actually the value of the lower 16 bits of the GS
   register for the LWP that we're interested in.  Returns the
   matching ssh struct (LDT entry).  */

static struct ssd *
proc_get_LDT_entry (procinfo *pi, int key)
{
  static struct ssd *ldt_entry = NULL;
#ifdef NEW_PROC_API
  char pathname[MAX_PROC_NAME_SIZE];
  struct cleanup *old_chain = NULL;
  int  fd;

  /* Allocate space for one LDT entry.
     This alloc must persist, because we return a pointer to it.  */
  if (ldt_entry == NULL)
    ldt_entry = (struct ssd *) xmalloc (sizeof (struct ssd));

  /* Open the file descriptor for the LDT table.  */
  sprintf (pathname, "/proc/%d/ldt", pi->pid);
  if ((fd = open_with_retry (pathname, O_RDONLY)) < 0)
    {
      proc_warn (pi, "proc_get_LDT_entry (open)", __LINE__);
      return NULL;
    }
  /* Make sure it gets closed again!  */
  old_chain = make_cleanup_close (fd);

  /* Now 'read' thru the table, find a match and return it.  */
  while (read (fd, ldt_entry, sizeof (struct ssd)) == sizeof (struct ssd))
    {
      if (ldt_entry->sel == 0 &&
	  ldt_entry->bo  == 0 &&
	  ldt_entry->acc1 == 0 &&
	  ldt_entry->acc2 == 0)
	break;	/* end of table */
      /* If key matches, return this entry.  */
      if (ldt_entry->sel == key)
	return ldt_entry;
    }
  /* Loop ended, match not found.  */
  return NULL;
#else
  int nldt, i;
  static int nalloc = 0;

  /* Get the number of LDT entries.  */
  if (ioctl (pi->ctl_fd, PIOCNLDT, &nldt) < 0)
    {
      proc_warn (pi, "proc_get_LDT_entry (PIOCNLDT)", __LINE__);
      return NULL;
    }

  /* Allocate space for the number of LDT entries.  */
  /* This alloc has to persist, 'cause we return a pointer to it.  */
  if (nldt > nalloc)
    {
      ldt_entry = (struct ssd *)
	xrealloc (ldt_entry, (nldt + 1) * sizeof (struct ssd));
      nalloc = nldt;
    }

  /* Read the whole table in one gulp.  */
  if (ioctl (pi->ctl_fd, PIOCLDT, ldt_entry) < 0)
    {
      proc_warn (pi, "proc_get_LDT_entry (PIOCLDT)", __LINE__);
      return NULL;
    }

  /* Search the table and return the (first) entry matching 'key'.  */
  for (i = 0; i < nldt; i++)
    if (ldt_entry[i].sel == key)
      return &ldt_entry[i];

  /* Loop ended, match not found.  */
  return NULL;
#endif
}

/* Returns the pointer to the LDT entry of PTID.  */

struct ssd *
procfs_find_LDT_entry (ptid_t ptid)
{
  gdb_gregset_t *gregs;
  int            key;
  procinfo      *pi;

  /* Find procinfo for the lwp.  */
  if ((pi = find_procinfo (ptid_get_pid (ptid), ptid_get_lwp (ptid))) == NULL)
    {
      warning (_("procfs_find_LDT_entry: could not find procinfo for %d:%ld."),
	       ptid_get_pid (ptid), ptid_get_lwp (ptid));
      return NULL;
    }
  /* get its general registers.  */
  if ((gregs = proc_get_gregs (pi)) == NULL)
    {
      warning (_("procfs_find_LDT_entry: could not read gregs for %d:%ld."),
	       ptid_get_pid (ptid), ptid_get_lwp (ptid));
      return NULL;
    }
  /* Now extract the GS register's lower 16 bits.  */
  key = (*gregs)[GS] & 0xffff;

  /* Find the matching entry and return it.  */
  return proc_get_LDT_entry (pi, key);
}

#endif

/* =============== END, non-thread part of /proc  "MODULE" =============== */

/* =================== Thread "MODULE" =================== */

/* NOTE: you'll see more ifdefs and duplication of functions here,
   since there is a different way to do threads on every OS.  */

/* Returns the number of threads for the process.  */

#if defined (PIOCNTHR) && defined (PIOCTLIST)
/* OSF version */
static int
proc_get_nthreads (procinfo *pi)
{
  int nthreads = 0;

  if (ioctl (pi->ctl_fd, PIOCNTHR, &nthreads) < 0)
    proc_warn (pi, "procfs: PIOCNTHR failed", __LINE__);

  return nthreads;
}

#else
#if defined (SYS_lwpcreate) || defined (SYS_lwp_create) /* FIXME: multiple */
/* Solaris version */
static int
proc_get_nthreads (procinfo *pi)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;

  /* NEW_PROC_API: only works for the process procinfo, because the
     LWP procinfos do not get prstatus filled in.  */
#ifdef NEW_PROC_API
  if (pi->tid != 0)	/* Find the parent process procinfo.  */
    pi = find_procinfo_or_die (pi->pid, 0);
#endif
  return pi->prstatus.pr_nlwp;
}

#else
/* Default version */
static int
proc_get_nthreads (procinfo *pi)
{
  return 0;
}
#endif
#endif

/* LWP version.

   Return the ID of the thread that had an event of interest.
   (ie. the one that hit a breakpoint or other traced event).  All
   other things being equal, this should be the ID of a thread that is
   currently executing.  */

#if defined (SYS_lwpcreate) || defined (SYS_lwp_create) /* FIXME: multiple */
/* Solaris version */
static int
proc_get_current_thread (procinfo *pi)
{
  /* Note: this should be applied to the root procinfo for the
     process, not to the procinfo for an LWP.  If applied to the
     procinfo for an LWP, it will simply return that LWP's ID.  In
     that case, find the parent process procinfo.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;

#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_lwpid;
#else
  return pi->prstatus.pr_who;
#endif
}

#else
#if defined (PIOCNTHR) && defined (PIOCTLIST)
/* OSF version */
static int
proc_get_current_thread (procinfo *pi)
{
#if 0	/* FIXME: not ready for prime time?  */
  return pi->prstatus.pr_tid;
#else
  return 0;
#endif
}

#else
/* Default version */
static int
proc_get_current_thread (procinfo *pi)
{
  return 0;
}

#endif
#endif

/* Discover the IDs of all the threads within the process, and create
   a procinfo for each of them (chained to the parent).  This
   unfortunately requires a different method on every OS.  Returns
   non-zero for success, zero for failure.  */

static int
proc_delete_dead_threads (procinfo *parent, procinfo *thread, void *ignore)
{
  if (thread && parent)	/* sanity */
    {
      thread->status_valid = 0;
      if (!proc_get_status (thread))
	destroy_one_procinfo (&parent->thread_list, thread);
    }
  return 0;	/* keep iterating */
}

#if defined (PIOCLSTATUS)
/* Solaris 2.5 (ioctl) version */
static int
proc_update_threads (procinfo *pi)
{
  gdb_prstatus_t *prstatus;
  struct cleanup *old_chain = NULL;
  procinfo *thread;
  int nlwp, i;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  proc_iterate_over_threads (pi, proc_delete_dead_threads, NULL);

  if ((nlwp = proc_get_nthreads (pi)) <= 1)
    return 1;	/* Process is not multi-threaded; nothing to do.  */

  prstatus = xmalloc (sizeof (gdb_prstatus_t) * (nlwp + 1));

  old_chain = make_cleanup (xfree, prstatus);
  if (ioctl (pi->ctl_fd, PIOCLSTATUS, prstatus) < 0)
    proc_error (pi, "update_threads (PIOCLSTATUS)", __LINE__);

  /* Skip element zero, which represents the process as a whole.  */
  for (i = 1; i < nlwp + 1; i++)
    {
      if ((thread = create_procinfo (pi->pid, prstatus[i].pr_who)) == NULL)
	proc_error (pi, "update_threads, create_procinfo", __LINE__);

      memcpy (&thread->prstatus, &prstatus[i], sizeof (*prstatus));
      thread->status_valid = 1;
    }
  pi->threads_valid = 1;
  do_cleanups (old_chain);
  return 1;
}
#else
#ifdef NEW_PROC_API
/* Solaris 6 (and later) version.  */
static void
do_closedir_cleanup (void *dir)
{
  closedir (dir);
}

static int
proc_update_threads (procinfo *pi)
{
  char pathname[MAX_PROC_NAME_SIZE + 16];
  struct dirent *direntry;
  struct cleanup *old_chain = NULL;
  procinfo *thread;
  DIR *dirp;
  int lwpid;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  proc_iterate_over_threads (pi, proc_delete_dead_threads, NULL);

  /* Note: this brute-force method was originally devised for Unixware
     (support removed since), and will also work on Solaris 2.6 and
     2.7.  The original comment mentioned the existence of a much
     simpler and more elegant way to do this on Solaris, but didn't
     point out what that was.  */

  strcpy (pathname, pi->pathname);
  strcat (pathname, "/lwp");
  if ((dirp = opendir (pathname)) == NULL)
    proc_error (pi, "update_threads, opendir", __LINE__);

  old_chain = make_cleanup (do_closedir_cleanup, dirp);
  while ((direntry = readdir (dirp)) != NULL)
    if (direntry->d_name[0] != '.')		/* skip '.' and '..' */
      {
	lwpid = atoi (&direntry->d_name[0]);
	if ((thread = create_procinfo (pi->pid, lwpid)) == NULL)
	  proc_error (pi, "update_threads, create_procinfo", __LINE__);
      }
  pi->threads_valid = 1;
  do_cleanups (old_chain);
  return 1;
}
#else
#ifdef PIOCTLIST
/* OSF version */
static int
proc_update_threads (procinfo *pi)
{
  int nthreads, i;
  tid_t *threads;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  proc_iterate_over_threads (pi, proc_delete_dead_threads, NULL);

  nthreads = proc_get_nthreads (pi);
  if (nthreads < 2)
    return 0;		/* Nothing to do for 1 or fewer threads.  */

  threads = xmalloc (nthreads * sizeof (tid_t));

  if (ioctl (pi->ctl_fd, PIOCTLIST, threads) < 0)
    proc_error (pi, "procfs: update_threads (PIOCTLIST)", __LINE__);

  for (i = 0; i < nthreads; i++)
    {
      if (!find_procinfo (pi->pid, threads[i]))
	if (!create_procinfo  (pi->pid, threads[i]))
	  proc_error (pi, "update_threads, create_procinfo", __LINE__);
    }
  pi->threads_valid = 1;
  return 1;
}
#else
/* Default version */
static int
proc_update_threads (procinfo *pi)
{
  return 0;
}
#endif	/* OSF PIOCTLIST */
#endif  /* NEW_PROC_API   */
#endif  /* SOL 2.5 PIOCLSTATUS */

/* Given a pointer to a function, call that function once for each lwp
   in the procinfo list, until the function returns non-zero, in which
   event return the value returned by the function.

   Note: this function does NOT call update_threads.  If you want to
   discover new threads first, you must call that function explicitly.
   This function just makes a quick pass over the currently-known
   procinfos.

   PI is the parent process procinfo.  FUNC is the per-thread
   function.  PTR is an opaque parameter for function.  Returns the
   first non-zero return value from the callee, or zero.  */

static int
proc_iterate_over_threads (procinfo *pi,
			   int (*func) (procinfo *, procinfo *, void *),
			   void *ptr)
{
  procinfo *thread, *next;
  int retval = 0;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  for (thread = pi->thread_list; thread != NULL; thread = next)
    {
      next = thread->next;	/* In case thread is destroyed.  */
      if ((retval = (*func) (pi, thread, ptr)) != 0)
	break;
    }

  return retval;
}

/* =================== END, Thread "MODULE" =================== */

/* =================== END, /proc  "MODULE" =================== */

/* ===================  GDB  "MODULE" =================== */

/* Here are all of the gdb target vector functions and their
   friends.  */

static ptid_t do_attach (ptid_t ptid);
static void do_detach (int signo);
static void proc_trace_syscalls_1 (procinfo *pi, int syscallnum,
				   int entry_or_exit, int mode, int from_tty);

/* On mips-irix, we need to insert a breakpoint at __dbx_link during
   the startup phase.  The following two variables are used to record
   the address of the breakpoint, and the code that was replaced by
   a breakpoint.  */
static int dbx_link_bpt_addr = 0;
static void *dbx_link_bpt;

/* Sets up the inferior to be debugged.  Registers to trace signals,
   hardware faults, and syscalls.  Note: does not set RLC flag: caller
   may want to customize that.  Returns zero for success (note!
   unlike most functions in this module); on failure, returns the LINE
   NUMBER where it failed!  */

static int
procfs_debug_inferior (procinfo *pi)
{
  fltset_t traced_faults;
  gdb_sigset_t traced_signals;
  sysset_t *traced_syscall_entries;
  sysset_t *traced_syscall_exits;
  int status;

#ifdef PROCFS_DONT_TRACE_FAULTS
  /* On some systems (OSF), we don't trace hardware faults.
     Apparently it's enough that we catch them as signals.
     Wonder why we don't just do that in general?  */
  premptyset (&traced_faults);		/* don't trace faults.  */
#else
  /* Register to trace hardware faults in the child.  */
  prfillset (&traced_faults);		/* trace all faults...  */
  gdb_prdelset  (&traced_faults, FLTPAGE);	/* except page fault.  */
#endif
  if (!proc_set_traced_faults  (pi, &traced_faults))
    return __LINE__;

  /* Initially, register to trace all signals in the child.  */
  prfillset (&traced_signals);
  if (!proc_set_traced_signals (pi, &traced_signals))
    return __LINE__;


  /* Register to trace the 'exit' system call (on entry).  */
  traced_syscall_entries = sysset_t_alloc (pi);
  gdb_premptysysset (traced_syscall_entries);
#ifdef SYS_exit
  gdb_praddsysset (traced_syscall_entries, SYS_exit);
#endif
#ifdef SYS_lwpexit
  gdb_praddsysset (traced_syscall_entries, SYS_lwpexit);/* And _lwp_exit...  */
#endif
#ifdef SYS_lwp_exit
  gdb_praddsysset (traced_syscall_entries, SYS_lwp_exit);
#endif
#ifdef DYNAMIC_SYSCALLS
  {
    int callnum = find_syscall (pi, "_exit");

    if (callnum >= 0)
      gdb_praddsysset (traced_syscall_entries, callnum);
  }
#endif

  status = proc_set_traced_sysentry (pi, traced_syscall_entries);
  xfree (traced_syscall_entries);
  if (!status)
    return __LINE__;

#ifdef PRFS_STOPEXEC	/* defined on OSF */
  /* OSF method for tracing exec syscalls.  Quoting:
     Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace
     exits from exec system calls because of the user level loader.  */
  /* FIXME: make nice and maybe move into an access function.  */
  {
    int prfs_flags;

    if (ioctl (pi->ctl_fd, PIOCGSPCACT, &prfs_flags) < 0)
      return __LINE__;

    prfs_flags |= PRFS_STOPEXEC;

    if (ioctl (pi->ctl_fd, PIOCSSPCACT, &prfs_flags) < 0)
      return __LINE__;
  }
#else /* not PRFS_STOPEXEC */
  /* Everyone else's (except OSF) method for tracing exec syscalls.  */
  /* GW: Rationale...
     Not all systems with /proc have all the exec* syscalls with the same
     names.  On the SGI, for example, there is no SYS_exec, but there
     *is* a SYS_execv.  So, we try to account for that.  */

  traced_syscall_exits = sysset_t_alloc (pi);
  gdb_premptysysset (traced_syscall_exits);
#ifdef SYS_exec
  gdb_praddsysset (traced_syscall_exits, SYS_exec);
#endif
#ifdef SYS_execve
  gdb_praddsysset (traced_syscall_exits, SYS_execve);
#endif
#ifdef SYS_execv
  gdb_praddsysset (traced_syscall_exits, SYS_execv);
#endif

#ifdef SYS_lwpcreate
  gdb_praddsysset (traced_syscall_exits, SYS_lwpcreate);
  gdb_praddsysset (traced_syscall_exits, SYS_lwpexit);
#endif

#ifdef SYS_lwp_create	/* FIXME: once only, please.  */
  gdb_praddsysset (traced_syscall_exits, SYS_lwp_create);
  gdb_praddsysset (traced_syscall_exits, SYS_lwp_exit);
#endif

#ifdef DYNAMIC_SYSCALLS
  {
    int callnum = find_syscall (pi, "execve");

    if (callnum >= 0)
      gdb_praddsysset (traced_syscall_exits, callnum);
    callnum = find_syscall (pi, "ra_execve");
    if (callnum >= 0)
      gdb_praddsysset (traced_syscall_exits, callnum);
  }
#endif

  status = proc_set_traced_sysexit (pi, traced_syscall_exits);
  xfree (traced_syscall_exits);
  if (!status)
    return __LINE__;

#endif /* PRFS_STOPEXEC */
  return 0;
}

static void
procfs_attach (struct target_ops *ops, char *args, int from_tty)
{
  char *exec_file;
  int   pid;

  pid = parse_pid_to_attach (args);

  if (pid == getpid ())
    error (_("Attaching GDB to itself is not a good idea..."));

  if (from_tty)
    {
      exec_file = get_exec_file (0);

      if (exec_file)
	printf_filtered (_("Attaching to program `%s', %s\n"),
			 exec_file, target_pid_to_str (pid_to_ptid (pid)));
      else
	printf_filtered (_("Attaching to %s\n"),
			 target_pid_to_str (pid_to_ptid (pid)));

      fflush (stdout);
    }
  inferior_ptid = do_attach (pid_to_ptid (pid));
  push_target (ops);
}

static void
procfs_detach (struct target_ops *ops, char *args, int from_tty)
{
  int sig = 0;
  int pid = ptid_get_pid (inferior_ptid);

  if (args)
    sig = atoi (args);

  if (from_tty)
    {
      char *exec_file;

      exec_file = get_exec_file (0);
      if (exec_file == NULL)
	exec_file = "";

      printf_filtered (_("Detaching from program: %s, %s\n"), exec_file,
		       target_pid_to_str (pid_to_ptid (pid)));
      gdb_flush (gdb_stdout);
    }

  do_detach (sig);

  inferior_ptid = null_ptid;
  detach_inferior (pid);
  unpush_target (ops);
}

static ptid_t
do_attach (ptid_t ptid)
{
  procinfo *pi;
  struct inferior *inf;
  int fail;
  int lwpid;

  if ((pi = create_procinfo (ptid_get_pid (ptid), 0)) == NULL)
    perror (_("procfs: out of memory in 'attach'"));

  if (!open_procinfo_files (pi, FD_CTL))
    {
      fprintf_filtered (gdb_stderr, "procfs:%d -- ", __LINE__);
      sprintf (errmsg, "do_attach: couldn't open /proc file for process %d",
	       ptid_get_pid (ptid));
      dead_procinfo (pi, errmsg, NOKILL);
    }

  /* Stop the process (if it isn't already stopped).  */
  if (proc_flags (pi) & (PR_STOPPED | PR_ISTOP))
    {
      pi->was_stopped = 1;
      proc_prettyprint_why (proc_why (pi), proc_what (pi), 1);
    }
  else
    {
      pi->was_stopped = 0;
      /* Set the process to run again when we close it.  */
      if (!proc_set_run_on_last_close (pi))
	dead_procinfo (pi, "do_attach: couldn't set RLC.", NOKILL);

      /* Now stop the process.  */
      if (!proc_stop_process (pi))
	dead_procinfo (pi, "do_attach: couldn't stop the process.", NOKILL);
      pi->ignore_next_sigstop = 1;
    }
  /* Save some of the /proc state to be restored if we detach.  */
  if (!proc_get_traced_faults   (pi, &pi->saved_fltset))
    dead_procinfo (pi, "do_attach: couldn't save traced faults.", NOKILL);
  if (!proc_get_traced_signals  (pi, &pi->saved_sigset))
    dead_procinfo (pi, "do_attach: couldn't save traced signals.", NOKILL);
  if (!proc_get_traced_sysentry (pi, pi->saved_entryset))
    dead_procinfo (pi, "do_attach: couldn't save traced syscall entries.",
		   NOKILL);
  if (!proc_get_traced_sysexit  (pi, pi->saved_exitset))
    dead_procinfo (pi, "do_attach: couldn't save traced syscall exits.",
		   NOKILL);
  if (!proc_get_held_signals    (pi, &pi->saved_sighold))
    dead_procinfo (pi, "do_attach: couldn't save held signals.", NOKILL);

  if ((fail = procfs_debug_inferior (pi)) != 0)
    dead_procinfo (pi, "do_attach: failed in procfs_debug_inferior", NOKILL);

  inf = current_inferior ();
  inferior_appeared (inf, pi->pid);
  /* Let GDB know that the inferior was attached.  */
  inf->attach_flag = 1;

  /* Create a procinfo for the current lwp.  */
  lwpid = proc_get_current_thread (pi);
  create_procinfo (pi->pid, lwpid);

  /* Add it to gdb's thread list.  */
  ptid = ptid_build (pi->pid, lwpid, 0);
  add_thread (ptid);

  return ptid;
}

static void
do_detach (int signo)
{
  procinfo *pi;

  /* Find procinfo for the main process.  */
  pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid),
			     0); /* FIXME: threads */
  if (signo)
    if (!proc_set_current_signal (pi, signo))
      proc_warn (pi, "do_detach, set_current_signal", __LINE__);

  if (!proc_set_traced_signals (pi, &pi->saved_sigset))
    proc_warn (pi, "do_detach, set_traced_signal", __LINE__);

  if (!proc_set_traced_faults (pi, &pi->saved_fltset))
    proc_warn (pi, "do_detach, set_traced_faults", __LINE__);

  if (!proc_set_traced_sysentry (pi, pi->saved_entryset))
    proc_warn (pi, "do_detach, set_traced_sysentry", __LINE__);

  if (!proc_set_traced_sysexit (pi, pi->saved_exitset))
    proc_warn (pi, "do_detach, set_traced_sysexit", __LINE__);

  if (!proc_set_held_signals (pi, &pi->saved_sighold))
    proc_warn (pi, "do_detach, set_held_signals", __LINE__);

  if (signo || (proc_flags (pi) & (PR_STOPPED | PR_ISTOP)))
    if (signo || !(pi->was_stopped) ||
	query (_("Was stopped when attached, make it runnable again? ")))
      {
	/* Clear any pending signal.  */
	if (!proc_clear_current_fault (pi))
	  proc_warn (pi, "do_detach, clear_current_fault", __LINE__);

	if (signo == 0 && !proc_clear_current_signal (pi))
	  proc_warn (pi, "do_detach, clear_current_signal", __LINE__);

	if (!proc_set_run_on_last_close (pi))
	  proc_warn (pi, "do_detach, set_rlc", __LINE__);
      }

  destroy_procinfo (pi);
}

/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this
   for all registers.

   ??? Is the following note still relevant?  We can't get individual
   registers with the PT_GETREGS ptrace(2) request either, yet we
   don't bother with caching at all in that case.

   NOTE: Since the /proc interface cannot give us individual
   registers, we pay no attention to REGNUM, and just fetch them all.
   This results in the possibility that we will do unnecessarily many
   fetches, since we may be called repeatedly for individual
   registers.  So we cache the results, and mark the cache invalid
   when the process is resumed.  */

static void
procfs_fetch_registers (struct target_ops *ops,
			struct regcache *regcache, int regnum)
{
  gdb_gregset_t *gregs;
  procinfo *pi;
  int pid = ptid_get_pid (inferior_ptid);
  int tid = ptid_get_lwp (inferior_ptid);
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  pi = find_procinfo_or_die (pid, tid);

  if (pi == NULL)
    error (_("procfs: fetch_registers failed to find procinfo for %s"),
	   target_pid_to_str (inferior_ptid));

  gregs = proc_get_gregs (pi);
  if (gregs == NULL)
    proc_error (pi, "fetch_registers, get_gregs", __LINE__);

  supply_gregset (regcache, (const gdb_gregset_t *) gregs);

  if (gdbarch_fp0_regnum (gdbarch) >= 0) /* Do we have an FPU?  */
    {
      gdb_fpregset_t *fpregs;

      if ((regnum >= 0 && regnum < gdbarch_fp0_regnum (gdbarch))
	  || regnum == gdbarch_pc_regnum (gdbarch)
	  || regnum == gdbarch_sp_regnum (gdbarch))
	return;			/* Not a floating point register.  */

      fpregs = proc_get_fpregs (pi);
      if (fpregs == NULL)
	proc_error (pi, "fetch_registers, get_fpregs", __LINE__);

      supply_fpregset (regcache, (const gdb_fpregset_t *) fpregs);
    }
}

/* Store register REGNUM back into the inferior.  If REGNUM is -1, do
   this for all registers.

   NOTE: Since the /proc interface will not read individual registers,
   we will cache these requests until the process is resumed, and only
   then write them back to the inferior process.

   FIXME: is that a really bad idea?  Have to think about cases where
   writing one register might affect the value of others, etc.  */

static void
procfs_store_registers (struct target_ops *ops,
			struct regcache *regcache, int regnum)
{
  gdb_gregset_t *gregs;
  procinfo *pi;
  int pid = ptid_get_pid (inferior_ptid);
  int tid = ptid_get_lwp (inferior_ptid);
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  pi = find_procinfo_or_die (pid, tid);

  if (pi == NULL)
    error (_("procfs: store_registers: failed to find procinfo for %s"),
	   target_pid_to_str (inferior_ptid));

  gregs = proc_get_gregs (pi);
  if (gregs == NULL)
    proc_error (pi, "store_registers, get_gregs", __LINE__);

  fill_gregset (regcache, gregs, regnum);
  if (!proc_set_gregs (pi))
    proc_error (pi, "store_registers, set_gregs", __LINE__);

  if (gdbarch_fp0_regnum (gdbarch) >= 0) /* Do we have an FPU?  */
    {
      gdb_fpregset_t *fpregs;

      if ((regnum >= 0 && regnum < gdbarch_fp0_regnum (gdbarch))
	  || regnum == gdbarch_pc_regnum (gdbarch)
	  || regnum == gdbarch_sp_regnum (gdbarch))
	return;			/* Not a floating point register.  */

      fpregs = proc_get_fpregs (pi);
      if (fpregs == NULL)
	proc_error (pi, "store_registers, get_fpregs", __LINE__);

      fill_fpregset (regcache, fpregs, regnum);
      if (!proc_set_fpregs (pi))
	proc_error (pi, "store_registers, set_fpregs", __LINE__);
    }
}

static int
syscall_is_lwp_exit (procinfo *pi, int scall)
{
#ifdef SYS_lwp_exit
  if (scall == SYS_lwp_exit)
    return 1;
#endif
#ifdef SYS_lwpexit
  if (scall == SYS_lwpexit)
    return 1;
#endif
  return 0;
}

static int
syscall_is_exit (procinfo *pi, int scall)
{
#ifdef SYS_exit
  if (scall == SYS_exit)
    return 1;
#endif
#ifdef DYNAMIC_SYSCALLS
  if (find_syscall (pi, "_exit") == scall)
    return 1;
#endif
  return 0;
}

static int
syscall_is_exec (procinfo *pi, int scall)
{
#ifdef SYS_exec
  if (scall == SYS_exec)
    return 1;
#endif
#ifdef SYS_execv
  if (scall == SYS_execv)
    return 1;
#endif
#ifdef SYS_execve
  if (scall == SYS_execve)
    return 1;
#endif
#ifdef DYNAMIC_SYSCALLS
  if (find_syscall (pi, "_execve"))
    return 1;
  if (find_syscall (pi, "ra_execve"))
    return 1;
#endif
  return 0;
}

static int
syscall_is_lwp_create (procinfo *pi, int scall)
{
#ifdef SYS_lwp_create
  if (scall == SYS_lwp_create)
    return 1;
#endif
#ifdef SYS_lwpcreate
  if (scall == SYS_lwpcreate)
    return 1;
#endif
  return 0;
}

/* Remove the breakpoint that we inserted in __dbx_link().
   Does nothing if the breakpoint hasn't been inserted or has already
   been removed.  */

static void
remove_dbx_link_breakpoint (void)
{
  if (dbx_link_bpt_addr == 0)
    return;

  if (deprecated_remove_raw_breakpoint (target_gdbarch (), dbx_link_bpt) != 0)
    warning (_("Unable to remove __dbx_link breakpoint."));

  dbx_link_bpt_addr = 0;
  dbx_link_bpt = NULL;
}

#ifdef SYS_syssgi
/* Return the address of the __dbx_link() function in the file
   refernced by ABFD by scanning its symbol table.  Return 0 if
   the symbol was not found.  */

static CORE_ADDR
dbx_link_addr (bfd *abfd)
{
  long storage_needed;
  asymbol **symbol_table;
  long number_of_symbols;
  long i;

  storage_needed = bfd_get_symtab_upper_bound (abfd);
  if (storage_needed <= 0)
    return 0;

  symbol_table = (asymbol **) xmalloc (storage_needed);
  make_cleanup (xfree, symbol_table);

  number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);

  for (i = 0; i < number_of_symbols; i++)
    {
      asymbol *sym = symbol_table[i];

      if ((sym->flags & BSF_GLOBAL)
	  && sym->name != NULL && strcmp (sym->name, "__dbx_link") == 0)
	return (sym->value + sym->section->vma);
    }

  /* Symbol not found, return NULL.  */
  return 0;
}

/* Search the symbol table of the file referenced by FD for a symbol
   named __dbx_link().  If found, then insert a breakpoint at this location,
   and return nonzero.  Return zero otherwise.  */

static int
insert_dbx_link_bpt_in_file (int fd, CORE_ADDR ignored)
{
  bfd *abfd;
  long storage_needed;
  CORE_ADDR sym_addr;

  abfd = gdb_bfd_fdopenr ("unamed", 0, fd);
  if (abfd == NULL)
    {
      warning (_("Failed to create a bfd: %s."), bfd_errmsg (bfd_get_error ()));
      return 0;
    }

  if (!bfd_check_format (abfd, bfd_object))
    {
      /* Not the correct format, so we can not possibly find the dbx_link
	 symbol in it.	*/
      gdb_bfd_unref (abfd);
      return 0;
    }

  sym_addr = dbx_link_addr (abfd);
  if (sym_addr != 0)
    {
      /* Insert the breakpoint.  */
      dbx_link_bpt_addr = sym_addr;
      dbx_link_bpt = deprecated_insert_raw_breakpoint (target_gdbarch (), NULL,
						       sym_addr);
      if (dbx_link_bpt == NULL)
	{
	  warning (_("Failed to insert dbx_link breakpoint."));
	  gdb_bfd_unref (abfd);
	  return 0;
	}
      gdb_bfd_unref (abfd);
      return 1;
    }

  gdb_bfd_unref (abfd);
  return 0;
}

/* Calls the supplied callback function once for each mapped address
   space in the process.  The callback function receives an open file
   descriptor for the file corresponding to that mapped address space
   (if there is one), and the base address of the mapped space.  Quit
   when the callback function returns a nonzero value, or at teh end
   of the mappings.  Returns the first non-zero return value of the
   callback function, or zero.  */

static int
solib_mappings_callback (struct prmap *map, int (*func) (int, CORE_ADDR),
			 void *data)
{
  procinfo *pi = data;
  int fd;

#ifdef NEW_PROC_API
  char name[MAX_PROC_NAME_SIZE + sizeof (map->pr_mapname)];

  if (map->pr_vaddr == 0 && map->pr_size == 0)
    return -1;		/* sanity */

  if (map->pr_mapname[0] == 0)
    {
      fd = -1;	/* no map file */
    }
  else
    {
      sprintf (name, "/proc/%d/object/%s", pi->pid, map->pr_mapname);
      /* Note: caller's responsibility to close this fd!  */
      fd = open_with_retry (name, O_RDONLY);
      /* Note: we don't test the above call for failure;
	 we just pass the FD on as given.  Sometimes there is
	 no file, so the open may return failure, but that's
	 not a problem.  */
    }
#else
  fd = ioctl (pi->ctl_fd, PIOCOPENM, &map->pr_vaddr);
  /* Note: we don't test the above call for failure;
     we just pass the FD on as given.  Sometimes there is
     no file, so the ioctl may return failure, but that's
     not a problem.  */
#endif
  return (*func) (fd, (CORE_ADDR) map->pr_vaddr);
}

/* If the given memory region MAP contains a symbol named __dbx_link,
   insert a breakpoint at this location and return nonzero.  Return
   zero otherwise.  */

static int
insert_dbx_link_bpt_in_region (struct prmap *map,
			       find_memory_region_ftype child_func,
			       void *data)
{
  procinfo *pi = (procinfo *) data;

  /* We know the symbol we're looking for is in a text region, so
     only look for it if the region is a text one.  */
  if (map->pr_mflags & MA_EXEC)
    return solib_mappings_callback (map, insert_dbx_link_bpt_in_file, pi);

  return 0;
}

/* Search all memory regions for a symbol named __dbx_link.  If found,
   insert a breakpoint at its location, and return nonzero.  Return zero
   otherwise.  */

static int
insert_dbx_link_breakpoint (procinfo *pi)
{
  return iterate_over_mappings (pi, NULL, pi, insert_dbx_link_bpt_in_region);
}
#endif

/* Retrieve the next stop event from the child process.  If child has
   not stopped yet, wait for it to stop.  Translate /proc eventcodes
   (or possibly wait eventcodes) into gdb internal event codes.
   Returns the id of process (and possibly thread) that incurred the
   event.  Event codes are returned through a pointer parameter.  */

static ptid_t
procfs_wait (struct target_ops *ops,
	     ptid_t ptid, struct target_waitstatus *status, int options)
{
  /* First cut: loosely based on original version 2.1.  */
  procinfo *pi;
  int       wstat;
  int       temp_tid;
  ptid_t    retval, temp_ptid;
  int       why, what, flags;
  int       retry = 0;

wait_again:

  retry++;
  wstat    = 0;
  retval   = pid_to_ptid (-1);

  /* Find procinfo for main process.  */
  pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);
  if (pi)
    {
      /* We must assume that the status is stale now...  */
      pi->status_valid = 0;
      pi->gregs_valid  = 0;
      pi->fpregs_valid = 0;

#if 0	/* just try this out...  */
      flags = proc_flags (pi);
      why   = proc_why (pi);
      if ((flags & PR_STOPPED) && (why == PR_REQUESTED))
	pi->status_valid = 0;	/* re-read again, IMMEDIATELY...  */
#endif
      /* If child is not stopped, wait for it to stop.  */
      if (!(proc_flags (pi) & (PR_STOPPED | PR_ISTOP)) &&
	  !proc_wait_for_stop (pi))
	{
	  /* wait_for_stop failed: has the child terminated?  */
	  if (errno == ENOENT)
	    {
	      int wait_retval;

	      /* /proc file not found; presumably child has terminated.  */
	      wait_retval = wait (&wstat); /* "wait" for the child's exit.  */

	      /* Wrong child?  */
	      if (wait_retval != ptid_get_pid (inferior_ptid))
		error (_("procfs: couldn't stop "
			 "process %d: wait returned %d."),
		       ptid_get_pid (inferior_ptid), wait_retval);
	      /* FIXME: might I not just use waitpid?
		 Or try find_procinfo to see if I know about this child?  */
	      retval = pid_to_ptid (wait_retval);
	    }
	  else if (errno == EINTR)
	    goto wait_again;
	  else
	    {
	      /* Unknown error from wait_for_stop.  */
	      proc_error (pi, "target_wait (wait_for_stop)", __LINE__);
	    }
	}
      else
	{
	  /* This long block is reached if either:
	     a) the child was already stopped, or
	     b) we successfully waited for the child with wait_for_stop.
	     This block will analyze the /proc status, and translate it
	     into a waitstatus for GDB.

	     If we actually had to call wait because the /proc file
	     is gone (child terminated), then we skip this block,
	     because we already have a waitstatus.  */

	  flags = proc_flags (pi);
	  why   = proc_why (pi);
	  what  = proc_what (pi);

	  if (flags & (PR_STOPPED | PR_ISTOP))
	    {
#ifdef PR_ASYNC
	      /* If it's running async (for single_thread control),
		 set it back to normal again.  */
	      if (flags & PR_ASYNC)
		if (!proc_unset_async (pi))
		  proc_error (pi, "target_wait, unset_async", __LINE__);
#endif

	      if (info_verbose)
		proc_prettyprint_why (why, what, 1);

	      /* The 'pid' we will return to GDB is composed of
		 the process ID plus the lwp ID.  */
	      retval = ptid_build (pi->pid, proc_get_current_thread (pi), 0);

	      switch (why) {
	      case PR_SIGNALLED:
		wstat = (what << 8) | 0177;
		break;
	      case PR_SYSENTRY:
		if (syscall_is_lwp_exit (pi, what))
		  {
		    if (print_thread_events)
		      printf_unfiltered (_("[%s exited]\n"),
					 target_pid_to_str (retval));
		    delete_thread (retval);
		    status->kind = TARGET_WAITKIND_SPURIOUS;
		    return retval;
		  }
		else if (syscall_is_exit (pi, what))
		  {
		    struct inferior *inf;

		    /* Handle SYS_exit call only.  */
		    /* Stopped at entry to SYS_exit.
		       Make it runnable, resume it, then use
		       the wait system call to get its exit code.
		       Proc_run_process always clears the current
		       fault and signal.
		       Then return its exit status.  */
		    pi->status_valid = 0;
		    wstat = 0;
		    /* FIXME: what we should do is return
		       TARGET_WAITKIND_SPURIOUS.  */
		    if (!proc_run_process (pi, 0, 0))
		      proc_error (pi, "target_wait, run_process", __LINE__);

		    inf = find_inferior_pid (pi->pid);
		    if (inf->attach_flag)
		      {
			/* Don't call wait: simulate waiting for exit,
			   return a "success" exit code.  Bogus: what if
			   it returns something else?  */
			wstat = 0;
			retval = inferior_ptid;  /* ? ? ? */
		      }
		    else
		      {
			int temp = wait (&wstat);

			/* FIXME: shouldn't I make sure I get the right
			   event from the right process?  If (for
			   instance) I have killed an earlier inferior
			   process but failed to clean up after it
			   somehow, I could get its termination event
			   here.  */

			/* If wait returns -1, that's what we return
			   to GDB.  */
			if (temp < 0)
			  retval = pid_to_ptid (temp);
		      }
		  }
		else
		  {
		    printf_filtered (_("procfs: trapped on entry to "));
		    proc_prettyprint_syscall (proc_what (pi), 0);
		    printf_filtered ("\n");
#ifndef PIOCSSPCACT
		    {
		      long i, nsysargs, *sysargs;

		      if ((nsysargs = proc_nsysarg (pi)) > 0 &&
			  (sysargs  = proc_sysargs (pi)) != NULL)
			{
			  printf_filtered (_("%ld syscall arguments:\n"),
					   nsysargs);
			  for (i = 0; i < nsysargs; i++)
			    printf_filtered ("#%ld: 0x%08lx\n",
					     i, sysargs[i]);
			}

		    }
#endif
		    if (status)
		      {
			/* How to exit gracefully, returning "unknown
			   event".  */
			status->kind = TARGET_WAITKIND_SPURIOUS;
			return inferior_ptid;
		      }
		    else
		      {
			/* How to keep going without returning to wfi: */
			target_resume (ptid, 0, GDB_SIGNAL_0);
			goto wait_again;
		      }
		  }
		break;
	      case PR_SYSEXIT:
		if (syscall_is_exec (pi, what))
		  {
		    /* Hopefully this is our own "fork-child" execing
		       the real child.  Hoax this event into a trap, and
		       GDB will see the child about to execute its start
		       address.  */
		    wstat = (SIGTRAP << 8) | 0177;
		  }
#ifdef SYS_syssgi
		else if (what == SYS_syssgi)
		  {
		    /* see if we can break on dbx_link().  If yes, then
		       we no longer need the SYS_syssgi notifications.	*/
		    if (insert_dbx_link_breakpoint (pi))
		      proc_trace_syscalls_1 (pi, SYS_syssgi, PR_SYSEXIT,
					     FLAG_RESET, 0);

		    /* This is an internal event and should be transparent
		       to wfi, so resume the execution and wait again.	See
		       comment in procfs_init_inferior() for more details.  */
		    target_resume (ptid, 0, GDB_SIGNAL_0);
		    goto wait_again;
		  }
#endif
		else if (syscall_is_lwp_create (pi, what))
		  {
		    /* This syscall is somewhat like fork/exec.  We
		       will get the event twice: once for the parent
		       LWP, and once for the child.  We should already
		       know about the parent LWP, but the child will
		       be new to us.  So, whenever we get this event,
		       if it represents a new thread, simply add the
		       thread to the list.  */

		    /* If not in procinfo list, add it.  */
		    temp_tid = proc_get_current_thread (pi);
		    if (!find_procinfo (pi->pid, temp_tid))
		      create_procinfo  (pi->pid, temp_tid);

		    temp_ptid = ptid_build (pi->pid, temp_tid, 0);
		    /* If not in GDB's thread list, add it.  */
		    if (!in_thread_list (temp_ptid))
		      add_thread (temp_ptid);

		    /* Return to WFI, but tell it to immediately resume.  */
		    status->kind = TARGET_WAITKIND_SPURIOUS;
		    return inferior_ptid;
		  }
		else if (syscall_is_lwp_exit (pi, what))
		  {
		    if (print_thread_events)
		      printf_unfiltered (_("[%s exited]\n"),
					 target_pid_to_str (retval));
		    delete_thread (retval);
		    status->kind = TARGET_WAITKIND_SPURIOUS;
		    return retval;
		  }
		else if (0)
		  {
		    /* FIXME:  Do we need to handle SYS_sproc,
		       SYS_fork, or SYS_vfork here?  The old procfs
		       seemed to use this event to handle threads on
		       older (non-LWP) systems, where I'm assuming
		       that threads were actually separate processes.
		       Irix, maybe?  Anyway, low priority for now.  */
		  }
		else
		  {
		    printf_filtered (_("procfs: trapped on exit from "));
		    proc_prettyprint_syscall (proc_what (pi), 0);
		    printf_filtered ("\n");
#ifndef PIOCSSPCACT
		    {
		      long i, nsysargs, *sysargs;

		      if ((nsysargs = proc_nsysarg (pi)) > 0 &&
			  (sysargs  = proc_sysargs (pi)) != NULL)
			{
			  printf_filtered (_("%ld syscall arguments:\n"),
					   nsysargs);
			  for (i = 0; i < nsysargs; i++)
			    printf_filtered ("#%ld: 0x%08lx\n",
					     i, sysargs[i]);
			}
		    }
#endif
		    status->kind = TARGET_WAITKIND_SPURIOUS;
		    return inferior_ptid;
		  }
		break;
	      case PR_REQUESTED:
#if 0	/* FIXME */
		wstat = (SIGSTOP << 8) | 0177;
		break;
#else
		if (retry < 5)
		  {
		    printf_filtered (_("Retry #%d:\n"), retry);
		    pi->status_valid = 0;
		    goto wait_again;
		  }
		else
		  {
		    /* If not in procinfo list, add it.  */
		    temp_tid = proc_get_current_thread (pi);
		    if (!find_procinfo (pi->pid, temp_tid))
		      create_procinfo  (pi->pid, temp_tid);

		    /* If not in GDB's thread list, add it.  */
		    temp_ptid = ptid_build (pi->pid, temp_tid, 0);
		    if (!in_thread_list (temp_ptid))
		      add_thread (temp_ptid);

		    status->kind = TARGET_WAITKIND_STOPPED;
		    status->value.sig = 0;
		    return retval;
		  }
#endif
	      case PR_JOBCONTROL:
		wstat = (what << 8) | 0177;
		break;
	      case PR_FAULTED:
		switch (what) {
#ifdef FLTWATCH
		case FLTWATCH:
		  wstat = (SIGTRAP << 8) | 0177;
		  break;
#endif
#ifdef FLTKWATCH
		case FLTKWATCH:
		  wstat = (SIGTRAP << 8) | 0177;
		  break;
#endif
		  /* FIXME: use si_signo where possible.  */
		case FLTPRIV:
#if (FLTILL != FLTPRIV)		/* Avoid "duplicate case" error.  */
		case FLTILL:
#endif
		  wstat = (SIGILL << 8) | 0177;
		  break;
		case FLTBPT:
#if (FLTTRACE != FLTBPT)	/* Avoid "duplicate case" error.  */
		case FLTTRACE:
#endif
		  /* If we hit our __dbx_link() internal breakpoint,
		     then remove it.  See comments in procfs_init_inferior()
		     for more details.	*/
		  if (dbx_link_bpt_addr != 0
		      && dbx_link_bpt_addr
			 == regcache_read_pc (get_current_regcache ()))
		    remove_dbx_link_breakpoint ();

		  wstat = (SIGTRAP << 8) | 0177;
		  break;
		case FLTSTACK:
		case FLTACCESS:
#if (FLTBOUNDS != FLTSTACK)	/* Avoid "duplicate case" error.  */
		case FLTBOUNDS:
#endif
		  wstat = (SIGSEGV << 8) | 0177;
		  break;
		case FLTIOVF:
		case FLTIZDIV:
#if (FLTFPE != FLTIOVF)		/* Avoid "duplicate case" error.  */
		case FLTFPE:
#endif
		  wstat = (SIGFPE << 8) | 0177;
		  break;
		case FLTPAGE:	/* Recoverable page fault */
		default:	/* FIXME: use si_signo if possible for
				   fault.  */
		  retval = pid_to_ptid (-1);
		  printf_filtered ("procfs:%d -- ", __LINE__);
		  printf_filtered (_("child stopped for unknown reason:\n"));
		  proc_prettyprint_why (why, what, 1);
		  error (_("... giving up..."));
		  break;
		}
		break;	/* case PR_FAULTED: */
	      default:	/* switch (why) unmatched */
		printf_filtered ("procfs:%d -- ", __LINE__);
		printf_filtered (_("child stopped for unknown reason:\n"));
		proc_prettyprint_why (why, what, 1);
		error (_("... giving up..."));
		break;
	      }
	      /* Got this far without error: If retval isn't in the
		 threads database, add it.  */
	      if (ptid_get_pid (retval) > 0 &&
		  !ptid_equal (retval, inferior_ptid) &&
		  !in_thread_list (retval))
		{
		  /* We have a new thread.  We need to add it both to
		     GDB's list and to our own.  If we don't create a
		     procinfo, resume may be unhappy later.  */
		  add_thread (retval);
		  if (find_procinfo (ptid_get_pid (retval),
				     ptid_get_lwp (retval)) == NULL)
		    create_procinfo (ptid_get_pid (retval),
				     ptid_get_lwp (retval));
		}
	    }
	  else	/* Flags do not indicate STOPPED.  */
	    {
	      /* surely this can't happen...  */
	      printf_filtered ("procfs:%d -- process not stopped.\n",
			       __LINE__);
	      proc_prettyprint_flags (flags, 1);
	      error (_("procfs: ...giving up..."));
	    }
	}

      if (status)
	store_waitstatus (status, wstat);
    }

  return retval;
}

/* Perform a partial transfer to/from the specified object.  For
   memory transfers, fall back to the old memory xfer functions.  */

static LONGEST
procfs_xfer_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, gdb_byte *readbuf,
		     const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  switch (object)
    {
    case TARGET_OBJECT_MEMORY:
      if (readbuf)
	return (*ops->deprecated_xfer_memory) (offset, readbuf,
					       len, 0/*read*/, NULL, ops);
      if (writebuf)
	return (*ops->deprecated_xfer_memory) (offset, (gdb_byte *) writebuf,
					       len, 1/*write*/, NULL, ops);
      return -1;

#ifdef NEW_PROC_API
    case TARGET_OBJECT_AUXV:
      return memory_xfer_auxv (ops, object, annex, readbuf, writebuf,
			       offset, len);
#endif

    default:
      if (ops->beneath != NULL)
	return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					      readbuf, writebuf, offset, len);
      return -1;
    }
}


/* Transfer LEN bytes between GDB address MYADDR and target address
   MEMADDR.  If DOWRITE is non-zero, transfer them to the target,
   otherwise transfer them from the target.  TARGET is unused.

   The return value is 0 if an error occurred or no bytes were
   transferred.  Otherwise, it will be a positive value which
   indicates the number of bytes transferred between gdb and the
   target.  (Note that the interface also makes provisions for
   negative values, but this capability isn't implemented here.)  */

static int
procfs_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int dowrite,
		    struct mem_attrib *attrib, struct target_ops *target)
{
  procinfo *pi;
  int nbytes = 0;

  /* Find procinfo for main process.  */
  pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);
  if (pi->as_fd == 0 &&
      open_procinfo_files (pi, FD_AS) == 0)
    {
      proc_warn (pi, "xfer_memory, open_proc_files", __LINE__);
      return 0;
    }

  if (lseek (pi->as_fd, (off_t) memaddr, SEEK_SET) == (off_t) memaddr)
    {
      if (dowrite)
	{
#ifdef NEW_PROC_API
	  PROCFS_NOTE ("write memory:\n");
#else
	  PROCFS_NOTE ("write memory:\n");
#endif
	  nbytes = write (pi->as_fd, myaddr, len);
	}
      else
	{
	  PROCFS_NOTE ("read  memory:\n");
	  nbytes = read (pi->as_fd, myaddr, len);
	}
      if (nbytes < 0)
	{
	  nbytes = 0;
	}
    }
  return nbytes;
}

/* Called by target_resume before making child runnable.  Mark cached
   registers and status's invalid.  If there are "dirty" caches that
   need to be written back to the child process, do that.

   File descriptors are also cached.  As they are a limited resource,
   we cannot hold onto them indefinitely.  However, as they are
   expensive to open, we don't want to throw them away
   indescriminately either.  As a compromise, we will keep the file
   descriptors for the parent process, but discard any file
   descriptors we may have accumulated for the threads.

   As this function is called by iterate_over_threads, it always
   returns zero (so that iterate_over_threads will keep
   iterating).  */

static int
invalidate_cache (procinfo *parent, procinfo *pi, void *ptr)
{
  /* About to run the child; invalidate caches and do any other
     cleanup.  */

#if 0
  if (pi->gregs_dirty)
    if (parent == NULL ||
	proc_get_current_thread (parent) != pi->tid)
      if (!proc_set_gregs (pi))	/* flush gregs cache */
	proc_warn (pi, "target_resume, set_gregs",
		   __LINE__);
  if (gdbarch_fp0_regnum (target_gdbarch ()) >= 0)
    if (pi->fpregs_dirty)
      if (parent == NULL ||
	  proc_get_current_thread (parent) != pi->tid)
	if (!proc_set_fpregs (pi))	/* flush fpregs cache */
	  proc_warn (pi, "target_resume, set_fpregs",
		     __LINE__);
#endif

  if (parent != NULL)
    {
      /* The presence of a parent indicates that this is an LWP.
	 Close any file descriptors that it might have open.
	 We don't do this to the master (parent) procinfo.  */

      close_procinfo_files (pi);
    }
  pi->gregs_valid   = 0;
  pi->fpregs_valid  = 0;
#if 0
  pi->gregs_dirty   = 0;
  pi->fpregs_dirty  = 0;
#endif
  pi->status_valid  = 0;
  pi->threads_valid = 0;

  return 0;
}

#if 0
/* A callback function for iterate_over_threads.  Find the
   asynchronous signal thread, and make it runnable.  See if that
   helps matters any.  */

static int
make_signal_thread_runnable (procinfo *process, procinfo *pi, void *ptr)
{
#ifdef PR_ASLWP
  if (proc_flags (pi) & PR_ASLWP)
    {
      if (!proc_run_process (pi, 0, -1))
	proc_error (pi, "make_signal_thread_runnable", __LINE__);
      return 1;
    }
#endif
  return 0;
}
#endif

/* Make the child process runnable.  Normally we will then call
   procfs_wait and wait for it to stop again (unless gdb is async).

   If STEP is true, then arrange for the child to stop again after
   executing a single instruction.  If SIGNO is zero, then cancel any
   pending signal; if non-zero, then arrange for the indicated signal
   to be delivered to the child when it runs.  If PID is -1, then
   allow any child thread to run; if non-zero, then allow only the
   indicated thread to run.  (not implemented yet).  */

static void
procfs_resume (struct target_ops *ops,
	       ptid_t ptid, int step, enum gdb_signal signo)
{
  procinfo *pi, *thread;
  int native_signo;

  /* 2.1:
     prrun.prflags |= PRSVADDR;
     prrun.pr_vaddr = $PC;	   set resume address
     prrun.prflags |= PRSTRACE;    trace signals in pr_trace (all)
     prrun.prflags |= PRSFAULT;    trace faults in pr_fault (all but PAGE)
     prrun.prflags |= PRCFAULT;    clear current fault.

     PRSTRACE and PRSFAULT can be done by other means
	(proc_trace_signals, proc_trace_faults)
     PRSVADDR is unnecessary.
     PRCFAULT may be replaced by a PIOCCFAULT call (proc_clear_current_fault)
     This basically leaves PRSTEP and PRCSIG.
     PRCSIG is like PIOCSSIG (proc_clear_current_signal).
     So basically PR_STEP is the sole argument that must be passed
     to proc_run_process (for use in the prrun struct by ioctl).  */

  /* Find procinfo for main process.  */
  pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);

  /* First cut: ignore pid argument.  */
  errno = 0;

  /* Convert signal to host numbering.  */
  if (signo == 0 ||
      (signo == GDB_SIGNAL_STOP && pi->ignore_next_sigstop))
    native_signo = 0;
  else
    native_signo = gdb_signal_to_host (signo);

  pi->ignore_next_sigstop = 0;

  /* Running the process voids all cached registers and status.  */
  /* Void the threads' caches first.  */
  proc_iterate_over_threads (pi, invalidate_cache, NULL);
  /* Void the process procinfo's caches.  */
  invalidate_cache (NULL, pi, NULL);

  if (ptid_get_pid (ptid) != -1)
    {
      /* Resume a specific thread, presumably suppressing the
	 others.  */
      thread = find_procinfo (ptid_get_pid (ptid), ptid_get_lwp (ptid));
      if (thread != NULL)
	{
	  if (thread->tid != 0)
	    {
	      /* We're to resume a specific thread, and not the
		 others.  Set the child process's PR_ASYNC flag.  */
#ifdef PR_ASYNC
	      if (!proc_set_async (pi))
		proc_error (pi, "target_resume, set_async", __LINE__);
#endif
#if 0
	      proc_iterate_over_threads (pi,
					 make_signal_thread_runnable,
					 NULL);
#endif
	      pi = thread;	/* Substitute the thread's procinfo
				   for run.  */
	    }
	}
    }

  if (!proc_run_process (pi, step, native_signo))
    {
      if (errno == EBUSY)
	warning (_("resume: target already running.  "
		   "Pretend to resume, and hope for the best!"));
      else
	proc_error (pi, "target_resume", __LINE__);
    }
}

/* Set up to trace signals in the child process.  */

static void
procfs_pass_signals (int numsigs, unsigned char *pass_signals)
{
  gdb_sigset_t signals;
  procinfo *pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);
  int signo;

  prfillset (&signals);

  for (signo = 0; signo < NSIG; signo++)
    {
      int target_signo = gdb_signal_from_host (signo);
      if (target_signo < numsigs && pass_signals[target_signo])
	gdb_prdelset (&signals, signo);
    }

  if (!proc_set_traced_signals (pi, &signals))
    proc_error (pi, "pass_signals", __LINE__);
}

/* Print status information about the child process.  */

static void
procfs_files_info (struct target_ops *ignore)
{
  struct inferior *inf = current_inferior ();

  printf_filtered (_("\tUsing the running image of %s %s via /proc.\n"),
		   inf->attach_flag? "attached": "child",
		   target_pid_to_str (inferior_ptid));
}

/* Stop the child process asynchronously, as when the gdb user types
   control-c or presses a "stop" button.  Works by sending
   kill(SIGINT) to the child's process group.  */

static void
procfs_stop (ptid_t ptid)
{
  kill (-inferior_process_group (), SIGINT);
}

/* Make it die.  Wait for it to die.  Clean up after it.  Note: this
   should only be applied to the real process, not to an LWP, because
   of the check for parent-process.  If we need this to work for an
   LWP, it needs some more logic.  */

static void
unconditionally_kill_inferior (procinfo *pi)
{
  int parent_pid;

  parent_pid = proc_parent_pid (pi);
#ifdef PROCFS_NEED_CLEAR_CURSIG_FOR_KILL
  /* FIXME: use access functions.  */
  /* Alpha OSF/1-3.x procfs needs a clear of the current signal
     before the PIOCKILL, otherwise it might generate a corrupted core
     file for the inferior.  */
  if (ioctl (pi->ctl_fd, PIOCSSIG, NULL) < 0)
    {
      printf_filtered ("unconditionally_kill: SSIG failed!\n");
    }
#endif
#ifdef PROCFS_NEED_PIOCSSIG_FOR_KILL
  /* Alpha OSF/1-2.x procfs needs a PIOCSSIG call with a SIGKILL signal
     to kill the inferior, otherwise it might remain stopped with a
     pending SIGKILL.
     We do not check the result of the PIOCSSIG, the inferior might have
     died already.  */
  {
    gdb_siginfo_t newsiginfo;

    memset ((char *) &newsiginfo, 0, sizeof (newsiginfo));
    newsiginfo.si_signo = SIGKILL;
    newsiginfo.si_code = 0;
    newsiginfo.si_errno = 0;
    newsiginfo.si_pid = getpid ();
    newsiginfo.si_uid = getuid ();
    /* FIXME: use proc_set_current_signal.  */
    ioctl (pi->ctl_fd, PIOCSSIG, &newsiginfo);
  }
#else /* PROCFS_NEED_PIOCSSIG_FOR_KILL */
  if (!proc_kill (pi, SIGKILL))
    proc_error (pi, "unconditionally_kill, proc_kill", __LINE__);
#endif /* PROCFS_NEED_PIOCSSIG_FOR_KILL */
  destroy_procinfo (pi);

  /* If pi is GDB's child, wait for it to die.  */
  if (parent_pid == getpid ())
    /* FIXME: should we use waitpid to make sure we get the right event?
       Should we check the returned event?  */
    {
#if 0
      int status, ret;

      ret = waitpid (pi->pid, &status, 0);
#else
      wait (NULL);
#endif
    }
}

/* We're done debugging it, and we want it to go away.  Then we want
   GDB to forget all about it.  */

static void
procfs_kill_inferior (struct target_ops *ops)
{
  if (!ptid_equal (inferior_ptid, null_ptid)) /* ? */
    {
      /* Find procinfo for main process.  */
      procinfo *pi = find_procinfo (ptid_get_pid (inferior_ptid), 0);

      if (pi)
	unconditionally_kill_inferior (pi);
      target_mourn_inferior ();
    }
}

/* Forget we ever debugged this thing!  */

static void
procfs_mourn_inferior (struct target_ops *ops)
{
  procinfo *pi;

  if (!ptid_equal (inferior_ptid, null_ptid))
    {
      /* Find procinfo for main process.  */
      pi = find_procinfo (ptid_get_pid (inferior_ptid), 0);
      if (pi)
	destroy_procinfo (pi);
    }
  unpush_target (ops);

  if (dbx_link_bpt != NULL)
    {
      deprecated_remove_raw_breakpoint (target_gdbarch (), dbx_link_bpt);
      dbx_link_bpt_addr = 0;
      dbx_link_bpt = NULL;
    }

  generic_mourn_inferior ();
}

/* When GDB forks to create a runnable inferior process, this function
   is called on the parent side of the fork.  It's job is to do
   whatever is necessary to make the child ready to be debugged, and
   then wait for the child to synchronize.  */

static void
procfs_init_inferior (struct target_ops *ops, int pid)
{
  procinfo *pi;
  gdb_sigset_t signals;
  int fail;
  int lwpid;

  /* This routine called on the parent side (GDB side)
     after GDB forks the inferior.  */
  push_target (ops);

  if ((pi = create_procinfo (pid, 0)) == NULL)
    perror (_("procfs: out of memory in 'init_inferior'"));

  if (!open_procinfo_files (pi, FD_CTL))
    proc_error (pi, "init_inferior, open_proc_files", __LINE__);

  /*
    xmalloc			// done
    open_procinfo_files		// done
    link list			// done
    prfillset (trace)
    procfs_notice_signals
    prfillset (fault)
    prdelset (FLTPAGE)
    PIOCWSTOP
    PIOCSFAULT
    */

  /* If not stopped yet, wait for it to stop.  */
  if (!(proc_flags (pi) & PR_STOPPED) &&
      !(proc_wait_for_stop (pi)))
    dead_procinfo (pi, "init_inferior: wait_for_stop failed", KILL);

  /* Save some of the /proc state to be restored if we detach.  */
  /* FIXME: Why?  In case another debugger was debugging it?
     We're it's parent, for Ghu's sake!  */
  if (!proc_get_traced_signals  (pi, &pi->saved_sigset))
    proc_error (pi, "init_inferior, get_traced_signals", __LINE__);
  if (!proc_get_held_signals    (pi, &pi->saved_sighold))
    proc_error (pi, "init_inferior, get_held_signals", __LINE__);
  if (!proc_get_traced_faults   (pi, &pi->saved_fltset))
    proc_error (pi, "init_inferior, get_traced_faults", __LINE__);
  if (!proc_get_traced_sysentry (pi, pi->saved_entryset))
    proc_error (pi, "init_inferior, get_traced_sysentry", __LINE__);
  if (!proc_get_traced_sysexit  (pi, pi->saved_exitset))
    proc_error (pi, "init_inferior, get_traced_sysexit", __LINE__);

  if ((fail = procfs_debug_inferior (pi)) != 0)
    proc_error (pi, "init_inferior (procfs_debug_inferior)", fail);

  /* FIXME: logically, we should really be turning OFF run-on-last-close,
     and possibly even turning ON kill-on-last-close at this point.  But
     I can't make that change without careful testing which I don't have
     time to do right now...  */
  /* Turn on run-on-last-close flag so that the child
     will die if GDB goes away for some reason.  */
  if (!proc_set_run_on_last_close (pi))
    proc_error (pi, "init_inferior, set_RLC", __LINE__);

  /* We now have have access to the lwpid of the main thread/lwp.  */
  lwpid = proc_get_current_thread (pi);

  /* Create a procinfo for the main lwp.  */
  create_procinfo (pid, lwpid);

  /* We already have a main thread registered in the thread table at
     this point, but it didn't have any lwp info yet.  Notify the core
     about it.  This changes inferior_ptid as well.  */
  thread_change_ptid (pid_to_ptid (pid),
		      ptid_build (pid, lwpid, 0));

  /* Typically two, one trap to exec the shell, one to exec the
     program being debugged.  Defined by "inferior.h".  */
  startup_inferior (START_INFERIOR_TRAPS_EXPECTED);

#ifdef SYS_syssgi
  /* On mips-irix, we need to stop the inferior early enough during
     the startup phase in order to be able to load the shared library
     symbols and insert the breakpoints that are located in these shared
     libraries.  Stopping at the program entry point is not good enough
     because the -init code is executed before the execution reaches
     that point.

     So what we need to do is to insert a breakpoint in the runtime
     loader (rld), more precisely in __dbx_link().  This procedure is
     called by rld once all shared libraries have been mapped, but before
     the -init code is executed.  Unfortuantely, this is not straightforward,
     as rld is not part of the executable we are running, and thus we need
     the inferior to run until rld itself has been mapped in memory.

     For this, we trace all syssgi() syscall exit events.  Each time
     we detect such an event, we iterate over each text memory maps,
     get its associated fd, and scan the symbol table for __dbx_link().
     When found, we know that rld has been mapped, and that we can insert
     the breakpoint at the symbol address.  Once the dbx_link() breakpoint
     has been inserted, the syssgi() notifications are no longer necessary,
     so they should be canceled.  */
  proc_trace_syscalls_1 (pi, SYS_syssgi, PR_SYSEXIT, FLAG_SET, 0);
#endif
}

/* When GDB forks to create a new process, this function is called on
   the child side of the fork before GDB exec's the user program.  Its
   job is to make the child minimally debuggable, so that the parent
   GDB process can connect to the child and take over.  This function
   should do only the minimum to make that possible, and to
   synchronize with the parent process.  The parent process should
   take care of the details.  */

static void
procfs_set_exec_trap (void)
{
  /* This routine called on the child side (inferior side)
     after GDB forks the inferior.  It must use only local variables,
     because it may be sharing data space with its parent.  */

  procinfo *pi;
  sysset_t *exitset;

  if ((pi = create_procinfo (getpid (), 0)) == NULL)
    perror_with_name (_("procfs: create_procinfo failed in child."));

  if (open_procinfo_files (pi, FD_CTL) == 0)
    {
      proc_warn (pi, "set_exec_trap, open_proc_files", __LINE__);
      gdb_flush (gdb_stderr);
      /* No need to call "dead_procinfo", because we're going to
	 exit.  */
      _exit (127);
    }

#ifdef PRFS_STOPEXEC	/* defined on OSF */
  /* OSF method for tracing exec syscalls.  Quoting:
     Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace
     exits from exec system calls because of the user level loader.  */
  /* FIXME: make nice and maybe move into an access function.  */
  {
    int prfs_flags;

    if (ioctl (pi->ctl_fd, PIOCGSPCACT, &prfs_flags) < 0)
      {
	proc_warn (pi, "set_exec_trap (PIOCGSPCACT)", __LINE__);
	gdb_flush (gdb_stderr);
	_exit (127);
      }
    prfs_flags |= PRFS_STOPEXEC;

    if (ioctl (pi->ctl_fd, PIOCSSPCACT, &prfs_flags) < 0)
      {
	proc_warn (pi, "set_exec_trap (PIOCSSPCACT)", __LINE__);
	gdb_flush (gdb_stderr);
	_exit (127);
      }
  }
#else /* not PRFS_STOPEXEC */
  /* Everyone else's (except OSF) method for tracing exec syscalls.  */
  /* GW: Rationale...
     Not all systems with /proc have all the exec* syscalls with the same
     names.  On the SGI, for example, there is no SYS_exec, but there
     *is* a SYS_execv.  So, we try to account for that.  */

  exitset = sysset_t_alloc (pi);
  gdb_premptysysset (exitset);
#ifdef SYS_exec
  gdb_praddsysset (exitset, SYS_exec);
#endif
#ifdef SYS_execve
  gdb_praddsysset (exitset, SYS_execve);
#endif
#ifdef SYS_execv
  gdb_praddsysset (exitset, SYS_execv);
#endif
#ifdef DYNAMIC_SYSCALLS
  {
    int callnum = find_syscall (pi, "execve");

    if (callnum >= 0)
      gdb_praddsysset (exitset, callnum);

    callnum = find_syscall (pi, "ra_execve");
    if (callnum >= 0)
      gdb_praddsysset (exitset, callnum);
  }
#endif /* DYNAMIC_SYSCALLS */

  if (!proc_set_traced_sysexit (pi, exitset))
    {
      proc_warn (pi, "set_exec_trap, set_traced_sysexit", __LINE__);
      gdb_flush (gdb_stderr);
      _exit (127);
    }
#endif /* PRFS_STOPEXEC */

  /* FIXME: should this be done in the parent instead?  */
  /* Turn off inherit on fork flag so that all grand-children
     of gdb start with tracing flags cleared.  */
  if (!proc_unset_inherit_on_fork (pi))
    proc_warn (pi, "set_exec_trap, unset_inherit", __LINE__);

  /* Turn off run on last close flag, so that the child process
     cannot run away just because we close our handle on it.
     We want it to wait for the parent to attach.  */
  if (!proc_unset_run_on_last_close (pi))
    proc_warn (pi, "set_exec_trap, unset_RLC", __LINE__);

  /* FIXME: No need to destroy the procinfo --
     we have our own address space, and we're about to do an exec!  */
  /*destroy_procinfo (pi);*/
}

/* This function is called BEFORE gdb forks the inferior process.  Its
   only real responsibility is to set things up for the fork, and tell
   GDB which two functions to call after the fork (one for the parent,
   and one for the child).

   This function does a complicated search for a unix shell program,
   which it then uses to parse arguments and environment variables to
   be sent to the child.  I wonder whether this code could not be
   abstracted out and shared with other unix targets such as
   inf-ptrace?  */

static void
procfs_create_inferior (struct target_ops *ops, char *exec_file,
			char *allargs, char **env, int from_tty)
{
  char *shell_file = getenv ("SHELL");
  char *tryname;
  int pid;

  if (shell_file != NULL && strchr (shell_file, '/') == NULL)
    {

      /* We will be looking down the PATH to find shell_file.  If we
	 just do this the normal way (via execlp, which operates by
	 attempting an exec for each element of the PATH until it
	 finds one which succeeds), then there will be an exec for
	 each failed attempt, each of which will cause a PR_SYSEXIT
	 stop, and we won't know how to distinguish the PR_SYSEXIT's
	 for these failed execs with the ones for successful execs
	 (whether the exec has succeeded is stored at that time in the
	 carry bit or some such architecture-specific and
	 non-ABI-specified place).

	 So I can't think of anything better than to search the PATH
	 now.  This has several disadvantages: (1) There is a race
	 condition; if we find a file now and it is deleted before we
	 exec it, we lose, even if the deletion leaves a valid file
	 further down in the PATH, (2) there is no way to know exactly
	 what an executable (in the sense of "capable of being
	 exec'd") file is.  Using access() loses because it may lose
	 if the caller is the superuser; failing to use it loses if
	 there are ACLs or some such.  */

      char *p;
      char *p1;
      /* FIXME-maybe: might want "set path" command so user can change what
	 path is used from within GDB.  */
      char *path = getenv ("PATH");
      int len;
      struct stat statbuf;

      if (path == NULL)
	path = "/bin:/usr/bin";

      tryname = alloca (strlen (path) + strlen (shell_file) + 2);
      for (p = path; p != NULL; p = p1 ? p1 + 1: NULL)
	{
	  p1 = strchr (p, ':');
	  if (p1 != NULL)
	    len = p1 - p;
	  else
	    len = strlen (p);
	  strncpy (tryname, p, len);
	  tryname[len] = '\0';
	  strcat (tryname, "/");
	  strcat (tryname, shell_file);
	  if (access (tryname, X_OK) < 0)
	    continue;
	  if (stat (tryname, &statbuf) < 0)
	    continue;
	  if (!S_ISREG (statbuf.st_mode))
	    /* We certainly need to reject directories.  I'm not quite
	       as sure about FIFOs, sockets, etc., but I kind of doubt
	       that people want to exec() these things.  */
	    continue;
	  break;
	}
      if (p == NULL)
	/* Not found.  This must be an error rather than merely passing
	   the file to execlp(), because execlp() would try all the
	   exec()s, causing GDB to get confused.  */
	error (_("procfs:%d -- Can't find shell %s in PATH"),
	       __LINE__, shell_file);

      shell_file = tryname;
    }

  pid = fork_inferior (exec_file, allargs, env, procfs_set_exec_trap,
		       NULL, NULL, shell_file, NULL);

  procfs_init_inferior (ops, pid);
}

/* An observer for the "inferior_created" event.  */

static void
procfs_inferior_created (struct target_ops *ops, int from_tty)
{
#ifdef SYS_syssgi
  /* Make sure to cancel the syssgi() syscall-exit notifications.
     They should normally have been removed by now, but they may still
     be activated if the inferior doesn't use shared libraries, or if
     we didn't locate __dbx_link, or if we never stopped in __dbx_link.
     See procfs_init_inferior() for more details.

     Since these notifications are only ever enabled when we spawned
     the inferior ourselves, there is nothing to do when the inferior
     was created by attaching to an already running process, or when
     debugging a core file.  */
  if (current_inferior ()->attach_flag || !target_can_run (&current_target))
    return;

  proc_trace_syscalls_1 (find_procinfo_or_die (ptid_get_pid (inferior_ptid),
			 0), SYS_syssgi, PR_SYSEXIT, FLAG_RESET, 0);
#endif
}

/* Callback for find_new_threads.  Calls "add_thread".  */

static int
procfs_notice_thread (procinfo *pi, procinfo *thread, void *ptr)
{
  ptid_t gdb_threadid = ptid_build (pi->pid, thread->tid, 0);

  if (!in_thread_list (gdb_threadid) || is_exited (gdb_threadid))
    add_thread (gdb_threadid);

  return 0;
}

/* Query all the threads that the target knows about, and give them
   back to GDB to add to its list.  */

static void
procfs_find_new_threads (struct target_ops *ops)
{
  procinfo *pi;

  /* Find procinfo for main process.  */
  pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);
  proc_update_threads (pi);
  proc_iterate_over_threads (pi, procfs_notice_thread, NULL);
}

/* Return true if the thread is still 'alive'.  This guy doesn't
   really seem to be doing his job.  Got to investigate how to tell
   when a thread is really gone.  */

static int
procfs_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  int proc, thread;
  procinfo *pi;

  proc    = ptid_get_pid (ptid);
  thread  = ptid_get_lwp (ptid);
  /* If I don't know it, it ain't alive!  */
  if ((pi = find_procinfo (proc, thread)) == NULL)
    return 0;

  /* If I can't get its status, it ain't alive!
     What's more, I need to forget about it!  */
  if (!proc_get_status (pi))
    {
      destroy_procinfo (pi);
      return 0;
    }
  /* I couldn't have got its status if it weren't alive, so it's
     alive.  */
  return 1;
}

/* Convert PTID to a string.  Returns the string in a static
   buffer.  */

static char *
procfs_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  static char buf[80];

  if (ptid_get_lwp (ptid) == 0)
    sprintf (buf, "process %d", ptid_get_pid (ptid));
  else
    sprintf (buf, "LWP %ld", ptid_get_lwp (ptid));

  return buf;
}

/* Insert a watchpoint.  */

static int
procfs_set_watchpoint (ptid_t ptid, CORE_ADDR addr, int len, int rwflag,
		       int after)
{
#ifndef AIX5
  int       pflags = 0;
  procinfo *pi;

  pi = find_procinfo_or_die (ptid_get_pid (ptid) == -1 ?
			     ptid_get_pid (inferior_ptid) : ptid_get_pid (ptid),
			     0);

  /* Translate from GDB's flags to /proc's.  */
  if (len > 0)	/* len == 0 means delete watchpoint.  */
    {
      switch (rwflag) {		/* FIXME: need an enum!  */
      case hw_write:		/* default watchpoint (write) */
	pflags = WRITE_WATCHFLAG;
	break;
      case hw_read:		/* read watchpoint */
	pflags = READ_WATCHFLAG;
	break;
      case hw_access:		/* access watchpoint */
	pflags = READ_WATCHFLAG | WRITE_WATCHFLAG;
	break;
      case hw_execute:		/* execution HW breakpoint */
	pflags = EXEC_WATCHFLAG;
	break;
      default:			/* Something weird.  Return error.  */
	return -1;
      }
      if (after)		/* Stop after r/w access is completed.  */
	pflags |= AFTER_WATCHFLAG;
    }

  if (!proc_set_watchpoint (pi, addr, len, pflags))
    {
      if (errno == E2BIG)	/* Typical error for no resources.  */
	return -1;		/* fail */
      /* GDB may try to remove the same watchpoint twice.
	 If a remove request returns no match, don't error.  */
      if (errno == ESRCH && len == 0)
	return 0;		/* ignore */
      proc_error (pi, "set_watchpoint", __LINE__);
    }
#endif /* AIX5 */
  return 0;
}

/* Return non-zero if we can set a hardware watchpoint of type TYPE.  TYPE
   is one of bp_hardware_watchpoint, bp_read_watchpoint, bp_write_watchpoint,
   or bp_hardware_watchpoint.  CNT is the number of watchpoints used so
   far.

   Note:  procfs_can_use_hw_breakpoint() is not yet used by all
   procfs.c targets due to the fact that some of them still define
   target_can_use_hardware_watchpoint.  */

static int
procfs_can_use_hw_breakpoint (int type, int cnt, int othertype)
{
  /* Due to the way that proc_set_watchpoint() is implemented, host
     and target pointers must be of the same size.  If they are not,
     we can't use hardware watchpoints.  This limitation is due to the
     fact that proc_set_watchpoint() calls
     procfs_address_to_host_pointer(); a close inspection of
     procfs_address_to_host_pointer will reveal that an internal error
     will be generated when the host and target pointer sizes are
     different.  */
  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;

  if (sizeof (void *) != TYPE_LENGTH (ptr_type))
    return 0;

  /* Other tests here???  */

  return 1;
}

/* Returns non-zero if process is stopped on a hardware watchpoint
   fault, else returns zero.  */

static int
procfs_stopped_by_watchpoint (void)
{
  procinfo *pi;

  pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);

  if (proc_flags (pi) & (PR_STOPPED | PR_ISTOP))
    {
      if (proc_why (pi) == PR_FAULTED)
	{
#ifdef FLTWATCH
	  if (proc_what (pi) == FLTWATCH)
	    return 1;
#endif
#ifdef FLTKWATCH
	  if (proc_what (pi) == FLTKWATCH)
	    return 1;
#endif
	}
    }
  return 0;
}

/* Returns 1 if the OS knows the position of the triggered watchpoint,
   and sets *ADDR to that address.  Returns 0 if OS cannot report that
   address.  This function is only called if
   procfs_stopped_by_watchpoint returned 1, thus no further checks are
   done.  The function also assumes that ADDR is not NULL.  */

static int
procfs_stopped_data_address (struct target_ops *targ, CORE_ADDR *addr)
{
  procinfo *pi;

  pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);
  return proc_watchpoint_address (pi, addr);
}

static int
procfs_insert_watchpoint (CORE_ADDR addr, int len, int type,
			  struct expression *cond)
{
  if (!target_have_steppable_watchpoint
      && !gdbarch_have_nonsteppable_watchpoint (target_gdbarch ()))
    {
      /* When a hardware watchpoint fires off the PC will be left at
	 the instruction following the one which caused the
	 watchpoint.  It will *NOT* be necessary for GDB to step over
	 the watchpoint.  */
      return procfs_set_watchpoint (inferior_ptid, addr, len, type, 1);
    }
  else
    {
      /* When a hardware watchpoint fires off the PC will be left at
	 the instruction which caused the watchpoint.  It will be
	 necessary for GDB to step over the watchpoint.  */
      return procfs_set_watchpoint (inferior_ptid, addr, len, type, 0);
    }
}

static int
procfs_remove_watchpoint (CORE_ADDR addr, int len, int type,
			  struct expression *cond)
{
  return procfs_set_watchpoint (inferior_ptid, addr, 0, 0, 0);
}

static int
procfs_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)
{
  /* The man page for proc(4) on Solaris 2.6 and up says that the
     system can support "thousands" of hardware watchpoints, but gives
     no method for finding out how many; It doesn't say anything about
     the allowed size for the watched area either.  So we just tell
     GDB 'yes'.  */
  return 1;
}

void
procfs_use_watchpoints (struct target_ops *t)
{
  t->to_stopped_by_watchpoint = procfs_stopped_by_watchpoint;
  t->to_insert_watchpoint = procfs_insert_watchpoint;
  t->to_remove_watchpoint = procfs_remove_watchpoint;
  t->to_region_ok_for_hw_watchpoint = procfs_region_ok_for_hw_watchpoint;
  t->to_can_use_hw_breakpoint = procfs_can_use_hw_breakpoint;
  t->to_stopped_data_address = procfs_stopped_data_address;
}

/* Memory Mappings Functions: */

/* Call a callback function once for each mapping, passing it the
   mapping, an optional secondary callback function, and some optional
   opaque data.  Quit and return the first non-zero value returned
   from the callback.

   PI is the procinfo struct for the process to be mapped.  FUNC is
   the callback function to be called by this iterator.  DATA is the
   optional opaque data to be passed to the callback function.
   CHILD_FUNC is the optional secondary function pointer to be passed
   to the child function.  Returns the first non-zero return value
   from the callback function, or zero.  */

static int
iterate_over_mappings (procinfo *pi, find_memory_region_ftype child_func,
		       void *data,
		       int (*func) (struct prmap *map,
				    find_memory_region_ftype child_func,
				    void *data))
{
  char pathname[MAX_PROC_NAME_SIZE];
  struct prmap *prmaps;
  struct prmap *prmap;
  int funcstat;
  int map_fd;
  int nmap;
  struct cleanup *cleanups = make_cleanup (null_cleanup, NULL);
#ifdef NEW_PROC_API
  struct stat sbuf;
#endif

  /* Get the number of mappings, allocate space,
     and read the mappings into prmaps.  */
#ifdef NEW_PROC_API
  /* Open map fd.  */
  sprintf (pathname, "/proc/%d/map", pi->pid);
  if ((map_fd = open (pathname, O_RDONLY)) < 0)
    proc_error (pi, "iterate_over_mappings (open)", __LINE__);

  /* Make sure it gets closed again.  */
  make_cleanup_close (map_fd);

  /* Use stat to determine the file size, and compute
     the number of prmap_t objects it contains.  */
  if (fstat (map_fd, &sbuf) != 0)
    proc_error (pi, "iterate_over_mappings (fstat)", __LINE__);

  nmap = sbuf.st_size / sizeof (prmap_t);
  prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));
  if (read (map_fd, (char *) prmaps, nmap * sizeof (*prmaps))
      != (nmap * sizeof (*prmaps)))
    proc_error (pi, "iterate_over_mappings (read)", __LINE__);
#else
  /* Use ioctl command PIOCNMAP to get number of mappings.  */
  if (ioctl (pi->ctl_fd, PIOCNMAP, &nmap) != 0)
    proc_error (pi, "iterate_over_mappings (PIOCNMAP)", __LINE__);

  prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));
  if (ioctl (pi->ctl_fd, PIOCMAP, prmaps) != 0)
    proc_error (pi, "iterate_over_mappings (PIOCMAP)", __LINE__);
#endif

  for (prmap = prmaps; nmap > 0; prmap++, nmap--)
    if ((funcstat = (*func) (prmap, child_func, data)) != 0)
      {
	do_cleanups (cleanups);
        return funcstat;
      }

  do_cleanups (cleanups);
  return 0;
}

/* Implements the to_find_memory_regions method.  Calls an external
   function for each memory region.
   Returns the integer value returned by the callback.  */

static int
find_memory_regions_callback (struct prmap *map,
			      find_memory_region_ftype func, void *data)
{
  return (*func) ((CORE_ADDR) map->pr_vaddr,
		  map->pr_size,
		  (map->pr_mflags & MA_READ) != 0,
		  (map->pr_mflags & MA_WRITE) != 0,
		  (map->pr_mflags & MA_EXEC) != 0,
		  1, /* MODIFIED is unknown, pass it as true.  */
		  data);
}

/* External interface.  Calls a callback function once for each
   mapped memory region in the child process, passing as arguments:

	CORE_ADDR virtual_address,
	unsigned long size,
	int read,	TRUE if region is readable by the child
	int write,	TRUE if region is writable by the child
	int execute	TRUE if region is executable by the child.

   Stops iterating and returns the first non-zero value returned by
   the callback.  */

static int
proc_find_memory_regions (find_memory_region_ftype func, void *data)
{
  procinfo *pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);

  return iterate_over_mappings (pi, func, data,
				find_memory_regions_callback);
}

/* Returns an ascii representation of a memory mapping's flags.  */

static char *
mappingflags (long flags)
{
  static char asciiflags[8];

  strcpy (asciiflags, "-------");
#if defined (MA_PHYS)
  if (flags & MA_PHYS)
    asciiflags[0] = 'd';
#endif
  if (flags & MA_STACK)
    asciiflags[1] = 's';
  if (flags & MA_BREAK)
    asciiflags[2] = 'b';
  if (flags & MA_SHARED)
    asciiflags[3] = 's';
  if (flags & MA_READ)
    asciiflags[4] = 'r';
  if (flags & MA_WRITE)
    asciiflags[5] = 'w';
  if (flags & MA_EXEC)
    asciiflags[6] = 'x';
  return (asciiflags);
}

/* Callback function, does the actual work for 'info proc
   mappings'.  */

static int
info_mappings_callback (struct prmap *map, find_memory_region_ftype ignore,
			void *unused)
{
  unsigned int pr_off;

#ifdef PCAGENT	/* Horrible hack: only defined on Solaris 2.6+ */
  pr_off = (unsigned int) map->pr_offset;
#else
  pr_off = map->pr_off;
#endif

  if (gdbarch_addr_bit (target_gdbarch ()) == 32)
    printf_filtered ("\t%#10lx %#10lx %#10lx %#10x %7s\n",
		     (unsigned long) map->pr_vaddr,
		     (unsigned long) map->pr_vaddr + map->pr_size - 1,
		     (unsigned long) map->pr_size,
		     pr_off,
		     mappingflags (map->pr_mflags));
  else
    printf_filtered ("  %#18lx %#18lx %#10lx %#10x %7s\n",
		     (unsigned long) map->pr_vaddr,
		     (unsigned long) map->pr_vaddr + map->pr_size - 1,
		     (unsigned long) map->pr_size,
		     pr_off,
		     mappingflags (map->pr_mflags));

  return 0;
}

/* Implement the "info proc mappings" subcommand.  */

static void
info_proc_mappings (procinfo *pi, int summary)
{
  if (summary)
    return;	/* No output for summary mode.  */

  printf_filtered (_("Mapped address spaces:\n\n"));
  if (gdbarch_ptr_bit (target_gdbarch ()) == 32)
    printf_filtered ("\t%10s %10s %10s %10s %7s\n",
		     "Start Addr",
		     "  End Addr",
		     "      Size",
		     "    Offset",
		     "Flags");
  else
    printf_filtered ("  %18s %18s %10s %10s %7s\n",
		     "Start Addr",
		     "  End Addr",
		     "      Size",
		     "    Offset",
		     "Flags");

  iterate_over_mappings (pi, NULL, NULL, info_mappings_callback);
  printf_filtered ("\n");
}

/* Implement the "info proc" command.  */

static void
procfs_info_proc (struct target_ops *ops, char *args,
		  enum info_proc_what what)
{
  struct cleanup *old_chain;
  procinfo *process  = NULL;
  procinfo *thread   = NULL;
  char    **argv     = NULL;
  char     *tmp      = NULL;
  int       pid      = 0;
  int       tid      = 0;
  int       mappings = 0;

  switch (what)
    {
    case IP_MINIMAL:
      break;

    case IP_MAPPINGS:
    case IP_ALL:
      mappings = 1;
      break;

    default:
      error (_("Not supported on this target."));
    }

  old_chain = make_cleanup (null_cleanup, 0);
  if (args)
    {
      argv = gdb_buildargv (args);
      make_cleanup_freeargv (argv);
    }
  while (argv != NULL && *argv != NULL)
    {
      if (isdigit (argv[0][0]))
	{
	  pid = strtoul (argv[0], &tmp, 10);
	  if (*tmp == '/')
	    tid = strtoul (++tmp, NULL, 10);
	}
      else if (argv[0][0] == '/')
	{
	  tid = strtoul (argv[0] + 1, NULL, 10);
	}
      argv++;
    }
  if (pid == 0)
    pid = ptid_get_pid (inferior_ptid);
  if (pid == 0)
    error (_("No current process: you must name one."));
  else
    {
      /* Have pid, will travel.
	 First see if it's a process we're already debugging.  */
      process = find_procinfo (pid, 0);
       if (process == NULL)
	 {
	   /* No.  So open a procinfo for it, but
	      remember to close it again when finished.  */
	   process = create_procinfo (pid, 0);
	   make_cleanup (do_destroy_procinfo_cleanup, process);
	   if (!open_procinfo_files (process, FD_CTL))
	     proc_error (process, "info proc, open_procinfo_files", __LINE__);
	 }
    }
  if (tid != 0)
    thread = create_procinfo (pid, tid);

  if (process)
    {
      printf_filtered (_("process %d flags:\n"), process->pid);
      proc_prettyprint_flags (proc_flags (process), 1);
      if (proc_flags (process) & (PR_STOPPED | PR_ISTOP))
	proc_prettyprint_why (proc_why (process), proc_what (process), 1);
      if (proc_get_nthreads (process) > 1)
	printf_filtered ("Process has %d threads.\n",
			 proc_get_nthreads (process));
    }
  if (thread)
    {
      printf_filtered (_("thread %d flags:\n"), thread->tid);
      proc_prettyprint_flags (proc_flags (thread), 1);
      if (proc_flags (thread) & (PR_STOPPED | PR_ISTOP))
	proc_prettyprint_why (proc_why (thread), proc_what (thread), 1);
    }

  if (mappings)
    {
      info_proc_mappings (process, 0);
    }

  do_cleanups (old_chain);
}

/* Modify the status of the system call identified by SYSCALLNUM in
   the set of syscalls that are currently traced/debugged.

   If ENTRY_OR_EXIT is set to PR_SYSENTRY, then the entry syscalls set
   will be updated.  Otherwise, the exit syscalls set will be updated.

   If MODE is FLAG_SET, then traces will be enabled.  Otherwise, they
   will be disabled.  */

static void
proc_trace_syscalls_1 (procinfo *pi, int syscallnum, int entry_or_exit,
		       int mode, int from_tty)
{
  sysset_t *sysset;

  if (entry_or_exit == PR_SYSENTRY)
    sysset = proc_get_traced_sysentry (pi, NULL);
  else
    sysset = proc_get_traced_sysexit (pi, NULL);

  if (sysset == NULL)
    proc_error (pi, "proc-trace, get_traced_sysset", __LINE__);

  if (mode == FLAG_SET)
    gdb_praddsysset (sysset, syscallnum);
  else
    gdb_prdelsysset (sysset, syscallnum);

  if (entry_or_exit == PR_SYSENTRY)
    {
      if (!proc_set_traced_sysentry (pi, sysset))
	proc_error (pi, "proc-trace, set_traced_sysentry", __LINE__);
    }
  else
    {
      if (!proc_set_traced_sysexit (pi, sysset))
	proc_error (pi, "proc-trace, set_traced_sysexit", __LINE__);
    }
}

static void
proc_trace_syscalls (char *args, int from_tty, int entry_or_exit, int mode)
{
  procinfo *pi;

  if (ptid_get_pid (inferior_ptid) <= 0)
    error (_("you must be debugging a process to use this command."));

  if (args == NULL || args[0] == 0)
    error_no_arg (_("system call to trace"));

  pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);
  if (isdigit (args[0]))
    {
      const int syscallnum = atoi (args);

      proc_trace_syscalls_1 (pi, syscallnum, entry_or_exit, mode, from_tty);
    }
}

static void
proc_trace_sysentry_cmd (char *args, int from_tty)
{
  proc_trace_syscalls (args, from_tty, PR_SYSENTRY, FLAG_SET);
}

static void
proc_trace_sysexit_cmd (char *args, int from_tty)
{
  proc_trace_syscalls (args, from_tty, PR_SYSEXIT, FLAG_SET);
}

static void
proc_untrace_sysentry_cmd (char *args, int from_tty)
{
  proc_trace_syscalls (args, from_tty, PR_SYSENTRY, FLAG_RESET);
}

static void
proc_untrace_sysexit_cmd (char *args, int from_tty)
{
  proc_trace_syscalls (args, from_tty, PR_SYSEXIT, FLAG_RESET);
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
extern void _initialize_procfs (void);

void
_initialize_procfs (void)
{
  observer_attach_inferior_created (procfs_inferior_created);

  add_com ("proc-trace-entry", no_class, proc_trace_sysentry_cmd,
	   _("Give a trace of entries into the syscall."));
  add_com ("proc-trace-exit", no_class, proc_trace_sysexit_cmd,
	   _("Give a trace of exits from the syscall."));
  add_com ("proc-untrace-entry", no_class, proc_untrace_sysentry_cmd,
	   _("Cancel a trace of entries into the syscall."));
  add_com ("proc-untrace-exit", no_class, proc_untrace_sysexit_cmd,
	   _("Cancel a trace of exits from the syscall."));
}

/* =================== END, GDB  "MODULE" =================== */



/* miscellaneous stubs: */

/* The following satisfy a few random symbols mostly created by the
   solaris threads implementation, which I will chase down later.  */

/* Return a pid for which we guarantee we will be able to find a
   'live' procinfo.  */

ptid_t
procfs_first_available (void)
{
  return pid_to_ptid (procinfo_list ? procinfo_list->pid : -1);
}

/* ===================  GCORE .NOTE "MODULE" =================== */
#if defined (PIOCOPENLWP) || defined (PCAGENT)
/* gcore only implemented on solaris (so far) */

static char *
procfs_do_thread_registers (bfd *obfd, ptid_t ptid,
			    char *note_data, int *note_size,
			    enum gdb_signal stop_signal)
{
  struct regcache *regcache = get_thread_regcache (ptid);
  gdb_gregset_t gregs;
  gdb_fpregset_t fpregs;
  unsigned long merged_pid;
  struct cleanup *old_chain;

  merged_pid = ptid_get_lwp (ptid) << 16 | ptid_get_pid (ptid);

  /* This part is the old method for fetching registers.
     It should be replaced by the newer one using regsets
     once it is implemented in this platform:
     gdbarch_regset_from_core_section() and regset->collect_regset().  */

  old_chain = save_inferior_ptid ();
  inferior_ptid = ptid;
  target_fetch_registers (regcache, -1);

  fill_gregset (regcache, &gregs, -1);
#if defined (NEW_PROC_API)
  note_data = (char *) elfcore_write_lwpstatus (obfd,
						note_data,
						note_size,
						merged_pid,
						stop_signal,
						&gregs);
#else
  note_data = (char *) elfcore_write_prstatus (obfd,
					       note_data,
					       note_size,
					       merged_pid,
					       stop_signal,
					       &gregs);
#endif
  fill_fpregset (regcache, &fpregs, -1);
  note_data = (char *) elfcore_write_prfpreg (obfd,
					      note_data,
					      note_size,
					      &fpregs,
					      sizeof (fpregs));

  do_cleanups (old_chain);

  return note_data;
}

struct procfs_corefile_thread_data {
  bfd *obfd;
  char *note_data;
  int *note_size;
  enum gdb_signal stop_signal;
};

static int
procfs_corefile_thread_callback (procinfo *pi, procinfo *thread, void *data)
{
  struct procfs_corefile_thread_data *args = data;

  if (pi != NULL)
    {
      ptid_t ptid = ptid_build (pi->pid, thread->tid, 0);

      args->note_data = procfs_do_thread_registers (args->obfd, ptid,
						    args->note_data,
						    args->note_size,
						    args->stop_signal);
    }
  return 0;
}

static int
find_signalled_thread (struct thread_info *info, void *data)
{
  if (info->suspend.stop_signal != GDB_SIGNAL_0
      && ptid_get_pid (info->ptid) == ptid_get_pid (inferior_ptid))
    return 1;

  return 0;
}

static enum gdb_signal
find_stop_signal (void)
{
  struct thread_info *info =
    iterate_over_threads (find_signalled_thread, NULL);

  if (info)
    return info->suspend.stop_signal;
  else
    return GDB_SIGNAL_0;
}

static char *
procfs_make_note_section (bfd *obfd, int *note_size)
{
  struct cleanup *old_chain;
  gdb_gregset_t gregs;
  gdb_fpregset_t fpregs;
  char fname[16] = {'\0'};
  char psargs[80] = {'\0'};
  procinfo *pi = find_procinfo_or_die (ptid_get_pid (inferior_ptid), 0);
  char *note_data = NULL;
  char *inf_args;
  struct procfs_corefile_thread_data thread_args;
  gdb_byte *auxv;
  int auxv_len;
  enum gdb_signal stop_signal;

  if (get_exec_file (0))
    {
      strncpy (fname, lbasename (get_exec_file (0)), sizeof (fname));
      fname[sizeof (fname) - 1] = 0;
      strncpy (psargs, get_exec_file (0), sizeof (psargs));
      psargs[sizeof (psargs) - 1] = 0;

      inf_args = get_inferior_args ();
      if (inf_args && *inf_args &&
	  strlen (inf_args) < ((int) sizeof (psargs) - (int) strlen (psargs)))
	{
	  strncat (psargs, " ",
		   sizeof (psargs) - strlen (psargs));
	  strncat (psargs, inf_args,
		   sizeof (psargs) - strlen (psargs));
	}
    }

  note_data = (char *) elfcore_write_prpsinfo (obfd,
					       note_data,
					       note_size,
					       fname,
					       psargs);

  stop_signal = find_stop_signal ();

#ifdef NEW_PROC_API
  fill_gregset (get_current_regcache (), &gregs, -1);
  note_data = elfcore_write_pstatus (obfd, note_data, note_size,
				     ptid_get_pid (inferior_ptid),
				     stop_signal, &gregs);
#endif

  thread_args.obfd = obfd;
  thread_args.note_data = note_data;
  thread_args.note_size = note_size;
  thread_args.stop_signal = stop_signal;
  proc_iterate_over_threads (pi, procfs_corefile_thread_callback,
			     &thread_args);

  /* There should be always at least one thread.  */
  gdb_assert (thread_args.note_data != note_data);
  note_data = thread_args.note_data;

  auxv_len = target_read_alloc (&current_target, TARGET_OBJECT_AUXV,
				NULL, &auxv);
  if (auxv_len > 0)
    {
      note_data = elfcore_write_note (obfd, note_data, note_size,
				      "CORE", NT_AUXV, auxv, auxv_len);
      xfree (auxv);
    }

  make_cleanup (xfree, note_data);
  return note_data;
}
#else /* !Solaris */
static char *
procfs_make_note_section (bfd *obfd, int *note_size)
{
  error (_("gcore not implemented for this host."));
  return NULL;	/* lint */
}
#endif /* Solaris */
/* ===================  END GCORE .NOTE "MODULE" =================== */
@


1.168
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@d4452 1
a4452 1
		      ptid_build (pid, lwpid), 0);
@


1.167
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d2572 1
a2572 1
  if ((pi = find_procinfo (PIDGET (ptid), TIDGET (ptid))) == NULL)
d2575 1
a2575 1
	       PIDGET (ptid), TIDGET (ptid));
d2582 1
a2582 1
	       PIDGET (ptid), TIDGET (ptid));
d3077 1
a3077 1
  int pid = PIDGET (inferior_ptid);
d3110 1
a3110 1
  if ((pi = create_procinfo (PIDGET (ptid), 0)) == NULL)
d3117 1
a3117 1
	       PIDGET (ptid));
d3166 1
a3166 1
  ptid = MERGEPID (pi->pid, lwpid);
d3178 2
a3179 1
  pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0); /* FIXME: threads */
d3237 2
a3238 2
  int pid = PIDGET (inferior_ptid);
  int tid = TIDGET (inferior_ptid);
d3286 2
a3287 2
  int pid = PIDGET (inferior_ptid);
  int tid = TIDGET (inferior_ptid);
d3588 1
a3588 1
  pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d3614 2
a3615 1
	      if (wait_retval != PIDGET (inferior_ptid)) /* wrong child?  */
d3618 1
a3618 1
		       PIDGET (inferior_ptid), wait_retval);
d3662 1
a3662 1
	      retval = MERGEPID (pi->pid, proc_get_current_thread (pi));
d3798 1
a3798 1
		    temp_ptid = MERGEPID (pi->pid, temp_tid);
d3868 1
a3868 1
		    temp_ptid = MERGEPID (pi->pid, temp_tid);
d3947 1
a3947 1
	      if (PIDGET (retval) > 0 &&
d3955 4
a3958 2
		  if (find_procinfo (PIDGET (retval), TIDGET (retval)) == NULL)
		    create_procinfo (PIDGET (retval), TIDGET (retval));
d4030 1
a4030 1
  pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d4173 1
a4173 1
  pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d4193 1
a4193 1
  if (PIDGET (ptid) != -1)
d4197 1
a4197 1
      thread = find_procinfo (PIDGET (ptid), TIDGET (ptid));
d4235 1
a4235 1
  procinfo *pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d4342 1
a4342 1
      procinfo *pi = find_procinfo (PIDGET (inferior_ptid), 0);
d4360 1
a4360 1
      pi = find_procinfo (PIDGET (inferior_ptid), 0);
d4452 1
a4452 1
		      MERGEPID (pid, lwpid));
d4705 2
a4706 2
  proc_trace_syscalls_1 (find_procinfo_or_die (PIDGET (inferior_ptid), 0),
			 SYS_syssgi, PR_SYSEXIT, FLAG_RESET, 0);
d4715 1
a4715 1
  ptid_t gdb_threadid = MERGEPID (pi->pid, thread->tid);
d4732 1
a4732 1
  pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d4747 2
a4748 2
  proc    = PIDGET (ptid);
  thread  = TIDGET (ptid);
d4773 2
a4774 2
  if (TIDGET (ptid) == 0)
    sprintf (buf, "process %d", PIDGET (ptid));
d4776 1
a4776 1
    sprintf (buf, "LWP %ld", TIDGET (ptid));
d4791 3
a4793 2
  pi = find_procinfo_or_die (PIDGET (ptid) == -1 ?
			     PIDGET (inferior_ptid) : PIDGET (ptid), 0);
d4870 1
a4870 1
  pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d4900 1
a4900 1
  pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d5061 1
a5061 1
  procinfo *pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d5205 1
a5205 1
    pid = PIDGET (inferior_ptid);
d5297 1
a5297 1
  if (PIDGET (inferior_ptid) <= 0)
d5303 1
a5303 1
  pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d5388 1
a5388 1
  merged_pid = TIDGET (ptid) << 16 | PIDGET (ptid);
d5441 1
a5441 1
      ptid_t ptid = MERGEPID (pi->pid, thread->tid);
d5481 1
a5481 1
  procinfo *pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);
d5518 1
a5518 1
				     PIDGET (inferior_ptid),
@


1.166
log
@2012-12-11  Pedro Alves  <pedro@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* procfs.c (procfs_make_note_section) [NEW_PROC_API]: Output a
	NT_PSTATUS note.
	* sol2-tdep.c (sol2_core_pid_to_str): Print process IDs
	differently from LWP IDs.
@
text
@d3 1
a3 1
   Copyright (C) 1999-2003, 2006-2012 Free Software Foundation, Inc.
@


1.165
log
@gdb/
2012-12-11  Pedro Alves  <palves@@redhat.com>

	* configure.ac (detect type of /proc): Remove Unixware handling.
	* configure: Regenerate.
	* proc-api.c (ioctl_table) [PIOCLSTATUS]: Don't mention Unixware.
	(ioctl_table) [PCRESET]: Remove entry.
	* proc-events.c (SYS_lwp_create, SYS_lwp_exit, SYS_lwp_wait)
	(SYS_lwp_self, SYS_lwp_info, SYS_lwp_private, SYS_lwp_kill)
	(SYS_lwp_suspend, SYS_lwp_continue): Don't define.
	* proc-why.c (pr_why_table) [PR_SUSPENDED]: Don't mention Unixware.
	* procfs.c: Remove all UNIXWARE guarded code, and all traces of
	Unixware in comments throughout.
	* i386-tdep.c (i386_svr4_sigtramp_p): Don't match _sigacthandler,
	and remove mention of Unixware.

gdb/doc/
2012-12-11  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo: Remove all mentions of Unixware throughout.
@
text
@d5510 7
@


1.164
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@a64 1
     Unixware
d551 1
a551 1
     NEW_PROC_API (Solaris 2.6, Solaris 2.7, Unixware):
a1076 10
#if 0 /*def UNIXWARE*/
	  if (pi->status_valid &&
	      (pi->prstatus.pr_lwp.pr_flags & PR_ISTOP) &&
	      pi->prstatus.pr_lwp.pr_why == PR_REQUESTED)
	    /* Unixware peculiarity -- read the damn thing again!  */
	    pi->status_valid = (read (pi->status_fd,
				      (char *) &pi->prstatus,
				      sizeof (gdb_prstatus_t))
				== sizeof (gdb_prstatus_t));
#endif /* UNIXWARE */
a1139 6
# ifdef UNIXWARE
  /* UnixWare 7.1 puts process status flags, e.g. PR_ASYNC, in
     pstatus_t and LWP status flags, e.g. PR_STOPPED, in lwpstatus_t.
     The two sets of flags don't overlap.  */
  return pi->prstatus.pr_flags | pi->prstatus.pr_lwp.pr_flags;
# else
a1140 1
# endif
d1302 1
a1302 1
#ifdef NEW_PROC_API	/* Newest method: UnixWare and newer Solarii.  */
a1805 3
#ifdef UNIXWARE
  ret = &pi->prstatus.pr_lwp.pr_context.uc_sigmask;
#else
a1806 1
#endif /* UNIXWARE */
a2187 3
  /* OK, sorry about the ifdef's.  There's three cases instead of two,
     because in this case Unixware and Solaris/RW differ.  */

a2188 3
# ifdef UNIXWARE		/* FIXME:  Should be autoconfigured.  */
  return &pi->prstatus.pr_lwp.pr_context.uc_mcontext.gregs;
# else
a2189 1
# endif
a2205 3
# ifdef UNIXWARE		/* FIXME:  Should be autoconfigured.  */
  return &pi->prstatus.pr_lwp.pr_context.uc_mcontext.fpregs;
# else
a2206 1
# endif
d2421 1
a2421 1
    && !(defined (PIOCOPENLWP) || defined (UNIXWARE))
d2445 1
a2445 1
#if defined (PIOCOPENLWP) || defined (UNIXWARE)	/* Solaris 2.5: bail out.  */
d2618 1
a2618 1
/* Solaris and Unixware version */
d2653 1
a2653 1
/* Solaris and Unixware version */
d2761 1
a2761 1
/* Unixware and Solaris 6 (and later) version.  */
d2788 5
a2792 7
  /* Unixware

     Note: this brute-force method is the only way I know of to
     accomplish this task on Unixware.  This method will also work on
     Solaris 2.6 and 2.7.  There is a much simpler and more elegant
     way to do this on Solaris, but the margins of this manuscript are
     too small to write it here...  ;-)  */
a4782 1
#ifndef UNIXWARE
a4823 1
#endif /* UNIXWARE */
d5369 2
a5370 2
#if defined (UNIXWARE) || defined (PIOCOPENLWP) || defined (PCAGENT)
/* gcore only implemented on solaris and unixware (so far) */
a5509 7
#ifdef UNIXWARE
  fill_gregset (get_current_regcache (), &gregs, -1);
  note_data = elfcore_write_pstatus (obfd, note_data, note_size,
				     PIDGET (inferior_ptid),
				     stop_signal, &gregs);
#endif

d5533 1
a5533 1
#else /* !(Solaris or Unixware) */
d5540 1
a5540 1
#endif /* Solaris or Unixware */
@


1.163
log
@Make procfs.c:proc_get_LDT_entry static

This function is not used outside of procfs.c.

gdb/ChangeLog:

        * procfs.c (proc_get_LDT_entry): Make static.
@
text
@d162 1
a162 1
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d1209 2
a1210 2
  *addr = (CORE_ADDR) gdbarch_pointer_to_address (target_gdbarch,
	    builtin_type (target_gdbarch)->builtin_data_ptr,
d1213 2
a1214 2
  *addr = (CORE_ADDR) gdbarch_pointer_to_address (target_gdbarch,
	    builtin_type (target_gdbarch)->builtin_data_ptr,
d2458 1
a2458 1
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d2462 1
a2462 1
  gdbarch_address_to_pointer (target_gdbarch, ptr_type,
d3433 1
a3433 1
  if (deprecated_remove_raw_breakpoint (target_gdbarch, dbx_link_bpt) != 0)
d3506 1
a3506 1
      dbx_link_bpt = deprecated_insert_raw_breakpoint (target_gdbarch, NULL,
d4121 1
a4121 1
  if (gdbarch_fp0_regnum (target_gdbarch) >= 0)
d4399 1
a4399 1
      deprecated_remove_raw_breakpoint (target_gdbarch, dbx_link_bpt);
d4884 1
a4884 1
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d4941 1
a4941 1
      && !gdbarch_have_nonsteppable_watchpoint (target_gdbarch))
d5141 1
a5141 1
  if (gdbarch_addr_bit (target_gdbarch) == 32)
d5168 1
a5168 1
  if (gdbarch_ptr_bit (target_gdbarch) == 32)
@


1.162
log
@Fix declaration of proc_find_memory_regions

This function is used as a target_ops callback. The function
implemention was recently changed, but the declaration wasn't
updated accordingly.

This fixes a build failure on Solaris.

gdb/ChangeLog:

        * procfs.c (proc_find_memory_regions): Fix declaration.
@
text
@d2520 1
a2520 1
struct ssd *
@


1.161
log
@	* procfs.c: Add gdb_bfd header.
	* rs6000-nat.c: Likewise.
	* solib-pa64.c: Likewise.
	* spu-linux-nat.c: Likewise.
	* windows-nat.c: Likewise.
@
text
@d145 1
a145 5
static int proc_find_memory_regions (int (*) (CORE_ADDR,
					      unsigned long,
					      int, int, int,
					      void *),
				     void *);
@


1.160
log
@gdb/
	PR 11804
	* defs.h (find_memory_region_ftype): New comment.  New arg modified.
	* fbsd-nat.c (fbsd_find_memory_regions): Add the passed modified value.
	* gcore.c (gcore_create_callback): New function comment.  Add modified
	parameter.  Only write modified regions.  Set SEC_READONLY exactly
	according to MODIFIED.
	(objfile_find_memory_regions): Ignore separate debug info files.  Ass
	the passed modified value to FUNC.
	* gnu-nat.c (gnu_find_memory_regions): Add the passed modified value.
	* linux-tdep.c (linux_find_memory_regions): Try to reads smaps file
	first.  New variables modified and has_anonymous.  Parse the lines of
	smaps file.  Add the passed MODIFIED value to FUNC.
	* procfs.c (find_memory_regions_callback): Add the passed modified
	value.

gdb/testsuite/
	PR 11804
	* gdb.base/gcore-relro.exp: New file.
	* gdb.base/gcore-relro-main.c: New file.
	* gdb.base/gcore-relro-lib.c: New file.
@
text
@d48 1
@


1.159
log
@	* cli/cli-dump.c (bfd_openr_with_cleanup): Use gdb_bfd_openr.
	(bfd_openw_with_cleanup): Use gdb_bfd_openw.
	* corelow.c (core_open): Use gdb_bfd_fopen.
	* dsrec.c (load_srec): Use gdb_bfd_openr.
	* exec.c (exec_file_attach): Use gdb_bfd_fopen.
	* gcore.c (gcore_memory_sections): Use gdb_bfd_openw.
	* gdb_bfd.c (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): New functions.
	* gdb_bfd.h (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): Declare.
	* jit.c (bfd_open_from_target_memory): Use gdb_bfd_openr_iovec.
	* m32-rom.c (m32r_load, m32r_upload_command): Use gdb_bfd_openr.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_openr,
	gdb_bfd_openr_next_archived_file.
	(macho_check_dsym): Use gdb_bfd_openr.
	(macho_add_oso_symfile): Don't call gdb_bfd_stash_filename.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_fdopenr.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_openr.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Use
	gdb_bfd_openr.
	* remote.c (remote_bfd_open): Use gdb_bfd_openr_iovec.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_openr, gdb_bfd_fdopenr,
	gdb_bfd_openr_next_archived_file.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_openr.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_openr.
	* solib-spu.c (spu_bfd_fopen): Use gdb_bfd_openr_iovec.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_fopen.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_openr_iovec.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_openr.
	(symfile_bfd_open): Use gdb_bfd_fopen.
	(generic_load): Use gdb_bfd_openr.
	* windows-nat.c (windows_make_so): Use gdb_bfd_openr.
@
text
@d5077 1
@


1.158
log
@	* bfd-target.c (target_bfd_reopen): Update.
	* cli/cli-dump.c (bfd_openr_with_cleanup)
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* exec.c (exec_file_attach): Update.
	* gcore.c (create_gcore_bfd): Update.
	* gdb_bfd.c (gdb_bfd_ref): Return void.
	(gdb_bfd_open): Update.
	* gdb_bfd.h (gdb_bfd_ref): Return void.
	Update comments.
	* jit.c (jit_bfd_try_read_symtab): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* machoread.c (macho_symfile_read_all_oso): Update.
	(macho_check_dsym): Update.
	* procfs.c (insert_dbx_link_bpt_in_file): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Update.
	* rs6000-nat.c (add_vmap): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-spu.c (spu_bfd_open): Update.
	* solib.c (solib_bfd_fopen, solib_read_symbols): Update.
	* spu-linux-nat.c (spu_bfd_open): Update.
	* symfile.c (bfd_open_maybe_remote, symfile_bfd_open)
	(generic_load): Update.
	* windows-nat.c (windows_make_so): Update.
@
text
@d3489 1
a3489 2
  abfd = bfd_fdopenr ("unamed", 0, fd);
  gdb_bfd_ref (abfd);
@


1.157
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d3489 2
a3490 1
  abfd = gdb_bfd_ref (bfd_fdopenr ("unamed", 0, fd));
@


1.156
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d3489 1
a3489 1
  abfd = bfd_fdopenr ("unamed", 0, fd);
d3500 1
a3500 1
      bfd_close (abfd);
d3514 1
a3514 1
	  bfd_close (abfd);
d3517 1
a3517 1
      bfd_close (abfd);
d3521 1
a3521 1
  bfd_close (abfd);
@


1.155
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d3789 1
a3789 1
			target_resume (ptid, 0, TARGET_SIGNAL_0);
d3815 1
a3815 1
		    target_resume (ptid, 0, TARGET_SIGNAL_0);
d4214 1
a4214 1
      (signo == TARGET_SIGNAL_STOP && pi->ignore_next_sigstop))
d5488 1
a5488 1
  if (info->suspend.stop_signal != TARGET_SIGNAL_0
d5504 1
a5504 1
    return TARGET_SIGNAL_0;
@


1.154
log
@procfs.c: Remove unused functions and make many functions static

gdb/ChangeLog:

        * procfs.c (procfs_find_new_threads, procfs_pid_to_str,
        proc_warn, proc_error, proc_get_status, proc_flags,
        proc_why, proc_what, proc_nsysarg, proc_sysargs,
        proc_set_run_on_last_close, proc_unset_run_on_last_close,
        proc_unset_inherit_on_fork, proc_set_async, proc_unset_async,
        proc_stop_process, proc_wait_for_stop, proc_run_process,
        proc_set_traced_signals, proc_set_traced_faults,
        proc_set_traced_sysentry, proc_set_traced_sysexit,
        proc_set_held_signals, proc_get_held_signals,
        proc_get_traced_signals, proc_get_traced_faults,
        proc_get_traced_sysentry, proc_get_traced_sysexit,
        proc_clear_current_fault, proc_set_current_signal,
        proc_clear_current_signal, proc_get_gregs, proc_get_fpregs,
        proc_set_gregs, proc_set_fpregs, proc_kill, proc_parent_pid,
        proc_get_nthreads, proc_get_nthreads, proc_get_nthreads,
        proc_get_current_thread, proc_get_current_thread,
        proc_get_current_thread, proc_update_threads,
        proc_update_threads, proc_update_threads, proc_update_threads,
        proc_iterate_over_threads, procfs_find_new_threads,
        procfs_pid_to_str): Make static.  Remove advance declaration.
        (proc_cursig): Make static.  Conditionalized defintion on
        PROCFS_DONT_PIOCSSIG_CURSIG being defined.
        (proc_syscall, proc_set_kill_on_last_close,
        proc_unset_kill_on_last_close, proc_set_inherit_on_fork,
        proc_get_pending_signals, proc_get_signal_actions,
        proc_trace_signal, proc_ignore_signal): Delete.
@
text
@d115 1
a115 1
			   ptid_t, int, enum target_signal);
d2125 1
a2125 1
      && wait_status.value.sig == target_signal_from_host (signo)
d4185 1
a4185 1
	       ptid_t ptid, int step, enum target_signal signo)
d4217 1
a4217 1
    native_signo = target_signal_to_host (signo);
d4276 1
a4276 1
      int target_signo = target_signal_from_host (signo);
d5414 1
a5414 1
			    enum target_signal stop_signal)
d5465 1
a5465 1
  enum target_signal stop_signal;
d5495 1
a5495 1
static enum target_signal
d5521 1
a5521 1
  enum target_signal stop_signal;
@


1.153
log
@	* proc-utils.h (proc_prettyprint_signalset): New prototype.
	(proc_prettyprint_signal): Likewise.
	(proc_prettyprint_faultset): Likewise.
	(proc_prettyprint_fault): Likewise.
	(proc_prettyprint_actionset): Likewise.
	(proc_prettyprint_flags): Move to new proc-flags.c section.
	(proc_prettyfprint_flags): New prototype.
	* procfs.c (proc_nsysarg, proc_sysargs): Add prototypes.
	(proc_syscall, proc_cursig): Likewise.
	(proc_set_kill_on_last_close): Likewise.
	(proc_unset_kill_on_last_close): Likewise.
	(proc_set_watchpoint): Make static.
	(proc_delete_dead_threads): Likewise.
	(procfs_set_watchpoint): Likewise.
	(_initialize_procfs): Add prototype.
	* proc-events.c: Include proc-utils.h.
	(init_syscall_table): Make static.
	* proc-api.c (_initialize_proc_api): Add prototype.
	* proc-flags.c: Include proc-utils.h.
@
text
@d141 2
a142 2
void procfs_find_new_threads (struct target_ops *ops);
char *procfs_pid_to_str (struct target_ops *, ptid_t);
d1022 9
a1030 51
int proc_get_status (procinfo * pi);
long proc_flags (procinfo * pi);
int proc_why (procinfo * pi);
int proc_what (procinfo * pi);
int proc_nsysarg (procinfo * pi);
long *proc_sysargs (procinfo * pi);
int proc_syscall (procinfo * pi);
long proc_cursig (struct procinfo * pi);
int proc_set_run_on_last_close (procinfo * pi);
int proc_unset_run_on_last_close (procinfo * pi);
int proc_set_kill_on_last_close (procinfo * pi);
int proc_unset_kill_on_last_close (procinfo * pi);
int proc_set_inherit_on_fork (procinfo * pi);
int proc_unset_inherit_on_fork (procinfo * pi);
int proc_set_async (procinfo * pi);
int proc_unset_async (procinfo * pi);
int proc_stop_process (procinfo * pi);
int proc_trace_signal (procinfo * pi, int signo);
int proc_ignore_signal (procinfo * pi, int signo);
int proc_clear_current_fault (procinfo * pi);
int proc_set_current_signal (procinfo * pi, int signo);
int proc_clear_current_signal (procinfo * pi);
int proc_set_gregs (procinfo * pi);
int proc_set_fpregs (procinfo * pi);
int proc_wait_for_stop (procinfo * pi);
int proc_run_process (procinfo * pi, int step, int signo);
int proc_kill (procinfo * pi, int signo);
int proc_parent_pid (procinfo * pi);
int proc_get_nthreads (procinfo * pi);
int proc_get_current_thread (procinfo * pi);
int proc_set_held_signals (procinfo * pi, gdb_sigset_t * sighold);
int proc_set_traced_sysexit (procinfo * pi, sysset_t * sysset);
int proc_set_traced_sysentry (procinfo * pi, sysset_t * sysset);
int proc_set_traced_faults (procinfo * pi, fltset_t * fltset);
int proc_set_traced_signals (procinfo * pi, gdb_sigset_t * sigset);

int proc_update_threads (procinfo * pi);
int proc_iterate_over_threads (procinfo * pi,
			       int (*func) (procinfo *, procinfo *, void *),
			       void *ptr);

gdb_gregset_t *proc_get_gregs (procinfo * pi);
gdb_fpregset_t *proc_get_fpregs (procinfo * pi);
sysset_t *proc_get_traced_sysexit (procinfo * pi, sysset_t * save);
sysset_t *proc_get_traced_sysentry (procinfo * pi, sysset_t * save);
fltset_t *proc_get_traced_faults (procinfo * pi, fltset_t * save);
gdb_sigset_t *proc_get_traced_signals (procinfo * pi, gdb_sigset_t * save);
gdb_sigset_t *proc_get_held_signals (procinfo * pi, gdb_sigset_t * save);
gdb_sigset_t *proc_get_pending_signals (procinfo * pi, gdb_sigset_t * save);
gdb_sigaction_t *proc_get_signal_actions (procinfo * pi,
					  gdb_sigaction_t *save);
d1032 1
a1032 4
void proc_warn (procinfo * pi, char *func, int line);
void proc_error (procinfo * pi, char *func, int line);

void
d1039 1
a1039 1
void
d1052 1
a1052 1
int
d1146 1
a1146 1
long
d1169 1
a1169 1
int
d1185 1
a1185 1
int
d1228 1
a1228 1
int
d1245 1
a1245 1
long *
a1257 17

/* Returns the pr_syscall field (id of current syscall if we are in
   one).  */

int
proc_syscall (procinfo *pi)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;

#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_syscall;
#else
  return pi->prstatus.pr_syscall;
#endif
}
d1260 1
d1263 1
a1263 1
long
d1276 1
d1411 1
a1411 1
int
d1421 1
a1421 1
int
a1426 33
#ifdef PR_KLC
/* Set the kill_on_last_close flag.  Process with all threads will be
   killed when debugger closes all /proc fds (or debugger exits or
   dies).  Returns non-zero for success, zero for failure.  */

int
proc_set_kill_on_last_close (procinfo *pi)
{
  return proc_modify_flag (pi, PR_KLC, FLAG_SET);
}

/* Reset the kill_on_last_close flag.  Process will NOT be killed when
   debugger closes its file handles (or exits or dies).  Returns
   non-zero for success, zero for failure.  */

int
proc_unset_kill_on_last_close (procinfo *pi)
{
  return proc_modify_flag (pi, PR_KLC, FLAG_RESET);
}
#endif /* PR_KLC */

/* Set inherit_on_fork flag.  If the process forks a child while we
   are registered for events in the parent, then we will also recieve
   events from the child.  Returns non-zero for success, zero for
   failure.  */

int
proc_set_inherit_on_fork (procinfo *pi)
{
  return proc_modify_flag (pi, PR_FORK, FLAG_SET);
}

d1432 1
a1432 1
int
d1443 1
a1443 1
int
d1453 1
a1453 1
int
d1463 1
a1463 1
int
d1500 1
a1500 1
int
d1556 1
a1556 1
int
d1603 1
a1603 1
int
d1643 1
a1643 1
int
d1681 1
a1681 1
int
d1726 1
a1726 1
int
d1771 1
a1771 1
int
a1805 62
/* Returns the set of signals that are pending in the process or LWP.
   Will also copy the sigset if SAVE is non-zero.  */

gdb_sigset_t *
proc_get_pending_signals (procinfo *pi, gdb_sigset_t *save)
{
  gdb_sigset_t *ret = NULL;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

#ifdef NEW_PROC_API
  ret = &pi->prstatus.pr_lwp.pr_lwppend;
#else
  ret = &pi->prstatus.pr_sigpend;
#endif
  if (save && ret)
    memcpy (save, ret, sizeof (gdb_sigset_t));

  return ret;
}

/* Returns the set of signal actions.  Will also copy the sigactionset
   if SAVE is non-zero.  */

gdb_sigaction_t *
proc_get_signal_actions (procinfo *pi, gdb_sigaction_t *save)
{
  gdb_sigaction_t *ret = NULL;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

#ifdef NEW_PROC_API
  ret = &pi->prstatus.pr_lwp.pr_action;
#else
  ret = &pi->prstatus.pr_action;
#endif
  if (save && ret)
    memcpy (save, ret, sizeof (gdb_sigaction_t));

  return ret;
}

d1809 1
a1809 1
gdb_sigset_t *
d1849 1
a1849 1
gdb_sigset_t *
a1881 56
/* Add SIGNO to the set of signals that are traced.  Returns non-zero
   for success, zero for failure.  */

int
proc_trace_signal (procinfo *pi, int signo)
{
  gdb_sigset_t temp;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  if (pi)
    {
      if (proc_get_traced_signals (pi, &temp))
	{
	  gdb_praddset (&temp, signo);
	  return proc_set_traced_signals (pi, &temp);
	}
    }

  return 0;	/* failure */
}

/* Remove SIGNO from the set of signals that are traced.  Returns
   non-zero for success, zero for failure.  */

int
proc_ignore_signal (procinfo *pi, int signo)
{
  gdb_sigset_t temp;

  /* We should never have to apply this operation to any procinfo
     except the one for the main process.  If that ever changes for
     any reason, then take out the following clause and replace it
     with one that makes sure the ctl_fd is open.  */

  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  if (pi)
    {
      if (proc_get_traced_signals (pi, &temp))
	{
	  gdb_prdelset (&temp, signo);
	  return proc_set_traced_signals (pi, &temp);
	}
    }

  return 0;	/* failure */
}

d1885 1
a1885 1
fltset_t *
d1921 1
a1921 1
sysset_t *
d1988 1
a1988 1
sysset_t *
d2056 1
a2056 1
int
d2090 1
a2090 1
int
d2163 1
a2163 1
int
d2206 1
a2206 1
gdb_gregset_t *
d2230 1
a2230 1
gdb_fpregset_t *
d2303 1
a2303 1
int
d2343 1
a2343 1
int
d2401 1
a2401 1
int
d2435 1
a2435 1
int
d2641 1
a2641 1
int
d2655 1
a2655 1
int
d2673 1
a2673 1
int
d2690 1
a2690 1
int
d2715 1
a2715 1
int
d2727 1
a2727 1
int
d2755 1
a2755 1
int
d2804 1
a2804 1
int
d2852 1
a2852 1
int
d2888 1
a2888 1
int
d2910 1
a2910 1
int
d4760 1
a4760 1
void
d4802 1
a4802 1
char *
@


1.152
log
@avoid a few strncpy-induced buffer overruns

* procfs.c (procfs_make_note_section): Be sure to NUL-terminate
fname and psargs before trying to concatenate.
* tui/tui-stack.c (tui_get_function_from_frame): NUL-terminate
"name" before applying strchr.
@
text
@d1026 4
d1032 2
d2682 1
a2682 1
int
d2952 1
a2952 1
int
d5028 1
a5028 1
int
d5582 3
@


1.151
log
@struct siginfo vs. siginfo_t

gdb/
	* amd64-linux-nat.c (amd64_linux_siginfo_fixup): Use siginfo_t instead
	of struct siginfo.
	* arm-linux-nat.c (arm_linux_stopped_data_address): Likewise.
	* ia64-linux-nat.c (ia64_linux_stopped_data_address): Likewise.
	* linux-nat.c (linux_nat_siginfo_fixup, siginfo_fixup)
	(linux_xfer_siginfo, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-nat.h (struct lwp_info, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Likewise.
	* procfs.c (gdb_siginfo_t): Likewise.

gdbserver/
	* linux-arm-low.c (arm_stopped_by_watchpoint): Use siginfo_t instead of
	struct siginfo.
	* linux-low.c (siginfo_fixup, linux_xfer_siginfo): Likewise.
	* linux-x86-low.c (x86_siginfo_fixup): Likewise.
	* linux-low.h: Include <signal.h>.
	(struct siginfo): Remove forward declaration.
	(struct linux_target_ops) <siginfo_fixup>: Use siginfo_t instead of
	struct siginfo.
@
text
@d5728 3
a5730 2
      strncpy (psargs, get_exec_file (0),
	       sizeof (psargs));
@


1.150
log
@ChangeLog:

	* defs.h (enum info_proc_what): Moved here from linux-nat.c
	* infcmd.c: (info_proc_cmd_1): New function.
	(info_proc_cmd): New function, moved here from equivalent routine
	orignally in linux-nat.c.
	(info_proc_cmd_mappings): Likewise.
	(info_proc_cmd_stat): Likewise.
	(info_proc_cmd_status): Likewise.
	(info_proc_cmd_cwd): Likewise.
	(info_proc_cmd_cmdline): Likewise.
	(info_proc_cmd_exe): Likewise.
	(info_proc_cmd_all): Likewise.
	(_initialize_infcmd): Install "info proc" command and subcommands.

	* target.h (struct target_ops): Add to_info_proc.
	(target_info_proc): Add prototype.
	* target.c (target_info_proc): New function.

	* procfs.c (procfs_info_proc): Add prototype.
	(info_proc_cmd): Rename into ...
	(procfs_info_proc): ... this.  Update argument types as appropriate
	for a to_info_proc implementation.  Handle "what" argument.
	(procfs_target): Install procfs_info_proc.
	(_initialize_procfs): No longer install "info proc" command.

	* linux-nat.c: (enum info_proc_what): Remove.
	(linux_nat_info_proc_cmd_1): Rename into ...
	(linux_nat_info_proc): ... this.  Update argument types as appropriate
	for a to_info_proc implementation.
	(linux_nat_info_proc_cmd): Remove.
	(linux_nat_info_proc_cmd_mappings): Likewise.
	(linux_nat_info_proc_cmd_stat): Likewise.
	(linux_nat_info_proc_cmd_status): Likewise.
	(linux_nat_info_proc_cmd_cwd): Likewise.
	(linux_nat_info_proc_cmd_cmdline): Likewise.
	(linux_nat_info_proc_cmd_exe): Likewise.
	(linux_nat_info_proc_cmd_all): Likewise.
	(linux_target_install_ops): Install linux_nat_info_proc.
	(_initialize_linux_nat): No longer install "info proc" command
	and subcommands.

testsuite/ChangeLog:

	* gdb.base/info-proc.exp: Also run on remote targets.  Main
	"info proc" command is now always present; whether target supports
	actual info proc operation is detected when attempting to issue
	the command.
@
text
@d269 1
a269 1
typedef struct siginfo gdb_siginfo_t;
@


1.149
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d154 3
d217 1
d5397 2
a5398 1
info_proc_cmd (char *args, int from_tty)
d5409 14
a5440 8
      else if (strncmp (argv[0], "mappings", strlen (argv[0])) == 0)
	{
	  mappings = 1;
	}
      else
	{
	  /* [...] */
	}
a5580 4
  add_info ("proc", info_proc_cmd, _("\
Show /proc process information about any running process.\n\
Specify process id, or use the program being debugged by default.\n\
Specify keyword 'mappings' for detailed info on memory mappings."));
@


1.148
log
@procfs file descriptor leaks

gdb/ChangeLog (from Tom Tromey):

	* procfs.c (load_syscalls): Make a cleanup.
	(open_procinfo_files): fd==0 is ok.
@
text
@d3 1
a3 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.148.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1999-2003, 2006-2012 Free Software Foundation, Inc.
@


1.147
log
@[procfs] /proc/.../map file descriptor leak

When opening the procfs map file, we create a cleanup routine to make
sure that the associated file descriptor gets closed, but we never
call the cleanup. So the FD gets leaked.

gdb/ChangeLog:

        * procfs.c (iterate_over_mappings): Call do_cleanups before
        returning.
@
text
@d608 1
a608 1
    if (fd <= 0)
d617 1
a617 1
    if (fd <= 0)
d627 1
a627 1
    if (fd <= 0)
d649 1
a649 1
  if ((fd = open_with_retry (pi->pathname, O_RDWR)) == 0)
d655 1
a655 1
      if (fd <= 0)
d669 1
a669 1
      if ((fd = ioctl (process->ctl_fd, PIOCOPENLWP, &lwpid)) <= 0)
d881 1
d893 1
d909 1
d912 1
a912 4
    {
      xfree (syscalls);
      error (_("load_syscalls: Error reading /proc/%d/sysent"), pi->pid);
    }
d966 1
a966 2
  close (sysent_fd);
  xfree (syscalls);
@


1.146
log
@2011-09-22  Tristan Gingold  <gingold@@adacore.com>

	* fork-child.c (fork_inferior): Add exec_fun parameter.
	Call exec_fun or execvp.
	* inferior.h: Adjust prototype.
	* gnu-nat.c (gnu_create_inferior): Adjust fork_inferior call.
	* inf-ttrace.c (inf_ttrace_create_inferior): Ditto.
	* inf-ptrace.c (inf_ptrace_create_inferior): Ditto.
	* procfs.c (procfs_create_inferior): Ditto.
	* darwin-nat.c (darwin_execvp): New function.
	(darwin_create_inferior): Use it.
@
text
@d5220 1
d5258 4
a5261 1
      return funcstat;
d5263 1
@


1.145
log
@fix procfs.c:procfs_pass_signals advance declaration

gdb/ChangeLog:

	* procfs.c (procfs_pass_signals): Fix advance declaration.
@
text
@d4918 1
a4918 1
		       NULL, NULL, shell_file);
@


1.144
log
@	* target.h (struct target_ops): Remove to_notice_signals;
	add to_pass_signals.
	(target_notice_signals): Remove.
	(target_pass_signals): Add prototype.
	* target.c (update_current_target): Remove to_notice_signals;
	mention to_pass_signals.
	(target_pass_signals): New function.
	(debug_to_notice_signals): Remove.
	(setup_target_debug): Do not install debug_to_notice_signals.

	* infrun.c (signal_pass): New global.
	(resume): Call target_pass_signals.
	(handle_inferior_event): Report all signals while stepping over
	non-steppable watchpoint.  Reset trap_expected to ensure breakpoints
	are re-inserted when stepping over a signal handler.
	(signal_cache_update): New function.
	(signal_stop_update): Call it.
	(signal_print_update): Likewise.
	(signal_pass_update): Likewise.
	(handle_command): Call signal_cache_update and target_pass_signals
	instead of target_notice_signals.
	(_initialize_infrun): Initialize signal_pass.

	* linux-nat.c (pass_mask): New global.
	(linux_nat_pass_signals): New function.
	(linux_nat_create_inferior): Report all signals initially.
	(linux_nat_attach): Likewise.
	(linux_nat_resume): Use pass_mask to decide whether to directly
	handle an inferior signal.
	(linux_nat_wait_1): Likewise.
	(linux_nat_add_target): Install to_pass_signals callback.

	* nto-procfs.c (notice_signals): Remove.
	(procfs_resume): Do not call notice_signals.
	(procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(init_procfs_ops): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(_initialize_procfs): Report all signals initially.

	* procfs.c (procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(procfs_target): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(register_gdb_signals): Remove.
	(procfs_debug_inferior): Report all signals initially.
	(procfs_init_inferior): Remove redundant register_gdb_signals call.

	* remote.c (remote_pass_signals): Add numsigs and pass_signals
	parameters; use them instead of calling signal_..._state routines.
	(remote_notice_signals): Remove.
	(remote_start_remote): Report all signals initially.
	(remote_resume): Do not call remote_pass_signals.
	(_initialize_remote): Install to_pass_signals callback instead of
	to_notice_signals callback.
@
text
@d123 1
a123 1
static void procfs_pass_signals (ptid_t, int, unsigned char *);
@


1.143
log
@	* cli/cli-cmds.c (shell_escape): Use lbasename.
	* coffread.c (coff_start_symtab): Constify parameter.
	(complete_symtab): Constify `name' parameter.
	(coff_symtab_read): Constify `filestring' local.
	(coff_getfilename): Constify return and `result' local.
	Use lbasename.
	* fbsd-nat.c (fbsd_make_corefile_notes): Use lbasename.
	* linux-fork.c (info_checkpoints_command): Use lbasename.
	* linux-nat.c (linux_nat_make_corefile_notes): Use lbasename.
	* minsyms.c (lookup_minimal_symbol): Use lbasename.
	* nto-tdep.c (nto_find_and_open_solib): Use lbasename.
	* procfs.c (procfs_make_note_section): Use lbasename.
	* tui/tui-io.c (printable_part): Constity return and parameter.
	Use lbasename.
	(print_filename): Constify parameters, and local `s'.
	(tui_rl_display_match_list): Constify local `temp'.
@
text
@d123 1
a123 1
static void procfs_notice_signals (ptid_t);
d204 1
a204 1
  t->to_notice_signals = procfs_notice_signals;
a3149 1
static int register_gdb_signals (procinfo *, gdb_sigset_t *);
d3188 3
a3190 3
  /* Register to trace selected signals in the child.  */
  premptyset (&traced_signals);
  if (!register_gdb_signals (pi, &traced_signals))
d4466 1
a4466 4
/* Traverse the list of signals that GDB knows about (see "handle"
   command), and arrange for the target to be stopped or not,
   according to these settings.  Returns non-zero for success, zero
   for failure.  */
d4468 2
a4469 2
static int
register_gdb_signals (procinfo *pi, gdb_sigset_t *signals)
d4471 2
d4475 1
a4475 7
  for (signo = 0; signo < NSIG; signo ++)
    if (signal_stop_state  (target_signal_from_host (signo)) == 0 &&
	signal_print_state (target_signal_from_host (signo)) == 0 &&
	signal_pass_state  (target_signal_from_host (signo)) == 1)
      gdb_prdelset (signals, signo);
    else
      gdb_praddset (signals, signo);
d4477 6
a4482 2
  return proc_set_traced_signals (pi, signals);
}
d4484 2
a4485 13
/* Set up to trace signals in the child process.  */

static void
procfs_notice_signals (ptid_t ptid)
{
  gdb_sigset_t signals;
  procinfo *pi = find_procinfo_or_die (PIDGET (ptid), 0);

  if (proc_get_traced_signals (pi, &signals) &&
      register_gdb_signals    (pi, &signals))
    return;
  else
    proc_error (pi, "notice_signals", __LINE__);
a4666 5
  /* Register to trace selected signals in the child.  */
  prfillset (&signals);
  if (!register_gdb_signals (pi, &signals))
    proc_error (pi, "init_inferior, register_signals", __LINE__);

@


1.142
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d5737 1
a5737 1
      strncpy (fname, strrchr (get_exec_file (0), '/') + 1, sizeof (fname));
@


1.141
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d4646 1
a4646 1
    perror ("procfs: out of memory in 'init_inferior'");
@


1.140
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d35 1
a35 1
#define _STRUCTURED_PROC 1	/* Should be done by configure script. */
d341 1
a341 1
   inferior's procinfo information. */
d366 1
a366 1
/* the name of the proc status struct depends on the implementation */
d592 1
a592 2
	 thread, getting a new handle for the same 'file'.
   */
d601 1
a601 1
  switch (which) {	/* which file descriptor to open? */
d614 1
a614 1
      return 0;		/* there is no 'as' file descriptor for an lwp */
d648 1
a648 1
  /* Only one FD; just open it. */
d651 1
a651 1
#else			/* Sol 2.5, Irix, other? */
d664 1
a664 1
      /* Find the procinfo for the entire process. */
d668 1
a668 1
      /* Now obtain the file descriptor for the LWP. */
d671 2
a672 2
#else			/* Irix, other? */
      return 0;		/* Don't know how to open threads */
d692 1
a692 1
    return pi;			/* Already exists, nothing to do. */
d694 1
a694 1
  /* find parent before doing malloc, to save having to cleanup */
d698 1
a698 1
						   doesn't exist yet? */
d783 1
a783 1
  if (pi->tid != 0)	/* destroy a thread procinfo */
d785 1
a785 1
      tmp = find_procinfo (pi->pid, 0);	/* find the parent process */
d788 1
a788 1
  else			/* destroy a process procinfo and all its threads */
d868 1
a868 1
   names for these numbers will be left as NULL.) */
d917 1
a917 1
     call numbers may be skipped.) */
d955 1
a955 1
	  /* FIXME: Generate warning */
d1092 1
a1092 1
  /* Status file descriptor is opened "lazily" */
d1106 1
a1106 1
	 depending on whether this is a main process or an LWP. */
d1122 1
a1122 1
	    /* Unixware peculiarity -- read the damn thing again! */
d1134 1
a1134 1
      /* Just read the danged status.  Now isn't that simple? */
d1188 1
a1188 1
      return 0;	/* FIXME: not a good failure value (but what is?) */
d1211 1
a1211 1
      return 0;	/* FIXME: not a good failure value (but what is?) */
d1227 1
a1227 1
      return 0;	/* FIXME: not a good failure value (but what is?) */
d1321 1
a1321 1
      return 0;	/* FIXME: not a good failure value (but what is?) */
d1375 1
a1375 1
#ifdef NEW_PROC_API	/* Newest method: UnixWare and newer Solarii */
d1389 1
a1389 1
    if (mode == FLAG_SET)	/* Set the flag (RLC, FORK, or ASYNC) */
d1391 1
a1391 1
    else			/* Reset the flag */
d1399 1
a1399 1
  if (mode == FLAG_SET)	/* Set the flag (hopefully RLC, FORK, or ASYNC) */
d1403 1
a1403 1
  else			/* Reset the flag */
d1432 1
a1432 1
    win = 0;		/* fail -- unknown flag (can't do PR_ASYNC) */
d1656 1
a1656 1
  runflags    = PRCFAULT;	/* always clear current fault  */
d1661 1
a1661 1
  else if (signo != -1)		/* -1 means do nothing W.R.T. signals */
d1717 1
a1717 1
  /* The above operation renders the procinfo's cached pstatus obsolete. */
d1757 1
a1757 1
  /* The above operation renders the procinfo's cached pstatus obsolete. */
d2321 1
a2321 1
    return 1;           /* I assume this is a success? */
d2627 1
a2627 1
	 procfs.c/unconditionally_kill_inferior?  Perhaps only for SIGKILL? */
d2683 2
a2684 2
/* Horrible hack!  Detect Solaris 2.5, because this doesn't work on 2.5 */
#if defined (PIOCOPENLWP) || defined (UNIXWARE)	/* Solaris 2.5: bail out */
d2747 1
a2747 1
  /* Make sure it gets closed again! */
d2758 1
a2758 1
      /* If key matches, return this entry. */
d2762 1
a2762 1
  /* Loop ended, match not found. */
d2775 2
a2776 2
  /* Allocate space for the number of LDT entries. */
  /* This alloc has to persist, 'cause we return a pointer to it. */
d2791 1
a2791 1
  /* Search the table and return the (first) entry matching 'key'. */
d2796 1
a2796 1
  /* Loop ended, match not found. */
d2810 1
a2810 1
  /* Find procinfo for the lwp. */
d2817 1
a2817 1
  /* get its general registers. */
d2824 1
a2824 1
  /* Now extract the GS register's lower 16 bits. */
d2827 1
a2827 1
  /* Find the matching entry and return it. */
d2868 1
a2868 1
  if (pi->tid != 0)	/* find the parent process procinfo */
d2921 1
a2921 1
#if 0	/* FIXME: not ready for prime time? */
d3000 1
a3000 1
/* Unixware and Solaris 6 (and later) version */
d3073 1
a3073 1
    return 0;		/* nothing to do for 1 or fewer threads */
d3131 1
a3131 1
      next = thread->next;	/* in case thread is destroyed */
d3179 2
a3180 2
     Wonder why we don't just do that in general? */
  premptyset (&traced_faults);		/* don't trace faults. */
d3182 2
a3183 2
  /* Register to trace hardware faults in the child. */
  prfillset (&traced_faults);		/* trace all faults... */
d3189 1
a3189 1
  /* Register to trace selected signals in the child. */
d3202 1
a3202 1
  gdb_praddsysset (traced_syscall_entries, SYS_lwpexit);	/* And _lwp_exit... */
d3225 1
a3225 1
  /* FIXME: make nice and maybe move into an access function. */
d3238 1
a3238 1
  /* Everyone else's (except OSF) method for tracing exec syscalls */
d3242 1
a3242 1
     *is* a SYS_execv.  So, we try to account for that. */
d3261 1
a3261 1
#ifdef SYS_lwp_create	/* FIXME: once only, please */
d3376 1
a3376 1
      /* Now stop the process. */
d3419 1
a3419 1
  /* Find procinfo for the main process */
d3683 1
a3683 1
   named __dbx_link(). If found, then insert a breakpoint at this location,
d3814 1
a3814 1
  /* First cut: loosely based on original version 2.1 */
d3828 1
a3828 1
  /* Find procinfo for main process */
d3832 1
a3832 1
      /* We must assume that the status is stale now... */
d3837 1
a3837 1
#if 0	/* just try this out... */
d3841 1
a3841 1
	pi->status_valid = 0;	/* re-read again, IMMEDIATELY... */
d3847 1
a3847 1
	  /* wait_for_stop failed: has the child terminated? */
d3852 2
a3853 2
	      /* /proc file not found; presumably child has terminated. */
	      wait_retval = wait (&wstat); /* "wait" for the child's exit  */
d3855 1
a3855 1
	      if (wait_retval != PIDGET (inferior_ptid)) /* wrong child? */
d3860 1
a3860 1
		 Or try find_procinfo to see if I know about this child? */
d3867 1
a3867 1
	      /* Unknown error from wait_for_stop. */
d3922 1
a3922 1
		    /* Handle SYS_exit call only */
d3956 2
a3957 1
			/* If wait returns -1, that's what we return to GDB. */
d3985 2
a3986 1
			/* How to exit gracefully, returning "unknown event" */
d4004 1
a4004 1
		       address. */
d4043 1
a4043 1
		    /* Return to WFI, but tell it to immediately resume. */
d4132 1
a4132 1
		  /* FIXME: use si_signo where possible. */
d4134 1
a4134 1
#if (FLTILL != FLTPRIV)		/* avoid "duplicate case" error */
d4140 1
a4140 1
#if (FLTTRACE != FLTBPT)	/* avoid "duplicate case" error */
d4155 1
a4155 1
#if (FLTBOUNDS != FLTSTACK)	/* avoid "duplicate case" error */
d4162 1
a4162 1
#if (FLTFPE != FLTIOVF)		/* avoid "duplicate case" error */
d4168 2
a4169 1
		default:	/* FIXME: use si_signo if possible for fault */
d4199 1
a4199 1
	  else	/* flags do not indicate STOPPED */
d4201 1
a4201 1
	      /* surely this can't happen... */
d4258 1
a4258 1
   negative values, but this capability isn't implemented here.) */
d4267 1
a4267 1
  /* Find procinfo for main process */
d4410 1
a4410 1
  /* Find procinfo for main process */
d4451 2
a4452 1
	      pi = thread;	/* substitute the thread's procinfo for run */
d4537 1
a4537 1
  /* FIXME: use access functions */
d4561 1
a4561 1
    /* FIXME: use proc_set_current_signal */
d4593 1
a4593 1
      /* Find procinfo for main process */
d4611 1
a4611 1
      /* Find procinfo for main process */
d4670 1
a4670 1
     We're it's parent, for Ghu's sake! */
d4726 1
a4726 1
     the -init code is executed. Unfortuantely, this is not straightforward,
d4833 1
a4833 1
  /* FIXME: should this be done in the parent instead? */
d4846 1
a4846 1
     we have our own address space, and we're about to do an exec! */
d4988 1
a4988 1
  /* Find procinfo for main process */
d5006 1
a5006 1
  /* If I don't know it, it ain't alive! */
d5052 2
a5053 2
  /* Translate from GDB's flags to /proc's */
  if (len > 0)	/* len == 0 means delete watchpoint */
d5055 1
a5055 1
      switch (rwflag) {		/* FIXME: need an enum! */
d5068 1
a5068 1
      default:			/* Something weird.  Return error. */
d5071 1
a5071 1
      if (after)		/* Stop after r/w access is completed. */
d5077 1
a5077 1
      if (errno == E2BIG)	/* Typical error for no resources */
d5247 1
a5247 1
  /* Open map fd. */
d5252 1
a5252 1
  /* Make sure it gets closed again. */
d5385 1
a5385 1
    return;	/* No output for summary mode. */
d5456 1
a5456 1
	 First see if it's a process we're already debugging. */
d5501 1
a5501 1
   will be updated. Otherwise, the exit syscalls set will be updated.
d5503 1
a5503 1
   If MODE is FLAG_SET, then traces will be enabled. Otherwise, they
d5639 1
a5639 1
     gdbarch_regset_from_core_section() and regset->collect_regset(). */
@


1.139
log
@run copyright.sh for 2011.
@
text
@d136 2
a137 1
				    gdb_byte *readbuf, const gdb_byte *writebuf,
d490 2
a491 2
	error (_("\
procfs: couldn't find pid %d (kernel thread %d) in procinfo list."),
d902 2
a903 2
      error (_("\
load_syscalls: /proc/%d/sysent contains no syscalls!"), pi->pid);
d1064 2
a1065 1
gdb_sigaction_t *proc_get_signal_actions (procinfo * pi, gdb_sigaction_t *save);
d3857 2
a3858 1
		error (_("procfs: couldn't stop process %d: wait returned %d."),
d3974 2
a3975 1
			  printf_filtered (_("%ld syscall arguments:\n"), nsysargs);
d4166 2
a4167 2
		case FLTPAGE:		/* Recoverable page fault */
		default:	 /* FIXME: use si_signo if possible for fault */
d5768 2
a5769 1
  proc_iterate_over_threads (pi, procfs_corefile_thread_callback, &thread_args);
@


1.138
log
@gdb/
	Rename and move inferior_thread_state and inferior_status.
	* gdbthread.h (struct thread_control_state): New struct, move fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step and stop_bpstat here from struct thread_info.
	(struct thread_suspend_state): New struct, move field stop_signal here
	from struct thread_info.
	(struct thread_info): Move the fields above from this struct.
	* inferior.h: Move the inferior_thread_state and inferior_status
	declarations comment to their definitions at infrun.c.
	(struct inferior_control_state): New struct, move field stop_soon from
	struct inferior here.
	(struct inferior_suspend_state): New empty struct.
	(struct inferior): New fields control and suspend.  Move out field
	stop_soon.
	* infrun.c (struct inferior_thread_state): Rename to ...
	(infcall_suspend_state): ... here.  Replace field stop_signal by
	fields thread_suspend and inferior_suspend.
	(save_inferior_thread_state): Rename to ...
	(save_infcall_suspend_state): ... here.  New variable inf.  Update the
	code for new fields.
	(restore_inferior_thread_state): Rename to ...
	(restore_infcall_suspend_state): ... here.  New variable inf.  Update
	the code for new fields.
	(do_restore_inferior_thread_state_cleanup): Rename to ...
	(do_restore_infcall_suspend_state_cleanup): ... here.
	(make_cleanup_restore_inferior_thread_state): Rename to ...
	(make_cleanup_restore_infcall_suspend_state): ... here.
	(discard_inferior_thread_state): Rename to ...
	(discard_infcall_suspend_state): ... here.
	(get_inferior_thread_state_regcache): Rename to ...
	(get_infcall_suspend_state_regcache): ... here.
	(struct inferior_status): Rename to ...
	(struct infcall_control_state): ... here.  Replace fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step, stop_bpstat and stop_soon by fields thread_control and
	inferior_control.
	(save_inferior_status): Rename to ...
	(save_infcall_control_state): ... here.  Update the code for new
	fields.
	(restore_inferior_status): Rename to ...
	(restore_infcall_control_state): ... here.  Update the code for new
	fields.
	(do_restore_inferior_status_cleanup): Rename to ...
	(do_restore_infcall_control_state_cleanup): ... here.
	(make_cleanup_restore_inferior_status): Rename to ...
	(make_cleanup_restore_infcall_control_state): ... here.
	(discard_inferior_status): Rename to ...
	(discard_infcall_control_state): ... here.
	* alpha-tdep.c, breakpoint.c, dummy-frame.c, dummy-frame.h,
	exceptions.c, fbsd-nat.c, gdbthread.h, infcall.c, infcmd.c,
	inferior.c, inferior.h, infrun.c, linux-nat.c, mi/mi-interp.c,
	mips-tdep.c, procfs.c, solib-irix.c, solib-osf.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, thread.c, windows-nat.c: Update all the
	references to the moved fields and renamed functions.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.137
log
@gdb/
	Code cleanup.
	* defs.h (find_memory_region_ftype): New typedef.
	(exec_set_find_memory_regions): Use it.
	* exec.c (exec_set_find_memory_regions): Use find_memory_region_ftype.
	* fbsd-nat.c (fbsd_find_memory_regions): Likewise.
	* gcore.c (objfile_find_memory_regions): Likewise.
	* gnu-nat.c (gnu_find_memory_regions): Likewise.
	* linux-nat.c (linux_nat_find_memory_regions): Likewise.
	* procfs.c (iterate_over_mappings_cb_ftype): Remove.
	(iterate_over_mappings): Rename iterate_over_mappings_cb_ftype to
	find_memory_region_ftype.
	(insert_dbx_link_bpt_in_region): Likewise.
	(iterate_over_mappings): Likewise.  Drop the comment part about the
	function prototype.
	(find_memory_regions_callback): Use find_memory_region_ftype.
	(proc_find_memory_regions): Likewise.
	(info_mappings_callback): Rename iterate_over_mappings_cb_ftype to
	find_memory_region_ftype.
	* target.c (dummy_find_memory_regions): Use find_memory_region_ftype.
	* target.h (struct target_ops) <to_find_memory_regions>: Likewise.
@
text
@d5693 1
a5693 1
  if (info->stop_signal != TARGET_SIGNAL_0
d5707 1
a5707 1
    return info->stop_signal;
@


1.136
log
@2010-07-07  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Support for hw accelerated condition watchpoints in booke powerpc.

	* breakpoint.c (fetch_watchpoint_value): Rename to fetch_subexp_value
	and move to eval.c.  Change callers.
	(insert_bp_location): Pass watchpoint condition in
	target_insert_watchpoint.
	(remove_breakpoint_1) Pass watchpoint condition in
	target_remove_watchpoint.
	(watchpoint_locations_match): Call
	target_can_accel_watchpoint_condition.
	* eval.c: Include wrapper.h.
	(fetch_subexp_value): Moved from breakpoint.c.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint):
	Formatting fix.
	(can_use_watchpoint_cond_accel): New function.
	(calculate_dvc): Likewise.
	(num_memory_accesses): Likewise.
	(check_condition): Likewise.
	(ppc_linux_can_accel_watchpoint_condition): Likewise
	(ppc_linux_insert_watchpoint): Call can_use_watchpoint_cond_accel,
	check_condition and calculate_dvc.
	(ppc_linux_remove_watchpoint): Likewise.
	(_initialize_ppc_linux_nat): Set to_can_accel_watchpoint_condition to
	ppc_linux_can_accel_watchpoint_condition
	* target.c (debug_to_insert_watchpoint): Add argument for watchpoint
	condition.
	(debug_to_remove_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): New function.
	(update_current_target): Set to_can_accel_watchpoint_condition.
	(setup_target_debug): Set to_can_accel_watchpoint_condition.
	* target.h: Add opaque declaration for struct expression.
	(struct target_ops) <to_insert_watchpoint>,
	<to_remove_watchpoint>: Add new arguments to pass the watchpoint
	<to_can_accel_watchpoint_condition>: New member.
	condition.  Update all callers and implementations.
	(target_can_accel_watchpoint_condition): New macro.
	* value.c (free_value_chain): New function.
	* value.h (fetch_subexp_value): New prototype.
	(free_value_chain): Likewise.
@
text
@a440 5
/* A function type used as a callback back iterate_over_mappings.  */
typedef int (iterate_over_mappings_cb_ftype)
  (CORE_ADDR vaddr, unsigned long size, int read, int write, int execute,
   void *data);

d442 2
a443 5
  (procinfo *pi,
   iterate_over_mappings_cb_ftype *child_func,
   void *data,
   int (*func) (struct prmap *map,
		iterate_over_mappings_cb_ftype *child_func,
d3779 1
a3779 1
			       iterate_over_mappings_cb_ftype *child_func,
d5221 1
a5221 2
iterate_over_mappings (procinfo *pi,
		       iterate_over_mappings_cb_ftype *child_func,
d5224 1
a5224 1
				    iterate_over_mappings_cb_ftype *child_func,
d5276 1
a5276 8
   function for each memory region.  The external function will have
   the signature:

     int callback (CORE_ADDR vaddr,
		   unsigned long size,
		   int read, int write, int execute,
		   void *data);

d5281 1
a5281 5
			      int (*func) (CORE_ADDR,
					   unsigned long,
					   int, int, int,
					   void *),
			      void *data)
d5304 1
a5304 5
proc_find_memory_regions (int (*func) (CORE_ADDR,
				       unsigned long,
				       int, int, int,
				       void *),
			  void *data)
d5343 1
a5343 2
info_mappings_callback (struct prmap *map,
			iterate_over_mappings_cb_ftype *ignore,
@


1.135
log
@	* breakpoint.c (update_watchpoint, _initialize_breakpoint): Remove
	unnecessary space in string.
	* filesystem.c (_initialize_filesystem): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* infcmd.c (step_once): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* linux-nat.c (linux_child_follow_fork): Ditto.
	* maint.c (maintenance_deprecate): Ditto.
	* memattr.c (_initialize_mem): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* monitor.c (monitor_open): Ditto.
	* procfs.c (procfs_xfer_memory): Ditto.
	* reverse.c (bookmarks_info): Ditto.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Ditto.
	* stack.c (_initialize_stack): Ditto.
	* tracepoint.c (_initialize_tracepoint): Ditto.
	* xtensa-tdep.c (xtensa_supply_gregset,
	xtensa_regset_from_core_section): Ditto.
@
text
@d5164 2
a5165 1
procfs_insert_watchpoint (CORE_ADDR addr, int len, int type)
d5186 2
a5187 1
procfs_remove_watchpoint (CORE_ADDR addr, int len, int type)
@


1.134
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* procfs.c: White space.
@
text
@d4283 1
a4283 1
	  PROCFS_NOTE ("write memory: ");
d4285 1
a4285 1
	  PROCFS_NOTE ("write memory: \n");
d4291 1
a4291 1
	  PROCFS_NOTE ("read  memory: \n");
@


1.133
log
@	* procfs.c: Reformat.
@
text
@d862 1
d1004 1
d1570 1
d1608 1
d2282 1
d3217 1
d3276 1
a3573 1

d4510 1
d5112 1
d5704 1
@


1.132
log
@	* procfs.c (proc_watchpoint_address): New function.
	(procfs_stopped_by_watchpoint): Remove useless check after
	find_procinfo_or_die call.
	(procfs_stopped_data_address): New function.
	(procfs_use_watchpoints): Register new watchpoint related function.
@
text
@d56 34
a89 36
/*
 * PROCFS.C
 *
 * This module provides the interface between GDB and the
 * /proc file system, which is used on many versions of Unix
 * as a means for debuggers to control other processes.
 * Examples of the systems that use this interface are:
 *   Irix
 *   Solaris
 *   OSF
 *   Unixware
 *   AIX5
 *
 * /proc works by imitating a file system: you open a simulated file
 * that represents the process you wish to interact with, and
 * perform operations on that "file" in order to examine or change
 * the state of the other process.
 *
 * The most important thing to know about /proc and this module
 * is that there are two very different interfaces to /proc:
 *   One that uses the ioctl system call, and
 *   another that uses read and write system calls.
 * This module has to support both /proc interfaces.  This means
 * that there are two different ways of doing every basic operation.
 *
 * In order to keep most of the code simple and clean, I have
 * defined an interface "layer" which hides all these system calls.
 * An ifdef (NEW_PROC_API) determines which interface we are using,
 * and most or all occurrances of this ifdef should be confined to
 * this interface layer.
 */


/* Determine which /proc API we are using:
   The ioctl API defines PIOCSTATUS, while
   the read/write (multiple fd) API never does.  */
d106 1
a106 1
/* Prototypes for supply_gregset etc. */
d111 1
a111 3
/*
 * This module defines the GDB target vector and its methods.
 */
d126 1
a126 1
static void procfs_create_inferior (struct target_ops *, char *, 
d155 3
a157 3
/* When GDB is built as 64-bit application on Solaris, the auxv data is
   presented in 64-bit format.  We need to provide a custom parser to handle 
   that.  */
d160 1
a160 1
                  gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp)
d167 1
a167 1
  
d188 3
a190 3
  t->to_shortname           = "procfs";
  t->to_longname            = "Unix /proc child process";
  t->to_doc                 =
d192 10
a201 10
  t->to_create_inferior     = procfs_create_inferior;
  t->to_kill                = procfs_kill_inferior;
  t->to_mourn_inferior      = procfs_mourn_inferior;
  t->to_attach              = procfs_attach;
  t->to_detach              = procfs_detach;
  t->to_wait                = procfs_wait;
  t->to_resume              = procfs_resume;
  t->to_fetch_registers     = procfs_fetch_registers;
  t->to_store_registers     = procfs_store_registers;
  t->to_xfer_partial        = procfs_xfer_partial;
d203 7
a209 7
  t->to_notice_signals      = procfs_notice_signals;
  t->to_files_info          = procfs_files_info;
  t->to_stop                = procfs_stop;

  t->to_find_new_threads    = procfs_find_new_threads;
  t->to_thread_alive        = procfs_thread_alive;
  t->to_pid_to_str          = procfs_pid_to_str;
d211 1
a211 1
  t->to_has_thread_control  = tc_schedlock;
d219 1
a219 1
  t->to_magic               = OPS_MAGIC;
d226 4
a229 6
/*
 * World Unification:
 *
 * Put any typedefs, defines etc. here that are required for
 * the unification of code that handles different versions of /proc.
 */
d314 1
a314 2
   (in theory) have different syscall numbers.
*/
d384 7
a390 7
  /*
   * The next three file descriptors are actually only needed in the
   * read/write, multiple-file-descriptor implemenation (NEW_PROC_API).
   * However, to avoid a bunch of #ifdefs in the code, we will use
   * them uniformly by (in the case of the ioctl single-file-descriptor
   * implementation) filling them with copies of the control fd.
   */
d451 2
a452 2
                iterate_over_mappings_cb_ftype *child_func,
                void *data));
d457 2
a458 7
/*
 * Function: find_procinfo
 *
 * Search the procinfo list.
 *
 * Returns: pointer to procinfo, or NULL if not found.
 */
d477 1
a477 1
	   thread. */
d487 1
a487 5
/*
 * Function: find_procinfo_or_die
 *
 * Calls find_procinfo, but errors on failure.
 */
d497 2
a498 1
	error (_("procfs: couldn't find pid %d (kernel thread %d) in procinfo list."),
d506 9
a514 10
/* open_with_retry() is a wrapper for open().  The appropriate
   open() call is attempted; if unsuccessful, it will be retried as
   many times as needed for the EAGAIN and EINTR conditions.

   For other conditions, open_with_retry() will retry the open() a
   limited number of times.  In addition, a short sleep is imposed
   prior to retrying the open().  The reason for this sleep is to give
   the kernel a chance to catch up and create the file in question in
   the event that GDB "wins" the race to open a file before the kernel
   has created it.  */
d539 6
a544 12
/*
 * Function: open_procinfo_files
 *
 * Open the file descriptor for the process or LWP.
 * ifdef NEW_PROC_API, we only open the control file descriptor;
 * the others are opened lazily as needed.
 * else (if not NEW_PROC_API), there is only one real
 * file descriptor, but we keep multiple copies of it so that
 * the code that uses them does not have to be #ifdef'd.
 *
 * Return: file descriptor, or zero for failure.
 */
d556 44
a599 45
  /*
   * This function is getting ALMOST long enough to break up into several.
   * Here is some rationale:
   *
   * NEW_PROC_API (Solaris 2.6, Solaris 2.7, Unixware):
   *   There are several file descriptors that may need to be open
   *   for any given process or LWP.  The ones we're intereted in are:
   *     - control	 (ctl)	  write-only	change the state
   *     - status	 (status) read-only	query the state
   *     - address space (as)     read/write	access memory
   *     - map           (map)    read-only     virtual addr map
   *   Most of these are opened lazily as they are needed.
   *   The pathnames for the 'files' for an LWP look slightly
   *   different from those of a first-class process:
   *     Pathnames for a process (<proc-id>):
   *       /proc/<proc-id>/ctl
   *       /proc/<proc-id>/status
   *       /proc/<proc-id>/as
   *       /proc/<proc-id>/map
   *     Pathnames for an LWP (lwp-id):
   *       /proc/<proc-id>/lwp/<lwp-id>/lwpctl
   *       /proc/<proc-id>/lwp/<lwp-id>/lwpstatus
   *   An LWP has no map or address space file descriptor, since
   *   the memory map and address space are shared by all LWPs.
   *
   * Everyone else (Solaris 2.5, Irix, OSF)
   *   There is only one file descriptor for each process or LWP.
   *   For convenience, we copy the same file descriptor into all
   *   three fields of the procinfo struct (ctl_fd, status_fd, and
   *   as_fd, see NEW_PROC_API above) so that code that uses them
   *   doesn't need any #ifdef's.
   *     Pathname for all:
   *       /proc/<proc-id>
   *
   *   Solaris 2.5 LWP's:
   *     Each LWP has an independent file descriptor, but these
   *     are not obtained via the 'open' system call like the rest:
   *     instead, they're obtained thru an ioctl call (PIOCOPENLWP)
   *     to the file descriptor of the parent process.
   *
   *   OSF threads:
   *     These do not even have their own independent file descriptor.
   *     All operations are carried out on the file descriptor of the
   *     parent process.  Therefore we just call open again for each
   *     thread, getting a new handle for the same 'file'.
d603 4
a606 6
  /*
   * In this case, there are several different file descriptors that
   * we might be asked to open.  The control file descriptor will be
   * opened early, but the others will be opened lazily as they are
   * needed.
   */
d643 10
a652 12
  /*
   * In this case, there is only one file descriptor for each procinfo
   * (ie. each process or LWP).  In fact, only the file descriptor for
   * the process can actually be opened by an 'open' system call.
   * The ones for the LWPs have to be obtained thru an IOCTL call
   * on the process's file descriptor.
   *
   * For convenience, we copy each procinfo's single file descriptor
   * into all of the fields occupied by the several file descriptors
   * of the NEW_PROC_API implementation.  That way, the code that uses
   * them can be written without ifdefs.
   */
d690 3
a692 8
/*
 * Function: create_procinfo
 *
 * Allocate a data structure and link it into the procinfo list.
 * (First tries to find a pre-existing one (FIXME: why?)
 *
 * Return: pointer to new procinfo struct.
 */
d740 1
a740 5
/*
 * Function: close_procinfo_files
 *
 * Close all file descriptors associated with the procinfo
 */
d756 1
a756 5
/*
 * Function: destroy_procinfo
 *
 * Destructor function.  Close, unlink and deallocate the object.
 */
d763 1
a763 1
  /* Step one: unlink the procinfo from its list */
d774 1
a774 1
  /* Step two: close any open file descriptors */
d777 1
a777 1
  /* Step three: free the memory. */
d814 3
a816 7
/*
 * Function: dead_procinfo
 *
 * To be called on a non_recoverable error for a procinfo.
 * Prints error messages, optionally sends a SIGKILL to the process,
 * then destroys the data structure.
 */
d839 3
a841 7
/*
 * Function: sysset_t_size
 *
 * Returns the (complete) size of a sysset_t struct.  Normally, this
 * is just sizeof (syset_t), but in the case of Monterey/64, the actual
 * size of sysset_t isn't known until runtime.
 */
d855 1
a855 3
/* Function: sysset_t_alloc

   Allocate and (partially) initialize a sysset_t struct.  */
d864 2
a865 2
  ret->pr_size = (pi->num_syscalls + (8 * sizeof (uint64_t) - 1))
                 / (8 * sizeof (uint64_t));
d872 1
a872 3
/* Function: load_syscalls

   Extract syscall numbers and names from /proc/<pid>/sysent.  Initialize
d892 1
a892 1
  /* Open the file descriptor for the sysent file */
d908 2
a909 1
      error (_("load_syscalls: /proc/%d/sysent contains no syscalls!"), pi->pid);
d930 1
a930 1
        && syscalls[i].pr_nameoff > 0
d940 1
a940 1
  /* Read the syscall names in */
d948 1
a948 1
          || syscalls[i].pr_number < 0
d951 1
a951 1
                                       != (off_t) syscalls[i].pr_nameoff))
d977 1
a977 3
/* Function: free_syscalls

   Free the space allocated for the syscall names from the procinfo
d996 1
a996 3
/* Function: find_syscall

   Given a name, look up (and return) the corresponding syscall number.
d1016 9
a1024 11
/*
 * This "module" is the interface layer between the /proc system API
 * and the gdb target vector functions.  This layer consists of
 * access functions that encapsulate each of the basic operations
 * that we need to use from the /proc API.
 *
 * The main motivation for this layer is to hide the fact that
 * there are two very different implementations of the /proc API.
 * Rather than have a bunch of #ifdefs all thru the gdb target vector
 * functions, we do our best to hide them all in here.
 */
d1088 5
a1092 11
/*
 * Function: proc_get_status
 *
 * Updates the status struct in the procinfo.
 * There is a 'valid' flag, to let other functions know when
 * this function needs to be called (so the status is only
 * read when it is needed).  The status file descriptor is
 * also only opened when it is needed.
 *
 * Return: non-zero for success, zero for failure.
 */
d1163 1
a1163 1
  /* Just read the danged status.  Now isn't that simple? */
d1176 1
a1176 1
  /* The status struct includes general regs, so mark them valid too */
d1179 2
a1180 2
  /* In the read/write multiple-fd model,
     the status struct includes the fp regs too, so mark them valid too */
d1183 1
a1183 1
  return pi->status_valid;	/* True if success, false if failure. */
d1186 1
a1186 5
/*
 * Function: proc_flags
 *
 * returns the process flags (pr_flags field).
 */
d1199 1
a1199 1
     The two sets of flags don't overlap. */
d1209 1
a1209 5
/*
 * Function: proc_why
 *
 * returns the pr_why field (why the process stopped).
 */
d1225 1
a1225 5
/*
 * Function: proc_what
 *
 * returns the pr_what field (details of why the process stopped).
 */
d1241 4
a1244 8
/*
 * Function: proc_watchpoint_address
 *
 *   This function is only called when PI is stopped by a watchpoint.
 *   Assuming OS supports it, write to *ADDR the data address which
 * triggered it and return 1.
 * Return 0 if it is not possible to know the address.
 */
d1266 3
a1268 5
/*
 * Function: proc_nsysarg
 *
 * returns the pr_nsysarg field (number of args to the current syscall).
 */
d1284 2
a1285 5
/*
 * Function: proc_sysargs
 *
 * returns the pr_sysarg field (pointer to the arguments of current syscall).
 */
d1301 2
a1302 5
/*
 * Function: proc_syscall
 *
 * returns the pr_syscall field (id of current syscall if we are in one).
 */
d1319 1
a1319 5
/*
 * Function: proc_cursig:
 *
 * returns the pr_cursig field (current signal).
 */
d1335 28
a1362 32
/*
 * Function: proc_modify_flag
 *
 *  === I appologize for the messiness of this function.
 *  === This is an area where the different versions of
 *  === /proc are more inconsistent than usual.     MVS
 *
 * Set or reset any of the following process flags:
 *    PR_FORK	-- forked child will inherit trace flags
 *    PR_RLC	-- traced process runs when last /proc file closed.
 *    PR_KLC    -- traced process is killed when last /proc file closed.
 *    PR_ASYNC	-- LWP's get to run/stop independently.
 *
 * There are three methods for doing this function:
 * 1) Newest: read/write [PCSET/PCRESET/PCUNSET]
 *    [Sol6, Sol7, UW]
 * 2) Middle: PIOCSET/PIOCRESET
 *    [Irix, Sol5]
 * 3) Oldest: PIOCSFORK/PIOCRFORK/PIOCSRLC/PIOCRRLC
 *    [OSF, Sol5]
 *
 * Note: Irix does not define PR_ASYNC.
 * Note: OSF  does not define PR_KLC.
 * Note: OSF  is the only one that can ONLY use the oldest method.
 *
 * Arguments:
 *    pi   -- the procinfo
 *    flag -- one of PR_FORK, PR_RLC, or PR_ASYNC
 *    mode -- 1 for set, 0 for reset.
 *
 * Returns non-zero for success, zero for failure.
 */
d1371 5
a1375 8
  /*
   * These operations affect the process as a whole, and applying
   * them to an individual LWP has the same meaning as applying them
   * to the main process.  Therefore, if we're ever called with a
   * pointer to an LWP's procinfo, let's substitute the process's
   * procinfo and avoid opening the LWP's file descriptor
   * unnecessarily.
   */
d1444 2
a1445 1
  /* The above operation renders the procinfo's cached pstatus obsolete. */
d1464 3
a1466 9
/*
 * Function: proc_set_run_on_last_close
 *
 * Set the run_on_last_close flag.
 * Process with all threads will become runnable
 * when debugger closes all /proc fds.
 *
 * Returns non-zero for success, zero for failure.
 */
d1474 3
a1476 9
/*
 * Function: proc_unset_run_on_last_close
 *
 * Reset the run_on_last_close flag.
 * Process will NOT become runnable
 * when debugger closes its file handles.
 *
 * Returns non-zero for success, zero for failure.
 */
d1485 3
a1487 9
/*
 * Function: proc_set_kill_on_last_close
 *
 * Set the kill_on_last_close flag.
 * Process with all threads will be killed when debugger
 * closes all /proc fds (or debugger exits or dies).
 *
 * Returns non-zero for success, zero for failure.
 */
d1495 3
a1497 9
/*
 * Function: proc_unset_kill_on_last_close
 *
 * Reset the kill_on_last_close flag.
 * Process will NOT be killed when debugger
 * closes its file handles (or exits or dies).
 *
 * Returns non-zero for success, zero for failure.
 */
d1506 4
a1509 9
/*
 * Function: proc_set_inherit_on_fork
 *
 * Set inherit_on_fork flag.
 * If the process forks a child while we are registered for events
 * in the parent, then we will also recieve events from the child.
 *
 * Returns non-zero for success, zero for failure.
 */
d1517 4
a1520 9
/*
 * Function: proc_unset_inherit_on_fork
 *
 * Reset inherit_on_fork flag.
 * If the process forks a child while we are registered for events
 * in the parent, then we will NOT recieve events from the child.
 *
 * Returns non-zero for success, zero for failure.
 */
d1529 3
a1531 9
/*
 * Function: proc_set_async
 *
 * Set PR_ASYNC flag.
 * If one LWP stops because of a debug event (signal etc.),
 * the remaining LWPs will continue to run.
 *
 * Returns non-zero for success, zero for failure.
 */
d1539 3
a1541 9
/*
 * Function: proc_unset_async
 *
 * Reset PR_ASYNC flag.
 * If one LWP stops because of a debug event (signal etc.),
 * then all other LWPs will stop as well.
 *
 * Returns non-zero for success, zero for failure.
 */
d1550 2
a1551 6
/*
 * Function: proc_stop_process
 *
 * Request the process/LWP to stop.  Does not wait.
 * Returns non-zero for success, zero for failure.
 */
d1558 2
a1559 4
  /*
   * We might conceivably apply this operation to an LWP, and
   * the LWP's ctl file descriptor might not be open.
   */
d1586 2
a1587 6
/*
 * Function: proc_wait_for_stop
 *
 * Wait for the process or LWP to stop (block until it does).
 * Returns non-zero for success, zero for failure.
 */
d1594 4
a1597 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d1625 18
a1642 25
/*
 * Function: proc_run_process
 *
 * Make the process or LWP runnable.
 * Options (not all are implemented):
 *   - single-step
 *   - clear current fault
 *   - clear current signal
 *   - abort the current system call
 *   - stop as soon as finished with system call
 *   - (ioctl): set traced signal set
 *   - (ioctl): set held   signal set
 *   - (ioctl): set traced fault  set
 *   - (ioctl): set start pc (vaddr)
 * Always clear the current fault.
 * Clear the current signal if 'signo' is zero.
 *
 * Arguments:
 *   pi		the process or LWP to operate on.
 *   step	if true, set the process or LWP to trap after one instr.
 *   signo	if zero, clear the current signal if any.
 *		if non-zero, set the current signal to this one.
 *
 * Returns non-zero for success, zero for failure.
 */
d1650 2
a1651 4
  /*
   * We will probably have to apply this operation to individual threads,
   * so make sure the control file descriptor is open.
   */
d1688 2
a1689 6
/*
 * Function: proc_set_traced_signals
 *
 * Register to trace signals in the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d1696 4
a1699 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d1728 2
a1729 6
/*
 * Function: proc_set_traced_faults
 *
 * Register to trace hardware faults in the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d1736 4
a1739 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d1766 2
a1767 6
/*
 * Function: proc_set_traced_sysentry
 *
 * Register to trace entry to system calls in the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d1774 4
a1777 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d1790 1
a1790 1
                  - sizeof (sysset_t)
d1804 2
a1805 1
  /* The above operation renders the procinfo's cached pstatus obsolete. */
d1811 2
a1812 6
/*
 * Function: proc_set_traced_sysexit
 *
 * Register to trace exit from system calls in the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d1819 4
a1822 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d1835 1
a1835 1
                  - sizeof (sysset_t)
d1849 2
a1850 1
  /* The above operation renders the procinfo's cached pstatus obsolete. */
d1856 2
a1857 6
/*
 * Function: proc_set_held_signals
 *
 * Specify the set of blocked / held signals in the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d1864 4
a1867 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d1887 2
a1888 1
  /* The above operation renders the procinfo's cached pstatus obsolete. */
d1894 2
a1895 6
/*
 * Function: proc_get_pending_signals
 *
 * returns the set of signals that are pending in the process or LWP.
 * Will also copy the sigset if 'save' is non-zero.
 */
d1902 4
a1905 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d1925 2
a1926 6
/*
 * Function: proc_get_signal_actions
 *
 * returns the set of signal actions.
 * Will also copy the sigactionset if 'save' is non-zero.
 */
d1933 4
a1936 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d1956 2
a1957 6
/*
 * Function: proc_get_held_signals
 *
 * returns the set of signals that are held / blocked.
 * Will also copy the sigset if 'save' is non-zero.
 */
d1964 4
a1967 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d1996 2
a1997 6
/*
 * Function: proc_get_traced_signals
 *
 * returns the set of signals that are traced / debugged.
 * Will also copy the sigset if 'save' is non-zero.
 */
d2004 4
a2007 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2032 2
a2033 6
/*
 * Function: proc_trace_signal
 *
 * Add 'signo' to the set of signals that are traced.
 * Returns non-zero for success, zero for failure.
 */
d2040 4
a2043 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2060 2
a2061 6
/*
 * Function: proc_ignore_signal
 *
 * Remove 'signo' from the set of signals that are traced.
 * Returns non-zero for success, zero for failure.
 */
d2068 4
a2071 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2088 2
a2089 6
/*
 * Function: proc_get_traced_faults
 *
 * returns the set of hardware faults that are traced /debugged.
 * Will also copy the faultset if 'save' is non-zero.
 */
d2096 4
a2099 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2124 2
a2125 6
/*
 * Function: proc_get_traced_sysentry
 *
 * returns the set of syscalls that are traced /debugged on entry.
 * Will also copy the syscall set if 'save' is non-zero.
 */
d2132 4
a2135 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2166 1
a2166 1
	           SEEK_SET)
d2191 2
a2192 6
/*
 * Function: proc_get_traced_sysexit
 *
 * returns the set of syscalls that are traced /debugged on exit.
 * Will also copy the syscall set if 'save' is non-zero.
 */
d2199 4
a2202 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2232 2
a2233 1
	if (lseek (pi->status_fd, (off_t) pi->prstatus.pr_sysexit_offset, SEEK_SET)
d2258 3
a2260 7
/*
 * Function: proc_clear_current_fault
 *
 * The current fault (if any) is cleared; the associated signal
 * will not be sent to the process or LWP when it resumes.
 * Returns non-zero for success,  zero for failure.
 */
d2267 4
a2270 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2287 7
a2293 12
/*
 * Function: proc_set_current_signal
 *
 * Set the "current signal" that will be delivered next to the process.
 * NOTE: semantics are different from those of KILL.
 * This signal will be delivered to the process or LWP
 * immediately when it is resumed (even if the signal is held/blocked);
 * it will NOT immediately cause another event of interest, and will NOT
 * first trap back to the debugger.
 *
 * Returns non-zero for success,  zero for failure.
 */
d2308 4
a2311 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2318 3
a2320 3
   * receives a PIOCSSIG with a signal identical to the current signal,
   * it messes up the current signal. Work around the kernel bug.
   */
d2364 3
a2366 7
/*
 * Function: proc_clear_current_signal
 *
 * The current signal (if any) is cleared, and
 * is not sent to the process or LWP when it resumes.
 * Returns non-zero for success,  zero for failure.
 */
d2373 4
a2376 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2603 2
a2604 6
/*
 * Function: proc_kill
 *
 * Send a signal to the proc or lwp with the semantics of "kill()".
 * Returns non-zero for success,  zero for failure.
 */
d2611 2
a2612 4
  /*
   * We might conceivably apply this operation to an LWP, and
   * the LWP's ctl file descriptor might not be open.
   */
d2637 2
a2638 6
/*
 * Function: proc_parent_pid
 *
 * Find the pid of the process that started this one.
 * Returns the parent process pid, or zero.
 */
d2643 4
a2646 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
a2675 5
/*
 * Function: proc_set_watchpoint
 *
 */

d2724 3
a2726 12
/*
 * Function: proc_get_LDT_entry
 *
 * Inputs:
 *   procinfo *pi;
 *   int key;
 *
 * The 'key' is actually the value of the lower 16 bits of
 * the GS register for the LWP that we're interested in.
 *
 * Return: matching ssh struct (LDT entry).
 */
d2803 1
a2803 9
/*
 * Function: procfs_find_LDT_entry
 *
 * Input:
 *   ptid_t ptid;	// The GDB-style pid-plus-LWP.
 *
 * Return:
 *   pointer to the corresponding LDT entry.
 */
d2842 1
a2842 5
/*
 * Function: proc_get_nthreads
 *
 * Return the number of threads for the process
 */
d2845 1
a2845 3
/*
 * OSF version
 */
d2859 1
a2859 3
/*
 * Solaris and Unixware version
 */
d2867 2
a2868 4
  /*
   * NEW_PROC_API: only works for the process procinfo,
   * because the LWP procinfos do not get prstatus filled in.
   */
d2877 1
a2877 3
/*
 * Default version
 */
d2886 6
a2891 8
/*
 * Function: proc_get_current_thread (LWP version)
 *
 * Return the ID of the thread that had an event of interest.
 * (ie. the one that hit a breakpoint or other traced event).
 * All other things being equal, this should be the ID of a
 * thread that is currently executing.
 */
d2894 1
a2894 3
/*
 * Solaris and Unixware version
 */
d2898 4
a2901 6
  /*
   * Note: this should be applied to the root procinfo for the process,
   * not to the procinfo for an LWP.  If applied to the procinfo for
   * an LWP, it will simply return that LWP's ID.  In that case,
   * find the parent process procinfo.
   */
d2919 1
a2919 3
/*
 * OSF version
 */
d2931 1
a2931 3
/*
 * Default version
 */
d2941 4
a2944 10
/*
 * Function: proc_update_threads
 *
 * Discover the IDs of all the threads within the process, and
 * create a procinfo for each of them (chained to the parent).
 *
 * This unfortunately requires a different method on every OS.
 *
 * Return: non-zero for success, zero for failure.
 */
d2959 1
a2959 3
/*
 * Solaris 2.5 (ioctl) version
 */
d2968 4
a2971 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d2987 1
a2987 1
  /* Skip element zero, which represents the process as a whole. */
d3002 1
a3002 3
/*
 * Unixware and Solaris 6 (and later) version
 */
d3019 4
a3022 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d3029 7
a3035 9
  /*
   * Unixware
   *
   * Note: this brute-force method is the only way I know of
   * to accomplish this task on Unixware.  This method will
   * also work on Solaris 2.6 and 2.7.  There is a much simpler
   * and more elegant way to do this on Solaris, but the margins
   * of this manuscript are too small to write it here...  ;-)
   */
d3056 1
a3056 3
/*
 * OSF version
 */
d3063 4
a3066 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d3092 1
a3092 3
/*
 * Default version
 */
d3102 12
a3113 22
/*
 * Function: proc_iterate_over_threads
 *
 * Description:
 *   Given a pointer to a function, call that function once
 *   for each lwp in the procinfo list, until the function
 *   returns non-zero, in which event return the value
 *   returned by the function.
 *
 * Note: this function does NOT call update_threads.
 * If you want to discover new threads first, you must
 * call that function explicitly.  This function just makes
 * a quick pass over the currently-known procinfos.
 *
 * Arguments:
 *   pi		- parent process procinfo
 *   func	- per-thread function
 *   ptr	- opaque parameter for function.
 *
 * Return:
 *   First non-zero return value from the callee, or zero.
 */
d3123 4
a3126 6
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and
   * replace it with one that makes sure the ctl_fd is open.
   */
d3147 2
a3148 3
/*
 * Here are all of the gdb target vector functions and their friends.
 */
d3154 1
a3154 1
                                   int entry_or_exit, int mode, int from_tty);
d3163 5
a3167 10
/*
 * Function: procfs_debug_inferior
 *
 * Sets up the inferior to be debugged.
 * Registers to trace signals, hardware faults, and syscalls.
 * Note: does not set RLC flag: caller may want to customize that.
 *
 * Returns: zero for success (note! unlike most functions in this module)
 *   On failure, returns the LINE NUMBER where it failed!
 */
d3307 1
a3307 1
	                 target_pid_to_str (pid_to_ptid (pid)));
d3517 1
a3517 1
 
d3675 2
a3676 2
          && sym->name != NULL && strcmp (sym->name, "__dbx_link") == 0)
        return (sym->value + sym->section->vma);
d3704 1
a3704 1
         symbol in it.  */
d3717 5
a3721 5
        {
          warning (_("Failed to insert dbx_link breakpoint."));
          bfd_close (abfd);
          return 0;
        }
d3731 6
a3736 8
   space in the process.  The callback function  receives an open
   file descriptor for the file corresponding to that mapped
   address space (if there is one), and the base address of the
   mapped space.  Quit when the callback function returns a
   nonzero value, or at teh end of the mappings.

   Returns: the first non-zero return value of the callback function,
   or zero.  */
d3781 2
a3782 2
                               iterate_over_mappings_cb_ftype *child_func,
                               void *data)
d3805 5
a3809 11
/*
 * Function: target_wait
 *
 * Retrieve the next stop event from the child process.
 * If child has not stopped yet, wait for it to stop.
 * Translate /proc eventcodes (or possibly wait eventcodes)
 * into gdb internal event codes.
 *
 * Return: id of process (and possibly thread) that incurred the event.
 *         event codes are returned thru a pointer parameter.
 */
d4005 14
a4018 14
                else if (what == SYS_syssgi)
                  {
                    /* see if we can break on dbx_link().  If yes, then
                       we no longer need the SYS_syssgi notifications.  */
                    if (insert_dbx_link_breakpoint (pi))
                      proc_trace_syscalls_1 (pi, SYS_syssgi, PR_SYSEXIT,
                                             FLAG_RESET, 0);

                    /* This is an internal event and should be transparent
                       to wfi, so resume the execution and wait again.  See
                       comment in procfs_init_inferior() for more details.  */
                    target_resume (ptid, 0, TARGET_SIGNAL_0);
                    goto wait_again;
                  }
d4022 7
a4028 8
		    /*
		     * This syscall is somewhat like fork/exec.
		     * We will get the event twice: once for the parent LWP,
		     * and once for the child.  We should already know about
		     * the parent LWP, but the child will be new to us.  So,
		     * whenever we get this event, if it represents a new
		     * thread, simply add the thread to the list.
		     */
d4074 2
a4075 1
			  printf_filtered (_("%ld syscall arguments:\n"), nsysargs);
d4140 5
a4144 5
                  /* If we hit our __dbx_link() internal breakpoint,
                     then remove it.  See comments in procfs_init_inferior()
                     for more details.  */
                  if (dbx_link_bpt_addr != 0
                      && dbx_link_bpt_addr
d4146 1
a4146 1
                    remove_dbx_link_breakpoint ();
d4181 2
a4182 4
	      /*
	       * Got this far without error:
	       * If retval isn't in the threads database, add it.
	       */
d4187 3
a4189 6
		  /*
		   * We have a new thread.
		   * We need to add it both to GDB's list and to our own.
		   * If we don't create a procinfo, resume may be unhappy
		   * later.
		   */
d4296 14
a4309 20
/*
 * Function: invalidate_cache
 *
 * Called by target_resume before making child runnable.
 * Mark cached registers and status's invalid.
 * If there are "dirty" caches that need to be written back
 * to the child process, do that.
 *
 * File descriptors are also cached.
 * As they are a limited resource, we cannot hold onto them indefinitely.
 * However, as they are expensive to open, we don't want to throw them
 * away indescriminately either.  As a compromise, we will keep the
 * file descriptors for the parent process, but discard any file
 * descriptors we may have accumulated for the threads.
 *
 * Return value:
 * As this function is called by iterate_over_threads, it always
 * returns zero (so that iterate_over_threads will keep iterating).
 */

d4314 2
a4315 3
  /*
   * About to run the child; invalidate caches and do any other cleanup.
   */
d4354 3
a4356 7
/*
 * Function: make_signal_thread_runnable
 *
 * A callback function for iterate_over_threads.
 * Find the asynchronous signal thread, and make it runnable.
 * See if that helps matters any.
 */
d4373 9
a4381 16
/*
 * Function: target_resume
 *
 * Make the child process runnable.  Normally we will then call
 * procfs_wait and wait for it to stop again (unles gdb is async).
 *
 * Arguments:
 *  step:  if true, then arrange for the child to stop again
 *         after executing a single instruction.
 *  signo: if zero, then cancel any pending signal.
 *         If non-zero, then arrange for the indicated signal
 *         to be delivered to the child when it runs.
 *  pid:   if -1, then allow any child thread to run.
 *         if non-zero, then allow only the indicated thread to run.
 *******   (not implemented yet)
 */
d4398 1
a4398 1
     	(proc_trace_signals, proc_trace_faults)
d4404 1
a4404 1
     to proc_run_process (for use in the prrun struct by ioctl). */
d4409 1
a4409 1
  /* First cut: ignore pid argument */
d4421 2
a4422 2
  /* Running the process voids all cached registers and status. */
  /* Void the threads' caches first */
d4429 2
a4430 1
      /* Resume a specific thread, presumably suppressing the others. */
d4436 2
a4437 3
	      /* We're to resume a specific thread, and not the others.
	       * Set the child process's PR_ASYNC flag.
	       */
d4455 2
a4456 1
	warning (_("resume: target already running.  Pretend to resume, and hope for the best!"));
d4462 4
a4465 9
/*
 * Function: register_gdb_signals
 *
 * Traverse the list of signals that GDB knows about
 * (see "handle" command), and arrange for the target
 * to be stopped or not, according to these settings.
 *
 * Returns non-zero for success, zero for failure.
 */
d4483 1
a4483 5
/*
 * Function: target_notice_signals
 *
 * Set up to trace signals in the child process.
 */
d4498 1
a4498 5
/*
 * Function: target_files_info
 *
 * Print status information about the child process.
 */
d4509 3
a4511 8
/*
 * Function: target_stop
 *
 * Stop the child process asynchronously, as when the
 * gdb user types control-c or presses a "stop" button.
 *
 * Works by sending kill(SIGINT) to the child's process group.
 */
d4519 4
a4522 8
/*
 * Function: unconditionally_kill_inferior
 *
 * Make it die.  Wait for it to die.  Clean up after it.
 * Note: this should only be applied to the real process,
 * not to an LWP, because of the check for parent-process.
 * If we need this to work for an LWP, it needs some more logic.
 */
d4579 2
a4580 6
/*
 * Function: target_kill_inferior
 *
 * We're done debugging it, and we want it to go away.
 * Then we want GDB to forget all about it.
 */
d4596 1
a4596 5
/*
 * Function: target_mourn_inferior
 *
 * Forget we ever debugged this thing!
 */
d4622 4
a4625 8
/*
 * Function: init_inferior
 *
 * When GDB forks to create a runnable inferior process,
 * this function is called on the parent side of the fork.
 * It's job is to do whatever is necessary to make the child
 * ready to be debugged, and then wait for the child to synchronize.
 */
d4657 1
a4657 1
  /* If not stopped yet, wait for it to stop. */
d4676 1
a4676 1
  /* Register to trace selected signals in the child. */
d4723 1
a4723 1
     
d4735 7
a4741 11
/*
 * Function: set_exec_trap
 *
 * When GDB forks to create a new process, this function is called
 * on the child side of the fork before GDB exec's the user program.
 * Its job is to make the child minimally debuggable, so that the
 * parent GDB process can connect to the child and take over.
 * This function should do only the minimum to make that possible,
 * and to synchronize with the parent process.  The parent process
 * should take care of the details.
 */
d4760 2
a4761 1
      /* no need to call "dead_procinfo", because we're going to exit. */
d4769 1
a4769 1
  /* FIXME: make nice and maybe move into an access function. */
d4789 1
a4789 1
  /* Everyone else's (except OSF) method for tracing exec syscalls */
d4793 1
a4793 1
     *is* a SYS_execv.  So, we try to account for that. */
d4844 10
a4853 14
/*
 * Function: create_inferior
 *
 * This function is called BEFORE gdb forks the inferior process.
 * Its only real responsibility is to set things up for the fork,
 * and tell GDB which two functions to call after the fork (one
 * for the parent, and one for the child).
 *
 * This function does a complicated search for a unix shell program,
 * which it then uses to parse arguments and environment variables
 * to be sent to the child.  I wonder whether this code could not
 * be abstracted out and shared with other unix targets such as
 * infptrace?
 */
d4943 1
a4943 1
  /* Make sure to cancel the syssgi() syscall-exit notifications.  
d4957 1
a4957 1
                         SYS_syssgi, PR_SYSEXIT, FLAG_RESET, 0);
d4961 1
a4961 6
/*
 * Function: notice_thread
 *
 * Callback for find_new_threads.
 * Calls "add_thread".
 */
d4974 2
a4975 6
/*
 * Function: target_find_new_threads
 *
 * Query all the threads that the target knows about,
 * and give them back to GDB to add to its list.
 */
d4988 3
a4990 8
/*
 * Function: target_thread_alive
 *
 * Return true if the thread is still 'alive'.
 *
 * This guy doesn't really seem to be doing his job.
 * Got to investigate how to tell when a thread is really gone.
 */
d5011 2
a5012 1
  /* I couldn't have got its status if it weren't alive, so it's alive.  */
d5016 2
a5017 1
/* Convert PTID to a string.  Returns the string in a static buffer.  */
d5032 1
a5032 4
/*
 * Function: procfs_set_watchpoint
 * Insert a watchpoint
 */
d5036 1
a5036 1
                       int after)
d5113 2
a5114 6
/*
 * Function: stopped_by_watchpoint
 *
 * Returns non-zero if process is stopped on a hardware watchpoint fault,
 * else returns zero.
 */
d5140 5
a5144 10
/*
 * Function procfs_stopped_data_address
 * 
 * Returns 1 if we the OS knows the position of the triggered
 * watchpoint.  Sets *ADDR to that address.
 * Returns 0 if OS cannot report that address.
 * This function is only called if procfs_stopped_by_watchpoint
 * returned 1, thus no further checks are done.
 * The function also assumes that ADDR is not NULL.
 */
d5204 13
a5216 21
/*
 * Memory Mappings Functions:
 */

/*
 * Function: iterate_over_mappings
 *
 * Call a callback function once for each mapping, passing it the mapping,
 * an optional secondary callback function, and some optional opaque data.
 * Quit and return the first non-zero value returned from the callback.
 *
 * Arguments:
 *   pi   -- procinfo struct for the process to be mapped.
 *   func -- callback function to be called by this iterator.
 *   data -- optional opaque data to be passed to the callback function.
 *   child_func -- optional secondary function pointer to be passed
 *                 to the child function.
 *
 * Return: First non-zero return value from the callback function,
 *         or zero.
 */
d5274 10
a5283 14
/*
 * Function: find_memory_regions_callback
 *
 * Implements the to_find_memory_regions method.
 * Calls an external function for each memory region.
 * External function will have the signiture:
 *
 *   int callback (CORE_ADDR vaddr,
 *                 unsigned long size,
 *                 int read, int write, int execute,
 *                 void *data);
 *
 * Returns the integer value returned by the callback.
 */
d5301 11
a5311 14
/*
 * Function: proc_find_memory_regions
 *
 * External interface.  Calls a callback function once for each
 * mapped memory region in the child process, passing as arguments
 *	CORE_ADDR virtual_address,
 *	unsigned long size,
 *	int read, 	TRUE if region is readable by the child
 *	int write, 	TRUE if region is writable by the child
 *	int execute	TRUE if region is executable by the child.
 *
 * Stops iterating and returns the first non-zero value
 * returned by the callback.
 */
d5326 1
a5326 5
/*
 * Function: mappingflags
 *
 * Returns an ascii representation of a memory mapping's flags.
 */
d5353 2
a5354 5
/*
 * Function: info_mappings_callback
 *
 * Callback function, does the actual work for 'info proc mappings'.
 */
d5387 1
a5387 5
/*
 * Function: info_proc_mappings
 *
 * Implement the "info proc mappings" subcommand.
 */
d5415 1
a5415 5
/*
 * Function: info_proc_cmd
 *
 * Implement the "info proc" command.
 */
d5516 1
a5516 1
                      int mode, int from_tty)
d5519 1
a5519 1
  
d5536 1
a5536 1
        proc_error (pi, "proc-trace, set_traced_sysentry", __LINE__);
d5541 1
a5541 1
        proc_error (pi, "proc-trace, set_traced_sysexit", __LINE__);
d5613 7
a5619 9
/* miscellaneous stubs:                                             */
/* The following satisfy a few random symbols mostly created by    */
/* the solaris threads implementation, which I will chase down     */
/* later.        */

/*
 * Return a pid for which we guarantee
 * we will be able to find a 'live' procinfo.
 */
@


1.131
log
@Unused function in procfs.c on alpha-tru64.

The procfs_address_to_host_pointer function was not used outside of
alpha-tru64, and thus was triggering a compiler warning.  Adjusted
accordingly.

gdb/ChangeLog:

        * procfs.c (procfs_address_to_host_pointer): Only define when used.
@
text
@d1316 28
a5571 3
  if (!pi)	/* If no process, then not stopped by watchpoint!  */
    return 0;

d5589 20
d5655 1
@


1.130
log
@procfs.c: iterate_over_mappings callback has wrong profile.

The function proc_find_memory_regions calls iterate_over_mappings as
follow:

> return iterate_over_mappings (pi, func, data,
>                               find_memory_regions_callback);

The problem is that both func and find_memory_regions_callback
do not match the profile expected by iterate_over_mappings:

> iterate_over_mappings (procinfo *pi, int (*child_func) (), void *data,
>                        int (*func) (struct prmap *map,
>                                     int (*child_func) (),
>                                     void *data))

We cannot change proc_find_memory_regions such that FUNC is a pointer
to a function that takes no argument (in place of the 6 that it has).
This is because proc_find_memory_regions is used as a target_ops method.
However, it turns out that changing iterate_over_mappings to conform
to the profile imposed by the target_ops vector is possible without
much effort.

gdb/ChangeLog:

        * procfs.c (iterate_over_mappings_cb_ftype): New typedef.
        (iterate_over_mappings): Adjust function profile. Add declaration.
        (insert_dbx_link_bpt_in_region, info_mappings_callback):
        Adjust accordingly.
@
text
@a2904 1

d2908 2
d2921 1
@


1.129
log
@procfs.c: Move solib_mappings_callback up to avoid compiler warning.

There are currently 2 issues with the placement of this routine:
  - It's defined after it is being used (causing an implicit declaration);
  - It looks like it's being defined all the time, whereas it is used
    only on mips-irix (AFAICT) - shouldn't have this triggered a warning
    on sparc-solaris, for instance???

In any case, this patch moves this function up, inside the right region,
just before the function where it is actually used.

gdb/ChangeLog:

        * procfs.c (solib_mappings_callback): Move function up to avoid
        a compiler warning.
@
text
@d448 13
d4112 1
a4112 1
                               int (*child_func) (),
d5633 3
a5635 1
iterate_over_mappings (procinfo *pi, int (*child_func) (), void *data,
d5637 1
a5637 1
				    int (*child_func) (),
d5785 3
a5787 1
info_mappings_callback (struct prmap *map, int (*ignore) (), void *unused)
@


1.128
log
@procfs.c: Move find_signalled_thread and find_stop_signal.

These two functions are only used from procfs_make_note_section, which
itself is only defined if:

    #if defined (UNIXWARE) || defined (PIOCOPENLWP) || defined (PCAGENT)

So these two functions are unused on mips-irix, and they get flagged
by -Wunused-function. This patch simply moves these functions closer
to the function that uses them, which also has the effect of putting
them inside the same #if block as procfs_make_note_section.  Thus
they are defined only when used.

gdb/ChangeLog:

        * procfs.c (find_signalled_thread, find_stop_signal): Move
        these functions down to define them only when used.
@
text
@d4046 47
a5673 51
 * Function: solib_mappings_callback
 *
 * Calls the supplied callback function once for each mapped address
 * space in the process.  The callback function  receives an open
 * file descriptor for the file corresponding to that mapped
 * address space (if there is one), and the base address of the
 * mapped space.  Quit when the callback function returns a
 * nonzero value, or at teh end of the mappings.
 *
 * Returns: the first non-zero return value of the callback function,
 * or zero.
 */

int solib_mappings_callback (struct prmap *map,
			     int (*func) (int, CORE_ADDR),
			     void *data)
{
  procinfo *pi = data;
  int fd;

#ifdef NEW_PROC_API
  char name[MAX_PROC_NAME_SIZE + sizeof (map->pr_mapname)];

  if (map->pr_vaddr == 0 && map->pr_size == 0)
    return -1;		/* sanity */

  if (map->pr_mapname[0] == 0)
    {
      fd = -1;	/* no map file */
    }
  else
    {
      sprintf (name, "/proc/%d/object/%s", pi->pid, map->pr_mapname);
      /* Note: caller's responsibility to close this fd!  */
      fd = open_with_retry (name, O_RDONLY);
      /* Note: we don't test the above call for failure;
	 we just pass the FD on as given.  Sometimes there is
	 no file, so the open may return failure, but that's
	 not a problem.  */
    }
#else
  fd = ioctl (pi->ctl_fd, PIOCOPENM, &map->pr_vaddr);
  /* Note: we don't test the above call for failure;
     we just pass the FD on as given.  Sometimes there is
     no file, so the ioctl may return failure, but that's
     not a problem.  */
#endif
  return (*func) (fd, (CORE_ADDR) map->pr_vaddr);
}

/*
@


1.127
log
@gdb/
	* defs.h (parse_pid_to_attach): New.
	* utils.c (parse_pid_to_attach): New.
	* darwin-nat.c (darwin_attach): Replace ARGS parsing by parse_pid.
	* gnu-nat.c (gnu_attach): Likewise.
	* nto-procfs.c (procfs_attach): Likewise.
	* procfs.c (procfs_attach): Likewise.
	* windows-nat.c (windows_attach): Likewise.
	* inf-ptrace.c (inf_ptrace_attach): Likewise.  Remove variable dummy.
	* inf-ttrace.c (inf_ttrace_attach): Likewise.
	* remote.c (extended_remote_attach_1): Likewise.  New comment on getpid
	check.

gdb/testsuite/
	* gdb.base/attach.exp (attach to nonsense is prohibited): Make the
	"Illegal process-id" expect string more exact.
	(attach to digits-starting nonsense is prohibited): New.
@
text
@a6051 22
static int
find_signalled_thread (struct thread_info *info, void *data)
{
  if (info->stop_signal != TARGET_SIGNAL_0
      && ptid_get_pid (info->ptid) == ptid_get_pid (inferior_ptid))
    return 1;

  return 0;
}

static enum target_signal
find_stop_signal (void)
{
  struct thread_info *info =
    iterate_over_threads (find_signalled_thread, NULL);

  if (info)
    return info->stop_signal;
  else
    return TARGET_SIGNAL_0;
}

d6129 22
@


1.126
log
@Another -Wunused-function error in procfs.c (sparc-solaris)

        * procfs.c (insert_dbx_link_breakpoint): Delete declaration.  Move up.
        Only define if SYS_syssgi is defined.
        (remove_dbx_link_breakpoint): Delete declaration.  Move up.
        (dbx_link_addr, insert_dbx_link_bpt_in_file)
        (insert_dbx_link_bpt_in_region): Move up.  Only define if SYS_syssgi
        is itself defined.
@
text
@d3609 1
a3609 2
  if (!args)
    error_no_arg (_("process-id to attach"));
a3610 1
  pid = atoi (args);
@


1.125
log
@gdb/
	Support Valgrind attachments broken by the PIE support.
	* auxv.c: Include gdbcore.h.
	(procfs_xfer_auxv): Make static.  Reduce its comment.  Drop its
	parameters ops, object and annex.  Remove their assertions.
	(ld_so_xfer_auxv, memory_xfer_auxv): New function.
	* auxv.h (procfs_xfer_auxv): Remove comment.  Rename to ...
	(memory_xfer_auxv): ... here.
	* linux-nat.c (linux_xfer_partial): Rename procfs_xfer_auxv to
	memory_xfer_auxv.
	* procfs.c (procfs_xfer_partial): Likewise.
	* solib-svr4.c (svr4_relocate_main_executable): New prototype.
	(svr4_special_symbol_handling): Call svr4_relocate_main_executable.
	(svr4_solib_create_inferior_hook): Conditionalize the
	svr4_relocate_main_executable call.

gdb/testsuite/
	* gdb.base/valgrind-db-attach.exp, gdb.base/valgrind-db-attach.c: New.
@
text
@a3465 2
static int insert_dbx_link_breakpoint (procinfo *pi);
static void remove_dbx_link_breakpoint (void);
d3949 129
a5737 127
/* Remove the breakpoint that we inserted in __dbx_link().
   Does nothing if the breakpoint hasn't been inserted or has already
   been removed.  */

static void
remove_dbx_link_breakpoint (void)
{
  if (dbx_link_bpt_addr == 0)
    return;

  if (deprecated_remove_raw_breakpoint (target_gdbarch, dbx_link_bpt) != 0)
    warning (_("Unable to remove __dbx_link breakpoint."));

  dbx_link_bpt_addr = 0;
  dbx_link_bpt = NULL;
}

/* Return the address of the __dbx_link() function in the file
   refernced by ABFD by scanning its symbol table.  Return 0 if
   the symbol was not found.  */

static CORE_ADDR
dbx_link_addr (bfd *abfd)
{
  long storage_needed;
  asymbol **symbol_table;
  long number_of_symbols;
  long i;

  storage_needed = bfd_get_symtab_upper_bound (abfd);
  if (storage_needed <= 0)
    return 0;

  symbol_table = (asymbol **) xmalloc (storage_needed);
  make_cleanup (xfree, symbol_table);

  number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);

  for (i = 0; i < number_of_symbols; i++)
    {
      asymbol *sym = symbol_table[i];

      if ((sym->flags & BSF_GLOBAL)
          && sym->name != NULL && strcmp (sym->name, "__dbx_link") == 0)
        return (sym->value + sym->section->vma);
    }

  /* Symbol not found, return NULL.  */
  return 0;
}

/* Search the symbol table of the file referenced by FD for a symbol
   named __dbx_link(). If found, then insert a breakpoint at this location,
   and return nonzero.  Return zero otherwise.  */

static int
insert_dbx_link_bpt_in_file (int fd, CORE_ADDR ignored)
{
  bfd *abfd;
  long storage_needed;
  CORE_ADDR sym_addr;

  abfd = bfd_fdopenr ("unamed", 0, fd);
  if (abfd == NULL)
    {
      warning (_("Failed to create a bfd: %s."), bfd_errmsg (bfd_get_error ()));
      return 0;
    }

  if (!bfd_check_format (abfd, bfd_object))
    {
      /* Not the correct format, so we can not possibly find the dbx_link
         symbol in it.  */
      bfd_close (abfd);
      return 0;
    }

  sym_addr = dbx_link_addr (abfd);
  if (sym_addr != 0)
    {
      /* Insert the breakpoint.  */
      dbx_link_bpt_addr = sym_addr;
      dbx_link_bpt = deprecated_insert_raw_breakpoint (target_gdbarch, NULL,
						       sym_addr);
      if (dbx_link_bpt == NULL)
        {
          warning (_("Failed to insert dbx_link breakpoint."));
          bfd_close (abfd);
          return 0;
        }
      bfd_close (abfd);
      return 1;
    }

  bfd_close (abfd);
  return 0;
} 

/* If the given memory region MAP contains a symbol named __dbx_link,
   insert a breakpoint at this location and return nonzero.  Return
   zero otherwise.  */

static int
insert_dbx_link_bpt_in_region (struct prmap *map,
                               int (*child_func) (),
                               void *data)
{     
  procinfo *pi = (procinfo *) data;
        
  /* We know the symbol we're looking for is in a text region, so
     only look for it if the region is a text one.  */
  if (map->pr_mflags & MA_EXEC)
    return solib_mappings_callback (map, insert_dbx_link_bpt_in_file, pi);
 
  return 0;
}           

/* Search all memory regions for a symbol named __dbx_link.  If found,
   insert a breakpoint at its location, and return nonzero.  Return zero
   otherwise.  */

static int
insert_dbx_link_breakpoint (procinfo *pi)
{
  return iterate_over_mappings (pi, NULL, pi, insert_dbx_link_bpt_in_region);
}

@


1.124
log
@Breakpoint in shared library does not work on mips-irix.

        * procfs.c: #include "observer.h".
        (procfs_inferior_created): New function, moving here the code
        which unsets the syssgi syscall-exit notifications.
        (procfs_create_inferior): Remove the code which unsets the syssgi
        syscall-exit notifications. It is too early to do this here.
        (_initialize_procfs): Attach the procfs_inferior_created observer.
@
text
@d4390 1
a4390 1
      return procfs_xfer_auxv (ops, object, annex, readbuf, writebuf,
@


1.123
log
@-Wunused warning in procfs.c (mips-irix only).

        * procfs.c (gdb_praddset, gdb_prdelset): New macros.  Use them
        throughout instead of using praddset and prdelset respectively.
@
text
@d54 1
d5150 3
d5154 3
d5162 9
a5170 1
     See procfs_init_inferior() for more details.  */
d6018 2
@


1.122
log
@        * procfs.c: (procfs_do_thread_registers) Use elfcore_write_lwpstatus.
@
text
@d273 9
d293 1
a293 1
#define gdb_praddsysset praddset
d300 1
a300 1
#define gdb_prdelsysset prdelset
d2231 1
a2231 1
	  praddset (&temp, signo);
d2265 1
a2265 1
	  prdelset (&temp, signo);
d3503 1
a3503 1
  prdelset  (&traced_faults, FLTPAGE);	/* except page fault.  */
d4654 1
a4654 1
      prdelset (signals, signo);
d4656 1
a4656 1
      praddset (signals, signo);
@


1.121
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d6077 1
a6077 1
#if defined (UNIXWARE)
@


1.120
log
@2009-11-10  Daniel Gutson  <dgutson@@codesourcery.com>

	* procfs.c (procfs_do_thread_registers): Added a call to fetch
	register values before saving them in the core file
	through the gcore command.
	(procfs_corefile_thread_callback): Removed the backup of
	inferior_ptid before calling procfs_do_thread_registers since
	the function already saves and restores it before returning.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008, 2009
@


1.119
log
@	* rs6000-nat.c (exec_one_dummy_insn): Add missing new ASPACE parameter
	to depreacted_insert_raw_breakpoint function call.
	* procfs.c (insert_dbx_link_bpt_in_file): Likewise.
@
text
@d6063 1
d6067 9
d6098 3
d6118 2
a6119 3
      ptid_t saved_ptid = inferior_ptid;
      inferior_ptid = MERGEPID (pi->pid, thread->tid);
      args->note_data = procfs_do_thread_registers (args->obfd, inferior_ptid,
a6122 1
      inferior_ptid = saved_ptid;
@


1.118
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d5669 1
a5669 1
      dbx_link_bpt = deprecated_insert_raw_breakpoint (target_gdbarch,
@


1.117
log
@	* procfs.c (procfs_make_note_section): Go back to only outputing
	an NT_PSTATUS note when UNIXWARE is defined.
@
text
@d3708 2
a3709 1
  inf = add_inferior (pi->pid);
@


1.116
log
@	* procfs.c (procfs_make_note_section): Always output a NT_PSTATUS
	note when NEW_PROC_API is defined.
@
text
@d6156 1
a6156 1
#ifdef NEW_PROC_API
@


1.115
log
@	* procfs.c (proc_set_current_signal): Populate mysinfo before
	copying it to arg.
	(proc_clear_current_signal): Likewise.
	(proc_set_watchpoint): Populate pwatch before copying it to arg.
@
text
@d6129 1
d6154 3
a6156 1
#ifdef UNIXWARE
d6166 1
a6166 1
  thread_args.stop_signal = find_stop_signal ();
@


1.114
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d2508 1
a2508 1
  gdb_siginfo_t *mysinfo;
a2532 1
  mysinfo = (gdb_siginfo_t *) &arg.sinfo;
d2547 1
a2547 1
    memcpy (mysinfo, &pi->prstatus.pr_lwp.pr_info, sizeof (gdb_siginfo_t));
d2549 1
a2549 1
    memcpy (mysinfo, &pi->prstatus.pr_info, sizeof (gdb_siginfo_t));
d2553 5
a2557 4
      mysinfo->si_signo = signo;
      mysinfo->si_code  = 0;
      mysinfo->si_pid   = getpid ();       /* ?why? */
      mysinfo->si_uid   = getuid ();       /* ?why? */
d2600 1
a2600 1
    gdb_siginfo_t *mysinfo;
d2604 6
a2609 6
    mysinfo = (gdb_siginfo_t *) &arg.sinfo;
    mysinfo->si_signo = 0;
    mysinfo->si_code  = 0;
    mysinfo->si_errno = 0;
    mysinfo->si_pid   = getpid ();       /* ?why? */
    mysinfo->si_uid   = getuid ();       /* ?why? */
d2920 1
a2920 1
  prwatch_t *pwatch;
a2921 1
  pwatch            = (prwatch_t *) &arg.watch;
d2926 1
a2926 1
  pwatch->pr_vaddr  = (uintptr_t) procfs_address_to_host_pointer (addr);
d2928 1
a2928 1
  pwatch->pr_vaddr  = (caddr_t) procfs_address_to_host_pointer (addr);
d2930 2
a2931 2
  pwatch->pr_size   = len;
  pwatch->pr_wflags = wflags;
d2934 1
d2938 1
a2938 1
  return (ioctl (pi->ctl_fd, PIOCSWATCH, pwatch) >= 0);
@


1.113
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d165 1
d174 1
a174 1
  *typep = extract_unsigned_integer (ptr, 4);
d178 1
a178 1
  *valp = extract_unsigned_integer (ptr, 8);
@


1.112
log
@	* ada-tasks.c (read_known_tasks_array): Use target_gdbarch instead
	of current_gdbarch.
	* aix-thread.c (pd_enable): Likewise.
	* amd64-linux-nat.c (ps_get_thread_area): Likewise.
	* bsd-uthread.c (bsd_uthread_activate): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* linux-thread-db.c (enable_thread_event): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory): Likewise.
	* nto-procfs.c (procfs_open): Likewise.
	* procfs.c (invalidate_cache, procfs_insert_watchpoint,
	info_proc_mappings, info_mappings_callback): Likewise.
	* record.c (record_open): Likewise.
	* rs6000-nat.c (ARCH64): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	(darwin_bfd_open): Likewise.
	* memattr.c (mem_info_command): Likewise.

	* windows-nat.c (win32_resume): Use current regcache architecture
	instead of current_gdbarch.

	* dbug-rom.c (dbug_regname): Remove check against number of
	registers in current_gdbarch.
	* solib-pa64.c (read_dynamic_info): Remove unused variable.
@
text
@d4806 1
a4806 1
      deprecated_remove_raw_breakpoint (dbx_link_bpt);
d5595 1
a5595 1
  if (deprecated_remove_raw_breakpoint (dbx_link_bpt) != 0)
d5667 2
a5668 1
      dbx_link_bpt = deprecated_insert_raw_breakpoint (sym_addr);
@


1.111
log
@2009-06-07  Pedro Alves  <pedro@@codesourcery.com>

	* procfs.h: New.
	* proc-utils.h (procfs_first_available): Don't declare here.
	* sol-thread.c: Include procfs.h instead of sys/procfs.h and
	proc-utils.h.
	* procfs.c: Include procfs.h.
	(procfs_target): Make it public.  Don't register
	procfs_can_use_hw_breakpoint here.
	(proc_set_watchpoint): Check for PCWATCH or PIOCSWATCH being
	defined instead of TARGET_HAS_HARDWARE_WATCHPOINTS.
	(procfs_can_use_hw_breakpoint): Remove check of
	TARGET_HAS_HARDWARE_WATCHPOINTS.
	(procfs_use_watchpoints): Register procfs_can_use_hw_breakpoint
	here.
	(_initialize_procfs): Don't add the procfs target here.

	* i386-sol2-nat.c: Include target.h and procfs.h.
	(_initialize_amd64_sol2_nat): Install the procfs target here,
	customized with watchpoints support.
	* irix5-nat.c: Include target.h.
	(_initialize_core_irix5): Rename to ...
	(_initialize_irix5_nat): ... this.  Install the procfs target
	here, customized with watchpoints support.
	* alpha-nat.c: Include procfs.h.
	(_initialize_core_alpha): Rename to...
	(_initialize_alpha_nat): ... this.  Install the procfs target
	here, customized with watchpoints support.
	* sparc-sol2-nat.c: Include target.h and procfs.h.
	(_initialize_sparc_sol2_nat): New.

	* config/i386/nm-i386sol2.h (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete.
	* config/sparc/nm-sol2.h (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete.
	* config/mips/irix5.mh (NAT_FILE): Delete.
	* config/mips/irix6.mh (NAT_FILE): Delete.
	* config/mips/nm-irix5.h: Delete.

2009-06-07  Pedro Alves  <pedro@@codesourcery.com>

	* gdbint.texinfo (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete all
	references.
@
text
@d4476 1
a4476 1
  if (gdbarch_fp0_regnum (current_gdbarch) >= 0)
d5355 1
a5355 1
      && !gdbarch_have_nonsteppable_watchpoint (current_gdbarch))
d5759 1
a5759 1
  if (gdbarch_addr_bit (current_gdbarch) == 32)
d5790 1
a5790 1
  if (gdbarch_ptr_bit (current_gdbarch) == 32)
@


1.110
log
@	* inferior.h (proc_iterate_over_mappings): Delete declaration.
	* nto-tdep.h (proc_iterate_over_mappings): Delete declaration.
	* procfs.c (proc_iterate_over_mappings): Delete.
@
text
@d53 1
d185 1
a185 1
static struct target_ops *
a215 1
  t->to_can_use_hw_breakpoint = procfs_can_use_hw_breakpoint;
d2905 4
a2908 1
#if !defined (TARGET_HAS_HARDWARE_WATCHPOINTS)
a5299 3
#ifndef TARGET_HAS_HARDWARE_WATCHPOINTS
  return 0;
#else
a5314 1
#endif
d5396 1
a5990 10
  struct target_ops * t;

  t = procfs_target ();

#ifdef TARGET_HAS_HARDWARE_WATCHPOINTS
  procfs_use_watchpoints (t);
#endif

  add_target (t);

@


1.109
log
@	* procfs.c (procfs_wait): Add options parameter.
@
text
@a5526 25
 * Function: proc_iterate_over_mappings
 *
 * Uses the unified "iterate_over_mappings" function
 * to implement the exported interface to solib-svr4.c.
 *
 * Given a pointer to a function, call that function once for every
 * mapped address space in the process.  The callback function
 * receives an open file descriptor for the file corresponding to
 * that mapped address space (if there is one), and the base address
 * of the mapped space.  Quit when the callback function returns a
 * nonzero value, or at teh end of the mappings.
 *
 * Returns: the first non-zero return value of the callback function,
 * or zero.
 */

int
proc_iterate_over_mappings (int (*func) (int, CORE_ADDR))
{
  procinfo *pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);

  return iterate_over_mappings (pi, func, pi, solib_mappings_callback);
}

/*
@


1.108
log
@	* inflow.h (our_process_group): Remove declaration.
	(inferior_process_group): Delete global variable declaration.
	(inferior_process_group): New function declaration.
	* inflow.c: Include observer.h.
	(inferior_ttystate, our_ttystate, tflags_inferior, tflags_ours):
	Delete.
	(struct terminal_info): New struct.
	(our_terminal_info): New global.
	(inferior_process_group): New function.
	(inferior_thisrun_terminal): Extend description comment.
	(gdb_has_a_terminal): Adjust to write to our_terminal_info fields
	instead of globals.
	(terminal_init_inferior_with_pgrp): Adjust to per-inferior
	terminal settings.
	(terminal_inferior): Ditto.
	(terminal_ours_1): Ditto.
	(inflow_new_inferior, inflow_inferior_exit): New functions.
	(child_terminal_info): Adjust to per-inferior terminal settings.
	(osig_set): New global.
	(set_sigint_trap): Adjust to per-inferior terminal settings.  Set
	or clear `osig_set' accordingly.
	(clear_sigint_trap): Check `osig_set' to decide wheater to restore
	SIGINT handler, instead of checking the current inferior (which
	may be none).
	(_initialize_inflow): Attach inflow_new_inferior and
	inflow_inferior_exit to the "new_inferior" and "inferior_exit"
	notifications, respectively.
	* inferior.h (struct terminal_info): Forward declare.
	(struct inferior): Add `terminal_info' field.
	* inferior.c (delete_inferior_1): Notify the inferior_exit
	observers before removing the inferior from the lists and deleting
	it.
	* inf-ptrace.c (inf_ptrace_stop): `inferior_process_group' is now
	a function instead of a variable.  Adjust.
	* procfs.c (procfs_stop): Ditto.
@
text
@d131 1
a131 1
			   ptid_t, struct target_waitstatus *);
d3950 1
a3950 1
	     ptid_t ptid, struct target_waitstatus *status)
@


1.107
log
@	Unify target macros.

	* target.h (STOPPED_BY_WATCHPOINT): Delete, replaced by ...
	(target_stoppped_by_watchpoint): New macro.
	(HAVE_STEPPABLE_WATCHPOINT): Delete, replaced by ...
	(target_have_steppable_watchpoint): New macro.
	(HAVE_CONTINUABLE_WATCHPOINT): Delete, replace by ...
	(target_have_continuable_watchpoint): New macro.
	(TARGET_CAN_USE_HARDWARE_WATCHPOINT):Delete, replaced by ...
	(target_can_use_hardware_watchpoint): New macro.
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT):Delete, replaced by ...
	(target_region_ok_for_hw_watchpoint): New macro.

	* breakpoint.c (update_watchpoint): Use new macros.
	(bpstat_alloc): Likewise.
	(create_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(can_use_hardware_watchpoint): Likewise.
	(do_enable_breakpoint): Likewise.
	* infrun.c (handle_inferior_event): Adapt to new macros.
	* mips-tdep.c (mips_gdbarch_init): Update comments.
	* procfs.c (procfs_set_watchpoint): Update comment.
	(procfs_insert_watchpoint): Adapt to new macros.
	* remote-m32r-sdi.c (m32r_stop):
	* remote-mips.c (mips_remove_breakpoint):
	* target.c (debug_to_region_ok_for_hw_watchpoint): Update to new macros.
	(debug_to_stopped_by_watchpoint): Likewise.
@
text
@d4693 1
a4693 1
  kill (-inferior_process_group, SIGINT);
@


1.106
log
@	* procfs.c (procfs_insert_watchpoint, procfs_remove_watchpoint)
	(procfs_region_ok_for_hw_watchpoint, procfs_use_watchpoints): New
	functions.
	(procfs_stopped_by_watchpoint): Made static, ptid argument
	removed.
	(_initialize_procfs): Register new watchpoint related target
	functions.
	* config/i386/nm-i386sol2.h (TARGET_CAN_USE_HARDWARE_WATCHPOINT)
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT, STOPPED_BY_WATCHPOINT)
	(HAVE_CONTINUABLE_WATCHPOINT): Delete.
	(target_insert_watchpoint, target_remove_watchpoint): Delete.
	(procfs_stopped_by_watchpoint, procfs_set_watchpoint): Delete
	declarations.
	* config/mips/nm-irix5.h (STOPPED_BY_WATCHPOINT)
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	(target_insert_watchpoint, target_remove_watchpoint): Delete.
	(procfs_stopped_by_watchpoint, procfs_set_watchpoint): Delete
	declarations.
	* config/sparc/nm-sol2.h (TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT)
	(HAVE_CONTINUABLE_WATCHPOINT, STOPPED_BY_WATCHPOINT): Delete.
	(target_insert_watchpoint, target_remove_watchpoint): Delete.
	(procfs_stopped_by_watchpoint, procfs_set_watchpoint): Delete
	declarations.
@
text
@d5292 1
a5292 1
   TARGET_CAN_USE_HARDWARE_WATCHPOINT.  */
d5355 1
a5355 1
  if (!HAVE_STEPPABLE_WATCHPOINT
@


1.105
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d5325 2
a5326 2
int
procfs_stopped_by_watchpoint (ptid_t ptid)
d5330 1
a5330 2
  pi = find_procinfo_or_die (PIDGET (ptid) == -1 ?
			     PIDGET (inferior_ptid) : PIDGET (ptid), 0);
d5352 47
d6020 4
@


1.104
log
@Undo the following change. Not correct, after all:

        * procfs.c (solib_mappings_callback, find_memory_regions_callback):
        Fix a compilation warning on mips-irix due to casting from
        a pointer of different size.
@
text
@d4281 2
a4282 1
                      && dbx_link_bpt_addr == read_pc ())
@


1.103
log
@        * procfs.c (solib_mappings_callback, find_memory_regions_callback):
        Fix a compilation warning on mips-irix due to casting from
        a pointer of different size.
@
text
@d5476 1
a5476 1
  return (*func) (fd, (CORE_ADDR) (uintptr_t) map->pr_vaddr);
d5527 1
a5527 1
  return (*func) ((CORE_ADDR) (uintptr_t) map->pr_vaddr,
@


1.102
log
@        Add a target_ops parameter to the to_kill method in struct target_ops.

        * target.h (struct target_ops): Add a "target_ops *" parameter to
        method to_kill.
        (target_kill): Remove macro. Add declaration.
        * target.c (debug_to_kill): Delete, no longer necessary.
        (target_kill): New function.
        (update_current_target):  Stop inheriting the to_kill method.
        Do not de_fault it to no_process either.
        (setup_target_debug): Do not set current_target.to_kill.
        * gnu-nat.c, go32-nat.c, hpux-thread.c, inf-ptrace.c, inf-ttrace.c,
        linux-nat.c, monitor.c, nto-procfs.c, procfs.c, remote-m32r-sdi.c,
        remote-mips.c, remote-sim.c, remote.c, windows-nat.c: Update
        accordingly.
@
text
@d5476 1
a5476 1
  return (*func) (fd, (CORE_ADDR) map->pr_vaddr);
d5527 1
a5527 1
  return (*func) ((CORE_ADDR) map->pr_vaddr,
@


1.101
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d126 1
a126 1
static void procfs_kill_inferior (void);
d4767 1
a4767 1
procfs_kill_inferior (void)
@


1.100
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@d32 1
a114 1
static void procfs_open (char *, int);
d117 2
a118 2
static void procfs_resume (ptid_t, int, enum target_signal);
static int procfs_can_run (void);
d121 4
a124 2
static void procfs_fetch_registers (struct regcache *, int);
static void procfs_store_registers (struct regcache *, int);
a125 1
static void procfs_prepare_to_store (struct regcache *);
d141 1
a141 1
static int procfs_thread_alive (ptid_t);
d143 1
a143 1
void procfs_find_new_threads (void);
a155 2
struct target_ops procfs_ops;		/* the target vector */

d184 2
a185 2
static void
init_procfs_ops (void)
d187 5
a191 3
  procfs_ops.to_shortname           = "procfs";
  procfs_ops.to_longname            = "Unix /proc child process";
  procfs_ops.to_doc                 =
d193 23
a215 41
  procfs_ops.to_open                = procfs_open;
  procfs_ops.to_can_run             = procfs_can_run;
  procfs_ops.to_create_inferior     = procfs_create_inferior;
  procfs_ops.to_kill                = procfs_kill_inferior;
  procfs_ops.to_mourn_inferior      = procfs_mourn_inferior;
  procfs_ops.to_attach              = procfs_attach;
  procfs_ops.to_detach              = procfs_detach;
  procfs_ops.to_wait                = procfs_wait;
  procfs_ops.to_resume              = procfs_resume;
  procfs_ops.to_prepare_to_store    = procfs_prepare_to_store;
  procfs_ops.to_fetch_registers     = procfs_fetch_registers;
  procfs_ops.to_store_registers     = procfs_store_registers;
  procfs_ops.to_xfer_partial        = procfs_xfer_partial;
  procfs_ops.deprecated_xfer_memory = procfs_xfer_memory;
  procfs_ops.to_insert_breakpoint   =  memory_insert_breakpoint;
  procfs_ops.to_remove_breakpoint   =  memory_remove_breakpoint;
  procfs_ops.to_notice_signals      = procfs_notice_signals;
  procfs_ops.to_files_info          = procfs_files_info;
  procfs_ops.to_stop                = procfs_stop;

  procfs_ops.to_terminal_init       = terminal_init_inferior;
  procfs_ops.to_terminal_inferior   = terminal_inferior;
  procfs_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  procfs_ops.to_terminal_ours       = terminal_ours;
  procfs_ops.to_terminal_save_ours  = terminal_save_ours;
  procfs_ops.to_terminal_info       = child_terminal_info;

  procfs_ops.to_find_new_threads    = procfs_find_new_threads;
  procfs_ops.to_thread_alive        = procfs_thread_alive;
  procfs_ops.to_pid_to_str          = procfs_pid_to_str;

  procfs_ops.to_has_all_memory      = 1;
  procfs_ops.to_has_memory          = 1;
  procfs_ops.to_has_execution       = 1;
  procfs_ops.to_has_stack           = 1;
  procfs_ops.to_has_registers       = 1;
  procfs_ops.to_stratum             = process_stratum;
  procfs_ops.to_has_thread_control  = tc_schedlock;
  procfs_ops.to_find_memory_regions = proc_find_memory_regions;
  procfs_ops.to_make_corefile_notes = procfs_make_note_section;
  procfs_ops.to_can_use_hw_breakpoint = procfs_can_use_hw_breakpoint;
d218 1
a218 1
  procfs_ops.to_auxv_parse = procfs_auxv_parse;
d221 3
a223 1
  procfs_ops.to_magic               = OPS_MAGIC;
d3618 1
a3618 1
  push_target (&procfs_ops);
d3647 1
a3647 1
  unpush_target (&procfs_ops);
d3778 2
a3779 1
procfs_fetch_registers (struct regcache *regcache, int regnum)
a3815 11
/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On
   machines which store all the registers in one fell swoop, such as
   /proc, this makes sure that registers contains all the registers
   from the program being debugged.  */

static void
procfs_prepare_to_store (struct regcache *regcache)
{
}

d3827 2
a3828 1
procfs_store_registers (struct regcache *regcache, int regnum)
d4543 2
a4544 1
procfs_resume (ptid_t ptid, int step, enum target_signal signo)
a4680 38
 * Function: target_open
 *
 * A dummy: you don't open procfs.
 */

static void
procfs_open (char *args, int from_tty)
{
  error (_("Use the \"run\" command to start a Unix child process."));
}

/*
 * Function: target_can_run
 *
 * This tells GDB that this target vector can be invoked
 * for "run" or "attach".
 */

int procfs_suppress_run = 0;	/* Non-zero if procfs should pretend not to
				   be a runnable target.  Used by targets
				   that can sit atop procfs, such as solaris
				   thread support.  */


static int
procfs_can_run (void)
{
  /* This variable is controlled by modules that sit atop procfs that
     may layer their own process structure atop that provided here.
     sol-thread.c does this because of the Solaris two-level thread
     model.  */

  /* NOTE: possibly obsolete -- use the thread_stratum approach instead. */

  return !procfs_suppress_run;
}

/*
d4798 1
a4798 1
  unpush_target (&procfs_ops);
d4820 1
a4820 1
procfs_init_inferior (int pid)
d4829 1
a4829 2

  push_target (&procfs_ops);
d5060 2
d5130 4
a5133 2
  fork_inferior (exec_file, allargs, env, procfs_set_exec_trap,
		 procfs_init_inferior, NULL, shell_file);
d5172 1
a5172 1
procfs_find_new_threads (void)
d5192 1
a5192 1
procfs_thread_alive (ptid_t ptid)
d5969 6
a5974 2
  init_procfs_ops ();
  add_target (&procfs_ops);
@


1.99
log
@	* gdb/procfs.c (info_mappings_callback): Cast map->pr_size to
	unsigned long.
@
text
@d129 2
a130 1
static ptid_t procfs_wait (ptid_t, struct target_waitstatus *);
d143 1
a143 1
char *procfs_pid_to_str (ptid_t);
d3973 2
a3974 1
procfs_wait (ptid_t ptid, struct target_waitstatus *status)
d5275 1
a5275 1
procfs_pid_to_str (ptid_t ptid)
@


1.98
log
@        Updated copyright notices for most files.
@
text
@d5794 1
a5794 1
    printf_filtered ("\t%#10lx %#10lx %#10x %#10x %7s\n",
d5797 1
a5797 1
		     map->pr_size,
d5801 1
a5801 1
    printf_filtered ("  %#18lx %#18lx %#10x %#10x %7s\n",
d5804 1
a5804 1
		     map->pr_size,
@


1.97
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008
@


1.96
log
@2008-10-09  Pedro Alves  <pedro@@codesourcery.com>

	Make it compile without warnings.

	* procfs.c (create_procinfo): Initialize `parent'.
	(dead_procinfo): Pass a constant string as format to error.
	(procfs_address_to_host_pointer): Add cast to gdb_type *.
	(procfs_find_LDT_entry): Adjust format string to long int
	ptid.tid.
	(procfs_xfer_partial): Adjust prototype.  Add gdb_byte* cast.
	(procfs_xfer_memory): Adjust prototype.
	(info_mappings_callback, info_proc_mappings): Adjust to not pass a
	variable as printf_filtered format.
	(procfs_make_note_section): Change type of auxv local to gdb_byte.
	* Makefile.in: Remove special rule.
@
text
@d115 2
a116 2
static void procfs_attach (char *, int);
static void procfs_detach (char *, int);
d126 3
a128 2
static void procfs_mourn_inferior (void);
static void procfs_create_inferior (char *, char *, char **, int);
d3606 1
a3606 1
procfs_attach (char *args, int from_tty)
d3636 1
a3636 1
procfs_detach (char *args, int from_tty)
d4846 1
a4846 1
procfs_mourn_inferior (void)
d5115 2
a5116 2
procfs_create_inferior (char *exec_file, char *allargs, char **env,
			int from_tty)
@


1.95
log
@2008-10-03  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* utils.c, defs.h (gdb_buildargv): New fn. Wrap buildargv
	and check for out-of-memory condition.
	* exec.c (exec_file_command): Call it.
	* infrun.c (handle_command, xdb_handle_command): Likewise.
	* interps.c (interpreter_exec_cmd): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* procfs.c (info_proc_cmd): Likewise.
	* remote-mips.c (common_open): Likewise.
	* remote-sim.c (gdbsim_kill, gdbsim_create_inferior)
	(gdbsim_open): Likewise.
	* remote.c (extended_remote_run, remote_put_command)
	(remote_get_command, remote_delete_command): Likewise.
	* ser-mingw.c (pipe_windows_open): Likesise.
	* source.c (add_path, show_substitute_path_command)
	(unset_substitute_path_command, set_substitute_path_command):
	Likewise.
	* stack.c (backtrace_command): Likewise.
	* symfile.c (symbol_file_command, generic_load)
	(add_symbol_file_command): Likesise.
	* symmisc.c (maintenance_print_symbols, maintenance_print_psymbols)
	(maintenance_print_msymbols): Likewise.
@
text
@d129 1
a129 1
static int procfs_xfer_memory (CORE_ADDR, char *, int, int,
d135 1
a135 1
				    void *readbuf, const void *writebuf,
d718 1
a718 1
  procinfo *pi, *parent;
d869 1
a869 1
  error ((msg));
d2905 2
a2906 1
  gdbarch_address_to_pointer (target_gdbarch, ptr_type, &ptr, addr);
d3068 1
a3068 1
      warning (_("procfs_find_LDT_entry: could not find procinfo for %d:%d."),
d3075 1
a3075 1
      warning (_("procfs_find_LDT_entry: could not read gregs for %d:%d."),
d4379 2
a4380 2
		     const char *annex, void *readbuf,
		     const void *writebuf, ULONGEST offset, LONGEST len)
d4386 2
a4387 2
	return (*ops->deprecated_xfer_memory) (offset, readbuf, len,
					       0/*read*/, NULL, ops);
d4389 2
a4390 2
	return (*ops->deprecated_xfer_memory) (offset, writebuf, len,
					       1/*write*/, NULL, ops);
d4419 1
a4419 1
procfs_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int dowrite,
d5784 1
a5784 1
  char *data_fmt_string;
a5785 9
  if (gdbarch_addr_bit (current_gdbarch) == 32)
    data_fmt_string   = "\t%#10lx %#10lx %#10x %#10x %7s\n";
  else
    data_fmt_string   = "  %#18lx %#18lx %#10x %#10x %7s\n";

  printf_filtered (data_fmt_string,
		   (unsigned long) map->pr_vaddr,
		   (unsigned long) map->pr_vaddr + map->pr_size - 1,
		   map->pr_size,
d5787 1
a5787 1
		   (unsigned int) map->pr_offset,
d5789 1
a5789 1
		   map->pr_off,
d5791 15
a5805 1
		   mappingflags (map->pr_mflags));
a5818 7
  char *header_fmt_string;

  if (gdbarch_ptr_bit (current_gdbarch) == 32)
    header_fmt_string = "\t%10s %10s %10s %10s %7s\n";
  else
    header_fmt_string = "  %18s %18s %10s %10s %7s\n";

d5823 14
a5836 6
  printf_filtered (header_fmt_string,
		   "Start Addr",
		   "  End Addr",
		   "      Size",
		   "    Offset",
		   "Flags");
d6160 1
a6160 1
  char *auxv;
@


1.94
log
@	Remove the attach_flag global, and make it per-inferior.

	* inferior.h (attach_flag): Delete.
	(inferior_process): Declare.
	* solib.c (update_solib_list): Adjust.
	* gnu-nat.c (gnu_create_inferior, gnu_attach): Adjust.
	* inf-ptrace.c (inf_ptrace_detach): Adjust.
	(inf_ptrace_files_info): Get it from the current inferior.
	* inf-ttrace.c (inf_ttrace_attach): Adjust.
	(inf_ttrace_files_info): Get it from the current
	inferior.
	* inflow.c (terminal_inferior, terminal_ours_1, set_sigint_trap)
	(clear_sigint_trap): Get it from the current process.
	* remote.c (extended_remote_attach_1)
	(extended_remote_create_inferior_1): Adjust.
	* top.c (quit_confirm, quit_target): Get it from the current inferior.
	* procfs.c (do_detach): Adjust.
	(procfs_wait): Get it from the event inferior.
	(procfs_files_info): Get it from the current inferior.
	* nto-procfs.c (procfs_files_info): Likewise.
	(procfs_attach): Adjust.  Set the attach_flag here.
	(do_attach): Don't set it here.
	(procfs_detach): Don't clear it.
	(procfs_mourn_inferior): Don't clear it.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* target.c (attach_flag): Delete.
	(generic_mourn_inferior): Don't clear it.
	* win32-nat.c (get_win32_debug_event): Get it from the event
	process.
	(do_initial_win32_stuff): Add attaching argument.  Set attach_flag
	in the inferior accordingly.
	(win32_attach): Don't set the attach_flag here.  Pass 1 to
	do_intial_win32_stuff.
	(win32_files_info): Get it from the current inferior.
	(win32_create_inferior): Dont clear attach_flag here.  Pass 0 to
	do_intial_win32_stuff.
@
text
@d5856 2
a5857 4
      if ((argv = buildargv (args)) == NULL)
	nomem (0);
      else
	make_cleanup_freeargv (argv);
@


1.93
log
@	* gnu-nat.c (gnu_attach): Add process to inferiors table.
	(gnu_detach): Remove it.
	* go32-nat.c (go32_create_inferior): Add process to gdb's inferior
	table.
	* inf-ptrace.c (inf_ptrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ptrace_attach): Add new process to inferior table.
	(inf_ptrace_detach): Remove it.
	* inf-ttrace.c (inf_ttrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ttrace_attach): Add process to inferior table.
	(inf_ttrace_detach): Remove it.
	* linux-fork.c (init_fork_list): Delete any left over inferior.
	(linux_fork_mourn_inferior, detach_fork_command): Also delete
	processes from inferior list.
	* monitor.c (monitor_open): Add process to inferior list.
	(monitor_close): Remove it.
	* nto-procfs.c (procfs_attach): Add process to inferior list.
	Find threads after pushing the target.
	(procfs_detach): Remove process from inferior list.
	(procfs_create_inferior): Add process to inferior list.
	* procfs.c (procfs_detach): Remove process from inferior list.
	(do_attach): Add process to inferior list.
	* remote-sim.c (sim_create_inferior): Add process to inferior list.
	(gdbsim_close): Remove it.
	* target.c (generic_mourn_inferior): If inferior_ptid is not
	null_ptid, remove the corresponding inferior from inferior list.
	* win32-nat.c (do_initial_win32_stuff): Add process to inferior list.
	(win32_detach): Remove it.
	* linux-nat.c (linux_child_follow_fork): Delete and add inferiors
	to inferior list accordingly.
	* fork-child.c (fork_inferior): Add process to inferior list.
	* corelow.c (CORELOW_PID): Define.
	(core_close): Remove core from inferior list.
	(core_open): Add it.
@
text
@d3666 1
d3716 1
a3716 1
  add_inferior (pi->pid);
d3718 1
a3718 1
  attach_flag = 1;
a3771 1
  attach_flag = 0;
d4077 2
d4092 3
a4094 1
		    if (attach_flag)
d4693 1
d4695 1
a4695 1
		   attach_flag? "attached": "child",
@


1.92
log
@	* procfs.c (procfs_address_to_host_pointer): Use target_gdbarch
	and its associated types to perform pointer conversion.
	(procfs_can_use_hw_breakpoint): Likewise.
	(procfs_auxv_parse): Remove unused variable.
@
text
@d3637 1
a3643 1
      int pid = PIDGET (inferior_ptid);
d3658 1
d3715 1
@


1.91
log
@	Remove the global stop_signal in favour of a per-thread
	stop_signal.

	* inferior.h (stop_signal): Delete.
	* gdbthread.h (save_infrun_state, load_infrun_state): Remove
	stop_signal argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_signal argument.  Don't reference it.

	* infcmd.c (stop_signal): Delete.
	(program_info): Adjust.
	* infrun.c (resume): Clear stop_signal.
	(proceed): Adjust.  Pass the last stop_signal to the thread we're
	resuming.
	(context_switch): Don't context-switch stop_signal.
	(handle_inferior_event, keep_going): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* fbsd-nat.c: Include "gdbthread.h".
	(find_signalled_thread, find_stop_signal): New.
	(fbsd_make_corefile_notes): Use it.
	* fork-child.c (startup_inferior): Adjust.

	* linux-nat.c (get_pending_status): Adjust.
	(linux_nat_do_thread_registers): Adjust.
	(find_signalled_thread, find_stop_signal): New.
	(linux_nat_do_thread_registers): Add stop_signal parameter.
	(struct linux_nat_corefile_thread_data): Add stop_signal member.
	(linux_nat_corefile_thread_callback): Pass stop_signal.
	(linux_nat_do_registers): Delete.
	(linux_nat_make_corefile_notes): Use find_stop_signal.  Assume
	there's always a thread.

	* procfs.c (find_signalled_thread, find_stop_signal): New.
	(find_stop_signal): New.
	(procfs_do_thread_registers): Add stop_signal parameter.
	(struct procfs_corefile_thread_data): Add stop_signal member.
	(procfs_corefile_thread_callback): Pass args->stop_signal.
	(procfs_make_note_section): Find the last stop_signal.

	* solib-irix.c: Include gdbthread.h.
	(irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c: Include gdbthread.h.
	(osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c: Include gdbthread.h.
	(sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c: Include gdbthread.h.
	(svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.
@
text
@a162 1
  const int pointer_size = TYPE_LENGTH (builtin_type_void_data_ptr);
d2901 1
d2904 2
a2905 3
  gdb_assert (sizeof (ptr) == TYPE_LENGTH (builtin_type_void_data_ptr));
  gdbarch_address_to_pointer (current_gdbarch, builtin_type_void_data_ptr,
			      &ptr, addr);
d5354 2
a5355 1
  if (sizeof (void *) != TYPE_LENGTH (builtin_type_void_data_ptr))
@


1.90
log
@	* procfs.c (to_attach): Create a procinfo for the current lwp.
	Add it to gdb's thread list.
	(procfs_fetch_registers, procfs_store_registers): Assume there's
	always an lwp.
	(procfs_wait): Don't add the main thread here.
	(procfs_init_inferior): Create a procinfo for the main lwp here.
	Change main thread's ptid with thread_change_ptid.
	(procfs_notice_thread): Check for exited threads.
	(procfs_corefile_thread_callback): Remove check for the main
	process.
	(procfs_make_note_section): Assume there is always a thread.

	* sol-thread.c (sol_thread_attach): Clear sol_thread_active before
	attaching.  Change the main thread ptid with thread_change_ptid.
	(sol_thread_detach): Clear sol_thread_active.
	(sol_thread_wait): Check for exited threads.
	(sol_thread_create_inferior): Clear sol_thread_active before
	creating a new inferior.  Change the main thread ptid with
	thread_change_ptid.
	(sol_thread_mourn_inferior): Clear sol_thread_active.
	(sol_find_new_threads_callback): Check for exited threads.
@
text
@d6048 22
d6076 2
a6077 1
			    char *note_data, int *note_size)
d6115 1
d6129 2
a6130 1
						    args->note_size);
d6184 1
@


1.89
log
@	Adjust all targets to new target_stop interface.

	* gnu-nat.c (gnu_stop): Add ptid argument.
	* go32-nat.c (go32_stop): Add ptid argument.
	(go32_create_inferior): Pass inferior_ptid to go32_stop.
	* hpux-thread.c (hpux_thread_stop): Add ptid argument.
	* monitor.c (monitor_stop): Add ptid argument.
	(monitor_open): Pass inferior_ptid to monitor_stop.
	(monitor_interrupt): Pass inferior_ptid to target_stop.
	(monitor_stop): Add ptid argument.
	* nto-procfs.c (nto_interrupt): Pass inferior_ptid to target_stop.
	(procfs_create_inferior): Add ptid argument.
	* procfs.c (procfs_stop): Add ptid argument.
	* remote-m32r-sdi.c (m32r_stop): Add ptid argument.
	* remote-sim.c (gdbsim_stop): Add ptid argument.
	* sol-thread.c (sol_thread_stop): Add ptid argument.
	* win32-nat.c (win32_stop): Add ptid argument.
@
text
@d3667 1
d3717 10
a3726 1
  return MERGEPID (pi->pid, proc_get_current_thread (pi));
d3797 1
a3797 8
  /* First look up procinfo for the main process.  */
  pi = find_procinfo_or_die (pid, 0);

  /* If the event thread is not the same as GDB's requested thread
     (ie. inferior_ptid), then look up procinfo for the requested
     thread.  */
  if (tid != 0 && tid != proc_get_current_thread (pi))
    pi = find_procinfo_or_die (pid, tid);
d3856 1
a3856 8
  /* First find procinfo for main process.  */
  pi = find_procinfo_or_die (pid, 0);

  /* If the event thread is not the same as GDB's requested thread
     (ie. inferior_ptid), then look up procinfo for the requested
     thread.  */
  if (tid != 0 && tid != proc_get_current_thread (pi))
    pi = find_procinfo_or_die (pid, tid);
a4348 14

		  /* In addition, it's possible that this is the first
		   * new thread we've seen, in which case we may not
		   * have created entries for inferior_ptid yet.
		   */
		  if (TIDGET (inferior_ptid) != 0)
		    {
		      if (!in_thread_list (inferior_ptid))
			add_thread (inferior_ptid);
		      if (find_procinfo (PIDGET (inferior_ptid),
					 TIDGET (inferior_ptid)) == NULL)
			create_procinfo (PIDGET (inferior_ptid),
					 TIDGET (inferior_ptid));
		    }
d4876 1
d4937 11
a4947 3
  /* The 'process ID' we return to GDB is composed of
     the actual process ID plus the lwp ID. */
  inferior_ptid = MERGEPID (pi->pid, proc_get_current_thread (pi));
d5206 1
a5206 1
  if (!in_thread_list (gdb_threadid))
d6099 1
a6099 1
  if (pi != NULL && thread->tid != 0)
d6161 3
a6163 11
  if (thread_args.note_data == note_data)
    {
      /* iterate_over_threads didn't come up with any threads;
	 just use inferior_ptid. */
      note_data = procfs_do_thread_registers (obfd, inferior_ptid,
					      note_data, note_size);
    }
  else
    {
      note_data = thread_args.note_data;
    }
@


1.88
log
@        Fix auxv data parsing on 64-bit solaris
	* target.h (struct target_ops): New field to_auxv_parse.
	* auxv.c (default_auxv_parse): New, renamed from previous
	target_auxv_parse.
	(target_auxv_parse): Try to call target method.  Fallback to
	default_auxv_parse if not found.
	* procfs.c (procfs_auxv_parse): New.
	(init_procfs_ops): On Solaris, in 64-bit mode, install
	procfs_auxv_parse.
@
text
@d119 1
a119 1
static void procfs_stop (void);
d4759 1
a4759 1
procfs_stop (void)
@


1.87
log
@2008-03-21  Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdbthread.h (add_thread_with_info): New.
	* linux-thread-db.c: Add some documentation.
	(GET_LWP, GET_PID, GET_THREAD, is_lwp, is_thread, BUILD_LWP): Delete.
	(struct private_thread_info): Remove th_valid and ti_valid.
	Replace ti with tid.
	(thread_get_info_callback): Do not add TID to the new ptid.  Do
	not cache th or ti.
	(thread_db_map_id2thr, lwp_from_thread): Delete functions.
	(thread_from_lwp): Assert that the LWP is set.  Do not add TID to the
	new PTID.
	(attach_thread): Handle an already-existing thread.  Use
	add_thread_with_info.  Cache the th and tid.
	(detach_thread): Verify that private was set.  Remove verbose
	argument and printing.  Update caller.
	(thread_db_detach): Do not adjust inferior_ptid.
	(clear_lwpid_callback, thread_db_resume, thread_db_kill): Delete.
	(check_event, find_new_threads_callback): Do not add TID to the new PTID.
	(thread_db_wait): Do not use lwp_from_thread.
	(thread_db_pid_to_str): Use the cached TID.
	(thread_db_extra_thread_info): Check that private is set.
	(same_ptid_callback): Delete.
	(thread_db_get_thread_local_address): Do not use it or check
	is_thread.  Check that private is set.  Assume that the thread
	handle is already cached.
	(init_thread_db_ops): Remove to_resume and to_kill.
	* thread.c (add_thread_with_info): New.
	(add_thread): Use it.
	* linux-nat.c (find_thread_from_lwp): Delete.
	(exit_lwp): Do not use it.  Check print_thread_events.  Print before
	deleting the thread.
	(GET_PID, GET_LWP, BUILD_LWP, is_lwp): Move to...
	* linux-nat.h (GET_PID, GET_LWP, BUILD_LWP, is_lwp): ...here.
	* inf-ttrace.c (inf_ttrace_wait): Use print_thread_events and
	printf_unfiltered for thread exits.
	* procfs.c (procfs_wait): Likewise.

2008-03-21  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.threads/fork-child-threads.exp: Test next over fork.
@
text
@d155 29
d232 5
@


1.86
log
@        * sol-thread.c: Replace use of TM_I386SOL2_H by an expression
        that is true only on x86-solaris and x86_64-solaris.
        * procfs.c: Likewise. Move procfs_find_LDT_entry up together
        with proc_get_LDT_entry.
@
text
@d4037 3
a4039 2
		    printf_filtered (_("[%s exited]\n"),
				     target_pid_to_str (retval));
d4169 3
a4171 2
		    printf_filtered (_("[%s exited]\n"),
				     target_pid_to_str (retval));
@


1.85
log
@2008-01-24  Michael Snyder  <msnyder@@specifix.com>

	* procfs.c (procfs_xfer_partial): Comment, cut/paste error.
	* win32-nat.c (win32_xfer_partial): Ditto.
	* target.c (default_xfer_partial): Minor whitespace adjustment.
@
text
@d2922 1
a2922 1
#ifdef TM_I386SOL2_H		/* Is it hokey to use this? */
d3014 39
a3052 1
#endif /* TM_I386SOL2_H */
a5371 40
#ifdef TM_I386SOL2_H
/*
 * Function: procfs_find_LDT_entry
 *
 * Input:
 *   ptid_t ptid;	// The GDB-style pid-plus-LWP.
 *
 * Return:
 *   pointer to the corresponding LDT entry.
 */

struct ssd *
procfs_find_LDT_entry (ptid_t ptid)
{
  gdb_gregset_t *gregs;
  int            key;
  procinfo      *pi;

  /* Find procinfo for the lwp. */
  if ((pi = find_procinfo (PIDGET (ptid), TIDGET (ptid))) == NULL)
    {
      warning (_("procfs_find_LDT_entry: could not find procinfo for %d:%d."),
	       PIDGET (ptid), TIDGET (ptid));
      return NULL;
    }
  /* get its general registers. */
  if ((gregs = proc_get_gregs (pi)) == NULL)
    {
      warning (_("procfs_find_LDT_entry: could not read gregs for %d:%d."),
	       PIDGET (ptid), TIDGET (ptid));
      return NULL;
    }
  /* Now extract the GS register's lower 16 bits. */
  key = (*gregs)[GS] & 0xffff;

  /* Find the matching entry and return it. */
  return proc_get_LDT_entry (pi, key);
}
#endif /* TM_I386SOL2_H */

@


1.85.2.1
log
@        * sol-thread.c: Replace use of TM_I386SOL2_H by an expression
        that is true only on x86-solaris and x86_64-solaris.
        * procfs.c: Likewise. Move procfs_find_LDT_entry up together
        with proc_get_LDT_entry.
@
text
@d2922 1
a2922 1
#if (defined(__i386__) || defined(__x86_64__)) && defined (sun)
d3014 1
a3014 39
/*
 * Function: procfs_find_LDT_entry
 *
 * Input:
 *   ptid_t ptid;	// The GDB-style pid-plus-LWP.
 *
 * Return:
 *   pointer to the corresponding LDT entry.
 */

struct ssd *
procfs_find_LDT_entry (ptid_t ptid)
{
  gdb_gregset_t *gregs;
  int            key;
  procinfo      *pi;

  /* Find procinfo for the lwp. */
  if ((pi = find_procinfo (PIDGET (ptid), TIDGET (ptid))) == NULL)
    {
      warning (_("procfs_find_LDT_entry: could not find procinfo for %d:%d."),
	       PIDGET (ptid), TIDGET (ptid));
      return NULL;
    }
  /* get its general registers. */
  if ((gregs = proc_get_gregs (pi)) == NULL)
    {
      warning (_("procfs_find_LDT_entry: could not read gregs for %d:%d."),
	       PIDGET (ptid), TIDGET (ptid));
      return NULL;
    }
  /* Now extract the GS register's lower 16 bits. */
  key = (*gregs)[GS] & 0xffff;

  /* Find the matching entry and return it. */
  return proc_get_LDT_entry (pi, key);
}

#endif
d5334 40
@


1.84
log
@        Inform about new thread in a single place.

        * thread.c (add_thread_silent): Renamed
        from add_thread.
        (print_thread_events): New variable definition.
        (show_print_thread_events): New function.
        (_initialize_thread): Add "set print thread-events" and
        "show print thread-events" commands.
        (add_thread): Announce new thread.
        * gdbthread.h (add_thread_silent): Declare.
        (print_thread_events): New variable declaration.
        * inf-ttrace.c (inf_ttrace_wait): Don't
        inform about new thread, as add_thread is always
        called too, and will take care of that.
        * infrun.c (handle_inferior_event): Likewise.
        * procfs.c (procfs_wait): Likewise.
        * remote.c (remote_currthread): Likewise.
        * sol-thread.c (sol_thread_wait): Likewise.
        * win32-nat.c (get_win32_debug_event): Likewise.
        * linux-thread-db.c (attach_thread): Likewise.
        Remove the verbose parameter.
        (check_event): Make detach_thread be verbose
        only if print_thread_events is set.
        * linux-nat.c (lin_lwp_attach_lwp): Don't inform
        about new thread.  This is called only from
        linux-thread-db.c:attach_thread, which will take care.
        Remove the verbose parameter.
        * linux-nat.h (lin_lwp_attach_lwp): Adjust prototype.
@
text
@d4325 1
a4325 1
					       0/*write*/, NULL, ops);
@


1.83
log
@	Updated copyright notices for most files.
@
text
@d4122 2
a4123 5
		      {
			printf_filtered (_("[New %s]\n"),
					 target_pid_to_str (temp_ptid));
			add_thread (temp_ptid);
		      }
d4189 1
a4189 5
		      {
			printf_filtered (_("[New %s]\n"),
					 target_pid_to_str (temp_ptid));
			add_thread (temp_ptid);
		      }
a4275 1
		  printf_filtered (_("[New %s]\n"), target_pid_to_str (retval));
@


1.82
log
@2007-12-16  Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac: Check for *-*-solaris2.1[[0-9]]* instead of
	*-*-solaris2.1[[0-9]].
	* configure: Regenerate.
	* procfs.c (proc_set_current_signal): If redelivering a signal,
	reuse the current siginfo if possible.

testsuite:
	* gdb.base/siginfo-addr.exp, gdb.base/siginfo-addr.c: New.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2006, 2007
@


1.81
log
@2007-11-16  Markus Deuling  <deuling@@de.ibm.com>

	* m32r-rom.c (m32r_supply_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	* ppcnbsd-nat.c (ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, fetch_ppc_registers)
	(store_altivec_register, store_spe_register, store_register)
	(fill_vrregset, store_ppc_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Likewise.

	* trad-frame.c (trad_frame_alloc_saved_regs): Replace current_gdbarch by
	gdbarch.
	* user-regs.c (user_reg_map_name_to_regnum): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_return_value): Likewise.
	* m32c-tdep.c (m32c_register_reggroup_p): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.

	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Use get_frame_arch to
	get at the current architecture by frame_info.
	* gcore.c (derive_stack_segment): Likewise.

	* shnbsd-nat.c (GETREGS_SUPPLIES): Add gdbarch parameter.
	(shnbsd_fetch_inferior_registers, shnbsd_store_inferior_registers): Add
	gdbarch to GETREGS_SUPPLIES call.
@
text
@d2488 2
d2513 25
a2537 4
  mysinfo->si_signo = signo;
  mysinfo->si_code  = 0;
  mysinfo->si_pid   = getpid ();       /* ?why? */
  mysinfo->si_uid   = getuid ();       /* ?why? */
@


1.80
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3690 1
d3711 1
a3711 1
  if (gdbarch_fp0_regnum (current_gdbarch) >= 0) /* Do we have an FPU?  */
d3715 3
a3717 3
      if ((regnum >= 0 && regnum < gdbarch_fp0_regnum (current_gdbarch))
	  || regnum == gdbarch_pc_regnum (current_gdbarch)
	  || regnum == gdbarch_sp_regnum (current_gdbarch))
d3756 1
d3779 1
a3779 1
  if (gdbarch_fp0_regnum (current_gdbarch) >= 0) /* Do we have an FPU?  */
d3783 3
a3785 3
      if ((regnum >= 0 && regnum < gdbarch_fp0_regnum (current_gdbarch))
	  || regnum == gdbarch_pc_regnum (current_gdbarch)
	  || regnum == gdbarch_sp_regnum (current_gdbarch))
@


1.79
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d9 1
a9 1
This file is part of GDB.
d11 12
a22 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
@


1.78
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d3712 1
a3712 1
  if (FP0_REGNUM >= 0)		/* Do we have an FPU?  */
d3716 3
a3718 3
      if ((regnum >= 0 && regnum < FP0_REGNUM)
	  || regnum == PC_REGNUM
	  || regnum == SP_REGNUM)
d3779 1
a3779 1
  if (FP0_REGNUM >= 0)		/* Do we have an FPU?  */
d3783 3
a3785 3
      if ((regnum >= 0 && regnum < FP0_REGNUM)
	  || regnum == PC_REGNUM
	  || regnum == SP_REGNUM)
d4416 1
a4416 1
  if (FP0_REGNUM >= 0)
@


1.77
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d6016 1
d6023 1
a6023 1
  fill_gregset (current_regcache, &gregs, -1);
d6039 1
a6039 1
  fill_fpregset (current_regcache, &fpregs, -1);
d6110 1
a6110 1
  fill_gregset (current_regcache, &gregs, -1);
@


1.76
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_PTR_BIT): Replace with gdbarch_ptr_bit.
	* solib-svr4.c (svr4_truncate_ptr): Likewise.
	* solib-pa64.c (read_dynamic_info): Likewise.
	* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Likewise.
	* solib.c (info_sharedlibrary_command): Likewise.
	* s390-nat.c (SUBOFF): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* procfs.c (info_proc_mappings): Likewise.
	* printcmd.c (decode_format): Likewise.
	* nto-tdep.c (nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips64_linux_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* jv-valprint.c (java_value_print): Likewise.
	* jv-lang.c (get_java_object_header_size): Likewise.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code)
	(hppa_hpux_unwind_adjust_stub): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* gdbtypes.c (make_pointer_type, make_reference_type)
	(smash_to_memberptr_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d5738 1
a5738 1
  if (TARGET_ADDR_BIT == 32)
@


1.75
log
@2007-06-06  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDRESS_TO_POINTER): Replace by
	gdbarch_address_to_pointer.
	* findvar.c (store_typed_address): Likewise.
	* gdbtypes.c (make_pointer_type): Likewise (comment).
	* procfs.c (procfs_address_to_host_pointer): Likewise.
	* std-regs.c (value_of_builtin_frame_reg): Likewise.
	(value_of_builtin_frame_fp_reg): Likewise.
	(value_of_builtin_frame_pc_reg): Likewise.
	* utils.c (paddress): Likewise (comment).
	* gdbarch.sh (POINTER_TO_ADDRESS): Replace by
	gdbarch_pointer_to_address.
	* findvar.c (extract_typed_address): Likewise.
	* gdbtypes.c (make_pointer_type): Likewise (comment).
	* valops.c (value_cast): Likewise (comment).
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d5768 1
a5768 1
  if (TARGET_PTR_BIT == 32)
@


1.74
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@d2850 2
a2851 1
  ADDRESS_TO_POINTER (builtin_type_void_data_ptr, &ptr, addr);
@


1.73
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d126 1
a126 1
static void procfs_prepare_to_store (void);
d3735 1
a3735 1
procfs_prepare_to_store (void)
a3736 3
#ifdef CHILD_PREPARE_TO_STORE
  CHILD_PREPARE_TO_STORE ();
#endif
@


1.72
log
@	* gregset.h (struct regcache): Add forward declaration.
	(supply_gregset): Add REGCACHE parameter, make GREGS const.
	(supply_fpregset): Add REGCACHE parameter, make FPREGS const.
	(supply_fpxregset): Add REGCACHE parameter, make FPXREGS const.
	(fill_gregset): Add REGCACHE parameter.
	(fill_fpregset): Likewise.
	(fill_fpxregset): Likewise.

	Update all definitions accordingly:
	* alphabsd-nat.c, alpha-linux-nat.c, alpha-nat.c, amd64-linux-nat.c,
	arm-linux-nat.c, hppa-linux-nat.c, i386gnu-nat.c, i386-linux-nat.c,
	i386-sol2-nat.c, i386v4-nat.c, ia64-linux-nat.c, irix5-nat.c,
	m32r-linux-nat.c, m68klinux-nat.c, mips-linux-nat.c, ppc-linux-nat.c,
	s390-nat.c, sparc64-linux-nat.c, sparc-linux-nat.c, sparc-sol2-nat.c
	(supply_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make GREGSETP parameter const, adapt casts.
	(supply_fpregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make FPREGSETP parameter const, adapt casts.
	(fill_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.
	(fill_fpregset): Likewise.

	Update all callers to pass in current_regcache as the new argument:
	* core-regset.c: Include "regcache.h".
	(fetch_core_registers): Update supply_gregset,and supply_fpregset calls.
	* procfs.c: Include "regcache.h".
	(procfs_fetch_registers): Update supply_gregset, supply_fpregset calls.
	(procfs_store_registers): Update fill_gregset, fill_fpregset calls.
	(procfs_do_thread_registers): Likewise.
	(procfs_make_note_section): Likewise.
	* proc-service.c: Include "regcache.h".
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.
	* sol-thread.c (sol_thread_fetch_registers): Update supply_gregset,
	supply_fpregset calls.
	(sol_thread_store_registers): Update fill_gregset, fill_fpregset calls.
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.

	* linux-nat.c (linux_nat_do_thread_registers): Update fill_gregset,
	fill_fpregset, and fill_fpxregset calls.
	* i386-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_fpxregs): Update supply_fpxregset call.
	(store_fpxregs): Update fill_fpxregset call.
	* m32r-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	* m68klinux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_core_registers): Update supply_gregset, supply_fpregset calls.
	* s390-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.

	* Makefile.in (core-regset.o, procfs.o, proc-service.o): Update
	dependencies.
@
text
@d123 2
a124 2
static void procfs_fetch_registers (int);
static void procfs_store_registers (int);
d3685 1
a3685 1
procfs_fetch_registers (int regnum)
d3709 1
a3709 1
  supply_gregset (current_regcache, (const gdb_gregset_t *) gregs);
d3724 1
a3724 1
      supply_fpregset (current_regcache, (const gdb_fpregset_t *) fpregs);
d3753 1
a3753 1
procfs_store_registers (int regnum)
d3777 1
a3777 1
  fill_gregset (current_regcache, gregs, regnum);
d3794 1
a3794 1
      fill_fpregset (current_regcache, fpregs, regnum);
@


1.71
log
@Copyright updates for 2007.
@
text
@d33 1
d3709 1
a3709 1
  supply_gregset (gregs);
d3724 1
a3724 1
      supply_fpregset (fpregs);
d3777 1
a3777 1
  fill_gregset (gregs, regnum);
d3794 1
a3794 1
      fill_fpregset (fpregs, regnum);
d6024 1
a6024 1
  fill_gregset (&gregs, -1);
d6040 1
a6040 1
  fill_fpregset (&fpregs, -1);
d6111 1
a6111 1
  fill_gregset (&gregs, -1);
@


1.70
log
@	* target.c (target_read): Stop if target_read_partial returns 0
	when some bytes have already been read.
	(target_write): Likewise for target_write_partial.
	(target_read_partial, target_write_partial): Make static.
	(target_read_alloc): New.
	* target.h: Doc fixes.
	(target_read_partial, target_write_partial): Delete prototypes.
	(target_read_alloc): New prototype.

	* auxv.c (target_auxv_read): Delete.
	(target_auxv_search, fprint_target_auxv): Use target_read_alloc.
	* auxv.h (target_auxv_read): Delete prototype.
	* avr-tdep.c (avr_io_reg_read_command): Use target_read_alloc.
	* ia64-tdep.c (getunwind_table, get_kernel_table): Likewise.
	* linux-nat.c (linux_nat_make_corefile_notes): Likewise.
	* procfs.c (procfs_make_note_section): Likewise.
	* remote.c (remote_xfer_partial): Don't loop here.
	* sparc-tdep.c (sparc_fetch_wcookie): Use target_read.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2006 Free Software Foundation,
   Inc.
@


1.69
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d6133 2
a6134 1
  auxv_len = target_auxv_read (&current_target, &auxv);
@


1.69.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d6133 1
a6133 2
  auxv_len = target_read_alloc (&current_target, TARGET_OBJECT_AUXV,
				NULL, &auxv);
@


1.68
log
@	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.

	* gnu-nat.c (gnu_create_inferior): Don't call proceed.
	* go32-nat.c (go32_create_inferior): Likewise.
	* nto-procfs.c (procfs_create_inferior): Likewise.
	* procfs.c (procfs_create_inferior): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Likewise.
	* remote.c (extended_remote_create_inferior)
	(extended_remote_async_create_inferior): Likewise.
	* win32-nat.c (win32_create_inferior): Likewise.
	* wince.c (child_create_inferior): Likewise.

	* monitor.c (monitor_create_inferior): Don't call proceed.
	Set the PC manually.
	* ocd.c (ocd_create_inferior): Likewise.
	* remote-e7000.c (e7000_create_inferior): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior): Likewise.
	* remote-mips.c (mips_create_inferior): Likewise.
	* remote-rdp.c (remote_rdp_create_inferior): Likewise.
	* remote-sds.c (sds_create_inferior): Likewise.
	* remote-st.c (st2000_create_inferior): Likewise.

	* inf-ptrace.c (inf_ptrace_create_inferior): Don't call
	proceed or observer_notify_inferior_created.
	* inf-ttrace.c (inf_ttrace_create_inferior): Likewise.
	* inftarg.c (child_create_inferior): Likewise.
@
text
@d3378 1
a3378 1
static char dbx_link_shadow_contents[BREAKPOINT_MAX];
d4780 8
a4896 1
  dbx_link_bpt_addr = 0;
d5581 1
a5581 2
  if (memory_remove_breakpoint (dbx_link_bpt_addr,
                                dbx_link_shadow_contents) != 0)
d5585 1
d5653 2
a5654 1
      if (target_insert_breakpoint (sym_addr, dbx_link_shadow_contents) != 0)
@


1.68.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d6125 1
a6125 2
  auxv_len = target_read_whole (&current_target, TARGET_OBJECT_AUXV, NULL,
				&auxv);
@


1.68.2.1.2.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d3374 5
a3378 2
   the startup phase.  */
static struct breakpoint *dbx_link_bpt;
d4210 2
a4211 2
		  if (dbx_link_bpt != NULL
		      && dbx_link_bpt->loc->address == read_pc ())
a4779 7

  if (dbx_link_bpt != NULL)
    {
      deprecated_remove_raw_breakpoint (dbx_link_bpt);
      dbx_link_bpt = NULL;
    }

d4889 1
d5571 1
a5571 1
  if (dbx_link_bpt == NULL)
d5574 2
a5575 1
  if (deprecated_remove_raw_breakpoint (dbx_link_bpt) != 0)
d5578 1
a5578 1
  dbx_link_bpt = NULL;
d5645 2
a5646 2
      dbx_link_bpt = deprecated_insert_raw_breakpoint (sym_addr);
      if (dbx_link_bpt == NULL)
@


1.68.4.1
log
@Initial version of available features support.
@
text
@d6125 1
a6125 2
  auxv_len = target_read_whole (&current_target, TARGET_OBJECT_AUXV, NULL,
				&auxv);
@


1.67
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
a5105 5
  
  /* We are at the first instruction we care about.  */
  /* Pedal to the metal... */

  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
@


1.66
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d23 2
a24 1
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.66.10.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d5105 5
@


1.66.6.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d5105 5
@


1.65
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d5971 2
a5972 2
  add_info ("proc", info_proc_cmd,
	    "Show /proc process information about any running process.\n\
d5974 1
a5974 1
Specify keyword 'mappings' for detailed info on memory mappings.");
d5976 1
a5976 1
	   "Give a trace of entries into the syscall.");
d5978 1
a5978 1
	   "Give a trace of exits from the syscall.");
d5980 1
a5980 1
	   "Cancel a trace of entries into the syscall.");
d5982 1
a5982 1
	   "Cancel a trace of exits from the syscall.");
@


1.64
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d3526 1
a3526 1
	printf_filtered ("Attaching to program `%s', %s\n",
d3529 1
a3529 1
	printf_filtered ("Attaching to %s\n",
d3555 1
a3555 1
      printf_filtered ("Detaching from program: %s, %s\n", exec_file,
d3976 1
a3976 1
		    printf_filtered ("[%s exited]\n",
d4023 1
a4023 1
		    printf_filtered ("procfs: trapped on entry to ");
d4033 1
a4033 1
			  printf_filtered ("%ld syscall arguments:\n", nsysargs);
d4100 1
a4100 1
			printf_filtered ("[New %s]\n",
d4110 1
a4110 1
		    printf_filtered ("[%s exited]\n",
d4127 1
a4127 1
		    printf_filtered ("procfs: trapped on exit from ");
d4137 1
a4137 1
			  printf_filtered ("%ld syscall arguments:\n", nsysargs);
d4155 1
a4155 1
		    printf_filtered ("Retry #%d:\n", retry);
d4170 1
a4170 1
			printf_filtered ("[New %s]\n",
d4233 1
a4233 1
		  printf_filtered ("child stopped for unknown reason:\n");
d4241 1
a4241 1
		printf_filtered ("child stopped for unknown reason:\n");
d4260 1
a4260 1
		  printf_filtered ("[New %s]\n", target_pid_to_str (retval));
d4617 1
a4617 1
  printf_filtered ("\tUsing the running image of %s %s via /proc.\n",
d5773 1
a5773 1
  printf_filtered ("Mapped address spaces:\n\n");
d5857 1
a5857 1
      printf_filtered ("process %d flags:\n", process->pid);
d5867 1
a5867 1
      printf_filtered ("thread %d flags:\n", thread->tid);
@


1.63
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d3515 1
a3515 1
    error_no_arg ("process-id to attach");
d3651 1
a3651 1
	query ("Was stopped when attached, make it runnable again? "))
d4915 1
a4915 1
    perror_with_name ("procfs: create_procinfo failed in child.");
d5930 1
a5930 1
    error_no_arg ("system call to trace");
@


1.62
log
@* procfs.c (procfs_fetch_registers, procfs_store_registers): Like
Remove optimization for DEPRECATED_FP_REGNUM.
@
text
@d469 1
a469 1
	error ("procfs: couldn't find pid %d (kernel thread %d) in procinfo list.",
d472 1
a472 1
	error ("procfs: couldn't find pid %d in procinfo list.", pid);
d836 1
a836 1
  error (msg);
d905 1
a905 1
      error ("load_syscalls: Can't open /proc/%d/sysent", pi->pid);
d911 1
a911 1
      error ("load_syscalls: Error reading /proc/%d/sysent", pi->pid);
d916 1
a916 1
      error ("load_syscalls: /proc/%d/sysent contains no syscalls!", pi->pid);
d925 1
a925 1
      error ("load_syscalls: Error reading /proc/%d/sysent", pi->pid);
d1474 1
a1474 1
    warning ("procfs: modify_flag failed to turn %s %s",
d1822 1
a1822 1
    warning ("procfs: set_traced_signals failed");
d3519 1
a3519 1
    error ("Attaching GDB to itself is not a good idea...");
d3573 1
a3573 1
    perror ("procfs: out of memory in 'attach'");
d3700 1
a3700 1
    error ("procfs: fetch_registers failed to find procinfo for %s",
d3768 1
a3768 1
    error ("procfs: store_registers: failed to find procinfo for %s",
d3922 1
a3922 1
		error ("procfs: couldn't stop process %d: wait returned %d\n",
d4235 1
a4235 1
		  error ("... giving up...");
d4243 1
a4243 1
		error ("... giving up...");
d4286 1
a4286 1
	      error ("procfs: ...giving up...");
d4557 1
a4557 1
	warning ("resume: target already running.  Pretend to resume, and hope for the best!\n");
d4631 1
a4631 1
  error ("Use the \"run\" command to start a Unix child process.");
d5087 1
a5087 1
	error ("procfs:%d -- Can't find shell %s in PATH",
d5338 1
a5338 1
      warning ("procfs_find_LDT_entry: could not find procinfo for %d:%d.",
d5345 1
a5345 1
      warning ("procfs_find_LDT_entry: could not read gregs for %d:%d.",
d5580 1
a5580 1
    warning ("Unable to remove __dbx_link breakpoint.");
d5633 1
a5633 1
      warning ("Failed to create a bfd: %s.\n", bfd_errmsg (bfd_get_error ()));
d5652 1
a5652 1
          warning ("Failed to insert dbx_link breakpoint.");
d5836 1
a5836 1
    error ("No current process: you must name one.");
d5927 1
a5927 1
    error ("you must be debugging a process to use this command.");
d6144 1
a6144 1
  error ("gcore not implemented for this host.");
@


1.61
log
@* procfs.c (proc_get_gregs, proc_get_fpregs, proc_set_gregs)
(proc_set_fpregs, procfs_fetch_registers, procfs_store_registers):
Cleanup coding style.
@
text
@a3714 1
	  || regnum == DEPRECATED_FP_REGNUM
a3784 1
	  || regnum == DEPRECATED_FP_REGNUM
@


1.60
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d2576 2
a2577 6
/*
 * Function: proc_get_gregs
 *
 * Get the general registers for the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d2586 2
a2587 5
  /*
   * OK, sorry about the ifdef's.
   * There's three cases instead of two, because
   * in this instance Unixware and Solaris/RW differ.
   */
d2590 1
a2590 1
#ifdef UNIXWARE		/* ugh, a true architecture dependency */
d2592 1
a2592 1
#else	/* not Unixware */
d2594 2
a2595 2
#endif	/* Unixware */
#else	/* not NEW_PROC_API */
d2597 1
a2597 1
#endif	/* NEW_PROC_API */
d2600 2
a2601 6
/*
 * Function: proc_get_fpregs
 *
 * Get the floating point registers for the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d2611 1
a2611 1
#ifdef UNIXWARE		/* a true architecture dependency */
d2613 1
a2613 1
#else
d2615 1
a2615 1
#endif	/* Unixware */
d2617 1
a2617 1
#else	/* not NEW_PROC_API */
d2619 1
a2619 1
    return &pi->fpregset;	/* already got 'em */
d2622 1
a2622 2
      if (pi->ctl_fd == 0 &&
	  open_procinfo_files (pi, FD_CTL) == 0)
d2628 1
a2628 1
#ifdef PIOCTGFPREG
d2638 2
a2639 2
	  if (pi->tid == 0 &&
	      ioctl (pi->ctl_fd, PIOCGFPREG, &pi->fpregset) >= 0)
d2642 1
a2642 1
	      return &pi->fpregset;	/* got 'em now! */
d2644 2
a2645 2
	  else if (pi->tid != 0 &&
		   ioctl (pi->ctl_fd, PIOCTGFPREG, &thread_fpregs) >= 0)
d2650 1
a2650 1
	      return &pi->fpregset;	/* got 'em now! */
d2656 1
a2656 1
#else
d2660 1
a2660 1
	      return &pi->fpregset;	/* got 'em now! */
d2666 1
a2666 1
#endif
d2669 1
a2669 1
#endif
d2672 3
a2674 6
/*
 * Function: proc_set_gregs
 *
 * Write the general registers back to the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d2682 3
a2684 2
  if ((gregs = proc_get_gregs (pi)) == NULL)
    return 0;	/* get_regs has already warned */
d2686 1
a2686 2
  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
d2699 1
a2699 1
      arg.cmd   = PCSREG;
d2707 1
a2707 1
  /* Policy: writing the regs invalidates our cache. */
d2712 3
a2714 6
/*
 * Function: proc_set_fpregs
 *
 * Modify the floating point register set of the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d2722 3
a2724 2
  if ((fpregs = proc_get_fpregs (pi)) == NULL)
    return 0;		/* get_fpregs has already warned */
d2726 1
a2726 2
  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
d2739 1
a2739 1
      arg.cmd   = PCSFPREG;
d2743 1
a2743 1
#ifdef PIOCTSFPREG
d2760 1
a2760 1
#else
d2762 2
a2763 2
#endif	/* osf PIOCTSFPREG */
#endif	/* NEW_PROC_API */
d2766 1
a2766 1
  /* Policy: writing the regs invalidates our cache. */
d3668 13
a3680 10
/*
 * fetch_registers
 *
 * Since the /proc interface cannot give us individual registers,
 * we pay no attention to the (regno) argument, and just fetch them all.
 * This results in the possibility that we will do unnecessarily many
 * fetches, since we may be called repeatedly for individual registers.
 * So we cache the results, and mark the cache invalid when the process
 * is resumed.
 */
d3683 1
a3683 1
procfs_fetch_registers (int regno)
d3685 4
a3688 5
  gdb_fpregset_t *fpregs;
  gdb_gregset_t  *gregs;
  procinfo       *pi;
  int            pid;
  int            tid;
d3690 2
a3691 5
  pid = PIDGET (inferior_ptid);
  tid = TIDGET (inferior_ptid);

  /* First look up procinfo for the main process. */
  pi  = find_procinfo_or_die (pid, 0);
d3696 1
a3696 2
  if ((tid != 0) &&
      (tid != proc_get_current_thread (pi)))
d3703 2
a3704 1
  if ((gregs = proc_get_gregs (pi)) == NULL)
d3709 1
a3709 1
  if (FP0_REGNUM >= 0)	/* need floating point? */
d3711 1
a3711 5
      if ((regno >= 0 && regno < FP0_REGNUM)
	  || regno == PC_REGNUM
	  || regno == DEPRECATED_FP_REGNUM
	  || regno == SP_REGNUM)
	return;			/* not a floating point register */
d3713 8
a3720 1
      if ((fpregs = proc_get_fpregs (pi)) == NULL)
d3741 9
a3749 10
/*
 * store_registers
 *
 * Since the /proc interface will not read individual registers,
 * we will cache these requests until the process is resumed, and
 * only then write them back to the inferior process.
 *
 * FIXME: is that a really bad idea?  Have to think about cases
 * where writing one register might affect the value of others, etc.
 */
d3752 1
a3752 1
procfs_store_registers (int regno)
d3754 4
a3757 8
  gdb_fpregset_t *fpregs;
  gdb_gregset_t  *gregs;
  procinfo       *pi;
  int            pid;
  int            tid;

  pid = PIDGET (inferior_ptid);
  tid = TIDGET (inferior_ptid);
d3759 2
a3760 2
  /* First find procinfo for main process */
  pi  = find_procinfo_or_die (pid, 0);
d3762 4
a3765 5
  /* If current lwp for process is not the same as requested thread
     (ie. inferior_ptid), then find procinfo for the requested thread.  */

  if ((tid != 0) &&
      (tid != proc_get_current_thread (pi)))
d3772 2
a3773 1
  if ((gregs = proc_get_gregs (pi)) == NULL)
d3776 1
a3776 1
  fill_gregset (gregs, regno);
d3780 1
a3780 1
  if (FP0_REGNUM >= 0)		/* need floating point? */
d3782 7
a3788 5
      if ((regno >= 0 && regno < FP0_REGNUM)
	  || regno == PC_REGNUM
	  || regno == DEPRECATED_FP_REGNUM
	  || regno == SP_REGNUM)
	return;			/* not a floating point register */
d3790 2
a3791 1
      if ((fpregs = proc_get_fpregs (pi)) == NULL)
d3794 1
a3794 1
      fill_fpregset (fpregs, regno);
@


1.59
log
@* procfs.c (procfs_xfer_partial): Use WRITEBUF instead of READBUF
when writing to memory.
@
text
@d175 1
a175 1
  procfs_ops.to_xfer_memory         = procfs_xfer_memory;
d4329 2
a4330 2
	return (*ops->to_xfer_memory) (offset, readbuf, len, 0/*write*/,
				       NULL, ops);
d4332 2
a4333 2
	return (*ops->to_xfer_memory) (offset, writebuf, len, 1/*write*/,
				       NULL, ops);
@


1.58
log
@        * procfs.c (dbx_link_bpt_addr): New static global variable.
        (dbx_link_shadow_contents): New static global variable.
        (procfs_wait, case <PR_SYSEXIT>): Handle syssgi events.
        (procfs_wait, case <FLTBPT>): Remove the __dbx_link brekapoint
        if we just hit it.
        (procfs_init_inferior): Enable syssgi() syscall trace if appropriate.
        Reset dbx_link_bpt_addr as the address of __dbx_link() may change
        from run to run.
        (procfs_create_inferior): Remove syssgi syscall-exit notifications
        after the inferior has been forked.
        (remove_dbx_link_breakpoint): New function.
        (dbx_link_addr): New function.
        (insert_dbx_link_bpt_in_file): New function.
        (insert_dbx_link_bpt_in_region): New function.
        (insert_dbx_link_breakpoint): New function.
        (proc_trace_syscalls_1): New function, extracted from
        proc_trace_syscalls.
        (proc_trace_syscalls): Replace extract code by call to
        proc_trace_syscalls_1.
        * solib-irix.c (disable_break): Remove stop_pc assertion, as it
        is no longer valid.
@
text
@d4332 1
a4332 1
	return (*ops->to_xfer_memory) (offset, readbuf, len, 1/*write*/,
@


1.57
log
@* procfs.c (procfs_detach): Cleanup.  Print process ID, not LWP
ID.  Use comma in output.  Use gdb_flush on gdb_stdout instead of
fflush on stdout.
@
text
@d3385 11
d4084 16
d4226 7
d4884 26
d5116 10
d5588 125
d5901 40
a5944 2
  sysset_t *sysset;
  int       syscallnum = 0;
d5955 1
a5955 13
      syscallnum = atoi (args);
      if (entry_or_exit == PR_SYSENTRY)
	sysset = proc_get_traced_sysentry (pi, NULL);
      else
	sysset = proc_get_traced_sysexit (pi, NULL);

      if (sysset == NULL)
	proc_error (pi, "proc-trace, get_traced_sysset", __LINE__);

      if (mode == FLAG_SET)
	gdb_praddsysset (sysset, syscallnum);
      else
	gdb_prdelsysset (sysset, syscallnum);
d5957 1
a5957 10
      if (entry_or_exit == PR_SYSENTRY)
	{
	  if (!proc_set_traced_sysentry (pi, sysset))
	    proc_error (pi, "proc-trace, set_traced_sysentry", __LINE__);
	}
      else
	{
	  if (!proc_set_traced_sysexit (pi, sysset))
	    proc_error (pi, "proc-trace, set_traced_sysexit", __LINE__);
	}
@


1.56
log
@* procfs.c (procfs_pid_to_str): Use "%ld" to print LWP.
@
text
@d3548 4
a3551 2
  char *exec_file;
  int   signo = 0;
d3555 3
d3559 1
a3559 1
      if (exec_file == 0)
d3561 4
a3564 3
      printf_filtered ("Detaching from program: %s %s\n",
	      exec_file, target_pid_to_str (inferior_ptid));
      fflush (stdout);
a3565 2
  if (args)
    signo = atoi (args);
d3567 2
a3568 1
  do_detach (signo);
d3570 1
a3570 1
  unpush_target (&procfs_ops);		/* Pop out of handling an inferior */
@


1.55
log
@* procfs.c (procfs_pid_to_str): Remove redundant and unused
variables.  Incapitalized "process".
@
text
@d5135 1
a5135 1
    sprintf (buf, "LWP %d", TIDGET (ptid));
@


1.54
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d5125 1
a5125 6
/*
 * Function: target_pid_to_str
 *
 * Return a string to be used to identify the thread in
 * the "info threads" display.
 */
a5130 2
  int proc, thread;
  procinfo *pi;
d5132 4
a5135 3
  proc    = PIDGET (ptid);
  thread  = TIDGET (ptid);
  pi      = find_procinfo (proc, thread);
d5137 1
a5137 5
  if (thread == 0)
    sprintf (buf, "Process %d", proc);
  else
    sprintf (buf, "LWP %d", thread);
  return &buf[0];
@


1.53
log
@2004-02-15  Andrew Cagney  <cagney@@redhat.com>

	* procfs.c (procfs_init_inferior): Assume that
	START_INFERIOR_TRAPS_EXPECTED is defined.
	* config/ns32k/nbsdaout.mt (TM_FILE): Set to tm-ns32k.h.
	* config/ns32k/tm-nbsd.h: Delete file,
	START_INFERIOR_TRAPS_EXPECTED already defined as 2.
@
text
@d127 1
a127 1
static void procfs_create_inferior (char *, char *, char **);
d4975 2
a4976 1
procfs_create_inferior (char *exec_file, char *allargs, char **env)
@


1.53.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d127 1
a127 1
static void procfs_create_inferior (char *, char *, char **, int);
a3384 11
static void proc_trace_syscalls_1 (procinfo *pi, int syscallnum,
                                   int entry_or_exit, int mode, int from_tty);
static int insert_dbx_link_breakpoint (procinfo *pi);
static void remove_dbx_link_breakpoint (void);

/* On mips-irix, we need to insert a breakpoint at __dbx_link during
   the startup phase.  The following two variables are used to record
   the address of the breakpoint, and the code that was replaced by
   a breakpoint.  */
static int dbx_link_bpt_addr = 0;
static char dbx_link_shadow_contents[BREAKPOINT_MAX];
d3548 2
a3549 4
  int sig = 0;

  if (args)
    sig = atoi (args);
a3552 3
      int pid = PIDGET (inferior_ptid);
      char *exec_file;

d3554 1
a3554 1
      if (exec_file == NULL)
d3556 3
a3558 4

      printf_filtered ("Detaching from program: %s, %s\n", exec_file,
		       target_pid_to_str (pid_to_ptid (pid)));
      gdb_flush (gdb_stdout);
d3560 2
d3563 1
a3563 2
  do_detach (sig);

d3565 1
a3565 1
  unpush_target (&procfs_ops);
a4067 16
#ifdef SYS_syssgi
                else if (what == SYS_syssgi)
                  {
                    /* see if we can break on dbx_link().  If yes, then
                       we no longer need the SYS_syssgi notifications.  */
                    if (insert_dbx_link_breakpoint (pi))
                      proc_trace_syscalls_1 (pi, SYS_syssgi, PR_SYSEXIT,
                                             FLAG_RESET, 0);

                    /* This is an internal event and should be transparent
                       to wfi, so resume the execution and wait again.  See
                       comment in procfs_init_inferior() for more details.  */
                    target_resume (ptid, 0, TARGET_SIGNAL_0);
                    goto wait_again;
                  }
#endif
a4193 7
                  /* If we hit our __dbx_link() internal breakpoint,
                     then remove it.  See comments in procfs_init_inferior()
                     for more details.  */
                  if (dbx_link_bpt_addr != 0
                      && dbx_link_bpt_addr == read_pc ())
                    remove_dbx_link_breakpoint ();

a4844 26

#ifdef SYS_syssgi
  /* On mips-irix, we need to stop the inferior early enough during
     the startup phase in order to be able to load the shared library
     symbols and insert the breakpoints that are located in these shared
     libraries.  Stopping at the program entry point is not good enough
     because the -init code is executed before the execution reaches
     that point.

     So what we need to do is to insert a breakpoint in the runtime
     loader (rld), more precisely in __dbx_link().  This procedure is
     called by rld once all shared libraries have been mapped, but before
     the -init code is executed. Unfortuantely, this is not straightforward,
     as rld is not part of the executable we are running, and thus we need
     the inferior to run until rld itself has been mapped in memory.
     
     For this, we trace all syssgi() syscall exit events.  Each time
     we detect such an event, we iterate over each text memory maps,
     get its associated fd, and scan the symbol table for __dbx_link().
     When found, we know that rld has been mapped, and that we can insert
     the breakpoint at the symbol address.  Once the dbx_link() breakpoint
     has been inserted, the syssgi() notifications are no longer necessary,
     so they should be canceled.  */
  proc_trace_syscalls_1 (pi, SYS_syssgi, PR_SYSEXIT, FLAG_SET, 0);
  dbx_link_bpt_addr = 0;
#endif
d4975 1
a4975 2
procfs_create_inferior (char *exec_file, char *allargs, char **env,
			int from_tty)
a5049 10
#ifdef SYS_syssgi
  /* Make sure to cancel the syssgi() syscall-exit notifications.  
     They should normally have been removed by now, but they may still
     be activated if the inferior doesn't use shared libraries, or if
     we didn't locate __dbx_link, or if we never stopped in __dbx_link.
     See procfs_init_inferior() for more details.  */
  proc_trace_syscalls_1 (find_procinfo_or_die (PIDGET (inferior_ptid), 0),
                         SYS_syssgi, PR_SYSEXIT, FLAG_RESET, 0);
#endif
  
d5124 6
a5129 1
/* Convert PTID to a string.  Returns the string in a static buffer.  */
d5135 2
d5138 6
a5143 2
  if (TIDGET (ptid) == 0)
    sprintf (buf, "process %d", PIDGET (ptid));
d5145 2
a5146 3
    sprintf (buf, "LWP %ld", TIDGET (ptid));

  return buf;
a5521 125
/* Remove the breakpoint that we inserted in __dbx_link().
   Does nothing if the breakpoint hasn't been inserted or has already
   been removed.  */

static void
remove_dbx_link_breakpoint (void)
{
  if (dbx_link_bpt_addr == 0)
    return;

  if (memory_remove_breakpoint (dbx_link_bpt_addr,
                                dbx_link_shadow_contents) != 0)
    warning ("Unable to remove __dbx_link breakpoint.");

  dbx_link_bpt_addr = 0;
}

/* Return the address of the __dbx_link() function in the file
   refernced by ABFD by scanning its symbol table.  Return 0 if
   the symbol was not found.  */

static CORE_ADDR
dbx_link_addr (bfd *abfd)
{
  long storage_needed;
  asymbol **symbol_table;
  long number_of_symbols;
  long i;

  storage_needed = bfd_get_symtab_upper_bound (abfd);
  if (storage_needed <= 0)
    return 0;

  symbol_table = (asymbol **) xmalloc (storage_needed);
  make_cleanup (xfree, symbol_table);

  number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);

  for (i = 0; i < number_of_symbols; i++)
    {
      asymbol *sym = symbol_table[i];

      if ((sym->flags & BSF_GLOBAL)
          && sym->name != NULL && strcmp (sym->name, "__dbx_link") == 0)
        return (sym->value + sym->section->vma);
    }

  /* Symbol not found, return NULL.  */
  return 0;
}

/* Search the symbol table of the file referenced by FD for a symbol
   named __dbx_link(). If found, then insert a breakpoint at this location,
   and return nonzero.  Return zero otherwise.  */

static int
insert_dbx_link_bpt_in_file (int fd, CORE_ADDR ignored)
{
  bfd *abfd;
  long storage_needed;
  CORE_ADDR sym_addr;

  abfd = bfd_fdopenr ("unamed", 0, fd);
  if (abfd == NULL)
    {
      warning ("Failed to create a bfd: %s.\n", bfd_errmsg (bfd_get_error ()));
      return 0;
    }

  if (!bfd_check_format (abfd, bfd_object))
    {
      /* Not the correct format, so we can not possibly find the dbx_link
         symbol in it.  */
      bfd_close (abfd);
      return 0;
    }

  sym_addr = dbx_link_addr (abfd);
  if (sym_addr != 0)
    {
      /* Insert the breakpoint.  */
      dbx_link_bpt_addr = sym_addr;
      if (target_insert_breakpoint (sym_addr, dbx_link_shadow_contents) != 0)
        {
          warning ("Failed to insert dbx_link breakpoint.");
          bfd_close (abfd);
          return 0;
        }
      bfd_close (abfd);
      return 1;
    }

  bfd_close (abfd);
  return 0;
} 

/* If the given memory region MAP contains a symbol named __dbx_link,
   insert a breakpoint at this location and return nonzero.  Return
   zero otherwise.  */

static int
insert_dbx_link_bpt_in_region (struct prmap *map,
                               int (*child_func) (),
                               void *data)
{     
  procinfo *pi = (procinfo *) data;
        
  /* We know the symbol we're looking for is in a text region, so
     only look for it if the region is a text one.  */
  if (map->pr_mflags & MA_EXEC)
    return solib_mappings_callback (map, insert_dbx_link_bpt_in_file, pi);
 
  return 0;
}           

/* Search all memory regions for a symbol named __dbx_link.  If found,
   insert a breakpoint at its location, and return nonzero.  Return zero
   otherwise.  */

static int
insert_dbx_link_breakpoint (procinfo *pi)
{
  return iterate_over_mappings (pi, NULL, pi, insert_dbx_link_bpt_in_region);
}

a5709 40
/* Modify the status of the system call identified by SYSCALLNUM in
   the set of syscalls that are currently traced/debugged.

   If ENTRY_OR_EXIT is set to PR_SYSENTRY, then the entry syscalls set
   will be updated. Otherwise, the exit syscalls set will be updated.

   If MODE is FLAG_SET, then traces will be enabled. Otherwise, they
   will be disabled.  */

static void
proc_trace_syscalls_1 (procinfo *pi, int syscallnum, int entry_or_exit,
                      int mode, int from_tty)
{
  sysset_t *sysset;
  
  if (entry_or_exit == PR_SYSENTRY)
    sysset = proc_get_traced_sysentry (pi, NULL);
  else
    sysset = proc_get_traced_sysexit (pi, NULL);

  if (sysset == NULL)
    proc_error (pi, "proc-trace, get_traced_sysset", __LINE__);

  if (mode == FLAG_SET)
    gdb_praddsysset (sysset, syscallnum);
  else
    gdb_prdelsysset (sysset, syscallnum);

  if (entry_or_exit == PR_SYSENTRY)
    {
      if (!proc_set_traced_sysentry (pi, sysset))
        proc_error (pi, "proc-trace, set_traced_sysentry", __LINE__);
    }
  else
    {
      if (!proc_set_traced_sysexit (pi, sysset))
        proc_error (pi, "proc-trace, set_traced_sysexit", __LINE__);
    }
}

d5714 2
d5726 13
a5738 1
      const int syscallnum = atoi (args);
d5740 10
a5749 1
      proc_trace_syscalls_1 (pi, syscallnum, entry_or_exit, mode, from_tty);
@


1.52
log
@2004-01-28  Roland McGrath  <roland@@redhat.com>

	* procfs.c (procfs_xfer_partial): New function.
	(init_procfs_ops): Use that for procfs_ops.to_xfer_partial.
	* Makefile.in (procfs.o): Add $(auxv_h) dep.
	* procfs.c (procfs_make_note_section): If we can read
	TARGET_OBJECT_AUXV data, add an NT_AUXV note containing it.
	* linux-proc.c (linux_make_note_section): Likewise.
@
text
@d4842 2
a4843 1
#ifdef START_INFERIOR_TRAPS_EXPECTED
a4844 4
#else
  /* One trap to exec the shell, one to exec the program being debugged.  */
  startup_inferior (2);
#endif /* START_INFERIOR_TRAPS_EXPECTED */
@


1.51
log
@2004-01-29  Roland McGrath  <roland@@redhat.com>

	* procfs.c: Include gdb_string.h for str* decls, otherwise warnings.
	* Makefile.in (procfs.o): Add dep.
@
text
@d51 1
d132 5
d174 1
d4278 34
d5894 2
d5942 8
@


1.50
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_NPC_REGNUM): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* procfs.c (procfs_fetch_registers): Delete reference to
	DEPRECATED_NPC_REGNUM.
	(procfs_store_registers): Ditto.
	* regcache.c (generic_target_write_pc): Simplify.
	* lynx-nat.c: Delete #ifdef SPARC code.  Not used.

Index: doc/ChangeLog
2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	documentation on DEPRECATED_NPC_REGNUM.
@
text
@d22 1
a22 1
along with this program; if not, write to the Free Software Foundation, 
d48 1
d52 1
a52 1
/* 
d77 1
a77 1
 * In order to keep most of the code simple and clean, I have 
d86 1
a86 1
   The ioctl API defines PIOCSTATUS, while 
d137 4
a140 4
static int proc_find_memory_regions (int (*) (CORE_ADDR, 
					      unsigned long, 
					      int, int, int, 
					      void *), 
d154 1
a154 1
  procfs_ops.to_doc                 = 
d210 1
a210 1
     enum { READ_WATCHFLAG  = WA_READ, 
d217 1
a217 1
     enum { READ_WATCHFLAG  = MA_READ, 
d348 1
a348 1
  /* The following four fd fields may be identical, or may contain 
d356 1
a356 1
   * However, to avoid a bunch of #ifdefs in the code, we will use 
d381 1
a381 1
  
d421 1
a421 1
static procinfo * 
d462 1
a462 1
	error ("procfs: couldn't find pid %d (kernel thread %d) in procinfo list.", 
d473 1
a473 1
   
d480 1
a480 1
   
d527 1
a527 1
  /* 
d532 1
a532 1
   *   There are several file descriptors that may need to be open 
d539 1
a539 1
   *   The pathnames for the 'files' for an LWP look slightly 
d557 1
a557 1
   *   doesn't need any #ifdef's.  
d562 1
a562 1
   *     Each LWP has an independent file descriptor, but these 
d621 2
a622 2
   * The ones for the LWPs have to be obtained thru an IOCTL call 
   * on the process's file descriptor. 
d625 1
a625 1
   * into all of the fields occupied by the several file descriptors 
d755 1
a755 1
  else 
d853 1
a853 1
  
d872 1
a872 1
  
d972 1
a972 1
  
d978 1
a978 1
   
d1002 1
a1002 1
   
d1022 1
a1022 1
 * and the gdb target vector functions.  This layer consists of 
d1122 1
a1122 1
      /* Sigh... I have to read a different data structure, 
d1125 2
a1126 2
	pi->status_valid = (read (pi->status_fd, 
				  (char *) &pi->prstatus.pr_lwp, 
d1131 1
a1131 1
	  pi->status_valid = (read (pi->status_fd, 
d1140 1
a1140 1
	    pi->status_valid = (read (pi->status_fd, 
d1152 1
a1152 1
      pi->status_valid = 
d1169 1
a1169 1
	  memcpy (&pi->prstatus, &thread_status.status, 
d1182 1
a1182 1
      PROC_PRETTYFPRINT_STATUS (proc_flags (pi), 
d1184 1
a1184 1
				proc_what (pi), 
d1191 1
a1191 1
  /* In the read/write multiple-fd model, 
d1202 1
a1202 1
 */ 
d1278 1
a1278 1
  
d1298 1
a1298 1
  
d1318 1
a1318 1
  
d1348 1
a1348 1
 * Function: proc_modify_flag 
d1350 1
a1350 1
 *  === I appologize for the messiness of this function. 
d1372 1
a1372 1
 * Arguments: 
d1387 7
a1393 7
  /* 
   * These operations affect the process as a whole, and applying 
   * them to an individual LWP has the same meaning as applying them 
   * to the main process.  Therefore, if we're ever called with a 
   * pointer to an LWP's procinfo, let's substitute the process's 
   * procinfo and avoid opening the LWP's file descriptor 
   * unnecessarily.  
d1400 1
a1400 1
  /* First normalize the PCUNSET/PCRESET command opcode 
d1467 1
a1467 1
    warning ("procfs: modify_flag failed to turn %s %s", 
d1535 1
a1535 1
 * Process will NOT be killed when debugger 
d1585 1
a1585 1
 * If one LWP stops because of a debug event (signal etc.), 
d1618 1
a1618 1
 * Returns non-zero for success, zero for failure. 
d1645 1
a1645 1
	  PROC_PRETTYFPRINT_STATUS (proc_flags (pi), 
d1647 1
a1647 1
				    proc_what (pi), 
d1660 1
a1660 1
 * Returns non-zero for success, zero for failure. 
d1671 1
a1671 1
   * for any reason, then take out the following clause and 
d1674 1
a1674 1
  
d1691 1
a1691 1
      PROC_PRETTYFPRINT_STATUS (proc_flags (pi), 
d1693 1
a1693 1
				proc_what (pi), 
d1724 1
a1724 1
 * Returns non-zero for success, zero for failure. 
d1737 1
a1737 1
  
d1777 1
a1777 1
 * Returns non-zero for success, zero for failure. 
d1788 1
a1788 1
   * for any reason, then take out the following clause and 
d1791 1
a1791 1
  
d1823 1
a1823 1
 * Returns non-zero for success, zero for failure. 
d1834 1
a1834 1
   * for any reason, then take out the following clause and 
d1837 1
a1837 1
  
d1867 1
a1867 1
 * Returns non-zero for success, zero for failure. 
d1878 1
a1878 1
   * for any reason, then take out the following clause and 
d1881 1
a1881 1
  
d1909 1
a1909 1
     
d1917 1
a1917 1
 * Returns non-zero for success, zero for failure. 
d1928 1
a1928 1
   * for any reason, then take out the following clause and 
d1931 1
a1931 1
  
d1967 1
a1967 1
 * Returns non-zero for success, zero for failure. 
d1978 1
a1978 1
   * for any reason, then take out the following clause and 
d1981 1
a1981 1
  
d2021 1
a2021 1
   * for any reason, then take out the following clause and 
d2024 1
a2024 1
  
d2058 1
a2058 1
   * for any reason, then take out the following clause and 
d2061 1
a2061 1
  
d2095 1
a2095 1
   * for any reason, then take out the following clause and 
d2098 1
a2098 1
  
d2141 1
a2141 1
   * for any reason, then take out the following clause and 
d2144 1
a2144 1
  
d2183 1
a2183 1
   * for any reason, then take out the following clause and 
d2186 1
a2186 1
  
d2217 1
a2217 1
   * for any reason, then take out the following clause and 
d2220 1
a2220 1
  
d2251 1
a2251 1
   * for any reason, then take out the following clause and 
d2254 1
a2254 1
  
d2293 1
a2293 1
   * for any reason, then take out the following clause and 
d2296 1
a2296 1
  
d2366 1
a2366 1
   * for any reason, then take out the following clause and 
d2369 1
a2369 1
  
d2439 1
a2439 1
   * for any reason, then take out the following clause and 
d2442 1
a2442 1
  
d2485 1
a2485 1
   * for any reason, then take out the following clause and 
d2488 1
a2488 1
  
d2495 1
a2495 1
   * it messes up the current signal. Work around the kernel bug. 
d2535 1
a2535 1
   * for any reason, then take out the following clause and 
d2538 1
a2538 1
  
d2585 1
a2585 1
   * There's three cases instead of two, because 
d2835 1
a2835 1
   * for any reason, then take out the following clause and 
d2838 1
a2838 1
  
d2871 1
a2871 1
#if !defined (TARGET_HAS_HARDWARE_WATCHPOINTS)  
d2979 1
a2979 1
      ldt_entry = (struct ssd *) 
d2983 1
a2983 1
  
d3011 1
a3011 1
 * Function: proc_get_nthreads 
d3013 1
a3013 1
 * Return the number of threads for the process 
d3020 1
a3020 1
int 
d3044 1
a3044 1
   * NEW_PROC_API: only works for the process procinfo, 
d3047 1
a3047 1
#ifdef NEW_PROC_API  
d3085 1
a3085 1
   * an LWP, it will simply return that LWP's ID.  In that case, 
d3088 1
a3088 1
  
d3108 1
a3108 1
int 
d3122 1
a3122 1
int 
d3132 1
a3132 1
 * Function: proc_update_threads 
d3169 1
a3169 1
   * for any reason, then take out the following clause and 
d3172 1
a3172 1
  
d3224 1
a3224 1
   * for any reason, then take out the following clause and 
d3227 1
a3227 1
  
d3236 2
a3237 2
   * Note: this brute-force method is the only way I know of 
   * to accomplish this task on Unixware.  This method will 
d3265 1
a3265 1
int 
d3274 1
a3274 1
   * for any reason, then take out the following clause and 
d3277 1
a3277 1
  
d3288 1
a3288 1
  
d3326 2
a3327 2
 * a quick pass over the currently-known procinfos. 
 * 
d3348 1
a3348 1
   * for any reason, then take out the following clause and 
d3351 1
a3351 1
  
d3508 1
a3508 1
static void 
d3526 1
a3526 1
	printf_filtered ("Attaching to program `%s', %s\n", 
d3538 1
a3538 1
static void 
d3555 1
a3555 1
  
d3573 1
a3573 1
      sprintf (errmsg, "do_attach: couldn't open /proc file for process %d", 
d3605 1
a3605 1
    dead_procinfo (pi, "do_attach: couldn't save traced syscall exits.", 
d3689 2
a3690 2
  /* If the event thread is not the same as GDB's requested thread 
     (ie. inferior_ptid), then look up procinfo for the requested 
d3692 1
a3692 1
  if ((tid != 0) && 
d3697 1
a3697 1
    error ("procfs: fetch_registers failed to find procinfo for %s", 
d3737 1
a3737 1
 * Since the /proc interface will not read individual registers, 
d3763 1
a3763 1
  if ((tid != 0) && 
d3942 1
a3942 1
	     is gone (child terminated), then we skip this block, 
d3983 1
a3983 1
		       Make it runnable, resume it, then use 
d3985 1
a3985 1
		       Proc_run_process always clears the current 
d3990 1
a3990 1
		    /* FIXME: what we should do is return 
d3996 1
a3996 1
			/* Don't call wait: simulate waiting for exit, 
d4032 1
a4032 1
			    printf_filtered ("#%ld: 0x%08lx\n", 
d4103 1
a4103 1
		       that threads were actually separate processes. 
d4120 1
a4120 1
			    printf_filtered ("#%ld: 0x%08lx\n", 
d4151 1
a4151 1
			printf_filtered ("[New %s]\n", 
d4229 1
a4229 1
		   * We have a new thread.  
d4231 1
a4231 1
		   * If we don't create a procinfo, resume may be unhappy 
d4240 1
a4240 1
		   * new thread we've seen, in which case we may not 
d4247 1
a4247 1
		      if (find_procinfo (PIDGET (inferior_ptid), 
d4249 1
a4249 1
			create_procinfo (PIDGET (inferior_ptid), 
d4329 1
a4329 1
 * File descriptors are also cached.  
d4337 1
a4337 1
 * As this function is called by iterate_over_threads, it always 
d4361 1
a4361 1
	  proc_warn (pi, "target_resume, set_fpregs", 
d4368 1
a4368 1
	 Close any file descriptors that it might have open.  
d4416 1
a4416 1
 *  step:  if true, then arrange for the child to stop again 
d4419 1
a4419 1
 *         If non-zero, then arrange for the indicated signal 
d4432 1
a4432 1
  /* 2.1: 
d4434 1
a4434 1
     prrun.pr_vaddr = $PC;	   set resume address 
d4436 1
a4436 1
     prrun.prflags |= PRSFAULT;    trace faults in pr_fault (all but PAGE) 
d4465 1
a4465 1
  proc_iterate_over_threads (pi, invalidate_cache, NULL); 
d4485 1
a4485 1
	      proc_iterate_over_threads (pi, 
d4506 1
a4506 1
 * Traverse the list of signals that GDB knows about 
d4558 1
a4558 1
		   attach_flag? "attached": "child", 
d4577 1
a4577 1
 * This tells GDB that this target vector can be invoked 
d4594 1
a4594 1
  
d4619 1
a4619 1
 * Note: this should only be applied to the real process, 
d4666 1
a4666 1
    /* FIXME: should we use waitpid to make sure we get the right event?  
d4686 1
a4686 1
static void 
d4706 1
a4706 1
static void 
d4725 1
a4725 1
 * When GDB forks to create a runnable inferior process, 
d4731 1
a4731 1
static void 
d4916 1
a4916 1
  /* FIXME: No need to destroy the procinfo -- 
d4925 1
a4925 1
 * Its only real responsibility is to set things up for the fork, 
d4928 1
a4928 1
 * 
d5009 1
a5009 1
  fork_inferior (exec_file, allargs, env, procfs_set_exec_trap, 
d5039 1
a5039 1
 * Query all the threads that the target knows about, 
d5054 1
a5054 1
/* 
d5089 1
a5089 1
 * Return a string to be used to identify the thread in 
d5116 1
a5116 1
int 
d5123 1
a5123 1
  procinfo *pi; 
d5125 1
a5125 1
  pi = find_procinfo_or_die (PIDGET (ptid) == -1 ? 
d5170 1
a5170 1
   
d5210 1
a5210 1
  pi = find_procinfo_or_die (PIDGET (ptid) == -1 ? 
d5219 1
a5219 1
	{	
d5235 1
a5235 1
 * Function: procfs_find_LDT_entry 
d5277 1
a5277 1
/* 
d5291 1
a5291 1
 * Return: First non-zero return value from the callback function, 
d5296 3
a5298 3
iterate_over_mappings (procinfo *pi, int (*child_func) (), void *data, 
		       int (*func) (struct prmap *map, 
				    int (*child_func) (), 
d5311 1
a5311 1
  /* Get the number of mappings, allocate space, 
d5322 1
a5322 1
  /* Use stat to determine the file size, and compute 
d5352 4
a5355 4
 * Calls the supplied callback function once for each mapped address 
 * space in the process.  The callback function  receives an open 
 * file descriptor for the file corresponding to that mapped 
 * address space (if there is one), and the base address of the 
d5363 1
a5363 1
int solib_mappings_callback (struct prmap *map, 
d5386 1
a5386 1
	 we just pass the FD on as given.  Sometimes there is 
d5393 1
a5393 1
     we just pass the FD on as given.  Sometimes there is 
d5407 1
a5407 1
 * mapped address space in the process.  The callback function 
d5432 3
a5434 3
 *   int callback (CORE_ADDR vaddr, 
 *                 unsigned long size, 
 *                 int read, int write, int execute, 
d5441 4
a5444 4
find_memory_regions_callback (struct prmap *map, 
			      int (*func) (CORE_ADDR, 
					   unsigned long, 
					   int, int, int, 
d5449 1
a5449 1
		  map->pr_size, 
d5452 1
a5452 1
		  (map->pr_mflags & MA_EXEC) != 0, 
d5462 1
a5462 1
 *	unsigned long size, 
d5466 1
a5466 1
 * 
d5472 4
a5475 4
proc_find_memory_regions (int (*func) (CORE_ADDR, 
				       unsigned long, 
				       int, int, int, 
				       void *), 
d5480 1
a5480 1
  return iterate_over_mappings (pi, func, data, 
d5531 1
a5531 1
  printf_filtered (data_fmt_string, 
d5536 1
a5536 1
		   (unsigned int) map->pr_offset, 
d5565 1
a5565 1
  printf_filtered (header_fmt_string, 
d5635 1
a5635 1
	   /* No.  So open a procinfo for it, but 
d5653 1
a5653 1
	printf_filtered ("Process has %d threads.\n", 
d5715 1
a5715 1
static void 
d5721 1
a5721 1
static void 
d5727 1
a5727 1
static void 
d5733 1
a5733 1
static void 
d5745 1
a5745 1
  add_info ("proc", info_proc_cmd, 
d5749 1
a5749 1
  add_com ("proc-trace-entry", no_class, proc_trace_sysentry_cmd, 
d5751 1
a5751 1
  add_com ("proc-trace-exit", no_class, proc_trace_sysexit_cmd, 
d5753 1
a5753 1
  add_com ("proc-untrace-entry", no_class, proc_untrace_sysentry_cmd, 
d5755 1
a5755 1
  add_com ("proc-untrace-exit", no_class, proc_untrace_sysexit_cmd, 
d5784 1
a5784 1
procfs_do_thread_registers (bfd *obfd, ptid_t ptid, 
d5798 1
a5798 1
						merged_pid, 
d5805 1
a5805 1
					       merged_pid, 
d5833 2
a5834 2
      args->note_data = procfs_do_thread_registers (args->obfd, inferior_ptid, 
						    args->note_data, 
d5857 1
a5857 1
      strncpy (psargs, get_exec_file (0), 
d5864 1
a5864 1
	  strncat (psargs, " ", 
d5866 1
a5866 1
	  strncat (psargs, inf_args, 
d5871 4
a5874 4
  note_data = (char *) elfcore_write_prpsinfo (obfd, 
					       note_data, 
					       note_size, 
					       fname, 
d5879 2
a5880 2
  note_data = elfcore_write_pstatus (obfd, note_data, note_size, 
				     PIDGET (inferior_ptid), 
d5893 1
a5893 1
      note_data = procfs_do_thread_registers (obfd, inferior_ptid, 
@


1.49
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* procfs.c (procfs_wait): Delete FAULTED_USE_SIGINFO comment.
	* config/sparc/tm-sun4sol2.h (FAULTED_USE_SIGINFO): Delete macro.
	* config/i386/tm-i386sol2.h (FAULTED_USE_SIGINFO): Delete macro.
	* config/alpha/nm-osf2.h (FAULTED_USE_SIGINFO): Delete macro.
@
text
@d3706 4
a3709 5
      if ((regno >= 0 && regno < FP0_REGNUM) ||
	  regno == PC_REGNUM  ||
	  (DEPRECATED_NPC_REGNUM >= 0 && regno == DEPRECATED_NPC_REGNUM) ||
	  regno == DEPRECATED_FP_REGNUM  ||
	  regno == SP_REGNUM)
d3779 4
a3782 5
      if ((regno >= 0 && regno < FP0_REGNUM) ||
	  regno == PC_REGNUM  ||
	  (DEPRECATED_NPC_REGNUM >= 0 && regno == DEPRECATED_NPC_REGNUM) ||
	  regno == DEPRECATED_FP_REGNUM  ||
	  regno == SP_REGNUM)
@


1.48
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d4166 1
a4166 1
		switch (what) {	/* FIXME: FAULTED_USE_SIGINFO */
@


1.47
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_NPC_REGNUM): Deprecate NPC_REGNUM.
	* gdbarch.h, gdbarch.c: Regenerate.
	* core-sol2.c, hppa-tdep.c, lynx-nat.c, procfs.c: Update.
	* regcache.c, remote-vxsparc.c, sparc-linux-nat.c: Update.
	* sparc-nat.c, sparc-tdep.c, sparc64-tdep.c: Update.
	* sparcnbsd-tdep.c: Update.
@
text
@a5521 1
/* ARGSUSED */
@


1.46
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d3708 1
a3708 1
	  (NPC_REGNUM >= 0 && regno == NPC_REGNUM) ||
d3782 1
a3782 1
	  (NPC_REGNUM >= 0 && regno == NPC_REGNUM) ||
@


1.46.18.1
log
@2003-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* exec.c (exec_set_find_memory_regions): Update parameter list.
	* defs.h (exec_set_find_memory_regions): Update parameter list.
	* fbsd-proc.c (fbsd_find_memory_regions): Likewise. Update call to
	function parameter.
	* gcore.c (gcore_create_callback): Update paramter list.
	(objfile_find_memory_regions): Update parameter list. Update calls
	to function parameter.
	* gnu-nat.c (gnu_find_memory_regions): Update parameter
	list. Update calls to function parameter.
	* inftarg.c (inftarg_set_find_memory_regions): Update parameter
	list.
	* linux-proc.c (read_mapping): Prune the leading whitespaces in
	the filename.
	(linux_find_memory_regions): Update parameter list. Update call to
	function parameter.
	* procfs.c (find_memory_regions_callback): Update paremeters and
	calls.
	(proc_find_memory_regions): Update parameters.
	* sol-thread.c (sol_find_memory_regions): Update parameter list.
	* target.h (struct target_ops): Update definition of
	to_find_memory_regions field.
@
text
@d139 1
a139 1
					      char *, void *), 
d5436 1
a5436 1
 *                 char *filename, void *data);
d5446 1
a5446 1
					   char *, void *),
a5453 1
                  NULL,
d5466 1
a5466 2
 *	int execute	TRUE if region is executable by the child
 *      char *filename.
d5476 1
a5476 1
				       char *, void *), 
@


1.45
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* Makefile.in (symm-nat.o): Update dependencies.
	(sparc-nat.o, procfs.o, proc-api.o, ppc-linux-nat.o): Ditto.
	(lynx-nat.o, ia64-linux-nat.): Ditto.
	* symm-nat.c, sparc-nat.c, procfs.c, proc-api.c: Include
	"gdb_wait.h" instead of <wait.h> or <sys/wait.h>.
	* ppc-linux-nat.c, lynx-nat.c, ia64-linux-nat.c: Ditto.
@
text
@d3709 1
a3709 1
	  regno == FP_REGNUM  ||
d3783 1
a3783 1
	  regno == FP_REGNUM  ||
@


1.45.16.1
log
@Merge from mainline.
@
text
@d3709 1
a3709 1
	  regno == DEPRECATED_FP_REGNUM  ||
d3783 1
a3783 1
	  regno == DEPRECATED_FP_REGNUM  ||
@


1.44
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* Makefile.in (inflow_h): Define.
	(procfs.o, inflow.o, procfs.o): Update dependencies.
	* inftarg.c (child_stop): Delete extern declaration of
	inferior_process_group.  Include "inflow.h".
	* procfs.c (procfs_stop): Ditto.  Include "inflow.h".
	* inflow.c (PROCESS_GROUP_TYPE): Move definitions from here ...
	* inflow.h (PROCESS_GROUP_TYPE): ... to here.  New file.
	(our_process_group, inferior_process_group): Extern declarations.
@
text
@d2 4
a5 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d45 1
a45 1
#include <sys/wait.h>
@


1.43
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* procfs.c: Include "gdb_assert.h".
@
text
@d46 1
a4609 2
  extern pid_t inferior_process_group;

@


1.42
log
@2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* defs.h (host_pointer_to_address): Delete declaration.
	(address_to_host_pointer): Delete declaration.
	* utils.c (host_pointer_to_address): Delete function.
	(address_to_host_pointer): Delete function.
	* procfs.c (procfs_address_to_host_pointer): New function.
	* procfs.c (proc_set_watchpoint): Use.
	(procfs_can_use_hw_breakpoint): Update comments.
	* somsolib.c (hpux_address_to_host_pointer_hack): New function.
	(som_solib_add): Use.
	* hppa-tdep.c (hppa_pointer_to_address_hack): New function.
	* hppa-tdep.c (unwind_command): Use.
@
text
@d45 1
@


1.41
log
@2002-06-05  Paul N. Hilfinger  <hilfingr@@otisco.mckusick.com>

	* procfs.c (do_detach): Clear current signal, not just fault.
	Corrects problem with breakpoint trap signal leaking to detached
	process on Tru64.
@
text
@d2844 13
d2879 3
d2883 1
a2883 1
  pwatch->pr_vaddr  = (uintptr_t) address_to_host_pointer (addr);
d2885 1
a2885 1
  pwatch->pr_vaddr  = (caddr_t) address_to_host_pointer (addr);
d5182 5
a5186 4
     fact that proc_set_watchpoint() calls address_to_host_pointer();
     a close inspection of address_to_host_pointer will reveal that
     an internal error will be generated when the host and target
     pointer sizes are different.  */
@


1.41.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 4

   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

d42 1
a42 1
#include "gdb_wait.h"
a44 2
#include "gdb_assert.h"
#include "inflow.h"
a2843 13
/* Convert a target address (a.k.a. CORE_ADDR) into a host address
   (a.k.a void pointer)!  */

static void *
procfs_address_to_host_pointer (CORE_ADDR addr)
{
  void *ptr;

  gdb_assert (sizeof (ptr) == TYPE_LENGTH (builtin_type_void_data_ptr));
  ADDRESS_TO_POINTER (builtin_type_void_data_ptr, &ptr, addr);
  return ptr;
}

a2865 3
  /* NOTE: cagney/2003-02-01: Even more horrible hack.  Need to
     convert a target address into something that can be stored in a
     native data structure.  */
d2867 1
a2867 1
  pwatch->pr_vaddr  = (uintptr_t) procfs_address_to_host_pointer (addr);
d2869 1
a2869 1
  pwatch->pr_vaddr  = (caddr_t) procfs_address_to_host_pointer (addr);
d3687 2
a3688 2
	  (DEPRECATED_NPC_REGNUM >= 0 && regno == DEPRECATED_NPC_REGNUM) ||
	  regno == DEPRECATED_FP_REGNUM  ||
d3761 2
a3762 2
	  (DEPRECATED_NPC_REGNUM >= 0 && regno == DEPRECATED_NPC_REGNUM) ||
	  regno == DEPRECATED_FP_REGNUM  ||
d4145 1
a4145 1
		switch (what) {
d4592 2
d5166 4
a5169 5
     fact that proc_set_watchpoint() calls
     procfs_address_to_host_pointer(); a close inspection of
     procfs_address_to_host_pointer will reveal that an internal error
     will be generated when the host and target pointer sizes are
     different.  */
d5502 1
@


1.41.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d22 1
a22 1
along with this program; if not, write to the Free Software Foundation,
a47 1
#include "gdb_string.h"
a49 1
#include "auxv.h"
d51 1
a51 1
/*
d76 1
a76 1
 * In order to keep most of the code simple and clean, I have
d85 1
a85 1
   The ioctl API defines PIOCSTATUS, while
a129 5
static LONGEST procfs_xfer_partial (struct target_ops *ops,
				    enum target_object object,
				    const char *annex,
				    void *readbuf, const void *writebuf,
				    ULONGEST offset, LONGEST len);
d136 4
a139 4
static int proc_find_memory_regions (int (*) (CORE_ADDR,
					      unsigned long,
					      int, int, int,
					      void *),
d153 1
a153 1
  procfs_ops.to_doc                 =
a166 1
  procfs_ops.to_xfer_partial        = procfs_xfer_partial;
d209 1
a209 1
     enum { READ_WATCHFLAG  = WA_READ,
d216 1
a216 1
     enum { READ_WATCHFLAG  = MA_READ,
d347 1
a347 1
  /* The following four fd fields may be identical, or may contain
d355 1
a355 1
   * However, to avoid a bunch of #ifdefs in the code, we will use
d380 1
a380 1

d420 1
a420 1
static procinfo *
d461 1
a461 1
	error ("procfs: couldn't find pid %d (kernel thread %d) in procinfo list.",
d472 1
a472 1

d479 1
a479 1

d526 1
a526 1
  /*
d531 1
a531 1
   *   There are several file descriptors that may need to be open
d538 1
a538 1
   *   The pathnames for the 'files' for an LWP look slightly
d556 1
a556 1
   *   doesn't need any #ifdef's.
d561 1
a561 1
   *     Each LWP has an independent file descriptor, but these
d620 2
a621 2
   * The ones for the LWPs have to be obtained thru an IOCTL call
   * on the process's file descriptor.
d624 1
a624 1
   * into all of the fields occupied by the several file descriptors
d754 1
a754 1
  else
d852 1
a852 1

d871 1
a871 1

d971 1
a971 1

d977 1
a977 1

d1001 1
a1001 1

d1021 1
a1021 1
 * and the gdb target vector functions.  This layer consists of
d1121 1
a1121 1
      /* Sigh... I have to read a different data structure,
d1124 2
a1125 2
	pi->status_valid = (read (pi->status_fd,
				  (char *) &pi->prstatus.pr_lwp,
d1130 1
a1130 1
	  pi->status_valid = (read (pi->status_fd,
d1139 1
a1139 1
	    pi->status_valid = (read (pi->status_fd,
d1151 1
a1151 1
      pi->status_valid =
d1168 1
a1168 1
	  memcpy (&pi->prstatus, &thread_status.status,
d1181 1
a1181 1
      PROC_PRETTYFPRINT_STATUS (proc_flags (pi),
d1183 1
a1183 1
				proc_what (pi),
d1190 1
a1190 1
  /* In the read/write multiple-fd model,
d1201 1
a1201 1
 */
d1277 1
a1277 1

d1297 1
a1297 1

d1317 1
a1317 1

d1347 1
a1347 1
 * Function: proc_modify_flag
d1349 1
a1349 1
 *  === I appologize for the messiness of this function.
d1371 1
a1371 1
 * Arguments:
d1386 7
a1392 7
  /*
   * These operations affect the process as a whole, and applying
   * them to an individual LWP has the same meaning as applying them
   * to the main process.  Therefore, if we're ever called with a
   * pointer to an LWP's procinfo, let's substitute the process's
   * procinfo and avoid opening the LWP's file descriptor
   * unnecessarily.
d1399 1
a1399 1
  /* First normalize the PCUNSET/PCRESET command opcode
d1466 1
a1466 1
    warning ("procfs: modify_flag failed to turn %s %s",
d1534 1
a1534 1
 * Process will NOT be killed when debugger
d1584 1
a1584 1
 * If one LWP stops because of a debug event (signal etc.),
d1617 1
a1617 1
 * Returns non-zero for success, zero for failure.
d1644 1
a1644 1
	  PROC_PRETTYFPRINT_STATUS (proc_flags (pi),
d1646 1
a1646 1
				    proc_what (pi),
d1659 1
a1659 1
 * Returns non-zero for success, zero for failure.
d1670 1
a1670 1
   * for any reason, then take out the following clause and
d1673 1
a1673 1

d1690 1
a1690 1
      PROC_PRETTYFPRINT_STATUS (proc_flags (pi),
d1692 1
a1692 1
				proc_what (pi),
d1723 1
a1723 1
 * Returns non-zero for success, zero for failure.
d1736 1
a1736 1

d1776 1
a1776 1
 * Returns non-zero for success, zero for failure.
d1787 1
a1787 1
   * for any reason, then take out the following clause and
d1790 1
a1790 1

d1822 1
a1822 1
 * Returns non-zero for success, zero for failure.
d1833 1
a1833 1
   * for any reason, then take out the following clause and
d1836 1
a1836 1

d1866 1
a1866 1
 * Returns non-zero for success, zero for failure.
d1877 1
a1877 1
   * for any reason, then take out the following clause and
d1880 1
a1880 1

d1908 1
a1908 1

d1916 1
a1916 1
 * Returns non-zero for success, zero for failure.
d1927 1
a1927 1
   * for any reason, then take out the following clause and
d1930 1
a1930 1

d1966 1
a1966 1
 * Returns non-zero for success, zero for failure.
d1977 1
a1977 1
   * for any reason, then take out the following clause and
d1980 1
a1980 1

d2020 1
a2020 1
   * for any reason, then take out the following clause and
d2023 1
a2023 1

d2057 1
a2057 1
   * for any reason, then take out the following clause and
d2060 1
a2060 1

d2094 1
a2094 1
   * for any reason, then take out the following clause and
d2097 1
a2097 1

d2140 1
a2140 1
   * for any reason, then take out the following clause and
d2143 1
a2143 1

d2182 1
a2182 1
   * for any reason, then take out the following clause and
d2185 1
a2185 1

d2216 1
a2216 1
   * for any reason, then take out the following clause and
d2219 1
a2219 1

d2250 1
a2250 1
   * for any reason, then take out the following clause and
d2253 1
a2253 1

d2292 1
a2292 1
   * for any reason, then take out the following clause and
d2295 1
a2295 1

d2365 1
a2365 1
   * for any reason, then take out the following clause and
d2368 1
a2368 1

d2438 1
a2438 1
   * for any reason, then take out the following clause and
d2441 1
a2441 1

d2484 1
a2484 1
   * for any reason, then take out the following clause and
d2487 1
a2487 1

d2494 1
a2494 1
   * it messes up the current signal. Work around the kernel bug.
d2534 1
a2534 1
   * for any reason, then take out the following clause and
d2537 1
a2537 1

d2584 1
a2584 1
   * There's three cases instead of two, because
d2834 1
a2834 1
   * for any reason, then take out the following clause and
d2837 1
a2837 1

d2870 1
a2870 1
#if !defined (TARGET_HAS_HARDWARE_WATCHPOINTS)
d2978 1
a2978 1
      ldt_entry = (struct ssd *)
d2982 1
a2982 1

d3010 1
a3010 1
 * Function: proc_get_nthreads
d3012 1
a3012 1
 * Return the number of threads for the process
d3019 1
a3019 1
int
d3043 1
a3043 1
   * NEW_PROC_API: only works for the process procinfo,
d3046 1
a3046 1
#ifdef NEW_PROC_API
d3084 1
a3084 1
   * an LWP, it will simply return that LWP's ID.  In that case,
d3087 1
a3087 1

d3107 1
a3107 1
int
d3121 1
a3121 1
int
d3131 1
a3131 1
 * Function: proc_update_threads
d3168 1
a3168 1
   * for any reason, then take out the following clause and
d3171 1
a3171 1

d3223 1
a3223 1
   * for any reason, then take out the following clause and
d3226 1
a3226 1

d3235 2
a3236 2
   * Note: this brute-force method is the only way I know of
   * to accomplish this task on Unixware.  This method will
d3264 1
a3264 1
int
d3273 1
a3273 1
   * for any reason, then take out the following clause and
d3276 1
a3276 1

d3287 1
a3287 1

d3325 2
a3326 2
 * a quick pass over the currently-known procinfos.
 *
d3347 1
a3347 1
   * for any reason, then take out the following clause and
d3350 1
a3350 1

d3507 1
a3507 1
static void
d3525 1
a3525 1
	printf_filtered ("Attaching to program `%s', %s\n",
d3537 1
a3537 1
static void
d3554 1
a3554 1

d3572 1
a3572 1
      sprintf (errmsg, "do_attach: couldn't open /proc file for process %d",
d3604 1
a3604 1
    dead_procinfo (pi, "do_attach: couldn't save traced syscall exits.",
d3688 2
a3689 2
  /* If the event thread is not the same as GDB's requested thread
     (ie. inferior_ptid), then look up procinfo for the requested
d3691 1
a3691 1
  if ((tid != 0) &&
d3696 1
a3696 1
    error ("procfs: fetch_registers failed to find procinfo for %s",
d3706 5
a3710 4
      if ((regno >= 0 && regno < FP0_REGNUM)
	  || regno == PC_REGNUM
	  || regno == DEPRECATED_FP_REGNUM
	  || regno == SP_REGNUM)
d3737 1
a3737 1
 * Since the /proc interface will not read individual registers,
d3763 1
a3763 1
  if ((tid != 0) &&
d3780 5
a3784 4
      if ((regno >= 0 && regno < FP0_REGNUM)
	  || regno == PC_REGNUM
	  || regno == DEPRECATED_FP_REGNUM
	  || regno == SP_REGNUM)
d3943 1
a3943 1
	     is gone (child terminated), then we skip this block,
d3984 1
a3984 1
		       Make it runnable, resume it, then use
d3986 1
a3986 1
		       Proc_run_process always clears the current
d3991 1
a3991 1
		    /* FIXME: what we should do is return
d3997 1
a3997 1
			/* Don't call wait: simulate waiting for exit,
d4033 1
a4033 1
			    printf_filtered ("#%ld: 0x%08lx\n",
d4104 1
a4104 1
		       that threads were actually separate processes.
d4121 1
a4121 1
			    printf_filtered ("#%ld: 0x%08lx\n",
d4152 1
a4152 1
			printf_filtered ("[New %s]\n",
d4230 1
a4230 1
		   * We have a new thread.
d4232 1
a4232 1
		   * If we don't create a procinfo, resume may be unhappy
d4241 1
a4241 1
		   * new thread we've seen, in which case we may not
d4248 1
a4248 1
		      if (find_procinfo (PIDGET (inferior_ptid),
d4250 1
a4250 1
			create_procinfo (PIDGET (inferior_ptid),
a4271 34
/* Perform a partial transfer to/from the specified object.  For
   memory transfers, fall back to the old memory xfer functions.  */

static LONGEST
procfs_xfer_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, void *readbuf,
		     const void *writebuf, ULONGEST offset, LONGEST len)
{
  switch (object)
    {
    case TARGET_OBJECT_MEMORY:
      if (readbuf)
	return (*ops->to_xfer_memory) (offset, readbuf, len, 0/*write*/,
				       NULL, ops);
      if (writebuf)
	return (*ops->to_xfer_memory) (offset, readbuf, len, 1/*write*/,
				       NULL, ops);
      return -1;

#ifdef NEW_PROC_API
    case TARGET_OBJECT_AUXV:
      return procfs_xfer_auxv (ops, object, annex, readbuf, writebuf,
			       offset, len);
#endif

    default:
      if (ops->beneath != NULL)
	return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					      readbuf, writebuf, offset, len);
      return -1;
    }
}


d4330 1
a4330 1
 * File descriptors are also cached.
d4338 1
a4338 1
 * As this function is called by iterate_over_threads, it always
d4362 1
a4362 1
	  proc_warn (pi, "target_resume, set_fpregs",
d4369 1
a4369 1
	 Close any file descriptors that it might have open.
d4417 1
a4417 1
 *  step:  if true, then arrange for the child to stop again
d4420 1
a4420 1
 *         If non-zero, then arrange for the indicated signal
d4433 1
a4433 1
  /* 2.1:
d4435 1
a4435 1
     prrun.pr_vaddr = $PC;	   set resume address
d4437 1
a4437 1
     prrun.prflags |= PRSFAULT;    trace faults in pr_fault (all but PAGE)
d4466 1
a4466 1
  proc_iterate_over_threads (pi, invalidate_cache, NULL);
d4486 1
a4486 1
	      proc_iterate_over_threads (pi,
d4507 1
a4507 1
 * Traverse the list of signals that GDB knows about
d4559 1
a4559 1
		   attach_flag? "attached": "child",
d4578 1
a4578 1
 * This tells GDB that this target vector can be invoked
d4595 1
a4595 1

d4620 1
a4620 1
 * Note: this should only be applied to the real process,
d4667 1
a4667 1
    /* FIXME: should we use waitpid to make sure we get the right event?
d4687 1
a4687 1
static void
d4707 1
a4707 1
static void
d4726 1
a4726 1
 * When GDB forks to create a runnable inferior process,
d4732 1
a4732 1
static void
d4917 1
a4917 1
  /* FIXME: No need to destroy the procinfo --
d4926 1
a4926 1
 * Its only real responsibility is to set things up for the fork,
d4929 1
a4929 1
 *
d5010 1
a5010 1
  fork_inferior (exec_file, allargs, env, procfs_set_exec_trap,
d5040 1
a5040 1
 * Query all the threads that the target knows about,
d5055 1
a5055 1
/*
d5090 1
a5090 1
 * Return a string to be used to identify the thread in
d5117 1
a5117 1
int
d5124 1
a5124 1
  procinfo *pi;
d5126 1
a5126 1
  pi = find_procinfo_or_die (PIDGET (ptid) == -1 ?
d5171 1
a5171 1

d5211 1
a5211 1
  pi = find_procinfo_or_die (PIDGET (ptid) == -1 ?
d5220 1
a5220 1
	{
d5236 1
a5236 1
 * Function: procfs_find_LDT_entry
d5278 1
a5278 1
/*
d5292 1
a5292 1
 * Return: First non-zero return value from the callback function,
d5297 3
a5299 3
iterate_over_mappings (procinfo *pi, int (*child_func) (), void *data,
		       int (*func) (struct prmap *map,
				    int (*child_func) (),
d5312 1
a5312 1
  /* Get the number of mappings, allocate space,
d5323 1
a5323 1
  /* Use stat to determine the file size, and compute
d5353 4
a5356 4
 * Calls the supplied callback function once for each mapped address
 * space in the process.  The callback function  receives an open
 * file descriptor for the file corresponding to that mapped
 * address space (if there is one), and the base address of the
d5364 1
a5364 1
int solib_mappings_callback (struct prmap *map,
d5387 1
a5387 1
	 we just pass the FD on as given.  Sometimes there is
d5394 1
a5394 1
     we just pass the FD on as given.  Sometimes there is
d5408 1
a5408 1
 * mapped address space in the process.  The callback function
d5433 3
a5435 3
 *   int callback (CORE_ADDR vaddr,
 *                 unsigned long size,
 *                 int read, int write, int execute,
d5442 4
a5445 4
find_memory_regions_callback (struct prmap *map,
			      int (*func) (CORE_ADDR,
					   unsigned long,
					   int, int, int,
d5450 1
a5450 1
		  map->pr_size,
d5453 1
a5453 1
		  (map->pr_mflags & MA_EXEC) != 0,
d5463 1
a5463 1
 *	unsigned long size,
d5467 1
a5467 1
 *
d5473 4
a5476 4
proc_find_memory_regions (int (*func) (CORE_ADDR,
				       unsigned long,
				       int, int, int,
				       void *),
d5481 1
a5481 1
  return iterate_over_mappings (pi, func, data,
d5532 1
a5532 1
  printf_filtered (data_fmt_string,
d5537 1
a5537 1
		   (unsigned int) map->pr_offset,
d5566 1
a5566 1
  printf_filtered (header_fmt_string,
d5636 1
a5636 1
	   /* No.  So open a procinfo for it, but
d5654 1
a5654 1
	printf_filtered ("Process has %d threads.\n",
d5716 1
a5716 1
static void
d5722 1
a5722 1
static void
d5728 1
a5728 1
static void
d5734 1
a5734 1
static void
d5746 1
a5746 1
  add_info ("proc", info_proc_cmd,
d5750 1
a5750 1
  add_com ("proc-trace-entry", no_class, proc_trace_sysentry_cmd,
d5752 1
a5752 1
  add_com ("proc-trace-exit", no_class, proc_trace_sysexit_cmd,
d5754 1
a5754 1
  add_com ("proc-untrace-entry", no_class, proc_untrace_sysentry_cmd,
d5756 1
a5756 1
  add_com ("proc-untrace-exit", no_class, proc_untrace_sysexit_cmd,
d5785 1
a5785 1
procfs_do_thread_registers (bfd *obfd, ptid_t ptid,
d5799 1
a5799 1
						merged_pid,
d5806 1
a5806 1
					       merged_pid,
d5834 2
a5835 2
      args->note_data = procfs_do_thread_registers (args->obfd, inferior_ptid,
						    args->note_data,
a5853 2
  char *auxv;
  int auxv_len;
d5858 1
a5858 1
      strncpy (psargs, get_exec_file (0),
d5865 1
a5865 1
	  strncat (psargs, " ",
d5867 1
a5867 1
	  strncat (psargs, inf_args,
d5872 4
a5875 4
  note_data = (char *) elfcore_write_prpsinfo (obfd,
					       note_data,
					       note_size,
					       fname,
d5880 2
a5881 2
  note_data = elfcore_write_pstatus (obfd, note_data, note_size,
				     PIDGET (inferior_ptid),
d5894 1
a5894 1
      note_data = procfs_do_thread_registers (obfd, inferior_ptid,
a5899 8
    }

  auxv_len = target_auxv_read (&current_target, &auxv);
  if (auxv_len > 0)
    {
      note_data = elfcore_write_note (obfd, note_data, note_size,
				      "CORE", NT_AUXV, auxv, auxv_len);
      xfree (auxv);
@


1.41.2.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 4

   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

d42 1
a42 1
#include "gdb_wait.h"
a44 2
#include "gdb_assert.h"
#include "inflow.h"
a2843 13
/* Convert a target address (a.k.a. CORE_ADDR) into a host address
   (a.k.a void pointer)!  */

static void *
procfs_address_to_host_pointer (CORE_ADDR addr)
{
  void *ptr;

  gdb_assert (sizeof (ptr) == TYPE_LENGTH (builtin_type_void_data_ptr));
  ADDRESS_TO_POINTER (builtin_type_void_data_ptr, &ptr, addr);
  return ptr;
}

a2865 3
  /* NOTE: cagney/2003-02-01: Even more horrible hack.  Need to
     convert a target address into something that can be stored in a
     native data structure.  */
d2867 1
a2867 1
  pwatch->pr_vaddr  = (uintptr_t) procfs_address_to_host_pointer (addr);
d2869 1
a2869 1
  pwatch->pr_vaddr  = (caddr_t) procfs_address_to_host_pointer (addr);
d4592 2
d5166 4
a5169 5
     fact that proc_set_watchpoint() calls
     procfs_address_to_host_pointer(); a close inspection of
     procfs_address_to_host_pointer will reveal that an internal error
     will be generated when the host and target pointer sizes are
     different.  */
@


1.41.2.2
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d3709 1
a3709 1
	  regno == DEPRECATED_FP_REGNUM  ||
d3783 1
a3783 1
	  regno == DEPRECATED_FP_REGNUM  ||
@


1.41.2.3
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d3708 1
a3708 1
	  (DEPRECATED_NPC_REGNUM >= 0 && regno == DEPRECATED_NPC_REGNUM) ||
d3782 1
a3782 1
	  (DEPRECATED_NPC_REGNUM >= 0 && regno == DEPRECATED_NPC_REGNUM) ||
@


1.41.2.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d5522 1
@


1.41.2.5
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d4166 1
a4166 1
		switch (what) {
@


1.41.2.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d3706 5
a3710 4
      if ((regno >= 0 && regno < FP0_REGNUM)
	  || regno == PC_REGNUM
	  || regno == DEPRECATED_FP_REGNUM
	  || regno == SP_REGNUM)
d3780 5
a3784 4
      if ((regno >= 0 && regno < FP0_REGNUM)
	  || regno == PC_REGNUM
	  || regno == DEPRECATED_FP_REGNUM
	  || regno == SP_REGNUM)
@


1.40
log
@	Fix PR gdb/393:
	* inflow.c (terminal_save_ours): New function to save terminal
	settings.
	* inferior.h (terminal_save_ours): Declare.
	* target.c (debug_to_terminal_save_ours): New function.
	(cleanup_target): Defaults to_terminal_save_ours.
	(update_current_target): Inherit to_terminal_save_ours.
	(setup_target_debug): Set to_terminal_save_ours.
	* target.h (target_terminal_save_ours): New to save terminal settings.
	(target_ops): New member to_terminal_save_ours.
	* gnu-nat.c (init_gnu_ops): Set to_terminal_save_ours.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* inftarg.c (init_child_ops): Likewise.
	* m3-nat.c (init_m3_ops): Likewise.
	* procfs.c (init_procfs_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* sol-thread.c (init_sol_thread_ops): Likewise.
@
text
@d3630 3
@


1.39
log
@	* procfs.c (procfs_can_use_hw_breakpoint): New function.
	(init_procfs_ops): Define ``to_can_use_hw_breakpoint'' for procfs
	target vector.
	* config/mips/nm-irix5.h (TARGET_CAN_USE_HARDWARE_WATCHPOINT):
	Delete.  Add comment regarding this now-deleted target method.
@
text
@d173 1
@


1.38
log
@Fix some K&R isms.
@
text
@d139 2
d188 1
d5142 31
@


1.37
log
@2002-02-13  Michael Snyder  <msnyder@@redhat.com>

	* gcore.c (gcore_command): Use gcore_default_target instead of NULL.
	(default_gcore_mach): Just return 0, work around a problem in bfd.
	(default_gcore_target): OK to return NULL if exec_bfd is null.
	(make_mem_sec): Use a cast, avoid a warning.

	* procfs.c (find_memory_regions_callback): Use a cast instead of
	calling host_pointer_to_address (which complains if
	sizeof (host pointer) != sizeof (target pointer)).
	(procfs_make_note_section): Avoid overflow in psargs string.
@
text
@d5434 1
a5434 2
mappingflags (flags)
     long flags;
@


1.37.8.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d5434 2
a5435 1
mappingflags (long flags)
@


1.37.8.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a138 2
static int procfs_can_use_hw_breakpoint (int, int, int);

a170 1
  procfs_ops.to_terminal_save_ours  = terminal_save_ours;
a185 1
  procfs_ops.to_can_use_hw_breakpoint = procfs_can_use_hw_breakpoint;
a5138 31
}

/* Return non-zero if we can set a hardware watchpoint of type TYPE.  TYPE
   is one of bp_hardware_watchpoint, bp_read_watchpoint, bp_write_watchpoint,
   or bp_hardware_watchpoint.  CNT is the number of watchpoints used so
   far.
   
   Note:  procfs_can_use_hw_breakpoint() is not yet used by all
   procfs.c targets due to the fact that some of them still define
   TARGET_CAN_USE_HARDWARE_WATCHPOINT.  */

static int
procfs_can_use_hw_breakpoint (int type, int cnt, int othertype)
{
#ifndef TARGET_HAS_HARDWARE_WATCHPOINTS
  return 0;
#else
  /* Due to the way that proc_set_watchpoint() is implemented, host
     and target pointers must be of the same size.  If they are not,
     we can't use hardware watchpoints.  This limitation is due to the
     fact that proc_set_watchpoint() calls address_to_host_pointer();
     a close inspection of address_to_host_pointer will reveal that
     an internal error will be generated when the host and target
     pointer sizes are different.  */
  if (sizeof (void *) != TYPE_LENGTH (builtin_type_void_data_ptr))
    return 0;

  /* Other tests here???  */

  return 1;
#endif
@


1.37.8.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a3629 3
	if (signo == 0 && !proc_clear_current_signal (pi))
	  proc_warn (pi, "do_detach, clear_current_signal", __LINE__);

@


1.36
log
@2002-02-13  Michael Snyder  <msnyder@@redhat.com>

	* procfs.c (procfs_make_note_section): Make the default
	implementation return an error.

2002-02-13  Rodney Brown  <rbrown64@@csc.com.au>

	* procfs.c (procfs_make_note_section): Provide a default definition
	(for alpha-dec-osf4.0f). Fix typos.

2002-02-11  Michael Snyder  <msnyder@@redhat.com>

	* procfs.c: Include elf-bfd.h (for elfcore_write functions).
	(gcore section): Ifdef for Solaris and Unixware only.
	(procfs_do_thread_registers): Unixware needs one lwpstatus
	per thread (not one prstatus or pstatus).
	(procfs_make_note_section): Iterate only over kernel threads (lwps),
	not over all gdb threads.  For unixware, call elfcore_write_pstatus
	once before iterating over threads.
@
text
@d5391 1
a5391 1
  return (*func) (host_pointer_to_address ((void *) map->pr_vaddr),
d5796 1
d5804 4
a5807 1
      if (get_inferior_args ())
d5811 1
a5811 1
	  strncat (psargs, get_inferior_args (), 
@


1.35
log
@2002-01-03  Michael Snyder  <msnyder@@redhat.com>

	Implement a "generate-core-file" command in gdb, save target state.
	* gcore.c: New file.  Implement new command 'generate-core-file'.
	Save a corefile image of the current state of the inferior.
	* linux-proc.c: Add linux-specific code for saving corefiles.
	* target.h (struct target_ops): Add new target vectors for saving
	corefiles; to_find_memory_regions and to_make_corefile_notes.
	(target_find_memory_regions): New macro.
	(target_make_corefile_notes): New macro.
	* target.c (update_current_target): Inherit new target methods.
	(dummy_find_memory_regions): New place-holder method.
	(dummy_make_corefile_notes): New place-holder method.
	(init_dummy_target): Initialize new dummy target vectors.
	* exec.c (exec_set_find_memory_regions): New function.
	Allow the exec_ops vector for memory regions to be taken over.
	(exec_make_note_section): New function, target vector method.
	* defs.h (exec_set_find_memory_regions): Export prototype.
	* procfs.c (proc_find_memory_regions): New function, corefile method.
	(procfs_make_note_section): New function, corefile method.
	(init_procfs_ops): Set new target vector pointers.
	(find_memory_regions_callback): New function.
	(procfs_do_thread_registers): New function.
	(procfs_corefile_thread_callback): New function.
	* sol-thread.c (sol_find_memory_regions): New function.
	(sol_make_note_section): New function.
	(init_sol_thread_ops): Initialize new target vectors.
	* inftarg.c (inftarg_set_find_memory_regions): New function.
	Allow to_find_memory_regions vector to be taken over.
	(inftarg_set_make_corefile_notes): New function.
	Allow to_make_corefile_notes vector to be taken over.
	* thread-db.c (thread_db_new_objfile): Don't activate thread-db
	interface layer if not target_has_execution (may be a corefile).
	* config/i386/linux.mh: Add gcore.o to NATDEPFILES.
	* config/sparc/sun4sol2.mh: Ditto.
	* config/alpha/alpha-linux.mh: Ditto.
	* config/arm/linux.mh: Ditto.
	* config/i386/x86-64linux.mh: Ditto.
	* config/ia64/linux.mh: Ditto.
	* config/m68k/linux.mh: Ditto.
	* config/mips/linux.mh: Ditto.
	* config/powerpc/linux.mh: Ditto.
	* config/sparc/linux.mh: Ditto.
@
text
@d26 1
d59 1
a59 1
 * /proc works by immitating a file system: you open a simulated file
d5708 1
a5708 1
/* miscelaneous stubs:                                             */
d5725 2
d5739 8
d5748 2
a5749 2
                                               note_data,
                                               note_size,
d5752 2
a5753 1
                                               &gregs);
d5770 1
a5770 1
procfs_corefile_thread_callback (struct thread_info *ti, void *data)
a5772 1
  procinfo *pi = find_procinfo (PIDGET (ti->ptid), TIDGET (ti->ptid));
d5774 1
a5774 1
  if (pi != NULL && TIDGET (ti->ptid) != 0)
d5777 2
a5778 2
      inferior_ptid = ti->ptid;
      args->note_data = procfs_do_thread_registers (args->obfd, ti->ptid, 
d5818 7
d5828 2
a5829 1
  iterate_over_threads (procfs_corefile_thread_callback, &thread_args);
d5845 8
a5852 1

@


1.34
log
@2001-12-28  Michael Snyder  <msnyder@@redhat.com>

	Abstract the functionality of iterating over mapped memory
	regions into a general purpose iterator function.
	* procfs.c (iterate_over_mappings): New function, general purpose
	iterator for memory sections.
	(proc_iterate_over_mappings): Reimplement using iterate_over_mappings.
	(solib_mappings_callback): New function, callback for above.
	(info_proc_mappings): Reimpliment using iterate_over_mappings.
	(info_mappings_callback): New function, callback for above.

	* procfs.c (proc_set_watchpoint): Add cast to suppress warning.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d130 8
d143 3
a145 3
  procfs_ops.to_shortname          = "procfs";
  procfs_ops.to_longname           = "Unix /proc child process";
  procfs_ops.to_doc                = 
d147 18
a164 18
  procfs_ops.to_open               = procfs_open;
  procfs_ops.to_can_run            = procfs_can_run;
  procfs_ops.to_create_inferior    = procfs_create_inferior;
  procfs_ops.to_kill               = procfs_kill_inferior;
  procfs_ops.to_mourn_inferior     = procfs_mourn_inferior;
  procfs_ops.to_attach             = procfs_attach;
  procfs_ops.to_detach             = procfs_detach;
  procfs_ops.to_wait               = procfs_wait;
  procfs_ops.to_resume             = procfs_resume;
  procfs_ops.to_prepare_to_store   = procfs_prepare_to_store;
  procfs_ops.to_fetch_registers    = procfs_fetch_registers;
  procfs_ops.to_store_registers    = procfs_store_registers;
  procfs_ops.to_xfer_memory        = procfs_xfer_memory;
  procfs_ops.to_insert_breakpoint  =  memory_insert_breakpoint;
  procfs_ops.to_remove_breakpoint  =  memory_remove_breakpoint;
  procfs_ops.to_notice_signals     = procfs_notice_signals;
  procfs_ops.to_files_info         = procfs_files_info;
  procfs_ops.to_stop               = procfs_stop;
d166 2
a167 2
  procfs_ops.to_terminal_init      = terminal_init_inferior;
  procfs_ops.to_terminal_inferior  = terminal_inferior;
d169 2
a170 2
  procfs_ops.to_terminal_ours      = terminal_ours;
  procfs_ops.to_terminal_info      = child_terminal_info;
d172 14
a185 12
  procfs_ops.to_find_new_threads   = procfs_find_new_threads;
  procfs_ops.to_thread_alive       = procfs_thread_alive;
  procfs_ops.to_pid_to_str         = procfs_pid_to_str;

  procfs_ops.to_has_all_memory     = 1;
  procfs_ops.to_has_memory         = 1;
  procfs_ops.to_has_execution      = 1;
  procfs_ops.to_has_stack          = 1;
  procfs_ops.to_has_registers      = 1;
  procfs_ops.to_stratum            = process_stratum;
  procfs_ops.to_has_thread_control = tc_schedlock;
  procfs_ops.to_magic              = OPS_MAGIC;
d5368 59
d5722 106
@


1.33
log
@2001-12-21  Michael Snyder  <msnyder@@redhat.com>

	* procfs.c (info_proc_cmd): Add the 'mappings' sub-command that
	was dropped a few years ago, when procfs.c was rewritten.
	(info_proc_mappings): New function, implement 'info proc mappings'.
	(mappingflags): New function.
	(_initialize_procfs): Document new option to 'info proc' command.
@
text
@d2851 5
a2855 1
  pwatch->pr_vaddr  = address_to_host_pointer (addr);
a2871 109
/*
 * Function: proc_iterate_over_mappings
 *
 * Given a pointer to a function, call that function once for every
 * mapped address space in the process.  The callback function 
 * receives an open file descriptor for the file corresponding to
 * that mapped address space (if there is one), and the base address
 * of the mapped space.  Quit when the callback function returns a
 * nonzero value, or at teh end of the mappings.
 *
 * Returns: the first non-zero return value of the callback function,
 * or zero.
 */

int
proc_iterate_over_mappings (int (*func) (int, CORE_ADDR))
{
  struct prmap *map;
  procinfo *pi;
#ifndef NEW_PROC_API	/* avoid compiler warning */
  int nmaps = 0;
  int i;
#else
  int map_fd;
  char pathname[MAX_PROC_NAME_SIZE];
#endif
  int funcstat = 0;
  int fd;

  pi = find_procinfo_or_die (PIDGET (inferior_ptid), 0);

#ifdef NEW_PROC_API
  /* Open map fd.  */
  sprintf (pathname, "/proc/%d/map", pi->pid);
  if ((map_fd = open_with_retry (pathname, O_RDONLY)) < 0)
    proc_error (pi, "proc_iterate_over_mappings (open)", __LINE__);

  /* Make sure it gets closed again.  */
  make_cleanup_close (map_fd);

  /* Allocate space for mapping (lifetime only for this function). */
  map = alloca (sizeof (struct prmap));

  /* Now read the mappings from the file, 
     open a file descriptor for those that have a name, 
     and call the callback function.  */
  while (read (map_fd, 
	       (void *) map, 
	       sizeof (struct prmap)) == sizeof (struct prmap))
    {
      char name[MAX_PROC_NAME_SIZE + sizeof (map->pr_mapname)];

      if (map->pr_vaddr == 0 && map->pr_size == 0)
	break;		/* sanity */

      if (map->pr_mapname[0] == 0)
	{
	  fd = -1;	/* no map file */
	}
      else
	{
	  sprintf (name, "/proc/%d/object/%s", pi->pid, map->pr_mapname);
	  /* Note: caller's responsibility to close this fd!  */
	  fd = open_with_retry (name, O_RDONLY);
	  /* Note: we don't test the above call for failure;
	     we just pass the FD on as given.  Sometimes there is 
	     no file, so the ioctl may return failure, but that's
	     not a problem.  */
	}

      /* Stop looping if the callback returns non-zero.  */
      if ((funcstat = (*func) (fd, (CORE_ADDR) map->pr_vaddr)) != 0)
	break;
    }  
#else
  /* Get the number of mapping entries.  */
  if (ioctl (pi->ctl_fd, PIOCNMAP, &nmaps) < 0)
    proc_error (pi, "proc_iterate_over_mappings (PIOCNMAP)", __LINE__);

  /* Allocate space for mappings (lifetime only this function).  */
  map = (struct prmap *) alloca ((nmaps + 1) * sizeof (struct prmap));

  /* Read in all the mappings.  */
  if (ioctl (pi->ctl_fd, PIOCMAP, map) < 0)
    proc_error (pi, "proc_iterate_over_mappings (PIOCMAP)", __LINE__);

  /* Now loop through the mappings, open an fd for each, and
     call the callback function.  */
  for (i = 0; 
       i < nmaps && map[i].pr_size != 0; 
       i++)
    {
      /* Note: caller's responsibility to close this fd!  */
      fd = ioctl (pi->ctl_fd, PIOCOPENM, &map[i].pr_vaddr);
      /* Note: we don't test the above call for failure;
	 we just pass the FD on as given.  Sometimes there is 
	 no file, so the ioctl may return failure, but that's
	 not a problem.  */

      /* Stop looping if the callback returns non-zero.  */
      funcstat = (*func) (fd, host_pointer_to_address (map[i].pr_vaddr));
      if (funcstat != 0)
	break;
    }
#endif

  return funcstat;
}

d5206 152
d5390 31
d5429 1
a5429 9
  char *header_fmt_string, *data_fmt_string;
  char pathname[MAX_PROC_NAME_SIZE];
  struct prmap *prmaps;
  struct prmap *prmap;
  int map_fd;
  int nmap;
#ifdef NEW_PROC_API
  struct stat sbuf;
#endif
d5432 1
a5432 4
    {
      header_fmt_string = "\t%10s %10s %10s %10s %7s\n";
      data_fmt_string   = "\t%#10lx %#10lx %#10x %#10x %7s\n";
    }
d5434 1
a5434 4
    {
      header_fmt_string = "  %18s %18s %10s %10s %7s\n";
      data_fmt_string   = "  %#18lx %#18lx %#10x %#10x %7s\n";
    }
a5438 29
  /* Get the number of mappings, allocate space, 
     and read the mappings into prmaps.  */
#ifdef NEW_PROC_API
  /* Open map fd. */
  sprintf (pathname, "/proc/%d/map", pi->pid);
  if ((map_fd = open (pathname, O_RDONLY)) < 0)
    return;		/* Can't open map file. */
  /* Make sure it gets closed again. */
  make_cleanup_close (map_fd);

  /* Use stat to determine the file size, and compute 
     the number of prmap_t objects it contains.  */
  if (fstat (map_fd, &sbuf) != 0)
    return;		/* Can't stat file.  */

  nmap = sbuf.st_size / sizeof (prmap_t);
  prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));
  if (read (map_fd, (char *) prmaps, nmap * sizeof (*prmaps))
      != (nmap * sizeof (*prmaps)))
    return;		/* Can't read file. */
#else
  /* Use ioctl command PIOCNMAP to get number of mappings.  */
  if (ioctl (pi->ctl_fd, PIOCNMAP, &nmap) != 0)
    return;	/* Can't get number of mappings.  */
  prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));
  if (ioctl (pi->ctl_fd, PIOCMAP, prmaps) != 0)
    return;	/* Can't read mappings. */
#endif

d5447 1
a5447 14
  for (prmap = prmaps; nmap > 0; prmap++, nmap--)
    {
      printf_filtered (data_fmt_string, 
		       (unsigned long) prmap->pr_vaddr,
		       (unsigned long) prmap->pr_vaddr
		       + prmap->pr_size - 1,
		       prmap->pr_size,
#ifdef PCAGENT		/* Gross hack: only defined on Solaris 2.6+ */
		       (unsigned int) prmap->pr_offset, 
#else
		       prmap->pr_off,
#endif
		       mappingflags (prmap->pr_mflags));
    }
@


1.32
log
@Allocate/free space associated with saved_entryset and saved_exitset.
@
text
@a2881 3
/* FIXME: it's probably a waste to cache this FD. 
   It doesn't get called that often... and if I open it
   every time, I don't need to lseek it.  */
d5310 118
d5429 5
d5439 7
a5445 6
  procinfo *process = NULL;
  procinfo *thread  = NULL;
  char    **argv    = NULL;
  char     *tmp     = NULL;
  int       pid     = 0;
  int       tid     = 0;
d5467 4
d5517 5
d5599 3
a5601 2
	    "Show /proc process information about any running process.\
Default is the process being debugged.");
@


1.31
log
@2001-07-06  Michael Snyder  <msnyder@@redhat.com>

	* procfs.c (procfs_resume): Silence noisy warning.
@
text
@d677 3
d749 2
@


1.30
log
@Redefine ptid_t to be a struct rather than an int.
@
text
@d4538 1
a4538 4
      if (thread == NULL)
	warning ("procfs: resume can't find thread %ld -- resuming all.",
		 TIDGET (ptid));
      else
@


1.29
log
@Phase 1 of the ptid_t changes.
@
text
@a317 12

/* Provide default composite pid manipulation macros for systems that
   don't have threads. */

#ifndef PIDGET
#define PIDGET(PID)		(PID)
#define TIDGET(PID)		(PID)
#endif
#ifndef MERGEPID
#define MERGEPID(PID, TID)	(PID)
#endif

@


1.28
log
@Add code to retry certain open()s.
@
text
@d109 1
a109 1
static void procfs_resume (int, int, enum target_signal);
d115 1
a115 1
static void procfs_notice_signals (int);
d120 1
a120 1
static int procfs_wait (int, struct target_waitstatus *);
d125 1
a125 1
static int procfs_thread_alive (int);
d128 1
a128 1
char *procfs_pid_to_str (int);
d2907 1
a2907 1
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
d3453 1
a3453 1
static int do_attach (int pid);
d3605 1
a3605 1
			 exec_file, target_pid_to_str (pid));
d3607 2
a3608 1
	printf_filtered ("Attaching to %s\n", target_pid_to_str (pid));
d3612 1
a3612 1
  inferior_pid = do_attach (pid);
d3628 1
a3628 1
	      exec_file, target_pid_to_str (inferior_pid));
d3635 1
a3635 1
  inferior_pid = 0;
d3639 2
a3640 2
static int
do_attach (int pid)
d3645 1
a3645 1
  if ((pi = create_procinfo (pid, 0)) == NULL)
d3652 1
a3652 1
	       pid);
d3702 1
a3702 1
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);	/* FIXME: threads */
d3758 2
a3759 2
  pid = PIDGET (inferior_pid);
  tid = TIDGET (inferior_pid);
d3765 1
a3765 1
     (ie. inferior_pid), then look up procinfo for the requested 
d3773 1
a3773 1
	   target_pid_to_str (inferior_pid));
d3830 2
a3831 2
  pid = PIDGET (inferior_pid);
  tid = TIDGET (inferior_pid);
d3837 1
a3837 1
     (ie. inferior_pid), then find procinfo for the requested thread.  */
d3845 1
a3845 1
	   target_pid_to_str (inferior_pid));
d3951 2
a3952 2
static int  
procfs_wait (int pid, struct target_waitstatus *status)
d3956 3
a3958 2
  int       temp, wstat;
  int       retval;
d3966 1
a3966 1
  retval   = -1;
d3969 1
a3969 1
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
d3990 2
d3993 1
a3993 1
	      retval = wait (&wstat);	/* "wait" for the child's exit  */
d3995 1
a3995 1
	      if (retval != PIDGET (inferior_pid))	/* wrong child? */
d3997 1
a3997 1
		       inferior_pid, retval);
d4000 1
d4077 1
a4077 1
			retval = inferior_pid;  /* ? ? ? */
d4092 1
a4092 1
			  retval = temp;
d4119 1
a4119 1
			return inferior_pid;
d4124 1
a4124 1
			target_resume (pid, 0, TARGET_SIGNAL_0);
d4150 3
a4152 3
		    temp = proc_get_current_thread (pi);
		    if (!find_procinfo (pi->pid, temp))
		      create_procinfo  (pi->pid, temp);
d4154 1
a4154 1
		    temp = MERGEPID (pi->pid, temp);
d4156 1
a4156 1
		    if (!in_thread_list (temp))
d4158 3
a4160 2
			printf_filtered ("[New %s]\n", target_pid_to_str (temp));
			add_thread (temp);
d4164 1
a4164 1
		    return inferior_pid;
d4203 1
a4203 1
		    return inferior_pid;
d4220 3
a4222 3
		    temp = proc_get_current_thread (pi);
		    if (!find_procinfo (pi->pid, temp))
		      create_procinfo  (pi->pid, temp);
d4225 2
a4226 2
		    temp = MERGEPID (pi->pid, temp);
		    if (!in_thread_list (temp))
d4229 2
a4230 2
					 target_pid_to_str (temp));
			add_thread (temp);
d4282 1
a4282 1
		  retval = -1;
d4301 2
a4302 2
	      if (retval > 0 &&
		  retval != inferior_pid &&
d4318 1
a4318 1
		   * have created entries for inferior_pid yet.
d4320 1
a4320 1
		  if (TIDGET (inferior_pid) != 0)
d4322 6
a4327 6
		      if (!in_thread_list (inferior_pid))
			add_thread (inferior_pid);
		      if (find_procinfo (PIDGET (inferior_pid), 
					 TIDGET (inferior_pid)) == NULL)
			create_procinfo (PIDGET (inferior_pid), 
					 TIDGET (inferior_pid));
d4366 1
a4366 1
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
d4504 1
a4504 1
procfs_resume (int pid, int step, enum target_signal signo)
d4526 1
a4526 1
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
d4546 1
a4546 1
  if (pid != -1)
d4549 1
a4549 1
      thread = find_procinfo (PIDGET (pid), TIDGET (pid));
d4551 2
a4552 2
	warning ("procfs: resume can't find thread %d -- resuming all.",
		 TIDGET (pid));
d4616 1
a4616 1
procfs_notice_signals (int pid)
d4619 1
a4619 1
  procinfo *pi = find_procinfo_or_die (PIDGET (pid), 0);
d4639 1
a4639 1
		   target_pid_to_str (inferior_pid));
d4771 1
a4771 1
  if (inferior_pid != 0) /* ? */
d4774 1
a4774 1
      procinfo *pi = find_procinfo (PIDGET (inferior_pid), 0);
d4793 1
a4793 1
  if (inferior_pid != 0)
d4796 1
a4796 1
      pi = find_procinfo (PIDGET (inferior_pid), 0);
d4881 1
a4881 1
  inferior_pid = MERGEPID (pi->pid, proc_get_current_thread (pi));
d5110 1
a5110 1
  int gdb_threadid = MERGEPID (pi->pid, thread->tid);
d5131 1
a5131 1
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
d5146 1
a5146 1
procfs_thread_alive (int pid)
d5151 2
a5152 2
  proc    = PIDGET (pid);
  thread  = TIDGET (pid);
d5176 1
a5176 1
procfs_pid_to_str (int pid)
d5182 2
a5183 2
  proc    = PIDGET (pid);
  thread  = TIDGET (pid);
d5199 2
a5200 1
procfs_set_watchpoint (int pid, CORE_ADDR addr, int len, int rwflag, int after)
d5207 2
a5208 2
  pi = find_procinfo_or_die (pid == -1 ? 
			     PIDGET (inferior_pid) : PIDGET (pid), 0);
d5256 1
a5256 1
procfs_stopped_by_watchpoint (int pid)
d5260 2
a5261 2
  pi = find_procinfo (pid == -1 ? 
		      PIDGET (inferior_pid) : PIDGET (pid), 0);
d5288 1
a5288 1
 *   int pid;	// The GDB-style pid-plus-LWP.
d5295 1
a5295 1
procfs_find_LDT_entry (int pid)
d5302 1
a5302 1
  if ((pi = find_procinfo (PIDGET (pid), TIDGET (pid))) == NULL)
d5304 2
a5305 2
      warning ("procfs_find_LDT_entry: could not find procinfi for %d.",
	       pid);
d5311 2
a5312 2
      warning ("procfs_find_LDT_entry: could not read gregs for %d.",
	       pid);
d5363 1
a5363 1
    pid = PIDGET (inferior_pid);
d5412 1
a5412 1
  if (inferior_pid <= 0)
d5418 1
a5418 1
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
d5505 1
a5505 1
int
d5508 1
a5508 4
  if (procinfo_list)
    return procinfo_list->pid;
  else
    return -1;
@


1.27
log
@2001-04-13  Fernando Nasser  <fnasser@@redhat.com>

	From  Adam Mirowski  <Adam.Mirowski@@Sun.COM>
	Fixed Insight on Solaris. It was not possible to debug a process
	because of EINTR "errors".
	* procfs.c: (procfs_wait): if proc_wait_for_stop() fails
	with EINTR, retry the call.
@
text
@d461 34
d580 1
a580 1
    fd = open (tmp, O_WRONLY);
d589 1
a589 1
    fd = open (tmp, O_RDWR);
d599 1
a599 1
    fd = open (tmp, O_RDONLY);
d623 2
a624 1
  if ((fd = open (pi->pathname, O_RDWR)) == 0) /* Only one FD; just open it. */
d629 1
a629 1
      fd = open (pi->pathname, O_RDWR);
d881 1
a881 1
  sysent_fd = open (pathname, O_RDONLY);
d2912 1
a2912 1
  if ((map_fd = open (pathname, O_RDONLY)) < 0)
d2941 1
a2941 1
	  fd = open (name, O_RDONLY);
d3020 1
a3020 1
  if ((fd = open (pathname, O_RDONLY)) < 0)
@


1.26
log
@Add AIX5 procfs support.
@
text
@d3962 2
@


1.25
log
@malloc() -> xmalloc.
Move malloc() decl to utils.c
@
text
@d34 1
d36 2
d39 1
d56 1
d188 1
a188 1
#ifndef UNIXWARE
d203 63
d318 1
d357 4
a360 4
  sigset_t saved_sigset;	/* Saved traced signal set */
  sigset_t saved_sighold;	/* Saved held signal set */
  sysset_t saved_exitset;	/* Saved traced system call exit set */
  sysset_t saved_entryset;	/* Saved traced system call entry set */
d367 5
d393 7
d650 4
d720 3
d783 184
d1007 1
a1007 1
int proc_set_held_signals (procinfo * pi, sigset_t * sighold);
d1011 1
a1011 1
int proc_set_traced_signals (procinfo * pi, sigset_t * sigset);
d1023 4
a1026 5
sigset_t *proc_get_traced_signals (procinfo * pi, sigset_t * save);
sigset_t *proc_get_held_signals (procinfo * pi, sigset_t * save);
sigset_t *proc_get_pending_signals (procinfo * pi, sigset_t * save);
struct sigaction *proc_get_signal_actions (procinfo * pi,
					   struct sigaction *save);
d1356 1
a1356 1
#endif
d1360 1
d1362 1
a1362 1
    long arg[2];
d1588 1
a1588 1
      long cmd = PCSTOP;
d1631 1
a1631 1
    long cmd = PCWSTOP;
d1705 1
a1705 1
    long cmd[2];
d1732 1
a1732 1
proc_set_traced_signals (procinfo *pi, sigset_t *sigset)
d1749 1
a1749 1
      long cmd;
d1751 1
a1751 1
      char sigset[sizeof (sigset_t)];
d1755 1
a1755 1
    memcpy (&arg.sigset, sigset, sizeof (sigset_t));
d1795 1
a1795 1
      long cmd;
d1838 2
a1839 2
    struct {
      long cmd;
d1842 6
a1847 1
    } arg;
d1849 2
a1850 2
    arg.cmd = PCSENTRY;
    memcpy (&arg.sysset, sysset, sizeof (sysset_t));
d1852 2
a1853 1
    win = (write (pi->ctl_fd, (char *) &arg, sizeof (arg)) == sizeof (arg));
d1888 2
a1889 2
    struct {
      long cmd;
d1892 6
a1897 1
    } arg;
d1899 2
a1900 2
    arg.cmd = PCSEXIT;
    memcpy (&arg.sysset, sysset, sizeof (sysset_t));
d1902 2
a1903 1
    win = (write (pi->ctl_fd, (char *) &arg, sizeof (arg)) == sizeof (arg));
d1922 1
a1922 1
proc_set_held_signals (procinfo *pi, sigset_t *sighold)
d1939 1
a1939 1
      long cmd;
d1941 1
a1941 1
      char hold[sizeof (sigset_t)];
d1945 1
a1945 1
    memcpy (&arg.hold, sighold, sizeof (sigset_t));
d1964 2
a1965 2
sigset_t *
proc_get_pending_signals (procinfo *pi, sigset_t *save)
d1967 1
a1967 1
  sigset_t *ret = NULL;
d1989 1
a1989 1
    memcpy (save, ret, sizeof (sigset_t));
d2001 2
a2002 2
struct sigaction *
proc_get_signal_actions (procinfo *pi, struct sigaction *save)
d2004 1
a2004 1
  struct sigaction *ret = NULL;
d2026 1
a2026 1
    memcpy (save, ret, sizeof (struct sigaction));
d2038 2
a2039 2
sigset_t *
proc_get_held_signals (procinfo *pi, sigset_t *save)
d2041 1
a2041 1
  sigset_t *ret = NULL;
d2065 1
a2065 1
    static sigset_t sigheld;
d2072 1
a2072 1
    memcpy (save, ret, sizeof (sigset_t));
d2084 2
a2085 2
sigset_t *
proc_get_traced_signals (procinfo *pi, sigset_t *save)
d2087 1
a2087 1
  sigset_t *ret = NULL;
d2107 1
a2107 1
    static sigset_t sigtrace;
d2114 1
a2114 1
    memcpy (save, ret, sizeof (sigset_t));
d2129 1
a2129 1
  sigset_t temp;
d2163 1
a2163 1
  sigset_t temp;
d2256 1
d2258 31
a2288 1
#else
d2295 1
a2295 1
#endif
d2297 1
a2297 1
    memcpy (save, ret, sizeof (sysset_t));
d2329 1
d2331 29
d2369 1
a2369 1
    memcpy (save, ret, sizeof (sysset_t));
d2399 1
a2399 1
    long cmd = PCCFAULT;
d2427 1
a2427 1
    long cmd;
d2429 1
a2429 1
    char sinfo[sizeof (struct siginfo)];
d2431 1
a2431 1
  struct siginfo *mysinfo;
d2454 1
a2454 1
  mysinfo = (struct siginfo *) &arg.sinfo;
d2496 1
a2496 1
      long cmd;
d2498 1
a2498 1
      char sinfo[sizeof (struct siginfo)];
d2500 1
a2500 1
    struct siginfo *mysinfo;
d2504 1
a2504 1
    mysinfo = (struct siginfo *) &arg.sinfo;
d2653 1
a2653 1
	long cmd;
d2696 1
a2696 1
	long cmd;
d2758 1
a2758 1
      long cmd[2];
d2817 1
a2817 1
    long cmd;
d3420 1
a3420 1
static int register_gdb_signals (procinfo *, sigset_t *);
d3437 4
a3440 3
  sigset_t traced_signals;
  sysset_t traced_syscall_entries;
  sysset_t traced_syscall_exits;
d3460 1
d3462 5
a3466 2
  premptyset (&traced_syscall_entries);
  praddset   (&traced_syscall_entries, SYS_exit);
d3468 1
a3468 1
  praddset   (&traced_syscall_entries, SYS_lwpexit);	/* And _lwp_exit... */
d3471 8
a3478 1
  praddset   (&traced_syscall_entries, SYS_lwp_exit);
d3481 3
a3483 1
  if (!proc_set_traced_sysentry (pi, &traced_syscall_entries))
d3509 2
a3510 1
  premptyset (&traced_syscall_exits);
d3512 1
a3512 1
  praddset (&traced_syscall_exits, SYS_exec);
d3515 1
a3515 1
  praddset (&traced_syscall_exits, SYS_execve);
d3518 1
a3518 1
  praddset (&traced_syscall_exits, SYS_execv);
d3522 2
a3523 2
  praddset (&traced_syscall_exits, SYS_lwpcreate);
  praddset (&traced_syscall_exits, SYS_lwpexit);
d3527 2
a3528 2
  praddset (&traced_syscall_exits, SYS_lwp_create);
  praddset (&traced_syscall_exits, SYS_lwp_exit);
d3531 10
d3542 3
a3544 1
  if (!proc_set_traced_sysexit (pi, &traced_syscall_exits))
d3643 1
a3643 1
  if (!proc_get_traced_sysentry (pi, &pi->saved_entryset))
d3646 1
a3646 1
  if (!proc_get_traced_sysexit  (pi, &pi->saved_exitset))
d3677 1
a3677 1
  if (!proc_set_traced_sysentry (pi, &pi->saved_entryset))
d3680 1
a3680 1
  if (!proc_set_traced_sysexit (pi, &pi->saved_exitset))
d3836 67
d4006 9
a4014 58
		switch (what) {
#ifdef SYS_lwp_exit
		case SYS_lwp_exit:
#endif
#ifdef SYS_lwpexit
		case SYS_lwpexit:
#endif
#if defined (SYS_lwp_exit) || defined (SYS_lwpexit)
		  printf_filtered ("[%s exited]\n",
				   target_pid_to_str (retval));
		  delete_thread (retval);
		  status->kind = TARGET_WAITKIND_SPURIOUS;
		  return retval;
#endif /* _lwp_exit */

		case SYS_exit:
		  /* Handle SYS_exit call only */
		  /* Stopped at entry to SYS_exit.
		     Make it runnable, resume it, then use 
		     the wait system call to get its exit code.
		     Proc_run_process always clears the current 
		     fault and signal.
		     Then return its exit status.  */
		  pi->status_valid = 0;
		  wstat = 0;
		  /* FIXME: what we should do is return 
		     TARGET_WAITKIND_SPURIOUS.  */
		  if (!proc_run_process (pi, 0, 0))
		    proc_error (pi, "target_wait, run_process", __LINE__);
		  if (attach_flag)
		    {
		      /* Don't call wait: simulate waiting for exit, 
			 return a "success" exit code.  Bogus: what if
			 it returns something else?  */
		      wstat = 0;
		      retval = inferior_pid;  /* ? ? ? */
		    }
		  else
		    {
		      int temp = wait (&wstat);

		      /* FIXME: shouldn't I make sure I get the right
			 event from the right process?  If (for
			 instance) I have killed an earlier inferior
			 process but failed to clean up after it
			 somehow, I could get its termination event
			 here.  */

		      /* If wait returns -1, that's what we return to GDB. */
		      if (temp < 0)
			retval = temp;
		    }
		  break;
		default:
		  printf_filtered ("procfs: trapped on entry to ");
		  proc_prettyprint_syscall (proc_what (pi), 0);
		  printf_filtered ("\n");
#ifndef PIOCSSPCACT
d4016 14
a4029 4
		    long i, nsysargs, *sysargs;

		    if ((nsysargs = proc_nsysarg (pi)) > 0 &&
			(sysargs  = proc_sysargs (pi)) != NULL)
d4031 5
a4035 4
			printf_filtered ("%ld syscall arguments:\n", nsysargs);
			for (i = 0; i < nsysargs; i++)
			  printf_filtered ("#%ld: 0x%08lx\n", 
					   i, sysargs[i]);
d4037 3
d4041 11
d4053 6
a4058 2
#endif
		  if (status)
d4060 11
a4070 3
		      /* How to exit gracefully, returning "unknown event" */
		      status->kind = TARGET_WAITKIND_SPURIOUS;
		      return inferior_pid;
d4072 14
a4085 8
		  else
		    {
		      /* How to keep going without returning to wfi: */
		      target_resume (pid, 0, TARGET_SIGNAL_0);
		      goto wait_again;
		    }
		  break;
		}
d4088 18
a4105 31
		switch (what) {
#ifdef SYS_exec
		case SYS_exec:
#endif
#ifdef SYS_execv
		case SYS_execv:
#endif
#ifdef SYS_execve
		case SYS_execve:
#endif
		  /* Hopefully this is our own "fork-child" execing
		     the real child.  Hoax this event into a trap, and
		     GDB will see the child about to execute its start
		     address. */
		  wstat = (SIGTRAP << 8) | 0177;
		  break;
#ifdef SYS_lwp_create
		case SYS_lwp_create:
#endif
#ifdef SYS_lwpcreate
		case SYS_lwpcreate:
#endif
#if defined(SYS_lwp_create) || defined(SYS_lwpcreate) 
		  /*
		   * This syscall is somewhat like fork/exec.
		   * We will get the event twice: once for the parent LWP,
		   * and once for the child.  We should already know about
		   * the parent LWP, but the child will be new to us.  So,
		   * whenever we get this event, if it represents a new
		   * thread, simply add the thread to the list.
		   */
d4107 4
a4110 16
		  /* If not in procinfo list, add it.  */
		  temp = proc_get_current_thread (pi);
		  if (!find_procinfo (pi->pid, temp))
		    create_procinfo  (pi->pid, temp);

		  temp = MERGEPID (pi->pid, temp);
		  /* If not in GDB's thread list, add it.  */
		  if (!in_thread_list (temp))
		    {
		      printf_filtered ("[New %s]\n", target_pid_to_str (temp));
		      add_thread (temp);
		    }
		  /* Return to WFI, but tell it to immediately resume. */
		  status->kind = TARGET_WAITKIND_SPURIOUS;
		  return inferior_pid;
#endif	/* _lwp_create */
d4112 3
a4114 40
#ifdef SYS_lwp_exit
		case SYS_lwp_exit:
#endif
#ifdef SYS_lwpexit
		case SYS_lwpexit:
#endif
#if defined (SYS_lwp_exit) || defined (SYS_lwpexit)
		  printf_filtered ("[%s exited]\n",
				   target_pid_to_str (retval));
		  delete_thread (retval);
		  status->kind = TARGET_WAITKIND_SPURIOUS;
		  return retval;
#endif /* _lwp_exit */

#ifdef SYS_sproc
		case SYS_sproc:
		  /* Nothing to do here for now.  The old procfs
		     seemed to use this event to handle threads on
		     older (non-LWP) systems, where I'm assuming that
		     threads were actually separate processes.  Irix,
		     maybe?  Anyway, low priority for now.  */
#endif
#ifdef SYS_fork
		case SYS_fork:
		  /* FIXME: do we need to handle this?  Investigate.  */
#endif
#ifdef SYS_vfork
		case SYS_vfork:
		  /* FIXME: see above.  */
#endif
		default:
		  printf_filtered ("procfs: trapped on exit from ");
		  proc_prettyprint_syscall (proc_what (pi), 0);
		  printf_filtered ("\n");
#ifndef PIOCSSPCACT
		  {
		    long i, nsysargs, *sysargs;

		    if ((nsysargs = proc_nsysarg (pi)) > 0 &&
			(sysargs  = proc_sysargs (pi)) != NULL)
d4116 2
a4117 4
			printf_filtered ("%ld syscall arguments:\n", nsysargs);
			for (i = 0; i < nsysargs; i++)
			  printf_filtered ("#%ld: 0x%08lx\n", 
					   i, sysargs[i]);
d4119 20
d4140 18
d4159 3
a4161 3
		  status->kind = TARGET_WAITKIND_SPURIOUS;
		  return inferior_pid;
		}
d4317 1
a4317 2
		    struct mem_attrib *attrib,
		    struct target_ops *target)
d4551 1
a4551 1
register_gdb_signals (procinfo *pi, sigset_t *signals)
d4575 1
a4575 1
  sigset_t signals;
d4686 1
a4686 1
    struct siginfo newsiginfo;
d4774 1
a4774 1
  sigset_t signals;
d4814 1
a4814 1
  if (!proc_get_traced_sysentry (pi, &pi->saved_entryset))
d4816 1
a4816 1
  if (!proc_get_traced_sysexit  (pi, &pi->saved_exitset))
d4868 1
a4868 1
  sysset_t exitset;
d4911 2
a4912 1
  premptyset (&exitset);
d4914 1
a4914 1
  praddset (&exitset, SYS_exec);
d4917 1
a4917 1
  praddset (&exitset, SYS_execve);
d4920 1
a4920 1
  praddset (&exitset, SYS_execv);
d4922 6
d4929 7
a4935 1
  if (!proc_set_traced_sysexit (pi, &exitset))
d5159 1
d5199 2
a5200 1
#endif
d5387 1
a5387 1
	praddset (sysset, syscallnum);
d5389 1
a5389 1
	prdelset (sysset, syscallnum);
@


1.24
log
@Add ``attrib'' parameter to *xfer_memory() functions.
@
text
@d2879 1
a2879 3
  if ((prstatus = (gdb_prstatus_t *) 
       malloc (sizeof (gdb_prstatus_t) * (nlwp + 1))) == 0)
    perror_with_name ("procfs: malloc failed in update_threads");
d2985 1
a2985 2
  if ((threads = malloc (nthreads * sizeof (tid_t))) == NULL)
    proc_error (pi, "update_threads, malloc", __LINE__);
@


1.23
log
@Update/correct copyright notices.
@
text
@d116 3
a118 2
static int procfs_xfer_memory (CORE_ADDR,
			       char *, int, int, struct target_ops *);
d3913 1
@


1.22
log
@2001-01-16  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * procfs.c (procfs_stopped_by_watchpoint): Don't die if	process
        goes away -- just return false.
@
text
@d2 1
a2 1
   Copyright 1999-2000 Free Software Foundation, Inc.
@


1.21
log
@Replace free() with xfree().
@
text
@d4796 6
a4801 2
  pi = find_procinfo_or_die (pid == -1 ? 
			     PIDGET (inferior_pid) : PIDGET (pid), 0);
@


1.20
log
@Protoization.
@
text
@d634 1
a634 1
  free (pi);
d2882 1
a2882 1
  old_chain = make_cleanup (free, prstatus);
@


1.19
log
@Protoization.
@
text
@d2512 1
a2512 2
proc_iterate_over_mappings (func)
     int (*func) (int, CORE_ADDR);
d3038 3
a3040 4
proc_iterate_over_threads (pi, func, ptr)
     procinfo *pi;
     int (*func) (procinfo *, procinfo *, void *);
     void     *ptr;
d3900 10
d3911 2
a3912 6
procfs_xfer_memory (memaddr, myaddr, len, dowrite, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int dowrite;
     struct target_ops *target; /* ignored */
@


1.18
log
@Eliminate use of PARAMS.
@
text
@d127 1
a127 1
init_procfs_ops ()
d331 1
a331 3
find_procinfo (pid, tid)
     int pid;
     int tid;
d364 1
a364 3
find_procinfo_or_die (pid, tid)
     int pid;
     int tid;
d395 1
a395 3
open_procinfo_files (pi, which)
     procinfo *pi;
     int       which;
d550 1
a550 3
create_procinfo (pid, tid)
     int pid;
     int tid;
d595 1
a595 2
close_procinfo_files (pi)
     procinfo *pi;
d615 1
a615 3
destroy_one_procinfo (list, pi)
     procinfo **list;
     procinfo  *pi;
d638 1
a638 2
destroy_procinfo (pi)
     procinfo *pi;
d674 1
a674 4
dead_procinfo (pi, msg, kill_p)
     procinfo *pi;
     char     *msg;
     int       kill_p;
d760 1
a760 4
proc_warn (pi, func, line)
     procinfo *pi;
     char     *func;
     int      line;
d767 1
a767 4
proc_error (pi, func, line)
     procinfo *pi;
     char     *func;
     int      line;
d786 1
a786 2
proc_get_status (pi)
     procinfo *pi;
d884 1
a884 2
proc_flags (pi)
     procinfo *pi;
d911 1
a911 2
proc_why (pi)
     procinfo *pi;
d931 1
a931 2
proc_what (pi)
     procinfo *pi;
d952 1
a952 2
proc_nsysarg (pi)
     procinfo *pi;
d972 1
a972 2
proc_sysargs (pi)
     procinfo *pi;
d992 1
a992 2
proc_syscall (pi)
     procinfo *pi;
d1062 1
a1062 4
proc_modify_flag (pi, flag, mode)
     procinfo *pi;
     long flag;
     long mode;
d1171 1
a1171 2
proc_set_run_on_last_close (pi)
     procinfo *pi;
d1187 1
a1187 2
proc_unset_run_on_last_close (pi)
     procinfo *pi;
d1204 1
a1204 2
proc_set_kill_on_last_close (pi)
     procinfo *pi;
d1220 1
a1220 2
proc_unset_kill_on_last_close (pi)
     procinfo *pi;
d1237 1
a1237 2
proc_set_inherit_on_fork (pi)
     procinfo *pi;
d1253 1
a1253 2
proc_unset_inherit_on_fork (pi)
     procinfo *pi;
d1270 1
a1270 2
proc_set_async (pi)
     procinfo *pi;
d1286 1
a1286 2
proc_unset_async (pi)
     procinfo *pi;
d1300 1
a1300 2
proc_stop_process (pi)
     procinfo *pi;
d1342 1
a1342 2
proc_wait_for_stop (pi)
     procinfo *pi;
d1406 1
a1406 4
proc_run_process (pi, step, signo)
     procinfo *pi;
     int step;
     int signo;
d1459 1
a1459 3
proc_set_traced_signals (pi, sigset)
     procinfo *pi;
     sigset_t *sigset;
d1505 1
a1505 3
proc_set_traced_faults (pi, fltset)
     procinfo *pi;
     fltset_t *fltset;
d1549 1
a1549 3
proc_set_traced_sysentry (pi, sysset)
     procinfo *pi;
     sysset_t *sysset;
d1593 1
a1593 3
proc_set_traced_sysexit (pi, sysset)
     procinfo *pi;
     sysset_t *sysset;
d1637 1
a1637 3
proc_set_held_signals (pi, sighold)
     procinfo *pi;
     sigset_t *sighold;
d1680 1
a1680 3
proc_get_pending_signals (pi, save)
     procinfo *pi;
     sigset_t *save;
d1717 1
a1717 3
proc_get_signal_actions (pi, save)
     procinfo         *pi;
     struct sigaction *save;
d1754 1
a1754 3
proc_get_held_signals (pi, save)
     procinfo *pi;
     sigset_t *save;
d1800 1
a1800 3
proc_get_traced_signals (pi, save)
     procinfo *pi;
     sigset_t *save;
d1842 1
a1842 3
proc_trace_signal (pi, signo)
     procinfo *pi;
     int signo;
d1876 1
a1876 3
proc_ignore_signal (pi, signo)
     procinfo *pi;
     int signo;
d1910 1
a1910 3
proc_get_traced_faults (pi, save)
     procinfo *pi;
     fltset_t *save;
d1952 1
a1952 3
proc_get_traced_sysentry (pi, save)
     procinfo *pi;
     sysset_t *save;
d1994 1
a1994 3
proc_get_traced_sysexit (pi, save)
     procinfo *pi;
     sysset_t *save;
d2037 1
a2037 2
proc_clear_current_fault (pi)
     procinfo *pi;
d2077 1
a2077 3
proc_set_current_signal (pi, signo)
     procinfo *pi;
     int signo;
d2133 1
a2133 2
proc_clear_current_signal (pi)
     procinfo *pi;
d2182 1
a2182 2
proc_get_gregs (pi)
     procinfo *pi;
d2213 1
a2213 2
proc_get_fpregs (pi)
     procinfo *pi;
d2290 1
a2290 2
proc_set_gregs (pi)
     procinfo *pi;
d2333 1
a2333 2
proc_set_fpregs (pi)
     procinfo *pi;
d2395 1
a2395 3
proc_kill (pi, signo)
     procinfo *pi;
     int signo;
d2435 1
a2435 2
proc_parent_pid (pi)
     procinfo *pi;
d2461 1
a2461 5
proc_set_watchpoint (pi, addr, len, wflags)
     procinfo  *pi;
     CORE_ADDR addr;
     int       len;
     int       wflags;
d2625 1
a2625 3
proc_get_LDT_entry (pi, key)
     procinfo *pi;
     int       key;
d2719 1
a2719 2
proc_get_nthreads (pi)
     procinfo *pi;
d2735 1
a2735 2
proc_get_nthreads (pi)
     procinfo *pi;
d2757 1
a2757 2
proc_get_nthreads (pi)
     procinfo *pi;
d2778 1
a2778 2
proc_get_current_thread (pi)
     procinfo *pi;
d2807 1
a2807 2
proc_get_current_thread (pi)
     procinfo *pi;
d2821 1
a2821 2
proc_get_current_thread (pi)
     procinfo *pi;
d2841 1
a2841 4
proc_delete_dead_threads (parent, thread, ignore)
     procinfo *parent;
     procinfo *thread;
     void     *ignore;
d2857 1
a2857 2
proc_update_threads (pi)
     procinfo *pi;
d2912 1
a2912 2
proc_update_threads (pi)
     procinfo *pi;
d2966 1
a2966 2
proc_update_threads (pi)
     procinfo *pi;
d3007 1
a3007 2
proc_update_threads (pi)
     procinfo *pi;
d3093 1
a3093 2
procfs_debug_inferior (pi)
     procinfo *pi;
d3184 1
a3184 3
procfs_attach (args, from_tty)
     char *args;
     int from_tty;
d3213 1
a3213 3
procfs_detach (args, from_tty)
     char *args;
     int from_tty;
d3236 1
a3236 2
do_attach (pid)
     int pid;
d3293 1
a3293 2
do_detach (signo)
     int signo;
d3346 1
a3346 2
procfs_fetch_registers (regno)
     int regno;
d3399 1
a3399 1
procfs_prepare_to_store ()
d3418 1
a3418 2
procfs_store_registers (regno)
     int regno;
d3481 1
a3481 3
procfs_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d3968 1
a3968 4
invalidate_cache (parent, pi, ptr)
     procinfo *parent;
     procinfo *pi;
     void     *ptr;
d4020 1
a4020 4
make_signal_thread_runnable (process, pi, ptr)
     procinfo *process;
     procinfo *pi;
     void     *ptr;
d4052 1
a4052 4
procfs_resume (pid, step, signo)
     int pid;
     int step;
     enum target_signal signo;
d4142 1
a4142 3
register_gdb_signals (pi, signals)
     procinfo *pi;
     sigset_t *signals;
d4164 1
a4164 2
procfs_notice_signals (pid)
     int pid;
d4183 1
a4183 2
procfs_files_info (ignore)
     struct target_ops *ignore;
d4197 1
a4197 3
procfs_open (args, from_tty)
     char *args;
     int from_tty;
d4216 1
a4216 1
procfs_can_run ()
d4238 1
a4238 1
procfs_stop ()
d4255 1
a4255 2
unconditionally_kill_inferior (pi)
     procinfo *pi;
d4317 1
a4317 1
procfs_kill_inferior ()
d4337 1
a4337 1
procfs_mourn_inferior ()
d4362 1
a4362 2
procfs_init_inferior (pid)
     int pid;
d4452 1
a4452 1
procfs_set_exec_trap ()
d4554 1
a4554 4
procfs_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d4643 1
a4643 4
procfs_notice_thread (pi, thread, ptr)
     procinfo *pi;
     procinfo *thread;
     void *ptr;
d4661 1
a4661 1
procfs_find_new_threads ()
d4681 1
a4681 2
procfs_thread_alive (pid)
     int pid;
d4711 1
a4711 2
procfs_pid_to_str (pid)
     int pid;
d4734 1
a4734 6
procfs_set_watchpoint (pid, addr, len, rwflag, after)
     int       pid;
     CORE_ADDR addr;
     int       len;
     int       rwflag;
     int       after;
d4788 1
a4788 2
procfs_stopped_by_watchpoint (pid)
    int    pid;
d4823 1
a4823 2
procfs_find_LDT_entry (pid)
     int pid;
d4854 1
a4854 3
info_proc_cmd (args, from_tty)
     char *args;
     int from_tty;
d4934 1
a4934 5
proc_trace_syscalls (args, from_tty, entry_or_exit, mode)
     char *args;
     int   from_tty;
     int   entry_or_exit;
     int   mode;
d4977 1
a4977 3
proc_trace_sysentry_cmd (args, from_tty)
     char *args;
     int   from_tty;
d4983 1
a4983 3
proc_trace_sysexit_cmd (args, from_tty)
     char *args;
     int   from_tty;
d4989 1
a4989 3
proc_untrace_sysentry_cmd (args, from_tty)
     char *args;
     int   from_tty;
d4995 1
a4995 3
proc_untrace_sysexit_cmd (args, from_tty)
     char *args;
     int   from_tty;
d5002 1
a5002 1
_initialize_procfs ()
d5034 1
a5034 1
procfs_first_available ()
@


1.17
log
@Add host_pointer_to_address() and address_to_host_pointer().  Add
signed_pointer_to_address() etc.  Rename generic_pointer_to_address()
to unsigned_pointer_to_address() etc.
@
text
@d101 1
a101 1
static void procfs_open              PARAMS((char *, int));
d757 2
a758 3
			       int (*func) PARAMS ((procinfo *,
						    procinfo *,
						    void *)), void *ptr);
@


1.16
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d2565 1
a2565 1
  pwatch->pr_vaddr  = addr;
d2686 2
a2687 1
      if ((funcstat = (*func) (fd, (CORE_ADDR) map[i].pr_vaddr)) != 0)
@


1.15
log
@PARAMS removal.
@
text
@d2601 1
a2601 1
     int (*func) PARAMS ((int, CORE_ADDR));
d3143 1
a3143 1
     int     (*func) PARAMS ((procinfo *, procinfo *, void *));
@


1.14
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d102 16
a117 18
static void procfs_attach            PARAMS ((char *, int));
static void procfs_detach            PARAMS ((char *, int));
static void procfs_resume            PARAMS ((int, int, enum target_signal));
static int  procfs_can_run           PARAMS ((void));
static void procfs_stop              PARAMS ((void));
static void procfs_files_info        PARAMS ((struct target_ops *));
static void procfs_fetch_registers   PARAMS ((int));
static void procfs_store_registers   PARAMS ((int));
static void procfs_notice_signals    PARAMS ((int));
static void procfs_prepare_to_store  PARAMS ((void));
static void procfs_kill_inferior     PARAMS ((void));
static void procfs_mourn_inferior    PARAMS ((void));
static void procfs_create_inferior   PARAMS ((char *, char *, char **));
static int  procfs_wait              PARAMS ((int, 
					       struct target_waitstatus *));
static int  procfs_xfer_memory       PARAMS ((CORE_ADDR, 
					       char *, int, int, 
					       struct target_ops *));
d119 1
a119 1
static int  procfs_thread_alive      PARAMS ((int));
d121 2
a122 2
void procfs_find_new_threads         PARAMS ((void));
char *procfs_pid_to_str              PARAMS ((int));
d310 4
a313 4
static procinfo *find_procinfo_or_die PARAMS ((int pid, int tid));
static procinfo *find_procinfo        PARAMS ((int pid, int tid));
static procinfo *create_procinfo      PARAMS ((int pid, int tid));
static void      destroy_procinfo     PARAMS ((procinfo *p));
d315 3
a317 4
static void      dead_procinfo        PARAMS ((procinfo *p, 
					       char *msg, int killp));
static int       open_procinfo_files  PARAMS ((procinfo *p, int which));
static void      close_procinfo_files PARAMS ((procinfo *p));
d725 46
a770 47
int proc_get_status PARAMS ((procinfo *pi));
long proc_flags     PARAMS ((procinfo *pi));
int proc_why        PARAMS ((procinfo *pi));
int proc_what       PARAMS ((procinfo *pi));
int proc_set_run_on_last_close   PARAMS ((procinfo *pi));
int proc_unset_run_on_last_close PARAMS ((procinfo *pi));
int proc_set_inherit_on_fork     PARAMS ((procinfo *pi));
int proc_unset_inherit_on_fork   PARAMS ((procinfo *pi));
int proc_set_async            PARAMS ((procinfo *pi));
int proc_unset_async          PARAMS ((procinfo *pi));
int proc_stop_process         PARAMS ((procinfo *pi));
int proc_trace_signal         PARAMS ((procinfo *pi, int signo));
int proc_ignore_signal        PARAMS ((procinfo *pi, int signo));
int proc_clear_current_fault  PARAMS ((procinfo *pi));
int proc_set_current_signal   PARAMS ((procinfo *pi, int signo));
int proc_clear_current_signal PARAMS ((procinfo *pi));
int proc_set_gregs            PARAMS ((procinfo *pi));
int proc_set_fpregs           PARAMS ((procinfo *pi));
int proc_wait_for_stop        PARAMS ((procinfo *pi));
int proc_run_process          PARAMS ((procinfo *pi, int step, int signo));
int proc_kill                 PARAMS ((procinfo *pi, int signo));
int proc_parent_pid           PARAMS ((procinfo *pi));
int proc_get_nthreads         PARAMS ((procinfo *pi));
int proc_get_current_thread   PARAMS ((procinfo *pi));
int proc_set_held_signals     PARAMS ((procinfo *pi, sigset_t *sighold));
int proc_set_traced_sysexit   PARAMS ((procinfo *pi, sysset_t *sysset));
int proc_set_traced_sysentry  PARAMS ((procinfo *pi, sysset_t *sysset));
int proc_set_traced_faults    PARAMS ((procinfo *pi, fltset_t *fltset));
int proc_set_traced_signals   PARAMS ((procinfo *pi, sigset_t *sigset));

int proc_update_threads       PARAMS ((procinfo *pi));
int proc_iterate_over_threads PARAMS ((procinfo *pi,
				       int     (*func) PARAMS ((procinfo *, 
								procinfo *, 
								void *)),
				       void     *ptr));

gdb_gregset_t   *proc_get_gregs     PARAMS ((procinfo *pi));
gdb_fpregset_t  *proc_get_fpregs    PARAMS ((procinfo *pi));
sysset_t *proc_get_traced_sysexit   PARAMS ((procinfo *pi, sysset_t *save));
sysset_t *proc_get_traced_sysentry  PARAMS ((procinfo *pi, sysset_t *save));
fltset_t *proc_get_traced_faults    PARAMS ((procinfo *pi, fltset_t *save));
sigset_t *proc_get_traced_signals   PARAMS ((procinfo *pi, sigset_t *save));
sigset_t *proc_get_held_signals     PARAMS ((procinfo *pi, sigset_t *save));
sigset_t *proc_get_pending_signals  PARAMS ((procinfo *pi, sigset_t *save));
struct sigaction *proc_get_signal_actions PARAMS ((procinfo *pi, 
						   struct sigaction *save));
d772 2
a773 2
void proc_warn  PARAMS ((procinfo *pi, char *func, int line));
void proc_error PARAMS ((procinfo *pi, char *func, int line));
d3179 3
a3181 3
static int  do_attach PARAMS ((int pid));
static void do_detach PARAMS ((int signo));
static int register_gdb_signals PARAMS ((procinfo *, sigset_t *));
@


1.13
log
@Replace <sys/dir.h> (and <dirent.h>) with "gdb_dirent.h".
@
text
@d92 3
a250 18

/* These #ifdefs are for sol2.x in particular.  sol2.x has
   both a "gregset_t" and a "prgregset_t", which have
   similar uses but different layouts.  sol2.x gdb tries to
   use prgregset_t (and prfpregset_t) everywhere. */

#ifdef GDB_GREGSET_TYPE
  typedef GDB_GREGSET_TYPE gdb_gregset_t;
#else
  typedef gregset_t gdb_gregset_t;
#endif

#ifdef GDB_FPREGSET_TYPE
  typedef GDB_FPREGSET_TYPE gdb_fpregset_t;
#else
  typedef fpregset_t gdb_fpregset_t;
#endif

a3456 13

/* These could go in a header file, but the many and various
   definitions of gregset_t would make it tricky and ugly.  Several
   different native operating systems (notably Solaris and Linux) have
   various different definitions for gregset_t and fpregset_t.  We
   have been kludging around this problem for a while, it would be
   nice if someday we came up with a prettier way of handling it
   (FIXME).  */

extern void fill_gregset (gdb_gregset_t *, int);
extern void fill_fpregset (gdb_fpregset_t *, int);
extern void supply_gregset (gdb_gregset_t *);
extern void supply_fpregset (gdb_fpregset_t *);
@


1.12
log
@Purge procfs.c of make_cleanup_func.
@
text
@d2 1
a2 1
   Copyright 1999 Free Software Foundation, Inc.
d79 1
a79 1
#include <dirent.h>	/* opendir/readdir, for listing the LWP's */
@


1.11
log
@2000-05-08  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gdbarch.sh: Add FP0_REGNUM to list of multi-arched register numbers.
        * gdbarch.c, gdbarch.h: Regenerate.
        * core-regset.c: Change FP0_REGNUM to a runtime test.
        * procfs.c: Ditto.
        * sun3-nat.c: Ditto.
        * sparc-tdep.c: Ditto.

        * i386mach-nat.c: Remove unnecessary ifdef for FP0_REGNUM.
        * ptx4-nat.c: Ditto.

        * sol-thread.c (sol_thread_create_inferior): only add the thread
        to the thread list if it is not already in there.
        (prototypes for thread_db func ptrs): pretty up formatting.
@
text
@d331 1
d687 6
d2643 1
a2643 1
  make_cleanup ((make_cleanup_func) close, (void *) map_fd);
d2754 1
a2754 1
  old_chain = make_cleanup ((make_cleanup_func) close, (void *) fd);
d3023 6
d3067 1
a3067 1
  old_chain = make_cleanup ((make_cleanup_func) closedir, dirp);
d5049 1
a5049 1
	make_cleanup ((make_cleanup_func) freeargv, argv);
d5083 1
a5083 1
	   make_cleanup ((make_cleanup_func) destroy_procinfo, process);
@


1.10
log
@* procfs.c (PROCFS_TRACE): Delete definition.
* proc-utils.h (PROCFS_NOTE, PROC_PRETTYFPRINT_STATUS): Always define.
@
text
@d3505 8
a3512 7
#if defined (FP0_REGNUM)	/* need floating point? */
  if ((regno >= 0 && regno < FP0_REGNUM) ||
      regno == PC_REGNUM  ||
      (NPC_REGNUM >= 0 && regno == NPC_REGNUM) ||
      regno == FP_REGNUM  ||
      regno == SP_REGNUM)
    return;			/* not a floating point register */
d3514 2
a3515 2
  if ((fpregs = proc_get_fpregs (pi)) == NULL)
    proc_error (pi, "fetch_registers, get_fpregs", __LINE__);
d3517 2
a3518 2
  supply_fpregset (fpregs);
#endif
d3580 16
a3595 15
#if defined (FP0_REGNUM)	/* need floating point? */
  if ((regno >= 0 && regno < FP0_REGNUM) ||
      regno == PC_REGNUM  ||
      (NPC_REGNUM >= 0 && regno == NPC_REGNUM) ||
      regno == FP_REGNUM  ||
      regno == SP_REGNUM)
    return;			/* not a floating point register */

  if ((fpregs = proc_get_fpregs (pi)) == NULL)
    proc_error (pi, "store_registers, get_fpregs", __LINE__);

  fill_fpregset (fpregs, regno);
  if (!proc_set_fpregs (pi))
    proc_error (pi, "store_registers, set_fpregs", __LINE__);
#endif
d4116 7
a4122 8
#ifdef FP0_REGNUM
  if (pi->fpregs_dirty)
    if (parent == NULL ||
	proc_get_current_thread (parent) != pi->tid)
      if (!proc_set_fpregs (pi))	/* flush fpregs cache */
	proc_warn (pi, "target_resume, set_fpregs", 
		   __LINE__);
#endif
@


1.9
log
@2000-05-05  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * procfs.c: Cleanup of procfs tracing.  Move defines and
        prototypes to proc-utils.h
        * proc-utils.h: Define tracing macros.  Declare trace functions.
        * proc-api.c: Make procfs tracing a runtime option.
        (prepare_to_trace): New function, abstracted out of several
        places.  Open a trace file if one is required.
        (ioctl_with_trace, write_with_trace, open_with_trace,
        close_with_trace, wait_with_trace, lseek_with_trace):
        Report errno if an error occurs in a system call.
        (write_with_trace): Make 2nd arg void *, to agree with write.
@
text
@a89 1
#define PROCFS_TRACE
@


1.8
log
@2000-05-05  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * procfs.c (many functions): change int cmd; to long cmd;
        Solaris /proc API calls this parameter a long, and requires it
        for 64-bit hosts (where sizeof(long) != sizeof(int)).  UnixWare
        calls it an int, but on existing UnixWare hosts, int and long
        are the same size.  So long it must be.  If a future UnixWare
        version has problems with this, we'll have to use autoconf.
        * proc-api.c (write_with_trace): use long instead of int.
@
text
@a40 2
#include "proc-utils.h"

d86 7
d162 2
a163 2
  procfs_ops.to_has_all_memory    = 1;
  procfs_ops.to_has_memory        = 1;
a174 30
 * Temporary debugging code:
 *
 * These macros allow me to trace the system calls that we make
 * to control the child process.  This is quite handy for comparing
 * with the older version of procfs.
 */

#ifdef TRACE_PROCFS
#ifdef NEW_PROC_API
extern  int   write_with_trace PARAMS ((int, void *, size_t, char *, int));
extern  off_t lseek_with_trace PARAMS ((int, off_t,  int,    char *, int));
#define write(X,Y,Z)   write_with_trace (X, Y, Z, __FILE__, __LINE__)
#define lseek(X,Y,Z)   lseek_with_trace (X, Y, Z, __FILE__, __LINE__)
#else
extern  int ioctl_with_trace PARAMS ((int, long, void *, char *, int));
#define ioctl(X,Y,Z)   ioctl_with_trace (X, Y, Z, __FILE__, __LINE__)
#endif
#define open(X,Y)      open_with_trace  (X, Y,    __FILE__, __LINE__)
#define close(X)       close_with_trace (X,       __FILE__, __LINE__)
#define wait(X)        wait_with_trace  (X,       __FILE__, __LINE__)
#define PROCFS_NOTE(X) procfs_note      (X,       __FILE__, __LINE__)
#define PROC_PRETTYFPRINT_STATUS(X,Y,Z,T) \
proc_prettyfprint_status (X, Y, Z, T)
#else
#define PROCFS_NOTE(X)
#define PROC_PRETTYFPRINT_STATUS(X,Y,Z,T)
#endif


/*
d4438 1
a4438 1
    proc_warn (pi, "unconditionally_kill, proc_kill", __LINE__);
@


1.7
log
@Multi-arch NPC_REGNUM NNPC_REGNUM.
@
text
@d1394 1
a1394 1
      int cmd = PCSTOP;
d1438 1
a1438 1
    int cmd = PCWSTOP;
d1515 1
a1515 1
    int cmd[2];
d1561 1
a1561 1
      int cmd;
d1609 1
a1609 1
      int cmd;
d1655 1
a1655 1
      int cmd;
d1701 1
a1701 1
      int cmd;
d1747 1
a1747 1
      int cmd;
d2165 1
a2165 1
    int cmd = PCCFAULT;
d2195 1
a2195 1
    int cmd;
d2265 1
a2265 1
      int cmd;
d2425 1
a2425 1
	int cmd;
d2469 1
a2469 1
	int cmd;
d2533 1
a2533 1
      int cmd[2];
d2597 1
a2597 1
    int cmd;
@


1.6
log
@2000-04-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

	* procfs.c (comments): Eliminate "???" in comments, which GCC
	wants to interpret as a trigraph.  (fill_gregset, supply_gregset,
	fill_fpregset, supply_fpregset): declare.
	(procfs_wait): Sysargs is a long, change printf format to match.
	(test-mapping, mapping_test, test_mapping_cmd) Remove (test only).
@
text
@d3534 1
a3534 3
#ifdef NPC_REGNUM
      regno == NPC_REGNUM ||
#endif
d3608 1
a3608 3
#ifdef NPC_REGNUM
      regno == NPC_REGNUM ||
#endif
@


1.5
log
@From 2000-03-27 Peter Schauer <pes@@regent.e-technik.tu-muenchen.de>:
* procfs.c (init_procfs_ops):  Set procfs_ops.to_has_memory and
procfs_ops.to_has_all_memory to 1.
@
text
@d593 1
a593 1
 * (First tries to find a pre-existing one (FIXME: why???)
d3486 13
d3766 1
a3766 1
		      retval = inferior_pid;  /* ??? */
d3797 1
a3797 1
			  printf_filtered ("#%ld: 0x%08x\n", 
d3911 1
a3911 1
			  printf_filtered ("#%ld: 0x%08x\n", 
a5207 21
int
mapping_test (fd, core_addr)
     int fd;
     CORE_ADDR core_addr;
{
  printf ("File descriptor %d, base address 0x%08x\n", fd, core_addr);
  if (fd > 0)
    close (fd);
  return 0;
}

void
test_mapping_cmd (args, from_tty)
     char *args;
     int from_tty;
{
  int ret;
  ret = proc_iterate_over_mappings (mapping_test);
  printf ("iterate_over_mappings returned %d.\n", ret);
}

a5223 3

  add_com ("test-mapping", no_class, test_mapping_cmd, 
	   "test iterate-over-mappings");
@


1.4
log
@2000-03-28  Peter Schauer  <pes@@regent.e-technik.tu-muenchen.de>

        * procfs.c (proc_set_watchpoint):  Declare addr parameter as
        CORE_ADDR, to match call from procfs_set_watchpoint.
@
text
@d157 2
@


1.3
log
@From Peter Schauer: Fix Solaris/x86 threads by copying linux code.
@
text
@d2582 2
a2583 2
     procinfo *pi;
     void     *addr;
@


1.2
log
@From Rodney Brown: Define MERGEPID when needed.
@
text
@a5256 17

int
procfs_get_pid_fd (pid)
     int pid;
{
  procinfo *pi;

  if (pid == -1 && inferior_pid != 0)
    pi = find_procinfo (PIDGET (inferior_pid), 0);
  else
    pi = find_procinfo (PIDGET (pid), 0);

  if (pi)
    return pi->ctl_fd;
  else
    return -1;
}
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
   Copyright 1991, 1992-98, 1999 Free Software Foundation, Inc.
   Written by Fred Fish at Cygnus Support.  Changes for sysv4.2mp procfs
   compatibility by Geoffrey Noer at Cygnus Solutions.
d19 2
a20 2
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 51
a73 1
/*			N  O  T  E  S
d75 12
a86 2
For information on the details of using /proc consult section proc(4)
in the UNIX System V Release 4 System Administrator's Reference Manual.
d88 1
a88 4
The general register and floating point register sets are manipulated
separately.  This file makes the assumption that if FP0_REGNUM is
defined, then support for the floating point register set is desired,
regardless of whether or not the actual target has floating point hardware.
d90 2
d94 21
d116 2
a117 1
#include "defs.h"
d119 1
a119 12
#include <sys/types.h>
#include <time.h>
#include <sys/fault.h>
#include <sys/syscall.h>
#include <sys/procfs.h>
#include <fcntl.h>
#include <errno.h>
#include "gdb_string.h"
#include <stropts.h>
#include <poll.h>
#include <unistd.h>
#include "gdb_stat.h"
d121 25
a145 5
#include "inferior.h"
#include "target.h"
#include "command.h"
#include "gdbcore.h"
#include "gdbthread.h"
d147 5
a151 3
#if !defined(SYS_lwp_create) && defined(SYS_lwpcreate)
# define SYS_lwp_create SYS_lwpcreate
#endif
d153 3
a155 3
#if !defined(SYS_lwp_exit) && defined(SYS_lwpexit)
# define SYS_lwp_exit SYS_lwpexit
#endif
d157 7
a163 3
#if !defined(SYS_lwp_wait) && defined(SYS_lwpwait)
# define SYS_lwp_wait SYS_lwpwait
#endif
d165 1
a165 3
#if !defined(SYS_lwp_self) && defined(SYS_lwpself)
# define SYS_lwp_self SYS_lwpself
#endif
d167 7
a173 3
#if !defined(SYS_lwp_info) && defined(SYS_lwpinfo)
# define SYS_lwp_info SYS_lwpinfo
#endif
d175 9
a183 2
#if !defined(SYS_lwp_private) && defined(SYS_lwpprivate)
# define SYS_lwp_private SYS_lwpprivate
d185 9
a193 3

#if !defined(SYS_lwp_kill) && defined(SYS_lwpkill)
# define SYS_lwp_kill SYS_lwpkill
a195 3
#if !defined(SYS_lwp_suspend) && defined(SYS_lwpsuspend)
# define SYS_lwp_suspend SYS_lwpsuspend
#endif
d197 6
a202 3
#if !defined(SYS_lwp_continue) && defined(SYS_lwpcontinue)
# define SYS_lwp_continue SYS_lwpcontinue
#endif
d204 1
a204 10
/* the name of the proc status struct depends on the implementation */
/* Wrap Light Weight Process member in THE_PR_LWP macro for clearer code */
#ifndef HAVE_PSTATUS_T
  typedef prstatus_t gdb_prstatus_t;
#define THE_PR_LWP(a)	a
#else	/* HAVE_PSTATUS_T */
  typedef pstatus_t gdb_prstatus_t;
#define THE_PR_LWP(a)	a.pr_lwp
#if !defined(HAVE_PRRUN_T) && defined(HAVE_MULTIPLE_PROC_FDS)
  /* Fallback definitions - for using configure information directly */
d206 12
a217 1
#define UNIXWARE	1
a218 5
#if !defined(PROCFS_USE_READ_WRITE) && !defined(HAVE_PROCFS_PIOCSET)
#define PROCFS_USE_READ_WRITE	1
#endif
#endif	/* !HAVE_PRRUN_T && HAVE_MULTIPLE_PROC_FDS */
#endif	/* HAVE_PSTATUS_T */
d220 31
a250 8
#define MAX_SYSCALLS	256	/* Maximum number of syscalls for table */

/* proc name formats may vary depending on the proc implementation */
#ifdef HAVE_MULTIPLE_PROC_FDS
#  ifndef CTL_PROC_NAME_FMT
#  define CTL_PROC_NAME_FMT "/proc/%d/ctl"
#  define AS_PROC_NAME_FMT "/proc/%d/as"
#  define MAP_PROC_NAME_FMT "/proc/%d/map"
d252 12
a263 6
#  endif
#else /* HAVE_MULTIPLE_PROC_FDS */
#  ifndef CTL_PROC_NAME_FMT
#  define CTL_PROC_NAME_FMT "/proc/%05d"
#  define AS_PROC_NAME_FMT "/proc/%05d"
#  define MAP_PROC_NAME_FMT "/proc/%05d"
d265 6
a270 2
#  endif
#endif /* HAVE_MULTIPLE_PROC_FDS */
d290 2
d293 6
a298 11
#define MAX_PROC_NAME_SIZE sizeof("/proc/1234567890/status")

struct target_ops procfs_ops;

int procfs_suppress_run = 0;	/* Non-zero if procfs should pretend not to
				   be a runnable target.  Used by targets
				   that can sit atop procfs, such as solaris
				   thread support.  */

#if 1	/* FIXME: Gross and ugly hack to resolve coredep.c global */
CORE_ADDR kernel_u_addr;
d301 4
a304 61
#ifdef BROKEN_SIGINFO_H		/* Workaround broken SGS <sys/siginfo.h> */
#undef si_pid
#define si_pid _data._proc.pid
#undef si_uid
#define si_uid _data._proc._pdata._kill.uid
#endif /* BROKEN_SIGINFO_H */

/* Define structures for passing commands to /proc/pid/ctl file.  Note that
   while we create these for the PROCFS_USE_READ_WRITE world, we use them
   and ignore the extra cmd int in other proc schemes.
*/
/* generic ctl msg */
struct proc_ctl {
        int     cmd;
        long    data;
};

/* set general registers */
struct greg_ctl {
        int             cmd;
        gdb_gregset_t	gregset;
};

/* set fp registers */
struct fpreg_ctl {
        int             cmd;
        gdb_fpregset_t	fpregset;
};

/* set signals to be traced */
struct sig_ctl {
        int             cmd;
        sigset_t        sigset;
};

/* set faults to be traced */
struct flt_ctl {
        int             cmd;
        fltset_t        fltset;
};

/* set system calls to be traced */
struct sys_ctl {
        int             cmd;
        sysset_t        sysset;
};

/* set current signal to be traced */
struct sigi_ctl {
        int             cmd;
        siginfo_t       siginfo;
};

/*  All access to the inferior, either one started by gdb or one that has
    been attached to, is controlled by an instance of a procinfo structure,
    defined below.  Since gdb currently only handles one inferior at a time,
    the procinfo structure for the inferior is statically allocated and
    only one exists at any given time.  There is a separate procinfo
    structure for use by the "info proc" command, so that we can print
    useful information about any random process without interfering with
    the inferior's procinfo information. */
d306 16
a321 4
struct procinfo {
  struct procinfo *next;
  int pid;			/* Process ID of inferior */
  int ctl_fd;			/* File descriptor for /proc ctl file */
a323 28
  int map_fd;			/* File descriptor for /proc map file */
  char *pathname;		/* Pathname to /proc entry */
  int had_event;		/* poll/select says something happened */
  int was_stopped;		/* Nonzero if was stopped prior to attach */
  int nopass_next_sigstop;	/* Don't pass a sigstop on next resume */
#ifdef HAVE_PRRUN_T
  prrun_t prrun;		/* Control state when it is run */
#endif
  gdb_prstatus_t prstatus;	/* Current process status info */
  struct greg_ctl gregset;	/* General register set */
  struct fpreg_ctl fpregset;	/* Floating point register set */
  struct flt_ctl fltset;	/* Current traced hardware fault set */
  struct sig_ctl trace;		/* Current traced signal set */
  struct sys_ctl exitset;	/* Current traced system call exit set */
  struct sys_ctl entryset;	/* Current traced system call entry set */
  struct sig_ctl saved_sighold;	/* Saved held signal set */
  struct flt_ctl saved_fltset;  /* Saved traced hardware fault set */
  struct sig_ctl saved_trace;   /* Saved traced signal set */
  struct sys_ctl saved_exitset; /* Saved traced system call exit set */
  struct sys_ctl saved_entryset;/* Saved traced system call entry set */
  int num_syscall_handlers;	/* Number of syscall trap handlers
				   currently installed */
				/* Pointer to list of syscall trap handlers */
  struct procfs_syscall_handler *syscall_handlers; 
  int saved_rtnval;		/* return value and status for wait(), */
  int saved_statval;		/*  as supplied by a syscall handler. */
  int new_child;		/* Non-zero if it's a new thread */
};
d325 1
a325 3
/* List of inferior process information */
static struct procinfo *procinfo_list = NULL;
static struct pollfd *poll_list; /* pollfds used for waiting on /proc */
d327 5
a331 1
static int num_poll_list = 0;	/* Number of entries in poll_list */
d333 1
a333 13
/*  Much of the information used in the /proc interface, particularly for
    printing status information, is kept as tables of structures of the
    following form.  These tables can be used to map numeric values to
    their symbolic names and to a string that describes their specific use. */

struct trans {
  int value;			/* The numeric value */
  char *name;			/* The equivalent symbolic value */
  char *desc;			/* Short description of value */
};

/*  Translate bits in the pr_flags member of the prstatus structure, into the
    names and desc information. */
d335 2
a336 4
static struct trans pr_flag_table[] =
{
#if defined (PR_STOPPED)
  { PR_STOPPED, "PR_STOPPED", "Process is stopped" },
d338 2
a339 47
#if defined (PR_ISTOP)
  { PR_ISTOP, "PR_ISTOP", "Stopped on an event of interest" },
#endif
#if defined (PR_DSTOP)
  { PR_DSTOP, "PR_DSTOP", "A stop directive is in effect" },
#endif
#if defined (PR_ASLEEP)
  { PR_ASLEEP, "PR_ASLEEP", "Sleeping in an interruptible system call" },
#endif
#if defined (PR_FORK)
  { PR_FORK, "PR_FORK", "Inherit-on-fork is in effect" },
#endif
#if defined (PR_RLC)
  { PR_RLC, "PR_RLC", "Run-on-last-close is in effect" },
#endif
#if defined (PR_PTRACE)
  { PR_PTRACE, "PR_PTRACE", "Process is being controlled by ptrace" },
#endif
#if defined (PR_PCINVAL)
  { PR_PCINVAL, "PR_PCINVAL", "PC refers to an invalid virtual address" },
#endif
#if defined (PR_ISSYS)
  { PR_ISSYS, "PR_ISSYS", "Is a system process" },
#endif
#if defined (PR_STEP)
  { PR_STEP, "PR_STEP", "Process has single step pending" },
#endif
#if defined (PR_KLC)
  { PR_KLC, "PR_KLC", "Kill-on-last-close is in effect" },
#endif
#if defined (PR_ASYNC)
  { PR_ASYNC, "PR_ASYNC", "Asynchronous stop is in effect" },
#endif
#if defined (PR_PCOMPAT)
  { PR_PCOMPAT, "PR_PCOMPAT", "Ptrace compatibility mode in effect" },
#endif
#if defined (PR_MSACCT)
  { PR_MSACCT, "PR_MSACCT", "Microstate accounting enabled" },
#endif
#if defined (PR_BPTADJ)
  { PR_BPTADJ, "PR_BPTADJ", "Breakpoint PC adjustment in effect" },
#endif
#if defined (PR_ASLWP)
  { PR_ASLWP, "PR_ASLWP", "Asynchronus signal LWP" },
#endif
  { 0, NULL, NULL }
};
d341 29
a369 1
/*  Translate values in the pr_why field of the prstatus struct. */
d371 4
a374 1
static struct trans pr_why_table[] =
d376 1
a376 26
#if defined (PR_REQUESTED)
  { PR_REQUESTED, "PR_REQUESTED", "Directed to stop via PIOCSTOP/PIOCWSTOP" },
#endif
#if defined (PR_SIGNALLED)
  { PR_SIGNALLED, "PR_SIGNALLED", "Receipt of a traced signal" },
#endif
#if defined (PR_SYSENTRY)
  { PR_SYSENTRY, "PR_SYSENTRY", "Entry to a traced system call" },
#endif
#if defined (PR_SYSEXIT)
  { PR_SYSEXIT, "PR_SYSEXIT", "Exit from a traced system call" },
#endif
#if defined (PR_JOBCONTROL)
  { PR_JOBCONTROL, "PR_JOBCONTROL", "Default job control stop signal action" },
#endif
#if defined (PR_FAULTED)
  { PR_FAULTED, "PR_FAULTED", "Incurred a traced hardware fault" },
#endif
#if defined (PR_SUSPENDED)
  { PR_SUSPENDED, "PR_SUSPENDED", "Process suspended" },
#endif
#if defined (PR_CHECKPOINT)
  { PR_CHECKPOINT, "PR_CHECKPOINT", "(???)" },
#endif
  { 0, NULL, NULL }
};
d378 3
a380 1
/*  Hardware fault translation table. */
d382 9
a390 37
static struct trans faults_table[] =
{
#if defined (FLTILL)
  { FLTILL, "FLTILL", "Illegal instruction" },
#endif
#if defined (FLTPRIV)
  { FLTPRIV, "FLTPRIV", "Privileged instruction" },
#endif
#if defined (FLTBPT)
  { FLTBPT, "FLTBPT", "Breakpoint trap" },
#endif
#if defined (FLTTRACE)
  { FLTTRACE, "FLTTRACE", "Trace trap" },
#endif
#if defined (FLTACCESS)
  { FLTACCESS, "FLTACCESS", "Memory access fault" },
#endif
#if defined (FLTBOUNDS)
  { FLTBOUNDS, "FLTBOUNDS", "Memory bounds violation" },
#endif
#if defined (FLTIOVF)
  { FLTIOVF, "FLTIOVF", "Integer overflow" },
#endif
#if defined (FLTIZDIV)
  { FLTIZDIV, "FLTIZDIV", "Integer zero divide" },
#endif
#if defined (FLTFPE)
  { FLTFPE, "FLTFPE", "Floating-point exception" },
#endif
#if defined (FLTSTACK)
  { FLTSTACK, "FLTSTACK", "Unrecoverable stack fault" },
#endif
#if defined (FLTPAGE)
  { FLTPAGE, "FLTPAGE", "Recoverable page fault" },
#endif
  { 0, NULL, NULL }
};
d392 4
a395 2
/* Translation table for signal generation information.  See UNIX System
   V Release 4 Programmer's Reference Manual, siginfo(5).  */
d397 2
a398 113
static struct sigcode {
  int signo;
  int code;
  char *codename;
  char *desc;
} siginfo_table[] = {
#if defined (SIGILL) && defined (ILL_ILLOPC)
  { SIGILL, ILL_ILLOPC, "ILL_ILLOPC", "Illegal opcode" },
#endif
#if defined (SIGILL) && defined (ILL_ILLOPN)
  { SIGILL, ILL_ILLOPN, "ILL_ILLOPN", "Illegal operand", },
#endif
#if defined (SIGILL) && defined (ILL_ILLADR)
  { SIGILL, ILL_ILLADR, "ILL_ILLADR", "Illegal addressing mode" },
#endif
#if defined (SIGILL) && defined (ILL_ILLTRP)
  { SIGILL, ILL_ILLTRP, "ILL_ILLTRP", "Illegal trap" },
#endif
#if defined (SIGILL) && defined (ILL_PRVOPC)
  { SIGILL, ILL_PRVOPC, "ILL_PRVOPC", "Privileged opcode" },
#endif
#if defined (SIGILL) && defined (ILL_PRVREG)
  { SIGILL, ILL_PRVREG, "ILL_PRVREG", "Privileged register" },
#endif
#if defined (SIGILL) && defined (ILL_COPROC)
  { SIGILL, ILL_COPROC, "ILL_COPROC", "Coprocessor error" },
#endif
#if defined (SIGILL) && defined (ILL_BADSTK)
  { SIGILL, ILL_BADSTK, "ILL_BADSTK", "Internal stack error" },
#endif
#if defined (SIGFPE) && defined (FPE_INTDIV)
  { SIGFPE, FPE_INTDIV, "FPE_INTDIV", "Integer divide by zero" },
#endif
#if defined (SIGFPE) && defined (FPE_INTOVF)
  { SIGFPE, FPE_INTOVF, "FPE_INTOVF", "Integer overflow" },
#endif
#if defined (SIGFPE) && defined (FPE_FLTDIV)
  { SIGFPE, FPE_FLTDIV, "FPE_FLTDIV", "Floating point divide by zero" },
#endif
#if defined (SIGFPE) && defined (FPE_FLTOVF)
  { SIGFPE, FPE_FLTOVF, "FPE_FLTOVF", "Floating point overflow" },
#endif
#if defined (SIGFPE) && defined (FPE_FLTUND)
  { SIGFPE, FPE_FLTUND, "FPE_FLTUND", "Floating point underflow" },
#endif
#if defined (SIGFPE) && defined (FPE_FLTRES)
  { SIGFPE, FPE_FLTRES, "FPE_FLTRES", "Floating point inexact result" },
#endif
#if defined (SIGFPE) && defined (FPE_FLTINV)
  { SIGFPE, FPE_FLTINV, "FPE_FLTINV", "Invalid floating point operation" },
#endif
#if defined (SIGFPE) && defined (FPE_FLTSUB)
  { SIGFPE, FPE_FLTSUB, "FPE_FLTSUB", "Subscript out of range" },
#endif
#if defined (SIGSEGV) && defined (SEGV_MAPERR)
  { SIGSEGV, SEGV_MAPERR, "SEGV_MAPERR", "Address not mapped to object" },
#endif
#if defined (SIGSEGV) && defined (SEGV_ACCERR)
  { SIGSEGV, SEGV_ACCERR, "SEGV_ACCERR", "Invalid permissions for object" },
#endif
#if defined (SIGBUS) && defined (BUS_ADRALN)
  { SIGBUS, BUS_ADRALN, "BUS_ADRALN", "Invalid address alignment" },
#endif
#if defined (SIGBUS) && defined (BUS_ADRERR)
  { SIGBUS, BUS_ADRERR, "BUS_ADRERR", "Non-existent physical address" },
#endif
#if defined (SIGBUS) && defined (BUS_OBJERR)
  { SIGBUS, BUS_OBJERR, "BUS_OBJERR", "Object specific hardware error" },
#endif
#if defined (SIGTRAP) && defined (TRAP_BRKPT)
  { SIGTRAP, TRAP_BRKPT, "TRAP_BRKPT", "Process breakpoint" },
#endif
#if defined (SIGTRAP) && defined (TRAP_TRACE)
  { SIGTRAP, TRAP_TRACE, "TRAP_TRACE", "Process trace trap" },
#endif
#if defined (SIGCLD) && defined (CLD_EXITED)
  { SIGCLD, CLD_EXITED, "CLD_EXITED", "Child has exited" },
#endif
#if defined (SIGCLD) && defined (CLD_KILLED)
  { SIGCLD, CLD_KILLED, "CLD_KILLED", "Child was killed" },
#endif
#if defined (SIGCLD) && defined (CLD_DUMPED)
  { SIGCLD, CLD_DUMPED, "CLD_DUMPED", "Child has terminated abnormally" },
#endif
#if defined (SIGCLD) && defined (CLD_TRAPPED)
  { SIGCLD, CLD_TRAPPED, "CLD_TRAPPED", "Traced child has trapped" },
#endif
#if defined (SIGCLD) && defined (CLD_STOPPED)
  { SIGCLD, CLD_STOPPED, "CLD_STOPPED", "Child has stopped" },
#endif
#if defined (SIGCLD) && defined (CLD_CONTINUED)
  { SIGCLD, CLD_CONTINUED, "CLD_CONTINUED", "Stopped child had continued" },
#endif
#if defined (SIGPOLL) && defined (POLL_IN)
  { SIGPOLL, POLL_IN, "POLL_IN", "Input input available" },
#endif
#if defined (SIGPOLL) && defined (POLL_OUT)
  { SIGPOLL, POLL_OUT, "POLL_OUT", "Output buffers available" },
#endif
#if defined (SIGPOLL) && defined (POLL_MSG)
  { SIGPOLL, POLL_MSG, "POLL_MSG", "Input message available" },
#endif
#if defined (SIGPOLL) && defined (POLL_ERR)
  { SIGPOLL, POLL_ERR, "POLL_ERR", "I/O error" },
#endif
#if defined (SIGPOLL) && defined (POLL_PRI)
  { SIGPOLL, POLL_PRI, "POLL_PRI", "High priority input available" },
#endif
#if defined (SIGPOLL) && defined (POLL_HUP)
  { SIGPOLL, POLL_HUP, "POLL_HUP", "Device disconnected" },
#endif
  { 0, 0, NULL, NULL }
};
d400 5
a404 1
static char *syscall_table[MAX_SYSCALLS];
d406 6
a411 1
/* Prototypes for local functions */
d413 10
a422 1
static void procfs_stop PARAMS ((void));
d424 12
a435 1
static int procfs_thread_alive PARAMS ((int));
d437 1
a437 1
static int procfs_can_run PARAMS ((void));
d439 112
a550 1
static void procfs_mourn_inferior PARAMS ((void));
a551 1
static void procfs_fetch_registers PARAMS ((int));
d553 15
a567 1
static int procfs_wait PARAMS ((int, struct target_waitstatus *));
d569 3
a571 1
static void procfs_open PARAMS ((char *, int));
d573 10
a582 1
static void procfs_files_info PARAMS ((struct target_ops *));
d584 2
a585 1
static void procfs_prepare_to_store PARAMS ((void));
d587 8
a594 1
static void procfs_detach PARAMS ((char *, int));
d596 6
a601 1
static void procfs_attach PARAMS ((char *, int));
d603 2
a604 1
static void proc_set_exec_trap PARAMS ((void));
d606 30
a635 1
static void  procfs_init_inferior PARAMS ((int));
d637 5
a641 1
static struct procinfo *create_procinfo PARAMS ((int));
d643 14
a656 1
static void procfs_store_registers PARAMS ((int));
d658 5
a662 1
static int procfs_xfer_memory PARAMS ((CORE_ADDR, char *, int, int, struct target_ops *));
d664 17
a680 1
static void procfs_kill_inferior PARAMS ((void));
d682 2
a683 1
static char *sigcodedesc PARAMS ((siginfo_t *));
d685 3
a687 1
static char *sigcodename PARAMS ((siginfo_t *));
d689 5
a693 1
static struct procinfo *wait_fd PARAMS ((void));
d695 14
a708 1
static void remove_fd PARAMS ((struct procinfo *));
d710 1
a710 1
static void add_fd PARAMS ((struct procinfo *));
d712 7
a718 1
static void set_proc_siginfo PARAMS ((struct procinfo *, int));
d720 7
a726 1
static void init_syscall_table PARAMS ((void));
d728 11
a738 1
static char *syscallname PARAMS ((int));
d740 3
a742 1
static char *signalname PARAMS ((int));
d744 1
a744 1
static char *errnoname PARAMS ((int));
d746 1
a746 1
static int proc_address_to_fd PARAMS ((struct procinfo *, CORE_ADDR, int));
d748 11
a758 1
static int open_proc_file PARAMS ((int, struct procinfo *, int, int));
d760 47
a806 1
static void close_proc_file PARAMS ((struct procinfo *));
d808 2
a809 1
static void unconditionally_kill_inferior PARAMS ((struct procinfo *));
d811 9
a819 1
static NORETURN void proc_init_failed PARAMS ((struct procinfo *, char *, int)) ATTR_NORETURN;
d821 9
a829 1
static void info_proc PARAMS ((char *, int));
d831 11
a841 1
static void info_proc_flags PARAMS ((struct procinfo *, int));
d843 11
a853 1
static void info_proc_stop PARAMS ((struct procinfo *, int));
d855 46
a900 1
static void info_proc_siginfo PARAMS ((struct procinfo *, int));
d902 15
a916 1
static void info_proc_syscalls PARAMS ((struct procinfo *, int));
d918 7
a924 1
static void info_proc_mappings PARAMS ((struct procinfo *, int));
d926 9
a934 1
static void info_proc_signals PARAMS ((struct procinfo *, int));
d936 5
a940 1
static void info_proc_faults PARAMS ((struct procinfo *, int));
d942 7
a948 1
static char *mappingflags PARAMS ((long));
d950 13
a962 1
static char *lookupname PARAMS ((struct trans *, unsigned int, char *));
d964 5
a968 1
static char *lookupdesc PARAMS ((struct trans *, unsigned int));
d970 20
a989 1
static int do_attach PARAMS ((int pid));
d991 7
a997 1
static void do_detach PARAMS ((int siggnal));
d999 6
a1004 1
static void procfs_create_inferior PARAMS ((char *, char *, char **));
d1006 6
a1011 1
static void procfs_notice_signals PARAMS ((int pid));
d1013 14
a1026 1
static void notice_signals PARAMS ((struct procinfo *, struct sig_ctl *));
d1028 5
a1032 1
static struct procinfo *find_procinfo PARAMS ((pid_t pid, int okfail));
d1034 14
a1047 3
static int procfs_write_pcwstop PARAMS ((struct procinfo *));
static int procfs_read_status PARAMS ((struct procinfo *));
static void procfs_write_pckill PARAMS ((struct procinfo *));
d1049 5
a1053 2
typedef int syscall_func_t PARAMS ((struct procinfo *pi, int syscall_num,
				    int why, int *rtnval, int *statval));
d1055 15
a1069 3
static void procfs_set_syscall_trap PARAMS ((struct procinfo *pi,
					     int syscall_num, int flags,
					     syscall_func_t *func));
d1071 5
a1075 2
static void procfs_clear_syscall_trap PARAMS ((struct procinfo *pi,
					       int syscall_num, int errok));
d1077 13
a1089 2
#define PROCFS_SYSCALL_ENTRY 0x1 /* Trap on entry to sys call */
#define PROCFS_SYSCALL_EXIT 0x2	/* Trap on exit from sys call */
d1091 32
a1122 1
static syscall_func_t procfs_exit_handler;
d1124 1
a1124 1
static syscall_func_t procfs_exec_handler;
d1126 29
a1154 3
#ifdef SYS_sproc
static syscall_func_t procfs_sproc_handler;
static syscall_func_t procfs_fork_handler;
d1156 2
d1159 62
a1220 2
#ifdef SYS_lwp_create
static syscall_func_t procfs_lwp_creation_handler;
d1222 2
d1225 2
a1226 2
static void modify_inherit_on_fork_flag PARAMS ((int fd, int flag));
static void modify_run_on_last_close_flag PARAMS ((int fd, int flag));
d1228 9
a1236 1
/* */
d1238 3
a1240 1
struct procfs_syscall_handler
d1242 12
a1253 4
  int syscall_num;		/* The number of the system call being handled */
				/* The function to be called */
  syscall_func_t *func;
};
d1255 6
a1260 2
static void procfs_resume PARAMS ((int pid, int step,
				   enum target_signal signo));
d1262 10
a1271 1
static void init_procfs_ops PARAMS ((void));
d1273 6
a1278 2
/* External function prototypes that can't be easily included in any
   header file because the args are typedefs in system include files. */
d1280 9
a1288 1
extern void supply_gregset PARAMS ((gdb_gregset_t *));
d1290 7
a1296 1
extern void fill_gregset PARAMS ((gdb_gregset_t *, int));
d1298 9
a1306 2
#ifdef FP0_REGNUM
extern void supply_fpregset PARAMS ((gdb_fpregset_t *));
d1308 6
a1313 2
extern void fill_fpregset PARAMS ((gdb_fpregset_t *, int));
#endif
d1316 15
d1332 10
a1341 1
LOCAL FUNCTION
d1343 6
a1348 1
	find_procinfo -- convert a process id to a struct procinfo
d1350 9
a1358 1
SYNOPSIS
d1360 7
a1366 1
	static struct procinfo * find_procinfo (pid_t pid, int okfail);
d1368 5
a1372 5
DESCRIPTION
	
	Given a process id, look it up in the procinfo chain.  Returns
	a struct procinfo *.  If can't find pid, then call error(),
	unless okfail is set, in which case, return NULL;
d1375 3
a1377 4
static struct procinfo *
find_procinfo (pid, okfail)
     pid_t pid;
     int okfail;
d1379 1
a1379 1
  struct procinfo *procinfo;
d1381 4
a1384 3
  for (procinfo = procinfo_list; procinfo; procinfo = procinfo->next)
    if (procinfo->pid == pid)
      return procinfo;
d1386 21
a1406 2
  if (okfail)
    return NULL;
d1408 1
a1408 1
  error ("procfs (find_procinfo):  Couldn't locate pid %d", pid);
d1412 5
d1418 5
a1422 1
LOCAL MACRO
d1424 9
a1432 1
	current_procinfo -- convert inferior_pid to a struct procinfo
d1434 19
a1452 1
SYNOPSIS
d1454 2
a1455 1
	static struct procinfo * current_procinfo;
d1457 24
a1480 4
DESCRIPTION
	
	Looks up inferior_pid in the procinfo chain.  Always returns a
	struct procinfo *.  If process can't be found, we error() out.
d1483 19
a1501 1
#define current_procinfo find_procinfo (inferior_pid, 0)
d1503 7
a1509 1
/*
d1511 3
a1513 1
LOCAL FUNCTION
d1515 7
a1521 1
	add_fd -- Add the fd to the poll/select list
d1523 5
a1527 1
SYNOPSIS
d1529 2
a1530 1
	static void add_fd (struct procinfo *);
d1532 5
a1536 4
DESCRIPTION
	
	Add the fd of the supplied procinfo to the list of fds used for
	poll/select operations.
d1539 32
a1570 15
static void
add_fd (pi)
     struct procinfo *pi;
{
  if (num_poll_list <= 0)
    poll_list = (struct pollfd *) xmalloc (sizeof (struct pollfd));
  else
    poll_list = (struct pollfd *) xrealloc (poll_list,
					    (num_poll_list + 1)
					    * sizeof (struct pollfd));
  poll_list[num_poll_list].fd = pi->ctl_fd;
#ifdef UNIXWARE
  poll_list[num_poll_list].events = POLLWRNORM;
#else
  poll_list[num_poll_list].events = POLLPRI;
d1572 2
d1575 3
a1577 1
  num_poll_list++;
d1581 22
d1604 7
a1610 1
LOCAL FUNCTION
d1612 2
a1613 1
	remove_fd -- Remove the fd from the poll/select list
d1615 7
a1621 1
SYNOPSIS
d1623 2
a1624 1
	static void remove_fd (struct procinfo *);
d1626 5
a1630 4
DESCRIPTION
	
	Remove the fd of the supplied procinfo from the list of fds used 
	for poll/select operations.
d1633 16
a1648 5
static void
remove_fd (pi)
     struct procinfo *pi;
{
  int i;
d1650 7
a1656 7
  for (i = 0; i < num_poll_list; i++)
    {
      if (poll_list[i].fd == pi->ctl_fd)
	{
	  if (i != num_poll_list - 1)
	    memcpy (poll_list + i, poll_list + i + 1,
		    (num_poll_list - i - 1) * sizeof (struct pollfd));
d1658 2
a1659 1
	  num_poll_list--;
d1661 9
a1669 9
	  if (num_poll_list == 0)
	    free (poll_list);
	  else
	    poll_list = (struct pollfd *) xrealloc (poll_list,
						    num_poll_list
						    * sizeof (struct pollfd));
	  return;
	}
    }
d1673 5
d1679 24
a1702 1
LOCAL FUNCTION
d1704 2
a1705 1
	procfs_read_status - get procfs fd status
d1707 7
a1713 1
SYNOPSIS
d1715 2
a1716 1
	static int procfs_read_status (pi) struct procinfo *pi;
d1718 5
a1722 5
DESCRIPTION
	
	Given a pointer to a procinfo struct, get the status of
	the status_fd in the appropriate way.  Returns 0 on failure,
	1 on success.
d1725 29
a1753 8
static int
procfs_read_status (pi)
  struct procinfo *pi;
{
#ifdef PROCFS_USE_READ_WRITE
   if ((lseek (pi->status_fd, 0, SEEK_SET) < 0) ||
           (read (pi->status_fd, (char *) &pi->prstatus, 
             sizeof (gdb_prstatus_t)) != sizeof (gdb_prstatus_t)))
d1755 1
a1755 1
  if (ioctl (pi->status_fd, PIOCSTATUS, &pi->prstatus) < 0)
d1757 4
a1760 3
    return 0;
  else
    return 1;
d1764 5
d1770 16
a1785 1
LOCAL FUNCTION
d1787 3
a1789 1
	procfs_write_pcwstop - send a PCWSTOP to procfs fd
d1791 7
a1797 1
SYNOPSIS
d1799 2
a1800 1
	static int procfs_write_pcwstop (pi) struct procinfo *pi;
d1802 5
a1806 5
DESCRIPTION
	
	Given a pointer to a procinfo struct, send a PCWSTOP to
	the ctl_fd in the appropriate way.  Returns 0 on failure,
	1 on success.
d1809 23
a1831 7
static int
procfs_write_pcwstop (pi)
  struct procinfo *pi;
{
#ifdef PROCFS_USE_READ_WRITE
  long cmd = PCWSTOP;
  if (write (pi->ctl_fd, (char *) &cmd, sizeof (long)) < 0)
d1833 1
a1833 1
  if (ioctl (pi->ctl_fd, PIOCWSTOP, &pi->prstatus) < 0)
d1835 4
a1838 3
    return 0;
  else
    return 1;
d1842 22
d1865 4
a1868 1
LOCAL FUNCTION
d1870 8
a1877 1
	procfs_write_pckill - send a kill to procfs fd
d1879 6
a1884 1
SYNOPSIS
d1886 2
a1887 1
	static void procfs_write_pckill (pi) struct procinfo *pi;
d1889 5
a1893 5
DESCRIPTION
	
	Given a pointer to a procinfo struct, send a kill to
	the ctl_fd in the appropriate way.  Returns 0 on failure,
	1 on success.
d1896 23
a1918 9
static void
procfs_write_pckill (pi)
  struct procinfo *pi;
{
#ifdef PROCFS_USE_READ_WRITE
  struct proc_ctl pctl;
  pctl.cmd = PCKILL;
  pctl.data = SIGKILL;
  write (pi->ctl_fd, &pctl, sizeof (struct proc_ctl));
d1920 6
a1925 2
  int signo = SIGKILL;
  ioctl (pi->ctl_fd, PIOCKILL, &signo);
d1927 4
d1933 11
a1943 2
static struct procinfo *
wait_fd ()
d1945 1
a1945 5
  struct procinfo *pi, *next_pi;
#ifndef LOSING_POLL
  int num_fds;
  int i;
#endif
d1947 9
a1955 18
  set_sigint_trap ();	/* Causes SIGINT to be passed on to the
			   attached process. */
  set_sigio_trap ();

 wait_again:
#ifndef LOSING_POLL
  while (1)
    {
      num_fds = poll (poll_list, num_poll_list, -1);
      if (num_fds > 0)
	break;
      if (num_fds < 0 && errno == EINTR)
	continue;
      print_sys_errmsg ("poll failed", errno);
      error ("Poll failed, returned %d", num_fds);
    }
#else /* LOSING_POLL */
  pi = current_procinfo;
d1957 1
a1957 1
  while (!procfs_write_pcwstop (pi))
d1959 1
a1959 7
      if (errno == ENOENT)
	{
	  /* Process exited.  */
	  pi->prstatus.pr_flags = 0;
	  break;
	}
      else if (errno != EINTR)
d1961 2
a1962 2
	  print_sys_errmsg (pi->pathname, errno);
	  error ("procfs_write_pcwstop failed");
a1964 5
  pi->had_event = 1;
#endif /* LOSING_POLL */
  
  clear_sigint_trap ();
  clear_sigio_trap ();
d1966 2
a1967 1
#ifndef LOSING_POLL
d1969 25
a1993 1
  for (i = 0; i < num_poll_list && num_fds > 0; i++)
d1995 1
a1995 4
      if (0 == (poll_list[i].revents & 
		(POLLWRNORM | POLLPRI | POLLERR | POLLHUP | POLLNVAL)))
	continue;
      for (pi = procinfo_list; pi; pi = next_pi)
d1997 2
a1998 26
	  next_pi = pi->next;
	  if (poll_list[i].fd == pi->ctl_fd)
	    {
	      num_fds--;
	      if ((poll_list[i].revents & POLLHUP) != 0	||
		  !procfs_read_status(pi))
		{ /* The LWP has apparently terminated.  */
		  if (num_poll_list <= 1)
		    {
		      pi->prstatus.pr_flags = 0;
		      pi->had_event = 1;
		      break;
		    }
		  if (info_verbose)
		    printf_filtered ("LWP %d exited.\n", 
				     (pi->pid >> 16) & 0xffff);
		  close_proc_file (pi);
		  i--;			/* don't skip deleted entry */
		  if (num_fds != 0)
		    break;		/* already another event to process */
		  else
		    goto wait_again; 	/* wait for another event */
		}
	      pi->had_event = 1;
	      break;
	    }
a1999 3
      if (!pi)
	error ("wait_fd: Couldn't find procinfo for fd %d\n",
	       poll_list[i].fd);
a2000 1
#endif /* LOSING_POLL */
d2002 89
a2090 1
  return pi;
d2094 5
d2100 21
a2120 1
LOCAL FUNCTION
d2122 4
a2125 1
	lookupdesc -- translate a value to a summary desc string
d2127 6
a2132 1
SYNOPSIS
d2134 2
a2135 1
	static char *lookupdesc (struct trans *transp, unsigned int val);
d2137 6
a2142 4
DESCRIPTION
	
	Given a pointer to a translation table and a value to be translated,
	lookup the desc string and return it.
d2145 3
a2147 4
static char *
lookupdesc (transp, val)
     struct trans *transp;
     unsigned int val;
d2149 8
a2156 1
  char *desc;
d2158 2
a2159 8
  for (desc = NULL; transp -> name != NULL; transp++)
    {
      if (transp -> value == val)
	{
	  desc = transp -> desc;
	  break;
	}
    }
d2161 8
a2168 1
  /* Didn't find a translation for the specified value, set a default one. */
d2170 1
a2170 5
  if (desc == NULL)
    {
      desc = "Unknown";
    }
  return (desc);
d2174 11
d2186 22
a2207 1
LOCAL FUNCTION
d2209 9
a2217 1
	lookupname -- translate a value to symbolic name
d2219 6
a2224 1
SYNOPSIS
d2226 6
a2231 2
	static char *lookupname (struct trans *transp, unsigned int val,
				 char *prefix);
d2233 2
a2234 6
DESCRIPTION
	
	Given a pointer to a translation table, a value to be translated,
	and a default prefix to return if the value can't be translated,
	match the value with one of the translation table entries and
	return a pointer to the symbolic name.
d2236 6
a2241 3
	If no match is found it just returns the value as a printable string,
	with the given prefix.  The previous such value, if any, is freed
	at this time.
d2244 3
a2246 5
static char *
lookupname (transp, val, prefix)
     struct trans *transp;
     unsigned int val;
     char *prefix;
d2248 8
a2255 2
  static char *locbuf;
  char *name;
d2257 88
a2344 1
  for (name = NULL; transp -> name != NULL; transp++)
d2346 2
a2347 1
      if (transp -> value == val)
d2349 1
a2349 2
	  name = transp -> name;
	  break;
d2351 8
a2358 1
    }
d2360 2
a2361 3
  /* Didn't find a translation for the specified value, build a default
     one using the specified prefix and return it.  The lifetime of
     the value is only until the next one is needed. */
d2363 29
a2391 5
  if (name == NULL)
    {
      if (locbuf != NULL)
	{
	  free (locbuf);
a2392 3
      locbuf = xmalloc (strlen (prefix) + 16);
      sprintf (locbuf, "%s %u", prefix, val);
      name = locbuf;
d2394 1
a2394 1
  return (name);
d2397 10
a2406 3
static char *
sigcodename (sip)
     siginfo_t *sip;
d2408 8
a2415 5
  struct sigcode *scp;
  char *name = NULL;
  static char locbuf[32];
  
  for (scp = siginfo_table; scp -> codename != NULL; scp++)
d2417 1
a2417 6
      if ((scp -> signo == sip -> si_signo) &&
	  (scp -> code == sip -> si_code))
	{
	  name = scp -> codename;
	  break;
	}
d2419 1
a2419 1
  if (name == NULL)
d2421 13
a2433 2
      sprintf (locbuf, "sigcode %u", sip -> si_signo);
      name = locbuf;
d2435 4
a2438 1
  return (name);
d2441 10
a2450 3
static char *
sigcodedesc (sip)
     siginfo_t *sip;
d2452 12
a2463 4
  struct sigcode *scp;
  char *desc = NULL;
  
  for (scp = siginfo_table; scp -> codename != NULL; scp++)
d2465 15
a2479 2
      if ((scp -> signo == sip -> si_signo) &&
	  (scp -> code == sip -> si_code))
d2481 11
a2491 2
	  desc = scp -> desc;
	  break;
d2493 4
d2498 27
a2524 1
  if (desc == NULL)
d2526 1
a2526 1
      desc = "Unrecognized signal or trap use";
d2528 16
a2543 1
  return (desc);
d2547 5
d2553 20
a2572 1
LOCAL FUNCTION
a2573 1
	syscallname - translate a system call number into a system call name
d2575 4
a2578 1
SYNOPSIS
d2580 19
a2598 1
	char *syscallname (int syscallnum)
d2600 17
a2616 1
DESCRIPTION
d2618 12
a2629 3
	Given a system call number, translate it into the printable name
	of a system call, or into "syscall <num>" if it is an unknown
	number.
d2632 6
a2637 3
static char *
syscallname (syscallnum)
     int syscallnum;
d2639 32
a2670 6
  static char locbuf[32];
  
  if (syscallnum >= 0 && syscallnum < MAX_SYSCALLS
      && syscall_table[syscallnum] != NULL)
    return syscall_table[syscallnum];
  else
d2672 52
a2723 2
      sprintf (locbuf, "syscall %u", syscallnum);
      return locbuf;
d2725 3
d2730 4
d2735 78
d2814 4
a2817 1
LOCAL FUNCTION
d2819 4
a2822 1
	init_syscall_table - initialize syscall translation table
d2824 1
a2824 1
SYNOPSIS
d2826 1
a2826 1
	void init_syscall_table (void)
d2828 1
a2828 1
DESCRIPTION
d2830 2
a2831 3
	Dynamically initialize the translation table to convert system
	call numbers into printable system call names.  Done once per
	gdb run, on initialization.
d2833 5
a2837 1
NOTES
d2839 3
a2841 2
	This is awfully ugly, but preprocessor tricks to make it prettier
	tend to be nonportable.
d2843 11
d2855 8
a2862 2
static void
init_syscall_table ()
d2864 11
a2874 2
#if defined (SYS_exit)
  syscall_table[SYS_exit] = "exit";
d2876 13
a2888 2
#if defined (SYS_fork)
  syscall_table[SYS_fork] = "fork";
a2889 2
#if defined (SYS_read)
  syscall_table[SYS_read] = "read";
a2890 1997
#if defined (SYS_write)
  syscall_table[SYS_write] = "write";
#endif
#if defined (SYS_open)
  syscall_table[SYS_open] = "open";
#endif
#if defined (SYS_close)
  syscall_table[SYS_close] = "close";
#endif
#if defined (SYS_wait)
  syscall_table[SYS_wait] = "wait";
#endif
#if defined (SYS_creat)
  syscall_table[SYS_creat] = "creat";
#endif
#if defined (SYS_link)
  syscall_table[SYS_link] = "link";
#endif
#if defined (SYS_unlink)
  syscall_table[SYS_unlink] = "unlink";
#endif
#if defined (SYS_exec)
  syscall_table[SYS_exec] = "exec";
#endif
#if defined (SYS_execv)
  syscall_table[SYS_execv] = "execv";
#endif
#if defined (SYS_execve)
  syscall_table[SYS_execve] = "execve";
#endif
#if defined (SYS_chdir)
  syscall_table[SYS_chdir] = "chdir";
#endif
#if defined (SYS_time)
  syscall_table[SYS_time] = "time";
#endif
#if defined (SYS_mknod)
  syscall_table[SYS_mknod] = "mknod";
#endif
#if defined (SYS_chmod)
  syscall_table[SYS_chmod] = "chmod";
#endif
#if defined (SYS_chown)
  syscall_table[SYS_chown] = "chown";
#endif
#if defined (SYS_brk)
  syscall_table[SYS_brk] = "brk";
#endif
#if defined (SYS_stat)
  syscall_table[SYS_stat] = "stat";
#endif
#if defined (SYS_lseek)
  syscall_table[SYS_lseek] = "lseek";
#endif
#if defined (SYS_getpid)
  syscall_table[SYS_getpid] = "getpid";
#endif
#if defined (SYS_mount)
  syscall_table[SYS_mount] = "mount";
#endif
#if defined (SYS_umount)
  syscall_table[SYS_umount] = "umount";
#endif
#if defined (SYS_setuid)
  syscall_table[SYS_setuid] = "setuid";
#endif
#if defined (SYS_getuid)
  syscall_table[SYS_getuid] = "getuid";
#endif
#if defined (SYS_stime)
  syscall_table[SYS_stime] = "stime";
#endif
#if defined (SYS_ptrace)
  syscall_table[SYS_ptrace] = "ptrace";
#endif
#if defined (SYS_alarm)
  syscall_table[SYS_alarm] = "alarm";
#endif
#if defined (SYS_fstat)
  syscall_table[SYS_fstat] = "fstat";
#endif
#if defined (SYS_pause)
  syscall_table[SYS_pause] = "pause";
#endif
#if defined (SYS_utime)
  syscall_table[SYS_utime] = "utime";
#endif
#if defined (SYS_stty)
  syscall_table[SYS_stty] = "stty";
#endif
#if defined (SYS_gtty)
  syscall_table[SYS_gtty] = "gtty";
#endif
#if defined (SYS_access)
  syscall_table[SYS_access] = "access";
#endif
#if defined (SYS_nice)
  syscall_table[SYS_nice] = "nice";
#endif
#if defined (SYS_statfs)
  syscall_table[SYS_statfs] = "statfs";
#endif
#if defined (SYS_sync)
  syscall_table[SYS_sync] = "sync";
#endif
#if defined (SYS_kill)
  syscall_table[SYS_kill] = "kill";
#endif
#if defined (SYS_fstatfs)
  syscall_table[SYS_fstatfs] = "fstatfs";
#endif
#if defined (SYS_pgrpsys)
  syscall_table[SYS_pgrpsys] = "pgrpsys";
#endif
#if defined (SYS_xenix)
  syscall_table[SYS_xenix] = "xenix";
#endif
#if defined (SYS_dup)
  syscall_table[SYS_dup] = "dup";
#endif
#if defined (SYS_pipe)
  syscall_table[SYS_pipe] = "pipe";
#endif
#if defined (SYS_times)
  syscall_table[SYS_times] = "times";
#endif
#if defined (SYS_profil)
  syscall_table[SYS_profil] = "profil";
#endif
#if defined (SYS_plock)
  syscall_table[SYS_plock] = "plock";
#endif
#if defined (SYS_setgid)
  syscall_table[SYS_setgid] = "setgid";
#endif
#if defined (SYS_getgid)
  syscall_table[SYS_getgid] = "getgid";
#endif
#if defined (SYS_signal)
  syscall_table[SYS_signal] = "signal";
#endif
#if defined (SYS_msgsys)
  syscall_table[SYS_msgsys] = "msgsys";
#endif
#if defined (SYS_sys3b)
  syscall_table[SYS_sys3b] = "sys3b";
#endif
#if defined (SYS_sysi86)
  syscall_table[SYS_sysi86] = "sysi86";
#endif
#if defined (SYS_acct)
  syscall_table[SYS_acct] = "acct";
#endif
#if defined (SYS_shmsys)
  syscall_table[SYS_shmsys] = "shmsys";
#endif
#if defined (SYS_semsys)
  syscall_table[SYS_semsys] = "semsys";
#endif
#if defined (SYS_ioctl)
  syscall_table[SYS_ioctl] = "ioctl";
#endif
#if defined (SYS_uadmin)
  syscall_table[SYS_uadmin] = "uadmin";
#endif
#if defined (SYS_utssys)
  syscall_table[SYS_utssys] = "utssys";
#endif
#if defined (SYS_fsync)
  syscall_table[SYS_fsync] = "fsync";
#endif
#if defined (SYS_umask)
  syscall_table[SYS_umask] = "umask";
#endif
#if defined (SYS_chroot)
  syscall_table[SYS_chroot] = "chroot";
#endif
#if defined (SYS_fcntl)
  syscall_table[SYS_fcntl] = "fcntl";
#endif
#if defined (SYS_ulimit)
  syscall_table[SYS_ulimit] = "ulimit";
#endif
#if defined (SYS_rfsys)
  syscall_table[SYS_rfsys] = "rfsys";
#endif
#if defined (SYS_rmdir)
  syscall_table[SYS_rmdir] = "rmdir";
#endif
#if defined (SYS_mkdir)
  syscall_table[SYS_mkdir] = "mkdir";
#endif
#if defined (SYS_getdents)
  syscall_table[SYS_getdents] = "getdents";
#endif
#if defined (SYS_sysfs)
  syscall_table[SYS_sysfs] = "sysfs";
#endif
#if defined (SYS_getmsg)
  syscall_table[SYS_getmsg] = "getmsg";
#endif
#if defined (SYS_putmsg)
  syscall_table[SYS_putmsg] = "putmsg";
#endif
#if defined (SYS_poll)
  syscall_table[SYS_poll] = "poll";
#endif
#if defined (SYS_lstat)
  syscall_table[SYS_lstat] = "lstat";
#endif
#if defined (SYS_symlink)
  syscall_table[SYS_symlink] = "symlink";
#endif
#if defined (SYS_readlink)
  syscall_table[SYS_readlink] = "readlink";
#endif
#if defined (SYS_setgroups)
  syscall_table[SYS_setgroups] = "setgroups";
#endif
#if defined (SYS_getgroups)
  syscall_table[SYS_getgroups] = "getgroups";
#endif
#if defined (SYS_fchmod)
  syscall_table[SYS_fchmod] = "fchmod";
#endif
#if defined (SYS_fchown)
  syscall_table[SYS_fchown] = "fchown";
#endif
#if defined (SYS_sigprocmask)
  syscall_table[SYS_sigprocmask] = "sigprocmask";
#endif
#if defined (SYS_sigsuspend)
  syscall_table[SYS_sigsuspend] = "sigsuspend";
#endif
#if defined (SYS_sigaltstack)
  syscall_table[SYS_sigaltstack] = "sigaltstack";
#endif
#if defined (SYS_sigaction)
  syscall_table[SYS_sigaction] = "sigaction";
#endif
#if defined (SYS_sigpending)
  syscall_table[SYS_sigpending] = "sigpending";
#endif
#if defined (SYS_context)
  syscall_table[SYS_context] = "context";
#endif
#if defined (SYS_evsys)
  syscall_table[SYS_evsys] = "evsys";
#endif
#if defined (SYS_evtrapret)
  syscall_table[SYS_evtrapret] = "evtrapret";
#endif
#if defined (SYS_statvfs)
  syscall_table[SYS_statvfs] = "statvfs";
#endif
#if defined (SYS_fstatvfs)
  syscall_table[SYS_fstatvfs] = "fstatvfs";
#endif
#if defined (SYS_nfssys)
  syscall_table[SYS_nfssys] = "nfssys";
#endif
#if defined (SYS_waitsys)
  syscall_table[SYS_waitsys] = "waitsys";
#endif
#if defined (SYS_sigsendsys)
  syscall_table[SYS_sigsendsys] = "sigsendsys";
#endif
#if defined (SYS_hrtsys)
  syscall_table[SYS_hrtsys] = "hrtsys";
#endif
#if defined (SYS_acancel)
  syscall_table[SYS_acancel] = "acancel";
#endif
#if defined (SYS_async)
  syscall_table[SYS_async] = "async";
#endif
#if defined (SYS_priocntlsys)
  syscall_table[SYS_priocntlsys] = "priocntlsys";
#endif
#if defined (SYS_pathconf)
  syscall_table[SYS_pathconf] = "pathconf";
#endif
#if defined (SYS_mincore)
  syscall_table[SYS_mincore] = "mincore";
#endif
#if defined (SYS_mmap)
  syscall_table[SYS_mmap] = "mmap";
#endif
#if defined (SYS_mprotect)
  syscall_table[SYS_mprotect] = "mprotect";
#endif
#if defined (SYS_munmap)
  syscall_table[SYS_munmap] = "munmap";
#endif
#if defined (SYS_fpathconf)
  syscall_table[SYS_fpathconf] = "fpathconf";
#endif
#if defined (SYS_vfork)
  syscall_table[SYS_vfork] = "vfork";
#endif
#if defined (SYS_fchdir)
  syscall_table[SYS_fchdir] = "fchdir";
#endif
#if defined (SYS_readv)
  syscall_table[SYS_readv] = "readv";
#endif
#if defined (SYS_writev)
  syscall_table[SYS_writev] = "writev";
#endif
#if defined (SYS_xstat)
  syscall_table[SYS_xstat] = "xstat";
#endif
#if defined (SYS_lxstat)
  syscall_table[SYS_lxstat] = "lxstat";
#endif
#if defined (SYS_fxstat)
  syscall_table[SYS_fxstat] = "fxstat";
#endif
#if defined (SYS_xmknod)
  syscall_table[SYS_xmknod] = "xmknod";
#endif
#if defined (SYS_clocal)
  syscall_table[SYS_clocal] = "clocal";
#endif
#if defined (SYS_setrlimit)
  syscall_table[SYS_setrlimit] = "setrlimit";
#endif
#if defined (SYS_getrlimit)
  syscall_table[SYS_getrlimit] = "getrlimit";
#endif
#if defined (SYS_lchown)
  syscall_table[SYS_lchown] = "lchown";
#endif
#if defined (SYS_memcntl)
  syscall_table[SYS_memcntl] = "memcntl";
#endif
#if defined (SYS_getpmsg)
  syscall_table[SYS_getpmsg] = "getpmsg";
#endif
#if defined (SYS_putpmsg)
  syscall_table[SYS_putpmsg] = "putpmsg";
#endif
#if defined (SYS_rename)
  syscall_table[SYS_rename] = "rename";
#endif
#if defined (SYS_uname)
  syscall_table[SYS_uname] = "uname";
#endif
#if defined (SYS_setegid)
  syscall_table[SYS_setegid] = "setegid";
#endif
#if defined (SYS_sysconfig)
  syscall_table[SYS_sysconfig] = "sysconfig";
#endif
#if defined (SYS_adjtime)
  syscall_table[SYS_adjtime] = "adjtime";
#endif
#if defined (SYS_systeminfo)
  syscall_table[SYS_systeminfo] = "systeminfo";
#endif
#if defined (SYS_seteuid)
  syscall_table[SYS_seteuid] = "seteuid";
#endif
#if defined (SYS_sproc)
  syscall_table[SYS_sproc] = "sproc";
#endif
#if defined (SYS_keyctl)
  syscall_table[SYS_keyctl] = "keyctl";
#endif
#if defined (SYS_secsys)
  syscall_table[SYS_secsys] = "secsys";
#endif
#if defined (SYS_filepriv)
  syscall_table[SYS_filepriv] = "filepriv";
#endif
#if defined (SYS_procpriv)
  syscall_table[SYS_procpriv] = "procpriv";
#endif
#if defined (SYS_devstat)
  syscall_table[SYS_devstat] = "devstat";
#endif
#if defined (SYS_aclipc)
  syscall_table[SYS_aclipc] = "aclipc";
#endif
#if defined (SYS_fdevstat)
  syscall_table[SYS_fdevstat] = "fdevstat";
#endif
#if defined (SYS_flvlfile)
  syscall_table[SYS_flvlfile] = "flvlfile";
#endif
#if defined (SYS_lvlfile)
  syscall_table[SYS_lvlfile] = "lvlfile";
#endif
#if defined (SYS_lvlequal)
  syscall_table[SYS_lvlequal] = "lvlequal";
#endif
#if defined (SYS_lvlproc)
  syscall_table[SYS_lvlproc] = "lvlproc";
#endif
#if defined (SYS_lvlipc)
  syscall_table[SYS_lvlipc] = "lvlipc";
#endif
#if defined (SYS_acl)
  syscall_table[SYS_acl] = "acl";
#endif
#if defined (SYS_auditevt)
  syscall_table[SYS_auditevt] = "auditevt";
#endif
#if defined (SYS_auditctl)
  syscall_table[SYS_auditctl] = "auditctl";
#endif
#if defined (SYS_auditdmp)
  syscall_table[SYS_auditdmp] = "auditdmp";
#endif
#if defined (SYS_auditlog)
  syscall_table[SYS_auditlog] = "auditlog";
#endif
#if defined (SYS_auditbuf)
  syscall_table[SYS_auditbuf] = "auditbuf";
#endif
#if defined (SYS_lvldom)
  syscall_table[SYS_lvldom] = "lvldom";
#endif
#if defined (SYS_lvlvfs)
  syscall_table[SYS_lvlvfs] = "lvlvfs";
#endif
#if defined (SYS_mkmld)
  syscall_table[SYS_mkmld] = "mkmld";
#endif
#if defined (SYS_mldmode)
  syscall_table[SYS_mldmode] = "mldmode";
#endif
#if defined (SYS_secadvise)
  syscall_table[SYS_secadvise] = "secadvise";
#endif
#if defined (SYS_online)
  syscall_table[SYS_online] = "online";
#endif
#if defined (SYS_setitimer)
  syscall_table[SYS_setitimer] = "setitimer";
#endif
#if defined (SYS_getitimer)
  syscall_table[SYS_getitimer] = "getitimer";
#endif
#if defined (SYS_gettimeofday)
  syscall_table[SYS_gettimeofday] = "gettimeofday";
#endif
#if defined (SYS_settimeofday)
  syscall_table[SYS_settimeofday] = "settimeofday";
#endif
#if defined (SYS_lwp_create)
  syscall_table[SYS_lwp_create] = "_lwp_create";
#endif
#if defined (SYS_lwp_exit)
  syscall_table[SYS_lwp_exit] = "_lwp_exit";
#endif
#if defined (SYS_lwp_wait)
  syscall_table[SYS_lwp_wait] = "_lwp_wait";
#endif
#if defined (SYS_lwp_self)
  syscall_table[SYS_lwp_self] = "_lwp_self";
#endif
#if defined (SYS_lwp_info)
  syscall_table[SYS_lwp_info] = "_lwp_info";
#endif
#if defined (SYS_lwp_private)
  syscall_table[SYS_lwp_private] = "_lwp_private";
#endif
#if defined (SYS_processor_bind)
  syscall_table[SYS_processor_bind] = "processor_bind";
#endif
#if defined (SYS_processor_exbind)
  syscall_table[SYS_processor_exbind] = "processor_exbind";
#endif
#if defined (SYS_prepblock)
  syscall_table[SYS_prepblock] = "prepblock";
#endif
#if defined (SYS_block)
  syscall_table[SYS_block] = "block";
#endif
#if defined (SYS_rdblock)
  syscall_table[SYS_rdblock] = "rdblock";
#endif
#if defined (SYS_unblock)
  syscall_table[SYS_unblock] = "unblock";
#endif
#if defined (SYS_cancelblock)
  syscall_table[SYS_cancelblock] = "cancelblock";
#endif
#if defined (SYS_pread)
  syscall_table[SYS_pread] = "pread";
#endif
#if defined (SYS_pwrite)
  syscall_table[SYS_pwrite] = "pwrite";
#endif
#if defined (SYS_truncate)
  syscall_table[SYS_truncate] = "truncate";
#endif
#if defined (SYS_ftruncate)
  syscall_table[SYS_ftruncate] = "ftruncate";
#endif
#if defined (SYS_lwp_kill)
  syscall_table[SYS_lwp_kill] = "_lwp_kill";
#endif
#if defined (SYS_sigwait)
  syscall_table[SYS_sigwait] = "sigwait";
#endif
#if defined (SYS_fork1)
  syscall_table[SYS_fork1] = "fork1";
#endif
#if defined (SYS_forkall)
  syscall_table[SYS_forkall] = "forkall";
#endif
#if defined (SYS_modload)
  syscall_table[SYS_modload] = "modload";
#endif
#if defined (SYS_moduload)
  syscall_table[SYS_moduload] = "moduload";
#endif
#if defined (SYS_modpath)
  syscall_table[SYS_modpath] = "modpath";
#endif
#if defined (SYS_modstat)
  syscall_table[SYS_modstat] = "modstat";
#endif
#if defined (SYS_modadm)
  syscall_table[SYS_modadm] = "modadm";
#endif
#if defined (SYS_getksym)
  syscall_table[SYS_getksym] = "getksym";
#endif
#if defined (SYS_lwp_suspend)
  syscall_table[SYS_lwp_suspend] = "_lwp_suspend";
#endif
#if defined (SYS_lwp_continue)
  syscall_table[SYS_lwp_continue] = "_lwp_continue";
#endif
#if defined (SYS_priocntllst)
  syscall_table[SYS_priocntllst] = "priocntllst";
#endif
#if defined (SYS_sleep)
  syscall_table[SYS_sleep] = "sleep";
#endif
#if defined (SYS_lwp_sema_wait)
  syscall_table[SYS_lwp_sema_wait] = "_lwp_sema_wait";
#endif
#if defined (SYS_lwp_sema_post)
  syscall_table[SYS_lwp_sema_post] = "_lwp_sema_post";
#endif
#if defined (SYS_lwp_sema_trywait)
  syscall_table[SYS_lwp_sema_trywait] = "lwp_sema_trywait";
#endif
#if defined(SYS_fstatvfs64)
  syscall_table[SYS_fstatvfs64] = "fstatvfs64";
#endif
#if defined(SYS_statvfs64)
  syscall_table[SYS_statvfs64] = "statvfs64";
#endif
#if defined(SYS_ftruncate64)
  syscall_table[SYS_ftruncate64] = "ftruncate64";
#endif
#if defined(SYS_truncate64)
  syscall_table[SYS_truncate64] = "truncate64";
#endif
#if defined(SYS_getrlimit64)
  syscall_table[SYS_getrlimit64] = "getrlimit64";
#endif
#if defined(SYS_setrlimit64)
  syscall_table[SYS_setrlimit64] = "setrlimit64";
#endif
#if defined(SYS_lseek64)
  syscall_table[SYS_lseek64] = "lseek64";
#endif
#if defined(SYS_mmap64)
  syscall_table[SYS_mmap64] = "mmap64";
#endif
#if defined(SYS_pread64)
  syscall_table[SYS_pread64] = "pread64";
#endif
#if defined(SYS_creat64)
  syscall_table[SYS_creat64] = "creat64";
#endif
#if defined(SYS_dshmsys)
  syscall_table[SYS_dshmsys] = "dshmsys";
#endif
#if defined(SYS_invlpg)
  syscall_table[SYS_invlpg] = "invlpg";
#endif
#if defined(SYS_cg_ids)
  syscall_table[SYS_cg_ids] = "cg_ids";
#endif
#if defined(SYS_cg_processors)
  syscall_table[SYS_cg_processors] = "cg_processors";
#endif
#if defined(SYS_cg_info)
  syscall_table[SYS_cg_info] = "cg_info";
#endif
#if defined(SYS_cg_bind)
  syscall_table[SYS_cg_bind] = "cg_bind";
#endif
#if defined(SYS_cg_current)
  syscall_table[SYS_cg_current] = "cg_current";
#endif
#if defined(SYS_cg_memloc)
  syscall_table[SYS_cg_memloc] = "cg_memloc";
#endif
}

/*

LOCAL FUNCTION

	procfs_kill_inferior - kill any currently inferior

SYNOPSIS

	void procfs_kill_inferior (void)

DESCRIPTION

	Kill any current inferior.

NOTES

	Kills even attached inferiors.  Presumably the user has already
	been prompted that the inferior is an attached one rather than
	one started by gdb.  (FIXME?)

*/

static void
procfs_kill_inferior ()
{
  target_mourn_inferior ();
}

/*

LOCAL FUNCTION

	unconditionally_kill_inferior - terminate the inferior

SYNOPSIS

	static void unconditionally_kill_inferior (struct procinfo *)

DESCRIPTION

	Kill the specified inferior.

NOTE

	A possibly useful enhancement would be to first try sending
	the inferior a terminate signal, politely asking it to commit
	suicide, before we murder it (we could call that
	politely_kill_inferior()).

*/

static void
unconditionally_kill_inferior (pi)
     struct procinfo *pi;
{
  int ppid;
  struct proc_ctl pctl;
  
  ppid = pi->prstatus.pr_ppid;

#ifdef PROCFS_NEED_CLEAR_CURSIG_FOR_KILL
  /* Alpha OSF/1-3.x procfs needs a clear of the current signal
     before the PIOCKILL, otherwise it might generate a corrupted core
     file for the inferior.  */
  ioctl (pi->ctl_fd, PIOCSSIG, NULL);
#endif
#ifdef PROCFS_NEED_PIOCSSIG_FOR_KILL
  /* Alpha OSF/1-2.x procfs needs a PIOCSSIG call with a SIGKILL signal
     to kill the inferior, otherwise it might remain stopped with a
     pending SIGKILL.
     We do not check the result of the PIOCSSIG, the inferior might have
     died already.  */
  {
    struct siginfo newsiginfo;

    memset ((char *) &newsiginfo, 0, sizeof (newsiginfo));
    newsiginfo.si_signo = SIGKILL;
    newsiginfo.si_code = 0;
    newsiginfo.si_errno = 0;
    newsiginfo.si_pid = getpid ();
    newsiginfo.si_uid = getuid ();
    ioctl (pi->ctl_fd, PIOCSSIG, &newsiginfo);
  }
#else /* PROCFS_NEED_PIOCSSIG_FOR_KILL */
  procfs_write_pckill (pi);
#endif /* PROCFS_NEED_PIOCSSIG_FOR_KILL */

  close_proc_file (pi);

/* Only wait() for our direct children.  Our grandchildren zombies are killed
   by the death of their parents.  */

  if (ppid == getpid())
    wait ((int *) 0);
}

/*

LOCAL FUNCTION

	procfs_xfer_memory -- copy data to or from inferior memory space

SYNOPSIS

	int procfs_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
		int dowrite, struct target_ops target)

DESCRIPTION

	Copy LEN bytes to/from inferior's memory starting at MEMADDR
	from/to debugger memory starting at MYADDR.  Copy from inferior
	if DOWRITE is zero or to inferior if DOWRITE is nonzero.
  
	Returns the length copied, which is either the LEN argument or
	zero.  This xfer function does not do partial moves, since procfs_ops
	doesn't allow memory operations to cross below us in the target stack
	anyway.

NOTES

	The /proc interface makes this an almost trivial task.
 */

static int
procfs_xfer_memory (memaddr, myaddr, len, dowrite, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int dowrite;
     struct target_ops *target; /* ignored */
{
  int nbytes = 0;
  struct procinfo *pi;

  pi = current_procinfo;

  if (lseek(pi->as_fd, (off_t) memaddr, SEEK_SET) == (off_t) memaddr)
    {
      if (dowrite)
	{
	  nbytes = write (pi->as_fd, myaddr, len);
	}
      else
	{
	  nbytes = read (pi->as_fd, myaddr, len);
	}
      if (nbytes < 0)
	{
	  nbytes = 0;
	}
    }
  return (nbytes);
}

/*

LOCAL FUNCTION

	procfs_store_registers -- copy register values back to inferior

SYNOPSIS

	void procfs_store_registers (int regno)

DESCRIPTION

	Store our current register values back into the inferior.  If
	REGNO is -1 then store all the register, otherwise store just
	the value specified by REGNO.

NOTES

	If we are storing only a single register, we first have to get all
	the current values from the process, overwrite the desired register
	in the gregset with the one we want from gdb's registers, and then
	send the whole set back to the process.  For writing all the
	registers, all we have to do is generate the gregset and send it to
	the process.

	Also note that the process has to be stopped on an event of interest
	for this to work, which basically means that it has to have been
	run under the control of one of the other /proc ioctl calls and not
	ptrace.  Since we don't use ptrace anyway, we don't worry about this
	fine point, but it is worth noting for future reference.

	Gdb is confused about what this function is supposed to return.
	Some versions return a value, others return nothing.  Some are
	declared to return a value and actually return nothing.  Gdb ignores
	anything returned.  (FIXME)

 */

static void
procfs_store_registers (regno)
     int regno;
{
  struct procinfo *pi;
#ifdef PROCFS_USE_READ_WRITE
  struct greg_ctl greg;
  struct fpreg_ctl fpreg;
#endif

  pi = current_procinfo;

#ifdef PROCFS_USE_READ_WRITE
  if (regno != -1)
    {
      procfs_read_status (pi);
      memcpy ((char *) &greg.gregset,
         (char *) &pi->prstatus.pr_lwp.pr_context.uc_mcontext.gregs,
         sizeof (gdb_gregset_t));
    }
  fill_gregset (&greg.gregset, regno);
  greg.cmd = PCSREG;
  write (pi->ctl_fd, &greg, sizeof (greg));
#else /* PROCFS_USE_READ_WRITE */
  if (regno != -1)
    {
      ioctl (pi->ctl_fd, PIOCGREG, &pi->gregset.gregset);
    }
  fill_gregset (&pi->gregset.gregset, regno);
  ioctl (pi->ctl_fd, PIOCSREG, &pi->gregset.gregset);
#endif /* PROCFS_USE_READ_WRITE */

#if defined (FP0_REGNUM)

  /* Now repeat everything using the floating point register set, if the
     target has floating point hardware. Since we ignore the returned value,
     we'll never know whether it worked or not anyway. */

#ifdef PROCFS_USE_READ_WRITE
  if (regno != -1)
    {
      procfs_read_status (pi);
      memcpy ((char *) &fpreg.fpregset,
          (char *) &pi->prstatus.pr_lwp.pr_context.uc_mcontext.fpregs,
          sizeof (gdb_fpregset_t));
    }
  fill_fpregset (&fpreg.fpregset, regno);
  fpreg.cmd = PCSFPREG;
  write (pi->ctl_fd, &fpreg, sizeof (fpreg));
#else /* PROCFS_USE_READ_WRITE */
  if (regno != -1)
    {
      ioctl (pi->ctl_fd, PIOCGFPREG, &pi->fpregset.fpregset);
    }
  fill_fpregset (&pi->fpregset.fpregset, regno);
  ioctl (pi->ctl_fd, PIOCSFPREG, &pi->fpregset.fpregset);
#endif /* PROCFS_USE_READ_WRITE */

#endif	/* FP0_REGNUM */

}

/*

LOCAL FUNCTION

	init_procinfo - setup a procinfo struct and connect it to a process

SYNOPSIS

	struct procinfo * init_procinfo (int pid)

DESCRIPTION

	Allocate a procinfo structure, open the /proc file and then set up the
	set of signals and faults that are to be traced.  Returns a pointer to
	the new procinfo structure.  

NOTES

	If proc_init_failed ever gets called, control returns to the command
	processing loop via the standard error handling code.

 */

static struct procinfo *
init_procinfo (pid, kill)
     int pid;
     int kill;
{
  struct procinfo *pi = (struct procinfo *) 
    xmalloc (sizeof (struct procinfo));
  struct sig_ctl  sctl;
  struct flt_ctl  fctl;

  memset ((char *) pi, 0, sizeof (*pi));
  if (!open_proc_file (pid, pi, O_RDWR, 1))
    proc_init_failed (pi, "can't open process file", kill);

  /* open_proc_file may modify pid.  */

  pid = pi -> pid;

  /* Add new process to process info list */

  pi->next = procinfo_list;
  procinfo_list = pi;

  add_fd (pi);			/* Add to list for poll/select */

  /*  Remember some things about the inferior that we will, or might, change
      so that we can restore them when we detach. */
#ifdef UNIXWARE
  memcpy ((char *) &pi->saved_trace.sigset,
	  (char *) &pi->prstatus.pr_sigtrace, sizeof (sigset_t));
  memcpy ((char *) &pi->saved_fltset.fltset,
	  (char *) &pi->prstatus.pr_flttrace, sizeof (fltset_t));
  memcpy ((char *) &pi->saved_entryset.sysset,
	  (char *) &pi->prstatus.pr_sysentry, sizeof (sysset_t));
  memcpy ((char *) &pi->saved_exitset.sysset,
	  (char *) &pi->prstatus.pr_sysexit, sizeof (sysset_t));

  /* Set up trace and fault sets, as gdb expects them. */

  prfillset (&sctl.sigset);
  notice_signals (pi, &sctl);
  prfillset (&fctl.fltset);
  prdelset (&fctl.fltset, FLTPAGE);

#else /* ! UNIXWARE */
  ioctl (pi->ctl_fd, PIOCGTRACE, &pi->saved_trace.sigset);
  ioctl (pi->ctl_fd, PIOCGHOLD, &pi->saved_sighold.sigset);
  ioctl (pi->ctl_fd, PIOCGFAULT, &pi->saved_fltset.fltset);
  ioctl (pi->ctl_fd, PIOCGENTRY, &pi->saved_entryset.sysset);
  ioctl (pi->ctl_fd, PIOCGEXIT, &pi->saved_exitset.sysset);
  
  /* Set up trace and fault sets, as gdb expects them. */
  
  memset ((char *) &pi->prrun, 0, sizeof (pi->prrun));
  prfillset (&pi->prrun.pr_trace);
  procfs_notice_signals (pid);
  prfillset (&pi->prrun.pr_fault);
  prdelset (&pi->prrun.pr_fault, FLTPAGE);
#ifdef PROCFS_DONT_TRACE_FAULTS
  premptyset (&pi->prrun.pr_fault);
#endif
#endif /* UNIXWARE */

  if (!procfs_read_status (pi))
    proc_init_failed (pi, "procfs_read_status failed", kill);

  return pi;
}

/*

LOCAL FUNCTION

	create_procinfo - initialize access to a /proc entry

SYNOPSIS

	struct procinfo * create_procinfo (int pid)

DESCRIPTION

	Allocate a procinfo structure, open the /proc file and then set up the
	set of signals and faults that are to be traced.  Returns a pointer to
	the new procinfo structure.

NOTES

	If proc_init_failed ever gets called, control returns to the command
	processing loop via the standard error handling code.

 */

static struct procinfo *
create_procinfo (pid)
     int pid;
{
  struct procinfo *pi;
  struct sig_ctl  sctl;
  struct flt_ctl  fctl;

  pi = find_procinfo (pid, 1);
  if (pi != NULL)
    return pi;			/* All done!  It already exists */

  pi = init_procinfo (pid, 1);

#ifndef UNIXWARE
/* A bug in Solaris (2.5 at least) causes PIOCWSTOP to hang on LWPs that are
   already stopped, even if they all have PR_ASYNC set.  */
  if (!(pi->prstatus.pr_flags & PR_STOPPED))
#endif
    if (!procfs_write_pcwstop (pi))
      proc_init_failed (pi, "procfs_write_pcwstop failed", 1);

#ifdef PROCFS_USE_READ_WRITE
  fctl.cmd = PCSFAULT;
  if (write (pi->ctl_fd, (char *) &fctl, sizeof (struct flt_ctl)) < 0)
    proc_init_failed (pi, "PCSFAULT failed", 1);
#else
  if (ioctl (pi->ctl_fd, PIOCSFAULT, &pi->prrun.pr_fault) < 0)
    proc_init_failed (pi, "PIOCSFAULT failed", 1);
#endif

  return pi;
}

/*

LOCAL FUNCTION

	procfs_exit_handler - handle entry into the _exit syscall

SYNOPSIS

	int procfs_exit_handler (pi, syscall_num, why, rtnvalp, statvalp)

DESCRIPTION

	This routine is called when an inferior process enters the _exit()
	system call.  It continues the process, and then collects the exit
	status and pid which are returned in *statvalp and *rtnvalp.  After
	that it returns non-zero to indicate that procfs_wait should wake up.

NOTES
	There is probably a better way to do this.

 */

static int
procfs_exit_handler (pi, syscall_num, why, rtnvalp, statvalp)
     struct procinfo *pi;
     int syscall_num;
     int why;
     int *rtnvalp;
     int *statvalp;
{
  struct procinfo *temp_pi, *next_pi;
  struct proc_ctl pctl;

#ifdef UNIXWARE
  pctl.cmd = PCRUN;
  pctl.data = PRCFAULT;
#else
  pi->prrun.pr_flags = PRCFAULT;
#endif

#ifdef PROCFS_USE_READ_WRITE
  if (write (pi->ctl_fd, (char *)&pctl, sizeof (struct proc_ctl)) < 0)
#else
  if (ioctl (pi->ctl_fd, PIOCRUN, &pi->prrun) != 0)
#endif
    perror_with_name (pi->pathname);

  if (attach_flag)
    {
      /* Claim it exited (don't call wait). */
      if (info_verbose)
	printf_filtered ("(attached process has exited)\n");
      *statvalp = 0;
      *rtnvalp  = inferior_pid;
    }
  else
    {
      *rtnvalp = wait (statvalp);
      if (*rtnvalp >= 0)
	*rtnvalp = pi->pid;
    }

  /* Close ALL open proc file handles,
     except the one that called SYS_exit. */
  for (temp_pi = procinfo_list; temp_pi; temp_pi = next_pi)
    {
      next_pi = temp_pi->next;
      if (temp_pi == pi)
	continue;		/* Handled below */
      close_proc_file (temp_pi);
    }
  return 1;
}

/*

LOCAL FUNCTION

	procfs_exec_handler - handle exit from the exec family of syscalls

SYNOPSIS

	int procfs_exec_handler (pi, syscall_num, why, rtnvalp, statvalp)

DESCRIPTION

	This routine is called when an inferior process is about to finish any
	of the exec() family of	system calls.  It pretends that we got a
	SIGTRAP (for compatibility with ptrace behavior), and returns non-zero
	to tell procfs_wait to wake up.

NOTES
	This need for compatibility with ptrace is questionable.  In the
	future, it shouldn't be necessary.

 */

static int
procfs_exec_handler (pi, syscall_num, why, rtnvalp, statvalp)
     struct procinfo *pi;
     int syscall_num;
     int why;
     int *rtnvalp;
     int *statvalp;
{
  *statvalp = (SIGTRAP << 8) | 0177;

  return 1;
}

#if defined(SYS_sproc) && !defined(UNIXWARE)
/* IRIX lwp creation system call */

/*

LOCAL FUNCTION

	procfs_sproc_handler - handle exit from the sproc syscall

SYNOPSIS

	int procfs_sproc_handler (pi, syscall_num, why, rtnvalp, statvalp)

DESCRIPTION

	This routine is called when an inferior process is about to finish an
	sproc() system call.  This is the system call that IRIX uses to create
	a lightweight process.  When the target process gets this event, we can
	look at rval1 to find the new child processes ID, and create a new
	procinfo struct from that.

	After that, it pretends that we got a SIGTRAP, and returns non-zero
	to tell procfs_wait to wake up.  Subsequently, wait_for_inferior gets
	woken up, sees the new process and continues it.

NOTES
	We actually never see the child exiting from sproc because we will
	shortly stop the child with PIOCSTOP, which is then registered as the
	event of interest.
 */

static int
procfs_sproc_handler (pi, syscall_num, why, rtnvalp, statvalp)
     struct procinfo *pi;
     int syscall_num;
     int why;
     int *rtnvalp;
     int *statvalp;
{
/* We've just detected the completion of an sproc system call.  Now we need to
   setup a procinfo struct for this thread, and notify the thread system of the
   new arrival.  */

/* If sproc failed, then nothing interesting happened.  Continue the process
   and go back to sleep. */

  if (pi->prstatus.pr_errno != 0)
    {
      pi->prrun.pr_flags &= PRSTEP;
      pi->prrun.pr_flags |= PRCFAULT;

      if (ioctl (pi->ctl_fd, PIOCRUN, &pi->prrun) != 0)
	perror_with_name (pi->pathname);

      return 0;
    }

  /* At this point, the new thread is stopped at it's first instruction, and
     the parent is stopped at the exit from sproc.  */

  /* Notify the caller of the arrival of a new thread. */
  create_procinfo (pi->prstatus.pr_rval1);

  *rtnvalp = pi->prstatus.pr_rval1;
  *statvalp = (SIGTRAP << 8) | 0177;

  return 1;
}

/*

LOCAL FUNCTION

	procfs_fork_handler - handle exit from the fork syscall

SYNOPSIS

	int procfs_fork_handler (pi, syscall_num, why, rtnvalp, statvalp)

DESCRIPTION

	This routine is called when an inferior process is about to finish a
	fork() system call.  We will open up the new process, and then close
	it, which releases it from the clutches of the debugger.

	After that, we continue the target process as though nothing had
	happened.

NOTES
	This is necessary for IRIX because we have to set PR_FORK in order
	to catch the creation of lwps (via sproc()).  When an actual fork
	occurs, it becomes necessary to reset the forks debugger flags and
	continue it because we can't hack multiple processes yet.
 */

static int
procfs_fork_handler (pi, syscall_num, why, rtnvalp, statvalp)
     struct procinfo *pi;
     int syscall_num;
     int why;
     int *rtnvalp;
     int *statvalp;
{
  struct procinfo *pitemp;

/* At this point, we've detected the completion of a fork (or vfork) call in
   our child.  The grandchild is also stopped because we set inherit-on-fork
   earlier.  (Note that nobody has the grandchilds' /proc file open at this
   point.)  We will release the grandchild from the debugger by opening it's
   /proc file and then closing it.  Since run-on-last-close is set, the
   grandchild continues on its' merry way.  */


  pitemp = create_procinfo (pi->prstatus.pr_rval1);
  if (pitemp)
    close_proc_file (pitemp);

  if (ioctl (pi->ctl_fd, PIOCRUN, &pi->prrun) != 0)
    perror_with_name (pi->pathname);

  return 0;
}
#endif /* SYS_sproc && !UNIXWARE */

/*

LOCAL FUNCTION

	procfs_set_inferior_syscall_traps - setup the syscall traps 

SYNOPSIS

	void procfs_set_inferior_syscall_traps (struct procinfo *pip)

DESCRIPTION

	Called for each "procinfo" (process, thread, or LWP) in the
	inferior, to register for notification of and handlers for
	syscall traps in the inferior.

 */

static void
procfs_set_inferior_syscall_traps (pip)
     struct procinfo *pip;
{
  procfs_set_syscall_trap (pip, SYS_exit, PROCFS_SYSCALL_ENTRY,
			   procfs_exit_handler);

#ifndef PRFS_STOPEXEC
#ifdef SYS_exec
  procfs_set_syscall_trap (pip, SYS_exec, PROCFS_SYSCALL_EXIT,
			   procfs_exec_handler);
#endif
#ifdef SYS_execv
  procfs_set_syscall_trap (pip, SYS_execv, PROCFS_SYSCALL_EXIT,
			   procfs_exec_handler);
#endif
#ifdef SYS_execve
  procfs_set_syscall_trap (pip, SYS_execve, PROCFS_SYSCALL_EXIT,
			   procfs_exec_handler);
#endif
#endif  /* PRFS_STOPEXEC */

  /* Setup traps on exit from sproc() */

#ifdef SYS_sproc
  procfs_set_syscall_trap (pip, SYS_sproc, PROCFS_SYSCALL_EXIT,
			   procfs_sproc_handler);
  procfs_set_syscall_trap (pip, SYS_fork, PROCFS_SYSCALL_EXIT,
			   procfs_fork_handler);
#ifdef SYS_vfork
  procfs_set_syscall_trap (pip, SYS_vfork, PROCFS_SYSCALL_EXIT,
			   procfs_fork_handler);
#endif
/* Turn on inherit-on-fork flag so that all children of the target process
   start with tracing flags set.  This allows us to trap lwp creation.  Note
   that we also have to trap on fork and vfork in order to disable all tracing
   in the targets child processes.  */

  modify_inherit_on_fork_flag (pip->ctl_fd, 1);
#endif

#ifdef SYS_lwp_create
  procfs_set_syscall_trap (pip, SYS_lwp_create, PROCFS_SYSCALL_EXIT,
			   procfs_lwp_creation_handler);
#endif
}

/*

LOCAL FUNCTION

	procfs_init_inferior - initialize target vector and access to a
	/proc entry

SYNOPSIS

	void procfs_init_inferior (int pid)

DESCRIPTION

	When gdb starts an inferior, this function is called in the parent
	process immediately after the fork.  It waits for the child to stop
	on the return from the exec system call (the child itself takes care
	of ensuring that this is set up), then sets up the set of signals
	and faults that are to be traced.  Returns the pid, which may have had
	the thread-id added to it.

NOTES

	If proc_init_failed ever gets called, control returns to the command
	processing loop via the standard error handling code.

 */

static void 
procfs_init_inferior (pid)
     int pid;
{
  struct procinfo *pip;

  push_target (&procfs_ops);

  pip = create_procinfo (pid);

  procfs_set_inferior_syscall_traps (pip);

  /* create_procinfo may change the pid, so we have to update inferior_pid
     here before calling other gdb routines that need the right pid.  */

  pid = pip -> pid;
  inferior_pid = pid;

  add_thread (pip -> pid);	/* Setup initial thread */

#ifdef START_INFERIOR_TRAPS_EXPECTED
  startup_inferior (START_INFERIOR_TRAPS_EXPECTED);
#else
  /* One trap to exec the shell, one to exec the program being debugged.  */
  startup_inferior (2);
#endif
}

/*

GLOBAL FUNCTION

	procfs_notice_signals

SYNOPSIS

	static void procfs_notice_signals (int pid);

DESCRIPTION

	When the user changes the state of gdb's signal handling via the
	"handle" command, this function gets called to see if any change
	in the /proc interface is required.  It is also called internally
	by other /proc interface functions to initialize the state of
	the traced signal set.

	One thing it does is that signals for which the state is "nostop",
	"noprint", and "pass", have their trace bits reset in the pr_trace
	field, so that they are no longer traced.  This allows them to be
	delivered directly to the inferior without the debugger ever being
	involved.
 */

static void
procfs_notice_signals (pid)
     int pid;
{
  struct procinfo *pi;
  struct sig_ctl  sctl;

  pi = find_procinfo (pid, 0);

#ifndef HAVE_PRRUN_T
  premptyset (&sctl.sigset);
#else
  sctl.sigset = pi->prrun.pr_trace;
#endif

  notice_signals (pi, &sctl);

#ifdef HAVE_PRRUN_T
  pi->prrun.pr_trace = sctl.sigset;
#endif
}

static void
notice_signals (pi, sctl)
	struct procinfo *pi;
	struct sig_ctl *sctl;
{
  int signo;

  for (signo = 0; signo < NSIG; signo++)
    {
      if (signal_stop_state (target_signal_from_host (signo)) == 0 &&
	  signal_print_state (target_signal_from_host (signo)) == 0 &&
	  signal_pass_state (target_signal_from_host (signo)) == 1)
	{
	  prdelset (&sctl->sigset, signo);
	}
      else
	{
	  praddset (&sctl->sigset, signo);
	}
    }
#ifdef PROCFS_USE_READ_WRITE
  sctl->cmd = PCSTRACE;
  if (write (pi->ctl_fd, (char *) sctl, sizeof (struct sig_ctl)) < 0)
#else
  if (ioctl (pi->ctl_fd, PIOCSTRACE, &sctl->sigset))
#endif
    {
      print_sys_errmsg ("PIOCSTRACE failed", errno);
    }
}

/*

LOCAL FUNCTION

	proc_set_exec_trap -- arrange for exec'd child to halt at startup

SYNOPSIS

	void proc_set_exec_trap (void)

DESCRIPTION

	This function is called in the child process when starting up
	an inferior, prior to doing the exec of the actual inferior.
	It sets the child process's exitset to make exit from the exec
	system call an event of interest to stop on, and then simply
	returns.  The child does the exec, the system call returns, and
	the child stops at the first instruction, ready for the gdb
	parent process to take control of it.

NOTE

	We need to use all local variables since the child may be sharing
	it's data space with the parent, if vfork was used rather than
	fork.

	Also note that we want to turn off the inherit-on-fork flag in
	the child process so that any grand-children start with all
	tracing flags cleared.
 */

static void
proc_set_exec_trap ()
{
  struct sys_ctl exitset;
  struct sys_ctl entryset;
  char procname[MAX_PROC_NAME_SIZE];
  int fd;
  
  sprintf (procname, CTL_PROC_NAME_FMT, getpid ());
#ifdef UNIXWARE
  if ((fd = open (procname, O_WRONLY)) < 0)
#else
  if ((fd = open (procname, O_RDWR)) < 0)
#endif
    {
      perror (procname);
      gdb_flush (gdb_stderr);
      _exit (127);
    }
  premptyset (&exitset.sysset);
  premptyset (&entryset.sysset);

#ifdef PRFS_STOPEXEC
  /* Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace
     exits from exec system calls because of the user level loader.  */
  {
    int prfs_flags;

    if (ioctl (fd, PIOCGSPCACT, &prfs_flags) < 0)
      {
	perror (procname);
	gdb_flush (gdb_stderr);
	_exit (127);
      }
    prfs_flags |= PRFS_STOPEXEC;
    if (ioctl (fd, PIOCSSPCACT, &prfs_flags) < 0)
      {
	perror (procname);
	gdb_flush (gdb_stderr);
	_exit (127);
      }
  }
#else /* PRFS_STOPEXEC */
  /* GW: Rationale...
     Not all systems with /proc have all the exec* syscalls with the same
     names.  On the SGI, for example, there is no SYS_exec, but there
     *is* a SYS_execv.  So, we try to account for that. */

#ifdef SYS_exec
  praddset (&exitset.sysset, SYS_exec);
#endif
#ifdef SYS_execve
  praddset (&exitset.sysset, SYS_execve);
#endif
#ifdef SYS_execv
  praddset (&exitset.sysset, SYS_execv);
#endif

#ifdef PROCFS_USE_READ_WRITE
  exitset.cmd = PCSEXIT;
  if (write (fd, (char *) &exitset, sizeof (struct sys_ctl)) < 0)
#else
  if (ioctl (fd, PIOCSEXIT, &exitset.sysset) < 0)
#endif
    {
      perror (procname);
      gdb_flush (gdb_stderr);
      _exit (127);
    }
#endif /* PRFS_STOPEXEC */

  praddset (&entryset.sysset, SYS_exit);

#ifdef PROCFS_USE_READ_WRITE
  entryset.cmd = PCSENTRY;
  if (write (fd, (char *) &entryset, sizeof (struct sys_ctl)) < 0)
#else
  if (ioctl (fd, PIOCSENTRY, &entryset.sysset) < 0)
#endif
    {
      perror (procname);
      gdb_flush (gdb_stderr);
      _exit (126);
    }

  /* Turn off inherit-on-fork flag so that all grand-children of gdb
     start with tracing flags cleared. */

  modify_inherit_on_fork_flag (fd, 0);

  /* Turn on run-on-last-close flag so that this process will not hang
     if GDB goes away for some reason.  */

  modify_run_on_last_close_flag (fd, 1);

#ifndef UNIXWARE	/* since this is a solaris-ism, we don't want it */
			/* NOTE: revisit when doing thread support for UW */
#ifdef PR_ASYNC
  {
    long pr_flags;
    struct proc_ctl pctl;

/* Solaris needs this to make procfs treat all threads seperately.  Without
   this, all threads halt whenever something happens to any thread.  Since
   GDB wants to control all this itself, it needs to set PR_ASYNC.  */

    pr_flags = PR_ASYNC;
#ifdef PROCFS_USE_READ_WRITE
    pctl.cmd = PCSET;
    pctl.data = PR_FORK|PR_ASYNC;
    write (fd, (char *) &pctl, sizeof (struct proc_ctl));
#else
    ioctl (fd, PIOCSET, &pr_flags);
#endif
  }
#endif	/* PR_ASYNC */
#endif	/* !UNIXWARE */
}

/*

GLOBAL FUNCTION

	proc_iterate_over_mappings -- call function for every mapped space

SYNOPSIS

	int proc_iterate_over_mappings (int (*func)())

DESCRIPTION

	Given a pointer to a function, call that function for every
	mapped address space, passing it an open file descriptor for
	the file corresponding to that mapped address space (if any)
	and the base address of the mapped space.  Quit when we hit
	the end of the mappings or the function returns nonzero.
 */

#ifdef UNIXWARE
int
proc_iterate_over_mappings (func)
     int (*func) PARAMS ((int, CORE_ADDR));
{
  int nmap;
  int fd;
  int funcstat = 0;
  prmap_t *prmaps;
  prmap_t *prmap;
  struct procinfo *pi;
  struct stat sbuf;

  pi = current_procinfo;

  if (fstat (pi->map_fd, &sbuf) < 0)
    return 0;

  nmap = sbuf.st_size / sizeof (prmap_t);
  prmaps = (prmap_t *) alloca (nmap * sizeof(prmap_t));
  if ((lseek (pi->map_fd, 0, SEEK_SET) == 0) &&
	(read (pi->map_fd, (char *) prmaps, nmap * sizeof (prmap_t)) ==
	(nmap * sizeof (prmap_t))))
    {
      int i = 0;
      for (prmap = prmaps; i < nmap && funcstat == 0; ++prmap, ++i)
        {
          char name[sizeof ("/proc/1234567890/object") +
		sizeof (prmap->pr_mapname)];
          sprintf (name, "/proc/%d/object/%s", pi->pid, prmap->pr_mapname);
          if ((fd = open (name, O_RDONLY)) == -1)
            {
              funcstat = 1;
              break;
            }
          funcstat = (*func) (fd, (CORE_ADDR) prmap->pr_vaddr);
          close (fd);
        }
    }
  return (funcstat);
}
#else /* UNIXWARE */
int
proc_iterate_over_mappings (func)
     int (*func) PARAMS ((int, CORE_ADDR));
{
  int nmap;
  int fd;
  int funcstat = 0;
  struct prmap *prmaps;
  struct prmap *prmap;
  struct procinfo *pi;

  pi = current_procinfo;

  if (ioctl (pi->map_fd, PIOCNMAP, &nmap) == 0)
    {
      prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));
      if (ioctl (pi->map_fd, PIOCMAP, prmaps) == 0)
	{
	  for (prmap = prmaps; prmap -> pr_size && funcstat == 0; ++prmap)
	    {
	      fd = proc_address_to_fd (pi, (CORE_ADDR) prmap -> pr_vaddr, 0);
	      funcstat = (*func) (fd, (CORE_ADDR) prmap -> pr_vaddr);
	      close (fd);
	    }
	}
    }
  return (funcstat);
}
#endif /* UNIXWARE */

#if 0	/* Currently unused */
/*

GLOBAL FUNCTION

	proc_base_address -- find base address for segment containing address

SYNOPSIS

	CORE_ADDR proc_base_address (CORE_ADDR addr)

DESCRIPTION

	Given an address of a location in the inferior, find and return
	the base address of the mapped segment containing that address.

	This is used for example, by the shared library support code,
	where we have the pc value for some location in the shared library
	where we are stopped, and need to know the base address of the
	segment containing that address.
*/

CORE_ADDR
proc_base_address (addr)
     CORE_ADDR addr;
{
  int nmap;
  struct prmap *prmaps;
  struct prmap *prmap;
  CORE_ADDR baseaddr = 0;
  struct procinfo *pi;

  pi = current_procinfo;

  if (ioctl (pi->map_fd, PIOCNMAP, &nmap) == 0)
    {
      prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));
      if (ioctl (pi->map_fd, PIOCMAP, prmaps) == 0)
	{
	  for (prmap = prmaps; prmap -> pr_size; ++prmap)
	    {
	      if ((prmap -> pr_vaddr <= (caddr_t) addr) &&
		  (prmap -> pr_vaddr + prmap -> pr_size > (caddr_t) addr))
		{
		  baseaddr = (CORE_ADDR) prmap -> pr_vaddr;
		  break;
		}
	    }
	}
    }
  return (baseaddr);
}

#endif	/* 0 */

#ifndef UNIXWARE
/*

LOCAL FUNCTION

	proc_address_to_fd -- return open fd for file mapped to address

SYNOPSIS

	int proc_address_to_fd (struct procinfo *pi, CORE_ADDR addr, complain)

DESCRIPTION

	Given an address in the current inferior's address space, use the
	/proc interface to find an open file descriptor for the file that
	this address was mapped in from.  Return -1 if there is no current
	inferior.  Print a warning message if there is an inferior but
	the address corresponds to no file (IE a bogus address).

*/

static int
proc_address_to_fd (pi, addr, complain)
     struct procinfo *pi;
     CORE_ADDR addr;
     int complain;
{
  int fd = -1;

  if ((fd = ioctl (pi->ctl_fd, PIOCOPENM, (caddr_t *) &addr)) < 0)
    {
      if (complain)
	{
	  print_sys_errmsg (pi->pathname, errno);
	  warning ("can't find mapped file for address 0x%x", addr);
	}
    }
  return (fd);
}
#endif /* !UNIXWARE */

/* Attach to process PID, then initialize for debugging it
   and wait for the trace-trap that results from attaching.  */

static void
procfs_attach (args, from_tty)
     char *args;
     int from_tty;
{
  char *exec_file;
  int pid;

  if (!args)
    error_no_arg ("process-id to attach");

  pid = atoi (args);

  if (pid == getpid())		/* Trying to masturbate? */
    error ("I refuse to debug myself!");

  if (from_tty)
    {
      exec_file = (char *) get_exec_file (0);

      if (exec_file)
	printf_unfiltered ("Attaching to program `%s', %s\n", exec_file, target_pid_to_str (pid));
      else
	printf_unfiltered ("Attaching to %s\n", target_pid_to_str (pid));

      gdb_flush (gdb_stdout);
    }

  inferior_pid = pid = do_attach (pid);
  push_target (&procfs_ops);
}


/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via the normal ptrace (PTRACE_TRACEME).  */

static void
procfs_detach (args, from_tty)
     char *args;
     int from_tty;
{
  int siggnal = 0;

  if (from_tty)
    {
      char *exec_file = get_exec_file (0);
      if (exec_file == 0)
	exec_file = "";
      printf_unfiltered ("Detaching from program: %s %s\n",
	      exec_file, target_pid_to_str (inferior_pid));
      gdb_flush (gdb_stdout);
    }
  if (args)
    siggnal = atoi (args);
  
  do_detach (siggnal);
  inferior_pid = 0;
  unpush_target (&procfs_ops);		/* Pop out of handling an inferior */
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
procfs_prepare_to_store ()
{
#ifdef CHILD_PREPARE_TO_STORE
  CHILD_PREPARE_TO_STORE ();
#endif
}

/* Print status information about what we're accessing.  */

static void
procfs_files_info (ignore)
     struct target_ops *ignore;
{
  printf_unfiltered ("\tUsing the running image of %s %s via /proc.\n",
	  attach_flag? "attached": "child", target_pid_to_str (inferior_pid));
}

/* ARGSUSED */
static void
procfs_open (arg, from_tty)
     char *arg;
     int from_tty;
{
  error ("Use the \"run\" command to start a Unix child process.");
}

/*

LOCAL FUNCTION

	do_attach -- attach to an already existing process

SYNOPSIS

	int do_attach (int pid)

DESCRIPTION

	Attach to an already existing process with the specified process
	id.  If the process is not already stopped, query whether to
	stop it or not.

NOTES

	The option of stopping at attach time is specific to the /proc
	versions of gdb.  Versions using ptrace force the attachee
	to stop.  (I have changed this version to do so, too.  All you
	have to do is "continue" to make it go on. -- gnu@@cygnus.com)

*/

static int
do_attach (pid)
     int pid;
{
  struct procinfo *pi;
  struct sig_ctl sctl;
  struct flt_ctl fctl;
  int nlwp, *lwps;

  pi  = init_procinfo (pid, 0);

#ifdef PIOCLWPIDS
  nlwp = pi->prstatus.pr_nlwp;
  lwps = alloca ((2 * nlwp + 2) * sizeof (id_t));

  if (ioctl (pi->ctl_fd, PIOCLWPIDS, lwps))
    {
      print_sys_errmsg (pi -> pathname, errno);
      error ("PIOCLWPIDS failed");
    }
#else /* PIOCLWPIDS */
  nlwp = 1;
  lwps = alloca ((2 * nlwp + 2) * sizeof *lwps);
  lwps[0] = 0;
#endif
  for (; nlwp > 0; nlwp--, lwps++)
    {
      /* First one has already been created above.  */
      if ((pi = find_procinfo ((*lwps << 16) | pid, 1)) == 0)
	pi = init_procinfo ((*lwps << 16) | pid, 0);

      if (THE_PR_LWP(pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP))
	{
	  pi->was_stopped = 1;
	}
      else
	{
	  pi->was_stopped = 0;
	  if (1 || query ("Process is currently running, stop it? "))
	    {
	      long cmd;
	      /* Make it run again when we close it.  */
	      modify_run_on_last_close_flag (pi->ctl_fd, 1);
#ifdef PROCFS_USE_READ_WRITE
	      cmd = PCSTOP;
	      if (write (pi->ctl_fd, (char *) &cmd, sizeof (long)) < 0)
#else
	      if (ioctl (pi->ctl_fd, PIOCSTOP, &pi->prstatus) < 0)
#endif
		{
		  print_sys_errmsg (pi->pathname, errno);
		  close_proc_file (pi);
		  error ("PIOCSTOP failed");
		}
#ifdef UNIXWARE
	      if (!procfs_read_status (pi))
		{
		  print_sys_errmsg (pi->pathname, errno);
		  close_proc_file (pi);
		  error ("procfs_read_status failed");
		} 
#endif
	      pi->nopass_next_sigstop = 1;
	    }
	  else
	    {
	      printf_unfiltered ("Ok, gdb will wait for %s to stop.\n", 
				 target_pid_to_str (pi->pid));
	    }
	}

#ifdef PROCFS_USE_READ_WRITE
      fctl.cmd = PCSFAULT;
      if (write (pi->ctl_fd, (char *) &fctl, sizeof (struct flt_ctl)) < 0)
	print_sys_errmsg ("PCSFAULT failed", errno);
#else /* PROCFS_USE_READ_WRITE */
      if (ioctl (pi->ctl_fd, PIOCSFAULT, &pi->prrun.pr_fault))
	{
	  print_sys_errmsg ("PIOCSFAULT failed", errno);
	}
      if (ioctl (pi->ctl_fd, PIOCSTRACE, &pi->prrun.pr_trace))
	{
	  print_sys_errmsg ("PIOCSTRACE failed", errno);
	}
      add_thread (pi->pid);
      procfs_set_inferior_syscall_traps (pi);
#endif /* PROCFS_USE_READ_WRITE */
    }
  attach_flag = 1;
  return (pi->pid);
}
d2893 11
a2903 26

LOCAL FUNCTION

	do_detach -- detach from an attached-to process

SYNOPSIS

	void do_detach (int signal)

DESCRIPTION

	Detach from the current attachee.

	If signal is non-zero, the attachee is started running again and sent
	the specified signal.

	If signal is zero and the attachee was not already stopped when we
	attached to it, then we make it runnable again when we detach.

	Otherwise, we query whether or not to make the attachee runnable
	again, since we may simply want to leave it in the state it was in
	when we attached.

	We report any problems, but do not consider them errors, since we
	MUST detach even if some things don't seem to go right.  This may not
	be the ideal situation.  (FIXME).
d2905 3
a2907 4

static void
do_detach (signal)
     int signal;
d2909 9
a2917 497
  struct procinfo *pi;

  for (pi = procinfo_list; pi; pi = pi->next)
    {
      if (signal)
	{
	  set_proc_siginfo (pi, signal);
	}
#ifdef PROCFS_USE_READ_WRITE
      pi->saved_exitset.cmd = PCSEXIT;
      if (write (pi->ctl_fd, (char *) &pi->saved_exitset,
		 sizeof (struct sys_ctl)) < 0)
#else
	if (ioctl (pi->ctl_fd, PIOCSEXIT, &pi->saved_exitset.sysset) < 0)
#endif
	  {
	    print_sys_errmsg (pi->pathname, errno);
	    printf_unfiltered ("PIOCSEXIT failed.\n");
	  }
#ifdef PROCFS_USE_READ_WRITE
      pi->saved_entryset.cmd = PCSENTRY;
      if (write (pi->ctl_fd, (char *) &pi->saved_entryset,
		 sizeof (struct sys_ctl)) < 0)
#else
	if (ioctl (pi->ctl_fd, PIOCSENTRY, &pi->saved_entryset.sysset) < 0)
#endif
	  {
	    print_sys_errmsg (pi->pathname, errno);
	    printf_unfiltered ("PIOCSENTRY failed.\n");
	  }
#ifdef PROCFS_USE_READ_WRITE
      pi->saved_trace.cmd = PCSTRACE;
      if (write (pi->ctl_fd, (char *) &pi->saved_trace,
		 sizeof (struct sig_ctl)) < 0)
#else
	if (ioctl (pi->ctl_fd, PIOCSTRACE, &pi->saved_trace.sigset) < 0)
#endif
	  {
	    print_sys_errmsg (pi->pathname, errno);
	    printf_unfiltered ("PIOCSTRACE failed.\n");
	  }
#ifndef UNIXWARE
      if (ioctl (pi->ctl_fd, PIOCSHOLD, &pi->saved_sighold.sigset) < 0)
	{
	  print_sys_errmsg (pi->pathname, errno);
	  printf_unfiltered ("PIOSCHOLD failed.\n");
	}
#endif
#ifdef PROCFS_USE_READ_WRITE
      pi->saved_fltset.cmd = PCSFAULT;
      if (write (pi->ctl_fd, (char *) &pi->saved_fltset,
		 sizeof (struct flt_ctl)) < 0)
#else
      if (ioctl (pi->ctl_fd, PIOCSFAULT, &pi->saved_fltset.fltset) < 0)
#endif
	{
	  print_sys_errmsg (pi->pathname, errno);
	  printf_unfiltered ("PIOCSFAULT failed.\n");
	}
      if (!procfs_read_status (pi))
	{
	  print_sys_errmsg (pi->pathname, errno);
	  printf_unfiltered ("procfs_read_status failed.\n");
	}
      else
	{
	  if (signal
	  || (THE_PR_LWP(pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP)))
	    {
	      long cmd;
	      struct proc_ctl pctl;

	      if (signal || !pi->was_stopped ||
		  query ("Was stopped when attached, make it runnable again? "))
		{
		  /* Clear any pending signal if we want to detach without
		     a signal.  */
		  if (signal == 0)
		    set_proc_siginfo (pi, signal);

		  /* Clear any fault that might have stopped it.  */
#ifdef PROCFS_USE_READ_WRITE
		  cmd = PCCFAULT;
		  if (write (pi->ctl_fd, (char *) &cmd, sizeof (long)) < 0)
#else
		  if (ioctl (pi->ctl_fd, PIOCCFAULT, 0))
#endif
		    {
		      print_sys_errmsg (pi->pathname, errno);
		      printf_unfiltered ("PIOCCFAULT failed.\n");
		    }

		  /* Make it run again when we close it.  */

		  modify_run_on_last_close_flag (pi->ctl_fd, 1);
		}
	    }
	}
      close_proc_file (pi);
    }
  attach_flag = 0;
}

/*  emulate wait() as much as possible.
    Wait for child to do something.  Return pid of child, or -1 in case
    of error; store status in *OURSTATUS.

    Not sure why we can't
    just use wait(), but it seems to have problems when applied to a
    process being controlled with the /proc interface.

    We have a race problem here with no obvious solution.  We need to let
    the inferior run until it stops on an event of interest, which means
    that we need to use the PIOCWSTOP ioctl.  However, we cannot use this
    ioctl if the process is already stopped on something that is not an
    event of interest, or the call will hang indefinitely.  Thus we first
    use PIOCSTATUS to see if the process is not stopped.  If not, then we
    use PIOCWSTOP.  But during the window between the two, if the process
    stops for any reason that is not an event of interest (such as a job
    control signal) then gdb will hang.  One possible workaround is to set
    an alarm to wake up every minute of so and check to see if the process
    is still running, and if so, then reissue the PIOCWSTOP.  But this is
    a real kludge, so has not been implemented.  FIXME: investigate
    alternatives.

    FIXME:  Investigate why wait() seems to have problems with programs
    being control by /proc routines.  */
static int
procfs_wait (pid, ourstatus)
     int pid;
     struct target_waitstatus *ourstatus;
{
  short what;
  short why;
  int statval = 0;
  int checkerr = 0;
  int rtnval = -1;
  struct procinfo *pi;
  struct proc_ctl pctl;

scan_again:

  /* handle all syscall events first, otherwise we might not
     notice a thread was created until too late. */

  for (pi = procinfo_list; pi; pi = pi->next)
    {
      if (!pi->had_event)
	continue;

      if (! (THE_PR_LWP(pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP)) )
	continue;

      why = THE_PR_LWP(pi->prstatus).pr_why;
      what = THE_PR_LWP(pi->prstatus).pr_what;
      if (why == PR_SYSENTRY || why == PR_SYSEXIT)
	{
	  int i;
	  int found_handler = 0;

	  for (i = 0; i < pi->num_syscall_handlers; i++)
	    if (pi->syscall_handlers[i].syscall_num == what)
	      {
		found_handler = 1;
		pi->saved_rtnval = pi->pid;
		pi->saved_statval = 0;
		if (!pi->syscall_handlers[i].func
		    (pi, what, why, &pi->saved_rtnval, &pi->saved_statval))
		  pi->had_event = 0;
		break;
	      }

	  if (!found_handler)
	    {
	      if (why == PR_SYSENTRY)
		error ("PR_SYSENTRY, unhandled system call %d", what);
	      else
		error ("PR_SYSEXIT, unhandled system call %d", what);
	    }
	}
    }

  /* find a relevant process with an event */

  for (pi = procinfo_list; pi; pi = pi->next)
    if (pi->had_event && (pid == -1 || pi->pid == pid))
      break;

  if (!pi)
    {
      wait_fd ();
      goto scan_again;
    }

  if (!checkerr
  && !(THE_PR_LWP(pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP)))
    {
      if (!procfs_write_pcwstop (pi))
	{
	  checkerr++;
	}
    }
  if (checkerr)
    {
      if (errno == ENOENT)
	{
	  /* XXX Fixme -- what to do if attached?  Can't call wait... */
	  rtnval = wait (&statval);
	  if ((rtnval) != (PIDGET (inferior_pid)))
	    {
	      print_sys_errmsg (pi->pathname, errno);
	      error ("procfs_wait: wait failed, returned %d", rtnval);
	      /* NOTREACHED */
	    }
	}
      else
	{
	  print_sys_errmsg (pi->pathname, errno);
	  error ("PIOCSTATUS or PIOCWSTOP failed.");
	  /* NOTREACHED */
	}
    }
  else if (THE_PR_LWP(pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP))
    {
#ifdef UNIXWARE
      rtnval = pi->prstatus.pr_pid;
#else
      rtnval = pi->pid;
#endif
      why = THE_PR_LWP(pi->prstatus).pr_why;
      what = THE_PR_LWP(pi->prstatus).pr_what;

      switch (why)
	{
	case PR_SIGNALLED:
	  statval = (what << 8) | 0177;
	  break;
	case PR_SYSENTRY:
	case PR_SYSEXIT:
	  rtnval = pi->saved_rtnval;
	  statval = pi->saved_statval;
	  break;
	case PR_REQUESTED:
	  statval = (SIGSTOP << 8) | 0177;
	  break;
	case PR_JOBCONTROL:
	  statval = (what << 8) | 0177;
	  break;
	case PR_FAULTED:
	  switch (what)
	    {
#ifdef FLTWATCH
	    case FLTWATCH:
	      statval = (SIGTRAP << 8) | 0177;
	      break;
#endif
#ifdef FLTKWATCH
	    case FLTKWATCH:
	      statval = (SIGTRAP << 8) | 0177;
	      break;
#endif
#ifndef FAULTED_USE_SIGINFO
	      /* Irix, contrary to the documentation, fills in 0 for si_signo.
		 Solaris fills in si_signo.  I'm not sure about others.  */
	    case FLTPRIV:
	    case FLTILL:
	      statval = (SIGILL << 8) | 0177;
	      break;
	    case FLTBPT:
	    case FLTTRACE:
	      statval = (SIGTRAP << 8) | 0177;
	      break;
	    case FLTSTACK:
	    case FLTACCESS:
	    case FLTBOUNDS:
	      statval = (SIGSEGV << 8) | 0177;
	      break;
	    case FLTIOVF:
	    case FLTIZDIV:
	    case FLTFPE:
	      statval = (SIGFPE << 8) | 0177;
	      break;
	    case FLTPAGE:		/* Recoverable page fault */
#endif /* not FAULTED_USE_SIGINFO */
	    default:
	      /* Use the signal which the kernel assigns.  This is better than
		 trying to second-guess it from the fault.  In fact, I suspect
		 that FLTACCESS can be either SIGSEGV or SIGBUS.  */
              statval =
		 ((THE_PR_LWP(pi->prstatus).pr_info.si_signo) << 8) | 0177;
	      break;
	    }
	  break;
	default:
	  error ("PIOCWSTOP, unknown why %d, what %d", why, what);
	}
      /* Stop all the other threads when any of them stops.  */

      {
	struct procinfo *procinfo, *next_pi;

	for (procinfo = procinfo_list; procinfo; procinfo = next_pi)
	  {
	    next_pi = procinfo->next;
	    if (!procinfo->had_event)
	      {
#ifdef PROCFS_USE_READ_WRITE
		long cmd = PCSTOP;
		if (write (pi->ctl_fd, (char *) &cmd, sizeof (long)) < 0)
		  {
		    print_sys_errmsg (procinfo->pathname, errno);
		    error ("PCSTOP failed");
		  }
#else
		/* A bug in Solaris (2.5) causes us to hang when trying to
		   stop a stopped process.  So, we have to check first in
		   order to avoid the hang. */
		if (!procfs_read_status (procinfo))
		  {
		    /* The LWP has apparently terminated.  */
		    if (info_verbose)
		      printf_filtered ("LWP %d doesn't respond.\n", 
				       (procinfo->pid >> 16) & 0xffff);
		    close_proc_file (procinfo);
		    continue;
		  }

		if (!(procinfo->prstatus.pr_flags & PR_STOPPED))
		  if (ioctl (procinfo->ctl_fd, PIOCSTOP, &procinfo->prstatus)
		      < 0)
		    {
		      print_sys_errmsg (procinfo->pathname, errno);
		      warning ("PIOCSTOP failed");
		    }
#endif
	      }
	  }
      }
    }
  else
    {
      error ("PIOCWSTOP, stopped for unknown/unhandled reason, flags %#x",
	     THE_PR_LWP(pi->prstatus).pr_flags);
    }

  store_waitstatus (ourstatus, statval);

  if (rtnval == -1)		/* No more children to wait for */
    {
      warning ("Child process unexpectedly missing");
      /* Claim it exited with unknown signal.  */
      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
      ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
      return rtnval;
    }

  pi->had_event = 0;		/* Indicate that we've seen this one */
  return (rtnval);
}

/*

LOCAL FUNCTION

	set_proc_siginfo - set a process's current signal info

SYNOPSIS

	void set_proc_siginfo (struct procinfo *pip, int signo);

DESCRIPTION

	Given a pointer to a process info struct in PIP and a signal number
	in SIGNO, set the process's current signal and its associated signal
	information.  The signal will be delivered to the process immediately
	after execution is resumed, even if it is being held.  In addition,
	this particular delivery will not cause another PR_SIGNALLED stop
	even if the signal is being traced.

	If we are not delivering the same signal that the prstatus siginfo
	struct contains information about, then synthesize a siginfo struct
	to match the signal we are doing to deliver, make it of the type
	"generated by a user process", and send this synthesized copy.  When
	used to set the inferior's signal state, this will be required if we
	are not currently stopped because of a traced signal, or if we decide
	to continue with a different signal.

	Note that when continuing the inferior from a stop due to receipt
	of a traced signal, we either have set PRCSIG to clear the existing
	signal, or we have to call this function to do a PIOCSSIG with either
	the existing siginfo struct from pr_info, or one we have synthesized
	appropriately for the signal we want to deliver.  Otherwise if the
	signal is still being traced, the inferior will immediately stop
	again.

	See siginfo(5) for more details.
*/

static void
set_proc_siginfo (pip, signo)
     struct procinfo *pip;
     int signo;
{
  struct siginfo newsiginfo;
  struct siginfo *sip;
  struct sigi_ctl sictl;

#ifdef PROCFS_DONT_PIOCSSIG_CURSIG
  /* With Alpha OSF/1 procfs, the kernel gets really confused if it
     receives a PIOCSSIG with a signal identical to the current signal,
     it messes up the current signal. Work around the kernel bug.  */
  if (signo == THE_PR_LWP(pip->prstatus).pr_cursig)
    return;
#endif

#ifdef UNIXWARE
  if (signo == THE_PR_LWP(pip->prstatus).pr_info.si_signo)
    {
      memcpy ((char *) &sictl.siginfo, (char *) &pip->prstatus.pr_lwp.pr_info,
		sizeof (siginfo_t));
    }
#else
  if (signo == THE_PR_LWP(pip->prstatus).pr_info.si_signo)
    {
      sip = &pip -> prstatus.pr_info;
    }
#endif
  else
    {
#ifdef UNIXWARE
      siginfo_t *sip = &sictl.siginfo;
      memset ((char *) sip, 0, sizeof (siginfo_t));
#else
      memset ((char *) &newsiginfo, 0, sizeof (newsiginfo));
      sip = &newsiginfo;
#endif
      sip -> si_signo = signo;
      sip -> si_code = 0;
      sip -> si_errno = 0;
      sip -> si_pid = getpid ();
      sip -> si_uid = getuid ();
    }
#ifdef PROCFS_USE_READ_WRITE
  sictl.cmd = PCSSIG;
  if (write (pip->ctl_fd, (char *) &sictl, sizeof (struct sigi_ctl)) < 0)
#else
  if (ioctl (pip->ctl_fd, PIOCSSIG, sip) < 0)
#endif
    {
      print_sys_errmsg (pip -> pathname, errno);
      warning ("PIOCSSIG failed");
    }
}

/* Resume execution of process PID.  If STEP is nozero, then
   just single step it.  If SIGNAL is nonzero, restart it with that
   signal activated.  */

static void
procfs_resume (pid, step, signo)
     int pid;
     int step;
     enum target_signal signo;
{
  int signal_to_pass;
  struct procinfo *pi, *procinfo, *next_pi;
  struct proc_ctl pctl;

  pi = find_procinfo (pid == -1 ? inferior_pid : pid, 0);

  errno = 0;
#ifdef UNIXWARE
  pctl.cmd = PCRUN;
  pctl.data = PRCFAULT;
#else
  pi->prrun.pr_flags = PRSTRACE | PRSFAULT | PRCFAULT;
#endif

#if 0
  /* It should not be necessary.  If the user explicitly changes the value,
     value_assign calls write_register_bytes, which writes it.  */
/*	It may not be absolutely necessary to specify the PC value for
	restarting, but to be safe we use the value that gdb considers
	to be current.  One case where this might be necessary is if the
	user explicitly changes the PC value that gdb considers to be
	current.  FIXME:  Investigate if this is necessary or not.  */

#ifdef PRSVADDR_BROKEN
/* Can't do this under Solaris running on a Sparc, as there seems to be no
   place to put nPC.  In fact, if you use this, nPC seems to be set to some
   random garbage.  We have to rely on the fact that PC and nPC have been
   written previously via PIOCSREG during a register flush. */

  pi->prrun.pr_vaddr = (caddr_t) *(int *) &registers[REGISTER_BYTE (PC_REGNUM)];
  pi->prrun.pr_flags != PRSVADDR;
#endif
#endif
d2919 3
a2921 34
  if (signo == TARGET_SIGNAL_STOP && pi->nopass_next_sigstop)
    /* When attaching to a child process, if we forced it to stop with
       a PIOCSTOP, then we will have set the nopass_next_sigstop flag.
       Upon resuming the first time after such a stop, we explicitly
       inhibit sending it another SIGSTOP, which would be the normal
       result of default signal handling.  One potential drawback to
       this is that we will also ignore any attempt to by the user
       to explicitly continue after the attach with a SIGSTOP.  Ultimately
       this problem should be dealt with by making the routines that
       deal with the inferior a little smarter, and possibly even allow
       an inferior to continue running at the same time as gdb.  (FIXME?)  */
    signal_to_pass = 0;
  else if (signo == TARGET_SIGNAL_TSTP
	   && THE_PR_LWP(pi->prstatus).pr_cursig == SIGTSTP
	   && THE_PR_LWP(pi->prstatus).pr_action.sa_handler == SIG_DFL
	   )

    /* We are about to pass the inferior a SIGTSTP whose action is
       SIG_DFL.  The SIG_DFL action for a SIGTSTP is to stop
       (notifying the parent via wait()), and then keep going from the
       same place when the parent is ready for you to keep going.  So
       under the debugger, it should do nothing (as if the program had
       been stopped and then later resumed.  Under ptrace, this
       happens for us, but under /proc, the system obligingly stops
       the process, and wait_for_inferior would have no way of
       distinguishing that type of stop (which indicates that we
       should just start it again), with a stop due to the pr_trace
       field of the prrun_t struct.

       Note that if the SIGTSTP is being caught, we *do* need to pass it,
       because the handler needs to get executed.  */
    signal_to_pass = 0;
  else
    signal_to_pass = target_signal_to_host (signo);
d2923 2
a2924 8
  if (signal_to_pass)
    {
      set_proc_siginfo (pi, signal_to_pass);
    }
  else
    {
#ifdef UNIXWARE
      pctl.data |= PRCSIG;
d2926 1
a2926 1
      pi->prrun.pr_flags |= PRCSIG;
d2928 1
a2928 13
    }
  pi->nopass_next_sigstop = 0;
  if (step)
    {
#ifdef UNIXWARE
      pctl.data |= PRSTEP;
#else
      pi->prrun.pr_flags |= PRSTEP;
#endif
    }
  pi->had_event = 0;
  /* Don't try to start a process unless it's stopped on an
     `event of interest'.  Doing so will cause errors.  */
a2929 12
  if (!procfs_read_status (pi))
    {
      /* The LWP has apparently terminated.  */
      if (info_verbose)
	printf_filtered ("LWP %d doesn't respond.\n", 
			 (pi->pid >> 16) & 0xffff);
      close_proc_file (pi);
    }
  else
    {
#ifdef PROCFS_USE_READ_WRITE
      if (write (pi->ctl_fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
d2931 10
a2940 38
      if ((pi->prstatus.pr_flags & PR_ISTOP)
	  && ioctl (pi->ctl_fd, PIOCRUN, &pi->prrun) != 0)
#endif
	{
	  /* The LWP has apparently terminated.  */
	  if (info_verbose)
	    printf_filtered ("LWP %d doesn't respond.\n", 
			     (pi->pid >> 16) & 0xffff);
	  close_proc_file (pi);
	}
    }

  /* Continue all the other threads that haven't had an event of interest.
     Also continue them if they have NOPASS_NEXT_SIGSTOP set; this is only
     set by do_attach, and means this is the first resume after an attach.  
     All threads were CSTOP'd by do_attach, and should be resumed now.  */

  if (pid == -1)
    for (procinfo = procinfo_list; procinfo; procinfo = next_pi)
      {
	next_pi = procinfo->next;
	if (pi != procinfo)
	  if (!procinfo->had_event || 
	      (procinfo->nopass_next_sigstop && signo == TARGET_SIGNAL_STOP))
	    {
	      procinfo->had_event = procinfo->nopass_next_sigstop = 0;
#ifdef PROCFS_USE_READ_WRITE
	      pctl.data = PRCFAULT | PRCSIG;
	      if (write (procinfo->ctl_fd, (char *) &pctl,
			 sizeof (struct proc_ctl)) < 0)
		{
		  if (!procfs_read_status (procinfo))
		    fprintf_unfiltered(gdb_stderr, 
				       "procfs_read_status failed, errno=%d\n",
				       errno);
		  print_sys_errmsg (procinfo->pathname, errno);
		  error ("PCRUN failed");
		}
d2942 1
a2942 25
	      procinfo->prrun.pr_flags &= PRSTEP;
	      procinfo->prrun.pr_flags |= PRCFAULT | PRCSIG;
	      if (!procfs_read_status (procinfo))
		{
		  /* The LWP has apparently terminated.  */
		  if (info_verbose)
		    printf_filtered ("LWP %d doesn't respond.\n", 
				     (procinfo->pid >> 16) & 0xffff);
		  close_proc_file (procinfo);
		  continue;
		}

	      /* Don't try to start a process unless it's stopped on an
		 `event of interest'.  Doing so will cause errors.  */

	      if ((procinfo->prstatus.pr_flags & PR_ISTOP)
		  && ioctl (procinfo->ctl_fd, PIOCRUN, &procinfo->prrun) < 0)
		{
		  if (!procfs_read_status (procinfo))
		    fprintf_unfiltered(gdb_stderr, 
				       "procfs_read_status failed, errno=%d\n",
				       errno);
		  print_sys_errmsg (procinfo->pathname, errno);
		  warning ("PIOCRUN failed");
		}
a2943 3
	    }
	procfs_read_status (procinfo);
      }
d2946 1
d2948 5
a2952 20

LOCAL FUNCTION

	procfs_fetch_registers -- fetch current registers from inferior

SYNOPSIS

	void procfs_fetch_registers (int regno)

DESCRIPTION

	Read the current values of the inferior's registers, both the
	general register set and floating point registers (if supported)
	and update gdb's idea of their current values.

*/

static void
procfs_fetch_registers (regno)
     int regno;
d2954 2
a2955 3
  struct procinfo *pi;

  pi = current_procinfo;
a2956 6
#ifdef UNIXWARE
  if (procfs_read_status (pi))
    {
      supply_gregset (&pi->prstatus.pr_lwp.pr_context.uc_mcontext.gregs);
#if defined (FP0_REGNUM)
      supply_fpregset (&pi->prstatus.pr_lwp.pr_context.uc_mcontext.fpregs); 
a2957 11
    }
#else /* UNIXWARE */
  if (ioctl (pi->ctl_fd, PIOCGREG, &pi->gregset.gregset) != -1)
    {
      supply_gregset (&pi->gregset.gregset);
    }
#if defined (FP0_REGNUM)
  if (ioctl (pi->ctl_fd, PIOCGFPREG, &pi->fpregset.fpregset) != -1)
    {
      supply_fpregset (&pi->fpregset.fpregset);
    }
a2958 2
#endif /* UNIXWARE */
}
d2961 8
a2968 17

LOCAL FUNCTION

	proc_init_failed - called when /proc access initialization fails
fails

SYNOPSIS

	static void proc_init_failed (struct procinfo *pi, 
				      char *why, int kill_p)

DESCRIPTION

	This function is called whenever initialization of access to a /proc
	entry fails.  It prints a suitable error message, does some cleanup,
	and then invokes the standard error processing routine which dumps
	us back into the command loop.  If KILL_P is true, sends SIGKILL.
d2971 5
a2975 5
static void
proc_init_failed (pi, why, kill_p)
     struct procinfo *pi;
     char *why;
     int  kill_p;
d2977 7
a2983 6
  print_sys_errmsg (pi->pathname, errno);
  if (kill_p)
    kill (pi->pid, SIGKILL);
  close_proc_file (pi);
  error (why);
  /* NOTREACHED */
d2986 1
d2988 1
a2988 16

LOCAL FUNCTION

	close_proc_file - close any currently open /proc entry

SYNOPSIS

	static void close_proc_file (struct procinfo *pip)

DESCRIPTION

	Close any currently open /proc entry and mark the process information
	entry as invalid.  In order to ensure that we don't try to reuse any
	stale information, the pid, fd, and pathnames are explicitly
	invalidated, which may be overkill.

d2990 3
a2992 4

static void
close_proc_file (pip)
     struct procinfo *pip;
d2994 14
a3007 1
  struct procinfo *procinfo;
d3009 1
a3009 2
  delete_thread (pip->pid);	/* remove thread from GDB's thread list */
  remove_fd (pip);		/* Remove fd from poll/select list */
d3011 2
a3012 6
  close (pip->ctl_fd);
#ifdef HAVE_MULTIPLE_PROC_FDS
  close (pip->as_fd);
  close (pip->status_fd);
  close (pip->map_fd);
#endif
d3014 3
a3016 1
  free (pip -> pathname);
d3018 3
a3020 1
  /* Unlink pip from the procinfo chain.  Note pip might not be on the list. */
d3022 2
a3023 3
  if (procinfo_list == pip)
    procinfo_list = pip->next;
  else
d3025 5
a3029 9
      for (procinfo = procinfo_list; procinfo; procinfo = procinfo->next)
        {
          if (procinfo->next == pip)
	    {
	      procinfo->next = pip->next;
	      break;
	    }
        }
      free (pip);
d3031 3
d3035 2
a3036 1

d3038 1
a3038 26

LOCAL FUNCTION

	open_proc_file - open a /proc entry for a given process id

SYNOPSIS

	static int open_proc_file (int pid, struct procinfo *pip, int mode)

DESCRIPTION

	Given a process id and a mode, close the existing open /proc
	entry (if any) and open one for the new process id, in the
	specified mode.  Once it is open, then mark the local process
	information structure as valid, which guarantees that the pid,
	fd, and pathname fields match an open /proc entry.  Returns
	zero if the open fails, nonzero otherwise.

	Note that the pathname is left intact, even when the open fails,
	so that callers can use it to construct meaningful error messages
	rather than just "file open failed".

	Note that for Solaris, the process-id also includes an LWP-id, so we
	actually attempt to open that.  If we are handed a pid with a 0 LWP-id,
	then we will ask the kernel what it is and add it to the pid.  Hence,
	the pid can be changed by us.
d3040 3
a3042 7

static int
open_proc_file (pid, pip, mode, control)
     int pid;
     struct procinfo *pip;
     int mode;
     int control;
d3044 16
a3059 1
  int tmp, tmpfd;
d3061 1
a3061 4
  pip -> next = NULL;
  pip -> had_event = 0;
  pip -> pathname = xmalloc (MAX_PROC_NAME_SIZE);
  pip -> pid = pid;
d3063 27
a3089 2
#ifndef PIOCOPENLWP
  tmp = pid;
d3091 20
a3110 2
  tmp = pid & 0xffff;
#endif
d3112 1
a3112 6
#ifdef HAVE_MULTIPLE_PROC_FDS
  sprintf (pip->pathname, STATUS_PROC_NAME_FMT, tmp);
  if ((pip->status_fd = open (pip->pathname, O_RDONLY)) < 0)
    {
      return 0;
    }
d3114 3
a3116 6
  sprintf (pip->pathname, AS_PROC_NAME_FMT, tmp);
  if ((pip->as_fd = open (pip->pathname, O_RDWR)) < 0)
    {
      close (pip->status_fd);
      return 0;
    }
d3118 5
a3122 7
  sprintf (pip->pathname, MAP_PROC_NAME_FMT, tmp);
  if ((pip->map_fd = open (pip->pathname, O_RDONLY)) < 0)
    {
      close (pip->status_fd);
      close (pip->as_fd);
      return 0;
    }
d3124 1
a3124 1
  if (control)
d3126 3
a3128 8
      sprintf (pip->pathname, CTL_PROC_NAME_FMT, tmp);
      if ((pip->ctl_fd = open (pip->pathname, O_WRONLY)) < 0)
	{
	  close (pip->status_fd);
          close (pip->as_fd);
          close (pip->map_fd);
          return 0;
        }
d3130 39
d3170 8
a3177 2
#else /* HAVE_MULTIPLE_PROC_FDS */
  sprintf (pip -> pathname, CTL_PROC_NAME_FMT, tmp);
d3179 9
a3187 23
  if ((tmpfd = open (pip -> pathname, mode)) < 0)
    return 0;

#ifndef PIOCOPENLWP
    pip -> ctl_fd = tmpfd;
    pip -> as_fd = tmpfd;
    pip -> map_fd = tmpfd;
    pip -> status_fd = tmpfd;
#else
  tmp = (pid >> 16) & 0xffff;	/* Extract thread id */

  if (tmp == 0)
    {				/* Don't know thread id yet */
      if (ioctl (tmpfd, PIOCSTATUS, &pip -> prstatus) < 0)
	{
	  print_sys_errmsg (pip -> pathname, errno);
	  close (tmpfd);
	  error ("open_proc_file: PIOCSTATUS failed");
	}

      tmp = pip -> prstatus.pr_who; /* Get thread id from prstatus_t */
      pip -> pid = (tmp << 16) | pid; /* Update pip */
    }
d3189 1
a3189 1
  if ((pip -> ctl_fd = ioctl (tmpfd, PIOCOPENLWP, &tmp)) < 0)
d3191 3
a3193 2
      close (tmpfd);
      return 0;
d3196 2
a3197 7
#ifdef PIOCSET			/* New method */
  {
      long pr_flags;
      pr_flags = PR_ASYNC;
      ioctl (pip -> ctl_fd, PIOCSET, &pr_flags);
  }
#endif
d3199 1
a3199 4
  /* keep extra fds in sync */
  pip->as_fd = pip->ctl_fd;
  pip->map_fd = pip->ctl_fd;
  pip->status_fd = pip->ctl_fd;
d3201 1
a3201 2
  close (tmpfd);		/* All done with main pid */
#endif	/* PIOCOPENLWP */
d3203 1
a3203 1
#endif /* HAVE_MULTIPLE_PROC_FDS */
d3205 3
a3207 2
  return 1;
}
d3209 3
a3211 18
static char *
mappingflags (flags)
     long flags;
{
  static char asciiflags[8];
  
  strcpy (asciiflags, "-------");
#if defined (MA_PHYS)
  if (flags & MA_PHYS)   asciiflags[0] = 'd';
#endif
  if (flags & MA_STACK)  asciiflags[1] = 's';
  if (flags & MA_BREAK)  asciiflags[2] = 'b';
  if (flags & MA_SHARED) asciiflags[3] = 's';
  if (flags & MA_READ)   asciiflags[4] = 'r';
  if (flags & MA_WRITE)  asciiflags[5] = 'w';
  if (flags & MA_EXEC)   asciiflags[6] = 'x';
  return (asciiflags);
}
d3213 10
a3222 11
static void
info_proc_flags (pip, summary)
     struct procinfo *pip;
     int summary;
{
  struct trans *transp;
#ifdef UNIXWARE
  long flags = pip->prstatus.pr_flags | pip->prstatus.pr_lwp.pr_flags;
#else
  long flags = pip->prstatus.pr_flags;
#endif
d3224 3
a3226 26
  printf_filtered ("%-32s", "Process status flags:");
  if (!summary)
    {
      printf_filtered ("\n\n");
    }
  for (transp = pr_flag_table; transp -> name != NULL; transp++)
    {
      if (flags & transp -> value)
	{
	  if (summary)
	    {
	      printf_filtered ("%s ", transp -> name);
	    }
	  else
	    {
	      printf_filtered ("\t%-16s %s.\n", transp -> name, transp -> desc);
	    }
	}
    }
  printf_filtered ("\n");
}

static void
info_proc_stop (pip, summary)
     struct procinfo *pip;
     int summary;
d3228 4
a3231 3
  struct trans *transp;
  int why;
  int what;
d3233 38
a3270 86
  why = THE_PR_LWP(pip->prstatus).pr_why;
  what = THE_PR_LWP(pip->prstatus).pr_what;

  if (THE_PR_LWP(pip->prstatus).pr_flags & PR_STOPPED)
    {
      printf_filtered ("%-32s", "Reason for stopping:");
      if (!summary)
	{
	  printf_filtered ("\n\n");
	}
      for (transp = pr_why_table; transp -> name != NULL; transp++)
	{
	  if (why == transp -> value)
	    {
	      if (summary)
		{
		  printf_filtered ("%s ", transp -> name);
		}
	      else
		{
		  printf_filtered ("\t%-16s %s.\n",
				   transp -> name, transp -> desc);
		}
	      break;
	    }
	}
      
      /* Use the pr_why field to determine what the pr_what field means, and
	 print more information. */
      
      switch (why)
	{
	  case PR_REQUESTED:
	    /* pr_what is unused for this case */
	    break;
	  case PR_JOBCONTROL:
	  case PR_SIGNALLED:
	    if (summary)
	      {
		printf_filtered ("%s ", signalname (what));
	      }
	    else
	      {
		printf_filtered ("\t%-16s %s.\n", signalname (what),
				 safe_strsignal (what));
	      }
	    break;
	  case PR_SYSENTRY:
	    if (summary)
	      {
		printf_filtered ("%s ", syscallname (what));
	      }
	    else
	      {
		printf_filtered ("\t%-16s %s.\n", syscallname (what),
				 "Entered this system call");
	      }
	    break;
	  case PR_SYSEXIT:
	    if (summary)
	      {
		printf_filtered ("%s ", syscallname (what));
	      }
	    else
	      {
		printf_filtered ("\t%-16s %s.\n", syscallname (what),
				 "Returned from this system call");
	      }
	    break;
	  case PR_FAULTED:
	    if (summary)
	      {
		printf_filtered ("%s ",
				 lookupname (faults_table, what, "fault"));
	      }
	    else
	      {
		printf_filtered ("\t%-16s %s.\n",
				 lookupname (faults_table, what, "fault"),
				 lookupdesc (faults_table, what));
	      }
	    break;
	  }
      printf_filtered ("\n");
    }
}
d3272 2
a3273 102
static void
info_proc_siginfo (pip, summary)
     struct procinfo *pip;
     int summary;
{
  struct siginfo *sip;

  if ((THE_PR_LWP(pip->prstatus).pr_flags & PR_STOPPED) &&
      (THE_PR_LWP(pip->prstatus).pr_why == PR_SIGNALLED ||
       THE_PR_LWP(pip->prstatus).pr_why == PR_FAULTED))
    {
      printf_filtered ("%-32s", "Additional signal/fault info:");
      sip = &(THE_PR_LWP(pip->prstatus).pr_info);
      if (summary)
	{
	  printf_filtered ("%s ", signalname (sip -> si_signo));
	  if (sip -> si_errno > 0)
	    {
	      printf_filtered ("%s ", errnoname (sip -> si_errno));
	    }
	  if (sip -> si_code <= 0)
	    {
	      printf_filtered ("sent by %s, uid %d ",
			       target_pid_to_str (sip -> si_pid),
			       sip -> si_uid);
	    }
	  else
	    {
	      printf_filtered ("%s ", sigcodename (sip));
	      if ((sip -> si_signo == SIGILL) ||
		  (sip -> si_signo == SIGFPE) ||
		  (sip -> si_signo == SIGSEGV) ||
		  (sip -> si_signo == SIGBUS))
		{
		  printf_filtered ("addr=%#lx ",
				   (unsigned long) sip -> si_addr);
		}
	      else if ((sip -> si_signo == SIGCHLD))
		{
		  printf_filtered ("child %s, status %u ",
				   target_pid_to_str (sip -> si_pid),
				   sip -> si_status);
		}
	      else if ((sip -> si_signo == SIGPOLL))
		{
		  printf_filtered ("band %u ", sip -> si_band);
		}
	    }
	}
      else
	{
	  printf_filtered ("\n\n");
	  printf_filtered ("\t%-16s %s.\n", signalname (sip -> si_signo),
			   safe_strsignal (sip -> si_signo));
	  if (sip -> si_errno > 0)
	    {
	      printf_filtered ("\t%-16s %s.\n",
			       errnoname (sip -> si_errno),
			       safe_strerror (sip -> si_errno));
	    }
	  if (sip -> si_code <= 0)
	    {
	      printf_filtered ("\t%-16u %s\n", sip -> si_pid, /* XXX need target_pid_to_str() */
			       "PID of process sending signal");
	      printf_filtered ("\t%-16u %s\n", sip -> si_uid,
			       "UID of process sending signal");
	    }
	  else
	    {
	      printf_filtered ("\t%-16s %s.\n", sigcodename (sip),
			       sigcodedesc (sip));
	      if ((sip -> si_signo == SIGILL) ||
		  (sip -> si_signo == SIGFPE))
		{
		  printf_filtered ("\t%#-16lx %s.\n",
				   (unsigned long) sip -> si_addr,
				   "Address of faulting instruction");
		}
	      else if ((sip -> si_signo == SIGSEGV) ||
		       (sip -> si_signo == SIGBUS))
		{
		  printf_filtered ("\t%#-16lx %s.\n",
				   (unsigned long) sip -> si_addr,
				   "Address of faulting memory reference");
		}
	      else if ((sip -> si_signo == SIGCHLD))
		{
		  printf_filtered ("\t%-16u %s.\n", sip -> si_pid, /* XXX need target_pid_to_str() */
				   "Child process ID");
		  printf_filtered ("\t%-16u %s.\n", sip -> si_status,
				   "Child process exit value or signal");
		}
	      else if ((sip -> si_signo == SIGPOLL))
		{
		  printf_filtered ("\t%-16u %s.\n", sip -> si_band,
				   "Band event for POLL_{IN,OUT,MSG}");
		}
	    }
	}
      printf_filtered ("\n");
    }
}
d3275 1
a3275 6
static void
info_proc_syscalls (pip, summary)
     struct procinfo *pip;
     int summary;
{
  int syscallnum;
d3277 9
a3285 2
  if (!summary)
    {
d3287 9
a3295 15
#if 0	/* FIXME:  Needs to use gdb-wide configured info about system calls. */
      if (pip -> prstatus.pr_flags & PR_ASLEEP)
	{
	  int syscallnum = pip -> prstatus.pr_reg[R_D0];
	  if (summary)
	    {
	      printf_filtered ("%-32s", "Sleeping in system call:");
	      printf_filtered ("%s", syscallname (syscallnum));
	    }
	  else
	    {
	      printf_filtered ("Sleeping in system call '%s'.\n",
			       syscallname (syscallnum));
	    }
	}
d3298 3
a3300 12
#ifndef UNIXWARE
      if (ioctl (pip -> ctl_fd, PIOCGENTRY, &pip -> entryset) < 0)
	{
	  print_sys_errmsg (pip -> pathname, errno);
	  error ("PIOCGENTRY failed");
	}
      
      if (ioctl (pip -> ctl_fd, PIOCGEXIT, &pip -> exitset) < 0)
	{
	  print_sys_errmsg (pip -> pathname, errno);
	  error ("PIOCGEXIT failed");
	}
a3301 14
      
      printf_filtered ("System call tracing information:\n\n");
      
      printf_filtered ("\t%-12s %-8s %-8s\n",
		       "System call",
		       "Entry",
		       "Exit");
      for (syscallnum = 0; syscallnum < MAX_SYSCALLS; syscallnum++)
	{
	  QUIT;
	  if (syscall_table[syscallnum] != NULL)
	    printf_filtered ("\t%-12s ", syscall_table[syscallnum]);
	  else
	    printf_filtered ("\t%-12d ", syscallnum);
d3303 3
a3305 14
#ifdef UNIXWARE
	  printf_filtered ("%-8s ",
			   prismember (&pip->prstatus.pr_sysentry, syscallnum)
			   ? "on" : "off");
	  printf_filtered ("%-8s ",
			   prismember (&pip->prstatus.pr_sysexit, syscallnum)
			   ? "on" : "off");
#else
	  printf_filtered ("%-8s ",
			   prismember (&pip -> entryset, syscallnum)
			   ? "on" : "off");
	  printf_filtered ("%-8s ",
			   prismember (&pip -> exitset, syscallnum)
			   ? "on" : "off");
d3307 7
a3313 4
	  printf_filtered ("\n");
	}
      printf_filtered ("\n");
    }
d3316 4
a3319 3
static char *
signalname (signo)
     int signo;
d3321 2
a3322 2
  const char *name;
  static char locbuf[32];
d3324 8
a3331 2
  name = strsigno (signo);
  if (name == NULL)
d3333 9
a3341 1
      sprintf (locbuf, "Signal %d", signo);
d3343 13
a3355 1
  else
d3357 6
a3362 1
      sprintf (locbuf, "%s (%d)", name, signo);
d3364 6
a3369 1
  return (locbuf);
d3372 3
a3374 3
static char *
errnoname (errnum)
     int errnum;
d3376 2
a3377 2
  const char *name;
  static char locbuf[32];
d3379 13
a3391 2
  name = strerrno (errnum);
  if (name == NULL)
d3393 2
a3394 1
      sprintf (locbuf, "Errno %d", errnum);
d3398 30
a3427 3
      sprintf (locbuf, "%s (%d)", name, errnum);
    }
  return (locbuf);
d3431 2
a3432 3
info_proc_signals (pip, summary)
     struct procinfo *pip;
     int summary;
d3434 30
a3463 1
  int signo;
d3465 3
a3467 32
  if (!summary)
    {
#ifndef PROCFS_USE_READ_WRITE
      if (ioctl (pip -> ctl_fd, PIOCGTRACE, &pip -> trace) < 0)
	{
	  print_sys_errmsg (pip -> pathname, errno);
	  error ("PIOCGTRACE failed");
	}
#endif
      
      printf_filtered ("Disposition of signals:\n\n");
      printf_filtered ("\t%-15s %-8s %-8s %-8s  %s\n\n",
		       "Signal", "Trace", "Hold", "Pending", "Description");
      for (signo = 0; signo < NSIG; signo++)
	{
	  QUIT;
	  printf_filtered ("\t%-15s ", signalname (signo));
#ifdef UNIXWARE
	  printf_filtered ("%-8s ",
			   prismember (&pip -> prstatus.pr_sigtrace, signo)
			   ? "on" : "off");
	  printf_filtered ("%-8s ",
			   prismember (&pip -> prstatus.pr_lwp.pr_context.uc_sigmask, signo)
			   ? "on" : "off");
#else
	  printf_filtered ("%-8s ",
			   prismember (&pip -> trace, signo)
			   ? "on" : "off");
	  printf_filtered ("%-8s ",
			   prismember (&pip -> prstatus.pr_sighold, signo)
			   ? "on" : "off");
#endif
d3469 2
a3470 24
#ifdef UNIXWARE
	  if (prismember (&pip->prstatus.pr_sigpend, signo) ||
		prismember (&pip->prstatus.pr_lwp.pr_lwppend, signo))
	    printf_filtered("%-8s ", "yes");
	  else
	    printf_filtered("%-8s ", "no");
#else /* UNIXWARE */
#ifdef PROCFS_SIGPEND_OFFSET
	  /* Alpha OSF/1 numbers the pending signals from 1.  */
	  printf_filtered ("%-8s ",
			   (signo ? prismember (&pip -> prstatus.pr_sigpend,
						signo - 1)
				  : 0)
			   ? "yes" : "no");
#else
	  printf_filtered ("%-8s ",
			   prismember (&pip -> prstatus.pr_sigpend, signo)
			   ? "yes" : "no");
#endif
#endif /* UNIXWARE */
	  printf_filtered (" %s\n", safe_strsignal (signo));
	}
      printf_filtered ("\n");
    }
d3473 11
d3485 2
a3486 3
info_proc_faults (pip, summary)
     struct procinfo *pip;
     int summary;
d3488 22
a3509 1
  struct trans *transp;
d3511 10
a3520 8
  if (!summary)
    {
#ifndef UNIXWARE
      if (ioctl (pip -> ctl_fd, PIOCGFAULT, &pip->fltset.fltset) < 0)
	{
	  print_sys_errmsg (pip -> pathname, errno);
	  error ("PIOCGFAULT failed");
	}
d3522 3
a3524 3
      
      printf_filtered ("Current traced hardware fault set:\n\n");
      printf_filtered ("\t%-12s %-8s\n", "Fault", "Trace");
d3526 4
a3529 10
      for (transp = faults_table; transp -> name != NULL; transp++)
	{
	  QUIT;
	  printf_filtered ("\t%-12s ", transp -> name);
#ifdef UNIXWARE
	  printf_filtered ("%-8s", prismember (&pip->prstatus.pr_flttrace, transp -> value)
			   ? "on" : "off");
#else
	  printf_filtered ("%-8s", prismember (&pip->fltset.fltset, transp -> value)
			   ? "on" : "off");
a3530 4
	  printf_filtered ("\n");
	}
      printf_filtered ("\n");
    }
d3533 6
d3540 4
a3543 46
info_proc_mappings (pip, summary)
     struct procinfo *pip;
     int summary;
{
  int nmap;
  struct prmap *prmaps;
  struct prmap *prmap;
  struct stat sbuf;

  if (!summary)
    {
      printf_filtered ("Mapped address spaces:\n\n");
#ifdef BFD_HOST_64_BIT
      printf_filtered ("  %18s %18s %10s %10s %7s\n",
#else
      printf_filtered ("\t%10s %10s %10s %10s %7s\n",
#endif
		       "Start Addr",
		       "  End Addr",
		       "      Size",
		       "    Offset",
		       "Flags");
#ifdef PROCFS_USE_READ_WRITE
      if (fstat (pip->map_fd, &sbuf) == 0)
        {
          nmap = sbuf.st_size / sizeof (prmap_t);
	  prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));
          if ((lseek (pip->map_fd, 0, SEEK_SET) == 0) &&
		(read (pip->map_fd, (char *) prmaps,
		nmap * sizeof (*prmaps)) == (nmap * sizeof (*prmaps))))
	    {
	      int i = 0;
	      for (prmap = prmaps; i < nmap; ++prmap, ++i)
#else
      if (ioctl (pip -> ctl_fd, PIOCNMAP, &nmap) == 0)
	{
	  prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));
	  if (ioctl (pip -> ctl_fd, PIOCMAP, prmaps) == 0)
	    {
	      for (prmap = prmaps; prmap -> pr_size; ++prmap)
#endif /* PROCFS_USE_READ_WRITE */
		{
#ifdef BFD_HOST_64_BIT
		  printf_filtered ("  %#18lx %#18lx %#10x %#10x %7s\n",
#else
		  printf_filtered ("\t%#10lx %#10lx %#10x %#10x %7s\n",
a3544 11
				   (unsigned long)prmap -> pr_vaddr,
				   (unsigned long)prmap -> pr_vaddr
				     + prmap -> pr_size - 1,
				   prmap -> pr_size,
				   prmap -> pr_off,
				   mappingflags (prmap -> pr_mflags));
		}
	    }
	}
      printf_filtered ("\n");
    }
d3548 9
d3558 22
a3579 1
LOCAL FUNCTION
d3581 3
a3583 1
	info_proc -- implement the "info proc" command
d3585 2
a3586 1
SYNOPSIS
d3588 3
a3590 1
	void info_proc (char *args, int from_tty)
d3592 9
a3600 1
DESCRIPTION
d3602 2
a3603 2
	Implement gdb's "info proc" command by using the /proc interface
	to print status information about any currently running process.
d3605 5
a3609 12
	Examples of the use of "info proc" are:

	info proc		(prints summary info for current inferior)
	info proc 123		(prints summary info for process with pid 123)
	info proc mappings	(prints address mappings)
	info proc times		(prints process/children times)
	info proc id		(prints pid, ppid, gid, sid, etc)
		FIXME:  i proc id not implemented.
	info proc status	(prints general process state info)
		FIXME:  i proc status not implemented.
	info proc signals	(prints info about signal handling)
	info proc all		(prints all info)
d3611 10
d3623 4
a3626 4
static void
info_proc (args, from_tty)
     char *args;
     int from_tty;
d3628 31
a3658 31
  int pid;
  struct procinfo *pip;
  struct cleanup *old_chain;
  char **argv;
  int argsize;
  int summary = 1;
  int flags = 0;
  int syscalls = 0;
  int signals = 0;
  int faults = 0;
  int mappings = 0;
  int times = 0;
  int id = 0;
  int status = 0;
  int all = 0;
  int nlwp;
  int *lwps;

  old_chain = make_cleanup (null_cleanup, 0);

  /* Default to using the current inferior if no pid specified.  Note
     that inferior_pid may be 0, hence we set okerr.  */

  pid = inferior_pid & 0x7fffffff;		/* strip off sol-thread bit */
  if (!(pip = find_procinfo (pid, 1)))		/* inferior_pid no good?  */
    pip = procinfo_list;			/* take first available */
  pid = pid & 0xffff;				/* extract "real" pid */

  if (args != NULL)
    {
      if ((argv = buildargv (args)) == NULL)
d3660 5
a3664 3
	  nomem (0);
	}
      make_cleanup (freeargv, (char *) argv);
d3666 5
a3670 7
      while (*argv != NULL)
	{
	  argsize = strlen (*argv);
	  if (argsize >= 1 && strncmp (*argv, "all", argsize) == 0)
	    {
	      summary = 0;
	      all = 1;
d3672 1
a3672 1
	  else if (argsize >= 2 && strncmp (*argv, "faults", argsize) == 0)
d3674 2
a3675 2
	      summary = 0;
	      faults = 1;
d3677 18
a3694 1
	  else if (argsize >= 2 && strncmp (*argv, "flags", argsize) == 0)
d3696 194
a3889 37
	      summary = 0;
	      flags = 1;
	    }
	  else if (argsize >= 1 && strncmp (*argv, "id", argsize) == 0)
	    {
	      summary = 0;
	      id = 1;
	    }
	  else if (argsize >= 1 && strncmp (*argv, "mappings", argsize) == 0)
	    {
	      summary = 0;
	      mappings = 1;
	    }
	  else if (argsize >= 2 && strncmp (*argv, "signals", argsize) == 0)
	    {
	      summary = 0;
	      signals = 1;
	    }
	  else if (argsize >= 2 && strncmp (*argv, "status", argsize) == 0)
	    {
	      summary = 0;
	      status = 1;
	    }
	  else if (argsize >= 2 && strncmp (*argv, "syscalls", argsize) == 0)
	    {
	      summary = 0;
	      syscalls = 1;
	    }
	  else if (argsize >= 1 && strncmp (*argv, "times", argsize) == 0)
	    {
	      summary = 0;
	      times = 1;
	    }
	  else if ((pid = atoi (*argv)) > 0)
	    {
	      pip = (struct procinfo *) xmalloc (sizeof (struct procinfo));
	      memset (pip, 0, sizeof (*pip));
d3891 112
a4002 2
	      pip->pid = pid;
	      if (!open_proc_file (pid, pip, O_RDONLY, 0))
d4004 24
a4027 2
		  perror_with_name (pip -> pathname);
		  /* NOTREACHED */
a4028 2
	      pid = pip->pid;
	      make_cleanup (close_proc_file, pip);
d4030 1
a4030 1
	  else if (**argv != '\000')
d4032 5
a4036 1
	      error ("Unrecognized or ambiguous keyword `%s'.", *argv);
a4037 1
	  argv++;
a4038 4
    }

  /* If we don't have a valid open process at this point, then we have no
     inferior or didn't specify a specific pid. */
d4040 2
a4041 4
  if (!pip)
    {
      error ("\
No process.  Start debugging a program or specify an explicit process ID.");
d4044 2
a4045 5
  if (!procfs_read_status (pip))
    {
      print_sys_errmsg (pip -> pathname, errno);
      error ("procfs_read_status failed");
    }
d4047 10
a4056 4
#ifndef PROCFS_USE_READ_WRITE
#ifdef PIOCLWPIDS
  nlwp = pip->prstatus.pr_nlwp;
  lwps = alloca ((2 * nlwp + 2) * sizeof (*lwps));
d4058 4
a4061 1
  if (ioctl (pip->ctl_fd, PIOCLWPIDS, lwps))
d4063 2
a4064 2
      print_sys_errmsg (pip -> pathname, errno);
      error ("PIOCLWPIDS failed");
a4065 5
#else /* PIOCLWPIDS */
  nlwp = 1;
  lwps = alloca ((2 * nlwp + 2) * sizeof *lwps);
  lwps[0] = 0;
#endif /* PIOCLWPIDS */
d4067 1
a4067 1
  for (; nlwp > 0; nlwp--, lwps++)
d4069 1
a4069 29
      pip = find_procinfo ((*lwps << 16) | pid, 1);

      if (!pip)
	{
	  pip = (struct procinfo *) xmalloc (sizeof (struct procinfo));
	  memset (pip, 0, sizeof (*pip));
	  if (!open_proc_file ((*lwps << 16) | pid, pip, O_RDONLY, 0))
	    continue;

	  make_cleanup (close_proc_file, pip);

	  if (!procfs_read_status (pip))
	    {
	      print_sys_errmsg (pip -> pathname, errno);
	      error ("procfs_read_status failed");
	    }
	}

#endif /* PROCFS_USE_READ_WRITE */

      /* Print verbose information of the requested type(s), or just a summary
	 of the information for all types. */

      printf_filtered ("\nInformation for %s.%d:\n\n", pip -> pathname, *lwps);
      if (summary || all || flags)
	{
	  info_proc_flags (pip, summary);
	}
      if (summary || all)
d4071 2
a4072 3
	  info_proc_stop (pip, summary);
#ifdef UNIXWARE
	  supply_gregset (&pip->prstatus.pr_lwp.pr_context.uc_mcontext.gregs);
d4074 1
a4074 1
	  supply_gregset (&pip->prstatus.pr_reg);
d4076 1
a4076 3
	  printf_filtered ("PC: ");
	  print_address (read_pc (), gdb_stdout);
	  printf_filtered ("\n");
d4078 1
a4078 1
      if (summary || all || signals || faults)
d4080 2
a4081 1
	  info_proc_siginfo (pip, summary);
d4083 1
a4083 1
      if (summary || all || syscalls)
d4085 1
a4085 5
	  info_proc_syscalls (pip, summary);
	}
      if (summary || all || mappings)
	{
	  info_proc_mappings (pip, summary);
a4086 15
      if (summary || all || signals)
	{
	  info_proc_signals (pip, summary);
	}
      if (summary || all || faults)
	{
	  info_proc_faults (pip, summary);
	}
      printf_filtered ("\n");

      /* All done, deal with closing any temporary process info structure,
	 freeing temporary memory , etc. */

      do_cleanups (old_chain);
#ifndef PROCFS_USE_READ_WRITE
d4088 1
a4088 1
#endif
d4092 18
a4110 1
LOCAL FUNCTION
d4112 9
a4120 1
	modify_inherit_on_fork_flag - Change the inherit-on-fork flag
d4122 16
a4137 1
SYNOPSIS
d4139 5
a4143 1
	void modify_inherit_on_fork_flag (fd, flag)
d4145 10
a4154 1
DESCRIPTION
d4156 2
a4157 3
	Call this routine to modify the inherit-on-fork flag.  This routine is
	just a nice wrapper to hide the #ifdefs needed by various systems to
	control this flag.
d4159 7
d4168 12
a4179 23
static void
modify_inherit_on_fork_flag (fd, flag)
     int fd;
     int flag;
{
#if defined (PIOCSET) || defined (PCSET)
  long pr_flags;
#endif
  int retval = 0;
  struct proc_ctl pctl;

#if defined (PIOCSET) || defined (PCSET)	/* New method */
  pr_flags = PR_FORK;
  if (flag)
    {
#ifdef PROCFS_USE_READ_WRITE
      pctl.cmd = PCSET;
      pctl.data = PR_FORK;
      if (write (fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
	retval = -1;
#else
      retval = ioctl (fd, PIOCSET, &pr_flags);
#endif
a4180 9
  else
    {
#ifdef PROCFS_USE_READ_WRITE
      pctl.cmd = PCRESET;
      pctl.data = PR_FORK;
      if (write (fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
	retval = -1;
#else
      retval = ioctl (fd, PIOCRESET, &pr_flags);
d4182 2
a4183 14
    }

#else
#ifdef PIOCSFORK		/* Original method */
  if (flag)
    {
      retval = ioctl (fd, PIOCSFORK, NULL);
    }
  else
    {
      retval = ioctl (fd, PIOCRFORK, NULL);
    }
#else
  Neither PR_FORK nor PIOCSFORK exist!!!
a4184 8
#endif

  if (!retval)
    return;

  print_sys_errmsg ("modify_inherit_on_fork_flag", errno);
  error ("PIOCSFORK or PR_FORK modification failed");
}
d4187 15
d4203 8
a4210 1
LOCAL FUNCTION
d4212 15
a4226 1
	modify_run_on_last_close_flag - Change the run-on-last-close flag
d4228 2
a4229 1
SYNOPSIS
d4231 2
a4232 1
	void modify_run_on_last_close_flag (fd, flag)
d4234 6
a4239 1
DESCRIPTION
d4241 1
a4241 3
	Call this routine to modify the run-on-last-close flag.  This routine
	is just a nice wrapper to hide the #ifdefs needed by various systems to
	control this flag.
d4243 23
a4265 9
 */

static void
modify_run_on_last_close_flag (fd, flag)
     int fd;
     int flag;
{
#if defined (PIOCSET) || defined (PCSET)
  long pr_flags;
d4267 4
a4270 14
  int retval = 0;
  struct proc_ctl pctl;

#if defined (PIOCSET) || defined (PCSET)	/* New method */
  pr_flags = PR_RLC;
  if (flag)
    {
#ifdef PROCFS_USE_READ_WRITE
      pctl.cmd = PCSET;
      pctl.data = PR_RLC;
      if (write (fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
	retval = -1;
#else
      retval = ioctl (fd, PIOCSET, &pr_flags);
d4272 3
d4276 2
a4277 1
  else
d4279 4
a4282 8
#ifdef PROCFS_USE_READ_WRITE
      pctl.cmd = PCRESET;
      pctl.data = PR_RLC;
      if (write (fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
	retval = -1;
#else
      retval = ioctl (fd, PIOCRESET, &pr_flags);
#endif
a4283 17

#else
#ifdef PIOCSRLC			/* Original method */
  if (flag)
    retval = ioctl (fd, PIOCSRLC, NULL);
  else
    retval = ioctl (fd, PIOCRRLC, NULL);
#else
  Neither PR_RLC nor PIOCSRLC exist!!!
#endif
#endif

  if (!retval)
    return;

  print_sys_errmsg ("modify_run_on_last_close_flag", errno);
  error ("PIOCSRLC or PR_RLC modification failed");
d4287 8
d4296 6
a4301 1
LOCAL FUNCTION
d4303 7
a4309 1
	procfs_clear_syscall_trap -- Deletes the trap for the specified system call.
d4311 2
a4312 1
SYNOPSIS
d4314 4
a4317 6
	void procfs_clear_syscall_trap (struct procinfo *, int syscall_num, int errok)

DESCRIPTION

	This function function disables traps for the specified system call.
	errok is non-zero if errors should be ignored.
d4321 2
a4322 4
procfs_clear_syscall_trap (pi, syscall_num, errok)
     struct procinfo *pi;
     int syscall_num;
     int errok;
d4324 2
a4325 2
  sysset_t sysset;
  int goterr, i;
d4327 6
a4332 2
#ifndef UNIXWARE
  goterr = ioctl (pi->ctl_fd, PIOCGENTRY, &sysset) < 0;
d4334 5
a4338 5
  if (goterr && !errok)
    {
      print_sys_errmsg (pi->pathname, errno);
      error ("PIOCGENTRY failed");
    }
d4340 8
a4347 3
  if (!goterr)
    {
      prdelset (&sysset, syscall_num);
d4349 5
a4353 6
      if ((ioctl (pi->ctl_fd, PIOCSENTRY, &sysset) < 0) && !errok)
	{
	  print_sys_errmsg (pi->pathname, errno);
	  error ("PIOCSENTRY failed");
	}
    }
d4355 7
a4361 1
  goterr = ioctl (pi->ctl_fd, PIOCGEXIT, &sysset) < 0;
d4363 6
a4368 6
  if (goterr && !errok)
    {
      procfs_clear_syscall_trap (pi, syscall_num, 1);
      print_sys_errmsg (pi->pathname, errno);
      error ("PIOCGEXIT failed");
    }
d4370 4
a4373 12
  if (!goterr)
    {
      praddset (&sysset, syscall_num);

      if ((ioctl (pi->ctl_fd, PIOCSEXIT, &sysset) < 0) && !errok)
	{
	  procfs_clear_syscall_trap (pi, syscall_num, 1);
	  print_sys_errmsg (pi->pathname, errno);
	  error ("PIOCSEXIT failed");
	}
    }
#endif
a4374 6
  if (!pi->syscall_handlers)
    {
      if (!errok)
	error ("procfs_clear_syscall_trap:  syscall_handlers is empty");
      return;
    }
d4376 9
a4384 1
  /* Remove handler func from the handler list */
d4386 1
a4386 21
  for (i = 0; i < pi->num_syscall_handlers; i++)
    if (pi->syscall_handlers[i].syscall_num == syscall_num)
      {
	if (i + 1 != pi->num_syscall_handlers)
	  {			/* Not the last entry.
				   Move subsequent entries fwd. */
	    memcpy (&pi->syscall_handlers[i], &pi->syscall_handlers[i + 1],
		    (pi->num_syscall_handlers - i - 1)
		    * sizeof (struct procfs_syscall_handler));
	  }

	pi->syscall_handlers = xrealloc (pi->syscall_handlers,
					 (pi->num_syscall_handlers - 1)
					 * sizeof (struct procfs_syscall_handler));
	pi->num_syscall_handlers--;
	return;
      }

  if (!errok)
    error ("procfs_clear_syscall_trap:  Couldn't find handler for sys call %d",
	   syscall_num);
d4390 7
d4398 4
a4401 1
LOCAL FUNCTION
d4403 2
a4404 2
	procfs_set_syscall_trap -- arrange for a function to be called when the
				   child executes the specified system call.
d4406 7
a4412 13
SYNOPSIS

	void procfs_set_syscall_trap (struct procinfo *, int syscall_num, int flags,
				      syscall_func_t *function)

DESCRIPTION

	This function sets up an entry and/or exit trap for the specified system
	call.  When the child executes the specified system call, your function
	will be	called with the call #, a flag that indicates entry or exit, and
	pointers to rtnval and statval (which are used by procfs_wait).  The
	function should return non-zero if something interesting happened, zero
	otherwise.
d4416 2
a4417 5
procfs_set_syscall_trap (pi, syscall_num, flags, func)
     struct procinfo *pi;
     int syscall_num;
     int flags;
     syscall_func_t *func;
d4419 1
a4419 1
  sysset_t sysset;
d4421 7
a4427 2
#ifndef UNIXWARE
  if (flags & PROCFS_SYSCALL_ENTRY)
d4429 11
a4439 5
      if (ioctl (pi->ctl_fd, PIOCGENTRY, &sysset) < 0)
	{
	  print_sys_errmsg (pi->pathname, errno);
	  error ("PIOCGENTRY failed");
	}
d4441 14
a4454 8
      praddset (&sysset, syscall_num);

      if (ioctl (pi->ctl_fd, PIOCSENTRY, &sysset) < 0)
	{
	  print_sys_errmsg (pi->pathname, errno);
	  error ("PIOCSENTRY failed");
	}
    }
d4456 4
a4459 1
  if (flags & PROCFS_SYSCALL_EXIT)
d4461 2
a4462 6
      if (ioctl (pi->ctl_fd, PIOCGEXIT, &sysset) < 0)
	{
	  procfs_clear_syscall_trap (pi, syscall_num, 1);
	  print_sys_errmsg (pi->pathname, errno);
	  error ("PIOCGEXIT failed");
	}
d4464 3
a4466 9
      praddset (&sysset, syscall_num);

      if (ioctl (pi->ctl_fd, PIOCSEXIT, &sysset) < 0)
	{
	  procfs_clear_syscall_trap (pi, syscall_num, 1);
	  print_sys_errmsg (pi->pathname, errno);
	  error ("PIOCSEXIT failed");
	}
    }
a4467 24

  if (!pi->syscall_handlers)
    {
      pi->syscall_handlers = xmalloc (sizeof (struct procfs_syscall_handler));
      pi->syscall_handlers[0].syscall_num = syscall_num;
      pi->syscall_handlers[0].func = func;
      pi->num_syscall_handlers = 1;
    }
  else
    {
      int i;

      for (i = 0; i < pi->num_syscall_handlers; i++)
	if (pi->syscall_handlers[i].syscall_num == syscall_num)
	  {
	    pi->syscall_handlers[i].func = func;
	    return;
	  }

      pi->syscall_handlers = xrealloc (pi->syscall_handlers, (i + 1)
				       * sizeof (struct procfs_syscall_handler));
      pi->syscall_handlers[i].syscall_num = syscall_num;
      pi->syscall_handlers[i].func = func;
      pi->num_syscall_handlers++;
a4470 2
#ifdef SYS_lwp_create

d4472 5
d4478 7
a4484 1
LOCAL FUNCTION
d4486 5
a4490 5
	procfs_lwp_creation_handler - handle exit from the _lwp_create syscall

SYNOPSIS

	int procfs_lwp_creation_handler (pi, syscall_num, why, rtnvalp, statvalp)
d4492 5
a4496 1
DESCRIPTION
d4498 4
a4501 8
	This routine is called both when an inferior process and it's new lwp
	are about to finish a _lwp_create() system call.  This is the system
	call that Solaris uses to create a lightweight process.  When the
	target process gets this event, we can look at sysarg[2] to find the
	new childs lwp ID, and create a procinfo struct from that.  After that,
	we pretend that we got a SIGTRAP, and return non-zero to tell
	procfs_wait to wake up.  Subsequently, wait_for_inferior gets woken up,
	sees the new process and continues it.
d4503 10
a4512 2
	When we see the child exiting from lwp_create, we just contine it,
	since everything was handled when the parent trapped.
d4514 7
a4520 4
NOTES
	In effect, we are only paying attention to the parent's completion of
	the lwp_create syscall.  If we only paid attention to the child
	instead, then we wouldn't detect the creation of a suspended thread.
d4523 7
a4529 15
static int
procfs_lwp_creation_handler (pi, syscall_num, why, rtnvalp, statvalp)
     struct procinfo *pi;
     int syscall_num;
     int why;
     int *rtnvalp;
     int *statvalp;
{
  int lwp_id;
  struct procinfo *childpi;
  struct proc_ctl pctl;

  /* We've just detected the completion of an lwp_create system call.  Now we
     need to setup a procinfo struct for this thread, and notify the thread
     system of the new arrival.  */
d4531 2
a4532 2
  /* If lwp_create failed, then nothing interesting happened.  Continue the
     process and go back to sleep. */
d4534 1
a4534 6
#ifdef UNIXWARE
  /* Joel ... can you check this logic out please? JKJ */
  if (pi->prstatus.pr_lwp.pr_context.uc_mcontext.gregs[R_EFL] & 1)
    { /* _lwp_create failed */
      pctl.cmd = PCRUN;
      pctl.data = PRCFAULT;
d4536 2
a4537 2
      if (write (pi->ctl_fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
	perror_with_name (pi->pathname);
d4539 2
a4540 7
      return 0;
    }
#else /* UNIXWARE */
  if (PROCFS_GET_CARRY (pi->prstatus.pr_reg))
    {				/* _lwp_create failed */
      pi->prrun.pr_flags &= PRSTEP;
      pi->prrun.pr_flags |= PRCFAULT;
d4542 51
a4592 2
      if (ioctl (pi->ctl_fd, PIOCRUN, &pi->prrun) != 0)
	perror_with_name (pi->pathname);
d4594 7
a4600 3
      return 0;
    }
#endif
d4602 11
a4612 2
  /* At this point, the new thread is stopped at it's first instruction, and
     the parent is stopped at the exit from lwp_create.  */
d4614 6
a4619 5
  if (pi->new_child)		/* Child? */
    {				/* Yes, just continue it */
#ifdef UNIXWARE
      pctl.cmd = PCRUN;
      pctl.data = PRCFAULT;
d4621 2
a4622 9
      if (write(pi->ctl_fd, (char *)&pctl, sizeof (struct proc_ctl)) < 0)
#else /* !UNIXWARE */
      pi->prrun.pr_flags &= PRSTEP;
      pi->prrun.pr_flags |= PRCFAULT;

      if ((pi->prstatus.pr_flags & PR_ISTOP)
	  && ioctl (pi->ctl_fd, PIOCRUN, &pi->prrun) != 0)
#endif /* !UNIXWARE */
	perror_with_name (pi->pathname);
d4624 2
a4625 1
      pi->new_child = 0;	/* No longer new */
d4627 6
a4632 1
      return 0;
d4635 7
a4641 2
  /* We're the proud parent of a new thread.  Setup an exit trap for lwp_create
     in the child and continue the parent.  */
d4643 7
a4649 3
  /* Third arg is pointer to new thread id. */
  lwp_id = read_memory_integer (
     THE_PR_LWP(pi->prstatus).pr_sysarg[2], sizeof (int));
d4651 13
a4663 1
  lwp_id = (lwp_id << 16) | PIDGET (pi->pid);
d4665 9
a4673 20
  childpi = create_procinfo (lwp_id);

  /* The new process has actually inherited the lwp_create syscall trap from
     it's parent, but we still have to call this to register handlers for
     that child.  */

  procfs_set_inferior_syscall_traps (childpi);
  add_thread (lwp_id);
  printf_filtered ("[New %s]\n", target_pid_to_str (lwp_id));

  /* Continue the parent */
#ifdef UNIXWARE
  pctl.cmd = PCRUN;
  pctl.data = PRCFAULT;

  if (write(pi->ctl_fd, (char *)&pctl, sizeof (struct proc_ctl)) < 0)
#else
  pi->prrun.pr_flags &= PRSTEP;
  pi->prrun.pr_flags |= PRCFAULT;
  if (ioctl (pi->ctl_fd, PIOCRUN, &pi->prrun) != 0)
a4674 1
    perror_with_name (pi->pathname);
d4676 1
a4676 7
  /* The new child may have been created in one of two states: 
     SUSPENDED or RUNNABLE.  If runnable, we will simply signal it to run.
     If suspended, we flag it to be continued later, when it has an event.  */

  if (THE_PR_LWP(childpi->prstatus).pr_why == PR_SUSPENDED)
    childpi->new_child = 1;	/* Flag this as an unseen child process */
  else
d4678 5
a4682 9
      /* Continue the child */
#ifdef UNIXWARE
      pctl.cmd = PCRUN;
      pctl.data = PRCFAULT;

      if (write(pi->ctl_fd, (char *)&pctl, sizeof (struct proc_ctl)) < 0)
#else
      childpi->prrun.pr_flags &= PRSTEP;
      childpi->prrun.pr_flags |= PRCFAULT;
d4684 15
a4698 5
      if (ioctl (childpi->ctl_fd, PIOCRUN, &childpi->prrun) != 0)
#endif
	perror_with_name (childpi->pathname);
    }
  return 0;
a4699 1
#endif /* SYS_lwp_create */
d4701 14
a4714 1
/* Fork an inferior process, and start debugging it with /proc.  */
d4786 2
a4787 1
	error ("Can't find shell %s in PATH", shell_file);
d4792 2
a4793 2
  fork_inferior (exec_file, allargs, env,
		 proc_set_exec_trap, procfs_init_inferior, NULL, shell_file);
d4801 47
a4847 1
/* Clean up after the inferior dies.  */
d4849 3
a4851 2
static void
procfs_mourn_inferior ()
d4853 8
a4860 2
  struct procinfo *pi;
  struct procinfo *next_pi;
d4862 3
a4864 1
  for (pi = procinfo_list; pi; pi = next_pi)
d4866 2
a4867 2
      next_pi = pi->next;
      unconditionally_kill_inferior (pi);
d4869 2
a4870 3

  unpush_target (&procfs_ops);
  generic_mourn_inferior ();
d4873 6
d4880 3
a4882 3
/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
static int
procfs_can_run ()
d4884 7
a4890 3
  /* This variable is controlled by modules that sit atop procfs that may layer
     their own process structure atop that provided here.  sol-thread.c does
     this because of the Solaris two-level thread model.  */
d4892 5
a4896 1
  return !procfs_suppress_run;
d4898 14
a4911 1
#ifdef TARGET_HAS_HARDWARE_WATCHPOINTS
d4913 8
a4920 17

/* Insert a watchpoint */
int
procfs_set_watchpoint(pid, addr, len, rw)
     int		pid;
     CORE_ADDR		addr;
     int		len;
     int		rw;
{
  struct procinfo	*pi;
  prwatch_t		wpt;

  pi = find_procinfo (pid == -1 ? inferior_pid : pid, 0);
  wpt.pr_vaddr = (caddr_t)addr;
  wpt.pr_size = len;
  wpt.pr_wflags = ((rw & 1) ? MA_READ : 0) | ((rw & 2) ? MA_WRITE : 0);
  if (ioctl (pi->ctl_fd, PIOCSWATCH, &wpt) < 0)
d4922 14
a4935 1
      if (errno == E2BIG)
d4937 11
a4947 2
      /* Currently it sometimes happens that the same watchpoint gets
	 deleted twice - don't die in this case (FIXME please) */
d4949 2
a4950 3
	return 0;
      print_sys_errmsg (pi->pathname, errno);
      error ("PIOCSWATCH failed");
d4952 1
d4956 7
d4964 2
a4965 2
procfs_stopped_by_watchpoint(pid)
    int			pid;
d4967 8
a4974 13
  struct procinfo	*pi;
  short 		what;
  short 		why;

  pi = find_procinfo (pid == -1 ? inferior_pid : pid, 0);
  if (pi->prstatus.pr_flags & (PR_STOPPED | PR_ISTOP))
    {
      why = pi->prstatus.pr_why;
      what = pi->prstatus.pr_what;
      if (why == PR_FAULTED 
#if defined (FLTWATCH) && defined (FLTKWATCH)
	  && (what == FLTWATCH || what == FLTKWATCH)
#else
d4976 2
a4977 1
	  && (what == FLTWATCH) 
d4980 2
a4981 1
	  && (what == FLTKWATCH)
d4983 1
a4983 3
#endif
	  )
	return what;
a4986 2
#endif /* !UNIXWARE */
#endif /* TARGET_HAS_HARDWARE_WATCHPOINTS */
d4988 10
a4997 2
/* Why is this necessary?  Shouldn't dead threads just be removed from the
   thread database?  */
d4999 2
a5000 2
static int
procfs_thread_alive (pid)
d5003 3
a5005 1
  struct procinfo *pi, *next_pi;
d5007 9
a5015 1
  for (pi = procinfo_list; pi; pi = next_pi)
d5017 3
a5019 9
      next_pi = pi->next;
      if (pi -> pid == pid)
	if (procfs_read_status (pi))	/* alive */
	  return 1;
	else				/* defunct (exited) */
	  {
	    close_proc_file (pi);
	    return 0;
	  }
d5021 5
a5025 1
  return 0;
d5027 2
d5030 5
a5034 2
int
procfs_first_available ()
d5036 7
a5042 1
  struct procinfo *pi;
d5044 31
a5074 1
  for (pi = procinfo_list; pi; pi = pi->next)
d5076 32
a5107 2
      if (procfs_read_status (pi))
	return pi->pid;
d5109 2
a5110 1
  return -1;
d5113 28
a5140 5
int
procfs_get_pid_fd (pid)
     int pid;
{
  struct procinfo *pi = find_procinfo (pid, 1);
d5142 4
a5145 2
  if (pi == NULL)
    return -1;
d5147 11
a5157 1
  return pi->ctl_fd;
d5160 7
a5166 2
/* Send a SIGINT to the process group.  This acts just like the user typed a
   ^C on the controlling terminal.
d5168 7
a5174 2
   XXX - This may not be correct for all systems.  Some may want to use
   killpg() instead of kill (-pgrp). */
d5176 4
a5179 2
static void
procfs_stop ()
d5181 1
a5181 3
  extern pid_t inferior_process_group;

  kill (-inferior_process_group, SIGINT);
a5182 2

/* Convert a pid to printable form. */
d5184 4
a5187 4
#ifdef TIDGET
char *
procfs_pid_to_str (pid)
     int pid;
d5189 2
a5190 1
  static char buf[100];
a5191 1
  sprintf (buf, "Kernel thread %d", TIDGET (pid));
d5193 9
a5201 1
  return buf;
a5202 1
#endif /* TIDGET */
d5204 4
a5207 3

static void
init_procfs_ops ()
d5209 3
a5211 34
  procfs_ops.to_shortname = "procfs";
  procfs_ops.to_longname = "Unix /proc child process";
  procfs_ops.to_doc = "Unix /proc child process (started by the \"run\" command).";
  procfs_ops.to_open = procfs_open;
  procfs_ops.to_attach = procfs_attach;
  procfs_ops.to_detach = procfs_detach;
  procfs_ops.to_resume = procfs_resume;
  procfs_ops.to_wait = procfs_wait;
  procfs_ops.to_fetch_registers = procfs_fetch_registers;
  procfs_ops.to_store_registers = procfs_store_registers;
  procfs_ops.to_prepare_to_store = procfs_prepare_to_store;
  procfs_ops.to_xfer_memory = procfs_xfer_memory;
  procfs_ops.to_files_info = procfs_files_info;
  procfs_ops.to_insert_breakpoint = memory_insert_breakpoint;
  procfs_ops.to_remove_breakpoint = memory_remove_breakpoint;
  procfs_ops.to_terminal_init = terminal_init_inferior;
  procfs_ops.to_terminal_inferior = terminal_inferior;
  procfs_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  procfs_ops.to_terminal_ours = terminal_ours;
  procfs_ops.to_terminal_info = child_terminal_info;
  procfs_ops.to_kill = procfs_kill_inferior;
  procfs_ops.to_create_inferior = procfs_create_inferior;
  procfs_ops.to_mourn_inferior = procfs_mourn_inferior;
  procfs_ops.to_can_run = procfs_can_run;
  procfs_ops.to_notice_signals = procfs_notice_signals;
  procfs_ops.to_thread_alive = procfs_thread_alive;
  procfs_ops.to_stop = procfs_stop;
  procfs_ops.to_stratum = process_stratum;
  procfs_ops.to_has_all_memory = 1;
  procfs_ops.to_has_memory = 1;
  procfs_ops.to_has_stack = 1;
  procfs_ops.to_has_registers = 1;
  procfs_ops.to_has_execution = 1;
  procfs_ops.to_magic = OPS_MAGIC;
d5217 31
a5247 3
#ifdef HAVE_OPTIONAL_PROC_FS
  char procname[MAX_PROC_NAME_SIZE];
  int fd;
d5249 8
a5256 8
  /* If we have an optional /proc filesystem (e.g. under OSF/1),
     don't add procfs support if we cannot access the running
     GDB via /proc.  */
  sprintf (procname, STATUS_PROC_NAME_FMT, getpid ());
  if ((fd = open (procname, O_RDONLY)) < 0)
    return;
  close (fd);
#endif
d5258 5
a5262 2
  init_procfs_ops ();
  add_target (&procfs_ops);
d5264 4
a5267 7
  add_info ("processes", info_proc, 
"Show process status information using /proc entry.\n\
Specify process id or use current inferior by default.\n\
Specify keywords for detailed information; default is summary.\n\
Keywords are: `all', `faults', `flags', `id', `mappings', `signals',\n\
`status', `syscalls', and `times'.\n\
Unambiguous abbreviations may be used.");
d5269 4
a5272 1
  init_syscall_table ();
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a584 4
static void close_proc_file_cleanup PARAMS ((void*));

static struct cleanup *make_cleanup_close_proc_file PARAMS ((struct procinfo *));

a4026 14
static void
close_proc_file_cleanup (pip)
     void *pip;
{
  close_proc_file ((struct procinfo *) pip);
}

static struct cleanup *
make_cleanup_close_proc_file (pip)
     struct procinfo *pip;
{
  return make_cleanup (close_proc_file_cleanup, pip);
}

d4763 1
a4763 1
      make_cleanup_freeargv (argv);
d4825 1
a4825 1
	      make_cleanup_close_proc_file (pip);
d4877 1
a4877 1
	  make_cleanup_close_proc_file (pip);
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@d1834 1
a1834 1
	procfs_kill_inferior - kill any current inferior
d3634 1
a3634 1
	to match the signal we are going to deliver, make it of the type
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d6 1
a6 1
   This file is part of GDB.
d8 4
a11 4
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d13 4
a16 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d18 3
a20 4
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d23 1
a23 1
/*                      N  O  T  E  S
d25 2
a26 2
   For information on the details of using /proc consult section proc(4)
   in the UNIX System V Release 4 System Administrator's Reference Manual.
d28 4
a31 4
   The general register and floating point register sets are manipulated
   separately.  This file makes the assumption that if FP0_REGNUM is
   defined, then support for the floating point register set is desired,
   regardless of whether or not the actual target has floating point hardware.
d58 1
a58 1
#define SYS_lwp_create SYS_lwpcreate
d62 1
a62 1
#define SYS_lwp_exit SYS_lwpexit
d66 1
a66 1
#define SYS_lwp_wait SYS_lwpwait
d70 1
a70 1
#define SYS_lwp_self SYS_lwpself
d74 1
a74 1
#define SYS_lwp_info SYS_lwpinfo
d78 1
a78 1
#define SYS_lwp_private SYS_lwpprivate
d82 1
a82 1
#define SYS_lwp_kill SYS_lwpkill
d86 1
a86 1
#define SYS_lwp_suspend SYS_lwpsuspend
d90 1
a90 1
#define SYS_lwp_continue SYS_lwpcontinue
d96 1
a96 1
typedef prstatus_t gdb_prstatus_t;
d98 2
a99 2
#else /* HAVE_PSTATUS_T */
typedef pstatus_t gdb_prstatus_t;
d109 2
a110 2
#endif /* !HAVE_PRRUN_T && HAVE_MULTIPLE_PROC_FDS */
#endif /* HAVE_PSTATUS_T */
d116 6
a121 6
#ifndef CTL_PROC_NAME_FMT
#define CTL_PROC_NAME_FMT "/proc/%d/ctl"
#define AS_PROC_NAME_FMT "/proc/%d/as"
#define MAP_PROC_NAME_FMT "/proc/%d/map"
#define STATUS_PROC_NAME_FMT "/proc/%d/status"
#endif
d123 6
a128 6
#ifndef CTL_PROC_NAME_FMT
#define CTL_PROC_NAME_FMT "/proc/%05d"
#define AS_PROC_NAME_FMT "/proc/%05d"
#define MAP_PROC_NAME_FMT "/proc/%05d"
#define STATUS_PROC_NAME_FMT "/proc/%05d"
#endif
d138 1
a138 1
typedef GDB_GREGSET_TYPE gdb_gregset_t;
d140 1
a140 1
typedef gregset_t gdb_gregset_t;
d144 1
a144 1
typedef GDB_FPREGSET_TYPE gdb_fpregset_t;
d146 1
a146 1
typedef fpregset_t gdb_fpregset_t;
d159 1
a159 1
#if 1				/* FIXME: Gross and ugly hack to resolve coredep.c global */
d173 1
a173 1
 */
d175 4
a178 5
struct proc_ctl
  {
    int cmd;
    long data;
  };
d181 4
a184 5
struct greg_ctl
  {
    int cmd;
    gdb_gregset_t gregset;
  };
d187 4
a190 5
struct fpreg_ctl
  {
    int cmd;
    gdb_fpregset_t fpregset;
  };
d193 4
a196 5
struct sig_ctl
  {
    int cmd;
    sigset_t sigset;
  };
d199 4
a202 5
struct flt_ctl
  {
    int cmd;
    fltset_t fltset;
  };
d205 4
a208 5
struct sys_ctl
  {
    int cmd;
    sysset_t sysset;
  };
d211 4
a214 5
struct sigi_ctl
  {
    int cmd;
    siginfo_t siginfo;
  };
d217 19
a235 20
   been attached to, is controlled by an instance of a procinfo structure,
   defined below.  Since gdb currently only handles one inferior at a time,
   the procinfo structure for the inferior is statically allocated and
   only one exists at any given time.  There is a separate procinfo
   structure for use by the "info proc" command, so that we can print
   useful information about any random process without interfering with
   the inferior's procinfo information. */

struct procinfo
  {
    struct procinfo *next;
    int pid;			/* Process ID of inferior */
    int ctl_fd;			/* File descriptor for /proc ctl file */
    int status_fd;		/* File descriptor for /proc status file */
    int as_fd;			/* File descriptor for /proc as file */
    int map_fd;			/* File descriptor for /proc map file */
    char *pathname;		/* Pathname to /proc entry */
    int had_event;		/* poll/select says something happened */
    int was_stopped;		/* Nonzero if was stopped prior to attach */
    int nopass_next_sigstop;	/* Don't pass a sigstop on next resume */
d237 1
a237 1
    prrun_t prrun;		/* Control state when it is run */
d239 13
a251 13
    gdb_prstatus_t prstatus;	/* Current process status info */
    struct greg_ctl gregset;	/* General register set */
    struct fpreg_ctl fpregset;	/* Floating point register set */
    struct flt_ctl fltset;	/* Current traced hardware fault set */
    struct sig_ctl trace;	/* Current traced signal set */
    struct sys_ctl exitset;	/* Current traced system call exit set */
    struct sys_ctl entryset;	/* Current traced system call entry set */
    struct sig_ctl saved_sighold;	/* Saved held signal set */
    struct flt_ctl saved_fltset;	/* Saved traced hardware fault set */
    struct sig_ctl saved_trace;	/* Saved traced signal set */
    struct sys_ctl saved_exitset;	/* Saved traced system call exit set */
    struct sys_ctl saved_entryset;	/* Saved traced system call entry set */
    int num_syscall_handlers;	/* Number of syscall trap handlers
d253 6
a258 6
    /* Pointer to list of syscall trap handlers */
    struct procfs_syscall_handler *syscall_handlers;
    int saved_rtnval;		/* return value and status for wait(), */
    int saved_statval;		/*  as supplied by a syscall handler. */
    int new_child;		/* Non-zero if it's a new thread */
  };
d262 1
a262 1
static struct pollfd *poll_list;	/* pollfds used for waiting on /proc */
d267 9
a275 10
   printing status information, is kept as tables of structures of the
   following form.  These tables can be used to map numeric values to
   their symbolic names and to a string that describes their specific use. */

struct trans
  {
    int value;			/* The numeric value */
    char *name;			/* The equivalent symbolic value */
    char *desc;			/* Short description of value */
  };
d278 1
a278 1
   names and desc information. */
d283 1
a283 1
  {PR_STOPPED, "PR_STOPPED", "Process is stopped"},
d286 1
a286 1
  {PR_ISTOP, "PR_ISTOP", "Stopped on an event of interest"},
d289 1
a289 1
  {PR_DSTOP, "PR_DSTOP", "A stop directive is in effect"},
d292 1
a292 1
  {PR_ASLEEP, "PR_ASLEEP", "Sleeping in an interruptible system call"},
d295 1
a295 1
  {PR_FORK, "PR_FORK", "Inherit-on-fork is in effect"},
d298 1
a298 1
  {PR_RLC, "PR_RLC", "Run-on-last-close is in effect"},
d301 1
a301 1
  {PR_PTRACE, "PR_PTRACE", "Process is being controlled by ptrace"},
d304 1
a304 1
  {PR_PCINVAL, "PR_PCINVAL", "PC refers to an invalid virtual address"},
d307 1
a307 1
  {PR_ISSYS, "PR_ISSYS", "Is a system process"},
d310 1
a310 1
  {PR_STEP, "PR_STEP", "Process has single step pending"},
d313 1
a313 1
  {PR_KLC, "PR_KLC", "Kill-on-last-close is in effect"},
d316 1
a316 1
  {PR_ASYNC, "PR_ASYNC", "Asynchronous stop is in effect"},
d319 1
a319 1
  {PR_PCOMPAT, "PR_PCOMPAT", "Ptrace compatibility mode in effect"},
d322 1
a322 1
  {PR_MSACCT, "PR_MSACCT", "Microstate accounting enabled"},
d325 1
a325 1
  {PR_BPTADJ, "PR_BPTADJ", "Breakpoint PC adjustment in effect"},
d328 1
a328 1
  {PR_ASLWP, "PR_ASLWP", "Asynchronus signal LWP"},
d330 1
a330 1
  {0, NULL, NULL}
d338 1
a338 1
  {PR_REQUESTED, "PR_REQUESTED", "Directed to stop via PIOCSTOP/PIOCWSTOP"},
d341 1
a341 1
  {PR_SIGNALLED, "PR_SIGNALLED", "Receipt of a traced signal"},
d344 1
a344 1
  {PR_SYSENTRY, "PR_SYSENTRY", "Entry to a traced system call"},
d347 1
a347 1
  {PR_SYSEXIT, "PR_SYSEXIT", "Exit from a traced system call"},
d350 1
a350 1
  {PR_JOBCONTROL, "PR_JOBCONTROL", "Default job control stop signal action"},
d353 1
a353 1
  {PR_FAULTED, "PR_FAULTED", "Incurred a traced hardware fault"},
d356 1
a356 1
  {PR_SUSPENDED, "PR_SUSPENDED", "Process suspended"},
d359 1
a359 1
  {PR_CHECKPOINT, "PR_CHECKPOINT", "(???)"},
d361 1
a361 1
  {0, NULL, NULL}
d369 1
a369 1
  {FLTILL, "FLTILL", "Illegal instruction"},
d372 1
a372 1
  {FLTPRIV, "FLTPRIV", "Privileged instruction"},
d375 1
a375 1
  {FLTBPT, "FLTBPT", "Breakpoint trap"},
d378 1
a378 1
  {FLTTRACE, "FLTTRACE", "Trace trap"},
d381 1
a381 1
  {FLTACCESS, "FLTACCESS", "Memory access fault"},
d384 1
a384 1
  {FLTBOUNDS, "FLTBOUNDS", "Memory bounds violation"},
d387 1
a387 1
  {FLTIOVF, "FLTIOVF", "Integer overflow"},
d390 1
a390 1
  {FLTIZDIV, "FLTIZDIV", "Integer zero divide"},
d393 1
a393 1
  {FLTFPE, "FLTFPE", "Floating-point exception"},
d396 1
a396 1
  {FLTSTACK, "FLTSTACK", "Unrecoverable stack fault"},
d399 1
a399 1
  {FLTPAGE, "FLTPAGE", "Recoverable page fault"},
d401 1
a401 1
  {0, NULL, NULL}
d407 6
a412 9
static struct sigcode
  {
    int signo;
    int code;
    char *codename;
    char *desc;
  }
siginfo_table[] =
{
d414 1
a414 4
  {
    SIGILL, ILL_ILLOPC, "ILL_ILLOPC", "Illegal opcode"
  }
  ,
d417 1
a417 4
  {
    SIGILL, ILL_ILLOPN, "ILL_ILLOPN", "Illegal operand",
  }
  ,
d420 1
a420 4
  {
    SIGILL, ILL_ILLADR, "ILL_ILLADR", "Illegal addressing mode"
  }
  ,
d423 1
a423 4
  {
    SIGILL, ILL_ILLTRP, "ILL_ILLTRP", "Illegal trap"
  }
  ,
d426 1
a426 4
  {
    SIGILL, ILL_PRVOPC, "ILL_PRVOPC", "Privileged opcode"
  }
  ,
d429 1
a429 4
  {
    SIGILL, ILL_PRVREG, "ILL_PRVREG", "Privileged register"
  }
  ,
d432 1
a432 4
  {
    SIGILL, ILL_COPROC, "ILL_COPROC", "Coprocessor error"
  }
  ,
d435 1
a435 4
  {
    SIGILL, ILL_BADSTK, "ILL_BADSTK", "Internal stack error"
  }
  ,
d438 1
a438 4
  {
    SIGFPE, FPE_INTDIV, "FPE_INTDIV", "Integer divide by zero"
  }
  ,
d441 1
a441 4
  {
    SIGFPE, FPE_INTOVF, "FPE_INTOVF", "Integer overflow"
  }
  ,
d444 1
a444 4
  {
    SIGFPE, FPE_FLTDIV, "FPE_FLTDIV", "Floating point divide by zero"
  }
  ,
d447 1
a447 4
  {
    SIGFPE, FPE_FLTOVF, "FPE_FLTOVF", "Floating point overflow"
  }
  ,
d450 1
a450 4
  {
    SIGFPE, FPE_FLTUND, "FPE_FLTUND", "Floating point underflow"
  }
  ,
d453 1
a453 4
  {
    SIGFPE, FPE_FLTRES, "FPE_FLTRES", "Floating point inexact result"
  }
  ,
d456 1
a456 4
  {
    SIGFPE, FPE_FLTINV, "FPE_FLTINV", "Invalid floating point operation"
  }
  ,
d459 1
a459 4
  {
    SIGFPE, FPE_FLTSUB, "FPE_FLTSUB", "Subscript out of range"
  }
  ,
d462 1
a462 4
  {
    SIGSEGV, SEGV_MAPERR, "SEGV_MAPERR", "Address not mapped to object"
  }
  ,
d465 1
a465 4
  {
    SIGSEGV, SEGV_ACCERR, "SEGV_ACCERR", "Invalid permissions for object"
  }
  ,
d468 1
a468 4
  {
    SIGBUS, BUS_ADRALN, "BUS_ADRALN", "Invalid address alignment"
  }
  ,
d471 1
a471 4
  {
    SIGBUS, BUS_ADRERR, "BUS_ADRERR", "Non-existent physical address"
  }
  ,
d474 1
a474 4
  {
    SIGBUS, BUS_OBJERR, "BUS_OBJERR", "Object specific hardware error"
  }
  ,
d477 1
a477 4
  {
    SIGTRAP, TRAP_BRKPT, "TRAP_BRKPT", "Process breakpoint"
  }
  ,
d480 1
a480 4
  {
    SIGTRAP, TRAP_TRACE, "TRAP_TRACE", "Process trace trap"
  }
  ,
d483 1
a483 4
  {
    SIGCLD, CLD_EXITED, "CLD_EXITED", "Child has exited"
  }
  ,
d486 1
a486 4
  {
    SIGCLD, CLD_KILLED, "CLD_KILLED", "Child was killed"
  }
  ,
d489 1
a489 4
  {
    SIGCLD, CLD_DUMPED, "CLD_DUMPED", "Child has terminated abnormally"
  }
  ,
d492 1
a492 4
  {
    SIGCLD, CLD_TRAPPED, "CLD_TRAPPED", "Traced child has trapped"
  }
  ,
d495 1
a495 4
  {
    SIGCLD, CLD_STOPPED, "CLD_STOPPED", "Child has stopped"
  }
  ,
d498 1
a498 4
  {
    SIGCLD, CLD_CONTINUED, "CLD_CONTINUED", "Stopped child had continued"
  }
  ,
d501 1
a501 4
  {
    SIGPOLL, POLL_IN, "POLL_IN", "Input input available"
  }
  ,
d504 1
a504 4
  {
    SIGPOLL, POLL_OUT, "POLL_OUT", "Output buffers available"
  }
  ,
d507 1
a507 4
  {
    SIGPOLL, POLL_MSG, "POLL_MSG", "Input message available"
  }
  ,
d510 1
a510 4
  {
    SIGPOLL, POLL_ERR, "POLL_ERR", "I/O error"
  }
  ,
d513 1
a513 4
  {
    SIGPOLL, POLL_PRI, "POLL_PRI", "High priority input available"
  }
  ,
d516 1
a516 4
  {
    SIGPOLL, POLL_HUP, "POLL_HUP", "Device disconnected"
  }
  ,
d518 1
a518 3
  {
    0, 0, NULL, NULL
  }
d549 1
a549 1
static void procfs_init_inferior PARAMS ((int));
d585 1
a585 1
static void close_proc_file_cleanup PARAMS ((void *));
d591 1
a591 2
static NORETURN void proc_init_failed
PARAMS ((struct procinfo *, char *, int)) ATTR_NORETURN;
d593 1
a593 1
     static void info_proc PARAMS ((char *, int));
d595 1
a595 1
     static void info_proc_flags PARAMS ((struct procinfo *, int));
d597 1
a597 1
     static void info_proc_stop PARAMS ((struct procinfo *, int));
d599 1
a599 1
     static void info_proc_siginfo PARAMS ((struct procinfo *, int));
d601 1
a601 1
     static void info_proc_syscalls PARAMS ((struct procinfo *, int));
d603 1
a603 1
     static void info_proc_mappings PARAMS ((struct procinfo *, int));
d605 1
a605 1
     static void info_proc_signals PARAMS ((struct procinfo *, int));
d607 1
a607 1
     static void info_proc_faults PARAMS ((struct procinfo *, int));
d609 1
a609 1
     static char *mappingflags PARAMS ((long));
d611 1
a611 1
     static char *lookupname PARAMS ((struct trans *, unsigned int, char *));
d613 1
a613 1
     static char *lookupdesc PARAMS ((struct trans *, unsigned int));
d615 1
a615 1
     static int do_attach PARAMS ((int pid));
d617 1
a617 1
     static void do_detach PARAMS ((int siggnal));
d619 1
a619 1
     static void procfs_create_inferior PARAMS ((char *, char *, char **));
d621 1
a621 1
     static void procfs_notice_signals PARAMS ((int pid));
d623 1
a623 1
     static void notice_signals PARAMS ((struct procinfo *, struct sig_ctl *));
d625 1
a625 1
     static struct procinfo *find_procinfo PARAMS ((pid_t pid, int okfail));
d627 3
a629 3
     static int procfs_write_pcwstop PARAMS ((struct procinfo *));
     static int procfs_read_status PARAMS ((struct procinfo *));
     static void procfs_write_pckill PARAMS ((struct procinfo *));
d631 2
a632 2
     typedef int syscall_func_t PARAMS ((struct procinfo * pi, int syscall_num,
				       int why, int *rtnval, int *statval));
d634 3
a636 3
     static void procfs_set_syscall_trap PARAMS ((struct procinfo * pi,
						  int syscall_num, int flags,
						  syscall_func_t * func));
d638 1
a638 1
     static void procfs_clear_syscall_trap PARAMS ((struct procinfo * pi,
d641 1
a641 1
#define PROCFS_SYSCALL_ENTRY 0x1	/* Trap on entry to sys call */
d644 1
a644 1
     static syscall_func_t procfs_exit_handler;
d646 1
a646 1
     static syscall_func_t procfs_exec_handler;
d649 2
a650 2
     static syscall_func_t procfs_sproc_handler;
     static syscall_func_t procfs_fork_handler;
d654 1
a654 1
     static syscall_func_t procfs_lwp_creation_handler;
d657 2
a658 2
     static void modify_inherit_on_fork_flag PARAMS ((int fd, int flag));
     static void modify_run_on_last_close_flag PARAMS ((int fd, int flag));
d662 6
a667 6
     struct procfs_syscall_handler
       {
	 int syscall_num;	/* The number of the system call being handled */
	 /* The function to be called */
	 syscall_func_t *func;
       };
d669 2
a670 2
     static void procfs_resume PARAMS ((int pid, int step,
					enum target_signal signo));
d672 1
a672 1
     static void init_procfs_ops PARAMS ((void));
d677 1
a677 1
     extern void supply_gregset PARAMS ((gdb_gregset_t *));
d679 1
a679 1
     extern void fill_gregset PARAMS ((gdb_gregset_t *, int));
d682 1
a682 1
     extern void supply_fpregset PARAMS ((gdb_fpregset_t *));
d684 1
a684 1
     extern void fill_fpregset PARAMS ((gdb_fpregset_t *, int));
d689 1
a689 1
   LOCAL FUNCTION
d691 1
a691 1
   find_procinfo -- convert a process id to a struct procinfo
d693 1
a693 1
   SYNOPSIS
d695 1
a695 1
   static struct procinfo * find_procinfo (pid_t pid, int okfail);
d697 5
a701 5
   DESCRIPTION

   Given a process id, look it up in the procinfo chain.  Returns
   a struct procinfo *.  If can't find pid, then call error(),
   unless okfail is set, in which case, return NULL;
d704 2
a705 2
     static struct procinfo *
       find_procinfo (pid, okfail)
d723 1
a723 1
   LOCAL MACRO
d725 1
a725 1
   current_procinfo -- convert inferior_pid to a struct procinfo
d727 1
a727 1
   SYNOPSIS
d729 1
a729 1
   static struct procinfo * current_procinfo;
d731 4
a734 4
   DESCRIPTION

   Looks up inferior_pid in the procinfo chain.  Always returns a
   struct procinfo *.  If process can't be found, we error() out.
d741 1
a741 3
   LOCAL FUNCTION

   add_fd -- Add the fd to the poll/select list
d743 1
a743 1
   SYNOPSIS
d745 1
a745 1
   static void add_fd (struct procinfo *);
d747 1
a747 1
   DESCRIPTION
d749 4
a752 2
   Add the fd of the supplied procinfo to the list of fds used for
   poll/select operations.
d777 1
a777 1
   LOCAL FUNCTION
d779 1
a779 1
   remove_fd -- Remove the fd from the poll/select list
d781 1
a781 1
   SYNOPSIS
d783 1
a783 1
   static void remove_fd (struct procinfo *);
d785 4
a788 4
   DESCRIPTION

   Remove the fd of the supplied procinfo from the list of fds used 
   for poll/select operations.
d812 1
a812 1
						  * sizeof (struct pollfd));
d820 1
a820 3
   LOCAL FUNCTION

   procfs_read_status - get procfs fd status
d822 1
a822 1
   SYNOPSIS
d824 1
a824 1
   static int procfs_read_status (pi) struct procinfo *pi;
d826 1
a826 1
   DESCRIPTION
d828 5
a832 3
   Given a pointer to a procinfo struct, get the status of
   the status_fd in the appropriate way.  Returns 0 on failure,
   1 on success.
d837 1
a837 1
     struct procinfo *pi;
d840 3
a842 3
  if ((lseek (pi->status_fd, 0, SEEK_SET) < 0) ||
      (read (pi->status_fd, (char *) &pi->prstatus,
	     sizeof (gdb_prstatus_t)) != sizeof (gdb_prstatus_t)))
d853 1
a853 1
   LOCAL FUNCTION
d855 1
a855 1
   procfs_write_pcwstop - send a PCWSTOP to procfs fd
d857 1
a857 1
   SYNOPSIS
d859 1
a859 1
   static int procfs_write_pcwstop (pi) struct procinfo *pi;
d861 5
a865 5
   DESCRIPTION

   Given a pointer to a procinfo struct, send a PCWSTOP to
   the ctl_fd in the appropriate way.  Returns 0 on failure,
   1 on success.
d870 1
a870 1
     struct procinfo *pi;
d885 1
a885 3
   LOCAL FUNCTION

   procfs_write_pckill - send a kill to procfs fd
d887 1
a887 1
   SYNOPSIS
d889 1
a889 1
   static void procfs_write_pckill (pi) struct procinfo *pi;
d891 1
a891 1
   DESCRIPTION
d893 5
a897 3
   Given a pointer to a procinfo struct, send a kill to
   the ctl_fd in the appropriate way.  Returns 0 on failure,
   1 on success.
d902 1
a902 1
     struct procinfo *pi;
d924 2
a925 2
  set_sigint_trap ();		/* Causes SIGINT to be passed on to the
				   attached process. */
d928 1
a928 1
wait_again:
d959 1
a959 1

d967 1
a967 1
      if (0 == (poll_list[i].revents &
d976 3
a978 3
	      if ((poll_list[i].revents & POLLHUP) != 0 ||
		  !procfs_read_status (pi))
		{		/* The LWP has apparently terminated.  */
d986 1
a986 1
		    printf_filtered ("LWP %d exited.\n",
d989 1
a989 1
		  i--;		/* don't skip deleted entry */
d991 1
a991 1
		    break;	/* already another event to process */
d993 1
a993 1
		    goto wait_again;	/* wait for another event */
d1010 1
a1010 3
   LOCAL FUNCTION

   lookupdesc -- translate a value to a summary desc string
d1012 1
a1012 1
   SYNOPSIS
d1014 1
a1014 1
   static char *lookupdesc (struct trans *transp, unsigned int val);
d1016 1
a1016 1
   DESCRIPTION
d1018 4
a1021 2
   Given a pointer to a translation table and a value to be translated,
   lookup the desc string and return it.
d1030 2
a1031 2

  for (desc = NULL; transp->name != NULL; transp++)
d1033 1
a1033 1
      if (transp->value == val)
d1035 1
a1035 1
	  desc = transp->desc;
d1051 1
a1051 3
   LOCAL FUNCTION

   lookupname -- translate a value to symbolic name
d1053 1
a1053 1
   SYNOPSIS
d1055 1
a1055 2
   static char *lookupname (struct trans *transp, unsigned int val,
   char *prefix);
d1057 2
a1058 1
   DESCRIPTION
d1060 6
a1065 4
   Given a pointer to a translation table, a value to be translated,
   and a default prefix to return if the value can't be translated,
   match the value with one of the translation table entries and
   return a pointer to the symbolic name.
d1067 3
a1069 3
   If no match is found it just returns the value as a printable string,
   with the given prefix.  The previous such value, if any, is freed
   at this time.
d1080 2
a1081 2

  for (name = NULL; transp->name != NULL; transp++)
d1083 1
a1083 1
      if (transp->value == val)
d1085 1
a1085 1
	  name = transp->name;
d1114 2
a1115 2

  for (scp = siginfo_table; scp->codename != NULL; scp++)
d1117 2
a1118 2
      if ((scp->signo == sip->si_signo) &&
	  (scp->code == sip->si_code))
d1120 1
a1120 1
	  name = scp->codename;
d1126 1
a1126 1
      sprintf (locbuf, "sigcode %u", sip->si_signo);
d1138 2
a1139 2

  for (scp = siginfo_table; scp->codename != NULL; scp++)
d1141 2
a1142 2
      if ((scp->signo == sip->si_signo) &&
	  (scp->code == sip->si_code))
d1144 1
a1144 1
	  desc = scp->desc;
d1157 1
a1157 1
   LOCAL FUNCTION
d1159 1
a1159 1
   syscallname - translate a system call number into a system call name
d1161 1
a1161 1
   SYNOPSIS
d1163 1
a1163 1
   char *syscallname (int syscallnum)
d1165 1
a1165 1
   DESCRIPTION
d1167 3
a1169 3
   Given a system call number, translate it into the printable name
   of a system call, or into "syscall <num>" if it is an unknown
   number.
d1177 1
a1177 1

d1190 1
a1190 1
   LOCAL FUNCTION
d1192 1
a1192 1
   init_syscall_table - initialize syscall translation table
d1194 1
a1194 1
   SYNOPSIS
d1196 1
a1196 1
   void init_syscall_table (void)
d1198 1
a1198 1
   DESCRIPTION
d1200 3
a1202 3
   Dynamically initialize the translation table to convert system
   call numbers into printable system call names.  Done once per
   gdb run, on initialization.
d1204 1
a1204 1
   NOTES
d1206 2
a1207 2
   This is awfully ugly, but preprocessor tricks to make it prettier
   tend to be nonportable.
d1832 1
a1832 1
   LOCAL FUNCTION
d1834 1
a1834 1
   procfs_kill_inferior - kill any current inferior
d1836 1
a1836 1
   SYNOPSIS
d1838 1
a1838 1
   void procfs_kill_inferior (void)
d1840 1
a1840 1
   DESCRIPTION
d1842 1
a1842 1
   Kill any current inferior.
d1844 1
a1844 1
   NOTES
d1846 3
a1848 3
   Kills even attached inferiors.  Presumably the user has already
   been prompted that the inferior is an attached one rather than
   one started by gdb.  (FIXME?)
d1850 1
a1850 1
 */
d1860 1
a1860 1
   LOCAL FUNCTION
d1862 1
a1862 1
   unconditionally_kill_inferior - terminate the inferior
d1864 1
a1864 1
   SYNOPSIS
d1866 1
a1866 1
   static void unconditionally_kill_inferior (struct procinfo *)
d1868 1
a1868 1
   DESCRIPTION
d1870 1
a1870 1
   Kill the specified inferior.
d1872 1
a1872 1
   NOTE
d1874 4
a1877 4
   A possibly useful enhancement would be to first try sending
   the inferior a terminate signal, politely asking it to commit
   suicide, before we murder it (we could call that
   politely_kill_inferior()).
d1879 1
a1879 1
 */
d1887 1
a1887 1

d1922 1
a1922 1
  if (ppid == getpid ())
d1928 1
a1928 1
   LOCAL FUNCTION
d1930 1
a1930 1
   procfs_xfer_memory -- copy data to or from inferior memory space
d1932 1
a1932 1
   SYNOPSIS
d1934 2
a1935 2
   int procfs_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
   int dowrite, struct target_ops target)
d1937 1
a1937 1
   DESCRIPTION
d1939 8
a1946 3
   Copy LEN bytes to/from inferior's memory starting at MEMADDR
   from/to debugger memory starting at MYADDR.  Copy from inferior
   if DOWRITE is zero or to inferior if DOWRITE is nonzero.
d1948 1
a1948 4
   Returns the length copied, which is either the LEN argument or
   zero.  This xfer function does not do partial moves, since procfs_ops
   doesn't allow memory operations to cross below us in the target stack
   anyway.
d1950 1
a1950 3
   NOTES

   The /proc interface makes this an almost trivial task.
d1959 1
a1959 1
     struct target_ops *target;	/* ignored */
d1966 1
a1966 1
  if (lseek (pi->as_fd, (off_t) memaddr, SEEK_SET) == (off_t) memaddr)
d1986 1
a1986 1
   LOCAL FUNCTION
d1988 1
a1988 1
   procfs_store_registers -- copy register values back to inferior
d1990 1
a1990 1
   SYNOPSIS
d1992 1
a1992 1
   void procfs_store_registers (int regno)
d1994 1
a1994 1
   DESCRIPTION
d1996 3
a1998 3
   Store our current register values back into the inferior.  If
   REGNO is -1 then store all the register, otherwise store just
   the value specified by REGNO.
d2000 1
a2000 1
   NOTES
d2002 6
a2007 6
   If we are storing only a single register, we first have to get all
   the current values from the process, overwrite the desired register
   in the gregset with the one we want from gdb's registers, and then
   send the whole set back to the process.  For writing all the
   registers, all we have to do is generate the gregset and send it to
   the process.
d2009 5
a2013 5
   Also note that the process has to be stopped on an event of interest
   for this to work, which basically means that it has to have been
   run under the control of one of the other /proc ioctl calls and not
   ptrace.  Since we don't use ptrace anyway, we don't worry about this
   fine point, but it is worth noting for future reference.
d2015 4
a2018 4
   Gdb is confused about what this function is supposed to return.
   Some versions return a value, others return nothing.  Some are
   declared to return a value and actually return nothing.  Gdb ignores
   anything returned.  (FIXME)
d2039 2
a2040 2
	      (char *) &pi->prstatus.pr_lwp.pr_context.uc_mcontext.gregs,
	      sizeof (gdb_gregset_t));
d2065 2
a2066 2
	      (char *) &pi->prstatus.pr_lwp.pr_context.uc_mcontext.fpregs,
	      sizeof (gdb_fpregset_t));
d2080 1
a2080 1
#endif /* FP0_REGNUM */
d2086 1
a2086 1
   LOCAL FUNCTION
d2088 1
a2088 1
   init_procinfo - setup a procinfo struct and connect it to a process
d2090 1
a2090 1
   SYNOPSIS
d2092 1
a2092 1
   struct procinfo * init_procinfo (int pid)
d2094 1
a2094 1
   DESCRIPTION
d2096 3
a2098 3
   Allocate a procinfo structure, open the /proc file and then set up the
   set of signals and faults that are to be traced.  Returns a pointer to
   the new procinfo structure.  
d2100 1
a2100 1
   NOTES
d2102 2
a2103 2
   If proc_init_failed ever gets called, control returns to the command
   processing loop via the standard error handling code.
d2112 4
a2115 4
  struct procinfo *pi = (struct procinfo *)
  xmalloc (sizeof (struct procinfo));
  struct sig_ctl sctl;
  struct flt_ctl fctl;
d2123 1
a2123 1
  pid = pi->pid;
d2133 1
a2133 1
     so that we can restore them when we detach. */
d2157 1
a2157 1

d2159 1
a2159 1

d2178 1
a2178 1
   LOCAL FUNCTION
d2180 1
a2180 1
   create_procinfo - initialize access to a /proc entry
d2182 1
a2182 1
   SYNOPSIS
d2184 1
a2184 1
   struct procinfo * create_procinfo (int pid)
d2186 1
a2186 1
   DESCRIPTION
d2188 3
a2190 3
   Allocate a procinfo structure, open the /proc file and then set up the
   set of signals and faults that are to be traced.  Returns a pointer to
   the new procinfo structure.
d2192 1
a2192 1
   NOTES
d2194 2
a2195 2
   If proc_init_failed ever gets called, control returns to the command
   processing loop via the standard error handling code.
d2204 2
a2205 2
  struct sig_ctl sctl;
  struct flt_ctl fctl;
d2224 1
a2224 1
      proc_init_failed (pi, "PCSFAULT failed", 1);
d2235 1
a2235 1
   LOCAL FUNCTION
d2237 1
a2237 1
   procfs_exit_handler - handle entry into the _exit syscall
d2239 1
a2239 1
   SYNOPSIS
d2241 1
a2241 1
   int procfs_exit_handler (pi, syscall_num, why, rtnvalp, statvalp)
d2243 1
a2243 1
   DESCRIPTION
d2245 4
a2248 4
   This routine is called when an inferior process enters the _exit()
   system call.  It continues the process, and then collects the exit
   status and pid which are returned in *statvalp and *rtnvalp.  After
   that it returns non-zero to indicate that procfs_wait should wake up.
d2250 2
a2251 2
   NOTES
   There is probably a better way to do this.
d2274 1
a2274 1
  if (write (pi->ctl_fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
d2286 1
a2286 1
      *rtnvalp = inferior_pid;
d2309 1
a2309 1
   LOCAL FUNCTION
d2311 1
a2311 1
   procfs_exec_handler - handle exit from the exec family of syscalls
d2313 1
a2313 1
   SYNOPSIS
d2315 1
a2315 1
   int procfs_exec_handler (pi, syscall_num, why, rtnvalp, statvalp)
d2317 1
a2317 1
   DESCRIPTION
d2319 4
a2322 4
   This routine is called when an inferior process is about to finish any
   of the exec() family of      system calls.  It pretends that we got a
   SIGTRAP (for compatibility with ptrace behavior), and returns non-zero
   to tell procfs_wait to wake up.
d2324 3
a2326 3
   NOTES
   This need for compatibility with ptrace is questionable.  In the
   future, it shouldn't be necessary.
d2348 1
a2348 1
   LOCAL FUNCTION
d2350 1
a2350 1
   procfs_sproc_handler - handle exit from the sproc syscall
d2352 1
a2352 1
   SYNOPSIS
d2354 1
a2354 1
   int procfs_sproc_handler (pi, syscall_num, why, rtnvalp, statvalp)
d2356 1
a2356 1
   DESCRIPTION
d2358 5
a2362 5
   This routine is called when an inferior process is about to finish an
   sproc() system call.  This is the system call that IRIX uses to create
   a lightweight process.  When the target process gets this event, we can
   look at rval1 to find the new child processes ID, and create a new
   procinfo struct from that.
d2364 3
a2366 3
   After that, it pretends that we got a SIGTRAP, and returns non-zero
   to tell procfs_wait to wake up.  Subsequently, wait_for_inferior gets
   woken up, sees the new process and continues it.
d2368 4
a2371 4
   NOTES
   We actually never see the child exiting from sproc because we will
   shortly stop the child with PIOCSTOP, which is then registered as the
   event of interest.
d2414 1
a2414 1
   LOCAL FUNCTION
d2416 1
a2416 1
   procfs_fork_handler - handle exit from the fork syscall
d2418 1
a2418 1
   SYNOPSIS
d2420 1
a2420 1
   int procfs_fork_handler (pi, syscall_num, why, rtnvalp, statvalp)
d2422 1
a2422 1
   DESCRIPTION
d2424 3
a2426 3
   This routine is called when an inferior process is about to finish a
   fork() system call.  We will open up the new process, and then close
   it, which releases it from the clutches of the debugger.
d2428 2
a2429 2
   After that, we continue the target process as though nothing had
   happened.
d2431 5
a2435 5
   NOTES
   This is necessary for IRIX because we have to set PR_FORK in order
   to catch the creation of lwps (via sproc()).  When an actual fork
   occurs, it becomes necessary to reset the forks debugger flags and
   continue it because we can't hack multiple processes yet.
d2469 1
a2469 1
   LOCAL FUNCTION
d2471 1
a2471 1
   procfs_set_inferior_syscall_traps - setup the syscall traps 
d2473 1
a2473 1
   SYNOPSIS
d2475 1
a2475 1
   void procfs_set_inferior_syscall_traps (struct procinfo *pip)
d2477 1
a2477 1
   DESCRIPTION
d2479 3
a2481 3
   Called for each "procinfo" (process, thread, or LWP) in the
   inferior, to register for notification of and handlers for
   syscall traps in the inferior.
d2505 1
a2505 1
#endif /* PRFS_STOPEXEC */
d2534 1
a2534 1
   LOCAL FUNCTION
d2536 2
a2537 2
   procfs_init_inferior - initialize target vector and access to a
   /proc entry
d2539 1
a2539 1
   SYNOPSIS
d2541 1
a2541 1
   void procfs_init_inferior (int pid)
d2543 1
a2543 1
   DESCRIPTION
d2545 6
a2550 6
   When gdb starts an inferior, this function is called in the parent
   process immediately after the fork.  It waits for the child to stop
   on the return from the exec system call (the child itself takes care
   of ensuring that this is set up), then sets up the set of signals
   and faults that are to be traced.  Returns the pid, which may have had
   the thread-id added to it.
d2552 1
a2552 1
   NOTES
d2554 2
a2555 2
   If proc_init_failed ever gets called, control returns to the command
   processing loop via the standard error handling code.
d2559 1
a2559 1
static void
d2574 1
a2574 1
  pid = pip->pid;
d2577 1
a2577 1
  add_thread (pip->pid);	/* Setup initial thread */
d2589 1
a2589 1
   GLOBAL FUNCTION
d2591 1
a2591 1
   procfs_notice_signals
d2593 1
a2593 1
   SYNOPSIS
d2595 1
a2595 1
   static void procfs_notice_signals (int pid);
d2597 1
a2597 1
   DESCRIPTION
d2599 5
a2603 5
   When the user changes the state of gdb's signal handling via the
   "handle" command, this function gets called to see if any change
   in the /proc interface is required.  It is also called internally
   by other /proc interface functions to initialize the state of
   the traced signal set.
d2605 5
a2609 5
   One thing it does is that signals for which the state is "nostop",
   "noprint", and "pass", have their trace bits reset in the pr_trace
   field, so that they are no longer traced.  This allows them to be
   delivered directly to the inferior without the debugger ever being
   involved.
d2617 1
a2617 1
  struct sig_ctl sctl;
d2636 2
a2637 2
     struct procinfo *pi;
     struct sig_ctl *sctl;
d2667 1
a2667 1
   LOCAL FUNCTION
d2669 1
a2669 1
   proc_set_exec_trap -- arrange for exec'd child to halt at startup
d2671 1
a2671 1
   SYNOPSIS
d2673 1
a2673 1
   void proc_set_exec_trap (void)
d2675 1
a2675 1
   DESCRIPTION
d2677 7
a2683 7
   This function is called in the child process when starting up
   an inferior, prior to doing the exec of the actual inferior.
   It sets the child process's exitset to make exit from the exec
   system call an event of interest to stop on, and then simply
   returns.  The child does the exec, the system call returns, and
   the child stops at the first instruction, ready for the gdb
   parent process to take control of it.
d2685 1
a2685 1
   NOTE
d2687 3
a2689 3
   We need to use all local variables since the child may be sharing
   it's data space with the parent, if vfork was used rather than
   fork.
d2691 3
a2693 3
   Also note that we want to turn off the inherit-on-fork flag in
   the child process so that any grand-children start with all
   tracing flags cleared.
d2703 1
a2703 1

d2791 2
a2792 2
#ifndef UNIXWARE		/* since this is a solaris-ism, we don't want it */
  /* NOTE: revisit when doing thread support for UW */
d2805 1
a2805 1
    pctl.data = PR_FORK | PR_ASYNC;
d2811 2
a2812 2
#endif /* PR_ASYNC */
#endif /* !UNIXWARE */
d2817 1
a2817 1
   GLOBAL FUNCTION
d2819 1
a2819 1
   proc_iterate_over_mappings -- call function for every mapped space
d2821 1
a2821 1
   SYNOPSIS
d2823 1
a2823 1
   int proc_iterate_over_mappings (int (*func)())
d2825 1
a2825 1
   DESCRIPTION
d2827 5
a2831 5
   Given a pointer to a function, call that function for every
   mapped address space, passing it an open file descriptor for
   the file corresponding to that mapped address space (if any)
   and the base address of the mapped space.  Quit when we hit
   the end of the mappings or the function returns nonzero.
d2853 1
a2853 1
  prmaps = (prmap_t *) alloca (nmap * sizeof (prmap_t));
d2855 2
a2856 2
      (read (pi->map_fd, (char *) prmaps, nmap * sizeof (prmap_t)) ==
       (nmap * sizeof (prmap_t))))
d2860 12
a2871 12
	{
	  char name[sizeof ("/proc/1234567890/object") +
		    sizeof (prmap->pr_mapname)];
	  sprintf (name, "/proc/%d/object/%s", pi->pid, prmap->pr_mapname);
	  if ((fd = open (name, O_RDONLY)) == -1)
	    {
	      funcstat = 1;
	      break;
	    }
	  funcstat = (*func) (fd, (CORE_ADDR) prmap->pr_vaddr);
	  close (fd);
	}
d2894 1
a2894 1
	  for (prmap = prmaps; prmap->pr_size && funcstat == 0; ++prmap)
d2896 2
a2897 2
	      fd = proc_address_to_fd (pi, (CORE_ADDR) prmap->pr_vaddr, 0);
	      funcstat = (*func) (fd, (CORE_ADDR) prmap->pr_vaddr);
d2906 1
a2906 1
#if 0				/* Currently unused */
d2909 1
a2909 1
   GLOBAL FUNCTION
d2911 1
a2911 1
   proc_base_address -- find base address for segment containing address
d2913 1
a2913 1
   SYNOPSIS
d2915 1
a2915 1
   CORE_ADDR proc_base_address (CORE_ADDR addr)
d2917 1
a2917 1
   DESCRIPTION
d2919 2
a2920 2
   Given an address of a location in the inferior, find and return
   the base address of the mapped segment containing that address.
d2922 5
a2926 5
   This is used for example, by the shared library support code,
   where we have the pc value for some location in the shared library
   where we are stopped, and need to know the base address of the
   segment containing that address.
 */
d2945 1
a2945 1
	  for (prmap = prmaps; prmap->pr_size; ++prmap)
d2947 2
a2948 2
	      if ((prmap->pr_vaddr <= (caddr_t) addr) &&
		  (prmap->pr_vaddr + prmap->pr_size > (caddr_t) addr))
d2950 1
a2950 1
		  baseaddr = (CORE_ADDR) prmap->pr_vaddr;
d2959 1
a2959 1
#endif /* 0 */
d2964 1
a2964 1
   LOCAL FUNCTION
d2966 1
a2966 1
   proc_address_to_fd -- return open fd for file mapped to address
d2968 1
a2968 1
   SYNOPSIS
d2970 1
a2970 1
   int proc_address_to_fd (struct procinfo *pi, CORE_ADDR addr, complain)
d2972 1
a2972 1
   DESCRIPTION
d2974 5
a2978 5
   Given an address in the current inferior's address space, use the
   /proc interface to find an open file descriptor for the file that
   this address was mapped in from.  Return -1 if there is no current
   inferior.  Print a warning message if there is an inferior but
   the address corresponds to no file (IE a bogus address).
d2980 1
a2980 1
 */
d2990 1
a2990 1
  if ((fd = ioctl (pi->ctl_fd, PIOCOPENM, (caddr_t *) & addr)) < 0)
d3018 1
a3018 1
  if (pid == getpid ())		/* Trying to masturbate? */
d3059 1
a3059 1
			 exec_file, target_pid_to_str (inferior_pid));
d3064 1
a3064 1

d3067 1
a3067 1
  unpush_target (&procfs_ops);	/* Pop out of handling an inferior */
d3091 1
a3091 1
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_pid));
d3105 1
a3105 1
   LOCAL FUNCTION
d3107 1
a3107 1
   do_attach -- attach to an already existing process
d3109 1
a3109 1
   SYNOPSIS
d3111 1
a3111 1
   int do_attach (int pid)
d3113 1
a3113 1
   DESCRIPTION
d3115 3
a3117 3
   Attach to an already existing process with the specified process
   id.  If the process is not already stopped, query whether to
   stop it or not.
d3119 1
a3119 1
   NOTES
d3121 4
a3124 4
   The option of stopping at attach time is specific to the /proc
   versions of gdb.  Versions using ptrace force the attachee
   to stop.  (I have changed this version to do so, too.  All you
   have to do is "continue" to make it go on. -- gnu@@cygnus.com)
d3126 1
a3126 1
 */
d3137 1
a3137 1
  pi = init_procinfo (pid, 0);
d3145 1
a3145 1
      print_sys_errmsg (pi->pathname, errno);
d3159 1
a3159 1
      if (THE_PR_LWP (pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP))
d3188 1
a3188 1
		}
d3194 1
a3194 1
	      printf_unfiltered ("Ok, gdb will wait for %s to stop.\n",
d3202 1
a3202 1
	  print_sys_errmsg ("PCSFAULT failed", errno);
d3222 1
a3222 1
   LOCAL FUNCTION
d3224 1
a3224 1
   do_detach -- detach from an attached-to process
d3226 1
a3226 1
   SYNOPSIS
d3228 1
a3228 1
   void do_detach (int signal)
d3230 1
a3230 1
   DESCRIPTION
d3232 1
a3232 1
   Detach from the current attachee.
d3234 2
a3235 2
   If signal is non-zero, the attachee is started running again and sent
   the specified signal.
d3237 2
a3238 2
   If signal is zero and the attachee was not already stopped when we
   attached to it, then we make it runnable again when we detach.
d3240 3
a3242 3
   Otherwise, we query whether or not to make the attachee runnable
   again, since we may simply want to leave it in the state it was in
   when we attached.
d3244 3
a3246 3
   We report any problems, but do not consider them errors, since we
   MUST detach even if some things don't seem to go right.  This may not
   be the ideal situation.  (FIXME).
d3266 1
a3266 1
      if (ioctl (pi->ctl_fd, PIOCSEXIT, &pi->saved_exitset.sysset) < 0)
d3268 4
a3271 4
	{
	  print_sys_errmsg (pi->pathname, errno);
	  printf_unfiltered ("PIOCSEXIT failed.\n");
	}
d3277 1
a3277 1
      if (ioctl (pi->ctl_fd, PIOCSENTRY, &pi->saved_entryset.sysset) < 0)
d3279 4
a3282 4
	{
	  print_sys_errmsg (pi->pathname, errno);
	  printf_unfiltered ("PIOCSENTRY failed.\n");
	}
d3288 1
a3288 1
      if (ioctl (pi->ctl_fd, PIOCSTRACE, &pi->saved_trace.sigset) < 0)
d3290 4
a3293 4
	{
	  print_sys_errmsg (pi->pathname, errno);
	  printf_unfiltered ("PIOCSTRACE failed.\n");
	}
d3320 1
a3320 1
	  || (THE_PR_LWP (pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP)))
d3326 1
a3326 1
	      query ("Was stopped when attached, make it runnable again? "))
d3357 2
a3358 2
   Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status in *OURSTATUS.
d3360 17
a3376 17
   Not sure why we can't
   just use wait(), but it seems to have problems when applied to a
   process being controlled with the /proc interface.

   We have a race problem here with no obvious solution.  We need to let
   the inferior run until it stops on an event of interest, which means
   that we need to use the PIOCWSTOP ioctl.  However, we cannot use this
   ioctl if the process is already stopped on something that is not an
   event of interest, or the call will hang indefinitely.  Thus we first
   use PIOCSTATUS to see if the process is not stopped.  If not, then we
   use PIOCWSTOP.  But during the window between the two, if the process
   stops for any reason that is not an event of interest (such as a job
   control signal) then gdb will hang.  One possible workaround is to set
   an alarm to wake up every minute of so and check to see if the process
   is still running, and if so, then reissue the PIOCWSTOP.  But this is
   a real kludge, so has not been implemented.  FIXME: investigate
   alternatives.
d3378 2
a3379 2
   FIXME:  Investigate why wait() seems to have problems with programs
   being control by /proc routines.  */
d3403 1
a3403 1
      if (!(THE_PR_LWP (pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP)))
d3406 2
a3407 2
      why = THE_PR_LWP (pi->prstatus).pr_why;
      what = THE_PR_LWP (pi->prstatus).pr_what;
d3448 1
a3448 1
      && !(THE_PR_LWP (pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP)))
d3475 1
a3475 1
  else if (THE_PR_LWP (pi->prstatus).pr_flags & (PR_STOPPED | PR_ISTOP))
d3482 2
a3483 2
      why = THE_PR_LWP (pi->prstatus).pr_why;
      what = THE_PR_LWP (pi->prstatus).pr_what;
d3516 1
a3516 1
	         Solaris fills in si_signo.  I'm not sure about others.  */
d3535 1
a3535 1
	    case FLTPAGE:	/* Recoverable page fault */
d3539 4
a3542 4
	         trying to second-guess it from the fault.  In fact, I suspect
	         that FLTACCESS can be either SIGSEGV or SIGBUS.  */
	      statval =
		((THE_PR_LWP (pi->prstatus).pr_info.si_signo) << 8) | 0177;
d3574 1
a3574 1
		      printf_filtered ("LWP %d doesn't respond.\n",
d3595 1
a3595 1
	     THE_PR_LWP (pi->prstatus).pr_flags);
d3615 1
a3615 1
   LOCAL FUNCTION
d3617 1
a3617 1
   set_proc_siginfo - set a process's current signal info
d3619 1
a3619 1
   SYNOPSIS
d3621 1
a3621 1
   void set_proc_siginfo (struct procinfo *pip, int signo);
d3623 24
a3646 24
   DESCRIPTION

   Given a pointer to a process info struct in PIP and a signal number
   in SIGNO, set the process's current signal and its associated signal
   information.  The signal will be delivered to the process immediately
   after execution is resumed, even if it is being held.  In addition,
   this particular delivery will not cause another PR_SIGNALLED stop
   even if the signal is being traced.

   If we are not delivering the same signal that the prstatus siginfo
   struct contains information about, then synthesize a siginfo struct
   to match the signal we are going to deliver, make it of the type
   "generated by a user process", and send this synthesized copy.  When
   used to set the inferior's signal state, this will be required if we
   are not currently stopped because of a traced signal, or if we decide
   to continue with a different signal.

   Note that when continuing the inferior from a stop due to receipt
   of a traced signal, we either have set PRCSIG to clear the existing
   signal, or we have to call this function to do a PIOCSSIG with either
   the existing siginfo struct from pr_info, or one we have synthesized
   appropriately for the signal we want to deliver.  Otherwise if the
   signal is still being traced, the inferior will immediately stop
   again.
d3648 2
a3649 2
   See siginfo(5) for more details.
 */
d3664 1
a3664 1
  if (signo == THE_PR_LWP (pip->prstatus).pr_cursig)
d3669 1
a3669 1
  if (signo == THE_PR_LWP (pip->prstatus).pr_info.si_signo)
d3672 1
a3672 1
	      sizeof (siginfo_t));
d3675 1
a3675 1
  if (signo == THE_PR_LWP (pip->prstatus).pr_info.si_signo)
d3677 1
a3677 1
      sip = &pip->prstatus.pr_info;
d3689 5
a3693 5
      sip->si_signo = signo;
      sip->si_code = 0;
      sip->si_errno = 0;
      sip->si_pid = getpid ();
      sip->si_uid = getuid ();
d3702 1
a3702 1
      print_sys_errmsg (pip->pathname, errno);
d3734 5
a3738 5
/*      It may not be absolutely necessary to specify the PC value for
   restarting, but to be safe we use the value that gdb considers
   to be current.  One case where this might be necessary is if the
   user explicitly changes the PC value that gdb considers to be
   current.  FIXME:  Investigate if this is necessary or not.  */
d3746 1
a3746 1
  pi->prrun.pr_vaddr = (caddr_t) * (int *) &registers[REGISTER_BYTE (PC_REGNUM)];
d3764 3
a3766 3
	   && THE_PR_LWP (pi->prstatus).pr_cursig == SIGTSTP
	   && THE_PR_LWP (pi->prstatus).pr_action.sa_handler == SIG_DFL
    )
d3815 1
a3815 1
	printf_filtered ("LWP %d doesn't respond.\n",
d3830 1
a3830 1
	    printf_filtered ("LWP %d doesn't respond.\n",
d3846 1
a3846 1
	  if (!procinfo->had_event ||
d3856 3
a3858 3
		    fprintf_unfiltered (gdb_stderr,
				    "procfs_read_status failed, errno=%d\n",
					errno);
d3869 1
a3869 1
		    printf_filtered ("LWP %d doesn't respond.\n",
d3876 1
a3876 1
	         `event of interest'.  Doing so will cause errors.  */
d3882 3
a3884 3
		    fprintf_unfiltered (gdb_stderr,
				    "procfs_read_status failed, errno=%d\n",
					errno);
d3896 1
a3896 1
   LOCAL FUNCTION
d3898 1
a3898 1
   procfs_fetch_registers -- fetch current registers from inferior
d3900 1
a3900 1
   SYNOPSIS
d3902 1
a3902 1
   void procfs_fetch_registers (int regno)
d3904 1
a3904 1
   DESCRIPTION
d3906 3
a3908 3
   Read the current values of the inferior's registers, both the
   general register set and floating point registers (if supported)
   and update gdb's idea of their current values.
d3910 1
a3910 1
 */
d3925 1
a3925 1
      supply_fpregset (&pi->prstatus.pr_lwp.pr_context.uc_mcontext.fpregs);
d3944 1
a3944 1
   LOCAL FUNCTION
d3946 2
a3947 2
   proc_init_failed - called when /proc access initialization fails
   fails
d3949 1
a3949 1
   SYNOPSIS
d3951 2
a3952 2
   static void proc_init_failed (struct procinfo *pi, 
   char *why, int kill_p)
d3954 1
a3954 1
   DESCRIPTION
d3956 4
a3959 4
   This function is called whenever initialization of access to a /proc
   entry fails.  It prints a suitable error message, does some cleanup,
   and then invokes the standard error processing routine which dumps
   us back into the command loop.  If KILL_P is true, sends SIGKILL.
d3966 1
a3966 1
     int kill_p;
d3978 1
a3978 1
   LOCAL FUNCTION
d3980 1
a3980 1
   close_proc_file - close any currently open /proc entry
d3982 1
a3982 1
   SYNOPSIS
d3984 1
a3984 1
   static void close_proc_file (struct procinfo *pip)
d3986 1
a3986 1
   DESCRIPTION
d3988 4
a3991 4
   Close any currently open /proc entry and mark the process information
   entry as invalid.  In order to ensure that we don't try to reuse any
   stale information, the pid, fd, and pathnames are explicitly
   invalidated, which may be overkill.
d4011 1
a4011 1
  free (pip->pathname);
d4020 2
a4021 2
	{
	  if (procinfo->next == pip)
d4026 1
a4026 1
	}
d4047 1
a4047 1
   LOCAL FUNCTION
d4049 1
a4049 1
   open_proc_file - open a /proc entry for a given process id
d4051 1
a4051 1
   SYNOPSIS
d4053 1
a4053 1
   static int open_proc_file (int pid, struct procinfo *pip, int mode)
d4055 1
a4055 1
   DESCRIPTION
d4057 6
a4062 6
   Given a process id and a mode, close the existing open /proc
   entry (if any) and open one for the new process id, in the
   specified mode.  Once it is open, then mark the local process
   information structure as valid, which guarantees that the pid,
   fd, and pathname fields match an open /proc entry.  Returns
   zero if the open fails, nonzero otherwise.
d4064 3
a4066 3
   Note that the pathname is left intact, even when the open fails,
   so that callers can use it to construct meaningful error messages
   rather than just "file open failed".
d4068 4
a4071 4
   Note that for Solaris, the process-id also includes an LWP-id, so we
   actually attempt to open that.  If we are handed a pid with a 0 LWP-id,
   then we will ask the kernel what it is and add it to the pid.  Hence,
   the pid can be changed by us.
d4083 4
a4086 4
  pip->next = NULL;
  pip->had_event = 0;
  pip->pathname = xmalloc (MAX_PROC_NAME_SIZE);
  pip->pid = pid;
d4122 4
a4125 4
	  close (pip->as_fd);
	  close (pip->map_fd);
	  return 0;
	}
d4129 1
a4129 1
  sprintf (pip->pathname, CTL_PROC_NAME_FMT, tmp);
d4131 1
a4131 1
  if ((tmpfd = open (pip->pathname, mode)) < 0)
d4135 4
a4138 4
  pip->ctl_fd = tmpfd;
  pip->as_fd = tmpfd;
  pip->map_fd = tmpfd;
  pip->status_fd = tmpfd;
d4144 1
a4144 1
      if (ioctl (tmpfd, PIOCSTATUS, &pip->prstatus) < 0)
d4146 1
a4146 1
	  print_sys_errmsg (pip->pathname, errno);
d4151 2
a4152 2
      tmp = pip->prstatus.pr_who;	/* Get thread id from prstatus_t */
      pip->pid = (tmp << 16) | pid;	/* Update pip */
d4155 1
a4155 1
  if ((pip->ctl_fd = ioctl (tmpfd, PIOCOPENLWP, &tmp)) < 0)
d4163 3
a4165 3
    long pr_flags;
    pr_flags = PR_ASYNC;
    ioctl (pip->ctl_fd, PIOCSET, &pr_flags);
d4175 1
a4175 1
#endif /* PIOCOPENLWP */
d4187 1
a4187 1

d4190 1
a4190 2
  if (flags & MA_PHYS)
    asciiflags[0] = 'd';
d4192 6
a4197 12
  if (flags & MA_STACK)
    asciiflags[1] = 's';
  if (flags & MA_BREAK)
    asciiflags[2] = 'b';
  if (flags & MA_SHARED)
    asciiflags[3] = 's';
  if (flags & MA_READ)
    asciiflags[4] = 'r';
  if (flags & MA_WRITE)
    asciiflags[5] = 'w';
  if (flags & MA_EXEC)
    asciiflags[6] = 'x';
d4218 1
a4218 1
  for (transp = pr_flag_table; transp->name != NULL; transp++)
d4220 1
a4220 1
      if (flags & transp->value)
d4224 1
a4224 1
	      printf_filtered ("%s ", transp->name);
d4228 1
a4228 1
	      printf_filtered ("\t%-16s %s.\n", transp->name, transp->desc);
d4244 2
a4245 2
  why = THE_PR_LWP (pip->prstatus).pr_why;
  what = THE_PR_LWP (pip->prstatus).pr_what;
d4247 1
a4247 1
  if (THE_PR_LWP (pip->prstatus).pr_flags & PR_STOPPED)
d4254 1
a4254 1
      for (transp = pr_why_table; transp->name != NULL; transp++)
d4256 1
a4256 1
	  if (why == transp->value)
d4260 1
a4260 1
		  printf_filtered ("%s ", transp->name);
d4265 1
a4265 1
				   transp->name, transp->desc);
d4270 1
a4270 1

d4272 2
a4273 2
         print more information. */

d4276 51
a4326 51
	case PR_REQUESTED:
	  /* pr_what is unused for this case */
	  break;
	case PR_JOBCONTROL:
	case PR_SIGNALLED:
	  if (summary)
	    {
	      printf_filtered ("%s ", signalname (what));
	    }
	  else
	    {
	      printf_filtered ("\t%-16s %s.\n", signalname (what),
			       safe_strsignal (what));
	    }
	  break;
	case PR_SYSENTRY:
	  if (summary)
	    {
	      printf_filtered ("%s ", syscallname (what));
	    }
	  else
	    {
	      printf_filtered ("\t%-16s %s.\n", syscallname (what),
			       "Entered this system call");
	    }
	  break;
	case PR_SYSEXIT:
	  if (summary)
	    {
	      printf_filtered ("%s ", syscallname (what));
	    }
	  else
	    {
	      printf_filtered ("\t%-16s %s.\n", syscallname (what),
			       "Returned from this system call");
	    }
	  break;
	case PR_FAULTED:
	  if (summary)
	    {
	      printf_filtered ("%s ",
			       lookupname (faults_table, what, "fault"));
	    }
	  else
	    {
	      printf_filtered ("\t%-16s %s.\n",
			       lookupname (faults_table, what, "fault"),
			       lookupdesc (faults_table, what));
	    }
	  break;
	}
d4338 3
a4340 3
  if ((THE_PR_LWP (pip->prstatus).pr_flags & PR_STOPPED) &&
      (THE_PR_LWP (pip->prstatus).pr_why == PR_SIGNALLED ||
       THE_PR_LWP (pip->prstatus).pr_why == PR_FAULTED))
d4343 1
a4343 1
      sip = &(THE_PR_LWP (pip->prstatus).pr_info);
d4346 2
a4347 2
	  printf_filtered ("%s ", signalname (sip->si_signo));
	  if (sip->si_errno > 0)
d4349 1
a4349 1
	      printf_filtered ("%s ", errnoname (sip->si_errno));
d4351 1
a4351 1
	  if (sip->si_code <= 0)
d4354 2
a4355 2
			       target_pid_to_str (sip->si_pid),
			       sip->si_uid);
d4360 4
a4363 4
	      if ((sip->si_signo == SIGILL) ||
		  (sip->si_signo == SIGFPE) ||
		  (sip->si_signo == SIGSEGV) ||
		  (sip->si_signo == SIGBUS))
d4366 1
a4366 1
				   (unsigned long) sip->si_addr);
d4368 1
a4368 1
	      else if ((sip->si_signo == SIGCHLD))
d4371 2
a4372 2
				   target_pid_to_str (sip->si_pid),
				   sip->si_status);
d4374 1
a4374 1
	      else if ((sip->si_signo == SIGPOLL))
d4376 1
a4376 1
		  printf_filtered ("band %u ", sip->si_band);
d4383 3
a4385 3
	  printf_filtered ("\t%-16s %s.\n", signalname (sip->si_signo),
			   safe_strsignal (sip->si_signo));
	  if (sip->si_errno > 0)
d4388 2
a4389 2
			       errnoname (sip->si_errno),
			       safe_strerror (sip->si_errno));
d4391 1
a4391 1
	  if (sip->si_code <= 0)
d4393 1
a4393 1
	      printf_filtered ("\t%-16u %s\n", sip->si_pid,	/* XXX need target_pid_to_str() */
d4395 1
a4395 1
	      printf_filtered ("\t%-16u %s\n", sip->si_uid,
d4402 2
a4403 2
	      if ((sip->si_signo == SIGILL) ||
		  (sip->si_signo == SIGFPE))
d4406 1
a4406 1
				   (unsigned long) sip->si_addr,
d4409 2
a4410 2
	      else if ((sip->si_signo == SIGSEGV) ||
		       (sip->si_signo == SIGBUS))
d4413 1
a4413 1
				   (unsigned long) sip->si_addr,
d4416 1
a4416 1
	      else if ((sip->si_signo == SIGCHLD))
d4418 1
a4418 1
		  printf_filtered ("\t%-16u %s.\n", sip->si_pid,	/* XXX need target_pid_to_str() */
d4420 1
a4420 1
		  printf_filtered ("\t%-16u %s.\n", sip->si_status,
d4423 1
a4423 1
	      else if ((sip->si_signo == SIGPOLL))
d4425 1
a4425 1
		  printf_filtered ("\t%-16u %s.\n", sip->si_band,
d4444 2
a4445 2
#if 0				/* FIXME:  Needs to use gdb-wide configured info about system calls. */
      if (pip->prstatus.pr_flags & PR_ASLEEP)
d4447 1
a4447 1
	  int syscallnum = pip->prstatus.pr_reg[R_D0];
d4462 1
a4462 1
      if (ioctl (pip->ctl_fd, PIOCGENTRY, &pip->entryset) < 0)
d4464 1
a4464 1
	  print_sys_errmsg (pip->pathname, errno);
d4467 2
a4468 2

      if (ioctl (pip->ctl_fd, PIOCGEXIT, &pip->exitset) < 0)
d4470 1
a4470 1
	  print_sys_errmsg (pip->pathname, errno);
d4474 1
a4474 1

d4476 1
a4476 1

d4491 1
a4491 1
			 prismember (&pip->prstatus.pr_sysentry, syscallnum)
d4498 1
a4498 1
			   prismember (&pip->entryset, syscallnum)
d4501 1
a4501 1
			   prismember (&pip->exitset, syscallnum)
d4558 1
a4558 1
      if (ioctl (pip->ctl_fd, PIOCGTRACE, &pip->trace) < 0)
d4560 1
a4560 1
	  print_sys_errmsg (pip->pathname, errno);
d4564 1
a4564 1

d4574 1
a4574 1
			   prismember (&pip->prstatus.pr_sigtrace, signo)
d4577 1
a4577 1
	     prismember (&pip->prstatus.pr_lwp.pr_context.uc_sigmask, signo)
d4581 1
a4581 1
			   prismember (&pip->trace, signo)
d4584 1
a4584 1
			   prismember (&pip->prstatus.pr_sighold, signo)
d4590 2
a4591 2
	      prismember (&pip->prstatus.pr_lwp.pr_lwppend, signo))
	    printf_filtered ("%-8s ", "yes");
d4593 1
a4593 1
	    printf_filtered ("%-8s ", "no");
d4598 1
a4598 1
			   (signo ? prismember (&pip->prstatus.pr_sigpend,
d4600 1
a4600 1
			    : 0)
d4604 1
a4604 1
			   prismember (&pip->prstatus.pr_sigpend, signo)
d4624 1
a4624 1
      if (ioctl (pip->ctl_fd, PIOCGFAULT, &pip->fltset.fltset) < 0)
d4626 1
a4626 1
	  print_sys_errmsg (pip->pathname, errno);
d4630 1
a4630 1

d4634 1
a4634 1
      for (transp = faults_table; transp->name != NULL; transp++)
d4637 1
a4637 1
	  printf_filtered ("\t%-12s ", transp->name);
d4639 1
a4639 1
	  printf_filtered ("%-8s", prismember (&pip->prstatus.pr_flttrace, transp->value)
d4642 1
a4642 1
	  printf_filtered ("%-8s", prismember (&pip->fltset.fltset, transp->value)
d4676 2
a4677 2
	{
	  nmap = sbuf.st_size / sizeof (prmap_t);
d4679 3
a4681 3
	  if ((lseek (pip->map_fd, 0, SEEK_SET) == 0) &&
	      (read (pip->map_fd, (char *) prmaps,
		     nmap * sizeof (*prmaps)) == (nmap * sizeof (*prmaps))))
d4686 1
a4686 1
      if (ioctl (pip->ctl_fd, PIOCNMAP, &nmap) == 0)
d4689 1
a4689 1
	  if (ioctl (pip->ctl_fd, PIOCMAP, prmaps) == 0)
d4691 1
a4691 1
	      for (prmap = prmaps; prmap->pr_size; ++prmap)
d4699 6
a4704 6
				   (unsigned long) prmap->pr_vaddr,
				   (unsigned long) prmap->pr_vaddr
				   + prmap->pr_size - 1,
				   prmap->pr_size,
				   prmap->pr_off,
				   mappingflags (prmap->pr_mflags));
d4714 1
a4714 1
   LOCAL FUNCTION
d4716 1
a4716 1
   info_proc -- implement the "info proc" command
d4718 1
a4718 1
   SYNOPSIS
d4720 1
a4720 1
   void info_proc (char *args, int from_tty)
d4722 1
a4722 1
   DESCRIPTION
d4724 2
a4725 2
   Implement gdb's "info proc" command by using the /proc interface
   to print status information about any currently running process.
d4727 1
a4727 1
   Examples of the use of "info proc" are:
d4729 10
a4738 10
   info proc            (prints summary info for current inferior)
   info proc 123                (prints summary info for process with pid 123)
   info proc mappings   (prints address mappings)
   info proc times              (prints process/children times)
   info proc id         (prints pid, ppid, gid, sid, etc)
   FIXME:  i proc id not implemented.
   info proc status     (prints general process state info)
   FIXME:  i proc status not implemented.
   info proc signals    (prints info about signal handling)
   info proc all                (prints all info)
d4770 4
a4773 4
  pid = inferior_pid & 0x7fffffff;	/* strip off sol-thread bit */
  if (!(pip = find_procinfo (pid, 1)))	/* inferior_pid no good?  */
    pip = procinfo_list;	/* take first available */
  pid = pid & 0xffff;		/* extract "real" pid */
d4839 1
a4839 1
		  perror_with_name (pip->pathname);
d4864 1
a4864 1
      print_sys_errmsg (pip->pathname, errno);
d4875 1
a4875 1
      print_sys_errmsg (pip->pathname, errno);
d4899 1
a4899 1
	      print_sys_errmsg (pip->pathname, errno);
d4907 1
a4907 1
         of the information for all types. */
d4909 1
a4909 1
      printf_filtered ("\nInformation for %s.%d:\n\n", pip->pathname, *lwps);
d4949 1
a4949 1
         freeing temporary memory , etc. */
d4959 1
a4959 1
   LOCAL FUNCTION
d4961 1
a4961 1
   modify_inherit_on_fork_flag - Change the inherit-on-fork flag
d4963 1
a4963 1
   SYNOPSIS
d4965 1
a4965 1
   void modify_inherit_on_fork_flag (fd, flag)
d4967 1
a4967 1
   DESCRIPTION
d4969 3
a4971 3
   Call this routine to modify the inherit-on-fork flag.  This routine is
   just a nice wrapper to hide the #ifdefs needed by various systems to
   control this flag.
d4994 1
a4994 1
	  retval = -1;
d5005 1
a5005 1
	  retval = -1;
d5022 1
a5022 1
  Neither PR_FORK nor PIOCSFORK exist ! !!
d5027 1
a5027 1
      return;
d5035 1
a5035 1
   LOCAL FUNCTION
d5037 1
a5037 1
   modify_run_on_last_close_flag - Change the run-on-last-close flag
d5039 1
a5039 1
   SYNOPSIS
d5041 1
a5041 1
   void modify_run_on_last_close_flag (fd, flag)
d5043 1
a5043 1
   DESCRIPTION
d5045 3
a5047 3
   Call this routine to modify the run-on-last-close flag.  This routine
   is just a nice wrapper to hide the #ifdefs needed by various systems to
   control this flag.
d5070 1
a5070 1
	  retval = -1;
d5081 1
a5081 1
	  retval = -1;
d5094 1
a5094 1
  Neither PR_RLC nor PIOCSRLC exist ! !!
d5099 1
a5099 1
      return;
d5107 1
a5107 1
   LOCAL FUNCTION
d5109 1
a5109 1
   procfs_clear_syscall_trap -- Deletes the trap for the specified system call.
d5111 1
a5111 1
   SYNOPSIS
d5113 1
a5113 1
   void procfs_clear_syscall_trap (struct procinfo *, int syscall_num, int errok)
d5115 1
a5115 1
   DESCRIPTION
d5117 2
a5118 2
   This function function disables traps for the specified system call.
   errok is non-zero if errors should be ignored.
d5194 1
a5194 1
				  * sizeof (struct procfs_syscall_handler));
d5206 1
a5206 1
   LOCAL FUNCTION
d5208 2
a5209 2
   procfs_set_syscall_trap -- arrange for a function to be called when the
   child executes the specified system call.
d5211 1
a5211 1
   SYNOPSIS
d5213 2
a5214 2
   void procfs_set_syscall_trap (struct procinfo *, int syscall_num, int flags,
   syscall_func_t *function)
d5216 1
a5216 1
   DESCRIPTION
d5218 6
a5223 6
   This function sets up an entry and/or exit trap for the specified system
   call.  When the child executes the specified system call, your function
   will be      called with the call #, a flag that indicates entry or exit, and
   pointers to rtnval and statval (which are used by procfs_wait).  The
   function should return non-zero if something interesting happened, zero
   otherwise.
d5292 1
a5292 1
				  * sizeof (struct procfs_syscall_handler));
d5303 1
a5303 1
   LOCAL FUNCTION
d5305 1
a5305 1
   procfs_lwp_creation_handler - handle exit from the _lwp_create syscall
d5307 1
a5307 1
   SYNOPSIS
d5309 1
a5309 1
   int procfs_lwp_creation_handler (pi, syscall_num, why, rtnvalp, statvalp)
d5311 1
a5311 1
   DESCRIPTION
d5313 8
a5320 8
   This routine is called both when an inferior process and it's new lwp
   are about to finish a _lwp_create() system call.  This is the system
   call that Solaris uses to create a lightweight process.  When the
   target process gets this event, we can look at sysarg[2] to find the
   new childs lwp ID, and create a procinfo struct from that.  After that,
   we pretend that we got a SIGTRAP, and return non-zero to tell
   procfs_wait to wake up.  Subsequently, wait_for_inferior gets woken up,
   sees the new process and continues it.
d5322 2
a5323 2
   When we see the child exiting from lwp_create, we just contine it,
   since everything was handled when the parent trapped.
d5325 4
a5328 4
   NOTES
   In effect, we are only paying attention to the parent's completion of
   the lwp_create syscall.  If we only paid attention to the child
   instead, then we wouldn't detect the creation of a suspended thread.
d5353 1
a5353 1
    {				/* _lwp_create failed */
d5358 1
a5358 1
	  perror_with_name (pi->pathname);
d5384 1
a5384 1
      if (write (pi->ctl_fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
d5404 1
a5404 1
		      THE_PR_LWP (pi->prstatus).pr_sysarg[2], sizeof (int));
d5423 1
a5423 1
  if (write (pi->ctl_fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
d5435 1
a5435 1
  if (THE_PR_LWP (childpi->prstatus).pr_why == PR_SUSPENDED)
d5444 1
a5444 1
      if (write (pi->ctl_fd, (char *) &pctl, sizeof (struct proc_ctl)) < 0)
d5471 19
a5489 19
         just do this the normal way (via execlp, which operates by
         attempting an exec for each element of the PATH until it
         finds one which succeeds), then there will be an exec for
         each failed attempt, each of which will cause a PR_SYSEXIT
         stop, and we won't know how to distinguish the PR_SYSEXIT's
         for these failed execs with the ones for successful execs
         (whether the exec has succeeded is stored at that time in the
         carry bit or some such architecture-specific and
         non-ABI-specified place).

         So I can't think of anything better than to search the PATH
         now.  This has several disadvantages: (1) There is a race
         condition; if we find a file now and it is deleted before we
         exec it, we lose, even if the deletion leaves a valid file
         further down in the PATH, (2) there is no way to know exactly
         what an executable (in the sense of "capable of being
         exec'd") file is.  Using access() loses because it may lose
         if the caller is the superuser; failing to use it loses if
         there are ACLs or some such.  */
d5494 1
a5494 1
         path is used from within GDB.  */
d5503 1
a5503 1
      for (p = path; p != NULL; p = p1 ? p1 + 1 : NULL)
d5540 1
a5540 1
  proceed ((CORE_ADDR) - 1, TARGET_SIGNAL_0, 0);
d5577 5
a5581 5
procfs_set_watchpoint (pid, addr, len, rw)
     int pid;
     CORE_ADDR addr;
     int len;
     int rw;
d5583 2
a5584 2
  struct procinfo *pi;
  prwatch_t wpt;
d5587 1
a5587 1
  wpt.pr_vaddr = (caddr_t) addr;
d5595 1
a5595 1
         deleted twice - don't die in this case (FIXME please) */
d5605 2
a5606 2
procfs_stopped_by_watchpoint (pid)
     int pid;
d5608 3
a5610 3
  struct procinfo *pi;
  short what;
  short why;
d5617 1
a5617 1
      if (why == PR_FAULTED
d5622 1
a5622 1
	  && (what == FLTWATCH)
d5628 1
a5628 1
	)
d5648 1
a5648 1
      if (pi->pid == pid)
d5651 1
a5651 2
	else
	  /* defunct (exited) */
d5713 1
a5714 1

d5773 2
a5774 2
  add_info ("processes", info_proc,
	    "Show process status information using /proc entry.\n\
@


1.1.1.5
log
@import gdb-1999-08-30 snapshot
@
text
@d49 1
@


1.1.1.6
log
@import gdb-1999-09-28 snapshot
@
text
@d2268 3
d2283 5
a2342 3
  prfillset (&fctl.fltset);
  prdelset (&fctl.fltset, FLTPAGE);

a2345 5
  prfillset (&pi->prrun.pr_fault);
  prdelset (&pi->prrun.pr_fault, FLTPAGE);
#ifdef PROCFS_DONT_TRACE_FAULTS
  premptyset (&pi->prrun.pr_fault);
#endif
a3320 3
      prfillset (&fctl.fltset);
      prdelset (&fctl.fltset, FLTPAGE);

a3323 5
      prfillset (&pi->prrun.pr_fault);
      prdelset (&pi->prrun.pr_fault, FLTPAGE);
#ifdef PROCFS_DONT_TRACE_FAULTS
      premptyset (&pi->prrun.pr_fault);
#endif
@


1.1.1.7
log
@import gdb-1999-10-04 snapshot
@
text
@d5675 1
a5675 1
  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
@


1.1.1.8
log
@import gdb-1999-11-08 snapshot
@
text
@d2006 1
a2233 1
#ifdef UNIXWARE
d2235 1
a2235 1
#endif /* UNIXWARE */
d2316 1
a2316 1
#ifdef PROCFS_USE_READ_WRITE
a2317 1
#endif
a2383 1
#if defined (UNIXWARE) || defined (PROCFS_USE_READ_WRITE)	
a2384 1
#endif
a2915 1
#ifdef PROCFS_USE_READ_WRITE
a2916 1
#endif
d3253 1
a3253 1
#ifdef PROCFS_USE_READ_WRITE
a3254 1
#endif
a3287 1
#ifdef PROCFS_USE_READ_WRITE
a3288 1
#endif
a3449 1
#ifdef PROCFS_USE_READ_WRITE
d3451 1
a3451 1
#endif
d3519 1
a3785 1
#if defined (UNIXWARE) || defined (PROCFS_USE_READ_WRITE)	
a3786 1
#endif
a3846 1
#if defined (UNIXWARE) || defined (PROCFS_USE_READ_WRITE)	
a3847 1
#endif
a4793 1
#ifdef PROCFS_USE_READ_WRITE
a4794 1
#endif
a5118 1
#ifdef PROCFS_USE_READ_WRITE
a5119 1
#endif
a5194 1
#ifdef PROCFS_USE_READ_WRITE
a5195 1
#endif
a5475 1
#ifdef UNIXWARE
a5476 1
#endif
d5784 8
a5791 10
	{
	  if (procfs_read_status (pi))	/* alive */
	    return 1;
	  else
	    /* defunct (exited) */
	    {
	      close_proc_file (pi);
	      return 0;
	    }
	}
@


1.1.1.9
log
@import gdb-1999-12-21 snapshot
@
text
@a5901 3
#ifdef TIDGET
  procfs_ops.to_pid_to_str = procfs_pid_to_str;
#endif
@


1.1.1.10
log
@import gdb-2000-01-05 snapshot
@
text
@d2 3
a4 19
   Copyright 1999 Free Software Foundation, Inc.
   Written by Michael Snyder at Cygnus Solutions.
   Based on work by Fred Fish, Stu Grossman, Geoff Noer, and others.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation, 
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d6 1
a6 5
#include "defs.h"
#include "inferior.h"
#include "target.h"
#include "gdbcore.h"
#include "gdbcmd.h"
d8 4
a11 8
#if defined (NEW_PROC_API)
#define _STRUCTURED_PROC 1	/* Should be done by configure script. */
#endif

#include <sys/procfs.h>
#include <sys/fault.h>
#include <sys/syscall.h>
#include <sys/errno.h>
d13 4
a16 30
/* 
 * PROCFS.C
 *
 * This module provides the interface between GDB and the
 * /proc file system, which is used on many versions of Unix
 * as a means for debuggers to control other processes.
 * Examples of the systems that use this interface are:
 *   Irix
 *   Solaris
 *   OSF
 *   Unixware
 *
 * /proc works by immitating a file system: you open a simulated file
 * that represents the process you wish to interact with, and
 * perform operations on that "file" in order to examine or change
 * the state of the other process.
 *
 * The most important thing to know about /proc and this module
 * is that there are two very different interfaces to /proc:
 *   One that uses the ioctl system call, and
 *   another that uses read and write system calls.
 * This module has to support both /proc interfaces.  This means
 * that there are two different ways of doing every basic operation.
 *
 * In order to keep most of the code simple and clean, I have 
 * defined an interface "layer" which hides all these system calls.
 * An ifdef (NEW_PROC_API) determines which interface we are using,
 * and most or all occurrances of this ifdef should be confined to
 * this interface layer.
 */
d18 4
a22 3
/* Determine which /proc API we are using:
   The ioctl API defines PIOCSTATUS, while 
   the read/write (multiple fd) API never does.  */
d24 1
a24 4
#ifdef NEW_PROC_API
#include <sys/types.h>
#include <dirent.h>	/* opendir/readdir, for listing the LWP's */
#endif
d26 2
a27 3
#include <fcntl.h>	/* for O_RDONLY */
#include <unistd.h>	/* for "X_OK" */
#include "gdb_stat.h"	/* for struct stat */
d29 4
a32 1
/* =================== TARGET_OPS "MODULE" =================== */
a33 2
/*
 * This module defines the GDB target vector and its methods.
a35 19
static void procfs_open              PARAMS((char *, int));
static void procfs_attach            PARAMS ((char *, int));
static void procfs_detach            PARAMS ((char *, int));
static void procfs_resume            PARAMS ((int, int, enum target_signal));
static int  procfs_can_run           PARAMS ((void));
static void procfs_stop              PARAMS ((void));
static void procfs_files_info        PARAMS ((struct target_ops *));
static void procfs_fetch_registers   PARAMS ((int));
static void procfs_store_registers   PARAMS ((int));
static void procfs_notice_signals    PARAMS ((int));
static void procfs_prepare_to_store  PARAMS ((void));
static void procfs_kill_inferior     PARAMS ((void));
static void procfs_mourn_inferior    PARAMS ((void));
static void procfs_create_inferior   PARAMS ((char *, char *, char **));
static int  procfs_wait              PARAMS ((int, 
					       struct target_waitstatus *));
static int  procfs_xfer_memory       PARAMS ((CORE_ADDR, 
					       char *, int, int, 
					       struct target_ops *));
d37 1
a37 1
static int  procfs_thread_alive      PARAMS ((int));
d39 11
a49 2
void procfs_find_new_threads         PARAMS ((void));
char *procfs_pid_to_str              PARAMS ((int));
d51 5
a55 1
struct target_ops procfs_ops;		/* the target vector */
d57 3
a59 25
static void
init_procfs_ops ()
{
  procfs_ops.to_shortname          = "procfs";
  procfs_ops.to_longname           = "Unix /proc child process";
  procfs_ops.to_doc                = 
    "Unix /proc child process (started by the \"run\" command).";
  procfs_ops.to_open               = procfs_open;
  procfs_ops.to_can_run            = procfs_can_run;
  procfs_ops.to_create_inferior    = procfs_create_inferior;
  procfs_ops.to_kill               = procfs_kill_inferior;
  procfs_ops.to_mourn_inferior     = procfs_mourn_inferior;
  procfs_ops.to_attach             = procfs_attach;
  procfs_ops.to_detach             = procfs_detach;
  procfs_ops.to_wait               = procfs_wait;
  procfs_ops.to_resume             = procfs_resume;
  procfs_ops.to_prepare_to_store   = procfs_prepare_to_store;
  procfs_ops.to_fetch_registers    = procfs_fetch_registers;
  procfs_ops.to_store_registers    = procfs_store_registers;
  procfs_ops.to_xfer_memory        = procfs_xfer_memory;
  procfs_ops.to_insert_breakpoint  =  memory_insert_breakpoint;
  procfs_ops.to_remove_breakpoint  =  memory_remove_breakpoint;
  procfs_ops.to_notice_signals     = procfs_notice_signals;
  procfs_ops.to_files_info         = procfs_files_info;
  procfs_ops.to_stop               = procfs_stop;
d61 3
a63 5
  procfs_ops.to_terminal_init      = terminal_init_inferior;
  procfs_ops.to_terminal_inferior  = terminal_inferior;
  procfs_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  procfs_ops.to_terminal_ours      = terminal_ours;
  procfs_ops.to_terminal_info      = child_terminal_info;
d65 3
a67 3
  procfs_ops.to_find_new_threads   = procfs_find_new_threads;
  procfs_ops.to_thread_alive       = procfs_thread_alive;
  procfs_ops.to_pid_to_str         = procfs_pid_to_str;
d69 3
a71 7
  procfs_ops.to_has_execution      = 1;
  procfs_ops.to_has_stack          = 1;
  procfs_ops.to_has_registers      = 1;
  procfs_ops.to_stratum            = process_stratum;
  procfs_ops.to_has_thread_control = tc_schedlock;
  procfs_ops.to_magic              = OPS_MAGIC;
}
d73 3
a75 9
/* =================== END, TARGET_OPS "MODULE" =================== */

/*
 * Temporary debugging code:
 *
 * These macros allow me to trace the system calls that we make
 * to control the child process.  This is quite handy for comparing
 * with the older version of procfs.
 */
d77 2
a78 7
#ifdef TRACE_PROCFS
#ifdef NEW_PROC_API
extern  int   write_with_trace PARAMS ((int, void *, size_t, char *, int));
extern  off_t lseek_with_trace PARAMS ((int, off_t,  int,    char *, int));

#if 0
#define write(X,Y,Z)   write_with_trace (X, Y, Z, __FILE__, __LINE__)
d81 2
a82 4
#define lseek(X,Y,Z)   lseek_with_trace (X, Y, Z, __FILE__, __LINE__)
#else
extern  int ioctl_with_trace PARAMS ((int, long, void *, char *, int));
#define ioctl(X,Y,Z)   ioctl_with_trace (X, Y, Z, __FILE__, __LINE__)
a83 3
#define open(X,Y)      open_with_trace  (X, Y,    __FILE__, __LINE__)
#define close(X)       close_with_trace (X,       __FILE__, __LINE__)
#define wait(X)        wait_with_trace  (X,       __FILE__, __LINE__)
d85 2
a86 7
#if 0
#define PROCFS_NOTE(X) procfs_note      (X,       __FILE__, __LINE__)
#define PROC_PRETTYFPRINT_STATUS(X,Y,Z,T) \
proc_prettyfprint_status (X, Y, Z, T)
#else 
#define PROCFS_NOTE(X)
#define PROC_PRETTYFPRINT_STATUS(X,Y,Z,T)
d89 2
a90 3
#else
#define PROCFS_NOTE(X)
#define PROC_PRETTYFPRINT_STATUS(X,Y,Z,T)
d93 10
a102 14
     /* temp: */
#undef  PROCFS_NOTE
#define PROCFS_NOTE(X)
     /* suppress */


/*
 * World Unification:
 *
 * Put any typedefs, defines etc. here that are required for
 * the unification of code that handles different versions of /proc.
 */

#ifdef NEW_PROC_API		/* Solaris 7 && 8 method for watchpoints */
d104 1
a104 12
     enum { READ_WATCHFLAG  = WA_READ, 
	    WRITE_WATCHFLAG = WA_WRITE,
	    EXEC_WATCHFLAG  = WA_EXEC,
	    AFTER_WATCHFLAG = WA_TRAPAFTER
     };
#endif
#else				/* Irix method for watchpoints */
     enum { READ_WATCHFLAG  = MA_READ, 
	    WRITE_WATCHFLAG = MA_WRITE,
	    EXEC_WATCHFLAG  = MA_EXEC,
	    AFTER_WATCHFLAG = 0		/* trapafter not implemented */
     };
d106 5
d112 18
a129 51



/* =================== STRUCT PROCINFO "MODULE" =================== */

     /* FIXME: this comment will soon be out of date W.R.T. threads.  */

/* The procinfo struct is a wrapper to hold all the state information
   concerning a /proc process.  There should be exactly one procinfo
   for each process, and since GDB currently can debug only one
   process at a time, that means there should be only one procinfo.
   All of the LWP's of a process can be accessed indirectly thru the
   single process procinfo.

   However, against the day when GDB may debug more than one process,
   this data structure is kept in a list (which for now will hold no
   more than one member), and many functions will have a pointer to a
   procinfo as an argument.

   There will be a separate procinfo structure for use by the (not yet
   implemented) "info proc" command, so that we can print useful
   information about any random process without interfering with the
   inferior's procinfo information. */

#ifdef NEW_PROC_API
/* format strings for /proc paths */
# ifndef CTL_PROC_NAME_FMT
#  define MAIN_PROC_NAME_FMT   "/proc/%d"
#  define CTL_PROC_NAME_FMT    "/proc/%d/ctl"
#  define AS_PROC_NAME_FMT     "/proc/%d/as"
#  define MAP_PROC_NAME_FMT    "/proc/%d/map"
#  define STATUS_PROC_NAME_FMT "/proc/%d/status"
#  define MAX_PROC_NAME_SIZE sizeof("/proc/99999/lwp/8096/lstatus")
# endif
/* the name of the proc status struct depends on the implementation */
typedef pstatus_t   gdb_prstatus_t;
typedef lwpstatus_t gdb_lwpstatus_t;
#else /* ! NEW_PROC_API */
/* format strings for /proc paths */
# ifndef CTL_PROC_NAME_FMT
#  define MAIN_PROC_NAME_FMT   "/proc/%05d"
#  define CTL_PROC_NAME_FMT    "/proc/%05d"
#  define AS_PROC_NAME_FMT     "/proc/%05d"
#  define MAP_PROC_NAME_FMT    "/proc/%05d"
#  define STATUS_PROC_NAME_FMT "/proc/%05d"
#  define MAX_PROC_NAME_SIZE sizeof("/proc/ttttppppp")
# endif
/* the name of the proc status struct depends on the implementation */
typedef prstatus_t gdb_prstatus_t;
typedef prstatus_t gdb_lwpstatus_t;
#endif /* NEW_PROC_API */
d138 1
a138 1
  typedef GDB_GREGSET_TYPE gdb_gregset_t;
d140 1
a140 1
  typedef gregset_t gdb_gregset_t;
d144 1
a144 1
  typedef GDB_FPREGSET_TYPE gdb_fpregset_t;
d146 1
a146 1
  typedef fpregset_t gdb_fpregset_t;
a148 3
/* The PIDs that we pass to and from GDB will be composed from
   the actual PID plus the LWPID.  These macros will be used to
   compose and decompose them.  */
d150 8
a157 3
#ifndef PIDGET
#define PIDGET(PID)		(((PID) & 0xffff))
#endif
d159 2
a160 2
#ifndef TIDGET
#define TIDGET(PID)		(((PID) & 0x7fffffff) >> 16)
d163 17
a179 3
#ifndef MERGEPID
#define MERGEPID(PID, TID)	(((PID) & 0xffff) | ((TID) << 16))
#endif
d181 6
a186 4
typedef struct procinfo {
  struct procinfo *next;
  int pid;			/* Process ID    */
  int tid;			/* Thread/LWP id */
d188 6
a193 3
  /* process state */
  int was_stopped;
  int ignore_next_sigstop;
d195 6
a200 3
  /* The following four fd fields may be identical, or may contain 
     several different fd's, depending on the version of /proc
     (old ioctl or new read/write).  */
d202 6
a207 10
  int ctl_fd;			/* File descriptor for /proc control file */
  /*
   * The next three file descriptors are actually only needed in the
   * read/write, multiple-file-descriptor implemenation (NEW_PROC_API).
   * However, to avoid a bunch of #ifdefs in the code, we will use 
   * them uniformly by (in the case of the ioctl single-file-descriptor
   * implementation) filling them with copies of the control fd.
   */
  int status_fd;		/* File descriptor for /proc status file */
  int as_fd;			/* File descriptor for /proc as file */
d209 6
a214 1
  char pathname[MAX_PROC_NAME_SIZE];	/* Pathname to /proc entry */
d216 6
a221 5
  fltset_t saved_fltset;	/* Saved traced hardware fault set */
  sigset_t saved_sigset;	/* Saved traced signal set */
  sigset_t saved_sighold;	/* Saved held signal set */
  sysset_t saved_exitset;	/* Saved traced system call exit set */
  sysset_t saved_entryset;	/* Saved traced system call entry set */
d223 8
a230 1
  gdb_prstatus_t prstatus;	/* Current process status info */
d232 46
a277 5
#ifndef NEW_PROC_API
  gdb_fpregset_t fpregset;	/* Current floating point registers */
#endif
  
  struct procinfo *thread_list;
d279 6
a284 5
  int status_valid : 1;
  int gregs_valid  : 1;
  int fpregs_valid : 1;
  int threads_valid: 1;
} procinfo;
d286 2
a287 1
static char errmsg[128];	/* shared error msg buffer */
d289 52
a340 1
/* Function prototypes for procinfo module: */
d342 1
a342 8
static procinfo *find_procinfo_or_die PARAMS ((int pid, int tid));
static procinfo *find_procinfo        PARAMS ((int pid, int tid));
static procinfo *create_procinfo      PARAMS ((int pid, int tid));
static void      destroy_procinfo     PARAMS ((procinfo *p));
static void      dead_procinfo        PARAMS ((procinfo *p, 
					       char *msg, int killp));
static int       open_procinfo_files  PARAMS ((procinfo *p, int which));
static void      close_procinfo_files PARAMS ((procinfo *p));
d344 28
a371 2
/* The head of the procinfo list: */
static procinfo * procinfo_list;
d373 1
a373 7
/*
 * Function: find_procinfo
 *
 * Search the procinfo list.
 *
 * Returns: pointer to procinfo, or NULL if not found.
 */
d375 1
a375 4
static procinfo * 
find_procinfo (pid, tid)
     int pid;
     int tid;
d377 35
a411 1
  procinfo *pi;
d413 2
a414 3
  for (pi = procinfo_list; pi; pi = pi->next)
    if (pi->pid == pid)
      break;
d416 223
a638 14
  if (pi)
    if (tid)
      {
	/* Don't check threads_valid.  If we're updating the
	   thread_list, we want to find whatever threads are already
	   here.  This means that in general it is the caller's
	   responsibility to check threads_valid and update before
	   calling find_procinfo, if the caller wants to find a new
	   thread. */

	for (pi = pi->thread_list; pi; pi = pi->next)
	  if (pi->tid == tid)
	    break;
      }
d640 1
a640 2
  return pi;
}
d642 1
a642 5
/*
 * Function: find_procinfo_or_die
 *
 * Calls find_procinfo, but errors on failure.
 */
d644 1
a644 6
static procinfo *
find_procinfo_or_die (pid, tid)
     int pid;
     int tid;
{
  procinfo *pi = find_procinfo (pid, tid);
d646 1
a646 8
  if (pi == NULL)
    if (tid)
      error ("procfs: couldn't find pid %d (kernel thread %d) in procinfo list.", 
	     pid, tid);
    else
      error ("procfs: couldn't find pid %d in procinfo list.", pid);
  return pi;
}
d648 1
a648 12
/*
 * Function: open_procinfo_files
 *
 * Open the file descriptor for the process or LWP.
 * ifdef NEW_PROC_API, we only open the control file descriptor;
 * the others are opened lazily as needed.
 * else (if not NEW_PROC_API), there is only one real
 * file descriptor, but we keep multiple copies of it so that
 * the code that uses them does not have to be #ifdef'd.
 *
 * Return: file descriptor, or zero for failure.
 */
d650 1
a650 1
enum { FD_CTL, FD_STATUS, FD_AS };
d652 1
a652 110
static int
open_procinfo_files (pi, which)
     procinfo *pi;
     int       which;
{
  char tmp[MAX_PROC_NAME_SIZE];
  int  fd;

  /* 
   * This function is getting ALMOST long enough to break up into several.
   * Here is some rationale:
   *
   * NEW_PROC_API (Solaris 2.6, Solaris 2.7, Unixware):
   *   There are several file descriptors that may need to be open 
   *   for any given process or LWP.  The ones we're intereted in are:
   *     - control	 (ctl)	  write-only	change the state
   *     - status	 (status) read-only	query the state
   *     - address space (as)     read/write	access memory
   *     - map           (map)    read-only     virtual addr map
   *   Most of these are opened lazily as they are needed.
   *   The pathnames for the 'files' for an LWP look slightly 
   *   different from those of a first-class process:
   *     Pathnames for a process (<proc-id>):
   *       /proc/<proc-id>/ctl
   *       /proc/<proc-id>/status
   *       /proc/<proc-id>/as
   *       /proc/<proc-id>/map
   *     Pathnames for an LWP (lwp-id):
   *       /proc/<proc-id>/lwp/<lwp-id>/lwpctl
   *       /proc/<proc-id>/lwp/<lwp-id>/lwpstatus
   *   An LWP has no map or address space file descriptor, since
   *   the memory map and address space are shared by all LWPs.
   *
   * Everyone else (Solaris 2.5, Irix, OSF)
   *   There is only one file descriptor for each process or LWP.
   *   For convenience, we copy the same file descriptor into all
   *   three fields of the procinfo struct (ctl_fd, status_fd, and
   *   as_fd, see NEW_PROC_API above) so that code that uses them
   *   doesn't need any #ifdef's.  
   *     Pathname for all:
   *       /proc/<proc-id>
   *
   *   Solaris 2.5 LWP's:
   *     Each LWP has an independent file descriptor, but these 
   *     are not obtained via the 'open' system call like the rest:
   *     instead, they're obtained thru an ioctl call (PIOCOPENLWP)
   *     to the file descriptor of the parent process.
   *
   *   OSF threads:
   *     These do not even have their own independent file descriptor.
   *     All operations are carried out on the file descriptor of the
   *     parent process.  Therefore we just call open again for each
   *     thread, getting a new handle for the same 'file'.
   */

#ifdef NEW_PROC_API
  /*
   * In this case, there are several different file descriptors that
   * we might be asked to open.  The control file descriptor will be
   * opened early, but the others will be opened lazily as they are
   * needed.
   */

  strcpy (tmp, pi->pathname);
  switch (which) {	/* which file descriptor to open? */
  case FD_CTL:
    if (pi->tid)
      strcat (tmp, "/lwpctl");
    else
      strcat (tmp, "/ctl");
    fd = open (tmp, O_WRONLY);
    if (fd <= 0)
      return 0;		/* fail */
    pi->ctl_fd = fd;
    break;
  case FD_AS:
    if (pi->tid)
      return 0;		/* there is no 'as' file descriptor for an lwp */
    strcat (tmp, "/as");
    fd = open (tmp, O_RDWR);
    if (fd <= 0)
      return 0;		/* fail */
    pi->as_fd = fd;
    break;
  case FD_STATUS:
    if (pi->tid)
      strcat (tmp, "/lwpstatus");
    else
      strcat (tmp, "/status");
    fd = open (tmp, O_RDONLY);
    if (fd <= 0)
      return 0;		/* fail */
    pi->status_fd = fd;
    break;
  default:
    return 0;		/* unknown file descriptor */
  }
#else  /* not NEW_PROC_API */
  /*
   * In this case, there is only one file descriptor for each procinfo
   * (ie. each process or LWP).  In fact, only the file descriptor for
   * the process can actually be opened by an 'open' system call.
   * The ones for the LWPs have to be obtained thru an IOCTL call 
   * on the process's file descriptor. 
   *
   * For convenience, we copy each procinfo's single file descriptor
   * into all of the fields occupied by the several file descriptors 
   * of the NEW_PROC_API implementation.  That way, the code that uses
   * them can be written without ifdefs.
   */
d654 1
d656 1
a656 15
#ifdef PIOCTSTATUS	/* OSF */
  if ((fd = open (pi->pathname, O_RDWR)) == 0) /* Only one FD; just open it. */
    return 0;
#else			/* Sol 2.5, Irix, other? */
  if (pi->tid == 0)	/* Master procinfo for the process */
    {
      fd = open (pi->pathname, O_RDWR);
      if (fd <= 0)
	return 0;	/* fail */
    }
  else			/* LWP thread procinfo */
    {
#ifdef PIOCOPENLWP	/* Sol 2.5, thread/LWP */
      procinfo *process;
      int lwpid = pi->tid;
d658 1
a658 3
      /* Find the procinfo for the entire process. */
      if ((process = find_procinfo (pi->pid, 0)) == NULL)
	return 0;	/* fail */
d660 1
a660 10
      /* Now obtain the file descriptor for the LWP. */
      if ((fd = ioctl (process->ctl_fd, PIOCOPENLWP, &lwpid)) <= 0)
	return 0;	/* fail */
#else			/* Irix, other? */
      return 0;		/* Don't know how to open threads */
#endif	/* Sol 2.5 PIOCOPENLWP */
    }
#endif	/* OSF     PIOCTSTATUS */
  pi->ctl_fd = pi->as_fd = pi->status_fd = fd;
#endif	/* NEW_PROC_API */
d662 1
a662 2
  return 1;		/* success */
}
d664 1
a664 8
/*
 * Function: create_procinfo
 *
 * Allocate a data structure and link it into the procinfo list.
 * (First tries to find a pre-existing one (FIXME: why???)
 *
 * Return: pointer to new procinfo struct.
 */
d666 1
a666 6
static procinfo *
create_procinfo (pid, tid)
     int pid;
     int tid;
{
  procinfo *pi, *parent;
d668 1
a668 2
  if (pi = find_procinfo (pid, tid))
    return pi;			/* Already exists, nothing to do. */
d670 15
a684 30
  /* find parent before doing malloc, to save having to cleanup */
  if (tid != 0)
    parent = find_procinfo_or_die (pid, 0);	/* FIXME: should I
						   create it if it
						   doesn't exist yet? */

  pi = (procinfo *) xmalloc (sizeof (procinfo));
  memset (pi, 0, sizeof (procinfo));
  pi->pid = pid;
  pi->tid = tid;

  /* Chain into list.  */
  if (tid == 0)
    {
      sprintf (pi->pathname, MAIN_PROC_NAME_FMT, pid);
      pi->next = procinfo_list;
      procinfo_list = pi;
    }
  else
    {
#ifdef NEW_PROC_API
      sprintf (pi->pathname, "/proc/%05d/lwp/%d", pid, tid);
#else
      sprintf (pi->pathname, MAIN_PROC_NAME_FMT, pid);
#endif
      pi->next = parent->thread_list;
      parent->thread_list = pi;
    }
  return pi;
}
d686 1
a686 5
/*
 * Function: close_procinfo_files
 *
 * Close all file descriptors associated with the procinfo
 */
d688 1
a688 14
static void
close_procinfo_files (pi)
     procinfo *pi;
{
  if (pi->ctl_fd > 0)
    close (pi->ctl_fd);
#ifdef NEW_PROC_API
  if (pi->as_fd > 0)
    close (pi->as_fd);
  if (pi->status_fd > 0)
    close (pi->status_fd);
#endif
  pi->ctl_fd = pi->as_fd = pi->status_fd = 0;
}
d690 1
a690 5
/*
 * Function: destroy_procinfo
 *
 * Destructor function.  Close, unlink and deallocate the object.
 */
d692 1
a692 17
static void
destroy_one_procinfo (list, pi)
     procinfo **list;
     procinfo  *pi;
{
  procinfo *ptr;

  /* Step one: unlink the procinfo from its list */
  if (pi == *list)
    *list = pi->next;
  else 
    for (ptr = *list; ptr; ptr = ptr->next)
      if (ptr->next == pi)
	{
	  ptr->next =  pi->next;
	  break;
	}
d694 1
a694 2
  /* Step two: close any open file descriptors */
  close_procinfo_files (pi);
d696 1
a696 3
  /* Step three: free the memory. */
  free (pi);
}
d698 1
a698 5
static void
destroy_procinfo (pi)
     procinfo *pi;
{
  procinfo *tmp;
d700 1
a700 14
  if (pi->tid != 0)	/* destroy a thread procinfo */
    {
      tmp = find_procinfo (pi->pid, 0);	/* find the parent process */
      destroy_one_procinfo (&tmp->thread_list, pi);
    }
  else			/* destroy a process procinfo and all its threads */
    {
      /* First destroy the children, if any; */
      while (pi->thread_list != NULL)
	destroy_one_procinfo (&pi->thread_list, pi->thread_list);
      /* Then destroy the parent.  Genocide!!!  */
      destroy_one_procinfo (&procinfo_list, pi);
    }
}
d702 1
a702 1
enum { NOKILL, KILL };
d704 1
a704 7
/*
 * Function: dead_procinfo
 *
 * To be called on a non_recoverable error for a procinfo.
 * Prints error messages, optionally sends a SIGKILL to the process,
 * then destroys the data structure.
 */
d706 1
a706 7
static void
dead_procinfo (pi, msg, kill_p)
     procinfo *pi;
     char     *msg;
     int       kill_p;
{
  char procfile[80];
d708 1
a708 11
  if (pi->pathname)
    {
      print_sys_errmsg (pi->pathname, errno);
    }
  else
    {
      sprintf (procfile, "process %d", pi->pid);
      print_sys_errmsg (procfile, errno);
    }
  if (kill_p == KILL)
    kill (pi->pid, SIGKILL);
d710 2
a711 3
  destroy_procinfo (pi);
  error (msg);
}
d713 1
a713 1
/* =================== END, STRUCT PROCINFO "MODULE" =================== */
d715 1
a715 1
/* ===================  /proc  "MODULE" =================== */
d717 1
a717 59
/*
 * This "module" is the interface layer between the /proc system API
 * and the gdb target vector functions.  This layer consists of 
 * access functions that encapsulate each of the basic operations
 * that we need to use from the /proc API.
 *
 * The main motivation for this layer is to hide the fact that
 * there are two very different implementations of the /proc API.
 * Rather than have a bunch of #ifdefs all thru the gdb target vector
 * functions, we do our best to hide them all in here.
 */

int proc_get_status PARAMS ((procinfo *pi));
long proc_flags     PARAMS ((procinfo *pi));
int proc_why        PARAMS ((procinfo *pi));
int proc_what       PARAMS ((procinfo *pi));
int proc_set_run_on_last_close   PARAMS ((procinfo *pi));
int proc_unset_run_on_last_close PARAMS ((procinfo *pi));
int proc_set_inherit_on_fork     PARAMS ((procinfo *pi));
int proc_unset_inherit_on_fork   PARAMS ((procinfo *pi));
int proc_set_async            PARAMS ((procinfo *pi));
int proc_unset_async          PARAMS ((procinfo *pi));
int proc_stop_process         PARAMS ((procinfo *pi));
int proc_trace_signal         PARAMS ((procinfo *pi, int signo));
int proc_ignore_signal        PARAMS ((procinfo *pi, int signo));
int proc_clear_current_fault  PARAMS ((procinfo *pi));
int proc_set_current_signal   PARAMS ((procinfo *pi, int signo));
int proc_clear_current_signal PARAMS ((procinfo *pi));
int proc_set_gregs            PARAMS ((procinfo *pi));
int proc_set_fpregs           PARAMS ((procinfo *pi));
int proc_wait_for_stop        PARAMS ((procinfo *pi));
int proc_run_process          PARAMS ((procinfo *pi, int step, int signo));
int proc_kill                 PARAMS ((procinfo *pi, int signo));
int proc_parent_pid           PARAMS ((procinfo *pi));
int proc_get_nthreads         PARAMS ((procinfo *pi));
int proc_get_current_thread   PARAMS ((procinfo *pi));
int proc_set_held_signals     PARAMS ((procinfo *pi, sigset_t *sighold));
int proc_set_traced_sysexit   PARAMS ((procinfo *pi, sysset_t *sysset));
int proc_set_traced_sysentry  PARAMS ((procinfo *pi, sysset_t *sysset));
int proc_set_traced_faults    PARAMS ((procinfo *pi, fltset_t *fltset));
int proc_set_traced_signals   PARAMS ((procinfo *pi, sigset_t *sigset));

int proc_update_threads       PARAMS ((procinfo *pi));
int proc_iterate_over_threads PARAMS ((procinfo *pi,
				       int     (*func) PARAMS ((procinfo *, 
								procinfo *, 
								void *)),
				       void     *ptr));

gdb_gregset_t   *proc_get_gregs     PARAMS ((procinfo *pi));
gdb_fpregset_t  *proc_get_fpregs    PARAMS ((procinfo *pi));
sysset_t *proc_get_traced_sysexit   PARAMS ((procinfo *pi, sysset_t *save));
sysset_t *proc_get_traced_sysentry  PARAMS ((procinfo *pi, sysset_t *save));
fltset_t *proc_get_traced_faults    PARAMS ((procinfo *pi, fltset_t *save));
sigset_t *proc_get_traced_signals   PARAMS ((procinfo *pi, sigset_t *save));
sigset_t *proc_get_held_signals     PARAMS ((procinfo *pi, sigset_t *save));
sigset_t *proc_get_pending_signals  PARAMS ((procinfo *pi, sigset_t *save));
struct sigaction *proc_get_signal_actions PARAMS ((procinfo *pi, 
						   struct sigaction *save));
d719 1
a719 2
void proc_warn  PARAMS ((procinfo *pi, char *func, int line));
void proc_error PARAMS ((procinfo *pi, char *func, int line));
d721 1
a721 9
void
proc_warn (pi, func, line)
     procinfo *pi;
     char     *func;
     int      line;
{
  sprintf (errmsg, "procfs: %s line %d, %s", func, line, pi->pathname);
  print_sys_errmsg (errmsg, errno);
}
d723 1
a723 9
void
proc_error (pi, func, line)
     procinfo *pi;
     char     *func;
     int      line;
{
  sprintf (errmsg, "procfs: %s line %d, %s", func, line, pi->pathname);
  perror_with_name (errmsg);
}
d725 1
a725 11
/*
 * Function: proc_get_status
 *
 * Updates the status struct in the procinfo.
 * There is a 'valid' flag, to let other functions know when
 * this function needs to be called (so the status is only
 * read when it is needed).  The status file descriptor is
 * also only opened when it is needed.
 *
 * Return: non-zero for success, zero for failure.
 */
d727 1
a727 11
int
proc_get_status (pi)
     procinfo *pi;
{
  /* Status file descriptor is opened "lazily" */
  if (pi->status_fd == 0 &&
      open_procinfo_files (pi, FD_STATUS) == 0)
    {
      pi->status_valid = 0;
      return 0;
    }
d729 1
a729 46
#ifdef NEW_PROC_API
  if (lseek (pi->status_fd, 0, SEEK_SET) < 0)
    pi->status_valid = 0;			/* fail */
  else
    {
      /* Sigh... I have to read a different data structure, 
	 depending on whether this is a main process or an LWP. */
      if (pi->tid)
	pi->status_valid = (read (pi->status_fd, 
				  (char *) &pi->prstatus.pr_lwp, 
				  sizeof (lwpstatus_t))
			    == sizeof (lwpstatus_t));
      else
	{
	  pi->status_valid = (read (pi->status_fd, 
				    (char *) &pi->prstatus,
				    sizeof (gdb_prstatus_t))
			      == sizeof (gdb_prstatus_t));
#if 0 /*def UNIXWARE*/
	  if (pi->status_valid &&
	      (pi->prstatus.pr_lwp.pr_flags & PR_ISTOP) &&
	      pi->prstatus.pr_lwp.pr_why == PR_REQUESTED)
	    /* Unixware peculiarity -- read the damn thing again! */
	    pi->status_valid = (read (pi->status_fd, 
				      (char *) &pi->prstatus,
				      sizeof (gdb_prstatus_t))
				== sizeof (gdb_prstatus_t));
#endif /* UNIXWARE */
	}
    }
#else	/* ioctl method */
#ifdef PIOCTSTATUS	/* osf */
  if (pi->tid == 0)	/* main process */
    {
      /* Just read the danged status.  Now isn't that simple? */
      pi->status_valid = 
	(ioctl (pi->status_fd, PIOCSTATUS, &pi->prstatus) >= 0);
    }
  else
    {
      int win;
      struct {
	long pr_count;
	tid_t pr_error_thread;
	struct prstatus status;
      } thread_status;
d731 1
a731 15
      thread_status.pr_count = 1;
      thread_status.status.pr_tid = pi->tid;
      win = (ioctl (pi->status_fd, PIOCTSTATUS, &thread_status) >= 0);
      if (win)
	{
	  memcpy (&pi->prstatus, &thread_status.status, 
		  sizeof (pi->prstatus));
	  pi->status_valid = 1;
	}
    }
#else
  /* Just read the danged status.  Now isn't that simple? */
  pi->status_valid = (ioctl (pi->status_fd, PIOCSTATUS, &pi->prstatus) >= 0);
#endif
#endif
d733 1
a733 7
  if (pi->status_valid)
    {
      PROC_PRETTYFPRINT_STATUS (proc_flags (pi), 
				proc_why (pi),
				proc_what (pi), 
				proc_get_current_thread (pi));
    }
d735 1
a735 9
  /* The status struct includes general regs, so mark them valid too */
  pi->gregs_valid  = pi->status_valid;
#ifdef NEW_PROC_API
  /* In the read/write multiple-fd model, 
     the status struct includes the fp regs too, so mark them valid too */
  pi->fpregs_valid = pi->status_valid;
#endif
  return pi->status_valid;	/* True if success, false if failure. */
}
d737 1
a737 5
/*
 * Function: proc_flags
 *
 * returns the process flags (pr_flags field).
 */ 
d739 1
a739 7
long
proc_flags (pi)
     procinfo *pi;
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;	/* FIXME: not a good failure value (but what is?) */
d741 1
a741 6
#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_flags;
#else
  return pi->prstatus.pr_flags;
#endif
}
d743 1
a743 5
/*
 * Function: proc_why
 *
 * returns the pr_why field (why the process stopped).
 */
d745 1
a745 7
int
proc_why (pi)
     procinfo *pi;
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;	/* FIXME: not a good failure value (but what is?) */
d747 3
a749 6
#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_why;
#else
  return pi->prstatus.pr_why;
#endif
}
d751 2
a752 5
/*
 * Function: proc_what
 *
 * returns the pr_what field (details of why the process stopped).
 */
d754 3
a756 7
int
proc_what (pi)
     procinfo *pi;
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;	/* FIXME: not a good failure value (but what is?) */
d758 2
a759 6
#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_what;
#else
  return pi->prstatus.pr_what;
#endif
}
d761 2
a762 6
#ifndef PIOCSSPCACT	/* The following is not supported on OSF.  */
/*
 * Function: proc_nsysarg
 *
 * returns the pr_nsysarg field (number of args to the current syscall).
 */
d764 1
a764 14
int
proc_nsysarg (pi)
     procinfo *pi;
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;
  
#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_nsysarg;
#else
  return pi->prstatus.pr_nsysarg;
#endif
}
d766 1
a766 5
/*
 * Function: proc_sysargs
 *
 * returns the pr_sysarg field (pointer to the arguments of current syscall).
 */
d768 3
a770 12
long *
proc_sysargs (pi)
     procinfo *pi;
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;
  
#ifdef NEW_PROC_API
  return (long *) &pi->prstatus.pr_lwp.pr_sysarg;
#else
  return (long *) &pi->prstatus.pr_sysarg;
a771 1
}
d773 3
a775 5
/*
 * Function: proc_syscall
 *
 * returns the pr_syscall field (id of current syscall if we are in one).
 */
d777 2
a778 15
int
proc_syscall (pi)
     procinfo *pi;
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;
  
#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_syscall;
#else
  return pi->prstatus.pr_syscall;
#endif
}
#endif /* PIOCSSPCACT */
d780 1
a780 5
/*
 * Function: proc_cursig:
 *
 * returns the pr_cursig field (current signal).
 */
d782 6
a787 6
long
proc_cursig (struct procinfo *pi)
{
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;	/* FIXME: not a good failure value (but what is?) */
d789 2
a790 6
#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_cursig;
#else
  return pi->prstatus.pr_cursig;
#endif
}
d792 1
a792 30
/*
 * Function: proc_modify_flags 
 *
 *  === I appologize for the messiness of this function. 
 *  === This is an area where the different versions of
 *  === /proc are more inconsistent than usual.     MVS
 *
 * Set or reset any of the following process flags:
 *    PR_FORK	-- forked child will inherit trace flags
 *    PR_RLC	-- traced process runs when last /proc file closed.
 *    PR_ASYNC	-- LWP's get to run/stop independently.
 *
 * There are three methods for doing this function:
 * 1) Newest: read/write [PCSET/PCRESET/PCUNSET]
 *    [Sol6, Sol7, UW]
 * 2) Middle: PIOCSET/PIOCRESET
 *    [Irix, Sol5]
 * 3) Oldest: PIOCSFORK/PIOCRFORK/PIOCSRLC/PIOCRRLC
 *    [OSF, Sol5]
 *
 * Note: Irix does not define PR_ASYNC.
 * Note: OSF is the only one that can ONLY use the oldest method.
 *
 * Arguments: 
 *    pi   -- the procinfo
 *    flag -- one of PR_FORK, PR_RLC, or PR_ASYNC
 *    mode -- 1 for set, 0 for reset.
 *
 * Returns non-zero for success, zero for failure.
 */
d794 2
a795 1
enum { FLAG_RESET, FLAG_SET };
d797 1
a797 7
static int
proc_modify_flag (pi, flag, mode)
     procinfo *pi;
     long flag;
     long mode;
{
  long win = 0;		/* default to fail */
d799 1
a799 8
  /* 
   * These operations affect the process as a whole, and applying 
   * them to an individual LWP has the same meaning as applying them 
   * to the main process.  Therefore, if we're ever called with a 
   * pointer to an LWP's procinfo, let's substitute the process's 
   * procinfo and avoid opening the LWP's file descriptor 
   * unnecessarily.  
   */
d801 2
a802 2
  if (pi->pid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d804 1
a804 6
#ifdef NEW_PROC_API	/* Newest method: UnixWare and newer Solarii */
  /* First normalize the PCUNSET/PCRESET command opcode 
     (which for no obvious reason has a different definition
     from one operating system to the next...)  */
#ifdef  PCUNSET
#define GDBRESET PCUNSET
a805 5
#ifdef  PCRESET
#define GDBRESET PCRESET
#endif
  {
    long arg[2];
d807 3
a809 4
    if (mode == FLAG_SET)	/* Set the flag (RLC, FORK, or ASYNC) */
      arg[0] = PCSET;
    else			/* Reset the flag */
      arg[0] = GDBRESET;
d811 1
a811 13
    arg[1] = flag;
    win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else
#ifdef PIOCSET		/* Irix/Sol5 method */
  if (mode == FLAG_SET)	/* Set the flag (hopefully RLC, FORK, or ASYNC) */
    {
      win = (ioctl (pi->ctl_fd, PIOCSET, &flag)   >= 0);
    }
  else			/* Reset the flag */
    {
      win = (ioctl (pi->ctl_fd, PIOCRESET, &flag) >= 0);
    }
d813 1
a813 33
#else
#ifdef PIOCSRLC		/* Oldest method: OSF */
  switch (flag) {
  case PR_RLC:
    if (mode == FLAG_SET)	/* Set run-on-last-close */
      {
	win = (ioctl (pi->ctl_fd, PIOCSRLC, NULL) >= 0);
      }
    else			/* Clear run-on-last-close */
      {
	win = (ioctl (pi->ctl_fd, PIOCRRLC, NULL) >= 0);
      }
    break;
  case PR_FORK:
    if (mode == FLAG_SET)	/* Set inherit-on-fork */
      {
	win = (ioctl (pi->ctl_fd, PIOCSFORK, NULL) >= 0);
      }
    else			/* Clear inherit-on-fork */
      {
	win = (ioctl (pi->ctl_fd, PIOCRFORK, NULL) >= 0);
      }
    break;
  default:
    win = 0;		/* fail -- unknown flag (can't do PR_ASYNC) */
    break;
  }
#endif
#endif
#endif
#undef GDBRESET
  /* The above operation renders the procinfo's cached pstatus obsolete. */
  pi->status_valid = 0;
d815 1
a815 9
  if (!win)
    warning ("procfs: modify_flag failed to turn %s %s", 
	     flag == PR_FORK  ? "PR_FORK"  :
	     flag == PR_RLC   ? "PR_RLC"   :
#ifdef PR_ASYNC
	     flag == PR_ASYNC ? "PR_ASYNC" :
#endif
	     "<unknown flag>",
	     mode == FLAG_RESET ? "off" : "on");
d817 1
a817 2
  return win;
}
d819 3
a821 8
/*
 * Function: proc_set_run_on_last_close
 *
 * Set the run_on_last_close flag.
 * Process with all threads will become runnable
 * when debugger closes all /proc fds.
 *
 * Returns non-zero for success, zero for failure.
d824 4
a827 3
int
proc_set_run_on_last_close (pi)
     procinfo *pi;
d829 5
a833 2
  return proc_modify_flag (pi, PR_RLC, FLAG_SET);
}
d835 2
a836 9
/*
 * Function: proc_unset_run_on_last_close
 *
 * Reset the run_on_last_close flag.
 * Process will NOT become runnable
 * when debugger closes its file handles.
 *
 * Returns non-zero for success, zero for failure.
 */
d838 1
a838 5
int
proc_unset_run_on_last_close (pi)
     procinfo *pi;
{
  return proc_modify_flag (pi, PR_RLC, FLAG_RESET);
a841 8
 * Function: proc_set_inherit_on_fork
 *
 * Set inherit_on_fork flag.
 * If the process forks a child while we are registered for events
 * in the parent, then we will also recieve events from the child.
 *
 * Returns non-zero for success, zero for failure.
 */
d843 1
a843 6
int
proc_set_inherit_on_fork (pi)
     procinfo *pi;
{
  return proc_modify_flag (pi, PR_FORK, FLAG_SET);
}
d845 1
a845 9
/*
 * Function: proc_unset_inherit_on_fork
 *
 * Reset inherit_on_fork flag.
 * If the process forks a child while we are registered for events
 * in the parent, then we will NOT recieve events from the child.
 *
 * Returns non-zero for success, zero for failure.
 */
d847 1
a847 6
int
proc_unset_inherit_on_fork (pi)
     procinfo *pi;
{
  return proc_modify_flag (pi, PR_FORK, FLAG_RESET);
}
d849 1
a849 10
#ifdef PR_ASYNC
/*
 * Function: proc_set_async
 *
 * Set PR_ASYNC flag.
 * If one LWP stops because of a debug event (signal etc.), 
 * the remaining LWPs will continue to run.
 *
 * Returns non-zero for success, zero for failure.
 */
d851 1
a851 6
int
proc_set_async (pi)
     procinfo *pi;
{
  return proc_modify_flag (pi, PR_ASYNC, FLAG_SET);
}
d853 2
a854 8
/*
 * Function: proc_unset_async
 *
 * Reset PR_ASYNC flag.
 * If one LWP stops because of a debug event (signal etc.),
 * then all other LWPs will stop as well.
 *
 * Returns non-zero for success, zero for failure.
d857 1
a857 7
int
proc_unset_async (pi)
     procinfo *pi;
{
  return proc_modify_flag (pi, PR_ASYNC, FLAG_RESET);
}
#endif /* PR_ASYNC */
a859 5
 * Function: proc_stop_process
 *
 * Request the process/LWP to stop.  Does not wait.
 * Returns non-zero for success, zero for failure. 
 */
d861 3
a863 5
int
proc_stop_process (pi)
     procinfo *pi;
{
  int win;
d865 1
a865 4
  /*
   * We might conceivably apply this operation to an LWP, and
   * the LWP's ctl file descriptor might not be open.
   */
d867 1
a867 21
  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
    return 0;
  else
    {
#ifdef NEW_PROC_API
      int cmd = PCSTOP;
      win = (write (pi->ctl_fd, (char *) &cmd, sizeof (cmd)) == sizeof (cmd));
#else	/* ioctl method */
      win = (ioctl (pi->ctl_fd, PIOCSTOP, &pi->prstatus) >= 0);
      /* Note: the call also reads the prstatus.  */
      if (win)
	{
	  pi->status_valid = 1;
	  PROC_PRETTYFPRINT_STATUS (proc_flags (pi), 
				    proc_why (pi),
				    proc_what (pi), 
				    proc_get_current_thread (pi));
	}
#endif
    }
d869 1
a869 2
  return win;
}
d871 2
a872 5
/*
 * Function: proc_wait_for_stop
 *
 * Wait for the process or LWP to stop (block until it does).
 * Returns non-zero for success, zero for failure. 
d875 3
a877 3
int
proc_wait_for_stop (pi)
     procinfo *pi;
d879 11
a889 30
  int win;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    int cmd = PCWSTOP;
    win = (write (pi->ctl_fd, (char *) &cmd, sizeof (cmd)) == sizeof (cmd));
    /* We been runnin' and we stopped -- need to update status.  */
    pi->status_valid = 0;
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCWSTOP, &pi->prstatus) >= 0);
  /* Above call also refreshes the prstatus.  */
  if (win)
    {
      pi->status_valid = 1;
      PROC_PRETTYFPRINT_STATUS (proc_flags (pi), 
				proc_why (pi),
				proc_what (pi), 
				proc_get_current_thread (pi));
    }
d892 1
a892 1
  return win;
a895 44
 * Function: proc_run_process
 *
 * Make the process or LWP runnable.
 * Options (not all are implemented):
 *   - single-step
 *   - clear current fault
 *   - clear current signal
 *   - abort the current system call
 *   - stop as soon as finished with system call
 *   - (ioctl): set traced signal set
 *   - (ioctl): set held   signal set
 *   - (ioctl): set traced fault  set
 *   - (ioctl): set start pc (vaddr)
 * Always clear the current fault.
 * Clear the current signal if 'signo' is zero.
 *
 * Arguments:
 *   pi		the process or LWP to operate on.
 *   step	if true, set the process or LWP to trap after one instr.
 *   signo	if zero, clear the current signal if any.
 *		if non-zero, set the current signal to this one.
 *
 * Returns non-zero for success, zero for failure. 
 */

int
proc_run_process (pi, step, signo)
     procinfo *pi;
     int step;
     int signo;
{
  int win;
  int runflags;

  /*
   * We will probably have to apply this operation to individual threads,
   * so make sure the control file descriptor is open.
   */
  
  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
    {
      return 0;
    }
d897 1
a897 7
  runflags    = PRCFAULT;	/* always clear current fault  */
  if (step)
    runflags |= PRSTEP;
  if (signo == 0)
    runflags |= PRCSIG;
  else if (signo != -1)		/* -1 means do nothing W.R.T. signals */
    proc_set_current_signal (pi, signo);
d899 1
a899 3
#ifdef NEW_PROC_API
  {
    int cmd[2];
d901 1
a901 7
    cmd[0]  = PCRUN;
    cmd[1]  = runflags;
    win = (write (pi->ctl_fd, (char *) &cmd, sizeof (cmd)) == sizeof (cmd));
  }
#else	/* ioctl method */
  {
    prrun_t prrun;
d903 1
a903 5
    memset (&prrun, 0, sizeof (prrun));
    prrun.pr_flags  = runflags;
    win = (ioctl (pi->ctl_fd, PIOCRUN, &prrun) >= 0);
  }
#endif
d905 1
a905 2
  return win;
}
d907 2
a908 5
/*
 * Function: proc_set_traced_signals
 *
 * Register to trace signals in the process or LWP.
 * Returns non-zero for success, zero for failure. 
d911 3
a913 4
int
proc_set_traced_signals (pi, sigset)
     procinfo *pi;
     sigset_t *sigset;
d915 1
a915 1
  int win;
d917 7
a923 9
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d925 1
a925 7
#ifdef NEW_PROC_API
  {
    struct {
      int cmd;
      /* Use char array to avoid alignment issues.  */
      char sigset[sizeof (sigset_t)];
    } arg;
d927 10
a936 2
    arg.cmd = PCSTRACE;
    memcpy (&arg.sigset, sigset, sizeof (sigset_t));
d938 1
a938 7
    win = (write (pi->ctl_fd, (char *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCSTRACE, sigset) >= 0);
#endif
  /* The above operation renders the procinfo's cached pstatus obsolete. */
  pi->status_valid = 0;
d940 1
a940 4
  if (!win)
    warning ("procfs: set_traced_signals failed");
  return win;
}
d942 1
a942 6
/*
 * Function: proc_set_traced_faults
 *
 * Register to trace hardware faults in the process or LWP.
 * Returns non-zero for success, zero for failure. 
 */
d944 1
a944 6
int
proc_set_traced_faults (pi, fltset)
     procinfo *pi;
     fltset_t *fltset;
{
  int win;
d946 1
a946 9
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d948 1
a948 7
#ifdef NEW_PROC_API
  {
    struct {
      int cmd;
      /* Use char array to avoid alignment issues.  */
      char fltset[sizeof (fltset_t)];
    } arg;
d950 4
a953 2
    arg.cmd = PCSFAULT;
    memcpy (&arg.fltset, fltset, sizeof (fltset_t));
d955 10
a964 4
    win = (write (pi->ctl_fd, (char *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCSFAULT, fltset) >= 0);
d966 3
a968 4
  /* The above operation renders the procinfo's cached pstatus obsolete. */
  pi->status_valid = 0;

  return win;
a971 5
 * Function: proc_set_traced_sysentry
 *
 * Register to trace entry to system calls in the process or LWP.
 * Returns non-zero for success, zero for failure. 
 */
d973 1
a973 6
int
proc_set_traced_sysentry (pi, sysset)
     procinfo *pi;
     sysset_t *sysset;
{
  int win;
d975 1
a975 9
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d977 1
a977 7
#ifdef NEW_PROC_API
  {
    struct {
      int cmd;
      /* Use char array to avoid alignment issues.  */
      char sysset[sizeof (sysset_t)];
    } arg;
d979 1
a979 2
    arg.cmd = PCSENTRY;
    memcpy (&arg.sysset, sysset, sizeof (sysset_t));
d981 1
a981 10
    win = (write (pi->ctl_fd, (char *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCSENTRY, sysset) >= 0);
#endif
  /* The above operation renders the procinfo's cached pstatus obsolete. */
  pi->status_valid = 0;
     
  return win;
}
d983 3
a985 5
/*
 * Function: proc_set_traced_sysexit
 *
 * Register to trace exit from system calls in the process or LWP.
 * Returns non-zero for success, zero for failure. 
d988 3
a990 50
int
proc_set_traced_sysexit (pi, sysset)
     procinfo *pi;
     sysset_t *sysset;
{
  int win;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    struct {
      int cmd;
      /* Use char array to avoid alignment issues.  */
      char sysset[sizeof (sysset_t)];
    } arg;

    arg.cmd = PCSEXIT;
    memcpy (&arg.sysset, sysset, sizeof (sysset_t));

    win = (write (pi->ctl_fd, (char *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else	/* ioctl method */
  win = (ioctl (pi->ctl_fd, PIOCSEXIT, sysset) >= 0);
#endif
  /* The above operation renders the procinfo's cached pstatus obsolete. */
  pi->status_valid = 0;

  return win;
}

/*
 * Function: proc_set_held_signals
 *
 * Specify the set of blocked / held signals in the process or LWP.
 * Returns non-zero for success, zero for failure. 
 */

int
proc_set_held_signals (pi, sighold)
     procinfo *pi;
     sigset_t *sighold;
d992 3
a994 24
  int win;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    struct {
      int cmd;
      /* Use char array to avoid alignment issues.  */
      char hold[sizeof (sigset_t)];
    } arg;

    arg.cmd  = PCSHOLD;
    memcpy (&arg.hold, sighold, sizeof (sigset_t));
    win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
  }
d996 1
a996 1
  win = (ioctl (pi->ctl_fd, PIOCSHOLD, sighold) >= 0);
d998 3
a1000 4
  /* The above operation renders the procinfo's cached pstatus obsolete. */
  pi->status_valid = 0;

  return win;
a1003 5
 * Function: proc_get_pending_signals
 *
 * returns the set of signals that are pending in the process or LWP.
 * Will also copy the sigset if 'save' is non-zero.
 */
d1005 1
a1005 6
sigset_t *
proc_get_pending_signals (pi, save)
     procinfo *pi;
     sigset_t *save;
{
  sigset_t *ret = NULL;
d1007 1
a1007 9
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d1009 1
a1009 3
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;
d1011 1
a1011 7
#ifdef NEW_PROC_API
  ret = &pi->prstatus.pr_lwp.pr_lwppend;
#else
  ret = &pi->prstatus.pr_sigpend;
#endif
  if (save && ret)
    memcpy (save, ret, sizeof (sigset_t));
d1013 1
a1013 2
  return ret;
}
d1015 3
a1017 5
/*
 * Function: proc_get_signal_actions
 *
 * returns the set of signal actions.
 * Will also copy the sigactionset if 'save' is non-zero.
d1020 3
a1022 4
struct sigaction *
proc_get_signal_actions (pi, save)
     procinfo         *pi;
     struct sigaction *save;
d1024 5
a1028 18
  struct sigaction *ret = NULL;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

#ifdef NEW_PROC_API
  ret = &pi->prstatus.pr_lwp.pr_action;
d1030 2
a1031 1
  ret = &pi->prstatus.pr_action;
a1032 52
  if (save && ret)
    memcpy (save, ret, sizeof (struct sigaction));

  return ret;
}

/*
 * Function: proc_get_held_signals
 *
 * returns the set of signals that are held / blocked.
 * Will also copy the sigset if 'save' is non-zero.
 */

sigset_t *
proc_get_held_signals (pi, save)
     procinfo *pi;
     sigset_t *save;
{
  sigset_t *ret = NULL;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

#ifdef UNIXWARE
  ret = &pi->prstatus.pr_lwp.pr_context.uc_sigmask;
#else
  ret = &pi->prstatus.pr_lwp.pr_lwphold;
#endif /* UNIXWARE */
#else  /* not NEW_PROC_API */
  {
    static sigset_t sigheld;

    if (ioctl (pi->ctl_fd, PIOCGHOLD, &sigheld) >= 0)
      ret = &sigheld;
  }
#endif /* NEW_PROC_API */
  if (save && ret)
    memcpy (save, ret, sizeof (sigset_t));

  return ret;
d1035 2
a1036 11
/*
 * Function: proc_get_traced_signals
 *
 * returns the set of signals that are traced / debugged.
 * Will also copy the sigset if 'save' is non-zero.
 */

sigset_t *
proc_get_traced_signals (pi, save)
     procinfo *pi;
     sigset_t *save;
d1038 4
a1041 25
  sigset_t *ret = NULL;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;

  ret = &pi->prstatus.pr_sigtrace;
#else
  {
    static sigset_t sigtrace;

    if (ioctl (pi->ctl_fd, PIOCGTRACE, &sigtrace) >= 0)
      ret = &sigtrace;
  }
a1042 2
  if (save && ret)
    memcpy (save, ret, sizeof (sigset_t));
d1044 3
a1046 2
  return ret;
}
d1048 14
a1061 23
/*
 * Function: proc_trace_signal
 *
 * Add 'signo' to the set of signals that are traced.
 * Returns non-zero for success, zero for failure.
 */

int
proc_trace_signal (pi, signo)
     procinfo *pi;
     int signo;
{
  sigset_t temp;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d1063 1
a1063 1
  if (pi)
d1065 7
a1071 1
      if (proc_get_traced_signals (pi, &temp))
d1073 2
a1074 2
	  praddset (&temp, signo);
	  return proc_set_traced_signals (pi, &temp);
d1077 2
d1080 2
a1081 16
  return 0;	/* failure */
}

/*
 * Function: proc_ignore_signal
 *
 * Remove 'signo' from the set of signals that are traced.
 * Returns non-zero for success, zero for failure.
 */

int
proc_ignore_signal (pi, signo)
     procinfo *pi;
     int signo;
{
  sigset_t temp;
d1083 1
a1083 9
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d1085 1
a1085 1
  if (pi)
d1087 4
a1090 1
      if (proc_get_traced_signals (pi, &temp))
d1092 26
a1117 2
	  prdelset (&temp, signo);
	  return proc_set_traced_signals (pi, &temp);
d1119 3
d1123 1
d1125 1
a1125 1
  return 0;	/* failure */
a1128 12
 * Function: proc_get_traced_faults
 *
 * returns the set of hardware faults that are traced /debugged.
 * Will also copy the faultset if 'save' is non-zero.
 */

fltset_t *
proc_get_traced_faults (pi, save)
     procinfo *pi;
     fltset_t *save;
{
  fltset_t *ret = NULL;
d1130 1
a1130 9
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d1132 1
a1132 4
#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;
d1134 1
a1134 4
  ret = &pi->prstatus.pr_flttrace;
#else
  {
    static fltset_t flttrace;
d1136 1
a1136 6
    if (ioctl (pi->ctl_fd, PIOCGFAULT, &flttrace) >= 0)
      ret = &flttrace;
  }
#endif
  if (save && ret)
    memcpy (save, ret, sizeof (fltset_t));
d1138 1
a1138 2
  return ret;
}
d1140 2
a1141 5
/*
 * Function: proc_get_traced_sysentry
 *
 * returns the set of syscalls that are traced /debugged on entry.
 * Will also copy the syscall set if 'save' is non-zero.
d1144 4
a1147 4
sysset_t *
proc_get_traced_sysentry (pi, save)
     procinfo *pi;
     sysset_t *save;
d1149 1
a1149 1
  sysset_t *ret = NULL;
d1151 8
a1158 9
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d1160 1
a1160 4
#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;
d1162 5
a1166 13
  ret = &pi->prstatus.pr_sysentry;
#else
  {
    static sysset_t sysentry;

    if (ioctl (pi->ctl_fd, PIOCGENTRY, &sysentry) >= 0)
      ret = &sysentry;
  }
#endif
  if (save && ret)
    memcpy (save, ret, sizeof (sysset_t));

  return ret;
a1169 5
 * Function: proc_get_traced_sysexit
 *
 * returns the set of syscalls that are traced /debugged on exit.
 * Will also copy the syscall set if 'save' is non-zero.
 */
d1171 1
a1171 6
sysset_t *
proc_get_traced_sysexit (pi, save)
     procinfo *pi;
     sysset_t *save;
{
  sysset_t * ret = NULL;
d1173 1
a1173 9
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d1175 1
a1175 4
#ifdef NEW_PROC_API
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return NULL;
d1177 2
a1178 4
  ret = &pi->prstatus.pr_sysexit;
#else
  {
    static sysset_t sysexit;
d1180 1
a1180 6
    if (ioctl (pi->ctl_fd, PIOCGEXIT, &sysexit) >= 0)
      ret = &sysexit;
  }
#endif
  if (save && ret)
    memcpy (save, ret, sizeof (sysset_t));
d1182 4
a1185 2
  return ret;
}
d1187 3
a1189 6
/*
 * Function: proc_clear_current_fault
 *
 * The current fault (if any) is cleared; the associated signal
 * will not be sent to the process or LWP when it resumes.
 * Returns non-zero for success,  zero for failure.
d1192 5
a1196 3
int
proc_clear_current_fault (pi)
     procinfo *pi;
d1198 2
a1199 1
  int win;
d1201 8
a1208 9
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d1210 3
a1212 8
#ifdef NEW_PROC_API
  {
    int cmd = PCCFAULT;
    win = (write (pi->ctl_fd, (void *) &cmd, sizeof (cmd)) == sizeof (cmd));
  }
#else
  win = (ioctl (pi->ctl_fd, PIOCCFAULT, 0) >= 0);
#endif
d1214 11
a1224 1
  return win;
d1227 3
a1229 17
/*
 * Function: proc_set_current_signal
 *
 * Set the "current signal" that will be delivered next to the process.
 * NOTE: semantics are different from those of KILL.
 * This signal will be delivered to the process or LWP
 * immediately when it is resumed (even if the signal is held/blocked);
 * it will NOT immediately cause another event of interest, and will NOT
 * first trap back to the debugger.
 *
 * Returns non-zero for success,  zero for failure.
 */

int
proc_set_current_signal (pi, signo)
     procinfo *pi;
     int signo;
d1231 3
a1233 17
  int win;
  struct {
    int cmd;
    /* Use char array to avoid alignment issues.  */
    char sinfo[sizeof (struct siginfo)];
  } arg;
  struct siginfo *mysinfo;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d1235 15
a1249 108
#ifdef PROCFS_DONT_PIOCSSIG_CURSIG
  /* With Alpha OSF/1 procfs, the kernel gets really confused if it
   * receives a PIOCSSIG with a signal identical to the current signal,
   * it messes up the current signal. Work around the kernel bug. 
   */
  if (signo > 0 &&
      signo == proc_cursig (pi))
    return 1;           /* I assume this is a success? */
#endif

  /* The pointer is just a type alias.  */
  mysinfo = (struct siginfo *) &arg.sinfo;
  mysinfo->si_signo = signo;
  mysinfo->si_code  = 0;
  mysinfo->si_pid   = getpid ();       /* ?why? */
  mysinfo->si_uid   = getuid ();       /* ?why? */

#ifdef NEW_PROC_API
  arg.cmd = PCSSIG;
  win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg))  == sizeof (arg));
#else
  win = (ioctl (pi->ctl_fd, PIOCSSIG, (void *) &arg.sinfo) >= 0);
#endif

  return win;
}

/*
 * Function: proc_clear_current_signal
 *
 * The current signal (if any) is cleared, and
 * is not sent to the process or LWP when it resumes.
 * Returns non-zero for success,  zero for failure.
 */

int
proc_clear_current_signal (pi)
     procinfo *pi;
{
  int win;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

#ifdef NEW_PROC_API
  {
    struct {
      int cmd;
      /* Use char array to avoid alignment issues.  */
      char sinfo[sizeof (struct siginfo)];
    } arg;
    struct siginfo *mysinfo;

    arg.cmd = PCSSIG;
    /* The pointer is just a type alias.  */
    mysinfo = (struct siginfo *) &arg.sinfo;
    mysinfo->si_signo = 0;
    mysinfo->si_code  = 0;
    mysinfo->si_errno = 0;
    mysinfo->si_pid   = getpid ();       /* ?why? */
    mysinfo->si_uid   = getuid ();       /* ?why? */

    win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
  }
#else
  win = (ioctl (pi->ctl_fd, PIOCSSIG, 0) >= 0);
#endif

  return win;
}

/*
 * Function: proc_get_gregs
 *
 * Get the general registers for the process or LWP.
 * Returns non-zero for success, zero for failure.
 */

gdb_gregset_t *
proc_get_gregs (pi)
     procinfo *pi;
{
  if (!pi->status_valid || !pi->gregs_valid)
    if (!proc_get_status (pi))
      return NULL;

  /*
   * OK, sorry about the ifdef's.
   * There's three cases instead of two, because 
   * in this instance Unixware and Solaris/RW differ.
   */

#ifdef NEW_PROC_API
#ifdef UNIXWARE		/* ugh, a true architecture dependency */
  return &pi->prstatus.pr_lwp.pr_context.uc_mcontext.gregs;
#else	/* not Unixware */
  return &pi->prstatus.pr_lwp.pr_reg;
#endif	/* Unixware */
#else	/* not NEW_PROC_API */
  return &pi->prstatus.pr_reg;
#endif	/* NEW_PROC_API */
d1252 3
a1254 10
/*
 * Function: proc_get_fpregs
 *
 * Get the floating point registers for the process or LWP.
 * Returns non-zero for success, zero for failure.
 */

gdb_fpregset_t *
proc_get_fpregs (pi)
     procinfo *pi;
d1256 2
a1257 4
#ifdef NEW_PROC_API
  if (!pi->status_valid || !pi->fpregs_valid)
    if (!proc_get_status (pi))
      return NULL;
d1259 1
a1259 10
#ifdef UNIXWARE		/* a true architecture dependency */
  return &pi->prstatus.pr_lwp.pr_context.uc_mcontext.fpregs;
#else
  return &pi->prstatus.pr_lwp.pr_fpreg;
#endif	/* Unixware */

#else	/* not NEW_PROC_API */
  if (pi->fpregs_valid)
    return &pi->fpregset;	/* already got 'em */
  else
d1261 2
a1262 2
      if (pi->ctl_fd == 0 &&
	  open_procinfo_files (pi, FD_CTL) == 0)
d1264 2
a1265 43
	  return NULL;
	}
      else
	{
#ifdef PIOCTGFPREG
	  struct {
	    long pr_count;
	    tid_t pr_error_thread;
	    tfpregset_t thread_1;
	  } thread_fpregs;

	  thread_fpregs.pr_count = 1;
	  thread_fpregs.thread_1.tid = pi->tid;

	  if (pi->tid == 0 &&
	      ioctl (pi->ctl_fd, PIOCGFPREG, &pi->fpregset) >= 0)
	    {
	      pi->fpregs_valid = 1;
	      return &pi->fpregset;	/* got 'em now! */
	    }
	  else if (pi->tid != 0 &&
		   ioctl (pi->ctl_fd, PIOCTGFPREG, &thread_fpregs) >= 0)
	    {
	      memcpy (&pi->fpregset, &thread_fpregs.thread_1.pr_fpregs,
		      sizeof (pi->fpregset));
	      pi->fpregs_valid = 1;
	      return &pi->fpregset;	/* got 'em now! */
	    }
	  else
	    {
	      return NULL;
	    }
#else
	  if (ioctl (pi->ctl_fd, PIOCGFPREG, &pi->fpregset) >= 0)
	    {
	      pi->fpregs_valid = 1;
	      return &pi->fpregset;	/* got 'em now! */
	    }
	  else
	    {
	      return NULL;
	    }
#endif
d1268 5
a1272 1
#endif
a1275 5
 * Function: proc_set_gregs
 *
 * Write the general registers back to the process or LWP.
 * Returns non-zero for success, zero for failure.
 */
d1277 1
a1277 6
int
proc_set_gregs (pi)
     procinfo *pi;
{
  gdb_gregset_t *gregs;
  int win;
d1279 1
a1279 2
  if ((gregs = proc_get_gregs (pi)) == NULL)
    return 0;	/* get_regs has already warned */
d1281 1
a1281 13
  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
    {
      return 0;
    }
  else
    {
#ifdef NEW_PROC_API
      struct {
	int cmd;
	/* Use char array to avoid alignment issues.  */
	char gregs[sizeof (gdb_gregset_t)];
      } arg;
d1283 1
a1283 7
      arg.cmd   = PCSREG;
      memcpy (&arg.gregs, gregs, sizeof (arg.gregs));
      win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
#else
      win = (ioctl (pi->ctl_fd, PIOCSREG, gregs) >= 0);
#endif
    }
d1285 1
a1285 4
  /* Policy: writing the regs invalidates our cache. */
  pi->gregs_valid = 0;
  return win;
}
d1287 3
a1289 5
/*
 * Function: proc_set_fpregs
 *
 * Modify the floating point register set of the process or LWP.
 * Returns non-zero for success, zero for failure.
d1292 3
a1294 3
int
proc_set_fpregs (pi)
     procinfo *pi;
d1296 1
a1296 5
  gdb_fpregset_t *fpregs;
  int win;

  if ((fpregs = proc_get_fpregs (pi)) == NULL)
    return 0;		/* get_fpregs has already warned */
d1298 3
a1300 5
  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
    {
      return 0;
    }
d1303 2
a1304 32
#ifdef NEW_PROC_API
      struct {
	int cmd;
	/* Use char array to avoid alignment issues.  */
	char fpregs[sizeof (gdb_fpregset_t)];
      } arg;

      arg.cmd   = PCSFPREG;
      memcpy (&arg.fpregs, fpregs, sizeof (arg.fpregs));
      win = (write (pi->ctl_fd, (void *) &arg, sizeof (arg)) == sizeof (arg));
#else
#ifdef PIOCTSFPREG
      if (pi->tid == 0)
	win = (ioctl (pi->ctl_fd, PIOCSFPREG, fpregs) >= 0);
      else
	{
	  struct {
	    long pr_count;
	    tid_t pr_error_thread;
	    tfpregset_t thread_1;
	  } thread_fpregs;

	  thread_fpregs.pr_count = 1;
	  thread_fpregs.thread_1.tid = pi->tid;
	  memcpy (&thread_fpregs.thread_1.pr_fpregs, fpregs,
		  sizeof (*fpregs));
	  win = (ioctl (pi->ctl_fd, PIOCTSFPREG, &thread_fpregs) >= 0);
	}
#else
      win = (ioctl (pi->ctl_fd, PIOCSFPREG, fpregs) >= 0);
#endif	/* osf PIOCTSFPREG */
#endif	/* NEW_PROC_API */
a1305 4

  /* Policy: writing the regs invalidates our cache. */
  pi->fpregs_valid = 0;
  return win;
a1308 27
 * Function: proc_kill
 *
 * Send a signal to the proc or lwp with the semantics of "kill()".
 * Returns non-zero for success,  zero for failure.
 */

int
proc_kill (pi, signo)
     procinfo *pi;
     int signo;
{
  int win;

  /*
   * We might conceivably apply this operation to an LWP, and
   * the LWP's ctl file descriptor might not be open.
   */

  if (pi->ctl_fd == 0 &&
      open_procinfo_files (pi, FD_CTL) == 0)
    {
      return 0;
    }
  else
    {
#ifdef NEW_PROC_API
      int cmd[2];
d1310 1
a1310 9
      cmd[0] = PCKILL;
      cmd[1] = signo;
      win = (write (pi->ctl_fd, (char *) &cmd, sizeof (cmd)) == sizeof (cmd));
#else   /* ioctl method */
      /* FIXME: do I need the Alpha OSF fixups present in
	 procfs.c/unconditionally_kill_inferior?  Perhaps only for SIGKILL? */
      win = (ioctl (pi->ctl_fd, PIOCKILL, &signo) >= 0);
#endif
  }
d1312 1
a1312 2
  return win;
}
d1314 1
a1314 6
/*
 * Function: proc_parent_pid
 *
 * Find the pid of the process that started this one.
 * Returns the parent process pid, or zero.
 */
d1316 1
a1316 13
int
proc_parent_pid (pi)
     procinfo *pi;
{
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d1318 1
a1318 3
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;
d1320 3
a1322 2
  return pi->prstatus.pr_ppid;
}
d1324 1
d1326 2
a1327 3
/*
 * Function: proc_set_watchpoint
 *
d1330 2461
a3790 6
int
proc_set_watchpoint (pi, addr, len, wflags)
     procinfo *pi;
     void     *addr;
     int       len;
     int       wflags;
d3792 31
a3822 2
#if !defined (TARGET_HAS_HARDWARE_WATCHPOINTS)  
  return 0;
d3824 12
a3835 3
/* Horrible hack!  Detect Solaris 2.5, because this doesn't work on 2.5 */
#if defined (PIOCOPENLWP) || defined (UNIXWARE)	/* Solaris 2.5: bail out */
  return 0;
d3837 25
a3861 5
  struct {
    int cmd;
    char watch[sizeof (prwatch_t)];
  } arg;
  prwatch_t *pwatch;
d3863 4
a3866 7
  pwatch            = (prwatch_t *) &arg.watch;
  pwatch->pr_vaddr  = addr;
  pwatch->pr_size   = len;
  pwatch->pr_wflags = wflags;
#if defined(NEW_PROC_API) && defined (PCWATCH)
  arg.cmd = PCWATCH;
  return (write (pi->ctl_fd, &arg, sizeof (arg)) == sizeof (arg));
d3868 66
a3933 2
#if defined (PIOCSWATCH)
  return (ioctl (pi->ctl_fd, PIOCSWATCH, pwatch) >= 0);
d3935 1
a3935 1
  return 0;	/* Fail */
d3937 8
d3946 20
d3967 61
d4029 3
d4035 15
a4049 11
 * Function: proc_iterate_over_mappings
 *
 * Given a pointer to a function, call that function once for every
 * mapped address space in the process.  The callback function 
 * receives an open file descriptor for the file corresponding to
 * that mapped address space (if there is one), and the base address
 * of the mapped space.  Quit when the callback function returns a
 * nonzero value, or at teh end of the mappings.
 *
 * Returns: the first non-zero return value of the callback function,
 * or zero.
d4052 36
a4087 13
/* FIXME: it's probably a waste to cache this FD. 
   It doesn't get called that often... and if I open it
   every time, I don't need to lseek it.  */
int
proc_iterate_over_mappings (func)
     int (*func) PARAMS ((int, CORE_ADDR));
{
  struct prmap *map;
  procinfo *pi;
  int nmaps = 0, i;
  int funcstat = 0;
  int fd, map_fd;
  char pathname[MAX_PROC_NAME_SIZE];
d4089 1
a4089 1
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
d4091 2
a4092 5
#ifdef NEW_PROC_API
  /* Open map fd.  */
  sprintf (pathname, "/proc/%d/map", pi->pid);
  if ((map_fd = open (pathname, O_RDONLY)) < 0)
    proc_error (pi, "proc_iterate_over_mappings (open)", __LINE__);
d4094 1
a4094 2
  /* Make sure it gets closed again.  */
  make_cleanup ((make_cleanup_func) close, (void *) map_fd);
d4096 5
a4100 2
  /* Allocate space for mapping (lifetime only for this function). */
  map = alloca (sizeof (struct prmap));
d4102 13
a4114 8
  /* Now read the mappings from the file, 
     open a file descriptor for those that have a name, 
     and call the callback function.  */
  while (read (map_fd, 
	       (void *) map, 
	       sizeof (struct prmap)) == sizeof (struct prmap))
    {
      char name[MAX_PROC_NAME_SIZE + sizeof (map->pr_mapname)];
d4116 1
a4116 2
      if (map->pr_vaddr == 0 && map->pr_size == 0)
	break;		/* sanity */
d4118 1
a4118 14
      if (map->pr_mapname[0] == 0)
	{
	  fd = -1;	/* no map file */
	}
      else
	{
	  sprintf (name, "/proc/%d/object/%s", pi->pid, map->pr_mapname);
	  /* Note: caller's responsibility to close this fd!  */
	  fd = open (name, O_RDONLY);
	  /* Note: we don't test the above call for failure;
	     we just pass the FD on as given.  Sometimes there is 
	     no file, so the ioctl may return failure, but that's
	     not a problem.  */
	}
d4120 1
a4120 28
      /* Stop looping if the callback returns non-zero.  */
      if ((funcstat = (*func) (fd, (CORE_ADDR) map->pr_vaddr)) != 0)
	break;
    }  
#else
  /* Get the number of mapping entries.  */
  if (ioctl (pi->ctl_fd, PIOCNMAP, &nmaps) < 0)
    proc_error (pi, "proc_iterate_over_mappings (PIOCNMAP)", __LINE__);

  /* Allocate space for mappings (lifetime only this function).  */
  map = (struct prmap *) alloca ((nmaps + 1) * sizeof (struct prmap));

  /* Read in all the mappings.  */
  if (ioctl (pi->ctl_fd, PIOCMAP, map) < 0)
    proc_error (pi, "proc_iterate_over_mappings (PIOCMAP)", __LINE__);

  /* Now loop through the mappings, open an fd for each, and
     call the callback function.  */
  for (i = 0; 
       i < nmaps && map[i].pr_size != 0; 
       i++)
    {
      /* Note: caller's responsibility to close this fd!  */
      fd = ioctl (pi->ctl_fd, PIOCOPENM, &map[i].pr_vaddr);
      /* Note: we don't test the above call for failure;
	 we just pass the FD on as given.  Sometimes there is 
	 no file, so the ioctl may return failure, but that's
	 not a problem.  */
d4122 1
a4122 5
      /* Stop looping if the callback returns non-zero.  */
      if ((funcstat = (*func) (fd, (CORE_ADDR) map[i].pr_vaddr)) != 0)
	break;
    }
#endif
d4124 1
a4124 2
  return funcstat;
}
d4126 1
a4126 1
#ifdef TM_I386SOL2_H		/* Is it hokey to use this? */
d4128 4
a4131 1
#include <sys/sysi86.h>
a4132 11
/*
 * Function: proc_get_LDT_entry
 *
 * Inputs:
 *   procinfo *pi;
 *   int key;
 *
 * The 'key' is actually the value of the lower 16 bits of
 * the GS register for the LWP that we're interested in.
 *
 * Return: matching ssh struct (LDT entry).
d4135 3
a4137 4
struct ssd *
proc_get_LDT_entry (pi, key)
     procinfo *pi;
     int       key;
d4139 1
a4139 5
  static struct ssd *ldt_entry = NULL;
#ifdef NEW_PROC_API
  char pathname[MAX_PROC_NAME_SIZE];
  struct cleanup *old_chain = NULL;
  int  fd;
d4141 2
a4142 4
  /* Allocate space for one LDT entry.
     This alloc must persist, because we return a pointer to it.  */
  if (ldt_entry == NULL)
    ldt_entry = (struct ssd *) xmalloc (sizeof (struct ssd));
d4144 6
a4149 9
  /* Open the file descriptor for the LDT table.  */
  sprintf (pathname, "/proc/%d/ldt", pi->pid);
  if ((fd = open (pathname, O_RDONLY)) < 0)
    {
      proc_warn (pi, "proc_get_LDT_entry (open)", __LINE__);
      return NULL;
    }
  /* Make sure it gets closed again! */
  old_chain = make_cleanup ((make_cleanup_func) close, (void *) fd);
d4151 1
a4151 17
  /* Now 'read' thru the table, find a match and return it.  */
  while (read (fd, ldt_entry, sizeof (struct ssd)) == sizeof (struct ssd))
    {
      if (ldt_entry->sel == 0 &&
	  ldt_entry->bo  == 0 &&
	  ldt_entry->acc1 == 0 &&
	  ldt_entry->acc2 == 0)
	break;	/* end of table */
      /* If key matches, return this entry. */
      if (ldt_entry->sel == key)
	return ldt_entry;
    }
  /* Loop ended, match not found. */
  return NULL;
#else
  int nldt, i;
  static int nalloc = 0;
d4153 1
a4153 6
  /* Get the number of LDT entries.  */
  if (ioctl (pi->ctl_fd, PIOCNLDT, &nldt) < 0)
    {
      proc_warn (pi, "proc_get_LDT_entry (PIOCNLDT)", __LINE__);
      return NULL;
    }
d4155 3
a4157 3
  /* Allocate space for the number of LDT entries. */
  /* This alloc has to persist, 'cause we return a pointer to it. */
  if (nldt > nalloc)
d4159 9
a4167 10
      ldt_entry = (struct ssd *) 
	xrealloc (ldt_entry, (nldt + 1) * sizeof (struct ssd));
      nalloc = nldt;
    }
  
  /* Read the whole table in one gulp.  */
  if (ioctl (pi->ctl_fd, PIOCLDT, ldt_entry) < 0)
    {
      proc_warn (pi, "proc_get_LDT_entry (PIOCLDT)", __LINE__);
      return NULL;
d4169 1
d4171 6
a4176 4
  /* Search the table and return the (first) entry matching 'key'. */
  for (i = 0; i < nldt; i++)
    if (ldt_entry[i].sel == key)
      return &ldt_entry[i];
d4178 5
a4182 3
  /* Loop ended, match not found. */
  return NULL;
#endif
d4185 1
a4185 1
#endif /* TM_I386SOL2_H */
d4187 1
a4187 1
/* =============== END, non-thread part of /proc  "MODULE" =============== */
d4189 1
a4189 1
/* =================== Thread "MODULE" =================== */
d4191 1
a4191 2
/* NOTE: you'll see more ifdefs and duplication of functions here,
   since there is a different way to do threads on every OS.  */
d4193 1
a4193 5
/*
 * Function: proc_get_nthreads 
 *
 * Return the number of threads for the process 
 */
d4195 1
a4195 9
#if defined (PIOCNTHR) && defined (PIOCTLIST)
/*
 * OSF version
 */
int 
proc_get_nthreads (pi)
     procinfo *pi;
{
  int nthreads = 0;
d4197 6
a4202 2
  if (ioctl (pi->ctl_fd, PIOCNTHR, &nthreads) < 0)
    proc_warn (pi, "procfs: PIOCNTHR failed", __LINE__);
d4204 3
a4206 2
  return nthreads;
}
d4208 4
a4211 4
#else
#if defined (SYS_lwpcreate) || defined (SYS_lwp_create) /* FIXME: multiple */
/*
 * Solaris and Unixware version
d4213 7
a4219 3
int
proc_get_nthreads (pi)
     procinfo *pi;
d4221 1
a4221 3
  if (!pi->status_valid)
    if (!proc_get_status (pi))
      return 0;
d4223 4
a4226 10
  /*
   * NEW_PROC_API: only works for the process procinfo, 
   * because the LWP procinfos do not get prstatus filled in.
   */
#ifdef NEW_PROC_API  
  if (pi->tid != 0)	/* find the parent process procinfo */
    pi = find_procinfo_or_die (pi->pid, 0);
#endif
  return pi->prstatus.pr_nlwp;
}
d4228 2
d4231 1
a4231 10
/*
 * Default version
 */
int
proc_get_nthreads (pi)
     procinfo *pi;
{
  return 0;
}
#endif
d4234 6
a4239 8
/*
 * Function: proc_get_current_thread (LWP version)
 *
 * Return the ID of the thread that had an event of interest.
 * (ie. the one that hit a breakpoint or other traced event).
 * All other things being equal, this should be the ID of a
 * thread that is currently executing.
 */
d4241 6
a4246 17
#if defined (SYS_lwpcreate) || defined (SYS_lwp_create) /* FIXME: multiple */
/*
 * Solaris and Unixware version
 */
int
proc_get_current_thread (pi)
     procinfo *pi;
{
  /*
   * Note: this should be applied to the root procinfo for the process,
   * not to the procinfo for an LWP.  If applied to the procinfo for
   * an LWP, it will simply return that LWP's ID.  In that case, 
   * find the parent process procinfo.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);
d4248 5
a4252 2
  if (!pi->status_valid)
    if (!proc_get_status (pi))
d4254 1
d4256 11
a4266 6
#ifdef NEW_PROC_API
  return pi->prstatus.pr_lwp.pr_lwpid;
#else
  return pi->prstatus.pr_who;
#endif
}
d4268 2
a4269 15
#else
#if defined (PIOCNTHR) && defined (PIOCTLIST)
/*
 * OSF version
 */
int 
proc_get_current_thread (pi)
     procinfo *pi;
{
#if 0	/* FIXME: not ready for prime time? */
  return pi->prstatus.pr_tid;
#else
  return 0;
#endif
}
d4271 2
a4272 10
#else
/*
 * Default version
 */
int 
proc_get_current_thread (pi)
     procinfo *pi;
{
  return 0;
}
d4274 16
a4289 2
#endif
#endif
d4291 3
a4293 10
/*
 * Function: proc_update_threads 
 *
 * Discover the IDs of all the threads within the process, and
 * create a procinfo for each of them (chained to the parent).
 *
 * This unfortunately requires a different method on every OS.
 *
 * Return: non-zero for success, zero for failure.
 */
d4295 1
a4295 7
int
proc_delete_dead_threads (parent, thread, ignore)
     procinfo *parent;
     procinfo *thread;
     void     *ignore;
{
  if (thread && parent)	/* sanity */
d4297 2
a4298 3
      thread->status_valid = 0;
      if (!proc_get_status (thread))
	destroy_one_procinfo (&parent->thread_list, thread);
a4299 2
  return 0;	/* keep iterating */
}
d4301 17
a4317 41
#if defined (PIOCLSTATUS)
/*
 * Solaris 2.5 (ioctl) version
 */
int
proc_update_threads (pi)
     procinfo *pi;
{
  gdb_prstatus_t *prstatus;
  struct cleanup *old_chain = NULL;
  procinfo *thread;
  int nlwp, i;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  proc_iterate_over_threads (pi, proc_delete_dead_threads, NULL);

  if ((nlwp = proc_get_nthreads (pi)) <= 1)
    return 1;	/* Process is not multi-threaded; nothing to do.  */

  if ((prstatus = (gdb_prstatus_t *) 
       malloc (sizeof (gdb_prstatus_t) * (nlwp + 1))) == 0)
    perror_with_name ("procfs: malloc failed in update_threads");

  old_chain = make_cleanup (free, prstatus);
  if (ioctl (pi->ctl_fd, PIOCLSTATUS, prstatus) < 0)
    proc_error (pi, "update_threads (PIOCLSTATUS)", __LINE__);

  /* Skip element zero, which represents the process as a whole. */
  for (i = 1; i < nlwp + 1; i++)
    {
      if ((thread = create_procinfo (pi->pid, prstatus[i].pr_who)) == NULL)
	proc_error (pi, "update_threads, create_procinfo", __LINE__);
a4318 5
      memcpy (&thread->prstatus, &prstatus[i], sizeof (*prstatus));
      thread->status_valid = 1;
    }
  pi->threads_valid = 1;
  do_cleanups (old_chain);
d4321 25
a4345 107
#else
#ifdef NEW_PROC_API
/*
 * Unixware and Solaris 6 (and later) version
 */
int
proc_update_threads (pi)
     procinfo *pi;
{
  char pathname[MAX_PROC_NAME_SIZE + 16];
  struct dirent *direntry;
  struct cleanup *old_chain = NULL;
  procinfo *thread;
  DIR *dirp;
  int lwpid;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  proc_iterate_over_threads (pi, proc_delete_dead_threads, NULL);

  /*
   * Unixware
   *
   * Note: this brute-force method is the only way I know of 
   * to accomplish this task on Unixware.  This method will 
   * also work on Solaris 2.6 and 2.7.  There is a much simpler
   * and more elegant way to do this on Solaris, but the margins
   * of this manuscript are too small to write it here...  ;-)
   */

  strcpy (pathname, pi->pathname);
  strcat (pathname, "/lwp");
  if ((dirp = opendir (pathname)) == NULL)
    proc_error (pi, "update_threads, opendir", __LINE__);

  old_chain = make_cleanup ((make_cleanup_func) closedir, dirp);
  while ((direntry = readdir (dirp)) != NULL)
    if (direntry->d_name[0] != '.')		/* skip '.' and '..' */
      {
	lwpid = atoi (&direntry->d_name[0]);
	if ((thread = create_procinfo (pi->pid, lwpid)) == NULL)
	  proc_error (pi, "update_threads, create_procinfo", __LINE__);
      }
  pi->threads_valid = 1;
  do_cleanups (old_chain);
  return 1;
}
#else
#ifdef PIOCTLIST
/*
 * OSF version
 */
int 
proc_update_threads (pi)
     procinfo *pi;
{
  int nthreads, i;
  tid_t *threads;

  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  proc_iterate_over_threads (pi, proc_delete_dead_threads, NULL);

  nthreads = proc_get_nthreads (pi);
  if (nthreads < 2)
    return 0;		/* nothing to do for 1 or fewer threads */

  if ((threads = malloc (nthreads * sizeof (tid_t))) == NULL)
    proc_error (pi, "update_threads, malloc", __LINE__);
  
  if (ioctl (pi->ctl_fd, PIOCTLIST, threads) < 0)
    proc_error (pi, "procfs: update_threads (PIOCTLIST)", __LINE__);

  for (i = 0; i < nthreads; i++)
    {
      if (!find_procinfo (pi->pid, threads[i]))
	if (!create_procinfo  (pi->pid, threads[i]))
	  proc_error (pi, "update_threads, create_procinfo", __LINE__);
    }
  pi->threads_valid = 1;
  return 1;
}
#else
/*
 * Default version
 */
int
proc_update_threads (pi)
     procinfo *pi;
{
  return 0;
a4346 26
#endif	/* OSF PIOCTLIST */
#endif  /* NEW_PROC_API   */
#endif  /* SOL 2.5 PIOCLSTATUS */

/*
 * Function: proc_iterate_over_threads
 *
 * Description:
 *   Given a pointer to a function, call that function once
 *   for each lwp in the procinfo list, until the function
 *   returns non-zero, in which event return the value
 *   returned by the function.
 *
 * Note: this function does NOT call update_threads.
 * If you want to discover new threads first, you must
 * call that function explicitly.  This function just makes
 * a quick pass over the currently-known procinfos. 
 * 
 * Arguments:
 *   pi		- parent process procinfo
 *   func	- per-thread function
 *   ptr	- opaque parameter for function.
 *
 * Return:
 *   First non-zero return value from the callee, or zero.
 */
d4348 4
a4351 5
int
proc_iterate_over_threads (pi, func, ptr)
     procinfo *pi;
     int     (*func) PARAMS ((procinfo *, procinfo *, void *));
     void     *ptr;
d4353 6
a4358 2
  procinfo *thread, *next;
  int retval = 0;
d4360 6
a4365 11
  /*
   * We should never have to apply this operation to any procinfo
   * except the one for the main process.  If that ever changes
   * for any reason, then take out the following clause and 
   * replace it with one that makes sure the ctl_fd is open.
   */
  
  if (pi->tid != 0)
    pi = find_procinfo_or_die (pi->pid, 0);

  for (thread = pi->thread_list; thread != NULL; thread = next)
d4367 11
a4377 3
      next = thread->next;	/* in case thread is destroyed */
      if ((retval = (*func) (pi, thread, ptr)) != 0)
	break;
d4379 1
a4379 2

  return retval;
d4382 8
a4389 1
/* =================== END, Thread "MODULE" =================== */
d4391 2
a4392 1
/* =================== END, /proc  "MODULE" =================== */
d4394 23
a4416 1
/* ===================  GDB  "MODULE" =================== */
d4418 2
a4419 3
/*
 * Here are all of the gdb target vector functions and their friends.
 */
d4421 56
a4476 3
static int  do_attach PARAMS ((int pid));
static void do_detach PARAMS ((int signo));
static int register_gdb_signals PARAMS ((procinfo *, sigset_t *));
d4478 102
a4579 58
/*
 * Function: procfs_debug_inferior
 *
 * Sets up the inferior to be debugged.
 * Registers to trace signals, hardware faults, and syscalls.
 * Note: does not set RLC flag: caller may want to customize that.
 *
 * Returns: zero for success (note! unlike most functions in this module)
 *   On failure, returns the LINE NUMBER where it failed!
 */

static int
procfs_debug_inferior (pi)
     procinfo *pi;
{
  fltset_t traced_faults;
  sigset_t traced_signals;
  sysset_t traced_syscall_entries;
  sysset_t traced_syscall_exits;

#ifdef PROCFS_DONT_TRACE_FAULTS
  /* On some systems (OSF), we don't trace hardware faults.
     Apparently it's enough that we catch them as signals.
     Wonder why we don't just do that in general? */
  premptyset (&traced_faults);		/* don't trace faults. */
#else
  /* Register to trace hardware faults in the child. */
  prfillset (&traced_faults);		/* trace all faults... */
  prdelset  (&traced_faults, FLTPAGE);	/* except page fault.  */
#endif
  if (!proc_set_traced_faults  (pi, &traced_faults))
    return __LINE__;

  /* Register to trace selected signals in the child. */
  premptyset (&traced_signals);
  if (!register_gdb_signals (pi, &traced_signals))
    return __LINE__;

  /* Register to trace the 'exit' system call (on entry).  */
  premptyset (&traced_syscall_entries);
  praddset   (&traced_syscall_entries, SYS_exit);
#ifdef SYS_lwpexit
  praddset   (&traced_syscall_entries, SYS_lwpexit);	/* And _lwp_exit... */
#endif
#ifdef SYS_lwp_exit
  praddset   (&traced_syscall_entries, SYS_lwp_exit);
#endif

  if (!proc_set_traced_sysentry (pi, &traced_syscall_entries))
    return __LINE__;

#ifdef PRFS_STOPEXEC	/* defined on OSF */
  /* OSF method for tracing exec syscalls.  Quoting:
     Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace
     exits from exec system calls because of the user level loader.  */
  /* FIXME: make nice and maybe move into an access function. */
  {
    int prfs_flags;
d4581 6
a4586 2
    if (ioctl (pi->ctl_fd, PIOCGSPCACT, &prfs_flags) < 0)
      return __LINE__;
d4588 2
a4589 1
    prfs_flags |= PRFS_STOPEXEC;
d4591 15
a4605 19
    if (ioctl (pi->ctl_fd, PIOCSSPCACT, &prfs_flags) < 0)
      return __LINE__;
  }
#else /* not PRFS_STOPEXEC */
  /* Everyone else's (except OSF) method for tracing exec syscalls */
  /* GW: Rationale...
     Not all systems with /proc have all the exec* syscalls with the same
     names.  On the SGI, for example, there is no SYS_exec, but there
     *is* a SYS_execv.  So, we try to account for that. */

  premptyset (&traced_syscall_exits);
#ifdef SYS_exec
  praddset (&traced_syscall_exits, SYS_exec);
#endif
#ifdef SYS_execve
  praddset (&traced_syscall_exits, SYS_execve);
#endif
#ifdef SYS_execv
  praddset (&traced_syscall_exits, SYS_execv);
d4608 6
a4613 4
#ifdef SYS_lwpcreate
  praddset (&traced_syscall_exits, SYS_lwpcreate);
  praddset (&traced_syscall_exits, SYS_lwpexit);
#endif
d4615 5
a4619 3
#ifdef SYS_lwp_create	/* FIXME: once only, please */
  praddset (&traced_syscall_exits, SYS_lwp_create);
  praddset (&traced_syscall_exits, SYS_lwp_exit);
d4622 1
d4624 11
a4634 2
  if (!proc_set_traced_sysexit (pi, &traced_syscall_exits))
    return __LINE__;
d4636 19
a4654 2
#endif /* PRFS_STOPEXEC */
  return 0;
d4657 3
a4659 4
static void 
procfs_attach (args, from_tty)
     char *args;
     int from_tty;
d4661 2
a4662 9
  char *exec_file;
  int   pid;

  if (!args)
    error_no_arg ("process-id to attach");

  pid = atoi (args);
  if (pid == getpid ())
    error ("Attaching GDB to itself is not a good idea...");
d4664 2
a4665 1
  if (from_tty)
d4667 1
a4667 9
      exec_file = get_exec_file (0);

      if (exec_file)
	printf_filtered ("Attaching to program `%s', %s\n", 
			 exec_file, target_pid_to_str (pid));
      else
	printf_filtered ("Attaching to %s\n", target_pid_to_str (pid));

      fflush (stdout);
d4669 1
a4669 13
  inferior_pid = do_attach (pid);
  push_target (&procfs_ops);
}

static void 
procfs_detach (args, from_tty)
     char *args;
     int from_tty;
{
  char *exec_file;
  int   signo = 0;

  if (from_tty)
d4671 1
a4671 6
      exec_file = get_exec_file (0);
      if (exec_file == 0)
	exec_file = "";
      printf_filtered ("Detaching from program: %s %s\n",
	      exec_file, target_pid_to_str (inferior_pid));
      fflush (stdout);
d4673 1
a4673 6
  if (args)
    signo = atoi (args);
  
  do_detach (signo);
  inferior_pid = 0;
  unpush_target (&procfs_ops);		/* Pop out of handling an inferior */
d4676 3
a4678 3
static int
do_attach (pid)
     int pid;
d4680 2
a4681 2
  procinfo *pi;
  int fail;
d4683 2
a4684 4
  if ((pi = create_procinfo (pid, 0)) == NULL)
    perror ("procfs: out of memory in 'attach'");

  if (!open_procinfo_files (pi, FD_CTL))
d4686 1
a4686 4
      fprintf_filtered (gdb_stderr, "procfs:%d -- ", __LINE__);
      sprintf (errmsg, "do_attach: couldn't open /proc file for process %d", 
	       pid);
      dead_procinfo (pi, errmsg, NOKILL);
d4688 1
a4688 3

  /* Stop the process (if it isn't already stopped).  */
  if (proc_flags (pi) & (PR_STOPPED | PR_ISTOP))
d4690 1
a4690 2
      pi->was_stopped = 1;
      proc_prettyprint_why (proc_why (pi), proc_what (pi), 1);
d4692 1
a4692 32
  else
    {
      pi->was_stopped = 0;
      /* Set the process to run again when we close it.  */
      if (!proc_set_run_on_last_close (pi))
	dead_procinfo (pi, "do_attach: couldn't set RLC.", NOKILL);

      /* Now stop the process. */
      if (!proc_stop_process (pi))
	dead_procinfo (pi, "do_attach: couldn't stop the process.", NOKILL);
      pi->ignore_next_sigstop = 1;
    }
  /* Save some of the /proc state to be restored if we detach.  */
  if (!proc_get_traced_faults   (pi, &pi->saved_fltset))
    dead_procinfo (pi, "do_attach: couldn't save traced faults.", NOKILL);
  if (!proc_get_traced_signals  (pi, &pi->saved_sigset))
    dead_procinfo (pi, "do_attach: couldn't save traced signals.", NOKILL);
  if (!proc_get_traced_sysentry (pi, &pi->saved_entryset))
    dead_procinfo (pi, "do_attach: couldn't save traced syscall entries.",
		   NOKILL);
  if (!proc_get_traced_sysexit  (pi, &pi->saved_exitset))
    dead_procinfo (pi, "do_attach: couldn't save traced syscall exits.", 
		   NOKILL);
  if (!proc_get_held_signals    (pi, &pi->saved_sighold))
    dead_procinfo (pi, "do_attach: couldn't save held signals.", NOKILL);

  if ((fail = procfs_debug_inferior (pi)) != 0)
    dead_procinfo (pi, "do_attach: failed in procfs_debug_inferior", NOKILL);

  /* Let GDB know that the inferior was attached.  */
  attach_flag = 1;
  return MERGEPID (pi->pid, proc_get_current_thread (pi));
d4696 3
a4698 2
do_detach (signo)
     int signo;
d4700 1
a4700 2
  procinfo *pi;
  long      pflags;
d4702 9
a4710 5
  /* Find procinfo for the main process */
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);	/* FIXME: threads */
  if (signo)
    if (!proc_set_current_signal (pi, signo))
      proc_warn (pi, "do_detach, set_current_signal", __LINE__);
d4712 22
a4733 2
  if (!proc_set_traced_signals (pi, &pi->saved_sigset))
    proc_warn (pi, "do_detach, set_traced_signal", __LINE__);
d4735 24
a4758 26
  if (!proc_set_traced_faults (pi, &pi->saved_fltset))
    proc_warn (pi, "do_detach, set_traced_faults", __LINE__);

  if (!proc_set_traced_sysentry (pi, &pi->saved_entryset))
    proc_warn (pi, "do_detach, set_traced_sysentry", __LINE__);

  if (!proc_set_traced_sysexit (pi, &pi->saved_exitset))
    proc_warn (pi, "do_detach, set_traced_sysexit", __LINE__);

  if (!proc_set_held_signals (pi, &pi->saved_sighold))
    proc_warn (pi, "do_detach, set_held_signals", __LINE__);

  if (signo || (proc_flags (pi) & (PR_STOPPED | PR_ISTOP)))
    if (signo || !(pi->was_stopped) ||
	query ("Was stopped when attached, make it runnable again? "))
      {
	/* Clear any pending signal.  */
	if (!proc_clear_current_fault (pi))
	  proc_warn (pi, "do_detach, clear_current_fault", __LINE__);

	if (!proc_set_run_on_last_close (pi))
	  proc_warn (pi, "do_detach, set_rlc", __LINE__);
      }

  attach_flag = 0;
  destroy_procinfo (pi);
a4760 11
/*
 * fetch_registers
 *
 * Since the /proc interface cannot give us individual registers,
 * we pay no attention to the (regno) argument, and just fetch them all.
 * This results in the possibility that we will do unnecessarily many
 * fetches, since we may be called repeatedly for individual registers.
 * So we cache the results, and mark the cache invalid when the process
 * is resumed.
 */

d4762 3
a4764 2
procfs_fetch_registers (regno)
     int regno;
d4766 1
a4766 18
  gdb_fpregset_t *fpregs;
  gdb_gregset_t  *gregs;
  procinfo       *pi;
  int            pid;
  int            tid;

  pid = PIDGET (inferior_pid);
  tid = TIDGET (inferior_pid);

  /* First look up procinfo for the main process. */
  pi  = find_procinfo_or_die (pid, 0);

  /* If the event thread is not the same as GDB's requested thread 
     (ie. inferior_pid), then look up procinfo for the requested 
     thread.  */
  if ((tid != 0) && 
      (tid != proc_get_current_thread (pi)))
    pi = find_procinfo_or_die (pid, tid);
d4768 8
a4775 14
  if (pi == NULL)
    error ("procfs: fetch_registers failed to find procinfo for %s", 
	   target_pid_to_str (inferior_pid));

  if ((gregs = proc_get_gregs (pi)) == NULL)
    proc_error (pi, "fetch_registers, get_gregs", __LINE__);

  supply_gregset (gregs);

#if defined (FP0_REGNUM)	/* need floating point? */
  if ((regno >= 0 && regno < FP0_REGNUM) ||
      regno == PC_REGNUM  ||
#ifdef NPC_REGNUM
      regno == NPC_REGNUM ||
a4776 3
      regno == FP_REGNUM  ||
      regno == SP_REGNUM)
    return;			/* not a floating point register */
d4778 2
a4779 2
  if ((fpregs = proc_get_fpregs (pi)) == NULL)
    proc_error (pi, "fetch_registers, get_fpregs", __LINE__);
d4781 10
a4790 1
  supply_fpregset (fpregs);
d4792 4
a4797 6
/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On
   machines which store all the registers in one fell swoop, such as
   /proc, this makes sure that registers contains all the registers
   from the program being debugged.  */

d4799 48
a4846 4
procfs_prepare_to_store ()
{
#ifdef CHILD_PREPARE_TO_STORE
  CHILD_PREPARE_TO_STORE ();
d4848 11
a4861 9
 * store_registers
 *
 * Since the /proc interface will not read individual registers, 
 * we will cache these requests until the process is resumed, and
 * only then write them back to the inferior process.
 *
 * FIXME: is that a really bad idea?  Have to think about cases
 * where writing one register might affect the value of others, etc.
 */
d4863 3
a4865 22
static void
procfs_store_registers (regno)
     int regno;
{
  gdb_fpregset_t *fpregs;
  gdb_gregset_t  *gregs;
  procinfo       *pi;
  int            pid;
  int            tid;

  pid = PIDGET (inferior_pid);
  tid = TIDGET (inferior_pid);

  /* First find procinfo for main process */
  pi  = find_procinfo_or_die (pid, 0);

  /* If current lwp for process is not the same as requested thread
     (ie. inferior_pid), then find procinfo for the requested thread.  */

  if ((tid != 0) && 
      (tid != proc_get_current_thread (pi)))
    pi = find_procinfo_or_die (pid, tid);
d4867 1
a4867 3
  if (pi == NULL)
    error ("procfs: store_registers: failed to find procinfo for %s",
	   target_pid_to_str (inferior_pid));
d4869 1
a4869 2
  if ((gregs = proc_get_gregs (pi)) == NULL)
    proc_error (pi, "store_registers, get_gregs", __LINE__);
d4871 1
a4871 3
  fill_gregset (gregs, regno);
  if (!proc_set_gregs (pi))
    proc_error (pi, "store_registers, set_gregs", __LINE__);
d4873 2
a4874 9
#if defined (FP0_REGNUM)	/* need floating point? */
  if ((regno >= 0 && regno < FP0_REGNUM) ||
      regno == PC_REGNUM  ||
#ifdef NPC_REGNUM
      regno == NPC_REGNUM ||
#endif
      regno == FP_REGNUM  ||
      regno == SP_REGNUM)
    return;			/* not a floating point register */
d4876 1
a4876 2
  if ((fpregs = proc_get_fpregs (pi)) == NULL)
    proc_error (pi, "store_registers, get_fpregs", __LINE__);
d4878 10
a4887 5
  fill_fpregset (fpregs, regno);
  if (!proc_set_fpregs (pi))
    proc_error (pi, "store_registers, set_fpregs", __LINE__);
#endif
}
a4888 10
/*
 * Function: target_wait
 *
 * Retrieve the next stop event from the child process.
 * If child has not stopped yet, wait for it to stop.
 * Translate /proc eventcodes (or possibly wait eventcodes)
 * into gdb internal event codes.
 *
 * Return: id of process (and possibly thread) that incurred the event.
 *         event codes are returned thru a pointer parameter.
d4891 4
a4894 4
static int  
procfs_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d4896 22
a4917 6
  /* First cut: loosely based on original version 2.1 */
  procinfo *pi;
  int       temp, wstat;
  int       retval;
  int       why, what, flags;
  int       retry = 0;
d4919 12
a4930 1
wait_again:
d4932 42
a4973 34
  retry++;
  wstat    = 0;
  retval   = -1;

  /* Find procinfo for main process */
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
  if (pi)
    {
      /* We must assume that the status is stale now... */
      pi->status_valid = 0;
      pi->gregs_valid  = 0;
      pi->fpregs_valid = 0;

#if 0	/* just try this out... */
      flags = proc_flags (pi);
      why   = proc_why (pi);
      if ((flags & PR_STOPPED) && (why == PR_REQUESTED))
	pi->status_valid = 0;	/* re-read again, IMMEDIATELY... */
#endif
      /* If child is not stopped, wait for it to stop.  */
      if (!(proc_flags (pi) & (PR_STOPPED | PR_ISTOP)) &&
	  !proc_wait_for_stop (pi))
	{
	  /* wait_for_stop failed: has the child terminated? */
	  if (errno == ENOENT)
	    {
	      /* /proc file not found; presumably child has terminated. */
	      retval = wait (&wstat);	/* "wait" for the child's exit  */

	      if (retval != PIDGET (inferior_pid))	/* wrong child? */
		error ("procfs: couldn't stop process %d: wait returned %d\n",
		       inferior_pid, retval);
	      /* FIXME: might I not just use waitpid?
		 Or try find_procinfo to see if I know about this child? */
d4975 1
a4975 1
	  else
d4977 2
a4978 2
	      /* Unknown error from wait_for_stop. */
	      proc_error (pi, "target_wait (wait_for_stop)", __LINE__);
d4980 1
a4980 30
	}
      else
	{
	  /* This long block is reached if either:
	     a) the child was already stopped, or
	     b) we successfully waited for the child with wait_for_stop.
	     This block will analyze the /proc status, and translate it
	     into a waitstatus for GDB.

	     If we actually had to call wait because the /proc file
	     is gone (child terminated), then we skip this block, 
	     because we already have a waitstatus.  */

	  flags = proc_flags (pi);
	  why   = proc_why (pi);
	  what  = proc_what (pi);

#if 0
	  {
	    int stopped_pc = read_pc ();
	    if (stopped_pc != 0x10c68 &&
		stopped_pc != 0x10c6c &&
		stopped_pc != 0x10c70 &&
		stopped_pc != 0x22768 &&
		stopped_pc != 0x10c74)
	      printf ("%x,%d,%d\n", stopped_pc, why, what);
	  }
#endif

	  if (flags & (PR_STOPPED | PR_ISTOP))
d4982 2
a4983 194
#ifdef PR_ASYNC
	      /* If it's running async (for single_thread control),
		 set it back to normal again.  */
	      if (flags & PR_ASYNC)
		if (!proc_unset_async (pi))
		  proc_error (pi, "target_wait, unset_async", __LINE__);
#endif

	      if (info_verbose)
		proc_prettyprint_why (why, what, 1);

	      /* The 'pid' we will return to GDB is composed of
		 the process ID plus the lwp ID.  */
	      retval = MERGEPID (pi->pid, proc_get_current_thread (pi));

	      switch (why) {
	      case PR_SIGNALLED:
		wstat = (what << 8) | 0177;
		break;
	      case PR_SYSENTRY:
		switch (what) {
#ifdef SYS_lwp_exit
		case SYS_lwp_exit:
#endif
#ifdef SYS_lwpexit
		case SYS_lwpexit:
#endif
#if defined (SYS_lwp_exit) || defined (SYS_lwpexit)
		  printf_filtered ("[%s exited]\n",
				   target_pid_to_str (retval));
		  delete_thread (retval);
		  status->kind = TARGET_WAITKIND_SPURIOUS;
		  return retval;
#endif /* _lwp_exit */

		case SYS_exit:
		  /* Handle SYS_exit call only */
		  /* Stopped at entry to SYS_exit.
		     Make it runnable, resume it, then use 
		     the wait system call to get its exit code.
		     Proc_run_process always clears the current 
		     fault and signal.
		     Then return its exit status.  */
		  pi->status_valid = 0;
		  wstat = 0;
		  /* FIXME: what we should do is return 
		     TARGET_WAITKIND_SPURIOUS.  */
		  if (!proc_run_process (pi, 0, 0))
		    proc_error (pi, "target_wait, run_process", __LINE__);
		  if (attach_flag)
		    {
		      /* Don't call wait: simulate waiting for exit, 
			 return a "success" exit code.  Bogus: what if
			 it returns something else?  */
		      wstat = 0;
		      retval = inferior_pid;  /* ??? */
		    }
		  else
		    {
		      int temp = wait (&wstat);

		      /* FIXME: shouldn't I make sure I get the right
			 event from the right process?  If (for
			 instance) I have killed an earlier inferior
			 process but failed to clean up after it
			 somehow, I could get its termination event
			 here.  */

		      /* If wait returns -1, that's what we return to GDB. */
		      if (temp < 0)
			retval = temp;
		    }
		  break;
		default:
		  printf_filtered ("procfs: trapped on entry to ");
		  proc_prettyprint_syscall (proc_what (pi), 0);
		  printf_filtered ("\n");
#ifndef PIOCSSPCACT
		  {
		    long i, nsysargs, *sysargs;

		    if ((nsysargs = proc_nsysarg (pi)) > 0 &&
			(sysargs  = proc_sysargs (pi)) != NULL)
		      {
			printf_filtered ("%d syscall arguments:\n", nsysargs);
			for (i = 0; i < nsysargs; i++)
			  printf_filtered ("#%d: 0x%08x\n", 
					   i, sysargs[i]);
		      }

		  }
#endif
		  if (status)
		    {
		      /* How to exit gracefully, returning "unknown event" */
		      status->kind = TARGET_WAITKIND_SPURIOUS;
		      return inferior_pid;
		    }
		  else
		    {
		      /* How to keep going without returning to wfi: */
		      target_resume (pid, 0, TARGET_SIGNAL_0);
		      goto wait_again;
		    }
		  break;
		}
		break;
	      case PR_SYSEXIT:
		switch (what) {
#ifdef SYS_exec
		case SYS_exec:
#endif
#ifdef SYS_execv
		case SYS_execv:
#endif
#ifdef SYS_execve
		case SYS_execve:
#endif
		  /* Hopefully this is our own "fork-child" execing
		     the real child.  Hoax this event into a trap, and
		     GDB will see the child about to execute its start
		     address. */
		  wstat = (SIGTRAP << 8) | 0177;
		  break;
#ifdef SYS_lwp_create
		case SYS_lwp_create:
#endif
#ifdef SYS_lwpcreate
		case SYS_lwpcreate:
#endif
#if defined(SYS_lwp_create) || defined(SYS_lwpcreate) 
		  /*
		   * This syscall is somewhat like fork/exec.
		   * We will get the event twice: once for the parent LWP,
		   * and once for the child.  We should already know about
		   * the parent LWP, but the child will be new to us.  So,
		   * whenever we get this event, if it represents a new
		   * thread, simply add the thread to the list.
		   */

		  /* If not in procinfo list, add it.  */
		  temp = proc_get_current_thread (pi);
		  if (!find_procinfo (pi->pid, temp))
		    create_procinfo  (pi->pid, temp);

		  temp = MERGEPID (pi->pid, temp);
		  /* If not in GDB's thread list, add it.  */
		  if (!in_thread_list (temp))
		    {
		      printf_filtered ("[New %s]\n", target_pid_to_str (temp));
		      add_thread (temp);
		    }
		  /* Return to WFI, but tell it to immediately resume. */
		  status->kind = TARGET_WAITKIND_SPURIOUS;
		  return inferior_pid;
#endif	/* _lwp_create */

#ifdef SYS_lwp_exit
		case SYS_lwp_exit:
#endif
#ifdef SYS_lwpexit
		case SYS_lwpexit:
#endif
#if defined (SYS_lwp_exit) || defined (SYS_lwpexit)
		  printf_filtered ("[%s exited]\n",
				   target_pid_to_str (retval));
		  delete_thread (retval);
		  status->kind = TARGET_WAITKIND_SPURIOUS;
		  return retval;
#endif /* _lwp_exit */

#ifdef SYS_sproc
		case SYS_sproc:
		  /* Nothing to do here for now.  The old procfs
		     seemed to use this event to handle threads on
		     older (non-LWP) systems, where I'm assuming that
		     threads were actually separate processes.  Irix,
		     maybe?  Anyway, low priority for now.  */
#endif
#ifdef SYS_fork
		case SYS_fork:
		  /* FIXME: do we need to handle this?  Investigate.  */
#endif
#ifdef SYS_vfork
		case SYS_vfork:
		  /* FIXME: see above.  */
#endif
		default:
		  printf_filtered ("procfs: trapped on exit from ");
		  proc_prettyprint_syscall (proc_what (pi), 0);
		  printf_filtered ("\n");
#ifndef PIOCSSPCACT
		  {
		    long i, nsysargs, *sysargs;
d4985 2
a4986 112
		    if ((nsysargs = proc_nsysarg (pi)) > 0 &&
			(sysargs  = proc_sysargs (pi)) != NULL)
		      {
			printf_filtered ("%d syscall arguments:\n", nsysargs);
			for (i = 0; i < nsysargs; i++)
			  printf_filtered ("#%d: 0x%08x\n", 
					   i, sysargs[i]);
		      }
		  }
#endif
		  status->kind = TARGET_WAITKIND_SPURIOUS;
		  return inferior_pid;
		}
		break;
	      case PR_REQUESTED:
#if 0	/* FIXME */
		wstat = (SIGSTOP << 8) | 0177;
		break;
#else
		if (retry < 5)
		  {
		    printf_filtered ("Retry #%d:\n", retry);
		    pi->status_valid = 0;
		    goto wait_again;
		  }
		else
		  {
		    /* If not in procinfo list, add it.  */
		    temp = proc_get_current_thread (pi);
		    if (!find_procinfo (pi->pid, temp))
		      create_procinfo  (pi->pid, temp);

		    /* If not in GDB's thread list, add it.  */
		    temp = MERGEPID (pi->pid, temp);
		    if (!in_thread_list (temp))
		      {
			printf_filtered ("[*New %s]\n", 
					 target_pid_to_str (temp));
			add_thread (temp);
		      }

		    status->kind = TARGET_WAITKIND_STOPPED;
		    status->value.sig = 0;
		    return retval;
		  }
#endif
	      case PR_JOBCONTROL:
		wstat = (what << 8) | 0177;
		break;
	      case PR_FAULTED:
		switch (what) {	/* FIXME: FAULTED_USE_SIGINFO */
#ifdef FLTWATCH
		case FLTWATCH:
		  wstat = (SIGTRAP << 8) | 0177;
		  break;
#endif
#ifdef FLTKWATCH
		case FLTKWATCH:
		  wstat = (SIGTRAP << 8) | 0177;
		  break;
#endif
		  /* FIXME: use si_signo where possible. */
		case FLTPRIV:
#if (FLTILL != FLTPRIV)		/* avoid "duplicate case" error */
		case FLTILL:
#endif
		  wstat = (SIGILL << 8) | 0177;
		  break;
		case FLTBPT:
#if (FLTTRACE != FLTBPT)	/* avoid "duplicate case" error */
		case FLTTRACE:
#endif
		  wstat = (SIGTRAP << 8) | 0177;
		  break;
		case FLTSTACK:
		case FLTACCESS:
#if (FLTBOUNDS != FLTSTACK)	/* avoid "duplicate case" error */
		case FLTBOUNDS:
#endif
		  wstat = (SIGSEGV << 8) | 0177;
		  break;
		case FLTIOVF:
		case FLTIZDIV:
#if (FLTFPE != FLTIOVF)		/* avoid "duplicate case" error */
		case FLTFPE:
#endif
		  wstat = (SIGFPE << 8) | 0177;
		  break;
		case FLTPAGE:		/* Recoverable page fault */
		default:	 /* FIXME: use si_signo if possible for fault */
		  retval = -1;
		  printf_filtered ("procfs:%d -- ", __LINE__);
		  printf_filtered ("child stopped for unknown reason:\n");
		  proc_prettyprint_why (why, what, 1);
		  error ("... giving up...");
		  break;
		}
		break;	/* case PR_FAULTED: */
	      default:	/* switch (why) unmatched */
		printf_filtered ("procfs:%d -- ", __LINE__);
		printf_filtered ("child stopped for unknown reason:\n");
		proc_prettyprint_why (why, what, 1);
		error ("... giving up...");
		break;
	      }
	      /*
	       * Got this far without error:
	       * If retval isn't in the threads database, add it.
	       */
	      if (retval > 0 &&
		  retval != inferior_pid &&
		  !in_thread_list (retval))
d4988 2
a4989 24
		  /*
		   * We have a new thread.  
		   * We need to add it both to GDB's list and to our own.
		   * If we don't create a procinfo, resume may be unhappy 
		   * later.
		   */
		  printf_filtered ("[New %s]\n", target_pid_to_str (retval));
		  add_thread (retval);
		  if (find_procinfo (PIDGET (retval), TIDGET (retval)) == NULL)
		    create_procinfo (PIDGET (retval), TIDGET (retval));

		  /* In addition, it's possible that this is the first
		   * new thread we've seen, in which case we may not 
		   * have created entries for inferior_pid yet.
		   */
		  if (TIDGET (inferior_pid) != 0)
		    {
		      if (!in_thread_list (inferior_pid))
			add_thread (inferior_pid);
		      if (find_procinfo (PIDGET (inferior_pid), 
					 TIDGET (inferior_pid)) == NULL)
			create_procinfo (PIDGET (inferior_pid), 
					 TIDGET (inferior_pid));
		    }
d4991 2
d4994 1
a4994 1
	  else	/* flags do not indicate STOPPED */
d4996 1
a4996 5
	      /* surely this can't happen... */
	      printf_filtered ("procfs:%d -- process not stopped.\n",
			       __LINE__);
	      proc_prettyprint_flags (flags, 1);
	      error ("procfs: ...giving up...");
d4998 1
d5000 1
d5002 7
a5008 2
      if (status)
	store_waitstatus (status, wstat);
d5011 5
a5015 2
  return retval;
}
d5017 4
a5020 10
static int
procfs_xfer_memory (memaddr, myaddr, len, dowrite, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int dowrite;
     struct target_ops *target; /* ignored */
{
  procinfo *pi;
  int nbytes = 0;
d5022 1
a5022 4
  /* Find procinfo for main process */
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
  if (pi->as_fd == 0 &&
      open_procinfo_files (pi, FD_AS) == 0)
d5024 2
a5025 2
      proc_warn (pi, "xfer_memory, open_proc_files", __LINE__);
      return 0;
d5027 5
d5033 1
a5033 1
  if (lseek (pi->as_fd, (off_t) memaddr, SEEK_SET) == (off_t) memaddr)
d5035 29
a5063 1
      if (dowrite)
d5065 3
a5067 2
#ifdef NEW_PROC_API
	  PROCFS_NOTE ("write memory: ");
d5069 1
a5069 1
	  PROCFS_NOTE ("write memory: \n");
d5071 15
a5085 1
	  nbytes = write (pi->as_fd, myaddr, len);
d5087 1
a5087 1
      else
d5089 1
a5089 2
	  PROCFS_NOTE ("read  memory: \n");
	  nbytes = read (pi->as_fd, myaddr, len);
d5091 1
a5091 1
      if (nbytes < 0)
d5093 1
a5093 1
	  nbytes = 0;
d5095 7
d5103 1
a5103 1
  return nbytes;
a5106 18
 * Function: invalidate_cache
 *
 * Called by target_resume before making child runnable.
 * Mark cached registers and status's invalid.
 * If there are "dirty" caches that need to be written back
 * to the child process, do that.
 *
 * File descriptors are also cached.  
 * As they are a limited resource, we cannot hold onto them indefinitely.
 * However, as they are expensive to open, we don't want to throw them
 * away indescriminately either.  As a compromise, we will keep the
 * file descriptors for the parent process, but discard any file
 * descriptors we may have accumulated for the threads.
 *
 * Return value:
 * As this function is called by iterate_over_threads, it always 
 * returns zero (so that iterate_over_threads will keep iterating).
 */
d5108 13
d5122 1
a5122 9
static int
invalidate_cache (parent, pi, ptr)
     procinfo *parent;
     procinfo *pi;
     void     *ptr;
{
  /*
   * About to run the child; invalidate caches and do any other cleanup.
   */
d5124 7
a5130 14
#if 0
  if (pi->gregs_dirty)
    if (parent == NULL ||
	proc_get_current_thread (parent) != pi->tid)
      if (!proc_set_gregs (pi))	/* flush gregs cache */
	proc_warn (pi, "target_resume, set_gregs",
		   __LINE__);
#ifdef FP0_REGNUM
  if (pi->fpregs_dirty)
    if (parent == NULL ||
	proc_get_current_thread (parent) != pi->tid)
      if (!proc_set_fpregs (pi))	/* flush fpregs cache */
	proc_warn (pi, "target_resume, set_fpregs", 
		   __LINE__);
d5132 3
d5137 14
a5150 1
  if (parent != NULL)
d5152 9
a5160 3
      /* The presence of a parent indicates that this is an LWP.
	 Close any file descriptors that it might have open.  
	 We don't do this to the master (parent) procinfo.  */
d5162 5
a5166 1
      close_procinfo_files (pi);
d5168 7
a5174 5
  pi->gregs_valid   = 0;
  pi->fpregs_valid  = 0;
#if 0
  pi->gregs_dirty   = 0;
  pi->fpregs_dirty  = 0;
a5175 2
  pi->status_valid  = 0;
  pi->threads_valid = 0;
d5177 5
a5181 1
  return 0;
d5185 15
a5199 5
 * Function: make_signal_thread_runnable
 *
 * A callback function for iterate_over_threads.
 * Find the asynchronous signal thread, and make it runnable.
 * See if that helps matters any.
d5202 36
a5237 12
static int
make_signal_thread_runnable (process, pi, ptr)
     procinfo *process;
     procinfo *pi;
     void     *ptr;
{
#ifdef PR_ASLWP
  if (proc_flags (pi) & PR_ASLWP)
    {
      if (!proc_run_process (pi, 0, -1))
	proc_error (pi, "make_signal_thread_runnable", __LINE__);
      return 1;
d5239 10
d5250 6
a5255 1
  return 0;
d5259 13
a5271 14
 * Function: target_resume
 *
 * Make the child process runnable.  Normally we will then call
 * procfs_wait and wait for it to stop again (unles gdb is async).
 *
 * Arguments:
 *  step:  if true, then arrange for the child to stop again 
 *         after executing a single instruction.
 *  signo: if zero, then cancel any pending signal.
 *         If non-zero, then arrange for the indicated signal 
 *         to be delivered to the child when it runs.
 *  pid:   if -1, then allow any child thread to run.
 *         if non-zero, then allow only the indicated thread to run.
 *******   (not implemented yet)
d5275 4
a5278 4
procfs_resume (pid, step, signo)
     int pid;
     int step;
     enum target_signal signo;
d5280 2
a5281 2
  procinfo *pi, *thread;
  int native_signo;
d5283 2
a5284 15
  /* 2.1: 
     prrun.prflags |= PRSVADDR;
     prrun.pr_vaddr = $PC;	   set resume address 
     prrun.prflags |= PRSTRACE;    trace signals in pr_trace (all)
     prrun.prflags |= PRSFAULT;    trace faults in pr_fault (all but PAGE) 
     prrun.prflags |= PRCFAULT;    clear current fault.

     PRSTRACE and PRSFAULT can be done by other means
     	(proc_trace_signals, proc_trace_faults)
     PRSVADDR is unnecessary.
     PRCFAULT may be replaced by a PIOCCFAULT call (proc_clear_current_fault)
     This basically leaves PRSTEP and PRCSIG.
     PRCSIG is like PIOCSSIG (proc_clear_current_signal).
     So basically PR_STEP is the sole argument that must be passed
     to proc_run_process (for use in the prrun struct by ioctl). */
d5286 5
a5290 2
  /* Find procinfo for main process */
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
d5292 3
a5294 11
  /* First cut: ignore pid argument */
  errno = 0;

  /* Convert signal to host numbering.  */
  if (signo == 0 ||
      signo == TARGET_SIGNAL_STOP && pi->ignore_next_sigstop)
    native_signo = 0;
  else
    native_signo = target_signal_to_host (signo);

  pi->ignore_next_sigstop = 0;
d5296 1
a5296 14
  /* Running the process voids all cached registers and status. */
  /* Void the threads' caches first */
  proc_iterate_over_threads (pi, invalidate_cache, NULL); 
  /* Void the process procinfo's caches.  */
  invalidate_cache (NULL, pi, NULL);

  if (pid != -1)
    {
      /* Resume a specific thread, presumably suppressing the others. */
      thread = find_procinfo (PIDGET (pid), TIDGET (pid));
      if (thread == NULL)
	warning ("procfs: resume can't find thread %d -- resuming all.",
		 TIDGET (pid));
      else
d5298 2
a5299 16
	  if (thread->tid != 0)
	    {
	      /* We're to resume a specific thread, and not the others.
	       * Set the child process's PR_ASYNC flag.
	       */
#ifdef PR_ASYNC
	      if (!proc_set_async (pi))
		proc_error (pi, "target_resume, set_async", __LINE__);
#endif
#if 0
	      proc_iterate_over_threads (pi, 
					 make_signal_thread_runnable,
					 NULL);
#endif
	      pi = thread;	/* substitute the thread's procinfo for run */
	    }
d5303 3
a5305 1
  if (!proc_run_process (pi, step, native_signo))
d5307 3
a5309 4
      if (errno == EBUSY)
	warning ("resume: target already running.  Pretend to resume, and hope for the best!\n");
      else
	proc_error (pi, "target_resume", __LINE__);
a5310 1
}
d5312 3
a5314 9
/*
 * Function: register_gdb_signals
 *
 * Traverse the list of signals that GDB knows about 
 * (see "handle" command), and arrange for the target
 * to be stopped or not, according to these settings.
 *
 * Returns non-zero for success, zero for failure.
 */
d5316 8
a5323 6
static int
register_gdb_signals (pi, signals)
     procinfo *pi;
     sigset_t *signals;
{
  int signo;
d5325 6
a5330 7
  for (signo = 0; signo < NSIG; signo ++)
    if (signal_stop_state  (target_signal_from_host (signo)) == 0 &&
	signal_print_state (target_signal_from_host (signo)) == 0 &&
	signal_pass_state  (target_signal_from_host (signo)) == 1)
      prdelset (signals, signo);
    else
      praddset (signals, signo);
d5332 1
a5332 2
  return proc_set_traced_signals (pi, signals);
}
d5334 10
a5343 5
/*
 * Function: target_notice_signals
 *
 * Set up to trace signals in the child process.
 */
d5345 6
a5350 19
static void
procfs_notice_signals (pid)
     int pid;
{
  sigset_t signals;
  procinfo *pi = find_procinfo_or_die (PIDGET (pid), 0);

  if (proc_get_traced_signals (pi, &signals) &&
      register_gdb_signals    (pi, &signals))
    return;
  else
    proc_error (pi, "notice_signals", __LINE__);
}

/*
 * Function: target_files_info
 *
 * Print status information about the child process.
 */
d5352 3
a5354 7
static void
procfs_files_info (ignore)
     struct target_ops *ignore;
{
  printf_filtered ("\tUsing the running image of %s %s via /proc.\n",
		   attach_flag? "attached": "child", 
		   target_pid_to_str (inferior_pid));
a5357 12
 * Function: target_open
 *
 * A dummy: you don't open procfs.
 */

static void
procfs_open (args, from_tty)
     char *args;
     int from_tty;
{
  error ("Use the \"run\" command to start a Unix child process.");
}
d5359 1
a5359 6
/*
 * Function: target_can_run
 *
 * This tells GDB that this target vector can be invoked 
 * for "run" or "attach".
 */
d5361 2
a5362 4
int procfs_suppress_run = 0;	/* Non-zero if procfs should pretend not to
				   be a runnable target.  Used by targets
				   that can sit atop procfs, such as solaris
				   thread support.  */
d5364 1
d5366 2
a5367 9
static int
procfs_can_run ()
{
  /* This variable is controlled by modules that sit atop procfs that
     may layer their own process structure atop that provided here.
     sol-thread.c does this because of the Solaris two-level thread
     model.  */
  
  /* NOTE: possibly obsolete -- use the thread_stratum approach instead. */
d5369 1
a5369 2
  return !procfs_suppress_run;
}
d5371 6
a5376 7
/*
 * Function: target_stop
 *
 * Stop the child process asynchronously, as when the
 * gdb user types control-c or presses a "stop" button.
 *
 * Works by sending kill(SIGINT) to the child's process group.
d5380 5
a5384 1
procfs_stop ()
d5386 1
a5386 1
  extern pid_t inferior_process_group;
d5388 8
a5395 2
  kill (-inferior_process_group, SIGINT);
}
d5397 1
a5397 8
/*
 * Function: unconditionally_kill_inferior
 *
 * Make it die.  Wait for it to die.  Clean up after it.
 * Note: this should only be applied to the real process, 
 * not to an LWP, because of the check for parent-process.
 * If we need this to work for an LWP, it needs some more logic.
 */
d5399 6
a5404 5
static void
unconditionally_kill_inferior (pi)
     procinfo *pi;
{
  int parent_pid;
d5406 1
a5406 7
  parent_pid = proc_parent_pid (pi);
#ifdef PROCFS_NEED_CLEAR_CURSIG_FOR_KILL
  /* FIXME: use access functions */
  /* Alpha OSF/1-3.x procfs needs a clear of the current signal
     before the PIOCKILL, otherwise it might generate a corrupted core
     file for the inferior.  */
  if (ioctl (pi->ctl_fd, PIOCSSIG, NULL) < 0)
d5408 15
a5422 1
      printf_filtered ("unconditionally_kill: SSIG failed!\n");
a5424 8
#ifdef PROCFS_NEED_PIOCSSIG_FOR_KILL
  /* Alpha OSF/1-2.x procfs needs a PIOCSSIG call with a SIGKILL signal
     to kill the inferior, otherwise it might remain stopped with a
     pending SIGKILL.
     We do not check the result of the PIOCSSIG, the inferior might have
     died already.  */
  {
    struct siginfo newsiginfo;
d5426 10
a5435 14
    memset ((char *) &newsiginfo, 0, sizeof (newsiginfo));
    newsiginfo.si_signo = SIGKILL;
    newsiginfo.si_code = 0;
    newsiginfo.si_errno = 0;
    newsiginfo.si_pid = getpid ();
    newsiginfo.si_uid = getuid ();
    /* FIXME: use proc_set_current_signal */
    ioctl (pi->ctl_fd, PIOCSSIG, &newsiginfo);
  }
#else /* PROCFS_NEED_PIOCSSIG_FOR_KILL */
  if (!proc_kill (pi, SIGKILL))
    proc_warn (pi, "unconditionally_kill, proc_kill", __LINE__);
#endif /* PROCFS_NEED_PIOCSSIG_FOR_KILL */
  destroy_procinfo (pi);
d5437 6
a5442 6
  /* If pi is GDB's child, wait for it to die.  */
  if (parent_pid == getpid ())
    /* FIXME: should we use waitpid to make sure we get the right event?  
       Should we check the returned event?  */
    {
      int status, ret;
d5444 5
a5448 5
#if 0
      ret = waitpid (pi->pid, &status, 0);
#else
      wait (NULL);
#endif
d5452 2
a5454 5
 * Function: target_kill_inferior
 *
 * We're done debugging it, and we want it to go away.
 * Then we want GDB to forget all about it.
 */
d5456 5
a5460 7
static void 
procfs_kill_inferior ()
{
  if (inferior_pid != 0) /* ? */
    {
      /* Find procinfo for main process */
      procinfo *pi = find_procinfo (PIDGET (inferior_pid), 0);
d5462 1
a5462 5
      if (pi)
	unconditionally_kill_inferior (pi);
      target_mourn_inferior ();
    }
}
d5464 1
a5464 5
/*
 * Function: target_mourn_inferior
 *
 * Forget we ever debugged this thing!
 */
d5466 8
a5473 4
static void 
procfs_mourn_inferior ()
{
  procinfo *pi;
d5475 2
a5476 10
  if (inferior_pid != 0)
    {
      /* Find procinfo for main process */
      pi = find_procinfo (PIDGET (inferior_pid), 0);
      if (pi)
	destroy_procinfo (pi);
    }
  unpush_target (&procfs_ops);
  generic_mourn_inferior ();
}
d5478 4
a5481 7
/*
 * Function: init_inferior
 *
 * When GDB forks to create a runnable inferior process, 
 * this function is called on the parent side of the fork.
 * It's job is to do whatever is necessary to make the child
 * ready to be debugged, and then wait for the child to synchronize.
d5484 7
a5490 3
static void 
procfs_init_inferior (pid)
     int pid;
d5492 9
a5500 3
  procinfo *pi;
  sigset_t signals;
  int fail;
d5502 2
a5503 2
  /* This routine called on the parent side (GDB side)
     after GDB forks the inferior.  */
d5505 6
a5510 1
  push_target (&procfs_ops);
d5512 2
a5513 2
  if ((pi = create_procinfo (pid, 0)) == NULL)
    perror ("procfs: out of memory in 'init_inferior'");
d5515 7
a5521 2
  if (!open_procinfo_files (pi, FD_CTL))
    proc_error (pi, "init_inferior, open_proc_files", __LINE__);
d5523 2
a5524 47
  /*
    xmalloc			// done
    open_procinfo_files		// done
    link list			// done
    prfillset (trace)
    procfs_notice_signals
    prfillset (fault)
    prdelset (FLTPAGE)
    PIOCWSTOP
    PIOCSFAULT
    */

  /* If not stopped yet, wait for it to stop. */
  if (!(proc_flags (pi) & PR_STOPPED) &&
      !(proc_wait_for_stop (pi)))
    dead_procinfo (pi, "init_inferior: wait_for_stop failed", KILL);

  /* Save some of the /proc state to be restored if we detach.  */
  /* FIXME: Why?  In case another debugger was debugging it?
     We're it's parent, for Ghu's sake! */
  if (!proc_get_traced_signals  (pi, &pi->saved_sigset))
    proc_error (pi, "init_inferior, get_traced_signals", __LINE__);
  if (!proc_get_held_signals    (pi, &pi->saved_sighold))
    proc_error (pi, "init_inferior, get_held_signals", __LINE__);
  if (!proc_get_traced_faults   (pi, &pi->saved_fltset))
    proc_error (pi, "init_inferior, get_traced_faults", __LINE__);
  if (!proc_get_traced_sysentry (pi, &pi->saved_entryset))
    proc_error (pi, "init_inferior, get_traced_sysentry", __LINE__);
  if (!proc_get_traced_sysexit  (pi, &pi->saved_exitset))
    proc_error (pi, "init_inferior, get_traced_sysexit", __LINE__);

  /* Register to trace selected signals in the child. */
  prfillset (&signals);
  if (!register_gdb_signals (pi, &signals))
    proc_error (pi, "init_inferior, register_signals", __LINE__);

  if ((fail = procfs_debug_inferior (pi)) != 0)
    proc_error (pi, "init_inferior (procfs_debug_inferior)", fail);

  /* Turn on run-on-last-close flag so that the child
     will die if GDB goes away for some reason.  */
  if (!proc_set_run_on_last_close (pi))
    proc_error (pi, "init_inferior, set_RLC", __LINE__);

  /* The 'process ID' we return to GDB is composed of
     the actual process ID plus the lwp ID. */
  inferior_pid = MERGEPID (pi->pid, proc_get_current_thread (pi));
d5526 2
a5527 5
#ifdef START_INFERIOR_TRAPS_EXPECTED
  startup_inferior (START_INFERIOR_TRAPS_EXPECTED);
#else
  /* One trap to exec the shell, one to exec the program being debugged.  */
  startup_inferior (2);
a5528 1
}
d5530 2
a5531 11
/*
 * Function: set_exec_trap
 *
 * When GDB forks to create a new process, this function is called
 * on the child side of the fork before GDB exec's the user program.
 * Its job is to make the child minimally debuggable, so that the
 * parent GDB process can connect to the child and take over.
 * This function should do only the minimum to make that possible,
 * and to synchronize with the parent process.  The parent process
 * should take care of the details.
 */
d5533 5
a5537 6
static void
procfs_set_exec_trap ()
{
  /* This routine called on the child side (inferior side)
     after GDB forks the inferior.  It must use only local variables,
     because it may be sharing data space with its parent.  */
d5539 9
a5547 3
  procinfo *pi;
  sysset_t exitset;
  sysset_t entryset;
d5549 1
a5549 2
  if ((pi = create_procinfo (getpid (), 0)) == NULL)
    perror_with_name ("procfs: create_procinfo failed in child.");
d5551 1
a5551 6
  if (open_procinfo_files (pi, FD_CTL) == 0)
    {
      proc_warn (pi, "set_exec_trap, open_proc_files", __LINE__);
      gdb_flush (gdb_stderr);
      /* no need to call "dead_procinfo", because we're going to exit. */
      _exit (127);
d5554 14
a5567 7
#ifdef PRFS_STOPEXEC	/* defined on OSF */
  /* OSF method for tracing exec syscalls.  Quoting:
     Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace
     exits from exec system calls because of the user level loader.  */
  /* FIXME: make nice and maybe move into an access function. */
  {
    int prfs_flags;
d5569 3
a5571 7
    if (ioctl (pi->ctl_fd, PIOCGSPCACT, &prfs_flags) < 0)
      {
	proc_warn (pi, "set_exec_trap (PIOCGSPCACT)", __LINE__);
	gdb_flush (gdb_stderr);
	_exit (127);
      }
    prfs_flags |= PRFS_STOPEXEC;
d5573 4
a5576 13
    if (ioctl (pi->ctl_fd, PIOCSSPCACT, &prfs_flags) < 0)
      {
	proc_warn (pi, "set_exec_trap (PIOCSSPCACT)", __LINE__);
	gdb_flush (gdb_stderr);
	_exit (127);
      }
  }
#else /* not PRFS_STOPEXEC */
  /* Everyone else's (except OSF) method for tracing exec syscalls */
  /* GW: Rationale...
     Not all systems with /proc have all the exec* syscalls with the same
     names.  On the SGI, for example, there is no SYS_exec, but there
     *is* a SYS_execv.  So, we try to account for that. */
d5578 5
a5582 9
  premptyset (&exitset);
#ifdef SYS_exec
  praddset (&exitset, SYS_exec);
#endif
#ifdef SYS_execve
  praddset (&exitset, SYS_execve);
#endif
#ifdef SYS_execv
  praddset (&exitset, SYS_execv);
d5584 5
d5590 3
a5592 1
  if (!proc_set_traced_sysexit (pi, &exitset))
d5594 13
a5606 3
      proc_warn (pi, "set_exec_trap, set_traced_sysexit", __LINE__);
      gdb_flush (gdb_stderr);
      _exit (127);
d5608 1
a5608 17
#endif /* PRFS_STOPEXEC */

  /* FIXME: should this be done in the parent instead? */
  /* Turn off inherit on fork flag so that all grand-children
     of gdb start with tracing flags cleared.  */
  if (!proc_unset_inherit_on_fork (pi))
    proc_warn (pi, "set_exec_trap, unset_inherit", __LINE__);

  /* Turn off run on last close flag, so that the child process
     cannot run away just because we close our handle on it.
     We want it to wait for the parent to attach.  */
  if (!proc_unset_run_on_last_close (pi))
    proc_warn (pi, "set_exec_trap, unset_RLC", __LINE__);

  /* FIXME: No need to destroy the procinfo -- 
     we have our own address space, and we're about to do an exec! */
  /*destroy_procinfo (pi);*/
d5610 1
d5612 1
a5612 14
/*
 * Function: create_inferior
 *
 * This function is called BEFORE gdb forks the inferior process.
 * Its only real responsibility is to set things up for the fork, 
 * and tell GDB which two functions to call after the fork (one
 * for the parent, and one for the child).
 * 
 * This function does a complicated search for a unix shell program,
 * which it then uses to parse arguments and environment variables
 * to be sent to the child.  I wonder whether this code could not
 * be abstracted out and shared with other unix targets such as
 * infptrace?
 */
d5626 19
a5644 19
	 just do this the normal way (via execlp, which operates by
	 attempting an exec for each element of the PATH until it
	 finds one which succeeds), then there will be an exec for
	 each failed attempt, each of which will cause a PR_SYSEXIT
	 stop, and we won't know how to distinguish the PR_SYSEXIT's
	 for these failed execs with the ones for successful execs
	 (whether the exec has succeeded is stored at that time in the
	 carry bit or some such architecture-specific and
	 non-ABI-specified place).

	 So I can't think of anything better than to search the PATH
	 now.  This has several disadvantages: (1) There is a race
	 condition; if we find a file now and it is deleted before we
	 exec it, we lose, even if the deletion leaves a valid file
	 further down in the PATH, (2) there is no way to know exactly
	 what an executable (in the sense of "capable of being
	 exec'd") file is.  Using access() loses because it may lose
	 if the caller is the superuser; failing to use it loses if
	 there are ACLs or some such.  */
d5649 1
a5649 1
	 path is used from within GDB.  */
d5658 1
a5658 1
      for (p = path; p != NULL; p = p1 ? p1 + 1: NULL)
d5684 1
a5684 2
	error ("procfs:%d -- Can't find shell %s in PATH",
	       __LINE__, shell_file);
d5689 2
a5690 2
  fork_inferior (exec_file, allargs, env, procfs_set_exec_trap, 
		 procfs_init_inferior, NULL, shell_file);
d5698 1
a5698 6
/*
 * Function: notice_thread
 *
 * Callback for find_new_threads.
 * Calls "add_thread".
 */
d5700 2
a5701 5
static int
procfs_notice_thread (pi, thread, ptr)
     procinfo *pi;
     procinfo *thread;
     void *ptr;
d5703 2
a5704 1
  int gdb_threadid = MERGEPID (pi->pid, thread->tid);
d5706 5
a5710 2
  if (!in_thread_list (gdb_threadid))
    add_thread (gdb_threadid);
d5712 2
a5713 1
  return 0;
a5715 26
/*
 * Function: target_find_new_threads
 *
 * Query all the threads that the target knows about, 
 * and give them back to GDB to add to its list.
 */

void
procfs_find_new_threads ()
{
  procinfo *pi;

  /* Find procinfo for main process */
  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
  proc_update_threads (pi);
  proc_iterate_over_threads (pi, procfs_notice_thread, NULL);
}

/* 
 * Function: target_thread_alive
 *
 * Return true if the thread is still 'alive'.
 *
 * This guy doesn't really seem to be doing his job.
 * Got to investigate how to tell when a thread is really gone.
 */
d5717 1
d5719 1
a5719 2
procfs_thread_alive (pid)
     int pid;
d5721 3
a5723 2
  int proc, thread;
  procinfo *pi;
d5725 1
a5725 15
  proc    = PIDGET (pid);
  thread  = TIDGET (pid);
  /* If I don't know it, it ain't alive! */
  if ((pi = find_procinfo (proc, thread)) == NULL)
    return 0;

  /* If I can't get its status, it ain't alive!
     What's more, I need to forget about it!  */
  if (!proc_get_status (pi))
    {
      destroy_procinfo (pi);
      return 0;
    }
  /* I couldn't have got its status if it weren't alive, so it's alive.  */
  return 1;
d5727 6
a5732 10

/*
 * Function: target_pid_to_str
 *
 * Return a string to be used to identify the thread in 
 * the "info threads" display.
 */

char *
procfs_pid_to_str (pid)
a5733 24
{
  static char buf[80];
  int proc, thread;
  procinfo *pi;

  proc    = PIDGET (pid);
  thread  = TIDGET (pid);
  pi      = find_procinfo (proc, thread);

  if (thread == 0)
    sprintf (buf, "Process %d", proc);
  else
    sprintf (buf, "LWP %d", thread);
  return &buf[0];
}

/*
 * Function: procfs_set_watchpoint
 * Insert a watchpoint
 */

int 
procfs_set_watchpoint (pid, addr, len, rwflag, after)
     int       pid;
d5735 2
a5736 3
     int       len;
     int       rwflag;
     int       after;
d5738 2
a5739 3
#ifndef UNIXWARE
  int       pflags = 0;
  procinfo *pi; 
d5741 5
a5745 5
  pi = find_procinfo_or_die (pid == -1 ? 
			     PIDGET (inferior_pid) : PIDGET (pid), 0);

  /* Translate from GDB's flags to /proc's */
  if (len > 0)	/* len == 0 means delete watchpoint */
d5747 1
a5747 14
      switch (rwflag) {		/* FIXME: need an enum! */
      case hw_write:		/* default watchpoint (write) */
	pflags = WRITE_WATCHFLAG;
	break;
      case hw_read:		/* read watchpoint */
	pflags = READ_WATCHFLAG;
	break;
      case hw_access:		/* access watchpoint */
	pflags = READ_WATCHFLAG | WRITE_WATCHFLAG;
	break;
      case hw_execute:		/* execution HW breakpoint */
	pflags = EXEC_WATCHFLAG;
	break;
      default:			/* Something weird.  Return error. */
d5749 2
a5750 11
      }
      if (after)		/* Stop after r/w access is completed. */
	pflags |= AFTER_WATCHFLAG;
    }

  if (!proc_set_watchpoint (pi, addr, len, pflags))
    {
      if (errno == E2BIG)	/* Typical error for no resources */
	return -1;		/* fail */
      /* GDB may try to remove the same watchpoint twice.
	 If a remove request returns no match, don't error.  */
d5752 3
a5754 2
	return 0;		/* ignore */
      proc_error (pi, "set_watchpoint", __LINE__);
a5755 1
#endif
a5758 7
/*
 * Function: stopped_by_watchpoint
 *
 * Returns non-zero if process is stopped on a hardware watchpoint fault,
 * else returns zero.
 */

d5761 1
a5761 1
    int    pid;
d5763 13
a5775 8
  procinfo *pi;

  pi = find_procinfo_or_die (pid == -1 ? 
			     PIDGET (inferior_pid) : PIDGET (pid), 0);
  if (proc_flags (pi) & (PR_STOPPED | PR_ISTOP))
    {
      if (proc_why (pi) == PR_FAULTED)
	{	
d5777 1
a5777 2
	  if (proc_what (pi) == FLTWATCH)
	    return 1;
d5780 2
a5781 2
	  if (proc_what (pi) == FLTKWATCH)
	    return 1;
d5783 2
a5784 1
	}
d5788 2
d5791 2
a5792 10
#ifdef TM_I386SOL2_H
/*
 * Function: procfs_find_LDT_entry 
 *
 * Input:
 *   int pid;	// The GDB-style pid-plus-LWP.
 *
 * Return:
 *   pointer to the corresponding LDT entry.
 */
d5794 2
a5795 2
struct ssd *
procfs_find_LDT_entry (pid)
d5798 1
a5798 3
  gdb_gregset_t *gregs;
  int            key;
  procinfo      *pi;
d5800 1
a5800 2
  /* Find procinfo for the lwp. */
  if ((pi = find_procinfo (PIDGET (pid), TIDGET (pid))) == NULL)
d5802 12
a5813 3
      warning ("procfs_find_LDT_entry: could not find procinfi for %d.",
	       pid);
      return NULL;
d5815 1
a5815 12
  /* get its general registers. */
  if ((gregs = proc_get_gregs (pi)) == NULL)
    {
      warning ("procfs_find_LDT_entry: could not read gregs for %d.",
	       pid);
      return NULL;
    }
  /* Now extract the GS register's lower 16 bits. */
  key = (*gregs)[GS] & 0xffff;

  /* Find the matching entry and return it. */
  return proc_get_LDT_entry (pi, key);
a5816 1
#endif /* TM_I386SOL2_H */
d5818 2
a5819 6


static void
info_proc_cmd (args, from_tty)
     char *args;
     int from_tty;
d5821 1
a5821 7
  struct cleanup *old_chain;
  procinfo *process = NULL;
  procinfo *thread  = NULL;
  char    **argv    = NULL;
  char     *tmp     = NULL;
  int       pid     = 0;
  int       tid     = 0;
d5823 1
a5823 30
  old_chain = make_cleanup (null_cleanup, 0);
  if (args)
    if ((argv = buildargv (args)) == NULL)
      nomem (0);
    else
      make_cleanup ((make_cleanup_func) freeargv, argv);

  while (argv != NULL && *argv != NULL)
    {
      if (isdigit (argv[0][0]))
	{
	  pid = strtoul (argv[0], &tmp, 10);
	  if (*tmp == '/')
	    tid = strtoul (++tmp, NULL, 10);
	}
      else if (argv[0][0] == '/')
	{
	  tid = strtoul (argv[0] + 1, NULL, 10);
	}
      else
	{
	  /* [...] */
	}
      argv++;
    }
  if (pid == 0)
    pid = PIDGET (inferior_pid);
  if (pid == 0)
    error ("No current process: you must name one.");
  else
d5825 2
a5826 32
      /* Have pid, will travel.
	 First see if it's a process we're already debugging. */
      process = find_procinfo (pid, 0);
       if (process == NULL)
	 {
	   /* No.  So open a procinfo for it, but 
	      remember to close it again when finished.  */
	   process = create_procinfo (pid, 0);
	   make_cleanup ((make_cleanup_func) destroy_procinfo, process);
	   if (!open_procinfo_files (process, FD_CTL))
	     proc_error (process, "info proc, open_procinfo_files", __LINE__);
	 }
    }
  if (tid != 0)
    thread = create_procinfo (pid, tid);

  if (process)
    {
      printf_filtered ("process %d flags:\n", process->pid);
      proc_prettyprint_flags (proc_flags (process), 1);
      if (proc_flags (process) & (PR_STOPPED | PR_ISTOP))
	proc_prettyprint_why (proc_why (process), proc_what (process), 1);
      if (proc_get_nthreads (process) > 1)
	printf_filtered ("Process has %d threads.\n", 
			 proc_get_nthreads (process));
    }
  if (thread)
    {
      printf_filtered ("thread %d flags:\n", thread->tid);
      proc_prettyprint_flags (proc_flags (thread), 1);
      if (proc_flags (thread) & (PR_STOPPED | PR_ISTOP))
	proc_prettyprint_why (proc_why (thread), proc_what (thread), 1);
d5828 1
a5828 2

  do_cleanups (old_chain);
d5831 5
a5835 25
static void
proc_trace_syscalls (args, from_tty, entry_or_exit, mode)
     char *args;
     int   from_tty;
     int   entry_or_exit;
     int   mode;
{
  procinfo *pi;
  sysset_t *sysset;
  int       syscallnum = 0;

  if (inferior_pid <= 0)
    error ("you must be debugging a process to use this command.");

  if (args == NULL || args[0] == 0)
    error_no_arg ("system call to trace");

  pi = find_procinfo_or_die (PIDGET (inferior_pid), 0);
  if (isdigit (args[0]))
    {
      syscallnum = atoi (args);
      if (entry_or_exit == PR_SYSENTRY)
	sysset = proc_get_traced_sysentry (pi, NULL);
      else
	sysset = proc_get_traced_sysexit (pi, NULL);
d5837 2
a5838 2
      if (sysset == NULL)
	proc_error (pi, "proc-trace, get_traced_sysset", __LINE__);
d5840 2
a5841 4
      if (mode == FLAG_SET)
	praddset (sysset, syscallnum);
      else
	prdelset (sysset, syscallnum);
d5843 2
a5844 12
      if (entry_or_exit == PR_SYSENTRY)
	{
	  if (!proc_set_traced_sysentry (pi, sysset))
	    proc_error (pi, "proc-trace, set_traced_sysentry", __LINE__);
	}
      else
	{
	  if (!proc_set_traced_sysexit (pi, sysset))
	    proc_error (pi, "proc-trace, set_traced_sysexit", __LINE__);
	}
    }
}
d5846 2
a5847 7
static void 
proc_trace_sysentry_cmd (args, from_tty)
     char *args;
     int   from_tty;
{
  proc_trace_syscalls (args, from_tty, PR_SYSENTRY, FLAG_SET);
}
d5849 2
a5850 4
static void 
proc_trace_sysexit_cmd (args, from_tty)
     char *args;
     int   from_tty;
d5852 1
a5852 2
  proc_trace_syscalls (args, from_tty, PR_SYSEXIT, FLAG_SET);
}
d5854 1
a5854 6
static void 
proc_untrace_sysentry_cmd (args, from_tty)
     char *args;
     int   from_tty;
{
  proc_trace_syscalls (args, from_tty, PR_SYSENTRY, FLAG_RESET);
d5856 2
d5859 4
a5862 4
static void 
proc_untrace_sysexit_cmd (args, from_tty)
     char *args;
     int   from_tty;
d5864 1
a5864 2
  proc_trace_syscalls (args, from_tty, PR_SYSEXIT, FLAG_RESET);
}
d5866 1
d5868 1
a5868 9
int
mapping_test (fd, core_addr)
     int fd;
     CORE_ADDR core_addr;
{
  printf ("File descriptor %d, base address 0x%08x\n", fd, core_addr);
  if (fd > 0)
    close (fd);
  return 0;
d5870 2
d5873 2
a5874 4
void
test_mapping_cmd (args, from_tty)
     char *args;
     int from_tty;
d5876 37
a5912 3
  int ret;
  ret = proc_iterate_over_mappings (mapping_test);
  printf ("iterate_over_mappings returned %d.\n", ret);
d5918 13
a5932 38
  add_info ("proc", info_proc_cmd, 
	    "Show /proc process information about any running process.\
Default is the process being debugged.");
  add_com ("proc-trace-entry", no_class, proc_trace_sysentry_cmd, 
	   "Give a trace of entries into the syscall.");
  add_com ("proc-trace-exit", no_class, proc_trace_sysexit_cmd, 
	   "Give a trace of exits from the syscall.");
  add_com ("proc-untrace-entry", no_class, proc_untrace_sysentry_cmd, 
	   "Cancel a trace of entries into the syscall.");
  add_com ("proc-untrace-exit", no_class, proc_untrace_sysexit_cmd, 
	   "Cancel a trace of exits from the syscall.");

  add_com ("test-mapping", no_class, test_mapping_cmd, 
	   "test iterate-over-mappings");
}

/* =================== END, GDB  "MODULE" =================== */



/* miscelaneous stubs:                                             */
/* The following satisfy a few random symbols mostly created by    */
/* the solaris threads implementation, which I will chase down     */
/* later.        */

/*
 * Return a pid for which we guarantee
 * we will be able to find a 'live' procinfo.
 */

int
procfs_first_available ()
{
  if (procinfo_list)
    return procinfo_list->pid;
  else
    return -1;
}
d5934 7
a5940 5
int
procfs_get_pid_fd (pid)
     int pid;
{
  procinfo *pi;
d5942 1
a5942 9
  if (pid == -1 && inferior_pid != 0)
    pi = find_procinfo (PIDGET (inferior_pid), 0);
  else
    pi = find_procinfo (PIDGET (pid), 0);

  if (pi)
    return pi->ctl_fd;
  else
    return -1;
@


1.1.1.11
log
@import gdb-2000-01-10 snapshot
@
text
@d173 2
d176 2
d186 2
d191 5
d201 5
d300 3
a302 2
/* Provide default composite pid manipulation macros for systems that
   don't have threads. */
d305 9
a313 3
#define PIDGET(PID)		(PID)
#define TIDGET(PID)		(PID)
#define MERGEPID(PID, TID)	(PID)
d614 1
a614 1
  if ((pi = find_procinfo (pid, tid)))
a961 6
# ifdef UNIXWARE
  /* UnixWare 7.1 puts process status flags, e.g. PR_ASYNC, in
     pstatus_t and LWP status flags, e.g. PR_STOPPED, in lwpstatus_t.
     The two sets of flags don't overlap. */
  return pi->prstatus.pr_flags | pi->prstatus.pr_lwp.pr_flags;
# else
a962 1
# endif
d1096 1
a1096 1
 * Function: proc_modify_flag 
a1104 1
 *    PR_KLC    -- traced process is killed when last /proc file closed.
d1116 1
a1116 2
 * Note: OSF  does not define PR_KLC.
 * Note: OSF  is the only one that can ONLY use the oldest method.
a1220 3
#ifdef PR_KLC
	     flag == PR_KLC   ? "PR_KLC"   :
#endif
a1260 36
#ifdef PR_KLC
/*
 * Function: proc_set_kill_on_last_close
 *
 * Set the kill_on_last_close flag.
 * Process with all threads will be killed when debugger
 * closes all /proc fds (or debugger exits or dies).
 *
 * Returns non-zero for success, zero for failure.
 */

int
proc_set_kill_on_last_close (pi)
     procinfo *pi;
{
  return proc_modify_flag (pi, PR_KLC, FLAG_SET);
}

/*
 * Function: proc_unset_kill_on_last_close
 *
 * Reset the kill_on_last_close flag.
 * Process will NOT be killed when debugger 
 * closes its file handles (or exits or dies).
 *
 * Returns non-zero for success, zero for failure.
 */

int
proc_unset_kill_on_last_close (pi)
     procinfo *pi;
{
  return proc_modify_flag (pi, PR_KLC, FLAG_RESET);
}
#endif /* PR_KLC */

a2603 1
#ifndef NEW_PROC_API	/* avoid compiler warning */
a2604 1
#endif
d3393 1
d3653 12
d3898 1
a3898 1
			printf_filtered ("[New %s]\n", 
a4429 1
#if 0
d4432 1
a4549 4
  /* FIXME: logically, we should really be turning OFF run-on-last-close,
     and possibly even turning ON kill-on-last-close at this point.  But
     I can't make that change without careful testing which I don't have
     time to do right now...  */
d4564 1
a4564 1
#endif /* START_INFERIOR_TRAPS_EXPECTED */
@


1.1.1.12
log
@import gdb-2000-01-24 snapshot
@
text
@a26 1
#include "gdbthread.h"
a35 5
#include <sys/wait.h>
#include <signal.h>
#include <ctype.h>

#include "proc-utils.h"
d406 5
a410 7
    {
      if (tid)
	error ("procfs: couldn't find pid %d (kernel thread %d) in procinfo list.", 
	       pid, tid);
      else
	error ("procfs: couldn't find pid %d in procinfo list.", pid);
    }
a433 1
#ifdef NEW_PROC_API
a434 1
#endif
d2630 1
a2630 5
  int nmaps = 0;
  int i;
#else
  int map_fd;
  char pathname[MAX_PROC_NAME_SIZE];
d2633 2
a2634 1
  int fd;
d3765 1
a3765 1
			printf_filtered ("%ld syscall arguments:\n", nsysargs);
d3767 1
a3767 1
			  printf_filtered ("#%ld: 0x%08x\n", 
d3879 1
a3879 1
			printf_filtered ("%ld syscall arguments:\n", nsysargs);
d3881 1
a3881 1
			  printf_filtered ("#%ld: 0x%08x\n", 
a4143 1
#if 0
a4167 1
#endif
d4219 1
a4219 1
      (signo == TARGET_SIGNAL_STOP && pi->ignore_next_sigstop))
d4606 1
d5030 5
a5034 6
    {
      if ((argv = buildargv (args)) == NULL)
	nomem (0);
      else
	make_cleanup ((make_cleanup_func) freeargv, argv);
    }
@


