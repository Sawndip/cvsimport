head	1.50;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.49
	gdb_7_6-2013-04-26-release:1.49
	gdb_7_6-branch:1.49.0.2
	gdb_7_6-2013-03-12-branchpoint:1.49
	gdb_7_5_1-2012-11-29-release:1.47
	gdb_7_5-2012-08-17-release:1.47
	gdb_7_5-branch:1.47.0.2
	gdb_7_5-2012-07-18-branchpoint:1.47
	gdb_7_4_1-2012-04-26-release:1.46.2.1
	gdb_7_4-2012-01-24-release:1.46.2.1
	gdb_7_4-branch:1.46.0.2
	gdb_7_4-2011-12-13-branchpoint:1.46
	gdb_7_3_1-2011-09-04-release:1.45
	gdb_7_3-2011-07-26-release:1.45
	gdb_7_3-branch:1.45.0.2
	gdb_7_3-2011-04-01-branchpoint:1.45
	gdb_7_2-2010-09-02-release:1.43
	gdb_7_2-branch:1.43.0.2
	gdb_7_2-2010-07-07-branchpoint:1.43
	gdb_7_1-2010-03-18-release:1.41
	gdb_7_1-branch:1.41.0.2
	gdb_7_1-2010-02-18-branchpoint:1.41
	gdb_7_0_1-2009-12-22-release:1.36.2.1
	gdb_7_0-2009-10-06-release:1.36
	gdb_7_0-branch:1.36.0.2
	gdb_7_0-2009-09-16-branchpoint:1.36
	arc-sim-20090309:1.30
	msnyder-checkpoint-072509-branch:1.33.0.2
	msnyder-checkpoint-072509-branchpoint:1.33
	arc-insight_6_8-branch:1.30.0.10
	arc-insight_6_8-branchpoint:1.30
	insight_6_8-branch:1.30.0.8
	insight_6_8-branchpoint:1.30
	reverse-20081226-branch:1.31.0.6
	reverse-20081226-branchpoint:1.31
	multiprocess-20081120-branch:1.31.0.4
	multiprocess-20081120-branchpoint:1.31
	reverse-20080930-branch:1.31.0.2
	reverse-20080930-branchpoint:1.31
	reverse-20080717-branch:1.30.0.6
	reverse-20080717-branchpoint:1.30
	msnyder-reverse-20080609-branch:1.30.0.4
	msnyder-reverse-20080609-branchpoint:1.30
	drow-reverse-20070409-branch:1.28.0.2
	drow-reverse-20070409-branchpoint:1.28
	gdb_6_8-2008-03-27-release:1.30
	gdb_6_8-branch:1.30.0.2
	gdb_6_8-2008-02-26-branchpoint:1.30
	gdb_6_7_1-2007-10-29-release:1.29
	gdb_6_7-2007-10-10-release:1.29
	gdb_6_7-branch:1.29.0.2
	gdb_6_7-2007-09-07-branchpoint:1.29
	insight_6_6-20070208-release:1.27
	gdb_6_6-2006-12-18-release:1.27
	gdb_6_6-branch:1.27.0.2
	gdb_6_6-2006-11-15-branchpoint:1.27
	insight_6_5-20061003-release:1.26
	gdb-csl-symbian-6_4_50_20060226-12:1.26
	gdb-csl-sourcerygxx-3_4_4-25:1.25
	nickrob-async-20060828-mergepoint:1.27
	gdb-csl-symbian-6_4_50_20060226-11:1.26
	gdb-csl-sourcerygxx-4_1-17:1.26
	gdb-csl-20060226-branch-local-2:1.26
	gdb-csl-sourcerygxx-4_1-14:1.26
	gdb-csl-sourcerygxx-4_1-13:1.26
	gdb-csl-sourcerygxx-4_1-12:1.26
	gdb-csl-sourcerygxx-3_4_4-21:1.26
	gdb_6_5-20060621-release:1.26
	gdb-csl-sourcerygxx-4_1-9:1.26
	gdb-csl-sourcerygxx-4_1-8:1.26
	gdb-csl-sourcerygxx-4_1-7:1.26
	gdb-csl-arm-2006q1-6:1.26
	gdb-csl-sourcerygxx-4_1-6:1.26
	gdb-csl-symbian-6_4_50_20060226-10:1.26
	gdb-csl-symbian-6_4_50_20060226-9:1.26
	gdb-csl-symbian-6_4_50_20060226-8:1.26
	gdb-csl-coldfire-4_1-11:1.26
	gdb-csl-sourcerygxx-3_4_4-19:1.26
	gdb-csl-coldfire-4_1-10:1.26
	gdb_6_5-branch:1.26.0.16
	gdb_6_5-2006-05-14-branchpoint:1.26
	gdb-csl-sourcerygxx-4_1-5:1.26
	nickrob-async-20060513-branch:1.26.0.14
	nickrob-async-20060513-branchpoint:1.26
	gdb-csl-sourcerygxx-4_1-4:1.26
	msnyder-reverse-20060502-branch:1.26.0.12
	msnyder-reverse-20060502-branchpoint:1.26
	gdb-csl-morpho-4_1-4:1.26
	gdb-csl-sourcerygxx-3_4_4-17:1.26
	readline_5_1-import-branch:1.26.0.10
	readline_5_1-import-branchpoint:1.26
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.26
	gdb-csl-symbian-20060226-branch:1.26.0.8
	gdb-csl-symbian-20060226-branchpoint:1.26
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.26
	msnyder-reverse-20060331-branch:1.26.0.6
	msnyder-reverse-20060331-branchpoint:1.26
	gdb-csl-available-20060303-branch:1.26.0.4
	gdb-csl-available-20060303-branchpoint:1.26
	gdb-csl-20060226-branch:1.26.0.2
	gdb-csl-20060226-branchpoint:1.26
	gdb_6_4-20051202-release:1.25
	msnyder-fork-checkpoint-branch:1.25.0.10
	msnyder-fork-checkpoint-branchpoint:1.25
	gdb-csl-gxxpro-6_3-branch:1.25.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.25
	gdb_6_4-branch:1.25.0.6
	gdb_6_4-2005-11-01-branchpoint:1.25
	gdb-csl-arm-20051020-branch:1.25.0.4
	gdb-csl-arm-20051020-branchpoint:1.25
	msnyder-tracepoint-checkpoint-branch:1.25.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.25
	gdb-csl-arm-20050325-2005-q1b:1.23
	gdb-csl-arm-20050325-2005-q1a:1.23
	csl-arm-20050325-branch:1.23.0.2
	csl-arm-20050325-branchpoint:1.23
	gdb-post-i18n-errorwarning-20050211:1.19
	gdb-pre-i18n-errorwarning-20050211:1.19
	gdb_6_3-20041109-release:1.19
	gdb_6_3-branch:1.19.0.2
	gdb_6_3-20041019-branchpoint:1.19
	drow_intercu-merge-20040921:1.19
	drow_intercu-merge-20040915:1.19
	jimb-gdb_6_2-e500-branch:1.18.0.22
	jimb-gdb_6_2-e500-branchpoint:1.18
	gdb_6_2-20040730-release:1.18
	gdb_6_2-branch:1.18.0.18
	gdb_6_2-2004-07-10-gmt-branchpoint:1.18
	gdb_6_1_1-20040616-release:1.18
	gdb_6_1-2004-04-05-release:1.18
	drow_intercu-merge-20040402:1.18
	drow_intercu-merge-20040327:1.18
	ezannoni_pie-20040323-branch:1.18.0.16
	ezannoni_pie-20040323-branchpoint:1.18
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.18.0.14
	cagney_tramp-20040309-branchpoint:1.18
	gdb_6_1-branch:1.18.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.18
	drow_intercu-20040221-branch:1.18.0.10
	drow_intercu-20040221-branchpoint:1.18
	cagney_bfdfile-20040213-branch:1.18.0.8
	cagney_bfdfile-20040213-branchpoint:1.18
	drow-cplus-merge-20040208:1.18
	carlton_dictionary-20040126-merge:1.18
	cagney_bigcore-20040122-branch:1.18.0.6
	cagney_bigcore-20040122-branchpoint:1.18
	drow-cplus-merge-20040113:1.18
	drow-cplus-merge-20031224:1.18
	drow-cplus-merge-20031220:1.18
	carlton_dictionary-20031215-merge:1.18
	drow-cplus-merge-20031214:1.18
	carlton-dictionary-20031111-merge:1.18
	gdb_6_0-2003-10-04-release:1.15
	kettenis_sparc-20030918-branch:1.18.0.4
	kettenis_sparc-20030918-branchpoint:1.18
	carlton_dictionary-20030917-merge:1.18
	ezannoni_pie-20030916-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.2
	cagney_x86i386-20030821-branch:1.15.0.62
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.60
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.15.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.15
	cagney_convert-20030606-branch:1.15.0.56
	cagney_convert-20030606-branchpoint:1.15
	cagney_writestrings-20030508-branch:1.15.0.54
	cagney_writestrings-20030508-branchpoint:1.15
	jimb-ppc64-linux-20030528-branch:1.15.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.15
	carlton_dictionary-20030523-merge:1.15
	cagney_fileio-20030521-branch:1.15.0.50
	cagney_fileio-20030521-branchpoint:1.15
	kettenis_i386newframe-20030517-mergepoint:1.15
	jimb-ppc64-linux-20030509-branch:1.15.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.15
	kettenis_i386newframe-20030504-mergepoint:1.15
	carlton_dictionary-20030430-merge:1.15
	kettenis_i386newframe-20030419-branch:1.15.0.46
	kettenis_i386newframe-20030419-branchpoint:1.15
	carlton_dictionary-20030416-merge:1.15
	cagney_frameaddr-20030409-mergepoint:1.15
	kettenis_i386newframe-20030406-branch:1.15.0.44
	kettenis_i386newframe-20030406-branchpoint:1.15
	cagney_frameaddr-20030403-branchpoint:1.15
	cagney_frameaddr-20030403-branch:1.15.0.42
	cagney_framebase-20030330-mergepoint:1.15
	cagney_framebase-20030326-branch:1.15.0.40
	cagney_framebase-20030326-branchpoint:1.15
	cagney_lazyid-20030317-branch:1.15.0.38
	cagney_lazyid-20030317-branchpoint:1.15
	kettenis-i386newframe-20030316-mergepoint:1.15
	offbyone-20030313-branch:1.15.0.36
	offbyone-20030313-branchpoint:1.15
	kettenis-i386newframe-20030308-branch:1.15.0.34
	kettenis-i386newframe-20030308-branchpoint:1.15
	carlton_dictionary-20030305-merge:1.15
	cagney_offbyone-20030303-branch:1.15.0.32
	cagney_offbyone-20030303-branchpoint:1.15
	carlton_dictionary-20030207-merge:1.15
	interps-20030203-mergepoint:1.15
	interps-20030202-branch:1.15.0.30
	interps-20030202-branchpoint:1.15
	cagney-unwind-20030108-branch:1.15.0.28
	cagney-unwind-20030108-branchpoint:1.15
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.15
	carlton_dictionary-20021115-merge:1.15
	kseitz_interps-20021105-merge:1.15
	kseitz_interps-20021103-merge:1.15
	drow-cplus-merge-20021020:1.15
	drow-cplus-merge-20021025:1.15
	carlton_dictionary-20021025-merge:1.15
	carlton_dictionary-20021011-merge:1.15
	drow-cplus-branch:1.15.0.26
	drow-cplus-branchpoint:1.15
	kseitz_interps-20020930-merge:1.15
	carlton_dictionary-20020927-merge:1.15
	carlton_dictionary-branch:1.15.0.24
	carlton_dictionary-20020920-branchpoint:1.15
	gdb_5_3-branch:1.15.0.22
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.15
	cagney_sysregs-20020825-branch:1.15.0.20
	cagney_sysregs-20020825-branchpoint:1.15
	readline_4_3-import-branch:1.15.0.18
	readline_4_3-import-branchpoint:1.15
	gdb_5_2_1-2002-07-23-release:1.15
	kseitz_interps-20020528-branch:1.15.0.16
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.14
	cagney_regbuf-20020515-branchpoint:1.15
	jimb-macro-020506-branch:1.15.0.12
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.15
	gdb_5_2-branch:1.15.0.10
	gdb_5_2-2002-03-03-branchpoint:1.15
	gdb_5_1_1-2002-01-24-release:1.15
	gdb_5_1_0_1-2002-01-03-release:1.15
	cygnus_cvs_20020108_pre:1.15
	gdb_5_1_0_1-2002-01-03-branchpoint:1.15
	gdb_5_1_0_1-2002-01-03-branch:1.15.0.8
	gdb_5_1-2001-11-21-release:1.15
	gdb_s390-2001-09-26-branch:1.15.0.6
	gdb_s390-2001-09-26-branchpoint:1.15
	gdb_5_1-2001-07-29-branch:1.15.0.4
	gdb_5_1-2001-07-29-branchpoint:1.15
	dberlin-typesystem-branch:1.15.0.2
	dberlin-typesystem-branchpoint:1.15
	gdb-post-ptid_t-2001-05-03:1.15
	gdb-pre-ptid_t-2001-05-03:1.15
	insight-precleanup-2001-01-01:1.11
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.5
	gdb_5_0-2000-05-19-release:1.1.1.5
	gdb_4_18_2-2000-05-18-release:1.1.1.5
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.5
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.5
	gdb_5_0-2000-04-10-branch:1.1.1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.5
	repo-unification-2000-02-06:1.1.1.5
	insight-2000-02-04:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.50
date	2013.03.26.19.16.05;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2013.01.01.06.32.41;	author brobecke;	state Exp;
branches;
next	1.48;

1.48
date	2012.11.09.19.57.58;	author tromey;	state Exp;
branches;
next	1.47;

1.47
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.46;

1.46
date	2011.07.26.15.24.02;	author ppluzhnikov;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.44;

1.44
date	2011.01.01.15.32.59;	author brobecke;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.14.17.53.15;	author msnyder;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.05.20.50.24;	author msnyder;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.19.09.39.11;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.13.23.26.19;	author devans;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.13.18.51.08;	author devans;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.10.18.36.50;	author msnyder;	state Exp;
branches;
next	1.36;

1.36
date	2009.08.31.20.18.45;	author devans;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2009.08.20.23.30.15;	author devans;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.20.22.30.12;	author devans;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.23.18.35.29;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2007.08.23.18.08.28;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.15.18.46.24;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches
	1.26.14.1;
next	1.25;

1.25
date	2005.05.23.19.32.27;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.16.04.45.42;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.24.13.51.31;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.18.15.25.25;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.15.15.49.08;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.12.00.39.18;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.26.14.52.59;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.16.18.56.34;	author cagney;	state Exp;
branches
	1.18.10.1;
next	1.17;

1.17
date	2003.09.14.22.35.33;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.06.22.43.55;	author jtc;	state Exp;
branches
	1.15.24.1
	1.15.26.1
	1.15.54.1;
next	1.14;

1.14
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.24.21.01.02;	author jtc;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.03.22.00.56;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.01.00.12.10;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.18.22.52.22;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.11.14.47.38;	author jtc;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.10.18.54.27;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.19.18.59.07;	author jtc;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.46.2.1
date	2012.01.06.04.43.06;	author brobecke;	state Exp;
branches;
next	;

1.36.2.1
date	2009.12.21.05.41.38;	author brobecke;	state Exp;
branches;
next	;

1.26.14.1
date	2006.08.28.07.48.49;	author nickrob;	state Exp;
branches;
next	;

1.18.10.1
date	2004.09.16.17.01.01;	author drow;	state Exp;
branches;
next	;

1.15.24.1
date	2003.09.17.21.28.14;	author carlton;	state Exp;
branches;
next	;

1.15.26.1
date	2003.12.14.20.27.10;	author drow;	state Exp;
branches;
next	;

1.15.54.1
date	2003.06.03.20.54.33;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.04.47;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.08.23.59.03;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.10.19.02.46.35;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.12.07.03.55.58;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Make "set/show dcache line-size" and "set/show dcache size" zinteger commands instead of uinteger.

It doesn't make sense to request an "unlimited" dcache.  You want to
configure the cache with specific lines and length of lines.

It doesn't actually work anyway:

  (gdb) set dcache line-size 0
  Invalid dcache line size: 4294967295 (must be power of 2).

  (gdb) set dcache size 0
  (gdb) show dcache size
  Number of dcache lines is unlimited.

  (gdb) info dcache
  Dcache 4294967295 lines of 64 bytes each.
  No data cache available.

The code already has guards in place to forbid 0s:

static void
set_dcache_size (char *args, int from_tty,
		 struct cmd_list_element *c)
{
  if (dcache_size == 0)
    {
      dcache_size = DCACHE_DEFAULT_SIZE;
      error (_("Dcache size must be greater than 0."));
    }
  if (last_cache)
    dcache_invalidate (last_cache);
}

static void
set_dcache_line_size (char *args, int from_tty,
		      struct cmd_list_element *c)
{
  if (dcache_line_size < 2
      || (dcache_line_size & (dcache_line_size - 1)) != 0)
    {
      unsigned d = dcache_line_size;
      dcache_line_size = DCACHE_DEFAULT_LINE_SIZE;
      error (_("Invalid dcache line size: %u (must be power of 2)."), d);
    }
  if (last_cache)
    dcache_invalidate (last_cache);
}

So we now get:

  (gdb) set dcache line-size 0
  Invalid dcache line size: 0 (must be power of 2).
  (gdb) set dcache size 0
  Dcache size must be greater than 0.

gdb/
2013-03-26  Pedro Alves  <palves@@redhat.com>

	* dcache.c (_initialize_dcache): Make the "set dcache line-size"
	and "set dcache size" commands zuinteger instead of uinteger.
@
text
@/* Caching code for GDB, the GNU debugger.

   Copyright (C) 1992-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "dcache.h"
#include "gdbcmd.h"
#include "gdb_string.h"
#include "gdbcore.h"
#include "target.h"
#include "inferior.h"
#include "splay-tree.h"

/* Commands with a prefix of `{set,show} dcache'.  */
static struct cmd_list_element *dcache_set_list = NULL;
static struct cmd_list_element *dcache_show_list = NULL;

/* The data cache could lead to incorrect results because it doesn't
   know about volatile variables, thus making it impossible to debug
   functions which use memory mapped I/O devices.  Set the nocache
   memory region attribute in those cases.

   In general the dcache speeds up performance.  Some speed improvement
   comes from the actual caching mechanism, but the major gain is in
   the reduction of the remote protocol overhead; instead of reading
   or writing a large area of memory in 4 byte requests, the cache
   bundles up the requests into LINE_SIZE chunks, reducing overhead
   significantly.  This is most useful when accessing a large amount
   of data, such as when performing a backtrace.

   The cache is a splay tree along with a linked list for replacement.
   Each block caches a LINE_SIZE area of memory.  Within each line we
   remember the address of the line (which must be a multiple of
   LINE_SIZE) and the actual data block.

   Lines are only allocated as needed, so DCACHE_SIZE really specifies the
   *maximum* number of lines in the cache.

   At present, the cache is write-through rather than writeback: as soon
   as data is written to the cache, it is also immediately written to
   the target.  Therefore, cache lines are never "dirty".  Whether a given
   line is valid or not depends on where it is stored in the dcache_struct;
   there is no per-block valid flag.  */

/* NOTE: Interaction of dcache and memory region attributes

   As there is no requirement that memory region attributes be aligned
   to or be a multiple of the dcache page size, dcache_read_line() and
   dcache_write_line() must break up the page by memory region.  If a
   chunk does not have the cache attribute set, an invalid memory type
   is set, etc., then the chunk is skipped.  Those chunks are handled
   in target_xfer_memory() (or target_xfer_memory_partial()).

   This doesn't occur very often.  The most common occurance is when
   the last bit of the .text segment and the first bit of the .data
   segment fall within the same dcache page with a ro/cacheable memory
   region defined for the .text segment and a rw/non-cacheable memory
   region defined for the .data segment.  */

/* The maximum number of lines stored.  The total size of the cache is
   equal to DCACHE_SIZE times LINE_SIZE.  */
#define DCACHE_DEFAULT_SIZE 4096
static unsigned dcache_size = DCACHE_DEFAULT_SIZE;

/* The default size of a cache line.  Smaller values reduce the time taken to
   read a single byte and make the cache more granular, but increase
   overhead and reduce the effectiveness of the cache as a prefetcher.  */
#define DCACHE_DEFAULT_LINE_SIZE 64
static unsigned dcache_line_size = DCACHE_DEFAULT_LINE_SIZE;

/* Each cache block holds LINE_SIZE bytes of data
   starting at a multiple-of-LINE_SIZE address.  */

#define LINE_SIZE_MASK(dcache)  ((dcache->line_size - 1))
#define XFORM(dcache, x) 	((x) & LINE_SIZE_MASK (dcache))
#define MASK(dcache, x)         ((x) & ~LINE_SIZE_MASK (dcache))

struct dcache_block
{
  /* For least-recently-allocated and free lists.  */
  struct dcache_block *prev;
  struct dcache_block *next;

  CORE_ADDR addr;		/* address of data */
  int refs;			/* # hits */
  gdb_byte data[1];		/* line_size bytes at given address */
};

struct dcache_struct
{
  splay_tree tree;
  struct dcache_block *oldest; /* least-recently-allocated list.  */

  /* The free list is maintained identically to OLDEST to simplify
     the code: we only need one set of accessors.  */
  struct dcache_block *freelist;

  /* The number of in-use lines in the cache.  */
  int size;
  CORE_ADDR line_size;  /* current line_size.  */

  /* The ptid of last inferior to use cache or null_ptid.  */
  ptid_t ptid;
};

typedef void (block_func) (struct dcache_block *block, void *param);

static struct dcache_block *dcache_hit (DCACHE *dcache, CORE_ADDR addr);

static int dcache_read_line (DCACHE *dcache, struct dcache_block *db);

static struct dcache_block *dcache_alloc (DCACHE *dcache, CORE_ADDR addr);

static void dcache_info (char *exp, int tty);

void _initialize_dcache (void);

static int dcache_enabled_p = 0; /* OBSOLETE */

static void
show_dcache_enabled_p (struct ui_file *file, int from_tty,
		       struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Deprecated remotecache flag is %s.\n"), value);
}

static DCACHE *last_cache; /* Used by info dcache.  */

/* Add BLOCK to circular block list BLIST, behind the block at *BLIST.
   *BLIST is not updated (unless it was previously NULL of course).
   This is for the least-recently-allocated list's sake:
   BLIST points to the oldest block.
   ??? This makes for poor cache usage of the free list,
   but is it measurable?  */

static void
append_block (struct dcache_block **blist, struct dcache_block *block)
{
  if (*blist)
    {
      block->next = *blist;
      block->prev = (*blist)->prev;
      block->prev->next = block;
      (*blist)->prev = block;
      /* We don't update *BLIST here to maintain the invariant that for the
	 least-recently-allocated list *BLIST points to the oldest block.  */
    }
  else
    {
      block->next = block;
      block->prev = block;
      *blist = block;
    }
}

/* Remove BLOCK from circular block list BLIST.  */

static void
remove_block (struct dcache_block **blist, struct dcache_block *block)
{
  if (block->next == block)
    {
      *blist = NULL;
    }
  else
    {
      block->next->prev = block->prev;
      block->prev->next = block->next;
      /* If we removed the block *BLIST points to, shift it to the next block
	 to maintain the invariant that for the least-recently-allocated list
	 *BLIST points to the oldest block.  */
      if (*blist == block)
	*blist = block->next;
    }
}

/* Iterate over all elements in BLIST, calling FUNC.
   PARAM is passed to FUNC.
   FUNC may remove the block it's passed, but only that block.  */

static void
for_each_block (struct dcache_block **blist, block_func *func, void *param)
{
  struct dcache_block *db;

  if (*blist == NULL)
    return;

  db = *blist;
  do
    {
      struct dcache_block *next = db->next;

      func (db, param);
      db = next;
    }
  while (*blist && db != *blist);
}

/* BLOCK_FUNC routine for dcache_free.  */

static void
free_block (struct dcache_block *block, void *param)
{
  xfree (block);
}

/* Free a data cache.  */

void
dcache_free (DCACHE *dcache)
{
  if (last_cache == dcache)
    last_cache = NULL;

  splay_tree_delete (dcache->tree);
  for_each_block (&dcache->oldest, free_block, NULL);
  for_each_block (&dcache->freelist, free_block, NULL);
  xfree (dcache);
}


/* BLOCK_FUNC function for dcache_invalidate.
   This doesn't remove the block from the oldest list on purpose.
   dcache_invalidate will do it later.  */

static void
invalidate_block (struct dcache_block *block, void *param)
{
  DCACHE *dcache = (DCACHE *) param;

  splay_tree_remove (dcache->tree, (splay_tree_key) block->addr);
  append_block (&dcache->freelist, block);
}

/* Free all the data cache blocks, thus discarding all cached data.  */

void
dcache_invalidate (DCACHE *dcache)
{
  for_each_block (&dcache->oldest, invalidate_block, dcache);

  dcache->oldest = NULL;
  dcache->size = 0;
  dcache->ptid = null_ptid;

  if (dcache->line_size != dcache_line_size)
    {
      /* We've been asked to use a different line size.
	 All of our freelist blocks are now the wrong size, so free them.  */

      for_each_block (&dcache->freelist, free_block, dcache);
      dcache->freelist = NULL;
      dcache->line_size = dcache_line_size;
    }
}

/* Invalidate the line associated with ADDR.  */

static void
dcache_invalidate_line (DCACHE *dcache, CORE_ADDR addr)
{
  struct dcache_block *db = dcache_hit (dcache, addr);

  if (db)
    {
      splay_tree_remove (dcache->tree, (splay_tree_key) db->addr);
      remove_block (&dcache->oldest, db);
      append_block (&dcache->freelist, db);
      --dcache->size;
    }
}

/* If addr is present in the dcache, return the address of the block
   containing it.  Otherwise return NULL.  */

static struct dcache_block *
dcache_hit (DCACHE *dcache, CORE_ADDR addr)
{
  struct dcache_block *db;

  splay_tree_node node = splay_tree_lookup (dcache->tree,
					    (splay_tree_key) MASK (dcache, addr));

  if (!node)
    return NULL;

  db = (struct dcache_block *) node->value;
  db->refs++;
  return db;
}

/* Fill a cache line from target memory.
   The result is 1 for success, 0 if the (entire) cache line
   wasn't readable.  */

static int
dcache_read_line (DCACHE *dcache, struct dcache_block *db)
{
  CORE_ADDR memaddr;
  gdb_byte *myaddr;
  int len;
  int res;
  int reg_len;
  struct mem_region *region;

  len = dcache->line_size;
  memaddr = db->addr;
  myaddr  = db->data;

  while (len > 0)
    {
      /* Don't overrun if this block is right at the end of the region.  */
      region = lookup_mem_region (memaddr);
      if (region->hi == 0 || memaddr + len < region->hi)
	reg_len = len;
      else
	reg_len = region->hi - memaddr;

      /* Skip non-readable regions.  The cache attribute can be ignored,
         since we may be loading this for a stack access.  */
      if (region->attrib.mode == MEM_WO)
	{
	  memaddr += reg_len;
	  myaddr  += reg_len;
	  len     -= reg_len;
	  continue;
	}
      
      res = target_read (&current_target, TARGET_OBJECT_RAW_MEMORY,
			 NULL, myaddr, memaddr, reg_len);
      if (res < reg_len)
	return 0;

      memaddr += res;
      myaddr += res;
      len -= res;
    }

  return 1;
}

/* Get a free cache block, put or keep it on the valid list,
   and return its address.  */

static struct dcache_block *
dcache_alloc (DCACHE *dcache, CORE_ADDR addr)
{
  struct dcache_block *db;

  if (dcache->size >= dcache_size)
    {
      /* Evict the least recently allocated line.  */
      db = dcache->oldest;
      remove_block (&dcache->oldest, db);

      splay_tree_remove (dcache->tree, (splay_tree_key) db->addr);
    }
  else
    {
      db = dcache->freelist;
      if (db)
	remove_block (&dcache->freelist, db);
      else
	db = xmalloc (offsetof (struct dcache_block, data) +
		      dcache->line_size);

      dcache->size++;
    }

  db->addr = MASK (dcache, addr);
  db->refs = 0;

  /* Put DB at the end of the list, it's the newest.  */
  append_block (&dcache->oldest, db);

  splay_tree_insert (dcache->tree, (splay_tree_key) db->addr,
		     (splay_tree_value) db);

  return db;
}

/* Using the data cache DCACHE, store in *PTR the contents of the byte at
   address ADDR in the remote machine.  

   Returns 1 for success, 0 for error.  */

static int
dcache_peek_byte (DCACHE *dcache, CORE_ADDR addr, gdb_byte *ptr)
{
  struct dcache_block *db = dcache_hit (dcache, addr);

  if (!db)
    {
      db = dcache_alloc (dcache, addr);

      if (!dcache_read_line (dcache, db))
         return 0;
    }

  *ptr = db->data[XFORM (dcache, addr)];
  return 1;
}

/* Write the byte at PTR into ADDR in the data cache.

   The caller is responsible for also promptly writing the data
   through to target memory.

   If addr is not in cache, this function does nothing; writing to
   an area of memory which wasn't present in the cache doesn't cause
   it to be loaded in.

   Always return 1 (meaning success) to simplify dcache_xfer_memory.  */

static int
dcache_poke_byte (DCACHE *dcache, CORE_ADDR addr, gdb_byte *ptr)
{
  struct dcache_block *db = dcache_hit (dcache, addr);

  if (db)
    db->data[XFORM (dcache, addr)] = *ptr;

  return 1;
}

static int
dcache_splay_tree_compare (splay_tree_key a, splay_tree_key b)
{
  if (a > b)
    return 1;
  else if (a == b)
    return 0;
  else
    return -1;
}

/* Allocate and initialize a data cache.  */

DCACHE *
dcache_init (void)
{
  DCACHE *dcache;

  dcache = (DCACHE *) xmalloc (sizeof (*dcache));

  dcache->tree = splay_tree_new (dcache_splay_tree_compare,
				 NULL,
				 NULL);

  dcache->oldest = NULL;
  dcache->freelist = NULL;
  dcache->size = 0;
  dcache->line_size = dcache_line_size;
  dcache->ptid = null_ptid;
  last_cache = dcache;

  return dcache;
}


/* Read or write LEN bytes from inferior memory at MEMADDR, transferring
   to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is
   nonzero. 

   Return the number of bytes actually transfered, or -1 if the
   transfer is not supported or otherwise fails.  Return of a non-negative
   value less than LEN indicates that no further transfer is possible.
   NOTE: This is different than the to_xfer_partial interface, in which
   positive values less than LEN mean further transfers may be possible.  */

int
dcache_xfer_memory (struct target_ops *ops, DCACHE *dcache,
		    CORE_ADDR memaddr, gdb_byte *myaddr,
		    int len, int should_write)
{
  int i;
  int res;
  int (*xfunc) (DCACHE *dcache, CORE_ADDR addr, gdb_byte *ptr);

  xfunc = should_write ? dcache_poke_byte : dcache_peek_byte;

  /* If this is a different inferior from what we've recorded,
     flush the cache.  */

  if (! ptid_equal (inferior_ptid, dcache->ptid))
    {
      dcache_invalidate (dcache);
      dcache->ptid = inferior_ptid;
    }

  /* Do write-through first, so that if it fails, we don't write to
     the cache at all.  */

  if (should_write)
    {
      res = target_write (ops, TARGET_OBJECT_RAW_MEMORY,
			  NULL, myaddr, memaddr, len);
      if (res <= 0)
	return res;
      /* Update LEN to what was actually written.  */
      len = res;
    }
      
  for (i = 0; i < len; i++)
    {
      if (!xfunc (dcache, memaddr + i, myaddr + i))
	{
	  /* That failed.  Discard its cache line so we don't have a
	     partially read line.  */
	  dcache_invalidate_line (dcache, memaddr + i);
	  /* If we're writing, we still wrote LEN bytes.  */
	  if (should_write)
	    return len;
	  else
	    return i;
	}
    }
    
  return len;
}

/* FIXME: There would be some benefit to making the cache write-back and
   moving the writeback operation to a higher layer, as it could occur
   after a sequence of smaller writes have been completed (as when a stack
   frame is constructed for an inferior function call).  Note that only
   moving it up one level to target_xfer_memory[_partial]() is not
   sufficient since we want to coalesce memory transfers that are
   "logically" connected but not actually a single call to one of the
   memory transfer functions.  */

/* Just update any cache lines which are already present.  This is called
   by memory_xfer_partial in cases where the access would otherwise not go
   through the cache.  */

void
dcache_update (DCACHE *dcache, CORE_ADDR memaddr, gdb_byte *myaddr, int len)
{
  int i;

  for (i = 0; i < len; i++)
    dcache_poke_byte (dcache, memaddr + i, myaddr + i);
}

static void
dcache_print_line (int index)
{
  splay_tree_node n;
  struct dcache_block *db;
  int i, j;

  if (!last_cache)
    {
      printf_filtered (_("No data cache available.\n"));
      return;
    }

  n = splay_tree_min (last_cache->tree);

  for (i = index; i > 0; --i)
    {
      if (!n)
	break;
      n = splay_tree_successor (last_cache->tree, n->key);
    }

  if (!n)
    {
      printf_filtered (_("No such cache line exists.\n"));
      return;
    }
    
  db = (struct dcache_block *) n->value;

  printf_filtered (_("Line %d: address %s [%d hits]\n"),
		   index, paddress (target_gdbarch (), db->addr), db->refs);

  for (j = 0; j < last_cache->line_size; j++)
    {
      printf_filtered ("%02x ", db->data[j]);

      /* Print a newline every 16 bytes (48 characters).  */
      if ((j % 16 == 15) && (j != last_cache->line_size - 1))
	printf_filtered ("\n");
    }
  printf_filtered ("\n");
}

static void
dcache_info (char *exp, int tty)
{
  splay_tree_node n;
  int i, refcount;

  if (exp)
    {
      char *linestart;

      i = strtol (exp, &linestart, 10);
      if (linestart == exp || i < 0)
	{
	  printf_filtered (_("Usage: info dcache [linenumber]\n"));
          return;
	}

      dcache_print_line (i);
      return;
    }

  printf_filtered (_("Dcache %u lines of %u bytes each.\n"),
		   dcache_size,
		   last_cache ? (unsigned) last_cache->line_size
		   : dcache_line_size);

  if (!last_cache || ptid_equal (last_cache->ptid, null_ptid))
    {
      printf_filtered (_("No data cache available.\n"));
      return;
    }

  printf_filtered (_("Contains data for %s\n"),
		   target_pid_to_str (last_cache->ptid));

  refcount = 0;

  n = splay_tree_min (last_cache->tree);
  i = 0;

  while (n)
    {
      struct dcache_block *db = (struct dcache_block *) n->value;

      printf_filtered (_("Line %d: address %s [%d hits]\n"),
		       i, paddress (target_gdbarch (), db->addr), db->refs);
      i++;
      refcount += db->refs;

      n = splay_tree_successor (last_cache->tree, n->key);
    }

  printf_filtered (_("Cache state: %d active lines, %d hits\n"), i, refcount);
}

static void
set_dcache_size (char *args, int from_tty,
		 struct cmd_list_element *c)
{
  if (dcache_size == 0)
    {
      dcache_size = DCACHE_DEFAULT_SIZE;
      error (_("Dcache size must be greater than 0."));
    }
  if (last_cache)
    dcache_invalidate (last_cache);
}

static void
set_dcache_line_size (char *args, int from_tty,
		      struct cmd_list_element *c)
{
  if (dcache_line_size < 2
      || (dcache_line_size & (dcache_line_size - 1)) != 0)
    {
      unsigned d = dcache_line_size;
      dcache_line_size = DCACHE_DEFAULT_LINE_SIZE;
      error (_("Invalid dcache line size: %u (must be power of 2)."), d);
    }
  if (last_cache)
    dcache_invalidate (last_cache);
}

static void
set_dcache_command (char *arg, int from_tty)
{
  printf_unfiltered (
     "\"set dcache\" must be followed by the name of a subcommand.\n");
  help_list (dcache_set_list, "set dcache ", -1, gdb_stdout);
}

static void
show_dcache_command (char *args, int from_tty)
{
  cmd_show_list (dcache_show_list, from_tty, "");
}

void
_initialize_dcache (void)
{
  add_setshow_boolean_cmd ("remotecache", class_support,
			   &dcache_enabled_p, _("\
Set cache use for remote targets."), _("\
Show cache use for remote targets."), _("\
This used to enable the data cache for remote targets.  The cache\n\
functionality is now controlled by the memory region system and the\n\
\"stack-cache\" flag; \"remotecache\" now does nothing and\n\
exists only for compatibility reasons."),
			   NULL,
			   show_dcache_enabled_p,
			   &setlist, &showlist);

  add_info ("dcache", dcache_info,
	    _("\
Print information on the dcache performance.\n\
With no arguments, this command prints the cache configuration and a\n\
summary of each line in the cache.  Use \"info dcache <lineno> to dump\"\n\
the contents of a given line."));

  add_prefix_cmd ("dcache", class_obscure, set_dcache_command, _("\
Use this command to set number of lines in dcache and line-size."),
		  &dcache_set_list, "set dcache ", /*allow_unknown*/0, &setlist);
  add_prefix_cmd ("dcache", class_obscure, show_dcache_command, _("\
Show dcachesettings."),
		  &dcache_show_list, "show dcache ", /*allow_unknown*/0, &showlist);

  add_setshow_zuinteger_cmd ("line-size", class_obscure,
			     &dcache_line_size, _("\
Set dcache line size in bytes (must be power of 2)."), _("\
Show dcache line size."),
			     NULL,
			     set_dcache_line_size,
			     NULL,
			     &dcache_set_list, &dcache_show_list);
  add_setshow_zuinteger_cmd ("size", class_obscure,
			     &dcache_size, _("\
Set number of dcache lines."), _("\
Show number of dcache lines."),
			     NULL,
			     set_dcache_size,
			     NULL,
			     &dcache_set_list, &dcache_show_list);
}
@


1.49
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d730 2
a731 2
  add_setshow_uinteger_cmd ("line-size", class_obscure,
			    &dcache_line_size, _("\
d734 6
a739 6
			    NULL,
			    set_dcache_line_size,
			    NULL,
			    &dcache_set_list, &dcache_show_list);
  add_setshow_uinteger_cmd ("size", class_obscure,
			    &dcache_size, _("\
d742 4
a745 4
			    NULL,
			    set_dcache_size,
			    NULL,
			    &dcache_set_list, &dcache_show_list);
@


1.48
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d3 1
a3 2
   Copyright (C) 1992-1993, 1995-1996, 1998-2001, 2003, 2007-2012 Free
   Software Foundation, Inc.
@


1.47
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d592 1
a592 1
		   index, paddress (target_gdbarch, db->addr), db->refs);
d650 1
a650 1
		       i, paddress (target_gdbarch, db->addr), db->refs);
@


1.46
log
@2011-07-26  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* NEWS: Mention dcache configuration.
	* dcache.c (dcache_set_list, dcache_show_list): New variables.
	(dcache_size, dcache_line_size): New variables.
	(LINE_SIZE_MASK, XFORM, MASK): Adjust.
	(struct dcache_block): Make it expandable.
	(struct dcache_struct): New field.
	(dcache_invalidate): Discard freelist upon dcache_line_size changes.
	(dcache_hit, dcache_alloc, dcache_peek_byte): Adjust.
	(dcache_poke_byte, dcache_print_line): Adjust.
	(set_dcache_size, set_dcache_line_size): New functions.
	(set_dcache_command, show_dcache_command): New functions.
	(_initialize_dcache): Add new commands.


doc/ChangeLog:

2011-07-26  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* gdb.texinfo (Caching Remote Data): Document {set,show} dcache
	size and line-size.
@
text
@d3 2
a4 2
   Copyright (C) 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2003, 2007,
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.46.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 2
   Copyright (C) 1992-1993, 1995-1996, 1998-2001, 2003, 2007-2012 Free
   Software Foundation, Inc.
@


1.45
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d30 4
d78 2
a79 1
#define DCACHE_SIZE 4096
d81 1
a81 1
/* The size of a cache line.  Smaller values reduce the time taken to
d84 2
a85 2
#define LINE_SIZE_POWER 6
#define LINE_SIZE (1 << LINE_SIZE_POWER)
d90 3
a92 3
#define LINE_SIZE_MASK  ((LINE_SIZE - 1))
#define XFORM(x) 	((x) & LINE_SIZE_MASK)
#define MASK(x)         ((x) & ~LINE_SIZE_MASK)
a100 1
  gdb_byte data[LINE_SIZE];	/* bytes at given address */
d102 1
d116 1
d216 23
d262 10
d299 1
a299 1
					    (splay_tree_key) MASK (addr));
d323 1
a323 1
  len = LINE_SIZE;
d367 1
a367 1
  if (dcache->size >= DCACHE_SIZE)
d381 2
a382 1
	db = xmalloc (sizeof (struct dcache_block));
d387 1
a387 1
  db->addr = MASK (addr);
d417 1
a417 1
  *ptr = db->data[XFORM (addr)];
d438 1
a438 1
    db->data[XFORM (addr)] = *ptr;
d470 1
a476 21
/* BLOCK_FUNC routine for dcache_free.  */

static void
free_block (struct dcache_block *block, void *param)
{
  free (block);
}

/* Free a data cache.  */

void
dcache_free (DCACHE *dcache)
{
  if (last_cache == dcache)
    last_cache = NULL;

  splay_tree_delete (dcache->tree);
  for_each_block (&dcache->oldest, free_block, NULL);
  for_each_block (&dcache->freelist, free_block, NULL);
  xfree (dcache);
}
d594 1
a594 1
  for (j = 0; j < LINE_SIZE; j++)
d599 1
a599 1
      if ((j % 16 == 15) && (j != LINE_SIZE - 1))
d626 4
a629 2
  printf_filtered (_("Dcache line width %d, maximum size %d\n"),
		   LINE_SIZE, DCACHE_SIZE);
d660 42
d723 24
@


1.44
log
@run copyright.sh for 2011.
@
text
@d91 1
a91 1
  /* for least-recently-allocated and free lists */
d103 1
a103 1
  struct dcache_block *oldest; /* least-recently-allocated list */
d137 1
a137 1
static DCACHE *last_cache; /* Used by info dcache */
d578 1
a578 1
      /* Print a newline every 16 bytes (48 characters) */
@


1.43
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* dbxread.c: White space.
	* dcache.c: White space.
	* disasm.c: White space.
	* doublest.c: White space.
	* dsrec.c: White space.
	* dummy-frame.c: White space.
	* dwarf2expr.c: White space.
	* dwarf2-frame.c: White space.
	* dwarf2loc.c: White space.
	* dwarf2read.c: White space.
@
text
@d4 1
a4 1
   2008, 2009, 2010 Free Software Foundation, Inc.
@


1.42
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* dcache.c (dcache_init): Delete unused variable.
	(dcache_info): Delete unused variable.
@
text
@d476 1
d536 1
d594 1
@


1.41
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@a419 1
  int i;
d587 1
a587 1
  int i, refcount, lineno;
@


1.40
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a119 2
static int dcache_write_line (DCACHE *dcache, struct dcache_block *db);

@


1.39
log
@	* dcache.c (dcache_hit, dcache_read_line): Tweak comments.
	(dcache_peek_byte, dcache_init, dcache_xfer_memory): Ditto.
	* target.c (memory_xfer_partial): Tweak comments.
	(target_xfer_partial, target_write_memory): Add comment.
	(target_read_partial): Remove note from 2003-10-21.
	(target_read, target_write): Add comments.
@
text
@d4 1
a4 1
   2008, 2009 Free Software Foundation, Inc.
@


1.38
log
@	* dcache.c (dcache_block): Replace member newer with next,prev.
	(dcache_struct): Delete member newest.
	(block_func): New typedef.
	(append_block, remove_block, for_each_block): New functions.
	(invalidate_block, free_block): New functions.
	(dcache_invalidate): Update
	(dcache_invalidate_line, dcache_alloc): Update to use new list
	accessors.
	(dcache_free): Ditto.  Fix memory leak.
@
text
@d254 1
a254 1
   containing it.  */
d272 3
a274 1
/* Fill a cache line from target memory.  */
d361 1
a361 1
/* Using the data cache DCACHE return the contents of the byte at
d416 1
a416 1
/* Initialize the data cache.  */
d465 5
a469 1
   The meaning of the result is the same as for target_write.  */
@


1.37
log
@2009-11-10  Michael Snyder  <msnyder@@vmware.com>

	* dcache.c: Fix typo, shorten long lines in comment.
@
text
@d91 4
a94 1
  struct dcache_block *newer;	/* for LRU and free list */
d103 1
a103 2
  struct dcache_block *oldest;
  struct dcache_block *newest;
d105 2
d116 2
d141 6
a146 1
/* Free all the data cache blocks, thus discarding all cached data.  */
d148 2
a149 2
void
dcache_invalidate (DCACHE *dcache)
d151 16
a166 1
  struct dcache_block *block, *next;
d168 1
a168 1
  block = dcache->oldest;
d170 8
a177 1
  while (block)
d179 9
a187 2
      splay_tree_remove (dcache->tree, (splay_tree_key) block->addr);
      next = block->newer;
d189 3
a191 2
      block->newer = dcache->freelist;
      dcache->freelist = block;
d193 15
a207 1
      block = next;
d209 22
a232 1
  dcache->newest = NULL;
d247 2
a248 2
      db->newer = dcache->freelist;
      dcache->freelist = db;
d330 1
a330 1
      /* Evict the least recently used line.  */
d332 1
a332 1
      dcache->oldest = db->newer;
d340 1
a340 1
        dcache->freelist = db->newer;
a347 1
  db->newer = NULL;
d350 2
a351 7
  if (dcache->newest)
    dcache->newest->newer = db;

  dcache->newest = db;

  if (!dcache->oldest)
    dcache->oldest = db;
a428 1
  dcache->newest = NULL;
d437 8
a449 2
  struct dcache_block *db, *next;

d454 2
a455 5
  for (db = dcache->freelist; db != NULL; db = next)
    {
      next = db->newer;
      xfree (db);
    }
@


1.36
log
@	Implement TARGET_OBJECT_STACK_MEMORY.
	* NEWS: Add note on new "set stack-cache" option.
	* corefile.c (read_stack): New function.
	* dcache.c (dcache_struct): New member ptid.
	(dcache_enable_p): Mark as obsolete.
	(show_dcache_enabled_p): Flag option as deprecated.
	(dcache_invalidate): Update ptid.
	(dcache_invalidate_line): New function.
	(dcache_read_line): No longer check cacheable attribute, stack
	accesses get cached despite attribute.
	(dcache_init): Set ptid.
	(dcache_xfer_memory): Flush cache if from different ptid than before.
	Update cache after write.
	(dcache_update): New function.
	(dcache_info): Report ptid.
	(_initialize_dcache): Update text for `remotecache' to indicate it
	is obsolete.
	* dcache.h (dcache_update): Declare.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Mark values on stack with
	set_value_stack.
	* frame-unwind.c (frame_unwind_got_memory): Ditto.
	* gdbcore.h (read_stack): Declare.
	* memattr.c (mem_enable_command): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(mem_disable_command, mem_delete_command): Ditto.
	* target.c (stack_cache_enabled_p_1): New static global.
	(stack_cache_enabled_p): New static global.
	(set_stack_cache_enabled_p): New function.
	(show_stack_cache_enabled_p): New function.
	(target_dcache): Make static.
	(target_dcache_invalidate): New function.
	(target_load, target_resume): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(memory_xfer_partial): New arg object, all callers updated.
	Check for existing inferior before calling dcache routines.
	When writing non-TARGET_OBJECT_STACK_MEMORY, notify dcache.
	(target_xfer_partial): Call memory_xfer_partial for
	TARGET_OBJECT_STACK_MEMORY.
	(target_read_stack): New function.
	(initialize_targets): Install new option `stack-cache'.
	* target.h: Remove #include of dcache.h.
	(enum target_object): New value TARGET_OBJECT_STACK_MEMORY.
	(target_dcache): Delete.
	(target_dcache_invalidate): Declare.
	(target_read_stack): Declare.
	* top.c (prepare_execute_command): New function.
	(execute_command): Call prepare_execute_command
	instead of free_all_values.
	* top.h (prepare_execute_command): Declare.
	* valops.c (get_value_at): New function.
	(value_at): Guts moved to get_value_at.
	(value_at_lazy): Similarly.
	(value_fetch_lazy): Call read_stack for stack values.
	* value.c (struct value): New member `stack'.
	(value_stack, set_value_stack): New functions.
	* value.h (value_stack, set_value_stack): Declare.
	* mi/mi-main.c (mi_cmd_execute): Call prepare_execute_command
	instead of free_all_values.

	doc/
	* gdb.texinfo (Caching Data of Remote Targets): Update text.
	Mark `set/show remotecache' options as obsolete.
	Document new `set/show stack-cache' option.
	Update text for `info dcache'.
@
text
@d44 3
a46 3
   Each block caches a LINE_SIZE area of memory.  Wtihin each line we remember
   the address of the line (which must be a multiple of LINE_SIZE) and the
   actual data block.
@


1.36.2.1
log
@        * dcache.c (dcache_block): Replace member newer with next,prev.
        (dcache_struct): Delete member newest.
        (block_func): New typedef.
        (append_block, remove_block, for_each_block): New functions.
        (invalidate_block, free_block): New functions.
        (dcache_invalidate): Update
        (dcache_invalidate_line, dcache_alloc): Update to use new list
        accessors.
        (dcache_free): Ditto.  Fix memory leak.
@
text
@d91 1
a91 4
  /* for least-recently-allocated and free lists */
  struct dcache_block *prev;
  struct dcache_block *next;

d100 2
a101 1
  struct dcache_block *oldest; /* least-recently-allocated list */
a102 2
  /* The free list is maintained identically to OLDEST to simplify
     the code: we only need one set of accessors.  */
a111 2
typedef void (block_func) (struct dcache_block *block, void *param);

d135 1
a135 3
/* Append BLOCK to circular block list starting at BLIST.
   The block is appended for the least-recently-allocated list's sake:
   BLIST points to the oldest block.  */
d137 2
a138 2
static void
append_block (struct dcache_block **blist, struct dcache_block *block)
d140 1
a140 16
  if (*blist)
    {
      block->next = *blist;
      block->prev = (*blist)->prev;
      block->prev->next = block;
      (*blist)->prev = block;
      /* We don't update *BLIST here to maintain the invariant that for the
	 least-recently-allocated list *BLIST points to the oldest block.  */
    }
  else
    {
      block->next = block;
      block->prev = block;
      *blist = block;
    }
}
d142 1
a142 1
/* Remove BLOCK from circular block list BLIST.  */
d144 1
a144 8
static void
remove_block (struct dcache_block **blist, struct dcache_block *block)
{
  if (block->next == block)
    {
      *blist = NULL;
    }
  else
d146 2
a147 9
      block->next->prev = block->prev;
      block->prev->next = block->next;
      /* If we removed the block *BLIST points to, shift it to the next block
	 to maintain the invariant that for the least-recently-allocated list
	 *BLIST points to the oldest block.  */
      if (*blist == block)
	*blist = block->next;
    }
}
d149 2
a150 3
/* Iterate over all elements in BLIST, calling FUNC.
   PARAM is passed to FUNC.
   FUNC may remove the block it's passed, but only that block.  */
d152 1
a152 15
static void
for_each_block (struct dcache_block **blist, block_func *func, void *param)
{
  struct dcache_block *db;

  if (*blist == NULL)
    return;

  db = *blist;
  do
    {
      struct dcache_block *next = db->next;

      func (db, param);
      db = next;
a153 20
  while (*blist && db != *blist);
}

/* BLOCK_FUNC function for dcache_invalidate.  */

static void
invalidate_block (struct dcache_block *block, void *param)
{
  DCACHE *dcache = (DCACHE *) param;

  splay_tree_remove (dcache->tree, (splay_tree_key) block->addr);
  append_block (&dcache->freelist, block);
}

/* Free all the data cache blocks, thus discarding all cached data.  */

void
dcache_invalidate (DCACHE *dcache)
{
  for_each_block (&dcache->oldest, invalidate_block, dcache);
d156 1
d171 2
a172 2
      remove_block (&dcache->oldest, db);
      append_block (&dcache->freelist, db);
d254 1
a254 1
      /* Evict the least recently allocated line.  */
d256 1
a256 1
      remove_block (&dcache->oldest, db);
d264 1
a264 1
	remove_block (&dcache->freelist, db);
d272 1
d275 7
a281 2
  /* Put DB at the end of the list, it's the newest.  */
  append_block (&dcache->oldest, db);
d359 1
a367 8
/* BLOCK_FUNC routine for dcache_free.  */

static void
free_block (struct dcache_block *block, void *param)
{
  free (block);
}

d373 2
d379 5
a383 2
  for_each_block (&dcache->oldest, free_block, NULL);
  for_each_block (&dcache->freelist, free_block, NULL);
@


1.35
log
@* dcache.c (dcache_print_line, dcache_info): Use paddress to print addresses.
@
text
@d27 1
d107 3
d124 1
a124 1
static int dcache_enabled_p = 0;
d130 1
a130 1
  fprintf_filtered (file, _("Cache use for remote targets is %s.\n"), value);
a132 1

d158 17
d221 3
a223 2
      /* Skip non-cacheable/non-readable regions.  */
      if (!region->attrib.cache || region->attrib.mode == MEM_WO)
d320 1
a320 1
   Always return 1 to simplify dcache_xfer_memory.  */
d362 1
d391 1
a391 1
   Returns length of data written or read; 0 for error.  */
d403 9
d419 4
a422 2
      if (res < len)
	return 0;
d428 10
a437 1
	return 0;
d452 12
d531 1
a531 1
  if (!last_cache)
d537 3
d567 4
a570 5
When on, use data caching for remote targets.  For many remote targets\n\
this option can offer better throughput for reading target memory.\n\
Unfortunately, gdb does not currently know anything about volatile\n\
registers and thus data caching will produce incorrect results with\n\
volatile registers are in use.  By default, this option is off."),
@


1.34
log
@	Replace dcache with splay tree.
	Remove partially implemented writeback support.
	* dcache.c: Include splay-tree.h.
	(LINE_SIZE_POWER): Change from 5 to 6.
	(DCACHE_SIZE): Change from 64 to 4096.
	(ENTRY_INVALID, ENTRY_VALID, ENTRY_DIRTY): Delete.
	(state_chars): Delete.
	(struct dcache_block): Clean up; remove state and anydirty fields.
	(struct dcache_struct): Redefine as a splay tree and linked list.
	(last_cache): Make static.
	(dcache_invalidate, dcache_hit): Rewrite for new cache structure.
	(dcache_read_line, dcache_alloc): Rewrite for new cache structure.
	(dcache_write_line): Delete.
	(dcache_writeback): Delete.
	(dcache_peek_byte): Clean up; remove "invalid" state check.
	(dcache_poke_byte): Rewrite for new cache structure; clarify comment.
	(dcache_splay_tree_compare): New function.
	(dcache_init, dcache_free): Rewrite for new cache structure.
	(dcache_xfer_memory): Rewrite for new write-through cache structure.
	(dcache_print_line): New function.
	(dcache_info): Rewrite for new cache structure.
	(_initialize_dcache): Update "info dcache" help text.
	* dcache.h (dcache_xfer_memory): Update declaration.
	* target.c (memory_xfer_partial): Update calls to dcache_xfer_memory.
@
text
@d440 2
a441 2
  printf_filtered (_("Line %d: address %lx [%d hits]\n"),
		  index, db->addr, db->refs);
d492 2
a493 2
      printf_filtered (_("Line %d: address %lx [%d hits]\n"),
		       i, db->addr, db->refs);
@


1.33
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d27 1
d34 1
a34 1
   In general the dcache speeds up performance, some speed improvement
d38 17
a54 41
   bundles up the requests into 32 byte (actually LINE_SIZE) chunks.
   Reducing the overhead to an eighth of what it was.  This is very
   obvious when displaying a large amount of data,

   eg, x/200x 0 

   caching     |   no    yes 
   ---------------------------- 
   first time  |   4 sec  2 sec improvement due to chunking 
   second time |   4 sec  0 sec improvement due to caching

   The cache structure is unusual, we keep a number of cache blocks
   (DCACHE_SIZE) and each one caches a LINE_SIZEed area of memory.
   Within each line we remember the address of the line (always a
   multiple of the LINE_SIZE) and a vector of bytes over the range.
   There's another vector which contains the state of the bytes.

   ENTRY_INVALID means that the byte is just plain wrong, and has no
   correspondence with anything else (as it would when the cache is
   turned on, but nothing has been done to it).

   ENTRY_DIRTY means that the byte has some data in it which should be
   written out to the remote target one day, but contains correct
   data.

   ENTRY_VALID means that the data is the same in the cache as it is in
   remote memory.


   The ENTRY_DIRTY state is necessary because GDB likes to write large
   lumps of memory in small bits.  If the caching mechanism didn't
   maintain the DIRTY information, then something like a two byte
   write would mean that the entire cache line would have to be read,
   the two bytes modified and then written out again.  The alternative
   would be to not read in the cache line in the first place, and just
   write the two bytes directly into target memory.  The trouble with
   that is that it really nails performance, because of the remote
   protocol overhead.  This way, all those little writes are bundled
   up into an entire cache line write in one go, without having to
   read the cache line in the first place.
 */
d69 1
a69 1
   region defined for the .data segment. */
d71 8
a78 12
/* This value regulates the number of cache blocks stored.
   Smaller values reduce the time spent searching for a cache
   line, and reduce memory requirements, but increase the risk
   of a line not being in memory */

#define DCACHE_SIZE 64

/* This value regulates the size of a cache line.  Smaller values
   reduce the time taken to read a single byte, but reduce overall
   throughput.  */

#define LINE_SIZE_POWER (5)
a87 12

#define ENTRY_INVALID 0 /* data at this byte is wrong */
#define ENTRY_DIRTY   1 /* data at this byte needs to be written back */
#define ENTRY_VALID   2 /* data at this byte is same as in memory */

/* For cache state display by "info dcache".
   The letters I,D,V map to
   I = ENTRY_INVALID
   D = ENTRY_DIRTY
   V = ENTRY_VALID  */
static const char state_chars[3] = { 'I', 'D', 'V' };

d89 6
a94 26
  {
    struct dcache_block *p;	/* next in list */
    CORE_ADDR addr;		/* Address for which data is recorded.  */
    gdb_byte data[LINE_SIZE];	/* bytes at given address */
    unsigned char state[LINE_SIZE];	/* what state the data is in */

    /* whether anything in state is dirty - used to speed up the 
       dirty scan. */
    int anydirty;

    int refs;
  };


/* FIXME: dcache_struct used to have a cache_has_stuff field that was
   used to record whether the cache had been accessed.  This was used
   to invalidate the cache whenever caching was (re-)enabled (if the
   cache was disabled and later re-enabled, it could contain stale
   data).  This was not needed because the cache is write through and
   the code that enables, disables, and deletes memory region all
   invalidate the cache.

   This is overkill, since it also invalidates cache lines from
   unrelated regions.  One way this could be addressed by adding a
   new function that takes an address and a length and invalidates
   only those cache lines that match. */
d97 10
a106 12
  {
    /* free list */
    struct dcache_block *free_head;
    struct dcache_block *free_tail;

    /* in use list */
    struct dcache_block *valid_head;
    struct dcache_block *valid_tail;

    /* The cache itself. */
    struct dcache_block *the_cache;
  };
a115 2
static int dcache_writeback (DCACHE *dcache);

d130 1
a130 2
DCACHE *last_cache;		/* Used by info dcache */

d137 1
a137 3
  int i;
  dcache->valid_head = 0;
  dcache->valid_tail = 0;
d139 1
a139 2
  dcache->free_head = 0;
  dcache->free_tail = 0;
d141 1
a141 1
  for (i = 0; i < DCACHE_SIZE; i++)
d143 2
a144 1
      struct dcache_block *db = dcache->the_cache + i;
d146 4
a149 6
      if (!dcache->free_head)
	dcache->free_head = db;
      else
	dcache->free_tail->p = db;
      dcache->free_tail = db;
      db->p = 0;
d152 3
a154 1
  return;
d158 1
a158 1
   containing it. */
d165 2
a166 2
  /* Search all cache blocks for one that is at this address.  */
  db = dcache->valid_head;
d168 2
a169 9
  while (db)
    {
      if (MASK (addr) == db->addr)
	{
	  db->refs++;
	  return db;
	}
      db = db->p;
    }
d171 3
a173 1
  return NULL;
d176 1
a176 39
/* Make sure that anything in this line which needs to
   be written is. */

static int
dcache_write_line (DCACHE *dcache, struct dcache_block *db)
{
  CORE_ADDR memaddr;
  gdb_byte *myaddr;
  int len;
  int res;
  int reg_len;
  struct mem_region *region;

  if (!db->anydirty)
    return 1;

  len = LINE_SIZE;
  memaddr = db->addr;
  myaddr  = db->data;

  while (len > 0)
    {
      int s;
      int e;
      int dirty_len;
      
      region = lookup_mem_region(memaddr);
      if (memaddr + len < region->hi)
	reg_len = len;
      else
	reg_len = region->hi - memaddr;

      if (!region->attrib.cache || region->attrib.mode == MEM_RO)
	{
	  memaddr += reg_len;
	  myaddr  += reg_len;
	  len     -= reg_len;
	  continue;
	}
a177 40
      while (reg_len > 0)
	{
	  s = XFORM(memaddr);
	  while (reg_len > 0) {
	    if (db->state[s] == ENTRY_DIRTY)
	      break;
	    s++;
	    reg_len--;

	    memaddr++;
	    myaddr++;
	    len--;
	  }

	  e = s;
	  while (reg_len > 0) {
	    if (db->state[e] != ENTRY_DIRTY)
	      break;
	    e++;
	    reg_len--;
	  }

	  dirty_len = e - s;
	  res = target_write (&current_target, TARGET_OBJECT_RAW_MEMORY,
			      NULL, myaddr, memaddr, dirty_len);
	  if (res < dirty_len)
	    return 0;

	  memset (&db->state[XFORM(memaddr)], ENTRY_VALID, res);
	  memaddr += res;
	  myaddr += res;
	  len -= res;
	}
    }

  db->anydirty = 0;
  return 1;
}

/* Read cache line */
a187 8
  /* If there are any dirty bytes in the line, it must be written
     before a new line can be read */
  if (db->anydirty)
    {
      if (!dcache_write_line (dcache, db))
	return 0;
    }
  
d194 3
a196 2
      region = lookup_mem_region(memaddr);
      if (memaddr + len < region->hi)
d201 1
a219 3
  memset (db->state, ENTRY_VALID, sizeof (db->data));
  db->anydirty = 0;
  
d231 1
a231 3
  /* Take something from the free list */
  db = dcache->free_head;
  if (db)
d233 5
a237 1
      dcache->free_head = db->p;
d241 5
a245 2
      /* Nothing left on free list, so grab one from the valid list */
      db = dcache->valid_head;
d247 1
a247 4
      if (!dcache_write_line (dcache, db))
	return NULL;
      
      dcache->valid_head = db->p;
d250 2
a251 1
  db->addr = MASK(addr);
a252 2
  db->anydirty = 0;
  memset (db->state, ENTRY_INVALID, sizeof (db->data));
d254 2
a255 7
  /* append this line to end of valid list */
  if (!dcache->valid_head)
    dcache->valid_head = db;
  else
    dcache->valid_tail->p = db;
  dcache->valid_tail = db;
  db->p = 0;
d257 1
a257 2
  return db;
}
d259 2
a260 5
/* Writeback any dirty lines. */
static int
dcache_writeback (DCACHE *dcache)
{
  struct dcache_block *db;
d262 2
a263 1
  db = dcache->valid_head;
d265 1
a265 7
  while (db)
    {
      if (!dcache_write_line (dcache, db))
	return 0;
      db = db->p;
    }
  return 1;
a267 1

d271 1
a271 1
   Returns 0 on error. */
d281 2
a282 7
      if (!db)
	return 0;
    }
  
  if (db->state[XFORM (addr)] == ENTRY_INVALID)
    {
      if (!dcache_read_line(dcache, db))
d290 8
d299 1
a299 3
/* Write the byte at PTR into ADDR in the data cache.
   Return zero on write error.
 */
d306 2
a307 6
  if (!db)
    {
      db = dcache_alloc (dcache, addr);
      if (!db)
	return 0;
    }
a308 3
  db->data[XFORM (addr)] = *ptr;
  db->state[XFORM (addr)] = ENTRY_DIRTY;
  db->anydirty = 1;
d312 11
d324 1
a327 1
  int csize = sizeof (struct dcache_block) * DCACHE_SIZE;
d329 1
d333 9
a341 4
  dcache->the_cache = (struct dcache_block *) xmalloc (csize);
  memset (dcache->the_cache, 0, csize);

  dcache_invalidate (dcache);
a342 1
  last_cache = dcache;
d346 2
a347 1
/* Free a data cache */
d351 2
d356 6
a361 1
  xfree (dcache->the_cache);
d369 1
a369 3
   Returns length of data written or read; 0 for error.  

   This routine is indended to be called by remote_xfer_ functions. */
d372 2
a373 1
dcache_xfer_memory (DCACHE *dcache, CORE_ADDR memaddr, gdb_byte *myaddr,
d377 1
d381 11
d397 25
d423 1
a423 8
  /* FIXME: There may be some benefit from moving the cache writeback
     to a higher layer, as it could occur after a sequence of smaller
     writes have been completed (as when a stack frame is constructed
     for an inferior function call).  Note that only moving it up one
     level to target_xfer_memory() (also target_xfer_memory_partial())
     is not sufficent, since we want to coalesce memory transfers that
     are "logically" connected but not actually a single call to one
     of the memory transfer functions. */
d425 12
a436 2
  if (should_write)
    dcache_writeback (dcache);
d438 14
a451 1
  return len;
d457 16
a472 1
  struct dcache_block *p;
d474 1
a474 1
  printf_filtered (_("Dcache line width %d, depth %d\n"),
d477 1
a477 1
  if (last_cache)
d479 12
a490 1
      printf_filtered (_("Cache state:\n"));
d492 6
a497 14
      for (p = last_cache->valid_head; p; p = p->p)
	{
	  int j;
	  printf_filtered (_("Line at %s, referenced %d times\n"),
			   paddress (target_gdbarch, p->addr), p->refs);

	  for (j = 0; j < LINE_SIZE; j++)
	    printf_filtered ("%02x", p->data[j] & 0xFF);
	  printf_filtered (("\n"));

	  for (j = 0; j < LINE_SIZE; j++)
	    printf_filtered (" %c", state_chars[p->state[j]]);
	  printf_filtered ("\n");
	}
d499 2
d522 3
a524 4
The state of each cached byte is represented by a letter:\n\
  I = invalid\n\
  D = dirty\n\
  V = valid"));
@


1.32
log
@        Updated copyright notices for most files.
@
text
@d572 1
a572 1
			   paddr (p->addr), p->refs);
@


1.31
log
@	* dcache.c (state_chars): New static global.
	(ENTRY_INVALID,ENTRY_VALID): Renamed from ENTRY_BAD,ENTRY_OK.
	All uses updated.
	(dcache_info): Print cache state as mnemonically useful letters instead
	of magic numbers.
	* doc/gdb.texinfo (info dcache): Update.
@
text
@d4 1
a4 1
   2008 Free Software Foundation, Inc.
@


1.30
log
@	Updated copyright notices for most files.
@
text
@d54 1
a54 1
   ENTRY_BAD means that the byte is just plain wrong, and has no
d56 1
a56 1
   turned on, but nothing has been done to it.
d62 1
a62 1
   ENTRY_OK means that the data is the same in the cache as it is in
d116 10
a125 4
#define ENTRY_BAD   0		/* data at this byte is wrong */
#define ENTRY_DIRTY 1		/* data at this byte needs to be written back */
#define ENTRY_OK    2		/* data at this byte is same as in memory */

d184 1
d315 1
a315 1
	  memset (&db->state[XFORM(memaddr)], ENTRY_OK, res);
d375 1
a375 1
  memset (db->state, ENTRY_OK, sizeof (db->data));
d409 1
a409 1
  memset (db->state, ENTRY_BAD, sizeof (db->data));
d457 1
a457 1
  if (db->state[XFORM (addr)] == ENTRY_BAD)
d579 1
a579 1
	    printf_filtered ("%2x", p->state[j]);
d602 6
a607 2
	    _("Print information on the dcache performance."));

@


1.29
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 2
a4 2
   Copyright (C) 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2003, 2007
   Free Software Foundation, Inc.
@


1.28
log
@Copyright updates for 2007.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.27
log
@	PR remote/1966
	* dcache.c (dcache_write_line): Use target_write.
	(dcache_read_line): Use target_read.
	* mi/mi-main.c (mi_cmd_data_read_memory): Use target_read.
	* symfile.c (struct load_section_data): Add new per-section
	members.
	(load_progress): New function.
	(load_section_callback): Pass load_progress to the new
	target_write_with_progress.
	* target.c (current_xfer_partial, memory_xfer_partial): New.
	(target_xfer_partial): New prototype.
	(target_xfer_memory, target_xfer_partial_p, xfer_using_stratum)
	(do_xfer_memory, target_xfer_memory_partial)
	(target_read_memory_partial, target_write_memory_partial): Delete.
	(trust_readonly): Move higher in the file.
	(update_current_target): Use current_xer_partial.
	(target_xfer_partial): Use memory_xfer_partial.  Handle
	TARGET_OBJECT_RAW_MEMORY specially.
	(target_read_memory): Use target_read.
	(target_write_memory): Use target_write.
	(default_xfer_partial): Call to_xfer_partial directly.
	(target_write_with_progress): New function, based on target_write.
	(target_write): Call it.
	* target.h (enum target_object): Add TARGET_OBJECT_RAW_MEMORY.
	(target_write_with_progress): New prototype.
	(do_xfer_memory, target_read_memory_partial)
	(target_write_memory_partial): Delete prototypes.
@
text
@d3 2
a4 2
   Copyright (C) 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2003 Free
   Software Foundation, Inc.
@


1.26
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d305 9
a313 13
	  while (dirty_len > 0)
	    {
	      res = do_xfer_memory(memaddr, myaddr, dirty_len, 1,
				   &region->attrib);
	      if (res <= 0)
		return 0;

	      memset (&db->state[XFORM(memaddr)], ENTRY_OK, res);
	      memaddr   += res;
	      myaddr    += res;
	      len       -= res;
	      dirty_len -= res;
	    }
d360 4
a363 6
      while (reg_len > 0)
	{
	  res = do_xfer_memory (memaddr, myaddr, reg_len, 0,
				&region->attrib);
	  if (res <= 0)
	    return 0;
d365 3
a367 5
	  memaddr += res;
	  myaddr  += res;
	  len     -= res;
	  reg_len -= res;
	}
@


1.26.14.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d305 13
a317 9
	  res = target_write (&current_target, TARGET_OBJECT_RAW_MEMORY,
			      NULL, myaddr, memaddr, dirty_len);
	  if (res < dirty_len)
	    return 0;

	  memset (&db->state[XFORM(memaddr)], ENTRY_OK, res);
	  memaddr += res;
	  myaddr += res;
	  len -= res;
d364 6
a369 4
      res = target_read (&current_target, TARGET_OBJECT_RAW_MEMORY,
			 NULL, myaddr, memaddr, reg_len);
      if (res < reg_len)
	return 0;
d371 5
a375 3
      memaddr += res;
      myaddr += res;
      len -= res;
@


1.25
log
@2005-05-23  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_xfer_memory): Use gdb_byte for byte buffer
	parameters.
	* inftarg.c (child_xfer_partial): Update.
	* wince.c (child_xfer_memory): Update.
	* win32-nat.c (child_xfer_memory): Update.
	* rs6000-nat.c (child_xfer_memory): Update.
	* infptrace.c (child_xfer_memory): Update.
	* dcache.c (struct dcache_block): Use gdb_byte for the byte
	buffers.
	(dcache_read_line, dcache_xfer_memory, dcache_poke_byte)
	(dcache_peek_byte, dcache_write_line): Ditto.
@
text
@d3 1
a3 1
   Copyright 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2003 Free
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.24
log
@2005-05-16  Andrew Cagney  <cagney@@gnu.org>

	* target.h (target_read_partial, target_write_partial)
	(do_xfer_memory, xfer_memory, target_read, target_write)
	(get_target_memory): For buffers, change "void*" to gdb_byte.
	(struct target_ops): Ditto for to_xfer_partial and
	deprecated_xfer_memory.
	* dcache.h (dcache_xfer_memory): Ditto.
	* target.c (default_xfer_partial, target_read_partial)
	(target_write_partial, target_read, target_write)
	(do_xfer_memory, update_current_target, get_target_memory): Update.
	(target_read_string): Change buf to a gdb_byte.
	* dcache.c (dcache_xfer_memory): Update.
	* exec.c (xfer_memory): Make buffer type to gdb_byte.
	* mem-break.c (default_memory_insert_breakpoint): Remove cast.
	* disasm.c (dis_asm_read_memory): Remove cast, use gdb_byte.
@
text
@d127 1
a127 1
    char data[LINE_SIZE];	/* bytes at given address */
a164 4
static int dcache_poke_byte (DCACHE *dcache, CORE_ADDR addr, char *ptr);

static int dcache_peek_byte (DCACHE *dcache, CORE_ADDR addr, char *ptr);

d249 1
a249 1
  char *myaddr;
d330 1
a330 1
  char *myaddr;
d449 1
a449 1
dcache_peek_byte (DCACHE *dcache, CORE_ADDR addr, char *ptr)
d476 1
a476 1
dcache_poke_byte (DCACHE *dcache, CORE_ADDR addr, char *ptr)
d535 1
a535 1
  int (*xfunc) (DCACHE *dcache, CORE_ADDR addr, char *ptr);
@


1.23
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d535 2
a536 2
dcache_xfer_memory (DCACHE *dcache, CORE_ADDR memaddr, char *myaddr, int len,
		    int should_write)
@


1.22
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d184 7
d605 1
a605 1
			   NULL, /* FIXME: i18n: */
@


1.21
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d588 4
a591 5
  deprecated_add_show_from_set
    (add_set_cmd ("remotecache", class_support, var_boolean,
		  (char *) &dcache_enabled_p,
		  "\
Set cache use for remote targets.\n\
d596 4
a599 3
volatile registers are in use.  By default, this option is off.",
		  &setlist),
     &showlist);
@


1.20
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d602 1
a602 1
	    "Print information on the dcache performance.");
@


1.19
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d561 1
a561 1
  printf_filtered ("Dcache line width %d, depth %d\n",
d566 1
a566 1
      printf_filtered ("Cache state:\n");
d571 1
a571 1
	  printf_filtered ("Line at %s, referenced %d times\n",
d576 1
a576 1
	  printf_filtered ("\n");
@


1.18
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d588 1
a588 1
  add_show_from_set
@


1.18.10.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d588 1
a588 1
  deprecated_add_show_from_set
@


1.17
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_push_dummy_call): Fix typos.
	* dcache.c: Update copyrights and descriptions.
	* scm-exp.c, ia64-aix-nat.c, hppam3-nat.c: environ.c: Ditto.
@
text
@d243 1
a243 1
dcache_write_line (DCACHE *dcache, register struct dcache_block *db)
@


1.16
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d1 4
a4 3
/* Caching code.
   Copyright 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.15
log
@* dcache.c (dcache_write_line): Fixed bugs where cache line was
not written to target correctly.
@
text
@d220 1
a220 1
  register struct dcache_block *db;
d386 1
a386 1
  register struct dcache_block *db;
d447 1
a447 1
  register struct dcache_block *db = dcache_hit (dcache, addr);
d474 1
a474 1
  register struct dcache_block *db = dcache_hit (dcache, addr);
@


1.15.26.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 3
a3 4
/* Caching code for GDB, the GNU debugger.

   Copyright 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2003 Free
   Software Foundation, Inc.
d220 1
a220 1
  struct dcache_block *db;
d242 1
a242 1
dcache_write_line (DCACHE *dcache, struct dcache_block *db)
d386 1
a386 1
  struct dcache_block *db;
d447 1
a447 1
  struct dcache_block *db = dcache_hit (dcache, addr);
d474 1
a474 1
  struct dcache_block *db = dcache_hit (dcache, addr);
@


1.15.24.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d1 3
a3 4
/* Caching code for GDB, the GNU debugger.

   Copyright 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2003 Free
   Software Foundation, Inc.
d220 1
a220 1
  struct dcache_block *db;
d242 1
a242 1
dcache_write_line (DCACHE *dcache, struct dcache_block *db)
d386 1
a386 1
  struct dcache_block *db;
d447 1
a447 1
  struct dcache_block *db = dcache_hit (dcache, addr);
d474 1
a474 1
  struct dcache_block *db = dcache_hit (dcache, addr);
@


1.15.54.1
log
@Snap const char * mess.
@
text
@d178 1
a178 1
static void dcache_info (const char *exp, int tty);
d556 1
a556 1
dcache_info (const char *exp, int tty)
@


1.14
log
@Update/correct copyright notices.
@
text
@d281 1
a281 1
	  do {
d286 5
a290 1
	  } while (reg_len > 0);
d293 1
a293 1
	  do {
d298 1
a298 1
	  } while (reg_len > 0);
d311 1
@


1.13
log
@* dcache.c (dcache_write_line): Fix typo.

* memattr.c (delete_mem_region): Replace free() with xfree().
(mem_number): Add explicit type.

* sol-thread.c (sol_thread_xfer_memory): Add attrib argument.
(rw_common): Likewise.
@
text
@d2 2
a3 1
   Copyright 1992-1993, 1995, 1998-1999, 2000, 2001 Free Software Foundation, Inc.
@


1.12
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@d303 1
a303 1
	      memset (db->state[XFORM(memaddr)], ENTRY_OK, res);
@


1.11
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1992-1993, 1995, 1998-1999, 2000 Free Software Foundation, Inc.
d28 4
a31 8
/* 
   The data cache could lead to incorrect results because it doesn't know
   about volatile variables, thus making it impossible to debug
   functions which use memory mapped I/O devices.

   set remotecache 0

   In those cases.
d60 4
a63 2
   data.  ENTRY_OK means that the data is the same in the cache as it
   is in remote memory.
d77 1
d79 1
d81 12
a92 2
 */

d136 13
a160 5

    /* potentially, if the cache was enabled, and then turned off, and
       then turned on again, the stuff in it could be stale, so this is
       used to mark it */
    int cache_has_stuff;
a209 2
  dcache->cache_has_stuff = 0;

d243 9
a251 2
  int s;
  int e;
d253 5
a257 1
  if (db->anydirty)
d259 11
a269 1
      for (s = 0; s < LINE_SIZE; s++)
d271 26
a296 1
	  if (db->state[s] == ENTRY_DIRTY)
d298 9
a306 20
	      int len = 0;
	      for (e = s; e < LINE_SIZE; e++, len++)
		if (db->state[e] != ENTRY_DIRTY)
		  break;
	      {
		/* all bytes from s..s+len-1 need to
		   be written out */
		int done = 0;
		while (done < len)
		  {
		    int t = do_xfer_memory (db->addr + s + done,
					    db->data + s + done,
					    len - done, 1);
		    if (t <= 0)
		      return 0;
		    done += t;
		  }
		memset (db->state + s, ENTRY_OK, len);
		s = e;
	      }
a308 1
      db->anydirty = 0;
d310 2
d323 2
d340 20
a359 3
      res = do_xfer_memory (memaddr, myaddr, len, 0);
      if (res <= 0)
	return 0;
d361 5
a365 3
      memaddr += res;
      myaddr  += res;
      len     -= res;
a381 3
  if (dcache_enabled_p == 0)
    abort ();

d415 1
a415 1
/* Writeback any dirty lines to the remote. */
d525 2
d528 1
a528 1
  if (dcache_enabled_p)
d530 2
a531 13
      int (*xfunc) (DCACHE *dcache, CORE_ADDR addr, char *ptr);
      xfunc = should_write ? dcache_poke_byte : dcache_peek_byte;

      for (i = 0; i < len; i++)
	{
	  if (!xfunc (dcache, memaddr + i, myaddr + i))
	    return 0;
	}

      if (should_write)
	dcache_writeback (dcache);

      dcache->cache_has_stuff = 1;
a532 4
  else
    {
      if (dcache->cache_has_stuff)
	dcache_invalidate (dcache);
d534 12
a545 2
      len = do_xfer_memory(memaddr, myaddr, len, should_write);
    }
d554 1
a554 6
  if (!dcache_enabled_p)
    {
      printf_filtered ("Dcache not enabled\n");
      return;
    }
  printf_filtered ("Dcache enabled, line width %d, depth %d\n",
a575 7
}

/* Turn dcache on or off. */
void
set_dcache_state (int what)
{
  dcache_enabled_p = !!what;
@


1.10
log
@* TODO: Note abstraction layer violation where "ocd reset" command
must invalidate the dcache, and how this might be fixed.

* monitor.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(monitor_open): Removed code that created local dcache.
(flush_monitor_dcache): Removed (unused function).
(monitor_resume): Removed call to dcache_invd().
(monitor_load): Likewise.
(monitor_xfer_memory): Changed to call monitor_write_memory(),
monitor_write_memory_block(), and monitor_read_memory() instead
of dcache_xfer_memory().
* monitor.h (flush_monitor_dcache): Removed (unused function).
* ocd.c (#include "dcache.h"): Removed.
(ocd_dcache): Removed.
(ocd_open): Removed code that created local dcache.
(ocd_resume): Removed call to dcache_invd().
(ocd_xfer_memory): Changed to call ocd_write_bytes() and
ocd_read_bytes() instead of dcache_xfer_memory().
(bdm_reset_command): Invalidate target dcache.
* remote-bug.c (bug_load): Remove call to dcache_invd().
(bug_resume): Likewise.
(bug_settings): Remove dcache, readfunc, and writefunc fields
from initializer.
(bug_xfer_memory): Changed to call bug_read_memory() and
bug_write_memory() instead of dcache_xfer_memory().
* remote-nindy.c (#include "dcache.h"): Removed.
(nindy_dcache): Removed.
(nindy_open): Removed code that created local dcache.
(nindy_resume): Removed call to dcache_invd().
(nindy_load): Likewise.
(nindy_xfer_inferior_memory): Changed to call ninMemPut() and
ninMemGet() instead of dcache_xfer_memory().
* remote-sds.c (#include "dcache.h"): Removed.
(sds_dcache): Removed.
(sds_open): Removed code that created local dcache.
(sds_resume): Removed call to dcache_invd().
(sds_xfer_memory): Changed to call sds_write_bytes() and
sds_read_bytes() instead of dcache_xfer_memory().
* remote-utils.c (gr_open): Removed code that created local dcache.
* remote-utils.h (#include "dcache.h"): Removed.
(struct gr_settings): Removed dcache, readfunc, and writefunc fields.
(gr_get_dcache, gr_set_dcache): Removed macro definitions.
* remote.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(remote_open_1): Removed code that created local dcache.
(remote_async_open_1): Likewise.
(remote_resume): Removed call to dcache_invd().
(remote_async_resume): Likewise.
(remote_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
* wince.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(child_create_inferior): Removed code that created local dcache.
(child_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
(child_resume): Removed call to dcache_invd().

* target.c (target_dcache): Added.
(target_load): Invalidate target_dcache.
(do_xfer_memory): New function.
(target_xfer_memory): Reimplement in terms of dcache_xfer_memory().
(target_xfer_memory_partial): Likewise.
(initialize_targets): Create target_dcache.
* target.h (#include "dcache.h"): Added.
(target_open): Invalidate target_dcache.
(target_resume): Likewise.
(do_xfer_memory): New declaration.

* dcache.c (dcache_init): Removed reading and writing arguments.
(dcache_struct): Removed read_memory and write_memory fields.
(dcache_write_line): Call do_xfer_memory.
(dcache_read_line): Likewise.
(dcache_xfer_memory): Likewise.
(dcache_invalidate): Renamed from dcache_invd.
(dcache_init): Updated.
(dcache_xfer_memory): Updated.
* dcache.h (memxferfunc): Removed definition.
@
text
@d438 2
a439 2
  free (dcache->the_cache);
  free (dcache);
@


1.9
log
@* dcache.c (dcache_info): Output a cache line's state vector so it
lines up under the data vector.

* dcache.c (dcache_read_line): New function.
(dcache_peek_byte): Use it.
(dcache_alloc): Return NULL if write of reclaimed cache line fails.
(dcache_peek_byte, dcache_poke_byte): Return failure if
dcache_alloc() returns a NULL data block pointer.
(dcache_xfer_memory): Don't force writeback unless we were writing.

* monitor.c (monitor_expect): Change places where immediate_quit
is set to 1 or 0 to increments and decrements respectively.  This
allows such changes to nest properly.
* ocd.c (ocd_start_remote): Likewise.
* remote-adapt.c (expect): Likewise.
* remote-array.c (expect): Likewise.
* remote-eb.c (expect): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-mips.c (mips_expect_timeout, mips_getstring): Likewise.
* remote-nrom.c (expect): Likewise.
* remote-os9k.c (expect): Likewise.
* remote-sds.c (sds_start_remote): Likewise.
* remote-st.c (expect): Likewise.
* remote-utils.c (sr_expect): Likewise.
* remote.c (remote_start_remote): Likewise.
* tracepoint.c (read_actions): Likewise.

* remote-mips.c (mips_getstring): Balance changes to immediate_quit.
@
text
@d1 2
a2 4
/* Caching code.  Typically used by remote back ends for
   caching remote memory.

   Copyright 1992-1993, 1995, 1998-1999 Free Software Foundation, Inc.
d26 1
a127 6
    /* Function to actually read the target memory. */
    memxferfunc read_memory;

    /* Function to actually write the target memory */
    memxferfunc write_memory;

d171 1
a171 1
dcache_invd (DCACHE *dcache)
d246 4
a249 4
		    int t = dcache->write_memory (db->addr + s + done,
						  db->data + s + done,
						  len - done);
		    if (t == 0)
a262 1

d286 2
a287 2
      res = (*dcache->read_memory) (memaddr, myaddr, len);
      if (res == 0)
d415 1
a415 1
dcache_init (memxferfunc reading, memxferfunc writing)
a420 2
  dcache->read_memory = reading;
  dcache->write_memory = writing;
d425 1
a425 1
  dcache_invd (dcache);
a473 3
      memxferfunc xfunc;
      xfunc = should_write ? dcache->write_memory : dcache->read_memory;

d475 1
a475 1
	dcache_invd (dcache);
d477 1
a477 1
      len = xfunc (memaddr, myaddr, len);
@


1.8
log
@* MAINTAINERS: Add myself as dcache.c maintainer.

* remote-nindy.c (nindy_load): Invalidate dcache.

* dcache.c (dcache_invd): Renamed from dcache_flush.  The term
flush with respect to caches usually implies that data will be
written to memory.
(dcache_init, dcache_xfer_memory): Updated.
* monitor.c (flush_monitor_dcache, monitor_resume, monitor_load):
Updated.
* ocd.c (ocd_open, ocd_resume, bdm_reset_command): Updated.
* remote-bug.c (bug_load, bug_resume): Updated.
* remote-nindy.c (nindy_open, nindy_resume): Updated.
* remote-sds.c (sds_open, sds_resume): Updated.
* remote-utils.c (gr_open): Updated.
* remote.c (remote_open_1, remote_resume, remote_async_resume,
remote_cisco_open): Updated.
* wince.c (child_create_inferior, child_resume): Updated.

* monitor.c (monitor_open): Free dcache before creating a new one.
* dcache.c (dcache_free): New function.
* dcache.h (dcache_free): New prototype.
-------------------------------------------------------------------
@
text
@d152 1
a152 1
static int dcache_poke_byte (DCACHE * dcache, CORE_ADDR addr, char *ptr);
d154 1
a154 1
static int dcache_peek_byte (DCACHE * dcache, CORE_ADDR addr, char *ptr);
d156 1
a156 1
static struct dcache_block *dcache_hit (DCACHE * dcache, CORE_ADDR addr);
d158 1
a158 1
static int dcache_write_line (DCACHE * dcache, struct dcache_block *db);
d160 1
a160 1
static struct dcache_block *dcache_alloc (DCACHE * dcache, CORE_ADDR addr);
d162 3
a164 1
static int dcache_writeback (DCACHE * dcache);
d236 1
a236 1
  s = 0;
d271 38
d330 4
a334 2

      dcache_write_line (dcache, db);
a352 42
/* Using the data cache DCACHE return the contents of the byte at
   address ADDR in the remote machine.  

   Returns 0 on error. */

static int
dcache_peek_byte (DCACHE *dcache, CORE_ADDR addr, char *ptr)
{
  register struct dcache_block *db = dcache_hit (dcache, addr);
  int ok = 1;
  int done = 0;
  if (db == 0
      || db->state[XFORM (addr)] == ENTRY_BAD)
    {
      if (db)
	{
	  dcache_write_line (dcache, db);
	}
      else
	db = dcache_alloc (dcache, addr);

      immediate_quit++;
      while (done < LINE_SIZE)
	{
	  int try =
	  (*dcache->read_memory)
	  (db->addr + done,
	   db->data + done,
	   LINE_SIZE - done);
	  if (try == 0)
	    return 0;
	  done += try;
	}
      immediate_quit--;

      memset (db->state, ENTRY_OK, sizeof (db->data));
      db->anydirty = 0;
    }
  *ptr = db->data[XFORM (addr)];
  return ok;
}

d371 28
d411 2
d468 1
a468 1
      int (*xfunc) (DCACHE * dcache, CORE_ADDR addr, char *ptr);
d476 4
a480 1
      dcache_writeback (dcache);
d523 1
a523 1
	    printf_filtered (" %2x", p->state[j]);
@


1.7
log
@* dcache.c (dcache_info): Don't print cache state if last_cache
is NULL.
@
text
@d176 1
a176 1
dcache_flush (DCACHE *dcache)
d405 1
a405 1
  dcache_flush (dcache);
d411 11
d455 1
a455 1
	dcache_flush (dcache);
@


1.6
log
@* monitor.c (monitor_open): If a dcache has already been created,
invalidate it rather than creating another.
* ocd.c (ocd_open): Likewise.
* remote-nindy.c (nindy_open): Likewise.
* remote-sds.c (sds_open): Likewise.
* remote-utils.c (gr_open): Likewise.
* remote.c (remote_open_1, remote_cisco_open): Likewise.

* dcache.c (dcache_alloc): Changed to take address of line as an
argument, and to invalidate cache line before returning.
(dcache_peek_byte): Updated.
(dcache_poke_byte): Updated.
-------------------------------------------------------------------
@
text
@d464 3
a466 1
  printf_filtered ("Cache state:\n");
d468 5
a472 5
  for (p = last_cache->valid_head; p; p = p->p)
    {
      int j;
      printf_filtered ("Line at %s, referenced %d times\n",
		       paddr (p->addr), p->refs);
d474 3
a476 3
      for (j = 0; j < LINE_SIZE; j++)
	printf_filtered ("%02x", p->data[j] & 0xFF);
      printf_filtered ("\n");
d478 4
a481 3
      for (j = 0; j < LINE_SIZE; j++)
	printf_filtered (" %2x", p->state[j]);
      printf_filtered ("\n");
@


1.5
log
@Protoization.
@
text
@d160 1
a160 1
static struct dcache_block *dcache_alloc (DCACHE * dcache);
d270 1
a270 6
   and return its address.  The caller should store into the block
   the address and data that it describes, then remque it from the
   free list and insert it into the valid list.  This procedure
   prevents errors from creeping in if a memory retrieval is
   interrupted (which used to put garbage blocks in the valid
   list...).  */
d273 1
a273 1
dcache_alloc (DCACHE *dcache)
d295 5
d330 2
a331 1
	db = dcache_alloc (dcache);
a332 1
      db->addr = MASK (addr);
d382 1
a382 3
      db = dcache_alloc (dcache);
      db->addr = MASK (addr);
      memset (db->state, ENTRY_BAD, sizeof (db->data));
@


1.4
log
@* remote-nindy.c (nindy_fetch_word, nindy_store_word): Removed
(nindy_xfer_inferior_memory): Use dcache_xfer_memory() instead of
breaking transfer into chunks and using nindy_fetch_word() and
nindy_store_word().

* remote-bug.c (bug_xfer_memory): Use dcache_xfer_memory() instead
of breaking transfer into chunks and using gr_fetch_word() and
gr_store_word().

* remote.c (remote_fetch_word, remote_store_word): Removed.

* remote-utils.h (gr_fetch_word, gr_store_word): Removed.
* remote-utils.c (gr_fetch_word, gr_store_word): Removed.

* dcache.h (dcache_fetch, dcache_poke, dcache_poke_block): Removed.
* dcache.c (dcache_fetch, dcache_poke): Removed.
@
text
@d176 1
a176 2
dcache_flush (dcache)
     DCACHE *dcache;
d206 1
a206 3
dcache_hit (dcache, addr)
     DCACHE *dcache;
     CORE_ADDR addr;
d230 1
a230 3
dcache_write_line (dcache, db)
     DCACHE *dcache;
     register struct dcache_block *db;
d278 1
a278 2
dcache_alloc (dcache)
     DCACHE *dcache;
d317 1
a317 4
dcache_peek_byte (dcache, addr, ptr)
     DCACHE *dcache;
     CORE_ADDR addr;
     char *ptr;
d355 1
a355 2
dcache_writeback (dcache)
     DCACHE *dcache;
d376 1
a376 4
dcache_poke_byte (dcache, addr, ptr)
     DCACHE *dcache;
     CORE_ADDR addr;
     char *ptr;
d395 1
a395 3
dcache_init (reading, writing)
     memxferfunc reading;
     memxferfunc writing;
d422 2
a423 6
dcache_xfer_memory (dcache, memaddr, myaddr, len, should_write)
     DCACHE *dcache;
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int should_write;
d454 1
a454 3
dcache_info (exp, tty)
     char *exp;
     int tty;
d492 1
a492 1
_initialize_dcache ()
@


1.3
log
@Eliminate PARAMS from function pointer declarations.
@
text
@a380 16
/* Using the data cache DCACHE return the contents of the word at
   address ADDR in the remote machine.  */
int
dcache_fetch (dcache, addr)
     DCACHE *dcache;
     CORE_ADDR addr;
{
  int res;

  if (dcache_xfer_memory (dcache, addr, (char *) &res, sizeof res, 0) != sizeof res)
    memory_error (EIO, addr);

  return res;
}


a404 17

/* Write the word at ADDR both in the data cache and in the remote machine.  
   Return zero on write error.
 */

int
dcache_poke (dcache, addr, data)
     DCACHE *dcache;
     CORE_ADDR addr;
     int data;
{
  if (dcache_xfer_memory (dcache, addr, (char *) &data, sizeof data, 1) != sizeof data)
    return 0;

  return dcache_writeback (dcache);
}

@


1.2
log
@PARAMS removal.
@
text
@d481 1
a481 1
      int (*xfunc) PARAMS ((DCACHE * dcache, CORE_ADDR addr, char *ptr));
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
   Copyright 1992, 1993, 1995, 1998 Free Software Foundation, Inc.
d20 2
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d82 1
a82 1
  */
d90 1
a90 1
#define DCACHE_SIZE 64 
d96 1
a96 1
#define LINE_SIZE_POWER (5) 
d102 1
a102 1
#define LINE_SIZE_MASK  ((LINE_SIZE - 1))	
d107 3
a109 3
#define ENTRY_BAD   0  /* data at this byte is wrong */
#define ENTRY_DIRTY 1  /* data at this byte needs to be written back */
#define ENTRY_OK    2  /* data at this byte is same as in memory */
d113 5
a117 5
{
  struct dcache_block *p;	/* next in list */
  CORE_ADDR addr;		/* Address for which data is recorded.  */
  char data[LINE_SIZE];		/* bytes at given address */
  unsigned char state[LINE_SIZE]; /* what state the data is in */
d119 3
a121 3
  /* whether anything in state is dirty - used to speed up the 
     dirty scan. */
  int anydirty;			
d123 2
a124 2
  int refs;
};
d127 4
a130 4
struct dcache_struct 
{
  /* Function to actually read the target memory. */
  memxferfunc read_memory;
d132 2
a133 2
  /* Function to actually write the target memory */
  memxferfunc write_memory;
d135 3
a137 3
  /* free list */
  struct dcache_block *free_head;
  struct dcache_block *free_tail;
d139 3
a141 3
  /* in use list */
  struct dcache_block *valid_head;
  struct dcache_block *valid_tail;
d143 2
a144 2
  /* The cache itself. */
  struct dcache_block *the_cache;
d146 5
a150 5
  /* potentially, if the cache was enabled, and then turned off, and
     then turned on again, the stuff in it could be stale, so this is
     used to mark it */
  int cache_has_stuff;
} ;
d152 1
a152 2
static int dcache_poke_byte PARAMS ((DCACHE *dcache, CORE_ADDR addr, 
                                     char *ptr));
d154 1
a154 2
static int dcache_peek_byte PARAMS ((DCACHE *dcache, CORE_ADDR addr, 
                                     char *ptr));
d156 1
a156 2
static struct dcache_block *dcache_hit PARAMS ((DCACHE *dcache, 
                                                CORE_ADDR addr));
d158 1
a158 1
static int dcache_write_line PARAMS ((DCACHE *dcache,struct dcache_block *db));
d160 1
a160 1
static struct dcache_block *dcache_alloc PARAMS ((DCACHE *dcache));
d162 1
a162 1
static int dcache_writeback PARAMS ((DCACHE *dcache));
d164 1
a164 1
static void dcache_info PARAMS ((char *exp, int tty));
d166 1
a166 1
void _initialize_dcache PARAMS ((void));
d168 1
a168 1
int remote_dcache = 0;
d170 1
a170 1
DCACHE *last_cache; /* Used by info dcache */
d218 1
a218 1
      if (MASK(addr) == db->addr)
d247 1
a247 1
	      for (e = s ; e < LINE_SIZE; e++, len++)
d254 9
a262 8
		while (done < len) {
		  int t = dcache->write_memory (db->addr + s + done,
						db->data + s + done,
						len - done);
		  if (t == 0)
		    return 0;
		  done += t;
		}
d288 1
a288 1
  if (remote_dcache == 0)
d329 1
a329 1
  int ok=1;
d338 2
a339 2
    else
      db = dcache_alloc (dcache);
d342 1
a342 1
      while (done < LINE_SIZE) 
d345 4
a348 4
	    (*dcache->read_memory)
	      (db->addr + done,
	       db->data + done,
	       LINE_SIZE - done);
d354 1
a354 1
     
d390 1
a390 1
  if (dcache_xfer_memory (dcache, addr, (char *)&res, sizeof res, 0) != sizeof res)
d432 1
a432 1
  if (dcache_xfer_memory (dcache, addr, (char *)&data, sizeof data, 1) != sizeof data)
d479 1
a479 1
  if (remote_dcache) 
d481 1
a481 1
      int (*xfunc) PARAMS ((DCACHE *dcache, CORE_ADDR addr, char *ptr));
d492 1
a492 1
  else 
d505 1
a505 1
static void 
d512 1
a512 1
  if (!remote_dcache)
d525 2
a526 2
      printf_filtered ("Line at %08xd, referenced %d times\n",
		       p->addr, p->refs);
d538 7
d550 1
a550 1
		  (char *) &remote_dcache,
d557 1
a557 1
volatile registers are in use.  By default, this option is on.",
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d20 1
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d81 1
a81 1
 */
d89 1
a89 1
#define DCACHE_SIZE 64
d95 1
a95 1
#define LINE_SIZE_POWER (5)
d101 1
a101 1
#define LINE_SIZE_MASK  ((LINE_SIZE - 1))
d106 3
a108 3
#define ENTRY_BAD   0		/* data at this byte is wrong */
#define ENTRY_DIRTY 1		/* data at this byte needs to be written back */
#define ENTRY_OK    2		/* data at this byte is same as in memory */
d112 5
a116 5
  {
    struct dcache_block *p;	/* next in list */
    CORE_ADDR addr;		/* Address for which data is recorded.  */
    char data[LINE_SIZE];	/* bytes at given address */
    unsigned char state[LINE_SIZE];	/* what state the data is in */
d118 3
a120 3
    /* whether anything in state is dirty - used to speed up the 
       dirty scan. */
    int anydirty;
d122 2
a123 2
    int refs;
  };
d126 4
a129 4
struct dcache_struct
  {
    /* Function to actually read the target memory. */
    memxferfunc read_memory;
d131 2
a132 2
    /* Function to actually write the target memory */
    memxferfunc write_memory;
d134 3
a136 3
    /* free list */
    struct dcache_block *free_head;
    struct dcache_block *free_tail;
d138 3
a140 3
    /* in use list */
    struct dcache_block *valid_head;
    struct dcache_block *valid_tail;
d142 2
a143 2
    /* The cache itself. */
    struct dcache_block *the_cache;
d145 5
a149 5
    /* potentially, if the cache was enabled, and then turned off, and
       then turned on again, the stuff in it could be stale, so this is
       used to mark it */
    int cache_has_stuff;
  };
d151 2
a152 2
static int dcache_poke_byte PARAMS ((DCACHE * dcache, CORE_ADDR addr,
				     char *ptr));
d154 2
a155 2
static int dcache_peek_byte PARAMS ((DCACHE * dcache, CORE_ADDR addr,
				     char *ptr));
d157 2
a158 2
static struct dcache_block *dcache_hit PARAMS ((DCACHE * dcache,
						CORE_ADDR addr));
d160 1
a160 1
static int dcache_write_line PARAMS ((DCACHE * dcache, struct dcache_block * db));
d162 1
a162 1
static struct dcache_block *dcache_alloc PARAMS ((DCACHE * dcache));
d164 1
a164 1
static int dcache_writeback PARAMS ((DCACHE * dcache));
d172 1
a172 1
DCACHE *last_cache;		/* Used by info dcache */
d220 1
a220 1
      if (MASK (addr) == db->addr)
d249 1
a249 1
	      for (e = s; e < LINE_SIZE; e++, len++)
d256 8
a263 9
		while (done < len)
		  {
		    int t = dcache->write_memory (db->addr + s + done,
						  db->data + s + done,
						  len - done);
		    if (t == 0)
		      return 0;
		    done += t;
		  }
d330 1
a330 1
  int ok = 1;
d339 2
a340 2
      else
	db = dcache_alloc (dcache);
d343 1
a343 1
      while (done < LINE_SIZE)
d346 4
a349 4
	  (*dcache->read_memory)
	  (db->addr + done,
	   db->data + done,
	   LINE_SIZE - done);
d355 1
a355 1

d391 1
a391 1
  if (dcache_xfer_memory (dcache, addr, (char *) &res, sizeof res, 0) != sizeof res)
d433 1
a433 1
  if (dcache_xfer_memory (dcache, addr, (char *) &data, sizeof data, 1) != sizeof data)
d480 1
a480 1
  if (remote_dcache)
d482 1
a482 1
      int (*xfunc) PARAMS ((DCACHE * dcache, CORE_ADDR addr, char *ptr));
d493 1
a493 1
  else
d506 1
a506 1
static void
@


1.1.1.3
log
@import gdb-1999-09-08 snapshot
@
text
@d528 2
a529 2
      printf_filtered ("Line at %s, referenced %d times\n",
		       paddr (p->addr), p->refs);
@


1.1.1.4
log
@import gdb-1999-10-18 snapshot
@
text
@d4 1
a4 1
   Copyright 1992-1993, 1995, 1998-1999 Free Software Foundation, Inc.
d171 1
a171 1
static int dcache_enabled_p = 0;
d291 1
a291 1
  if (dcache_enabled_p == 0)
d482 1
a482 1
  if (dcache_enabled_p)
d515 1
a515 1
  if (!dcache_enabled_p)
d546 1
a546 1
		  (char *) &dcache_enabled_p,
d553 1
a553 1
volatile registers are in use.  By default, this option is off.",
@


1.1.1.5
log
@import gdb-1999-12-06 snapshot
@
text
@a540 7
/* Turn dcache on or off. */
void
set_dcache_state (int what)
{
  dcache_enabled_p = !!what;
}

@


