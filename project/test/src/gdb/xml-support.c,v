head	1.29;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.27
	gdb_7_6-2013-04-26-release:1.27
	gdb_7_6-branch:1.27.0.2
	gdb_7_6-2013-03-12-branchpoint:1.27
	gdb_7_5_1-2012-11-29-release:1.26
	gdb_7_5-2012-08-17-release:1.26
	gdb_7_5-branch:1.26.0.2
	gdb_7_5-2012-07-18-branchpoint:1.26
	gdb_7_4_1-2012-04-26-release:1.25.2.1
	gdb_7_4-2012-01-24-release:1.25.2.1
	gdb_7_4-branch:1.25.0.2
	gdb_7_4-2011-12-13-branchpoint:1.25
	gdb_7_3_1-2011-09-04-release:1.24
	gdb_7_3-2011-07-26-release:1.24
	gdb_7_3-branch:1.24.0.2
	gdb_7_3-2011-04-01-branchpoint:1.24
	gdb_7_2-2010-09-02-release:1.19
	gdb_7_2-branch:1.19.0.2
	gdb_7_2-2010-07-07-branchpoint:1.19
	gdb_7_1-2010-03-18-release:1.17
	gdb_7_1-branch:1.17.0.2
	gdb_7_1-2010-02-18-branchpoint:1.17
	gdb_7_0_1-2009-12-22-release:1.16
	gdb_7_0-2009-10-06-release:1.16
	gdb_7_0-branch:1.16.0.2
	gdb_7_0-2009-09-16-branchpoint:1.16
	arc-sim-20090309:1.13
	msnyder-checkpoint-072509-branch:1.15.0.2
	msnyder-checkpoint-072509-branchpoint:1.15
	arc-insight_6_8-branch:1.13.0.14
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.12
	insight_6_8-branchpoint:1.13
	reverse-20081226-branch:1.14.0.2
	reverse-20081226-branchpoint:1.14
	multiprocess-20081120-branch:1.13.0.10
	multiprocess-20081120-branchpoint:1.13
	reverse-20080930-branch:1.13.0.8
	reverse-20080930-branchpoint:1.13
	reverse-20080717-branch:1.13.0.6
	reverse-20080717-branchpoint:1.13
	msnyder-reverse-20080609-branch:1.13.0.4
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.10.0.2
	drow-reverse-20070409-branchpoint:1.10
	gdb_6_8-2008-03-27-release:1.13
	gdb_6_8-branch:1.13.0.2
	gdb_6_8-2008-02-26-branchpoint:1.13
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	gdb_6_7-branch:1.12.0.2
	gdb_6_7-2007-09-07-branchpoint:1.12
	insight_6_6-20070208-release:1.3
	gdb_6_6-2006-12-18-release:1.3
	gdb_6_6-branch:1.3.0.2
	gdb_6_6-2006-11-15-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.29
date	2013.05.30.17.41.38;	author tromey;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.22.16.46.15;	author tromey;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.04.08.27.58;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.21.23.46.09;	author kcy;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2011.02.02.16.12.59;	author palves;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.25.09.49.59;	author palves;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.12.01.23.29;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.11.15.10.02;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.01.15.33.19;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.17.18.48.51;	author msnyder;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.07.02.09.54;	author msnyder;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.01.07.31.46;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.15.03.30.06;	author sergiodj;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.02.07.57.36;	author vprus;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.03.23.06.35;	author palves;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.23.18.08.47;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.26.19.20.21;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.08.21.00.34;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.07.22.48.06;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.09.14.58.57;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.05.00.39.54;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.04.22.11.44;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.05.19.42.31;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.03.15.54.01;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.21.13.54.03;	author drow;	state Exp;
branches;
next	;

1.25.2.1
date	2012.01.06.04.54.34;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.29
log
@fix up xml-support.c

xml-support.c has a function that returns a cleanup via an out parameter.

This changes this function to be a normal cleanup constructor --
returning the cleanup directly and returning the other result via an
out parameter.

This is sort of a hack, but it lets the checker work here.

I also noticed that gdb_xml_create_parser_and_cleanup does not need to
be exported any more.

	* xml-support.c (gdb_xml_create_parser_and_cleanup): Rename from
	gdb_xml_create_parser_and_cleanup_1.  Return a cleanup.  Remove
	'old_chain' argument.  Add 'parser_result' argument.
	(gdb_xml_create_parser_and_cleanup): Remove old version.
	(gdb_xml_parse_quick): Update.
	(xml_process_xincludes): Update.
	* xml-support.h (gdb_xml_create_parser_and_cleanup): Don't
	declare.
@
text
@/* Helper routines for parsing XML using Expat.

   Copyright (C) 2006-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdbcmd.h"
#include "exceptions.h"
#include "xml-support.h"
#include "filestuff.h"

#include "gdb_string.h"
#include "safe-ctype.h"

/* Debugging flag.  */
static int debug_xml;

/* The contents of this file are only useful if XML support is
   available.  */
#ifdef HAVE_LIBEXPAT

#include "gdb_expat.h"

/* The maximum depth of <xi:include> nesting.  No need to be miserly,
   we just want to avoid running out of stack on loops.  */
#define MAX_XINCLUDE_DEPTH 30

/* Simplified XML parser infrastructure.  */

/* A parsing level -- used to keep track of the current element
   nesting.  */
struct scope_level
{
  /* Elements we allow at this level.  */
  const struct gdb_xml_element *elements;

  /* The element which we are within.  */
  const struct gdb_xml_element *element;

  /* Mask of which elements we've seen at this level (used for
     optional and repeatable checking).  */
  unsigned int seen;

  /* Body text accumulation.  */
  struct obstack *body;
};
typedef struct scope_level scope_level_s;
DEF_VEC_O(scope_level_s);

/* The parser itself, and our additional state.  */
struct gdb_xml_parser
{
  XML_Parser expat_parser;	/* The underlying expat parser.  */

  const char *name;		/* Name of this parser.  */
  void *user_data;		/* The user's callback data, for handlers.  */

  VEC(scope_level_s) *scopes;	/* Scoping stack.  */

  struct gdb_exception error;	/* A thrown error, if any.  */
  int last_line;		/* The line of the thrown error, or 0.  */

  const char *dtd_name;		/* The name of the expected / default DTD,
				   if specified.  */
  int is_xinclude;		/* Are we the special <xi:include> parser?  */
};

/* Process some body text.  We accumulate the text for later use; it's
   wrong to do anything with it immediately, because a single block of
   text might be broken up into multiple calls to this function.  */

static void
gdb_xml_body_text (void *data, const XML_Char *text, int length)
{
  struct gdb_xml_parser *parser = data;
  struct scope_level *scope = VEC_last (scope_level_s, parser->scopes);

  if (parser->error.reason < 0)
    return;

  if (scope->body == NULL)
    {
      scope->body = XZALLOC (struct obstack);
      obstack_init (scope->body);
    }

  obstack_grow (scope->body, text, length);
}

/* Issue a debugging message from one of PARSER's handlers.  */

void
gdb_xml_debug (struct gdb_xml_parser *parser, const char *format, ...)
{
  int line = XML_GetCurrentLineNumber (parser->expat_parser);
  va_list ap;
  char *message;

  if (!debug_xml)
    return;

  va_start (ap, format);
  message = xstrvprintf (format, ap);
  if (line)
    fprintf_unfiltered (gdb_stderr, "%s (line %d): %s\n",
			parser->name, line, message);
  else
    fprintf_unfiltered (gdb_stderr, "%s: %s\n",
			parser->name, message);
  xfree (message);
}

/* Issue an error message from one of PARSER's handlers, and stop
   parsing.  */

void
gdb_xml_error (struct gdb_xml_parser *parser, const char *format, ...)
{
  int line = XML_GetCurrentLineNumber (parser->expat_parser);
  va_list ap;

  parser->last_line = line;
  va_start (ap, format);
  throw_verror (XML_PARSE_ERROR, format, ap);
}

/* Find the attribute named NAME in the set of parsed attributes
   ATTRIBUTES.  Returns NULL if not found.  */

struct gdb_xml_value *
xml_find_attribute (VEC(gdb_xml_value_s) *attributes, const char *name)
{
  struct gdb_xml_value *value;
  int ix;

  for (ix = 0; VEC_iterate (gdb_xml_value_s, attributes, ix, value); ix++)
    if (strcmp (value->name, name) == 0)
      return value;

  return NULL;
}

/* Clean up a vector of parsed attribute values.  */

static void
gdb_xml_values_cleanup (void *data)
{
  VEC(gdb_xml_value_s) **values = data;
  struct gdb_xml_value *value;
  int ix;

  for (ix = 0; VEC_iterate (gdb_xml_value_s, *values, ix, value); ix++)
    xfree (value->value);
  VEC_free (gdb_xml_value_s, *values);
}

/* Handle the start of an element.  DATA is our local XML parser, NAME
   is the element, and ATTRS are the names and values of this
   element's attributes.  */

static void
gdb_xml_start_element (void *data, const XML_Char *name,
		       const XML_Char **attrs)
{
  struct gdb_xml_parser *parser = data;
  struct scope_level *scope;
  struct scope_level new_scope;
  const struct gdb_xml_element *element;
  const struct gdb_xml_attribute *attribute;
  VEC(gdb_xml_value_s) *attributes = NULL;
  unsigned int seen;
  struct cleanup *back_to;

  /* Push an error scope.  If we return or throw an exception before
     filling this in, it will tell us to ignore children of this
     element.  */
  VEC_reserve (scope_level_s, parser->scopes, 1);
  scope = VEC_last (scope_level_s, parser->scopes);
  memset (&new_scope, 0, sizeof (new_scope));
  VEC_quick_push (scope_level_s, parser->scopes, &new_scope);

  gdb_xml_debug (parser, _("Entering element <%s>"), name);

  /* Find this element in the list of the current scope's allowed
     children.  Record that we've seen it.  */

  seen = 1;
  for (element = scope->elements; element && element->name;
       element++, seen <<= 1)
    if (strcmp (element->name, name) == 0)
      break;

  if (element == NULL || element->name == NULL)
    {
      /* If we're working on XInclude, <xi:include> can be the child
	 of absolutely anything.  Copy the previous scope's element
	 list into the new scope even if there was no match.  */
      if (parser->is_xinclude)
	{
	  struct scope_level *unknown_scope;

	  XML_DefaultCurrent (parser->expat_parser);

	  unknown_scope = VEC_last (scope_level_s, parser->scopes);
	  unknown_scope->elements = scope->elements;
	  return;
	}

      gdb_xml_debug (parser, _("Element <%s> unknown"), name);
      return;
    }

  if (!(element->flags & GDB_XML_EF_REPEATABLE) && (seen & scope->seen))
    gdb_xml_error (parser, _("Element <%s> only expected once"), name);

  scope->seen |= seen;

  back_to = make_cleanup (gdb_xml_values_cleanup, &attributes);

  for (attribute = element->attributes;
       attribute != NULL && attribute->name != NULL;
       attribute++)
    {
      const char *val = NULL;
      const XML_Char **p;
      void *parsed_value;
      struct gdb_xml_value new_value;

      for (p = attrs; *p != NULL; p += 2)
	if (!strcmp (attribute->name, p[0]))
	  {
	    val = p[1];
	    break;
	  }

      if (*p != NULL && val == NULL)
	{
	  gdb_xml_debug (parser, _("Attribute \"%s\" missing a value"),
			 attribute->name);
	  continue;
	}

      if (*p == NULL && !(attribute->flags & GDB_XML_AF_OPTIONAL))
	{
	  gdb_xml_error (parser, _("Required attribute \"%s\" of "
				   "<%s> not specified"),
			 attribute->name, element->name);
	  continue;
	}

      if (*p == NULL)
	continue;

      gdb_xml_debug (parser, _("Parsing attribute %s=\"%s\""),
		     attribute->name, val);

      if (attribute->handler)
	parsed_value = attribute->handler (parser, attribute, val);
      else
	parsed_value = xstrdup (val);

      new_value.name = attribute->name;
      new_value.value = parsed_value;
      VEC_safe_push (gdb_xml_value_s, attributes, &new_value);
    }

  /* Check for unrecognized attributes.  */
  if (debug_xml)
    {
      const XML_Char **p;

      for (p = attrs; *p != NULL; p += 2)
	{
	  for (attribute = element->attributes;
	       attribute != NULL && attribute->name != NULL;
	       attribute++)
	    if (strcmp (attribute->name, *p) == 0)
	      break;

	  if (attribute == NULL || attribute->name == NULL)
	    gdb_xml_debug (parser, _("Ignoring unknown attribute %s"), *p);
	}
    }

  /* Call the element handler if there is one.  */
  if (element->start_handler)
    element->start_handler (parser, element, parser->user_data, attributes);

  /* Fill in a new scope level.  */
  scope = VEC_last (scope_level_s, parser->scopes);
  scope->element = element;
  scope->elements = element->children;

  do_cleanups (back_to);
}

/* Wrapper for gdb_xml_start_element, to prevent throwing exceptions
   through expat.  */

static void
gdb_xml_start_element_wrapper (void *data, const XML_Char *name,
			       const XML_Char **attrs)
{
  struct gdb_xml_parser *parser = data;
  volatile struct gdb_exception ex;

  if (parser->error.reason < 0)
    return;

  TRY_CATCH (ex, RETURN_MASK_ALL)
    {
      gdb_xml_start_element (data, name, attrs);
    }
  if (ex.reason < 0)
    {
      parser->error = ex;
#ifdef HAVE_XML_STOPPARSER
      XML_StopParser (parser->expat_parser, XML_FALSE);
#endif
    }
}

/* Handle the end of an element.  DATA is our local XML parser, and
   NAME is the current element.  */

static void
gdb_xml_end_element (void *data, const XML_Char *name)
{
  struct gdb_xml_parser *parser = data;
  struct scope_level *scope = VEC_last (scope_level_s, parser->scopes);
  const struct gdb_xml_element *element;
  unsigned int seen;

  gdb_xml_debug (parser, _("Leaving element <%s>"), name);

  for (element = scope->elements, seen = 1;
       element != NULL && element->name != NULL;
       element++, seen <<= 1)
    if ((scope->seen & seen) == 0
	&& (element->flags & GDB_XML_EF_OPTIONAL) == 0)
      gdb_xml_error (parser, _("Required element <%s> is missing"),
		     element->name);

  /* Call the element processor.  */
  if (scope->element != NULL && scope->element->end_handler)
    {
      char *body;

      if (scope->body == NULL)
	body = "";
      else
	{
	  int length;

	  length = obstack_object_size (scope->body);
	  obstack_1grow (scope->body, '\0');
	  body = obstack_finish (scope->body);

	  /* Strip leading and trailing whitespace.  */
	  while (length > 0 && ISSPACE (body[length-1]))
	    body[--length] = '\0';
	  while (*body && ISSPACE (*body))
	    body++;
	}

      scope->element->end_handler (parser, scope->element, parser->user_data,
				   body);
    }
  else if (scope->element == NULL)
    XML_DefaultCurrent (parser->expat_parser);

  /* Pop the scope level.  */
  if (scope->body)
    {
      obstack_free (scope->body, NULL);
      xfree (scope->body);
    }
  VEC_pop (scope_level_s, parser->scopes);
}

/* Wrapper for gdb_xml_end_element, to prevent throwing exceptions
   through expat.  */

static void
gdb_xml_end_element_wrapper (void *data, const XML_Char *name)
{
  struct gdb_xml_parser *parser = data;
  volatile struct gdb_exception ex;

  if (parser->error.reason < 0)
    return;

  TRY_CATCH (ex, RETURN_MASK_ALL)
    {
      gdb_xml_end_element (data, name);
    }
  if (ex.reason < 0)
    {
      parser->error = ex;
#ifdef HAVE_XML_STOPPARSER
      XML_StopParser (parser->expat_parser, XML_FALSE);
#endif
    }
}

/* Free a parser and all its associated state.  */

static void
gdb_xml_cleanup (void *arg)
{
  struct gdb_xml_parser *parser = arg;
  struct scope_level *scope;
  int ix;

  XML_ParserFree (parser->expat_parser);

  /* Clean up the scopes.  */
  for (ix = 0; VEC_iterate (scope_level_s, parser->scopes, ix, scope); ix++)
    if (scope->body)
      {
	obstack_free (scope->body, NULL);
	xfree (scope->body);
      }
  VEC_free (scope_level_s, parser->scopes);

  xfree (parser);
}

/* Initialize a parser and store it to *PARSER_RESULT.  Register a
   cleanup to destroy the parser.  */

static struct cleanup *
gdb_xml_create_parser_and_cleanup (const char *name,
				   const struct gdb_xml_element *elements,
				   void *user_data,
				   struct gdb_xml_parser **parser_result)
{
  struct gdb_xml_parser *parser;
  struct scope_level start_scope;
  struct cleanup *result;

  /* Initialize the parser.  */
  parser = XZALLOC (struct gdb_xml_parser);
  parser->expat_parser = XML_ParserCreateNS (NULL, '!');
  if (parser->expat_parser == NULL)
    {
      xfree (parser);
      malloc_failure (0);
    }

  parser->name = name;

  parser->user_data = user_data;
  XML_SetUserData (parser->expat_parser, parser);

  /* Set the callbacks.  */
  XML_SetElementHandler (parser->expat_parser, gdb_xml_start_element_wrapper,
			 gdb_xml_end_element_wrapper);
  XML_SetCharacterDataHandler (parser->expat_parser, gdb_xml_body_text);

  /* Initialize the outer scope.  */
  memset (&start_scope, 0, sizeof (start_scope));
  start_scope.elements = elements;
  VEC_safe_push (scope_level_s, parser->scopes, &start_scope);

  *parser_result = parser;
  return make_cleanup (gdb_xml_cleanup, parser);
}

/* External entity handler.  The only external entities we support
   are those compiled into GDB (we do not fetch entities from the
   target).  */

static int XMLCALL
gdb_xml_fetch_external_entity (XML_Parser expat_parser,
			       const XML_Char *context,
			       const XML_Char *base,
			       const XML_Char *systemId,
			       const XML_Char *publicId)
{
  struct gdb_xml_parser *parser = XML_GetUserData (expat_parser);
  XML_Parser entity_parser;
  const char *text;
  enum XML_Status status;

  if (systemId == NULL)
    {
      text = fetch_xml_builtin (parser->dtd_name);
      if (text == NULL)
	internal_error (__FILE__, __LINE__,
			_("could not locate built-in DTD %s"),
			parser->dtd_name);
    }
  else
    {
      text = fetch_xml_builtin (systemId);
      if (text == NULL)
	return XML_STATUS_ERROR;
    }

  entity_parser = XML_ExternalEntityParserCreate (expat_parser, context, NULL);

  /* Don't use our handlers for the contents of the DTD.  Just let expat
     process it.  */
  XML_SetElementHandler (entity_parser, NULL, NULL);
  XML_SetDoctypeDeclHandler (entity_parser, NULL, NULL);
  XML_SetXmlDeclHandler (entity_parser, NULL);
  XML_SetDefaultHandler (entity_parser, NULL);
  XML_SetUserData (entity_parser, NULL);

  status = XML_Parse (entity_parser, text, strlen (text), 1);

  XML_ParserFree (entity_parser);
  return status;
}

/* Associate DTD_NAME, which must be the name of a compiled-in DTD,
   with PARSER.  */

void
gdb_xml_use_dtd (struct gdb_xml_parser *parser, const char *dtd_name)
{
  enum XML_Error err;

  parser->dtd_name = dtd_name;

  XML_SetParamEntityParsing (parser->expat_parser,
			     XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE);
  XML_SetExternalEntityRefHandler (parser->expat_parser,
				   gdb_xml_fetch_external_entity);

  /* Even if no DTD is provided, use the built-in DTD anyway.  */
  err = XML_UseForeignDTD (parser->expat_parser, XML_TRUE);
  if (err != XML_ERROR_NONE)
    internal_error (__FILE__, __LINE__,
		    _("XML_UseForeignDTD failed: %s"),
		    XML_ErrorString (err));
}

/* Invoke PARSER on BUFFER.  BUFFER is the data to parse, which
   should be NUL-terminated.

   The return value is 0 for success or -1 for error.  It may throw,
   but only if something unexpected goes wrong during parsing; parse
   errors will be caught, warned about, and reported as failure.  */

int
gdb_xml_parse (struct gdb_xml_parser *parser, const char *buffer)
{
  enum XML_Status status;
  const char *error_string;

  gdb_xml_debug (parser, _("Starting:\n%s"), buffer);

  status = XML_Parse (parser->expat_parser, buffer, strlen (buffer), 1);

  if (status == XML_STATUS_OK && parser->error.reason == 0)
    return 0;

  if (parser->error.reason == RETURN_ERROR
      && parser->error.error == XML_PARSE_ERROR)
    {
      gdb_assert (parser->error.message != NULL);
      error_string = parser->error.message;
    }
  else if (status == XML_STATUS_ERROR)
    {
      enum XML_Error err = XML_GetErrorCode (parser->expat_parser);

      error_string = XML_ErrorString (err);
    }
  else
    {
      gdb_assert (parser->error.reason < 0);
      throw_exception (parser->error);
    }

  if (parser->last_line != 0)
    warning (_("while parsing %s (at line %d): %s"), parser->name,
	     parser->last_line, error_string);
  else
    warning (_("while parsing %s: %s"), parser->name, error_string);

  return -1;
}

int
gdb_xml_parse_quick (const char *name, const char *dtd_name,
		     const struct gdb_xml_element *elements,
		     const char *document, void *user_data)
{
  struct gdb_xml_parser *parser;
  struct cleanup *back_to;
  int result;

  back_to = gdb_xml_create_parser_and_cleanup (name, elements,
					       user_data, &parser);
  if (dtd_name != NULL)
    gdb_xml_use_dtd (parser, dtd_name);
  result = gdb_xml_parse (parser, document);

  do_cleanups (back_to);

  return result;
}

/* Parse a field VALSTR that we expect to contain an integer value.
   The integer is returned in *VALP.  The string is parsed with an
   equivalent to strtoul.

   Returns 0 for success, -1 for error.  */

static int
xml_parse_unsigned_integer (const char *valstr, ULONGEST *valp)
{
  const char *endptr;
  ULONGEST result;

  if (*valstr == '\0')
    return -1;

  result = strtoulst (valstr, &endptr, 0);
  if (*endptr != '\0')
    return -1;

  *valp = result;
  return 0;
}

/* Parse an integer string into a ULONGEST and return it, or call
   gdb_xml_error if it could not be parsed.  */

ULONGEST
gdb_xml_parse_ulongest (struct gdb_xml_parser *parser, const char *value)
{
  ULONGEST result;

  if (xml_parse_unsigned_integer (value, &result) != 0)
    gdb_xml_error (parser, _("Can't convert \"%s\" to an integer"), value);

  return result;
}

/* Parse an integer attribute into a ULONGEST.  */

void *
gdb_xml_parse_attr_ulongest (struct gdb_xml_parser *parser,
			     const struct gdb_xml_attribute *attribute,
			     const char *value)
{
  ULONGEST result;
  void *ret;

  if (xml_parse_unsigned_integer (value, &result) != 0)
    gdb_xml_error (parser, _("Can't convert %s=\"%s\" to an integer"),
		   attribute->name, value);

  ret = xmalloc (sizeof (result));
  memcpy (ret, &result, sizeof (result));
  return ret;
}

/* A handler_data for yes/no boolean values.  */

const struct gdb_xml_enum gdb_xml_enums_boolean[] = {
  { "yes", 1 },
  { "no", 0 },
  { NULL, 0 }
};

/* Map NAME to VALUE.  A struct gdb_xml_enum * should be saved as the
   value of handler_data when using gdb_xml_parse_attr_enum to parse a
   fixed list of possible strings.  The list is terminated by an entry
   with NAME == NULL.  */

void *
gdb_xml_parse_attr_enum (struct gdb_xml_parser *parser,
			 const struct gdb_xml_attribute *attribute,
			 const char *value)
{
  const struct gdb_xml_enum *enums = attribute->handler_data;
  void *ret;

  for (enums = attribute->handler_data; enums->name != NULL; enums++)
    if (strcasecmp (enums->name, value) == 0)
      break;

  if (enums->name == NULL)
    gdb_xml_error (parser, _("Unknown attribute value %s=\"%s\""),
		 attribute->name, value);

  ret = xmalloc (sizeof (enums->value));
  memcpy (ret, &enums->value, sizeof (enums->value));
  return ret;
}


/* XInclude processing.  This is done as a separate step from actually
   parsing the document, so that we can produce a single combined XML
   document - e.g. to hand to a front end or to simplify comparing two
   documents.  We make extensive use of XML_DefaultCurrent, to pass
   input text directly into the output without reformatting or
   requoting it.

   We output the DOCTYPE declaration for the first document unchanged,
   if present, and discard DOCTYPEs from included documents.  Only the
   one we pass through here is used when we feed the result back to
   expat.  The XInclude standard explicitly does not discuss
   validation of the result; we choose to apply the same DTD applied
   to the outermost document.

   We can not simply include the external DTD subset in the document
   as an internal subset, because <!IGNORE> and <!INCLUDE> are valid
   only in external subsets.  But if we do not pass the DTD into the
   output at all, default values will not be filled in.

   We don't pass through any <?xml> declaration because we generate
   UTF-8, not whatever the input encoding was.  */

struct xinclude_parsing_data
{
  /* The obstack to build the output in.  */
  struct obstack obstack;

  /* A count indicating whether we are in an element whose
     children should not be copied to the output, and if so,
     how deep we are nested.  This is used for anything inside
     an xi:include, and for the DTD.  */
  int skip_depth;

  /* The number of <xi:include> elements currently being processed,
     to detect loops.  */
  int include_depth;

  /* A function to call to obtain additional features, and its
     baton.  */
  xml_fetch_another fetcher;
  void *fetcher_baton;
};

static void
xinclude_start_include (struct gdb_xml_parser *parser,
			const struct gdb_xml_element *element,
			void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct xinclude_parsing_data *data = user_data;
  char *href = xml_find_attribute (attributes, "href")->value;
  struct cleanup *back_to;
  char *text, *output;

  gdb_xml_debug (parser, _("Processing XInclude of \"%s\""), href);

  if (data->include_depth > MAX_XINCLUDE_DEPTH)
    gdb_xml_error (parser, _("Maximum XInclude depth (%d) exceeded"),
		   MAX_XINCLUDE_DEPTH);

  text = data->fetcher (href, data->fetcher_baton);
  if (text == NULL)
    gdb_xml_error (parser, _("Could not load XML document \"%s\""), href);
  back_to = make_cleanup (xfree, text);

  output = xml_process_xincludes (parser->name, text, data->fetcher,
				  data->fetcher_baton,
				  data->include_depth + 1);
  if (output == NULL)
    gdb_xml_error (parser, _("Parsing \"%s\" failed"), href);

  obstack_grow (&data->obstack, output, strlen (output));
  xfree (output);

  do_cleanups (back_to);

  data->skip_depth++;
}

static void
xinclude_end_include (struct gdb_xml_parser *parser,
		      const struct gdb_xml_element *element,
		      void *user_data, const char *body_text)
{
  struct xinclude_parsing_data *data = user_data;

  data->skip_depth--;
}

static void XMLCALL
xml_xinclude_default (void *data_, const XML_Char *s, int len)
{
  struct gdb_xml_parser *parser = data_;
  struct xinclude_parsing_data *data = parser->user_data;

  /* If we are inside of e.g. xi:include or the DTD, don't save this
     string.  */
  if (data->skip_depth)
    return;

  /* Otherwise just add it to the end of the document we're building
     up.  */
  obstack_grow (&data->obstack, s, len);
}

static void XMLCALL
xml_xinclude_start_doctype (void *data_, const XML_Char *doctypeName,
			    const XML_Char *sysid, const XML_Char *pubid,
			    int has_internal_subset)
{
  struct gdb_xml_parser *parser = data_;
  struct xinclude_parsing_data *data = parser->user_data;

  /* Don't print out the doctype, or the contents of the DTD internal
     subset, if any.  */
  data->skip_depth++;
}

static void XMLCALL
xml_xinclude_end_doctype (void *data_)
{
  struct gdb_xml_parser *parser = data_;
  struct xinclude_parsing_data *data = parser->user_data;

  data->skip_depth--;
}

static void XMLCALL
xml_xinclude_xml_decl (void *data_, const XML_Char *version,
		       const XML_Char *encoding, int standalone)
{
  /* Do nothing - this function prevents the default handler from
     being called, thus suppressing the XML declaration from the
     output.  */
}

static void
xml_xinclude_cleanup (void *data_)
{
  struct xinclude_parsing_data *data = data_;

  obstack_free (&data->obstack, NULL);
  xfree (data);
}

const struct gdb_xml_attribute xinclude_attributes[] = {
  { "href", GDB_XML_AF_NONE, NULL, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

const struct gdb_xml_element xinclude_elements[] = {
  { "http://www.w3.org/2001/XInclude!include", xinclude_attributes, NULL,
    GDB_XML_EF_OPTIONAL | GDB_XML_EF_REPEATABLE,
    xinclude_start_include, xinclude_end_include },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

/* The main entry point for <xi:include> processing.  */

char *
xml_process_xincludes (const char *name, const char *text,
		       xml_fetch_another fetcher, void *fetcher_baton,
		       int depth)
{
  struct gdb_xml_parser *parser;
  struct xinclude_parsing_data *data;
  struct cleanup *back_to;
  char *result = NULL;

  data = XZALLOC (struct xinclude_parsing_data);
  obstack_init (&data->obstack);
  back_to = make_cleanup (xml_xinclude_cleanup, data);

  gdb_xml_create_parser_and_cleanup (name, xinclude_elements,
				     data, &parser);
  parser->is_xinclude = 1;

  data->include_depth = depth;
  data->fetcher = fetcher;
  data->fetcher_baton = fetcher_baton;

  XML_SetCharacterDataHandler (parser->expat_parser, NULL);
  XML_SetDefaultHandler (parser->expat_parser, xml_xinclude_default);

  /* Always discard the XML version declarations; the only important
     thing this provides is encoding, and our result will have been
     converted to UTF-8.  */
  XML_SetXmlDeclHandler (parser->expat_parser, xml_xinclude_xml_decl);

  if (depth > 0)
    /* Discard the doctype for included documents.  */
    XML_SetDoctypeDeclHandler (parser->expat_parser,
			       xml_xinclude_start_doctype,
			       xml_xinclude_end_doctype);

  gdb_xml_use_dtd (parser, "xinclude.dtd");

  if (gdb_xml_parse (parser, text) == 0)
    {
      obstack_1grow (&data->obstack, '\0');
      result = xstrdup (obstack_finish (&data->obstack));

      if (depth == 0)
	gdb_xml_debug (parser, _("XInclude processing succeeded."));
    }
  else
    result = NULL;

  do_cleanups (back_to);
  return result;
}
#endif /* HAVE_LIBEXPAT */


/* Return an XML document which was compiled into GDB, from
   the given FILENAME, or NULL if the file was not compiled in.  */

const char *
fetch_xml_builtin (const char *filename)
{
  const char *(*p)[2];

  for (p = xml_builtin; (*p)[0]; p++)
    if (strcmp ((*p)[0], filename) == 0)
      return (*p)[1];

  return NULL;
}

/* A to_xfer_partial helper function which reads XML files which were
   compiled into GDB.  The target may call this function from its own
   to_xfer_partial handler, after converting object and annex to the
   appropriate filename.  */

LONGEST
xml_builtin_xfer_partial (const char *filename,
			  gdb_byte *readbuf, const gdb_byte *writebuf,
			  ULONGEST offset, LONGEST len)
{
  const char *buf;
  LONGEST len_avail;

  gdb_assert (readbuf != NULL && writebuf == NULL);
  gdb_assert (filename != NULL);

  buf = fetch_xml_builtin (filename);
  if (buf == NULL)
    return -1;

  len_avail = strlen (buf);
  if (offset >= len_avail)
    return 0;

  if (len > len_avail - offset)
    len = len_avail - offset;
  memcpy (readbuf, buf + offset, len);
  return len;
}


static void
show_debug_xml (struct ui_file *file, int from_tty,
		struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("XML debugging is %s.\n"), value);
}

void
obstack_xml_printf (struct obstack *obstack, const char *format, ...)
{
  va_list ap;
  const char *f;
  const char *prev;
  int percent = 0;

  va_start (ap, format);

  prev = format;
  for (f = format; *f; f++)
    {
      if (percent)
       {
         switch (*f)
           {
           case 's':
             {
               char *p;
               char *a = va_arg (ap, char *);

               obstack_grow (obstack, prev, f - prev - 1);
               p = xml_escape_text (a);
               obstack_grow_str (obstack, p);
               xfree (p);
               prev = f + 1;
             }
             break;
           }
         percent = 0;
       }
      else if (*f == '%')
       percent = 1;
    }

  obstack_grow_str (obstack, prev);
  va_end (ap);
}

char *
xml_fetch_content_from_file (const char *filename, void *baton)
{
  const char *dirname = baton;
  FILE *file;
  struct cleanup *back_to;
  char *text;
  size_t len, offset;

  if (dirname && *dirname)
    {
      char *fullname = concat (dirname, "/", filename, (char *) NULL);

      if (fullname == NULL)
	malloc_failure (0);
      file = gdb_fopen_cloexec (fullname, FOPEN_RT);
      xfree (fullname);
    }
  else
    file = gdb_fopen_cloexec (filename, FOPEN_RT);

  if (file == NULL)
    return NULL;

  back_to = make_cleanup_fclose (file);

  /* Read in the whole file, one chunk at a time.  */
  len = 4096;
  offset = 0;
  text = xmalloc (len);
  make_cleanup (free_current_contents, &text);
  while (1)
    {
      size_t bytes_read;

      /* Continue reading where the last read left off.  Leave at least
	 one byte so that we can NUL-terminate the result.  */
      bytes_read = fread (text + offset, 1, len - offset - 1, file);
      if (ferror (file))
	{
	  warning (_("Read error from \"%s\""), filename);
	  do_cleanups (back_to);
	  return NULL;
	}

      offset += bytes_read;

      if (feof (file))
	break;

      len = len * 2;
      text = xrealloc (text, len);
    }

  fclose (file);
  discard_cleanups (back_to);

  text[offset] = '\0';
  return text;
}

void _initialize_xml_support (void);

void
_initialize_xml_support (void)
{
  add_setshow_boolean_cmd ("xml", class_maintenance, &debug_xml,
			   _("Set XML parser debugging."),
			   _("Show XML parser debugging."),
			   _("When set, debugging messages for XML parsers "
			     "are displayed."),
			   NULL, show_debug_xml,
			   &setdebuglist, &showdebuglist);
}
@


1.28
log
@	PR gdb/7912:
	* Makefile.in (SFILES): Add filestuff.c
	(COMMON_OBS): Add filestuff.o.
	(filestuff.o): New target.
	* auto-load.c (auto_load_objfile_script_1): Use
	gdb_fopen_cloexec.
	* auxv.c (procfs_xfer_auxv): Use gdb_open_cloexec.
	* cli/cli-cmds.c (shell_escape): Call close_most_fds.
	* cli/cli-dump.c (fopen_with_cleanup): Use gdb_fopen_cloexec.
	* common/agent.c (gdb_connect_sync_socket): Use
	gdb_socket_cloexec.
	* common/filestuff.c: New file.
	* common/filestuff.h: New file.
	* common/linux-osdata.c (linux_common_core_of_thread)
	(command_from_pid, commandline_from_pid, print_source_lines)
	(linux_xfer_osdata_shm, linux_xfer_osdata_sem)
	(linux_xfer_osdata_msg, linux_xfer_osdata_modules): Use
	gdb_fopen_cloexec.
	* common/linux-procfs.c (linux_proc_get_int)
	(linux_proc_pid_has_state): Use gdb_fopen_cloexec.
	* config.in, configure: Rebuild.
	* configure.ac: Don't check for sys/socket.h.  Check for
	fdwalk, pipe2.
	* corelow.c (core_open): Use gdb_open_cloexec.
	* dwarf2read.c (write_psymtabs_to_index): Use gdb_fopen_cloexec.
	* fork-child.c (fork_inferior): Call close_most_fds.
	* gdb_bfd.c (gdb_bfd_open): Use gdb_open_cloexec.
	* inf-child.c (inf_child_fileio_readlink): Use gdb_open_cloexec.
	* linux-nat.c (linux_nat_thread_name, linux_proc_pending_signals):
	Use gdb_fopen_cloexec.
	(linux_proc_xfer_partial, linux_proc_xfer_spu): Use
	gdb_open_cloexec.
	(linux_async_pipe): Use gdb_pipe_cloexec.
	* remote-fileio.c (remote_fileio_func_open): Use
	gdb_open_cloexec.
	* remote.c (remote_file_put, remote_file_get): Use
	gdb_fopen_cloexec.
	* ser-pipe.c (pipe_open): Use gdb_socketpair_cloexec,
	close_most_fds.
	* ser-tcp.c (net_open): Use gdb_socket_cloexec.
	* ser-unix.c (hardwire_open): Use gdb_open_cloexec.
	* solib.c (solib_find): Use gdb_open_cloexec.
	* source.c (openp, find_and_open_source): Use gdb_open_cloexec.
	* tracepoint.c (tfile_start): Use gdb_fopen_cloexec.
	(tfile_open): Use gdb_open_cloexec.
	* tui/tui-io.c (tui_initialize_io): Use gdb_pipe_cloexec.
	* ui-file.c (gdb_fopen): Use gdb_fopen_cloexec.
	* xml-support.c (xml_fetch_content_from_file): Use
	gdb_fopen_cloexec.
	* main.c (captured_main): Call notice_open_fds.
gdbserver
	* Makefile.in (SFILES): Add filestuff.c.
	(OBS): Add filestuff.o.
	(filestuff.o): New target.
	* config.in, configure: Rebuild.
	* configure.ac: Check for fdwalk, pipe2.
@
text
@d443 2
a444 2
/* Initialize and return a parser.  Register a cleanup to destroy the
   parser.  */
d446 5
a450 4
static struct gdb_xml_parser *
gdb_xml_create_parser_and_cleanup_1 (const char *name,
				     const struct gdb_xml_element *elements,
				     void *user_data, struct cleanup **old_chain)
d454 1
a454 1
  struct cleanup *dummy;
d480 2
a481 19
  if (old_chain == NULL)
    old_chain = &dummy;

  *old_chain = make_cleanup (gdb_xml_cleanup, parser);
  return parser;
}

/* Initialize and return a parser.  Register a cleanup to destroy the
   parser.  */

struct gdb_xml_parser *
gdb_xml_create_parser_and_cleanup (const char *name,
				   const struct gdb_xml_element *elements,
				   void *user_data)
{
  struct cleanup *old_chain;

  return gdb_xml_create_parser_and_cleanup_1 (name, elements, user_data,
					      &old_chain);
d610 2
a611 2
  parser = gdb_xml_create_parser_and_cleanup_1 (name, elements,
						user_data, &back_to);
d884 2
a885 1
  parser = gdb_xml_create_parser_and_cleanup (name, xinclude_elements, data);
@


1.27
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d24 1
d1048 1
a1048 1
      file = fopen (fullname, FOPEN_RT);
d1052 1
a1052 1
    file = fopen (filename, FOPEN_RT);
@


1.26
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.25
log
@2011-07-22  Kwok Cheung Yeung  <kcy@@codesourcery.com>

gdb/
	* defs.h: Add guard against inclusion in gdbserver.
	(struct ptid, ptid_t): Move to common/ptid.h.
	(xfree, xzalloc, xasprintf, xvasprintf, xstrprintf, xstrvprintf,
	xsnprintf, internal_error): Move to common/common-utils.h.
	(nomem): Delete.
	* gdb_assert.h: Move into common/ sub-directory.
	* gdb_locale.h: Ditto.
	* gdb_dirent.h: Ditto.
	* inferior.h (minus_one_ptid, null_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid):
	Move into common/ptid.h.
	* xml-support.c (xml_escape_text): Move into common/xml-utils.c.
	(gdb_xml_create_parser_and_cleanup_1, xml_fetch_context_from_file):
	Change nomem to malloc_failure.
	* xml-support.h (xml_escape_text): Move into common/xml-utils.h.
	* utils.c (nomem): Rename to malloc_failure.
	(xmalloc, xzalloc, xrealloc, xcalloc, xfree, xstrprintf, xasprintf,
	xvasprintf, xstrvprintf, xsnprintf): Move to common/common-utils.c.
	(gdb_buildargv): Change nomem to malloc_failure.
	* infrun.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal,
	ptid_is_pid): Move into common/ptid.c.
	(initialize_infrun): Delete initialization of null_ptid and
	minus_one_ptid.
	* linux-nat.c (linux_nat_xfer_osdata): Defer to
	linux_common_xfer_osdata.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/ptid.c and common/buffer.c.
	(HFILES_NO_SRCDIR): Add common/common-utils.h, common/xml-utils.h,
	common/ptid.h, common/buffer.h and common/linux-osdata.h.
	(COMMON_OBS): Add xml-utils.o, common-utils.o, buffer.o and ptid.o.
	(common-utils.o, xml-utils.o, ptid.o, buffer.o, linux-osdata.o): New
	rules.
	* common/gdb_assert.h: New.
	* common/gdb_dirent.h: New.
	* common/gdb_locale.h: New.
	* common/buffer.c: New.
	* common/buffer.h: New.
	* common/ptid.c: New.
	* common/ptid.h: New.
	* common/xml-utils.c: New.
	* common/xml-utils.h: New.
	* common/common-utils.c: New.
	* common/common-utils.h: New.
	* common/linux-osdata.c: New.
	* common/linux-osdata.h: New.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Add linux-osdata.o.
	* config/arm/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux64.mh (NATDEPFILES): Ditto.
	* config/ia64/linux.mh (NATDEPFILES): Ditto.
	* config/m32r/linux.mh (NATDEPFILES): Ditto.
	* config/m68k/linux.mh (NATDEPFILES): Ditto.
	* config/mips/linux.mh (NATDEPFILES): Ditto.
	* config/pa/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Ditto.
	* config/s390/s390.mh (NATDEPFILES): Ditto.
	* config/sparc/linux.mh (NATDEPFILES): Ditto.
	* config/sparc/linux64.mh (NATDEPFILES): Ditto.
	* config/xtensa/linux.mh (NATDEPFILES): Ditto.

gdbserver/
	* linux-low.c (compare_ints, unique, list_threads, show_process,
	linux_core_of_thread): Delete.
	(linux_target_ops): Change linux_core_of_thread to
	linux_common_core_of_thread.
	(linux_qxfer_osdata): Defer to linux_common_xfer_osdata.
	* utils.c (malloc_failure): Change type of argument.
	(xmalloc, xrealloc, xcalloc, xsnprintf): Delete.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/linux-osdata.c, common/ptid.c and common/buffer.c.
	(OBS): Add xml-utils.o, common-utils.o, ptid.o and buffer.o.
	(IPA_OBJS): Add common-utils-ipa.o.
	(ptid_h, linux_osdata_h): New macros.
	(server_h): Add common/common-utils.h, common/xml-utils.h,
	common/buffer.h, common/gdb_assert.h, common/gdb_locale.h and
	common/ptid.h.
	(common-utils-ipa.o, common-utils.o, xml-utils.o, linux-osdata.o,
	ptid.o, buffer.o): New rules.
	(linux-low.o): Add common/linux-osdata.h as a dependency.
	* configure.srv (srv_tgtobj): Add linux-osdata.o to Linux targets.
	* configure.ac: Add AC_HEADER_DIRENT check.
	* config.in: Regenerate.
	* configure: Regenerate.
	* remote-utils.c (xml_escape_text): Delete.
	(buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf): Move to common/buffer.c.
	* server.c (main): Remove call to initialize_inferiors.
	* server.h (struct ptid, ptid_t, minus_one_ptid, null_ptid,
	ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp, ptid_get_tid,
	ptid_equal, ptid_is_pid, initialize_inferiors, xml_escape_text,
	internal_error, gdb_assert, gdb_assert_fail): Delete.
	(struct buffer, buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf, buffer_grow_str, buffer_grow_str0): Move to
	common/buffer.h.
	* inferiors.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid,
	initialize_inferiors): Delete.
@
text
@d3 1
a3 2
   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.25.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.24
log
@	* xml-support.c (xml_find_attribute): New.
	(xinclude_start_include): Use it.
	* xml-support.h (xml_find_attribute): Declare.
	* memory-map.c (memory_map_start_memory)
	(memory_map_start_property): Use xml_find_attribute.
	* osdata.c (osdata_start_osdata, osdata_start_column): Use
	xml_find_attribute.
	* remote.c (start_thread): Use xml_find_attribute.
	* solib-target.c (library_list_start_segment)
	(library_list_start_section, library_list_start_library)
	(library_list_start_list): Use xml_find_attribute.
	* xml-tdesc.c (tdesc_start_target, tdesc_start_feature)
	(tdesc_start_union, tdesc_start_struct, tdesc_start_flags)
	(tdesc_start_field): Use xml_find_attribute.
@
text
@d461 1
a461 1
      nomem (0);
a992 62
/* Return a malloc allocated string with special characters from TEXT
   replaced by entity references.  */

char *
xml_escape_text (const char *text)
{
  char *result;
  int i, special;

  /* Compute the length of the result.  */
  for (i = 0, special = 0; text[i] != '\0'; i++)
    switch (text[i])
      {
      case '\'':
      case '\"':
	special += 5;
	break;
      case '&':
	special += 4;
	break;
      case '<':
      case '>':
	special += 3;
	break;
      default:
	break;
      }

  /* Expand the result.  */
  result = xmalloc (i + special + 1);
  for (i = 0, special = 0; text[i] != '\0'; i++)
    switch (text[i])
      {
      case '\'':
	strcpy (result + i + special, "&apos;");
	special += 5;
	break;
      case '\"':
	strcpy (result + i + special, "&quot;");
	special += 5;
	break;
      case '&':
	strcpy (result + i + special, "&amp;");
	special += 4;
	break;
      case '<':
	strcpy (result + i + special, "&lt;");
	special += 3;
	break;
      case '>':
	strcpy (result + i + special, "&gt;");
	special += 3;
	break;
      default:
	result[i + special] = text[i];
	break;
      }
  result[i + special] = '\0';

  return result;
}

d1047 1
a1047 1
	nomem (0);
@


1.23
log
@	Simplify XML parsing a bit.

	* xml-support.h (gdb_xml_parse_quick): Declare.
	* xml-support.c (gdb_xml_create_parser_and_cleanup_1): Renamed
	from gdb_xml_create_parser_and_cleanup, and added `old_chain'
	parameter.
	(gdb_xml_create_parser_and_cleanup): Reimplement on top of
	gdb_xml_create_parser_and_cleanup_1.
	(gdb_xml_parse_quick): New.
	* memory-map.c (parse_memory_map): Use gdb_xml_parse_quick.
	* osdata.c (osdata_parse): Ditto.
	* remote.c (remote_threads_info): Ditto.
	* solib-target.c (solib_target_parse_libraries): Ditto.
	* xml-syscall.c (syscall_parse_xml): Ditto.
	* xml-tdesc.c (tdesc_parse_xml): Ditto.
@
text
@d141 16
d777 1
a777 1
  char *href = VEC_index (gdb_xml_value_s, attributes, 0)->value;
@


1.22
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* ui-file.c: Comment cleanup, mostly periods and spaces.
	* ui-file.h: Ditto.
	* ui-out.c: Ditto.
	* ui-out.h: Ditto.
	* utils.c: Ditto.
	* v850-tdep.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* value.h: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vax-tdep.c: Ditto.
	* vec.c: Ditto.
	* vec.h: Ditto.
	* version.h: Ditto.
	* windows-nat.c: Ditto.
	* windows-tdep.c: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xml-support.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* xtensa-tdep.c: Ditto.
	* xtensa-tdep.h: Ditto.
@
text
@d430 4
a433 4
struct gdb_xml_parser *
gdb_xml_create_parser_and_cleanup (const char *name,
				   const struct gdb_xml_element *elements,
				   void *user_data)
d437 1
d463 2
a464 1
  make_cleanup (gdb_xml_cleanup, parser);
d466 1
d470 14
d601 20
@


1.21
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d342 1
a342 1
  /* Call the element processor. */
@


1.20
log
@run copyright.sh for 2011.
@
text
@d487 2
a488 1
	internal_error (__FILE__, __LINE__, "could not locate built-in DTD %s",
d533 2
a534 1
		    "XML_UseForeignDTD failed: %s", XML_ErrorString (err));
@


1.19
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* valarith.c: White space.
	* valops.c: White space.
	* valprint.c: White space.
	* value.c: White space.
	* varobj.c: White space.
	* xcoffread.c: White space.
	* xml-support.c: White space.
	* xml-tdesc.c: White space.
@
text
@d3 2
a4 1
   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.18
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* xml-support.c (xinclude_start_include): Delete unused variable.
	(xml_process_xincludes): Delete unused variable.
	* xml-syscall.c (syscall_parse_xml): Delete unused variable.
	* target-descriptions.c (tdesc_gdb_type): Delete unused variable.
	(tdesc_find_arch_register): Delete unused variable.
	(tdesc_use_registers): Delete unused variable.
	* xml-tdesc.c (tdesc_start_target): Delete unused variable.
	* inferior.c (print_inferior): Delete unused variable.
	* record.c (record_open_1): Delete unused variable.
	(record_restore): Delete unused variable.
	(cmd_record_save): Delete unused variable.
	* gcore.c (derive_heap_segment): Delete unused variable.
	(objfile_find_memory_regions): Use unused variable.
	* jit.c (jit_inferior_init): Delete unused variable.
	* progspace.c (clone_program_space): Delete unused variable.
	(pspace_empty_p): Delete unused variable.
@
text
@d563 1
d1020 1
d1051 1
@


1.17
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a722 1
  int ret;
a833 1
  enum XML_Error err;
@


1.16
log
@Implementing catch syscall.

* amd64-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(amd64_linux_get_syscall_number): New function.
(amd64_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* breakpoint.c: New include: xml-syscall.h.
(set_raw_breakpoint_without_location): Setting the parameters
for the catch syscall feature.
(insert_catch_syscall): New.
(remove_catch_syscall): New.
(breakpoint_hit_catch_syscall): New.
(print_it_catch_syscall): New.
(print_one_catch_syscall): New.
(print_mention_catch_syscall): New.
(catch_syscall_breakpoint_ops): New.
(syscall_catchpoint_p): New.
(create_catchpoint_without_mention): New.
(create_catchpoint): Modified in order to use
create_catchpoint_without_mention.
(create_syscall_event_catchpoint): New.
(clean_up_filters): New.
(catch_syscall_split_args): New.
(catch_syscall_command_1): New.
(delete_breakpoint): Add cleanup for catch syscall.
(is_syscall_catchpoint_enabled): New.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
(catch_syscall_completer): New completer function.
(add_catch_command): Add the completer function for catchpoints.
* breakpoint.h (syscalls_to_be_caught): New vector.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
* gdbarch.c: Regenerated.
* gdbarch.h: Regenerated.
* gdbarch.sh: Add syscall catchpoint functions and structures.
(get_syscall_number): New.
(UNKNOWN_SYSCALL): New definition.
* i386-linux-nat.c (i386_linux_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* i386-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(i386_linux_get_syscall_number): New.
(i386_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* inf-child.c (inf_child_set_syscall_catchpoint): New.
(inf_child_target): Assign default values to target_ops.
* inf-ptrace.c (inf_ptrace_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* inferior.h (struct inferior): Included new variables
any_syscall_count, syscalls_counts and total_syscalls_count,
used to keep track of requested syscall catchpoints.
* infrun.c (resume): Add syscall catchpoint.
(deal_with_syscall_event): New.
(handle_inferior_event): Add syscall entry/return events.
(inferior_has_called_syscall): New.
* linux-nat.c: Define some helpful variables to track wether we have
support for the needed ptrace option.
(linux_test_for_tracesysgood): New.
(linux_supports_tracesysgood): New.
(linux_enable_tracesysgood): New.
(linux_enable_event_reporting): Save the current used ptrace
options.
(linux_child_post_attach): Calling linux_enable_tracesysgood.
(linux_child_post_startup_inferior): Likewise.
(linux_child_set_syscall_catchpoint): New function.
(linux_handle_extended_wait): Handle the case which the inferior stops
because it has called or returned from a syscall.
(linux_target_install_ops): Install the necessary functions to handle
syscall catchpoints.
* linux-nat.h (struct lwp_info): Include syscall_state into the
structure, which indicates if we are in a syscall entry or return.
* ppc-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall filename for the arch.
(ppc_linux_get_syscall_number): New.
(ppc_linux_init_abi): Register the correct functions for syscall
catchpoint; setting the correct name for the XML syscall file.
* target.c (update_current_target): Update/copy functions related to
syscall catchpoint.
(target_waitstatus_to_string): Add syscall catchpoint entry/return
events.
* target.h (struct target_waitstatus): Add syscall number.
(struct syscall): New struct to hold information about syscalls
in the system.
(struct target_ops): Add ops for syscall catchpoint.
(inferior_has_called_syscall): New.
(target_set_syscall_catchpoint): New.
* xml-support.c (xml_fetch_content_from_file): New function,
transferred from xml-tdesc.c.
* xml-support.h (xml_fetch_content_from_file): New.
* xml-tdesc.c (fetch_xml_from_file): Function removed;
transferred to xml-support.c.
(file_read_description_xml): Updated to use the new
xml_fetch_content_from_file function.
* syscalls/gdb-syscalls.dtd: New definition file for syscall's XML
support.
* syscalls/amd64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use amd64 architecture.
* syscalls/i386-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use i386 architecture.
* syscalls/ppc-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC architecture.
* syscalls/ppc64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC64 architecture.
* xml-syscall.c: New file containing functions for manipulating
syscall's XML files.
* xml-syscall.h: New file, exporting the functions above mentioned.
* Makefile.in: Support for relocatable GDB datadir and XML
syscall.
* NEWS: Added information about the catch syscall feature.
* doc/gdb.texinfo (Set Catchpoints): Documentation about the new
feature.
* testsuite/Makefile.in: Inclusion of catch-syscall object.
* testsuite/gdb.base/catch-syscall.c: New file.
* testsuite/gdb.base/catch-syscall.exp: New file.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.15
log
@        Updated copyright notices for most files.
@
text
@d1039 60
@


1.14
log
@	Implement -list-thread-groups --available

        * Makefile.in (XMLFILES): Add osdata.dtd.
        (SFILES): Add osdata.c.
        (COMMON_OBS): Add osdata.o.
        * linux-nat.c: Include pwd.h, sys/types.h, gdb_dirent.h and xml-support.h.
        (linux_nat_xfer_osdata): New function.
        (linux_xfer_partial): Handle TARGET_OBJECT_OSDATA.
        * osdata.c: New file.
        * osdata.h: New file.
        * remote.c (PACKET_qXfer_osdata): New packet enum.
        (remote_protocol_features): Add "qXfer:osdata:read".
        (remote_read_qxfer): Handle TARGET_OBJECT_OSDATA.
        (extended_remote_can_run): New.
        (init_extended_remote_ops): Set to_can_run to
        extended_remote_can_run.
        (_initialize_remote): Add packet config command for
        "qXfer:osdata:read".
        * xml-support.c (obstack_xml_printf): New function.
        * xml-support.h (obstack_xml_printf): Declare.
        * target.c (target_get_osdata): New function.
        * target.h (enum target_object): Add TARGET_OBJECT_OSDATA.
        (target_os_data): Declare.
        * features/osdata.dtd: New file.
        * mi/mi-main.c (mi_list_thread_groups): Handle the --available
        option.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.13
log
@	Updated copyright notices for most files.
@
text
@d1000 39
@


1.12
log
@	* gdbarch.sh (core_xfer_shared_libraries): New.

	* corelow.c (core_xfer_partial): Handle TARGET_OBJECT_LIBRARIES.

	* gdb_obstack.h (obstack_grow_str, obstack_grow_str0): New.

	* xml-support.c (gdb_xml_parse): Debug output tweaks.
	(xml_escape_text): New.
	* xml-support.h (xml_escape_text): Declare.

	* config/i386/cygwin.mh (NATDEPFILES): Move corelow.o to ...
	* config/i386/cygwin.mt (TDEPFILES): ... here.

	* win32-nat.c: (fetch_elf_core_registers): Delete.
	(win32_elf_core_fn): Delete.
	(_initialize_core_win32): Delete.

	* i386-cygwin-tdep.c: Include "regset.h", "gdb_objstack.h",
	"xml-support.h" and "gdbcore.h".
	(i386_win32_gregset_reg_offset): New.
	(I386_WIN32_SIZEOF_GREGSET): New.
	(i386_win32_regset_from_core_section): New.
	(win32_xfer_shared_library): New.
	(struct cpms_data): New.
	(core_process_module_section): New.
	(win32_core_xfer_shared_libraries): New.
	(i386_cygwin_skip_trampoline_code): Register gregset_reg_offset,
	gregset_num_regs, sizeof_gregset members of tdep.  Register
	regset_from_core_section and core_xfer_shared_libraries callbacks.

	* Makefile.in (i386-cygwin-tdep.o): Update dependencies.
	* gdbarch.h, gdbarch.c: Regenerate.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
@


1.11
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d547 2
d874 1
a874 2
	gdb_xml_debug (parser, _("XInclude processing succeeded:\n%s"),
		       result);
d938 62
@


1.10
log
@	* Makefile.in (XMLFILES): Include $(TDEP_XML).
	(filenames_h): New variable.
	(clean): Clean up xml-builtin.c and stamp-xml.
	(arm-linux-nat.o): Update.
	* config/arm/linux.mh (TDEP_XML): Define.
	* arm-linux-nat.c (PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_linux_has_wmmx_registers): New.
	(GET_THREAD_ID): Fix typo.
	(IWMMXT_REGS_SIZE): Define.
	(fetch_wmmx_regs, store_wmmx_regs): New.
	(arm_linux_fetch_inferior_registers): Use fetch_wmmx_regs.
	(arm_linux_store_inferior_registers): Use store_wmmx_regs.
	(super_xfer_partial, arm_linux_xfer_partial): New.
	(_initialize_arm_linux_nat): Use them.
	* xml-support.c (fetch_xml_builtin): Move outside HAVE_LIBEXPAT.
	(xml_builtin_xfer_partial): New function.
	* xml-support.h (xml_builtin_xfer_partial): New prototype.
	* NEWS: Update mention of iWMMXt support.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.9
log
@	* Makefile.in (arm-tdep.o, eval.o, target-descriptions.o)
	(xml-tdesc.o): Update.
	* xml-support.c: Add a comment.
	(gdb_xml_enums_boolean): New variable.
	(gdb_xml_parse_attr_enum): Use strcasecmp.
	* xml-support.h (gdb_xml_enums_boolean): Declare.
	* xml-tdesc.c (struct tdesc_parsing_data): Record current_feature,
	next_regnum, and current_union.
	(tdesc_start_feature, tdesc_start_reg, tdesc_start_union)
	(tdesc_end_union, tdesc_start_field, tdesc_start_vector)
	(field_attributes, union_children, reg_attributes, union_attributes)
	(vector_attributes, feature_attributes, feature_children): New.
	(target_children): Make static.  Add <feature>.
	(tdesc_elements): Make static.
	* target-descriptions.c (struct tdesc_reg, tdesc_reg_p, type_p)
	(struct tdesc_feature, tdesc_feature_p): New types.
	(struct target_desc): Add features member.
	(struct tdesc_arch_data, tdesc_data): New.
	(target_find_description): Clarify error message.  Warn about
	ignored register descriptions.
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_data_init, tdesc_data_alloc)
	(tdesc_data_cleanup, tdesc_numbered_register)
	(tdesc_numbered_register_choices, tdesc_find_register)
	(tdesc_register_name, tdesc_register_type)
	(tdesc_remote_register_number, tdesc_register_reggroup_p)
	(set_tdesc_pseudo_register_name, set_tdesc_pseudo_register_type)
	(set_tdesc_pseudo_register_reggroup_p, tdesc_use_registers)
	(tdesc_free_reg, tdesc_create_reg, tdesc_free_feature)
	(tdesc_create_feature, tdesc_record_type): New.
	(free_target_description): Free features.
	(_initialize_target_descriptions): Initialize tdesc_data.
	* arch-utils.c (default_remote_register_number): New.
	* arch-utils.h (default_remote_register_number): New prototype.
	* target-descriptions.h (set_tdesc_pseudo_register_name)
	(set_tdesc_pseudo_register_type, set_tdesc_pseudo_register_reggroup_p)
	(tdesc_use_registers, tdesc_data_alloc, tdesc_data_cleanup)
	(tdesc_numbered_register, tdesc_numbered_register_choices)
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_create_feature, tdesc_record_type)
	(tdesc_create_reg): Declare.
	* gdbarch.sh (remote_register_number): New entry.
	* gdbarch.c, gdbarch.h: Regenerate.
	* remote.c (init_remote_state): Use gdbarch_remote_register_number.
	* features/gdb-target.dtd: Add feature, reg, vector, union, and field.

	* arm-tdep.c (arm_register_aliases): New.
	(arm_register_name_strings): Rename to...
	(arm_register_names): ...this.  Make const.  Delete the old version.
	(current_option, arm_register_byte): Delete.
	(set_disassembly_style): Simplify.  Do not adjust arm_register_names.
	(value_of_arm_user_reg): New.
	(arm_gdbarch_init): Verify any described registers.  Call
	tdesc_use_registers.  Don't use arm_register_byte.  Create aliases
	for standard register names.
	(_initialize_arm_tdep): Do not adjust arm_register_names.
	* user-regs.c (struct user_reg): Add baton member.
	(append_user_reg, user_reg_add_builtin, user_regs_init)
	(user_reg_add, value_of_user_reg): Use a baton for user
	register functions.
	* std-regs.c: Update.
	* user-regs.h (user_reg_read_ftype, user_reg_add_builtin)
	(user_reg_add): Add baton argument.
	* NEWS: Mention target description register support.
	* features/arm-core.xml, features/arm-fpa.xml: New.
	* eval.c (evaluate_subexp_standard): Allow ptype $register
	when the program is not running.

	* gdb.texinfo (-target-disconnect): Use @@smallexample.
	(Requirements): Add anchor for Expat.  Update description.
	(Target Descriptions): Mention Expat.
	(Target Description Format): Document new elements.  Use
	@@smallexample.
	(Predefined Target Types, Standard Target Features): New sections.
	* doc/gdbint.texinfo (Target Descriptions): New section.

	* gdb.xml/single-reg.xml, gdb.xml/tdesc-regs.exp,
	gdb.xml/core-only.xml, gdb.xml/extra-regs.xml: New files.
@
text
@d24 5
a36 3
#include "exceptions.h"
#include "xml-support.h"

a37 2
#include "gdb_string.h"
#include "safe-ctype.h"
d883 1
d901 30
a930 1
#endif /* HAVE_LIBEXPAT */
@


1.8
log
@	* Makefile.in (XMLFILES): New.
	(COMMON_OBS): Add xml-builtin.o.
	(xml-builtin.c, stamp-xml): New rules.
	(xml-tdesc.o): Update.
	* features/feature_to_c.sh: New file.
	* xml-support.c (MAX_XINCLUDE_DEPTH): Define.
	(struct gdb_xml_parser): Add dtd_name and is_xinclude.
	(gdb_xml_start_element): Initialize scope after possibly reallocating
	scopes.  Move cleanup later.  Handle the XInclude description
	specially.
	(gdb_xml_end_element): Only parse the body if there is a current element.
	Call XML_DefaultCurrent if there is no element.
	(gdb_xml_fetch_external_entity, gdb_xml_use_dtd): New.
	(struct xinclude_parsing_data, xinclude_start_include)
	(xinclude_end_include, xml_xinclude_default)
	(xml_xinclude_start_doctype, xml_xinclude_end_doctype)
	(xml_xinclude_xml_decl, xml_xinclude_cleanup, xinclude_attributes)
	(xinclude_elements, xml_process_xincludes, fetch_xml_builtin): New.
	* xml-support.h (xml_fetch_another, xml_process_xincludes)
	(fetch_xml_builtin, xml_builtin, gdb_xml_use_dtd): New declarations.
	* xml-tdesc.c (tdesc_parse_xml): Add fetcher_baton argument.  Expand
	XInclude directives.  Use the compiled in DTD.
	(fetch_xml_from_file): Add baton argument.  Treat it as a containing
	directory name.  Do not warn here.
	(file_read_description_xml): Update call.  Warn here instead.  Pass
	a dirname as baton.
	(fetch_available_features_from_target): New.
	(target_read_description_xml): Use it.
	* features/gdb-target.dtd: Add copyright notice.  Use xinclude.dtd
	to handle XInclude.
	* features/xinclude.dtd: New file.

	* gdb.xml/bad-include.xml, gdb.xml/inc-2.xml, gdb.xml/inc-body.xml,
	gdb.xml/includes.xml, gdb.xml/tdesc-xinclude.exp: New files.

	* gdb.texinfo (Target Description Format): Add section on XInclude.
@
text
@d43 2
d636 8
d658 1
a658 1
    if (strcmp (enums->name, value) == 0)
@


1.7
log
@Copyright updates for 2007.
@
text
@d39 4
d75 4
d163 1
a163 1
  struct scope_level *scope = VEC_last (scope_level_s, parser->scopes);
a170 2
  back_to = make_cleanup (gdb_xml_values_cleanup, &attributes);

d174 2
d177 1
a177 1
  VEC_safe_push (scope_level_s, parser->scopes, &new_scope);
d192 14
a206 1
      do_cleanups (back_to);
d215 2
a329 1
  char *body;
d342 1
a342 3
  if (scope->body == NULL)
    body = "";
  else
d344 18
a361 1
      int length;
d363 2
a364 9
      length = obstack_object_size (scope->body);
      obstack_1grow (scope->body, '\0');
      body = obstack_finish (scope->body);

      /* Strip leading and trailing whitespace.  */
      while (length > 0 && ISSPACE (body[length-1]))
	body[--length] = '\0';
      while (*body && ISSPACE (*body))
	body++;
d366 2
a367 4

  if (scope->element != NULL && scope->element->end_handler)
    scope->element->end_handler (parser, scope->element, parser->user_data,
				 body);
d466 68
d659 230
@


1.6
log
@	* configure.ac: Check for XML_StopParser.
	* xml-support.c (gdb_xml_body_text): Check for an error.
	(gdb_xml_start_element_wrapper): Conditionalize call to XML_StopParser.
	(gdb_xml_end_element_wrapper): Likewise.
	* config.in, configure: Regenerated.
@
text
@d3 1
a3 2
   Copyright (C) 2006
   Free Software Foundation, Inc.
@


1.5
log
@	* xml-support.c (gdb_xml_end_element): Remove wrong backslashes.
@
text
@d84 3
d292 1
d294 1
d370 1
d372 1
@


1.4
log
@	* memory-map.c (struct_memory_map_parsing_data): Remove most
	members.  Make property_name an array.
	(free_memory_map_parsing_data, memory_map_start_element)
	(memory_map_end_element, memory_map_character_data): Delete.
	(memory_map_start_memory, memory_map_end_memory)
	(memory_map_start_property, memory_map_end_property): New functions.
	(property_attributes, memory_children, memory_type_enum)
	(memory_attributes, memory_map_children, memory_map_elements): New.
	(parse_memory_map): Rewrite.
	* xml-support.c (debug_xml): New.
	(xml_get_required_attribute, xml_get_integer_attribute)
	(xml_get_enum_value, free_xml_parser, make_cleanup_free_xml_parser):
	Delete.
	(struct scope_level, struct gdb_xml_parser, gdb_xml_body_text)
	(gdb_xml_debug, gdb_xml_error, gdb_xml_values_cleanup)
	(gdb_xml_start_element, gdb_xml_start_element_wrapper)
	(gdb_xml_end_element, gdb_xml_end_element_wrapper, gdb_xml_cleanup)
	(gdb_xml_create_parser_and_cleanup, gdb_xml_parse)
	(gdb_xml_parse_ulongest, gdb_xml_parse_attr_ulongest)
	(gdb_xml_parse_attr_enum, show_debug_xml, _initialize_xml_support):
	New.
	* xml-support.h (struct gdb_xml_value, gdb_xml_attribute_handler)
	(enum gdb_xml_attribute_flag, struct gdb_xml_attribute)
	(enum gdb_xml_element_flag, struct gdb_xml_element)
	(gdb_xml_element_start_handler, gdb_xml_element_end_handler)
	(struct gdb_xml_enum): New.
	(gdb_xml_create_parser_and_cleanup, gdb_xml_parse, gdb_xml_debug)
	(gdb_xml_error, gdb_xml_parse_attr_ulongest)
	(gdb_xml_parse_attr_enum, gdb_xml_parse_ulongest): New prototypes.
	(xml_get_required_attribute, xml_get_integer_attribute)
	(xml_get_enum_value, make_cleanup_free_xml_parser): Delete prototypes.
	* Makefile.in (xml_support_h, xml-support.o): Update.

	* gdb.texinfo (Debugging Output): Document "set debug xml"
	and "show debug xml".
@
text
@d312 1
a312 1
      gdb_xml_error (parser, _("Required element \<%s\> is missing"),
@


1.3
log
@	* Makefile.in (gdb_expat_h): New.
	(xml_support_h): Add gdb_expat.h dependency.
	(memory-map.o, xml-support.o): Likewise.
	* gdb_expat.h: New file.
	* xml-support.h: Include it.
	* memory-map.c, xml-support.c: Likewise.  Remove XML_STATUS_OK
	definitions.
@
text
@d24 4
d38 8
d47 2
a48 2
/* Returns the value of attribute ATTR from expat attribute list
   ATTRLIST.  If not found, throws an exception.  */
d50 12
a61 3
const XML_Char *
xml_get_required_attribute (const XML_Char **attrs,
			    const XML_Char *attr)
d63 22
a84 2
  const XML_Char **p;
  for (p = attrs; *p; p += 2)
d86 43
a128 2
      const char *name = p[0];
      const char *val = p[1];
d130 55
a184 2
      if (strcmp (name, attr) == 0)
	return val;
d186 288
a473 1
  throw_error (XML_PARSE_ERROR, _("Can't find attribute %s"), attr);
d499 2
a500 3
/* Gets the value of an integer attribute named ATTR, if it's present.
   If the attribute is not found, or can't be parsed as integer,
   throws an exception.  */
d503 1
a503 2
xml_get_integer_attribute (const XML_Char **attrs,
			   const XML_Char *attr)
a505 1
  const XML_Char *value = xml_get_required_attribute (attrs, attr);
d508 2
a509 5
    {
      throw_error (XML_PARSE_ERROR,
		   _("Can't convert value of attribute %s, %s, to integer"),
		   attr, value);
    }
d513 18
a530 10
/* Obtains a value of attribute with enumerated type. In XML, enumerated
   attributes have string as a value, and in C, they are represented as
   values of enumerated type. This function maps the attribute onto
   an integer value that can be immediately converted into enumerated
   type.

   First, obtains the string value of ATTR in ATTRS.
   Then, finds the index of that value in XML_NAMES, which is a zero-terminated
   array of strings. If found, returns the element of VALUES with that index.
   Otherwise throws.  */
d532 9
a540 5
int
xml_get_enum_value (const XML_Char **attrs,
		    const XML_Char *attr,
		    const XML_Char **xml_names,
		    int *values)
d542 2
a543 1
  const XML_Char *value = xml_get_required_attribute (attrs, attr);
d545 11
a555 8
  int i;
  for (i = 0; xml_names[i]; ++i)
    {
      if (strcmp (xml_names[i], value) == 0)
	return values[i];
    }
  throw_error (XML_PARSE_ERROR,
	       _("Invalid enumerated value in XML: %s"), value);
d558 1
a558 2
/* Cleanup wrapper for XML_ParserFree, with the correct type
   for make_cleanup.  */
d561 2
a562 1
free_xml_parser (void *parser)
d564 1
a564 1
  XML_ParserFree (parser);
d567 1
a567 3
/* Register a cleanup to release PARSER.  Only the parser itself
   is freed; another cleanup may be necessary to discard any
   associated user data.  */
d570 1
a570 1
make_cleanup_free_xml_parser (XML_Parser parser)
d572 7
a578 1
  make_cleanup (free_xml_parser, parser);
a579 2

#endif /* HAVE_LIBEXPAT */
@


1.2
log
@	* memory-map.c (XML_STATUS_OK, XML_STATUS_ERROR): Provide default
	definitions.
	* xml-support.c (XML_STATUS_OK, XML_STATUS_ERROR): Likewise.
@
text
@d32 1
a32 2
#include <expat.h>

a34 5
#ifndef XML_STATUS_OK
# define XML_STATUS_OK    1
# define XML_STATUS_ERROR 0
#endif

@


1.1
log
@gdb/
2006-09-21  Vladimir Prus  <vladimir@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* Makefile.in (SFILES): Add memory-map.c and xml-support.c.
	(memory_map_h, xml_support_h): New.
	(target_h): Add vec_h dependency.
	(COMMON_OBS): Add memory-map.o and xml-support.o.
	(memory-map.o, xml-support.o): New rules.
	(remote.o): Update.
	* exceptions.h (enum errors): Add XML_PARSE_ERROR.
	* infcmd.c (run_command_1, attach_command): Call target_pre_inferior.
	* memattr.c (default_mem_attrib): Initialize blocksize.
	(target_mem_region_list, mem_use_target)
	(target_mem_regions_valid, mem_region_cmp, mem_region_init)
	(require_user_regions, require_target_regions)
	(invalidate_target_mem_regions): New.
	(create_mem_region): Use mem_region_init.
	(mem_clear): Move higher.
	(lookup_mem_region): Use require_target_regions.
	(mem_command): Implement "mem auto".
	(mem_info_command): Handle target-supplied regions and flash
	attributes.
	(mem_enable_command, mem_disable_command, mem_delete_command): Use
	require_user_regions.
	(_initialize_mem): Mention "mem auto" in help.
	* memattr.h (enum mem_access_mode): Add MEM_FLASH.
	(struct mem_attrib): Add blocksize.
	(invalidate_target_mem_regions, mem_region_init, mem_region_cmp): New
	prototypes.
	* remote.c: Include "memory-map.h".
	(PACKET_qXfer_memory_map): New enum value.
	(remote_protocol_features): Add qXfer:memory-map:read.
	(remote_xfer_partial): Handle memory maps.
	(remote_memory_map): New.
	(init_remote_ops, init_remote_async_ops): Set to_memory_map.
	(_initialize_remote): Register qXfer:memory-map:read.
	* target.c (update_current_target): Mention to_memory_map.
	(target_memory_map, target_pre_inferior): New.
	(target_preopen): Call target_pre_inferior.
	* target.h: Include "vec.h".
	(enum target_object): Add TARGET_OBJECT_MEMORY_MAP.
	(struct target_ops): Add to_memory_map.
	(target_memory_map, target_pre_inferior): New prototypes.
	* memory-map.c, memory-map.h, xml-support.c, xml-support.h: New files.
gdb/doc/
2006-09-21  Vladimir Prus  <vladimir@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb.texinfo (Memory Region Attributes): Mention target-supplied
	memory regions and "mem auto".
@
text
@d36 5
@

