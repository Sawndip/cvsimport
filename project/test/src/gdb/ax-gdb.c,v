head	1.113;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.110
	gdb_7_6-2013-04-26-release:1.110
	gdb_7_6-branch:1.110.0.2
	gdb_7_6-2013-03-12-branchpoint:1.110
	gdb_7_5_1-2012-11-29-release:1.103
	gdb_7_5-2012-08-17-release:1.103
	gdb_7_5-branch:1.103.0.2
	gdb_7_5-2012-07-18-branchpoint:1.103
	gdb_7_4_1-2012-04-26-release:1.90.2.1
	gdb_7_4-2012-01-24-release:1.90.2.1
	gdb_7_4-branch:1.90.0.2
	gdb_7_4-2011-12-13-branchpoint:1.90
	gdb_7_3_1-2011-09-04-release:1.86
	gdb_7_3-2011-07-26-release:1.86
	gdb_7_3-branch:1.86.0.2
	gdb_7_3-2011-04-01-branchpoint:1.86
	gdb_7_2-2010-09-02-release:1.76
	gdb_7_2-branch:1.76.0.2
	gdb_7_2-2010-07-07-branchpoint:1.76
	gdb_7_1-2010-03-18-release:1.64
	gdb_7_1-branch:1.64.0.2
	gdb_7_1-2010-02-18-branchpoint:1.64
	gdb_7_0_1-2009-12-22-release:1.53
	gdb_7_0-2009-10-06-release:1.53
	gdb_7_0-branch:1.53.0.4
	gdb_7_0-2009-09-16-branchpoint:1.53
	arc-sim-20090309:1.41
	msnyder-checkpoint-072509-branch:1.53.0.2
	msnyder-checkpoint-072509-branchpoint:1.53
	arc-insight_6_8-branch:1.41.0.6
	arc-insight_6_8-branchpoint:1.41
	insight_6_8-branch:1.41.0.4
	insight_6_8-branchpoint:1.41
	reverse-20081226-branch:1.47.0.6
	reverse-20081226-branchpoint:1.47
	multiprocess-20081120-branch:1.47.0.4
	multiprocess-20081120-branchpoint:1.47
	reverse-20080930-branch:1.47.0.2
	reverse-20080930-branchpoint:1.47
	reverse-20080717-branch:1.44.0.4
	reverse-20080717-branchpoint:1.44
	msnyder-reverse-20080609-branch:1.44.0.2
	msnyder-reverse-20080609-branchpoint:1.44
	drow-reverse-20070409-branch:1.31.0.2
	drow-reverse-20070409-branchpoint:1.31
	gdb_6_8-2008-03-27-release:1.41
	gdb_6_8-branch:1.41.0.2
	gdb_6_8-2008-02-26-branchpoint:1.41
	gdb_6_7_1-2007-10-29-release:1.36
	gdb_6_7-2007-10-10-release:1.36
	gdb_6_7-branch:1.36.0.2
	gdb_6_7-2007-09-07-branchpoint:1.36
	insight_6_6-20070208-release:1.30
	gdb_6_6-2006-12-18-release:1.30
	gdb_6_6-branch:1.30.0.18
	gdb_6_6-2006-11-15-branchpoint:1.30
	insight_6_5-20061003-release:1.30
	gdb-csl-symbian-6_4_50_20060226-12:1.30
	gdb-csl-sourcerygxx-3_4_4-25:1.29
	nickrob-async-20060828-mergepoint:1.30
	gdb-csl-symbian-6_4_50_20060226-11:1.30
	gdb-csl-sourcerygxx-4_1-17:1.30
	gdb-csl-20060226-branch-local-2:1.30
	gdb-csl-sourcerygxx-4_1-14:1.30
	gdb-csl-sourcerygxx-4_1-13:1.30
	gdb-csl-sourcerygxx-4_1-12:1.30
	gdb-csl-sourcerygxx-3_4_4-21:1.30
	gdb_6_5-20060621-release:1.30
	gdb-csl-sourcerygxx-4_1-9:1.30
	gdb-csl-sourcerygxx-4_1-8:1.30
	gdb-csl-sourcerygxx-4_1-7:1.30
	gdb-csl-arm-2006q1-6:1.30
	gdb-csl-sourcerygxx-4_1-6:1.30
	gdb-csl-symbian-6_4_50_20060226-10:1.30
	gdb-csl-symbian-6_4_50_20060226-9:1.30
	gdb-csl-symbian-6_4_50_20060226-8:1.30
	gdb-csl-coldfire-4_1-11:1.30
	gdb-csl-sourcerygxx-3_4_4-19:1.30
	gdb-csl-coldfire-4_1-10:1.30
	gdb_6_5-branch:1.30.0.16
	gdb_6_5-2006-05-14-branchpoint:1.30
	gdb-csl-sourcerygxx-4_1-5:1.30
	nickrob-async-20060513-branch:1.30.0.14
	nickrob-async-20060513-branchpoint:1.30
	gdb-csl-sourcerygxx-4_1-4:1.30
	msnyder-reverse-20060502-branch:1.30.0.12
	msnyder-reverse-20060502-branchpoint:1.30
	gdb-csl-morpho-4_1-4:1.30
	gdb-csl-sourcerygxx-3_4_4-17:1.30
	readline_5_1-import-branch:1.30.0.10
	readline_5_1-import-branchpoint:1.30
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.30
	gdb-csl-symbian-20060226-branch:1.30.0.8
	gdb-csl-symbian-20060226-branchpoint:1.30
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.30
	msnyder-reverse-20060331-branch:1.30.0.6
	msnyder-reverse-20060331-branchpoint:1.30
	gdb-csl-available-20060303-branch:1.30.0.4
	gdb-csl-available-20060303-branchpoint:1.30
	gdb-csl-20060226-branch:1.30.0.2
	gdb-csl-20060226-branchpoint:1.30
	gdb_6_4-20051202-release:1.29
	msnyder-fork-checkpoint-branch:1.29.0.12
	msnyder-fork-checkpoint-branchpoint:1.29
	gdb-csl-gxxpro-6_3-branch:1.29.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.29
	gdb_6_4-branch:1.29.0.8
	gdb_6_4-2005-11-01-branchpoint:1.29
	gdb-csl-arm-20051020-branch:1.29.0.6
	gdb-csl-arm-20051020-branchpoint:1.29
	msnyder-tracepoint-checkpoint-branch:1.29.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.29
	gdb-csl-arm-20050325-2005-q1b:1.29
	gdb-csl-arm-20050325-2005-q1a:1.29
	csl-arm-20050325-branch:1.29.0.2
	csl-arm-20050325-branchpoint:1.29
	gdb-post-i18n-errorwarning-20050211:1.28
	gdb-pre-i18n-errorwarning-20050211:1.28
	gdb_6_3-20041109-release:1.25
	gdb_6_3-branch:1.25.0.14
	gdb_6_3-20041019-branchpoint:1.25
	drow_intercu-merge-20040921:1.25
	drow_intercu-merge-20040915:1.25
	jimb-gdb_6_2-e500-branch:1.25.0.16
	jimb-gdb_6_2-e500-branchpoint:1.25
	gdb_6_2-20040730-release:1.25
	gdb_6_2-branch:1.25.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.25
	gdb_6_1_1-20040616-release:1.25
	gdb_6_1-2004-04-05-release:1.25
	drow_intercu-merge-20040402:1.25
	drow_intercu-merge-20040327:1.25
	ezannoni_pie-20040323-branch:1.25.0.10
	ezannoni_pie-20040323-branchpoint:1.25
	cagney_tramp-20040321-mergepoint:1.25
	cagney_tramp-20040309-branch:1.25.0.8
	cagney_tramp-20040309-branchpoint:1.25
	gdb_6_1-branch:1.25.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.25
	drow_intercu-20040221-branch:1.25.0.4
	drow_intercu-20040221-branchpoint:1.25
	cagney_bfdfile-20040213-branch:1.25.0.2
	cagney_bfdfile-20040213-branchpoint:1.25
	drow-cplus-merge-20040208:1.25
	carlton_dictionary-20040126-merge:1.23
	cagney_bigcore-20040122-branch:1.23.0.2
	cagney_bigcore-20040122-branchpoint:1.23
	drow-cplus-merge-20040113:1.22
	drow-cplus-merge-20031224:1.22
	drow-cplus-merge-20031220:1.22
	carlton_dictionary-20031215-merge:1.22
	drow-cplus-merge-20031214:1.22
	carlton-dictionary-20031111-merge:1.22
	gdb_6_0-2003-10-04-release:1.22
	kettenis_sparc-20030918-branch:1.22.0.36
	kettenis_sparc-20030918-branchpoint:1.22
	carlton_dictionary-20030917-merge:1.22
	ezannoni_pie-20030916-branchpoint:1.22
	ezannoni_pie-20030916-branch:1.22.0.34
	cagney_x86i386-20030821-branch:1.22.0.32
	cagney_x86i386-20030821-branchpoint:1.22
	carlton_dictionary-20030805-merge:1.22
	carlton_dictionary-20030627-merge:1.22
	gdb_6_0-branch:1.22.0.30
	gdb_6_0-2003-06-23-branchpoint:1.22
	jimb-ppc64-linux-20030613-branch:1.22.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.22
	cagney_convert-20030606-branch:1.22.0.26
	cagney_convert-20030606-branchpoint:1.22
	cagney_writestrings-20030508-branch:1.22.0.24
	cagney_writestrings-20030508-branchpoint:1.22
	jimb-ppc64-linux-20030528-branch:1.22.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.22
	carlton_dictionary-20030523-merge:1.22
	cagney_fileio-20030521-branch:1.22.0.20
	cagney_fileio-20030521-branchpoint:1.22
	kettenis_i386newframe-20030517-mergepoint:1.22
	jimb-ppc64-linux-20030509-branch:1.22.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.22
	kettenis_i386newframe-20030504-mergepoint:1.22
	carlton_dictionary-20030430-merge:1.22
	kettenis_i386newframe-20030419-branch:1.22.0.16
	kettenis_i386newframe-20030419-branchpoint:1.22
	carlton_dictionary-20030416-merge:1.22
	cagney_frameaddr-20030409-mergepoint:1.22
	kettenis_i386newframe-20030406-branch:1.22.0.14
	kettenis_i386newframe-20030406-branchpoint:1.22
	cagney_frameaddr-20030403-branchpoint:1.22
	cagney_frameaddr-20030403-branch:1.22.0.12
	cagney_framebase-20030330-mergepoint:1.22
	cagney_framebase-20030326-branch:1.22.0.10
	cagney_framebase-20030326-branchpoint:1.22
	cagney_lazyid-20030317-branch:1.22.0.8
	cagney_lazyid-20030317-branchpoint:1.22
	kettenis-i386newframe-20030316-mergepoint:1.22
	offbyone-20030313-branch:1.22.0.6
	offbyone-20030313-branchpoint:1.22
	kettenis-i386newframe-20030308-branch:1.22.0.4
	kettenis-i386newframe-20030308-branchpoint:1.22
	carlton_dictionary-20030305-merge:1.22
	cagney_offbyone-20030303-branch:1.22.0.2
	cagney_offbyone-20030303-branchpoint:1.22
	carlton_dictionary-20030207-merge:1.17
	interps-20030203-mergepoint:1.17
	interps-20030202-branch:1.17.0.2
	interps-20030202-branchpoint:1.17
	cagney-unwind-20030108-branch:1.16.0.2
	cagney-unwind-20030108-branchpoint:1.16
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.14
	kseitz_interps-20021105-merge:1.14
	kseitz_interps-20021103-merge:1.14
	drow-cplus-merge-20021020:1.14
	drow-cplus-merge-20021025:1.14
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.14
	drow-cplus-branch:1.14.0.6
	drow-cplus-branchpoint:1.14
	kseitz_interps-20020930-merge:1.14
	carlton_dictionary-20020927-merge:1.14
	carlton_dictionary-branch:1.14.0.4
	carlton_dictionary-20020920-branchpoint:1.14
	gdb_5_3-branch:1.14.0.2
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.13.0.8
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.13.0.6
	readline_4_3-import-branchpoint:1.13
	gdb_5_2_1-2002-07-23-release:1.12
	kseitz_interps-20020528-branch:1.13.0.4
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.13.0.2
	cagney_regbuf-20020515-branchpoint:1.13
	jimb-macro-020506-branch:1.12.0.4
	jimb-macro-020506-branchpoint:1.12
	gdb_5_2-2002-04-29-release:1.12
	gdb_5_2-branch:1.12.0.2
	gdb_5_2-2002-03-03-branchpoint:1.12
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.11
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.8
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.6
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.4
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.9
	insight-precleanup-2001-01-01:1.7
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.1.1.7
	gdb_4_18_2-2000-05-18-release:1.1.1.7
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.7
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.7
	gdb_5_0-2000-04-10-branch:1.1.1.7.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.7
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.113
date	2013.03.21.16.09.27;	author tromey;	state Exp;
branches;
next	1.112;

1.112
date	2013.03.20.18.35.22;	author tromey;	state Exp;
branches;
next	1.111;

1.111
date	2013.03.13.18.34.53;	author palves;	state Exp;
branches;
next	1.110;

1.110
date	2013.03.12.17.39.43;	author kseitz;	state Exp;
branches;
next	1.109;

1.109
date	2013.03.07.00.48.25;	author kseitz;	state Exp;
branches;
next	1.108;

1.108
date	2013.01.31.16.27.50;	author aristovski;	state Exp;
branches;
next	1.107;

1.107
date	2013.01.01.06.32.39;	author brobecke;	state Exp;
branches;
next	1.106;

1.106
date	2012.09.25.12.48.52;	author siddhesh;	state Exp;
branches;
next	1.105;

1.105
date	2012.07.19.15.38.16;	author tromey;	state Exp;
branches;
next	1.104;

1.104
date	2012.07.19.15.33.24;	author tromey;	state Exp;
branches;
next	1.103;

1.103
date	2012.07.05.01.03.01;	author teawater;	state Exp;
branches;
next	1.102;

1.102
date	2012.07.02.15.29.33;	author shebs;	state Exp;
branches;
next	1.101;

1.101
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.100;

1.100
date	2012.04.27.20.47.51;	author sergiodj;	state Exp;
branches;
next	1.99;

1.99
date	2012.04.27.20.38.38;	author sergiodj;	state Exp;
branches;
next	1.98;

1.98
date	2012.03.21.15.16.23;	author brobecke;	state Exp;
branches;
next	1.97;

1.97
date	2012.03.14.01.38.58;	author brobecke;	state Exp;
branches;
next	1.96;

1.96
date	2012.03.14.01.38.30;	author brobecke;	state Exp;
branches;
next	1.95;

1.95
date	2012.03.08.22.19.09;	author brobecke;	state Exp;
branches;
next	1.94;

1.94
date	2012.03.08.21.07.25;	author luisgpm;	state Exp;
branches;
next	1.93;

1.93
date	2012.03.08.20.54.36;	author brobecke;	state Exp;
branches;
next	1.92;

1.92
date	2012.02.07.04.48.18;	author devans;	state Exp;
branches;
next	1.91;

1.91
date	2012.01.04.08.16.59;	author brobecke;	state Exp;
branches;
next	1.90;

1.90
date	2011.11.02.23.44.19;	author shebs;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2011.09.27.13.09.34;	author shebs;	state Exp;
branches;
next	1.88;

1.88
date	2011.06.17.20.46.47;	author tromey;	state Exp;
branches;
next	1.87;

1.87
date	2011.05.18.20.19.51;	author tromey;	state Exp;
branches;
next	1.86;

1.86
date	2011.02.24.07.39.47;	author brobecke;	state Exp;
branches;
next	1.85;

1.85
date	2011.02.21.08.38.10;	author teawater;	state Exp;
branches;
next	1.84;

1.84
date	2011.02.16.18.07.57;	author palves;	state Exp;
branches;
next	1.83;

1.83
date	2011.01.07.17.35.27;	author msnyder;	state Exp;
branches;
next	1.82;

1.82
date	2011.01.05.22.22.47;	author msnyder;	state Exp;
branches;
next	1.81;

1.81
date	2011.01.01.15.32.57;	author brobecke;	state Exp;
branches;
next	1.80;

1.80
date	2010.12.31.19.16.37;	author msnyder;	state Exp;
branches;
next	1.79;

1.79
date	2010.12.29.12.47.19;	author teawater;	state Exp;
branches;
next	1.78;

1.78
date	2010.12.28.17.59.58;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2010.12.28.16.00.12;	author teawater;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.18.19.23.37;	author msnyder;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2010.05.06.00.31.46;	author msnyder;	state Exp;
branches;
next	1.74;

1.74
date	2010.04.23.23.51.05;	author shebs;	state Exp;
branches;
next	1.73;

1.73
date	2010.04.20.18.52.58;	author shebs;	state Exp;
branches;
next	1.72;

1.72
date	2010.03.19.22.00.17;	author shebs;	state Exp;
branches;
next	1.71;

1.71
date	2010.03.18.16.01.29;	author shebs;	state Exp;
branches;
next	1.70;

1.70
date	2010.03.18.01.47.33;	author shebs;	state Exp;
branches;
next	1.69;

1.69
date	2010.03.17.22.04.43;	author shebs;	state Exp;
branches;
next	1.68;

1.68
date	2010.03.16.00.52.54;	author shebs;	state Exp;
branches;
next	1.67;

1.67
date	2010.03.15.23.53.21;	author shebs;	state Exp;
branches;
next	1.66;

1.66
date	2010.03.12.23.13.19;	author shebs;	state Exp;
branches;
next	1.65;

1.65
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.64;

1.64
date	2010.02.11.23.03.22;	author palves;	state Exp;
branches;
next	1.63;

1.63
date	2010.02.11.21.45.25;	author palves;	state Exp;
branches;
next	1.62;

1.62
date	2010.02.11.18.24.57;	author palves;	state Exp;
branches;
next	1.61;

1.61
date	2010.01.15.22.37.17;	author shebs;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.59;

1.59
date	2009.12.29.23.57.59;	author shebs;	state Exp;
branches;
next	1.58;

1.58
date	2009.12.29.23.21.38;	author shebs;	state Exp;
branches;
next	1.57;

1.57
date	2009.12.28.23.39.08;	author shebs;	state Exp;
branches;
next	1.56;

1.56
date	2009.12.28.16.49.14;	author palves;	state Exp;
branches;
next	1.55;

1.55
date	2009.12.24.01.42.03;	author shebs;	state Exp;
branches;
next	1.54;

1.54
date	2009.12.24.00.40.49;	author shebs;	state Exp;
branches;
next	1.53;

1.53
date	2009.07.14.21.40.30;	author shebs;	state Exp;
branches;
next	1.52;

1.52
date	2009.07.02.12.20.17;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2009.07.02.12.18.46;	author uweigand;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.17.18.40.53;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.04.12.28.39;	author uweigand;	state Exp;
branches;
next	1.48;

1.48
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.47;

1.47
date	2008.09.11.14.15.39;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.21.20.13.08;	author uweigand;	state Exp;
branches;
next	1.45;

1.45
date	2008.08.21.18.14.38;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.22.17.00.07;	author uweigand;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.22.16.59.01;	author uweigand;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.05.15.54.34;	author jimb;	state Exp;
branches;
next	1.40;

1.40
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.26.23.42.28;	author jimb;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.26.23.07.26;	author jimb;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.26.23.04.57;	author jimb;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.23.18.08.26;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.24.22.49.44;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.13.17.11.09;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.12.16.43.39;	author uweigand;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.31.17.00.06;	author uweigand;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.08.14.35.16;	author nathan;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.07.23.51.02;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.29.17.53.25;	author ibr;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.12.21.45.05;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.06.18.30.47;	author fnf;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.26.20.36.31;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.21.15.37.11;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.01.17.03.19;	author cagney;	state Exp;
branches
	1.22.24.1;
next	1.21;

1.21
date	2003.02.28.20.03.17;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.25.21.36.16;	author carlton;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.20.17.17.23;	author carlton;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.20.00.01.04;	author carlton;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.14.00.49.03;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.09.18.30.32;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.09.03.30.44;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.27.22.37.06;	author tromey;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;

1.13
date	2002.05.13.14.00.35;	author drow;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2002.02.03.23.11.33;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.05.04.30.15;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.11.00.59.29;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.06.08.21.05;	author kevinb;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.02.08.06.03.52;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.30.21.15.56;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.24;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.15.06.15.27;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.12.41.47;	author phdm;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.14.18.43.41;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.90.2.1
date	2012.01.06.04.43.05;	author brobecke;	state Exp;
branches;
next	;

1.76.2.1
date	2010.12.30.03.17.35;	author teawater;	state Exp;
branches;
next	;

1.22.24.1
date	2003.06.03.20.54.33;	author cagney;	state Exp;
branches;
next	;

1.14.4.1
date	2002.10.18.23.42.57;	author carlton;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2002.12.21.00.17.42;	author carlton;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2002.12.23.19.38.12;	author carlton;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2003.02.07.19.17.44;	author carlton;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2003.03.06.00.56.23;	author carlton;	state Exp;
branches;
next	1.14.4.6;

1.14.4.6
date	2003.03.07.22.52.52;	author carlton;	state Exp;
branches;
next	1.14.4.7;

1.14.4.7
date	2004.01.26.19.11.15;	author carlton;	state Exp;
branches;
next	;

1.14.6.1
date	2003.12.14.20.27.07;	author drow;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2004.02.09.19.43.30;	author drow;	state Exp;
branches;
next	;

1.13.4.1
date	2002.08.30.22.52.42;	author kseitz;	state Exp;
branches;
next	;

1.9.2.1
date	2001.07.06.19.16.57;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.35;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.06.28.16.00.14;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.04.17;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.08.23.59.00;	author shebs;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.28.21.51.57;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2000.02.02.00.21.04;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.113
log
@	* tracepoint.h (decode_agent_options): Add 'trace_string'
	argument.
	* tracepoint.c (decode_agent_options): Add 'trace_string'
	argument.
	(validate_actionline): Update.
	(collect_symbol): Add 'trace_string' argument.
	(struct add_local_symbols_data) <trace_string>: New field.
	(do_collect_symbol): Update.
	(add_local_symbols): Add 'trace_string' argument.
	(encode_actions_1): Update.
	(trace_dump_actions): Update.
	* dwarf2loc.c (access_memory): Update.
	* ax.h (struct agent_expr) <tracing, trace_string>: New fields.
	* ax-general.c (new_agent_expr): Update.
	* ax-gdb.h (gen_trace_for_expr, gen_trace_for_var)
	(gen_trace_for_return_address): Add argument.
	(trace_kludge, trace_string_kludge): Remove.
	* ax-gdb.c (trace_kludge, trace_string_kludge): Remove.
	(gen_traced_pop, gen_fetch, gen_bitfield_ref, gen_expr): Update.
	(gen_trace_for_var): Add 'trace_string' argument.
	(gen_trace_for_expr, gen_trace_for_return_address): Likewise.
	(gen_printf, agent_eval_command_one): Update.
@
text
@/* GDB-specific functions for operating on agent expressions.

   Copyright (C) 1998-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include "symfile.h"
#include "gdbtypes.h"
#include "language.h"
#include "value.h"
#include "expression.h"
#include "command.h"
#include "gdbcmd.h"
#include "frame.h"
#include "target.h"
#include "ax.h"
#include "ax-gdb.h"
#include "gdb_string.h"
#include "block.h"
#include "regcache.h"
#include "user-regs.h"
#include "language.h"
#include "dictionary.h"
#include "breakpoint.h"
#include "tracepoint.h"
#include "cp-support.h"
#include "arch-utils.h"
#include "cli/cli-utils.h"
#include "linespec.h"

#include "valprint.h"
#include "c-lang.h"

#include "format.h"

/* To make sense of this file, you should read doc/agentexpr.texi.
   Then look at the types and enums in ax-gdb.h.  For the code itself,
   look at gen_expr, towards the bottom; that's the main function that
   looks at the GDB expressions and calls everything else to generate
   code.

   I'm beginning to wonder whether it wouldn't be nicer to internally
   generate trees, with types, and then spit out the bytecode in
   linear form afterwards; we could generate fewer `swap', `ext', and
   `zero_ext' bytecodes that way; it would make good constant folding
   easier, too.  But at the moment, I think we should be willing to
   pay for the simplicity of this code with less-than-optimal bytecode
   strings.

   Remember, "GBD" stands for "Great Britain, Dammit!"  So be careful.  */



/* Prototypes for local functions.  */

/* There's a standard order to the arguments of these functions:
   union exp_element ** --- pointer into expression
   struct agent_expr * --- agent expression buffer to generate code into
   struct axs_value * --- describes value left on top of stack  */

static struct value *const_var_ref (struct symbol *var);
static struct value *const_expr (union exp_element **pc);
static struct value *maybe_const_expr (union exp_element **pc);

static void gen_traced_pop (struct gdbarch *, struct agent_expr *,
			    struct axs_value *);

static void gen_sign_extend (struct agent_expr *, struct type *);
static void gen_extend (struct agent_expr *, struct type *);
static void gen_fetch (struct agent_expr *, struct type *);
static void gen_left_shift (struct agent_expr *, int);


static void gen_frame_args_address (struct gdbarch *, struct agent_expr *);
static void gen_frame_locals_address (struct gdbarch *, struct agent_expr *);
static void gen_offset (struct agent_expr *ax, int offset);
static void gen_sym_offset (struct agent_expr *, struct symbol *);
static void gen_var_ref (struct gdbarch *, struct agent_expr *ax,
			 struct axs_value *value, struct symbol *var);


static void gen_int_literal (struct agent_expr *ax,
			     struct axs_value *value,
			     LONGEST k, struct type *type);

static void gen_usual_unary (struct expression *exp, struct agent_expr *ax,
			     struct axs_value *value);
static int type_wider_than (struct type *type1, struct type *type2);
static struct type *max_type (struct type *type1, struct type *type2);
static void gen_conversion (struct agent_expr *ax,
			    struct type *from, struct type *to);
static int is_nontrivial_conversion (struct type *from, struct type *to);
static void gen_usual_arithmetic (struct expression *exp,
				  struct agent_expr *ax,
				  struct axs_value *value1,
				  struct axs_value *value2);
static void gen_integral_promotions (struct expression *exp,
				     struct agent_expr *ax,
				     struct axs_value *value);
static void gen_cast (struct agent_expr *ax,
		      struct axs_value *value, struct type *type);
static void gen_scale (struct agent_expr *ax,
		       enum agent_op op, struct type *type);
static void gen_ptradd (struct agent_expr *ax, struct axs_value *value,
			struct axs_value *value1, struct axs_value *value2);
static void gen_ptrsub (struct agent_expr *ax, struct axs_value *value,
			struct axs_value *value1, struct axs_value *value2);
static void gen_ptrdiff (struct agent_expr *ax, struct axs_value *value,
			 struct axs_value *value1, struct axs_value *value2,
			 struct type *result_type);
static void gen_binop (struct agent_expr *ax,
		       struct axs_value *value,
		       struct axs_value *value1,
		       struct axs_value *value2,
		       enum agent_op op,
		       enum agent_op op_unsigned, int may_carry, char *name);
static void gen_logical_not (struct agent_expr *ax, struct axs_value *value,
			     struct type *result_type);
static void gen_complement (struct agent_expr *ax, struct axs_value *value);
static void gen_deref (struct agent_expr *, struct axs_value *);
static void gen_address_of (struct agent_expr *, struct axs_value *);
static void gen_bitfield_ref (struct expression *exp, struct agent_expr *ax,
			      struct axs_value *value,
			      struct type *type, int start, int end);
static void gen_primitive_field (struct expression *exp,
				 struct agent_expr *ax,
				 struct axs_value *value,
				 int offset, int fieldno, struct type *type);
static int gen_struct_ref_recursive (struct expression *exp,
				     struct agent_expr *ax,
				     struct axs_value *value,
				     char *field, int offset,
				     struct type *type);
static void gen_struct_ref (struct expression *exp, struct agent_expr *ax,
			    struct axs_value *value,
			    char *field,
			    char *operator_name, char *operand_name);
static void gen_static_field (struct gdbarch *gdbarch,
			      struct agent_expr *ax, struct axs_value *value,
			      struct type *type, int fieldno);
static void gen_repeat (struct expression *exp, union exp_element **pc,
			struct agent_expr *ax, struct axs_value *value);
static void gen_sizeof (struct expression *exp, union exp_element **pc,
			struct agent_expr *ax, struct axs_value *value,
			struct type *size_type);
static void gen_expr_binop_rest (struct expression *exp,
				 enum exp_opcode op, union exp_element **pc,
				 struct agent_expr *ax,
				 struct axs_value *value,
				 struct axs_value *value1,
				 struct axs_value *value2);

static void agent_command (char *exp, int from_tty);


/* Detecting constant expressions.  */

/* If the variable reference at *PC is a constant, return its value.
   Otherwise, return zero.

   Hey, Wally!  How can a variable reference be a constant?

   Well, Beav, this function really handles the OP_VAR_VALUE operator,
   not specifically variable references.  GDB uses OP_VAR_VALUE to
   refer to any kind of symbolic reference: function names, enum
   elements, and goto labels are all handled through the OP_VAR_VALUE
   operator, even though they're constants.  It makes sense given the
   situation.

   Gee, Wally, don'cha wonder sometimes if data representations that
   subvert commonly accepted definitions of terms in favor of heavily
   context-specific interpretations are really just a tool of the
   programming hegemony to preserve their power and exclude the
   proletariat?  */

static struct value *
const_var_ref (struct symbol *var)
{
  struct type *type = SYMBOL_TYPE (var);

  switch (SYMBOL_CLASS (var))
    {
    case LOC_CONST:
      return value_from_longest (type, (LONGEST) SYMBOL_VALUE (var));

    case LOC_LABEL:
      return value_from_pointer (type, (CORE_ADDR) SYMBOL_VALUE_ADDRESS (var));

    default:
      return 0;
    }
}


/* If the expression starting at *PC has a constant value, return it.
   Otherwise, return zero.  If we return a value, then *PC will be
   advanced to the end of it.  If we return zero, *PC could be
   anywhere.  */
static struct value *
const_expr (union exp_element **pc)
{
  enum exp_opcode op = (*pc)->opcode;
  struct value *v1;

  switch (op)
    {
    case OP_LONG:
      {
	struct type *type = (*pc)[1].type;
	LONGEST k = (*pc)[2].longconst;

	(*pc) += 4;
	return value_from_longest (type, k);
      }

    case OP_VAR_VALUE:
      {
	struct value *v = const_var_ref ((*pc)[2].symbol);

	(*pc) += 4;
	return v;
      }

      /* We could add more operators in here.  */

    case UNOP_NEG:
      (*pc)++;
      v1 = const_expr (pc);
      if (v1)
	return value_neg (v1);
      else
	return 0;

    default:
      return 0;
    }
}


/* Like const_expr, but guarantee also that *PC is undisturbed if the
   expression is not constant.  */
static struct value *
maybe_const_expr (union exp_element **pc)
{
  union exp_element *tentative_pc = *pc;
  struct value *v = const_expr (&tentative_pc);

  /* If we got a value, then update the real PC.  */
  if (v)
    *pc = tentative_pc;

  return v;
}


/* Generating bytecode from GDB expressions: general assumptions */

/* Here are a few general assumptions made throughout the code; if you
   want to make a change that contradicts one of these, then you'd
   better scan things pretty thoroughly.

   - We assume that all values occupy one stack element.  For example,
   sometimes we'll swap to get at the left argument to a binary
   operator.  If we decide that void values should occupy no stack
   elements, or that synthetic arrays (whose size is determined at
   run time, created by the `@@' operator) should occupy two stack
   elements (address and length), then this will cause trouble.

   - We assume the stack elements are infinitely wide, and that we
   don't have to worry what happens if the user requests an
   operation that is wider than the actual interpreter's stack.
   That is, it's up to the interpreter to handle directly all the
   integer widths the user has access to.  (Woe betide the language
   with bignums!)

   - We don't support side effects.  Thus, we don't have to worry about
   GCC's generalized lvalues, function calls, etc.

   - We don't support floating point.  Many places where we switch on
   some type don't bother to include cases for floating point; there
   may be even more subtle ways this assumption exists.  For
   example, the arguments to % must be integers.

   - We assume all subexpressions have a static, unchanging type.  If
   we tried to support convenience variables, this would be a
   problem.

   - All values on the stack should always be fully zero- or
   sign-extended.

   (I wasn't sure whether to choose this or its opposite --- that
   only addresses are assumed extended --- but it turns out that
   neither convention completely eliminates spurious extend
   operations (if everything is always extended, then you have to
   extend after add, because it could overflow; if nothing is
   extended, then you end up producing extends whenever you change
   sizes), and this is simpler.)  */


/* Scan for all static fields in the given class, including any base
   classes, and generate tracing bytecodes for each.  */

static void
gen_trace_static_fields (struct gdbarch *gdbarch,
			 struct agent_expr *ax,
			 struct type *type)
{
  int i, nbases = TYPE_N_BASECLASSES (type);
  struct axs_value value;

  CHECK_TYPEDEF (type);

  for (i = TYPE_NFIELDS (type) - 1; i >= nbases; i--)
    {
      if (field_is_static (&TYPE_FIELD (type, i)))
	{
	  gen_static_field (gdbarch, ax, &value, type, i);
	  if (value.optimized_out)
	    continue;
	  switch (value.kind)
	    {
	    case axs_lvalue_memory:
	      {
	        /* Initialize the TYPE_LENGTH if it is a typedef.  */
	        check_typedef (value.type);
		ax_const_l (ax, TYPE_LENGTH (value.type));
		ax_simple (ax, aop_trace);
	      }
	      break;

	    case axs_lvalue_register:
	      /* We don't actually need the register's value to be pushed,
		 just note that we need it to be collected.  */
	      ax_reg_mask (ax, value.u.reg);

	    default:
	      break;
	    }
	}
    }

  /* Now scan through base classes recursively.  */
  for (i = 0; i < nbases; i++)
    {
      struct type *basetype = check_typedef (TYPE_BASECLASS (type, i));

      gen_trace_static_fields (gdbarch, ax, basetype);
    }
}

/* Trace the lvalue on the stack, if it needs it.  In either case, pop
   the value.  Useful on the left side of a comma, and at the end of
   an expression being used for tracing.  */
static void
gen_traced_pop (struct gdbarch *gdbarch,
		struct agent_expr *ax, struct axs_value *value)
{
  int string_trace = 0;
  if (ax->trace_string
      && TYPE_CODE (value->type) == TYPE_CODE_PTR
      && c_textual_element_type (check_typedef (TYPE_TARGET_TYPE (value->type)),
				 's'))
    string_trace = 1;

  if (ax->tracing)
    switch (value->kind)
      {
      case axs_rvalue:
	if (string_trace)
	  {
	    ax_const_l (ax, ax->trace_string);
	    ax_simple (ax, aop_tracenz);
	  }
	else
	  /* We don't trace rvalues, just the lvalues necessary to
	     produce them.  So just dispose of this value.  */
	  ax_simple (ax, aop_pop);
	break;

      case axs_lvalue_memory:
	{
	  if (string_trace)
	    ax_simple (ax, aop_dup);

	  /* Initialize the TYPE_LENGTH if it is a typedef.  */
	  check_typedef (value->type);

	  /* There's no point in trying to use a trace_quick bytecode
	     here, since "trace_quick SIZE pop" is three bytes, whereas
	     "const8 SIZE trace" is also three bytes, does the same
	     thing, and the simplest code which generates that will also
	     work correctly for objects with large sizes.  */
	  ax_const_l (ax, TYPE_LENGTH (value->type));
	  ax_simple (ax, aop_trace);

	  if (string_trace)
	    {
	      ax_simple (ax, aop_ref32);
	      ax_const_l (ax, ax->trace_string);
	      ax_simple (ax, aop_tracenz);
	    }
	}
	break;

      case axs_lvalue_register:
	/* We don't actually need the register's value to be on the
	   stack, and the target will get heartburn if the register is
	   larger than will fit in a stack, so just mark it for
	   collection and be done with it.  */
	ax_reg_mask (ax, value->u.reg);
       
	/* But if the register points to a string, assume the value
	   will fit on the stack and push it anyway.  */
	if (string_trace)
	  {
	    ax_reg (ax, value->u.reg);
	    ax_const_l (ax, ax->trace_string);
	    ax_simple (ax, aop_tracenz);
	  }
	break;
      }
  else
    /* If we're not tracing, just pop the value.  */
    ax_simple (ax, aop_pop);

  /* To trace C++ classes with static fields stored elsewhere.  */
  if (ax->tracing
      && (TYPE_CODE (value->type) == TYPE_CODE_STRUCT
	  || TYPE_CODE (value->type) == TYPE_CODE_UNION))
    gen_trace_static_fields (gdbarch, ax, value->type);
}



/* Generating bytecode from GDB expressions: helper functions */

/* Assume that the lower bits of the top of the stack is a value of
   type TYPE, and the upper bits are zero.  Sign-extend if necessary.  */
static void
gen_sign_extend (struct agent_expr *ax, struct type *type)
{
  /* Do we need to sign-extend this?  */
  if (!TYPE_UNSIGNED (type))
    ax_ext (ax, TYPE_LENGTH (type) * TARGET_CHAR_BIT);
}


/* Assume the lower bits of the top of the stack hold a value of type
   TYPE, and the upper bits are garbage.  Sign-extend or truncate as
   needed.  */
static void
gen_extend (struct agent_expr *ax, struct type *type)
{
  int bits = TYPE_LENGTH (type) * TARGET_CHAR_BIT;

  /* I just had to.  */
  ((TYPE_UNSIGNED (type) ? ax_zero_ext : ax_ext) (ax, bits));
}


/* Assume that the top of the stack contains a value of type "pointer
   to TYPE"; generate code to fetch its value.  Note that TYPE is the
   target type, not the pointer type.  */
static void
gen_fetch (struct agent_expr *ax, struct type *type)
{
  if (ax->tracing)
    {
      /* Record the area of memory we're about to fetch.  */
      ax_trace_quick (ax, TYPE_LENGTH (type));
    }

  if (TYPE_CODE (type) == TYPE_CODE_RANGE)
    type = TYPE_TARGET_TYPE (type);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_BOOL:
      /* It's a scalar value, so we know how to dereference it.  How
         many bytes long is it?  */
      switch (TYPE_LENGTH (type))
	{
	case 8 / TARGET_CHAR_BIT:
	  ax_simple (ax, aop_ref8);
	  break;
	case 16 / TARGET_CHAR_BIT:
	  ax_simple (ax, aop_ref16);
	  break;
	case 32 / TARGET_CHAR_BIT:
	  ax_simple (ax, aop_ref32);
	  break;
	case 64 / TARGET_CHAR_BIT:
	  ax_simple (ax, aop_ref64);
	  break;

	  /* Either our caller shouldn't have asked us to dereference
	     that pointer (other code's fault), or we're not
	     implementing something we should be (this code's fault).
	     In any case, it's a bug the user shouldn't see.  */
	default:
	  internal_error (__FILE__, __LINE__,
			  _("gen_fetch: strange size"));
	}

      gen_sign_extend (ax, type);
      break;

    default:
      /* Our caller requested us to dereference a pointer from an unsupported
	 type.  Error out and give callers a chance to handle the failure
	 gracefully.  */
      error (_("gen_fetch: Unsupported type code `%s'."),
	     TYPE_NAME (type));
    }
}


/* Generate code to left shift the top of the stack by DISTANCE bits, or
   right shift it by -DISTANCE bits if DISTANCE < 0.  This generates
   unsigned (logical) right shifts.  */
static void
gen_left_shift (struct agent_expr *ax, int distance)
{
  if (distance > 0)
    {
      ax_const_l (ax, distance);
      ax_simple (ax, aop_lsh);
    }
  else if (distance < 0)
    {
      ax_const_l (ax, -distance);
      ax_simple (ax, aop_rsh_unsigned);
    }
}



/* Generating bytecode from GDB expressions: symbol references */

/* Generate code to push the base address of the argument portion of
   the top stack frame.  */
static void
gen_frame_args_address (struct gdbarch *gdbarch, struct agent_expr *ax)
{
  int frame_reg;
  LONGEST frame_offset;

  gdbarch_virtual_frame_pointer (gdbarch,
				 ax->scope, &frame_reg, &frame_offset);
  ax_reg (ax, frame_reg);
  gen_offset (ax, frame_offset);
}


/* Generate code to push the base address of the locals portion of the
   top stack frame.  */
static void
gen_frame_locals_address (struct gdbarch *gdbarch, struct agent_expr *ax)
{
  int frame_reg;
  LONGEST frame_offset;

  gdbarch_virtual_frame_pointer (gdbarch,
				 ax->scope, &frame_reg, &frame_offset);
  ax_reg (ax, frame_reg);
  gen_offset (ax, frame_offset);
}


/* Generate code to add OFFSET to the top of the stack.  Try to
   generate short and readable code.  We use this for getting to
   variables on the stack, and structure members.  If we were
   programming in ML, it would be clearer why these are the same
   thing.  */
static void
gen_offset (struct agent_expr *ax, int offset)
{
  /* It would suffice to simply push the offset and add it, but this
     makes it easier to read positive and negative offsets in the
     bytecode.  */
  if (offset > 0)
    {
      ax_const_l (ax, offset);
      ax_simple (ax, aop_add);
    }
  else if (offset < 0)
    {
      ax_const_l (ax, -offset);
      ax_simple (ax, aop_sub);
    }
}


/* In many cases, a symbol's value is the offset from some other
   address (stack frame, base register, etc.)  Generate code to add
   VAR's value to the top of the stack.  */
static void
gen_sym_offset (struct agent_expr *ax, struct symbol *var)
{
  gen_offset (ax, SYMBOL_VALUE (var));
}


/* Generate code for a variable reference to AX.  The variable is the
   symbol VAR.  Set VALUE to describe the result.  */

static void
gen_var_ref (struct gdbarch *gdbarch, struct agent_expr *ax,
	     struct axs_value *value, struct symbol *var)
{
  /* Dereference any typedefs.  */
  value->type = check_typedef (SYMBOL_TYPE (var));
  value->optimized_out = 0;

  if (SYMBOL_COMPUTED_OPS (var) != NULL)
    {
      SYMBOL_COMPUTED_OPS (var)->tracepoint_var_ref (var, gdbarch, ax, value);
      return;
    }

  /* I'm imitating the code in read_var_value.  */
  switch (SYMBOL_CLASS (var))
    {
    case LOC_CONST:		/* A constant, like an enum value.  */
      ax_const_l (ax, (LONGEST) SYMBOL_VALUE (var));
      value->kind = axs_rvalue;
      break;

    case LOC_LABEL:		/* A goto label, being used as a value.  */
      ax_const_l (ax, (LONGEST) SYMBOL_VALUE_ADDRESS (var));
      value->kind = axs_rvalue;
      break;

    case LOC_CONST_BYTES:
      internal_error (__FILE__, __LINE__,
		      _("gen_var_ref: LOC_CONST_BYTES "
			"symbols are not supported"));

      /* Variable at a fixed location in memory.  Easy.  */
    case LOC_STATIC:
      /* Push the address of the variable.  */
      ax_const_l (ax, SYMBOL_VALUE_ADDRESS (var));
      value->kind = axs_lvalue_memory;
      break;

    case LOC_ARG:		/* var lives in argument area of frame */
      gen_frame_args_address (gdbarch, ax);
      gen_sym_offset (ax, var);
      value->kind = axs_lvalue_memory;
      break;

    case LOC_REF_ARG:		/* As above, but the frame slot really
				   holds the address of the variable.  */
      gen_frame_args_address (gdbarch, ax);
      gen_sym_offset (ax, var);
      /* Don't assume any particular pointer size.  */
      gen_fetch (ax, builtin_type (gdbarch)->builtin_data_ptr);
      value->kind = axs_lvalue_memory;
      break;

    case LOC_LOCAL:		/* var lives in locals area of frame */
      gen_frame_locals_address (gdbarch, ax);
      gen_sym_offset (ax, var);
      value->kind = axs_lvalue_memory;
      break;

    case LOC_TYPEDEF:
      error (_("Cannot compute value of typedef `%s'."),
	     SYMBOL_PRINT_NAME (var));
      break;

    case LOC_BLOCK:
      ax_const_l (ax, BLOCK_START (SYMBOL_BLOCK_VALUE (var)));
      value->kind = axs_rvalue;
      break;

    case LOC_REGISTER:
      /* Don't generate any code at all; in the process of treating
         this as an lvalue or rvalue, the caller will generate the
         right code.  */
      value->kind = axs_lvalue_register;
      value->u.reg = SYMBOL_REGISTER_OPS (var)->register_number (var, gdbarch);
      break;

      /* A lot like LOC_REF_ARG, but the pointer lives directly in a
         register, not on the stack.  Simpler than LOC_REGISTER
         because it's just like any other case where the thing
	 has a real address.  */
    case LOC_REGPARM_ADDR:
      ax_reg (ax, SYMBOL_REGISTER_OPS (var)->register_number (var, gdbarch));
      value->kind = axs_lvalue_memory;
      break;

    case LOC_UNRESOLVED:
      {
	struct minimal_symbol *msym
	  = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (var), NULL, NULL);

	if (!msym)
	  error (_("Couldn't resolve symbol `%s'."), SYMBOL_PRINT_NAME (var));

	/* Push the address of the variable.  */
	ax_const_l (ax, SYMBOL_VALUE_ADDRESS (msym));
	value->kind = axs_lvalue_memory;
      }
      break;

    case LOC_COMPUTED:
      gdb_assert_not_reached (_("LOC_COMPUTED variable missing a method"));

    case LOC_OPTIMIZED_OUT:
      /* Flag this, but don't say anything; leave it up to callers to
	 warn the user.  */
      value->optimized_out = 1;
      break;

    default:
      error (_("Cannot find value of botched symbol `%s'."),
	     SYMBOL_PRINT_NAME (var));
      break;
    }
}



/* Generating bytecode from GDB expressions: literals */

static void
gen_int_literal (struct agent_expr *ax, struct axs_value *value, LONGEST k,
		 struct type *type)
{
  ax_const_l (ax, k);
  value->kind = axs_rvalue;
  value->type = check_typedef (type);
}



/* Generating bytecode from GDB expressions: unary conversions, casts */

/* Take what's on the top of the stack (as described by VALUE), and
   try to make an rvalue out of it.  Signal an error if we can't do
   that.  */
void
require_rvalue (struct agent_expr *ax, struct axs_value *value)
{
  /* Only deal with scalars, structs and such may be too large
     to fit in a stack entry.  */
  value->type = check_typedef (value->type);
  if (TYPE_CODE (value->type) == TYPE_CODE_ARRAY
      || TYPE_CODE (value->type) == TYPE_CODE_STRUCT
      || TYPE_CODE (value->type) == TYPE_CODE_UNION
      || TYPE_CODE (value->type) == TYPE_CODE_FUNC)
    error (_("Value not scalar: cannot be an rvalue."));

  switch (value->kind)
    {
    case axs_rvalue:
      /* It's already an rvalue.  */
      break;

    case axs_lvalue_memory:
      /* The top of stack is the address of the object.  Dereference.  */
      gen_fetch (ax, value->type);
      break;

    case axs_lvalue_register:
      /* There's nothing on the stack, but value->u.reg is the
         register number containing the value.

         When we add floating-point support, this is going to have to
         change.  What about SPARC register pairs, for example?  */
      ax_reg (ax, value->u.reg);
      gen_extend (ax, value->type);
      break;
    }

  value->kind = axs_rvalue;
}


/* Assume the top of the stack is described by VALUE, and perform the
   usual unary conversions.  This is motivated by ANSI 6.2.2, but of
   course GDB expressions are not ANSI; they're the mishmash union of
   a bunch of languages.  Rah.

   NOTE!  This function promises to produce an rvalue only when the
   incoming value is of an appropriate type.  In other words, the
   consumer of the value this function produces may assume the value
   is an rvalue only after checking its type.

   The immediate issue is that if the user tries to use a structure or
   union as an operand of, say, the `+' operator, we don't want to try
   to convert that structure to an rvalue; require_rvalue will bomb on
   structs and unions.  Rather, we want to simply pass the struct
   lvalue through unchanged, and let `+' raise an error.  */

static void
gen_usual_unary (struct expression *exp, struct agent_expr *ax,
		 struct axs_value *value)
{
  /* We don't have to generate any code for the usual integral
     conversions, since values are always represented as full-width on
     the stack.  Should we tweak the type?  */

  /* Some types require special handling.  */
  switch (TYPE_CODE (value->type))
    {
      /* Functions get converted to a pointer to the function.  */
    case TYPE_CODE_FUNC:
      value->type = lookup_pointer_type (value->type);
      value->kind = axs_rvalue;	/* Should always be true, but just in case.  */
      break;

      /* Arrays get converted to a pointer to their first element, and
         are no longer an lvalue.  */
    case TYPE_CODE_ARRAY:
      {
	struct type *elements = TYPE_TARGET_TYPE (value->type);

	value->type = lookup_pointer_type (elements);
	value->kind = axs_rvalue;
	/* We don't need to generate any code; the address of the array
	   is also the address of its first element.  */
      }
      break;

      /* Don't try to convert structures and unions to rvalues.  Let the
         consumer signal an error.  */
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return;
    }

  /* If the value is an lvalue, dereference it.  */
  require_rvalue (ax, value);
}


/* Return non-zero iff the type TYPE1 is considered "wider" than the
   type TYPE2, according to the rules described in gen_usual_arithmetic.  */
static int
type_wider_than (struct type *type1, struct type *type2)
{
  return (TYPE_LENGTH (type1) > TYPE_LENGTH (type2)
	  || (TYPE_LENGTH (type1) == TYPE_LENGTH (type2)
	      && TYPE_UNSIGNED (type1)
	      && !TYPE_UNSIGNED (type2)));
}


/* Return the "wider" of the two types TYPE1 and TYPE2.  */
static struct type *
max_type (struct type *type1, struct type *type2)
{
  return type_wider_than (type1, type2) ? type1 : type2;
}


/* Generate code to convert a scalar value of type FROM to type TO.  */
static void
gen_conversion (struct agent_expr *ax, struct type *from, struct type *to)
{
  /* Perhaps there is a more graceful way to state these rules.  */

  /* If we're converting to a narrower type, then we need to clear out
     the upper bits.  */
  if (TYPE_LENGTH (to) < TYPE_LENGTH (from))
    gen_extend (ax, from);

  /* If the two values have equal width, but different signednesses,
     then we need to extend.  */
  else if (TYPE_LENGTH (to) == TYPE_LENGTH (from))
    {
      if (TYPE_UNSIGNED (from) != TYPE_UNSIGNED (to))
	gen_extend (ax, to);
    }

  /* If we're converting to a wider type, and becoming unsigned, then
     we need to zero out any possible sign bits.  */
  else if (TYPE_LENGTH (to) > TYPE_LENGTH (from))
    {
      if (TYPE_UNSIGNED (to))
	gen_extend (ax, to);
    }
}


/* Return non-zero iff the type FROM will require any bytecodes to be
   emitted to be converted to the type TO.  */
static int
is_nontrivial_conversion (struct type *from, struct type *to)
{
  struct agent_expr *ax = new_agent_expr (NULL, 0);
  int nontrivial;

  /* Actually generate the code, and see if anything came out.  At the
     moment, it would be trivial to replicate the code in
     gen_conversion here, but in the future, when we're supporting
     floating point and the like, it may not be.  Doing things this
     way allows this function to be independent of the logic in
     gen_conversion.  */
  gen_conversion (ax, from, to);
  nontrivial = ax->len > 0;
  free_agent_expr (ax);
  return nontrivial;
}


/* Generate code to perform the "usual arithmetic conversions" (ANSI C
   6.2.1.5) for the two operands of an arithmetic operator.  This
   effectively finds a "least upper bound" type for the two arguments,
   and promotes each argument to that type.  *VALUE1 and *VALUE2
   describe the values as they are passed in, and as they are left.  */
static void
gen_usual_arithmetic (struct expression *exp, struct agent_expr *ax,
		      struct axs_value *value1, struct axs_value *value2)
{
  /* Do the usual binary conversions.  */
  if (TYPE_CODE (value1->type) == TYPE_CODE_INT
      && TYPE_CODE (value2->type) == TYPE_CODE_INT)
    {
      /* The ANSI integral promotions seem to work this way: Order the
         integer types by size, and then by signedness: an n-bit
         unsigned type is considered "wider" than an n-bit signed
         type.  Promote to the "wider" of the two types, and always
         promote at least to int.  */
      struct type *target = max_type (builtin_type (exp->gdbarch)->builtin_int,
				      max_type (value1->type, value2->type));

      /* Deal with value2, on the top of the stack.  */
      gen_conversion (ax, value2->type, target);

      /* Deal with value1, not on the top of the stack.  Don't
         generate the `swap' instructions if we're not actually going
         to do anything.  */
      if (is_nontrivial_conversion (value1->type, target))
	{
	  ax_simple (ax, aop_swap);
	  gen_conversion (ax, value1->type, target);
	  ax_simple (ax, aop_swap);
	}

      value1->type = value2->type = check_typedef (target);
    }
}


/* Generate code to perform the integral promotions (ANSI 6.2.1.1) on
   the value on the top of the stack, as described by VALUE.  Assume
   the value has integral type.  */
static void
gen_integral_promotions (struct expression *exp, struct agent_expr *ax,
			 struct axs_value *value)
{
  const struct builtin_type *builtin = builtin_type (exp->gdbarch);

  if (!type_wider_than (value->type, builtin->builtin_int))
    {
      gen_conversion (ax, value->type, builtin->builtin_int);
      value->type = builtin->builtin_int;
    }
  else if (!type_wider_than (value->type, builtin->builtin_unsigned_int))
    {
      gen_conversion (ax, value->type, builtin->builtin_unsigned_int);
      value->type = builtin->builtin_unsigned_int;
    }
}


/* Generate code for a cast to TYPE.  */
static void
gen_cast (struct agent_expr *ax, struct axs_value *value, struct type *type)
{
  /* GCC does allow casts to yield lvalues, so this should be fixed
     before merging these changes into the trunk.  */
  require_rvalue (ax, value);
  /* Dereference typedefs.  */
  type = check_typedef (type);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      /* It's implementation-defined, and I'll bet this is what GCC
         does.  */
      break;

    case TYPE_CODE_ARRAY:
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_FUNC:
      error (_("Invalid type cast: intended type must be scalar."));

    case TYPE_CODE_ENUM:
    case TYPE_CODE_BOOL:
      /* We don't have to worry about the size of the value, because
         all our integral values are fully sign-extended, and when
         casting pointers we can do anything we like.  Is there any
         way for us to know what GCC actually does with a cast like
         this?  */
      break;

    case TYPE_CODE_INT:
      gen_conversion (ax, value->type, type);
      break;

    case TYPE_CODE_VOID:
      /* We could pop the value, and rely on everyone else to check
         the type and notice that this value doesn't occupy a stack
         slot.  But for now, leave the value on the stack, and
         preserve the "value == stack element" assumption.  */
      break;

    default:
      error (_("Casts to requested type are not yet implemented."));
    }

  value->type = type;
}



/* Generating bytecode from GDB expressions: arithmetic */

/* Scale the integer on the top of the stack by the size of the target
   of the pointer type TYPE.  */
static void
gen_scale (struct agent_expr *ax, enum agent_op op, struct type *type)
{
  struct type *element = TYPE_TARGET_TYPE (type);

  if (TYPE_LENGTH (element) != 1)
    {
      ax_const_l (ax, TYPE_LENGTH (element));
      ax_simple (ax, op);
    }
}


/* Generate code for pointer arithmetic PTR + INT.  */
static void
gen_ptradd (struct agent_expr *ax, struct axs_value *value,
	    struct axs_value *value1, struct axs_value *value2)
{
  gdb_assert (pointer_type (value1->type));
  gdb_assert (TYPE_CODE (value2->type) == TYPE_CODE_INT);

  gen_scale (ax, aop_mul, value1->type);
  ax_simple (ax, aop_add);
  gen_extend (ax, value1->type);	/* Catch overflow.  */
  value->type = value1->type;
  value->kind = axs_rvalue;
}


/* Generate code for pointer arithmetic PTR - INT.  */
static void
gen_ptrsub (struct agent_expr *ax, struct axs_value *value,
	    struct axs_value *value1, struct axs_value *value2)
{
  gdb_assert (pointer_type (value1->type));
  gdb_assert (TYPE_CODE (value2->type) == TYPE_CODE_INT);

  gen_scale (ax, aop_mul, value1->type);
  ax_simple (ax, aop_sub);
  gen_extend (ax, value1->type);	/* Catch overflow.  */
  value->type = value1->type;
  value->kind = axs_rvalue;
}


/* Generate code for pointer arithmetic PTR - PTR.  */
static void
gen_ptrdiff (struct agent_expr *ax, struct axs_value *value,
	     struct axs_value *value1, struct axs_value *value2,
	     struct type *result_type)
{
  gdb_assert (pointer_type (value1->type));
  gdb_assert (pointer_type (value2->type));

  if (TYPE_LENGTH (TYPE_TARGET_TYPE (value1->type))
      != TYPE_LENGTH (TYPE_TARGET_TYPE (value2->type)))
    error (_("\
First argument of `-' is a pointer, but second argument is neither\n\
an integer nor a pointer of the same type."));

  ax_simple (ax, aop_sub);
  gen_scale (ax, aop_div_unsigned, value1->type);
  value->type = result_type;
  value->kind = axs_rvalue;
}

static void
gen_equal (struct agent_expr *ax, struct axs_value *value,
	   struct axs_value *value1, struct axs_value *value2,
	   struct type *result_type)
{
  if (pointer_type (value1->type) || pointer_type (value2->type))
    ax_simple (ax, aop_equal);
  else
    gen_binop (ax, value, value1, value2,
	       aop_equal, aop_equal, 0, "equal");
  value->type = result_type;
  value->kind = axs_rvalue;
}

static void
gen_less (struct agent_expr *ax, struct axs_value *value,
	  struct axs_value *value1, struct axs_value *value2,
	  struct type *result_type)
{
  if (pointer_type (value1->type) || pointer_type (value2->type))
    ax_simple (ax, aop_less_unsigned);
  else
    gen_binop (ax, value, value1, value2,
	       aop_less_signed, aop_less_unsigned, 0, "less than");
  value->type = result_type;
  value->kind = axs_rvalue;
}

/* Generate code for a binary operator that doesn't do pointer magic.
   We set VALUE to describe the result value; we assume VALUE1 and
   VALUE2 describe the two operands, and that they've undergone the
   usual binary conversions.  MAY_CARRY should be non-zero iff the
   result needs to be extended.  NAME is the English name of the
   operator, used in error messages */
static void
gen_binop (struct agent_expr *ax, struct axs_value *value,
	   struct axs_value *value1, struct axs_value *value2,
	   enum agent_op op, enum agent_op op_unsigned,
	   int may_carry, char *name)
{
  /* We only handle INT op INT.  */
  if ((TYPE_CODE (value1->type) != TYPE_CODE_INT)
      || (TYPE_CODE (value2->type) != TYPE_CODE_INT))
    error (_("Invalid combination of types in %s."), name);

  ax_simple (ax,
	     TYPE_UNSIGNED (value1->type) ? op_unsigned : op);
  if (may_carry)
    gen_extend (ax, value1->type);	/* catch overflow */
  value->type = value1->type;
  value->kind = axs_rvalue;
}


static void
gen_logical_not (struct agent_expr *ax, struct axs_value *value,
		 struct type *result_type)
{
  if (TYPE_CODE (value->type) != TYPE_CODE_INT
      && TYPE_CODE (value->type) != TYPE_CODE_PTR)
    error (_("Invalid type of operand to `!'."));

  ax_simple (ax, aop_log_not);
  value->type = result_type;
}


static void
gen_complement (struct agent_expr *ax, struct axs_value *value)
{
  if (TYPE_CODE (value->type) != TYPE_CODE_INT)
    error (_("Invalid type of operand to `~'."));

  ax_simple (ax, aop_bit_not);
  gen_extend (ax, value->type);
}



/* Generating bytecode from GDB expressions: * & . -> @@ sizeof */

/* Dereference the value on the top of the stack.  */
static void
gen_deref (struct agent_expr *ax, struct axs_value *value)
{
  /* The caller should check the type, because several operators use
     this, and we don't know what error message to generate.  */
  if (!pointer_type (value->type))
    internal_error (__FILE__, __LINE__,
		    _("gen_deref: expected a pointer"));

  /* We've got an rvalue now, which is a pointer.  We want to yield an
     lvalue, whose address is exactly that pointer.  So we don't
     actually emit any code; we just change the type from "Pointer to
     T" to "T", and mark the value as an lvalue in memory.  Leave it
     to the consumer to actually dereference it.  */
  value->type = check_typedef (TYPE_TARGET_TYPE (value->type));
  if (TYPE_CODE (value->type) == TYPE_CODE_VOID)
    error (_("Attempt to dereference a generic pointer."));
  value->kind = ((TYPE_CODE (value->type) == TYPE_CODE_FUNC)
		 ? axs_rvalue : axs_lvalue_memory);
}


/* Produce the address of the lvalue on the top of the stack.  */
static void
gen_address_of (struct agent_expr *ax, struct axs_value *value)
{
  /* Special case for taking the address of a function.  The ANSI
     standard describes this as a special case, too, so this
     arrangement is not without motivation.  */
  if (TYPE_CODE (value->type) == TYPE_CODE_FUNC)
    /* The value's already an rvalue on the stack, so we just need to
       change the type.  */
    value->type = lookup_pointer_type (value->type);
  else
    switch (value->kind)
      {
      case axs_rvalue:
	error (_("Operand of `&' is an rvalue, which has no address."));

      case axs_lvalue_register:
	error (_("Operand of `&' is in a register, and has no address."));

      case axs_lvalue_memory:
	value->kind = axs_rvalue;
	value->type = lookup_pointer_type (value->type);
	break;
      }
}

/* Generate code to push the value of a bitfield of a structure whose
   address is on the top of the stack.  START and END give the
   starting and one-past-ending *bit* numbers of the field within the
   structure.  */
static void
gen_bitfield_ref (struct expression *exp, struct agent_expr *ax,
		  struct axs_value *value, struct type *type,
		  int start, int end)
{
  /* Note that ops[i] fetches 8 << i bits.  */
  static enum agent_op ops[]
    = {aop_ref8, aop_ref16, aop_ref32, aop_ref64};
  static int num_ops = (sizeof (ops) / sizeof (ops[0]));

  /* We don't want to touch any byte that the bitfield doesn't
     actually occupy; we shouldn't make any accesses we're not
     explicitly permitted to.  We rely here on the fact that the
     bytecode `ref' operators work on unaligned addresses.

     It takes some fancy footwork to get the stack to work the way
     we'd like.  Say we're retrieving a bitfield that requires three
     fetches.  Initially, the stack just contains the address:
     addr
     For the first fetch, we duplicate the address
     addr addr
     then add the byte offset, do the fetch, and shift and mask as
     needed, yielding a fragment of the value, properly aligned for
     the final bitwise or:
     addr frag1
     then we swap, and repeat the process:
     frag1 addr                    --- address on top
     frag1 addr addr               --- duplicate it
     frag1 addr frag2              --- get second fragment
     frag1 frag2 addr              --- swap again
     frag1 frag2 frag3             --- get third fragment
     Notice that, since the third fragment is the last one, we don't
     bother duplicating the address this time.  Now we have all the
     fragments on the stack, and we can simply `or' them together,
     yielding the final value of the bitfield.  */

  /* The first and one-after-last bits in the field, but rounded down
     and up to byte boundaries.  */
  int bound_start = (start / TARGET_CHAR_BIT) * TARGET_CHAR_BIT;
  int bound_end = (((end + TARGET_CHAR_BIT - 1)
		    / TARGET_CHAR_BIT)
		   * TARGET_CHAR_BIT);

  /* current bit offset within the structure */
  int offset;

  /* The index in ops of the opcode we're considering.  */
  int op;

  /* The number of fragments we generated in the process.  Probably
     equal to the number of `one' bits in bytesize, but who cares?  */
  int fragment_count;

  /* Dereference any typedefs.  */
  type = check_typedef (type);

  /* Can we fetch the number of bits requested at all?  */
  if ((end - start) > ((1 << num_ops) * 8))
    internal_error (__FILE__, __LINE__,
		    _("gen_bitfield_ref: bitfield too wide"));

  /* Note that we know here that we only need to try each opcode once.
     That may not be true on machines with weird byte sizes.  */
  offset = bound_start;
  fragment_count = 0;
  for (op = num_ops - 1; op >= 0; op--)
    {
      /* number of bits that ops[op] would fetch */
      int op_size = 8 << op;

      /* The stack at this point, from bottom to top, contains zero or
         more fragments, then the address.  */

      /* Does this fetch fit within the bitfield?  */
      if (offset + op_size <= bound_end)
	{
	  /* Is this the last fragment?  */
	  int last_frag = (offset + op_size == bound_end);

	  if (!last_frag)
	    ax_simple (ax, aop_dup);	/* keep a copy of the address */

	  /* Add the offset.  */
	  gen_offset (ax, offset / TARGET_CHAR_BIT);

	  if (ax->tracing)
	    {
	      /* Record the area of memory we're about to fetch.  */
	      ax_trace_quick (ax, op_size / TARGET_CHAR_BIT);
	    }

	  /* Perform the fetch.  */
	  ax_simple (ax, ops[op]);

	  /* Shift the bits we have to their proper position.
	     gen_left_shift will generate right shifts when the operand
	     is negative.

	     A big-endian field diagram to ponder:
	     byte 0  byte 1  byte 2  byte 3  byte 4  byte 5  byte 6  byte 7
	     +------++------++------++------++------++------++------++------+
	     xxxxAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBCCCCCxxxxxxxxxxx
	     ^               ^               ^    ^
	     bit number      16              32              48   53
	     These are bit numbers as supplied by GDB.  Note that the
	     bit numbers run from right to left once you've fetched the
	     value!

	     A little-endian field diagram to ponder:
	     byte 7  byte 6  byte 5  byte 4  byte 3  byte 2  byte 1  byte 0
	     +------++------++------++------++------++------++------++------+
	     xxxxxxxxxxxAAAAABBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCxxxx
	     ^               ^               ^           ^   ^
	     bit number     48              32              16          4   0

	     In both cases, the most significant end is on the left
	     (i.e. normal numeric writing order), which means that you
	     don't go crazy thinking about `left' and `right' shifts.

	     We don't have to worry about masking yet:
	     - If they contain garbage off the least significant end, then we
	     must be looking at the low end of the field, and the right
	     shift will wipe them out.
	     - If they contain garbage off the most significant end, then we
	     must be looking at the most significant end of the word, and
	     the sign/zero extension will wipe them out.
	     - If we're in the interior of the word, then there is no garbage
	     on either end, because the ref operators zero-extend.  */
	  if (gdbarch_byte_order (exp->gdbarch) == BFD_ENDIAN_BIG)
	    gen_left_shift (ax, end - (offset + op_size));
	  else
	    gen_left_shift (ax, offset - start);

	  if (!last_frag)
	    /* Bring the copy of the address up to the top.  */
	    ax_simple (ax, aop_swap);

	  offset += op_size;
	  fragment_count++;
	}
    }

  /* Generate enough bitwise `or' operations to combine all the
     fragments we left on the stack.  */
  while (fragment_count-- > 1)
    ax_simple (ax, aop_bit_or);

  /* Sign- or zero-extend the value as appropriate.  */
  ((TYPE_UNSIGNED (type) ? ax_zero_ext : ax_ext) (ax, end - start));

  /* This is *not* an lvalue.  Ugh.  */
  value->kind = axs_rvalue;
  value->type = type;
}

/* Generate bytecodes for field number FIELDNO of type TYPE.  OFFSET
   is an accumulated offset (in bytes), will be nonzero for objects
   embedded in other objects, like C++ base classes.  Behavior should
   generally follow value_primitive_field.  */

static void
gen_primitive_field (struct expression *exp,
		     struct agent_expr *ax, struct axs_value *value,
		     int offset, int fieldno, struct type *type)
{
  /* Is this a bitfield?  */
  if (TYPE_FIELD_PACKED (type, fieldno))
    gen_bitfield_ref (exp, ax, value, TYPE_FIELD_TYPE (type, fieldno),
		      (offset * TARGET_CHAR_BIT
		       + TYPE_FIELD_BITPOS (type, fieldno)),
		      (offset * TARGET_CHAR_BIT
		       + TYPE_FIELD_BITPOS (type, fieldno)
		       + TYPE_FIELD_BITSIZE (type, fieldno)));
  else
    {
      gen_offset (ax, offset
		  + TYPE_FIELD_BITPOS (type, fieldno) / TARGET_CHAR_BIT);
      value->kind = axs_lvalue_memory;
      value->type = TYPE_FIELD_TYPE (type, fieldno);
    }
}

/* Search for the given field in either the given type or one of its
   base classes.  Return 1 if found, 0 if not.  */

static int
gen_struct_ref_recursive (struct expression *exp, struct agent_expr *ax,
			  struct axs_value *value,
			  char *field, int offset, struct type *type)
{
  int i, rslt;
  int nbases = TYPE_N_BASECLASSES (type);

  CHECK_TYPEDEF (type);

  for (i = TYPE_NFIELDS (type) - 1; i >= nbases; i--)
    {
      const char *this_name = TYPE_FIELD_NAME (type, i);

      if (this_name)
	{
	  if (strcmp (field, this_name) == 0)
	    {
	      /* Note that bytecodes for the struct's base (aka
		 "this") will have been generated already, which will
		 be unnecessary but not harmful if the static field is
		 being handled as a global.  */
	      if (field_is_static (&TYPE_FIELD (type, i)))
		{
		  gen_static_field (exp->gdbarch, ax, value, type, i);
		  if (value->optimized_out)
		    error (_("static field `%s' has been "
			     "optimized out, cannot use"),
			   field);
		  return 1;
		}

	      gen_primitive_field (exp, ax, value, offset, i, type);
	      return 1;
	    }
#if 0 /* is this right? */
	  if (this_name[0] == '\0')
	    internal_error (__FILE__, __LINE__,
			    _("find_field: anonymous unions not supported"));
#endif
	}
    }

  /* Now scan through base classes recursively.  */
  for (i = 0; i < nbases; i++)
    {
      struct type *basetype = check_typedef (TYPE_BASECLASS (type, i));

      rslt = gen_struct_ref_recursive (exp, ax, value, field,
				       offset + TYPE_BASECLASS_BITPOS (type, i)
				       / TARGET_CHAR_BIT,
				       basetype);
      if (rslt)
	return 1;
    }

  /* Not found anywhere, flag so caller can complain.  */
  return 0;
}

/* Generate code to reference the member named FIELD of a structure or
   union.  The top of the stack, as described by VALUE, should have
   type (pointer to a)* struct/union.  OPERATOR_NAME is the name of
   the operator being compiled, and OPERAND_NAME is the kind of thing
   it operates on; we use them in error messages.  */
static void
gen_struct_ref (struct expression *exp, struct agent_expr *ax,
		struct axs_value *value, char *field,
		char *operator_name, char *operand_name)
{
  struct type *type;
  int found;

  /* Follow pointers until we reach a non-pointer.  These aren't the C
     semantics, but they're what the normal GDB evaluator does, so we
     should at least be consistent.  */
  while (pointer_type (value->type))
    {
      require_rvalue (ax, value);
      gen_deref (ax, value);
    }
  type = check_typedef (value->type);

  /* This must yield a structure or a union.  */
  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
      && TYPE_CODE (type) != TYPE_CODE_UNION)
    error (_("The left operand of `%s' is not a %s."),
	   operator_name, operand_name);

  /* And it must be in memory; we don't deal with structure rvalues,
     or structures living in registers.  */
  if (value->kind != axs_lvalue_memory)
    error (_("Structure does not live in memory."));

  /* Search through fields and base classes recursively.  */
  found = gen_struct_ref_recursive (exp, ax, value, field, 0, type);
  
  if (!found)
    error (_("Couldn't find member named `%s' in struct/union/class `%s'"),
	   field, TYPE_TAG_NAME (type));
}

static int
gen_namespace_elt (struct expression *exp,
		   struct agent_expr *ax, struct axs_value *value,
		   const struct type *curtype, char *name);
static int
gen_maybe_namespace_elt (struct expression *exp,
			 struct agent_expr *ax, struct axs_value *value,
			 const struct type *curtype, char *name);

static void
gen_static_field (struct gdbarch *gdbarch,
		  struct agent_expr *ax, struct axs_value *value,
		  struct type *type, int fieldno)
{
  if (TYPE_FIELD_LOC_KIND (type, fieldno) == FIELD_LOC_KIND_PHYSADDR)
    {
      ax_const_l (ax, TYPE_FIELD_STATIC_PHYSADDR (type, fieldno));
      value->kind = axs_lvalue_memory;
      value->type = TYPE_FIELD_TYPE (type, fieldno);
      value->optimized_out = 0;
    }
  else
    {
      const char *phys_name = TYPE_FIELD_STATIC_PHYSNAME (type, fieldno);
      struct symbol *sym = lookup_symbol (phys_name, 0, VAR_DOMAIN, 0);

      if (sym)
	{
	  gen_var_ref (gdbarch, ax, value, sym);
  
	  /* Don't error if the value was optimized out, we may be
	     scanning all static fields and just want to pass over this
	     and continue with the rest.  */
	}
      else
	{
	  /* Silently assume this was optimized out; class printing
	     will let the user know why the data is missing.  */
	  value->optimized_out = 1;
	}
    }
}

static int
gen_struct_elt_for_reference (struct expression *exp,
			      struct agent_expr *ax, struct axs_value *value,
			      struct type *type, char *fieldname)
{
  struct type *t = type;
  int i;

  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
      && TYPE_CODE (t) != TYPE_CODE_UNION)
    internal_error (__FILE__, __LINE__,
		    _("non-aggregate type to gen_struct_elt_for_reference"));

  for (i = TYPE_NFIELDS (t) - 1; i >= TYPE_N_BASECLASSES (t); i--)
    {
      const char *t_field_name = TYPE_FIELD_NAME (t, i);

      if (t_field_name && strcmp (t_field_name, fieldname) == 0)
	{
	  if (field_is_static (&TYPE_FIELD (t, i)))
	    {
	      gen_static_field (exp->gdbarch, ax, value, t, i);
	      if (value->optimized_out)
		error (_("static field `%s' has been "
			 "optimized out, cannot use"),
		       fieldname);
	      return 1;
	    }
	  if (TYPE_FIELD_PACKED (t, i))
	    error (_("pointers to bitfield members not allowed"));

	  /* FIXME we need a way to do "want_address" equivalent */	  

	  error (_("Cannot reference non-static field \"%s\""), fieldname);
	}
    }

  /* FIXME add other scoped-reference cases here */

  /* Do a last-ditch lookup.  */
  return gen_maybe_namespace_elt (exp, ax, value, type, fieldname);
}

/* C++: Return the member NAME of the namespace given by the type
   CURTYPE.  */

static int
gen_namespace_elt (struct expression *exp,
		   struct agent_expr *ax, struct axs_value *value,
		   const struct type *curtype, char *name)
{
  int found = gen_maybe_namespace_elt (exp, ax, value, curtype, name);

  if (!found)
    error (_("No symbol \"%s\" in namespace \"%s\"."), 
	   name, TYPE_TAG_NAME (curtype));

  return found;
}

/* A helper function used by value_namespace_elt and
   value_struct_elt_for_reference.  It looks up NAME inside the
   context CURTYPE; this works if CURTYPE is a namespace or if CURTYPE
   is a class and NAME refers to a type in CURTYPE itself (as opposed
   to, say, some base class of CURTYPE).  */

static int
gen_maybe_namespace_elt (struct expression *exp,
			 struct agent_expr *ax, struct axs_value *value,
			 const struct type *curtype, char *name)
{
  const char *namespace_name = TYPE_TAG_NAME (curtype);
  struct symbol *sym;

  sym = cp_lookup_symbol_namespace (namespace_name, name,
				    block_for_pc (ax->scope),
				    VAR_DOMAIN);

  if (sym == NULL)
    return 0;

  gen_var_ref (exp->gdbarch, ax, value, sym);

  if (value->optimized_out)
    error (_("`%s' has been optimized out, cannot use"),
	   SYMBOL_PRINT_NAME (sym));

  return 1;
}


static int
gen_aggregate_elt_ref (struct expression *exp,
		       struct agent_expr *ax, struct axs_value *value,
		       struct type *type, char *field,
		       char *operator_name, char *operand_name)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return gen_struct_elt_for_reference (exp, ax, value, type, field);
      break;
    case TYPE_CODE_NAMESPACE:
      return gen_namespace_elt (exp, ax, value, type, field);
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("non-aggregate type in gen_aggregate_elt_ref"));
    }

  return 0;
}

/* Generate code for GDB's magical `repeat' operator.
   LVALUE @@ INT creates an array INT elements long, and whose elements
   have the same type as LVALUE, located in memory so that LVALUE is
   its first element.  For example, argv[0]@@argc gives you the array
   of command-line arguments.

   Unfortunately, because we have to know the types before we actually
   have a value for the expression, we can't implement this perfectly
   without changing the type system, having values that occupy two
   stack slots, doing weird things with sizeof, etc.  So we require
   the right operand to be a constant expression.  */
static void
gen_repeat (struct expression *exp, union exp_element **pc,
	    struct agent_expr *ax, struct axs_value *value)
{
  struct axs_value value1;

  /* We don't want to turn this into an rvalue, so no conversions
     here.  */
  gen_expr (exp, pc, ax, &value1);
  if (value1.kind != axs_lvalue_memory)
    error (_("Left operand of `@@' must be an object in memory."));

  /* Evaluate the length; it had better be a constant.  */
  {
    struct value *v = const_expr (pc);
    int length;

    if (!v)
      error (_("Right operand of `@@' must be a "
	       "constant, in agent expressions."));
    if (TYPE_CODE (value_type (v)) != TYPE_CODE_INT)
      error (_("Right operand of `@@' must be an integer."));
    length = value_as_long (v);
    if (length <= 0)
      error (_("Right operand of `@@' must be positive."));

    /* The top of the stack is already the address of the object, so
       all we need to do is frob the type of the lvalue.  */
    {
      /* FIXME-type-allocation: need a way to free this type when we are
         done with it.  */
      struct type *array
	= lookup_array_range_type (value1.type, 0, length - 1);

      value->kind = axs_lvalue_memory;
      value->type = array;
    }
  }
}


/* Emit code for the `sizeof' operator.
   *PC should point at the start of the operand expression; we advance it
   to the first instruction after the operand.  */
static void
gen_sizeof (struct expression *exp, union exp_element **pc,
	    struct agent_expr *ax, struct axs_value *value,
	    struct type *size_type)
{
  /* We don't care about the value of the operand expression; we only
     care about its type.  However, in the current arrangement, the
     only way to find an expression's type is to generate code for it.
     So we generate code for the operand, and then throw it away,
     replacing it with code that simply pushes its size.  */
  int start = ax->len;

  gen_expr (exp, pc, ax, value);

  /* Throw away the code we just generated.  */
  ax->len = start;

  ax_const_l (ax, TYPE_LENGTH (value->type));
  value->kind = axs_rvalue;
  value->type = size_type;
}


/* Generating bytecode from GDB expressions: general recursive thingy  */

/* XXX: i18n */
/* A gen_expr function written by a Gen-X'er guy.
   Append code for the subexpression of EXPR starting at *POS_P to AX.  */
void
gen_expr (struct expression *exp, union exp_element **pc,
	  struct agent_expr *ax, struct axs_value *value)
{
  /* Used to hold the descriptions of operand expressions.  */
  struct axs_value value1, value2, value3;
  enum exp_opcode op = (*pc)[0].opcode, op2;
  int if1, go1, if2, go2, end;
  struct type *int_type = builtin_type (exp->gdbarch)->builtin_int;

  /* If we're looking at a constant expression, just push its value.  */
  {
    struct value *v = maybe_const_expr (pc);

    if (v)
      {
	ax_const_l (ax, value_as_long (v));
	value->kind = axs_rvalue;
	value->type = check_typedef (value_type (v));
	return;
      }
  }

  /* Otherwise, go ahead and generate code for it.  */
  switch (op)
    {
      /* Binary arithmetic operators.  */
    case BINOP_ADD:
    case BINOP_SUB:
    case BINOP_MUL:
    case BINOP_DIV:
    case BINOP_REM:
    case BINOP_LSH:
    case BINOP_RSH:
    case BINOP_SUBSCRIPT:
    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:
    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:
      (*pc)++;
      gen_expr (exp, pc, ax, &value1);
      gen_usual_unary (exp, ax, &value1);
      gen_expr_binop_rest (exp, op, pc, ax, value, &value1, &value2);
      break;

    case BINOP_LOGICAL_AND:
      (*pc)++;
      /* Generate the obvious sequence of tests and jumps.  */
      gen_expr (exp, pc, ax, &value1);
      gen_usual_unary (exp, ax, &value1);
      if1 = ax_goto (ax, aop_if_goto);
      go1 = ax_goto (ax, aop_goto);
      ax_label (ax, if1, ax->len);
      gen_expr (exp, pc, ax, &value2);
      gen_usual_unary (exp, ax, &value2);
      if2 = ax_goto (ax, aop_if_goto);
      go2 = ax_goto (ax, aop_goto);
      ax_label (ax, if2, ax->len);
      ax_const_l (ax, 1);
      end = ax_goto (ax, aop_goto);
      ax_label (ax, go1, ax->len);
      ax_label (ax, go2, ax->len);
      ax_const_l (ax, 0);
      ax_label (ax, end, ax->len);
      value->kind = axs_rvalue;
      value->type = int_type;
      break;

    case BINOP_LOGICAL_OR:
      (*pc)++;
      /* Generate the obvious sequence of tests and jumps.  */
      gen_expr (exp, pc, ax, &value1);
      gen_usual_unary (exp, ax, &value1);
      if1 = ax_goto (ax, aop_if_goto);
      gen_expr (exp, pc, ax, &value2);
      gen_usual_unary (exp, ax, &value2);
      if2 = ax_goto (ax, aop_if_goto);
      ax_const_l (ax, 0);
      end = ax_goto (ax, aop_goto);
      ax_label (ax, if1, ax->len);
      ax_label (ax, if2, ax->len);
      ax_const_l (ax, 1);
      ax_label (ax, end, ax->len);
      value->kind = axs_rvalue;
      value->type = int_type;
      break;

    case TERNOP_COND:
      (*pc)++;
      gen_expr (exp, pc, ax, &value1);
      gen_usual_unary (exp, ax, &value1);
      /* For (A ? B : C), it's easiest to generate subexpression
	 bytecodes in order, but if_goto jumps on true, so we invert
	 the sense of A.  Then we can do B by dropping through, and
	 jump to do C.  */
      gen_logical_not (ax, &value1, int_type);
      if1 = ax_goto (ax, aop_if_goto);
      gen_expr (exp, pc, ax, &value2);
      gen_usual_unary (exp, ax, &value2);
      end = ax_goto (ax, aop_goto);
      ax_label (ax, if1, ax->len);
      gen_expr (exp, pc, ax, &value3);
      gen_usual_unary (exp, ax, &value3);
      ax_label (ax, end, ax->len);
      /* This is arbitary - what if B and C are incompatible types? */
      value->type = value2.type;
      value->kind = value2.kind;
      break;

    case BINOP_ASSIGN:
      (*pc)++;
      if ((*pc)[0].opcode == OP_INTERNALVAR)
	{
	  char *name = internalvar_name ((*pc)[1].internalvar);
	  struct trace_state_variable *tsv;

	  (*pc) += 3;
	  gen_expr (exp, pc, ax, value);
	  tsv = find_trace_state_variable (name);
	  if (tsv)
	    {
	      ax_tsv (ax, aop_setv, tsv->number);
	      if (ax->tracing)
		ax_tsv (ax, aop_tracev, tsv->number);
	    }
	  else
	    error (_("$%s is not a trace state variable, "
		     "may not assign to it"), name);
	}
      else
	error (_("May only assign to trace state variables"));
      break;

    case BINOP_ASSIGN_MODIFY:
      (*pc)++;
      op2 = (*pc)[0].opcode;
      (*pc)++;
      (*pc)++;
      if ((*pc)[0].opcode == OP_INTERNALVAR)
	{
	  char *name = internalvar_name ((*pc)[1].internalvar);
	  struct trace_state_variable *tsv;

	  (*pc) += 3;
	  tsv = find_trace_state_variable (name);
	  if (tsv)
	    {
	      /* The tsv will be the left half of the binary operation.  */
	      ax_tsv (ax, aop_getv, tsv->number);
	      if (ax->tracing)
		ax_tsv (ax, aop_tracev, tsv->number);
	      /* Trace state variables are always 64-bit integers.  */
	      value1.kind = axs_rvalue;
	      value1.type = builtin_type (exp->gdbarch)->builtin_long_long;
	      /* Now do right half of expression.  */
	      gen_expr_binop_rest (exp, op2, pc, ax, value, &value1, &value2);
	      /* We have a result of the binary op, set the tsv.  */
	      ax_tsv (ax, aop_setv, tsv->number);
	      if (ax->tracing)
		ax_tsv (ax, aop_tracev, tsv->number);
	    }
	  else
	    error (_("$%s is not a trace state variable, "
		     "may not assign to it"), name);
	}
      else
	error (_("May only assign to trace state variables"));
      break;

      /* Note that we need to be a little subtle about generating code
         for comma.  In C, we can do some optimizations here because
         we know the left operand is only being evaluated for effect.
         However, if the tracing kludge is in effect, then we always
         need to evaluate the left hand side fully, so that all the
         variables it mentions get traced.  */
    case BINOP_COMMA:
      (*pc)++;
      gen_expr (exp, pc, ax, &value1);
      /* Don't just dispose of the left operand.  We might be tracing,
         in which case we want to emit code to trace it if it's an
         lvalue.  */
      gen_traced_pop (exp->gdbarch, ax, &value1);
      gen_expr (exp, pc, ax, value);
      /* It's the consumer's responsibility to trace the right operand.  */
      break;

    case OP_LONG:		/* some integer constant */
      {
	struct type *type = (*pc)[1].type;
	LONGEST k = (*pc)[2].longconst;

	(*pc) += 4;
	gen_int_literal (ax, value, k, type);
      }
      break;

    case OP_VAR_VALUE:
      gen_var_ref (exp->gdbarch, ax, value, (*pc)[2].symbol);

      if (value->optimized_out)
	error (_("`%s' has been optimized out, cannot use"),
	       SYMBOL_PRINT_NAME ((*pc)[2].symbol));

      (*pc) += 4;
      break;

    case OP_REGISTER:
      {
	const char *name = &(*pc)[2].string;
	int reg;

	(*pc) += 4 + BYTES_TO_EXP_ELEM ((*pc)[1].longconst + 1);
	reg = user_reg_map_name_to_regnum (exp->gdbarch, name, strlen (name));
	if (reg == -1)
	  internal_error (__FILE__, __LINE__,
			  _("Register $%s not available"), name);
	/* No support for tracing user registers yet.  */
	if (reg >= gdbarch_num_regs (exp->gdbarch)
	    + gdbarch_num_pseudo_regs (exp->gdbarch))
	  error (_("'%s' is a user-register; "
		   "GDB cannot yet trace user-register contents."),
		 name);
	value->kind = axs_lvalue_register;
	value->u.reg = reg;
	value->type = register_type (exp->gdbarch, reg);
      }
      break;

    case OP_INTERNALVAR:
      {
	struct internalvar *var = (*pc)[1].internalvar;
	const char *name = internalvar_name (var);
	struct trace_state_variable *tsv;

	(*pc) += 3;
	tsv = find_trace_state_variable (name);
	if (tsv)
	  {
	    ax_tsv (ax, aop_getv, tsv->number);
	    if (ax->tracing)
	      ax_tsv (ax, aop_tracev, tsv->number);
	    /* Trace state variables are always 64-bit integers.  */
	    value->kind = axs_rvalue;
	    value->type = builtin_type (exp->gdbarch)->builtin_long_long;
	  }
	else if (! compile_internalvar_to_ax (var, ax, value))
	  error (_("$%s is not a trace state variable; GDB agent "
		   "expressions cannot use convenience variables."), name);
      }
      break;

      /* Weirdo operator: see comments for gen_repeat for details.  */
    case BINOP_REPEAT:
      /* Note that gen_repeat handles its own argument evaluation.  */
      (*pc)++;
      gen_repeat (exp, pc, ax, value);
      break;

    case UNOP_CAST:
      {
	struct type *type = (*pc)[1].type;

	(*pc) += 3;
	gen_expr (exp, pc, ax, value);
	gen_cast (ax, value, type);
      }
      break;

    case UNOP_CAST_TYPE:
      {
	int offset;
	struct value *val;
	struct type *type;

	++*pc;
	offset = *pc - exp->elts;
	val = evaluate_subexp (NULL, exp, &offset, EVAL_AVOID_SIDE_EFFECTS);
	type = value_type (val);
	*pc = &exp->elts[offset];

	gen_expr (exp, pc, ax, value);
	gen_cast (ax, value, type);
      }
      break;

    case UNOP_MEMVAL:
      {
	struct type *type = check_typedef ((*pc)[1].type);

	(*pc) += 3;
	gen_expr (exp, pc, ax, value);

	/* If we have an axs_rvalue or an axs_lvalue_memory, then we
	   already have the right value on the stack.  For
	   axs_lvalue_register, we must convert.  */
	if (value->kind == axs_lvalue_register)
	  require_rvalue (ax, value);

	value->type = type;
	value->kind = axs_lvalue_memory;
      }
      break;

    case UNOP_MEMVAL_TYPE:
      {
	int offset;
	struct value *val;
	struct type *type;

	++*pc;
	offset = *pc - exp->elts;
	val = evaluate_subexp (NULL, exp, &offset, EVAL_AVOID_SIDE_EFFECTS);
	type = value_type (val);
	*pc = &exp->elts[offset];

	gen_expr (exp, pc, ax, value);

	/* If we have an axs_rvalue or an axs_lvalue_memory, then we
	   already have the right value on the stack.  For
	   axs_lvalue_register, we must convert.  */
	if (value->kind == axs_lvalue_register)
	  require_rvalue (ax, value);

	value->type = type;
	value->kind = axs_lvalue_memory;
      }
      break;

    case UNOP_PLUS:
      (*pc)++;
      /* + FOO is equivalent to 0 + FOO, which can be optimized.  */
      gen_expr (exp, pc, ax, value);
      gen_usual_unary (exp, ax, value);
      break;
      
    case UNOP_NEG:
      (*pc)++;
      /* -FOO is equivalent to 0 - FOO.  */
      gen_int_literal (ax, &value1, 0,
		       builtin_type (exp->gdbarch)->builtin_int);
      gen_usual_unary (exp, ax, &value1);	/* shouldn't do much */
      gen_expr (exp, pc, ax, &value2);
      gen_usual_unary (exp, ax, &value2);
      gen_usual_arithmetic (exp, ax, &value1, &value2);
      gen_binop (ax, value, &value1, &value2, aop_sub, aop_sub, 1, "negation");
      break;

    case UNOP_LOGICAL_NOT:
      (*pc)++;
      gen_expr (exp, pc, ax, value);
      gen_usual_unary (exp, ax, value);
      gen_logical_not (ax, value, int_type);
      break;

    case UNOP_COMPLEMENT:
      (*pc)++;
      gen_expr (exp, pc, ax, value);
      gen_usual_unary (exp, ax, value);
      gen_integral_promotions (exp, ax, value);
      gen_complement (ax, value);
      break;

    case UNOP_IND:
      (*pc)++;
      gen_expr (exp, pc, ax, value);
      gen_usual_unary (exp, ax, value);
      if (!pointer_type (value->type))
	error (_("Argument of unary `*' is not a pointer."));
      gen_deref (ax, value);
      break;

    case UNOP_ADDR:
      (*pc)++;
      gen_expr (exp, pc, ax, value);
      gen_address_of (ax, value);
      break;

    case UNOP_SIZEOF:
      (*pc)++;
      /* Notice that gen_sizeof handles its own operand, unlike most
         of the other unary operator functions.  This is because we
         have to throw away the code we generate.  */
      gen_sizeof (exp, pc, ax, value,
		  builtin_type (exp->gdbarch)->builtin_int);
      break;

    case STRUCTOP_STRUCT:
    case STRUCTOP_PTR:
      {
	int length = (*pc)[1].longconst;
	char *name = &(*pc)[2].string;

	(*pc) += 4 + BYTES_TO_EXP_ELEM (length + 1);
	gen_expr (exp, pc, ax, value);
	if (op == STRUCTOP_STRUCT)
	  gen_struct_ref (exp, ax, value, name, ".", "structure or union");
	else if (op == STRUCTOP_PTR)
	  gen_struct_ref (exp, ax, value, name, "->",
			  "pointer to a structure or union");
	else
	  /* If this `if' chain doesn't handle it, then the case list
	     shouldn't mention it, and we shouldn't be here.  */
	  internal_error (__FILE__, __LINE__,
			  _("gen_expr: unhandled struct case"));
      }
      break;

    case OP_THIS:
      {
	struct symbol *sym, *func;
	struct block *b;
	const struct language_defn *lang;

	b = block_for_pc (ax->scope);
	func = block_linkage_function (b);
	lang = language_def (SYMBOL_LANGUAGE (func));

	sym = lookup_language_this (lang, b);
	if (!sym)
	  error (_("no `%s' found"), lang->la_name_of_this);

	gen_var_ref (exp->gdbarch, ax, value, sym);

	if (value->optimized_out)
	  error (_("`%s' has been optimized out, cannot use"),
		 SYMBOL_PRINT_NAME (sym));

	(*pc) += 2;
      }
      break;

    case OP_SCOPE:
      {
	struct type *type = (*pc)[1].type;
	int length = longest_to_int ((*pc)[2].longconst);
	char *name = &(*pc)[3].string;
	int found;

	found = gen_aggregate_elt_ref (exp, ax, value, type, name,
				       "?", "??");
	if (!found)
	  error (_("There is no field named %s"), name);
	(*pc) += 5 + BYTES_TO_EXP_ELEM (length + 1);
      }
      break;

    case OP_TYPE:
    case OP_TYPEOF:
    case OP_DECLTYPE:
      error (_("Attempt to use a type name as an expression."));

    default:
      error (_("Unsupported operator %s (%d) in expression."),
	     op_name (exp, op), op);
    }
}

/* This handles the middle-to-right-side of code generation for binary
   expressions, which is shared between regular binary operations and
   assign-modify (+= and friends) expressions.  */

static void
gen_expr_binop_rest (struct expression *exp,
		     enum exp_opcode op, union exp_element **pc,
		     struct agent_expr *ax, struct axs_value *value,
		     struct axs_value *value1, struct axs_value *value2)
{
  struct type *int_type = builtin_type (exp->gdbarch)->builtin_int;

  gen_expr (exp, pc, ax, value2);
  gen_usual_unary (exp, ax, value2);
  gen_usual_arithmetic (exp, ax, value1, value2);
  switch (op)
    {
    case BINOP_ADD:
      if (TYPE_CODE (value1->type) == TYPE_CODE_INT
	  && pointer_type (value2->type))
	{
	  /* Swap the values and proceed normally.  */
	  ax_simple (ax, aop_swap);
	  gen_ptradd (ax, value, value2, value1);
	}
      else if (pointer_type (value1->type)
	       && TYPE_CODE (value2->type) == TYPE_CODE_INT)
	gen_ptradd (ax, value, value1, value2);
      else
	gen_binop (ax, value, value1, value2,
		   aop_add, aop_add, 1, "addition");
      break;
    case BINOP_SUB:
      if (pointer_type (value1->type)
	  && TYPE_CODE (value2->type) == TYPE_CODE_INT)
	gen_ptrsub (ax,value, value1, value2);
      else if (pointer_type (value1->type)
	       && pointer_type (value2->type))
	/* FIXME --- result type should be ptrdiff_t */
	gen_ptrdiff (ax, value, value1, value2,
		     builtin_type (exp->gdbarch)->builtin_long);
      else
	gen_binop (ax, value, value1, value2,
		   aop_sub, aop_sub, 1, "subtraction");
      break;
    case BINOP_MUL:
      gen_binop (ax, value, value1, value2,
		 aop_mul, aop_mul, 1, "multiplication");
      break;
    case BINOP_DIV:
      gen_binop (ax, value, value1, value2,
		 aop_div_signed, aop_div_unsigned, 1, "division");
      break;
    case BINOP_REM:
      gen_binop (ax, value, value1, value2,
		 aop_rem_signed, aop_rem_unsigned, 1, "remainder");
      break;
    case BINOP_LSH:
      gen_binop (ax, value, value1, value2,
		 aop_lsh, aop_lsh, 1, "left shift");
      break;
    case BINOP_RSH:
      gen_binop (ax, value, value1, value2,
		 aop_rsh_signed, aop_rsh_unsigned, 1, "right shift");
      break;
    case BINOP_SUBSCRIPT:
      {
	struct type *type;

	if (binop_types_user_defined_p (op, value1->type, value2->type))
	  {
	    error (_("cannot subscript requested type: "
		     "cannot call user defined functions"));
	  }
	else
	  {
	    /* If the user attempts to subscript something that is not
	       an array or pointer type (like a plain int variable for
	       example), then report this as an error.  */
	    type = check_typedef (value1->type);
	    if (TYPE_CODE (type) != TYPE_CODE_ARRAY
		&& TYPE_CODE (type) != TYPE_CODE_PTR)
	      {
		if (TYPE_NAME (type))
		  error (_("cannot subscript something of type `%s'"),
			 TYPE_NAME (type));
		else
		  error (_("cannot subscript requested type"));
	      }
	  }

	if (!is_integral_type (value2->type))
	  error (_("Argument to arithmetic operation "
		   "not a number or boolean."));

	gen_ptradd (ax, value, value1, value2);
	gen_deref (ax, value);
	break;
      }
    case BINOP_BITWISE_AND:
      gen_binop (ax, value, value1, value2,
		 aop_bit_and, aop_bit_and, 0, "bitwise and");
      break;

    case BINOP_BITWISE_IOR:
      gen_binop (ax, value, value1, value2,
		 aop_bit_or, aop_bit_or, 0, "bitwise or");
      break;
      
    case BINOP_BITWISE_XOR:
      gen_binop (ax, value, value1, value2,
		 aop_bit_xor, aop_bit_xor, 0, "bitwise exclusive-or");
      break;

    case BINOP_EQUAL:
      gen_equal (ax, value, value1, value2, int_type);
      break;

    case BINOP_NOTEQUAL:
      gen_equal (ax, value, value1, value2, int_type);
      gen_logical_not (ax, value, int_type);
      break;

    case BINOP_LESS:
      gen_less (ax, value, value1, value2, int_type);
      break;

    case BINOP_GTR:
      ax_simple (ax, aop_swap);
      gen_less (ax, value, value1, value2, int_type);
      break;

    case BINOP_LEQ:
      ax_simple (ax, aop_swap);
      gen_less (ax, value, value1, value2, int_type);
      gen_logical_not (ax, value, int_type);
      break;

    case BINOP_GEQ:
      gen_less (ax, value, value1, value2, int_type);
      gen_logical_not (ax, value, int_type);
      break;

    default:
      /* We should only list operators in the outer case statement
	 that we actually handle in the inner case statement.  */
      internal_error (__FILE__, __LINE__,
		      _("gen_expr: op case sets don't match"));
    }
}


/* Given a single variable and a scope, generate bytecodes to trace
   its value.  This is for use in situations where we have only a
   variable's name, and no parsed expression; for instance, when the
   name comes from a list of local variables of a function.  */

struct agent_expr *
gen_trace_for_var (CORE_ADDR scope, struct gdbarch *gdbarch,
		   struct symbol *var, int trace_string)
{
  struct cleanup *old_chain = 0;
  struct agent_expr *ax = new_agent_expr (gdbarch, scope);
  struct axs_value value;

  old_chain = make_cleanup_free_agent_expr (ax);

  ax->tracing = 1;
  ax->trace_string = trace_string;
  gen_var_ref (gdbarch, ax, &value, var);

  /* If there is no actual variable to trace, flag it by returning
     an empty agent expression.  */
  if (value.optimized_out)
    {
      do_cleanups (old_chain);
      return NULL;
    }

  /* Make sure we record the final object, and get rid of it.  */
  gen_traced_pop (gdbarch, ax, &value);

  /* Oh, and terminate.  */
  ax_simple (ax, aop_end);

  /* We have successfully built the agent expr, so cancel the cleanup
     request.  If we add more cleanups that we always want done, this
     will have to get more complicated.  */
  discard_cleanups (old_chain);
  return ax;
}

/* Generating bytecode from GDB expressions: driver */

/* Given a GDB expression EXPR, return bytecode to trace its value.
   The result will use the `trace' and `trace_quick' bytecodes to
   record the value of all memory touched by the expression.  The
   caller can then use the ax_reqs function to discover which
   registers it relies upon.  */
struct agent_expr *
gen_trace_for_expr (CORE_ADDR scope, struct expression *expr,
		    int trace_string)
{
  struct cleanup *old_chain = 0;
  struct agent_expr *ax = new_agent_expr (expr->gdbarch, scope);
  union exp_element *pc;
  struct axs_value value;

  old_chain = make_cleanup_free_agent_expr (ax);

  pc = expr->elts;
  ax->tracing = 1;
  ax->trace_string = trace_string;
  value.optimized_out = 0;
  gen_expr (expr, &pc, ax, &value);

  /* Make sure we record the final object, and get rid of it.  */
  gen_traced_pop (expr->gdbarch, ax, &value);

  /* Oh, and terminate.  */
  ax_simple (ax, aop_end);

  /* We have successfully built the agent expr, so cancel the cleanup
     request.  If we add more cleanups that we always want done, this
     will have to get more complicated.  */
  discard_cleanups (old_chain);
  return ax;
}

/* Given a GDB expression EXPR, return a bytecode sequence that will
   evaluate and return a result.  The bytecodes will do a direct
   evaluation, using the current data on the target, rather than
   recording blocks of memory and registers for later use, as
   gen_trace_for_expr does.  The generated bytecode sequence leaves
   the result of expression evaluation on the top of the stack.  */

struct agent_expr *
gen_eval_for_expr (CORE_ADDR scope, struct expression *expr)
{
  struct cleanup *old_chain = 0;
  struct agent_expr *ax = new_agent_expr (expr->gdbarch, scope);
  union exp_element *pc;
  struct axs_value value;

  old_chain = make_cleanup_free_agent_expr (ax);

  pc = expr->elts;
  ax->tracing = 0;
  value.optimized_out = 0;
  gen_expr (expr, &pc, ax, &value);

  require_rvalue (ax, &value);

  /* Oh, and terminate.  */
  ax_simple (ax, aop_end);

  /* We have successfully built the agent expr, so cancel the cleanup
     request.  If we add more cleanups that we always want done, this
     will have to get more complicated.  */
  discard_cleanups (old_chain);
  return ax;
}

struct agent_expr *
gen_trace_for_return_address (CORE_ADDR scope, struct gdbarch *gdbarch,
			      int trace_string)
{
  struct cleanup *old_chain = 0;
  struct agent_expr *ax = new_agent_expr (gdbarch, scope);
  struct axs_value value;

  old_chain = make_cleanup_free_agent_expr (ax);

  ax->tracing = 1;
  ax->trace_string = trace_string;

  gdbarch_gen_return_address (gdbarch, ax, &value, scope);

  /* Make sure we record the final object, and get rid of it.  */
  gen_traced_pop (gdbarch, ax, &value);

  /* Oh, and terminate.  */
  ax_simple (ax, aop_end);

  /* We have successfully built the agent expr, so cancel the cleanup
     request.  If we add more cleanups that we always want done, this
     will have to get more complicated.  */
  discard_cleanups (old_chain);
  return ax;
}

/* Given a collection of printf-style arguments, generate code to
   evaluate the arguments and pass everything to a special
   bytecode.  */

struct agent_expr *
gen_printf (CORE_ADDR scope, struct gdbarch *gdbarch,
	    CORE_ADDR function, LONGEST channel,
	    const char *format, int fmtlen,
	    struct format_piece *frags,
	    int nargs, struct expression **exprs)
{
  struct cleanup *old_chain = 0;
  struct agent_expr *ax = new_agent_expr (gdbarch, scope);
  union exp_element *pc;
  struct axs_value value;
  int tem;

  old_chain = make_cleanup_free_agent_expr (ax);

  /* We're computing values, not doing side effects.  */
  ax->tracing = 0;

  /* Evaluate and push the args on the stack in reverse order,
     for simplicity of collecting them on the target side.  */
  for (tem = nargs - 1; tem >= 0; --tem)
    {
      pc = exprs[tem]->elts;
      value.optimized_out = 0;
      gen_expr (exprs[tem], &pc, ax, &value);
      require_rvalue (ax, &value);
    }

  /* Push function and channel.  */
  ax_const_l (ax, channel);
  ax_const_l (ax, function);

  /* Issue the printf bytecode proper.  */
  ax_simple (ax, aop_printf);
  ax_simple (ax, nargs);
  ax_string (ax, format, fmtlen);

  /* And terminate.  */
  ax_simple (ax, aop_end);

  /* We have successfully built the agent expr, so cancel the cleanup
     request.  If we add more cleanups that we always want done, this
     will have to get more complicated.  */
  discard_cleanups (old_chain);

  return ax;
}

static void
agent_eval_command_one (const char *exp, int eval, CORE_ADDR pc)
{
  struct cleanup *old_chain = 0;
  struct expression *expr;
  struct agent_expr *agent;
  const char *arg;
  int trace_string = 0;

  if (!eval)
    {
      if (*exp == '/')
        exp = decode_agent_options (exp, &trace_string);
    }

  arg = exp;
  if (!eval && strcmp (arg, "$_ret") == 0)
    {
      agent = gen_trace_for_return_address (pc, get_current_arch (),
					    trace_string);
      old_chain = make_cleanup_free_agent_expr (agent);
    }
  else
    {
      expr = parse_exp_1 (&arg, pc, block_for_pc (pc), 0);
      old_chain = make_cleanup (free_current_contents, &expr);
      if (eval)
	{
	  gdb_assert (trace_string == 0);
	  agent = gen_eval_for_expr (pc, expr);
	}
      else
	agent = gen_trace_for_expr (pc, expr, trace_string);
      make_cleanup_free_agent_expr (agent);
    }

  ax_reqs (agent);
  ax_print (gdb_stdout, agent);

  /* It would be nice to call ax_reqs here to gather some general info
     about the expression, and then print out the result.  */

  do_cleanups (old_chain);
  dont_repeat ();
}

static void
agent_command_1 (char *exp, int eval)
{
  /* We don't deal with overlay debugging at the moment.  We need to
     think more carefully about this.  If you copy this code into
     another command, change the error message; the user shouldn't
     have to know anything about agent expressions.  */
  if (overlay_debugging)
    error (_("GDB can't do agent expression translation with overlays."));

  if (exp == 0)
    error_no_arg (_("expression to translate"));

  if (check_for_argument (&exp, "-at", sizeof ("-at") - 1))
    {
      struct linespec_result canonical;
      int ix;
      struct linespec_sals *iter;
      struct cleanup *old_chain;

      exp = skip_spaces (exp);
      init_linespec_result (&canonical);
      decode_line_full (&exp, DECODE_LINE_FUNFIRSTLINE,
			(struct symtab *) NULL, 0, &canonical,
			NULL, NULL);
      old_chain = make_cleanup_destroy_linespec_result (&canonical);
      exp = skip_spaces (exp);
      if (exp[0] == ',')
        {
	  exp++;
	  exp = skip_spaces (exp);
	}
      for (ix = 0; VEC_iterate (linespec_sals, canonical.sals, ix, iter); ++ix)
        {
	  int i;

	  for (i = 0; i < iter->sals.nelts; i++)
	    agent_eval_command_one (exp, eval, iter->sals.sals[i].pc);
        }
      do_cleanups (old_chain);
    }
  else
    agent_eval_command_one (exp, eval, get_frame_pc (get_current_frame ()));

  dont_repeat ();
}

static void
agent_command (char *exp, int from_tty)
{
  agent_command_1 (exp, 0);
}

/* Parse the given expression, compile it into an agent expression
   that does direct evaluation, and display the resulting
   expression.  */

static void
agent_eval_command (char *exp, int from_tty)
{
  agent_command_1 (exp, 1);
}

/* Parse the given expression, compile it into an agent expression
   that does a printf, and display the resulting expression.  */

static void
maint_agent_printf_command (char *exp, int from_tty)
{
  struct cleanup *old_chain = 0;
  struct expression *expr;
  struct expression *argvec[100];
  struct agent_expr *agent;
  struct frame_info *fi = get_current_frame ();	/* need current scope */
  const char *cmdrest;
  const char *format_start, *format_end;
  struct format_piece *fpieces;
  int nargs;

  /* We don't deal with overlay debugging at the moment.  We need to
     think more carefully about this.  If you copy this code into
     another command, change the error message; the user shouldn't
     have to know anything about agent expressions.  */
  if (overlay_debugging)
    error (_("GDB can't do agent expression translation with overlays."));

  if (exp == 0)
    error_no_arg (_("expression to translate"));

  cmdrest = exp;

  cmdrest = skip_spaces_const (cmdrest);

  if (*cmdrest++ != '"')
    error (_("Must start with a format string."));

  format_start = cmdrest;

  fpieces = parse_format_string (&cmdrest);

  old_chain = make_cleanup (free_format_pieces_cleanup, &fpieces);

  format_end = cmdrest;

  if (*cmdrest++ != '"')
    error (_("Bad format string, non-terminated '\"'."));
  
  cmdrest = skip_spaces_const (cmdrest);

  if (*cmdrest != ',' && *cmdrest != 0)
    error (_("Invalid argument syntax"));

  if (*cmdrest == ',')
    cmdrest++;
  cmdrest = skip_spaces_const (cmdrest);

  nargs = 0;
  while (*cmdrest != '\0')
    {
      const char *cmd1;

      cmd1 = cmdrest;
      expr = parse_exp_1 (&cmd1, 0, (struct block *) 0, 1);
      argvec[nargs] = expr;
      ++nargs;
      cmdrest = cmd1;
      if (*cmdrest == ',')
	++cmdrest;
      /* else complain? */
    }


  agent = gen_printf (get_frame_pc (fi), get_current_arch (), 0, 0,
		      format_start, format_end - format_start,
		      fpieces, nargs, argvec);
  make_cleanup_free_agent_expr (agent);
  ax_reqs (agent);
  ax_print (gdb_stdout, agent);

  /* It would be nice to call ax_reqs here to gather some general info
     about the expression, and then print out the result.  */

  do_cleanups (old_chain);
  dont_repeat ();
}


/* Initialization code.  */

void _initialize_ax_gdb (void);
void
_initialize_ax_gdb (void)
{
  add_cmd ("agent", class_maintenance, agent_command,
	   _("\
Translate an expression into remote agent bytecode for tracing.\n\
Usage: maint agent [-at location,] EXPRESSION\n\
If -at is given, generate remote agent bytecode for this location.\n\
If not, generate remote agent bytecode for current frame pc address."),
	   &maintenancelist);

  add_cmd ("agent-eval", class_maintenance, agent_eval_command,
	   _("\
Translate an expression into remote agent bytecode for evaluation.\n\
Usage: maint agent-eval [-at location,] EXPRESSION\n\
If -at is given, generate remote agent bytecode for this location.\n\
If not, generate remote agent bytecode for current frame pc address."),
	   &maintenancelist);

  add_cmd ("agent-printf", class_maintenance, maint_agent_printf_command,
	   _("Translate an expression into remote "
	     "agent bytecode for evaluation and display the bytecodes."),
	   &maintenancelist);
}
@


1.112
log
@	* ax-gdb.c (gen_var_ref): Unconditionally call via computed ops,
	if possible.
	* dwarf2read.c (read_func_scope): Remove old FIXME.
	* eval.c (evaluate_subexp_standard): Check SYMBOL_COMPUTED_OPS,
	not LOC_COMPUTED.
	* findvar.c (symbol_read_needs_frame, default_read_var_value):
	Unconditionally call via computed ops, if possible.
	* printcmd.c (address_info): Unconditionally call via computed ops,
	if possible.
	* stack.c (read_frame_arg): Unconditionally call via computed ops,
	if possible.
	* symtab.c (register_symbol_computed_impl): Sanity check 'ops'.
	* tracepoint.c (scope_info): Unconditionally call via computed ops,
	if possible.
@
text
@a314 30
/* Generating bytecode from GDB expressions: the `trace' kludge  */

/* The compiler in this file is a general-purpose mechanism for
   translating GDB expressions into bytecode.  One ought to be able to
   find a million and one uses for it.

   However, at the moment it is HOPELESSLY BRAIN-DAMAGED for the sake
   of expediency.  Let he who is without sin cast the first stone.

   For the data tracing facility, we need to insert `trace' bytecodes
   before each data fetch; this records all the memory that the
   expression touches in the course of evaluation, so that memory will
   be available when the user later tries to evaluate the expression
   in GDB.

   This should be done (I think) in a post-processing pass, that walks
   an arbitrary agent expression and inserts `trace' operations at the
   appropriate points.  But it's much faster to just hack them
   directly into the code.  And since we're in a crunch, that's what
   I've done.

   Setting the flag trace_kludge to non-zero enables the code that
   emits the trace bytecodes at the appropriate points.  */
int trace_kludge;

/* Inspired by trace_kludge, this indicates that pointers to chars
   should get an added tracenz bytecode to record nonzero bytes, up to
   a length that is the value of trace_string_kludge.  */
int trace_string_kludge;

d374 1
a374 1
  if (trace_string_kludge
d380 1
a380 1
  if (trace_kludge)
d386 1
a386 1
	    ax_const_l (ax, trace_string_kludge);
d414 1
a414 1
	      ax_const_l (ax, trace_string_kludge);
d432 1
a432 1
	    ax_const_l (ax, trace_string_kludge);
d442 1
a442 1
  if (trace_kludge
d482 1
a482 1
  if (trace_kludge)
d1334 1
a1334 1
	  if (trace_kludge)
d1903 1
a1903 1
	      if (trace_kludge)
d1930 1
a1930 1
	      if (trace_kludge)
d1939 1
a1939 1
	      if (trace_kludge)
d2020 1
a2020 1
	    if (trace_kludge)
d2397 1
a2397 1
		   struct symbol *var)
d2405 2
a2406 1
  trace_kludge = 1;
d2438 2
a2439 1
gen_trace_for_expr (CORE_ADDR scope, struct expression *expr)
d2449 2
a2450 1
  trace_kludge = 1;
d2485 1
a2485 1
  trace_kludge = 0;
d2502 2
a2503 1
gen_trace_for_return_address (CORE_ADDR scope, struct gdbarch *gdbarch)
d2511 2
a2512 1
  trace_kludge = 1;
d2548 3
a2555 2
      /* We're computing values, not doing side effects.  */
      trace_kludge = 0;
d2588 1
a2591 1
      trace_string_kludge = 0;
d2593 1
a2593 1
        exp = decode_agent_options (exp);
d2599 2
a2600 1
      agent = gen_trace_for_return_address (pc, get_current_arch ());
d2608 4
a2611 1
	agent = gen_eval_for_expr (pc, expr);
d2613 1
a2613 1
	agent = gen_trace_for_expr (pc, expr);
@


1.111
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d665 6
d759 1
a759 7
      /* FIXME: cagney/2004-01-26: It should be possible to
	 unconditionally call the SYMBOL_COMPUTED_OPS method when available.
	 Unfortunately DWARF 2 stores the frame-base (instead of the
	 function) location in a function's symbol.  Oops!  For the
	 moment enable this when/where applicable.  */
      SYMBOL_COMPUTED_OPS (var)->tracepoint_var_ref (var, gdbarch, ax, value);
      break;
@


1.110
log
@	* ada-lang.c (ada_read_renaming_var_value): Pass const
	pointer to expression string to parse_exp_1.
	(create_excep_cond_exprs): Likewise.
	* ax-gdb.c (agent_eval_command_one): Likewise.
	(maint_agent_printf_command): Likewise.
	Constify much of the string handling/parsing.
	* breakpoint.c (set_breakpoint_condition): Pass const
	pointer to expression string to parse_exp_1.
	(update_watchpoint): Likewise.
	(parse_cmd_to_aexpr): Constify string handling.
	Pass const pointer to parse_exp_1.
	(init_breakpoint_sal): Pass const pointer to parse_exp_1.
	(find_condition_and_thread): Likewise.
	Make TOK const.
	(watch_command_1): Make "arg" const.
	Constify string handling.
	Copy the expression string instead of changing the input
	string.
	(update_breakpoint_location): Pass const pointer to
	parse_exp_1.
	* eval.c (parse_and_eval_address): Make "exp" const.
	(parse_to_comma_and_eval): Make "expp" const.
	(parse_and_eval): Make "exp" const.
	* expression.h (parse_expression): Make argument const.
	(parse_exp_1): Make first argument const.
	* findcmd.c (parse_find_args): Treat "args" as const.
	* linespec.c (parse_linespec): Pass const pointer to
	linespec_expression_to_pc.
	(linespec_expression_to_pc): Make "exp_ptr" const.
	* parse.c (parse_exp_1): Make "stringptr" const.
	Make a copy of the expression to pass to parse_exp_in_context until
	this whole interface can be constified.
	(parse_expression): Make "string" const.
	* printcmd.c (ui_printf): Treat "arg" as const.
	Handle const strings.
	* tracepoint.c (validate_actionline): Pass const pointer to
	all calls to parse_exp_1.
	(encode_actions_1): Likewise.
	* value.h (parse_to_comma_and_eval): Make argument const.
	(parse_and_eval_address): Likewise.
	(parse_and_eval): Likewise.
	* varobj.c (varobj_create): Pass const pointer to parse_exp_1.
	(varobj_set_value): Likewise.
	* cli/cli-cmds.c (disassemble_command): Treat "arg" as const and
	constify string handling.
	Pass const pointers to parse_and_eval_address and
	parse_to_comman_and_eval.
	* cli/cli-utils.c (skip_to_space): Rename to ...
	(skip_to_space_const): ... this. Handle const strings.
	* cli/cli-utils.h (skip_to_space): Turn into macro which invokes
	skip_to_space_const.
	(skip_to_space_const): Declare.
	* common/format.c (parse_format_string): Make "arg" const.
	Handle const strings.
	* common/format.h (parse_format_string): Make "arg" const.
	* gdbserver/ax.c (ax_printf): Make "format" const.
	* python/python.c (gdbpy_parse_and_eval): Do not make a copy
	of the expression string.
@
text
@d2606 1
a2606 1
agent_eval_command_one (char *exp, int eval, CORE_ADDR pc)
@


1.109
log
@	* ax-gdb.c (gen_printf): Make FORMAT const.
	* ax-gdb.h (gen_printf): Likewise.
	* ax-general.c (ax_string): Make STR const.
	* ax.h (ax_string): Likewise.
@
text
@d2611 1
d2620 2
a2621 1
  if (!eval && strcmp (exp, "$_ret") == 0)
d2628 1
a2628 1
      expr = parse_exp_1 (&exp, pc, block_for_pc (pc), 0);
d2721 2
a2722 2
  char *cmdrest;
  char *format_start, *format_end;
d2738 1
a2738 1
  cmdrest = skip_spaces (cmdrest);
d2754 1
a2754 1
  cmdrest = skip_spaces (cmdrest);
d2761 1
a2761 1
  cmdrest = skip_spaces (cmdrest);
d2766 1
a2766 1
      char *cmd1;
@


1.108
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

        * auto-load.c (auto_load_expand_dir_vars): Remove unused dir_vec.
        * ax-gdb.c (gen_printf): Remove unused expr, i, bot, fr, flen, fmt.
        * ax-general.c (ax_print): Remove unused is_float.
        * blockframe.c (block_innermost_frame): Remove unused start, end.
        * break-catch-sig.c (catch_signal_command): Remove unused gdbarch.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00752.html
@
text
@d2561 1
a2561 1
	    char *format, int fmtlen,
@


1.107
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a2564 1
  struct expression *expr;
d2569 1
a2569 2
  int i, tem, bot, fr, flen;
  char *fmt;
@


1.106
log
@	* ada-valprint.c (ada_val_print_1): Eliminate single-use
	variable LEN.
	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
	directly.
	(alpha_store_return_value): Likewise.
	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
	(amd64_push_arguments): Likewise.
	* ax-gdb.c (gen_trace_static_fields): Likewise.
	(gen_traced_pop): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* breakpoint.c (update_watchpoint): Likewise.
	* findcmd.c (parse_find_args): Use local variable for type
	instead of length.
	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
	(h8300_store_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
	Use i386_darwin_arg_type_alignment directly.
	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	(m68hc11_extract_return_value): Likewise.
	* mep-tdep.c (mep_push_dummy_call): Likewise.
	* printcmd.c (float_type_from_length): Likewise.
	* s390-tdep.c (s390_value_from_register): Likewise.
	* stack.c (read_frame_arg): Likewise.
	* tracepoint.c (encode_actions_1): Likewise.
	* valops.c (value_fetch_lazy): Use local variable for type
	instead of length.  Use TYPE_LENGTH directly.
	* value.c (value_contents_equal): Use TYPE_LENGTH directly.
@
text
@d3 1
a3 2
   Copyright (C) 1998-2001, 2003, 2007-2012 Free Software Foundation,
   Inc.
@


1.105
log
@	PR exp/13206:
	* ax-gdb.c (gen_expr) <OP_TYPEOF, OP_DECLTYPE>: New cases.
	* breakpoint.c (watchpoint_exp_is_const) <OP_TYPEOF,
	OP_DECLTYPE>: New cases.
	* c-exp.y (TYPEOF, DECLTYPE): New tokens.
	(type_exp): Add new productions.
	(ident_tokens): Add __typeof__, typeof, __typeof, __decltype,
	and decltype.
	* eval.c (evaluate_subexp_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* expprint.c (dump_subexp_body_standard) <OP_TYPEOF,
	OP_DECLTYPE>: New case.
	* parse.c (operator_length_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* std-operator.def (OP_TYPEOF, OP_DECLTYPE): New constants.
	* varobj.c (varobj_create): Handle OP_TYPEOF, OP_DECLTYPE.
gdb/testsuite
	* gdb.cp/casts.exp: Add tests for typeof and decltype.
	* gdb.cp/casts.cc (decltype): New function.
	(main): Use it.
@
text
@d370 3
a372 3
		int length = TYPE_LENGTH (check_typedef (value.type));

		ax_const_l (ax, length);
a427 2
	  int length = TYPE_LENGTH (check_typedef (value->type));

d431 3
d439 1
a439 1
	  ax_const_l (ax, length);
@


1.104
log
@	* ax-gdb.c (gen_expr): Handle UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE.
	* breakpoint.c (watchpoint_exp_is_const): Handle UNOP_CAST_TYPE,
	UNOP_REINTERPRET_CAST, UNOP_DYNAMIC_CAST.
	* c-exp.y (exp): Emit UNOP_MEMVAL_TYPE, UNOP_CAST_TYPE.  Update
	for changes to UNOP_REINTERPRET_CAST, UNOP_DYNAMIC_CAST.  Use
	type_exp production where appropriate.
	* eval.c (evaluate_subexp_standard) <UNOP_CAST_TYPE>: New case.
	<UNOP_DYNAMIC_CAST, UNOP_REINTERPRET_CAST>: Update.
	<UNOP_MEMVAL_TYPE>: New case.
	(evaluate_subexp_for_address) <UNOP_MEMVAL_TYPE>: New case.
	(evaluate_subexp_for_sizeof) <UNOP_MEMVAL_TYPE>: New case.
	* expprint.c (print_subexp_standard) <UNOP_CAST_TYPE>: New case.
	<UNOP_MEMVAL_TYPE>: New case.
	(dump_subexp_body_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: Update.
	<UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE>: New cases.
	* parse.c (operator_length_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: Update.
	<UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE>: New cases.
	* stack.c (return_command): Also check for UNOP_CAST_TYPE.
	* std-operator.def (UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE): New
	constants.
@
text
@d2258 2
@


1.103
log
@2012-07-05  Hui Zhu  <hui_zhu@@mentor.com>

	* ax-gdb.c (cli/cli-utils.h): New include.
	(linespec.h): Ditto.
	(agent_eval_command_one): New function.
	(agent_command_1): Ditto.
	(agent_command): Call function agent_command_1.
	(agent_eval_command): Ditto.
	(_initialize_ax_gdb): Change help for "maint agent"
	and "maint agent-eval".
@
text
@d2079 17
d2114 25
@


1.102
log
@	Add target-side support for dynamic printf.
	* NEWS: Mention the additional style.
	* breakpoint.h (struct bp_target_info): New fields tcommands, persist.
	(struct bp_location): New field cmd_bytecode.
	* breakpoint.c: Include format.h.
	(disconnected_dprintf): New global.
	(parse_cmd_to_aexpr): New function.
	(build_target_command_list): New function.
	(insert_bp_location): Call it.
	(remove_breakpoints_pid): Skip dprintf breakpoints.
	(print_one_breakpoint_location): Ditto.
	(dprintf_style_agent): New global.
	(dprintf_style_enums): Add dprintf_style_agent.
	(update_dprintf_command_list): Add agent case.
	(agent_printf_command): New function.
	(_initialize_breakpoint): Add new commands.
	* common/ax.def (printf): New bytecode.
	* ax.h (ax_string): Declare.
	* ax-gdb.h (gen_printf): Declare.
	* ax-gdb.c: Include cli-utils.h, format.h.
	(gen_printf): New function.
	(maint_agent_print_command): New function.
	(_initialize_ax_gdb): Add maint agent-printf command.
	* ax-general.c (ax_string): New function.
	(ax_print): Add printf disassembly.
	* Makefile.in (SFILES): Add format.c
	(COMMON_OBS): Add format.o.
	* common/format.h: New file.
	* common/format.c: New file.
	* printcmd.c: Include format.h.
	(ui_printf): Call parse_format_string.
	* remote.c (remote_state): New field breakpoint_commands.
	(PACKET_BreakpointCommands): New enum.
	(remote_breakpoint_commands_feature): New function.
	(remote_protocol_features): Add new BreakpointCommands entry.
	(remote_can_run_breakpoint_commands): New function.
	(remote_add_target_side_commands): New function.
	(remote_insert_breakpoint): Call it.
	(remote_insert_hw_breakpoint): Ditto.
	(_initialize_remote): Add new packet configuration for
	target-side breakpoint commands.
	* target.h (struct target_ops): New field
	to_can_run_breakpoint_commands.
	(target_can_run_breakpoint_commands): New macro.
	* target.c (update_current_target): Handle
	to_can_run_breakpoint_commands.

	[gdbserver]
	* Makefile.in (WARN_CFLAGS_NO_FORMAT): Define.
	(ax.o): Add it to build rule.
	(ax-ipa.o): Ditto.
	(OBS): Add format.o.
	(IPA_OBS): Add format.o.
	* server.c (handle_query): Claim support for breakpoint commands.
	(process_point_options): Add command case.
	(process_serial_event): Leave running if there are printfs in
	effect.
	* mem-break.h (any_persistent_commands): Declare.
	(add_breakpoint_commands): Declare.
	(gdb_no_commands_at_breakpoint): Declare.
	(run_breakpoint_commands): Declare.
	* mem-break.c (struct point_command_list): New struct.
	(struct breakpoint): New field command_list.
	(any_persistent_commands): New function.
	(add_commands_to_breakpoint): New function.
	(add_breakpoint_commands): New function.
	(gdb_no_commands_at_breakpoint): New function.
	(run_breakpoint_commands): New function.
	* linux-low.c (linux_wait_1): Test for and run breakpoint commands
	locally.
	* ax.c: Include format.h.
	(ax_printf): New function.
	(gdb_eval_agent_expr): Add printf opcode.

	[doc]
	* gdb.texinfo (Dynamic Printf): Mention agent style and
	disconnected dprintf.
	(Maintenance Commands): Describe maint agent-printf.
	(General Query Packets): Mention BreakpointCommands feature.
	(Packets): Document commands extension to Z0 packet.
	* agentexpr.texi (Bytecode Descriptions): Document printf
	bytecode.

	[testsuite]
	* gdb.base/dprintf.exp: Add agent style tests.
@
text
@d45 1
d2564 1
a2564 1
agent_command (char *exp, int from_tty)
a2568 1
  struct frame_info *fi = get_current_frame ();	/* need current scope */
d2570 6
a2575 9
  /* We don't deal with overlay debugging at the moment.  We need to
     think more carefully about this.  If you copy this code into
     another command, change the error message; the user shouldn't
     have to know anything about agent expressions.  */
  if (overlay_debugging)
    error (_("GDB can't do agent expression translation with overlays."));

  if (exp == 0)
    error_no_arg (_("expression to translate"));
d2577 1
a2577 7
  trace_string_kludge = 0;
  if (*exp == '/')
    exp = decode_agent_options (exp);

  /* Recognize the return address collection directive specially.  Note
     that it is not really an expression of any sort.  */
  if (strcmp (exp, "$_ret") == 0)
d2579 1
a2579 2
      agent = gen_trace_for_return_address (get_frame_pc (fi),
					    get_current_arch ());
d2584 1
a2584 1
      expr = parse_expression (exp);
d2586 4
a2589 1
      agent = gen_trace_for_expr (get_frame_pc (fi), expr);
a2602 4
/* Parse the given expression, compile it into an agent expression
   that does direct evaluation, and display the resulting
   expression.  */

d2604 1
a2604 1
agent_eval_command (char *exp, int from_tty)
a2605 5
  struct cleanup *old_chain = 0;
  struct expression *expr;
  struct agent_expr *agent;
  struct frame_info *fi = get_current_frame ();	/* need current scope */

d2616 39
a2654 6
  expr = parse_expression (exp);
  old_chain = make_cleanup (free_current_contents, &expr);
  agent = gen_eval_for_expr (get_frame_pc (fi), expr);
  make_cleanup_free_agent_expr (agent);
  ax_reqs (agent);
  ax_print (gdb_stdout, agent);
d2656 3
a2658 2
  /* It would be nice to call ax_reqs here to gather some general info
     about the expression, and then print out the result.  */
d2660 4
a2663 2
  do_cleanups (old_chain);
  dont_repeat ();
d2665 1
d2757 5
a2761 2
	   _("Translate an expression into "
	     "remote agent bytecode for tracing."),
d2765 5
a2769 2
	   _("Translate an expression into remote "
	     "agent bytecode for evaluation."),
@


1.101
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d44 1
d49 2
d2509 53
d2645 82
d2744 5
@


1.100
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@a2173 1
	char *this_name;
@


1.99
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	* ax-gdb.c (gen_expr): Clean up code to handle internal variables
	and to compile agent expressions.
	* infrun.c (siginfo_make_value): New argument `ignore'.
	(siginfo_funcs): New struct.
	(_initialize_infrun): New argument when calling
	`create_internalvar_type_lazy'.
	* thread.c (thread_id_make_value): New argument `ignore'.
	(thread_funcs): New struct.
	(_initialize_thread): New argument when calling
	`create_internalvar_type_lazy'.
	* tracepoint.c (sdata_make_value): New argument `ignore'.
	(sdata_funcs): New struct.
	(_initialize_tracepoint): New argument when calling
	`create_internalvar_type_lazy'.
	* value.c (make_value): New struct.
	(create_internalvar_type_lazy): New argument `data'.
	(compile_internalvar_to_ax): New function.
	(value_of_internalvar): Properly handling `make_value' case.
	(clear_internalvar): Likewise.
	(show_convenience): Adding `TRY_CATCH' block.
	* value.h (internalvar_make_value): Delete, replace by...
	(struct internalvar_funcs): ... this.
	(create_internalvar_type_lazy) <fun>: Delete argument.
	(create_internalvar_type_lazy) <funcs>, <data>: New arguments.
	(compile_internalvar_to_ax): New function.
	* windows-tdep.c (tlb_make_value): New argument `ignore'.
	(tlb_funcs): New struct.
	(_initialize_windows_tdep): New argument when calling
	`create_internalvar_type_lazy'.
@
text
@a97 2

static void require_rvalue (struct agent_expr *ax, struct axs_value *value);
a157 2
static void gen_expr (struct expression *exp, union exp_element **pc,
		      struct agent_expr *ax, struct axs_value *value);
d790 1
a790 1
static void
d1802 1
a1802 1
static void
@


1.98
log
@SEGV during AX eval of OP_DOUBLE (unsupported)

To reproduce the problem, simply try the following with any program:

    (gdb) maintenance agent-eval 1.0
    Critical error handler: process [...] terminated due to access violation

(this is on Windows; on GNU/Linux, the libc copes better)

The problem is quite simple: gen_expr is given an expression that
contains an unrecognized operator (OP_DOUBLE in this case). When that
happens, it tries to report an error with a string image of the operator
in the error message.  Conversion of the opcode into a string is done
using op_string which, despite its name, probably is not what the author
was looking for.  This function returns NULL for a lot of the opcodes,
thus triggering the crash.

There is a function that corresponds to what we are looking for:
expprint.c:op_name. It was static, though, so I made it non-static,
and used it from ax-gdb.c:gen_expr.

gdb/ChangeLog:

        * expression.h (op_name): Add declaration.
        * expprint.c (op_name): Remove declaration.  Make non-static.
        * ax-gdb.c (gen_expr): Use op_name instead of op_string.
@
text
@d2041 2
a2042 1
	const char *name = internalvar_name ((*pc)[1].internalvar);
d2056 1
a2056 1
	else
@


1.97
log
@ax-gdb: Do not treat enums and bools as integers.

This patch fixes a problem when using gdb + gdbserver, and trying
to break on a function when one of the (enum) parameters is equal
to a certain value, and the size of that enum is 1 byte.

    (gdb) break mixed.adb:15 if light = green
    Breakpoint 2 at 0x402d5a: file mixed.adb, line 15.
    (gdb) cont
    Continuing.
    [Inferior 1 (process 9742) exited normally]

The debugger should have stopped once when our function was call
with light set to green.

Here is what happens: Because we're using a recent GDBserver,
GDB hands off the evaluation of the condition to GDBserver, by
providing it in the Z0 packet. This is what GDB sends:

    $Z0,402d5a,1;X13,26000622100223ff1c16100219162022011327#cf

I decoded the condition as follow:

    260006    reg 6 -> push
    2210      const8 0x10 -> push
    02        add (stack now has 1 element equal to reg6 + 16)
    23ff1c    const16 0xff1c
    1610      ext 16 (sign extend 16 bits)
    02        add (stack now has 1 element equal to reg6 + 16 - 228)
    19        ref32: Pop as addr, push 32bit value at addr.
    1620      ext 32 (sign extend 32 bits)
    2201      const8 0x01
    13        equal
    27        end

The beginning of the agent expression can be explained by the address
of symbol "light":

    (gdb) info addr light
    Symbol "light" is a variable at frame base reg $rbp offset 16+-228.

However, the mistake is the "ext 32" operation (extend 32 bits),
because our variable is *not* 32bits, only 8:

    (gdb) print light'size
    $5 = 8

But the reason why GDB decides to use a 32bit extension is because
it overrides the symbol's type with a plain integer type in
ax-gdb.c:gen_usual_unary...

      /* If the value is an enum or a bool, call it an integer.  */
    case TYPE_CODE_ENUM:
    case TYPE_CODE_BOOL:
      value->type = builtin_type (exp->gdbarch)->builtin_int;
      break;

... before calling require_rvalue. And of course, that causes the
generator to generate a sizeof(int) extension of the result.

One way to fix this would be to use an integer type of the correct
size, but I do not understand why this is necessary. The two routines
that use that information to generate the opcode down the line are
gen_fetch (for a memory value), or gen_extend (for a register value).
And they both have handling of enums and bools.

So the fix we elected to implement was simply to remove that code.

gdb/ChangeLog:

        * ax-gdb.c (gen_usual_unary): Remove special handling of
        enum and bool types.
@
text
@d2220 1
a2220 1
	     op_string (op), op);
@


1.96
log
@ax-gdb.c: Add handling of TYPE_CODE_RANGE types.

This patch fixes an error that occurs with GDB + GDBserver when
trying to insert a breakpoint with a condition that involves
a range type. For instance:

    type INT_T  is range 0 .. 1000;
    INT_VAR : INT_T := 12;

And then trying to insert the breakpoint:

    (gdb) break foo.adb:18 if int_var > 15
    Breakpoint 1 at 0x4021eb: file foo.adb, line 18.
    (gdb) cont
    Continuing.
    /[...]/ax-gdb.c:560: internal-error: gen_fetch: bad type code
    A problem internal to GDB has been detected,
    further debugging may prove unreliable.
    Quit this debugging session? (y or n)

This patch fixes the problem by adding handling for range types
in gen_fetch.

gdb/ChangeLog:

        * ax-gdb.c (gen_fetch): Add handling for TYPE_CODE_RANGE types.
@
text
@a882 6

      /* If the value is an enum or a bool, call it an integer.  */
    case TYPE_CODE_ENUM:
    case TYPE_CODE_BOOL:
      value->type = builtin_type (exp->gdbarch)->builtin_int;
      break;
@


1.95
log
@Revert "ax-gdb: Do not treat enums and bools as integers."

This patch was checked hasn't been reviewed and has been checked in
by mistake (wrong patch applied).
@
text
@d518 3
@


1.94
log
@2012-03-08  Luis Machado  <lgustavo@@codesourcery.com>

	* ax-gdb.c (gen_fetch): Fail gracefully and use error instead
	of internal error for unknown/unsupported types.
@
text
@d880 6
@


1.93
log
@ax-gdb: Do not treat enums and bools as integers.

This patch fixes a problem when using gdb + gdbserver, and trying
to break on a function when one of the (enum) parameters is equal
to a certain value, and the size of that enum is 1 byte.

    (gdb) break mixed.adb:15 if light = green
    Breakpoint 2 at 0x402d5a: file mixed.adb, line 15.
    (gdb) cont
    Continuing.
    [Inferior 1 (process 9742) exited normally]

The debugger should have stopped once when our function was call
with light set to green.

Here is what happens: Because we're using a recent GDBserver,
GDB hands off the evaluation of the condition to GDBserver, by
providing it in the Z0 packet. This is what GDB sends:

    $Z0,402d5a,1;X13,26000622100223ff1c16100219162022011327#cf

I decoded the condition as follow:

    260006    reg 6 -> push
    2210      const8 0x10 -> push
    02        add (stack now has 1 element equal to reg6 + 16)
    23ff1c    const16 0xff1c
    1610      ext 16 (sign extend 16 bits)
    02        add (stack now has 1 element equal to reg6 + 16 - 228)
    19        ref32: Pop as addr, push 32bit value at addr.
    1620      ext 32 (sign extend 32 bits)
    2201      const8 0x01
    13        equal
    27        end

The beginning of the agent expression can be explained by the address
of symbol "light":

    (gdb) info addr light
    Symbol "light" is a variable at frame base reg $rbp offset 16+-228.

However, the mistake is the "ext 32" operation (extend 32 bits),
because our variable is *not* 32bits, only 8:

    (gdb) print light'size
    $5 = 8

But the reason why GDB decides to use a 32bit extension is because
it overrides the symbol's type with a plain integer type in
ax-gdb.c:gen_usual_unary...

      /* If the value is an enum or a bool, call it an integer.  */
    case TYPE_CODE_ENUM:
    case TYPE_CODE_BOOL:
      value->type = builtin_type (exp->gdbarch)->builtin_int;
      break;

... before calling require_rvalue. And of course, that causes the
generator to generate a sizeof(int) extension of the result.

One way to fix this would be to use an integer type of the correct
size, but I do not understand why this is necessary. The two routines
that use that information to generate the opcode down the line are
gen_fetch (for a memory value), or gen_extend (for a register value).
And they both have handling of enums and bools.

So the fix we elected to implement was simply to remove that code.

gdb/ChangeLog:

        * ax-gdb.c (gen_usual_unary): Remove special handling of
        enum and bool types.
@
text
@d556 5
a560 6
      /* Either our caller shouldn't have asked us to dereference that
         pointer (other code's fault), or we're not implementing
         something we should be (this code's fault).  In any case,
         it's a bug the user shouldn't see.  */
      internal_error (__FILE__, __LINE__,
		      _("gen_fetch: bad type code"));
@


1.92
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@a880 6

      /* If the value is an enum or a bool, call it an integer.  */
    case TYPE_CODE_ENUM:
    case TYPE_CODE_BOOL:
      value->type = builtin_type (exp->gdbarch)->builtin_int;
      break;
@


1.91
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1480 1
a1480 1
      char *this_name = TYPE_FIELD_NAME (type, i);
d1628 1
a1628 1
      char *t_field_name = TYPE_FIELD_NAME (t, i);
@


1.90
log
@2011-11-02  Stan Shebs  <stan@@codesourcery.com>

	String collection for tracepoints.
	* NEWS: Mention string collection.
	* common/ax.def (tracenz): New bytecode.
	* ax-gdb.h (trace_string_kludge): Declare.
	* ax-gdb.c: Include valprint.h and c-lang.h.
	(trace_string_kludge): New global.
	(gen_traced_pop): Add string case.
	(agent_command): Add string case.
	* tracepoint.h (decode_agent_options): Declare.
	* tracepoint.c: Include cli-utils.h.
	(decode_agent_options): New function.
	(validate_actionline): Call it.
	(encode_actions_1): Ditto.
	* target.h (struct target_ops): New method to_supports_string_tracing.
	(target_supports_string_tracing): New macro.
	* target.c (update_current_target): Add to_supports_string_tracing.
	* remote.c (struct remote_state): New field string_tracing.
	(remote_string_tracing_feature): New function.
	(remote_protocol_features): New feature tracenz.
	(remote_supports_string_tracing): New function.
	(init_remote_ops): Set to_supports_string_tracing.

	* tracepoint.c (agent_mem_read_string): New function.
	(eval_agent_expr): Call it for tracenz.
	* server.c (handle_query): Report support for tracenz.

	* gdb.texinfo (Tracepoint Action Lists): Document collect/s.
	(General Query Packets): Describe tracenz feature.
	* agentexpr.texi (Bytecode Descriptions): Describe tracenz.

	* gdb.trace/collection.c: Add code using strings.
	* gdb.trace/collection.exp: Add tests of string collection.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.90.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 2
   Copyright (C) 1998-2001, 2003, 2007-2012 Free Software Foundation,
   Inc.
@


1.89
log
@	Add return address collection for tracepoints.
	* tracepoint.c (encode_actions_1): Add case for $_ret.
	(validate_actionline): Check for $_ret.
	(trace_dump_actions): Ditto.
	* ax-gdb.h (gen_trace_for_return_address): Declare.
	* ax-gdb.c: Include arch-utils.h.
	(gen_trace_for_return_address): New function.
	(agent_command): Add return address special case.
	* amd64-tdep.c: Include ax.h and ax-gdb.h.
	(amd64_gen_return_address): New function.
	(amd64_init_abi): Call it.
	* i386-tdep.c: Include ax.h and ax-gdb.h.
	(i386_gen_return_address): New function.
	(i386_init_abi): Call it.
	* arch-utils.h (default_gen_return_address): Declare.
	* arch-utils.c (default_gen_return_address): New function.
	* gdbarch.sh (gen_return_address): New method.
	* gdbarch.h, gdbarch.c: Regenerate.

	* gdb.texinfo (Tracepoint Action Lists): Document $_ret.

	* gdb.trace/collection.exp: Test collection of $_ret.
@
text
@d45 3
d341 5
d404 7
d415 9
a423 3
	/* We don't trace rvalues, just the lvalues necessary to
	   produce them.  So just dispose of this value.  */
	ax_simple (ax, aop_pop);
d430 3
d440 7
d456 9
d2532 4
@


1.88
log
@	* valops.c (value_of_this): Use lookup_language_this.
	* symtab.h (lookup_language_this): Declare.
	* symtab.c (lookup_language_this): New function.
	(lookup_symbol_aux): Use lookup_language_this.
	* ax-gdb.c (gen_expr) <OP_THIS>: Use lookup_language_this.
@
text
@d43 1
d2448 26
d2492 16
a2507 4
  expr = parse_expression (exp);
  old_chain = make_cleanup (free_current_contents, &expr);
  agent = gen_trace_for_expr (get_frame_pc (fi), expr);
  make_cleanup_free_agent_expr (agent);
@


1.87
log
@	* dwarf2read.c (dwarf2_add_field): Constify.
	* value.c (value_static_field): Constify.
	* gdbtypes.h (struct main_type) <field.field_location.physname>:
	Now const.
	* ax-gdb.c (gen_static_field): Constify
@
text
@d2141 1
a2141 1
	struct symbol *func, *sym;
d2143 1
d2145 5
a2149 7
	func = block_linkage_function (block_for_pc (ax->scope));
	this_name = language_def (SYMBOL_LANGUAGE (func))->la_name_of_this;
	b = SYMBOL_BLOCK_VALUE (func);

	/* Calling lookup_block_symbol is necessary to get the LOC_REGISTER
	   symbol instead of the LOC_ARG one (if both exist).  */
	sym = lookup_block_symbol (b, this_name, VAR_DOMAIN);
d2151 1
a2151 1
	  error (_("no `%s' found"), this_name);
@


1.86
log
@Revert the following change (not approved yet):

	2011-02-21  Hui Zhu  <teawater@@gmail.com>
	* Makefile.in (HFILES_NO_SRCDIR): Add printcmd.h.
	* ax-gdb.c (gen_printf_expr_callback): New function.
	* ax-gdb.h (gen_printf_expr_callback): Forward declare.
	* ax-general.c (ax_memcpy): New function.
	(ax_print): Handle "printf".
	(ax_reqs): Ditto.
	* ax.h (ax_memcpy): Forward declare.
	* common/ax.def (invalid2): Removed.
	(printf): New entry.
	* printcmd.c (printcmd.h): New include.
	(string_printf): New function.
	(ui_printf): Removed.
	(printf_command): Remove static.  Call string_printf.
	(eval_command): Call string_printf.
	* printcmd.h: New file.
	* tracepoint.c (validate_actionline,
	encode_actions_1): handle printf_command.
@
text
@d1552 1
a1552 1
      char *phys_name = TYPE_FIELD_STATIC_PHYSNAME (type, fieldno);
@


1.85
log
@2011-02-21  Hui Zhu  <teawater@@gmail.com>

	* Makefile.in (HFILES_NO_SRCDIR): Add printcmd.h.
	* ax-gdb.c (gen_printf_expr_callback): New function.
	* ax-gdb.h (gen_printf_expr_callback): Forward declare.
	* ax-general.c (ax_memcpy): New function.
	(ax_print): Handle "printf".
	(ax_reqs): Ditto.
	* ax.h (ax_memcpy): Forward declare.
	* common/ax.def (invalid2): Removed.
	(printf): New entry.
	* printcmd.c (printcmd.h): New include.
	(string_printf): New function.
	(ui_printf): Removed.
	(printf_command): Remove static.  Call string_printf.
	(eval_command): Call string_printf.
	* printcmd.h: New file.
	* tracepoint.c (validate_actionline,
	encode_actions_1): handle printf_command.
@
text
@a2447 59
void
gen_printf_expr_callback (char *fbuf, char **expp, void *loc_v, void *aexpr_v)
{
  struct bp_location	*loc = loc_v;
  struct agent_expr	*aexpr = aexpr_v;

  if (expp)
    {
      struct cleanup *old_chain = NULL;
      struct expression *expr = NULL;
      union exp_element *pc;
      struct axs_value value;

      expr = parse_exp_1 (expp, block_for_pc (loc->address), 1);
      old_chain = make_cleanup (free_current_contents, &expr);

      pc = expr->elts;
      trace_kludge = 0;
      value.optimized_out = 0;
      gen_expr (expr, &pc, aexpr, &value);

      if (value.optimized_out)
        error (_("value has been optimized out"));
      switch (value.kind)
        {
	case axs_lvalue_memory:
	  if (TYPE_CODE (value.type) != TYPE_CODE_ARRAY)
	    {
	      int length = TYPE_LENGTH (check_typedef (value.type));
	      switch (length)
		{
		case 4:
		  ax_simple (aexpr, aop_ref32);
		  break;
		case 8:
		  ax_simple (aexpr, aop_ref64);
		  break;
		default:
		  error (_("Size of value is not OK."));
		  break;
		}
	    }
	  break;
	case axs_lvalue_register:
	  ax_reg (aexpr, value.u.reg);
	  break;
        }

      do_cleanups (old_chain);
    }

  ax_simple (aexpr, aop_printf);
  if (expp)
    ax_simple (aexpr, 1);
  else
    ax_simple (aexpr, 0);
  ax_memcpy (aexpr, fbuf, strlen (fbuf) + 1);
}

@


1.84
log
@2011-02-16  Tom Tromey  <tromey@@redhat.com>

	gdb/
	* ax-gdb.c.c (gen_expr) <UNOP_MEMVAL>: Handle value kinds other
	than axs_rvalue.

2011-02-16  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* collection.c (globalarr3): New global.
	(main): Initialize it before collecting, and and clear it
	afterwards.
	* collection.exp (gdb_collect_globals_test): Test collecting with
	'{type} addr', where the addr expression is not an rvalue.
@
text
@d2448 59
@


1.83
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ax-gdb.c: Adjust some long output strings.
	* breakpoint.c: Ditto.
	* charset.c: Ditto.
	* cp-abi.c: Ditto.
	* infcall.c: Ditto.
	* infrun.c: Ditto.
	* linux-nat.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
@
text
@d2047 7
a2053 8
	/* I'm not sure I understand UNOP_MEMVAL entirely.  I think
	   it's just a hack for dealing with minsyms; you take some
	   integer constant, pretend it's the address of an lvalue of
	   the given type, and dereference it.  */
	if (value->kind != axs_rvalue)
	  /* This would be weird.  */
	  internal_error (__FILE__, __LINE__,
			  _("gen_expr: OP_MEMVAL operand isn't an rvalue???"));
@


1.82
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d1097 3
a1099 2
    error (_("First argument of `-' is a pointer, but second argument "
	     "is neither\nan integer nor a pointer of the same type."));
@


1.81
log
@run copyright.sh for 2011.
@
text
@d73 2
a74 1
static void gen_traced_pop (struct gdbarch *, struct agent_expr *, struct axs_value *);
d637 2
a638 1
		      _("gen_var_ref: LOC_CONST_BYTES symbols are not supported"));
d1097 2
a1098 3
    error (_("\
First argument of `-' is a pointer, but second argument is neither\n\
an integer nor a pointer of the same type."));
d1142 3
a1144 2
	   struct axs_value *value1, struct axs_value *value2, enum agent_op op,
	   enum agent_op op_unsigned, int may_carry, char *name)
d1452 2
a1453 1
		    error (_("static field `%s' has been optimized out, cannot use"),
d1475 2
a1476 1
				       offset + TYPE_BASECLASS_BITPOS (type, i) / TARGET_CHAR_BIT,
d1594 2
a1595 1
		error (_("static field `%s' has been optimized out, cannot use"),
d1714 2
a1715 1
      error (_("Right operand of `@@' must be a constant, in agent expressions."));
d1899 2
a1900 1
	    error (_("$%s is not a trace state variable, may not assign to it"), name);
d1935 2
a1936 1
	    error (_("$%s is not a trace state variable, may not assign to it"), name);
d2018 2
a2019 1
	  error (_("$%s is not a trace state variable; GDB agent expressions cannot use convenience variables."), name);
d2259 2
a2260 2
	    error (_("\
cannot subscript requested type: cannot call user defined functions"));
d2280 2
a2281 1
	  error (_("Argument to arithmetic operation not a number or boolean."));
d2524 2
a2525 1
	   _("Translate an expression into remote agent bytecode for tracing."),
d2529 2
a2530 1
	   _("Translate an expression into remote agent bytecode for evaluation."),
@


1.80
log
@2010-12-31  Michael Snyder  <msnyder@@vmware.com>

	* annotate.c: Comment cleanup, shorten long lines.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* auxv.c: Ditto.
	* auxv.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-gdb.h: Ditto.
	* ax-general.c: Ditto.
	* breakpoint.h: Ditto.
	* buildsym.h: Ditto.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2007, 2008, 2009, 2010
@


1.79
log
@2010-12-29  Hui Zhu  <teawater@@gmail.com>

	* ax-gdb.c (gen_expr): Change error message.
@
text
@d62 1
a62 1
/* Prototypes for local functions. */
d617 1
a617 1
  /* Dereference any typedefs. */
d989 1
a989 1
  /* Dereference typedefs. */
d1292 1
a1292 1
  /* Dereference any typedefs. */
d1680 1
a1680 1
/* Generate code for GDB's magical `repeat' operator.  
d2052 1
a2052 1
      /* + FOO is equivalent to 0 + FOO, which can be optimized. */
@


1.78
log
@	* ax-gdb.c (gen_expr) <OP_REGISTER>: Error out if trying to
	collect a user register.
@
text
@d1984 2
a1985 2
	  error (_("'%s' is a pseudo-register; "
		   "GDB cannot yet trace pseudoregister contents."),
@


1.77
log
@2010-12-28  Hui Zhu  <teawater@@gmail.com>

	* gdbarch.sh (ax_pseudo_register_collect,
	ax_pseudo_register_push_stack): new callbacks.
	(agent_expr): Forward declare.
	* gdbarch.h, gdbarch.c: Regenerate.
	* ax-gdb.c (gen_expr): Remove pseudo-register check code.
	* ax-general.c (user-regs.h): New include.
	(ax_reg): Call gdbarch_ax_pseudo_register_push_stack.
	(ax_reg_mask): Call gdbarch_ax_pseudo_register_collect.
	* mips-tdep.c (ax.h): New include.
	(mips_ax_pseudo_register_collect,
	mips_ax_pseudo_register_push_stack): New functions.
	(mips_gdbarch_init): Set mips_ax_pseudo_register_collect and
	mips_ax_pseudo_register_push_stack.
@
text
@d1981 6
@


1.76
log
@2010-05-18  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: White space.
	* ada-typeprint.c: White space.
	* ada-valprint.c: White space.
	* addrmap.c: White space.
	* auxv.c: White space.
	* ax-gdb.c: White space.
@
text
@a1980 4
	if (reg >= gdbarch_num_regs (exp->gdbarch))
	  error (_("'%s' is a pseudo-register; "
		   "GDB cannot yet trace pseudoregister contents."),
		 name);
@


1.76.2.1
log
@Make tracepoint can trace pseudo register.
Add MIPS callbacks.
@
text
@d1981 3
a1983 5
	/* No support for tracing user registers yet.  */
	if (reg >= gdbarch_num_regs (exp->gdbarch)
	    + gdbarch_num_pseudo_regs (exp->gdbarch))
	  error (_("'%s' is a user-register; "
		   "GDB cannot yet trace user-register contents."),
@


1.75
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* ax-gdb.c (gen_struct_elt_for_reference): Delete unused variables.
	* tracepoint.c (delete_trace_variable_command):
	Delete unused variables.
	(encode_actions_1): Delete unused variables.
	(start_tracing): Delete unused variable.
	(trace_status_mi): Delete unused variable.
	(tfind_1): Delete unused variable.
	(trace_find_pc_command): Delete unused variable.
	(trace_find_line_command): Delete unused variables.
	(trace_find_range_command): Delete unused variables.
	(trace_find_outside_command): Delete unused variables.
	(parse_tracepoint_definition): Delete unused variables.
	(tfile_fetch_registers): Delete unused variable.
@
text
@d222 1
d230 1
d458 1
d697 1
d825 1
d1246 1
a1246 2
  =
  {aop_ref8, aop_ref16, aop_ref32, aop_ref64};
d1696 1
d1745 1
d1882 1
d1908 1
d1955 1
d1975 1
d1995 1
d2022 1
d2032 1
@


1.74
log
@2010-04-23  Stan Shebs  <stan@@codesourcery.com>

	* ax.h (struct agent_expr): Merge in agent_reqs fields, add some
	comments.
	(struct agent_reqs): Remove.
	(ax_reg_mask): Declare.
	* ax-general.c (new_agent_expr): Add gdbarch argument, set new fields.
	(free_agent_expr): Free reg_mask.
	(ax_print): Add scope and register mask info.
	(ax_reqs): Remove agent_reqs argument, use agent expression
	fields, and move part of register mask computation to...
	(ax_reg_mask): New function.
	* ax-gdb.c (gen_trace_static_fields): Call it.
	(gen_traced_pop): Ditto.
	(is_nontrivial_conversion): Add dummy gdbarch to new_agent_expr.
	(gen_trace_for_var): Pass gdbarch to new_agent_expr.
	(gen_trace_for_expr): Ditto, and clear optimized_out flag.
	(gen_eval_for_expr): Ditto, and require an rvalue.
	(agent_command): Call ax_reqs.
	(agent_eval_command): Ditto.
	* tracepoint.c (report_agent_reqs_errors): Use agent expression fields.
	(validate_action_line): Ditto.
	(collect_symbol): Ditto.
	(encode_actions_1): Ditto.
@
text
@a1569 1
  struct value *v, *result;
@


1.73
log
@2010-04-20  Stan Shebs  <stan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* dwarf2loc.c (struct axs_var_loc): New struct.
	(dwarf2_tracepoint_var_loc): New function.
	(dwarf2_tracepoint_var_access): New function.
	(dwarf2_tracepoint_var_ref): Use dwarf2_tracepoint_var_loc, deal
	with DW_OP_piece.
	(locexpr_describe_location_piece): New function.
	(locexpr_describe_location_1): New function.
	(locexpr_describe_location): Call it, update signature.
	(loclist_describe_location): Rewrite to loop over locations,
	update signature.
	* symtab.h (struct symbol_computed_ops): Add address to
	describe_location arguments, return void.
	* printcmd.c (address_info): Get context PC, pass to computed
	location description.
	* tracepoint.c (scope_info): Ditto.
	* ax-gdb.c (trace_kludge): Export.
@
text
@d366 3
a368 4
	      /* We need to mention the register somewhere in the bytecode,
		 so ax_reqs will pick it up and add it to the mask of
		 registers used.  */
	      ax_reg (ax, value.u.reg);
d416 5
a420 5
	/* We need to mention the register somewhere in the bytecode,
	   so ax_reqs will pick it up and add it to the mask of
	   registers used.  */
	ax_reg (ax, value->u.reg);
	ax_simple (ax, aop_pop);
d900 1
a900 1
  struct agent_expr *ax = new_agent_expr (0);
d2326 1
a2326 1
  struct agent_expr *ax = new_agent_expr (scope);
d2366 1
a2366 1
  struct agent_expr *ax = new_agent_expr (scope);
d2374 1
d2401 1
a2401 1
  struct agent_expr *ax = new_agent_expr (scope);
d2409 1
d2412 2
d2446 1
d2482 1
@


1.72
log
@2010-03-19  Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.c (gen_fetch): Handle bool.
	(gen_usual_unary): Ditto.
	(gen_cast): Ditto.
	(gen_equal): New function.
	(gen_less): New function.
	(gen_expr_binop_rest): Call them, also return integer type from
	logical operations.
	(gen_expr): Ditto.

	* gdb.trace/ax.exp: New file.
@
text
@d332 1
a332 1
static int trace_kludge;
@


1.71
log
@Fix last checkin
@
text
@d481 1
d835 1
a835 1
      /* If the value is an enum, call it an integer.  */
d837 1
d1003 1
d1101 27
d1766 1
d1828 1
a1828 1
      value->type = language_bool_type (exp->language_defn, exp->gdbarch);
d1847 1
a1847 1
      value->type = language_bool_type (exp->language_defn, exp->gdbarch);
d1858 1
a1858 2
      gen_logical_not (ax, &value1,
		       language_bool_type (exp->language_defn, exp->gdbarch));
d2060 1
a2060 2
      gen_logical_not (ax, value,
		       language_bool_type (exp->language_defn, exp->gdbarch));
d2176 2
d2280 1
a2280 2
      gen_binop (ax, value, value1, value2,
		 aop_equal, aop_equal, 0, "equal");
d2284 2
a2285 5
      gen_binop (ax, value, value1, value2,
		 aop_equal, aop_equal, 0, "equal");
      gen_logical_not (ax, value,
		       language_bool_type (exp->language_defn,
					   exp->gdbarch));
d2289 1
a2289 2
      gen_binop (ax, value, value1, value2,
		 aop_less_signed, aop_less_unsigned, 0, "less than");
d2294 1
a2294 2
      gen_binop (ax, value, value1, value2,
		 aop_less_signed, aop_less_unsigned, 0, "less than");
d2299 2
a2300 5
      gen_binop (ax, value, value1, value2,
		 aop_less_signed, aop_less_unsigned, 0, "less than");
      gen_logical_not (ax, value,
		       language_bool_type (exp->language_defn,
					   exp->gdbarch));
d2304 2
a2305 5
      gen_binop (ax, value, value1, value2,
		 aop_less_signed, aop_less_unsigned, 0, "less than");
      gen_logical_not (ax, value,
		       language_bool_type (exp->language_defn,
					   exp->gdbarch));
@


1.70
log
@2010-03-17 Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.c (require_rvalue): Disallow non-scalars.
@
text
@d755 1
a755 1
    error ("Value not scalar: cannot be an rvalue.");
@


1.69
log
@2010-03-17 Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.h (struct axs_value): New field optimized_out.
	(gen_trace_for_var): Add gdbarch argument.
	* ax-gdb.c (gen_trace_static_fields): New function.
	(gen_traced_pop): Call it, add gdbarch argument.
	(gen_trace_for_expr): Update call to it.
	(gen_trace_for_var): Ditto, and report optimized-out variables.
	(gen_struct_ref_recursive): Check for optimized-out value.
	(gen_struct_elt_for_reference): Ditto.
	(gen_static_field): Pass gdbarch instead of expression, assume
	optimization if field not found.
	(gen_var_ref): Set the optimized_out flag.
	(gen_expr): Error on optimized-out variable.
	* tracepoint.c (collect_symbol): Handle struct-valued vars as
	expressions, skip optimized-out variables with computed locations.
	* dwarf2loc.c (dwarf2_tracepoint_var_ref): Flag instead of
	erroring out if location expression missing.
	(loclist_tracepoint_var_ref): Don't error out here.
@
text
@d748 9
@


1.68
log
@Fix a commit snafu
@
text
@d73 1
a73 1
static void gen_traced_pop (struct agent_expr *, struct axs_value *);
d147 1
a147 1
static void gen_static_field (struct expression *exp,
d334 52
d390 2
a391 1
gen_traced_pop (struct agent_expr *ax, struct axs_value *value)
d427 6
d616 1
d713 3
a715 2
      error (_("The variable `%s' has been optimized out."),
	     SYMBOL_PRINT_NAME (var));
d1406 4
a1409 1
		  gen_static_field (exp, ax, value, type, i);
d1492 1
a1492 1
gen_static_field (struct expression *exp,
d1501 1
a1506 2
      if (sym == NULL)
	error (_("symbol not found"));
d1508 14
a1521 1
      gen_var_ref (exp->gdbarch, ax, value, sym);
d1547 4
a1550 1
	      gen_static_field (exp, ax, value, t, i);
d1608 4
d1901 1
a1901 1
      gen_traced_pop (ax, &value1);
d1917 5
d2095 5
d2295 2
a2296 1
gen_trace_for_var (CORE_ADDR scope, struct symbol *var)
d2305 9
a2313 1
  gen_var_ref (NULL, ax, &value, var);
d2316 1
a2316 1
  gen_traced_pop (ax, &value);
d2350 1
a2350 1
  gen_traced_pop (ax, &value);
@


1.67
log
@2010-03-15 Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.c: Include cp-support.h.
	(find_field): Remove.
	(gen_primitive_field): New function.
	(gen_struct_ref_recursive): New function.
	(gen_struct_ref): Rewrite to call gen_struct_ref_recursive instead
	of find_field.
	(gen_static_field): New function.
	(gen_struct_elt_for_reference): New.
	(gen_namespace_elt): New.
	(gen_maybe_namespace_elt): New.
	(gen_aggregate_elt_ref): New.
	(gen_expr): Add OP_SCOPE, display opcode name in error message.
@
text
@d1522 1
a1522 1
				    VAR_DOMAIN, 0);
@


1.66
log
@2010-03-12 Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.c (gen_expr): Add shift expressions.
	(gen_expr_binop_rest): Ditto.
@
text
@d42 1
a130 1
static int find_field (struct type *type, char *name);
d134 9
d147 3
a1130 40

/* A lot of this stuff will have to change to support C++.  But we're
   not going to deal with that at the moment.  */

/* Find the field in the structure type TYPE named NAME, and return
   its index in TYPE's field array.  */
static int
find_field (struct type *type, char *name)
{
  int i;

  CHECK_TYPEDEF (type);

  /* Make sure this isn't C++.  */
  if (TYPE_N_BASECLASSES (type) != 0)
    internal_error (__FILE__, __LINE__,
		    _("find_field: derived classes supported"));

  for (i = 0; i < TYPE_NFIELDS (type); i++)
    {
      char *this_name = TYPE_FIELD_NAME (type, i);

      if (this_name)
	{
	  if (strcmp (name, this_name) == 0)
	    return i;

	  if (this_name[0] == '\0')
	    internal_error (__FILE__, __LINE__,
			    _("find_field: anonymous unions not supported"));
	}
    }

  error (_("Couldn't find member named `%s' in struct/union `%s'"),
	 name, TYPE_TAG_NAME (type));

  return 0;
}


d1291 84
d1387 1
a1387 1
  int i;
d1410 7
a1416 1
  i = find_field (type, field);
d1418 20
a1437 6
  /* Is this a bitfield?  */
  if (TYPE_FIELD_PACKED (type, i))
    gen_bitfield_ref (exp, ax, value, TYPE_FIELD_TYPE (type, i),
		      TYPE_FIELD_BITPOS (type, i),
		      (TYPE_FIELD_BITPOS (type, i)
		       + TYPE_FIELD_BITSIZE (type, i)));
d1440 41
a1480 3
      gen_offset (ax, TYPE_FIELD_BITPOS (type, i) / TARGET_CHAR_BIT);
      value->kind = axs_lvalue_memory;
      value->type = TYPE_FIELD_TYPE (type, i);
d1482 5
d1489 66
d2011 15
d2030 2
a2031 1
      error (_("Unsupported operator in expression."));
@


1.65
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d1482 2
d1889 8
@


1.64
log
@	* ax-gdb.c (gen_exp_binop_rest) [BINOP_SUBSCRIPT]: Error out if
	the offset value isn't of integral type.
@
text
@d1815 1
a1815 1
	sym = lookup_block_symbol (b, this_name, NULL, VAR_DOMAIN);
@


1.63
log
@	* ax-gdb.c (gen_exp_binop_rest) [BINOP_SUBSCRIPT]: Error out on
	non-subscriptable types.
	* valarith.c (binop_types_user_defined_p): New, abstracted out
	from ...
	(binop_user_defined_p): ... this.
	* value.h (binop_types_user_defined_p): Declare.
@
text
@d1913 3
@


1.62
log
@	* ax-gdb.c (gen_deref): Don't allow dereferencing void pointers.
@
text
@d1888 29
a1916 5
      gen_ptradd (ax, value, value1, value2);
      if (!pointer_type (value->type))
	error (_("Invalid combination of types in array subscripting."));
      gen_deref (ax, value);
      break;
@


1.61
log
@	Add trace file support.
	* tracepoint.h (enum trace_stop_reason): New enum.
	(struct trace_status): New struct.
	(parse_trace_status): Declare.
	(struct uploaded_tp): Move here from remote.c,
	add fields for actions.
	(struct uploaded_tsv): New struct.
	* tracepoint.c (tfile_ops): New target vector.
	(trace_fd): New global.
	(tfile_open): New function.
	(tfile_close): New function.
	(tfile_files_info): New function.
	(tfile_get_trace_status): New function.
	(tfile_get_traceframe_address): New function.
	(tfile_trace_find): New function.
	(tfile_fetch_registers): New function.
	(tfile_xfer_partial): New function.
	(tfile_get_trace_state_variable_value): New function.
	(init_tfile_ops): New function.
	(_initialize_tracepoint): Call it, add tfile target.
	(trace_status): New global.
	(current_trace_status): New function.
	(trace_running_p): Remove, change all users to get from
	current_trace_status()->running.
	(get_trace_status): Remove.
	(trace_status_command): Call target_get_trace_status directly,
	report more detail including tracing stop reasons.
	(trace_find_command): Always allow tfind on a file.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	(trace_frames_offset, cur_offset): Declare as off_t.
	(trace_regblock_size): Rename from reg_size, update users.
	(parse_trace_status): New function.
	(tfile_interp_line): New function.
	(disconnect_or_stop_tracing): Ensure current trace
	status before asking what to do.
	(stop_reason_names): New global.
	(trace_save_command): New command.
	(get_uploaded_tp): Move here from remote.c.
	(find_matching_tracepoint): Ditto.
	(merge_uploaded_tracepoints): New function.
	(parse_trace_status): Use stop_reason_names.
	(_initialize_tracepoint): Define tsave command.
	* target.h (target_ops): New fields to_save_trace_data,
	to_upload_tracepoints, to_upload_trace_state_variables,
	to_get_raw_trace_data, change to_get_trace_status
	to take a pointer to a status struct.
	(target_save_trace_data): New macro.
	(target_upload_tracepoints): New macro.
	(target_upload_trace_state_variables): New macro.
	(target_get_raw_trace_data): New macro.
	* target.c (update_current_target): Add new methods, change
	signature of to_get_trace_status.
	* remote.c (hex2bin): Make globally visible.
	(bin2hex): Ditto.
	(remote_download_trace_state_variable): Download name also.
	(remote_get_trace_status): Update parameter, use
	parse_trace_status.
	(remote_save_trace_data): New function.
	(remote_upload_tracepoints): New function.
	(remote_upload_trace_state_variables): New function.
	(remote_get_raw_trace_data): New function.
	(remote_start_remote): Use them.
	(_initialize_remote_ops): Add operations.
	* ax-gdb.c: Include breakpoint.h.
	* breakpoint.c (create_tracepoint_from_upload): Use
	break_command_really, return tracepoint, warn about unimplemented
	parts.
	* NEWS: Mention trace file addition.

	* gdb.texinfo (Trace Files): New section.
	(Tracepoint Packets): Document QTSave and qTBuffer.
	(Trace File Format): New appendix.

	* generic/gdbtk-bp.c (gdb_trace_status): Use current_trace_status.

	* gdb.trace/tfile.c: New file.
	* gdb.trace/tfile.exp: New file.
@
text
@d1085 2
@


1.60
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d40 1
@


1.59
log
@	* language.c (pointer_type): Un-comment out.
	* ax-gdb.c: Include language.h, use pointer_type throughout
	instead of testing TYPE_CODE_PTR.
	(gen_fetch): Include TYPE_CODE_REF.
	(gen_cast): Ditto.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2007, 2008, 2009
@


1.58
log
@	* ax-gdb.c (gen_expr): Handle logical and, logical or, and
	conditional expressions.
@
text
@d25 1
d405 1
d906 1
d967 1
a967 1
  gdb_assert (TYPE_CODE (value1->type) == TYPE_CODE_PTR);
d983 1
a983 1
  gdb_assert (TYPE_CODE (value1->type) == TYPE_CODE_PTR);
d1000 2
a1001 2
  gdb_assert (TYPE_CODE (value1->type) == TYPE_CODE_PTR);
  gdb_assert (TYPE_CODE (value2->type) == TYPE_CODE_PTR);
d1074 1
a1074 1
  if (TYPE_CODE (value->type) != TYPE_CODE_PTR)
d1333 1
a1333 1
  while (TYPE_CODE (value->type) == TYPE_CODE_PTR)
d1759 1
a1759 1
      if (TYPE_CODE (value->type) != TYPE_CODE_PTR)
d1846 1
a1846 1
	  && TYPE_CODE (value2->type) == TYPE_CODE_PTR)
d1852 1
a1852 1
      else if (TYPE_CODE (value1->type) == TYPE_CODE_PTR
d1860 1
a1860 1
      if (TYPE_CODE (value1->type) == TYPE_CODE_PTR
d1863 2
a1864 2
      else if (TYPE_CODE (value1->type) == TYPE_CODE_PTR
	       && TYPE_CODE (value2->type) == TYPE_CODE_PTR)
d1886 1
a1886 1
      if (TYPE_CODE (value->type) != TYPE_CODE_PTR)
@


1.57
log
@2009-12-28  Stan Shebs  <stan@@codesourcery.com>

	Add trace state variables.
	* ax.h (enum agent_op): Add getv, setv, and tracev.
	(ax_tsv): Declare.
	* ax-gdb.c: Include tracepoint.h.
	(gen_expr): Handle BINOP_ASSIGN, BINOP_ASSIGN_MODIFY, and
	OP_INTERNALVAR.
	(gen_expr_binop_rest): New function, split from gen_expr.
	* ax-general.c (ax_tsv): New function.
	(aop_map): Add new bytecodes.
	* tracepoint.h (struct trace_state_variable): New struct.
	(tsv_s): New typedef.
	(find_trace_state_variable): Declare.
	* tracepoint.c (tvariables): New global.
	(next_tsv_number): New global.
	(create_trace_state_variable): New function.
	(find_trace_state_variable): New function.
	(delete_trace_state_variable): New function.
	(trace_variable_command): New function.
	(delete_trace_variable_command): New function.
	(tvariables_info): New function.
	(trace_start_command): Download tsvs with initial values.
	(_initialize_tracepoint): Add new commands.
	* NEWS: Mention the addition of trace state variables.

==> doc/ChangeLog <==
2009-12-28  Stan Shebs  <stan@@codesourcery.com>

	* gdb.texinfo (Trace State Variables): New section.
	(Tracepoint Packets): Describe trace state variable packets.
	* agentexpr.texi (Bytecode Descriptions): Describe trace state
	variable bytecodes.

==> testsuite/ChangeLog <==
2009-12-28  Stan Shebs  <stan@@codesourcery.com>

	* gdb.trace/tsv.exp: New file.
	* gdb.base/completion.exp: Update ambiguous info output.
@
text
@d1450 1
a1450 1
  struct axs_value value1, value2;
d1452 1
d1492 65
@


1.56
log
@	* ax-gdb.c (gen_expr) <OP_THIS>: Lookup `this' in the context of
	the tracepoint, not of the selected frame and language.
@
text
@d39 1
d143 6
d1451 1
a1451 1
  enum exp_opcode op = (*pc)[0].opcode;
d1488 6
a1493 4
      gen_expr (exp, pc, ax, &value2);
      gen_usual_unary (exp, ax, &value2);
      gen_usual_arithmetic (exp, ax, &value1, &value2);
      switch (op)
d1495 6
a1500 3
	case BINOP_ADD:
	  if (TYPE_CODE (value1.type) == TYPE_CODE_INT
	      && TYPE_CODE (value2.type) == TYPE_CODE_PTR)
d1502 3
a1504 3
	      /* Swap the values and proceed normally.  */
	      ax_simple (ax, aop_swap);
	      gen_ptradd (ax, value, &value2, &value1);
a1505 3
	  else if (TYPE_CODE (value1.type) == TYPE_CODE_PTR
		   && TYPE_CODE (value2.type) == TYPE_CODE_INT)
	    gen_ptradd (ax, value, &value1, &value2);
d1507 33
a1539 12
	    gen_binop (ax, value, &value1, &value2,
		       aop_add, aop_add, 1, "addition");
	  break;
	case BINOP_SUB:
	  if (TYPE_CODE (value1.type) == TYPE_CODE_PTR
	      && TYPE_CODE (value2.type) == TYPE_CODE_INT)
	    gen_ptrsub (ax,value, &value1, &value2);
	  else if (TYPE_CODE (value1.type) == TYPE_CODE_PTR
		   && TYPE_CODE (value2.type) == TYPE_CODE_PTR)
	    /* FIXME --- result type should be ptrdiff_t */
	    gen_ptrdiff (ax, value, &value1, &value2,
		         builtin_type (exp->gdbarch)->builtin_long);
d1541 1
a1541 82
	    gen_binop (ax, value, &value1, &value2,
		       aop_sub, aop_sub, 1, "subtraction");
	  break;
	case BINOP_MUL:
	  gen_binop (ax, value, &value1, &value2,
		     aop_mul, aop_mul, 1, "multiplication");
	  break;
	case BINOP_DIV:
	  gen_binop (ax, value, &value1, &value2,
		     aop_div_signed, aop_div_unsigned, 1, "division");
	  break;
	case BINOP_REM:
	  gen_binop (ax, value, &value1, &value2,
		     aop_rem_signed, aop_rem_unsigned, 1, "remainder");
	  break;
	case BINOP_SUBSCRIPT:
	  gen_ptradd (ax, value, &value1, &value2);
	  if (TYPE_CODE (value->type) != TYPE_CODE_PTR)
	    error (_("Invalid combination of types in array subscripting."));
	  gen_deref (ax, value);
	  break;
	case BINOP_BITWISE_AND:
	  gen_binop (ax, value, &value1, &value2,
		     aop_bit_and, aop_bit_and, 0, "bitwise and");
	  break;

	case BINOP_BITWISE_IOR:
	  gen_binop (ax, value, &value1, &value2,
		     aop_bit_or, aop_bit_or, 0, "bitwise or");
	  break;

	case BINOP_BITWISE_XOR:
	  gen_binop (ax, value, &value1, &value2,
		     aop_bit_xor, aop_bit_xor, 0, "bitwise exclusive-or");
	  break;

	case BINOP_EQUAL:
	  gen_binop (ax, value, &value1, &value2,
		     aop_equal, aop_equal, 0, "equal");
	  break;

	case BINOP_NOTEQUAL:
	  gen_binop (ax, value, &value1, &value2,
		     aop_equal, aop_equal, 0, "equal");
	  gen_logical_not (ax, value,
			   language_bool_type (exp->language_defn,
					       exp->gdbarch));
	  break;

	case BINOP_LESS:
	  gen_binop (ax, value, &value1, &value2,
		     aop_less_signed, aop_less_unsigned, 0, "less than");
	  break;

	case BINOP_GTR:
	  ax_simple (ax, aop_swap);
	  gen_binop (ax, value, &value1, &value2,
		     aop_less_signed, aop_less_unsigned, 0, "less than");
	  break;

	case BINOP_LEQ:
	  ax_simple (ax, aop_swap);
	  gen_binop (ax, value, &value1, &value2,
		     aop_less_signed, aop_less_unsigned, 0, "less than");
	  gen_logical_not (ax, value,
			   language_bool_type (exp->language_defn,
					       exp->gdbarch));
	  break;

	case BINOP_GEQ:
	  gen_binop (ax, value, &value1, &value2,
		     aop_less_signed, aop_less_unsigned, 0, "less than");
	  gen_logical_not (ax, value,
			   language_bool_type (exp->language_defn,
					       exp->gdbarch));
	  break;

	default:
	  /* We should only list operators in the outer case statement
	     that we actually handle in the inner case statement.  */
	  internal_error (__FILE__, __LINE__,
			  _("gen_expr: op case sets don't match"));
d1543 2
d1598 18
a1615 1
      error (_("GDB agent expressions cannot use convenience variables."));
d1759 125
@


1.55
log
@2009-12-23  Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.c (gen_expr): Handle OP_THIS.
@
text
@d1765 1
a1765 2
	char *name;
	struct frame_info *frame;
d1769 2
a1770 10
	name = current_language->la_name_of_this;
	if (!name)
	  error (_("no `this' in current language"));

	frame = get_selected_frame (_("no frame selected"));

	func = get_frame_function (frame);
	if (!func)
	  error (_("no `%s' in nameless context"), name);

a1771 2
	if (dict_empty (BLOCK_DICT (b)))
	  error (_("no args, no `%s' in block"), name);
d1775 1
a1775 1
	sym = lookup_block_symbol (b, name, NULL, VAR_DOMAIN);
d1777 1
a1777 1
	  error (_("no `%s' found"), name);
@


1.54
log
@2009-12-23  Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.h (gen_trace_for_var): Declare.
	* ax-gdb.c (gen_trace_for_var): New function.
	* dwarf2loc.c (dwarf_expr_frame_base_1): New function, split from...
	(dwarf_expr_frame_base): ...here.
	(dwarf2_tracepoint_var_ref): Add computed location case.
	* tracepoint.c (collect_symbol): Add scope arg and LOC_COMPUTED
	case.
	(add_local_symbols): Update call to collect_symbol.
	(encode_actions): Ditto.
@
text
@d38 1
d1763 32
@


1.53
log
@	gdb/
	Conditional tracepoints.
	* ax-gdb.h (gen_eval_for_expr): Declare.
	* ax-gdb.c (gen_expr): Generate bytecodes for BINOP_EQUAL
	and other comparisons.
	(gen_eval_for_expr): New function.
	(agent_eval_command): New maintenance command.
	(_initialize_ax_gdb): Define the command.
	* remote.c (struct remote_state): New field cond_tracepoints.
	(PACKET_ConditionalTracepoints): New packet config type.
	(remote_cond_tracepoint_feature): New function.
	(remote_protocol_features): Add ConditionalTracepoints.
	(remote_supports_cond_tracepoints): New function.
	(_initialize_remote): Add ConditionalTracepoints.
	* tracepoint.c (download_tracepoint): Add conditional.
	* NEWS: Mention conditional tracepoints.

	gdb/doc/
	* gdb.texinfo (Tracepoint Conditions): New section.
	(General Query Packets): Describe ConditionalTracepoints.
	(Tracepoint Packets): Describe condition field.
	(Maintenance Commands): Describe maint agent-eval.
	* agentexpr.texi (Using Agent Expressions): Mention eval usage.

	gdb/testsuite/
	* gdb.trace/tracecmd.exp: Add basic test of tracepoint conditions.
@
text
@d1771 29
@


1.52
log
@	* ada-lang.c (assign_component): Use platform-specific integer type
	instead of builtin_type_int32 type.
	(ada_evaluate_subexp) [OP_ATR_SIZE]: Likewise.

	* ax-gdb.c (gen_expr) [UNOP_NEG]: Use platform-specific integer type
	instead of builtin_type_int8 type.
	* valarith.c (value_x_unop): Likewise.
	* python/python-value.c (valpy_absolute): Avoid reference to
	builtin_type_int8 type.

	* eval.c (evaluate_subexp_standard): Use platform-specific integer
	type instead of builtin_type_int8 as EVAL_SKIP return value type.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
	* jv-lang.c (evaluate_subexp_java): Likewise.
	* m2-lang.c (evaluate_subexp_modula2): Likewise.
	* scm-lang.c (evaluate_exp): Likewise.

	* value.h (value_bitstring): Add INDEX_TYPE argument.
	* valops.c (value_bitstring): Add INDEX_TYPE argument, use it instead
	of builtin_type_int32 as base range type.
	* eval.c (evaluate_subexp_standard): Update value_bitstring call.
@
text
@d1471 6
d1546 41
d1806 31
d1867 35
d1911 5
a1915 1
	   _("Translate an expression into remote agent bytecode."),
@


1.51
log
@	* gdbtypes.c (lookup_array_range_type): Add prototype.
	(lookup_string_range_type): Likewise.
	* gdbtypes.c (lookup_array_range_type): New function.
	(lookup_string_range_type): Likewise.

	* ax-gdb.c (gen_repeat): Use lookup_array_range_type.
	* parse.c (follow_types): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
	* value.c (allocate_repeat_value): Likewise.
	* valops.c (value_array, value_cstring): Likewise.
	* valops.c (value_string): Use lookup_string_range_type.
@
text
@d1645 2
a1646 1
      gen_int_literal (ax, &value1, (LONGEST) 0, builtin_type_int8);
@


1.50
log
@	* ax-gdb.c (gen_bitfield_ref): Add EXP argument, use expression
	architecture instead of current_gdbarch.
	(gen_struct_ref): Add EXP argument, pass to get_bitfield_ref.
	(gen_expr): Pass expression to get_struct_ref.

	* symtab.h (struct symbol_ops): Add GDBARCH parameter to
	tracepoint_var_ref callback.
	* ax-gdb.c (gen_var_ref): Pass architecture to tracepoint_var_ref
	symbol operation callback.
	* dwarf2loc.c (dwarf2_tracepoint_var_ref): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	(locexpr_tracepoint_var_ref): Add GDBARCH parameter.  Pass it to
	dwarf2_tracepoint_var_ref.
	(loclist_tracepoint_var_ref): Likewise.
@
text
@d1397 2
a1398 3
      struct type *range
      = create_range_type (0, builtin_type_int32, 0, length - 1);
      struct type *array = create_array_type (0, value1.type, range);
@


1.49
log
@	* symtab.h: Rename SYMBOL_OPS to SYMBOL_COMPUTED_OPS.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value, symbol_read_needs_frame): Likewise.
	* printcmd.c (address_info): Likewise.
	* dwarf2loc.c (dwarf_expr_frame_base): Likewise.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Likewise.
	* symtab.h: Rename struct symbol_ops to struct symbol_computed_ops.
	* dwarf2loc.h: Likewise.
	* dwarf2loc.c (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Likewise.

	* symtab.h: (struct symbol_register_ops): New struct definition.
	(struct symbol): Make "ops" member a union of symbol_computed_ops and
	symbol_register_ops callback pointers.
	(SYMBOL_REGISTER_OPS): New macro.
	* tracepoint.c: Include "objfiles.h".
	(scope_info, collect_symbol): Use SYMBOL_REGISTER_OPS register_number
	callback to retrieve register numbers.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value): Likewise.
	* printcmd.c (address_info): Likewise.

	* coffread.c (coff_reg_to_regnum): New function.
	(coff_register_funcs): New static variable.
	(process_coff_symbol): Do not call gdbarch_sdb_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* mdebugread.c (mdebug_reg_to_regnum): New function.
	(mdebug_register_funcs): New static variable.
	(parse_symbol): Do not call gdbarch_ecoff_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* stabsread.c (stab_reg_to_regnum): New function.
	(stab_register_funcs): New static variable.
	(define_symbol): Do not call gdbarch_stab_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
@
text
@d127 1
a127 1
static void gen_bitfield_ref (struct agent_expr *ax,
d130 1
a130 1
static void gen_struct_ref (struct agent_expr *ax,
d626 1
a626 1
      SYMBOL_COMPUTED_OPS (var)->tracepoint_var_ref (var, ax, value);
d1150 3
a1152 2
gen_bitfield_ref (struct agent_expr *ax, struct axs_value *value,
		  struct type *type, int start, int end)
d1278 1
a1278 1
	  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1312 2
a1313 1
gen_struct_ref (struct agent_expr *ax, struct axs_value *value, char *field,
d1344 1
a1344 1
    gen_bitfield_ref (ax, value, TYPE_FIELD_TYPE (type, i),
d1703 1
a1703 1
	  gen_struct_ref (ax, value, name, ".", "structure or union");
d1705 1
a1705 1
	  gen_struct_ref (ax, value, name, "->",
@


1.48
log
@        Updated copyright notices for most files.
@
text
@d595 1
a595 1
      value->u.reg = SYMBOL_VALUE (var);
d603 1
a603 1
      ax_reg (ax, SYMBOL_VALUE (var));
d622 1
a622 1
	 unconditionally call the SYMBOL_OPS method when available.
d626 1
a626 1
      SYMBOL_OPS (var)->tracepoint_var_ref (var, ax, value);
@


1.47
log
@	* ax-gdb.c: Include "language.h".
	(gen_frame_args_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	(gen_frame_locals_address): Likewise.
	(gen_var_ref): Add GDBARCH parameter.  Update calls to
	gen_frame_args_address and gen_frame_locals_address.  Use
	pointer type from gdbarch.
	(gen_usual_unary): Add EXP parameter.  Use integer type
	from exp->gdbarch.
	(gen_usual_arithmetic): Likewise.
	(gen_integral_promotions): Likewise.
	(gen_add, gen_sub): Remove.
	(gen_ptradd, gen_ptrsub, gen_ptrdiff): New functions.
	(gen_logical_not): Use passed-in boolean result type
	instead of builtin_type_int.
	(gen_complement): Do not call gen_usual_unary or
	gen_integral_promotions.
	(gen_struct_ref): Call require_rvalue instead of gen_usual_unary.
	(gen_repeat): Add EXP parameter.  Update call to gen_expr.
	Use builtin_type_int32 as internal range type.
	(gen_sizeof): Add EXP and SIZE_TYPE parameters.  Use SIZE_TYPE
	as result type.  Update call to gen_expr.
	(gen_expr): Add EXP parameter.  Update calls to gen_expr,
	gen_repeat, gen_var_ref, gen_usual_unary, gen_usual_arithmetic,
	and gen_integral_promotions.  Call gen_ptradd, gen_ptrsub,
	gen_ptrdiff, or gen_binop instead of gen_add or gen_sub.
	Use exp->gdbarch instead of current_gdbarch.
	Call language_bool_type to determine result type of UNOP_LOGICAL_NOT.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2007, 2008
@


1.46
log
@	* frame.h (frame_map_regnum_to_name): Remove prototype.
	(frame_map_name_to_regnum): Remove prototype.
	* frame.c (frame_map_regnum_to_name): Remove.
	(frame_map_name_to_regnum): Remove.
	(frame_unwind_register_value): Use user_reg_map_regnum_to_name
	instead of frame_map_regnum_to_name.
	* ax-gdb.c: Include "user-regs.h".
	(gen_expr): Use user_reg_map_name_to_regnum instead of
	frame_map_name_to_regnum.
	* eval.c:  Include "user-regs.h".
	(evaluate_subexp_standard): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* infcmd.c (registers_info): Likewise.
	* parse.c: Include "user-regs.h".
	(write_dollar_variable): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* tracepoint.c: Include "user-regs.h".
	(encode_actions): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* valops.c: Include "user-regs.h".
	(value_fetch_lazy): Use user_reg_map_regnum_to_name instead
	of frame_map_regnum_to_name.
@
text
@d37 1
d76 2
a77 2
static void gen_frame_args_address (struct agent_expr *);
static void gen_frame_locals_address (struct agent_expr *);
d80 1
a80 1
static void gen_var_ref (struct agent_expr *ax,
d90 2
a91 1
static void gen_usual_unary (struct agent_expr *ax, struct axs_value *value);
d97 2
a98 1
static void gen_usual_arithmetic (struct agent_expr *ax,
d101 2
a102 1
static void gen_integral_promotions (struct agent_expr *ax,
d108 7
a114 7
static void gen_add (struct agent_expr *ax,
		     struct axs_value *value,
		     struct axs_value *value1,
		     struct axs_value *value2, char *name);
static void gen_sub (struct agent_expr *ax,
		     struct axs_value *value,
		     struct axs_value *value1, struct axs_value *value2);
d121 2
a122 1
static void gen_logical_not (struct agent_expr *ax, struct axs_value *value);
d134 1
a134 1
static void gen_repeat (union exp_element **pc,
d136 4
a139 3
static void gen_sizeof (union exp_element **pc,
			struct agent_expr *ax, struct axs_value *value);
static void gen_expr (union exp_element **pc,
d464 1
a464 1
gen_frame_args_address (struct agent_expr *ax)
d469 1
a469 1
  gdbarch_virtual_frame_pointer (current_gdbarch,
d479 1
a479 1
gen_frame_locals_address (struct agent_expr *ax)
d484 1
a484 1
  gdbarch_virtual_frame_pointer (current_gdbarch,
d529 2
a530 1
gen_var_ref (struct agent_expr *ax, struct axs_value *value, struct symbol *var)
d560 1
a560 1
      gen_frame_args_address (ax);
d567 1
a567 1
      gen_frame_args_address (ax);
d570 1
a570 1
      gen_fetch (ax, lookup_pointer_type (builtin_type_void));
d575 1
a575 1
      gen_frame_locals_address (ax);
d707 2
a708 1
gen_usual_unary (struct agent_expr *ax, struct axs_value *value)
d743 1
a743 1
      value->type = builtin_type_int;
d828 2
a829 2
gen_usual_arithmetic (struct agent_expr *ax, struct axs_value *value1,
		      struct axs_value *value2)
d840 1
a840 1
      struct type *target = max_type (builtin_type_int,
d865 2
a866 1
gen_integral_promotions (struct agent_expr *ax, struct axs_value *value)
d868 3
a870 1
  if (!type_wider_than (value->type, builtin_type_int))
d872 2
a873 2
      gen_conversion (ax, value->type, builtin_type_int);
      value->type = builtin_type_int;
d875 1
a875 1
  else if (!type_wider_than (value->type, builtin_type_unsigned_int))
d877 2
a878 2
      gen_conversion (ax, value->type, builtin_type_unsigned_int);
      value->type = builtin_type_unsigned_int;
d951 1
a951 5
/* Generate code for an addition; non-trivial because we deal with
   pointer arithmetic.  We set VALUE to describe the result value; we
   assume VALUE1 and VALUE2 describe the two operands, and that
   they've undergone the usual binary conversions.  Used by both
   BINOP_ADD and BINOP_SUBSCRIPT.  NAME is used in error messages.  */
d953 2
a954 2
gen_add (struct agent_expr *ax, struct axs_value *value,
	 struct axs_value *value1, struct axs_value *value2, char *name)
d956 2
a957 11
  /* Is it INT+PTR?  */
  if (TYPE_CODE (value1->type) == TYPE_CODE_INT
      && TYPE_CODE (value2->type) == TYPE_CODE_PTR)
    {
      /* Swap the values and proceed normally.  */
      ax_simple (ax, aop_swap);
      gen_scale (ax, aop_mul, value2->type);
      ax_simple (ax, aop_add);
      gen_extend (ax, value2->type);	/* Catch overflow.  */
      value->type = value2->type;
    }
d959 6
a964 9
  /* Is it PTR+INT?  */
  else if (TYPE_CODE (value1->type) == TYPE_CODE_PTR
	   && TYPE_CODE (value2->type) == TYPE_CODE_INT)
    {
      gen_scale (ax, aop_mul, value1->type);
      ax_simple (ax, aop_add);
      gen_extend (ax, value1->type);	/* Catch overflow.  */
      value->type = value1->type;
    }
a965 9
  /* Must be number + number; the usual binary conversions will have
     brought them both to the same width.  */
  else if (TYPE_CODE (value1->type) == TYPE_CODE_INT
	   && TYPE_CODE (value2->type) == TYPE_CODE_INT)
    {
      ax_simple (ax, aop_add);
      gen_extend (ax, value1->type);	/* Catch overflow.  */
      value->type = value1->type;
    }
d967 7
a973 2
  else
    error (_("Invalid combination of types in %s."), name);
d975 4
d983 1
a983 4
/* Generate code for an addition; non-trivial because we have to deal
   with pointer arithmetic.  We set VALUE to describe the result
   value; we assume VALUE1 and VALUE2 describe the two operands, and
   that they've undergone the usual binary conversions.  */
d985 10
a994 27
gen_sub (struct agent_expr *ax, struct axs_value *value,
	 struct axs_value *value1, struct axs_value *value2)
{
  if (TYPE_CODE (value1->type) == TYPE_CODE_PTR)
    {
      /* Is it PTR - INT?  */
      if (TYPE_CODE (value2->type) == TYPE_CODE_INT)
	{
	  gen_scale (ax, aop_mul, value1->type);
	  ax_simple (ax, aop_sub);
	  gen_extend (ax, value1->type);	/* Catch overflow.  */
	  value->type = value1->type;
	}

      /* Is it PTR - PTR?  Strictly speaking, the types ought to
         match, but this is what the normal GDB expression evaluator
         tests for.  */
      else if (TYPE_CODE (value2->type) == TYPE_CODE_PTR
	       && (TYPE_LENGTH (TYPE_TARGET_TYPE (value1->type))
		   == TYPE_LENGTH (TYPE_TARGET_TYPE (value2->type))))
	{
	  ax_simple (ax, aop_sub);
	  gen_scale (ax, aop_div_unsigned, value1->type);
	  value->type = builtin_type_long;	/* FIXME --- should be ptrdiff_t */
	}
      else
	error (_("\
a996 13
    }

  /* Must be number + number.  */
  else if (TYPE_CODE (value1->type) == TYPE_CODE_INT
	   && TYPE_CODE (value2->type) == TYPE_CODE_INT)
    {
      ax_simple (ax, aop_sub);
      gen_extend (ax, value1->type);	/* Catch overflow.  */
      value->type = value1->type;
    }

  else
    error (_("Invalid combination of types in subtraction."));
d998 3
d1004 1
d1031 2
a1032 1
gen_logical_not (struct agent_expr *ax, struct axs_value *value)
a1037 1
  gen_usual_unary (ax, value);
d1039 1
a1039 1
  value->type = builtin_type_int;
a1048 2
  gen_usual_unary (ax, value);
  gen_integral_promotions (ax, value);
d1322 1
a1322 1
      gen_usual_unary (ax, value);
d1367 2
a1368 2
gen_repeat (union exp_element **pc, struct agent_expr *ax,
	    struct axs_value *value)
d1373 1
a1373 1
  gen_expr (pc, ax, &value1);
d1396 1
a1396 1
      = create_range_type (0, builtin_type_int, 0, length - 1);
d1410 3
a1412 2
gen_sizeof (union exp_element **pc, struct agent_expr *ax,
	    struct axs_value *value)
d1420 1
a1420 1
  gen_expr (pc, ax, value);
d1427 1
a1427 1
  value->type = builtin_type_int;
d1437 2
a1438 2
gen_expr (union exp_element **pc, struct agent_expr *ax,
	  struct axs_value *value)
d1471 5
a1475 5
      gen_expr (pc, ax, &value1);
      gen_usual_unary (ax, &value1);
      gen_expr (pc, ax, &value2);
      gen_usual_unary (ax, &value2);
      gen_usual_arithmetic (ax, &value1, &value2);
d1479 13
a1491 1
	  gen_add (ax, value, &value1, &value2, "addition");
d1494 11
a1504 1
	  gen_sub (ax, value, &value1, &value2);
d1519 1
a1519 1
	  gen_add (ax, value, &value1, &value2, "array subscripting");
d1555 1
a1555 1
      gen_expr (pc, ax, &value1);
d1560 1
a1560 1
      gen_expr (pc, ax, value);
d1574 1
a1574 1
      gen_var_ref (ax, value, (*pc)[2].symbol);
d1583 1
a1583 2
	reg = user_reg_map_name_to_regnum (current_gdbarch,
					   name, strlen (name));
d1587 1
a1587 1
	if (reg >= gdbarch_num_regs (current_gdbarch))
d1593 1
a1593 1
	value->type = register_type (current_gdbarch, reg);
d1604 1
a1604 1
      gen_repeat (pc, ax, value);
d1611 1
a1611 1
	gen_expr (pc, ax, value);
d1620 1
a1620 1
	gen_expr (pc, ax, value);
d1637 2
a1638 2
      gen_expr (pc, ax, value);
      gen_usual_unary (ax, value);
d1644 6
a1649 6
      gen_int_literal (ax, &value1, (LONGEST) 0, builtin_type_int);
      gen_usual_unary (ax, &value1);	/* shouldn't do much */
      gen_expr (pc, ax, &value2);
      gen_usual_unary (ax, &value2);
      gen_usual_arithmetic (ax, &value1, &value2);
      gen_sub (ax, value, &value1, &value2);
d1654 4
a1657 2
      gen_expr (pc, ax, value);
      gen_logical_not (ax, value);
d1662 3
a1664 1
      gen_expr (pc, ax, value);
d1670 2
a1671 2
      gen_expr (pc, ax, value);
      gen_usual_unary (ax, value);
d1679 1
a1679 1
      gen_expr (pc, ax, value);
d1688 2
a1689 1
      gen_sizeof (pc, ax, value);
d1699 1
a1699 1
	gen_expr (pc, ax, value);
d1742 1
a1742 1
  gen_expr (&pc, ax, &value);
@


1.45
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d36 1
d1596 2
a1597 2
	reg = frame_map_name_to_regnum (deprecated_safe_get_selected_frame (),
					name, strlen (name));
@


1.44
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@d602 1
a602 1
	= lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (var), NULL, NULL);
@


1.43
log
@	* symtab.h (enum address_class): Remove LOC_BASEREG and
	LOC_BASEREG_ARG.
	(struct symbol): Remove "basereg" member of "aux_value" union.
	(SYMBOL_BASEREG): Remove.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_BASEREG
	or LOC_BASEREG_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsym.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals): Likewise.
	(print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a582 1
    case LOC_REGPARM:
d591 3
a593 3
         register, not on the stack.  Simpler than LOC_REGISTER and
         LOC_REGPARM, because it's just like any other case where the
         thing has a real address.  */
a612 1
    case LOC_COMPUTED_ARG:
@


1.42
log
@	* symtab.h (enum address_class): Remove LOC_LOCAL_ARG.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_LOCAL_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsyms.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a571 7
    case LOC_BASEREG:		/* relative to some base register */
    case LOC_BASEREG_ARG:
      ax_reg (ax, SYMBOL_BASEREG (var));
      gen_sym_offset (ax, var);
      value->kind = axs_lvalue_memory;
      break;

@


1.41
log
@* ax-gdb.c (gen_expr): Yield ordinary error if asked to trace a
pseudoregister, not an internal error.
@
text
@a566 1
    case LOC_LOCAL_ARG:
@


1.40
log
@	Updated copyright notices for most files.
@
text
@d1610 4
@


1.39
log
@* ax-gdb.c (expr_to_agent): Delete unused function.
(expr_to_address_and_size): Delete #if 0'd function.
* ax-gdb.h (expr_to_agent): Delete declaration.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2007
@


1.38
log
@* ax-gdb.c (gen_cast): Remove redundant assignment to
value->type.  Doc fix.
@
text
@a1738 50
/* Given a GDB expression EXPR, produce a string of agent bytecode
   which computes its value.  Return the agent expression, and set
   *VALUE to describe its type, and whether it's an lvalue or rvalue.  */
struct agent_expr *
expr_to_agent (struct expression *expr, struct axs_value *value)
{
  struct cleanup *old_chain = 0;
  struct agent_expr *ax = new_agent_expr (0);
  union exp_element *pc;

  old_chain = make_cleanup_free_agent_expr (ax);

  pc = expr->elts;
  trace_kludge = 0;
  gen_expr (&pc, ax, value);

  /* We have successfully built the agent expr, so cancel the cleanup
     request.  If we add more cleanups that we always want done, this
     will have to get more complicated.  */
  discard_cleanups (old_chain);
  return ax;
}


#if 0				/* not used */
/* Given a GDB expression EXPR denoting an lvalue in memory, produce a
   string of agent bytecode which will leave its address and size on
   the top of stack.  Return the agent expression.

   Not sure this function is useful at all.  */
struct agent_expr *
expr_to_address_and_size (struct expression *expr)
{
  struct axs_value value;
  struct agent_expr *ax = expr_to_agent (expr, &value);

  /* Complain if the result is not a memory lvalue.  */
  if (value.kind != axs_lvalue_memory)
    {
      free_agent_expr (ax);
      error (_("Expression does not denote an object in memory."));
    }

  /* Push the object's size on the stack.  */
  ax_const_l (ax, TYPE_LENGTH (value.type));

  return ax;
}
#endif

@


1.37
log
@* ax-general.c (gen_traced_pop, gen_int_literal)
(gen_usual_arithmetic): Check for typedefs.
@
text
@d908 2
a909 3
         way for us to actually know what GCC actually does with a
         cast like this?  */
      value->type = type;
@


1.36
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d322 1
a322 1
	  int length = TYPE_LENGTH (value->type);
d653 1
a653 1
  value->type = type;
d857 1
a857 1
      value1->type = value2->type = target;
@


1.35
log
@2007-07-24  Michael Snyder  <msnyder@@access-company.com>

	* ax-gdb.c (find_field): Guard against null ptr.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.34
log
@	* expression.h (enum exp_opcode): Document a register name for
	OP_REGISTER.
	* parse.c (write_dollar_variable): Write the register name for
	OP_REGISTER.
	(operator_length_standard): Expect the register name following
	OP_REGISTER.
	* ada-lang.c (resolve_subexp): Likewise.
	* ax-gdb.c (gen_expr): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* expprint.c (print_subexp_standard, dump_subexp_body_standard):
	Likewise.
	* tracepoint.c (encode_actions): Likewise.
@
text
@d1175 4
a1178 2
      if (this_name && strcmp (name, this_name) == 0)
	return i;
d1180 4
a1183 3
      if (this_name[0] == '\0')
	internal_error (__FILE__, __LINE__,
			_("find_field: anonymous unions not supported"));
@


1.33
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_VIRTUAL_FRAME_POINTER): Replace by
	gdbarch_virtual_frame_pointer.
	* tracepoint.c (encode_actions): Likewise.
	* dwarf2loc.c (dwarf2_loc_desc_needs_frame): Likewise.
	* ax-gdb.c (gen_frame_args_address, gen_frame_locals_address): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1602 8
a1609 2
	int reg = (int) (*pc)[1].longconst;
	(*pc) += 3;
@


1.32
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_BYTE_ORDER): Replace by gdbarch_byte_order.
	* ax-gdb.c (gen_bitfield_ref): Likewise.
	* mi/mi-main.c (get_register): Likewise.
	* findvar.c (default_value_from_register, extract_signed_integer)
	(extract_unsigned_integer, extract_long_unsigned_integer)
	(store_signed_integer, store_unsigned_integer): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* value.c (lookup_internalvar, value_of_internalvar)
	(set_internalvar): Likewise.
	* defs.h: Likewise.
	* valprint.c (print_binary_chars, print_octal_chars)
	(print_decimal_chars, print_hex_chars, print_char_chars): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* arch-utils.c (selected_byte_order, show_endian): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* doublest.c (floatformat_from_length, floatformat_from_type)
	(extract_typed_floating, store_typed_floating): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d464 2
a465 1
  TARGET_VIRTUAL_FRAME_POINTER (ax->scope, &frame_reg, &frame_offset);
d479 2
a480 1
  TARGET_VIRTUAL_FRAME_POINTER (ax->scope, &frame_reg, &frame_offset);
@


1.31
log
@Copyright updates for 2007.
@
text
@d1320 1
a1320 1
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
@


1.30
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software Foundation,
   Inc.
@


1.29
log
@	* ax-gdb.c (gen_expr): Add UNOP_PLUS case.
	* c-exp.y (exp): Add unary plus.
	* eval.c (evaluate_subexp_standard): Add UNOP_PLUS case.
	* valarith.c (value_x_unop): Add UNOP_PLUS case.
	(value_pos): New.
	* value.h (value_pos): Declare.

	* gdb.cp/userdef.cc (A1::operator+): New unary plus.
	(A2): New class.
	(main): Test operator+.
	* gdb.cp/userdef.exp: Test unary plus.  Use A2::operator+ for
	breakpoint test.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2003 Free Software Foundation,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.28
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (deprecated_set_value_type): Declare.
	* value.c (deprecated_set_value_type): Define.
	* hpacc-abi.c, gnu-v2-abi.c, cp-valprint.c: Update.
	* c-valprint.c, jv-lang.c, objc-lang.c, ada-lang.c: Update.
	* infcall.c, printcmd.c, valops.c, eval.c, p-exp.y: Update.
	* ax-gdb.c, tracepoint.c: Update.
@
text
@d1645 7
@


1.27
log
@2005-01-29  Baurzhan Ismagulov  <ibr@@radix50.net>

	* ax-gdb.c, ax-general.c, bcache.c, bfd-target.c, bsd-kvm.c,
	* buildsym.c, c-lang.c, c-typeprint.c, c-valprint.c, charset.c,
	* coff-pe-read.c, coffread.c, complaints.c, copying.c: I18n markup.
@
text
@d1427 1
a1427 1
    if (TYPE_CODE (v->type) != TYPE_CODE_INT)
@


1.26
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d417 1
a417 1
			  "gen_fetch: strange size");
d429 1
a429 1
		      "gen_fetch: bad type code");
d542 1
a542 1
		      "gen_var_ref: LOC_CONST_BYTES symbols are not supported");
d581 1
a581 1
      error ("Cannot compute value of typedef `%s'.",
d613 1
a613 1
	  error ("Couldn't resolve symbol `%s'.", SYMBOL_PRINT_NAME (var));
d632 1
a632 1
      error ("The variable `%s' has been optimized out.",
d637 1
a637 1
      error ("Cannot find value of botched symbol `%s'.",
d902 1
a902 1
      error ("Illegal type cast: intended type must be scalar.");
d925 1
a925 1
      error ("Casts to requested type are not yet implemented.");
d992 1
a992 1
    error ("Illegal combination of types in %s.", name);
d1029 1
a1029 1
	error ("\
d1031 1
a1031 1
an integer nor a pointer of the same type.");
d1044 1
a1044 1
    error ("Illegal combination of types in subtraction.");
d1063 1
a1063 1
    error ("Illegal combination of types in %s.", name);
d1079 1
a1079 1
    error ("Illegal type of operand to `!'.");
d1091 1
a1091 1
    error ("Illegal type of operand to `~'.");
d1111 1
a1111 1
		    "gen_deref: expected a pointer");
d1139 1
a1139 1
	error ("Operand of `&' is an rvalue, which has no address.");
d1142 1
a1142 1
	error ("Operand of `&' is in a register, and has no address.");
d1167 1
a1167 1
		    "find_field: derived classes supported");
d1178 1
a1178 1
			"find_field: anonymous unions not supported");
d1181 1
a1181 1
  error ("Couldn't find member named `%s' in struct/union `%s'",
d1251 1
a1251 1
		    "gen_bitfield_ref: bitfield too wide");
d1373 1
a1373 1
    error ("The left operand of `%s' is not a %s.",
d1379 1
a1379 1
    error ("Structure does not live in memory.");
d1418 1
a1418 1
    error ("Left operand of `@@' must be an object in memory.");
d1426 1
a1426 1
      error ("Right operand of `@@' must be a constant, in agent expressions.");
d1428 1
a1428 1
      error ("Right operand of `@@' must be an integer.");
d1431 1
a1431 1
      error ("Right operand of `@@' must be positive.");
d1475 1
d1541 1
a1541 1
	    error ("Illegal combination of types in array subscripting.");
d1563 1
a1563 1
			  "gen_expr: op case sets don't match");
d1609 1
a1609 1
      error ("GDB agent expressions cannot use convenience variables.");
d1639 1
a1639 1
			  "gen_expr: OP_MEMVAL operand isn't an rvalue???");
d1673 1
a1673 1
	error ("Argument of unary `*' is not a pointer.");
d1708 1
a1708 1
			  "gen_expr: unhandled struct case");
d1713 1
a1713 1
      error ("Attempt to use a type name as an expression.");
d1716 1
a1716 1
      error ("Unsupported operator in expression.");
d1764 1
a1764 1
      error ("Expression does not denote an object in memory.");
d1819 1
a1819 1
    error ("GDB can't do agent expression translation with overlays.");
d1822 1
a1822 1
    error_no_arg ("expression to translate");
d1845 1
a1845 1
	   "Translate an expression into remote agent bytecode.",
@


1.25
log
@Fix typo in comments (Unfortunatly)
@
text
@d1493 1
a1493 1
	value->type = check_typedef (VALUE_TYPE (v));
@


1.24
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2loc.c (dwarf_expr_frame_base): Use SYMBOL_OPS instead of
	SYMBOL_LOCATION_FUNCS
	(dwarf2_loclist_funcs, dwarf2_locexpr_funcs): Change type to
	"struct symbol_ops".
	* dwarf2loc.h (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Change
	type to "struct symbol_ops".
	* symtab.h (struct symbol_ops): Rename "struct location_funcs".
	(struct symbol): Replace ".aux_value.loc.funcs" and
	".aux_value.loc.baton" with ".ops" and ".aux_value.ptr".
	(SYMBOL_OBJFILE): Delete macro.
	(SYMBOL_LOCATION_FUNCS): Delete macro.
	(SYMBOL_LOCATION_BATON): Update.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Set SYMBOL_OPS
	intead of SYMBOL_LOCATION_FUNCS.
	* ax-gdb.c (gen_var_ref): Ditto.
	* printcmd.c (address_info): Ditto.
	* findvar.c (read_var_value): Ditto.
	(symbol_read_needs_frame): Ditto.
@
text
@d625 1
a625 1
	 Unfortunatly DWARF 2 stores the frame-base (instead of the
@


1.23
log
@2004-01-20  Andrew Cagney  <cagney@@redhat.com>

	* ax-gdb.c (print_axs_value): Delete unused function.
	* jv-lang.c (java_lookup_type): Delete unused function.
	* cli/cli-dump.c (dump_filetype): Delete unused function.
	* remote-mips.c (remote_mips_insert_hw_breakpoint)
	(remote_mips_remove_hw_breakpoint): Delete unused functions.
	(mips_getstring): Delete unused function.
	(pmon_insert_breakpoint): Delete #if0ed function.
	(PMON_MAX_BP): Delete #if0ed MACRO.
	(mips_pmon_bp_info): Delete #if0ed variable.
	(pmon_remove_breakpoint): Delete #if0ed function.
	* monitor.c (monitor_write_even_block): Delete unused function.
	(monitor_write_memory_block): Delete #if0ed code.
	* dink32-rom.c (dink32_load): Delete unused function.
	(_initialize_dink32_rom): Delete #if0ed code.
	* d10v-tdep.c (d10v_daddr_p): Delete unused function.
@
text
@d623 6
a628 1
      (*SYMBOL_LOCATION_FUNCS (var)->tracepoint_var_ref) (var, ax, value);
@


1.22
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (ax-gdb.o): Update dependencies.
	* ax-gdb.c: Include "regcache.h".
	(gen_expr): Use register_type instead of REGISTER_VIRTUAL_TYPE.
	* findvar.c (value_of_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.

Index: mi/ChangeLog
2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (get_register): Use register_type instead of
	REGISTER_VIRTUAL_TYPE.
@
text
@a136 1
static void print_axs_value (struct ui_file *f, struct axs_value * value);
a1798 27



/* The "agent" command, for testing: compile and disassemble an expression.  */

static void
print_axs_value (struct ui_file *f, struct axs_value *value)
{
  switch (value->kind)
    {
    case axs_rvalue:
      fputs_filtered ("rvalue", f);
      break;

    case axs_lvalue_memory:
      fputs_filtered ("memory lvalue", f);
      break;

    case axs_lvalue_register:
      fprintf_filtered (f, "register %d lvalue", value->u.reg);
      break;
    }

  fputs_filtered (" : ", f);
  type_print (value->type, "", f, -1);
}

@


1.22.24.1
log
@Snap const char * mess.
@
text
@d138 1
a138 1
static void agent_command (const char *exp, int from_tty);
d1829 1
a1829 1
agent_command (const char *exp, int from_tty)
@


1.21
log
@	* Makefile.in (dwarf2loc.o): Update dependencies.
	* ax-gdb.c (gen_var_ref): Handle LOC_COMPUTED and LOC_COMPUTED_ARG.
	* dwarf2expr.c (read_uleb128, read_sleb128): Make non-static.
	* dwarf2expr.h (read_uleb128, read_sleb128): Add prototypes.
	* dwarf2loc.c: Include "ax.h" and "ax-gdb.h".
	(locexpr_tracepoint_var_ref): New function.
	(dwarf2_locexpr_funcs): Add locexpr_tracepoint_var_ref.
@
text
@d37 1
d1599 1
a1599 1
	value->type = REGISTER_VIRTUAL_TYPE (reg);
@


1.20
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d621 5
@


1.19
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d611 1
a611 1
	= lookup_minimal_symbol (SYMBOL_NAME (var), NULL, NULL);
@


1.18
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d582 1
a582 1
	     SYMBOL_SOURCE_NAME (var));
d613 1
a613 1
	  error ("Couldn't resolve symbol `%s'.", SYMBOL_SOURCE_NAME (var));
d623 1
a623 1
	     SYMBOL_SOURCE_NAME (var));
d628 1
a628 1
	     SYMBOL_SOURCE_NAME (var));
@


1.17
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d36 1
@


1.16
log
@2003-01-09  Andrew Cagney  <ac131313@@redhat.com>

	* somsolib.h: Fix function indentation.
	* disasm.c, buildsym.c, buildsym.h: Eliminate PTR.
	* gnu-v2-abi.c, f-typeprint.c, x86-64-linux-tdep.c: Eliminate STREQ.
	* demangle.c, ax-gdb.c, c-valprint.c: Eliminate STREQ.
	* alpha-osf1-tdep.c, corefile.c: Eliminate STREQ.
	* somsolib.c, inftarg.c: Remove assignment in if conditional.
@
text
@d1 4
a4 2
/* GDB-specific functions for operating on agent expressions
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.15
log
@2002-12-07  Andrew Cagney  <ac131313@@redhat.com>

	* f-valprint.c (info_common_command): Use get_frame_pc.
	* std-regs.c (value_of_builtin_frame_pc_reg): Ditto.
	* ax-gdb.c (agent_command): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	(rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc, frame_get_saved_regs): Ditto.
	(frame_initial_stack_address, rs6000_frame_chain): Ditto.
	* macroscope.c (default_macro_scope): Ditto.
	* stack.c (print_frame_info_base): Ditto.
	(print_frame, frame_info, print_frame_label_vars): Ditto.
	(return_command, func_command, get_frame_language): Ditto.
	* infcmd.c (finish_command): Ditto.
	* dummy-frame.c (cached_find_dummy_frame): Ditto.
	* breakpoint.c (deprecated_frame_in_dummy): Ditto.
	(break_at_finish_at_depth_command_1): Ditto.
	(break_at_finish_command_1): Ditto.
	(until_break_command, get_catch_sals): Ditto.
	* blockframe.c (func_frame_chain_valid): Ditto.
	(frameless_look_for_prologue): Ditto.
	(frame_address_in_block, generic_func_frame_chain_valid): Ditto.
@
text
@d1160 1
a1160 1
      if (this_name && STREQ (name, this_name))
@


1.14
log
@	* Makefile.in (osabi.o, i387-tdep.o, i386-linux-nat.o, lin-lwp.o,
	ax-gdb.o, signals.o, jv-valprint.o, c-valprint.o, cp-abi.o):
	Update dependencies.
	* i387-tdep.c: Include gdb_string.h.
	* osabi.c: Likewise.
	* i386-linux-nat.c: Likewise.
	* lin-lwp.c: Likewise.
	* ax-gdb.c: Likewise.
	* signals/signals.c: Likewise.
	* jv-valprint.c: Likewise.
	* p-lang.c: Likewise.
	* c-valprint.c: Likewise.
	* cp-abi.c: Likewise.
@
text
@d1839 1
a1839 1
  agent = gen_trace_for_expr (fi->pc, expr);
@


1.14.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 2
a2 4
/* GDB-specific functions for operating on agent expressions.

   Copyright 1998, 1999, 2000, 2001, 2003 Free Software Foundation,
   Inc.
a33 2
#include "block.h"
#include "regcache.h"
d579 1
a579 1
	     SYMBOL_PRINT_NAME (var));
d608 1
a608 1
	= lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (var), NULL, NULL);
d610 1
a610 1
	  error ("Couldn't resolve symbol `%s'.", SYMBOL_PRINT_NAME (var));
a617 5
    case LOC_COMPUTED:
    case LOC_COMPUTED_ARG:
      (*SYMBOL_LOCATION_FUNCS (var)->tracepoint_var_ref) (var, ax, value);
      break;

d620 1
a620 1
	     SYMBOL_PRINT_NAME (var));
d625 1
a625 1
	     SYMBOL_PRINT_NAME (var));
d1160 1
a1160 1
      if (this_name && strcmp (name, this_name) == 0)
d1590 1
a1590 1
	value->type = register_type (current_gdbarch, reg);
d1839 1
a1839 1
  agent = gen_trace_for_expr (get_frame_pc (fi), expr);
@


1.14.6.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d137 1
d624 1
a624 6
      /* FIXME: cagney/2004-01-26: It should be possible to
	 unconditionally call the SYMBOL_OPS method when available.
	 Unfortunately DWARF 2 stores the frame-base (instead of the
	 function) location in a function's symbol.  Oops!  For the
	 moment enable this when/where applicable.  */
      SYMBOL_OPS (var)->tracepoint_var_ref (var, ax, value);
d1800 27
@


1.14.4.1
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a22 1
#include "block.h"
@


1.14.4.2
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d580 1
a580 1
	     SYMBOL_PRINT_NAME (var));
d611 1
a611 1
	  error ("Couldn't resolve symbol `%s'.", SYMBOL_PRINT_NAME (var));
d621 1
a621 1
	     SYMBOL_PRINT_NAME (var));
d626 1
a626 1
	     SYMBOL_PRINT_NAME (var));
@


1.14.4.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1840 1
a1840 1
  agent = gen_trace_for_expr (get_frame_pc (fi), expr);
@


1.14.4.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 2
a2 4
/* GDB-specific functions for operating on agent expressions.

   Copyright 1998, 1999, 2000, 2001, 2003 Free Software Foundation,
   Inc.
d1161 1
a1161 1
      if (this_name && strcmp (name, this_name) == 0)
@


1.14.4.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d25 1
a36 2
#include "block.h"
#include "regcache.h"
d611 1
a611 1
	= lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (var), NULL, NULL);
a620 5
    case LOC_COMPUTED:
    case LOC_COMPUTED_ARG:
      (*SYMBOL_LOCATION_FUNCS (var)->tracepoint_var_ref) (var, ax, value);
      break;

d1593 1
a1593 1
	value->type = register_type (current_gdbarch, reg);
@


1.14.4.6
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d612 1
a612 1
	= lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (var), NULL, NULL);
@


1.14.4.7
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d137 1
d1800 27
@


1.13
log
@2002-05-13  Daniel Jacobowitz  <drow@@mvista.com>

        * ax-gdb.c (gen_sign_extend, gen_fetch, gen_usual_unary)
        (gen_cast, gen_scale, gen_add, gen_sub, gen_binop, gen_deref)
        (gen_address_of, gen_struct_ref, gen_repeat): Use type
        access macros.
        * c-typeprint.c (cp_type_print_method_args): Likewise.
        (c_type_print_args): Likewise.
        * d10v-tdep.c (d10v_push_arguments): Likewise.
        (d10v_extract_return_value): Likewise.
        * expprint.c (print_subexp): Likewise.
        * gdbtypes.c (lookup_primitive_typename): Likewise.
        (lookup_template_type, add_mangled_type, print_arg_types): Likewise.
        * gdbtypes.h (TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB)
        (TYPE_TARGET_STUB, TYPE_STATIC, TYPE_CONST, TYPE_VOLATILE)
        (TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_CODE_SPACE, TYPE_VARARGS)
        (TYPE_VECTOR): Likewise.
        * hpread.c (hpread_read_struct_type)
        (fix_static_member_physnames, fixup_class_method_type)
        (hpread_type_lookup): Likewise.
        * mdebugread.c (parse_symbol, parse_type): Likewise.
        * p-lang.c (is_pascal_string_type): Likewise.
        * valops.c (hand_function_call): Likewise.
        * x86-64-tdep.c (classify_argument): Likewise.

        * hpread.c (hpread_read_function_type)
        (hpread_read_doc_function_type): Call replace_type.
        * dstread.c (create_new_type): Delete.
        (decode_dst_structure, process_dst_function): Call alloc_type.
        Use type access macros.
@
text
@d33 1
@


1.13.4.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a32 1
#include "gdb_string.h"
@


1.12
log
@2002-02-03  Daniel Jacobowitz  <drow@@mvista.com>

        * ax-gdb.c (find_field): Use TYPE_TAG_NAME instead
        of accessing tag_name directly.
@
text
@d356 1
a356 1
    ax_ext (ax, type->length * TARGET_CHAR_BIT);
d366 1
a366 1
  int bits = type->length * TARGET_CHAR_BIT;
d384 1
a384 1
  switch (type->code)
d392 1
a392 1
      switch (type->length)
d702 1
a702 1
  switch (value->type->code)
d877 1
a877 1
  switch (type->code)
d928 1
a928 1
  if (element->length != 1)
d930 1
a930 1
      ax_const_l (ax, element->length);
d946 2
a947 2
  if (value1->type->code == TYPE_CODE_INT
      && value2->type->code == TYPE_CODE_PTR)
d958 2
a959 2
  else if (value1->type->code == TYPE_CODE_PTR
	   && value2->type->code == TYPE_CODE_INT)
d969 2
a970 2
  else if (value1->type->code == TYPE_CODE_INT
	   && value2->type->code == TYPE_CODE_INT)
d992 1
a992 1
  if (value1->type->code == TYPE_CODE_PTR)
d995 1
a995 1
      if (value2->type->code == TYPE_CODE_INT)
d1006 1
a1006 1
      else if (value2->type->code == TYPE_CODE_PTR
d1021 2
a1022 2
  else if (value1->type->code == TYPE_CODE_INT
	   && value2->type->code == TYPE_CODE_INT)
d1047 2
a1048 2
  if ((value1->type->code != TYPE_CODE_INT)
      || (value2->type->code != TYPE_CODE_INT))
d1095 1
a1095 1
  if (value->type->code != TYPE_CODE_PTR)
d1105 1
a1105 1
  value->kind = ((value->type->code == TYPE_CODE_FUNC)
d1117 1
a1117 1
  if (value->type->code == TYPE_CODE_FUNC)
d1349 1
a1349 1
  while (value->type->code == TYPE_CODE_PTR)
d1413 1
a1413 1
    if (v->type->code != TYPE_CODE_INT)
@


1.11
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d1168 1
a1168 1
	 name, type->tag_name);
@


1.10
log
@* target.h (TARGET_VIRTUAL_FRAME_POINTER): Delete, multi-arched.
* gdbarch.sh (TARGET_VIRTUAL_FRAME_POINTER): Add.
* gdbarch.h, gdbarch.c: Regenerate.

* arch-utils.h (legacy_virtual_frame_pointer): Declare.
* arch-utils.c: Include "gdb_assert.h".
(legacy_virtual_frame_pointer): Define.
* Makefile.in (arch-utils.o): Depends on gdb_assert.h.

* tracepoint.c (encode_actions): Make frame_reg an int.  Make
frame_offset a LONGEST.
* ax-gdb.c (gen_frame_args_address): Ditto.
(gen_frame_locals_address): Ditto.
* mn10300-tdep.c (mn10300_gdbarch_init): Initialize
virtual_frame_pointer.
(mn10300_virtual_frame_pointer): Make static.  Update parameter
list to match function signature.
* config/mn10300/tm-mn10300.h (TARGET_VIRTUAL_FRAME_POINTER): Delete.
@
text
@d1306 1
a1306 1
	  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.9
log
@Update/correct copyright notices.
@
text
@d457 2
a458 1
  long frame_reg, frame_offset;
d471 2
a472 1
  long frame_reg, frame_offset;
@


1.9.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d356 1
a356 1
    ax_ext (ax, TYPE_LENGTH(type) * TARGET_CHAR_BIT);
d366 1
a366 1
  int bits = TYPE_LENGTH(type) * TARGET_CHAR_BIT;
d384 1
a384 1
  switch (TYPE_CODE(type))
d392 1
a392 1
      switch (TYPE_LENGTH(type))
d700 1
a700 1
  switch (TYPE_CODE(value->type))
d712 1
a712 1
	struct type *elements = ARRAY_ELEMENT_TYPE (value->type);
d875 1
a875 1
  switch (TYPE_CODE(type))
d926 1
a926 1
  if (TYPE_LENGTH(element) != 1)
d928 1
a928 1
      ax_const_l (ax, TYPE_LENGTH(element));
d944 2
a945 2
  if (TYPE_CODE(value1->type) == TYPE_CODE_INT
      && TYPE_CODE(value2->type) == TYPE_CODE_PTR)
d956 2
a957 2
  else if (TYPE_CODE(value1->type) == TYPE_CODE_PTR
	   && TYPE_CODE(value2->type) == TYPE_CODE_INT)
d967 2
a968 2
  else if (TYPE_CODE(value1->type) == TYPE_CODE_INT
	   && TYPE_CODE(value2->type) == TYPE_CODE_INT)
d990 1
a990 1
  if (TYPE_CODE(value1->type) == TYPE_CODE_PTR)
d993 1
a993 1
      if (TYPE_CODE(value2->type) == TYPE_CODE_INT)
d1004 1
a1004 1
      else if (TYPE_CODE(value2->type) == TYPE_CODE_PTR
d1019 2
a1020 2
  else if (TYPE_CODE(value1->type) == TYPE_CODE_INT
	   && TYPE_CODE(value2->type) == TYPE_CODE_INT)
d1045 2
a1046 2
  if ((TYPE_CODE(value1->type) != TYPE_CODE_INT)
      || (TYPE_CODE(value2->type) != TYPE_CODE_INT))
d1093 1
a1093 1
  if (TYPE_CODE(value->type) != TYPE_CODE_PTR)
d1103 1
a1103 1
  value->kind = ((TYPE_CODE(value->type) == TYPE_CODE_FUNC)
d1115 1
a1115 1
  if (TYPE_CODE(value->type) == TYPE_CODE_FUNC)
d1166 1
a1166 1
	 name, TYPE_TAG_NAME(type));
d1347 1
a1347 1
  while (TYPE_CODE(value->type) == TYPE_CODE_PTR)
d1411 1
a1411 1
    if (TYPE_CODE(v->type) != TYPE_CODE_INT)
d1420 1
a1420 1
      /* TYPEFIX-type-allocation: need a way to free this type when we are
d1422 3
a1424 3
      struct range_type *range
      = make_range_type (NULL, builtin_type_int, 0, length - 1);
      struct type *array = (struct type *)make_array_type (NULL, value1.type, range);
@


1.8
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d2 1
a2 1
   Copyright 1998, 2000, 2001 Free Software Foundation, Inc.
@


1.7
log
@2000-10-19  Josef Ezra <jezra@@emc.com>

      * ax-gdb.c (gen_struct_ref): while generating data code, cases of
      "collect p1->p2->data" where not covered if p2 is a 'typedefed'
      type. this simple fix should forward the type pointer to the real
      type.
@
text
@d2 1
a2 1
   Copyright 1998, 2000 Free Software Foundation, Inc.
d412 2
a413 1
	  internal_error ("ax-gdb.c (gen_fetch): strange size");
d424 2
a425 1
      internal_error ("ax-gdb.c (gen_fetch): bad type code");
d535 2
a536 1
      internal_error ("ax-gdb.c (gen_var_ref): LOC_CONST_BYTES symbols are not supported");
d1094 2
a1095 1
    internal_error ("ax-gdb.c (gen_deref): expected a pointer");
d1150 2
a1151 1
    internal_error ("ax-gdb.c (find_field): derived classes supported");
d1161 2
a1162 1
	internal_error ("ax-gdb.c (find_field): anonymous unions not supported");
d1234 2
a1235 1
    internal_error ("ax-gdb.c (gen_bitfield_ref): bitfield too wide");
d1545 2
a1546 1
	  internal_error ("ax-gdb.c (gen_expr): op case sets don't match");
d1621 2
a1622 1
	  internal_error ("ax-gdb.c (gen_expr): OP_MEMVAL operand isn't an rvalue???");
d1690 2
a1691 1
	  internal_error ("ax-gdb.c (gen_expr): unhandled struct case");
@


1.6
log
@Protoization.
@
text
@d1345 1
a1345 1
  type = value->type;
@


1.5
log
@PARAMS removal.
@
text
@d157 1
a157 2
const_var_ref (var)
     struct symbol *var;
d180 1
a180 2
const_expr (pc)
     union exp_element **pc;
d221 1
a221 2
maybe_const_expr (pc)
     union exp_element **pc;
d307 1
a307 3
gen_traced_pop (ax, value)
     struct agent_expr *ax;
     struct axs_value *value;
d352 1
a352 3
gen_sign_extend (ax, type)
     struct agent_expr *ax;
     struct type *type;
d364 1
a364 3
gen_extend (ax, type)
     struct agent_expr *ax;
     struct type *type;
d376 1
a376 3
gen_fetch (ax, type)
     struct agent_expr *ax;
     struct type *type;
d432 1
a432 3
gen_left_shift (ax, distance)
     struct agent_expr *ax;
     int distance;
d453 1
a453 2
gen_frame_args_address (ax)
     struct agent_expr *ax;
d466 1
a466 2
gen_frame_locals_address (ax)
     struct agent_expr *ax;
d482 1
a482 3
gen_offset (ax, offset)
     struct agent_expr *ax;
     int offset;
d504 1
a504 3
gen_sym_offset (ax, var)
     struct agent_expr *ax;
     struct symbol *var;
d514 1
a514 4
gen_var_ref (ax, value, var)
     struct agent_expr *ax;
     struct axs_value *value;
     struct symbol *var;
d629 2
a630 5
gen_int_literal (ax, value, k, type)
     struct agent_expr *ax;
     struct axs_value *value;
     LONGEST k;
     struct type *type;
d645 1
a645 3
require_rvalue (ax, value)
     struct agent_expr *ax;
     struct axs_value *value;
d690 1
a690 3
gen_usual_unary (ax, value)
     struct agent_expr *ax;
     struct axs_value *value;
d737 1
a737 2
type_wider_than (type1, type2)
     struct type *type1, *type2;
d748 1
a748 2
max_type (type1, type2)
     struct type *type1, *type2;
d756 1
a756 3
gen_conversion (ax, from, to)
     struct agent_expr *ax;
     struct type *from, *to;
d786 1
a786 2
is_nontrivial_conversion (from, to)
     struct type *from, *to;
d810 2
a811 3
gen_usual_arithmetic (ax, value1, value2)
     struct agent_expr *ax;
     struct axs_value *value1, *value2;
d847 1
a847 3
gen_integral_promotions (ax, value)
     struct agent_expr *ax;
     struct axs_value *value;
d864 1
a864 4
gen_cast (ax, value, type)
     struct agent_expr *ax;
     struct axs_value *value;
     struct type *type;
d919 1
a919 4
gen_scale (ax, op, type)
     struct agent_expr *ax;
     enum agent_op op;
     struct type *type;
d937 2
a938 4
gen_add (ax, value, value1, value2, name)
     struct agent_expr *ax;
     struct axs_value *value, *value1, *value2;
     char *name;
d984 2
a985 3
gen_sub (ax, value, value1, value2)
     struct agent_expr *ax;
     struct axs_value *value, *value1, *value2;
d1037 3
a1039 6
gen_binop (ax, value, value1, value2, op, op_unsigned, may_carry, name)
     struct agent_expr *ax;
     struct axs_value *value, *value1, *value2;
     enum agent_op op, op_unsigned;
     int may_carry;
     char *name;
d1056 1
a1056 3
gen_logical_not (ax, value)
     struct agent_expr *ax;
     struct axs_value *value;
d1069 1
a1069 3
gen_complement (ax, value)
     struct agent_expr *ax;
     struct axs_value *value;
d1086 1
a1086 3
gen_deref (ax, value)
     struct agent_expr *ax;
     struct axs_value *value;
d1106 1
a1106 3
gen_address_of (ax, value)
     struct agent_expr *ax;
     struct axs_value *value;
d1138 1
a1138 3
find_field (type, name)
     struct type *type;
     char *name;
d1171 2
a1172 5
gen_bitfield_ref (ax, value, type, start, end)
     struct agent_expr *ax;
     struct axs_value *value;
     struct type *type;
     int start, end;
d1331 2
a1332 6
gen_struct_ref (ax, value, field, operator_name, operand_name)
     struct agent_expr *ax;
     struct axs_value *value;
     char *field;
     char *operator_name;
     char *operand_name;
d1387 2
a1388 4
gen_repeat (pc, ax, value)
     union exp_element **pc;
     struct agent_expr *ax;
     struct axs_value *value;
d1430 2
a1431 4
gen_sizeof (pc, ax, value)
     union exp_element **pc;
     struct agent_expr *ax;
     struct axs_value *value;
d1455 2
a1456 4
gen_expr (pc, ax, value)
     union exp_element **pc;
     struct agent_expr *ax;
     struct axs_value *value;
d1701 1
a1701 3
expr_to_agent (expr, value)
     struct expression *expr;
     struct axs_value *value;
d1728 1
a1728 2
expr_to_address_and_size (expr)
     struct expression *expr;
d1753 1
a1753 3
gen_trace_for_expr (scope, expr)
     CORE_ADDR scope;
     struct expression *expr;
d1784 1
a1784 3
print_axs_value (f, value)
     struct ui_file *f;
     struct axs_value *value;
d1807 1
a1807 3
agent_command (exp, from_tty)
     char *exp;
     int from_tty;
d1842 1
a1842 1
_initialize_ax_gdb ()
@


1.4
log
@Cleanup free_agent_expr cleanups.
@
text
@d59 72
a130 92
static struct value *const_var_ref PARAMS ((struct symbol * var));
static struct value *const_expr PARAMS ((union exp_element ** pc));
static struct value *maybe_const_expr PARAMS ((union exp_element ** pc));

static void gen_traced_pop PARAMS ((struct agent_expr *, struct axs_value *));

static void gen_sign_extend PARAMS ((struct agent_expr *, struct type *));
static void gen_extend PARAMS ((struct agent_expr *, struct type *));
static void gen_fetch PARAMS ((struct agent_expr *, struct type *));
static void gen_left_shift PARAMS ((struct agent_expr *, int));


static void gen_frame_args_address PARAMS ((struct agent_expr *));
static void gen_frame_locals_address PARAMS ((struct agent_expr *));
static void gen_offset PARAMS ((struct agent_expr * ax, int offset));
static void gen_sym_offset PARAMS ((struct agent_expr *, struct symbol *));
static void gen_var_ref PARAMS ((struct agent_expr * ax,
				 struct axs_value * value,
				 struct symbol * var));


static void gen_int_literal PARAMS ((struct agent_expr * ax,
				     struct axs_value * value,
				     LONGEST k, struct type * type));


static void require_rvalue PARAMS ((struct agent_expr * ax,
				    struct axs_value * value));
static void gen_usual_unary PARAMS ((struct agent_expr * ax,
				     struct axs_value * value));
static int type_wider_than PARAMS ((struct type * type1,
				    struct type * type2));
static struct type *max_type PARAMS ((struct type * type1,
				      struct type * type2));
static void gen_conversion PARAMS ((struct agent_expr * ax,
				    struct type * from,
				    struct type * to));
static int is_nontrivial_conversion PARAMS ((struct type * from,
					     struct type * to));
static void gen_usual_arithmetic PARAMS ((struct agent_expr * ax,
					  struct axs_value * value1,
					  struct axs_value * value2));
static void gen_integral_promotions PARAMS ((struct agent_expr * ax,
					     struct axs_value * value));
static void gen_cast PARAMS ((struct agent_expr * ax,
			      struct axs_value * value,
			      struct type * type));
static void gen_scale PARAMS ((struct agent_expr * ax,
			       enum agent_op op,
			       struct type * type));
static void gen_add PARAMS ((struct agent_expr * ax,
			     struct axs_value * value,
			     struct axs_value * value1,
			     struct axs_value * value2,
			     char *name));
static void gen_sub PARAMS ((struct agent_expr * ax,
			     struct axs_value * value,
			     struct axs_value * value1,
			     struct axs_value * value2));
static void gen_binop PARAMS ((struct agent_expr * ax,
			       struct axs_value * value,
			       struct axs_value * value1,
			       struct axs_value * value2,
			       enum agent_op op,
			       enum agent_op op_unsigned,
			       int may_carry,
			       char *name));
static void gen_logical_not PARAMS ((struct agent_expr * ax,
				     struct axs_value * value));
static void gen_complement PARAMS ((struct agent_expr * ax,
				    struct axs_value * value));
static void gen_deref PARAMS ((struct agent_expr *, struct axs_value *));
static void gen_address_of PARAMS ((struct agent_expr *, struct axs_value *));
static int find_field PARAMS ((struct type * type, char *name));
static void gen_bitfield_ref PARAMS ((struct agent_expr * ax,
				      struct axs_value * value,
				      struct type * type,
				      int start, int end));
static void gen_struct_ref PARAMS ((struct agent_expr * ax,
				    struct axs_value * value,
				    char *field,
				    char *operator_name,
				    char *operand_name));
static void gen_repeat PARAMS ((union exp_element ** pc,
				struct agent_expr * ax,
				struct axs_value * value));
static void gen_sizeof PARAMS ((union exp_element ** pc,
				struct agent_expr * ax,
				struct axs_value * value));
static void gen_expr PARAMS ((union exp_element ** pc,
			      struct agent_expr * ax,
			      struct axs_value * value));
d133 1
a133 1
static void agent_command PARAMS ((char *exp, int from_tty));
d1921 1
a1921 1
void _initialize_ax_gdb PARAMS ((void));
@


1.3
log
@	* ax-gdb.c (agent_command): Remove now useless cast of
	`free_current_contents' when passed to `make_cleanup'.
	* coffread.c (coff_symfile_read): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn, read_array_type): Ditto.
	(dwarf_decode_lines): Ditto.
	* eval.c (parse_and_eval_address, parse_and_eval_address_1): Ditto.
	(parse_and_eval, parse_to_comma_and_eval): Ditto.
	* parse.c (parse_exp_1): Ditto.
	* printcmd.c (print_command_1, output_command, set_command): Ditto.
	(x_command, print_frame_args, printf_command): Ditto.
	* top.c (execute_control_command): Ditto.
	* tracepoint.c (validate_actionline): Ditto.
	* typeprint.c (whatis_exp, ptype_command): Ditto.
	(maintenance_print_type): Ditto.
@
text
@d1801 1
a1801 1
  old_chain = make_cleanup ((make_cleanup_func) free_agent_expr, ax);
d1857 1
a1857 1
  old_chain = make_cleanup ((make_cleanup_func) free_agent_expr, ax);
d1928 1
a1928 1
  make_cleanup ((make_cleanup_func) free_agent_expr, agent);
@


1.2
log
@* gdbarch.sh (POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Two new
functions which architectures can redefine, defaulting to
generic_pointer_to_address and generic_address_to_pointer.
* findvar.c (extract_typed_address, store_typed_address,
generic_pointer_to_address, generic_address_to_pointer): New
functions.
(POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Provide default
definitions.
(extract_address, store_address): Doc fixes.
* values.c (value_as_pointer): Doc fix.
(value_from_pointer): New function.
* defs.h (extract_typed_address, store_typed_address): New
declarations.
* inferior.h (generic_address_to_pointer,
generic_pointer_to_address): New declarations.
* value.h (value_from_pointer): New declaration.

* ax-gdb.c (const_var_ref): Use value_from_pointer, not
value_from_longest.
* blockframe.c (generic_push_dummy_frame): Use read_pc and
read_sp, not read_register.
* c-valprint.c (c_val_print): Use extract_typed_address instead of
extract_address to extract vtable entries and references.
* cp-valprint.c (cp_print_value_fields): Use value_from_pointer
instead of value_from_longest to extract the vtable's address.
* eval.c (evaluate_subexp_standard): Use value_from_pointer
instead of value_from_longest to compute `this', and for doing
pointer-to-member dereferencing.
* findvar.c (read_register): Use extract_unsigned_integer, not
extract_address.
(read_var_value): Use store_typed_address instead of store_address
for building label values.
(locate_var_value): Use value_from_pointer instead of
value_from_longest.
* hppa-tdep.c (find_stub_with_shl_get): Use value_from_pointer,
instead of value_from_longest, to build arguments to __d_shl_get.
* printcmd.c (set_next_address): Use value_from_pointer, not
value_from_longest.
(x_command): Use value_from_pointer, not value_from_longest.
* tracepoint.c (set_traceframe_context): Use value_from_pointer,
not value_from_longest.
* valarith.c (value_add, value_sub): Use value_from_pointer, not
value_from_longest.
* valops.c (find_function_in_inferior, value_coerce_array,
value_coerce_function, value_addr, hand_function_call): Same.
* value.h (COERCE_REF): Use unpack_pointer, not unpack_long.
* values.c (unpack_long): Use extract_typed_address to produce
addresses from pointers and references, not extract_address.
(value_from_longest): Use store_typed_address instead of
store_address to produce pointer and reference values.
@
text
@d1926 1
a1926 1
  old_chain = make_cleanup ((make_cleanup_func) free_current_contents, &expr);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1998 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 15
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* $Id: ax-gdb.c,v 1.8 1998/12/03 05:34:24 cagney Exp $ */
d34 5
a38 4
/* Probably the best way to read this file is to start with the types
   and enums in ax-gdb.h, and then look at gen_expr, towards the
   bottom; that's the main function that looks at the GDB expressions
   and calls everything else to generate code.
d48 2
a49 1
   Remember, "GBD" stands for "Great Britain, Dammit!"  So be careful.  */ 
a51 1

d58 4
a61 4
   
static struct value *const_var_ref PARAMS ((struct symbol *var));
static struct value *const_expr PARAMS ((union exp_element **pc));
static struct value *maybe_const_expr PARAMS ((union exp_element **pc));
d71 1
a71 1
static void gen_frame_args_address   PARAMS ((struct agent_expr *));
d73 1
a73 1
static void gen_offset PARAMS ((struct agent_expr *ax, int offset));
d75 32
a106 32
static void gen_var_ref PARAMS ((struct agent_expr *ax,
				 struct axs_value *value,
				 struct symbol *var));


static void gen_int_literal PARAMS ((struct agent_expr *ax,
				     struct axs_value *value,
				     LONGEST k, struct type *type));


static void require_rvalue PARAMS ((struct agent_expr *ax,
				    struct axs_value *value));
static void gen_usual_unary PARAMS ((struct agent_expr *ax,
				     struct axs_value *value));
static int type_wider_than PARAMS ((struct type *type1,
				    struct type *type2));
static struct type *max_type PARAMS ((struct type *type1, 
				      struct type *type2));
static void gen_conversion PARAMS ((struct agent_expr *ax,
				    struct type *from,
				    struct type *to));
static int is_nontrivial_conversion PARAMS ((struct type *from,
					     struct type *to));
static void gen_usual_arithmetic PARAMS ((struct agent_expr *ax,
					  struct axs_value *value1,
					  struct axs_value *value2));
static void gen_integral_promotions PARAMS ((struct agent_expr *ax,
					     struct axs_value *value));
static void gen_cast PARAMS ((struct agent_expr *ax,
			      struct axs_value *value,
			      struct type *type));
static void gen_scale PARAMS ((struct agent_expr *ax,
d108 5
a112 5
			       struct type *type));
static void gen_add PARAMS ((struct agent_expr *ax,
			     struct axs_value *value, 
			     struct axs_value *value1,
			     struct axs_value *value2,
d114 8
a121 8
static void gen_sub PARAMS ((struct agent_expr *ax,
			     struct axs_value *value, 
			     struct axs_value *value1,
			     struct axs_value *value2));
static void gen_binop PARAMS ((struct agent_expr *ax,
			       struct axs_value *value,
			       struct axs_value *value1,
			       struct axs_value *value2,
d126 4
a129 4
static void gen_logical_not PARAMS ((struct agent_expr *ax,
				     struct axs_value *value));
static void gen_complement PARAMS ((struct agent_expr *ax,
				    struct axs_value *value));
d132 4
a135 4
static int find_field PARAMS ((struct type *type, char *name));
static void gen_bitfield_ref PARAMS ((struct agent_expr *ax,
				      struct axs_value *value,
				      struct type *type,
d137 2
a138 2
static void gen_struct_ref PARAMS ((struct agent_expr *ax,
				    struct axs_value *value,
d142 9
a150 9
static void gen_repeat PARAMS ((union exp_element **pc,
				struct agent_expr *ax,
				struct axs_value *value));
static void gen_sizeof PARAMS ((union exp_element **pc,
				struct agent_expr *ax,
				struct axs_value *value));
static void gen_expr PARAMS ((union exp_element **pc,
			      struct agent_expr *ax,
			      struct axs_value *value));
d152 1
a152 1
static void print_axs_value PARAMS ((GDB_FILE *f, struct axs_value *value));
d154 1
a155 1

d188 1
a188 1
      return value_from_longest (type, (LONGEST) SYMBOL_VALUE_ADDRESS (var));
d224 1
a224 1
    /* We could add more operators in here.  */
d252 1
a252 1
 
d255 1
a256 1

d264 5
a268 5
     sometimes we'll swap to get at the left argument to a binary
     operator.  If we decide that void values should occupy no stack
     elements, or that synthetic arrays (whose size is determined at
     run time, created by the `@@' operator) should occupy two stack
     elements (address and length), then this will cause trouble.
d271 5
a275 5
     don't have to worry what happens if the user requests an
     operation that is wider than the actual interpreter's stack.
     That is, it's up to the interpreter to handle directly all the
     integer widths the user has access to.  (Woe betide the language
     with bignums!)
d278 1
a278 1
     GCC's generalized lvalues, function calls, etc.
d281 3
a283 3
     some type don't bother to include cases for floating point; there
     may be even more subtle ways this assumption exists.  For
     example, the arguments to % must be integers.
d286 2
a287 2
     we tried to support convenience variables, this would be a
     problem.
d290 1
a290 1
     sign-extended.
d292 8
a299 7
     (I wasn't sure whether to choose this or its opposite --- that
     only addresses are assumed extended --- but it turns out that
     neither convention completely eliminates spurious extend
     operations (if everything is always extended, then you have to
     extend after add, because it could overflow; if nothing is
     extended, then you end up producing extends whenever you change
     sizes), and this is simpler.)  */
a300 1

d339 1
a339 1
           produce them.  So just dispose of this value.  */
d355 1
a355 1
      break;
d369 1
a371 1

d382 1
a382 1
  if (! TYPE_UNSIGNED (type))
d425 12
a436 4
	case 8  / TARGET_CHAR_BIT: ax_simple (ax, aop_ref8 ); break;
	case 16 / TARGET_CHAR_BIT: ax_simple (ax, aop_ref16); break;
	case 32 / TARGET_CHAR_BIT: ax_simple (ax, aop_ref32); break;
	case 64 / TARGET_CHAR_BIT: ax_simple (ax, aop_ref64); break;
d443 1
a443 1
	  error ("GDB bug: ax-gdb.c (gen_fetch): strange size");
d451 4
a454 4
	 pointer (other code's fault), or we're not implementing
	 something we should be (this code's fault).  In any case,
	 it's a bug the user shouldn't see.  */
      error ("GDB bug: ax-gdb.c (gen_fetch): bad type code");
d478 1
a480 1

d492 1
a492 1
  ax_reg     (ax, frame_reg);
d506 1
a506 1
  ax_reg     (ax, frame_reg);
d575 1
a575 1
      error ("GDB bug: ax-gdb.c (gen_var_ref): LOC_CONST_BYTES symbols are not supported");
d633 3
a635 3
	 register, not on the stack.  Simpler than LOC_REGISTER and
	 LOC_REGPARM, because it's just like any other case where the
	 thing has a real address.  */
d643 3
a645 3
	struct minimal_symbol *msym 
	  = lookup_minimal_symbol (SYMBOL_NAME (var), NULL, NULL);
	if (! msym)
d647 1
a647 1
	
d652 1
a652 1
    break;
d665 1
a667 1

d681 1
a683 1

d709 2
a710 2
	 When we add floating-point support, this is going to have to
	 change.  What about SPARC register pairs, for example?  */
d755 1
a755 1
	 are no longer an lvalue.  */
d764 1
a764 1
    break;
d766 2
a767 2
    /* Don't try to convert structures and unions to rvalues.  Let the
       consumer signal an error.  */
d792 1
a792 1
	      && ! TYPE_UNSIGNED (type2)));
d873 4
a876 4
	 integer types by size, and then by signedness: an n-bit
	 unsigned type is considered "wider" than an n-bit signed
	 type.  Promote to the "wider" of the two types, and always
	 promote at least to int.  */
d906 1
a906 1
  if (! type_wider_than (value->type, builtin_type_int))
d911 1
a911 1
  else if (! type_wider_than (value->type, builtin_type_unsigned_int))
d953 1
a953 1
      
d960 3
a962 3
	 the type and notice that this value doesn't occupy a stack
	 slot.  But for now, leave the value on the stack, and
	 preserve the "value == stack element" assumption.  */
d971 1
a973 1

d1013 1
a1013 1
      gen_extend (ax, value2->type); /* Catch overflow.  */
d1023 1
a1023 1
      gen_extend (ax, value1->type); /* Catch overflow.  */
d1033 1
a1033 1
      gen_extend (ax, value1->type); /* Catch overflow.  */
a1052 2
  struct type *element;

d1060 1
a1060 1
	  gen_extend (ax, value1->type); /* Catch overflow.  */
d1065 2
a1066 2
	 match, but this is what the normal GDB expression evaluator
	 tests for.  */
d1073 1
a1073 1
	  value->type = builtin_type_long; /* FIXME --- should be ptrdiff_t */
d1086 1
a1086 1
      gen_extend (ax, value1->type); /* Catch overflow.  */
d1089 1
a1089 1
  
d1114 1
a1114 1
  
d1118 1
a1118 1
    gen_extend (ax, value1->type); /* catch overflow */
d1152 1
a1154 1

d1166 1
a1166 1
    error ("GDB bug: ax-gdb.c (gen_deref): expected a pointer");
d1225 1
a1225 1
    error ("GDB bug: ax-gdb.c (find_field): derived classes supported");
d1235 1
a1235 1
	error ("GDB bug: ax-gdb.c (find_field): anonymous unions not supported");
d1258 2
a1259 1
    = { aop_ref8, aop_ref16, aop_ref32, aop_ref64 };
d1270 1
a1270 1
		addr
d1272 1
a1272 1
		addr addr
d1276 1
a1276 1
                addr frag1
d1278 5
a1282 5
                frag1 addr                    --- address on top
		frag1 addr addr               --- duplicate it
                frag1 addr frag2              --- get second fragment
                frag1 frag2 addr              --- swap again
                frag1 frag2 frag3             --- get third fragment
d1291 3
a1293 3
  int bound_end   = (((end + TARGET_CHAR_BIT - 1)
		      / TARGET_CHAR_BIT)
		     * TARGET_CHAR_BIT);
d1310 1
a1310 1
    error ("GDB bug: ax-gdb.c (gen_bitfield_ref): bitfield too wide");
d1322 2
a1323 2
	 more fragments, then the address.  */
      
d1330 3
a1332 3
	  if (! last_frag)
	    ax_simple (ax, aop_dup); /* keep a copy of the address */
	  
d1344 2
a1345 2
	
          /* Shift the bits we have to their proper position.
d1349 6
a1354 6
             A big-endian field diagram to ponder:
              byte 0  byte 1  byte 2  byte 3  byte 4  byte 5  byte 6  byte 7
             +------++------++------++------++------++------++------++------+
             xxxxAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBCCCCCxxxxxxxxxxx
                             ^               ^               ^    ^
             bit number      16              32              48   53
d1359 20
a1378 20
             A little-endian field diagram to ponder:
              byte 7  byte 6  byte 5  byte 4  byte 3  byte 2  byte 1  byte 0
             +------++------++------++------++------++------++------++------+
             xxxxxxxxxxxAAAAABBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCxxxx
                            ^               ^               ^           ^   ^
             bit number     48              32              16          4   0

             In both cases, the most significant end is on the left
             (i.e. normal numeric writing order), which means that you
             don't go crazy thinking about `left' and `right' shifts.

             We don't have to worry about masking yet:
             - If they contain garbage off the least significant end, then we
               must be looking at the low end of the field, and the right
               shift will wipe them out.
             - If they contain garbage off the most significant end, then we
               must be looking at the most significant end of the word, and
               the sign/zero extension will wipe them out.
             - If we're in the interior of the word, then there is no garbage
               on either end, because the ref operators zero-extend.  */
d1381 1
a1381 1
	  else 
d1384 1
a1384 1
	  if (! last_frag)
d1445 1
a1445 1
  
d1490 1
a1490 1
    if (! v)
d1502 1
a1502 1
	 done with it.  */
d1504 1
a1504 1
	= create_range_type (0, builtin_type_int, 0, length - 1);
d1533 1
a1533 1
  
d1538 1
a1539 1

d1557 1
a1557 1
    
d1629 2
a1630 2
             that we actually handle in the inner case statement.  */
	  error ("GDB bug: ax-gdb.c (gen_expr): op case sets don't match");
d1635 5
a1639 5
	 for comma.  In C, we can do some optimizations here because
	 we know the left operand is only being evaluated for effect.
	 However, if the tracing kludge is in effect, then we always
	 need to evaluate the left hand side fully, so that all the
	 variables it mentions get traced.  */
d1644 2
a1645 2
	 in which case we want to emit code to trace it if it's an
	 lvalue.  */
d1650 1
a1650 1
      
d1658 1
a1658 1
    break;
d1673 1
a1673 1
    break;
d1678 1
a1678 1
    /* Weirdo operator: see comments for gen_repeat for details.  */
d1692 1
a1692 1
    break;
d1705 1
a1705 1
	  error ("GDB bug: ax-gdb.c (gen_expr): OP_MEMVAL operand isn't an rvalue???");
d1709 1
a1709 1
    break;
d1715 1
a1715 1
      gen_usual_unary (ax, &value1); /* shouldn't do much */
d1752 2
a1753 2
	 of the other unary operator functions.  This is because we
	 have to throw away the code we generate.  */
d1772 2
a1773 2
             shouldn't mention it, and we shouldn't be here.  */
	  error ("GDB bug: ax-gdb.c (gen_expr): unhandled struct case");
d1775 1
a1775 1
    break;
d1784 2
a1785 1
     
a1786 2

#if 0  /* not used */
d1798 1
a1798 1
  struct agent_expr *ax = new_agent_expr ();
d1815 1
d1840 1
a1840 1
#endif /* 0 */
d1875 1
a1877 1

d1882 1
a1882 1
     GDB_FILE *f;
a1912 1
  struct agent_reqs reqs;
d1924 1
a1924 1
  
d1930 3
a1932 1
  ax_reqs (agent, &reqs);
d1937 1
a1938 1

a1944 2
  struct cmd_list_element *c;

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d20 2
@


1.1.1.3
log
@import gdb-1999-06-28 snapshot
@
text
@d1904 1
d1922 1
a1922 3

  /* It would be nice to call ax_reqs here to gather some general info
     about the expression, and then print out the result.  */
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d46 1
a46 2
   Remember, "GBD" stands for "Great Britain, Dammit!"  So be careful.  */

d49 1
d56 4
a59 4

static struct value *const_var_ref PARAMS ((struct symbol * var));
static struct value *const_expr PARAMS ((union exp_element ** pc));
static struct value *maybe_const_expr PARAMS ((union exp_element ** pc));
d69 1
a69 1
static void gen_frame_args_address PARAMS ((struct agent_expr *));
d71 1
a71 1
static void gen_offset PARAMS ((struct agent_expr * ax, int offset));
d73 32
a104 32
static void gen_var_ref PARAMS ((struct agent_expr * ax,
				 struct axs_value * value,
				 struct symbol * var));


static void gen_int_literal PARAMS ((struct agent_expr * ax,
				     struct axs_value * value,
				     LONGEST k, struct type * type));


static void require_rvalue PARAMS ((struct agent_expr * ax,
				    struct axs_value * value));
static void gen_usual_unary PARAMS ((struct agent_expr * ax,
				     struct axs_value * value));
static int type_wider_than PARAMS ((struct type * type1,
				    struct type * type2));
static struct type *max_type PARAMS ((struct type * type1,
				      struct type * type2));
static void gen_conversion PARAMS ((struct agent_expr * ax,
				    struct type * from,
				    struct type * to));
static int is_nontrivial_conversion PARAMS ((struct type * from,
					     struct type * to));
static void gen_usual_arithmetic PARAMS ((struct agent_expr * ax,
					  struct axs_value * value1,
					  struct axs_value * value2));
static void gen_integral_promotions PARAMS ((struct agent_expr * ax,
					     struct axs_value * value));
static void gen_cast PARAMS ((struct agent_expr * ax,
			      struct axs_value * value,
			      struct type * type));
static void gen_scale PARAMS ((struct agent_expr * ax,
d106 5
a110 5
			       struct type * type));
static void gen_add PARAMS ((struct agent_expr * ax,
			     struct axs_value * value,
			     struct axs_value * value1,
			     struct axs_value * value2,
d112 8
a119 8
static void gen_sub PARAMS ((struct agent_expr * ax,
			     struct axs_value * value,
			     struct axs_value * value1,
			     struct axs_value * value2));
static void gen_binop PARAMS ((struct agent_expr * ax,
			       struct axs_value * value,
			       struct axs_value * value1,
			       struct axs_value * value2,
d124 4
a127 4
static void gen_logical_not PARAMS ((struct agent_expr * ax,
				     struct axs_value * value));
static void gen_complement PARAMS ((struct agent_expr * ax,
				    struct axs_value * value));
d130 4
a133 4
static int find_field PARAMS ((struct type * type, char *name));
static void gen_bitfield_ref PARAMS ((struct agent_expr * ax,
				      struct axs_value * value,
				      struct type * type,
d135 2
a136 2
static void gen_struct_ref PARAMS ((struct agent_expr * ax,
				    struct axs_value * value,
d140 9
a148 9
static void gen_repeat PARAMS ((union exp_element ** pc,
				struct agent_expr * ax,
				struct axs_value * value));
static void gen_sizeof PARAMS ((union exp_element ** pc,
				struct agent_expr * ax,
				struct axs_value * value));
static void gen_expr PARAMS ((union exp_element ** pc,
			      struct agent_expr * ax,
			      struct axs_value * value));
d150 1
a150 1
static void print_axs_value PARAMS ((GDB_FILE * f, struct axs_value * value));
d152 1
a153 1

d222 1
a222 1
      /* We could add more operators in here.  */
d250 1
a250 1

d253 1
a254 1

d262 5
a266 5
   sometimes we'll swap to get at the left argument to a binary
   operator.  If we decide that void values should occupy no stack
   elements, or that synthetic arrays (whose size is determined at
   run time, created by the `@@' operator) should occupy two stack
   elements (address and length), then this will cause trouble.
d269 5
a273 5
   don't have to worry what happens if the user requests an
   operation that is wider than the actual interpreter's stack.
   That is, it's up to the interpreter to handle directly all the
   integer widths the user has access to.  (Woe betide the language
   with bignums!)
d276 1
a276 1
   GCC's generalized lvalues, function calls, etc.
d279 3
a281 3
   some type don't bother to include cases for floating point; there
   may be even more subtle ways this assumption exists.  For
   example, the arguments to % must be integers.
d284 2
a285 2
   we tried to support convenience variables, this would be a
   problem.
d288 9
a296 1
   sign-extended.
a297 7
   (I wasn't sure whether to choose this or its opposite --- that
   only addresses are assumed extended --- but it turns out that
   neither convention completely eliminates spurious extend
   operations (if everything is always extended, then you have to
   extend after add, because it could overflow; if nothing is
   extended, then you end up producing extends whenever you change
   sizes), and this is simpler.)  */
a298 1

d337 1
a337 1
	   produce them.  So just dispose of this value.  */
d353 1
a353 1
	break;
a366 1

d369 1
d380 1
a380 1
  if (!TYPE_UNSIGNED (type))
d423 4
a426 12
	case 8 / TARGET_CHAR_BIT:
	  ax_simple (ax, aop_ref8);
	  break;
	case 16 / TARGET_CHAR_BIT:
	  ax_simple (ax, aop_ref16);
	  break;
	case 32 / TARGET_CHAR_BIT:
	  ax_simple (ax, aop_ref32);
	  break;
	case 64 / TARGET_CHAR_BIT:
	  ax_simple (ax, aop_ref64);
	  break;
d441 3
a443 3
         pointer (other code's fault), or we're not implementing
         something we should be (this code's fault).  In any case,
         it's a bug the user shouldn't see.  */
a467 1

d470 1
d482 1
a482 1
  ax_reg (ax, frame_reg);
d496 1
a496 1
  ax_reg (ax, frame_reg);
d623 3
a625 3
         register, not on the stack.  Simpler than LOC_REGISTER and
         LOC_REGPARM, because it's just like any other case where the
         thing has a real address.  */
d633 3
a635 3
	struct minimal_symbol *msym
	= lookup_minimal_symbol (SYMBOL_NAME (var), NULL, NULL);
	if (!msym)
d637 1
a637 1

d642 1
a642 1
      break;
a654 1

d657 1
a670 1

d673 1
d699 2
a700 2
         When we add floating-point support, this is going to have to
         change.  What about SPARC register pairs, for example?  */
d745 1
a745 1
         are no longer an lvalue.  */
d754 1
a754 1
      break;
d756 2
a757 2
      /* Don't try to convert structures and unions to rvalues.  Let the
         consumer signal an error.  */
d782 1
a782 1
	      && !TYPE_UNSIGNED (type2)));
d863 4
a866 4
         integer types by size, and then by signedness: an n-bit
         unsigned type is considered "wider" than an n-bit signed
         type.  Promote to the "wider" of the two types, and always
         promote at least to int.  */
d896 1
a896 1
  if (!type_wider_than (value->type, builtin_type_int))
d901 1
a901 1
  else if (!type_wider_than (value->type, builtin_type_unsigned_int))
d943 1
a943 1

d950 3
a952 3
         the type and notice that this value doesn't occupy a stack
         slot.  But for now, leave the value on the stack, and
         preserve the "value == stack element" assumption.  */
a960 1

d963 1
d1003 1
a1003 1
      gen_extend (ax, value2->type);	/* Catch overflow.  */
d1013 1
a1013 1
      gen_extend (ax, value1->type);	/* Catch overflow.  */
d1023 1
a1023 1
      gen_extend (ax, value1->type);	/* Catch overflow.  */
d1052 1
a1052 1
	  gen_extend (ax, value1->type);	/* Catch overflow.  */
d1057 2
a1058 2
         match, but this is what the normal GDB expression evaluator
         tests for.  */
d1065 1
a1065 1
	  value->type = builtin_type_long;	/* FIXME --- should be ptrdiff_t */
d1078 1
a1078 1
      gen_extend (ax, value1->type);	/* Catch overflow.  */
d1081 1
a1081 1

d1106 1
a1106 1

d1110 1
a1110 1
    gen_extend (ax, value1->type);	/* catch overflow */
a1143 1

d1146 1
d1250 1
a1250 2
  =
  {aop_ref8, aop_ref16, aop_ref32, aop_ref64};
d1261 1
a1261 1
     addr
d1263 1
a1263 1
     addr addr
d1267 1
a1267 1
     addr frag1
d1269 5
a1273 5
     frag1 addr                    --- address on top
     frag1 addr addr               --- duplicate it
     frag1 addr frag2              --- get second fragment
     frag1 frag2 addr              --- swap again
     frag1 frag2 frag3             --- get third fragment
d1282 3
a1284 3
  int bound_end = (((end + TARGET_CHAR_BIT - 1)
		    / TARGET_CHAR_BIT)
		   * TARGET_CHAR_BIT);
d1313 2
a1314 2
         more fragments, then the address.  */

d1321 3
a1323 3
	  if (!last_frag)
	    ax_simple (ax, aop_dup);	/* keep a copy of the address */

d1335 2
a1336 2

	  /* Shift the bits we have to their proper position.
d1340 6
a1345 6
	     A big-endian field diagram to ponder:
	     byte 0  byte 1  byte 2  byte 3  byte 4  byte 5  byte 6  byte 7
	     +------++------++------++------++------++------++------++------+
	     xxxxAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBCCCCCxxxxxxxxxxx
	     ^               ^               ^    ^
	     bit number      16              32              48   53
d1350 20
a1369 20
	     A little-endian field diagram to ponder:
	     byte 7  byte 6  byte 5  byte 4  byte 3  byte 2  byte 1  byte 0
	     +------++------++------++------++------++------++------++------+
	     xxxxxxxxxxxAAAAABBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCxxxx
	     ^               ^               ^           ^   ^
	     bit number     48              32              16          4   0

	     In both cases, the most significant end is on the left
	     (i.e. normal numeric writing order), which means that you
	     don't go crazy thinking about `left' and `right' shifts.

	     We don't have to worry about masking yet:
	     - If they contain garbage off the least significant end, then we
	     must be looking at the low end of the field, and the right
	     shift will wipe them out.
	     - If they contain garbage off the most significant end, then we
	     must be looking at the most significant end of the word, and
	     the sign/zero extension will wipe them out.
	     - If we're in the interior of the word, then there is no garbage
	     on either end, because the ref operators zero-extend.  */
d1372 1
a1372 1
	  else
d1375 1
a1375 1
	  if (!last_frag)
d1436 1
a1436 1

d1481 1
a1481 1
    if (!v)
d1493 1
a1493 1
         done with it.  */
d1495 1
a1495 1
      = create_range_type (0, builtin_type_int, 0, length - 1);
d1524 1
a1524 1

d1529 1
a1530 1

d1548 1
a1548 1

d1620 1
a1620 1
	     that we actually handle in the inner case statement.  */
d1626 5
a1630 5
         for comma.  In C, we can do some optimizations here because
         we know the left operand is only being evaluated for effect.
         However, if the tracing kludge is in effect, then we always
         need to evaluate the left hand side fully, so that all the
         variables it mentions get traced.  */
d1635 2
a1636 2
         in which case we want to emit code to trace it if it's an
         lvalue.  */
d1641 1
a1641 1

d1649 1
a1649 1
      break;
d1664 1
a1664 1
      break;
d1669 1
a1669 1
      /* Weirdo operator: see comments for gen_repeat for details.  */
d1683 1
a1683 1
      break;
d1700 1
a1700 1
      break;
d1706 1
a1706 1
      gen_usual_unary (ax, &value1);	/* shouldn't do much */
d1743 2
a1744 2
         of the other unary operator functions.  This is because we
         have to throw away the code we generate.  */
d1763 1
a1763 1
	     shouldn't mention it, and we shouldn't be here.  */
d1766 1
a1766 1
      break;
d1775 2
d1778 1
a1778 3


#if 0				/* not used */
a1865 1

d1868 1
d1904 1
a1904 1
  struct frame_info *fi = get_current_frame ();		/* need current scope */
d1915 1
a1915 1

d1928 1
a1929 1

@


1.1.1.5
log
@import gdb-1999-09-08 snapshot
@
text
@d1052 2
d1946 2
@


1.1.1.6
log
@import gdb-1999-09-28 snapshot
@
text
@d34 4
a37 5
/* To make sense of this file, you should read doc/agentexpr.texi.
   Then look at the types and enums in ax-gdb.h.  For the code itself,
   look at gen_expr, towards the bottom; that's the main function that
   looks at the GDB expressions and calls everything else to generate
   code.
d442 1
a442 1
	  internal_error ("ax-gdb.c (gen_fetch): strange size");
d453 1
a453 1
      internal_error ("ax-gdb.c (gen_fetch): bad type code");
d574 1
a574 1
      internal_error ("ax-gdb.c (gen_var_ref): LOC_CONST_BYTES symbols are not supported");
d1165 1
a1165 1
    internal_error ("ax-gdb.c (gen_deref): expected a pointer");
d1224 1
a1224 1
    internal_error ("ax-gdb.c (find_field): derived classes supported");
d1234 1
a1234 1
	internal_error ("ax-gdb.c (find_field): anonymous unions not supported");
d1309 1
a1309 1
    internal_error ("ax-gdb.c (gen_bitfield_ref): bitfield too wide");
d1629 1
a1629 1
	  internal_error ("ax-gdb.c (gen_expr): op case sets don't match");
d1704 1
a1704 1
	  internal_error ("ax-gdb.c (gen_expr): OP_MEMVAL operand isn't an rvalue???");
d1772 1
a1772 1
	  internal_error ("ax-gdb.c (gen_expr): unhandled struct case");
d1786 1
d1798 1
a1798 1
  struct agent_expr *ax = new_agent_expr (0);
a1814 1
#if 0				/* not used */
d1839 1
a1839 1
#endif
d1912 1
a1912 1
  struct frame_info *fi = get_current_frame ();	/* need current scope */
@


1.1.1.7
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1998, 2000 Free Software Foundation, Inc.
d152 1
a152 1
static void print_axs_value (struct ui_file *f, struct axs_value * value);
d1882 1
a1882 1
     struct ui_file *f;
@


