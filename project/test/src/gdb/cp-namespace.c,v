head	1.69;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.65.2.2
	gdb_7_6-2013-04-26-release:1.65.2.1
	gdb_7_6-branch:1.65.0.2
	gdb_7_6-2013-03-12-branchpoint:1.65
	gdb_7_5_1-2012-11-29-release:1.58
	gdb_7_5-2012-08-17-release:1.58
	gdb_7_5-branch:1.58.0.2
	gdb_7_5-2012-07-18-branchpoint:1.58
	gdb_7_4_1-2012-04-26-release:1.56.2.1
	gdb_7_4-2012-01-24-release:1.56.2.1
	gdb_7_4-branch:1.56.0.2
	gdb_7_4-2011-12-13-branchpoint:1.56
	gdb_7_3_1-2011-09-04-release:1.49.2.1
	gdb_7_3-2011-07-26-release:1.49.2.1
	gdb_7_3-branch:1.49.0.2
	gdb_7_3-2011-04-01-branchpoint:1.49
	gdb_7_2-2010-09-02-release:1.43
	gdb_7_2-branch:1.43.0.2
	gdb_7_2-2010-07-07-branchpoint:1.43
	gdb_7_1-2010-03-18-release:1.34
	gdb_7_1-branch:1.34.0.2
	gdb_7_1-2010-02-18-branchpoint:1.34
	gdb_7_0_1-2009-12-22-release:1.28
	gdb_7_0-2009-10-06-release:1.28
	gdb_7_0-branch:1.28.0.4
	gdb_7_0-2009-09-16-branchpoint:1.28
	arc-sim-20090309:1.21
	msnyder-checkpoint-072509-branch:1.28.0.2
	msnyder-checkpoint-072509-branchpoint:1.28
	arc-insight_6_8-branch:1.21.0.6
	arc-insight_6_8-branchpoint:1.21
	insight_6_8-branch:1.21.0.4
	insight_6_8-branchpoint:1.21
	reverse-20081226-branch:1.23.0.6
	reverse-20081226-branchpoint:1.23
	multiprocess-20081120-branch:1.23.0.4
	multiprocess-20081120-branchpoint:1.23
	reverse-20080930-branch:1.23.0.2
	reverse-20080930-branchpoint:1.23
	reverse-20080717-branch:1.22.0.4
	reverse-20080717-branchpoint:1.22
	msnyder-reverse-20080609-branch:1.22.0.2
	msnyder-reverse-20080609-branchpoint:1.22
	drow-reverse-20070409-branch:1.18.0.2
	drow-reverse-20070409-branchpoint:1.18
	gdb_6_8-2008-03-27-release:1.21
	gdb_6_8-branch:1.21.0.2
	gdb_6_8-2008-02-26-branchpoint:1.21
	gdb_6_7_1-2007-10-29-release:1.20
	gdb_6_7-2007-10-10-release:1.20
	gdb_6_7-branch:1.20.0.2
	gdb_6_7-2007-09-07-branchpoint:1.20
	insight_6_6-20070208-release:1.17
	gdb_6_6-2006-12-18-release:1.17
	gdb_6_6-branch:1.17.0.18
	gdb_6_6-2006-11-15-branchpoint:1.17
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.16
	nickrob-async-20060828-mergepoint:1.17
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.17
	gdb-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.16
	gdb_6_5-2006-05-14-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.14
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.12
	msnyder-reverse-20060502-branchpoint:1.17
	gdb-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	readline_5_1-import-branch:1.17.0.10
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.8
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.6
	msnyder-reverse-20060331-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.4
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.2
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.16
	msnyder-fork-checkpoint-branch:1.16.0.12
	msnyder-fork-checkpoint-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.16.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.16
	gdb_6_4-branch:1.16.0.8
	gdb_6_4-2005-11-01-branchpoint:1.16
	gdb-csl-arm-20051020-branch:1.16.0.6
	gdb-csl-arm-20051020-branchpoint:1.16
	msnyder-tracepoint-checkpoint-branch:1.16.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.16
	gdb-csl-arm-20050325-2005-q1b:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	csl-arm-20050325-branch:1.16.0.2
	csl-arm-20050325-branchpoint:1.16
	gdb-post-i18n-errorwarning-20050211:1.13
	gdb-pre-i18n-errorwarning-20050211:1.13
	gdb_6_3-20041109-release:1.13
	gdb_6_3-branch:1.13.0.8
	gdb_6_3-20041019-branchpoint:1.13
	drow_intercu-merge-20040921:1.13
	drow_intercu-merge-20040915:1.13
	jimb-gdb_6_2-e500-branch:1.13.0.10
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.6
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.12.6.1
	gdb_6_1-2004-04-05-release:1.12.6.1
	drow_intercu-merge-20040402:1.13
	drow_intercu-merge-20040327:1.13
	ezannoni_pie-20040323-branch:1.13.0.4
	ezannoni_pie-20040323-branchpoint:1.13
	cagney_tramp-20040321-mergepoint:1.13
	cagney_tramp-20040309-branch:1.13.0.2
	cagney_tramp-20040309-branchpoint:1.13
	gdb_6_1-branch:1.12.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.12
	drow_intercu-20040221-branch:1.12.0.4
	drow_intercu-20040221-branchpoint:1.12
	cagney_bfdfile-20040213-branch:1.12.0.2
	cagney_bfdfile-20040213-branchpoint:1.12
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.10
	cagney_bigcore-20040122-branch:1.9.0.2
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.8
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-branch:1.7.0.2
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.4.0.4
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.2
	cagney_x86i386-20030821-branch:1.3.0.6
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.4
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.2.0.6
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.1.0.8
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.2.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.2
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.4
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-branch:1.1.0.2
	carlton_dictionary-20030416-merge:1.1;
locks; strict;
comment	@ * @;


1.69
date	2013.08.20.15.04.51;	author tromey;	state Exp;
branches;
next	1.68;

1.68
date	2013.06.05.22.28.51;	author devans;	state Exp;
branches;
next	1.67;

1.67
date	2013.05.30.17.29.06;	author tromey;	state Exp;
branches;
next	1.66;

1.66
date	2013.03.14.11.13.34;	author sergiodj;	state Exp;
branches;
next	1.65;

1.65
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2013.01.25.17.55.24;	author tromey;	state Exp;
branches;
next	1.63;

1.63
date	2013.01.25.17.36.01;	author tromey;	state Exp;
branches;
next	1.62;

1.62
date	2013.01.21.18.13.13;	author tromey;	state Exp;
branches;
next	1.61;

1.61
date	2013.01.01.06.32.40;	author brobecke;	state Exp;
branches;
next	1.60;

1.60
date	2012.11.16.20.54.29;	author kseitz;	state Exp;
branches;
next	1.59;

1.59
date	2012.11.13.09.46.10;	author muller;	state Exp;
branches;
next	1.58;

1.58
date	2012.06.13.16.10.07;	author jkratoch;	state Exp;
branches;
next	1.57;

1.57
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.56;

1.56
date	2011.11.04.16.37.17;	author tromey;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2011.10.20.20.06.13;	author aristovski;	state Exp;
branches;
next	1.54;

1.54
date	2011.06.29.22.05.15;	author jkratoch;	state Exp;
branches;
next	1.53;

1.53
date	2011.06.29.22.02.58;	author jkratoch;	state Exp;
branches;
next	1.52;

1.52
date	2011.05.31.21.54.07;	author kseitz;	state Exp;
branches;
next	1.51;

1.51
date	2011.05.06.14.12.17;	author jkratoch;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.04.14.37.16;	author tromey;	state Exp;
branches;
next	1.49;

1.49
date	2011.02.26.02.07.07;	author msnyder;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2011.01.05.22.22.47;	author msnyder;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.01.15.32.59;	author brobecke;	state Exp;
branches;
next	1.46;

1.46
date	2010.12.31.22.59.52;	author msnyder;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.09.19.42.46;	author swagiaal;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.28.16.23.56;	author tromey;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.28.20.35.52;	author jkratoch;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.13.23.53.32;	author msnyder;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.07.01.12.12;	author msnyder;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.03.20.10.22;	author jkratoch;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.26.09.30.10;	author jkratoch;	state Exp;
branches;
next	1.38;

1.38
date	2010.03.15.17.29.36;	author swagiaal;	state Exp;
branches;
next	1.37;

1.37
date	2010.03.10.16.22.29;	author swagiaal;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.35;

1.35
date	2010.02.19.20.22.03;	author tromey;	state Exp;
branches;
next	1.34;

1.34
date	2010.02.05.19.03.40;	author swagiaal;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2010.01.26.16.47.34;	author swagiaal;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.26.15.48.25;	author swagiaal;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.19.09.39.12;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.16.18.40.21;	author tromey;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.07.17.25.11;	author swagiaal;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.29.15.18.07;	author swagiaal;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.23.17.46.51;	author swagiaal;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.21.16.14.47;	author palves;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.21.18.40.34;	author drow;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2008.05.19.15.49.14;	author uweigand;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2007.08.23.18.08.27;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.03.12.14.43;	author uweigand;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.14.18.10.07;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.12.00.39.18;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.11.18.13.48;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.05.17.32.23;	author carlton;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.09.22.19.26;	author drow;	state Exp;
branches
	1.12.4.1
	1.12.6.1;
next	1.11;

1.11
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.23.23.03.29;	author carlton;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.14.16.54.41;	author carlton;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.09.22.22.07;	author ezannoni;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.13.19.34.02;	author carlton;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2003.11.13.17.28.37;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.25.16.39.38;	author carlton;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.11.19.49.17;	author carlton;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.13.00.55.43;	author carlton;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.20.03.56.28;	author carlton;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.15.23.07.11;	author carlton;	state Exp;
branches
	1.1.2.1;
next	;

1.65.2.1
date	2013.03.18.09.20.02;	author sergiodj;	state Exp;
branches;
next	1.65.2.2;

1.65.2.2
date	2013.06.27.22.18.33;	author devans;	state Exp;
branches;
next	;

1.56.2.1
date	2012.01.06.04.43.06;	author brobecke;	state Exp;
branches;
next	;

1.49.2.1
date	2011.07.02.19.37.21;	author jkratoch;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2011.10.25.18.32.25;	author aristovski;	state Exp;
branches;
next	;

1.34.2.1
date	2010.04.08.17.15.10;	author swagiaal;	state Exp;
branches;
next	;

1.23.4.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	;

1.12.4.1
date	2004.03.27.17.37.45;	author drow;	state Exp;
branches;
next	;

1.12.6.1
date	2004.03.05.18.04.21;	author carlton;	state Exp;
branches;
next	;

1.7.2.1
date	2003.12.14.20.27.10;	author drow;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2004.01.13.16.11.53;	author drow;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2004.02.09.19.43.35;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2003.04.16.19.56.51;	author carlton;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.04.30.23.11.31;	author carlton;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.05.01.00.46.47;	author carlton;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.05.23.18.40.35;	author carlton;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.05.23.22.28.54;	author carlton;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.06.16.20.00.45;	author carlton;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2003.06.27.21.49.51;	author carlton;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2003.06.27.22.47.33;	author carlton;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2003.09.17.21.28.13;	author carlton;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2003.09.30.18.16.06;	author carlton;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2003.11.12.00.20.58;	author carlton;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2003.12.16.00.00.25;	author carlton;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2004.01.26.19.11.22;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.69
log
@move gdbarch object from objfile to per-BFD

This moves the "gdbarch" field from the objfile into the BFD.

This field's value is derived from the BFD and is immutable over the
lifetime of the BFD.  This makes it a reasonable candidate for pushing
into the per-BFD object.

This is part of the long-term objfile splitting project.  In the long
run I think this patch will make it simpler to moves types from the
objfile to the per-BFD object; but the patch makes sense as a minor
cleanup by itself.

Built and regtested on x86-64 Fedora 18.

	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Use
	get_objfile_arch.
	* elfread.c (elf_rel_plt_read, elf_gnu_ifunc_record_cache)
	(elf_gnu_ifunc_resolve_by_got): Use get_objfile_arch.
	* jit.c (jit_object_close_impl): Update.
	* jv-lang.c (get_dynamics_objfile): Update.
	* linespec.c (add_minsym): Use get_dynamics_objfile.
	* objfiles.c (get_objfile_bfd_data): Initialize 'gdbarch' field.
	(allocate_objfile): Don't initialize 'gdbarch' field.
	(get_objfile_arch): Update.
	* objfiles.h (struct objfile_per_bfd_storage) <gdbarch>: New field,
	moved from...
	(struct objfile) <gdbarch>: ... here.  Remove.
	* stap-probe.c (stap_can_evaluate_probe_arguments): Use
	get_objfile_arch.
	* symfile.c (init_entry_point_info): Use get_objfile_arch.
@
text
@/* Helper routines for C++ support in GDB.
   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   Contributed by David Carlton and by Kealia, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "cp-support.h"
#include "gdb_obstack.h"
#include "symtab.h"
#include "symfile.h"
#include "gdb_assert.h"
#include "block.h"
#include "objfiles.h"
#include "gdbtypes.h"
#include "dictionary.h"
#include "command.h"
#include "frame.h"
#include "buildsym.h"
#include "language.h"

static struct symbol *lookup_namespace_scope (const char *name,
					      const struct block *block,
					      const domain_enum domain,
					      const char *scope,
					      int scope_len);

static struct symbol *lookup_symbol_file (const char *name,
					  const struct block *block,
					  const domain_enum domain,
					  int anonymous_namespace,
					  int search);

static struct type *cp_lookup_transparent_type_loop (const char *name,
						     const char *scope,
						     int scope_len);

/* Check to see if SYMBOL refers to an object contained within an
   anonymous namespace; if so, add an appropriate using directive.  */

void
cp_scan_for_anonymous_namespaces (const struct symbol *const symbol,
				  struct objfile *const objfile)
{
  if (SYMBOL_DEMANGLED_NAME (symbol) != NULL)
    {
      const char *name = SYMBOL_DEMANGLED_NAME (symbol);
      unsigned int previous_component;
      unsigned int next_component;

      /* Start with a quick-and-dirty check for mention of "(anonymous
	 namespace)".  */

      if (!cp_is_anonymous (name))
	return;

      previous_component = 0;
      next_component = cp_find_first_component (name + previous_component);

      while (name[next_component] == ':')
	{
	  if (((next_component - previous_component)
	       == CP_ANONYMOUS_NAMESPACE_LEN)
	      && strncmp (name + previous_component,
			  CP_ANONYMOUS_NAMESPACE_STR,
			  CP_ANONYMOUS_NAMESPACE_LEN) == 0)
	    {
	      int dest_len = (previous_component == 0
			      ? 0 : previous_component - 2);
	      int src_len = next_component;

	      char *dest = alloca (dest_len + 1);
	      char *src = alloca (src_len + 1);

	      memcpy (dest, name, dest_len);
	      memcpy (src, name, src_len);

	      dest[dest_len] = '\0';
	      src[src_len] = '\0';

	      /* We've found a component of the name that's an
		 anonymous namespace.  So add symbols in it to the
		 namespace given by the previous component if there is
		 one, or to the global namespace if there isn't.  */
	      cp_add_using_directive (dest, src, NULL, NULL, NULL, 1,
	                              &objfile->objfile_obstack);
	    }
	  /* The "+ 2" is for the "::".  */
	  previous_component = next_component + 2;
	  next_component = (previous_component
			    + cp_find_first_component (name
						       + previous_component));
	}
    }
}


/* Add a using directive to using_directives.  If the using directive
   in question has already been added, don't add it twice.

   Create a new struct using_direct which imports the namespace SRC
   into the scope DEST.  ALIAS is the name of the imported namespace
   in the current scope.  If ALIAS is NULL then the namespace is known
   by its original name.  DECLARATION is the name if the imported
   varable if this is a declaration import (Eg. using A::x), otherwise
   it is NULL.  EXCLUDES is a list of names not to import from an
   imported module or NULL.  If COPY_NAMES is non-zero, then the
   arguments are copied into newly allocated memory so they can be
   temporaries.  For EXCLUDES the VEC pointers are copied but the
   pointed to characters are not copied.  */

void
cp_add_using_directive (const char *dest,
			const char *src,
			const char *alias,
			const char *declaration,
			VEC (const_char_ptr) *excludes,
			int copy_names,
                        struct obstack *obstack)
{
  struct using_direct *current;
  struct using_direct *new;
  
  /* Has it already been added?  */

  for (current = using_directives; current != NULL; current = current->next)
    {
      int ix;
      const char *param;

      if (strcmp (current->import_src, src) != 0)
	continue;
      if (strcmp (current->import_dest, dest) != 0)
	continue;
      if ((alias == NULL && current->alias != NULL)
	  || (alias != NULL && current->alias == NULL)
	  || (alias != NULL && current->alias != NULL
	      && strcmp (alias, current->alias) != 0))
	continue;
      if ((declaration == NULL && current->declaration != NULL)
	  || (declaration != NULL && current->declaration == NULL)
	  || (declaration != NULL && current->declaration != NULL
	      && strcmp (declaration, current->declaration) != 0))
	continue;

      /* Compare the contents of EXCLUDES.  */
      for (ix = 0; VEC_iterate (const_char_ptr, excludes, ix, param); ix++)
	if (current->excludes[ix] == NULL
	    || strcmp (param, current->excludes[ix]) != 0)
	  break;
      if (ix < VEC_length (const_char_ptr, excludes)
	  || current->excludes[ix] != NULL)
	continue;

      /* Parameters exactly match CURRENT.  */
      return;
    }

  new = obstack_alloc (obstack, (sizeof (*new)
				 + (VEC_length (const_char_ptr, excludes)
				    * sizeof (*new->excludes))));
  memset (new, 0, sizeof (*new));

  if (copy_names)
    {
      new->import_src = obstack_copy0 (obstack, src, strlen (src));
      new->import_dest = obstack_copy0 (obstack, dest, strlen (dest));
    }
  else
    {
      new->import_src = src;
      new->import_dest = dest;
    }

  if (alias != NULL && copy_names)
    new->alias = obstack_copy0 (obstack, alias, strlen (alias));
  else
    new->alias = alias;

  if (declaration != NULL && copy_names)
    new->declaration = obstack_copy0 (obstack,
				      declaration, strlen (declaration));
  else
    new->declaration = declaration;

  memcpy (new->excludes, VEC_address (const_char_ptr, excludes),
	  VEC_length (const_char_ptr, excludes) * sizeof (*new->excludes));
  new->excludes[VEC_length (const_char_ptr, excludes)] = NULL;

  new->next = using_directives;
  using_directives = new;
}

/* Test whether or not NAMESPACE looks like it mentions an anonymous
   namespace; return nonzero if so.  */

int
cp_is_anonymous (const char *namespace)
{
  return (strstr (namespace, CP_ANONYMOUS_NAMESPACE_STR)
	  != NULL);
}

/* The C++-specific version of name lookup for static and global
   names.  This makes sure that names get looked for in all namespaces
   that are in scope.  NAME is the natural name of the symbol that
   we're looking for, BLOCK is the block that we're searching within,
   DOMAIN says what kind of symbols we're looking for, and if SYMTAB
   is non-NULL, we should store the symtab where we found the symbol
   in it.  */

struct symbol *
cp_lookup_symbol_nonlocal (const char *name,
			   const struct block *block,
			   const domain_enum domain)
{
  struct symbol *sym;
  const char *scope = block_scope (block);

  sym = lookup_namespace_scope (name, block,
				domain, scope, 0);
  if (sym != NULL)
    return sym;

  return cp_lookup_symbol_namespace (scope, name,
				     block, domain);
}

/* Look up NAME in the C++ namespace NAMESPACE.  Other arguments are
   as in cp_lookup_symbol_nonlocal.  If SEARCH is non-zero, search
   through base classes for a matching symbol.  */

static struct symbol *
cp_lookup_symbol_in_namespace (const char *namespace,
                               const char *name,
                               const struct block *block,
                               const domain_enum domain, int search)
{
  if (namespace[0] == '\0')
    {
      return lookup_symbol_file (name, block, domain, 0, search);
    }
  else
    {
      char *concatenated_name = alloca (strlen (namespace) + 2
					+ strlen (name) + 1);

      strcpy (concatenated_name, namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, name);
      return lookup_symbol_file (concatenated_name, block, domain,
				 cp_is_anonymous (namespace), search);
    }
}

/* Used for cleanups to reset the "searched" flag incase
   of an error.  */

static void
reset_directive_searched (void *data)
{
  struct using_direct *direct = data;
  direct->searched = 0;
}

/* Search for NAME by applying all import statements belonging to
   BLOCK which are applicable in SCOPE.  If DECLARATION_ONLY the
   search is restricted to using declarations.
   Example:

     namespace A {
       int x;
     }
     using A::x;

   If SEARCH_PARENTS the search will include imports which are
   applicable in parents of SCOPE.
   Example:

     namespace A {
       using namespace X;
       namespace B {
         using namespace Y;
       }
     }

   If SCOPE is "A::B" and SEARCH_PARENTS is true the imports of
   namespaces X and Y will be considered.  If SEARCH_PARENTS is false
   only the import of Y is considered.  */

struct symbol *
cp_lookup_symbol_imports (const char *scope,
                          const char *name,
                          const struct block *block,
                          const domain_enum domain,
                          const int declaration_only,
                          const int search_parents)
{
  struct using_direct *current;
  struct symbol *sym = NULL;
  int len;
  int directive_match;
  struct cleanup *searched_cleanup;

  /* First, try to find the symbol in the given namespace.  */
  if (!declaration_only)
    sym = cp_lookup_symbol_in_namespace (scope, name,
					 block, domain, 1);
  
  if (sym != NULL)
    return sym;

  /* Go through the using directives.  If any of them add new names to
     the namespace we're searching in, see if we can find a match by
     applying them.  */

  for (current = block_using (block);
       current != NULL;
       current = current->next)
    {
      const char **excludep;

      len = strlen (current->import_dest);
      directive_match = (search_parents
                         ? (strncmp (scope, current->import_dest,
                                     strlen (current->import_dest)) == 0
                            && (len == 0
                                || scope[len] == ':'
				|| scope[len] == '\0'))
                         : strcmp (scope, current->import_dest) == 0);

      /* If the import destination is the current scope or one of its
         ancestors then it is applicable.  */
      if (directive_match && !current->searched)
	{
	  /* Mark this import as searched so that the recursive call
	     does not search it again.  */
	  current->searched = 1;
	  searched_cleanup = make_cleanup (reset_directive_searched,
					   current);

	  /* If there is an import of a single declaration, compare the
	     imported declaration (after optional renaming by its alias)
	     with the sought out name.  If there is a match pass
	     current->import_src as NAMESPACE to direct the search
	     towards the imported namespace.  */
	  if (current->declaration
	      && strcmp (name, current->alias
			 ? current->alias : current->declaration) == 0)
	    sym = cp_lookup_symbol_in_namespace (current->import_src,
						 current->declaration,
						 block, domain, 1);

	  /* If this is a DECLARATION_ONLY search or a symbol was found
	     or this import statement was an import declaration, the
	     search of this import is complete.  */
	  if (declaration_only || sym != NULL || current->declaration)
	    {
	      current->searched = 0;
	      discard_cleanups (searched_cleanup);

	      if (sym != NULL)
		return sym;

	      continue;
	    }

	  /* Do not follow CURRENT if NAME matches its EXCLUDES.  */
	  for (excludep = current->excludes; *excludep; excludep++)
	    if (strcmp (name, *excludep) == 0)
	      break;
	  if (*excludep)
	    {
	      discard_cleanups (searched_cleanup);
	      continue;
	    }

	  if (current->alias != NULL
	      && strcmp (name, current->alias) == 0)
	    /* If the import is creating an alias and the alias matches
	       the sought name.  Pass current->import_src as the NAME to
	       direct the search towards the aliased namespace.  */
	    {
	      sym = cp_lookup_symbol_in_namespace (scope,
						   current->import_src,
						   block, domain, 1);
	    }
	  else if (current->alias == NULL)
	    {
	      /* If this import statement creates no alias, pass
		 current->inner as NAMESPACE to direct the search
		 towards the imported namespace.  */
	      sym = cp_lookup_symbol_imports (current->import_src,
					      name, block,
					      domain, 0, 0);
	    }
	  current->searched = 0;
	  discard_cleanups (searched_cleanup);

	  if (sym != NULL)
	    return sym;
	}
    }

  return NULL;
}

/* Helper function that searches an array of symbols for one named
   NAME.  */

static struct symbol *
search_symbol_list (const char *name, int num,
		    struct symbol **syms)
{
  int i;

  /* Maybe we should store a dictionary in here instead.  */
  for (i = 0; i < num; ++i)
    {
      if (strcmp (name, SYMBOL_NATURAL_NAME (syms[i])) == 0)
	return syms[i];
    }
  return NULL;
}

/* Like cp_lookup_symbol_imports, but if BLOCK is a function, it
   searches through the template parameters of the function and the
   function's type.  */

struct symbol *
cp_lookup_symbol_imports_or_template (const char *scope,
				      const char *name,
				      const struct block *block,
				      const domain_enum domain)
{
  struct symbol *function = BLOCK_FUNCTION (block);

  if (function != NULL && SYMBOL_LANGUAGE (function) == language_cplus)
    {
      /* Search the function's template parameters.  */
      if (SYMBOL_IS_CPLUS_TEMPLATE_FUNCTION (function))
	{
	  struct template_symbol *templ 
	    = (struct template_symbol *) function;
	  struct symbol *result;

	  result = search_symbol_list (name,
				       templ->n_template_arguments,
				       templ->template_arguments);
	  if (result != NULL)
	    return result;
	}

      /* Search the template parameters of the function's defining
	 context.  */
      if (SYMBOL_NATURAL_NAME (function))
	{
	  struct type *context;
	  char *name_copy = xstrdup (SYMBOL_NATURAL_NAME (function));
	  struct cleanup *cleanups = make_cleanup (xfree, name_copy);
	  const struct language_defn *lang = language_def (language_cplus);
	  struct gdbarch *arch
	    = get_objfile_arch (SYMBOL_SYMTAB (function)->objfile);
	  const struct block *parent = BLOCK_SUPERBLOCK (block);

	  while (1)
	    {
	      struct symbol *result;
	      unsigned int prefix_len = cp_entire_prefix_len (name_copy);

	      if (prefix_len == 0)
		context = NULL;
	      else
		{
		  name_copy[prefix_len] = '\0';
		  context = lookup_typename (lang, arch,
					     name_copy,
					     parent, 1);
		}

	      if (context == NULL)
		break;

	      result
		= search_symbol_list (name,
				      TYPE_N_TEMPLATE_ARGUMENTS (context),
				      TYPE_TEMPLATE_ARGUMENTS (context));
	      if (result != NULL)
		{
		  do_cleanups (cleanups);
		  return result;
		}
	    }

	  do_cleanups (cleanups);
	}
    }

  return cp_lookup_symbol_imports (scope, name, block, domain, 1, 1);
}

 /* Searches for NAME in the current namespace, and by applying
    relevant import statements belonging to BLOCK and its parents.
    SCOPE is the namespace scope of the context in which the search is
    being evaluated.  */

struct symbol*
cp_lookup_symbol_namespace (const char *scope,
                            const char *name,
                            const struct block *block,
                            const domain_enum domain)
{
  struct symbol *sym;
  
  /* First, try to find the symbol in the given namespace.  */
  sym = cp_lookup_symbol_in_namespace (scope, name,
				       block, domain, 1);
  if (sym != NULL)
    return sym;

  /* Search for name in namespaces imported to this and parent
     blocks.  */
  while (block != NULL)
    {
      sym = cp_lookup_symbol_imports (scope, name, block,
				      domain, 0, 1);

      if (sym)
	return sym;

      block = BLOCK_SUPERBLOCK (block);
    }

  return NULL;
}

/* Lookup NAME at namespace scope (or, in C terms, in static and
   global variables).  SCOPE is the namespace that the current
   function is defined within; only consider namespaces whose length
   is at least SCOPE_LEN.  Other arguments are as in
   cp_lookup_symbol_nonlocal.

   For example, if we're within a function A::B::f and looking for a
   symbol x, this will get called with NAME = "x", SCOPE = "A::B", and
   SCOPE_LEN = 0.  It then calls itself with NAME and SCOPE the same,
   but with SCOPE_LEN = 1.  And then it calls itself with NAME and
   SCOPE the same, but with SCOPE_LEN = 4.  This third call looks for
   "A::B::x"; if it doesn't find it, then the second call looks for
   "A::x", and if that call fails, then the first call looks for
   "x".  */

static struct symbol *
lookup_namespace_scope (const char *name,
			const struct block *block,
			const domain_enum domain,
			const char *scope,
			int scope_len)
{
  char *namespace;

  if (scope[scope_len] != '\0')
    {
      /* Recursively search for names in child namespaces first.  */

      struct symbol *sym;
      int new_scope_len = scope_len;

      /* If the current scope is followed by "::", skip past that.  */
      if (new_scope_len != 0)
	{
	  gdb_assert (scope[new_scope_len] == ':');
	  new_scope_len += 2;
	}
      new_scope_len += cp_find_first_component (scope + new_scope_len);
      sym = lookup_namespace_scope (name, block, domain,
				    scope, new_scope_len);
      if (sym != NULL)
	return sym;
    }

  /* Okay, we didn't find a match in our children, so look for the
     name in the current namespace.  */

  namespace = alloca (scope_len + 1);
  strncpy (namespace, scope, scope_len);
  namespace[scope_len] = '\0';
  return cp_lookup_symbol_in_namespace (namespace, name,
					block, domain, 1);
}

/* Look up NAME in BLOCK's static block and in global blocks.  If
   ANONYMOUS_NAMESPACE is nonzero, the symbol in question is located
   within an anonymous namespace.  If SEARCH is non-zero, search through
   base classes for a matching symbol.  Other arguments are as in
   cp_lookup_symbol_nonlocal.  */

static struct symbol *
lookup_symbol_file (const char *name,
		    const struct block *block,
		    const domain_enum domain,
		    int anonymous_namespace, int search)
{
  struct symbol *sym = NULL;

  sym = lookup_symbol_static (name, block, domain);
  if (sym != NULL)
    return sym;

  if (anonymous_namespace)
    {
      /* Symbols defined in anonymous namespaces have external linkage
	 but should be treated as local to a single file nonetheless.
	 So we only search the current file's global block.  */

      const struct block *global_block = block_global_block (block);
      
      if (global_block != NULL)
	sym = lookup_symbol_aux_block (name, global_block, domain);
    }
  else
    {
      sym = lookup_symbol_global (name, block, domain);
    }

  if (sym != NULL)
    return sym;

  if (search)
    {
      char *klass, *nested;
      unsigned int prefix_len;
      struct cleanup *cleanup;
      struct symbol *klass_sym;

      /* A simple lookup failed.  Check if the symbol was defined in
	 a base class.  */

      cleanup = make_cleanup (null_cleanup, NULL);

      /* Find the name of the class and the name of the method,
	 variable, etc.  */
      prefix_len = cp_entire_prefix_len (name);

      /* If no prefix was found, search "this".  */
      if (prefix_len == 0)
	{
	  struct type *type;
	  struct symbol *this;

	  this = lookup_language_this (language_def (language_cplus), block);
	  if (this == NULL)
	    {
	      do_cleanups (cleanup);
	      return NULL;
	    }

	  type = check_typedef (TYPE_TARGET_TYPE (SYMBOL_TYPE (this)));
	  klass = xstrdup (TYPE_NAME (type));
	  nested = xstrdup (name);
	}
      else
	{
	  /* The class name is everything up to and including PREFIX_LEN.  */
	  klass = savestring (name, prefix_len);

	  /* The rest of the name is everything else past the initial scope
	     operator.  */
	  nested = xstrdup (name + prefix_len + 2);
	}

      /* Add cleanups to free memory for these strings.  */
      make_cleanup (xfree, klass);
      make_cleanup (xfree, nested);

      /* Lookup a class named KLASS.  If none is found, there is nothing
	 more that can be done.  */
      klass_sym = lookup_symbol_global (klass, block, domain);
      if (klass_sym == NULL)
	{
	  do_cleanups (cleanup);
	  return NULL;
	}

      /* Look for a symbol named NESTED in this class.  */
      sym = cp_lookup_nested_symbol (SYMBOL_TYPE (klass_sym), nested, block);
      do_cleanups (cleanup);
    }

  return sym;
}

/* Search through the base classes of PARENT_TYPE for a symbol named
   NAME in block BLOCK.  */

static struct symbol *
find_symbol_in_baseclass (struct type *parent_type, const char *name,
			   const struct block *block)
{
  int i;
  struct symbol *sym;
  struct cleanup *cleanup;
  char *concatenated_name;

  sym = NULL;
  concatenated_name = NULL;
  cleanup = make_cleanup (free_current_contents, &concatenated_name);
  for (i = 0; i < TYPE_N_BASECLASSES (parent_type); ++i)
    {
      size_t len;
      struct type *base_type = TYPE_BASECLASS (parent_type, i);
      const char *base_name = TYPE_BASECLASS_NAME (parent_type, i);

      if (base_name == NULL)
	continue;

      /* Search this particular base class.  */
      sym = cp_lookup_symbol_in_namespace (base_name, name, block,
					   VAR_DOMAIN, 0);
      if (sym != NULL)
	break;

      /* Now search all static file-level symbols.  We have to do this for
	 things like typedefs in the class.  First search in this symtab,
	 what we want is possibly there.  */
      len = strlen (base_name) + 2 + strlen (name) + 1;
      concatenated_name = xrealloc (concatenated_name, len);
      xsnprintf (concatenated_name, len, "%s::%s", base_name, name);
      sym = lookup_symbol_static (concatenated_name, block, VAR_DOMAIN);
      if (sym != NULL)
	break;

      /* Nope.  We now have to search all static blocks in all objfiles,
	 even if block != NULL, because there's no guarantees as to which
	 symtab the symbol we want is in.  */
      sym = lookup_static_symbol_aux (concatenated_name, VAR_DOMAIN);
      if (sym != NULL)
	break;

      /* If this class has base classes, search them next.  */
      CHECK_TYPEDEF (base_type);
      if (TYPE_N_BASECLASSES (base_type) > 0)
	{
	  sym = find_symbol_in_baseclass (base_type, name, block);
	  if (sym != NULL)
	    break;
	}
    }

  do_cleanups (cleanup);
  return sym;
}

/* Look up a symbol named NESTED_NAME that is nested inside the C++
   class or namespace given by PARENT_TYPE, from within the context
   given by BLOCK.  Return NULL if there is no such nested type.  */

struct symbol *
cp_lookup_nested_symbol (struct type *parent_type,
			 const char *nested_name,
			 const struct block *block)
{
  /* type_name_no_tag_required provides better error reporting using the
     original type.  */
  struct type *saved_parent_type = parent_type;

  CHECK_TYPEDEF (parent_type);

  switch (TYPE_CODE (parent_type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_NAMESPACE:
    case TYPE_CODE_UNION:
      {
	/* NOTE: carlton/2003-11-10: We don't treat C++ class members
	   of classes like, say, data or function members.  Instead,
	   they're just represented by symbols whose names are
	   qualified by the name of the surrounding class.  This is
	   just like members of namespaces; in particular,
	   lookup_symbol_namespace works when looking them up.  */

	int size;
	const char *parent_name = type_name_no_tag_or_error (saved_parent_type);
	struct symbol *sym
	  = cp_lookup_symbol_in_namespace (parent_name, nested_name,
					   block, VAR_DOMAIN, 0);
	char *concatenated_name;

	if (sym != NULL)
	  return sym;

	/* Now search all static file-level symbols.  We have to do this
	   for things like typedefs in the class.  We do not try to
	   guess any imported namespace as even the fully specified
	   namespace search is already not C++ compliant and more
	   assumptions could make it too magic.  */

	size = strlen (parent_name) + 2 + strlen (nested_name) + 1;
	concatenated_name = alloca (size);
	xsnprintf (concatenated_name, size, "%s::%s",
		 parent_name, nested_name);
	sym = lookup_static_symbol_aux (concatenated_name, VAR_DOMAIN);
	if (sym != NULL)
	  return sym;

	/* If no matching symbols were found, try searching any
	   base classes.  */
	return find_symbol_in_baseclass (parent_type, nested_name, block);
      }

    case TYPE_CODE_FUNC:
    case TYPE_CODE_METHOD:
      return NULL;

    default:
      internal_error (__FILE__, __LINE__,
		      _("cp_lookup_nested_symbol called "
			"on a non-aggregate type."));
    }
}

/* The C++-version of lookup_transparent_type.  */

/* FIXME: carlton/2004-01-16: The problem that this is trying to
   address is that, unfortunately, sometimes NAME is wrong: it may not
   include the name of namespaces enclosing the type in question.
   lookup_transparent_type gets called when the type in question
   is a declaration, and we're trying to find its definition; but, for
   declarations, our type name deduction mechanism doesn't work.
   There's nothing we can do to fix this in general, I think, in the
   absence of debug information about namespaces (I've filed PR
   gdb/1511 about this); until such debug information becomes more
   prevalent, one heuristic which sometimes looks is to search for the
   definition in namespaces containing the current namespace.

   We should delete this functions once the appropriate debug
   information becomes more widespread.  (GCC 3.4 will be the first
   released version of GCC with such information.)  */

struct type *
cp_lookup_transparent_type (const char *name)
{
  /* First, try the honest way of looking up the definition.  */
  struct type *t = basic_lookup_transparent_type (name);
  const char *scope;

  if (t != NULL)
    return t;

  /* If that doesn't work and we're within a namespace, look there
     instead.  */
  scope = block_scope (get_selected_block (0));

  if (scope[0] == '\0')
    return NULL;

  return cp_lookup_transparent_type_loop (name, scope, 0);
}

/* Lookup the type definition associated to NAME in namespaces/classes
   containing SCOPE whose name is strictly longer than LENGTH.  LENGTH
   must be the index of the start of a component of SCOPE.  */

static struct type *
cp_lookup_transparent_type_loop (const char *name,
				 const char *scope,
				 int length)
{
  int scope_length = length + cp_find_first_component (scope + length);
  char *full_name;

  /* If the current scope is followed by "::", look in the next
     component.  */
  if (scope[scope_length] == ':')
    {
      struct type *retval
	= cp_lookup_transparent_type_loop (name, scope,
					   scope_length + 2);

      if (retval != NULL)
	return retval;
    }

  full_name = alloca (scope_length + 2 + strlen (name) + 1);
  strncpy (full_name, scope, scope_length);
  strncpy (full_name + scope_length, "::", 2);
  strcpy (full_name + scope_length + 2, name);

  return basic_lookup_transparent_type (full_name);
}

/* This used to do something but was removed when it became
   obsolete.  */

static void
maintenance_cplus_namespace (char *args, int from_tty)
{
  printf_unfiltered (_("The `maint namespace' command was removed.\n"));
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_cp_namespace;

void
_initialize_cp_namespace (void)
{
  struct cmd_list_element *cmd;

  cmd = add_cmd ("namespace", class_maintenance,
		 maintenance_cplus_namespace,
		 _("Deprecated placeholder for removed functionality."),
		 &maint_cplus_cmd_list);
  deprecate_cmd (cmd, NULL);
}
@


1.68
log
@	PR 15519
	* cp-namespace.c (find_symbol_in_baseclass): Call
	cp_lookup_symbol_in_namespace instead of cp_lookup_symbol_namespace.
	Check result of call to lookup_symbol_static.
	Call lookup_static_symbol_aux unconditionally.
	Call check_typedef on base types before accessing them.
	(cp_lookup_nested_symbol): Fix comment.

	testsuite/
	* gdb.cp/derivation2.cc: New file.
	* gdb.cp/derivation.cc (main): Call foo2.
	* gdb.cp/derivation.exp: Add tests for typedefs in another
	file, and when there's an active block.
@
text
@d476 2
a477 1
	  struct gdbarch *arch = SYMBOL_SYMTAB (function)->objfile->gdbarch;
@


1.67
log
@fix cp-namespace.c

cp_lookup_symbol_imports_or_template could return without
running cleanups.

	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Call
	do_cleanups on all return paths.
@
text
@d723 1
d730 2
a731 1
      sym = cp_lookup_symbol_namespace (base_name, name, block, VAR_DOMAIN);
d735 3
d742 2
d745 6
a750 9
      /* If there is currently no BLOCK, e.g., the inferior hasn't yet
	 been started, then try searching all STATIC_BLOCK symbols in
	 all objfiles.  */
      if (block == NULL)
	{
	  sym = lookup_static_symbol_aux (concatenated_name, VAR_DOMAIN);
	  if (sym != NULL)
	    break;
	}
d753 2
a754 1
      if (TYPE_N_BASECLASSES (TYPE_BASECLASS (parent_type, i)) > 0)
d756 1
a756 2
	  sym = find_symbol_in_baseclass (TYPE_BASECLASS (parent_type, i),
					  name, block);
d804 2
a805 2
	/* Now search all static file-level symbols.  Not strictly
	   correct, but more useful than an error.  We do not try to
@


1.66
log
@From: Sergio Durigan Junior <sergiodj@@redhat.com>
Subject: [PATCH] Fix for PR c++/15203 and PR c++/15210
Date: Sat, 09 Mar 2013 02:50:49 -0300 (5 days, 4 hours, 57 minutes ago)
Message-ID: <m3a9qdnmti.fsf@@redhat.com>

Hi,

This bug was reported internally at our Bugzilla, along with a proposed
fix.  After talking to Keith about it, he investigated and came up with
another patch needed to really fix the issue on CVS HEAD.

The first part of the fix is the patch to cp-namespace.c.  It handles
the case when we are accessing a static variable inside a function
(inside a class) by the full linespec (is it right, Keith?).  E.g.:

    class foo
    {
    public:
        int bar()
        {
            static int var = 0;
        }
    };

And then, printing the value of `var':

    (gdb) print 'foo::bar()::var'

GDB would fall in an internal_error:

    gdb/cp-namespace.c:816: internal-error: cp_lookup_nested_symbol called on a non-aggregate type.

This is because `cp_lookup_nested_symbol' is not handling the case when
TYPE_CODE is either _FUNC or _METHOD.  This patch fixes it by returning
NULL in this case.

The second part of the fix is the patch to elfread.c.  It is needed
because the BSF_GNU_UNIQUE flag was added to some symbols in
<http://sourceware.org/ml/binutils/2009-06/msg00016.html>.  Because of
that, (still) the command:

    (gdb) print 'foo::bar()::var'

where `var' is a static variable returns:

    "No symbol "foo::bar()::var" in current context."

So with the second patch applied the command finally DTRT:

    (gdb) print 'foo::bar()::var'
    $1 = 0

This may not be the ideal solution, according to Keith it would be good
to implement productions on c-exp.y in order to recognize
CLASS::FUNCTION::VARIABLE, but it is a solution which works with what we
have today.

I regtested it in Fedora 17 x86_64 with -m64 and -m32, including
gdbserver, without regressions.

gdb/:
2013-03-14  Keith Seitz  <keiths@@redhat.com>
	    Alan Matsuoka  <alanm@@redhat.com>

	PR c++/15203
	PR c++/15210
	* cp-namespace.c (cp_lookup_nested_symbol): Handle TYPE_CODE_FUNC and
	TYPE_CODE_METHOD.
	* elfread.c (elf_symtab_read): Handle BSF_GNU_UNIQUE for certain
	symbols.

gdb/testsuite/:
2013-03-14  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR c++/15203
	PR c++/15210
	* gdb.cp/m-static.cc (keepalive_int): New function.
	(gnu_obj_1::method): New variable `sintvar', call `keepalive_int'.
	* gdb.cp/m-static.exp: New test for `sintvar'.
@
text
@d502 4
a505 1
		return result;
@


1.65
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d815 5
@


1.65.2.1
log
@From: Sergio Durigan Junior <sergiodj@@redhat.com>
Subject: [PATCH] Fix for PR c++/15203 and PR c++/15210
Date: Sat, 09 Mar 2013 02:50:49 -0300 (5 days, 4 hours, 57 minutes ago)
Message-ID: <m3a9qdnmti.fsf@@redhat.com>

Hi,

This bug was reported internally at our Bugzilla, along with a proposed
fix.  After talking to Keith about it, he investigated and came up with
another patch needed to really fix the issue on CVS HEAD.

The first part of the fix is the patch to cp-namespace.c.  It handles
the case when we are accessing a static variable inside a function
(inside a class) by the full linespec (is it right, Keith?).  E.g.:

    class foo
    {
    public:
        int bar()
        {
            static int var = 0;
        }
    };

And then, printing the value of `var':

    (gdb) print 'foo::bar()::var'

GDB would fall in an internal_error:

    gdb/cp-namespace.c:816: internal-error: cp_lookup_nested_symbol called on a non-aggregate type.

This is because `cp_lookup_nested_symbol' is not handling the case when
TYPE_CODE is either _FUNC or _METHOD.  This patch fixes it by returning
NULL in this case.

The second part of the fix is the patch to elfread.c.  It is needed
because the BSF_GNU_UNIQUE flag was added to some symbols in
<http://sourceware.org/ml/binutils/2009-06/msg00016.html>.  Because of
that, (still) the command:

    (gdb) print 'foo::bar()::var'

where `var' is a static variable returns:

    "No symbol "foo::bar()::var" in current context."

So with the second patch applied the command finally DTRT:

    (gdb) print 'foo::bar()::var'
    $1 = 0

This may not be the ideal solution, according to Keith it would be good
to implement productions on c-exp.y in order to recognize
CLASS::FUNCTION::VARIABLE, but it is a solution which works with what we
have today.

I regtested it in Fedora 17 x86_64 with -m64 and -m32, including
gdbserver, without regressions.

gdb/:
2013-03-14  Keith Seitz  <keiths@@redhat.com>
	    Alan Matsuoka  <alanm@@redhat.com>

	PR c++/15203
	PR c++/15210
	* cp-namespace.c (cp_lookup_nested_symbol): Handle TYPE_CODE_FUNC and
	TYPE_CODE_METHOD.
	* elfread.c (elf_symtab_read): Handle BSF_GNU_UNIQUE for certain
	symbols.

gdb/testsuite/:
2013-03-14  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR c++/15203
	PR c++/15210
	* gdb.cp/m-static.cc (keepalive_int): New function.
	(gnu_obj_1::method): New variable `sintvar', call `keepalive_int'.
	* gdb.cp/m-static.exp: New test for `sintvar'.
@
text
@a814 5

    case TYPE_CODE_FUNC:
    case TYPE_CODE_METHOD:
      return NULL;

@


1.65.2.2
log
@	PR 15519
	* cp-namespace.c (find_symbol_in_baseclass): Call
	cp_lookup_symbol_in_namespace instead of cp_lookup_symbol_namespace.
	Check result of call to lookup_symbol_static.
	Call lookup_static_symbol_aux unconditionally.
	Call check_typedef on base types before accessing them.
	(cp_lookup_nested_symbol): Fix comment.

	testsuite/
	* gdb.cp/derivation2.cc: New file.
	* gdb.cp/derivation.cc (main): Call foo2.
	* gdb.cp/derivation.exp: Add tests for typedefs in another
	file, and when there's an active block.

	testsuite/
	* gdb.cp/derivation.exp: Make tests have unique names.
@
text
@a719 1
      struct type *base_type = TYPE_BASECLASS (parent_type, i);
d726 1
a726 2
      sym = cp_lookup_symbol_in_namespace (base_name, name, block,
					   VAR_DOMAIN, 0);
a729 3
      /* Now search all static file-level symbols.  We have to do this for
	 things like typedefs in the class.  First search in this symtab,
	 what we want is possibly there.  */
a733 2
      if (sym != NULL)
	break;
d735 9
a743 6
      /* Nope.  We now have to search all static blocks in all objfiles,
	 even if block != NULL, because there's no guarantees as to which
	 symtab the symbol we want is in.  */
      sym = lookup_static_symbol_aux (concatenated_name, VAR_DOMAIN);
      if (sym != NULL)
	break;
d746 1
a746 2
      CHECK_TYPEDEF (base_type);
      if (TYPE_N_BASECLASSES (base_type) > 0)
d748 2
a749 1
	  sym = find_symbol_in_baseclass (base_type, name, block);
d797 2
a798 2
	/* Now search all static file-level symbols.  We have to do this
	   for things like typedefs in the class.  We do not try to
@


1.64
log
@	* cp-namespace.c (cp_set_block_scope): Remove.
	* cp-support.h (cp_set_block_scope): Remove.
	* dbxread.c: Include block.h.
	(cp_set_block_scope): New function.
	(process_one_symbol): Update.
	* dwarf2read.c (read_func_scope): Use block_set_scope.
@
text
@a453 4
      int i;
      struct cplus_specific *cps
	= function->ginfo.language_specific.cplus_specific;

@


1.63
log
@	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Update.
	(cp_add_using_directive): Add 'copy_names' argument.
	* cp-support.h (cp_add_using_directive): Update.
	(struct using_direct) <import_src, import_dest, alias,
	declaration>: Now const.
	* dwarf2read.c (read_import_statement): Use obconcat.
	Don't copy names passed to cp_add_using_directive.
@
text
@a207 37
/* Record the namespace that the function defined by SYMBOL was
   defined in, if necessary.  BLOCK is the associated block; use
   OBSTACK for allocation.  */

void
cp_set_block_scope (const struct symbol *symbol,
		    struct block *block,
		    struct obstack *obstack,
		    const char *processing_current_prefix,
		    int processing_has_namespace_info)
{
  if (processing_has_namespace_info)
    {
      block_set_scope
	(block, obstack_copy0 (obstack, processing_current_prefix,
			       strlen (processing_current_prefix)),
	 obstack);
    }
  else if (SYMBOL_DEMANGLED_NAME (symbol) != NULL)
    {
      /* Try to figure out the appropriate namespace from the
	 demangled name.  */

      /* FIXME: carlton/2003-04-15: If the function in question is
	 a method of a class, the name will actually include the
	 name of the class as well.  This should be harmless, but
	 is a little unfortunate.  */

      const char *name = SYMBOL_DEMANGLED_NAME (symbol);
      unsigned int prefix_len = cp_entire_prefix_len (name);

      block_set_scope (block,
		       obstack_copy0 (obstack, name, prefix_len),
		       obstack);
    }
}

@


1.62
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d99 1
a99 1
	      cp_add_using_directive (dest, src, NULL, NULL, NULL,
d120 4
a123 3
   it is NULL.  EXCLUDES is a list of names not to import from an imported
   module or NULL.  The arguments are copied into newly allocated memory so
   they can be temporaries.  For EXCLUDES the VEC pointers are copied but the
d132 1
d178 10
a187 2
  new->import_src = obstack_copy0 (obstack, src, strlen (src));
  new->import_dest = obstack_copy0 (obstack, dest, strlen (dest));
d189 1
a189 1
  if (alias != NULL)
d191 2
d194 1
a194 1
  if (declaration != NULL)
d197 2
@


1.61
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d176 2
a177 2
  new->import_src = obsavestring (src, strlen (src), obstack);
  new->import_dest = obsavestring (dest, strlen (dest), obstack);
d180 1
a180 1
    new->alias = obsavestring (alias, strlen (alias), obstack);
d183 2
a184 2
    new->declaration = obsavestring (declaration, strlen (declaration),
                                     obstack);
d208 2
a209 3
	(block, obsavestring (processing_current_prefix,
			      strlen (processing_current_prefix),
			      obstack),
d226 1
a226 1
		       obsavestring (name, prefix_len, obstack),
@


1.60
log
@	PR c++/13615
	* cp-namespace.c (cp_lookup_symbol_in_namespace): Add SEARCH
	parameter and pass it to lookup_symbol_file.
	(cp_lookup_symbol_imports): Tell cp_lookup_symbol_in_namespace
	to search base classes.
	(cp_lookup_symbol_namespace): Likewise.
	(lookup_namespace_scope): Likewise.
	(lookup_symbol_file): Add SEARCH parameter.
	If SEARCH is non-zero and no symbol is found, lookup the class
	and call cp_lookup_nested_symbol.
	(find_symbol_in_baseclass): New function.
	(cp_lookup_nested_symbol): Do not let
	cp_lookup_symbol_in_namespace search through base classes.
	Do that later when there is no global symbol match.

	PR c++/13615
	* gdb.cp/baseenum.cc: New file.
	* gdb.cp/baseenum.exp: New file.
	* gdb.cp/derivation.cc (A): Add copyright.
	Add a typedef.
	(B): Use A::value_type instead of int.  Change all references.
	(D): Use value_type instead of int.  Change all references.
	(E): Likewise.
	(F); Likewise.
	(Z): New class.
	(ZZ): New class.
 	(N, Base, Derived): New namespace and classes.
	(main): Add instances of Z and ZZ.
	Make sure all symbols from N are kept.
	* gdb.cp/derivation.exp: Update typedef changes in tests.
	Add tests for class typedefs both before and after starting
	the inferior.
	Add tests for searching for a typedef while stopped in a
	method.
@
text
@d2 1
a2 1
   Copyright (C) 2003-2004, 2007-2012 Free Software Foundation, Inc.
@


1.59
log
@	ARI fixes: Avoid sprintf function use rule.
	* charset.c (convert_between_encodings): Use xsnprintf.
	* cli-out.c (cli_field_int): Likewise.
	* cp-namespace.c (cp_lookup_nested_symbol): Likewise.
	* expprint.c (op_name_standard): Likewise.
	* frv-tdep.c (set_variant_num_gprs): Likewise.
	(set_variant_num_fprs): Likewise.
	* m68hc11-tdep.c (m68hc11_initialize_register_info): Likewise.
	* nto-tdep.c (nto_find_and_open_solib): Likewise.
	(nto_init_solib_absolute_prefix): Likewise.
	* source.c (init_source_path): Likewise.
	(print_source_lines_base): Likewise.
	* valprint.c (print_wchar): Likewise.
	* mi/mi-out.c (mi_field_int): Likewise.
	windows-nat.c (windows_pid_to_exec_file): Likewise.
	(windows_create_inferior): Likewise.
	(_initialize_check_for_gdb_ini): Likewise.
@
text
@d45 2
a46 1
					  int anonymous_namespace);
d268 2
a269 1
   as in cp_lookup_symbol_nonlocal.  */
d275 1
a275 1
                               const domain_enum domain)
d279 1
a279 1
      return lookup_symbol_file (name, block, domain, 0);
d290 1
a290 1
				 cp_is_anonymous (namespace));
d346 1
a346 1
					 block, domain);
d390 1
a390 1
						 block, domain);
d424 1
a424 1
						   block, domain);
d555 1
a555 1
				       block, domain);
d626 1
a626 1
					block, domain);
d631 2
a632 1
   within an anonymous namespace.  Other arguments are as in
d639 1
a639 1
		    int anonymous_namespace)
d663 121
d819 1
a819 1
					   block, VAR_DOMAIN);
d828 1
a828 1
	   namespace seach is is already not C++ compliant and more
d839 3
a841 1
	return NULL;
@


1.58
log
@gdb/
	PR c++/14177 - Fix parsing TYPENAME:: in parentheses.
	* c-exp.y (classify_inner_name): Remove caller assumptions in the
	function comment.  Return ERROR for unresolved cases.  Implement
	returning proper NAME.
	(yylex): Accept also NAME from classify_inner_name.
	* cp-namespace.c (cp_lookup_nested_type): Rename to ...
	(cp_lookup_nested_symbol): ... here.  Return any found symbol, not just
	LOC_TYPEDEF type.
	* cp-support.h (cp_lookup_nested_type): Update its declaration.

gdb/testsuite/
	PR c++/14177 - Fix parsing TYPENAME:: in parentheses.
	* gdb.cp/cpexprs.cc (class CV, CV::i, ATTRIBUTE_USED, CV_f): New.
	(test_function): Call CV_f.
	* gdb.cp/cpexprs.exp (p 'CV::m(int)', p CV::m(int))
	(p 'CV::m(int) const', p CV::m(int) const, p 'CV::m(int) volatile')
	(p CV::m(int) volatile, p 'CV::m(int) const volatile')
	(p CV::m(int) const volatile, p CV_f(int), p CV_f(CV::t))
	(p CV_f(CV::i)): New tests.
@
text
@d691 1
d707 3
a709 3
	concatenated_name = alloca (strlen (parent_name) + 2
				    + strlen (nested_name) + 1);
	sprintf (concatenated_name, "%s::%s",
@


1.57
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d663 1
a663 1
/* Look up a type named NESTED_NAME that is nested inside the C++
d667 4
a670 4
struct type *
cp_lookup_nested_type (struct type *parent_type,
		       const char *nested_name,
		       const struct block *block)
d697 2
a698 2
	if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
	  return SYMBOL_TYPE (sym);
d710 3
a712 4
	sym = lookup_static_symbol_aux (concatenated_name,
					VAR_DOMAIN);
	if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
	  return SYMBOL_TYPE (sym);
d718 1
a718 1
		      _("cp_lookup_nested_type called "
@


1.56
log
@	* cp-namespace.c (cp_lookup_symbol_imports): Reindent.
@
text
@d2 1
a2 2
   Copyright (C) 2003, 2004, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.56.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 2003-2004, 2007-2012 Free Software Foundation, Inc.
@


1.55
log
@	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.  Instead of getting objfile from
	symbol's symtab, use new argument OBJFILE.
	* cp-support.h (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.
	* gdb/dwarf2read.c (new_symbol_full): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
	* gdb/stabsread.c (define_symbol): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
@
text
@d373 16
a388 50
	/* Mark this import as searched so that the recursive call
           does not search it again.  */
	current->searched = 1;
	searched_cleanup = make_cleanup (reset_directive_searched,
					 current);

	/* If there is an import of a single declaration, compare the
	   imported declaration (after optional renaming by its alias)
	   with the sought out name.  If there is a match pass
	   current->import_src as NAMESPACE to direct the search
	   towards the imported namespace.  */
	if (current->declaration
	    && strcmp (name, current->alias
		       ? current->alias : current->declaration) == 0)
	  sym = cp_lookup_symbol_in_namespace (current->import_src,
					       current->declaration,
					       block, domain);

	/* If this is a DECLARATION_ONLY search or a symbol was found
	   or this import statement was an import declaration, the
	   search of this import is complete.  */
        if (declaration_only || sym != NULL || current->declaration)
          {
            current->searched = 0;
            discard_cleanups (searched_cleanup);

            if (sym != NULL)
              return sym;

            continue;
          }

	/* Do not follow CURRENT if NAME matches its EXCLUDES.  */
	for (excludep = current->excludes; *excludep; excludep++)
	  if (strcmp (name, *excludep) == 0)
	    break;
	if (*excludep)
	  {
	    discard_cleanups (searched_cleanup);
	    continue;
	  }

	if (current->alias != NULL
	    && strcmp (name, current->alias) == 0)
	  /* If the import is creating an alias and the alias matches
	     the sought name.  Pass current->import_src as the NAME to
	     direct the search towards the aliased namespace.  */
	  {
	    sym = cp_lookup_symbol_in_namespace (scope,
						 current->import_src,
a389 12
	  }
	else if (current->alias == NULL)
	  {
	    /* If this import statement creates no alias, pass
               current->inner as NAMESPACE to direct the search
               towards the imported namespace.  */
	    sym = cp_lookup_symbol_imports (current->import_src,
					    name, block,
					    domain, 0, 0);
	  }
	current->searched = 0;
	discard_cleanups (searched_cleanup);
d391 48
a438 2
	if (sym != NULL)
	  return sym;
@


1.54
log
@gdb/
	Fix non-only rename list for Fortran modules import.
	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Adjust the
	cp_add_using_directive caller.
	(cp_add_using_directive): New parameter excludes, describe it.  New
	variables ix and param.  Compare if also excludes match.  Allocate NEW
	with variable size, initialize EXCLUDES there.
	(cp_lookup_symbol_imports): New variable excludep, test
	current->EXCLUDES with it.
	* cp-support.h: Include vec.h.
	(struct using_direct): New field excludes, describe it.
	(DEF_VEC_P (const_char_ptr)): New.
	(cp_add_using_directive): New parameter excludes.
	* defs.h (const_char_ptr): New typedef.
	* dwarf2read.c (read_import_statement): New variables child_die,
	excludes and cleanups, read in excludes.
	(read_namespace): Adjust the cp_add_using_directive caller.

gdb/testsuite/
	Fix non-only rename list for Fortran modules import.
	* gdb.fortran/module.exp (print var_x, print var_y, print var_z): New
	tests.
	* gdb.fortran/module.f90 (module moduse): New.
	(program module): use moduse, test var_x, var_y and var_z.
@
text
@d56 2
a57 1
cp_scan_for_anonymous_namespaces (const struct symbol *symbol)
d100 1
a100 1
	                              &SYMBOL_SYMTAB (symbol)->objfile->objfile_obstack);
@


1.53
log
@gdb/
	Code cleanup.
	* cp-namespace.c (cp_add_using_directive): Turn positive comparison to
	negative comparisons.
@
text
@d98 1
a98 1
	      cp_add_using_directive (dest, src, NULL, NULL,
d119 4
a122 2
   it is NULL.  The arguments are copied into newly allocated memory
   so they can be temporaries.  */
d129 1
d139 3
d157 9
d170 4
a173 1
  new = OBSTACK_ZALLOC (obstack, struct using_direct);
d185 4
d357 2
d404 10
@


1.52
log
@	PR symtab/12704
	* cp-namespace.c (ANONYMOUS_NAMESPACE_LEN): Remove.
	(cp_scan_for_anonymous_namespaces): Use CP_ANONYMOUS_NAMESPACE_STR
	and CP_ANONYMOUS_NAMESPACE_LEN.
	(cp_is_anonymous): Likewise.
	* cp-support.h (CP_ANONYMOUS_NAMESPACE_STR): Define.
	(CP_ANONYMOUS_NAMESPACE_LEN): Define.
	* dwarf2read.c (namespace_name): Likewise.
	(fixup_partial_die): Likewise.
	* linespec.c (decode_compound): If CP_ANONYMOUS_NAMESPACE_STR is
	seen in the input, keep it.
@
text
@d136 17
a152 9
      if (strcmp (current->import_src, src) == 0
          && strcmp (current->import_dest, dest) == 0
          && ((alias == NULL && current->alias == NULL)
              || (alias != NULL && current->alias != NULL
        	  && strcmp (alias, current->alias) == 0))
	  && ((declaration == NULL && current->declaration == NULL)
	      || (declaration != NULL && current->declaration != NULL
		  && strcmp (declaration, current->declaration) == 0)))
	return;
@


1.51
log
@gdb/
	* c-exp.y (qualified_name): Call destructor_name_p with $1.type.
	(classify_inner_name): Call cp_lookup_nested_type with
	yylval.tsym.type.
	* cp-namespace.c (cp_lookup_nested_type): New variable
	saved_parent_type.  Call CHECK_TYPEDEF for parent_type.  Call
	type_name_no_tag_or_error with saved_parent_type.
	* dwarf2read.c (load_partial_dies): Read in any children of
	DW_TAG_typedef with complaint in such case.
	* gdbtypes.c (type_name_no_tag_or_error): New function.
	* gdbtypes.h (type_name_no_tag_or_error): New prototype.
	* valops.c (destructor_name_p): New comment for parameter type.  Remove
	type const.  Make dname and cp const.  Call type_name_no_tag_or_error.
	* value.h (destructor_name_p): Remove type const.
@
text
@a54 4
/* Optimize away strlen ("(anonymous namespace)").  */

#define ANONYMOUS_NAMESPACE_LEN 21

d75 2
a76 1
	  if ((next_component - previous_component) == ANONYMOUS_NAMESPACE_LEN
d78 2
a79 2
			  "(anonymous namespace)",
			  ANONYMOUS_NAMESPACE_LEN) == 0)
d207 1
a207 1
  return (strstr (namespace, "(anonymous namespace)")
@


1.50
log
@gdb
	* symfile.c (reread_symbols): Update.
	* objfiles.h (struct objfile) <cp_namespace_symtab>: Remove
	field.
	* objfiles.c (allocate_objfile): Update.
	* cp-support.h (cp_check_possible_namespace_symbols): Don't
	declare.
	* cp-namespace.c (lookup_symbol_file): Don't call
	lookup_possible_namespace_symbol.
	(initialize_namespace_symtab, get_possible_namespace_block)
	(free_namespace_block, cp_check_possible_namespace_symbols)
	(check_possible_namespace_symbols_loop)
	(check_one_possible_namespace_symbol)
	(lookup_possible_namespace_symbol): Remove.
	(maintenance_cplus_namespace): Replace with notice.
	(_initialize_cp_namespace): Deprecate `maint cplus namespace'.
gdb/testsuite
	* gdb.cp/maint.exp (test_help): Update.
	(test_namespace): Likewise.
@
text
@d633 6
d652 1
a652 1
	const char *parent_name = TYPE_TAG_NAME (parent_type);
@


1.49
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@a51 18
static void initialize_namespace_symtab (struct objfile *objfile);

static struct block *get_possible_namespace_block (struct objfile *objfile);

static void free_namespace_block (struct symtab *symtab);

static int check_possible_namespace_symbols_loop (const char *name,
						  int len,
						  struct objfile *objfile);

static int check_one_possible_namespace_symbol (const char *name,
						int len,
						struct objfile *objfile);

static struct symbol *lookup_possible_namespace_symbol (const char *name);

static void maintenance_cplus_namespace (char *args, int from_tty);

d621 1
a621 21
  if (sym != NULL)
    return sym;

  /* Now call "lookup_possible_namespace_symbol".  Symbols in here
     claim to be associated to namespaces, but this claim might be
     incorrect: the names in question might actually correspond to
     classes instead of namespaces.  But if they correspond to
     classes, then we should have found a match for them above.  So if
     we find them now, they should be genuine.  */

  /* FIXME: carlton/2003-06-12: This is a hack and should eventually
     be deleted: see comments below.  */

  if (domain == VAR_DOMAIN)
    {
      sym = lookup_possible_namespace_symbol (name);
      if (sym != NULL)
	return sym;
    }

  return NULL;
d749 2
a750 219
/* Now come functions for dealing with symbols associated to
   namespaces.  (They're used to store the namespaces themselves, not
   objects that live in the namespaces.)  These symbols come in two
   varieties: if we run into a DW_TAG_namespace DIE, then we know that
   we have a namespace, so dwarf2read.c creates a symbol for it just
   like normal.  But, unfortunately, versions of GCC through at least
   3.3 don't generate those DIE's.  Our solution is to try to guess
   their existence by looking at demangled names.  This might cause us
   to misidentify classes as namespaces, however.  So we put those
   symbols in a special block (one per objfile), and we only search
   that block as a last resort.  */

/* FIXME: carlton/2003-06-12: Once versions of GCC that generate
   DW_TAG_namespace have been out for a year or two, we should get rid
   of all of this "possible namespace" nonsense.  */

/* Allocate everything necessary for the possible namespace block
   associated to OBJFILE.  */

static void
initialize_namespace_symtab (struct objfile *objfile)
{
  struct symtab *namespace_symtab;
  struct blockvector *bv;
  struct block *bl;

  namespace_symtab = allocate_symtab ("<<C++-namespaces>>", objfile);
  namespace_symtab->language = language_cplus;
  namespace_symtab->free_code = free_nothing;
  namespace_symtab->dirname = NULL;

  bv = obstack_alloc (&objfile->objfile_obstack,
		      sizeof (struct blockvector)
		      + FIRST_LOCAL_BLOCK * sizeof (struct block *));
  BLOCKVECTOR_NBLOCKS (bv) = FIRST_LOCAL_BLOCK + 1;
  BLOCKVECTOR (namespace_symtab) = bv;
  
  /* Allocate empty GLOBAL_BLOCK and STATIC_BLOCK.  */

  bl = allocate_block (&objfile->objfile_obstack);
  BLOCK_DICT (bl) = dict_create_linear (&objfile->objfile_obstack,
					NULL);
  BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK) = bl;
  bl = allocate_block (&objfile->objfile_obstack);
  BLOCK_DICT (bl) = dict_create_linear (&objfile->objfile_obstack,
					NULL);
  BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK) = bl;

  /* Allocate the possible namespace block; we put it where the first
     local block will live, though I don't think there's any need to
     pretend that it's actually a local block (e.g. by setting
     BLOCK_SUPERBLOCK appropriately).  We don't use the global or
     static block because we don't want it searched during the normal
     search of all global/static blocks in lookup_symbol: we only want
     it used as a last resort.  */

  /* NOTE: carlton/2003-09-11: I considered not associating the fake
     symbols to a block/symtab at all.  But that would cause problems
     with lookup_symbol's SYMTAB argument and with block_found, so
     having a symtab/block for this purpose seems like the best
     solution for now.  */

  bl = allocate_block (&objfile->objfile_obstack);
  BLOCK_DICT (bl) = dict_create_hashed_expandable ();
  BLOCKVECTOR_BLOCK (bv, FIRST_LOCAL_BLOCK) = bl;

  namespace_symtab->free_func = free_namespace_block;

  objfile->cp_namespace_symtab = namespace_symtab;
}

/* Locate the possible namespace block associated to OBJFILE,
   allocating it if necessary.  */

static struct block *
get_possible_namespace_block (struct objfile *objfile)
{
  if (objfile->cp_namespace_symtab == NULL)
    initialize_namespace_symtab (objfile);

  return BLOCKVECTOR_BLOCK (BLOCKVECTOR (objfile->cp_namespace_symtab),
			    FIRST_LOCAL_BLOCK);
}

/* Free the dictionary associated to the possible namespace block.  */

static void
free_namespace_block (struct symtab *symtab)
{
  struct block *possible_namespace_block;

  possible_namespace_block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab),
						FIRST_LOCAL_BLOCK);
  gdb_assert (possible_namespace_block != NULL);
  dict_free (BLOCK_DICT (possible_namespace_block));
}

/* Ensure that there are symbols in the possible namespace block
   associated to OBJFILE for all initial substrings of NAME that look
   like namespaces or classes.  NAME should end in a member variable:
   it shouldn't consist solely of namespaces.  */

void
cp_check_possible_namespace_symbols (const char *name,
				     struct objfile *objfile)
{
  check_possible_namespace_symbols_loop (name,
					 cp_find_first_component (name),
					 objfile);
}

/* This is a helper loop for cp_check_possible_namespace_symbols; it
   ensures that there are symbols in the possible namespace block
   associated to OBJFILE for all namespaces that are initial
   substrings of NAME of length at least LEN.  It returns 1 if a
   previous loop had already created the shortest such symbol and 0
   otherwise.

   This function assumes that if there is already a symbol associated
   to a substring of NAME of a given length, then there are already
   symbols associated to all substrings of NAME whose length is less
   than that length.  So if cp_check_possible_namespace_symbols has
   been called once with argument "A::B::C::member", then that will
   create symbols "A", "A::B", and "A::B::C".  If it is then later
   called with argument "A::B::D::member", then the new call will
   generate a new symbol for "A::B::D", but once it sees that "A::B"
   has already been created, it doesn't bother checking to see if "A"
   has also been created.  */

static int
check_possible_namespace_symbols_loop (const char *name, int len,
				       struct objfile *objfile)
{
  if (name[len] == ':')
    {
      int done;
      int next_len = len + 2;

      next_len += cp_find_first_component (name + next_len);
      done = check_possible_namespace_symbols_loop (name, next_len,
						    objfile);

      if (!done)
	done = check_one_possible_namespace_symbol (name, len,
						    objfile);

      return done;
    }
  else
    return 0;
}

/* Check to see if there's already a possible namespace symbol in
   OBJFILE whose name is the initial substring of NAME of length LEN.
   If not, create one and return 0; otherwise, return 1.  */

static int
check_one_possible_namespace_symbol (const char *name, int len,
				     struct objfile *objfile)
{
  struct block *block = get_possible_namespace_block (objfile);
  char *name_copy = alloca (len + 1);
  struct symbol *sym;

  memcpy (name_copy, name, len);
  name_copy[len] = '\0';
  sym = lookup_block_symbol (block, name_copy, VAR_DOMAIN);

  if (sym == NULL)
    {
      struct type *type;

      type = init_type (TYPE_CODE_NAMESPACE, 0, 0,
			name_copy, objfile);

      TYPE_TAG_NAME (type) = TYPE_NAME (type);

      sym = obstack_alloc (&objfile->objfile_obstack,
			   sizeof (struct symbol));
      memset (sym, 0, sizeof (struct symbol));
      SYMBOL_SET_LANGUAGE (sym, language_cplus);
      /* Note that init_type copied the name to the objfile's
	 obstack.  */
      SYMBOL_SET_NAMES (sym, TYPE_NAME (type), len, 0, objfile);
      SYMBOL_CLASS (sym) = LOC_TYPEDEF;
      SYMBOL_TYPE (sym) = type;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;

      dict_add_symbol (BLOCK_DICT (block), sym);

      return 0;
    }
  else
    return 1;
}

/* Look for a symbol named NAME in all the possible namespace blocks.
   If one is found, return it.  */

static struct symbol *
lookup_possible_namespace_symbol (const char *name)
{
  struct objfile *objfile;

  ALL_OBJFILES (objfile)
    {
      struct symbol *sym;

      sym = lookup_block_symbol (get_possible_namespace_block (objfile),
				 name, VAR_DOMAIN);

      if (sym != NULL)
	return sym;
    }

  return NULL;
}

/* Print out all the possible namespace symbols.  */
d755 1
a755 14
  struct objfile *objfile;

  printf_unfiltered (_("Possible namespaces:\n"));
  ALL_OBJFILES (objfile)
    {
      struct dict_iterator iter;
      struct symbol *sym;

      ALL_BLOCK_SYMBOLS (get_possible_namespace_block (objfile),
			 iter, sym)
	{
	  printf_unfiltered ("%s\n", SYMBOL_PRINT_NAME (sym));
	}
    }
d764 7
a770 4
  add_cmd ("namespace", class_maintenance,
	   maintenance_cplus_namespace,
	   _("Print the list of possible C++ namespaces."),
	   &maint_cplus_cmd_list);
@


1.49.2.1
log
@commit f658463559c9f03672b0fd226e4941f159e65bc0
Author: Keith Seitz <keiths@@redhat.com>
Date:   Tue May 31 21:54:06 2011 +0000

gdb/
	PR symtab/12704
	* cp-namespace.c (ANONYMOUS_NAMESPACE_LEN): Remove.
	(cp_scan_for_anonymous_namespaces): Use CP_ANONYMOUS_NAMESPACE_STR
	and CP_ANONYMOUS_NAMESPACE_LEN.
	(cp_is_anonymous): Likewise.
	* cp-support.h (CP_ANONYMOUS_NAMESPACE_STR): Define.
	(CP_ANONYMOUS_NAMESPACE_LEN): Define.
	* dwarf2read.c (namespace_name): Likewise.
	(fixup_partial_die): Likewise.
	* linespec.c (decode_compound): If CP_ANONYMOUS_NAMESPACE_STR is
	seen in the input, keep it.
@
text
@d73 4
d97 1
a97 2
	  if (((next_component - previous_component)
	       == CP_ANONYMOUS_NAMESPACE_LEN)
d99 2
a100 2
			  CP_ANONYMOUS_NAMESPACE_STR,
			  CP_ANONYMOUS_NAMESPACE_LEN) == 0)
d228 1
a228 1
  return (strstr (namespace, CP_ANONYMOUS_NAMESPACE_STR)
@


1.49.2.2
log
@Commit patch from HEAD: http://sourceware.org/ml/gdb-patches/2011-10/msg00577.html

	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.  Instead of getting objfile from
	symbol's symtab, use new argument OBJFILE.
	* cp-support.h (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.
	* gdb/dwarf2read.c (new_symbol_full): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
	* gdb/stabsread.c (define_symbol): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
@
text
@d74 1
a74 2
cp_scan_for_anonymous_namespaces (const struct symbol *const symbol,
				  struct objfile *const objfile)
d117 1
a117 1
	                              &objfile->objfile_obstack);
@


1.48
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d722 1
a722 1
   lookup_transparent_type gets called when the the type in question
d755 3
a757 4
/* Lookup the the type definition associated to NAME in
   namespaces/classes containing SCOPE whose name is strictly longer
   than LENGTH.  LENGTH must be the index of the start of a component
   of SCOPE.  */
@


1.47
log
@run copyright.sh for 2011.
@
text
@d712 2
a713 1
		      _("cp_lookup_nested_type called on a non-aggregate type."));
@


1.46
log
@2010-12-31  Michael Snyder  <msnyder@@vmware.com>

	* charset.c: Comment cleanup and long line wrapping.
	* charset.h: Ditto.
	* c-lang.c: Ditto.
	* c-lang.h: Ditto.
	* coff-pe-read.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* complaints.c: Ditto.
	* complaints.h: Ditto.
	* completer.c: Ditto.
	* completer.h: Ditto.
	* corefile.c: Ditto.
	* corelow.c: Ditto.
	* core-regset.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-abi.h: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cp-support.h: Ditto.
	* cp-valprint.c: Ditto.
	* cp-typeprint.c: Ditto.
	* c-valprint.c: Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2007, 2008, 2009, 2010
@


1.45
log
@create and use symbol_set_language.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed SYMBOL_INIT_LANGUAGE_SPECIFIC to
	SYMBOL_SET_LANGUAGE.
	(symbol_init_language_specific): Renamed to symbol_set_language.
	* symtab.c (symbol_init_language_specific): Removed redundant check
	for language_cplus.
	Renamed to symbol_set_language.
	* stabsread.c (define_symbol): Updated.
	(read_enum_type): Updated
	* psymtab.c (add_psymbol_to_bcache): Updated.
	* minsyms.c (install_minimal_symbols): Updated.
	* coffread.c (process_coff_symbol): SYMBOL_SET_LANGUAGE instead of
	SYMBOL_LANGUAGE to set the language.
	* minsyms.c (prim_record_minimal_symbol_full): Ditto.
	* mdebugread.c (new_symbol): Ditto.
	* cp-namespace.c (check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol_full): Ditto.
	* jv-lang.c (add_class_symbol): Ditto.
@
text
@d102 2
a103 1
	      int dest_len = (previous_component == 0 ? 0 : previous_component - 2);
d132 10
a141 8
/* Add a using directive to using_directives.  If the using directive in
   question has already been added, don't add it twice.
   Create a new struct using_direct which imports the namespace SRC into the
   scope DEST.  ALIAS is the name of the imported namespace in the current
   scope.  If ALIAS is NULL then the namespace is known by its original name.
   DECLARATION is the name if the imported varable if this is a declaration
   import (Eg. using A::x), otherwise it is NULL. The arguments are copied
   into newly allocated memory so they can be temporaries.  */
d236 3
a238 2
   DOMAIN says what kind of symbols we're looking for, and if SYMTAB is
   non-NULL, we should store the symtab where we found the symbol in it.  */
d248 2
a249 1
  sym = lookup_namespace_scope (name, block, domain, scope, 0);
d253 2
a254 1
  return cp_lookup_symbol_namespace (scope, name, block, domain);
d257 2
a258 2
/* Look up NAME in the C++ namespace NAMESPACE.  Other arguments are as in
   cp_lookup_symbol_nonlocal.  */
d272 2
a273 2
      char *concatenated_name = alloca (strlen (namespace) + 2 +
                                        strlen (name) + 1);
d278 2
a279 2
      return lookup_symbol_file (concatenated_name, block,
				 domain, cp_is_anonymous (namespace));
d293 3
a295 3
/* Search for NAME by applying all import statements belonging
   to BLOCK which are applicable in SCOPE.  If DECLARATION_ONLY the search
   is restricted to using declarations.
d298 1
a298 1
     namespace A{
d303 2
a304 2
   If SEARCH_PARENTS the search will include imports which are applicable in
   parents of SCOPE.
d307 1
a307 1
     namespace A{
d309 1
a309 1
       namespace B{
d314 3
a316 3
   If SCOPE is "A::B" and SEARCH_PARENTS is true the imports of namespaces X
   and Y will be considered.  If SEARCH_PARENTS is false only the import of Y
   is considered.  */
d334 2
a335 1
    sym = cp_lookup_symbol_in_namespace (scope, name, block, domain);
d340 3
a342 3
  /* Go through the using directives.  If any of them add new
     names to the namespace we're searching in, see if we can find a
     match by applying them.  */
d353 2
a354 1
                                || scope[len] == ':' || scope[len] == '\0'))
d357 2
a358 2
      /* If the import destination is the current scope or one of its ancestors then
         it is applicable.  */
d361 2
a362 2
	/* Mark this import as searched so that the recursive call does not
           search it again.  */
d364 2
a365 1
	searched_cleanup = make_cleanup (reset_directive_searched, current);
d367 5
a371 4
	/* If there is an import of a single declaration, compare the imported
	   declaration (after optional renaming by its alias) with the sought
	   out name.  If there is a match pass current->import_src as NAMESPACE
	   to direct the search towards the imported namespace.  */
d373 2
a374 2
	    && strcmp (name, current->alias ? current->alias
					    : current->declaration) == 0)
d376 6
a381 7
	                                       current->declaration,
	                                       block,
	                                       domain);

	/* If this is a DECLARATION_ONLY search or a symbol was found or
	   this import statement was an import declaration, the search
	   of this import is complete.  */
d393 5
a397 4
	if (current->alias != NULL && strcmp (name, current->alias) == 0)
	  /* If the import is creating an alias and the alias matches the
	     sought name.  Pass current->import_src as the NAME to direct the
	     search towards the aliased namespace.  */
d400 2
a401 3
	                                         current->import_src,
	                                         block,
	                                         domain);
d405 3
a407 2
	    /* If this import statement creates no alias, pass current->inner as
               NAMESPACE to direct the search towards the imported namespace.  */
d409 2
a410 5
	                                    name,
	                                    block,
	                                    domain,
	                                    0,
	                                    0);
d427 2
a428 1
search_symbol_list (const char *name, int num, struct symbol **syms)
d462 2
a463 1
	  struct template_symbol *templ = (struct template_symbol *) function;
d494 3
a496 1
		  context = lookup_typename (lang, arch, name_copy, parent, 1);
d502 4
a505 3
	      result = search_symbol_list (name,
					   TYPE_N_TEMPLATE_ARGUMENTS (context),
					   TYPE_TEMPLATE_ARGUMENTS (context));
d517 4
a520 3
 /* Searches for NAME in the current namespace, and by applying relevant import
    statements belonging to BLOCK and its parents. SCOPE is the namespace scope
    of the context in which the search is being evaluated.  */
d531 2
a532 1
  sym = cp_lookup_symbol_in_namespace (scope, name, block, domain);
d536 2
a537 1
  /* Search for name in namespaces imported to this and parent blocks.  */
d540 2
a541 1
      sym = cp_lookup_symbol_imports (scope, name, block, domain, 0, 1);
d590 2
a591 1
      sym = lookup_namespace_scope (name, block, domain, scope, new_scope_len);
d602 2
a603 1
  return cp_lookup_symbol_in_namespace (namespace, name, block, domain);
d685 3
a687 4
	struct symbol *sym = cp_lookup_symbol_in_namespace (parent_name,
	                                                    nested_name,
	                                                    block,
	                                                    VAR_DOMAIN);
d693 5
a697 4
	/* Now search all static file-level symbols.  Not strictly correct,
	   but more useful than an error.  We do not try to guess any imported
	   namespace as even the fully specified namespace seach is is already
	   not C++ compliant and more assumptions could make it too magic.  */
d701 4
a704 2
	sprintf (concatenated_name, "%s::%s", parent_name, nested_name);
	sym = lookup_static_symbol_aux (concatenated_name, VAR_DOMAIN);
d756 2
a757 2
   than LENGTH.  LENGTH must be the index of the start of a
   component of SCOPE.  */
d760 2
a761 1
cp_lookup_transparent_type_loop (const char *name, const char *scope,
d772 2
a773 1
	= cp_lookup_transparent_type_loop (name, scope, scope_length + 2);
d824 1
a824 1
  /* Allocate empty GLOBAL_BLOCK and STATIC_BLOCK. */
d890 2
a891 1
cp_check_possible_namespace_symbols (const char *name, struct objfile *objfile)
d930 2
a931 1
	done = check_one_possible_namespace_symbol (name, len, objfile);
d959 2
a960 1
      type = init_type (TYPE_CODE_NAMESPACE, 0, 0, name_copy, objfile);
d964 2
a965 1
      sym = obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d1018 2
a1019 1
      ALL_BLOCK_SYMBOLS (get_possible_namespace_block (objfile), iter, sym)
d1032 2
a1033 1
  add_cmd ("namespace", class_maintenance, maintenance_cplus_namespace,
@


1.44
log
@gdb
	PR c++/9946:
	* symfile.c (reread_symbols): Clear template_symbols.
	* symtab.h (struct symbol) <is_cplus_template_function>: New
	field.
	(SYMBOL_IS_CPLUS_TEMPLATE_FUNCTION): New macro.
	(struct template_symbol): New.
	* symtab.c (lookup_symbol_aux_local): Use
	cp_lookup_symbol_imports_or_template.
	* objfiles.h (struct objfile) <template_symbols>: New field.
	* objfiles.c (relocate_one_symbol): New function.
	(objfile_relocate1): Use it.  Relocate isolated symbols.
	* gdbtypes.h (struct cplus_struct_type) <n_template_arguments,
	template_arguments>: New fields.
	(TYPE_N_TEMPLATE_ARGUMENTS): New macro.
	(TYPE_TEMPLATE_ARGUMENTS): Likewise.
	(TYPE_TEMPLATE_ARGUMENT): Likewise.
	(lookup_typename): Update.
	* gdbtypes.c (lookup_typename): Constify "block" argument.
	* dwarf2read.c: Include vec.h.
	(symbolp): New typedef.
	(read_func_scope): Read template arguments.  Allocate a
	template_symbol when needed.
	(read_structure_type): Read template arguments.
	(new_symbol_full): New function, from new_symbol.  Handle
	DW_TAG_template_type_param and DW_TAG_template_value_param.
	(new_symbol): Rewrite as wrapper.
	* cp-support.h (cp_lookup_symbol_imports_or_template): Declare.
	* cp-namespace.c: Include language.h.
	(search_symbol_list): New function.
	(cp_lookup_symbol_imports_or_template): Likewise.
gdb/testsuite
	PR c++/9946:
	* gdb.cp/temargs.exp: New file.
	* gdb.cp/temargs.cc: New file.
@
text
@d941 1
a941 1
      SYMBOL_LANGUAGE (sym) = language_cplus;
@


1.43
log
@gdb/
	* cp-namespace.c (cp_lookup_nested_type): New variable
	concatenated_name.  Turn the current return condition into a reverse
	one.  Call also lookup_static_symbol_aux on the constructed qualified
	name.
	* symtab.c (lookup_symbol_aux): Move variable objfile and searching in
	other files into a called ...
	(lookup_static_symbol_aux): ... new function here.
	* symtab.h (lookup_static_symbol_aux): New prototype.
	* valops.c (value_maybe_namespace_elt): Call also
	lookup_static_symbol_aux if we failed otherwise.

gdb/testsuite/
	* gdb.cp/namespace.exp (whatis C::cOtherFileType)
	(whatis ::C::cOtherFileType, whatis C::cOtherFileVar)
	(whatis ::C::cOtherFileVar, print C::cOtherFileVar)
	(print ::C::cOtherFileVar)
	(whatis C::OtherFileClass::cOtherFileClassType)
	(whatis ::C::OtherFileClass::cOtherFileClassType)
	(print C::OtherFileClass::cOtherFileClassVar)
	(print ::cOtherFileClassVar)
	(print ::C::OtherFileClass::cOtherFileClassVar): New tests.
	(ptype OtherFileClass, ptype ::C::OtherFileClass): Permit arbitrary
	trailing content.
	* gdb.cp/namespace1.cc (C::OtherFileClass::cOtherFileClassType)
	(C::OtherFileClass::cOtherFileClassVar)
	(C::OtherFileClass::cOtherFileClassVar_use, C::cOtherFileType)
	(C::cOtherFileVar, C::cOtherFileVar_use): New.
@
text
@d35 1
d416 89
@


1.42
log
@2010-05-13  Michael Snyder  <msnyder@@vmware.com>

	* charset.c: White space.
	* c-lang.c: White space.
	* cli-out.c: White space.
	* coffread.c: White space.
	* complaints.c: White space.
	* completer.c: White space.
	* corefile.c: White space.
	* corelow.c: White space.
	* cp-abi.c: White space.
	* cp-namespace.c: White space.
	* cp-support.c: White space.
	* cp-valprint.c: White space.
	* c-typeprint.c: White space.
	* c-valprint.c: White space.
@
text
@d581 1
d583 1
a583 3
	if (sym == NULL || SYMBOL_CLASS (sym) != LOC_TYPEDEF)
	  return NULL;
	else
d585 14
@


1.41
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* frame-unwind.c (frame_unwind_find_by_frame):
	Delete unused variable.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Delete unused variable.
	* cp-support.c (mangled_name_to_comp): Delete unused variable.
	(method_name_from_physname): Delete unused variable.
	(cp_func_name): Delete unused variable.
	(cp_validate_operator): Delete unused variable.
	* cp-namespace.c (cp_scan_for_anonymous_namespaces):
	Delete unused variable.
	* trad-frame.c (trad_frame_get_prev_register):
	Delete unused variable.
	* tramp-frame.c (tramp_frame_cache): Delete unused variable.
@
text
@d267 1
d581 1
d649 1
d882 1
@


1.40
log
@gdb/
	* cp-namespace.c (cp_lookup_symbol_imports): Support ALIAS for the
	CURRENT->DECLARATION case.
	* cp-support.h (struct using_direct): Provide extended comment.
@
text
@a83 1
      const char *len;
@


1.39
log
@gdb/
	* cp-namespace.c (cp_lookup_symbol_in_namespace): Fix alloca size.
	Fix whitespace.
@
text
@d358 6
a363 4
	   declaration with the sought out name.  If there is a match pass
	   current->import_src as NAMESPACE to direct the search towards the
	   imported namespace.  */
	if (current->declaration && strcmp (name, current->declaration) == 0)
d365 1
a365 1
	                                       name,
@


1.38
log
@
    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        PR c++/7936:
        * cp-support.h: Added char *declaration element to using_direct
        data struct.
        (cp_add_using): Added char *declaration argument.
        (cp_add_using_directive): Ditto.
        (cp_lookup_symbol_imports): made extern.
        * cp-namespace.c: Updated with the above changes.
        * dwarf2read.c (read_import_statement): Ditto.
        (read_namespace): Ditto.
        (read_import_statement): Support import declarations.
        * cp-namespace.c (cp_lookup_symbol_imports): Check for imported
        declarations.
        Added support for 'declaration_only' search.
        (cp_lookup_symbol_namespace): Attempt to search for the name as
        is before consideration of imports.
        * symtab.c (lookup_symbol_aux_local): Added a 'declaration_only'
        search at every block level search.
        Now takes language argument.
        (lookup_symbol_aux): Updated.

    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        * gdb.cp/shadow.exp: Removed kfail; test has been fix.
        * gdb.cp/nsusing.exp: Ditto.
@
text
@d267 1
a267 1
                                        strlen (name+ 1));
d272 1
a272 1
				 domain,cp_is_anonymous (namespace));
@


1.37
log
@
   2010-03-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR C++/11236:
	* cp-namespace.c (cp_add_using): Deleted.
	(cp_add_using_directive): Use obstack allocations.
	Merged the function cp_add_using into this one.
	Added 'struct obstack *' argument.
	(cp_scan_for_anonymous_namespaces): Updated.
	* cp-support.h: Updated.
	* dwarf2read.c (read_import_statement): Updated.
	(read_namespace): Updated.
@
text
@d118 1
a118 1
	      cp_add_using_directive (dest, src, NULL,
d136 3
a138 2
   The arguments are copied into newly allocated memory so they can be 
   temporaries.  */
d141 4
a144 1
cp_add_using_directive (const char *dest, const char *src, const char *alias,
d149 1
a149 1

d158 4
a161 1
        	  && strcmp (alias, current->alias) == 0)))
d173 4
d248 1
a248 1
  return cp_lookup_symbol_namespace (scope, name, block, domain, 1);
d251 1
a251 1
/* Look up NAME in the C++ namespace NAMESPACE. Other arguments are as in
d287 9
a295 1
   to BLOCK which are applicable in SCOPE.
d308 1
a308 1
   and Y will be considered. If SEARCH_PARENTS is false only the import of Y
d311 1
a311 1
static struct symbol *
d316 1
d320 1
a320 1
  struct symbol *sym;
d326 3
a328 1
  sym = cp_lookup_symbol_in_namespace (scope, name, block, domain);
d357 24
d399 1
d421 1
a421 2
                            const domain_enum domain,
                            const int search_parents)
d424 5
d433 1
a433 2
      sym = cp_lookup_symbol_imports (scope, name, block, domain,
                                      search_parents);
@


1.36
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d118 2
a119 1
	      cp_add_using_directive (dest, src, NULL);
d130 8
a137 2
/* Add a using directive to using_list. If the using directive in question
   has already been added, don't add it twice.  */
d140 2
a141 1
cp_add_using_directive (const char *dest, const char *src, const char *alias)
d151 4
a154 1
          && strcmp (current->import_dest, dest) == 0)
d158 4
a161 1
  using_directives = cp_add_using (dest, src, alias, using_directives);
d163 5
a217 30
/* Create a new struct using direct which imports the namespace SRC into the
   scope DEST.  ALIAS is the name of the imported namespace in the current
   scope.  If ALIAS is NULL then the namespace is known by its original name.
   Set its next member in the linked list to NEXT; allocate all memory
   using xmalloc.  It copies the strings, so NAME can be a temporary
   string.  */

struct using_direct *
cp_add_using (const char *dest,
              const char *src,
              const char *alias,
	      struct using_direct *next)
{
  struct using_direct *retval;

  retval = xmalloc (sizeof (struct using_direct));
  retval->import_src = savestring (src, strlen(src));
  retval->import_dest = savestring (dest, strlen(dest));

  if (alias != NULL)
    retval->alias = savestring (alias, strlen (alias));
  else
    retval->alias = NULL;

  retval->next = next;
  retval->searched = 0;

  return retval;
}

@


1.35
log
@gdb
	PR c++/8693, PR c++/9496:
	* cp-namespace.c (cp_lookup_nested_type): Handle TYPE_CODE_UNION.
	* c-exp.y (lex_one_token): Rename from yylex.  Don't call
	write_dollar_variable.  Don't try to classify NAME tokens.
	(token_and_value): New type.
	(token_fifo, popping, name_obstack): New globals.
	(classify_name): New function.
	(classify_inner_name): Likewise.
	(yylex): Likewise.
	(VARIABLE): Now has type sval.
	(exp : VARIABLE): Call write_dollar_variable.
	(qualified_name): Use TYPENAME, not typebase.  Add production for
	multiple "::" instances.
	(variable): Use name_not_typename.
	(qualified_type): Remove.
	(typebase): Update.
gdb/testsuite
	PR c++/8693, PR c++/9496:
	* gdb.cp/namespace.exp: Remove some setup_kfail calls.  Added
	regression tests.
@
text
@a36 1
					      const char *linkage_name,
a42 1
					  const char *linkage_name,
d232 3
a234 4
   we're looking for, LINKAGE_NAME (which is optional) is its linkage
   name, BLOCK is the block that we're searching within, DOMAIN says
   what kind of symbols we're looking for, and if SYMTAB is non-NULL,
   we should store the symtab where we found the symbol in it.  */
a237 1
			   const char *linkage_name,
d244 1
a244 1
  sym = lookup_namespace_scope (name, linkage_name, block, domain, scope, 0);
d248 1
a248 2
  return cp_lookup_symbol_namespace (scope, name, linkage_name, block, domain,
                                     1);
a256 1
                               const char *linkage_name,
d262 1
a262 2
      return lookup_symbol_file (name, linkage_name, block,
                                 domain, 0);
d271 2
a272 2
      return lookup_symbol_file (concatenated_name, linkage_name,
                                 block, domain,cp_is_anonymous (namespace));
a305 1
                          const char *linkage_name,
d317 1
a317 2
  sym = cp_lookup_symbol_in_namespace (scope, name, linkage_name, block,
                                       domain);
a352 1
	                                         linkage_name,
a361 1
	                                    linkage_name,
a383 1
                            const char *linkage_name,
d393 1
a393 1
      sym = cp_lookup_symbol_imports (scope, name, linkage_name, block, domain,
a421 1
			const char *linkage_name,
d443 1
a443 2
      sym = lookup_namespace_scope (name, linkage_name, block,
				    domain, scope, new_scope_len);
d454 1
a454 2
  return cp_lookup_symbol_in_namespace (namespace, name, linkage_name,
                                        block, domain);
a463 1
		    const char *linkage_name,
d470 1
a470 1
  sym = lookup_symbol_static (name, linkage_name, block, domain);
d483 1
a483 2
	sym = lookup_symbol_aux_block (name, linkage_name, global_block,
				       domain);
d487 1
a487 1
      sym = lookup_symbol_global (name, linkage_name, block, domain);
a537 1
	                                                    NULL,
d783 1
a783 1
  sym = lookup_block_symbol (block, name_copy, NULL, VAR_DOMAIN);
d824 1
a824 1
				 name, NULL, VAR_DOMAIN);
@


1.34
log
@
2010-02-05  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR c++/7935:
	* gdb.cp/namespace-using.exp: Removed kfail; bug has been fixed.

2010-02-05  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR c++/7935:
	* cp-support.h: Added char* alias element to using_direct data
	struct.
	(cp_add_using): Added char* alias argument.
	(cp_add_using_directive): Ditto.
	* cp-namespace.c: Updated with the above changes.
	(cp_lookup_symbol_imports): Check for aliases.
	* dwarf2read.c (read_import_statement): Figure out local alias
	for the import and pass it on to cp_add_using.
	(read_namespace): Pass alias argument to cp_add_using.
@
text
@d543 1
@


1.34.2.1
log
@PR 11408: Backport using_directives memory leak fix.

2010-04-08  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR Breakpoints/11408:
	* cp-namespace.c (cp_add_using): Deleted.
	(cp_add_using_directive): Use obstack allocations.
	Merged the function cp_add_using into this one.
	Added 'struct obstack *' argument.
	(cp_scan_for_anonymous_namespaces): Updated.
	* cp-support.h: Updated.
	* dwarf2read.c (read_import_statement): Updated.
	(read_namespace): Updated.
	* buildsym.c (finish_block): Reset using_directives pointer
	after block initialization.


2010-03-22  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/gdb2384-base.h: Created 'namespace B'.
	* gdb.cp/gdb2384-base.cc: Use 'namespace B'.
@
text
@d120 1
a120 2
	      cp_add_using_directive (dest, src, NULL,
	                              &SYMBOL_SYMTAB (symbol)->objfile->objfile_obstack);
d131 2
a132 8

/* Add a using directive to using_directives.  If the using directive in
   question has already been added, don't add it twice.
   Create a new struct using_direct which imports the namespace SRC into the
   scope DEST.  ALIAS is the name of the imported namespace in the current
   scope.  If ALIAS is NULL then the namespace is known by its original name.
   The arguments are copied into newly allocated memory so they can be 
   temporaries.  */
d135 1
a135 2
cp_add_using_directive (const char *dest, const char *src, const char *alias,
                        struct obstack *obstack)
d145 1
a145 4
          && strcmp (current->import_dest, dest) == 0
          && ((alias == NULL && current->alias == NULL)
              || (alias != NULL && current->alias != NULL
        	  && strcmp (alias, current->alias) == 0)))
d149 1
a149 4
  new = OBSTACK_ZALLOC (obstack, struct using_direct);

  new->import_src = obsavestring (src, strlen (src), obstack);
  new->import_dest = obsavestring (dest, strlen (dest), obstack);
a150 5
  if (alias != NULL)
    new->alias = obsavestring (alias, strlen (alias), obstack);

  new->next = using_directives;
  using_directives = new;
d201 30
@


1.33
log
@ 2010-01-14  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/nsrecurs.exp: New test.
	* gdb.cp/nsrecurs.cc: New test program.
	* gdb.cp/nsstress.exp: New test.
	* gdb.cp/nsstress.cc: New test program.
	* gdb.cp/nsdecl.exp: New test.
	* gdb.cp/nsdecl.cc: New test program.


 2010-01-26  Sami Wagiaalla  <swagiaal@@redhat.com>

	* cp-namespace.c (cp_lookup_symbol_namespace): Added
	search_parent argument.
	(cp_add_using): Initialize 'searched' field.
	(reset_directive_searched): New function.
	* cp-support.h: Add 'searched' field to using_direct struct.
	(cp_lookup_symbol_imports): Ditto.
	* cp-namespace.c (cp_lookup_symbol_imports): Ditto.
	Perform recursive search.
	Implement non parent search.
	* valops.c (value_maybe_namespace_elt): Updated.
@
text
@d120 1
a120 1
	      cp_add_using_directive (dest, src);
d135 1
a135 1
cp_add_using_directive (const char *dest, const char *src)
d149 1
a149 1
  using_directives = cp_add_using (dest, src, using_directives);
d201 3
a203 2
/* Create a new struct using direct which imports the namespace SRC
   into the scope DEST.
d211 1
d219 6
d355 22
a376 7
	sym = cp_lookup_symbol_namespace (current->import_src,
	                                  name,
	                                  linkage_name,
	                                  block,
	                                  domain,
	                                  0);

@


1.32
log
@2010-01-26  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/namespace-using.exp: Add test for printing of namespaces
	imported into file scope.
	Marked test as xfail.
	* gdb.cp/namespace-using.cc (marker5): New function.
	* gdb.cp/shadow.exp: New test.
	* gdb.cp/shadow.cc: New test program.
	* gdb.cp/nsimport.exp: New test.
	* gdb.cp/nsimport.cc: New test program.

2010-01-26  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR gdb/10929:
	* dwarf2read.c (read_lexical_block_scope): Create blocks for
	scopes which contain using directives even if they contain no
	declarations.
	* symtab.c (lookup_symbol_aux): Pass lowest level block to
	la_lookup_symbol_nonlocal.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): call
	cp_lookup_symbol_namespace.
	(cp_lookup_symbol_namespace): Perform an import lookup at every
	block level.
	(cp_lookup_symbol_imports): New function.
	(cp_lookup_symbol_in_namespace): New function.
@
text
@d218 1
d244 2
a245 1
  return cp_lookup_symbol_namespace (scope, name, linkage_name, block, domain);
d275 10
d286 15
a300 1
   to BLOCK which are applicable in SCOPE.  */
d307 2
a308 1
                          const domain_enum domain)
d310 1
a310 1
  const struct using_direct *current;
d313 2
d330 7
d340 1
a340 3
      len = strlen (current->import_dest);
      if (strncmp (scope, current->import_dest, len) == 0
	  && (len == 0 || scope[len] == ':' || scope[len] == '\0'))
d342 17
a358 4
	  sym = cp_lookup_symbol_in_namespace (current->import_src, name,
					       linkage_name, block, domain);
	  if (sym != NULL)
	    return sym;
a364 1

d374 2
a375 1
                            const domain_enum domain)
d382 2
a383 1
      sym = cp_lookup_symbol_imports (scope,name, linkage_name, block, domain);
@


1.31
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@d236 108
a343 2
  return lookup_namespace_scope (name, linkage_name, block, domain,
				 block_scope (block), 0);
d397 2
a398 59
  return cp_lookup_symbol_namespace (namespace, name, linkage_name,
				     block, domain);
}

/* Look up NAME in the C++ namespace NAMESPACE, applying the using
   directives that are active in BLOCK.  Other arguments are as in
   cp_lookup_symbol_nonlocal.  */

struct symbol *
cp_lookup_symbol_namespace (const char *namespace,
			    const char *name,
			    const char *linkage_name,
			    const struct block *block,
			    const domain_enum domain)
{
  const struct using_direct *current;
  struct symbol *sym;

  /* First, go through the using directives.  If any of them add new
     names to the namespace we're searching in, see if we can find a
     match by applying them.  */

  for (current = block_using (block);
       current != NULL;
       current = current->next)
    {
      if (strcmp (namespace, current->import_dest) == 0)
	{
	  sym = cp_lookup_symbol_namespace (current->import_src,
					    name,
					    linkage_name,
					    block,
					    domain);
	  if (sym != NULL)
	    return sym;
	}
    }

  /* We didn't find anything by applying any of the using directives
     that are still applicable; so let's see if we've got a match
     using the current namespace.  */
  
  if (namespace[0] == '\0')
    {
      return lookup_symbol_file (name, linkage_name, block,
				 domain, 0);
    }
  else
    {
      char *concatenated_name
	= alloca (strlen (namespace) + 2 + strlen (name) + 1);
      strcpy (concatenated_name, namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, name);
      sym = lookup_symbol_file (concatenated_name, linkage_name,
				block, domain, 
				cp_is_anonymous (namespace));
      return sym;
    }
d481 5
a485 5
	struct symbol *sym = cp_lookup_symbol_namespace (parent_name,
							 nested_name,
							 NULL,
							 block,
							 VAR_DOMAIN);
@


1.30
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a35 3
static struct using_direct *cp_copy_usings (struct using_direct *using,
					    struct obstack *obstack);

a221 30
/* Make a copy of the using directives in the list pointed to by
   USING, using OBSTACK to allocate memory.  Free all memory pointed
   to by USING via xfree.  */

static struct using_direct *
cp_copy_usings (struct using_direct *using,
		struct obstack *obstack)
{
  if (using == NULL)
    {
      return NULL;
    }
  else
    {
      struct using_direct *retval
	= obstack_alloc (obstack, sizeof (struct using_direct));
      retval->import_src = obsavestring (using->import_src, strlen (using->import_src),
				    obstack);
      retval->import_dest = obsavestring (using->import_dest, strlen (using->import_dest),
				    obstack);
      retval->next = cp_copy_usings (using->next, obstack);

      xfree (using->import_src);
      xfree (using->import_dest);
      xfree (using);

      return retval;
    }
}

@


1.29
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d2 2
a3 1
   Copyright (C) 2003, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.28
log
@2009-07-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* cp-support.h (struct using_direct): Rename members inner and
	outer to import_src, and import_dest respectively.
	* cp-namespace.c (cp_add_using_directive): Update.
	(cp_add_using): Update.
	(cp_copy_usings): Update.
	(cp_lookup_symbol_namespace): Update.
	(cp_scan_for_anonymous_namespaces): Update.
	* cp-support.c (make_symbol_overload_list_using): Update.
	* cp-support.h (cp_add_using_directive, cp_add_using): Rename
	arguments from inner and outer to src and dest respectively.
	* cp-namespace.c (cp_add_using_directive): Ditto.
	(cp_add_using): Ditto.
@
text
@a716 1
      name_copy = obsavestring (name, len, &objfile->objfile_obstack);
d725 3
a727 1
      SYMBOL_SET_NAMES (sym, name_copy, len, objfile);
@


1.27
log
@2009-06-29  Sami Wagiaalla  <swagiaal@@redhat.com>

	* dwarf2read.c (read_import_statement): Properly set import location
	and destination.
	* cp-support.h (cp_add_using, cp_add_using_directive): Now take char*
	inner, char* outer arguments. Updated callers.

2009-06-29  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/namespace-nested-import.cc: New test.
	* gdb.cp/namespace-nested-import.exp: New test.
@
text
@d106 2
a107 2
	      int outer_len = (previous_component == 0 ? 0 : previous_component - 2);
	      int inner_len = next_component;
d109 2
a110 2
	      char *outer = alloca (outer_len + 1);
	      char *inner = alloca (inner_len + 1);
d112 2
a113 2
	      memcpy (outer, name, outer_len);
	      memcpy (inner, name, inner_len);
d115 2
a116 2
	      outer[outer_len] = '\0';
	      inner[inner_len] = '\0';
d122 1
a122 1
	      cp_add_using_directive (outer, inner);
d137 1
a137 1
cp_add_using_directive (const char *outer, const char *inner)
d146 2
a147 2
      if (strcmp (current->inner, inner) == 0
          && strcmp (current->outer, outer) == 0)
d151 1
a151 1
  using_directives = cp_add_using (outer, inner, using_directives);
d203 2
a204 2
/* Create a new struct using direct whose inner namespace is INNER
   and whose outer namespace is OUTER.
d210 2
a211 2
cp_add_using (const char *outer,
              const char *inner,
d217 2
a218 2
  retval->inner = savestring (inner, strlen(inner));
  retval->outer = savestring (outer, strlen(outer));
d240 1
a240 1
      retval->inner = obsavestring (using->inner, strlen (using->inner),
d242 1
a242 1
      retval->outer = obsavestring (using->outer, strlen (using->outer),
d246 2
a247 2
      xfree (using->inner);
      xfree (using->outer);
d349 1
a349 1
      if (strcmp (namespace, current->outer) == 0)
d351 1
a351 1
	  sym = cp_lookup_symbol_namespace (current->inner,
@


1.26
log
@2009-06-23  Sami Wagiaalla  <swagiaal@@redhat.com>

       * dwarf2read.c (process_die): Handle import statements
       (DW_TAG_imported_declaration, case DW_TAG_imported_module)
       (read_import_statement): New.
       (read_func_scope): Update using_directives to point to current context
       (read_lexical_block_scope): Ditto.
       * cp-support.h: Added prototype for cp_add_using.
       * cp-namespace.c: Removed local context_stack.
       (cp_initialize_namespace): Deleted.
       (cp_finalize_namespace): Deleted.
       (cp_add_using_directive): Use using_directives instead of using_list.
       (cp_add_using): No longer static.
       * buildsym.h: Created global using_direct variable.
       Created using_direct variable in context_stack.
       * buildsym.c (finish_block): Set using directives for the block under
       construction.
       (start_symtab): Removed call to cp_initialize_namespace().
       (end_symtab): Removed call to cp_finalize_namespace().
       (push_context): Save and reset using_directives.
       * block.c (block_using): Return using directives for given
       block instead of static block.

2009-06-23  Sami Wagiaalla  <swagiaal@@redhat.com>

       * gdb.cp/namespace-using.exp: New test.
       * gdb.cp/namespace-using.cc: New test.
@
text
@d106 12
d122 1
a122 4
	      cp_add_using_directive (name,
				      previous_component == 0
				      ? 0 : previous_component - 2,
				      next_component);
d133 2
a134 6
/* Add a using directive to using_list.  NAME is the start of a string
   that should contain the namespaces we want to add as initial
   substrings, OUTER_LENGTH is the end of the outer namespace, and
   INNER_LENGTH is the end of the inner namespace.  If the using
   directive in question has already been added, don't add it
   twice.  */
d137 1
a137 2
cp_add_using_directive (const char *name, unsigned int outer_length,
			unsigned int inner_length)
d146 2
a147 3
      if ((strncmp (current->inner, name, inner_length) == 0)
	  && (strlen (current->inner) == inner_length)
	  && (strlen (current->outer) == outer_length))
d151 2
a152 2
  using_directives = cp_add_using (name, inner_length, outer_length,
                                   using_directives);
d203 2
a204 3
/* Create a new struct using direct whose inner namespace is the
   initial substring of NAME of leng INNER_LEN and whose outer
   namespace is the initial substring of NAME of length OUTER_LENGTH.
d210 2
a211 3
cp_add_using (const char *name,
	      unsigned int inner_len,
	      unsigned int outer_len,
a215 2
  gdb_assert (outer_len < inner_len);

d217 2
a218 2
  retval->inner = savestring (name, inner_len);
  retval->outer = savestring (name, outer_len);
@


1.25
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d33 1
a33 9

/* List of using directives that are active in the current file.  */

static struct using_direct *using_list;

static struct using_direct *cp_add_using (const char *name,
					  unsigned int inner_len,
					  unsigned int outer_len,
					  struct using_direct *next);
a72 25
/* Set up support for dealing with C++ namespace info in the current
   symtab.  */

void cp_initialize_namespace ()
{
  using_list = NULL;
}

/* Add all the using directives we've gathered to the current symtab.
   STATIC_BLOCK should be the symtab's static block; OBSTACK is used
   for allocation.  */

void
cp_finalize_namespace (struct block *static_block,
		       struct obstack *obstack)
{
  if (using_list != NULL)
    {
      block_set_using (static_block,
		       cp_copy_usings (using_list, obstack),
		       obstack);
      using_list = NULL;
    }
}

d140 1
a140 1
  for (current = using_list; current != NULL; current = current->next)
d148 2
a149 2
  using_list = cp_add_using (name, inner_length, outer_length,
			     using_list);
d207 1
a207 1
static struct using_direct *
@


1.24
log
@        Updated copyright notices for most files.
@
text
@d814 3
@


1.23
log
@	* buildsym.c (add_symbol_to_list): Do not call
	cp_scan_for_anonymous_namespaces here.
	(finish_block): Do not call cp_set_block_scope here.
	* cp-namespace.c (processing_has_namespace_info)
	(processing_current_prefix): Delete.
	(cp_initialize_namespace): Do not initialize
	processing_has_namespace_info.
	(cp_scan_for_anonymous_namespaces): Use SYMBOL_DEMANGLED_NAME.  Do
	not check processing_has_namespace_info.
	(cp_set_block_scope): Take prefix and namespace info flag as
	arguments.  Honor namespaces regardless of a demangled name.
	* cp-support.h (processing_has_namespace_info)
	(processing_current_prefix): Delete declarations.
	(cp_set_block_scope): Update prototype.
	* dwarf2read.c (processing_has_namespace_info)
	(processing_current_prefix): New static variables.
	(read_file_scope): Initialize processing_has_namespace_info.
	(read_func_scope): Call cp_set_block_scope for C++.
	(new_symbol): Call cp_scan_for_anonymous_namespaces for C++.
	* symtab.c (symbol_demangled_name): Accept a const argument.
	* symtab.h (symbol_demangled_name): Update prototype.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.23.4.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a299 1
			   const struct exec *exec,
d432 1
a432 1
  sym = lookup_symbol_static (name, linkage_name, block, NULL, domain);
d450 1
a450 1
      sym = lookup_symbol_global (name, linkage_name, block, NULL, domain);
@


1.22
log
@	* language.h (struct language_defn): Remove SYMTAB parameter from
	la_lookup_symbol_nonlocal callback function pointer.

	* ada-lang.h (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	(ada_lookup_encoded_symbol): Likewise.
	* ada-lang.c (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	Always call fixup_symbol_section.
	(ada_lookup_symbol): Remove SYMTAB parameter.
	(ada_lookup_symbol_nonlocal): Likewise.
	* ada-exp.y (write_object_renaming): Update.
	(find_primitive_type): Likewise.

	* cp-support.h (cp_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(cp_lookup_symbol_namespace): Likewise.
	* cp-namespace.c (lookup_namespace_scope): Remove SYMTAB parameter.
	(lookup_symbol_file): Likewise.
	(lookup_possible_namespace_symbol): Likewise.
	(cp_lookup_symbol_nonlocal): Likewise.
	(cp_lookup_symbol_namespace): Likewise.
	(cp_lookup_nested_type): Update.

	* scm-valprint.c (scm_inferior_print): Update.
	* valops.c (value_maybe_namespace_elt): Update.

	* solist.h (struct target_so_ops): Remove SYMTAB parameter from
	lookup_lib_global_symbol callback function pointer.
	(solib_global_lookup): Remove SYMTAB parameter.
	* solib.c (solib_global_lookup): Remove SYMTAB parameter.
	* solib-svr4.c (elf_lookup_lib_symbol): Likewise.

	* symtab.h (basic_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	* symtab.c (lookup_symbol_aux): Remove SYMTAB parameter.
	(lookup_symbol_aux_local): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_symbol_aux_symtabs): Likewise.
	(lookup_symbol_aux_psymtabs): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	(basic_lookup_symbol_nonlocal): Likewise.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.

	(lookup_symbol_in_language): Do not pass SYMTAB to lookup_symbol_aux.
@
text
@a33 26
/* When set, the file that we're processing is known to have debugging
   info for C++ namespaces.  */

/* NOTE: carlton/2004-01-13: No currently released version of GCC (the
   latest of which is 3.3.x at the time of this writing) produces this
   debug info.  GCC 3.4 should, however.  */

unsigned char processing_has_namespace_info;

/* This contains our best guess as to the name of the current
   enclosing namespace(s)/class(es), if any.  For example, if we're
   within the method foo() in the following code:

    namespace N {
      class C {
	void foo () {
	}
      };
    }

   then processing_current_prefix should be set to "N::C".  If
   processing_has_namespace_info is false, then this variable might
   not be reliable.  */

const char *processing_current_prefix;

a85 1
  processing_has_namespace_info = 0;
d116 1
a116 2
  if (!processing_has_namespace_info
      && SYMBOL_CPLUS_DEMANGLED_NAME (symbol) != NULL)
d118 1
a118 1
      const char *name = SYMBOL_CPLUS_DEMANGLED_NAME (symbol);
d192 3
a194 1
		    struct obstack *obstack)
d196 17
a212 2
  /* Make sure that the name was originally mangled: if not, there
     certainly isn't any namespace information to worry about!  */
d214 2
a215 14
  if (SYMBOL_CPLUS_DEMANGLED_NAME (symbol) != NULL)
    {
      if (processing_has_namespace_info)
	{
	  block_set_scope
	    (block, obsavestring (processing_current_prefix,
				  strlen (processing_current_prefix),
				  obstack),
	     obstack);
	}
      else
	{
	  /* Try to figure out the appropriate namespace from the
	     demangled name.  */
d217 3
a219 12
	  /* FIXME: carlton/2003-04-15: If the function in question is
	     a method of a class, the name will actually include the
	     name of the class as well.  This should be harmless, but
	     is a little unfortunate.  */

	  const char *name = SYMBOL_CPLUS_DEMANGLED_NAME (symbol);
	  unsigned int prefix_len = cp_entire_prefix_len (name);

	  block_set_scope (block,
			   obsavestring (name, prefix_len, obstack),
			   obstack);
	}
@


1.21
log
@	Updated copyright notices for most files.
@
text
@a75 1
					      struct symtab **symtab,
a82 1
					  struct symtab **symtab,
d103 1
a103 3
static
struct symbol *lookup_possible_namespace_symbol (const char *name,
						 struct symtab **symtab);
d332 1
a332 2
			   const domain_enum domain,
			   struct symtab **symtab)
d335 1
a335 1
				 symtab, block_scope (block), 0);
a357 1
			struct symtab **symtab,
d378 1
a378 2
				    domain, symtab,
				    scope, new_scope_len);
d390 1
a390 1
				     block, domain, symtab);
d402 1
a402 2
			    const domain_enum domain,
			    struct symtab **symtab)
d421 1
a421 2
					    domain,
					    symtab);
d434 1
a434 1
				 domain, symtab, 0);
d444 1
a444 1
				block, domain, symtab,
a459 1
		    struct symtab **symtab,
d464 1
a464 1
  sym = lookup_symbol_static (name, linkage_name, block, domain, symtab);
d478 1
a478 1
				       domain, symtab);
d482 1
a482 1
      sym = lookup_symbol_global (name, linkage_name, block, domain, symtab);
d500 1
a500 1
      sym = lookup_possible_namespace_symbol (name, symtab);
d534 1
a534 2
							 VAR_DOMAIN,
							 NULL);
d806 1
a806 2
   If one is found, return it; if SYMTAB is non-NULL, set *SYMTAB to
   equal the symtab where it was found.  */
d809 1
a809 1
lookup_possible_namespace_symbol (const char *name, struct symtab **symtab)
d821 1
a821 6
	{
	  if (symtab != NULL)
	    *symtab = objfile->cp_namespace_symtab;

	  return sym;
	}
@


1.20
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2007 Free Software Foundation, Inc.
@


1.19
log
@2007-07-03  Markus Deuling  <deuling@@de.ibm.com>

	* cp-namespace.c (lookup_symbol_file): Add block to
	lookup_symbol_global call.
	* Makefile.in (solist_h): Add dependency on symtab header.
	(symtab.o): Add dependency on solist header.
	* solib.c (solib_global_lookup): New function.
	* solib-svr4.c (scan_dyntag): Likewise.
	(elf_locate_base): Call helper routine scan_dyntag.
	(elf_lookup_lib_symbol): New function.
	(_initialize_svr4_solib): Add elf_lookup_lib_symbol to svr4_so_ops.
	* solist.h (symtab.h): New include.
	(struct target_so_ops): New member lookup_lib_global_symbol.
	(solib_global_lookup): New prototype.
	* symtab.c: New include solist.h.
	(lookup_objfile_from_block): New function.
	(lookup_global_symbol_from_objfile): New function.
	(basic_lookup_symbol_nonlocal): Add block to lookup_symbol_global call.
	(lookup_symbol_global): Call library-specific lookup procedure.
	* symtab.h (lookup_global_symbol_from_objfile): New prototype.

	* NEWS: Document framework.

testsuite/

	* gdb.base/solib-symbol.exp: New file (testcase multiple symbol lookup).
	* gdb.base/solib-symbol-lib.c: Likewise.
	* gdb.base/solib-symbol-main.c: Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.18
log
@Copyright updates for 2007.
@
text
@d494 1
a494 1
      sym = lookup_symbol_global (name, linkage_name, domain, symtab);
@


1.17
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
@


1.16
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.15
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d869 1
a869 1
	   "Print the list of possible C++ namespaces.",
@


1.14
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d852 1
a852 1
  printf_unfiltered ("Possible namespaces:\n");
@


1.13
log
@2004-03-05  David Carlton  <carlton@@kealia.com>

	* cp-namespace.c (cp_lookup_transparent_type_loop): Fix recursion
	bug.

2004-03-05  David Carlton  <carlton@@kealia.com>

	* gdb.cp/rtti.exp: Add 'print *obj3' test.
	* gdb.cp/rtti.h: Update copyright.
	(namespace n2::n3): New.
	* gdb.cp/rtti1.cc: (refer_to (n2::n3::C3 *)): New.
	(n2::n3::func3): New.
	(main): Call n2::n3::func3.
	* gdb.cp/rtti2.cc: Update copyright.
	(n2::create3): New.
@
text
@d555 1
a555 1
		      "cp_lookup_nested_type called on a non-aggregate type.");
@


1.12
log
@	* cp-namespace.c (check_one_possible_namespace_symbol): Don't use
	obstack_free.
@
text
@d606 1
a606 1
  int scope_length = cp_find_first_component (scope + length);
@


1.12.4.1
log
@Merge mainline to intercu branch.
@
text
@d606 1
a606 1
  int scope_length = length + cp_find_first_component (scope + length);
@


1.12.6.1
log
@2004-03-05  David Carlton  <carlton@@kealia.com>

	* cp-namespace.c (cp_lookup_transparent_type_loop): Fix recursion
	bug.

2004-03-05  David Carlton  <carlton@@kealia.com>

	* gdb.cp/rtti.exp: Add 'print *obj3' test.
	* gdb.cp/rtti.h: Update copyright.
	(namespace n2::n3): New.
	* gdb.cp/rtti1.cc: (refer_to (n2::n3::C3 *)): New.
	(n2::n3::func3): New.
	(main): Call n2::n3::func3.
	* gdb.cp/rtti2.cc: Update copyright.
	(n2::create3): New.
@
text
@d606 1
a606 1
  int scope_length = length + cp_find_first_component (scope + length);
@


1.11
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@d786 6
a791 3
  char *name_copy = obsavestring (name, len, &objfile->objfile_obstack);
  struct symbol *sym = lookup_block_symbol (block, name_copy, NULL,
					    VAR_DOMAIN);
d795 5
a799 2
      struct type *type = init_type (TYPE_CODE_NAMESPACE, 0, 0,
				     name_copy, objfile);
d815 1
a815 5
    {
      obstack_free (&objfile->objfile_obstack, name_copy);

      return 1;
    }
@


1.10
log
@2004-01-23  David Carlton  <carlton@@kealia.com>

	Partial workaround for PR c++/1511:
	* cp-namespace.c: Include frame.h.
	(cp_lookup_transparent_type): New
	(cp_lookup_transparent_type_loop): New.
	* cp-support.h: Declare cp_lookup_transparent_type.
	* symtab.c (basic_lookup_transparent_type): Renamed from
	lookup_transparent_type.
	(lookup_transparent_type): Replace old body by a call to
	current_language->la_lookup_transparent_type.
	* symtab.h: Update copyright.  Declare
	basic_lookup_transparent_type.
	* language.h: Update copyright.
	(struct language_defn): Add la_lookup_transparent_type.
	* language.c: Update copyright.
	(unknown_language_defn): Add basic_lookup_transparent_type.
	(auto_language_defn): Add basic_lookup_transparent_type.
	(local_language_defn): Add basic_lookup_transparent_type.
	* ada-lang.c: Update copyright.
	(ada_language_defn): Add basic_lookup_transparent_type.
	* c-lang.c: Update copyright.
	(c_language_defn): Add basic_lookup_transparent_type.
	(cplus_language_defn): Add basic_lookup_transparent_type.
	(asm_language_defn): Add basic_lookup_transparent_type.
	(minimal_language_defn): Add basic_lookup_transparent_type.
	* f-lang.c: Update copyright.
	(f_language_defn): Add basic_lookup_transparent_type.
	* jv-lang.c: Update copyright.
	(java_language_defn): Add basic_lookup_transparent_type.
	* m2-lang.c: Update copyright.
	(m2_language_defn): Add basic_lookup_transparent_type.
	* objc-lang.c: Update copyright.
	(objc_language_defn): Add basic_lookup_transparent_type.
	* p-lang.c: Update copyright.
	(p_language_defn): Add basic_lookup_transparent_type.
	* scm-lang.c: Update copyright.
	(scm_language_defn): Add basic_lookup_transparent_type.
	* Makefile.in (cp-namespace.o): Depend on frame.h.

2004-01-23  David Carlton  <carlton@@kealia.com>

	* gdb.cp/rtti.exp: Don't include full path in ${srcfile}.  Add
	test for cp_lookup_transparent_type.
	* gdb.cp/rtti1.cc: Update copyright.  Add n2::func and refer_to;
	call them.
@
text
@d658 1
a658 1
  bv = obstack_alloc (&objfile->symbol_obstack,
d666 2
a667 2
  bl = allocate_block (&objfile->symbol_obstack);
  BLOCK_DICT (bl) = dict_create_linear (&objfile->symbol_obstack,
d670 2
a671 2
  bl = allocate_block (&objfile->symbol_obstack);
  BLOCK_DICT (bl) = dict_create_linear (&objfile->symbol_obstack,
d689 1
a689 1
  bl = allocate_block (&objfile->symbol_obstack);
d786 1
a786 1
  char *name_copy = obsavestring (name, len, &objfile->symbol_obstack);
d796 1
a796 1
      sym = obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d810 1
a810 1
      obstack_free (&objfile->symbol_obstack, name_copy);
@


1.9
log
@2004-01-14  David Carlton  <carlton@@kealia.com>

	Change symbols for C++ nested types to contain the fully qualified
	name, if possible.  (At least in the DWARF-2 case.)  Partial fix
	for PR's c++/57, c++/488, c++/539, c++/573, c++/609, c++/832,
	c++/895.
	* c-exp.y: Update copyright:
	(qualified_type): Handle types nested within classes.
	* cp-namespace.c: Update comments.
	(cp_set_block_scope): Delete #if 0.
	(cp_lookup_nested_type): Handle types nested within classes.
	* dwarf2read.c: (scan_partial_symbols): Call add_partial_structure
	when appropriate.
	(add_partial_symbol): Add the name of the enclosing namespace to
	types.
	(pdi_needs_namespace): New.
	(add_partial_namespace): Tweak comment.
	(add_partial_structure): New.
	(psymtab_to_symtab_1): Initialize processing_current_prefix
	here...
	(process_die): instead of here.
	(read_structure_scope): Try to figure out the name of the class or
	namespace that the structure might be defined within.
	(read_enumeration): Generate fully-qualified names, if possible.
	(read_namespace): Don't set name to NULL.
	(die_specification): New.
	(new_symbol): Generate fully-qualified names for types.
	(read_type_die): Determine appropriate prefix.
	(determine_prefix): New.
	(typename_concat): New.
	(class_name): New.
	* valops.c: Update copyright.
	(value_aggregate_elt): Pass NOSIDE to
	value_struct_elt_for_reference.
	(value_struct_elt_for_reference): Make static, add NOSIDE
	parameter, call value_maybe_namespace_elt as a last resort.
	(value_namespace_elt): Break out code into
	value_maybe_namespace_elt.
	(value_maybe_namespace_elt): New.

2004-01-14  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Add tests involving classes defined within
	namespaces.
	* gdb.cp/namespace.cc (C::CClass): New.
	* gdb.cp/namespace1.cc: Update copyright.
	(C::OtherFileClass): New.
@
text
@d34 1
d89 4
d557 68
@


1.8
log
@2004-01-09  David Carlton  <carlton@@kealia.com>

        Checked in by Elena Zannoni  <ezannoni@@redhat.com>.
        * dwarf2read.c (read_namespace): Pull out name-generating code
        into namespace_name. Rename previous_namespace to previous_prefix
        and processing_current_namespace to processing_current_prefix..
        (namespace_name): New function.
        (add_partial_symbol): Substitute uses of pdi->name with
        actual_name.
        * cp-support.h: Rename processing_current_namespace to
        processing_current_prefix.
        Update copyright year.
        * cp-namespace.c: Rename processing_current_namespace to
        processing_current_prefix.
        Update copyright year.
@
text
@d35 6
a40 3
/* When set, the file that we're processing seems to have debugging
   info for C++ namespaces, so cp-namespace.c shouldn't try to guess
   namespace info itself.  */
a227 6
#if 0
      /* FIXME: carlton/2003-06-12: As mentioned above,
	 'processing_has_namespace_info' currently isn't entirely
	 reliable, so let's always use demangled names to get this
	 information for now.  */

a236 1
#endif
a518 4
/* FIXME: carlton/2003-09-24: For now, this only works for nested
   namespaces; the patch to make this work on other sorts of nested
   types is next on my TODO list.  */

d526 1
d529 7
d550 1
a550 1
		      "cp_lookup_nested_type called on a non-namespace.");
@


1.7
log
@2003-11-13  David Carlton  <carlton@@kealia.com>

	* cp-namespace.c (lookup_namespace_scope): Fix typo in comment.
@
text
@d2 1
a2 1
   Copyright 2003 Free Software Foundation, Inc.
d41 10
a50 3
/* If processing_has_namespace_info is nonzero, this string should
   contain the name of the current namespace.  The string is
   temporary; copy it if you need it.  */
d52 3
a54 2
/* FIXME: carlton/2003-06-12: This isn't entirely reliable: currently,
   we get mislead by DW_AT_specification.  */
d56 1
a56 1
const char *processing_current_namespace;
d234 2
a235 2
	    (block, obsavestring (processing_current_namespace,
				  strlen (processing_current_namespace),
@


1.7.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.7.2.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d41 3
a43 10
/* This contains our best guess as to the name of the current
   enclosing namespace(s)/class(es), if any.  For example, if we're
   within the method foo() in the following code:

    namespace N {
      class C {
	void foo () {
	}
      };
    }
d45 2
a46 3
   then processing_current_prefix should be set to "N::C".  If
   processing_has_namespace_info is false, then this variable might
   not be reliable.  */
d48 1
a48 1
const char *processing_current_prefix;
d226 2
a227 2
	    (block, obsavestring (processing_current_prefix,
				  strlen (processing_current_prefix),
@


1.7.2.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@a33 1
#include "frame.h"
d35 3
a37 6
/* When set, the file that we're processing is known to have debugging
   info for C++ namespaces.  */

/* NOTE: carlton/2004-01-13: No currently released version of GCC (the
   latest of which is 3.3.x at the time of this writing) produces this
   debug info.  GCC 3.4 should, however.  */
a84 4
static struct type *cp_lookup_transparent_type_loop (const char *name,
						     const char *scope,
						     int scope_len);

d225 6
d240 1
d523 4
a533 1
    case TYPE_CODE_STRUCT:
a535 7
	/* NOTE: carlton/2003-11-10: We don't treat C++ class members
	   of classes like, say, data or function members.  Instead,
	   they're just represented by symbols whose names are
	   qualified by the name of the surrounding class.  This is
	   just like members of namespaces; in particular,
	   lookup_symbol_namespace works when looking them up.  */

d550 1
a550 62
		      "cp_lookup_nested_type called on a non-aggregate type.");
    }
}

/* The C++-version of lookup_transparent_type.  */

/* FIXME: carlton/2004-01-16: The problem that this is trying to
   address is that, unfortunately, sometimes NAME is wrong: it may not
   include the name of namespaces enclosing the type in question.
   lookup_transparent_type gets called when the the type in question
   is a declaration, and we're trying to find its definition; but, for
   declarations, our type name deduction mechanism doesn't work.
   There's nothing we can do to fix this in general, I think, in the
   absence of debug information about namespaces (I've filed PR
   gdb/1511 about this); until such debug information becomes more
   prevalent, one heuristic which sometimes looks is to search for the
   definition in namespaces containing the current namespace.

   We should delete this functions once the appropriate debug
   information becomes more widespread.  (GCC 3.4 will be the first
   released version of GCC with such information.)  */

struct type *
cp_lookup_transparent_type (const char *name)
{
  /* First, try the honest way of looking up the definition.  */
  struct type *t = basic_lookup_transparent_type (name);
  const char *scope;

  if (t != NULL)
    return t;

  /* If that doesn't work and we're within a namespace, look there
     instead.  */
  scope = block_scope (get_selected_block (0));

  if (scope[0] == '\0')
    return NULL;

  return cp_lookup_transparent_type_loop (name, scope, 0);
}

/* Lookup the the type definition associated to NAME in
   namespaces/classes containing SCOPE whose name is strictly longer
   than LENGTH.  LENGTH must be the index of the start of a
   component of SCOPE.  */

static struct type *
cp_lookup_transparent_type_loop (const char *name, const char *scope,
				 int length)
{
  int scope_length = cp_find_first_component (scope + length);
  char *full_name;

  /* If the current scope is followed by "::", look in the next
     component.  */
  if (scope[scope_length] == ':')
    {
      struct type *retval
	= cp_lookup_transparent_type_loop (name, scope, scope_length + 2);
      if (retval != NULL)
	return retval;
a551 7

  full_name = alloca (scope_length + 2 + strlen (name) + 1);
  strncpy (full_name, scope, scope_length);
  strncpy (full_name + scope_length, "::", 2);
  strcpy (full_name + scope_length + 2, name);

  return basic_lookup_transparent_type (full_name);
d585 1
a585 1
  bv = obstack_alloc (&objfile->objfile_obstack,
d593 2
a594 2
  bl = allocate_block (&objfile->objfile_obstack);
  BLOCK_DICT (bl) = dict_create_linear (&objfile->objfile_obstack,
d597 2
a598 2
  bl = allocate_block (&objfile->objfile_obstack);
  BLOCK_DICT (bl) = dict_create_linear (&objfile->objfile_obstack,
d616 1
a616 1
  bl = allocate_block (&objfile->objfile_obstack);
d713 1
a713 1
  char *name_copy = obsavestring (name, len, &objfile->objfile_obstack);
d723 1
a723 1
      sym = obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d737 1
a737 1
      obstack_free (&objfile->objfile_obstack, name_copy);
@


1.6
log
@* cp-namespace.c: Doc fix.
@
text
@d343 1
a343 1
   symbol x, this will get called with NAME = "f", SCOPE = "A::B", and
@


1.5
log
@2003-09-25  David Carlton  <carlton@@kealia.com>

	* c-exp.y: Include cp-support.h.  Add qualified_type.
	(yylex): Delete nested type hack; add comments.
	* cp-namespace.c (cp_lookup_nested_type): New function.
	* cp-support.h: Declare cp_lookup_nested_type.
	* eval.c (evaluate_subexp_standard): Call value_aggregate_elt
	instead of value_struct_elt_for_reference.
	* valops.c: Include cp-support.h.
	(value_aggregate_elt): New function.
	(value_namespace_elt): Ditto.
	(value_struct_elt_for_reference): Make static.
	* value.h: Delete declaration of value_struct_elt_for_reference;
	add declaration for value_aggregate_elt.
	* Makefile.in (c-exp.tab.o): Depend on $(cp_support_h).
	(valops.o): Ditto.

2003-09-25  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Tweak comments.  Add non-quoted versions
	of some print tests, where appropriate.  Add tests for C::D::cd,
	E::ce, F::cXfX, G::XgX.
	* gdb.cp/namespace.cc: Add XgX, cXfX, ce.
@
text
@d343 1
a343 1
   symbol f, this will get called with NAME = "f", SCOPE = "A::B", and
@


1.4
log
@2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdbtypes.h: Add TYPE_CODE_NAMESPACE.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	(recursive_dump_type): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix, c_type_print_base): Ditto.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	maint_cplus_cmd_list.
	* cp-support.c: Make maint_cplus_cmd_list extern.
	* cp-namespace.c: Include objfiles.h, gdbtypes.h, dictionary.h,
	command.h.
	(lookup_symbol_file): Look in possible namespace blocks when
	appropriate.
	(initialize_namespace_symtab): New.
	(get_possible_namespace_block, free_namespace_block)
	(check_possible_namespace_symbols)
	(check_possible_namespace_symbols_loop)
	(check_one_possible_namespace_symbol)
	(lookup_possible_namespace_symbol, maintenance_cplus_namespace)
	(_initialize_cp_namespace): Ditto.
	* block.h: Declare allocate_block.
	* block.c (allocate_block): New.
	* jv-lang.c (get_java_class_symtab): Allocate blocks via
	allocate_block.
	* symfile.h: Update declaration of add_psymbol_to_list.
	* symfile.c (add_psymbol_to_list): Return the partial symbol in
	question.
	* dwarf2read.c (dwarf2_build_psymtabs_hard): Add argument to
	scan_partial_symbols_call.
	(scan_partial_symbols): Add NAMESPACE argument; update calls to
	helper functions.
	(add_partial_symbol): If necessary, scan mangled names for names
	of namespaces.
	(add_partial_namespace): Add NAMESPACE argument; generate partial
	symbols associated  to namespaces.
	(add_partial_enumeration): Add NAMESPACE argument.
	(new_symbol): Allow namespace syms.
	(read_namespace): Generate namespace syms.
	* objfiles.h: Add opaque declaration of struct symtab.
	(struct objfile): Add cp_namespace_symtab member.
	* objfiles.c (allocate_objfile): Set
	objfile->cp_namespace_symtab.
	* Makefile.in (cp-namespace.o): Depend on objfiles_h, gdbtypes_h,
	dictionary_h, command_h.

2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdb.c++/namespace.exp: Add tests for namespace types.
	* gdb.c++/maint.exp (test_help): Test 'help maint cp namespace'.
	(test_namespace): New.
@
text
@d511 35
@


1.3
log
@2003-06-12  David Carlton  <carlton@@kealia.com>

	* cp-namespace.c (cp_set_block_scope): Comment out
	processing_has_namespace_info branch.
@
text
@d30 4
d77 20
d480 211
a690 4
	return lookup_symbol_aux_block (name, linkage_name, global_block,
					domain, symtab);
      else
	return NULL;
d694 3
a696 1
      return lookup_symbol_global (name, linkage_name, domain, symtab);
d698 55
@


1.2
log
@2003-05-19  David Carlton  <carlton@@bactrian.org>

	Partial fix for PR c++/827.
	* cp-support.h: Include symtab.h.
	Declare cp_lookup_symbol_nonlocal, cp_lookup_symbol_namespace.
	* cp-namespace.c: Update contributors.
	(cp_lookup_symbol_nonlocal): New.
	(lookup_namespace_scope, cp_lookup_symbol_namespace)
	(lookup_symbol_file): Ditto.
	* c-lang.c (cplus_language_defn): Use cp_lookup_symbol_nonlocal.
	* block.h: Declare block_scope, block_using, block_global_block.
	* block.c (block_scope): New.
	(block_using, block_global_block): Ditto.
	* Makefile.in (cp_support_h): Depend on symtab_h.
	* config/djgpp/fnchange.lst: Add testsuite/gdb.c++/namespace1.cc.

2003-05-19  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/namespace.exp: Add namespace scope and anonymous
	namespace tests.
	Bump copyright date.
	* gdb.c++/namespace.cc: Add anonymous namespace and namespace C.
	(main): Call C::D::marker2.
	* gdb.c++/namespace1.cc: New file.
@
text
@d41 3
d193 6
d208 1
@


1.1
log
@2003-04-15  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add cp-namespace.c.
	(COMMON_OBS): Add cp-namespace.o.
	(block.o): Depend on gdb_obstack_h and cp_support_h.
	(buildsym.o): Depend on cp_support_h.
	(cp-namespace.o): New.
	(cp-support.o): Depend on gdb_string_h, demangle_h, gdb_assert_h,
	gdb_obstack_h, symtab_h, symfile_h, and gdbcmd_h.
	(dwarf2read.o): Depend on cp_support_h.
	* jv-lang.c (get_java_class_symtab): Set BLOCK_NAMESPACE.
	* dwarf2read.c (process_die): Set processing_has_namespace_info,
	processing_current_namespace.
	(read_namespace): Update processing_current_namespace; check for
	anonymous namespaces.
	(dwarf2_name): New function.
	(dwarf2_extension): Ditto.
	* cp-support.h: Update copyright, contributors.
	Add inclusion guards.
	Add opaque declaration for structs obstack, block, symbol.
	(struct using_direct): New struct.
	Add declarations for cp_find_first_component,
	cp_entire_prefix_len, processing_has_namespace_info,
	processing_current_namespace, cp_is_anonymous,
	cp_add_using_directive, cp_initialize_namespace,
	cp_finalize_namespace, cp_set_block_scope,
	cp_scan_for_anonymous_namespaces.
	* cp-namespace.c: New file.
	* cp-support.c: Update copyright.
	Include ctype.h, gdb_assert.h, gdbcmd.h.
	New variable maint_cplus_cmd_list.
	(cp_find_first_component): New function.
	(cp_entire_prefix_len, maint_cplus_command)
	(first_component_command, _initialize_cp_support): Ditto.
	* buildsym.c: Include cp-support.h.
	New variable using_list.
	(add_symbol_to_list): Check for anonymous namespaces.
	(finish_block): Set block's scope.
	(start_symtab): Initialize C++ namespace support.
	(end_symtab): Finalize C++ namespace support.
	* block.h: Add opaque declarations for structs
	block_namespace_info, using_direct, and obstack.
	Add declarations for block_set_scope and block_set_using.
	(struct block): Add 'language_specific' member.
	(BLOCK_NAMESPACE): New macro.
	* block.c: Include gdb_obstack.h and cp-support.h.
	(struct block_namespace_info): New struct.
	(block_set_scope): New function.
	(block_set_using, block_initialize_namespace): Ditto.

2003-04-15  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/maint.exp: New file.
@
text
@d4 1
a4 1
   Contributed by David Carlton.
d55 15
d280 174
@


1.1.2.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d41 1
a41 1
const char *processing_current_prefix;
d178 2
a179 2
	    (block, obsavestring (processing_current_prefix,
				  strlen (processing_current_prefix),
@


1.1.2.2
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* Makefile.in (cp-namespace.o): Update dependencies.
	(cp-support.o): Ditto.
	* cp-support.h: Declare maint_cplus_cmd_list.
	* cp-namespace.c: Move variables namespace_block,
	possible_namespace_block, namespace_objfile here from
	cp-support.c.
	Move functions initialize_namespace_blocks, get_namespace_block,
	get_possible_namespace_block, free_namespace_blocks,
	check_one_possible_namespace_symbol,
	check_possible_namespace_symbols_loop, maintenance_print_namespace
	here from cp-support.c.
	Include objfiles.h, gdbtypes.h, dictionary.h, gdbcmd.h.
	* cp-namespace.c (_initialize_cp_namespace): New.
	(maintenance_cplus_namespace): Rename from
	maintenance_print_namespace.
	* cp-support.c (cp_find_first_component): Fix typo in comment.
	(_initialize_cp_support): Don't add 'maint print
	namespace'.
	Make maint_cplus_cmd_list extern.
	Prune includes.

2003-04-30  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/maint.exp (test_help): Refactor, and add test for maint
	cp namespace.
	(test_namespace): New.
@
text
@a29 4
#include "objfiles.h"
#include "gdbtypes.h"
#include "dictionary.h"
#include "gdbcmd.h"
a54 29
/* This block exists only to store symbols associated to namespaces.
   Normally, try to avoid accessing it directly: instead, use
   get_namespace_block if you can.  Similarly with
   possible_namespace_block and namespace_objfile.  */

static struct block *namespace_block = NULL;

static struct block *possible_namespace_block = NULL;

static struct objfile *namespace_objfile = NULL;

static void initialize_namespace_blocks (void);

static struct block *get_namespace_block (void);

static struct block *get_possible_namespace_block (void);

static struct objfile *get_namespace_objfile (void);

static void free_namespace_blocks (struct symtab *symtab);

static int check_one_possible_namespace_symbol (const char *name,
						int len);

static int check_possible_namespace_symbols_loop (const char *name,
						  int len);

static void maintenance_print_namespace (char *args, int from_tty);

a265 270
}

/* Allocate everything necessary for namespace_block and
   possible_namespace_block.  */

static void
initialize_namespace_blocks (void)
{
  struct objfile *objfile = get_namespace_objfile ();
  struct symtab *namespace_symtab;
  struct blockvector *bv;
  struct block *bl;

  namespace_symtab = allocate_symtab ("<C++-namespaces>", objfile);
  namespace_symtab->language = language_cplus;
  namespace_symtab->free_code = free_nothing;
  namespace_symtab->dirname = NULL;

  /* 2 = 3 blocks (global = namespace_block, static = NULL,
     possible_namespace_block) - 1 block that's always part of struct
     blockvector.  */
  bv = obstack_alloc (&objfile->symbol_obstack,
		      sizeof (struct blockvector)
		      + 2 * sizeof (struct block *));
  BLOCKVECTOR_NBLOCKS (bv) = 3;
  BLOCKVECTOR (namespace_symtab) = bv;
  
  /* Allocate dummy STATIC_BLOCK. */
  bl = allocate_block (&objfile->symbol_obstack);
  BLOCK_DICT (bl) = dict_create_linear (&objfile->symbol_obstack,
					NULL);
  BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK) = bl;

  /* Allocate GLOBAL_BLOCK, which is namespace_block.  */
  bl = allocate_block (&objfile->symbol_obstack);
  BLOCK_DICT (bl) = dict_create_hashed_expandable ();
  BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK) = bl;
  namespace_block = bl;

  /* Allocate possible_namespace_block; we put it where the first
     local block will live, though I don't think there's any need to
     pretend that it's actually a local block (e.g. by setting
     BLOCK_SUPERBLOCK appropriately).  */
  bl = allocate_block (&objfile->symbol_obstack);
  BLOCK_DICT (bl) = dict_create_hashed_expandable ();
  BLOCKVECTOR_BLOCK (bv, 2) = bl;
  possible_namespace_block = bl;

  namespace_symtab->free_func = free_namespace_blocks;
}

/* Locate namespace_block, allocating it if necessary.  */

static struct block *
get_namespace_block (void)
{
  if (namespace_block == NULL)
    initialize_namespace_blocks ();

  return namespace_block;
}

/* Locate possible_namespace_block, allocating it if necessary.  */

static struct block *
get_possible_namespace_block (void)
{
  if (namespace_block == NULL)
    initialize_namespace_blocks ();

  return possible_namespace_block;
}

/* Free the dictionary associated to the namespace block.  */

static void
free_namespace_blocks (struct symtab *symtab)
{
  gdb_assert (namespace_block != NULL);
  dict_free (BLOCK_DICT (namespace_block));
  namespace_block = NULL;
  dict_free (BLOCK_DICT (possible_namespace_block));
  possible_namespace_block = NULL;
  namespace_objfile = NULL;
}

/* Locate the namespace objfile, allocating it if necessary.  */

static struct objfile *
get_namespace_objfile (void)
{
  if (namespace_objfile == NULL)
    {
      namespace_objfile = allocate_objfile (NULL, 0);
      namespace_objfile->name = "<C++-namespaces>";
    }

  return namespace_objfile;
}

/* Check to see if there's already a namespace symbol corresponding to
   the initial substring of NAME whose length is LEN; if there isn't
   one, allocate one and add it to the namespace symtab.  Return the
   symbol in question.  */

struct symbol *
cp_check_namespace_symbol (const char *name, int len)
{
  struct objfile *objfile = get_namespace_objfile ();
  char *name_copy = obsavestring (name, len, &objfile->symbol_obstack);
  struct symbol *sym = cp_lookup_namespace_symbol (name_copy);

  if (sym == NULL)
    {
      struct type *type = init_type (TYPE_CODE_NAMESPACE, 0, 0,
				     name_copy, objfile);
      TYPE_TAG_NAME (type) = TYPE_NAME (type);

      sym = obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
      memset (sym, 0, sizeof (struct symbol));
      SYMBOL_LANGUAGE (sym) = language_cplus;
      DEPRECATED_SYMBOL_NAME (sym) = name_copy;
      SYMBOL_CLASS (sym) = LOC_TYPEDEF;
      SYMBOL_TYPE (sym) = type;
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;

      dict_add_symbol (BLOCK_DICT (get_namespace_block ()), sym);
    }
  else
    {
      obstack_free (&objfile->symbol_obstack, name_copy);
    }

  return sym;
}

/* Look for a symbol in namespace_block named NAME.  */

struct symbol *
cp_lookup_namespace_symbol (const char *name)
{
  return lookup_block_symbol (get_namespace_block (), name, NULL,
			      VAR_NAMESPACE);
}

/* The next few functions deal with "possible namespace symbols".
   These are symbols that claim to be associated to namespaces,
   whereas in fact we don't know if the object of that name is a
   namespace or a class.  So don't trust them until you've searched
   through all the global symbols to see if there's a class of that
   name or not.  */

/* FIXME: carlton/2002-12-18: This concept is a hack.  But it seems to
   be the easiest way to deal with our desire for namespace symbols,
   given the commonness of compilers that don't generate debugging
   info for them.  Once such compilers are more common, we should
   delete all the possible namespace stuff.  */

/* Check to see if there's already a possible namespace symbol whose
   name is the initial substring of NAME of length LEN.  If not,
   create one and return 0; otherwise, return 1.  */

static int
check_one_possible_namespace_symbol (const char *name, int len)
{
  struct objfile *objfile = get_namespace_objfile ();
  char *name_copy = obsavestring (name, len, &objfile->symbol_obstack);
  const struct block *block = get_possible_namespace_block ();
  struct symbol *sym = lookup_block_symbol (block, name_copy,
					    NULL, VAR_NAMESPACE);

  if (sym == NULL)
    {
      struct type *type = init_type (TYPE_CODE_NAMESPACE, 0, 0,
				     name_copy, objfile);
      TYPE_TAG_NAME (type) = TYPE_NAME (type);

      sym = obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
      memset (sym, 0, sizeof (struct symbol));
      SYMBOL_LANGUAGE (sym) = language_cplus;
      DEPRECATED_SYMBOL_NAME (sym) = name_copy;
      SYMBOL_CLASS (sym) = LOC_TYPEDEF;
      SYMBOL_TYPE (sym) = type;
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;

      dict_add_symbol (BLOCK_DICT (block), sym);
      return 0;
    }
  else
    {
      obstack_free (&objfile->symbol_obstack, name_copy);
      return 1;
    }
}

/* This is a helper loop for cp_check_possible_namespace_symbols; it
   ensures that there are namespace symbols for all namespaces that
   are initial substrings of NAME of length LEN.  It returns 1 if a
   previous loop had already created the shortest such symbol and 0
   otherwise.  */

static int
check_possible_namespace_symbols_loop (const char *name, int len)
{
  if (name[len] == ':')
    {
      int done;
      int next_len = len + 2;

      next_len += cp_find_first_component (name + next_len);
      done = check_possible_namespace_symbols_loop (name, next_len);

      if (!done)
	{
	  done = check_one_possible_namespace_symbol (name, len);
	}

      return done;
    }
  else
    return 0;
}

/* Ensure that there are symbols in possible_namespace_block for all
   initial substrings of NAME that look like namespaces or
   classes.  */

void
cp_check_possible_namespace_symbols (const char *name)
{
  check_possible_namespace_symbols_loop (name,
					 cp_find_first_component (name));
}

/* Look for a symbol in possible_namespace_block named NAME.  */

struct symbol *
cp_lookup_possible_namespace_symbol (const char *name)
{
  return lookup_block_symbol (get_possible_namespace_block (),
			      name, NULL, VAR_NAMESPACE);
}

static void
maintenance_cplus_namespace (char *args, int from_tty)
{
  const struct block *namespace_block = get_namespace_block ();
  const struct block *possible_namespace_block
    = get_possible_namespace_block ();
  struct dict_iterator iter;
  struct symbol *sym;

  printf_unfiltered ("Definite namespaces:\n");
  ALL_BLOCK_SYMBOLS (namespace_block, iter, sym)
    {
      printf_unfiltered ("%s\n", SYMBOL_PRINT_NAME (sym));
    }
  printf_unfiltered ("Possible namespaces:\n");
  ALL_BLOCK_SYMBOLS (possible_namespace_block, iter, sym)
    {
      printf_unfiltered ("%s\n", SYMBOL_PRINT_NAME (sym));
    }
}

void
_initialize_cp_namespace (void)
{
  add_cmd ("namespace", class_maintenance, maintenance_cplus_namespace,
	   "Print the list of current known C++ namespaces.",
	   &maint_cplus_cmd_list);
@


1.1.2.3
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d393 1
a393 2
      namespace_objfile->name
	= mstrsave (namespace_objfile->md, "<C++-namespaces>");
@


1.1.2.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d4 1
a4 1
   Contributed by David Carlton and by Kealia, Inc.
a58 15
static struct symbol *lookup_namespace_scope (const char *name,
					      const char *linkage_name,
					      const struct block *block,
					      const domain_enum domain,
					      struct symtab **symtab,
					      const char *scope,
					      int scope_len);

static struct symbol *lookup_symbol_file (const char *name,
					  const char *linkage_name,
					  const struct block *block,
					  const domain_enum domain,
					  struct symtab **symtab,
					  int anonymous_namespace);

a300 208
/* The C++-specific version of name lookup for static and global
   names.  This makes sure that names get looked for in all namespaces
   that are in scope.  NAME is the natural name of the symbol that
   we're looking for, LINKAGE_NAME (which is optional) is its linkage
   name, BLOCK is the block that we're searching within, DOMAIN says
   what kind of symbols we're looking for, and if SYMTAB is non-NULL,
   we should store the symtab where we found the symbol in it.  */

struct symbol *
cp_lookup_symbol_nonlocal (const char *name,
			   const char *linkage_name,
			   const struct block *block,
			   const domain_enum domain,
			   struct symtab **symtab)
{
  return lookup_namespace_scope (name, linkage_name, block, domain,
				 symtab, block_scope (block), 0);
}

/* Lookup NAME at namespace scope (or, in C terms, in static and
   global variables).  SCOPE is the namespace that the current
   function is defined within; only consider namespaces whose length
   is at least SCOPE_LEN.  Other arguments are as in
   cp_lookup_symbol_nonlocal.

   For example, if we're within a function A::B::f and looking for a
   symbol f, this will get called with NAME = "f", SCOPE = "A::B", and
   SCOPE_LEN = 0.  It then calls itself with NAME and SCOPE the same,
   but with SCOPE_LEN = 1.  And then it calls itself with NAME and
   SCOPE the same, but with SCOPE_LEN = 4.  This third call looks for
   "A::B::x"; if it doesn't find it, then the second call looks for
   "A::x", and if that call fails, then the first call looks for
   "x".  */

static struct symbol *
lookup_namespace_scope (const char *name,
			const char *linkage_name,
			const struct block *block,
			const domain_enum domain,
			struct symtab **symtab,
			const char *scope,
			int scope_len)
{
  char *namespace;

  if (scope[scope_len] != '\0')
    {
      /* Recursively search for names in child namespaces first.  */

      struct symbol *sym;
      int new_scope_len = scope_len;

      /* If the current scope is followed by "::", skip past that.  */
      if (new_scope_len != 0)
	{
	  gdb_assert (scope[new_scope_len] == ':');
	  new_scope_len += 2;
	}
      new_scope_len += cp_find_first_component (scope + new_scope_len);
      sym = lookup_namespace_scope (name, linkage_name, block,
				    domain, symtab,
				    scope, new_scope_len);
      if (sym != NULL)
	return sym;
    }

  /* Okay, we didn't find a match in our children, so look for the
     name in the current namespace.  */

  namespace = alloca (scope_len + 1);
  strncpy (namespace, scope, scope_len);
  namespace[scope_len] = '\0';
  return cp_lookup_symbol_namespace (namespace, name, linkage_name,
				     block, domain, symtab);
}

/* Look up NAME in the C++ namespace NAMESPACE, applying the using
   directives that are active in BLOCK.  Other arguments are as in
   cp_lookup_symbol_nonlocal.  */

struct symbol *
cp_lookup_symbol_namespace (const char *namespace,
			    const char *name,
			    const char *linkage_name,
			    const struct block *block,
			    const domain_enum domain,
			    struct symtab **symtab)
{
  const struct using_direct *current;
  struct symbol *sym;

  /* First, go through the using directives.  If any of them add new
     names to the namespace we're searching in, see if we can find a
     match by applying them.  */

  for (current = block_using (block);
       current != NULL;
       current = current->next)
    {
      if (strcmp (namespace, current->outer) == 0)
	{
	  sym = cp_lookup_symbol_namespace (current->inner,
					    name,
					    linkage_name,
					    block,
					    domain,
					    symtab);
	  if (sym != NULL)
	    return sym;
	}
    }

  /* We didn't find anything by applying any of the using directives
     that are still applicable; so let's see if we've got a match
     using the current namespace.  */
  
  if (namespace[0] == '\0')
    {
      return lookup_symbol_file (name, linkage_name, block,
				 domain, symtab, 0);
    }
  else
    {
      char *concatenated_name
	= alloca (strlen (namespace) + 2 + strlen (name) + 1);
      strcpy (concatenated_name, namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, name);
      sym = lookup_symbol_file (concatenated_name, linkage_name,
				block, domain, symtab,
				cp_is_anonymous (namespace));
      return sym;
    }
}

/* Look up NAME in BLOCK's static block and in global blocks.  If
   ANONYMOUS_NAMESPACE is nonzero, the symbol in question is located
   within an anonymous namespace.  Other arguments are as in
   cp_lookup_symbol_nonlocal.  */

static struct symbol *
lookup_symbol_file (const char *name,
		    const char *linkage_name,
		    const struct block *block,
		    const domain_enum domain,
		    struct symtab **symtab,
		    int anonymous_namespace)
{
  struct symbol *sym = NULL;

  sym = lookup_symbol_static (name, linkage_name, block, domain, symtab);
  if (sym != NULL)
    return sym;

  if (anonymous_namespace)
    {
      /* Symbols defined in anonymous namespaces have external linkage
	 but should be treated as local to a single file nonetheless.
	 So we only search the current file's global block.  */

      const struct block *global_block = block_global_block (block);
      
      if (global_block != NULL)
	sym = lookup_symbol_aux_block (name, linkage_name, global_block,
				       domain, symtab);

      if (sym == NULL || global_block == NULL)
	sym = cp_lookup_namespace_symbol (name);
    }
  else
    {
      sym = lookup_symbol_global (name, linkage_name, domain, symtab);
    }

  if (sym != NULL)
    return sym;

  /* Now call "cp_lookup_possible_namespace_symbol".  Symbols in here
     claim to be associated to namespaces, whereas the names in
     question might actually correspond to either namespaces or to
     classes.  But if they correspond to classes, then we should have
     found a match to them above.  So if we find them now, they should
     be genuine.  */

  /* FIXME: carlton/2002-12-18: This is a hack and should eventually
     be deleted: see cp-support.c.  */

  /* FIXME: carlton/2003-01-06: Searching this seems a bit fishy if
     anonymous_namespace is nonzero, since we might return a namespace
     that's really a class that doesn't happen to be mentioned in the
     current file.  Sigh.  Still, I don't think anything catastrophic
     should happen in that case.  Probably the right thing to do is to
     move anonymous namespace symbols to files' static blocks.  */

  if (domain == VAR_DOMAIN)
    {
      sym = cp_lookup_possible_namespace_symbol (name);
      if (sym != NULL)
	{
	  if (symtab != NULL)
	    *symtab = NULL;
	  return sym;
	}
    }

  return NULL;
}

d424 1
a424 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d442 1
a442 1
			      VAR_DOMAIN);
d469 1
a469 1
					    NULL, VAR_DOMAIN);
d483 1
a483 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d540 1
a540 1
			      name, NULL, VAR_DOMAIN);
@


1.1.2.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Makefile.in (cp-namespace.o): Depend on frame_h.
	* cp-support.h: Declare lookup_transparent_type_namespace,
	lookup_transparent_type_namespace_loop.
	* cp-namespace.c: Include frame.h.
	(lookup_transparent_type_namespace): New.
	(lookup_transparent_type_namespace_loop): New.
	* symtab.h: Declare lookup_transparent_type_aux.
	* symtab.c (lookup_transparent_type): Add FIXME, fork off code
	into lookup_transparent_type_aux, do backup strategy of trying to
	look in namespaces.
	(lookup_transparent_type_aux): New.
@
text
@a33 1
#include "frame.h"
a73 4
static struct type *lookup_transparent_type_namespace_loop (const char *name,
							    const char *scope,
							    int scope_len);

a521 52
}

/* Try to look up the type definition associated to NAME if honest
   methods don't work: look for NAME in the classes/namespaces that
   are currently active, on the off chance that it might be there.  */

struct type *
lookup_transparent_type_namespace (const char *name)
{
  const char *scope = block_scope (get_selected_block (0));

  if (strstr (scope, "::") == NULL)
    return NULL;

  return lookup_transparent_type_namespace_loop (name, scope, 0);
}

/* Lookup the the type definition associated to NAME in
   namespaces/classes containing SCOPE other than the global
   namespace.  */

static struct type *
lookup_transparent_type_namespace_loop (const char *name, const char *scope,
					int scope_len)
{
  int new_scope_len = scope_len;
  char *full_name;

  /* If the current scope is followed by "::", skip past that.  */
  if (new_scope_len != 0)
    new_scope_len += 2;
  new_scope_len += cp_find_first_component (scope + new_scope_len);

  if (scope[new_scope_len] == ':')
    {
      struct type *retval
	= lookup_transparent_type_namespace_loop (name, scope, new_scope_len);
      if (retval != NULL)
	return retval;
    }

  /* If there's no enclosing scope, lookup_transparent_type would have
     found it. */
  if (scope_len == 0)
    return NULL;

  full_name = alloca (scope_len + 2 + strlen (name) + 1);
  strncpy (full_name, scope, scope_len);
  strncpy (full_name + scope_len, "::", 2);
  strcpy (full_name + scope_len + 2, name);

  return lookup_transparent_type_aux (full_name);
@


1.1.2.6
log
@2003-06-16  David Carlton  <carlton@@kealia.com>

	* symfile.h: Change formatting.
	* block.c (allocate_block): Rephrase comment.
	* block.h (BLOCK_GCC_COMPILED): Move definition.
	* cp-namespace.c: Include command.h instead of gdbcmd.h.  Update
	comments, reorder functions.
	(lookup_symbol_file): Set symtab when looking for namespace
	symbols.  Update call to lookup_possible_namespace_symbol.
	(initialize_namespace_blocks): Change comment.
	(get_namespace_objfile): Change objfile name.
	(cp_check_namespace_symbol): Extract body into
	check_namespace_symbol_block.
	(check_namespace_symbol_block): New.
	(lookup_namespace_symbol): Make static, rename from
	cp_lookup_symbol.
	(check_possible_namespace_symbols_loop): Update comment.
	(check_one_possible_namespace_symbol): Call
	check_namespace_symbol_block.
	(lookup_possible_namespace_symbol): Make static; rename from
	cp_lookup_possible_namespace_symbol.
	* cp-support.h: Update declarations.
	* Makefile.in (c-typeprint.o): Don't depend on gdb_assert_h.
	(cp-namespace.o): Depend on command_h, not gdbcmd_h.
	* c-typeprint.c: Don't include gdb_assert.h.
	(c_type_print_base): Delete assertion.  Use TYPE_TAG_NAME.
	* dwarf2read.c: Delete double include of cp-support.h.
	(add_partial_symbol): Look at psym for static variables.
	(add_partial_namespace): Update call to
	cp_check_namespace_symbol.
	(locate_pdi_sibling): Update comment.

2003-06-16  David Carlton  <carlton@@kealia.com>

	* gdb.c++/namespace.exp: Add 'maint cp namespace' test.
	* gdb.c++/maint.exp (test_namespace): Change comment.
@
text
@d33 1
a33 1
#include "command.h"
d79 4
a82 4
/* The next three variables are used to store symbols associated to
   namespaces.  Don't refer to them directly: use
   get_namespace_block(), get_possible_namespace_block(), and
   get_namespace_objfile() instead.  */
a95 2
static void free_namespace_blocks (struct symtab *symtab);

d98 1
a98 2
static int check_namespace_symbol_block (const char *name, int len,
					 struct block *block);
d100 2
a101 1
static struct symbol *lookup_namespace_symbol (const char *name);
a105 5
static int check_one_possible_namespace_symbol (const char *name,
						int len);

static struct symbol *lookup_possible_namespace_symbol (const char *name);

d488 1
a488 5
	{
	  sym = lookup_namespace_symbol (name);
	  if (sym != NULL && symtab != NULL)
	    *symtab = NULL;
	}
d498 1
a498 1
  /* Now call "lookup_possible_namespace_symbol".  Symbols in here
d517 1
a517 1
      sym = lookup_possible_namespace_symbol (name);
a580 19
/* Now come functions for dealing with symbols associated to
   namespaces.  (They're used to store the namespaces themselves, not
   objects that live in the namespaces.)  Since namespaces span files,
   we create special blocks to store those symbols in instead of
   storing them in blocks associated to actual files.  That avoids
   duplication of symbols, among other issues.

   Unfortunately, versions of GCC through at least 3.3 don't generate
   debugging information to tell us about the existence of namespaces.
   Our solution is to try to guess their existence by looking at
   demangled names.  This might cause us to misidentify classes as
   namespaces, however.  So we put those symbols in
   'possible_namespace_block' instead of 'namespace_block', and we
   only search that block as a last resort.  */

/* FIXME: carlton/2003-06-12: Once versions of GCC that generate
   DW_TAG_namespace have been out for a year or two, we should get rid
   of possible_namespace_block and everything associated to it.  */

d597 3
a599 3
  /* 2 = three blocks (global = namespace_block, static = NULL, third
     block = possible_namespace_block), minus the one block that's
     always part of struct blockvector.  */
d674 1
a674 1
	= mstrsave (namespace_objfile->md, "<<C++-namespaces>>");
d680 4
a683 3
/* Check to see if there's already a namespace symbol whose name is
   NAME.  If there isn't one, allocate one and add it to the namespace
   symtab.  */
d685 2
a686 16
void
cp_check_namespace_symbol (const char *name)
{
  check_namespace_symbol_block (name, strlen (name),
				get_namespace_block ());
}

/* A helper function used by cp_check_namespace_symbol and
   check_one_possible_namespace_symbol.  Looks to see if there is a
   symbol whose name is the initial substring of NAME of length LEN in
   block BLOCK; if not, adds it.  Return 1 if the symbol was already
   in there, 0 otherwise.  */

static int
check_namespace_symbol_block (const char *name, int len,
			      struct block *block)
d690 1
a690 2
  struct symbol *sym = lookup_block_symbol (block, name_copy, NULL,
					    VAR_DOMAIN);
d701 1
a701 1
      SYMBOL_SET_NAMES (sym, name_copy, len, objfile);
d706 1
a706 3
      dict_add_symbol (BLOCK_DICT (block), sym);

      return 0;
d711 1
d713 1
a713 2
      return 1;
    }
d718 2
a719 2
static struct symbol *
lookup_namespace_symbol (const char *name)
d725 16
a740 4
/* Ensure that there are symbols in possible_namespace_block for all
   initial substrings of NAME that look like namespaces or classes.
   NAME should end in a member variable: it shouldn't consist solely
   of namespaces.  */
d742 2
a743 2
void
cp_check_possible_namespace_symbols (const char *name)
d745 28
a772 2
  check_possible_namespace_symbols_loop (name,
					 cp_find_first_component (name));
d777 3
a779 14
   are initial substrings of NAME of length at least LEN.  It returns
   1 if a previous loop had already created the shortest such symbol
   and 0 otherwise.

   This function assumes that if there is already a symbol associated
   to a substring of NAME of a given length, then there are already
   symbols associated to all substrings of NAME whose length is less
   than that length.  So if cp_check_possible_namespace_symbols has
   been called once with argument "A::B::C::member", then that will
   create symbols "A", "A::B", and "A::B::C".  If it is then later
   called with argument "A::B::D::member", then the new call will
   generate a new symbol for "A::B::D", but once it sees that "A::B"
   has already been created, it doesn't bother checking to see if "A"
   has also been created.  */
d803 3
a805 3
/* Check to see if there's already a possible namespace symbol whose
   name is the initial substring of NAME of length LEN.  If not,
   create one and return 0; otherwise, return 1.  */
d807 2
a808 2
static int
check_one_possible_namespace_symbol (const char *name, int len)
d810 2
a811 2
  return check_namespace_symbol_block (name, len,
				       get_possible_namespace_block ());
d816 2
a817 2
static struct symbol *
lookup_possible_namespace_symbol (const char *name)
@


1.1.2.7
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a45 3
/* FIXME: carlton/2003-06-12: This isn't entirely reliable: currently,
   we get mislead by DW_AT_specification.  */

a234 6
#if 0
      /* FIXME: carlton/2003-06-12: As mentioned above,
	 'processing_has_namespace_info' currently isn't entirely
	 reliable, so let's always use demangled names to get this
	 information for now.  */

a243 1
#endif
@


1.1.2.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (add_partial_symbol): Add 'objfile' argument to
	call to cp_check_possible_namespace_symbols.
	(add_partial_namespace): Add partial symbol instead of calling
	cp_check_namespace_symbol.
	(read_namespace): Add symbol associated to namespace.
	(new_symbol): Handle DW_TAG_namespace.
	* cp-support.h: Delete declaration of cp_check_namespace_symbol;
	add 'objfile' argument to declaration of
	cp_check_possible_namespace_symbols.
	* cp-namespace.c: Delete variables namespace_block,
	possible_namespace_block, namespace_objfile.
	Delete functions get_namespace_block, get_namespace_objfile,
	cp_check_namespace_symbol, check_namespace_symbol_block,
	lookup_namespace_symbol.
	(lookup_symbol_file): Delete call to lookup_namespace_symbol;
	tweak call to lookup_possible_namespace_symbol.
	(initialize_namespace_symtab): Rename from
	initialize_namespace_blocks; add 'objfile' argument, don't do
	anything special with global block.
	(get_possible_namespace_block): Add 'objfile' argument.
	(check_possible_namespace_symbols_loop)
	(cp_check_possible_namespace_symbols): Ditto.
	(free_namespace_block): Rename from free_namespace_blocks; don't
	do anything special with global block.
	(check_one_possible_namespace_symbol): Add 'objfile' argument, and
	inline call to check_namespace_symbol_block.
	(lookup_possible_namespace_symbol): Add 'symtab' argument, loop
	over all objfiles.
	(maintenance_cplus_namespace): Only have possible symbols; add
	loop over objfiles.
	(_initialize_cp_namespace): Tweak doc string.
	* objfiles.h: Add opaque declaration of struct symtab.
	(struct objfile): Add cp_namespace_symtab member.
	* objfiles.c (allocate_objfile): Set
	objfile->cp_namespace_symtab.

2003-06-27  David Carlton  <carlton@@kealia.com>

	* carlton_runtest (FASTTESTS): Add gdb.c++/pr-1210.exp.
	* gdb.c++/namespace.exp: Delete test for maint cp namespace.
	* gdb.c++/maint.exp (test_help): Tweak output for 'help maint cp
	namespace'.
	(test_namespace): Tweak comment.
@
text
@d82 4
a85 1
static void initialize_namespace_symtab (struct objfile *objfile);
d87 1
a87 1
static struct block *get_possible_namespace_block (struct objfile *objfile);
d89 18
a106 1
static void free_namespace_block (struct symtab *symtab);
d109 1
a109 2
						  int len,
						  struct objfile *objfile);
d112 1
a112 2
						int len,
						struct objfile *objfile);
d114 1
a114 3
static
struct symbol *lookup_possible_namespace_symbol (const char *name,
						 struct symtab **symtab);
d116 1
a116 1
static void maintenance_cplus_namespace (char *args, int from_tty);
d503 7
d520 5
a524 5
     claim to be associated to namespaces, but this claim might be
     incorrect: the names in question might actually correspond to
     classes instead of namespaces.  But if they correspond to
     classes, then we should have found a match for them above.  So if
     we find them now, they should be genuine.  */
d538 1
a538 1
      sym = lookup_possible_namespace_symbol (name, symtab);
d540 5
a544 1
	return sym;
d604 12
a615 9
   objects that live in the namespaces.)  These symbols come in two
   varieties: if we run into a DW_TAG_namespace DIE, then we know that
   we have a namespace, so dwarf2read.c creates a symbol for it just
   like normal.  But, unfortunately, versions of GCC through at least
   3.3 don't generate those DIE's.  Our solution is to try to guess
   their existence by looking at demangled names.  This might cause us
   to misidentify classes as namespaces, however.  So we put those
   symbols in a special block (one per objfile), and we only search
   that block as a last resort.  */
d619 1
a619 1
   of all of this "possible namespace" nonsense.  */
d621 2
a622 2
/* Allocate everything necessary for the possible namespace block
   associated to OBJFILE.  */
d625 1
a625 1
initialize_namespace_symtab (struct objfile *objfile)
d627 1
d632 1
a632 1
  namespace_symtab = allocate_symtab ("<<C++-namespaces>>", objfile);
d637 3
d642 2
a643 2
		      + FIRST_LOCAL_BLOCK * sizeof (struct block *));
  BLOCKVECTOR_NBLOCKS (bv) = FIRST_LOCAL_BLOCK + 1;
d646 1
a646 2
  /* Allocate empty GLOBAL_BLOCK and STATIC_BLOCK. */

d650 5
d656 1
a656 4
  bl = allocate_block (&objfile->symbol_obstack);
  BLOCK_DICT (bl) = dict_create_linear (&objfile->symbol_obstack,
					NULL);
  BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK) = bl;
d658 1
a658 1
  /* Allocate the possible namespace block; we put it where the first
a661 1

d664 2
a665 1
  BLOCKVECTOR_BLOCK (bv, FIRST_LOCAL_BLOCK) = bl;
d667 1
a667 3
  namespace_symtab->free_func = free_namespace_block;

  objfile->cp_namespace_symtab = namespace_symtab;
d670 1
a670 2
/* Locate the possible namespace block associated to OBJFILE,
   allocating it if necessary.  */
d673 1
a673 1
get_possible_namespace_block (struct objfile *objfile)
d675 2
a676 2
  if (objfile->cp_namespace_symtab == NULL)
    initialize_namespace_symtab (objfile);
d678 1
a678 2
  return BLOCKVECTOR_BLOCK (BLOCKVECTOR (objfile->cp_namespace_symtab),
			    FIRST_LOCAL_BLOCK);
d681 1
a681 1
/* Free the dictionary associated to the possible namespace block.  */
d683 2
a684 2
static void
free_namespace_block (struct symtab *symtab)
d686 2
a687 1
  struct block *possible_namespace_block;
d689 1
a689 4
  possible_namespace_block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab),
						FIRST_LOCAL_BLOCK);
  gdb_assert (possible_namespace_block != NULL);
  dict_free (BLOCK_DICT (possible_namespace_block));
d692 1
a692 4
/* Ensure that there are symbols in the possible namespace block
   associated to OBJFILE for all initial substrings of NAME that look
   like namespaces or classes.  NAME should end in a member variable:
   it shouldn't consist solely of namespaces.  */
d694 2
a695 2
void
cp_check_possible_namespace_symbols (const char *name, struct objfile *objfile)
d697 6
a702 3
  check_possible_namespace_symbols_loop (name,
					 cp_find_first_component (name),
					 objfile);
d705 1
a705 17
/* This is a helper loop for cp_check_possible_namespace_symbols; it
   ensures that there are symbols in the possible namespace block
   associated to OBJFILE for all namespaces that are initial
   substrings of NAME of length at least LEN.  It returns 1 if a
   previous loop had already created the shortest such symbol and 0
   otherwise.

   This function assumes that if there is already a symbol associated
   to a substring of NAME of a given length, then there are already
   symbols associated to all substrings of NAME whose length is less
   than that length.  So if cp_check_possible_namespace_symbols has
   been called once with argument "A::B::C::member", then that will
   create symbols "A", "A::B", and "A::B::C".  If it is then later
   called with argument "A::B::D::member", then the new call will
   generate a new symbol for "A::B::D", but once it sees that "A::B"
   has already been created, it doesn't bother checking to see if "A"
   has also been created.  */
d707 2
a708 3
static int
check_possible_namespace_symbols_loop (const char *name, int len,
				       struct objfile *objfile)
d710 1
a710 1
  if (name[len] == ':')
d712 4
a715 2
      int done;
      int next_len = len + 2;
d717 2
a718 3
      next_len += cp_find_first_component (name + next_len);
      done = check_possible_namespace_symbols_loop (name, next_len,
						    objfile);
d720 3
a722 2
      if (!done)
	done = check_one_possible_namespace_symbol (name, len, objfile);
d724 5
a728 4
      return done;
    }
  else
    return 0;
d731 5
a735 3
/* Check to see if there's already a possible namespace symbol in
   OBJFILE whose name is the initial substring of NAME of length LEN.
   If not, create one and return 0; otherwise, return 1.  */
d738 2
a739 2
check_one_possible_namespace_symbol (const char *name, int len,
				     struct objfile *objfile)
d741 1
a741 1
  struct block *block = get_possible_namespace_block (objfile);
d772 1
a772 3
/* Look for a symbol named NAME in all the possible namespace blocks.
   If one is found, return it; if SYMTAB is non-NULL, set *SYMTAB to
   equal the symtab where it was found.  */
d775 1
a775 1
lookup_possible_namespace_symbol (const char *name, struct symtab **symtab)
d777 8
a784 1
  struct objfile *objfile;
d786 28
a813 1
  ALL_OBJFILES (objfile)
d815 2
a816 1
      struct symbol *sym;
d818 2
a819 2
      sym = lookup_block_symbol (get_possible_namespace_block (objfile),
				 name, NULL, VAR_DOMAIN);
d821 1
a821 1
      if (sym != NULL)
d823 2
a824 2
	  if (symtab != NULL)
	    *symtab = objfile->cp_namespace_symtab;
d826 1
a826 2
	  return sym;
	}
d828 7
d836 5
a840 1
  return NULL;
d843 8
a850 1
/* Print out all the possible namespace symbols.  */
d855 11
a865 1
  struct objfile *objfile;
d867 1
a867 1
  ALL_OBJFILES (objfile)
d869 1
a869 7
      struct dict_iterator iter;
      struct symbol *sym;

      ALL_BLOCK_SYMBOLS (get_possible_namespace_block (objfile), iter, sym)
	{
	  printf_unfiltered ("%s\n", SYMBOL_PRINT_NAME (sym));
	}
d877 1
a877 1
	   "Print the list of possible C++ namespaces.",
@


1.1.2.9
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d503 2
a504 2
  /* FIXME: carlton/2003-06-12: This is a hack and should eventually
     be deleted: see comments below.  */
d626 1
a626 10
     BLOCK_SUPERBLOCK appropriately).  We don't use the global or
     static block because we don't want it searched during the normal
     search of all global/static blocks in lookup_symbol: we only want
     it used as a last resort.  */

  /* NOTE: carlton/2003-09-11: I considered not associating the fake
     symbols to a block/symtab at all.  But that would cause problems
     with lookup_symbol's SYMTAB argument and with block_found, so
     having a symtab/block for this purpose seems like the best
     solution for now.  */
@


1.1.2.10
log
@2003-09-30  David Carlton  <carlton@@kealia.com>

	* Makefile.in (c-exp.tab.o): Depend on cp_support_h.
	* c-exp.y: Include c-exp.y.  Update comments, replace
	lookup_nested_type by cp_lookup_nested_type.
	(yylex): Update comments, remove #if 0 block.
	* cp-namespace.c (cp_lookup_nested_type): Move here from symtab.c;
	rename from lookup_nested_type.
	* cp-support.h: Add cp_lookup_nested_type declaration.
	* dwarf2read.c (read_die_and_children): Update comment.
	(read_die_and_siblings): Update comment, move declaration of
	'die'.
	(read_full_die): Update comment, tweak formatting.
	* symtab.c (lookup_nested_type): Move to cp-namespace.c, rename to
	cp_lookup_nested_type.
	* symtab.h: Delete declaration of lookup_nested_type.
@
text
@a522 45
/* Look up a type named NESTED_NAME that is nested inside the C++
   class or namespace given by PARENT_TYPE, from within the context
   given by BLOCK.  */

struct type *
cp_lookup_nested_type (struct type *parent_type,
		       const char *nested_name,
		       const struct block *block)
{
  switch (TYPE_CODE (parent_type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_NAMESPACE:
      {
	/* NOTE: carlton/2002-12-17: As of this writing, C++ class
	   members of classes aren't treated like, say, data or
	   function members.  Instead, they're just represented by
	   symbols whose names are qualified by the name of the
	   surrounding class.  This is just like members of
	   namespaces; in particular, lookup_symbol_namespace works
	   when looking them up.  */

	/* NOTE: carlton/2002-12-17: The above is, actually, lying:
	   there are still situations where nested types are
	   represented by symbols that include only the member name,
	   not the parent name.  Sigh.  Blame it on stabs, or
	   something.  */
	const char *parent_name = TYPE_TAG_NAME (parent_type);
	struct symbol *sym = cp_lookup_symbol_namespace (parent_name,
							 nested_name,
							 NULL,
							 block,
							 VAR_DOMAIN,
							 NULL);
	if (sym == NULL || SYMBOL_CLASS (sym) != LOC_TYPEDEF)
	  return NULL;
	else
	  return SYMBOL_TYPE (sym);
      }
    default:
      error ("\"%s\" is not defined as a compound type.",
	     TYPE_NAME (parent_type));
    }
}

@


1.1.2.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* valops.c: Tweak comments to match proposed patch.
	(value_aggregate_elt): Use internal_error instead of error.
	* dwarf2read.c: Tweak comments to match proposed patch.
	(new_symbol): Use SYMBOL_LINKAGE_NAME or SYMBOL_NATURAL_NAME
	instead of DEPRECATED_SYMBOL_NAME.
	* cp-namespace.c: Tweak comments to match proposed patch.
	(cp_set_block_scope): Remove #if 0.
	(cp_lookup_nested_type): Use internal_error instead of error.

2003-11-11  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Remove doubled comment.
@
text
@d36 3
a38 6
/* When set, the file that we're processing is known to have debugging
   info for C++ namespaces.  */

/* NOTE: carlton/2003-11-10: No currently released version of GCC (the
   latest of which is 3.3.x at the time of this writing) produces this
   debug info.  */
d42 3
a44 10
/* This contains our best guess as to the name of the current
   enclosing namespace(s)/class(es), if any.  For example, if we're
   within the method foo() in the following code:

    namespace N {
      class C {
	void foo () {
	}
      };
    }
d46 2
a47 3
    then processing_current_prefix should be set to "N::C".  If
    processing_has_namespace_info is false, then this variable might
    not be reliable.  */
d222 6
d237 1
d506 7
d525 1
a525 1
   given by BLOCK.  Return NULL if there is no such nested type.  */
d563 2
a564 2
      internal_error (__FILE__, __LINE__,
		      "cp_lookup_nested_type called on a non-aggregate type.");
@


1.1.2.12
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d352 1
a352 1
   symbol x, this will get called with NAME = "x", SCOPE = "A::B", and
@


1.1.2.13
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d39 1
a39 1
/* NOTE: carlton/2004-01-13: No currently released version of GCC (the
d41 1
a41 1
   debug info.  GCC 3.4 should, however.  */
d56 3
a58 3
   then processing_current_prefix should be set to "N::C".  If
   processing_has_namespace_info is false, then this variable might
   not be reliable.  */
d89 3
a91 3
static struct type *cp_lookup_transparent_type_loop (const char *name,
						     const char *scope,
						     int scope_len);
d534 13
a546 7
	/* NOTE: carlton/2003-11-10: We don't treat C++ class members
	   of classes like, say, data or function members.  Instead,
	   they're just represented by symbols whose names are
	   qualified by the name of the surrounding class.  This is
	   just like members of namespaces; in particular,
	   lookup_symbol_namespace works when looking them up.  */

d565 3
a567 17
/* The C++-version of lookup_transparent_type.  */

/* FIXME: carlton/2004-01-16: The problem that this is trying to
   address is that, unfortunately, sometimes NAME is wrong: it may not
   include the name of namespaces enclosing the type in question.
   lookup_transparent_type gets called when the the type in question
   is a declaration, and we're trying to find its definition; but, for
   declarations, our type name deduction mechanism doesn't work.
   There's nothing we can do to fix this in general, I think, in the
   absence of debug information about namespaces (I've filed PR
   gdb/1511 about this); until such debug information becomes more
   prevalent, one heuristic which sometimes looks is to search for the
   definition in namespaces containing the current namespace.

   We should delete this functions once the appropriate debug
   information becomes more widespread.  (GCC 3.4 will be the first
   released version of GCC with such information.)  */
d570 1
a570 1
cp_lookup_transparent_type (const char *name)
d572 1
a572 10
  /* First, try the honest way of looking up the definition.  */
  struct type *t = basic_lookup_transparent_type (name);
  const char *scope;

  if (t != NULL)
    return t;

  /* If that doesn't work and we're within a namespace, look there
     instead.  */
  scope = block_scope (get_selected_block (0));
d574 1
a574 1
  if (scope[0] == '\0')
d577 1
a577 1
  return cp_lookup_transparent_type_loop (name, scope, 0);
d581 2
a582 3
   namespaces/classes containing SCOPE whose name is strictly longer
   than LENGTH.  LENGTH must be the index of the start of a
   component of SCOPE.  */
d585 2
a586 2
cp_lookup_transparent_type_loop (const char *name, const char *scope,
				 int length)
d588 1
a588 1
  int scope_length = cp_find_first_component (scope + length);
d591 6
a596 3
  /* If the current scope is followed by "::", look in the next
     component.  */
  if (scope[scope_length] == ':')
d599 1
a599 1
	= cp_lookup_transparent_type_loop (name, scope, scope_length + 2);
d604 9
a612 4
  full_name = alloca (scope_length + 2 + strlen (name) + 1);
  strncpy (full_name, scope, scope_length);
  strncpy (full_name + scope_length, "::", 2);
  strcpy (full_name + scope_length + 2, name);
d614 1
a614 1
  return basic_lookup_transparent_type (full_name);
@


