head	1.324;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.286
	gdb_7_6-2013-04-26-release:1.286
	gdb_7_6-branch:1.286.0.2
	gdb_7_6-2013-03-12-branchpoint:1.286
	gdb_7_5_1-2012-11-29-release:1.260
	gdb_7_5-2012-08-17-release:1.260
	gdb_7_5-branch:1.260.0.2
	gdb_7_5-2012-07-18-branchpoint:1.260
	gdb_7_4_1-2012-04-26-release:1.243.2.1
	gdb_7_4-2012-01-24-release:1.243.2.1
	gdb_7_4-branch:1.243.0.2
	gdb_7_4-2011-12-13-branchpoint:1.243
	gdb_7_3_1-2011-09-04-release:1.220.2.4
	gdb_7_3-2011-07-26-release:1.220.2.4
	gdb_7_3-branch:1.220.0.2
	gdb_7_3-2011-04-01-branchpoint:1.220
	gdb_7_2-2010-09-02-release:1.191
	gdb_7_2-branch:1.191.0.2
	gdb_7_2-2010-07-07-branchpoint:1.191
	gdb_7_1-2010-03-18-release:1.143.2.2
	gdb_7_1-branch:1.143.0.2
	gdb_7_1-2010-02-18-branchpoint:1.143
	gdb_7_0_1-2009-12-22-release:1.126
	gdb_7_0-2009-10-06-release:1.126
	gdb_7_0-branch:1.126.0.4
	gdb_7_0-2009-09-16-branchpoint:1.126
	arc-sim-20090309:1.101
	msnyder-checkpoint-072509-branch:1.126.0.2
	msnyder-checkpoint-072509-branchpoint:1.126
	arc-insight_6_8-branch:1.101.0.6
	arc-insight_6_8-branchpoint:1.101
	insight_6_8-branch:1.101.0.4
	insight_6_8-branchpoint:1.101
	reverse-20081226-branch:1.113.0.4
	reverse-20081226-branchpoint:1.113
	multiprocess-20081120-branch:1.113.0.2
	multiprocess-20081120-branchpoint:1.113
	reverse-20080930-branch:1.111.0.2
	reverse-20080930-branchpoint:1.111
	reverse-20080717-branch:1.106.0.4
	reverse-20080717-branchpoint:1.106
	msnyder-reverse-20080609-branch:1.106.0.2
	msnyder-reverse-20080609-branchpoint:1.106
	drow-reverse-20070409-branch:1.89.0.2
	drow-reverse-20070409-branchpoint:1.89
	gdb_6_8-2008-03-27-release:1.101
	gdb_6_8-branch:1.101.0.2
	gdb_6_8-2008-02-26-branchpoint:1.101
	gdb_6_7_1-2007-10-29-release:1.97
	gdb_6_7-2007-10-10-release:1.97
	gdb_6_7-branch:1.97.0.2
	gdb_6_7-2007-09-07-branchpoint:1.97
	insight_6_6-20070208-release:1.87
	gdb_6_6-2006-12-18-release:1.87
	gdb_6_6-branch:1.87.0.2
	gdb_6_6-2006-11-15-branchpoint:1.87
	insight_6_5-20061003-release:1.86
	gdb-csl-symbian-6_4_50_20060226-12:1.84.6.1
	gdb-csl-sourcerygxx-3_4_4-25:1.78
	nickrob-async-20060828-mergepoint:1.87
	gdb-csl-symbian-6_4_50_20060226-11:1.84.6.1
	gdb-csl-sourcerygxx-4_1-17:1.84.2.1
	gdb-csl-20060226-branch-local-2:1.84.2.1
	gdb-csl-sourcerygxx-4_1-14:1.84
	gdb-csl-sourcerygxx-4_1-13:1.84
	gdb-csl-sourcerygxx-4_1-12:1.84
	gdb-csl-sourcerygxx-3_4_4-21:1.84
	gdb_6_5-20060621-release:1.86
	gdb-csl-sourcerygxx-4_1-9:1.84
	gdb-csl-sourcerygxx-4_1-8:1.84
	gdb-csl-sourcerygxx-4_1-7:1.84
	gdb-csl-arm-2006q1-6:1.84
	gdb-csl-sourcerygxx-4_1-6:1.84
	gdb-csl-symbian-6_4_50_20060226-10:1.84.6.1
	gdb-csl-symbian-6_4_50_20060226-9:1.84.6.1
	gdb-csl-symbian-6_4_50_20060226-8:1.84.6.1
	gdb-csl-coldfire-4_1-11:1.84
	gdb-csl-sourcerygxx-3_4_4-19:1.84
	gdb-csl-coldfire-4_1-10:1.84
	gdb_6_5-branch:1.86.0.8
	gdb_6_5-2006-05-14-branchpoint:1.86
	gdb-csl-sourcerygxx-4_1-5:1.84
	nickrob-async-20060513-branch:1.86.0.6
	nickrob-async-20060513-branchpoint:1.86
	gdb-csl-sourcerygxx-4_1-4:1.84
	msnyder-reverse-20060502-branch:1.86.0.4
	msnyder-reverse-20060502-branchpoint:1.86
	gdb-csl-morpho-4_1-4:1.84
	gdb-csl-sourcerygxx-3_4_4-17:1.84
	readline_5_1-import-branch:1.86.0.2
	readline_5_1-import-branchpoint:1.86
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.84
	gdb-csl-symbian-20060226-branch:1.84.0.6
	gdb-csl-symbian-20060226-branchpoint:1.84
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.84
	msnyder-reverse-20060331-branch:1.85.0.2
	msnyder-reverse-20060331-branchpoint:1.85
	gdb-csl-available-20060303-branch:1.84.0.4
	gdb-csl-available-20060303-branchpoint:1.84
	gdb-csl-20060226-branch:1.84.0.2
	gdb-csl-20060226-branchpoint:1.84
	gdb_6_4-20051202-release:1.78
	msnyder-fork-checkpoint-branch:1.82.0.2
	msnyder-fork-checkpoint-branchpoint:1.82
	gdb-csl-gxxpro-6_3-branch:1.78.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.78
	gdb_6_4-branch:1.78.0.4
	gdb_6_4-2005-11-01-branchpoint:1.78
	gdb-csl-arm-20051020-branch:1.78.0.2
	gdb-csl-arm-20051020-branchpoint:1.78
	msnyder-tracepoint-checkpoint-branch:1.77.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.77
	gdb-csl-arm-20050325-2005-q1b:1.76
	gdb-csl-arm-20050325-2005-q1a:1.76
	csl-arm-20050325-branch:1.76.0.2
	csl-arm-20050325-branchpoint:1.76
	gdb-post-i18n-errorwarning-20050211:1.71
	gdb-pre-i18n-errorwarning-20050211:1.70
	gdb_6_3-20041109-release:1.64
	gdb_6_3-branch:1.64.0.2
	gdb_6_3-20041019-branchpoint:1.64
	drow_intercu-merge-20040921:1.64
	drow_intercu-merge-20040915:1.64
	jimb-gdb_6_2-e500-branch:1.61.0.6
	jimb-gdb_6_2-e500-branchpoint:1.61
	gdb_6_2-20040730-release:1.61
	gdb_6_2-branch:1.61.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.61
	gdb_6_1_1-20040616-release:1.57
	gdb_6_1-2004-04-05-release:1.57
	drow_intercu-merge-20040402:1.57
	drow_intercu-merge-20040327:1.57
	ezannoni_pie-20040323-branch:1.57.0.6
	ezannoni_pie-20040323-branchpoint:1.57
	cagney_tramp-20040321-mergepoint:1.57
	cagney_tramp-20040309-branch:1.57.0.4
	cagney_tramp-20040309-branchpoint:1.57
	gdb_6_1-branch:1.57.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.57
	drow_intercu-20040221-branch:1.56.0.6
	drow_intercu-20040221-branchpoint:1.56
	cagney_bfdfile-20040213-branch:1.56.0.4
	cagney_bfdfile-20040213-branchpoint:1.56
	drow-cplus-merge-20040208:1.56
	carlton_dictionary-20040126-merge:1.56
	cagney_bigcore-20040122-branch:1.56.0.2
	cagney_bigcore-20040122-branchpoint:1.56
	drow-cplus-merge-20040113:1.56
	drow-cplus-merge-20031224:1.55
	drow-cplus-merge-20031220:1.55
	carlton_dictionary-20031215-merge:1.54
	drow-cplus-merge-20031214:1.54
	carlton-dictionary-20031111-merge:1.54
	gdb_6_0-2003-10-04-release:1.51
	kettenis_sparc-20030918-branch:1.53.0.4
	kettenis_sparc-20030918-branchpoint:1.53
	carlton_dictionary-20030917-merge:1.53
	ezannoni_pie-20030916-branchpoint:1.53
	ezannoni_pie-20030916-branch:1.53.0.2
	cagney_x86i386-20030821-branch:1.51.0.6
	cagney_x86i386-20030821-branchpoint:1.51
	carlton_dictionary-20030805-merge:1.51
	carlton_dictionary-20030627-merge:1.51
	gdb_6_0-branch:1.51.0.4
	gdb_6_0-2003-06-23-branchpoint:1.51
	jimb-ppc64-linux-20030613-branch:1.51.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.51
	cagney_convert-20030606-branch:1.50.0.10
	cagney_convert-20030606-branchpoint:1.50
	cagney_writestrings-20030508-branch:1.50.0.8
	cagney_writestrings-20030508-branchpoint:1.50
	jimb-ppc64-linux-20030528-branch:1.50.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.50
	carlton_dictionary-20030523-merge:1.50
	cagney_fileio-20030521-branch:1.50.0.4
	cagney_fileio-20030521-branchpoint:1.50
	kettenis_i386newframe-20030517-mergepoint:1.50
	jimb-ppc64-linux-20030509-branch:1.50.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.50
	kettenis_i386newframe-20030504-mergepoint:1.49
	carlton_dictionary-20030430-merge:1.49
	kettenis_i386newframe-20030419-branch:1.49.0.16
	kettenis_i386newframe-20030419-branchpoint:1.49
	carlton_dictionary-20030416-merge:1.49
	cagney_frameaddr-20030409-mergepoint:1.49
	kettenis_i386newframe-20030406-branch:1.49.0.14
	kettenis_i386newframe-20030406-branchpoint:1.49
	cagney_frameaddr-20030403-branchpoint:1.49
	cagney_frameaddr-20030403-branch:1.49.0.12
	cagney_framebase-20030330-mergepoint:1.49
	cagney_framebase-20030326-branch:1.49.0.10
	cagney_framebase-20030326-branchpoint:1.49
	cagney_lazyid-20030317-branch:1.49.0.8
	cagney_lazyid-20030317-branchpoint:1.49
	kettenis-i386newframe-20030316-mergepoint:1.49
	offbyone-20030313-branch:1.49.0.6
	offbyone-20030313-branchpoint:1.49
	kettenis-i386newframe-20030308-branch:1.49.0.4
	kettenis-i386newframe-20030308-branchpoint:1.49
	carlton_dictionary-20030305-merge:1.49
	cagney_offbyone-20030303-branch:1.49.0.2
	cagney_offbyone-20030303-branchpoint:1.49
	carlton_dictionary-20030207-merge:1.46
	interps-20030203-mergepoint:1.46
	interps-20030202-branch:1.46.0.4
	interps-20030202-branchpoint:1.46
	cagney-unwind-20030108-branch:1.46.0.2
	cagney-unwind-20030108-branchpoint:1.46
	carlton_dictionary-20021223-merge:1.45
	gdb_5_3-2002-12-12-release:1.40
	carlton_dictionary-20021115-merge:1.42
	kseitz_interps-20021105-merge:1.42
	kseitz_interps-20021103-merge:1.42
	drow-cplus-merge-20021020:1.42
	drow-cplus-merge-20021025:1.42
	carlton_dictionary-20021025-merge:1.42
	carlton_dictionary-20021011-merge:1.42
	drow-cplus-branch:1.42.0.2
	drow-cplus-branchpoint:1.42
	kseitz_interps-20020930-merge:1.41
	carlton_dictionary-20020927-merge:1.41
	carlton_dictionary-branch:1.41.0.2
	carlton_dictionary-20020920-branchpoint:1.41
	gdb_5_3-branch:1.40.0.6
	gdb_5_3-2002-09-04-branchpoint:1.40
	kseitz_interps-20020829-merge:1.40
	cagney_sysregs-20020825-branch:1.40.0.4
	cagney_sysregs-20020825-branchpoint:1.40
	readline_4_3-import-branch:1.40.0.2
	readline_4_3-import-branchpoint:1.40
	gdb_5_2_1-2002-07-23-release:1.33
	kseitz_interps-20020528-branch:1.39.0.4
	kseitz_interps-20020528-branchpoint:1.39
	cagney_regbuf-20020515-branch:1.39.0.2
	cagney_regbuf-20020515-branchpoint:1.39
	jimb-macro-020506-branch:1.38.0.2
	jimb-macro-020506-branchpoint:1.38
	gdb_5_2-2002-04-29-release:1.33
	gdb_5_2-branch:1.33.0.2
	gdb_5_2-2002-03-03-branchpoint:1.33
	gdb_5_1_1-2002-01-24-release:1.23.4.1
	gdb_5_1_0_1-2002-01-03-release:1.23.4.1
	cygnus_cvs_20020108_pre:1.29
	gdb_5_1_0_1-2002-01-03-branchpoint:1.23.4.1
	gdb_5_1_0_1-2002-01-03-branch:1.23.4.1.0.4
	gdb_5_1-2001-11-21-release:1.23.4.1
	gdb_s390-2001-09-26-branch:1.23.4.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.23.4.1
	gdb_5_1-2001-07-29-branch:1.23.0.4
	gdb_5_1-2001-07-29-branchpoint:1.23
	dberlin-typesystem-branch:1.23.0.2
	dberlin-typesystem-branchpoint:1.23
	gdb-post-ptid_t-2001-05-03:1.20
	gdb-pre-ptid_t-2001-05-03:1.20
	insight-precleanup-2001-01-01:1.15
	gdb-post-protoization-2000-07-29:1.8
	gdb-pre-protoization-2000-07-29:1.7
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb-post-params-removal-2000-06-04:1.7
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.6
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.1.1.11
	gdb_4_18_2-2000-05-18-release:1.1.1.11
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.11
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.11
	gdb_5_0-2000-04-10-branch:1.1.1.11.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.11
	repo-unification-2000-02-06:1.1.1.11
	insight-2000-02-04:1.1.1.11
	gdb-2000-02-04:1.1.1.11
	gdb-2000-02-02:1.1.1.11
	gdb-2000-02-01:1.1.1.11
	gdb-2000-01-31:1.1.1.11
	gdb-2000-01-26:1.1.1.11
	gdb-2000-01-24:1.1.1.11
	gdb-2000-01-17:1.1.1.11
	gdb-2000-01-10:1.1.1.11
	gdb-2000-01-05:1.1.1.11
	gdb-1999-12-21:1.1.1.11
	gdb-1999-12-13:1.1.1.11
	gdb-1999-12-07:1.1.1.10
	gdb-1999-12-06:1.1.1.10
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.9
	gdb-1999-11-01:1.1.1.9
	gdb-1999-10-25:1.1.1.8
	gdb-1999-10-18:1.1.1.8
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.8
	gdb-1999-09-28:1.1.1.8
	gdb-1999-09-21:1.1.1.7
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.4
	gdb-1999-06-28:1.1.1.4
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.4
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.324
date	2013.09.17.18.26.39;	author palves;	state Exp;
branches;
next	1.323;

1.323
date	2013.08.09.15.35.03;	author palves;	state Exp;
branches;
next	1.322;

1.322
date	2013.07.31.00.44.42;	author qiyao;	state Exp;
branches;
next	1.321;

1.321
date	2013.07.25.14.34.51;	author tromey;	state Exp;
branches;
next	1.320;

1.320
date	2013.07.01.11.19.27;	author palves;	state Exp;
branches;
next	1.319;

1.319
date	2013.06.28.14.23.11;	author tromey;	state Exp;
branches;
next	1.318;

1.318
date	2013.06.26.15.17.59;	author ddk;	state Exp;
branches;
next	1.317;

1.317
date	2013.06.26.15.14.38;	author ddk;	state Exp;
branches;
next	1.316;

1.316
date	2013.06.26.08.17.26;	author qiyao;	state Exp;
branches;
next	1.315;

1.315
date	2013.06.26.08.01.55;	author qiyao;	state Exp;
branches;
next	1.314;

1.314
date	2013.06.26.05.35.45;	author qiyao;	state Exp;
branches;
next	1.313;

1.313
date	2013.06.26.05.28.01;	author qiyao;	state Exp;
branches;
next	1.312;

1.312
date	2013.06.26.05.25.28;	author qiyao;	state Exp;
branches;
next	1.311;

1.311
date	2013.06.07.00.19.35;	author qiyao;	state Exp;
branches;
next	1.310;

1.310
date	2013.05.31.10.06.02;	author qiyao;	state Exp;
branches;
next	1.309;

1.309
date	2013.05.30.17.10.41;	author tromey;	state Exp;
branches;
next	1.308;

1.308
date	2013.05.30.09.29.18;	author qiyao;	state Exp;
branches;
next	1.307;

1.307
date	2013.05.28.02.55.04;	author qiyao;	state Exp;
branches;
next	1.306;

1.306
date	2013.05.24.12.27.38;	author qiyao;	state Exp;
branches;
next	1.305;

1.305
date	2013.04.24.18.22.31;	author kseitz;	state Exp;
branches;
next	1.304;

1.304
date	2013.04.22.16.46.15;	author tromey;	state Exp;
branches;
next	1.303;

1.303
date	2013.04.19.15.27.06;	author palves;	state Exp;
branches;
next	1.302;

1.302
date	2013.04.19.15.09.46;	author palves;	state Exp;
branches;
next	1.301;

1.301
date	2013.04.11.05.05.49;	author qiyao;	state Exp;
branches;
next	1.300;

1.300
date	2013.04.10.15.11.11;	author palves;	state Exp;
branches;
next	1.299;

1.299
date	2013.04.10.14.10.35;	author palves;	state Exp;
branches;
next	1.298;

1.298
date	2013.04.10.09.42.56;	author qiyao;	state Exp;
branches;
next	1.297;

1.297
date	2013.04.07.10.23.34;	author qiyao;	state Exp;
branches;
next	1.296;

1.296
date	2013.03.29.15.21.23;	author qiyao;	state Exp;
branches;
next	1.295;

1.295
date	2013.03.21.16.09.27;	author tromey;	state Exp;
branches;
next	1.294;

1.294
date	2013.03.20.18.35.22;	author tromey;	state Exp;
branches;
next	1.293;

1.293
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.292;

1.292
date	2013.03.14.09.08.56;	author qiyao;	state Exp;
branches;
next	1.291;

1.291
date	2013.03.14.09.06.40;	author qiyao;	state Exp;
branches;
next	1.290;

1.290
date	2013.03.14.09.02.27;	author qiyao;	state Exp;
branches;
next	1.289;

1.289
date	2013.03.14.08.50.54;	author qiyao;	state Exp;
branches;
next	1.288;

1.288
date	2013.03.13.18.34.54;	author palves;	state Exp;
branches;
next	1.287;

1.287
date	2013.03.13.03.40.26;	author qiyao;	state Exp;
branches;
next	1.286;

1.286
date	2013.03.12.17.39.44;	author kseitz;	state Exp;
branches;
next	1.285;

1.285
date	2013.03.08.15.35.06;	author qiyao;	state Exp;
branches;
next	1.284;

1.284
date	2013.03.08.15.06.35;	author abidh;	state Exp;
branches;
next	1.283;

1.283
date	2013.03.07.21.57.30;	author kseitz;	state Exp;
branches;
next	1.282;

1.282
date	2013.03.07.17.29.32;	author palves;	state Exp;
branches;
next	1.281;

1.281
date	2013.03.04.13.52.46;	author teawater;	state Exp;
branches;
next	1.280;

1.280
date	2013.02.27.01.39.26;	author qiyao;	state Exp;
branches;
next	1.279;

1.279
date	2013.02.15.09.47.46;	author abidh;	state Exp;
branches;
next	1.278;

1.278
date	2013.02.14.10.19.39;	author abidh;	state Exp;
branches;
next	1.277;

1.277
date	2013.02.14.03.57.13;	author qiyao;	state Exp;
branches;
next	1.276;

1.276
date	2013.02.06.14.45.13;	author qiyao;	state Exp;
branches;
next	1.275;

1.275
date	2013.02.03.16.13.29;	author jkratoch;	state Exp;
branches;
next	1.274;

1.274
date	2013.01.08.02.00.34;	author teawater;	state Exp;
branches;
next	1.273;

1.273
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.272;

1.272
date	2012.12.25.08.03.31;	author jkratoch;	state Exp;
branches;
next	1.271;

1.271
date	2012.12.24.19.42.15;	author jkratoch;	state Exp;
branches;
next	1.270;

1.270
date	2012.12.15.02.19.19;	author qiyao;	state Exp;
branches;
next	1.269;

1.269
date	2012.11.09.19.58.02;	author tromey;	state Exp;
branches;
next	1.268;

1.268
date	2012.10.18.20.14.44;	author tromey;	state Exp;
branches;
next	1.267;

1.267
date	2012.09.25.12.48.53;	author siddhesh;	state Exp;
branches;
next	1.266;

1.266
date	2012.09.18.12.09.26;	author qiyao;	state Exp;
branches;
next	1.265;

1.265
date	2012.09.18.11.33.41;	author qiyao;	state Exp;
branches;
next	1.264;

1.264
date	2012.08.23.16.11.08;	author qiyao;	state Exp;
branches;
next	1.263;

1.263
date	2012.08.16.07.26.16;	author qiyao;	state Exp;
branches;
next	1.262;

1.262
date	2012.07.31.07.12.28;	author qiyao;	state Exp;
branches;
next	1.261;

1.261
date	2012.07.27.16.21.44;	author qiyao;	state Exp;
branches;
next	1.260;

1.260
date	2012.06.29.22.46.46;	author devans;	state Exp;
branches;
next	1.259;

1.259
date	2012.06.27.18.08.40;	author tromey;	state Exp;
branches;
next	1.258;

1.258
date	2012.06.16.15.07.35;	author teawater;	state Exp;
branches;
next	1.257;

1.257
date	2012.05.22.08.45.56;	author muller;	state Exp;
branches;
next	1.256;

1.256
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.255;

1.255
date	2012.05.10.19.50.09;	author tromey;	state Exp;
branches;
next	1.254;

1.254
date	2012.04.29.15.14.31;	author sergiodj;	state Exp;
branches;
next	1.253;

1.253
date	2012.04.27.20.47.56;	author sergiodj;	state Exp;
branches;
next	1.252;

1.252
date	2012.04.27.20.38.39;	author sergiodj;	state Exp;
branches;
next	1.251;

1.251
date	2012.04.18.06.52.33;	author jkratoch;	state Exp;
branches;
next	1.250;

1.250
date	2012.03.27.19.08.36;	author palves;	state Exp;
branches;
next	1.249;

1.249
date	2012.03.03.09.51.28;	author qiyao;	state Exp;
branches;
next	1.248;

1.248
date	2012.03.03.03.32.44;	author qiyao;	state Exp;
branches;
next	1.247;

1.247
date	2012.03.01.21.14.00;	author palves;	state Exp;
branches;
next	1.246;

1.246
date	2012.03.01.21.07.31;	author palves;	state Exp;
branches;
next	1.245;

1.245
date	2012.02.07.04.48.22;	author devans;	state Exp;
branches;
next	1.244;

1.244
date	2012.01.04.08.27.57;	author brobecke;	state Exp;
branches;
next	1.243;

1.243
date	2011.12.10.15.16.35;	author qiyao;	state Exp;
branches
	1.243.2.1;
next	1.242;

1.242
date	2011.12.10.09.41.19;	author teawater;	state Exp;
branches;
next	1.241;

1.241
date	2011.12.06.18.54.39;	author tromey;	state Exp;
branches;
next	1.240;

1.240
date	2011.11.21.00.43.48;	author shebs;	state Exp;
branches;
next	1.239;

1.239
date	2011.11.20.23.59.47;	author shebs;	state Exp;
branches;
next	1.238;

1.238
date	2011.11.18.01.21.34;	author qiyao;	state Exp;
branches;
next	1.237;

1.237
date	2011.11.14.16.10.18;	author tromey;	state Exp;
branches;
next	1.236;

1.236
date	2011.11.14.15.18.54;	author qiyao;	state Exp;
branches;
next	1.235;

1.235
date	2011.11.14.14.11.36;	author qiyao;	state Exp;
branches;
next	1.234;

1.234
date	2011.11.02.23.44.19;	author shebs;	state Exp;
branches;
next	1.233;

1.233
date	2011.10.13.13.06.18;	author luisgpm;	state Exp;
branches;
next	1.232;

1.232
date	2011.09.27.13.09.36;	author shebs;	state Exp;
branches;
next	1.231;

1.231
date	2011.08.24.09.24.10;	author teawater;	state Exp;
branches;
next	1.230;

1.230
date	2011.08.04.19.10.13;	author palves;	state Exp;
branches;
next	1.229;

1.229
date	2011.07.25.11.24.44;	author palves;	state Exp;
branches;
next	1.228;

1.228
date	2011.07.07.13.32.55;	author teawater;	state Exp;
branches;
next	1.227;

1.227
date	2011.07.06.02.43.12;	author teawater;	state Exp;
branches;
next	1.226;

1.226
date	2011.05.20.14.41.12;	author palves;	state Exp;
branches;
next	1.225;

1.225
date	2011.05.20.14.40.23;	author palves;	state Exp;
branches;
next	1.224;

1.224
date	2011.05.19.14.06.44;	author teawater;	state Exp;
branches;
next	1.223;

1.223
date	2011.05.12.12.09.16;	author kcy;	state Exp;
branches;
next	1.222;

1.222
date	2011.04.19.18.04.07;	author tromey;	state Exp;
branches;
next	1.221;

1.221
date	2011.04.04.17.41.07;	author tromey;	state Exp;
branches;
next	1.220;

1.220
date	2011.03.18.18.47.56;	author palves;	state Exp;
branches
	1.220.2.1;
next	1.219;

1.219
date	2011.03.16.17.59.03;	author muller;	state Exp;
branches;
next	1.218;

1.218
date	2011.03.16.15.18.58;	author tromey;	state Exp;
branches;
next	1.217;

1.217
date	2011.03.14.15.43.50;	author muller;	state Exp;
branches;
next	1.216;

1.216
date	2011.03.10.18.33.59;	author tromey;	state Exp;
branches;
next	1.215;

1.215
date	2011.03.01.22.24.30;	author msnyder;	state Exp;
branches;
next	1.214;

1.214
date	2011.03.01.22.13.48;	author msnyder;	state Exp;
branches;
next	1.213;

1.213
date	2011.02.24.07.39.48;	author brobecke;	state Exp;
branches;
next	1.212;

1.212
date	2011.02.21.08.38.10;	author teawater;	state Exp;
branches;
next	1.211;

1.211
date	2011.02.16.12.59.04;	author palves;	state Exp;
branches;
next	1.210;

1.210
date	2011.02.14.19.19.18;	author palves;	state Exp;
branches;
next	1.209;

1.209
date	2011.02.14.11.34.31;	author palves;	state Exp;
branches;
next	1.208;

1.208
date	2011.02.14.11.22.29;	author palves;	state Exp;
branches;
next	1.207;

1.207
date	2011.02.14.11.20.27;	author palves;	state Exp;
branches;
next	1.206;

1.206
date	2011.02.14.11.13.11;	author palves;	state Exp;
branches;
next	1.205;

1.205
date	2011.01.31.03.12.06;	author brobecke;	state Exp;
branches;
next	1.204;

1.204
date	2011.01.28.16.18.54;	author palves;	state Exp;
branches;
next	1.203;

1.203
date	2011.01.27.21.39.24;	author palves;	state Exp;
branches;
next	1.202;

1.202
date	2011.01.25.12.47.24;	author palves;	state Exp;
branches;
next	1.201;

1.201
date	2011.01.11.21.53.25;	author msnyder;	state Exp;
branches;
next	1.200;

1.200
date	2011.01.10.17.14.13;	author msnyder;	state Exp;
branches;
next	1.199;

1.199
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.198;

1.198
date	2011.01.01.15.33.18;	author brobecke;	state Exp;
branches;
next	1.197;

1.197
date	2010.11.01.07.00.13;	author teawater;	state Exp;
branches;
next	1.196;

1.196
date	2010.10.28.03.38.36;	author teawater;	state Exp;
branches;
next	1.195;

1.195
date	2010.10.20.14.03.17;	author teawater;	state Exp;
branches;
next	1.194;

1.194
date	2010.10.08.20.45.21;	author drow;	state Exp;
branches;
next	1.193;

1.193
date	2010.07.28.18.04.19;	author brobecke;	state Exp;
branches;
next	1.192;

1.192
date	2010.07.19.17.51.23;	author jkratoch;	state Exp;
branches;
next	1.191;

1.191
date	2010.07.01.15.36.17;	author palves;	state Exp;
branches
	1.191.2.1;
next	1.190;

1.190
date	2010.07.01.10.36.09;	author palves;	state Exp;
branches;
next	1.189;

1.189
date	2010.06.12.00.05.21;	author shebs;	state Exp;
branches;
next	1.188;

1.188
date	2010.05.27.22.06.00;	author palves;	state Exp;
branches;
next	1.187;

1.187
date	2010.05.17.01.15.20;	author msnyder;	state Exp;
branches;
next	1.186;

1.186
date	2010.05.06.00.31.46;	author msnyder;	state Exp;
branches;
next	1.185;

1.185
date	2010.05.04.21.09.24;	author kettenis;	state Exp;
branches;
next	1.184;

1.184
date	2010.04.23.23.51.05;	author shebs;	state Exp;
branches;
next	1.183;

1.183
date	2010.04.22.04.14.15;	author shebs;	state Exp;
branches;
next	1.182;

1.182
date	2010.04.20.18.52.59;	author shebs;	state Exp;
branches;
next	1.181;

1.181
date	2010.04.19.22.06.17;	author shebs;	state Exp;
branches;
next	1.180;

1.180
date	2010.04.16.18.22.01;	author shebs;	state Exp;
branches;
next	1.179;

1.179
date	2010.04.16.01.12.07;	author shebs;	state Exp;
branches;
next	1.178;

1.178
date	2010.04.13.03.53.50;	author shebs;	state Exp;
branches;
next	1.177;

1.177
date	2010.04.09.20.46.40;	author shebs;	state Exp;
branches;
next	1.176;

1.176
date	2010.04.09.19.34.57;	author shebs;	state Exp;
branches;
next	1.175;

1.175
date	2010.04.09.15.22.09;	author palves;	state Exp;
branches;
next	1.174;

1.174
date	2010.04.09.03.00.58;	author shebs;	state Exp;
branches;
next	1.173;

1.173
date	2010.04.06.17.47.40;	author shebs;	state Exp;
branches;
next	1.172;

1.172
date	2010.04.05.21.57.17;	author shebs;	state Exp;
branches;
next	1.171;

1.171
date	2010.04.04.23.31.28;	author shebs;	state Exp;
branches;
next	1.170;

1.170
date	2010.04.02.01.39.53;	author palves;	state Exp;
branches;
next	1.169;

1.169
date	2010.04.02.01.18.34;	author palves;	state Exp;
branches;
next	1.168;

1.168
date	2010.04.01.22.57.24;	author shebs;	state Exp;
branches;
next	1.167;

1.167
date	2010.04.01.20.30.56;	author shebs;	state Exp;
branches;
next	1.166;

1.166
date	2010.04.01.11.24.00;	author palves;	state Exp;
branches;
next	1.165;

1.165
date	2010.03.31.17.59.48;	author shebs;	state Exp;
branches;
next	1.164;

1.164
date	2010.03.30.00.19.43;	author shebs;	state Exp;
branches;
next	1.163;

1.163
date	2010.03.29.23.45.06;	author shebs;	state Exp;
branches;
next	1.162;

1.162
date	2010.03.29.17.58.17;	author shebs;	state Exp;
branches;
next	1.161;

1.161
date	2010.03.29.17.41.38;	author shebs;	state Exp;
branches;
next	1.160;

1.160
date	2010.03.27.00.12.34;	author shebs;	state Exp;
branches;
next	1.159;

1.159
date	2010.03.26.15.26.29;	author palves;	state Exp;
branches;
next	1.158;

1.158
date	2010.03.26.14.31.47;	author palves;	state Exp;
branches;
next	1.157;

1.157
date	2010.03.26.13.35.06;	author palves;	state Exp;
branches;
next	1.156;

1.156
date	2010.03.26.01.46.28;	author shebs;	state Exp;
branches;
next	1.155;

1.155
date	2010.03.24.21.12.18;	author tromey;	state Exp;
branches;
next	1.154;

1.154
date	2010.03.24.19.37.06;	author vprus;	state Exp;
branches;
next	1.153;

1.153
date	2010.03.23.22.05.45;	author vprus;	state Exp;
branches;
next	1.152;

1.152
date	2010.03.23.22.01.47;	author vprus;	state Exp;
branches;
next	1.151;

1.151
date	2010.03.23.21.50.10;	author vprus;	state Exp;
branches;
next	1.150;

1.150
date	2010.03.23.21.46.33;	author vprus;	state Exp;
branches;
next	1.149;

1.149
date	2010.03.23.21.32.27;	author vprus;	state Exp;
branches;
next	1.148;

1.148
date	2010.03.18.21.23.33;	author shebs;	state Exp;
branches;
next	1.147;

1.147
date	2010.03.17.22.04.43;	author shebs;	state Exp;
branches;
next	1.146;

1.146
date	2010.03.12.03.54.45;	author palves;	state Exp;
branches;
next	1.145;

1.145
date	2010.03.04.00.32.50;	author shebs;	state Exp;
branches;
next	1.144;

1.144
date	2010.02.24.01.06.27;	author palves;	state Exp;
branches;
next	1.143;

1.143
date	2010.02.12.16.15.24;	author palves;	state Exp;
branches
	1.143.2.1;
next	1.142;

1.142
date	2010.02.11.21.00.12;	author palves;	state Exp;
branches;
next	1.141;

1.141
date	2010.01.19.09.39.11;	author brobecke;	state Exp;
branches;
next	1.140;

1.140
date	2010.01.16.23.15.11;	author shebs;	state Exp;
branches;
next	1.139;

1.139
date	2010.01.15.22.37.17;	author shebs;	state Exp;
branches;
next	1.138;

1.138
date	2010.01.07.19.17.46;	author shebs;	state Exp;
branches;
next	1.137;

1.137
date	2010.01.07.19.09.09;	author shebs;	state Exp;
branches;
next	1.136;

1.136
date	2010.01.06.20.31.28;	author shebs;	state Exp;
branches;
next	1.135;

1.135
date	2010.01.06.04.20.26;	author shebs;	state Exp;
branches;
next	1.134;

1.134
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.133;

1.133
date	2009.12.31.17.47.42;	author shebs;	state Exp;
branches;
next	1.132;

1.132
date	2009.12.31.17.39.53;	author shebs;	state Exp;
branches;
next	1.131;

1.131
date	2009.12.30.22.32.03;	author shebs;	state Exp;
branches;
next	1.130;

1.130
date	2009.12.30.16.11.06;	author shebs;	state Exp;
branches;
next	1.129;

1.129
date	2009.12.28.23.39.08;	author shebs;	state Exp;
branches;
next	1.128;

1.128
date	2009.12.24.00.40.49;	author shebs;	state Exp;
branches;
next	1.127;

1.127
date	2009.12.23.23.21.29;	author tromey;	state Exp;
branches;
next	1.126;

1.126
date	2009.07.14.21.40.30;	author shebs;	state Exp;
branches;
next	1.125;

1.125
date	2009.07.02.17.21.07;	author uweigand;	state Exp;
branches;
next	1.124;

1.124
date	2009.07.02.17.12.27;	author uweigand;	state Exp;
branches;
next	1.123;

1.123
date	2009.07.02.12.11.19;	author uweigand;	state Exp;
branches;
next	1.122;

1.122
date	2009.06.04.12.28.39;	author uweigand;	state Exp;
branches;
next	1.121;

1.121
date	2009.06.03.18.16.44;	author uweigand;	state Exp;
branches;
next	1.120;

1.120
date	2009.05.28.00.53.52;	author tromey;	state Exp;
branches;
next	1.119;

1.119
date	2009.05.23.16.17.18;	author jkratoch;	state Exp;
branches;
next	1.118;

1.118
date	2009.05.22.00.52.05;	author palves;	state Exp;
branches;
next	1.117;

1.117
date	2009.05.05.13.24.49;	author uweigand;	state Exp;
branches;
next	1.116;

1.116
date	2009.03.31.05.08.32;	author shebs;	state Exp;
branches;
next	1.115;

1.115
date	2009.02.25.02.14.23;	author teawater;	state Exp;
branches;
next	1.114;

1.114
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.113;

1.113
date	2008.10.28.17.19.57;	author tromey;	state Exp;
branches;
next	1.112;

1.112
date	2008.10.28.15.22.12;	author tromey;	state Exp;
branches;
next	1.111;

1.111
date	2008.09.13.23.37.05;	author tromey;	state Exp;
branches;
next	1.110;

1.110
date	2008.09.11.14.21.49;	author uweigand;	state Exp;
branches;
next	1.109;

1.109
date	2008.08.21.20.13.08;	author uweigand;	state Exp;
branches;
next	1.108;

1.108
date	2008.08.21.18.14.39;	author drow;	state Exp;
branches;
next	1.107;

1.107
date	2008.07.25.16.12.03;	author tromey;	state Exp;
branches;
next	1.106;

1.106
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.105;

1.105
date	2008.05.22.17.00.07;	author uweigand;	state Exp;
branches;
next	1.104;

1.104
date	2008.05.22.16.59.01;	author uweigand;	state Exp;
branches;
next	1.103;

1.103
date	2008.05.22.16.58.02;	author uweigand;	state Exp;
branches;
next	1.102;

1.102
date	2008.05.04.14.12.34;	author uweigand;	state Exp;
branches;
next	1.101;

1.101
date	2008.02.05.16.05.56;	author jimb;	state Exp;
branches;
next	1.100;

1.100
date	2008.01.11.13.34.15;	author deuling;	state Exp;
branches;
next	1.99;

1.99
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.98;

1.98
date	2007.10.27.00.34.48;	author jimb;	state Exp;
branches;
next	1.97;

1.97
date	2007.08.23.18.08.46;	author brobecke;	state Exp;
branches;
next	1.96;

1.96
date	2007.08.05.00.36.53;	author msnyder;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.13.17.59.50;	author uweigand;	state Exp;
branches;
next	1.94;

1.94
date	2007.06.13.17.11.09;	author drow;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.12.16.43.39;	author uweigand;	state Exp;
branches;
next	1.92;

1.92
date	2007.06.09.13.55.51;	author uweigand;	state Exp;
branches;
next	1.91;

1.91
date	2007.06.09.13.42.16;	author uweigand;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.89;

1.89
date	2007.02.28.17.35.01;	author drow;	state Exp;
branches;
next	1.88;

1.88
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.87;

1.87
date	2006.07.17.22.15.55;	author kettenis;	state Exp;
branches;
next	1.86;

1.86
date	2006.03.30.16.25.06;	author drow;	state Exp;
branches
	1.86.6.1;
next	1.85;

1.85
date	2006.03.17.00.38.19;	author msnyder;	state Exp;
branches;
next	1.84;

1.84
date	2006.02.01.23.14.10;	author drow;	state Exp;
branches
	1.84.2.1
	1.84.6.1;
next	1.83;

1.83
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.82;

1.82
date	2005.11.21.00.30.22;	author jimb;	state Exp;
branches;
next	1.81;

1.81
date	2005.11.19.18.57.28;	author jimb;	state Exp;
branches;
next	1.80;

1.80
date	2005.11.19.04.44.43;	author jimb;	state Exp;
branches;
next	1.79;

1.79
date	2005.11.19.01.23.26;	author jimb;	state Exp;
branches;
next	1.78;

1.78
date	2005.08.01.03.41.34;	author drow;	state Exp;
branches;
next	1.77;

1.77
date	2005.05.26.20.48.58;	author cagney;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2005.03.08.10.03.47;	author nathan;	state Exp;
branches;
next	1.75;

1.75
date	2005.02.15.15.49.23;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.14.18.10.10;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.14.14.37.38;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2005.02.11.18.13.54;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.11.04.06.07;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2005.02.08.00.25.31;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2005.02.07.23.51.03;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2005.02.02.00.20.05;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2005.01.14.03.59.19;	author msnyder;	state Exp;
branches;
next	1.66;

1.66
date	2004.11.12.21.45.07;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2004.10.29.20.23.13;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2004.09.13.18.26.30;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2004.09.11.10.24.51;	author hilfingr;	state Exp;
branches;
next	1.62;

1.62
date	2004.08.03.00.57.27;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2004.06.15.01.04.20;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.13.19.09.30;	author msnyder;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.28.16.36.25;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.28.18.04.37;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.07.19.14.45;	author msnyder;	state Exp;
branches
	1.56.6.1;
next	1.55;

1.55
date	2003.12.17.21.47.47;	author jjohnstn;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2003.08.21.18.09.54;	author msnyder;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.11.23.29.48;	author carlton;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.08.18.46.48;	author cagney;	state Exp;
branches
	1.50.8.1;
next	1.49;

1.49
date	2003.02.25.21.36.20;	author carlton;	state Exp;
branches
	1.49.16.1;
next	1.48;

1.48
date	2003.02.20.17.17.25;	author carlton;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.20.00.01.06;	author carlton;	state Exp;
branches;
next	1.46;

1.46
date	2002.12.28.23.22.21;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2002.12.09.03.30.44;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2002.11.29.19.15.15;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2002.11.24.19.48.13;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.02.21.33.58;	author ezannoni;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2002.09.12.19.49.56;	author brobecke;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2002.07.24.17.58.46;	author tromey;	state Exp;
branches;
next	1.39;

1.39
date	2002.05.12.04.20.06;	author cagney;	state Exp;
branches
	1.39.4.1;
next	1.38;

1.38
date	2002.05.05.01.15.13;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.04.21.20.23.33;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.27.21.35.35;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.23.17.38.13;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.06.06.28.34;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.23.20.12.13;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.05.04.37.22;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.02.00.56.34;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.08.01.52.12;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.25.22.24.38;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.06.23.38.15;	author fnf;	state Exp;
branches;
next	1.27;

1.27
date	2001.10.12.23.51.29;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.23.20.31.36;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.11.00.59.29;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.02.11.58.29;	author eliz;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.14.17.09.36;	author kseitz;	state Exp;
branches
	1.23.2.1
	1.23.4.1;
next	1.22;

1.22
date	2001.06.11.16.05.24;	author eliz;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.07.22.02.18;	author kseitz;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.17.20.16.30;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.27.20.36.24;	author jtc;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.19.11.47.16;	author eliz;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.15.01.01.50;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.01.00.41.27;	author fnasser;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.16.14.51.49;	author taylor;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.30.21.50.58;	author jtc;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.30.15.32.51;	author taylor;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.01.00.12.10;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.01.05.06.03;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.28.01.12.32;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.15.06.15.27;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.12.41.48;	author phdm;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.14.18.43.41;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.243.2.1
date	2012.01.06.04.54.31;	author brobecke;	state Exp;
branches;
next	;

1.220.2.1
date	2011.05.20.05.12.11;	author teawater;	state Exp;
branches;
next	1.220.2.2;

1.220.2.2
date	2011.05.20.14.31.24;	author palves;	state Exp;
branches;
next	1.220.2.3;

1.220.2.3
date	2011.05.20.14.37.42;	author palves;	state Exp;
branches;
next	1.220.2.4;

1.220.2.4
date	2011.07.02.19.33.10;	author jkratoch;	state Exp;
branches;
next	;

1.191.2.1
date	2010.11.02.05.34.25;	author teawater;	state Exp;
branches;
next	;

1.143.2.1
date	2010.02.24.21.43.03;	author palves;	state Exp;
branches;
next	1.143.2.2;

1.143.2.2
date	2010.03.12.03.56.31;	author palves;	state Exp;
branches;
next	;

1.86.6.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.84.2.1
date	2006.07.03.15.58.50;	author drow;	state Exp;
branches;
next	;

1.84.6.1
date	2006.04.12.14.48.21;	author drow;	state Exp;
branches;
next	;

1.77.2.1
date	2005.05.30.22.33.44;	author msnyder;	state Exp;
branches;
next	1.77.2.2;

1.77.2.2
date	2005.06.03.14.44.01;	author msnyder;	state Exp;
branches;
next	1.77.2.3;

1.77.2.3
date	2005.06.04.02.18.29;	author msnyder;	state Exp;
branches;
next	;

1.56.6.1
date	2004.03.27.17.37.54;	author drow;	state Exp;
branches;
next	1.56.6.2;

1.56.6.2
date	2004.09.16.17.01.24;	author drow;	state Exp;
branches;
next	;

1.50.8.1
date	2003.06.03.20.54.40;	author cagney;	state Exp;
branches;
next	;

1.49.16.1
date	2003.05.18.09.44.25;	author kettenis;	state Exp;
branches;
next	;

1.42.2.1
date	2003.12.14.20.27.33;	author drow;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2003.12.20.18.16.49;	author drow;	state Exp;
branches;
next	1.42.2.3;

1.42.2.3
date	2004.01.13.16.12.02;	author drow;	state Exp;
branches;
next	;

1.41.2.1
date	2002.09.24.00.04.52;	author carlton;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.10.11.22.22.56;	author carlton;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.10.18.23.42.58;	author carlton;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2002.12.21.00.17.44;	author carlton;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2002.12.23.19.38.47;	author carlton;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2003.02.07.19.17.53;	author carlton;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2003.03.06.00.56.33;	author carlton;	state Exp;
branches;
next	1.41.2.8;

1.41.2.8
date	2003.03.07.22.52.55;	author carlton;	state Exp;
branches;
next	1.41.2.9;

1.41.2.9
date	2003.05.23.18.40.46;	author carlton;	state Exp;
branches;
next	1.41.2.10;

1.41.2.10
date	2003.09.17.21.28.34;	author carlton;	state Exp;
branches;
next	1.41.2.11;

1.41.2.11
date	2003.11.11.23.50.58;	author carlton;	state Exp;
branches;
next	1.41.2.12;

1.41.2.12
date	2004.01.26.19.11.34;	author carlton;	state Exp;
branches;
next	;

1.39.4.1
date	2002.08.09.18.34.27;	author kseitz;	state Exp;
branches;
next	1.39.4.2;

1.39.4.2
date	2002.10.01.00.46.15;	author kseitz;	state Exp;
branches;
next	1.39.4.3;

1.39.4.3
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.23.2.1
date	2001.07.06.19.17.03;	author dberlin;	state Exp;
branches;
next	;

1.23.4.1
date	2001.08.02.12.05.57;	author eliz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.41;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.03.42;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.14.18.08.07;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.10.48;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.31.01.06.14;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.22.03.25.10;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.09.28.21.52.37;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.11.02.04.44.19;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.12.07.03.56.07;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.12.14.01.05.38;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.324
log
@PR gdb/15911: "info threads" changes the default source and line (for "break", "list")

"info threads" changes the default source for "break" and "list", to
whatever the location of the first/bottom thread in the thread list
is...

 (gdb) b start
 (gdb) c
 ...
 (gdb) list
 *lists "start"*
 (gdb) b 23
 Breakpoint 3 at 0x400614: file test.c, line 23.
 (gdb) info threads
   Id   Target Id         Frame
 * 2    Thread 0x7ffff7fcb700 (LWP 1760) "test" start (arg=0x0) at test.c:23
   1    Thread 0x7ffff7fcc740 (LWP 1748) "test" 0x000000323dc08e60 in pthread_join (threadid=140737353922304, thread_return=0x0) at pthread_join.c:93
 (gdb) b 23
 Breakpoint 4 at 0x323dc08d90: file pthread_join.c, line 23.
                                    ^^^^^^^^^^^^^^^
 (gdb) list
 93          lll_wait_tid (pd->tid);
 94
 95
 96        /* Restore cancellation mode.  */
 97        CANCEL_RESET (oldtype);
 98
 99        /* Remove the handler.  */
 100       pthread_cleanup_pop (0);
 101
 102

The issue is that print_stack_frame always sets the current sal to the
frame's sal.  print_frame_info (which print_stack_frame calls to do
most of the work) also sets the last displayed sal, but only if
print_what isn't LOCATION.  Now the call in question, from within
thread.c:print_thread_info, does pass in LOCATION as print_what, but
print_stack_frame doesn't have the same check print_frame_info has.
We could consider adding it, but setting these globals depending on
print_what isn't very clean, IMO.  What we have is two logically
distinct operations mixed in the same function(s):

  #1 - print frame, in the format specified by {print_what,
    print_level and print_args}.

  #2 - We're displaying a frame to the user, and I want the default
    sal to point here, because the program stopped here, or the user
    did some context-changing command (up, down, etc.).

So I added a new parameter to print_stack_frame & friends for point
#2, and went through all calls in the tree adjusting as necessary.

Tested on x86_64 Fedora 17.

gdb/
2013-09-17  Pedro Alves  <palves@@redhat.com>

	PR gdb/15911
	* ada-tasks.c (task_command_1): Adjust call to print_stack_frame.
	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd):
	* corelow.c (core_open):
	* frame.h (print_stack_frame, print_frame_info): New
	'set_current_sal' parameter.
	* infcmd.c (finish_command, kill_command): Adjust call to
	print_stack_frame.
	* inferior.c (inferior_command): Likewise.
	* infrun.c (normal_stop): Likewise.
	* linux-fork.c (linux_fork_context): Likewise.
	* record-full.c (record_full_goto_entry, record_full_restore):
	Likewise.
	* remote-mips.c (common_open): Likewise.
	* stack.c (print_stack_frame): New 'set_current_sal' parameter.
	Use it.
	(print_frame_info): New 'set_current_sal' parameter.  Set the last
	displayed sal depending on the new paremeter instead of looking at
	print_what.
	(backtrace_command_1, select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Adjust call to
	print_stack_frame.
	* thread.c (print_thread_info, restore_selected_frame)
	(do_captured_thread_select): Adjust call to print_stack_frame.
	* tracepoint.c (tfind_1): Likewise.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_frame): Likewise.
	* mi/mi-interp.c (mi_on_normal_stop): Likewise.
	* mi/mi-main.c (mi_cmd_exec_return, mi_cmd_trace_find): Likewise.

	gdb/testsuite/
	* gdb.threads/info-threads-cur-sal-2.c: New file.
	* gdb.threads/info-threads-cur-sal.c: New file.
	* gdb.threads/info-threads-cur-sal.exp: New file.
@
text
@/* Tracing functionality for remote targets in custom GDB protocol

   Copyright (C) 1997-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "symtab.h"
#include "frame.h"
#include "gdbtypes.h"
#include "expression.h"
#include "gdbcmd.h"
#include "value.h"
#include "target.h"
#include "language.h"
#include "gdb_string.h"
#include "inferior.h"
#include "breakpoint.h"
#include "tracepoint.h"
#include "linespec.h"
#include "regcache.h"
#include "completer.h"
#include "block.h"
#include "dictionary.h"
#include "observer.h"
#include "user-regs.h"
#include "valprint.h"
#include "gdbcore.h"
#include "objfiles.h"
#include "filenames.h"
#include "gdbthread.h"
#include "stack.h"
#include "gdbcore.h"
#include "remote.h"
#include "source.h"
#include "ax.h"
#include "ax-gdb.h"
#include "memrange.h"
#include "exceptions.h"
#include "cli/cli-utils.h"
#include "probe.h"
#include "ctf.h"
#include "completer.h"
#include "filestuff.h"

/* readline include files */
#include "readline/readline.h"
#include "readline/history.h"

/* readline defines this.  */
#undef savestring

#include <unistd.h>

#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

/* Maximum length of an agent aexpression.
   This accounts for the fact that packets are limited to 400 bytes
   (which includes everything -- including the checksum), and assumes
   the worst case of maximum length for each of the pieces of a
   continuation packet.

   NOTE: expressions get mem2hex'ed otherwise this would be twice as
   large.  (400 - 31)/2 == 184 */
#define MAX_AGENT_EXPR_LEN	184

/* A hook used to notify the UI of tracepoint operations.  */

void (*deprecated_trace_find_hook) (char *arg, int from_tty);
void (*deprecated_trace_start_stop_hook) (int start, int from_tty);

/* 
   Tracepoint.c:

   This module defines the following debugger commands:
   trace            : set a tracepoint on a function, line, or address.
   info trace       : list all debugger-defined tracepoints.
   delete trace     : delete one or more tracepoints.
   enable trace     : enable one or more tracepoints.
   disable trace    : disable one or more tracepoints.
   actions          : specify actions to be taken at a tracepoint.
   passcount        : specify a pass count for a tracepoint.
   tstart           : start a trace experiment.
   tstop            : stop a trace experiment.
   tstatus          : query the status of a trace experiment.
   tfind            : find a trace frame in the trace buffer.
   tdump            : print everything collected at the current tracepoint.
   save-tracepoints : write tracepoint setup into a file.

   This module defines the following user-visible debugger variables:
   $trace_frame : sequence number of trace frame currently being debugged.
   $trace_line  : source line of trace frame currently being debugged.
   $trace_file  : source file of trace frame currently being debugged.
   $tracepoint  : tracepoint number of trace frame currently being debugged.
 */


/* ======= Important global variables: ======= */

/* The list of all trace state variables.  We don't retain pointers to
   any of these for any reason - API is by name or number only - so it
   works to have a vector of objects.  */

typedef struct trace_state_variable tsv_s;
DEF_VEC_O(tsv_s);

static VEC(tsv_s) *tvariables;

/* The next integer to assign to a variable.  */

static int next_tsv_number = 1;

/* Number of last traceframe collected.  */
static int traceframe_number;

/* Tracepoint for last traceframe collected.  */
static int tracepoint_number;

/* Symbol for function for last traceframe collected.  */
static struct symbol *traceframe_fun;

/* Symtab and line for last traceframe collected.  */
static struct symtab_and_line traceframe_sal;

/* The traceframe info of the current traceframe.  NULL if we haven't
   yet attempted to fetch it, or if the target does not support
   fetching this object, or if we're not inspecting a traceframe
   presently.  */
static struct traceframe_info *traceframe_info;

/* Tracing command lists.  */
static struct cmd_list_element *tfindlist;

/* List of expressions to collect by default at each tracepoint hit.  */
char *default_collect = "";

static int disconnected_tracing;

/* This variable controls whether we ask the target for a linear or
   circular trace buffer.  */

static int circular_trace_buffer;

/* This variable is the requested trace buffer size, or -1 to indicate
   that we don't care and leave it up to the target to set a size.  */

static int trace_buffer_size = -1;

/* Textual notes applying to the current and/or future trace runs.  */

char *trace_user = NULL;

/* Textual notes applying to the current and/or future trace runs.  */

char *trace_notes = NULL;

/* Textual notes applying to the stopping of a trace.  */

char *trace_stop_notes = NULL;

/* ======= Important command functions: ======= */
static void trace_actions_command (char *, int);
static void trace_start_command (char *, int);
static void trace_stop_command (char *, int);
static void trace_status_command (char *, int);
static void trace_find_command (char *, int);
static void trace_find_pc_command (char *, int);
static void trace_find_tracepoint_command (char *, int);
static void trace_find_line_command (char *, int);
static void trace_find_range_command (char *, int);
static void trace_find_outside_command (char *, int);
static void trace_dump_command (char *, int);

/* support routines */

struct collection_list;
static void add_aexpr (struct collection_list *, struct agent_expr *);
static char *mem2hex (gdb_byte *, char *, int);
static void add_register (struct collection_list *collection,
			  unsigned int regno);

static void free_uploaded_tps (struct uploaded_tp **utpp);
static void free_uploaded_tsvs (struct uploaded_tsv **utsvp);

static struct command_line *
  all_tracepoint_actions_and_cleanup (struct breakpoint *t);

extern void _initialize_tracepoint (void);

static struct trace_status trace_status;

char *stop_reason_names[] = {
  "tunknown",
  "tnotrun",
  "tstop",
  "tfull",
  "tdisconnected",
  "tpasscount",
  "terror"
};

struct trace_status *
current_trace_status (void)
{
  return &trace_status;
}

/* Destroy INFO.  */

static void
free_traceframe_info (struct traceframe_info *info)
{
  if (info != NULL)
    {
      VEC_free (mem_range_s, info->memory);
      VEC_free (int, info->tvars);

      xfree (info);
    }
}

/* Free and clear the traceframe info cache of the current
   traceframe.  */

static void
clear_traceframe_info (void)
{
  free_traceframe_info (traceframe_info);
  traceframe_info = NULL;
}

/* Set traceframe number to NUM.  */
static void
set_traceframe_num (int num)
{
  traceframe_number = num;
  set_internalvar_integer (lookup_internalvar ("trace_frame"), num);
}

/* Set tracepoint number to NUM.  */
static void
set_tracepoint_num (int num)
{
  tracepoint_number = num;
  set_internalvar_integer (lookup_internalvar ("tracepoint"), num);
}

/* Set externally visible debug variables for querying/printing
   the traceframe context (line, function, file).  */

static void
set_traceframe_context (struct frame_info *trace_frame)
{
  CORE_ADDR trace_pc;

  /* Save as globals for internal use.  */
  if (trace_frame != NULL
      && get_frame_pc_if_available (trace_frame, &trace_pc))
    {
      traceframe_sal = find_pc_line (trace_pc, 0);
      traceframe_fun = find_pc_function (trace_pc);

      /* Save linenumber as "$trace_line", a debugger variable visible to
	 users.  */
      set_internalvar_integer (lookup_internalvar ("trace_line"),
			       traceframe_sal.line);
    }
  else
    {
      init_sal (&traceframe_sal);
      traceframe_fun = NULL;
      set_internalvar_integer (lookup_internalvar ("trace_line"), -1);
    }

  /* Save func name as "$trace_func", a debugger variable visible to
     users.  */
  if (traceframe_fun == NULL
      || SYMBOL_LINKAGE_NAME (traceframe_fun) == NULL)
    clear_internalvar (lookup_internalvar ("trace_func"));
  else
    set_internalvar_string (lookup_internalvar ("trace_func"),
			    SYMBOL_LINKAGE_NAME (traceframe_fun));

  /* Save file name as "$trace_file", a debugger variable visible to
     users.  */
  if (traceframe_sal.symtab == NULL)
    clear_internalvar (lookup_internalvar ("trace_file"));
  else
    set_internalvar_string (lookup_internalvar ("trace_file"),
			symtab_to_filename_for_display (traceframe_sal.symtab));
}

/* Create a new trace state variable with the given name.  */

struct trace_state_variable *
create_trace_state_variable (const char *name)
{
  struct trace_state_variable tsv;

  memset (&tsv, 0, sizeof (tsv));
  tsv.name = xstrdup (name);
  tsv.number = next_tsv_number++;
  return VEC_safe_push (tsv_s, tvariables, &tsv);
}

/* Look for a trace state variable of the given name.  */

struct trace_state_variable *
find_trace_state_variable (const char *name)
{
  struct trace_state_variable *tsv;
  int ix;

  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
    if (strcmp (name, tsv->name) == 0)
      return tsv;

  return NULL;
}

/* Look for a trace state variable of the given number.  Return NULL if
   not found.  */

struct trace_state_variable *
find_trace_state_variable_by_number (int number)
{
  struct trace_state_variable *tsv;
  int ix;

  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
    if (tsv->number == number)
      return tsv;

  return NULL;
}

static void
delete_trace_state_variable (const char *name)
{
  struct trace_state_variable *tsv;
  int ix;

  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
    if (strcmp (name, tsv->name) == 0)
      {
	observer_notify_tsv_deleted (tsv);

	xfree ((void *)tsv->name);
	VEC_unordered_remove (tsv_s, tvariables, ix);

	return;
      }

  warning (_("No trace variable named \"$%s\", not deleting"), name);
}

/* Throws an error if NAME is not valid syntax for a trace state
   variable's name.  */

void
validate_trace_state_variable_name (const char *name)
{
  const char *p;

  if (*name == '\0')
    error (_("Must supply a non-empty variable name"));

  /* All digits in the name is reserved for value history
     references.  */
  for (p = name; isdigit (*p); p++)
    ;
  if (*p == '\0')
    error (_("$%s is not a valid trace state variable name"), name);

  for (p = name; isalnum (*p) || *p == '_'; p++)
    ;
  if (*p != '\0')
    error (_("$%s is not a valid trace state variable name"), name);
}

/* The 'tvariable' command collects a name and optional expression to
   evaluate into an initial value.  */

static void
trace_variable_command (char *args, int from_tty)
{
  struct cleanup *old_chain;
  LONGEST initval = 0;
  struct trace_state_variable *tsv;
  char *name, *p;

  if (!args || !*args)
    error_no_arg (_("Syntax is $NAME [ = EXPR ]"));

  /* Only allow two syntaxes; "$name" and "$name=value".  */
  p = skip_spaces (args);

  if (*p++ != '$')
    error (_("Name of trace variable should start with '$'"));

  name = p;
  while (isalnum (*p) || *p == '_')
    p++;
  name = savestring (name, p - name);
  old_chain = make_cleanup (xfree, name);

  p = skip_spaces (p);
  if (*p != '=' && *p != '\0')
    error (_("Syntax must be $NAME [ = EXPR ]"));

  validate_trace_state_variable_name (name);

  if (*p == '=')
    initval = value_as_long (parse_and_eval (++p));

  /* If the variable already exists, just change its initial value.  */
  tsv = find_trace_state_variable (name);
  if (tsv)
    {
      if (tsv->initial_value != initval)
	{
	  tsv->initial_value = initval;
	  observer_notify_tsv_modified (tsv);
	}
      printf_filtered (_("Trace state variable $%s "
			 "now has initial value %s.\n"),
		       tsv->name, plongest (tsv->initial_value));
      do_cleanups (old_chain);
      return;
    }

  /* Create a new variable.  */
  tsv = create_trace_state_variable (name);
  tsv->initial_value = initval;

  observer_notify_tsv_created (tsv);

  printf_filtered (_("Trace state variable $%s "
		     "created, with initial value %s.\n"),
		   tsv->name, plongest (tsv->initial_value));

  do_cleanups (old_chain);
}

static void
delete_trace_variable_command (char *args, int from_tty)
{
  int ix;
  char **argv;
  struct cleanup *back_to;

  if (args == NULL)
    {
      if (query (_("Delete all trace state variables? ")))
	VEC_free (tsv_s, tvariables);
      dont_repeat ();
      observer_notify_tsv_deleted (NULL);
      return;
    }

  argv = gdb_buildargv (args);
  back_to = make_cleanup_freeargv (argv);

  for (ix = 0; argv[ix] != NULL; ix++)
    {
      if (*argv[ix] == '$')
	delete_trace_state_variable (argv[ix] + 1);
      else
	warning (_("Name \"%s\" not prefixed with '$', ignoring"), argv[ix]);
    }

  do_cleanups (back_to);

  dont_repeat ();
}

void
tvariables_info_1 (void)
{
  struct trace_state_variable *tsv;
  int ix;
  int count = 0;
  struct cleanup *back_to;
  struct ui_out *uiout = current_uiout;

  if (VEC_length (tsv_s, tvariables) == 0 && !ui_out_is_mi_like_p (uiout))
    {
      printf_filtered (_("No trace state variables.\n"));
      return;
    }

  /* Try to acquire values from the target.  */
  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix, ++count)
    tsv->value_known = target_get_trace_state_variable_value (tsv->number,
							      &(tsv->value));

  back_to = make_cleanup_ui_out_table_begin_end (uiout, 3,
                                                 count, "trace-variables");
  ui_out_table_header (uiout, 15, ui_left, "name", "Name");
  ui_out_table_header (uiout, 11, ui_left, "initial", "Initial");
  ui_out_table_header (uiout, 11, ui_left, "current", "Current");

  ui_out_table_body (uiout);

  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
    {
      struct cleanup *back_to2;
      char *c;
      char *name;

      back_to2 = make_cleanup_ui_out_tuple_begin_end (uiout, "variable");

      name = concat ("$", tsv->name, (char *) NULL);
      make_cleanup (xfree, name);
      ui_out_field_string (uiout, "name", name);
      ui_out_field_string (uiout, "initial", plongest (tsv->initial_value));

      if (tsv->value_known)
        c = plongest (tsv->value);
      else if (ui_out_is_mi_like_p (uiout))
        /* For MI, we prefer not to use magic string constants, but rather
           omit the field completely.  The difference between unknown and
           undefined does not seem important enough to represent.  */
        c = NULL;
      else if (current_trace_status ()->running || traceframe_number >= 0)
	/* The value is/was defined, but we don't have it.  */
        c = "<unknown>";
      else
	/* It is not meaningful to ask about the value.  */
        c = "<undefined>";
      if (c)
        ui_out_field_string (uiout, "current", c);
      ui_out_text (uiout, "\n");

      do_cleanups (back_to2);
    }

  do_cleanups (back_to);
}

/* List all the trace state variables.  */

static void
tvariables_info (char *args, int from_tty)
{
  tvariables_info_1 ();
}

/* Stash definitions of tsvs into the given file.  */

void
save_trace_state_variables (struct ui_file *fp)
{
  struct trace_state_variable *tsv;
  int ix;

  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
    {
      fprintf_unfiltered (fp, "tvariable $%s", tsv->name);
      if (tsv->initial_value)
	fprintf_unfiltered (fp, " = %s", plongest (tsv->initial_value));
      fprintf_unfiltered (fp, "\n");
    }
}

/* ACTIONS functions: */

/* The three functions:
   collect_pseudocommand, 
   while_stepping_pseudocommand, and 
   end_actions_pseudocommand
   are placeholders for "commands" that are actually ONLY to be used
   within a tracepoint action list.  If the actual function is ever called,
   it means that somebody issued the "command" at the top level,
   which is always an error.  */

static void
end_actions_pseudocommand (char *args, int from_tty)
{
  error (_("This command cannot be used at the top level."));
}

static void
while_stepping_pseudocommand (char *args, int from_tty)
{
  error (_("This command can only be used in a tracepoint actions list."));
}

static void
collect_pseudocommand (char *args, int from_tty)
{
  error (_("This command can only be used in a tracepoint actions list."));
}

static void
teval_pseudocommand (char *args, int from_tty)
{
  error (_("This command can only be used in a tracepoint actions list."));
}

/* Parse any collection options, such as /s for strings.  */

const char *
decode_agent_options (const char *exp, int *trace_string)
{
  struct value_print_options opts;

  *trace_string = 0;

  if (*exp != '/')
    return exp;

  /* Call this to borrow the print elements default for collection
     size.  */
  get_user_print_options (&opts);

  exp++;
  if (*exp == 's')
    {
      if (target_supports_string_tracing ())
	{
	  /* Allow an optional decimal number giving an explicit maximum
	     string length, defaulting it to the "print elements" value;
	     so "collect/s80 mystr" gets at most 80 bytes of string.  */
	  *trace_string = opts.print_max;
	  exp++;
	  if (*exp >= '0' && *exp <= '9')
	    *trace_string = atoi (exp);
	  while (*exp >= '0' && *exp <= '9')
	    exp++;
	}
      else
	error (_("Target does not support \"/s\" option for string tracing."));
    }
  else
    error (_("Undefined collection format \"%c\"."), *exp);

  exp = skip_spaces_const (exp);

  return exp;
}

/* Enter a list of actions for a tracepoint.  */
static void
trace_actions_command (char *args, int from_tty)
{
  struct tracepoint *t;
  struct command_line *l;

  t = get_tracepoint_by_number (&args, NULL, 1);
  if (t)
    {
      char *tmpbuf =
	xstrprintf ("Enter actions for tracepoint %d, one per line.",
		    t->base.number);
      struct cleanup *cleanups = make_cleanup (xfree, tmpbuf);

      l = read_command_lines (tmpbuf, from_tty, 1,
			      check_tracepoint_command, t);
      do_cleanups (cleanups);
      breakpoint_set_commands (&t->base, l);
    }
  /* else just return */
}

/* Report the results of checking the agent expression, as errors or
   internal errors.  */

static void
report_agent_reqs_errors (struct agent_expr *aexpr)
{
  /* All of the "flaws" are serious bytecode generation issues that
     should never occur.  */
  if (aexpr->flaw != agent_flaw_none)
    internal_error (__FILE__, __LINE__, _("expression is malformed"));

  /* If analysis shows a stack underflow, GDB must have done something
     badly wrong in its bytecode generation.  */
  if (aexpr->min_height < 0)
    internal_error (__FILE__, __LINE__,
		    _("expression has min height < 0"));

  /* Issue this error if the stack is predicted to get too deep.  The
     limit is rather arbitrary; a better scheme might be for the
     target to report how much stack it will have available.  The
     depth roughly corresponds to parenthesization, so a limit of 20
     amounts to 20 levels of expression nesting, which is actually
     a pretty big hairy expression.  */
  if (aexpr->max_height > 20)
    error (_("Expression is too complicated."));
}

/* worker function */
void
validate_actionline (const char *line, struct breakpoint *b)
{
  struct cmd_list_element *c;
  struct expression *exp = NULL;
  struct cleanup *old_chain = NULL;
  const char *tmp_p;
  const char *p;
  struct bp_location *loc;
  struct agent_expr *aexpr;
  struct tracepoint *t = (struct tracepoint *) b;

  /* If EOF is typed, *line is NULL.  */
  if (line == NULL)
    return;

  p = skip_spaces_const (line);

  /* Symbol lookup etc.  */
  if (*p == '\0')	/* empty line: just prompt for another line.  */
    return;

  if (*p == '#')		/* comment line */
    return;

  c = lookup_cmd (&p, cmdlist, "", -1, 1);
  if (c == 0)
    error (_("`%s' is not a tracepoint action, or is ambiguous."), p);

  if (cmd_cfunc_eq (c, collect_pseudocommand))
    {
      int trace_string = 0;

      if (*p == '/')
	p = decode_agent_options (p, &trace_string);

      do
	{			/* Repeat over a comma-separated list.  */
	  QUIT;			/* Allow user to bail out with ^C.  */
	  p = skip_spaces_const (p);

	  if (*p == '$')	/* Look for special pseudo-symbols.  */
	    {
	      if (0 == strncasecmp ("reg", p + 1, 3)
		  || 0 == strncasecmp ("arg", p + 1, 3)
		  || 0 == strncasecmp ("loc", p + 1, 3)
		  || 0 == strncasecmp ("_ret", p + 1, 4)
		  || 0 == strncasecmp ("_sdata", p + 1, 6))
		{
		  p = strchr (p, ',');
		  continue;
		}
	      /* else fall thru, treat p as an expression and parse it!  */
	    }
	  tmp_p = p;
	  for (loc = t->base.loc; loc; loc = loc->next)
	    {
	      p = tmp_p;
	      exp = parse_exp_1 (&p, loc->address,
				 block_for_pc (loc->address), 1);
	      old_chain = make_cleanup (free_current_contents, &exp);

	      if (exp->elts[0].opcode == OP_VAR_VALUE)
		{
		  if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_CONST)
		    {
		      error (_("constant `%s' (value %s) "
			       "will not be collected."),
			     SYMBOL_PRINT_NAME (exp->elts[2].symbol),
			     plongest (SYMBOL_VALUE (exp->elts[2].symbol)));
		    }
		  else if (SYMBOL_CLASS (exp->elts[2].symbol)
			   == LOC_OPTIMIZED_OUT)
		    {
		      error (_("`%s' is optimized away "
			       "and cannot be collected."),
			     SYMBOL_PRINT_NAME (exp->elts[2].symbol));
		    }
		}

	      /* We have something to collect, make sure that the expr to
		 bytecode translator can handle it and that it's not too
		 long.  */
	      aexpr = gen_trace_for_expr (loc->address, exp, trace_string);
	      make_cleanup_free_agent_expr (aexpr);

	      if (aexpr->len > MAX_AGENT_EXPR_LEN)
		error (_("Expression is too complicated."));

	      ax_reqs (aexpr);

	      report_agent_reqs_errors (aexpr);

	      do_cleanups (old_chain);
	    }
	}
      while (p && *p++ == ',');
    }

  else if (cmd_cfunc_eq (c, teval_pseudocommand))
    {
      do
	{			/* Repeat over a comma-separated list.  */
	  QUIT;			/* Allow user to bail out with ^C.  */
	  p = skip_spaces_const (p);

	  tmp_p = p;
	  for (loc = t->base.loc; loc; loc = loc->next)
	    {
	      p = tmp_p;

	      /* Only expressions are allowed for this action.  */
	      exp = parse_exp_1 (&p, loc->address,
				 block_for_pc (loc->address), 1);
	      old_chain = make_cleanup (free_current_contents, &exp);

	      /* We have something to evaluate, make sure that the expr to
		 bytecode translator can handle it and that it's not too
		 long.  */
	      aexpr = gen_eval_for_expr (loc->address, exp);
	      make_cleanup_free_agent_expr (aexpr);

	      if (aexpr->len > MAX_AGENT_EXPR_LEN)
		error (_("Expression is too complicated."));

	      ax_reqs (aexpr);
	      report_agent_reqs_errors (aexpr);

	      do_cleanups (old_chain);
	    }
	}
      while (p && *p++ == ',');
    }

  else if (cmd_cfunc_eq (c, while_stepping_pseudocommand))
    {
      char *endp;

      p = skip_spaces_const (p);
      t->step_count = strtol (p, &endp, 0);
      if (endp == p || t->step_count == 0)
	error (_("while-stepping step count `%s' is malformed."), line);
      p = endp;
    }

  else if (cmd_cfunc_eq (c, end_actions_pseudocommand))
    ;

  else
    error (_("`%s' is not a supported tracepoint action."), line);
}

enum {
  memrange_absolute = -1
};

/* MEMRANGE functions: */

static int memrange_cmp (const void *, const void *);

/* Compare memranges for qsort.  */
static int
memrange_cmp (const void *va, const void *vb)
{
  const struct memrange *a = va, *b = vb;

  if (a->type < b->type)
    return -1;
  if (a->type > b->type)
    return 1;
  if (a->type == memrange_absolute)
    {
      if ((bfd_vma) a->start < (bfd_vma) b->start)
	return -1;
      if ((bfd_vma) a->start > (bfd_vma) b->start)
	return 1;
    }
  else
    {
      if (a->start < b->start)
	return -1;
      if (a->start > b->start)
	return 1;
    }
  return 0;
}

/* Sort the memrange list using qsort, and merge adjacent memranges.  */
static void
memrange_sortmerge (struct collection_list *memranges)
{
  int a, b;

  qsort (memranges->list, memranges->next_memrange,
	 sizeof (struct memrange), memrange_cmp);
  if (memranges->next_memrange > 0)
    {
      for (a = 0, b = 1; b < memranges->next_memrange; b++)
	{
	  /* If memrange b overlaps or is adjacent to memrange a,
	     merge them.  */
	  if (memranges->list[a].type == memranges->list[b].type
	      && memranges->list[b].start <= memranges->list[a].end)
	    {
	      if (memranges->list[b].end > memranges->list[a].end)
		memranges->list[a].end = memranges->list[b].end;
	      continue;		/* next b, same a */
	    }
	  a++;			/* next a */
	  if (a != b)
	    memcpy (&memranges->list[a], &memranges->list[b],
		    sizeof (struct memrange));
	}
      memranges->next_memrange = a + 1;
    }
}

/* Add a register to a collection list.  */
static void
add_register (struct collection_list *collection, unsigned int regno)
{
  if (info_verbose)
    printf_filtered ("collect register %d\n", regno);
  if (regno >= (8 * sizeof (collection->regs_mask)))
    error (_("Internal: register number %d too large for tracepoint"),
	   regno);
  collection->regs_mask[regno / 8] |= 1 << (regno % 8);
}

/* Add a memrange to a collection list.  */
static void
add_memrange (struct collection_list *memranges, 
	      int type, bfd_signed_vma base,
	      unsigned long len)
{
  if (info_verbose)
    {
      printf_filtered ("(%d,", type);
      printf_vma (base);
      printf_filtered (",%ld)\n", len);
    }

  /* type: memrange_absolute == memory, other n == basereg */
  memranges->list[memranges->next_memrange].type = type;
  /* base: addr if memory, offset if reg relative.  */
  memranges->list[memranges->next_memrange].start = base;
  /* len: we actually save end (base + len) for convenience */
  memranges->list[memranges->next_memrange].end = base + len;
  memranges->next_memrange++;
  if (memranges->next_memrange >= memranges->listsize)
    {
      memranges->listsize *= 2;
      memranges->list = xrealloc (memranges->list,
				  memranges->listsize);
    }

  if (type != memrange_absolute)    /* Better collect the base register!  */
    add_register (memranges, type);
}

/* Add a symbol to a collection list.  */
static void
collect_symbol (struct collection_list *collect, 
		struct symbol *sym,
		struct gdbarch *gdbarch,
		long frame_regno, long frame_offset,
		CORE_ADDR scope,
		int trace_string)
{
  unsigned long len;
  unsigned int reg;
  bfd_signed_vma offset;
  int treat_as_expr = 0;

  len = TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym)));
  switch (SYMBOL_CLASS (sym))
    {
    default:
      printf_filtered ("%s: don't know symbol class %d\n",
		       SYMBOL_PRINT_NAME (sym),
		       SYMBOL_CLASS (sym));
      break;
    case LOC_CONST:
      printf_filtered ("constant %s (value %s) will not be collected.\n",
		       SYMBOL_PRINT_NAME (sym), plongest (SYMBOL_VALUE (sym)));
      break;
    case LOC_STATIC:
      offset = SYMBOL_VALUE_ADDRESS (sym);
      if (info_verbose)
	{
	  char tmp[40];

	  sprintf_vma (tmp, offset);
	  printf_filtered ("LOC_STATIC %s: collect %ld bytes at %s.\n",
			   SYMBOL_PRINT_NAME (sym), len,
			   tmp /* address */);
	}
      /* A struct may be a C++ class with static fields, go to general
	 expression handling.  */
      if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_STRUCT)
	treat_as_expr = 1;
      else
	add_memrange (collect, memrange_absolute, offset, len);
      break;
    case LOC_REGISTER:
      reg = SYMBOL_REGISTER_OPS (sym)->register_number (sym, gdbarch);
      if (info_verbose)
	printf_filtered ("LOC_REG[parm] %s: ", 
			 SYMBOL_PRINT_NAME (sym));
      add_register (collect, reg);
      /* Check for doubles stored in two registers.  */
      /* FIXME: how about larger types stored in 3 or more regs?  */
      if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FLT &&
	  len > register_size (gdbarch, reg))
	add_register (collect, reg + 1);
      break;
    case LOC_REF_ARG:
      printf_filtered ("Sorry, don't know how to do LOC_REF_ARG yet.\n");
      printf_filtered ("       (will not collect %s)\n",
		       SYMBOL_PRINT_NAME (sym));
      break;
    case LOC_ARG:
      reg = frame_regno;
      offset = frame_offset + SYMBOL_VALUE (sym);
      if (info_verbose)
	{
	  printf_filtered ("LOC_LOCAL %s: Collect %ld bytes at offset ",
			   SYMBOL_PRINT_NAME (sym), len);
	  printf_vma (offset);
	  printf_filtered (" from frame ptr reg %d\n", reg);
	}
      add_memrange (collect, reg, offset, len);
      break;
    case LOC_REGPARM_ADDR:
      reg = SYMBOL_VALUE (sym);
      offset = 0;
      if (info_verbose)
	{
	  printf_filtered ("LOC_REGPARM_ADDR %s: Collect %ld bytes at offset ",
			   SYMBOL_PRINT_NAME (sym), len);
	  printf_vma (offset);
	  printf_filtered (" from reg %d\n", reg);
	}
      add_memrange (collect, reg, offset, len);
      break;
    case LOC_LOCAL:
      reg = frame_regno;
      offset = frame_offset + SYMBOL_VALUE (sym);
      if (info_verbose)
	{
	  printf_filtered ("LOC_LOCAL %s: Collect %ld bytes at offset ",
			   SYMBOL_PRINT_NAME (sym), len);
	  printf_vma (offset);
	  printf_filtered (" from frame ptr reg %d\n", reg);
	}
      add_memrange (collect, reg, offset, len);
      break;

    case LOC_UNRESOLVED:
      treat_as_expr = 1;
      break;

    case LOC_OPTIMIZED_OUT:
      printf_filtered ("%s has been optimized out of existence.\n",
		       SYMBOL_PRINT_NAME (sym));
      break;

    case LOC_COMPUTED:
      treat_as_expr = 1;
      break;
    }

  /* Expressions are the most general case.  */
  if (treat_as_expr)
    {
      struct agent_expr *aexpr;
      struct cleanup *old_chain1 = NULL;

      aexpr = gen_trace_for_var (scope, gdbarch, sym, trace_string);

      /* It can happen that the symbol is recorded as a computed
	 location, but it's been optimized away and doesn't actually
	 have a location expression.  */
      if (!aexpr)
	{
	  printf_filtered ("%s has been optimized out of existence.\n",
			   SYMBOL_PRINT_NAME (sym));
	  return;
	}

      old_chain1 = make_cleanup_free_agent_expr (aexpr);

      ax_reqs (aexpr);

      report_agent_reqs_errors (aexpr);

      discard_cleanups (old_chain1);
      add_aexpr (collect, aexpr);

      /* Take care of the registers.  */
      if (aexpr->reg_mask_len > 0)
	{
	  int ndx1, ndx2;

	  for (ndx1 = 0; ndx1 < aexpr->reg_mask_len; ndx1++)
	    {
	      QUIT;	/* Allow user to bail out with ^C.  */
	      if (aexpr->reg_mask[ndx1] != 0)
		{
		  /* Assume chars have 8 bits.  */
		  for (ndx2 = 0; ndx2 < 8; ndx2++)
		    if (aexpr->reg_mask[ndx1] & (1 << ndx2))
		      /* It's used -- record it.  */
		      add_register (collect, ndx1 * 8 + ndx2);
		}
	    }
	}
    }
}

/* Data to be passed around in the calls to the locals and args
   iterators.  */

struct add_local_symbols_data
{
  struct collection_list *collect;
  struct gdbarch *gdbarch;
  CORE_ADDR pc;
  long frame_regno;
  long frame_offset;
  int count;
  int trace_string;
};

/* The callback for the locals and args iterators.  */

static void
do_collect_symbol (const char *print_name,
		   struct symbol *sym,
		   void *cb_data)
{
  struct add_local_symbols_data *p = cb_data;

  collect_symbol (p->collect, sym, p->gdbarch, p->frame_regno,
		  p->frame_offset, p->pc, p->trace_string);
  p->count++;

  VEC_safe_push (char_ptr, p->collect->wholly_collected,
		 xstrdup (print_name));
}

/* Add all locals (or args) symbols to collection list.  */
static void
add_local_symbols (struct collection_list *collect,
		   struct gdbarch *gdbarch, CORE_ADDR pc,
		   long frame_regno, long frame_offset, int type,
		   int trace_string)
{
  struct block *block;
  struct add_local_symbols_data cb_data;

  cb_data.collect = collect;
  cb_data.gdbarch = gdbarch;
  cb_data.pc = pc;
  cb_data.frame_regno = frame_regno;
  cb_data.frame_offset = frame_offset;
  cb_data.count = 0;
  cb_data.trace_string = trace_string;

  if (type == 'L')
    {
      block = block_for_pc (pc);
      if (block == NULL)
	{
	  warning (_("Can't collect locals; "
		     "no symbol table info available.\n"));
	  return;
	}

      iterate_over_block_local_vars (block, do_collect_symbol, &cb_data);
      if (cb_data.count == 0)
	warning (_("No locals found in scope."));
    }
  else
    {
      pc = get_pc_function_start (pc);
      block = block_for_pc (pc);
      if (block == NULL)
	{
	  warning (_("Can't collect args; no symbol table info available."));
	  return;
	}

      iterate_over_block_arg_vars (block, do_collect_symbol, &cb_data);
      if (cb_data.count == 0)
	warning (_("No args found in scope."));
    }
}

static void
add_static_trace_data (struct collection_list *collection)
{
  if (info_verbose)
    printf_filtered ("collect static trace data\n");
  collection->strace_data = 1;
}

/* worker function */
static void
clear_collection_list (struct collection_list *list)
{
  int ndx;

  list->next_memrange = 0;
  for (ndx = 0; ndx < list->next_aexpr_elt; ndx++)
    {
      free_agent_expr (list->aexpr_list[ndx]);
      list->aexpr_list[ndx] = NULL;
    }
  list->next_aexpr_elt = 0;
  memset (list->regs_mask, 0, sizeof (list->regs_mask));
  list->strace_data = 0;

  xfree (list->aexpr_list);
  xfree (list->list);

  VEC_free (char_ptr, list->wholly_collected);
  VEC_free (char_ptr, list->computed);
}

/* A cleanup wrapper for function clear_collection_list.  */

static void
do_clear_collection_list (void *list)
{
  struct collection_list *l = list;

  clear_collection_list (l);
}

/* Initialize collection_list CLIST.  */

static void
init_collection_list (struct collection_list *clist)
{
  memset (clist, 0, sizeof *clist);

  clist->listsize = 128;
  clist->list = xcalloc (clist->listsize,
			 sizeof (struct memrange));

  clist->aexpr_listsize = 128;
  clist->aexpr_list = xcalloc (clist->aexpr_listsize,
			       sizeof (struct agent_expr *));
}

/* Reduce a collection list to string form (for gdb protocol).  */
static char **
stringify_collection_list (struct collection_list *list)
{
  char temp_buf[2048];
  char tmp2[40];
  int count;
  int ndx = 0;
  char *(*str_list)[];
  char *end;
  long i;

  count = 1 + 1 + list->next_memrange + list->next_aexpr_elt + 1;
  str_list = (char *(*)[]) xmalloc (count * sizeof (char *));

  if (list->strace_data)
    {
      if (info_verbose)
	printf_filtered ("\nCollecting static trace data\n");
      end = temp_buf;
      *end++ = 'L';
      (*str_list)[ndx] = savestring (temp_buf, end - temp_buf);
      ndx++;
    }

  for (i = sizeof (list->regs_mask) - 1; i > 0; i--)
    if (list->regs_mask[i] != 0)    /* Skip leading zeroes in regs_mask.  */
      break;
  if (list->regs_mask[i] != 0)	/* Prepare to send regs_mask to the stub.  */
    {
      if (info_verbose)
	printf_filtered ("\nCollecting registers (mask): 0x");
      end = temp_buf;
      *end++ = 'R';
      for (; i >= 0; i--)
	{
	  QUIT;			/* Allow user to bail out with ^C.  */
	  if (info_verbose)
	    printf_filtered ("%02X", list->regs_mask[i]);
	  sprintf (end, "%02X", list->regs_mask[i]);
	  end += 2;
	}
      (*str_list)[ndx] = xstrdup (temp_buf);
      ndx++;
    }
  if (info_verbose)
    printf_filtered ("\n");
  if (list->next_memrange > 0 && info_verbose)
    printf_filtered ("Collecting memranges: \n");
  for (i = 0, count = 0, end = temp_buf; i < list->next_memrange; i++)
    {
      QUIT;			/* Allow user to bail out with ^C.  */
      sprintf_vma (tmp2, list->list[i].start);
      if (info_verbose)
	{
	  printf_filtered ("(%d, %s, %ld)\n", 
			   list->list[i].type, 
			   tmp2, 
			   (long) (list->list[i].end - list->list[i].start));
	}
      if (count + 27 > MAX_AGENT_EXPR_LEN)
	{
	  (*str_list)[ndx] = savestring (temp_buf, count);
	  ndx++;
	  count = 0;
	  end = temp_buf;
	}

      {
        bfd_signed_vma length = list->list[i].end - list->list[i].start;

        /* The "%X" conversion specifier expects an unsigned argument,
           so passing -1 (memrange_absolute) to it directly gives you
           "FFFFFFFF" (or more, depending on sizeof (unsigned)).
           Special-case it.  */
        if (list->list[i].type == memrange_absolute)
          sprintf (end, "M-1,%s,%lX", tmp2, (long) length);
        else
          sprintf (end, "M%X,%s,%lX", list->list[i].type, tmp2, (long) length);
      }

      count += strlen (end);
      end = temp_buf + count;
    }

  for (i = 0; i < list->next_aexpr_elt; i++)
    {
      QUIT;			/* Allow user to bail out with ^C.  */
      if ((count + 10 + 2 * list->aexpr_list[i]->len) > MAX_AGENT_EXPR_LEN)
	{
	  (*str_list)[ndx] = savestring (temp_buf, count);
	  ndx++;
	  count = 0;
	  end = temp_buf;
	}
      sprintf (end, "X%08X,", list->aexpr_list[i]->len);
      end += 10;		/* 'X' + 8 hex digits + ',' */
      count += 10;

      end = mem2hex (list->aexpr_list[i]->buf, 
		     end, list->aexpr_list[i]->len);
      count += 2 * list->aexpr_list[i]->len;
    }

  if (count != 0)
    {
      (*str_list)[ndx] = savestring (temp_buf, count);
      ndx++;
      count = 0;
      end = temp_buf;
    }
  (*str_list)[ndx] = NULL;

  if (ndx == 0)
    {
      xfree (str_list);
      return NULL;
    }
  else
    return *str_list;
}

/* Add the printed expression EXP to *LIST.  */

static void
append_exp (struct expression *exp, VEC(char_ptr) **list)
{
  struct ui_file *tmp_stream = mem_fileopen ();
  char *text;

  print_expression (exp, tmp_stream);

  text = ui_file_xstrdup (tmp_stream, NULL);

  VEC_safe_push (char_ptr, *list, text);
  ui_file_delete (tmp_stream);
}

static void
encode_actions_1 (struct command_line *action,
		  struct bp_location *tloc,
		  int frame_reg,
		  LONGEST frame_offset,
		  struct collection_list *collect,
		  struct collection_list *stepping_list)
{
  const char *action_exp;
  struct expression *exp = NULL;
  int i;
  struct value *tempval;
  struct cmd_list_element *cmd;
  struct agent_expr *aexpr;

  for (; action; action = action->next)
    {
      QUIT;			/* Allow user to bail out with ^C.  */
      action_exp = action->line;
      action_exp = skip_spaces_const (action_exp);

      cmd = lookup_cmd (&action_exp, cmdlist, "", -1, 1);
      if (cmd == 0)
	error (_("Bad action list item: %s"), action_exp);

      if (cmd_cfunc_eq (cmd, collect_pseudocommand))
	{
	  int trace_string = 0;

	  if (*action_exp == '/')
	    action_exp = decode_agent_options (action_exp, &trace_string);

	  do
	    {			/* Repeat over a comma-separated list.  */
	      QUIT;		/* Allow user to bail out with ^C.  */
	      action_exp = skip_spaces_const (action_exp);

	      if (0 == strncasecmp ("$reg", action_exp, 4))
		{
		  for (i = 0; i < gdbarch_num_regs (tloc->gdbarch); i++)
		    add_register (collect, i);
		  action_exp = strchr (action_exp, ',');	/* more? */
		}
	      else if (0 == strncasecmp ("$arg", action_exp, 4))
		{
		  add_local_symbols (collect,
				     tloc->gdbarch,
				     tloc->address,
				     frame_reg,
				     frame_offset,
				     'A',
				     trace_string);
		  action_exp = strchr (action_exp, ',');	/* more? */
		}
	      else if (0 == strncasecmp ("$loc", action_exp, 4))
		{
		  add_local_symbols (collect,
				     tloc->gdbarch,
				     tloc->address,
				     frame_reg,
				     frame_offset,
				     'L',
				     trace_string);
		  action_exp = strchr (action_exp, ',');	/* more? */
		}
	      else if (0 == strncasecmp ("$_ret", action_exp, 5))
		{
		  struct cleanup *old_chain1 = NULL;

		  aexpr = gen_trace_for_return_address (tloc->address,
							tloc->gdbarch,
							trace_string);

		  old_chain1 = make_cleanup_free_agent_expr (aexpr);

		  ax_reqs (aexpr);
		  report_agent_reqs_errors (aexpr);

		  discard_cleanups (old_chain1);
		  add_aexpr (collect, aexpr);

		  /* take care of the registers */
		  if (aexpr->reg_mask_len > 0)
		    {
		      int ndx1, ndx2;

		      for (ndx1 = 0; ndx1 < aexpr->reg_mask_len; ndx1++)
			{
			  QUIT;	/* allow user to bail out with ^C */
			  if (aexpr->reg_mask[ndx1] != 0)
			    {
			      /* assume chars have 8 bits */
			      for (ndx2 = 0; ndx2 < 8; ndx2++)
				if (aexpr->reg_mask[ndx1] & (1 << ndx2))
				  /* it's used -- record it */
				  add_register (collect, 
						ndx1 * 8 + ndx2);
			    }
			}
		    }

		  action_exp = strchr (action_exp, ',');	/* more? */
		}
	      else if (0 == strncasecmp ("$_sdata", action_exp, 7))
		{
		  add_static_trace_data (collect);
		  action_exp = strchr (action_exp, ',');	/* more? */
		}
	      else
		{
		  unsigned long addr;
		  struct cleanup *old_chain = NULL;
		  struct cleanup *old_chain1 = NULL;

		  exp = parse_exp_1 (&action_exp, tloc->address,
				     block_for_pc (tloc->address), 1);
		  old_chain = make_cleanup (free_current_contents, &exp);

		  switch (exp->elts[0].opcode)
		    {
		    case OP_REGISTER:
		      {
			const char *name = &exp->elts[2].string;

			i = user_reg_map_name_to_regnum (tloc->gdbarch,
							 name, strlen (name));
			if (i == -1)
			  internal_error (__FILE__, __LINE__,
					  _("Register $%s not available"),
					  name);
			if (info_verbose)
			  printf_filtered ("OP_REGISTER: ");
			add_register (collect, i);
			break;
		      }

		    case UNOP_MEMVAL:
		      /* Safe because we know it's a simple expression.  */
		      tempval = evaluate_expression (exp);
		      addr = value_address (tempval);
		      /* Initialize the TYPE_LENGTH if it is a typedef.  */
		      check_typedef (exp->elts[1].type);
		      add_memrange (collect, memrange_absolute, addr,
				    TYPE_LENGTH (exp->elts[1].type));
		      append_exp (exp, &collect->computed);
		      break;

		    case OP_VAR_VALUE:
		      {
			struct symbol *sym = exp->elts[2].symbol;
			char_ptr name = (char_ptr) SYMBOL_NATURAL_NAME (sym);

			collect_symbol (collect,
					exp->elts[2].symbol,
					tloc->gdbarch,
					frame_reg,
					frame_offset,
					tloc->address,
					trace_string);
			VEC_safe_push (char_ptr,
				       collect->wholly_collected,
				       name);
		      }
		      break;

		    default:	/* Full-fledged expression.  */
		      aexpr = gen_trace_for_expr (tloc->address, exp,
						  trace_string);

		      old_chain1 = make_cleanup_free_agent_expr (aexpr);

		      ax_reqs (aexpr);

		      report_agent_reqs_errors (aexpr);

		      discard_cleanups (old_chain1);
		      add_aexpr (collect, aexpr);

		      /* Take care of the registers.  */
		      if (aexpr->reg_mask_len > 0)
			{
			  int ndx1;
			  int ndx2;

			  for (ndx1 = 0; ndx1 < aexpr->reg_mask_len; ndx1++)
			    {
			      QUIT;	/* Allow user to bail out with ^C.  */
			      if (aexpr->reg_mask[ndx1] != 0)
				{
				  /* Assume chars have 8 bits.  */
				  for (ndx2 = 0; ndx2 < 8; ndx2++)
				    if (aexpr->reg_mask[ndx1] & (1 << ndx2))
				      /* It's used -- record it.  */
				      add_register (collect, 
						    ndx1 * 8 + ndx2);
				}
			    }
			}

		      append_exp (exp, &collect->computed);
		      break;
		    }		/* switch */
		  do_cleanups (old_chain);
		}		/* do */
	    }
	  while (action_exp && *action_exp++ == ',');
	}			/* if */
      else if (cmd_cfunc_eq (cmd, teval_pseudocommand))
	{
	  do
	    {			/* Repeat over a comma-separated list.  */
	      QUIT;		/* Allow user to bail out with ^C.  */
	      action_exp = skip_spaces_const (action_exp);

		{
		  struct cleanup *old_chain = NULL;
		  struct cleanup *old_chain1 = NULL;

		  exp = parse_exp_1 (&action_exp, tloc->address,
				     block_for_pc (tloc->address), 1);
		  old_chain = make_cleanup (free_current_contents, &exp);

		  aexpr = gen_eval_for_expr (tloc->address, exp);
		  old_chain1 = make_cleanup_free_agent_expr (aexpr);

		  ax_reqs (aexpr);
		  report_agent_reqs_errors (aexpr);

		  discard_cleanups (old_chain1);
		  /* Even though we're not officially collecting, add
		     to the collect list anyway.  */
		  add_aexpr (collect, aexpr);

		  do_cleanups (old_chain);
		}		/* do */
	    }
	  while (action_exp && *action_exp++ == ',');
	}			/* if */
      else if (cmd_cfunc_eq (cmd, while_stepping_pseudocommand))
	{
	  /* We check against nested while-stepping when setting
	     breakpoint action, so no way to run into nested
	     here.  */
	  gdb_assert (stepping_list);

	  encode_actions_1 (action->body_list[0], tloc, frame_reg,
			    frame_offset, stepping_list, NULL);
	}
      else
	error (_("Invalid tracepoint command '%s'"), action->line);
    }				/* for */
}

/* Encode actions of tracepoint TLOC->owner and fill TRACEPOINT_LIST
   and STEPPING_LIST.  Return a cleanup pointer to clean up both
   TRACEPOINT_LIST and STEPPING_LIST.  */

struct cleanup *
encode_actions_and_make_cleanup (struct bp_location *tloc,
				 struct collection_list *tracepoint_list,
				 struct collection_list *stepping_list)
{
  char *default_collect_line = NULL;
  struct command_line *actions;
  struct command_line *default_collect_action = NULL;
  int frame_reg;
  LONGEST frame_offset;
  struct cleanup *back_to, *return_chain;

  return_chain = make_cleanup (null_cleanup, NULL);
  init_collection_list (tracepoint_list);
  init_collection_list (stepping_list);

  make_cleanup (do_clear_collection_list, tracepoint_list);
  make_cleanup (do_clear_collection_list, stepping_list);

  back_to = make_cleanup (null_cleanup, NULL);
  gdbarch_virtual_frame_pointer (tloc->gdbarch,
				 tloc->address, &frame_reg, &frame_offset);

  actions = all_tracepoint_actions_and_cleanup (tloc->owner);

  encode_actions_1 (actions, tloc, frame_reg, frame_offset,
		    tracepoint_list, stepping_list);

  memrange_sortmerge (tracepoint_list);
  memrange_sortmerge (stepping_list);

  do_cleanups (back_to);
  return return_chain;
}

/* Render all actions into gdb protocol.  */

void
encode_actions_rsp (struct bp_location *tloc, char ***tdp_actions,
		    char ***stepping_actions)
{
  struct collection_list tracepoint_list, stepping_list;
  struct cleanup *cleanup;

  *tdp_actions = NULL;
  *stepping_actions = NULL;

  cleanup = encode_actions_and_make_cleanup (tloc, &tracepoint_list,
					     &stepping_list);

  *tdp_actions = stringify_collection_list (&tracepoint_list);
  *stepping_actions = stringify_collection_list (&stepping_list);

  do_cleanups (cleanup);
}

static void
add_aexpr (struct collection_list *collect, struct agent_expr *aexpr)
{
  if (collect->next_aexpr_elt >= collect->aexpr_listsize)
    {
      collect->aexpr_list =
	xrealloc (collect->aexpr_list,
		  2 * collect->aexpr_listsize * sizeof (struct agent_expr *));
      collect->aexpr_listsize *= 2;
    }
  collect->aexpr_list[collect->next_aexpr_elt] = aexpr;
  collect->next_aexpr_elt++;
}

static void
process_tracepoint_on_disconnect (void)
{
  VEC(breakpoint_p) *tp_vec = NULL;
  int ix;
  struct breakpoint *b;
  int has_pending_p = 0;

  /* Check whether we still have pending tracepoint.  If we have, warn the
     user that pending tracepoint will no longer work.  */
  tp_vec = all_tracepoints ();
  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, b); ix++)
    {
      if (b->loc == NULL)
	{
	  has_pending_p = 1;
	  break;
	}
      else
	{
	  struct bp_location *loc1;

	  for (loc1 = b->loc; loc1; loc1 = loc1->next)
	    {
	      if (loc1->shlib_disabled)
		{
		  has_pending_p = 1;
		  break;
		}
	    }

	  if (has_pending_p)
	    break;
	}
    }
  VEC_free (breakpoint_p, tp_vec);

  if (has_pending_p)
    warning (_("Pending tracepoints will not be resolved while"
	       " GDB is disconnected\n"));
}

/* Reset local state of tracing.  */

void
trace_reset_local_state (void)
{
  set_traceframe_num (-1);
  set_tracepoint_num (-1);
  set_traceframe_context (NULL);
  clear_traceframe_info ();
}

void
start_tracing (char *notes)
{
  VEC(breakpoint_p) *tp_vec = NULL;
  int ix;
  struct breakpoint *b;
  struct trace_state_variable *tsv;
  int any_enabled = 0, num_to_download = 0;
  int ret;

  tp_vec = all_tracepoints ();

  /* No point in tracing without any tracepoints...  */
  if (VEC_length (breakpoint_p, tp_vec) == 0)
    {
      VEC_free (breakpoint_p, tp_vec);
      error (_("No tracepoints defined, not starting trace"));
    }

  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, b); ix++)
    {
      struct tracepoint *t = (struct tracepoint *) b;
      struct bp_location *loc;

      if (b->enable_state == bp_enabled)
	any_enabled = 1;

      if ((b->type == bp_fast_tracepoint
	   ? may_insert_fast_tracepoints
	   : may_insert_tracepoints))
	++num_to_download;
      else
	warning (_("May not insert %stracepoints, skipping tracepoint %d"),
		 (b->type == bp_fast_tracepoint ? "fast " : ""), b->number);
    }

  if (!any_enabled)
    {
      if (target_supports_enable_disable_tracepoint ())
	warning (_("No tracepoints enabled"));
      else
	{
	  /* No point in tracing with only disabled tracepoints that
	     cannot be re-enabled.  */
	  VEC_free (breakpoint_p, tp_vec);
	  error (_("No tracepoints enabled, not starting trace"));
	}
    }

  if (num_to_download <= 0)
    {
      VEC_free (breakpoint_p, tp_vec);
      error (_("No tracepoints that may be downloaded, not starting trace"));
    }

  target_trace_init ();

  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, b); ix++)
    {
      struct tracepoint *t = (struct tracepoint *) b;
      struct bp_location *loc;
      int bp_location_downloaded = 0;

      /* Clear `inserted' flag.  */
      for (loc = b->loc; loc; loc = loc->next)
	loc->inserted = 0;

      if ((b->type == bp_fast_tracepoint
	   ? !may_insert_fast_tracepoints
	   : !may_insert_tracepoints))
	continue;

      t->number_on_target = 0;

      for (loc = b->loc; loc; loc = loc->next)
	{
	  /* Since tracepoint locations are never duplicated, `inserted'
	     flag should be zero.  */
	  gdb_assert (!loc->inserted);

	  target_download_tracepoint (loc);

	  loc->inserted = 1;
	  bp_location_downloaded = 1;
	}

      t->number_on_target = b->number;

      for (loc = b->loc; loc; loc = loc->next)
	if (loc->probe != NULL)
	  loc->probe->pops->set_semaphore (loc->probe, loc->gdbarch);

      if (bp_location_downloaded)
	observer_notify_breakpoint_modified (b);
    }
  VEC_free (breakpoint_p, tp_vec);

  /* Send down all the trace state variables too.  */
  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
    {
      target_download_trace_state_variable (tsv);
    }
  
  /* Tell target to treat text-like sections as transparent.  */
  target_trace_set_readonly_regions ();
  /* Set some mode flags.  */
  target_set_disconnected_tracing (disconnected_tracing);
  target_set_circular_trace_buffer (circular_trace_buffer);
  target_set_trace_buffer_size (trace_buffer_size);

  if (!notes)
    notes = trace_notes;
  ret = target_set_trace_notes (trace_user, notes, NULL);

  if (!ret && (trace_user || notes))
    warning (_("Target does not support trace user/notes, info ignored"));

  /* Now insert traps and begin collecting data.  */
  target_trace_start ();

  /* Reset our local state.  */
  trace_reset_local_state ();
  current_trace_status()->running = 1;
}

/* The tstart command requests the target to start a new trace run.
   The command passes any arguments it has to the target verbatim, as
   an optional "trace note".  This is useful as for instance a warning
   to other users if the trace runs disconnected, and you don't want
   anybody else messing with the target.  */

static void
trace_start_command (char *args, int from_tty)
{
  dont_repeat ();	/* Like "run", dangerous to repeat accidentally.  */

  if (current_trace_status ()->running)
    {
      if (from_tty
	  && !query (_("A trace is running already.  Start a new run? ")))
	error (_("New trace run not started."));
    }

  start_tracing (args);
}

/* The tstop command stops the tracing run.  The command passes any
   supplied arguments to the target verbatim as a "stop note"; if the
   target supports trace notes, then it will be reported back as part
   of the trace run's status.  */

static void
trace_stop_command (char *args, int from_tty)
{
  if (!current_trace_status ()->running)
    error (_("Trace is not running."));

  stop_tracing (args);
}

void
stop_tracing (char *note)
{
  int ret;
  VEC(breakpoint_p) *tp_vec = NULL;
  int ix;
  struct breakpoint *t;

  target_trace_stop ();

  tp_vec = all_tracepoints ();
  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, t); ix++)
    {
      struct bp_location *loc;

      if ((t->type == bp_fast_tracepoint
	   ? !may_insert_fast_tracepoints
	   : !may_insert_tracepoints))
	continue;

      for (loc = t->loc; loc; loc = loc->next)
	{
	  /* GDB can be totally absent in some disconnected trace scenarios,
	     but we don't really care if this semaphore goes out of sync.
	     That's why we are decrementing it here, but not taking care
	     in other places.  */
	  if (loc->probe != NULL)
	    loc->probe->pops->clear_semaphore (loc->probe, loc->gdbarch);
	}
    }

  VEC_free (breakpoint_p, tp_vec);

  if (!note)
    note = trace_stop_notes;
  ret = target_set_trace_notes (NULL, NULL, note);

  if (!ret && note)
    warning (_("Target does not support trace notes, note ignored"));

  /* Should change in response to reply?  */
  current_trace_status ()->running = 0;
}

/* tstatus command */
static void
trace_status_command (char *args, int from_tty)
{
  struct trace_status *ts = current_trace_status ();
  int status, ix;
  VEC(breakpoint_p) *tp_vec = NULL;
  struct breakpoint *t;
  
  status = target_get_trace_status (ts);

  if (status == -1)
    {
      if (ts->filename != NULL)
	printf_filtered (_("Using a trace file.\n"));
      else
	{
	  printf_filtered (_("Trace can not be run on this target.\n"));
	  return;
	}
    }

  if (!ts->running_known)
    {
      printf_filtered (_("Run/stop status is unknown.\n"));
    }
  else if (ts->running)
    {
      printf_filtered (_("Trace is running on the target.\n"));
    }
  else
    {
      switch (ts->stop_reason)
	{
	case trace_never_run:
	  printf_filtered (_("No trace has been run on the target.\n"));
	  break;
	case tstop_command:
	  if (ts->stop_desc)
	    printf_filtered (_("Trace stopped by a tstop command (%s).\n"),
			     ts->stop_desc);
	  else
	    printf_filtered (_("Trace stopped by a tstop command.\n"));
	  break;
	case trace_buffer_full:
	  printf_filtered (_("Trace stopped because the buffer was full.\n"));
	  break;
	case trace_disconnected:
	  printf_filtered (_("Trace stopped because of disconnection.\n"));
	  break;
	case tracepoint_passcount:
	  printf_filtered (_("Trace stopped by tracepoint %d.\n"),
			   ts->stopping_tracepoint);
	  break;
	case tracepoint_error:
	  if (ts->stopping_tracepoint)
	    printf_filtered (_("Trace stopped by an "
			       "error (%s, tracepoint %d).\n"),
			     ts->stop_desc, ts->stopping_tracepoint);
	  else
	    printf_filtered (_("Trace stopped by an error (%s).\n"),
			     ts->stop_desc);
	  break;
	case trace_stop_reason_unknown:
	  printf_filtered (_("Trace stopped for an unknown reason.\n"));
	  break;
	default:
	  printf_filtered (_("Trace stopped for some other reason (%d).\n"),
			   ts->stop_reason);
	  break;
	}
    }

  if (ts->traceframes_created >= 0
      && ts->traceframe_count != ts->traceframes_created)
    {
      printf_filtered (_("Buffer contains %d trace "
			 "frames (of %d created total).\n"),
		       ts->traceframe_count, ts->traceframes_created);
    }
  else if (ts->traceframe_count >= 0)
    {
      printf_filtered (_("Collected %d trace frames.\n"),
		       ts->traceframe_count);
    }

  if (ts->buffer_free >= 0)
    {
      if (ts->buffer_size >= 0)
	{
	  printf_filtered (_("Trace buffer has %d bytes of %d bytes free"),
			   ts->buffer_free, ts->buffer_size);
	  if (ts->buffer_size > 0)
	    printf_filtered (_(" (%d%% full)"),
			     ((int) ((((long long) (ts->buffer_size
						    - ts->buffer_free)) * 100)
				     / ts->buffer_size)));
	  printf_filtered (_(".\n"));
	}
      else
	printf_filtered (_("Trace buffer has %d bytes free.\n"),
			 ts->buffer_free);
    }

  if (ts->disconnected_tracing)
    printf_filtered (_("Trace will continue if GDB disconnects.\n"));
  else
    printf_filtered (_("Trace will stop if GDB disconnects.\n"));

  if (ts->circular_buffer)
    printf_filtered (_("Trace buffer is circular.\n"));

  if (ts->user_name && strlen (ts->user_name) > 0)
    printf_filtered (_("Trace user is %s.\n"), ts->user_name);

  if (ts->notes && strlen (ts->notes) > 0)
    printf_filtered (_("Trace notes: %s.\n"), ts->notes);

  /* Now report on what we're doing with tfind.  */
  if (traceframe_number >= 0)
    printf_filtered (_("Looking at trace frame %d, tracepoint %d.\n"),
		     traceframe_number, tracepoint_number);
  else
    printf_filtered (_("Not looking at any trace frame.\n"));

  /* Report start/stop times if supplied.  */
  if (ts->start_time)
    {
      if (ts->stop_time)
	{
	  LONGEST run_time = ts->stop_time - ts->start_time;

	  /* Reporting a run time is more readable than two long numbers.  */
	  printf_filtered (_("Trace started at %ld.%06ld secs, stopped %ld.%06ld secs later.\n"),
			   (long int) (ts->start_time / 1000000),
			   (long int) (ts->start_time % 1000000),
			   (long int) (run_time / 1000000),
			   (long int) (run_time % 1000000));
	}
      else
	printf_filtered (_("Trace started at %ld.%06ld secs.\n"),
			 (long int) (ts->start_time / 1000000),
			 (long int) (ts->start_time % 1000000));
    }
  else if (ts->stop_time)
    printf_filtered (_("Trace stopped at %ld.%06ld secs.\n"),
		     (long int) (ts->stop_time / 1000000),
		     (long int) (ts->stop_time % 1000000));

  /* Now report any per-tracepoint status available.  */
  tp_vec = all_tracepoints ();

  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, t); ix++)
    target_get_tracepoint_status (t, NULL);

  VEC_free (breakpoint_p, tp_vec);
}

/* Report the trace status to uiout, in a way suitable for MI, and not
   suitable for CLI.  If ON_STOP is true, suppress a few fields that
   are not meaningful in the -trace-stop response.

   The implementation is essentially parallel to trace_status_command, but
   merging them will result in unreadable code.  */
void
trace_status_mi (int on_stop)
{
  struct ui_out *uiout = current_uiout;
  struct trace_status *ts = current_trace_status ();
  int status;

  status = target_get_trace_status (ts);

  if (status == -1 && ts->filename == NULL)
    {
      ui_out_field_string (uiout, "supported", "0");
      return;
    }

  if (ts->filename != NULL)
    ui_out_field_string (uiout, "supported", "file");
  else if (!on_stop)
    ui_out_field_string (uiout, "supported", "1");

  if (ts->filename != NULL)
    ui_out_field_string (uiout, "trace-file", ts->filename);

  gdb_assert (ts->running_known);

  if (ts->running)
    {
      ui_out_field_string (uiout, "running", "1");

      /* Unlike CLI, do not show the state of 'disconnected-tracing' variable.
	 Given that the frontend gets the status either on -trace-stop, or from
	 -trace-status after re-connection, it does not seem like this
	 information is necessary for anything.  It is not necessary for either
	 figuring the vital state of the target nor for navigation of trace
	 frames.  If the frontend wants to show the current state is some
	 configure dialog, it can request the value when such dialog is
	 invoked by the user.  */
    }
  else
    {
      char *stop_reason = NULL;
      int stopping_tracepoint = -1;

      if (!on_stop)
	ui_out_field_string (uiout, "running", "0");

      if (ts->stop_reason != trace_stop_reason_unknown)
	{
	  switch (ts->stop_reason)
	    {
	    case tstop_command:
	      stop_reason = "request";
	      break;
	    case trace_buffer_full:
	      stop_reason = "overflow";
	      break;
	    case trace_disconnected:
	      stop_reason = "disconnection";
	      break;
	    case tracepoint_passcount:
	      stop_reason = "passcount";
	      stopping_tracepoint = ts->stopping_tracepoint;
	      break;
	    case tracepoint_error:
	      stop_reason = "error";
	      stopping_tracepoint = ts->stopping_tracepoint;
	      break;
	    }
	  
	  if (stop_reason)
	    {
	      ui_out_field_string (uiout, "stop-reason", stop_reason);
	      if (stopping_tracepoint != -1)
		ui_out_field_int (uiout, "stopping-tracepoint",
				  stopping_tracepoint);
	      if (ts->stop_reason == tracepoint_error)
		ui_out_field_string (uiout, "error-description",
				     ts->stop_desc);
	    }
	}
    }

  if (ts->traceframe_count != -1)
    ui_out_field_int (uiout, "frames", ts->traceframe_count);
  if (ts->traceframes_created != -1)
    ui_out_field_int (uiout, "frames-created", ts->traceframes_created);
  if (ts->buffer_size != -1)
    ui_out_field_int (uiout, "buffer-size", ts->buffer_size);
  if (ts->buffer_free != -1)
    ui_out_field_int (uiout, "buffer-free", ts->buffer_free);

  ui_out_field_int (uiout, "disconnected",  ts->disconnected_tracing);
  ui_out_field_int (uiout, "circular",  ts->circular_buffer);

  ui_out_field_string (uiout, "user-name", ts->user_name);
  ui_out_field_string (uiout, "notes", ts->notes);

  {
    char buf[100];

    xsnprintf (buf, sizeof buf, "%ld.%06ld",
	       (long int) (ts->start_time / 1000000),
	       (long int) (ts->start_time % 1000000));
    ui_out_field_string (uiout, "start-time", buf);
    xsnprintf (buf, sizeof buf, "%ld.%06ld",
	       (long int) (ts->stop_time / 1000000),
	       (long int) (ts->stop_time % 1000000));
    ui_out_field_string (uiout, "stop-time", buf);
  }
}

/* Check if a trace run is ongoing.  If so, and FROM_TTY, query the
   user if she really wants to detach.  */

void
query_if_trace_running (int from_tty)
{
  if (!from_tty)
    return;

  /* It can happen that the target that was tracing went away on its
     own, and we didn't notice.  Get a status update, and if the
     current target doesn't even do tracing, then assume it's not
     running anymore.  */
  if (target_get_trace_status (current_trace_status ()) < 0)
    current_trace_status ()->running = 0;

  /* If running interactively, give the user the option to cancel and
     then decide what to do differently with the run.  Scripts are
     just going to disconnect and let the target deal with it,
     according to how it's been instructed previously via
     disconnected-tracing.  */
  if (current_trace_status ()->running)
    {
      process_tracepoint_on_disconnect ();

      if (current_trace_status ()->disconnected_tracing)
	{
	  if (!query (_("Trace is running and will "
			"continue after detach; detach anyway? ")))
	    error (_("Not confirmed."));
	}
      else
	{
	  if (!query (_("Trace is running but will "
			"stop on detach; detach anyway? ")))
	    error (_("Not confirmed."));
	}
    }
}

/* This function handles the details of what to do about an ongoing
   tracing run if the user has asked to detach or otherwise disconnect
   from the target.  */

void
disconnect_tracing (void)
{
  /* Also we want to be out of tfind mode, otherwise things can get
     confusing upon reconnection.  Just use these calls instead of
     full tfind_1 behavior because we're in the middle of detaching,
     and there's no point to updating current stack frame etc.  */
  trace_reset_local_state ();
}

/* Worker function for the various flavors of the tfind command.  */
void
tfind_1 (enum trace_find_type type, int num,
	 CORE_ADDR addr1, CORE_ADDR addr2,
	 int from_tty)
{
  int target_frameno = -1, target_tracept = -1;
  struct frame_id old_frame_id = null_frame_id;
  struct tracepoint *tp;
  struct ui_out *uiout = current_uiout;

  /* Only try to get the current stack frame if we have a chance of
     succeeding.  In particular, if we're trying to get a first trace
     frame while all threads are running, it's not going to succeed,
     so leave it with a default value and let the frame comparison
     below (correctly) decide to print out the source location of the
     trace frame.  */
  if (!(type == tfind_number && num == -1)
      && (has_stack_frames () || traceframe_number >= 0))
    old_frame_id = get_frame_id (get_current_frame ());

  target_frameno = target_trace_find (type, num, addr1, addr2,
				      &target_tracept);
  
  if (type == tfind_number
      && num == -1
      && target_frameno == -1)
    {
      /* We told the target to get out of tfind mode, and it did.  */
    }
  else if (target_frameno == -1)
    {
      /* A request for a non-existent trace frame has failed.
	 Our response will be different, depending on FROM_TTY:

	 If FROM_TTY is true, meaning that this command was 
	 typed interactively by the user, then give an error
	 and DO NOT change the state of traceframe_number etc.

	 However if FROM_TTY is false, meaning that we're either
	 in a script, a loop, or a user-defined command, then 
	 DON'T give an error, but DO change the state of
	 traceframe_number etc. to invalid.

	 The rationalle is that if you typed the command, you
	 might just have committed a typo or something, and you'd
	 like to NOT lose your current debugging state.  However
	 if you're in a user-defined command or especially in a
	 loop, then you need a way to detect that the command
	 failed WITHOUT aborting.  This allows you to write
	 scripts that search thru the trace buffer until the end,
	 and then continue on to do something else.  */
  
      if (from_tty)
	error (_("Target failed to find requested trace frame."));
      else
	{
	  if (info_verbose)
	    printf_filtered ("End of trace buffer.\n");
#if 0 /* dubious now?  */
	  /* The following will not recurse, since it's
	     special-cased.  */
	  trace_find_command ("-1", from_tty);
#endif
	}
    }
  
  tp = get_tracepoint_by_number_on_target (target_tracept);

  reinit_frame_cache ();
  target_dcache_invalidate ();

  set_tracepoint_num (tp ? tp->base.number : target_tracept);

  if (target_frameno != get_traceframe_number ())
    observer_notify_traceframe_changed (target_frameno, tracepoint_number);

  set_current_traceframe (target_frameno);

  if (target_frameno == -1)
    set_traceframe_context (NULL);
  else
    set_traceframe_context (get_current_frame ());

  if (traceframe_number >= 0)
    {
      /* Use different branches for MI and CLI to make CLI messages
	 i18n-eable.  */
      if (ui_out_is_mi_like_p (uiout))
	{
	  ui_out_field_string (uiout, "found", "1");
	  ui_out_field_int (uiout, "tracepoint", tracepoint_number);
	  ui_out_field_int (uiout, "traceframe", traceframe_number);
	}
      else
	{
	  printf_unfiltered (_("Found trace frame %d, tracepoint %d\n"),
			     traceframe_number, tracepoint_number);
	}
    }
  else
    {
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string (uiout, "found", "0");
      else if (type == tfind_number && num == -1)
	printf_unfiltered (_("No longer looking at any trace frame\n"));
      else /* This case may never occur, check.  */
	printf_unfiltered (_("No trace frame found\n"));
    }

  /* If we're in nonstop mode and getting out of looking at trace
     frames, there won't be any current frame to go back to and
     display.  */
  if (from_tty
      && (has_stack_frames () || traceframe_number >= 0))
    {
      enum print_what print_what;

      /* NOTE: in imitation of the step command, try to determine
         whether we have made a transition from one function to
         another.  If so, we'll print the "stack frame" (ie. the new
         function and it's arguments) -- otherwise we'll just show the
         new source line.  */

      if (frame_id_eq (old_frame_id,
		       get_frame_id (get_current_frame ())))
	print_what = SRC_LINE;
      else
	print_what = SRC_AND_LOC;

      print_stack_frame (get_selected_frame (NULL), 1, print_what, 1);
      do_displays ();
    }
}

/* trace_find_command takes a trace frame number n, 
   sends "QTFrame:<n>" to the target, 
   and accepts a reply that may contain several optional pieces
   of information: a frame number, a tracepoint number, and an
   indication of whether this is a trap frame or a stepping frame.

   The minimal response is just "OK" (which indicates that the 
   target does not give us a frame number or a tracepoint number).
   Instead of that, the target may send us a string containing
   any combination of:
   F<hexnum>    (gives the selected frame number)
   T<hexnum>    (gives the selected tracepoint number)
 */

/* tfind command */
static void
trace_find_command (char *args, int from_tty)
{ /* This should only be called with a numeric argument.  */
  int frameno = -1;

  if (current_trace_status ()->running
      && current_trace_status ()->filename == NULL)
    error (_("May not look at trace frames while trace is running."));
  
  if (args == 0 || *args == 0)
    { /* TFIND with no args means find NEXT trace frame.  */
      if (traceframe_number == -1)
	frameno = 0;	/* "next" is first one.  */
        else
	frameno = traceframe_number + 1;
    }
  else if (0 == strcmp (args, "-"))
    {
      if (traceframe_number == -1)
	error (_("not debugging trace buffer"));
      else if (from_tty && traceframe_number == 0)
	error (_("already at start of trace buffer"));
      
      frameno = traceframe_number - 1;
      }
  /* A hack to work around eval's need for fp to have been collected.  */
  else if (0 == strcmp (args, "-1"))
    frameno = -1;
  else
    frameno = parse_and_eval_long (args);

  if (frameno < -1)
    error (_("invalid input (%d is less than zero)"), frameno);

  tfind_1 (tfind_number, frameno, 0, 0, from_tty);
}

/* tfind end */
static void
trace_find_end_command (char *args, int from_tty)
{
  trace_find_command ("-1", from_tty);
}

/* tfind start */
static void
trace_find_start_command (char *args, int from_tty)
{
  trace_find_command ("0", from_tty);
}

/* tfind pc command */
static void
trace_find_pc_command (char *args, int from_tty)
{
  CORE_ADDR pc;

  if (current_trace_status ()->running
      && current_trace_status ()->filename == NULL)
    error (_("May not look at trace frames while trace is running."));

  if (args == 0 || *args == 0)
    pc = regcache_read_pc (get_current_regcache ());
  else
    pc = parse_and_eval_address (args);

  tfind_1 (tfind_pc, 0, pc, 0, from_tty);
}

/* tfind tracepoint command */
static void
trace_find_tracepoint_command (char *args, int from_tty)
{
  int tdp;
  struct tracepoint *tp;

  if (current_trace_status ()->running
      && current_trace_status ()->filename == NULL)
    error (_("May not look at trace frames while trace is running."));

  if (args == 0 || *args == 0)
    {
      if (tracepoint_number == -1)
	error (_("No current tracepoint -- please supply an argument."));
      else
	tdp = tracepoint_number;	/* Default is current TDP.  */
    }
  else
    tdp = parse_and_eval_long (args);

  /* If we have the tracepoint on hand, use the number that the
     target knows about (which may be different if we disconnected
     and reconnected).  */
  tp = get_tracepoint (tdp);
  if (tp)
    tdp = tp->number_on_target;

  tfind_1 (tfind_tp, tdp, 0, 0, from_tty);
}

/* TFIND LINE command:

   This command will take a sourceline for argument, just like BREAK
   or TRACE (ie. anything that "decode_line_1" can handle).

   With no argument, this command will find the next trace frame 
   corresponding to a source line OTHER THAN THE CURRENT ONE.  */

static void
trace_find_line_command (char *args, int from_tty)
{
  static CORE_ADDR start_pc, end_pc;
  struct symtabs_and_lines sals;
  struct symtab_and_line sal;
  struct cleanup *old_chain;

  if (current_trace_status ()->running
      && current_trace_status ()->filename == NULL)
    error (_("May not look at trace frames while trace is running."));

  if (args == 0 || *args == 0)
    {
      sal = find_pc_line (get_frame_pc (get_current_frame ()), 0);
      sals.nelts = 1;
      sals.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));
      sals.sals[0] = sal;
    }
  else
    {
      sals = decode_line_with_current_source (args, DECODE_LINE_FUNFIRSTLINE);
      sal = sals.sals[0];
    }
  
  old_chain = make_cleanup (xfree, sals.sals);
  if (sal.symtab == 0)
    error (_("No line number information available."));

  if (sal.line > 0 && find_line_pc_range (sal, &start_pc, &end_pc))
    {
      if (start_pc == end_pc)
  	{
	  printf_filtered ("Line %d of \"%s\"",
			   sal.line,
			   symtab_to_filename_for_display (sal.symtab));
	  wrap_here ("  ");
	  printf_filtered (" is at address ");
	  print_address (get_current_arch (), start_pc, gdb_stdout);
	  wrap_here ("  ");
	  printf_filtered (" but contains no code.\n");
	  sal = find_pc_line (start_pc, 0);
	  if (sal.line > 0
	      && find_line_pc_range (sal, &start_pc, &end_pc)
	      && start_pc != end_pc)
	    printf_filtered ("Attempting to find line %d instead.\n",
			     sal.line);
  	  else
	    error (_("Cannot find a good line."));
  	}
      }
    else
    /* Is there any case in which we get here, and have an address
       which the user would want to see?  If we have debugging
       symbols and no line numbers?  */
    error (_("Line number %d is out of range for \"%s\"."),
	   sal.line, symtab_to_filename_for_display (sal.symtab));

  /* Find within range of stated line.  */
  if (args && *args)
    tfind_1 (tfind_range, 0, start_pc, end_pc - 1, from_tty);
  else
    tfind_1 (tfind_outside, 0, start_pc, end_pc - 1, from_tty);
  do_cleanups (old_chain);
}

/* tfind range command */
static void
trace_find_range_command (char *args, int from_tty)
{
  static CORE_ADDR start, stop;
  char *tmp;

  if (current_trace_status ()->running
      && current_trace_status ()->filename == NULL)
    error (_("May not look at trace frames while trace is running."));

  if (args == 0 || *args == 0)
    { /* XXX FIXME: what should default behavior be?  */
      printf_filtered ("Usage: tfind range <startaddr>,<endaddr>\n");
      return;
    }

  if (0 != (tmp = strchr (args, ',')))
    {
      *tmp++ = '\0';	/* Terminate start address.  */
      tmp = skip_spaces (tmp);
      start = parse_and_eval_address (args);
      stop = parse_and_eval_address (tmp);
    }
  else
    {			/* No explicit end address?  */
      start = parse_and_eval_address (args);
      stop = start + 1;	/* ??? */
    }

  tfind_1 (tfind_range, 0, start, stop, from_tty);
}

/* tfind outside command */
static void
trace_find_outside_command (char *args, int from_tty)
{
  CORE_ADDR start, stop;
  char *tmp;

  if (current_trace_status ()->running
      && current_trace_status ()->filename == NULL)
    error (_("May not look at trace frames while trace is running."));

  if (args == 0 || *args == 0)
    { /* XXX FIXME: what should default behavior be?  */
      printf_filtered ("Usage: tfind outside <startaddr>,<endaddr>\n");
      return;
    }

  if (0 != (tmp = strchr (args, ',')))
    {
      *tmp++ = '\0';	/* Terminate start address.  */
      tmp = skip_spaces (tmp);
      start = parse_and_eval_address (args);
      stop = parse_and_eval_address (tmp);
    }
  else
    {			/* No explicit end address?  */
      start = parse_and_eval_address (args);
      stop = start + 1;	/* ??? */
    }

  tfind_1 (tfind_outside, 0, start, stop, from_tty);
}

/* info scope command: list the locals for a scope.  */
static void
scope_info (char *args, int from_tty)
{
  struct symtabs_and_lines sals;
  struct symbol *sym;
  struct minimal_symbol *msym;
  struct block *block;
  const char *symname;
  char *save_args = args;
  struct block_iterator iter;
  int j, count = 0;
  struct gdbarch *gdbarch;
  int regno;

  if (args == 0 || *args == 0)
    error (_("requires an argument (function, "
	     "line or *addr) to define a scope"));

  sals = decode_line_1 (&args, DECODE_LINE_FUNFIRSTLINE, NULL, 0);
  if (sals.nelts == 0)
    return;		/* Presumably decode_line_1 has already warned.  */

  /* Resolve line numbers to PC.  */
  resolve_sal_pc (&sals.sals[0]);
  block = block_for_pc (sals.sals[0].pc);

  while (block != 0)
    {
      QUIT;			/* Allow user to bail out with ^C.  */
      ALL_BLOCK_SYMBOLS (block, iter, sym)
	{
	  QUIT;			/* Allow user to bail out with ^C.  */
	  if (count == 0)
	    printf_filtered ("Scope for %s:\n", save_args);
	  count++;

	  symname = SYMBOL_PRINT_NAME (sym);
	  if (symname == NULL || *symname == '\0')
	    continue;		/* Probably botched, certainly useless.  */

	  gdbarch = get_objfile_arch (SYMBOL_SYMTAB (sym)->objfile);

	  printf_filtered ("Symbol %s is ", symname);

	  if (SYMBOL_COMPUTED_OPS (sym) != NULL)
	    SYMBOL_COMPUTED_OPS (sym)->describe_location (sym,
							  BLOCK_START (block),
							  gdb_stdout);
	  else
	    {
	      switch (SYMBOL_CLASS (sym))
		{
		default:
		case LOC_UNDEF:	/* Messed up symbol?  */
		  printf_filtered ("a bogus symbol, class %d.\n",
				   SYMBOL_CLASS (sym));
		  count--;		/* Don't count this one.  */
		  continue;
		case LOC_CONST:
		  printf_filtered ("a constant with value %s (%s)",
				   plongest (SYMBOL_VALUE (sym)),
				   hex_string (SYMBOL_VALUE (sym)));
		  break;
		case LOC_CONST_BYTES:
		  printf_filtered ("constant bytes: ");
		  if (SYMBOL_TYPE (sym))
		    for (j = 0; j < TYPE_LENGTH (SYMBOL_TYPE (sym)); j++)
		      fprintf_filtered (gdb_stdout, " %02x",
					(unsigned) SYMBOL_VALUE_BYTES (sym)[j]);
		  break;
		case LOC_STATIC:
		  printf_filtered ("in static storage at address ");
		  printf_filtered ("%s", paddress (gdbarch,
						   SYMBOL_VALUE_ADDRESS (sym)));
		  break;
		case LOC_REGISTER:
		  /* GDBARCH is the architecture associated with the objfile
		     the symbol is defined in; the target architecture may be
		     different, and may provide additional registers.  However,
		     we do not know the target architecture at this point.
		     We assume the objfile architecture will contain all the
		     standard registers that occur in debug info in that
		     objfile.  */
		  regno = SYMBOL_REGISTER_OPS (sym)->register_number (sym,
								      gdbarch);

		  if (SYMBOL_IS_ARGUMENT (sym))
		    printf_filtered ("an argument in register $%s",
				     gdbarch_register_name (gdbarch, regno));
		  else
		    printf_filtered ("a local variable in register $%s",
				     gdbarch_register_name (gdbarch, regno));
		  break;
		case LOC_ARG:
		  printf_filtered ("an argument at stack/frame offset %s",
				   plongest (SYMBOL_VALUE (sym)));
		  break;
		case LOC_LOCAL:
		  printf_filtered ("a local variable at frame offset %s",
				   plongest (SYMBOL_VALUE (sym)));
		  break;
		case LOC_REF_ARG:
		  printf_filtered ("a reference argument at offset %s",
				   plongest (SYMBOL_VALUE (sym)));
		  break;
		case LOC_REGPARM_ADDR:
		  /* Note comment at LOC_REGISTER.  */
		  regno = SYMBOL_REGISTER_OPS (sym)->register_number (sym,
								      gdbarch);
		  printf_filtered ("the address of an argument, in register $%s",
				   gdbarch_register_name (gdbarch, regno));
		  break;
		case LOC_TYPEDEF:
		  printf_filtered ("a typedef.\n");
		  continue;
		case LOC_LABEL:
		  printf_filtered ("a label at address ");
		  printf_filtered ("%s", paddress (gdbarch,
						   SYMBOL_VALUE_ADDRESS (sym)));
		  break;
		case LOC_BLOCK:
		  printf_filtered ("a function at address ");
		  printf_filtered ("%s",
				   paddress (gdbarch, BLOCK_START (SYMBOL_BLOCK_VALUE (sym))));
		  break;
		case LOC_UNRESOLVED:
		  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym),
						NULL, NULL);
		  if (msym == NULL)
		    printf_filtered ("Unresolved Static");
		  else
		    {
		      printf_filtered ("static storage at address ");
		      printf_filtered ("%s",
				       paddress (gdbarch,
						 SYMBOL_VALUE_ADDRESS (msym)));
		    }
		  break;
		case LOC_OPTIMIZED_OUT:
		  printf_filtered ("optimized out.\n");
		  continue;
		case LOC_COMPUTED:
		  gdb_assert_not_reached (_("LOC_COMPUTED variable missing a method"));
		}
	    }
	  if (SYMBOL_TYPE (sym))
	    printf_filtered (", length %d.\n",
			     TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym))));
	}
      if (BLOCK_FUNCTION (block))
	break;
      else
	block = BLOCK_SUPERBLOCK (block);
    }
  if (count <= 0)
    printf_filtered ("Scope for %s contains no locals or arguments.\n",
		     save_args);
}

/* Helper for trace_dump_command.  Dump the action list starting at
   ACTION.  STEPPING_ACTIONS is true if we're iterating over the
   actions of the body of a while-stepping action.  STEPPING_FRAME is
   set if the current traceframe was determined to be a while-stepping
   traceframe.  */

static void
trace_dump_actions (struct command_line *action,
		    int stepping_actions, int stepping_frame,
		    int from_tty)
{
  const char *action_exp, *next_comma;

  for (; action != NULL; action = action->next)
    {
      struct cmd_list_element *cmd;

      QUIT;			/* Allow user to bail out with ^C.  */
      action_exp = action->line;
      action_exp = skip_spaces_const (action_exp);

      /* The collection actions to be done while stepping are
         bracketed by the commands "while-stepping" and "end".  */

      if (*action_exp == '#')	/* comment line */
	continue;

      cmd = lookup_cmd (&action_exp, cmdlist, "", -1, 1);
      if (cmd == 0)
	error (_("Bad action list item: %s"), action_exp);

      if (cmd_cfunc_eq (cmd, while_stepping_pseudocommand))
	{
	  int i;

	  for (i = 0; i < action->body_count; ++i)
	    trace_dump_actions (action->body_list[i],
				1, stepping_frame, from_tty);
	}
      else if (cmd_cfunc_eq (cmd, collect_pseudocommand))
	{
	  /* Display the collected data.
	     For the trap frame, display only what was collected at
	     the trap.  Likewise for stepping frames, display only
	     what was collected while stepping.  This means that the
	     two boolean variables, STEPPING_FRAME and
	     STEPPING_ACTIONS should be equal.  */
	  if (stepping_frame == stepping_actions)
	    {
	      char *cmd = NULL;
	      struct cleanup *old_chain
		= make_cleanup (free_current_contents, &cmd);
	      int trace_string = 0;

	      if (*action_exp == '/')
		action_exp = decode_agent_options (action_exp, &trace_string);

	      do
		{		/* Repeat over a comma-separated list.  */
		  QUIT;		/* Allow user to bail out with ^C.  */
		  if (*action_exp == ',')
		    action_exp++;
		  action_exp = skip_spaces_const (action_exp);

		  next_comma = strchr (action_exp, ',');

		  if (0 == strncasecmp (action_exp, "$reg", 4))
		    registers_info (NULL, from_tty);
		  else if (0 == strncasecmp (action_exp, "$_ret", 5))
		    ;
		  else if (0 == strncasecmp (action_exp, "$loc", 4))
		    locals_info (NULL, from_tty);
		  else if (0 == strncasecmp (action_exp, "$arg", 4))
		    args_info (NULL, from_tty);
		  else
		    {		/* variable */
		      if (next_comma != NULL)
			{
			  size_t len = next_comma - action_exp;

			  cmd = xrealloc (cmd, len + 1);
			  memcpy (cmd, action_exp, len);
			  cmd[len] = 0;
			}
		      else
			{
			  size_t len = strlen (action_exp);

			  cmd = xrealloc (cmd, len + 1);
			  memcpy (cmd, action_exp, len + 1);
			}

		      printf_filtered ("%s = ", cmd);
		      output_command_const (cmd, from_tty);
		      printf_filtered ("\n");
		    }
		  action_exp = next_comma;
		}
	      while (action_exp && *action_exp == ',');

	      do_cleanups (old_chain);
	    }
	}
    }
}

/* Return bp_location of the tracepoint associated with the current
   traceframe.  Set *STEPPING_FRAME_P to 1 if the current traceframe
   is a stepping traceframe.  */

struct bp_location *
get_traceframe_location (int *stepping_frame_p)
{
  struct tracepoint *t;
  struct bp_location *tloc;
  struct regcache *regcache;

  if (tracepoint_number == -1)
    error (_("No current trace frame."));

  t = get_tracepoint (tracepoint_number);

  if (t == NULL)
    error (_("No known tracepoint matches 'current' tracepoint #%d."),
	   tracepoint_number);

  /* The current frame is a trap frame if the frame PC is equal to the
     tracepoint PC.  If not, then the current frame was collected
     during single-stepping.  */
  regcache = get_current_regcache ();

  /* If the traceframe's address matches any of the tracepoint's
     locations, assume it is a direct hit rather than a while-stepping
     frame.  (FIXME this is not reliable, should record each frame's
     type.)  */
  for (tloc = t->base.loc; tloc; tloc = tloc->next)
    if (tloc->address == regcache_read_pc (regcache))
      {
	*stepping_frame_p = 0;
	return tloc;
      }

  /* If this is a stepping frame, we don't know which location
     triggered.  The first is as good (or bad) a guess as any...  */
  *stepping_frame_p = 1;
  return t->base.loc;
}

/* Return all the actions, including default collect, of a tracepoint
   T.  It constructs cleanups into the chain, and leaves the caller to
   handle them (call do_cleanups).  */

static struct command_line *
all_tracepoint_actions_and_cleanup (struct breakpoint *t)
{
  struct command_line *actions;

  actions = breakpoint_commands (t);

  /* If there are default expressions to collect, make up a collect
     action and prepend to the action list to encode.  Note that since
     validation is per-tracepoint (local var "xyz" might be valid for
     one tracepoint and not another, etc), we make up the action on
     the fly, and don't cache it.  */
  if (*default_collect)
    {
      struct command_line *default_collect_action;
      char *default_collect_line;

      default_collect_line = xstrprintf ("collect %s", default_collect);
      make_cleanup (xfree, default_collect_line);

      validate_actionline (default_collect_line, t);
      default_collect_action = xmalloc (sizeof (struct command_line));
      make_cleanup (xfree, default_collect_action);
      default_collect_action->next = actions;
      default_collect_action->line = default_collect_line;
      actions = default_collect_action;
    }

  return actions;
}

/* The tdump command.  */

static void
trace_dump_command (char *args, int from_tty)
{
  int stepping_frame = 0;
  struct bp_location *loc;
  struct cleanup *old_chain;
  struct command_line *actions;

  /* This throws an error is not inspecting a trace frame.  */
  loc = get_traceframe_location (&stepping_frame);

  printf_filtered ("Data collected at tracepoint %d, trace frame %d:\n",
		   tracepoint_number, traceframe_number);

  old_chain = make_cleanup (null_cleanup, NULL);

  /* This command only makes sense for the current frame, not the
     selected frame.  */
  make_cleanup_restore_current_thread ();
  select_frame (get_current_frame ());

  actions = all_tracepoint_actions_and_cleanup (loc->owner);

  trace_dump_actions (actions, 0, stepping_frame, from_tty);

  do_cleanups (old_chain);
}

/* Encode a piece of a tracepoint's source-level definition in a form
   that is suitable for both protocol and saving in files.  */
/* This version does not do multiple encodes for long strings; it should
   return an offset to the next piece to encode.  FIXME  */

extern int
encode_source_string (int tpnum, ULONGEST addr,
		      char *srctype, char *src, char *buf, int buf_size)
{
  if (80 + strlen (srctype) > buf_size)
    error (_("Buffer too small for source encoding"));
  sprintf (buf, "%x:%s:%s:%x:%x:",
	   tpnum, phex_nz (addr, sizeof (addr)),
	   srctype, 0, (int) strlen (src));
  if (strlen (buf) + strlen (src) * 2 >= buf_size)
    error (_("Source string too long for buffer"));
  bin2hex ((gdb_byte *) src, buf + strlen (buf), 0);
  return -1;
}

/* Free trace file writer.  */

static void
trace_file_writer_xfree (void *arg)
{
  struct trace_file_writer *writer = arg;

  writer->ops->dtor (writer);
  xfree (writer);
}

/* TFILE trace writer.  */

struct tfile_trace_file_writer
{
  struct trace_file_writer base;

  /* File pointer to tfile trace file.  */
  FILE *fp;
  /* Path name of the tfile trace file.  */
  char *pathname;
};

/* This is the implementation of trace_file_write_ops method
   target_save.  We just call the generic target
   target_save_trace_data to do target-side saving.  */

static int
tfile_target_save (struct trace_file_writer *self,
		   const char *filename)
{
  int err = target_save_trace_data (filename);

  return (err >= 0);
}

/* This is the implementation of trace_file_write_ops method
   dtor.  */

static void
tfile_dtor (struct trace_file_writer *self)
{
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;

  xfree (writer->pathname);

  if (writer->fp != NULL)
    fclose (writer->fp);
}

/* This is the implementation of trace_file_write_ops method
   start.  It creates the trace file FILENAME and registers some
   cleanups.  */

static void
tfile_start (struct trace_file_writer *self, const char *filename)
{
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;

  writer->pathname = tilde_expand (filename);
  writer->fp = gdb_fopen_cloexec (writer->pathname, "wb");
  if (writer->fp == NULL)
    error (_("Unable to open file '%s' for saving trace data (%s)"),
	   writer->pathname, safe_strerror (errno));
}

/* This is the implementation of trace_file_write_ops method
   write_header.  Write the TFILE header.  */

static void
tfile_write_header (struct trace_file_writer *self)
{
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;
  int written;

  /* Write a file header, with a high-bit-set char to indicate a
     binary file, plus a hint as what this file is, and a version
     number in case of future needs.  */
  written = fwrite ("\x7fTRACE0\n", 8, 1, writer->fp);
  if (written < 1)
    perror_with_name (writer->pathname);
}

/* This is the implementation of trace_file_write_ops method
   write_regblock_type.  Write the size of register block.  */

static void
tfile_write_regblock_type (struct trace_file_writer *self, int size)
{
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;

  fprintf (writer->fp, "R %x\n", size);
}

/* This is the implementation of trace_file_write_ops method
   write_status.  */

static void
tfile_write_status (struct trace_file_writer *self,
		    struct trace_status *ts)
{
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;

  fprintf (writer->fp, "status %c;%s",
	   (ts->running ? '1' : '0'), stop_reason_names[ts->stop_reason]);
  if (ts->stop_reason == tracepoint_error
      || ts->stop_reason == tstop_command)
    {
      char *buf = (char *) alloca (strlen (ts->stop_desc) * 2 + 1);

      bin2hex ((gdb_byte *) ts->stop_desc, buf, 0);
      fprintf (writer->fp, ":%s", buf);
    }
  fprintf (writer->fp, ":%x", ts->stopping_tracepoint);
  if (ts->traceframe_count >= 0)
    fprintf (writer->fp, ";tframes:%x", ts->traceframe_count);
  if (ts->traceframes_created >= 0)
    fprintf (writer->fp, ";tcreated:%x", ts->traceframes_created);
  if (ts->buffer_free >= 0)
    fprintf (writer->fp, ";tfree:%x", ts->buffer_free);
  if (ts->buffer_size >= 0)
    fprintf (writer->fp, ";tsize:%x", ts->buffer_size);
  if (ts->disconnected_tracing)
    fprintf (writer->fp, ";disconn:%x", ts->disconnected_tracing);
  if (ts->circular_buffer)
    fprintf (writer->fp, ";circular:%x", ts->circular_buffer);
  if (ts->start_time)
    {
      fprintf (writer->fp, ";starttime:%s",
      phex_nz (ts->start_time, sizeof (ts->start_time)));
    }
  if (ts->stop_time)
    {
      fprintf (writer->fp, ";stoptime:%s",
      phex_nz (ts->stop_time, sizeof (ts->stop_time)));
    }
  if (ts->notes != NULL)
    {
      char *buf = (char *) alloca (strlen (ts->notes) * 2 + 1);

      bin2hex ((gdb_byte *) ts->notes, buf, 0);
      fprintf (writer->fp, ";notes:%s", buf);
    }
  if (ts->user_name != NULL)
    {
      char *buf = (char *) alloca (strlen (ts->user_name) * 2 + 1);

      bin2hex ((gdb_byte *) ts->user_name, buf, 0);
      fprintf (writer->fp, ";username:%s", buf);
    }
  fprintf (writer->fp, "\n");
}

/* This is the implementation of trace_file_write_ops method
   write_uploaded_tsv.  */

static void
tfile_write_uploaded_tsv (struct trace_file_writer *self,
			  struct uploaded_tsv *utsv)
{
  char *buf = "";
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;

  if (utsv->name)
    {
      buf = (char *) xmalloc (strlen (utsv->name) * 2 + 1);
      bin2hex ((gdb_byte *) (utsv->name), buf, 0);
    }

  fprintf (writer->fp, "tsv %x:%s:%x:%s\n",
	   utsv->number, phex_nz (utsv->initial_value, 8),
	   utsv->builtin, buf);

  if (utsv->name)
    xfree (buf);
}

#define MAX_TRACE_UPLOAD 2000

/* This is the implementation of trace_file_write_ops method
   write_uploaded_tp.  */

static void
tfile_write_uploaded_tp (struct trace_file_writer *self,
			 struct uploaded_tp *utp)
{
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;
  int a;
  char *act;
  char buf[MAX_TRACE_UPLOAD];

  fprintf (writer->fp, "tp T%x:%s:%c:%x:%x",
	   utp->number, phex_nz (utp->addr, sizeof (utp->addr)),
	   (utp->enabled ? 'E' : 'D'), utp->step, utp->pass);
  if (utp->type == bp_fast_tracepoint)
    fprintf (writer->fp, ":F%x", utp->orig_size);
  if (utp->cond)
    fprintf (writer->fp,
	     ":X%x,%s", (unsigned int) strlen (utp->cond) / 2,
	     utp->cond);
  fprintf (writer->fp, "\n");
  for (a = 0; VEC_iterate (char_ptr, utp->actions, a, act); ++a)
    fprintf (writer->fp, "tp A%x:%s:%s\n",
	     utp->number, phex_nz (utp->addr, sizeof (utp->addr)), act);
  for (a = 0; VEC_iterate (char_ptr, utp->step_actions, a, act); ++a)
    fprintf (writer->fp, "tp S%x:%s:%s\n",
	     utp->number, phex_nz (utp->addr, sizeof (utp->addr)), act);
  if (utp->at_string)
    {
      encode_source_string (utp->number, utp->addr,
			    "at", utp->at_string, buf, MAX_TRACE_UPLOAD);
      fprintf (writer->fp, "tp Z%s\n", buf);
    }
  if (utp->cond_string)
    {
      encode_source_string (utp->number, utp->addr,
			    "cond", utp->cond_string,
			    buf, MAX_TRACE_UPLOAD);
      fprintf (writer->fp, "tp Z%s\n", buf);
    }
  for (a = 0; VEC_iterate (char_ptr, utp->cmd_strings, a, act); ++a)
    {
      encode_source_string (utp->number, utp->addr, "cmd", act,
			    buf, MAX_TRACE_UPLOAD);
      fprintf (writer->fp, "tp Z%s\n", buf);
    }
  fprintf (writer->fp, "tp V%x:%s:%x:%s\n",
	   utp->number, phex_nz (utp->addr, sizeof (utp->addr)),
	   utp->hit_count,
	   phex_nz (utp->traceframe_usage,
		    sizeof (utp->traceframe_usage)));
}

/* This is the implementation of trace_file_write_ops method
   write_definition_end.  */

static void
tfile_write_definition_end (struct trace_file_writer *self)
{
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;

  fprintf (writer->fp, "\n");
}

/* This is the implementation of trace_file_write_ops method
   write_raw_data.  */

static void
tfile_write_raw_data (struct trace_file_writer *self, gdb_byte *buf,
		      LONGEST len)
{
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;

  if (fwrite (buf, len, 1, writer->fp) < 1)
    perror_with_name (writer->pathname);
}

/* This is the implementation of trace_file_write_ops method
   end.  */

static void
tfile_end (struct trace_file_writer *self)
{
  struct tfile_trace_file_writer *writer
    = (struct tfile_trace_file_writer *) self;
  uint32_t gotten = 0;

  /* Mark the end of trace data.  */
  if (fwrite (&gotten, 4, 1, writer->fp) < 1)
    perror_with_name (writer->pathname);
}

/* Operations to write trace buffers into TFILE format.  */

static const struct trace_file_write_ops tfile_write_ops =
{
  tfile_dtor,
  tfile_target_save,
  tfile_start,
  tfile_write_header,
  tfile_write_regblock_type,
  tfile_write_status,
  tfile_write_uploaded_tsv,
  tfile_write_uploaded_tp,
  tfile_write_definition_end,
  tfile_write_raw_data,
  NULL,
  tfile_end,
};

/* Helper macros.  */

#define TRACE_WRITE_R_BLOCK(writer, buf, size)	\
  writer->ops->frame_ops->write_r_block ((writer), (buf), (size))
#define TRACE_WRITE_M_BLOCK_HEADER(writer, addr, size)		  \
  writer->ops->frame_ops->write_m_block_header ((writer), (addr), \
						(size))
#define TRACE_WRITE_M_BLOCK_MEMORY(writer, buf, size)	  \
  writer->ops->frame_ops->write_m_block_memory ((writer), (buf), \
						(size))
#define TRACE_WRITE_V_BLOCK(writer, num, val)	\
  writer->ops->frame_ops->write_v_block ((writer), (num), (val))

/* Save tracepoint data to file named FILENAME through WRITER.  WRITER
   determines the trace file format.  If TARGET_DOES_SAVE is non-zero,
   the save is performed on the target, otherwise GDB obtains all trace
   data and saves it locally.  */

static void
trace_save (const char *filename, struct trace_file_writer *writer,
	    int target_does_save)
{
  struct trace_status *ts = current_trace_status ();
  int status;
  struct uploaded_tp *uploaded_tps = NULL, *utp;
  struct uploaded_tsv *uploaded_tsvs = NULL, *utsv;

  ULONGEST offset = 0;
  gdb_byte buf[MAX_TRACE_UPLOAD];
#define MAX_TRACE_UPLOAD 2000
  int written;
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());

  /* If the target is to save the data to a file on its own, then just
     send the command and be done with it.  */
  if (target_does_save)
    {
      if (!writer->ops->target_save (writer, filename))
	error (_("Target failed to save trace data to '%s'."),
	       filename);
      return;
    }

  /* Get the trace status first before opening the file, so if the
     target is losing, we can get out without touching files.  */
  status = target_get_trace_status (ts);

  writer->ops->start (writer, filename);

  writer->ops->write_header (writer);

  /* Write descriptive info.  */

  /* Write out the size of a register block.  */
  writer->ops->write_regblock_type (writer, trace_regblock_size);

  /* Write out status of the tracing run (aka "tstatus" info).  */
  writer->ops->write_status (writer, ts);

  /* Note that we want to upload tracepoints and save those, rather
     than simply writing out the local ones, because the user may have
     changed tracepoints in GDB in preparation for a future tracing
     run, or maybe just mass-deleted all types of breakpoints as part
     of cleaning up.  So as not to contaminate the session, leave the
     data in its uploaded form, don't make into real tracepoints.  */

  /* Get trace state variables first, they may be checked when parsing
     uploaded commands.  */

  target_upload_trace_state_variables (&uploaded_tsvs);

  for (utsv = uploaded_tsvs; utsv; utsv = utsv->next)
    writer->ops->write_uploaded_tsv (writer, utsv);

  free_uploaded_tsvs (&uploaded_tsvs);

  target_upload_tracepoints (&uploaded_tps);

  for (utp = uploaded_tps; utp; utp = utp->next)
    target_get_tracepoint_status (NULL, utp);

  for (utp = uploaded_tps; utp; utp = utp->next)
    writer->ops->write_uploaded_tp (writer, utp);

  free_uploaded_tps (&uploaded_tps);

  /* Mark the end of the definition section.  */
  writer->ops->write_definition_end (writer);

  /* Get and write the trace data proper.  */
  while (1)
    {
      LONGEST gotten = 0;

      /* The writer supports writing the contents of trace buffer
	  directly to trace file.  Don't parse the contents of trace
	  buffer.  */
      if (writer->ops->write_trace_buffer != NULL)
	{
	  /* We ask for big blocks, in the hopes of efficiency, but
	     will take less if the target has packet size limitations
	     or some such.  */
	  gotten = target_get_raw_trace_data (buf, offset,
					      MAX_TRACE_UPLOAD);
	  if (gotten < 0)
	    error (_("Failure to get requested trace buffer data"));
	  /* No more data is forthcoming, we're done.  */
	  if (gotten == 0)
	    break;

	  writer->ops->write_trace_buffer (writer, buf, gotten);

	  offset += gotten;
	}
      else
	{
	  uint16_t tp_num;
	  uint32_t tf_size;
	  /* Parse the trace buffers according to how data are stored
	     in trace buffer in GDBserver.  */

	  gotten = target_get_raw_trace_data (buf, offset, 6);

	  if (gotten == 0)
	    break;

	  /* Read the first six bytes in, which is the tracepoint
	     number and trace frame size.  */
	  tp_num = (uint16_t)
	    extract_unsigned_integer (&buf[0], 2, byte_order);

	  tf_size = (uint32_t)
	    extract_unsigned_integer (&buf[2], 4, byte_order);

	  writer->ops->frame_ops->start (writer, tp_num);
	  gotten = 6;

	  if (tf_size > 0)
	    {
	      unsigned int block;

	      offset += 6;

	      for (block = 0; block < tf_size; )
		{
		  gdb_byte block_type;

		  /* We'll fetch one block each time, in order to
		     handle the extremely large 'M' block.  We first
		     fetch one byte to get the type of the block.  */
		  gotten = target_get_raw_trace_data (buf, offset, 1);
		  if (gotten < 1)
		    error (_("Failure to get requested trace buffer data"));

		  gotten = 1;
		  block += 1;
		  offset += 1;

		  block_type = buf[0];
		  switch (block_type)
		    {
		    case 'R':
		      gotten
			= target_get_raw_trace_data (buf, offset,
						     trace_regblock_size);
		      if (gotten < trace_regblock_size)
			error (_("Failure to get requested trace"
				 " buffer data"));

		      TRACE_WRITE_R_BLOCK (writer, buf,
					   trace_regblock_size);
		      break;
		    case 'M':
		      {
			unsigned short mlen;
			ULONGEST addr;
			LONGEST t;
			int j;

			t = target_get_raw_trace_data (buf,offset, 10);
			if (t < 10)
			  error (_("Failure to get requested trace"
				   " buffer data"));

			offset += 10;
			block += 10;

			gotten = 0;
			addr = (ULONGEST)
			  extract_unsigned_integer (buf, 8,
						    byte_order);
			mlen = (unsigned short)
			  extract_unsigned_integer (&buf[8], 2,
						    byte_order);

			TRACE_WRITE_M_BLOCK_HEADER (writer, addr,
						    mlen);

			/* The memory contents in 'M' block may be
			   very large.  Fetch the data from the target
			   and write them into file one by one.  */
			for (j = 0; j < mlen; )
			  {
			    unsigned int read_length;

			    if (mlen - j > MAX_TRACE_UPLOAD)
			      read_length = MAX_TRACE_UPLOAD;
			    else
			      read_length = mlen - j;

			    t = target_get_raw_trace_data (buf,
							   offset + j,
							   read_length);
			    if (t < read_length)
			      error (_("Failure to get requested"
				       " trace buffer data"));

			    TRACE_WRITE_M_BLOCK_MEMORY (writer, buf,
							read_length);

			    j += read_length;
			    gotten += read_length;
			  }

			break;
		      }
		    case 'V':
		      {
			int vnum;
			LONGEST val;

			gotten
			  = target_get_raw_trace_data (buf, offset,
						       12);
			if (gotten < 12)
			  error (_("Failure to get requested"
				   " trace buffer data"));

			vnum  = (int) extract_signed_integer (buf,
							      4,
							      byte_order);
			val
			  = extract_signed_integer (&buf[4], 8,
						    byte_order);

			TRACE_WRITE_V_BLOCK (writer, vnum, val);
		      }
		      break;
		    default:
		      error (_("Unknown block type '%c' (0x%x) in"
			       " trace frame"),
			     block_type, block_type);
		    }

		  block += gotten;
		  offset += gotten;
		}
	    }
	  else
	    offset += gotten;

	  writer->ops->frame_ops->end (writer);
	}
    }

  writer->ops->end (writer);
}

/* Return a trace writer for TFILE format.  */

static struct trace_file_writer *
tfile_trace_file_writer_new (void)
{
  struct tfile_trace_file_writer *writer
    = xmalloc (sizeof (struct tfile_trace_file_writer));

  writer->base.ops = &tfile_write_ops;
  writer->fp = NULL;
  writer->pathname = NULL;

  return (struct trace_file_writer *) writer;
}

static void
trace_save_command (char *args, int from_tty)
{
  int target_does_save = 0;
  char **argv;
  char *filename = NULL;
  struct cleanup *back_to;
  int generate_ctf = 0;
  struct trace_file_writer *writer = NULL;

  if (args == NULL)
    error_no_arg (_("file in which to save trace data"));

  argv = gdb_buildargv (args);
  back_to = make_cleanup_freeargv (argv);

  for (; *argv; ++argv)
    {
      if (strcmp (*argv, "-r") == 0)
	target_does_save = 1;
      if (strcmp (*argv, "-ctf") == 0)
	generate_ctf = 1;
      else if (**argv == '-')
	error (_("unknown option `%s'"), *argv);
      else
	filename = *argv;
    }

  if (!filename)
    error_no_arg (_("file in which to save trace data"));

  if (generate_ctf)
    writer = ctf_trace_file_writer_new ();
  else
    writer = tfile_trace_file_writer_new ();

  make_cleanup (trace_file_writer_xfree, writer);

  trace_save (filename, writer, target_does_save);

  if (from_tty)
    printf_filtered (_("Trace data saved to %s '%s'.\n"),
		     generate_ctf ? "directory" : "file", filename);

  do_cleanups (back_to);
}

/* Save the trace data to file FILENAME of tfile format.  */

void
trace_save_tfile (const char *filename, int target_does_save)
{
  struct trace_file_writer *writer;
  struct cleanup *back_to;

  writer = tfile_trace_file_writer_new ();
  back_to = make_cleanup (trace_file_writer_xfree, writer);
  trace_save (filename, writer, target_does_save);
  do_cleanups (back_to);
}

/* Save the trace data to dir DIRNAME of ctf format.  */

void
trace_save_ctf (const char *dirname, int target_does_save)
{
  struct trace_file_writer *writer;
  struct cleanup *back_to;

  writer = ctf_trace_file_writer_new ();
  back_to = make_cleanup (trace_file_writer_xfree, writer);

  trace_save (dirname, writer, target_does_save);
  do_cleanups (back_to);
}

/* Tell the target what to do with an ongoing tracing run if GDB
   disconnects for some reason.  */

static void
set_disconnected_tracing (char *args, int from_tty,
			  struct cmd_list_element *c)
{
  target_set_disconnected_tracing (disconnected_tracing);
}

static void
set_circular_trace_buffer (char *args, int from_tty,
			   struct cmd_list_element *c)
{
  target_set_circular_trace_buffer (circular_trace_buffer);
}

static void
set_trace_buffer_size (char *args, int from_tty,
			   struct cmd_list_element *c)
{
  target_set_trace_buffer_size (trace_buffer_size);
}

static void
set_trace_user (char *args, int from_tty,
		struct cmd_list_element *c)
{
  int ret;

  ret = target_set_trace_notes (trace_user, NULL, NULL);

  if (!ret)
    warning (_("Target does not support trace notes, user ignored"));
}

static void
set_trace_notes (char *args, int from_tty,
		 struct cmd_list_element *c)
{
  int ret;

  ret = target_set_trace_notes (NULL, trace_notes, NULL);

  if (!ret)
    warning (_("Target does not support trace notes, note ignored"));
}

static void
set_trace_stop_notes (char *args, int from_tty,
		      struct cmd_list_element *c)
{
  int ret;

  ret = target_set_trace_notes (NULL, NULL, trace_stop_notes);

  if (!ret)
    warning (_("Target does not support trace notes, stop note ignored"));
}

/* Convert the memory pointed to by mem into hex, placing result in buf.
 * Return a pointer to the last char put in buf (null)
 * "stolen" from sparc-stub.c
 */

static const char hexchars[] = "0123456789abcdef";

static char *
mem2hex (gdb_byte *mem, char *buf, int count)
{
  gdb_byte ch;

  while (count-- > 0)
    {
      ch = *mem++;

      *buf++ = hexchars[ch >> 4];
      *buf++ = hexchars[ch & 0xf];
    }

  *buf = 0;

  return buf;
}

int
get_traceframe_number (void)
{
  return traceframe_number;
}

int
get_tracepoint_number (void)
{
  return tracepoint_number;
}

/* Make the traceframe NUM be the current trace frame.  Does nothing
   if NUM is already current.  */

void
set_current_traceframe (int num)
{
  int newnum;

  if (traceframe_number == num)
    {
      /* Nothing to do.  */
      return;
    }

  newnum = target_trace_find (tfind_number, num, 0, 0, NULL);

  if (newnum != num)
    warning (_("could not change traceframe"));

  set_traceframe_num (newnum);

  /* Changing the traceframe changes our view of registers and of the
     frame chain.  */
  registers_changed ();

  clear_traceframe_info ();
}

/* Make the traceframe NUM be the current trace frame, and do nothing
   more.  */

void
set_traceframe_number (int num)
{
  traceframe_number = num;
}

/* A cleanup used when switching away and back from tfind mode.  */

struct current_traceframe_cleanup
{
  /* The traceframe we were inspecting.  */
  int traceframe_number;
};

static void
do_restore_current_traceframe_cleanup (void *arg)
{
  struct current_traceframe_cleanup *old = arg;

  set_current_traceframe (old->traceframe_number);
}

static void
restore_current_traceframe_cleanup_dtor (void *arg)
{
  struct current_traceframe_cleanup *old = arg;

  xfree (old);
}

struct cleanup *
make_cleanup_restore_current_traceframe (void)
{
  struct current_traceframe_cleanup *old;

  old = xmalloc (sizeof (struct current_traceframe_cleanup));
  old->traceframe_number = traceframe_number;

  return make_cleanup_dtor (do_restore_current_traceframe_cleanup, old,
			    restore_current_traceframe_cleanup_dtor);
}

struct cleanup *
make_cleanup_restore_traceframe_number (void)
{
  return make_cleanup_restore_integer (&traceframe_number);
}

/* Given a number and address, return an uploaded tracepoint with that
   number, creating if necessary.  */

struct uploaded_tp *
get_uploaded_tp (int num, ULONGEST addr, struct uploaded_tp **utpp)
{
  struct uploaded_tp *utp;

  for (utp = *utpp; utp; utp = utp->next)
    if (utp->number == num && utp->addr == addr)
      return utp;
  utp = (struct uploaded_tp *) xmalloc (sizeof (struct uploaded_tp));
  memset (utp, 0, sizeof (struct uploaded_tp));
  utp->number = num;
  utp->addr = addr;
  utp->actions = NULL;
  utp->step_actions = NULL;
  utp->cmd_strings = NULL;
  utp->next = *utpp;
  *utpp = utp;
  return utp;
}

static void
free_uploaded_tps (struct uploaded_tp **utpp)
{
  struct uploaded_tp *next_one;

  while (*utpp)
    {
      next_one = (*utpp)->next;
      xfree (*utpp);
      *utpp = next_one;
    }
}

/* Given a number and address, return an uploaded tracepoint with that
   number, creating if necessary.  */

struct uploaded_tsv *
get_uploaded_tsv (int num, struct uploaded_tsv **utsvp)
{
  struct uploaded_tsv *utsv;

  for (utsv = *utsvp; utsv; utsv = utsv->next)
    if (utsv->number == num)
      return utsv;
  utsv = (struct uploaded_tsv *) xmalloc (sizeof (struct uploaded_tsv));
  memset (utsv, 0, sizeof (struct uploaded_tsv));
  utsv->number = num;
  utsv->next = *utsvp;
  *utsvp = utsv;
  return utsv;
}

static void
free_uploaded_tsvs (struct uploaded_tsv **utsvp)
{
  struct uploaded_tsv *next_one;

  while (*utsvp)
    {
      next_one = (*utsvp)->next;
      xfree (*utsvp);
      *utsvp = next_one;
    }
}

/* FIXME this function is heuristic and will miss the cases where the
   conditional is semantically identical but differs in whitespace,
   such as "x == 0" vs "x==0".  */

static int
cond_string_is_same (char *str1, char *str2)
{
  if (str1 == NULL || str2 == NULL)
    return (str1 == str2);

  return (strcmp (str1, str2) == 0);
}

/* Look for an existing tracepoint that seems similar enough to the
   uploaded one.  Enablement isn't compared, because the user can
   toggle that freely, and may have done so in anticipation of the
   next trace run.  Return the location of matched tracepoint.  */

static struct bp_location *
find_matching_tracepoint_location (struct uploaded_tp *utp)
{
  VEC(breakpoint_p) *tp_vec = all_tracepoints ();
  int ix;
  struct breakpoint *b;
  struct bp_location *loc;

  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, b); ix++)
    {
      struct tracepoint *t = (struct tracepoint *) b;

      if (b->type == utp->type
	  && t->step_count == utp->step
	  && t->pass_count == utp->pass
	  && cond_string_is_same (t->base.cond_string, utp->cond_string)
	  /* FIXME also test actions.  */
	  )
	{
	  /* Scan the locations for an address match.  */
	  for (loc = b->loc; loc; loc = loc->next)
	    {
	      if (loc->address == utp->addr)
		return loc;
	    }
	}
    }
  return NULL;
}

/* Given a list of tracepoints uploaded from a target, attempt to
   match them up with existing tracepoints, and create new ones if not
   found.  */

void
merge_uploaded_tracepoints (struct uploaded_tp **uploaded_tps)
{
  struct uploaded_tp *utp;
  /* A set of tracepoints which are modified.  */
  VEC(breakpoint_p) *modified_tp = NULL;
  int ix;
  struct breakpoint *b;

  /* Look for GDB tracepoints that match up with our uploaded versions.  */
  for (utp = *uploaded_tps; utp; utp = utp->next)
    {
      struct bp_location *loc;
      struct tracepoint *t;

      loc = find_matching_tracepoint_location (utp);
      if (loc)
	{
	  int found = 0;

	  /* Mark this location as already inserted.  */
	  loc->inserted = 1;
	  t = (struct tracepoint *) loc->owner;
	  printf_filtered (_("Assuming tracepoint %d is same "
			     "as target's tracepoint %d at %s.\n"),
			   loc->owner->number, utp->number,
			   paddress (loc->gdbarch, utp->addr));

	  /* The tracepoint LOC->owner was modified (the location LOC
	     was marked as inserted in the target).  Save it in
	     MODIFIED_TP if not there yet.  The 'breakpoint-modified'
	     observers will be notified later once for each tracepoint
	     saved in MODIFIED_TP.  */
	  for (ix = 0;
	       VEC_iterate (breakpoint_p, modified_tp, ix, b);
	       ix++)
	    if (b == loc->owner)
	      {
		found = 1;
		break;
	      }
	  if (!found)
	    VEC_safe_push (breakpoint_p, modified_tp, loc->owner);
	}
      else
	{
	  t = create_tracepoint_from_upload (utp);
	  if (t)
	    printf_filtered (_("Created tracepoint %d for "
			       "target's tracepoint %d at %s.\n"),
			     t->base.number, utp->number,
			     paddress (get_current_arch (), utp->addr));
	  else
	    printf_filtered (_("Failed to create tracepoint for target's "
			       "tracepoint %d at %s, skipping it.\n"),
			     utp->number,
			     paddress (get_current_arch (), utp->addr));
	}
      /* Whether found or created, record the number used by the
	 target, to help with mapping target tracepoints back to their
	 counterparts here.  */
      if (t)
	t->number_on_target = utp->number;
    }

  /* Notify 'breakpoint-modified' observer that at least one of B's
     locations was changed.  */
  for (ix = 0; VEC_iterate (breakpoint_p, modified_tp, ix, b); ix++)
    observer_notify_breakpoint_modified (b);

  VEC_free (breakpoint_p, modified_tp);
  free_uploaded_tps (uploaded_tps);
}

/* Trace state variables don't have much to identify them beyond their
   name, so just use that to detect matches.  */

static struct trace_state_variable *
find_matching_tsv (struct uploaded_tsv *utsv)
{
  if (!utsv->name)
    return NULL;

  return find_trace_state_variable (utsv->name);
}

static struct trace_state_variable *
create_tsv_from_upload (struct uploaded_tsv *utsv)
{
  const char *namebase;
  char *buf;
  int try_num = 0;
  struct trace_state_variable *tsv;
  struct cleanup *old_chain;

  if (utsv->name)
    {
      namebase = utsv->name;
      buf = xstrprintf ("%s", namebase);
    }
  else
    {
      namebase = "__tsv";
      buf = xstrprintf ("%s_%d", namebase, try_num++);
    }

  /* Fish for a name that is not in use.  */
  /* (should check against all internal vars?)  */
  while (find_trace_state_variable (buf))
    {
      xfree (buf);
      buf = xstrprintf ("%s_%d", namebase, try_num++);
    }

  old_chain = make_cleanup (xfree, buf);

  /* We have an available name, create the variable.  */
  tsv = create_trace_state_variable (buf);
  tsv->initial_value = utsv->initial_value;
  tsv->builtin = utsv->builtin;

  observer_notify_tsv_created (tsv);

  do_cleanups (old_chain);

  return tsv;
}

/* Given a list of uploaded trace state variables, try to match them
   up with existing variables, or create additional ones.  */

void
merge_uploaded_trace_state_variables (struct uploaded_tsv **uploaded_tsvs)
{
  int ix;
  struct uploaded_tsv *utsv;
  struct trace_state_variable *tsv;
  int highest;

  /* Most likely some numbers will have to be reassigned as part of
     the merge, so clear them all in anticipation.  */
  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
    tsv->number = 0;

  for (utsv = *uploaded_tsvs; utsv; utsv = utsv->next)
    {
      tsv = find_matching_tsv (utsv);
      if (tsv)
	{
	  if (info_verbose)
	    printf_filtered (_("Assuming trace state variable $%s "
			       "is same as target's variable %d.\n"),
			     tsv->name, utsv->number);
	}
      else
	{
	  tsv = create_tsv_from_upload (utsv);
	  if (info_verbose)
	    printf_filtered (_("Created trace state variable "
			       "$%s for target's variable %d.\n"),
			     tsv->name, utsv->number);
	}
      /* Give precedence to numberings that come from the target.  */
      if (tsv)
	tsv->number = utsv->number;
    }

  /* Renumber everything that didn't get a target-assigned number.  */
  highest = 0;
  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
    if (tsv->number > highest)
      highest = tsv->number;

  ++highest;
  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
    if (tsv->number == 0)
      tsv->number = highest++;

  free_uploaded_tsvs (uploaded_tsvs);
}

/* target tfile command */

static struct target_ops tfile_ops;

/* Fill in tfile_ops with its defined operations and properties.  */

#define TRACE_HEADER_SIZE 8

static char *trace_filename;
static int trace_fd = -1;
static off_t trace_frames_offset;
static off_t cur_offset;
static int cur_data_size;
int trace_regblock_size;

static void tfile_interp_line (char *line,
			       struct uploaded_tp **utpp,
			       struct uploaded_tsv **utsvp);

/* Read SIZE bytes into READBUF from the trace frame, starting at
   TRACE_FD's current position.  Note that this call `read'
   underneath, hence it advances the file's seek position.  Throws an
   error if the `read' syscall fails, or less than SIZE bytes are
   read.  */

static void
tfile_read (gdb_byte *readbuf, int size)
{
  int gotten;

  gotten = read (trace_fd, readbuf, size);
  if (gotten < 0)
    perror_with_name (trace_filename);
  else if (gotten < size)
    error (_("Premature end of file while reading trace file"));
}

static void
tfile_open (char *filename, int from_tty)
{
  volatile struct gdb_exception ex;
  char *temp;
  struct cleanup *old_chain;
  int flags;
  int scratch_chan;
  char header[TRACE_HEADER_SIZE];
  char linebuf[1000]; /* Should be max remote packet size or so.  */
  gdb_byte byte;
  int bytes, i;
  struct trace_status *ts;
  struct uploaded_tp *uploaded_tps = NULL;
  struct uploaded_tsv *uploaded_tsvs = NULL;

  target_preopen (from_tty);
  if (!filename)
    error (_("No trace file specified."));

  filename = tilde_expand (filename);
  if (!IS_ABSOLUTE_PATH(filename))
    {
      temp = concat (current_directory, "/", filename, (char *) NULL);
      xfree (filename);
      filename = temp;
    }

  old_chain = make_cleanup (xfree, filename);

  flags = O_BINARY | O_LARGEFILE;
  flags |= O_RDONLY;
  scratch_chan = gdb_open_cloexec (filename, flags, 0);
  if (scratch_chan < 0)
    perror_with_name (filename);

  /* Looks semi-reasonable.  Toss the old trace file and work on the new.  */

  discard_cleanups (old_chain);	/* Don't free filename any more.  */
  unpush_target (&tfile_ops);

  trace_filename = xstrdup (filename);
  trace_fd = scratch_chan;

  bytes = 0;
  /* Read the file header and test for validity.  */
  tfile_read ((gdb_byte *) &header, TRACE_HEADER_SIZE);

  bytes += TRACE_HEADER_SIZE;
  if (!(header[0] == 0x7f
	&& (strncmp (header + 1, "TRACE0\n", 7) == 0)))
    error (_("File is not a valid trace file."));

  push_target (&tfile_ops);

  trace_regblock_size = 0;
  ts = current_trace_status ();
  /* We know we're working with a file.  Record its name.  */
  ts->filename = trace_filename;
  /* Set defaults in case there is no status line.  */
  ts->running_known = 0;
  ts->stop_reason = trace_stop_reason_unknown;
  ts->traceframe_count = -1;
  ts->buffer_free = 0;
  ts->disconnected_tracing = 0;
  ts->circular_buffer = 0;

  TRY_CATCH (ex, RETURN_MASK_ALL)
    {
      /* Read through a section of newline-terminated lines that
	 define things like tracepoints.  */
      i = 0;
      while (1)
	{
	  tfile_read (&byte, 1);

	  ++bytes;
	  if (byte == '\n')
	    {
	      /* Empty line marks end of the definition section.  */
	      if (i == 0)
		break;
	      linebuf[i] = '\0';
	      i = 0;
	      tfile_interp_line (linebuf, &uploaded_tps, &uploaded_tsvs);
	    }
	  else
	    linebuf[i++] = byte;
	  if (i >= 1000)
	    error (_("Excessively long lines in trace file"));
	}

      /* Record the starting offset of the binary trace data.  */
      trace_frames_offset = bytes;

      /* If we don't have a blocksize, we can't interpret the
	 traceframes.  */
      if (trace_regblock_size == 0)
	error (_("No register block size recorded in trace file"));
    }
  if (ex.reason < 0)
    {
      /* Remove the partially set up target.  */
      unpush_target (&tfile_ops);
      throw_exception (ex);
    }

  if (ts->traceframe_count <= 0)
    warning (_("No traceframes present in this file."));

  /* Add the file's tracepoints and variables into the current mix.  */

  /* Get trace state variables first, they may be checked when parsing
     uploaded commands.  */
  merge_uploaded_trace_state_variables (&uploaded_tsvs);

  merge_uploaded_tracepoints (&uploaded_tps);
}

/* Interpret the given line from the definitions part of the trace
   file.  */

static void
tfile_interp_line (char *line, struct uploaded_tp **utpp,
		   struct uploaded_tsv **utsvp)
{
  char *p = line;

  if (strncmp (p, "R ", strlen ("R ")) == 0)
    {
      p += strlen ("R ");
      trace_regblock_size = strtol (p, &p, 16);
    }
  else if (strncmp (p, "status ", strlen ("status ")) == 0)
    {
      p += strlen ("status ");
      parse_trace_status (p, current_trace_status ());
    }
  else if (strncmp (p, "tp ", strlen ("tp ")) == 0)
    {
      p += strlen ("tp ");
      parse_tracepoint_definition (p, utpp);
    }
  else if (strncmp (p, "tsv ", strlen ("tsv ")) == 0)
    {
      p += strlen ("tsv ");
      parse_tsv_definition (p, utsvp);
    }
  else
    warning (_("Ignoring trace file definition \"%s\""), line);
}

/* Parse the part of trace status syntax that is shared between
   the remote protocol and the trace file reader.  */

void
parse_trace_status (char *line, struct trace_status *ts)
{
  char *p = line, *p1, *p2, *p3, *p_temp;
  int end;
  ULONGEST val;

  ts->running_known = 1;
  ts->running = (*p++ == '1');
  ts->stop_reason = trace_stop_reason_unknown;
  xfree (ts->stop_desc);
  ts->stop_desc = NULL;
  ts->traceframe_count = -1;
  ts->traceframes_created = -1;
  ts->buffer_free = -1;
  ts->buffer_size = -1;
  ts->disconnected_tracing = 0;
  ts->circular_buffer = 0;
  xfree (ts->user_name);
  ts->user_name = NULL;
  xfree (ts->notes);
  ts->notes = NULL;
  ts->start_time = ts->stop_time = 0;

  while (*p++)
    {
      p1 = strchr (p, ':');
      if (p1 == NULL)
	error (_("Malformed trace status, at %s\n\
Status line: '%s'\n"), p, line);
      p3 = strchr (p, ';');
      if (p3 == NULL)
	p3 = p + strlen (p);
      if (strncmp (p, stop_reason_names[trace_buffer_full], p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->stop_reason = trace_buffer_full;
	}
      else if (strncmp (p, stop_reason_names[trace_never_run], p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->stop_reason = trace_never_run;
	}
      else if (strncmp (p, stop_reason_names[tracepoint_passcount],
			p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->stop_reason = tracepoint_passcount;
	  ts->stopping_tracepoint = val;
	}
      else if (strncmp (p, stop_reason_names[tstop_command], p1 - p) == 0)
	{
	  p2 = strchr (++p1, ':');
	  if (!p2 || p2 > p3)
	    {
	      /*older style*/
	      p2 = p1;
	    }
	  else if (p2 != p1)
	    {
	      ts->stop_desc = xmalloc (strlen (line));
	      end = hex2bin (p1, (gdb_byte *) ts->stop_desc, (p2 - p1) / 2);
	      ts->stop_desc[end] = '\0';
	    }
	  else
	    ts->stop_desc = xstrdup ("");

	  p = unpack_varlen_hex (++p2, &val);
	  ts->stop_reason = tstop_command;
	}
      else if (strncmp (p, stop_reason_names[trace_disconnected], p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->stop_reason = trace_disconnected;
	}
      else if (strncmp (p, stop_reason_names[tracepoint_error], p1 - p) == 0)
	{
	  p2 = strchr (++p1, ':');
	  if (p2 != p1)
	    {
	      ts->stop_desc = xmalloc ((p2 - p1) / 2 + 1);
	      end = hex2bin (p1, (gdb_byte *) ts->stop_desc, (p2 - p1) / 2);
	      ts->stop_desc[end] = '\0';
	    }
	  else
	    ts->stop_desc = xstrdup ("");

	  p = unpack_varlen_hex (++p2, &val);
	  ts->stopping_tracepoint = val;
	  ts->stop_reason = tracepoint_error;
	}
      else if (strncmp (p, "tframes", p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->traceframe_count = val;
	}
      else if (strncmp (p, "tcreated", p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->traceframes_created = val;
	}
      else if (strncmp (p, "tfree", p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->buffer_free = val;
	}
      else if (strncmp (p, "tsize", p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->buffer_size = val;
	}
      else if (strncmp (p, "disconn", p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->disconnected_tracing = val;
	}
      else if (strncmp (p, "circular", p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->circular_buffer = val;
	}
      else if (strncmp (p, "starttime", p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->start_time = val;
	}
      else if (strncmp (p, "stoptime", p1 - p) == 0)
	{
	  p = unpack_varlen_hex (++p1, &val);
	  ts->stop_time = val;
	}
      else if (strncmp (p, "username", p1 - p) == 0)
	{
	  ++p1;
	  ts->user_name = xmalloc (strlen (p) / 2);
	  end = hex2bin (p1, (gdb_byte *) ts->user_name, (p3 - p1)  / 2);
	  ts->user_name[end] = '\0';
	  p = p3;
	}
      else if (strncmp (p, "notes", p1 - p) == 0)
	{
	  ++p1;
	  ts->notes = xmalloc (strlen (p) / 2);
	  end = hex2bin (p1, (gdb_byte *) ts->notes, (p3 - p1) / 2);
	  ts->notes[end] = '\0';
	  p = p3;
	}
      else
	{
	  /* Silently skip unknown optional info.  */
	  p_temp = strchr (p1 + 1, ';');
	  if (p_temp)
	    p = p_temp;
	  else
	    /* Must be at the end.  */
	    break;
	}
    }
}

void
parse_tracepoint_status (char *p, struct breakpoint *bp,
			 struct uploaded_tp *utp)
{
  ULONGEST uval;
  struct tracepoint *tp = (struct tracepoint *) bp;

  p = unpack_varlen_hex (p, &uval);
  if (tp)
    tp->base.hit_count += uval;
  else
    utp->hit_count += uval;
  p = unpack_varlen_hex (p + 1, &uval);
  if (tp)
    tp->traceframe_usage += uval;
  else
    utp->traceframe_usage += uval;
  /* Ignore any extra, allowing for future extensions.  */
}

/* Given a line of text defining a part of a tracepoint, parse it into
   an "uploaded tracepoint".  */

void
parse_tracepoint_definition (char *line, struct uploaded_tp **utpp)
{
  char *p;
  char piece;
  ULONGEST num, addr, step, pass, orig_size, xlen, start;
  int enabled, end;
  enum bptype type;
  char *cond, *srctype, *buf;
  struct uploaded_tp *utp = NULL;

  p = line;
  /* Both tracepoint and action definitions start with the same number
     and address sequence.  */
  piece = *p++;
  p = unpack_varlen_hex (p, &num);
  p++;  /* skip a colon */
  p = unpack_varlen_hex (p, &addr);
  p++;  /* skip a colon */
  if (piece == 'T')
    {
      enabled = (*p++ == 'E');
      p++;  /* skip a colon */
      p = unpack_varlen_hex (p, &step);
      p++;  /* skip a colon */
      p = unpack_varlen_hex (p, &pass);
      type = bp_tracepoint;
      cond = NULL;
      /* Thumb through optional fields.  */
      while (*p == ':')
	{
	  p++;  /* skip a colon */
	  if (*p == 'F')
	    {
	      type = bp_fast_tracepoint;
	      p++;
	      p = unpack_varlen_hex (p, &orig_size);
	    }
	  else if (*p == 'S')
	    {
	      type = bp_static_tracepoint;
	      p++;
	    }
	  else if (*p == 'X')
	    {
	      p++;
	      p = unpack_varlen_hex (p, &xlen);
	      p++;  /* skip a comma */
	      cond = (char *) xmalloc (2 * xlen + 1);
	      strncpy (cond, p, 2 * xlen);
	      cond[2 * xlen] = '\0';
	      p += 2 * xlen;
	    }
	  else
	    warning (_("Unrecognized char '%c' in tracepoint "
		       "definition, skipping rest"), *p);
	}
      utp = get_uploaded_tp (num, addr, utpp);
      utp->type = type;
      utp->enabled = enabled;
      utp->step = step;
      utp->pass = pass;
      utp->cond = cond;
    }
  else if (piece == 'A')
    {
      utp = get_uploaded_tp (num, addr, utpp);
      VEC_safe_push (char_ptr, utp->actions, xstrdup (p));
    }
  else if (piece == 'S')
    {
      utp = get_uploaded_tp (num, addr, utpp);
      VEC_safe_push (char_ptr, utp->step_actions, xstrdup (p));
    }
  else if (piece == 'Z')
    {
      /* Parse a chunk of source form definition.  */
      utp = get_uploaded_tp (num, addr, utpp);
      srctype = p;
      p = strchr (p, ':');
      p++;  /* skip a colon */
      p = unpack_varlen_hex (p, &start);
      p++;  /* skip a colon */
      p = unpack_varlen_hex (p, &xlen);
      p++;  /* skip a colon */

      buf = alloca (strlen (line));

      end = hex2bin (p, (gdb_byte *) buf, strlen (p) / 2);
      buf[end] = '\0';

      if (strncmp (srctype, "at:", strlen ("at:")) == 0)
	utp->at_string = xstrdup (buf);
      else if (strncmp (srctype, "cond:", strlen ("cond:")) == 0)
	utp->cond_string = xstrdup (buf);
      else if (strncmp (srctype, "cmd:", strlen ("cmd:")) == 0)
	VEC_safe_push (char_ptr, utp->cmd_strings, xstrdup (buf));
    }
  else if (piece == 'V')
    {
      utp = get_uploaded_tp (num, addr, utpp);

      parse_tracepoint_status (p, NULL, utp);
    }
  else
    {
      /* Don't error out, the target might be sending us optional
	 info that we don't care about.  */
      warning (_("Unrecognized tracepoint piece '%c', ignoring"), piece);
    }
}

/* Convert a textual description of a trace state variable into an
   uploaded object.  */

void
parse_tsv_definition (char *line, struct uploaded_tsv **utsvp)
{
  char *p, *buf;
  ULONGEST num, initval, builtin;
  int end;
  struct uploaded_tsv *utsv = NULL;

  buf = alloca (strlen (line));

  p = line;
  p = unpack_varlen_hex (p, &num);
  p++; /* skip a colon */
  p = unpack_varlen_hex (p, &initval);
  p++; /* skip a colon */
  p = unpack_varlen_hex (p, &builtin);
  p++; /* skip a colon */
  end = hex2bin (p, (gdb_byte *) buf, strlen (p) / 2);
  buf[end] = '\0';

  utsv = get_uploaded_tsv (num, utsvp);
  utsv->initial_value = initval;
  utsv->builtin = builtin;
  utsv->name = xstrdup (buf);
}

/* Close the trace file and generally clean up.  */

static void
tfile_close (void)
{
  int pid;

  if (trace_fd < 0)
    return;

  close (trace_fd);
  trace_fd = -1;
  xfree (trace_filename);
  trace_filename = NULL;

  trace_reset_local_state ();
}

static void
tfile_files_info (struct target_ops *t)
{
  printf_filtered ("\t`%s'\n", trace_filename);
}

/* The trace status for a file is that tracing can never be run.  */

static int
tfile_get_trace_status (struct trace_status *ts)
{
  /* Other bits of trace status were collected as part of opening the
     trace files, so nothing to do here.  */

  return -1;
}

static void
tfile_get_tracepoint_status (struct breakpoint *tp, struct uploaded_tp *utp)
{
  /* Other bits of trace status were collected as part of opening the
     trace files, so nothing to do here.  */
}

/* Given the position of a traceframe in the file, figure out what
   address the frame was collected at.  This would normally be the
   value of a collected PC register, but if not available, we
   improvise.  */

static CORE_ADDR
tfile_get_traceframe_address (off_t tframe_offset)
{
  CORE_ADDR addr = 0;
  short tpnum;
  struct tracepoint *tp;
  off_t saved_offset = cur_offset;

  /* FIXME dig pc out of collected registers.  */

  /* Fall back to using tracepoint address.  */
  lseek (trace_fd, tframe_offset, SEEK_SET);
  tfile_read ((gdb_byte *) &tpnum, 2);
  tpnum = (short) extract_signed_integer ((gdb_byte *) &tpnum, 2,
					  gdbarch_byte_order
					      (target_gdbarch ()));

  tp = get_tracepoint_by_number_on_target (tpnum);
  /* FIXME this is a poor heuristic if multiple locations.  */
  if (tp && tp->base.loc)
    addr = tp->base.loc->address;

  /* Restore our seek position.  */
  cur_offset = saved_offset;
  lseek (trace_fd, cur_offset, SEEK_SET);
  return addr;
}

/* Given a type of search and some parameters, scan the collection of
   traceframes in the file looking for a match.  When found, return
   both the traceframe and tracepoint number, otherwise -1 for
   each.  */

static int
tfile_trace_find (enum trace_find_type type, int num,
		  CORE_ADDR addr1, CORE_ADDR addr2, int *tpp)
{
  short tpnum;
  int tfnum = 0, found = 0;
  unsigned int data_size;
  struct tracepoint *tp;
  off_t offset, tframe_offset;
  CORE_ADDR tfaddr;

  if (num == -1)
    {
      if (tpp)
        *tpp = -1;
      return -1;
    }

  lseek (trace_fd, trace_frames_offset, SEEK_SET);
  offset = trace_frames_offset;
  while (1)
    {
      tframe_offset = offset;
      tfile_read ((gdb_byte *) &tpnum, 2);
      tpnum = (short) extract_signed_integer ((gdb_byte *) &tpnum, 2,
					      gdbarch_byte_order
						  (target_gdbarch ()));
      offset += 2;
      if (tpnum == 0)
	break;
      tfile_read ((gdb_byte *) &data_size, 4);
      data_size = (unsigned int) extract_unsigned_integer
                                     ((gdb_byte *) &data_size, 4,
				      gdbarch_byte_order (target_gdbarch ()));
      offset += 4;

      if (type == tfind_number)
	{
	  /* Looking for a specific trace frame.  */
	  if (tfnum == num)
	    found = 1;
	}
      else
	{
	  /* Start from the _next_ trace frame.  */
	  if (tfnum > traceframe_number)
	    {
	      switch (type)
		{
		case tfind_pc:
		  tfaddr = tfile_get_traceframe_address (tframe_offset);
		  if (tfaddr == addr1)
		    found = 1;
		  break;
		case tfind_tp:
		  tp = get_tracepoint (num);
		  if (tp && tpnum == tp->number_on_target)
		    found = 1;
		  break;
		case tfind_range:
		  tfaddr = tfile_get_traceframe_address (tframe_offset);
		  if (addr1 <= tfaddr && tfaddr <= addr2)
		    found = 1;
		  break;
		case tfind_outside:
		  tfaddr = tfile_get_traceframe_address (tframe_offset);
		  if (!(addr1 <= tfaddr && tfaddr <= addr2))
		    found = 1;
		  break;
		default:
		  internal_error (__FILE__, __LINE__, _("unknown tfind type"));
		}
	    }
	}

      if (found)
	{
	  if (tpp)
	    *tpp = tpnum;
	  cur_offset = offset;
	  cur_data_size = data_size;

	  return tfnum;
	}
      /* Skip past the traceframe's data.  */
      lseek (trace_fd, data_size, SEEK_CUR);
      offset += data_size;
      /* Update our own count of traceframes.  */
      ++tfnum;
    }
  /* Did not find what we were looking for.  */
  if (tpp)
    *tpp = -1;
  return -1;
}

/* Prototype of the callback passed to tframe_walk_blocks.  */
typedef int (*walk_blocks_callback_func) (char blocktype, void *data);

/* Callback for traceframe_walk_blocks, used to find a given block
   type in a traceframe.  */

static int
match_blocktype (char blocktype, void *data)
{
  char *wantedp = data;

  if (*wantedp == blocktype)
    return 1;

  return 0;
}

/* Walk over all traceframe block starting at POS offset from
   CUR_OFFSET, and call CALLBACK for each block found, passing in DATA
   unmodified.  If CALLBACK returns true, this returns the position in
   the traceframe where the block is found, relative to the start of
   the traceframe (cur_offset).  Returns -1 if no callback call
   returned true, indicating that all blocks have been walked.  */

static int
traceframe_walk_blocks (walk_blocks_callback_func callback,
			int pos, void *data)
{
  /* Iterate through a traceframe's blocks, looking for a block of the
     requested type.  */

  lseek (trace_fd, cur_offset + pos, SEEK_SET);
  while (pos < cur_data_size)
    {
      unsigned short mlen;
      char block_type;

      tfile_read ((gdb_byte *) &block_type, 1);

      ++pos;

      if ((*callback) (block_type, data))
	return pos;

      switch (block_type)
	{
	case 'R':
	  lseek (trace_fd, cur_offset + pos + trace_regblock_size, SEEK_SET);
	  pos += trace_regblock_size;
	  break;
	case 'M':
	  lseek (trace_fd, cur_offset + pos + 8, SEEK_SET);
	  tfile_read ((gdb_byte *) &mlen, 2);
          mlen = (unsigned short)
                extract_unsigned_integer ((gdb_byte *) &mlen, 2,
                                          gdbarch_byte_order
                                              (target_gdbarch ()));
	  lseek (trace_fd, mlen, SEEK_CUR);
	  pos += (8 + 2 + mlen);
	  break;
	case 'V':
	  lseek (trace_fd, cur_offset + pos + 4 + 8, SEEK_SET);
	  pos += (4 + 8);
	  break;
	default:
	  error (_("Unknown block type '%c' (0x%x) in trace frame"),
		 block_type, block_type);
	  break;
	}
    }

  return -1;
}

/* Convenience wrapper around traceframe_walk_blocks.  Looks for the
   position offset of a block of type TYPE_WANTED in the current trace
   frame, starting at POS.  Returns -1 if no such block was found.  */

static int
traceframe_find_block_type (char type_wanted, int pos)
{
  return traceframe_walk_blocks (match_blocktype, pos, &type_wanted);
}

/* Look for a block of saved registers in the traceframe, and get the
   requested register from it.  */

static void
tfile_fetch_registers (struct target_ops *ops,
		       struct regcache *regcache, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  int offset, regn, regsize, pc_regno;
  gdb_byte *regs;

  /* An uninitialized reg size says we're not going to be
     successful at getting register blocks.  */
  if (!trace_regblock_size)
    return;

  regs = alloca (trace_regblock_size);

  if (traceframe_find_block_type ('R', 0) >= 0)
    {
      tfile_read (regs, trace_regblock_size);

      /* Assume the block is laid out in GDB register number order,
	 each register with the size that it has in GDB.  */
      offset = 0;
      for (regn = 0; regn < gdbarch_num_regs (gdbarch); regn++)
	{
	  regsize = register_size (gdbarch, regn);
	  /* Make sure we stay within block bounds.  */
	  if (offset + regsize >= trace_regblock_size)
	    break;
	  if (regcache_register_status (regcache, regn) == REG_UNKNOWN)
	    {
	      if (regno == regn)
		{
		  regcache_raw_supply (regcache, regno, regs + offset);
		  break;
		}
	      else if (regno == -1)
		{
		  regcache_raw_supply (regcache, regn, regs + offset);
		}
	    }
	  offset += regsize;
	}
      return;
    }

  /* We get here if no register data has been found.  Mark registers
     as unavailable.  */
  for (regn = 0; regn < gdbarch_num_regs (gdbarch); regn++)
    regcache_raw_supply (regcache, regn, NULL);

  /* We can often usefully guess that the PC is going to be the same
     as the address of the tracepoint.  */
  pc_regno = gdbarch_pc_regnum (gdbarch);
  if (pc_regno >= 0 && (regno == -1 || regno == pc_regno))
    {
      struct tracepoint *tp = get_tracepoint (tracepoint_number);

      if (tp && tp->base.loc)
	{
	  /* But don't try to guess if tracepoint is multi-location...  */
	  if (tp->base.loc->next)
	    {
	      warning (_("Tracepoint %d has multiple "
			 "locations, cannot infer $pc"),
		       tp->base.number);
	      return;
	    }
	  /* ... or does while-stepping.  */
	  if (tp->step_count > 0)
	    {
	      warning (_("Tracepoint %d does while-stepping, "
			 "cannot infer $pc"),
		       tp->base.number);
	      return;
	    }

	  store_unsigned_integer (regs, register_size (gdbarch, pc_regno),
				  gdbarch_byte_order (gdbarch),
				  tp->base.loc->address);
	  regcache_raw_supply (regcache, pc_regno, regs);
	}
    }
}

static LONGEST
tfile_xfer_partial (struct target_ops *ops, enum target_object object,
		    const char *annex, gdb_byte *readbuf,
		    const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  /* We're only doing regular memory for now.  */
  if (object != TARGET_OBJECT_MEMORY)
    return -1;

  if (readbuf == NULL)
    error (_("tfile_xfer_partial: trace file is read-only"));

 if (traceframe_number != -1)
    {
      int pos = 0;

      /* Iterate through the traceframe's blocks, looking for
	 memory.  */
      while ((pos = traceframe_find_block_type ('M', pos)) >= 0)
	{
	  ULONGEST maddr, amt;
	  unsigned short mlen;
	  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());

	  tfile_read ((gdb_byte *) &maddr, 8);
	  maddr = extract_unsigned_integer ((gdb_byte *) &maddr, 8,
					    byte_order);
	  tfile_read ((gdb_byte *) &mlen, 2);
	  mlen = (unsigned short)
	    extract_unsigned_integer ((gdb_byte *) &mlen, 2, byte_order);

	  /* If the block includes the first part of the desired
	     range, return as much it has; GDB will re-request the
	     remainder, which might be in a different block of this
	     trace frame.  */
	  if (maddr <= offset && offset < (maddr + mlen))
	    {
	      amt = (maddr + mlen) - offset;
	      if (amt > len)
		amt = len;

	      if (maddr != offset)
	        lseek (trace_fd, offset - maddr, SEEK_CUR);
	      tfile_read (readbuf, amt);
	      return amt;
	    }

	  /* Skip over this block.  */
	  pos += (8 + 2 + mlen);
	}
    }

  /* It's unduly pedantic to refuse to look at the executable for
     read-only pieces; so do the equivalent of readonly regions aka
     QTro packet.  */
  /* FIXME account for relocation at some point.  */
  if (exec_bfd)
    {
      asection *s;
      bfd_size_type size;
      bfd_vma vma;

      for (s = exec_bfd->sections; s; s = s->next)
	{
	  if ((s->flags & SEC_LOAD) == 0
	      || (s->flags & SEC_READONLY) == 0)
	    continue;

	  vma = s->vma;
	  size = bfd_get_section_size (s);
	  if (vma <= offset && offset < (vma + size))
	    {
	      ULONGEST amt;

	      amt = (vma + size) - offset;
	      if (amt > len)
		amt = len;

	      amt = bfd_get_section_contents (exec_bfd, s,
					      readbuf, offset - vma, amt);
	      return amt;
	    }
	}
    }

  /* Indicate failure to find the requested memory block.  */
  return -1;
}

/* Iterate through the blocks of a trace frame, looking for a 'V'
   block with a matching tsv number.  */

static int
tfile_get_trace_state_variable_value (int tsvnum, LONGEST *val)
{
  int pos;
  int found = 0;

  /* Iterate over blocks in current frame and find the last 'V'
     block in which tsv number is TSVNUM.  In one trace frame, there
     may be multiple 'V' blocks created for a given trace variable,
     and the last matched 'V' block contains the updated value.  */
  pos = 0;
  while ((pos = traceframe_find_block_type ('V', pos)) >= 0)
    {
      int vnum;

      tfile_read ((gdb_byte *) &vnum, 4);
      vnum = (int) extract_signed_integer ((gdb_byte *) &vnum, 4,
					   gdbarch_byte_order
					   (target_gdbarch ()));
      if (tsvnum == vnum)
	{
	  tfile_read ((gdb_byte *) val, 8);
	  *val = extract_signed_integer ((gdb_byte *) val, 8,
					 gdbarch_byte_order
					 (target_gdbarch ()));
	  found = 1;
	}
      pos += (4 + 8);
    }

  return found;
}

static int
tfile_has_all_memory (struct target_ops *ops)
{
  return 1;
}

static int
tfile_has_memory (struct target_ops *ops)
{
  return 1;
}

static int
tfile_has_stack (struct target_ops *ops)
{
  return traceframe_number != -1;
}

static int
tfile_has_registers (struct target_ops *ops)
{
  return traceframe_number != -1;
}

/* Callback for traceframe_walk_blocks.  Builds a traceframe_info
   object for the tfile target's current traceframe.  */

static int
build_traceframe_info (char blocktype, void *data)
{
  struct traceframe_info *info = data;

  switch (blocktype)
    {
    case 'M':
      {
	struct mem_range *r;
	ULONGEST maddr;
	unsigned short mlen;

	tfile_read ((gdb_byte *) &maddr, 8);
	maddr = extract_unsigned_integer ((gdb_byte *) &maddr, 8,
					  gdbarch_byte_order
					  (target_gdbarch ()));
	tfile_read ((gdb_byte *) &mlen, 2);
	mlen = (unsigned short)
		extract_unsigned_integer ((gdb_byte *) &mlen,
					  2, gdbarch_byte_order
					  (target_gdbarch ()));

	r = VEC_safe_push (mem_range_s, info->memory, NULL);

	r->start = maddr;
	r->length = mlen;
	break;
      }
    case 'V':
      {
	int vnum;

	tfile_read ((gdb_byte *) &vnum, 4);
	VEC_safe_push (int, info->tvars, vnum);
      }
    case 'R':
    case 'S':
      {
	break;
      }
    default:
      warning (_("Unhandled trace block type (%d) '%c ' "
		 "while building trace frame info."),
	       blocktype, blocktype);
      break;
    }

  return 0;
}

static struct traceframe_info *
tfile_traceframe_info (void)
{
  struct traceframe_info *info = XCNEW (struct traceframe_info);

  traceframe_walk_blocks (build_traceframe_info, 0, info);
  return info;
}

static void
init_tfile_ops (void)
{
  tfile_ops.to_shortname = "tfile";
  tfile_ops.to_longname = "Local trace dump file";
  tfile_ops.to_doc
    = "Use a trace file as a target.  Specify the filename of the trace file.";
  tfile_ops.to_open = tfile_open;
  tfile_ops.to_close = tfile_close;
  tfile_ops.to_fetch_registers = tfile_fetch_registers;
  tfile_ops.to_xfer_partial = tfile_xfer_partial;
  tfile_ops.to_files_info = tfile_files_info;
  tfile_ops.to_get_trace_status = tfile_get_trace_status;
  tfile_ops.to_get_tracepoint_status = tfile_get_tracepoint_status;
  tfile_ops.to_trace_find = tfile_trace_find;
  tfile_ops.to_get_trace_state_variable_value
    = tfile_get_trace_state_variable_value;
  tfile_ops.to_stratum = process_stratum;
  tfile_ops.to_has_all_memory = tfile_has_all_memory;
  tfile_ops.to_has_memory = tfile_has_memory;
  tfile_ops.to_has_stack = tfile_has_stack;
  tfile_ops.to_has_registers = tfile_has_registers;
  tfile_ops.to_traceframe_info = tfile_traceframe_info;
  tfile_ops.to_magic = OPS_MAGIC;
}

void
free_current_marker (void *arg)
{
  struct static_tracepoint_marker **marker_p = arg;

  if (*marker_p != NULL)
    {
      release_static_tracepoint_marker (*marker_p);
      xfree (*marker_p);
    }
  else
    *marker_p = NULL;
}

/* Given a line of text defining a static tracepoint marker, parse it
   into a "static tracepoint marker" object.  Throws an error is
   parsing fails.  If PP is non-null, it points to one past the end of
   the parsed marker definition.  */

void
parse_static_tracepoint_marker_definition (char *line, char **pp,
					   struct static_tracepoint_marker *marker)
{
  char *p, *endp;
  ULONGEST addr;
  int end;

  p = line;
  p = unpack_varlen_hex (p, &addr);
  p++;  /* skip a colon */

  marker->gdbarch = target_gdbarch ();
  marker->address = (CORE_ADDR) addr;

  endp = strchr (p, ':');
  if (endp == NULL)
    error (_("bad marker definition: %s"), line);

  marker->str_id = xmalloc (endp - p + 1);
  end = hex2bin (p, (gdb_byte *) marker->str_id, (endp - p + 1) / 2);
  marker->str_id[end] = '\0';

  p += 2 * end;
  p++;  /* skip a colon */

  marker->extra = xmalloc (strlen (p) + 1);
  end = hex2bin (p, (gdb_byte *) marker->extra, strlen (p) / 2);
  marker->extra[end] = '\0';

  if (pp)
    *pp = p;
}

/* Release a static tracepoint marker's contents.  Note that the
   object itself isn't released here.  There objects are usually on
   the stack.  */

void
release_static_tracepoint_marker (struct static_tracepoint_marker *marker)
{
  xfree (marker->str_id);
  marker->str_id = NULL;
}

/* Print MARKER to gdb_stdout.  */

static void
print_one_static_tracepoint_marker (int count,
				    struct static_tracepoint_marker *marker)
{
  struct command_line *l;
  struct symbol *sym;

  char wrap_indent[80];
  char extra_field_indent[80];
  struct ui_out *uiout = current_uiout;
  struct cleanup *bkpt_chain;
  VEC(breakpoint_p) *tracepoints;

  struct symtab_and_line sal;

  init_sal (&sal);

  sal.pc = marker->address;

  tracepoints = static_tracepoints_here (marker->address);

  bkpt_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "marker");

  /* A counter field to help readability.  This is not a stable
     identifier!  */
  ui_out_field_int (uiout, "count", count);

  ui_out_field_string (uiout, "marker-id", marker->str_id);

  ui_out_field_fmt (uiout, "enabled", "%c",
		    !VEC_empty (breakpoint_p, tracepoints) ? 'y' : 'n');
  ui_out_spaces (uiout, 2);

  strcpy (wrap_indent, "                                   ");

  if (gdbarch_addr_bit (marker->gdbarch) <= 32)
    strcat (wrap_indent, "           ");
  else
    strcat (wrap_indent, "                   ");

  strcpy (extra_field_indent, "         ");

  ui_out_field_core_addr (uiout, "addr", marker->gdbarch, marker->address);

  sal = find_pc_line (marker->address, 0);
  sym = find_pc_sect_function (marker->address, NULL);
  if (sym)
    {
      ui_out_text (uiout, "in ");
      ui_out_field_string (uiout, "func",
			   SYMBOL_PRINT_NAME (sym));
      ui_out_wrap_hint (uiout, wrap_indent);
      ui_out_text (uiout, " at ");
    }
  else
    ui_out_field_skip (uiout, "func");

  if (sal.symtab != NULL)
    {
      ui_out_field_string (uiout, "file",
			   symtab_to_filename_for_display (sal.symtab));
      ui_out_text (uiout, ":");

      if (ui_out_is_mi_like_p (uiout))
	{
	  const char *fullname = symtab_to_fullname (sal.symtab);

	  ui_out_field_string (uiout, "fullname", fullname);
	}
      else
	ui_out_field_skip (uiout, "fullname");

      ui_out_field_int (uiout, "line", sal.line);
    }
  else
    {
      ui_out_field_skip (uiout, "fullname");
      ui_out_field_skip (uiout, "line");
    }

  ui_out_text (uiout, "\n");
  ui_out_text (uiout, extra_field_indent);
  ui_out_text (uiout, _("Data: \""));
  ui_out_field_string (uiout, "extra-data", marker->extra);
  ui_out_text (uiout, "\"\n");

  if (!VEC_empty (breakpoint_p, tracepoints))
    {
      struct cleanup *cleanup_chain;
      int ix;
      struct breakpoint *b;

      cleanup_chain = make_cleanup_ui_out_tuple_begin_end (uiout,
							   "tracepoints-at");

      ui_out_text (uiout, extra_field_indent);
      ui_out_text (uiout, _("Probed by static tracepoints: "));
      for (ix = 0; VEC_iterate(breakpoint_p, tracepoints, ix, b); ix++)
	{
	  if (ix > 0)
	    ui_out_text (uiout, ", ");
	  ui_out_text (uiout, "#");
	  ui_out_field_int (uiout, "tracepoint-id", b->number);
	}

      do_cleanups (cleanup_chain);

      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_int (uiout, "number-of-tracepoints",
			  VEC_length(breakpoint_p, tracepoints));
      else
	ui_out_text (uiout, "\n");
    }
  VEC_free (breakpoint_p, tracepoints);

  do_cleanups (bkpt_chain);
}

static void
info_static_tracepoint_markers_command (char *arg, int from_tty)
{
  VEC(static_tracepoint_marker_p) *markers;
  struct cleanup *old_chain;
  struct static_tracepoint_marker *marker;
  struct ui_out *uiout = current_uiout;
  int i;

  /* We don't have to check target_can_use_agent and agent's capability on
     static tracepoint here, in order to be compatible with older GDBserver.
     We don't check USE_AGENT is true or not, because static tracepoints
     don't work without in-process agent, so we don't bother users to type
     `set agent on' when to use static tracepoint.  */

  old_chain
    = make_cleanup_ui_out_table_begin_end (uiout, 5, -1,
					   "StaticTracepointMarkersTable");

  ui_out_table_header (uiout, 7, ui_left, "counter", "Cnt");

  ui_out_table_header (uiout, 40, ui_left, "marker-id", "ID");

  ui_out_table_header (uiout, 3, ui_left, "enabled", "Enb");
  if (gdbarch_addr_bit (target_gdbarch ()) <= 32)
    ui_out_table_header (uiout, 10, ui_left, "addr", "Address");
  else
    ui_out_table_header (uiout, 18, ui_left, "addr", "Address");
  ui_out_table_header (uiout, 40, ui_noalign, "what", "What");

  ui_out_table_body (uiout);

  markers = target_static_tracepoint_markers_by_strid (NULL);
  make_cleanup (VEC_cleanup (static_tracepoint_marker_p), &markers);

  for (i = 0;
       VEC_iterate (static_tracepoint_marker_p,
		    markers, i, marker);
       i++)
    {
      print_one_static_tracepoint_marker (i + 1, marker);
      release_static_tracepoint_marker (marker);
    }

  do_cleanups (old_chain);
}

/* The $_sdata convenience variable is a bit special.  We don't know
   for sure type of the value until we actually have a chance to fetch
   the data --- the size of the object depends on what has been
   collected.  We solve this by making $_sdata be an internalvar that
   creates a new value on access.  */

/* Return a new value with the correct type for the sdata object of
   the current trace frame.  Return a void value if there's no object
   available.  */

static struct value *
sdata_make_value (struct gdbarch *gdbarch, struct internalvar *var,
		  void *ignore)
{
  LONGEST size;
  gdb_byte *buf;

  /* We need to read the whole object before we know its size.  */
  size = target_read_alloc (&current_target,
			    TARGET_OBJECT_STATIC_TRACE_DATA,
			    NULL, &buf);
  if (size >= 0)
    {
      struct value *v;
      struct type *type;

      type = init_vector_type (builtin_type (gdbarch)->builtin_true_char,
			       size);
      v = allocate_value (type);
      memcpy (value_contents_raw (v), buf, size);
      xfree (buf);
      return v;
    }
  else
    return allocate_value (builtin_type (gdbarch)->builtin_void);
}

#if !defined(HAVE_LIBEXPAT)

struct traceframe_info *
parse_traceframe_info (const char *tframe_info)
{
  static int have_warned;

  if (!have_warned)
    {
      have_warned = 1;
      warning (_("Can not parse XML trace frame info; XML support "
		 "was disabled at compile time"));
    }

  return NULL;
}

#else /* HAVE_LIBEXPAT */

#include "xml-support.h"

/* Handle the start of a <memory> element.  */

static void
traceframe_info_start_memory (struct gdb_xml_parser *parser,
			      const struct gdb_xml_element *element,
			      void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct traceframe_info *info = user_data;
  struct mem_range *r = VEC_safe_push (mem_range_s, info->memory, NULL);
  ULONGEST *start_p, *length_p;

  start_p = xml_find_attribute (attributes, "start")->value;
  length_p = xml_find_attribute (attributes, "length")->value;

  r->start = *start_p;
  r->length = *length_p;
}

/* Handle the start of a <tvar> element.  */

static void
traceframe_info_start_tvar (struct gdb_xml_parser *parser,
			     const struct gdb_xml_element *element,
			     void *user_data,
			     VEC(gdb_xml_value_s) *attributes)
{
  struct traceframe_info *info = user_data;
  const char *id_attrib = xml_find_attribute (attributes, "id")->value;
  int id = gdb_xml_parse_ulongest (parser, id_attrib);

  VEC_safe_push (int, info->tvars, id);
}

/* Discard the constructed trace frame info (if an error occurs).  */

static void
free_result (void *p)
{
  struct traceframe_info *result = p;

  free_traceframe_info (result);
}

/* The allowed elements and attributes for an XML memory map.  */

static const struct gdb_xml_attribute memory_attributes[] = {
  { "start", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { "length", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute tvar_attributes[] = {
  { "id", GDB_XML_AF_NONE, NULL, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_element traceframe_info_children[] = {
  { "memory", memory_attributes, NULL,
    GDB_XML_EF_REPEATABLE | GDB_XML_EF_OPTIONAL,
    traceframe_info_start_memory, NULL },
  { "tvar", tvar_attributes, NULL,
    GDB_XML_EF_REPEATABLE | GDB_XML_EF_OPTIONAL,
    traceframe_info_start_tvar, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

static const struct gdb_xml_element traceframe_info_elements[] = {
  { "traceframe-info", NULL, traceframe_info_children, GDB_XML_EF_NONE,
    NULL, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

/* Parse a traceframe-info XML document.  */

struct traceframe_info *
parse_traceframe_info (const char *tframe_info)
{
  struct traceframe_info *result;
  struct cleanup *back_to;

  result = XCNEW (struct traceframe_info);
  back_to = make_cleanup (free_result, result);

  if (gdb_xml_parse_quick (_("trace frame info"),
			   "traceframe-info.dtd", traceframe_info_elements,
			   tframe_info, result) == 0)
    {
      /* Parsed successfully, keep the result.  */
      discard_cleanups (back_to);

      return result;
    }

  do_cleanups (back_to);
  return NULL;
}

#endif /* HAVE_LIBEXPAT */

/* Returns the traceframe_info object for the current traceframe.
   This is where we avoid re-fetching the object from the target if we
   already have it cached.  */

struct traceframe_info *
get_traceframe_info (void)
{
  if (traceframe_info == NULL)
    traceframe_info = target_traceframe_info ();

  return traceframe_info;
}

/* If the target supports the query, return in RESULT the set of
   collected memory in the current traceframe, found within the LEN
   bytes range starting at MEMADDR.  Returns true if the target
   supports the query, otherwise returns false, and RESULT is left
   undefined.  */

int
traceframe_available_memory (VEC(mem_range_s) **result,
			     CORE_ADDR memaddr, ULONGEST len)
{
  struct traceframe_info *info = get_traceframe_info ();

  if (info != NULL)
    {
      struct mem_range *r;
      int i;

      *result = NULL;

      for (i = 0; VEC_iterate (mem_range_s, info->memory, i, r); i++)
	if (mem_ranges_overlap (r->start, r->length, memaddr, len))
	  {
	    ULONGEST lo1, hi1, lo2, hi2;
	    struct mem_range *nr;

	    lo1 = memaddr;
	    hi1 = memaddr + len;

	    lo2 = r->start;
	    hi2 = r->start + r->length;

	    nr = VEC_safe_push (mem_range_s, *result, NULL);

	    nr->start = max (lo1, lo2);
	    nr->length = min (hi1, hi2) - nr->start;
	  }

      normalize_mem_ranges (*result);
      return 1;
    }

  return 0;
}

/* Implementation of `sdata' variable.  */

static const struct internalvar_funcs sdata_funcs =
{
  sdata_make_value,
  NULL,
  NULL
};

/* module initialization */
void
_initialize_tracepoint (void)
{
  struct cmd_list_element *c;

  /* Explicitly create without lookup, since that tries to create a
     value with a void typed value, and when we get here, gdbarch
     isn't initialized yet.  At this point, we're quite sure there
     isn't another convenience variable of the same name.  */
  create_internalvar_type_lazy ("_sdata", &sdata_funcs, NULL);

  traceframe_number = -1;
  tracepoint_number = -1;

  add_info ("scope", scope_info,
	    _("List the variables local to a scope"));

  add_cmd ("tracepoints", class_trace, NULL,
	   _("Tracing of program execution without stopping the program."),
	   &cmdlist);

  add_com ("tdump", class_trace, trace_dump_command,
	   _("Print everything collected at the current tracepoint."));

  add_com ("tsave", class_trace, trace_save_command, _("\
Save the trace data to a file.\n\
Use the '-ctf' option to save the data to CTF format.\n\
Use the '-r' option to direct the target to save directly to the file,\n\
using its own filesystem."));

  c = add_com ("tvariable", class_trace, trace_variable_command,_("\
Define a trace state variable.\n\
Argument is a $-prefixed name, optionally followed\n\
by '=' and an expression that sets the initial value\n\
at the start of tracing."));
  set_cmd_completer (c, expression_completer);

  add_cmd ("tvariable", class_trace, delete_trace_variable_command, _("\
Delete one or more trace state variables.\n\
Arguments are the names of the variables to delete.\n\
If no arguments are supplied, delete all variables."), &deletelist);
  /* FIXME add a trace variable completer.  */

  add_info ("tvariables", tvariables_info, _("\
Status of trace state variables and their values.\n\
"));

  add_info ("static-tracepoint-markers",
	    info_static_tracepoint_markers_command, _("\
List target static tracepoints markers.\n\
"));

  add_prefix_cmd ("tfind", class_trace, trace_find_command, _("\
Select a trace frame;\n\
No argument means forward by one frame; '-' means backward by one frame."),
		  &tfindlist, "tfind ", 1, &cmdlist);

  add_cmd ("outside", class_trace, trace_find_outside_command, _("\
Select a trace frame whose PC is outside the given range (exclusive).\n\
Usage: tfind outside addr1, addr2"),
	   &tfindlist);

  add_cmd ("range", class_trace, trace_find_range_command, _("\
Select a trace frame whose PC is in the given range (inclusive).\n\
Usage: tfind range addr1,addr2"),
	   &tfindlist);

  add_cmd ("line", class_trace, trace_find_line_command, _("\
Select a trace frame by source line.\n\
Argument can be a line number (with optional source file),\n\
a function name, or '*' followed by an address.\n\
Default argument is 'the next source line that was traced'."),
	   &tfindlist);

  add_cmd ("tracepoint", class_trace, trace_find_tracepoint_command, _("\
Select a trace frame by tracepoint number.\n\
Default is the tracepoint for the current trace frame."),
	   &tfindlist);

  add_cmd ("pc", class_trace, trace_find_pc_command, _("\
Select a trace frame by PC.\n\
Default is the current PC, or the PC of the current trace frame."),
	   &tfindlist);

  add_cmd ("end", class_trace, trace_find_end_command, _("\
De-select any trace frame and resume 'live' debugging."),
	   &tfindlist);

  add_alias_cmd ("none", "end", class_trace, 0, &tfindlist);

  add_cmd ("start", class_trace, trace_find_start_command,
	   _("Select the first trace frame in the trace buffer."),
	   &tfindlist);

  add_com ("tstatus", class_trace, trace_status_command,
	   _("Display the status of the current trace data collection."));

  add_com ("tstop", class_trace, trace_stop_command, _("\
Stop trace data collection.\n\
Usage: tstop [ <notes> ... ]\n\
Any arguments supplied are recorded with the trace as a stop reason and\n\
reported by tstatus (if the target supports trace notes)."));

  add_com ("tstart", class_trace, trace_start_command, _("\
Start trace data collection.\n\
Usage: tstart [ <notes> ... ]\n\
Any arguments supplied are recorded with the trace as a note and\n\
reported by tstatus (if the target supports trace notes)."));

  add_com ("end", class_trace, end_actions_pseudocommand, _("\
Ends a list of commands or actions.\n\
Several GDB commands allow you to enter a list of commands or actions.\n\
Entering \"end\" on a line by itself is the normal way to terminate\n\
such a list.\n\n\
Note: the \"end\" command cannot be used at the gdb prompt."));

  add_com ("while-stepping", class_trace, while_stepping_pseudocommand, _("\
Specify single-stepping behavior at a tracepoint.\n\
Argument is number of instructions to trace in single-step mode\n\
following the tracepoint.  This command is normally followed by\n\
one or more \"collect\" commands, to specify what to collect\n\
while single-stepping.\n\n\
Note: this command can only be used in a tracepoint \"actions\" list."));

  add_com_alias ("ws", "while-stepping", class_alias, 0);
  add_com_alias ("stepping", "while-stepping", class_alias, 0);

  add_com ("collect", class_trace, collect_pseudocommand, _("\
Specify one or more data items to be collected at a tracepoint.\n\
Accepts a comma-separated list of (one or more) expressions.  GDB will\n\
collect all data (variables, registers) referenced by that expression.\n\
Also accepts the following special arguments:\n\
    $regs   -- all registers.\n\
    $args   -- all function arguments.\n\
    $locals -- all variables local to the block/function scope.\n\
    $_sdata -- static tracepoint data (ignored for non-static tracepoints).\n\
Note: this command can only be used in a tracepoint \"actions\" list."));

  add_com ("teval", class_trace, teval_pseudocommand, _("\
Specify one or more expressions to be evaluated at a tracepoint.\n\
Accepts a comma-separated list of (one or more) expressions.\n\
The result of each evaluation will be discarded.\n\
Note: this command can only be used in a tracepoint \"actions\" list."));

  add_com ("actions", class_trace, trace_actions_command, _("\
Specify the actions to be taken at a tracepoint.\n\
Tracepoint actions may include collecting of specified data,\n\
single-stepping, or enabling/disabling other tracepoints,\n\
depending on target's capabilities."));

  default_collect = xstrdup ("");
  add_setshow_string_cmd ("default-collect", class_trace,
			  &default_collect, _("\
Set the list of expressions to collect by default"), _("\
Show the list of expressions to collect by default"), NULL,
			  NULL, NULL,
			  &setlist, &showlist);

  add_setshow_boolean_cmd ("disconnected-tracing", no_class,
			   &disconnected_tracing, _("\
Set whether tracing continues after GDB disconnects."), _("\
Show whether tracing continues after GDB disconnects."), _("\
Use this to continue a tracing run even if GDB disconnects\n\
or detaches from the target.  You can reconnect later and look at\n\
trace data collected in the meantime."),
			   set_disconnected_tracing,
			   NULL,
			   &setlist,
			   &showlist);

  add_setshow_boolean_cmd ("circular-trace-buffer", no_class,
			   &circular_trace_buffer, _("\
Set target's use of circular trace buffer."), _("\
Show target's use of circular trace buffer."), _("\
Use this to make the trace buffer into a circular buffer,\n\
which will discard traceframes (oldest first) instead of filling\n\
up and stopping the trace run."),
			   set_circular_trace_buffer,
			   NULL,
			   &setlist,
			   &showlist);

  add_setshow_zuinteger_unlimited_cmd ("trace-buffer-size", no_class,
				       &trace_buffer_size, _("\
Set requested size of trace buffer."), _("\
Show requested size of trace buffer."), _("\
Use this to choose a size for the trace buffer.  Some targets\n\
may have fixed or limited buffer sizes.  Specifying \"unlimited\" or -1\n\
disables any attempt to set the buffer size and lets the target choose."),
				       set_trace_buffer_size, NULL,
				       &setlist, &showlist);

  add_setshow_string_cmd ("trace-user", class_trace,
			  &trace_user, _("\
Set the user name to use for current and future trace runs"), _("\
Show the user name to use for current and future trace runs"), NULL,
			  set_trace_user, NULL,
			  &setlist, &showlist);

  add_setshow_string_cmd ("trace-notes", class_trace,
			  &trace_notes, _("\
Set notes string to use for current and future trace runs"), _("\
Show the notes string to use for current and future trace runs"), NULL,
			  set_trace_notes, NULL,
			  &setlist, &showlist);

  add_setshow_string_cmd ("trace-stop-notes", class_trace,
			  &trace_stop_notes, _("\
Set notes string to use for future tstop commands"), _("\
Show the notes string to use for future tstop commands"), NULL,
			  set_trace_stop_notes, NULL,
			  &setlist, &showlist);

  init_tfile_ops ();

  add_target_with_completer (&tfile_ops, filename_completer);
}
@


1.323
log
@tsave: Make tilde-expanded filename visible.

Before:

  (gdb) tsave ~/a/b
  Unable to open file '~/a/b' for saving trace data (No such file or directory)

After:

  (gdb) tsave ~/a/b
  Unable to open file '/home/pedro/a/b' for saving trace data (No such file or directory)

Tested on x86_64 Fedora 17.

gdb/
2013-08-09  Pedro Alves  <palves@@redhat.com>

	* tracepoint.c (tfile_start): Show tilde-expanded filename in
	error message.
@
text
@d2447 1
a2447 1
      print_stack_frame (get_selected_frame (NULL), 1, print_what);
@


1.322
log
@gdb/

	* tracepoint.c (trace_dump_command): Select the current frame.

gdb/testsuite/

	* gdb.trace/backtrace.exp (gdb_backtrace_tdp_4): Test command
	'tdump' on stack frame 0 and 1 respectively.
@
text
@d3166 1
a3166 1
	   filename, safe_strerror (errno));
@


1.321
log
@remove pop_target

This patch fixes the target double-close problem (PR remote/15266),
and in the process removes pop_target entire (PR remote/15256).

The first issue is that pop_target calls target_close.  However, it
then calls unpush_target, which also calls target_close.  This means
targets must be able to be closed twice.  Not only is this strange,
but it also directly contradicts the contract of to_xclose targets.
(We currently have just a single such target, and it is never pushed;
but I plan to add more, and so this latent bug is triggered.)

The second issue is that it seems to me that calling pop_target is
often unsafe.  This is what cropped up in 15256, where the remote
target assumed that it could pop_target -- but there was another
target higher on the stack, leading to confusion.

But, it is always just as easy to call unpush_target as it is to call
pop_target; and it is also safer.  So, removing pop_target seemed like
an improvement.

Finally, this adds an assertion to target_close to ensure that no
currently-pushed target can be closed.

Built and regtested on x86-64 Fedora 18; both natively and using the
native-gdbserver board file.

	PR remote/15256, PR remote/15266:
	* bfd-target.c (target_bfd_reopen): Initialize to_magic.
	* monitor.c (monitor_detach): Use unpush_target.
	* remote-m32r-sdi.c (m32r_detach): Use unpush_target.
	* remote-mips.c (mips_detach): Use unpush_target.  Don't
	call mips_close.
	* remote-sim.c (gdbsim_detach): Use unpush_target.
	* target.c (pop_target): Remove.
	(pop_all_targets_above): Don't call target_close.
	(target_close): Assert that the target is unpushed.
	* target.h (pop_target): Don't declare.
	* tracepoint.c (tfile_open): Use unpush_target.
@
text
@d3068 6
@


1.320
log
@Rely on gnulib's unistd.h replacement.

With gnulib's unistd module, we can assume unistd.h is always present, and that
STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO are always defined.

Don't remove unistd.h from GDB's configure.ac, as later tests in the
file use HAVE_UNISTD_H checks.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Don't check HAVE_UNISTD_H before including <unistd.h>.
	(STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO): Delete.
	* tracepoint.c: Don't check HAVE_UNISTD_H before including
	<unistd.h>.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* event-loop.c: Don't check HAVE_UNISTD_H before including
	<unistd.h>.
	* gdbreplay.c: Likewise.
	* remote-utils.c: Likewise.
	* server.c: Likewise.
	* configure.ac: Don't check for unistd.h.
	* configure: Regenerate.
@
text
@d4369 2
a4370 2
      /* Pop the partially set up target.  */
      pop_target ();
@


1.319
log
@	* tracepoint.c (deprecated_readline_begin_hook)
	(deprecated_readline_hook, deprecated_readline_end_hook): Don't
	declare.
@
text
@a66 1
#ifdef HAVE_UNISTD_H
a67 1
#endif
@


1.318
log
@	Extend tsave to save starttime, stoptime.
@
text
@a89 4
extern void (*deprecated_readline_begin_hook) (char *, ...);
extern char *(*deprecated_readline_hook) (char *);
extern void (*deprecated_readline_end_hook) (void);

@


1.317
log
@	Fix trace-status to output proper start-time and stop-time.
@
text
@d3232 10
@


1.316
log
@gdb/

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* gdb.texinfo (GDB/MI Tracepoint Commands): Document
	-trace-frame-collected.
gdb:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* mi/mi-cmds.c (mi_cmds): Register -trace-frame-collected.
	* mi/mi-cmds.h (mi_cmd_trace_frame_collected): Declare.
	* mi/mi-main.c (print_variable_or_computed): New function.
	(mi_cmd_trace_frame_collected): New function.
	* tracepoint.c (find_trace_state_variable_by_number): New.
	(struct traceframe_info): Move to tracepoint.h
	(struct collection_list): Likewise.
	(do_collect_symbol): Include locals and arguments in the wholly
	collected variables list.
	(clear_collection_list): Clear wholly collected variables list
	and computed variables list.
	(append_exp): New function.
	(encode_actions_1): Include variables in the wholly
	collected variables list.  Include memory ranges and
	full-fledged expressions in the computed expressions list.
	(encode_actions): Move some code to ...
	Return the cleanup chain.
	(encode_actions_rsp): ... here.  New function.
	(get_traceframe_location, get_traceframe_info): Remove static.
	* tracepoint.h (struct memrange): Moved	from tracepoint.c.
	(struct collection_list): Moved from tracepoint.c.  Add two
	new fields 'wholly_collected' and 'computed'.
	(find_trace_state_variable_by_number): Declare.
	(encode_actions): Adjust declaration.
	(encode_actions_rsp): Declare.
	(get_traceframe_info, get_traceframe_location): Declare.

	* NEWS: Mention new MI command -trace-frame-collected.
@
text
@d2128 4
a2131 4
			   (long int) ts->start_time / 1000000,
			   (long int) ts->start_time % 1000000,
			   (long int) run_time / 1000000,
			   (long int) run_time % 1000000);
d2135 2
a2136 2
			 (long int) ts->start_time / 1000000,
			 (long int) ts->start_time % 1000000);
d2140 2
a2141 2
		     (long int) ts->stop_time / 1000000,
		     (long int) ts->stop_time % 1000000);
d2259 2
a2260 2
	       (long int) ts->start_time / 1000000,
	       (long int) ts->start_time % 1000000);
d2263 2
a2264 2
	       (long int) ts->stop_time / 1000000,
	       (long int) ts->stop_time % 1000000);
@


1.315
log
@gdb/

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* ctf.c (ctf_traceframe_info): Push trace state variables
	present in the trace data into the traceframe info object.
	* breakpoint.c (DEF_VEC_I): Remove.
	* common/filestuff.c (DEF_VEC_I): Likewise.
	* dwarf2loc.c (DEF_VEC_I): Likewise.
	* mi/mi-main.c (DEF_VEC_I): Likewise.
	* common/gdb_vecs.h (DEF_VEC_I): Define vector for int.
	* features/traceframe-info.dtd: Add tvar element and its
	attributes.
	* tracepoint.c (free_traceframe_info): Free vector 'tvars'.
	(build_traceframe_info): Push trace state variables present in the
	trace data into the traceframe info object.
	(traceframe_info_start_tvar): New function.
	(tvar_attributes): New.
	(traceframe_info_children): Add "tvar" element.
	* tracepoint.h (struct traceframe_info) <tvars>: New field.

	* NEWS: Mention the change in GDB and GDBserver.

gdb/doc:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Traceframe Info Format): Document tvar element and
	its attributes.

gdb/gdbserver:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>

	* tracepoint.c (build_traceframe_info_xml): Output trace state
	variables present in the trace buffer.
@
text
@d343 16
a871 23
struct memrange
{
  int type;		/* memrange_absolute for absolute memory range,
                           else basereg number.  */
  bfd_signed_vma start;
  bfd_signed_vma end;
};

struct collection_list
  {
    unsigned char regs_mask[32];	/* room for up to 256 regs */
    long listsize;
    long next_memrange;
    struct memrange *list;
    long aexpr_listsize;	/* size of array pointed to by expr_list elt */
    long next_aexpr_elt;
    struct agent_expr **aexpr_list;

    /* True is the user requested a collection of "$_sdata", "static
       tracepoint data".  */
    int strace_data;
  };

d1162 3
d1241 3
d1394 15
d1554 1
d1558 15
a1572 7
		      collect_symbol (collect,
				      exp->elts[2].symbol,
				      tloc->gdbarch,
				      frame_reg,
				      frame_offset,
				      tloc->address,
				      trace_string);
d1608 2
d1663 3
a1665 1
/* Render all actions into gdb protocol.  */
d1667 4
a1670 3
void
encode_actions (struct bp_location *tloc, char ***tdp_actions,
		char ***stepping_actions)
d1677 1
a1677 2
  struct cleanup *back_to;
  struct collection_list tracepoint_list, stepping_list;
d1679 3
a1681 1
  back_to = make_cleanup (null_cleanup, NULL);
d1683 2
a1684 8
  init_collection_list (&tracepoint_list);
  init_collection_list (&stepping_list);

  make_cleanup (do_clear_collection_list, &tracepoint_list);
  make_cleanup (do_clear_collection_list, &stepping_list);

  *tdp_actions = NULL;
  *stepping_actions = NULL;
d1686 1
d1693 17
a1709 1
		    &tracepoint_list, &stepping_list);
d1711 5
a1715 2
  memrange_sortmerge (&tracepoint_list);
  memrange_sortmerge (&stepping_list);
d1720 1
a1720 1
  do_cleanups (back_to);
d2984 1
a2984 1
static struct bp_location *
d5719 1
a5719 1
static struct traceframe_info *
@


1.314
log
@gdb/

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* tracepoint.c (trace_dump_command): Move code to ...
	(get_traceframe_location): ... here.  New.
@
text
@d238 1
d5228 6
d5591 15
d5624 5
d5633 3
@


1.313
log
@gdb/

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* tracepoint.c (trace_dump_command): GDB emits an error
	 instead of a warning when a traceframe is not selected.
@
text
@d2936 42
a3017 2
  struct regcache *regcache;
  struct tracepoint *t;
a3019 2
  char *default_collect_line = NULL;
  struct command_line *actions, *default_collect_action = NULL;
d3021 1
d3023 2
a3024 9
  if (tracepoint_number == -1)
    error (_("No current trace frame."));

  old_chain = make_cleanup (null_cleanup, NULL);
  t = get_tracepoint (tracepoint_number);

  if (t == NULL)
    error (_("No known tracepoint matches 'current' tracepoint #%d."),
	   tracepoint_number);
d3029 2
a3030 16
  /* The current frame is a trap frame if the frame PC is equal
     to the tracepoint PC.  If not, then the current frame was
     collected during single-stepping.  */

  regcache = get_current_regcache ();

  /* If the traceframe's address matches any of the tracepoint's
     locations, assume it is a direct hit rather than a while-stepping
     frame.  (FIXME this is not reliable, should record each frame's
     type.)  */
  stepping_frame = 1;
  for (loc = t->base.loc; loc; loc = loc->next)
    if (loc->address == regcache_read_pc (regcache))
      stepping_frame = 0;

  actions = all_tracepoint_actions_and_cleanup (&t->base);
@


1.312
log
@gdb/

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* tracepoint.c (tracepoint_list, stepping_list): Remove.
	(clear_collection_list): Free fields 'aexpre_list' and 'list'
	in collection_list.
	(do_clear_collection_list, init_collection_list): New.
	(encode_actions): Add local variables 'tracepoint_list' and
	'stepping_list'.  Call init_collection_list and make cleanup
	which calls do_clear_collection_list.  Don't call
	clear_collection_list.
	(_initialize_tracepoint): Delete references to
	'tracepoint_list' and 'stepping_list'.
@
text
@d2985 1
a2985 4
    {
      warning (_("No current trace frame."));
      return;
    }
@


1.311
log
@gdb/

	* tracepoint.c (start_tracing): Move code to ...
	(trace_reset_local_state): ... here.  New.
	(disconnect_tracing): Don't call set_current_traceframe,
	set_tracepoint_num, and set_traceframe_context. Call
	trace_reset_local_state instead.
	(tfile_close): Call trace_reset_local_state.
	* ctf.c (ctf_close): Likewise.
	* remote.c (remote_close): Likewise.
	* tracepoint.h (trace_reset_local_state): Declare.
@
text
@d876 1
a876 2
  }
tracepoint_list, stepping_list;
d1241 29
d1649 1
d1653 5
a1657 2
  clear_collection_list (&tracepoint_list);
  clear_collection_list (&stepping_list);
a5707 27
  if (tracepoint_list.list == NULL)
    {
      tracepoint_list.listsize = 128;
      tracepoint_list.list = xmalloc
	(tracepoint_list.listsize * sizeof (struct memrange));
    }
  if (tracepoint_list.aexpr_list == NULL)
    {
      tracepoint_list.aexpr_listsize = 128;
      tracepoint_list.aexpr_list = xmalloc
	(tracepoint_list.aexpr_listsize * sizeof (struct agent_expr *));
    }

  if (stepping_list.list == NULL)
    {
      stepping_list.listsize = 128;
      stepping_list.list = xmalloc
	(stepping_list.listsize * sizeof (struct memrange));
    }

  if (stepping_list.aexpr_list == NULL)
    {
      stepping_list.aexpr_listsize = 128;
      stepping_list.aexpr_list = xmalloc
	(stepping_list.aexpr_listsize * sizeof (struct agent_expr *));
    }

@


1.310
log
@gdb/
	* tracepoint.c (all_tracepoint_actions_and_cleanup): Declare.
	(encode_actions): Move code to ...
	(all_tracepoint_actions_and_cleanup): ... here.  New.
	(trace_dump_command): Likewise.
@
text
@d1703 10
d1835 1
a1835 3
  set_traceframe_num (-1);
  set_tracepoint_num (-1);
  set_traceframe_context (NULL);
a1836 1
  clear_traceframe_info ();
d2244 1
a2244 3
  set_current_traceframe (-1);
  set_tracepoint_num (-1);
  set_traceframe_context (NULL);
d4665 2
@


1.309
log
@make a cleanup unconditionally in tracepoint.c

This is another cosmetic patch.  It introduces an "outer" cleanup in
trace_dump_command and arranges to unconditionally call do_cleanups.
This lets the checker analyze the function.

	* tracepoint.c (trace_dump_command): Unconditionally call
	do_cleanups.
@
text
@d207 2
d1633 1
a1633 1
  actions = breakpoint_commands (tloc->owner);
a1634 18
  /* If there are default expressions to collect, make up a collect
     action and prepend to the action list to encode.  Note that since
     validation is per-tracepoint (local var "xyz" might be valid for
     one tracepoint and not another, etc), we make up the action on
     the fly, and don't cache it.  */
  if (*default_collect)
    {
      default_collect_line =  xstrprintf ("collect %s", default_collect);
      make_cleanup (xfree, default_collect_line);

      validate_actionline (default_collect_line, tloc->owner);

      default_collect_action = xmalloc (sizeof (struct command_line));
      make_cleanup (xfree, default_collect_action);
      default_collect_action->next = actions;
      default_collect_action->line = default_collect_line;
      actions = default_collect_action;
    }
d2899 35
d2978 1
a2978 17
  actions = breakpoint_commands (&t->base);

  /* If there is a default-collect list, make up a collect command,
     prepend to the tracepoint's commands, and pass the whole mess to
     the trace dump scanner.  We need to validate because
     default-collect might have been junked since the trace run.  */
  if (*default_collect)
    {
      default_collect_line = xstrprintf ("collect %s", default_collect);
      make_cleanup (xfree, default_collect_line);
      validate_actionline (default_collect_line, &t->base);
      default_collect_action = xmalloc (sizeof (struct command_line));
      make_cleanup (xfree, default_collect_action);
      default_collect_action->next = actions;
      default_collect_action->line = default_collect_line;
      actions = default_collect_action;
    }
@


1.308
log
@gdb/
	* tracepoint.c (encode_actions_1): Remove parameter 't'.
	Caller update.
	(encode_actions): Likewise.
	* remote.c (remote_download_tracepoint): Caller update.
	* tracepoint.h (encode_actions): Update declaration.
@
text
@d2926 1
a2926 1
  struct cleanup *old_chain = NULL;
d2934 1
d2968 1
a2968 1
      old_chain = make_cleanup (xfree, default_collect_line);
d2979 1
a2979 2
  if (*default_collect)
    do_cleanups (old_chain);
@


1.307
log
@gdb/
	* tracepoint.c (stringify_collection_list): Remove parameter
	'string'.
	(encode_actions): Caller update.  Remove local variables.
@
text
@a1366 1
		  struct breakpoint *t,
d1599 1
a1599 1
	  encode_actions_1 (action->body_list[0], t, tloc, frame_reg,
d1610 2
a1611 2
encode_actions (struct breakpoint *t, struct bp_location *tloc,
		char ***tdp_actions, char ***stepping_actions)
d1631 1
a1631 1
  actions = breakpoint_commands (t);
d1643 1
a1643 1
      validate_actionline (default_collect_line, t);
d1651 1
a1651 1
  encode_actions_1 (actions, t, tloc, frame_reg, frame_offset,
@


1.306
log
@gdb/

	* tracepoint.c (TFILE_PID): Remove.
	(tfile_open): Don't add thread and inferior.
	(tfile_close): Don't set 'inferior_ptid'.  Don't call
	exit_inferior_silent.
	(tfile_thread_alive): Remove.
	(init_tfile_ops): Don't set field 'to_thread_alive' of
	tfile_ops.

gdb/testsuite/

	* gdb.trace/tfile.exp: Test inferior and thread.
@
text
@d1244 1
a1244 1
stringify_collection_list (struct collection_list *list, char *string)
a1613 1
  static char tdp_buff[2048], step_buff[2048];
d1658 2
a1659 4
  *tdp_actions = stringify_collection_list (&tracepoint_list,
					    tdp_buff);
  *stepping_actions = stringify_collection_list (&stepping_list,
						 step_buff);
@


1.305
log
@	* tracepoint.c (trace_save):  Call the writer's start method.
@
text
@a84 2
#define TFILE_PID (1)

a4274 4
  inferior_appeared (current_inferior (), TFILE_PID);
  inferior_ptid = pid_to_ptid (TFILE_PID);
  add_thread_silent (inferior_ptid);

a4284 2

  post_create_inferior (&tfile_ops, from_tty);
a4656 4
  pid = ptid_get_pid (inferior_ptid);
  inferior_ptid = null_ptid;	/* Avoid confusion from thread stuff.  */
  exit_inferior_silent (pid);

a5140 6
static int
tfile_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  return 1;
}

a5220 1
  tfile_ops.to_thread_alive = tfile_thread_alive;
@


1.304
log
@	PR gdb/7912:
	* Makefile.in (SFILES): Add filestuff.c
	(COMMON_OBS): Add filestuff.o.
	(filestuff.o): New target.
	* auto-load.c (auto_load_objfile_script_1): Use
	gdb_fopen_cloexec.
	* auxv.c (procfs_xfer_auxv): Use gdb_open_cloexec.
	* cli/cli-cmds.c (shell_escape): Call close_most_fds.
	* cli/cli-dump.c (fopen_with_cleanup): Use gdb_fopen_cloexec.
	* common/agent.c (gdb_connect_sync_socket): Use
	gdb_socket_cloexec.
	* common/filestuff.c: New file.
	* common/filestuff.h: New file.
	* common/linux-osdata.c (linux_common_core_of_thread)
	(command_from_pid, commandline_from_pid, print_source_lines)
	(linux_xfer_osdata_shm, linux_xfer_osdata_sem)
	(linux_xfer_osdata_msg, linux_xfer_osdata_modules): Use
	gdb_fopen_cloexec.
	* common/linux-procfs.c (linux_proc_get_int)
	(linux_proc_pid_has_state): Use gdb_fopen_cloexec.
	* config.in, configure: Rebuild.
	* configure.ac: Don't check for sys/socket.h.  Check for
	fdwalk, pipe2.
	* corelow.c (core_open): Use gdb_open_cloexec.
	* dwarf2read.c (write_psymtabs_to_index): Use gdb_fopen_cloexec.
	* fork-child.c (fork_inferior): Call close_most_fds.
	* gdb_bfd.c (gdb_bfd_open): Use gdb_open_cloexec.
	* inf-child.c (inf_child_fileio_readlink): Use gdb_open_cloexec.
	* linux-nat.c (linux_nat_thread_name, linux_proc_pending_signals):
	Use gdb_fopen_cloexec.
	(linux_proc_xfer_partial, linux_proc_xfer_spu): Use
	gdb_open_cloexec.
	(linux_async_pipe): Use gdb_pipe_cloexec.
	* remote-fileio.c (remote_fileio_func_open): Use
	gdb_open_cloexec.
	* remote.c (remote_file_put, remote_file_get): Use
	gdb_fopen_cloexec.
	* ser-pipe.c (pipe_open): Use gdb_socketpair_cloexec,
	close_most_fds.
	* ser-tcp.c (net_open): Use gdb_socket_cloexec.
	* ser-unix.c (hardwire_open): Use gdb_open_cloexec.
	* solib.c (solib_find): Use gdb_open_cloexec.
	* source.c (openp, find_and_open_source): Use gdb_open_cloexec.
	* tracepoint.c (tfile_start): Use gdb_fopen_cloexec.
	(tfile_open): Use gdb_open_cloexec.
	* tui/tui-io.c (tui_initialize_io): Use gdb_pipe_cloexec.
	* ui-file.c (gdb_fopen): Use gdb_fopen_cloexec.
	* xml-support.c (xml_fetch_content_from_file): Use
	gdb_fopen_cloexec.
	* main.c (captured_main): Call notice_open_fds.
gdbserver
	* Makefile.in (SFILES): Add filestuff.c.
	(OBS): Add filestuff.o.
	(filestuff.o): New target.
	* config.in, configure: Rebuild.
	* configure.ac: Check for fdwalk, pipe2.
@
text
@d3344 2
@


1.303
log
@gdb_byte for binary buffer, char for string: remote.c, tracepoint.c.

While the RSP is largely ASCII based (hence the packet buffer type is
char *), at places we pass around 8-bit binary packets in that buffer.
Functions like hex2bin or remote_escape_output conceptually are
handling binary buffers, so I left them as working with gdb_byte, and
added casts where necessary.  Whether these are host bytes or target
bytes is blurry at present, so this is largely a matter of taste.
Switching some of these functions to take "char *" or "void *" would
be equally good.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* remote.c (remote_write_bytes_aux, compare_sections_command)
	(remote_read_qxfer)
	(remote_search_memory, remote_hostio_pwrite, remote_hostio_pread)
	(remote_hostio_readlink, remote_bfd_iovec_pread)
	(remote_set_trace_notes): Use gdb_byte when RSP buffer is used as
	binary buffer, and char when buffer is used as string.
	* tracepoint.c (encode_source_string, tfile_write_uploaded_tp)
	(trace_save, tfile_open, traceframe_walk_blocks)
	(tfile_fetch_registers): Likewise.
@
text
@d58 1
d3070 1
a3070 1
  writer->fp = fopen (writer->pathname, "wb");
a3343 2
  writer->ops->start (writer, filename);

d4200 1
a4200 1
  scratch_chan = open (filename, flags, 0);
@


1.302
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d3003 1
a3003 1
  bin2hex (src, buf + strlen (buf), 0);
d3193 1
a3193 1
  gdb_byte buf[MAX_TRACE_UPLOAD];
d3325 1
d4179 1
a4179 1
  char byte;
d4391 1
a4391 1
	      end = hex2bin (p1, ts->stop_desc, (p2 - p1) / 2);
d4411 1
a4411 1
	      end = hex2bin (p1, ts->stop_desc, (p2 - p1) / 2);
d4465 1
a4465 1
	  end = hex2bin (p1, ts->user_name, (p3 - p1)  / 2);
d4473 1
a4473 1
	  end = hex2bin (p1, ts->notes, (p3 - p1) / 2);
d4869 1
a4869 1
      tfile_read (&block_type, 1);
@


1.301
log
@gdb/

	* tracepoint.c (tfile_interp_line): Fit parameters line and
	utpp in one line.
@
text
@d4924 1
a4924 1
  char *regs;
@


1.300
log
@Accept "set foo unlimited" in integer/uinteger/zuinteger_unlimited commands.

Currently, several commands take "0" or "-1" to mean "unlimited".

"show" knows when to print "unlimited":

 (gdb) show height
 Number of lines gdb thinks are in a page is 45.
 (gdb) set height 0
 (gdb) show height
 Number of lines gdb thinks are in a page is unlimited.

However, the user can't herself specify "unlimited" directly:

 (gdb) set height unlimited
 No symbol table is loaded.  Use the "file" command.
 (gdb)

This patch addresses that, by adjusting the set handler for all
integer/uinteger/zuinteger_unlimited commands to accept literal
"unlimited".  It also installs a completer.  Presently, we complete on
symbols by default, and at
<http://sourceware.org/ml/gdb-patches/2013-03/msg00864.html> I've
shown a WIP prototype that tried to keep that half working in these
commands.  In the end, it turned out to be more complicated than
justifiable, IMO.  It's super rare to want to pass the value of a
variable/symbol in the program to a GDB set/show knob.  That'll still
work, it's just that we won't assist with completion anymore.  This
patch just sticks with the simple, and completes on "unlimited", and
nothing else.  This simplification means that

  "set he<tab><tab>"

is all it takes to get to:

  "set height unlimited"

The patch then goes through all integer/uinteger/zuinteger_unlimited
commands in the tree, and updates both the online help and the manual
to mention that "unlimited" is accepted in addition to 0/-1.  In the
cases where the command had no online help text at all, this adds it.
I've tried to make the texts read in a way that "unlimited" is
suggested before "0" or "-1" is.

Tested on x86_64 Fedora 17.

gdb/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* cli/cli-decode.c (integer_unlimited_completer): New function.
	(add_setshow_integer_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd): Install the "unlimited"
	completer.
	* cli/cli-setshow.c: Include "cli/cli-utils.h".
	(is_unlimited_literal): New function.
	(do_set_command): Handle literal "unlimited" arguments.
	* frame.c (_initialize_frame) <set backtrace limit>: Document
	"unlimited".
	* printcmd.c (_initialize_printcmd) <set print
	max-symbolic-offset>: Add help text.
	* record-full.c (_initialize_record_full) <set record full
	insn-number-max>: Likewise.
	* record.c (_initialize_record) <set record
	instruction-history-size, set record function-call-history-size>:
	Add help text.
	* ser-tcp.c (_initialize_ser_tcp) <set tcp connect-timeout>: Add
	help text.
	* tracepoint.c (_initialize_tracepoint) <set trace-buffer-size>:
	Likewise.
	* source.c (_initialize_source) <set listsize>: Add help text.
	* utils.c (initialize_utils) <set height, set width>: Likewise.
	<set pagination>: Mention "set height unlimited".
	* valprint.c (_initialize_valprint) <set print elements, set print
	repeats>: Document "unlimited".

gdb/doc/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Process Record and Replay): Document that "set
	record full insn-number-max", "set record
	instruction-history-size" and "set record
	function-call-history-size" accept "unlimited".
	(Backtrace): Document that "set backtrace limit" accepts
	"unlimited".
	(List): Document that "set listsize" accepts "unlimited".
	(Print Settings)" Document that "set print max-symbolic-offset",
	"set print elements" and "set print repeats" accept "unlimited".
	(Starting and Stopping Trace Experiments): Document that "set
	trace-buffer-size" accepts "unlimited".
	(Remote Configuration): Document that "set tcp connect-timeout"
	accepts "unlimited".
	(Command History): Document that "set history size" accepts
	"unlimited".
	(Screen Size): Document that "set height" and "set width" accepts
	"unlimited".  Adjust "set pagination"'s description to suggest
	"set height unlimited" instead of "set height 0".

gdb/testsuite/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.base/completion.exp: Test "set height", "set listsize" and
	"set trace-buffer-size" completion.
	* gdb.base/setshow.exp: Test "set height unlimited".
	* gdb.trace/trace-buffer-size.exp: Test "set trace-buffer-size
	unlimited".
@
text
@d4297 2
a4298 2
tfile_interp_line (char *line,
		   struct uploaded_tp **utpp, struct uploaded_tsv **utsvp)
@


1.299
log
@make -gdb-exit call disconnect_tracing too, and don't lose history if the target errors on "quit"

Gareth mentions in PR gdb/15275:

 "The MI '-gdb-exit' command mi_cmd_gdb_exit() never calls disconnect_tracing()
 and therefore exits correctly."

It should, so to get out of tfind mode, as quit may detach instead of
kill, and we don't want to confuse the memory/register accesses
etc. of the detach process.  So we should push down the disconnect
tracing bits at least to quit_force.  But we can't as is, as that
would swallow the error thrown by answering "no" to:

  Trace is running but will stop on detach; detach anyway? (y or n)

So to address that, we split disconnect_tracing in two.  One part that
does the query, and another part that does the rest, and we make
quit_force call the latter.

Looking at quit_force, it does several things, some of which are a bit
independent of the others.  It first kills/detaches, and then writes
history, and then runs the final cleanups.  It seems better to me to
do each of these things even if the previous thing throws.  E.g., as
is, if something throws while detaching, then we skip writing history.

Tested on x86_64 Fedora 17.

gdb/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* cli/cli-cmds.c (quit_command): Call query_if_trace_running
	instead of disconnect_tracing.
	* infcmd.c (detach_command, disconnect_command): Call
	query_if_trace_running.  Adjust.
	* top.c: Include "tracepoint.h".
	(quit_target): Delete.  Contents moved ...
	(quit_force): ... here.  Wrap each stage of teardown in
	TRY_CATCH.  Call disconnect_tracing before detaching.
@
text
@d5887 2
a5888 2
may have fixed or limited buffer sizes.  A value of -1 disables\n\
any attempt to set the buffer size and lets the target choose."),
@


1.298
log
@gdb/

2013-04-10  Hui Zhu  <hui@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* configure.ac: Check libbabeltrace is installed.
	* config.in: Regenerate.
	* configure: Regenerate.
	* Makefile.in (LIBBABELTRACE): New.
	(CLIBS): Add LIBBABELTRACE.
	* ctf.c: Include "exec.h".
	(CTF_EVENT_ID_STATUS, CTF_EVENT_ID_TSV_DEF): New macros.
	(CTF_EVENT_ID_TP_DEF, ctf_save_write_int32): New macros.
	(ctf_save_metadata_header): Define new type aliases in
	metadata.
	(ctf_write_header): Define event type "tsv_def" and "tp_def"
	in metadata.  Start a new faked packet for trace status.
	(ctf_write_status): Write trace status to CTF.
	(ctf_write_uploaded_tsv): Write TSV to CTF.
	(ctf_write_uploaded_tp): Write tracepoint definition to CTF.
	(ctf_write_definition_end): End the faked packet.

	(ctx, ctf_iter, trace_dirname): New.
	(start_pos): New variable.
	(ctf_destroy, ctf_open_dir, ctf_open): New.
	(SET_INT32_FIELD, SET_ARRAY_FIELD, SET_STRING_FIELD): New
	macros.
	(ctf_read_tsv, ctf_read_tp, ctf_close, ctf_files_info): New.
	(ctf_fetch_registers, ctf_xfer_partial): New.
	(ctf_get_trace_state_variable_value): New.
	(ctf_get_tpnum_from_frame_event): New.
	(ctf_get_traceframe_address): New.
	(ctf_trace_find, ctf_has_stack): New.
	(ctf_has_registers, ctf_traceframe_info, init_ctf_ops): New.
	(ctf_get_trace_status, ctf_read_status): New.
	(_initialize_ctf): New.
	* tracepoint.c (get_tracepoint_number): New
	(get_uploaded_tsv): Remove 'static'.
 	(struct traceframe_info, trace_regblock_size): Move it to ...
	* tracepoint.h: ... here.
	(get_tracepoint_number): Declare it.
	(get_uploaded_tsv): Declare it.

	* NEWS: Mention new configure option.

gdb/doc/

2013-04-10  Yao Qi  <yao@@codesourcery.com>

	* gdb.texinfo (Trace Files): Add "target ctf".

gdb/testsuite/

2013-04-10  Yao Qi  <yao@@codesourcery.com>

	* gdb.trace/actions.exp: Save trace data to CTF.
	Change to ctf target if GDB supports, read CTF data in ctf
	target, and check the actions of tracepoints.
	* gdb.trace/while-stepping.exp: Likewise.
	* gdb.trace/report.exp: Test GDB saves trace data to CTF
	format and read CTF trace file if GDB supports.
	* gdb.trace/tstatus.exp: Save trace data to CTF.  If ctf
	target is supported, change to ctf target, read trace data and
	check output of command "tstatus".
	* gdb.trace/tsv.exp: Save trace frame to CTF.  If GDB supports,
	read CTF data by target ctf and call check_tsv.
@
text
@d2207 3
a2209 3
/* This function handles the details of what to do about an ongoing
   tracing run if the user has asked to detach or otherwise disconnect
   from the target.  */
d2211 1
a2211 1
disconnect_tracing (int from_tty)
d2213 3
d2228 1
a2228 1
  if (current_trace_status ()->running && from_tty)
d2245 1
d2247 7
@


1.297
log
@gdb/
	* remote.c (remote_trace_find): Change type of parameters 'addr1'
	and 'addr2' to CORE_ADDR.
	* target.c (update_current_target): Update.
	* target.h (struct target_ops) <to_trace_find>: Change parameter
	type to CORE_ADDR.
	* tracepoint.c (tfind_1): Change type of parameters 'addr1' and
	'addr2' to CORE_ADDR.
	(tfile_trace_find): Likewise.
	(tfile_get_traceframe_address): Change return type to CORE_ADDR.
	Change local variable 'addr' to type CORE_ADDR.
	* tracepoint.h (tfind_1): Update declaration.
@
text
@a129 8
/* An object describing the contents of a traceframe.  */

struct traceframe_info
{
  /* Collected memory.  */
  VEC(mem_range_s) *memory;
};

a3297 2
extern int trace_regblock_size;

d3734 6
d3858 1
a3858 1
static struct uploaded_tsv *
@


1.296
log
@gdb/

2013-03-29  Yao Qi  <yao@@codesourcery.com>

	* corelow.c: Include "completer.h".
	(_initialize_corelow): Call add_target_with_completer with
	argument 'filename_completer'.
	* tracepoint.c: Likewise.
	* exec.c (_initialize_exec): Likewise.
	* target.c (add_target): Rename to ...
	(add_target_with_completer): ... this.  Call set_cmd_completer
	if parameter completer is not NULL.
	(add_target): New.
	* target.h: Include "command.h".
	(add_target_with_completer): Declare it.

gdb/testsuite:

2013-03-29  Yao Qi  <yao@@codesourcery.com>

	* gdb.base/completion.exp: Test completion of commands
	"target core", "target tfile" and "target exec".
	* gdb.trace/tfile.exp: Test completion of command
	"target tfile".
@
text
@d2263 1
a2263 1
	 ULONGEST addr1, ULONGEST addr2,
d4695 1
a4695 1
static ULONGEST
d4698 1
a4698 1
  ULONGEST addr = 0;
d4730 1
a4730 1
		  ULONGEST addr1, ULONGEST addr2, int *tpp)
d4737 1
a4737 1
  ULONGEST tfaddr;
@


1.295
log
@	* tracepoint.h (decode_agent_options): Add 'trace_string'
	argument.
	* tracepoint.c (decode_agent_options): Add 'trace_string'
	argument.
	(validate_actionline): Update.
	(collect_symbol): Add 'trace_string' argument.
	(struct add_local_symbols_data) <trace_string>: New field.
	(do_collect_symbol): Update.
	(add_local_symbols): Add 'trace_string' argument.
	(encode_actions_1): Update.
	(trace_dump_actions): Update.
	* dwarf2loc.c (access_memory): Update.
	* ax.h (struct agent_expr) <tracing, trace_string>: New fields.
	* ax-general.c (new_agent_expr): Update.
	* ax-gdb.h (gen_trace_for_expr, gen_trace_for_var)
	(gen_trace_for_return_address): Add argument.
	(trace_kludge, trace_string_kludge): Remove.
	* ax-gdb.c (trace_kludge, trace_string_kludge): Remove.
	(gen_traced_pop, gen_fetch, gen_bitfield_ref, gen_expr): Update.
	(gen_trace_for_var): Add 'trace_string' argument.
	(gen_trace_for_expr, gen_trace_for_return_address): Likewise.
	(gen_printf, agent_eval_command_one): Update.
@
text
@d57 1
d5908 1
a5908 1
  add_target (&tfile_ops);
@


1.294
log
@	* ax-gdb.c (gen_var_ref): Unconditionally call via computed ops,
	if possible.
	* dwarf2read.c (read_func_scope): Remove old FIXME.
	* eval.c (evaluate_subexp_standard): Check SYMBOL_COMPUTED_OPS,
	not LOC_COMPUTED.
	* findvar.c (symbol_read_needs_frame, default_read_var_value):
	Unconditionally call via computed ops, if possible.
	* printcmd.c (address_info): Unconditionally call via computed ops,
	if possible.
	* stack.c (read_frame_arg): Unconditionally call via computed ops,
	if possible.
	* symtab.c (register_symbol_computed_impl): Sanity check 'ops'.
	* tracepoint.c (scope_info): Unconditionally call via computed ops,
	if possible.
@
text
@d615 1
a615 1
decode_agent_options (const char *exp)
d619 2
d636 1
a636 1
	  trace_string_kludge = opts.print_max;
d639 1
a639 1
	    trace_string_kludge = atoi (exp);
d736 2
a737 1
      trace_string_kludge = 0;
d739 1
a739 1
	p = decode_agent_options (p);
d788 1
a788 1
	      aexpr = gen_trace_for_expr (loc->address, exp);
d995 2
a996 1
		CORE_ADDR scope)
d1107 1
a1107 1
      aexpr = gen_trace_for_var (scope, gdbarch, sym);
d1160 1
d1173 1
a1173 1
		  p->frame_offset, p->pc);
d1181 2
a1182 1
		   long frame_regno, long frame_offset, int type)
d1193 1
d1401 2
a1402 1
	  trace_string_kludge = 0;
d1404 1
a1404 1
	    action_exp = decode_agent_options (action_exp);
d1424 2
a1425 1
				     'A');
d1435 2
a1436 1
				     'L');
d1444 2
a1445 1
							tloc->gdbarch);
d1526 2
a1527 1
				      tloc->address);
d1531 2
a1532 1
		      aexpr = gen_trace_for_expr (tloc->address, exp);
d2862 1
d2865 1
a2865 1
		action_exp = decode_agent_options (action_exp);
@


1.293
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@d2681 6
a2686 1
	  switch (SYMBOL_CLASS (sym))
d2688 1
a2688 79
	    default:
	    case LOC_UNDEF:	/* Messed up symbol?  */
	      printf_filtered ("a bogus symbol, class %d.\n",
			       SYMBOL_CLASS (sym));
	      count--;		/* Don't count this one.  */
	      continue;
	    case LOC_CONST:
	      printf_filtered ("a constant with value %s (%s)",
			       plongest (SYMBOL_VALUE (sym)),
			       hex_string (SYMBOL_VALUE (sym)));
	      break;
	    case LOC_CONST_BYTES:
	      printf_filtered ("constant bytes: ");
	      if (SYMBOL_TYPE (sym))
		for (j = 0; j < TYPE_LENGTH (SYMBOL_TYPE (sym)); j++)
		  fprintf_filtered (gdb_stdout, " %02x",
				    (unsigned) SYMBOL_VALUE_BYTES (sym)[j]);
	      break;
	    case LOC_STATIC:
	      printf_filtered ("in static storage at address ");
	      printf_filtered ("%s", paddress (gdbarch,
					       SYMBOL_VALUE_ADDRESS (sym)));
	      break;
	    case LOC_REGISTER:
	      /* GDBARCH is the architecture associated with the objfile
		 the symbol is defined in; the target architecture may be
		 different, and may provide additional registers.  However,
		 we do not know the target architecture at this point.
		 We assume the objfile architecture will contain all the
		 standard registers that occur in debug info in that
		 objfile.  */
	      regno = SYMBOL_REGISTER_OPS (sym)->register_number (sym,
								  gdbarch);

	      if (SYMBOL_IS_ARGUMENT (sym))
		printf_filtered ("an argument in register $%s",
				 gdbarch_register_name (gdbarch, regno));
	      else
		printf_filtered ("a local variable in register $%s",
				 gdbarch_register_name (gdbarch, regno));
	      break;
	    case LOC_ARG:
	      printf_filtered ("an argument at stack/frame offset %s",
			       plongest (SYMBOL_VALUE (sym)));
	      break;
	    case LOC_LOCAL:
	      printf_filtered ("a local variable at frame offset %s",
			       plongest (SYMBOL_VALUE (sym)));
	      break;
	    case LOC_REF_ARG:
	      printf_filtered ("a reference argument at offset %s",
			       plongest (SYMBOL_VALUE (sym)));
	      break;
	    case LOC_REGPARM_ADDR:
	      /* Note comment at LOC_REGISTER.  */
	      regno = SYMBOL_REGISTER_OPS (sym)->register_number (sym,
								  gdbarch);
	      printf_filtered ("the address of an argument, in register $%s",
			       gdbarch_register_name (gdbarch, regno));
	      break;
	    case LOC_TYPEDEF:
	      printf_filtered ("a typedef.\n");
	      continue;
	    case LOC_LABEL:
	      printf_filtered ("a label at address ");
	      printf_filtered ("%s", paddress (gdbarch,
					       SYMBOL_VALUE_ADDRESS (sym)));
	      break;
	    case LOC_BLOCK:
	      printf_filtered ("a function at address ");
	      printf_filtered ("%s",
		paddress (gdbarch, BLOCK_START (SYMBOL_BLOCK_VALUE (sym))));
	      break;
	    case LOC_UNRESOLVED:
	      msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym),
					    NULL, NULL);
	      if (msym == NULL)
		printf_filtered ("Unresolved Static");
	      else
d2690 70
a2759 1
		  printf_filtered ("static storage at address ");
d2761 20
a2780 1
		    paddress (gdbarch, SYMBOL_VALUE_ADDRESS (msym)));
a2781 9
	      break;
	    case LOC_OPTIMIZED_OUT:
	      printf_filtered ("optimized out.\n");
	      continue;
	    case LOC_COMPUTED:
	      SYMBOL_COMPUTED_OPS (sym)->describe_location (sym,
							    BLOCK_START (block),
							    gdb_stdout);
	      break;
@


1.292
log
@gdb/
	* tracepoint.c (tfile_write_status): Write 'stop_desc' of trace
	status to tfile if trace is stopped by command 'tstop'.
@
text
@d4628 1
a4628 1
tfile_close (int quitting)
@


1.291
log
@gdb/
	* tracepoint.c (tfile_write_status): Write trace notes and user
	name into tfile if they are not NULL.
@
text
@d3093 2
a3094 1
  if (ts->stop_reason == tracepoint_error)
@


1.290
log
@gdb/
2013-03-14  Hui Zhu  <hui@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* Makefile.in (REMOTE_OBS): Add ctf.o.
	(SFILES): Add ctf.c.
	(HFILES_NO_SRCDIR): Add ctf.h.
	* ctf.c, ctf.h: New files.
	* tracepoint.c: Include 'ctf.h'.
	(collect_pseudocommand): Remove static.
	(trace_save_command): Parse option "-ctf".
	Produce different trace file writers per option.
	Adjust output message.
	(trace_save_tfile, trace_save_ctf): New.
	* tracepoint.h (trace_save_tfile, trace_save_ctf): Declare.
	* mi/mi-main.c: Include 'ctf.h'.
	(mi_cmd_trace_save): Handle option '-ctf'.  Call either
	trace_save_tfile or trace_save_ctf.
	* NEWS: Mention these changes.

gdb/doc/
2013-03-14  Hui Zhu  <hui@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* gdb.texinfo (Trace Files): Add "tsave -ctf".
@
text
@d3113 14
@


1.289
log
@gdb/
	* tracepoint.c (trace_file_writer_xfree): New.
	(struct tfile_writer_data): New.
	(tfile_dtor, tfile_can_target_save, tfile_start): New.
	(tfile_write_header, tfile_write_regblock_type): New.
	(tfile_write_status, tfile_write_uploaded_tsv): New.
	(tfile_write_uploaded_tp, tfile_write_definition_end): New.
	(tfile_write_raw_data, (tfile_end): New.
	(tfile_write_ops): New global variable.
	(TRACE_WRITE_R_BLOCK): New macro.
	(TRACE_WRITE_M_BLOCK_HEADER): New macro.
	(TRACE_WRITE_M_BLOCK_MEMORY): New macro.
	(TRACE_WRITE_V_BLOCK): New macro.
	(trace_save): Add extra one parameter WRITER.  Make it static.
	Use WRITER to writer trace.
	(tfile_trace_file_writer_new): New.
	(trace_save_command): Caller update.
	(trace_save_tfile): Write trace data in TFILE format.
	* tracepoint.h (struct trace_frame_write_ops): New.
	(struct trace_file_write_ops): New.
	(struct trace_file_writer): New.
	(trace_save): Remove its declaration.
	(trace_save_tfile): Declare it.
	* mi/mi-main.c (mi_cmd_trace_save): Call trace_save_tfile
	instead of trace_save.
@
text
@d56 1
d3548 1
d3561 2
d3572 4
a3575 1
  writer = tfile_trace_file_writer_new ();
d3582 2
a3583 1
    printf_filtered (_("Trace data saved to file '%s'.\n"), filename);
d3602 15
d5683 1
@


1.288
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d2982 287
d3271 4
a3274 3
/* Save tracepoint data to file named FILENAME.  If TARGET_DOES_SAVE is
   non-zero, the save is performed on the target, otherwise GDB obtains all
   trace data and saves it locally.  */
d3276 3
a3278 2
void
trace_save (const char *filename, int target_does_save)
a3279 2
  struct cleanup *cleanup;
  char *pathname;
d3281 1
a3281 2
  int err, status;
  FILE *fp;
d3284 1
a3284 3
  int a;
  char *act;
  LONGEST gotten = 0;
a3285 1
#define MAX_TRACE_UPLOAD 2000
d3288 1
d3294 1
a3294 2
      err = target_save_trace_data (filename);
      if (err < 0)
d3304 1
a3304 2
  pathname = tilde_expand (filename);
  cleanup = make_cleanup (xfree, pathname);
d3306 1
a3306 12
  fp = fopen (pathname, "wb");
  if (!fp)
    error (_("Unable to open file '%s' for saving trace data (%s)"),
	   filename, safe_strerror (errno));
  make_cleanup_fclose (fp);

  /* Write a file header, with a high-bit-set char to indicate a
     binary file, plus a hint as what this file is, and a version
     number in case of future needs.  */
  written = fwrite ("\x7fTRACE0\n", 8, 1, fp);
  if (written < 1)
    perror_with_name (pathname);
d3311 1
a3311 1
  fprintf (fp, "R %x\n", trace_regblock_size);
d3314 1
a3314 23
  fprintf (fp, "status %c;%s",
	   (ts->running ? '1' : '0'), stop_reason_names[ts->stop_reason]);
  if (ts->stop_reason == tracepoint_error)
    {
      char *buf = (char *) alloca (strlen (ts->stop_desc) * 2 + 1);

      bin2hex ((gdb_byte *) ts->stop_desc, buf, 0);
      fprintf (fp, ":%s", buf);
    }
  fprintf (fp, ":%x", ts->stopping_tracepoint);
  if (ts->traceframe_count >= 0)
    fprintf (fp, ";tframes:%x", ts->traceframe_count);
  if (ts->traceframes_created >= 0)
    fprintf (fp, ";tcreated:%x", ts->traceframes_created);
  if (ts->buffer_free >= 0)
    fprintf (fp, ";tfree:%x", ts->buffer_free);
  if (ts->buffer_size >= 0)
    fprintf (fp, ";tsize:%x", ts->buffer_size);
  if (ts->disconnected_tracing)
    fprintf (fp, ";disconn:%x", ts->disconnected_tracing);
  if (ts->circular_buffer)
    fprintf (fp, ";circular:%x", ts->circular_buffer);
  fprintf (fp, "\n");
d3329 1
a3329 16
    {
      char *buf = "";

      if (utsv->name)
	{
	  buf = (char *) xmalloc (strlen (utsv->name) * 2 + 1);
	  bin2hex ((gdb_byte *) (utsv->name), buf, 0);
	}

      fprintf (fp, "tsv %x:%s:%x:%s\n",
	       utsv->number, phex_nz (utsv->initial_value, 8),
	       utsv->builtin, buf);

      if (utsv->name)
	xfree (buf);
    }
d3339 1
a3339 41
    {
      fprintf (fp, "tp T%x:%s:%c:%x:%x",
	       utp->number, phex_nz (utp->addr, sizeof (utp->addr)),
	       (utp->enabled ? 'E' : 'D'), utp->step, utp->pass);
      if (utp->type == bp_fast_tracepoint)
	fprintf (fp, ":F%x", utp->orig_size);
      if (utp->cond)
	fprintf (fp, ":X%x,%s", (unsigned int) strlen (utp->cond) / 2,
		 utp->cond);
      fprintf (fp, "\n");
      for (a = 0; VEC_iterate (char_ptr, utp->actions, a, act); ++a)
	fprintf (fp, "tp A%x:%s:%s\n",
		 utp->number, phex_nz (utp->addr, sizeof (utp->addr)), act);
      for (a = 0; VEC_iterate (char_ptr, utp->step_actions, a, act); ++a)
	fprintf (fp, "tp S%x:%s:%s\n",
		 utp->number, phex_nz (utp->addr, sizeof (utp->addr)), act);
      if (utp->at_string)
	{
	  encode_source_string (utp->number, utp->addr,
				"at", utp->at_string, buf, MAX_TRACE_UPLOAD);
	  fprintf (fp, "tp Z%s\n", buf);
	}
      if (utp->cond_string)
	{
	  encode_source_string (utp->number, utp->addr,
				"cond", utp->cond_string,
				buf, MAX_TRACE_UPLOAD);
	  fprintf (fp, "tp Z%s\n", buf);
	}
      for (a = 0; VEC_iterate (char_ptr, utp->cmd_strings, a, act); ++a)
	{
	  encode_source_string (utp->number, utp->addr, "cmd", act,
				buf, MAX_TRACE_UPLOAD);
	  fprintf (fp, "tp Z%s\n", buf);
	}
      fprintf (fp, "tp V%x:%s:%x:%s\n",
	       utp->number, phex_nz (utp->addr, sizeof (utp->addr)),
	       utp->hit_count,
	       phex_nz (utp->traceframe_usage,
			sizeof (utp->traceframe_usage)));
    }
d3344 1
a3344 1
  fprintf (fp, "\n");
d3346 1
a3346 3
  /* Get and write the trace data proper.  We ask for big blocks, in
     the hopes of efficiency, but will take less if the target has
     packet size limitations or some such.  */
d3349 171
a3519 10
      gotten = target_get_raw_trace_data (buf, offset, MAX_TRACE_UPLOAD);
      if (gotten < 0)
	error (_("Failure to get requested trace buffer data"));
      /* No more data is forthcoming, we're done.  */
      if (gotten == 0)
	break;
      written = fwrite (buf, gotten, 1, fp);
      if (written < 1)
	perror_with_name (pathname);
      offset += gotten;
d3522 14
a3535 4
  /* Mark the end of trace data.  (We know that gotten is 0 at this point.)  */
  written = fwrite (&gotten, 4, 1, fp);
  if (written < 1)
    perror_with_name (pathname);
d3537 1
a3537 1
  do_cleanups (cleanup);
d3547 1
d3568 5
a3572 1
  trace_save (filename, target_does_save);
d3580 14
@


1.287
log
@	* tracepoint.c (tfile_get_trace_state_variable_value): Look for
	the last matched 'V' blcok in trace frame.

gdb/gdbserver:

	* tracepoint.c (traceframe_read_tsv): Look for the last matched
	'V' block in trace frame.

gdb/testsuite:

	* gdb.trace/tsv.exp (check_tsv): New.
	(top level): Save a tfile on current trace session. Call
	check_tsv on live target.  Load the tfile with target tfile
	and call check_tsv again.
@
text
@d613 2
a614 2
char *
decode_agent_options (char *exp)
d646 1
a646 1
  exp = skip_spaces (exp);
d703 1
a703 1
validate_actionline (char **line, struct breakpoint *b)
d708 2
a709 1
  char *p, *tmp_p;
d715 1
a715 1
  if (*line == NULL)
d718 1
a718 1
  p = skip_spaces (*line);
d740 1
a740 1
	  p = skip_spaces (p);
d758 2
a759 4
	      const char *q;

	      q = tmp_p;
	      exp = parse_exp_1 (&q, loc->address,
a760 1
	      p = (char *) q;
d805 1
a805 1
	  p = skip_spaces (p);
d810 1
a810 1
	      const char *q;
a811 1
	      q = tmp_p;
d813 1
a813 1
	      exp = parse_exp_1 (&q, loc->address,
a814 1
	      p = (char *) q;
d837 1
a837 4
      char *steparg;		/* In case warning is necessary.  */

      p = skip_spaces (p);
      steparg = p;
d839 5
a843 2
      if (*p == '\0' || (t->step_count = strtol (p, &p, 0)) == 0)
	error (_("while-stepping step count `%s' is malformed."), *line);
d850 1
a850 1
    error (_("`%s' is not a supported tracepoint action."), *line);
d1374 1
a1374 1
  char *action_exp;
d1385 1
a1385 1
      action_exp = skip_spaces (action_exp);
d1400 1
a1400 1
	      action_exp = skip_spaces (action_exp);
a1474 1
		  const char *q;
d1476 1
a1476 2
		  q = action_exp;
		  exp = parse_exp_1 (&q, tloc->address,
a1477 1
		  action_exp = (char *) q;
d1561 1
a1561 1
	      action_exp = skip_spaces (action_exp);
a1565 1
		  const char *q;
d1567 1
a1567 2
		  q = action_exp;
		  exp = parse_exp_1 (&q, tloc->address,
a1568 1
		  action_exp = (char *) q;
a1635 2
      char *line;

d1639 1
a1639 2
      line = default_collect_line;
      validate_actionline (&line, t);
d1644 1
a1644 1
      default_collect_action->line = line;
a2789 9
/* worker function (cleanup) */
static void
replace_comma (void *data)
{
  char *comma = data;
  *comma = ',';
}


d2801 1
a2801 1
  char *action_exp, *next_comma;
d2809 1
a2809 1
      action_exp = skip_spaces (action_exp);
d2839 4
d2851 1
a2851 1
		  action_exp = skip_spaces (action_exp);
d2865 1
a2865 1
		      if (next_comma)
d2867 12
a2878 2
			  make_cleanup (replace_comma, next_comma);
			  *next_comma = '\0';
d2880 3
a2882 2
		      printf_filtered ("%s = ", action_exp);
		      output_command (action_exp, from_tty);
a2884 2
		  if (next_comma)
		    *next_comma = ',';
d2888 2
d2904 1
a2904 1
  char *line, *default_collect_line = NULL;
d2948 1
a2948 2
      line = default_collect_line;
      validate_actionline (&line, &t->base);
d2952 1
a2952 1
      default_collect_action->line = line;
@


1.286
log
@	* ada-lang.c (ada_read_renaming_var_value): Pass const
	pointer to expression string to parse_exp_1.
	(create_excep_cond_exprs): Likewise.
	* ax-gdb.c (agent_eval_command_one): Likewise.
	(maint_agent_printf_command): Likewise.
	Constify much of the string handling/parsing.
	* breakpoint.c (set_breakpoint_condition): Pass const
	pointer to expression string to parse_exp_1.
	(update_watchpoint): Likewise.
	(parse_cmd_to_aexpr): Constify string handling.
	Pass const pointer to parse_exp_1.
	(init_breakpoint_sal): Pass const pointer to parse_exp_1.
	(find_condition_and_thread): Likewise.
	Make TOK const.
	(watch_command_1): Make "arg" const.
	Constify string handling.
	Copy the expression string instead of changing the input
	string.
	(update_breakpoint_location): Pass const pointer to
	parse_exp_1.
	* eval.c (parse_and_eval_address): Make "exp" const.
	(parse_to_comma_and_eval): Make "expp" const.
	(parse_and_eval): Make "exp" const.
	* expression.h (parse_expression): Make argument const.
	(parse_exp_1): Make first argument const.
	* findcmd.c (parse_find_args): Treat "args" as const.
	* linespec.c (parse_linespec): Pass const pointer to
	linespec_expression_to_pc.
	(linespec_expression_to_pc): Make "exp_ptr" const.
	* parse.c (parse_exp_1): Make "stringptr" const.
	Make a copy of the expression to pass to parse_exp_in_context until
	this whole interface can be constified.
	(parse_expression): Make "string" const.
	* printcmd.c (ui_printf): Treat "arg" as const.
	Handle const strings.
	* tracepoint.c (validate_actionline): Pass const pointer to
	all calls to parse_exp_1.
	(encode_actions_1): Likewise.
	* value.h (parse_to_comma_and_eval): Make argument const.
	(parse_and_eval_address): Likewise.
	(parse_and_eval): Likewise.
	* varobj.c (varobj_create): Pass const pointer to parse_exp_1.
	(varobj_set_value): Likewise.
	* cli/cli-cmds.c (disassemble_command): Treat "arg" as const and
	constify string handling.
	Pass const pointers to parse_and_eval_address and
	parse_to_comman_and_eval.
	* cli/cli-utils.c (skip_to_space): Rename to ...
	(skip_to_space_const): ... this. Handle const strings.
	* cli/cli-utils.h (skip_to_space): Turn into macro which invokes
	skip_to_space_const.
	(skip_to_space_const): Declare.
	* common/format.c (parse_format_string): Make "arg" const.
	Handle const strings.
	* common/format.h (parse_format_string): Make "arg" const.
	* gdbserver/ax.c (ax_printf): Make "format" const.
	* python/python.c (gdbpy_parse_and_eval): Do not make a copy
	of the expression string.
@
text
@d4658 1
d4660 4
d4679 1
a4679 1
	  return 1;
d4684 1
a4684 2
  /* Didn't find anything.  */
  return 0;
@


1.285
log
@gdb/

	* tracepoint.c (_initialize_tracepoint): Indent the code.
@
text
@d757 4
a760 2
	      p = tmp_p;
	      exp = parse_exp_1 (&p, loc->address,
d762 1
d812 3
a814 1
	      p = tmp_p;
d816 1
a816 1
	      exp = parse_exp_1 (&p, loc->address,
d818 1
d1479 1
d1481 2
a1482 1
		  exp = parse_exp_1 (&action_exp, tloc->address,
d1484 1
d1573 1
d1575 2
a1576 1
		  exp = parse_exp_1 (&action_exp, tloc->address,
d1578 1
@


1.284
log
@2012-03-08  Stan Shebs  <stan@@codesourcery.com>
	    Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	gdb/
	* NEWS: Mention set and show trace-buffer-size commands.
	Mention new packet.
	* target.h (struct target_ops): New method
	to_set_trace_buffer_size.
	(target_set_trace_buffer_size): New macro.
	* target.c (update_current_target): Set up new method.
	* tracepoint.c (trace_buffer_size): New global.
	(start_tracing): Send it to the target.
	(set_trace_buffer_size): New function.
	(_initialize_tracepoint): Add new setshow for trace-buffer-size.
	* remote.c (remote_set_trace_buffer_size): New function.
	(_initialize_remote): Use it.
	(QTBuffer:size) New remote command.
	(PACKET_QTBuffer_size): New enum.
	(remote_protocol_features): Add an entry for
	PACKET_QTBuffer_size.

	gdb/gdbserver/
	* tracepoint.c (trace_buffer_size): New global.
	(DEFAULT_TRACE_BUFFER_SIZE): New define.
	(init_trace_buffer): Change to one-argument function. Allocate
	trace buffer memory.
	(handle_tracepoint_general_set): Call cmd_bigqtbuffer_size to
	handle QTBuffer:size packet.
	(cmd_bigqtbuffer_size): New function.
	(initialize_tracepoint): Call init_trace_buffer with
	DEFAULT_TRACE_BUFFER_SIZE.
	* server.c (handle_query): Add QTBuffer:size in the
	supported packets.

	gdb/doc/
	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	trace-buffer-size set and show commands.
	(Tracepoint Packets): Document QTBuffer:size.
	(General Query Packets): Document QTBuffer:size.

	gdb/testsuite/
	* gdb.trace/trace-buffer-size.exp: New file.
	* gdb.trace/trace-buffer-size.c: New file.
@
text
@d5426 1
a5426 1
			    &trace_buffer_size, _("\
d5432 2
a5433 2
			    set_trace_buffer_size, NULL,
			    &setlist, &showlist);
@


1.283
log
@	* breakpoint.c (catch_syscall_split_args): Use skip_spaces.
	(trace_pass_command): Likewise.
	* cli/cli-cmds.c: Include cli/cli-utils.h.
	(source_command): Use skip-spaces.
	(disassemble_command): Likewise.
	* findcmd.c: Include cli/cli-utils.h.
	(parse_find_args): Use skip_spaces.
	* go32-nat.c: Include cli/cli-utils.h.
	(go32_sldt): Use skip_spaces.
	(go32_sgdt): Likewise.
	(go32_sidt): Likewise.
	(go32_pde): Likewise.
	(go32_pte): Likewise.
	(go32_pte_for_address): Likewise.
	* infcmd.c: Include cli/cli-utils.h.
	(registers_info): Use skip_spaces.
	* linux-tdep.c (read_mapping): Use skip_spaces_const.
	(linux_info_proc): Likewise.
	* linux-thread-db.c: Include cli/cli-utils.h.
	(info_auto_load_libthread_db): Use skip_spaces_const.
	* m32r-rom.c: Include cli/cli-utils.h.
	(m32r_upload_command): Use skip_spaces.
	* maint.c: Include cli/cli-utils.h.
	(maintenance_translate_address): Use skip_spaces.
	* mi/mi-parse.c: Include cli/cli-utils.h.
	(mi_parse_argv): Use skip_spaces.
	(mi_parse): Likewise.
	* minsyms.c: Include cli/cli-utils.h.
	(msymbol_hash_iw): Use skip_spaces_const.
	* objc-lang.c: Include cli/cli-utils.h.
	(parse_selector): Use skip_spaces.
	(parse_method): Likewise.
	* python/python.c: Include cli/cli-utils.h.
	(python_interactive_command)[HAVE_PYTHON]: Use skip_spaces.
	(python_command)[HAVE_PYTHON]: Likewise.
	(python_interactive_command)[!HAVE_PYTHON]: Likewise.
	* remote-m32r-sdi.c: Include cli/cli-utils.h.
	(m32r_load): Use skip_spaces.
	* serial.c: Include cli/cli-utils.h.
	(serial_open): Use skip_spaces_const.
	* stack.c: Include cli/cli-utils.h.
	(parse_frame_specification_1): Use skip_spaces_const.
	* symfile.c: Include cli/cli-utils.h.
	(set_ext_lang_command): Use skip_spaces.
	* symtab.c: Include cli/cli-utils.h.
	(rbreak_command): Use skip_spaces.
	* thread.c (thread_name_command): Use skip_spaces.
	* tracepoint.c (validate_actionline): Use skip_spaces.
	(encode_actions_1): Likewise.
	(trace_find_range_command): Likewise.
	(trace_find_outside_command): Likewise.
	(trace_dump_actions): Likewise.
@
text
@d173 5
d1827 1
d3226 7
d5425 10
@


1.282
log
@hex2bin, bin2hex: move declarations to header.

Move the declarations to a header, rather than declaring them in
(multiple) .c files.

gdb/
2013-03-07  Pedro Alves  <palves@@redhat.com>

	* remote.c (hex2bin, bin2hex): Move extern declarations to ...
	* remote.h (hex2bin, bin2hex): ... here.
	* tracepoint.c (hex2bin, bin2hex): Remove extern declarations.
@
text
@d712 1
a712 2
  for (p = *line; isspace ((int) *p);)
    p++;
d734 1
a734 2
	  while (isspace ((int) *p))
	    p++;
d799 1
a799 2
	  while (isspace ((int) *p))
	    p++;
d832 1
a832 2
      while (isspace ((int) *p))
	p++;
d1378 1
a1378 2
      while (isspace ((int) *action_exp))
	action_exp++;
d1393 1
a1393 2
	      while (isspace ((int) *action_exp))
		action_exp++;
d1554 1
a1554 2
	      while (isspace ((int) *action_exp))
		action_exp++;
d2585 1
a2585 2
      while (isspace ((int) *tmp))
	tmp++;
d2618 1
a2618 2
      while (isspace ((int) *tmp))
	tmp++;
d2813 1
a2813 2
      while (isspace ((int) *action_exp))
	action_exp++;
d2851 1
a2851 2
		  while (isspace ((int) *action_exp))
		    action_exp++;
@


1.281
log
@2013-03-04  Luis Machado  <lgustavo@@codesourcery.com>

	* tracepoint.c (build_traceframe_info): Add code for byte order.
@
text
@a71 3
extern int hex2bin (const char *hex, gdb_byte *bin, int count);
extern int bin2hex (const gdb_byte *bin, char *hex, int count);

@


1.280
log
@gdb/
2013-02-27  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* tracepoint.c (tfile_trace_find): For tfind
    	pc/tp/range/outside, look for the next trace frame instead of
    	always starting from frame 0.
@
text
@d4719 3
d4723 4
@


1.279
log
@2013-02-15  Pedro Alves  <pedro@@codesourcery.com>
	    Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	gdb/
	* NEWS: Mention new field "trace-file".
	* tracepoint.c (trace_status_mi): Output "trace-file" field.
	(tfile_open): Record the trace file's filename in the trace
	status.
	(tfile_files_info): Mention the name of the trace file.
	Check the "filename" field explicitely.
	(trace_status_command): Explicitely check "filename" field.
	(trace_find_command): Ditto.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	* tracepoint.h (struct trace_status) <from_file>: Rename it
	to "filename" and make it hold the trace file's filename
	instead of a boolean.
	* remote.c (remote_get_trace_status): Initialize "filename"
	field with NULL instead	of 0.

	gdb/doc/
	* gdb.texinfo (GDB/MI Tracepoint Commands) <-trace-status>:
	Document the "trace-file" field.

	gdb/testsuite/
	* gdb.trace/tfile.exp: Add test for -trace-status command.
@
text
@d4319 2
a4320 1
      switch (type)
d4322 1
a4322 1
	case tfind_number:
a4324 23
	  break;
	case tfind_pc:
	  tfaddr = tfile_get_traceframe_address (tframe_offset);
	  if (tfaddr == addr1)
	    found = 1;
	  break;
	case tfind_tp:
	  tp = get_tracepoint (num);
	  if (tp && tpnum == tp->number_on_target)
	    found = 1;
	  break;
	case tfind_range:
	  tfaddr = tfile_get_traceframe_address (tframe_offset);
	  if (addr1 <= tfaddr && tfaddr <= addr2)
	    found = 1;
	  break;
	case tfind_outside:
	  tfaddr = tfile_get_traceframe_address (tframe_offset);
	  if (!(addr1 <= tfaddr && tfaddr <= addr2))
	    found = 1;
	  break;
	default:
	  internal_error (__FILE__, __LINE__, _("unknown tfind type"));
d4326 33
@


1.278
log
@2013-02-14  Pedro Alves  <pedro@@codesourcery.com>
	    Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	gdb/
	* tracepoint.h (validate_trace_state_variable_name): Declare.
	* tracepoint.c (validate_trace_state_variable_name): New.
	(trace_variable_command): Parse the trace state variable's name
	without using parse_expression.  Do several validations.
	* mi/mi-main.c (mi_cmd_trace_define_variable): Don't parse the
	trace state variable's name with parse_expression.  Validate it.

	gdb/testsuite/
	* gdb.trace/tsv.exp: Adjust tests, and add a few more.
@
text
@d1943 1
a1943 1
      if (ts->from_file)
d2103 1
a2103 1
  if (status == -1 && !ts->from_file)
d2109 1
a2109 1
  if (ts->from_file)
d2114 3
d2405 2
a2406 1
  if (current_trace_status ()->running && !current_trace_status ()->from_file)
d2457 2
a2458 1
  if (current_trace_status ()->running && !current_trace_status ()->from_file)
d2476 2
a2477 1
  if (current_trace_status ()->running && !current_trace_status ()->from_file)
d2516 2
a2517 1
  if (current_trace_status ()->running && !current_trace_status ()->from_file)
d2582 2
a2583 1
  if (current_trace_status ()->running && !current_trace_status ()->from_file)
d2616 2
a2617 1
  if (current_trace_status ()->running && !current_trace_status ()->from_file)
d3774 2
a3775 2
  /* We know we're working with a file.  */
  ts->from_file = 1;
d4225 1
a4225 2
  /* (it would be useful to mention the name of the file).  */
  printf_filtered ("Looking at a trace file.\n");
@


1.277
log
@gdb/
	* tracepoint.c (end_actions_pseudocommand): Make it static.
	(while_stepping_pseudocommand): Likewise.
	* tracepoint.h (end_actions_pseudocommand): Remove the
	declaration.
	(while_stepping_pseudocommand): Likewise.
@
text
@d365 24
a394 1
  struct expression *expr;
a395 1
  struct internalvar *intvar = NULL;
d398 1
d401 1
a401 1
    error_no_arg (_("trace state variable name"));
d403 5
a407 3
  /* All the possible valid arguments are expressions.  */
  expr = parse_expression (args);
  old_chain = make_cleanup (free_current_contents, &expr);
d409 5
a413 2
  if (expr->nelts == 0)
    error (_("No expression?"));
d415 2
a416 12
  /* Only allow two syntaxes; "$name" and "$name=value".  */
  if (expr->elts[0].opcode == OP_INTERNALVAR)
    {
      intvar = expr->elts[1].internalvar;
    }
  else if (expr->elts[0].opcode == BINOP_ASSIGN
	   && expr->elts[1].opcode == OP_INTERNALVAR)
    {
      intvar = expr->elts[2].internalvar;
      initval = value_as_long (evaluate_subexpression_type (expr, 4));
    }
  else
d419 1
a419 2
  if (!intvar)
    error (_("No name given"));
d421 2
a422 2
  if (strlen (internalvar_name (intvar)) <= 0)
    error (_("Must supply a non-empty variable name"));
d425 1
a425 1
  tsv = find_trace_state_variable (internalvar_name (intvar));
d441 1
a441 1
  tsv = create_trace_state_variable (internalvar_name (intvar));
@


1.276
log
@gdb/doc:

2013-02-06  Yao Qi  <yao@@codesourcery.com>

	* gdb.texinfo (GDB/MI Async Records): Document new MI
	notification "=tsv-modified".  Update the document of MI
	notification "=tsv-created".
	* observer.texi (GDB Observers): New observer tsv_modified.
	Update observer tsv_created and tsv_deleted.

gdb:

2013-02-06  Yao Qi  <yao@@codesourcery.com>

	* mi/mi-interp.c: Include "tracepoint.h".
	(mi_tsv_modified): Declare.
	(mi_tsv_created, mi_tsv_deleted): Update declaration.
	(mi_interpreter_init): Call observer_attach_tsv_modified.
	(mi_tsv_modified): New.
	(mi_tsv_created, mi_tsv_deleted): Update.
	* tracepoint.c (trace_variable_command): Call
	observer_notify_tsv_modified if the initial value of tsv is
	changed.
	(delete_trace_state_variable): Call
	observer_notify_tsv_deleted earlier.
	(trace_variable_command): Caller update.
	(create_tsv_from_upload): Likewise.
	* observer.sh: Declare "struct trace_state_variable".

	* NEWS: Mention the new MI notification "=tsv-modified".

gdb/testsuite:

2013-02-06  Yao Qi  <yao@@codesourcery.com>

	* gdb.trace/mi-tsv-changed.exp (test_create_delete_tsv): Rename
	to ...
	(test_create_delete_modify_tsv): ... here.  New test on modifying
	the initial value of a tsv.
@
text
@d568 1
a568 1
void
d574 1
a574 1
void
@


1.275
log
@gdb/
	* ada-lang.c (user_select_syms): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* breakpoint.c (print_breakpoint_location, resolve_sal_pc): Likewise.
	(clear_command): New variable sal_fullname, initialize it.  Replace
	compare_filenames_for_search by filename_cmp with sal_fullname.
	(say_where, update_static_tracepoint): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* cli/cli-cmds.c (edit_command, list_command, ambiguous_line_spec):
	Likewise.
	* dwarf2read.c: Include source.h.
	(fixup_go_packaging): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* linespec.c (add_sal_to_sals): Rename variable filename to fullname.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(create_sals_line_offset, convert_linespec_to_sals): New variable
	fullname, initialize it, replace symtab->filename reference by the
	variable.
	* linux-fork.c: Include source.h.
	(info_checkpoints_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* macroscope.c (sal_macro_scope): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* mdebugread.c: Include source.h.
	(psymtab_to_symtab_1): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* printcmd.c: Include source.h.
	(build_address_symbolic): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* psymtab.c (partial_map_symtabs_matching_filename)
	(read_psymtabs_with_fullname): Call compare_filenames_for_search also
	with psymtab_to_fullname.
	* python/py-symtab.c (stpy_str): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(stpy_get_filename): New variable filename, initialize it, use instead
	of symtab->filename refererences.
	(salpy_str): Make variable filename const char *.  Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	* skip.c: Include source.h and filenames.h.
	(skip_file_command): Remove const from the symtab variable.  Replace
	symtab->filename refererences by symtab_to_fullname call.
	(function_name_is_marked_for_skip): New variables searched_for_fullname
	and fullname.  Use them to search also with symtab's fullname.
	* source.c (find_source_lines): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(print_source_lines_base): New variable filename, use it instead of
	symtab->filename.  Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(line_info, forward_search_command): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	(reverse_search_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.  New variable filename for it.
	* stack.c (frame_info): Likewise.
	* symmisc.c: Include source.h.
	(dump_objfile, dump_symtab_1, maintenance_print_symbols)
	(maintenance_info_symtabs): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* symtab.c (iterate_over_some_symtabs): Call
	compare_filenames_for_search also with symtab_to_fullname.
	(lookup_symbol_aux_quick, basic_lookup_transparent_type_quick): Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	(find_line_symtab): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(file_matches): Replace filename_cmp by compare_filenames_for_search.
	(print_symbol_info): Make the last parameter const char *.  New
	variable s_filename.  Use it in the function.
	(symtab_symbol_info): Make the last_filename variable const char *.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(rbreak_command): New variable fullname.  Use it.  Replace
	symtab->filename refererence by symtab_to_filename_for_display call.
	* tracepoint.c (set_traceframe_context, trace_find_line_command)
	(print_one_static_tracepoint_marker): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* tui/tui-source.c (tui_set_source_content): New variables filename and
	s_filename.  Replace symtab->filename refererences by this variable.
	Replace other symtab->filename refererences by
	symtab_to_filename_for_display calls.
@
text
@d354 2
a358 2
	observer_notify_tsv_deleted (name);

d411 5
a415 1
      tsv->initial_value = initval;
d427 1
a427 1
  observer_notify_tsv_created (tsv->name, initval);
d3594 1
a3594 1
  observer_notify_tsv_created (tsv->name, tsv->initial_value);
@


1.274
log
@2013-01-08  Hui Zhu  <hui_zhu@@mentor.com>

	* printcmd.c: Remove define of function output_command.
	* tracepoint.c: Remove extern of function output_command.
	* valprint.h: (output_command): New extern.
@
text
@d314 1
a314 1
			    traceframe_sal.symtab->filename);
d2515 2
a2516 1
			   sal.line, sal.symtab->filename);
d2537 1
a2537 1
	   sal.line, sal.symtab->filename);
d4864 2
a4865 1
      ui_out_field_string (uiout, "file", sal.symtab->filename);
@


1.273
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a95 5
/* GDB commands implemented in other modules:
 */  

extern void output_command (char *, int);

@


1.272
log
@gdb/
	* ada-lang.c (is_known_support_routine): New variable fullname.  Use
	access call to verify the symtab_to_fullname result.
	* breakpoint.c (print_breakpoint_location, update_static_tracepoint):
	Remove NULL check of symtab_to_fullname result.
	* cli/cli-cmds.c (edit_command): Likewise.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* python/py-symtab.c (stpy_fullname): Likewise.
	* source.c (symtab_to_fullname): Update function comment.  Rename
	variable r to fd, move it to inner block.  Always provide non-NULL
	result.
	(print_source_lines_base): Remove NULL check of symtab_to_fullname
	result.
	* stack.c (print_frame): Likewise.
	* symtab.c (iterate_over_some_symtabs, find_line_symtab, sources_info):
	Likewise.
	* tracepoint.c (print_one_static_tracepoint_marker): Likewise.

gdb/doc/
	* gdb.texinfo (GDB/MI Data Manipulation) (fullname): Make it always
	present.
	(GDB/MI File Commands) (-file-list-exec-source-files): Make the
	fullname output always present.

gdb/testsuite/
	* gdb.mi/mi-fullname-deleted.exp: New file.
@
text
@d3 1
a3 1
   Copyright (C) 1997-2012 Free Software Foundation, Inc.
@


1.271
log
@gdb/
	Code cleanup.
	* dwarf2read.c (fixup_go_packaging): Do not check symtab->FILENAME for
	NULL.
	* linespec.c (add_sal_to_sals): Likewise.
	* psympriv.h (allocate_psymtab): Add ATTRIBUTE_NONNULL.
	* stack.c (print_frame): Do not check symtab->FILENAME for NULL.
	* symfile.h (allocate_symtab): Add ATTRIBUTE_NONNULL.
	* symtab.h (struct symtab): Add comment it is never NULL for filename.
	* tracepoint.c (set_traceframe_context): Do not check symtab->FILENAME
	for NULL.
	* tui/tui-source.c (tui_set_source_content): Likewise.
@
text
@d4875 1
a4875 2
	  if (fullname)
	    ui_out_field_string (uiout, "fullname", fullname);
@


1.270
log
@2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* breakpoint.c (print_one_breakpoint_location): Display the
	state of 'installed' of each non-pending location of a tracepoint
	in both CLI and MI.
	(download_tracepoint_locations): Notify 'breakpoint-modified'
	observer if any tracepoint location is downloaded.
	* tracepoint.c (start_tracing): Likewise.
	(merge_uploaded_tracepoints): Record all modified
	tracepoints and notify 'breakpoint-modified' observer for them.

	* NEWS: Mention the change for CLI and MI.

gdb/doc:
2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* gdb.texinfo (Listing Tracepoints): New item and example about
	'installed on target' output.
	Add more in the example about 'installed on target'.
	(GDB/MI Breakpoint Commands): Doc about 'installed field.

gdb/testsuite:
2012-12-15  Yao Qi  <yao@@codesourcery.com>

	* gdb.trace/mi-tracepoint-changed.exp (test_pending_resolved): Check
	'installed' field in '=breakpoint-modified'.
	(test_reconnect): Check 'installed' field in
	'=breakpoint-modified' and '=breakpoint-created'.

	* gdb.trace/actions.exp: Update test for 'installed' field.
	* gdb.trace/change-loc.exp (tracepoint_change_loc_1):
	(tracepoint_change_loc_2): Likewise.
	Check 'info tracepoint' display nothing else.
	* gdb.trace/deltrace.exp: Likewise.
	* gdb.trace/infotrace.exp: Likewise.
	* gdb.trace/mi-traceframe-changed.exp (test_tfind_remote):
	Likewise.
	* gdb.trace/passcount.exp: Likewise.
	* gdb.trace/tracecmd.exp: Likewise.
	* gdb.trace/while-stepping.exp: Likewise.
@
text
@d315 1
a315 2
  if (traceframe_sal.symtab == NULL
      || traceframe_sal.symtab->filename == NULL)
@


1.269
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d1770 1
d1792 1
d1800 3
d3478 4
d3492 2
d3501 16
d3539 6
@


1.268
log
@	* tracepoint.c (print_one_static_tracepoint_marker): Constify.
	* symtab.c (iterate_over_some_symtabs): Constify.
	* source.h (symtab_to_fullname): Return 'const char *'.
	* source.c (symtab_to_fullname): Return 'const char *'.
	* python/py-symtab.c (stpy_fullname): Constify.
	* cli/cli-cmds.c (edit_command): Constify.
	* breakpoint.c (print_breakpoint_location)
	(update_static_tracepoint): Constify.
@
text
@d4209 1
a4209 1
					      (target_gdbarch));
d4253 1
a4253 1
						  (target_gdbarch));
d4260 1
a4260 1
				      gdbarch_byte_order (target_gdbarch));
d4368 1
a4368 1
                                              (target_gdbarch));
d4505 1
a4505 1
	  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d4588 1
a4588 1
					   (target_gdbarch));
d4594 1
a4594 1
					 (target_gdbarch));
d4742 1
a4742 1
  marker->gdbarch = target_gdbarch;
d4919 1
a4919 1
  if (gdbarch_addr_bit (target_gdbarch) <= 32)
@


1.267
log
@	* ada-valprint.c (ada_val_print_1): Eliminate single-use
	variable LEN.
	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
	directly.
	(alpha_store_return_value): Likewise.
	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
	(amd64_push_arguments): Likewise.
	* ax-gdb.c (gen_trace_static_fields): Likewise.
	(gen_traced_pop): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* breakpoint.c (update_watchpoint): Likewise.
	* findcmd.c (parse_find_args): Use local variable for type
	instead of length.
	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
	(h8300_store_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
	Use i386_darwin_arg_type_alignment directly.
	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	(m68hc11_extract_return_value): Likewise.
	* mep-tdep.c (mep_push_dummy_call): Likewise.
	* printcmd.c (float_type_from_length): Likewise.
	* s390-tdep.c (s390_value_from_register): Likewise.
	* stack.c (read_frame_arg): Likewise.
	* tracepoint.c (encode_actions_1): Likewise.
	* valops.c (value_fetch_lazy): Use local variable for type
	instead of length.  Use TYPE_LENGTH directly.
	* value.c (value_contents_equal): Use TYPE_LENGTH directly.
@
text
@d4841 1
a4841 1
	  char *fullname = symtab_to_fullname (sal.symtab);
@


1.266
log
@gdb/doc:

	* gdb.texinfo (GDB/MI Async Records): Document new MI
	notifications '=tsv-created' and '=tsv-deleted'.
	* observer.texi (GDB Observers): New observer tsv_created and
	tsv_deleted.

gdb:

	* mi/mi-interp.c: Declare mi_tsv_created and mi_tsv_deleted.
	(mi_interpreter_init): Call observer_attach_tsv_created and
	observer_attach_tsv_deleted.
	(mi_tsv_created, mi_tsv_deleted): New.
	* tracepoint.c (delete_trace_state_variable): Call
	observer_notify_tsv_deleted.
	(trace_variable_command): Call observer_notify_tsv_created.
	(delete_trace_variable_command): Call
	observer_notify_tsv_deleted.
	(create_tsv_from_upload): Call observer_notify_tsv_created.
	* NEWS: Mention it.

gdb/testsuite:

	gdb.trace/mi-tsv-changed.exp: New.
@
text
@d1459 1
a1459 1
		  unsigned long addr, len;
d1489 4
a1492 2
		      len = TYPE_LENGTH (check_typedef (exp->elts[1].type));
		      add_memrange (collect, memrange_absolute, addr, len);
@


1.265
log
@gdb/doc:

	* observer.texi (GDB Observers): New observer 'traceframe_changed'.
	* gdb.texinfo (GDB/MI Async Records): Mention new MI notification
	'=traceframe-changed'.

gdb:

	* tracepoint.c (tfind_1): Call observer_notify_traceframe_changed
	if traceframe changed.

	* mi/mi-cmds.c (mi_cmd mi_cmds): Adjust for command
	"trace-find".
	* mi/mi-interp.c: Declare 'mi_traceframe_changed'.
	(mi_interpreter_init): Hook mi_traceframe_changed to observer
	'traceframe_changed'.
	(mi_traceframe_changed): New.
	* mi/mi-main.h (struct mi_suppress_notification) <traceframe>:
	New field.

	* NEWS: Mention the new MI notification.

gdb/testsuite:

	* gdb.trace/mi-traceframe-changed.exp: New.
@
text
@d362 3
d429 2
d450 1
d3560 2
@


1.264
log
@gdb/

	* tracepoint.c (disconnect_tracing): Call set_tracepoint_num.
	(tfind_1): Don't call registers_changed, set_traceframe_num,
	and clear_traceframe_info.
	Call set_current_traceframe.
	(set_current_traceframe): call set_traceframe_num.

gdb/testsuite:

	* gdb.trace/disconnected-tracing.c (start, end): New.
	(main): Call start and end.
	* gdb.trace/disconnected-tracing.exp (disconnected_tracing): Move
	existing tests into this proc.
	(disconnected_tfind): New.
@
text
@d2291 5
a2297 1
  set_tracepoint_num (tp ? tp->base.number : target_tracept);
@


1.263
log
@gdb/
	* tracepoint.c (trace_find_none_command): Remove.
	(_initialize_tracepoint): Call add_alias_cmd for "tfind none".
@
text
@d2215 1
a2288 1
  registers_changed ();
d2290 3
a2292 2
  set_traceframe_num (target_frameno);
  clear_traceframe_info ();
d3277 1
a3277 1
  traceframe_number = newnum;
@


1.262
log
@gdb/
	* tracepoint.c: Add 'static' for some variables.
@
text
@a2406 7
/* tfind none */
static void
trace_find_none_command (char *args, int from_tty)
{
  trace_find_command ("-1", from_tty);
}

a5238 1
Synonym for 'none'.\n\
d5242 1
a5242 3
  add_cmd ("none", class_trace, trace_find_none_command,
	   _("De-select any trace frame and resume 'live' debugging."),
	   &tfindlist);
@


1.261
log
@gdb/
	* tracepoint.c (cur_traceframe_number): Remove.
	(set_tfile_traceframe): Remove.
	(tfile_trace_find, tfile_fetch_registers): Update callers.
	(tfile_xfer_partial, tfile_get_trace_state_variable_value): Likewise.
	(tfile_open, tfile_trace_find): Likewise.
@
text
@d3616 1
a3616 1
struct target_ops tfile_ops;
d3622 5
a3626 5
char *trace_filename;
int trace_fd = -1;
off_t trace_frames_offset;
off_t cur_offset;
int cur_data_size;
@


1.260
log
@	* linespec.c: #include "stack.h".
	(decode_line_with_current_source): Moved here from symtab.c and
	renamed from decode_line_spec.  All callers updated.
	(decode_line_with_last_displayed): Moved here from breakpoint.c and
	renamed from decode_line_spec_1.  All callers updated.
	* linespec.h (decode_line_with_current_source): Move declaration here
	from symtab.h and renamed from decode_line_spec.
	(decode_line_with_last_displayed): Move declaration here from symtab.h
	and renamed from decode_line_spec_1.
	* macrocmd.c: #include "linespec.h".
	* symtab.c: Remove #include "linespec.h".
@
text
@a3625 1
int cur_traceframe_number;
a3717 2
  cur_traceframe_number = -1;

a4213 22
/* Make tfile's selected traceframe match GDB's selected
   traceframe.  */

static void
set_tfile_traceframe (void)
{
  int newnum;

  if (cur_traceframe_number == get_traceframe_number ())
    return;

  /* Avoid recursion, tfile_trace_find calls us again.  */
  cur_traceframe_number = get_traceframe_number ();

  newnum = target_trace_find (tfind_number,
			      get_traceframe_number (), 0, 0, NULL);

  /* Should not happen.  If it does, all bets are off.  */
  if (newnum != get_traceframe_number ())
    warning (_("could not set tfile's traceframe"));
}

d4230 1
a4230 6
  /* Lookups other than by absolute frame number depend on the current
     trace selected, so make sure it is correct on the tfile end
     first.  */
  if (type != tfind_number)
    set_tfile_traceframe ();
  else if (num == -1)
d4289 1
a4289 1
	  cur_traceframe_number = tfnum;
a4403 2
  set_tfile_traceframe ();

a4486 2
  set_tfile_traceframe ();

a4571 2
  set_tfile_traceframe ();

@


1.259
log
@	PR macros/7961:
	* varobj.c (varobj_create): Update.
	(varobj_set_value): Update.
	* tracepoint.c (validate_actionline): Update.
	(encode_actions_1): Update.
	* parse.c (parse_exp_1): Add 'pc' argument.
	(parse_exp_in_context): Add 'pc' argument.  Change how
	expression_context_pc is set.
	(parse_expression): Update.
	(parse_field_expression): Update.
	* expression.h (parse_exp_1): Update.
	* eval.c (parse_to_comma_and_eval): Update.
	* breakpoint.c (set_breakpoint_condition): Update.
	(update_watchpoint): Update.
	(init_breakpoint_sal): Update
	(find_condition_and_thread): Update.
	(watch_command_1): Update.
	(update_breakpoint_locations): Update.
	* ada-lang.c (ada_read_renaming_var_value): Update.
	(create_excep_cond_exprs): Update.
testsuite
	* gdb.base/macscp1.c (macscp_expr): Add breakpoint comment.
	* gdb.base/macscp.exp (maybe_kfail): Add test for macro scope.
@
text
@d2497 1
a2497 1
      sals = decode_line_spec (args, DECODE_LINE_FUNFIRSTLINE);
@


1.258
log
@2012-06-15  Hui Zhu  <hui_zhu@@mentor.com>

	* tracepoint.c (tfile_xfer_partial): Add a lseek.
@
text
@d737 2
a738 1
	      exp = parse_exp_1 (&p, block_for_pc (loc->address), 1);
d791 2
a792 1
	      exp = parse_exp_1 (&p, block_for_pc (loc->address), 1);
d1457 1
a1457 1
		  exp = parse_exp_1 (&action_exp, 
d1547 1
a1547 1
		  exp = parse_exp_1 (&action_exp, 
@


1.257
log
@	* tracepoint.c (start_tracing): Add missing i18n markup.
	(stop_tracing, set_trace_user): Ditto.
	(set_trace_notes, set_trace_stop_notes): Ditto.
@
text
@d4548 2
@


1.256
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d1808 1
a1808 1
    warning ("Target does not support trace user/notes, info ignored");
d1894 1
a1894 1
    warning ("Target does not support trace notes, note ignored");
d3204 1
a3204 1
    warning ("Target does not support trace notes, user ignored");
d3216 1
a3216 1
    warning ("Target does not support trace notes, note ignored");
d3228 1
a3228 1
    warning ("Target does not support trace notes, stop note ignored");
@


1.255
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (lookup_block_symbol, iterate_over_symbols)
	(find_pc_sect_symtab, search_symbols)
	(default_make_symbol_completion_list_break_on)
	(make_file_symbol_completion_list): Update.
	* symmisc.c (dump_symtab_1): Update.
	* stack.c (print_frame_args, iterate_over_block_locals)
	(print_frame_labels, iterate_over_block_arg_vars): Update.
	* python/py-block.c (block_object) <dict>: Remove.
	<block>: New field.
	<iter>: Change type.
	(blpy_iter): Update.
	(blpy_block_syms_iternext): Update.
	* psymtab.c (map_block): Use block iterators.
	* objfiles.c (objfile_relocate1): Use ALL_DICT_SYMBOLS.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* mdebugread.c (parse_symbol, mylookup_symbol): Update.
	* infrun.c (check_exception_resume): Update.
	* cp-support.c (make_symbol_overload_list_block): Update.
	* coffread.c (patch_opaque_types): Update.
	* buildsym.c (finish_block, end_symtab): Use ALL_DICT_SYMBOLS.
	* block.h (struct block_iterator): New.
	(block_iterator_first, block_iterator_next, block_iter_name_first)
	(block_iter_name_next, block_iter_match_first)
	(block_iter_match_next): Declare.
	(ALL_BLOCK_SYMBOLS): Redefine.
	* block.c (block_iterator_first, block_iterator_next)
	(block_iter_name_first, block_iter_name_next)
	(block_iter_match_first, block_iter_match_next): New functions.
	* ada-lang.c (ada_add_block_symbols)
	(ada_make_symbol_completion_list): Use block iterator.
@
text
@d4424 1
a4424 3
  char block_type;
  int pos, offset, regn, regsize, pc_regno;
  unsigned short mlen;
@


1.254
log
@2012-04-29  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* tracepoint.c (start_tracing, stop_tracing): Checking for NULL
	probes.
@
text
@d2615 1
a2615 1
  struct dict_iterator iter;
@


1.253
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d1786 2
a1787 1
	loc->probe->pops->set_semaphore (loc->probe, loc->gdbarch);
d1882 2
a1883 1
	  loc->probe->pops->clear_semaphore (loc->probe, loc->gdbarch);
@


1.252
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	* ax-gdb.c (gen_expr): Clean up code to handle internal variables
	and to compile agent expressions.
	* infrun.c (siginfo_make_value): New argument `ignore'.
	(siginfo_funcs): New struct.
	(_initialize_infrun): New argument when calling
	`create_internalvar_type_lazy'.
	* thread.c (thread_id_make_value): New argument `ignore'.
	(thread_funcs): New struct.
	(_initialize_thread): New argument when calling
	`create_internalvar_type_lazy'.
	* tracepoint.c (sdata_make_value): New argument `ignore'.
	(sdata_funcs): New struct.
	(_initialize_tracepoint): New argument when calling
	`create_internalvar_type_lazy'.
	* value.c (make_value): New struct.
	(create_internalvar_type_lazy): New argument `data'.
	(compile_internalvar_to_ax): New function.
	(value_of_internalvar): Properly handling `make_value' case.
	(clear_internalvar): Likewise.
	(show_convenience): Adding `TRY_CATCH' block.
	* value.h (internalvar_make_value): Delete, replace by...
	(struct internalvar_funcs): ... this.
	(create_internalvar_type_lazy) <fun>: Delete argument.
	(create_internalvar_type_lazy) <funcs>, <data>: New arguments.
	(compile_internalvar_to_ax): New function.
	* windows-tdep.c (tlb_make_value): New argument `ignore'.
	(tlb_funcs): New struct.
	(_initialize_windows_tdep): New argument when calling
	`create_internalvar_type_lazy'.
@
text
@d55 1
d1721 1
d1784 3
d1859 3
d1865 22
@


1.251
log
@gdb/
	Fix 64-bit constants on 32-bit hosts.
	* dwarf2read.c (read_unsigned_leb128): Change declaration return type
	from unsigned long to ULONGEST.
	(read_signed_leb128): Change declaration return type from long to
	LONGEST.
	(dwarf2_const_value_attr): Change declaration parameter value from long
	to LONGEST.
	(dwarf2_compute_name): Change variable value from long to LONGEST.
	(read_unsigned_leb128): Change return type, variable result and some
	casts from unsigned long to ULONGEST.
	(read_signed_leb128): Change return type, variable result and some
	casts from long to LONGEST.
	(dwarf2_const_value_data, dwarf2_const_value_attr): Change parameter
	value from long to LONGEST.
	(dwarf2_const_value): Change variable value from long to LONGEST.
	* symmisc.c (print_symbol): Change SYMBOL_VALUE format strings to use
	plongest and hex_string.
	* symtab.h (struct general_symbol_info): Change ivalue from long to
	LONGEST, remove the comment.
	* tracepoint.c (validate_actionline, collect_symbol, scope_info):
	Change SYMBOL_VALUE format strings to use plongest and hex_string.
@
text
@d4947 2
a4948 1
sdata_make_value (struct gdbarch *gdbarch, struct internalvar *var)
d5127 9
d5146 1
a5146 1
  create_internalvar_type_lazy ("_sdata", sdata_make_value);
@


1.250
log
@2012-03-27  Pedro Alves  <palves@@redhat.com>

	Eliminate struct ui_stream.

	* ui-out.h (struct ui_stream): Delete.
	(ui_out_field_stream): Adjust prototype.
	(ui_out_stream_new, ui_out_stream_delete)
	(make_cleanup_ui_out_stream_delete): Delete declarations.
	* ui-out.c (ui_out_field_stream): Change prototype to take a
	ui_file instead of a ui_stream.  Adjust.
	(ui_out_stream_new, ui_out_stream_delete, do_stream_delete)
	(make_cleanup_ui_out_stream_delete): Delete.
	* breakpoint.c (print_breakpoint_location)
	(print_one_detail_ranged_breakpoint, print_it_watchpoint): Use
	ui_file/mem_fileopen instead of ui_stream/ui_out_stream_new.
	* disasm.c (dump_insns): Ditto.
	(do_mixed_source_and_assembly, do_assembly_only): Adjust
	prototype.
	(gdb_disassembly): Use ui_file/mem_fileopen instead of
	ui_stream/ui_out_stream_new.
	* infcmd.c (print_return_value): Ditto.
	* osdata.c (info_osdata_command): Don't allocate a local
	ui_stream.
	* stack.c (print_frame_arg, print_frame_args, print_frame): Use
	ui_file/mem_fileopen instead of ui_stream/ui_out_stream_new.
	* tracepoint.c (print_one_static_tracepoint_marker): Don't
	allocate a local ui_stream.
	* mi/mi-cmd-stack.c (list_arg_or_local): Use ui_file/mem_fileopen
	instead of ui_stream/ui_out_stream_new.
	(list_args_or_locals): Don't allocate a local ui_stream.
	* mi/mi-main.c (get_register, mi_cmd_data_evaluate_expression)
	(mi_cmd_data_read_memory): Use ui_file/mem_fileopen instead of
	ui_stream/ui_out_stream_new.
	* cli/cli-setshow.c (do_setshow_command): Ditto.
@
text
@d743 1
a743 1
		      error (_("constant `%s' (value %ld) "
d746 1
a746 1
			     SYMBOL_VALUE (exp->elts[2].symbol));
d983 2
a984 2
      printf_filtered ("constant %s (value %ld) will not be collected.\n",
		       SYMBOL_PRINT_NAME (sym), SYMBOL_VALUE (sym));
d2626 3
a2628 2
	      printf_filtered ("a constant with value %ld (0x%lx)",
			       SYMBOL_VALUE (sym), SYMBOL_VALUE (sym));
d2661 2
a2662 2
	      printf_filtered ("an argument at stack/frame offset %ld",
			       SYMBOL_VALUE (sym));
d2665 2
a2666 2
	      printf_filtered ("a local variable at frame offset %ld",
			       SYMBOL_VALUE (sym));
d2669 2
a2670 2
	      printf_filtered ("a reference argument at offset %ld",
			       SYMBOL_VALUE (sym));
@


1.249
log
@gdb:
	* common/agent.c (agent_look_up_symbols): Add one parameter 'arg'.
	* common/agent.h: Update declaration.
	* inf-child.c (inf_child_use_agent): New.
	(inf_child_can_use_agent): New.
	(inf_child_target): Initialize fields `to_use_agent'
	and `to_can_use_agent'.
	* agent.c (agent_new_objfile): New.
        (_initialize_agent): Add agent_new_objfile to new_objfile
	observer.

	* linux-nat.c (linux_child_static_tracepoint_markers_by_strid):
	New.
        (linux_target_install_ops): Initialize field
	`to_static_tracepoint_markers_by_strid'.
	* remote.c (free_current_marker): Move it to ...
	* tracepoint.c (free_current_marker): ... here.  New.
	(cleanup_target_stop): New.
	* tracepoint.h: Declare free_current_marker.
	* NEWS: Add one entry about `info static-tracepoint-marker'.

gdb/gdbserver:
	* tracepoint.c (tracepoint_look_up_symbols): Update call to
	agent_look_up_symbols.

gdb/testsuite:
	* gdb.trace/strace.exp: run strace_info_marker in linux native gdb.
@
text
@a4779 2
  struct ui_stream *stb = ui_out_stream_new (uiout);
  struct cleanup *old_chain = make_cleanup_ui_out_stream_delete (stb);
a4885 1
  do_cleanups (old_chain);
@


1.248
log
@gdb:
	* target.h (struct target_ops) <to_use_agent>: New field.
	(struct target_ops) <to_can_use_agent>: New field.
	(target_use_agent, target_can_use_agent): New macro.
	* target.c (update_current_target): Update.
	* remote.c: New enum `PACKET_QAgent'.
	(remote_protocol_features): Add a new element.
	(remote_use_agent, remote_can_use_agent): New.
	(init_remote_ops): Initialize field `can_use_agent' with
	remote_can_use_agent.  Intiailize field `use_agent' with
	remote_use_agent.
	* common/agent.c (use_agent): New global.
	* common/agent.h: Declare it.
	* tracepoint.c (info_static_tracepoint_markers_command): Add
	comment.
	* Makefile.in (SFILES): Add common/agent.c and agent.c.
	(COMMON_OBS): Add common/agent.o and agent.o
	(common-agent.o): New rule.
	* agent.c: New.

gdb/doc:
	* gdb.texinfo (In-Process Agent): New node.
	Document new commands.
	(General Query Packets): Add packet `QAgent'.

gdb/gdbserver:
	* linux-low.c (linux_supports_agent): New.
	(linux_target_ops): Initialize field `supports_agent' with
	linux_supports_agent.
	* target.h (struct target_ops) <supports_agent>: New.
	(target_supports_agent): New macro.
	* server.c (handle_general_set): Handle packet 'QAgent'.
	(handle_query): Send `QAgent+'.
	* Makefile.in (server.o): Depends on agent.h.
@
text
@d4704 14
@


1.247
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d4886 6
@


1.246
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* remote.c (encode_actions): Delete declaration.
	* tracepoint.c (encode_actions): Make extern.
	* tracepoint.h (encode_actions): Declare.
@
text
@d350 1
a350 1
void
d370 1
a370 1
void
d432 1
a432 1
void
d3347 1
a3347 1
struct uploaded_tsv *
d3394 1
a3394 1
struct bp_location *
d3477 1
a3477 1
struct trace_state_variable *
d3486 1
a3486 1
struct trace_state_variable *
d5055 1
a5055 1
struct traceframe_info *
@


1.245
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d1580 2
a1581 1
/*static*/ void
@


1.244
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2580 2
a2581 1
  char *symname, *save_args = args;
@


1.243
log
@2011-12-10  Hui Zhu  <teawater@@gmail.com>
	    Yao Qi  <yao@@codesourcery.com>

	* tracepoint.c (start_tracing): Clear `inserted' flag.

2011-12-10  Yao Qi  <yao@@codesourcery.com>

	* gdb.trace/status-stop.exp: New.
	* gdb.trace/status-stop.c: New.
@
text
@d3 1
a3 2
   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.243.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1997-2012 Free Software Foundation, Inc.
@


1.242
log
@2011-12-10  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (create_tsv_from_upload): Change sprintf to xstrprintf.
@
text
@d1759 4
@


1.241
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d3485 1
a3485 1
  char buf[20];
d3488 1
d3493 1
a3493 1
      sprintf (buf, "%s", namebase);
d3498 1
a3498 1
      sprintf (buf, "%s_%d", namebase, try_num++);
d3504 6
a3509 1
    sprintf (buf, "%s_%d", namebase, try_num++);
d3516 2
@


1.240
log
@Fix a 32-bit compile error in the previous checkin
@
text
@d2459 1
a2459 1
      sals = decode_line_spec (args, 1);
d2587 1
a2587 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL);
@


1.239
log
@	* NEWS: Mention tracepoint additions.
	* breakpoint.h (struct tracepoint): New field traceframe_usage.
	* breakpoint.c (print_one_breakpoint_location): Identify
	tracepoints as such when reporting hit counts, report
	trace buffer usage.
	(create_tracepoint_from_upload): Copy status info.
	* tracepoint.h (struct trace_status): Rename error_desc to stop_desc,
	add fields user_name, notes, start_time, stop_time.
	(struct uploaded_tp): Add fields hit_count, traceframe_usage.
	* tracepoint.c (trace_user): New global.
	(trace_notes): New global.
	(trace_stop_notes): New global.
	(start_tracing): Add argument and trace note handling.
	(stop_tracing): Ditto.
	(trace_start_command): Add notes argument.
	(trace_stop_command): Ditto.
	(trace_status_command): Report additional status info.
	(trace_status_mi): Similarly.
	(trace_save): Update, record tracepoint status.
	(set_disconnected_tracing): Call target method directly.
	(send_disconnected_tracing_value): Remove.
	(set_trace_user): New function.
	(set_trace_notes): New function.
	(set_trace_stop_notes): New function.
	(parse_trace_status): Handle additional status.
	(parse_tracepoint_status): New function.
	(parse_tracepoint_definition): Call it.
	(tfile_get_tracepoint_status): New function.
	(init_tfile_ops): Use it.
	(_initialize_tracepoint): Add new setshows.
	* target.h (struct target_ops): New methods to_get_tracepoint_status
	and to_set_trace_notes.
	(target_get_tracepoint_status): New macro.
	(target_set_trace_notes): New macro.
	* target.c (update_current_target): Add new methods.
	* remote.c (remote_get_tracepoint_status): New function.
	(remote_set_trace_notes): New function.
	(init_remote_ops): Add them.
	* mi/mi-main.c (mi_cmd_trace_start): Add argument to call.
	(mi_cmd_trace_stop): Ditto.

	* tracepoint.c (struct tracepoint): New field traceframe_usage.
	(tracing_start_time): New global.
	(tracing_stop_time): New global.
	(tracing_user_name): New global.
	(tracing_notes): New global.
	(tracing_stop_note): New global.
	(cmd_qtstart): Set traceframe_usage, start_time.
	(stop_tracing): Set stop_time.
	(cmd_qtstatus): Report additional status.
	(cmd_qtp): New function.
	(handle_tracepoint_query): Call it.
	(cmd_qtnotes): New function.
	(handle_tracepoint_general_set): Call it.
	(get_timestamp): Rename from tsv_get_timestamp.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	note-related options and variables.
	(Tracepoint Packets): Document packet changes.

	* gdb.trace/tstatus.exp: New.
	* gdb.trace/actions.c: Include string.h.
@
text
@d1998 4
a2001 2
			   ts->start_time / 1000000, ts->start_time % 1000000,
			   run_time / 1000000, run_time % 1000000);
d2005 2
a2006 1
			 ts->start_time / 1000000, ts->start_time % 1000000);
d2010 2
a2011 1
		     ts->stop_time / 1000000, ts->stop_time % 1000000);
d2126 2
a2127 1
	       ts->start_time / 1000000, ts->start_time % 1000000);
d2130 2
a2131 1
	       ts->stop_time / 1000000, ts->stop_time % 1000000);
@


1.238
log
@gdb/
	* breakpoint.c (create_breakpoint): Produce query message according to
	breakpoint's type.
	Allocate tracepoint per correct type.
	Don't check SALs for pending fast tracepoints.
	* tracepoint.c (process_tracepoint_on_disconnect): New.
	(disconnect_tracing): Call process_tracepoint_on_disconnect.

gdb/doc/
	* gdb.texinfo (Create and Delete Tracepoints): Mention pending
	tracepoint.

gdb/testsuite/
	* gdb.trace/pending.exp: New.
	* gdb.trace/pending.c: New.
	* gdb.trace/pendshr1.c: New.
	* gdb.trace/pendshr2.c: New.
	* gdb.trace/change-loc.exp (tracepoint_change_loc_1): Check one
	tracepoint location becomes pending.
	(tracepoint_change_loc_2): New.
@
text
@d181 12
a213 2
extern void send_disconnected_tracing_value (int value);

d1699 1
a1699 1
start_tracing (void)
d1706 2
a1707 1
  
d1793 7
d1811 5
a1815 6
/* tstart command:

   Tell target to clear any previous trace experiment.
   Walk the list of tracepoints, and send them (and their actions)
   to the target.  If no errors,
   Tell target to start a new trace experiment.  */
d1829 1
a1829 1
  start_tracing ();
d1832 5
a1836 1
/* tstop command */
d1843 1
a1843 1
  stop_tracing ();
d1847 1
a1847 1
stop_tracing (void)
d1849 2
d1852 8
d1869 3
a1871 1
  int status;
d1902 5
a1906 1
	  printf_filtered (_("Trace stopped by a tstop command.\n"));
d1922 1
a1922 1
			     ts->error_desc, ts->stopping_tracepoint);
d1925 1
a1925 1
			     ts->error_desc);
d1976 6
d1988 28
d2098 1
a2098 1
				     ts->error_desc);
d2114 14
d2969 1
a2969 1
      char *buf = (char *) alloca (strlen (ts->error_desc) * 2 + 1);
d2971 1
a2971 1
      bin2hex ((gdb_byte *) ts->error_desc, buf, 0);
d3024 3
d3062 5
a3136 6
void
send_disconnected_tracing_value (int value)
{
  target_set_disconnected_tracing (value);
}

d3141 1
a3141 1
  send_disconnected_tracing_value (disconnected_tracing);
d3151 36
d3764 2
a3765 1
  char *p = line, *p1, *p2, *p_temp;
d3771 2
a3772 2
  xfree (ts->error_desc);
  ts->error_desc = NULL;
d3779 5
d3791 3
d3813 16
a3828 1
	  p = unpack_varlen_hex (++p1, &val);
d3841 3
a3843 5
	      int end;

	      ts->error_desc = xmalloc ((p2 - p1) / 2 + 1);
	      end = hex2bin (p1, ts->error_desc, (p2 - p1) / 2);
	      ts->error_desc[end] = '\0';
d3846 1
a3846 1
	    ts->error_desc = xstrdup ("");
d3882 26
d3921 20
d4042 6
d4123 7
d4671 1
d5216 11
a5226 5
  add_com ("tstop", class_trace, trace_stop_command,
	   _("Stop trace data collection."));

  add_com ("tstart", class_trace, trace_start_command,
	   _("Start trace data collection."));
d5301 21
@


1.237
log
@	* tracepoint.c (encode_actions_1): Use the location's gdbarch.
	(encode_actions): Likewise.
@
text
@d1645 42
d2065 2
@


1.236
log
@gdb/
	* remote.c (struct remote_state): <install_in_trace> new field.
	(PACKET_InstallInTrace): New enum value.
	(remote_install_in_trace_feature): Support InstallInTrace.
	(remote_supports_install_in_trace): Likewise.
	(remote_protocol_features): Likewise.
	(_initialize_remote): Likewise.
	(remote_can_download_tracepoint): New.
	* target.h (struct target): New field
	`to_can_download_tracepoint'.
	(target_can_download_tracepoint): New macro.
	* target.c (update_current_target): Update.
	* breakpoint.h (struct bp_location): Add comment on field
	`duplicate'.
	(should_be_inserted): Don't differentiate breakpoint and tracepoint.
	(remove_breakpoints): Don't remove tracepoints.
	(tracepoint_locations_match ): New.
	(breakpoint_locations_match): Call it.
	(disable_breakpoints_in_unloaded_shlib): Handle tracepoint.
	(download_tracepoint_locations): New.
	(update_global_location_list): Call it.
	* tracepoint.c (find_matching_tracepoint): Delete.
	(find_matching_tracepoint_location): Renamed from
	find_matching_tracepoint.  Return bp_location rather than
	tracepoint.
	(merge_uploaded_tracepoints): Set `inserted' field to 1 if
	tracepoint is found.

gdb/doc/
	* gdb.texinfo (Create and Delete Tracepoints): Describe changed
	behavior of tracepoint.
	(General Query Packets): New feature InstallInTrace.
	(Remote Configuration): Document "set remote
	install-in-trace-packet".

gdb/gdbserver/
	* server.c (handle_query): Handle InstallInTrace for qSupported.
	* tracepoint.c (add_tracepoint): Sort list.
	(install_tracepoint, download_tracepoint): New.
	(cmd_qtdp): Call them to install and download tracepoints.
	(sort_tracepoints): Removed.
	(cmd_qtstart): Update.

gdb/testsuite/
	* gdb.trace/change-loc-1.c: New.
	* gdb.trace/change-loc-2.c: New.
	* gdb.trace/change-loc.c: New.
	* gdb.trace/change-loc.exp:  New.
	* gdb.trace/change-loc.h:  New.
	* gdb.trace/trace-break.c (marker): Define new symbol.
	* gdb.trace/trace-break.exp (break_trace_same_addr_5):
        New.
	(break_trace_same_addr_6): New.
@
text
@d1373 1
a1373 1
		  for (i = 0; i < gdbarch_num_regs (t->gdbarch); i++)
d1380 1
a1380 1
				     t->gdbarch,
d1390 1
a1390 1
				     t->gdbarch,
d1402 1
a1402 1
							t->gdbarch);
d1455 1
a1455 1
			i = user_reg_map_name_to_regnum (t->gdbarch,
d1478 1
a1478 1
				      t->gdbarch,
d1591 2
a1592 2
  gdbarch_virtual_frame_pointer (t->gdbarch,
				 t->loc->address, &frame_reg, &frame_offset);
@


1.235
log
@	* target.h (struct target): <to_download_tracepoint> Change type
	of parameter from tracepoint to bp_location.
	* target.c (update_current_target): Update.
	* tracepoint.c (start_tracing): Update.
	* remote.c (remote_download_tracepoint): Remove loop for each location
	of a tracepoint.
@
text
@d1714 9
a1722 1
	target_download_tracepoint (loc);
d3214 1
a3214 1
   next trace run.  */
d3216 2
a3217 2
struct tracepoint *
find_matching_tracepoint (struct uploaded_tp *utp)
d3239 1
a3239 1
		return t;
a3253 1
  struct tracepoint *t;
d3258 14
a3271 6
      t = find_matching_tracepoint (utp);
      if (t)
	printf_filtered (_("Assuming tracepoint %d is same "
			   "as target's tracepoint %d at %s.\n"),
			 t->base.number, utp->number,
			 paddress (get_current_arch (), utp->addr));
@


1.234
log
@2011-11-02  Stan Shebs  <stan@@codesourcery.com>

	String collection for tracepoints.
	* NEWS: Mention string collection.
	* common/ax.def (tracenz): New bytecode.
	* ax-gdb.h (trace_string_kludge): Declare.
	* ax-gdb.c: Include valprint.h and c-lang.h.
	(trace_string_kludge): New global.
	(gen_traced_pop): Add string case.
	(agent_command): Add string case.
	* tracepoint.h (decode_agent_options): Declare.
	* tracepoint.c: Include cli-utils.h.
	(decode_agent_options): New function.
	(validate_actionline): Call it.
	(encode_actions_1): Ditto.
	* target.h (struct target_ops): New method to_supports_string_tracing.
	(target_supports_string_tracing): New macro.
	* target.c (update_current_target): Add to_supports_string_tracing.
	* remote.c (struct remote_state): New field string_tracing.
	(remote_string_tracing_feature): New function.
	(remote_protocol_features): New feature tracenz.
	(remote_supports_string_tracing): New function.
	(init_remote_ops): Set to_supports_string_tracing.

	* tracepoint.c (agent_mem_read_string): New function.
	(eval_agent_expr): Call it for tracenz.
	* server.c (handle_query): Report support for tracenz.

	* gdb.texinfo (Tracepoint Action Lists): Document collect/s.
	(General Query Packets): Describe tracenz feature.
	* agentexpr.texi (Bytecode Descriptions): Describe tracenz.

	* gdb.trace/collection.c: Add code using strings.
	* gdb.trace/collection.exp: Add tests of string collection.
@
text
@d1704 1
d1712 4
a1715 1
      target_download_tracepoint (b);
@


1.233
log
@2011-10-13  Luis Machado  <lgustavo@@codesourcery.com>

	* tracepoint.c (trace_save_command): Use filename instead of
	args when printing.
@
text
@d55 1
d578 40
d700 4
d1361 4
d2633 3
@


1.232
log
@	Add return address collection for tracepoints.
	* tracepoint.c (encode_actions_1): Add case for $_ret.
	(validate_actionline): Check for $_ret.
	(trace_dump_actions): Ditto.
	* ax-gdb.h (gen_trace_for_return_address): Declare.
	* ax-gdb.c: Include arch-utils.h.
	(gen_trace_for_return_address): New function.
	(agent_command): Add return address special case.
	* amd64-tdep.c: Include ax.h and ax-gdb.h.
	(amd64_gen_return_address): New function.
	(amd64_init_abi): Call it.
	* i386-tdep.c: Include ax.h and ax-gdb.h.
	(i386_gen_return_address): New function.
	(i386_init_abi): Call it.
	* arch-utils.h (default_gen_return_address): Declare.
	* arch-utils.c (default_gen_return_address): New function.
	* gdbarch.sh (gen_return_address): New method.
	* gdbarch.h, gdbarch.c: Regenerate.

	* gdb.texinfo (Tracepoint Action Lists): Document $_ret.

	* gdb.trace/collection.exp: Test collection of $_ret.
@
text
@d2928 1
a2928 1
    printf_filtered (_("Trace data saved to file '%s'.\n"), args);
@


1.231
log
@2011-08-24  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (cond_string_is_same): New function.
	(find_matching_tracepoint): Add condition check
	by cond_string_is_same.
@
text
@d670 1
d1348 37
d2596 2
@


1.230
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d3094 13
d3127 2
a3128 1
	  /* FIXME also test conditionals and actions.  */
@


1.229
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.h (print_recreate_thread): Declare.
	(struct breakpoint): Move step_count, pass_count,
	number_on_target, static_trace_marker_id,
	static_trace_marker_id_idx ...
	(struct tracepoint): ... to this new struct.
	(get_tracepoint, get_tracepoint_by_number_on_target)
	(get_tracepoint_by_number): Change return type to struct
	tracepoint pointer.
	* breakpoint.c (is_tracepoint_type): New, factored out from
	is_tracepoint.
	(is_tracepoint): Adjust.
	(print_one_breakpoint_location): Cast to struct tracepoint as
	necessary, and adjust.
	(print_recreate_catch_fork, print_recreate_catch_vfork)
	(print_recreate_catch_syscall, print_recreate_catch_exec): Call
	print_recreate_thread.
	(init_breakpoint_sal): New, factored out from
	create_breakpoint_sal.
	(create_breakpoint_sal): Reimplement.
	(create_breakpoint): Allocate a struct tracecepoint if the caller
	wanted a tracepoint.  Use init_breakpoint_sal and
	install_breakpoint.
	(print_recreate_ranged_breakpoint, print_recreate_watchpoint)
	(print_recreate_masked_watchpoint)
	(print_recreate_exception_catchpoint): Call print_recreate_thread.
	(tracepoint_print_one_detail): Adjust.
	(tracepoint_print_recreate): Adjust.  Call print_recreate_thread.
	Dump the pass count here.
	(update_static_tracepoint): Adjust.
	(addr_string_to_sals): Adjust.
	(create_tracepoint_from_upload): Adjust.  Change return type to
	struct tracepoint pointer.
	(trace_pass_set_count): Change parameter type to struct tracepoint
	pointer, and adjust.
	(trace_pass_command): Adjust.
	(get_tracepoint, get_tracepoint_by_number_on_target)
	(get_tracepoint_by_number): Change return type to struct
	tracepoint pointer, and adjust.
	(print_recreate_thread): New, factored out from save_breakpoints.
	(save_breakpoints): Don't print thread and task and passcount
	recreation here.
	* remote.c (remote_download_tracepoint): Adjust.
	* tracepoint.c (trace_actions_command, validate_actionline)
	(start_tracing, tfind_1, trace_find_tracepoint_command)
	(trace_dump_command): Adjust.
	(find_matching_tracepoint): Change return type to struct
	tracepoint pointer, and adjust.
	(merge_uploaded_tracepoints, tfile_get_traceframe_address)
	(tfile_trace_find, tfile_fetch_registers): Adjust.
	* tracepoint.h (create_tracepoint_from_upload): Change return type
	to struct tracepoint pointer.
	* ada-lang.c (print_recreate_exception): Call
	print_recreate_thread.
	* mi/mi-cmd-break.c (mi_cmd_break_passcount): Adjust.
@
text
@d460 1
d1815 1
d1955 1
d4372 1
d4490 1
@


1.228
log
@2011-07-07  Hui Zhu  <teawater@@gmail.com>

	Revert:
	2011-07-06  Hui Zhu  <teawater@@gmail.com>
	* remote.c (remote_start_remote): Add TRY_CATCH for
	remote_get_trace_status.
	* tracepoint.c (disconnect_tracing): Ditto.
@
text
@d580 1
a580 1
  struct breakpoint *t;
d588 1
a588 1
		    t->number);
d594 1
a594 1
      breakpoint_set_commands (t, l);
d628 1
a628 1
validate_actionline (char **line, struct breakpoint *t)
d636 1
d677 1
a677 1
	  for (loc = t->loc; loc; loc = loc->next)
d729 1
a729 1
	  for (loc = t->loc; loc; loc = loc->next)
d1563 1
a1563 1
  struct breakpoint *t;
d1576 1
a1576 1
  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, t); ix++)
d1578 3
a1580 1
      if (t->enable_state == bp_enabled)
d1583 1
a1583 1
      if ((t->type == bp_fast_tracepoint
d1589 1
a1589 1
		 (t->type == bp_fast_tracepoint ? "fast " : ""), t->number);
d1613 1
a1613 1
  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, t); ix++)
d1615 3
a1617 1
      if ((t->type == bp_fast_tracepoint
d1623 2
a1624 2
      target_download_tracepoint (t);
      t->number_on_target = t->number;
d1952 1
a1952 1
  struct breakpoint *tp;
d2017 1
a2017 1
  set_tracepoint_num (tp ? tp->number : target_tracept);
d2168 1
a2168 1
  struct breakpoint *tp;
d2586 1
a2586 1
  struct breakpoint *t;
d2619 1
a2619 1
  for (loc = t->loc; loc; loc = loc->next)
d2623 1
a2623 1
  actions = breakpoint_commands (t);
d2634 1
a2634 1
      validate_actionline (&line, t);
d3096 1
a3096 1
struct breakpoint *
d3101 1
a3101 1
  struct breakpoint *t;
d3104 1
a3104 1
  for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, t); ix++)
d3106 3
a3108 1
      if (t->type == utp->type
d3115 1
a3115 1
	  for (loc = t->loc; loc; loc = loc->next)
d3133 1
a3133 1
  struct breakpoint *t;
d3142 1
a3142 1
			 t->number, utp->number,
d3150 1
a3150 1
			     t->number, utp->number,
d3764 1
a3764 1
  struct breakpoint *tp;
d3778 2
a3779 2
  if (tp && tp->loc)
    addr = tp->loc->address;
d3821 1
a3821 1
  struct breakpoint *tp;
d4050 1
a4050 1
      struct breakpoint *tp = get_tracepoint (tracepoint_number);
d4052 1
a4052 1
      if (tp && tp->loc)
d4055 1
a4055 1
	  if (tp->loc->next)
d4059 1
a4059 1
		       tp->number);
d4067 1
a4067 1
		       tp->number);
d4073 1
a4073 1
				  tp->loc->address);
@


1.227
log
@2011-07-06  Hui Zhu  <teawater@@gmail.com>

	* remote.c (remote_start_remote): Add TRY_CATCH for
	remote_get_trace_status.
	* tracepoint.c (disconnect_tracing): Ditto.
@
text
@a1902 3
  int ret = 0;
  volatile struct gdb_exception ex;

d1907 1
a1907 10
  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      ret = target_get_trace_status (current_trace_status ());
    }
  if (ex.reason < 0)
    {
      warning (_("%s"), ex.message);
      ret = -1;
    }
  if (ret < 0)
@


1.226
log
@2011-05-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* tracepoint.c: Include exceptions.h.
	(TFILE_PID): Move higher in file.
	(tfile_open): Delay pushing the tfile target until we're assured
	the tfile header is present in the file.  Wrap reading the initial
	newline-terminated lines in TRY_CATCH.  Pop the target if the
	initial setup failed.  Add the tfile's thread immediately
	aftwards, before any non-essential setup.  Don't skip
	post_create_inferior if there are no traceframes present in the
	file.
	(tfile_close): Remove redundant check for null before xfree call.
	(tfile_thread_alive): New function.
	(init_tfile_ops): Register it as to_thread_alive callback.
@
text
@d1903 3
d1910 10
a1919 1
  if (target_get_trace_status (current_trace_status ()) < 0)
@


1.225
log
@2011-05-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* tracepoint.c (tfile_open): Delete #if 0'd code.
@
text
@d54 1
d84 2
d3299 1
a3336 2
  push_target (&tfile_ops);

d3349 2
d3365 1
a3365 4
  /* Read through a section of newline-terminated lines that
     define things like tracepoints.  */
  i = 0;
  while (1)
d3367 6
a3372 1
      tfile_read (&byte, 1);
d3374 14
a3387 9
      ++bytes;
      if (byte == '\n')
	{
	  /* Empty line marks end of the definition section.  */
	  if (i == 0)
	    break;
	  linebuf[i] = '\0';
	  i = 0;
	  tfile_interp_line (linebuf, &uploaded_tps, &uploaded_tsvs);
d3389 14
a3402 4
      else
	linebuf[i++] = byte;
      if (i >= 1000)
	error (_("Excessively long lines in trace file"));
d3405 7
a3419 18
  /* Record the starting offset of the binary trace data.  */
  trace_frames_offset = bytes;

  /* If we don't have a blocksize, we can't interpret the
     traceframes.  */
  if (trace_regblock_size == 0)
    error (_("No register block size recorded in trace file"));
  if (ts->traceframe_count <= 0)
    {
      warning (_("No traceframes present in this file."));
      return;
    }

#define TFILE_PID (1)
  inferior_appeared (current_inferior (), TFILE_PID);
  inferior_ptid = pid_to_ptid (TFILE_PID);
  add_thread_silent (inferior_ptid);

d3725 2
a3726 2
  if (trace_filename)
    xfree (trace_filename);
d4219 6
d4297 1
@


1.224
log
@2011-05-19  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (tfile_trace_find): Return directly when num is -1.
@
text
@a3410 5

#if 0
  /* FIXME this will get defined in MI patch submission.  */
  tfind_1 (tfind_number, 0, 0, 0, 0);
#endif
@


1.223
log
@Add support for enabling and disabling tracepoints while a trace
experiment is still running.

gdb/
	* breakpoint.c (disable_breakpoint): Disable all locations
	associated with a tracepoint on target if a trace experiment is
	running.
	(disable_command): Disable a specific tracepoint location on target if
	a trace	experiment is running.
	(do_enable_breakpoint): Enable all locations associated with a
	tracepoint on target if a trace experiment is running.
	(enable_command) Enable a specific tracepoint location on target if a
	trace experiment is running.
	* target.c (update_current_target): Add INHERIT and de_fault clauses for
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint.
	* target.h: Add declaration of struct bp_location.
	(struct target_ops): Add new functions
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint to target operations.
	(target_supports_enable_disable_tracepoint): New macro.
	(target_enable_tracepoint): New macro.
	(target_disable_tracepoint): New macro.
	* remote.c (struct remote_state): Add new field.
	(remote_enable_disable_tracepoint_feature): New.
	(remote_protocol_features): Add new entry.
	(remote_supports_enable_disable_tracepoint): New.
	(remote_enable_tracepoint): New.
	(remote_disable_tracepoint): New.
	(init_remote_ops): Add remote_enable_tracepoint,
	remote_disable_tracepoint and remote_supports_enable_disable_tracepoint
	to remote operations.
	* tracepoint.c (start_tracing): Allow tracing to start without any
	tracepoints enabled with just a warning if they can be re-enabled
	later.
	* NEWS: Add news item for the new behaviour of the enable and disable
	GDB commands when applied to tracepoints.
	Add news items for the new remote packets QTEnable and QTDisable.

gdb/doc/
	* gdb.texinfo: Document change in the behaviour of the enable and
	disable GDB commands when applied to tracepoints.
	Document the EnableDisableTracepoints remote stub feature.
	Document QTEnable and QTDisable in the list of tracepoint packets.

gdb/gdbserver/
	* server.c (handle_query): Add EnableDisableTracepoints to the list
	of supported features.
	* tracepoint.c (clear_installed_tracepoints): Uninstall	disabled
	tracepoints.
	(cmd_qtenable_disable): New.
	(cmd_qtstart): Install tracepoints even if disabled.
	(handle_tracepoint_general_set): Add call to cmd_qtenable_disable on
	receiving a QTEnable or QTDisable packet.
	(gdb_collect): Skip data collection if fast tracepoint is disabled.
	(ust_marker_to_static_tracepoint): Do not ignore disabled static
	tracepoints.
	(gdb_probe): Skip data collection if static tracepoint is disabled.
@
text
@d3818 6
@


1.222
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@a1585 1
  /* No point in tracing with only disabled tracepoints.  */
d1588 9
a1596 2
      VEC_free (breakpoint_p, tp_vec);
      error (_("No tracepoints enabled, not starting trace"));
@


1.221
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (decode_line_spec): Update.
	* python/python.c (gdbpy_decode_line): Update.
	* linespec.h (decode_line_1): Update.
	* linespec.c (decode_line_1): Remove 'not_found_ptr' argument.
	(decode_compound, find_method, symtab_from_filename)
	(decode_variable): Likewise.
	* cli/cli-cmds.c (edit_command): Update.
	(list_command): Update.
	* breakpoint.c (parse_breakpoint_sals): Remove 'not_found_ptr'
	argument.
	(create_breakpoint): Update.
	(until_break_command): Update.
	(addr_string_to_sals): Update.
	(decode_line_spec_1): Update.
@
text
@d237 1
a237 1
/* Free and and clear the traceframe info cache of the current
@


1.220
log
@	gdb/
	* tracepoint.c (set_traceframe_context): Handle unavailable PC
	gracefully.
@
text
@d2336 1
a2336 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL, NULL);
@


1.220.2.1
log
@2011-05-20  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (tfile_trace_find): Return directly when num is -1.
@
text
@a3811 6
  else if (num == -1)
    {
      if (tpp)
        *tpp = -1;
      return -1;
    }
@


1.220.2.2
log
@2011-05-20  Pedro Alves  <pedro@@codesourcery.com>

	* tracepoint.c (tfile_open): Delete #if 0'd code.
@
text
@d3405 5
@


1.220.2.3
log
@2011-05-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* tracepoint.c: Include exceptions.h.
	(TFILE_PID): Move higher in file.
	(tfile_open): Delay pushing the tfile target until we're assured
	the tfile header is present in the file.  Wrap reading the initial
	newline-terminated lines in TRY_CATCH.  Pop the target if the
	initial setup failed.  Add the tfile's thread immediately
	aftwards, before any non-essential setup.  Don't skip
	post_create_inferior if there are no traceframes present in the
	file.
	(tfile_close): Remove redundant check for null before xfree call.
	(tfile_thread_alive): New function.
	(init_tfile_ops): Register it as to_thread_alive callback.
@
text
@a53 1
#include "exceptions.h"
a82 2
#define TFILE_PID (1)

a3289 1
  volatile struct gdb_exception ex;
d3327 2
a3340 2
  push_target (&tfile_ops);

d3355 4
a3358 1
  TRY_CATCH (ex, RETURN_MASK_ALL)
d3360 4
a3363 4
      /* Read through a section of newline-terminated lines that
	 define things like tracepoints.  */
      i = 0;
      while (1)
d3365 6
a3370 16
	  tfile_read (&byte, 1);

	  ++bytes;
	  if (byte == '\n')
	    {
	      /* Empty line marks end of the definition section.  */
	      if (i == 0)
		break;
	      linebuf[i] = '\0';
	      i = 0;
	      tfile_interp_line (linebuf, &uploaded_tps, &uploaded_tsvs);
	    }
	  else
	    linebuf[i++] = byte;
	  if (i >= 1000)
	    error (_("Excessively long lines in trace file"));
d3372 4
a3375 14

      /* Record the starting offset of the binary trace data.  */
      trace_frames_offset = bytes;

      /* If we don't have a blocksize, we can't interpret the
	 traceframes.  */
      if (trace_regblock_size == 0)
	error (_("No register block size recorded in trace file"));
    }
  if (ex.reason < 0)
    {
      /* Pop the partially set up target.  */
      pop_target ();
      throw_exception (ex);
a3377 7
  inferior_appeared (current_inferior (), TFILE_PID);
  inferior_ptid = pid_to_ptid (TFILE_PID);
  add_thread_silent (inferior_ptid);

  if (ts->traceframe_count <= 0)
    warning (_("No traceframes present in this file."));

d3386 18
d3709 2
a3710 2
  xfree (trace_filename);
  trace_filename = NULL;
a4202 6
static int
tfile_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  return 1;
}

a4274 1
  tfile_ops.to_thread_alive = tfile_thread_alive;
@


1.220.2.4
log
@commit 7f71565092a430e0a7509868b7279497db6f7cbe
Author: Tom Tromey <tromey@@redhat.com>
Date:   Mon Apr 4 17:41:05 2011 +0000

gdb/
	* tracepoint.c (scope_info): Update.
	* symtab.c (decode_line_spec): Update.
	* python/python.c (gdbpy_decode_line): Update.
	* linespec.h (decode_line_1): Update.
	* linespec.c (decode_line_1): Remove 'not_found_ptr' argument.
	(decode_compound, find_method, symtab_from_filename)
	(decode_variable): Likewise.
	* cli/cli-cmds.c (edit_command): Update.
	(list_command): Update.
	* breakpoint.c (parse_breakpoint_sals): Remove 'not_found_ptr'
	argument.
	(create_breakpoint): Update.
	(until_break_command): Update.
	(addr_string_to_sals): Update.
	(decode_line_spec_1): Update.
@
text
@d2339 1
a2339 1
  sals = decode_line_1 (&args, 1, NULL, 0, NULL);
@


1.219
log
@	Fix ARI warnings about new lines at the end of messages, which
	are unneeded as there is a new line added at the end of the message
	automatically.
	* darwin-nat.c (darwin_stop_inferior): Ditto.
	* dec-thread.c (dec_thread_get_ada_task_ptid): Ditto.
	* dfp.c (decimal_to_number): Ditto.
	* exec.c (print_section_info): Ditto.
	* i386-darwin-nat.c (darwin_set_sstep): Ditto.
	* osdata.c (get_osdata): Ditto.
	* record.c (bfdcore_write): Ditto.
	* remote-mips.c (mips_readchar): Ditto.
	* remote.c (read_ptid): Ditto.
	* ser-mingw.c (ser_windows_raw): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	* windows-nat.c (fake_create_process): Ditto.
@
text
@d271 13
a283 1
  if (trace_frame == NULL)	/* Cease debugging any trace buffers.  */
d285 2
a286 5
      traceframe_fun = 0;
      traceframe_sal.pc = traceframe_sal.line = 0;
      traceframe_sal.symtab = NULL;
      clear_internalvar (lookup_internalvar ("trace_func"));
      clear_internalvar (lookup_internalvar ("trace_file"));
a287 1
      return;
a289 10
  /* Save as globals for internal use.  */
  trace_pc = get_frame_pc (trace_frame);
  traceframe_sal = find_pc_line (trace_pc, 0);
  traceframe_fun = find_pc_function (trace_pc);

  /* Save linenumber as "$trace_line", a debugger variable visible to
     users.  */
  set_internalvar_integer (lookup_internalvar ("trace_line"),
			   traceframe_sal.line);

@


1.218
log
@	* tracepoint.c (stop_tracing): Don't declare.
	* event-top.c (after_char_processing_hook): Add `(void)'.
@
text
@d1125 1
a1125 1
	  warning (_("Can't collect args; no symbol table info available.\n"));
@


1.217
log
@	Fix ARI warning about functions without parameters that do not
	use (void).
	* breakpoint.c (all_tracepoints): Replace () by (void).
	* f-exp.y (match_string_literal): Ditto.
	(yylex): Ditto.
	* m2-exp.y (yylex): Ditto.
	* mep-tdep.c (current_me_module): Ditto.
	(current_options): Ditto.
	(current_cop_data_bus_width): Ditto.
	(current_cr_names): Ditto.
	(current_cr_is_float): Ditto.
	(current_ccr_names): Ditto.
	* objc-exp.y (yylex): Ditto.
	* p-exp.y (yylex): Ditto.
	* remote.c (send_interrupt_sequence): Ditto.
	* tracepoint.c (current_trace_status): Ditto.
	* python/py-evts.c (gdbpy_initialize_py_events): Ditto.
	* python/py-prettyprint.c (push_dummy_python_frame): Ditto.
@
text
@a72 2
extern void stop_tracing ();

@


1.216
log
@	* tracepoint.c (trace_actions_command): Update.
	* thread.c (thread_apply_command): Update.
	* reverse.c (delete_bookmark_command): Update.
	(bookmarks_info): Update.
	* printcmd.c (undisplay_command): Update.
	* memattr.c (mem_enable_command): Update.
	(mem_disable_command): Update.
	(mem_delete_command): Update.
	* inferior.c (detach_inferior_command): Update.
	(kill_inferior_command): Update.
	(remove_inferior_command): Update.
	* cli/cli-utils.h (struct get_number_or_range_state): New.
	(init_number_or_range): Declare.
	(get_number_or_range): Update.
	* cli/cli-utils.c (init_number_or_range): New function.
	(get_number_or_range): Change 'pp' parameter to 'state'.  Remove
	static variables.
	(number_is_in_list): Update.
	* breakpoint.h (get_tracepoint_by_number): Update.
	* breakpoint.c (map_breakpoint_numbers): Update for change to
	get_number_or_range.
	(find_location_by_number): Use get_number, not
	get_number_or_range.
	(trace_pass_set_count): New function.
	(trace_pass_command): Update for change to get_number_or_range.
	Rework loop logic.
	(get_tracepoint_by_number): Remove 'multi_p' parameter; add
	'state' parameter.
@
text
@d221 1
a221 1
current_trace_status ()
@


1.215
log
@2011-03-01  Michael Snyder  <msnyder@@vmware.com>

	* tracepoint.c (create_tsv_from_upload): Superfluous call
	to xstrdup.  Callee already calls xstrdup.
@
text
@d584 1
a584 1
  t = get_tracepoint_by_number (&args, 0, 1);
@


1.214
log
@2011-03-01  Michael Snyder  <msnyder@@vmware.com>

	* tracepoint.c (scope_info): Fix mem leak, remove underused
	variable.
@
text
@d3193 1
a3193 1
  tsv = create_trace_state_variable (xstrdup (buf));
@


1.213
log
@Revert the following change (not approved yet):

	2011-02-21  Hui Zhu  <teawater@@gmail.com>
	* Makefile.in (HFILES_NO_SRCDIR): Add printcmd.h.
	* ax-gdb.c (gen_printf_expr_callback): New function.
	* ax-gdb.h (gen_printf_expr_callback): Forward declare.
	* ax-general.c (ax_memcpy): New function.
	(ax_print): Handle "printf".
	(ax_reqs): Ditto.
	* ax.h (ax_memcpy): Forward declare.
	* common/ax.def (invalid2): Removed.
	(printf): New entry.
	* printcmd.c (printcmd.h): New include.
	(string_printf): New function.
	(ui_printf): Removed.
	(printf_command): Remove static.  Call string_printf.
	(eval_command): Call string_printf.
	* printcmd.h: New file.
	* tracepoint.c (validate_actionline,
	encode_actions_1): handle printf_command.
@
text
@d2330 1
a2330 1
  char **canonical, *symname, *save_args = args;
d2340 1
a2340 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical, NULL);
@


1.212
log
@2011-02-21  Hui Zhu  <teawater@@gmail.com>

	* Makefile.in (HFILES_NO_SRCDIR): Add printcmd.h.
	* ax-gdb.c (gen_printf_expr_callback): New function.
	* ax-gdb.h (gen_printf_expr_callback): Forward declare.
	* ax-general.c (ax_memcpy): New function.
	(ax_print): Handle "printf".
	(ax_reqs): Ditto.
	* ax.h (ax_memcpy): Forward declare.
	* common/ax.def (invalid2): Removed.
	(printf): New entry.
	* printcmd.c (printcmd.h): New include.
	(string_printf): New function.
	(ui_printf): Removed.
	(printf_command): Remove static.  Call string_printf.
	(eval_command): Call string_printf.
	* printcmd.h: New file.
	* tracepoint.c (validate_actionline,
	encode_actions_1): handle printf_command.
@
text
@a53 1
#include "printcmd.h"
a765 22
  else if (cmd_cfunc_eq (c, printf_command))
    {
      char fbuf[101];

      for (loc = t->loc; loc; loc = loc->next)
	{
	  int nargs;
	  aexpr = new_agent_expr (loc->gdbarch, loc->address);
	  old_chain = make_cleanup_free_agent_expr (aexpr);
	  string_printf (p, NULL, gen_printf_expr_callback,
			 loc, aexpr);
	  ax_simple (aexpr, aop_end);
	  /* The agent expr include expr for arguments, format string, 1 byte
	     for aop_printf, 1 byte for the number of arguments, 1 byte for
	     size of format string, 1 byte for blank after format string
	     and 1 byte for aop_end.  */
	  if (aexpr->len > MAX_AGENT_EXPR_LEN)
	    error (_("Expression is too complicated."));
	  do_cleanups (old_chain);
	}
    }

a1476 16
      else if (cmd_cfunc_eq (cmd, printf_command))
	{
          char fbuf[101];
	  struct cleanup *old_chain = NULL;

	  aexpr = new_agent_expr (tloc->gdbarch, tloc->address);
	  old_chain = make_cleanup_free_agent_expr (aexpr);
	  string_printf (action_exp, NULL, gen_printf_expr_callback,
			 tloc, aexpr);
	  ax_simple (aexpr, aop_end);

	  ax_reqs (aexpr);
	  report_agent_reqs_errors (aexpr);
	  discard_cleanups (old_chain);
	  add_aexpr (collect, aexpr);
	}
@


1.211
log
@2011-02-16  Pedro Alves  <pedro@@codesourcery.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	gdb/
	* tracepoint.c (memrange_sortmerge): Fix list A's end calculation.

2011-02-16  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* collection.c (globalarr2): New global.
	(main): Initialize it before collecting, and and clear it
	afterwards.
	* collection.exp (gdb_collect_globals_test): Test collecting
	overlapping memory ranges.
@
text
@d54 1
d767 22
d1500 16
@


1.210
log
@	gdb/
	* memrange.c (compare_mem_ranges): Mention sort order in
	describing comment.
	(normalize_mem_ranges): Add comment.  Fix ra->length calculation.
	* tracepoint.c (traceframe_available_memory): Extend comment to
	mention what happens to RESULT when the target does not support
	the query.
@
text
@d849 2
a850 1
	      memranges->list[a].end = memranges->list[b].end;
@


1.209
log
@	gdb/testuite/
	* gdb.trace/unavailable.cc (a, b, c): New globals.
	(main): Set and clear them.
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Collect
	`a' and `c', and check that `b' isn't collected, although `a' and
	`c' are.

	gdb/
	* tracepoint.c (memrange_sortmerge): Don't merge ranges that are
	almost but not quite adjacent.
@
text
@d4638 5
a4642 4
/* Return in RESULT, the set of collected memory in the current
   traceframe, found within the LEN bytes range starting at MEMADDR.
   Returns true if the target supports the query, otherwise returns
   false.  */
@


1.208
log
@	gdb/
	* target.c (target_read_live_memory): New function.
	(memory_xfer_live_readonly_partial): New.
	(memory_xfer_partial): If reading from a traceframe, fallback to
	reading unavailable read-only memory from read-only regions of
	live target memory.
	* tracepoint.c (disconnect_tracing): Adjust.
	(set_current_traceframe): New, factored out from
	set_traceframe_number.
	(set_traceframe_number): Reimplement to only change the traceframe
	number on the GDB side.
	(do_restore_current_traceframe_cleanup): Adjust.
	(make_cleanup_restore_traceframe_number): New.
	(cur_traceframe_number): New global.
	(tfile_open): Set cur_traceframe_number to no traceframe.
	(set_tfile_traceframe): New function.
	(tfile_trace_find): If looking up a traceframe using any method
	other than by number, make sure the current tfile traceframe
	matches gdb's current traceframe.  Update the current tfile
	traceframe if the lookup succeeded.
	(tfile_fetch_registers, tfile_xfer_partial)
	(tfile_get_trace_state_variable_value): Make sure the remote
	traceframe matches gdb's current traceframe.
	* remote.c (remote_traceframe_number): New global.
	(remote_open_1): Set it to -1.
	(set_remote_traceframe): New function.
	(remote_fetch_registers, remote_store_registers)
	(remote_xfer_memory, remote_xfer_partial)
	(remote_get_trace_state_variable_value): Make sure the remote
	traceframe matches gdb's current traceframe.
	(remote_trace_find): If looking up a traceframe using any method
	other than by number, make sure the current remote traceframe
	matches gdb's current traceframe.  Update the current remote
	traceframe if the lookup succeeded.
	* infrun.c (fetch_inferior_event): Adjust.
	* tracepoint.h (set_current_traceframe): Declare.
	(get_traceframe_number, set_traceframe_number): Add describing
	comments.
@
text
@d844 4
a847 3
	  if (memranges->list[a].type == memranges->list[b].type &&
	      memranges->list[b].start - memranges->list[a].end <=
	      MAX_REGISTER_SIZE)
d849 1
a849 3
	      /* memrange b starts before memrange a ends; merge them.  */
	      if (memranges->list[b].end > memranges->list[a].end)
		memranges->list[a].end = memranges->list[b].end;
@


1.207
log
@2011-02-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* Makefile.in (SFILES): Add memrange.c.
	(HFILES_NO_SRCDIR): Add memrange.h.
	(COMMON_OBS): Add memrange.o.
	* memrange.c: New file.
	* memrange.h: New file.
	* tracepoint.c: Include memrange.h.
	(struct mem_range): Delete.
	(mem_range_s): Delete.
	(traceframe_available_memory): New function.
	* tracepoint.h (traceframe_available_memory): Declare.
@
text
@d1930 1
a1930 1
  set_traceframe_number (-1);
d2938 1
a2938 1
set_traceframe_number (int num)
d2962 9
d2984 1
a2984 1
  set_traceframe_number (old->traceframe_number);
d3007 6
d3265 1
d3357 2
d3773 22
d3811 6
d3869 1
d3986 2
d4071 3
a4073 1
  if (traceframe_number != -1)
d4156 2
@


1.206
log
@	gdb/
	* target.h (struct traceframe_info): Forward declare.
	(enum target_object): Add TARGET_OBJECT_TRACEFRAME_INFO.
	(struct target_ops) <to_traceframe_info>: New field.
	(target_traceframe_info): New.
	* target.c (update_current_target): Inherit and default
	to_traceframe_info.
	* remote.c (PACKET_qXfer_traceframe_info): New.
	(remote_protocol_features): Register qXfer:traceframe-info:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_TRACEFRAME_INFO.
	(remote_traceframe_info): New.
	(init_remote_ops): Install it.
	(_initialize_remote): Install "set/show remote traceframe-info"
	commands.
	* tracepoint.h (parse_traceframe_info): Declare.
	* tracepoint.c (struct mem_range): New.
	(mem_range_s): New typedef.
	(struct traceframe_info): New.
	(traceframe_info): New global.
	(free_traceframe_info): New function.
	(clear_traceframe_info): New function.
	(start_tracing, tfind_1, set_traceframe_number): Clear traceframe
	info.
	(build_traceframe_info): New function.
	(tfile_traceframe_info): New function.
	(init_tfile_ops): Install tfile_traceframe_info.
	(traceframe_info_start_memory, free_result): New functions.
	(memory_attributes, traceframe_info_elements): New globals.
	(parse_traceframe_info, get_traceframe_info): New functions.
	* features/traceframe-info.dtd: New file.
	* Makefile.in (XMLFILES): Add traceframe-info.dtd.

	gdb/gdbserver/
	* server.c (handle_qxfer_traceframe_info): New.
	(qxfer_packets): Register "traceframe-info".
	(handle_query): Report support for qXfer:traceframe-info:read+.
	* tracepoint.c (match_blocktype): New.
	(traceframe_find_block_type): Rename to ...
	(traceframe_walk_blocks): ... this.  Add callback filter argument,
	and use it.
	(traceframe_find_block_type): New, reimplemented on top of
	traceframe_walk_blocks.
	(build_traceframe_info_xml): New.
	(traceframe_read_info): New.
	* server.h (traceframe_read_info): Declare.

	gdb/doc/
	* gdb.texinfo (Remote Configuration): Mention set/show remote
	traceframe-info.
	(Tools/Packages Optional for Building GDB): Mention that expat is
	used for traceframe info.
	(Remote Protocol) <Menu>: Add "Traceframe Info Format".
	(General Query Packets) <qSupported>: Describe the
	qXfer:traceframe-info:read feature.
	(qXfer::read): Describe qXfer:traceframe-info:read.
	(Traceframe Info Format): New section.
@
text
@d53 1
a133 15
/* Defines a [START, START + LENGTH) memory range.  */

struct mem_range
{
  /* Lowest address in the range.  */
  CORE_ADDR start;

  /* Length of the range.  */
  int length;
};

typedef struct mem_range mem_range_s;

DEF_VEC_O(mem_range_s);

d4586 43
@


1.205
log
@Add missing i18n markup in tracepoint.c:traceframe_walk_blocks

gdb/ChangeLog:

 	* tracepoint.c (traceframe_walk_blocks): Add missing i18n markup
 	in error message.
@
text
@d133 23
d174 6
d240 23
d1652 1
d2020 1
d2972 2
d4167 50
d4238 1
d4490 110
@


1.204
log
@	gdb/
	* tracepoint.c (tfile_xfer_partial): If there's no traceframe
	selected, don't try iterating over the traceframe's blocks.
	(tfile_has_stack): If there's no traceframe selected, then there's
	no stack.
	(tfile_has_registers): If there's no traceframe selected, then
	there's no registers.

	gdb/testsuite/
	* gdb.trace/tfile.exp: Test that with no traceframe selected,
	there's no stack or registers.
@
text
@d3860 1
a3860 1
	  error ("Unknown block type '%c' (0x%x) in trace frame",
@


1.203
log
@	gdb/
	* tracepoint.c (tfile_read): New.
	(tfile_open): Use it.
	(tfile_get_traceframe_address): Use it.
	(tfile_trace_find): Use it.
	(walk_blocks_callback_func): New typedef.
	(match_blocktype): New function.
	(traceframe_walk_blocks): New function.
	(traceframe_find_block_type): New function.
	(tfile_fetch_registers, tfile_xfer_partial)
	(tfile_get_trace_state_variable_value): Use
	traceframe_find_block_type and tfile_read.
@
text
@a3972 2
  int pos;

d3980 1
a3980 3
  /* Iterate through the traceframe's blocks, looking for memory.  */
  pos = 0;
  while ((pos = traceframe_find_block_type ('M', pos)) >= 0)
d3982 1
a3982 2
      ULONGEST maddr, amt;
      unsigned short mlen;
d3984 3
a3986 12
      tfile_read ((gdb_byte *) &maddr, 8);
      maddr = extract_unsigned_integer ((gdb_byte *) &maddr, 8,
					gdbarch_byte_order (target_gdbarch));
      tfile_read ((gdb_byte *) &mlen, 2);
      mlen = (unsigned short)
	extract_unsigned_integer ((gdb_byte *) &mlen, 2,
				  gdbarch_byte_order (target_gdbarch));

      /* If the block includes the first part of the desired range,
	 return as much it has; GDB will re-request the remainder,
	 which might be in a different block of this trace frame.  */
      if (maddr <= offset && offset < (maddr + mlen))
d3988 20
a4007 3
	  amt = (maddr + mlen) - offset;
	  if (amt > len)
	    amt = len;
d4009 6
a4014 2
	  tfile_read (readbuf, amt);
	  return amt;
a4015 3

      /* Skip over this block.  */
      pos += (8 + 2 + mlen);
d4102 1
a4102 1
  return 1;
d4108 1
a4108 1
  return 1;
@


1.202
log
@	* regcache.c (struct regcache_descr): Rename
	sizeof_raw_register_valid_p field to sizeof_raw_register_status,
	and sizeof_cooked_register_valid_p to
	sizeof_cooked_register_status.
	(init_regcache_descr): Adjust.
	(struct regcache): Rename register_valid_p field to
	register_status.
	(regcache_xmalloc_1, regcache_xfree, regcache_save)
	(do_cooked_read): Adjust.
	(regcache_valid_p): Rename to ...
	(regcache_register_status): ... this.  Adjust.
	(regcache_invalidate): Adjust.
	(regcache_raw_read, regcache_cooked_read, regcache_raw_write):
	Adjust.
	(regcache_raw_supply): Adjust.  If buf i NULL, mark the register
	as unavailable, not valid.
	(regcache_dump): Adjust.
	* regcache.h (enum register_status): New.
	(regcache_register_status): Declare.
	(regcache_invalidate): Delete declaration.
	* corelow.c (get_core_registers): Adjust.
	* tracepoint.c (tfile_fetch_registers): Adjust.
	* trad-frame.c (REG_VALUE): Rename to ...
	(TF_REG_VALUE): ... this.
	(REG_UNKNOWN): Rename to ...
	(TF_REG_UNKNOWN): ... this.
	(trad_frame_set_value, trad_frame_set_unknown): Adjust.
	* mi/mi-main.c (register_changed_p): Adjust.
@
text
@d3215 18
d3243 1
a3243 1
  int bytes, i, gotten;
d3280 1
a3280 5
  gotten = read (trace_fd, &header, TRACE_HEADER_SIZE);
  if (gotten < 0)
    perror_with_name (trace_filename);
  else if (gotten < TRACE_HEADER_SIZE)
    error (_("Premature end of file while reading trace file"));
d3304 1
a3304 5
      gotten = read (trace_fd, &byte, 1);
      if (gotten < 0)
	perror_with_name (trace_filename);
      else if (gotten < 1)
	error (_("Premature end of file while reading trace file"));
a3691 1
  int gotten;
d3697 1
a3697 5
  gotten = read (trace_fd, &tpnum, 2);
  if (gotten < 0)
    perror_with_name (trace_filename);
  else if (gotten < 2)
    error (_("Premature end of file while reading trace file"));
d3723 1
a3723 1
  int tfnum = 0, found = 0, gotten;
d3734 1
a3734 5
      gotten = read (trace_fd, &tpnum, 2);
      if (gotten < 0)
	perror_with_name (trace_filename);
      else if (gotten < 2)
	error (_("Premature end of file while reading trace file"));
d3741 1
a3741 5
      gotten = read (trace_fd, &data_size, 4);	
      if (gotten < 0)
	perror_with_name (trace_filename);
      else if (gotten < 4)
	error (_("Premature end of file while reading trace file"));
d3795 84
d3888 1
a3888 1
  int pos, offset, regn, regsize, gotten, pc_regno;
d3899 1
a3899 3
  lseek (trace_fd, cur_offset, SEEK_SET);
  pos = 0;
  while (pos < cur_data_size)
d3901 1
a3901 5
      gotten = read (trace_fd, &block_type, 1);
      if (gotten < 0)
	perror_with_name (trace_filename);
      else if (gotten < 1)
	error (_("Premature end of file while reading trace file"));
d3903 10
a3912 14
      ++pos;
      switch (block_type)
	{
	case 'R':
	  gotten = read (trace_fd, regs, trace_regblock_size);
	  if (gotten < 0)
	    perror_with_name (trace_filename);
	  else if (gotten < trace_regblock_size)
	    error (_("Premature end of file while reading trace file"));

	  /* Assume the block is laid out in GDB register number order,
	     each register with the size that it has in GDB.  */
	  offset = 0;
	  for (regn = 0; regn < gdbarch_num_regs (gdbarch); regn++)
d3914 6
a3919 5
	      regsize = register_size (gdbarch, regn);
	      /* Make sure we stay within block bounds.  */
	      if (offset + regsize >= trace_regblock_size)
		break;
	      if (regcache_register_status (regcache, regn) == REG_UNKNOWN)
d3921 1
a3921 9
		  if (regno == regn)
		    {
		      regcache_raw_supply (regcache, regno, regs + offset);
		      break;
		    }
		  else if (regno == -1)
		    {
		      regcache_raw_supply (regcache, regn, regs + offset);
		    }
a3922 1
	      offset += regsize;
d3924 1
a3924 23
	  return;
	case 'M':
	  lseek (trace_fd, 8, SEEK_CUR);
	  gotten = read (trace_fd, &mlen, 2);
	  if (gotten < 0)
	    perror_with_name (trace_filename);
	  else if (gotten < 2)
	    error (_("Premature end of file while reading trace file"));
          mlen = (unsigned short)
		 extract_unsigned_integer ((gdb_byte *) &mlen, 2,
					   gdbarch_byte_order
					       (target_gdbarch));
	  lseek (trace_fd, mlen, SEEK_CUR);
	  pos += (8 + 2 + mlen);
	  break;
	case 'V':
	  lseek (trace_fd, 4 + 8, SEEK_CUR);
	  pos += (4 + 8);
	  break;
	default:
	  error (_("Unknown block type '%c' (0x%x) in trace frame"),
		 block_type, block_type);
	  break;
d3926 1
d3929 2
a3930 4
  /* We get here if no register data has been found.  Although we
     don't like making up numbers, GDB has all manner of troubles when
     the target says some register is not available.  Filling in with
     zeroes is a reasonable fallback.  */
d3973 1
a3973 4
  char block_type;
  int pos, gotten;
  ULONGEST maddr, amt;
  unsigned short mlen;
d3982 1
a3982 1
  lseek (trace_fd, cur_offset, SEEK_SET);
d3984 1
a3984 1
  while (pos < cur_data_size)
d3986 19
a4004 39
      gotten = read (trace_fd, &block_type, 1);
      if (gotten < 0)
	perror_with_name (trace_filename);
      else if (gotten < 1)
	error (_("Premature end of file while reading trace file"));
      ++pos;
      switch (block_type)
	{
	case 'R':
	  lseek (trace_fd, trace_regblock_size, SEEK_CUR);
	  pos += trace_regblock_size;
	  break;
	case 'M':
	  gotten = read (trace_fd, &maddr, 8);
	  if (gotten < 0)
	    perror_with_name (trace_filename);
	  else if (gotten < 8)
	    error (_("Premature end of file while reading trace file"));
          maddr = extract_unsigned_integer ((gdb_byte *) &maddr, 8,
					    gdbarch_byte_order
						(target_gdbarch));
	  gotten = read (trace_fd, &mlen, 2);
	  if (gotten < 0)
	    perror_with_name (trace_filename);
	  else if (gotten < 2)
	    error (_("Premature end of file while reading trace file"));
          mlen = (unsigned short)
		 extract_unsigned_integer ((gdb_byte *) &mlen, 2,
					   gdbarch_byte_order
					       (target_gdbarch));
	  /* If the block includes the first part of the desired
	     range, return as much it has; GDB will re-request the
	     remainder, which might be in a different block of this
	     trace frame.  */
	  if (maddr <= offset && offset < (maddr + mlen))
  	    {
	      amt = (maddr + mlen) - offset;
	      if (amt > len)
		amt = len;
d4006 2
a4007 21
	      gotten = read (trace_fd, readbuf, amt);
	      if (gotten < 0)
		perror_with_name (trace_filename);
	      /* While it's acceptable to return less than was
		 originally asked for, it's not acceptable to return
		 less than what this block claims to contain.  */
	      else if (gotten < amt)
		error (_("Premature end of file while reading trace file"));
	      return amt;
  	    }
	  lseek (trace_fd, mlen, SEEK_CUR);
	  pos += (8 + 2 + mlen);
	  break;
	case 'V':
	  lseek (trace_fd, 4 + 8, SEEK_CUR);
	  pos += (4 + 8);
	  break;
	default:
	  error (_("Unknown block type '%c' (0x%x) in traceframe"),
		 block_type, block_type);
	  break;
d4009 3
d4026 2
a4027 2
	  if ((s->flags & SEC_LOAD) == 0 ||
	      (s->flags & SEC_READONLY) == 0)
d4034 2
d4057 1
a4057 3
  char block_type;
  int pos, vnum, gotten;
  unsigned short mlen;
a4058 1
  lseek (trace_fd, cur_offset, SEEK_SET);
d4060 1
a4060 1
  while (pos < cur_data_size)
d4062 7
a4068 7
      gotten = read (trace_fd, &block_type, 1);
      if (gotten < 0)
	perror_with_name (trace_filename);
      else if (gotten < 1)
	error (_("Premature end of file while reading trace file"));
      ++pos;
      switch (block_type)
d4070 5
a4074 46
	case 'R':
	  lseek (trace_fd, trace_regblock_size, SEEK_CUR);
	  pos += trace_regblock_size;
	  break;
	case 'M':
	  lseek (trace_fd, 8, SEEK_CUR);
	  gotten = read (trace_fd, &mlen, 2);
	  if (gotten < 0)
	    perror_with_name (trace_filename);
	  else if (gotten < 2)
	    error (_("Premature end of file while reading trace file"));
          mlen = (unsigned short)
		 extract_unsigned_integer ((gdb_byte *) &mlen, 2,
					   gdbarch_byte_order
					       (target_gdbarch));
	  lseek (trace_fd, mlen, SEEK_CUR);
	  pos += (8 + 2 + mlen);
	  break;
	case 'V':
	  gotten = read (trace_fd, &vnum, 4);
	  if (gotten < 0)
	    perror_with_name (trace_filename);
	  else if (gotten < 4)
	    error (_("Premature end of file while reading trace file"));
          vnum = (int) extract_signed_integer ((gdb_byte *) &vnum, 4,
					       gdbarch_byte_order
						   (target_gdbarch));
	  if (tsvnum == vnum)
	    {
	      gotten = read (trace_fd, val, 8);
	      if (gotten < 0)
		perror_with_name (trace_filename);
	      else if (gotten < 8)
		error (_("Premature end of file while reading trace file"));
              *val = extract_signed_integer ((gdb_byte *)val, 8,
					     gdbarch_byte_order
						 (target_gdbarch));
	      return 1;
	    }
	  lseek (trace_fd, 8, SEEK_CUR);
	  pos += (4 + 8);
	  break;
	default:
	  error (_("Unknown block type '%c' (0x%x) in traceframe"),
		 block_type, block_type);
	  break;
d4076 1
d4078 1
@


1.201
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d3847 1
a3847 1
	      if (!regcache_valid_p (regcache, regn))
@


1.200
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* charset.c (validate): Internationalization.
	* coffread.c (read_one_sym): Ditto.
	* dwarf2read.c (dwarf2_attach_fields_to_type): Ditto.
	* h8300-tdep.c (H8300_extract_return_value): Ditto.
	* inflow.c (new_tty): Ditto.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* mep-tdep.c (mep_store_return_value): Ditto.
	* score-tdep.c (score7_fetch_insn): Ditto.
	* ser-mingw.c (pipe_windows_open): Ditto.
	* sh64-tdep.c (sh64_extract_return_value): Ditto.
	* spu-tdep.c (spu_register_type): Ditto.
	* tracepoint.c (trace_find_command): Ditto.
	* valarith.c (value_pos): Ditto.
@
text
@d145 1
a145 1
/* Symbol for function for last traceframe collected */
d148 1
a148 1
/* Symtab and line for last traceframe collected */
d151 1
a151 1
/* Tracing command lists */
d228 1
a228 1
   the traceframe context (line, function, file) */
d600 1
a600 1
  /* if EOF is typed, *line is NULL */
d621 2
a622 2
	{			/* repeat over a comma-separated list */
	  QUIT;			/* allow user to bail out with ^C */
d626 1
a626 1
	  if (*p == '$')	/* look for special pseudo-symbols */
d685 2
a686 2
	{			/* repeat over a comma-separated list */
	  QUIT;			/* allow user to bail out with ^C */
d718 1
a718 1
      char *steparg;		/* in case warning is necessary */
d742 1
a742 1
                           else basereg number */
d767 1
a767 1
/* compare memranges for qsort */
d836 1
a836 1
/* Add a memrange to a collection list */
d1005 1
a1005 1
      /* take care of the registers */
d1012 1
a1012 1
	      QUIT;	/* allow user to bail out with ^C */
d1015 1
a1015 1
		  /* assume chars have 8 bits */
d1018 1
a1018 1
		      /* it's used -- record it */
d1039 1
a1039 1
/* The callback for the locals and args iterators  */
d1053 1
a1053 1
/* Add all locals (or args) symbols to collection list */
d1124 1
a1124 1
/* reduce a collection list to string form (for gdb protocol) */
d1150 1
a1150 1
    if (list->regs_mask[i] != 0)	/* skip leading zeroes in regs_mask */
d1152 1
a1152 1
  if (list->regs_mask[i] != 0)	/* prepare to send regs_mask to the stub */
d1160 1
a1160 1
	  QUIT;			/* allow user to bail out with ^C */
d1175 1
a1175 1
      QUIT;			/* allow user to bail out with ^C */
d1211 1
a1211 1
      QUIT;			/* allow user to bail out with ^C */
d1265 1
a1265 1
      QUIT;			/* allow user to bail out with ^C */
d1277 2
a1278 2
	    {			/* repeat over a comma-separated list */
	      QUIT;		/* allow user to bail out with ^C */
d1342 1
a1342 1
		      /* safe because we know it's a simple expression */
d1358 1
a1358 1
		    default:	/* full-fledged expression */
d1370 1
a1370 1
		      /* take care of the registers */
d1378 1
a1378 1
			      QUIT;	/* allow user to bail out with ^C */
d1381 1
a1381 1
				  /* assume chars have 8 bits */
d1384 1
a1384 1
				      /* it's used -- record it */
d1400 2
a1401 2
	    {			/* repeat over a comma-separated list */
	      QUIT;		/* allow user to bail out with ^C */
d1531 1
a1531 1
  /* No point in tracing without any tracepoints... */
d1638 1
a1638 1
  /* should change in response to reply? */
d1953 1
a1953 1
#if 0 /* dubious now? */
d1995 1
a1995 1
      else /* this case may never occur, check */
d2041 1
a2041 1
{ /* this should only be called with a numeric argument */
d2050 1
a2050 1
	frameno = 0;	/* "next" is first one */
d2128 1
a2128 1
	tdp = tracepoint_number;	/* default is current TDP */
d2234 1
a2234 1
      *tmp++ = '\0';	/* terminate start address */
d2241 1
a2241 1
    {			/* no explicit end address? */
d2260 1
a2260 1
    { /* XXX FIXME: what should default behavior be? */
d2267 1
a2267 1
      *tmp++ = '\0';	/* terminate start address */
d2274 1
a2274 1
    {			/* no explicit end address? */
d2302 1
a2302 1
    return;		/* presumably decode_line_1 has already warned */
d2304 1
a2304 1
  /* Resolve line numbers to PC */
d2310 1
a2310 1
      QUIT;			/* allow user to bail out with ^C */
d2313 1
a2313 1
	  QUIT;			/* allow user to bail out with ^C */
d2320 1
a2320 1
	    continue;		/* probably botched, certainly useless */
d2328 1
a2328 1
	    case LOC_UNDEF:	/* messed up symbol? */
d2331 1
a2331 1
	      count--;		/* don't count this one */
d2460 1
a2460 1
      QUIT;			/* allow user to bail out with ^C */
d2494 2
a2495 2
		{		/* repeat over a comma-separated list */
		  QUIT;		/* allow user to bail out with ^C */
d3042 1
a3042 1
	  /* FIXME also test conditionals and actions */
d3131 1
a3131 1
  /* (should check against all internal vars?) */
d3223 1
a3223 1
  char linebuf[1000]; /* should be max remote packet size or so */
d3252 1
a3252 1
  discard_cleanups (old_chain);	/* Don't free filename any more */
d3341 1
a3341 1
  /* FIXME this will get defined in MI patch submission */
d3643 1
a3643 1
  inferior_ptid = null_ptid;	/* Avoid confusion from thread stuff */
d3655 1
a3655 1
  /* (it would be useful to mention the name of the file) */
d3684 1
a3684 1
  /* FIXME dig pc out of collected registers */
d3698 1
a3698 1
  /* FIXME this is a poor heuristic if multiple locations */
d4016 1
a4016 1
  /* FIXME account for relocation at some point */
d4486 1
a4486 1
  /* FIXME add a trace variable completer */
@


1.199
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d2045 1
a2045 1
    error ("May not look at trace frames while trace is running.");
d2103 1
a2103 1
    error ("May not look at trace frames while trace is running.");
d2121 1
a2121 1
    error ("May not look at trace frames while trace is running.");
d2160 1
a2160 1
    error ("May not look at trace frames while trace is running.");
d2224 1
a2224 1
    error ("May not look at trace frames while trace is running.");
d2257 1
a2257 1
    error ("May not look at trace frames while trace is running.");
d3329 1
a3329 1
      warning ("No traceframes present in this file.");
d3376 1
a3376 1
    warning ("Ignoring trace file definition \"%s\"", line);
d3881 1
a3881 1
	  error ("Unknown block type '%c' (0x%x) in trace frame",
d3906 2
a3907 2
	      warning ("Tracepoint %d has multiple "
		       "locations, cannot infer $pc",
d3914 2
a3915 1
	      warning ("Tracepoint %d does while-stepping, cannot infer $pc",
d3943 1
a3943 1
    error ("tfile_xfer_partial: trace file is read-only");
d4007 1
a4007 1
	  error ("Unknown block type '%c' (0x%x) in traceframe",
d4113 1
a4113 1
	  error ("Unknown block type '%c' (0x%x) in traceframe",
@


1.198
log
@run copyright.sh for 2011.
@
text
@d235 1
a235 1
  if (trace_frame == NULL)		/* Cease debugging any trace buffers.  */
d367 2
a368 1
      printf_filtered (_("Trace state variable $%s now has initial value %s.\n"),
d378 2
a379 1
  printf_filtered (_("Trace state variable $%s created, with initial value %s.\n"),
d554 2
a555 1
      l = read_command_lines (tmpbuf, from_tty, 1, check_tracepoint_command, t);
d649 2
a650 1
		      error (_("constant `%s' (value %ld) will not be collected."),
d654 2
a655 1
		  else if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_OPTIMIZED_OUT)
d657 2
a658 1
		      error (_("`%s' is optimized away and cannot be collected."),
d863 1
a863 1
  if (type != memrange_absolute)		/* Better collect the base register!  */
d1692 2
a1693 1
	    printf_filtered (_("Trace stopped by an error (%s, tracepoint %d).\n"),
d1712 2
a1713 1
      printf_filtered (_("Buffer contains %d trace frames (of %d created total).\n"),
d1875 2
a1876 1
	  if (!query (_("Trace is running and will continue after detach; detach anyway? ")))
d1881 2
a1882 1
	  if (!query (_("Trace is running but will stop on detach; detach anyway? ")))
d2297 2
a2298 1
    error (_("requires an argument (function, line or *addr) to define a scope"));
d2357 2
a2358 1
	      regno = SYMBOL_REGISTER_OPS (sym)->register_number (sym, gdbarch);
d2381 2
a2382 1
	      regno = SYMBOL_REGISTER_OPS (sym)->register_number (sym, gdbarch);
d2610 2
a2611 1
	   tpnum, phex_nz (addr, sizeof (addr)), srctype, 0, (int) strlen (src));
d2763 2
a2764 1
				"cond", utp->cond_string, buf, MAX_TRACE_UPLOAD);
d3071 4
a3074 2
	printf_filtered (_("Assuming tracepoint %d is same as target's tracepoint %d at %s.\n"),
			 t->number, utp->number, paddress (get_current_arch (), utp->addr));
d3079 4
a3082 2
	    printf_filtered (_("Created tracepoint %d for target's tracepoint %d at %s.\n"),
			     t->number, utp->number, paddress (get_current_arch (), utp->addr));
d3084 4
a3087 2
	    printf_filtered (_("Failed to create tracepoint for target's tracepoint %d at %s, skipping it.\n"),
			     utp->number, paddress (get_current_arch (), utp->addr));
d3165 2
a3166 1
	    printf_filtered (_("Assuming trace state variable $%s is same as target's variable %d.\n"),
d3173 2
a3174 1
	    printf_filtered (_("Created trace state variable $%s for target's variable %d.\n"),
d3416 2
a3417 1
      else if (strncmp (p, stop_reason_names[tracepoint_passcount], p1 - p) == 0)
d3551 2
a3552 1
	    warning (_("Unrecognized char '%c' in tracepoint definition, skipping rest"), *p);
d3906 2
a3907 1
	      warning ("Tracepoint %d has multiple locations, cannot infer $pc",
d4150 2
a4151 2
  tfile_ops.to_doc =
    "Use a trace file as a target.  Specify the filename of the trace file.";
d4159 2
a4160 1
  tfile_ops.to_get_trace_state_variable_value = tfile_get_trace_state_variable_value;
@


1.197
log
@2010-10-31  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (tfile_xfer_partial): Change lma to vma.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.196
log
@2010-10-28  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (trace_save): Change utp->actions to
	utp->step_actions.
@
text
@d3994 1
a3994 1
      bfd_vma lma;
d4002 1
a4002 1
	  lma = s->lma;
d4004 1
a4004 1
	  if (lma <= offset && offset < (lma + size))
d4006 1
a4006 1
	      amt = (lma + size) - offset;
d4011 1
a4011 1
					      readbuf, offset - lma, amt);
@


1.195
log
@2010-10-20  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (tfile_get_traceframe_address): Call
	extract_signed_integer.
	(tfile_trace_find): Call extract_signed_integer and
	extract_unsigned_integer.  Change data_size to unsigned int.
	(tfile_fetch_registers): Call extract_unsigned_integer.
	(tfile_xfer_partial): Ditto.
	(tfile_get_trace_state_variable_value): Call
	extract_signed_integer and extract_unsigned_integer.
@
text
@d2737 1
a2737 1
      for (a = 0; VEC_iterate (char_ptr, utp->actions, a, act); ++a)
@


1.194
log
@	* tracepoint.c (merge_uploaded_trace_state_variables): Only print
	messages if info_verbose.
@
text
@d3668 3
d3694 1
a3694 1
  int data_size;
d3709 3
d3720 3
d3844 4
d3940 3
a3942 1

d3948 4
d4054 4
d4067 3
d4077 3
@


1.193
log
@Add missing gettext markup.

gdb/ChangeLog:

        * remote.c (remote_download_tracepoint): Add missing gettext markup.
        * tracepoint.c (parse_static_tracepoint_marker_definition): Likewise.
@
text
@d3142 5
a3146 2
	printf_filtered (_("Assuming trace state variable $%s is same as target's variable %d.\n"),
			 tsv->name, utsv->number);
d3150 3
a3152 2
	  printf_filtered (_("Created trace state variable $%s for target's variable %d.\n"),
			   tsv->name, utsv->number);
@


1.192
log
@gdb/
	Make core files the process_stratum.
	* corefile.c (core_target): New variable.
	(core_file_command): Remove variable t, use core_target.
	* corelow.c (core_ops): Make it static.
	(init_core_ops): Change to process_stratum.  Initialize CORE_TARGET.
	* defs.h (make_cleanup_unpush_target): New prototype.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (core_pid_to_str): Remove core_stratum from its comment.
	* gdbcore.h (core_target): New declaration.
	* inf-ptrace.c (inf_ptrace_create_inferior, inf_ptrace_attach): New
	variables ops_already_pushed and back_to.  Use push_target,
	make_cleanup_unpush_target and discard_cleanups calls.
	* record.c (record_open): Replace core_stratum by a core_bfd check.
	* target.c (target_is_pushed): New function.
	(find_core_target): Remove.
	* target.h (enum strata) <core_stratum>: Remove.
	(target_is_pushed): New declaration.
	(find_core_target): Remove declaration.
	* tracepoint.c (init_tfile_ops) <to_stratum>: Remove comment.
	* utils.c (do_unpush_target, make_cleanup_unpush_target): New functions.

gdb/doc/
	Make core files the process_stratum.
	* gdb.texinfo (Active Targets): Remove core_stratum.  Include
	record_stratum example.

gdb/testsuite/
	Make core files the process_stratum.
	* gdb.base/corefile.exp (run: load core again)
	(run: sanity check we see the core file, run: with core)
	(run: core file is cleared, attach: load core again)
	(attach: sanity check we see the core file, attach: with core)
	(attach: core file is cleared): New tests.
	* gdb.base/coremaker.c (main): New parameters.  Implement "sleep" argv.
@
text
@d4131 1
a4131 1
    error ("bad marker definition: %s", line);
@


1.191
log
@	* breakpoint.c (update_watchpoint, _initialize_breakpoint): Remove
	unnecessary space in string.
	* filesystem.c (_initialize_filesystem): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* infcmd.c (step_once): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* linux-nat.c (linux_child_follow_fork): Ditto.
	* maint.c (maintenance_deprecate): Ditto.
	* memattr.c (_initialize_mem): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* monitor.c (monitor_open): Ditto.
	* procfs.c (procfs_xfer_memory): Ditto.
	* reverse.c (bookmarks_info): Ditto.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Ditto.
	* stack.c (_initialize_stack): Ditto.
	* tracepoint.c (_initialize_tracepoint): Ditto.
	* xtensa-tdep.c (xtensa_supply_gregset,
	xtensa_regset_from_core_section): Ditto.
@
text
@a4100 2
  /* core_stratum might seem more logical, but GDB doesn't like having
     more than one core_stratum vector.  */
@


1.191.2.1
log
@2010-11-02  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (tfile_xfer_partial): Change lma to vma.

2010-11-02  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (trace_save): Change utp->actions to
	utp->step_actions.

2010-11-02  Hui Zhu  <teawater@@gmail.com>

	* tracepoint.c (tfile_get_traceframe_address): Call
	extract_signed_integer.
	(tfile_trace_find): Call extract_signed_integer and
	extract_unsigned_integer.  Change data_size to unsigned int.
	(tfile_fetch_registers): Call extract_unsigned_integer.
	(tfile_xfer_partial): Ditto.
	(tfile_get_trace_state_variable_value): Call
	extract_signed_integer and extract_unsigned_integer.
@
text
@d2737 1
a2737 1
      for (a = 0; VEC_iterate (char_ptr, utp->step_actions, a, act); ++a)
a3663 3
  tpnum = (short) extract_signed_integer ((gdb_byte *)&tpnum, 2,
					  gdbarch_byte_order
					      (target_gdbarch));
d3687 1
a3687 1
  unsigned int data_size;
a3701 3
      tpnum = (short) extract_signed_integer ((gdb_byte *)&tpnum, 2,
					      gdbarch_byte_order
						  (target_gdbarch));
a3709 3
      data_size = (unsigned int) extract_unsigned_integer
                                     ((gdb_byte *)&data_size, 4,
				      gdbarch_byte_order (target_gdbarch));
a3830 4
          mlen = (unsigned short)
		 extract_unsigned_integer ((gdb_byte *)&mlen, 2,
					   gdbarch_byte_order
					       (target_gdbarch));
d3923 1
a3923 3
          maddr = extract_unsigned_integer ((gdb_byte *)&maddr, 8,
					    gdbarch_byte_order
						(target_gdbarch));
a3928 4
          mlen = (unsigned short)
		 extract_unsigned_integer ((gdb_byte *)&mlen, 2,
					   gdbarch_byte_order
					       (target_gdbarch));
d3971 1
a3971 1
      bfd_vma vma;
d3979 1
a3979 1
	  vma = s->vma;
d3981 1
a3981 1
	  if (vma <= offset && offset < (vma + size))
d3983 1
a3983 1
	      amt = (vma + size) - offset;
d3988 1
a3988 1
					      readbuf, offset - vma, amt);
a4030 4
          mlen = (unsigned short)
		 extract_unsigned_integer ((gdb_byte *)&mlen, 2,
					   gdbarch_byte_order
					       (target_gdbarch));
a4039 3
          vnum = (int) extract_signed_integer ((gdb_byte *)&vnum, 4,
					       gdbarch_byte_order
						   (target_gdbarch));
a4046 3
              *val = extract_signed_integer ((gdb_byte *)val, 8,
					     gdbarch_byte_order
						 (target_gdbarch));
@


1.190
log
@	Static tracepoints support, and UST integration.

	gdb/gdbserver/
	* configure.ac: Handle --with-ust.  substitute ustlibs and ustinc.
	* mem-break.c (uninsert_all_breakpoints)
	(reinsert_all_breakpoints): New.
	* mem-break.h (reinsert_all_breakpoints, uninsert_all_breakpoints):
	* tracepoint.c (ust_loaded, helper_thread_id, cmd_buf): New.
	(gdb_agent_ust_loaded, helper_thread_id)
	(gdb_agent_helper_thread_id): New macros.
	(struct ipa_sym_addresses): Add addr_ust_loaded,
	addr_helper_thread_id, addr_cmd_buf.
	(symbol_list): Add ust_loaded, helper_thread_id, cmd_buf.
	(in_process_agent_loaded_ust): New.
	(write_e_ust_not_loaded): New.
	(maybe_write_ipa_ust_not_loaded): New.
	(struct collect_static_trace_data_action): New.
	(enum tracepoint_type) <static_tracepoint>: New.
	(struct tracepoint) <handle>: Mention static tracepoints.
	(struct static_tracepoint_ctx): New.
	(CMD_BUF_SIZE): New.
	(add_tracepoint_action): Handle static tracepoint actions.
	(unprobe_marker_at): New.
	(clear_installed_tracepoints): Handle static tracepoints.
	(cmd_qtdp): Handle static tracepoints.
	(probe_marker_at): New.
	(cmd_qtstart): Handle static tracepoints.
	(response_tracepoint): Handle static tracepoints.
	(cmd_qtfstm, cmd_qtsstm, cmd_qtstmat): New.
	(handle_tracepoint_query): Handle qTfSTM, qTsSTM and qTSTMat.
	(get_context_regcache): Handle static tracepoints.
	(do_action_at_tracepoint): Handle static tracepoint actions.
	(traceframe_find_block_type): Handle static trace data blocks.
	(traceframe_read_sdata): New.
	(download_tracepoints): Download static tracepoint actions.
	[HAVE_UST] Include ust/ust.h, dlfcn.h, sys/socket.h, and sys/un.h.
	(GDB_PROBE_NAME): New.
	(ust_ops): New.
	(GET_UST_SYM): New.
	(USTF): New.
	(dlsym_ust): New.
	(ust_marker_to_static_tracepoint): New.
	(gdb_probe): New.
	(collect_ust_data_at_tracepoint): New.
	(gdb_ust_probe): New.
	(UNIX_PATH_MAX, SOCK_DIR): New.
	(gdb_ust_connect_sync_socket): New.
	(resume_thread, stop_thread): New.
	(run_inferior_command): New.
	(init_named_socket): New.
	(gdb_ust_socket_init): New.
	(cstr_to_hexstr): New.
	(next_st): New.
	(first_marker, next_marker): New.
	(response_ust_marker): New.
	(cmd_qtfstm, cmd_qtsstm): New.
	(unprobe_marker_at, probe_marker_at): New.
	(cmd_qtstmat, gdb_ust_thread): New.
	(gdb_ust_init): New.
	(initialize_tracepoint_ftlib): Call gdb_ust_init.
	* linux-amd64-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(x86_64_st_collect_regmap): New.
	(X86_64_NUM_ST_COLLECT_GREGS): New.
	(AMD64_RIP_REGNUM): New.
	(supply_static_tracepoint_registers): New.
	* linux-i386-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(i386_st_collect_regmap): New.
	(i386_NUM_ST_COLLECT_GREGS): New.
	(supply_static_tracepoint_registers): New.
	* server.c (handle_query): Handle qXfer:statictrace:read.
	<qSupported>: Report support for StaticTracepoints, and
	qXfer:statictrace:read features.
	* server.h (traceframe_read_sdata)
	(supply_static_tracepoint_registers): Declare.
	* remote-utils.c (convert_int_to_ascii, hexchars, ishex, tohex)
	(unpack_varlen_hex): Include in IPA build.
	* Makefile.in (ustlibs, ustinc): New.
	(IPA_OBJS): Add remote-utils-ipa.o.
	($(IPA_LIB)): Link -ldl and -lpthread.
	(UST_CFLAGS): New.
	(IPAGENT_CFLAGS): Add UST_CFLAGS.
	* config.in, configure: Regenerate.

	gdb/
	* NEWS: Mention new support for static tracepoints.
	(New packets): Mention qTfSTM, qTsSTM, qTSTMat and
	qXfer:statictrace:read.
	(New features in the GDB remote stub, GDBserver): Mention static
	tracepoints support using an UST based backend.
	(New commands): Mention "info static-tracepoint-markers" and
	"strace".
	* breakpoint.c (is_marker_spec): New.
	(is_tracepoint): Handle static tracepoints.
	(validate_commands_for_breakpoint): Static tracepoints can't do
	while-stepping.
	(static_tracepoints_here): New.
	(bpstat_what): Handle static tracepoints.
	(print_one_breakpoint_location, allocate_bp_location, mention):
	Ditto.
	(create_breakpoint_sal): Ditto.
	(decode_static_tracepoint_spec): New.
	(create_breakpoint): Replace `hardwareflag', and `traceflag' with
	`type_wanted'.  Adjust.  Handle static tracepoint marker
	locations.
	(break_command_1): Adjust.
	(update_static_tracepoint): New.
	(update_breakpoint_locations): Handle static tracepoints.
	(breakpoint_re_set_one): Handle static tracepoint marker
	locations.
	(disable_command, enable_command): Handle static tracepoints.
	(trace_command, ftrace_command): Adjust.
	(strace_command): New.
	(create_tracepoint_from_upload): Adjust.
	(save_breakpoints): Handle static tracepoints.
	(_initialize_breakpoint): Install the "strace" command.
	* breakpoint.h (enum bptype): New bp_static_tracepoint type.
	(struct breakpoint): New fields static_trace_marker_id and
	static_trace_marker_id_idx.
	(breakpoints_here_p): Declare.
	(create_breakpoint): Adjust.
	(static_tracepoints_here): Declare.
	* remote.c (struct remote_state) <static_tracepoints>: New field.
	(PACKET_qXfer_statictrace_read, PACKET_StaticTracepoints): New.
	(remote_static_tracepoint_marker_at): New.
	(remote_static_tracepoint_markers_by_strid): New.
	(remote_static_tracepoint_feature): New.
	(remote_disconnected_tracing_feature): Handle "StaticTracepoints".
	(remote_xfer_partial): Handle TARGET_OBJECT_STATIC_TRACE_DATA.
	(remote_supports_static_tracepoints): New.
	(remote_download_tracepoint): Download static tracepoints.
	(init_remote_ops): Install remote_static_tracepoint_marker_at and
	remote_static_tracepoint_markers_by_strid.
	(_initialize_remote): Install set|show remote static-tracepoints,
	and set|show remote read-sdata-object commands.
	* target.c (update_current_target): Inherit and default
	to_static_tracepoint_marker_at, and
	to_static_tracepoint_markers_by_strid.
	* target.h (static_tracepoint_marker): Forward declare.
	(enum target_object): New object TARGET_OBJECT_STATIC_TRACE_DATA.
	(static_tracepoint_marker_p): New typedef.
	(DEF_VEC_P(static_tracepoint_marker_p)): New VEC type.
	(struct target_ops): New fields to_static_tracepoint_marker_at and
	to_static_tracepoint_markers_by_strid.
	(target_static_tracepoint_marker_at)
	(target_static_tracepoint_markers_by_strid): New.
	* tracepoint.c: Include source.h.
	(validate_actionline): Handle $_sdata.
	(struct collection_list): New field strace_data.
	(add_static_trace_data): New.
	(clear_collection_list): Clear strace_data.
	(stringify_collection_list): Account for a possible static trace
	data collection.
	(encode_actions_1): Encode an $_sdata collection.
	(parse_tracepoint_definition): Handle static tracepoints.
	(parse_static_tracepoint_marker_definition): New.
	(release_static_tracepoint_marker): New.
	(print_one_static_tracepoint_marker): New.
	(info_static_tracepoint_markers_command): New.
	(sdata_make_value): New.
	(_initialize_tracepoint): Create the $_sdata convenience variable.
	Add the "info static-tracepoint-markers" command.
	Mention $_sdata in the "collect" command's help output.
	* tracepoint.h (struct static_tracepoint_marker): New.
	(parse_static_tracepoint_marker_definition)
	(release_static_tracepoint_marker): Declare.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_new): Adjust.

	doc/
	* gdb.texinfo (Convenience Variables): Document $_sdata.
	(Commands to Set Tracepoints): Describe static tracepoints.  Add
	`Listing Static Tracepoint Markers' menu entry.  Document
	"strace".
	(Tracepoint Action Lists): Document collecting $_sdata.
	(Listing Static Tracepoint Markers): New subsection.
	(Tracepoints support in gdbserver): Mention static tracepoints.
	(remote packets, enabling and disabling): Mention
	read-sdata-object.
	(General Query Packets) <qSupported>: Document qXfer:sdata:read
	and StaticTracepoint.
	Mention qTfSTM, qTsSTM and qTSTMat as tracepoint packets.
	Document qXfer:sdata:read.
	(Tracepoint packets): Document qTfSTM, qTsSTM and qTSTMat.
@
text
@d4455 1
a4455 1
Argument can be a line number (with optional source file), \n\
d4529 2
a4530 2
Tracepoint actions may include collecting of specified data, \n\
single-stepping, or enabling/disabling other tracepoints, \n\
@


1.189
log
@2010-06-11  Stan Shebs  <stan@@codesourcery.com>

	Add per-operation permission flags.

	* target.h (struct target_ops): New method to_set_permissions.
	(target_set_permissions): New macro.
	(target_insert_breakpoint): Change macro to function.
	(target_remove_breakpoint): Ditto.
	(target_stop): Ditto.
	(may_write_registers): Declare.
	(may_write_memory): Declare.
	(may_insert_breakpoints): Declare.
	(may_insert_tracepoints): Declare.
	(may_insert_fast_tracepoints): Declare.
	(may_stop): Declare.
	* target.c (may_write_registers, may_write_registers_1): New globals.
	(may_write_memory, may_write_memory_1): New globals.
	(may_insert_breakpoints, may_insert_breakpoints_1): New globals.
	(may_insert_tracepoints, may_insert_tracepoints_1): New globals.
	(may_insert_fast_tracepoints, may_insert_fast_tracepoints_1): New
	globals.
	(may_stop, may_stop_1): New global.
	(target_xfer_partial): Test for write permission.
	(target_store_registers): Ditto.
	(target_insert_breakpoint): New function.
	(target_remove_breakpoint): New function.
	(target_stop): New function.
	(_initialize_targets): Add new set/show variables.
	(set_write_memory_permission): New function.
	(update_target_permissions): New function.
	(set_target_permissions): New function.
	(update_current_target): Default to_set_permissions.
	(_initialize_targets): Use new globals and setter function.
	* tracepoint.c (start_tracing): Test for permission.
	* inferior.h (update_observer_mode): Declare.
	* infrun.c (non_stop_1): Define earlier.
	(observer_mode, observer_mode_1): New globals.
	(set_observer_mode, show_observer_mode): New functions.
	(update_observer_mode): New function.
	(_initialize_infrun): Define "set observer" command.
	* remote.c (PACKET_QAllow): New optional packet.
	(remote_protocol_features): Add QAllow.
	(remote_set_permissions): New function.
	(remote_start_remote): Call it.
	(init_remote_ops): Add it to target vector.
	(_initialize_remote): Add config command for QAllow.

	* gdb.texinfo (Observer Mode): New section.
	(General Query Packets): Document QAllow.

	* gdb.base/permissions.exp: New file.
@
text
@d50 1
a50 1

d625 4
a628 3
	      if ((0 == strncasecmp ("reg", p + 1, 3)) ||
		  (0 == strncasecmp ("arg", p + 1, 3)) ||
		  (0 == strncasecmp ("loc", p + 1, 3)))
d751 3
d1093 8
d1115 1
d1130 1
a1130 1
  count = 1 + list->next_memrange + list->next_aexpr_elt + 1;
d1133 10
d1302 5
d3507 5
d4111 248
d4365 6
d4433 5
d4518 1
@


1.188
log
@	* remote.c (unpack_varlen_hex): Remove forward declaration.
	(remote_console_output): Make static, and add forward declaration.
	* remote.h: Drop FIXME comment.
	(unpack_varlen_hex): Declare.
	(remote_console_output, remote_cisco_objfile_relocate)
	(deprecated_target_resume_hook, deprecated_target_wait_loop_hook):
	Delete declarations.
	* tracepoint.c: Include "remote.h".
	(unpack_varlen_hex): Delete declaration.
@
text
@d1493 1
a1493 1
  int any_enabled = 0;
d1507 9
a1515 4
	{
	  any_enabled = 1;
	  break;
	}
d1525 6
d1535 5
@


1.187
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* target.c: White space.
	* target-descriptions.c: White space.
	* target-memory.c: White space.
	* thread.c: White space.
	* top.c: White space.
	* tracepoint.c: White space.
	* trad-frame.c: White space.
	* tramp-frame.c: White space.
	* ui-file.c: White space.
	* ui-out.c: White space.
	* user-regs.c: White space.
	* utils.c: White space.
@
text
@d49 1
a3310 2
extern char *unpack_varlen_hex (char *buff, ULONGEST *result);

@


1.186
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* ax-gdb.c (gen_struct_elt_for_reference): Delete unused variables.
	* tracepoint.c (delete_trace_variable_command):
	Delete unused variables.
	(encode_actions_1): Delete unused variables.
	(start_tracing): Delete unused variable.
	(trace_status_mi): Delete unused variable.
	(tfind_1): Delete unused variable.
	(trace_find_pc_command): Delete unused variable.
	(trace_find_line_command): Delete unused variables.
	(trace_find_range_command): Delete unused variables.
	(trace_find_outside_command): Delete unused variables.
	(parse_tracepoint_definition): Delete unused variables.
	(tfile_fetch_registers): Delete unused variable.
@
text
@d1477 1
a1477 1
		2 * collect->aexpr_listsize * sizeof (struct agent_expr *));
d2625 1
@


1.185
log
@* remote.c (register_remote_support_xml)
(remote_query_supported_append, remote_query_supported): Add cast
to NULL used as sentinel.
* tracepoint.c (tvariables_info_1): Likewise.
* utils.c (add_internal_problem_command): Likewise.
@
text
@d385 1
a385 1
  int i, ix;
a387 1
  struct trace_state_variable *tsv;
d400 1
a400 1
  for (i = 0; argv[i] != NULL; i++)
d402 2
a403 2
      if (*argv[i] == '$')
	delete_trace_state_variable (argv[i] + 1);
d405 1
a405 1
	warning (_("Name \"%s\" not prefixed with '$', ignoring"), argv[i]);
a1227 1
  struct command_line *actions;
a1370 1
		  unsigned long addr, len;
d1401 2
a1402 2
	  encode_actions_1 (action->body_list[0], t, tloc, frame_reg, frame_offset,
			    stepping_list, NULL);
a1487 1
  char buf[2048];
a1713 1
  char *string_status;
a1847 1
  char *reply;
a2045 1
  char tmp[40];
a2102 1
  char   startpc_str[40], endpc_str[40];
a2165 1
  char start_str[40], stop_str[40];
a2198 1
  char start_str[40], stop_str[40];
d3431 1
a3431 1
  int enabled, i, end;
d3433 1
a3433 1
  char *cond, *srctype, *src, *buf;
d3720 1
a3720 1
  int i, pos, offset, regn, regsize, gotten, pc_regno;
@


1.184
log
@2010-04-23  Stan Shebs  <stan@@codesourcery.com>

	* ax.h (struct agent_expr): Merge in agent_reqs fields, add some
	comments.
	(struct agent_reqs): Remove.
	(ax_reg_mask): Declare.
	* ax-general.c (new_agent_expr): Add gdbarch argument, set new fields.
	(free_agent_expr): Free reg_mask.
	(ax_print): Add scope and register mask info.
	(ax_reqs): Remove agent_reqs argument, use agent expression
	fields, and move part of register mask computation to...
	(ax_reg_mask): New function.
	* ax-gdb.c (gen_trace_static_fields): Call it.
	(gen_traced_pop): Ditto.
	(is_nontrivial_conversion): Add dummy gdbarch to new_agent_expr.
	(gen_trace_for_var): Pass gdbarch to new_agent_expr.
	(gen_trace_for_expr): Ditto, and clear optimized_out flag.
	(gen_eval_for_expr): Ditto, and require an rvalue.
	(agent_command): Call ax_reqs.
	(agent_eval_command): Ditto.
	* tracepoint.c (report_agent_reqs_errors): Use agent expression fields.
	(validate_action_line): Ditto.
	(collect_symbol): Ditto.
	(encode_actions_1): Ditto.
@
text
@d449 1
a449 1
      name = concat ("$", tsv->name, NULL);
d3174 1
a3174 1
      temp = concat (current_directory, "/", filename, (char *)NULL);
@


1.183
log
@2010-04-21  Stan Shebs  <stan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* tracepoint.c (trace_save): Open in binary mode.
@
text
@d563 1
a563 1
report_agent_reqs_errors (struct agent_expr *aexpr, struct agent_reqs *areqs)
d567 1
a567 1
  if (areqs->flaw != agent_flaw_none)
d572 1
a572 1
  if (areqs->min_height < 0)
d582 1
a582 1
  if (areqs->max_height > 20)
a595 1
  struct agent_reqs areqs;
d665 1
a665 2
	      ax_reqs (aexpr, &areqs);
	      (void) make_cleanup (xfree, areqs.reg_mask);
d667 1
a667 1
	      report_agent_reqs_errors (aexpr, &areqs);
d700 2
a701 4
	      ax_reqs (aexpr, &areqs);
	      (void) make_cleanup (xfree, areqs.reg_mask);

	      report_agent_reqs_errors (aexpr, &areqs);
a972 1
      struct agent_reqs areqs;
d988 1
a988 1
      ax_reqs (aexpr, &areqs);
d990 1
a990 1
      report_agent_reqs_errors (aexpr, &areqs);
d996 1
a996 1
      if (areqs.reg_mask_len > 0)
d1000 1
a1000 1
	  for (ndx1 = 0; ndx1 < areqs.reg_mask_len; ndx1++)
d1003 1
a1003 1
	      if (areqs.reg_mask[ndx1] != 0)
d1007 1
a1007 1
		    if (areqs.reg_mask[ndx1] & (1 << ndx2))
a1284 1
		  struct agent_reqs areqs;
d1330 1
a1330 1
		      ax_reqs (aexpr, &areqs);
d1332 1
a1332 1
		      report_agent_reqs_errors (aexpr, &areqs);
d1338 1
a1338 1
		      if (areqs.reg_mask_len > 0)
d1343 1
a1343 1
			  for (ndx1 = 0; ndx1 < areqs.reg_mask_len; ndx1++)
d1346 1
a1346 1
			      if (areqs.reg_mask[ndx1] != 0)
d1350 1
a1350 1
				    if (areqs.reg_mask[ndx1] & (1 << ndx2))
a1375 1
		  struct agent_reqs areqs;
d1384 2
a1385 3
		  ax_reqs (aexpr, &areqs);

		  report_agent_reqs_errors (aexpr, &areqs);
@


1.182
log
@2010-04-20  Stan Shebs  <stan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* dwarf2loc.c (struct axs_var_loc): New struct.
	(dwarf2_tracepoint_var_loc): New function.
	(dwarf2_tracepoint_var_access): New function.
	(dwarf2_tracepoint_var_ref): Use dwarf2_tracepoint_var_loc, deal
	with DW_OP_piece.
	(locexpr_describe_location_piece): New function.
	(locexpr_describe_location_1): New function.
	(locexpr_describe_location): Call it, update signature.
	(loclist_describe_location): Rewrite to loop over locations,
	update signature.
	* symtab.h (struct symbol_computed_ops): Add address to
	describe_location arguments, return void.
	* printcmd.c (address_info): Get context PC, pass to computed
	location description.
	* tracepoint.c (scope_info): Ditto.
	* ax-gdb.c (trace_kludge): Export.
@
text
@d2619 1
a2619 1
  fp = fopen (pathname, "w");
@


1.181
log
@2010-04-19  Stan Shebs  <stan@@codesourcery.com>
	    Vladimir Prus  <vladimir@@codesourcery.com>

	* tracepoint.c (tfind_1): Add missing newline, report exit from
	tfind mode as such.
	* target.c (update_current_target): Make default
	to_trace_find return -1.
@
text
@d2375 3
a2377 1
	      SYMBOL_COMPUTED_OPS (sym)->describe_location (sym, gdb_stdout);
@


1.180
log
@2010-04-16  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (trace_variable_command): Run a cleanup.
@
text
@d1952 4
a1955 2
      else
	printf_unfiltered (_("No trace frame found"));
@


1.179
log
@2010-04-15  Stan Shebs  <stan@@codesourcery.com>

	* frame.c: Include tracepoint.h.
	(get_current_frame): Allow a trace frame to be an alternate source
	of stack frame data.
	* tracepoint.c (tfind_1): Don't try to get current stack frame if
	it won't succeed.
@
text
@d368 1
@


1.178
log
@2010-04-12  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (tfile_xfer_partial): Check read result.
@
text
@d1859 1
a1859 1
  struct frame_id old_frame_id;
d1863 9
a1871 1
  old_frame_id = get_frame_id (get_current_frame ());
d1884 1
a1884 1
      /* A request for a non-existant trace frame has failed.
d1963 1
a1963 1
      /* NOTE: in immitation of the step command, try to determine
@


1.177
log
@2010-04-09  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (trace_status_mi): Report frames created.

	* gdb.texinfo (gdb/mi Tracepoint Commands) <-trace-status>:
	Describe the `frames-created' field, tweak grammar.
@
text
@d3895 8
a3902 1
	      read (trace_fd, readbuf, amt);
@


1.176
log
@2010-04-09  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (trace_dump_command): Include default-collect
	expressions.
@
text
@d1801 2
@


1.175
log
@	gdb/
	* tracepoint.c (trace_status_mi): Report disconnected tracing and
	circular trace buffer statuses.

	gdb/doc/
	* gdb.texinfo (gdb/mi Tracepoint Commands) <-trace-status>:
	Describe the `circular' and `disconnected' fields.
@
text
@d2484 3
d2518 23
a2540 1
  trace_dump_actions (breakpoint_commands (t), 0, stepping_frame, from_tty);
@


1.174
log
@2010-04-08  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* tracepoint.h (struct trace_status): New fields disconnected_tracing
	and circular_buffer.
	(disconnect_tracing): Rename from disconnect_or_stop_tracing.
	* tracepoint.c (trace_status_command): Display target's status for
	disconnected tracing and circular buffer.
	(disconnect_tracing): Rename from disconnect_or_stop_tracing, add
	query for non-disconnected-tracing case, remove the stop_tracing
	call.
	(tfile_open): Clear disconnected and circular buffer status.
	(trace_save): Save disconnected and circular buffer status.
	(parse_trace_status): Parse disconnected and circular buffer status,
	also recognize disconnected as a stop reason.
	* remote.c (remote_set_disconnected_tracing): Only set
	QTDisconnected if the remote end supports disconnected tracing.
	Warn otherwise, if trying to enable disconnected tracing.
	* infcmd.c (detach_command): Update disconnect_tracing call.
	* cli/cli-cmds.c (quit_command): Ditto.

	* gdb.texinfo (Tracepoint Packets): Describe disconn and circular
	trace status fields.
@
text
@d1799 6
d1806 2
a1807 6
  if ((int) ts->traceframe_count != -1)
    ui_out_field_int (uiout, "frames", ts->traceframe_count);
  if ((int) ts->buffer_size != -1)
    ui_out_field_int (uiout, "buffer-size",  (int) ts->buffer_size);
  if ((int) ts->buffer_free != -1)
    ui_out_field_int (uiout, "buffer-free",  (int) ts->buffer_free);
@


1.173
log
@2010-04-06  Stan Shebs  <stan@@codesourcery.com>

	* defs.h (char_ptr): Move typedef here from...
	* ada-lang.c (char_ptr): Remove.
	* charset.c (char_ptr): Remove.
	* tracepoint.h (struct uploaded_string): Remove.
	(struct uploaded_tp): Use vectors for string arrays.
	* tracepoint.c (trace_save): Use vectors of actions.
	(parse_tracepoint_definition): Ditto.
	(get_uploaded_tp): Clear vectors.
	* breakpoint.c (create_tracepoint_from_upload): Use vectors.
	(next_cmd): Change to an int.
	(read_next_cmd): Use vector of command strings.
@
text
@a1628 4
      if (disconnected_tracing)
	printf_filtered (_("Trace will continue if GDB disconnects.\n"));
      else
	printf_filtered (_("Trace will stop if GDB disconnects.\n"));
d1698 8
d1808 3
a1810 1

d1812 1
a1812 1
disconnect_or_stop_tracing (int from_tty)
d1821 5
d1828 10
a1837 10
      int cont = query (_("Trace is running.  Continue tracing after detach? "));
      /* Note that we send the query result without affecting the
	 user's setting of disconnected_tracing, so that the answer is
	 a one-time-only.  */
      send_disconnected_tracing_value (cont);

      /* Also ensure that we do the equivalent of a tstop command if
	 tracing is not to continue after the detach.  */
      if (!cont)
	stop_tracing ();
d2613 4
d3185 2
d3302 2
d3332 5
d3375 10
@


1.172
log
@2010-04-05  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c: Include gdbcore.h.
	(tfile_xfer_partial): Return partial results, also try reading
	from executable.
	(tfile_has_all_memory): New function.
	(init_tfile_ops): Use it.

	* gdb.trace/tfile.c: Add a variable split across two blocks, and a
	constant global.
	* gdb.trace/tfile.exp: Try to print them.
@
text
@d2541 1
a2541 1
  struct uploaded_string *cmd;
d2649 1
a2649 1
      for (a = 0; a < utp->numactions; ++a)
d2651 2
a2652 3
		 utp->number, phex_nz (utp->addr, sizeof (utp->addr)),
		 utp->actions[a]);
      for (a = 0; a < utp->num_step_actions; ++a)
d2654 1
a2654 2
		 utp->number, phex_nz (utp->addr, sizeof (utp->addr)),
		 utp->step_actions[a]);
d2667 1
a2667 1
      for (cmd = utp->cmd_strings; cmd; cmd = cmd->next)
d2669 1
a2669 1
	  encode_source_string (utp->number, utp->addr, "cmd", cmd->str,
d2871 3
d3428 1
a3428 1
      utp->actions[utp->numactions++] = xstrdup (p);
d3433 1
a3433 1
      utp->step_actions[utp->num_step_actions++] = xstrdup (p);
d3457 1
a3457 15
	{
	  /* FIXME consider using a vector? */
	  struct uploaded_string *last, *newlast;
	  newlast = (struct uploaded_string *) xmalloc (sizeof (struct uploaded_string));
	  newlast->str = xstrdup (buf);
	  newlast->next = NULL;
	  if (utp->cmd_strings)
	    {
	      for (last = utp->cmd_strings; last->next; last = last->next)
		;
	      last->next = newlast;
	    }
	  else
	    utp->cmd_strings = newlast;
	}
@


1.171
log
@2010-04-04  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (tfile_fetch_registers): Add fallback case.

	* gdb.texinfo (Tracepoint Restrictions): Document PC inference.
	(tdump): Explain how tdump works.

	* gdb.trace/tfile.exp: Sharpen tfind test.
@
text
@d48 1
d3797 1
a3797 1
  ULONGEST maddr;
d3835 13
a3847 10
	  if (maddr <= offset && (offset + len) <= (maddr + mlen))
	    {
	      gotten = read (trace_fd, readbuf, mlen);
	      if (gotten < 0)
		perror_with_name (trace_filename);
	      else if (gotten < mlen)
		error (_("Premature end of file qwhile reading trace file"));

	      return mlen;
	    }
d3861 32
d3962 6
d4003 1
@


1.170
log
@	* tracepoint.c (trace_dump_actions): New, factored out from
	trace_dump_command, and adjusted to recurse into while-stepping's
	action list.
	(trace_dump_command): Use it.
@
text
@d3674 1
a3674 1
  int i, pos, offset, regn, regsize, gotten;
d3749 38
@


1.169
log
@	* breakpoint.h (struct counted_command_line): Moved definition to
	breakpoint.c, and forward declare.
	(breakpoint_commands): Declare.
	* breakpoint.c (struct counted_command_line): Moved here.
	(breakpoint_commands): New.
	* tracepoint.c (encode_actions): Use breakpoint_commands.
	* remote.c (remote_download_tracepoint): Ditto.
@
text
@d2373 7
a2379 1
/* tdump command */
d2381 3
a2383 1
trace_dump_command (char *args, int from_tty)
a2384 4
  struct regcache *regcache;
  struct gdbarch *gdbarch;
  struct breakpoint *t;
  struct command_line *action;
a2385 4
  struct cleanup *old_cleanups;
  int stepping_actions = 0;
  int stepping_frame = 0;
  struct bp_location *loc;
d2387 1
a2387 34
  if (tracepoint_number == -1)
    {
      warning (_("No current trace frame."));
      return;
    }

  t = get_tracepoint (tracepoint_number);

  if (t == NULL)
    error (_("No known tracepoint matches 'current' tracepoint #%d."),
	   tracepoint_number);

  old_cleanups = make_cleanup (null_cleanup, NULL);

  printf_filtered ("Data collected at tracepoint %d, trace frame %d:\n",
		   tracepoint_number, traceframe_number);

  /* The current frame is a trap frame if the frame PC is equal
     to the tracepoint PC.  If not, then the current frame was
     collected during single-stepping.  */

  regcache = get_current_regcache ();
  gdbarch = get_regcache_arch (regcache);

  /* If the traceframe's address matches any of the tracepoint's
     locations, assume it is a direct hit rather than a while-stepping
     frame.  (FIXME this is not reliable, should record each frame's
     type.)  */
  stepping_frame = 1;
  for (loc = t->loc; loc; loc = loc->next)
    if (loc->address == regcache_read_pc (regcache))
      stepping_frame = 0;

  for (action = breakpoint_commands (t); action; action = action->next)
d2407 7
a2413 3
	stepping_actions = 1;
      else if (cmd_cfunc_eq (cmd, end_actions_pseudocommand))
	stepping_actions = 0;
d2459 43
a2501 1
  discard_cleanups (old_cleanups);
@


1.168
log
@2010-04-01  Stan Shebs  <stan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* tracepoint.h (enum actionline_type): Remove.
	(validate_actionline): Change return to void.
	* tracepoint.c (report_agent_reqs_errors): New function.
	(validate_actionline): Call it, change return to void, report errors
	more consistently.
	(collect_symbol): Call report_agent_reqs_errors.
	(encode_actions_1): Ditto.
	(encode_actions): Don't expect a result from validate_actionline.

	* gdb.trace/actions.exp: Tweak expected output.
	* gdb.trace/while-stepping.exp: Tweak expected output.
@
text
@d1442 1
a1442 1
  actions = t->commands->commands;
d1461 1
a1461 1
      default_collect_action->next = t->commands->commands;
d2420 1
a2420 1
  for (action = t->commands->commands; action; action = action->next)
@


1.167
log
@2010-04-01  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (trace_start_command): Confirm if trace is running.
	(trace_stop_command): Error if trace not running.
@
text
@d557 27
d585 1
a585 1
enum actionline_type
d593 2
d598 1
a598 1
    return END;
d605 1
a605 1
    return BADLINE;
d608 1
a608 1
    return GENERIC;
d612 1
a612 5
    {
      warning (_("'%s' is not an action that I know, or is ambiguous."), 
	       p);
      return BADLINE;
    }
a615 3
      struct agent_expr *aexpr;
      struct agent_reqs areqs;

d644 3
a646 4
		      warning (_("constant %s (value %ld) will not be collected."),
			       SYMBOL_PRINT_NAME (exp->elts[2].symbol),
			       SYMBOL_VALUE (exp->elts[2].symbol));
		      return BADLINE;
d650 2
a651 3
		      warning (_("%s is optimized away and cannot be collected."),
			       SYMBOL_PRINT_NAME (exp->elts[2].symbol));
		      return BADLINE;
d662 1
a662 1
		error (_("expression too complicated, try simplifying"));
d667 1
a667 8
	      if (areqs.flaw != agent_flaw_none)
		error (_("malformed expression"));

	      if (areqs.min_height < 0)
		error (_("gdb: Internal error: expression has min height < 0"));

	      if (areqs.max_height > 20)
		error (_("expression too complicated, try simplifying"));
a672 1
      return GENERIC;
d674 1
a676 2
      struct agent_expr *aexpr;

d698 6
a703 1
		error (_("expression too complicated, try simplifying"));
a708 1
      return GENERIC;
d710 1
d719 2
a720 6
      if (*p == '\0' ||
	  (t->step_count = strtol (p, &p, 0)) == 0)
	{
	  error (_("'%s': bad step-count."), *line);
	}
      return STEPPING;
d722 1
d724 2
a725 1
    return END;
d727 1
a727 3
    {
      error (_("'%s' is not a supported tracepoint action."), *line);
    }
d992 2
a993 7
      if (areqs.flaw != agent_flaw_none)
	error (_("malformed expression"));
      
      if (areqs.min_height < 0)
	error (_("gdb: Internal error: expression has min height < 0"));
      if (areqs.max_height > 20)
	error (_("expression too complicated, try simplifying"));
a1334 2
		      if (areqs.flaw != agent_flaw_none)
			error (_("malformed expression"));
d1336 1
a1336 4
		      if (areqs.min_height < 0)
			error (_("gdb: Internal error: expression has min height < 0"));
		      if (areqs.max_height > 20)
			error (_("expression too complicated, try simplifying"));
a1389 2
		  if (areqs.flaw != agent_flaw_none)
		    error (_("malformed expression"));
d1391 1
a1391 4
		  if (areqs.min_height < 0)
		    error (_("gdb: Internal error: expression has min height < 0"));
		  if (areqs.max_height > 20)
		    error (_("expression too complicated, try simplifying"));
a1451 1
      enum actionline_type linetype;
d1457 7
a1463 9
      linetype = validate_actionline (&line, t);
      if (linetype != BADLINE)
	{
	  default_collect_action = xmalloc (sizeof (struct command_line));
	  make_cleanup (xfree, default_collect_action);
	  default_collect_action->next = t->commands->commands;
	  default_collect_action->line = line;
	  actions = default_collect_action;
	}
@


1.166
log
@	gdb/
	* tracepoint.c: Include stack.h.
	(struct add_local_symbols_data): New.
	(do_collect_symbol): New.
	(add_local_symbols): Rewrite using iterate_over_block_arg_vars and
	iterate_over_block_local_vars.
	* stack.c (print_block_frame_locals): Rewrite as ...
	(iterate_over_block_locals): ... this.  Take a callback function
	pointer and generic data pointer, and call that instead of
	print_variable_and_value.
	(struct print_variable_and_value_data): New.
	(do_print_variable_and_value): New.
	(iterate_over_block_local_vars): New, abstracted out from
	print_frame_local_vars.
	(print_frame_local_vars): Rewrite using
	iterate_over_block_local_vars.
	(iterate_over_block_arg_vars): New, abstracted out from
	print_frame_arg_vars.
	(print_frame_arg_vars): Rewrite using iterate_over_block_arg_vars.
	* stack.h (iterate_over_block_arg_local_vars_cb): New typedef.
	(iterate_over_block_arg_vars, iterate_over_block_local_vars): Declare.

	gdb/testsuite/
	* gdb.trace/collection.c (local_test_func): Define a local struct,
	and instanciate it.
@
text
@d1579 7
d1593 3
@


1.165
log
@2010-03-31  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (tracepoint_save_command): Include variables,
 	conditionals, tracepoint types, and default-collect.
	* tracepoint.c (save_trace_state_variables): New function.
	* tracepoint.h (save_trace_state_variables): Declare it.

	* gdb.trace/save-trace.exp: Test save/restore of default-collect
	and tracepoint conditionals.
	(gdb_verify_tracepoints): Delete unused return.
@
text
@d47 1
d1012 27
a1044 1
  struct symbol *sym;
d1046 18
a1063 2
  struct dict_iterator iter;
  int count = 0;
d1065 5
a1069 2
  block = block_for_pc (pc);
  while (block != 0)
d1071 3
a1073 2
      QUIT;			/* allow user to bail out with ^C */
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d1075 2
a1076 8
	  if (SYMBOL_IS_ARGUMENT (sym)
	      ? type == 'A'	/* collecting Arguments */
	      : type == 'L')	/* collecting Locals */
	    {
	      count++;
	      collect_symbol (collect, sym, gdbarch,
			      frame_regno, frame_offset, pc);
	    }
d1078 4
a1081 4
      if (BLOCK_FUNCTION (block))
	break;
      else
	block = BLOCK_SUPERBLOCK (block);
a1082 3
  if (count == 0)
    warning (_("No %s found in scope."), 
	     type == 'L' ? "locals" : "args");
@


1.164
log
@2010-03-29  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (trace_find_line_command): Remove dead code.
@
text
@d482 17
@


1.163
log
@2010-03-29  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.h (struct uploaded_string): New struct.
	(struct uploaded_tp): New fields for source strings.
	* breakpoint.c (this_utp, next_cmd): New globals.
	(read_uploaded_action): New function.
	(create_tracepoint_from_upload): Fill in more parts
	of a tracepoint.
	* tracepoint.c (encode_source_string): New function.
	(trace_save): Write out source strings, fix error checks.
	(parse_tracepoint_definition): Add source string parsing.
	* remote.c (PACKET_TracepointSource): New packet type.
	(remote_download_command_source): New function.
	(remote_download_tracepoint): Download source pieces also.
	(_initialize_remote): Add packet config command.

	* gdb.texinfo (Tracepoint Packets): Describe QTDPsrc.
	(General Query Packets): Describe TracepointSource.
@
text
@d2046 1
a2046 1
      {
d2053 3
a2055 20
    {
      printf_filtered ("TFIND: No line number information available");
      if (sal.pc != 0)
	{
	  /* This is useful for "info line *0x7f34".  If we can't
	     tell the user about a source line, at least let them
	     have the symbolic address.  */
	  printf_filtered (" for address ");
	  wrap_here ("  ");
	  print_address (get_current_arch (), sal.pc, gdb_stdout);
	  printf_filtered (";\n -- will attempt to find by PC. \n");
  	}
        else
  	{
	  printf_filtered (".\n");
	  return;		/* No line, no PC; what can we do?  */
  	}
    }
  else if (sal.line > 0
	   && find_line_pc_range (sal, &start_pc, &end_pc))
@


1.162
log
@2010-03-29  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (collect_symbol): Send LOC_UNRESOLVED symbols to
	expression handler.
@
text
@d2449 19
d2485 1
d2520 1
a2520 1
  if (written < 8)
d2601 18
d2638 1
a2638 1
      if (written < gotten)
d2643 1
a2643 1
  /* Mark the end of trace data.  */
d2645 1
a2645 1
  if (written < 4)
d3307 2
a3308 2
/* Given a line of text defining a tracepoint or tracepoint action, parse
   it into an "uploaded tracepoint".  */
d3315 2
a3316 2
  ULONGEST num, addr, step, pass, orig_size, xlen;
  int enabled, i;
d3318 1
a3318 1
  char *cond;
d3359 1
a3359 1
	    warning ("Unrecognized char '%c' in tracepoint definition, skipping rest", *p);
d3378 38
d3418 3
a3420 1
      error ("Invalid tracepoint piece");
@


1.161
log
@2010-03-29  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (start_tracing): Check tracepoints before sending
	commands to target, don't start if all tracepoints disabled.
@
text
@d925 1
d927 1
a927 2
      printf_filtered ("Don't know LOC_UNRESOLVED %s\n", 
		       SYMBOL_PRINT_NAME (sym));
d929 1
@


1.160
log
@2010-03-26  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.c (disconnect_or_stop_tracing): Get out of tfind mode.
@
text
@d1452 26
a1477 1
  int any_downloaded = 0;
d1480 1
a1480 2
  
  tp_vec = all_tracepoints ();
a1485 1
      any_downloaded = 1;
d1488 1
a1488 5
  
  /* No point in tracing without any tracepoints... */
  if (!any_downloaded)
    error ("No tracepoints downloaded, not starting trace");
  
@


1.159
log
@	* tracepoint.c (current_trace_status): Don't make sure error_desc
	is non-NULL here.
	(parse_trace_status): Release a previous error_desc string, and
	set it to NULL by default.  If stop reason is tracepoint_error,
	make sure error_desc is not left NULL.
@
text
@d1748 7
@


1.158
log
@	gdb/
	* tracepoint.c (trace_save): Remove X from tracepoint error
	description.

	gdb/testsuite/
	* gdb.trace/tfile.c (tohex, bin2hex): New.
	(write_error_trace_file): Hexify error description.
@
text
@a204 3
  /* Ensure this is never NULL.  */
  if (!trace_status.error_desc)
    trace_status.error_desc = "";
d3157 2
a3158 1
  ts->error_desc = "";
d3202 3
@


1.157
log
@	gdb/
	* tracepoint.c (parse_trace_status): Don't allow plain strings in
	the terror description.  Don't expect an X prefix.

	gdb/doc/
	* gdb.texinfo (Tracepoint Packets): Remove mention that
	terror:string may be plain text, and drop mention of X prefix.
@
text
@a2486 1
  /* Encode the error message in hex, might have weird chars.  */
d2491 1
a2491 1
      fprintf (fp, ":X%s", buf);
@


1.156
log
@2010-03-25  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.h (trace_stop_reason): Add tracepoint_error.
	(struct trace_status): New field error_desc.
	* tracepoint.c (stop_reason_names): Add terror.
	(current_trace_status): Ensure non-NULL error description.
	(trace_status_command): Add error report.
	(trace_status_mi): Ditto.
	(trace_save): Add special case for error description.
	(parse_trace_status): Add case for errors.

	* gdb.texinfo (Tracepoint Packets): Document trace error status.

	* gdb.trace/tfile.c: Generate an additional trace file, improve
	portability.
	* gdb.trace/tfile.exp: Test trace file with an error stop, delete
	files in a better way.
@
text
@d3200 3
a3202 12
	      ts->error_desc = (char *) xmalloc (p2 - p1 + 1);
	      /* See if we're doing plain text or hex encoding.  */
	      if (*p1 == 'X')
		{
		  ++p1;
		  end = hex2bin (p1, ts->error_desc, (p2 - p1) / 2);
		}
	      else
		{
		  memcpy (ts->error_desc, p1, p2 - p1);
		  end = p2 - p1;
		}
@


1.155
log
@	* breakpoint.h (struct counted_command_line): New struct.
	(struct breakpoint) <commands>: Change type.
	(struct bpstats) <commands>: Change type.
	<commands_left>: New field.
	* breakpoint.c (alloc_counted_command_line): New function.
	(incref_counted_command_line): Likewise.
	(decref_counted_command_line): Likewise.
	(do_cleanup_counted_command_line): Likewise.
	(make_cleanup_decref_counted_command_line): Likewise.
	(breakpoint_set_commands): Use decref_counted_command_line and
	alloc_counted_command_line.
	(commands_command): Don't error if breakpoint commands are
	executing.
	(commands_from_control_command): Likewise.
	(bpstat_free): Update.
	(bpstat_copy): Likewise.
	(bpstat_clear_actions): Likewise.
	(bpstat_do_actions_1): Likewise.
	(bpstat_stop_status): Likewise.
	(print_one_breakpoint_location): Likewise.
	(delete_breakpoint): Likewise.
	(bpstat_alloc): Initialize new field.
	(tracepoint_save_command): Update.
	* tracepoint.c (encode_actions): Update.
	(trace_dump_command): Update.
@
text
@d198 2
a199 1
  "tpasscount"
d205 3
d1577 8
d1699 4
d1711 3
d2485 10
a2494 3
  fprintf (fp, "status %c;%s:%x",
	   (ts->running ? '1' : '0'),
 	   stop_reason_names[ts->stop_reason], ts->stopping_tracepoint);
d3155 1
a3155 1
  char *p = line, *p1, *p_temp;
d3161 1
d3194 24
@


1.154
log
@	* tracepoint.c (tvariables_info_1): Actually compute
	the number of rows in the result.
@
text
@d1388 1
a1388 1
  actions = t->commands;
d1409 1
a1409 1
	  default_collect_action->next = t->commands;
d2335 1
a2335 1
  for (action = t->commands; action; action = action->next)
@


1.153
log
@	Implement -trace-save.

	* mi-cmds.h (mi_cmds_trace_save): Declare.
	* mi-cmds.c (mi_cmds): Register -trace-save.
	* mi/mi-main.c (mi_cmd_trace_save): New.
	* remote.c (remote_save_trace_data): Take const parameter.
	* target.h (struct target_ops::to_save_trace_data): Take
	const parameter.
	* target.c (update_current_target): Adjust to the above.
	* tracepoint.c (trave_save): New, extracted from
	(trace_save_command): ...this.
	(tfile_trace_find): Remove message that is unnecessary now
	that 'tfind' reports found frame.
	* tracepoint.h (trace_save): Declare.
@
text
@d425 1
a425 1
  for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
@


1.152
log
@	Implement -trace-find.

	* mi/mi-cmds.c (mi_cmds): Register -trace-find.
	* mi/mi-cmds.h (mi_cmd_trace_find): Declare.
	* mi/mi-main.c (mi_cmd_trace_find): New.
	* target.h (struct target_ops): Document to_trace_find.
	* tracepoint.h (tfind_1): Declare.
	* tracepoint.c (finish_tfind_command): Rename to...
	(tfind_1): ...this.
	* remote.c (remote_trace_find): Return -1 if target say
	there's no frame.  Improve error diagnostics.
@
text
@d2408 6
a2413 2
static void
trace_save_command (char *args, int from_tty)
a2414 3
  char **argv;
  char *filename = NULL, *pathname;
  int target_does_save = 0;
d2416 1
a2428 19
  if (args == NULL)
    error_no_arg (_("file in which to save trace data"));

  argv = gdb_buildargv (args);
  make_cleanup_freeargv (argv);

  for (; *argv; ++argv)
    {
      if (strcmp (*argv, "-r") == 0)
	target_does_save = 1;
      else if (**argv == '-')
	error (_("unknown option `%s'"), *argv);
      else
	filename = *argv;
    }

  if (!filename)
    error_no_arg (_("file in which to save trace data"));

d2444 1
a2444 1
  pathname = tilde_expand (args);
d2450 1
a2450 1
	   args, safe_strerror (errno));
d2562 31
d2595 2
a3444 1
	  printf_filtered ("Found traceframe %d.\n", tfnum);
@


1.151
log
@        -trace-define-variable and -trace-list-variables.

    	* tracepoint.c (create_trace_state_variable): Make
    	private copy of name, as opposed to assuming the
    	pointer lives forever.
    	(tvariables_info_1): New.
    	(tvariables_info): Use the above.
    	* tracepoint.h (create_trace_state_variable, tvariables_info_1):
    	Declare.
    	* mi/mi-cmds.c (mi_cmds): Register -trace-define-variable
    	and -trace-list-variables.
    	* mi/mi-cmds.h (mi_cmd_trace_define_variable)
    	(mi_cmd_trace_list_variables): New.
    	* mi/mi-main.c (mi_cmd_trace_define_variable)
    	(mi_cmd_trace_list_variables): New.
@
text
@d1735 4
a1738 4
static void
finish_tfind_command (enum trace_find_type type, int num,
		      ULONGEST addr1, ULONGEST addr2,
		      int from_tty)
d1805 24
d1902 1
a1902 1
  finish_tfind_command (tfind_number, frameno, 0, 0, from_tty);
d1941 1
a1941 1
  finish_tfind_command (tfind_pc, 0, pc, 0, from_tty);
d1971 1
a1971 1
  finish_tfind_command (tfind_tp, tdp, 0, 0, from_tty);
d2059 1
a2059 1
    finish_tfind_command (tfind_range, 0, start_pc, end_pc - 1, from_tty);
d2061 1
a2061 1
    finish_tfind_command (tfind_outside, 0, start_pc, end_pc - 1, from_tty);
d2096 1
a2096 1
  finish_tfind_command (tfind_range, 0, start, stop, from_tty);
d2130 1
a2130 1
  finish_tfind_command (tfind_outside, 0, start, stop, from_tty);
@


1.150
log
@	-trace-start/-trace-end/-trace-status.

	* mi/mi-cmds.c (mi_cmds): Register -trace-start, -trace-status
	and -trace-stop.
	* mi/mi-cmds.h (mi_cmd_trace_start, mi_cmd_trace_status)
	(mi_cmd_trace_stop): Declare.
	* mi/mi-main.c (mi_cmd_trace_start, mi_cmd_trace_status)
	(mi_cmd_trace_stop): New.
	* tracepoint.c (start_tracing): New, extracted from...
	(trace_start_command): ...this.
	(trace_status_mi): New.
	* tracepoint.h (struct trace_status): Document
	stopping_tracepoint.
	(start_tracing, stop_tracing, trace_status_mi): Declare.
@
text
@d279 1
a279 1
  tsv.name = name;
d308 1
d410 2
a411 4
/* List all the trace state variables.  */

static void
tvariables_info (char *args, int from_tty)
d415 2
a416 2
  char *reply;
  ULONGEST tval;
d418 1
a418 1
  if (VEC_length (tsv_s, tvariables) == 0)
d429 7
a435 1
  printf_filtered (_("Name\t\t  Initial\tCurrent\n"));
d439 11
a449 4
      printf_filtered ("$%s", tsv->name);
      print_spaces_filtered (17 - strlen (tsv->name), gdb_stdout);
      printf_filtered ("%s ", plongest (tsv->initial_value));
      print_spaces_filtered (11 - strlen (plongest (tsv->initial_value)), gdb_stdout);
d451 6
a456 1
	printf_filtered ("  %s", plongest (tsv->value));
d459 1
a459 1
	printf_filtered (_("  <unknown>"));
d462 6
a467 2
	printf_filtered (_("  <undefined>"));
      printf_filtered ("\n");
d469 10
@


1.149
log
@	Unify actions and commands

	* defs.h (read_command_lines, read_command_lines_1): New
	parameters validator and closure.
	* tracepoint.h (struct action_line): Remove.
	* breakpoint.h (struct breakpoint): Remove the 'actions'
	field.
	* defs.h (enum command_control_type): New value
	while_stepping_control.
	(struct command_line): Add comments.
	* breakpoint.c (breakoint_is_tracepoint): New.
	(breakpoint_set_commands): For tracepoints,
	verify the commands are permissible.
	(check_tracepoint_commands): New.
	(commands_command): Require that each new line is validated using
	check_tracepoint_command, if we set commands for a tracepoint.
	(create_tracepoint_from_upload): Likewise.
	(print_one_breakpoint_location): Remove the code to print
	actions specifically.
	(tracepoint_save_command): Relay to print_command_lines.
	* cli/cli-script.c (process_next_line): New parameters validator
	and closure. Handle 'while-stepping'. Call validator if not null.
	(read_command_lines, read_command_lines1): Likewise.
	(recurse_read_control_structure): New parameters validator and
	closure. Handle while_stepping_control.
	(print_command_lines): Handle while-stepping.
	(get_command_line, define_command, document_command): Adjust.
	* remote.c (remote_download_tracepoint): Adjust.
	* tracepoint.c (make_cleanup_free_actions, read_actions)
	(free_actions, do_free_actions_cleanup): Remove.
	(trace_actions_command): Use read_command_lines.
	(validate_actionline): Use error in one place.
	(encode_actions_1): New, extracted from...
	(encode_actions): ...this. Also use cleanups for exception
	safety.
	(trace_dump_command): Adjust.
	* mi/mi-cmd-break (mi_cmd_break_commands): Validate commands if
	it's tracepoint.
@
text
@a1410 1
/* tstart command:
d1412 2
a1413 7
   Tell target to clear any previous trace experiment.
   Walk the list of tracepoints, and send them (and their actions)
   to the target.  If no errors, 
   Tell target to start a new trace experiment.  */

static void
trace_start_command (char *args, int from_tty)
a1421 2
  dont_repeat ();	/* Like "run", dangerous to repeat accidentally.  */

d1460 15
d1483 1
a1483 1
stop_tracing ()
a1538 1
	  /* FIXME account for number on target */
d1590 88
@


1.148
log
@2010-03-18  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* target.h (struct target_ops): New method
	to_set_circular_trace_buffer.
	(target_set_circular_trace_buffer): New macro.
	* target.c (update_current_target): Add
	to_set_circular_trace_buffer, fix to_set_disconnected_tracing
	default behavior.
	* remote.c (remote_set_circular_trace_buffer): New function.
	(init_remote_ops): Add it to vector.
	* tracepoint.h (struct trace_status): New field traceframes_created,
	change buffer_size and buffer_free to int.
	* tracepoint.c (circular_trace_buffer): New global.
	(start_tracing): Send values of disconnected tracing and circular
	trace buffer settings.
	(set_circular_trace_buffer): New function.
	(parse_trace_state): Handle total space and frames created.
	(trace_status_command): Display total space and total frames
	created.
	(trace_save): Write out new status values.
	(parse_trace_status): Set traceframe_count, traceframes_created,
	buffer_free and buffer_size to -1 by default.
	(_initialize_tracepoint): New setshow for circular-trace-buffer.
	* NEWS: Mention the circular trace buffer option.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Describe
	circular-trace-buffer.
	(Tracepoint Packets): Describe QTBuffer, and details of the
	qTStatus reply.

	* gdb.trace/circ.exp: Test circular-trace-buffer.
	* gdb.trace/tfile.exp: Update tstatus test.
@
text
@a180 1
static struct cleanup *make_cleanup_free_actions (struct breakpoint *t);
a451 3
/* Prototypes for action-parsing utility commands  */
static void read_actions (struct breakpoint *);

d490 1
a490 2
  char tmpbuf[128];
  char *end_msg = "End with a line saying just \"end\".";
d495 8
a502 18
      sprintf (tmpbuf, "Enter actions for tracepoint %d, one per line.",
	       t->number);

      if (from_tty)
	{
	  if (deprecated_readline_begin_hook)
	    (*deprecated_readline_begin_hook) ("%s  %s\n", tmpbuf, end_msg);
	  else if (input_from_terminal_p ())
	    printf_filtered ("%s\n%s\n", tmpbuf, end_msg);
	}

      free_actions (t);
      t->step_count = 0;	/* read_actions may set this */
      read_actions (t);

      if (deprecated_readline_end_hook)
	(*deprecated_readline_end_hook) ();
      /* tracepoints_changed () */
a507 104
static void
read_actions (struct breakpoint *t)
{
  char *line;
  char *prompt1 = "> ", *prompt2 = "  > ";
  char *prompt = prompt1;
  enum actionline_type linetype;
  extern FILE *instream;
  struct action_line *next = NULL, *temp;
  struct cleanup *old_chain;

  /* Control-C quits instantly if typed while in this loop
     since it should not wait until the user types a newline.  */
  immediate_quit++;
  /* FIXME: kettenis/20010823: Something is wrong here.  In this file
     STOP_SIGNAL is never defined.  So this code has been left out, at
     least for quite a while now.  Replacing STOP_SIGNAL with SIGTSTP
     leads to compilation failures since the variable job_control
     isn't declared.  Leave this alone for now.  */
#ifdef STOP_SIGNAL
  if (job_control)
    signal (STOP_SIGNAL, handle_stop_sig);
#endif
  old_chain = make_cleanup_free_actions (t);
  while (1)
    {
      /* Make sure that all output has been output.  Some machines may
         let you get away with leaving out some of the gdb_flush, but
         not all.  */
      wrap_here ("");
      gdb_flush (gdb_stdout);
      gdb_flush (gdb_stderr);

      if (deprecated_readline_hook && instream == NULL)
	line = (*deprecated_readline_hook) (prompt);
      else if (instream == stdin && ISATTY (instream))
	{
	  line = gdb_readline_wrapper (prompt);
	  if (line && *line)	/* add it to command history */
	    add_history (line);
	}
      else
	line = gdb_readline (0);

      if (!line)
        {
          line = xstrdup ("end");
          printf_filtered ("end\n");
        }
      
      linetype = validate_actionline (&line, t);
      if (linetype == BADLINE)
	continue;		/* already warned -- collect another line */

      temp = xmalloc (sizeof (struct action_line));
      temp->next = NULL;
      temp->action = line;

      if (next == NULL)		/* first action for this tracepoint? */
	t->actions = next = temp;
      else
	{
	  next->next = temp;
	  next = temp;
	}

      if (linetype == STEPPING)	/* begin "while-stepping" */
	{
	  if (prompt == prompt2)
	    {
	      warning (_("Already processing 'while-stepping'"));
	      continue;
	    }
	  else
	    prompt = prompt2;	/* change prompt for stepping actions */
	}
      else if (linetype == END)
	{
	  if (prompt == prompt2)
	    {
	      prompt = prompt1;	/* end of single-stepping actions */
	    }
	  else
	    {			/* end of actions */
	      if (t->actions->next == NULL)
		{
		  /* An "end" all by itself with no other actions
		     means this tracepoint has no actions.
		     Discard empty list.  */
		  free_actions (t);
		}
	      break;
	    }
	}
    }
#ifdef STOP_SIGNAL
  if (job_control)
    signal (STOP_SIGNAL, SIG_DFL);
#endif
  immediate_quit--;
  discard_cleanups (old_chain);
}

/* worker function */
d656 1
a656 2
	  warning (_("'%s': bad step-count; command ignored."), *line);
	  return BADLINE;
d664 1
a664 17
      warning (_("'%s' is not a supported tracepoint action."), *line);
      return BADLINE;
    }
}

/* worker function */
void
free_actions (struct breakpoint *t)
{
  struct action_line *line, *next;

  for (line = t->actions; line; line = next)
    {
      next = line->next;
      if (line->action)
	xfree (line->action);
      xfree (line);
a665 13
  t->actions = NULL;
}

static void
do_free_actions_cleanup (void *t)
{
  free_actions (t);
}

static struct cleanup *
make_cleanup_free_actions (struct breakpoint *t)
{
  return make_cleanup (do_free_actions_cleanup, t);
d1125 9
a1133 4
/* Render all actions into gdb protocol.  */
/*static*/ void
encode_actions (struct breakpoint *t, struct bp_location *tloc,
		char ***tdp_actions, char ***stepping_actions)
a1134 1
  static char tdp_buff[2048], step_buff[2048];
d1137 1
a1137 1
  struct action_line *action;
a1139 1
  struct collection_list *collect;
a1141 39
  int frame_reg;
  LONGEST frame_offset;
  char *default_collect_line = NULL;
  struct action_line *default_collect_action = NULL;

  clear_collection_list (&tracepoint_list);
  clear_collection_list (&stepping_list);
  collect = &tracepoint_list;

  *tdp_actions = NULL;
  *stepping_actions = NULL;

  gdbarch_virtual_frame_pointer (t->gdbarch,
				 tloc->address, &frame_reg, &frame_offset);

  action = t->actions;

  /* If there are default expressions to collect, make up a collect
     action and prepend to the action list to encode.  Note that since
     validation is per-tracepoint (local var "xyz" might be valid for
     one tracepoint and not another, etc), we make up the action on
     the fly, and don't cache it.  */
  if (*default_collect)
    {
      char *line;
      enum actionline_type linetype;

      default_collect_line = xmalloc (12 + strlen (default_collect));
      sprintf (default_collect_line, "collect %s", default_collect);
      line = default_collect_line;
      linetype = validate_actionline (&line, t);
      if (linetype != BADLINE)
	{
	  default_collect_action = xmalloc (sizeof (struct action_line));
	  default_collect_action->next = t->actions;
	  default_collect_action->action = line;
	  action = default_collect_action;
	}
    }
d1146 1
a1146 1
      action_exp = action->action;
a1149 3
      if (*action_exp == '#')	/* comment line */
	return;

d1320 7
a1326 1
	  collect = &stepping_list;
d1328 47
a1374 1
      else if (cmd_cfunc_eq (cmd, end_actions_pseudocommand))
d1376 5
a1380 4
	  if (collect == &stepping_list)	/* end stepping actions */
	    collect = &tracepoint_list;
	  else
	    break;		/* end tracepoint actions */
d1382 4
a1385 1
    }				/* for */
d1389 1
a1389 1
  *tdp_actions = stringify_collection_list (&tracepoint_list, 
d1391 1
a1391 1
  *stepping_actions = stringify_collection_list (&stepping_list, 
d1394 1
a1394 2
  xfree (default_collect_line);
  xfree (default_collect_action);
d2146 1
a2146 1
  struct action_line *action;
d2186 1
a2186 1
  for (action = t->actions; action; action = action->next)
d2191 1
a2191 1
      action_exp = action->action;
@


1.147
log
@2010-03-17 Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.h (struct axs_value): New field optimized_out.
	(gen_trace_for_var): Add gdbarch argument.
	* ax-gdb.c (gen_trace_static_fields): New function.
	(gen_traced_pop): Call it, add gdbarch argument.
	(gen_trace_for_expr): Update call to it.
	(gen_trace_for_var): Ditto, and report optimized-out variables.
	(gen_struct_ref_recursive): Check for optimized-out value.
	(gen_struct_elt_for_reference): Ditto.
	(gen_static_field): Pass gdbarch instead of expression, assume
	optimization if field not found.
	(gen_var_ref): Set the optimized_out flag.
	(gen_expr): Error on optimized-out variable.
	* tracepoint.c (collect_symbol): Handle struct-valued vars as
	expressions, skip optimized-out variables with computed locations.
	* dwarf2loc.c (dwarf2_tracepoint_var_ref): Flag instead of
	erroring out if location expression missing.
	(loclist_tracepoint_var_ref): Don't error out here.
@
text
@d156 5
d1587 3
d1679 7
a1685 1
  if (ts->traceframe_count >= 0)
d1691 1
a1691 1
  if (ts->buffer_free)
d1693 14
a1706 2
      printf_filtered (_("Trace buffer has %llu bytes free.\n"),
		       ts->buffer_free);
d2467 1
a2467 1
  fprintf (fp, "status %c;%s:%x;tframes:%x;tfree:%llx\n",
d2469 10
a2478 2
	   stop_reason_names[ts->stop_reason], ts->stopping_tracepoint,
	   ts->traceframe_count, ts->buffer_free);
d2583 7
d3103 5
d3135 1
a3135 1
      if (strncmp (p, "tframes", p1 - p) == 0)
d3140 6
a3145 1
      if (strncmp (p, "tfree", p1 - p) == 0)
d3150 5
d3878 12
@


1.146
log
@	* target.c (memory_xfer_partial): Don't use the stack cache if
	inspecting trace frames.
	* tracepoint.c (finish_tfind_command): Invalidate the target
	dcache.
@
text
@d952 1
d977 6
a982 1
      add_memrange (collect, memrange_absolute, offset, len);
d1047 1
a1047 41
      {
	struct agent_expr *aexpr;
	struct cleanup *old_chain1 = NULL;
	struct agent_reqs areqs;

	aexpr = gen_trace_for_var (scope, sym);

	old_chain1 = make_cleanup_free_agent_expr (aexpr);

	ax_reqs (aexpr, &areqs);
	if (areqs.flaw != agent_flaw_none)
	  error (_("malformed expression"));
	
	if (areqs.min_height < 0)
	  error (_("gdb: Internal error: expression has min height < 0"));
	if (areqs.max_height > 20)
	  error (_("expression too complicated, try simplifying"));

	discard_cleanups (old_chain1);
	add_aexpr (collect, aexpr);

	/* take care of the registers */
	if (areqs.reg_mask_len > 0)
	  {
	    int ndx1, ndx2;

	    for (ndx1 = 0; ndx1 < areqs.reg_mask_len; ndx1++)
	      {
		QUIT;	/* allow user to bail out with ^C */
		if (areqs.reg_mask[ndx1] != 0)
		  {
		    /* assume chars have 8 bits */
		    for (ndx2 = 0; ndx2 < 8; ndx2++)
		      if (areqs.reg_mask[ndx1] & (1 << ndx2))
			/* it's used -- record it */
			add_register (collect, 
				      ndx1 * 8 + ndx2);
		  }
	      }
	  }
      }
d1050 53
@


1.145
log
@2010-03-03 Stan Shebs  <stan@@codesourcery.com>

	* remote.c (remote_download_tracepoint): Iterate over locations.
	* tracepoint.c (validate_actionline): Ditto.
	(encode_actions): Add location argument.
	(trace_dump_command): Check all locations to see if stepping
	frame.
@
text
@d1760 1
@


1.144
log
@	* tracepoint.h (set_traceframe_number)
	(cleanup_restore_current_traceframe): Declare.
	* tracepoint.c (set_traceframe_number): New.
	(struct current_traceframe_cleanup): New.
	(do_restore_current_traceframe_cleanup)
	(restore_current_traceframe_cleanup_dtor)
	(make_cleanup_restore_current_traceframe): New.
	* infrun.c: Include tracepoint.h.
	(fetch_inferior_event): Switch out and in of tfind mode.
@
text
@d628 2
a629 1
  char *p;
d675 6
a680 2
	  exp = parse_exp_1 (&p, block_for_pc (t->loc->address), 1);
	  old_chain = make_cleanup (free_current_contents, &exp);
d682 1
a682 3
	  if (exp->elts[0].opcode == OP_VAR_VALUE)
	    {
	      if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_CONST)
d684 13
a696 4
		  warning (_("constant %s (value %ld) will not be collected."),
			   SYMBOL_PRINT_NAME (exp->elts[2].symbol),
			   SYMBOL_VALUE (exp->elts[2].symbol));
		  return BADLINE;
a697 7
	      else if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_OPTIMIZED_OUT)
		{
		  warning (_("%s is optimized away and cannot be collected."),
			   SYMBOL_PRINT_NAME (exp->elts[2].symbol));
		  return BADLINE;
		}
	    }
d699 5
a703 5
	  /* We have something to collect, make sure that the expr to
	     bytecode translator can handle it and that it's not too
	     long.  */
	  aexpr = gen_trace_for_expr (t->loc->address, exp);
	  make_cleanup_free_agent_expr (aexpr);
d705 2
a706 2
	  if (aexpr->len > MAX_AGENT_EXPR_LEN)
	    error (_("expression too complicated, try simplifying"));
d708 2
a709 2
	  ax_reqs (aexpr, &areqs);
	  (void) make_cleanup (xfree, areqs.reg_mask);
d711 2
a712 2
	  if (areqs.flaw != agent_flaw_none)
	    error (_("malformed expression"));
d714 2
a715 2
	  if (areqs.min_height < 0)
	    error (_("gdb: Internal error: expression has min height < 0"));
d717 2
a718 2
	  if (areqs.max_height > 20)
	    error (_("expression too complicated, try simplifying"));
d720 2
a721 1
	  do_cleanups (old_chain);
d736 13
a748 9
	  /* Only expressions are allowed for this action.  */
	  exp = parse_exp_1 (&p, block_for_pc (t->loc->address), 1);
	  old_chain = make_cleanup (free_current_contents, &exp);

	  /* We have something to evaluate, make sure that the expr to
	     bytecode translator can handle it and that it's not too
	     long.  */
	  aexpr = gen_eval_for_expr (t->loc->address, exp);
	  make_cleanup_free_agent_expr (aexpr);
d750 2
a751 2
	  if (aexpr->len > MAX_AGENT_EXPR_LEN)
	    error (_("expression too complicated, try simplifying"));
d753 2
a754 1
	  do_cleanups (old_chain);
d1252 2
a1253 2
encode_actions (struct breakpoint *t, char ***tdp_actions,
		char ***stepping_actions)
d1277 1
a1277 1
				 t->loc->address, &frame_reg, &frame_offset);
d1336 1
a1336 1
				     t->loc->address,
d1346 1
a1346 1
				     t->loc->address,
d1360 1
a1360 1
				     block_for_pc (t->loc->address), 1);
d1395 1
a1395 1
				      t->loc->address);
d1399 1
a1399 1
		      aexpr = gen_trace_for_expr (t->loc->address, exp);
d1457 1
a1457 1
				     block_for_pc (t->loc->address), 1);
d1460 1
a1460 1
		  aexpr = gen_eval_for_expr (t->loc->address, exp);
d2238 1
d2264 8
a2271 1
  stepping_frame = (t->loc->address != (regcache_read_pc (regcache)));
d3261 1
@


1.143
log
@	gdb/doc/
	* gdb.texinfo (Using the Collected Data): Specify that the address
	range of `tfind outsize' is exclusive, and that the address range
	of `tfind range' is inclusive.
	(Tracepoint Packets): Specify that the address range of
	`QTFrame:range' is inclusive, and that the address range of
	`QTFrame:outside' is exclusive

	gdb/
	* tracepoint.c (_initialize_tracepoint): Specify that the address
	range of `tfind outsize' is exclusive, and that the address range
	of `tfind range' is inclusive, in the commands' help strings.
@
text
@d2541 61
@


1.143.2.1
log
@	* tracepoint.h (set_traceframe_number)
	(cleanup_restore_current_traceframe): Declare.
	* tracepoint.c (set_traceframe_number): New.
	(struct current_traceframe_cleanup): New.
	(do_restore_current_traceframe_cleanup)
	(restore_current_traceframe_cleanup_dtor)
	(make_cleanup_restore_current_traceframe): New.
	* infrun.c: Include tracepoint.h.
	(fetch_inferior_event): Switch out and in of tfind mode.
@
text
@a2540 61
/* Make the traceframe NUM be the current trace frame.  Does nothing
   if NUM is already current.  */

void
set_traceframe_number (int num)
{
  int newnum;

  if (traceframe_number == num)
    {
      /* Nothing to do.  */
      return;
    }

  newnum = target_trace_find (tfind_number, num, 0, 0, NULL);

  if (newnum != num)
    warning (_("could not change traceframe"));

  traceframe_number = newnum;

  /* Changing the traceframe changes our view of registers and of the
     frame chain.  */
  registers_changed ();
}

/* A cleanup used when switching away and back from tfind mode.  */

struct current_traceframe_cleanup
{
  /* The traceframe we were inspecting.  */
  int traceframe_number;
};

static void
do_restore_current_traceframe_cleanup (void *arg)
{
  struct current_traceframe_cleanup *old = arg;

  set_traceframe_number (old->traceframe_number);
}

static void
restore_current_traceframe_cleanup_dtor (void *arg)
{
  struct current_traceframe_cleanup *old = arg;

  xfree (old);
}

struct cleanup *
make_cleanup_restore_current_traceframe (void)
{
  struct current_traceframe_cleanup *old;

  old = xmalloc (sizeof (struct current_traceframe_cleanup));
  old->traceframe_number = traceframe_number;

  return make_cleanup_dtor (do_restore_current_traceframe_cleanup, old,
			    restore_current_traceframe_cleanup_dtor);
}
@


1.143.2.2
log
@	* target.c (memory_xfer_partial): Don't use the stack cache if
	inspecting trace frames.
	* tracepoint.c (finish_tfind_command): Invalidate the target
	dcache.
@
text
@a1748 1
  target_dcache_invalidate ();
@


1.142
log
@	* tracepoint.c (tfile_open): Remove spurious discard_cleanups.
	Merge uploaded TSVs before merging uploaded tracepoints.
@
text
@d3613 1
a3613 1
Select a trace frame whose PC is outside the given range.\n\
d3618 1
a3618 1
Select a trace frame whose PC is in the given range.\n\
@


1.141
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@a2826 1
  discard_cleanups (old_chain);
d2883 4
a2888 2
  merge_uploaded_trace_state_variables (&uploaded_tsvs);

@


1.140
log
@2010-01-16  Stan Shebs  <stan@@codesourcery.com>

	* tracepoint.h (struct trace_status): Use unsigned long long
	instead of size_t.
	* tracepoint.c (trace_status_command): Fix printf directive.
	(trace_save_command): Check fwrite returns, fix printf directive.
	(trace_filename): New global.
	(tfile_open): Set it, check read returns.
	(tfile_close): Free trace_filename.
	(tfile_get_traceframe_address): Check read returns.
	(tfile_trace_find): Ditto.
	(tfile_fetch_registers): Ditto.
	(tfile_xfer_partial): Ditto.
	(tfile_get_trace_state_variable_value): Ditto.
@
text
@a166 1
static void tracepoint_save_command (char *, int);
@


1.139
log
@	Add trace file support.
	* tracepoint.h (enum trace_stop_reason): New enum.
	(struct trace_status): New struct.
	(parse_trace_status): Declare.
	(struct uploaded_tp): Move here from remote.c,
	add fields for actions.
	(struct uploaded_tsv): New struct.
	* tracepoint.c (tfile_ops): New target vector.
	(trace_fd): New global.
	(tfile_open): New function.
	(tfile_close): New function.
	(tfile_files_info): New function.
	(tfile_get_trace_status): New function.
	(tfile_get_traceframe_address): New function.
	(tfile_trace_find): New function.
	(tfile_fetch_registers): New function.
	(tfile_xfer_partial): New function.
	(tfile_get_trace_state_variable_value): New function.
	(init_tfile_ops): New function.
	(_initialize_tracepoint): Call it, add tfile target.
	(trace_status): New global.
	(current_trace_status): New function.
	(trace_running_p): Remove, change all users to get from
	current_trace_status()->running.
	(get_trace_status): Remove.
	(trace_status_command): Call target_get_trace_status directly,
	report more detail including tracing stop reasons.
	(trace_find_command): Always allow tfind on a file.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	(trace_frames_offset, cur_offset): Declare as off_t.
	(trace_regblock_size): Rename from reg_size, update users.
	(parse_trace_status): New function.
	(tfile_interp_line): New function.
	(disconnect_or_stop_tracing): Ensure current trace
	status before asking what to do.
	(stop_reason_names): New global.
	(trace_save_command): New command.
	(get_uploaded_tp): Move here from remote.c.
	(find_matching_tracepoint): Ditto.
	(merge_uploaded_tracepoints): New function.
	(parse_trace_status): Use stop_reason_names.
	(_initialize_tracepoint): Define tsave command.
	* target.h (target_ops): New fields to_save_trace_data,
	to_upload_tracepoints, to_upload_trace_state_variables,
	to_get_raw_trace_data, change to_get_trace_status
	to take a pointer to a status struct.
	(target_save_trace_data): New macro.
	(target_upload_tracepoints): New macro.
	(target_upload_trace_state_variables): New macro.
	(target_get_raw_trace_data): New macro.
	* target.c (update_current_target): Add new methods, change
	signature of to_get_trace_status.
	* remote.c (hex2bin): Make globally visible.
	(bin2hex): Ditto.
	(remote_download_trace_state_variable): Download name also.
	(remote_get_trace_status): Update parameter, use
	parse_trace_status.
	(remote_save_trace_data): New function.
	(remote_upload_tracepoints): New function.
	(remote_upload_trace_state_variables): New function.
	(remote_get_raw_trace_data): New function.
	(remote_start_remote): Use them.
	(_initialize_remote_ops): Add operations.
	* ax-gdb.c: Include breakpoint.h.
	* breakpoint.c (create_tracepoint_from_upload): Use
	break_command_really, return tracepoint, warn about unimplemented
	parts.
	* NEWS: Mention trace file addition.

	* gdb.texinfo (Trace Files): New section.
	(Tracepoint Packets): Document QTSave and qTBuffer.
	(Trace File Format): New appendix.

	* generic/gdbtk-bp.c (gdb_trace_status): Use current_trace_status.

	* gdb.trace/tfile.c: New file.
	* gdb.trace/tfile.exp: New file.
@
text
@d1650 1
a1650 1
      printf_filtered (_("Trace buffer has %d bytes free.\n"),
d2345 1
d2393 3
a2395 1
  fwrite ("\x7fTRACE0\n", 8, 1, fp);
d2403 1
a2403 1
  fprintf (fp, "status %c;%s:%x;tframes:%x;tfree:%x\n",
d2406 1
a2406 1
	   ts->traceframe_count, (unsigned int) ts->buffer_free);
d2479 3
a2481 1
      fwrite (buf, gotten, 1, fp);
d2486 3
a2488 1
  fwrite (&gotten, 4, 1, fp);
d2776 1
d2797 1
a2797 1
  int bytes, i;
d2830 1
d2835 6
a2840 1
  read (trace_fd, &header, TRACE_HEADER_SIZE);
d2861 6
a2866 1
      read (trace_fd, &byte, 1);
d3134 2
d3168 1
d3174 6
a3179 1
  read (trace_fd, &tpnum, 2);
d3200 1
a3200 1
  int tfnum = 0, found = 0;
d3211 5
a3215 1
      read (trace_fd, &tpnum, 2);
d3219 5
a3223 1
      read (trace_fd, &data_size, 4);	
d3284 1
a3284 1
  int i, pos, offset, regn, regsize;
d3299 6
a3304 1
      read (trace_fd, &block_type, 1);
d3309 6
a3314 1
	  read (trace_fd, regs, trace_regblock_size);
d3341 5
a3345 1
	  read (trace_fd, &mlen, 2);
d3367 1
a3367 1
  int pos;
d3382 5
a3386 1
      read (trace_fd, &block_type, 1);
d3395 11
a3405 2
	  read (trace_fd, &maddr, 8);
	  read (trace_fd, &mlen, 2);
d3408 6
a3413 1
	      read (trace_fd, readbuf, mlen);
d3440 1
a3440 1
  int pos, vnum;
d3447 5
a3451 1
      read (trace_fd, &block_type, 1);
d3461 5
a3465 1
	  read (trace_fd, &mlen, 2);
d3470 5
a3474 1
	  read (trace_fd, &vnum, 4);
d3477 5
a3481 1
	      read (trace_fd, val, 8);
@


1.138
log
@	Make tracepoint operations go through target vector.
	* target.h (enum trace_find_type): New enum.
	(struct target_ops): New fields to_trace_init,
	to_download_tracepoint, to_download_trace_state_variable,
	to_trace_set_readonly_regions, to_trace_start, to_get_trace_status,
	to_trace_stop, to_trace_find, to_get_trace_state_variable_value,
	to_set_disconnected_tracing.
	(target_trace_init): New macro.
	(target_download_tracepoint): New macro.
	(target_download_trace_state_variable): New macro.
	(target_trace_start): New macro.
	(target_trace_set_readonly_regions): New macro.
	(target_get_trace_status): New macro.
	(target_trace_stop): New macro.
	(target_trace_find): New macro.
	(target_get_trace_state_variable_value): New macro.
	(target_set_disconnected_tracing): New macro.
	* target.c (update_current_target): Inherit and set defaults for
	tracepoint operations.
	* tracepoint.c (default_collect): Make globally visible.
	(target_is_remote): Remove, along with all calls.
	(tvariables_info): Call target_get_trace_state_variable_value.
	(remote_set_transparent_ranges): Remove.
	(trace_start_command): Call target_trace_init,
	target_download_tracepoint, etc.
	(download_tracepoint): Remove.
	(trace_stop_command): Simplify.
	(stop_tracing): Call target_trace_stop.
	(get_trace_status): Call target_get_trace_status.
	(trace_status_command): Add case for targets that cannot trace.
	(finish_tfind_command): Change to take numerical arguments, call
	target_trace_find.
	(trace_find_command): Update call to finish_tfind_command.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	(set_disconnected_tracing_value): Call
	target_set_disconnected_tracing.
	* remote.c: Add protocol encoding bits from tracepoint.c.
	(trace_error): Move from tracepoint.c.
	(remote_get_noisy_reply): Ditto.
	(free_actions_list_cleanup_wrapper): Ditto.
	(free_actions_list): Ditto.
	(remote_trace_init): New function.
	(remote_download_tracepoint): New function.
	(remote_download_trace_state_variable): New function.
	(remote_trace_set_readonly_regions): New function.
	(remote_trace_start): New function.
	(remote_get_trace_status): New function.
	(remote_trace_stop): New function.
	(remote_trace_find): New function.
	(remote_download_trace_state_variable): New function.
	(remote_set_disconnected_tracing): New function.
	(init_remote_ops): Add tracepoint operations.
@
text
@d46 1
d62 7
d181 4
d187 17
d437 1
a437 1
      else if (trace_running_p || traceframe_number >= 0)
d1545 1
a1545 1
  /* Init any trace state variables that start with nonzero values.  */
d1548 1
a1548 2
      if (tsv->initial_value != 0)
	target_download_trace_state_variable (tsv);
d1561 1
a1561 1
  trace_running_p = 1;
d1575 2
a1576 14
  trace_running_p = 0;
}

unsigned long trace_running_p;

int
get_trace_status ()
{
  int status = target_get_trace_status (NULL);

  /* exported for use by the GUI */
  trace_running_p = (status > 0);

  return status;
d1583 2
a1584 1
  int status = get_trace_status ();
d1586 18
a1603 3
  if (status < 0)
    printf_filtered (_("Trace can not be run on the target.\n"));
  else if (trace_running_p)
d1612 35
a1646 1
    printf_filtered (_("Trace is not running on the target.\n"));
d1648 7
d1665 8
a1672 1
  if (trace_running_p && from_tty)
d1757 5
a1761 1
  if (from_tty)
d1802 1
a1802 1
  if (trace_running_p)
d1861 1
a1861 1
  if (trace_running_p)
d1879 1
a1879 1
  if (trace_running_p)
d1919 1
a1919 1
  if (trace_running_p)
d2001 1
a2001 1
  if (trace_running_p)
d2035 1
a2035 1
  if (trace_running_p)
d2326 162
d2535 921
d3502 5
d3637 4
@


1.137
log
@	* tracepoint.c (trace_dump_command): Don't decr_pc_after_break.
@
text
@a34 4
#include "remote.h"
extern int remote_supports_cond_tracepoints (void);
extern int remote_supports_fast_tracepoints (void);
extern char *unpack_varlen_hex (char *buff, ULONGEST *result);
d45 1
d144 1
a144 1
static char *default_collect = "";
a147 3
static char *target_buf;
static long target_buf_size;
  
a169 2
static void free_actions_list (char **actions_list);
static void free_actions_list_cleanup_wrapper (void *);
a174 57
/* Utility: returns true if "target remote" */
static int
target_is_remote (void)
{
  if (current_target.to_shortname &&
      (strcmp (current_target.to_shortname, "remote") == 0
       || strcmp (current_target.to_shortname, "extended-remote") == 0))
    return 1;
  else
    return 0;
}

/* Utility: generate error from an incoming stub packet.  */
static void
trace_error (char *buf)
{
  if (*buf++ != 'E')
    return;			/* not an error msg */
  switch (*buf)
    {
    case '1':			/* malformed packet error */
      if (*++buf == '0')	/*   general case: */
	error (_("tracepoint.c: error in outgoing packet."));
      else
	error (_("tracepoint.c: error in outgoing packet at field #%ld."),
	       strtol (buf, NULL, 16));
    case '2':
      error (_("trace API error 0x%s."), ++buf);
    default:
      error (_("Target returns error code '%s'."), buf);
    }
}

/* Utility: wait for reply from stub, while accepting "O" packets.  */
static char *
remote_get_noisy_reply (char **buf_p,
			long *sizeof_buf)
{
  do				/* Loop on reply from remote stub.  */
    {
      char *buf;
      QUIT;			/* allow user to bail out with ^C */
      getpkt (buf_p, sizeof_buf, 0);
      buf = *buf_p;
      if (buf[0] == 0)
	error (_("Target does not support this command."));
      else if (buf[0] == 'E')
	trace_error (buf);
      else if (buf[0] == 'O' &&
	       buf[1] != 'K')
	remote_console_output (buf + 1);	/* 'O' message from stub */
      else
	return buf;		/* here's the actual reply */
    }
  while (1);
}

a386 25
  if (target_is_remote ())
    {
      char buf[20];

      for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
	{
	  /* We don't know anything about the value until we get a
	     valid packet.  */
	  tsv->value_known = 0;
	  sprintf (buf, "qTV:%x", tsv->number);
	  putpkt (buf);
	  reply = remote_get_noisy_reply (&target_buf, &target_buf_size);
	  if (reply && *reply)
	    {
	      if (*reply == 'V')
		{
		  unpack_varlen_hex (reply + 1, &tval);
		  tsv->value = (LONGEST) tval;
		  tsv->value_known = 1;
		}
	      /* FIXME say anything about oddball replies? */
	    }
	}
    }

d393 5
a1210 20
static void
free_actions_list_cleanup_wrapper (void *al)
{
  free_actions_list (al);
}

static void
free_actions_list (char **actions_list)
{
  int ndx;

  if (actions_list == 0)
    return;

  for (ndx = 0; actions_list[ndx]; ndx++)
    xfree (actions_list[ndx]);

  xfree (actions_list);
}

d1212 1
a1212 1
static void
a1480 43
/* Set "transparent" memory ranges

   Allow trace mechanism to treat text-like sections
   (and perhaps all read-only sections) transparently, 
   i.e. don't reject memory requests from these address ranges
   just because they haven't been collected.  */

static void
remote_set_transparent_ranges (void)
{
  asection *s;
  bfd_size_type size;
  bfd_vma lma;
  int anysecs = 0;

  if (!exec_bfd)
    return;			/* No information to give.  */

  strcpy (target_buf, "QTro");
  for (s = exec_bfd->sections; s; s = s->next)
    {
      char tmp1[40], tmp2[40];

      if ((s->flags & SEC_LOAD) == 0 ||
      /* (s->flags & SEC_CODE)     == 0 || */
	  (s->flags & SEC_READONLY) == 0)
	continue;

      anysecs = 1;
      lma = s->lma;
      size = bfd_get_section_size (s);
      sprintf_vma (tmp1, lma);
      sprintf_vma (tmp2, lma + size);
      sprintf (target_buf + strlen (target_buf), 
	       ":%s,%s", tmp1, tmp2);
    }
  if (anysecs)
    {
      putpkt (target_buf);
      getpkt (&target_buf, &target_buf_size, 0);
    }
}

a1487 2
int download_tracepoint (struct breakpoint *t);

d1500 4
a1503 1
  if (target_is_remote ())
d1505 4
a1508 48
      putpkt ("QTinit");
      remote_get_noisy_reply (&target_buf, &target_buf_size);
      if (strcmp (target_buf, "OK"))
	error (_("Target does not support this command."));

      tp_vec = all_tracepoints ();
      for (ix = 0; VEC_iterate (breakpoint_p, tp_vec, ix, t); ix++)
	{
	  t->number_on_target = 0;
	  if (download_tracepoint (t))
	    {
	      t->number_on_target = t->number;
	      any_downloaded = 1;
	    }
	}
      VEC_free (breakpoint_p, tp_vec);

      /* No point in tracing without any tracepoints... */
      if (!any_downloaded)
	error ("No tracepoints downloaded, not starting trace");

      /* Init any trace state variables that start with nonzero values.  */

      for (ix = 0; VEC_iterate (tsv_s, tvariables, ix, tsv); ++ix)
	{
	  if (tsv->initial_value != 0)
	    {
	      sprintf (buf, "QTDV:%x:%s",
		       tsv->number, phex ((ULONGEST) tsv->initial_value, 8));
	      putpkt (buf);
	      remote_get_noisy_reply (&target_buf, &target_buf_size);
	    }
	}

      /* Tell target to treat text-like sections as transparent.  */
      remote_set_transparent_ranges ();
      /* Now insert traps and begin collecting data.  */
      putpkt ("QTStart");
      remote_get_noisy_reply (&target_buf, &target_buf_size);
      if (strcmp (target_buf, "OK"))
	error (_("Bogus reply from target: %s"), target_buf);
      set_traceframe_num (-1);	/* All old traceframes invalidated.  */
      set_tracepoint_num (-1);
      set_traceframe_context (NULL);
      trace_running_p = 1;
      if (deprecated_trace_start_stop_hook)
	deprecated_trace_start_stop_hook (1, from_tty);

d1510 11
a1520 68
  else
    error (_("Trace can only be run on remote targets."));
}

/* Send the definition of a single tracepoint to the target.  Return 1
   if successful, 0 if not.  */

int
download_tracepoint (struct breakpoint *t)
{
  CORE_ADDR tpaddr;
  char tmp[40];
  char buf[2048];
  char **tdp_actions;
  char **stepping_actions;
  int ndx;
  struct cleanup *old_chain = NULL;
  struct agent_expr *aexpr;
  struct cleanup *aexpr_chain = NULL;

  tpaddr = t->loc->address;
  sprintf_vma (tmp, (t->loc ? tpaddr : 0));
  sprintf (buf, "QTDP:%x:%s:%c:%lx:%x", t->number, 
	   tmp, /* address */
	   (t->enable_state == bp_enabled ? 'E' : 'D'),
	   t->step_count, t->pass_count);
  /* Fast tracepoints are mostly handled by the target, but we can
     tell the target how big of an instruction block should be moved
     around.  */
  if (t->type == bp_fast_tracepoint)
    {
      /* Only test for support at download time; we may not know
	 target capabilities at definition time.  */
      if (remote_supports_fast_tracepoints ())
	{
	  int isize;

	  if (gdbarch_fast_tracepoint_valid_at (get_current_arch (),
						tpaddr, &isize, NULL))
	    sprintf (buf + strlen (buf), ":F%x", isize);
	  else
	    /* If it passed validation at definition but fails now,
	       something is very wrong.  */
	    internal_error (__FILE__, __LINE__,
			    "Fast tracepoint not valid during download");
	}
      else
	/* Fast tracepoints are functionally identical to regular
	   tracepoints, so don't take lack of support as a reason to
	   give up on the trace run.  */
	warning (_("Target does not support fast tracepoints, downloading %d as regular tracepoint"), t->number);
    }
  /* If the tracepoint has a conditional, make it into an agent
     expression and append to the definition.  */
  if (t->loc->cond)
    {
      /* Only test support at download time, we may not know target
	 capabilities at definition time.  */
      if (remote_supports_cond_tracepoints ())
	{
	  aexpr = gen_eval_for_expr (t->loc->address, t->loc->cond);
	  aexpr_chain = make_cleanup_free_agent_expr (aexpr);
	  sprintf (buf + strlen (buf), ":X%x,", aexpr->len);
	  mem2hex (aexpr->buf, buf + strlen (buf), aexpr->len);
	  do_cleanups (aexpr_chain);
	}
      else
	warning (_("Target does not support conditional tracepoints, ignoring tp %d cond"), t->number);
d1522 3
d1526 2
a1527 6
  if (t->actions || *default_collect)
    strcat (buf, "-");
  putpkt (buf);
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (strcmp (target_buf, "OK"))
    error (_("Target does not support tracepoints."));
d1529 5
a1533 45
  if (!t->actions && !*default_collect)
    return 1;

  encode_actions (t, &tdp_actions, &stepping_actions);
  old_chain = make_cleanup (free_actions_list_cleanup_wrapper,
			    tdp_actions);
  (void) make_cleanup (free_actions_list_cleanup_wrapper, stepping_actions);

  /* do_single_steps (t); */
  if (tdp_actions)
    {
      for (ndx = 0; tdp_actions[ndx]; ndx++)
	{
	  QUIT;	/* allow user to bail out with ^C */
	  sprintf (buf, "QTDP:-%x:%s:%s%c",
		   t->number, tmp, /* address */
		   tdp_actions[ndx],
		   ((tdp_actions[ndx + 1] || stepping_actions)
		    ? '-' : 0));
	  putpkt (buf);
	  remote_get_noisy_reply (&target_buf,
				  &target_buf_size);
	  if (strcmp (target_buf, "OK"))
	    error (_("Error on target while setting tracepoints."));
	}
    }
  if (stepping_actions)
    {
      for (ndx = 0; stepping_actions[ndx]; ndx++)
	{
	  QUIT;	/* allow user to bail out with ^C */
	  sprintf (buf, "QTDP:-%x:%s:%s%s%s",
		   t->number, tmp, /* address */
		   ((ndx == 0) ? "S" : ""),
		   stepping_actions[ndx],
		   (stepping_actions[ndx + 1] ? "-" : ""));
	  putpkt (buf);
	  remote_get_noisy_reply (&target_buf,
				  &target_buf_size);
	  if (strcmp (target_buf, "OK"))
	    error (_("Error on target while setting tracepoints."));
	}
    }
  do_cleanups (old_chain);
  return 1;
d1540 1
a1540 8
  if (target_is_remote ())
    {
      stop_tracing ();
      if (deprecated_trace_start_stop_hook)
	deprecated_trace_start_stop_hook (0, from_tty);
    }
  else
    error (_("Trace can only be run on remote targets."));
d1546 1
a1546 4
  putpkt ("QTStop");
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (strcmp (target_buf, "OK"))
    error (_("Bogus reply from target: %s"), target_buf);
d1552 1
a1552 1
void
d1555 1
a1555 2
  putpkt ("qTStatus");
  remote_get_noisy_reply (&target_buf, &target_buf_size);
d1557 2
a1558 3
  if (target_buf[0] != 'T' ||
      (target_buf[1] != '0' && target_buf[1] != '1'))
    error (_("Bogus trace status reply from target: %s"), target_buf);
d1560 1
a1560 2
  /* exported for use by the GUI */
  trace_running_p = (target_buf[1] == '1');
d1567 9
a1575 12
  if (target_is_remote ())
    {
      get_trace_status ();

      if (trace_running_p)
	{
	  printf_filtered (_("Trace is running on the target.\n"));
	  if (disconnected_tracing)
	    printf_filtered (_("Trace will continue if GDB disconnects.\n"));
	  else
	    printf_filtered (_("Trace will stop if GDB disconnects.\n"));
	}
d1577 4
a1580 7
	printf_filtered (_("Trace is not running on the target.\n"));

      if (traceframe_number >= 0)
	printf_filtered (_("Looking at trace frame %d, tracepoint %d.\n"),
			 traceframe_number, tracepoint_number);
      else
	printf_filtered (_("Not looking at any trace frame.\n"));
d1582 3
a1584 1
    }
d1586 1
a1586 1
    error (_("Trace can only be run on remote targets."));
d1609 2
a1610 2
finish_tfind_command (char **msg,
		      long *sizeof_msg,
d1620 46
a1665 58
  putpkt (*msg);
  reply = remote_get_noisy_reply (msg, sizeof_msg);

  while (reply && *reply)
    switch (*reply)
      {
      case 'F':
	if ((target_frameno = (int) strtol (++reply, &reply, 16)) == -1)
	  {
	    /* A request for a non-existant trace frame has failed.
	       Our response will be different, depending on FROM_TTY:

	       If FROM_TTY is true, meaning that this command was 
	       typed interactively by the user, then give an error
	       and DO NOT change the state of traceframe_number etc.

	       However if FROM_TTY is false, meaning that we're either
	       in a script, a loop, or a user-defined command, then 
	       DON'T give an error, but DO change the state of
	       traceframe_number etc. to invalid.

	       The rationalle is that if you typed the command, you
	       might just have committed a typo or something, and you'd
	       like to NOT lose your current debugging state.  However
	       if you're in a user-defined command or especially in a
	       loop, then you need a way to detect that the command
	       failed WITHOUT aborting.  This allows you to write
	       scripts that search thru the trace buffer until the end,
	       and then continue on to do something else.  */

	    if (from_tty)
	      error (_("Target failed to find requested trace frame."));
	    else
	      {
		if (info_verbose)
		  printf_filtered ("End of trace buffer.\n");
		/* The following will not recurse, since it's
		   special-cased.  */
		trace_find_command ("-1", from_tty);
		reply = NULL;	/* Break out of loop 
				   (avoid recursive nonsense).  */
	      }
	  }
	break;
      case 'T':
	if ((target_tracept = (int) strtol (++reply, &reply, 16)) == -1)
	  error (_("Target failed to find requested trace frame."));
	break;
      case 'O':		/* "OK"? */
	if (reply[1] == 'K' && reply[2] == '\0')
	  reply += 2;
	else
	  error (_("Bogus reply from target: %s"), reply);
	break;
      default:
	error (_("Bogus reply from target: %s"), reply);
      }

d1718 11
a1728 1
  if (target_is_remote ())
d1730 12
a1741 2
      if (trace_running_p)
	error ("May not look at trace frames while trace is running.");
d1743 2
a1744 2
      if (deprecated_trace_find_hook)
	deprecated_trace_find_hook (args, from_tty);
d1746 1
a1746 27
      if (args == 0 || *args == 0)
	{ /* TFIND with no args means find NEXT trace frame.  */
	  if (traceframe_number == -1)
	    frameno = 0;	/* "next" is first one */
	  else
	    frameno = traceframe_number + 1;
	}
      else if (0 == strcmp (args, "-"))
	{
	  if (traceframe_number == -1)
	    error (_("not debugging trace buffer"));
	  else if (from_tty && traceframe_number == 0)
	    error (_("already at start of trace buffer"));

	  frameno = traceframe_number - 1;
	}
      else
	frameno = parse_and_eval_long (args);

      if (frameno < -1)
	error (_("invalid input (%d is less than zero)"), frameno);

      sprintf (target_buf, "QTFrame:%x", frameno);
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
    }
  else
    error (_("Trace can only be run on remote targets."));
d1777 2
a1778 4
  if (target_is_remote ())
    {
      if (trace_running_p)
	error ("May not look at trace frames while trace is running.");
d1780 4
a1783 4
      if (args == 0 || *args == 0)
	pc = regcache_read_pc (get_current_regcache ());
      else
	pc = parse_and_eval_address (args);
d1785 1
a1785 6
      sprintf_vma (tmp, pc);
      sprintf (target_buf, "QTFrame:pc:%s", tmp);
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
    }
  else
    error (_("Trace can only be run on remote targets."));
d1795 4
a1798 1
  if (target_is_remote ())
d1800 2
a1801 10
      if (trace_running_p)
	error ("May not look at trace frames while trace is running.");

      if (args == 0 || *args == 0)
	{
	  if (tracepoint_number == -1)
	    error (_("No current tracepoint -- please supply an argument."));
	  else
	    tdp = tracepoint_number;	/* default is current TDP */
	}
d1803 4
a1806 1
	tdp = parse_and_eval_long (args);
d1808 6
a1813 6
      /* If we have the tracepoint on hand, use the number that the
	 target knows about (which may be different if we disconnected
	 and reconnected).  */
      tp = get_tracepoint (tdp);
      if (tp)
	tdp = tp->number_on_target;
d1815 1
a1815 5
      sprintf (target_buf, "QTFrame:tdp:%x", tdp);
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
    }
  else
    error (_("Trace can only be run on remote targets."));
d1835 19
a1853 1
  if (target_is_remote ())
d1855 2
a1856 4
      if (trace_running_p)
	error ("May not look at trace frames while trace is running.");

      if (args == 0 || *args == 0)
d1858 46
a1903 79
	  sal = find_pc_line (get_frame_pc (get_current_frame ()), 0);
	  sals.nelts = 1;
	  sals.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));
	  sals.sals[0] = sal;
	}
      else
	{
	  sals = decode_line_spec (args, 1);
	  sal = sals.sals[0];
	}

      old_chain = make_cleanup (xfree, sals.sals);
      if (sal.symtab == 0)
	{
	  struct gdbarch *gdbarch = get_current_arch ();

	  printf_filtered ("TFIND: No line number information available");
	  if (sal.pc != 0)
	    {
	      /* This is useful for "info line *0x7f34".  If we can't
	         tell the user about a source line, at least let them
	         have the symbolic address.  */
	      printf_filtered (" for address ");
	      wrap_here ("  ");
	      print_address (gdbarch, sal.pc, gdb_stdout);
	      printf_filtered (";\n -- will attempt to find by PC. \n");
	    }
	  else
	    {
	      printf_filtered (".\n");
	      return;		/* No line, no PC; what can we do?  */
	    }
	}
      else if (sal.line > 0
	       && find_line_pc_range (sal, &start_pc, &end_pc))
	{
	  struct gdbarch *gdbarch = get_objfile_arch (sal.symtab->objfile);

	  if (start_pc == end_pc)
	    {
	      printf_filtered ("Line %d of \"%s\"",
			       sal.line, sal.symtab->filename);
	      wrap_here ("  ");
	      printf_filtered (" is at address ");
	      print_address (gdbarch, start_pc, gdb_stdout);
	      wrap_here ("  ");
	      printf_filtered (" but contains no code.\n");
	      sal = find_pc_line (start_pc, 0);
	      if (sal.line > 0 &&
		  find_line_pc_range (sal, &start_pc, &end_pc) &&
		  start_pc != end_pc)
		printf_filtered ("Attempting to find line %d instead.\n",
				 sal.line);
	      else
		error (_("Cannot find a good line."));
	    }
	}
      else
	/* Is there any case in which we get here, and have an address
	   which the user would want to see?  If we have debugging
	   symbols and no line numbers?  */
	error (_("Line number %d is out of range for \"%s\"."),
	       sal.line, sal.symtab->filename);

      sprintf_vma (startpc_str, start_pc);
      sprintf_vma (endpc_str, end_pc - 1);
      /* Find within range of stated line.  */
      if (args && *args)
	sprintf (target_buf, "QTFrame:range:%s:%s", 
		 startpc_str, endpc_str);
      /* Find OUTSIDE OF range of CURRENT line.  */
      else
	sprintf (target_buf, "QTFrame:outside:%s:%s", 
		 startpc_str, endpc_str);
      finish_tfind_command (&target_buf, &target_buf_size,
			    from_tty);
      do_cleanups (old_chain);
    }
d1905 2
a1906 1
    error (_("Trace can only be run on remote targets."));
d1917 2
a1918 4
  if (target_is_remote ())
    {
      if (trace_running_p)
	error ("May not look at trace frames while trace is running.");
d1920 5
a1924 5
      if (args == 0 || *args == 0)
	{ /* XXX FIXME: what should default behavior be?  */
	  printf_filtered ("Usage: tfind range <startaddr>,<endaddr>\n");
	  return;
	}
d1926 7
a1932 18
      if (0 != (tmp = strchr (args, ',')))
	{
	  *tmp++ = '\0';	/* terminate start address */
	  while (isspace ((int) *tmp))
	    tmp++;
	  start = parse_and_eval_address (args);
	  stop = parse_and_eval_address (tmp);
	}
      else
	{			/* no explicit end address? */
	  start = parse_and_eval_address (args);
	  stop = start + 1;	/* ??? */
	}

      sprintf_vma (start_str, start);
      sprintf_vma (stop_str, stop);
      sprintf (target_buf, "QTFrame:range:%s:%s", start_str, stop_str);
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d1935 6
a1940 1
    error (_("Trace can only be run on remote targets."));
d1951 2
a1952 4
  if (target_is_remote ())
    {
      if (trace_running_p)
	error ("May not look at trace frames while trace is running.");
d1954 5
a1958 5
      if (args == 0 || *args == 0)
	{ /* XXX FIXME: what should default behavior be? */
	  printf_filtered ("Usage: tfind outside <startaddr>,<endaddr>\n");
	  return;
	}
d1960 7
a1966 18
      if (0 != (tmp = strchr (args, ',')))
	{
	  *tmp++ = '\0';	/* terminate start address */
	  while (isspace ((int) *tmp))
	    tmp++;
	  start = parse_and_eval_address (args);
	  stop = parse_and_eval_address (tmp);
	}
      else
	{			/* no explicit end address? */
	  start = parse_and_eval_address (args);
	  stop = start + 1;	/* ??? */
	}

      sprintf_vma (start_str, start);
      sprintf_vma (stop_str, stop);
      sprintf (target_buf, "QTFrame:outside:%s:%s", start_str, stop_str);
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d1969 6
a1974 1
    error (_("Trace can only be run on remote targets."));
a2144 6
  if (!target_is_remote ())
    {
      error (_("Trace can only be run on remote targets."));
      return;
    }

d2248 1
a2248 11
  char buf[30];

  /* No need to do anything special if target not active.  */
  if (!target_is_remote ())
    return;

  sprintf (buf, "QTDisconnected:%x", value);
  putpkt (buf);
  remote_get_noisy_reply (&target_buf, &target_buf_size);
  if (strcmp (target_buf, "OK"))
    error (_("Target does not support this command."));
a2464 3

  target_buf_size = 2048;
  target_buf = xmalloc (target_buf_size);
@


1.136
log
@	Support disconnected tracing.
	* infcmd.c (detach_command): Ask whether to stop tracing.
	* cli/cli-cmds.c (quit_command): Ditto.
	* breakpoint.h (struct breakpoint): New field number_on_target.
	* breakpoint.c (create_tracepoint_from_upload): New function.
	(get_tracepoint_by_number_on_target): New function.
	* remote.c (struct remote): New field disconnected_tracing.
	(remote_disconnected_tracing_feature): New function.
	(remote_protocol_features): Add DisconnectedTracing.
	(struct uploaded_tp): New struct.
	(uploaded_tps): New global.
	(get_uploaded_tp): New function.
	(find_matching_tracepoint): New function.
	(remote_get_tracing_state): New function.
	(remote_start_remote): Call it.
	* tracepoint.c (disconnected_tracing): New global.
	(trace_start_command): Initialize number_on_target.
	(stop_tracing): New function, split out from...
	(trace_stop_command): Call stop_tracing.
	(get_trace_status): New function, split out from...
	(trace_status_command): Call get_trace_status, add info on
	disconnection behavior.
	(disconnect_or_stop_tracing): New function.
	(finish_tfind_command): Translate from number on target.
	(trace_find_tracepoint_command): Translate to number on target.
	(send_disconnected_tracing_value): New function.
	(set_disconnected_tracing): New function.
	(_initialize_tracepoint): Add disconnected-tracing variable.
	* NEWS: Mention disconnected tracing.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	disconnected tracing.
	(Tracepoint Packets): Document new protocol.
@
text
@d2544 1
a2544 2
  stepping_frame = (t->loc->address != (regcache_read_pc (regcache)
				   - gdbarch_decr_pc_after_break (gdbarch)));
@


1.135
log
@	Add fast tracepoints.
	* arch-utils.h (default_fast_tracepoint_valid_at): Declare.
	* arch-utils.c (default_fast_tracepoint_valid_at): New function.
	* breakpoint.h (enum bptype): Add bp_fast_tracepoint.
	* breakpoint.c (tracepoint_type): New function.
	(ALL_TRACEPOINTS): Use it.
	(should_be_inserted): Ditto.
	(bpstat_check_location): Ditto.
	(print_one_breakpoint_location): Ditto.
	(user_settable_breakpoint): Ditto.
	(set_breakpoint_location_function): Ditto.
	(disable_breakpoints_in_shlibs): Ditto.
	(delete_trace_command): Ditto.
	(print_it_typical): Add bp_fast_tracepoint case.
	(bpstat_what): Ditto.
	(print_one_breakpoint_location): Ditto.
	(allocate_bp_location): Ditto.
	(mention): Ditto.
	(breakpoint_re_set_one): Ditto.
	(disable_command): Ditto.
	(enable_command): Ditto.
	(check_fast_tracepoint_sals): New function.
	(break_command_really): Call it.
	(ftrace_command): New function.
	(_initialize_breakpoint): Add ftrace command.
	* gdbarch.sh (fast_tracepoint_valid_at): New.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): New function.
	(i386_gdbarch_init): Use it.
	* remote.c (struct remote_state): New field fast_tracepoints.
	(PACKET_FastTracepoints): New packet config type.
	(remote_fast_tracepoint_feature): New function.
	(remote_protocol_features): Add FastTracepoints.
	(remote_supports_fast_tracepoints): New function.
	(_initialize_remote): Add FastTracepoints.
	* tracepoint.c (download_tracepoint): Add fast tracepoint option.
	* NEWS: Mention fast tracepoints.

	* gdb.texinfo (Create and Delete Tracepoints): Describe fast
	tracepoints.
	(Tracepoint Packets): Describe remote protocol for fast
	tracepoints.

	* gdb.trace/tracecmd.exp: Test ftrace.
@
text
@d64 2
d149 2
d179 2
d1636 1
a1636 1
void download_tracepoint (struct breakpoint *t);
d1646 1
d1660 6
a1665 1
	  download_tracepoint (t);
d1669 4
d1705 2
a1706 1
/* Send the definition of a single tracepoint to the target.  */
d1708 1
a1708 1
void
d1779 1
a1779 1
    return;
d1822 1
d1831 1
a1831 5
      putpkt ("QTStop");
      remote_get_noisy_reply (&target_buf, &target_buf_size);
      if (strcmp (target_buf, "OK"))
	error (_("Bogus reply from target: %s"), target_buf);
      trace_running_p = 0;
d1839 10
d1851 14
d1871 1
a1871 9
      putpkt ("qTStatus");
      remote_get_noisy_reply (&target_buf, &target_buf_size);

      if (target_buf[0] != 'T' ||
	  (target_buf[1] != '0' && target_buf[1] != '1'))
	error (_("Bogus reply from target: %s"), target_buf);

      /* exported for use by the GUI */
      trace_running_p = (target_buf[1] == '1');
d1874 7
a1880 1
	printf_filtered (_("Trace is running on the target.\n"));
d1895 18
d1922 1
d1984 2
d1989 1
a1989 1
  set_tracepoint_num (target_tracept);
d2124 1
d2141 7
d2618 26
a2674 1

d2840 12
@


1.134
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d37 1
d1694 1
d1704 2
a1705 1
  sprintf_vma (tmp, (t->loc ? t->loc->address : 0));
d1710 26
@


1.133
log
@	Add new tracepoint action teval.
	* tracepoint.c (teval_pseudocommand): New function.
	(validate_actionline): Add teval action case.
	(encode_actions): Ditto.
	(_initialize_tracepoint): Define teval pseudocommand.
	* NEWS: Mention teval.

	* gdb.texinfo (Tracepoint Actions): Describe teval.

	* gdb.trace/actions.exp: Test teval action.
@
text
@d4 1
a4 1
   2007, 2008, 2009 Free Software Foundation, Inc.
@


1.132
log
@	* tracepoint.c (trace_find_command): Error out if trace running.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
@
text
@d528 6
d770 28
d1501 40
d2701 6
@


1.131
log
@	* tracepoint.c (trace_status_command): Add some status output.
@
text
@d1878 3
d1943 3
d1967 3
d2006 3
d2104 3
d2146 3
@


1.130
log
@	Add default-collect variable.
	* tracepoint.c (default_collect): New global.
	(encode_actions): Use it.
	(download_tracepoint): Test it, for otherwise
	action-less tracepoints.
	(_initialize_tracepoint): Add set/show.
	* NEWS: Mention default-collect.

	* gdb.texinfo (Tracepoint Actions): Describe default-collect.

	* gdb.trace/actions.exp: Test default-collect.
@
text
@d1739 12
@


1.129
log
@2009-12-28  Stan Shebs  <stan@@codesourcery.com>

	Add trace state variables.
	* ax.h (enum agent_op): Add getv, setv, and tracev.
	(ax_tsv): Declare.
	* ax-gdb.c: Include tracepoint.h.
	(gen_expr): Handle BINOP_ASSIGN, BINOP_ASSIGN_MODIFY, and
	OP_INTERNALVAR.
	(gen_expr_binop_rest): New function, split from gen_expr.
	* ax-general.c (ax_tsv): New function.
	(aop_map): Add new bytecodes.
	* tracepoint.h (struct trace_state_variable): New struct.
	(tsv_s): New typedef.
	(find_trace_state_variable): Declare.
	* tracepoint.c (tvariables): New global.
	(next_tsv_number): New global.
	(create_trace_state_variable): New function.
	(find_trace_state_variable): New function.
	(delete_trace_state_variable): New function.
	(trace_variable_command): New function.
	(delete_trace_variable_command): New function.
	(tvariables_info): New function.
	(trace_start_command): Download tsvs with initial values.
	(_initialize_tracepoint): Add new commands.
	* NEWS: Mention the addition of trace state variables.

==> doc/ChangeLog <==
2009-12-28  Stan Shebs  <stan@@codesourcery.com>

	* gdb.texinfo (Trace State Variables): New section.
	(Tracepoint Packets): Describe trace state variable packets.
	* agentexpr.texi (Bytecode Descriptions): Describe trace state
	variable bytecodes.

==> testsuite/ChangeLog <==
2009-12-28  Stan Shebs  <stan@@codesourcery.com>

	* gdb.trace/tsv.exp: New file.
	* gdb.base/completion.exp: Update ambiguous info output.
@
text
@d143 3
d148 1
a148 1

d1291 2
a1292 1

d1304 26
a1329 1
  for (action = t->actions; action; action = action->next)
d1486 3
d1651 1
a1651 1
  if (t->actions)
d1658 1
a1658 1
  if (!t->actions)
d2603 8
@


1.128
log
@2009-12-23  Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.h (gen_trace_for_var): Declare.
	* ax-gdb.c (gen_trace_for_var): New function.
	* dwarf2loc.c (dwarf_expr_frame_base_1): New function, split from...
	(dwarf_expr_frame_base): ...here.
	(dwarf2_tracepoint_var_ref): Add computed location case.
	* tracepoint.c (collect_symbol): Add scope arg and LOC_COMPUTED
	case.
	(add_local_symbols): Update call to collect_symbol.
	(encode_actions): Ditto.
@
text
@d37 1
d115 13
d143 3
d294 199
a1472 3
static char *target_buf;
static long target_buf_size;

d1528 1
d1532 1
d1550 13
d2466 17
@


1.127
log
@2009-12-23  Dmitry Gorbachev  <d.g.gorbachev@@gmail.com>

	PR gdb/11110
	* tracepoint.h (deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Declare extern.
	* tracepoint.c (deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Define.
@
text
@d732 2
a733 1
		long frame_regno, long frame_offset)
d825 44
d895 1
a895 1
			      frame_regno, frame_offset);
d1174 2
a1175 1
				      frame_offset);
@


1.126
log
@	gdb/
	Conditional tracepoints.
	* ax-gdb.h (gen_eval_for_expr): Declare.
	* ax-gdb.c (gen_expr): Generate bytecodes for BINOP_EQUAL
	and other comparisons.
	(gen_eval_for_expr): New function.
	(agent_eval_command): New maintenance command.
	(_initialize_ax_gdb): Define the command.
	* remote.c (struct remote_state): New field cond_tracepoints.
	(PACKET_ConditionalTracepoints): New packet config type.
	(remote_cond_tracepoint_feature): New function.
	(remote_protocol_features): Add ConditionalTracepoints.
	(remote_supports_cond_tracepoints): New function.
	(_initialize_remote): Add ConditionalTracepoints.
	* tracepoint.c (download_tracepoint): Add conditional.
	* NEWS: Mention conditional tracepoints.

	gdb/doc/
	* gdb.texinfo (Tracepoint Conditions): New section.
	(General Query Packets): Describe ConditionalTracepoints.
	(Tracepoint Packets): Describe condition field.
	(Maintenance Commands): Describe maint agent-eval.
	* agentexpr.texi (Using Agent Expressions): Mention eval usage.

	gdb/testsuite/
	* gdb.trace/tracecmd.exp: Add basic test of tracepoint conditions.
@
text
@d72 4
@


1.125
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d36 1
d1315 2
d1323 17
@


1.124
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d22 1
d1672 2
d1682 1
a1682 1
	      print_address (sal.pc, gdb_stdout);
d1694 2
d1702 1
a1702 1
	      print_address (start_pc, gdb_stdout);
d1881 2
a1882 1
	      printf_filtered ("%s", paddress (SYMBOL_VALUE_ADDRESS (sym)));
d1924 2
a1925 1
	      printf_filtered ("%s", paddress (SYMBOL_VALUE_ADDRESS (sym)));
d1929 2
a1930 1
	      printf_filtered ("%s", paddress (BLOCK_START (SYMBOL_BLOCK_VALUE (sym))));
d1940 2
a1941 1
		  printf_filtered ("%s", paddress (SYMBOL_VALUE_ADDRESS (msym)));
@


1.123
log
@	* gdbtypes.h (struct builtin_type): Add internal_fn member.
	* gdbtypes.c (gdbtypes_post_init): Initialize it.
	* value.c (internal_fn_type): Remove.
	(_initialize_values): Do not initialize it.

	* value.c (struct internalvar): Add enum internalvar_kind type and
	kind member.  Restructure union internalvar_data type.  Remove type,
	canonical, and make_value members.
	(init_if_undefined_command): Update for data structure changes.
	(create_internalvar): Likewise.
	(create_internalvar_type_lazy): Likewise.
	(get_internalvar_integer): Likewise.
	(get_internalvar_function): Likewise.
	(set_internalvar_component): Likewise.
	(set_internalvar): Likewise.
	(set_internalvar_integer): Likewise.
	(set_internalvar_function): Likewise.
	(clear_internalvar): Likewise.
	(add_internal_function): Likewise.
	(preserve_one_internalvar): New function.
	(preserve_values): Call it.

	* value.h (value_of_internalvar): Add GDBARCH parameter.
	(internalvar_make_value): Likewise.
	* value.c (value_of_internalvar): Add GDBARCH parameter.  Pass it to
	make_value callback.  Use it to generate per-architecture result value
	types for internal variables with no pre-defined type.  Update for data
	structure changes.
	(show_convenience): Pass architecture to value_of_internalvar.
	* eval.c (evaluate_subexp_standard): Likewise.
	* infrun.c (siginfo_make_value): Add GDBARCH parameter.  Use it
	instead of current frame architecture.  Return per-architecture type.

	* value.h (set_internalvar_string): Add prototype.
	* value.c (set_internalvar_string): New function.
	* tracepoint.c (set_traceframe_context): Use it.
@
text
@d725 1
d758 1
a758 1
      reg = SYMBOL_REGISTER_OPS (sym)->register_number (sym, current_gdbarch);
d766 1
a766 1
	  len > register_size (current_gdbarch, reg))
d823 2
a824 1
add_local_symbols (struct collection_list *collect, CORE_ADDR pc,
d843 2
a844 2
	      collect_symbol (collect, sym, frame_regno, 
			      frame_offset);
d1030 1
a1030 1
  gdbarch_virtual_frame_pointer (current_gdbarch, 
d1057 1
a1057 1
		  for (i = 0; i < gdbarch_num_regs (current_gdbarch); i++)
d1064 1
d1074 1
d1098 1
a1098 1
			i = user_reg_map_name_to_regnum (current_gdbarch,
d1121 1
@


1.122
log
@	* symtab.h: Rename SYMBOL_OPS to SYMBOL_COMPUTED_OPS.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value, symbol_read_needs_frame): Likewise.
	* printcmd.c (address_info): Likewise.
	* dwarf2loc.c (dwarf_expr_frame_base): Likewise.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Likewise.
	* symtab.h: Rename struct symbol_ops to struct symbol_computed_ops.
	* dwarf2loc.h: Likewise.
	* dwarf2loc.c (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Likewise.

	* symtab.h: (struct symbol_register_ops): New struct definition.
	(struct symbol): Make "ops" member a union of symbol_computed_ops and
	symbol_register_ops callback pointers.
	(SYMBOL_REGISTER_OPS): New macro.
	* tracepoint.c: Include "objfiles.h".
	(scope_info, collect_symbol): Use SYMBOL_REGISTER_OPS register_number
	callback to retrieve register numbers.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value): Likewise.
	* printcmd.c (address_info): Likewise.

	* coffread.c (coff_reg_to_regnum): New function.
	(coff_register_funcs): New static variable.
	(process_coff_symbol): Do not call gdbarch_sdb_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* mdebugread.c (mdebug_reg_to_regnum): New function.
	(mdebug_register_funcs): New static variable.
	(parse_symbol): Do not call gdbarch_ecoff_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* stabsread.c (stab_reg_to_regnum): New function.
	(stab_register_funcs): New static variable.
	(define_symbol): Do not call gdbarch_stab_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
@
text
@a230 6
  static struct type *func_string, *file_string;
  static struct type *func_range, *file_range;
  struct value *func_val;
  struct value *file_val;
  int len;

d258 2
a259 14
    {
      len = strlen (SYMBOL_LINKAGE_NAME (traceframe_fun));
      func_range = create_range_type (func_range,
				      builtin_type_int32, 0, len - 1);
      func_string = create_array_type (func_string,
				       builtin_type_true_char, func_range);
      func_val = allocate_value (func_string);
      deprecated_set_value_type (func_val, func_string);
      memcpy (value_contents_raw (func_val),
	      SYMBOL_LINKAGE_NAME (traceframe_fun),
	      len);
      deprecated_set_value_modifiable (func_val, 0);
      set_internalvar (lookup_internalvar ("trace_func"), func_val);
    }
d267 2
a268 14
    {
      len = strlen (traceframe_sal.symtab->filename);
      file_range = create_range_type (file_range,
				      builtin_type_int32, 0, len - 1);
      file_string = create_array_type (file_string,
				       builtin_type_true_char, file_range);
      file_val = allocate_value (file_string);
      deprecated_set_value_type (file_val, file_string);
      memcpy (value_contents_raw (file_val),
	      traceframe_sal.symtab->filename,
	      len);
      deprecated_set_value_modifiable (file_val, 0);
      set_internalvar (lookup_internalvar ("trace_file"), file_val);
    }
@


1.121
log
@	* value.h (struct internalvar): Remove.
	(get_internalvar_integer): Add prototype.
	(set_internalvar_integer): Add prototype.
	(clear_internalvar): Add prototype.

	* value.c (struct internalvar): Move here.  Add type member.  Remove
	endian member.  Add union_internalvar member instead of value member.
	(init_if_undefined_command): Use intvar->type.
	(create_internalvar): Do not initialize value/endian, but type.
	(create_internalvar_type_lazy): Call create_internalvar.
	(value_of_internalvar): Handle host-side internalvar contents.
	(set_internalvar_component): Likewise.
	(set_internalvar): Likewise.
	(get_internalvar_integer): New function.
	(clear_internalvar): Likewise.
	(set_internalvar_integer): Likewise.
	(preserve_values): Handle host-side internalvar contents.

	* breakpoint.c (set_breakpoint_count, set_tracepoint_count): Call
	set_internalvar_integer instead of set_internalvar.
	* findcmd.c (find_command): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* source.c (forward_search_command, reverse_search_command): Likewise.
	* tracepoint.c (set_traceframe_num, set_tracepoint_num,
	set_traceframe_context): Likewise.

	* printcmd.c (x_command): Call clear_internalvar instead of
	set_internalvar.
	* tracepoint.c (set_traceframe_context): Likewise.

	* breakpoint.c (get_number_trailer): Call get_internalvar_integer
	instead of value_of_internalvar.
	* linespec.c (decode_dollar): Likewise.

	* expprint.c (dump_subexp_body_standard): Use internalvar_name
	instead of accessing internalvar private elements.
	* valops.c (value_assign): Copy from original source instead of
	accessing internalvar private elements.
@
text
@d44 1
d787 1
a787 1
      reg = SYMBOL_VALUE (sym);
d1849 2
d1877 2
d1904 9
d1915 1
a1915 2
				 gdbarch_register_name
				 (current_gdbarch, SYMBOL_VALUE (sym)));
d1918 1
a1918 2
				 gdbarch_register_name
				 (current_gdbarch, SYMBOL_VALUE (sym)));
d1933 2
d1936 1
a1936 2
			       gdbarch_register_name
				 (current_gdbarch, SYMBOL_VALUE (sym)));
d1964 1
a1964 1
	      SYMBOL_OPS (sym)->describe_location (sym, gdb_stdout);
@


1.120
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d211 1
a211 2
  set_internalvar (lookup_internalvar ("trace_frame"),
		   value_from_longest (builtin_type_int32, (LONGEST) num));
d219 1
a219 2
  set_internalvar (lookup_internalvar ("tracepoint"),
		   value_from_longest (builtin_type_int32, (LONGEST) num));
d241 3
a243 7
      set_internalvar (lookup_internalvar ("trace_func"),
		       allocate_value (builtin_type_void));
      set_internalvar (lookup_internalvar ("trace_file"),
		       allocate_value (builtin_type_void));
      set_internalvar (lookup_internalvar ("trace_line"),
		       value_from_longest (builtin_type_int32,
					   (LONGEST) - 1));
d254 2
a255 3
  set_internalvar (lookup_internalvar ("trace_line"),
		   value_from_longest (builtin_type_int32,
				       (LONGEST) traceframe_sal.line));
d259 3
a261 4
  if (traceframe_fun == NULL ||
      SYMBOL_LINKAGE_NAME (traceframe_fun) == NULL)
    set_internalvar (lookup_internalvar ("trace_func"),
		     allocate_value (builtin_type_void));
d280 3
a282 4
  if (traceframe_sal.symtab == NULL ||
      traceframe_sal.symtab->filename == NULL)
    set_internalvar (lookup_internalvar ("trace_file"),
		     allocate_value (builtin_type_void));
@


1.119
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d1147 1
a1147 1
		      addr = VALUE_ADDRESS (tempval) + value_offset (tempval);
@


1.118
log
@	* remote.c (compare_sections_command): Don't declare exec_bfd.
	* tracepoint.c: Include "gdbcore.h".
	(remote_set_transparent_ranges): Don't declare exec_bfd.
@
text
@d941 1
a941 1
      (*str_list)[ndx] = savestring (temp_buf, end - temp_buf);
@


1.117
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d43 1
a1250 1
  extern bfd *exec_bfd;
@


1.116
log
@2009-03-30  Stan Shebs  <stan@@codesourcery.com>

	Make tracepoints into a type of breakpoint.
	* breakpoint.h (enum bptype): Add bp_tracepoint.
	(struct breakpoint): Add fields step_count, pass_count, actions.
	(get_tracepoint, get_tracepoint_by_number): Declare.
	(all_tracepoints): Declare.
	* breakpoint.c: Include tracepoint.h, readline.h.
	(ALL_TRACEPOINTS): Move here from tracepoint.c.
	(tracepoint_count): Ditto.
	(should_be_inserted): GDB does not insert tracepoints itself.
	(print_it_typical): Add tracepoint case.
	(bpstat_what): Ditto.
	(print_one_breakpoint_location): Ditto, and add printing for
	pass count, step count, and action list.
	(user_settable_breakpoint): Add tracepoint case.
	(allocate_bp_location): Ditto.
	(set_breakpoint_location_function): Ditto.
	(disable_breakpoints_in_shlibs): Ditto.
	(mention): Ditto.
	(break_command_really): Add argument traceflag, use to choose
	basic breakpoint type.
	(break_command_1): Pass extra argument.
	(set_breakpoint, handle_gnu_v3_exceptions): Ditto.
	(breakpoint_re_set_one): Add tracepoint case.
	(disable_command, enable_command): Ditto.
	(set_tracepoint_count): Move here from tracepoint.c.
	(trace_command): Move here from tracepoint.c and use
	break_command_really.
	(tracepoints_info): Move here from tracepoint.c and call
	breakpoints_info.
	(enable_trace_command): Move here from tracepoint.c and call
	enable_command.
	(disable_trace_command): Move here from tracepoint.c and call
	disable_command.
	(delete_trace_command): Move here from tracepoint.c and call
	delete_breakpoint.
	(trace_pass_command): Move here from tracepoint.c.
	(get_tracepoint_by_number): Ditto.
	(tracepoint_save_command): Ditto.
	(get_tracepoint): New function.
	(all_tracepoints): New function.
	(_initialize_breakpoint): Move tracepoint init from tracepoint.c,
	deprecate "enable trace" and "disable trace" commands.
	* tracepoint.h (struct tracepoint): Remove.
	(tracepoint_chain): Remove decl.
	(deprecated_create_tracepoint_hook): Remove decl.
	(deprecated_delete_tracepoint_hook): Remove decl.
	(deprecated_modify_tracepoint_hook): Remove decl.
	(ALL_TRACEPOINTS, ALL_TRACEPOINTS_SAFE): Remove.
	(free_actions): Update signature.
	(validate_actionline): Update signature.
	(end_actions_pseudocommand): Declare.
	(while_stepping_pseudocommand): Declare.
	* tracepoint.c: Include breakpoint.h.
	(tracepoint_chain, tracepoint_count): Remove.
	(free_actions, make_cleanup_free_actions): Update signature.
	(trace_command, set_raw_tracepoint): Remove.
	(trace_mention): Remove.
	(tracepoints_info): Remove.
	(tracepoint_operation, map_args_over_tracepoints): Remove.
	(get_tracepoint_by_number): Remove.
	(enable_trace_command, disable_trace_command): Remove.
	(delete_trace_command, trace_pass_command): Remove.
	(trace_actions_command, read_actions): Update signature.
	(validate_actionline): Update signature, use bp loc.
	(encode_actions): Ditto.
	(download_tracepoint): New function, body of trace_start_command.
	(trace_start_command): Call it, use all_tracepoints.
	(tracepoint_save_command): Remove.
	(tracepoint_dump_command): Use get_tracepoint.
	(end_actions_pseudocommand): Make globally visible.
	(while_stepping_pseudocommand): Ditto.
	(_initialize_tracepoint): Move command definitions to breakpoint.c.

	doc/
	* gdb.texinfo (Tracepoints): Describe tracepoints as a
	special case of breakpoints.
	(Enable and Disable Tracepoints): Mention deprecation.
	(Listing Tracepoints): Update description and example.

	testsuite/
	* gdb.trace/actions.exp: Update to match new info trace format.
	* gdb.trace/deltrace.exp: Ditto.
	* gdb.trace/infotrace.exp: Ditto.
	* gdb.trace/passcount.exp: Ditto.
	* gdb.trace/save-trace.exp: Ditto.
	* gdb.trace/while-stepping.exp: Ditto.
	* gdb.trace/tracecmd.exp: Ditto, plus don't allow pending option.

	gdbtk/
	* generic/gdbtk-bp.c (gdb_actions_command): Update to handle
	tracepoints as breakpoints.
	(gdb_get_tracepoint_info): Ditto, plus use get_tracepoint and
	breakpoint locations.
	(tracepoint_exists): Ditto, plus use all_tracepoints.
@
text
@d227 1
a227 1
set_traceframe_context (CORE_ADDR trace_pc)
d229 2
d237 1
a237 1
  if (trace_pc == -1)		/* Cease debugging any trace buffers.  */
d253 1
d1325 1
a1325 1
      set_traceframe_context (-1);
d1453 1
a1453 2
  CORE_ADDR old_frame_addr;
  struct symbol *old_func;
d1456 1
a1456 2
  old_frame_addr = get_frame_base (get_current_frame ());
  old_func = find_pc_function (read_pc ());
d1521 1
a1521 1
    set_traceframe_context (-1);
d1523 1
a1523 1
    set_traceframe_context (read_pc ());
d1533 1
a1533 1
         new source line.
d1535 2
a1536 10
         This determination is made by checking (1) whether the
         current function has changed, and (2) whether the current FP
         has changed.  Hack: if the FP wasn't collected, either at the
         current or the previous frame, assume that the FP has NOT
         changed.  */

      if (old_func == find_pc_function (read_pc ()) &&
	  (old_frame_addr == 0 ||
	   get_frame_base (get_current_frame ()) == 0 ||
	   old_frame_addr == get_frame_base (get_current_frame ())))
d1631 1
a1631 1
	pc = read_pc ();	/* default is current pc */
@


1.115
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@d32 1
a105 6
/* Chain of all tracepoints defined.  */
struct tracepoint *tracepoint_chain;

/* Number of last tracepoint made.  */
static int tracepoint_count;

a121 6
static void trace_command (char *, int);
static void tracepoints_info (char *, int);
static void delete_trace_command (char *, int);
static void enable_trace_command (char *, int);
static void disable_trace_command (char *, int);
static void trace_pass_command (char *, int);
a135 1
static void trace_mention (struct tracepoint *);
d142 1
a142 1
static struct cleanup *make_cleanup_free_actions (struct tracepoint *t);
a204 9
/* Set tracepoint count to NUM.  */
static void
set_tracepoint_count (int num)
{
  tracepoint_count = num;
  set_internalvar (lookup_internalvar ("tpnum"),
		   value_from_longest (builtin_type_int32, (LONGEST) num));
}

a304 426
/* Low level routine to set a tracepoint.
   Returns the tracepoint object so caller can set other things.
   Does not set the tracepoint number!
   Does not print anything.

   ==> This routine should not be called if there is a chance of later
   error(); otherwise it leaves a bogus tracepoint on the chain.
   Validate your arguments BEFORE calling this routine!  */

static struct tracepoint *
set_raw_tracepoint (struct symtab_and_line sal)
{
  struct tracepoint *t, *tc;
  struct cleanup *old_chain;

  t = (struct tracepoint *) xmalloc (sizeof (struct tracepoint));
  old_chain = make_cleanup (xfree, t);
  memset (t, 0, sizeof (*t));
  t->address = sal.pc;
  if (sal.symtab == NULL)
    t->source_file = NULL;
  else
    t->source_file = savestring (sal.symtab->filename,
				 strlen (sal.symtab->filename));

  t->section = sal.section;
  t->language = current_language->la_language;
  t->input_radix = input_radix;
  t->line_number = sal.line;
  t->enabled_p = 1;
  t->next = 0;
  t->step_count = 0;
  t->pass_count = 0;
  t->addr_string = NULL;

  /* Add this tracepoint to the end of the chain
     so that a list of tracepoints will come out in order
     of increasing numbers.  */

  tc = tracepoint_chain;
  if (tc == 0)
    tracepoint_chain = t;
  else
    {
      while (tc->next)
	tc = tc->next;
      tc->next = t;
    }
  discard_cleanups (old_chain);
  return t;
}

/* Set a tracepoint according to ARG (function, linenum or *address).  */
static void
trace_command (char *arg, int from_tty)
{
  char **canonical = (char **) NULL;
  struct symtabs_and_lines sals;
  struct symtab_and_line sal;
  struct tracepoint *t;
  char *addr_start = 0, *addr_end = 0;
  int i;

  if (!arg || !*arg)
    error (_("trace command requires an argument"));

  if (from_tty && info_verbose)
    printf_filtered ("TRACE %s\n", arg);

  addr_start = arg;
  sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 
			0, &canonical, NULL);
  addr_end = arg;
  if (!sals.nelts)
    return;	/* ??? Presumably decode_line_1 has already warned?  */

  /* Resolve all line numbers to PC's */
  for (i = 0; i < sals.nelts; i++)
    resolve_sal_pc (&sals.sals[i]);

  /* Now set all the tracepoints.  */
  for (i = 0; i < sals.nelts; i++)
    {
      sal = sals.sals[i];

      t = set_raw_tracepoint (sal);
      set_tracepoint_count (tracepoint_count + 1);
      t->number = tracepoint_count;

      /* If a canonical line spec is needed use that instead of the
         command string.  */
      if (canonical != (char **) NULL && canonical[i] != NULL)
	t->addr_string = canonical[i];
      else if (addr_start)
	t->addr_string = savestring (addr_start, addr_end - addr_start);

      trace_mention (t);
    }

  if (sals.nelts > 1)
    {
      printf_filtered ("Multiple tracepoints were set.\n");
      printf_filtered ("Use 'delete trace' to delete unwanted tracepoints.\n");
    }
}

/* Tell the user we have just set a tracepoint TP.  */

static void
trace_mention (struct tracepoint *tp)
{
  struct value_print_options opts;
  printf_filtered ("Tracepoint %d", tp->number);

  get_user_print_options (&opts);
  if (opts.addressprint || (tp->source_file == NULL))
    {
      printf_filtered (" at ");
      printf_filtered ("%s", paddress (tp->address));
    }
  if (tp->source_file)
    printf_filtered (": file %s, line %d.",
		     tp->source_file, tp->line_number);

  printf_filtered ("\n");
}

/* Print information on tracepoint number TPNUM_EXP, or all if
   omitted.  */

static void
tracepoints_info (char *tpnum_exp, int from_tty)
{
  struct tracepoint *t;
  struct action_line *action;
  int found_a_tracepoint = 0;
  char wrap_indent[80];
  struct symbol *sym;
  int tpnum = -1;

  if (tpnum_exp)
    tpnum = parse_and_eval_long (tpnum_exp);

  ALL_TRACEPOINTS (t)
    if (tpnum == -1 || tpnum == t->number)
    {
      struct value_print_options opts;
      get_user_print_options (&opts);
      if (!found_a_tracepoint++)
	{
	  printf_filtered ("Num Enb ");
	  if (opts.addressprint)
	    {
	      if (gdbarch_addr_bit (current_gdbarch) <= 32)
		printf_filtered ("Address    ");
	      else
		printf_filtered ("Address            ");
	    }
	  printf_filtered ("PassC StepC What\n");
	}
      strcpy (wrap_indent, "                           ");
      if (opts.addressprint)
	{
	  if (gdbarch_addr_bit (current_gdbarch) <= 32)
	    strcat (wrap_indent, "           ");
	  else
	    strcat (wrap_indent, "                   ");
	}

      printf_filtered ("%-3d %-3s ", t->number,
		       t->enabled_p ? "y" : "n");
      if (opts.addressprint)
	{
	  char *tmp;

	  if (gdbarch_addr_bit (current_gdbarch) <= 32)
	    tmp = hex_string_custom (t->address & (CORE_ADDR) 0xffffffff, 
				     8);
	  else
	    tmp = hex_string_custom (t->address, 16);

	  printf_filtered ("%s ", tmp);
	}
      printf_filtered ("%-5d %-5ld ", t->pass_count, t->step_count);

      if (t->source_file)
	{
	  sym = find_pc_sect_function (t->address, t->section);
	  if (sym)
	    {
	      fputs_filtered ("in ", gdb_stdout);
	      fputs_filtered (SYMBOL_PRINT_NAME (sym), gdb_stdout);
	      wrap_here (wrap_indent);
	      fputs_filtered (" at ", gdb_stdout);
	    }
	  fputs_filtered (t->source_file, gdb_stdout);
	  printf_filtered (":%d", t->line_number);
	}
      else
	print_address_symbolic (t->address, gdb_stdout, demangle, " ");

      printf_filtered ("\n");
      if (t->actions)
	{
	  printf_filtered ("  Actions for tracepoint %d: \n", t->number);
	  for (action = t->actions; action; action = action->next)
	    {
	      printf_filtered ("\t%s\n", action->action);
	    }
	}
    }
  if (!found_a_tracepoint)
    {
      if (tpnum == -1)
	printf_filtered ("No tracepoints.\n");
      else
	printf_filtered ("No tracepoint number %d.\n", tpnum);
    }
}

/* Optimization: the code to parse an enable, disable, or delete TP
   command is virtually identical except for whether it performs an
   enable, disable, or delete.  Therefore I've combined them into one
   function with an opcode.  */
enum tracepoint_opcode
{
  enable_op,
  disable_op,
  delete_op
};

/* This function implements enable, disable and delete commands.  */
static void
tracepoint_operation (struct tracepoint *t, int from_tty,
		      enum tracepoint_opcode opcode)
{
  struct tracepoint *t2;

  if (t == NULL)	/* no tracepoint operand */
    return;

  switch (opcode)
    {
    case enable_op:
      t->enabled_p = 1;
      observer_notify_tracepoint_modified (t->number);
      break;
    case disable_op:
      t->enabled_p = 0;
      observer_notify_tracepoint_modified (t->number);
      break;
    case delete_op:
      if (tracepoint_chain == t)
	tracepoint_chain = t->next;

      ALL_TRACEPOINTS (t2)
	if (t2->next == t)
	{
	  t2->next = t->next;
	  break;
	}

      observer_notify_tracepoint_deleted (t->number);

      if (t->addr_string)
	xfree (t->addr_string);
      if (t->source_file)
	xfree (t->source_file);
      if (t->actions)
	free_actions (t);

      xfree (t);
      break;
    }
}

/* Utility: parse a tracepoint number and look it up in the list.
   If MULTI_P is true, there might be a range of tracepoints in ARG.
   if OPTIONAL_P is true, then if the argument is missing, the most
   recent tracepoint (tracepoint_count) is returned.  */
struct tracepoint *
get_tracepoint_by_number (char **arg, int multi_p, int optional_p)
{
  struct tracepoint *t;
  int tpnum;
  char *instring = arg == NULL ? NULL : *arg;

  if (arg == NULL || *arg == NULL || ! **arg)
    {
      if (optional_p)
	tpnum = tracepoint_count;
      else
	error_no_arg (_("tracepoint number"));
    }
  else
    tpnum = multi_p ? get_number_or_range (arg) : get_number (arg);

  if (tpnum <= 0)
    {
      if (instring && *instring)
	printf_filtered ("bad tracepoint number at or near '%s'\n", 
			 instring);
      else
	printf_filtered ("Tracepoint argument missing and no previous tracepoint\n");
      return NULL;
    }

  ALL_TRACEPOINTS (t)
    if (t->number == tpnum)
    {
      return t;
    }

  /* FIXME: if we are in the middle of a range we don't want to give
     a message.  The current interface to get_number_or_range doesn't
     allow us to discover this.  */
  printf_unfiltered ("No tracepoint number %d.\n", tpnum);
  return NULL;
}

/* Utility: 
   parse a list of tracepoint numbers, and call a func for each.  */
static void
map_args_over_tracepoints (char *args, int from_tty,
			   enum tracepoint_opcode opcode)
{
  struct tracepoint *t, *tmp;

  if (args == 0 || *args == 0)	/* do them all */
    ALL_TRACEPOINTS_SAFE (t, tmp)
      tracepoint_operation (t, from_tty, opcode);
  else
    while (*args)
      {
	QUIT;		/* Give user option to bail out with ^C.  */
	t = get_tracepoint_by_number (&args, 1, 0);
	tracepoint_operation (t, from_tty, opcode);
	while (*args == ' ' || *args == '\t')
	  args++;
      }
}

/* The 'enable trace' command enables tracepoints.  
   Not supported by all targets.  */
static void
enable_trace_command (char *args, int from_tty)
{
  dont_repeat ();
  map_args_over_tracepoints (args, from_tty, enable_op);
}

/* The 'disable trace' command disables tracepoints.  
   Not supported by all targets.  */
static void
disable_trace_command (char *args, int from_tty)
{
  dont_repeat ();
  map_args_over_tracepoints (args, from_tty, disable_op);
}

/* Remove a tracepoint (or all if no argument) */
static void
delete_trace_command (char *args, int from_tty)
{
  dont_repeat ();
  if (!args || !*args)		/* No args implies all tracepoints; */
    if (from_tty)		/* confirm only if from_tty...  */
      if (tracepoint_chain)	/* and if there are tracepoints to
				   delete!  */
	if (!query (_("Delete all tracepoints? ")))
	  return;

  map_args_over_tracepoints (args, from_tty, delete_op);
}

/* Set passcount for tracepoint.

   First command argument is passcount, second is tracepoint number.
   If tracepoint number omitted, apply to most recently defined.
   Also accepts special argument "all".  */

static void
trace_pass_command (char *args, int from_tty)
{
  struct tracepoint *t1 = (struct tracepoint *) -1, *t2;
  unsigned int count;
  int all = 0;

  if (args == 0 || *args == 0)
    error (_("passcount command requires an argument (count + optional TP num)"));

  count = strtoul (args, &args, 10);	/* Count comes first, then TP num. */

  while (*args && isspace ((int) *args))
    args++;

  if (*args && strncasecmp (args, "all", 3) == 0)
    {
      args += 3;			/* Skip special argument "all".  */
      all = 1;
      if (*args)
	error (_("Junk at end of arguments."));
    }
  else
    t1 = get_tracepoint_by_number (&args, 1, 1);

  do
    {
      if (t1)
	{
	  ALL_TRACEPOINTS (t2)
	    if (t1 == (struct tracepoint *) -1 || t1 == t2)
	      {
		t2->pass_count = count;
		observer_notify_tracepoint_modified (t2->number);
		if (from_tty)
		  printf_filtered ("Setting tracepoint %d's passcount to %d\n",
				   t2->number, count);
	      }
	  if (! all && *args)
	    t1 = get_tracepoint_by_number (&args, 1, 0);
	}
    }
  while (*args);
}

d308 1
a308 1
static void read_actions (struct tracepoint *);
d319 1
a319 1
static void
d325 1
a325 1
static void
d341 1
a341 1
  struct tracepoint *t;
d372 1
a372 1
read_actions (struct tracepoint *t)
d476 1
a476 1
validate_actionline (char **line, struct tracepoint *t)
d527 1
a527 1
	  exp = parse_exp_1 (&p, block_for_pc (t->address), 1);
d550 1
a550 1
	  aexpr = gen_trace_for_expr (t->address, exp);
d600 1
a600 1
free_actions (struct tracepoint *t)
d621 1
a621 1
make_cleanup_free_actions (struct tracepoint *t)
d1039 1
a1039 1
encode_actions (struct tracepoint *t, char ***tdp_actions,
d1063 1
a1063 1
				 t->address, &frame_reg, &frame_offset);
d1096 1
a1096 1
				     t->address,
d1105 1
a1105 1
				     t->address,
d1119 1
a1119 1
				     block_for_pc (t->address), 1);
d1156 1
a1156 1
		      aexpr = gen_trace_for_expr (t->address, exp);
d1288 2
d1293 3
a1295 6
  struct tracepoint *t;
  char buf[2048];
  char **tdp_actions;
  char **stepping_actions;
  int ndx;
  struct cleanup *old_chain = NULL;
d1306 6
a1311 24
      ALL_TRACEPOINTS (t)
      {
	char tmp[40];

	sprintf_vma (tmp, t->address);
	sprintf (buf, "QTDP:%x:%s:%c:%lx:%x", t->number, 
		 tmp, /* address */
		 t->enabled_p ? 'E' : 'D',
		 t->step_count, t->pass_count);

	if (t->actions)
	  strcat (buf, "-");
	putpkt (buf);
	remote_get_noisy_reply (&target_buf, &target_buf_size);
	if (strcmp (target_buf, "OK"))
	  error (_("Target does not support tracepoints."));

	if (t->actions)
	  {
	    encode_actions (t, &tdp_actions, &stepping_actions);
	    old_chain = make_cleanup (free_actions_list_cleanup_wrapper,
				      tdp_actions);
	    (void) make_cleanup (free_actions_list_cleanup_wrapper,
				 stepping_actions);
a1312 39
	    /* do_single_steps (t); */
	    if (tdp_actions)
	      {
		for (ndx = 0; tdp_actions[ndx]; ndx++)
		  {
		    QUIT;	/* allow user to bail out with ^C */
		    sprintf (buf, "QTDP:-%x:%s:%s%c",
			     t->number, tmp, /* address */
			     tdp_actions[ndx],
			     ((tdp_actions[ndx + 1] || stepping_actions)
			      ? '-' : 0));
		    putpkt (buf);
		    remote_get_noisy_reply (&target_buf,
					    &target_buf_size);
		    if (strcmp (target_buf, "OK"))
		      error (_("Error on target while setting tracepoints."));
		  }
	      }
	    if (stepping_actions)
	      {
		for (ndx = 0; stepping_actions[ndx]; ndx++)
		  {
		    QUIT;	/* allow user to bail out with ^C */
		    sprintf (buf, "QTDP:-%x:%s:%s%s%s",
			     t->number, tmp, /* address */
			     ((ndx == 0) ? "S" : ""),
			     stepping_actions[ndx],
			     (stepping_actions[ndx + 1] ? "-" : ""));
		    putpkt (buf);
		    remote_get_noisy_reply (&target_buf,
					    &target_buf_size);
		    if (strcmp (target_buf, "OK"))
		      error (_("Error on target while setting tracepoints."));
		  }
	      }

	    do_cleanups (old_chain);
	  }
      }
d1332 71
a1852 74
/* save-tracepoints command */
static void
tracepoint_save_command (char *args, int from_tty)
{
  struct tracepoint *tp;
  struct action_line *line;
  FILE *fp;
  char *i1 = "    ", *i2 = "      ";
  char *indent, *actionline, *pathname;
  char tmp[40];
  struct cleanup *cleanup;

  if (args == 0 || *args == 0)
    error (_("Argument required (file name in which to save tracepoints)"));

  if (tracepoint_chain == 0)
    {
      warning (_("save-tracepoints: no tracepoints to save."));
      return;
    }

  pathname = tilde_expand (args);
  cleanup = make_cleanup (xfree, pathname);
  if (!(fp = fopen (pathname, "w")))
    error (_("Unable to open file '%s' for saving tracepoints (%s)"),
	   args, safe_strerror (errno));
  make_cleanup_fclose (fp);
  
  ALL_TRACEPOINTS (tp)
  {
    if (tp->addr_string)
      fprintf (fp, "trace %s\n", tp->addr_string);
    else
      {
	sprintf_vma (tmp, tp->address);
	fprintf (fp, "trace *0x%s\n", tmp);
      }

    if (tp->pass_count)
      fprintf (fp, "  passcount %d\n", tp->pass_count);

    if (tp->actions)
      {
	fprintf (fp, "  actions\n");
	indent = i1;
	for (line = tp->actions; line; line = line->next)
	  {
	    struct cmd_list_element *cmd;

	    QUIT;		/* allow user to bail out with ^C */
	    actionline = line->action;
	    while (isspace ((int) *actionline))
	      actionline++;

	    fprintf (fp, "%s%s\n", indent, actionline);
	    if (*actionline != '#')	/* skip for comment lines */
	      {
		cmd = lookup_cmd (&actionline, cmdlist, "", -1, 1);
		if (cmd == 0)
		  error (_("Bad action list item: %s"), actionline);
		if (cmd_cfunc_eq (cmd, while_stepping_pseudocommand))
		  indent = i2;
		else if (cmd_cfunc_eq (cmd, end_actions_pseudocommand))
		  indent = i1;
	      }
	  }
      }
  }
  do_cleanups (cleanup);
  if (from_tty)
    printf_filtered ("Tracepoints saved to file '%s'.\n", args);
  return;
}

d1998 1
a1998 1
  struct tracepoint *t;
d2017 1
a2017 3
  ALL_TRACEPOINTS (t)
    if (t->number == tracepoint_number)
    break;
d2035 1
a2035 1
  stepping_frame = (t->address != (regcache_read_pc (regcache)
a2146 2
  tracepoint_chain = 0;
  tracepoint_count = 0;
a2183 12
  add_info ("tracepoints", tracepoints_info, _("\
Status of tracepoints, or tracepoint number NUMBER.\n\
Convenience variable \"$tpnum\" contains the number of the\n\
last tracepoint set."));

  add_info_alias ("tp", "tracepoints", 1);

  c = add_com ("save-tracepoints", class_trace, tracepoint_save_command, _("\
Save current tracepoint definitions as a script.\n\
Use the 'source' command in another debug session to restore them."));
  set_cmd_completer (c, filename_completer);

a2240 6
  add_com ("passcount", class_trace, trace_pass_command, _("\
Set the passcount for a tracepoint.\n\
The trace will end when the tracepoint has been passed 'count' times.\n\
Usage: passcount COUNT TPNUM, where TPNUM may also be \"all\";\n\
if TPNUM is omitted, passcount refers to the last tracepoint defined."));

a2274 31
  add_cmd ("tracepoints", class_trace, delete_trace_command, _("\
Delete specified tracepoints.\n\
Arguments are tracepoint numbers, separated by spaces.\n\
No argument means delete all tracepoints."),
	   &deletelist);

  add_cmd ("tracepoints", class_trace, disable_trace_command, _("\
Disable specified tracepoints.\n\
Arguments are tracepoint numbers, separated by spaces.\n\
No argument means disable all tracepoints."),
	   &disablelist);

  add_cmd ("tracepoints", class_trace, enable_trace_command, _("\
Enable specified tracepoints.\n\
Arguments are tracepoint numbers, separated by spaces.\n\
No argument means enable all tracepoints."),
	   &enablelist);

  c = add_com ("trace", class_trace, trace_command, _("\
Set a tracepoint at a specified line or function or address.\n\
Argument may be a line number, function name, or '*' plus an address.\n\
For a line number or function, trace at the start of its code.\n\
If an address is specified, trace at that exact address.\n\n\
Do \"help tracepoints\" for info on other tracepoint commands."));
  set_cmd_completer (c, location_completer);

  add_com_alias ("tp", "trace", class_alias, 0);
  add_com_alias ("tr", "trace", class_alias, 1);
  add_com_alias ("tra", "trace", class_alias, 1);
  add_com_alias ("trac", "trace", class_alias, 1);

@


1.114
log
@        Updated copyright notices for most files.
@
text
@d695 1
a695 1
	if (!query ("Delete all tracepoints? "))
@


1.113
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d4 1
a4 1
   2007, 2008 Free Software Foundation, Inc.
@


1.112
log
@	* cli/cli-script.c (do_fclose_cleanup): Remove.
	(script_from_file): Use make_cleanup_fclose.
	* xml-tdesc.c (do_cleanup_fclose): Remove.
	(fetch_xml_from_file): Use make_cleanup_fclose.
	* tracepoint.c (tracepoint_save_command): Use
	make_cleanup_fclose.  Always free pathname.
	* source.c (print_source_lines_base): Use make_cleanup_fclose.
	* remote.c (fclose_cleanup): Remove.
	(remote_file_put): Use make_cleanup_fclose.
	(remote_file_get): Likewise.
	* linux-nat.c (linux_nat_find_memory_regions): Use
	make_cleanup_fclose.
	(linux_nat_info_proc_cmd): Likewise.
	(linux_proc_pending_signals): Likewise.
	* fbsd-nat.c (fbsd_find_memory_regions): Use make_cleanup_fclose.
	Free file name.
	* cli/cli-dump.c (do_fclose_cleanup): Remove.
	(make_cleanup_fclose): Remove.
	* defs.h (make_cleanup_fclose): Declare.
	* utils.c (do_fclose_cleanup): New function.
	(make_cleanup_fclose): Likewise.
@
text
@d41 1
a70 1
extern int addressprint;	/* Print machine addresses? */
d437 1
d440 2
a441 1
  if (addressprint || (tp->source_file == NULL))
d472 2
a473 2
      extern int addressprint;	/* Print machine addresses?  */

d477 1
a477 1
	  if (addressprint)
d487 1
a487 1
      if (addressprint)
d497 1
a497 1
      if (addressprint)
@


1.111
log
@	* varobj.c (varobj_set_display_format): Use xfree.
	* tracepoint.c (stringify_collection_list): Use xfree.
	* remote-fileio.c (remote_fileio_reset): Use xfree.
	* mipsread.c (read_alphacoff_dynamic_symtab): Use xfree.
	* dfp.c (decimal_from_floating): Use xfree, xstrprintf.  Don't use
	asprintf.
	* cp-support.c (mangled_name_to_comp): Use xfree.
@
text
@d2295 1
d2307 1
d2311 1
a2311 1
  xfree (pathname);
d2353 1
a2353 1
  fclose (fp);
@


1.110
log
@	* defs.h (struct gdbarch): Add forward declaration.
	(set_next_address): Add GDBARCH argument.
	* printcmd.c (set_next_address): Use it to find pointer type.
	* breakpoint.c (breakpoint_1): Update call.
	* source.c (line_info): Likewise.
	* findcmd.c (find_command): Use current_gdbarch to find pointer type.

	* breakpoint.c (set_breakpoint_count): Use platform-neutral
	types for internal variable values.
	* infrun.c (handle_inferior_event): Likewise.
	* source.c (forward_search_command, reverse_search_command): Likewise.
	* tracepoint.c (set_tracepoint_count, set_traceframe_num,
	set_tracepoint_num, set_traceframe_context): Likewise.
@
text
@d1455 1
a1455 1
      free (str_list);
@


1.109
log
@	* frame.h (frame_map_regnum_to_name): Remove prototype.
	(frame_map_name_to_regnum): Remove prototype.
	* frame.c (frame_map_regnum_to_name): Remove.
	(frame_map_name_to_regnum): Remove.
	(frame_unwind_register_value): Use user_reg_map_regnum_to_name
	instead of frame_map_regnum_to_name.
	* ax-gdb.c: Include "user-regs.h".
	(gen_expr): Use user_reg_map_name_to_regnum instead of
	frame_map_name_to_regnum.
	* eval.c:  Include "user-regs.h".
	(evaluate_subexp_standard): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* infcmd.c (registers_info): Likewise.
	* parse.c: Include "user-regs.h".
	(write_dollar_variable): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* tracepoint.c: Include "user-regs.h".
	(encode_actions): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* valops.c: Include "user-regs.h".
	(value_fetch_lazy): Use user_reg_map_regnum_to_name instead
	of frame_map_regnum_to_name.
@
text
@d223 1
a223 1
		   value_from_longest (builtin_type_int, (LONGEST) num));
d232 1
a232 1
		   value_from_longest (builtin_type_int, (LONGEST) num));
d241 1
a241 2
		   value_from_longest (builtin_type_int, 
				       (LONGEST) num));
a253 1
  static struct type *charstar;
a255 3
  if (charstar == (struct type *) NULL)
    charstar = lookup_pointer_type (builtin_type_char);

d262 1
a262 1
		       value_from_pointer (charstar, (LONGEST) 0));
d264 1
a264 1
		       value_from_pointer (charstar, (LONGEST) 0));
d266 1
a266 1
		       value_from_longest (builtin_type_int, 
d278 1
a278 1
		   value_from_longest (builtin_type_int,
d286 1
a286 1
		     value_from_pointer (charstar, (LONGEST) 0));
d291 1
a291 1
				      builtin_type_int, 0, len - 1);
d293 1
a293 1
				       builtin_type_char, func_range);
d308 1
a308 1
		     value_from_pointer (charstar, (LONGEST) 0));
d313 1
a313 1
				      builtin_type_int, 0, len - 1);
d315 1
a315 1
				       builtin_type_char, file_range);
@


1.108
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d40 1
d1578 2
a1579 2
			i = frame_map_name_to_regnum (deprecated_safe_get_selected_frame (),
						      name, strlen (name));
@


1.107
log
@gdb:
	* tui/tui-hooks.c: Include observer.h.
	(tui_event_default, tui_old_event_hooks, tui_event_hooks):
	Remove.
	(tui_bp_created_observer, tui_bp_deleted_observer,
	tui_bp_modified_observer): New globals.
	(tui_install_hooks): Use observers, not events.
	(tui_remove_hooks): Likewise.
	* mi/mi-cmd-break.c: Include observer.h, not gdb-events.h.
	(mi_breakpoint_observers_installed, mi_can_breakpoint_notify): New
	globals.
	(breakpoint_notify): Check mi_can_breakpoint_notify.
	(breakpoint_hooks): Remove.
	(mi_cmd_break_insert): Attach observers.  Don't use events.
	* tracepoint.c: Include observer.h, not gdb-events.h.
	(tracepoint_operation, trace_pass_command): Notify observer.
	* interps.c: Don't include gdb-events.h.
	(clear_interpreter_hooks): Don't call clear_gdb_event_hooks.
	* gdbarch.c: Rebuild.
	* gdbarch.sh: Emit include for observer.h, not gdb-events.h.
	(deprecated_current_gdbarch_select_hack): Notify observer.
	* breakpoint.h: Don't include gdb-events.h.
	* breakpoint.c: Don't include gdb-events.h.
	(condition_command): Notify observer.
	(commands_command): Likewise.
	(commands_from_control_command): Likewise.
	(mention, delete_breakpoint, set_ignore_count): Likewise.
	(disable_breakpoint, do_enable_breakpoint): Likewise.
	* Makefile.in (gdb_events_h): Remove.
	(breakpoint_h): Update.
	(COMMON_OBS): Remove gdb-events.o.
	(gdb-events.o): Remove.
	(breakpoint.o, gdbarch.o, interps.o, tracepoint.o, gdbtk-bp.o,
	gdbtk-hooks.o, mi-cmd-break.o, tui-hooks.o): Update.
	* gdb-events.c: Remove.
	* gdb-events.h: Remove.
	* gdb-events.sh: Remove.
gdb/doc:
	* observer.texi (GDB Observers): Document new observers:
	breakpoint_created, breakpoint_deleted, breakpoint_modified,
	tracepoint_created, tracepoint_deleted, tracepoint_modified,
	architecture_changed.
gdb/gdbtk:
	* generic/gdbtk-hooks.c: Include observer.h, not gdb-events.h.
	(gdbtk_add_hooks): Use observers, not events.
	(gdbtk_architecture_changed): Add argument, for observer.
	* generic/gdbtk-bp.c: Include observer.h.
	(gdb_set_bp): Notify observer.
	(gdb_set_bp_addr): Likewise.
@
text
@d288 1
a288 1
      DEPRECATED_SYMBOL_NAME (traceframe_fun) == NULL)
d293 1
a293 1
      len = strlen (DEPRECATED_SYMBOL_NAME (traceframe_fun));
d301 1
a301 1
	      DEPRECATED_SYMBOL_NAME (traceframe_fun),
d984 1
a984 1
			   DEPRECATED_SYMBOL_NAME (exp->elts[2].symbol),
d991 1
a991 1
			   DEPRECATED_SYMBOL_NAME (exp->elts[2].symbol));
d1219 1
a1219 1
		       DEPRECATED_SYMBOL_NAME (sym), 
d1224 1
a1224 1
		       DEPRECATED_SYMBOL_NAME (sym), SYMBOL_VALUE (sym));
d1234 1
a1234 1
			   DEPRECATED_SYMBOL_NAME (sym), len, 
d1243 1
a1243 1
			 DEPRECATED_SYMBOL_NAME (sym));
d1254 1
a1254 1
		       DEPRECATED_SYMBOL_NAME (sym));
d1262 1
a1262 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1274 1
a1274 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1286 1
a1286 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1294 1
a1294 1
		       DEPRECATED_SYMBOL_NAME (sym));
d1298 1
a1298 1
		       DEPRECATED_SYMBOL_NAME (sym));
d2394 1
a2394 1
	  symname = DEPRECATED_SYMBOL_NAME (sym);
d2461 1
a2461 1
	      msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), 
@


1.106
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@a36 1
#include "gdb-events.h"
d39 1
d573 1
a573 1
      tracepoint_modify_event (t->number);
d577 1
a577 1
      tracepoint_modify_event (t->number);
d590 1
a590 1
      tracepoint_delete_event (t->number);
d742 1
a742 1
		tracepoint_modify_event (t2->number);
@


1.105
log
@	* symtab.h (enum address_class): Remove LOC_BASEREG and
	LOC_BASEREG_ARG.
	(struct symbol): Remove "basereg" member of "aux_value" union.
	(SYMBOL_BASEREG): Remove.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_BASEREG
	or LOC_BASEREG_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsym.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals): Likewise.
	(print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a1239 1
    case LOC_REGPARM:
d1319 3
a1321 1
	  switch (SYMBOL_CLASS (sym))
d1323 3
a1325 23
	    default:
	      warning (_("don't know how to trace local symbol %s"), 
		       DEPRECATED_SYMBOL_NAME (sym));
	    case LOC_LOCAL:
	    case LOC_STATIC:
	    case LOC_REGISTER:
	      if (type == 'L')	/* collecting Locals */
		{
		  count++;
		  collect_symbol (collect, sym, frame_regno, 
				  frame_offset);
		}
	      break;
	    case LOC_ARG:
	    case LOC_REF_ARG:
	    case LOC_REGPARM:
	    case LOC_REGPARM_ADDR:
	      if (type == 'A')	/* collecting Arguments */
		{
		  count++;
		  collect_symbol (collect, sym, frame_regno, 
				  frame_offset);
		}
d2423 7
a2429 2
	      printf_filtered ("a local variable in register $%s",
			       gdbarch_register_name
a2443 5
	    case LOC_REGPARM:
	      printf_filtered ("an argument in register $%s",
			       gdbarch_register_name
				 (current_gdbarch, SYMBOL_VALUE (sym)));
	      break;
a2474 1
	    case LOC_COMPUTED_ARG:
@


1.104
log
@	* symtab.h (enum address_class): Remove LOC_LOCAL_ARG.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_LOCAL_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsyms.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a1292 13
    case LOC_BASEREG:
    case LOC_BASEREG_ARG:
      reg = SYMBOL_BASEREG (sym);
      offset = SYMBOL_VALUE (sym);
      if (info_verbose)
	{
	  printf_filtered ("LOC_BASEREG %s: collect %ld bytes at offset ",
			   DEPRECATED_SYMBOL_NAME (sym), len);
	  printf_vma (offset);
	  printf_filtered (" from basereg %d\n", reg);
	}
      add_memrange (collect, reg, offset, len);
      break;
a1327 1
	    case LOC_BASEREG:
a1338 1
	    case LOC_BASEREG_ARG:
a2478 12
	    case LOC_BASEREG:
	      printf_filtered ("a variable at offset %ld from register $%s",
			       SYMBOL_VALUE (sym),
			       gdbarch_register_name
				 (current_gdbarch, SYMBOL_BASEREG (sym)));
	      break;
	    case LOC_BASEREG_ARG:
	      printf_filtered ("an argument at offset %ld from register $%s",
			       SYMBOL_VALUE (sym),
			       gdbarch_register_name
				 (current_gdbarch, SYMBOL_BASEREG (sym)));
	      break;
@


1.103
log
@	* symtab.h (enum address_class): Remove LOC_INDIRECT and
	LOC_HP_THREAD_LOCAL_STATIC.

	* findvar.c (symbol_read_needs_frame, read_var_value): Do not
	handle LOC_INDIRECT or LOC_HP_THREAD_LOCAL_STATIC.
	(read_var_value): Likewise.
	* buildsym.c (finish_block): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (scope_info): Likewise.
@
text
@a1281 1
    case LOC_LOCAL_ARG:
a1349 1
	    case LOC_LOCAL_ARG:
a2461 1
	    case LOC_LOCAL_ARG:
@


1.102
log
@	* inferior.h (read_pc_pid, write_pc_pid): Remove.
	* regcache.h (regcache_read_pc, regcache_write_pc): Add prototypes.

	* regcache.c (read_pc_pid): Remove, replace by ...
	(regcache_read_pc): ... this function.
	(write_pc_pid): Remove, replace by ...
	(regcache_write_pc): ... this function.
	(read_pc, write_pc): Update.

	* infrun.c (displaced_step_prepare): Replace read_pc_pid and
	write_pc_pid by regcache_read_pc and regcache_write_pc.
	(displaced_step_fixup): Likewise.
	(resume): Likewise.  Use regcache arch instead of current_gdbarch.
	(prepare_to_proceed): Likewise.
	(proceed): Likewise.
	(adjust_pc_after_break): Likewise.
	(handle_inferior_event): Likewise.

	* linux-nat.c (cancel_breakpoint): Likewise.
	* linux-thread-db.c (check_event): Likewise.
	* aix-thread.c (aix_thread_wait): Likewise.
	* tracepoint.c (trace_dump_command): Likewise.
@
text
@a2522 7
	    case LOC_HP_THREAD_LOCAL_STATIC:
	      printf_filtered ("HP thread local static ");
	      break;
	    case LOC_INDIRECT:
	      printf_filtered ("extern (local indirect) at address ");
	      printf_filtered ("%s", paddress (SYMBOL_VALUE_ADDRESS (sym)));
	      break;
@


1.101
log
@2008-02-05  Andrzej Zaborowski  <balrogg@@gmail.com>

	* tracepoint.c (read_actions): Handle end-of-text indicator
	in action list properly.  (Committed by Jim Blandy)
@
text
@d2561 2
d2599 5
a2603 2
  stepping_frame = (t->address != (read_pc () - gdbarch_decr_pc_after_break
						  (current_gdbarch)));
@


1.100
log
@	* exec.c: #include "arch-utils.h"
	 (print_section_info): Use gdbarch_from_bfd to get at the
	current architecture. Replace current_gdbarch. Fix indention.
	Replace deprecated_print_address_numeric by paddress.
	* Makefile.in (exec.o) Add dependency to arch-utils.h.

	* valprint.c (val_print_string): Replace
	deprecated_print_address_numeric.
	* tracepoint.c (trace_mention, scope_info): Likewise.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1, print_symbol)
	(print_symbol, print_partial_symbols, maintenance_info_psymtabs)
	(maintenance_check_symtabs): Likewise.
	* symfile.c (list_overlays_command): Likewise.
	* stack.c (frame_info, print_block_frame_labels): Likewise.
	* printcmd.c (print_address, print_address_demangle)
	(address_info): Likewise.
	* corefile.c (memory_error): Likewise.
	* infcmd.c (jump_command): Likewise.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints)
	(mention, delete_breakpoint): Likewise.
	* c-valprint.c (print_function_pointer_address, c_val_print): Likewise.
	* dwarf2read.c (dump_die): Likewise.
	* ada-valprint.c (ada_val_print_1): Likewise.
	* f-valprint.c (f_val_print): Likewise.
	* linux-fork.c (info_forks_command): Likewise.
	* m32r-com.c (m32r_load_section, m32r_load)
	(m32r_upload_command): Likewise.

	* ui-out.c (ui_out_field_core_addr): Remove unnecessary comment.
@
text
@d865 4
a868 1
	line = "end";
@


1.99
log
@	Updated copyright notices for most files.
@
text
@d446 1
a446 1
      deprecated_print_address_numeric (tp->address, 1, gdb_stdout);
d2453 1
a2453 2
	      deprecated_print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 
				     1, gdb_stdout);
d2488 1
a2488 2
	      deprecated_print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 
				     1, gdb_stdout);
d2492 1
a2492 2
	      deprecated_print_address_numeric (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)),
				     1, gdb_stdout);
d2514 1
a2514 2
		  deprecated_print_address_numeric (SYMBOL_VALUE_ADDRESS (msym), 1,
					 gdb_stdout);
d2525 1
a2525 2
	      deprecated_print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 
				     1, gdb_stdout);
@


1.98
log
@* tracepoint.c (tracepoint_operation): Report the deletion event
after we have unlinked the tracepoint from the list, and use the
proper tracepoint number.
@
text
@d4 1
a4 1
   2007 Free Software Foundation, Inc.
@


1.97
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a585 1
	  tracepoint_delete_event (t2->number);
d590 2
@


1.96
log
@2007-08-04  Michael Snyder  <msnyder@@access-company.com>

	* tracepoint.c (add_register): Off by one error.
	(stringify_collection_list): Free malloc buffer.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.95
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1165 1
a1165 1
  if (regno > (8 * sizeof (collection->regs_mask)))
d1492 4
a1495 1
    return NULL;
@


1.94
log
@	* expression.h (enum exp_opcode): Document a register name for
	OP_REGISTER.
	* parse.c (write_dollar_variable): Write the register name for
	OP_REGISTER.
	(operator_length_standard): Expect the register name following
	OP_REGISTER.
	* ada-lang.c (resolve_subexp): Likewise.
	* ax-gdb.c (gen_expr): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* expprint.c (print_subexp_standard, dump_subexp_body_standard):
	Likewise.
	* tracepoint.c (encode_actions): Likewise.
@
text
@d483 1
a483 1
	      if (TARGET_ADDR_BIT <= 32)
d493 1
a493 1
	  if (TARGET_ADDR_BIT <= 32)
d505 1
a505 1
	  if (TARGET_ADDR_BIT <= 32)
@


1.93
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_VIRTUAL_FRAME_POINTER): Replace by
	gdbarch_virtual_frame_pointer.
	* tracepoint.c (encode_actions): Likewise.
	* dwarf2loc.c (dwarf2_loc_desc_needs_frame): Likewise.
	* ax-gdb.c (gen_frame_args_address, gen_frame_locals_address): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1605 14
a1618 5
		      i = exp->elts[1].longconst;
		      if (info_verbose)
			printf_filtered ("OP_REGISTER: ");
		      add_register (collect, i);
		      break;
@


1.92
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Replace by
	gdbarch_decr_pc_after_break.
	* tracepoint.c (trace_dump_command): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* linux-thread-db.c (check_event): Likewise.
	* linux-nat.c (cancel_breakpoints_callback): Likewise.
	* infrun.c (adjust_pc_after_break, normal_stop): Likewise.
	* frame.h: Likewise (comment).
	* dummy-frame.c (deprecated_pc_in_call_dummy): Likewise.
	* aix-thread.c (aix_thread_wait): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1542 2
a1543 1
  TARGET_VIRTUAL_FRAME_POINTER (t->address, &frame_reg, &frame_offset);
@


1.91
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2587 2
a2588 1
  stepping_frame = (t->address != (read_pc () - DECR_PC_AFTER_BREAK));
@


1.90
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d2446 2
a2447 1
			       REGISTER_NAME (SYMBOL_VALUE (sym)));
d2464 2
a2465 1
			       REGISTER_NAME (SYMBOL_VALUE (sym)));
d2469 2
a2470 1
			       REGISTER_NAME (SYMBOL_VALUE (sym)));
d2488 2
a2489 1
			       REGISTER_NAME (SYMBOL_BASEREG (sym)));
d2494 2
a2495 1
			       REGISTER_NAME (SYMBOL_BASEREG (sym)));
@


1.89
log
@	* frame.c (frame_pop, frame_observer_target_changed): Call
	reinit_frame_cache.
	(flush_cached_frames): Rename to reinit_frame_cache and delete
	old implementation.
	* frame.h (flush_cached_frames): Delete prototype and update comment.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Call
	reinit_frame_cache instead of flush_cached_frames.  Do not call
	select_frame after reinit_frame_cache.
	* corelow.c (core_open): Likewise.
	* gdbarch.sh (deprecated_current_gdbarch_select_hack): Likewise.
	* infrun.c (prepare_to_proceed, context_switch)
	(handle_inferior_event): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* ocd.c (ocd_start_remote): Likewise.
	* remote-e7000.c (e7000_start_remote): Likewise.
	* remote-mips.c (device): Likewise.
	* thread.c (switch_to_thread): Likewise.
	* tracepoint.c (finish_tfind_command): Likewise.
	* gdbarch.c: Regenerated.
@
text
@d1568 1
a1568 1
		  for (i = 0; i < NUM_REGS; i++)
@


1.88
log
@Copyright updates for 2007.
@
text
@d1972 1
a1972 1
  flush_cached_frames ();
a1973 1
  select_frame (get_current_frame ());
@


1.87
log
@* printcmd.c: Coding style fixes: add missing spaces in comments
and wrapping long lines.
(delete_display, enable_display_command, disable_display_command)
(printf_command, display_info, undisplay_command, free_display)
(display_command, x_command, address_info, set_command)
(inspect_command, call_command, print_command, print_command_1)
(validate_format, print_formatted, decode_format, sym_format):
Remove prototypes.
(x_command): Make static.
(printf_command): Convert error into internal consistency check.
(address_info): Avoid assignment within function call.
(printf_command): Avoid redundant cast.
* tracepoint.c (x_command): Remove extern prototype.
@
text
@d3 2
a4 2
   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006 Free Software Foundation, Inc.
@


1.86
log
@	* remote.c (struct remote_state): Add BUF and BUF_SIZE.
	(init_remote_state): Initialize the new fields.
	(get_memory_packet_size): Update BUF and BUF_SIZE if necessary.
	(set_thread, remote_thread_alive, remote_unpack_thread_info_response)
	(remote_get_threadinfo, parse_threadlist_response)
	(remote_get_threadlist, remote_current_thread, remote_threads_info)
	(remote_threads_extra_info, extended_remote_restart, get_offsets)
	(remote_check_symbols, remote_open_1, remote_detach)
	(remove_vcont_probe, remote_vcont_resume, remote_resume)
	(remote_wait, remote_async_wait, fetch_register_using_p)
	(remote_fetch_registers, store_register_using_P)
	(remote_store_registers, check_binary_download, remote_write_bytes)
	(remote_read_bytes, remote_insert_breakpoint)
	(remote_remove_breakpoint, remote_insert_watchpoint)
	(remote_remove_watchpoint, remote_insert_hw_breakpoint)
	(remote_remove_hw_breakpoint, compare_sections_command)
	(remote_xfer_partial, remote_rcmd, packet_command)
	(remote_get_thread_local_address): Use the global incoming buffer
	instead of alloca or xmalloc.  Limit outgoing packets to
	rs->remote_packet_size and incoming packets to rs->buf_size.
	Update calls to getpkt and remote_send.
	(remote_send): Take arguments by reference.
	(putpkt_binary): Eliminate junkbuf.  Use skip_frame.
	(skip_frame): New function.
	(read_frame): Take arguments by reference.  Expand the packet
	buffer instead of issuing an error.
	(getpkt, getpkt_sane): Take arguments by reference.
	* remote.h (getpkt): Update prototype and doc.
	* tracepoint.c (remote_get_noisy_reply): Take arguments by
	reference.
	(target_buf): Change from array to pointer.
	(target_buf_size): New variable.
	(remote_set_transparent_ranges): Update call to getpkt.
	(trace_start_command, trace_stop_command, trace_status_command):
	Update calls to remote_get_noisy_reply.
	(finish_tfind_command): Take arguments by reference.
	(trace_find_command, trace_find_pc_command)
	(trace_find_tracepoint_command, trace_find_line_command):
	(trace_find_range_command, trace_find_outside_command): Update
	calls to finish_tfind_command.
	(_initialize_tracepoint): Initialize target_buf_size and target_buf.
@
text
@d3 2
a4 2
   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free
   Software Foundation, Inc.
a70 1
extern void x_command (char *, int);
@


1.86.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d3 2
a4 2
   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006 Free Software Foundation, Inc.
d71 1
@


1.85
log
@2006-03-16  Michael Snyder  <msnyder@@redhat.com>

	* tracepoint.c (tracepoint_save_command): Fix typo in error msg.
@
text
@d197 2
a198 2
remote_get_noisy_reply (char *buf,
			long sizeof_buf)
d202 1
d204 2
a205 1
      getpkt (buf, sizeof_buf, 0);
d1705 2
a1706 1
static char target_buf[2048];
d1748 1
a1748 1
      getpkt (target_buf, sizeof (target_buf), 0);
d1774 1
a1774 1
      remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1791 1
a1791 1
	remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1815 2
a1816 2
		    remote_get_noisy_reply (target_buf, 
					    sizeof (target_buf));
d1832 2
a1833 2
		    remote_get_noisy_reply (target_buf, 
					    sizeof (target_buf));
d1846 1
a1846 1
      remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1868 1
a1868 1
      remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1888 1
a1888 1
      remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1903 2
a1904 2
finish_tfind_command (char *msg,
		      long sizeof_msg,
d1915 1
a1915 1
  putpkt (msg);
d2060 1
a2060 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2103 1
a2103 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2128 1
a2128 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2226 1
a2226 1
      finish_tfind_command (target_buf, sizeof (target_buf), 
d2267 1
a2267 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2306 1
a2306 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2873 3
@


1.84
log
@gdb/
	* Makefile.in (gdbtypes_h, gdbtypes.o, utils.o): Update.
	* defs.h (hashtab_obstack_allocate, dummy_obstack_deallocate): Add
	prototypes.
	* dwarf2read.c (read_subroutine_type): Use TYPE_ZALLOC.
	(hashtab_obstack_allocate, dummy_obstack_deallocate): Moved to...
	* utils.c (hashtab_obstack_allocate, dummy_obstack_deallocate):
	...here.
	* gdbtypes.c: Include "hashtab.h".
	(build_gdbtypes): Remove extra prototype.
	(struct type_pair, type_pair_hash, type_pair_eq)
	(create_copied_types_hash, copy_type_recursive): New.
	* gdbtypes.h: Include "hashtab.h".
	(TYPE_ZALLOC): New.
	(create_copied_types_hash, copy_type_recursive): New prototypes.
	* objfiles.c (free_objfile): Call preserve_values.
	* symfile.c (reread_symbols): Likewise.
	(clear_symtab_users): Remove calls to clear_value_history and
	clear_internalvars.
	* value.c (clear_value_history, clear_internalvars): Removed.
	(preserve_one_value, preserve_values): New functions.
	* value.h (clear_value_history, clear_internalvars): Removed.
	(preserve_values): New prototype.

	* tracepoint.c (_initialize_tracepoint): Do not initialize convenience
	variables here.
gdb/doc/
	* gdb.texinfo (Files): Remove obsolete bits from the description
	of "symbol-file".
@
text
@d2321 1
a2321 1
    error (_("Argument required (file name in which to save tracepoints"));
@


1.84.2.1
log
@Backport rs->buf patch from HEAD.
@
text
@d197 2
a198 2
remote_get_noisy_reply (char **buf_p,
			long *sizeof_buf)
a201 1
      char *buf;
d203 1
a203 2
      getpkt (buf_p, sizeof_buf, 0);
      buf = *buf_p;
d1703 1
a1703 2
static char *target_buf;
static long target_buf_size;
d1745 1
a1745 1
      getpkt (&target_buf, &target_buf_size, 0);
d1771 1
a1771 1
      remote_get_noisy_reply (&target_buf, &target_buf_size);
d1788 1
a1788 1
	remote_get_noisy_reply (&target_buf, &target_buf_size);
d1812 2
a1813 2
		    remote_get_noisy_reply (&target_buf,
					    &target_buf_size);
d1829 2
a1830 2
		    remote_get_noisy_reply (&target_buf,
					    &target_buf_size);
d1843 1
a1843 1
      remote_get_noisy_reply (&target_buf, &target_buf_size);
d1865 1
a1865 1
      remote_get_noisy_reply (&target_buf, &target_buf_size);
d1885 1
a1885 1
      remote_get_noisy_reply (&target_buf, &target_buf_size);
d1900 2
a1901 2
finish_tfind_command (char **msg,
		      long *sizeof_msg,
d1912 1
a1912 1
  putpkt (*msg);
d2057 1
a2057 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d2100 1
a2100 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d2125 1
a2125 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d2223 1
a2223 1
      finish_tfind_command (&target_buf, &target_buf_size,
d2264 1
a2264 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d2303 1
a2303 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
a2869 3

  target_buf_size = 2048;
  target_buf = xmalloc (target_buf_size);
@


1.84.6.1
log
@Actually include patch, not just changelog.
@
text
@d197 2
a198 2
remote_get_noisy_reply (char **buf_p,
			long *sizeof_buf)
a201 1
      char *buf;
d203 1
a203 2
      getpkt (buf_p, sizeof_buf, 0);
      buf = *buf_p;
d1703 1
a1703 2
static char *target_buf;
static long target_buf_size;
d1745 1
a1745 1
      getpkt (&target_buf, &target_buf_size, 0);
d1771 1
a1771 1
      remote_get_noisy_reply (&target_buf, &target_buf_size);
d1788 1
a1788 1
	remote_get_noisy_reply (&target_buf, &target_buf_size);
d1812 2
a1813 2
		    remote_get_noisy_reply (&target_buf,
					    &target_buf_size);
d1829 2
a1830 2
		    remote_get_noisy_reply (&target_buf,
					    &target_buf_size);
d1843 1
a1843 1
      remote_get_noisy_reply (&target_buf, &target_buf_size);
d1865 1
a1865 1
      remote_get_noisy_reply (&target_buf, &target_buf_size);
d1885 1
a1885 1
      remote_get_noisy_reply (&target_buf, &target_buf_size);
d1900 2
a1901 2
finish_tfind_command (char **msg,
		      long *sizeof_msg,
d1912 1
a1912 1
  putpkt (*msg);
d2057 1
a2057 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d2100 1
a2100 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d2125 1
a2125 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d2223 1
a2223 1
      finish_tfind_command (&target_buf, &target_buf_size,
d2264 1
a2264 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
d2303 1
a2303 1
      finish_tfind_command (&target_buf, &target_buf_size, from_tty);
a2869 3

  target_buf_size = 2048;
  target_buf = xmalloc (target_buf_size);
@


1.83
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@a2696 5
  set_internalvar (lookup_internalvar ("tpnum"),
		   value_from_longest (builtin_type_int, (LONGEST) 0));
  set_internalvar (lookup_internalvar ("trace_frame"),
		   value_from_longest (builtin_type_int, (LONGEST) - 1));

@


1.82
log
@gdb/ChangeLog:
2005-11-19  Jim Blandy  <jimb@@redhat.com>

	* tracepoint.c (memrange_absolute): New enum constant.
	(struct memrange, memrange_cmp, add_memrange, collect_symbol,
	stringify_collection_list, encode_actions): Use it instead of '-1'
	to indicate an fixed-address memory range.
	(Suggested by Eli Zaretskii.)
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.81
log
@2005-11-19  Jim Blandy  <jimb@@redhat.com>

	* tracepoint.c (stringify_collection_list): Indicate absolute
	memory ranges by using "-1" as the memory range's base register
	number, not "FFFFFFFF".
@
text
@d1072 4
d1078 2
a1079 1
  int type;		/* -1 for absolute memory range, else basereg number */
d1111 1
a1111 1
  if (a->type == 0)
d1183 1
a1183 1
  /* type: -1 == memory, n == basereg */
d1197 1
a1197 1
  if (type != -1)		/* Better collect the base register!  */
d1234 1
a1234 1
      add_memrange (collect, -1, offset, len);	/* -1 == memory */
d1449 4
a1452 3
           so passing -1 to it directly gives you "FFFFFFFF" (or more,
           depending on sizeof (unsigned)).  Special-case it.  */
        if (list->list[i].type == -1)
d1614 1
a1614 1
		      add_memrange (collect, -1, addr, len);
@


1.80
log
@2005-11-18  Jim Blandy  <jimb@@redhat.com>

	* tracepoint.c (collect_symbol): Doc fix.
@
text
@d1440 11
a1450 4
      sprintf (end, "M%X,%s,%lX", 
	       list->list[i].type,
	       tmp2,
	       (long) (list->list[i].end - list->list[i].start));
@


1.79
log
@2005-11-18  Jim Blandy  <jimb@@redhat.com>

	* tracepoint.c (struct memrange): Doc fix.
@
text
@d1229 1
a1229 1
      add_memrange (collect, -1, offset, len);	/* 0 == memory */
@


1.78
log
@	From Josef Ezra <jezra@@emc.com>:
	* tracepoint.c (stringify_collection_list): Correct pointer
	arithmetic.
@
text
@d1074 1
a1074 1
  int type;		/* 0 for absolute memory range, else basereg number */
@


1.77
log
@2005-05-26  Andrew Cagney  <cagney@@gnu.org>

	* command.h (add_setshow_integer_cmd): Make VAR an integer.
	* cli/cli-decode.c (add_setshow_integer_cmd): Update to match.
	* valops.c (value_string): Add a cast.
	* eval.c (evaluate_subexp_standard): Use gdb_byte for byte buffers.
	* breakpoint.c (re_enable_breakpoints_in_shlibs): Use gdb_byte for
	byte buffers.
	* target.h (struct target_ops): For to_insert_hw_breakpoint and
	to_remove_hw_breakpoint use gdb_byte for byte buffer parameters.
	* breakpoint.h (struct bp_location): Make shadow_contents a
	gdb_byte buffer.
	* cli/cli-setshow.c (do_setshow_command): Fix cast.
	* cli/cli-dump.c (restore_section_callback)
	(restore_binary_file): Use gdb_byte for byte buffers.
	* proc-service.c (ps_ptwrite, ps_ptread, ps_pdwrite): Fix casts.
	(ps_xfer_memory): Use gdb_byte for byte buffers.
	* tracepoint.c (mem2hex): Use gdb_byte for byte buffers, and char
	for string buffers.
	* ser-tcp.c (net_open): Make len a socklen_t.
@
text
@d1446 1
a1446 1
      end += count;
@


1.77.2.1
log
@2005-05-30  Michael Snyder  <msnyder@@redhat.com>

	Add support for writing tracepoint/checkpoint data to a file.

	* breakpoint.c (bpstat_stop_status): Add hook for interpreting
	breakpoints as tracepoints, enabling gdb to handle them directly
	by a "default" fallback method (writing data to a file).

	* tracepoint.c (default_tracepoint_method): New user-settable
	mode variable -- tells gdb to use a "default" (fallback) method
	for collecting tracepoint data.
	(trace_start_command, trace_stop_command, trace_status_command):
	Add "default" mode.

	(tracepoint_event_p, default_do_tracepoints_command): New
	functions, entry points into default tracepoint collection method.

	(checkpoint_open, checkpoint_close): Open / close checkpoint file.
	(checkpoint_command): Drop a checkpoint into checkpoint file.

	(emit_checkpoint_method1, emit_checkpoint_method2,
	emit_checkpoint_method3, emit_checkpoint_method4): Experimental
	methods for writing checkpoint/tracepoint data to a file.

	(checkpoint_emit_memrange, checkpoint_emit_gregs,
	checkpoint_emit_stack, checkpoint_emit_id, etc.):
	Support functions for writing checkpoint/tracepoint data.

	(get_tracepoint_by_address): New function.
	(validate_actionline): Add "$stack" pseudo-object for collection.
	(tracepoint_top_of_stack, tracepoint_size_of_stack):
	New user-settable variables.
	(encode_actions): Interpret "$stack" pseudo-object, collect stack.

	* tracepoint.h (default_trace_method, tracepoint_event_p):
	Exported interface for default tracepoint method.
@
text
@a101 11

   A number of the methods in this module assume "target remote", 
   and some of them contain code that belongs in remote.c and 
   ought to be accessed thru the target vector (so that non-remote
   targets could implement them too).

   Therefore this module defines a user-settable mode variable
   "default-tracepoint-method", which will override the original
   methods and cause a simple-minded fall-back method to be used, 
   which should work on most if not all targets.

a103 1
int default_trace_method;
a603 16
/* Utility: Look up a tracepoint in the list, by address.  
   Returns the first match that's enabled.  */

struct tracepoint *
get_tracepoint_by_address (CORE_ADDR address)
{
  struct tracepoint *t;

  ALL_TRACEPOINTS (t)
    if (t->enabled_p)
      if (t->address == address)
	return t;

  return NULL;
}

d966 1
a966 2
		  (0 == strncasecmp ("loc", p + 1, 3)) ||
		  (0 == strncasecmp ("stack", p + 1, 5)))
a1502 3
static CORE_ADDR tracepoint_top_of_stack;
static unsigned int tracepoint_size_of_stack = 256;

a1575 22
	      else if (0 == strncasecmp ("$stack", action_exp, 6))
		{
		  CORE_ADDR lo, hi;
		  int stacklen;

		  /* FIXME: frame pointer? stack_grows_down?  */
		  lo = read_sp ();
		  if (tracepoint_top_of_stack != 0)
		    hi = tracepoint_top_of_stack;
		  else
		    hi = lo + tracepoint_size_of_stack;

		  stacklen = hi - lo;

		  if (tracepoint_top_of_stack != 0 &&
		      stacklen > 10000)	/* Arbitrary sanity check.  */
		    error ("Stack too big: sp = 0x%08lx, TOS = 0x%08lx, check TOS.",
			   (unsigned long) lo, (unsigned long) hi);

		  add_memrange (collect, -1, lo, stacklen);
		  action_exp = strchr (action_exp, ',');	/* more? */
		}
d1755 1
a1755 7
  if (default_trace_method)
    {
      /* Default implementation.  */
      if (from_tty && info_verbose)
	printf_filtered ("Activating trace experiment, default method.\n");
    }
  else if (target_is_remote ())
d1833 7
d1842 1
a1842 11
    {
      error (_("Target does not implement this command (tstart)."));
    }

  /* All methods.  */
  set_traceframe_num (-1);	/* All old traceframes invalidated.  */
  set_tracepoint_num (-1);
  set_traceframe_context (-1);
  trace_running_p = 1;
  if (deprecated_trace_start_stop_hook)
    deprecated_trace_start_stop_hook (1, from_tty);
d1849 1
a1849 7
  if (default_trace_method)
    {
      /* Default implementation.  */
      if (from_tty && info_verbose)
	printf_filtered ("Deactivating trace experiment, default method.\n");
    }
  else if (target_is_remote ())
d1855 3
d1860 1
a1860 8
    {
      error (_("Target does not implement this command (tstop)."));
    }

  /* All methods.  */
  trace_running_p = 0;
  if (deprecated_trace_start_stop_hook)
    deprecated_trace_start_stop_hook (0, from_tty);
d1869 1
a1869 5
  if (default_trace_method)
    {
      printf_filtered ("Trace is %s.\n", trace_running_p ? "on" : "off");
    }
  else if (target_is_remote ())
d1882 1
a1882 3
    {
      error (_("Target does not implement this command (tstatus)."));
    }
a2015 3
  if (default_trace_method)
    error ("default trace find");

a2538 3
  if (default_trace_method)
    error ("default trace dump");

a2671 419
static FILE *checkpoint_file;
static int tracepoint_method;

static void
emit_checkpoint_method1 (struct tracepoint *t)
{
  /* This extremely concise method emits only a few essential registers. 
     Think of it as an execution trace.  */
  if (checkpoint_file)
    {
      /* Method 1: Emit minimal subset of registers.  */
      fputs ("T00", checkpoint_file);
      /* FIXME: print 'em like addresses.  */
      if (PC_REGNUM >= 0)
	{
	  fputs (int_string ((LONGEST) PC_REGNUM, 16, 0, 0, 0), 
		 checkpoint_file);
	  fputc (':', checkpoint_file);
	  fputs (paddr (read_pc ()), checkpoint_file);
	  fputc (';', checkpoint_file);
	}
      if (SP_REGNUM >= 0)
	{
	  fputs (int_string ((LONGEST) SP_REGNUM, 16, 0, 0, 0), 
		 checkpoint_file);
	  fputc (':', checkpoint_file);
	  fputs (paddr (read_sp ()), checkpoint_file);
	  fputc (';', checkpoint_file);
	}
      if (DEPRECATED_FP_REGNUM >= 0)
	{
	  fputs (int_string ((LONGEST) DEPRECATED_FP_REGNUM, 16, 0, 0, 0), 
		 checkpoint_file);
	  fputc (':', checkpoint_file);
	  fputs (paddr ((CORE_ADDR) read_register (DEPRECATED_FP_REGNUM)), 
		 checkpoint_file);
	  fputc (';', checkpoint_file);
	}
      if (PS_REGNUM >= 0)
	{
	  fputs (int_string ((LONGEST) PS_REGNUM, 16, 0, 0, 0), 
		 checkpoint_file);
	  fputc (':', checkpoint_file);
	  fputs (paddr ((CORE_ADDR) read_register (PS_REGNUM)), 
		 checkpoint_file);
	  fputc (';', checkpoint_file);
	}
#define I386_EBP_REGNUM 5	/* mumble, mutter... */

#if defined (I386_EBP_REGNUM)
      fputs (int_string ((LONGEST) I386_EBP_REGNUM, 16, 0, 0, 0), 
	     checkpoint_file);
      fputc (':', checkpoint_file);
      fputs (paddr ((CORE_ADDR) read_register (I386_EBP_REGNUM)), 
	     checkpoint_file);
      fputc (';', checkpoint_file);
#endif
      fputc ('\n', checkpoint_file);
    }
}

static void
checkpoint_emit_id (int id, FILE *file)
{
  fprintf (file, "\nCHECKPOINT ID %d\n", id);
}

static void
checkpoint_emit_sequential_id (FILE *file)
{
  static int cpnum;
  checkpoint_emit_id (cpnum++, file);
}

static void
checkpoint_emit_gregs (FILE *file)
{
  /* FIXME: assume the g packet includes regs 0 to NUM_REGS-1.  */
  unsigned char binbuf[32];
  char ascbuf[128];
  int i;

  for (i = 0; i < NUM_REGS; i++)
    {
      if (!register_cached (i))
	target_fetch_registers (i);
      regcache_raw_collect (current_regcache, i, binbuf);
      *(mem2hex (binbuf, ascbuf, register_size (current_gdbarch, i))) = '\0';
      fputs (ascbuf, file);
    }
  fputc ('\n', file);
}

static void
checkpoint_emit_memrange (CORE_ADDR lo, CORE_ADDR hi, FILE *file)
{
  unsigned char *buf;
  unsigned int i, len = hi - lo;

  fprintf (file, "S3%02x%s", (len + 5) > 255 ? 255 : (len + 5), paddr (lo));

  /* FIXME: cleanup.  */
  buf = xmalloc (len);
  target_read_memory (lo, buf, len);

  /* FIXME: byte order?  */
  for (i = 0; i < len; i++)
    {
      if ((i > 0) && ((i % 256) == 0))
	fprintf (file, "xx\nS3%02x%s", 
		 (len + 5 - i) > 255 ? 255 : (len + 5 - i), paddr (lo + i));
      fprintf (file, "%02x", buf[i]);
    }
  xfree (buf);

  /* We don't really care about the checksum.  */
  fputs ("xx\n", file);
}

static void
checkpoint_emit_stack (FILE *file)
{
  CORE_ADDR lo, hi;
  int stacklen;

  /* FIXME: frame pointer? stack_grows_down?  */
  lo = read_sp ();
  if (tracepoint_top_of_stack != 0)
    hi = tracepoint_top_of_stack;
  else
    hi = lo + tracepoint_size_of_stack;

  stacklen = hi - lo;

  if (tracepoint_top_of_stack != 0 &&
      stacklen > 10000)	/* Arbitrary sanity check.  */
    error ("Stack too big: sp = 0x%08lx, TOS = 0x%08lx, check TOS.",
	   (unsigned long) lo, (unsigned long) hi);

  checkpoint_emit_memrange (lo, hi, file);
}

static void
emit_checkpoint_method2 (struct tracepoint *t)
{
  /* This relatively concise method emits the standard "g packet"
     register set.  It's still mostly an execution trace, but any
     variables in registers will be captured too.  */

  checkpoint_emit_sequential_id (checkpoint_file);
  fputs ("REGISTERS\n", checkpoint_file);
  checkpoint_emit_gregs (checkpoint_file);
}

static void
emit_checkpoint_method3 (struct tracepoint *t)
{
  /* This medium-complexity method emits the standard "g packet"
     register set, plus a configurable chunk of the machine stack.
     User may either specify the size of the chunk (default 512),
     or the top of the stack.  By this means, we hopefully capture
     all local variables and arguments, and can do backtrace.  */

  checkpoint_emit_sequential_id (checkpoint_file);
  fputs ("REGISTERS\n", checkpoint_file);
  checkpoint_emit_gregs (checkpoint_file);

  /* And here's where memory goes.  */
  fputs ("MEMORY\n", checkpoint_file);
  checkpoint_emit_stack (checkpoint_file);
}

static void
emit_checkpoint_method4 (struct tracepoint *t)
{
  /* This method will not immediately lend itself to the "drop"
     command, because it wants to interpret the "actions" of the
     actual tracepoint.  "Drop" doesn't have an actual tracepoint
     associated with it (unles we give it an argument...  Hmmm!) */

  char **tdp_actions, **stepping_actions;
  int memory_flag = 0;
  int i;

  if (checkpoint_file)
    {
      encode_actions (t, &tdp_actions, &stepping_actions);
      if (tdp_actions == NULL)
	{
	  /* Fixme -- no actions -- should just lay down a 
	     "method 1" tracepoint, but rda doesn't know how
	     to read those yet, so fall back to method2.  */
	  emit_checkpoint_method2 (t);
	  return;
	}

      checkpoint_emit_sequential_id (checkpoint_file);
      for (i = 0; tdp_actions[i]; i++)
	{
	  CORE_ADDR offset, base;
	  int regnum, len;
	  char *ptr;

	  if (tdp_actions[i][0] == 'R')
	    {
	      /* We want some regs.  Let's just take 'em all.  */
	      fputs ("REGISTERS\n", checkpoint_file);
	      checkpoint_emit_gregs (checkpoint_file);
	    }
	do_memrange:
	  if (tdp_actions[i][0] == 'M')
	    {
	      /* A mem range.  */
	      if (memory_flag == 0)
		{
		  fputs ("MEMORY\n", checkpoint_file);
		  memory_flag++;
		}
	      if (strncmp (tdp_actions[i] + 1, "FFFF", 4) == 0)
		{
		  /* Absolute memory range.  */
		  if ((ptr = strchr (tdp_actions[i], ',')) != NULL)
		    {
		      /* FIXME strtoull? */
		      base = strtoul (++ptr, NULL, 16);
		      if ((ptr = strchr (ptr, ',')) != NULL)
			{
			  len = strtoul (++ptr, NULL, 16);
			  checkpoint_emit_memrange (base, base + len, 
						    checkpoint_file);
			}
		    }
		}
	      else
		{
		  /* Register-based memory range.  */
		  regnum = strtol (tdp_actions[i] + 1, NULL, 16);
		  base = read_register (regnum);
		  if ((ptr = strchr (tdp_actions[i], ',')) != NULL)
		    {
		      offset = strtoul (++ptr, NULL, 16);
		      if ((ptr = strchr (ptr, ',')) != NULL)
			{
			  len = strtol (++ptr, NULL, 16);
			  checkpoint_emit_memrange (base + offset, 
						    base + offset + len,
						    checkpoint_file);
			}
		    }
		}
	      if ((ptr = strchr (ptr, 'M')) != NULL)
		{
		  tdp_actions[i] = ptr;
		  goto do_memrange;
		}
	    }
	}
    }
}

static void
tracepoint_set_tos_command (char *args, int from_tty)
{
  if (args == NULL || *args == '\0')
    error ("Argument required: address of TOS");

  /* Fixme -- expression.  */
  tracepoint_top_of_stack = parse_and_eval_address (args);
}

static void
tracepoint_set_size_of_stack_command (char *args, int from_tty)
{
  if (args == NULL || *args == '\0')
    error ("Argument required: size of desired stack memrange.");

  /* Fixme -- expression.  */
  tracepoint_size_of_stack = parse_and_eval_address (args);
}

static void
default_do_tracepoints_command (char *args, int from_tty)
{
  CORE_ADDR stop_pc;
  struct tracepoint *t;

  if (checkpoint_file == NULL)
    error ("You must open a checkpoint file first.  Type help open-checkpoint.");

  if (tracepoint_chain == NULL)
    error ("No tracepoints defined.");

  if (!target_has_execution)
    error ("Target not running.");

  if (from_tty && info_verbose)
    printf_filtered ("Do default tracepoint actions.\n");

  /* OK, find a tracepoint that matches the current pc.
     FIXME handle while-stepping.  */
  stop_pc = read_pc ();
  ALL_TRACEPOINTS (t)
    if (t->address == stop_pc)
      {
	if (from_tty && info_verbose)
	  printf_filtered ("Will collect data for tracepoint %d\n", t->number);
	switch (tracepoint_method) 
	  {
	  case 1:	emit_checkpoint_method1 (t);	break;
	  case 2:	emit_checkpoint_method2 (t);	break;
	  case 3:	emit_checkpoint_method3 (t);	break;
	  case 4:	emit_checkpoint_method4 (t);	break;
	  default:	emit_checkpoint_method4 (t);	break;
	  }
      }
}

/* boolean tracepoint_event_p --

   Decides whether to handle the current stop event as a 
   tracepoint event.  If so, handles the event (collects 
   the tracepoint data) and returns true.  GDB will not stop.

   Otherwise the event must be handled by someone else,
   eg. as a breakpoint event.  */

int
tracepoint_event_p ()
{
  struct tracepoint *t;

  /* Can't be ours if default trace method is not on.  */
  if (!default_trace_method)
    return 0;

  /* Can't be ours if a trace experiment is not running.  */
  if (!trace_running_p)
    return 0;

  /* Can't be ours if we don't have an open tracepoint file.  */
  if (checkpoint_file == NULL)
    return 0;

  /* Can't be ours if there's no (enabled) tracepoint here.  */
  if ((t = get_tracepoint_by_address (read_pc ())) == NULL)
    return 0;

  /* OK, it's ours, let's handle it.  */
  switch (tracepoint_method) 
    {
    case 1:	emit_checkpoint_method1 (t);	break;
    case 2:	emit_checkpoint_method2 (t);	break;
    case 3:	emit_checkpoint_method3 (t);	break;
    case 4:	emit_checkpoint_method4 (t);	break;
    default:	emit_checkpoint_method4 (t);	break;
    }
  /* Tell caller we've handled it.  */
  return 1;
}

/* Open file for checkpoints (tracepoint frames).  */
static void
checkpoint_open (char *args, int from_tty)
{
  if (args == NULL || *args == '\0')
    error ("Argument required: checkpoint file name.");

  if ((checkpoint_file = fopen (args, "w")) == NULL)
    error ("Could not open checkpoint file %s for output.", args);

  fprintf (checkpoint_file, "CHECKPOINT FILE\n");
  if (from_tty)
    fprintf_filtered (gdb_stdout, "File '%s' open for checkpoints.\n",
		      args);
}

/* Close file for checkpoints (tracepoint frames).  */
static void
checkpoint_close (char *unused, int from_tty)
{
  if (checkpoint_file == NULL)
    error ("No checkpoint file is open.");

  fclose (checkpoint_file);
  if (from_tty)
    fprintf_filtered (gdb_stdout, "Checkpoint file closed.\n");
}

/* "Drop" a checkpoint into the checkpoint file.  */
static void
checkpoint_command (char *args, int from_tty)
{
  if (checkpoint_file)
    {
      switch (tracepoint_method) 
	{
	case 1:		emit_checkpoint_method1 (NULL);	break;
	case 2:		emit_checkpoint_method2 (NULL);	break;
	case 3:		emit_checkpoint_method3 (NULL);	break;
	case 4:
	  if (args && *args)
	    {
	      struct tracepoint *t = get_tracepoint_by_number (&args, 0, 0);

	      if (t)
		{
		  emit_checkpoint_method4 (t);
		  break;
		}
	    }
	  error ("Must specify a tracepoint ID for method 4.");
	  break;
	default:	emit_checkpoint_method3 (NULL);	break;
	}
    }
  else
    error ("You must open a checkpoint file.");
}

a2678 50
  add_setshow_boolean_cmd ("default-tracepoint-method", class_trace, 
			   &default_trace_method, _("\
Set whether gdb will use a brute-force tracepoint method."), _("\
Show whether gdb will use a brute-force tracepoint method."), _("\
When this is set, tracepoint data will actually be collected\n\
by gdb, and not by the target.  Obviously this method is far\n\
more intrusive and time consuming than the ideal."), 
			   NULL, NULL, &setlist, &showlist);

  add_setshow_integer_cmd ("tracepoint-method", class_trace, 
			   &tracepoint_method, _("\
Set the method for saving a tracepoint."), _("\
Show the method for saving a tracepoint."), _("\
Method 1, save only a minimal subset of registers.\n\
Method 2, save all of the registers (but not pseudo-registers).\n\
Method 3, save all registers and the machine stack\n\
  (see tos and size-of-stack).\n\
Method 4, use tracepoints to determine what to save.\n\
Method 5 etc. TBD."), 
			   NULL, NULL, &setlist, &showlist);

  add_com ("default-do-tracepoints", class_trace, 
	   default_do_tracepoints_command, "Collect tracepoint data.");

  c = add_com ("open-checkpoint", class_trace, checkpoint_open, "\
Open output file for checkpoints.\n\
Argument is filename.");
  set_cmd_completer (c, filename_completer);

  c = add_com ("close-checkpoint", class_trace, checkpoint_close, "\
Close checkpoint file.\n\
No arguments, since only one checkpoint file may be open at a time.");
  set_cmd_completer (c, noop_completer);

  c = add_com ("drop-checkpoint", class_trace, checkpoint_command, "\
Drop a checkpoint.\n\
Best not ask what good it will do...");
  set_cmd_completer (c, noop_completer);

  c = add_com ("tos", class_trace, tracepoint_set_tos_command, "\
Set TOS so that checkpoints can save the stack.");
  set_cmd_completer (c, noop_completer);

  c = add_com ("size-of-stack", class_trace, 
	       tracepoint_set_size_of_stack_command, "\
Set size of stack to be saved at a checkpoint.");
  set_cmd_completer (c, noop_completer);

  /* End checkpoint stuff.  */

@


1.77.2.2
log
@2005-05-12  Michael Snyder  <msnyder@@redhat.com>

	* tracepoint.c (emit_checkpoint_method4): Add PC to ckpt record.
@
text
@a2953 3
      fputs ("PC=", checkpoint_file);
      fputs (paddr (read_pc ()), checkpoint_file);
      fputc ('\n', checkpoint_file);
@


1.77.2.3
log
@2005-06-03  Michael Snyder  <msnyder@@redhat.com>

	* tracepoint.c, remote.c, target.c, target.h, etc.:
	Begin moving tracepoint methods into the target vector,
	and migrating some of the remote protocol stuff from
	tracepoint.c into remote.c.
@
text
@a1789 3
unsigned long trace_running_p;
static FILE *checkpoint_file;

a1796 21
extern int
trace_default_start (char *args, int from_tty)
{
  if (checkpoint_file == NULL)
    error (_("\
You must open a tracepoint file to use the default tracepoint\n\
method.  This will enable gdb to save trace data into a file.\n\n\
See 'help open-tracepoint-file'."));

  if (from_tty && info_verbose)
    fprintf_filtered (gdb_stdout, "default trace start\n");
  set_traceframe_num (-1);	/* All old traceframes invalidated.  */
  set_tracepoint_num (-1);
  set_traceframe_context (-1);
  trace_running_p = 1;
  if (deprecated_trace_start_stop_hook)
    deprecated_trace_start_stop_hook (1, from_tty);

  return 1;	/* Handled.  */
}

a1799 14
#if 1
  if (!target_start_tracepoints (args, from_tty))
    {
      if (!default_trace_method)
	if (query (_("Target tracepoint support not active.  Use default method? ")))
	  default_trace_method++;

      if (default_trace_method)
	trace_default_start (args, from_tty);
      else if (from_tty)
	fprintf_filtered (gdb_stdout, "Cancelled.\n");
    }
  return;
#else
a1905 22
#endif
}

/* tstop command:
   Tell the target to stop collecting trace data.  */

extern int
trace_default_stop (char *args, int from_tty)
{
  if (checkpoint_file == NULL)
    error (_("\
You must open a tracepoint file to use the default tracepoint\n\
method.  This will enable gdb to save trace data into a file.\n\n\
See 'help open-tracepoint-file'."));

  if (from_tty && info_verbose)
    fprintf_filtered (gdb_stdout, "default trace stop\n");
  trace_running_p = 0;
  if (deprecated_trace_start_stop_hook)
    deprecated_trace_start_stop_hook (0, from_tty);

  return 1;	/* Handled.  */
d1908 1
a1911 14
#if 1
  if (!target_stop_tracepoints (args, from_tty))
    {
      if (!default_trace_method)
	if (query (_("Target tracepoint support not active.  Use default method? ")))
	  default_trace_method++;

      if (default_trace_method)
	trace_default_stop (args, from_tty);
      else
	fprintf_filtered (gdb_stdout, "Cancelled.\n");
    }
  return;
#else
a1933 1
#endif
d1936 1
a1936 20
/* tstatus command:
   Report whether trace is running.   */

extern int
trace_default_status (char *args, int from_tty)
{
  if (checkpoint_file == NULL)
    error (_("\
You must open a tracepoint file to use the default tracepoint\n\
method.  This will enable gdb to save trace data into a file.\n\n\
See 'help open-tracepoint-file'."));

  if (from_tty && info_verbose)
    fprintf_filtered (gdb_stdout, "default trace status\n");

  fprintf_filtered (gdb_stdout, "Trace is %s.\n",
		    trace_running_p ? "on" : "off");

  return 1;	/* Handled.  */
}
d1938 1
a1941 14
#if 1
  if (!target_tracepoint_status (args, from_tty))
    {
      if (!default_trace_method)
	if (query (_("Target tracepoint support not active.  Use default method? ")))
	  default_trace_method++;

      if (default_trace_method)
	trace_default_status (args, from_tty);
      else
	fprintf_filtered (gdb_stdout, "Cancelled.\n");
    }
  return;
#else
a1961 1
#endif
d2757 1
d3125 1
a3125 1
    error ("Argument required: filename for tracepoint/checkpoint data.");
d3132 1
a3132 1
    fprintf_filtered (gdb_stdout, "File '%s' open for trace/checkpoints.\n",
a3214 5
  c = add_com ("open-tracepoint", class_trace, checkpoint_open, "\
Open output file for tracepoints.\n\
Argument is filename.");
  set_cmd_completer (c, filename_completer);

@


1.76
log
@	* tracepoint.c (target_is_remote): Allow extended-remote.
	(struct collection_list): Allow 256 registers, like the comment
	said.
	(add_memrange): Fix comment.
	(read_actions): Turn EOF into 'end'.
@
text
@d153 1
a153 1
static unsigned char *mem2hex (unsigned char *, unsigned char *, int);
d2648 2
a2649 2
static unsigned char *
mem2hex (unsigned char *mem, unsigned char *buf, int count)
d2651 1
a2651 1
  unsigned char ch;
@


1.75
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d167 2
a168 1
      strcmp (current_target.to_shortname, "remote") == 0)
d864 3
d1081 1
a1081 1
    unsigned char regs_mask[8];	/* room for up to 256 regs */
d1178 1
a1178 1
  /* type: 0 == memory, n == basereg */
@


1.74
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d2713 1
a2713 1
	    "List the variables local to a scope");
d2719 2
a2720 2
  add_info ("tracepoints", tracepoints_info,
	    "Status of tracepoints, or tracepoint number NUMBER.\n\
d2722 1
a2722 1
last tracepoint set.");
d2726 3
a2728 3
  c = add_com ("save-tracepoints", class_trace, tracepoint_save_command,
	       "Save current tracepoint definitions as a script.\n\
Use the 'source' command in another debug session to restore them.");
d2732 1
a2732 1
	   "Print everything collected at the current tracepoint.");
d2734 3
a2736 3
  add_prefix_cmd ("tfind", class_trace, trace_find_command,
		  "Select a trace frame;\n\
No argument means forward by one frame; '-' means backward by one frame.",
d2780 1
a2780 1
	   "Display the status of the current trace data collection.");
d2783 1
a2783 1
	   "Stop trace data collection.");
d2786 1
a2786 1
	   "Start trace data collection.");
d2788 2
a2789 2
  add_com ("passcount", class_trace, trace_pass_command,
	   "Set the passcount for a tracepoint.\n\
d2792 1
a2792 1
if TPNUM is omitted, passcount refers to the last tracepoint defined.");
d2794 2
a2795 2
  add_com ("end", class_trace, end_actions_pseudocommand,
	   "Ends a list of commands or actions.\n\
d2799 1
a2799 1
Note: the \"end\" command cannot be used at the gdb prompt.");
d2801 2
a2802 2
  add_com ("while-stepping", class_trace, while_stepping_pseudocommand,
	   "Specify single-stepping behavior at a tracepoint.\n\
d2807 1
a2807 1
Note: this command can only be used in a tracepoint \"actions\" list.");
d2812 2
a2813 2
  add_com ("collect", class_trace, collect_pseudocommand,
	   "Specify one or more data items to be collected at a tracepoint.\n\
d2820 1
a2820 1
Note: this command can only be used in a tracepoint \"actions\" list.");
d2822 2
a2823 2
  add_com ("actions", class_trace, trace_actions_command,
	   "Specify the actions to be taken at a tracepoint.\n\
d2826 1
a2826 1
depending on target's capabilities.");
d2846 2
a2847 2
  c = add_com ("trace", class_trace, trace_command,
	       "Set a tracepoint at a specified line or function or address.\n\
d2851 1
a2851 1
Do \"help tracepoints\" for info on other tracepoint commands.");
@


1.73
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (paddress): New function.
	* defs.h (paddress): Declare.
	* printcmd.c (deprecated_print_address_numeric): Rename
	print_address_numeric, call paddress.
	* valprint.c, ui-out.c, tui/tui-stack.c, tracepoint.c: Update.
	* symmisc.c, symfile.c stack.c, p-valprint.c, printcmd.c: Update.
	* maint.c, m32r-rom.c, infcmd.c, f-valprint.c, exec.c: Update.
	* dwarf2read.c, dve3900-rom.c, defs.h, c-valprint.c: Update.
	* corefile.c, cli/cli-cmds.c, breakpoint.c, annotate.c: Update.
	* ada-valprint.c: Update.
@
text
@d2716 1
a2716 1
	   "Tracing of program execution without stopping the program.",
d2739 3
a2741 3
  add_cmd ("outside", class_trace, trace_find_outside_command,
	   "Select a trace frame whose PC is outside the given \
range.\nUsage: tfind outside addr1, addr2",
d2744 3
a2746 3
  add_cmd ("range", class_trace, trace_find_range_command,
	   "Select a trace frame whose PC is in the given range.\n\
Usage: tfind range addr1,addr2",
d2749 2
a2750 2
  add_cmd ("line", class_trace, trace_find_line_command,
	   "Select a trace frame by source line.\n\
d2753 1
a2753 1
Default argument is 'the next source line that was traced'.",
d2756 3
a2758 3
  add_cmd ("tracepoint", class_trace, trace_find_tracepoint_command,
	   "Select a trace frame by tracepoint number.\n\
Default is the tracepoint for the current trace frame.",
d2761 3
a2763 3
  add_cmd ("pc", class_trace, trace_find_pc_command,
	   "Select a trace frame by PC.\n\
Default is the current PC, or the PC of the current trace frame.",
d2766 3
a2768 3
  add_cmd ("end", class_trace, trace_find_end_command,
	   "Synonym for 'none'.\n\
De-select any trace frame and resume 'live' debugging.",
d2772 1
a2772 1
	   "De-select any trace frame and resume 'live' debugging.",
d2776 1
a2776 1
	   "Select the first trace frame in the trace buffer.",
d2828 2
a2829 2
  add_cmd ("tracepoints", class_trace, delete_trace_command,
	   "Delete specified tracepoints.\n\
d2831 1
a2831 1
No argument means delete all tracepoints.",
d2834 2
a2835 2
  add_cmd ("tracepoints", class_trace, disable_trace_command,
	   "Disable specified tracepoints.\n\
d2837 1
a2837 1
No argument means disable all tracepoints.",
d2840 2
a2841 2
  add_cmd ("tracepoints", class_trace, enable_trace_command,
	   "Enable specified tracepoints.\n\
d2843 1
a2843 1
No argument means enable all tracepoints.",
@


1.72
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d446 1
a446 1
      print_address_numeric (tp->address, 1, gdb_stdout);
d2423 1
a2423 1
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 
d2456 1
a2456 1
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 
d2461 1
a2461 1
	      print_address_numeric (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)),
d2482 1
a2482 1
		  print_address_numeric (SYMBOL_VALUE_ADDRESS (msym), 1,
d2494 1
a2494 1
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 
@


1.71
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d619 1
a619 1
	error_no_arg ("tracepoint number");
@


1.70
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (deprecated_set_value_modifiable)
	(deprecated_value_modifiable): Declare.
	* value.c (deprecated_set_value_modifiable): Define.
	(deprecated_value_modifiable): Define.
	* ada-lang.c, valops.c, breakpoint.c, tracepoint.c: Update.
@
text
@d183 1
a183 1
	error ("tracepoint.c: error in outgoing packet.");
d185 1
a185 1
	error ("tracepoint.c: error in outgoing packet at field #%ld.",
d188 1
a188 1
      error ("trace API error 0x%s.", ++buf);
d190 1
a190 1
      error ("Target returns error code '%s'.", buf);
d204 1
a204 1
	error ("Target does not support this command.");
d394 1
a394 1
    error ("trace command requires an argument");
d716 1
a716 1
    error ("passcount command requires an argument (count + optional TP num)");
d728 1
a728 1
	error ("Junk at end of arguments.");
d770 1
a770 1
  error ("This command cannot be used at the top level.");
d776 1
a776 1
  error ("This command can only be used in a tracepoint actions list.");
d782 1
a782 1
  error ("This command can only be used in a tracepoint actions list.");
d883 1
a883 1
	      warning ("Already processing 'while-stepping'");
d942 1
a942 1
      warning ("'%s' is not an action that I know, or is ambiguous.", 
d976 1
a976 1
		  warning ("constant %s (value %ld) will not be collected.",
d983 1
a983 1
		  warning ("%s is optimized away and cannot be collected.",
d996 1
a996 1
	    error ("expression too complicated, try simplifying");
d1002 1
a1002 1
	    error ("malformed expression");
d1005 1
a1005 1
	    error ("gdb: Internal error: expression has min height < 0");
d1008 1
a1008 1
	    error ("expression too complicated, try simplifying");
d1026 1
a1026 1
	  warning ("'%s': bad step-count; command ignored.", *line);
d1035 1
a1035 1
      warning ("'%s' is not a supported tracepoint action.", *line);
d1156 1
a1156 1
    error ("Internal: register number %d too large for tracepoint",
d1325 1
a1325 1
	      warning ("don't know how to trace local symbol %s", 
d1358 1
a1358 1
    warning ("No %s found in scope.", 
d1538 1
a1538 1
	error ("Bad action list item: %s", action_exp);
d1614 1
a1614 1
			error ("malformed expression");
d1617 1
a1617 1
			error ("gdb: Internal error: expression has min height < 0");
d1619 1
a1619 1
			error ("expression too complicated, try simplifying");
d1756 1
a1756 1
	error ("Target does not support this command.");
d1773 1
a1773 1
	  error ("Target does not support tracepoints.");
d1798 1
a1798 1
		      error ("Error on target while setting tracepoints.");
d1815 1
a1815 1
		      error ("Error on target while setting tracepoints.");
d1828 1
a1828 1
	error ("Bogus reply from target: %s", target_buf);
d1838 1
a1838 1
    error ("Trace can only be run on remote targets.");
d1850 1
a1850 1
	error ("Bogus reply from target: %s", target_buf);
d1856 1
a1856 1
    error ("Trace can only be run on remote targets.");
d1872 1
a1872 1
	error ("Bogus reply from target: %s", target_buf);
d1878 1
a1878 1
    error ("Trace can only be run on remote targets.");
d1926 1
a1926 1
	      error ("Target failed to find requested trace frame.");
d1941 1
a1941 1
	  error ("Target failed to find requested trace frame.");
d1947 1
a1947 1
	  error ("Bogus reply from target: %s", reply);
d1950 1
a1950 1
	error ("Bogus reply from target: %s", reply);
d2027 1
a2027 1
	    error ("not debugging trace buffer");
d2029 1
a2029 1
	    error ("already at start of trace buffer");
d2037 1
a2037 1
	error ("invalid input (%d is less than zero)", frameno);
d2043 1
a2043 1
    error ("Trace can only be run on remote targets.");
d2086 1
a2086 1
    error ("Trace can only be run on remote targets.");
d2100 1
a2100 1
	    error ("No current tracepoint -- please supply an argument.");
d2111 1
a2111 1
    error ("Trace can only be run on remote targets.");
d2186 1
a2186 1
		error ("Cannot find a good line.");
d2193 1
a2193 1
	error ("Line number %d is out of range for \"%s\".\n",
d2211 1
a2211 1
    error ("Trace can only be run on remote targets.");
d2250 1
a2250 1
    error ("Trace can only be run on remote targets.");
d2289 1
a2289 1
    error ("Trace can only be run on remote targets.");
d2304 1
a2304 1
    error ("Argument required (file name in which to save tracepoints");
d2308 1
a2308 1
      warning ("save-tracepoints: no tracepoints to save.\n");
d2314 1
a2314 1
    error ("Unable to open file '%s' for saving tracepoints (%s)",
d2349 1
a2349 1
		  error ("Bad action list item: %s", actionline);
d2377 1
a2377 1
    error ("requires an argument (function, line or *addr) to define a scope");
d2537 1
a2537 1
      error ("Trace can only be run on remote targets.");
d2543 1
a2543 1
      warning ("No current trace frame.");
d2552 1
a2552 1
    error ("No known tracepoint matches 'current' tracepoint #%d.",
d2583 1
a2583 1
	error ("Bad action list item: %s", action_exp);
@


1.69
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (deprecated_set_value_type): Declare.
	* value.c (deprecated_set_value_type): Define.
	* hpacc-abi.c, gnu-v2-abi.c, cp-valprint.c: Update.
	* c-valprint.c, jv-lang.c, objc-lang.c, ada-lang.c: Update.
	* infcall.c, printcmd.c, valops.c, eval.c, p-exp.y: Update.
	* ax-gdb.c, tracepoint.c: Update.
@
text
@d303 1
a303 1
      func_val->modifiable = 0;
d325 1
a325 1
      file_val->modifiable = 0;
@


1.68
log
@2005-02-01  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents_all_raw)
	(value_contents_raw): New functions.
	* value.h (VALUE_CONTENTS_ALL_RAW, VALUE_CONTENTS_RAW): Delete.
	(value_contents_raw, value_contents_all_raw): Declare functions.
	(VALUE_CONTENTS, VALUE_CONTENTS_ALL): Update.
	* std-regs.c, valarith.c, valops.c, eval.c: Update.
	* tracepoint.c, findvar.c: Update.
@
text
@d299 1
a299 1
      func_val->type = func_string;
d321 1
a321 1
      file_val->type = file_string;
@


1.67
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* tracepoint.[ch]: Whitespace tweaks.
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d300 1
a300 1
      memcpy (VALUE_CONTENTS_RAW (func_val),
d322 1
a322 1
      memcpy (VALUE_CONTENTS_RAW (file_val),
@


1.66
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d57 2
a58 2
/* maximum length of an agent aexpression.
   this accounts for the fact that packets are limited to 400 bytes
d194 1
a194 1
/* Utility: wait for reply from stub, while accepting "O" packets */
d199 1
a199 1
  do				/* loop on reply from remote stub */
d240 2
a241 1
		   value_from_longest (builtin_type_int, (LONGEST) num));
d260 1
a260 1
  if (trace_pc == -1)		/* cease debugging any trace buffers */
d270 2
a271 1
		       value_from_longest (builtin_type_int, (LONGEST) - 1));
d275 1
a275 1
  /* save as globals for internal use */
d279 2
a280 1
  /* save linenumber as "$trace_line", a debugger variable visible to users */
d285 2
a286 1
  /* save func name as "$trace_func", a debugger variable visible to users */
d307 2
a308 1
  /* save file name as "$trace_file", a debugger variable visible to users */
d336 2
a337 2
   error(); otherwise it leaves a bogus tracepoint on the chain.  Validate
   your arguments BEFORE calling this routine!  */
d382 1
a382 1
/* Set a tracepoint according to ARG (function, linenum or *address) */
d400 2
a401 1
  sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, &canonical, NULL);
d404 1
a404 1
    return;			/* ??? Presumably decode_line_1 has already warned? */
d436 1
a436 1
/* Tell the user we have just set a tracepoint TP. */
d455 2
a456 1
/* Print information on tracepoint number TPNUM_EXP, or all if omitted.  */
d474 1
a474 1
      extern int addressprint;	/* print machine addresses? */
d548 4
a551 4
/* Optimization: the code to parse an enable, disable, or delete TP command
   is virtually identical except for whether it performs an enable, disable,
   or delete.  Therefore I've combined them into one function with an opcode.
 */
d559 1
a559 1
/* This function implements enable, disable and delete commands. */
d627 2
a628 1
	printf_filtered ("bad tracepoint number at or near '%s'\n", instring);
d647 2
a648 1
/* Utility: parse a list of tracepoint numbers, and call a func for each. */
d661 1
a661 1
	QUIT;			/* give user option to bail out with ^C */
d669 2
a670 1
/* The 'enable trace' command enables tracepoints.  Not supported by all targets.  */
d678 2
a679 1
/* The 'disable trace' command enables tracepoints.  Not supported by all targets.  */
d693 3
a695 2
    if (from_tty)		/* confirm only if from_tty... */
      if (tracepoint_chain)	/* and if there are tracepoints to delete! */
d718 1
a718 1
  count = strtoul (args, &args, 10);	/* count comes first, then TP num */
d725 1
a725 1
      args += 3;			/* skip special argument "all" */
d845 3
a847 2
      /* Make sure that all output has been output.  Some machines may let
         you get away with leaving out some of the gdb_flush, but not all.  */
d899 3
a901 2
		  /* an "end" all by itself with no other actions means
		     this tracepoint has no actions.  Discard empty list. */
d932 2
a933 2
  /* symbol lookup etc. */
  if (*p == '\0')		/* empty line: just prompt for another line. */
d942 2
a943 1
      warning ("'%s' is not an action that I know, or is ambiguous.", p);
d967 1
a967 1
	      /* else fall thru, treat p as an expression and parse it! */
d989 3
a991 2
	  /* we have something to collect, make sure that the expr to
	     bytecode translator can handle it and that it's not too long */
d1119 1
a1119 1
/* Sort the memrange list using qsort, and merge adjacent memranges */
d1149 1
a1149 1
/* Add a register to a collection list */
d1163 2
a1164 1
add_memrange (struct collection_list *memranges, int type, bfd_signed_vma base,
d1176 1
a1176 1
  /* base: addr if memory, offset if reg relative. */
d1188 1
a1188 1
  if (type != -1)		/* better collect the base register! */
d1192 1
a1192 1
/* Add a symbol to a collection list */
d1194 2
a1195 1
collect_symbol (struct collection_list *collect, struct symbol *sym,
d1207 2
a1208 1
		       DEPRECATED_SYMBOL_NAME (sym), SYMBOL_CLASS (sym));
d1222 2
a1223 1
			   DEPRECATED_SYMBOL_NAME (sym), len, tmp /* address */);
d1231 2
a1232 1
	printf_filtered ("LOC_REG[parm] %s: ", DEPRECATED_SYMBOL_NAME (sym));
d1234 2
a1235 2
      /* check for doubles stored in two registers */
      /* FIXME: how about larger types stored in 3 or more regs? */
d1296 2
a1297 1
      printf_filtered ("Don't know LOC_UNRESOLVED %s\n", DEPRECATED_SYMBOL_NAME (sym));
d1334 2
a1335 1
		  collect_symbol (collect, sym, frame_regno, frame_offset);
d1347 2
a1348 1
		  collect_symbol (collect, sym, frame_regno, frame_offset);
d1358 2
a1359 1
    warning ("No %s found in scope.", type == 'L' ? "locals" : "args");
d1459 2
a1460 1
      end = mem2hex (list->aexpr_list[i]->buf, end, list->aexpr_list[i]->len);
d1499 1
a1499 1
/* render all actions into gdb protocol */
d1639 2
a1640 1
				      add_register (collect, ndx1 * 8 + ndx2);
d1666 4
a1669 2
  *tdp_actions = stringify_collection_list (&tracepoint_list, tdp_buff);
  *stepping_actions = stringify_collection_list (&stepping_list, step_buff);
d1705 1
a1705 1
    return;			/* no information to give. */
d1741 1
a1741 1
{				/* STUB_COMM MOSTLY_IMPLEMENTED */
d1749 1
a1749 1
  dont_repeat ();		/* like "run", dangerous to repeat accidentally */
d1763 2
a1764 1
	sprintf (buf, "QTDP:%x:%s:%c:%lx:%x", t->number, tmp, /* address */
d1795 2
a1796 1
		    remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1812 2
a1813 1
		    remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1822 1
a1822 1
      /* Tell target to treat text-like sections as transparent */
d1824 1
a1824 1
      /* Now insert traps and begin collecting data */
d1829 1
a1829 1
      set_traceframe_num (-1);	/* all old traceframes invalidated */
d1844 1
a1844 1
{				/* STUB_COMM IS_IMPLEMENTED */
d1864 1
a1864 1
{				/* STUB_COMM IS_IMPLEMENTED */
d1881 1
a1881 1
/* Worker function for the various flavors of the tfind command */
d1931 2
a1932 1
		/* The following will not recurse, since it's special-cased */
d1934 2
a1935 2
		reply = NULL;	/* break out of loop, 
				   (avoid recursive nonsense) */
d1968 10
a1977 8
         whether we have made a transition from one function to another.
         If so, we'll print the "stack frame" (ie. the new function and
         it's arguments) -- otherwise we'll just show the new source line.

         This determination is made by checking (1) whether the current
         function has changed, and (2) whether the current FP has changed.
         Hack: if the FP wasn't collected, either at the current or the
         previous frame, assume that the FP has NOT changed.  */
d2009 1
a2009 2
{				/* STUB_COMM PART_IMPLEMENTED */
  /* this should only be called with a numeric argument */
d2018 1
a2018 1
	{			/* TFIND with no args means find NEXT trace frame. */
d2070 1
a2070 1
{				/* STUB_COMM PART_IMPLEMENTED */
d2092 1
a2092 1
{				/* STUB_COMM PART_IMPLEMENTED */
d2117 1
a2117 1
   or TRACE (ie. anything that "decode_line_1" can handle).  
d2124 1
a2124 1
{				/* STUB_COMM PART_IMPLEMENTED */
d2153 3
a2155 3
	      /* This is useful for "info line *0x7f34".  If we can't tell the
	         user about a source line, at least let them have the symbolic
	         address.  */
d2164 1
a2164 1
	      return;		/* no line, no PC; what can we do? */
d2191 2
a2192 2
	   which the user would want to see?  If we have debugging symbols
	   and no line numbers?  */
d2198 10
a2207 5
      if (args && *args)	/* find within range of stated line */
	sprintf (target_buf, "QTFrame:range:%s:%s", startpc_str, endpc_str);
      else			/* find OUTSIDE OF range of CURRENT line */
	sprintf (target_buf, "QTFrame:outside:%s:%s", startpc_str, endpc_str);
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2225 1
a2225 1
	{		/* XXX FIXME: what should default behavior be? */
d2264 1
a2264 1
	{		/* XXX FIXME: what should default behavior be? */
d2592 5
a2596 4
	     For the trap frame, display only what was collected at the trap.
	     Likewise for stepping frames, display only what was collected
	     while stepping.  This means that the two boolean variables,
	     STEPPING_FRAME and STEPPING_ACTIONS should be equal.  */
d2736 1
a2736 1
No argument means forward by one frame; '-' meand backward by one frame.",
@


1.65
log
@2004-10-29  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (get_selected_frame): Add message parameter.
	* frame.c (get_selected_frame): Add and use message parameter.
	* stack.c (current_frame_command, return_command, locals_info)
	(catch_info, args_info, up_silently_base, down_silently_base): Use
	get_selected_frame with an explicit message.
	* thread.c, stack.c, sh-tdep.c, sh64-tdep.c: Update.
	* remote-rdp.c, remote-mips.c, remote-e7000.c: Update.
	* ocd.c, mi/mi-main.c, mi/mi-cmd-stack.c: Update.
	* infrun.c, inflow.c, infcmd.c, frame.c: Update.
	* findvar.c, eval.c, corelow.c, bsd-kvm.c: Update.
	* breakpoint.c: Update.
@
text
@d295 1
a295 1
      VALUE_TYPE (func_val) = func_string;
d316 1
a316 1
      VALUE_TYPE (file_val) = file_string;
d1569 1
a1569 1
		      addr = VALUE_ADDRESS (tempval) + VALUE_OFFSET (tempval);
@


1.64
log
@2004-09-13  Andrew Cagney  <cagney@@gnu.org>

	Eliminate event_loop_p, always has the value 1.
	* defs.h (event_loop_p): Delete macro.
	* breakpoint.c (until_break_command): Simplify.
	* utils.c (prompt_for_continue): Simplify.
	* tracepoint.c (read_actions): Simplify.
	* top.c (throw_exception, execute_command, gdb_readline_wrapper)
	(gdb_rl_operate_and_get_next, command_line_input, get_prompt)
	(set_prompt, init_main): Simplify.
	(init_signals, disconnect): Delete, unused.
	* remote.c (remote_async_resume)
	(extended_remote_async_create_inferior): Simplify.
	* mi/mi-interp.c (mi_input): Delete, unused.
	(mi_interpreter_resume, mi_command_loop): Simplify.
	* interps.c (current_interp_command_loop): Simplify.
	* infrun.c (proceed): Simplify.
	* infcmd.c (run_command, continue_command, step_1, jump_command)
	(until_command, advance_command, finish_command)
	(interrupt_target_command): Simplify.
	* event-top.c (gdb_setup_readline, gdb_disable_readline): Simplify.
@
text
@d1952 1
a1952 1
      print_stack_frame (get_selected_frame (), 1, print_what);
@


1.63
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d828 1
a828 6
    {
      if (event_loop_p)
	signal (STOP_SIGNAL, handle_stop_sig);
      else
	signal (STOP_SIGNAL, stop_sig);
    }
@


1.62
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d497 2
a498 3
	    tmp = local_hex_string_custom (t->address
					   & (CORE_ADDR) 0xffffffff, 
					   "08l");
d500 1
a500 1
	    tmp = local_hex_string_custom (t->address, "016l");
@


1.61
log
@	* dsrec.c (load_srec, make_srec): Use bfd_get_section_size instead of
	bfd_get_section_size_before_reloc or _raw_size.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2read.c (dwarf2_locate_sections): Likewise.
	(dwarf2_read_section): Likewise.
	* elfread.c (elf_locate_sections): Likewise.
	* gcore.c (derive_heap_segment): Likewise.
	* mipsread.c (read_alphacoff_dynamic_symtab): Likewise.
	* remote-e7000.c (e7000_load): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* remote-mips.c (mips_load_srec): Likewise.
	(pmon_load_fast): Likewise.
	* remote.c (compare_sections_command): Likewise.
	* symfile.c (add_section_size_callback): Likewise.
	(load_section_callback): Likewise.
	(pc_in_unmapped_range): Likewise.
	(pc_in_mapped_range): Likewise.
	(sections_overlap): Likewise.
	(list_overlays_command): Likewise.
	(simple_overlay_update_1): Likewise.
	(simple_overlay_update): Likewise.
	* tracepoint.c (remote_set_transparent_ranges): Likewise.
	* win32-nat.c (core_section_load_dll_symbols): Likewise.
@
text
@d1222 1
a1222 1
	  len > DEPRECATED_REGISTER_RAW_SIZE (reg))
@


1.60
log
@2004-05-07  Michael Snyder  <msnyder@@redhat.com>

        * tracepoint.c (scope_info): Add handling for LOC_COMPUTED,
        LOC_COMPUTED_ARG, and LOC_INDIRECT.
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.
d1696 1
a1696 1
      size = bfd_get_section_size_before_reloc (s);
@


1.59
log
@2004-04-28  Andrew Cagney  <cagney@@redhat.com>

	* stack.c (print_stack_frame_stub): Delete declaration.
	(struct print_stack_frame_args, print_stack_frame)
	(print_frame_info, print_frame): Replace "source" with print what.
	Replace "print" with "print_level".  Replace "args" with
	"print_args".
	* frame.h (show_and_print_stack_frame, print_stack_frame)
	(print_frame_info): Update declarations.
	* stack.c (select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Update calls -
	use get_selected_frame, pass "enum print_what" for source, do not
	call frame_relative_level.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames): Ditto.
	* remote-rdp.c (remote_rdp_open): Ditto.
	* remote-mips.c (common_open): Ditto.
	* remote-e7000.c (e7000_start_remote): Ditto.
	* ocd.c (ocd_start_remote): Ditto.
	* mi/mi-main.c (mi_cmd_exec_return): Ditto.
	* infrun.c (normal_stop): Ditto.
	* inflow.c (kill_command): Ditto.
	* infcmd.c (finish_command): Ditto.
	* corelow.c (core_open): Ditto.
	* tracepoint.c (finish_tfind_command): Ditto.
	* thread.c (info_threads_command, info_threads_command)
	(restore_current_thread, do_captured_thread_select): Ditto.
	* ada-tasks.c (task_command): Ditto.
@
text
@d2348 1
a2348 1
    return;			/* presumably decode_line_1 has already warned */
d2390 2
a2391 1
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 1, gdb_stdout);
d2423 2
a2424 1
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 1, gdb_stdout);
d2428 2
a2429 2
	      print_address_numeric (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)), 1,
				     gdb_stdout);
d2442 2
a2443 1
	      msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), NULL, NULL);
d2456 12
d2471 1
a2471 1
			   TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym))));
@


1.58
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d1938 1
a1938 1
      int source_only;
d1954 1
a1954 1
	source_only = -1;
d1956 1
a1956 1
	source_only = 1;
d1958 1
a1958 3
      print_stack_frame (deprecated_selected_frame,
			 frame_relative_level (deprecated_selected_frame),
			 source_only);
@


1.57
log
@2004-02-28  Andrew Cagney  <cagney@@redhat.com>

	* utils.c: Use "", instead of <>, to include readline.
	tui/tui-win.c, tui/tui.c, tui/tui-hooks.c: Ditto.
	* tracepoint.c, top.c, symmisc.c, symfile.c: Ditto.
	* source.c, solib.c, exec.c, event-top.c: Ditto.
	* corelow.c, completer.c, cli/cli-setshow.c: Ditto.
	* cli/cli-dump.c, cli/cli-cmds.c: Ditto.
	* Makefile.in: Update all dependencies.
	(readline_tilde_h, readline_history_h): Define.
	(readline_headers): Delete.
@
text
@d68 3
a70 3
extern void (*readline_begin_hook) (char *, ...);
extern char *(*readline_hook) (char *);
extern void (*readline_end_hook) (void);
d790 2
a791 2
	  if (readline_begin_hook)
	    (*readline_begin_hook) ("%s  %s\n", tmpbuf, end_msg);
d800 2
a801 2
      if (readline_end_hook)
	(*readline_end_hook) ();
d845 2
a846 2
      if (readline_hook && instream == NULL)
	line = (*readline_hook) (prompt);
d1807 2
a1808 2
      if (trace_start_stop_hook)
	trace_start_stop_hook (1, from_tty);
d1826 2
a1827 2
      if (trace_start_stop_hook)
	trace_start_stop_hook (0, from_tty);
d1988 2
a1989 2
      if (trace_find_hook)
	trace_find_hook (args, from_tty);
@


1.56
log
@2004-01-02  Pawel Ostrowski  <pasza@@zodiac.mimuw.edu.pl>

        * tracepoint.c (validate_actionline): Fix segv at EOF
@
text
@d47 2
a48 2
#include <readline/readline.h>
#include <readline/history.h>
@


1.56.6.1
log
@Merge mainline to intercu branch.
@
text
@d47 2
a48 2
#include "readline/readline.h"
#include "readline/history.h"
@


1.56.6.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d68 3
a70 3
extern void (*deprecated_readline_begin_hook) (char *, ...);
extern char *(*deprecated_readline_hook) (char *);
extern void (*deprecated_readline_end_hook) (void);
d497 3
a499 2
	    tmp = hex_string_custom (t->address & (CORE_ADDR) 0xffffffff, 
				     8);
d501 1
a501 1
	    tmp = hex_string_custom (t->address, 16);
d790 2
a791 2
	  if (deprecated_readline_begin_hook)
	    (*deprecated_readline_begin_hook) ("%s  %s\n", tmpbuf, end_msg);
d800 2
a801 2
      if (deprecated_readline_end_hook)
	(*deprecated_readline_end_hook) ();
d829 6
a834 1
    signal (STOP_SIGNAL, handle_stop_sig);
d845 2
a846 2
      if (deprecated_readline_hook && instream == NULL)
	line = (*deprecated_readline_hook) (prompt);
d1222 1
a1222 1
	  len > register_size (current_gdbarch, reg))
d1696 1
a1696 1
      size = bfd_get_section_size (s);
d1807 2
a1808 2
      if (deprecated_trace_start_stop_hook)
	deprecated_trace_start_stop_hook (1, from_tty);
d1826 2
a1827 2
      if (deprecated_trace_start_stop_hook)
	deprecated_trace_start_stop_hook (0, from_tty);
d1938 1
a1938 1
      enum print_what print_what;
d1954 1
a1954 1
	print_what = SRC_LINE;
d1956 1
a1956 1
	print_what = SRC_AND_LOC;
d1958 3
a1960 1
      print_stack_frame (get_selected_frame (), 1, print_what);
d1988 2
a1989 2
      if (deprecated_trace_find_hook)
	deprecated_trace_find_hook (args, from_tty);
d2350 1
a2350 1
    return;		/* presumably decode_line_1 has already warned */
d2392 1
a2392 2
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 
				     1, gdb_stdout);
d2424 1
a2424 2
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 
				     1, gdb_stdout);
d2428 2
a2429 2
	      print_address_numeric (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)),
				     1, gdb_stdout);
d2442 1
a2442 2
	      msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), 
					    NULL, NULL);
a2454 12
	    case LOC_HP_THREAD_LOCAL_STATIC:
	      printf_filtered ("HP thread local static ");
	      break;
	    case LOC_INDIRECT:
	      printf_filtered ("extern (local indirect) at address ");
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 
				     1, gdb_stdout);
	      break;
	    case LOC_COMPUTED:
	    case LOC_COMPUTED_ARG:
	      SYMBOL_OPS (sym)->describe_location (sym, gdb_stdout);
	      break;
d2458 1
a2458 1
			     TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym))));
@


1.55
log
@
2003-12-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * linespec.h (decode_line_1): Add new not_found_ptr parameter.
        * linespec.c (decode_line_1): Add new parameter.  Pass on
        new parameter to decode_variable and symtab_from_filename
        functions.
        (decode_variable): Add new not_found_ptr parameter.  Throw exception
        rather than failing if the not_found_ptr is non-null and the
        function is not found.
        (symtab_from_filename): Add new not_found_ptr parametr.   Throw
        exception rather than failing if the not_found_ptr is non-null and
        the source file is not found.
        * breakpoint.c: Change all callers of decode_line_1 to add default
        extra parameter for decode_line_1 calls.
        * tracepoint.c: Ditto.
        * cli/cli-cmds.c: Ditto.
@
text
@d917 4
@


1.54
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d395 1
a395 1
  sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, &canonical);
d2344 1
a2344 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical);
@


1.53
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d1218 1
a1218 1
	  len > REGISTER_RAW_SIZE (reg))
@


1.52
log
@2003-08-21  Michael Snyder  <msnyder@@redhat.com>

        * tracepoint.c (trace_dump_command): Trace break address
	is subject to DECR_PC_AFTER_BREAK.
        (set_traceframe_context): Make "trace_line" an int.
        Fixes suggested	by Mark	Newman	 <mark.newman@@lmco.com>
@
text
@d337 1
a337 1
  register struct tracepoint *t, *tc;
@


1.51
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@d269 1
a269 1
		       value_from_pointer (builtin_type_int, (LONGEST) - 1));
d2514 1
a2514 1
  stepping_frame = (t->address != read_pc ());
@


1.50
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Add comments on MAX_REGISTER_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Delete macro.
	(legacy_max_register_virtual_size): Delete declaration.
	* infcmd.c (default_print_registers_info): Use MAX_REGISTER_SIZE.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.
	* tracepoint.c (memrange_sortmerge): Ditto.
	* sparc-tdep.c (sparc_print_registers): Ditto.
	* regcache.c (legacy_max_register_virtual_size): Delete function.
@
text
@d41 1
d1293 2
a1294 1
  int i, count = 0;
d1300 1
a1300 1
      ALL_BLOCK_SYMBOLS (block, i, sym)
d2338 2
a2339 1
  int i, j, count = 0;
d2355 1
a2355 1
      ALL_BLOCK_SYMBOLS (block, i, sym)
@


1.50.8.1
log
@Snap const char * mess.
@
text
@d128 18
a145 18
static void trace_command (const char *, int);
static void tracepoints_info (const char *, int);
static void delete_trace_command (const char *, int);
static void enable_trace_command (const char *, int);
static void disable_trace_command (const char *, int);
static void trace_pass_command (const char *, int);
static void trace_actions_command (const char *, int);
static void trace_start_command (const char *, int);
static void trace_stop_command (const char *, int);
static void trace_status_command (const char *, int);
static void trace_find_command (const char *, int);
static void trace_find_pc_command (const char *, int);
static void trace_find_tracepoint_command (const char *, int);
static void trace_find_line_command (const char *, int);
static void trace_find_range_command (const char *, int);
static void trace_find_outside_command (const char *, int);
static void tracepoint_save_command (const char *, int);
static void trace_dump_command (const char *, int);
d195 2
a196 1
remote_get_noisy_reply (const char *buf, long sizeof_buf)
d378 1
a378 1
trace_command (const char *arg, int from_tty)
d384 1
a384 2
  const char *addr_start = 0;
  const char *addr_end = 0;
d451 1
a451 1
tracepoints_info (const char *tpnum_exp, int from_tty)
d601 1
a601 1
get_tracepoint_by_number (const char **arg, int multi_p, int optional_p)
d605 1
a605 1
  const char *instring = arg == NULL ? NULL : *arg;
d641 1
a641 1
map_args_over_tracepoints (const char *args, int from_tty,
d662 1
a662 1
enable_trace_command (const char *args, int from_tty)
d670 1
a670 1
disable_trace_command (const char *args, int from_tty)
d678 1
a678 1
delete_trace_command (const char *args, int from_tty)
d697 1
a697 1
trace_pass_command (const char *args, int from_tty)
d756 1
a756 1
end_actions_pseudocommand (const char *args, int from_tty)
d762 1
a762 1
while_stepping_pseudocommand (const char *args, int from_tty)
d768 1
a768 1
collect_pseudocommand (const char *args, int from_tty)
d775 1
a775 1
trace_actions_command (const char *args, int from_tty)
d914 1
a914 1
  const char *p;
d1002 1
a1002 1
      const char *steparg;		/* in case warning is necessary */
d1479 1
a1479 1
  const char *action_exp;
d1711 1
a1711 1
trace_start_command (const char *args, int from_tty)
d1811 1
a1811 1
trace_stop_command (const char *args, int from_tty)
d1831 1
a1831 1
trace_status_command (const char *args, int from_tty)
d1851 1
a1851 1
finish_tfind_command (const char *msg,
d1975 1
a1975 1
trace_find_command (const char *args, int from_tty)
d2016 1
a2016 1
trace_find_end_command (const char *args, int from_tty)
d2023 1
a2023 1
trace_find_none_command (const char *args, int from_tty)
d2030 1
a2030 1
trace_find_start_command (const char *args, int from_tty)
d2037 1
a2037 1
trace_find_pc_command (const char *args, int from_tty)
d2059 1
a2059 1
trace_find_tracepoint_command (const char *args, int from_tty)
d2091 1
a2091 1
trace_find_line_command (const char *args, int from_tty)
d2179 1
a2179 1
trace_find_range_command (const char *args, int from_tty)
d2218 1
a2218 1
trace_find_outside_command (const char *args, int from_tty)
d2257 1
a2257 1
tracepoint_save_command (const char *args, int from_tty)
d2473 1
a2473 1
trace_dump_command (const char *args, int from_tty)
d2477 1
a2477 1
  const char *action_exp, *next_comma;
@


1.49
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d1118 1
a1118 1
	      MAX_REGISTER_VIRTUAL_SIZE)
@


1.49.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1118 1
a1118 1
	      MAX_REGISTER_SIZE)
@


1.48
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d283 1
a283 1
      SYMBOL_NAME (traceframe_fun) == NULL)
d288 1
a288 1
      len = strlen (SYMBOL_NAME (traceframe_fun));
d296 1
a296 1
	      SYMBOL_NAME (traceframe_fun),
d963 1
a963 1
			   SYMBOL_NAME (exp->elts[2].symbol),
d970 1
a970 1
			   SYMBOL_NAME (exp->elts[2].symbol));
d1190 1
a1190 1
		       SYMBOL_NAME (sym), SYMBOL_CLASS (sym));
d1194 1
a1194 1
		       SYMBOL_NAME (sym), SYMBOL_VALUE (sym));
d1204 1
a1204 1
			   SYMBOL_NAME (sym), len, tmp /* address */);
d1212 1
a1212 1
	printf_filtered ("LOC_REG[parm] %s: ", SYMBOL_NAME (sym));
d1223 1
a1223 1
		       SYMBOL_NAME (sym));
d1231 1
a1231 1
			   SYMBOL_NAME (sym), len);
d1243 1
a1243 1
			   SYMBOL_NAME (sym), len);
d1256 1
a1256 1
			   SYMBOL_NAME (sym), len);
d1269 1
a1269 1
			   SYMBOL_NAME (sym), len);
d1276 1
a1276 1
      printf_filtered ("Don't know LOC_UNRESOLVED %s\n", SYMBOL_NAME (sym));
d1280 1
a1280 1
		       SYMBOL_NAME (sym));
d1304 1
a1304 1
		       SYMBOL_NAME (sym));
d2359 1
a2359 1
	  symname = SYMBOL_NAME (sym);
d2435 1
a2435 1
	      msym = lookup_minimal_symbol (SYMBOL_NAME (sym), NULL, NULL);
@


1.47
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software
d512 1
a512 1
	      fputs_filtered (SYMBOL_SOURCE_NAME (sym), gdb_stdout);
@


1.46
log
@* tracepoint.c (ISATTY): Removed.
@
text
@d40 1
@


1.45
log
@2002-12-07  Andrew Cagney  <ac131313@@redhat.com>

	* f-valprint.c (info_common_command): Use get_frame_pc.
	* std-regs.c (value_of_builtin_frame_pc_reg): Ditto.
	* ax-gdb.c (agent_command): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	(rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc, frame_get_saved_regs): Ditto.
	(frame_initial_stack_address, rs6000_frame_chain): Ditto.
	* macroscope.c (default_macro_scope): Ditto.
	* stack.c (print_frame_info_base): Ditto.
	(print_frame, frame_info, print_frame_label_vars): Ditto.
	(return_command, func_command, get_frame_language): Ditto.
	* infcmd.c (finish_command): Ditto.
	* dummy-frame.c (cached_find_dummy_frame): Ditto.
	* breakpoint.c (deprecated_frame_in_dummy): Ditto.
	(break_at_finish_at_depth_command_1): Ditto.
	(break_at_finish_command_1): Ditto.
	(until_break_command, get_catch_sals): Ditto.
	* blockframe.c (func_frame_chain_valid): Ditto.
	(frameless_look_for_prologue): Ditto.
	(frame_address_in_block, generic_func_frame_chain_valid): Ditto.
@
text
@a76 6
/* If this definition isn't overridden by the header files, assume
   that isatty and fileno exist on this system.  */
#ifndef ISATTY
#define ISATTY(FP)	(isatty (fileno (FP)))
#endif

@


1.44
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d2108 1
a2108 1
	  sal = find_pc_line ((get_current_frame ())->pc, 0);
@


1.43
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d1957 2
a1958 1
      print_stack_frame (selected_frame, frame_relative_level (selected_frame),
@


1.42
log
@2002-10-02  Elena Zannoni  <ezannoni@@redhat.com>

        * inferior.h (registers_info, stepi_command, nexti_command,
        continue_command, interrupt_target_command): Export from infcmd.c.
        * frame.h (args_info, selected_frame_level_changed_hook,
        return_command): Export from stack.c.
        * v850ice.c (stepi_command, nexti_command, continue_command): use
        prototypes from inferior.h.
        * tracepoint.c (registers_info, args_info, locals_info): Use
        prototypes from frame.h and inferior.h.
        * Makefile.in (mi-main.o): Add dependency on frame.h.

2002-10-02  Elena Zannoni  <ezannoni@@redhat.com>

        * mi-main.c (mi_cmd_exec_return): Don't use
        return_command_wrapper, use return_command instead.
        (mi_cmd_exec_interrupt): Don't use
        interrupt_target_command_wrapper, use interrupt_target_command
        instead.
        (return_command_wrapper, interrupt_target_command_wrapper):
        Delete.
        Include frame.h.

2002-10-02  Elena Zannoni  <ezannoni@@redhat.com>

        * tui-hooks.c (selected_frame_level_changed_hook): Use the one
        exported from frame.h.
@
text
@d1865 1
a1865 1
  old_frame_addr = FRAME_FP (get_current_frame ());
d1951 2
a1952 2
	   FRAME_FP (get_current_frame ()) == 0 ||
	   old_frame_addr == FRAME_FP (get_current_frame ())))
@


1.42.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
a39 2
#include "block.h"
#include "dictionary.h"
d77 6
d273 1
a273 1
		       value_from_longest (builtin_type_int, (LONGEST) - 1));
d288 1
a288 1
      DEPRECATED_SYMBOL_NAME (traceframe_fun) == NULL)
d293 1
a293 1
      len = strlen (DEPRECATED_SYMBOL_NAME (traceframe_fun));
d301 1
a301 1
	      DEPRECATED_SYMBOL_NAME (traceframe_fun),
d341 1
a341 1
  struct tracepoint *t, *tc;
d517 1
a517 1
	      fputs_filtered (SYMBOL_PRINT_NAME (sym), gdb_stdout);
d968 1
a968 1
			   DEPRECATED_SYMBOL_NAME (exp->elts[2].symbol),
d975 1
a975 1
			   DEPRECATED_SYMBOL_NAME (exp->elts[2].symbol));
d1123 1
a1123 1
	      MAX_REGISTER_SIZE)
d1195 1
a1195 1
		       DEPRECATED_SYMBOL_NAME (sym), SYMBOL_CLASS (sym));
d1199 1
a1199 1
		       DEPRECATED_SYMBOL_NAME (sym), SYMBOL_VALUE (sym));
d1209 1
a1209 1
			   DEPRECATED_SYMBOL_NAME (sym), len, tmp /* address */);
d1217 1
a1217 1
	printf_filtered ("LOC_REG[parm] %s: ", DEPRECATED_SYMBOL_NAME (sym));
d1222 1
a1222 1
	  len > DEPRECATED_REGISTER_RAW_SIZE (reg))
d1228 1
a1228 1
		       DEPRECATED_SYMBOL_NAME (sym));
d1236 1
a1236 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1248 1
a1248 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1261 1
a1261 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1274 1
a1274 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1281 1
a1281 1
      printf_filtered ("Don't know LOC_UNRESOLVED %s\n", DEPRECATED_SYMBOL_NAME (sym));
d1285 1
a1285 1
		       DEPRECATED_SYMBOL_NAME (sym));
d1297 1
a1297 2
  struct dict_iterator iter;
  int count = 0;
d1303 1
a1303 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d1309 1
a1309 1
		       DEPRECATED_SYMBOL_NAME (sym));
d1865 1
a1865 1
  old_frame_addr = get_frame_base (get_current_frame ());
d1951 2
a1952 2
	   get_frame_base (get_current_frame ()) == 0 ||
	   old_frame_addr == get_frame_base (get_current_frame ())))
d1957 1
a1957 2
      print_stack_frame (deprecated_selected_frame,
			 frame_relative_level (deprecated_selected_frame),
d2107 1
a2107 1
	  sal = find_pc_line (get_frame_pc (get_current_frame ()), 0);
d2340 1
a2340 2
  struct dict_iterator iter;
  int j, count = 0;
d2356 1
a2356 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d2363 1
a2363 1
	  symname = DEPRECATED_SYMBOL_NAME (sym);
d2439 1
a2439 1
	      msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), NULL, NULL);
d2515 1
a2515 1
  stepping_frame = (t->address != (read_pc () - DECR_PC_AFTER_BREAK));
@


1.42.2.2
log
@Merge from mainline.
@
text
@d395 1
a395 1
  sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, &canonical, NULL);
d2344 1
a2344 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical, NULL);
@


1.42.2.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@a916 4
  /* if EOF is typed, *line is NULL */
  if (*line == NULL)
    return END;

@


1.41
log
@        * exec.c (xfer_memory): Fix compilation warning with old versions
        of GCC.
        * tracepoint.c (trace_find_tracepoint_command): Likewise.
@
text
@a75 4
extern void registers_info (char *, int);
extern void args_info (char *, int);
extern void locals_info (char *, int);

@


1.41.2.1
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@a39 1
#include "dictionary.h"
d1301 1
a1301 2
  struct dict_iterator iter;
  int count = 0;
d1307 1
a1307 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d2344 1
a2344 2
  struct dict_iterator iter;
  int j, count = 0;
d2360 1
a2360 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
@


1.41.2.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d77 4
@


1.41.2.3
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a24 1
#include "block.h"
@


1.41.2.4
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d519 1
a519 1
	      fputs_filtered (SYMBOL_PRINT_NAME (sym), gdb_stdout);
@


1.41.2.5
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1868 1
a1868 1
  old_frame_addr = get_frame_base (get_current_frame ());
d1954 2
a1955 2
	   get_frame_base (get_current_frame ()) == 0 ||
	   old_frame_addr == get_frame_base (get_current_frame ())))
d1960 1
a1960 2
      print_stack_frame (deprecated_selected_frame,
			 frame_relative_level (deprecated_selected_frame),
d2110 1
a2110 1
	  sal = find_pc_line (get_frame_pc (get_current_frame ()), 0);
@


1.41.2.6
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d79 6
@


1.41.2.7
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
d25 1
a40 1
#include "block.h"
d284 1
a284 1
      DEPRECATED_SYMBOL_NAME (traceframe_fun) == NULL)
d289 1
a289 1
      len = strlen (DEPRECATED_SYMBOL_NAME (traceframe_fun));
d297 1
a297 1
	      DEPRECATED_SYMBOL_NAME (traceframe_fun),
d964 1
a964 1
			   DEPRECATED_SYMBOL_NAME (exp->elts[2].symbol),
d971 1
a971 1
			   DEPRECATED_SYMBOL_NAME (exp->elts[2].symbol));
d1191 1
a1191 1
		       DEPRECATED_SYMBOL_NAME (sym), SYMBOL_CLASS (sym));
d1195 1
a1195 1
		       DEPRECATED_SYMBOL_NAME (sym), SYMBOL_VALUE (sym));
d1205 1
a1205 1
			   DEPRECATED_SYMBOL_NAME (sym), len, tmp /* address */);
d1213 1
a1213 1
	printf_filtered ("LOC_REG[parm] %s: ", DEPRECATED_SYMBOL_NAME (sym));
d1224 1
a1224 1
		       DEPRECATED_SYMBOL_NAME (sym));
d1232 1
a1232 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1244 1
a1244 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1257 1
a1257 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1270 1
a1270 1
			   DEPRECATED_SYMBOL_NAME (sym), len);
d1277 1
a1277 1
      printf_filtered ("Don't know LOC_UNRESOLVED %s\n", DEPRECATED_SYMBOL_NAME (sym));
d1281 1
a1281 1
		       DEPRECATED_SYMBOL_NAME (sym));
d1306 1
a1306 1
		       DEPRECATED_SYMBOL_NAME (sym));
d2362 1
a2362 1
	  symname = DEPRECATED_SYMBOL_NAME (sym);
d2438 1
a2438 1
	      msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (sym), NULL, NULL);
@


1.41.2.8
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d2438 1
a2438 1
	      msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym), NULL, NULL);
@


1.41.2.9
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1119 1
a1119 1
	      MAX_REGISTER_SIZE)
@


1.41.2.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d269 1
a269 1
		       value_from_longest (builtin_type_int, (LONGEST) - 1));
d337 1
a337 1
  struct tracepoint *t, *tc;
d2514 1
a2514 1
  stepping_frame = (t->address != (read_pc () - DECR_PC_AFTER_BREAK));
@


1.41.2.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1218 1
a1218 1
	  len > DEPRECATED_REGISTER_RAW_SIZE (reg))
@


1.41.2.12
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d395 1
a395 1
  sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, &canonical, NULL);
a916 4
  /* if EOF is typed, *line is NULL */
  if (*line == NULL)
    return END;

d2344 1
a2344 1
  sals = decode_line_1 (&args, 1, NULL, 0, &canonical, NULL);
@


1.40
log
@	* defs.h (gdb_readline_wrapper): Declare.
	* utils.c (prompt_for_continue): Use gdb_readline_wrapper.
	* tracepoint.c (read_actions): Use gdb_readline_wrapper.
	* top.c (gdb_readline_wrapper): New function.
	(command_line_input): Use it.
@
text
@d2074 6
a2079 4
	if (tracepoint_number == -1)
	  error ("No current tracepoint -- please supply an argument.");
	else
	  tdp = tracepoint_number;	/* default is current TDP */
@


1.39
log
@* language.c (local_hex_string_custom): Simplify.  Do not depend
on PRINTF_HAS_LONG_LONG or CC_HAS_LONG_LONG.

* memattr.c (mem_info_command): Replace calls to
longest_local_hex_string and longest_local_hex_string_custom.
* buildsym.c (make_blockvector): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* symtab.c (print_msymbol_info): Ditto.

* language.c (local_hex_string): Delete.
(local_hex_string_custom): Delete.
(longest_local_hex_string): Rename to local_hex_string.
(longest_local_hex_string_custom): Rename to
local_hex_string_custom.
* language.h (local_hex_string): Change parameter type to LONGEST.
(local_hex_string_custom): Ditto.
(longest_local_hex_string): Delete declaration.
(longest_local_hex_string_custom): Ditto.

* solib.c: Update copyright.
* memattr.c: Update copyright.
@
text
@d857 1
a857 1
	  line = readline (prompt);
@


1.39.4.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d857 1
a857 1
	  line = gdb_readline_wrapper (prompt);
@


1.39.4.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d2074 4
a2077 6
	{
	  if (tracepoint_number == -1)
	    error ("No current tracepoint -- please supply an argument.");
	  else
	    tdp = tracepoint_number;	/* default is current TDP */
	}
@


1.39.4.3
log
@merge from mainline
@
text
@d76 4
@


1.38
log
@* frame.h (select_frame): Delete level parameter.
* stack.c (select_frame): Update.  Use frame_relative_level to
obtain the frame's level.
(select_and_print_frame): Update call.
(select_frame_command): Ditto.
(up_silently_base): Ditto.
(down_silently_base): Ditto.
* ocd.c (ocd_start_remote): Ditto.
* remote-rdp.c (remote_rdp_open): Ditto.
* remote-mips.c (mips_initialize): Ditto.
(common_open): Ditto.
* remote-e7000.c (e7000_start_remote): Ditto.
* m3-nat.c (select_thread): Ditto.
* hppa-tdep.c (child_get_current_exception_event): Ditto.
(child_get_current_exception_event): Ditto.
* varobj.c (varobj_create): Ditto.
(varobj_update): Ditto.
(c_value_of_root): Ditto.
* tracepoint.c (finish_tfind_command): Ditto.
* corelow.c (core_open): Ditto.
* arch-utils.c (generic_prepare_to_proceed): Ditto.
* thread.c (info_threads_command): Ditto.
(switch_to_thread): Ditto.
* infrun.c (normal_stop): Ditto.
(restore_selected_frame): Ditto.
(restore_inferior_status): Ditto.
* breakpoint.c (insert_breakpoints): Ditto.
(watchpoint_check): Ditto.
(bpstat_stop_status): Ditto.
(do_enable_breakpoint): Ditto.
* blockframe.c (flush_cached_frames): Ditto.
(reinit_frame_cache): Ditto.
@
text
@d505 3
a507 3
	    tmp = longest_local_hex_string_custom (t->address
						   & (CORE_ADDR) 0xffffffff, 
						   "08l");
d509 1
a509 1
	    tmp = longest_local_hex_string_custom (t->address, "016l");
@


1.37
log
@* frame.h (selected_frame_level): Document as deprecated.
(frame_relative_level): Declare.
* stack.c (frame_relative_level): New function.
(selected_frame_level): Document as deprecated.
(select_frame): Do not set the selected_frame_level.

* stack.c (frame_info, record_selected_frame): Update.
(frame_command, current_frame_command): Update.
(up_silently_base, up_command, down_silently_base): Update.
(down_command): Update.
* inflow.c (kill_command): Update.
* tracepoint.c (finish_tfind_command): Update.
* corelow.c (core_open): Update.
* thread.c (info_threads_command): Update.
(do_captured_thread_select): Update.
* infcmd.c (finish_command): Update.
* breakpoint.c (insert_breakpoints, do_enable_breakpoint): Update.
@
text
@d1931 1
a1931 1
  select_frame (get_current_frame (), 0);
@


1.36
log
@s/strerror/safe_strerror/
@
text
@d1961 2
a1962 1
      print_stack_frame (selected_frame, selected_frame_level, source_only);
@


1.35
log
@* defs.h (error): Add printf format attribute.
* thread-db.c (thread_from_lwp): Fix error format string.
* stack.c (parse_frame_specification): Ditto.
* cli/cli-decode.c (undef_cmd_error): Ditto.
* scm-lang.c (scm_lookup_name): Ditto.
* tracepoint.c (trace_error): Ditto.
* remote-utils.c (usage): Ditto.
* remote.c (compare_sections_command): Ditto.
Fix PR gdb/328.
@
text
@d2283 1
a2283 1
	   args, strerror (errno));
@


1.34
log
@* cli/cli-decode.c (set_cmd_completer): New function.
* command.h (set_cmd_completer): Declare.
* cli/cli-decode.h (set_cmd_completer): Ditto.

* breakpoint.c (_initialize_breakpoint): Use set_cmd_completer.
* cli/cli-cmds.c (init_cli_cmds): Ditto.
* win32-nat.c (_initialize_inftarg): Ditto.
* remote-rdi.c (_initialize_remote_rdi): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* hppa-tdep.c (_initialize_hppa_tdep): Ditto.
* source.c (_initialize_source): Ditto.
* exec.c (_initialize_exec): Ditto.
* solib.c (_initialize_solib): Ditto.
* top.c (init_main): Ditto.
* tracepoint.c (_initialize_tracepoint): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* printcmd.c (_initialize_printcmd): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
@
text
@d193 1
a193 1
	error ("tracepoint.c: error in outgoing packet at field #%d.",
@


1.33
log
@* cli/cli-decode.c (cmd_cfunc_eq): New function.
* command.h (cmd_cfunc_eq): Declare.
* cli/cli-decode.h (cmd_cfunc_eq): Ditto.

* cli/cli-cmds.h (is_complete_command): Change parameter to a
``struct cmd_list_element *''.
* cli/cli-cmds.c (is_complete_command): Update.  Use
cmd_cfunc_eq.
* top.c (execute_command): Pass the command to
is_complete_command.
* tracepoint.c: Replace function.cfunc with cmd_cfunc_eq.
@
text
@d2680 1
a2680 1
  c->completer = filename_completer;
d2803 1
a2803 1
  c->completer = location_completer;
@


1.32
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@d942 1
a942 1
  if (c->function.cfunc == collect_pseudocommand)
d1009 1
a1009 1
  else if (c->function.cfunc == while_stepping_pseudocommand)
d1025 1
a1025 1
  else if (c->function.cfunc == end_actions_pseudocommand)
d1523 1
a1523 1
      if (cmd->function.cfunc == collect_pseudocommand)
d1633 1
a1633 1
      else if (cmd->function.cfunc == while_stepping_pseudocommand)
d1637 1
a1637 1
      else if (cmd->function.cfunc == end_actions_pseudocommand)
d2318 1
a2318 1
		if (cmd->function.cfunc == while_stepping_pseudocommand)
d2320 1
a2320 1
		else if (cmd->function.cfunc == end_actions_pseudocommand)
d2537 1
a2537 1
      if (cmd->function.cfunc == while_stepping_pseudocommand)
d2539 1
a2539 1
      else if (cmd->function.cfunc == end_actions_pseudocommand)
d2541 1
a2541 1
      else if (cmd->function.cfunc == collect_pseudocommand)
@


1.31
log
@s/NO_FUNCTION/NULL/
@
text
@d2 3
a4 1
   Copyright 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.30
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* tracepoint.c (tracepoint_save_command): From Klee Deines --
	use tilde_expand and strerror for opening save-tracepoints file.
@
text
@d2664 1
a2664 1
  add_cmd ("tracepoints", class_trace, NO_FUNCTION,
@


1.29
log
@* cli/cli-script.c (execute_control_command): Replace value_ptr
with a struct value pointer.
* ch-lang.c (evaluate_subexp_chill): Ditto.
* printcmd.c (printf_command): Ditto.
* tracepoint.c (set_traceframe_context): Ditto.
(encode_actions): Ditto.
* eval.c (evaluate_subexp_standard): Ditto.
@
text
@d2266 1
a2266 1
  char *indent, *actionline;
d2278 6
a2283 3
  if (!(fp = fopen (args, "w")))
    error ("Unable to open file '%s' for saving tracepoints");

@


1.28
log
@	2001-11-06  Fred Fish  <fnf@@redhat.com>
	* complaints.c (info_verbose): Remove unneeded decl, is in defs.h.
	* dbxread.c: Ditto
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* exec.c: Ditto.
	* hpread.c: Ditto.
	* hpread.h: Ditto.
	* mdebugread.c: Ditto.
	* os9kread.c: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* tracepoint.c: Ditto.
@
text
@d257 2
a258 1
  static value_ptr func_val, file_val;
d1490 1
a1490 1
  value_ptr tempval;
@


1.27
log
@2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (struct block): (ALL_BLOCK_SYMBOLS): New macro.

        * symtab.c (find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
        (make_symbol_completion_list): Likewise.
        (make_symbol_overload_list): Likewise.
        * buildsym.c (finish_block): Likewise.
        * breakpoint.c (get_catch_sals):  Likewise.
        * mdebugread.c (mylookup_symbol): Likewise.
        * objfiles.c (objfile_relocate): Likewise.
        * printcmd.c (print_frame_args): Likewise.
        * stack.c (print_block_frame_locals): Likewise.
        (print_block_frame_labels): Likewise.
        (print_frame_arg_vars): Likewise.
        * symmisc.c (dump_symtab): Likewise.
        * tracepoint.c (add_local_symbols): Likewise.
        (scope_info): Likewise.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * mi-cmd-stack.c (list_args_or_locals): Use ALL_BLOCK_SYMBOLS.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Use ALL_BLOCK_SYMBOLS.
        * generic/gdbtk-stack.c (gdb_block_vars): Likewise.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
5~
@
text
@a63 1
extern int info_verbose;
@


1.26
log
@* tracepoint.c (read_actions): Add FIXME for code depending on
STOP_SIGNAL.
@
text
@d1299 1
a1299 1
  int i, nsyms, count = 0;
d1305 1
a1305 2
      nsyms = BLOCK_NSYMS (block);
      for (i = 0; i < nsyms; i++)
a1306 1
	  sym = BLOCK_SYM (block, i);
d2336 1
a2336 1
  int i, j, nsyms, count = 0;
d2352 1
a2352 2
      nsyms = BLOCK_NSYMS (block);
      for (i = 0; i < nsyms; i++)
d2358 1
a2358 1
	  sym = BLOCK_SYM (block, i);
@


1.25
log
@* target.h (TARGET_VIRTUAL_FRAME_POINTER): Delete, multi-arched.
* gdbarch.sh (TARGET_VIRTUAL_FRAME_POINTER): Add.
* gdbarch.h, gdbarch.c: Regenerate.

* arch-utils.h (legacy_virtual_frame_pointer): Declare.
* arch-utils.c: Include "gdb_assert.h".
(legacy_virtual_frame_pointer): Define.
* Makefile.in (arch-utils.o): Depends on gdb_assert.h.

* tracepoint.c (encode_actions): Make frame_reg an int.  Make
frame_offset a LONGEST.
* ax-gdb.c (gen_frame_args_address): Ditto.
(gen_frame_locals_address): Ditto.
* mn10300-tdep.c (mn10300_gdbarch_init): Initialize
virtual_frame_pointer.
(mn10300_virtual_frame_pointer): Make static.  Update parameter
list to match function signature.
* config/mn10300/tm-mn10300.h (TARGET_VIRTUAL_FRAME_POINTER): Delete.
@
text
@d828 5
@


1.24
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".
	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d1491 2
a1492 1
  long frame_reg, frame_offset;
@


1.23
log
@	* tracepoint.c (trace_command): We now have tracepoint
	events. Get rid of those ugly hooks.
	(tracepoint_operation): Likewise.
	(trace_pass_command): Likewise.
@
text
@d360 1
a360 1
  t->enabled = enabled;
d497 1
a497 1
		       t->enabled == enabled ? "y" : "n");
d572 1
a572 1
      t->enabled = enabled;
d576 1
a576 1
      t->enabled = disabled;
d1738 1
a1738 1
		 t->enabled == enabled ? 'E' : 'D',
@


1.23.4.1
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".

	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d360 1
a360 1
  t->enabled_p = 1;
d497 1
a497 1
		       t->enabled_p ? "y" : "n");
d572 1
a572 1
      t->enabled_p = 1;
d576 1
a576 1
      t->enabled_p = 0;
d1738 1
a1738 1
		 t->enabled_p ? 'E' : 'D',
@


1.23.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d257 1
a257 1
  static struct range_type *func_range, *file_range;
d296 1
a296 1
      func_range = make_range_type (NULL, 
d298 1
a298 1
      func_string = (struct type *)make_array_type (NULL, 
d317 1
a317 1
      file_range = make_range_type (NULL, 
d319 1
a319 1
      file_string = (struct type *)make_array_type (NULL,  
@


1.22
log
@	* completer.c (gdb_completer_loc_break_characters): New variable.
	(line_completion_function): If we are completing on locations,
	back up the start of word pointer past all characters which can
	appear in a location spec.
	(location_completer): New function.

	* completer.h: Add prototype for location_completer.

	* symtab.c (make_source_files_completion_list)
	(add_filename_to_list, not_interesting_fname): New functions.
	(filename_seen): New function, body extracted from
	output_source_filename.
	(output_source_filename): Call filename_seen to check if the file
	was already printed.
	(make_symbol_completion_list): If TEXT includes a
	double-quoted string, return an empty list, not NULL.
	(make_file_symbol_completion_list): New function, similar to
	make_symbol_completion_list but with an additional argument
	SRCFILE.

	* symtab.h (make_file_symbol_completion_list)
	(make_source_files_completion_list): Add prototypes.

	* breakpoint.c (_initialize_breakpoint): Make location_completer
	be the completion function for all commands which set breakpoints
	and watchpoints.
	(top-level): #include "completer.h".

	* tracepoint.c (_initialize_tracepoint): Make location_completer
	be the completion function for the "trace" command.
	(top-level): #include "completer.h".

	* printcmd.c (_initialize_printcmd): Make location_completer be
	the completion function for the "print", "inspect", "call", and
	"disassemble" commands.
	(top-level): #include "completer.h".

	* infcmd.c (_initialize_infcmd): Make location_completer be the
	completion function for the "go", "jump", and "until" commands.
	(top-level): #include "completer.h".
@
text
@a426 4

      /* Let the UI know of any additions */
      if (create_tracepoint_hook)
	create_tracepoint_hook (t);
a572 2
      if (modify_tracepoint_hook)
	modify_tracepoint_hook (t);
a576 2
      if (modify_tracepoint_hook)
	modify_tracepoint_hook (t);
a590 4
      /* Let the UI know of any deletions */
      if (delete_tracepoint_hook)
	delete_tracepoint_hook (t);

a735 2
		if (modify_tracepoint_hook)
		  modify_tracepoint_hook (t2);
@


1.21
log
@	* tracepoint.c (tracepoint_opertation): Add ui event
	notifications.
	(trace_pass_command): Ditto.
@
text
@d36 1
d2803 2
a2804 2
  add_com ("trace", class_trace, trace_command,
	   "Set a tracepoint at a specified line or function or address.\n\
d2809 1
@


1.20
log
@2001-04-17  Michael Snyder  <msnyder@@redhat.com>

        * breakpoint.c (print_one_breakpoint): Handle 64-bit addresses.
	* tracepoint.c (tracepoints_info): Handle 64-bit addresses.
        * testsuite/gdb.trace/deltrace.exp: Allow for 64-bit addresses.
	* testsuite/gdb.trace/infotrace.exp: Ditto.
        * testsuite/gdb.trace/passcount.exp: Ditto.
	* testsuite/gdb.trace/while-stepping.exp: Ditto.
@
text
@d36 1
d578 1
d584 1
d593 1
d749 1
@


1.19
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d481 6
a486 1
	    printf_filtered ("Address    ");
d491 6
a496 1
	strcat (wrap_indent, "           ");
d501 12
a512 3
	printf_filtered ("%s ",
			 local_hex_string_custom ((unsigned long) t->address,
						  "08l"));
d1564 2
a1565 1
		  exp = parse_exp_1 (&action_exp, block_for_pc (t->address), 1);
@


1.18
log
@Update/correct copyright notices.
@
text
@a34 1
#include "completer.h"
@


1.17
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2001 Free Software Foundation, Inc.
@


1.16
log
@	* demangle.c (demangling_style_names): New variable.
	(_initialize_demangler): Fill demangling_style_names with the
	names of known demangling styles from libiberty_demanglers[].  Use
	add_set_enum_cmd instead of add_set_cmd, to get completion on
	demangling style names.

	* proc-api.c (_initialize_proc_api): Make `procfs-file' use
	file-name completion.

	* remote-rdi.c (_initialize_remote_rdi): Ditto for `rdilogfile'.

	* solib.c (_initialize_solib): Ditto for `solib-search-path' and
	`solib-absolute-prefix'.

	* tracepoint.c (_initialize_tracepoint): Ditto for
	`save-tracepoints'.

	* win32-nat.c (_initialize_inftarg): Ditto for `dll-symbols'.

	* cli/cli-cmds.c (init_cli_cmds): Make `shell' and `make' use
	file-name completion.

	* infcmd.c (_initialize_infcmd): Make the following commands use
	the file-name completer: `tty', `args', `path', `paths', and
	`run'.
@
text
@d2 1
a2 1
   Copyright 1997, 1998 Free Software Foundation, Inc.
d36 1
@


1.15
log
@Replace free() with xfree().
@
text
@d35 1
d2604 2
d2657 2
a2658 2
  add_com ("save-tracepoints", class_trace, tracepoint_save_command,
	   "Save current tracepoint definitions as a script.\n\
d2660 1
@


1.14
log
@2000-11-30  Fernando Nasser  <fnasser@@redhat.com>

        * linespec.h: New file. Declarations for linespec.c.
        * linespec.c, alpha-tdep.c, breakpoint.c, parse.c, source.c,
        symtab.c, tracepoint.c: Include the above.
        * completer.c: New file. Line completion stuff for GDB.
        (get_gdb_completer_word_break_characters,
        get_gdb_completer_quote_characters): New functions. Accessors for
        useful completer internal data.
        (filename_completer, line_completion_function, skip_quoted): Moved
        here from top.c.
        * completer.h: New file. Declarations for the above.
        * linespec.c (decode_line_1): Use
        get_gdb_completer_word_break_characters and
        get_gdb_completer_quote_characters.
        * top.c: Include completer.h.
        (filename_completer, line_completion_function, skip_quoted):
        Moved to completer.c.
        * corefile.c, exec.c, source.c, symfile.c, linespec.c: Include
        completer.h.
        * Makefile.in (SFILES): Add completer.c.
        (COMMON_OBS): Add completer.o.
        (completer.o): New target.
        (linespec.o, alpha-tdep.o, breakpoint.o, parse.o, source.o,
        symtab.o, tracepoint.o): Add linespec.h to dependencies list.
        (corefile.o, exec.o, source.o, symfile.o, linespec.o): Add completer.h
        to dependencies list.
@
text
@d344 1
a344 1
  old_chain = make_cleanup (free, t);
d579 1
a579 1
	free (t->addr_string);
d581 1
a581 1
	free (t->source_file);
d585 1
a585 1
      free (t);
d974 1
a974 1
	  (void) make_cleanup (free, areqs.reg_mask);
d1025 2
a1026 2
	free (line->action);
      free (line);
d1460 1
a1460 1
    free (actions_list[ndx]);
d1462 1
a1462 1
  free (actions_list);
d2101 1
a2101 1
      old_chain = make_cleanup (free, sals.sals);
@


1.13
log
@	* tracepoint.c (trace_find_tracepoint_command): Replace call to
	parse_and_eval_address with a call to parse_and_eval_long as
	we are evaluating an integer, not an address.
	* top.c (show_commands): Ditto.
@
text
@d34 1
@


1.12
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d2058 1
a2058 1
	tdp = parse_and_eval_address (args);
@


1.11
log
@	* eval.c (parse_and_eval_long): New function.
	* value.h: Declare it.

	* breakpoint.c (breakpoints_info, maintenance_info_breakpoints):
	Call parse_and_eval_long, not parse_and_eval_address.
	* command.c (do_setshow_command): Ditto.
	* infcmd.c (step_1, signal_command, continue_command): Ditto.
	* infrun.c (signals_info): Ditto.
	* stack.c (set_backtrace_limit_command, backtrace_command_1,
	up_silently_base, down_silently_base): Ditto.
	* tracepoints.c (tracepoints_info, trace_find_command,
 	trace_find_tracepoint_command): Ditto.
	* valprint.c (set_radix): Ditto.
	* values.c (show_values): Ditto.
@
text
@d1268 1
a1268 1
      printf_filtered ("%s has been optimized out of existance.\n",
@


1.10
log
@* dcache.c (dcache_info): Output a cache line's state vector so it
lines up under the data vector.

* dcache.c (dcache_read_line): New function.
(dcache_peek_byte): Use it.
(dcache_alloc): Return NULL if write of reclaimed cache line fails.
(dcache_peek_byte, dcache_poke_byte): Return failure if
dcache_alloc() returns a NULL data block pointer.
(dcache_xfer_memory): Don't force writeback unless we were writing.

* monitor.c (monitor_expect): Change places where immediate_quit
is set to 1 or 0 to increments and decrements respectively.  This
allows such changes to nest properly.
* ocd.c (ocd_start_remote): Likewise.
* remote-adapt.c (expect): Likewise.
* remote-array.c (expect): Likewise.
* remote-eb.c (expect): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-mips.c (mips_expect_timeout, mips_getstring): Likewise.
* remote-nrom.c (expect): Likewise.
* remote-os9k.c (expect): Likewise.
* remote-sds.c (sds_start_remote): Likewise.
* remote-st.c (expect): Likewise.
* remote-utils.c (sr_expect): Likewise.
* remote.c (remote_start_remote): Likewise.
* tracepoint.c (read_actions): Likewise.

* remote-mips.c (mips_getstring): Balance changes to immediate_quit.
@
text
@d468 1
a468 1
    tpnum = parse_and_eval_address (tpnum_exp);
d1989 1
a1989 1
	frameno = parse_and_eval_address (args);
@


1.9
log
@* top.c (get_prompt_1), tracepoint.c (replace_comma): Update
function signatures so that they match catch_errors and
make_cleanup callbacks.
* tracepoint.c (encode_actions): Fix arguments passed to
stringify_collection_list.
@
text
@d892 1
a892 1
  immediate_quit = 0;
@


1.8
log
@Protoization.
@
text
@d1628 2
a1629 2
  *tdp_actions = stringify_collection_list (&tracepoint_list, &tdp_buff);
  *stepping_actions = stringify_collection_list (&stepping_list, &step_buff);
d2448 1
a2448 1
replace_comma (char *comma)
d2450 1
@


1.7
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d167 1
a167 1
target_is_remote ()
d178 1
a178 2
trace_error (buf)
     char *buf;
d221 1
a221 2
set_tracepoint_count (num)
     int num;
d230 1
a230 2
set_traceframe_num (num)
     int num;
d239 1
a239 2
set_tracepoint_num (num)
     int num;
d250 1
a250 2
set_traceframe_context (trace_pc)
     CORE_ADDR trace_pc;
d337 1
a337 2
set_raw_tracepoint (sal)
     struct symtab_and_line sal;
d381 1
a381 3
trace_command (arg, from_tty)
     char *arg;
     int from_tty;
d439 1
a439 2
trace_mention (tp)
     struct tracepoint *tp;
d458 1
a458 3
tracepoints_info (tpnum_exp, from_tty)
     char *tpnum_exp;
     int from_tty;
d542 2
a543 4
tracepoint_operation (t, from_tty, opcode)
     struct tracepoint *t;
     int from_tty;
     enum tracepoint_opcode opcode;
d594 1
a594 3
get_tracepoint_by_number (arg, multi_p, optional_p)
     char **arg;
     int multi_p, optional_p;
d634 2
a635 4
map_args_over_tracepoints (args, from_tty, opcode)
     char *args;
     int from_tty;
     enum tracepoint_opcode opcode;
d655 1
a655 3
enable_trace_command (args, from_tty)
     char *args;
     int from_tty;
d663 1
a663 3
disable_trace_command (args, from_tty)
     char *args;
     int from_tty;
d671 1
a671 3
delete_trace_command (args, from_tty)
     char *args;
     int from_tty;
d690 1
a690 3
trace_pass_command (args, from_tty)
     char *args;
     int from_tty;
d750 1
a750 3
end_actions_pseudocommand (args, from_tty)
     char *args;
     int from_tty;
d756 1
a756 3
while_stepping_pseudocommand (args, from_tty)
     char *args;
     int from_tty;
d762 1
a762 3
collect_pseudocommand (args, from_tty)
     char *args;
     int from_tty;
d769 1
a769 3
trace_actions_command (args, from_tty)
     char *args;
     int from_tty;
d802 1
a802 2
read_actions (t)
     struct tracepoint *t;
d898 1
a898 3
validate_actionline (line, t)
     char **line;
     struct tracepoint *t;
d1016 1
a1016 2
free_actions (t)
     struct tracepoint *t;
d1068 1
a1068 3
memrange_cmp (va, vb)
     const void *va;
     const void *vb;
d1095 1
a1095 2
memrange_sortmerge (memranges)
     struct collection_list *memranges;
d1125 1
a1125 3
add_register (collection, regno)
     struct collection_list *collection;
     unsigned int regno;
d1137 2
a1138 5
add_memrange (memranges, type, base, len)
     struct collection_list *memranges;
     int type;
     bfd_signed_vma base;
     unsigned long len;
d1167 2
a1168 5
collect_symbol (collect, sym, frame_regno, frame_offset)
     struct collection_list *collect;
     struct symbol *sym;
     long frame_regno;
     long frame_offset;
d1276 2
a1277 6
add_local_symbols (collect, pc, frame_regno, frame_offset, type)
     struct collection_list *collect;
     CORE_ADDR pc;
     long frame_regno;
     long frame_offset;
     int type;
d1330 1
a1330 2
clear_collection_list (list)
     struct collection_list *list;
d1346 1
a1346 3
stringify_collection_list (list, string)
     struct collection_list *list;
     char *string;
d1445 1
a1445 2
free_actions_list_cleanup_wrapper (al)
     void *al;
d1451 1
a1451 2
free_actions_list (actions_list)
     char **actions_list;
d1466 2
a1467 4
encode_actions (t, tdp_actions, stepping_actions)
     struct tracepoint *t;
     char ***tdp_actions;
     char ***stepping_actions;
d1633 1
a1633 3
add_aexpr (collect, aexpr)
     struct collection_list *collect;
     struct agent_expr *aexpr;
d1700 1
a1700 3
trace_start_command (args, from_tty)
     char *args;
     int from_tty;
d1800 1
a1800 3
trace_stop_command (args, from_tty)
     char *args;
     int from_tty;
d1820 1
a1820 3
trace_status_command (args, from_tty)
     char *args;
     int from_tty;
d1962 1
a1962 3
trace_find_command (args, from_tty)
     char *args;
     int from_tty;
d2003 1
a2003 3
trace_find_end_command (args, from_tty)
     char *args;
     int from_tty;
d2010 1
a2010 3
trace_find_none_command (args, from_tty)
     char *args;
     int from_tty;
d2017 1
a2017 3
trace_find_start_command (args, from_tty)
     char *args;
     int from_tty;
d2024 1
a2024 3
trace_find_pc_command (args, from_tty)
     char *args;
     int from_tty;
d2046 1
a2046 3
trace_find_tracepoint_command (args, from_tty)
     char *args;
     int from_tty;
d2076 1
a2076 3
trace_find_line_command (args, from_tty)
     char *args;
     int from_tty;
d2164 1
a2164 3
trace_find_range_command (args, from_tty)
     char *args;
     int from_tty;
d2203 1
a2203 3
trace_find_outside_command (args, from_tty)
     char *args;
     int from_tty;
d2242 1
a2242 3
tracepoint_save_command (args, from_tty)
     char *args;
     int from_tty;
d2311 1
a2311 3
scope_info (args, from_tty)
     char *args;
     int from_tty;
d2448 1
a2448 2
replace_comma (comma)
     char *comma;
d2455 1
a2455 3
trace_dump_command (args, from_tty)
     char *args;
     int from_tty;
d2573 1
a2573 4
mem2hex (mem, buf, count)
     unsigned char *mem;
     unsigned char *buf;
     int count;
d2591 1
a2591 1
get_traceframe_number ()
d2599 1
a2599 1
_initialize_tracepoint ()
@


1.6
log
@PARAMS removal.
@
text
@d61 3
a63 3
extern void (*readline_begin_hook) PARAMS ((char *,...));
extern char *(*readline_hook) PARAMS ((char *));
extern void (*readline_end_hook) PARAMS ((void));
@


1.5
log
@Purge (almost) make_cleanup_func.
@
text
@d64 1
a64 1
extern void x_command PARAMS ((char *, int));
d70 4
a73 4
extern void output_command PARAMS ((char *, int));
extern void registers_info PARAMS ((char *, int));
extern void args_info      PARAMS ((char *, int));
extern void locals_info    PARAMS ((char *, int));
d132 18
a149 18
static void trace_command PARAMS ((char *, int));
static void tracepoints_info PARAMS ((char *, int));
static void delete_trace_command PARAMS ((char *, int));
static void enable_trace_command PARAMS ((char *, int));
static void disable_trace_command PARAMS ((char *, int));
static void trace_pass_command PARAMS ((char *, int));
static void trace_actions_command PARAMS ((char *, int));
static void trace_start_command PARAMS ((char *, int));
static void trace_stop_command PARAMS ((char *, int));
static void trace_status_command PARAMS ((char *, int));
static void trace_find_command PARAMS ((char *, int));
static void trace_find_pc_command PARAMS ((char *, int));
static void trace_find_tracepoint_command PARAMS ((char *, int));
static void trace_find_line_command PARAMS ((char *, int));
static void trace_find_range_command PARAMS ((char *, int));
static void trace_find_outside_command PARAMS ((char *, int));
static void tracepoint_save_command PARAMS ((char *, int));
static void trace_dump_command PARAMS ((char *, int));
d152 1
a152 1
static void trace_mention PARAMS ((struct tracepoint *));
d155 1
a155 1
static void add_aexpr PARAMS ((struct collection_list *, struct agent_expr *));
d157 2
a158 2
static void add_register PARAMS ((struct collection_list * collection, 
				  unsigned int regno));
d160 2
a161 2
static void free_actions_list PARAMS ((char **actions_list));
static void free_actions_list_cleanup_wrapper PARAMS ((void *));
d163 1
a163 1
extern void _initialize_tracepoint PARAMS ((void));
d763 1
a763 1
static void read_actions PARAMS ((struct tracepoint *));
d1101 1
a1101 1
static int memrange_cmp PARAMS ((const void *, const void *));
@


1.4
log
@Cleanup free_agent_expr cleanups.
@
text
@d159 1
d858 1
a858 1
  old_chain = make_cleanup ((make_cleanup_func) free_actions, (void *) t);
d1067 12
d1603 1
a1603 2
		  old_chain = make_cleanup ((make_cleanup_func)
					    free_current_contents, &exp);
@


1.3
log
@	* ax-gdb.c (agent_command): Remove now useless cast of
	`free_current_contents' when passed to `make_cleanup'.
	* coffread.c (coff_symfile_read): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn, read_array_type): Ditto.
	(dwarf_decode_lines): Ditto.
	* eval.c (parse_and_eval_address, parse_and_eval_address_1): Ditto.
	(parse_and_eval, parse_to_comma_and_eval): Ditto.
	* parse.c (parse_exp_1): Ditto.
	* printcmd.c (print_command_1, output_command, set_command): Ditto.
	(x_command, print_frame_args, printf_command): Ditto.
	* top.c (execute_control_command): Ditto.
	* tracepoint.c (validate_actionline): Ditto.
	* typeprint.c (whatis_exp, ptype_command): Ditto.
	(maintenance_print_type): Ditto.
@
text
@d1002 1
a1002 1
	  (void) make_cleanup ((make_cleanup_func) free_agent_expr, aexpr);
d1620 1
a1620 2
		      old_chain1 = make_cleanup ((make_cleanup_func)
						 free_agent_expr, aexpr);
@


1.2
log
@* gdbarch.sh (POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Two new
functions which architectures can redefine, defaulting to
generic_pointer_to_address and generic_address_to_pointer.
* findvar.c (extract_typed_address, store_typed_address,
generic_pointer_to_address, generic_address_to_pointer): New
functions.
(POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Provide default
definitions.
(extract_address, store_address): Doc fixes.
* values.c (value_as_pointer): Doc fix.
(value_from_pointer): New function.
* defs.h (extract_typed_address, store_typed_address): New
declarations.
* inferior.h (generic_address_to_pointer,
generic_pointer_to_address): New declarations.
* value.h (value_from_pointer): New declaration.

* ax-gdb.c (const_var_ref): Use value_from_pointer, not
value_from_longest.
* blockframe.c (generic_push_dummy_frame): Use read_pc and
read_sp, not read_register.
* c-valprint.c (c_val_print): Use extract_typed_address instead of
extract_address to extract vtable entries and references.
* cp-valprint.c (cp_print_value_fields): Use value_from_pointer
instead of value_from_longest to extract the vtable's address.
* eval.c (evaluate_subexp_standard): Use value_from_pointer
instead of value_from_longest to compute `this', and for doing
pointer-to-member dereferencing.
* findvar.c (read_register): Use extract_unsigned_integer, not
extract_address.
(read_var_value): Use store_typed_address instead of store_address
for building label values.
(locate_var_value): Use value_from_pointer instead of
value_from_longest.
* hppa-tdep.c (find_stub_with_shl_get): Use value_from_pointer,
instead of value_from_longest, to build arguments to __d_shl_get.
* printcmd.c (set_next_address): Use value_from_pointer, not
value_from_longest.
(x_command): Use value_from_pointer, not value_from_longest.
* tracepoint.c (set_traceframe_context): Use value_from_pointer,
not value_from_longest.
* valarith.c (value_add, value_sub): Use value_from_pointer, not
value_from_longest.
* valops.c (find_function_in_inferior, value_coerce_array,
value_coerce_function, value_addr, hand_function_call): Same.
* value.h (COERCE_REF): Use unpack_pointer, not unpack_long.
* values.c (unpack_long): Use extract_typed_address to produce
addresses from pointers and references, not extract_address.
(value_from_longest): Use store_typed_address instead of
store_address to produce pointer and reference values.
@
text
@d980 1
a980 2
	  old_chain = make_cleanup ((make_cleanup_func) free_current_contents,
				    &exp);
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a23 1
#include "tracepoint.h"
d31 3
d54 1
a54 1
   
d61 2
a62 2
extern void (*readline_begin_hook) PARAMS ((char *, ...));
extern char * (*readline_hook) PARAMS ((char *));
d65 10
a74 1
extern int addressprint;		/* Print machine addresses? */
d105 1
a105 1
   */
d132 12
a143 12
static void trace_command                 PARAMS ((char *, int));
static void tracepoints_info              PARAMS ((char *, int));
static void delete_trace_command          PARAMS ((char *, int));
static void enable_trace_command          PARAMS ((char *, int));
static void disable_trace_command         PARAMS ((char *, int));
static void trace_pass_command            PARAMS ((char *, int));
static void trace_actions_command         PARAMS ((char *, int));
static void trace_start_command           PARAMS ((char *, int));
static void trace_stop_command            PARAMS ((char *, int));
static void trace_status_command          PARAMS ((char *, int));
static void trace_find_command            PARAMS ((char *, int));
static void trace_find_pc_command         PARAMS ((char *, int));
d145 5
a149 5
static void trace_find_line_command       PARAMS ((char *, int));
static void trace_find_range_command      PARAMS ((char *, int));
static void trace_find_outside_command    PARAMS ((char *, int));
static void tracepoint_save_command       PARAMS ((char *, int));
static void trace_dump_command            PARAMS ((char *, int));
d152 1
a152 1
static void trace_mention                 PARAMS ((struct tracepoint *));
d156 7
a162 1
static unsigned char *mem2hex(unsigned char *, unsigned char *, int);
d176 1
a176 1
static void 
d182 1
a182 1
  switch (*buf) 
d188 1
a188 1
	error ("tracepoint.c: error in outgoing packet at field #%d.", 
d199 2
a200 2
remote_get_noisy_reply (buf)
     char *buf;
d202 1
a202 1
  do	/* loop on reply from remote stub */
d204 2
a205 2
      QUIT;				/* allow user to bail out with ^C */
      getpkt (buf, 0);
d214 3
a216 2
	return buf;				/* here's the actual reply */
    } while (1);
d257 2
a258 2
  static struct type *func_range,  *file_range;
  static value_ptr    func_val,     file_val;
d265 1
a265 1
  if (trace_pc == -1)	/* cease debugging any trace buffers */
d270 4
a273 4
      set_internalvar (lookup_internalvar ("trace_func"), 
		       value_from_longest (charstar, (LONGEST) 0));
      set_internalvar (lookup_internalvar ("trace_file"), 
		       value_from_longest (charstar, (LONGEST) 0));
d275 1
a275 1
		       value_from_longest (builtin_type_int, (LONGEST) -1));
d285 1
a285 1
		   value_from_longest (builtin_type_int, 
d289 1
a289 1
  if (traceframe_fun == NULL || 
d291 2
a292 2
    set_internalvar (lookup_internalvar ("trace_func"), 
		     value_from_longest (charstar, (LONGEST) 0));
d296 3
a298 3
      func_range  = create_range_type (func_range,  
				       builtin_type_int, 0, len - 1);
      func_string = create_array_type (func_string, 
d302 2
a303 2
      memcpy (VALUE_CONTENTS_RAW (func_val), 
	      SYMBOL_NAME (traceframe_fun), 
d310 1
a310 1
  if (traceframe_sal.symtab == NULL || 
d312 2
a313 2
    set_internalvar (lookup_internalvar ("trace_file"), 
		     value_from_longest (charstar, (LONGEST) 0));
d317 3
a319 3
      file_range  = create_range_type (file_range,  
				       builtin_type_int, 0, len - 1);
      file_string = create_array_type (file_string, 
d323 2
a324 2
      memcpy (VALUE_CONTENTS_RAW (file_val), 
	      traceframe_sal.symtab->filename, 
d354 1
a354 1
    t->source_file = savestring (sal.symtab->filename, 
d357 2
a358 2
  t->section     = sal.section;
  t->language    = current_language->la_language;
d361 4
a364 4
  t->enabled     = enabled;
  t->next        = 0;
  t->step_count  = 0;
  t->pass_count  = 0;
d390 1
a390 1
  char **canonical = (char **)NULL;
d404 4
a407 4
  sals = decode_line_1 (&arg, 1, (struct symtab *)NULL, 0, &canonical);
  addr_end   = arg;
  if (! sals.nelts) 
    return;	/* ??? Presumably decode_line_1 has already warned? */
d423 2
a424 2
	 command string.  */
      if (canonical != (char **)NULL && canonical[i] != NULL)
d482 2
a483 2
      {
	extern int addressprint;	/* print machine addresses? */
d485 18
a502 18
	if (!found_a_tracepoint++)
	  {
	    printf_filtered ("Num Enb ");
	    if (addressprint)
	      printf_filtered ("Address    ");
	    printf_filtered ("PassC StepC What\n");
	  }
	strcpy (wrap_indent, "                           ");
	if (addressprint)
	  strcat (wrap_indent, "           ");

	printf_filtered ("%-3d %-3s ", t->number, 
			 t->enabled == enabled ? "y" : "n");
	if (addressprint)
	  printf_filtered ("%s ", 
			   local_hex_string_custom ((unsigned long) t->address,
						    "08l"));
	printf_filtered ("%-5d %-5d ", t->pass_count, t->step_count);
d504 15
a518 15
	if (t->source_file)
	  {
	    sym = find_pc_sect_function (t->address, t->section);
	    if (sym)
	      {
		fputs_filtered ("in ", gdb_stdout);
		fputs_filtered (SYMBOL_SOURCE_NAME (sym), gdb_stdout);
		wrap_here (wrap_indent);
		fputs_filtered (" at ", gdb_stdout);
	      }
	    fputs_filtered (t->source_file, gdb_stdout);
	    printf_filtered (":%d", t->line_number);
	  }
	else
	  print_address_symbolic (t->address, gdb_stdout, demangle, " ");
d520 10
a529 10
	printf_filtered ("\n");
	if (t->actions)
	  {
	    printf_filtered ("  Actions for tracepoint %d: \n", t->number);
	    for (action = t->actions; action; action = action->next)
	      {
		printf_filtered ("\t%s\n", action->action);
	      }
	  }
      }
d533 1
a533 1
        printf_filtered ("No tracepoints.\n");
d535 1
a535 1
        printf_filtered ("No tracepoint number %d.\n", tpnum);
d542 2
a543 2
   */
enum tracepoint_opcode 
d545 3
a547 3
  enable, 
  disable,
  delete
d550 1
a550 1
/* This function implements enable, disable and delete. */
d559 18
a576 14
  switch (opcode) {
  case enable:
    t->enabled = enabled;
    if (modify_tracepoint_hook)
      modify_tracepoint_hook (t);
    break;
  case disable:
    t->enabled = disabled;
    if (modify_tracepoint_hook)
      modify_tracepoint_hook (t);
    break;
  case delete:
    if (tracepoint_chain == t)
      tracepoint_chain = t->next;
d578 2
a579 2
    ALL_TRACEPOINTS (t2)
      if (t2->next == t)
d585 10
a594 10
    /* Let the UI know of any deletions */
    if (delete_tracepoint_hook)
      delete_tracepoint_hook (t);

    if (t->addr_string)
      free (t->addr_string);
    if (t->source_file)
      free (t->source_file);
    if (t->actions)
      free_actions (t);
d596 3
a598 3
    free (t);
    break;
  }
d601 4
a604 1
/* Utility: parse a tracepoint number and look it up in the list.  */
d606 1
a606 1
get_tracepoint_by_number (arg)
d608 1
a610 2
  char *end, *copy;
  value_ptr val;
d612 1
d614 9
a622 2
  if (arg == 0)
    error ("Bad tracepoint argument");
d624 7
a630 25
  if (*arg == 0 || **arg == 0)	/* empty arg means refer to last tp */
    tpnum = tracepoint_count;
  else if (**arg == '$')	/* handle convenience variable */
    {
      /* Make a copy of the name, so we can null-terminate it
	 to pass to lookup_internalvar().  */
      end = *arg + 1;
      while (isalnum(*end) || *end == '_')
	end++;
      copy = (char *) alloca (end - *arg);
      strncpy (copy, *arg + 1, (end - *arg - 1));
      copy[end - *arg - 1] = '\0';
      *arg = end;

      val = value_of_internalvar (lookup_internalvar (copy));
      if (TYPE_CODE( VALUE_TYPE (val)) != TYPE_CODE_INT)
	error ("Convenience variable must have integral type.");
      tpnum = (int) value_as_long (val);
    }
  else		/* handle tracepoint number */
    {
      tpnum = strtol (*arg, arg, 0);
      if (tpnum == 0)		/* possible strtol failure */
	while (**arg && !isspace (**arg))
	  (*arg)++;		/* advance to next white space, if any */
d632 1
d635 7
a641 3
      {
	return t;
      }
a653 2
  int tpnum;
  char *cp;
d661 3
a663 3
	QUIT;		/* give user option to bail out with ^C */
	if (t = get_tracepoint_by_number (&args))
	  tracepoint_operation (t, from_tty, opcode);
d676 1
a676 1
  map_args_over_tracepoints (args, from_tty, enable);
d686 1
a686 1
  map_args_over_tracepoints (args, from_tty, disable);
d698 1
a698 1
      if (tracepoint_chain) 	/* and if there are tracepoints to delete! */
d702 1
a702 1
  map_args_over_tracepoints (args, from_tty, delete);
d717 2
a718 1
  unsigned long count;
d721 1
a721 1
    error ("PASS command requires an argument (count + optional TP num)");
d725 1
a725 1
  while (*args && isspace (*args))
d729 6
a734 1
    args += 3;	/* skip special argument "all" */
d736 1
a736 1
    t1 = get_tracepoint_by_number (&args);
d738 19
a756 16
  if (*args)
    error ("Junk at end of arguments.");

  if (t1 == NULL)
    return;	/* error, bad tracepoint number */

  ALL_TRACEPOINTS (t2)
    if (t1 == (struct tracepoint *) -1 || t1 == t2)
      {
	t2->pass_count = count;
        if (modify_tracepoint_hook)
          modify_tracepoint_hook (t2);
	if (from_tty)
	  printf_filtered ("Setting tracepoint %d's passcount to %d\n", 
			   t2->number, count);
      }
d762 1
a762 6
static void  read_actions PARAMS((struct tracepoint *));
static char *parse_and_eval_memrange PARAMS ((char *,
					      CORE_ADDR, 
					      long *,
					      bfd_signed_vma *,
					      long *));
d765 3
a767 3
   	collect_pseudocommand, 
	while_stepping_pseudocommand, and 
	end_actions_pseudocommand
d773 1
a773 1
static void 
a803 1
  char *actions;
d807 2
a808 1
  if (t = get_tracepoint_by_number (&args))
a826 1

d829 1
a829 1
  /* else error, just return; */
d850 6
a855 1
    signal (STOP_SIGNAL, stop_sig);
d861 1
a861 1
	 you get away with leaving out some of the gdb_flush, but not all.  */
d871 1
a871 1
	  if (line && *line)		/* add it to command history */
d879 1
a879 1
	continue;	/* already warned -- collect another line */
d894 9
a902 7
	if (prompt == prompt2)
	  {
	    warning ("Already processing 'while-stepping'");
	    continue;
	  }
	else
	  prompt = prompt2;	/* change prompt for stepping actions */
d904 16
a919 14
	if (prompt == prompt2)
	  {
	    prompt = prompt1;	/* end of single-stepping actions */
	  }
	else
	  { /* end of actions */
	    if (t->actions->next == NULL)
	      {
		/* an "end" all by itself with no other actions means
		   this tracepoint has no actions.  Discard empty list. */
		free_actions (t);
	      }
	    break;
	  }
a936 1
  value_ptr temp, temp2;
d940 1
a940 1
  for (p = *line; isspace (*p); )
d944 1
a944 1
  if (*p == '\0')	/* empty line: just prompt for another line. */
d947 1
a947 1
  if (*p == '#')	/* comment line */
d956 1
a956 1
    
d962 5
a966 22
      do {			/* repeat over a comma-separated list */
	QUIT;			/* allow user to bail out with ^C */
	while (isspace (*p))
	  p++;

	if (*p == '$')			/* look for special pseudo-symbols */
	  {
	    long typecode, size;
	    bfd_signed_vma offset;

	    if ((0 == strncasecmp ("reg", p + 1, 3)) ||
		(0 == strncasecmp ("arg", p + 1, 3)) ||
		(0 == strncasecmp ("loc", p + 1, 3)))
	      {
		p = strchr (p, ',');
		continue;
	      }
	    /* else fall thru, treat p as an expression and parse it! */
	  }
	exp   = parse_exp_1 (&p, block_for_pc (t->address), 1);
	old_chain = make_cleanup ((make_cleanup_func) free_current_contents, 
                                  &exp);
d968 1
a968 2
	if (exp->elts[0].opcode == OP_VAR_VALUE)
	  if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_CONST)
d970 8
a977 4
	      warning ("%s is constant (value %d): will not be collected.",
		       SYMBOL_NAME (exp->elts[2].symbol),
		       SYMBOL_VALUE (exp->elts[2].symbol));
	      return BADLINE;
d979 5
a983 1
	  else if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_OPTIMIZED_OUT)
d985 13
a997 3
	      warning ("%s is optimized away and cannot be collected.",
		       SYMBOL_NAME (exp->elts[2].symbol));
	      return BADLINE;
d1000 4
a1003 4
	/* we have something to collect, make sure that the expr to
	   bytecode translator can handle it and that it's not too long */
	aexpr = gen_trace_for_expr (t->address, exp);
	(void) make_cleanup ((make_cleanup_func) free_agent_expr, aexpr);
d1005 2
a1006 2
	if (aexpr->len > MAX_AGENT_EXPR_LEN)
	  error ("expression too complicated, try simplifying");
d1008 2
a1009 2
	ax_reqs(aexpr, &areqs);
	(void) make_cleanup (free, areqs.reg_mask);
d1011 2
a1012 2
	if (areqs.flaw != agent_flaw_none)
	  error ("malformed expression");
d1014 2
a1015 2
	if (areqs.min_height < 0)
	  error ("gdb: Internal error: expression has min height < 0");
d1017 2
a1018 2
	if (areqs.max_height > 20)
	  error ("expression too complicated, try simplifying");
d1020 3
a1022 2
	do_cleanups (old_chain);
      } while (p && *p++ == ',');
d1027 1
a1027 1
      char *steparg;	/* in case warning is necessary */
d1029 1
a1029 1
      while (isspace (*p))
d1036 1
a1036 1
	  warning ("bad step-count: command ignored.", *line);
d1051 1
a1051 1
void 
d1060 1
a1060 1
      if (line->action) 
d1067 2
a1068 1
struct memrange {
d1074 12
a1085 10
struct collection_list {
  unsigned char regs_mask[8];	/* room for up to 256 regs */
  long listsize;
  long next_memrange;
  struct memrange *list;
  long aexpr_listsize;		/* size of array pointed to by expr_list elt */
  long next_aexpr_elt;
  struct agent_expr **aexpr_list;
  
} tracepoint_list, stepping_list;
d1102 1
a1102 1
    return  1;
d1105 4
a1108 2
      if ((bfd_vma) a->start  < (bfd_vma) b->start)  return -1;
      if ((bfd_vma) a->start  > (bfd_vma) b->start)  return  1;
d1112 1
a1112 1
      if (a->start  < b->start)
d1114 2
a1115 2
      if (a->start  > b->start)
	return  1;
d1127 1
a1127 1
  qsort (memranges->list, memranges->next_memrange, 
d1134 1
a1134 1
	      memranges->list[b].start - memranges->list[a].end <= 
d1144 1
a1144 1
	    memcpy (&memranges->list[a], &memranges->list[b], 
d1152 1
a1152 1
void
d1155 1
a1155 1
     unsigned long regno;
d1162 1
a1162 1
  collection->regs_mask [regno / 8] |= 1 << (regno  % 8);
d1174 6
a1179 1
    printf_filtered ("(%d,0x%x,%d)\n", type, base, len);
d1181 1
a1181 1
  memranges->list[memranges->next_memrange].type  = type;
d1185 1
a1185 1
  memranges->list[memranges->next_memrange].end   = base + len;
d1190 1
a1190 1
      memranges->list = xrealloc (memranges->list, 
d1194 1
a1194 1
  if (type != -1)	/* better collect the base register! */
d1206 2
a1207 2
  unsigned long  len;
  unsigned long  reg;
d1210 98
a1307 87
  len  = TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym)));
  switch (SYMBOL_CLASS (sym)) {
  default:
    printf_filtered ("%s: don't know symbol class %d\n",
		     SYMBOL_NAME (sym), SYMBOL_CLASS (sym));
    break;
  case LOC_CONST:
    printf_filtered ("%s is constant, value is %d: will not be collected.\n",
		     SYMBOL_NAME (sym), SYMBOL_VALUE (sym));
    break;
  case LOC_STATIC:
    offset = SYMBOL_VALUE_ADDRESS (sym); 
    if (info_verbose)
      printf_filtered ("LOC_STATIC %s: collect %d bytes at 0x%08x\n",
		       SYMBOL_NAME (sym), len, offset);
    add_memrange (collect, -1, offset, len);	/* 0 == memory */
    break;
  case LOC_REGISTER:
  case LOC_REGPARM:
    reg = SYMBOL_VALUE (sym); 
    if (info_verbose)
      printf_filtered ("LOC_REG[parm] %s: ", SYMBOL_NAME (sym));
    add_register (collect, reg);
    /* check for doubles stored in two registers */
    /* FIXME: how about larger types stored in 3 or more regs? */
    if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FLT &&
	len > REGISTER_RAW_SIZE (reg))
      add_register (collect, reg + 1);
    break;
  case LOC_REF_ARG:
    printf_filtered ("Sorry, don't know how to do LOC_REF_ARG yet.\n");
    printf_filtered ("       (will not collect %s)\n", 
		     SYMBOL_NAME (sym));
    break;
  case LOC_ARG:
    reg    = frame_regno;
    offset = frame_offset + SYMBOL_VALUE (sym);
    if (info_verbose)
      {
	printf_filtered ("LOC_LOCAL %s: Collect %d bytes at offset",
			 SYMBOL_NAME (sym), len);
	printf_filtered (" %d from frame ptr reg %d\n", offset, reg);
      }
    add_memrange (collect, reg, offset, len);
    break;
  case LOC_REGPARM_ADDR:
    reg = SYMBOL_VALUE (sym);
    offset = 0;
    if (info_verbose)
      {
	printf_filtered ("LOC_REGPARM_ADDR %s: Collect %d bytes at offset",
			 SYMBOL_NAME (sym), len);
	printf_filtered (" %d from reg %d\n", offset, reg);
      }
    add_memrange (collect, reg, offset, len);
    break;
  case LOC_LOCAL:
  case LOC_LOCAL_ARG:
    reg    = frame_regno;
    offset = frame_offset + SYMBOL_VALUE (sym);
    if (info_verbose)
      {
	printf_filtered ("LOC_LOCAL %s: Collect %d bytes at offset",
			 SYMBOL_NAME (sym), len);
	printf_filtered (" %d from frame ptr reg %d\n", offset, reg);
      }
    add_memrange (collect, reg, offset, len);
    break;
  case LOC_BASEREG:
  case LOC_BASEREG_ARG:
    reg = SYMBOL_BASEREG (sym);
    offset  = SYMBOL_VALUE (sym);
    if (info_verbose)
      {
	printf_filtered ("LOC_BASEREG %s: collect %d bytes at offset %d from basereg %d\n", 
			 SYMBOL_NAME (sym), len, offset, reg);
      }
    add_memrange (collect, reg, offset, len);
    break;
  case LOC_UNRESOLVED:
    printf_filtered ("Don't know LOC_UNRESOLVED %s\n", SYMBOL_NAME (sym));
    break;
  case LOC_OPTIMIZED_OUT:
    printf_filtered ("%s has been optimized out of existance.\n",
		     SYMBOL_NAME (sym));
    break;
  }
d1320 1
a1320 1
  struct block  *block;
d1326 1
a1326 1
      QUIT;				/* allow user to bail out with ^C */
d1331 27
a1357 23
	  switch (SYMBOL_CLASS (sym)) {
	  case LOC_LOCAL:
	  case LOC_STATIC:
	  case LOC_REGISTER:
	  case LOC_BASEREG:
	    if (type == 'L')	/* collecting Locals */
	      {
		count++;
		collect_symbol (collect, sym, frame_regno, frame_offset);
	      }
	    break;
	  case LOC_ARG:
	  case LOC_LOCAL_ARG:
	  case LOC_REF_ARG:
	  case LOC_REGPARM:
	  case LOC_REGPARM_ADDR:
	  case LOC_BASEREG_ARG:
	    if (type == 'A')	/* collecting Arguments */
	      {
		count++;
		collect_symbol (collect, sym, frame_regno, frame_offset);
	      }
	  }
d1378 1
a1378 1
      free_agent_expr(list->aexpr_list[ndx]);
d1392 1
d1397 1
a1397 1
  long  i;
d1400 1
a1400 1
  str_list = (char *(*)[])xmalloc(count * sizeof (char *));
d1410 1
a1410 1
      *end++='R';
d1413 1
a1413 1
	  QUIT;				/* allow user to bail out with ^C */
d1416 1
a1416 1
	  sprintf (end,  "%02X", list->regs_mask[i]);
d1419 1
a1419 1
      (*str_list)[ndx] = savestring(temp_buf, end - temp_buf);
d1429 1
d1431 6
a1436 4
	printf_filtered ("(%d, 0x%x, %d)\n", 
			 list->list[i].type, 
			 list->list[i].start, 
			 list->list[i].end - list->list[i].start);
d1439 1
a1439 1
	  (*str_list)[ndx] = savestring(temp_buf, count);
d1444 6
a1449 4
      sprintf (end, "M%X,%X,%X", 
	       list->list[i].type, 
	       list->list[i].start, 
	       list->list[i].end - list->list[i].start);
d1451 1
a1451 1
      end += strlen (end);
d1459 1
a1459 1
	  (*str_list)[ndx] = savestring(temp_buf, count);
d1468 1
a1468 1
      end = mem2hex(list->aexpr_list[i]->buf, end, list->aexpr_list[i]->len);
d1474 1
a1474 1
      (*str_list)[ndx] = savestring(temp_buf, count);
d1487 9
a1495 2
void
free_actions_list(actions_list)
d1504 1
a1504 1
    free(actions_list[ndx]);
d1506 1
a1506 1
  free(actions_list);
d1512 7
a1518 7
     struct tracepoint  *t;
     char              ***tdp_actions;
     char              ***stepping_actions;
{
  static char        tdp_buff[2048], step_buff[2048];
  char               *action_exp;
  struct expression  *exp = NULL;
d1520 3
a1522 4
  bfd_signed_vma      offset;
  long                i;
  value_ptr           tempval;
  struct collection_list  *collect;
d1525 1
a1525 1
  long                frame_reg, frame_offset;
d1541 1
a1541 1
      while (isspace (*action_exp))
d1553 5
a1557 4
	  do {	/* repeat over a comma-separated list */
	    QUIT;		/* allow user to bail out with ^C */
	    while (isspace (*action_exp))
	      action_exp++;
d1559 34
a1592 72
	    if (0 == strncasecmp ("$reg", action_exp, 4))
	      {
		for (i = 0; i < NUM_REGS; i++)
		  add_register (collect, i);
		action_exp = strchr (action_exp, ','); /* more? */
	      }
	    else if (0 == strncasecmp ("$arg", action_exp, 4))
	      {
		add_local_symbols (collect, 
				   t->address, 
				   frame_reg,
				   frame_offset,
				   'A');
		action_exp = strchr (action_exp, ','); /* more? */
	      }
	    else if (0 == strncasecmp ("$loc", action_exp, 4))
	      {
		add_local_symbols (collect, 
				   t->address, 
				   frame_reg,
				   frame_offset,
				   'L');
		action_exp = strchr (action_exp, ','); /* more? */
	      }
	    else
	      {
		unsigned long addr, len;
		struct cleanup *old_chain = NULL;
		struct cleanup *old_chain1 = NULL;
		struct agent_reqs areqs;

		exp = parse_exp_1 (&action_exp, block_for_pc (t->address), 1);
		old_chain = make_cleanup ((make_cleanup_func) 
                                          free_current_contents, &exp);

		switch (exp->elts[0].opcode) {
		case OP_REGISTER:
		  i = exp->elts[1].longconst;
		  if (info_verbose)
		    printf_filtered ("OP_REGISTER: ");
		  add_register (collect, i);
		  break;

		case UNOP_MEMVAL:
		  /* safe because we know it's a simple expression */
		  tempval = evaluate_expression (exp);
		  addr = VALUE_ADDRESS (tempval) + VALUE_OFFSET (tempval);
		  len = TYPE_LENGTH (check_typedef (exp->elts[1].type));
		  add_memrange (collect, -1, addr, len);
		  break;

		case OP_VAR_VALUE:
		  collect_symbol (collect, 
				  exp->elts[2].symbol,
				  frame_reg,
				  frame_offset);
		  break;

		default:	/* full-fledged expression */
		  aexpr = gen_trace_for_expr (t->address, exp);

		  old_chain1 = make_cleanup ((make_cleanup_func) 
                                             free_agent_expr, aexpr);

		  ax_reqs (aexpr, &areqs);
		  if (areqs.flaw != agent_flaw_none)
		    error ("malformed expression");

		  if (areqs.min_height < 0)
		    error ("gdb: Internal error: expression has min height < 0");
		  if (areqs.max_height > 20)
		    error ("expression too complicated, try simplifying");
d1594 38
a1631 2
		  discard_cleanups (old_chain1);
		  add_aexpr (collect, aexpr);
d1633 2
a1634 5
		  /* take care of the registers */
		  if (areqs.reg_mask_len > 0)
		    {
		      int ndx1;
		      int ndx2;
d1636 2
a1637 1
		      for (ndx1 = 0; ndx1 < areqs.reg_mask_len; ndx1++)
d1639 4
a1642 2
			  QUIT;		/* allow user to bail out with ^C */
			  if (areqs.reg_mask[ndx1] != 0)
d1644 9
a1652 5
			      /* assume chars have 8 bits */
			      for (ndx2 = 0; ndx2 < 8; ndx2++)
				if (areqs.reg_mask[ndx1] & (1 << ndx2))
				  /* it's used -- record it */
				  add_register (collect, ndx1 * 8 + ndx2);
d1655 7
a1661 7
		    }
		  break;
		}	/* switch */
		do_cleanups (old_chain);
	      }		/* do */
	  } while (action_exp && *action_exp++ == ',');
	}		/* if */
d1671 1
a1671 1
	    break;			/* end tracepoint actions */
d1673 3
a1675 3
    }			/* for */
  memrange_sortmerge (&tracepoint_list); 
  memrange_sortmerge (&stepping_list); 
d1677 2
a1678 2
  *tdp_actions      = stringify_collection_list (&tracepoint_list, &tdp_buff);
  *stepping_actions = stringify_collection_list (&stepping_list,   &step_buff);
d1682 1
a1682 1
add_aexpr(collect, aexpr)
d1690 1
a1690 1
		  2 * collect->aexpr_listsize * sizeof (struct agent_expr *));
d1716 1
a1716 1
    return;		/* no information to give. */
d1721 1
a1721 1
      char tmp[40];
d1723 2
a1724 2
      if ((s->flags & SEC_LOAD)     == 0 ||
       /* (s->flags & SEC_CODE)     == 0 || */
d1729 1
a1729 1
      lma  = s->lma;
d1731 4
a1734 2
      sprintf (tmp, ":%x,%x", lma, lma + size);
      strcat (target_buf, tmp);
d1739 1
a1739 1
      getpkt (target_buf, 0);
d1744 1
a1744 1
 
d1754 1
a1754 1
{ /* STUB_COMM MOSTLY_IMPLEMENTED */
d1762 2
a1763 2
  dont_repeat ();	/* like "run", dangerous to repeat accidentally */
  
d1767 1
a1767 1
      remote_get_noisy_reply (target_buf);
d1772 14
a1785 15
	{
	  int ss_count;		/* if actions include singlestepping */
	  int disable_mask;	/* ??? */
	  int enable_mask;	/* ??? */

	  sprintf (buf, "QTDP:%x:%x:%c:%x:%x", t->number, t->address, 
		   t->enabled == enabled ? 'E' : 'D', 
		   t->step_count, t->pass_count);

	  if (t->actions)
	    strcat (buf, "-");
	  putpkt (buf);
	  remote_get_noisy_reply (target_buf);
	  if (strcmp (target_buf, "OK"))
	    error ("Target does not support tracepoints.");
d1787 7
a1793 5
	  if (t->actions)
	    {
	      encode_actions (t, &tdp_actions, &stepping_actions);
	      old_chain = make_cleanup (free_actions_list, tdp_actions);
	      (void) make_cleanup (free_actions_list, stepping_actions);
d1795 33
a1827 33
	      /* do_single_steps (t); */
	      if (tdp_actions)
		{
		  for (ndx = 0; tdp_actions[ndx]; ndx++)
		    {
		      QUIT;		/* allow user to bail out with ^C */
		      sprintf (buf, "QTDP:-%x:%x:%s%c",
			       t->number, t->address,
			       tdp_actions[ndx],
			       ((tdp_actions[ndx+1] || stepping_actions)
				? '-' : 0));
		      putpkt (buf);
		      remote_get_noisy_reply (target_buf);
		      if (strcmp (target_buf, "OK"))
			error ("Error on target while setting tracepoints.");
		    }
		}
	      if (stepping_actions)
		{
		  for (ndx = 0; stepping_actions[ndx]; ndx++)
		    {
		      QUIT;		/* allow user to bail out with ^C */
		      sprintf (buf, "QTDP:-%x:%x:%s%s%s",
			       t->number, t->address,
			       ((ndx == 0) ? "S" : ""),
			       stepping_actions[ndx],
			       (stepping_actions[ndx+1] ? "-" : ""));
		      putpkt (buf);
		      remote_get_noisy_reply (target_buf);
		      if (strcmp (target_buf, "OK"))
			error ("Error on target while setting tracepoints.");
		    }
		}
d1829 3
a1831 3
	      do_cleanups (old_chain);
	    }
	}
d1836 1
a1836 1
      remote_get_noisy_reply (target_buf);
d1841 1
a1841 1
      set_traceframe_context(-1);
d1844 2
a1845 2
	trace_start_stop_hook(1, from_tty);
      
d1856 1
a1856 1
{ /* STUB_COMM IS_IMPLEMENTED */
d1860 1
a1860 1
      remote_get_noisy_reply (target_buf);
d1865 1
a1865 1
	trace_start_stop_hook(0, from_tty);
d1878 1
a1878 1
{ /* STUB_COMM IS_IMPLEMENTED */
d1882 1
a1882 1
      remote_get_noisy_reply (target_buf);
d1897 3
a1899 3
finish_tfind_command (msg, from_tty)
     char *msg;
     int from_tty;
d1907 1
a1907 1
  old_func       = find_pc_function (read_pc ());
d1910 1
a1910 1
  reply = remote_get_noisy_reply (msg);
d1913 25
a1937 24
    switch (*reply) {
    case 'F':
      if ((target_frameno = (int) strtol (++reply, &reply, 16)) == -1)
	{ 
	  /* A request for a non-existant trace frame has failed.
	     Our response will be different, depending on FROM_TTY:

	     If FROM_TTY is true, meaning that this command was 
	     typed interactively by the user, then give an error
	     and DO NOT change the state of traceframe_number etc.

	     However if FROM_TTY is false, meaning that we're either
	     in a script, a loop, or a user-defined command, then 
	     DON'T give an error, but DO change the state of
	     traceframe_number etc. to invalid.

	     The rationalle is that if you typed the command, you
	     might just have committed a typo or something, and you'd
	     like to NOT lose your current debugging state.  However
	     if you're in a user-defined command or especially in a
	     loop, then you need a way to detect that the command
	     failed WITHOUT aborting.  This allows you to write
	     scripts that search thru the trace buffer until the end,
	     and then continue on to do something else.  */
d1939 9
a1947 9
	  if (from_tty)
	    error ("Target failed to find requested trace frame.");
	  else
	    {
	      if (info_verbose)
		printf_filtered ("End of trace buffer.\n");
	      /* The following will not recurse, since it's special-cased */
	      trace_find_command ("-1", from_tty);
	      reply = NULL;	/* break out of loop, 
d1949 14
a1962 11
	    }
	}
      break;
    case 'T':
      if ((target_tracept = (int) strtol (++reply, &reply, 16)) == -1)
	error ("Target failed to find requested trace frame.");
      break;
    case 'O':	/* "OK"? */
      if (reply[1] == 'K' && reply[2] == '\0')
	reply += 2;
      else
d1964 1
a1964 4
      break;
    default:
      error ("Bogus reply from target: %s", reply);
    }
d1981 13
a1993 13
	 whether we have made a transition from one function to another.
	 If so, we'll print the "stack frame" (ie. the new function and
	 it's arguments) -- otherwise we'll just show the new source line.

	 This determination is made by checking (1) whether the current
	 function has changed, and (2) whether the current FP has changed.
	 Hack: if the FP wasn't collected, either at the current or the
	 previous frame, assume that the FP has NOT changed.  */

      if (old_func       == find_pc_function (read_pc ()) &&
	 (old_frame_addr == 0 ||
	  FRAME_FP (get_current_frame ()) == 0 ||
	  old_frame_addr == FRAME_FP (get_current_frame ())))
d1996 1
a1996 1
	source_only =  1;
d2013 3
a2015 3
	F<hexnum>	(gives the selected frame number)
	T<hexnum>	(gives the selected tracepoint number)
   */
d2022 1
a2022 1
{ /* STUB_COMM PART_IMPLEMENTED */
a2024 1
  char *tmp;
d2029 2
a2030 2
	trace_find_hook (args, from_tty);  
      
d2032 1
a2032 1
	{ /* TFIND with no args means find NEXT trace frame. */
d2054 1
a2054 1
      finish_tfind_command (target_buf, from_tty);
d2092 1
a2092 1
{ /* STUB_COMM PART_IMPLEMENTED */
d2094 1
a2094 1
  char *tmp;
d2103 3
a2105 2
      sprintf (target_buf, "QTFrame:pc:%x", pc);
      finish_tfind_command (target_buf, from_tty);
d2116 1
a2116 1
{ /* STUB_COMM PART_IMPLEMENTED */
a2117 1
  char buf[40], *tmp;
d2130 1
a2130 1
      finish_tfind_command (target_buf, from_tty);
d2137 1
a2137 1
 
d2140 1
a2140 1
   
d2148 1
a2148 1
{ /* STUB_COMM PART_IMPLEMENTED */
a2151 1
  char *tmp;
d2153 1
d2168 1
a2168 1
	  sal  = sals.sals[0];
d2178 2
a2179 2
		 user about a source line, at least let them have the symbolic
		 address.  */
d2188 1
a2188 1
	      return;	/* no line, no PC; what can we do? */
d2220 2
d2223 1
a2223 1
	sprintf (target_buf, "QTFrame:range:%x:%x", start_pc, end_pc - 1);
d2225 2
a2226 2
	sprintf (target_buf, "QTFrame:outside:%x:%x", start_pc, end_pc - 1);
      finish_tfind_command (target_buf, from_tty);
d2230 1
a2230 1
      error ("Trace can only be run on remote targets.");
d2238 1
a2238 1
{ /* STUB_COMM PART_IMPLEMENTED */
d2240 1
d2246 1
a2246 1
	{ /* XXX FIXME: what should default behavior be? */
d2251 1
a2251 1
      if (0 != (tmp = strchr (args, ',' )))
d2254 1
a2254 1
	  while (isspace (*tmp))
d2257 1
a2257 1
	  stop  = parse_and_eval_address (tmp);
d2260 1
a2260 1
	{ /* no explicit end address? */
d2262 1
a2262 1
	  stop  = start + 1; /* ??? */
d2265 4
a2268 2
      sprintf (target_buf, "QTFrame:range:%x:%x", start, stop);
      finish_tfind_command (target_buf, from_tty);
d2271 1
a2271 1
      error ("Trace can only be run on remote targets.");
d2279 1
a2279 1
{ /* STUB_COMM PART_IMPLEMENTED */
d2281 1
d2287 1
a2287 1
	{ /* XXX FIXME: what should default behavior be? */
d2292 1
a2292 1
      if (0 != (tmp = strchr (args, ',' )))
d2295 1
a2295 1
	  while (isspace (*tmp))
d2298 1
a2298 1
	  stop  = parse_and_eval_address (tmp);
d2301 1
a2301 1
	{ /* no explicit end address? */
d2303 1
a2303 1
	  stop  = start + 1; /* ??? */
d2306 4
a2309 2
      sprintf (target_buf, "QTFrame:outside:%x:%x", start, stop);
      finish_tfind_command (target_buf, from_tty);
d2312 1
a2312 1
      error ("Trace can only be run on remote targets.");
d2321 1
a2321 1
  struct tracepoint  *tp;
d2326 1
d2341 8
a2348 5
    {
      if (tp->addr_string)
	fprintf (fp, "trace %s\n", tp->addr_string);
      else
	fprintf (fp, "trace *0x%x\n", tp->address);
d2350 2
a2351 2
      if (tp->pass_count)
	fprintf (fp, "  passcount %d\n", tp->pass_count);
d2353 7
a2359 7
      if (tp->actions)
	{
	  fprintf (fp, "  actions\n");
	  indent = i1;
	  for (line = tp->actions; line; line = line->next)
	    {
	      struct cmd_list_element *cmd;
d2361 4
a2364 4
	      QUIT;			/* allow user to bail out with ^C */
	      actionline = line->action;
	      while (isspace(*actionline))
		actionline++;
d2366 14
a2379 14
	      fprintf (fp, "%s%s\n", indent, actionline);
	      if (*actionline != '#')	/* skip for comment lines */
		{
		  cmd = lookup_cmd (&actionline, cmdlist, "", -1, 1);
		  if (cmd == 0)
		    error ("Bad action list item: %s", actionline);
		  if (cmd->function.cfunc == while_stepping_pseudocommand)
		    indent = i2;
		  else if (cmd->function.cfunc == end_actions_pseudocommand)
		    indent = i1;
		}
	    }
	}
    }
a2391 1
  struct symtab_and_line sal;
d2404 1
a2404 1
    return;		/* presumably decode_line_1 has already warned */
d2412 1
a2412 1
      QUIT;				/* allow user to bail out with ^C */
d2416 1
a2416 1
	  QUIT;				/* allow user to bail out with ^C */
d2423 1
a2423 1
	    continue;	/* probably botched, certainly useless */
d2426 85
a2510 84
	  switch (SYMBOL_CLASS (sym)) {
	  default:
	  case LOC_UNDEF:		/* messed up symbol? */
	    printf_filtered ("a bogus symbol, class %d.\n", 
			     SYMBOL_CLASS (sym));
	    count--;			/* don't count this one */
	    continue;
	  case LOC_CONST:
	    printf_filtered ("a constant with value %d (0x%x)", 
			     SYMBOL_VALUE (sym), SYMBOL_VALUE (sym));
	    break;
	  case LOC_CONST_BYTES:
	    printf_filtered ("constant bytes: ");
	    if (SYMBOL_TYPE (sym))
	      for (j = 0; j < TYPE_LENGTH (SYMBOL_TYPE (sym)); j++)
		fprintf_filtered (gdb_stdout, " %02x",
				  (unsigned) SYMBOL_VALUE_BYTES (sym) [j]);
  	    break;
	  case LOC_STATIC:
	    printf_filtered ("in static storage at address ");
	    print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 1, gdb_stdout);
	    break;
	  case LOC_REGISTER:
	    printf_filtered ("a local variable in register $%s",
			     REGISTER_NAME (SYMBOL_VALUE (sym)));
	    break;
	  case LOC_ARG:
	  case LOC_LOCAL_ARG:
	    printf_filtered ("an argument at stack/frame offset %ld",
			     SYMBOL_VALUE (sym));
	    break;
	  case LOC_LOCAL:
	    printf_filtered ("a local variable at frame offset %ld",
			     SYMBOL_VALUE (sym));
	    break;
	  case LOC_REF_ARG:
	    printf_filtered ("a reference argument at offset %ld",
			     SYMBOL_VALUE (sym));
	    break;
	  case LOC_REGPARM:
	    printf_filtered ("an argument in register $%s",
			     REGISTER_NAME (SYMBOL_VALUE (sym)));
	    break;
	  case LOC_REGPARM_ADDR:
	    printf_filtered ("the address of an argument, in register $%s",
			     REGISTER_NAME (SYMBOL_VALUE (sym)));
	    break;
	  case LOC_TYPEDEF:
	    printf_filtered ("a typedef.\n");
	    continue;
	  case LOC_LABEL:
	    printf_filtered ("a label at address ");
	    print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 1, gdb_stdout);
	    break;
	  case LOC_BLOCK:
	    printf_filtered ("a function at address ");
	    print_address_numeric (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)), 1,
				   gdb_stdout);
	    break;
	  case LOC_BASEREG:
	    printf_filtered ("a variable at offset %d from register $%s",
			     SYMBOL_VALUE (sym),
			     REGISTER_NAME  (SYMBOL_BASEREG (sym)));
	    break;
	  case LOC_BASEREG_ARG:
	    printf_filtered ("an argument at offset %d from register $%s",
			     SYMBOL_VALUE (sym),
			     REGISTER_NAME  (SYMBOL_BASEREG (sym)));
	    break;
	  case LOC_UNRESOLVED:
	    msym = lookup_minimal_symbol (SYMBOL_NAME (sym), NULL, NULL);
	    if (msym == NULL)
	      printf_filtered ("Unresolved Static");
	    else
	      {
		printf_filtered ("static storage at address ");
		print_address_numeric (SYMBOL_VALUE_ADDRESS (msym), 1, 
				       gdb_stdout);
	      }
	    break;
	  case LOC_OPTIMIZED_OUT:
	    printf_filtered ("optimized out.\n");
	    continue;
	  }
d2512 2
a2513 2
	    printf_filtered (", length %d.\n", 
			     TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym))));
d2539 1
a2539 1
  struct tracepoint  *t;
d2541 4
a2544 4
  char               *action_exp, *next_comma;
  struct cleanup     *old_cleanups;
  int                 stepping_actions = 0;
  int                 stepping_frame   = 0;
d2560 1
a2560 1
      break;
d2563 1
a2563 1
    error ("No known tracepoint matches 'current' tracepoint #%d.", 
d2568 1
a2568 1
  printf_filtered ("Data collected at tracepoint %d, trace frame %d:\n", 
d2575 1
a2575 1
  stepping_frame = (t->address != read_pc());
d2581 1
a2581 1
      QUIT;				/* allow user to bail out with ^C */
d2583 1
a2583 1
      while (isspace (*action_exp))
d2587 1
a2587 1
	 bracketed by the commands "while-stepping" and "end".  */
d2609 32
a2640 30
	      do { /* repeat over a comma-separated list */
		QUIT;		/* allow user to bail out with ^C */
		if (*action_exp == ',')
		  action_exp++;
		while (isspace (*action_exp))
		  action_exp++;

		next_comma = strchr (action_exp, ',');

		if      (0 == strncasecmp (action_exp, "$reg", 4))
		  registers_info (NULL, from_tty);
		else if (0 == strncasecmp (action_exp, "$loc", 4))
		  locals_info (NULL, from_tty);
		else if (0 == strncasecmp (action_exp, "$arg", 4))
		  args_info (NULL, from_tty);
		else
		  { /* variable */
		    if (next_comma)
		      {
			make_cleanup (replace_comma, next_comma);
			*next_comma = '\0';
		      }
		    printf_filtered ("%s = ", action_exp);
		    output_command (action_exp, from_tty);
		    printf_filtered ("\n");
		  }
		if (next_comma)
		  *next_comma = ',';
		action_exp = next_comma;
	      } while (action_exp && *action_exp == ',');
d2652 1
a2652 1
static const char hexchars[]="0123456789abcdef";
d2655 1
a2655 1
mem2hex(mem, buf, count)
d2675 2
a2676 1
int get_traceframe_number()
d2678 1
a2678 1
 return traceframe_number;
d2686 2
a2687 2
  tracepoint_chain  = 0;
  tracepoint_count  = 0;
d2691 1
a2691 1
  set_internalvar (lookup_internalvar ("tpnum"), 
d2693 2
a2694 2
  set_internalvar (lookup_internalvar ("trace_frame"), 
		   value_from_longest (builtin_type_int, (LONGEST) -1));
d2699 1
a2699 1
      tracepoint_list.list = xmalloc 
d2712 1
a2712 1
      stepping_list.list = xmalloc 
d2723 1
a2723 1
  add_info ("scope", scope_info, 
d2726 2
a2727 2
  add_cmd ("tracepoints", class_trace, NO_FUNCTION, 
	   "Tracing of program execution without stopping the program.", 
d2737 1
a2737 1
  add_com ("save-tracepoints", class_trace, tracepoint_save_command, 
d2741 1
a2741 1
  add_com ("tdump", class_trace, trace_dump_command, 
d2744 1
a2744 1
  add_prefix_cmd ("tfind",  class_trace, trace_find_command,
d2751 1
a2751 1
range.\nUsage: tfind outside addr1, addr2", 
d2756 1
a2756 1
Usage: tfind range addr1,addr2", 
d2789 1
a2789 1
  add_com ("tstatus",  class_trace, trace_status_command,
d2792 1
a2792 1
  add_com ("tstop",  class_trace, trace_stop_command,
d2798 1
a2798 1
  add_com ("passcount", class_trace, trace_pass_command, 
d2819 2
a2820 2
  add_com_alias ("ws",         "while-stepping", class_alias, 0);
  add_com_alias ("stepping",   "while-stepping", class_alias, 0);
d2822 1
a2822 1
  add_com ("collect", class_trace, collect_pseudocommand, 
d2838 1
a2838 1
  add_cmd ("tracepoints", class_trace, delete_trace_command, 
d2844 1
a2844 1
  add_cmd ("tracepoints", class_trace, disable_trace_command, 
d2850 1
a2850 1
  add_cmd ("tracepoints", class_trace, enable_trace_command, 
d2863 3
a2865 3
  add_com_alias ("tp",   "trace", class_alias, 0);
  add_com_alias ("tr",   "trace", class_alias, 1);
  add_com_alias ("tra",  "trace", class_alias, 1);
a2867 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d644 1
a644 2
	t = get_tracepoint_by_number (&args);
	if (t)
d786 1
a786 2
  t = get_tracepoint_by_number (&args);
  if (t)
d868 7
a874 9
	{
	  if (prompt == prompt2)
	    {
	      warning ("Already processing 'while-stepping'");
	      continue;
	    }
	  else
	    prompt = prompt2;	/* change prompt for stepping actions */
	}
d876 14
a889 16
	{
	  if (prompt == prompt2)
	    {
	      prompt = prompt1;	/* end of single-stepping actions */
	    }
	  else
	    { /* end of actions */
	      if (t->actions->next == NULL)
		{
		  /* an "end" all by itself with no other actions means
		     this tracepoint has no actions.  Discard empty list. */
		  free_actions (t);
		}
	      break;
	    }
	}
d957 13
a969 15
	  {
	    if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_CONST)
	      {
		warning ("%s is constant (value %d): will not be collected.",
			 SYMBOL_NAME (exp->elts[2].symbol),
			 SYMBOL_VALUE (exp->elts[2].symbol));
		return BADLINE;
	      }
	    else if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_OPTIMIZED_OUT)
	      {
		warning ("%s is optimized away and cannot be collected.",
			 SYMBOL_NAME (exp->elts[2].symbol));
		return BADLINE;
	      }
	  }
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@a141 1
#if __STDC__
a142 1
#endif
a144 5
static void add_register PARAMS ((struct collection_list *collection, unsigned long regno));
static void free_actions_list PARAMS ((char **actions_list));
static void free_actions_list_cleanup_wrapper PARAMS ((void*));

extern void _initialize_tracepoint PARAMS ((void));
d1125 1
a1125 1
static void
d1434 1
a1434 8
static void
free_actions_list_cleanup_wrapper (al)
     void *al;
{
  free_actions_list (al);
}

static void
d1727 2
a1728 4
	      old_chain = make_cleanup (free_actions_list_cleanup_wrapper,
					tdp_actions);
	      (void) make_cleanup (free_actions_list_cleanup_wrapper,
				   stepping_actions);
@


1.1.1.4
log
@import gdb-1999-06-14 snapshot
@
text
@d838 1
a838 6
    {
      if (async_p)
	signal (STOP_SIGNAL, handle_stop_sig);
      else
	signal (STOP_SIGNAL, stop_sig);
    } 
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d51 1
a51 1

d58 2
a59 2
extern void (*readline_begin_hook) PARAMS ((char *,...));
extern char *(*readline_hook) PARAMS ((char *));
d62 1
a62 1
extern int addressprint;	/* Print machine addresses? */
d93 1
a93 1
 */
d120 12
a131 12
static void trace_command PARAMS ((char *, int));
static void tracepoints_info PARAMS ((char *, int));
static void delete_trace_command PARAMS ((char *, int));
static void enable_trace_command PARAMS ((char *, int));
static void disable_trace_command PARAMS ((char *, int));
static void trace_pass_command PARAMS ((char *, int));
static void trace_actions_command PARAMS ((char *, int));
static void trace_start_command PARAMS ((char *, int));
static void trace_stop_command PARAMS ((char *, int));
static void trace_status_command PARAMS ((char *, int));
static void trace_find_command PARAMS ((char *, int));
static void trace_find_pc_command PARAMS ((char *, int));
d133 5
a137 5
static void trace_find_line_command PARAMS ((char *, int));
static void trace_find_range_command PARAMS ((char *, int));
static void trace_find_outside_command PARAMS ((char *, int));
static void tracepoint_save_command PARAMS ((char *, int));
static void trace_dump_command PARAMS ((char *, int));
d140 1
a140 1
static void trace_mention PARAMS ((struct tracepoint *));
d146 2
a147 2
static unsigned char *mem2hex (unsigned char *, unsigned char *, int);
static void add_register PARAMS ((struct collection_list * collection, unsigned long regno));
d149 1
a149 1
static void free_actions_list_cleanup_wrapper PARAMS ((void *));
d165 1
a165 1
static void
d171 1
a171 1
  switch (*buf)
d177 1
a177 1
	error ("tracepoint.c: error in outgoing packet at field #%d.",
d191 1
a191 1
  do				/* loop on reply from remote stub */
d193 1
a193 1
      QUIT;			/* allow user to bail out with ^C */
d203 2
a204 3
	return buf;		/* here's the actual reply */
    }
  while (1);
d245 2
a246 2
  static struct type *func_range, *file_range;
  static value_ptr func_val, file_val;
d253 1
a253 1
  if (trace_pc == -1)		/* cease debugging any trace buffers */
d258 1
a258 1
      set_internalvar (lookup_internalvar ("trace_func"),
d260 1
a260 1
      set_internalvar (lookup_internalvar ("trace_file"),
d263 1
a263 1
		       value_from_longest (builtin_type_int, (LONGEST) - 1));
d273 1
a273 1
		   value_from_longest (builtin_type_int,
d277 1
a277 1
  if (traceframe_fun == NULL ||
d279 1
a279 1
    set_internalvar (lookup_internalvar ("trace_func"),
d284 3
a286 3
      func_range = create_range_type (func_range,
				      builtin_type_int, 0, len - 1);
      func_string = create_array_type (func_string,
d290 2
a291 2
      memcpy (VALUE_CONTENTS_RAW (func_val),
	      SYMBOL_NAME (traceframe_fun),
d298 1
a298 1
  if (traceframe_sal.symtab == NULL ||
d300 1
a300 1
    set_internalvar (lookup_internalvar ("trace_file"),
d305 3
a307 3
      file_range = create_range_type (file_range,
				      builtin_type_int, 0, len - 1);
      file_string = create_array_type (file_string,
d311 2
a312 2
      memcpy (VALUE_CONTENTS_RAW (file_val),
	      traceframe_sal.symtab->filename,
d342 1
a342 1
    t->source_file = savestring (sal.symtab->filename,
d345 2
a346 2
  t->section = sal.section;
  t->language = current_language->la_language;
d349 4
a352 4
  t->enabled = enabled;
  t->next = 0;
  t->step_count = 0;
  t->pass_count = 0;
d378 1
a378 1
  char **canonical = (char **) NULL;
d392 4
a395 4
  sals = decode_line_1 (&arg, 1, (struct symtab *) NULL, 0, &canonical);
  addr_end = arg;
  if (!sals.nelts)
    return;			/* ??? Presumably decode_line_1 has already warned? */
d411 2
a412 2
         command string.  */
      if (canonical != (char **) NULL && canonical[i] != NULL)
d470 2
a471 2
    {
      extern int addressprint;	/* print machine addresses? */
d473 18
a490 18
      if (!found_a_tracepoint++)
	{
	  printf_filtered ("Num Enb ");
	  if (addressprint)
	    printf_filtered ("Address    ");
	  printf_filtered ("PassC StepC What\n");
	}
      strcpy (wrap_indent, "                           ");
      if (addressprint)
	strcat (wrap_indent, "           ");

      printf_filtered ("%-3d %-3s ", t->number,
		       t->enabled == enabled ? "y" : "n");
      if (addressprint)
	printf_filtered ("%s ",
			 local_hex_string_custom ((unsigned long) t->address,
						  "08l"));
      printf_filtered ("%-5d %-5d ", t->pass_count, t->step_count);
d492 15
a506 15
      if (t->source_file)
	{
	  sym = find_pc_sect_function (t->address, t->section);
	  if (sym)
	    {
	      fputs_filtered ("in ", gdb_stdout);
	      fputs_filtered (SYMBOL_SOURCE_NAME (sym), gdb_stdout);
	      wrap_here (wrap_indent);
	      fputs_filtered (" at ", gdb_stdout);
	    }
	  fputs_filtered (t->source_file, gdb_stdout);
	  printf_filtered (":%d", t->line_number);
	}
      else
	print_address_symbolic (t->address, gdb_stdout, demangle, " ");
d508 10
a517 10
      printf_filtered ("\n");
      if (t->actions)
	{
	  printf_filtered ("  Actions for tracepoint %d: \n", t->number);
	  for (action = t->actions; action; action = action->next)
	    {
	      printf_filtered ("\t%s\n", action->action);
	    }
	}
    }
d521 1
a521 1
	printf_filtered ("No tracepoints.\n");
d523 1
a523 1
	printf_filtered ("No tracepoint number %d.\n", tpnum);
d530 2
a531 2
 */
enum tracepoint_opcode
d533 1
a533 1
  enable,
d547 14
a560 15
  switch (opcode)
    {
    case enable:
      t->enabled = enabled;
      if (modify_tracepoint_hook)
	modify_tracepoint_hook (t);
      break;
    case disable:
      t->enabled = disabled;
      if (modify_tracepoint_hook)
	modify_tracepoint_hook (t);
      break;
    case delete:
      if (tracepoint_chain == t)
	tracepoint_chain = t->next;
d562 2
a563 2
      ALL_TRACEPOINTS (t2)
	if (t2->next == t)
d569 10
a578 10
      /* Let the UI know of any deletions */
      if (delete_tracepoint_hook)
	delete_tracepoint_hook (t);

      if (t->addr_string)
	free (t->addr_string);
      if (t->source_file)
	free (t->source_file);
      if (t->actions)
	free_actions (t);
d580 3
a582 3
      free (t);
      break;
    }
d603 1
a603 1
         to pass to lookup_internalvar().  */
d605 1
a605 1
      while (isalnum (*end) || *end == '_')
d613 1
a613 1
      if (TYPE_CODE (VALUE_TYPE (val)) != TYPE_CODE_INT)
d617 1
a617 2
  else
    /* handle tracepoint number */
d626 3
a628 3
    {
      return t;
    }
d650 1
a650 1
	QUIT;			/* give user option to bail out with ^C */
d688 1
a688 1
      if (tracepoint_chain)	/* and if there are tracepoints to delete! */
d718 1
a718 1
    args += 3;			/* skip special argument "all" */
d726 1
a726 1
    return;			/* error, bad tracepoint number */
d730 8
a737 8
    {
      t2->pass_count = count;
      if (modify_tracepoint_hook)
	modify_tracepoint_hook (t2);
      if (from_tty)
	printf_filtered ("Setting tracepoint %d's passcount to %d\n",
			 t2->number, count);
    }
d743 1
a743 1
static void read_actions PARAMS ((struct tracepoint *));
d745 1
a745 1
					      CORE_ADDR,
d751 3
a753 3
   collect_pseudocommand, 
   while_stepping_pseudocommand, and 
   end_actions_pseudocommand
d759 1
a759 1
static void
d843 1
a843 1
    }
d849 1
a849 1
         you get away with leaving out some of the gdb_flush, but not all.  */
d859 1
a859 1
	  if (line && *line)	/* add it to command history */
d867 1
a867 1
	continue;		/* already warned -- collect another line */
d898 1
a898 1
	    {			/* end of actions */
d929 1
a929 1
  for (p = *line; isspace (*p);)
d933 1
a933 1
  if (*p == '\0')		/* empty line: just prompt for another line. */
d936 1
a936 1
  if (*p == '#')		/* comment line */
d945 1
a945 1

d951 4
a954 5
      do
	{			/* repeat over a comma-separated list */
	  QUIT;			/* allow user to bail out with ^C */
	  while (isspace (*p))
	    p++;
d956 4
a959 4
	  if (*p == '$')	/* look for special pseudo-symbols */
	    {
	      long typecode, size;
	      bfd_signed_vma offset;
d961 12
a972 12
	      if ((0 == strncasecmp ("reg", p + 1, 3)) ||
		  (0 == strncasecmp ("arg", p + 1, 3)) ||
		  (0 == strncasecmp ("loc", p + 1, 3)))
		{
		  p = strchr (p, ',');
		  continue;
		}
	      /* else fall thru, treat p as an expression and parse it! */
	    }
	  exp = parse_exp_1 (&p, block_for_pc (t->address), 1);
	  old_chain = make_cleanup ((make_cleanup_func) free_current_contents,
				    &exp);
d974 16
a989 16
	  if (exp->elts[0].opcode == OP_VAR_VALUE)
	    {
	      if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_CONST)
		{
		  warning ("%s is constant (value %d): will not be collected.",
			   SYMBOL_NAME (exp->elts[2].symbol),
			   SYMBOL_VALUE (exp->elts[2].symbol));
		  return BADLINE;
		}
	      else if (SYMBOL_CLASS (exp->elts[2].symbol) == LOC_OPTIMIZED_OUT)
		{
		  warning ("%s is optimized away and cannot be collected.",
			   SYMBOL_NAME (exp->elts[2].symbol));
		  return BADLINE;
		}
	    }
d991 4
a994 4
	  /* we have something to collect, make sure that the expr to
	     bytecode translator can handle it and that it's not too long */
	  aexpr = gen_trace_for_expr (t->address, exp);
	  (void) make_cleanup ((make_cleanup_func) free_agent_expr, aexpr);
d996 2
a997 2
	  if (aexpr->len > MAX_AGENT_EXPR_LEN)
	    error ("expression too complicated, try simplifying");
d999 2
a1000 2
	  ax_reqs (aexpr, &areqs);
	  (void) make_cleanup (free, areqs.reg_mask);
d1002 2
a1003 2
	  if (areqs.flaw != agent_flaw_none)
	    error ("malformed expression");
d1005 2
a1006 2
	  if (areqs.min_height < 0)
	    error ("gdb: Internal error: expression has min height < 0");
d1008 2
a1009 2
	  if (areqs.max_height > 20)
	    error ("expression too complicated, try simplifying");
d1011 2
a1012 3
	  do_cleanups (old_chain);
	}
      while (p && *p++ == ',');
d1017 1
a1017 1
      char *steparg;		/* in case warning is necessary */
d1041 1
a1041 1
void
d1050 1
a1050 1
      if (line->action)
d1057 2
a1058 3
struct memrange
{
  int type;			/* 0 for absolute memory range, else basereg number */
d1063 10
a1072 12
struct collection_list
  {
    unsigned char regs_mask[8];	/* room for up to 256 regs */
    long listsize;
    long next_memrange;
    struct memrange *list;
    long aexpr_listsize;	/* size of array pointed to by expr_list elt */
    long next_aexpr_elt;
    struct agent_expr **aexpr_list;

  }
tracepoint_list, stepping_list;
d1089 1
a1089 1
    return 1;
d1092 2
a1093 4
      if ((bfd_vma) a->start < (bfd_vma) b->start)
	return -1;
      if ((bfd_vma) a->start > (bfd_vma) b->start)
	return 1;
d1097 1
a1097 1
      if (a->start < b->start)
d1099 2
a1100 2
      if (a->start > b->start)
	return 1;
d1112 1
a1112 1
  qsort (memranges->list, memranges->next_memrange,
d1119 1
a1119 1
	      memranges->list[b].start - memranges->list[a].end <=
d1129 1
a1129 1
	    memcpy (&memranges->list[a], &memranges->list[b],
d1147 1
a1147 1
  collection->regs_mask[regno / 8] |= 1 << (regno % 8);
d1161 1
a1161 1
  memranges->list[memranges->next_memrange].type = type;
d1165 1
a1165 1
  memranges->list[memranges->next_memrange].end = base + len;
d1170 1
a1170 1
      memranges->list = xrealloc (memranges->list,
d1174 1
a1174 1
  if (type != -1)		/* better collect the base register! */
d1186 2
a1187 2
  unsigned long len;
  unsigned long reg;
d1190 87
a1276 88
  len = TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym)));
  switch (SYMBOL_CLASS (sym))
    {
    default:
      printf_filtered ("%s: don't know symbol class %d\n",
		       SYMBOL_NAME (sym), SYMBOL_CLASS (sym));
      break;
    case LOC_CONST:
      printf_filtered ("%s is constant, value is %d: will not be collected.\n",
		       SYMBOL_NAME (sym), SYMBOL_VALUE (sym));
      break;
    case LOC_STATIC:
      offset = SYMBOL_VALUE_ADDRESS (sym);
      if (info_verbose)
	printf_filtered ("LOC_STATIC %s: collect %d bytes at 0x%08x\n",
			 SYMBOL_NAME (sym), len, offset);
      add_memrange (collect, -1, offset, len);	/* 0 == memory */
      break;
    case LOC_REGISTER:
    case LOC_REGPARM:
      reg = SYMBOL_VALUE (sym);
      if (info_verbose)
	printf_filtered ("LOC_REG[parm] %s: ", SYMBOL_NAME (sym));
      add_register (collect, reg);
      /* check for doubles stored in two registers */
      /* FIXME: how about larger types stored in 3 or more regs? */
      if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FLT &&
	  len > REGISTER_RAW_SIZE (reg))
	add_register (collect, reg + 1);
      break;
    case LOC_REF_ARG:
      printf_filtered ("Sorry, don't know how to do LOC_REF_ARG yet.\n");
      printf_filtered ("       (will not collect %s)\n",
		       SYMBOL_NAME (sym));
      break;
    case LOC_ARG:
      reg = frame_regno;
      offset = frame_offset + SYMBOL_VALUE (sym);
      if (info_verbose)
	{
	  printf_filtered ("LOC_LOCAL %s: Collect %d bytes at offset",
			   SYMBOL_NAME (sym), len);
	  printf_filtered (" %d from frame ptr reg %d\n", offset, reg);
	}
      add_memrange (collect, reg, offset, len);
      break;
    case LOC_REGPARM_ADDR:
      reg = SYMBOL_VALUE (sym);
      offset = 0;
      if (info_verbose)
	{
	  printf_filtered ("LOC_REGPARM_ADDR %s: Collect %d bytes at offset",
			   SYMBOL_NAME (sym), len);
	  printf_filtered (" %d from reg %d\n", offset, reg);
	}
      add_memrange (collect, reg, offset, len);
      break;
    case LOC_LOCAL:
    case LOC_LOCAL_ARG:
      reg = frame_regno;
      offset = frame_offset + SYMBOL_VALUE (sym);
      if (info_verbose)
	{
	  printf_filtered ("LOC_LOCAL %s: Collect %d bytes at offset",
			   SYMBOL_NAME (sym), len);
	  printf_filtered (" %d from frame ptr reg %d\n", offset, reg);
	}
      add_memrange (collect, reg, offset, len);
      break;
    case LOC_BASEREG:
    case LOC_BASEREG_ARG:
      reg = SYMBOL_BASEREG (sym);
      offset = SYMBOL_VALUE (sym);
      if (info_verbose)
	{
	  printf_filtered ("LOC_BASEREG %s: collect %d bytes at offset %d from basereg %d\n",
			   SYMBOL_NAME (sym), len, offset, reg);
	}
      add_memrange (collect, reg, offset, len);
      break;
    case LOC_UNRESOLVED:
      printf_filtered ("Don't know LOC_UNRESOLVED %s\n", SYMBOL_NAME (sym));
      break;
    case LOC_OPTIMIZED_OUT:
      printf_filtered ("%s has been optimized out of existance.\n",
		       SYMBOL_NAME (sym));
      break;
    }
d1289 1
a1289 1
  struct block *block;
d1295 1
a1295 1
      QUIT;			/* allow user to bail out with ^C */
d1300 23
a1322 24
	  switch (SYMBOL_CLASS (sym))
	    {
	    case LOC_LOCAL:
	    case LOC_STATIC:
	    case LOC_REGISTER:
	    case LOC_BASEREG:
	      if (type == 'L')	/* collecting Locals */
		{
		  count++;
		  collect_symbol (collect, sym, frame_regno, frame_offset);
		}
	      break;
	    case LOC_ARG:
	    case LOC_LOCAL_ARG:
	    case LOC_REF_ARG:
	    case LOC_REGPARM:
	    case LOC_REGPARM_ADDR:
	    case LOC_BASEREG_ARG:
	      if (type == 'A')	/* collecting Arguments */
		{
		  count++;
		  collect_symbol (collect, sym, frame_regno, frame_offset);
		}
	    }
d1343 1
a1343 1
      free_agent_expr (list->aexpr_list[ndx]);
d1361 1
a1361 1
  long i;
d1364 1
a1364 1
  str_list = (char *(*)[]) xmalloc (count * sizeof (char *));
d1374 1
a1374 1
      *end++ = 'R';
d1377 1
a1377 1
	  QUIT;			/* allow user to bail out with ^C */
d1380 1
a1380 1
	  sprintf (end, "%02X", list->regs_mask[i]);
d1383 1
a1383 1
      (*str_list)[ndx] = savestring (temp_buf, end - temp_buf);
d1394 3
a1396 3
	printf_filtered ("(%d, 0x%x, %d)\n",
			 list->list[i].type,
			 list->list[i].start,
d1400 1
a1400 1
	  (*str_list)[ndx] = savestring (temp_buf, count);
d1405 3
a1407 3
      sprintf (end, "M%X,%X,%X",
	       list->list[i].type,
	       list->list[i].start,
d1418 1
a1418 1
	  (*str_list)[ndx] = savestring (temp_buf, count);
d1427 1
a1427 1
      end = mem2hex (list->aexpr_list[i]->buf, end, list->aexpr_list[i]->len);
d1433 1
a1433 1
      (*str_list)[ndx] = savestring (temp_buf, count);
d1454 1
a1454 1
free_actions_list (actions_list)
d1463 1
a1463 1
    free (actions_list[ndx]);
d1465 1
a1465 1
  free (actions_list);
d1471 7
a1477 7
     struct tracepoint *t;
     char ***tdp_actions;
     char ***stepping_actions;
{
  static char tdp_buff[2048], step_buff[2048];
  char *action_exp;
  struct expression *exp = NULL;
d1479 4
a1482 4
  bfd_signed_vma offset;
  long i;
  value_ptr tempval;
  struct collection_list *collect;
d1485 1
a1485 1
  long frame_reg, frame_offset;
d1513 77
a1589 5
	  do
	    {			/* repeat over a comma-separated list */
	      QUIT;		/* allow user to bail out with ^C */
	      while (isspace (*action_exp))
		action_exp++;
d1591 2
a1592 34
	      if (0 == strncasecmp ("$reg", action_exp, 4))
		{
		  for (i = 0; i < NUM_REGS; i++)
		    add_register (collect, i);
		  action_exp = strchr (action_exp, ',');	/* more? */
		}
	      else if (0 == strncasecmp ("$arg", action_exp, 4))
		{
		  add_local_symbols (collect,
				     t->address,
				     frame_reg,
				     frame_offset,
				     'A');
		  action_exp = strchr (action_exp, ',');	/* more? */
		}
	      else if (0 == strncasecmp ("$loc", action_exp, 4))
		{
		  add_local_symbols (collect,
				     t->address,
				     frame_reg,
				     frame_offset,
				     'L');
		  action_exp = strchr (action_exp, ',');	/* more? */
		}
	      else
		{
		  unsigned long addr, len;
		  struct cleanup *old_chain = NULL;
		  struct cleanup *old_chain1 = NULL;
		  struct agent_reqs areqs;

		  exp = parse_exp_1 (&action_exp, block_for_pc (t->address), 1);
		  old_chain = make_cleanup ((make_cleanup_func)
					    free_current_contents, &exp);
d1594 2
a1595 1
		  switch (exp->elts[0].opcode)
d1597 2
a1598 36
		    case OP_REGISTER:
		      i = exp->elts[1].longconst;
		      if (info_verbose)
			printf_filtered ("OP_REGISTER: ");
		      add_register (collect, i);
		      break;

		    case UNOP_MEMVAL:
		      /* safe because we know it's a simple expression */
		      tempval = evaluate_expression (exp);
		      addr = VALUE_ADDRESS (tempval) + VALUE_OFFSET (tempval);
		      len = TYPE_LENGTH (check_typedef (exp->elts[1].type));
		      add_memrange (collect, -1, addr, len);
		      break;

		    case OP_VAR_VALUE:
		      collect_symbol (collect,
				      exp->elts[2].symbol,
				      frame_reg,
				      frame_offset);
		      break;

		    default:	/* full-fledged expression */
		      aexpr = gen_trace_for_expr (t->address, exp);

		      old_chain1 = make_cleanup ((make_cleanup_func)
						 free_agent_expr, aexpr);

		      ax_reqs (aexpr, &areqs);
		      if (areqs.flaw != agent_flaw_none)
			error ("malformed expression");

		      if (areqs.min_height < 0)
			error ("gdb: Internal error: expression has min height < 0");
		      if (areqs.max_height > 20)
			error ("expression too complicated, try simplifying");
d1600 1
a1600 5
		      discard_cleanups (old_chain1);
		      add_aexpr (collect, aexpr);

		      /* take care of the registers */
		      if (areqs.reg_mask_len > 0)
d1602 2
a1603 4
			  int ndx1;
			  int ndx2;

			  for (ndx1 = 0; ndx1 < areqs.reg_mask_len; ndx1++)
d1605 5
a1609 9
			      QUIT;	/* allow user to bail out with ^C */
			      if (areqs.reg_mask[ndx1] != 0)
				{
				  /* assume chars have 8 bits */
				  for (ndx2 = 0; ndx2 < 8; ndx2++)
				    if (areqs.reg_mask[ndx1] & (1 << ndx2))
				      /* it's used -- record it */
				      add_register (collect, ndx1 * 8 + ndx2);
				}
d1612 7
a1618 7
		      break;
		    }		/* switch */
		  do_cleanups (old_chain);
		}		/* do */
	    }
	  while (action_exp && *action_exp++ == ',');
	}			/* if */
d1628 1
a1628 1
	    break;		/* end tracepoint actions */
d1630 3
a1632 3
    }				/* for */
  memrange_sortmerge (&tracepoint_list);
  memrange_sortmerge (&stepping_list);
d1634 2
a1635 2
  *tdp_actions = stringify_collection_list (&tracepoint_list, &tdp_buff);
  *stepping_actions = stringify_collection_list (&stepping_list, &step_buff);
d1639 1
a1639 1
add_aexpr (collect, aexpr)
d1647 1
a1647 1
		2 * collect->aexpr_listsize * sizeof (struct agent_expr *));
d1673 1
a1673 1
    return;			/* no information to give. */
d1680 2
a1681 2
      if ((s->flags & SEC_LOAD) == 0 ||
      /* (s->flags & SEC_CODE)     == 0 || */
d1686 1
a1686 1
      lma = s->lma;
d1699 1
a1699 1

d1709 1
a1709 1
{				/* STUB_COMM MOSTLY_IMPLEMENTED */
d1717 2
a1718 2
  dont_repeat ();		/* like "run", dangerous to repeat accidentally */

d1727 15
a1741 8
      {
	int ss_count;		/* if actions include singlestepping */
	int disable_mask;	/* ??? */
	int enable_mask;	/* ??? */

	sprintf (buf, "QTDP:%x:%x:%c:%x:%x", t->number, t->address,
		 t->enabled == enabled ? 'E' : 'D',
		 t->step_count, t->pass_count);
d1743 7
a1749 6
	if (t->actions)
	  strcat (buf, "-");
	putpkt (buf);
	remote_get_noisy_reply (target_buf);
	if (strcmp (target_buf, "OK"))
	  error ("Target does not support tracepoints.");
d1751 33
a1783 7
	if (t->actions)
	  {
	    encode_actions (t, &tdp_actions, &stepping_actions);
	    old_chain = make_cleanup (free_actions_list_cleanup_wrapper,
				      tdp_actions);
	    (void) make_cleanup (free_actions_list_cleanup_wrapper,
				 stepping_actions);
d1785 3
a1787 37
	    /* do_single_steps (t); */
	    if (tdp_actions)
	      {
		for (ndx = 0; tdp_actions[ndx]; ndx++)
		  {
		    QUIT;	/* allow user to bail out with ^C */
		    sprintf (buf, "QTDP:-%x:%x:%s%c",
			     t->number, t->address,
			     tdp_actions[ndx],
			     ((tdp_actions[ndx + 1] || stepping_actions)
			      ? '-' : 0));
		    putpkt (buf);
		    remote_get_noisy_reply (target_buf);
		    if (strcmp (target_buf, "OK"))
		      error ("Error on target while setting tracepoints.");
		  }
	      }
	    if (stepping_actions)
	      {
		for (ndx = 0; stepping_actions[ndx]; ndx++)
		  {
		    QUIT;	/* allow user to bail out with ^C */
		    sprintf (buf, "QTDP:-%x:%x:%s%s%s",
			     t->number, t->address,
			     ((ndx == 0) ? "S" : ""),
			     stepping_actions[ndx],
			     (stepping_actions[ndx + 1] ? "-" : ""));
		    putpkt (buf);
		    remote_get_noisy_reply (target_buf);
		    if (strcmp (target_buf, "OK"))
		      error ("Error on target while setting tracepoints.");
		  }
	      }

	    do_cleanups (old_chain);
	  }
      }
d1797 1
a1797 1
      set_traceframe_context (-1);
d1800 2
a1801 2
	trace_start_stop_hook (1, from_tty);

d1812 1
a1812 1
{				/* STUB_COMM IS_IMPLEMENTED */
d1821 1
a1821 1
	trace_start_stop_hook (0, from_tty);
d1834 1
a1834 1
{				/* STUB_COMM IS_IMPLEMENTED */
d1863 1
a1863 1
  old_func = find_pc_function (read_pc ());
d1869 24
a1892 7
    switch (*reply)
      {
      case 'F':
	if ((target_frameno = (int) strtol (++reply, &reply, 16)) == -1)
	  {
	    /* A request for a non-existant trace frame has failed.
	       Our response will be different, depending on FROM_TTY:
d1894 9
a1902 27
	       If FROM_TTY is true, meaning that this command was 
	       typed interactively by the user, then give an error
	       and DO NOT change the state of traceframe_number etc.

	       However if FROM_TTY is false, meaning that we're either
	       in a script, a loop, or a user-defined command, then 
	       DON'T give an error, but DO change the state of
	       traceframe_number etc. to invalid.

	       The rationalle is that if you typed the command, you
	       might just have committed a typo or something, and you'd
	       like to NOT lose your current debugging state.  However
	       if you're in a user-defined command or especially in a
	       loop, then you need a way to detect that the command
	       failed WITHOUT aborting.  This allows you to write
	       scripts that search thru the trace buffer until the end,
	       and then continue on to do something else.  */

	    if (from_tty)
	      error ("Target failed to find requested trace frame.");
	    else
	      {
		if (info_verbose)
		  printf_filtered ("End of trace buffer.\n");
		/* The following will not recurse, since it's special-cased */
		trace_find_command ("-1", from_tty);
		reply = NULL;	/* break out of loop, 
d1904 11
a1914 14
	      }
	  }
	break;
      case 'T':
	if ((target_tracept = (int) strtol (++reply, &reply, 16)) == -1)
	  error ("Target failed to find requested trace frame.");
	break;
      case 'O':		/* "OK"? */
	if (reply[1] == 'K' && reply[2] == '\0')
	  reply += 2;
	else
	  error ("Bogus reply from target: %s", reply);
	break;
      default:
d1916 4
a1919 1
      }
d1936 13
a1948 13
         whether we have made a transition from one function to another.
         If so, we'll print the "stack frame" (ie. the new function and
         it's arguments) -- otherwise we'll just show the new source line.

         This determination is made by checking (1) whether the current
         function has changed, and (2) whether the current FP has changed.
         Hack: if the FP wasn't collected, either at the current or the
         previous frame, assume that the FP has NOT changed.  */

      if (old_func == find_pc_function (read_pc ()) &&
	  (old_frame_addr == 0 ||
	   FRAME_FP (get_current_frame ()) == 0 ||
	   old_frame_addr == FRAME_FP (get_current_frame ())))
d1951 1
a1951 1
	source_only = 1;
d1968 3
a1970 3
   F<hexnum>    (gives the selected frame number)
   T<hexnum>    (gives the selected tracepoint number)
 */
d1977 1
a1977 1
{				/* STUB_COMM PART_IMPLEMENTED */
d1985 2
a1986 2
	trace_find_hook (args, from_tty);

d1988 1
a1988 1
	{			/* TFIND with no args means find NEXT trace frame. */
d2048 1
a2048 1
{				/* STUB_COMM PART_IMPLEMENTED */
d2071 1
a2071 1
{				/* STUB_COMM PART_IMPLEMENTED */
d2093 1
a2093 1

d2096 1
a2096 1

d2104 1
a2104 1
{				/* STUB_COMM PART_IMPLEMENTED */
d2124 1
a2124 1
	  sal = sals.sals[0];
d2134 2
a2135 2
	         user about a source line, at least let them have the symbolic
	         address.  */
d2144 1
a2144 1
	      return;		/* no line, no PC; what can we do? */
d2184 1
a2184 1
    error ("Trace can only be run on remote targets.");
d2192 1
a2192 1
{				/* STUB_COMM PART_IMPLEMENTED */
d2199 1
a2199 1
	{			/* XXX FIXME: what should default behavior be? */
d2204 1
a2204 1
      if (0 != (tmp = strchr (args, ',')))
d2210 1
a2210 1
	  stop = parse_and_eval_address (tmp);
d2213 1
a2213 1
	{			/* no explicit end address? */
d2215 1
a2215 1
	  stop = start + 1;	/* ??? */
d2222 1
a2222 1
    error ("Trace can only be run on remote targets.");
d2230 1
a2230 1
{				/* STUB_COMM PART_IMPLEMENTED */
d2237 1
a2237 1
	{			/* XXX FIXME: what should default behavior be? */
d2242 1
a2242 1
      if (0 != (tmp = strchr (args, ',')))
d2248 1
a2248 1
	  stop = parse_and_eval_address (tmp);
d2251 1
a2251 1
	{			/* no explicit end address? */
d2253 1
a2253 1
	  stop = start + 1;	/* ??? */
d2260 1
a2260 1
    error ("Trace can only be run on remote targets.");
d2269 1
a2269 1
  struct tracepoint *tp;
d2288 5
a2292 5
  {
    if (tp->addr_string)
      fprintf (fp, "trace %s\n", tp->addr_string);
    else
      fprintf (fp, "trace *0x%x\n", tp->address);
d2294 2
a2295 2
    if (tp->pass_count)
      fprintf (fp, "  passcount %d\n", tp->pass_count);
d2297 7
a2303 7
    if (tp->actions)
      {
	fprintf (fp, "  actions\n");
	indent = i1;
	for (line = tp->actions; line; line = line->next)
	  {
	    struct cmd_list_element *cmd;
d2305 4
a2308 4
	    QUIT;		/* allow user to bail out with ^C */
	    actionline = line->action;
	    while (isspace (*actionline))
	      actionline++;
d2310 14
a2323 14
	    fprintf (fp, "%s%s\n", indent, actionline);
	    if (*actionline != '#')	/* skip for comment lines */
	      {
		cmd = lookup_cmd (&actionline, cmdlist, "", -1, 1);
		if (cmd == 0)
		  error ("Bad action list item: %s", actionline);
		if (cmd->function.cfunc == while_stepping_pseudocommand)
		  indent = i2;
		else if (cmd->function.cfunc == end_actions_pseudocommand)
		  indent = i1;
	      }
	  }
      }
  }
d2349 1
a2349 1
    return;			/* presumably decode_line_1 has already warned */
d2357 1
a2357 1
      QUIT;			/* allow user to bail out with ^C */
d2361 1
a2361 1
	  QUIT;			/* allow user to bail out with ^C */
d2368 1
a2368 1
	    continue;		/* probably botched, certainly useless */
d2371 84
a2454 85
	  switch (SYMBOL_CLASS (sym))
	    {
	    default:
	    case LOC_UNDEF:	/* messed up symbol? */
	      printf_filtered ("a bogus symbol, class %d.\n",
			       SYMBOL_CLASS (sym));
	      count--;		/* don't count this one */
	      continue;
	    case LOC_CONST:
	      printf_filtered ("a constant with value %d (0x%x)",
			       SYMBOL_VALUE (sym), SYMBOL_VALUE (sym));
	      break;
	    case LOC_CONST_BYTES:
	      printf_filtered ("constant bytes: ");
	      if (SYMBOL_TYPE (sym))
		for (j = 0; j < TYPE_LENGTH (SYMBOL_TYPE (sym)); j++)
		  fprintf_filtered (gdb_stdout, " %02x",
				    (unsigned) SYMBOL_VALUE_BYTES (sym)[j]);
	      break;
	    case LOC_STATIC:
	      printf_filtered ("in static storage at address ");
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 1, gdb_stdout);
	      break;
	    case LOC_REGISTER:
	      printf_filtered ("a local variable in register $%s",
			       REGISTER_NAME (SYMBOL_VALUE (sym)));
	      break;
	    case LOC_ARG:
	    case LOC_LOCAL_ARG:
	      printf_filtered ("an argument at stack/frame offset %ld",
			       SYMBOL_VALUE (sym));
	      break;
	    case LOC_LOCAL:
	      printf_filtered ("a local variable at frame offset %ld",
			       SYMBOL_VALUE (sym));
	      break;
	    case LOC_REF_ARG:
	      printf_filtered ("a reference argument at offset %ld",
			       SYMBOL_VALUE (sym));
	      break;
	    case LOC_REGPARM:
	      printf_filtered ("an argument in register $%s",
			       REGISTER_NAME (SYMBOL_VALUE (sym)));
	      break;
	    case LOC_REGPARM_ADDR:
	      printf_filtered ("the address of an argument, in register $%s",
			       REGISTER_NAME (SYMBOL_VALUE (sym)));
	      break;
	    case LOC_TYPEDEF:
	      printf_filtered ("a typedef.\n");
	      continue;
	    case LOC_LABEL:
	      printf_filtered ("a label at address ");
	      print_address_numeric (SYMBOL_VALUE_ADDRESS (sym), 1, gdb_stdout);
	      break;
	    case LOC_BLOCK:
	      printf_filtered ("a function at address ");
	      print_address_numeric (BLOCK_START (SYMBOL_BLOCK_VALUE (sym)), 1,
				     gdb_stdout);
	      break;
	    case LOC_BASEREG:
	      printf_filtered ("a variable at offset %d from register $%s",
			       SYMBOL_VALUE (sym),
			       REGISTER_NAME (SYMBOL_BASEREG (sym)));
	      break;
	    case LOC_BASEREG_ARG:
	      printf_filtered ("an argument at offset %d from register $%s",
			       SYMBOL_VALUE (sym),
			       REGISTER_NAME (SYMBOL_BASEREG (sym)));
	      break;
	    case LOC_UNRESOLVED:
	      msym = lookup_minimal_symbol (SYMBOL_NAME (sym), NULL, NULL);
	      if (msym == NULL)
		printf_filtered ("Unresolved Static");
	      else
		{
		  printf_filtered ("static storage at address ");
		  print_address_numeric (SYMBOL_VALUE_ADDRESS (msym), 1,
					 gdb_stdout);
		}
	      break;
	    case LOC_OPTIMIZED_OUT:
	      printf_filtered ("optimized out.\n");
	      continue;
	    }
d2456 2
a2457 2
	    printf_filtered (", length %d.\n",
			   TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym))));
d2483 1
a2483 1
  struct tracepoint *t;
d2485 4
a2488 4
  char *action_exp, *next_comma;
  struct cleanup *old_cleanups;
  int stepping_actions = 0;
  int stepping_frame = 0;
d2504 1
a2504 1
    break;
d2507 1
a2507 1
    error ("No known tracepoint matches 'current' tracepoint #%d.",
d2512 1
a2512 1
  printf_filtered ("Data collected at tracepoint %d, trace frame %d:\n",
d2519 1
a2519 1
  stepping_frame = (t->address != read_pc ());
d2525 1
a2525 1
      QUIT;			/* allow user to bail out with ^C */
d2531 1
a2531 1
         bracketed by the commands "while-stepping" and "end".  */
d2553 30
a2582 32
	      do
		{		/* repeat over a comma-separated list */
		  QUIT;		/* allow user to bail out with ^C */
		  if (*action_exp == ',')
		    action_exp++;
		  while (isspace (*action_exp))
		    action_exp++;

		  next_comma = strchr (action_exp, ',');

		  if (0 == strncasecmp (action_exp, "$reg", 4))
		    registers_info (NULL, from_tty);
		  else if (0 == strncasecmp (action_exp, "$loc", 4))
		    locals_info (NULL, from_tty);
		  else if (0 == strncasecmp (action_exp, "$arg", 4))
		    args_info (NULL, from_tty);
		  else
		    {		/* variable */
		      if (next_comma)
			{
			  make_cleanup (replace_comma, next_comma);
			  *next_comma = '\0';
			}
		      printf_filtered ("%s = ", action_exp);
		      output_command (action_exp, from_tty);
		      printf_filtered ("\n");
		    }
		  if (next_comma)
		    *next_comma = ',';
		  action_exp = next_comma;
		}
	      while (action_exp && *action_exp == ',');
d2594 1
a2594 1
static const char hexchars[] = "0123456789abcdef";
d2597 1
a2597 1
mem2hex (mem, buf, count)
d2617 1
a2617 2
int
get_traceframe_number ()
d2619 1
a2619 1
  return traceframe_number;
d2627 2
a2628 2
  tracepoint_chain = 0;
  tracepoint_count = 0;
d2632 1
a2632 1
  set_internalvar (lookup_internalvar ("tpnum"),
d2634 2
a2635 2
  set_internalvar (lookup_internalvar ("trace_frame"),
		   value_from_longest (builtin_type_int, (LONGEST) - 1));
d2640 1
a2640 1
      tracepoint_list.list = xmalloc
d2653 1
a2653 1
      stepping_list.list = xmalloc
d2664 1
a2664 1
  add_info ("scope", scope_info,
d2667 2
a2668 2
  add_cmd ("tracepoints", class_trace, NO_FUNCTION,
	   "Tracing of program execution without stopping the program.",
d2678 1
a2678 1
  add_com ("save-tracepoints", class_trace, tracepoint_save_command,
d2682 1
a2682 1
  add_com ("tdump", class_trace, trace_dump_command,
d2685 1
a2685 1
  add_prefix_cmd ("tfind", class_trace, trace_find_command,
d2692 1
a2692 1
range.\nUsage: tfind outside addr1, addr2",
d2697 1
a2697 1
Usage: tfind range addr1,addr2",
d2730 1
a2730 1
  add_com ("tstatus", class_trace, trace_status_command,
d2733 1
a2733 1
  add_com ("tstop", class_trace, trace_stop_command,
d2739 1
a2739 1
  add_com ("passcount", class_trace, trace_pass_command,
d2760 2
a2761 2
  add_com_alias ("ws", "while-stepping", class_alias, 0);
  add_com_alias ("stepping", "while-stepping", class_alias, 0);
d2763 1
a2763 1
  add_com ("collect", class_trace, collect_pseudocommand,
d2779 1
a2779 1
  add_cmd ("tracepoints", class_trace, delete_trace_command,
d2785 1
a2785 1
  add_cmd ("tracepoints", class_trace, disable_trace_command,
d2791 1
a2791 1
  add_cmd ("tracepoints", class_trace, enable_trace_command,
d2804 3
a2806 3
  add_com_alias ("tp", "trace", class_alias, 0);
  add_com_alias ("tr", "trace", class_alias, 1);
  add_com_alias ("tra", "trace", class_alias, 1);
d2809 1
@


1.1.1.6
log
@import gdb-1999-08-30 snapshot
@
text
@d24 1
a31 2
#include "inferior.h"
#include "tracepoint.h"
a64 9
/* GDB commands implemented in other modules:
 */  

extern void output_command PARAMS ((char *, int));
extern void registers_info PARAMS ((char *, int));
extern void args_info      PARAMS ((char *, int));
extern void locals_info    PARAMS ((char *, int));


d143 1
d145 1
d148 1
a148 2
static void add_register PARAMS ((struct collection_list * collection, 
				  unsigned int regno));
a186 7
/* Entry points into remote.c (FIXME: move this interface down to tgt vector)
 */

extern int  putpkt PARAMS ((char *));
extern void getpkt PARAMS ((char *, int));
extern void remote_console_output PARAMS ((char *));

d535 3
a537 3
  enable_op,
  disable_op,
  delete_op
d540 1
a540 1
/* This function implements enable, disable and delete commands. */
d551 1
a551 1
    case enable_op:
d556 1
a556 1
    case disable_op:
d561 1
a561 1
    case delete_op:
d608 1
a608 1
      while (isalnum ((int) *end) || *end == '_')
d625 1
a625 1
	while (**arg && !isspace ((int) **arg))
d645 2
d670 1
a670 1
  map_args_over_tracepoints (args, from_tty, enable_op);
d680 1
a680 1
  map_args_over_tracepoints (args, from_tty, disable_op);
d696 1
a696 1
  map_args_over_tracepoints (args, from_tty, delete_op);
d711 1
a711 1
  unsigned int count;
d718 1
a718 1
  while (*args && isspace ((int) *args))
d748 5
d794 1
d929 1
d933 1
a933 1
  for (p = *line; isspace ((int) *p);)
d958 1
a958 1
	  while (isspace ((int) *p))
d963 3
d983 1
a983 1
		  warning ("constant %s (value %ld) will not be collected.",
d1025 1
a1025 1
      while (isspace ((int) *p))
d1032 1
a1032 1
	  warning ("'%s': bad step-count; command ignored.", *line);
d1065 1
a1065 1
  int type;		/* 0 for absolute memory range, else basereg number */
d1151 1
a1151 1
     unsigned int regno;
d1170 1
a1170 6
    {
      printf_filtered ("(%d,", type);
      printf_vma (base);
      printf_filtered (",%ld)\n", len);
    }

d1198 1
a1198 1
  unsigned int reg;
d1209 1
a1209 1
      printf_filtered ("constant %s (value %ld) will not be collected.\n",
d1215 2
a1216 7
	{
	  char tmp[40];

	  sprintf_vma (tmp, offset);
	  printf_filtered ("LOC_STATIC %s: collect %ld bytes at %s.\n",
			   SYMBOL_NAME (sym), len, tmp /* address */);
	}
d1241 1
a1241 1
	  printf_filtered ("LOC_LOCAL %s: Collect %ld bytes at offset ",
d1243 1
a1243 2
	  printf_vma (offset);
	  printf_filtered (" from frame ptr reg %d\n", reg);
d1252 1
a1252 1
	  printf_filtered ("LOC_REGPARM_ADDR %s: Collect %ld bytes at offset ",
d1254 1
a1254 2
	  printf_vma (offset);
	  printf_filtered (" from reg %d\n", reg);
d1264 1
a1264 1
	  printf_filtered ("LOC_LOCAL %s: Collect %ld bytes at offset ",
d1266 1
a1266 2
	  printf_vma (offset);
	  printf_filtered (" from frame ptr reg %d\n", reg);
d1276 2
a1277 4
	  printf_filtered ("LOC_BASEREG %s: collect %ld bytes at offset ",
			   SYMBOL_NAME (sym), len);
	  printf_vma (offset);
	  printf_filtered (" from basereg %d\n", reg);
a1313 3
	    default:
	      warning ("don't know how to trace local symbol %s", 
		       SYMBOL_NAME (sym));
a1369 1
  char tmp2[40];
a1405 1
      sprintf_vma (tmp2, list->list[i].start);
d1407 4
a1410 6
	{
	  printf_filtered ("(%d, %s, %ld)\n", 
			   list->list[i].type, 
			   tmp2, 
			   (long) (list->list[i].end - list->list[i].start));
	}
d1418 1
a1418 2

      sprintf (end, "M%X,%s,%lX", 
d1420 2
a1421 3
	       tmp2,
	       (long) (list->list[i].end - list->list[i].start));

d1423 1
a1423 1
      end += count;
d1492 2
a1493 1
  int i;
d1514 1
a1514 1
      while (isspace ((int) *action_exp))
d1529 1
a1529 1
	      while (isspace ((int) *action_exp))
d1694 1
a1694 1
      char tmp1[40], tmp2[40];
d1704 2
a1705 4
      sprintf_vma (tmp1, lma);
      sprintf_vma (tmp2, lma + size);
      sprintf (target_buf + strlen (target_buf), 
	       ":%s,%s", tmp1, tmp2);
d1744 3
a1746 1
	char tmp[40];
d1748 1
a1748 2
	sprintf_vma (tmp, t->address);
	sprintf (buf, "QTDP:%x:%s:%c:%x:%x", t->number, tmp, /* address */
d1773 2
a1774 2
		    sprintf (buf, "QTDP:-%x:%s:%s%c",
			     t->number, tmp, /* address */
d1789 2
a1790 2
		    sprintf (buf, "QTDP:-%x:%s:%s%s%s",
			     t->number, tmp, /* address */
d1997 1
d2067 1
a2067 1
  char tmp[40];
d2076 1
a2076 2
      sprintf_vma (tmp, pc);
      sprintf (target_buf, "QTFrame:pc:%s", tmp);
d2090 1
d2125 1
a2126 1
  char   startpc_str[40], endpc_str[40];
a2192 2
      sprintf_vma (startpc_str, start_pc);
      sprintf_vma (endpc_str, end_pc - 1);
d2194 1
a2194 1
	sprintf (target_buf, "QTFrame:range:%s:%s", startpc_str, endpc_str);
d2196 1
a2196 1
	sprintf (target_buf, "QTFrame:outside:%s:%s", startpc_str, endpc_str);
d2209 1
a2209 1
{
a2210 1
  char start_str[40], stop_str[40];
d2216 1
a2216 1
	{		/* XXX FIXME: what should default behavior be? */
d2224 1
a2224 1
	  while (isspace ((int) *tmp))
d2235 1
a2235 3
      sprintf_vma (start_str, start);
      sprintf_vma (stop_str, stop);
      sprintf (target_buf, "QTFrame:range:%s:%s", start_str, stop_str);
d2247 1
a2247 1
{
a2248 1
  char start_str[40], stop_str[40];
d2254 1
a2254 1
	{		/* XXX FIXME: what should default behavior be? */
d2262 1
a2262 1
	  while (isspace ((int) *tmp))
d2273 1
a2273 3
      sprintf_vma (start_str, start);
      sprintf_vma (stop_str, stop);
      sprintf (target_buf, "QTFrame:outside:%s:%s", start_str, stop_str);
a2290 1
  char tmp[40];
d2309 1
a2309 4
      {
	sprintf_vma (tmp, tp->address);
	fprintf (fp, "trace *0x%s\n", tmp);
      }
d2324 1
a2324 1
	    while (isspace ((int) *actionline))
d2353 1
d2397 1
a2397 1
	      printf_filtered ("a constant with value %ld (0x%lx)",
d2449 1
a2449 1
	      printf_filtered ("a variable at offset %ld from register $%s",
d2454 1
a2454 1
	      printf_filtered ("an argument at offset %ld from register $%s",
d2545 1
a2545 1
      while (isspace ((int) *action_exp))
d2576 1
a2576 1
		  while (isspace ((int) *action_exp))
@


1.1.1.7
log
@import gdb-1999-09-21
@
text
@a32 1
#include "remote.h"
d195 7
@


1.1.1.8
log
@import gdb-1999-09-28 snapshot
@
text
@d845 1
a845 1
      if (event_loop_p)
@


1.1.1.9
log
@import gdb-1999-11-01 snapshot
@
text
@a558 3
  if (t == NULL)	/* no tracepoint operand */
    return;

d598 1
a598 2
/* Utility: parse a tracepoint number and look it up in the list.
   If MULTI_P is true, there might be a range of tracepoints in ARG.  */
d600 1
a600 1
get_tracepoint_by_number (arg, multi_p)
a601 1
     int multi_p;
d604 2
a605 1
  char *instring = *arg;
d608 2
a609 2
  if (arg == NULL)
    error_no_arg ("tracepoint number");
d611 21
a631 2
  tpnum = multi_p ? get_number_or_range (arg) : get_number (arg);
  if (tpnum <= 0)
d633 4
a636 2
      printf_filtered ("bad tracepoint number at or near '%s'\n", instring);
      return NULL;
a637 1

a642 4

  /* FIXME: if we are in the middle of a range we don't want to give
     a message.  The current interface to get_number_or_range doesn't
     allow us to discover this.  */
d663 3
a665 2
	t = get_tracepoint_by_number (&args, 1);
	tracepoint_operation (t, from_tty, opcode);
a719 1
  int all = 0;
d730 1
a730 6
    {
      args += 3;			/* skip special argument "all" */
      all = 1;
      if (*args)
	error ("Junk at end of arguments.");
    }
d732 1
a732 1
    t1 = get_tracepoint_by_number (&args, 1);
d734 8
a741 1
  do
d743 6
a748 15
      if (t1)
	{
	  ALL_TRACEPOINTS (t2)
	    if (t1 == (struct tracepoint *) -1 || t1 == t2)
	      {
		t2->pass_count = count;
		if (modify_tracepoint_hook)
		  modify_tracepoint_hook (t2);
		if (from_tty)
		  printf_filtered ("Setting tracepoint %d's passcount to %d\n",
				   t2->number, count);
	      }
	}
      if (! all)
	t1 = get_tracepoint_by_number (&args, 1);
a749 1
  while (*args);
d800 1
a800 1
  t = get_tracepoint_by_number (&args, 0);
d820 1
d823 1
a823 1
  /* else just return */
@


1.1.1.10
log
@import gdb-1999-12-06 snapshot
@
text
@d199 2
a200 2
remote_get_noisy_reply (char *buf,
			long sizeof_buf)
d205 1
a205 1
      getpkt (buf, sizeof_buf, 0);
d602 1
a602 3
   If MULTI_P is true, there might be a range of tracepoints in ARG.
   if OPTIONAL_P is true, then if the argument is missing, the most
   recent tracepoint (tracepoint_count) is returned.  */
d604 1
a604 1
get_tracepoint_by_number (arg, multi_p, optional_p)
d606 1
a606 1
     int multi_p, optional_p;
d609 1
a610 1
  char *instring = arg == NULL ? NULL : *arg;
d612 2
a613 9
  if (arg == NULL || *arg == NULL || ! **arg)
    {
      if (optional_p)
	tpnum = tracepoint_count;
      else
	error_no_arg ("tracepoint number");
    }
  else
    tpnum = multi_p ? get_number_or_range (arg) : get_number (arg);
d615 1
d618 1
a618 4
      if (instring && *instring)
	printf_filtered ("bad tracepoint number at or near '%s'\n", instring);
      else
	printf_filtered ("Tracepoint argument missing and no previous tracepoint\n");
d651 1
a651 1
	t = get_tracepoint_by_number (&args, 1, 0);
d710 1
a710 1
    error ("passcount command requires an argument (count + optional TP num)");
d725 1
a725 1
    t1 = get_tracepoint_by_number (&args, 1, 1);
a740 2
	  if (! all && *args)
	    t1 = get_tracepoint_by_number (&args, 1, 0);
d742 2
d796 1
a796 1
  t = get_tracepoint_by_number (&args, 0, 1);
d1728 1
a1728 1
      getpkt (target_buf, sizeof (target_buf), 0);
d1756 1
a1756 1
      remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1772 1
a1772 1
	remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1796 1
a1796 1
		    remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1812 1
a1812 1
		    remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1825 1
a1825 1
      remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1849 1
a1849 1
      remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1871 1
a1871 1
      remote_get_noisy_reply (target_buf, sizeof (target_buf));
d1886 3
a1888 3
finish_tfind_command (char *msg,
		      long sizeof_msg,
		      int from_tty)
d1899 1
a1899 1
  reply = remote_get_noisy_reply (msg, sizeof_msg);
d2043 1
a2043 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2094 1
a2094 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2119 1
a2119 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2215 1
a2215 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2257 1
a2257 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
d2298 1
a2298 1
      finish_tfind_command (target_buf, sizeof (target_buf), from_tty);
@


1.1.1.11
log
@import gdb-1999-12-13 snapshot
@
text
@d502 1
a502 1
      printf_filtered ("%-5d %-5ld ", t->pass_count, t->step_count);
d1776 1
a1776 1
	sprintf (buf, "QTDP:%x:%s:%c:%lx:%x", t->number, tmp, /* address */
@


