head	1.150;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.139
	gdb_7_6-2013-04-26-release:1.139
	gdb_7_6-branch:1.139.0.2
	gdb_7_6-2013-03-12-branchpoint:1.139
	gdb_7_5_1-2012-11-29-release:1.131
	gdb_7_5-2012-08-17-release:1.131
	gdb_7_5-branch:1.131.0.2
	gdb_7_5-2012-07-18-branchpoint:1.131
	gdb_7_4_1-2012-04-26-release:1.124.2.1
	gdb_7_4-2012-01-24-release:1.124.2.1
	gdb_7_4-branch:1.124.0.2
	gdb_7_4-2011-12-13-branchpoint:1.124
	gdb_7_3_1-2011-09-04-release:1.121
	gdb_7_3-2011-07-26-release:1.121
	gdb_7_3-branch:1.121.0.2
	gdb_7_3-2011-04-01-branchpoint:1.121
	gdb_7_2-2010-09-02-release:1.108
	gdb_7_2-branch:1.108.0.2
	gdb_7_2-2010-07-07-branchpoint:1.108
	gdb_7_1-2010-03-18-release:1.105
	gdb_7_1-branch:1.105.0.2
	gdb_7_1-2010-02-18-branchpoint:1.105
	gdb_7_0_1-2009-12-22-release:1.95
	gdb_7_0-2009-10-06-release:1.95
	gdb_7_0-branch:1.95.0.4
	gdb_7_0-2009-09-16-branchpoint:1.95
	arc-sim-20090309:1.80
	msnyder-checkpoint-072509-branch:1.95.0.2
	msnyder-checkpoint-072509-branchpoint:1.95
	arc-insight_6_8-branch:1.80.0.6
	arc-insight_6_8-branchpoint:1.80
	insight_6_8-branch:1.80.0.4
	insight_6_8-branchpoint:1.80
	reverse-20081226-branch:1.88.0.4
	reverse-20081226-branchpoint:1.88
	multiprocess-20081120-branch:1.88.0.2
	multiprocess-20081120-branchpoint:1.88
	reverse-20080930-branch:1.85.0.2
	reverse-20080930-branchpoint:1.85
	reverse-20080717-branch:1.82.0.4
	reverse-20080717-branchpoint:1.82
	msnyder-reverse-20080609-branch:1.82.0.2
	msnyder-reverse-20080609-branchpoint:1.82
	drow-reverse-20070409-branch:1.66.0.2
	drow-reverse-20070409-branchpoint:1.66
	gdb_6_8-2008-03-27-release:1.80
	gdb_6_8-branch:1.80.0.2
	gdb_6_8-2008-02-26-branchpoint:1.80
	gdb_6_7_1-2007-10-29-release:1.74
	gdb_6_7-2007-10-10-release:1.74
	gdb_6_7-branch:1.74.0.2
	gdb_6_7-2007-09-07-branchpoint:1.74
	insight_6_6-20070208-release:1.63
	gdb_6_6-2006-12-18-release:1.63
	gdb_6_6-branch:1.63.0.18
	gdb_6_6-2006-11-15-branchpoint:1.63
	insight_6_5-20061003-release:1.63
	gdb-csl-symbian-6_4_50_20060226-12:1.63
	gdb-csl-sourcerygxx-3_4_4-25:1.62
	nickrob-async-20060828-mergepoint:1.63
	gdb-csl-symbian-6_4_50_20060226-11:1.63
	gdb-csl-sourcerygxx-4_1-17:1.63
	gdb-csl-20060226-branch-local-2:1.63
	gdb-csl-sourcerygxx-4_1-14:1.63
	gdb-csl-sourcerygxx-4_1-13:1.63
	gdb-csl-sourcerygxx-4_1-12:1.63
	gdb-csl-sourcerygxx-3_4_4-21:1.63
	gdb_6_5-20060621-release:1.63
	gdb-csl-sourcerygxx-4_1-9:1.63
	gdb-csl-sourcerygxx-4_1-8:1.63
	gdb-csl-sourcerygxx-4_1-7:1.63
	gdb-csl-arm-2006q1-6:1.63
	gdb-csl-sourcerygxx-4_1-6:1.63
	gdb-csl-symbian-6_4_50_20060226-10:1.63
	gdb-csl-symbian-6_4_50_20060226-9:1.63
	gdb-csl-symbian-6_4_50_20060226-8:1.63
	gdb-csl-coldfire-4_1-11:1.63
	gdb-csl-sourcerygxx-3_4_4-19:1.63
	gdb-csl-coldfire-4_1-10:1.63
	gdb_6_5-branch:1.63.0.16
	gdb_6_5-2006-05-14-branchpoint:1.63
	gdb-csl-sourcerygxx-4_1-5:1.63
	nickrob-async-20060513-branch:1.63.0.14
	nickrob-async-20060513-branchpoint:1.63
	gdb-csl-sourcerygxx-4_1-4:1.63
	msnyder-reverse-20060502-branch:1.63.0.12
	msnyder-reverse-20060502-branchpoint:1.63
	gdb-csl-morpho-4_1-4:1.63
	gdb-csl-sourcerygxx-3_4_4-17:1.63
	readline_5_1-import-branch:1.63.0.10
	readline_5_1-import-branchpoint:1.63
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.63
	gdb-csl-symbian-20060226-branch:1.63.0.8
	gdb-csl-symbian-20060226-branchpoint:1.63
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.63
	msnyder-reverse-20060331-branch:1.63.0.6
	msnyder-reverse-20060331-branchpoint:1.63
	gdb-csl-available-20060303-branch:1.63.0.4
	gdb-csl-available-20060303-branchpoint:1.63
	gdb-csl-20060226-branch:1.63.0.2
	gdb-csl-20060226-branchpoint:1.63
	gdb_6_4-20051202-release:1.62
	msnyder-fork-checkpoint-branch:1.62.0.8
	msnyder-fork-checkpoint-branchpoint:1.62
	gdb-csl-gxxpro-6_3-branch:1.62.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.62
	gdb_6_4-branch:1.62.0.4
	gdb_6_4-2005-11-01-branchpoint:1.62
	gdb-csl-arm-20051020-branch:1.62.0.2
	gdb-csl-arm-20051020-branchpoint:1.62
	msnyder-tracepoint-checkpoint-branch:1.61.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.61
	gdb-csl-arm-20050325-2005-q1b:1.61
	gdb-csl-arm-20050325-2005-q1a:1.61
	csl-arm-20050325-branch:1.61.0.2
	csl-arm-20050325-branchpoint:1.61
	gdb-post-i18n-errorwarning-20050211:1.61
	gdb-pre-i18n-errorwarning-20050211:1.60
	gdb_6_3-20041109-release:1.58
	gdb_6_3-branch:1.58.0.2
	gdb_6_3-20041019-branchpoint:1.58
	drow_intercu-merge-20040921:1.58
	drow_intercu-merge-20040915:1.58
	jimb-gdb_6_2-e500-branch:1.56.0.6
	jimb-gdb_6_2-e500-branchpoint:1.56
	gdb_6_2-20040730-release:1.56
	gdb_6_2-branch:1.56.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.56
	gdb_6_1_1-20040616-release:1.53
	gdb_6_1-2004-04-05-release:1.53
	drow_intercu-merge-20040402:1.53
	drow_intercu-merge-20040327:1.53
	ezannoni_pie-20040323-branch:1.53.0.6
	ezannoni_pie-20040323-branchpoint:1.53
	cagney_tramp-20040321-mergepoint:1.53
	cagney_tramp-20040309-branch:1.53.0.4
	cagney_tramp-20040309-branchpoint:1.53
	gdb_6_1-branch:1.53.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.53
	drow_intercu-20040221-branch:1.52.0.2
	drow_intercu-20040221-branchpoint:1.52
	cagney_bfdfile-20040213-branch:1.51.0.2
	cagney_bfdfile-20040213-branchpoint:1.51
	drow-cplus-merge-20040208:1.51
	carlton_dictionary-20040126-merge:1.50
	cagney_bigcore-20040122-branch:1.50.0.2
	cagney_bigcore-20040122-branchpoint:1.50
	drow-cplus-merge-20040113:1.50
	drow-cplus-merge-20031224:1.50
	drow-cplus-merge-20031220:1.50
	carlton_dictionary-20031215-merge:1.50
	drow-cplus-merge-20031214:1.50
	carlton-dictionary-20031111-merge:1.49
	gdb_6_0-2003-10-04-release:1.41
	kettenis_sparc-20030918-branch:1.44.0.4
	kettenis_sparc-20030918-branchpoint:1.44
	carlton_dictionary-20030917-merge:1.44
	ezannoni_pie-20030916-branchpoint:1.44
	ezannoni_pie-20030916-branch:1.44.0.2
	cagney_x86i386-20030821-branch:1.41.0.6
	cagney_x86i386-20030821-branchpoint:1.41
	carlton_dictionary-20030805-merge:1.41
	carlton_dictionary-20030627-merge:1.41
	gdb_6_0-branch:1.41.0.4
	gdb_6_0-2003-06-23-branchpoint:1.41
	jimb-ppc64-linux-20030613-branch:1.41.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.41
	cagney_convert-20030606-branch:1.39.0.4
	cagney_convert-20030606-branchpoint:1.39
	cagney_writestrings-20030508-branch:1.37.0.20
	cagney_writestrings-20030508-branchpoint:1.37
	jimb-ppc64-linux-20030528-branch:1.39.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.39
	carlton_dictionary-20030523-merge:1.38
	cagney_fileio-20030521-branch:1.38.0.2
	cagney_fileio-20030521-branchpoint:1.38
	kettenis_i386newframe-20030517-mergepoint:1.38
	jimb-ppc64-linux-20030509-branch:1.37.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.37
	kettenis_i386newframe-20030504-mergepoint:1.37
	carlton_dictionary-20030430-merge:1.37
	kettenis_i386newframe-20030419-branch:1.37.0.16
	kettenis_i386newframe-20030419-branchpoint:1.37
	carlton_dictionary-20030416-merge:1.37
	cagney_frameaddr-20030409-mergepoint:1.37
	kettenis_i386newframe-20030406-branch:1.37.0.14
	kettenis_i386newframe-20030406-branchpoint:1.37
	cagney_frameaddr-20030403-branchpoint:1.37
	cagney_frameaddr-20030403-branch:1.37.0.12
	cagney_framebase-20030330-mergepoint:1.37
	cagney_framebase-20030326-branch:1.37.0.10
	cagney_framebase-20030326-branchpoint:1.37
	cagney_lazyid-20030317-branch:1.37.0.8
	cagney_lazyid-20030317-branchpoint:1.37
	kettenis-i386newframe-20030316-mergepoint:1.37
	offbyone-20030313-branch:1.37.0.6
	offbyone-20030313-branchpoint:1.37
	kettenis-i386newframe-20030308-branch:1.37.0.4
	kettenis-i386newframe-20030308-branchpoint:1.37
	carlton_dictionary-20030305-merge:1.37
	cagney_offbyone-20030303-branch:1.37.0.2
	cagney_offbyone-20030303-branchpoint:1.37
	carlton_dictionary-20030207-merge:1.33
	interps-20030203-mergepoint:1.32
	interps-20030202-branch:1.32.0.4
	interps-20030202-branchpoint:1.32
	cagney-unwind-20030108-branch:1.32.0.2
	cagney-unwind-20030108-branchpoint:1.32
	carlton_dictionary-20021223-merge:1.32
	gdb_5_3-2002-12-12-release:1.29
	carlton_dictionary-20021115-merge:1.31
	kseitz_interps-20021105-merge:1.30
	kseitz_interps-20021103-merge:1.30
	drow-cplus-merge-20021020:1.29
	drow-cplus-merge-20021025:1.29
	carlton_dictionary-20021025-merge:1.29
	carlton_dictionary-20021011-merge:1.29
	drow-cplus-branch:1.29.0.10
	drow-cplus-branchpoint:1.29
	kseitz_interps-20020930-merge:1.29
	carlton_dictionary-20020927-merge:1.29
	carlton_dictionary-branch:1.29.0.8
	carlton_dictionary-20020920-branchpoint:1.29
	gdb_5_3-branch:1.29.0.6
	gdb_5_3-2002-09-04-branchpoint:1.29
	kseitz_interps-20020829-merge:1.29
	cagney_sysregs-20020825-branch:1.29.0.4
	cagney_sysregs-20020825-branchpoint:1.29
	readline_4_3-import-branch:1.29.0.2
	readline_4_3-import-branchpoint:1.29
	gdb_5_2_1-2002-07-23-release:1.25.2.1
	kseitz_interps-20020528-branch:1.26.0.6
	kseitz_interps-20020528-branchpoint:1.26
	cagney_regbuf-20020515-branch:1.26.0.4
	cagney_regbuf-20020515-branchpoint:1.26
	jimb-macro-020506-branch:1.26.0.2
	jimb-macro-020506-branchpoint:1.26
	gdb_5_2-2002-04-29-release:1.25.2.1
	gdb_5_2-branch:1.25.0.2
	gdb_5_2-2002-03-03-branchpoint:1.25
	gdb_5_1_1-2002-01-24-release:1.19
	gdb_5_1_0_1-2002-01-03-release:1.19
	cygnus_cvs_20020108_pre:1.22
	gdb_5_1_0_1-2002-01-03-branchpoint:1.19
	gdb_5_1_0_1-2002-01-03-branch:1.19.0.8
	gdb_5_1-2001-11-21-release:1.19
	gdb_s390-2001-09-26-branch:1.19.0.6
	gdb_s390-2001-09-26-branchpoint:1.19
	gdb_5_1-2001-07-29-branch:1.19.0.4
	gdb_5_1-2001-07-29-branchpoint:1.19
	dberlin-typesystem-branch:1.19.0.2
	dberlin-typesystem-branchpoint:1.19
	gdb-post-ptid_t-2001-05-03:1.17
	gdb-pre-ptid_t-2001-05-03:1.17
	insight-precleanup-2001-01-01:1.14
	gdb-post-protoization-2000-07-29:1.10
	gdb-pre-protoization-2000-07-29:1.9
	gdb-premipsmulti-2000-06-06-branch:1.8.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.8
	gdb-post-params-removal-2000-06-04:1.8
	gdb-pre-params-removal-2000-06-04:1.8
	gdb-post-params-removal-2000-05-28:1.8
	gdb-pre-params-removal-2000-05-28:1.7
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.11
	insight-2000-02-04:1.1.1.11
	gdb-2000-02-04:1.1.1.11
	gdb-2000-02-02:1.1.1.11
	gdb-2000-02-01:1.1.1.11
	gdb-2000-01-31:1.1.1.11
	gdb-2000-01-26:1.1.1.11
	gdb-2000-01-24:1.1.1.11
	gdb-2000-01-17:1.1.1.11
	gdb-2000-01-10:1.1.1.11
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.10
	gdb-1999-12-13:1.1.1.10
	gdb-1999-12-07:1.1.1.10
	gdb-1999-12-06:1.1.1.10
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.9
	gdb-1999-11-01:1.1.1.9
	gdb-1999-10-25:1.1.1.9
	gdb-1999-10-18:1.1.1.9
	gdb-1999-10-11:1.1.1.9
	gdb-1999-10-04:1.1.1.9
	gdb-1999-09-28:1.1.1.9
	gdb-1999-09-21:1.1.1.9
	gdb-1999-09-13:1.1.1.9
	gdb-1999-09-08:1.1.1.9
	gdb-1999-08-30:1.1.1.8
	gdb-1999-08-23:1.1.1.8
	gdb-1999-08-16:1.1.1.8
	gdb-1999-08-09:1.1.1.7
	gdb-1999-08-02:1.1.1.6
	gdb-1999-07-26:1.1.1.6
	gdb-1999-07-19:1.1.1.6
	gdb-1999-07-12:1.1.1.6
	gdb-post-reformat-19990707:1.1.1.6
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.6
	gdb-pre-reformat-19990707:1.1.1.5
	gdb-1999-07-07:1.1.1.5
	gdb-1999-07-05:1.1.1.5
	gdb-1999-06-28:1.1.1.5
	gdb-1999-06-21:1.1.1.5
	gdb-1999-06-14:1.1.1.5
	gdb-1999-06-07:1.1.1.5
	gdb-1999-06-01:1.1.1.5
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.5
	gdb-1999-05-19:1.1.1.4
	gdb-1999-05-10:1.1.1.4
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.150
date	2013.09.25.22.48.18;	author devans;	state Exp;
branches;
next	1.149;

1.149
date	2013.09.24.14.00.06;	author jkratoch;	state Exp;
branches;
next	1.148;

1.148
date	2013.09.24.13.57.36;	author jkratoch;	state Exp;
branches;
next	1.147;

1.147
date	2013.08.20.18.57.00;	author devans;	state Exp;
branches;
next	1.146;

1.146
date	2013.07.18.01.45.15;	author qiyao;	state Exp;
branches;
next	1.145;

1.145
date	2013.04.08.20.13.21;	author tromey;	state Exp;
branches;
next	1.144;

1.144
date	2013.04.08.20.04.42;	author tromey;	state Exp;
branches;
next	1.143;

1.143
date	2013.04.08.19.56.03;	author tromey;	state Exp;
branches;
next	1.142;

1.142
date	2013.04.08.19.48.30;	author tromey;	state Exp;
branches;
next	1.141;

1.141
date	2013.03.29.02.04.15;	author brobecke;	state Exp;
branches;
next	1.140;

1.140
date	2013.03.20.18.33.05;	author tromey;	state Exp;
branches;
next	1.139;

1.139
date	2013.01.21.18.13.13;	author tromey;	state Exp;
branches;
next	1.138;

1.138
date	2013.01.21.18.05.13;	author tromey;	state Exp;
branches;
next	1.137;

1.137
date	2013.01.01.06.32.40;	author brobecke;	state Exp;
branches;
next	1.136;

1.136
date	2012.12.15.13.10.50;	author brobecke;	state Exp;
branches;
next	1.135;

1.135
date	2012.12.12.16.22.33;	author tromey;	state Exp;
branches;
next	1.134;

1.134
date	2012.12.12.15.57.01;	author tromey;	state Exp;
branches;
next	1.133;

1.133
date	2012.11.21.00.29.54;	author qiyao;	state Exp;
branches;
next	1.132;

1.132
date	2012.07.23.14.58.44;	author tromey;	state Exp;
branches;
next	1.131;

1.131
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.130;

1.130
date	2012.05.16.22.10.48;	author sergiodj;	state Exp;
branches;
next	1.129;

1.129
date	2012.05.10.19.50.07;	author tromey;	state Exp;
branches;
next	1.128;

1.128
date	2012.04.27.20.47.52;	author sergiodj;	state Exp;
branches;
next	1.127;

1.127
date	2012.04.18.06.46.46;	author jkratoch;	state Exp;
branches;
next	1.126;

1.126
date	2012.02.07.04.48.18;	author devans;	state Exp;
branches;
next	1.125;

1.125
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.124;

1.124
date	2011.06.14.18.53.13;	author tromey;	state Exp;
branches
	1.124.2.1;
next	1.123;

1.123
date	2011.06.14.16.49.40;	author tromey;	state Exp;
branches;
next	1.122;

1.122
date	2011.05.26.07.47.10;	author gingold;	state Exp;
branches;
next	1.121;

1.121
date	2011.03.17.13.19.23;	author brobecke;	state Exp;
branches;
next	1.120;

1.120
date	2011.03.09.12.48.55;	author palves;	state Exp;
branches;
next	1.119;

1.119
date	2011.03.07.16.17.28;	author tromey;	state Exp;
branches;
next	1.118;

1.118
date	2011.03.01.01.58.33;	author msnyder;	state Exp;
branches;
next	1.117;

1.117
date	2011.02.28.23.17.07;	author msnyder;	state Exp;
branches;
next	1.116;

1.116
date	2011.01.10.17.14.12;	author msnyder;	state Exp;
branches;
next	1.115;

1.115
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.114;

1.114
date	2011.01.05.22.22.47;	author msnyder;	state Exp;
branches;
next	1.113;

1.113
date	2011.01.01.15.32.58;	author brobecke;	state Exp;
branches;
next	1.112;

1.112
date	2010.12.31.22.59.52;	author msnyder;	state Exp;
branches;
next	1.111;

1.111
date	2010.09.30.19.14.30;	author tromey;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.10.16.12.22;	author muller;	state Exp;
branches;
next	1.109;

1.109
date	2010.08.09.19.42.46;	author swagiaal;	state Exp;
branches;
next	1.108;

1.108
date	2010.05.13.23.53.32;	author msnyder;	state Exp;
branches;
next	1.107;

1.107
date	2010.05.05.23.44.19;	author msnyder;	state Exp;
branches;
next	1.106;

1.106
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	1.105;

1.105
date	2010.02.03.14.13.16;	author gingold;	state Exp;
branches;
next	1.104;

1.104
date	2010.01.19.09.47.47;	author brobecke;	state Exp;
branches;
next	1.103;

1.103
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.102;

1.102
date	2009.12.09.13.44.52;	author gingold;	state Exp;
branches;
next	1.101;

1.101
date	2009.12.07.09.47.39;	author gingold;	state Exp;
branches;
next	1.100;

1.100
date	2009.12.07.09.36.43;	author gingold;	state Exp;
branches;
next	1.99;

1.99
date	2009.12.02.11.44.35;	author gingold;	state Exp;
branches;
next	1.98;

1.98
date	2009.12.02.11.34.37;	author gingold;	state Exp;
branches;
next	1.97;

1.97
date	2009.11.16.18.40.21;	author tromey;	state Exp;
branches;
next	1.96;

1.96
date	2009.10.06.22.47.20;	author muller;	state Exp;
branches;
next	1.95;

1.95
date	2009.06.29.13.18.37;	author uweigand;	state Exp;
branches;
next	1.94;

1.94
date	2009.06.17.18.41.50;	author uweigand;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.04.12.28.39;	author uweigand;	state Exp;
branches;
next	1.92;

1.92
date	2009.05.23.16.17.13;	author jkratoch;	state Exp;
branches;
next	1.91;

1.91
date	2009.05.23.09.32.47;	author eliz;	state Exp;
branches;
next	1.90;

1.90
date	2009.05.23.09.26.06;	author eliz;	state Exp;
branches;
next	1.89;

1.89
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.88;

1.88
date	2008.11.08.09.38.06;	author eliz;	state Exp;
branches;
next	1.87;

1.87
date	2008.10.08.12.49.12;	author jkratoch;	state Exp;
branches;
next	1.86;

1.86
date	2008.10.01.16.41.27;	author tromey;	state Exp;
branches;
next	1.85;

1.85
date	2008.08.24.16.39.56;	author tromey;	state Exp;
branches;
next	1.84;

1.84
date	2008.08.21.18.14.38;	author drow;	state Exp;
branches;
next	1.83;

1.83
date	2008.08.01.01.09.00;	author shebs;	state Exp;
branches;
next	1.82;

1.82
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.16.11.21.42;	author deuling;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.78;

1.78
date	2007.12.04.23.33.00;	author uweigand;	state Exp;
branches;
next	1.77;

1.77
date	2007.10.22.01.16.34;	author drow;	state Exp;
branches;
next	1.76;

1.76
date	2007.10.11.19.48.02;	author drow;	state Exp;
branches;
next	1.75;

1.75
date	2007.09.21.18.01.23;	author brobecke;	state Exp;
branches;
next	1.74;

1.74
date	2007.08.23.18.08.27;	author brobecke;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.19.17.21.51;	author uweigand;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.18.15.46.37;	author drow;	state Exp;
branches;
next	1.71;

1.71
date	2007.06.12.16.59.42;	author uweigand;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.12.16.55.32;	author uweigand;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.12.15.33.03;	author uweigand;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.06.15.32.25;	author uweigand;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.03.23.06.29;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.28.16.53.54;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.04.13.29.10;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2005.02.11.04.05.45;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2005.01.29.17.53.26;	author ibr;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.23.16.18.08;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2004.08.10.21.52.04;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2004.08.10.19.37.47;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.10.15.52.04;	author ford;	state Exp;
branches;
next	1.55;

1.55
date	2004.05.07.14.29.33;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2004.04.02.19.23.05;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.27.17.46.11;	author eliz;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.14.15.46.32;	author ezannoni;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2004.02.07.23.13.46;	author ezannoni;	state Exp;
branches;
next	1.50;

1.50
date	2003.11.23.20.41.16;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2003.11.06.02.52.27;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.05.15.30.35;	author ezannoni;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.05.15.27.31;	author ezannoni;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.21.01.26.44;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.16.18.56.34;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.12.18.40.16;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.11.23.29.46;	author carlton;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.11.22.27.09;	author carlton;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.23.16.16.00;	author ezannoni;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.14.17.43.16;	author ezannoni;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.25.21.36.17;	author carlton;	state Exp;
branches
	1.37.16.1;
next	1.36;

1.36
date	2003.02.20.18.31.14;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.20.03.12.46;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.20.00.01.05;	author carlton;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.04.18.07.00;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.17.00.39.07;	author kevinb;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.11.00.55.34;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.25.22.25.55;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.22.05.50.11;	author jimb;	state Exp;
branches
	1.29.8.1
	1.29.10.1;
next	1.28;

1.28
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.11.20.46.19;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.19.19.00.03;	author aoliva;	state Exp;
branches
	1.26.6.1;
next	1.25;

1.25
date	2002.02.06.01.20.23;	author ezannoni;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2002.02.04.11.55.34;	author rearnsha;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.02.03.42.58;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.05.04.30.15;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.02.22.38.23;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.20.03.03.39;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.01.10.04.58;	author eliz;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.05.29.10.45.10;	author aoliva;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.26.02.50.46;	author ezannoni;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.26.02.48.23;	author ezannoni;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.04.04.01.15;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.24.21.13.08;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.07.15.02.48;	author ezannoni;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.30.01.48.24;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.12.14.05.44;	author ezannoni;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.22.09.02.22;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.16.04.07.39;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.11.20.39.58;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.04.16.52.33;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.12.41.48;	author phdm;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.04.39.01;	author kingdon;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.124.2.1
date	2012.01.06.04.43.06;	author brobecke;	state Exp;
branches;
next	;

1.52.2.1
date	2004.02.23.19.33.47;	author drow;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2004.03.27.17.37.44;	author drow;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2004.09.16.17.00.54;	author drow;	state Exp;
branches;
next	;

1.37.16.1
date	2003.05.18.09.44.00;	author kettenis;	state Exp;
branches;
next	;

1.29.8.1
date	2002.09.20.18.52.16;	author carlton;	state Exp;
branches;
next	1.29.8.2;

1.29.8.2
date	2002.09.24.00.04.50;	author carlton;	state Exp;
branches;
next	1.29.8.3;

1.29.8.3
date	2002.10.18.23.42.57;	author carlton;	state Exp;
branches;
next	1.29.8.4;

1.29.8.4
date	2002.11.15.19.18.37;	author carlton;	state Exp;
branches;
next	1.29.8.5;

1.29.8.5
date	2002.12.23.19.38.14;	author carlton;	state Exp;
branches;
next	1.29.8.6;

1.29.8.6
date	2003.02.07.19.17.45;	author carlton;	state Exp;
branches;
next	1.29.8.7;

1.29.8.7
date	2003.02.22.01.33.13;	author carlton;	state Exp;
branches;
next	1.29.8.8;

1.29.8.8
date	2003.03.06.00.56.24;	author carlton;	state Exp;
branches;
next	1.29.8.9;

1.29.8.9
date	2003.05.23.18.40.35;	author carlton;	state Exp;
branches;
next	1.29.8.10;

1.29.8.10
date	2003.06.27.21.49.46;	author carlton;	state Exp;
branches;
next	1.29.8.11;

1.29.8.11
date	2003.09.17.21.28.08;	author carlton;	state Exp;
branches;
next	1.29.8.12;

1.29.8.12
date	2003.11.11.23.50.39;	author carlton;	state Exp;
branches;
next	1.29.8.13;

1.29.8.13
date	2003.12.16.00.00.15;	author carlton;	state Exp;
branches;
next	;

1.29.10.1
date	2003.12.14.20.27.08;	author drow;	state Exp;
branches;
next	1.29.10.2;

1.29.10.2
date	2004.02.09.19.43.31;	author drow;	state Exp;
branches;
next	;

1.26.6.1
date	2002.07.22.21.46.56;	author kseitz;	state Exp;
branches;
next	1.26.6.2;

1.26.6.2
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	1.26.6.3;

1.26.6.3
date	2002.08.30.22.52.42;	author kseitz;	state Exp;
branches;
next	1.26.6.4;

1.26.6.4
date	2002.11.04.00.17.29;	author ezannoni;	state Exp;
branches;
next	;

1.25.2.1
date	2002.03.25.16.50.20;	author aoliva;	state Exp;
branches;
next	;

1.19.2.1
date	2001.07.06.19.16.57;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.46;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.15;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.11.13.28.59;	author shebs;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.05.25.18.01.16;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.07.07.20.04.55;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.08.09.21.33.20;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.16.19.52.09;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.09.08.23.59.04;	author shebs;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.12.07.03.55.58;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2000.01.11.03.07.19;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.150
log
@	* symfile.h (struct sym_fns): Delete member "sym_flavour".
	All uses updated.
	(add_symtab_fns): Update prototype.
	* symfile.c (sym_fns_ptr): Delete.  Replace with ...
	(registered_sym_fns): ... this.
	(symtab_fns): Update.
	(add_symtab_fns): New arg "flavour".  All callers updated.
	(find_sym_fns): Rewrite to use new sym_fns registry.
@
text
@/* Read coff symbol tables and convert to internal format, for GDB.
   Copyright (C) 1987-2013 Free Software Foundation, Inc.
   Contributed by David D. Johnson, Brown University (ddj@@cs.brown.edu).

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "demangle.h"
#include "breakpoint.h"

#include "bfd.h"
#include "gdb_obstack.h"

#include "gdb_string.h"
#include <ctype.h>

#include "coff/internal.h"	/* Internal format of COFF symbols in BFD */
#include "libcoff.h"		/* FIXME secret internal data from BFD */
#include "objfiles.h"
#include "buildsym.h"
#include "gdb-stabs.h"
#include "stabsread.h"
#include "complaints.h"
#include "target.h"
#include "gdb_assert.h"
#include "block.h"
#include "dictionary.h"

#include "coff-pe-read.h"

#include "psymtab.h"

extern void _initialize_coffread (void);

/* Key for COFF-associated data.  */

static const struct objfile_data *coff_objfile_data_key;

/* The objfile we are currently reading.  */

static struct objfile *coffread_objfile;

struct coff_symfile_info
  {
    file_ptr min_lineno_offset;	/* Where in file lowest line#s are.  */
    file_ptr max_lineno_offset;	/* 1+last byte of line#s in file.  */

    CORE_ADDR textaddr;		/* Addr of .text section.  */
    unsigned int textsize;	/* Size of .text section.  */
    struct stab_section_list *stabsects;	/* .stab sections.  */
    asection *stabstrsect;	/* Section pointer for .stab section.  */
    char *stabstrdata;
  };

/* Translate an external name string into a user-visible name.  */
#define	EXTERNAL_NAME(string, abfd) \
	(string[0] == bfd_get_symbol_leading_char (abfd) \
	? string + 1 : string)

/* To be an sdb debug type, type must have at least a basic or primary
   derived type.  Using this rather than checking against T_NULL is
   said to prevent core dumps if we try to operate on Michael Bloom
   dbx-in-coff file.  */

#define SDB_TYPE(type) (BTYPE(type) | (type & N_TMASK))

/* Core address of start and end of text of current source file.
   This comes from a ".text" symbol where x_nlinno > 0.  */

static CORE_ADDR current_source_start_addr;
static CORE_ADDR current_source_end_addr;

/* The addresses of the symbol table stream and number of symbols
   of the object file we are reading (as copied into core).  */

static bfd *nlist_bfd_global;
static int nlist_nsyms_global;


/* Pointers to scratch storage, used for reading raw symbols and
   auxents.  */

static char *temp_sym;
static char *temp_aux;

/* Local variables that hold the shift and mask values for the
   COFF file that we are currently reading.  These come back to us
   from BFD, and are referenced by their macro names, as well as
   internally to the BTYPE, ISPTR, ISFCN, ISARY, ISTAG, and DECREF
   macros from include/coff/internal.h .  */

static unsigned local_n_btmask;
static unsigned local_n_btshft;
static unsigned local_n_tmask;
static unsigned local_n_tshift;

#define	N_BTMASK	local_n_btmask
#define	N_BTSHFT	local_n_btshft
#define	N_TMASK		local_n_tmask
#define	N_TSHIFT	local_n_tshift

/* Local variables that hold the sizes in the file of various COFF
   structures.  (We only need to know this to read them from the file
   -- BFD will then translate the data in them, into `internal_xxx'
   structs in the right byte order, alignment, etc.)  */

static unsigned local_linesz;
static unsigned local_symesz;
static unsigned local_auxesz;

/* This is set if this is a PE format file.  */

static int pe_file;

/* Chain of typedefs of pointers to empty struct/union types.
   They are chained thru the SYMBOL_VALUE_CHAIN.  */

static struct symbol *opaque_type_chain[HASHSIZE];

/* Simplified internal version of coff symbol table information.  */

struct coff_symbol
  {
    char *c_name;
    int c_symnum;		/* Symbol number of this entry.  */
    int c_naux;			/* 0 if syment only, 1 if syment +
				   auxent, etc.  */
    CORE_ADDR c_value;
    int c_sclass;
    int c_secnum;
    unsigned int c_type;
  };

/* Vector of types defined so far, indexed by their type numbers.  */

static struct type **type_vector;

/* Number of elements allocated for type_vector currently.  */

static int type_vector_length;

/* Initial size of type vector.  Is realloc'd larger if needed, and
   realloc'd down to the size actually used, when completed.  */

#define INITIAL_TYPE_VECTOR_LENGTH 160

extern void stabsread_clear_cache (void);

static struct type *coff_read_struct_type (int, int, int,
					   struct objfile *);

static struct type *decode_base_type (struct coff_symbol *,
				      unsigned int,
				      union internal_auxent *,
				      struct objfile *);

static struct type *decode_type (struct coff_symbol *, unsigned int,
				 union internal_auxent *,
				 struct objfile *);

static struct type *decode_function_type (struct coff_symbol *,
					  unsigned int,
					  union internal_auxent *,
					  struct objfile *);

static struct type *coff_read_enum_type (int, int, int,
					 struct objfile *);

static struct symbol *process_coff_symbol (struct coff_symbol *,
					   union internal_auxent *,
					   struct objfile *);

static void patch_opaque_types (struct symtab *);

static void enter_linenos (long, int, int, struct objfile *);

static void free_linetab (void);

static void free_linetab_cleanup (void *ignore);

static int init_lineno (bfd *, long, int);

static char *getsymname (struct internal_syment *);

static const char *coff_getfilename (union internal_auxent *);

static void free_stringtab (void);

static void free_stringtab_cleanup (void *ignore);

static int init_stringtab (bfd *, long);

static void read_one_sym (struct coff_symbol *,
			  struct internal_syment *,
			  union internal_auxent *);

static void coff_symtab_read (long, unsigned int, struct objfile *);

/* We are called once per section from coff_symfile_read.  We
   need to examine each section we are passed, check to see
   if it is something we are interested in processing, and
   if so, stash away some access information for the section.

   FIXME: The section names should not be hardwired strings (what
   should they be?  I don't think most object file formats have enough
   section flags to specify what kind of debug section it is
   -kingdon).  */

static void
coff_locate_sections (bfd *abfd, asection *sectp, void *csip)
{
  struct coff_symfile_info *csi;
  const char *name;

  csi = (struct coff_symfile_info *) csip;
  name = bfd_get_section_name (abfd, sectp);
  if (strcmp (name, ".text") == 0)
    {
      csi->textaddr = bfd_section_vma (abfd, sectp);
      csi->textsize += bfd_section_size (abfd, sectp);
    }
  else if (strncmp (name, ".text", sizeof ".text" - 1) == 0)
    {
      csi->textsize += bfd_section_size (abfd, sectp);
    }
  else if (strcmp (name, ".stabstr") == 0)
    {
      csi->stabstrsect = sectp;
    }
  else if (strncmp (name, ".stab", sizeof ".stab" - 1) == 0)
    {
      const char *s;

      /* We can have multiple .stab sections if linked with
         --split-by-reloc.  */
      for (s = name + sizeof ".stab" - 1; *s != '\0'; s++)
	if (!isdigit (*s))
	  break;
      if (*s == '\0')
	{
	  struct stab_section_list *n, **pn;

	  n = ((struct stab_section_list *)
	       xmalloc (sizeof (struct stab_section_list)));
	  n->section = sectp;
	  n->next = NULL;
	  for (pn = &csi->stabsects; *pn != NULL; pn = &(*pn)->next)
	    ;
	  *pn = n;

	  /* This will be run after coffstab_build_psymtabs is called
	     in coff_symfile_read, at which point we no longer need
	     the information.  */
	  make_cleanup (xfree, n);
	}
    }
}

/* Return the section_offsets* that CS points to.  */
static int cs_to_section (struct coff_symbol *, struct objfile *);

struct find_targ_sec_arg
  {
    int targ_index;
    asection **resultp;
  };

static void
find_targ_sec (bfd *abfd, asection *sect, void *obj)
{
  struct find_targ_sec_arg *args = (struct find_targ_sec_arg *) obj;

  if (sect->target_index == args->targ_index)
    *args->resultp = sect;
}

/* Return the bfd_section that CS points to.  */
static struct bfd_section*
cs_to_bfd_section (struct coff_symbol *cs, struct objfile *objfile)
{
  asection *sect = NULL;
  struct find_targ_sec_arg args;

  args.targ_index = cs->c_secnum;
  args.resultp = &sect;
  bfd_map_over_sections (objfile->obfd, find_targ_sec, &args);
  return sect;
}

/* Return the section number (SECT_OFF_*) that CS points to.  */
static int
cs_to_section (struct coff_symbol *cs, struct objfile *objfile)
{
  asection *sect = cs_to_bfd_section (cs, objfile);

  if (sect == NULL)
    return SECT_OFF_TEXT (objfile);
  return gdb_bfd_section_index (objfile->obfd, sect);
}

/* Return the address of the section of a COFF symbol.  */

static CORE_ADDR cs_section_address (struct coff_symbol *, bfd *);

static CORE_ADDR
cs_section_address (struct coff_symbol *cs, bfd *abfd)
{
  asection *sect = NULL;
  struct find_targ_sec_arg args;
  CORE_ADDR addr = 0;

  args.targ_index = cs->c_secnum;
  args.resultp = &sect;
  bfd_map_over_sections (abfd, find_targ_sec, &args);
  if (sect != NULL)
    addr = bfd_get_section_vma (abfd, sect);
  return addr;
}

/* Look up a coff type-number index.  Return the address of the slot
   where the type for that index is stored.
   The type-number is in INDEX. 

   This can be used for finding the type associated with that index
   or for associating a new type with the index.  */

static struct type **
coff_lookup_type (int index)
{
  if (index >= type_vector_length)
    {
      int old_vector_length = type_vector_length;

      type_vector_length *= 2;
      if (index /* is still */  >= type_vector_length)
	type_vector_length = index * 2;

      type_vector = (struct type **)
	xrealloc ((char *) type_vector,
		  type_vector_length * sizeof (struct type *));
      memset (&type_vector[old_vector_length], 0,
	 (type_vector_length - old_vector_length) * sizeof (struct type *));
    }
  return &type_vector[index];
}

/* Make sure there is a type allocated for type number index
   and return the type object.
   This can create an empty (zeroed) type object.  */

static struct type *
coff_alloc_type (int index)
{
  struct type **type_addr = coff_lookup_type (index);
  struct type *type = *type_addr;

  /* If we are referring to a type not known at all yet,
     allocate an empty type for it.
     We will fill it in later if we find out how.  */
  if (type == NULL)
    {
      type = alloc_type (coffread_objfile);
      *type_addr = type;
    }
  return type;
}

/* Start a new symtab for a new source file.
   This is called when a COFF ".file" symbol is seen;
   it indicates the start of data for one original source file.  */

static void
coff_start_symtab (const char *name)
{
  start_symtab (
  /* We fill in the filename later.  start_symtab puts this pointer
     into last_source_file and we put it in subfiles->name, which
     end_symtab frees; that's why it must be malloc'd.  */
		 xstrdup (name),
  /* We never know the directory name for COFF.  */
		 NULL,
  /* The start address is irrelevant, since we set
     last_source_start_addr in coff_end_symtab.  */
		 0);
  record_debugformat ("COFF");
}

/* Save the vital information from when starting to read a file,
   for use when closing off the current file.
   NAME is the file name the symbols came from, START_ADDR is the
   first text address for the file, and SIZE is the number of bytes of
   text.  */

static void
complete_symtab (const char *name, CORE_ADDR start_addr, unsigned int size)
{
  set_last_source_file (name);
  current_source_start_addr = start_addr;
  current_source_end_addr = start_addr + size;
}

/* Finish the symbol definitions for one main source file, close off
   all the lexical contexts for that file (creating struct block's for
   them), then make the struct symtab for that file and put it in the
   list of all such.  */

static void
coff_end_symtab (struct objfile *objfile)
{
  last_source_start_addr = current_source_start_addr;

  end_symtab (current_source_end_addr, objfile,
	      SECT_OFF_TEXT (objfile));

  /* Reinitialize for beginning of new file.  */
  set_last_source_file (NULL);
}

/* The linker sometimes generates some non-function symbols inside
   functions referencing variables imported from another DLL.
   Return nonzero if the given symbol corresponds to one of them.  */

static int
is_import_fixup_symbol (struct coff_symbol *cs,
			enum minimal_symbol_type type)
{
  /* The following is a bit of a heuristic using the characterictics
     of these fixup symbols, but should work well in practice...  */
  int i;

  /* Must be a non-static text symbol.  */
  if (type != mst_text)
    return 0;

  /* Must be a non-function symbol.  */
  if (ISFCN (cs->c_type))
    return 0;

  /* The name must start with "__fu<digits>__".  */
  if (strncmp (cs->c_name, "__fu", 4) != 0)
    return 0;
  if (! isdigit (cs->c_name[4]))
    return 0;
  for (i = 5; cs->c_name[i] != '\0' && isdigit (cs->c_name[i]); i++)
    /* Nothing, just incrementing index past all digits.  */;
  if (cs->c_name[i] != '_' || cs->c_name[i + 1] != '_')
    return 0;

  return 1;
}

static struct minimal_symbol *
record_minimal_symbol (struct coff_symbol *cs, CORE_ADDR address,
		       enum minimal_symbol_type type, int section, 
		       struct objfile *objfile)
{
  /* We don't want TDESC entry points in the minimal symbol table.  */
  if (cs->c_name[0] == '@@')
    return NULL;

  if (is_import_fixup_symbol (cs, type))
    {
      /* Because the value of these symbols is within a function code
	 range, these symbols interfere with the symbol-from-address
	 reverse lookup; this manifests itselfs in backtraces, or any
	 other commands that prints symbolic addresses.  Just pretend
	 these symbols do not exist.  */
      return NULL;
    }

  return prim_record_minimal_symbol_and_info (cs->c_name, address,
					      type, section, objfile);
}

/* coff_symfile_init ()
   is the coff-specific initialization routine for reading symbols.
   It is passed a struct objfile which contains, among other things,
   the BFD for the file whose symbols are being read, and a slot for
   a pointer to "private data" which we fill with cookies and other
   treats for coff_symfile_read ().

   We will only be called if this is a COFF or COFF-like file.  BFD
   handles figuring out the format of the file, and code in symtab.c
   uses BFD's determination to vector to us.

   The ultimate result is a new symtab (or, FIXME, eventually a
   psymtab).  */

static void
coff_symfile_init (struct objfile *objfile)
{
  struct dbx_symfile_info *dbx;
  struct coff_symfile_info *coff;

  /* Allocate struct to keep track of stab reading.  */
  dbx = XCNEW (struct dbx_symfile_info);
  set_objfile_data (objfile, dbx_objfile_data_key, dbx);

  /* Allocate struct to keep track of the symfile.  */
  coff = XCNEW (struct coff_symfile_info);
  set_objfile_data (objfile, coff_objfile_data_key, coff);

  /* COFF objects may be reordered, so set OBJF_REORDERED.  If we
     find this causes a significant slowdown in gdb then we could
     set it in the debug symbol readers only when necessary.  */
  objfile->flags |= OBJF_REORDERED;
}

/* This function is called for every section; it finds the outer
   limits of the line table (minimum and maximum file offset) so that
   the mainline code can read the whole thing for efficiency.  */

static void
find_linenos (bfd *abfd, struct bfd_section *asect, void *vpinfo)
{
  struct coff_symfile_info *info;
  int size, count;
  file_ptr offset, maxoff;

  /* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
  count = asect->lineno_count;
  /* End of warning.  */

  if (count == 0)
    return;
  size = count * local_linesz;

  info = (struct coff_symfile_info *) vpinfo;
  /* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
  offset = asect->line_filepos;
  /* End of warning.  */

  if (offset < info->min_lineno_offset || info->min_lineno_offset == 0)
    info->min_lineno_offset = offset;

  maxoff = offset + size;
  if (maxoff > info->max_lineno_offset)
    info->max_lineno_offset = maxoff;
}


/* The BFD for this file -- only good while we're actively reading
   symbols into a psymtab or a symtab.  */

static bfd *symfile_bfd;

/* Read a symbol file, after initialization by coff_symfile_init.  */

static void
coff_symfile_read (struct objfile *objfile, int symfile_flags)
{
  struct coff_symfile_info *info;
  struct dbx_symfile_info *dbxinfo;
  bfd *abfd = objfile->obfd;
  coff_data_type *cdata = coff_data (abfd);
  char *name = bfd_get_filename (abfd);
  int val;
  unsigned int num_symbols;
  int symtab_offset;
  int stringtab_offset;
  struct cleanup *back_to, *cleanup_minimal_symbols;
  int stabstrsize;
  
  info = objfile_data (objfile, coff_objfile_data_key);
  dbxinfo = DBX_SYMFILE_INFO (objfile);
  symfile_bfd = abfd;		/* Kludge for swap routines.  */

/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
  num_symbols = bfd_get_symcount (abfd);	/* How many syms */
  symtab_offset = cdata->sym_filepos;	/* Symbol table file offset */
  stringtab_offset = symtab_offset +	/* String table file offset */
    num_symbols * cdata->local_symesz;

  /* Set a few file-statics that give us specific information about
     the particular COFF file format we're reading.  */
  local_n_btmask = cdata->local_n_btmask;
  local_n_btshft = cdata->local_n_btshft;
  local_n_tmask = cdata->local_n_tmask;
  local_n_tshift = cdata->local_n_tshift;
  local_linesz = cdata->local_linesz;
  local_symesz = cdata->local_symesz;
  local_auxesz = cdata->local_auxesz;

  /* Allocate space for raw symbol and aux entries, based on their
     space requirements as reported by BFD.  */
  temp_sym = (char *) xmalloc
    (cdata->local_symesz + cdata->local_auxesz);
  temp_aux = temp_sym + cdata->local_symesz;
  back_to = make_cleanup (free_current_contents, &temp_sym);

  /* We need to know whether this is a PE file, because in PE files,
     unlike standard COFF files, symbol values are stored as offsets
     from the section address, rather than as absolute addresses.
     FIXME: We should use BFD to read the symbol table, and thus avoid
     this problem.  */
  pe_file =
    strncmp (bfd_get_target (objfile->obfd), "pe", 2) == 0
    || strncmp (bfd_get_target (objfile->obfd), "epoc-pe", 7) == 0;

  /* End of warning.  */

  info->min_lineno_offset = 0;
  info->max_lineno_offset = 0;

  /* Only read line number information if we have symbols.

     On Windows NT, some of the system's DLL's have sections with
     PointerToLinenumbers fields that are non-zero, but point at
     random places within the image file.  (In the case I found,
     KERNEL32.DLL's .text section has a line number info pointer that
     points into the middle of the string `lib\\i386\kernel32.dll'.)

     However, these DLL's also have no symbols.  The line number
     tables are meaningless without symbols.  And in fact, GDB never
     uses the line number information unless there are symbols.  So we
     can avoid spurious error messages (and maybe run a little
     faster!) by not even reading the line number table unless we have
     symbols.  */
  if (num_symbols > 0)
    {
      /* Read the line number table, all at once.  */
      bfd_map_over_sections (abfd, find_linenos, (void *) info);

      make_cleanup (free_linetab_cleanup, 0 /*ignore*/);
      val = init_lineno (abfd, info->min_lineno_offset,
                         info->max_lineno_offset - info->min_lineno_offset);
      if (val < 0)
        error (_("\"%s\": error reading line numbers."), name);
    }

  /* Now read the string table, all at once.  */

  make_cleanup (free_stringtab_cleanup, 0 /*ignore*/);
  val = init_stringtab (abfd, stringtab_offset);
  if (val < 0)
    error (_("\"%s\": can't get string table"), name);

  init_minimal_symbol_collection ();
  cleanup_minimal_symbols = make_cleanup_discard_minimal_symbols ();

  /* Now that the executable file is positioned at symbol table,
     process it and define symbols accordingly.  */

  coff_symtab_read ((long) symtab_offset, num_symbols, objfile);

  /* Install any minimal symbols that have been collected as the
     current minimal symbols for this objfile.  */

  install_minimal_symbols (objfile);

  if (pe_file)
    {
      struct minimal_symbol *msym;

      ALL_OBJFILE_MSYMBOLS (objfile, msym)
	{
	  const char *name = SYMBOL_LINKAGE_NAME (msym);

	  /* If the minimal symbols whose name are prefixed by "__imp_"
	     or "_imp_", get rid of the prefix, and search the minimal
	     symbol in OBJFILE.  Note that 'maintenance print msymbols'
	     shows that type of these "_imp_XXXX" symbols is mst_data.  */
	  if (MSYMBOL_TYPE (msym) == mst_data
	      && (strncmp (name, "__imp_", 6) == 0
		  || strncmp (name, "_imp_", 5) == 0))
	    {
	      const char *name1 = (name[1] == '_' ? &name[7] : &name[6]);
	      struct minimal_symbol *found;

	      found = lookup_minimal_symbol (name1, NULL, objfile);
	      /* If found, there are symbols named "_imp_foo" and "foo"
		 respectively in OBJFILE.  Set the type of symbol "foo"
		 as 'mst_solib_trampoline'.  */
	      if (found != NULL && MSYMBOL_TYPE (found) == mst_text)
		MSYMBOL_TYPE (found) = mst_solib_trampoline;
	    }
	}
    }

  /* Free the installed minimal symbol data.  */
  do_cleanups (cleanup_minimal_symbols);

  bfd_map_over_sections (abfd, coff_locate_sections, (void *) info);

  if (info->stabsects)
    {
      if (!info->stabstrsect)
	{
	  error (_("The debugging information in `%s' is corrupted.\nThe "
		   "file has a `.stabs' section, but no `.stabstr' section."),
		 name);
	}

      /* FIXME: dubious.  Why can't we use something normal like
         bfd_get_section_contents?  */
      bfd_seek (abfd, abfd->where, 0);

      stabstrsize = bfd_section_size (abfd, info->stabstrsect);

      coffstab_build_psymtabs (objfile,
			       info->textaddr, info->textsize,
			       info->stabsects,
			       info->stabstrsect->filepos, stabstrsize);
    }
  if (dwarf2_has_info (objfile, NULL))
    {
      /* DWARF2 sections.  */
      dwarf2_build_psymtabs (objfile);
    }

  dwarf2_build_frame_info (objfile);

  /* Try to add separate debug file if no symbols table found.   */
  if (!objfile_has_partial_symbols (objfile))
    {
      char *debugfile;

      debugfile = find_separate_debug_file_by_debuglink (objfile);
      make_cleanup (xfree, debugfile);

      if (debugfile)
	{
	  bfd *abfd = symfile_bfd_open (debugfile);

	  make_cleanup_bfd_unref (abfd);
	  symbol_file_add_separate (abfd, debugfile, symfile_flags, objfile);
	}
    }

  do_cleanups (back_to);
}

static void
coff_new_init (struct objfile *ignore)
{
}

/* Perform any local cleanups required when we are done with a
   particular objfile.  I.E, we are in the process of discarding all
   symbol information for an objfile, freeing up all memory held for
   it, and unlinking the objfile struct from the global list of known
   objfiles.  */

static void
coff_symfile_finish (struct objfile *objfile)
{
  /* Let stabs reader clean up.  */
  stabsread_clear_cache ();

  dwarf2_free_objfile (objfile);
}


/* Given pointers to a symbol table in coff style exec file,
   analyze them and create struct symtab's describing the symbols.
   NSYMS is the number of symbols in the symbol table.
   We read them one at a time using read_one_sym ().  */

static void
coff_symtab_read (long symtab_offset, unsigned int nsyms,
		  struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct context_stack *new;
  struct coff_symbol coff_symbol;
  struct coff_symbol *cs = &coff_symbol;
  static struct internal_syment main_sym;
  static union internal_auxent main_aux;
  struct coff_symbol fcn_cs_saved;
  static struct internal_syment fcn_sym_saved;
  static union internal_auxent fcn_aux_saved;
  struct symtab *s;
  /* A .file is open.  */
  int in_source_file = 0;
  int next_file_symnum = -1;
  /* Name of the current file.  */
  const char *filestring = "";
  int depth = 0;
  int fcn_first_line = 0;
  CORE_ADDR fcn_first_line_addr = 0;
  int fcn_last_line = 0;
  int fcn_start_addr = 0;
  long fcn_line_ptr = 0;
  int val;
  CORE_ADDR tmpaddr;
  struct minimal_symbol *msym;

  /* Work around a stdio bug in SunOS4.1.1 (this makes me nervous....
     it's hard to know I've really worked around it.  The fix should
     be harmless, anyway).  The symptom of the bug is that the first
     fread (in read_one_sym), will (in my example) actually get data
     from file offset 268, when the fseek was to 264 (and ftell shows
     264).  This causes all hell to break loose.  I was unable to
     reproduce this on a short test program which operated on the same
     file, performing (I think) the same sequence of operations.

     It stopped happening when I put in this (former) rewind().

     FIXME: Find out if this has been reported to Sun, whether it has
     been fixed in a later release, etc.  */

  bfd_seek (objfile->obfd, 0, 0);

  /* Position to read the symbol table.  */
  val = bfd_seek (objfile->obfd, (long) symtab_offset, 0);
  if (val < 0)
    perror_with_name (objfile_name (objfile));

  coffread_objfile = objfile;
  nlist_bfd_global = objfile->obfd;
  nlist_nsyms_global = nsyms;
  set_last_source_file (NULL);
  memset (opaque_type_chain, 0, sizeof opaque_type_chain);

  if (type_vector)		/* Get rid of previous one.  */
    xfree (type_vector);
  type_vector_length = INITIAL_TYPE_VECTOR_LENGTH;
  type_vector = (struct type **)
    xmalloc (type_vector_length * sizeof (struct type *));
  memset (type_vector, 0, type_vector_length * sizeof (struct type *));

  coff_start_symtab ("");

  symnum = 0;
  while (symnum < nsyms)
    {
      QUIT;			/* Make this command interruptable.  */

      read_one_sym (cs, &main_sym, &main_aux);

      if (cs->c_symnum == next_file_symnum && cs->c_sclass != C_FILE)
	{
	  if (get_last_source_file ())
	    coff_end_symtab (objfile);

	  coff_start_symtab ("_globals_");
	  /* coff_start_symtab will set the language of this symtab to
	     language_unknown, since such a ``file name'' is not
	     recognized.  Override that with the minimal language to
	     allow printing values in this symtab.  */
	  current_subfile->language = language_minimal;
	  complete_symtab ("_globals_", 0, 0);
	  /* Done with all files, everything from here on out is
	     globals.  */
	}

      /* Special case for file with type declarations only, no
	 text.  */
      if (!get_last_source_file () && SDB_TYPE (cs->c_type)
	  && cs->c_secnum == N_DEBUG)
	complete_symtab (filestring, 0, 0);

      /* Typedefs should not be treated as symbol definitions.  */
      if (ISFCN (cs->c_type) && cs->c_sclass != C_TPDEF)
	{
	  /* Record all functions -- external and static -- in
	     minsyms.  */
	  int section = cs_to_section (cs, objfile);

	  tmpaddr = cs->c_value + ANOFFSET (objfile->section_offsets,
					    SECT_OFF_TEXT (objfile));
	  record_minimal_symbol (cs, tmpaddr, mst_text,
				 section, objfile);

	  fcn_line_ptr = main_aux.x_sym.x_fcnary.x_fcn.x_lnnoptr;
	  fcn_start_addr = tmpaddr;
	  fcn_cs_saved = *cs;
	  fcn_sym_saved = main_sym;
	  fcn_aux_saved = main_aux;
	  continue;
	}

      switch (cs->c_sclass)
	{
	case C_EFCN:
	case C_EXTDEF:
	case C_ULABEL:
	case C_USTATIC:
	case C_LINE:
	case C_ALIAS:
	case C_HIDDEN:
	  complaint (&symfile_complaints,
		     _("Bad n_sclass for symbol %s"),
		     cs->c_name);
	  break;

	case C_FILE:
	  /* c_value field contains symnum of next .file entry in
	     table or symnum of first global after last .file.  */
	  next_file_symnum = cs->c_value;
	  if (cs->c_naux > 0)
	    filestring = coff_getfilename (&main_aux);
	  else
	    filestring = "";

	  /* Complete symbol table for last object file
	     containing debugging information.  */
	  if (get_last_source_file ())
	    {
	      coff_end_symtab (objfile);
	      coff_start_symtab (filestring);
	    }
	  in_source_file = 1;
	  break;

	  /* C_LABEL is used for labels and static functions.
	     Including it here allows gdb to see static functions when
	     no debug info is available.  */
	case C_LABEL:
	  /* However, labels within a function can make weird
	     backtraces, so filter them out (from phdm@@macqel.be).  */
	  if (within_function)
	    break;
	case C_STAT:
	case C_THUMBLABEL:
	case C_THUMBSTAT:
	case C_THUMBSTATFUNC:
	  if (cs->c_name[0] == '.')
	    {
	      if (strcmp (cs->c_name, ".text") == 0)
		{
		  /* FIXME: don't wire in ".text" as section name or
		     symbol name!  */
		  /* Check for in_source_file deals with case of a
		     file with debugging symbols followed by a later
		     file with no symbols.  */
		  if (in_source_file)
		    complete_symtab (filestring,
		    cs->c_value + ANOFFSET (objfile->section_offsets,
					    SECT_OFF_TEXT (objfile)),
				     main_aux.x_scn.x_scnlen);
		  in_source_file = 0;
		}
	      /* Flush rest of '.' symbols.  */
	      break;
	    }
	  else if (!SDB_TYPE (cs->c_type)
		   && cs->c_name[0] == 'L'
		   && (strncmp (cs->c_name, "LI%", 3) == 0
		       || strncmp (cs->c_name, "LF%", 3) == 0
		       || strncmp (cs->c_name, "LC%", 3) == 0
		       || strncmp (cs->c_name, "LP%", 3) == 0
		       || strncmp (cs->c_name, "LPB%", 4) == 0
		       || strncmp (cs->c_name, "LBB%", 4) == 0
		       || strncmp (cs->c_name, "LBE%", 4) == 0
		       || strncmp (cs->c_name, "LPBX%", 5) == 0))
	    /* At least on a 3b1, gcc generates swbeg and string labels
	       that look like this.  Ignore them.  */
	    break;
	  /* Fall in for static symbols that don't start with '.'  */
	case C_THUMBEXT:
	case C_THUMBEXTFUNC:
	case C_EXT:
	  {
	    /* Record it in the minimal symbols regardless of
	       SDB_TYPE.  This parallels what we do for other debug
	       formats, and probably is needed to make
	       print_address_symbolic work right without the (now
	       gone) "set fast-symbolic-addr off" kludge.  */

	    enum minimal_symbol_type ms_type;
	    int sec;

	    if (cs->c_secnum == N_UNDEF)
	      {
		/* This is a common symbol.  We used to rely on
		   the target to tell us whether it knows where
		   the symbol has been relocated to, but none of
		   the target implementations actually provided
		   that operation.  So we just ignore the symbol,
		   the same way we would do if we had a target-side
		   symbol lookup which returned no match.  */
		break;
	      }
 	    else if (cs->c_secnum == N_ABS)
 	      {
 		/* Use the correct minimal symbol type (and don't
 		   relocate) for absolute values.  */
 		ms_type = mst_abs;
 		sec = cs_to_section (cs, objfile);
 		tmpaddr = cs->c_value;
 	      }
	    else
	      {
		asection *bfd_section = cs_to_bfd_section (cs, objfile);

		sec = cs_to_section (cs, objfile);
		tmpaddr = cs->c_value;
 		/* Statics in a PE file also get relocated.  */
 		if (cs->c_sclass == C_EXT
 		    || cs->c_sclass == C_THUMBEXTFUNC
 		    || cs->c_sclass == C_THUMBEXT
 		    || (pe_file && (cs->c_sclass == C_STAT)))
		  tmpaddr += ANOFFSET (objfile->section_offsets, sec);

		if (bfd_section->flags & SEC_CODE)
		  {
		    ms_type =
		      cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXTFUNC
		      || cs->c_sclass == C_THUMBEXT ?
		      mst_text : mst_file_text;
		    tmpaddr = gdbarch_addr_bits_remove (gdbarch, tmpaddr);
		  }
		else if (bfd_section->flags & SEC_ALLOC
			 && bfd_section->flags & SEC_LOAD)
		  {
		    ms_type =
		      cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXT
		      ? mst_data : mst_file_data;
		  }
		else if (bfd_section->flags & SEC_ALLOC)
		  {
		    ms_type =
		      cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXT
		      ? mst_bss : mst_file_bss;
		  }
		else
		  ms_type = mst_unknown;
	      }

	    msym = record_minimal_symbol (cs, tmpaddr, ms_type,
					  sec, objfile);
	    if (msym)
	      gdbarch_coff_make_msymbol_special (gdbarch,
						 cs->c_sclass, msym);

	    if (SDB_TYPE (cs->c_type))
	      {
		struct symbol *sym;

		sym = process_coff_symbol
		  (cs, &main_aux, objfile);
		SYMBOL_VALUE (sym) = tmpaddr;
		SYMBOL_SECTION (sym) = sec;
	      }
	  }
	  break;

	case C_FCN:
	  if (strcmp (cs->c_name, ".bf") == 0)
	    {
	      within_function = 1;

	      /* Value contains address of first non-init type
		 code.  */
	      /* main_aux.x_sym.x_misc.x_lnsz.x_lnno
	         contains line number of '{' }.  */
	      if (cs->c_naux != 1)
		complaint (&symfile_complaints,
			   _("`.bf' symbol %d has no aux entry"),
			   cs->c_symnum);
	      fcn_first_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;
	      fcn_first_line_addr = cs->c_value;

	      /* Might want to check that locals are 0 and
	         context_stack_depth is zero, and complain if not.  */

	      depth = 0;
	      new = push_context (depth, fcn_start_addr);
	      fcn_cs_saved.c_name = getsymname (&fcn_sym_saved);
	      new->name =
		process_coff_symbol (&fcn_cs_saved, 
				     &fcn_aux_saved, objfile);
	    }
	  else if (strcmp (cs->c_name, ".ef") == 0)
	    {
	      if (!within_function)
		error (_("Bad coff function information."));
	      /* The value of .ef is the address of epilogue code;
	         not useful for gdb.  */
	      /* { main_aux.x_sym.x_misc.x_lnsz.x_lnno
	         contains number of lines to '}' */

	      if (context_stack_depth <= 0)
		{	/* We attempted to pop an empty context stack.  */
		  complaint (&symfile_complaints,
			     _("`.ef' symbol without matching `.bf' "
			       "symbol ignored starting at symnum %d"),
			     cs->c_symnum);
		  within_function = 0;
		  break;
		}

	      new = pop_context ();
	      /* Stack must be empty now.  */
	      if (context_stack_depth > 0 || new == NULL)
		{
		  complaint (&symfile_complaints,
			     _("Unmatched .ef symbol(s) ignored "
			       "starting at symnum %d"),
			     cs->c_symnum);
		  within_function = 0;
		  break;
		}
	      if (cs->c_naux != 1)
		{
		  complaint (&symfile_complaints,
			     _("`.ef' symbol %d has no aux entry"),
			     cs->c_symnum);
		  fcn_last_line = 0x7FFFFFFF;
		}
	      else
		{
		  fcn_last_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;
		}
	      /* fcn_first_line is the line number of the opening '{'.
	         Do not record it - because it would affect gdb's idea
	         of the line number of the first statement of the
	         function - except for one-line functions, for which
	         it is also the line number of all the statements and
	         of the closing '}', and for which we do not have any
	         other statement-line-number.  */
	      if (fcn_last_line == 1)
		record_line (current_subfile, fcn_first_line,
			     gdbarch_addr_bits_remove (gdbarch,
						       fcn_first_line_addr));
	      else
		enter_linenos (fcn_line_ptr, fcn_first_line,
			       fcn_last_line, objfile);

	      finish_block (new->name, &local_symbols,
			    new->old_blocks, new->start_addr,
			    fcn_cs_saved.c_value
			    + fcn_aux_saved.x_sym.x_misc.x_fsize
			    + ANOFFSET (objfile->section_offsets,
					SECT_OFF_TEXT (objfile)),
			    objfile
		);
	      within_function = 0;
	    }
	  break;

	case C_BLOCK:
	  if (strcmp (cs->c_name, ".bb") == 0)
	    {
	      tmpaddr = cs->c_value;
	      tmpaddr += ANOFFSET (objfile->section_offsets,
				   SECT_OFF_TEXT (objfile));
	      push_context (++depth, tmpaddr);
	    }
	  else if (strcmp (cs->c_name, ".eb") == 0)
	    {
	      if (context_stack_depth <= 0)
		{	/* We attempted to pop an empty context stack.  */
		  complaint (&symfile_complaints,
			     _("`.eb' symbol without matching `.bb' "
			       "symbol ignored starting at symnum %d"),
			     cs->c_symnum);
		  break;
		}

	      new = pop_context ();
	      if (depth-- != new->depth)
		{
		  complaint (&symfile_complaints,
			     _("Mismatched .eb symbol ignored "
			       "starting at symnum %d"),
			     symnum);
		  break;
		}
	      if (local_symbols && context_stack_depth > 0)
		{
		  tmpaddr =
		    cs->c_value + ANOFFSET (objfile->section_offsets,
					    SECT_OFF_TEXT (objfile));
		  /* Make a block for the local symbols within.  */
		  finish_block (0, &local_symbols, new->old_blocks,
				new->start_addr, tmpaddr, objfile);
		}
	      /* Now pop locals of block just finished.  */
	      local_symbols = new->locals;
	    }
	  break;

	default:
	  process_coff_symbol (cs, &main_aux, objfile);
	  break;
	}
    }

  if ((nsyms == 0) && (pe_file))
    {
      /* We've got no debugging symbols, but it's a portable
	 executable, so try to read the export table.  */
      read_pe_exported_syms (objfile);
    }

  if (get_last_source_file ())
    coff_end_symtab (objfile);

  /* Patch up any opaque types (references to types that are not defined
     in the file where they are referenced, e.g. "struct foo *bar").  */
  ALL_OBJFILE_SYMTABS (objfile, s)
    patch_opaque_types (s);

  coffread_objfile = NULL;
}

/* Routines for reading headers and symbols from executable.  */

/* Read the next symbol, swap it, and return it in both
   internal_syment form, and coff_symbol form.  Also return its first
   auxent, if any, in internal_auxent form, and skip any other
   auxents.  */

static void
read_one_sym (struct coff_symbol *cs,
	      struct internal_syment *sym,
	      union internal_auxent *aux)
{
  int i;
  bfd_size_type bytes;

  cs->c_symnum = symnum;
  bytes = bfd_bread (temp_sym, local_symesz, nlist_bfd_global);
  if (bytes != local_symesz)
    error (_("%s: error reading symbols"), objfile_name (coffread_objfile));
  bfd_coff_swap_sym_in (symfile_bfd, temp_sym, (char *) sym);
  cs->c_naux = sym->n_numaux & 0xff;
  if (cs->c_naux >= 1)
    {
      bytes  = bfd_bread (temp_aux, local_auxesz, nlist_bfd_global);
      if (bytes != local_auxesz)
	error (_("%s: error reading symbols"), objfile_name (coffread_objfile));
      bfd_coff_swap_aux_in (symfile_bfd, temp_aux,
			    sym->n_type, sym->n_sclass,
			    0, cs->c_naux, (char *) aux);
      /* If more than one aux entry, read past it (only the first aux
         is important).  */
      for (i = 1; i < cs->c_naux; i++)
	{
	  bytes = bfd_bread (temp_aux, local_auxesz, nlist_bfd_global);
	  if (bytes != local_auxesz)
	    error (_("%s: error reading symbols"),
		   objfile_name (coffread_objfile));
	}
    }
  cs->c_name = getsymname (sym);
  cs->c_value = sym->n_value;
  cs->c_sclass = (sym->n_sclass & 0xff);
  cs->c_secnum = sym->n_scnum;
  cs->c_type = (unsigned) sym->n_type;
  if (!SDB_TYPE (cs->c_type))
    cs->c_type = 0;

#if 0
  if (cs->c_sclass & 128)
    printf (_("thumb symbol %s, class 0x%x\n"), cs->c_name, cs->c_sclass);
#endif

  symnum += 1 + cs->c_naux;

  /* The PE file format stores symbol values as offsets within the
     section, rather than as absolute addresses.  We correct that
     here, if the symbol has an appropriate storage class.  FIXME: We
     should use BFD to read the symbols, rather than duplicating the
     work here.  */
  if (pe_file)
    {
      switch (cs->c_sclass)
	{
	case C_EXT:
	case C_THUMBEXT:
	case C_THUMBEXTFUNC:
	case C_SECTION:
	case C_NT_WEAK:
	case C_STAT:
	case C_THUMBSTAT:
	case C_THUMBSTATFUNC:
	case C_LABEL:
	case C_THUMBLABEL:
	case C_BLOCK:
	case C_FCN:
	case C_EFCN:
	  if (cs->c_secnum != 0)
	    cs->c_value += cs_section_address (cs, symfile_bfd);
	  break;
	}
    }
}

/* Support for string table handling.  */

static char *stringtab = NULL;

static int
init_stringtab (bfd *abfd, long offset)
{
  long length;
  int val;
  unsigned char lengthbuf[4];

  free_stringtab ();

  /* If the file is stripped, the offset might be zero, indicating no
     string table.  Just return with `stringtab' set to null.  */
  if (offset == 0)
    return 0;

  if (bfd_seek (abfd, offset, 0) < 0)
    return -1;

  val = bfd_bread ((char *) lengthbuf, sizeof lengthbuf, abfd);
  length = bfd_h_get_32 (symfile_bfd, lengthbuf);

  /* If no string table is needed, then the file may end immediately
     after the symbols.  Just return with `stringtab' set to null.  */
  if (val != sizeof lengthbuf || length < sizeof lengthbuf)
    return 0;

  stringtab = (char *) xmalloc (length);
  /* This is in target format (probably not very useful, and not
     currently used), not host format.  */
  memcpy (stringtab, lengthbuf, sizeof lengthbuf);
  if (length == sizeof length)	/* Empty table -- just the count.  */
    return 0;

  val = bfd_bread (stringtab + sizeof lengthbuf, 
		   length - sizeof lengthbuf, abfd);
  if (val != length - sizeof lengthbuf || stringtab[length - 1] != '\0')
    return -1;

  return 0;
}

static void
free_stringtab (void)
{
  if (stringtab)
    xfree (stringtab);
  stringtab = NULL;
}

static void
free_stringtab_cleanup (void *ignore)
{
  free_stringtab ();
}

static char *
getsymname (struct internal_syment *symbol_entry)
{
  static char buffer[SYMNMLEN + 1];
  char *result;

  if (symbol_entry->_n._n_n._n_zeroes == 0)
    {
      /* FIXME: Probably should be detecting corrupt symbol files by
         seeing whether offset points to within the stringtab.  */
      result = stringtab + symbol_entry->_n._n_n._n_offset;
    }
  else
    {
      strncpy (buffer, symbol_entry->_n._n_name, SYMNMLEN);
      buffer[SYMNMLEN] = '\0';
      result = buffer;
    }
  return result;
}

/* Extract the file name from the aux entry of a C_FILE symbol.
   Return only the last component of the name.  Result is in static
   storage and is only good for temporary use.  */

static const char *
coff_getfilename (union internal_auxent *aux_entry)
{
  static char buffer[BUFSIZ];
  const char *result;

  if (aux_entry->x_file.x_n.x_zeroes == 0)
    {
      if (strlen (stringtab + aux_entry->x_file.x_n.x_offset) >= BUFSIZ)
	internal_error (__FILE__, __LINE__, _("coff file name too long"));
      strcpy (buffer, stringtab + aux_entry->x_file.x_n.x_offset);
    }
  else
    {
      strncpy (buffer, aux_entry->x_file.x_fname, FILNMLEN);
      buffer[FILNMLEN] = '\0';
    }
  result = buffer;

  /* FIXME: We should not be throwing away the information about what
     directory.  It should go into dirname of the symtab, or some such
     place.  */
  result = lbasename (result);
  return (result);
}

/* Support for line number handling.  */

static char *linetab = NULL;
static long linetab_offset;
static unsigned long linetab_size;

/* Read in all the line numbers for fast lookups later.  Leave them in
   external (unswapped) format in memory; we'll swap them as we enter
   them into GDB's data structures.  */

static int
init_lineno (bfd *abfd, long offset, int size)
{
  int val;

  linetab_offset = offset;
  linetab_size = size;

  free_linetab ();

  if (size == 0)
    return 0;

  if (bfd_seek (abfd, offset, 0) < 0)
    return -1;

  /* Allocate the desired table, plus a sentinel.  */
  linetab = (char *) xmalloc (size + local_linesz);

  val = bfd_bread (linetab, size, abfd);
  if (val != size)
    return -1;

  /* Terminate it with an all-zero sentinel record.  */
  memset (linetab + size, 0, local_linesz);

  return 0;
}

static void
free_linetab (void)
{
  if (linetab)
    xfree (linetab);
  linetab = NULL;
}

static void
free_linetab_cleanup (void *ignore)
{
  free_linetab ();
}

#if !defined (L_LNNO32)
#define L_LNNO32(lp) ((lp)->l_lnno)
#endif

static void
enter_linenos (long file_offset, int first_line,
	       int last_line, struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  char *rawptr;
  struct internal_lineno lptr;

  if (!linetab)
    return;
  if (file_offset < linetab_offset)
    {
      complaint (&symfile_complaints,
		 _("Line number pointer %ld lower than start of line numbers"),
		 file_offset);
      if (file_offset > linetab_size)	/* Too big to be an offset?  */
	return;
      file_offset += linetab_offset;	/* Try reading at that linetab
					   offset.  */
    }

  rawptr = &linetab[file_offset - linetab_offset];

  /* Skip first line entry for each function.  */
  rawptr += local_linesz;
  /* Line numbers start at one for the first line of the function.  */
  first_line--;

  /* If the line number table is full (e.g. 64K lines in COFF debug
     info), the next function's L_LNNO32 might not be zero, so don't
     overstep the table's end in any case.  */
  while (rawptr <= &linetab[0] + linetab_size)
    {
      bfd_coff_swap_lineno_in (symfile_bfd, rawptr, &lptr);
      rawptr += local_linesz;
      /* The next function, or the sentinel, will have L_LNNO32 zero;
	 we exit.  */
      if (L_LNNO32 (&lptr) && L_LNNO32 (&lptr) <= last_line)
	{
	  CORE_ADDR addr = lptr.l_addr.l_paddr;
	  addr += ANOFFSET (objfile->section_offsets,
			    SECT_OFF_TEXT (objfile));
	  record_line (current_subfile,
		       first_line + L_LNNO32 (&lptr),
		       gdbarch_addr_bits_remove (gdbarch, addr));
	}
      else
	break;
    }
}

static void
patch_type (struct type *type, struct type *real_type)
{
  struct type *target = TYPE_TARGET_TYPE (type);
  struct type *real_target = TYPE_TARGET_TYPE (real_type);
  int field_size = TYPE_NFIELDS (real_target) * sizeof (struct field);

  TYPE_LENGTH (target) = TYPE_LENGTH (real_target);
  TYPE_NFIELDS (target) = TYPE_NFIELDS (real_target);
  TYPE_FIELDS (target) = (struct field *) TYPE_ALLOC (target,
						      field_size);

  memcpy (TYPE_FIELDS (target), 
	  TYPE_FIELDS (real_target), 
	  field_size);

  if (TYPE_NAME (real_target))
    {
      /* The previous copy of TYPE_NAME is allocated by
	 process_coff_symbol.  */
      if (TYPE_NAME (target))
	xfree ((char*) TYPE_NAME (target));
      TYPE_NAME (target) = xstrdup (TYPE_NAME (real_target));
    }
}

/* Patch up all appropriate typedef symbols in the opaque_type_chains
   so that they can be used to print out opaque data structures
   properly.  */

static void
patch_opaque_types (struct symtab *s)
{
  struct block *b;
  struct block_iterator iter;
  struct symbol *real_sym;

  /* Go through the per-file symbols only.  */
  b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
  ALL_BLOCK_SYMBOLS (b, iter, real_sym)
    {
      /* Find completed typedefs to use to fix opaque ones.
         Remove syms from the chain when their types are stored,
         but search the whole chain, as there may be several syms
         from different files with the same name.  */
      if (SYMBOL_CLASS (real_sym) == LOC_TYPEDEF
	  && SYMBOL_DOMAIN (real_sym) == VAR_DOMAIN
	  && TYPE_CODE (SYMBOL_TYPE (real_sym)) == TYPE_CODE_PTR
	  && TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (real_sym))) != 0)
	{
	  const char *name = SYMBOL_LINKAGE_NAME (real_sym);
	  int hash = hashname (name);
	  struct symbol *sym, *prev;

	  prev = 0;
	  for (sym = opaque_type_chain[hash]; sym;)
	    {
	      if (name[0] == SYMBOL_LINKAGE_NAME (sym)[0]
		  && strcmp (name + 1, SYMBOL_LINKAGE_NAME (sym) + 1) == 0)
		{
		  if (prev)
		    {
		      SYMBOL_VALUE_CHAIN (prev) = SYMBOL_VALUE_CHAIN (sym);
		    }
		  else
		    {
		      opaque_type_chain[hash] = SYMBOL_VALUE_CHAIN (sym);
		    }

		  patch_type (SYMBOL_TYPE (sym), SYMBOL_TYPE (real_sym));

		  if (prev)
		    {
		      sym = SYMBOL_VALUE_CHAIN (prev);
		    }
		  else
		    {
		      sym = opaque_type_chain[hash];
		    }
		}
	      else
		{
		  prev = sym;
		  sym = SYMBOL_VALUE_CHAIN (sym);
		}
	    }
	}
    }
}

static int
coff_reg_to_regnum (struct symbol *sym, struct gdbarch *gdbarch)
{
  return gdbarch_sdb_reg_to_regnum (gdbarch, SYMBOL_VALUE (sym));
}

static const struct symbol_register_ops coff_register_funcs = {
  coff_reg_to_regnum
};

/* The "aclass" index for computed COFF symbols.  */

static int coff_register_index;

static struct symbol *
process_coff_symbol (struct coff_symbol *cs,
		     union internal_auxent *aux,
		     struct objfile *objfile)
{
  struct symbol *sym = allocate_symbol (objfile);
  char *name;

  name = cs->c_name;
  name = EXTERNAL_NAME (name, objfile->obfd);
  SYMBOL_SET_LANGUAGE (sym, current_subfile->language,
		       &objfile->objfile_obstack);
  SYMBOL_SET_NAMES (sym, name, strlen (name), 1, objfile);

  /* default assumptions */
  SYMBOL_VALUE (sym) = cs->c_value;
  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
  SYMBOL_SECTION (sym) = cs_to_section (cs, objfile);

  if (ISFCN (cs->c_type))
    {
      SYMBOL_VALUE (sym) += ANOFFSET (objfile->section_offsets,
				      SECT_OFF_TEXT (objfile));
      SYMBOL_TYPE (sym) =
	lookup_function_type (decode_function_type (cs, cs->c_type,
						    aux, objfile));

      SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;
      if (cs->c_sclass == C_STAT || cs->c_sclass == C_THUMBSTAT
	  || cs->c_sclass == C_THUMBSTATFUNC)
	add_symbol_to_list (sym, &file_symbols);
      else if (cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXT
	       || cs->c_sclass == C_THUMBEXTFUNC)
	add_symbol_to_list (sym, &global_symbols);
    }
  else
    {
      SYMBOL_TYPE (sym) = decode_type (cs, cs->c_type, aux, objfile);
      switch (cs->c_sclass)
	{
	case C_NULL:
	  break;

	case C_AUTO:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_LOCAL;
	  add_symbol_to_list (sym, &local_symbols);
	  break;

	case C_THUMBEXT:
	case C_THUMBEXTFUNC:
	case C_EXT:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;
	  SYMBOL_VALUE_ADDRESS (sym) = (CORE_ADDR) cs->c_value;
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets,
						  SECT_OFF_TEXT (objfile));
	  add_symbol_to_list (sym, &global_symbols);
	  break;

	case C_THUMBSTAT:
	case C_THUMBSTATFUNC:
	case C_STAT:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;
	  SYMBOL_VALUE_ADDRESS (sym) = (CORE_ADDR) cs->c_value;
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets,
						  SECT_OFF_TEXT (objfile));
	  if (within_function)
	    {
	      /* Static symbol of local scope.  */
	      add_symbol_to_list (sym, &local_symbols);
	    }
	  else
	    {
	      /* Static symbol at top level of file.  */
	      add_symbol_to_list (sym, &file_symbols);
	    }
	  break;

#ifdef C_GLBLREG		/* AMD coff */
	case C_GLBLREG:
#endif
	case C_REG:
	  SYMBOL_ACLASS_INDEX (sym) = coff_register_index;
	  SYMBOL_VALUE (sym) = cs->c_value;
	  add_symbol_to_list (sym, &local_symbols);
	  break;

	case C_THUMBLABEL:
	case C_LABEL:
	  break;

	case C_ARG:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_ARG;
	  SYMBOL_IS_ARGUMENT (sym) = 1;
	  add_symbol_to_list (sym, &local_symbols);
	  break;

	case C_REGPARM:
	  SYMBOL_ACLASS_INDEX (sym) = coff_register_index;
	  SYMBOL_IS_ARGUMENT (sym) = 1;
	  SYMBOL_VALUE (sym) = cs->c_value;
	  add_symbol_to_list (sym, &local_symbols);
	  break;

	case C_TPDEF:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;

	  /* If type has no name, give it one.  */
	  if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
	    {
	      if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR
		  || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FUNC)
		{
		  /* If we are giving a name to a type such as
		     "pointer to foo" or "function returning foo", we
		     better not set the TYPE_NAME.  If the program
		     contains "typedef char *caddr_t;", we don't want 
		     all variables of type char * to print as caddr_t.
		     This is not just a consequence of GDB's type
		     management; CC and GCC (at least through version
		     2.4) both output variables of either type char *
		     or caddr_t with the type refering to the C_TPDEF
		     symbol for caddr_t.  If a future compiler cleans
		     this up it GDB is not ready for it yet, but if it
		     becomes ready we somehow need to disable this
		     check (without breaking the PCC/GCC2.4 case).

		     Sigh.

		     Fortunately, this check seems not to be necessary
		     for anything except pointers or functions.  */
		  ;
		}
	      else
		TYPE_NAME (SYMBOL_TYPE (sym)) =
		  xstrdup (SYMBOL_LINKAGE_NAME (sym));
	    }

	  /* Keep track of any type which points to empty structured
	     type, so it can be filled from a definition from another
	     file.  A simple forward reference (TYPE_CODE_UNDEF) is
	     not an empty structured type, though; the forward
	     references work themselves out via the magic of
	     coff_lookup_type.  */
	  if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR
	      && TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))) == 0
	      && TYPE_CODE (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym)))
	         != TYPE_CODE_UNDEF)
	    {
	      int i = hashname (SYMBOL_LINKAGE_NAME (sym));

	      SYMBOL_VALUE_CHAIN (sym) = opaque_type_chain[i];
	      opaque_type_chain[i] = sym;
	    }
	  add_symbol_to_list (sym, &file_symbols);
	  break;

	case C_STRTAG:
	case C_UNTAG:
	case C_ENTAG:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;

	  /* Some compilers try to be helpful by inventing "fake"
	     names for anonymous enums, structures, and unions, like
	     "~0fake" or ".0fake".  Thanks, but no thanks...  */
	  if (TYPE_TAG_NAME (SYMBOL_TYPE (sym)) == 0)
	    if (SYMBOL_LINKAGE_NAME (sym) != NULL
		&& *SYMBOL_LINKAGE_NAME (sym) != '~'
		&& *SYMBOL_LINKAGE_NAME (sym) != '.')
	      TYPE_TAG_NAME (SYMBOL_TYPE (sym)) =
		concat (SYMBOL_LINKAGE_NAME (sym), (char *)NULL);

	  add_symbol_to_list (sym, &file_symbols);
	  break;

	default:
	  break;
	}
    }
  return sym;
}

/* Decode a coff type specifier;  return the type that is meant.  */

static struct type *
decode_type (struct coff_symbol *cs, unsigned int c_type,
	     union internal_auxent *aux, struct objfile *objfile)
{
  struct type *type = 0;
  unsigned int new_c_type;

  if (c_type & ~N_BTMASK)
    {
      new_c_type = DECREF (c_type);
      if (ISPTR (c_type))
	{
	  type = decode_type (cs, new_c_type, aux, objfile);
	  type = lookup_pointer_type (type);
	}
      else if (ISFCN (c_type))
	{
	  type = decode_type (cs, new_c_type, aux, objfile);
	  type = lookup_function_type (type);
	}
      else if (ISARY (c_type))
	{
	  int i, n;
	  unsigned short *dim;
	  struct type *base_type, *index_type, *range_type;

	  /* Define an array type.  */
	  /* auxent refers to array, not base type.  */
	  if (aux->x_sym.x_tagndx.l == 0)
	    cs->c_naux = 0;

	  /* Shift the indices down.  */
	  dim = &aux->x_sym.x_fcnary.x_ary.x_dimen[0];
	  i = 1;
	  n = dim[0];
	  for (i = 0; *dim && i < DIMNUM - 1; i++, dim++)
	    *dim = *(dim + 1);
	  *dim = 0;

	  base_type = decode_type (cs, new_c_type, aux, objfile);
	  index_type = objfile_type (objfile)->builtin_int;
	  range_type =
	    create_range_type ((struct type *) NULL, 
			       index_type, 0, n - 1);
	  type =
	    create_array_type ((struct type *) NULL, 
			       base_type, range_type);
	}
      return type;
    }

  /* Reference to existing type.  This only occurs with the struct,
     union, and enum types.  EPI a29k coff fakes us out by producing
     aux entries with a nonzero x_tagndx for definitions of structs,
     unions, and enums, so we have to check the c_sclass field.  SCO
     3.2v4 cc gets confused with pointers to pointers to defined
     structs, and generates negative x_tagndx fields.  */
  if (cs->c_naux > 0 && aux->x_sym.x_tagndx.l != 0)
    {
      if (cs->c_sclass != C_STRTAG
	  && cs->c_sclass != C_UNTAG
	  && cs->c_sclass != C_ENTAG
	  && aux->x_sym.x_tagndx.l >= 0)
	{
	  type = coff_alloc_type (aux->x_sym.x_tagndx.l);
	  return type;
	}
      else
	{
	  complaint (&symfile_complaints,
		     _("Symbol table entry for %s has bad tagndx value"),
		     cs->c_name);
	  /* And fall through to decode_base_type...  */
	}
    }

  return decode_base_type (cs, BTYPE (c_type), aux, objfile);
}

/* Decode a coff type specifier for function definition;
   return the type that the function returns.  */

static struct type *
decode_function_type (struct coff_symbol *cs, 
		      unsigned int c_type,
		      union internal_auxent *aux, 
		      struct objfile *objfile)
{
  if (aux->x_sym.x_tagndx.l == 0)
    cs->c_naux = 0;	/* auxent refers to function, not base
			   type.  */

  return decode_type (cs, DECREF (c_type), aux, objfile);
}

/* Basic C types.  */

static struct type *
decode_base_type (struct coff_symbol *cs, 
		  unsigned int c_type,
		  union internal_auxent *aux, 
		  struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct type *type;

  switch (c_type)
    {
    case T_NULL:
      /* Shows up with "void (*foo)();" structure members.  */
      return objfile_type (objfile)->builtin_void;

#ifdef T_VOID
    case T_VOID:
      /* Intel 960 COFF has this symbol and meaning.  */
      return objfile_type (objfile)->builtin_void;
#endif

    case T_CHAR:
      return objfile_type (objfile)->builtin_char;

    case T_SHORT:
      return objfile_type (objfile)->builtin_short;

    case T_INT:
      return objfile_type (objfile)->builtin_int;

    case T_LONG:
      if (cs->c_sclass == C_FIELD
	  && aux->x_sym.x_misc.x_lnsz.x_size
	     > gdbarch_long_bit (gdbarch))
	return objfile_type (objfile)->builtin_long_long;
      else
	return objfile_type (objfile)->builtin_long;

    case T_FLOAT:
      return objfile_type (objfile)->builtin_float;

    case T_DOUBLE:
      return objfile_type (objfile)->builtin_double;

    case T_LNGDBL:
      return objfile_type (objfile)->builtin_long_double;

    case T_STRUCT:
      if (cs->c_naux != 1)
	{
	  /* Anonymous structure type.  */
	  type = coff_alloc_type (cs->c_symnum);
	  TYPE_CODE (type) = TYPE_CODE_STRUCT;
	  TYPE_NAME (type) = NULL;
	  /* This used to set the tag to "<opaque>".  But I think
	     setting it to NULL is right, and the printing code can
	     print it as "struct {...}".  */
	  TYPE_TAG_NAME (type) = NULL;
	  INIT_CPLUS_SPECIFIC (type);
	  TYPE_LENGTH (type) = 0;
	  TYPE_FIELDS (type) = 0;
	  TYPE_NFIELDS (type) = 0;
	}
      else
	{
	  type = coff_read_struct_type (cs->c_symnum,
					aux->x_sym.x_misc.x_lnsz.x_size,
					aux->x_sym.x_fcnary.x_fcn.x_endndx.l,
					objfile);
	}
      return type;

    case T_UNION:
      if (cs->c_naux != 1)
	{
	  /* Anonymous union type.  */
	  type = coff_alloc_type (cs->c_symnum);
	  TYPE_NAME (type) = NULL;
	  /* This used to set the tag to "<opaque>".  But I think
	     setting it to NULL is right, and the printing code can
	     print it as "union {...}".  */
	  TYPE_TAG_NAME (type) = NULL;
	  INIT_CPLUS_SPECIFIC (type);
	  TYPE_LENGTH (type) = 0;
	  TYPE_FIELDS (type) = 0;
	  TYPE_NFIELDS (type) = 0;
	}
      else
	{
	  type = coff_read_struct_type (cs->c_symnum,
					aux->x_sym.x_misc.x_lnsz.x_size,
					aux->x_sym.x_fcnary.x_fcn.x_endndx.l,
					objfile);
	}
      TYPE_CODE (type) = TYPE_CODE_UNION;
      return type;

    case T_ENUM:
      if (cs->c_naux != 1)
	{
	  /* Anonymous enum type.  */
	  type = coff_alloc_type (cs->c_symnum);
	  TYPE_CODE (type) = TYPE_CODE_ENUM;
	  TYPE_NAME (type) = NULL;
	  /* This used to set the tag to "<opaque>".  But I think
	     setting it to NULL is right, and the printing code can
	     print it as "enum {...}".  */
	  TYPE_TAG_NAME (type) = NULL;
	  TYPE_LENGTH (type) = 0;
	  TYPE_FIELDS (type) = 0;
	  TYPE_NFIELDS (type) = 0;
	}
      else
	{
	  type = coff_read_enum_type (cs->c_symnum,
				      aux->x_sym.x_misc.x_lnsz.x_size,
				      aux->x_sym.x_fcnary.x_fcn.x_endndx.l,
				      objfile);
	}
      return type;

    case T_MOE:
      /* Shouldn't show up here.  */
      break;

    case T_UCHAR:
      return objfile_type (objfile)->builtin_unsigned_char;

    case T_USHORT:
      return objfile_type (objfile)->builtin_unsigned_short;

    case T_UINT:
      return objfile_type (objfile)->builtin_unsigned_int;

    case T_ULONG:
      if (cs->c_sclass == C_FIELD
	  && aux->x_sym.x_misc.x_lnsz.x_size
	     > gdbarch_long_bit (gdbarch))
	return objfile_type (objfile)->builtin_unsigned_long_long;
      else
	return objfile_type (objfile)->builtin_unsigned_long;
    }
  complaint (&symfile_complaints, 
	     _("Unexpected type for symbol %s"), cs->c_name);
  return objfile_type (objfile)->builtin_void;
}

/* This page contains subroutines of read_type.  */

/* Read the description of a structure (or union type) and return an
   object describing the type.  */

static struct type *
coff_read_struct_type (int index, int length, int lastsym,
		       struct objfile *objfile)
{
  struct nextfield
    {
      struct nextfield *next;
      struct field field;
    };

  struct type *type;
  struct nextfield *list = 0;
  struct nextfield *new;
  int nfields = 0;
  int n;
  char *name;
  struct coff_symbol member_sym;
  struct coff_symbol *ms = &member_sym;
  struct internal_syment sub_sym;
  union internal_auxent sub_aux;
  int done = 0;

  type = coff_alloc_type (index);
  TYPE_CODE (type) = TYPE_CODE_STRUCT;
  INIT_CPLUS_SPECIFIC (type);
  TYPE_LENGTH (type) = length;

  while (!done && symnum < lastsym && symnum < nlist_nsyms_global)
    {
      read_one_sym (ms, &sub_sym, &sub_aux);
      name = ms->c_name;
      name = EXTERNAL_NAME (name, objfile->obfd);

      switch (ms->c_sclass)
	{
	case C_MOS:
	case C_MOU:

	  /* Get space to record the next field's data.  */
	  new = (struct nextfield *) alloca (sizeof (struct nextfield));
	  new->next = list;
	  list = new;

	  /* Save the data.  */
	  list->field.name = obstack_copy0 (&objfile->objfile_obstack,
					    name, strlen (name));
	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type,
						  &sub_aux, objfile);
	  SET_FIELD_BITPOS (list->field, 8 * ms->c_value);
	  FIELD_BITSIZE (list->field) = 0;
	  nfields++;
	  break;

	case C_FIELD:

	  /* Get space to record the next field's data.  */
	  new = (struct nextfield *) alloca (sizeof (struct nextfield));
	  new->next = list;
	  list = new;

	  /* Save the data.  */
	  list->field.name = obstack_copy0 (&objfile->objfile_obstack,
					    name, strlen (name));
	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type,
						  &sub_aux, objfile);
	  SET_FIELD_BITPOS (list->field, ms->c_value);
	  FIELD_BITSIZE (list->field) = sub_aux.x_sym.x_misc.x_lnsz.x_size;
	  nfields++;
	  break;

	case C_EOS:
	  done = 1;
	  break;
	}
    }
  /* Now create the vector of fields, and record how big it is.  */

  TYPE_NFIELDS (type) = nfields;
  TYPE_FIELDS (type) = (struct field *)
    TYPE_ALLOC (type, sizeof (struct field) * nfields);

  /* Copy the saved-up fields into the field vector.  */

  for (n = nfields; list; list = list->next)
    TYPE_FIELD (type, --n) = list->field;

  return type;
}

/* Read a definition of an enumeration type,
   and create and return a suitable type object.
   Also defines the symbols that represent the values of the type.  */

static struct type *
coff_read_enum_type (int index, int length, int lastsym,
		     struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct symbol *sym;
  struct type *type;
  int nsyms = 0;
  int done = 0;
  struct pending **symlist;
  struct coff_symbol member_sym;
  struct coff_symbol *ms = &member_sym;
  struct internal_syment sub_sym;
  union internal_auxent sub_aux;
  struct pending *osyms, *syms;
  int o_nsyms;
  int n;
  char *name;
  int unsigned_enum = 1;

  type = coff_alloc_type (index);
  if (within_function)
    symlist = &local_symbols;
  else
    symlist = &file_symbols;
  osyms = *symlist;
  o_nsyms = osyms ? osyms->nsyms : 0;

  while (!done && symnum < lastsym && symnum < nlist_nsyms_global)
    {
      read_one_sym (ms, &sub_sym, &sub_aux);
      name = ms->c_name;
      name = EXTERNAL_NAME (name, objfile->obfd);

      switch (ms->c_sclass)
	{
	case C_MOE:
	  sym = allocate_symbol (objfile);

	  SYMBOL_SET_LINKAGE_NAME (sym,
				   obstack_copy0 (&objfile->objfile_obstack,
						  name, strlen (name)));
	  SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
	  SYMBOL_VALUE (sym) = ms->c_value;
	  add_symbol_to_list (sym, symlist);
	  nsyms++;
	  break;

	case C_EOS:
	  /* Sometimes the linker (on 386/ix 2.0.2 at least) screws
	     up the count of how many symbols to read.  So stop
	     on .eos.  */
	  done = 1;
	  break;
	}
    }

  /* Now fill in the fields of the type-structure.  */

  if (length > 0)
    TYPE_LENGTH (type) = length;
  else /* Assume ints.  */
    TYPE_LENGTH (type) = gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT;
  TYPE_CODE (type) = TYPE_CODE_ENUM;
  TYPE_NFIELDS (type) = nsyms;
  TYPE_FIELDS (type) = (struct field *)
    TYPE_ALLOC (type, sizeof (struct field) * nsyms);

  /* Find the symbols for the values and put them into the type.
     The symbols can be found in the symlist that we put them on
     to cause them to be defined.  osyms contains the old value
     of that symlist; everything up to there was defined by us.  */
  /* Note that we preserve the order of the enum constants, so
     that in something like "enum {FOO, LAST_THING=FOO}" we print
     FOO, not LAST_THING.  */

  for (syms = *symlist, n = 0; syms; syms = syms->next)
    {
      int j = 0;

      if (syms == osyms)
	j = o_nsyms;
      for (; j < syms->nsyms; j++, n++)
	{
	  struct symbol *xsym = syms->symbol[j];

	  SYMBOL_TYPE (xsym) = type;
	  TYPE_FIELD_NAME (type, n) = SYMBOL_LINKAGE_NAME (xsym);
	  SET_FIELD_ENUMVAL (TYPE_FIELD (type, n), SYMBOL_VALUE (xsym));
	  if (SYMBOL_VALUE (xsym) < 0)
	    unsigned_enum = 0;
	  TYPE_FIELD_BITSIZE (type, n) = 0;
	}
      if (syms == osyms)
	break;
    }

  if (unsigned_enum)
    TYPE_UNSIGNED (type) = 1;

  return type;
}

/* Register our ability to parse symbols for coff BFD files.  */

static const struct sym_fns coff_sym_fns =
{
  coff_new_init,		/* sym_new_init: init anything gbl to
				   entire symtab */
  coff_symfile_init,		/* sym_init: read initial info, setup
				   for sym_read() */
  coff_symfile_read,		/* sym_read: read a symbol file into
				   symtab */
  NULL,				/* sym_read_psymbols */
  coff_symfile_finish,		/* sym_finish: finished with file,
				   cleanup */
  default_symfile_offsets,	/* sym_offsets: xlate external to
				   internal form */
  default_symfile_segments,	/* sym_segments: Get segment
				   information from a file */
  NULL,                         /* sym_read_linetable  */

  default_symfile_relocate,	/* sym_relocate: Relocate a debug
				   section.  */
  NULL,				/* sym_probe_fns */
  &psym_functions
};

/* Free the per-objfile COFF data.  */

static void
coff_free_info (struct objfile *objfile, void *arg)
{
  xfree (arg);
}

void
_initialize_coffread (void)
{
  add_symtab_fns (bfd_target_coff_flavour, &coff_sym_fns);

  coff_objfile_data_key = register_objfile_data_with_cleanup (NULL,
							      coff_free_info);

  coff_register_index
    = register_symbol_register_impl (LOC_REGISTER, &coff_register_funcs);
}
@


1.149
log
@Keep objfile original filename

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Pass down original filename for objfile.
	* coffread.c (coff_symfile_read): Update symbol_file_add_separate call.
	* elfread.c (elf_symfile_read): Likewise.
	* jit.c (jit_object_close_impl): Update allocate_objfile call, no
	longer set ORIGINAL_NAME.
	(jit_bfd_try_read_symtab): Update symbol_file_add_from_bfd call.
	* jv-lang.c (get_dynamics_objfile): Update allocate_objfile call.
	* machoread.c (macho_add_oso_symfile): Add parameter name.  Update
	symbol_file_add_from_bfd call.
	(macho_symfile_read_all_oso): Update two macho_add_oso_symfile calls.
	(macho_check_dsym): Add parameter filenamep.  Change function comment.
	Set *filenamep.
	(macho_symfile_read): New variable dsym_filename.  Update
	macho_check_dsym call.  Use it for symbol_file_add_separate.
	* objfiles.c (allocate_objfile): Add parameter name.  New comment for
	it.  Use it for objfile->original_name.
	(objfile_name): Return OBFD's filename, if available.
	* objfiles.h (allocate_objfile): Add new parameter name.
	* solib.c (solib_read_symbols): Update symbol_file_add_from_bfd call.
	* symfile-mem.c (symbol_file_add_from_memory): Update
	symbol_file_add_from_bfd call.
	* symfile.c (read_symbols): Update symbol_file_add_separate call, new
	comment for it.
	(symbol_file_add_with_addrs): New parameter name, add function comment
	for it.  Remove variable name.  Update allocate_objfile call.
	(symbol_file_add_separate): New parameter name, add function comment
	for it.  Update symbol_file_add_with_addrs call.
	(symbol_file_add_from_bfd): New parameter name.  Update
	symbol_file_add_with_addrs call.
	(symbol_file_add): Update symbol_file_add_from_bfd call.
	(reread_symbols): New variable original_name.  Save
	objfile->original_name by it.
	* symfile.h (symbol_file_add_from_bfd, symbol_file_add_separate): Add
	second parameter.
@
text
@a2252 1
  bfd_target_coff_flavour,
d2285 1
a2285 1
  add_symtab_fns (&coff_sym_fns);
@


1.148
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d741 1
a741 1
	  symbol_file_add_separate (abfd, symfile_flags, objfile);
@


1.147
log
@	* buildsym.c (subfile_stack): Move here from buildsym.h.
	(pending_macros): Ditto.
	(get_macro_table): New function.
	(buildsym_init): Initialize subfile_stack.
	* coffread.c (type_vector,type_vector_length): Moved here from
	buildsym.h.
	(INITIAL_TYPE_VECTOR_LENGTH): Ditto.
	(coff_symtab_read): Use it.
	* dbxread.c (read_ofile_symtab): Delete init of subfile_stack.
	* dwarf2read.c (macro_start_file): Replace uses of pending_macros
	with call to get_macro_table.
	* stabsread.c (type_vector,type_vector_length): Moved here from
	buildsym.h.
	(INITIAL_TYPE_VECTOR_LENGTH): Ditto.
	* buildsym.h (get_macro_table): Declare.
@
text
@d822 1
a822 1
    perror_with_name (objfile->name);
d1232 1
a1232 1
    error (_("%s: error reading symbols"), coffread_objfile->name);
d1239 1
a1239 1
	error (_("%s: error reading symbols"), coffread_objfile->name);
d1249 2
a1250 1
	    error (_("%s: error reading symbols"), coffread_objfile->name);
@


1.146
log
@gdb/
	* coffread.c (coff_symfile_read): Iterate over minimal symbols,
	if the name is prefixed by "__imp_" or "_imp_", look for minimal
	symbol without prefix.  If found, set its type to
	'mst_solib_trampoline'.
@
text
@d149 13
d832 1
a832 1
  type_vector_length = 160;
@


1.145
log
@	* coffread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* elfread.c (record_minimal_symbol): Update.
	* machoread.c (macho_symtab_add_minsym): Update.
	* mdebugread.c (record_minimal_symbol, parse_partial_symbols):
	Update.
	* minsyms.c (prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_full): Remove 'bfd_section'
	argument.
	(prim_record_minimal_symbol_and_info): Likewise.
	* minsyms.h (prim_record_minimal_symbol_full)
	(prim_record_minimal_symbol_and_info): Update.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Initialize SYMBOL_SECTION.
	* xcoffread.c (record_minimal_symbol, scan_xcoff_symtab):
	Update.
@
text
@d653 29
@


1.144
log
@	* coffread.c (cs_to_section): Use gdb_bfd_section_index.
	* elfread.c (record_minimal_symbol, elf_symtab_read): Use
	gdb_bfd_section_index.
	* gdb_bfd.c (gdb_bfd_section_index, gdb_bfd_count_sections):
	New functions.
	* gdb_bfd.h (gdb_bfd_section_index, gdb_bfd_count_sections):
	Declare.
	* machoread.c (macho_symtab_add_minsym, macho_symfile_offsets):
	Update.
	* objfiles.c (add_to_objfile_sections_full): New function.
	(add_to_objfile_sections): Use it.
	(build_section_table): Rewrite.
	(objfile_relocate1): Use gdb_bfd_section_index.  Update.
	* objfiles.h (obj_section_offset): Use gdb_bfd_section_index.
	(struct objfile) <sections>: Update comment.
	(ALL_OBJFILE_OSECTIONS): Skip sections where the_bfd_section
	is NULL.
	(ALL_OBJSECTIONS): Use it.
	* solib-dsbt.c (dsbt_relocate_main_executable): Update.
	* solib-frv.c (frv_relocate_main_executable): Update.
	* solib-target.c (solib_target_relocate_section_addresses):
	Use gdb_bfd_section_index.
	* symfile.c (build_section_addr_info_from_section_table):
	Use gdb_bfd_section_index.
	(build_section_addr_info_from_bfd, place_section): Likewise.
	* symtab.c (fixup_section): Update.
	* xcoffread.c (find_targ_sec): Use gdb_bfd_section_index.
@
text
@a458 2
  struct bfd_section *bfd_section;

a472 1
  bfd_section = cs_to_bfd_section (cs, objfile);
d474 1
a474 2
					      type, section,
					      bfd_section, objfile);
@


1.143
log
@	* ada-lang.c (ada_decode_symbol): Check and set 'ada_mangled'.
	Use symbol's obstack, not an objfile.
	* coffread.c (process_coff_symbol): Update.
	* dwarf2read.c (fixup_go_packaging, new_symbol_full): Update.
	* jv-lang.c (add_class_symbol): Update.
	* mdebugread.c (new_symbol): Update.
	* minsyms.c (prim_record_minimal_symbol_full)
	(terminate_minimal_symbol_table): Update.
	* psymtab.c (add_psymbol_to_bcache): Clear entire symbol.  Update.
	* stabsread.c (define_symbol, read_enum_type): Update.
	* symtab.c (symbol_set_demangled_name, symbol_get_demangled_name):
	Handle Ada specially.
	(symbol_set_language): Add 'obstack' argument.
	(symbol_set_names): Update.
	(symbol_natural_name, symbol_demangled_name): Always use
	ada_decode_symbol.
	* symtab.h (struct general_symbol_info)
	<language_specific::obstack>: New field.
	<ada_mangled>: New field.
	(SYMBOL_SET_LANGUAGE): Add 'obstack' argument.
	(symbol_set_language): Update.
@
text
@d300 1
a300 1
  return sect->index;
@


1.142
log
@	* coffread.c (process_coff_symbol, coff_read_enum_type): Call
	allocate_symbol.
	* dwarf2read.c (fixup_go_packaging): Call allocate_symbol.
	(read_func_scope): Call allocate_template_symbol.
	(new_symbol_full): Call allocate_symbol.
	* jit.c (finalize_symtab): Call allocate_symbol.
	* jv-lang.c (add_class_symbol): Call allocate_symbol.
	* mdebugread.c (parse_symbol, new_block): Call allocate_symbol.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_end): Call allocate_symbol.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): New functions.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Declare.
	* xcoffread.c (process_xcoff_symbol): Call initialize_symbol.
@
text
@d1589 2
a1590 1
  SYMBOL_SET_LANGUAGE (sym, current_subfile->language);
@


1.141
log
@Ignore __fu<digits>__ symbols from COFF symbol tables

The debugger sometimes prints strange function names for given
addresses. For instance, with the following source code...

	4    procedure Foo is
	5       A : Integer;
	6    begin
	7       Do_Nothing (A'Address);
	8    end Foo;

... we can see...

    (gdb) info line 5
    Line 5 of "foo.adb" starts at address 0x4017ca <_ada_foo+6>
       and ends at 0x4017d2 <_fu29__system__scalar_values__is_is4+7>.
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

_fu29__system__scalar_values__is_is4 is an artificial symbol
generated by the linker, and interferes with the pc-to-symbol
resolution.  There isn't much in the general minimal_symbol
data that could help us identify them, so this patch changes
the COFF reader to simply ignore them.

gdb/ChangeLog:

	* coffread.c (is_import_fixup_symbol): New function.
	(record_minimal_symbol): Use is_import_fixup_symbol to
	detect import fixup symbols, and discard them.

gdb/testsuite/ChangeLog:

        * gdb.ada/win_fu_syms: New testcase.
@
text
@d1584 1
a1584 3
  struct symbol *sym
    = (struct symbol *) obstack_alloc (&objfile->objfile_obstack,
				       sizeof (struct symbol));
a1586 1
  memset (sym, 0, sizeof (struct symbol));
d2142 1
a2142 3
	  sym = (struct symbol *) obstack_alloc
	    (&objfile->objfile_obstack, sizeof (struct symbol));
	  memset (sym, 0, sizeof (struct symbol));
@


1.140
log
@2013-03-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	PR symtab/8421:
	* coffread.c (coff_register_index): New global.
	(process_coff_symbol, coff_read_enum_type): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_coffread): Initialize new global.
	* dwarf2loc.c (locexpr_find_frame_base_location)
	(dwarf2_block_frame_base_locexpr_funcs)
	(loclist_find_frame_base_location)
	(dwarf2_block_frame_base_loclist_funcs): New.
	(dwarf_expr_frame_base_1): Call SYMBOL_BLOCK_OPS, remove internal_error.
	(dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Add location_has_loclist.
	* dwarf2loc.h (dwarf2_block_frame_base_locexpr_funcs)
	(dwarf2_block_frame_base_loclist_funcs): New.
	* dwarf2read.c (dwarf2_locexpr_index, dwarf2_loclist_index)
	(dwarf2_locexpr_block_index, dwarf2_loclist_block_index): New
	globals.
	(read_func_scope): Update.
	(fixup_go_packaging, mark_common_block_symbol_computed)
	(var_decode_location, new_symbol_full, dwarf2_const_value):
	Set SYMBOL_ACLASS_INDEX.
	(dwarf2_symbol_mark_computed): Likewise.  Add 'is_block' argument.
	(_initialize_dwarf2_read): Initialize new globals.
	* jit.c (finalize_symtab): Set SYMBOL_ACLASS_INDEX.
	* jv-lang.c (add_class_symbol): Set SYMBOL_ACLASS_INDEX.
	* mdebugread.c (mdebug_register_index, mdebug_regparm_index): New
	globals.
	(parse_symbol, psymtab_to_symtab_1): Set SYMBOL_ACLASS_INDEX.
	(_initialize_mdebugread): Initialize new globals.
	* psympriv.h (struct partial_symbol) <aclass>: Update comment.
	* stabsread.c (patch_block_stabs): Set SYMBOL_ACLASS_INDEX.
	(stab_register_index, stab_regparm_index): New globals.
	(define_symbol, read_enum_type, common_block_end): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_stabsread): Initialize new globals.
	* symtab.c (next_aclass_value, symbol_impl, symbol_impls): New
	globals.
	(MAX_SYMBOL_IMPLS): New define.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl)
	(initialize_ordinary_address_classes): New functions.
	(_initialize_symtab): Call initialize_ordinary_address_classes.
	* symtab.h (enum address_class) <LOC_FINAL_VALUE>: New constant.
	(struct symbol_impl): New.
	(SYMBOL_ACLASS_BITS): New define.
	(struct symbol) <aclass, ops>: Remove fields.
	<aclass_index>: New field.
	(symbol_impls): Declare.
	(SYMBOL_CLASS, SYMBOL_COMPUTED_OPS, SYMBOL_REGISTER_OPS): Redefine.
	(SYMBOL_IMPL, SYMBOL_ACLASS_INDEX): New defines.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl): Declare.
	(struct symbol_computed_ops): Add location_has_loclist.
	(struct symbol_block_ops): New.
	(SYMBOL_BLOCK_OPS): New.
	* xcoffread.c (process_xcoff_symbol): Set SYMBOL_ACLASS_INDEX.
@
text
@d421 33
d465 10
@


1.139
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d1532 4
d1565 1
a1565 1
      SYMBOL_CLASS (sym) = LOC_BLOCK;
d1582 1
a1582 1
	  SYMBOL_CLASS (sym) = LOC_LOCAL;
d1589 1
a1589 1
	  SYMBOL_CLASS (sym) = LOC_STATIC;
d1599 1
a1599 1
	  SYMBOL_CLASS (sym) = LOC_STATIC;
d1619 1
a1619 2
	  SYMBOL_CLASS (sym) = LOC_REGISTER;
	  SYMBOL_REGISTER_OPS (sym) = &coff_register_funcs;
d1629 1
a1629 1
	  SYMBOL_CLASS (sym) = LOC_ARG;
d1635 1
a1635 2
	  SYMBOL_CLASS (sym) = LOC_REGISTER;
	  SYMBOL_REGISTER_OPS (sym) = &coff_register_funcs;
d1642 1
a1642 1
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
d1698 1
a1698 1
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
d2109 1
a2109 1
	  SYMBOL_CLASS (sym) = LOC_CONST;
d2212 3
@


1.138
log
@	* buildsym.c (patch_subfile_names): Use set_last_source_file.
	(start_symtab): Make 'name' and 'dirname' const.  Use
	set_last_source_file.
	(restart_symtab, reset_symtab_globals): Use set_last_source_file.
	(last_source_file): Define.  Now static.
	(set_last_source_file, get_last_source_file): New functions.
	* buildsym.h (last_source_file): Don't declare.
	(start_symtab): Update.
	(set_last_source_file, get_last_source_file): Declare.
	* coffread.c (complete_symtab): Use set_last_source_file.
	(coff_end_symtab): Likewise.
	(coff_symtab_read): Use set_last_source_file, get_last_source_file.
	* dbxread.c (read_dbx_symtab, read_ofile_symtab): Use
	set_last_source_file.
	(process_one_symbol): Use get_last_source_file.
	* mdebugread.c (parse_partial_symbols): Use set_last_source_file.
	(psymtab_to_symtab_1): Use get_last_source_file.
	* xcoffread.c (process_linenos): Use get_last_source_file.
	(complete_symtab): Use set_last_source_file.
	(read_xcoff_symtab): Use set_last_source_file, get_last_source_file.
	(scan_xcoff_symtab): Use set_last_source_file.
@
text
@d2014 2
a2015 2
	  list->field.name = obsavestring (name, strlen (name), 
					   &objfile->objfile_obstack);
d2031 2
a2032 2
	  list->field.name = obsavestring (name, strlen (name), 
					   &objfile->objfile_obstack);
d2105 2
a2106 2
				   obsavestring (name, strlen (name),
						 &objfile->objfile_obstack));
@


1.137
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d399 1
a399 3
  if (last_source_file != NULL)
    xfree (last_source_file);
  last_source_file = xstrdup (name);
d418 1
a418 1
  last_source_file = NULL;
d746 1
a746 1
  last_source_file = NULL;
d767 1
a767 1
	  if (last_source_file)
d783 1
a783 1
      if (!last_source_file && SDB_TYPE (cs->c_type)
d832 1
a832 1
	  if (last_source_file)
d1122 1
a1122 1
  if (last_source_file)
@


1.136
log
@Fix NULL objfile's section_offsets dereference during symbol load.

gdb/ChangeLog:

        * symfile.c (syms_from_objfile_1): Renames syms_from_objfile.
        Remove call to init_entry_point_info.  Add OBJFILE's
        section_offsets and num_sections initialization.  Add note
        about entry info in the function documentation.
        (syms_from_objfile): New function.
        * coffread.c (coff_symfile_init): Remove call to
        init_entry_point_info.
        * machoread.c (macho_symfile_init): Likewise.
        * xcoffread.c(xcoff_symfile_init): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1987-2005, 2007-2012 Free Software Foundation, Inc.
@


1.135
log
@	* coffread.c (coff_objfile_data_key): New global.
	(coff_symfile_init): Use set_objfile_data.
	(coff_symfile_read): Use objfile_data.
	(coff_symfile_finish): Don't free deprecated_sym_private.
	(coff_free_info): New function.
	(_initialize_coffread): Initialize coff_objfile_data_key.
	* mdebugread.c (pending_list): Update comment.
	* objfiles.h (struct objfile) <deprecated_sym_private>: Remove.
	* symfile.c (reread_symbols): Don't mention
	deprecated_sym_private.
	* xcoffread.c (xcoff_objfile_data_key): New global.
	(XCOFF_DATA): New macro.
	(process_linenos, enter_line_range, xcoff_next_symbol_text)
	(read_xcoff_symtab, coff_getfilename, read_symbol_lineno): Use
	XCOFF_DATA.
	(xcoff_new_init) Use set_objfile_data.
	(xcoff_symfile_finish): Don't free deprecated_sym_private.
	(init_stringtab, swap_sym, scan_xcoff_symtab)
	(xcoff_get_toc_offset, xcoff_initial_scan): Use XCOFF_DATA.
	(xcoff_free_info): New function.
	(_initialize_xcoffread): Initialize xcoff_objfile_data_key.
@
text
@a471 2

  init_entry_point_info (objfile);
@


1.134
log
@	* coffread.c (coff_symfile_init): Use set_objfile_data.
	(coff_symfile_read): Use DBX_SYMFILE_INFO.
	* dbxread.c (dbx_objfile_data_key): New global.
	(dbx_symfile_init): Use set_objfile_data.
	(dbx_symfile_finish): Don't free deprecated_sym_stab_info.
	(dbx_free_symfile_info): New function.
	(coffstab_build_psymtabs, elfstab_build_psymtabs): Use
	DBX_SYMFILE_INFO.
	(stabsect_build_psymtabs): Use set_objfile_data.
	(_initialize_dbxreadb): Initialize dbx_objfile_data_key.
	* elfread.c (elf_symtab_read): Use DBX_SYMFILE_INFO,
	set_objfile_data.
	(free_elfinfo): Use DBX_SYMFILE_INFO.
	(elf_symfile_finish): Don't free deprecated_sym_stab_info.
	(elfstab_offset_sections): Use DBX_SYMFILE_INFO.
	* gdb-stabs.h (dbx_objfile_data_key): Declare.
	(DBX_SYMFILE_INFO): Rewrite to use objfile_data.
	* objfiles.h (struct objfile) <deprecated_sym_stab_info>: Remove.
	* somread.c (som_symfile_finish): Don't free
	deprecated_sym_stab_info.
@
text
@d50 4
d458 1
d465 2
a466 5
  objfile->deprecated_sym_private
    = xmalloc (sizeof (struct coff_symfile_info));

  memset (objfile->deprecated_sym_private, 0,
	  sizeof (struct coff_symfile_info));
d531 1
a531 1
  info = (struct coff_symfile_info *) objfile->deprecated_sym_private;
a684 5
  if (objfile->deprecated_sym_private != NULL)
    {
      xfree (objfile->deprecated_sym_private);
    }

d2199 8
d2211 3
@


1.133
log
@gdb/
2012-11-21  Yao Qi  <yao@@codesourcery.com>

	PR tdep/7438
	* gdbarch.sh (smash_text_address): Remove.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arm-tdep.c (arm_smash_text_address): Remove.
	(arm_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	* hppa-tdep.c (hppa_smash_text_address): Remove.
	(hppa_addr_bits_remove): Rename from hppa_smash_text_address.
	(hppa_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	Caller update.
	* coffread.c (coff_symtab_read): Caller update.
	* dbxread.c (process_one_symbol): Likewise.
	* elfread.c (record_minimal_symbol): Likewise.
	* somread.c (som_symtab_read): Likewise.
@
text
@d453 2
d456 2
a457 5
  objfile->deprecated_sym_stab_info = (struct dbx_symfile_info *)
    xmalloc (sizeof (struct dbx_symfile_info));

  memset (objfile->deprecated_sym_stab_info, 0,
	  sizeof (struct dbx_symfile_info));
d530 1
a530 1
  dbxinfo = objfile->deprecated_sym_stab_info;
@


1.132
log
@	* coffread.c (coff_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* elfread.c (elf_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* jit.c (jit_bfd_try_read_symtab): Make a cleanup for 'nbfd'.
	* machoread.c (macho_add_oso_symfile): Make a cleanup for
	'abfd'.
	(macho_symfile_read): Make a cleanup for 'dsym_bfd'.
	* objfiles.c (allocate_objfile): Acquire a new reference.
	* rs6000-nat.c (add_vmap): Don't acquire a BFD reference.
	* solib.c (solib_read_symbols): Don't acquire a BFD reference.
	* spu-linux-nat.c (spu_symbol_file_add_from_memory): Make
	a cleanup for 'nbfd'.
	* symfile-mem.c (symbol_file_add_from_memory): Make a cleanup
	for 'nbfd'.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Don't
	make a cleanup for 'abfd'.
	(symbol_file_add): Make a BFD cleanup.
@
text
@d944 1
a944 1
		    tmpaddr = gdbarch_smash_text_address (gdbarch, tmpaddr);
@


1.131
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d656 1
d662 1
a663 1
	  xfree (debugfile);
@


1.130
log
@2012-05-16  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* coffread.c (cs_section_address): Passing proper argument for
	`bfd_get_section_vma'.
	* dwarf2read.c (dwarf2_locate_sections): Likewise, for
	`bfd_get_section_flags'.
	* remote.c (remote_trace_set_readonly_regions): Likewise, for
	`bfd_get_section_vma'.
@
text
@a1308 1
  char *temp;
@


1.129
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (lookup_block_symbol, iterate_over_symbols)
	(find_pc_sect_symtab, search_symbols)
	(default_make_symbol_completion_list_break_on)
	(make_file_symbol_completion_list): Update.
	* symmisc.c (dump_symtab_1): Update.
	* stack.c (print_frame_args, iterate_over_block_locals)
	(print_frame_labels, iterate_over_block_arg_vars): Update.
	* python/py-block.c (block_object) <dict>: Remove.
	<block>: New field.
	<iter>: Change type.
	(blpy_iter): Update.
	(blpy_block_syms_iternext): Update.
	* psymtab.c (map_block): Use block iterators.
	* objfiles.c (objfile_relocate1): Use ALL_DICT_SYMBOLS.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* mdebugread.c (parse_symbol, mylookup_symbol): Update.
	* infrun.c (check_exception_resume): Update.
	* cp-support.c (make_symbol_overload_list_block): Update.
	* coffread.c (patch_opaque_types): Update.
	* buildsym.c (finish_block, end_symtab): Use ALL_DICT_SYMBOLS.
	* block.h (struct block_iterator): New.
	(block_iterator_first, block_iterator_next, block_iter_name_first)
	(block_iter_name_next, block_iter_match_first)
	(block_iter_match_next): Declare.
	(ALL_BLOCK_SYMBOLS): Redefine.
	* block.c (block_iterator_first, block_iterator_next)
	(block_iter_name_first, block_iter_name_next)
	(block_iter_match_first, block_iter_match_next): New functions.
	* ada-lang.c (ada_add_block_symbols)
	(ada_make_symbol_completion_list): Use block iterator.
@
text
@d314 1
a314 1
    addr = bfd_get_section_vma (objfile->obfd, sect);
@


1.128
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d1474 1
a1474 1
  struct dict_iterator iter;
@


1.127
log
@gdb/
	PR symtab/7259:
	* ada-exp.y (convert_char_literal): Use TYPE_FIELD_ENUMVAL.
	* ada-lang.c (ada_discrete_type_high_bound)
	(ada_discrete_type_low_bound): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(ada_identical_enum_types_p): Use TYPE_FIELD_ENUMVAL.
	(pos_atr, value_val_atr): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* ada-typeprint.c (print_enum_type): Change variable lastval to LONGEST.
	Use TYPE_FIELD_ENUMVAL.
	* ada-valprint.c (print_optional_low_bound, ada_print_scalar)
	(ada_val_print_1): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* c-typeprint.c (c_type_print_base): Move variable lastval to inner
	block, change it to LONGEST.  Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* coffread.c (coff_read_enum_type): Use SET_FIELD_ENUMVAL.
	* dwarf2read.c (process_enumeration_scope): Likewise.
	* gdb-gdb.py (TypeFlagsPrinter): Use field.enumval instead of
	field.bitpos.
	(class StructMainTypePrettyPrinter): Support also
	FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.c (get_discrete_bounds): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(recursive_dump_type): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(copy_type_recursive): Support also FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.h (enum field_loc_kind): New FIELD_LOC_KIND_ENUMVAL.
	(struct main_type.flds_bnds.fields.loc): Adjust bitpos comment.  New
	field enumval.
	(struct main_type.flds_bnds.bields): Adjust loc_kind and bitsize to
	accommodate enumval.
	(struct call_site): Adjust loc_kind to accommodate enumval.
	(FIELD_ENUMVAL, FIELD_ENUMVAL_LVAL, SET_FIELD_ENUMVAL)
	(TYPE_FIELD_ENUMVAL): New macros.
	* m2-typeprint.c (m2_enum): Use TYPE_FIELD_ENUMVAL.
	* mdebugread.c (parse_symbol): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* python/lib/gdb/printing.py (class FlagEnumerationPrinter): Use
	enumval.
	* python/lib/gdb/types.py (make_enum_dict): Likewise.
	* python/py-type.c (convert_field): New variable addrstring.  Use
	TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(check_types_equal): Support also FIELD_LOC_KIND_ENUMVAL.
	* stabsread.c (read_enum_type): Use SET_FIELD_ENUMVAL.
	* typepint.c (print_type_scalar): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* valprint.c (generic_val_print): Likewise.

gdb/testsuite/
	PR symtab/7259:
	* gdb.base/enumval.c: New test case.
	* gdb.base/enumval.exp: New test case.
	* gdb.python/py-type.exp (test_enums): Use field.enumval instead of
	field.bitpos.
@
text
@d2199 1
@


1.126
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d2162 1
a2162 1
	  SET_FIELD_BITPOS (TYPE_FIELD (type, n), SYMBOL_VALUE (xsym));
@


1.125
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1458 2
d1461 2
a1462 3
	xfree (TYPE_NAME (target));
      TYPE_NAME (target) = concat (TYPE_NAME (real_target), 
				   (char *) NULL);
d1490 1
a1490 1
	  char *name = SYMBOL_LINKAGE_NAME (real_sym);
d1679 1
a1679 1
		  concat (SYMBOL_LINKAGE_NAME (sym), (char *) NULL);
@


1.124
log
@	* coffread.c (coffread_objfile): Rename from current_objfile.
	* dbxread.c (dbxread_objfile): Rename from current_objfile.
	* mdebugread.c (mdebugread_objfile): Rename from current_objfile.
@
text
@d2 1
a2 3
   Copyright (C) 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.124.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 3
a4 1
   Copyright (C) 1987-2005, 2007-2012 Free Software Foundation, Inc.
@


1.123
log
@	* symtab.h (current_objfile): Don't declare.
	* objfiles.h (current_objfile): Don't declare.
	* objfiles.c (current_objfile): Remove.
	* mdebugread.c (current_objfile): New file-scope global.
	* dbxread.c (current_objfile): New file-scope global.
	* coffread.c (current_objfile): New file-scope global.
@
text
@d54 1
a54 1
static struct objfile *current_objfile;
d362 1
a362 1
      type = alloc_type (current_objfile);
d752 1
a752 1
  current_objfile = objfile;
d1139 1
a1139 1
  current_objfile = NULL;
d1160 1
a1160 1
    error (_("%s: error reading symbols"), current_objfile->name);
d1167 1
a1167 1
	error (_("%s: error reading symbols"), current_objfile->name);
d1177 1
a1177 1
	    error (_("%s: error reading symbols"), current_objfile->name);
@


1.122
log
@2011-05-26  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct dwarf2_section_names): New type.
	(struct dwarf2_debug_sections): New type.
	(dwarf2_has_info): Add parameter.
	* dwarf2read.c (dwarf2_elf_names): New variable.
	(INFO_SECTION, ABBREV_SECTION, LINE_SECTION, LOC_SECTION)
	(MACINFO_SECTION, STR_SECTION, RANGES_SECTION, TYPES_SECTION)
	(FRAME_SECTION, EH_FRAME_SECTION, GDB_INDEX_SECTION): Remove.
	(dwarf2_has_info): Add names parameter.  Pass names
	to dwarf2_locate_sections.
	(section_is_p): Rewrite using the names parameter.
	(dwarf2_locate_sections): Use section names from the names parameter.
	* coffread.c (coff_symfile_read): Adjust call to dwarf2_has_info.
	* elfread.c (read_psyms): Ditto.
	* machoread.c (macho_symfile_read): Ditto.
@
text
@d52 4
@


1.121
log
@delete target_ops.to_lookup_symbol

gdb/ChangeLog:

        * target.h (struct target_ops): Remove to_lookup_symbol field.
        (target_lookup_symbol): Delete macro.
        * target.c (nosymbol, debug_to_lookup_symbol): Delete.
        (update_current_target, setup_target_debug): Remove handling
        of to_lookup_symbol target_ops field.
        * ada-tasks.c (get_known_tasks_addr): Remove use of
        target_lookup_symbol.
        * coffread.c (coff_symtab_read): Likewise.
        * dbxread.c (read_dbx_symtab): Ditto.
@
text
@d640 1
a640 1
  if (dwarf2_has_info (objfile))
@


1.120
log
@	* cli/cli-cmds.c (shell_escape): Use lbasename.
	* coffread.c (coff_start_symtab): Constify parameter.
	(complete_symtab): Constify `name' parameter.
	(coff_symtab_read): Constify `filestring' local.
	(coff_getfilename): Constify return and `result' local.
	Use lbasename.
	* fbsd-nat.c (fbsd_make_corefile_notes): Use lbasename.
	* linux-fork.c (info_checkpoints_command): Use lbasename.
	* linux-nat.c (linux_nat_make_corefile_notes): Use lbasename.
	* minsyms.c (lookup_minimal_symbol): Use lbasename.
	* nto-tdep.c (nto_find_and_open_solib): Use lbasename.
	* procfs.c (procfs_make_note_section): Use lbasename.
	* tui/tui-io.c (printable_part): Constity return and parameter.
	Use lbasename.
	(print_filename): Constify parameters, and local `s'.
	(tui_rl_display_match_list): Constify local `temp'.
@
text
@d905 8
a912 16
		/* This is a common symbol.  See if the target
		   environment knows where it has been relocated to.  */
		CORE_ADDR reladdr;

		if (target_lookup_symbol (cs->c_name, &reladdr))
		  {
		    /* Error in lookup; ignore symbol.  */
		    break;
		  }
		tmpaddr = reladdr;
		/* The address has already been relocated; make sure that
		   objfile_relocate doesn't relocate it again.  */
		sec = -2;
		ms_type = cs->c_sclass == C_EXT
		  || cs->c_sclass == C_THUMBEXT ?
		  mst_bss : mst_file_bss;
@


1.119
log
@	* xcoffread.c (xcoff_sym_fns): Update.
	* symfile.h (struct sym_fns) <sym_read_psymbols>: New field.
	(enum symfile_add_flags) <SYMFILE_NO_READ>: New constant.
	* symfile.c (syms_from_objfile): Handle SYMFILE_NO_READ.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(reread_symbols): Handle OBJF_PSYMTABS_READ.
	* somread.c (som_sym_fns): Update.
	* psymtab.h (require_partial_symbols): Declare.
	* psymtab.c (require_partial_symbols): New function.
	(ALL_OBJFILE_PSYMTABS_REQUIRED): New macro.
	(ALL_OBJFILE_PSYMTABS): Undef.
	(ALL_PSYMTABS): Move from psympriv.h.
	(lookup_partial_symtab, find_pc_sect_psymtab)
	(lookup_symbol_aux_psymtabs, relocate_psymtabs)
	(find_last_source_symtab_from_partial)
	(forget_cached_source_info_partial)
	(print_psymtab_stats_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(map_symbol_names_psymtab, map_symbol_filenames_psymtab)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_info_psymtabs):
	Use ALL_OBJFILE_PSYMTABS_REQUIRED.
	* psympriv.h (ALL_PSYMTABS): Move to psymtab.c.
	* objfiles.h (OBJF_PSYMTABS_READ): New macro.
	* objfiles.c (objfile_has_partial_symbols): Handle lazily-read
	psymtabs.
	* mipsread.c (ecoff_sym_fns): Update.
	* machoread.c (macho_sym_fns): Update.
	* elfread.c (elf_symfile_read): Set up for lazy psymtab reading.
	(read_psyms): New function.
	(elf_sym_fns, elf_sym_fns_gdb_index): Update.
	(elf_sym_fns_lazy_psyms): New global.
	* dwarf2read.c (dwarf2_initialize_objfile): Don't call
	dwarf2_build_psymtabs.
	* dbxread.c (aout_sym_fns): Update.
	* coffread.c (coff_sym_fns): Update.
@
text
@d181 1
a181 1
static char *coff_getfilename (union internal_auxent *);
d369 1
a369 1
coff_start_symtab (char *name)
d391 1
a391 1
complete_symtab (char *name, CORE_ADDR start_addr, unsigned int size)
d716 1
a716 1
  char *filestring = "";
d1311 1
a1311 1
static char *
d1316 1
a1316 1
  char *result;
d1334 1
a1334 2
  if ((temp = strrchr (result, '/')) != NULL)
    result = temp + 1;
@


1.118
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* coffread.c (coff_getfilename): Add check to avoid overflow.
@
text
@d2194 1
@


1.117
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* coffread.c (coff_end_symtab): Delete unused variable.
@
text
@d1319 5
a1323 1
    strcpy (buffer, stringtab + aux_entry->x_file.x_n.x_offset);
@


1.116
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* charset.c (validate): Internationalization.
	* coffread.c (read_one_sym): Ditto.
	* dwarf2read.c (dwarf2_attach_fields_to_type): Ditto.
	* h8300-tdep.c (H8300_extract_return_value): Ditto.
	* inflow.c (new_tty): Ditto.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* mep-tdep.c (mep_store_return_value): Ditto.
	* score-tdep.c (score7_fetch_insn): Ditto.
	* ser-mingw.c (pipe_windows_open): Ditto.
	* sh64-tdep.c (sh64_extract_return_value): Ditto.
	* spu-tdep.c (spu_register_type): Ditto.
	* tracepoint.c (trace_find_command): Ditto.
	* valarith.c (value_pos): Ditto.
@
text
@a407 2
  struct symtab *symtab;

d410 2
a411 2
  symtab = end_symtab (current_source_end_addr, objfile,
		       SECT_OFF_TEXT (objfile));
@


1.115
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d1166 1
a1166 1
    error ("%s: error reading symbols", current_objfile->name);
d1173 1
a1173 1
	error ("%s: error reading symbols", current_objfile->name);
d1183 1
a1183 1
	    error ("%s: error reading symbols", current_objfile->name);
@


1.114
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d1093 1
a1093 1
		{	/* We attempted to pop an empty context stack. */
d1655 1
a1655 1
	  /* If type has no name, give it one */
@


1.113
log
@run copyright.sh for 2011.
@
text
@d626 2
a627 2
	  error (_("The debugging information in `%s' is corrupted.\n"
		   "The file has a `.stabs' section, but no `.stabstr' section."),
d1026 2
a1027 1
			     _("`.ef' symbol without matching `.bf' symbol ignored starting at symnum %d"),
d1038 2
a1039 1
			     _("Unmatched .ef symbol(s) ignored starting at symnum %d"),
d1095 2
a1096 1
			     _("`.eb' symbol without matching `.bb' symbol ignored starting at symnum %d"),
d1104 3
a1106 2
		  complaint (&symfile_complaints, 
			     _("Mismatched .eb symbol ignored starting at symnum %d"),
@


1.112
log
@2010-12-31  Michael Snyder  <msnyder@@vmware.com>

	* charset.c: Comment cleanup and long line wrapping.
	* charset.h: Ditto.
	* c-lang.c: Ditto.
	* c-lang.h: Ditto.
	* coff-pe-read.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* complaints.c: Ditto.
	* complaints.h: Ditto.
	* completer.c: Ditto.
	* completer.h: Ditto.
	* corefile.c: Ditto.
	* corelow.c: Ditto.
	* core-regset.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-abi.h: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cp-support.h: Ditto.
	* cp-valprint.c: Ditto.
	* cp-typeprint.c: Ditto.
	* c-valprint.c: Ditto.
@
text
@d4 1
a4 1
   2010 Free Software Foundation, Inc.
@


1.111
log
@	* symfile.h (struct sym_fns) <next>: Remove.
	(add_symtab_fns): Update.
	* symfile.c (sym_fns_ptr): New typedef.
	(symtab_fns): Now a VEC.
	(add_symtab_fns): Update.  Change argument type.
	(find_sym_fns): Update.  Change return type.
	(get_symfile_segment_data): Update.
	* objfiles.h (struct objfile) <sf>: Now const.
	* somread.c (som_sym_fns): Now const.  Update.
	* xcoffread.c (xcoff_sym_fns): Now const.  Update.
	* mipsread.c (ecoff_sym_fns): Now const.  Update.
	* machoread.c (macho_sym_fns): Now const.  Update.
	* elfread.c (elf_sym_fns): Now const.  Update.
	(elf_sym_fns_gdb_index): Likewise.
	* dbxread.c (aout_sym_fns): Now const.  Update.
	* coffread.c (coff_sym_fns): Now const.  Update.
@
text
@d54 2
a55 2
    file_ptr min_lineno_offset;	/* Where in file lowest line#s are */
    file_ptr max_lineno_offset;	/* 1+last byte of line#s in file */
d57 2
a58 2
    CORE_ADDR textaddr;		/* Addr of .text section. */
    unsigned int textsize;	/* Size of .text section. */
d60 1
a60 1
    asection *stabstrsect;	/* Section pointer for .stab section */
d66 2
a67 1
	(string[0] == bfd_get_symbol_leading_char(abfd)? string+1: string)
d89 2
a90 1
/* Pointers to scratch storage, used for reading raw symbols and auxents.  */
d111 4
a114 4
/* Local variables that hold the sizes in the file of various COFF structures.
   (We only need to know this to read them from the file -- BFD will then
   translate the data in them, into `internal_xxx' structs in the right
   byte order, alignment, etc.)  */
d129 1
a129 1
/* Simplified internal version of coff symbol table information */
d134 3
a136 2
    int c_symnum;		/* symbol number of this entry */
    int c_naux;			/* 0 if syment only, 1 if syment + auxent, etc */
d149 2
a150 1
				      unsigned int, union internal_auxent *,
d190 2
a191 1
			  struct internal_syment *, union internal_auxent *);
d372 3
a374 4
  /* We fill in the filename later.  start_symtab puts
     this pointer into last_source_file and we put it in
     subfiles->name, which end_symtab frees; that's why
     it must be malloc'd.  */
d386 3
a388 2
   NAME is the file name the symbols came from, START_ADDR is the first
   text address for the file, and SIZE is the number of bytes of text.  */
d400 4
a403 4
/* Finish the symbol definitions for one main source file,
   close off all the lexical contexts for that file
   (creating struct block's for them), then make the
   struct symtab for that file and put it in the list of all such. */
d412 2
a413 1
  symtab = end_symtab (current_source_end_addr, objfile, SECT_OFF_TEXT (objfile));
d415 1
a415 1
  /* Reinitialize for beginning of new file. */
d426 1
a426 1
  /* We don't want TDESC entry points in the minimal symbol table */
d431 3
a433 2
  return prim_record_minimal_symbol_and_info (cs->c_name, address, type,
					      section, bfd_section, objfile);
d443 2
a444 2
   We will only be called if this is a COFF or COFF-like file.
   BFD handles figuring out the format of the file, and code in symtab.c
d447 2
a448 1
   The ultimate result is a new symtab (or, FIXME, eventually a psymtab).  */
d453 1
a453 1
  /* Allocate struct to keep track of stab reading. */
d460 3
a462 2
  /* Allocate struct to keep track of the symfile */
  objfile->deprecated_sym_private = xmalloc (sizeof (struct coff_symfile_info));
d464 2
a465 1
  memset (objfile->deprecated_sym_private, 0, sizeof (struct coff_symfile_info));
d475 3
a477 3
/* This function is called for every section; it finds the outer limits
   of the line table (minimum and maximum file offset) so that the
   mainline code can read the whole thing for efficiency.  */
d486 1
a486 1
/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
d488 1
a488 1
/* End of warning */
d495 1
a495 1
/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
d497 1
a497 1
/* End of warning */
d532 1
a532 1
  symfile_bfd = abfd;		/* Kludge for swap routines */
d566 1
a566 1
/* End of warning */
d612 2
a613 2
  /* Install any minimal symbols that have been collected as the current
     minimal symbols for this objfile.  */
d674 5
a678 4
/* Perform any local cleanups required when we are done with a particular
   objfile.  I.E, we are in the process of discarding all symbol information
   for an objfile, freeing up all memory held for it, and unlinking the
   objfile struct from the global list of known objfiles. */
d688 1
a688 1
  /* Let stabs reader clean up */
d730 2
a731 2
     it's hard to know I've really worked around it.  The fix should be
     harmless, anyway).  The symptom of the bug is that the first
d745 1
a745 1
  /* Position to read the symbol table. */
d756 1
a756 1
  if (type_vector)		/* Get rid of previous one */
d784 2
a785 1
	  /* done with all files, everything from here on out is globals */
d788 2
a789 1
      /* Special case for file with type declarations only, no text.  */
d797 2
a798 1
	  /* Record all functions -- external and static -- in minsyms. */
d801 4
a804 2
	  tmpaddr = cs->c_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
	  record_minimal_symbol (cs, tmpaddr, mst_text, section, objfile);
d823 2
a824 1
	  complaint (&symfile_complaints, _("Bad n_sclass for symbol %s"),
d829 2
a830 2
	  /* c_value field contains symnum of next .file entry in table
	     or symnum of first global after last .file.  */
d847 3
a849 3
	  /* C_LABEL is used for labels and static functions.  Including
	     it here allows gdb to see static functions when no debug
	     info is available.  */
d851 2
a852 2
	  /* However, labels within a function can make weird backtraces,
	     so filter them out (from phdm@@macqel.be). */
d863 5
a867 5
		  /* FIXME:  don't wire in ".text" as section name
		     or symbol name! */
		  /* Check for in_source_file deals with case of
		     a file with debugging symbols
		     followed by a later file with no symbols.  */
d870 2
a871 1
		    cs->c_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile)),
d875 1
a875 1
	      /* flush rest of '.' symbols */
d891 1
a891 1
	  /* fall in for static symbols that don't start with '.' */
d927 1
a927 1
 		   relocate) for absolute values. */
d938 1
a938 1
 		/* Statics in a PE file also get relocated */
d957 2
a958 2
		      cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXT ?
		      mst_data : mst_file_data;
d963 2
a964 2
		      cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXT ?
		      mst_bss : mst_file_bss;
d970 2
a971 1
	    msym = record_minimal_symbol (cs, tmpaddr, ms_type, sec, objfile);
d973 2
a974 1
	      gdbarch_coff_make_msymbol_special (gdbarch, cs->c_sclass, msym);
d993 2
a994 1
	      /* value contains address of first non-init type code */
d996 1
a996 1
	         contains line number of '{' } */
d999 2
a1000 1
			   _("`.bf' symbol %d has no aux entry"), cs->c_symnum);
d1011 2
a1012 1
		process_coff_symbol (&fcn_cs_saved, &fcn_aux_saved, objfile);
d1018 1
a1018 1
	      /* the value of .ef is the address of epilogue code;
d1024 1
a1024 1
		{		/* We attempted to pop an empty context stack */
d1045 2
a1046 1
			     _("`.ef' symbol %d has no aux entry"), cs->c_symnum);
d1055 5
a1059 4
	         of the line number of the first statement of the function -
	         except for one-line functions, for which it is also the line
	         number of all the statements and of the closing '}', and
	         for which we do not have any other statement-line-number. */
d1065 2
a1066 2
		enter_linenos (fcn_line_ptr, fcn_first_line, fcn_last_line,
			       objfile);
d1068 2
a1069 2
	      finish_block (new->name, &local_symbols, new->old_blocks,
			    new->start_addr,
d1072 2
a1073 1
			    + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile)),
d1084 2
a1085 1
	      tmpaddr += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1091 1
a1091 1
		{		/* We attempted to pop an empty context stack */
d1101 1
a1101 1
		  complaint (&symfile_complaints,
d1109 2
a1110 1
		    cs->c_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1129 1
a1129 1
	 executable, so try to read the export table */
d1146 4
a1149 3
/* Read the next symbol, swap it, and return it in both internal_syment
   form, and coff_symbol form.  Also return its first auxent, if any,
   in internal_auxent form, and skip any other auxents.  */
d1170 2
a1171 1
      bfd_coff_swap_aux_in (symfile_bfd, temp_aux, sym->n_type, sym->n_sclass,
d1174 1
a1174 1
         is important). */
d1226 1
a1226 1
/* Support for string table handling */
d1240 1
a1240 1
     string table.  Just return with `stringtab' set to null. */
d1251 1
a1251 1
     after the symbols.  Just return with `stringtab' set to null. */
d1256 2
a1257 2
  /* This is in target format (probably not very useful, and not currently
     used), not host format.  */
d1259 1
a1259 1
  if (length == sizeof length)	/* Empty table -- just the count */
d1262 2
a1263 2
  val = bfd_bread (stringtab + sizeof lengthbuf, length - sizeof lengthbuf,
		   abfd);
d1305 3
a1307 3
/* Extract the file name from the aux entry of a C_FILE symbol.  Return
   only the last component of the name.  Result is in static storage and
   is only good for temporary use.  */
d1359 1
a1359 1
  /* Allocate the desired table, plus a sentinel */
d1366 1
a1366 1
  /* Terminate it with an all-zero sentinel record */
d1405 1
a1405 1
      if (file_offset > linetab_size)	/* Too big to be an offset? */
d1407 2
a1408 1
      file_offset += linetab_offset;	/* Try reading at that linetab offset */
d1413 1
a1413 1
  /* skip first line entry for each function */
d1415 1
a1415 1
  /* line numbers start at one for the first line of the function */
d1426 1
a1426 1
	 we exit. */
d1430 4
a1433 2
	  addr += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
	  record_line (current_subfile, first_line + L_LNNO32 (&lptr),
d1450 2
a1451 1
  TYPE_FIELDS (target) = (struct field *) TYPE_ALLOC (target, field_size);
d1453 3
a1455 1
  memcpy (TYPE_FIELDS (target), TYPE_FIELDS (real_target), field_size);
d1461 2
a1462 1
      TYPE_NAME (target) = concat (TYPE_NAME (real_target), (char *)NULL);
d1467 2
a1468 1
   so that they can be used to print out opaque data structures properly.  */
d1477 1
a1477 1
  /* Go through the per-file symbols only */
d1563 2
a1564 1
      SYMBOL_VALUE (sym) += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1566 2
a1567 1
	lookup_function_type (decode_function_type (cs, cs->c_type, aux, objfile));
d1595 2
a1596 1
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1605 2
a1606 1
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1609 1
a1609 1
	      /* Static symbol of local scope */
d1614 1
a1614 1
	      /* Static symbol at top level of file */
d1657 13
a1669 13
		  /* If we are giving a name to a type such as "pointer to
		     foo" or "function returning foo", we better not set
		     the TYPE_NAME.  If the program contains "typedef char
		     *caddr_t;", we don't want all variables of type char
		     * to print as caddr_t.  This is not just a
		     consequence of GDB's type management; CC and GCC (at
		     least through version 2.4) both output variables of
		     either type char * or caddr_t with the type
		     refering to the C_TPDEF symbol for caddr_t.  If a future
		     compiler cleans this up it GDB is not ready for it
		     yet, but if it becomes ready we somehow need to
		     disable this check (without breaking the PCC/GCC2.4
		     case).
d1679 1
a1679 1
		  concat (SYMBOL_LINKAGE_NAME (sym), (char *)NULL);
d1682 6
a1687 5
	  /* Keep track of any type which points to empty structured type,
	     so it can be filled from a definition from another file.  A
	     simple forward reference (TYPE_CODE_UNDEF) is not an
	     empty structured type, though; the forward references
	     work themselves out via the magic of coff_lookup_type.  */
d1709 1
a1709 1
	     "~0fake" or ".0fake".  Thanks, but no thanks... */
d1756 1
a1756 1
	  /* auxent refers to array, not base type */
d1760 1
a1760 1
	  /* shift the indices down */
d1771 2
a1772 1
	    create_range_type ((struct type *) NULL, index_type, 0, n - 1);
d1774 2
a1775 1
	    create_array_type ((struct type *) NULL, base_type, range_type);
d1780 6
a1785 7
  /* Reference to existing type.  This only occurs with the
     struct, union, and enum types.  EPI a29k coff
     fakes us out by producing aux entries with a nonzero
     x_tagndx for definitions of structs, unions, and enums, so we
     have to check the c_sclass field.  SCO 3.2v4 cc gets confused
     with pointers to pointers to defined structs, and generates
     negative x_tagndx fields.  */
d1801 1
a1801 1
	  /* And fall through to decode_base_type... */
d1812 4
a1815 2
decode_function_type (struct coff_symbol *cs, unsigned int c_type,
		      union internal_auxent *aux, struct objfile *objfile)
d1818 2
a1819 1
    cs->c_naux = 0;		/* auxent refers to function, not base type */
d1824 1
a1824 1
/* basic C types */
d1827 4
a1830 2
decode_base_type (struct coff_symbol *cs, unsigned int c_type,
		  union internal_auxent *aux, struct objfile *objfile)
d1838 1
a1838 1
      /* shows up with "void (*foo)();" structure members */
d1876 1
a1876 1
	  /* anonymous structure type */
d1880 3
a1882 3
	  /* This used to set the tag to "<opaque>".  But I think setting it
	     to NULL is right, and the printing code can print it as
	     "struct {...}".  */
d1901 1
a1901 1
	  /* anonymous union type */
d1904 3
a1906 3
	  /* This used to set the tag to "<opaque>".  But I think setting it
	     to NULL is right, and the printing code can print it as
	     "union {...}".  */
d1926 1
a1926 1
	  /* anonymous enum type */
d1930 3
a1932 3
	  /* This used to set the tag to "<opaque>".  But I think setting it
	     to NULL is right, and the printing code can print it as
	     "enum {...}".  */
d1948 1
a1948 1
      /* shouldn't show up here */
d1968 2
a1969 1
  complaint (&symfile_complaints, _("Unexpected type for symbol %s"), cs->c_name);
d2022 4
a2025 4
	  list->field.name =
	    obsavestring (name, strlen (name), &objfile->objfile_obstack);
	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux,
						  objfile);
d2039 4
a2042 4
	  list->field.name =
	    obsavestring (name, strlen (name), &objfile->objfile_obstack);
	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux,
						  objfile);
d2177 1
a2177 1
/* Register our ability to parse symbols for coff BFD files. */
d2182 12
a2193 7
  coff_new_init,		/* sym_new_init: init anything gbl to entire symtab */
  coff_symfile_init,		/* sym_init: read initial info, setup for sym_read() */
  coff_symfile_read,		/* sym_read: read a symbol file into symtab */
  coff_symfile_finish,		/* sym_finish: finished with file, cleanup */
  default_symfile_offsets,	/* sym_offsets:  xlate external to internal form */
  default_symfile_segments,	/* sym_segments: Get segment information from
				   a file.  */
d2195 3
a2197 1
  default_symfile_relocate,	/* sym_relocate: Relocate a debug section.  */
@


1.110
log
@	* coffread.c (struct coff_symbol): Change c_value type from `long' to
	`CORE_ADDRESS' as it might contain target addresses.
@
text
@d2129 1
a2129 1
static struct sym_fns coff_sym_fns =
d2141 1
a2141 2
  &psym_functions,
  NULL				/* next: pointer to next struct sym_fns */
@


1.109
log
@create and use symbol_set_language.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed SYMBOL_INIT_LANGUAGE_SPECIFIC to
	SYMBOL_SET_LANGUAGE.
	(symbol_init_language_specific): Renamed to symbol_set_language.
	* symtab.c (symbol_init_language_specific): Removed redundant check
	for language_cplus.
	Renamed to symbol_set_language.
	* stabsread.c (define_symbol): Updated.
	(read_enum_type): Updated
	* psymtab.c (add_psymbol_to_bcache): Updated.
	* minsyms.c (install_minimal_symbols): Updated.
	* coffread.c (process_coff_symbol): SYMBOL_SET_LANGUAGE instead of
	SYMBOL_LANGUAGE to set the language.
	* minsyms.c (prim_record_minimal_symbol_full): Ditto.
	* mdebugread.c (new_symbol): Ditto.
	* cp-namespace.c (check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol_full): Ditto.
	* jv-lang.c (add_class_symbol): Ditto.
@
text
@d134 1
a134 1
    long c_value;
@


1.108
log
@2010-05-13  Michael Snyder  <msnyder@@vmware.com>

	* charset.c: White space.
	* c-lang.c: White space.
	* cli-out.c: White space.
	* coffread.c: White space.
	* complaints.c: White space.
	* completer.c: White space.
	* corefile.c: White space.
	* corelow.c: White space.
	* cp-abi.c: White space.
	* cp-namespace.c: White space.
	* cp-support.c: White space.
	* cp-valprint.c: White space.
	* c-typeprint.c: White space.
	* c-valprint.c: White space.
@
text
@d1515 1
a1515 1
  SYMBOL_LANGUAGE (sym) = current_subfile->language;
@


1.107
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* elfread.c (elf_symtab_read): Delete unused variable.
	(find_separate_debug_file_by_buildid): Delete unused variables.
	(elf_symfile_read): Delete unused variable.

	* coffread.c (coff_symfile_read): Delete unused variables.

	* coff-pe-read.c (add_pe_exported_sym): Delete unused variable.
	(read_pe_exported_syms): Delete unused variable.

	* stabsread.c (define_symbol): Delete unused variable.

	* dwarf2read.c (read_type_comp_unit_head): Delete unused variable.
	(process_psymtab_comp_unit): Delete unused variable.
	(dwarf2_build_psymtabs_hard): Delete unused variable.
	(load_partial_comp_unit): Delete unused variable.
	(create_all_comp_units): Delete unused variable.
	(scan_partial_symbols): Delete unused variable.
	(add_partial_symbol): Delete unused variable.
	(add_partial_namespace): Delete unused variable.
	(add_partial_enumeration): Delete unused variable.
	(load_full_comp_unit): Delete unused variable.
	(process_full_comp_unit): Delete unused variable.
	(read_file_scope): Delete unused variable.
	(read_type_unit_scope): Delete unused variable.
	(process_structure_scope): Delete unused variable.
	(process_enumeration_scope): Delete unused variable.
	(read_tag_ptr_to_member_type): Delete unused variable.
	(read_typedef): Delete unused variable.
	(read_partial_die): Delete unused variable.
	(decode_locdesc): Delete unused variable.
	(zeroed_partial_die): Delete unused global variable.
@
text
@d263 1
d286 1
d419 1
d650 1
d786 1
d892 1
d917 1
d959 1
d1508 2
a1509 2
  = (struct symbol *) obstack_alloc (&objfile->objfile_obstack,
				     sizeof (struct symbol));
d2109 1
@


1.106
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@a515 2
  int len;
  char * target;
@


1.105
log
@2010-02-03  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Add sym_relocate field.
	(default_symfile_relocate): New prototype.
	(symfile_relocate_debug_section): First argument is now an objfile.
	* symfile.c (default_symfile_relocate): Rename from
	symfile_relocate_debug_section, first argument is now an objfile.
	(symfile_relocate_debug_section): New function.
	* coffread.c (coff_sym_fns): Set sym_relocate field.
	* somread.c (som_sym_fns): Ditto.
	* mipsread.c (ecoff_sym_fns): Ditto.
	* machoread.c (macho_sym_fns): Ditto.
	* elfread.c (elf_sym_fns): Ditto.
	* dwarf2read.c (dwarf2_read_section): Ditto.
	* xcoffread.c (xcoff_sym_fns): Ditto.
	* dbxread.c (aout_sym_fns): Ditto.
	(dbx_psymtab_to_symtab): Adjust call to symfile_relocate_debug_section.
	(elfstab_build_psymtabs): Ditto.
@
text
@d48 2
d2134 1
@


1.104
log
@Delete free_named_symtabs and associated cleanup.

        * symfile.h (free_named_symtabs): Delete declaration.
        * symfile.c: Remove some commented out code (clear_symtab_users_once).
        (cashier_psymtab): Comment function out.
        Delete declaration.
        (free_named_symtabs): Delete.
        * coffread.c (coff_end_symtab): Remove call to free_named_symtabs.
        * dbxread.c (end_psymtab): Likewise.
        * dwarf2read.c (process_psymtab_comp_unit): Ditto.
        * exec.c (exec_close_1): Ditto.
        * xcoffread.c (xcoff_end_psymtab): Likewise.
@
text
@d2131 1
@


1.103
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a404 3
  if (symtab != NULL)
    free_named_symtabs (symtab->filename);

@


1.102
log
@2009-12-02  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (symbol_file_add_separate): New prototype.
	(find_separate_debug_file_by_buildid): Ditto.
	(find_separate_debug_file_by_debuglink): Ditto.
	* symfile.c (reread_separate_symbols): Remove.
	(find_separate_debug_file): Split into ...
	(find_separate_debug_file_by_buildid): ... this and ...
	(find_separate_debug_file_by_debuglink): ... this.
	(symbol_file_add_with_addrs_or_offsets): Do not save orig_addrs.
	Remove separate debug file handling.
	(symbol_file_add_separate): New function.
	(reread_symbols): Do not considere separate debug files, but free
	them while handling their parent.  Reindent.
	* coffread.c (coff_symfile_read): Handle separate object file.
	* elfread.c (elf_symfile_read): Ditto.
@
text
@d3 2
a4 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.101
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Adjust comment on sym_read.
	* symfile.c (syms_from_objfile): Pass all symfile flags to sym_read.
	* dbxread.c (dbx_symfile_read): Rename mainline to symfile_flags,
	adjust header comment.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
	* xcoffread.c (xcoff_initial_scan): Ditto.
	* coffread.c (coff_symfile_read): Rename mainline to symfile_flags.
	* machoread.c (macho_symfile_read): Ditto.
	* mipsread.c (mipscoff_symfile_read): Ditto.
@
text
@d640 15
@


1.100
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* dbxread.c (dbx_symfile_read): No need to test mainline to call
	init_psymbol_list.
	* xcoffread.c (xcoff_initial_scan): Ditto;
	* coffread.c (coff_symfile_read): Remove call to init_psymbol_list.
	* elfread.c (elf_symfile_read): Ditto.
	* machoread.c (macho_symfile_read): Ditto.
@
text
@d504 1
a504 1
coff_symfile_read (struct objfile *objfile, int mainline)
@


1.99
log
@2009-12-02  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (dwarf2_build_psymtabs): Remove mainline parameter in
	prototype.
	* dwarf2read.c (dwarf2_build_psymtabs): Remove mainline paramter in
	definition, simplify code assuming it is always 0.
	* coffread.c (coff_symfile_read): Adjust call.
	* elfread.c (elf_symfile_read): Ditto.
	* machoread.c (macho_symfile_read): Explicitely calls
	init_psymbol_list if mainline is set.
@
text
@a609 9
  /* If we are reinitializing, or if we have not loaded syms yet,
     empty the psymtab.  "mainline" is cleared so the *_read_psymtab
     functions do not all re-initialize it.  */
  if (mainline)
    {
      init_psymbol_list (objfile, 0);
      mainline = 0;
    }

@


1.98
log
@2009-12-02  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2read.c (dwarf2_build_psymtabs_easy): Remove mainline parameter.
	(dwarf2_build_psymtabs_hard): Ditto.
	(dwarf2_build_psymtabs): Ajust calls.
	* stabsread.h (elfstab_build_psymtabs): Remove mainline parameter on
	the prototype.
	(coffstab_build_psymtabs): Ditto.
	(stabsect_build_psymtabs): Ditto.
	* dbxread.c (coffstab_build_psymtabs): Remove mainline parameter on
	the definition.
	(elfstab_build_psymtabs): Ditto.
	(stabsect_build_psymtabs): Ditto.
	* coffread.c (coff_symfile_read): Adjust call.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
@
text
@d644 1
a644 1
      dwarf2_build_psymtabs (objfile, mainline);
@


1.97
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@a636 1
			       mainline,
@


1.96
log
@	ARI fix: OP eol rule.
	* blockframe.c (find_pc_partial_function): Avoid operator at end of
	line.
	* buildsym.c (find_symbol_in_list): Idem.
	(start_subfile, patch_subfile_names): Idem.
	* c-exp.y (variable, yylex): Idem.
	* c-typeprint.c (c_print_type, c_type_print_base): Idem.
	* c-valprint.c (c_val_print): Idem.
	* coffread.c (patch_opaque_types, process_coff_symbol): Idem.
	* corelow.c (core_open): Idem.
	* cris-tdep.c (move_reg_to_mem_movem_op): Idem.
	* cli/cli-decode.c (help_cmd_list, find_command_name_length): Idem.
@
text
@d1506 1
a1506 1
  SYMBOL_SET_NAMES (sym, name, strlen (name), objfile);
@


1.95
log
@	* gdbtypes.h (struct builtin_type): Remove builtin_core_addr,
	nodebug_text_symbol, nodebug_data_symbol, nodebug_unknown_symbol,
	and nodebug_tls_symbol members.
	(struct objfile_type): New data structure.
	(objfile_type): Add prototype.
	* gdbtypes.c (gdbtypes_post_init): Remove initialization code
	for types no longer in struct builtin_type.
	(objfile_type_data): New static variable.
	(_initialize_gdbtypes): Initialize it.
	(objfile_type): New function.

	* gdbtypes.h (builtin_type_error): Remove.
	* gdbtypes.c (build_complex): Do not use builtin_type_error.
	* symtab.c (builtin_type_error): Remove.
	(_initialize_symtab): Remove initialization.

	* stabsread.c (dbx_lookup_type, define_symbol, error_type,
	rs6000_builtin_type, read_range_type): Use per-objfile types
	instead of global or per-architecture builtin types.
	* coffread.c (decode_type): Likewise.
	* dwarf2read.c (read_array_type, read_tag_string_type,
	new_symbol, die_type): Likewise.
	* mdebugread.c (parse_symbol, basic_type, upgrade_type,
	parse_procedure, psymtab_to_symtab_1): Likewise.
	* xcoffread.c (process_xcoff_symbol): Likewise.
	* parse.c (write_exp_msymbol): Likewise.

	* stabsread.c (rs6000_builtin_type_data): New static variable.
	(_initialize_stabsread): Initialize it.
	(rs6000_builtin_type): Add OBJFILE argument.  Allocate builtin
	types per-objfile instead of globally.

	* stabsread.c (dbx_lookup_type): Add OBJFILE argument.  Use it
	instead of current_objfile; pass it to rs6000_builtin_type.
	(dbx_alloc_type, read_type, read_range_type): Update calls.
	(cleanup_undefined_types_noname): Add OBJFILE argument and
	pass it to dbx_lookup_type.
	(cleanup_undefined_types): Add OBJFILE argument and pass it
	to cleanup_undefined_types_noname.
	* stabsread.h (cleanup_undefined_types): Add OBJFILE argument.
	* buildsym.c (end_symtab): Update call.
@
text
@d1437 4
a1440 4
      if (SYMBOL_CLASS (real_sym) == LOC_TYPEDEF &&
	  SYMBOL_DOMAIN (real_sym) == VAR_DOMAIN &&
	  TYPE_CODE (SYMBOL_TYPE (real_sym)) == TYPE_CODE_PTR &&
	  TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (real_sym))) != 0)
d1449 2
a1450 2
	      if (name[0] == SYMBOL_LINKAGE_NAME (sym)[0] &&
		  strcmp (name + 1, SYMBOL_LINKAGE_NAME (sym) + 1) == 0)
d1635 4
a1638 4
	  if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR &&
	      TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))) == 0 &&
	      TYPE_CODE (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))) !=
	      TYPE_CODE_UNDEF)
@


1.94
log
@	* buildsym.c (record_line): Remove call to gdbarch_addr_bits_remove.

	* coffread.c (coff_symtab_read): Call gdbarch_addr_bits_remove before
	calling record_line.
	(enter_linenos): Likewise.
	* dbxread.c (process_one_symbol): Likewise.
	* dwarf2read.c (dwarf_decode_lines): Likewise.
	* mdebugread.c (psymtab_to_symtab_1): Likewise.
	* xcoffread.c (enter_line_range): Likewise.
@
text
@d1716 1
a1716 1
	  index_type = builtin_type_int32;
d1780 1
a1780 1
      return builtin_type (gdbarch)->builtin_void;
d1785 1
a1785 1
      return builtin_type (gdbarch)->builtin_void;
d1789 1
a1789 1
      return builtin_type (gdbarch)->builtin_char;
d1792 1
a1792 1
      return builtin_type (gdbarch)->builtin_short;
d1795 1
a1795 1
      return builtin_type (gdbarch)->builtin_int;
d1801 1
a1801 1
	return builtin_type (gdbarch)->builtin_long_long;
d1803 1
a1803 1
	return builtin_type (gdbarch)->builtin_long;
d1806 1
a1806 1
      return builtin_type (gdbarch)->builtin_float;
d1809 1
a1809 1
      return builtin_type (gdbarch)->builtin_double;
d1812 1
a1812 1
      return builtin_type (gdbarch)->builtin_long_double;
d1893 1
a1893 1
      return builtin_type (gdbarch)->builtin_unsigned_char;
d1896 1
a1896 1
      return builtin_type (gdbarch)->builtin_unsigned_short;
d1899 1
a1899 1
      return builtin_type (gdbarch)->builtin_unsigned_int;
d1905 1
a1905 1
	return builtin_type (gdbarch)->builtin_unsigned_long_long;
d1907 1
a1907 1
	return builtin_type (gdbarch)->builtin_unsigned_long;
d1910 1
a1910 1
  return builtin_type (gdbarch)->builtin_void;
@


1.93
log
@	* symtab.h: Rename SYMBOL_OPS to SYMBOL_COMPUTED_OPS.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value, symbol_read_needs_frame): Likewise.
	* printcmd.c (address_info): Likewise.
	* dwarf2loc.c (dwarf_expr_frame_base): Likewise.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Likewise.
	* symtab.h: Rename struct symbol_ops to struct symbol_computed_ops.
	* dwarf2loc.h: Likewise.
	* dwarf2loc.c (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Likewise.

	* symtab.h: (struct symbol_register_ops): New struct definition.
	(struct symbol): Make "ops" member a union of symbol_computed_ops and
	symbol_register_ops callback pointers.
	(SYMBOL_REGISTER_OPS): New macro.
	* tracepoint.c: Include "objfiles.h".
	(scope_info, collect_symbol): Use SYMBOL_REGISTER_OPS register_number
	callback to retrieve register numbers.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value): Likewise.
	* printcmd.c (address_info): Likewise.

	* coffread.c (coff_reg_to_regnum): New function.
	(coff_register_funcs): New static variable.
	(process_coff_symbol): Do not call gdbarch_sdb_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* mdebugread.c (mdebug_reg_to_regnum): New function.
	(mdebug_register_funcs): New static variable.
	(parse_symbol): Do not call gdbarch_ecoff_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* stabsread.c (stab_reg_to_regnum): New function.
	(stab_register_funcs): New static variable.
	(define_symbol): Do not call gdbarch_stab_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
@
text
@d1027 2
a1028 1
			     fcn_first_line_addr);
d1354 1
d1387 6
a1392 3
	record_line (current_subfile, first_line + L_LNNO32 (&lptr),
		     lptr.l_addr.l_paddr
		     + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile)));
@


1.92
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d1477 10
d1567 2
a1568 2
	  SYMBOL_VALUE (sym) = gdbarch_sdb_reg_to_regnum
				 (current_gdbarch, cs->c_value);
d1584 1
d1586 1
a1586 2
	  SYMBOL_VALUE (sym) = gdbarch_sdb_reg_to_regnum
				 (current_gdbarch, cs->c_value);
@


1.91
log
@
	* coffread.c (process_coff_symbol): Set the symbol's language to
	the language of current_subfile.
@
text
@d367 1
a367 1
		 savestring (name, strlen (name)),
d386 1
a386 1
  last_source_file = savestring (name, strlen (name));
@


1.90
log
@
	* symmisc.c (dump_symtab): Switch the current language to
	the language of the symtab we are dumping only if the symtab's
	language is neither language_auto nor language_unknown.

	* coffread.c (coff_symtab_read): Set language_minimal as the
	language for the "_globals_" pseudo-file.
@
text
@d1490 1
a1490 1
  SYMBOL_LANGUAGE (sym) = language_auto;
@


1.89
log
@        Updated copyright notices for most files.
@
text
@d761 5
@


1.88
log
@(coff_symtab_read): Fix a typo in a comment.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
@


1.87
log
@	Convert static_kind into loc_kind enum.
	* gdbtypes.h (enum field_loc_kind): New.
	(union field_location): New field dwarf_block.
	(struct field): Rename static_kind as loc_kind.
	(FIELD_STATIC_KIND): Rename to ...
	(FIELD_LOC_KIND): ... here.
	(TYPE_FIELD_STATIC_KIND): Rename to ...
	(TYPE_FIELD_LOC_KIND): ... here and use there now new FIELD_LOC_KIND.
	(TYPE_FIELD_STATIC_HAS_ADDR): Remove.
	(TYPE_FIELD_STATIC): Remove.
	(TYPE_FIELD_BITPOS): Reformat.
	(SET_FIELD_BITPOS): New.
	(FIELD_PHYSADDR): Rename to ...
	(FIELD_STATIC_PHYSADDR): ... here.
	(TYPE_FIELD_STATIC_PHYSADDR): Follow the FIELD_PHYSADDR rename.
	(SET_FIELD_PHYSADDR): Use new FIELD_LOC_KIND.
	(FIELD_PHYSNAME): Rename to ...
	(FIELD_STATIC_PHYSNAME): ... here.
	(TYPE_FIELD_STATIC_PHYSNAME): Follow the FIELD_PHYSNAME rename.
	(SET_FIELD_PHYSNAME): Use new FIELD_LOC_KIND.
	(FIELD_DWARF_BLOCK, TYPE_FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK): New.
	(field_is_static): New declaration.
	* gdbtypes.c (field_is_static): New function.
	(copy_type_recursive): Update throughout.
	* amd64-tdep.c, c-typeprint.c, coffread.c, cp-valprint.c, dwarf2read.c,
	eval.c, jv-typeprint.c, jv-valprint.c, mdebugread.c, p-typeprint.c,
	p-valprint.c, valops.c, value.c, varobj.c: Update throughout.
@
text
@d1084 1
a1084 1
      /* We've got no debugging symbols, but it's is a portable
@


1.86
log
@	* xcoffread.c (RECORD_MINIMAL_SYMBOL): Update.
	(scan_xcoff_symtab): Update.
	* mdebugread.c (record_minimal_symbol): Update.
	(parse_partial_symbols): Update.
	* elfread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* coffread.c (record_minimal_symbol): Update.
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Redefine.
	(sh64_elf_make_msymbol_special): Update.
	* mips-tdep.c (mips_elf_make_msymbol_special): Use
	MSYMBOL_TARGET_FLAG_1.
	(mips_elf_make_msymbol_special): Likewise.
	(msymbol_is_special): Likewise.
	* minsyms.c (prim_record_minimal_symbol_and_info): Update.
	(install_minimal_symbols): Likewise.
	(prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_and_info): Remove 'info' argument.
	* m68hc11-tdep.c (MSYMBOL_SET_RTC): Redefine.
	(MSYMBOL_SET_RTI): Redefine.
	(MSYMBOL_IS_RTC): Redefine.
	(MSYMBOL_IS_RTI): Redefine.
	* arm-tdep.c (MSYMBOL_SET_SPECIAL): Redefine.
	(MSYMBOL_IS_SPECIAL): Redefine.
	* symtab.h (struct minimal_symbol) <info>: Remove.
	<target_flag_1, target_flag_2>: New fields.
	(MSYMBOL_INFO): Remove.
	(MSYMBOL_TARGET_FLAG_1): New macro.
	(MSYMBOL_TARGET_FLAG_2): Likewise.
	(prim_record_minimal_symbol_and_info): Update.
@
text
@d1946 1
a1946 1
	  FIELD_BITPOS (list->field) = 8 * ms->c_value;
a1947 1
	  FIELD_STATIC_KIND (list->field) = 0;
d1963 1
a1963 1
	  FIELD_BITPOS (list->field) = ms->c_value;
a1964 1
	  FIELD_STATIC_KIND (list->field) = 0;
d2081 1
a2081 1
	  TYPE_FIELD_BITPOS (type, n) = SYMBOL_VALUE (xsym);
a2084 1
	  TYPE_FIELD_STATIC_KIND (type, n) = 0;
@


1.85
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d424 1
a424 1
    NULL, section, bfd_section, objfile);
@


1.84
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d2094 1
a2094 1
    TYPE_FLAGS (type) |= TYPE_FLAG_UNSIGNED;
@


1.83
log
@	* coffread.c (coff_symtab_read): Remove FUNCTION_EPILOGUE_SIZE.

	* gdbint.texinfo: Remove FUNCTION_EPILOGUE_SIZE.
@
text
@d1432 1
a1432 1
	  char *name = DEPRECATED_SYMBOL_NAME (real_sym);
d1439 2
a1440 2
	      if (name[0] == DEPRECATED_SYMBOL_NAME (sym)[0] &&
		  strcmp (name + 1, DEPRECATED_SYMBOL_NAME (sym) + 1) == 0)
d1607 1
a1607 1
		  concat (DEPRECATED_SYMBOL_NAME (sym), (char *)NULL);
d1620 1
a1620 1
	      int i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d1638 3
a1640 3
	    if (DEPRECATED_SYMBOL_NAME (sym) != NULL
		&& *DEPRECATED_SYMBOL_NAME (sym) != '~'
		&& *DEPRECATED_SYMBOL_NAME (sym) != '.')
d1642 1
a1642 1
		concat (DEPRECATED_SYMBOL_NAME (sym), (char *)NULL);
d2034 3
a2036 2
	  DEPRECATED_SYMBOL_NAME (sym) =
	    obsavestring (name, strlen (name), &objfile->objfile_obstack);
d2082 1
a2082 1
	  TYPE_FIELD_NAME (type, n) = DEPRECATED_SYMBOL_NAME (xsym);
@


1.82
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@a1028 12
#if defined (FUNCTION_EPILOGUE_SIZE)
	      /* This macro should be defined only on
	         machines where the
	         fcn_aux_saved.x_sym.x_misc.x_fsize
	         field is always zero.
	         So use the .bf record information that
	         points to the epilogue and add the size
	         of the epilogue.  */
			    cs->c_value
			    + FUNCTION_EPILOGUE_SIZE
			    + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile)),
#else
a1031 1
#endif
@


1.81
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d1576 1
d1581 2
a1582 1
	  SYMBOL_CLASS (sym) = LOC_REGPARM;
@


1.80
log
@
	* rs6000-nat.c (add_vmap, vmap_ldinfo, vmap_exec): Replace
	DEPRECATED_STREQ by its expression.
	* coffread.c (coff_locate_sections, coff_symtab_read): Likewise.
	* xcoffread.c (read_xcoff_symtab, read_symbol_lineno, find_linenos)
	(scan_xcoff_symtab): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Likewise.
	* f-lang.c (find_common_for_function): Likewise.
	* objc-exp.y (parse_number): Likewise.

	* defs.h (DEPRECATED_STREQ): Remove.
@
text
@d140 2
a141 1
static struct type *coff_read_struct_type (int, int, int);
d144 2
a145 1
				      unsigned int, union internal_auxent *);
d148 2
a149 1
				 union internal_auxent *);
d153 2
a154 1
					  union internal_auxent *);
d156 2
a157 1
static struct type *coff_read_enum_type (int, int, int);
d687 1
d919 1
a919 2
		    tmpaddr = gdbarch_smash_text_address
				(current_gdbarch, tmpaddr);
d940 1
a940 2
	      gdbarch_coff_make_msymbol_special
	      (current_gdbarch, cs->c_sclass, msym);
d1510 1
a1510 1
	lookup_function_type (decode_function_type (cs, cs->c_type, aux));
d1522 1
a1522 1
      SYMBOL_TYPE (sym) = decode_type (cs, cs->c_type, aux);
d1669 1
a1669 1
	     union internal_auxent *aux)
d1679 1
a1679 1
	  type = decode_type (cs, new_c_type, aux);
d1684 1
a1684 1
	  type = decode_type (cs, new_c_type, aux);
d1706 1
a1706 1
	  base_type = decode_type (cs, new_c_type, aux);
d1742 1
a1742 1
  return decode_base_type (cs, BTYPE (c_type), aux);
d1750 1
a1750 1
		      union internal_auxent *aux)
d1755 1
a1755 1
  return decode_type (cs, DECREF (c_type), aux);
d1762 1
a1762 1
		  union internal_auxent *aux)
d1764 1
d1771 1
a1771 1
      return builtin_type (current_gdbarch)->builtin_void;
d1776 1
a1776 1
      return builtin_type (current_gdbarch)->builtin_void;
d1780 1
a1780 1
      return builtin_type (current_gdbarch)->builtin_char;
d1783 1
a1783 1
      return builtin_type (current_gdbarch)->builtin_short;
d1786 1
a1786 1
      return builtin_type (current_gdbarch)->builtin_int;
d1791 2
a1792 2
	     > gdbarch_long_bit (current_gdbarch))
	return builtin_type (current_gdbarch)->builtin_long_long;
d1794 1
a1794 1
	return builtin_type (current_gdbarch)->builtin_long;
d1797 1
a1797 1
      return builtin_type (current_gdbarch)->builtin_float;
d1800 1
a1800 1
      return builtin_type (current_gdbarch)->builtin_double;
d1803 1
a1803 1
      return builtin_type (current_gdbarch)->builtin_long_double;
d1825 2
a1826 1
				      aux->x_sym.x_fcnary.x_fcn.x_endndx.l);
d1849 2
a1850 1
				      aux->x_sym.x_fcnary.x_fcn.x_endndx.l);
d1874 2
a1875 1
				      aux->x_sym.x_fcnary.x_fcn.x_endndx.l);
d1884 1
a1884 1
      return builtin_type (current_gdbarch)->builtin_unsigned_char;
d1887 1
a1887 1
      return builtin_type (current_gdbarch)->builtin_unsigned_short;
d1890 1
a1890 1
      return builtin_type (current_gdbarch)->builtin_unsigned_int;
d1895 2
a1896 2
	     > gdbarch_long_bit (current_gdbarch))
	return builtin_type (current_gdbarch)->builtin_unsigned_long_long;
d1898 1
a1898 1
	return builtin_type (current_gdbarch)->builtin_unsigned_long;
d1901 1
a1901 1
  return builtin_type (current_gdbarch)->builtin_void;
d1910 2
a1911 1
coff_read_struct_type (int index, int length, int lastsym)
d1940 1
a1940 1
      name = EXTERNAL_NAME (name, current_objfile->obfd);
d1954 3
a1956 4
	    obsavestring (name,
			  strlen (name),
			  &current_objfile->objfile_obstack);
	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux);
d1972 3
a1974 4
	    obsavestring (name,
			  strlen (name),
			  &current_objfile->objfile_obstack);
	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux);
d2005 2
a2006 1
coff_read_enum_type (int index, int length, int lastsym)
d2008 1
d2036 1
a2036 1
      name = EXTERNAL_NAME (name, current_objfile->obfd);
d2042 1
a2042 2
	    (&current_objfile->objfile_obstack,
	     sizeof (struct symbol));
d2046 1
a2046 2
	    obsavestring (name, strlen (name),
			  &current_objfile->objfile_obstack);
d2068 1
a2068 1
    TYPE_LENGTH (type) = gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT;
@


1.79
log
@	Updated copyright notices for most files.
@
text
@d201 1
a201 1
  if (DEPRECATED_STREQ (name, ".text"))
d210 1
a210 1
  else if (DEPRECATED_STREQ (name, ".stabstr"))
d826 1
a826 1
	      if (DEPRECATED_STREQ (cs->c_name, ".text"))
d950 1
a950 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bf"))
d972 1
a972 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".ef"))
d1048 1
a1048 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bb"))
d1054 1
a1054 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".eb"))
@


1.78
log
@	* coffread.c (decode_type): Use builtin_type_int32 instead
	of FT_INTEGER fundamental type for array range index type.
	(decode_base_type): Use builtin types of current_gdbarch
	instead of fundamental types.

	* dwarf2read.c (struct dwarf2_cu): Remove ftypes member.
	(read_file_scope): Do not initialize ftypes member.
	(dwarf_base_type, dwarf2_fundamental_types): Remove functions.
	(read_array_type): Use builtin_type_int32 instead of FT_INTEGER
	fundamental type for array range index type.
	(read_tag_string_type): Likewise for string range index type.
	Also, do not overwrite FT_CHAR type with new string type.
	(read_base_type): If DW_AT_name is missing, create unnamed type
	with given properties instead of looking for a fundamental type.
	Create new types as TYPE_TARGET_TYPE for DW_ATE_address and
	DW_ATE_complex_float types.
	(read_subrange_type): Create new type to represent missing
	DW_AT_type instead of looking for a fundamental type.
	(die_type): Use builtin type to represent "void" instead of
	looking for a fundamental type.

	* stabsread.c (define_symbol): Use builtin types to represent
	'r' and 'i' floating-point and integer constants.

	* gdbtypes.c (lookup_fundamental_type): Remove.
	* gdbtypes.h (lookup_fundamental_type): Remove prototype.
	(FT_VOID, FT_BOOLEAN, FT_CHAR, FT_SIGNED_CHAR, FT_UNSIGNED_CHAR,
	FT_SHORT, FT_SIGNED_SHORT, FT_UNSIGNED_SHORT, FT_INTEGER,
	FT_SIGNED_INTEGER, FT_UNSIGNED_INTEGER, FT_LONG, FT_SIGNED_LONG,
	FT_UNSIGNED_LONG, FT_LONG_LONG, FT_SIGNED_LONG_LONG,
	FT_UNSIGNED_LONG_LONG, FT_FLOAT, FT_DBL_PREC_FLOAT, FT_EXT_PREC_FLOAT,
	FT_COMPLEX, FT_DBL_PREC_COMPLEX, FT_EXT_PREC_COMPLEX, FT_STRING,
	FT_FIXED_DECIMAL, FT_FLOAT_DECIMAL, FT_BYTE, FT_UNSIGNED_BYTE,
	FT_TEMPLATE_ARG, FT_DECFLOAT, FT_DBL_PREC_DECFLOAT,
	FT_EXT_PREC_DECFLOAT, FT_NUM_MEMBERS): Remove macros.
	* objfiles.c (struct objfile): Remove fundamental_types member.
	* symfile.c (reread_symbols): Do not clear fundamental_types.

	* language.h (struct language_defn): Remove la_fund_type member.
	(create_fundamental_type): Remove.
	* language.c (unk_lang_create_fundamental_type): Remove.
	(unknown_language_defn, auto_language_defn,
	local_language_defn): Adapt initializer.
	* ada-lang.c (ada_create_fundamental_type): Remove.
	(ada_language_defn): Adapt initializer.
	* c-lang.h (c_create_fundamental_type): Remove prototype.
	* c-lang.c (c_create_fundamental_type): Remove.
	(c_language_defn, cplus_language_defn, asm_language_defn,
	minimal_language_defn): Adapt initializer.
	* f-lang.c (f_create_fundamental_type): Remove.
	(f_language_defn): Adapt initializer.
	* jv-lang.c (java_create_fundamental_type): Remove.
	(java_language_defn): Adapt initializer.
	* m2-lang.c (m2_create_fundamental_type): Remove.
	(m2_language_defn): Adapt initializer.
	* objc-lang.c (objc_create_fundamental_type): Remove.
	(objc_language_defn): Adapt initializer.
	* p-lang.h (pascal_create_fundamental_type): Remove prototype.
	* p-lang.c (pascal_create_fundamental_type): Remove.
	(pascal_language_defn): Adapt initializer.
	* scm-lang.c (scm_language_defn): Adapt initializer.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
@


1.77
log
@	* coffread.c (coff_symfile_finish): Call dwarf2_free_objfile.
	* dwarf2read.c (dwarf2_free_objfile): New.
	* elfread.c (elf_symfile_finish): Call dwarf2_free_objfile.
	* symfile.h (dwarf2_free_objfile): Declare.
@
text
@d1703 1
a1703 1
	  index_type = lookup_fundamental_type (current_objfile, FT_INTEGER);
d1766 1
a1766 1
      return lookup_fundamental_type (current_objfile, FT_VOID);
d1771 1
a1771 1
      return lookup_fundamental_type (current_objfile, FT_VOID);
d1775 1
a1775 1
      return lookup_fundamental_type (current_objfile, FT_CHAR);
d1778 1
a1778 1
      return lookup_fundamental_type (current_objfile, FT_SHORT);
d1781 1
a1781 1
      return lookup_fundamental_type (current_objfile, FT_INTEGER);
d1787 1
a1787 1
	return lookup_fundamental_type (current_objfile, FT_LONG_LONG);
d1789 1
a1789 1
	return lookup_fundamental_type (current_objfile, FT_LONG);
d1792 1
a1792 1
      return lookup_fundamental_type (current_objfile, FT_FLOAT);
d1795 1
a1795 1
      return lookup_fundamental_type (current_objfile, FT_DBL_PREC_FLOAT);
d1798 1
a1798 1
      return lookup_fundamental_type (current_objfile, FT_EXT_PREC_FLOAT);
d1876 1
a1876 1
      return lookup_fundamental_type (current_objfile, FT_UNSIGNED_CHAR);
d1879 1
a1879 1
      return lookup_fundamental_type (current_objfile, FT_UNSIGNED_SHORT);
d1882 1
a1882 1
      return lookup_fundamental_type (current_objfile, FT_UNSIGNED_INTEGER);
d1888 1
a1888 1
	return lookup_fundamental_type (current_objfile, FT_UNSIGNED_LONG_LONG);
d1890 1
a1890 1
	return lookup_fundamental_type (current_objfile, FT_UNSIGNED_LONG);
d1893 1
a1893 1
  return lookup_fundamental_type (current_objfile, FT_VOID);
@


1.76
log
@	PR gdb/2280
	* coffread.c (read_one_sym): Check for read errors.
@
text
@d668 2
@


1.75
log
@        * symfile.h (struct sym_fns): Add new field sym_read_linetable.
        * coffread.c, dbxread.c, elfread.c, mipsread.c somread.c:
        Adjust the struct sym_fns object accordingly by setting
        the new field to NULL.
        * xcoffread.c (aix_process_linenos): Make static.
        (xcoff_sym_fns): Set new field to aix_process_linenos.
        * buildsym.c (end_symtab): Replace call to PROCESS_LINENUMBER_HOOK
        by call to new the new sym_fns sym_read_linetable function.
        * config/powerpc/aix.mt (DEPRECATED_TM_FILE): Delete.
        * config/rs6000/tm-rs6000.h: Delete.
@
text
@d1119 1
d1122 3
a1124 1
  bfd_bread (temp_sym, local_symesz, nlist_bfd_global);
d1129 3
a1131 1
      bfd_bread (temp_aux, local_auxesz, nlist_bfd_global);
d1137 5
a1141 1
	bfd_bread (temp_aux, local_auxesz, nlist_bfd_global);
@


1.74
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2103 1
@


1.73
log
@	* gdbarch.sh (BELIEVE_PCC_PROMOTION): Replace by
	gdbarch_believe_pcc_promotion.
	* stabsread.c (define_symbol): Likewise.
	Remove unnecessary definition.
	* coffread.c (process_coff_symbol): Remove unnecessary code.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.72
log
@	* coffread.c (coff_sym_fns): Add default_symfile_segments.
	* dbxread.c (start_psymtab): Check HAVE_ELF.
	(aout_sym_fns): Likewise.
	* elfread.c (elf_symfile_segments): New.
	(elf_sym_fns): Add elf_symfile_segments.
	* mipsread.c (ecoff_sym_fns): Add default_symfile_segments.
	* remote.c (get_offsets): Use symfile_map_offsets_to_segments.
	Skip if there is no symfile_objfile.  Handle TextSeg and DataSeg.
	* somread.c (som_sym_fns): Use default_symfile_segments.
	* symfile.c (find_sym_fns): Take a BFD and return the sym_fns.
	(init_objfile_sect_indices): Call symfile_find_segment_sections.
	(default_symfile_segments): New function.
	(syms_from_objfile): Update call to find_sym_fns.
	(symfile_get_segment_data, free_symfile_segment_data): New.
	(symfile_map_offsets_to_segments): New.
	(symfile_find_segment_sections): New.
	* symfile.h (struct symfile_segment_data): New.
	(struct sym_fns): Add sym_segments.
	(default_symfile_segments, symfile_get_segment_data)
	(free_symfile_segment_data): New prototypes.
	(symfile_map_offsets_to_segments): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add default_symfile_segments.
	* Makefile.in (COMMON_OBS): Remove elfread.o.
	(elf_internal_h): New.
	(elfread.o): Update.
	* configure.ac: Add elfread.o to COMMON_OBS if bfd/elf.o was
	compiled.
	* config.in, configure: Regenerated.
	* NEWS: Mention qOffsets changes.

	* gdb.texinfo (General Query Packets): Document qOffsets changes.

	* Makefile.def: Add dependency from configure-gdb to all-bfd.
	* Makefile.in: Regenerated.
@
text
@a1563 19
#if !defined (BELIEVE_PCC_PROMOTION)
	  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
	    {
	      /* If PCC says a parameter is a short or a char,
	         aligned on an int boundary, realign it to the
	         "little end" of the int.  */
	      struct type *temptype;
	      temptype = lookup_fundamental_type (current_objfile,
						  FT_INTEGER);
	      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (temptype)
		  && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT
		  && 0 == SYMBOL_VALUE (sym) % TYPE_LENGTH (temptype))
		{
		  SYMBOL_VALUE (sym) +=
		    TYPE_LENGTH (temptype)
		    - TYPE_LENGTH (SYMBOL_TYPE (sym));
		}
	    }
#endif
a1570 20
#if !defined (BELIEVE_PCC_PROMOTION)
	  /* FIXME:  This should retain the current type, since it's just
	     a register value.  gnu@@adobe, 26Feb93 */
	  {
	    /* If PCC says a parameter is a short or a char,
	       it is really an int.  */
	    struct type *temptype;
	    temptype =
	      lookup_fundamental_type (current_objfile, FT_INTEGER);
	    if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (temptype)
		&& TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT)
	      {
		SYMBOL_TYPE (sym) =
		  (TYPE_UNSIGNED (SYMBOL_TYPE (sym))
		   ? lookup_fundamental_type (current_objfile,
					      FT_UNSIGNED_INTEGER)
		   : temptype);
	      }
	  }
#endif
@


1.71
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (STAB_REG_TO_REGNUM): Replace by
	gdbarch_stab_reg_to_regnum.
	* stabsread.c (define_symbol): Likewise.
	* gdbarch.sh (ECOFF_REG_TO_REGNUM): Replace by
	gdbarch_ecoff_reg_to_regnum.
	* mdebugread.c (parse_symbol): Likewise.
	* i386-tdep.c (i386_gdbarch_init): Likewise (comment).
	* gdbarch.sh (DWARF_REG_TO_REGNUM): Replace by
	gdbarch_dwarf_reg_to_regnum.
	* gdbarch.sh (SDB_REG_TO_REGNUM): Replace by gdbarch_sdb_reg_to_regnum.
	* coffread.c (process_coff_symbol): Likewise.
	* gdbarch.sh (DWARF2_REG_TO_REGNUM): Replace by
	gdbarch_dwarf2_reg_to_regnum.
	* dwarf2loc.c (dwarf_expr_read_reg,dwarf2_evaluate_loc_desc)
	(locexpr_describe_location): Likewise.
	* dwarf2-frame.c (read_reg,execute_cfa_program,dwarf2_frame_cache)
	(dwarf2_frame_prev_register,dwarf2_signal_frame_this_id): Likewise.
	* dwarf2loc.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* dwarf2read.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2142 2
@


1.70
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SMASH_TEXT_ADDRESS): Replace by
	gdbarch_smash_text_address.
	* somread.c (som_symtab_read): Likewise.
	* elfread.c (record_minimal_symbol): Likewise.
	* dbxread.c (process_one_symbol): Likewise.
	* coffread.c (coff_symtab_read): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1552 2
a1553 1
	  SYMBOL_VALUE (sym) = SDB_REG_TO_REGNUM (cs->c_value);
d1587 2
a1588 1
	  SYMBOL_VALUE (sym) = SDB_REG_TO_REGNUM (cs->c_value);
@


1.69
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d913 2
a914 1
		    tmpaddr = SMASH_TEXT_ADDRESS (tmpaddr);
@


1.68
log
@2007-06-06  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (COFF_MAKE_MSYMBOL_SPECIAL): Replace by
	gdbarch_coff_make_msymbol_special.
	* coffread.c (coff_symtab_read): Likewise.
	* gdbarch.sh (ELF_MAKE_MSYMBOL_SPECIAL): Replace by
	gdbarch_elf_make_msymbol_special.
	* elfread.c (elf_symtab_read): Likewise.
	* mips-tdep.c (mips_elf_make_msymbol_special): Likewise (comment).
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Likewise (comment).
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1812 2
a1813 1
	  && aux->x_sym.x_misc.x_lnsz.x_size > TARGET_LONG_BIT)
d1913 2
a1914 1
	  && aux->x_sym.x_misc.x_lnsz.x_size > TARGET_LONG_BIT)
d2087 2
a2088 2
  else
    TYPE_LENGTH (type) = TARGET_INT_BIT / TARGET_CHAR_BIT;	/* Assume ints */
@


1.67
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d934 2
a935 1
	      COFF_MAKE_MSYMBOL_SPECIAL (cs->c_sclass, msym);
@


1.66
log
@Copyright updates for 2007.
@
text
@d1562 1
a1562 1
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
@


1.65
log
@2007-01-03  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* coffread.c (cs_to_section): If bfd_section is found, always
	return its section index.
	(coff_symtab_read): Determine the minimal_symbol_type using the
	bfd_section flags.

	* gdb.base/shreloc.exp: Use ldflags instead of additional_flags to
	pass --image-base to linker.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
@


1.64
log
@2006-11-28  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* coffread.c (cs_to_bfd_section): New function.
	(cs_to_section): Use cs_to_bfd_section.
	(record_minimal_symbol): Take the coff_symbol* parameter instead
	of the symbol's name as a char*.
	Add 'int section' parameter. Call prim_record_minimal_symbol_and_info
	instead of prim_record_minimal_symbol_and_info.
	Change return type to struct minimal_symbol *.
	(coff_symtab_read): Adapt to new record_minimal_symbol's signature.
	Make all minimal symbol creations go through record_minimal_symbol.
@
text
@d280 3
a282 13
  int off = SECT_OFF_TEXT (objfile);
  if (sect != NULL)
    {
      /* This is the section.  Figure out what SECT_OFF_* code it is.  */
      if (bfd_get_section_flags (abfd, sect) & SEC_CODE)
	off = SECT_OFF_TEXT (objfile);
      else if (bfd_get_section_flags (abfd, sect) & SEC_LOAD)
	off = SECT_OFF_DATA (objfile);
      else
	/* Just return the bfd section index. */
	off = sect->index;
    }
  return off;
d704 1
d897 1
d907 1
a907 1
		if (sec == SECT_OFF_TEXT (objfile))
d915 2
a916 1
		else if (sec == SECT_OFF_DATA (objfile))
d922 1
a922 1
		else if (sec == SECT_OFF_BSS (objfile))
d926 1
a926 1
		      mst_data : mst_file_data;
d932 3
a934 6
	    {
	      struct minimal_symbol *msym;
	      msym = record_minimal_symbol (cs, tmpaddr, ms_type, sec, objfile);
	      if (msym)
	        COFF_MAKE_MSYMBOL_SPECIAL (cs->c_sclass, msym);
	    }
@


1.63
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d262 3
a264 3
/* Return the section number (SECT_OFF_*) that CS points to.  */
static int
cs_to_section (struct coff_symbol *cs, struct objfile *objfile)
a267 1
  int off = SECT_OFF_TEXT (objfile);
d272 9
d419 4
a422 3
static void
record_minimal_symbol (char *name, CORE_ADDR address,
		       enum minimal_symbol_type type, struct objfile *objfile)
d424 1
d426 2
a427 2
  if (name[0] == '@@')
    return;
d429 3
a431 1
  prim_record_minimal_symbol (name, address, type, objfile);
d777 1
d779 1
a779 1
	  record_minimal_symbol (cs->c_name, tmpaddr, mst_text, objfile);
d939 7
a945 9
	    if (cs->c_name[0] != '@@' /* Skip tdesc symbols */ )
	      {
		struct minimal_symbol *msym;
		msym = prim_record_minimal_symbol_and_info
		  (cs->c_name, tmpaddr, ms_type, NULL,
		   sec, NULL, objfile);
		if (msym)
		  COFF_MAKE_MSYMBOL_SPECIAL (cs->c_sclass, msym);
	      }
@


1.62
log
@* bsd-kvm.c (bsd_kvm_open): Properly cast sentinel in concat call.
* coffread.c (patch_type, process_coff_symbol): Likewise.
* corelow.c (core_open): Likewise.
* dwarf2read.c (dwarf_decode_lines, dwarf2_start_subfile):
* language.c (set_lang_str, set_type_str, set_range_str)
(set_case_str): Likewise.
* source.c (add_path, openp): Likewise.
* stabsread.c: Likewise.
* top.c (init_history): Likewise.
* utils.c (xfullpath): Likewise.
* value.c (lookup_internalvar): Likewise.
* cli/cli-cmds.c (cd_command): Likewise.
* cli/cli-dump.c (add_dump_command): Likewise.
@
text
@d2 1
a2 1
   Copyright 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.61
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d1402 1
a1402 1
      TYPE_NAME (target) = concat (TYPE_NAME (real_target), NULL);
d1639 1
a1639 1
		  concat (DEPRECATED_SYMBOL_NAME (sym), NULL);
d1674 1
a1674 1
		concat (DEPRECATED_SYMBOL_NAME (sym), NULL);
@


1.60
log
@2005-01-29  Baurzhan Ismagulov  <ibr@@radix50.net>

	* ax-gdb.c, ax-general.c, bcache.c, bfd-target.c, bsd-kvm.c,
	* buildsym.c, c-lang.c, c-typeprint.c, c-valprint.c, charset.c,
	* coff-pe-read.c, coffread.c, complaints.c, copying.c: I18n markup.
@
text
@d579 1
a579 1
        error (_("\"%s\": error reading line numbers\n"), name);
d972 1
a972 1
		error (_("Bad coff function information\n"));
@


1.59
log
@2004-10-23  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct objfile): Rename obj_private to
	deprecated_obj_private, sym_private to deprecated_sym_private, and
	sym_stab_info to deprecated_sym_stab_info.
	* gdb-stabs.h: Update.
	* elfread.c: Update.
	* dbxread.c: Update.
	* coffread.c: Update.
	* xcoffread.c: Update.
	* symfile.c: Update.
	* somread.c: Update.
	* nlmread.c: Update.
	* mdebugread.c: Update.
	* hpread.c: Update.
	* coffread.c: Update.
@
text
@d579 1
a579 1
        error ("\"%s\": error reading line numbers\n", name);
d587 1
a587 1
    error ("\"%s\": can't get string table", name);
d620 2
a621 3
	  error (("The debugging information in `%s' is corrupted.\n"
		  "The file has a `.stabs' section, but no `.stabstr' "
		  "section."),
d785 1
a785 1
	  complaint (&symfile_complaints, "Bad n_sclass for symbol %s",
d956 1
a956 1
			   "`.bf' symbol %d has no aux entry", cs->c_symnum);
d972 1
a972 1
		error ("Bad coff function information\n");
d981 1
a981 1
			     "`.ef' symbol without matching `.bf' symbol ignored starting at symnum %d",
d992 1
a992 1
			     "Unmatched .ef symbol(s) ignored starting at symnum %d",
d1000 1
a1000 1
			     "`.ef' symbol %d has no aux entry", cs->c_symnum);
d1056 1
a1056 1
			     "`.eb' symbol without matching `.bb' symbol ignored starting at symnum %d",
d1065 1
a1065 1
			     "Mismatched .eb symbol ignored starting at symnum %d",
d1143 1
a1143 1
    printf ("thumb symbol %s, class 0x%x\n", cs->c_name, cs->c_sclass);
d1353 1
a1353 1
		 "Line number pointer %ld lower than start of line numbers",
d1757 1
a1757 1
		     "Symbol table entry for %s has bad tagndx value",
d1915 1
a1915 1
  complaint (&symfile_complaints, "Unexpected type for symbol %s", cs->c_name);
@


1.58
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (xmfree): Delete.
	* utils.c (xmfree): Delete function.
	(xfree): Inline calls to xmfree and mfree.
	* symmisc.c (free_symtab_block, free_symtab): Use xfree.
	* symfile.c (reread_symbols, init_psymbol_list): Ditto.
	* source.c (forget_cached_source_info, find_and_open_source): Ditto.
	* somread.c (som_symfile_finish): Ditto.
	* objfiles.c (allocate_objfile, free_objfile):
	* nlmread.c (nlm_symfile_finish): Ditto.
	* hpread.c (hpread_symfile_finish): Ditto.
	* elfread.c (free_elfinfo, elf_symfile_finish): Ditto.
	* dbxread.c (dbx_symfile_finish, free_bincl_list): Ditto.
	* coffread.c (coff_symfile_finish): Ditto.
@
text
@d439 1
a439 1
  objfile->sym_stab_info = (struct dbx_symfile_info *)
d442 1
a442 1
  memset (objfile->sym_stab_info, 0,
d446 1
a446 1
  objfile->sym_private = xmalloc (sizeof (struct coff_symfile_info));
d448 1
a448 1
  memset (objfile->sym_private, 0, sizeof (struct coff_symfile_info));
d515 2
a516 2
  info = (struct coff_symfile_info *) objfile->sym_private;
  dbxinfo = objfile->sym_stab_info;
d662 1
a662 1
  if (objfile->sym_private != NULL)
d664 1
a664 1
      xfree (objfile->sym_private);
@


1.57
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (xmmalloc): Delete.
	(xmalloc): Inline xmmalloc and mmalloc calls.
	(msavestring): Use xmalloc.
	* defs.h (xmmalloc): Delete declaration.
	* xcoffread.c (xcoff_symfile_init): Use xmalloc instead of
	xmmalloc.
	* symmisc.c (extend_psymbol_list): Ditto.
	* symfile.c (init_psymbol_list): Ditto.
	* source.c (find_source_lines): Ditto.
	* hpread.c (hpread_symfile_init, hpread_lookup_type): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dbxread.c (dbx_symfile_init, init_bincl_list): Ditto.
	* coffread.c (coff_symfile_init): Ditto.
@
text
@d664 1
a664 1
      xmfree (objfile->md, objfile->sym_private);
@


1.56
log
@* coffread.c (coff_symfile_read): Prevent mixed debugging formats
from corrupting/reinitializing the psymtab.  Support DWARF 2 frame
info.
* dbxread.c (elfstab_build_psymtabs): Remove bogus comment.
@
text
@d440 1
a440 1
    xmmalloc (objfile->md, sizeof (struct dbx_symfile_info));
d446 1
a446 2
  objfile->sym_private = xmmalloc (objfile->md,
				   sizeof (struct coff_symfile_info));
@


1.55
log
@2004-05-07  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Delete unused fields
	deprecated_entry_file_lowpc and deprecated_entry_file_highpc.
	* objfiles.c (init_entry_point_info, objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab, read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d606 9
d645 2
@


1.54
log
@	* dwarf2read.c (dwarf2_objfile_data_key): New.
	(struct dwarf2_per_objfile, dwarf2_per_objfile): New.
	(dwarf_info_size, dwarf_abbrev_size, dwarf_line_size)
	(dwarf_pubnames_size, dwarf_aranges_size, dwarf_loc_size)
	(dwarf_macinfo_size, dwarf_str_size, dwarf_ranges_size)
	(dwarf_frame_size, dwarf_eh_frame_size, dwarf_info_buffer)
	(dwarf_abbrev_buffer, dwarf_line_buffer, dwarf_str_buffer)
	(dwarf_macinfo_buffer, dwarf_ranges_buffer, dwarf_loc_buffer):
	Remove variables.
	(struct dwarf2_pinfo): Remove per-objfile members.  Update comments.
	(DWARF_ABBREV_SIZE, DWARF_LINE_SIZE)
	(DWARF_LOC_SIZE, DWARF_MACINFO_SIZE, DWARF_STR_SIZE)
	(DWARF_RANGES_SIZE, DWARF_INFO_BUFFER)
	(DWARF_ABBREV_BUFFER, DWARF_LINE_BUFFER, DWARF_STR_BUFFER)
	(DWARF_MACINFO_BUFFER, DWARF_RANGES_BUFFER, DWARF_LOC_BUFFER):
	Remove macros.
	(dwarf2_has_info): Take an objfile argument.  Allocate per-objfile
	data.
	(dwarf2_locate_sections, dwarf2_build_psymtabs)
	(dwarf2_build_psymtabs_easy, dwarf2_build_psymtabs_hard)
	(skip_one_die, dwarf2_get_pc_bounds, dwarf2_read_abbrevs)
	(read_partial_die, read_full_die, read_indirect_string)
	(dwarf_decode_line_header, dwarf_decode_macros)
	(dwarf2_symbol_mark_computed): Remove use of removed macros.
	Update uses of removed variables.
	(psymtab_to_symtab_1): Restore per-objfile data pointer.  Remove use
	of removed macros.
	(_initialize_dwarf2_read): New function.
	* symfile.h (dwarf2_has_info): Update prototype.
	* coffread.c (coff_symfile_read): Update call to dwarf2_has_info.
	* elfread.c (elf_symfile_read): Likewise.
@
text
@a387 7

  if (current_objfile->ei.entry_point >= current_source_start_addr &&
      current_objfile->ei.entry_point < current_source_end_addr)
    {
      current_objfile->ei.deprecated_entry_file_lowpc = current_source_start_addr;
      current_objfile->ei.deprecated_entry_file_highpc = current_source_end_addr;
    }
@


1.53
log
@2004-02-27  Eli Zaretskii  <eliz@@elta.co.il>

	* coffread.c (enter_linenos): Don't let rawptr reference memory
	outside linetab[]'s limits.
@
text
@d637 1
a637 1
  if (dwarf2_has_info (abfd))
@


1.52
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@d1365 4
a1368 1
  for (;;)
d1372 2
a1373 1
      /* The next function, or the sentinel, will have L_LNNO32 zero; we exit. */
@


1.52.2.1
log
@	* dwarf2read.c (dwarf2_per_objfile_data): New.
	(struct dwarf2_per_objfile_data): New.
	(dwarf2_per_objfile): New.
	(dwarf_info_size, dwarf_abbrev_size, dwarf_line_size)
	(dwarf_pubnames_size, dwarf_aranges_size, dwarf_loc_size)
	(dwarf_macinfo_size, dwarf_str_size, dwarf_ranges_size)
	(dwarf_frame_size, dwarf_eh_frame_size, dwarf_info_buffer)
	(dwarf_abbrev_buffer, dwarf_line_buffer, dwarf_str_buffer)
	(dwarf_macinfo_buffer, dwarf_ranges_buffer, dwarf_loc_buffer):
	Replace with macros.
	(dwarf2_cu_tree): Remove.
	(struct dwarf2_pinfo): Remove per-objfile members.
	(DWARF_INFO_SIZE, DWARF_ABBREV_SIZE, DWARF_LINE_SIZE)
	(DWARF_LOC_SIZE, DWARF_MACINFO_SIZE, DWARF_STR_SIZE)
	(DWARF_RANGES_SIZE, DWARF_INFO_BUFFER)
	(DWARF_ABBREV_BUFFER, DWARF_LINE_BUFFER, DWARF_STR_BUFFER)
	(DWARF_MACINFO_BUFFER, DWARF_RANGES_BUFFER, DWARF_LOC_BUFFER):
	Remove macros.
	(dwarf2_has_info): Take an objfile argument.  Allocate per-objfile
	data.
	(dwarf2_build_psymtabs_hard): Remove use of removed macros.  Fetch
	cu_tree from dwarf2_per_objfile.
	(create_comp_unit_tree): Save cu_tree in dwarf2_per_objfile.
	(psymtab_to_symtab_1): Restore per-objfile data pointer.  Remove use
	of removed macros.
	(dwarf2_find_containing_comp_unit): Fetch cu_tree from
	dwarf2_per_objfile.
	(_initialize_dwarf2_read): Register dwarf2_per_objfile_data instead
	of dwarf2_cu_tree.
	* symfile.h (dwarf2_has_info): Update prototype.
	* coffread.c (coff_symfile_read): Update call to dwarf2_has_info.
	* elfread.c (elf_symfile_read): Likewise.
@
text
@d637 1
a637 1
  if (dwarf2_has_info (objfile))
@


1.52.2.2
log
@Merge mainline to intercu branch.
@
text
@d1365 1
a1365 4
  /* If the line number table is full (e.g. 64K lines in COFF debug
     info), the next function's L_LNNO32 might not be zero, so don't
     overstep the table's end in any case.  */
  while (rawptr <= &linetab[0] + linetab_size)
d1369 1
a1369 2
      /* The next function, or the sentinel, will have L_LNNO32 zero;
	 we exit. */
@


1.52.2.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d388 7
d447 1
a447 1
    xmalloc (sizeof (struct dbx_symfile_info));
d453 2
a454 1
  objfile->sym_private = xmalloc (sizeof (struct coff_symfile_info));
a612 9
  /* If we are reinitializing, or if we have not loaded syms yet,
     empty the psymtab.  "mainline" is cleared so the *_read_psymtab
     functions do not all re-initialize it.  */
  if (mainline)
    {
      init_psymbol_list (objfile, 0);
      mainline = 0;
    }

a642 2
  dwarf2_build_frame_info (objfile);

d661 1
a661 1
      xfree (objfile->sym_private);
@


1.51
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@a37 2

#include "symfile.h"
@


1.50
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003
d1471 1
a1471 1
  = (struct symbol *) obstack_alloc (&objfile->symbol_obstack,
d1966 1
a1966 1
			  &current_objfile->symbol_obstack);
d1985 1
a1985 1
			  &current_objfile->symbol_obstack);
d2052 1
a2052 1
	    (&current_objfile->symbol_obstack,
d2058 1
a2058 1
			  &current_objfile->symbol_obstack);
@


1.49
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d205 1
a205 1
  if (STREQ (name, ".text"))
d214 1
a214 1
  else if (STREQ (name, ".stabstr"))
d822 1
a822 1
	      if (STREQ (cs->c_name, ".text"))
d947 1
a947 1
	  if (STREQ (cs->c_name, ".bf"))
d969 1
a969 1
	  else if (STREQ (cs->c_name, ".ef"))
d1045 1
a1045 1
	  if (STREQ (cs->c_name, ".bb"))
d1051 1
a1051 1
	  else if (STREQ (cs->c_name, ".eb"))
@


1.48
log
@2003-11-05  Andrew Cagney  <cagney@@redhat.com>

	* xcoffread.c (find_linenos): Replace "sec_ptr" and "bfd" with
	"struct bfd_section" and "struct bfd".
	* target.h (struct section_table): Ditto.
	* rs6000-nat.c (xcoff_relocate_core): Ditto.
	* solib-svr4.c (elf_locate_base): Ditto.
	* pa64solib.c (dld_cache_t): Ditto.
	* objfiles.h (struct obj_section): Ditto.
	* objfiles.c (add_to_objfile_sections): Ditto.
	* exec.c (bfdsec_to_vmap): Ditto.
	(add_to_section_table): Ditto.
	(build_section_table): Ditto.
	* corelow.c (get_core_register_section): Ditto.
	* coffread.c (find_linenos): Ditto.
	* elfread.c (elf_interpreter): Delete #if0'd function.

	* mips-tdep.c (mips_dump_tdep): Delete code prinint VX_NUM_REGS.
	* config/sparc/tm-vxsparc.h (VX_NUM_REGS): Delete macro.
	* config/mips/tm-vxmips.h (VX_NUM_REGS): Delete macro.
	* config/m68k/tm-vx68.h (VX_NUM_REGS): Delete macro.

	* arch-utils.h (generic_cannot_extract_struct_value_address):
	Delete declaration.
	* wince.c (_initialize_wince): Fix multi-line string.
	* ia64-tdep.c (floatformat_valid): Convert to ISO C.
@
text
@d1433 1
a1433 1
		  STREQ (name + 1, DEPRECATED_SYMBOL_NAME (sym) + 1))
@


1.47
log
@2003-11-05 Elena Zannoni  <ezannoni@@redhat.com>

       * coffread.c (coff_symtab_read): Remove passing of info parameter
       to prim_record_minimal_symbol_and_info.
@
text
@d473 1
a473 1
find_linenos (bfd *abfd, sec_ptr asect, void *vpinfo)
@


1.46
log
@2003-11-05  Elena Zannoni  <ezannoni@@redhat.com>

       * coffread.c (process_coff_symbol): Delete CXUX_TARGET macro use.
       (decode_base_type): Delete ifdeffed out code.
@
text
@a928 7

 		/* FIXME: cagney/2001-02-01: The nasty (int) -> (long)
                   -> (void*) cast is to ensure that that the value of
                   cs->c_sclass can be correctly stored in a void
                   pointer in MSYMBOL_INFO.  Better solutions
                   welcome. */
		gdb_assert (sizeof (void *) >= sizeof (cs->c_sclass));
d930 1
a930 1
		  (cs->c_name, tmpaddr, ms_type, (void *) (long) cs->c_sclass,
@


1.45
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@a1643 5
#ifdef CXUX_TARGET
	  /* Ignore vendor section for Harris CX/UX targets. */
	  else if (cs->c_name[0] == '$')
	    break;
#endif /* CXUX_TARGET */
a1794 9

#if 0
/* DGUX actually defines both T_ARG and T_VOID to the same value.  */
#ifdef T_ARG
    case T_ARG:
      /* Shows up in DGUX, I think.  Not sure where.  */
      return lookup_fundamental_type (current_objfile, FT_VOID);	/* shouldn't show up here */
#endif
#endif /* 0 */
@


1.44
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@a471 1
/* ARGSUSED */
a507 1
/* ARGSUSED */
a2036 1
/* ARGSUSED */
@


1.43
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d316 1
a316 1
coff_lookup_type (register int index)
d1122 3
a1124 3
read_one_sym (register struct coff_symbol *cs,
	      register struct internal_syment *sym,
	      register union internal_auxent *aux)
d1351 2
a1352 2
enter_linenos (long file_offset, register int first_line,
	       register int last_line, struct objfile *objfile)
d1434 3
a1436 3
	  register char *name = DEPRECATED_SYMBOL_NAME (real_sym);
	  register int hash = hashname (name);
	  register struct symbol *sym, *prev;
d1475 2
a1476 2
process_coff_symbol (register struct coff_symbol *cs,
		     register union internal_auxent *aux,
d1662 1
a1662 1
	      register int i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d1699 2
a1700 2
decode_type (register struct coff_symbol *cs, unsigned int c_type,
	     register union internal_auxent *aux)
d1721 1
a1721 1
	  register unsigned short *dim;
d1780 2
a1781 2
decode_function_type (register struct coff_symbol *cs, unsigned int c_type,
		      register union internal_auxent *aux)
d1792 2
a1793 2
decode_base_type (register struct coff_symbol *cs, unsigned int c_type,
		  register union internal_auxent *aux)
@


1.42
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d200 1
a200 1
  register struct coff_symfile_info *csi;
d342 2
a343 2
  register struct type **type_addr = coff_lookup_type (index);
  register struct type *type = *type_addr;
d518 1
a518 1
  register int val;
d682 1
a682 1
  register struct context_stack *new;
d684 1
a684 1
  register struct coff_symbol *cs = &coff_symbol;
d1273 1
a1273 1
  register char *temp;
d1354 1
a1354 1
  register char *rawptr;
d1393 2
a1394 2
  register struct type *target = TYPE_TARGET_TYPE (type);
  register struct type *real_target = TYPE_TARGET_TYPE (real_type);
d1417 1
a1417 1
  register struct block *b;
d1419 1
a1419 1
  register struct symbol *real_sym;
d1479 1
a1479 1
  register struct symbol *sym
d1702 1
a1702 1
  register struct type *type = 0;
d1952 2
a1953 2
  register struct type *type;
  register struct nextfield *list = 0;
d1956 1
a1956 1
  register int n;
d1959 1
a1959 1
  register struct coff_symbol *ms = &member_sym;
d2043 2
a2044 2
  register struct symbol *sym;
  register struct type *type;
d2049 1
a2049 1
  register struct coff_symbol *ms = &member_sym;
d2054 1
a2054 1
  register int n;
@


1.41
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@d394 2
a395 2
      current_objfile->ei.entry_file_lowpc = current_source_start_addr;
      current_objfile->ei.entry_file_highpc = current_source_end_addr;
@


1.40
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* block.h (BLOCK_SHOULD_SORT): Delete.
	* symtab.c (lookup_block_symbol): Don't worry about sorted linear
	blocks.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Ditto.
	* symfile.h: Delete sort_symtabs_syms and sort_block_syms
	declarations.
	* coffread.c (coff_symfile_read): Don't call sort_symtab_syms.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
@
text
@d48 1
d1418 1
a1418 1
  register int i;
d1423 1
a1423 1
  ALL_BLOCK_SYMBOLS (b, i, real_sym)
@


1.39
log
@2003-05-23  Raoul Gough  <RaoulGough@@yahoo.co.uk>

	Committed by Elena Zannoni  <ezannoni@@redhat.com>.
  	* coffread.c(coff_symtab_read): Do relocate static symbols from PE
	files, don't relocate absolute symbols (and do use mst_abs).
@
text
@a607 9
  /* Sort symbols alphabetically within each block.  */

  {
    struct symtab *s;

    for (s = objfile->symtabs; s != NULL; s = s->next)
      sort_symtab_syms (s);
  }

@


1.38
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@a871 1
	    /* FIXME: should use mst_abs, and not relocate, if absolute.  */
d893 8
d905 5
a909 2
		if (cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXTFUNC
		    || cs->c_sclass == C_THUMBEXT)
@


1.37
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d1428 1
a1428 1
	  SYMBOL_NAMESPACE (real_sym) == VAR_NAMESPACE &&
d1490 1
a1490 1
  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1612 1
a1612 1
	  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1672 1
a1672 1
	  SYMBOL_NAMESPACE (sym) = STRUCT_NAMESPACE;
d2082 1
a2082 1
	  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
@


1.37.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1428 1
a1428 1
	  SYMBOL_DOMAIN (real_sym) == VAR_DOMAIN &&
d1490 1
a1490 1
  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1612 1
a1612 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1672 1
a1672 1
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d2082 1
a2082 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
@


1.36
log
@	* coffread.c (coff_symfile_read): Clean up minimal symbols earlier.
	* dbxread.c (elfstab_build_psymtabs): Don't call
	install_minimal_symbols.
	(stabsect_build_psymtabs): Likewise.
	* elfread.c (elf_symfile_read): Call install_minimal_symbols
	earlier.
	* somread.c (som_symfile_read): Call install_minimal_symbols
	and do_cleanups earlier.
	* nlmread.c (nlm_symfile_read): Likewise.
	* mdebugread.c (elfmdebug_build_psymtabs): Call
	install_minimal_symbols and make appropriate cleanups.
@
text
@d1432 1
a1432 1
	  register char *name = SYMBOL_NAME (real_sym);
d1439 2
a1440 2
	      if (name[0] == SYMBOL_NAME (sym)[0] &&
		  STREQ (name + 1, SYMBOL_NAME (sym) + 1))
d1642 1
a1642 1
		  concat (SYMBOL_NAME (sym), NULL);
d1660 1
a1660 1
	      register int i = hashname (SYMBOL_NAME (sym));
d1678 3
a1680 3
	    if (SYMBOL_NAME (sym) != NULL
		&& *SYMBOL_NAME (sym) != '~'
		&& *SYMBOL_NAME (sym) != '.')
d1682 1
a1682 1
		concat (SYMBOL_NAME (sym), NULL);
d2078 1
a2078 1
	  SYMBOL_NAME (sym) =
d2126 1
a2126 1
	  TYPE_FIELD_NAME (type, n) = SYMBOL_NAME (xsym);
@


1.35
log
@* coff-pe-read.c: New file - support reading of minimal symbols from a portable
executable using the export table.
* coff-pe-read.h: New file.
* coffread.c: Include coff-pe-read.h.
(coff_symtab_read): Call read_pe_exported_syms iff no recognized debugging
symbols found.
* Makefile.in (SFILES): Add coff-pe-read.o.
(coff_pe_read_h): Define.
(COMMON_OBS): Add coff-pe-read.o.
(coffread.o): Add coff_pe_read_h dependency.
(coff-pe-read.o): New target.
@
text
@d521 1
a521 1
  struct cleanup *back_to;
d601 1
a601 1
  make_cleanup_discard_minimal_symbols ();
d621 3
@


1.34
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d49 2
d1090 7
@


1.33
log
@	* defs.h (streq): Add prototype.
	* utils.c (streq): New function.

	* dwarf2read.c (new_symbol): Use SYMBOL_SET_NAMES instead of
	SYMBOL_NAME and SYMBOL_INIT_DEMANGLED_NAME.
	* mdebugread.c (new_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* dwarfread.c (new_symbol): Likewise.

	* minsyms.c (prim_record_minimal_symbol_and_info): Use
	SYMBOL_SET_NAMES instead of setting SYMBOL_NAME.  Set the language
	here.
	(install_minimal_symbols): Don't set SYMBOL_LANGUAGE or call
	SYMBOL_INIT_DEMANGLED_NAME.
	* objfiles.c: Include "hashtab.h".
	(allocate_objfile): Call htab_set_functions_ex for the
	demangled_names_hash.
	(free_objfile): Call htab_delete for the demangled_names_hash.
	* objfiles.h (struct htab): Add declaration.
	(struct objfile): Add demangled_names_hash.
	* symfile.c: Include "hashtab.h".
	(reread_symbols): Call htab_delete for the demangled_names_hash.
	(add_psymbol_to_list): Use SYMBOL_SET_NAMES instead of putting
	SYMBOL_NAME in the bcache.
	* symtab.c: Include "hashtab.h".  Update comments.
	(create_demangled_names_hash, symbol_set_names): New functions.
	(symbol_find_demangled_name): New function, broken out from
	symbol_init_demangled_names.
	(symbol_init_demangled_names): Use it.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Add missing parentheses.
	(SYMBOL_SET_NAMES): New macro.
	(symbol_set_names): Add prototype.
@
text
@d47 1
@


1.32
log
@Replace complain() with complaint().
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002
a1471 2
  SYMBOL_NAME (sym) = obsavestring (name, strlen (name),
				    &objfile->symbol_obstack);
d1473 1
a1473 1
  SYMBOL_INIT_DEMANGLED_NAME (sym, &objfile->symbol_obstack);
@


1.31
log
@	* gdbtypes.h (struct main_type): Move artificial flag out of
	loc.  New member of ``struct field'' named static_kind.  Reduce
	overloaded meaning of bitsize.
	(FIELD_ARTIFICIAL, SET_FIELD_PHYSNAME, SET_FIELD_PHYSADDR)
	(TYPE_FIELD_STATIC, TYPE_FIELD_STATIC_HAS_ADDR): Likewise.
	(FIELD_STATIC_KIND, TYPE_FIELD_STATIC_KIND): New macros.

	* ada-lang.c (fill_in_ada_prototype): Initialize static_kind for
	new fields.
	(template_to_fixed_record_type, template_to_static_fixed_type)
	(to_record_with_fixed_variant_part): Likewise.
	* coffread.c (coff_read_struct_type, coff_read_enum_type): Likewise.
	* dwarf2read.c (dwarf2_add_field, read_enumeration): Likewise.
	* dwarfread.c (struct_type, enum_type): Likewise.
	* hpread.c (hpread_read_enum_type)
	(hpread_read_function_type, hpread_read_doc_function_type)
	(hpread_read_struct_type): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
@
text
@a124 35
/* Complaints about various problems in the file being read  */

struct deprecated_complaint ef_complaint =
{"Unmatched .ef symbol(s) ignored starting at symnum %d", 0, 0};

struct deprecated_complaint ef_stack_complaint =
{"`.ef' symbol without matching `.bf' symbol ignored starting at symnum %d", 0, 0};

struct deprecated_complaint eb_stack_complaint =
{"`.eb' symbol without matching `.bb' symbol ignored starting at symnum %d", 0, 0};

struct deprecated_complaint bf_no_aux_complaint =
{"`.bf' symbol %d has no aux entry", 0, 0};

struct deprecated_complaint ef_no_aux_complaint =
{"`.ef' symbol %d has no aux entry", 0, 0};

struct deprecated_complaint lineno_complaint =
{"Line number pointer %d lower than start of line numbers", 0, 0};

struct deprecated_complaint unexpected_type_complaint =
{"Unexpected type for symbol %s", 0, 0};

struct deprecated_complaint bad_sclass_complaint =
{"Bad n_sclass for symbol %s", 0, 0};

struct deprecated_complaint misordered_blocks_complaint =
{"Blocks out of order at address %x", 0, 0};

struct deprecated_complaint tagndx_bad_complaint =
{"Symbol table entry for %s has bad tagndx value", 0, 0};

struct deprecated_complaint eb_complaint =
{"Mismatched .eb symbol ignored starting at symnum %d", 0, 0};

d789 2
a790 1
	  complain (&bad_sclass_complaint, cs->c_name);
d956 2
a957 1
		complain (&bf_no_aux_complaint, cs->c_symnum);
d981 3
a983 1
		  complain (&ef_stack_complaint, cs->c_symnum);
d992 3
a994 1
		  complain (&ef_complaint, cs->c_symnum);
d1000 2
a1001 1
		  complain (&ef_no_aux_complaint, cs->c_symnum);
d1056 3
a1058 1
		  complain (&eb_stack_complaint, cs->c_symnum);
d1065 3
a1067 1
		  complain (&eb_complaint, symnum);
d1346 3
a1348 1
      complain (&lineno_complaint, file_offset);
d1753 3
a1755 1
	  complain (&tagndx_bad_complaint, cs->c_name);
d1921 1
a1921 1
  complain (&unexpected_type_complaint, cs->c_name);
@


1.30
log
@2002-10-25  Andrew Cagney  <cagney@@redhat.com>

	* complaints.h (struct deprecated_complaint): Rename `struct
	complaint'.
	* complaints.c (complain): Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Delete
	incorrect comment indicating that "symfile.h" was being included
	for the `struct complaint' definition.
	* remote-vx.c: Update.
	* objc-lang.c: Update.
	* xcoffread.c: Update.
	* hpread.c: Update.
	* mdebugread.c: Update.
	* stabsread.c: Update.
	* dwarf2read.c: Update.
	* dwarfread.c: Update.
	* elfread.c: Update.
	* coffread.c: Update.
	* stabsread.h: Update.
	* dbxread.c: Update.
	* buildsym.c: Update.
	* gdbtypes.c: Update.
	* macrotab.c: Update.
@
text
@d2000 1
d2019 1
d2140 1
@


1.29
log
@* coffread.c (coff_symfile_read): Don't try to read the line
number table from disk if the image file doesn't have a symbol
table; we'll never actually look at the info anyway, and Windows
ships DLL's with bogus file offsets for the line number data.
@
text
@d127 1
a127 1
struct complaint ef_complaint =
d130 1
a130 1
struct complaint ef_stack_complaint =
d133 1
a133 1
struct complaint eb_stack_complaint =
d136 1
a136 1
struct complaint bf_no_aux_complaint =
d139 1
a139 1
struct complaint ef_no_aux_complaint =
d142 1
a142 1
struct complaint lineno_complaint =
d145 1
a145 1
struct complaint unexpected_type_complaint =
d148 1
a148 1
struct complaint bad_sclass_complaint =
d151 1
a151 1
struct complaint misordered_blocks_complaint =
d154 1
a154 1
struct complaint tagndx_bad_complaint =
d157 1
a157 1
struct complaint eb_complaint =
@


1.29.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003
a46 4
#include "block.h"
#include "dictionary.h"

#include "coff-pe-read.h"
d125 35
d231 1
a231 1
  struct coff_symfile_info *csi;
d236 1
a236 1
  if (DEPRECATED_STREQ (name, ".text"))
d245 1
a245 1
  else if (DEPRECATED_STREQ (name, ".stabstr"))
d347 1
a347 1
coff_lookup_type (int index)
d373 2
a374 2
  struct type **type_addr = coff_lookup_type (index);
  struct type *type = *type_addr;
d425 2
a426 2
      current_objfile->ei.deprecated_entry_file_lowpc = current_source_start_addr;
      current_objfile->ei.deprecated_entry_file_highpc = current_source_end_addr;
d503 1
d505 1
a505 1
find_linenos (bfd *abfd, struct bfd_section *asect, void *vpinfo)
d540 1
d549 1
a549 1
  int val;
d553 1
a553 1
  struct cleanup *back_to, *cleanup_minimal_symbols;
d633 1
a633 1
  cleanup_minimal_symbols = make_cleanup_discard_minimal_symbols ();
d640 9
a653 3
  /* Free the installed minimal symbol data.  */
  do_cleanups (cleanup_minimal_symbols);

d719 1
a719 1
  struct context_stack *new;
d721 1
a721 1
  struct coff_symbol *cs = &coff_symbol;
d824 1
a824 2
	  complaint (&symfile_complaints, "Bad n_sclass for symbol %s",
		     cs->c_name);
d860 1
a860 1
	      if (DEPRECATED_STREQ (cs->c_name, ".text"))
d900 1
a921 8
 	    else if (cs->c_secnum == N_ABS)
 	      {
 		/* Use the correct minimal symbol type (and don't
 		   relocate) for absolute values. */
 		ms_type = mst_abs;
 		sec = cs_to_section (cs, objfile);
 		tmpaddr = cs->c_value;
 	      }
d926 2
a927 5
 		/* Statics in a PE file also get relocated */
 		if (cs->c_sclass == C_EXT
 		    || cs->c_sclass == C_THUMBEXTFUNC
 		    || cs->c_sclass == C_THUMBEXT
 		    || (pe_file && (cs->c_sclass == C_STAT)))
d957 7
d965 1
a965 1
		  (cs->c_name, tmpaddr, ms_type, NULL,
d982 1
a982 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bf"))
d990 1
a990 2
		complaint (&symfile_complaints,
			   "`.bf' symbol %d has no aux entry", cs->c_symnum);
d1003 1
a1003 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".ef"))
d1014 1
a1014 3
		  complaint (&symfile_complaints,
			     "`.ef' symbol without matching `.bf' symbol ignored starting at symnum %d",
			     cs->c_symnum);
d1023 1
a1023 3
		  complaint (&symfile_complaints,
			     "Unmatched .ef symbol(s) ignored starting at symnum %d",
			     cs->c_symnum);
d1029 1
a1029 2
		  complaint (&symfile_complaints,
			     "`.ef' symbol %d has no aux entry", cs->c_symnum);
d1074 1
a1074 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bb"))
d1080 1
a1080 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".eb"))
d1084 1
a1084 3
		  complaint (&symfile_complaints,
			     "`.eb' symbol without matching `.bb' symbol ignored starting at symnum %d",
			     cs->c_symnum);
d1091 1
a1091 3
		  complaint (&symfile_complaints,
			     "Mismatched .eb symbol ignored starting at symnum %d",
			     symnum);
a1112 7
  if ((nsyms == 0) && (pe_file))
    {
      /* We've got no debugging symbols, but it's is a portable
	 executable, so try to read the export table */
      read_pe_exported_syms (objfile);
    }

d1131 3
a1133 3
read_one_sym (struct coff_symbol *cs,
	      struct internal_syment *sym,
	      union internal_auxent *aux)
d1282 1
a1282 1
  char *temp;
d1360 2
a1361 2
enter_linenos (long file_offset, int first_line,
	       int last_line, struct objfile *objfile)
d1363 1
a1363 1
  char *rawptr;
d1370 1
a1370 3
      complaint (&symfile_complaints,
		 "Line number pointer %ld lower than start of line numbers",
		 file_offset);
d1400 2
a1401 2
  struct type *target = TYPE_TARGET_TYPE (type);
  struct type *real_target = TYPE_TARGET_TYPE (real_type);
d1424 3
a1426 3
  struct block *b;
  struct dict_iterator iter;
  struct symbol *real_sym;
d1430 1
a1430 1
  ALL_BLOCK_SYMBOLS (b, iter, real_sym)
d1437 1
a1437 1
	  SYMBOL_DOMAIN (real_sym) == VAR_DOMAIN &&
d1441 3
a1443 3
	  char *name = DEPRECATED_SYMBOL_NAME (real_sym);
	  int hash = hashname (name);
	  struct symbol *sym, *prev;
d1448 2
a1449 2
	      if (name[0] == DEPRECATED_SYMBOL_NAME (sym)[0] &&
		  strcmp (name + 1, DEPRECATED_SYMBOL_NAME (sym) + 1) == 0)
d1482 2
a1483 2
process_coff_symbol (struct coff_symbol *cs,
		     union internal_auxent *aux,
d1486 1
a1486 1
  struct symbol *sym
d1494 2
d1497 1
a1497 1
  SYMBOL_SET_NAMES (sym, name, strlen (name), objfile);
d1501 1
a1501 1
  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1623 1
a1623 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1653 1
a1653 1
		  concat (DEPRECATED_SYMBOL_NAME (sym), NULL);
d1655 5
d1671 1
a1671 1
	      int i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d1683 1
a1683 1
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d1689 3
a1691 3
	    if (DEPRECATED_SYMBOL_NAME (sym) != NULL
		&& *DEPRECATED_SYMBOL_NAME (sym) != '~'
		&& *DEPRECATED_SYMBOL_NAME (sym) != '.')
d1693 1
a1693 1
		concat (DEPRECATED_SYMBOL_NAME (sym), NULL);
d1708 2
a1709 2
decode_type (struct coff_symbol *cs, unsigned int c_type,
	     union internal_auxent *aux)
d1711 1
a1711 1
  struct type *type = 0;
d1730 1
a1730 1
	  unsigned short *dim;
d1775 1
a1775 3
	  complaint (&symfile_complaints,
		     "Symbol table entry for %s has bad tagndx value",
		     cs->c_name);
d1787 2
a1788 2
decode_function_type (struct coff_symbol *cs, unsigned int c_type,
		      union internal_auxent *aux)
d1799 2
a1800 2
decode_base_type (struct coff_symbol *cs, unsigned int c_type,
		  union internal_auxent *aux)
d1810 9
d1941 1
a1941 1
  complaint (&symfile_complaints, "Unexpected type for symbol %s", cs->c_name);
d1959 2
a1960 2
  struct type *type;
  struct nextfield *list = 0;
d1963 1
a1963 1
  int n;
d1966 1
a1966 1
  struct coff_symbol *ms = &member_sym;
a1999 1
	  FIELD_STATIC_KIND (list->field) = 0;
a2017 1
	  FIELD_STATIC_KIND (list->field) = 0;
d2044 1
d2048 2
a2049 2
  struct symbol *sym;
  struct type *type;
d2054 1
a2054 1
  struct coff_symbol *ms = &member_sym;
d2059 1
a2059 1
  int n;
d2085 1
a2085 1
	  DEPRECATED_SYMBOL_NAME (sym) =
d2089 1
a2089 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2133 1
a2133 1
	  TYPE_FIELD_NAME (type, n) = DEPRECATED_SYMBOL_NAME (xsym);
a2137 1
	  TYPE_FIELD_STATIC_KIND (type, n) = 0;
@


1.29.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d1471 1
a1471 1
  = (struct symbol *) obstack_alloc (&objfile->objfile_obstack,
d1966 1
a1966 1
			  &current_objfile->objfile_obstack);
d1985 1
a1985 1
			  &current_objfile->objfile_obstack);
d2052 1
a2052 1
	    (&current_objfile->objfile_obstack,
d2058 1
a2058 1
			  &current_objfile->objfile_obstack);
@


1.29.8.1
log
@2002-09-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Delete BLOCK_SHOULD_SORT.
	* symtab.c (lookup_block_symbol): Assume non-hashed blocks aren't
	sorted.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.h: Delete prototypes for sort_block_syms and
	sort_symtab_syms.
	* symfile.c: Delete functions sort_block_syms and
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Remove call to
	sort_symtab_syms.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.

2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (c-lang.o): Correct dependencies.
	(utils.o): Gather dependencies.
	(charset.o): Move.
@
text
@d640 9
@


1.29.8.2
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@a46 1
#include "dictionary.h"
d1416 1
a1416 1
  struct dict_iterator iter;
d1421 1
a1421 1
  ALL_BLOCK_SYMBOLS (b, iter, real_sym)
@


1.29.8.3
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a25 1
#include "block.h"
@


1.29.8.4
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d129 1
a129 1
struct deprecated_complaint ef_complaint =
d132 1
a132 1
struct deprecated_complaint ef_stack_complaint =
d135 1
a135 1
struct deprecated_complaint eb_stack_complaint =
d138 1
a138 1
struct deprecated_complaint bf_no_aux_complaint =
d141 1
a141 1
struct deprecated_complaint ef_no_aux_complaint =
d144 1
a144 1
struct deprecated_complaint lineno_complaint =
d147 1
a147 1
struct deprecated_complaint unexpected_type_complaint =
d150 1
a150 1
struct deprecated_complaint bad_sclass_complaint =
d153 1
a153 1
struct deprecated_complaint misordered_blocks_complaint =
d156 1
a156 1
struct deprecated_complaint tagndx_bad_complaint =
d159 1
a159 1
struct deprecated_complaint eb_complaint =
a1992 1
	  FIELD_STATIC_KIND (list->field) = 0;
a2010 1
	  FIELD_STATIC_KIND (list->field) = 0;
a2130 1
	  TYPE_FIELD_STATIC_KIND (type, n) = 0;
@


1.29.8.5
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d127 35
d817 1
a817 2
	  complaint (&symfile_complaints, "Bad n_sclass for symbol %s",
		     cs->c_name);
d983 1
a983 2
		complaint (&symfile_complaints,
			   "`.bf' symbol %d has no aux entry", cs->c_symnum);
d1007 1
a1007 3
		  complaint (&symfile_complaints,
			     "`.ef' symbol without matching `.bf' symbol ignored starting at symnum %d",
			     cs->c_symnum);
d1016 1
a1016 3
		  complaint (&symfile_complaints,
			     "Unmatched .ef symbol(s) ignored starting at symnum %d",
			     cs->c_symnum);
d1022 1
a1022 2
		  complaint (&symfile_complaints,
			     "`.ef' symbol %d has no aux entry", cs->c_symnum);
d1077 1
a1077 3
		  complaint (&symfile_complaints,
			     "`.eb' symbol without matching `.bb' symbol ignored starting at symnum %d",
			     cs->c_symnum);
d1084 1
a1084 3
		  complaint (&symfile_complaints,
			     "Mismatched .eb symbol ignored starting at symnum %d",
			     symnum);
d1363 1
a1363 3
      complaint (&symfile_complaints,
		 "Line number pointer %ld lower than start of line numbers",
		 file_offset);
d1768 1
a1768 3
	  complaint (&symfile_complaints,
		     "Symbol table entry for %s has bad tagndx value",
		     cs->c_name);
d1934 1
a1934 1
  complaint (&symfile_complaints, "Unexpected type for symbol %s", cs->c_name);
@


1.29.8.6
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003
d1465 2
d1468 1
a1468 1
  SYMBOL_SET_NAMES (sym, name, strlen (name), objfile);
@


1.29.8.7
log
@2003-02-21  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (locate_compound_sym): Update call to
	lookup_symbol_namespace.
	* symtab.c (make_symbol_overload_list): Delete namespace_len
	argument.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* valops.c (find_oload_champ_namespace_loop): New format for
	make_symbol_overload_list.
	* symtab.c (lookup_symbol_namespace): Delete namespace_len
	argument.
	(lookup_symbol_aux_using_loop): Update call to
	lookup_symbol_namespace.
	(make_symbol_overload_list_using): Delete namespace_len argument.
	* linespec.c (decode_namespace): Update call to
	lookup_symbol_namespace.
	* valops.c (value_namespace_elt): Ditto.
	* symtab.c (lookup_nested_type): Ditto.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* block.c (block_all_usings): Delete.
	(block_using): Make static.
	(block_using_iterator_next): New using_direct format.
	(block_using_iterator_first): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Rename variables.
	(add_using_directive): New using functions.
	(end_symtab): Use cp_copy_usings.
	(copy_usings_to_obstack): Delete.
	* block.c: Tweak initial comment.
	(struct namespace_info): Move here.
	(block_initialize_namespace): Set scope to NULL!
	* block.h: Add compilation guards.
	Reorder and update declarations.
	* cp-support.c (cp_find_first_component): Return unsigned int.
	(cp_entire_prefix_len): New.
	(cp_add_using_obstack): Delete.
	(cp_add_using_xmalloc): Delete.
	(cp_copy_usings): Rewrite.
	(cp_free_usings): Delete.
	(cp_add_using): New.
	(cp_is_anonymous): Delete second argument.
	(xstrndup): New.
	* cp-support.h: Add compilation guards.
	Update declarations.
	* coffread.c: New variable coff_source_file.
	(coff_start_symtab): Use coff_source_file.
	(complete_symtab): Ditto.
	(coff_end_symtab): Ditto.
	(coff_symtab_read): Ditto.
	* dbxread.c (find_stab_function_addr): Const fix.
	* buildsym.h: Const fix.
	* buildsym.c (start_symtab): Const fix.
	(start_subfile): Ditto.
	* cp-support.c (cp_add_using_xmalloc): Copy name.
	* dwarf2read.c (read_namespace): Loop through extensions
	correctly.
	(read_file_scope): Const fix.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(read_typedef): Ditto.
	* buildsym.c (finish_block): Update comments and simplify code
	when setting scope.
	* buildsym.h: Add opaque declaration of 'struct block'.
	Change comment before processing_current_prefix.
	* arm-tdep.c (arm_gdbarch_init): Add break; after default:.
@
text
@a139 4
/* When starting a symtab, this is the file name.  */

static char *coff_source_file;

d361 1
d366 1
a366 3
  coff_source_file = savestring (name, strlen (name));

  start_symtab (coff_source_file,
d383 3
a385 4
  if (coff_source_file != NULL)
    xfree (coff_source_file);
  coff_source_file = savestring (name, strlen (name));
  last_source_file = coff_source_file;
a415 1
  coff_source_file = NULL;
a724 1
  coff_source_file = NULL;
@


1.29.8.8
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d26 1
a47 3
#include "block.h"

#include "coff-pe-read.h"
d527 1
a527 1
  struct cleanup *back_to, *cleanup_minimal_symbols;
d607 1
a607 1
  cleanup_minimal_symbols = make_cleanup_discard_minimal_symbols ();
a618 3
  /* Free the installed minimal symbol data.  */
  do_cleanups (cleanup_minimal_symbols);

a1089 7
  if ((nsyms == 0) && (pe_file))
    {
      /* We've got no debugging symbols, but it's is a portable
	 executable, so try to read the export table */
      read_pe_exported_syms (objfile);
    }

d1420 1
a1420 1
	  register char *name = DEPRECATED_SYMBOL_NAME (real_sym);
d1427 2
a1428 2
	      if (name[0] == DEPRECATED_SYMBOL_NAME (sym)[0] &&
		  STREQ (name + 1, DEPRECATED_SYMBOL_NAME (sym) + 1))
d1630 1
a1630 1
		  concat (DEPRECATED_SYMBOL_NAME (sym), NULL);
d1648 1
a1648 1
	      register int i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d1666 3
a1668 3
	    if (DEPRECATED_SYMBOL_NAME (sym) != NULL
		&& *DEPRECATED_SYMBOL_NAME (sym) != '~'
		&& *DEPRECATED_SYMBOL_NAME (sym) != '.')
d1670 1
a1670 1
		concat (DEPRECATED_SYMBOL_NAME (sym), NULL);
d2066 1
a2066 1
	  DEPRECATED_SYMBOL_NAME (sym) =
d2114 1
a2114 1
	  TYPE_FIELD_NAME (type, n) = DEPRECATED_SYMBOL_NAME (xsym);
@


1.29.8.9
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1428 1
a1428 1
	  SYMBOL_DOMAIN (real_sym) == VAR_DOMAIN &&
d1490 1
a1490 1
  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1612 1
a1612 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1672 1
a1672 1
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d2082 1
a2082 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
@


1.29.8.10
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a47 1
#include "dictionary.h"
d872 1
a893 8
 	    else if (cs->c_secnum == N_ABS)
 	      {
 		/* Use the correct minimal symbol type (and don't
 		   relocate) for absolute values. */
 		ms_type = mst_abs;
 		sec = cs_to_section (cs, objfile);
 		tmpaddr = cs->c_value;
 	      }
d898 2
a899 5
 		/* Statics in a PE file also get relocated */
 		if (cs->c_sclass == C_EXT
 		    || cs->c_sclass == C_THUMBEXTFUNC
 		    || cs->c_sclass == C_THUMBEXT
 		    || (pe_file && (cs->c_sclass == C_STAT)))
@


1.29.8.11
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d205 1
a205 1
  struct coff_symfile_info *csi;
d321 1
a321 1
coff_lookup_type (int index)
d347 2
a348 2
  struct type **type_addr = coff_lookup_type (index);
  struct type *type = *type_addr;
d401 2
a402 2
      current_objfile->ei.deprecated_entry_file_lowpc = current_source_start_addr;
      current_objfile->ei.deprecated_entry_file_highpc = current_source_end_addr;
d526 1
a526 1
  int val;
d690 1
a690 1
  struct context_stack *new;
d692 1
a692 1
  struct coff_symbol *cs = &coff_symbol;
d1131 3
a1133 3
read_one_sym (struct coff_symbol *cs,
	      struct internal_syment *sym,
	      union internal_auxent *aux)
d1282 1
a1282 1
  char *temp;
d1360 2
a1361 2
enter_linenos (long file_offset, int first_line,
	       int last_line, struct objfile *objfile)
d1363 1
a1363 1
  char *rawptr;
d1402 2
a1403 2
  struct type *target = TYPE_TARGET_TYPE (type);
  struct type *real_target = TYPE_TARGET_TYPE (real_type);
d1426 1
a1426 1
  struct block *b;
d1428 1
a1428 1
  struct symbol *real_sym;
d1443 3
a1445 3
	  char *name = DEPRECATED_SYMBOL_NAME (real_sym);
	  int hash = hashname (name);
	  struct symbol *sym, *prev;
d1484 2
a1485 2
process_coff_symbol (struct coff_symbol *cs,
		     union internal_auxent *aux,
d1488 1
a1488 1
  struct symbol *sym
d1671 1
a1671 1
	      int i = hashname (DEPRECATED_SYMBOL_NAME (sym));
d1708 2
a1709 2
decode_type (struct coff_symbol *cs, unsigned int c_type,
	     union internal_auxent *aux)
d1711 1
a1711 1
  struct type *type = 0;
d1730 1
a1730 1
	  unsigned short *dim;
d1789 2
a1790 2
decode_function_type (struct coff_symbol *cs, unsigned int c_type,
		      union internal_auxent *aux)
d1801 2
a1802 2
decode_base_type (struct coff_symbol *cs, unsigned int c_type,
		  union internal_auxent *aux)
d1961 2
a1962 2
  struct type *type;
  struct nextfield *list = 0;
d1965 1
a1965 1
  int n;
d1968 1
a1968 1
  struct coff_symbol *ms = &member_sym;
d2052 2
a2053 2
  struct symbol *sym;
  struct type *type;
d2058 1
a2058 1
  struct coff_symbol *ms = &member_sym;
d2063 1
a2063 1
  int n;
@


1.29.8.12
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d480 1
d482 1
a482 1
find_linenos (bfd *abfd, struct bfd_section *asect, void *vpinfo)
d517 1
d940 7
d948 1
a948 1
		  (cs->c_name, tmpaddr, ms_type, NULL,
d1451 1
a1451 1
		  strcmp (name + 1, DEPRECATED_SYMBOL_NAME (sym) + 1) == 0)
d1655 5
d1812 9
d2048 1
@


1.29.8.13
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d210 1
a210 1
  if (DEPRECATED_STREQ (name, ".text"))
d219 1
a219 1
  else if (DEPRECATED_STREQ (name, ".stabstr"))
d831 1
a831 1
	      if (DEPRECATED_STREQ (cs->c_name, ".text"))
d956 1
a956 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bf"))
d978 1
a978 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".ef"))
d1054 1
a1054 1
	  if (DEPRECATED_STREQ (cs->c_name, ".bb"))
d1060 1
a1060 1
	  else if (DEPRECATED_STREQ (cs->c_name, ".eb"))
@


1.28
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@a595 1
  /* Read the line number table, all at once.  */
a597 1
  bfd_map_over_sections (abfd, find_linenos, (void *) info);
d599 25
a623 5
  make_cleanup (free_linetab_cleanup, 0 /*ignore*/);
  val = init_lineno (abfd, info->min_lineno_offset,
		     info->max_lineno_offset - info->min_lineno_offset);
  if (val < 0)
    error ("\"%s\": error reading line numbers\n", name);
@


1.27
log
@2002-07-11  Daniel Jacobowitz  <drow@@mvista.com>

	Based on patch from Daniel Berlin <dberlin@@dberlin.org>.
	* buildsym.c: Include "demangle.h" for SYMBOL_INIT_DEMANGLED_NAME.
	(finish_block) For non-function blocks, hash the symbol table.  For
	function blocks, mark the symbol table as unhashed.
	* minsyms.c (msymbol_hash): Return hash value without taking modulus.
	(msymbol_hash_iw): Likewise.
	(add_minsym_to_hash_table): Take modulus of msymbol_hash's return
	value.
	(add_minsym_to_demangled_hash_table): Likewise for msymbol_hash_iw.
	(lookup_minimal_symbol): Likewise for both.
	* symtab.h (struct block): Add `hashtable' flag.  Comment the
	hashtable.
	(BLOCK_HASHTABLE, BLOCK_BUCKETS, BLOCK_BUCKET): New macro.
	(ALL_BLOCK_SYMBOLS): Update.
	(BLOCK_SHOULD_SORT): Do not sort hashed blocks.
	(struct symbol): Add `hash_next' pointer.
	* symtab.c (lookup_block_symbol): Search using the hash table when
	possible.
	(find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
	(search_symbols, find_addr_symbol): Likewise.

	* dstread.c (process_dst_block): Clear hashtable bit for new block.
	(read_dst_symtab): Likewise.
	* jv-lang.c (get_java_class_symtab): Likewise.
	* mdebugread.c: Include "gdb_assert.h".
	(shrink_block): Assert that the block being modified is not hashed.
	* coffread.c (patch_opaque_types): Use ALL_BLOCK_SYMBOLS.
	* symmisc.c (free_symtab_block): Walk the hash table when freeing
	symbols.
	(dump_symtab): Recognize hashed blocks.
	* printcmd.c (print_frame_args):  Assert that function blocks do not
	have hashed symbol tables.
	* ada-lang.c (symtab_for_sym): Use ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Likewise.
	(ada_add_block_symbols): Use ALL_BLOCK_SYMBOLS.  Handle hash tables.
@
text
@d31 1
a31 1
#include "obstack.h"
@


1.26
log
@* coffread.c: Remove redundant static declarations.  Replace
occurrences of `PTR' with `void *'.
* elfread.c, mdebugread.c, minsyms.c, mipsread.c: Likewise.
* top.h (quit_cover): Likewise.
* defs.h (catch_errors): Likewise.
@
text
@d1412 1
a1412 1
  for (i = BLOCK_NSYMS (b) - 1; i >= 0; i--)
a1417 1
      real_sym = BLOCK_SYM (b, i);
@


1.26.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1412 1
a1412 1
  ALL_BLOCK_SYMBOLS (b, i, real_sym)
d1418 1
@


1.26.6.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d31 1
a31 1
#include "gdb_obstack.h"
@


1.26.6.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d596 1
d599 1
d601 5
a605 25
  /* Only read line number information if we have symbols.

     On Windows NT, some of the system's DLL's have sections with
     PointerToLinenumbers fields that are non-zero, but point at
     random places within the image file.  (In the case I found,
     KERNEL32.DLL's .text section has a line number info pointer that
     points into the middle of the string `lib\\i386\kernel32.dll'.)

     However, these DLL's also have no symbols.  The line number
     tables are meaningless without symbols.  And in fact, GDB never
     uses the line number information unless there are symbols.  So we
     can avoid spurious error messages (and maybe run a little
     faster!) by not even reading the line number table unless we have
     symbols.  */
  if (num_symbols > 0)
    {
      /* Read the line number table, all at once.  */
      bfd_map_over_sections (abfd, find_linenos, (void *) info);

      make_cleanup (free_linetab_cleanup, 0 /*ignore*/);
      val = init_lineno (abfd, info->min_lineno_offset,
                         info->max_lineno_offset - info->min_lineno_offset);
      if (val < 0)
        error ("\"%s\": error reading line numbers\n", name);
    }
@


1.26.6.4
log
@merge from mainline
@
text
@d127 1
a127 1
struct deprecated_complaint ef_complaint =
d130 1
a130 1
struct deprecated_complaint ef_stack_complaint =
d133 1
a133 1
struct deprecated_complaint eb_stack_complaint =
d136 1
a136 1
struct deprecated_complaint bf_no_aux_complaint =
d139 1
a139 1
struct deprecated_complaint ef_no_aux_complaint =
d142 1
a142 1
struct deprecated_complaint lineno_complaint =
d145 1
a145 1
struct deprecated_complaint unexpected_type_complaint =
d148 1
a148 1
struct deprecated_complaint bad_sclass_complaint =
d151 1
a151 1
struct deprecated_complaint misordered_blocks_complaint =
d154 1
a154 1
struct deprecated_complaint tagndx_bad_complaint =
d157 1
a157 1
struct deprecated_complaint eb_complaint =
@


1.25
log
@2002-02-04  Elena Zannoni  <ezannoni@@redhat.com>

	* gdbarch.sh: Add definitions for COFF_MAKE_MSYMBOL_SPECIAL and
	ELF_MAKE_MSYMBOL_SPECIAL.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (default_elf_make_msymbol_special,
        default_coff_make_msymbol_special): New functions.
	* arch-utils.h (default_elf_make_msymbol_special,
        default_coff_make_msymbol_special): Export.
	* elfread.c (elf_symtab_read): Compile use of
	ELF_MAKE_MSYMBOL_SPECIAL unconditionally because it is now
	multiarched.
	* coffread.c (coff_symtab_read): Ditto, for
	COFF_MAKE_MSYMBOL_SPECIAL.
@
text
@a194 2
static void patch_type (struct type *, struct type *);

a216 26

static void find_linenos (bfd *, sec_ptr, PTR);

static void coff_symfile_init (struct objfile *);

static void coff_new_init (struct objfile *);

static void coff_symfile_read (struct objfile *, int);

static void coff_symfile_finish (struct objfile *);

static void record_minimal_symbol (char *, CORE_ADDR,
				   enum minimal_symbol_type,
				   struct objfile *);

static void coff_end_symtab (struct objfile *);

static void complete_symtab (char *, CORE_ADDR, unsigned int);

static void coff_start_symtab (char *);

static struct type *coff_alloc_type (int);

static struct type **coff_lookup_type (int);

static void coff_locate_sections (bfd *, asection *, PTR);
d229 1
a229 1
coff_locate_sections (bfd *abfd, asection *sectp, PTR csip)
a286 2
static void find_targ_sec (bfd *, asection *, PTR);

d288 1
a288 1
find_targ_sec (bfd *abfd, asection *sect, PTR obj)
d482 2
a483 1
  memset ((PTR) objfile->sym_stab_info, 0, sizeof (struct dbx_symfile_info));
d505 1
a505 1
find_linenos (bfd *abfd, sec_ptr asect, PTR vpinfo)
d599 1
a599 1
  bfd_map_over_sections (abfd, find_linenos, (PTR) info);
d636 1
a636 1
  bfd_map_over_sections (abfd, coff_locate_sections, (PTR) info);
@


1.25.2.1
log
@* coffread.c: Remove redundant static declarations.  Replace
occurrences of `PTR' with `void *'.
* elfread.c, mdebugread.c, minsyms.c, mipsread.c: Likewise.
* top.h (quit_cover): Likewise.
* defs.h (catch_errors): Likewise.
@
text
@d195 2
d219 26
d257 1
a257 1
coff_locate_sections (bfd *abfd, asection *sectp, void *csip)
d315 2
d318 1
a318 1
find_targ_sec (bfd *abfd, asection *sect, void *obj)
d512 1
a512 2
  memset (objfile->sym_stab_info, 0,
	  sizeof (struct dbx_symfile_info));
d534 1
a534 1
find_linenos (bfd *abfd, sec_ptr asect, void *vpinfo)
d628 1
a628 1
  bfd_map_over_sections (abfd, find_linenos, (void *) info);
d665 1
a665 1
  bfd_map_over_sections (abfd, coff_locate_sections, (void *) info);
@


1.24
log
@* gdbarch.sh (copyright): Update years in generated header.
(SMASH_TEXT_ADDRESS): Add rule.
*gdbarch.h, gdbarch.c: Re-generate.
* coffread.c: Multi-arch uses of SMASH_TEXT_ADDRESS.
* dbxread.c: Likewise.
* dwarfread.c: Likewise.
* elfread.c: Likewise.
* somread.c: Likewise.

* arm-tdep.c (arm_smash_text_address): New function.
* config/arm/tm-arm.h (SMASH_TEXT_ADDRESS): Define in terms of above.
@
text
@a977 1
#ifdef COFF_MAKE_MSYMBOL_SPECIAL
a979 1
#endif
@


1.23
log
@* utils.c (error_begin): Make static.
* defs.h (error_begin): Delete declaration.

* linespec.c (cplusplus_error): Replace cplusplus_hint.
(decode_line_1): Use cplusplus_error instead of error_begin,
cplusplus_hint and return_to_top_level.
* coffread.c (coff_symfile_read): Use error instead of error_begin
and return_to_top_level.
* infrun.c (default_skip_permanent_breakpoint): Ditto.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001
d947 1
a947 4
#ifdef SMASH_TEXT_ADDRESS
		    if (tmpaddr & 1)	/* FIXME: delete this line */
		      SMASH_TEXT_ADDRESS (tmpaddr);
#endif
@


1.22
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d671 4
a674 7
	  error_begin ();
	  fprintf_filtered
	    (gdb_stderr,
	     ("The debugging information in `%s' is corrupted.\n"
	   "The file has a `.stabs' section, but no `.stabstr' section.\n"),
	     name);
	  return_to_top_level (RETURN_ERROR);
@


1.21
log
@mfree() -> xmfree().
@
text
@d1595 1
a1595 1
	  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.20
log
@	* coffread.c: Replace all occurrences of bfd_read with bfd_bread.
	* dbxread.c: Likewise.
	* dwarf2read.c: Likewise.
	* dwarfread.c: Likewise.
	* somread.c: Likewise.
	* ultra3-nat.c: Likewise.
	* xcoffread.c: Likewise.
@
text
@d716 1
a716 1
      mfree (objfile->md, objfile->sym_private);
@


1.19
log
@        * coffread.c (coff_symfile_read): Parse DWARF2 info if present.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000
d1157 1
a1157 1
  bfd_read (temp_sym, local_symesz, 1, nlist_bfd_global);
d1162 1
a1162 1
      bfd_read (temp_aux, local_auxesz, 1, nlist_bfd_global);
d1168 1
a1168 1
	bfd_read (temp_aux, local_auxesz, 1, nlist_bfd_global);
d1235 1
a1235 1
  val = bfd_read ((char *) lengthbuf, sizeof lengthbuf, 1, abfd);
d1250 2
a1251 1
  val = bfd_read (stringtab + sizeof lengthbuf, length - sizeof lengthbuf, 1, abfd);
d1350 1
a1350 1
  val = bfd_read (linetab, size, 1, abfd);
@


1.19.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d1427 1
d1430 3
a1432 1
      TYPE_NAME (target) = TYPE_NAME (real_target);
d1448 1
a1448 1
  for (i = BLOCK_NBUCKETS (b) - 1; i >= 0; i--)
d1454 12
a1465 6
      for (real_sym = BLOCK_BUCKET (b, i); real_sym; real_sym = real_sym->hash_next)
	{
	  if (SYMBOL_CLASS (real_sym) == LOC_TYPEDEF &&
	      SYMBOL_NAMESPACE (real_sym) == VAR_NAMESPACE &&
	      TYPE_CODE (SYMBOL_TYPE (real_sym)) == TYPE_CODE_PTR &&
	      TYPE_LENGTH (POINTER_TARGET_TYPE (SYMBOL_TYPE (real_sym))) != 0)
d1467 2
a1468 6
	      register char *name = SYMBOL_NAME (real_sym);
	      register int hash = hashname (name);
	      register struct symbol *sym, *prev;
	      
	      prev = 0;
	      for (sym = opaque_type_chain[hash]; sym;)
d1470 1
a1470 2
		  if (name[0] == SYMBOL_NAME (sym)[0] &&
		      STREQ (name + 1, SYMBOL_NAME (sym) + 1))
d1472 1
a1472 19
		      if (prev)
			{
			  SYMBOL_VALUE_CHAIN (prev) = SYMBOL_VALUE_CHAIN (sym);
			}
		      else
			{
			  opaque_type_chain[hash] = SYMBOL_VALUE_CHAIN (sym);
			}
		      
		      patch_type (SYMBOL_TYPE (sym), SYMBOL_TYPE (real_sym));
		      
		      if (prev)
			{
			  sym = SYMBOL_VALUE_CHAIN (prev);
			}
		      else
			{
			  sym = opaque_type_chain[hash];
			}
d1476 1
a1476 2
		      prev = sym;
		      sym = SYMBOL_VALUE_CHAIN (sym);
d1478 16
d1526 2
a1527 2
      SYMBOL_TYPE (sym) = (struct type *)
	make_function_type (objfile, decode_function_type (cs, cs->c_type, aux), 0, NULL, 0);
d1686 2
a1687 2
	      TYPE_LENGTH (POINTER_TARGET_TYPE (SYMBOL_TYPE (sym))) == 0 &&
	      TYPE_CODE (POINTER_TARGET_TYPE (SYMBOL_TYPE (sym))) !=
d1744 1
a1744 2
	  type = (struct type *) make_function_type (current_objfile, type, 0, NULL, 0);

d1750 1
a1750 2
	  struct type *base_type, *index_type;
	  struct range_type *range_type;
d1768 3
a1770 3
	    make_range_type (current_objfile, index_type, 0, n - 1);
	  type = (struct type *)
	    make_array_type (current_objfile, base_type, range_type);
d2161 1
a2161 1
#if FIXTYPE
d2164 1
a2164 1
#endif
@


1.18
log
@* symfile.c (compare_psymbols, compare_symbols): Declare using
PTR, as in the definition.
* minsyms.c (compare_minimal_symbols): Likewise.
* coffread.c (find_targ_sec): Likewise.
* elfread.c (free_elfinfo, elf_locate_sections): Likewise.
* mipsread.c (alphacoff_locate_sections): Likewise.
* mdebugread.c (compare_blocks): Likewise.
@
text
@d692 5
@


1.17
log
@2001-03-25  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From  Andrew Cagney  <ac131313@@redhat.com>

        * coffread.c: Include "gdb_assert.h".
	(coff_symtab_read): Cast the integer s_sclass to a long before
 	casting it to a pointer.
@
text
@d315 1
a315 1
static void find_targ_sec (bfd *, asection *, void *);
@


1.16
log
@2001-03-25  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From  Andrew Cagney  <ac131313@@redhat.com>

        * coffread.c (coff_symtab_read): Initialize
 	``fcn_first_line_addr''.  Check that the ``.bf'' always preceeds
 	the ``.ef'' info.
	* dbxread.c (find_text_range): Initialize ``start'' and ``end''.
@
text
@d46 1
d970 6
d977 2
a978 2
		  (cs->c_name, tmpaddr, ms_type, (char *) cs->c_sclass, sec,
		   NULL, objfile);
@


1.15
log
@Update/correct copyright notices.
@
text
@d743 1
a743 1
  CORE_ADDR fcn_first_line_addr;
d1012 2
@


1.14
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright 1987, 88, 89, 90, 91, 92, 93, 94, 96, 97, 1998
@


1.13
log
@Multiarch STAB_REG_TO_REGNUM, ECOFF_REG_TO_REGNUM,
DWARF_REG_TO_REGNUM, SDB_REG_TO_REGNUM, DWARF2_REG_TO_REGNUM.
@
text
@d299 1
a299 1
	  make_cleanup (free, n);
d445 1
a445 1
    free (last_source_file);
d777 1
a777 1
    free ((PTR) type_vector);
d1246 1
a1246 1
    free (stringtab);
d1348 1
a1348 1
    free (linetab);
d1416 1
a1416 1
	free (TYPE_NAME (target));
@


1.12
log
@Call end_symtab() with SECT_OFF_TEXT (objfile).
@
text
@a70 8
/* Convert from an sdb register number to an internal gdb register number.
   This should be defined in tm.h, if REGISTER_NAMES is not set up
   to map one to one onto the sdb register numbers.  */

#ifndef SDB_REG_TO_REGNUM
#define SDB_REG_TO_REGNUM(value)     (value)
#endif

@


1.11
log
@2000-08-07  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* objfiles.h (SECT_OFF_BSS): Don't detect invalid sect_index_bss
 	here, let the users of the macro do it.
	* symtab.h (ANOFFSET): Detect here if the section index is not
 	initialized.
	* xcoffread.c (find_targ_sec): Don't treat .bss as special,
 	because some objfiles may not have that section at all.
	* coffread.c (cs_to_section): Ditto.
	* elfread.c (elf_symtab_read): Detect an uninitialized index
 	value.
	(elfstab_offset_sections): The macro ANOFFSET cannot be used as an
 	lvalue anymore.
	* remote.c (get_offsets, remote_cisco_objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* objfiles.c (objfile_relocate, objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* symfile.c (default_symfile_offsets): Don't use ANOFFSET as an
 	lvalue.
@
text
@d478 1
a478 1
  symtab = end_symtab (current_source_end_addr, objfile, 0);
@


1.10
log
@Protoization.
@
text
@d350 2
a351 1
	off = SECT_OFF_BSS (objfile);
@


1.9
log
@	* symfile.c (add_symbol_file_command): Properly reformat "else if"
 	code.
	* coffread.c (coff_symtab_read): Ditto.
@
text
@d263 1
a263 4
coff_locate_sections (abfd, sectp, csip)
     bfd *abfd;
     asection *sectp;
     PTR csip;
d324 1
a324 4
find_targ_sec (abfd, sect, obj)
     bfd *abfd;
     asection *sect;
     PTR obj;
d333 1
a333 3
cs_to_section (cs, objfile)
     struct coff_symbol *cs;
     struct objfile *objfile;
d360 1
a360 3
cs_section_address (cs, abfd)
     struct coff_symbol *cs;
     bfd *abfd;
d382 1
a382 2
coff_lookup_type (index)
     register int index;
d406 1
a406 2
coff_alloc_type (index)
     int index;
d427 1
a427 2
coff_start_symtab (name)
     char *name;
d449 1
a449 4
complete_symtab (name, start_addr, size)
     char *name;
     CORE_ADDR start_addr;
     unsigned int size;
d471 1
a471 2
coff_end_symtab (objfile)
     struct objfile *objfile;
d487 2
a488 5
record_minimal_symbol (name, address, type, objfile)
     char *name;
     CORE_ADDR address;
     enum minimal_symbol_type type;
     struct objfile *objfile;
d511 1
a511 2
coff_symfile_init (objfile)
     struct objfile *objfile;
d539 1
a539 4
find_linenos (abfd, asect, vpinfo)
     bfd *abfd;
     sec_ptr asect;
     PTR vpinfo;
d576 1
a576 3
coff_symfile_read (objfile, mainline)
     struct objfile *objfile;
     int mainline;
d702 1
a702 2
coff_new_init (ignore)
     struct objfile *ignore;
d712 1
a712 2
coff_symfile_finish (objfile)
     struct objfile *objfile;
d730 2
a731 4
coff_symtab_read (symtab_offset, nsyms, objfile)
     long symtab_offset;
     unsigned int nsyms;
     struct objfile *objfile;
d1142 3
a1144 4
read_one_sym (cs, sym, aux)
     register struct coff_symbol *cs;
     register struct internal_syment *sym;
     register union internal_auxent *aux;
d1211 1
a1211 3
init_stringtab (abfd, offset)
     bfd *abfd;
     long offset;
d1250 1
a1250 1
free_stringtab ()
d1264 1
a1264 2
getsymname (symbol_entry)
     struct internal_syment *symbol_entry;
d1289 1
a1289 2
coff_getfilename (aux_entry)
     union internal_auxent *aux_entry;
d1323 1
a1323 4
init_lineno (abfd, offset, size)
     bfd *abfd;
     long offset;
     int size;
d1352 1
a1352 1
free_linetab ()
d1370 2
a1371 5
enter_linenos (file_offset, first_line, last_line, objfile)
     long file_offset;
     register int first_line;
     register int last_line;
     struct objfile *objfile;
d1408 1
a1408 3
patch_type (type, real_type)
     struct type *type;
     struct type *real_type;
d1432 1
a1432 2
patch_opaque_types (s)
     struct symtab *s;
d1493 3
a1495 4
process_coff_symbol (cs, aux, objfile)
     register struct coff_symbol *cs;
     register union internal_auxent *aux;
     struct objfile *objfile;
d1719 2
a1720 4
decode_type (cs, c_type, aux)
     register struct coff_symbol *cs;
     unsigned int c_type;
     register union internal_auxent *aux;
d1798 2
a1799 4
decode_function_type (cs, c_type, aux)
     register struct coff_symbol *cs;
     unsigned int c_type;
     register union internal_auxent *aux;
d1810 2
a1811 4
decode_base_type (cs, c_type, aux)
     register struct coff_symbol *cs;
     unsigned int c_type;
     register union internal_auxent *aux;
d1962 1
a1962 4
coff_read_struct_type (index, length, lastsym)
     int index;
     int length;
     int lastsym;
d2057 1
a2057 4
coff_read_enum_type (index, length, lastsym)
     int index;
     int length;
     int lastsym;
d2174 1
a2174 1
_initialize_coffread ()
@


1.8
log
@PARAMS removal.
@
text
@d985 2
a986 3
		else
		  if  (sec == SECT_OFF_DATA (objfile))
		    {
d990 3
a992 4
		    }
		  else
		    if (sec == SECT_OFF_BSS (objfile))
		      {
d996 3
a998 3
		      }
		    else
		      ms_type = mst_unknown;
@


1.7
log
@Purge (almost) make_cleanup_func.
@
text
@d46 1
a46 1
extern void _initialize_coffread PARAMS ((void));
d179 1
a179 1
extern void stabsread_clear_cache PARAMS ((void));
d181 1
a181 1
static struct type *coff_read_struct_type PARAMS ((int, int, int));
d183 2
a184 3
static struct type *decode_base_type PARAMS ((struct coff_symbol *,
					      unsigned int,
					      union internal_auxent *));
d186 2
a187 2
static struct type *decode_type PARAMS ((struct coff_symbol *, unsigned int,
					 union internal_auxent *));
d189 3
a191 3
static struct type *decode_function_type PARAMS ((struct coff_symbol *,
						  unsigned int,
						  union internal_auxent *));
d193 1
a193 1
static struct type *coff_read_enum_type PARAMS ((int, int, int));
d195 3
a197 3
static struct symbol *process_coff_symbol PARAMS ((struct coff_symbol *,
						   union internal_auxent *,
						   struct objfile *));
d199 1
a199 1
static void patch_opaque_types PARAMS ((struct symtab *));
d201 1
a201 1
static void patch_type PARAMS ((struct type *, struct type *));
d203 1
a203 1
static void enter_linenos PARAMS ((long, int, int, struct objfile *));
d205 1
a205 1
static void free_linetab PARAMS ((void));
d209 1
a209 1
static int init_lineno PARAMS ((bfd *, long, int));
d211 1
a211 1
static char *getsymname PARAMS ((struct internal_syment *));
d213 1
a213 1
static char *coff_getfilename PARAMS ((union internal_auxent *));
d215 1
a215 1
static void free_stringtab PARAMS ((void));
d219 1
a219 1
static int init_stringtab PARAMS ((bfd *, long));
d221 2
a222 3
static void read_one_sym PARAMS ((struct coff_symbol *,
				  struct internal_syment *,
				  union internal_auxent *));
d224 1
a224 1
static void coff_symtab_read PARAMS ((long, unsigned int, struct objfile *));
d226 1
a226 1
static void find_linenos PARAMS ((bfd *, sec_ptr, PTR));
d228 1
a228 1
static void coff_symfile_init PARAMS ((struct objfile *));
d230 1
a230 1
static void coff_new_init PARAMS ((struct objfile *));
d232 1
a232 1
static void coff_symfile_read PARAMS ((struct objfile *, int));
d234 1
a234 1
static void coff_symfile_finish PARAMS ((struct objfile *));
d236 3
a238 3
static void record_minimal_symbol PARAMS ((char *, CORE_ADDR,
					   enum minimal_symbol_type,
					   struct objfile *));
d240 1
a240 1
static void coff_end_symtab PARAMS ((struct objfile *));
d242 1
a242 1
static void complete_symtab PARAMS ((char *, CORE_ADDR, unsigned int));
d244 1
a244 1
static void coff_start_symtab PARAMS ((char *));
d246 1
a246 1
static struct type *coff_alloc_type PARAMS ((int));
d248 1
a248 1
static struct type **coff_lookup_type PARAMS ((int));
d250 1
a250 1
static void coff_locate_sections PARAMS ((bfd *, asection *, PTR));
d316 1
a316 1
static int cs_to_section PARAMS ((struct coff_symbol *, struct objfile *));
d324 1
a324 1
static void find_targ_sec PARAMS ((bfd *, asection *, void *));
d365 1
a365 1
static CORE_ADDR cs_section_address PARAMS ((struct coff_symbol *, bfd *));
@


1.6
log
@Cleanup discard_minimal_symbols cleanup.
@
text
@d208 2
d218 2
d663 1
a663 1
  make_cleanup ((make_cleanup_func) free_linetab, 0);
d671 1
a671 1
  make_cleanup ((make_cleanup_func) free_stringtab, 0);
d1294 6
d1399 6
@


1.5
log
@2000-05-11  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* coffread.c (coff_symtab_read): In the case of C_THUMBEXT |
 	C_THUMBEXTFUNC | C_EXT, sec will never ever be the index for
 	.rodata, because cs_to_section doesn't deal with .rodata. Fix test
 	accordingly.
@
text
@d673 1
a673 1
  make_cleanup ((make_cleanup_func) discard_minimal_symbols, 0);
@


1.4
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d972 1
a972 1
		if (sec == SECT_OFF_TEXT (objfile) || sec == SECT_OFF_RODATA (objfile))
@


1.3
log
@	* ax-gdb.c (agent_command): Remove now useless cast of
	`free_current_contents' when passed to `make_cleanup'.
	* coffread.c (coff_symfile_read): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn, read_array_type): Ditto.
	(dwarf_decode_lines): Ditto.
	* eval.c (parse_and_eval_address, parse_and_eval_address_1): Ditto.
	(parse_and_eval, parse_to_comma_and_eval): Ditto.
	* parse.c (parse_exp_1): Ditto.
	* printcmd.c (print_command_1, output_command, set_command): Ditto.
	(x_command, print_frame_args, printf_command): Ditto.
	* top.c (execute_control_command): Ditto.
	* tracepoint.c (validate_actionline): Ditto.
	* typeprint.c (whatis_exp, ptype_command): Ditto.
	(maintenance_print_type): Ditto.
@
text
@d343 1
a343 1
  int off = SECT_OFF_TEXT;
d352 1
a352 1
	off = SECT_OFF_TEXT;
d354 1
a354 1
	off = SECT_OFF_DATA;
d356 1
a356 1
	off = SECT_OFF_BSS;
d846 1
a846 1
	  tmpaddr = cs->c_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d911 1
a911 1
		    cs->c_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT),
d972 1
a972 1
		switch (sec)
a973 2
		  case SECT_OFF_TEXT:
		  case SECT_OFF_RODATA:
d982 4
a985 2
		    break;
		  case SECT_OFF_DATA:
d989 4
a992 2
		    break;
		  case SECT_OFF_BSS:
d996 3
a998 5
		    break;
		  default:
		    ms_type = mst_unknown;
		    break;
		  }
d1102 1
a1102 1
			    + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT),
d1106 1
a1106 1
			    + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT),
d1118 1
a1118 1
	      tmpaddr += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d1138 1
a1138 1
		    cs->c_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d1430 1
a1430 1
		     + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT));
d1550 1
a1550 1
      SYMBOL_VALUE (sym) += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d1580 1
a1580 1
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d1589 1
a1589 1
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
@


1.2
log
@	Clean up compiler warnings:
	* bcache.h, bcache.c, c-valprint.c, coffread.c, stabsread.c,
	stack.c, valprint.c: Change variables to unsigned.
	* bcache.c: Rearrange to avoid warnings about variables not being set.
	* c-lang.c, ch-lang.c, f-lang.c, m2-lang.c: Include valprint.h
	rather than declaring print_max and repeat_count_threashold
	ourselves (incorrectly).
	* valprint.h: Do declare repeat_count_threashold.
	* ch-exp.c: Use default case for internal error.
	* findvar.c: Don't omit argument type.
	* symtab.c: Remove unused variable.
@
text
@d641 1
a641 1
  back_to = make_cleanup ((make_cleanup_func) free_current_contents, &temp_sym);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
             Free Software Foundation, Inc.
d6 1
a6 1
This file is part of GDB.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d46 13
a58 10
struct coff_symfile_info {
  file_ptr min_lineno_offset;		/* Where in file lowest line#s are */
  file_ptr max_lineno_offset;		/* 1+last byte of line#s in file */

  CORE_ADDR textaddr;			/* Addr of .text section. */
  unsigned int textsize;		/* Size of .text section. */
  struct stab_section_list *stabsects;	/* .stab sections.  */
  asection *stabstrsect;		/* Section pointer for .stab section */
  char *stabstrdata;
};
d76 1
a76 1
# define SDB_REG_TO_REGNUM(value)     (value)
a90 15
/* Vector of line number information.  */

static struct linetable *line_vector;

/* Index of next entry to go in line_vector_index.  */

static int line_vector_index;

/* Last line number recorded in the line vector.  */

static int prev_line_number;

/* Number of elements allocated for line_vector currently.  */

static int line_vector_length;
d103 4
a106 4
static unsigned	local_n_btmask;
static unsigned	local_n_btshft;
static unsigned	local_n_tmask;
static unsigned	local_n_tshift;
d112 1
a112 1
 
d118 3
a120 3
static unsigned	local_linesz;
static unsigned	local_symesz;
static unsigned	local_auxesz;
d133 2
a134 2
struct complaint ef_complaint = 
  {"Unmatched .ef symbol(s) ignored starting at symnum %d", 0, 0};
d136 2
a137 2
struct complaint ef_stack_complaint = 
  {"`.ef' symbol without matching `.bf' symbol ignored starting at symnum %d", 0, 0};
d139 2
a140 2
struct complaint eb_stack_complaint = 
  {"`.eb' symbol without matching `.bb' symbol ignored starting at symnum %d", 0, 0};
d143 1
a143 1
  {"`.bf' symbol %d has no aux entry", 0, 0};
d146 1
a146 1
  {"`.ef' symbol %d has no aux entry", 0, 0};
d149 1
a149 1
  {"Line number pointer %d lower than start of line numbers", 0, 0};
d152 1
a152 1
  {"Unexpected type for symbol %s", 0, 0};
d155 1
a155 1
  {"Bad n_sclass for symbol %s", 0, 0};
d158 1
a158 1
  {"Blocks out of order at address %x", 0, 0};
d161 1
a161 1
  {"Symbol table entry for %s has bad tagndx value", 0, 0};
d163 2
a164 2
struct complaint eb_complaint = 
  {"Mismatched .eb symbol ignored starting at symnum %d", 0, 0};
d168 12
a179 9
struct coff_symbol {
  char *c_name;
  int c_symnum;		/* symbol number of this entry */
  int c_naux;		/* 0 if syment only, 1 if syment + auxent, etc */
  long c_value;
  int c_sclass;
  int c_secnum;
  unsigned int c_type;
};
a197 1
						   struct section_offsets *,
d204 1
a204 1
static void enter_linenos PARAMS ((long, int, int, struct section_offsets *));
d222 1
a222 2
static void coff_symtab_read PARAMS ((long, int, struct section_offsets *,
				      struct objfile *));
d230 1
a230 2
static void coff_symfile_read PARAMS ((struct objfile *,
				       struct section_offsets *, int));
a243 2
static void coff_record_line PARAMS ((int, CORE_ADDR));

d291 1
a291 1
	if (! isdigit (*s))
d306 2
a307 2
             in coff_symfile_read, at which point we no longer need
             the information.  */
d316 5
a320 4
struct find_targ_sec_arg {
  int targ_index;
  asection **resultp;
};
d324 2
a325 1
static void find_targ_sec (abfd, sect, obj)
d330 1
a330 1
  struct find_targ_sec_arg *args = (struct find_targ_sec_arg *)obj;
d398 1
a398 1
      if (index /* is still */ >= type_vector_length)
d405 1
a405 1
	     (type_vector_length - old_vector_length) * sizeof(struct type *));
a431 24
/* Record a line number entry for line LINE at address PC.
   FIXME:  Use record_line instead.  */

static void
coff_record_line (line, pc)
     int line;
     CORE_ADDR pc;
{
  struct linetable_entry *e;
  /* Make sure line vector is big enough.  */

  if (line_vector_index + 2 >= line_vector_length)
    {
      line_vector_length *= 2;
      line_vector = (struct linetable *)
	xrealloc ((char *) line_vector, sizeof (struct linetable)
		  + (line_vector_length
		     * sizeof (struct linetable_entry)));
    }

  e = line_vector->item + line_vector_index++;
  e->line = line; e->pc = pc;
}

d438 1
a438 1
    char *name;
d441 10
a450 10
		/* We fill in the filename later.  start_symtab puts
		   this pointer into last_source_file and we put it in
		   subfiles->name, which end_symtab frees; that's why
		   it must be malloc'd.  */
		savestring (name, strlen(name)),
		/* We never know the directory name for COFF.  */
		NULL,
		/* The start address is irrelevant, since we set
		   last_source_start_addr in coff_end_symtab.  */
		0);
a451 11

  /* Initialize the source file line number information for this file.  */

  if (line_vector)		/* Unlikely, but maybe possible? */
    free ((PTR)line_vector);
  line_vector_index = 0;
  line_vector_length = 1000;
  prev_line_number = -2;	/* Force first line number to be explicit */
  line_vector = (struct linetable *)
    xmalloc (sizeof (struct linetable)
	     + line_vector_length * sizeof (struct linetable_entry));
d461 3
a463 3
    char *name;
    CORE_ADDR start_addr;
    unsigned int size;
d471 2
a472 2
  if (current_objfile -> ei.entry_point >= current_source_start_addr &&
      current_objfile -> ei.entry_point <  current_source_end_addr)
d474 2
a475 2
      current_objfile -> ei.entry_file_lowpc = current_source_start_addr;
      current_objfile -> ei.entry_file_highpc = current_source_end_addr;
a491 12
  /* For no good reason, this file stores the number of entries in a
     separate variable instead of in line_vector->nitems.  Fix it.  */
  if (line_vector)
    line_vector->nitems = line_vector_index;

  /* For COFF, we only have one subfile, so we can just look at
     subfiles and not worry about there being other elements in the
     chain.  We fill in various fields now because we didn't know them
     before (or because doing it now is simply an artifact of how this
     file used to be written).  */
  subfiles->line_vector = line_vector;

a497 2
  line_vector = 0;
  line_vector_length = -1;
d509 2
a510 1
  if (name[0] == '@@') return;
d575 1
a575 1
  info = (struct coff_symfile_info *)vpinfo;
d598 1
a598 1
coff_symfile_read (objfile, section_offsets, mainline)
a599 1
     struct section_offsets *section_offsets;
d608 1
a608 1
  int num_symbols;
d613 4
a616 2

  info = (struct coff_symfile_info *) objfile -> sym_private;
d618 1
a618 1
  symfile_bfd = abfd;			/* Kludge for swap routines */
d621 4
a624 4
   num_symbols = bfd_get_symcount (abfd);	/* How many syms */
   symtab_offset = cdata->sym_filepos;		/* Symbol table file offset */
   stringtab_offset = symtab_offset +		/* String table file offset */
		      num_symbols * cdata->local_symesz;
a627 1
  local_linesz   = cdata->local_linesz;
d630 1
a630 1
  local_n_tmask  = cdata->local_n_tmask;
d632 3
a634 3
  local_linesz   = cdata->local_linesz;
  local_symesz   = cdata->local_symesz;
  local_auxesz   = cdata->local_auxesz;
d639 1
a639 1
	 (cdata->local_symesz + cdata->local_auxesz);
d648 3
a650 1
  pe_file = strncmp (bfd_get_target (objfile->obfd), "pe", 2) == 0;
d660 1
a660 1
  val = init_lineno (abfd, info->min_lineno_offset, 
d678 1
a678 2
  coff_symtab_read ((long) symtab_offset, num_symbols, section_offsets,
		    objfile);
d685 1
a685 1
    for (s = objfile -> symtabs; s != NULL; s = s -> next)
d698 11
d710 1
a710 1
	 bfd_get_section_contents?  */
a715 1
			       section_offsets,
d740 1
a740 1
  if (objfile -> sym_private != NULL)
d742 1
a742 1
      mfree (objfile -> md, objfile -> sym_private);
d744 3
d748 1
a749 1

d756 1
a756 1
coff_symtab_read (symtab_offset, nsyms, section_offsets, objfile)
d758 1
a758 2
     int nsyms;
     struct section_offsets *section_offsets;
d777 1
d811 1
a811 1
  if (type_vector)			/* Get rid of previous one */
d846 1
a846 1
	  tmpaddr = cs->c_value + ANOFFSET (section_offsets, SECT_OFF_TEXT);
d859 9
a867 9
	  case C_EFCN:
	  case C_EXTDEF:
	  case C_ULABEL:
	  case C_USTATIC:
	  case C_LINE:
	  case C_ALIAS:
	  case C_HIDDEN:
	    complain (&bad_sclass_complaint, cs->c_name);
	    break;
d869 8
a876 8
	  case C_FILE:
	    /* c_value field contains symnum of next .file entry in table
	       or symnum of first global after last .file.  */
	    next_file_symnum = cs->c_value;
	    if (cs->c_naux > 0)
	      filestring = coff_getfilename (&main_aux);
	    else
	      filestring = "";
d878 9
a886 9
	    /* Complete symbol table for last object file
	       containing debugging information.  */
	    if (last_source_file)
	      {
		coff_end_symtab (objfile);
		coff_start_symtab (filestring);
	      }
	    in_source_file = 1;
	    break;
d891 13
a903 12
	  case C_LABEL:
	    /* However, labels within a function can make weird backtraces,
	       so filter them out (from phdm@@macqel.be). */
	    if (within_function)
	      break;
          case C_STAT:
	  case C_THUMBLABEL:
	  case C_THUMBSTAT:
	  case C_THUMBSTATFUNC:
	    if (cs->c_name[0] == '.')
	      {
		if (STREQ (cs->c_name, ".text")) {
d911 1
a911 1
				     cs->c_value + ANOFFSET (section_offsets, SECT_OFF_TEXT),
d915 1
a915 15
		/* flush rest of '.' symbols */
		break;
	      }
	    else if (!SDB_TYPE (cs->c_type)
		     && cs->c_name[0] == 'L'
		     && (strncmp (cs->c_name, "LI%", 3) == 0
			 || strncmp (cs->c_name, "LF%", 3) == 0
			 || strncmp (cs->c_name,"LC%",3) == 0
			 || strncmp (cs->c_name,"LP%",3) == 0
			 || strncmp (cs->c_name,"LPB%",4) == 0
			 || strncmp (cs->c_name,"LBB%",4) == 0
			 || strncmp (cs->c_name,"LBE%",4) == 0
			 || strncmp (cs->c_name,"LPBX%",5) == 0))
	      /* At least on a 3b1, gcc generates swbeg and string labels
		 that look like this.  Ignore them.  */
d917 28
a944 14
	    /* fall in for static symbols that don't start with '.' */
	  case C_THUMBEXT:
	  case C_THUMBEXTFUNC:
	  case C_EXT:
	    {
	      /* Record it in the minimal symbols regardless of
		 SDB_TYPE.  This parallels what we do for other debug
		 formats, and probably is needed to make
		 print_address_symbolic work right without the (now
		 gone) "set fast-symbolic-addr off" kludge.  */

	      /* FIXME: should use mst_abs, and not relocate, if absolute.  */
	      enum minimal_symbol_type ms_type;
	      int sec;
d946 25
a970 25
	      if (cs->c_secnum == N_UNDEF)
		{
		  /* This is a common symbol.  See if the target
		     environment knows where it has been relocated to.  */
		  CORE_ADDR reladdr;
		  if (target_lookup_symbol (cs->c_name, &reladdr))
		    {
		      /* Error in lookup; ignore symbol.  */
		      break;
		    }
		  tmpaddr = reladdr;
		  /* The address has already been relocated; make sure that
		     objfile_relocate doesn't relocate it again.  */
		  sec = -2;
		  ms_type = cs->c_sclass == C_EXT
			    || cs->c_sclass == C_THUMBEXT ?
			       mst_bss : mst_file_bss;
		}
	      else
		{
		  sec = cs_to_section (cs, objfile);
		  tmpaddr = cs->c_value;
		  if (cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXTFUNC
		      || cs->c_sclass == C_THUMBEXT)
		    tmpaddr += ANOFFSET (section_offsets, sec);
d972 8
a979 8
		  switch (sec)
		    {
		    case SECT_OFF_TEXT:
		    case SECT_OFF_RODATA:
		      ms_type =
			cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXTFUNC
					|| cs->c_sclass == C_THUMBEXT ?
					  mst_text : mst_file_text;
d981 2
a982 2
		      if (tmpaddr & 1)	/* FIXME: delete this line */
			SMASH_TEXT_ADDRESS (tmpaddr);
d984 16
a999 16
		      break;
		    case SECT_OFF_DATA:
		      ms_type =
			cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXT ?
			  mst_data : mst_file_data;
		      break;
		    case SECT_OFF_BSS:
		      ms_type =
			cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXT ?
			  mst_data : mst_file_data;
		      break;
		    default:
		      ms_type = mst_unknown;
		      break;
		    }
		}
d1001 3
a1003 3
	      if (cs->c_name[0] != '@@' /* Skip tdesc symbols */)
		{
		  struct minimal_symbol *msym;
d1005 2
a1006 2
		  msym = prim_record_minimal_symbol_and_info
		  (cs->c_name, tmpaddr, ms_type, (char *)cs->c_sclass, sec,
d1009 2
a1010 2
		  if(msym)
		    COFF_MAKE_MSYMBOL_SPECIAL(cs->c_sclass, msym);		
d1012 60
d1073 1
a1073 1
	      if (SDB_TYPE (cs->c_type))
d1075 1
a1075 5
		  struct symbol *sym;
		  sym = process_coff_symbol
		    (cs, &main_aux, section_offsets, objfile);
		  SYMBOL_VALUE (sym) = tmpaddr;
		  SYMBOL_SECTION (sym) = sec;
d1077 10
a1086 56
	    }
	    break;

	  case C_FCN:
	    if (STREQ (cs->c_name, ".bf"))
	      {
		within_function = 1;

		/* value contains address of first non-init type code */
		/* main_aux.x_sym.x_misc.x_lnsz.x_lnno
			    contains line number of '{' } */
		if (cs->c_naux != 1)
		  complain (&bf_no_aux_complaint, cs->c_symnum);
		fcn_first_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;

		/* Might want to check that locals are 0 and
		   context_stack_depth is zero, and complain if not.  */

		depth = 0;
		new = push_context (depth, fcn_start_addr);
		fcn_cs_saved.c_name = getsymname (&fcn_sym_saved);
		new->name =
		  process_coff_symbol (&fcn_cs_saved, &fcn_aux_saved,
				       section_offsets, objfile);
	      }
	    else if (STREQ (cs->c_name, ".ef"))
	      {
		/* the value of .ef is the address of epilogue code;
		   not useful for gdb.  */
		/* { main_aux.x_sym.x_misc.x_lnsz.x_lnno
			    contains number of lines to '}' */

		if (context_stack_depth <= 0)
		  {		/* We attempted to pop an empty context stack */
		    complain (&ef_stack_complaint, cs->c_symnum);
		    within_function = 0;
		    break;
		  }

		new = pop_context ();
		/* Stack must be empty now.  */
		if (context_stack_depth > 0 || new == NULL)
		  {
		    complain (&ef_complaint, cs->c_symnum);
		    within_function = 0;
		    break;
		  }
		if (cs->c_naux != 1)
		  {
		    complain (&ef_no_aux_complaint, cs->c_symnum);
		    fcn_last_line = 0x7FFFFFFF;
		  }
		else
		  {
		    fcn_last_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;
		  }
d1088 1
a1088 1
			       section_offsets);
d1090 2
a1091 2
		finish_block (new->name, &local_symbols, new->old_blocks,
			      new->start_addr,
d1093 10
a1102 10
			      /* This macro should be defined only on
				 machines where the
				 fcn_aux_saved.x_sym.x_misc.x_fsize
				 field is always zero.
				 So use the .bf record information that
				 points to the epilogue and add the size
				 of the epilogue.  */
			      cs->c_value
			      + FUNCTION_EPILOGUE_SIZE
			      + ANOFFSET (section_offsets, SECT_OFF_TEXT),
d1104 3
a1106 3
			      fcn_cs_saved.c_value
			      + fcn_aux_saved.x_sym.x_misc.x_fsize
			      + ANOFFSET (section_offsets, SECT_OFF_TEXT),
d1108 5
a1112 5
			      objfile
			      );
		within_function = 0;
	      }
	    break;
d1114 14
a1127 14
	  case C_BLOCK:
	    if (STREQ (cs->c_name, ".bb"))
	      {
		tmpaddr = cs->c_value;
		tmpaddr += ANOFFSET (section_offsets, SECT_OFF_TEXT);
		push_context (++depth, tmpaddr);
	      }
	    else if (STREQ (cs->c_name, ".eb"))
	      {
		if (context_stack_depth <= 0)
		  {		/* We attempted to pop an empty context stack */
		    complain (&eb_stack_complaint, cs->c_symnum);
		    break;
		  }
d1129 18
a1146 18
		new = pop_context ();
		if (depth-- != new->depth)
		  {
		    complain (&eb_complaint, symnum);
		    break;
		  }
		if (local_symbols && context_stack_depth > 0)
		  {
		    tmpaddr =
		      cs->c_value + ANOFFSET (section_offsets, SECT_OFF_TEXT);
		    /* Make a block for the local symbols within.  */
		    finish_block (0, &local_symbols, new->old_blocks,
				  new->start_addr, tmpaddr, objfile);
		  }
		/* Now pop locals of block just finished.  */
		local_symbols = new->locals;
	      }
	    break;
d1148 3
a1150 3
	  default:
	    process_coff_symbol (cs, &main_aux, section_offsets, objfile);
	    break;
d1173 3
a1175 3
    register struct coff_symbol *cs;
    register struct internal_syment *sym;
    register union internal_auxent *aux;
d1181 1
a1181 1
  bfd_coff_swap_sym_in (symfile_bfd, temp_sym, (char *)sym);
a1184 6
    bfd_read (temp_aux, local_auxesz, 1, nlist_bfd_global);
    bfd_coff_swap_aux_in (symfile_bfd, temp_aux, sym->n_type, sym->n_sclass,
			  0, cs->c_naux, (char *)aux);
    /* If more than one aux entry, read past it (only the first aux
       is important). */
    for (i = 1; i < cs->c_naux; i++)
d1186 6
d1203 1
a1203 1
    printf("thumb symbol %s, class 0x%x\n", cs->c_name, cs->c_sclass);
d1243 2
a1244 2
    bfd *abfd;
    long offset;
d1260 1
a1260 1
  val = bfd_read ((char *)lengthbuf, sizeof lengthbuf, 1, abfd);
d1262 1
a1262 1
       
d1272 1
a1272 1
  if (length == sizeof length)		/* Empty table -- just the count */
d1292 1
a1292 1
    struct internal_syment *symbol_entry;
d1294 1
a1294 1
  static char buffer[SYMNMLEN+1];
d1300 1
a1300 1
	 seeing whether offset points to within the stringtab.  */
d1318 1
a1318 1
    union internal_auxent *aux_entry;
d1350 1
a1350 1
 
d1353 3
a1355 3
    bfd *abfd;
    long offset;
    int size;
d1362 1
a1362 1
  free_linetab();
d1369 1
a1369 1
  
d1396 1
a1396 1
enter_linenos (file_offset, first_line, last_line, section_offsets)
d1400 1
a1400 1
     struct section_offsets *section_offsets;
d1406 1
a1406 1
    return ;
d1412 1
a1412 1
      file_offset += linetab_offset;  /* Try reading at that linetab offset */
d1414 1
a1414 1
  
d1422 12
a1433 11
  for (;;) {
    bfd_coff_swap_lineno_in (symfile_bfd, rawptr, &lptr);
    rawptr += local_linesz;
    /* The next function, or the sentinel, will have L_LNNO32 zero; we exit. */
    if (L_LNNO32 (&lptr) && L_LNNO32 (&lptr) <= last_line)
      coff_record_line (first_line + L_LNNO32 (&lptr),
			lptr.l_addr.l_paddr
			+ ANOFFSET (section_offsets, SECT_OFF_TEXT));
    else
      break;
  } 
d1438 2
a1439 2
    struct type *type;
    struct type *real_type;
d1469 1
a1469 1
  
d1475 3
a1477 3
	 Remove syms from the chain when their types are stored,
	 but search the whole chain, as there may be several syms
	 from different files with the same name.  */
d1487 1
a1487 1
	  
d1502 1
a1502 1
		  
d1504 1
a1504 1
		  
d1525 1
a1525 1
process_coff_symbol (cs, aux, section_offsets, objfile)
a1527 1
     struct section_offsets *section_offsets;
d1531 2
a1532 2
    = (struct symbol *) obstack_alloc (&objfile->symbol_obstack,
				       sizeof (struct symbol));
d1550 3
a1552 3
      SYMBOL_VALUE (sym) += ANOFFSET (section_offsets, SECT_OFF_TEXT);
       SYMBOL_TYPE(sym) = 
	 lookup_function_type (decode_function_type (cs, cs->c_type, aux));
d1567 2
a1568 2
	  case C_NULL:
	    break;
d1570 4
a1573 4
	  case C_AUTO:
	    SYMBOL_CLASS (sym) = LOC_LOCAL;
	    add_symbol_to_list (sym, &local_symbols);
	    break;
d1575 8
a1582 8
	  case C_THUMBEXT:
	  case C_THUMBEXTFUNC:
	  case C_EXT:
	    SYMBOL_CLASS (sym) = LOC_STATIC;
	    SYMBOL_VALUE_ADDRESS (sym) = (CORE_ADDR) cs->c_value;
	    SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	    add_symbol_to_list (sym, &global_symbols);
	    break;
d1584 8
a1591 7
	  case C_THUMBSTAT:
	  case C_THUMBSTATFUNC:
	  case C_STAT:
	    SYMBOL_CLASS (sym) = LOC_STATIC;
	    SYMBOL_VALUE_ADDRESS (sym) = (CORE_ADDR) cs->c_value;
	    SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	    if (within_function) {
d1595 2
a1596 1
	    else {
d1600 1
a1600 1
	    break;
d1603 1
a1603 1
	  case C_GLBLREG:
d1605 5
a1609 5
	  case C_REG:
	    SYMBOL_CLASS (sym) = LOC_REGISTER;
	    SYMBOL_VALUE (sym) = SDB_REG_TO_REGNUM(cs->c_value);
	    add_symbol_to_list (sym, &local_symbols);
	    break;
d1611 3
a1613 3
	  case C_THUMBLABEL:
	  case C_LABEL:
	    break;
d1615 3
a1617 3
	  case C_ARG:
	    SYMBOL_CLASS (sym) = LOC_ARG;
	    add_symbol_to_list (sym, &local_symbols);
d1619 17
a1635 17
	    if (TARGET_BYTE_ORDER == BIG_ENDIAN)
	      {
		/* If PCC says a parameter is a short or a char,
		   aligned on an int boundary, realign it to the
		   "little end" of the int.  */
		struct type *temptype;
		temptype = lookup_fundamental_type (current_objfile,
						    FT_INTEGER);
		if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (temptype)
		    && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT
		    && 0 == SYMBOL_VALUE (sym) % TYPE_LENGTH (temptype))
		  {
		    SYMBOL_VALUE (sym) +=
		      TYPE_LENGTH (temptype)
			- TYPE_LENGTH (SYMBOL_TYPE (sym));
		  }
	      }
d1637 1
a1637 1
	    break;
d1639 4
a1642 4
	  case C_REGPARM:
	    SYMBOL_CLASS (sym) = LOC_REGPARM;
	    SYMBOL_VALUE (sym) = SDB_REG_TO_REGNUM(cs->c_value);
	    add_symbol_to_list (sym, &local_symbols);
d1644 10
a1653 2
	    /* FIXME:  This should retain the current type, since it's just
	       a register value.  gnu@@adobe, 26Feb93 */
d1655 5
a1659 14
	        /* If PCC says a parameter is a short or a char,
		   it is really an int.  */
		struct type *temptype;
		temptype =
		  lookup_fundamental_type (current_objfile, FT_INTEGER);
		if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (temptype)
		    && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT)
		  {
		    SYMBOL_TYPE (sym) =
		      (TYPE_UNSIGNED (SYMBOL_TYPE (sym))
		       ? lookup_fundamental_type (current_objfile,
						  FT_UNSIGNED_INTEGER)
		       : temptype);
		  }
d1661 1
d1663 5
a1667 5
	    break;
	    
	  case C_TPDEF:
	    SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	    SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d1669 30
a1698 30
	    /* If type has no name, give it one */
	    if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
	      {
		if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR
		    || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FUNC)
		  {
		    /* If we are giving a name to a type such as "pointer to
		       foo" or "function returning foo", we better not set
		       the TYPE_NAME.  If the program contains "typedef char
		       *caddr_t;", we don't want all variables of type char
		       * to print as caddr_t.  This is not just a
		       consequence of GDB's type management; CC and GCC (at
		       least through version 2.4) both output variables of
		       either type char * or caddr_t with the type
		       refering to the C_TPDEF symbol for caddr_t.  If a future
		       compiler cleans this up it GDB is not ready for it
		       yet, but if it becomes ready we somehow need to
		       disable this check (without breaking the PCC/GCC2.4
		       case).

		       Sigh.

		       Fortunately, this check seems not to be necessary
		       for anything except pointers or functions.  */
		    ;
		  }
		else
		  TYPE_NAME (SYMBOL_TYPE (sym)) =
		    concat (SYMBOL_NAME (sym), NULL);
	      }
d1700 3
a1702 3
	    /* Ignore vendor section for Harris CX/UX targets. */
            else if (cs->c_name[0] == '$') 
	      break;
d1705 11
a1715 11
	    /* Keep track of any type which points to empty structured type,
		so it can be filled from a definition from another file.  A
		simple forward reference (TYPE_CODE_UNDEF) is not an
		empty structured type, though; the forward references
		work themselves out via the magic of coff_lookup_type.  */
	    if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR &&
		TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))) == 0 &&
		TYPE_CODE   (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))) !=
						TYPE_CODE_UNDEF)
	      {
		register int i = hashname (SYMBOL_NAME (sym));
d1717 5
a1721 5
		SYMBOL_VALUE_CHAIN (sym) = opaque_type_chain[i];
		opaque_type_chain[i] = sym;
	      }
	    add_symbol_to_list (sym, &file_symbols);
	    break;
d1723 15
a1737 15
	  case C_STRTAG:
	  case C_UNTAG:
	  case C_ENTAG:
	    SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	    SYMBOL_NAMESPACE (sym) = STRUCT_NAMESPACE;

            /* Some compilers try to be helpful by inventing "fake"
               names for anonymous enums, structures, and unions, like
               "~0fake" or ".0fake".  Thanks, but no thanks... */
	    if (TYPE_TAG_NAME (SYMBOL_TYPE (sym)) == 0)
	      if (SYMBOL_NAME(sym) != NULL
		  && *SYMBOL_NAME(sym) != '~'
		  && *SYMBOL_NAME(sym) != '.')
		TYPE_TAG_NAME (SYMBOL_TYPE (sym)) =
		  concat (SYMBOL_NAME (sym), NULL);
d1739 2
a1740 2
	    add_symbol_to_list (sym, &file_symbols);
	    break;
d1742 2
a1743 2
	  default:
	    break;
d1839 1
a1839 1
    cs->c_naux = 0;	/* auxent refers to function, not base type */
d1856 3
a1858 3
      case T_NULL:
        /* shows up with "void (*foo)();" structure members */
	return lookup_fundamental_type (current_objfile, FT_VOID);
d1863 3
a1865 3
      case T_ARG:
	/* Shows up in DGUX, I think.  Not sure where.  */
	return lookup_fundamental_type (current_objfile, FT_VOID);	/* shouldn't show up here */
d1870 3
a1872 3
      case T_VOID:
	/* Intel 960 COFF has this symbol and meaning.  */
	return lookup_fundamental_type (current_objfile, FT_VOID);
d1875 2
a1876 2
      case T_CHAR:
	return lookup_fundamental_type (current_objfile, FT_CHAR);
d1878 2
a1879 2
      case T_SHORT:
	return lookup_fundamental_type (current_objfile, FT_SHORT);
d1881 2
a1882 2
      case T_INT:
	return lookup_fundamental_type (current_objfile, FT_INTEGER);
d1884 6
a1889 6
      case T_LONG:
	if (cs->c_sclass == C_FIELD
	    && aux->x_sym.x_misc.x_lnsz.x_size > TARGET_LONG_BIT)
	  return lookup_fundamental_type (current_objfile, FT_LONG_LONG);
	else
	  return lookup_fundamental_type (current_objfile, FT_LONG);
d1891 2
a1892 2
      case T_FLOAT:
	return lookup_fundamental_type (current_objfile, FT_FLOAT);
d1894 2
a1895 2
      case T_DOUBLE:
	return lookup_fundamental_type (current_objfile, FT_DBL_PREC_FLOAT);
d1897 2
a1898 2
      case T_LNGDBL:
	return lookup_fundamental_type (current_objfile, FT_EXT_PREC_FLOAT);
d1900 23
a1922 23
      case T_STRUCT:
	if (cs->c_naux != 1)
	  {
	    /* anonymous structure type */
	    type = coff_alloc_type (cs->c_symnum);
	    TYPE_CODE (type) = TYPE_CODE_STRUCT;
	    TYPE_NAME (type) = NULL;
	    /* This used to set the tag to "<opaque>".  But I think setting it
	       to NULL is right, and the printing code can print it as
	       "struct {...}".  */
	    TYPE_TAG_NAME (type) = NULL;
	    INIT_CPLUS_SPECIFIC(type);
	    TYPE_LENGTH (type) = 0;
	    TYPE_FIELDS (type) = 0;
	    TYPE_NFIELDS (type) = 0;
	  }
	else
	  {
	    type = coff_read_struct_type (cs->c_symnum,
				    aux->x_sym.x_misc.x_lnsz.x_size,
				    aux->x_sym.x_fcnary.x_fcn.x_endndx.l);
	  }
	return type;
d1924 23
a1946 23
      case T_UNION:
	if (cs->c_naux != 1)
	  {
	    /* anonymous union type */
	    type = coff_alloc_type (cs->c_symnum);
	    TYPE_NAME (type) = NULL;
	    /* This used to set the tag to "<opaque>".  But I think setting it
	       to NULL is right, and the printing code can print it as
	       "union {...}".  */
	    TYPE_TAG_NAME (type) = NULL;
	    INIT_CPLUS_SPECIFIC(type);
	    TYPE_LENGTH (type) = 0;
	    TYPE_FIELDS (type) = 0;
	    TYPE_NFIELDS (type) = 0;
	  }
	else
	  {
	    type = coff_read_struct_type (cs->c_symnum,
				    aux->x_sym.x_misc.x_lnsz.x_size,
				    aux->x_sym.x_fcnary.x_fcn.x_endndx.l);
	  }
	TYPE_CODE (type) = TYPE_CODE_UNION;
	return type;
d1948 22
a1969 22
      case T_ENUM:
	if (cs->c_naux != 1)
	  {
	    /* anonymous enum type */
	    type = coff_alloc_type (cs->c_symnum);
	    TYPE_CODE (type) = TYPE_CODE_ENUM;
	    TYPE_NAME (type) = NULL;
	    /* This used to set the tag to "<opaque>".  But I think setting it
	       to NULL is right, and the printing code can print it as
	       "enum {...}".  */
	    TYPE_TAG_NAME (type) = NULL;
	    TYPE_LENGTH (type) = 0;
	    TYPE_FIELDS (type) = 0;
	    TYPE_NFIELDS(type) = 0;
	  }
	else
	  {
	    type = coff_read_enum_type (cs->c_symnum,
					aux->x_sym.x_misc.x_lnsz.x_size,
					aux->x_sym.x_fcnary.x_fcn.x_endndx.l);
	  }
	return type;
d1971 3
a1973 3
      case T_MOE:
	/* shouldn't show up here */
	break;
d1975 2
a1976 2
      case T_UCHAR:
	return lookup_fundamental_type (current_objfile, FT_UNSIGNED_CHAR);
d1978 2
a1979 2
      case T_USHORT:
	return lookup_fundamental_type (current_objfile, FT_UNSIGNED_SHORT);
d1981 2
a1982 2
      case T_UINT:
	return lookup_fundamental_type (current_objfile, FT_UNSIGNED_INTEGER);
d1984 6
a1989 6
      case T_ULONG:
	if (cs->c_sclass == C_FIELD
	    && aux->x_sym.x_misc.x_lnsz.x_size > TARGET_LONG_BIT)
	  return lookup_fundamental_type (current_objfile, FT_UNSIGNED_LONG_LONG);
	else
	  return lookup_fundamental_type (current_objfile, FT_UNSIGNED_LONG);
d2026 1
a2026 1
  INIT_CPLUS_SPECIFIC(type);
d2037 2
a2038 2
	  case C_MOS:
	  case C_MOU:
d2040 15
a2054 15
	    /* Get space to record the next field's data.  */
	    new = (struct nextfield *) alloca (sizeof (struct nextfield));
	    new->next = list;
	    list = new;

	    /* Save the data.  */
	    list->field.name =
	      obsavestring (name,
			    strlen (name),
			    &current_objfile->symbol_obstack);
	    FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux);
	    FIELD_BITPOS (list->field) = 8 * ms->c_value;
	    FIELD_BITSIZE (list->field) = 0;
	    nfields++;
	    break;
d2056 1
a2056 1
	  case C_FIELD:
d2058 15
a2072 15
	    /* Get space to record the next field's data.  */
	    new = (struct nextfield *) alloca (sizeof (struct nextfield));
	    new->next = list;
	    list = new;

	    /* Save the data.  */
	    list->field.name =
	      obsavestring (name,
			    strlen (name),
			    &current_objfile->symbol_obstack);
	    FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux);
	    FIELD_BITPOS (list->field) = ms->c_value;
	    FIELD_BITSIZE (list->field) = sub_aux.x_sym.x_misc.x_lnsz.x_size;
	    nfields++;
	    break;
d2074 3
a2076 3
	  case C_EOS:
	    done = 1;
	    break;
d2135 15
a2149 15
	  case C_MOE:
	    sym = (struct symbol *) obstack_alloc
	      (&current_objfile->symbol_obstack,
	       sizeof (struct symbol));
	    memset (sym, 0, sizeof (struct symbol));

	    SYMBOL_NAME (sym) =
	      obsavestring (name, strlen (name),
			    &current_objfile->symbol_obstack);
	    SYMBOL_CLASS (sym) = LOC_CONST;
	    SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
	    SYMBOL_VALUE (sym) = ms->c_value;
	    add_symbol_to_list (sym, symlist);
	    nsyms++;
	    break;
d2151 6
a2156 6
	  case C_EOS:
	    /* Sometimes the linker (on 386/ix 2.0.2 at least) screws
	       up the count of how many symbols to read.  So stop
	       on .eos.  */
	    done = 1;
	    break;
d2165 1
a2165 1
    TYPE_LENGTH (type) = TARGET_INT_BIT / TARGET_CHAR_BIT; /* Assume ints */
d2185 1
a2185 1
      for (; j < syms->nsyms; j++,n++)
d2210 6
a2215 7
  coff_new_init,	/* sym_new_init: init anything gbl to entire symtab */
  coff_symfile_init,	/* sym_init: read initial info, setup for sym_read() */
  coff_symfile_read,	/* sym_read: read a symbol file into symtab */
  coff_symfile_finish,	/* sym_finish: finished with file, cleanup */
  default_symfile_offsets,
			/* sym_offsets:  xlate external to internal form */
  NULL			/* next: pointer to next struct sym_fns */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d87 15
d255 2
d443 24
d487 11
d538 12
d556 2
d686 1
a1088 1
	        record_line (current_subfile, fcn_first_line, cs->c_value);
d1461 1
a1461 1
      record_line (current_subfile, first_line + L_LNNO32 (&lptr),
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@a688 11
      if (! info->stabstrsect)
	{
	  error_begin ();
	  fprintf_filtered
	    (gdb_stderr,
	     ("The debugging information in `%s' is corrupted.\n"
	      "The file has a `.stabs' section, but no `.stabstr' section.\n"),
	     name);
	  return_to_top_level (RETURN_ERROR);
	}

@


1.1.1.4
log
@import gdb-1999-05-10
@
text
@a766 1
  CORE_ADDR fcn_first_line_addr;
a1022 1
		fcn_first_line_addr = cs->c_value;
d1033 1
d1066 2
a1067 12
		/* fcn_first_line is the line number of the opening '{'.
		   Do not record it - because it would affect gdb's idea
		   of the line number of the first statement of the function -
		   except for one-line functions, for which it is also the line
		   number of all the statements and of the closing '}', and
		   for which we do not have any other statement-line-number. */
		if (fcn_last_line == 1)
	          record_line (current_subfile, fcn_first_line,
			       fcn_first_line_addr);
		else
		  enter_linenos (fcn_line_ptr, fcn_first_line, fcn_last_line,
				 section_offsets);
@


1.1.1.5
log
@import gdb-1999-05-25 snapshot
@
text
@a44 2
extern void _initialize_coffread PARAMS ((void));

@


1.1.1.6
log
@import gdb-1999-07-07 post reformat
@
text
@d3 1
a3 1
   Free Software Foundation, Inc.
d6 1
a6 1
   This file is part of GDB.
d8 13
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d47 10
a56 11
struct coff_symfile_info
  {
    file_ptr min_lineno_offset;	/* Where in file lowest line#s are */
    file_ptr max_lineno_offset;	/* 1+last byte of line#s in file */

    CORE_ADDR textaddr;		/* Addr of .text section. */
    unsigned int textsize;	/* Size of .text section. */
    struct stab_section_list *stabsects;	/* .stab sections.  */
    asection *stabstrsect;	/* Section pointer for .stab section */
    char *stabstrdata;
  };
d74 1
a74 1
#define SDB_REG_TO_REGNUM(value)     (value)
d101 4
a104 4
static unsigned local_n_btmask;
static unsigned local_n_btshft;
static unsigned local_n_tmask;
static unsigned local_n_tshift;
d110 1
a110 1

d116 3
a118 3
static unsigned local_linesz;
static unsigned local_symesz;
static unsigned local_auxesz;
d131 2
a132 2
struct complaint ef_complaint =
{"Unmatched .ef symbol(s) ignored starting at symnum %d", 0, 0};
d134 2
a135 2
struct complaint ef_stack_complaint =
{"`.ef' symbol without matching `.bf' symbol ignored starting at symnum %d", 0, 0};
d137 2
a138 2
struct complaint eb_stack_complaint =
{"`.eb' symbol without matching `.bb' symbol ignored starting at symnum %d", 0, 0};
d141 1
a141 1
{"`.bf' symbol %d has no aux entry", 0, 0};
d144 1
a144 1
{"`.ef' symbol %d has no aux entry", 0, 0};
d147 1
a147 1
{"Line number pointer %d lower than start of line numbers", 0, 0};
d150 1
a150 1
{"Unexpected type for symbol %s", 0, 0};
d153 1
a153 1
{"Bad n_sclass for symbol %s", 0, 0};
d156 1
a156 1
{"Blocks out of order at address %x", 0, 0};
d159 1
a159 1
{"Symbol table entry for %s has bad tagndx value", 0, 0};
d161 2
a162 2
struct complaint eb_complaint =
{"Mismatched .eb symbol ignored starting at symnum %d", 0, 0};
d166 9
a174 10
struct coff_symbol
  {
    char *c_name;
    int c_symnum;		/* symbol number of this entry */
    int c_naux;			/* 0 if syment only, 1 if syment + auxent, etc */
    long c_value;
    int c_sclass;
    int c_secnum;
    unsigned int c_type;
  };
d289 1
a289 1
	if (!isdigit (*s))
d304 2
a305 2
	     in coff_symfile_read, at which point we no longer need
	     the information.  */
d314 4
a317 5
struct find_targ_sec_arg
  {
    int targ_index;
    asection **resultp;
  };
d321 1
a321 2
static void
find_targ_sec (abfd, sect, obj)
d326 1
a326 1
  struct find_targ_sec_arg *args = (struct find_targ_sec_arg *) obj;
d394 1
a394 1
      if (index /* is still */  >= type_vector_length)
d401 1
a401 1
	 (type_vector_length - old_vector_length) * sizeof (struct type *));
d434 1
a434 1
     char *name;
d437 10
a446 10
  /* We fill in the filename later.  start_symtab puts
     this pointer into last_source_file and we put it in
     subfiles->name, which end_symtab frees; that's why
     it must be malloc'd.  */
		 savestring (name, strlen (name)),
  /* We never know the directory name for COFF.  */
		 NULL,
  /* The start address is irrelevant, since we set
     last_source_start_addr in coff_end_symtab.  */
		 0);
d457 3
a459 3
     char *name;
     CORE_ADDR start_addr;
     unsigned int size;
d467 2
a468 2
  if (current_objfile->ei.entry_point >= current_source_start_addr &&
      current_objfile->ei.entry_point < current_source_end_addr)
d470 2
a471 2
      current_objfile->ei.entry_file_lowpc = current_source_start_addr;
      current_objfile->ei.entry_file_highpc = current_source_end_addr;
d505 1
a505 2
  if (name[0] == '@@')
    return;
d570 1
a570 1
  info = (struct coff_symfile_info *) vpinfo;
d610 1
a610 1
  info = (struct coff_symfile_info *) objfile->sym_private;
d612 1
a612 1
  symfile_bfd = abfd;		/* Kludge for swap routines */
d615 4
a618 4
  num_symbols = bfd_get_symcount (abfd);	/* How many syms */
  symtab_offset = cdata->sym_filepos;	/* Symbol table file offset */
  stringtab_offset = symtab_offset +	/* String table file offset */
    num_symbols * cdata->local_symesz;
d624 1
a624 1
  local_n_tmask = cdata->local_n_tmask;
d626 3
a628 3
  local_linesz = cdata->local_linesz;
  local_symesz = cdata->local_symesz;
  local_auxesz = cdata->local_auxesz;
d633 1
a633 1
    (cdata->local_symesz + cdata->local_auxesz);
d652 1
a652 1
  val = init_lineno (abfd, info->min_lineno_offset,
d678 1
a678 1
    for (s = objfile->symtabs; s != NULL; s = s->next)
d691 1
a691 1
      if (!info->stabstrsect)
d697 1
a697 1
	   "The file has a `.stabs' section, but no `.stabstr' section.\n"),
d703 1
a703 1
         bfd_get_section_contents?  */
d734 1
a734 1
  if (objfile->sym_private != NULL)
d736 1
a736 1
      mfree (objfile->md, objfile->sym_private);
d739 1
a740 1

d803 1
a803 1
  if (type_vector)		/* Get rid of previous one */
d851 9
a859 9
	case C_EFCN:
	case C_EXTDEF:
	case C_ULABEL:
	case C_USTATIC:
	case C_LINE:
	case C_ALIAS:
	case C_HIDDEN:
	  complain (&bad_sclass_complaint, cs->c_name);
	  break;
d861 8
a868 8
	case C_FILE:
	  /* c_value field contains symnum of next .file entry in table
	     or symnum of first global after last .file.  */
	  next_file_symnum = cs->c_value;
	  if (cs->c_naux > 0)
	    filestring = coff_getfilename (&main_aux);
	  else
	    filestring = "";
d870 9
a878 9
	  /* Complete symbol table for last object file
	     containing debugging information.  */
	  if (last_source_file)
	    {
	      coff_end_symtab (objfile);
	      coff_start_symtab (filestring);
	    }
	  in_source_file = 1;
	  break;
d883 12
a894 13
	case C_LABEL:
	  /* However, labels within a function can make weird backtraces,
	     so filter them out (from phdm@@macqel.be). */
	  if (within_function)
	    break;
	case C_STAT:
	case C_THUMBLABEL:
	case C_THUMBSTAT:
	case C_THUMBSTATFUNC:
	  if (cs->c_name[0] == '.')
	    {
	      if (STREQ (cs->c_name, ".text"))
		{
d902 1
a902 1
		    cs->c_value + ANOFFSET (section_offsets, SECT_OFF_TEXT),
d906 15
a920 1
	      /* flush rest of '.' symbols */
d922 14
a935 28
	    }
	  else if (!SDB_TYPE (cs->c_type)
		   && cs->c_name[0] == 'L'
		   && (strncmp (cs->c_name, "LI%", 3) == 0
		       || strncmp (cs->c_name, "LF%", 3) == 0
		       || strncmp (cs->c_name, "LC%", 3) == 0
		       || strncmp (cs->c_name, "LP%", 3) == 0
		       || strncmp (cs->c_name, "LPB%", 4) == 0
		       || strncmp (cs->c_name, "LBB%", 4) == 0
		       || strncmp (cs->c_name, "LBE%", 4) == 0
		       || strncmp (cs->c_name, "LPBX%", 5) == 0))
	    /* At least on a 3b1, gcc generates swbeg and string labels
	       that look like this.  Ignore them.  */
	    break;
	  /* fall in for static symbols that don't start with '.' */
	case C_THUMBEXT:
	case C_THUMBEXTFUNC:
	case C_EXT:
	  {
	    /* Record it in the minimal symbols regardless of
	       SDB_TYPE.  This parallels what we do for other debug
	       formats, and probably is needed to make
	       print_address_symbolic work right without the (now
	       gone) "set fast-symbolic-addr off" kludge.  */

	    /* FIXME: should use mst_abs, and not relocate, if absolute.  */
	    enum minimal_symbol_type ms_type;
	    int sec;
d937 25
a961 25
	    if (cs->c_secnum == N_UNDEF)
	      {
		/* This is a common symbol.  See if the target
		   environment knows where it has been relocated to.  */
		CORE_ADDR reladdr;
		if (target_lookup_symbol (cs->c_name, &reladdr))
		  {
		    /* Error in lookup; ignore symbol.  */
		    break;
		  }
		tmpaddr = reladdr;
		/* The address has already been relocated; make sure that
		   objfile_relocate doesn't relocate it again.  */
		sec = -2;
		ms_type = cs->c_sclass == C_EXT
		  || cs->c_sclass == C_THUMBEXT ?
		  mst_bss : mst_file_bss;
	      }
	    else
	      {
		sec = cs_to_section (cs, objfile);
		tmpaddr = cs->c_value;
		if (cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXTFUNC
		    || cs->c_sclass == C_THUMBEXT)
		  tmpaddr += ANOFFSET (section_offsets, sec);
d963 8
a970 8
		switch (sec)
		  {
		  case SECT_OFF_TEXT:
		  case SECT_OFF_RODATA:
		    ms_type =
		      cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXTFUNC
		      || cs->c_sclass == C_THUMBEXT ?
		      mst_text : mst_file_text;
d972 2
a973 2
		    if (tmpaddr & 1)	/* FIXME: delete this line */
		      SMASH_TEXT_ADDRESS (tmpaddr);
d975 16
a990 16
		    break;
		  case SECT_OFF_DATA:
		    ms_type =
		      cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXT ?
		      mst_data : mst_file_data;
		    break;
		  case SECT_OFF_BSS:
		    ms_type =
		      cs->c_sclass == C_EXT || cs->c_sclass == C_THUMBEXT ?
		      mst_data : mst_file_data;
		    break;
		  default:
		    ms_type = mst_unknown;
		    break;
		  }
	      }
d992 3
a994 3
	    if (cs->c_name[0] != '@@' /* Skip tdesc symbols */ )
	      {
		struct minimal_symbol *msym;
d996 2
a997 2
		msym = prim_record_minimal_symbol_and_info
		  (cs->c_name, tmpaddr, ms_type, (char *) cs->c_sclass, sec,
d1000 2
a1001 2
		if (msym)
		  COFF_MAKE_MSYMBOL_SPECIAL (cs->c_sclass, msym);
d1003 34
d1038 1
a1038 1
	    if (SDB_TYPE (cs->c_type))
d1040 11
a1050 8
		struct symbol *sym;
		sym = process_coff_symbol
		  (cs, &main_aux, section_offsets, objfile);
		SYMBOL_VALUE (sym) = tmpaddr;
		SYMBOL_SECTION (sym) = sec;
	      }
	  }
	  break;
d1052 29
a1080 66
	case C_FCN:
	  if (STREQ (cs->c_name, ".bf"))
	    {
	      within_function = 1;

	      /* value contains address of first non-init type code */
	      /* main_aux.x_sym.x_misc.x_lnsz.x_lnno
	         contains line number of '{' } */
	      if (cs->c_naux != 1)
		complain (&bf_no_aux_complaint, cs->c_symnum);
	      fcn_first_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;
	      fcn_first_line_addr = cs->c_value;

	      /* Might want to check that locals are 0 and
	         context_stack_depth is zero, and complain if not.  */

	      depth = 0;
	      new = push_context (depth, fcn_start_addr);
	      fcn_cs_saved.c_name = getsymname (&fcn_sym_saved);
	      new->name =
		process_coff_symbol (&fcn_cs_saved, &fcn_aux_saved,
				     section_offsets, objfile);
	    }
	  else if (STREQ (cs->c_name, ".ef"))
	    {
	      /* the value of .ef is the address of epilogue code;
	         not useful for gdb.  */
	      /* { main_aux.x_sym.x_misc.x_lnsz.x_lnno
	         contains number of lines to '}' */

	      if (context_stack_depth <= 0)
		{		/* We attempted to pop an empty context stack */
		  complain (&ef_stack_complaint, cs->c_symnum);
		  within_function = 0;
		  break;
		}

	      new = pop_context ();
	      /* Stack must be empty now.  */
	      if (context_stack_depth > 0 || new == NULL)
		{
		  complain (&ef_complaint, cs->c_symnum);
		  within_function = 0;
		  break;
		}
	      if (cs->c_naux != 1)
		{
		  complain (&ef_no_aux_complaint, cs->c_symnum);
		  fcn_last_line = 0x7FFFFFFF;
		}
	      else
		{
		  fcn_last_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;
		}
	      /* fcn_first_line is the line number of the opening '{'.
	         Do not record it - because it would affect gdb's idea
	         of the line number of the first statement of the function -
	         except for one-line functions, for which it is also the line
	         number of all the statements and of the closing '}', and
	         for which we do not have any other statement-line-number. */
	      if (fcn_last_line == 1)
		record_line (current_subfile, fcn_first_line,
			     fcn_first_line_addr);
	      else
		enter_linenos (fcn_line_ptr, fcn_first_line, fcn_last_line,
			       section_offsets);
d1082 2
a1083 2
	      finish_block (new->name, &local_symbols, new->old_blocks,
			    new->start_addr,
d1085 10
a1094 10
	      /* This macro should be defined only on
	         machines where the
	         fcn_aux_saved.x_sym.x_misc.x_fsize
	         field is always zero.
	         So use the .bf record information that
	         points to the epilogue and add the size
	         of the epilogue.  */
			    cs->c_value
			    + FUNCTION_EPILOGUE_SIZE
			    + ANOFFSET (section_offsets, SECT_OFF_TEXT),
d1096 3
a1098 3
			    fcn_cs_saved.c_value
			    + fcn_aux_saved.x_sym.x_misc.x_fsize
			    + ANOFFSET (section_offsets, SECT_OFF_TEXT),
d1100 5
a1104 5
			    objfile
		);
	      within_function = 0;
	    }
	  break;
d1106 14
a1119 14
	case C_BLOCK:
	  if (STREQ (cs->c_name, ".bb"))
	    {
	      tmpaddr = cs->c_value;
	      tmpaddr += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	      push_context (++depth, tmpaddr);
	    }
	  else if (STREQ (cs->c_name, ".eb"))
	    {
	      if (context_stack_depth <= 0)
		{		/* We attempted to pop an empty context stack */
		  complain (&eb_stack_complaint, cs->c_symnum);
		  break;
		}
d1121 18
a1138 18
	      new = pop_context ();
	      if (depth-- != new->depth)
		{
		  complain (&eb_complaint, symnum);
		  break;
		}
	      if (local_symbols && context_stack_depth > 0)
		{
		  tmpaddr =
		    cs->c_value + ANOFFSET (section_offsets, SECT_OFF_TEXT);
		  /* Make a block for the local symbols within.  */
		  finish_block (0, &local_symbols, new->old_blocks,
				new->start_addr, tmpaddr, objfile);
		}
	      /* Now pop locals of block just finished.  */
	      local_symbols = new->locals;
	    }
	  break;
d1140 3
a1142 3
	default:
	  process_coff_symbol (cs, &main_aux, section_offsets, objfile);
	  break;
d1165 3
a1167 3
     register struct coff_symbol *cs;
     register struct internal_syment *sym;
     register union internal_auxent *aux;
d1173 1
a1173 1
  bfd_coff_swap_sym_in (symfile_bfd, temp_sym, (char *) sym);
d1177 6
a1183 6
      bfd_coff_swap_aux_in (symfile_bfd, temp_aux, sym->n_type, sym->n_sclass,
			    0, cs->c_naux, (char *) aux);
      /* If more than one aux entry, read past it (only the first aux
         is important). */
      for (i = 1; i < cs->c_naux; i++)
	bfd_read (temp_aux, local_auxesz, 1, nlist_bfd_global);
d1195 1
a1195 1
    printf ("thumb symbol %s, class 0x%x\n", cs->c_name, cs->c_sclass);
d1235 2
a1236 2
     bfd *abfd;
     long offset;
d1252 1
a1252 1
  val = bfd_read ((char *) lengthbuf, sizeof lengthbuf, 1, abfd);
d1254 1
a1254 1

d1264 1
a1264 1
  if (length == sizeof length)	/* Empty table -- just the count */
d1284 1
a1284 1
     struct internal_syment *symbol_entry;
d1286 1
a1286 1
  static char buffer[SYMNMLEN + 1];
d1292 1
a1292 1
         seeing whether offset points to within the stringtab.  */
d1310 1
a1310 1
     union internal_auxent *aux_entry;
d1342 1
a1342 1

d1345 3
a1347 3
     bfd *abfd;
     long offset;
     int size;
d1354 1
a1354 1
  free_linetab ();
d1361 1
a1361 1

d1398 1
a1398 1
    return;
d1404 1
a1404 1
      file_offset += linetab_offset;	/* Try reading at that linetab offset */
d1406 1
a1406 1

d1414 11
a1424 12
  for (;;)
    {
      bfd_coff_swap_lineno_in (symfile_bfd, rawptr, &lptr);
      rawptr += local_linesz;
      /* The next function, or the sentinel, will have L_LNNO32 zero; we exit. */
      if (L_LNNO32 (&lptr) && L_LNNO32 (&lptr) <= last_line)
	record_line (current_subfile, first_line + L_LNNO32 (&lptr),
		     lptr.l_addr.l_paddr
		     + ANOFFSET (section_offsets, SECT_OFF_TEXT));
      else
	break;
    }
d1429 2
a1430 2
     struct type *type;
     struct type *real_type;
d1460 1
a1460 1

d1466 3
a1468 3
         Remove syms from the chain when their types are stored,
         but search the whole chain, as there may be several syms
         from different files with the same name.  */
d1478 1
a1478 1

d1493 1
a1493 1

d1495 1
a1495 1

d1523 2
a1524 2
  = (struct symbol *) obstack_alloc (&objfile->symbol_obstack,
				     sizeof (struct symbol));
d1543 2
a1544 2
      SYMBOL_TYPE (sym) =
	lookup_function_type (decode_function_type (cs, cs->c_type, aux));
d1559 2
a1560 2
	case C_NULL:
	  break;
d1562 4
a1565 4
	case C_AUTO:
	  SYMBOL_CLASS (sym) = LOC_LOCAL;
	  add_symbol_to_list (sym, &local_symbols);
	  break;
d1567 8
a1574 8
	case C_THUMBEXT:
	case C_THUMBEXTFUNC:
	case C_EXT:
	  SYMBOL_CLASS (sym) = LOC_STATIC;
	  SYMBOL_VALUE_ADDRESS (sym) = (CORE_ADDR) cs->c_value;
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	  add_symbol_to_list (sym, &global_symbols);
	  break;
d1576 7
a1582 8
	case C_THUMBSTAT:
	case C_THUMBSTATFUNC:
	case C_STAT:
	  SYMBOL_CLASS (sym) = LOC_STATIC;
	  SYMBOL_VALUE_ADDRESS (sym) = (CORE_ADDR) cs->c_value;
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	  if (within_function)
	    {
d1586 1
a1586 2
	  else
	    {
d1590 1
a1590 1
	  break;
d1593 1
a1593 1
	case C_GLBLREG:
d1595 5
a1599 5
	case C_REG:
	  SYMBOL_CLASS (sym) = LOC_REGISTER;
	  SYMBOL_VALUE (sym) = SDB_REG_TO_REGNUM (cs->c_value);
	  add_symbol_to_list (sym, &local_symbols);
	  break;
d1601 3
a1603 3
	case C_THUMBLABEL:
	case C_LABEL:
	  break;
d1605 3
a1607 3
	case C_ARG:
	  SYMBOL_CLASS (sym) = LOC_ARG;
	  add_symbol_to_list (sym, &local_symbols);
d1609 17
a1625 17
	  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
	    {
	      /* If PCC says a parameter is a short or a char,
	         aligned on an int boundary, realign it to the
	         "little end" of the int.  */
	      struct type *temptype;
	      temptype = lookup_fundamental_type (current_objfile,
						  FT_INTEGER);
	      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (temptype)
		  && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT
		  && 0 == SYMBOL_VALUE (sym) % TYPE_LENGTH (temptype))
		{
		  SYMBOL_VALUE (sym) +=
		    TYPE_LENGTH (temptype)
		    - TYPE_LENGTH (SYMBOL_TYPE (sym));
		}
	    }
d1627 1
a1627 1
	  break;
d1629 4
a1632 4
	case C_REGPARM:
	  SYMBOL_CLASS (sym) = LOC_REGPARM;
	  SYMBOL_VALUE (sym) = SDB_REG_TO_REGNUM (cs->c_value);
	  add_symbol_to_list (sym, &local_symbols);
d1634 2
a1635 10
	  /* FIXME:  This should retain the current type, since it's just
	     a register value.  gnu@@adobe, 26Feb93 */
	  {
	    /* If PCC says a parameter is a short or a char,
	       it is really an int.  */
	    struct type *temptype;
	    temptype =
	      lookup_fundamental_type (current_objfile, FT_INTEGER);
	    if (TYPE_LENGTH (SYMBOL_TYPE (sym)) < TYPE_LENGTH (temptype)
		&& TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT)
d1637 14
a1650 5
		SYMBOL_TYPE (sym) =
		  (TYPE_UNSIGNED (SYMBOL_TYPE (sym))
		   ? lookup_fundamental_type (current_objfile,
					      FT_UNSIGNED_INTEGER)
		   : temptype);
a1651 1
	  }
d1653 5
a1657 1
	  break;
d1659 30
a1688 34
	case C_TPDEF:
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;

	  /* If type has no name, give it one */
	  if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
	    {
	      if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR
		  || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FUNC)
		{
		  /* If we are giving a name to a type such as "pointer to
		     foo" or "function returning foo", we better not set
		     the TYPE_NAME.  If the program contains "typedef char
		     *caddr_t;", we don't want all variables of type char
		     * to print as caddr_t.  This is not just a
		     consequence of GDB's type management; CC and GCC (at
		     least through version 2.4) both output variables of
		     either type char * or caddr_t with the type
		     refering to the C_TPDEF symbol for caddr_t.  If a future
		     compiler cleans this up it GDB is not ready for it
		     yet, but if it becomes ready we somehow need to
		     disable this check (without breaking the PCC/GCC2.4
		     case).

		     Sigh.

		     Fortunately, this check seems not to be necessary
		     for anything except pointers or functions.  */
		  ;
		}
	      else
		TYPE_NAME (SYMBOL_TYPE (sym)) =
		  concat (SYMBOL_NAME (sym), NULL);
	    }
d1690 3
a1692 3
	  /* Ignore vendor section for Harris CX/UX targets. */
	  else if (cs->c_name[0] == '$')
	    break;
d1695 11
a1705 11
	  /* Keep track of any type which points to empty structured type,
	     so it can be filled from a definition from another file.  A
	     simple forward reference (TYPE_CODE_UNDEF) is not an
	     empty structured type, though; the forward references
	     work themselves out via the magic of coff_lookup_type.  */
	  if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR &&
	      TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))) == 0 &&
	      TYPE_CODE (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))) !=
	      TYPE_CODE_UNDEF)
	    {
	      register int i = hashname (SYMBOL_NAME (sym));
d1707 5
a1711 5
	      SYMBOL_VALUE_CHAIN (sym) = opaque_type_chain[i];
	      opaque_type_chain[i] = sym;
	    }
	  add_symbol_to_list (sym, &file_symbols);
	  break;
d1713 15
a1727 15
	case C_STRTAG:
	case C_UNTAG:
	case C_ENTAG:
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	  SYMBOL_NAMESPACE (sym) = STRUCT_NAMESPACE;

	  /* Some compilers try to be helpful by inventing "fake"
	     names for anonymous enums, structures, and unions, like
	     "~0fake" or ".0fake".  Thanks, but no thanks... */
	  if (TYPE_TAG_NAME (SYMBOL_TYPE (sym)) == 0)
	    if (SYMBOL_NAME (sym) != NULL
		&& *SYMBOL_NAME (sym) != '~'
		&& *SYMBOL_NAME (sym) != '.')
	      TYPE_TAG_NAME (SYMBOL_TYPE (sym)) =
		concat (SYMBOL_NAME (sym), NULL);
d1729 2
a1730 2
	  add_symbol_to_list (sym, &file_symbols);
	  break;
d1732 2
a1733 2
	default:
	  break;
d1829 1
a1829 1
    cs->c_naux = 0;		/* auxent refers to function, not base type */
d1846 3
a1848 3
    case T_NULL:
      /* shows up with "void (*foo)();" structure members */
      return lookup_fundamental_type (current_objfile, FT_VOID);
d1853 3
a1855 3
    case T_ARG:
      /* Shows up in DGUX, I think.  Not sure where.  */
      return lookup_fundamental_type (current_objfile, FT_VOID);	/* shouldn't show up here */
d1860 3
a1862 3
    case T_VOID:
      /* Intel 960 COFF has this symbol and meaning.  */
      return lookup_fundamental_type (current_objfile, FT_VOID);
d1865 5
a1869 2
    case T_CHAR:
      return lookup_fundamental_type (current_objfile, FT_CHAR);
d1871 2
a1872 2
    case T_SHORT:
      return lookup_fundamental_type (current_objfile, FT_SHORT);
d1874 6
a1879 2
    case T_INT:
      return lookup_fundamental_type (current_objfile, FT_INTEGER);
d1881 2
a1882 6
    case T_LONG:
      if (cs->c_sclass == C_FIELD
	  && aux->x_sym.x_misc.x_lnsz.x_size > TARGET_LONG_BIT)
	return lookup_fundamental_type (current_objfile, FT_LONG_LONG);
      else
	return lookup_fundamental_type (current_objfile, FT_LONG);
d1884 2
a1885 2
    case T_FLOAT:
      return lookup_fundamental_type (current_objfile, FT_FLOAT);
d1887 2
a1888 2
    case T_DOUBLE:
      return lookup_fundamental_type (current_objfile, FT_DBL_PREC_FLOAT);
d1890 23
a1912 2
    case T_LNGDBL:
      return lookup_fundamental_type (current_objfile, FT_EXT_PREC_FLOAT);
d1914 23
a1936 23
    case T_STRUCT:
      if (cs->c_naux != 1)
	{
	  /* anonymous structure type */
	  type = coff_alloc_type (cs->c_symnum);
	  TYPE_CODE (type) = TYPE_CODE_STRUCT;
	  TYPE_NAME (type) = NULL;
	  /* This used to set the tag to "<opaque>".  But I think setting it
	     to NULL is right, and the printing code can print it as
	     "struct {...}".  */
	  TYPE_TAG_NAME (type) = NULL;
	  INIT_CPLUS_SPECIFIC (type);
	  TYPE_LENGTH (type) = 0;
	  TYPE_FIELDS (type) = 0;
	  TYPE_NFIELDS (type) = 0;
	}
      else
	{
	  type = coff_read_struct_type (cs->c_symnum,
					aux->x_sym.x_misc.x_lnsz.x_size,
				      aux->x_sym.x_fcnary.x_fcn.x_endndx.l);
	}
      return type;
d1938 18
a1955 18
    case T_UNION:
      if (cs->c_naux != 1)
	{
	  /* anonymous union type */
	  type = coff_alloc_type (cs->c_symnum);
	  TYPE_NAME (type) = NULL;
	  /* This used to set the tag to "<opaque>".  But I think setting it
	     to NULL is right, and the printing code can print it as
	     "union {...}".  */
	  TYPE_TAG_NAME (type) = NULL;
	  INIT_CPLUS_SPECIFIC (type);
	  TYPE_LENGTH (type) = 0;
	  TYPE_FIELDS (type) = 0;
	  TYPE_NFIELDS (type) = 0;
	}
      else
	{
	  type = coff_read_struct_type (cs->c_symnum,
d1957 3
a1959 4
				      aux->x_sym.x_fcnary.x_fcn.x_endndx.l);
	}
      TYPE_CODE (type) = TYPE_CODE_UNION;
      return type;
d1961 3
a1963 26
    case T_ENUM:
      if (cs->c_naux != 1)
	{
	  /* anonymous enum type */
	  type = coff_alloc_type (cs->c_symnum);
	  TYPE_CODE (type) = TYPE_CODE_ENUM;
	  TYPE_NAME (type) = NULL;
	  /* This used to set the tag to "<opaque>".  But I think setting it
	     to NULL is right, and the printing code can print it as
	     "enum {...}".  */
	  TYPE_TAG_NAME (type) = NULL;
	  TYPE_LENGTH (type) = 0;
	  TYPE_FIELDS (type) = 0;
	  TYPE_NFIELDS (type) = 0;
	}
      else
	{
	  type = coff_read_enum_type (cs->c_symnum,
				      aux->x_sym.x_misc.x_lnsz.x_size,
				      aux->x_sym.x_fcnary.x_fcn.x_endndx.l);
	}
      return type;

    case T_MOE:
      /* shouldn't show up here */
      break;
d1965 2
a1966 2
    case T_UCHAR:
      return lookup_fundamental_type (current_objfile, FT_UNSIGNED_CHAR);
d1968 2
a1969 2
    case T_USHORT:
      return lookup_fundamental_type (current_objfile, FT_UNSIGNED_SHORT);
d1971 2
a1972 2
    case T_UINT:
      return lookup_fundamental_type (current_objfile, FT_UNSIGNED_INTEGER);
d1974 6
a1979 6
    case T_ULONG:
      if (cs->c_sclass == C_FIELD
	  && aux->x_sym.x_misc.x_lnsz.x_size > TARGET_LONG_BIT)
	return lookup_fundamental_type (current_objfile, FT_UNSIGNED_LONG_LONG);
      else
	return lookup_fundamental_type (current_objfile, FT_UNSIGNED_LONG);
d2016 1
a2016 1
  INIT_CPLUS_SPECIFIC (type);
d2027 2
a2028 2
	case C_MOS:
	case C_MOU:
d2030 15
a2044 15
	  /* Get space to record the next field's data.  */
	  new = (struct nextfield *) alloca (sizeof (struct nextfield));
	  new->next = list;
	  list = new;

	  /* Save the data.  */
	  list->field.name =
	    obsavestring (name,
			  strlen (name),
			  &current_objfile->symbol_obstack);
	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux);
	  FIELD_BITPOS (list->field) = 8 * ms->c_value;
	  FIELD_BITSIZE (list->field) = 0;
	  nfields++;
	  break;
d2046 1
a2046 1
	case C_FIELD:
d2048 15
a2062 15
	  /* Get space to record the next field's data.  */
	  new = (struct nextfield *) alloca (sizeof (struct nextfield));
	  new->next = list;
	  list = new;

	  /* Save the data.  */
	  list->field.name =
	    obsavestring (name,
			  strlen (name),
			  &current_objfile->symbol_obstack);
	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux);
	  FIELD_BITPOS (list->field) = ms->c_value;
	  FIELD_BITSIZE (list->field) = sub_aux.x_sym.x_misc.x_lnsz.x_size;
	  nfields++;
	  break;
d2064 3
a2066 3
	case C_EOS:
	  done = 1;
	  break;
d2125 15
a2139 15
	case C_MOE:
	  sym = (struct symbol *) obstack_alloc
	    (&current_objfile->symbol_obstack,
	     sizeof (struct symbol));
	  memset (sym, 0, sizeof (struct symbol));

	  SYMBOL_NAME (sym) =
	    obsavestring (name, strlen (name),
			  &current_objfile->symbol_obstack);
	  SYMBOL_CLASS (sym) = LOC_CONST;
	  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
	  SYMBOL_VALUE (sym) = ms->c_value;
	  add_symbol_to_list (sym, symlist);
	  nsyms++;
	  break;
d2141 6
a2146 6
	case C_EOS:
	  /* Sometimes the linker (on 386/ix 2.0.2 at least) screws
	     up the count of how many symbols to read.  So stop
	     on .eos.  */
	  done = 1;
	  break;
d2155 1
a2155 1
    TYPE_LENGTH (type) = TARGET_INT_BIT / TARGET_CHAR_BIT;	/* Assume ints */
d2175 1
a2175 1
      for (; j < syms->nsyms; j++, n++)
d2200 4
a2203 4
  coff_new_init,		/* sym_new_init: init anything gbl to entire symtab */
  coff_symfile_init,		/* sym_init: read initial info, setup for sym_read() */
  coff_symfile_read,		/* sym_read: read a symbol file into symtab */
  coff_symfile_finish,		/* sym_finish: finished with file, cleanup */
d2206 1
a2206 1
  NULL				/* next: pointer to next struct sym_fns */
@


1.1.1.7
log
@import gdb-1999-08-09 snapshot
@
text
@d196 1
d221 2
a222 1
static void coff_symtab_read PARAMS ((long, int, struct objfile *));
d230 2
a231 1
static void coff_symfile_read PARAMS ((struct objfile *, int));
d599 1
a599 1
coff_symfile_read (objfile, mainline)
d601 1
d676 2
a677 1
  coff_symtab_read ((long) symtab_offset, num_symbols, objfile);
d715 1
d753 1
a753 1
coff_symtab_read (symtab_offset, nsyms, objfile)
d756 1
d844 1
a844 1
	  tmpaddr = cs->c_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d909 1
a909 1
		    cs->c_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT),
d968 1
a968 1
		  tmpaddr += ANOFFSET (objfile->section_offsets, sec);
d1015 1
a1015 1
		  (cs, &main_aux, objfile);
d1042 2
a1043 1
		process_coff_symbol (&fcn_cs_saved, &fcn_aux_saved, objfile);
d1087 1
a1087 1
			       objfile->section_offsets);
d1101 1
a1101 1
			    + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT),
d1105 1
a1105 1
			    + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT),
d1117 1
a1117 1
	      tmpaddr += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d1137 1
a1137 1
		    cs->c_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d1148 1
a1148 1
	  process_coff_symbol (cs, &main_aux, objfile);
d1524 1
a1524 1
process_coff_symbol (cs, aux, objfile)
d1527 1
d1550 1
a1550 1
      SYMBOL_VALUE (sym) += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d1580 1
a1580 1
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d1589 1
a1589 1
	  SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d2214 2
a2215 1
  default_symfile_offsets,	/* sym_offsets:  xlate external to internal form */
@


1.1.1.8
log
@import gdb-1999-08-16 snapshot
@
text
@a178 2
extern void stabsread_clear_cache PARAMS ((void));

a737 3

  /* Let stabs reader clean up */
  stabsread_clear_cache ();
@


1.1.1.9
log
@import gdb-1999-09-08 snapshot
@
text
@d204 1
a204 1
static void enter_linenos PARAMS ((long, int, int, struct objfile *));
d1084 1
a1084 1
			       objfile);
d1392 1
a1392 1
enter_linenos (file_offset, first_line, last_line, objfile)
d1396 1
a1396 1
     struct objfile *objfile;
d1426 1
a1426 1
		     + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT));
@


1.1.1.10
log
@import gdb-1999-12-06 snapshot
@
text
@d613 1
a613 3
  int len;
  char * target;
  
d646 1
a646 3
  pe_file = !
    (   strncmp (bfd_get_target (objfile->obfd), "pe", 2)
      | strncmp (bfd_get_target (objfile->obfd), "epoc-pe", 7));
@


1.1.1.11
log
@import gdb-2000-01-10 snapshot
@
text
@d648 3
a650 3
  pe_file =
    strncmp (bfd_get_target (objfile->obfd), "pe", 2) == 0
    || strncmp (bfd_get_target (objfile->obfd), "epoc-pe", 7) == 0;
@


