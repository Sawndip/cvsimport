head	1.4;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.4
	gdb_7_6-branch:1.4.0.4
	gdb_7_5-branch:1.4.0.2
	gdb_7_4-branch:1.3.0.28
	gdb_7_3-branch:1.3.0.26
	gdb_7_1-branch:1.3.0.24
	gdb_7_0-branch:1.3.0.22
	arc-sim-20090309:1.3
	arc-insight_6_8-branch:1.3.0.20
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.18
	insight_6_8-branchpoint:1.3
	gdb_6_8-branch:1.3.0.16
	insight_6_6-20070208-release:1.3
	gdb_6_6-branch:1.3.0.14
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb_6_5-branch:1.3.0.12
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb_6_4-branch:1.3.0.10
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb_6_1-2004-04-05-release:1.3
	gdb_6_1-branch:1.3.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	gdb_6_0-2003-10-04-release:1.3
	gdb_6_0-branch:1.3.0.6
	gdb_6_0-2003-06-23-branchpoint:1.3
	gdb_5_3-2002-12-12-release:1.3
	gdb_5_3-branch:1.3.0.4
	gdb_5_3-2002-09-04-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.2
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	LIBGUI_TCL_8_3:1.1.1.1
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2012.08.08.13.34.56;	author rosch;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.08.22.34.48;	author irox;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.13.17.53.52;	author kseitz;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.47;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.47;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@   * src/subcommand.c,src/subcommand.h
   (subcommand_implementation,ide_create_command_with_subcommands):
   Make some params const to match tcl/tk changes.
   * src/tclcursor.c (get_cursor_size,get_cursor_position): Ditto.
   * src/tclmsgbox.c: Include windows.h early.
   (msgbox_init,msgbox_exit): Take care about encodings to windows functions.
   (msgbox_thread): Use correct api call here.
   (msgbox_internal,msgbox): Make CONST84 where needed.
   * src/tclwinmode.c (seterrormode_command): Ditto.
   * src/tclshellexe.c (shell_execute_command): Ditto. Plus correct cast return
   value to shut up 64bit gcc.
   * src/tclwinfont.c (win_choose_font): Make CONST84 where needed and
   use dedicated windows api.
   * src/tclwinprint.c (winprint_page_setup_command): Make const/CONST84 where needed.
   (winprint_print_text_options,winprint_print_text_invoke,winprint_print_command): Ditto.
   (winprint_print_text_invoke,): Ditto.
   (winprint_start,winprint_print_commandwinprint_abort_command): use dedicated windows structs/api.
   * src/tkTable.c: Obsolete old dprint stuff.
   (StringifyObjects,Tk_TableObjCmd,TableWidgetObjCmd,TableConfigure,TableFetchSelection): adjust const.
   (selCmdNames,commandNames,updateOpts): make const.
   * src/tkTable.h: Adjust windows includes. include stdint.h. define CONST86 if missing. Deine
   PTR2INT/INT2PTR taken from tcl if missing. Make some functions const.
   * src/tkTableCmds.c: Make bdCmdNames and clearnames CONST84.
   * src/tkTableEdit.c: Make modCmdNamesand rcCmdNames CONST84.
   * src/tkTableTag.c: Make tagCmdNames CONST84.
   (TableTagGetEntry): Make param argcv CONST84.
   (TableInitTags): Make some internal strings CONST84.
   (FindRowColTag): Ditto.
   (Table_TagCmd): Ditto.
   * src/tkTableUtil.c (TableOptionBdSet):Ditto.
   (TableOptionBdGet): Make retval CONST86. Fix ptr/int arithmetics.
   (Cmd_OptionSet): Make param value CONST84.
   (Cmd_OptionGet): Make retval CONST86.
   * src/tkTableWin.c (StickyPrintProc): Ditto. Make some internal strings CONST84.
   (StickyParseProc): Make param value CONST84.
   * src/tkWarpPointer.c: Include windows.h ahead of tk.h.
   (WarpPointer): Remove unused var.
   * src/tkWinPrintCanvas.c (PrintCanvasCmd): use dedicated windows structs/api.
   Fix casting.
   * src/tkWinPrintText.c (PrintTextCmd): Add #if case for compiling against tcl 8.5 and up.
   use dedicated windows structs/api.
   (ide_delete_print_text_command): Delete unused static function.
   (DisplayDLineToDrawable): Add #if case for compiling against tcl 8.5 and up. Fix casting.
@
text
@/* 
 * tkTableWin.c --
 *
 *	This module implements embedded windows for table widgets.
 *	Much of this code is adapted from tkGrid.c and tkTextWind.c.
 *
 * Copyright (c) 1998-2000 Jeffrey Hobbs
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkTableWin.c,v 1.3 2000/08/31 02:09:18 hobbs Exp $
 */

#include "tkTable.h"

static int	StickyParseProc _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, Tk_Window tkwin, CONST84 char *value,
			    char *widgRec, int offset));
static CONST86 char *	StickyPrintProc _ANSI_ARGS_((ClientData clientData,
			    Tk_Window tkwin, char *widgRec, int offset,
			    Tcl_FreeProc **freeProcPtr));

static void	EmbWinLostSlaveProc _ANSI_ARGS_((ClientData clientData,
						Tk_Window tkwin));
static void	EmbWinRequestProc _ANSI_ARGS_((ClientData clientData,
					       Tk_Window tkwin));

static void	EmbWinCleanup _ANSI_ARGS_((Table *tablePtr,
					   TableEmbWindow *ewPtr));
static int	EmbWinConfigure _ANSI_ARGS_((Table *tablePtr,
					     TableEmbWindow *ewPtr,
					     int objc, Tcl_Obj *CONST objv[]));
static void	EmbWinStructureProc _ANSI_ARGS_((ClientData clientData,
						 XEvent *eventPtr));
static void	EmbWinUnmapNow _ANSI_ARGS_((Tk_Window ewTkwin,
					    Tk_Window tkwin));

static Tk_GeomMgr tableGeomType = {
    "table",			/* name */
    EmbWinRequestProc,		/* requestProc */
    EmbWinLostSlaveProc,	/* lostSlaveProc */
};

/* windows subcommands */
static const char *winCmdNames[] = {
    "cget", "configure", "delete", "move", "names", (char *) NULL
};
enum winCommand {
    WIN_CGET, WIN_CONFIGURE, WIN_DELETE, WIN_MOVE, WIN_NAMES
};

/* Flag values for "sticky"ness  The 16 combinations subsume the packer's
 * notion of anchor and fill.
 *
 * STICK_NORTH  	This window sticks to the top of its cavity.
 * STICK_EAST		This window sticks to the right edge of its cavity.
 * STICK_SOUTH		This window sticks to the bottom of its cavity.
 * STICK_WEST		This window sticks to the left edge of its cavity.
 */

#define STICK_NORTH	(1<<0)
#define STICK_EAST	(1<<1)
#define STICK_SOUTH	(1<<2)
#define STICK_WEST	(1<<3)

/*
 * The default specification for configuring embedded windows
 * Done like this to make the command line parsing easy
 */

static Tk_CustomOption stickyOption	= { StickyParseProc, StickyPrintProc,
					    (ClientData) NULL };
static Tk_CustomOption tagBdOpt		= { TableOptionBdSet, TableOptionBdGet,
					    (ClientData) BD_TABLE_WIN };

static Tk_ConfigSpec winConfigSpecs[] = {
  {TK_CONFIG_BORDER, "-background", "background", "Background", NULL,
   Tk_Offset(TableEmbWindow, bg),
   TK_CONFIG_DONT_SET_DEFAULT|TK_CONFIG_NULL_OK },
  {TK_CONFIG_SYNONYM, "-bd", "borderWidth", (char *)NULL, (char *)NULL, 0, 0},
  {TK_CONFIG_SYNONYM, "-bg", "background", (char *)NULL, (char *)NULL, 0, 0},
  {TK_CONFIG_CUSTOM, "-borderwidth", "borderWidth", "BorderWidth", "",
   0 /* no offset */,
   TK_CONFIG_DONT_SET_DEFAULT|TK_CONFIG_NULL_OK, &tagBdOpt },
  {TK_CONFIG_STRING, "-create", (char *)NULL, (char *)NULL, (char *)NULL,
   Tk_Offset(TableEmbWindow, create),
   TK_CONFIG_DONT_SET_DEFAULT|TK_CONFIG_NULL_OK },
  {TK_CONFIG_PIXELS, "-padx", (char *)NULL, (char *)NULL, (char *)NULL,
   Tk_Offset(TableEmbWindow, padX), TK_CONFIG_DONT_SET_DEFAULT },
  {TK_CONFIG_PIXELS, "-pady", (char *)NULL, (char *)NULL, (char *)NULL,
   Tk_Offset(TableEmbWindow, padY), TK_CONFIG_DONT_SET_DEFAULT },
  {TK_CONFIG_CUSTOM, "-sticky", (char *)NULL, (char *)NULL, (char *)NULL,
   Tk_Offset(TableEmbWindow, sticky), TK_CONFIG_DONT_SET_DEFAULT,
   &stickyOption},
  {TK_CONFIG_RELIEF, "-relief", "relief", "Relief", NULL,
   Tk_Offset(TableEmbWindow, relief), 0 },
  {TK_CONFIG_WINDOW, "-window", (char *)NULL, (char *)NULL, (char *)NULL,
   Tk_Offset(TableEmbWindow, tkwin),
   TK_CONFIG_DONT_SET_DEFAULT|TK_CONFIG_NULL_OK },
  {TK_CONFIG_END, (char *)NULL, (char *)NULL, (char *)NULL,
   (char *)NULL, 0, 0 }
};

/*
 *----------------------------------------------------------------------
 *
 * StickyPrintProc --
 *	Converts the internal boolean combination of "sticky" bits onto
 *	a TCL string element containing zero or more of n, s, e, or w.
 *
 * Results:
 *	A string is placed into the "result" pointer.
 *
 * Side effects:
 *	none.
 *
 *----------------------------------------------------------------------
 */
static CONST86 char *
StickyPrintProc(clientData, tkwin, widgRec, offset, freeProcPtr)
    ClientData clientData;		/* Ignored. */
    Tk_Window tkwin;			/* Window for text widget. */
    char *widgRec;			/* Pointer to TkTextEmbWindow
					 * structure. */
    int offset;				/* Ignored. */
    Tcl_FreeProc **freeProcPtr;		/* Pointer to variable to fill in with
					 * information about how to reclaim
					 * storage for return string. */
{
    int flags = ((TableEmbWindow *) widgRec)->sticky;
    int count = 0;
    char *result = (char *) ckalloc(5*sizeof(char));

    if (flags&STICK_NORTH) result[count++] = 'n';
    if (flags&STICK_EAST)  result[count++] = 'e';
    if (flags&STICK_SOUTH) result[count++] = 's';
    if (flags&STICK_WEST)  result[count++] = 'w';

    *freeProcPtr = TCL_DYNAMIC;
    result[count] = '\0';
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * StringParseProc --
 *	Converts an ascii string representing a widgets stickyness
 *	into the boolean result.
 *
 * Results:
 *	The boolean combination of the "sticky" bits is retuned.  If an
 *	error occurs, such as an invalid character, -1 is returned instead.
 *
 * Side effects:
 *	none
 *
 *----------------------------------------------------------------------
 */
static int
StickyParseProc(clientData, interp, tkwin, value, widgRec, offset)
    ClientData clientData;		/* Not used.*/
    Tcl_Interp *interp;			/* Used for reporting errors. */
    Tk_Window tkwin;			/* Window for text widget. */
    CONST84 char *value;			/* Value of option. */
    char *widgRec;			/* Pointer to TkTextEmbWindow
					 * structure. */
    int offset;				/* Offset into item (ignored). */
{
    register TableEmbWindow *ewPtr = (TableEmbWindow *) widgRec;
    int sticky = 0;
    char c;

    while ((c = *value++) != '\0') {
	switch (c) {
	case 'n': case 'N': sticky |= STICK_NORTH; break;
	case 'e': case 'E': sticky |= STICK_EAST;  break;
	case 's': case 'S': sticky |= STICK_SOUTH; break;
	case 'w': case 'W': sticky |= STICK_WEST;  break;
	case ' ': case ',': case '\t': case '\r': case '\n': break;
	default:
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
				   "bad sticky value \"", --value,
				   "\": must contain n, s, e or w",
				   (char *) NULL);
	    return TCL_ERROR;
	}
    }
    ewPtr->sticky = sticky;
    return TCL_OK;
}		

/*
 * ckallocs space for a new embedded window structure and clears the structure
 * returns the pointer to the new structure
 */
static TableEmbWindow *
TableNewEmbWindow(Table *tablePtr)
{
    TableEmbWindow *ewPtr = (TableEmbWindow *) ckalloc(sizeof(TableEmbWindow));
    memset((VOID *) ewPtr, 0, sizeof(TableEmbWindow));

    /*
     * Set the values that aren't 0/NULL by default
     */
    ewPtr->tablePtr	= tablePtr;
    ewPtr->relief	= -1;
    ewPtr->padX		= -1;
    ewPtr->padY		= -1;

    return ewPtr;
}

/* 
 *----------------------------------------------------------------------
 *
 * EmbWinCleanup --
 *	Releases resources used by an embedded window before it is freed up.
 *
 * Results:
 *	Window will no longer be valid.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
EmbWinCleanup(Table *tablePtr, TableEmbWindow *ewPtr)
{
    Tk_FreeOptions(winConfigSpecs, (char *) ewPtr, tablePtr->display, 0);
}

/*
 *--------------------------------------------------------------
 *
 * EmbWinDisplay --
 *
 *	This procedure is invoked by TableDisplay for
 *	mapping windows into cells.
 *
 * Results:
 *	Displays or moves window on table screen.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */
void
EmbWinDisplay(Table *tablePtr, Drawable window, TableEmbWindow *ewPtr,
	      TableTag *tagPtr, int x, int y, int width, int height)
{
    Tk_Window tkwin = tablePtr->tkwin;
    Tk_Window ewTkwin = ewPtr->tkwin;
    int diffx=0;	/* Cavity width - slave width. */
    int diffy=0;	/* Cavity hight - slave height. */
    int sticky = ewPtr->sticky;
    int padx, pady;

    if (ewPtr->bg)		tagPtr->bg	= ewPtr->bg;
    if (ewPtr->relief != -1)	tagPtr->relief	= ewPtr->relief;
    if (ewPtr->borders) {
	tagPtr->borderStr	= ewPtr->borderStr;
	tagPtr->borders		= ewPtr->borders;
	tagPtr->bd[0]		= ewPtr->bd[0];
	tagPtr->bd[1]		= ewPtr->bd[1];
	tagPtr->bd[2]		= ewPtr->bd[2];
	tagPtr->bd[3]		= ewPtr->bd[3];
    }

    padx = (ewPtr->padX < 0) ? tablePtr->padX : ewPtr->padX;
    pady = (ewPtr->padY < 0) ? tablePtr->padY : ewPtr->padY;

    x		+= padx;
    width	-= padx*2;
    y		+= pady;
    height	-= pady*2;

    if (width > Tk_ReqWidth(ewPtr->tkwin)) {
	diffx = width - Tk_ReqWidth(ewPtr->tkwin);
	width = Tk_ReqWidth(ewPtr->tkwin);
    }
    if (height > Tk_ReqHeight(ewPtr->tkwin)) {
	diffy = height - Tk_ReqHeight(ewPtr->tkwin);
	height = Tk_ReqHeight(ewPtr->tkwin);
    }
    if (sticky&STICK_EAST && sticky&STICK_WEST) {
	width += diffx;
    }
    if (sticky&STICK_NORTH && sticky&STICK_SOUTH) {
	height += diffy;
    }
    if (!(sticky&STICK_WEST)) {
	x += (sticky&STICK_EAST) ? diffx : diffx/2;
    }
    if (!(sticky&STICK_NORTH)) {
	y += (sticky&STICK_SOUTH) ? diffy : diffy/2;
    }

    /*
     * If we fall below a specific minimum width/height requirement,
     * we just unmap the window
     */
    if (width < 4 || height < 4) {
	if (ewPtr->displayed) {
	    EmbWinUnmapNow(ewTkwin, tkwin);
	}
	return;
    }

    if (tkwin == Tk_Parent(ewTkwin)) {
	if ((x != Tk_X(ewTkwin)) || (y != Tk_Y(ewTkwin))
	    || (width != Tk_Width(ewTkwin))
	    || (height != Tk_Height(ewTkwin))) {
	    Tk_MoveResizeWindow(ewTkwin, x, y, width, height);
	}
	Tk_MapWindow(ewTkwin);
    } else {
	Tk_MaintainGeometry(ewTkwin, tkwin, x, y, width, height);
    }
    ewPtr->displayed = 1;
}

/*
 *--------------------------------------------------------------
 *
 * EmbWinUnmapNow --
 *	Handles unmapping the window depending on parent.
 *	tkwin should be tablePtr->tkwin.
 *	ewTkwin should be ewPtr->tkwin.
 *
 * Results:
 *	Removes the window.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */
static void
EmbWinUnmapNow(Tk_Window ewTkwin, Tk_Window tkwin)
{
    if (tkwin != Tk_Parent(ewTkwin)) {
	Tk_UnmaintainGeometry(ewTkwin, tkwin);
    }
    Tk_UnmapWindow(ewTkwin);
}

/*
 *--------------------------------------------------------------
 *
 * EmbWinUnmap --
 *	This procedure is invoked by TableAdjustParams for
 *	unmapping windows managed moved offscreen.
 *	rlo, ... should be in real coords.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Unmaps embedded windows.
 *
 *--------------------------------------------------------------
 */
void
EmbWinUnmap(Table *tablePtr, int rlo, int rhi, int clo, int chi)
{
    register TableEmbWindow *ewPtr;
    Tcl_HashEntry *entryPtr;
    int row, col, trow, tcol;
    char buf[INDEX_BUFSIZE];

    /*
     * Transform numbers from real to user user coords
     */
    rlo += tablePtr->rowOffset;
    rhi += tablePtr->rowOffset;
    clo += tablePtr->colOffset;
    chi += tablePtr->colOffset;
    for (row = rlo; row <= rhi; row++) {
	for (col = clo; col <= chi; col++) {
	    TableTrueCell(tablePtr, row, col, &trow, &tcol);
	    TableMakeArrayIndex(trow, tcol, buf);
	    entryPtr = Tcl_FindHashEntry(tablePtr->winTable, buf);
	    if (entryPtr != NULL) {
		ewPtr = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);
		if (ewPtr->displayed) {
		    ewPtr->displayed = 0;
		    if (ewPtr->tkwin != NULL && tablePtr->tkwin != NULL) {
			EmbWinUnmapNow(ewPtr->tkwin, tablePtr->tkwin);
		    }
		}
	    }
	}
    }
}

/*
 *--------------------------------------------------------------
 *
 * EmbWinRequestProc --
 *	This procedure is invoked by Tk_GeometryRequest for
 *	windows managed by the Table.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Arranges for tkwin, and all its managed siblings, to
 *	be re-arranged at the next idle point.
 *
 *--------------------------------------------------------------
 */
static void
EmbWinRequestProc(clientData, tkwin)
    ClientData clientData;	/* Table's information about
				 * window that got new preferred
				 * geometry.  */
    Tk_Window tkwin;		/* Other Tk-related information
				 * about the window. */
{
    register TableEmbWindow *ewPtr = (TableEmbWindow *) clientData;

    /*
     * Resize depends on the sticky
     */
    if (ewPtr->displayed && ewPtr->hPtr != NULL) {
	Table *tablePtr = ewPtr->tablePtr;
	int row, col, x, y, width, height;

	TableParseArrayIndex(&row, &col,
			     Tcl_GetHashKey(tablePtr->winTable, ewPtr->hPtr));
	if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
			     col-tablePtr->colOffset, &x, &y, &width, &height,
			     0)) {
	    TableInvalidate(tablePtr, x, y, width, height, 0);
	}
    }
}

static void
EmbWinRemove(TableEmbWindow *ewPtr)
{
    Table *tablePtr = ewPtr->tablePtr;

    if (ewPtr->tkwin != NULL) {
	Tk_DeleteEventHandler(ewPtr->tkwin, StructureNotifyMask,
			      EmbWinStructureProc, (ClientData) ewPtr);
	ewPtr->tkwin = NULL;
    }
    ewPtr->displayed = 0;
    if (tablePtr->tkwin != NULL) {
	int row, col, x, y, width, height;

	TableParseArrayIndex(&row, &col,
			     Tcl_GetHashKey(tablePtr->winTable, ewPtr->hPtr));
	/* this will cause windows removed from the table to actually
	 * cause the associated embdedded window hash data to be removed */
	Tcl_DeleteHashEntry(ewPtr->hPtr);
	if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
			     col-tablePtr->colOffset, &x, &y, &width, &height,
			     0))
	    TableInvalidate(tablePtr, x, y, width, height, 1);
    }
    /* this will cause windows removed from the table to actually
     * cause the associated embdedded window hash data to be removed */
    EmbWinCleanup(tablePtr, ewPtr);
    ckfree((char *) ewPtr);
}

/*
 *--------------------------------------------------------------
 *
 * EmbWinLostSlaveProc --
 *	This procedure is invoked by Tk whenever some other geometry
 *	claims control over a slave that used to be managed by us.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Forgets all table-related information about the slave.
 *
 *--------------------------------------------------------------
 */

static void
EmbWinLostSlaveProc(clientData, tkwin)
    ClientData clientData;	/* Table structure for slave window that
				 * was stolen away. */
    Tk_Window tkwin;		/* Tk's handle for the slave window. */
{
    register TableEmbWindow *ewPtr = (TableEmbWindow *) clientData;

#if 0
    Tcl_CancelIdleCall(EmbWinDelayedUnmap, (ClientData) ewPtr);
#endif
    EmbWinUnmapNow(tkwin, ewPtr->tablePtr->tkwin);
    EmbWinRemove(ewPtr);
}

/*
 *--------------------------------------------------------------
 *
 * EmbWinStructureProc --
 *	This procedure is invoked by the Tk event loop whenever
 *	StructureNotify events occur for a window that's embedded
 *	in a table widget.  This procedure's only purpose is to
 *	clean up when windows are deleted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The window is disassociated from the window segment, and
 *	the portion of the table is redisplayed.
 *
 *--------------------------------------------------------------
 */
static void
EmbWinStructureProc(clientData, eventPtr)
    ClientData clientData;	/* Pointer to record describing window item. */
    XEvent *eventPtr;		/* Describes what just happened. */
{
    register TableEmbWindow *ewPtr = (TableEmbWindow *) clientData;

    if (eventPtr->type != DestroyNotify) {
	return;
    }

    EmbWinRemove(ewPtr);
}

/*
 *--------------------------------------------------------------
 *
 * EmbWinDelete --
 *	This procedure is invoked by ... whenever
 *	an embedded window is being deleted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The embedded window is deleted, if it exists, and any resources
 *	associated with it are released.
 *
 *--------------------------------------------------------------
 */
void
EmbWinDelete(register Table *tablePtr, TableEmbWindow *ewPtr)
{
    Tcl_HashEntry *entryPtr = ewPtr->hPtr;

    if (ewPtr->tkwin != NULL) {
	Tk_Window tkwin = ewPtr->tkwin;
	/*
	 * Delete the event handler for the window before destroying
	 * the window, so that EmbWinStructureProc doesn't get called
	 * (we'll already do everything that it would have done, and
	 * it will just get confused).
	 */

	ewPtr->tkwin = NULL;
	Tk_DeleteEventHandler(tkwin, StructureNotifyMask,
			      EmbWinStructureProc, (ClientData) ewPtr);
	Tk_DestroyWindow(tkwin);
    }
    if (tablePtr->tkwin != NULL && entryPtr != NULL) {
	int row, col, x, y, width, height;
	TableParseArrayIndex(&row, &col,
			     Tcl_GetHashKey(tablePtr->winTable, entryPtr));
	Tcl_DeleteHashEntry(entryPtr);

	if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
			     col-tablePtr->colOffset,
			     &x, &y, &width, &height, 0))
	    TableInvalidate(tablePtr, x, y, width, height, 0);
    }
#if 0
    Tcl_CancelIdleCall(EmbWinDelayedUnmap, (ClientData) ewPtr);
#endif
    EmbWinCleanup(tablePtr, ewPtr);
    ckfree((char *) ewPtr);
}

/*
 *--------------------------------------------------------------
 *
 * EmbWinConfigure --
 *	This procedure is called to handle configuration options
 *	for an embedded window.
 *
 * Results:
 *	The return value is a standard Tcl result.  If TCL_ERROR is
 *	returned, then the interp's result contains an error message..
 *
 * Side effects:
 *	Configuration information for the embedded window changes,
 *	such as alignment, stretching, or name of the embedded
 *	window.
 *
 *--------------------------------------------------------------
 */
static int
EmbWinConfigure(tablePtr, ewPtr, objc, objv)
     Table *tablePtr;		/* Information about table widget that
				 * contains embedded window. */
     TableEmbWindow *ewPtr;	/* Embedded window to be configured. */
     int objc;			/* Number of objs in objv. */
     Tcl_Obj *CONST objv[];	/* Obj type options. */
{
    Tcl_Interp *interp = tablePtr->interp;
    Tk_Window oldWindow;
    int i, result;
    const char **argv;

    oldWindow = ewPtr->tkwin;

    /* Stringify */
    argv = (const char **) ckalloc((objc + 1) * sizeof(char *));
    for (i = 0; i < objc; i++)
	argv[i] = Tcl_GetString(objv[i]);
    argv[i] = NULL;
    result = Tk_ConfigureWidget(interp, tablePtr->tkwin,
				winConfigSpecs, objc, argv, (char *) ewPtr,
				TK_CONFIG_ARGV_ONLY);
    ckfree((const char *) argv);
    if (result != TCL_OK) {
	return TCL_ERROR;
    }

    if (oldWindow != ewPtr->tkwin) {
	ewPtr->displayed = 0;
	if (oldWindow != NULL) {
	    Tk_DeleteEventHandler(oldWindow, StructureNotifyMask,
				  EmbWinStructureProc, (ClientData) ewPtr);
	    Tk_ManageGeometry(oldWindow, (Tk_GeomMgr *) NULL,
			      (ClientData) NULL);
	    EmbWinUnmapNow(oldWindow, tablePtr->tkwin);
	}
	if (ewPtr->tkwin != NULL) {
	    Tk_Window ancestor, parent;

	    /*
	     * Make sure that the table is either the parent of the
	     * embedded window or a descendant of that parent.  Also,
	     * don't allow a top-level window to be managed inside
	     * a table.
	     */

	    parent = Tk_Parent(ewPtr->tkwin);
	    for (ancestor = tablePtr->tkwin; ;
		 ancestor = Tk_Parent(ancestor)) {
		if (ancestor == parent) {
		    break;
		}
		if (Tk_IsTopLevel(ancestor)) {
		badMaster:
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
					   "can't embed ",
					   Tk_PathName(ewPtr->tkwin), " in ",
					   Tk_PathName(tablePtr->tkwin),
					   (char *)NULL);
		    ewPtr->tkwin = NULL;
		    return TCL_ERROR;
		}
	    }
	    if (Tk_IsTopLevel(ewPtr->tkwin) ||
		(ewPtr->tkwin == tablePtr->tkwin)) {
		goto badMaster;
	    }

	    /*
	     * Take over geometry management for the window, plus create
	     * an event handler to find out when it is deleted.
	     */

	    Tk_ManageGeometry(ewPtr->tkwin, &tableGeomType, (ClientData)ewPtr);
	    Tk_CreateEventHandler(ewPtr->tkwin, StructureNotifyMask,
				  EmbWinStructureProc, (ClientData) ewPtr);
	}
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * Table_WinMove --
 *	This procedure is invoked by ... whenever
 *	an embedded window is being moved.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	If an embedded window is in the dest cell, it is deleted.
 *
 *--------------------------------------------------------------
 */
int
Table_WinMove(register Table *tablePtr, char *CONST srcPtr,
	   char *CONST destPtr, int flags)
{
    int srow, scol, row, col, new;
    Tcl_HashEntry *entryPtr;
    TableEmbWindow *ewPtr;

    if (TableGetIndex(tablePtr, srcPtr, &srow, &scol) != TCL_OK ||
	TableGetIndex(tablePtr, destPtr, &row, &col) != TCL_OK) {
	return TCL_ERROR;
    }
    entryPtr = Tcl_FindHashEntry(tablePtr->winTable, srcPtr);
    if (entryPtr == NULL) {
	if (flags & INV_NO_ERR_MSG) {
	    return TCL_OK;
	} else {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(tablePtr->interp),
		    "no window at index \"", srcPtr, "\"", (char *) NULL);
	    return TCL_ERROR;
	}
    }
    /* avoid moving it to the same location */
    if (srow == row && scol == col) {
	return TCL_OK;
    }
    /* get the window pointer */
    ewPtr = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);
    /* and free the old hash table entry */
    Tcl_DeleteHashEntry(entryPtr);

    entryPtr = Tcl_CreateHashEntry(tablePtr->winTable, destPtr, &new);
    if (!new) {
	/* window already there - just delete it */
	TableEmbWindow *ewPtrDel;
	ewPtrDel = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);
	/* This prevents the deletion of it's own entry, since we need it */
	ewPtrDel->hPtr = NULL;
	EmbWinDelete(tablePtr, ewPtrDel);
    }
    /* set the new entry's value */
    Tcl_SetHashValue(entryPtr, (ClientData) ewPtr);
    ewPtr->hPtr = entryPtr;

    if (flags & INV_FORCE) {
	int x, y, w, h;
	/* Invalidate old cell */
	if (TableCellVCoords(tablePtr, srow-tablePtr->rowOffset,
		scol-tablePtr->colOffset, &x, &y, &w, &h, 0)) {
	    TableInvalidate(tablePtr, x, y, w, h, 0);
	}
	/* Invalidate new cell */
	if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
		col-tablePtr->colOffset, &x, &y, &w, &h, 0)) {
	    TableInvalidate(tablePtr, x, y, w, h, 0);
	}
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * Table_WinDelete --
 *	This procedure is invoked by ... whenever
 *	an embedded window is being delete.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	Window info will be deleted.
 *
 *--------------------------------------------------------------
 */
int
Table_WinDelete(register Table *tablePtr, char *CONST idxPtr)
{
    Tcl_HashEntry *entryPtr;

    entryPtr = Tcl_FindHashEntry(tablePtr->winTable, idxPtr);
    if (entryPtr != NULL) {
	/* get the window pointer & clean up data associated with it */
	EmbWinDelete(tablePtr, (TableEmbWindow *) Tcl_GetHashValue(entryPtr));
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * Table_WindowCmd --
 *	This procedure is invoked to process the window method
 *	that corresponds to a widget managed by this module.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */
int
Table_WindowCmd(ClientData clientData, register Tcl_Interp *interp,
		int objc, Tcl_Obj *CONST objv[])
{
    register Table *tablePtr = (Table *)clientData;
    int result = TCL_OK, cmdIndex, row, col, x, y, width, height, i, new;
    TableEmbWindow *ewPtr;
    Tcl_HashEntry *entryPtr;
    Tcl_HashSearch search;
    char buf[INDEX_BUFSIZE], *keybuf, *winname;

    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 2, objv, "option ?arg arg ...?");
	return TCL_ERROR;
    }

    /* parse the next argument */
    if (Tcl_GetIndexFromObj(interp, objv[2], winCmdNames,
			    "option", 0, &cmdIndex) != TCL_OK) {
	return TCL_ERROR;
    }
    switch ((enum winCommand) cmdIndex) {
    case WIN_CGET:
	if (objc != 5) {
	    Tcl_WrongNumArgs(interp, 3, objv, "index option");
	    return TCL_ERROR;
	}
	entryPtr = Tcl_FindHashEntry(tablePtr->winTable,
				     Tcl_GetString(objv[3]));
	if (entryPtr == NULL) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
				   "no window at index \"",
				   Tcl_GetString(objv[3]), "\"", (char *)NULL);
	    return TCL_ERROR;
	} else {
	    ewPtr = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);
	    result = Tk_ConfigureValue(interp, tablePtr->tkwin, winConfigSpecs,
				       (char *) ewPtr,
				       Tcl_GetString(objv[4]), 0);
	}
	return result;	/* CGET */

    case WIN_CONFIGURE:
	if (objc < 4) {
	    Tcl_WrongNumArgs(interp, 3, objv, "index ?arg arg  ...?");
	    return TCL_ERROR;
	}
	if (TableGetIndexObj(tablePtr, objv[3], &row, &col) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	TableMakeArrayIndex(row, col, buf);
	entryPtr = Tcl_CreateHashEntry(tablePtr->winTable, buf, &new);

	if (new) {
	    /* create the structure */
	    ewPtr = TableNewEmbWindow(tablePtr);

	    /* insert it into the table */
	    Tcl_SetHashValue(entryPtr, (ClientData) ewPtr);
	    ewPtr->hPtr = entryPtr;

	    /* configure the window structure */
	    result = EmbWinConfigure(tablePtr, ewPtr, objc-4, objv+4);
	    if (result == TCL_ERROR) {
		/* release the structure */
		EmbWinCleanup(tablePtr, ewPtr);
		ckfree((char *) ewPtr);

		/* and free the hash table entry */
		Tcl_DeleteHashEntry(entryPtr);
	    }
	} else {
	    /* window exists, do a reconfig if we have enough args */
	    /* get the window pointer from the table */
	    ewPtr = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);

	    /* 5 args means that there are values to replace */
	    if (objc > 5) {
		/* and do a reconfigure */
		result = EmbWinConfigure(tablePtr, ewPtr, objc-4, objv+4);
	    }
	}
	if (result == TCL_ERROR) {
	    return TCL_ERROR;
	}

	/* 
	 * If there were less than 6 args, we need
	 * to do a printout of the config, even for new windows
	 */
	if (objc < 6) {
	    result = Tk_ConfigureInfo(interp, tablePtr->tkwin, winConfigSpecs,
				      (char *) ewPtr, (objc == 5)?
				      Tcl_GetString(objv[4]) : NULL, 0);
	} else {
	    /* Otherwise we reconfigured so invalidate
	     * the table for a redraw */
	    if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
				 col-tablePtr->colOffset,
				 &x, &y, &width, &height, 0)) {
		TableInvalidate(tablePtr, x, y, width, height, 1);
	    }
	}
	return result;	/* CONFIGURE */

    case WIN_DELETE:
	if (objc < 4) {
	    Tcl_WrongNumArgs(interp, 3, objv, "index ?index ...?");
	    return TCL_ERROR;
	}
	for (i = 3; i < objc; i++) {
	    Table_WinDelete(tablePtr, Tcl_GetString(objv[i]));
	}
	break;

    case WIN_MOVE:
	if (objc != 5) {
	    Tcl_WrongNumArgs(interp, 3, objv, "srcIndex destIndex");
	    return TCL_ERROR;
	}
	result = Table_WinMove(tablePtr, Tcl_GetString(objv[3]),
			       Tcl_GetString(objv[4]), INV_FORCE);
	break;

    case WIN_NAMES: {
	Tcl_Obj *objPtr = Tcl_NewObj();

	/* just print out the window names */
	if (objc < 3 || objc > 4) {
	    Tcl_WrongNumArgs(interp, 3, objv, "?pattern?");
	    return TCL_ERROR;
	}
	winname = (objc == 4) ? Tcl_GetString(objv[3]) : NULL;
	entryPtr = Tcl_FirstHashEntry(tablePtr->winTable, &search);
	while (entryPtr != NULL) {
	    keybuf = Tcl_GetHashKey(tablePtr->winTable, entryPtr);
	    if (objc == 3 || Tcl_StringMatch(keybuf, winname)) {
		Tcl_ListObjAppendElement(NULL, objPtr,
					 Tcl_NewStringObj(keybuf, -1));
	    }
	    entryPtr = Tcl_NextHashEntry(&search);
	}
	Tcl_SetObjResult(interp, TableCellSortObj(interp, objPtr));
	break;
    }
    }
    return TCL_OK;
}
@


1.3
log
@touched all files to ease next import
@
text
@d18 1
a18 1
			    Tcl_Interp *interp, Tk_Window tkwin, char *value,
d20 1
a20 1
static char *	StickyPrintProc _ANSI_ARGS_((ClientData clientData,
d46 1
a46 1
static char *winCmdNames[] = {
d120 1
a120 1
static char *
d166 1
a166 1
    char *value;			/* Value of option. */
d618 1
a618 1
    char **argv;
d623 1
a623 1
    argv = (char **) ckalloc((objc + 1) * sizeof(char *));
d630 1
a630 1
    ckfree((char *) argv);
@


1.2
log
@	Update tkTable to version 2.7:
	* src/tkTableCmds.c, src/tkTable.tcl.h, src/tkTableCellSort.c,
	src/tkTableEdit.c, src/tkTableInitScript.h, src/tkTablePs.c,
	src/tkTableUtil.c, doc/tkTable.html: New files.
	* src/tkTable.c, src/tkTable.h, src/TkTable.tcl, src/tkTableCell.c,
	src/tkTableTag.c, src/tkTableWin.c, src/tkTable_version.in: Update to
	version 2.7.
	* configure.in: If compiling with cygwin, we need to have
	WIN32 defined to build tkTable modules.
	* configure: Regenerate.
	* src/Makefile.am: Add new tkTable files and update build rules
	for new version of tkTable.
	* src/Makefile.in: Regenerate.
@
text
@@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * Copyright (c) 1998 Jeffrey Hobbs
d12 1
d33 1
a33 1
					     int argc, char **argv));
d46 5
a50 12
#define WIN_CGET	1	/* get config item of embedded window */
#define WIN_CONFIGURE	2	/* configure an embedded window */
#define WIN_DELETE	3	/* delete an embedded window */
#define WIN_MOVE	4	/* moves a window index */
#define	WIN_NAMES	5	/* print the embedded window names */
static Cmd_Struct win_cmds[] = {
  {"configure",	WIN_CONFIGURE},
  {"cget",	WIN_CGET},
  {"delete",	WIN_DELETE},
  {"move",	WIN_MOVE},
  {"names",	WIN_NAMES},
  {"", 0}
d72 4
a75 2
static Tk_CustomOption stickyOption = {StickyParseProc, StickyPrintProc,
				       (ClientData) NULL};
d81 6
a86 3
  {TK_CONFIG_SYNONYM, "-bg", "background", (char *) NULL,
   (char *) NULL, 0, 0 },
  {TK_CONFIG_STRING, "-create", (char *) NULL, (char *) NULL, (char *) NULL,
d89 1
a89 1
  {TK_CONFIG_PIXELS, "-padx", (char *) NULL, (char *) NULL, (char *) NULL,
d91 1
a91 1
  {TK_CONFIG_PIXELS, "-pady", (char *) NULL, (char *) NULL, (char *) NULL,
d93 1
a93 1
  {TK_CONFIG_CUSTOM, "-sticky", (char *) NULL, (char *) NULL, (char *) NULL,
d98 1
a98 1
  {TK_CONFIG_WINDOW, "-window", (char *) NULL, (char *) NULL, (char *) NULL,
d101 2
a102 2
  {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
   (char *) NULL, 0, 0 }
d131 12
a142 12
  int flags = ((TableEmbWindow *) widgRec)->sticky;
  int count = 0;
  char *result = (char *) ckalloc(5*sizeof(char));

  if (flags&STICK_NORTH) result[count++] = 'n';
  if (flags&STICK_EAST)  result[count++] = 'e';
  if (flags&STICK_SOUTH) result[count++] = 's';
  if (flags&STICK_WEST)  result[count++] = 'w';

  *freeProcPtr = TCL_DYNAMIC;
  result[count] = '\0';
  return result;
d171 21
a191 20
  register TableEmbWindow *ewPtr = (TableEmbWindow *) widgRec;
  int sticky = 0;
  char c;

  while ((c = *value++) != '\0') {
    switch (c) {
    case 'n': case 'N': sticky |= STICK_NORTH; break;
    case 'e': case 'E': sticky |= STICK_EAST;  break;
    case 's': case 'S': sticky |= STICK_SOUTH; break;
    case 'w': case 'W': sticky |= STICK_WEST;  break;
    case ' ': case ',': case '\t': case '\r': case '\n': break;
    default:
      Tcl_AppendResult(interp, "bad sticky value \"", --value,
		       "\": must contain n, s, e or w",
		       (char *) NULL);
      return TCL_ERROR;
    }
  }
  ewPtr->sticky = sticky;
  return TCL_OK;
d201 12
a212 12
  TableEmbWindow *ewPtr = (TableEmbWindow *) ckalloc(sizeof(TableEmbWindow));
  ewPtr->tablePtr	= tablePtr;
  ewPtr->tkwin		= NULL;
  ewPtr->hPtr		= NULL;
  ewPtr->bg		= NULL;
  ewPtr->create		= NULL;
  ewPtr->relief		= -1;
  ewPtr->sticky		= 0;
  ewPtr->padX		= 0;
  ewPtr->padY		= 0;
  ewPtr->displayed	= 0;
  return ewPtr;
d232 1
a232 2
  /* free the options in the widget */
  Tk_FreeOptions(winConfigSpecs, (char *) ewPtr, tablePtr->display, 0);
d255 69
a323 57
  Tk_Window tkwin = tablePtr->tkwin;
  Tk_Window ewTkwin = ewPtr->tkwin;
  int diffx=0;	/* Cavity width - slave width. */
  int diffy=0;	/* Cavity hight - slave height. */
  int sticky = ewPtr->sticky;


  if (ewPtr->bg)
    tagPtr->bg = ewPtr->bg;
  if (ewPtr->relief != -1)
    tagPtr->relief = ewPtr->relief;

  x += ewPtr->padX/2;
  width -= ewPtr->padX;
  y += ewPtr->padY/2;
  height -= ewPtr->padY;

  if (width > Tk_ReqWidth(ewPtr->tkwin)) {
    diffx = width - Tk_ReqWidth(ewPtr->tkwin);
    width = Tk_ReqWidth(ewPtr->tkwin);
  }
  if (height > Tk_ReqHeight(ewPtr->tkwin)) {
    diffy = height - Tk_ReqHeight(ewPtr->tkwin);
    height = Tk_ReqHeight(ewPtr->tkwin);
  }
  if (sticky&STICK_EAST && sticky&STICK_WEST) {
    width += diffx;
  }
  if (sticky&STICK_NORTH && sticky&STICK_SOUTH) {
    height += diffy;
  }
  if (!(sticky&STICK_WEST)) {
    x += (sticky&STICK_EAST) ? diffx : diffx/2;
  }
  if (!(sticky&STICK_NORTH)) {
    y += (sticky&STICK_SOUTH) ? diffy : diffy/2;
  }

  /* If we fall below a specific minimum width/height requirement,
   * we just unmap the window */
  if (width < 4 || height < 4) {
    if (ewPtr->displayed) {
      EmbWinUnmapNow(ewTkwin, tkwin);
    }
    return;
  }

  if (tkwin == Tk_Parent(ewTkwin)) {
    if ((x != Tk_X(ewTkwin)) || (y != Tk_Y(ewTkwin))
	|| (width != Tk_Width(ewTkwin))	|| (height != Tk_Height(ewTkwin))) {
      Tk_MoveResizeWindow(ewTkwin, x, y, width, height);
    }
    Tk_MapWindow(ewTkwin);
  } else {
    Tk_MaintainGeometry(ewTkwin, tkwin, x, y, width, height);
  }
  ewPtr->displayed = 1;
d345 3
a347 3
  if (tkwin != Tk_Parent(ewTkwin)) {
    Tk_UnmaintainGeometry(ewTkwin, tkwin);
  } else {
a348 1
  }
d370 26
a395 20
  register TableEmbWindow *ewPtr;
  Tcl_HashEntry *entryPtr;
  int row, col;
  char buf[INDEX_BUFSIZE];

  /* we need to deal with things user coords */
  rlo += tablePtr->rowOffset;
  rhi += tablePtr->rowOffset;
  clo += tablePtr->colOffset;
  chi += tablePtr->colOffset;
  for (row = rlo; row <= rhi; row++) {
    for (col = clo; col <= chi; col++) {
      TableMakeArrayIndex(row, col, buf);
      if ((entryPtr = Tcl_FindHashEntry(tablePtr->winTable, buf)) != NULL) {
	ewPtr = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);
	if (ewPtr->displayed) {
	  ewPtr->displayed = 0;
	  if (ewPtr->tkwin != NULL && tablePtr->tkwin != NULL) {
	    EmbWinUnmapNow(ewPtr->tkwin, tablePtr->tkwin);
	  }
a396 1
      }
a397 1
  }
d424 1
a424 1
  register TableEmbWindow *ewPtr = (TableEmbWindow *) clientData;
d426 14
a439 10
  /* resize depends on the sticky */
  if (ewPtr->displayed && ewPtr->hPtr != NULL) {
    Table *tablePtr = ewPtr->tablePtr;
    int row, col, x, y, width, height;

    TableParseArrayIndex(&row, &col,
			 Tcl_GetHashKey(tablePtr->winTable, ewPtr->hPtr));
    if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
		     col-tablePtr->colOffset, &x, &y, &width, &height, 0)) {
      TableInvalidate(tablePtr, x, y, width, height, 0);
a440 1
  }
d446 1
a446 1
  Table *tablePtr = ewPtr->tablePtr;
d448 23
a470 11
  ewPtr->tkwin = NULL;
  ewPtr->displayed = 0;
  if (tablePtr->tkwin != NULL) {
    int row, col, x, y, width, height;

    TableParseArrayIndex(&row, &col,
			 Tcl_GetHashKey(tablePtr->winTable, ewPtr->hPtr));
    if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
			 col-tablePtr->colOffset, &x, &y, &width, &height, 0))
      TableInvalidate(tablePtr, x, y, width, height, 1);
  }
a496 2
    Tk_DeleteEventHandler(ewPtr->tkwin, StructureNotifyMask,
			  EmbWinStructureProc, (ClientData) ewPtr);
d527 1
a527 1
  register TableEmbWindow *ewPtr = (TableEmbWindow *) clientData;
d529 3
a531 3
  if (eventPtr->type != DestroyNotify) {
    return;
  }
d533 1
a533 1
  EmbWinRemove(ewPtr);
d555 1
a555 1
  Tcl_HashEntry *entryPtr;
d557 19
a575 14
  if (ewPtr->tkwin != NULL) {
    int row, col, x, y, width, height;
    entryPtr = ewPtr->hPtr;

    /*
     * Delete the event handler for the window before destroying
     * the window, so that EmbWinStructureProc doesn't get called
     * (we'll already do everything that it would have done, and
     * it will just get confused).
     */

    Tk_DeleteEventHandler(ewPtr->tkwin, StructureNotifyMask,
			  EmbWinStructureProc, (ClientData) ewPtr);
    Tk_DestroyWindow(ewPtr->tkwin);
d577 4
a580 9
    if (tablePtr->tkwin != NULL && entryPtr != NULL) {
      TableParseArrayIndex(&row, &col,
			   Tcl_GetHashKey(tablePtr->winTable, entryPtr));
      Tcl_DeleteHashEntry(entryPtr);

      if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
			   col-tablePtr->colOffset,
			   &x, &y, &width, &height, 0))
	TableInvalidate(tablePtr, x, y, width, height, 0);
a581 1
  }
d583 1
a583 1
  Tcl_CancelIdleCall(EmbWinDelayedUnmap, (ClientData) ewPtr);
d585 2
a586 2
  EmbWinCleanup(tablePtr, ewPtr);
  ckfree((char *) ewPtr);
d594 1
a594 1
 *	for an embedded window, using an argc/argv list.
d608 1
a608 1
EmbWinConfigure(tablePtr, ewPtr, argc, argv)
d612 21
a632 20
     int argc;			/* Number of strings in argv. */
     char **argv;		/* Array of strings describing configuration
				 * options. */
{
  Tk_Window oldWindow;

  oldWindow = ewPtr->tkwin;
  if (Tk_ConfigureWidget(tablePtr->interp, tablePtr->tkwin, winConfigSpecs,
			 argc, argv, (char *) ewPtr, TK_CONFIG_ARGV_ONLY)
      != TCL_OK) {
    return TCL_ERROR;
  }
  if (oldWindow != ewPtr->tkwin) {
    ewPtr->displayed = 0;
    if (oldWindow != NULL) {
      Tk_DeleteEventHandler(oldWindow, StructureNotifyMask,
			    EmbWinStructureProc, (ClientData) ewPtr);
      Tk_ManageGeometry(oldWindow, (Tk_GeomMgr *) NULL,
			(ClientData) NULL);
      EmbWinUnmapNow(oldWindow, tablePtr->tkwin);
a633 2
    if (ewPtr->tkwin != NULL) {
      Tk_Window ancestor, parent;
d635 11
a645 6
      /*
       * Make sure that the table is either the parent of the
       * embedded window or a descendant of that parent.  Also,
       * don't allow a top-level window to be managed inside
       * a table.
       */
d647 37
a683 5
      parent = Tk_Parent(ewPtr->tkwin);
      for (ancestor = tablePtr->tkwin; ;
	   ancestor = Tk_Parent(ancestor)) {
	if (ancestor == parent) {
	  break;
a684 21
	if (Tk_IsTopLevel(ancestor)) {
	badMaster:
	  Tcl_AppendResult(tablePtr->interp, "can't embed ",
			   Tk_PathName(ewPtr->tkwin), " in ",
			   Tk_PathName(tablePtr->tkwin), (char *) NULL);
	  ewPtr->tkwin = NULL;
	  return TCL_ERROR;
	}
      }
      if (Tk_IsTopLevel(ewPtr->tkwin) || (ewPtr->tkwin == tablePtr->tkwin)) {
	goto badMaster;
      }

      /*
       * Take over geometry management for the window, plus create
       * an event handler to find out when it is deleted.
       */

      Tk_ManageGeometry(ewPtr->tkwin, &tableGeomType, (ClientData) ewPtr);
      Tk_CreateEventHandler(ewPtr->tkwin, StructureNotifyMask,
			    EmbWinStructureProc, (ClientData) ewPtr);
d686 1
a686 2
  }
  return TCL_OK;
d692 3
a694 4
 * TableWindowCmd --
 *	This procedure is invoked to process the window method
 *	that corresponds to a widget managed by this module.
 *	See the user documentation for details on what it does.
d700 1
a700 1
 *	See the user documentation.
d705 2
a706 2
TableWindowCmd(Table * tablePtr, register Tcl_Interp *interp,
	       int argc, char *argv[])
d708 3
a710 57
  int result = TCL_OK, retval;
  int row, col, x, y, width, height, i, new;
  TableEmbWindow *ewPtr;
  Tcl_HashEntry *entryPtr;
  Tcl_HashSearch search;
  char buf[INDEX_BUFSIZE], *keybuf;

  /* parse the next argument */
  retval = Cmd_Parse(interp, win_cmds, argv[2]);
  switch (retval) {
    /* failed to parse the argument, error */
  case 0:
    return TCL_ERROR;

  case WIN_CGET:
    if (argc != 5) {
      Tcl_AppendResult(interp, "wrong # args: should be \"",
                       argv[0], " window cget index option\"", (char *) NULL);
      return TCL_ERROR;
    }
    if ((entryPtr=Tcl_FindHashEntry(tablePtr->winTable, argv[3])) == NULL) {
      Tcl_AppendResult(interp, "no window at index \"", argv[3],
		       "\"", (char *) NULL);
      return TCL_ERROR;
    } else {
      ewPtr = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);
      result = Tk_ConfigureValue(interp, tablePtr->tkwin, winConfigSpecs,
				 (char *) ewPtr, argv[4], 0);
    }
    return result;	/* CGET */

  case WIN_CONFIGURE:
    if (argc < 4) {
      Tcl_AppendResult(interp, "wrong # args: should be \"",
		       argv[0], " window configure index ?arg arg  ...?\"",
		       (char *) NULL);
      return TCL_ERROR;
    }
    if (TableGetIndex(tablePtr, argv[3], &row, &col) == TCL_ERROR) {
      return TCL_ERROR;
    }
    TableMakeArrayIndex(row, col, buf);
    entryPtr = Tcl_CreateHashEntry(tablePtr->winTable, buf, &new);
    if (new) {
      /* create the structure */
      ewPtr = TableNewEmbWindow(tablePtr);

      /* insert it into the table */
      Tcl_SetHashValue(entryPtr, (ClientData) ewPtr);
      ewPtr->hPtr = entryPtr;

      /* configure the window structure */
      result = EmbWinConfigure(tablePtr, ewPtr, argc-4, argv+4);
      if (result == TCL_ERROR) {
	/* release the structure */
	EmbWinCleanup(tablePtr, ewPtr);
	ckfree((char *) ewPtr);
d712 2
a713 2
	/* and free the hash table entry */
	Tcl_DeleteHashEntry(entryPtr);
a714 47
      }

      /* if a window was specified, make sure it exists */
    } else {
      /* pointer wasn't null, do a reconfig if we have enough arguments */
      /* get the window pointer from the table */
      ewPtr = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);

      /* 5 args means that there are values to replace */
      if (argc > 5) {
	/* and do a reconfigure */
	result = EmbWinConfigure(tablePtr, ewPtr, argc-4, argv+4);
	if (result == TCL_ERROR)
	  return TCL_ERROR;
      }
    }

    /* 
     * If there were less than 6 args, we need
     * to do a printout of the config, even for new windows
     */
    if (argc < 6) {
      result = Tk_ConfigureInfo(interp, tablePtr->tkwin, winConfigSpecs,
				(char *) ewPtr, (argc == 5)?argv[4]:0, 0);
    } else {
      /* Otherwise we reconfigured so invalidate the table for a redraw */
      if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
			   col-tablePtr->colOffset,
			   &x, &y, &width, &height, 0)) {
	TableInvalidate(tablePtr, x, y, width, height, 1);
      }
    }
    return result;	/* CONFIGURE */

  case WIN_DELETE:
    if (argc < 4) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		       " window delete index ?index ...?\"", (char *) NULL);
      return TCL_ERROR;
    }
    for (i = 3; i < argc; i++) {
      if ((entryPtr = Tcl_FindHashEntry(tablePtr->winTable, argv[i]))!=NULL) {
	/* get the window pointer */
	ewPtr = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);

	EmbWinDelete(tablePtr, ewPtr);
      }
d716 9
a724 19
    /* clear up anything that might have been placed in the result string */
    Tcl_SetResult(interp, "", TCL_STATIC);
    return result;

  case WIN_MOVE:
    if (argc != 5) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		       " window move oldIndex newIndex\"", (char *) NULL);
      return TCL_ERROR;
    }
    if (TableGetIndex(tablePtr, argv[3], &x, &y) == TCL_ERROR ||
	TableGetIndex(tablePtr, argv[4], &row, &col) == TCL_ERROR) {
      return TCL_ERROR;
    }
    TableMakeArrayIndex(x, y, buf);
    if ((entryPtr = Tcl_FindHashEntry(tablePtr->winTable, buf)) == NULL) {
      Tcl_AppendResult(interp, "no window at index \"", argv[3],
		       "\"", (char *) NULL);
      return TCL_ERROR;
d727 2
a728 2
    if (x == row && y == col) {
      return TCL_OK;
d735 1
a735 2
    TableMakeArrayIndex(row, col, buf);
    entryPtr = Tcl_CreateHashEntry(tablePtr->winTable, buf, &new);
d737 6
a742 7
      /* window already there - just delete it */
      TableEmbWindow *ewPtrDel;

      ewPtrDel = (TableEmbWindow *) Tcl_GetHashValue(entryPtr);
      /* This prevents the deletion of it's own entry, since we need it */
      ewPtrDel->hPtr = NULL;
      EmbWinDelete(tablePtr, ewPtrDel);
d748 207
a954 34
    /* Invalidate old cell */
    if (TableCellVCoords(tablePtr, x-tablePtr->rowOffset,
			 y-tablePtr->colOffset,
			 &x, &y, &width, &height, 0)) {
      TableInvalidate(tablePtr, x, y, width, height, 0);
    }
    /* Invalidate new cell */
    if (TableCellVCoords(tablePtr, row-tablePtr->rowOffset,
			 col-tablePtr->colOffset,
			 &x, &y, &width, &height, 0)) {
      TableInvalidate(tablePtr, x, y, width, height, 0);
    }
    break;

  case WIN_NAMES:
    /* just print out the image names */
    if (argc != 3 && argc != 4) {
      Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		       " window names ?pattern?\"", (char *) NULL);
      return TCL_ERROR;
    }
    entryPtr = Tcl_FirstHashEntry(tablePtr->winTable, &search);
    while (entryPtr != NULL) {
      keybuf = Tcl_GetHashKey(tablePtr->winTable, entryPtr);
      if (argc == 3 || Tcl_StringMatch(keybuf, argv[3]))
	Tcl_AppendElement(interp, keybuf);
      entryPtr = Tcl_NextHashEntry(&search);
    }
    Tcl_SetResult(interp,
		  TableCellSort(tablePtr, Tcl_GetStringResult(interp)),
		  TCL_DYNAMIC);
    break;
  }
  return TCL_OK;
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
