head	1.4;
access;
symbols
	insight_7_6-2013-04-10-branchpoint:1.4
	gdb_7_6-branch:1.4.0.4
	gdb_7_5-branch:1.4.0.2
	gdb_7_4-branch:1.3.0.28
	gdb_7_3-branch:1.3.0.26
	gdb_7_1-branch:1.3.0.24
	gdb_7_0-branch:1.3.0.22
	arc-sim-20090309:1.3
	arc-insight_6_8-branch:1.3.0.20
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.18
	insight_6_8-branchpoint:1.3
	gdb_6_8-branch:1.3.0.16
	insight_6_6-20070208-release:1.3
	gdb_6_6-branch:1.3.0.14
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb_6_5-branch:1.3.0.12
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb_6_4-branch:1.3.0.10
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb_6_1-2004-04-05-release:1.3
	gdb_6_1-branch:1.3.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	gdb_6_0-2003-10-04-release:1.3
	gdb_6_0-branch:1.3.0.6
	gdb_6_0-2003-06-23-branchpoint:1.3
	gdb_5_3-2002-12-12-release:1.3
	gdb_5_3-branch:1.3.0.4
	gdb_5_3-2002-09-04-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.2
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	LIBGUI_TCL_8_3:1.1.1.1
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2012.08.08.13.34.56;	author rosch;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.08.22.34.47;	author irox;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.13.17.53.52;	author kseitz;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.47;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.47;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@   * src/subcommand.c,src/subcommand.h
   (subcommand_implementation,ide_create_command_with_subcommands):
   Make some params const to match tcl/tk changes.
   * src/tclcursor.c (get_cursor_size,get_cursor_position): Ditto.
   * src/tclmsgbox.c: Include windows.h early.
   (msgbox_init,msgbox_exit): Take care about encodings to windows functions.
   (msgbox_thread): Use correct api call here.
   (msgbox_internal,msgbox): Make CONST84 where needed.
   * src/tclwinmode.c (seterrormode_command): Ditto.
   * src/tclshellexe.c (shell_execute_command): Ditto. Plus correct cast return
   value to shut up 64bit gcc.
   * src/tclwinfont.c (win_choose_font): Make CONST84 where needed and
   use dedicated windows api.
   * src/tclwinprint.c (winprint_page_setup_command): Make const/CONST84 where needed.
   (winprint_print_text_options,winprint_print_text_invoke,winprint_print_command): Ditto.
   (winprint_print_text_invoke,): Ditto.
   (winprint_start,winprint_print_commandwinprint_abort_command): use dedicated windows structs/api.
   * src/tkTable.c: Obsolete old dprint stuff.
   (StringifyObjects,Tk_TableObjCmd,TableWidgetObjCmd,TableConfigure,TableFetchSelection): adjust const.
   (selCmdNames,commandNames,updateOpts): make const.
   * src/tkTable.h: Adjust windows includes. include stdint.h. define CONST86 if missing. Deine
   PTR2INT/INT2PTR taken from tcl if missing. Make some functions const.
   * src/tkTableCmds.c: Make bdCmdNames and clearnames CONST84.
   * src/tkTableEdit.c: Make modCmdNamesand rcCmdNames CONST84.
   * src/tkTableTag.c: Make tagCmdNames CONST84.
   (TableTagGetEntry): Make param argcv CONST84.
   (TableInitTags): Make some internal strings CONST84.
   (FindRowColTag): Ditto.
   (Table_TagCmd): Ditto.
   * src/tkTableUtil.c (TableOptionBdSet):Ditto.
   (TableOptionBdGet): Make retval CONST86. Fix ptr/int arithmetics.
   (Cmd_OptionSet): Make param value CONST84.
   (Cmd_OptionGet): Make retval CONST86.
   * src/tkTableWin.c (StickyPrintProc): Ditto. Make some internal strings CONST84.
   (StickyParseProc): Make param value CONST84.
   * src/tkWarpPointer.c: Include windows.h ahead of tk.h.
   (WarpPointer): Remove unused var.
   * src/tkWinPrintCanvas.c (PrintCanvasCmd): use dedicated windows structs/api.
   Fix casting.
   * src/tkWinPrintText.c (PrintTextCmd): Add #if case for compiling against tcl 8.5 and up.
   use dedicated windows structs/api.
   (ide_delete_print_text_command): Delete unused static function.
   (DisplayDLineToDrawable): Add #if case for compiling against tcl 8.5 and up. Fix casting.
@
text
@/* 
 * tkTable.h --
 *
 *	This is the header file for the module that implements
 *	table widgets for the Tk toolkit.
 *
 * Copyright (c) 1997-2000 Jeffrey Hobbs
 *
 * See the file "license.txt" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkTable.h,v 1.10 2001/07/01 01:33:17 hobbs Exp $
 */

#ifndef _TKTABLE_H_
#define _TKTABLE_H_

#ifdef WIN32
#   define WIN32_LEAN_AND_MEAN
#   include <windows.h>
#   undef WIN32_LEAN_AND_MEAN
/* VC++ has an entry point called DllMain instead of DllEntryPoint */
#   if defined(_MSC_VER)
#	define DllEntryPoint DllMain
#   endif
#endif


#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <tk.h>

#ifndef CONST86
#      define CONST86 CONST84
#endif

#ifdef MAC_TCL
# include <Xatom.h>
#else
# include <X11/Xatom.h>
#endif /* MAC_TCL */

#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION == 0) /* Tcl8.0 stuff */
#define Tcl_GetString(objPtr)	Tcl_GetStringFromObj(objPtr, (int *)NULL)
#endif

/* This EXTERN declaration is needed for Tcl < 8.0.3 */
#ifndef EXTERN
# ifdef __cplusplus
#  define EXTERN extern "C"
# else
#  define EXTERN extern
# endif
#endif

#ifdef TCL_STORAGE_CLASS
# undef TCL_STORAGE_CLASS
#endif
#ifdef BUILD_tkTable
# define TCL_STORAGE_CLASS DLLEXPORT
#else
# define TCL_STORAGE_CLASS DLLIMPORT
#endif

#if defined(WIN32) || defined(MAC_TCL)
/* XSync call defined in the internals for some reason */
#   ifndef XSync
#	define XSync(display, bool) {display->request++;}
#   endif
#endif /* defn of XSync */

#ifndef NORMAL_BG
#   ifdef WIN32
#	define NORMAL_BG	"SystemButtonFace"
#	define ACTIVE_BG	NORMAL_BG
#	define SELECT_BG	"SystemHighlight"
#	define SELECT_FG	"SystemHighlightText"
#	define DISABLED		"SystemDisabledText"
#	define HIGHLIGHT	"SystemWindowFrame"
#	define DEF_TABLE_FONT	"{MS Sans Serif} 8"
#   elif defined(MAC_TCL)
#	define NORMAL_BG	"systemWindowBody"
#	define ACTIVE_BG	"#ececec"
#	define SELECT_BG	"systemHighlight"
#	define SELECT_FG	"systemHighlightText"
#	define DISABLED		"#a3a3a3"
#	define HIGHLIGHT	"Black"
#	define DEF_TABLE_FONT	"Helvetica 12"
#   else
#	define NORMAL_BG	"#d9d9d9"
#	define ACTIVE_BG	"#fcfcfc"
#	define SELECT_BG	"#c3c3c3"
#	define SELECT_FG	"Black"
#	define DISABLED		"#a3a3a3"
#	define HIGHLIGHT	"Black"
#	define DEF_TABLE_FONT	"Helvetica -12"
#   endif
#endif /* NORMAL_BG */

#define MAX(A,B)	(((A)>(B))?(A):(B))
#define MIN(A,B)	(((A)>(B))?(B):(A))
#define BETWEEN(val,min,max)	( ((val)<(min)) ? (min) : \
				( ((val)>(max)) ? (max) : (val) ) )
#define CONSTRAIN(val,min,max)	if ((val) < (min)) { (val) = (min); } \
				else if ((val) > (max)) { (val) = (max); }
#define STREQ(s1, s2)	(strcmp((s1), (s2)) == 0)
#define ARSIZE(A)	(sizeof(A)/sizeof(*A))
#define INDEX_BUFSIZE	32		/* max size of buffer for indices */
#define TEST_KEY	"#TEST KEY#"	/* index for testing array existence */

/*
 * Assigned bits of "flags" fields of Table structures, and what those
 * bits mean:
 *
 * REDRAW_PENDING:	Non-zero means a DoWhenIdle handler has
 *			already been queued to redisplay the table.
 * REDRAW_BORDER:	Non-zero means 3-D border must be redrawn
 *			around window during redisplay.	 Normally
 *			only text portion needs to be redrawn.
 * CURSOR_ON:		Non-zero means insert cursor is displayed at
 *			present.  0 means it isn't displayed.
 * TEXT_CHANGED:	Non-zero means the active cell text is being edited.
 * HAS_FOCUS:		Non-zero means this window has the input focus.
 * HAS_ACTIVE:		Non-zero means the active cell is set.
 * HAS_ANCHOR:		Non-zero means the anchor cell is set.
 * BROWSE_CMD:		Non-zero means we're evaluating the -browsecommand.
 * VALIDATING:		Non-zero means we are in a valCmd
 * SET_ACTIVE:		About to set the active array element internally
 * ACTIVE_DISABLED:	Non-zero means the active cell is -state disabled
 * OVER_BORDER:		Non-zero means we are over a table cell border
 * REDRAW_ON_MAP:	Forces a redraw on the unmap
 * AVOID_SPANS:		prevent cell spans from being used
 *
 * FIX - consider adding UPDATE_SCROLLBAR a la entry
 */
#define REDRAW_PENDING		(1L<<0)
#define CURSOR_ON		(1L<<1)
#define	HAS_FOCUS		(1L<<2)
#define TEXT_CHANGED		(1L<<3)
#define HAS_ACTIVE		(1L<<4)
#define HAS_ANCHOR		(1L<<5)
#define BROWSE_CMD		(1L<<6)
#define REDRAW_BORDER		(1L<<7)
#define VALIDATING		(1L<<8)
#define SET_ACTIVE		(1L<<9)
#define ACTIVE_DISABLED		(1L<<10)
#define OVER_BORDER		(1L<<11)
#define REDRAW_ON_MAP		(1L<<12)
#define AVOID_SPANS		(1L<<13)

/* Flags for TableInvalidate && TableRedraw */
#define ROW		(1L<<0)
#define COL		(1L<<1)
#define CELL		(1L<<2)

#define CELL_BAD	(1<<0)
#define CELL_OK		(1<<1)
#define CELL_SPAN	(1<<2)
#define CELL_HIDDEN	(1<<3)
#define CELL_VIEWABLE	(CELL_OK|CELL_SPAN)

#define INV_FILL	(1L<<3)	/* use for Redraw when the affected
				 * row/col will affect neighbors */
#define INV_FORCE	(1L<<4)
#define INV_HIGHLIGHT	(1L<<5)
#define INV_NO_ERR_MSG	(1L<<5) /* Don't leave an error message */

/* These alter how the selection set/clear commands behave */
#define SEL_ROW		(1<<0)
#define SEL_COL		(1<<1)
#define SEL_BOTH	(1<<2)
#define SEL_CELL	(1<<3)
#define SEL_NONE	(1<<4)

/*
 * Definitions for tablePtr->dataSource, by bit
 */
#define DATA_NONE	0
#define DATA_CACHE	(1<<1)
#define	DATA_ARRAY	(1<<2)
#define DATA_COMMAND	(1<<3)

/*
 * Definitions for configuring -borderwidth
 */
#define BD_TABLE	0
#define BD_TABLE_TAG	(1<<1)
#define BD_TABLE_WIN	(1<<2)

/*
 * Possible state values for tags
 */
typedef enum {
    STATE_UNUSED, STATE_UNKNOWN, STATE_HIDDEN,
    STATE_NORMAL, STATE_DISABLED, STATE_ACTIVE, STATE_LAST
} TableState;

/*
 * Structure for use in parsing table commands/values.
 * Accessor functions defined in tkTableUtil.c
 */
typedef struct {
  char *name;		/* name of the command/value */
  int value;		/* >0 because 0 represents an error or proc */
} Cmd_Struct;

/*
 * The tag structure
 */
typedef struct {
    Tk_3DBorder	bg;		/* background color */
    Tk_3DBorder	fg;		/* foreground color */

    char *	borderStr;	/* border style */
    int		borders;	/* number of borders specified (1, 2 or 4) */
    int		bd[4];		/* cell border width */

    int		relief;		/* relief type */
    Tk_Font	tkfont;		/* Information about text font, or NULL. */
    Tk_Anchor	anchor;		/* default anchor point */
    char *	imageStr;	/* name of image */
    Tk_Image	image;		/* actual pointer to image, if any */
    TableState	state;		/* state of the cell */
    Tk_Justify	justify;	/* justification of text in the cell */
    int		multiline;	/* wrapping style of multiline text */
    int		wrap;		/* wrapping style of multiline text */
    int		showtext;	/* whether to display text over image */
} TableTag;

/*  The widget structure for the table Widget */

typedef struct {
    /* basic information about the window and the interpreter */
    Tk_Window tkwin;
    Display *display;
    Tcl_Interp *interp;
    Tcl_Command widgetCmd;	/* Token for entry's widget command. */

    /*
     * Configurable Options
     */
    int autoClear;
    char *selectMode;		/* single, browse, multiple, or extended */
    int selectType;		/* row, col, both, or cell */
    int selectTitles;		/* whether to do automatic title selection */
    int rows, cols;		/* number of rows and columns */
    int defRowHeight;		/* default row height in chars (positive)
				 * or pixels (negative) */
    int defColWidth;		/* default column width in chars (positive)
				 * or pixels (negative) */
    int maxReqCols;		/* the requested # cols to display */
    int maxReqRows;		/* the requested # rows to display */
    int maxReqWidth;		/* the maximum requested width in pixels */
    int maxReqHeight;		/* the maximum requested height in pixels */
    char *arrayVar;		/* name of traced array variable */
    char *rowSep;		/* separator string to place between
				 * rows when getting selection */
    char *colSep;		/* separator string to place between
				 * cols when getting selection */
    TableTag defaultTag;	/* the default tag colors/fonts etc */
    char *yScrollCmd;		/* the y-scroll command */
    char *xScrollCmd;		/* the x-scroll command */
    char *browseCmd;		/* the command that is called when the
				 * active cell changes */
    int caching;		/* whether to cache values of table */
    char *command;		/* A command to eval when get/set occurs
				 * for table values */
    int useCmd;			/* Signals whether to use command or the
				 * array variable, will be 0 if command errs */
    char *selCmd;		/* the command that is called to when a
				 * [selection get] call occurs for a table */
    char *valCmd;		/* Command prefix to use when invoking
				 * validate command.  NULL means don't
				 * invoke commands.  Malloc'ed. */
    int validate;		/* Non-zero means try to validate */
    Tk_3DBorder insertBg;	/* the cursor color */
    Tk_Cursor cursor;		/* the regular mouse pointer */
    Tk_Cursor bdcursor;		/* the mouse pointer when over borders */
    int exportSelection;	/* Non-zero means tie internal table
				 * to X selection. */
    TableState state;		/* Normal or disabled.	Table is read-only
				 * when disabled. */
    int insertWidth;		/* Total width of insert cursor. */
    int insertBorderWidth;	/* Width of 3-D border around insert cursor. */
    int insertOnTime;		/* Number of milliseconds cursor should spend
				 * in "on" state for each blink. */
    int insertOffTime;		/* Number of milliseconds cursor should spend
				 * in "off" state for each blink. */
    int invertSelected;		/* Whether to draw selected cells swapping
				 * foreground and background */
    int colStretch;		/* The way to stretch columns if the window
				 * is too large */
    int rowStretch;		/* The way to stretch rows if the window is
				 * too large */
    int colOffset;		/* X index of leftmost col in the display */
    int rowOffset;		/* Y index of topmost row in the display */
    int drawMode;		/* The mode to use when redrawing */
    int flashMode;		/* Specifies whether flashing is enabled */
    int flashTime;		/* The number of ms to flash a cell for */
    int resize;			/* -resizeborders option for interactive
				 * resizing of borders */
    int sparse;			/* Whether to use "sparse" arrays by
				 * deleting empty array elements (default) */
    char *rowTagCmd, *colTagCmd;/* script to eval for getting row/tag cmd */
    int highlightWidth;		/* Width in pixels of highlight to draw
				 * around widget when it has the focus.
				 * <= 0 means don't draw a highlight. */
    XColor *highlightBgColorPtr;/* Color for drawing traversal highlight
				 * area when highlight is off. */
    XColor *highlightColorPtr;	/* Color for drawing traversal highlight. */
    char *takeFocus;		/* Used only in Tcl to check if this
				 * widget will accept focus */
    int padX, padY;		/* Extra space around text (pixels to leave
				 * on each side).  Ignored for bitmaps and
				 * images. */
    int ipadX, ipadY;		/* Space to leave empty around cell borders.
				 * This differs from pad* in that it is always
				 * present for the cell (except windows). */

    /*
     * Cached Information
     */
    int titleRows, titleCols;	/* the number of rows|cols to use as a title */
    /* these are kept in real coords */
    int topRow, leftCol;	/* The topleft cell to display excluding the
				 * fixed title rows.  This is just the
				 * config request.  The actual cell used may
				 * be different to keep the screen full */
    int anchorRow, anchorCol;	/* the row,col of the anchor cell */
    int activeRow, activeCol;	/* the row,col of the active cell */
    int oldTopRow, oldLeftCol;	/* cached by TableAdjustParams */
    int oldActRow, oldActCol;	/* cached by TableAdjustParams */
    int icursor;		/* The index of the insertion cursor in the
				 * active cell */
    int flags;			/* An or'ed combination of flags concerning
				 * redraw/cursor etc. */
    int dataSource;		/* where our data comes from:
				 * DATA_{NONE,CACHE,ARRAY,COMMAND} */
    int maxWidth, maxHeight;	/* max width|height required in pixels */
    int charWidth, charHeight;	/* size of a character in the default font */
    int *colPixels, *rowPixels;	/* Array of the pixel widths/heights */
    int *colStarts, *rowStarts;	/* Array of start pixels for rows|columns */
    int scanMarkX, scanMarkY;	/* Used by "scan" and "border" to mark */
    int scanMarkRow, scanMarkCol;/* necessary information for dragto */
    /* values in these are kept in user coords */
    Tcl_HashTable *cache;	/* value cache */

    /*
     * colWidths and rowHeights are indexed from 0, so always adjust numbers
     * by the appropriate *Offset factor
     */
    Tcl_HashTable *colWidths;	/* hash table of non default column widths */
    Tcl_HashTable *rowHeights;	/* hash table of non default row heights */
    Tcl_HashTable *spanTbl;	/* table for spans */
    Tcl_HashTable *spanAffTbl;	/* table for cells affected by spans */
    Tcl_HashTable *tagTable;	/* table for style tags */
    Tcl_HashTable *winTable;	/* table for embedded windows */
    Tcl_HashTable *rowStyles;	/* table for row styles */
    Tcl_HashTable *colStyles;	/* table for col styles */
    Tcl_HashTable *cellStyles;	/* table for cell styles */
    Tcl_HashTable *flashCells;	/* table of flashing cells */
    Tcl_HashTable *selCells;	/* table of selected cells */
    Tcl_TimerToken cursorTimer;	/* timer token for the cursor blinking */
    Tcl_TimerToken flashTimer;	/* timer token for the cell flashing */
    char *activeBuf;		/* buffer where the selection is kept
				 * for editing the active cell */
    char **tagPrioNames;	/* list of tag names in priority order */
    TableTag **tagPrios;	/* list of tag pointers in priority order */
    TableTag *activeTagPtr;	/* cache of active composite tag */
    int activeX, activeY;	/* cache offset of active layout in cell */
    int tagPrioSize;		/* size of tagPrios list */
    int tagPrioMax;		/* max allocated size of tagPrios list */

    /* The invalid rectangle if there is an update pending */
    int invalidX, invalidY, invalidWidth, invalidHeight;
    int seen[4];			/* see TableUndisplay */

#ifdef POSTSCRIPT
    /* Pointer to information used for generating Postscript for the canvas.
     * NULL means no Postscript is currently being generated. */
    struct TkPostscriptInfo *psInfoPtr;
#endif

#ifdef PROCS
    Tcl_HashTable *inProc;	/* cells where proc is being evaled */
    int showProcs;		/* whether to show embedded proc (1) or
				 * its calculated value (0) */
    int hasProcs;		/* whether table has embedded procs or not */
#endif
} Table;

/*
 * HEADERS FOR EMBEDDED WINDOWS
 */

/*
 * A structure of the following type holds information for each window
 * embedded in a table widget.
 */

typedef struct TableEmbWindow {
    Table *tablePtr;		/* Information about the overall table
				 * widget. */
    Tk_Window tkwin;		/* Window for this segment.  NULL means that
				 * the window hasn't been created yet. */
    Tcl_HashEntry *hPtr;	/* entry into winTable */
    char *create;		/* Script to create window on-demand.
				 * NULL means no such script.
				 * Malloc-ed. */
    Tk_3DBorder bg;		/* background color */

    char *borderStr;		/* border style */
    int borders;		/* number of borders specified (1, 2 or 4) */
    int bd[4];			/* border width for cell around window */

    int relief;			/* relief type */
    int sticky;			/* How to align window in space */
    int padX, padY;		/* Padding to leave around each side
				 * of window, in pixels. */
    int displayed;		/* Non-zero means that the window has been
				 * displayed on the screen recently. */
} TableEmbWindow;

extern Tk_ConfigSpec tableSpecs[];

extern void	EmbWinDisplay _ANSI_ARGS_((Table *tablePtr, Drawable window,
			TableEmbWindow *ewPtr, TableTag *tagPtr,
			int x, int y, int width, int height));
extern void	EmbWinUnmap _ANSI_ARGS_((register Table *tablePtr,
			int rlo, int rhi, int clo, int chi));
extern void	EmbWinDelete _ANSI_ARGS_((register Table *tablePtr,
			TableEmbWindow *ewPtr));
extern int	Table_WinMove _ANSI_ARGS_((register Table *tablePtr,
			char *CONST srcPtr, char *CONST destPtr, int flags));
extern int	Table_WinDelete _ANSI_ARGS_((register Table *tablePtr,
			char *CONST idxPtr));
extern int	Table_WindowCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	TableValidateChange _ANSI_ARGS_((Table *tablePtr, int r,
			int c, char *oldVal, char *newVal, int idx));
extern void	TableLostSelection _ANSI_ARGS_((ClientData clientData));
extern void	TableSetActiveIndex _ANSI_ARGS_((register Table *tablePtr));

/*
 * HEADERS IN tkTableCmds.c
 */

extern int	Table_ActivateCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_AdjustCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_BboxCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_BorderCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_ClearCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_CurselectionCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_CurvalueCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_GetCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_ScanCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_SeeCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_SelAnchorCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_SelClearCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_SelIncludesCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_SelSetCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_ViewCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));

/*
 * HEADERS IN tkTableEdit.c
 */

extern int	Table_EditCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern void	TableDeleteChars _ANSI_ARGS_((register Table *tablePtr,
			int idx, int count));
extern void	TableInsertChars _ANSI_ARGS_((register Table *tablePtr,
			int idx, char *string));

/*
 * HEADERS IN tkTableTag.c
 */

extern TableTag *TableNewTag _ANSI_ARGS_((Table *tablePtr));
extern void	TableResetTag _ANSI_ARGS_((Table *tablePtr, TableTag *tagPtr));
extern void	TableMergeTag _ANSI_ARGS_((Table *tablePtr, TableTag *baseTag,
			TableTag *addTag));
extern void	TableInvertTag _ANSI_ARGS_((TableTag *baseTag));
extern int	TableGetTagBorders _ANSI_ARGS_((TableTag *tagPtr,
			int *left, int *right, int *top, int *bottom));
extern void	TableInitTags _ANSI_ARGS_((Table *tablePtr));
extern TableTag *FindRowColTag _ANSI_ARGS_((Table *tablePtr,
			int cell, int type));
extern void	TableCleanupTag _ANSI_ARGS_((Table *tablePtr,
			TableTag *tagPtr));
extern int	Table_TagCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));

/*
 * HEADERS IN tkTableUtil.c
 */

extern int	TableOptionBdSet _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, Tk_Window tkwin,
			CONST84 char *value, char *widgRec, int offset));
extern CONST86 char *	TableOptionBdGet _ANSI_ARGS_((ClientData clientData,
			Tk_Window tkwin, char *widgRec, int offset,
			Tcl_FreeProc **freeProcPtr));
extern int	TableTagConfigureBd _ANSI_ARGS_((Table *tablePtr,
			TableTag *tagPtr, char *oldValue, int nullOK));
extern int	Cmd_OptionSet _ANSI_ARGS_((ClientData clientData,
					   Tcl_Interp *interp,
					   Tk_Window unused, CONST84 char *value,
					   char *widgRec, int offset));
extern CONST86 char *	Cmd_OptionGet _ANSI_ARGS_((ClientData clientData,
					   Tk_Window unused, char *widgRec,
					   int offset,
					   Tcl_FreeProc **freeProcPtr));

/*
 * HEADERS IN tkTableCell.c
 */

extern int	TableTrueCell _ANSI_ARGS_((Table *tablePtr, int row, int col,
					   int *trow, int *tcol));
extern int	TableCellCoords _ANSI_ARGS_((Table *tablePtr, int row,
			int col, int *rx, int *ry, int *rw, int *rh));
extern int	TableCellVCoords _ANSI_ARGS_((Table *tablePtr, int row,
			int col, int *rx, int *ry,
			int *rw, int *rh, int full));
extern void	TableWhatCell _ANSI_ARGS_((register Table *tablePtr,
			int x, int y, int *row, int *col));
extern int	TableAtBorder _ANSI_ARGS_((Table *tablePtr, int x, int y,
			int *row, int *col));
extern char *	TableGetCellValue _ANSI_ARGS_((Table *tablePtr, int r, int c));
extern int	TableSetCellValue _ANSI_ARGS_((Table *tablePtr, int r, int c,
			char *value));
extern int    TableMoveCellValue _ANSI_ARGS_((Table *tablePtr,
			int fromr, int fromc, char *frombuf,
			int tor, int toc, char *tobuf, int outOfBounds));

extern int	TableGetIcursor _ANSI_ARGS_((Table *tablePtr, char *arg,
			int *posn));
#define TableGetIcursorObj(tablePtr, objPtr, posnPtr) \
	TableGetIcursor(tablePtr, Tcl_GetString(objPtr), posnPtr)
extern int	TableGetIndex _ANSI_ARGS_((register Table *tablePtr,
			char *str, int *row_p, int *col_p));
#define TableGetIndexObj(tablePtr, objPtr, rowPtr, colPtr) \
	TableGetIndex(tablePtr, Tcl_GetString(objPtr), rowPtr, colPtr)
extern int	Table_SetCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_HiddenCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern int	Table_SpanCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern void	TableSpanSanCheck _ANSI_ARGS_((register Table *tablePtr));

/*
 * HEADERS IN TKTABLECELLSORT
 */
/*
 * We keep the old CellSort true because it is used for grabbing
 * the selection, so we really want them ordered
 */
extern char *	TableCellSort _ANSI_ARGS_((Table *tablePtr, char *str));
#ifdef NO_SORT_CELLS
#  define TableCellSortObj(interp, objPtr) (objPtr)
#else
extern Tcl_Obj*	TableCellSortObj _ANSI_ARGS_((Tcl_Interp *interp,
			Tcl_Obj *listObjPtr));
#endif

/*
 * HEADERS IN TKTABLEPS
 */

#ifdef POSTSCRIPT
extern int	Table_PostscriptCmd _ANSI_ARGS_((ClientData clientData,
			Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
extern void	Tcl_DStringAppendAll _ANSI_ARGS_(TCL_VARARGS(Tcl_DString *, arg1));
#endif

/*
 * HEADERS IN TKTABLE
 */

EXTERN int Tktable_Init		_ANSI_ARGS_((Tcl_Interp *interp));
EXTERN int Tktable_SafeInit	_ANSI_ARGS_((Tcl_Interp *interp));

extern void	TableGetActiveBuf _ANSI_ARGS_((register Table *tablePtr));
extern void	ExpandPercents _ANSI_ARGS_((Table *tablePtr, char *before,
			int r, int c, char *oldVal, char *newVal, int idx,
			Tcl_DString *dsPtr, int cmdType));
extern void	TableInvalidate _ANSI_ARGS_((Table *tablePtr, int x, int y,
			int width, int height, int force));
extern void	TableRefresh _ANSI_ARGS_((register Table *tablePtr,
			int arg1, int arg2, int mode));
extern void	TableGeometryRequest _ANSI_ARGS_((Table *tablePtr));
extern void	TableAdjustActive _ANSI_ARGS_((register Table *tablePtr));
extern void	TableAdjustParams _ANSI_ARGS_((register Table *tablePtr));
extern void	TableConfigCursor _ANSI_ARGS_((register Table *tablePtr));
extern void	TableAddFlash _ANSI_ARGS_((Table *tablePtr, int row, int col));


#define TableInvalidateAll(tablePtr, flags) \
	TableInvalidate((tablePtr), 0, 0, Tk_Width((tablePtr)->tkwin),\
		Tk_Height((tablePtr)->tkwin), (flags))

     /*
      * Turn row/col into an index into the table
      */
#define TableMakeArrayIndex(r, c, i)	sprintf((i), "%d,%d", (r), (c))

     /*
      * Turn array index back into row/col
      * return the number of args parsed (should be two)
      */
#define TableParseArrayIndex(r, c, i)	sscanf((i), "%d,%d", (r), (c))

     /*
      * Macro for finding the last cell of the table
      */
#define TableGetLastCell(tablePtr, rowPtr, colPtr) \
	TableWhatCell((tablePtr),\
		Tk_Width((tablePtr)->tkwin)-(tablePtr)->highlightWidth-1,\
		Tk_Height((tablePtr)->tkwin)-(tablePtr)->highlightWidth-1,\
		(rowPtr), (colPtr))

/*
 * Macros used to cast between pointers and integers (e.g. when storing an int
 * in ClientData), on 64-bit architectures they avoid gcc warning about "cast
 * to/from pointer from/to integer of different size".
 */

#if !defined(INT2PTR) && !defined(PTR2INT)
#   if defined(HAVE_INTPTR_T) || defined(intptr_t)
#  define INT2PTR(p) ((void *)(intptr_t)(p))
#  define PTR2INT(p) ((int)(intptr_t)(p))
#   else
#  define INT2PTR(p) ((void *)(p))
#  define PTR2INT(p) ((int)(p))
#   endif
#endif
#if !defined(UINT2PTR) && !defined(PTR2UINT)
#   if defined(HAVE_UINTPTR_T) || defined(uintptr_t)
#  define UINT2PTR(p) ((void *)(uintptr_t)(p))
#  define PTR2UINT(p) ((unsigned int)(uintptr_t)(p))
#   else
#  define UINT2PTR(p) ((void *)(p))
#  define PTR2UINT(p) ((unsigned int)(p))
#   endif
#endif

/*
 * end of header
 * reset TCL_STORAGE_CLASS to DLLIMPORT.
 */
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKTABLE_H_ */

@


1.3
log
@touched all files to ease next import
@
text
@d18 11
d31 1
d33 5
a65 10
#ifdef WIN32
#   define WIN32_LEAN_AND_MEAN
#   include <windows.h>
#   undef WIN32_LEAN_AND_MEAN
/* VC++ has an entry point called DllMain instead of DllEntryPoint */
#   if defined(_MSC_VER)
#	define DllEntryPoint DllMain
#   endif
#endif

d516 2
a517 2
			char *value, char *widgRec, int offset));
extern char *	TableOptionBdGet _ANSI_ARGS_((ClientData clientData,
d524 1
a524 1
					   Tk_Window unused, char *value,
d526 1
a526 1
extern char *	Cmd_OptionGet _ANSI_ARGS_((ClientData clientData,
d641 25
@


1.2
log
@	Update tkTable to version 2.7:
	* src/tkTableCmds.c, src/tkTable.tcl.h, src/tkTableCellSort.c,
	src/tkTableEdit.c, src/tkTableInitScript.h, src/tkTablePs.c,
	src/tkTableUtil.c, doc/tkTable.html: New files.
	* src/tkTable.c, src/tkTable.h, src/TkTable.tcl, src/tkTableCell.c,
	src/tkTableTag.c, src/tkTableWin.c, src/tkTable_version.in: Update to
	version 2.7.
	* configure.in: If compiling with cygwin, we need to have
	WIN32 defined to build tkTable modules.
	* configure: Regenerate.
	* src/Makefile.am: Add new tkTable files and update build rules
	for new version of tkTable.
	* src/Makefile.in: Regenerate.
@
text
@@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * Copyright (c) 1997,1998 Jeffrey Hobbs
d9 1
a9 1
 * See the file "license.terms" for information on usage and redistribution
d12 1
d21 18
a38 1
#include <X11/Xatom.h>
d40 8
a47 1
#include "tkTableCmd.h"
d49 1
a49 1
#ifdef _WIN32
d53 1
a53 6

/*
 * VC++ has an alternate entry point called DllMain, so we need to rename
 * our entry point.
 */

a54 1
#	define EXPORT(a,b) __declspec(dllexport) a b
a55 6
#   else
#	if defined(__BORLANDC__)
#	    define EXPORT(a,b) a _export b
#	else
#	    define EXPORT(a,b) a b
#	endif
d57 1
d59 6
a64 19
/* Necessary to get XSync call defined */
#   include <tkInt.h>

#else	/* ! WIN32 */
#   define EXPORT(a,b) a b
#endif	/* WIN32 */

#ifdef INLINE
#undef INLINE
#endif
#ifdef __GNUC__
#    define INLINE inline
#else
#    if defined(_MSC_VER)
#	define INLINE __inline
#    else
#	define INLINE
#    endif
#endif
d67 26
a92 16
#	ifdef _WIN32
#		define NORMAL_BG	"SystemButtonFace"
#		define ACTIVE_BG	NORMAL_BG
#		define SELECT_BG	"SystemHighlight"
#		define DISABLED		"SystemDisabledText"
#		define HIGHLIGHT	"SystemWindowFrame"
#		define DEF_TABLE_FONT	"{MS Sans Serif} 8"
#	else
#		define NORMAL_BG	"#d9d9d9"
#		define ACTIVE_BG	"#fcfcfc"
#		define SELECT_BG	"#c3c3c3"
#		define DISABLED		"#a3a3a3"
#		define HIGHLIGHT	"Black"
#		define DEF_TABLE_FONT	"Helvetica -12"
#	endif
#endif
d96 5
d102 1
a102 1
#define INDEX_BUFSIZE	64		/* max size of buffer for indices */
d126 1
d143 1
d148 8
a155 1
#define CELL		(ROW|COL)
d160 8
d177 10
d188 2
a189 3
  STATE_UNUSED, STATE_UNKNOWN, STATE_HIDDEN,
  STATE_NORMAL, STATE_DISABLED, STATE_ACTIVE,
  STATE_LAST
d192 4
a195 1
/* The tag structure */
d197 25
a221 12
  Tk_3DBorder	bg;		/* background color */
  Tk_3DBorder	fg;		/* foreground color */
  int		relief;		/* relief type */
  Tk_Font	tkfont;		/* Information about text font, or NULL. */
  Tk_Anchor	anchor;		/* default anchor point */
  char *	imageStr;	/* name of image */
  Tk_Image	image;		/* actual pointer to image, if any */
  TableState	state;		/* state of the cell */
  Tk_Justify	justify;	/* justification of text in the cell */
  int		multiline;	/* wrapping style of multiline text */
  int		wrap;		/* wrapping style of multiline text */
  int		showtext;	/* whether to display text over image */
d227 15
a241 12
  /* basic information about the window and the interpreter */
  Tk_Window tkwin;
  Display *display;
  Tcl_Interp *interp;
  Tcl_Command widgetCmd;	/* Token for entry's widget command. */
  /* Configurable Options */
  int autoClear;
  char *selectMode;		/* single, browse, multiple, or extended */
  int selectType;		/* row, col, both, or cell */
  int selectTitles;		/* whether to do automatic title selection */
  int rows, cols;		/* number of rows and columns */
  int defRowHeight;		/* default row height in chars (positive)
d243 1
a243 1
  int defColWidth;		/* default column width in chars (positive)
d245 6
a250 6
  int maxReqCols;		/* the requested # cols to display */
  int maxReqRows;		/* the requested # rows to display */
  int maxReqWidth;		/* the maximum requested width in pixels */
  int maxReqHeight;		/* the maximum requested height in pixels */
  char *arrayVar;		/* name of traced array variable */
  char *rowSep;			/* separator string to place between
d252 1
a252 1
  char *colSep;			/* separator string to place between
d254 4
a257 5
  int borderWidth;		/* internal borderwidth */
  TableTag defaultTag;		/* the default tag colors/fonts etc */
  char *yScrollCmd;		/* the y-scroll command */
  char *xScrollCmd;		/* the x-scroll command */
  char *browseCmd;		/* the command that is called when the
d259 2
a260 2
  int caching;			/* whether to cache values of table */
  char *command;		/* A command to eval when get/set occurs
d262 1
a262 1
  int useCmd;			/* Signals whether to use command or the
d264 1
a264 1
  char *selCmd;			/* the command that is called to when a
d266 1
a266 1
  char *valCmd;			/* Command prefix to use when invoking
d269 5
a273 5
  int validate;			/* Non-zero means try to validate */
  Tk_3DBorder insertBg;		/* the cursor color */
  Tk_Cursor cursor;		/* the regular mouse pointer */
  Tk_Cursor bdcursor;		/* the mouse pointer when over borders */
  int exportSelection;		/* Non-zero means tie internal table
d275 1
a275 1
  TableState state;		/* Normal or disabled.  Table is read-only
d277 3
a279 3
  int insertWidth;		/* Total width of insert cursor. */
  int insertBorderWidth;	/* Width of 3-D border around insert cursor. */
  int insertOnTime;		/* Number of milliseconds cursor should spend
d281 1
a281 1
  int insertOffTime;		/* Number of milliseconds cursor should spend
d283 12
a294 12
  int invertSelected;           /* Whether to draw selected cells swapping
                                   foreground and background */
  int colStretch;		/* The way to stretch columns if the window
				   is too large */
  int rowStretch;		/* The way to stretch rows if the window is
				   too large */
  int colOffset;		/* X index of leftmost col in the display */
  int rowOffset;		/* Y index of topmost row in the display */
  int drawMode;			/* The mode to use when redrawing */
  int flashMode;		/* Specifies whether flashing is enabled */
  int flashTime;		/* The number of ms to flash a cell for */
  int resize;			/* -resizeborders option for interactive
d296 4
a299 2
  char *rowTagCmd, *colTagCmd;	/* script to eval for getting row/tag cmd */
  int highlightWidth;		/* Width in pixels of highlight to draw
d302 1
a302 1
  XColor *highlightBgColorPtr;	/* Color for drawing traversal highlight
d304 2
a305 2
  XColor *highlightColorPtr;	/* Color for drawing traversal highlight. */
  char *takeFocus;		/* Used only in Tcl to check if this
d307 1
a307 1
  int padX, padY;		/* Extra space around text (pixels to leave
d310 10
a319 5

  /* Cached Information */
  int titleRows, titleCols;	/* the number of rows|cols to use as a title */
  /* these are kept in real coords */
  int topRow, leftCol;		/* The topleft cell to display excluding the
d323 9
a331 9
  int anchorRow, anchorCol;	/* the row,col of the anchor cell */
  int activeRow, activeCol;	/* the row,col of the active cell */
  int oldTopRow, oldLeftCol;	/* cached by TableAdjustParams */
  int oldActRow, oldActCol;	/* cached by TableAdjustParams */
  int icursor;			/* The index of the insertion cursor in the
				   active cell */
  int flags;			/* An or'ed combination of flags concerning
				   redraw/cursor etc. */
  int dataSource;		/* where our data comes from:
d333 51
a383 29
  int maxWidth, maxHeight;	/* max width|height required in pixels */
  int charWidth, charHeight;	/* size of a character in the default font */
  int *colPixels;		/* Array of the pixel width of each column */
  int *rowPixels;		/* Array of the pixel height of each row */
  int *colStarts, *rowStarts;	/* Array of start pixels for rows|columns */
  int scanMarkX, scanMarkY;	/* Used by "scan" and "border" to mark */
  int scanMarkRow, scanMarkCol;	/* necessary information for dragto */
  /* values in these are kept in user coords */
  Tcl_HashTable *cache;		/* value cache */
  /* colWidths and rowHeights are indexed from 0, so always adjust numbers
     by the appropriate *Offset factor */
  Tcl_HashTable *colWidths;	/* hash table of non default column widths */
  Tcl_HashTable *rowHeights;	/* hash table of non default row heights */
  Tcl_HashTable *tagTable;	/* table for style tags */
  Tcl_HashTable *winTable;	/* table for embedded windows */
  Tcl_HashTable *rowStyles;	/* table for row styles */
  Tcl_HashTable *colStyles;	/* table for col styles */
  Tcl_HashTable *cellStyles;	/* table for cell styles */
  Tcl_HashTable *flashCells;	/* table of flashing cells */
  Tcl_HashTable *selCells;	/* table of selected cells */
  Tcl_TimerToken cursorTimer;	/* timer token for the cursor blinking */
  Tcl_TimerToken flashTimer;	/* timer token for the cell flashing */
  char *activeBuf;		/* buffer where the selection is kept
				   for editing the active cell */
  Tk_TextLayout activeLayout;	/* cache of active layout */
  int activeX, activeY;		/* cache offset of active layout in cell */
  /* The invalid rectangle if there is an update pending */
  int invalidX, invalidY, invalidWidth, invalidHeight;
  int seen[4];			/* see TableUndisplay */
d396 1
a396 1
  Table *tablePtr;		/* Information about the overall table
d398 4
a401 6
  Tk_Window tkwin;		/* Window for this segment.  NULL
				 * means that the window hasn't
				 * been created yet. */
  Tcl_HashEntry *hPtr;		/* entry into winTable */
  Tk_3DBorder bg;		/* background color */
  char *create;			/* Script to create window on-demand.
d404 9
a412 3
  int relief;			/* relief type */
  int sticky;			/* How to align window in space */
  int padX, padY;		/* Padding to leave around each side
d414 2
a415 3
  int displayed;		/* Non-zero means that the window
				 * has been displayed on the screen
				 * recently. */
d418 2
d421 2
a422 3
					   TableEmbWindow *ewPtr,
					   TableTag *tagPtr, int x, int y,
					   int width, int height));
d424 1
a424 2
					 int rlo, int rhi,
					 int clo, int chi));
d426 46
a471 4
					   TableEmbWindow *ewPtr));
extern int	TableWindowCmd _ANSI_ARGS_((Table *tablePtr,
					    Tcl_Interp *interp,
					    int argc, char *argv[]));
d474 1
a474 1
 * HEADERS IN TKTABLETAG
d477 15
a491 3
extern TableTag *TableNewTag _ANSI_ARGS_((void));
extern void	TableMergeTag _ANSI_ARGS_((TableTag *baseTag,
					   TableTag *addTag));
d493 2
d497 1
a497 1
					     int cell, int type));
d499 3
a501 3
					     TableTag *tagPtr));
extern int	TableTagCmd _ANSI_ARGS_((Table *tablePtr, Tcl_Interp *interp,
					 int argc, char *argv[]));
d504 1
a504 1
 * HEADERS IN TKTABLECELL
d507 25
a531 3
extern void	TableCellCoords _ANSI_ARGS_((Table *tablePtr, int row,
					     int col, int *rx, int *ry,
					     int *rw, int *rh));
d533 2
a534 2
					      int col, int *rx, int *ry,
					      int *rw, int *rh, int full));
d536 1
a536 1
					   int x, int y, int *row, int *col));
d538 1
a538 1
					   int *row, int *col));
d541 28
a568 1
					       char *value));
d570 16
a585 4
extern int	TableGetIcursor _ANSI_ARGS_((Table *tablePtr, char *arg,
					     int *posn));
extern int	TableGetIndex _ANSI_ARGS_((register Table *tablePtr, char *str,
					   int *row_p, int *col_p));
d591 2
a592 1
EXTERN EXPORT(int,Example_Init) _ANSI_ARGS_((Tcl_Interp *interp));
d594 1
d596 1
a596 1
			int r, int c, char *old, char *new, int index,
d599 1
a599 2
					     int width, int height,
					     int force));
d601 6
a606 1
					  int arg1, int arg2, int mode));
d608 2
a609 1
#define TableInvalidateAll(tablePtr, flags)	\
d611 1
a611 1
			Tk_Height((tablePtr)->tkwin), (flags))
d627 1
a627 1
#define TableGetLastCell(tablePtr, rowPtr, colPtr)	\
d629 10
a638 3
		      Tk_Width((tablePtr)->tkwin)-(tablePtr)->highlightWidth,\
		      Tk_Height((tablePtr)->tkwin)-(tablePtr)->highlightWidth,\
		      (rowPtr), (colPtr))
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
