head	1.94;
access;
symbols
	binutils-2_24-branch:1.94.0.2
	binutils-2_24-branchpoint:1.94
	binutils-2_21_1:1.85.2.2
	binutils-2_23_2:1.91
	binutils-2_23_1:1.91
	binutils-2_23:1.91
	binutils-2_23-branch:1.91.0.2
	binutils-2_23-branchpoint:1.91
	binutils-2_22_branch:1.90.0.4
	binutils-2_22:1.90
	binutils-2_22-branch:1.90.0.2
	binutils-2_22-branchpoint:1.90
	binutils-2_21:1.85
	binutils-2_21-branch:1.85.0.2
	binutils-2_21-branchpoint:1.85
	binutils-2_20_1:1.77.2.3
	binutils-2_20:1.77.2.1
	binutils-arc-20081103-branch:1.72.0.6
	binutils-arc-20081103-branchpoint:1.72
	binutils-2_20-branch:1.77.0.2
	binutils-2_20-branchpoint:1.77
	dje-cgen-play1-branch:1.75.0.2
	dje-cgen-play1-branchpoint:1.75
	arc-20081103-branch:1.72.0.4
	arc-20081103-branchpoint:1.72
	binutils-2_19_1:1.72
	binutils-2_19:1.72
	binutils-2_19-branch:1.72.0.2
	binutils-2_19-branchpoint:1.72
	binutils-2_18:1.70
	binutils-2_18-branch:1.70.0.2
	binutils-2_18-branchpoint:1.70
	binutils-csl-coldfire-4_1-32:1.64.2.1
	binutils-csl-sourcerygxx-4_1-32:1.64.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.64.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.55
	binutils-csl-coldfire-4_1-30:1.64.2.1
	binutils-csl-sourcerygxx-4_1-30:1.64.2.1
	binutils-csl-coldfire-4_1-28:1.64.2.1
	binutils-csl-sourcerygxx-4_1-29:1.64.2.1
	binutils-csl-sourcerygxx-4_1-28:1.64.2.1
	binutils-csl-arm-2006q3-27:1.64.2.1
	binutils-csl-sourcerygxx-4_1-27:1.64.2.1
	binutils-csl-arm-2006q3-26:1.64.2.1
	binutils-csl-sourcerygxx-4_1-26:1.64.2.1
	binutils-csl-sourcerygxx-4_1-25:1.64.2.1
	binutils-csl-sourcerygxx-4_1-24:1.64.2.1
	binutils-csl-sourcerygxx-4_1-23:1.64.2.1
	binutils-csl-sourcerygxx-4_1-21:1.64.2.1
	binutils-csl-arm-2006q3-21:1.64.2.1
	binutils-csl-sourcerygxx-4_1-22:1.64.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.64.2.1
	binutils-csl-sourcerygxx-4_1-20:1.64.2.1
	binutils-csl-arm-2006q3-19:1.64.2.1
	binutils-csl-sourcerygxx-4_1-19:1.64.2.1
	binutils-csl-sourcerygxx-4_1-18:1.64.2.1
	binutils-csl-renesas-4_1-9:1.64.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.55
	binutils-csl-renesas-4_1-8:1.64
	binutils-csl-renesas-4_1-7:1.64
	binutils-csl-renesas-4_1-6:1.64
	binutils-csl-sourcerygxx-4_1-17:1.64
	binutils-csl-sourcerygxx-4_1-14:1.64
	binutils-csl-sourcerygxx-4_1-15:1.64
	binutils-csl-sourcerygxx-4_1-13:1.64
	binutils-2_17:1.65
	binutils-csl-sourcerygxx-4_1-12:1.64
	binutils-csl-sourcerygxx-3_4_4-21:1.64
	binutils-csl-wrs-linux-3_4_4-24:1.55
	binutils-csl-wrs-linux-3_4_4-23:1.55
	binutils-csl-sourcerygxx-4_1-9:1.64
	binutils-csl-sourcerygxx-4_1-8:1.64
	binutils-csl-sourcerygxx-4_1-7:1.64
	binutils-csl-arm-2006q1-6:1.64
	binutils-csl-sourcerygxx-4_1-6:1.64
	binutils-csl-wrs-linux-3_4_4-22:1.55
	binutils-csl-coldfire-4_1-11:1.64
	binutils-csl-sourcerygxx-3_4_4-19:1.64
	binutils-csl-coldfire-4_1-10:1.64
	binutils-csl-sourcerygxx-4_1-5:1.64
	binutils-csl-sourcerygxx-4_1-4:1.64
	binutils-csl-wrs-linux-3_4_4-21:1.55
	binutils-csl-morpho-4_1-4:1.64
	binutils-csl-sourcerygxx-3_4_4-17:1.64
	binutils-csl-wrs-linux-3_4_4-20:1.55
	binutils-2_17-branch:1.65.0.2
	binutils-2_17-branchpoint:1.65
	binutils-csl-2_17-branch:1.64.0.2
	binutils-csl-2_17-branchpoint:1.64
	binutils-csl-gxxpro-3_4-branch:1.55.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.55
	binutils-2_16_1:1.55
	binutils-csl-arm-2005q1b:1.55
	binutils-2_16:1.55
	binutils-csl-arm-2005q1a:1.55
	binutils-csl-arm-2005q1-branch:1.55.0.4
	binutils-csl-arm-2005q1-branchpoint:1.55
	binutils-2_16-branch:1.55.0.2
	binutils-2_16-branchpoint:1.55
	csl-arm-2004-q3d:1.52
	csl-arm-2004-q3:1.52
	binutils-2_15:1.48.6.2
	binutils-2_15-branchpoint:1.48
	csl-arm-2004-q1a:1.50
	csl-arm-2004-q1:1.49
	binutils-2_15-branch:1.48.0.6
	cagney_bfdfile-20040213-branch:1.48.0.4
	cagney_bfdfile-20040213-branchpoint:1.48
	cagney_bigcore-20040122-branch:1.48.0.2
	cagney_bigcore-20040122-branchpoint:1.48
	csl-arm-2003-q4:1.48
	binutils-2_14:1.46
	binutils-2_14-branch:1.46.0.2
	binutils-2_14-branchpoint:1.46
	binutils-2_13_2_1:1.42
	binutils-2_13_2:1.42
	binutils-2_13_1:1.42
	binutils-2_13:1.42
	binutils-2_13-branchpoint:1.42
	binutils-2_13-branch:1.42.0.2
	binutils-2_12_1:1.41
	binutils-2_12:1.41
	binutils-2_12-branch:1.41.0.2
	binutils-2_12-branchpoint:1.41
	cygnus_cvs_20020108_pre:1.41
	binutils-2_11_2:1.27.2.2
	binutils-2_11_1:1.27.2.2
	binutils-2_11:1.27.2.1
	x86_64versiong3:1.29
	binutils-2_11-branch:1.27.0.2
	binutils-2_10_1:1.14
	binutils-2_10:1.14
	binutils-2_10-branch:1.14.0.2
	binutils-2_10-branchpoint:1.14
	binutils_latest_snapshot:1.94
	repo-unification-2000-02-06:1.9
	binu_ss_19990721:1.5
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.94
date	2013.04.15.10.30.22;	author jules;	state Exp;
branches;
next	1.93;

1.93
date	2013.04.11.10.54.13;	author jules;	state Exp;
branches;
next	1.92;

1.92
date	2013.03.08.10.17.00;	author cltang;	state Exp;
branches;
next	1.91;

1.91
date	2012.06.30.00.27.31;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2011.03.17.10.59.29;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2010.12.04.00.19.19;	author macro;	state Exp;
branches;
next	1.88;

1.88
date	2010.12.02.13.25.12;	author rsandifo;	state Exp;
branches;
next	1.87;

1.87
date	2010.12.01.21.34.10;	author macro;	state Exp;
branches;
next	1.86;

1.86
date	2010.12.01.20.35.13;	author macro;	state Exp;
branches;
next	1.85;

1.85
date	2010.09.29.06.48.30;	author amodra;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2010.08.02.13.19.44;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.22.07.43.40;	author jbeulich;	state Exp;
branches;
next	1.82;

1.82
date	2010.04.21.17.10.44;	author hjl;	state Exp;
branches;
next	1.81;

1.81
date	2009.12.11.13.42.09;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2009.12.08.03.14.28;	author hjl;	state Exp;
branches;
next	1.79;

1.79
date	2009.10.28.08.21.45;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2009.07.28.06.20.49;	author jbeulich;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2009.04.20.06.26.23;	author jbeulich;	state Exp;
branches;
next	1.73;

1.73
date	2009.04.16.08.52.27;	author jbeulich;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.19.17.31.24;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.26.08.34.24;	author jbeulich;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.21.06.54.56;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2006.10.24.18.10.57;	author bje;	state Exp;
branches;
next	1.67;

1.67
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.09.04.54.32;	author bje;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.04.08.04.57;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2005.12.22.17.05.40;	author jbeulich;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2005.11.08.15.48.26;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2005.11.07.02.15.47;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2005.11.06.23.04.10;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.10.15.32.44;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.05.09.12.45;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2005.04.29.00.22.26;	author bje;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.15.15.41.31;	author jbeulich;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.03.17.22.12;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.01.22.35.21;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.01.02.00.14;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2004.08.11.02.11.57;	author mmitchel;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.23.04.35.11;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.16.01.55.27;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.18.09.19.20;	author nathan;	state Exp;
branches;
next	1.48;

1.48
date	2003.11.22.16.03.03;	author kazu;	state Exp;
branches
	1.48.6.1;
next	1.47;

1.47
date	2003.05.27.19.19.29;	author rth;	state Exp;
branches;
next	1.46;

1.46
date	2002.10.18.01.56.39;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2002.09.20.00.58.39;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.19.23.51.35;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2002.08.27.11.09.42;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.18.12.53.30;	author kazu;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.11.12.20.25;	author kazu;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.19.05.33.18;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.09.14.01.16;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.14.20.00.32;	author jjohnstn;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.13.11.29.53;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.25.01.59.43;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.25.00.01.30;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.22.10.23.48;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.12.07.03.10;	author aoliva;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.30.07.07.09;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.13.11.17.48;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.13.11.13.53;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.28.13.33.22;	author amodra;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2000.10.30.21.59.01;	author kazu;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.17.20.21.45;	author kazu;	state Exp;
branches;
next	1.24;

1.24
date	2000.09.05.03.53.02;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.03.21.51.27;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.11.17.50.25;	author kazu;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.10.23.13.37;	author kazu;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.17.17.51.18;	author fche;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.23.10.51.28;	author fche;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.23.10.12.48;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.19.01.22.39;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.02.02.52.09;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.21.20.22.22;	author wilson;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.13.21.20.15;	author hp;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.24.01.56.31;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.08.19.41.03;	author twall;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.08.19.06.00;	author twall;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.08.14.21.53;	author twall;	state Exp;
branches;
next	1.9;

1.9
date	99.11.05.21.50.54;	author meissner;	state Exp;
branches;
next	1.8;

1.8
date	99.10.18.22.29.14;	author meissner;	state Exp;
branches;
next	1.7;

1.7
date	99.09.12.02.27.58;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.09.11.14.24.59;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.05.18.19.05;	author rth;	state Exp;
branches;
next	1.4;

1.4
date	99.06.03.02.51.25;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.28.59;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.17.03.21.42;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.85.2.1
date	2011.02.01.12.25.40;	author amodra;	state Exp;
branches;
next	1.85.2.2;

1.85.2.2
date	2011.03.17.11.00.47;	author amodra;	state Exp;
branches;
next	;

1.77.2.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	1.77.2.2;

1.77.2.2
date	2009.10.28.08.23.48;	author amodra;	state Exp;
branches;
next	1.77.2.3;

1.77.2.3
date	2009.12.16.01.52.13;	author hjl;	state Exp;
branches;
next	;

1.64.2.1
date	2006.08.22.15.08.31;	author jsm28;	state Exp;
branches;
next	;

1.48.6.1
date	2004.04.09.18.28.10;	author drow;	state Exp;
branches;
next	1.48.6.2;

1.48.6.2
date	2004.04.16.01.56.00;	author amodra;	state Exp;
branches;
next	1.48.6.3;

1.48.6.3
date	2004.05.23.04.40.32;	author amodra;	state Exp;
branches;
next	;

1.27.2.1
date	2001.02.13.11.21.32;	author amodra;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2001.06.07.03.15.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches;
next	;


desc
@@


1.94
log
@    gas/
    * expr.c (add_to_result, subtract_from_result): Make global.
    * expr.h (add_to_result, subtract_from_result): Add prototypes.
    * config/tc-sh.c (sh_optimize_expr): Use add_to_result,
    subtract_from_result to handle extra bit of precision for .sleb128
    directive operands.

    gas/testsuite/
    * gas/all/gas.exp (sleb128-7): Don't run for tic4x, tic54x.
    * gas/all/sleb128-2.s: Reformat, use _ at start of labels, remove
    cruft.
    * gas/all/sleb128-3.s: Likewise.
    * gas/all/sleb128-4.s: Likewise.
    * gas/all/sleb128-5.s: Likewise.
    * gas/all/sleb128-7.s: Likewise.
    * gas/all/sleb128-2.d: Handle data sections named $DATA$.
    * gas/all/sleb128-3.d: Likewise.
    * gas/all/sleb128-4.d: Likewise.
    * gas/all/sleb128-5.d: Likewise.
    * gas/all/sleb128-7.d: Likewise.
@
text
@/* expr.c -operands, expressions-
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011,
   2012 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This is really a branch office of as-read.c. I split it out to clearly
   distinguish the world of expressions from the world of statements.
   (It also gives smaller files to re-compile.)
   Here, "operand"s are of expressions, not instructions.  */

#define min(a, b)       ((a) < (b) ? (a) : (b))

#include "as.h"
#include "safe-ctype.h"
#include "obstack.h"

#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif
#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

static void floating_constant (expressionS * expressionP);
static valueT generic_bignum_to_int32 (void);
#ifdef BFD64
static valueT generic_bignum_to_int64 (void);
#endif
static void integer_constant (int radix, expressionS * expressionP);
static void mri_char_constant (expressionS *);
static void clean_up_expression (expressionS * expressionP);
static segT operand (expressionS *, enum expr_mode);
static operatorT operatorf (int *);

extern const char EXP_CHARS[], FLT_CHARS[];

/* We keep a mapping of expression symbols to file positions, so that
   we can provide better error messages.  */

struct expr_symbol_line {
  struct expr_symbol_line *next;
  symbolS *sym;
  char *file;
  unsigned int line;
};

static struct expr_symbol_line *expr_symbol_lines;

/* Build a dummy symbol to hold a complex expression.  This is how we
   build expressions up out of other expressions.  The symbol is put
   into the fake section expr_section.  */

symbolS *
make_expr_symbol (expressionS *expressionP)
{
  expressionS zero;
  symbolS *symbolP;
  struct expr_symbol_line *n;

  if (expressionP->X_op == O_symbol
      && expressionP->X_add_number == 0)
    return expressionP->X_add_symbol;

  if (expressionP->X_op == O_big)
    {
      /* This won't work, because the actual value is stored in
	 generic_floating_point_number or generic_bignum, and we are
	 going to lose it if we haven't already.  */
      if (expressionP->X_add_number > 0)
	as_bad (_("bignum invalid"));
      else
	as_bad (_("floating point number invalid"));
      zero.X_op = O_constant;
      zero.X_add_number = 0;
      zero.X_unsigned = 0;
      zero.X_extrabit = 0;
      clean_up_expression (&zero);
      expressionP = &zero;
    }

  /* Putting constant symbols in absolute_section rather than
     expr_section is convenient for the old a.out code, for which
     S_GET_SEGMENT does not always retrieve the value put in by
     S_SET_SEGMENT.  */
  symbolP = symbol_create (FAKE_LABEL_NAME,
			   (expressionP->X_op == O_constant
			    ? absolute_section
			    : expressionP->X_op == O_register
			      ? reg_section
			      : expr_section),
			   0, &zero_address_frag);
  symbol_set_value_expression (symbolP, expressionP);

  if (expressionP->X_op == O_constant)
    resolve_symbol_value (symbolP);

  n = (struct expr_symbol_line *) xmalloc (sizeof *n);
  n->sym = symbolP;
  as_where (&n->file, &n->line);
  n->next = expr_symbol_lines;
  expr_symbol_lines = n;

  return symbolP;
}

/* Return the file and line number for an expr symbol.  Return
   non-zero if something was found, 0 if no information is known for
   the symbol.  */

int
expr_symbol_where (symbolS *sym, char **pfile, unsigned int *pline)
{
  register struct expr_symbol_line *l;

  for (l = expr_symbol_lines; l != NULL; l = l->next)
    {
      if (l->sym == sym)
	{
	  *pfile = l->file;
	  *pline = l->line;
	  return 1;
	}
    }

  return 0;
}

/* Utilities for building expressions.
   Since complex expressions are recorded as symbols for use in other
   expressions these return a symbolS * and not an expressionS *.
   These explicitly do not take an "add_number" argument.  */
/* ??? For completeness' sake one might want expr_build_symbol.
   It would just return its argument.  */

/* Build an expression for an unsigned constant.
   The corresponding one for signed constants is missing because
   there's currently no need for it.  One could add an unsigned_p flag
   but that seems more clumsy.  */

symbolS *
expr_build_uconstant (offsetT value)
{
  expressionS e;

  e.X_op = O_constant;
  e.X_add_number = value;
  e.X_unsigned = 1;
  e.X_extrabit = 0;
  return make_expr_symbol (&e);
}

/* Build an expression for the current location ('.').  */

symbolS *
expr_build_dot (void)
{
  expressionS e;

  current_location (&e);
  return symbol_clone_if_forward_ref (make_expr_symbol (&e));
}

/* Build any floating-point literal here.
   Also build any bignum literal here.  */

/* Seems atof_machine can backscan through generic_bignum and hit whatever
   happens to be loaded before it in memory.  And its way too complicated
   for me to fix right.  Thus a hack.  JF:  Just make generic_bignum bigger,
   and never write into the early words, thus they'll always be zero.
   I hate Dean's floating-point code.  Bleh.  */
LITTLENUM_TYPE generic_bignum[SIZE_OF_LARGE_NUMBER + 6];

FLONUM_TYPE generic_floating_point_number = {
  &generic_bignum[6],		/* low.  (JF: Was 0)  */
  &generic_bignum[SIZE_OF_LARGE_NUMBER + 6 - 1], /* high.  JF: (added +6)  */
  0,				/* leader.  */
  0,				/* exponent.  */
  0				/* sign.  */
};


static void
floating_constant (expressionS *expressionP)
{
  /* input_line_pointer -> floating-point constant.  */
  int error_code;

  error_code = atof_generic (&input_line_pointer, ".", EXP_CHARS,
			     &generic_floating_point_number);

  if (error_code)
    {
      if (error_code == ERROR_EXPONENT_OVERFLOW)
	{
	  as_bad (_("bad floating-point constant: exponent overflow"));
	}
      else
	{
	  as_bad (_("bad floating-point constant: unknown error code=%d"),
		  error_code);
	}
    }
  expressionP->X_op = O_big;
  /* input_line_pointer -> just after constant, which may point to
     whitespace.  */
  expressionP->X_add_number = -1;
}

static valueT
generic_bignum_to_int32 (void)
{
  valueT number =
	   ((generic_bignum[1] & LITTLENUM_MASK) << LITTLENUM_NUMBER_OF_BITS)
	   | (generic_bignum[0] & LITTLENUM_MASK);
  number &= 0xffffffff;
  return number;
}

#ifdef BFD64
static valueT
generic_bignum_to_int64 (void)
{
  valueT number =
    ((((((((valueT) generic_bignum[3] & LITTLENUM_MASK)
	  << LITTLENUM_NUMBER_OF_BITS)
	 | ((valueT) generic_bignum[2] & LITTLENUM_MASK))
	<< LITTLENUM_NUMBER_OF_BITS)
       | ((valueT) generic_bignum[1] & LITTLENUM_MASK))
      << LITTLENUM_NUMBER_OF_BITS)
     | ((valueT) generic_bignum[0] & LITTLENUM_MASK));
  return number;
}
#endif

static void
integer_constant (int radix, expressionS *expressionP)
{
  char *start;		/* Start of number.  */
  char *suffix = NULL;
  char c;
  valueT number;	/* Offset or (absolute) value.  */
  short int digit;	/* Value of next digit in current radix.  */
  short int maxdig = 0;	/* Highest permitted digit value.  */
  int too_many_digits = 0;	/* If we see >= this number of.  */
  char *name;		/* Points to name of symbol.  */
  symbolS *symbolP;	/* Points to symbol.  */

  int small;			/* True if fits in 32 bits.  */

  /* May be bignum, or may fit in 32 bits.  */
  /* Most numbers fit into 32 bits, and we want this case to be fast.
     so we pretend it will fit into 32 bits.  If, after making up a 32
     bit number, we realise that we have scanned more digits than
     comfortably fit into 32 bits, we re-scan the digits coding them
     into a bignum.  For decimal and octal numbers we are
     conservative: Some numbers may be assumed bignums when in fact
     they do fit into 32 bits.  Numbers of any radix can have excess
     leading zeros: We strive to recognise this and cast them back
     into 32 bits.  We must check that the bignum really is more than
     32 bits, and change it back to a 32-bit number if it fits.  The
     number we are looking for is expected to be positive, but if it
     fits into 32 bits as an unsigned number, we let it be a 32-bit
     number.  The cavalier approach is for speed in ordinary cases.  */
  /* This has been extended for 64 bits.  We blindly assume that if
     you're compiling in 64-bit mode, the target is a 64-bit machine.
     This should be cleaned up.  */

#ifdef BFD64
#define valuesize 64
#else /* includes non-bfd case, mostly */
#define valuesize 32
#endif

  if ((NUMBERS_WITH_SUFFIX || flag_m68k_mri) && radix == 0)
    {
      int flt = 0;

      /* In MRI mode, the number may have a suffix indicating the
	 radix.  For that matter, it might actually be a floating
	 point constant.  */
      for (suffix = input_line_pointer; ISALNUM (*suffix); suffix++)
	{
	  if (*suffix == 'e' || *suffix == 'E')
	    flt = 1;
	}

      if (suffix == input_line_pointer)
	{
	  radix = 10;
	  suffix = NULL;
	}
      else
	{
	  c = *--suffix;
	  c = TOUPPER (c);
	  /* If we have both NUMBERS_WITH_SUFFIX and LOCAL_LABELS_FB,
	     we distinguish between 'B' and 'b'.  This is the case for
	     Z80.  */
	  if ((NUMBERS_WITH_SUFFIX && LOCAL_LABELS_FB ? *suffix : c) == 'B')
	    radix = 2;
	  else if (c == 'D')
	    radix = 10;
	  else if (c == 'O' || c == 'Q')
	    radix = 8;
	  else if (c == 'H')
	    radix = 16;
	  else if (suffix[1] == '.' || c == 'E' || flt)
	    {
	      floating_constant (expressionP);
	      return;
	    }
	  else
	    {
	      radix = 10;
	      suffix = NULL;
	    }
	}
    }

  switch (radix)
    {
    case 2:
      maxdig = 2;
      too_many_digits = valuesize + 1;
      break;
    case 8:
      maxdig = radix = 8;
      too_many_digits = (valuesize + 2) / 3 + 1;
      break;
    case 16:
      maxdig = radix = 16;
      too_many_digits = (valuesize + 3) / 4 + 1;
      break;
    case 10:
      maxdig = radix = 10;
      too_many_digits = (valuesize + 11) / 4; /* Very rough.  */
    }
#undef valuesize
  start = input_line_pointer;
  c = *input_line_pointer++;
  for (number = 0;
       (digit = hex_value (c)) < maxdig;
       c = *input_line_pointer++)
    {
      number = number * radix + digit;
    }
  /* c contains character after number.  */
  /* input_line_pointer->char after c.  */
  small = (input_line_pointer - start - 1) < too_many_digits;

  if (radix == 16 && c == '_')
    {
      /* This is literal of the form 0x333_0_12345678_1.
	 This example is equivalent to 0x00000333000000001234567800000001.  */

      int num_little_digits = 0;
      int i;
      input_line_pointer = start;	/* -> 1st digit.  */

      know (LITTLENUM_NUMBER_OF_BITS == 16);

      for (c = '_'; c == '_'; num_little_digits += 2)
	{

	  /* Convert one 64-bit word.  */
	  int ndigit = 0;
	  number = 0;
	  for (c = *input_line_pointer++;
	       (digit = hex_value (c)) < maxdig;
	       c = *(input_line_pointer++))
	    {
	      number = number * radix + digit;
	      ndigit++;
	    }

	  /* Check for 8 digit per word max.  */
	  if (ndigit > 8)
	    as_bad (_("a bignum with underscores may not have more than 8 hex digits in any word"));

	  /* Add this chunk to the bignum.
	     Shift things down 2 little digits.  */
	  know (LITTLENUM_NUMBER_OF_BITS == 16);
	  for (i = min (num_little_digits + 1, SIZE_OF_LARGE_NUMBER - 1);
	       i >= 2;
	       i--)
	    generic_bignum[i] = generic_bignum[i - 2];

	  /* Add the new digits as the least significant new ones.  */
	  generic_bignum[0] = number & 0xffffffff;
	  generic_bignum[1] = number >> 16;
	}

      /* Again, c is char after number, input_line_pointer->after c.  */

      if (num_little_digits > SIZE_OF_LARGE_NUMBER - 1)
	num_little_digits = SIZE_OF_LARGE_NUMBER - 1;

      gas_assert (num_little_digits >= 4);

      if (num_little_digits != 8)
	as_bad (_("a bignum with underscores must have exactly 4 words"));

      /* We might have some leading zeros.  These can be trimmed to give
	 us a change to fit this constant into a small number.  */
      while (generic_bignum[num_little_digits - 1] == 0
	     && num_little_digits > 1)
	num_little_digits--;

      if (num_little_digits <= 2)
	{
	  /* will fit into 32 bits.  */
	  number = generic_bignum_to_int32 ();
	  small = 1;
	}
#ifdef BFD64
      else if (num_little_digits <= 4)
	{
	  /* Will fit into 64 bits.  */
	  number = generic_bignum_to_int64 ();
	  small = 1;
	}
#endif
      else
	{
	  small = 0;

	  /* Number of littlenums in the bignum.  */
	  number = num_little_digits;
	}
    }
  else if (!small)
    {
      /* We saw a lot of digits. manufacture a bignum the hard way.  */
      LITTLENUM_TYPE *leader;	/* -> high order littlenum of the bignum.  */
      LITTLENUM_TYPE *pointer;	/* -> littlenum we are frobbing now.  */
      long carry;

      leader = generic_bignum;
      generic_bignum[0] = 0;
      generic_bignum[1] = 0;
      generic_bignum[2] = 0;
      generic_bignum[3] = 0;
      input_line_pointer = start;	/* -> 1st digit.  */
      c = *input_line_pointer++;
      for (; (carry = hex_value (c)) < maxdig; c = *input_line_pointer++)
	{
	  for (pointer = generic_bignum; pointer <= leader; pointer++)
	    {
	      long work;

	      work = carry + radix * *pointer;
	      *pointer = work & LITTLENUM_MASK;
	      carry = work >> LITTLENUM_NUMBER_OF_BITS;
	    }
	  if (carry)
	    {
	      if (leader < generic_bignum + SIZE_OF_LARGE_NUMBER - 1)
		{
		  /* Room to grow a longer bignum.  */
		  *++leader = carry;
		}
	    }
	}
      /* Again, c is char after number.  */
      /* input_line_pointer -> after c.  */
      know (LITTLENUM_NUMBER_OF_BITS == 16);
      if (leader < generic_bignum + 2)
	{
	  /* Will fit into 32 bits.  */
	  number = generic_bignum_to_int32 ();
	  small = 1;
	}
#ifdef BFD64
      else if (leader < generic_bignum + 4)
	{
	  /* Will fit into 64 bits.  */
	  number = generic_bignum_to_int64 ();
	  small = 1;
	}
#endif
      else
	{
	  /* Number of littlenums in the bignum.  */
	  number = leader - generic_bignum + 1;
	}
    }

  if ((NUMBERS_WITH_SUFFIX || flag_m68k_mri)
      && suffix != NULL
      && input_line_pointer - 1 == suffix)
    c = *input_line_pointer++;

  if (small)
    {
      /* Here with number, in correct radix. c is the next char.
	 Note that unlike un*x, we allow "011f" "0x9f" to both mean
	 the same as the (conventional) "9f".
	 This is simply easier than checking for strict canonical
	 form.  Syntax sux!  */

      if (LOCAL_LABELS_FB && c == 'b')
	{
	  /* Backward ref to local label.
	     Because it is backward, expect it to be defined.  */
	  /* Construct a local label.  */
	  name = fb_label_name ((int) number, 0);

	  /* Seen before, or symbol is defined: OK.  */
	  symbolP = symbol_find (name);
	  if ((symbolP != NULL) && (S_IS_DEFINED (symbolP)))
	    {
	      /* Local labels are never absolute.  Don't waste time
		 checking absoluteness.  */
	      know (SEG_NORMAL (S_GET_SEGMENT (symbolP)));

	      expressionP->X_op = O_symbol;
	      expressionP->X_add_symbol = symbolP;
	    }
	  else
	    {
	      /* Either not seen or not defined.  */
	      /* @@@@ Should print out the original string instead of
		 the parsed number.  */
	      as_bad (_("backward ref to unknown label \"%d:\""),
		      (int) number);
	      expressionP->X_op = O_constant;
	    }

	  expressionP->X_add_number = 0;
	}			/* case 'b' */
      else if (LOCAL_LABELS_FB && c == 'f')
	{
	  /* Forward reference.  Expect symbol to be undefined or
	     unknown.  undefined: seen it before.  unknown: never seen
	     it before.

	     Construct a local label name, then an undefined symbol.
	     Don't create a xseg frag for it: caller may do that.
	     Just return it as never seen before.  */
	  name = fb_label_name ((int) number, 1);
	  symbolP = symbol_find_or_make (name);
	  /* We have no need to check symbol properties.  */
#ifndef many_segments
	  /* Since "know" puts its arg into a "string", we
	     can't have newlines in the argument.  */
	  know (S_GET_SEGMENT (symbolP) == undefined_section || S_GET_SEGMENT (symbolP) == text_section || S_GET_SEGMENT (symbolP) == data_section);
#endif
	  expressionP->X_op = O_symbol;
	  expressionP->X_add_symbol = symbolP;
	  expressionP->X_add_number = 0;
	}			/* case 'f' */
      else if (LOCAL_LABELS_DOLLAR && c == '$')
	{
	  /* If the dollar label is *currently* defined, then this is just
	     another reference to it.  If it is not *currently* defined,
	     then this is a fresh instantiation of that number, so create
	     it.  */

	  if (dollar_label_defined ((long) number))
	    {
	      name = dollar_label_name ((long) number, 0);
	      symbolP = symbol_find (name);
	      know (symbolP != NULL);
	    }
	  else
	    {
	      name = dollar_label_name ((long) number, 1);
	      symbolP = symbol_find_or_make (name);
	    }

	  expressionP->X_op = O_symbol;
	  expressionP->X_add_symbol = symbolP;
	  expressionP->X_add_number = 0;
	}			/* case '$' */
      else
	{
	  expressionP->X_op = O_constant;
	  expressionP->X_add_number = number;
	  input_line_pointer--;	/* Restore following character.  */
	}			/* Really just a number.  */
    }
  else
    {
      /* Not a small number.  */
      expressionP->X_op = O_big;
      expressionP->X_add_number = number;	/* Number of littlenums.  */
      input_line_pointer--;	/* -> char following number.  */
    }
}

/* Parse an MRI multi character constant.  */

static void
mri_char_constant (expressionS *expressionP)
{
  int i;

  if (*input_line_pointer == '\''
      && input_line_pointer[1] != '\'')
    {
      expressionP->X_op = O_constant;
      expressionP->X_add_number = 0;
      return;
    }

  /* In order to get the correct byte ordering, we must build the
     number in reverse.  */
  for (i = SIZE_OF_LARGE_NUMBER - 1; i >= 0; i--)
    {
      int j;

      generic_bignum[i] = 0;
      for (j = 0; j < CHARS_PER_LITTLENUM; j++)
	{
	  if (*input_line_pointer == '\'')
	    {
	      if (input_line_pointer[1] != '\'')
		break;
	      ++input_line_pointer;
	    }
	  generic_bignum[i] <<= 8;
	  generic_bignum[i] += *input_line_pointer;
	  ++input_line_pointer;
	}

      if (i < SIZE_OF_LARGE_NUMBER - 1)
	{
	  /* If there is more than one littlenum, left justify the
	     last one to make it match the earlier ones.  If there is
	     only one, we can just use the value directly.  */
	  for (; j < CHARS_PER_LITTLENUM; j++)
	    generic_bignum[i] <<= 8;
	}

      if (*input_line_pointer == '\''
	  && input_line_pointer[1] != '\'')
	break;
    }

  if (i < 0)
    {
      as_bad (_("character constant too large"));
      i = 0;
    }

  if (i > 0)
    {
      int c;
      int j;

      c = SIZE_OF_LARGE_NUMBER - i;
      for (j = 0; j < c; j++)
	generic_bignum[j] = generic_bignum[i + j];
      i = c;
    }

  know (LITTLENUM_NUMBER_OF_BITS == 16);
  if (i > 2)
    {
      expressionP->X_op = O_big;
      expressionP->X_add_number = i;
    }
  else
    {
      expressionP->X_op = O_constant;
      if (i < 2)
	expressionP->X_add_number = generic_bignum[0] & LITTLENUM_MASK;
      else
	expressionP->X_add_number =
	  (((generic_bignum[1] & LITTLENUM_MASK)
	    << LITTLENUM_NUMBER_OF_BITS)
	   | (generic_bignum[0] & LITTLENUM_MASK));
    }

  /* Skip the final closing quote.  */
  ++input_line_pointer;
}

/* Return an expression representing the current location.  This
   handles the magic symbol `.'.  */

void
current_location (expressionS *expressionp)
{
  if (now_seg == absolute_section)
    {
      expressionp->X_op = O_constant;
      expressionp->X_add_number = abs_section_offset;
    }
  else
    {
      expressionp->X_op = O_symbol;
      expressionp->X_add_symbol = &dot_symbol;
      expressionp->X_add_number = 0;
    }
}

/* In:	Input_line_pointer points to 1st char of operand, which may
	be a space.

   Out:	An expressionS.
	The operand may have been empty: in this case X_op == O_absent.
	Input_line_pointer->(next non-blank) char after operand.  */

static segT
operand (expressionS *expressionP, enum expr_mode mode)
{
  char c;
  symbolS *symbolP;	/* Points to symbol.  */
  char *name;		/* Points to name of symbol.  */
  segT segment;

  /* All integers are regarded as unsigned unless they are negated.
     This is because the only thing which cares whether a number is
     unsigned is the code in emit_expr which extends constants into
     bignums.  It should only sign extend negative numbers, so that
     something like ``.quad 0x80000000'' is not sign extended even
     though it appears negative if valueT is 32 bits.  */
  expressionP->X_unsigned = 1;
  expressionP->X_extrabit = 0;

  /* Digits, assume it is a bignum.  */

  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand.  */
  c = *input_line_pointer++;	/* input_line_pointer -> past char in c.  */

  if (is_end_of_line[(unsigned char) c])
    goto eol;

  switch (c)
    {
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      input_line_pointer--;

      integer_constant ((NUMBERS_WITH_SUFFIX || flag_m68k_mri)
			? 0 : 10,
			expressionP);
      break;

#ifdef LITERAL_PREFIXDOLLAR_HEX
    case '$':
      /* $L is the start of a local label, not a hex constant.  */
      if (* input_line_pointer == 'L')
      goto isname;
      integer_constant (16, expressionP);
      break;
#endif

#ifdef LITERAL_PREFIXPERCENT_BIN
    case '%':
      integer_constant (2, expressionP);
      break;
#endif

    case '0':
      /* Non-decimal radix.  */

      if (NUMBERS_WITH_SUFFIX || flag_m68k_mri)
	{
	  char *s;

	  /* Check for a hex or float constant.  */
	  for (s = input_line_pointer; hex_p (*s); s++)
	    ;
	  if (*s == 'h' || *s == 'H' || *input_line_pointer == '.')
	    {
	      --input_line_pointer;
	      integer_constant (0, expressionP);
	      break;
	    }
	}
      c = *input_line_pointer;
      switch (c)
	{
	case 'o':
	case 'O':
	case 'q':
	case 'Q':
	case '8':
	case '9':
	  if (NUMBERS_WITH_SUFFIX || flag_m68k_mri)
	    {
	      integer_constant (0, expressionP);
	      break;
	    }
	  /* Fall through.  */
	default:
	default_case:
	  if (c && strchr (FLT_CHARS, c))
	    {
	      input_line_pointer++;
	      floating_constant (expressionP);
	      expressionP->X_add_number = - TOLOWER (c);
	    }
	  else
	    {
	      /* The string was only zero.  */
	      expressionP->X_op = O_constant;
	      expressionP->X_add_number = 0;
	    }

	  break;

	case 'x':
	case 'X':
	  if (flag_m68k_mri)
	    goto default_case;
	  input_line_pointer++;
	  integer_constant (16, expressionP);
	  break;

	case 'b':
	  if (LOCAL_LABELS_FB && ! (flag_m68k_mri || NUMBERS_WITH_SUFFIX))
	    {
	      /* This code used to check for '+' and '-' here, and, in
		 some conditions, fall through to call
		 integer_constant.  However, that didn't make sense,
		 as integer_constant only accepts digits.  */
	      /* Some of our code elsewhere does permit digits greater
		 than the expected base; for consistency, do the same
		 here.  */
	      if (input_line_pointer[1] < '0'
		  || input_line_pointer[1] > '9')
		{
		  /* Parse this as a back reference to label 0.  */
		  input_line_pointer--;
		  integer_constant (10, expressionP);
		  break;
		}
	      /* Otherwise, parse this as a binary number.  */
	    }
	  /* Fall through.  */
	case 'B':
	  input_line_pointer++;
	  if (flag_m68k_mri || NUMBERS_WITH_SUFFIX)
	    goto default_case;
	  integer_constant (2, expressionP);
	  break;

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	  integer_constant ((flag_m68k_mri || NUMBERS_WITH_SUFFIX)
			    ? 0 : 8,
			    expressionP);
	  break;

	case 'f':
	  if (LOCAL_LABELS_FB)
	    {
	      /* If it says "0f" and it could possibly be a floating point
		 number, make it one.  Otherwise, make it a local label,
		 and try to deal with parsing the rest later.  */
	      if (!input_line_pointer[1]
		  || (is_end_of_line[0xff & input_line_pointer[1]])
		  || strchr (FLT_CHARS, 'f') == NULL)
		goto is_0f_label;
	      {
		char *cp = input_line_pointer + 1;
		int r = atof_generic (&cp, ".", EXP_CHARS,
				      &generic_floating_point_number);
		switch (r)
		  {
		  case 0:
		  case ERROR_EXPONENT_OVERFLOW:
		    if (*cp == 'f' || *cp == 'b')
		      /* Looks like a difference expression.  */
		      goto is_0f_label;
		    else if (cp == input_line_pointer + 1)
		      /* No characters has been accepted -- looks like
			 end of operand.  */
		      goto is_0f_label;
		    else
		      goto is_0f_float;
		  default:
		    as_fatal (_("expr.c(operand): bad atof_generic return val %d"),
			      r);
		  }
	      }

	      /* Okay, now we've sorted it out.  We resume at one of these
		 two labels, depending on what we've decided we're probably
		 looking at.  */
	    is_0f_label:
	      input_line_pointer--;
	      integer_constant (10, expressionP);
	      break;

	    is_0f_float:
	      /* Fall through.  */
	      ;
	    }

	case 'd':
	case 'D':
	  if (flag_m68k_mri || NUMBERS_WITH_SUFFIX)
	    {
	      integer_constant (0, expressionP);
	      break;
	    }
	  /* Fall through.  */
	case 'F':
	case 'r':
	case 'e':
	case 'E':
	case 'g':
	case 'G':
	  input_line_pointer++;
	  floating_constant (expressionP);
	  expressionP->X_add_number = - TOLOWER (c);
	  break;

	case '$':
	  if (LOCAL_LABELS_DOLLAR)
	    {
	      integer_constant (10, expressionP);
	      break;
	    }
	  else
	    goto default_case;
	}

      break;

#ifndef NEED_INDEX_OPERATOR
    case '[':
# ifdef md_need_index_operator
      if (md_need_index_operator())
	goto de_fault;
# endif
      /* FALLTHROUGH */
#endif
    case '(':
      /* Didn't begin with digit & not a name.  */
      segment = expr (0, expressionP, mode);
      /* expression () will pass trailing whitespace.  */
      if ((c == '(' && *input_line_pointer != ')')
	  || (c == '[' && *input_line_pointer != ']'))
	as_bad (_("missing '%c'"), c == '(' ? ')' : ']');
      else
	input_line_pointer++;
      SKIP_WHITESPACE ();
      /* Here with input_line_pointer -> char after "(...)".  */
      return segment;

#ifdef TC_M68K
    case 'E':
      if (! flag_m68k_mri || *input_line_pointer != '\'')
	goto de_fault;
      as_bad (_("EBCDIC constants are not supported"));
      /* Fall through.  */
    case 'A':
      if (! flag_m68k_mri || *input_line_pointer != '\'')
	goto de_fault;
      ++input_line_pointer;
      /* Fall through.  */
#endif
    case '\'':
      if (! flag_m68k_mri)
	{
	  /* Warning: to conform to other people's assemblers NO
	     ESCAPEMENT is permitted for a single quote.  The next
	     character, parity errors and all, is taken as the value
	     of the operand.  VERY KINKY.  */
	  expressionP->X_op = O_constant;
	  expressionP->X_add_number = *input_line_pointer++;
	  break;
	}

      mri_char_constant (expressionP);
      break;

#ifdef TC_M68K
    case '"':
      /* Double quote is the bitwise not operator in MRI mode.  */
      if (! flag_m68k_mri)
	goto de_fault;
      /* Fall through.  */
#endif
    case '~':
      /* '~' is permitted to start a label on the Delta.  */
      if (is_name_beginner (c))
	goto isname;
    case '!':
    case '-':
    case '+':
      {
#ifdef md_operator
      unary:
#endif
	operand (expressionP, mode);
	if (expressionP->X_op == O_constant)
	  {
	    /* input_line_pointer -> char after operand.  */
	    if (c == '-')
	      {
		expressionP->X_add_number = - expressionP->X_add_number;
		/* Notice: '-' may overflow: no warning is given.
		   This is compatible with other people's
		   assemblers.  Sigh.  */
		expressionP->X_unsigned = 0;
		if (expressionP->X_add_number)
		  expressionP->X_extrabit ^= 1;
	      }
	    else if (c == '~' || c == '"')
	      expressionP->X_add_number = ~ expressionP->X_add_number;
	    else if (c == '!')
	      expressionP->X_add_number = ! expressionP->X_add_number;
	  }
	else if (expressionP->X_op == O_big
		 && expressionP->X_add_number <= 0
		 && c == '-'
		 && (generic_floating_point_number.sign == '+'
		     || generic_floating_point_number.sign == 'P'))
	  {
	    /* Negative flonum (eg, -1.000e0).  */
	    if (generic_floating_point_number.sign == '+')
	      generic_floating_point_number.sign = '-';
	    else
	      generic_floating_point_number.sign = 'N';
	  }
	else if (expressionP->X_op == O_big
		 && expressionP->X_add_number > 0)
	  {
	    int i;

	    if (c == '~' || c == '-')
	      {
		for (i = 0; i < expressionP->X_add_number; ++i)
		  generic_bignum[i] = ~generic_bignum[i];

		/* Extend the bignum to at least the size of .octa.  */
		if (expressionP->X_add_number < SIZE_OF_LARGE_NUMBER)
		  {
		    expressionP->X_add_number = SIZE_OF_LARGE_NUMBER;
		    for (; i < expressionP->X_add_number; ++i)
		      generic_bignum[i] = ~(LITTLENUM_TYPE) 0;
		  }

		if (c == '-')
		  for (i = 0; i < expressionP->X_add_number; ++i)
		    {
		      generic_bignum[i] += 1;
		      if (generic_bignum[i])
			break;
		    }
	      }
	    else if (c == '!')
	      {
		for (i = 0; i < expressionP->X_add_number; ++i)
		  if (generic_bignum[i] != 0)
		    break;
		expressionP->X_add_number = i >= expressionP->X_add_number;
		expressionP->X_op = O_constant;
		expressionP->X_unsigned = 1;
		expressionP->X_extrabit = 0;
	      }
	  }
	else if (expressionP->X_op != O_illegal
		 && expressionP->X_op != O_absent)
	  {
	    if (c != '+')
	      {
		expressionP->X_add_symbol = make_expr_symbol (expressionP);
		if (c == '-')
		  expressionP->X_op = O_uminus;
		else if (c == '~' || c == '"')
		  expressionP->X_op = O_bit_not;
		else
		  expressionP->X_op = O_logical_not;
		expressionP->X_add_number = 0;
	      }
	  }
	else
	  as_warn (_("Unary operator %c ignored because bad operand follows"),
		   c);
      }
      break;

#if defined (DOLLAR_DOT) || defined (TC_M68K)
    case '$':
      /* '$' is the program counter when in MRI mode, or when
	 DOLLAR_DOT is defined.  */
#ifndef DOLLAR_DOT
      if (! flag_m68k_mri)
	goto de_fault;
#endif
      if (DOLLAR_AMBIGU && hex_p (*input_line_pointer))
	{
	  /* In MRI mode and on Z80, '$' is also used as the prefix
	     for a hexadecimal constant.  */
	  integer_constant (16, expressionP);
	  break;
	}

      if (is_part_of_name (*input_line_pointer))
	goto isname;

      current_location (expressionP);
      break;
#endif

    case '.':
      if (!is_part_of_name (*input_line_pointer))
	{
	  current_location (expressionP);
	  break;
	}
      else if ((strncasecmp (input_line_pointer, "startof.", 8) == 0
		&& ! is_part_of_name (input_line_pointer[8]))
	       || (strncasecmp (input_line_pointer, "sizeof.", 7) == 0
		   && ! is_part_of_name (input_line_pointer[7])))
	{
	  int start;

	  start = (input_line_pointer[1] == 't'
		   || input_line_pointer[1] == 'T');
	  input_line_pointer += start ? 8 : 7;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer != '(')
	    as_bad (_("syntax error in .startof. or .sizeof."));
	  else
	    {
	      char *buf;

	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      name = input_line_pointer;
	      c = get_symbol_end ();

	      buf = (char *) xmalloc (strlen (name) + 10);
	      if (start)
		sprintf (buf, ".startof.%s", name);
	      else
		sprintf (buf, ".sizeof.%s", name);
	      symbolP = symbol_make (buf);
	      free (buf);

	      expressionP->X_op = O_symbol;
	      expressionP->X_add_symbol = symbolP;
	      expressionP->X_add_number = 0;

	      *input_line_pointer = c;
	      SKIP_WHITESPACE ();
	      if (*input_line_pointer != ')')
		as_bad (_("syntax error in .startof. or .sizeof."));
	      else
		++input_line_pointer;
	    }
	  break;
	}
      else
	{
	  goto isname;
	}

    case ',':
    eol:
      /* Can't imagine any other kind of operand.  */
      expressionP->X_op = O_absent;
      input_line_pointer--;
      break;

#ifdef TC_M68K
    case '%':
      if (! flag_m68k_mri)
	goto de_fault;
      integer_constant (2, expressionP);
      break;

    case '@@':
      if (! flag_m68k_mri)
	goto de_fault;
      integer_constant (8, expressionP);
      break;

    case ':':
      if (! flag_m68k_mri)
	goto de_fault;

      /* In MRI mode, this is a floating point constant represented
	 using hexadecimal digits.  */

      ++input_line_pointer;
      integer_constant (16, expressionP);
      break;

    case '*':
      if (! flag_m68k_mri || is_part_of_name (*input_line_pointer))
	goto de_fault;

      current_location (expressionP);
      break;
#endif

    default:
#if defined(md_need_index_operator) || defined(TC_M68K)
    de_fault:
#endif
      if (is_name_beginner (c))	/* Here if did not begin with a digit.  */
	{
	  /* Identifier begins here.
	     This is kludged for speed, so code is repeated.  */
	isname:
	  name = --input_line_pointer;
	  c = get_symbol_end ();

#ifdef md_operator
	  {
	    operatorT op = md_operator (name, 1, &c);

	    switch (op)
	      {
	      case O_uminus:
		*input_line_pointer = c;
		c = '-';
		goto unary;
	      case O_bit_not:
		*input_line_pointer = c;
		c = '~';
		goto unary;
	      case O_logical_not:
		*input_line_pointer = c;
		c = '!';
		goto unary;
	      case O_illegal:
		as_bad (_("invalid use of operator \"%s\""), name);
		break;
	      default:
		break;
	      }
	    if (op != O_absent && op != O_illegal)
	      {
		*input_line_pointer = c;
		expr (9, expressionP, mode);
		expressionP->X_add_symbol = make_expr_symbol (expressionP);
		expressionP->X_op_symbol = NULL;
		expressionP->X_add_number = 0;
		expressionP->X_op = op;
		break;
	      }
	  }
#endif

#ifdef md_parse_name
	  /* This is a hook for the backend to parse certain names
	     specially in certain contexts.  If a name always has a
	     specific value, it can often be handled by simply
	     entering it in the symbol table.  */
	  if (md_parse_name (name, expressionP, mode, &c))
	    {
	      *input_line_pointer = c;
	      break;
	    }
#endif

#ifdef TC_I960
	  /* The MRI i960 assembler permits
	         lda sizeof code,g13
	     FIXME: This should use md_parse_name.  */
	  if (flag_mri
	      && (strcasecmp (name, "sizeof") == 0
		  || strcasecmp (name, "startof") == 0))
	    {
	      int start;
	      char *buf;

	      start = (name[1] == 't'
		       || name[1] == 'T');

	      *input_line_pointer = c;
	      SKIP_WHITESPACE ();

	      name = input_line_pointer;
	      c = get_symbol_end ();

	      buf = (char *) xmalloc (strlen (name) + 10);
	      if (start)
		sprintf (buf, ".startof.%s", name);
	      else
		sprintf (buf, ".sizeof.%s", name);
	      symbolP = symbol_make (buf);
	      free (buf);

	      expressionP->X_op = O_symbol;
	      expressionP->X_add_symbol = symbolP;
	      expressionP->X_add_number = 0;

	      *input_line_pointer = c;
	      SKIP_WHITESPACE ();

	      break;
	    }
#endif

	  symbolP = symbol_find_or_make (name);

	  /* If we have an absolute symbol or a reg, then we know its
	     value now.  */
	  segment = S_GET_SEGMENT (symbolP);
	  if (mode != expr_defer
	      && segment == absolute_section
	      && !S_FORCE_RELOC (symbolP, 0))
	    {
	      expressionP->X_op = O_constant;
	      expressionP->X_add_number = S_GET_VALUE (symbolP);
	    }
	  else if (mode != expr_defer && segment == reg_section)
	    {
	      expressionP->X_op = O_register;
	      expressionP->X_add_number = S_GET_VALUE (symbolP);
	    }
	  else
	    {
	      expressionP->X_op = O_symbol;
	      expressionP->X_add_symbol = symbolP;
	      expressionP->X_add_number = 0;
	    }
	  *input_line_pointer = c;
	}
      else
	{
	  /* Let the target try to parse it.  Success is indicated by changing
	     the X_op field to something other than O_absent and pointing
	     input_line_pointer past the expression.  If it can't parse the
	     expression, X_op and input_line_pointer should be unchanged.  */
	  expressionP->X_op = O_absent;
	  --input_line_pointer;
	  md_operand (expressionP);
	  if (expressionP->X_op == O_absent)
	    {
	      ++input_line_pointer;
	      as_bad (_("bad expression"));
	      expressionP->X_op = O_constant;
	      expressionP->X_add_number = 0;
	    }
	}
      break;
    }

  /* It is more 'efficient' to clean up the expressionS when they are
     created.  Doing it here saves lines of code.  */
  clean_up_expression (expressionP);
  SKIP_WHITESPACE ();		/* -> 1st char after operand.  */
  know (*input_line_pointer != ' ');

  /* The PA port needs this information.  */
  if (expressionP->X_add_symbol)
    symbol_mark_used (expressionP->X_add_symbol);

  if (mode != expr_defer)
    {
      expressionP->X_add_symbol
	= symbol_clone_if_forward_ref (expressionP->X_add_symbol);
      expressionP->X_op_symbol
	= symbol_clone_if_forward_ref (expressionP->X_op_symbol);
    }

  switch (expressionP->X_op)
    {
    default:
      return absolute_section;
    case O_symbol:
      return S_GET_SEGMENT (expressionP->X_add_symbol);
    case O_register:
      return reg_section;
    }
}

/* Internal.  Simplify a struct expression for use by expr ().  */

/* In:	address of an expressionS.
	The X_op field of the expressionS may only take certain values.
	Elsewise we waste time special-case testing. Sigh. Ditto SEG_ABSENT.

   Out:	expressionS may have been modified:
	Unused fields zeroed to help expr ().  */

static void
clean_up_expression (expressionS *expressionP)
{
  switch (expressionP->X_op)
    {
    case O_illegal:
    case O_absent:
      expressionP->X_add_number = 0;
      /* Fall through.  */
    case O_big:
    case O_constant:
    case O_register:
      expressionP->X_add_symbol = NULL;
      /* Fall through.  */
    case O_symbol:
    case O_uminus:
    case O_bit_not:
      expressionP->X_op_symbol = NULL;
      break;
    default:
      break;
    }
}

/* Expression parser.  */

/* We allow an empty expression, and just assume (absolute,0) silently.
   Unary operators and parenthetical expressions are treated as operands.
   As usual, Q==quantity==operand, O==operator, X==expression mnemonics.

   We used to do an aho/ullman shift-reduce parser, but the logic got so
   warped that I flushed it and wrote a recursive-descent parser instead.
   Now things are stable, would anybody like to write a fast parser?
   Most expressions are either register (which does not even reach here)
   or 1 symbol. Then "symbol+constant" and "symbol-symbol" are common.
   So I guess it doesn't really matter how inefficient more complex expressions
   are parsed.

   After expr(RANK,resultP) input_line_pointer->operator of rank <= RANK.
   Also, we have consumed any leading or trailing spaces (operand does that)
   and done all intervening operators.

   This returns the segment of the result, which will be
   absolute_section or the segment of a symbol.  */

#undef __
#define __ O_illegal
#ifndef O_SINGLE_EQ
#define O_SINGLE_EQ O_illegal
#endif

/* Maps ASCII -> operators.  */
static const operatorT op_encoding[256] = {
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,

  __, O_bit_or_not, __, __, __, O_modulus, O_bit_and, __,
  __, __, O_multiply, O_add, __, O_subtract, __, O_divide,
  __, __, __, __, __, __, __, __,
  __, __, __, __, O_lt, O_SINGLE_EQ, O_gt, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __,
  __, __, __,
#ifdef NEED_INDEX_OPERATOR
  O_index,
#else
  __,
#endif
  __, __, O_bit_exclusive_or, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, O_bit_inclusive_or, __, __, __,

  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __
};

/* Rank	Examples
   0	operand, (expression)
   1	||
   2	&&
   3	== <> < <= >= >
   4	+ -
   5	used for * / % in MRI mode
   6	& ^ ! |
   7	* / % << >>
   8	unary - unary ~
*/
static operator_rankT op_rank[O_max] = {
  0,	/* O_illegal */
  0,	/* O_absent */
  0,	/* O_constant */
  0,	/* O_symbol */
  0,	/* O_symbol_rva */
  0,	/* O_register */
  0,	/* O_big */
  9,	/* O_uminus */
  9,	/* O_bit_not */
  9,	/* O_logical_not */
  8,	/* O_multiply */
  8,	/* O_divide */
  8,	/* O_modulus */
  8,	/* O_left_shift */
  8,	/* O_right_shift */
  7,	/* O_bit_inclusive_or */
  7,	/* O_bit_or_not */
  7,	/* O_bit_exclusive_or */
  7,	/* O_bit_and */
  5,	/* O_add */
  5,	/* O_subtract */
  4,	/* O_eq */
  4,	/* O_ne */
  4,	/* O_lt */
  4,	/* O_le */
  4,	/* O_ge */
  4,	/* O_gt */
  3,	/* O_logical_and */
  2,	/* O_logical_or */
  1,	/* O_index */
};

/* Unfortunately, in MRI mode for the m68k, multiplication and
   division have lower precedence than the bit wise operators.  This
   function sets the operator precedences correctly for the current
   mode.  Also, MRI uses a different bit_not operator, and this fixes
   that as well.  */

#define STANDARD_MUL_PRECEDENCE 8
#define MRI_MUL_PRECEDENCE 6

void
expr_set_precedence (void)
{
  if (flag_m68k_mri)
    {
      op_rank[O_multiply] = MRI_MUL_PRECEDENCE;
      op_rank[O_divide] = MRI_MUL_PRECEDENCE;
      op_rank[O_modulus] = MRI_MUL_PRECEDENCE;
    }
  else
    {
      op_rank[O_multiply] = STANDARD_MUL_PRECEDENCE;
      op_rank[O_divide] = STANDARD_MUL_PRECEDENCE;
      op_rank[O_modulus] = STANDARD_MUL_PRECEDENCE;
    }
}

void
expr_set_rank (operatorT op, operator_rankT rank)
{
  gas_assert (op >= O_md1 && op < ARRAY_SIZE (op_rank));
  op_rank[op] = rank;
}

/* Initialize the expression parser.  */

void
expr_begin (void)
{
  expr_set_precedence ();

  /* Verify that X_op field is wide enough.  */
  {
    expressionS e;
    e.X_op = O_max;
    gas_assert (e.X_op == O_max);
  }
}

/* Return the encoding for the operator at INPUT_LINE_POINTER, and
   sets NUM_CHARS to the number of characters in the operator.
   Does not advance INPUT_LINE_POINTER.  */

static inline operatorT
operatorf (int *num_chars)
{
  int c;
  operatorT ret;

  c = *input_line_pointer & 0xff;
  *num_chars = 1;

  if (is_end_of_line[c])
    return O_illegal;

#ifdef md_operator
  if (is_name_beginner (c))
    {
      char *name = input_line_pointer;
      char ec = get_symbol_end ();

      ret = md_operator (name, 2, &ec);
      switch (ret)
	{
	case O_absent:
	  *input_line_pointer = ec;
	  input_line_pointer = name;
	  break;
	case O_uminus:
	case O_bit_not:
	case O_logical_not:
	  as_bad (_("invalid use of operator \"%s\""), name);
	  ret = O_illegal;
	  /* FALLTHROUGH */
	default:
	  *input_line_pointer = ec;
	  *num_chars = input_line_pointer - name;
	  input_line_pointer = name;
	  return ret;
	}
    }
#endif

  switch (c)
    {
    default:
      ret = op_encoding[c];
#ifdef md_operator
      if (ret == O_illegal)
	{
	  char *start = input_line_pointer;

	  ret = md_operator (NULL, 2, NULL);
	  if (ret != O_illegal)
	    *num_chars = input_line_pointer - start;
	  input_line_pointer = start;
	}
#endif
      return ret;

    case '+':
    case '-':
      return op_encoding[c];

    case '<':
      switch (input_line_pointer[1])
	{
	default:
	  return op_encoding[c];
	case '<':
	  ret = O_left_shift;
	  break;
	case '>':
	  ret = O_ne;
	  break;
	case '=':
	  ret = O_le;
	  break;
	}
      *num_chars = 2;
      return ret;

    case '=':
      if (input_line_pointer[1] != '=')
	return op_encoding[c];

      *num_chars = 2;
      return O_eq;

    case '>':
      switch (input_line_pointer[1])
	{
	default:
	  return op_encoding[c];
	case '>':
	  ret = O_right_shift;
	  break;
	case '=':
	  ret = O_ge;
	  break;
	}
      *num_chars = 2;
      return ret;

    case '!':
      switch (input_line_pointer[1])
	{
	case '!':
	  /* We accept !! as equivalent to ^ for MRI compatibility. */
	  *num_chars = 2;
	  return O_bit_exclusive_or;
	case '=':
	  /* We accept != as equivalent to <>.  */
	  *num_chars = 2;
	  return O_ne;
	default:
	  if (flag_m68k_mri)
	    return O_bit_inclusive_or;
	  return op_encoding[c];
	}

    case '|':
      if (input_line_pointer[1] != '|')
	return op_encoding[c];

      *num_chars = 2;
      return O_logical_or;

    case '&':
      if (input_line_pointer[1] != '&')
	return op_encoding[c];

      *num_chars = 2;
      return O_logical_and;
    }

  /* NOTREACHED  */
}

/* Implement "word-size + 1 bit" addition for
   {resultP->X_extrabit:resultP->X_add_number} + {rhs_highbit:amount}.  This
   is used so that the full range of unsigned word values and the full range of
   signed word values can be represented in an O_constant expression, which is
   useful e.g. for .sleb128 directives.  */

void
add_to_result (expressionS *resultP, offsetT amount, int rhs_highbit)
{
  valueT ures = resultP->X_add_number;
  valueT uamount = amount;

  resultP->X_add_number += amount;

  resultP->X_extrabit ^= rhs_highbit;

  if (ures + uamount < ures)
    resultP->X_extrabit ^= 1;
}

/* Similarly, for subtraction.  */

void
subtract_from_result (expressionS *resultP, offsetT amount, int rhs_highbit)
{
  valueT ures = resultP->X_add_number;
  valueT uamount = amount;

  resultP->X_add_number -= amount;

  resultP->X_extrabit ^= rhs_highbit;

  if (ures < uamount)
    resultP->X_extrabit ^= 1;
}

/* Parse an expression.  */

segT
expr (int rankarg,		/* Larger # is higher rank.  */
      expressionS *resultP,	/* Deliver result here.  */
      enum expr_mode mode	/* Controls behavior.  */)
{
  operator_rankT rank = (operator_rankT) rankarg;
  segT retval;
  expressionS right;
  operatorT op_left;
  operatorT op_right;
  int op_chars;

  know (rankarg >= 0);

  /* Save the value of dot for the fixup code.  */
  if (rank == 0)
    {
      dot_value = frag_now_fix ();
      dot_frag = frag_now;
    }

  retval = operand (resultP, mode);

  /* operand () gobbles spaces.  */
  know (*input_line_pointer != ' ');

  op_left = operatorf (&op_chars);
  while (op_left != O_illegal && op_rank[(int) op_left] > rank)
    {
      segT rightseg;
      offsetT frag_off;

      input_line_pointer += op_chars;	/* -> after operator.  */

      right.X_md = 0;
      rightseg = expr (op_rank[(int) op_left], &right, mode);
      if (right.X_op == O_absent)
	{
	  as_warn (_("missing operand; zero assumed"));
	  right.X_op = O_constant;
	  right.X_add_number = 0;
	  right.X_add_symbol = NULL;
	  right.X_op_symbol = NULL;
	}

      know (*input_line_pointer != ' ');

      if (op_left == O_index)
	{
	  if (*input_line_pointer != ']')
	    as_bad ("missing right bracket");
	  else
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	    }
	}

      op_right = operatorf (&op_chars);

      know (op_right == O_illegal || op_left == O_index
	    || op_rank[(int) op_right] <= op_rank[(int) op_left]);
      know ((int) op_left >= (int) O_multiply);
#ifndef md_operator
      know ((int) op_left <= (int) O_index);
#else
      know ((int) op_left < (int) O_max);
#endif

      /* input_line_pointer->after right-hand quantity.  */
      /* left-hand quantity in resultP.  */
      /* right-hand quantity in right.  */
      /* operator in op_left.  */

      if (resultP->X_op == O_big)
	{
	  if (resultP->X_add_number > 0)
	    as_warn (_("left operand is a bignum; integer 0 assumed"));
	  else
	    as_warn (_("left operand is a float; integer 0 assumed"));
	  resultP->X_op = O_constant;
	  resultP->X_add_number = 0;
	  resultP->X_add_symbol = NULL;
	  resultP->X_op_symbol = NULL;
	}
      if (right.X_op == O_big)
	{
	  if (right.X_add_number > 0)
	    as_warn (_("right operand is a bignum; integer 0 assumed"));
	  else
	    as_warn (_("right operand is a float; integer 0 assumed"));
	  right.X_op = O_constant;
	  right.X_add_number = 0;
	  right.X_add_symbol = NULL;
	  right.X_op_symbol = NULL;
	}

      /* Optimize common cases.  */
#ifdef md_optimize_expr
      if (md_optimize_expr (resultP, op_left, &right))
	{
	  /* Skip.  */
	  ;
	}
      else
#endif
#ifndef md_register_arithmetic
# define md_register_arithmetic 1
#endif
      if (op_left == O_add && right.X_op == O_constant
	  && (md_register_arithmetic || resultP->X_op != O_register))
	{
	  /* X + constant.  */
	  add_to_result (resultP, right.X_add_number, right.X_extrabit);
	}
      /* This case comes up in PIC code.  */
      else if (op_left == O_subtract
	       && right.X_op == O_symbol
	       && resultP->X_op == O_symbol
	       && retval == rightseg
#ifdef md_allow_local_subtract
	       && md_allow_local_subtract (resultP, & right, rightseg)
#endif
	       && ((SEG_NORMAL (rightseg)
		    && !S_FORCE_RELOC (resultP->X_add_symbol, 0)
		    && !S_FORCE_RELOC (right.X_add_symbol, 0))
		   || right.X_add_symbol == resultP->X_add_symbol)
	       && frag_offset_fixed_p (symbol_get_frag (resultP->X_add_symbol),
				       symbol_get_frag (right.X_add_symbol),
				       &frag_off))
	{
	  offsetT symval_diff = S_GET_VALUE (resultP->X_add_symbol)
				- S_GET_VALUE (right.X_add_symbol);
	  subtract_from_result (resultP, right.X_add_number, right.X_extrabit);
	  subtract_from_result (resultP, frag_off / OCTETS_PER_BYTE, 0);
	  add_to_result (resultP, symval_diff, symval_diff < 0);
	  resultP->X_op = O_constant;
	  resultP->X_add_symbol = 0;
	}
      else if (op_left == O_subtract && right.X_op == O_constant
	       && (md_register_arithmetic || resultP->X_op != O_register))
	{
	  /* X - constant.  */
	  subtract_from_result (resultP, right.X_add_number, right.X_extrabit);
	}
      else if (op_left == O_add && resultP->X_op == O_constant
	       && (md_register_arithmetic || right.X_op != O_register))
	{
	  /* Constant + X.  */
	  resultP->X_op = right.X_op;
	  resultP->X_add_symbol = right.X_add_symbol;
	  resultP->X_op_symbol = right.X_op_symbol;
	  add_to_result (resultP, right.X_add_number, right.X_extrabit);
	  retval = rightseg;
	}
      else if (resultP->X_op == O_constant && right.X_op == O_constant)
	{
	  /* Constant OP constant.  */
	  offsetT v = right.X_add_number;
	  if (v == 0 && (op_left == O_divide || op_left == O_modulus))
	    {
	      as_warn (_("division by zero"));
	      v = 1;
	    }
	  if ((valueT) v >= sizeof(valueT) * CHAR_BIT
	      && (op_left == O_left_shift || op_left == O_right_shift))
	    {
	      as_warn_value_out_of_range (_("shift count"), v, 0,
					  sizeof(valueT) * CHAR_BIT - 1,
					  NULL, 0);
	      resultP->X_add_number = v = 0;
	    }
	  switch (op_left)
	    {
	    default:			goto general;
	    case O_multiply:		resultP->X_add_number *= v; break;
	    case O_divide:		resultP->X_add_number /= v; break;
	    case O_modulus:		resultP->X_add_number %= v; break;
	    case O_left_shift:		resultP->X_add_number <<= v; break;
	    case O_right_shift:
	      /* We always use unsigned shifts, to avoid relying on
		 characteristics of the compiler used to compile gas.  */
	      resultP->X_add_number =
		(offsetT) ((valueT) resultP->X_add_number >> (valueT) v);
	      break;
	    case O_bit_inclusive_or:	resultP->X_add_number |= v; break;
	    case O_bit_or_not:		resultP->X_add_number |= ~v; break;
	    case O_bit_exclusive_or:	resultP->X_add_number ^= v; break;
	    case O_bit_and:		resultP->X_add_number &= v; break;
	      /* Constant + constant (O_add) is handled by the
		 previous if statement for constant + X, so is omitted
		 here.  */
	    case O_subtract:
	      subtract_from_result (resultP, v, 0);
	      break;
	    case O_eq:
	      resultP->X_add_number =
		resultP->X_add_number == v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_ne:
	      resultP->X_add_number =
		resultP->X_add_number != v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_lt:
	      resultP->X_add_number =
		resultP->X_add_number <  v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_le:
	      resultP->X_add_number =
		resultP->X_add_number <= v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_ge:
	      resultP->X_add_number =
		resultP->X_add_number >= v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_gt:
	      resultP->X_add_number =
		resultP->X_add_number >  v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_logical_and:
	      resultP->X_add_number = resultP->X_add_number && v;
	      break;
	    case O_logical_or:
	      resultP->X_add_number = resultP->X_add_number || v;
	      break;
	    }
	}
      else if (resultP->X_op == O_symbol
	       && right.X_op == O_symbol
	       && (op_left == O_add
		   || op_left == O_subtract
		   || (resultP->X_add_number == 0
		       && right.X_add_number == 0)))
	{
	  /* Symbol OP symbol.  */
	  resultP->X_op = op_left;
	  resultP->X_op_symbol = right.X_add_symbol;
	  if (op_left == O_add)
	    add_to_result (resultP, right.X_add_number, right.X_extrabit);
	  else if (op_left == O_subtract)
	    {
	      subtract_from_result (resultP, right.X_add_number,
				    right.X_extrabit);
	      if (retval == rightseg
		  && SEG_NORMAL (retval)
		  && !S_FORCE_RELOC (resultP->X_add_symbol, 0)
		  && !S_FORCE_RELOC (right.X_add_symbol, 0))
		{
		  retval = absolute_section;
		  rightseg = absolute_section;
		}
	    }
	}
      else
	{
        general:
	  /* The general case.  */
	  resultP->X_add_symbol = make_expr_symbol (resultP);
	  resultP->X_op_symbol = make_expr_symbol (&right);
	  resultP->X_op = op_left;
	  resultP->X_add_number = 0;
	  resultP->X_unsigned = 1;
	  resultP->X_extrabit = 0;
	}

      if (retval != rightseg)
	{
	  if (retval == undefined_section)
	    ;
	  else if (rightseg == undefined_section)
	    retval = rightseg;
	  else if (retval == expr_section)
	    ;
	  else if (rightseg == expr_section)
	    retval = rightseg;
	  else if (retval == reg_section)
	    ;
	  else if (rightseg == reg_section)
	    retval = rightseg;
	  else if (rightseg == absolute_section)
	    ;
	  else if (retval == absolute_section)
	    retval = rightseg;
#ifdef DIFF_EXPR_OK
	  else if (op_left == O_subtract)
	    ;
#endif
	  else
	    as_bad (_("operation combines symbols in different segments"));
	}

      op_left = op_right;
    }				/* While next operator is >= this rank.  */

  /* The PA port needs this information.  */
  if (resultP->X_add_symbol)
    symbol_mark_used (resultP->X_add_symbol);

  if (rank == 0 && mode == expr_evaluate)
    resolve_expression (resultP);

  return resultP->X_op == O_constant ? absolute_section : retval;
}

/* Resolve an expression without changing any symbols/sub-expressions
   used.  */

int
resolve_expression (expressionS *expressionP)
{
  /* Help out with CSE.  */
  valueT final_val = expressionP->X_add_number;
  symbolS *add_symbol = expressionP->X_add_symbol;
  symbolS *orig_add_symbol = add_symbol;
  symbolS *op_symbol = expressionP->X_op_symbol;
  operatorT op = expressionP->X_op;
  valueT left, right;
  segT seg_left, seg_right;
  fragS *frag_left, *frag_right;
  offsetT frag_off;

  switch (op)
    {
    default:
      return 0;

    case O_constant:
    case O_register:
      left = 0;
      break;

    case O_symbol:
    case O_symbol_rva:
      if (!snapshot_symbol (&add_symbol, &left, &seg_left, &frag_left))
	return 0;

      break;

    case O_uminus:
    case O_bit_not:
    case O_logical_not:
      if (!snapshot_symbol (&add_symbol, &left, &seg_left, &frag_left))
	return 0;

      if (seg_left != absolute_section)
	return 0;

      if (op == O_logical_not)
	left = !left;
      else if (op == O_uminus)
	left = -left;
      else
	left = ~left;
      op = O_constant;
      break;

    case O_multiply:
    case O_divide:
    case O_modulus:
    case O_left_shift:
    case O_right_shift:
    case O_bit_inclusive_or:
    case O_bit_or_not:
    case O_bit_exclusive_or:
    case O_bit_and:
    case O_add:
    case O_subtract:
    case O_eq:
    case O_ne:
    case O_lt:
    case O_le:
    case O_ge:
    case O_gt:
    case O_logical_and:
    case O_logical_or:
      if (!snapshot_symbol (&add_symbol, &left, &seg_left, &frag_left)
	  || !snapshot_symbol (&op_symbol, &right, &seg_right, &frag_right))
	return 0;

      /* Simplify addition or subtraction of a constant by folding the
	 constant into X_add_number.  */
      if (op == O_add)
	{
	  if (seg_right == absolute_section)
	    {
	      final_val += right;
	      op = O_symbol;
	      break;
	    }
	  else if (seg_left == absolute_section)
	    {
	      final_val += left;
	      left = right;
	      seg_left = seg_right;
	      add_symbol = op_symbol;
	      orig_add_symbol = expressionP->X_op_symbol;
	      op = O_symbol;
	      break;
	    }
	}
      else if (op == O_subtract)
	{
	  if (seg_right == absolute_section)
	    {
	      final_val -= right;
	      op = O_symbol;
	      break;
	    }
	}

      /* Equality and non-equality tests are permitted on anything.
	 Subtraction, and other comparison operators are permitted if
	 both operands are in the same section.
	 Shifts by constant zero are permitted on anything.
	 Multiplies, bit-ors, and bit-ands with constant zero are
	 permitted on anything.
	 Multiplies and divides by constant one are permitted on
	 anything.
	 Binary operations with both operands being the same register
	 or undefined symbol are permitted if the result doesn't depend
	 on the input value.
	 Otherwise, both operands must be absolute.  We already handled
	 the case of addition or subtraction of a constant above.  */
      frag_off = 0;
      if (!(seg_left == absolute_section
	       && seg_right == absolute_section)
	  && !(op == O_eq || op == O_ne)
	  && !((op == O_subtract
		|| op == O_lt || op == O_le || op == O_ge || op == O_gt)
	       && seg_left == seg_right
	       && (finalize_syms
		   || frag_offset_fixed_p (frag_left, frag_right, &frag_off))
	       && (seg_left != reg_section || left == right)
	       && (seg_left != undefined_section || add_symbol == op_symbol)))
	{
	  if ((seg_left == absolute_section && left == 0)
	      || (seg_right == absolute_section && right == 0))
	    {
	      if (op == O_bit_exclusive_or || op == O_bit_inclusive_or)
		{
		  if (!(seg_right == absolute_section && right == 0))
		    {
		      seg_left = seg_right;
		      left = right;
		      add_symbol = op_symbol;
		      orig_add_symbol = expressionP->X_op_symbol;
		    }
		  op = O_symbol;
		  break;
		}
	      else if (op == O_left_shift || op == O_right_shift)
		{
		  if (!(seg_left == absolute_section && left == 0))
		    {
		      op = O_symbol;
		      break;
		    }
		}
	      else if (op != O_multiply
		       && op != O_bit_or_not && op != O_bit_and)
	        return 0;
	    }
	  else if (op == O_multiply
		   && seg_left == absolute_section && left == 1)
	    {
	      seg_left = seg_right;
	      left = right;
	      add_symbol = op_symbol;
	      orig_add_symbol = expressionP->X_op_symbol;
	      op = O_symbol;
	      break;
	    }
	  else if ((op == O_multiply || op == O_divide)
		   && seg_right == absolute_section && right == 1)
	    {
	      op = O_symbol;
	      break;
	    }
	  else if (!(left == right
		     && ((seg_left == reg_section && seg_right == reg_section)
			 || (seg_left == undefined_section
			     && seg_right == undefined_section
			     && add_symbol == op_symbol))))
	    return 0;
	  else if (op == O_bit_and || op == O_bit_inclusive_or)
	    {
	      op = O_symbol;
	      break;
	    }
	  else if (op != O_bit_exclusive_or && op != O_bit_or_not)
	    return 0;
	}

      right += frag_off / OCTETS_PER_BYTE;
      switch (op)
	{
	case O_add:			left += right; break;
	case O_subtract:		left -= right; break;
	case O_multiply:		left *= right; break;
	case O_divide:
	  if (right == 0)
	    return 0;
	  left = (offsetT) left / (offsetT) right;
	  break;
	case O_modulus:
	  if (right == 0)
	    return 0;
	  left = (offsetT) left % (offsetT) right;
	  break;
	case O_left_shift:		left <<= right; break;
	case O_right_shift:		left >>= right; break;
	case O_bit_inclusive_or:	left |= right; break;
	case O_bit_or_not:		left |= ~right; break;
	case O_bit_exclusive_or:	left ^= right; break;
	case O_bit_and:			left &= right; break;
	case O_eq:
	case O_ne:
	  left = (left == right
		  && seg_left == seg_right
		  && (finalize_syms || frag_left == frag_right)
		  && (seg_left != undefined_section
		      || add_symbol == op_symbol)
		  ? ~ (valueT) 0 : 0);
	  if (op == O_ne)
	    left = ~left;
	  break;
	case O_lt:
	  left = (offsetT) left <  (offsetT) right ? ~ (valueT) 0 : 0;
	  break;
	case O_le:
	  left = (offsetT) left <= (offsetT) right ? ~ (valueT) 0 : 0;
	  break;
	case O_ge:
	  left = (offsetT) left >= (offsetT) right ? ~ (valueT) 0 : 0;
	  break;
	case O_gt:
	  left = (offsetT) left >  (offsetT) right ? ~ (valueT) 0 : 0;
	  break;
	case O_logical_and:	left = left && right; break;
	case O_logical_or:	left = left || right; break;
	default:		abort ();
	}

      op = O_constant;
      break;
    }

  if (op == O_symbol)
    {
      if (seg_left == absolute_section)
	op = O_constant;
      else if (seg_left == reg_section && final_val == 0)
	op = O_register;
      else if (!symbol_same_p (add_symbol, orig_add_symbol))
	final_val += left;
      expressionP->X_add_symbol = add_symbol;
    }
  expressionP->X_op = op;

  if (op == O_constant || op == O_register)
    final_val += left;
  expressionP->X_add_number = final_val;

  return 1;
}

/* This lives here because it belongs equally in expr.c & read.c.
   expr.c is just a branch office read.c anyway, and putting it
   here lessens the crowd at read.c.

   Assume input_line_pointer is at start of symbol name.
   Advance input_line_pointer past symbol name.
   Turn that character into a '\0', returning its former value.
   This allows a string compare (RMS wants symbol names to be strings)
   of the symbol name.
   There will always be a char following symbol name, because all good
   lines end in end-of-line.  */

char
get_symbol_end (void)
{
  char c;

  /* We accept \001 in a name in case this is being called with a
     constructed string.  */
  if (is_name_beginner (c = *input_line_pointer++) || c == '\001')
    {
      while (is_part_of_name (c = *input_line_pointer++)
	     || c == '\001')
	;
      if (is_name_ender (c))
	c = *input_line_pointer++;
    }
  *--input_line_pointer = 0;
  return (c);
}

unsigned int
get_single_number (void)
{
  expressionS exp;
  operand (&exp, expr_normal);
  return exp.X_add_number;
}
@


1.93
log
@    gas/
    * read.c (convert_to_bignum): Add sign parameter. Use it
    instead of X_unsigned to determine sign of resulting bignum.
    (emit_expr): Pass extra argument to convert_to_bignum.
    (emit_leb128_expr): Use X_extrabit instead of X_unsigned. Pass
    X_extrabit to convert_to_bignum.
    (parse_bitfield_cons): Set X_extrabit.
    * expr.c (make_expr_symbol, expr_build_uconstant, operand):
    Initialise X_extrabit field as appropriate.
    (add_to_result): New.
    (subtract_from_result): New.
    (expr): Use above.
    * expr.h (expressionS): Add X_extrabit field.

    gas/testsuite/
    * gas/all/sleb128-2.s: New test.
    * gas/all/sleb128-3.s: Likewise.
    * gas/all/sleb128-4.s: Likewise.
    * gas/all/sleb128-5.s: Likewise.
    * gas/all/sleb128-7.s: Likewise.
    * gas/all/sleb128-2.d: New.
    * gas/all/sleb128-3.d: New.
    * gas/all/sleb123-4.d: New.
    * gas/all/sleb123-5.d: New.
    * gas/all/sleb123-7.d: New.
    * gas/all/gas.exp (sleb128-2, sleb128-3, sleb128-4, sleb128-5)
    (sleb128-7): Run new tests.
@
text
@d1732 1
a1732 1
static void
d1748 1
a1748 1
static void
@


1.92
log
@2013-03-08  Chung-Lin Tang  <cltang@@codesourcery.com>

	* write.h (struct fix): Add fx_dot_frag field.
	(dot_frag): Declare.
	* write.c (dot_frag): New variable.
	(fix_new_internal): Set fx_dot_frag field with dot_frag.
	(fixup_segment): Base calculation of fx_offset with fx_dot_frag.
	* expr.c (expr): Save value of frag_now in dot_frag when setting
	dot_value.
	* read.c (emit_expr): Likewise. Delete comments.
@
text
@d93 1
d165 1
d737 1
d1032 2
d1086 1
d1726 36
d1877 1
a1877 1
	  resultP->X_add_number += right.X_add_number;
d1895 5
a1899 4
	  resultP->X_add_number -= right.X_add_number;
	  resultP->X_add_number -= frag_off / OCTETS_PER_BYTE;
	  resultP->X_add_number += (S_GET_VALUE (resultP->X_add_symbol)
				    - S_GET_VALUE (right.X_add_symbol));
d1907 1
a1907 1
	  resultP->X_add_number -= right.X_add_number;
d1916 1
a1916 1
	  resultP->X_add_number += right.X_add_number;
d1956 3
a1958 1
	    case O_subtract:		resultP->X_add_number -= v; break;
d2002 1
a2002 1
	    resultP->X_add_number += right.X_add_number;
d2005 2
a2006 1
	      resultP->X_add_number -= right.X_add_number;
d2026 1
@


1.91
log
@	* frags.h (frag_offset_fixed_p): Update prototype.
	* frags.c (frag_offset_fixed_p): Change type of "offset" to offsetT.
	* expr.c (expr, resolve_expression): Likewise for frag_off var.
@
text
@d1738 4
a1741 1
    dot_value = frag_now_fix ();
@


1.90
log
@	PR 12569
	* expr.c (operand): Correct passing of "mode" to expr.
	* read.c (do_org): Allow expr_section.
	(get_known_segmented_expression): Don't assert anything about the
	segment.
@
text
@d3 2
a4 2
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011
   Free Software Foundation, Inc.
d1749 1
a1749 1
      bfd_vma frag_off;
d2033 1
a2033 1
  bfd_vma frag_off;
@


1.89
log
@	PR gas/12282
	* expr.c (expr_build_dot): Make a clone of the symbol to return if
	needed.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
d962 1
a962 4
      if (mode != expr_defer)
	segment = expression (expressionP);
      else
	segment = deferred_expression (expressionP);
@


1.88
log
@gas/
	* symbols.c (S_FORCE_RELOC): Return true for indirect functions
	even if !strict.
	* expr.c (operand): Don't convert absolute symbols to constants
	if S_FORCE_RELOC is true.
	(expr): Only reduce subtractions between different symbols if
	S_FORCE_RELOC is false for both of them.
	* write.c (fixup_segment): Don't remove symbols if S_FORCE_RELOC
	is true for them, regardless of their segment.

gas/testsuite/
	* gas/i386/ifunc-2.s, gas/i386/ifunc-2.l: New test.
	* gas/i386/ifunc-3.s, gas/i386/ifunc-3.d: Likeise.
	* gas/i386/i386.exp: Run them.
@
text
@d175 1
a175 1
  return make_expr_symbol (&e);
@


1.87
log
@	* symbols.h (dot_symbol): New declaration.
	(dot_symbol_init): New prototype.
	* symbols.c (dot_symbol): New variable.
	(symbol_clone): Assert it's not dot_symbol being cloned.
	(dot_symbol_init): New function.
	(symbol_clone_if_forward_ref): Create a new temporary symbol
	when trying to clone dot_symbol.
	* expr.c (current_location): Refer to dot_symbol instead of
	making a new temporary symbol.
	* read.c (read_a_source_file): Update dot_symbol as we go.
	* as.c (main): Call dot_symbol_init.
@
text
@d1328 3
a1330 1
	  if (mode != expr_defer && segment == absolute_section)
d1845 3
a1847 1
	       && (SEG_NORMAL (rightseg)
d1961 4
a1964 1
	      if (retval == rightseg && SEG_NORMAL (retval))
@


1.86
log
@	* symbols.c (symbol_clone_if_forward_ref): Don't limit cloning
	to expr_section symbols; clone all equated symbols.  Clear
	sy_resolving of the cloned copy.
	* expr.c (operand): Only clone equated symbols on a final
	(i.e. non-equated) reference.
@
text
@d708 1
a708 1
      expressionp->X_add_symbol = symbol_temp_new_now ();
@


1.85
log
@	* expr.c (expr): Correct returned segment value.
@
text
@d1376 7
a1382 2
  expressionP->X_add_symbol = symbol_clone_if_forward_ref (expressionP->X_add_symbol);
  expressionP->X_op_symbol = symbol_clone_if_forward_ref (expressionP->X_op_symbol);
@


1.85.2.1
log
@backport from mainline
@
text
@d175 1
a175 1
  return symbol_clone_if_forward_ref (make_expr_symbol (&e));
d708 1
a708 1
      expressionp->X_add_symbol = &dot_symbol;
d1328 1
a1328 3
	  if (mode != expr_defer
	      && segment == absolute_section
	      && !S_FORCE_RELOC (symbolP, 0))
d1376 2
a1377 7
  if (mode != expr_defer)
    {
      expressionP->X_add_symbol
	= symbol_clone_if_forward_ref (expressionP->X_add_symbol);
      expressionP->X_op_symbol
	= symbol_clone_if_forward_ref (expressionP->X_op_symbol);
    }
d1838 1
a1838 3
	       && ((SEG_NORMAL (rightseg)
		    && !S_FORCE_RELOC (resultP->X_add_symbol, 0)
		    && !S_FORCE_RELOC (right.X_add_symbol, 0))
d1952 1
a1952 4
	      if (retval == rightseg
		  && SEG_NORMAL (retval)
		  && !S_FORCE_RELOC (resultP->X_add_symbol, 0)
		  && !S_FORCE_RELOC (right.X_add_symbol, 0))
@


1.85.2.2
log
@	PR 12569
	* expr.c (operand): Correct passing of "mode" to expr.
	* read.c (do_org): Allow expr_section.
	(get_known_segmented_expression): Don't assert anything about the
	segment.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011
d962 4
a965 1
      segment = expr (0, expressionP, mode);
@


1.84
log
@	PR gas/11867
	* expr.c (operand <'-' and '~'>): Widen bignums.
	(operand <'!'>): Correct bignum result and convert to O_constant.
	* read.c (emit_expr): Don't assert on .byte bignum.  Don't display
	bignum truncated warning for sign extended bignums.
@
text
@d1972 16
a1987 6
	  if (! SEG_NORMAL (retval))
	    {
	      if (retval != undefined_section || SEG_NORMAL (rightseg))
		retval = rightseg;
	    }
	  else if (SEG_NORMAL (rightseg)
d1989 2
a1990 1
		   && op_left != O_subtract
d1992 1
a1992 1
		   )
@


1.83
log
@gas/
2010-06-22  Jan Beulich  <jbeulich@@novell.com>

	PR gas/11732
	* config/tc-i386-intel.c (i386_intel_parse_name): Handle pseudo
	symbols named "$".
	(i386_intel_operand): Remove bogus handling of pseudo symbols
	named "$".
	* expr.c (current_location): Remove 'static' and local
	declaration.
	* expr.h (current_location): Declare.

gas/testsuite/
2010-06-22  Jan Beulich  <jbeulich@@novell.com>

	PR gas/11732
	* gas/i386/jump.d: Adjust.
	* gas/i386/jump.s: Add check for branch to 2+$.
@
text
@d1059 9
a1077 1
		int nonzero = 0;
d1079 5
a1083 6
		  {
		    if (generic_bignum[i])
		      nonzero = 1;
		    generic_bignum[i] = 0;
		  }
		generic_bignum[0] = nonzero;
@


1.82
log
@Initialize the X_md field.

2010-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* expr.c (expr): Initialize the X_md field.
@
text
@a47 1
static void current_location (expressionS *);
d697 1
a697 1
static void
@


1.81
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1743 1
@


1.80
log
@Call symbol_same_p to check to if 2 symbols are the same.

gas/

2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11037
	* expr.c (resolve_expression): Call symbol_same_p to check
	if 2 symbols are the same.

	* symbols.c (symbol_same_p): New.
	* symbols.h (symbol_same_p): Likewise.

gas/testsuite/

2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11037
	* gas/i386/intelpic.s: Add testcases.
	* gas/i386/intelpic.d: Updated.
@
text
@d1590 1
a1590 1
      char c = get_symbol_end ();
d1592 1
a1592 1
      ret = md_operator (name, 2, &c);
d1596 1
a1596 1
	  *input_line_pointer = c;
d1606 1
a1606 1
	  *input_line_pointer = c;
@


1.79
log
@	PR gas/10856
	* expr.c (resolve_expression): Only add "left" value to O_symbol
	expression when the symbol is undefined and different from the
	original symbol.  Simplify negative logic.

	* gas/i386/intelpic.d: Correct.
@
text
@d2240 1
a2240 2
      else if (seg_left == undefined_section
	       && add_symbol != orig_add_symbol)
@


1.78
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d2000 1
d2082 1
d2127 1
a2127 1
		  if (seg_right != absolute_section || right != 0)
d2132 1
d2139 1
a2139 1
		  if (seg_left != absolute_section || left != 0)
d2155 1
d2165 5
a2169 5
	  else if (left != right
		   || ((seg_left != reg_section || seg_right != reg_section)
		       && (seg_left != undefined_section
			   || seg_right != undefined_section
			   || add_symbol != op_symbol)))
d2240 2
a2241 1
      else if (add_symbol != expressionP->X_add_symbol)
@


1.77
log
@update copyright dates
@
text
@d51 1
a51 1
static operatorT operator (int *);
d1231 1
a1231 1
	    operatorT operator = md_operator (name, 1, &c);
d1233 1
a1233 1
	    switch (operator)
d1253 1
a1253 1
	    if (operator != O_absent && operator != O_illegal)
d1260 1
a1260 1
		expressionP->X_op = operator;
d1549 1
a1549 1
expr_set_rank (operatorT operator, operator_rankT rank)
d1551 2
a1552 2
  gas_assert (operator >= O_md1 && operator < ARRAY_SIZE (op_rank));
  op_rank[operator] = rank;
d1575 1
a1575 1
operator (int *num_chars)
d1735 1
a1735 1
  op_left = operator (&op_chars);
d1766 1
a1766 1
      op_right = operator (&op_chars);
@


1.77.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d51 1
a51 1
static operatorT operatorf (int *);
d1231 1
a1231 1
	    operatorT op = md_operator (name, 1, &c);
d1233 1
a1233 1
	    switch (op)
d1253 1
a1253 1
	    if (op != O_absent && op != O_illegal)
d1260 1
a1260 1
		expressionP->X_op = op;
d1549 1
a1549 1
expr_set_rank (operatorT op, operator_rankT rank)
d1551 2
a1552 2
  gas_assert (op >= O_md1 && op < ARRAY_SIZE (op_rank));
  op_rank[op] = rank;
d1575 1
a1575 1
operatorf (int *num_chars)
d1735 1
a1735 1
  op_left = operatorf (&op_chars);
d1766 1
a1766 1
      op_right = operatorf (&op_chars);
@


1.77.2.2
log
@	PR gas/10856
	* expr.c (resolve_expression): Only add "left" value to O_symbol
	expression when the symbol is undefined and different from the
	original symbol.  Simplify negative logic.
@
text
@a1999 1
  symbolS *orig_add_symbol = add_symbol;
a2080 1
	      orig_add_symbol = expressionP->X_op_symbol;
d2125 1
a2125 1
		  if (!(seg_right == absolute_section && right == 0))
a2129 1
		      orig_add_symbol = expressionP->X_op_symbol;
d2136 1
a2136 1
		  if (!(seg_left == absolute_section && left == 0))
a2151 1
	      orig_add_symbol = expressionP->X_op_symbol;
d2161 5
a2165 5
	  else if (!(left == right
		     && ((seg_left == reg_section && seg_right == reg_section)
			 || (seg_left == undefined_section
			     && seg_right == undefined_section
			     && add_symbol == op_symbol))))
d2236 1
a2236 2
      else if (seg_left == undefined_section
	       && add_symbol != orig_add_symbol)
@


1.77.2.3
log
@Fix PR gas/11037.

gas/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	Backport from trunk:
	2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11037
	* expr.c (resolve_expression): Call symbol_same_p to check
	if 2 symbols are the same.

	* symbols.c (symbol_same_p): New.
	* symbols.h (symbol_same_p): Likewise.

gas/testsuite/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	Backport from trunk:
	2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11037
	* gas/i386/intelpic.s: Add testcases.
	* gas/i386/intelpic.d: Updated.

	2009-10-28  Alan Modra  <amodra@@bigpond.net.au>

	* gas/i386/intelpic.d: Correct.

	2009-10-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10704
	* gas/i386/intelpic.s: Add 2 new tests.
	* gas/i386/intelpic.d: Updated.
@
text
@d2240 2
a2241 1
      else if (!symbol_same_p (add_symbol, orig_add_symbol))
@


1.76
log
@gas/
2009-07-28  Jan Beulich  <jbeulich@@novell.com>

	* expr.c (op_rank): Specify size. Remove O_md* initializers.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.75
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d1489 1
a1489 1
static operator_rankT op_rank[] = {
a1519 16
  0,	/* O_md1 */
  0,	/* O_md2 */
  0,	/* O_md3 */
  0,	/* O_md4 */
  0,	/* O_md5 */
  0,	/* O_md6 */
  0,	/* O_md7 */
  0,	/* O_md8 */
  0,	/* O_md9 */
  0,	/* O_md10 */
  0,	/* O_md11 */
  0,	/* O_md12 */
  0,	/* O_md13 */
  0,	/* O_md14 */
  0,	/* O_md15 */
  0,	/* O_md16 */
@


1.74
log
@gas/
2009-04-20  Jan Beulich  <jbeulich@@novell.com>

	* expr.c (operand): Call md_need_index_operator() and
	md_operator() if defined. Add unary label.
	(operator): Call md_operator() if defined.
	(expr): Adjust assertions on range and rank of op_left and
	op_right. Don't abort on unhandled operators when reducing
	expressions with both operands being constant.
	(expr_set_rank): New.
	* expr.h (expr_set_rank): Declare.
@
text
@d414 1
a414 1
      assert (num_little_digits >= 4);
d1567 1
a1567 1
  assert (operator >= O_md1 && operator < ARRAY_SIZE (op_rank));
d1582 1
a1582 1
    assert (e.X_op == O_max);
@


1.73
log
@gas/
2009-04-16  Jan Beulich  <jbeulich@@novell.com>

	* expr.c: Include limits.h if available, and #define CHAR_BITS
	otherwise.
	(expr): Check range of shift count when evaluating a constant
	expression.
@
text
@a952 1
    case '(':
d955 5
d961 1
d1019 3
d1218 1
a1218 1
#ifdef TC_M68K
d1229 37
d1564 7
d1602 28
d1633 13
a1645 1
      return op_encoding[c];
d1784 1
a1784 1
      know (op_right == O_illegal
d1786 6
a1791 2
      know ((int) op_left >= (int) O_multiply
	    && (int) op_left <= (int) O_index);
d1895 1
a1895 1
	    default:			abort ();
d1970 1
@


1.72
log
@Add MN10300 linker relaxation support for symbol differences
@
text
@d34 7
d1789 8
@


1.71
log
@gas/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.h (md_register_arithmetic): Define.
	* config/tc-ia64.h (md_register_arithmetic): Likewise.
	* doc/internals.texi: Document md_register_arithmetic.
	* expr.c (make_expr_symbol): Force O_register expressions into
	reg_section.
	(expr): Provide default for md_register_arithmetic. Don't resolve
	adding/subtracting constants to/from registers if
	md_register_arithmetic is zero.
@
text
@d1741 3
@


1.70
log
@Switch to GPLv3
@
text
@d98 3
a100 1
			    : expr_section),
d1727 5
a1731 1
      if (op_left == O_add && right.X_op == O_constant)
d1754 2
a1755 1
      else if (op_left == O_subtract && right.X_op == O_constant)
d1760 2
a1761 1
      else if (op_left == O_add && resultP->X_op == O_constant)
@


1.69
log
@gas/
	* expr.c (expr): Assert on rankarg, not rank which can be unsigned.
	* read.c (read_a_source_file): Remove buffer_limit[-1] assertion.
	Don't skip over NUL char.
	(pseudo_set): Set X_op for registers to O_register.
	* symbols.c (symbol_clone): Remove assertion that sym is defined.
	(resolve_symbol_value): Resolve O_register symbols.
	* config/tc-i386.c (parse_real_register): Don't use i386_float_regtab.
	Instead find st(0) by hash lookup.
	* config/tc-ppc.c (ppc_macro): Warning fix.
opcodes/
	* i386-opc.c (i386_float_regtab, i386_float_regtab_size): Delete.
	Move contents to..
	(i386_regtab): ..here.
	* i386-opc.h (i386_float_regtab, i386_float_regtab_size): Delete.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.68
log
@	* expr.c (expr): Replace O_add case in switch (op_left) explaining
	why it can never occur.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d1639 1
a1639 1
  know (rank >= 0);
@


1.67
log
@remove some duplicate #include's.
@
text
@d1788 3
a1790 1
	    case O_add:			resultP->X_add_number += v; break;
@


1.66
log
@        * expr.c (operand): Remove `if (0 && ..)' statement and
        subsequently unused target_op label.  Collapse `if (1 || ..)'
        statement.
        * app.c (do_scrub_chars): Remove unused case 0, as it is handled
        separately above the switch.
@
text
@a27 1
#include <string.h>
@


1.65
log
@	PR 997
	* frags.c (frag_offset_fixed_p): New function.
	* frags.h (frag_offset_fixed_p): Declare.
	* expr.c (expr): Use frag_offset_fixed_p when simplifying subtraction.
	(resolve_expression): Likewise.
@
text
@a1005 5
	/* Do not accept ++e or --e as +(+e) or -(-e)
	   Disabled, since the preprocessor removes whitespace.  */
	if (0 && (c == '-' || c == '+') && *input_line_pointer == c)
	  goto target_op;
	
a1288 1
	target_op:
d1549 1
a1549 5
      /* Do not allow a++b and a--b to be a + (+b) and a - (-b)
	 Disabled, since the preprocessor removes whitespace.  */
      if (1 || input_line_pointer[1] != c)
	return op_encoding[c];
      return O_illegal;
@


1.64
log
@gas/
2005-12-22  Jan Beulich  <jbeulich@@novell.com>

	* symbols.h (snapshot_symbol): First parameter is now pointer
	to pointer to symbolS.
	* symbols.c (snapshot_symbol): Likewise. Store resulting symbol
	there. Use symbol_equated_p.
	* expr.c (resolve_expression): Change first argument to
	snapshot_symbol. Track possibly changed add_symbol consistently
	across function. Resolve more special cases with known result.
	Also update final_val when replacing add_symbol.

gas/testsuite/
2005-12-22  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/cond.s: Also check .if works on equates to undefined
	when the expression value can be known without knowing the
	value of the symbol.
	* gas/all/cond.l: Adjust.
	* gas/i386/equ.s: Also check .if works on (equates to)
	registers when the expression value can be known without
	knowing the value of the register.
	* gas/i386/equ.e: Adjust.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005
d1665 1
d1745 1
a1745 2
	       && (symbol_get_frag (right.X_add_symbol)
		   == symbol_get_frag (resultP->X_add_symbol))
d1747 4
a1750 1
		   || right.X_add_symbol == resultP->X_add_symbol))
d1753 1
d1907 1
d2010 1
d2017 2
a2018 1
	       && (finalize_syms || frag_left == frag_right)
d2078 1
@


1.64.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
a1664 1
      bfd_vma frag_off;
d1744 2
a1745 1
	       && retval == rightseg
d1747 1
a1747 4
		   || right.X_add_symbol == resultP->X_add_symbol)
	       && frag_offset_fixed_p (symbol_get_frag (resultP->X_add_symbol),
				       symbol_get_frag (right.X_add_symbol),
				       &frag_off))
a1749 1
	  resultP->X_add_number -= frag_off / OCTETS_PER_BYTE;
a1902 1
  bfd_vma frag_off;
a2004 1
      frag_off = 0;
d2011 1
a2011 2
	       && (finalize_syms
		   || frag_offset_fixed_p (frag_left, frag_right, &frag_off))
a2070 1
      right += frag_off / OCTETS_PER_BYTE;
@


1.63
log
@* expr.c (operand <case '$'>): Use DOLLAR_AMBIGU rather than flag_mri_m68k
  as condition for parsing the '$' as a prefix.
* as.h (DOLLAR_AMBIGU): Define if needed.
@
text
@d1916 1
a1916 1
      if (!snapshot_symbol (add_symbol, &left, &seg_left, &frag_left))
d1924 1
a1924 1
      if (!snapshot_symbol (add_symbol, &left, &seg_left, &frag_left))
d1958 2
a1959 2
      if (!snapshot_symbol (add_symbol, &left, &seg_left, &frag_left)
	  || !snapshot_symbol (op_symbol, &right, &seg_right, &frag_right))
d1977 1
a1977 1
	      expressionP->X_add_symbol = expressionP->X_op_symbol;
d1994 11
a2004 3
	 both operands are in the same section.  Otherwise, both
	 operands must be absolute.  We already handled the case of
	 addition or subtraction of a constant above.  */
d2012 58
a2069 4
	       && ((seg_left != undefined_section
		    && seg_left != reg_section)
		   || add_symbol == op_symbol)))
	return 0;
d2097 1
a2097 2
		  && ((seg_left != undefined_section
		       && seg_left != reg_section)
d2130 3
@


1.62
log
@	* expr.c (op_encoding): Map '=' to O_SINGLE_EQ, if defined.
	* config/tc-z80.h: Define O_SINGLE_EQ as O_eq.
@
text
@d1098 1
a1098 1
      if (flag_m68k_mri && hex_p (*input_line_pointer))
d1100 2
a1101 2
	  /* In MRI mode, '$' is also used as the prefix for a
	     hexadecimal constant.  */
@


1.61
log
@	* expr.c (integer_constant): Match only 'B' as binary suffix if
        NUMBERS_WITH_SUFFIX and LOCAL_LABELS_FB.  Allow both 'b' and 'B'
        otherwise.
@
text
@d1393 3
d1405 1
a1405 1
  __, __, __, __, O_lt, __, O_gt, __,
@


1.60
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d304 4
a307 1
	  if (c == 'B')
@


1.59
log
@* expr.c (operator): Allow "!=" as a synonym for "<>".
* doc/as.texinfo (Infix Op): Mention "!=".
@
text
@d44 1
a44 1
static segT operand (expressionS *);
d711 1
a711 1
operand (expressionS *expressionP)
d947 4
a950 1
      segment = expression (expressionP);
d1008 1
a1008 1
	operand (expressionP);
d1220 1
a1220 1
	  if (md_parse_name (name, expressionP, &c))
d1271 1
a1271 1
	  if (segment == absolute_section)
d1276 1
a1276 1
	  else if (segment == reg_section)
d1320 3
d1634 2
a1635 1
      expressionS *resultP	/* Deliver result here.  */)
d1650 1
a1650 1
  retval = operand (resultP);
d1662 1
a1662 1
      rightseg = expr (op_rank[(int) op_left], &right);
d1877 3
d1882 190
d2108 1
a2108 1
  operand (&exp);
@


1.58
log
@Update the address and phone number of the FSF
@
text
@d1590 1
a1590 2
      /* We accept !! as equivalent to ^ for MRI compatibility.  */
      if (input_line_pointer[1] != '!')
d1592 9
a1604 2
      *num_chars = 2;
      return O_bit_exclusive_or;
@


1.57
log
@	* Makefile.am (GAS_CFILES): Remove bignum-copy.c.
	(GENERIC_OBJS): Likewise, remove bignum-copy.o.
	(bignum-copy.o): Remove.
	* Makefile.in: Regenerate.
	* makefile.vms (OBJS): Remove bignum-copy.obj.
	* symbols.h (local_symbol_make): Remove declaration.
	(verify_symbol_chain_2): Likewise.
	* symbols.c (local_symbol_make): Make static.
	(max_indent_level): Likewise.
	(verify_symbol_chain_2): Remove.
	* macro.c (macro_hash): Make static.
	* messages.c (fprint_value): Remove.
	* read.h (get_absolute_expr): Remove.
	(emit_leb128_expr): Likewise.
	(do_s_func): Likewise.
	* read.c (do_s_func): Make static.
	(emit_leb128_expr): Likewise.
	(get_absolute_expr): Likewise.
	* as.h (as_howmuch): Remove declaration.
	(fprint_value): Likewise.
	* as.c (myname): Make static.
	* input-scrub.c (as_howmuch): Remove.
	(as_1_char): Likewise.
	* input-file.h (input_file_is_open): Remove.
	* input-file.c (input_file_is_open): Likewise.
	* expr.h (expr_build_unary): Remove declaration.
	(expr_build_binary): Likewise.
	* expr.c (expr_build_unary): Remove.
	(expr_build_binary): Likewise.
	* hash.h (hash_replace): Remove declaration.
	(hash_delete): Likewise.
	* hash.c (hash_replace): Remove.
	(hash_delete): Likewise.
	* bignum-copy.c (bignum_copy): Move from here ..
	* config/tc-vax.c (bignum_copy): .. to here.
	* bignum.h (LOG_TO_BASE_2_OF_10): Remove.
	(bignum_copy): Remove extern declaration.
	* sb.h (string_count): Remove extern declaration.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* sb.c (dsize): Replace preprocessor macro with static int.
	(string_count): Make static.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* config/obj-coff.c (dim_index): Make static.
	* config/tc-i386.c (GOT_symbol): Likewise.
	(output_invalid_buf): Likewise.
	* doc/internals.texi (Warning and error messages): Remove the
	prototype for fprint_value.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.56
log
@gas/
2005-03-15  Jan Beulich  <jbeulich@@novell.com>

	* expr.c (operand): Merge handling of unary + into that for unary
	-, !, and ~.
@
text
@a159 27
/* Build an expression for OP s1.  */

symbolS *
expr_build_unary (operatorT op, symbolS *s1)
{
  expressionS e;

  e.X_op = op;
  e.X_add_symbol = s1;
  e.X_add_number = 0;
  return make_expr_symbol (&e);
}

/* Build an expression for s1 OP s2.  */

symbolS *
expr_build_binary (operatorT op, symbolS *s1, symbolS *s2)
{
  expressionS e;

  e.X_op = op;
  e.X_add_symbol = s1;
  e.X_op_symbol = s2;
  e.X_add_number = 0;
  return make_expr_symbol (&e);
}

a188 2
/* If nonzero, we've been asked to assemble nan, +inf or -inf.  */
int generic_floating_point_magic;
@


1.55
log
@Remove redundant code enclosed by #ifdef RELAX_PAREN_GROUPING....#endif.
@
text
@a1013 8
    case '+':
      /* Do not accept ++e as +(+e).
	 Disabled, since the preprocessor removes whitespace.  */
      if (0 && *input_line_pointer == '+')
	goto target_op;
      (void) operand (expressionP);
      break;

d1027 1
d1029 1
a1029 1
        /* Do not accept --e as -(-e)
d1031 1
a1031 1
	if (0 && c == '-' && *input_line_pointer == '-')
d1048 1
a1048 1
	    else
d1095 11
a1105 8
	    expressionP->X_add_symbol = make_expr_symbol (expressionP);
	    if (c == '-')
	      expressionP->X_op = O_uminus;
	    else if (c == '~' || c == '"')
	      expressionP->X_op = O_bit_not;
	    else
	      expressionP->X_op = O_logical_not;
	    expressionP->X_add_number = 0;
@


1.54
log
@	* expr.c (integer_constant): Remove TARGET_WORD_SIZE hack.
	* config/tc-m68k.h (TARGET_WORD_SIZE): Delete.
@
text
@d980 1
a980 6
	{
#ifdef RELAX_PAREN_GROUPING
	  if (c != '(')
#endif
	    as_bad (_("missing '%c'"), c == '(' ? ')' : ']');
	}
@


1.53
log
@	* as.h (assert): Warning fix.
	* expr.c (expr): Correct assertion.
	* read.c (s_comm_internal): Remove assertion.
	* write.c (relax_segment): Enable vma assertion only for BFD_ASSEMBLER.
	(fixup_segment): Remove assertion.
	* config/tc-dlx.c (machine_ip): Remove untrue assertions.
	(md_apply_fix3): Likewise.
	* config/tc-i370.c (md_begin): Correct assertion.
	(i370_macro): Warning fix for assertion.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002
a611 4
#ifdef TARGET_WORD_SIZE
	  /* Sign extend NUMBER.  */
	  number |= (-(number >> (TARGET_WORD_SIZE - 1))) << (TARGET_WORD_SIZE - 1);
#endif
@


1.52
log
@	* expr.c (operand): Handle the "~", "-", and "!" operators applied
	to bignums.

	* gas/arm/bignum1.s: New test.
	* gas/arm/arm.exp: Run it.
@
text
@d1719 1
a1719 1
	    && (int) op_left <= (int) O_logical_or);
@


1.51
log
@	* expr.c (operand, operator): Don't reject '++' and '--'.
@
text
@d1079 29
@


1.50
log
@	* expr.c (operand): Correct checks for ++ and --.
@
text
@d1024 3
a1026 2
      /* Do not accept ++e as +(+e) */
      if (*input_line_pointer == '+')
d1045 3
a1047 2
        /* Do not accept --e as -(-e) */
	if (c == '-' && *input_line_pointer == '-')
d1556 3
a1558 2
      /* Do not allow a++b and a--b to be a + (+b) and a - (-b) */
      if (input_line_pointer[1] != c)
@


1.49
log
@	* expr.c (operand): Reject ++ and --.
	(operator): Likewise.
@
text
@d1025 1
a1025 1
      if (input_line_pointer[1] == '+')
d1045 1
a1045 1
	if (c == '-' && input_line_pointer[1] == '-')
@


1.48
log
@	* ehopt.c: Convert to ISO-C.
	* emul.h: Likewise.
	* expr.c: Likewise.
	* expr.h: Likewise.
	* flonum-copy.c: Likewise.
	* flonum-mult.c: Likewise.
	* flonum.h: Likewise.
	* frags.c: Likewise.
	* frags.h: Likewise.
@
text
@d1024 3
d1044 4
d1299 1
d1551 7
@


1.48.6.1
log
@Merge to 2.15 branch.
@
text
@a1023 3
      /* Do not accept ++e as +(+e) */
      if (input_line_pointer[1] == '+')
	goto target_op;
a1040 4
        /* Do not accept --e as -(-e) */
	if (c == '-' && input_line_pointer[1] == '-')
	  goto target_op;
	
a1291 1
	target_op:
a1542 7

    case '+':
    case '-':
      /* Do not allow a++b and a--b to be a + (+b) and a - (-b) */
      if (input_line_pointer[1] != c)
	return op_encoding[c];
      return O_illegal;
@


1.48.6.2
log
@	* expr.c (operand): Correct checks for ++ and --.
@
text
@d1025 1
a1025 1
      if (*input_line_pointer == '+')
d1045 1
a1045 1
	if (c == '-' && *input_line_pointer == '-')
@


1.48.6.3
log
@	* expr.c (operand, operator): Don't reject '++' and '--'.
@
text
@d1024 2
a1025 3
      /* Do not accept ++e as +(+e).
	 Disabled, since the preprocessor removes whitespace.  */
      if (0 && *input_line_pointer == '+')
d1044 2
a1045 3
        /* Do not accept --e as -(-e)
	   Disabled, since the preprocessor removes whitespace.  */
	if (0 && c == '-' && *input_line_pointer == '-')
d1554 2
a1555 3
      /* Do not allow a++b and a--b to be a + (+b) and a - (-b)
	 Disabled, since the preprocessor removes whitespace.  */
      if (1 || input_line_pointer[1] != c)
@


1.47
log
@        * expr.c (make_expr_symbol): Fold FAKE_LABEL_NAME use into the
        symbol_create call.
        (current_location): Use symbol_temp_new_now.
        * stabs.c (s_stab_generic): Use symbol_temp_new.
        * symbols.c (temp_label_name): Remove.
        (symbol_temp_new, symbol_temp_make): Use FAKE_LABEL_NAME.
@
text
@d35 2
a36 2
static void floating_constant PARAMS ((expressionS * expressionP));
static valueT generic_bignum_to_int32 PARAMS ((void));
d38 1
a38 1
static valueT generic_bignum_to_int64 PARAMS ((void));
d40 6
a45 6
static void integer_constant PARAMS ((int radix, expressionS * expressionP));
static void mri_char_constant PARAMS ((expressionS *));
static void current_location PARAMS ((expressionS *));
static void clean_up_expression PARAMS ((expressionS * expressionP));
static segT operand PARAMS ((expressionS *));
static operatorT operator PARAMS ((int *));
d66 1
a66 2
make_expr_symbol (expressionP)
     expressionS *expressionP;
d120 1
a120 4
expr_symbol_where (sym, pfile, pline)
     symbolS *sym;
     char **pfile;
     unsigned int *pline;
d150 1
a150 2
expr_build_uconstant (value)
     offsetT value;
d163 1
a163 3
expr_build_unary (op, s1)
     operatorT op;
     symbolS *s1;
d176 1
a176 4
expr_build_binary (op, s1, s2)
     operatorT op;
     symbolS *s1;
     symbolS *s2;
d190 1
a190 1
expr_build_dot ()
d220 1
a220 2
floating_constant (expressionP)
     expressionS *expressionP;
d247 1
a247 1
generic_bignum_to_int32 ()
d258 1
a258 1
generic_bignum_to_int64 ()
d273 1
a273 3
integer_constant (radix, expressionP)
     int radix;
     expressionS *expressionP;
d632 1
a632 2
mri_char_constant (expressionP)
     expressionS *expressionP;
d721 1
a721 2
current_location (expressionp)
     expressionS *expressionp;
d744 1
a744 2
operand (expressionP)
     expressionS *expressionP;
d1341 1
a1341 2
clean_up_expression (expressionP)
     expressionS *expressionP;
d1492 1
a1492 1
expr_set_precedence ()
d1511 1
a1511 1
expr_begin ()
d1528 1
a1528 2
operator (num_chars)
     int *num_chars;
d1616 2
a1617 3
expr (rankarg, resultP)
     int rankarg;	/* Larger # is higher rank.  */
     expressionS *resultP;	/* Deliver result here.  */
d1875 1
a1875 1
get_symbol_end ()
d1894 1
a1894 1
get_single_number ()
@


1.46
log
@	* expr.c (operand): Add support for n.nn flonums.
@
text
@a69 1
  const char *fake;
a92 2
  fake = FAKE_LABEL_NAME;

d97 1
a97 1
  symbolP = symbol_create (fake,
a744 5
      symbolS *symbolp;

      symbolp = symbol_new (FAKE_LABEL_NAME, now_seg,
			    (valueT) frag_now_fix (),
			    frag_now);
d746 1
a746 1
      expressionp->X_add_symbol = symbolp;
@


1.45
log
@	* expr.c (expr): Simplify foo-foo here.
	(clean_up_expression): Remove O_subtract code.
@
text
@d81 2
a82 2
         generic_floating_point_number or generic_bignum, and we are
         going to lose it if we haven't already.  */
d332 2
a333 2
         radix.  For that matter, it might actually be a floating
         point constant.  */
d404 1
a404 1
         This example is equivalent to 0x00000333000000001234567800000001.  */
d684 2
a685 2
             last one to make it match the earlier ones.  If there is
             only one, we can just use the value directly.  */
d831 1
a831 1
	  /* Check for a hex constant.  */
d834 1
a834 1
	  if (*s == 'h' || *s == 'H')
d1082 12
d1115 1
a1115 1
         DOLLAR_DOT is defined.  */
d1123 1
a1123 1
             hexadecimal constant.  */
d1214 1
a1214 1
         using hexadecimal digits.  */
d1242 3
a1244 3
             specially in certain contexts.  If a name always has a
             specific value, it can often be handled by simply
             entering it in the symbol table.  */
d1790 1
a1790 1
                 characteristics of the compiler used to compile gas.  */
@


1.44
log
@	* write.h (struct fix): Add fx_dot_value.
	(dot_value): Declare.
	* write.c (dot_value): New var.
	(fix_new_internal): Save dot_value as fx_dot_value.
	* expr.c (expr): Update dot_value.
@
text
@a1349 2
	'foo-foo' symbol references cancelled to 0, which changes X_op
	from O_subtract to O_constant.
a1371 15
    case O_subtract:
      if (expressionP->X_op_symbol == expressionP->X_add_symbol
	  || ((symbol_get_frag (expressionP->X_op_symbol)
	       == symbol_get_frag (expressionP->X_add_symbol))
	      && SEG_NORMAL (S_GET_SEGMENT (expressionP->X_add_symbol))))
	{
	  addressT diff = (S_GET_VALUE (expressionP->X_add_symbol)
			   - S_GET_VALUE (expressionP->X_op_symbol));

	  expressionP->X_op = O_constant;
	  expressionP->X_add_symbol = NULL;
	  expressionP->X_op_symbol = NULL;
	  expressionP->X_add_number += diff;
	}
      break;
d1737 2
a1738 1
	       && SEG_NORMAL (rightseg))
@


1.43
log
@	* dwarf2dbg.c: Always include dwarf2dbg.h.
	(dwarf2_directive_file): Adjust dummy version args.
	* ecoff.c (ecoff_directive_weakext): Add ATTRIBUTE_UNUSED.
	* expr.c (clean_up_expression <O_subtract>): Allow subtraction
	when symbol values differ.
	* read.c (do_align): Add ATTRIBUTE_UNUSED to label.
	(pseudo_set <O_subtract>): Remove unnecessary segment test.
	* config/obj-bout.c (obj_pseudo_table): Warning fix.
@
text
@d1660 4
@


1.42
log
@	* app.c: Fix formatting.
	* as.c: Likewise.
	* ehopt.c: Likewise.
	* expr.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2001
d1378 1
a1378 3
	      && SEG_NORMAL (S_GET_SEGMENT (expressionP->X_add_symbol))
	      && (S_GET_VALUE (expressionP->X_op_symbol)
		  == S_GET_VALUE (expressionP->X_add_symbol))))
@


1.41
log
@	* app.c: Fix comment typos.
	* bit_fix.h: Likewise.
	* expr.c: Likewise.
	* itbl-ops.c: Likewise.
@
text
@d806 1
a806 1
                        expressionP);
@


1.40
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d762 1
a762 1
   Out:	A expressionS.
d1345 1
a1345 1
/* In:	address of a expressionS.
d1402 1
a1402 1
   We used to do a aho/ullman shift-reduce parser, but the logic got so
@


1.39
log
@	* expr.c (expr): Move code setting "retval" to the end of the loop,
	and rearrange for efficiency.  For "PIC code" subtraction, use
	"rightseg" rather than recalculating.  For "symbol OP symbol"
	subtract, set "retval" to absolute_section if symbols in same
	section.
	* symbols.c (resolve_symbol_value): Resolve "sym +/- expr" to an
	O_symbol.  Simplify a +/- b code.  Allow equality and non-equality
	comparisons on symbols from any section.  Allow other comparison
	operators as for subtraction.
	(symbol_equated_reloc_p): New predicate function.
	* symbols.h (symbol_equated_reloc_p): Declare.
	* write.c (adjust_reloc_syms): Use symbol_equated_reloc_p.
	(write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_segment <rs_machine_dependent>): Ensure segment for
	expression syms is set correctly.
	* config/tc-mips.c (md_estimate_size_before_relax): Likewise.
	* config/tc-i386.c (md_assemble <Output jumps>): Don't lose part
	of a complex expression when setting up frag_var.
@
text
@a27 1
#include <ctype.h>
d32 1
d334 1
a334 3
      for (suffix = input_line_pointer;
	   isalnum ((unsigned char) *suffix);
	   suffix++)
d348 1
a348 2
	  if (islower ((unsigned char) c))
	    c = toupper (c);
d862 1
a862 2
	      expressionP->X_add_number =
		- (isupper ((unsigned char) c) ? tolower (c) : c);
d984 1
a984 2
	  expressionP->X_add_number =
	    - (isupper ((unsigned char) c) ? tolower (c) : c);
@


1.38
log
@
2001-08-14  Jeff Johnston  <jjohnstn@@redhat.com>

        * expr.c (operand)[LITERAL_PREFIXDOLLAR_HEX]: Treat $L as
        a label, not a hex constant.

This patch was approved by Nick Clifton.
@
text
@a1701 15
      if (retval == undefined_section)
	{
	  if (SEG_NORMAL (rightseg))
	    retval = rightseg;
	}
      else if (! SEG_NORMAL (retval))
	retval = rightseg;
      else if (SEG_NORMAL (rightseg)
	       && retval != rightseg
#ifdef DIFF_EXPR_OK
	       && op_left != O_subtract
#endif
	       )
	as_bad (_("operation combines symbols in different segments"));

d1757 1
a1757 2
	       && SEG_NORMAL (S_GET_SEGMENT (right.X_add_symbol)))

d1852 8
a1859 1
	    resultP->X_add_number -= right.X_add_number;
d1869 15
@


1.37
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d814 3
@


1.36
log
@Fix typo in comment
@
text
@d84 1
a84 1
	as_bad (_("bignum invalid; zero assumed"));
d86 1
a86 1
	as_bad (_("floating point number invalid; zero assumed"));
d246 1
a246 1
	  as_bad (_("bad floating-point constant: exponent overflow, probably assembling junk"));
d250 2
a251 1
	  as_bad (_("bad floating-point constant: unknown error code=%d."), error_code);
d431 1
a431 1
	    as_bad (_("A bignum with underscores may not have more than 8 hex digits in any word."));
d454 1
a454 1
	as_bad (_("A bignum with underscores must have exactly 4 words."));
d577 1
a577 1
	      as_bad (_("backw. ref to unknown label \"%d:\", 0 assumed."),
d700 1
a700 1
      as_bad (_("Character constant too large"));
d1014 1
a1014 1
	    as_bad (_("Missing '%c' assumed"), c == '(' ? ')' : ']');
d1316 1
a1316 1
	      as_bad (_("Bad expression"));
@


1.35
log
@Revert last patch.
@
text
@d1459 1
a1459 1
   3	= <> < <= >= >
@


1.34
log
@	* expr.c (expr): Set return value to absolute_section for
	subtractive operations on symbols within a segment.
	* read.c (pseudo_set): Set segment for complex expressions.
@
text
@a1864 13
	  if (retval == rightseg
	      && (op_left == O_subtract
		  || op_left == O_eq
		  || op_left == O_ne
		  || op_left == O_lt
		  || op_left == O_le
		  || op_left == O_ge
		  || op_left == O_gt))
	    {
	      /* For subtractive operations on symbols within a
		 segment, the result will absolute.  */
	      retval = absolute_section;
	    }
@


1.33
log
@	* symbols.c (resolve_symbol_value): Remove "finalize" param,
	instead use finalize_syms directly.  Don't treat expressions
	specially with regard to finalize_syms.  Update calls to self.
	(resolve_local_symbol): Update call to resolve_symbol_value.
	(S_GET_VALUE): Likewise.  Return resolve_symbol_value if
	!finalize_syms.
	* symbols.h (resolve_symbol_value): Update prototype.
	* config/obj-aout.c (obj_crawl_symbol_chain): Update call
	to resolve_symbol_value.
	* config/obj-bout.c (obj_crawl_symbol_chain): Likewise.
	* config/obj-coff.c (do_relocs_for): Likewise.
	(yank_symbols): Likewise.
	(fixup_segment): Likewise.
	* config/obj-vms.c (obj_crawl_symbol_chain): Likewise.
	* config/tc-mips.c (md_convert_frag): Likewise.
	* config/tc-ppc.c (ppc_frob_symbol): Likewise.
	(ppc_fix_adjustable): Likewise.
	* dwarf2dbg.c (dwarf2dbg_estimate_size_before_relax): Likewise.
	(dwarf2dbg_convert_frag): Likewise.
	* ehopt.c (eh_frame_estimate_size_before_relax): Likewise.
	(eh_frame_convert_frag): Likewise.
	* expr.c (make_expr_symbol): Likewise.
	* write.c (adjust_reloc_syms): Likewise.
	(write_object_file): Likewise.
	(relax_segment): Likewise.
	(fixup_segment): Likewise.
	(finalize_syms): Init to zero, and update comment.
	(write_object_file): Set finalize_syms to 1 rather than 2.
	* doc/internals.texi (sy_value): Mention finalize_syms.
	(S_GET_VALUE): Remove restriction on when S_GET_VALUE can be called.
@
text
@d1865 13
@


1.32
log
@* expr.c (operand): Pass &c to md_parse_name().
* config/tc-ia64.h, config/tc-ppc.h, config/tc-tic54x.h: Adjust.
@
text
@d108 1
a108 1
    resolve_symbol_value (symbolP, finalize_syms);
@


1.31
log
@Pass finalize_syms on calls to resolve_symbol_value.
@
text
@d1234 1
a1234 1
	  if (md_parse_name (name, expressionP))
@


1.30
log
@Fix copyright notices
@
text
@d108 1
a108 1
    resolve_symbol_value (symbolP, 1);
@


1.29
log
@Update copyright date.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.28
log
@Fix parsing of multi-char operators.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.27
log
@Correct {STANDARD,MRI}_MUL_PRECEDENCE value.
@
text
@d44 1
a44 1
static operatorT operator PARAMS ((void));
d1555 3
a1557 3
/* Return the encoding for the operator at INPUT_LINE_POINTER.
   Advance INPUT_LINE_POINTER to the last character in the operator
   (i.e., don't change it for a single character operator).  */
d1560 2
a1561 1
operator ()
d1567 1
d1592 1
a1592 1
      ++input_line_pointer;
d1599 1
a1599 1
      ++input_line_pointer;
d1614 1
a1614 1
      ++input_line_pointer;
d1625 1
a1625 1
      ++input_line_pointer;
d1632 1
a1632 1
      ++input_line_pointer;
d1639 1
a1639 1
      ++input_line_pointer;
d1658 1
d1667 1
a1667 1
  op_left = operator ();
d1672 1
a1672 1
      input_line_pointer++;	/* -> after 1st character of operator.  */
d1712 1
a1712 1
      op_right = operator ();
@


1.27.2.1
log
@Fix parsing of multi-char operators.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
d44 1
a44 1
static operatorT operator PARAMS ((int *));
d1555 3
a1557 3
/* Return the encoding for the operator at INPUT_LINE_POINTER, and
   sets NUM_CHARS to the number of characters in the operator.
   Does not advance INPUT_LINE_POINTER.  */
d1560 1
a1560 2
operator (num_chars)
     int *num_chars;
a1565 1
  *num_chars = 1;
d1590 1
a1590 1
      *num_chars = 2;
d1597 1
a1597 1
      *num_chars = 2;
d1612 1
a1612 1
      *num_chars = 2;
d1623 1
a1623 1
      *num_chars = 2;
d1630 1
a1630 1
      *num_chars = 2;
d1637 1
a1637 1
      *num_chars = 2;
a1655 1
  int op_chars;
d1664 1
a1664 1
  op_left = operator (&op_chars);
d1669 1
a1669 1
      input_line_pointer += op_chars;	/* -> after operator.  */
d1709 1
a1709 1
      op_right = operator (&op_chars);
@


1.27.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001
@


1.26
log
@2000-10-30  Kazu Hirata  <kazu@@hxi.com>

	* expr.c: Fix formatting.
	* flonum-copy.c: Likewise.
	* flonum.h: Likewise.
	* gasp.c: Likewise.
	* hash.c: Likewise.
@
text
@d1472 1
a1472 1
  0,	/* O_bit */
d1520 2
a1521 2
#define STANDARD_MUL_PRECEDENCE (7)
#define MRI_MUL_PRECEDENCE (5)
@


1.25
log
@2000-10-17  Kazu Hirata  <kazu@@hxi.com>

	* debug.c: Fix formatting.
	* depend.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* expr.c: Likewise.
	* expr.h: Likewise.
	* flonum-konst.c: Likewise.
	* frags.h: Likewise.
@
text
@d1420 2
a1421 3
static const operatorT op_encoding[256] =
{				/* Maps ASCII -> operators.  */

@


1.24
log
@Miscellaneous tiny fixes.
@
text
@d51 1
a51 2
struct expr_symbol_line
{
d219 2
a220 2
FLONUM_TYPE generic_floating_point_number =
{
d1466 1
a1466 2
static operator_rankT op_rank[] =
{
@


1.23
log
@fix formatting
@
text
@d1307 1
a1307 1
	     input_line_pointer passed the expression.  If it can't parse the
@


1.22
log
@2000-08-11  Kazu Hirata  <kazu@@hxi.com>

	* expr.c: Fix formatting.
@
text
@d862 1
a862 1
		-(isupper ((unsigned char) c) ? tolower (c) : c);
d985 1
a985 1
	    -(isupper ((unsigned char) c) ? tolower (c) : c);
d1072 1
a1072 1
		expressionP->X_add_number = -expressionP->X_add_number;
d1820 1
a1820 1
		resultP->X_add_number == v ? ~(offsetT) 0 : 0;
d1824 1
a1824 1
		resultP->X_add_number != v ? ~(offsetT) 0 : 0;
d1828 1
a1828 1
		resultP->X_add_number < v ? ~(offsetT) 0 : 0;
d1832 1
a1832 1
		resultP->X_add_number <= v ? ~(offsetT) 0 : 0;
d1836 1
a1836 1
		resultP->X_add_number >= v ? ~(offsetT) 0 : 0;
d1840 1
a1840 1
		resultP->X_add_number > v ? ~(offsetT) 0 : 0;
@


1.21
log
@2000-08-10  Kazu Hirata  <kazu@@hxi.com>

	* expr.c: Fix formatting.
@
text
@d222 5
a226 5
  &generic_bignum[6],		/* Low.  (JF: Was 0)  */
  &generic_bignum[SIZE_OF_LARGE_NUMBER + 6 - 1], /* High.  JF: (added +6)  */
  0,				/* Leader.  */
  0,				/* Exponent.  */
  0				/* Sign.  */
d635 1
a635 1
	  input_line_pointer--;	/* Rstore following character.  */
d640 1
a640 1
      /* not a small number */
d788 1
a788 1
  c = *input_line_pointer++;	/* input_line_pointer->past char in c.  */
@


1.20
log
@* new parsing option

2000-07-17  Frank Ch. Eigler  <fche@@redhat.com>

	* expr.c (operand): Permit %bin literals if LITERAL_PREFIXPERCENT_BIN
	is defined.
@
text
@d20 1
a20 1
   02111-1307, USA. */
d22 4
a25 6
/*
 * This is really a branch office of as-read.c. I split it out to clearly
 * distinguish the world of expressions from the world of statements.
 * (It also gives smaller files to re-compile.)
 * Here, "operand"s are of expressions, not instructions.
 */
d211 2
a212 4
/*
 * Build any floating-point literal here.
 * Also build any bignum literal here.
 */
d222 5
a226 5
  &generic_bignum[6],		/* low (JF: Was 0) */
  &generic_bignum[SIZE_OF_LARGE_NUMBER + 6 - 1], /* high JF: (added +6) */
  0,				/* leader */
  0,				/* exponent */
  0				/* sign */
d228 2
a229 1
/* If nonzero, we've been asked to assemble nan, +inf or -inf */
d236 1
a236 2
  /* input_line_pointer->*/
  /* floating-point constant. */
d254 2
a255 2
  /* input_line_pointer->just after constant, */
  /* which may point to whitespace. */
d259 2
a260 2
static valueT 
generic_bignum_to_int32 () 
d270 2
a271 2
static valueT 
generic_bignum_to_int64 () 
d273 8
a280 8
  valueT number = 
	   ((((((((valueT) generic_bignum[3] & LITTLENUM_MASK)
		 << LITTLENUM_NUMBER_OF_BITS)
	        | ((valueT) generic_bignum[2] & LITTLENUM_MASK))
	       << LITTLENUM_NUMBER_OF_BITS)
	      | ((valueT) generic_bignum[1] & LITTLENUM_MASK))
	     << LITTLENUM_NUMBER_OF_BITS)
	    | ((valueT) generic_bignum[0] & LITTLENUM_MASK));
d290 1
a290 1
  char *start;		/* start of number. */
d293 6
a298 6
  valueT number;	/* offset or (absolute) value */
  short int digit;	/* value of next digit in current radix */
  short int maxdig = 0;/* highest permitted digit value. */
  int too_many_digits = 0;	/* if we see >= this number of */
  char *name;		/* points to name of symbol */
  symbolS *symbolP;	/* points to symbol */
d300 1
a300 1
  int small;			/* true if fits in 32 bits. */
d302 1
a302 1
  /* May be bignum, or may fit in 32 bits. */
d315 1
a315 1
     number.  The cavalier approach is for speed in ordinary cases. */
d388 1
a388 1
      too_many_digits = (valuesize + 11) / 4; /* very rough */
d399 2
a400 2
  /* c contains character after number. */
  /* input_line_pointer->char after c. */
d403 1
a403 1
  if (radix == 16 && c == '_') 
d410 1
a410 1
      input_line_pointer = start;	/*->1st digit. */
d414 1
a414 1
      for (c = '_'; c == '_'; num_little_digits+=2)
d417 2
a418 2
	  /* Convert one 64-bit word. */
	  int ndigit = 0; 
d429 1
a429 1
	  if (ndigit > 8) 
d432 2
a433 1
	  /* Add this chunk to the bignum.  Shift things down 2 little digits.*/
d435 4
a438 2
	  for (i = min (num_little_digits + 1, SIZE_OF_LARGE_NUMBER - 1); i >= 2; i--)
	    generic_bignum[i] = generic_bignum[i-2];
d440 1
a440 1
	  /* Add the new digits as the least significant new ones. */
d445 1
a445 1
      /* Again, c is char after number, input_line_pointer->after c. */
d456 3
a458 3
       * us a change to fit this constant into a small number.
       */
      while (generic_bignum[num_little_digits-1] == 0 && num_little_digits > 1)
d460 1
a460 1
	
d463 1
a463 1
	  /* will fit into 32 bits. */
d478 3
a480 1
	  number = num_little_digits; /* number of littlenums in the bignum. */
d485 3
a487 5
      /*
       * we saw a lot of digits. manufacture a bignum the hard way.
       */
      LITTLENUM_TYPE *leader;	/*->high order littlenum of the bignum. */
      LITTLENUM_TYPE *pointer;	/*->littlenum we are frobbing now. */
d495 1
a495 1
      input_line_pointer = start;	/*->1st digit. */
d497 3
a499 7
      for (;
	   (carry = hex_value (c)) < maxdig;
	   c = *input_line_pointer++)
	{
	  for (pointer = generic_bignum;
	       pointer <= leader;
	       pointer++)
d511 1
a511 1
		  /* room to grow a longer bignum. */
d516 2
a517 2
      /* again, c is char after number, */
      /* input_line_pointer->after c. */
d521 1
a521 1
	  /* will fit into 32 bits. */
d535 2
a536 1
	  number = leader - generic_bignum + 1;	/* number of littlenums in the bignum. */
d547 5
a551 6
      /*
       * here with number, in correct radix. c is the next char.
       * note that unlike un*x, we allow "011f" "0x9f" to
       * both mean the same as the (conventional) "9f". this is simply easier
       * than checking for strict canonical form. syntax sux!
       */
d555 2
a556 4
	  /*
	   * backward ref to local label.
	   * because it is backward, expect it to be defined.
	   */
d560 1
a560 1
	  /* seen before, or symbol is defined: ok */
d564 2
a565 2
	      /* local labels are never absolute. don't waste time
		 checking absoluteness. */
d573 1
a573 1
	      /* either not seen or not defined. */
d585 7
a591 8
	  /*
	   * forward reference. expect symbol to be undefined or
	   * unknown. undefined: seen it before. unknown: never seen
	   * it before.
	   * construct a local label name, then an undefined symbol.
	   * don't create a xseg frag for it: caller may do that.
	   * just return it as never seen before.
	   */
d594 1
a594 1
	  /* we have no need to check symbol properties. */
d596 1
a596 1
	  /* since "know" puts its arg into a "string", we
d635 2
a636 2
	  input_line_pointer--;	/* restore following character. */
	}			/* really just a number */
d642 2
a643 2
      expressionP->X_add_number = number;	/* number of littlenums */
      input_line_pointer--;	/*->char following number. */
d761 6
a766 10
/*
 * Summary of operand().
 *
 * in:	Input_line_pointer points to 1st char of operand, which may
 *	be a space.
 *
 * out:	A expressionS.
 *	The operand may have been empty: in this case X_op == O_absent.
 *	Input_line_pointer->(next non-blank) char after operand.
 */
d773 2
a774 2
  symbolS *symbolP;	/* points to symbol */
  char *name;		/* points to name of symbol */
d785 1
a785 1
  /* digits, assume it is a bignum. */
d787 2
a788 2
  SKIP_WHITESPACE ();		/* leading whitespace is part of operand. */
  c = *input_line_pointer++;	/* input_line_pointer->past char in c. */
d807 1
a807 1
                        ? 0 : 10,
d824 1
a824 1
      /* non-decimal radix */
d839 1
a839 1
        }
d862 1
a862 1
		- (isupper ((unsigned char) c) ? tolower (c) : c);
d866 1
a866 1
	      /* The string was only zero */
d918 2
a919 2
                            ? 0 : 8, 
                            expressionP);
d941 1
a941 1
		      /* looks like a difference expression */
d945 1
a945 1
                         end of operand. */
d964 1
a964 1
	      /* fall through */
d985 1
a985 1
	    - (isupper ((unsigned char) c) ? tolower (c) : c);
d1004 1
a1004 1
      /* didn't begin with digit & not a name */
d1006 1
a1006 1
      /* Expression() will pass trailing whitespace */
d1016 1
a1016 1
        input_line_pointer++;
d1018 1
a1018 1
      /* here with input_line_pointer->char after "(...)" */
d1037 1
a1037 1
	     ESCAPEMENT is permitted for a single quote. The next
d1039 1
a1039 1
	     of the operand. VERY KINKY.  */
d1060 1
a1060 1
      /* ~ is permitted to start a label on the Delta.  */
d1069 1
a1069 1
	    /* input_line_pointer -> char after operand */
d1072 4
a1075 3
		expressionP->X_add_number = - expressionP->X_add_number;
		/* Notice: '-' may overflow: no warning is given. This is
		   compatible with other people's assemblers. Sigh.  */
d1103 2
a1104 2
      /* $ is the program counter when in MRI mode, or when DOLLAR_DOT
         is defined.  */
d1111 1
a1111 1
	  /* In MRI mode, $ is also used as the prefix for a
d1180 1
a1180 1
      /* can't imagine any other kind of operand */
d1221 1
a1221 1
      if (is_name_beginner (c))	/* here if did not begin with a digit */
d1223 2
a1224 4
	  /*
	   * Identifier begins here.
	   * This is kludged for speed, so code is repeated.
	   */
d1277 1
a1277 1
	    }	      
d1323 2
a1324 4
  /*
   * It is more 'efficient' to clean up the expressionS when they are created.
   * Doing it here saves lines of code.
   */
d1326 1
a1326 1
  SKIP_WHITESPACE ();		/*->1st char after operand. */
d1342 1
a1342 1
}				/* operand() */
d1344 1
a1344 1
/* Internal. Simplify a struct expression for use by expr() */
d1346 8
a1353 9
/*
 * In:	address of a expressionS.
 *	The X_op field of the expressionS may only take certain values.
 *	Elsewise we waste time special-case testing. Sigh. Ditto SEG_ABSENT.
 * Out:	expressionS may have been modified:
 *	'foo-foo' symbol references cancelled to 0,
 *		which changes X_op from O_subtract to O_constant.
 *	Unused fields zeroed to help expr().
 */
d1397 17
a1413 1
/* Expression parser. */
d1415 2
a1416 20
/*
 * We allow an empty expression, and just assume (absolute,0) silently.
 * Unary operators and parenthetical expressions are treated as operands.
 * As usual, Q==quantity==operand, O==operator, X==expression mnemonics.
 *
 * We used to do a aho/ullman shift-reduce parser, but the logic got so
 * warped that I flushed it and wrote a recursive-descent parser instead.
 * Now things are stable, would anybody like to write a fast parser?
 * Most expressions are either register (which does not even reach here)
 * or 1 symbol. Then "symbol+constant" and "symbol-symbol" are common.
 * So I guess it doesn't really matter how inefficient more complex expressions
 * are parsed.
 *
 * After expr(RANK,resultP) input_line_pointer->operator of rank <= RANK.
 * Also, we have consumed any leading or trailing spaces (operand does that)
 * and done all intervening operators.
 *
 * This returns the segment of the result, which will be
 * absolute_section or the segment of a symbol.
 */
d1422 1
a1422 1
{				/* maps ASCII->operators */
d1456 11
a1466 13

/*
 *	Rank	Examples
 *	0	operand, (expression)
 *	1	||
 *	2	&&
 *	3	= <> < <= >= >
 *	4	+ -
 *	5	used for * / % in MRI mode
 *	6	& ^ ! |
 *	7	* / % << >>
 *	8	unary - unary ~
 */
d1644 1
a1644 1
  /*NOTREACHED*/
d1651 2
a1652 2
     int rankarg;	/* Larger # is higher rank. */
     expressionS *resultP;	/* Deliver result here. */
d1664 2
a1665 1
  know (*input_line_pointer != ' ');	/* Operand() gobbles spaces. */
d1672 1
a1672 1
      input_line_pointer++;	/*->after 1st character of operator. */
d1714 2
a1715 1
      know (op_right == O_illegal || op_rank[(int) op_right] <= op_rank[(int) op_left]);
d1719 4
a1722 4
      /* input_line_pointer->after right-hand quantity. */
      /* left-hand quantity in resultP */
      /* right-hand quantity in right. */
      /* operator in op_left. */
d1751 2
a1752 1
	  /* skip */;
d1820 1
a1820 1
		resultP->X_add_number == v ? ~ (offsetT) 0 : 0;
d1824 1
a1824 1
		resultP->X_add_number != v ? ~ (offsetT) 0 : 0;
d1828 1
a1828 1
		resultP->X_add_number <  v ? ~ (offsetT) 0 : 0;
d1832 1
a1832 1
		resultP->X_add_number <= v ? ~ (offsetT) 0 : 0;
d1836 1
a1836 1
		resultP->X_add_number >= v ? ~ (offsetT) 0 : 0;
d1840 1
a1840 1
		resultP->X_add_number >  v ? ~ (offsetT) 0 : 0;
d1876 1
a1876 1
    }				/* While next operator is >= this rank. */
d1885 12
a1896 15
/*
 *			get_symbol_end()
 *
 * This lives here because it belongs equally in expr.c & read.c.
 * Expr.c is just a branch office read.c anyway, and putting it
 * here lessens the crowd at read.c.
 *
 * Assume input_line_pointer is at start of symbol name.
 * Advance input_line_pointer past symbol name.
 * Turn that character into a '\0', returning its former value.
 * This allows a string compare (RMS wants symbol names to be strings)
 * of the symbol name.
 * There will always be a char following symbol name, because all good
 * lines end in end-of-line.
 */
a1915 1

a1921 1

a1922 2

/* end of expr.c */
@


1.19
log
@* $literal support

2000-06-23  Frank Ch. Eigler  <fche@@redhat.com>

	* expr.c (operand): Permit $hex literals if LITERAL_PREFIXDOLLAR_HEX
	is defined.
@
text
@d829 6
@


1.18
log
@(operand): Do not as_bad() if RELAX_PAREN_GROUPING is
defined.  Fix error message and double increment of
input_line_pointer for `[' grouping.
@
text
@d823 6
@


1.17
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d1007 2
a1008 2
      if ((c == '(' && *input_line_pointer++ != ')')
	  || (c == '[' && *input_line_pointer++ != ']'))
d1010 4
a1013 2
	  as_bad (_("Missing ')' assumed"));
	  input_line_pointer--;
d1015 2
@


1.16
log
@is_end_of_line fixes.
@
text
@d544 2
a545 2
  if ((NUMBERS_WITH_SUFFIX || flag_m68k_mri) 
      && suffix != NULL 
d818 1
a818 1
      integer_constant ((NUMBERS_WITH_SUFFIX || flag_m68k_mri) 
@


1.15
log
@IA-64 ELF support.
@
text
@d802 3
d1172 1
a1173 2
    case '\n':
    case '\0':
a1215 2
      if (is_end_of_line[(unsigned char) c])
	goto eol;
d1573 3
@


1.14
log
@	* expr.c (operand) [case 'f']: When testing if '0f' can start a
	floating-point-number, make sure 'f' is in FLT_CHARS.
@
text
@d1747 7
@


1.13
log
@Remove dead code when not TC_M68K.
@
text
@d926 2
a927 1
		  || (is_end_of_line[0xff & input_line_pointer[1]]))
@


1.12
log
@NUMBERS_WITH_SUFFIX *doesn't* want to handle 'x', since that is valid
when the 0x prefix is used.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d1013 1
d1024 1
d1044 1
d1050 1
d1092 1
d1113 1
d1177 1
d1207 1
d1210 1
d1212 1
@


1.11
log
@Remove redundant code for checking numbers with suffixes.  Add
functionality to break out of assembler loops.
@
text
@d872 1
a872 1
	  if (flag_m68k_mri || NUMBERS_WITH_SUFFIX)
@


1.10
log
@Add handling for numbers with suffixed radix.
@
text
@a835 19
          if (NUMBERS_WITH_SUFFIX)
            {
              /* Check for a binary constant.  */
              for (s = input_line_pointer; *s == '0' || *s == '1'; s++)
                ;
              if (toupper (*s) == 'B')
                {
                  integer_constant (0, expressionP);
                  break;
                }
              /* Check for an octal constant.  */
              for (s = input_line_pointer; *s >= '0' && *s <= '7'; s++)
                ;
              if (toupper (*s) == 'Q')
                {
                  integer_constant (0, expressionP);
                  break;
                }
            }
d872 1
a872 1
	  if (flag_m68k_mri)
d879 1
a879 1
	  if (LOCAL_LABELS_FB && ! flag_m68k_mri && ! NUMBERS_WITH_SUFFIX)
d901 1
a901 1
	  if (flag_m68k_mri)
d914 3
a916 1
	  integer_constant (flag_m68k_mri ? 0 : 8, expressionP);
d966 1
a966 1
	  if (flag_m68k_mri)
@


1.9
log
@Add more md operators
@
text
@d330 1
a330 1
  if (flag_m68k_mri && radix == 0)
d544 3
a546 1
  if (flag_m68k_mri && suffix != NULL && input_line_pointer - 1 == suffix)
d815 3
a817 1
      integer_constant (flag_m68k_mri ? 0 : 10, expressionP);
d823 1
a823 1
      if (flag_m68k_mri)
d836 20
a855 2
	}

d865 1
a865 1
	  if (flag_m68k_mri)
d898 1
a898 1
	  if (LOCAL_LABELS_FB && ! flag_m68k_mri)
@


1.8
log
@Add md expression support; Cleanup alpha warnings
@
text
@d1495 8
@


1.7
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* expr.c (expr): Change first parameter to int.
	* config/obj-coff.c: Add declarations for static functions.
	(coff_frob_symbol): Use SYM_AUXENT.
	* config/tc-i386.h (flag_16bit_code): Don't declare.
@
text
@d1487 8
@


1.6
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* expr.c (integer_constant): Correct too_many_digits calculation
	in base 10 case.
@
text
@d1619 2
a1620 2
expr (rank, resultP)
     operator_rankT rank;	/* Larger # is higher rank. */
d1623 1
@


1.5
log
@        * dwarf2dbg.c (*): Convert to K&R + prototypes.
        (dwarf2_gen_line_info): Kill unused variables.
        (dwarf2_finish): Likewise.
        (dwarf2_where): Likewise.
        (dwarf2_directive_file): If we've only got a string,
        hand off to s_app_file.
        * ecoff.c: Move the include of ecoff.h.
        * symbols.h (S_IS_FUNCTION): Prototype.
        * read.c (LEX_HASH): Supply a default.
        (lex_type): Use it.
        (s_globl): Update `c' after skipping whitespace.
        * read.h (LEX_END_NAME, is_name_ender): New.
        * expr.c (get_symbol_end): Respect it.
@
text
@d392 1
a392 1
      too_many_digits = (valuesize + 12) / 4; /* very rough */
@


1.4
log
@        * expr.c (operand): Don't use [ for parens if we want an index op.
        (op_encoding): Switch [ into O_index, if desired.
        (op_rank): Renumber with O_index on bottom.
        (expr): If O_index, match closing bracket.
        * expr.h (O_index): New.
@
text
@d1866 7
a1872 3
    while (is_part_of_name (c = *input_line_pointer++)
	   || c == '\001')
      ;
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d992 1
d994 1
d1420 7
a1426 1
  __, __, __, __, __, __, O_bit_exclusive_or, __,
d1464 23
a1486 22
  8,	/* O_uminus */
  8,	/* O_bit_not */
  8,	/* O_logical_not */
  7,	/* O_multiply */
  7,	/* O_divide */
  7,	/* O_modulus */
  7,	/* O_left_shift */
  7,	/* O_right_shift */
  6,	/* O_bit_inclusive_or */
  6,	/* O_bit_or_not */
  6,	/* O_bit_exclusive_or */
  6,	/* O_bit_and */
  4,	/* O_add */
  4,	/* O_subtract */
  3,	/* O_eq */
  3,	/* O_ne */
  3,	/* O_lt */
  3,	/* O_le */
  3,	/* O_ge */
  3,	/* O_gt */
  2,	/* O_logical_and */
  1	/* O_logical_or */
d1652 11
@


1.2
log
@/
Move bitfield overflow checks to after the md_apply_fix call in
fixup_segment so that md_apply_fix has a chance to modify value.
Handle 8 and 16-bit pcrel relocs for i386.
Prototypes and other minor code cleanups.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 1998
d107 1
a107 1
  symbolP->sy_value = *expressionP;
d1312 1
a1312 1
    expressionP->X_add_symbol->sy_used = 1;
d1359 2
a1360 2
	  || ((expressionP->X_op_symbol->sy_frag
	       == expressionP->X_add_symbol->sy_frag)
d1703 2
a1704 2
	       && (right.X_add_symbol->sy_frag
		   == resultP->X_add_symbol->sy_frag)
d1818 1
a1818 1
    resultP->X_add_symbol->sy_used = 1;
@


1.1
log
@Initial revision
@
text
@d37 4
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

