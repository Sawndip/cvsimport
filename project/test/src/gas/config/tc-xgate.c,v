head	1.11;
access;
symbols
	binutils-2_24-branch:1.10.0.2
	binutils-2_24-branchpoint:1.10
	binutils-2_23_2:1.5.2.1
	binutils-2_23_1:1.5.2.1
	binutils-2_23:1.5.2.1
	binutils-2_23-branch:1.5.0.2
	binutils-2_23-branchpoint:1.5
	binutils_latest_snapshot:1.11;
locks; strict;
comment	@ * @;


1.11
date	2013.10.11.04.55.42;	author seank;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.11.21.12.34;	author seank;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.10.22.15.05;	author seank;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.06.10.03.32;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.06.00.49.37;	author seank;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.27.22.33.22;	author seank;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.05.19.37.52;	author seank;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2012.06.28.21.36.35;	author seank;	state Exp;
branches;
next	1.3;

1.3
date	2012.05.31.22.10.53;	author seank;	state Exp;
branches;
next	1.2;

1.2
date	2012.05.15.18.34.23;	author seank;	state Exp;
branches;
next	1.1;

1.1
date	2012.05.03.13.11.59;	author nickc;	state Exp;
branches;
next	;

1.5.2.1
date	2012.08.06.19.32.49;	author seank;	state Exp;
branches;
next	;


desc
@@


1.11
log
@     * Removed short_hand field from opcode table and
     refactored assembler/disassember accordingly.
     Testsuite checkout OK.
@
text
@/* tc-xgate.c -- Assembler code for Freescale XGATE
   Copyright 2010, 2011, 2012
   Free Software Foundation, Inc.
   Contributed by Sean Keys <skeys@@ipdatasys.com>

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/xgate.h"
#include "dwarf2dbg.h"
#include "elf/xgate.h"

const char comment_chars[] = ";!";
const char line_comment_chars[] = "#*";
const char line_separator_chars[] = "";
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "dD";

/* Max opcodes per opcode handle.  */
#define MAX_OPCODES     0x05

#define SIXTEENTH_BIT		0x8000
#define N_BITS_IN_WORD		16
#define MAX_NUM_OPERANDS	3

/* #define STATE_CONDITIONAL_BRANCH		(1) */
#define STATE_PC_RELATIVE	(2)
#define REGISTER_P(ptr)		(ptr == 'r')
#define INCREMENT		01
#define DECREMENT		02
#define MAXREGISTER		07
#define MINREGISTER		00

#define OPTION_MMCU 'm'

/* This macro has no side-effects.  */
#define ENCODE_RELAX(what,length) (((what) << 2) + (length))

/* Each unique opcode name has a handle.  That handle may
   contain pointers to opcodes with the same name but
   different address modes.  */
struct xgate_opcode_handle
{
  int number_of_modes;
  char *name;
  struct xgate_opcode *opc0[MAX_OPCODES];
};

/* XGATE's registers all are 16-bit general purpose.
   They are numbered according to the specifications.  */
typedef enum register_id
{
  REG_NONE = -1,
  REG_R0 = 0,
  REG_R1 = 1,
  REG_R2 = 2,
  REG_R3 = 3,
  REG_R4 = 4,
  REG_R5 = 5,
  REG_R6 = 6,
  REG_R7 = 7,
  REG_PC = 8,
  REG_CCR = 9
} register_id;

/* Operand Modifiers */
typedef enum op_modifiers
{
  MOD_NONE = -1,
  MOD_POSTINC = 1,
  MOD_PREDEC = 2,
  MOD_CONSTANT = 3,
  MOD_LOAD_HIGH = 4,
  MOD_LOAD_LOW = 5
}op_modifiers;

typedef struct s_operand
{
  expressionS exp;
  register_id reg;
  op_modifiers mod;
} s_operand;


/* Forward declarations.  */
static inline char *skip_whitespace (char *);
static void get_default_target (void);
static char *extract_word (char *, char *, int);
static struct xgate_opcode *xgate_find_match (struct xgate_opcode_handle *,
					      int, s_operand [], unsigned int);
static int cmp_opcode (struct xgate_opcode *, struct xgate_opcode *);
static void xgate_print_table (void);
static unsigned int xgate_get_operands (char *, s_operand []);
static register_id reg_name_search (char *);
static op_modifiers xgate_determine_modifiers(char **);
static void xgate_scan_operands (struct xgate_opcode *opcode, s_operand []);
static unsigned int xgate_parse_operand (struct xgate_opcode *, int *, int,
					 char **, s_operand);

static struct hash_control *xgate_hash;

/* Previous opcode.  */
static unsigned int prev = 0;

static unsigned char fixup_required = 0;

/* Used to enable clipping of 16 bit operands into 8 bit constraints.  */
static unsigned char autoHiLo = 0;

static char oper_check;
static char flag_print_insn_syntax = 0;
static char flag_print_opcodes = 0;

static int current_architecture;
static const char *default_cpu;

/* ELF flags to set in the output file header.  */
static int elf_flags = E_XGATE_F64;

/* This table describes how you change sizes for the various types of variable
   size expressions.  This version only supports two kinds.  */

/* The fields are:
   How far Forward this mode will reach.
   How far Backward this mode will reach.
   How many bytes this mode will add to the size of the frag.
   Which mode to go to if the offset won't fit in this one.  */

relax_typeS md_relax_table[] =
{
  {1, 1, 0, 0},			/* First entries aren't used.  */
  {1, 1, 0, 0},			/* For no good reason except.  */
  {1, 1, 0, 0},			/* that the VAX doesn't either.  */
  {1, 1, 0, 0},
  /* XGATE 9 and 10 bit pc rel todo complete and test */
/*{(511), (-512), 0, ENCODE_RELAX (STATE_PC_RELATIVE, STATE_WORD)},
  {(1023), (-1024), 0, ENCODE_RELAX (STATE_PC_RELATIVE, STATE_WORD)}, */
  {0, 0, 0, 0}
};

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are: pseudo-op name without dot function to
   call to execute this pseudo-op Integer arg to pass to the function.  */
const pseudo_typeS md_pseudo_table[] =
{
  /* The following pseudo-ops are supported for MRI compatibility.  */
  {0, 0, 0}
};

const char *md_shortopts = "m:";

struct option md_longopts[] =
{
#define OPTION_PRINT_INSN_SYNTAX  (OPTION_MD_BASE + 0)
  { "print-insn-syntax", no_argument, NULL, OPTION_PRINT_INSN_SYNTAX },

#define OPTION_PRINT_OPCODES  (OPTION_MD_BASE + 1)
  { "print-opcodes", no_argument, NULL, OPTION_PRINT_OPCODES },

#define OPTION_GENERATE_EXAMPLE  (OPTION_MD_BASE + 2)
  { "generate-example", no_argument, NULL, OPTION_GENERATE_EXAMPLE },

#define OPTION_MSHORT  (OPTION_MD_BASE + 3)
  { "mshort", no_argument, NULL, OPTION_MSHORT },

#define OPTION_MLONG  (OPTION_MD_BASE + 4)
  { "mlong", no_argument, NULL, OPTION_MLONG },

#define OPTION_MSHORT_DOUBLE  (OPTION_MD_BASE + 5)
  { "mshort-double", no_argument, NULL, OPTION_MSHORT_DOUBLE },

#define OPTION_MLONG_DOUBLE  (OPTION_MD_BASE + 6)
  { "mlong-double", no_argument, NULL, OPTION_MLONG_DOUBLE },

  { NULL, no_argument, NULL, 0 }
};

size_t md_longopts_size = sizeof(md_longopts);

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case OPTION_MMCU:
      if (strcasecmp (arg, "v1") == 0)
	current_architecture = XGATE_V1;
      else if (strcasecmp (arg, "v2") == 0)
	current_architecture = XGATE_V2;
      else if (strcasecmp (arg, "v3") == 0)
	current_architecture = XGATE_V3;
      else
	as_bad (_(" architecture variant invalid"));
      break;

    case OPTION_PRINT_INSN_SYNTAX:
      flag_print_insn_syntax = 1;
      break;

    case OPTION_PRINT_OPCODES:
      flag_print_opcodes = 1;
      break;

    case OPTION_GENERATE_EXAMPLE:
      flag_print_opcodes = 2;
      break;

    case OPTION_MSHORT:
      elf_flags &= ~E_XGATE_I32;
      break;

    case OPTION_MLONG:
      elf_flags |= E_XGATE_I32;
      break;

    case OPTION_MSHORT_DOUBLE:
      elf_flags &= ~E_XGATE_F64;
      break;

    case OPTION_MLONG_DOUBLE:
      elf_flags |= E_XGATE_F64;
      break;

    default:
      return 0;
    }
  return 1;
}

const char *
xgate_arch_format (void)
{
  get_default_target ();

  if (current_architecture & cpuxgate)
    return "elf32-xgate";

  return "error";
}

static void
get_default_target (void)
{
  const bfd_target *target;
  bfd abfd;

  if (current_architecture != 0)
    return;

  default_cpu = "unknown";
  target = bfd_find_target (0, &abfd);

  if (target && target->name)
    {
      if (strcmp (target->name, "elf32-xgate") == 0)
	{
	  current_architecture = cpuxgate;
	  default_cpu = "XGATE V1";
	  return;
	}

      as_bad (_("Default target `%s' is not supported."), target->name);
    }
}

void
md_begin (void)
{
  struct xgate_opcode *xgate_opcode_ptr = NULL;
  struct xgate_opcode *xgate_op_table = NULL;
  struct xgate_opcode_handle *op_handles = 0;
  char *prev_op_name = 0;
  int handle_enum = 0;
  int number_of_op_handles = 0;
  int i, j = 0;

  /* Create a local copy of our opcode table
     including an extra line for NULL termination.  */
  xgate_op_table = (struct xgate_opcode *)
    xmalloc ((xgate_num_opcodes) * sizeof (struct xgate_opcode));

  memset (xgate_op_table, 0,
	  sizeof(struct xgate_opcode) * (xgate_num_opcodes));

  for (xgate_opcode_ptr = (struct xgate_opcode*) xgate_opcodes, i = 0;
       i < xgate_num_opcodes; i++)
    xgate_op_table[i] = xgate_opcode_ptr[i];

  qsort (xgate_op_table, xgate_num_opcodes, sizeof(struct xgate_opcode),
	 (int (*)(const void *, const void *)) cmp_opcode);

  /* Calculate number of handles since this will be
     smaller than the raw number of opcodes in the table.  */
  prev_op_name = "";
  for (xgate_opcode_ptr = xgate_op_table, i = 0;  i < xgate_num_opcodes;
       xgate_opcode_ptr++, i++)
    {
      if (strcmp (prev_op_name, xgate_opcode_ptr->name))
	number_of_op_handles++;
      prev_op_name = xgate_opcode_ptr->name;
    }

  op_handles = (struct xgate_opcode_handle *)
    xmalloc (sizeof(struct xgate_opcode_handle) * (number_of_op_handles));

  /* Insert unique opcode names into hash table, aliasing duplicates.  */
  xgate_hash = hash_new ();

  prev_op_name = "";
  for (xgate_opcode_ptr = xgate_op_table, i = 0, j = 0; i < xgate_num_opcodes;
       i++, xgate_opcode_ptr++)
    {
      if (!strcmp (prev_op_name, xgate_opcode_ptr->name))
	{
	  handle_enum++;
	  op_handles[j].opc0[handle_enum] = xgate_opcode_ptr;
	}
      else
	{
	  handle_enum = 0;
	  if (i)
	    j++;
	  op_handles[j].name = xgate_opcode_ptr->name;
	  op_handles[j].opc0[0] = xgate_opcode_ptr;
	  hash_insert (xgate_hash, (char *) op_handles[j].name,
		       (char *) &(op_handles[j]));
	}
      op_handles[j].number_of_modes = handle_enum;
      prev_op_name = op_handles[j].name;
    }

  if (flag_print_opcodes)
    {
      xgate_print_table ();
      exit (EXIT_SUCCESS);
    }
}

void
xgate_init_after_args (void)
{
}

void
md_show_usage (FILE * stream)
{
  get_default_target ();

  fprintf (stream,
	   _("\
Freescale XGATE co-processor options:\n\
  -mshort                 use 16-bit int ABI (default)\n\
  -mlong                  use 32-bit int ABI\n\
  -mshort-double          use 32-bit double ABI\n\
  -mlong-double           use 64-bit double ABI (default)\n\
  --mxgate                specify the processor variant[default %s]\n\
  --print-insn-syntax     print the syntax of instruction in case of error\n\
  --print-opcodes         print the list of instructions with syntax\n\
  --generate-example      generate an example of each instruction"),
	   default_cpu);
}

enum bfd_architecture
xgate_arch (void)
{
  get_default_target ();
  return bfd_arch_xgate;
}

int
xgate_mach (void)
{
  return 0;
}

static void
xgate_print_syntax (char *name)
{
  int i;

  for (i = 0; i < xgate_num_opcodes; i++)
    {
      if (!strcmp (xgate_opcodes[i].name, name))
	{
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IDR))
	    printf ("\tFormat is %s\tRx, Rx, Rx+|-Rx|Rx\n",
		    xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_INH))
	    printf ("\tFormat is %s\n", xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_TRI))
	    printf ("\tFormat is %s\tRx, Rx, Rx\n", xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_DYA))
	    printf ("\tFormat is %s\tRx, Rx\n", xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM3))
	    printf ("\tFormat is %s\t<3-bit value>\n", xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM4))
	    printf ("\tFormat is %s\t<4 -bit value>\n", xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM8))
	    printf ("\tFormat is %s\tRx, <8-bit value>\n",
		    xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM16))
	    printf ("\tFormat is %s\tRx, <16-bit value>\n",
		    xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_MON_R_C))
	    printf ("\tFormat is %s\tRx, CCR\n", xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_MON_C_R))
	    printf ("\tFormat is %s\tCCR, Rx\n", xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_MON_R_P))
	    printf ("\tFormat is %s\tRx, PC\n", xgate_opcodes[i].name);
	  if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM16mLDW))
	    printf ("\tFormat is %s\tRx, <16-bit value>\n",
		    xgate_opcodes[i].name);
	}
    }
}

static void
xgate_print_table (void)
{
  int i;

  for (i = 0; i < xgate_num_opcodes; i++)
    xgate_print_syntax (xgate_opcodes[i].name);

  return;
}

const char *
xgate_listing_header (void)
{
  if (current_architecture & cpuxgate)
    return "XGATE GAS ";

  return "ERROR MC9S12X GAS ";
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* GAS will call this function for each section at the end of the assembly,
   to permit the CPU backend to adjust the alignment of a section.  */

valueT
md_section_align (asection * seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_assemble (char *input_line)
{
  struct xgate_opcode *opcode = 0;
  struct xgate_opcode *macro_opcode = 0;
  struct xgate_opcode_handle *opcode_handle = 0;
  /* Caller expects it to be returned as it was passed.  */
  char *saved_input_line = input_line;
  char op_name[9] =  { 0 };
  unsigned int operandCount = 0;
  char *p = 0;

  s_operand new_operands[MAX_NUM_OPERANDS];

  fixup_required = 0;
  oper_check = 0; /* set error flags */
  input_line = extract_word (input_line, op_name, sizeof(op_name));

  /* Check to make sure we are not reading a bogus line.  */
  if (!op_name[0])
    as_bad (_("opcode missing or not found on input line"));

  if (!(opcode_handle = (struct xgate_opcode_handle *) hash_find (xgate_hash,
								  op_name)))
    {
      as_bad (_("opcode %s not found in opcode hash table"), op_name);
    }
  else
    {
      /* Parse operands so we can find the proper opcode bin.  */

      operandCount = xgate_get_operands (input_line, new_operands);

      opcode = xgate_find_match (opcode_handle, opcode_handle->number_of_modes,
				 new_operands, operandCount);

      if (!opcode)
	{
	  as_bad (_("matching operands to opcode "));
	  xgate_print_syntax (opcode_handle->opc0[0]->name);
	}
      else if (opcode->size == 2)
	{
	  /* Size is one word - assemble that native insn.  */
	  xgate_scan_operands (opcode, new_operands);
	}
      else
	{
	  /* Insn is a simplified instruction - expand it out.  */
	  autoHiLo = 1;
	  unsigned int i;

	  /* skip past our ';' separator.  */
	  for (i = strlen (opcode->constraints), p = opcode->constraints; i > 0;
	       i--, p++)
	    {
	      if (*p == ';')
		{
		  p++;
		  break;
		}
	    }
	  input_line = skip_whitespace (input_line);
	  char *macro_inline = input_line;

	  /* Loop though the macro's opcode list and apply operands to
	     each real opcode. */
	  for (i = 0; *p && i < (opcode->size / 2); i++)
	    {
	      /* Loop though macro operand list.  */
	      input_line = macro_inline; /* Rewind.  */
	      p = extract_word (p, op_name, 10);

	      if (!(opcode_handle = (struct xgate_opcode_handle *)
		    hash_find (xgate_hash, op_name)))
		{
		  as_bad (_(": processing macro, real opcode handle"
			    " not found in hash"));
		  break;
		}
	      else
		{
		  operandCount = xgate_get_operands(input_line, new_operands);
		  macro_opcode = xgate_find_match (opcode_handle,
						   opcode_handle->number_of_modes, new_operands,
					       operandCount);
		  xgate_scan_operands (macro_opcode, new_operands);
		}
	    }
	}
    }
  autoHiLo = 0;
  input_line = saved_input_line;
}

/* Force truly undefined symbols to their maximum size, and generally set up
   the frag list to be relaxed.  */

int
md_estimate_size_before_relax (fragS *fragp, asection *seg)
{
  /* If symbol is undefined or located in a different section,
     select the largest supported relocation.  */
  relax_substateT subtype;
  relax_substateT rlx_state[] = { 0, 2 };

  for (subtype = 0; subtype < ARRAY_SIZE (rlx_state); subtype += 2)
    {
      if (fragp->fr_subtype == rlx_state[subtype]
	  && (!S_IS_DEFINED (fragp->fr_symbol)
	      || seg != S_GET_SEGMENT (fragp->fr_symbol)))
	{
	  fragp->fr_subtype = rlx_state[subtype + 1];
	  break;
	}
    }

  if (fragp->fr_subtype >= ARRAY_SIZE (md_relax_table))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
}


/* Relocation, relaxation and frag conversions.  */

/* PC-relative offsets are relative to the start of the
   next instruction.  That is, the address of the offset, plus its
   size, since the offset is always the last part of the insn.  */

long
md_pcrel_from (fixS * fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

/* If while processing a fixup, a reloc really needs to be created
   then it is done here.  */

arelent *
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED, fixS * fixp)
{
  arelent * reloc;

  reloc = (arelent *) xmalloc (sizeof(arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof(asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  if (fixp->fx_r_type == 0)
    reloc->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_16);
  else
    reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line, _
		    ("Relocation %d is not supported by object file format."),
		    (int) fixp->fx_r_type);
      return NULL;
    }

  /* Since we use Rel instead of Rela, encode the vtable entry to be
     used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;
  reloc->addend = 0;
  return reloc;
}

/* Patch the instruction with the resolved operand.  Elf relocation
   info will also be generated to take care of linker/loader fixups.
   The XGATE addresses only 16-bit addresses.The BFD_RELOC_32 is necessary
   for the support of --gstabs.  */

void
md_apply_fix (fixS * fixP, valueT * valP, segT seg ATTRIBUTE_UNUSED)
{
  char *where;
  long value = *valP;
  int opcode = 0;
  ldiv_t result;

  /* If the fixup is done mark it done so no further symbol resolution
     will take place.  */
  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  /* We don't actually support subtracting a symbol.  */
  if (fixP->fx_subsy != (symbolS *) NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("Expression too complex."));

  where = fixP->fx_frag->fr_literal + fixP->fx_where;
  opcode = bfd_getl16 (where);
  int mask = 0;

  switch (fixP->fx_r_type)
    {
    case R_XGATE_PCREL_9:
      if (value < -512 || value > 511)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value %ld too large for 9-bit PC-relative branch."),
		      value);
      result = ldiv (value, 2); /* from bytes to words */
      value = result.quot;
      if (result.rem)
	as_bad_where (fixP->fx_file, fixP->fx_line, _
		      ("Value %ld not aligned by 2 for 9-bit"
		       " PC-relative branch."), value);
      /* Clip into 8-bit field.
	 FIXME I'm sure there is a more proper place for this.  */
      mask = 0x1FF;
      value &= mask;
      number_to_chars_bigendian (where, (opcode | value), 2);
      break;
    case R_XGATE_PCREL_10:
      if (value < -1024 || value > 1023)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value %ld too large for 10-bit PC-relative branch."),
		      value);
      result = ldiv (value, 2); /* from bytes to words */
      value = result.quot;
      if (result.rem)
	as_bad_where (fixP->fx_file, fixP->fx_line, _
		      ("Value %ld not aligned by 2 for 10-bit"
		       " PC-relative branch."), value);
      /* Clip into 9-bit field.
	 FIXME I'm sure there is a more proper place for this.  */
      mask = 0x3FF;
      value &= mask;
      number_to_chars_bigendian (where, (opcode | value), 2);
      break;
    case BFD_RELOC_XGATE_IMM8_HI:
      if (value < -65537 || value > 65535)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value out of 16-bit range."));
      value >>= 8;
      value &= 0x00ff;
      bfd_putb16 ((bfd_vma) value | opcode, (void *) where);
      break;
    case BFD_RELOC_XGATE_24:
    case BFD_RELOC_XGATE_IMM8_LO:
      if (value < -65537 || value > 65535)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value out of 16-bit range."));
      value &= 0x00ff;
      bfd_putb16 ((bfd_vma) value | opcode, (void *) where);
      break;
    case BFD_RELOC_XGATE_IMM3:
      if (value < 0 || value > 7)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value out of 3-bit range."));
      value <<= 8; /* make big endian */
      number_to_chars_bigendian (where, (opcode | value), 2);
      break;
    case BFD_RELOC_XGATE_IMM4:
      if (value < 0 || value > 15)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value out of 4-bit range."));
      value <<= 4; /* align the operand bits */
      number_to_chars_bigendian (where, (opcode | value), 2);
      break;
    case BFD_RELOC_XGATE_IMM5:
      if (value < 0 || value > 31)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Value out of 5-bit range."));
      value <<= 5; /* align the operand bits */
      number_to_chars_bigendian (where, (opcode | value), 2);
      break;
    case BFD_RELOC_8:
      ((bfd_byte *) where)[0] = (bfd_byte) value;
      break;
    case BFD_RELOC_32:
      bfd_putb32 ((bfd_vma) value, (unsigned char *) where);
      break;
    case BFD_RELOC_16:
      bfd_putb16 ((bfd_vma) value, (unsigned char *) where);
      break;
    default:
      as_fatal (_("Line %d: unknown relocation type: 0x%x."), fixP->fx_line,
		fixP->fx_r_type);
      break;
    }
}

/* See whether we need to force a relocation into the output file.  */

int
tc_xgate_force_relocation (fixS * fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_XGATE_RL_GROUP)
    return 1;
  return generic_force_reloc (fixP);
}

/* Here we decide which fixups can be adjusted to make them relative
   to the beginning of the section instead of the symbol.  Basically
   we need to make sure that the linker relaxation is done
   correctly, so in some cases we force the original symbol to be
   used.  */

int
tc_xgate_fix_adjustable (fixS * fixP)
{
  switch (fixP->fx_r_type)
    {
      /* For the linker relaxation to work correctly, these relocs
	 need to be on the symbol itself.  */
    case BFD_RELOC_16:
    case BFD_RELOC_XGATE_RL_JUMP:
    case BFD_RELOC_XGATE_RL_GROUP:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_32:
      return 0;
    default:
      return 1;
    }
}

void
md_convert_frag (bfd * abfd ATTRIBUTE_UNUSED,
		 asection * sec ATTRIBUTE_UNUSED,
		 fragS * fragP ATTRIBUTE_UNUSED)
{
  as_bad (("md_convert_frag not implemented yet"));
  abort ();
}

/* Set the ELF specific flags.  */

void
xgate_elf_final_processing (void)
{
  elf_flags |= EF_XGATE_MACH;
  elf_elfheader (stdoutput)->e_flags &= ~EF_XGATE_ABI;
  elf_elfheader (stdoutput)->e_flags |= elf_flags;
}

static inline char *
skip_whitespace (char *s)
{
  while (*s == ' ' || *s == '\t' || *s == '(' || *s == ')')
    s++;

  return s;
}

/* Extract a word (continuous alpha-numeric chars) from the input line.  */

static char *
extract_word (char *from, char *to, int limit)
{
  char *op_end;
  int size = 0;

  /* Drop leading whitespace.  */
  from = skip_whitespace (from);
  *to = 0;
  /* Find the op code end.  */
  for (op_end = from; *op_end != 0 && is_part_of_name (*op_end);)
    {
      to[size++] = *op_end++;
      if (size + 1 >= limit)
	break;
    }
  to[size] = 0;
  return op_end;
}

static char *
xgate_new_instruction (int size)
{
  char *f = frag_more (size);
  dwarf2_emit_insn (size);
  return f;
}

static unsigned short
xgate_apply_operand (unsigned short new_mask,
		     unsigned short *availiable_mask_bits,
		     unsigned short mask,
		     unsigned char n_bits)
{
  unsigned short n_shifts;
  unsigned int n_drop_bits;

  /* Shift until you find an available operand bit "1" and record
     the number of shifts.  */
  for (n_shifts = 0;
       !(*availiable_mask_bits & SIXTEENTH_BIT) && n_shifts < 16;
       n_shifts++)
    *availiable_mask_bits <<= 1;

  /* Shift for the number of bits your operand requires while bits
     are available.  */
  for (n_drop_bits = n_bits;
       n_drop_bits && (*availiable_mask_bits & SIXTEENTH_BIT);
       --n_drop_bits)
    *availiable_mask_bits <<= 1;

  if (n_drop_bits)
    as_bad (_(":operand has too many bits"));
  *availiable_mask_bits >>= n_shifts + n_bits;
  if ((n_drop_bits == 0) && (*availiable_mask_bits == 0))
    {
      oper_check = 1; /* flag operand check as good */
    }
  new_mask <<= N_BITS_IN_WORD - (n_shifts + n_bits);
  mask |= new_mask;
  return mask;
}

/* Parse ordinary expression.  */

static char *
xgate_parse_exp (char *s, expressionS * op)
{
  input_line_pointer = s;
  expression(op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  return input_line_pointer;
}

static int
cmp_opcode (struct xgate_opcode *op1, struct xgate_opcode *op2)
{
  return strcmp (op1->name, op2->name);
}

static struct xgate_opcode *
xgate_find_match (struct xgate_opcode_handle *opcode_handle,
		  int numberOfModes, s_operand oprs[], unsigned int operandCount)
{
  int i;

  if (numberOfModes == 0)
    return opcode_handle->opc0[0];

  for (i = 0; i <= numberOfModes; i++)
    {
      switch (operandCount)
        {
      case 0:
        if (!strcmp(opcode_handle->opc0[i]->constraints, XGATE_OP_INH))
          return opcode_handle->opc0[i];
        break;
      case 1:
        if (oprs[0].reg >= REG_R0 && oprs[0].reg <= REG_R7)
          if (!strcmp(opcode_handle->opc0[i]->constraints, XGATE_OP_MON))
            return opcode_handle->opc0[i];
          if (!strcmp(opcode_handle->opc0[i]->constraints, XGATE_OP_DYA_MON))
            return opcode_handle->opc0[i];
        if (oprs[0].reg == REG_NONE)
          if (!strcmp(opcode_handle->opc0[i]->constraints, XGATE_OP_IMM3))
            return opcode_handle->opc0[i];
        break;
      case 2:
        if (oprs[0].reg >= REG_R0 && oprs[0].reg <= REG_R7)
          {
            if (oprs[1].reg >= REG_R0 && oprs[1].reg <= REG_R7)
              if (!strcmp(opcode_handle->opc0[i]->constraints, XGATE_OP_DYA))
                return opcode_handle->opc0[i];
            if (oprs[1].reg == REG_CCR)
              if (!strcmp(opcode_handle->opc0[i]->constraints,
                  XGATE_OP_MON_R_C))
                return opcode_handle->opc0[i];
            if (oprs[1].reg == REG_PC)
              if (!strcmp(opcode_handle->opc0[i]->constraints,
                  XGATE_OP_MON_R_P))
                return opcode_handle->opc0[i];
            if (oprs[1].reg == REG_NONE)
              if (!strcmp(opcode_handle->opc0[i]->constraints, XGATE_OP_IMM16)
                  || !strcmp(opcode_handle->opc0[i]->constraints, XGATE_OP_IMM8)
                  || !strcmp(opcode_handle->opc0[i]->constraints, XGATE_OP_IMM4)
                  || !strcmp(opcode_handle->opc0[i]->constraints,
                      XGATE_OP_IMM16mADD)
                  || !strcmp(opcode_handle->opc0[i]->constraints,
                      XGATE_OP_IMM16mAND)
                  || !strcmp(opcode_handle->opc0[i]->constraints,
                      XGATE_OP_IMM16mCPC)
                  || !strcmp(opcode_handle->opc0[i]->constraints,
                      XGATE_OP_IMM16mSUB)
                  || !strcmp(opcode_handle->opc0[i]->constraints,
                      XGATE_OP_IMM16mLDW))
                return opcode_handle->opc0[i];
          }
        if (oprs[0].reg == REG_CCR)
          if (!strcmp(opcode_handle->opc0[i]->constraints, XGATE_OP_MON_C_R))
            return opcode_handle->opc0[i];
        break;
      case 3:
        if (oprs[0].reg >= REG_R0 && oprs[0].reg <= REG_R7)
          {
            if (oprs[1].reg >= REG_R0 && oprs[1].reg <= REG_R7)
              {
                if (oprs[2].reg >= REG_R0 && oprs[2].reg <= REG_R7)
                  {
                    if (!strcmp(opcode_handle->opc0[i]->constraints,
                        XGATE_OP_IDR)
                        || !strcmp(opcode_handle->opc0[i]->constraints,
                            XGATE_OP_TRI))
                      return opcode_handle->opc0[i];
                  }

                if (oprs[2].reg == REG_NONE)
                  if (!strcmp(opcode_handle->opc0[i]->constraints,
                      XGATE_OP_IDO5))
                    return opcode_handle->opc0[i];
              }
          }
        break;
      default:
        as_bad(_("unknown operand count"));
        break;
        }
    }
  return NULL ;
}

/* Because we are dealing with two different core that view the system
   memory with different offsets, we must differentiate what core a
   symbol belongs to, in order for the linker to cross-link.  */

int
xgate_frob_symbol (symbolS *sym)
{
  asymbol *bfdsym;
  elf_symbol_type *elfsym;

  bfdsym = symbol_get_bfdsym (sym);
  elfsym = elf_symbol_from (bfd_asymbol_bfd (bfdsym), bfdsym);

  gas_assert(elfsym);

  /* Mark the symbol as being *from XGATE  */
  elfsym->internal_elf_sym.st_target_internal = 1;

  return 0;
}

static unsigned int
xgate_get_operands (char *line, s_operand oprs[])
{
  int num_operands;

  /* If there are no operands, then it must be inherent.  */
  if (*line == 0 || *line == '\n' || *line == '\r')
    return 0;

  for (num_operands = 0; strlen (line) && (num_operands < MAX_NUM_OPERANDS);
       num_operands++)
    {
      line = skip_whitespace (line);
      if (*line == '#')
	line++;

      oprs[num_operands].mod = xgate_determine_modifiers (&line);

      if ((oprs[num_operands].reg = reg_name_search (line)) == REG_NONE)
	line = xgate_parse_exp (line, &oprs[num_operands].exp);

      /* skip to next operand */
      while (*line != 0)
	{
	  if (*line == ',')
	    {
	      line++;
	      break;
	    }
	  line++;
	}
    }
  if (num_operands > MAX_NUM_OPERANDS)
    return 0;
  return num_operands;
}

/* reg_name_search() finds the register number given its name.
   Returns the register number or REG_NONE on failure.  */
static register_id
reg_name_search (char *name)
{
  if (strncasecmp (name, "r0", 2) == 0)
    return REG_R0;
  if (strncasecmp (name, "r1", 2) == 0)
    return REG_R1;
  if (strncasecmp (name, "r2", 2) == 0)
    return REG_R2;
  if (strncasecmp (name, "r3", 2) == 0)
    return REG_R3;
  if (strncasecmp (name, "r4", 2) == 0)
    return REG_R4;
  if (strncasecmp (name, "r5", 2) == 0)
    return REG_R5;
  if (strncasecmp (name, "r6", 2) == 0)
    return REG_R6;
  if (strncasecmp (name, "r7", 2) == 0)
    return REG_R7;
  if (strncasecmp (name, "pc", 2) == 0)
    return REG_PC;
  if (strncasecmp (name, "ccr", 3) == 0)
    return REG_CCR;
  return REG_NONE;
}

/* Parse operand modifiers such as inc/dec/hi/low.  */

static op_modifiers
xgate_determine_modifiers(char **line)
{
  char *local_line = line[0];

  if (strncasecmp (local_line, "%hi", 3) == 0)
    {
      *line += 3;
      return MOD_LOAD_HIGH;
    }
  if (strncasecmp (local_line, "%lo", 3) == 0)
    {
      *line += 3;
      return MOD_LOAD_LOW;
    }
  if (*(local_line + 2) == '+')
    return MOD_POSTINC;
  if (strncasecmp (local_line, "-r", 2) == 0)
    {
      *line += 1;
      return MOD_PREDEC;
    }
  return MOD_NONE;
}

/* Parse instruction operands.  */

static void
xgate_scan_operands (struct xgate_opcode *opcode, s_operand oprs[])
{
  char *frag = xgate_new_instruction (opcode->size);
  int where = frag - frag_now->fr_literal;
  char *op = opcode->constraints;
  unsigned int bin = (int) opcode->bin_opcode;
  unsigned short oper_mask = 0;
  int operand_bit_length = 0;
  unsigned int operand = 0;
  char n_operand_bits = 0;
  char first_operand_equals_second = 0;
  int i = 0;
  char c = 0;

  /* Generate available operand bits mask.  */
  for (i = 0; (c = opcode->format[i]); i++)
    {
      if (ISDIGIT (c) || (c == 's'))
	{
	  oper_mask <<= 1;
	}
      else
	{
	  oper_mask <<= 1;
	  oper_mask += 1;
	  n_operand_bits++;
	}
    }

  /* Parse first operand.  */
  if (*op)
    {
      if (*op == '=')
	{
	  first_operand_equals_second = 1;
	  ++op;
	}
      operand = xgate_parse_operand (opcode, &operand_bit_length, where,
				     &op, oprs[0]);
      ++op;
      bin = xgate_apply_operand (operand, &oper_mask, bin, operand_bit_length);

      if(first_operand_equals_second)
	bin = xgate_apply_operand (operand, &oper_mask, bin,
				   operand_bit_length);
      /* Parse second operand.  */
      if (*op)
	{
	  if (*op == ',')
	    ++op;
	  if (first_operand_equals_second)
	    {
	      bin = xgate_apply_operand (operand, &oper_mask, bin,
					 operand_bit_length);
	      ++op;
	    }
	  else
	    {
	      operand = xgate_parse_operand (opcode, &operand_bit_length, where,
					     &op, oprs[1]);
	      bin = xgate_apply_operand (operand, &oper_mask, bin,
					 operand_bit_length);
	      ++op;
	    }
	}
      /* Parse the third register.  */
      if (*op)
	{
	  if (*op == ',')
	    ++op;
	  operand = xgate_parse_operand (opcode, &operand_bit_length, where,
					 &op, oprs[2]);
	  bin = xgate_apply_operand (operand, &oper_mask, bin,
				     operand_bit_length);
	}
    }
  if (opcode->size == 2 && fixup_required)
    {
      bfd_putl16 (bin, frag);
    }
  else if ( !strcmp (opcode->constraints, XGATE_OP_REL9)
      || !strcmp (opcode->constraints, XGATE_OP_REL10))
    {
      /* Write our data to a frag for further processing.  */
      bfd_putl16 (opcode->bin_opcode, frag);
    }
  else
    {
      /* Apply operand mask(s)to bin opcode and write the output.  */
      /* Since we are done write this frag in xgate BE format.  */
      number_to_chars_bigendian (frag, bin, opcode->size);
    }
  prev = bin;
  return;
}

static unsigned int
xgate_parse_operand (struct xgate_opcode *opcode,
		     int *bit_width,
		     int where,
		     char **op_con,
		     s_operand operand)
{
  char *op_constraint = *op_con;
  unsigned int op_mask = 0;
  unsigned int pp_fix = 0;
  unsigned short max_size = 0;
  int i;

  *bit_width = 0;
  /* Reset.  */

  switch (*op_constraint)
    {
    case '+': /* Indexed register operand +/- or plain r.  */
      /* Default to neither inc or dec.  */
      pp_fix = 0;
      *bit_width = 5;

      if (operand.reg == REG_NONE)
	as_bad (_(": expected register name r0-r7 ") );
      op_mask = operand.reg;
      if(operand.mod == MOD_POSTINC)
	pp_fix = INCREMENT;
      if(operand.mod == MOD_PREDEC)
	pp_fix = DECREMENT;
      op_mask <<= 2;
      op_mask |= pp_fix;
      break;

    case 'r': /* Register operand.  */
      if (operand.reg == REG_NONE)
	as_bad (_(": expected register name r0-r7 "));

      *bit_width = 3;

      op_mask = operand.reg;
      break;

    case 'i': /* Immediate value or expression expected.  */
      /* Advance the original format pointer.  */
      (*op_con)++;
      op_constraint++;
      if (ISDIGIT (*op_constraint))
	*bit_width = (int) *op_constraint - '0';
      else if (*op_constraint == 'a')
	*bit_width = 0x0A;
      else if (*op_constraint == 'f')
	*bit_width = 0x0F;

      /* http://tigcc.ticalc.org/doc/gnuasm.html#SEC31 */
      if (operand.exp.X_op == O_constant)
	{
	  op_mask = operand.exp.X_add_number;
	  if (((opcode->name[strlen (opcode->name) - 1] == 'l') && autoHiLo)
	      || operand.mod == MOD_LOAD_LOW)
	    op_mask &= 0x00FF;
	  else if (((opcode->name[strlen (opcode->name) - 1]) == 'h'
		    && autoHiLo) || operand.mod == MOD_LOAD_HIGH)
	    op_mask >>= 8;

	  /* Make sure it fits.  */
	  for (i = *bit_width; i; i--)
	    {
	      max_size <<= 1;
	      max_size += 1;
	    }
	  if (op_mask > max_size)
	    as_bad (_(":operand value(%d) too big for constraint"), op_mask);
	}
      else
	{
	  /* Should be BFD_RELOC_XGATE_IMM8_LO instead of BFD_RELOC_XGATE_24
	     TODO fix.  */
	  fixup_required = 1;
	  if (*op_constraint == '8')
	    {
	      if (((opcode->name[strlen (opcode->name) - 1] == 'l')
		   && autoHiLo) || operand.mod == MOD_LOAD_LOW)
		fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
			     BFD_RELOC_XGATE_24);
	      else if (((opcode->name[strlen (opcode->name) - 1]) == 'h'
			&& autoHiLo) || operand.mod == MOD_LOAD_HIGH )
		fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
			     BFD_RELOC_XGATE_IMM8_HI);
	      else
		as_bad (_("you must use a hi/lo directive or 16-bit macro "
			  "to load a 16-bit value."));
	    }
	  else if (*op_constraint == '5')
	    fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
			 BFD_RELOC_XGATE_IMM5);
	  else if (*op_constraint == '4')
	    fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
			 BFD_RELOC_XGATE_IMM4);
	  else if (*op_constraint == '3')
	    fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
			 BFD_RELOC_XGATE_IMM3);
	  else
	    as_bad (_(":unknown relocation constraint size"));
	}
      break;

    case 'c': /* CCR register expected.  */
      *bit_width = 0;
      if (operand.reg != REG_CCR)
	as_bad (_(": expected register name ccr "));
      break;

    case 'p': /* PC register expected.  */
      *bit_width = 0;
      if (operand.reg != REG_PC)
	as_bad (_(": expected register name pc "));
      break;

    case 'b': /* Branch expected.  */
      (*op_con)++;
      op_constraint++;

      if (operand.exp.X_op != O_register)
	{
	  if (*op_constraint == '9')
	    fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,
			 R_XGATE_PCREL_9);
	  else if (*op_constraint == 'a')
	    fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,
			 R_XGATE_PCREL_10);
	}
      else
	as_fatal (_("Operand `%x' not recognized in fixup8."),
		  operand.exp.X_op);
      break;
    case '?':
      break;

    default:
      as_bad (_("unknown constraint `%c'"), *op_constraint);
      break;
    }
  return op_mask;
}
@


1.10
log
@* config/tc-xgate.c (md_begin): Fix mistake made when going from
        git to cvs.
@
text
@d36 3
d107 1
a107 1
					      int, unsigned int);
d485 1
a485 1
  unsigned int sh_format = 0;
d507 1
a507 1
      sh_format = xgate_get_operands(input_line, new_operands);
d510 1
a510 1
				 sh_format);
d558 4
a561 5
		  sh_format = xgate_get_operands(input_line, new_operands);
		  macro_opcode
		    = xgate_find_match (opcode_handle,
					opcode_handle->number_of_modes,
					sh_format);
a562 1

d909 1
a909 2
		  int numberOfModes,
		  unsigned int sh_format)
d917 78
a994 4
    if (opcode_handle->opc0[i]->sh_format & sh_format)
      return opcode_handle->opc0[i];

  return NULL;
d1025 1
a1025 1
    return XG_INH;
a1049 1

d1052 1
a1052 42

  switch (num_operands)
    {
    case 1:
      if (oprs[0].reg >= REG_R0 && oprs[0].reg <= REG_R7)
	return XG_R;
      if (oprs[0].reg == REG_NONE)
	return XG_I;
      break;
    case 2:
      if (oprs[0].reg >= REG_R0 && oprs[0].reg <= REG_R7)
	{
	  if (oprs[1].reg >= REG_R0 && oprs[1].reg <= REG_R7)
	    return XG_R_R;
	  if (oprs[1].reg == REG_CCR)
	    return XG_R_C;
	  if (oprs[1].reg == REG_PC)
	    return XG_R_P;
	  if (oprs[1].reg == REG_NONE)
	    return XG_R_I;
	}
      if (oprs[0].reg == REG_CCR)
	return XG_C_R;
      break;
    case 3:
      if (oprs[0].reg >= REG_R0 && oprs[0].reg <= REG_R7)
	{
	  if (oprs[1].reg >= REG_R0 && oprs[1].reg <= REG_R7)
	    {
	      if (oprs[2].reg >= REG_R0 && oprs[2].reg <= REG_R7)
		return XG_R_R_R;
	      if (oprs[2].reg >= REG_NONE)
		return XG_R_R_I;
	    }
	}
      break;
    default:
      as_bad (_("unknown operand format"));
      break;
    }

  return 0;
d1193 2
a1194 1
  else if ((opcode->sh_format & XG_PCREL))
@


1.9
log
@* config/tc-xgate.c (md_begin): Fix the printing of opcodes so
        that the assember exits after the opcodes have been printed.
@
text
@d354 1
a354 1
      print_opcode_list ();
@


1.8
log
@	* config/tc-xgate.c: Make some functions static.  Formatting
	style and whitespace fixes.  Wrap overly long lines.  Format
	help message.
@
text
@d352 5
a356 2
  if (flag_print_opcodes == 1)
    xgate_print_table ();
@


1.7
log
@        * config/tc-xgate.c: Remove bogus use of <fx_pcrel_adjust>.
        * config/tc-m68hc11.c: Likewise.
@
text
@d36 3
a38 3
#define SIXTEENTH_BIT           0x8000
#define N_BITS_IN_WORD          16
#define MAX_NUM_OPERANDS        3
d63 2
a64 1
/* XGATE's registers all are 16-bit general purpose.  They are numbered according to the specifications.  */
d99 14
a112 35
/*  LOCAL FUNCTIONS */
static char *
xgate_parse_exp (char *, expressionS *);
static inline char *
skip_whitespace (char *);
static void
get_default_target (void);
static char *
extract_word (char *, char *, int);
static char *
xgate_new_instruction (int size);
unsigned short
xgate_apply_operand (unsigned short, unsigned short *, unsigned short,
    unsigned char);
static struct xgate_opcode *
xgate_find_match (struct xgate_opcode_handle *, int, unsigned int);
static int
cmp_opcode (struct xgate_opcode *, struct xgate_opcode *);
void
xgate_print_syntax (char *);
void
xgate_print_table (void);
unsigned int
xgate_get_operands (char *, s_operand []);
static register_id
reg_name_search (char *);
op_modifiers
xgate_determine_modifiers(char **);

void
xgate_scan_operands (struct xgate_opcode *opcode, s_operand []);

static unsigned int
xgate_parse_operand (struct xgate_opcode *, int *, int where, char **,
               s_operand);
a113 1
/* LOCAL DATA */
d122 1
a122 1
static unsigned char autoHiLo = 0;	
d276 5
a280 5
        {
          current_architecture = cpuxgate;
          default_cpu = "XGATE V1";
          return;
        }
d306 1
a306 1
      i < xgate_num_opcodes; i++)
d316 1
a316 1
      xgate_opcode_ptr++, i++)
d319 1
a319 1
        number_of_op_handles++;
d331 1
a331 1
      i++, xgate_opcode_ptr++)
d334 4
a337 4
        {
          handle_enum++;
          op_handles[j].opc0[handle_enum] = xgate_opcode_ptr;
        }
d339 9
a347 9
        {
          handle_enum = 0;
          if (i)
            j++;
          op_handles[j].name = xgate_opcode_ptr->name;
          op_handles[j].opc0[0] = xgate_opcode_ptr;
          hash_insert (xgate_hash, (char *) op_handles[j].name,
              (char *) &(op_handles[j]));
        }
d366 1
a366 2
  fprintf (
	   stream,
d368 9
a376 9
      Freescale XGATE co-processor options:\n			\
       -mshort                 use 16-bit int ABI (default)\n	\
       -mlong                  use 32-bit int ABI\n		\
       -mshort-double          use 32-bit double ABI\n			\
       -mlong-double           use 64-bit double ABI (default)\n\
      --mxgate                 specify the processor variant[default %s]\n\
      --print-insn-syntax     print the syntax of instruction in case of error\n\
      --print-opcodes         print the list of instructions with syntax\n\
      --generate-example      generate an example of each instruction"),
d393 1
a393 1
void
d401 3
a403 3
        {
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IDR))
            printf ("\tFormat is %s\tRx, Rx, Rx+|-Rx|Rx\n",
d405 12
a416 12
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_INH))
            printf ("\tFormat is %s\n", xgate_opcodes[i].name);
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_TRI))
            printf ("\tFormat is %s\tRx, Rx, Rx\n", xgate_opcodes[i].name);
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_DYA))
            printf ("\tFormat is %s\tRx, Rx\n", xgate_opcodes[i].name);
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM3))
            printf ("\tFormat is %s\t<3-bit value>\n", xgate_opcodes[i].name);
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM4))
            printf ("\tFormat is %s\t<4 -bit value>\n", xgate_opcodes[i].name);
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM8))
            printf ("\tFormat is %s\tRx, <8-bit value>\n",
d418 2
a419 2
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM16))
            printf ("\tFormat is %s\tRx, <16-bit value>\n",
d421 8
a428 8
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_MON_R_C))
            printf ("\tFormat is %s\tRx, CCR\n", xgate_opcodes[i].name);
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_MON_C_R))
            printf ("\tFormat is %s\tCCR, Rx\n", xgate_opcodes[i].name);
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_MON_R_P))
            printf ("\tFormat is %s\tRx, PC\n", xgate_opcodes[i].name);
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_IMM16mLDW))
            printf ("\tFormat is %s\tRx, <16-bit value>\n",
d430 1
a430 1
        }
d434 1
a434 1
void
d493 1
a493 1
      op_name)))
d504 1
a504 1
          sh_format);
d507 4
a510 4
        {
          as_bad (_("matching operands to opcode "));
          xgate_print_syntax (opcode_handle->opc0[0]->name);
        }
d512 1
a512 1
        {
d514 2
a515 2
          xgate_scan_operands (opcode, new_operands);
        }
d517 1
a517 1
        {
d519 2
a520 2
          autoHiLo = 1;
          unsigned int i;
d522 17
a538 16
          /* skip past our ';' separator.  */
          for (i = strlen (opcode->constraints), p = opcode->constraints; i > 0;
              i--, p++)
            {
              if (*p == ';')
                {
                  p++;
                  break;
                }
            }
          input_line = skip_whitespace (input_line);
          char *macro_inline = input_line;

          /* Loop though the macro's opcode list and apply operands to each real opcode. */
          for (i = 0; *p && i < (opcode->size / 2); i++)
            {
d540 2
a541 2
              input_line = macro_inline; /* Rewind.  */
              p = extract_word (p, op_name, 10);
d543 1
a543 1
              if (!(opcode_handle = (struct xgate_opcode_handle *)
d545 17
a561 15
                {
                  as_bad (
                      _(": processing macro, real opcode handle not found in hash"));
                  break;
                }
              else
                {
                  sh_format = xgate_get_operands(input_line, new_operands);
                  macro_opcode = xgate_find_match (opcode_handle,
                      opcode_handle->number_of_modes, sh_format);
                  xgate_scan_operands (macro_opcode, new_operands);

                }
            }
        }
d576 1
a576 2
  relax_substateT rlx_state[] =
    { 0, 2 };
d581 6
a586 6
          && (!S_IS_DEFINED (fragp->fr_symbol)
              || seg != S_GET_SEGMENT (fragp->fr_symbol)))
        {
          fragp->fr_subtype = rlx_state[subtype + 1];
          break;
        }
d622 1
a622 3
    {
      reloc->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_16);
    }
d624 1
a624 3
    {
      reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
    }
d629 2
a630 2
      ("Relocation %d is not supported by object file format."),
          (int) fixp->fx_r_type);
d655 2
a656 1
  /* If the fixup is done mark it done so no further symbol resolution will take place.  */
d658 1
a658 3
    {
      fixP->fx_done = 1;
    }
d673 2
a674 1
		      _("Value %ld too large for 9-bit PC-relative branch."), value);
d679 5
a683 2
		      ("Value %ld not aligned by 2 for 9-bit PC-relative branch."), value);
      mask = 0x1FF; /* Clip into 8-bit field FIXME I'm sure there is a more proper place for this */
d690 2
a691 1
		      _("Value %ld too large for 10-bit PC-relative branch."), value);
d696 5
a700 2
		      ("Value %ld not aligned by 2 for 10-bit PC-relative branch."), value);
      mask = 0x3FF; /* Clip into 9-bit field FIXME I'm sure there is a more proper place for this */
d836 1
a836 1
        break;
d850 1
a850 1
unsigned short
d859 2
a860 1
  /* Shift until you find an available operand bit "1" and record the number of shifts.  */
d866 2
a867 1
  /* Shift for the number of bits your operand requires while bits are available.  */
d941 1
a941 1
unsigned int
d951 1
a951 1
      num_operands++)
d955 1
a955 1
        line++;
d960 1
a960 1
        line = xgate_parse_exp (line, &oprs[num_operands].exp);
d964 8
a971 8
        {
          if (*line == ',')
            {
              line++;
              break;
            }
          line++;
        }
d979 36
a1014 36
  case 1:
    if (oprs[0].reg >= REG_R0 && oprs[0].reg <= REG_R7)
      return XG_R;
    if (oprs[0].reg == REG_NONE)
      return XG_I;
    break;
  case 2:
    if (oprs[0].reg >= REG_R0 && oprs[0].reg <= REG_R7)
      {
        if (oprs[1].reg >= REG_R0 && oprs[1].reg <= REG_R7)
          return XG_R_R;
        if (oprs[1].reg == REG_CCR)
          return XG_R_C;
        if (oprs[1].reg == REG_PC)
          return XG_R_P;
        if (oprs[1].reg == REG_NONE)
          return XG_R_I;
      }
    if (oprs[0].reg == REG_CCR)
      return XG_C_R;
    break;
  case 3:
    if (oprs[0].reg >= REG_R0 && oprs[0].reg <= REG_R7)
      {
        if (oprs[1].reg >= REG_R0 && oprs[1].reg <= REG_R7)
          {
            if (oprs[2].reg >= REG_R0 && oprs[2].reg <= REG_R7)
              return XG_R_R_R;
            if (oprs[2].reg >= REG_NONE)
              return XG_R_R_I;
          }
      }
    break;
  default:
    as_bad (_("unknown operand format"));
    break;
d1050 1
a1050 1
op_modifiers
d1066 1
a1066 1
        return MOD_POSTINC;
d1071 1
a1071 1
   }
d1077 1
a1077 1
void
d1096 3
a1098 3
        {
          oper_mask <<= 1;
        }
d1100 5
a1104 5
        {
          oper_mask <<= 1;
          oper_mask += 1;
          n_operand_bits++;
        }
d1111 6
a1116 5
        {
          first_operand_equals_second = 1;
          ++op;
        }
      operand = xgate_parse_operand (opcode, &operand_bit_length, where, &op, oprs[0]);
d1121 2
a1122 1
        bin = xgate_apply_operand (operand, &oper_mask, bin, operand_bit_length);
d1125 18
a1142 18
        {
          if (*op == ',')
            ++op;
          if (first_operand_equals_second)
            {
              bin = xgate_apply_operand (operand, &oper_mask, bin,
                  operand_bit_length);
              ++op;
            }
          else
            {
              operand = xgate_parse_operand (opcode, &operand_bit_length, where,
                  &op, oprs[1]);
              bin = xgate_apply_operand (operand, &oper_mask, bin,
                  operand_bit_length);
              ++op;
            }
        }
d1145 8
a1152 8
        {
          if (*op == ',')
            ++op;
          operand = xgate_parse_operand (opcode, &operand_bit_length, where, &op,
              oprs[2]);
          bin = xgate_apply_operand (operand, &oper_mask, bin,
              operand_bit_length);
        }
d1175 4
a1178 4
               int *bit_width,
               int where,
               char **op_con,
               s_operand operand)
d1197 1
a1197 1
            as_bad (_(": expected register name r0-r7 ") );
d1200 1
a1200 1
        pp_fix = INCREMENT;
d1202 1
a1202 1
        pp_fix = DECREMENT;
d1208 2
a1209 2
    if (operand.reg == REG_NONE)
      as_bad (_(": expected register name r0-r7 "));
d1211 1
a1211 1
    *bit_width = 3;
d1213 1
a1213 1
    op_mask = operand.reg;
d1221 1
a1221 3
        {
          *bit_width = (int) *op_constraint - '0';
        }
d1223 1
a1223 3
        {
          *bit_width = 0x0A;
        }
d1225 2
a1226 3
        {
          *bit_width = 0x0F;
        }
d1229 18
a1246 22
        {
          op_mask = operand.exp.X_add_number;
          if (((opcode->name[strlen (opcode->name) - 1] == 'l') && autoHiLo)
              || operand.mod == MOD_LOAD_LOW)
            {
              op_mask &= 0x00FF;
            }
          else if (((opcode->name[strlen (opcode->name) - 1]) == 'h'
                   && autoHiLo) || operand.mod == MOD_LOAD_HIGH)
            {
              op_mask >>= 8;
            }

          /* Make sure it fits.  */
          for (i = *bit_width; i; i--)
            {
              max_size <<= 1;
              max_size += 1;
            }
          if (op_mask > max_size)
            as_bad (_(":operand value(%d) too big for constraint"), op_mask);
        }
d1248 30
a1277 45
        {
          /* Should be BFD_RELOC_XGATE_IMM8_LO instead of BFD_RELOC_XGATE_24
             TODO fix.  */
          fixup_required = 1;
          if (*op_constraint == '8')
            {
              if (((opcode->name[strlen (opcode->name) - 1] == 'l')
                  && autoHiLo) || operand.mod == MOD_LOAD_LOW)
                {
                    fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                                 BFD_RELOC_XGATE_24);
                }
              else if (((opcode->name[strlen (opcode->name) - 1]) == 'h'
                  && autoHiLo) || operand.mod == MOD_LOAD_HIGH )
                {
                    fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                                 BFD_RELOC_XGATE_IMM8_HI);
                }
              else
                {
                  as_bad (_("you must use a hi/lo directive or 16-bit macro "
                      "to load a 16-bit value."));
                  break;
                }
            }
          else if (*op_constraint == '5')
            {
              fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                           BFD_RELOC_XGATE_IMM5);
            }
          else if (*op_constraint == '4')
            {
              fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                           BFD_RELOC_XGATE_IMM4);
            }
          else if (*op_constraint == '3')
            {
              fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                           BFD_RELOC_XGATE_IMM3);
          }
        else
          {
            as_bad (_(":unknown relocation constraint size"));
          }
      }
d1283 1
a1283 1
            as_bad (_(": expected register name ccr "));
d1288 2
a1289 2
            if (operand.reg != REG_PC)
                  as_bad (_(": expected register name pc "));
d1297 8
a1304 12
        {
          if (*op_constraint == '9')
            {
              fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,
                           R_XGATE_PCREL_9);
            }
          else if (*op_constraint == 'a')
            {
              fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,
                           R_XGATE_PCREL_10);
            }
        }
d1306 2
a1307 3
        {
          as_fatal (_("Operand `%x' not recognized in fixup8."), operand.exp.X_op);
        }
@


1.6
log
@2012-07-27  Sean Keys  <skeys@@ipdatasys.com>

gas/config/
	* tc-xgate.c: Consolidated inc/dec/hi/low modifieres into
	one function.
	(xgate_parse_operand): Added %hi and %lo handling.
gas/testsuite/gas/xgate
	* xgate.exp: Added hi/lo test.
	* hilo.d: New test file
	* hilo.s: Net test source file.
@
text
@a1192 1
  fixS *fixp = 0;
d1279 2
a1280 2
                    fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                                      BFD_RELOC_XGATE_24);
d1285 2
a1286 2
                    fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                                      BFD_RELOC_XGATE_IMM8_HI);
a1293 1
              fixp->fx_pcrel_adjust = 0;
d1297 2
a1298 3
              fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                                  BFD_RELOC_XGATE_IMM5);
              fixp->fx_pcrel_adjust = 0;
d1302 2
a1303 3
              fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                                  BFD_RELOC_XGATE_IMM4);
              fixp->fx_pcrel_adjust = 0;
d1307 2
a1308 3
            fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
                BFD_RELOC_XGATE_IMM3);
            fixp->fx_pcrel_adjust = 0;
d1337 2
a1338 3
              fixp = fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,
                                  R_XGATE_PCREL_9);
              fixp->fx_pcrel_adjust = 1;
d1342 2
a1343 3
              fixp = fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,
                                  R_XGATE_PCREL_10);
              fixp->fx_pcrel_adjust = 1;
@


1.5
log
@gas/config/
        * tc-xgate.c: Revised assembler so that operands
	are collected before the addressing mode is
	determined.

include/opcode/
	* xgate.h: Changed the format string for mode
	XGATE_OP_DYA_MON.

opcodes/
	* xgate-dis.c: Removed an IF statement that will
	always be false due to overlapping operand masks.
	* xgate-opc.c: Corrected 'com' opcode entry and
	fixed spacing.
@
text
@d125 1
a125 3
xgate_determine_hi_low(char **);
op_modifiers
xgate_determine_increment(char **);
d143 1
a143 1
static unsigned char macroClipping = 0;	
d541 1
a541 1
          macroClipping = 1;
d582 1
a582 1
  macroClipping = 0;
d972 1
a972 2
      oprs[num_operands].mod = xgate_determine_hi_low (&line);
      oprs[num_operands].mod = xgate_determine_increment (&line);
d1063 2
d1066 1
a1066 1
xgate_determine_hi_low(char **line)
a1079 8
  return MOD_NONE;
}

op_modifiers
xgate_determine_increment(char **line)
{
  char *local_line = line[0];

d1081 1
a1081 1
      return MOD_POSTINC;
d1086 1
a1086 1
    }
d1191 1
a1191 1
               s_operand operand_two)
d1210 1
a1210 1
      if (operand_two.reg == REG_NONE)
d1212 2
a1213 2
      op_mask = operand_two.reg;
      if(operand_two.mod == MOD_POSTINC)
d1215 1
a1215 1
      if(operand_two.mod == MOD_PREDEC)
d1222 1
a1222 1
    if (operand_two.reg == REG_NONE)
d1227 1
a1227 1
    op_mask = operand_two.reg;
d1247 1
a1247 1
      if (operand_two.exp.X_op == O_constant)
d1249 3
a1251 2
          op_mask = operand_two.exp.X_add_number;
          if ((opcode->name[strlen (opcode->name) - 1] == 'l') && macroClipping)
d1255 2
a1256 2
          else if ((opcode->name[strlen (opcode->name) - 1]) == 'h'
                   && macroClipping)
d1272 2
d1277 2
a1278 2
              if ((opcode->name[strlen (opcode->name) - 1] == 'l')
                  && macroClipping)
d1280 1
a1280 1
                  fixp = fix_new_exp (frag_now, where, 2, &operand_two.exp, FALSE,
a1281 2
                  /* Should be BFD_RELOC_XGATE_IMM8_LO TODO fix.  */
                  fixp->fx_pcrel_adjust = 0;
d1283 2
a1284 2
              if ((opcode->name[strlen (opcode->name) - 1]) == 'h'
                  && macroClipping)
d1286 1
a1286 1
                  fixp = fix_new_exp (frag_now, where, 2, &operand_two.exp, FALSE,
a1287 1
                  fixp->fx_pcrel_adjust = 0;
d1289 7
a1295 2
              if (!fixp)
                as_bad (_(":unknown relocation"));
d1299 1
a1299 1
              fixp = fix_new_exp (frag_now, where, 2, &operand_two.exp, FALSE,
d1305 1
a1305 1
              fixp = fix_new_exp (frag_now, where, 2, &operand_two.exp, FALSE,
d1311 1
a1311 1
            fixp = fix_new_exp (frag_now, where, 2, &operand_two.exp, FALSE,
d1320 1
a1320 1
    break;
d1324 1
a1324 1
      if (operand_two.reg != REG_CCR)
d1326 1
a1326 1
    break;
d1330 1
a1330 1
            if (operand_two.reg != REG_PC)
d1338 1
a1338 1
      if (operand_two.exp.X_op != O_register)
d1342 1
a1342 1
              fixp = fix_new_exp (frag_now, where, 2, &operand_two.exp, TRUE,
d1348 1
a1348 1
              fixp = fix_new_exp (frag_now, where, 2, &operand_two.exp, TRUE,
d1355 1
a1355 1
          as_fatal (_("Operand `%x' not recognized in fixup8."), operand_two.exp.X_op);
@


1.5.2.1
log
@	* tc-m68hc11.c (s_m68hc11_parse_pseudo_instruction):
	New function to parse pseudo ops that are unreleated to
	existing pseudo ops.
@
text
@d125 3
a127 1
xgate_determine_modifiers(char **);
d145 1
a145 1
static unsigned char autoHiLo = 0;	
d543 1
a543 1
          autoHiLo = 1;
d584 1
a584 1
  autoHiLo = 0;
d974 2
a975 1
      oprs[num_operands].mod = xgate_determine_modifiers (&line);
a1065 2
/* Parse operand modifiers such as inc/dec/hi/low.  */

d1067 1
a1067 1
xgate_determine_modifiers(char **line)
d1081 8
d1090 1
a1090 1
        return MOD_POSTINC;
d1095 1
a1095 1
   }
d1200 1
a1200 1
               s_operand operand)
d1219 1
a1219 1
      if (operand.reg == REG_NONE)
d1221 2
a1222 2
      op_mask = operand.reg;
      if(operand.mod == MOD_POSTINC)
d1224 1
a1224 1
      if(operand.mod == MOD_PREDEC)
d1231 1
a1231 1
    if (operand.reg == REG_NONE)
d1236 1
a1236 1
    op_mask = operand.reg;
d1256 1
a1256 1
      if (operand.exp.X_op == O_constant)
d1258 2
a1259 3
          op_mask = operand.exp.X_add_number;
          if (((opcode->name[strlen (opcode->name) - 1] == 'l') && autoHiLo)
              || operand.mod == MOD_LOAD_LOW)
d1263 2
a1264 2
          else if (((opcode->name[strlen (opcode->name) - 1]) == 'h'
                   && autoHiLo) || operand.mod == MOD_LOAD_HIGH)
a1279 2
          /* Should be BFD_RELOC_XGATE_IMM8_LO instead of BFD_RELOC_XGATE_24
             TODO fix.  */
d1283 2
a1284 2
              if (((opcode->name[strlen (opcode->name) - 1] == 'l')
                  && autoHiLo) || operand.mod == MOD_LOAD_LOW)
d1286 1
a1286 1
                    fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
d1288 2
d1291 2
a1292 2
              else if (((opcode->name[strlen (opcode->name) - 1]) == 'h'
                  && autoHiLo) || operand.mod == MOD_LOAD_HIGH )
d1294 1
a1294 1
                    fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
d1296 1
d1298 2
a1299 7
              else
                {
                  as_bad (_("you must use a hi/lo directive or 16-bit macro "
                      "to load a 16-bit value."));
                  break;
                }
              fixp->fx_pcrel_adjust = 0;
d1303 1
a1303 1
              fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
d1309 1
a1309 1
              fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
d1315 1
a1315 1
            fixp = fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,
d1324 1
a1324 1
      break;
d1328 1
a1328 1
      if (operand.reg != REG_CCR)
d1330 1
a1330 1
      break;
d1334 1
a1334 1
            if (operand.reg != REG_PC)
d1342 1
a1342 1
      if (operand.exp.X_op != O_register)
d1346 1
a1346 1
              fixp = fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,
d1352 1
a1352 1
              fixp = fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,
d1359 1
a1359 1
          as_fatal (_("Operand `%x' not recognized in fixup8."), operand.exp.X_op);
@


1.4
log
@gas/config/
	* tc-xgate.h: Defined tc_frob_symbol.
	* tc-xgate.c (xgate_frob_symbol): Wrote new function to mark
	  symbols as being XGATE by setting st_target_internal value.

bfd/
	* elf32-xgate.c (elf32_xgate_add_symbol_hook): Added a temp patch
	  that forces st_target_internal to equal 1, since tc_frob_symbol
	  seems to need adjusting.
@
text
@d36 3
a38 2
#define SIXTEENTH_BIT	0x8000
#define N_BITS_IN_WORD	16
d63 35
a111 4
void
xgate_operands (struct xgate_opcode *, char **);
static unsigned int
xgate_operand (struct xgate_opcode *, int *, int where, char **, char **);
a115 2
unsigned int
xgate_detect_format (char *);
d120 15
a177 16
/* XGATE's registers all are 16-bit general purpose.  They are numbered according to the specifications.  */
typedef enum register_id
{
  REG_NONE = -1,
  REG_R0 = 0,
  REG_R1 = 1,
  REG_R2 = 2,
  REG_R3 = 3,
  REG_R4 = 4,
  REG_R5 = 5,
  REG_R6 = 6,
  REG_R7 = 7,
  REG_PC = 8,
  REG_CCR = 9
} register_id;

a434 3
          if (!strcmp (xgate_opcodes[i].constraints, XGATE_OP_DYA_MON)
              || !strcmp (xgate_opcodes[i].constraints, XGATE_OP_MON))
            printf ("\tFormat is %s\tRx\n", xgate_opcodes[i].name);
d506 2
d523 3
a525 2
      /* Detect operand format so we can pull the proper opcode bin.  */
      sh_format = xgate_detect_format (input_line);
d538 1
a538 1
          xgate_operands (opcode, &input_line);
d575 1
a575 1
                  sh_format = xgate_detect_format (input_line);
d578 2
a579 1
                  xgate_operands (macro_opcode, &input_line);
a764 1
      /* todo figure out how to make BFD_RELOC_16 the default */
d914 26
a939 1
/* For testing.  Comment out to prevent defined but not used warning
d941 2
a942 2
static unsigned int
xgate_get_constant(char *str, int max)
d944 2
a945 1
  expressionS ex;
d947 2
a948 3
  str = skip_whitespace(str);
  input_line_pointer = str;
  expression (& ex);
d950 1
a950 2
  if (ex.X_op != O_constant)
    as_bad(_("constant value required"));
d952 2
a953 2
  if (ex.X_add_number > max || ex.X_add_number < 0)
    as_bad(_("number must be positive and less than %d"), max + 1);
d955 1
a955 1
  return ex.X_add_number;
a956 1
*/
d958 128
a1085 2
static int
cmp_opcode (struct xgate_opcode *op1, struct xgate_opcode *op2)
d1087 10
a1096 1
  return strcmp (op1->name, op2->name);
d1102 1
a1102 1
xgate_operands (struct xgate_opcode *opcode, char **line)
a1107 1
  char *str = *line;
a1130 1
  /* Opcode has operands.  */
d1139 1
a1139 1
      operand = xgate_operand (opcode, &operand_bit_length, where, &op, &str);
d1142 3
d1150 1
a1150 2
          str = skip_whitespace (str);
          if (*str++ != ',')
d1152 3
a1154 10
              if (first_operand_equals_second)
                {
                  bin = xgate_apply_operand (operand, &oper_mask, bin,
                      operand_bit_length);
                  ++op;
                }
              else
                {
                  as_bad (_("`,' required before second operand"));
                }
d1158 2
a1159 3
              str = skip_whitespace (str);
              operand = xgate_operand (opcode, &operand_bit_length, where, &op,
                  &str);
a1164 1

d1170 2
a1171 6
          str = skip_whitespace (str);
          if (*str++ != ',')
            as_bad (_("`,' required before third operand"));
          str = skip_whitespace (str);
          operand = xgate_operand (opcode, &operand_bit_length, where, &op,
              &str);
d1183 1
a1183 1
      bfd_putl16 (opcode->bin_opcode, frag); 
d1189 1
a1189 1
      number_to_chars_bigendian (frag, bin, opcode->size); 
a1191 1
  *line = str;
d1196 5
a1200 5
xgate_operand (struct xgate_opcode *opcode,
	       int *bit_width,
	       int where,
	       char **op_con,
	       char **line)
a1201 1
  expressionS op_expr;
a1204 3
  char *str = skip_whitespace (*line);
  char r_name[20] =
    { 0 };
a1214 2
      /* TODO should be able to combine with with case R.  */

d1218 8
a1225 21
      str = skip_whitespace (str);
      while (*str != ' ' && *str != '\t')
	{
	  if (*str == '-')
	    pp_fix = DECREMENT;
	  else if (*str == '+')
	    pp_fix = INCREMENT;
	  else if (*str == 'r' || *str == 'R')
	    {
	      str = extract_word (str, r_name, sizeof(r_name));
	      if (ISDIGIT (r_name[1]))
		{
		  if (r_name[2] == '\0' && (r_name[1] - '0' < 8))
		    op_mask = r_name[1] - '0';
		  if (r_name[2] != '\0' && (r_name[1] - '0' > 7))
		    as_bad (_(": expected register name r0-r7 read %s"), r_name);
		  continue;
		}
	    }
	  str++;
	}
d1231 6
a1236 20
      if (*str == 'r' || *str == 'R')
	{
	  *bit_width = 3;
	  str = extract_word (str, r_name, sizeof(r_name));
	  op_mask = 0xff;
	  if (ISDIGIT (r_name[1]))
	    {
	      if (r_name[2] == '\0')
		op_mask = r_name[1] - '0';
	      else if (r_name[1] != '0' && ISDIGIT (r_name[2])
		       && r_name[3] == '\0')
		op_mask = (r_name[1] - '0') * 10 + r_name[2] - '0';
	      if (op_mask > MAXREGISTER)
		as_bad (_(": expected register name r0-r7 read %s "), r_name);
	    }
	}
      else
	{
	  as_bad (_(": expected register name r0-r7 read %s "), r_name);
	}
d1244 3
a1246 3
	{
	  *bit_width = (int) *op_constraint - '0';
	}
d1248 3
a1250 3
	{
	  *bit_width = 0x0A;
	}
d1252 3
a1254 3
	{
	  *bit_width = 0x0F;
	}
d1256 22
a1277 29
      if (*str == '#')
	str++;
      str = xgate_parse_exp (str, &op_expr);
      if (op_expr.X_op == O_constant)
	{
	  if (!ISDIGIT (*op_constraint))
	    as_bad (
		    _(":expected bit length with constraint type i(# immediate) read %c"),
		    *op_constraint);
	  op_mask = op_expr.X_add_number;
	  if ((opcode->name[strlen (opcode->name) - 1] == 'l') && macroClipping)
	    {
	      op_mask &= 0x00FF;
	    }
	  else if ((opcode->name[strlen (opcode->name) - 1]) == 'h'
		   && macroClipping)
	    {
	      op_mask >>= 8;
	    }

	  /* Make sure it fits.  */
	  for (i = *bit_width; i; i--)
	    {
	      max_size <<= 1;
	      max_size += 1;
	    }
	  if (op_mask > max_size)
	    as_bad (_(":operand value(%d) too big for constraint"), op_mask);
	}
d1279 20
a1298 20
	{
	  fixup_required = 1;
	  if (*op_constraint == '8')
	    {
	      if ((opcode->name[strlen (opcode->name) - 1] == 'l')
		  && macroClipping)
		{
		  fixp = fix_new_exp (frag_now, where, 2, &op_expr, FALSE,
				      BFD_RELOC_XGATE_24);
		  /* Should be BFD_RELOC_XGATE_IMM8_LO TODO fix.  */
		  fixp->fx_pcrel_adjust = 0;
		}
	      if ((opcode->name[strlen (opcode->name) - 1]) == 'h'
		  && macroClipping)
		{
		  fixp = fix_new_exp (frag_now, where, 2, &op_expr, FALSE,
				      BFD_RELOC_XGATE_IMM8_HI);
		  fixp->fx_pcrel_adjust = 0;
		}
	      if (!fixp)
d1300 16
a1315 16
	    }
	  else if (*op_constraint == '5')
	    {
	      fixp = fix_new_exp (frag_now, where, 2, &op_expr, FALSE,
				  BFD_RELOC_XGATE_IMM5);
	      fixp->fx_pcrel_adjust = 0;
	    }
	  else if (*op_constraint == '4')
	    {
	      fixp = fix_new_exp (frag_now, where, 2, &op_expr, FALSE,
				  BFD_RELOC_XGATE_IMM4);
	      fixp->fx_pcrel_adjust = 0;
	    }
	  else if (*op_constraint == '3')
	    {
            fixp = fix_new_exp (frag_now, where, 2, &op_expr, FALSE,
d1327 3
a1329 11
    if (*str == 'c' || *str == 'C')
      {
        *bit_width = 0;
        str = extract_word (str, r_name, sizeof(r_name));
        if (!(strcmp (r_name, "ccr") || strcmp (r_name, "CCR")))
          as_bad (_(": expected register name ccr read %s "), r_name);
      }
    else
      {
        as_bad (_(": expected character c or C  read %c"), *str);
      }
d1333 3
a1335 11
      if (*str == 'p' || *str == 'P')
	{
	  *bit_width = 0;
	  str = extract_word (str, r_name, sizeof(r_name));
	  if (!(strcmp (r_name, "pc") || strcmp (r_name, "PC")))
	    as_bad (_(": expected register name pc read %s "), r_name);
	}
      else
	{
	  as_bad (_(": expected character p or P read %c "), *str);
	}
a1338 1
      str = xgate_parse_exp (str, &op_expr);
d1341 16
a1356 16
      if (op_expr.X_op != O_register)
	{
	  if (*op_constraint == '9')
	    {
	      /* mode == M68XG_OP_REL9 */
	      fixp = fix_new_exp (frag_now, where, 2, &op_expr, TRUE,
				  R_XGATE_PCREL_9);
	      fixp->fx_pcrel_adjust = 1;
	    }
	  else if (*op_constraint == 'a')
	    { /* mode == M68XG_OP_REL10 */
	      fixp = fix_new_exp (frag_now, where, 2, &op_expr, TRUE,
				  R_XGATE_PCREL_10);
	      fixp->fx_pcrel_adjust = 1;
	    }
	}
d1358 3
a1360 3
	{
	  as_fatal (_("Operand `%x' not recognized in fixup8."), op_expr.X_op);
	}
a1361 1

a1368 1
  *line = str;
a1370 177

unsigned int
xgate_detect_format (char *line_in)
{
  char num_operands = 0;
  char *str = skip_whitespace (line_in);
  int i = 0;
  int j = 0;
  char c = 0;
  unsigned int stripped_length = 0;
  char sh_format[10] =
    { 0 }; /* Shorthand format.  */
  char operands_stripped[3][20] =
    {
      { 0 }
    };
  /* Strings.  TODO maybe structure this.  */
  char *i_string =
    { "i" };
  char *r_string =
    { "r" };
  char *r_r_string =
    { "r,r" };
  char *r_r_r_string =
    { "r,r,r" };
  char *r_i_string =
    { "r,i" };
  char *r_c_string =
    { "r,c" };
  char *c_r_string =
    { "c,r" };
  char *r_p_string =
    { "r,p" };
  char *r_r_i_string =
    { "r,r,i" };

  /* If the length is zero this is an inherent instruction.  */
  if (strlen (str) == 0)
    return XG_INH;

  for (i = 0, j = 0, num_operands = 1; (c = TOLOWER (*str)) != 0; str++)
    {
      if (c == ' ' || c == '\t' || c == '(' || c == ')' || c == '-' || c == '+')
	continue;

      if (c == ',')
        {
          j++;
          num_operands++;
          i = 0;
          continue;
        }

      if (i > MAX_DETECT_CHARS)
	continue;

      operands_stripped[j][i++] = c;
    }

  /* Process our substrings to see what we have.  */
  for (i = 0, j = 0; num_operands > i; i++)
    {
      stripped_length = strlen (&operands_stripped[i][0]);

      /* Add separator if we have more than one operand.  */
      if (i > 0)
	sh_format[j++] = ',';

      /* Try to process by length first.  */
      if (stripped_length > 3)
        {
          sh_format[j++] = 'i';
        }
      else if (stripped_length == 1)
        {
          sh_format[j++] = 'i';
        }
      else if (stripped_length == 2)
        {
          if (operands_stripped[i][0]
              == 'r' && ISDIGIT (operands_stripped[i][1]))
            {
              sh_format[j++] = 'r';
            }
          else if (operands_stripped[i][0] == 'p'
              && operands_stripped[i][1] == 'c')
            {
              sh_format[j++] = 'p';
            }
          else
            {
              sh_format[j++] = 'i';
            }
        }
      else if (stripped_length == 3)
        {
          if (operands_stripped[i][0] == 'c'
              && (operands_stripped[i][1] == 'c'
                  && operands_stripped[i][2] == 'r'))
            {
              sh_format[j++] = 'c';
            }
          else if (operands_stripped[i][0] == '#')
            {
              sh_format[j++] = 'i';
            }
          else
            {
              sh_format[j++] = 'i';
            }
        }
      else /* default to immediate */
        {
          sh_format[j++] = 'i';
        }
    }

  /* See if we have a match.  */
  if (!strcmp (i_string, sh_format) && num_operands == 1)
    return XG_I;
  if (!strcmp (r_i_string, sh_format) && num_operands == 2)
    return XG_R_I;
  if (!strcmp (r_r_r_string, sh_format) && num_operands == 3)
    return XG_R_R_R;
  if (!strcmp (r_r_string, sh_format) && num_operands == 2)
    return XG_R_R;
  if (!strcmp (r_string, sh_format) && num_operands == 1)
    return XG_R;
  if (!strcmp (r_c_string, sh_format) && num_operands == 2)
    return XG_R_C;
  if (!strcmp (c_r_string, sh_format) && num_operands == 2)
    return XG_C_R;
  if (!strcmp (r_p_string, sh_format) && num_operands == 2)
    return XG_R_P;
  if (!strcmp (r_r_i_string, sh_format) && num_operands == 3)
    return XG_R_R_I;

  return 0;
}

static struct xgate_opcode *
xgate_find_match (struct xgate_opcode_handle *opcode_handle,
		  int numberOfModes,
		  unsigned int sh_format)
{
  int i;

  if (numberOfModes == 0)
    return opcode_handle->opc0[0];

  for (i = 0; i <= numberOfModes; i++)
    if (opcode_handle->opc0[i]->sh_format & sh_format)
      return opcode_handle->opc0[i];

  return NULL;
}

/* Because we are dealing with two different core that view the system
   memory with different offsets, we must differentiate what core a
   symbol belongs to, in order for the linker to cross-link.  */

int
xgate_frob_symbol (symbolS *sym)
{
  asymbol *bfdsym;
  elf_symbol_type *elfsym;

  bfdsym = symbol_get_bfdsym (sym);
  elfsym = elf_symbol_from (bfd_asymbol_bfd (bfdsym), bfdsym);

  gas_assert(elfsym);

  /* Mark the symbol as being *from XGATE  */
  elfsym->internal_elf_sym.st_target_internal = 1;

  return 0;
}
@


1.3
log
@gas/
    * tc-xgate.c (md_begin): Refactored code.
@
text
@d1413 21
@


1.2
log
@Rewrote a loop that caused a seg fault on Windows systems.
@
text
@d52 3
a54 1
/* what this is */
d288 1
a288 1
  unsigned int number_of_handle_rows = 0;
d294 1
a294 1
    xmalloc ((xgate_num_opcodes + 1) * sizeof (struct xgate_opcode));
d297 1
a297 1
	  sizeof(struct xgate_opcode) * (xgate_num_opcodes + 1));
d308 3
a310 2
  for (xgate_opcode_ptr = xgate_op_table; xgate_opcode_ptr->name;
      xgate_opcode_ptr++)
d312 2
a313 5
      if (prev_op_name != 0)
        {
          if (strcmp (prev_op_name, xgate_opcode_ptr->name))
	    number_of_handle_rows++;
        }
d318 1
a318 1
    xmalloc (sizeof(struct xgate_opcode_handle) * (number_of_handle_rows + 1));
d320 1
a320 1
  /* Insert opcode names into hash table, aliasing duplicates.  */
d323 1
d325 1
a325 1
       i++, xgate_opcode_ptr++)
d327 6
a332 1
      if (strcmp (prev_op_name, xgate_opcode_ptr->name) || i == 0)
d336 1
a336 2
	    j++;

d339 2
a340 5
        }
      else
        {
          handle_enum++;
          op_handles[j].opc0[handle_enum] = xgate_opcode_ptr;
a345 6
  for (i = 1; i < (int)number_of_handle_rows; i++)
    {
      hash_insert (xgate_hash, op_handles->name, (char *) op_handles);
      op_handles++;
    }

@


1.1
log
@Add support for Motorola XGATE embedded CPU
@
text
@d344 1
a344 1
  while (op_handles->name)
@

