head	1.113;
access;
symbols
	binutils-2_24-branch:1.113.0.2
	binutils-2_24-branchpoint:1.113
	binutils-2_21_1:1.110
	binutils-2_23_2:1.112
	binutils-2_23_1:1.112
	binutils-2_23:1.112
	binutils-2_23-branch:1.112.0.2
	binutils-2_23-branchpoint:1.112
	binutils-2_22_branch:1.111.0.4
	binutils-2_22:1.111
	binutils-2_22-branch:1.111.0.2
	binutils-2_22-branchpoint:1.111
	binutils-2_21:1.110
	binutils-2_21-branch:1.110.0.2
	binutils-2_21-branchpoint:1.110
	binutils-2_20_1:1.100.2.2
	binutils-2_20:1.100.2.1
	binutils-arc-20081103-branch:1.94.0.6
	binutils-arc-20081103-branchpoint:1.94
	binutils-2_20-branch:1.100.0.2
	binutils-2_20-branchpoint:1.100
	dje-cgen-play1-branch:1.97.0.2
	dje-cgen-play1-branchpoint:1.97
	arc-20081103-branch:1.94.0.4
	arc-20081103-branchpoint:1.94
	binutils-2_19_1:1.94
	binutils-2_19:1.94
	binutils-2_19-branch:1.94.0.2
	binutils-2_19-branchpoint:1.94
	binutils-2_18:1.92
	binutils-2_18-branch:1.92.0.2
	binutils-2_18-branchpoint:1.92
	binutils-csl-coldfire-4_1-32:1.90
	binutils-csl-sourcerygxx-4_1-32:1.90
	binutils-csl-innovasic-fido-3_4_4-33:1.90
	binutils-csl-sourcerygxx-3_4_4-32:1.79
	binutils-csl-coldfire-4_1-30:1.90
	binutils-csl-sourcerygxx-4_1-30:1.90
	binutils-csl-coldfire-4_1-28:1.90
	binutils-csl-sourcerygxx-4_1-29:1.90
	binutils-csl-sourcerygxx-4_1-28:1.90
	binutils-csl-arm-2006q3-27:1.90
	binutils-csl-sourcerygxx-4_1-27:1.90
	binutils-csl-arm-2006q3-26:1.90
	binutils-csl-sourcerygxx-4_1-26:1.90
	binutils-csl-sourcerygxx-4_1-25:1.90
	binutils-csl-sourcerygxx-4_1-24:1.90
	binutils-csl-sourcerygxx-4_1-23:1.90
	binutils-csl-sourcerygxx-4_1-21:1.90
	binutils-csl-arm-2006q3-21:1.90
	binutils-csl-sourcerygxx-4_1-22:1.90
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.90
	binutils-csl-sourcerygxx-4_1-20:1.90
	binutils-csl-arm-2006q3-19:1.90
	binutils-csl-sourcerygxx-4_1-19:1.90
	binutils-csl-sourcerygxx-4_1-18:1.90
	binutils-csl-renesas-4_1-9:1.90
	binutils-csl-sourcerygxx-3_4_4-25:1.79
	binutils-csl-renesas-4_1-8:1.90
	binutils-csl-renesas-4_1-7:1.90
	binutils-csl-renesas-4_1-6:1.90
	binutils-csl-sourcerygxx-4_1-17:1.90
	binutils-csl-sourcerygxx-4_1-14:1.90
	binutils-csl-sourcerygxx-4_1-15:1.90
	binutils-csl-sourcerygxx-4_1-13:1.90
	binutils-2_17:1.90
	binutils-csl-sourcerygxx-4_1-12:1.90
	binutils-csl-sourcerygxx-3_4_4-21:1.90
	binutils-csl-wrs-linux-3_4_4-24:1.79
	binutils-csl-wrs-linux-3_4_4-23:1.79
	binutils-csl-sourcerygxx-4_1-9:1.90
	binutils-csl-sourcerygxx-4_1-8:1.90
	binutils-csl-sourcerygxx-4_1-7:1.90
	binutils-csl-arm-2006q1-6:1.90
	binutils-csl-sourcerygxx-4_1-6:1.90
	binutils-csl-wrs-linux-3_4_4-22:1.79
	binutils-csl-coldfire-4_1-11:1.90
	binutils-csl-sourcerygxx-3_4_4-19:1.90
	binutils-csl-coldfire-4_1-10:1.90
	binutils-csl-sourcerygxx-4_1-5:1.90
	binutils-csl-sourcerygxx-4_1-4:1.90
	binutils-csl-wrs-linux-3_4_4-21:1.79
	binutils-csl-morpho-4_1-4:1.90
	binutils-csl-sourcerygxx-3_4_4-17:1.90
	binutils-csl-wrs-linux-3_4_4-20:1.79
	binutils-2_17-branch:1.90.0.4
	binutils-2_17-branchpoint:1.90
	binutils-csl-2_17-branch:1.90.0.2
	binutils-csl-2_17-branchpoint:1.90
	binutils-csl-gxxpro-3_4-branch:1.79.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.79
	binutils-2_16_1:1.79
	binutils-csl-arm-2005q1b:1.79
	binutils-2_16:1.79
	binutils-csl-arm-2005q1a:1.79
	binutils-csl-arm-2005q1-branch:1.79.0.4
	binutils-csl-arm-2005q1-branchpoint:1.79
	binutils-2_16-branch:1.79.0.2
	binutils-2_16-branchpoint:1.79
	csl-arm-2004-q3d:1.73
	csl-arm-2004-q3:1.73
	binutils-2_15:1.69
	binutils-2_15-branchpoint:1.69
	csl-arm-2004-q1a:1.69
	csl-arm-2004-q1:1.69
	binutils-2_15-branch:1.69.0.6
	cagney_bfdfile-20040213-branch:1.69.0.4
	cagney_bfdfile-20040213-branchpoint:1.69
	cagney_bigcore-20040122-branch:1.69.0.2
	cagney_bigcore-20040122-branchpoint:1.69
	csl-arm-2003-q4:1.69
	binutils-2_14:1.67
	binutils-2_14-branch:1.67.0.2
	binutils-2_14-branchpoint:1.67
	binutils-2_13_2_1:1.62
	binutils-2_13_2:1.62
	binutils-2_13_1:1.62
	binutils-2_13:1.62
	binutils-2_13-branchpoint:1.62
	binutils-2_13-branch:1.62.0.2
	binutils-2_12_1:1.56.2.1
	binutils-2_12:1.56
	binutils-2_12-branch:1.56.0.2
	binutils-2_12-branchpoint:1.56
	cygnus_cvs_20020108_pre:1.54
	binutils-2_11_2:1.39.2.2
	binutils-2_11_1:1.39.2.2
	binutils-2_11:1.39
	x86_64versiong3:1.41
	binutils-2_11-branch:1.39.0.2
	binutils-2_10_1:1.22.2.1
	binutils-2_10:1.22
	binutils-2_10-branch:1.22.0.2
	binutils-2_10-branchpoint:1.22
	binutils_latest_snapshot:1.113
	repo-unification-2000-02-06:1.21
	binu_ss_19990721:1.6
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.113
date	2012.10.18.17.00.56;	author ktietz;	state Exp;
branches;
next	1.112;

1.112
date	2011.09.27.18.57.22;	author ktietz;	state Exp;
branches;
next	1.111;

1.111
date	2011.05.18.07.58.34;	author gingold;	state Exp;
branches;
next	1.110;

1.110
date	2010.11.05.04.58.24;	author davek;	state Exp;
branches;
next	1.109;

1.109
date	2010.10.26.03.44.39;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2010.10.25.12.38.42;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2010.10.08.14.00.50;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2010.07.11.08.45.50;	author ktietz;	state Exp;
branches;
next	1.105;

1.105
date	2010.06.28.14.06.56;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2010.01.27.22.01.36;	author davek;	state Exp;
branches;
next	1.103;

1.103
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2009.11.02.11.49.48;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2009.09.09.13.19.51;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2009.08.17.11.45.22;	author ktietz;	state Exp;
branches;
next	1.98;

1.98
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2009.05.19.16.08.04;	author davek;	state Exp;
branches;
next	1.95;

1.95
date	2009.05.17.20.09.02;	author ktietz;	state Exp;
branches;
next	1.94;

1.94
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2007.09.17.17.15.30;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.90;

1.90
date	2005.11.07.17.57.00;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2005.10.27.07.40.07;	author jbeulich;	state Exp;
branches;
next	1.88;

1.88
date	2005.10.24.17.51.42;	author aoliva;	state Exp;
branches;
next	1.87;

1.87
date	2005.08.17.08.58.01;	author dannysmith;	state Exp;
branches;
next	1.86;

1.86
date	2005.08.11.01.25.24;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2005.06.07.17.54.15;	author zack;	state Exp;
branches;
next	1.84;

1.84
date	2005.05.05.09.12.52;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2005.04.29.00.22.28;	author bje;	state Exp;
branches;
next	1.82;

1.82
date	2005.04.19.15.05.07;	author jbeulich;	state Exp;
branches;
next	1.81;

1.81
date	2005.03.27.17.53.20;	author ian;	state Exp;
branches;
next	1.80;

1.80
date	2005.03.16.14.56.59;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2005.03.01.11.24.31;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2005.02.22.00.50.05;	author hjl;	state Exp;
branches;
next	1.77;

1.77
date	2005.02.17.13.46.03;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2005.01.31.23.18.24;	author bje;	state Exp;
branches;
next	1.75;

1.75
date	2004.11.19.12.20.24;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2004.11.08.08.12.45;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2004.07.27.11.37.08;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	2004.07.06.15.30.26;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2004.07.03.16.07.49;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.15.01.16.35;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2003.11.20.00.01.54;	author kazu;	state Exp;
branches;
next	1.68;

1.68
date	2003.10.04.11.06.31;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2002.12.12.22.46.47;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2002.11.30.08.39.42;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.04.16.10.56;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2002.09.05.00.01.16;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2002.08.28.10.38.48;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.27.16.16.04;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.23.10.45.14;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.23.08.08.47;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.11.12.08.26;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.09.13.12.57;	author kazu;	state Exp;
branches;
next	1.56;

1.56
date	2002.01.31.17.33.00;	author nickc;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2002.01.22.01.09.49;	author dj;	state Exp;
branches;
next	1.54;

1.54
date	2001.11.15.21.28.54;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.08.18.14.43;	author trix;	state Exp;
branches;
next	1.52;

1.52
date	2001.09.18.10.08.14;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.09.14.42.07;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.11.09.26.27;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.30.10.09.40;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.10.14.07.11;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.25.09.40.12;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.24.21.39.09;	author trix;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.22.10.23.49;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2001.04.25.09.11.31;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.30.07.07.10;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.27.01.56.26;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.11.23.22.25;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.28.10.07.55;	author rth;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2000.12.01.17.11.57;	author pb;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.28.21.29.02;	author kazu;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.08.00.24.23;	author hjl;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.12.21.49.09;	author kazu;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.22.19.14.31;	author hjl;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.14.19.41.40;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.24.17.50.35;	author dj;	state Exp;
branches;
next	1.31;

1.31
date	2000.07.20.23.38.05;	author dj;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.17.23.27.31;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.12.16.45.46;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.06.17.21.00;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.06.17.18.10;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.29.23.54.13;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.17.22.00.30;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.22.21.19.43;	author hp;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.26.15.09.43;	author cpopetz;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.22.07.50.13;	author ian;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.02.03.18.20.23;	author twall;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.26.22.48.31;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	99.09.12.03.44.41;	author ian;	state Exp;
branches;
next	1.18;

1.18
date	99.09.12.03.07.49;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	99.09.12.02.59.54;	author ian;	state Exp;
branches;
next	1.16;

1.16
date	99.09.12.02.55.58;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	99.09.12.02.49.28;	author ian;	state Exp;
branches;
next	1.14;

1.14
date	99.09.12.02.39.52;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	99.09.12.02.34.00;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	99.09.12.02.27.58;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	99.09.12.02.08.55;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	99.09.07.03.26.58;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.09.02.15.12.01;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	99.08.08.16.53.29;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.08.03.15.29.03;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.26.19.35.44;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.19.14.04.44;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.12.16.49.46;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.12;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.17.03.21.49;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.100.2.1
date	2009.09.09.13.20.28;	author amodra;	state Exp;
branches;
next	1.100.2.2;

1.100.2.2
date	2010.01.27.22.08.23;	author davek;	state Exp;
branches;
next	;

1.56.2.1
date	2002.05.11.16.49.58;	author drow;	state Exp;
branches;
next	;

1.39.2.1
date	2001.06.07.03.15.26;	author amodra;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2001.06.11.10.04.47;	author amodra;	state Exp;
branches;
next	;

1.22.2.1
date	2000.10.14.21.05.59;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.113
log
@        * config/obj-coff.c: Add include of struc-symbol.h header.
        (coff_frob_symbol): Check that function-aux entries are generated for
        defined symbols only.
@
text
@/* coff object file format
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
   Free Software Foundation, Inc.

   This file is part of GAS.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#define OBJ_HEADER "obj-coff.h"

#include "as.h"
#include "safe-ctype.h"
#include "obstack.h"
#include "subsegs.h"
#include "struc-symbol.h"

#ifdef TE_PE
#include "coff/pe.h"
#endif

#ifdef OBJ_XCOFF
#include "coff/xcoff.h"
#endif

#define streq(a,b)     (strcmp ((a), (b)) == 0)
#define strneq(a,b,n)  (strncmp ((a), (b), (n)) == 0)

/* I think this is probably always correct.  */
#ifndef KEEP_RELOC_INFO
#define KEEP_RELOC_INFO
#endif

/* obj_coff_section will use this macro to set a new section's
   attributes when a directive has no valid flags or the "w" flag is
   used.  This default should be appropriate for most.  */
#ifndef TC_COFF_SECTION_DEFAULT_ATTRIBUTES
#define TC_COFF_SECTION_DEFAULT_ATTRIBUTES (SEC_LOAD | SEC_DATA)
#endif

/* This is used to hold the symbol built by a sequence of pseudo-ops
   from .def and .endef.  */
static symbolS *def_symbol_in_progress;
#ifdef TE_PE
/* PE weak alternate symbols begin with this string.  */
static const char weak_altprefix[] = ".weak.";
#endif /* TE_PE */

#include "obj-coff-seh.c"

typedef struct
  {
    unsigned long chunk_size;
    unsigned long element_size;
    unsigned long size;
    char *data;
    unsigned long pointer;
  }
stack;


/* Stack stuff.  */

static stack *
stack_init (unsigned long chunk_size,
	    unsigned long element_size)
{
  stack *st;

  st = malloc (sizeof (* st));
  if (!st)
    return NULL;
  st->data = malloc (chunk_size);
  if (!st->data)
    {
      free (st);
      return NULL;
    }
  st->pointer = 0;
  st->size = chunk_size;
  st->chunk_size = chunk_size;
  st->element_size = element_size;
  return st;
}

static char *
stack_push (stack *st, char *element)
{
  if (st->pointer + st->element_size >= st->size)
    {
      st->size += st->chunk_size;
      if ((st->data = xrealloc (st->data, st->size)) == NULL)
	return NULL;
    }
  memcpy (st->data + st->pointer, element, st->element_size);
  st->pointer += st->element_size;
  return st->data + st->pointer;
}

static char *
stack_pop (stack *st)
{
  if (st->pointer < st->element_size)
    {
      st->pointer = 0;
      return NULL;
    }
  st->pointer -= st->element_size;
  return st->data + st->pointer;
}

/* Maintain a list of the tagnames of the structures.  */

static struct hash_control *tag_hash;

static void
tag_init (void)
{
  tag_hash = hash_new ();
}

static void
tag_insert (const char *name, symbolS *symbolP)
{
  const char *error_string;

  if ((error_string = hash_jam (tag_hash, name, (char *) symbolP)))
    as_fatal (_("Inserting \"%s\" into structure table failed: %s"),
	      name, error_string);
}

static symbolS *
tag_find (char *name)
{
  return (symbolS *) hash_find (tag_hash, name);
}

static symbolS *
tag_find_or_make (char *name)
{
  symbolS *symbolP;

  if ((symbolP = tag_find (name)) == NULL)
    {
      symbolP = symbol_new (name, undefined_section,
			    0, &zero_address_frag);

      tag_insert (S_GET_NAME (symbolP), symbolP);
      symbol_table_insert (symbolP);
    }

  return symbolP;
}

/* We accept the .bss directive to set the section for backward
   compatibility with earlier versions of gas.  */

static void
obj_coff_bss (int ignore ATTRIBUTE_UNUSED)
{
  if (*input_line_pointer == '\n')
    subseg_new (".bss", get_absolute_expression ());
  else
    s_lcomm (0);
}

#ifdef TE_PE
/* Called from read.c:s_comm after we've parsed .comm symbol, size.
   Parse a possible alignment value.  */

static symbolS *
obj_coff_common_parse (int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT size)
{
  addressT align = 0;

  if (*input_line_pointer == ',')
    {
      align = parse_align (0);
      if (align == (addressT) -1)
	return NULL;
    }

  S_SET_VALUE (symbolP, size);
  S_SET_EXTERNAL (symbolP);
  S_SET_SEGMENT (symbolP, bfd_com_section_ptr);

  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  /* There is no S_SET_ALIGN (symbolP, align) in COFF/PE.
     Instead we must add a note to the .drectve section.  */
  if (align)
    {
      segT current_seg = now_seg;
      subsegT current_subseg = now_subseg;
      flagword oldflags;
      asection *sec;
      size_t pfxlen, numlen;
      char *frag;
      char numbuff[20];

      sec = subseg_new (".drectve", 0);
      oldflags = bfd_get_section_flags (stdoutput, sec);
      if (oldflags == SEC_NO_FLAGS)
	{
	  if (!bfd_set_section_flags (stdoutput, sec,
		TC_COFF_SECTION_DEFAULT_ATTRIBUTES))
	    as_warn (_("error setting flags for \"%s\": %s"),
		bfd_section_name (stdoutput, sec),
		bfd_errmsg (bfd_get_error ()));
	}

      /* Emit a string.  Note no NUL-termination.  */
      pfxlen = strlen (" -aligncomm:") + 2 + strlen (S_GET_NAME (symbolP)) + 1;
      numlen = snprintf (numbuff, sizeof (numbuff), "%d", (int) align);
      frag = frag_more (pfxlen + numlen);
      (void) sprintf (frag, " -aligncomm:\"%s\",", S_GET_NAME (symbolP));
      memcpy (frag + pfxlen, numbuff, numlen);
      /* Restore original subseg. */
      subseg_set (current_seg, current_subseg);
    }

  return symbolP;
}

static void
obj_coff_comm (int ignore ATTRIBUTE_UNUSED)
{
  s_comm_internal (ignore, obj_coff_common_parse);
}
#endif /* TE_PE */

#define GET_FILENAME_STRING(X) \
  ((char *) (&((X)->sy_symbol.ost_auxent->x_file.x_n.x_offset))[1])

/* @@@@ Ick.  */
static segT
fetch_coff_debug_section (void)
{
  static segT debug_section;

  if (!debug_section)
    {
      const asymbol *s;

      s = bfd_make_debug_symbol (stdoutput, NULL, 0);
      gas_assert (s != 0);
      debug_section = s->section;
    }
  return debug_section;
}

void
SA_SET_SYM_ENDNDX (symbolS *sym, symbolS *val)
{
  combined_entry_type *entry, *p;

  entry = &coffsymbol (symbol_get_bfdsym (sym))->native[1];
  p = coffsymbol (symbol_get_bfdsym (val))->native;
  entry->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p = p;
  entry->fix_end = 1;
}

static void
SA_SET_SYM_TAGNDX (symbolS *sym, symbolS *val)
{
  combined_entry_type *entry, *p;

  entry = &coffsymbol (symbol_get_bfdsym (sym))->native[1];
  p = coffsymbol (symbol_get_bfdsym (val))->native;
  entry->u.auxent.x_sym.x_tagndx.p = p;
  entry->fix_tag = 1;
}

static int
S_GET_DATA_TYPE (symbolS *sym)
{
  return coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_type;
}

int
S_SET_DATA_TYPE (symbolS *sym, int val)
{
  coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_type = val;
  return val;
}

int
S_GET_STORAGE_CLASS (symbolS *sym)
{
  return coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_sclass;
}

int
S_SET_STORAGE_CLASS (symbolS *sym, int val)
{
  coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_sclass = val;
  return val;
}

/* Merge a debug symbol containing debug information into a normal symbol.  */

static void
c_symbol_merge (symbolS *debug, symbolS *normal)
{
  S_SET_DATA_TYPE (normal, S_GET_DATA_TYPE (debug));
  S_SET_STORAGE_CLASS (normal, S_GET_STORAGE_CLASS (debug));

  if (S_GET_NUMBER_AUXILIARY (debug) > S_GET_NUMBER_AUXILIARY (normal))
    /* Take the most we have.  */
    S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));

  if (S_GET_NUMBER_AUXILIARY (debug) > 0)
    /* Move all the auxiliary information.  */
    memcpy (SYM_AUXINFO (normal), SYM_AUXINFO (debug),
	    (S_GET_NUMBER_AUXILIARY (debug)
	     * sizeof (*SYM_AUXINFO (debug))));

  /* Move the debug flags.  */
  SF_SET_DEBUG_FIELD (normal, SF_GET_DEBUG_FIELD (debug));
}

void
c_dot_file_symbol (const char *filename, int appfile ATTRIBUTE_UNUSED)
{
  symbolS *symbolP;

  /* BFD converts filename to a .file symbol with an aux entry.  It
     also handles chaining.  */
  symbolP = symbol_new (filename, bfd_abs_section_ptr, 0, &zero_address_frag);

  S_SET_STORAGE_CLASS (symbolP, C_FILE);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);

  symbol_get_bfdsym (symbolP)->flags = BSF_DEBUGGING;

#ifndef NO_LISTING
  {
    extern int listing;

    if (listing)
      listing_source_file (filename);
  }
#endif

  /* Make sure that the symbol is first on the symbol chain.  */
  if (symbol_rootP != symbolP)
    {
      symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
      symbol_insert (symbolP, symbol_rootP, &symbol_rootP, &symbol_lastP);
    }
}

/* Line number handling.  */

struct line_no
{
  struct line_no *next;
  fragS *frag;
  alent l;
};

int coff_line_base;

/* Symbol of last function, which we should hang line#s off of.  */
static symbolS *line_fsym;

#define in_function()		(line_fsym != 0)
#define clear_function()	(line_fsym = 0)
#define set_function(F)		(line_fsym = (F), coff_add_linesym (F))


void
coff_obj_symbol_new_hook (symbolS *symbolP)
{
  long   sz = (OBJ_COFF_MAX_AUXENTRIES + 1) * sizeof (combined_entry_type);
  char * s  = xmalloc (sz);

  memset (s, 0, sz);
  coffsymbol (symbol_get_bfdsym (symbolP))->native = (combined_entry_type *) s;

  S_SET_DATA_TYPE (symbolP, T_NULL);
  S_SET_STORAGE_CLASS (symbolP, 0);
  S_SET_NUMBER_AUXILIARY (symbolP, 0);

  if (S_IS_STRING (symbolP))
    SF_SET_STRING (symbolP);

  if (S_IS_LOCAL (symbolP))
    SF_SET_LOCAL (symbolP);
}

void
coff_obj_symbol_clone_hook (symbolS *newsymP, symbolS *orgsymP)
{
  long sz = (OBJ_COFF_MAX_AUXENTRIES + 1) * sizeof (combined_entry_type);
  combined_entry_type * s = xmalloc (sz);

  memcpy (s, coffsymbol (symbol_get_bfdsym (orgsymP))->native, sz);
  coffsymbol (symbol_get_bfdsym (newsymP))->native = s;

  SF_SET (newsymP, SF_GET (orgsymP));
}


/* Handle .ln directives.  */

static symbolS *current_lineno_sym;
static struct line_no *line_nos;
/* FIXME:  Blindly assume all .ln directives will be in the .text section.  */
int coff_n_line_nos;

static void
add_lineno (fragS * frag, addressT offset, int num)
{
  struct line_no * new_line = xmalloc (sizeof (* new_line));

  if (!current_lineno_sym)
    abort ();

#ifndef OBJ_XCOFF
  /* The native aix assembler accepts negative line number.  */

  if (num <= 0)
    {
      /* Zero is used as an end marker in the file.  */
      as_warn (_("Line numbers must be positive integers\n"));
      num = 1;
    }
#endif /* OBJ_XCOFF */
  new_line->next = line_nos;
  new_line->frag = frag;
  new_line->l.line_number = num;
  new_line->l.u.offset = offset;
  line_nos = new_line;
  coff_n_line_nos++;
}

void
coff_add_linesym (symbolS *sym)
{
  if (line_nos)
    {
      coffsymbol (symbol_get_bfdsym (current_lineno_sym))->lineno =
	(alent *) line_nos;
      coff_n_line_nos++;
      line_nos = 0;
    }
  current_lineno_sym = sym;
}

static void
obj_coff_ln (int appline)
{
  int l;

  if (! appline && def_symbol_in_progress != NULL)
    {
      as_warn (_(".ln pseudo-op inside .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  l = get_absolute_expression ();

  /* If there is no lineno symbol, treat a .ln
     directive as if it were a .appline directive.  */
  if (appline || current_lineno_sym == NULL)
    new_logical_line ((char *) NULL, l - 1);
  else
    add_lineno (frag_now, frag_now_fix (), l);

#ifndef NO_LISTING
  {
    extern int listing;

    if (listing)
      {
	if (! appline)
	  l += coff_line_base - 1;
	listing_source_line (l);
      }
  }
#endif

  demand_empty_rest_of_line ();
}

/* .loc is essentially the same as .ln; parse it for assembler
   compatibility.  */

static void
obj_coff_loc (int ignore ATTRIBUTE_UNUSED)
{
  int lineno;

  /* FIXME: Why do we need this check?  We need it for ECOFF, but why
     do we need it for COFF?  */
  if (now_seg != text_section)
    {
      as_warn (_(".loc outside of .text"));
      demand_empty_rest_of_line ();
      return;
    }

  if (def_symbol_in_progress != NULL)
    {
      as_warn (_(".loc pseudo-op inside .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  /* Skip the file number.  */
  SKIP_WHITESPACE ();
  get_absolute_expression ();
  SKIP_WHITESPACE ();

  lineno = get_absolute_expression ();

#ifndef NO_LISTING
  {
    extern int listing;

    if (listing)
      {
	lineno += coff_line_base - 1;
	listing_source_line (lineno);
      }
  }
#endif

  demand_empty_rest_of_line ();

  add_lineno (frag_now, frag_now_fix (), lineno);
}

/* Handle the .ident pseudo-op.  */

static void
obj_coff_ident (int ignore ATTRIBUTE_UNUSED)
{
  segT current_seg = now_seg;
  subsegT current_subseg = now_subseg;

#ifdef TE_PE
  {
    segT sec;

    /* We could put it in .comment, but that creates an extra section
       that shouldn't be loaded into memory, which requires linker
       changes...  For now, until proven otherwise, use .rdata.  */
    sec = subseg_new (".rdata$zzz", 0);
    bfd_set_section_flags (stdoutput, sec,
			   ((SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA)
			    & bfd_applicable_section_flags (stdoutput)));
  }
#else
  subseg_new (".comment", 0);
#endif

  stringer (8 + 1);
  subseg_set (current_seg, current_subseg);
}

/* Handle .def directives.

   One might ask : why can't we symbol_new if the symbol does not
   already exist and fill it with debug information.  Because of
   the C_EFCN special symbol. It would clobber the value of the
   function symbol before we have a chance to notice that it is
   a C_EFCN. And a second reason is that the code is more clear this
   way. (at least I think it is :-).  */

#define SKIP_SEMI_COLON()	while (*input_line_pointer++ != ';')
#define SKIP_WHITESPACES()	while (*input_line_pointer == ' ' || \
				       *input_line_pointer == '\t')  \
                                  input_line_pointer++;

static void
obj_coff_def (int what ATTRIBUTE_UNUSED)
{
  char name_end;		/* Char after the end of name.  */
  char *symbol_name;		/* Name of the debug symbol.  */
  char *symbol_name_copy;	/* Temporary copy of the name.  */
  unsigned int symbol_name_length;

  if (def_symbol_in_progress != NULL)
    {
      as_warn (_(".def pseudo-op used inside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  SKIP_WHITESPACES ();

  symbol_name = input_line_pointer;
  name_end = get_symbol_end ();
  symbol_name_length = strlen (symbol_name);
  symbol_name_copy = xmalloc (symbol_name_length + 1);
  strcpy (symbol_name_copy, symbol_name);
#ifdef tc_canonicalize_symbol_name
  symbol_name_copy = tc_canonicalize_symbol_name (symbol_name_copy);
#endif

  /* Initialize the new symbol.  */
  def_symbol_in_progress = symbol_make (symbol_name_copy);
  symbol_set_frag (def_symbol_in_progress, &zero_address_frag);
  S_SET_VALUE (def_symbol_in_progress, 0);

  if (S_IS_STRING (def_symbol_in_progress))
    SF_SET_STRING (def_symbol_in_progress);

  *input_line_pointer = name_end;

  demand_empty_rest_of_line ();
}

static void
obj_coff_endef (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = NULL;

  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".endef pseudo-op used outside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  /* Set the section number according to storage class.  */
  switch (S_GET_STORAGE_CLASS (def_symbol_in_progress))
    {
    case C_STRTAG:
    case C_ENTAG:
    case C_UNTAG:
      SF_SET_TAG (def_symbol_in_progress);
      /* Fall through.  */
    case C_FILE:
    case C_TPDEF:
      SF_SET_DEBUG (def_symbol_in_progress);
      S_SET_SEGMENT (def_symbol_in_progress, fetch_coff_debug_section ());
      break;

    case C_EFCN:
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol.  */
      /* Fall through.  */
    case C_BLOCK:
      SF_SET_PROCESS (def_symbol_in_progress);	/* Will need processing before writing.  */
      /* Fall through.  */
    case C_FCN:
      {
	const char *name;

	S_SET_SEGMENT (def_symbol_in_progress, text_section);

	name = S_GET_NAME (def_symbol_in_progress);
	if (name[0] == '.' && name[2] == 'f' && name[3] == '\0')
	  {
	    switch (name[1])
	      {
	      case 'b':
		/* .bf */
		if (! in_function ())
		  as_warn (_("`%s' symbol without preceding function"), name);
		/* Will need relocating.  */
		SF_SET_PROCESS (def_symbol_in_progress);
		clear_function ();
		break;
#ifdef TE_PE
	      case 'e':
		/* .ef */
		/* The MS compilers output the actual endline, not the
		   function-relative one... we want to match without
		   changing the assembler input.  */
		SA_SET_SYM_LNNO (def_symbol_in_progress,
				 (SA_GET_SYM_LNNO (def_symbol_in_progress)
				  + coff_line_base));
		break;
#endif
	      }
	  }
      }
      break;

#ifdef C_AUTOARG
    case C_AUTOARG:
#endif /* C_AUTOARG */
    case C_AUTO:
    case C_REG:
    case C_ARG:
    case C_REGPARM:
    case C_FIELD:

    /* According to the COFF documentation:

       http://osr5doc.sco.com:1996/topics/COFF_SectNumFld.html

       A special section number (-2) marks symbolic debugging symbols,
       including structure/union/enumeration tag names, typedefs, and
       the name of the file. A section number of -1 indicates that the
       symbol has a value but is not relocatable. Examples of
       absolute-valued symbols include automatic and register variables,
       function arguments, and .eos symbols.

       But from Ian Lance Taylor:

       http://sources.redhat.com/ml/binutils/2000-08/msg00202.html

       the actual tools all marked them as section -1. So the GNU COFF
       assembler follows historical COFF assemblers.

       However, it causes problems for djgpp

       http://sources.redhat.com/ml/binutils/2000-08/msg00210.html

       By defining STRICTCOFF, a COFF port can make the assembler to
       follow the documented behavior.  */
#ifdef STRICTCOFF
    case C_MOS:
    case C_MOE:
    case C_MOU:
    case C_EOS:
#endif
      SF_SET_DEBUG (def_symbol_in_progress);
      S_SET_SEGMENT (def_symbol_in_progress, absolute_section);
      break;

#ifndef STRICTCOFF
    case C_MOS:
    case C_MOE:
    case C_MOU:
    case C_EOS:
      S_SET_SEGMENT (def_symbol_in_progress, absolute_section);
      break;
#endif

    case C_EXT:
    case C_WEAKEXT:
#ifdef TE_PE
    case C_NT_WEAK:
#endif
    case C_STAT:
    case C_LABEL:
      /* Valid but set somewhere else (s_comm, s_lcomm, colon).  */
      break;

    default:
    case C_USTATIC:
    case C_EXTDEF:
    case C_ULABEL:
      as_warn (_("unexpected storage class %d"),
	       S_GET_STORAGE_CLASS (def_symbol_in_progress));
      break;
    }

  /* Now that we have built a debug symbol, try to find if we should
     merge with an existing symbol or not.  If a symbol is C_EFCN or
     absolute_section or untagged SEG_DEBUG it never merges.  We also
     don't merge labels, which are in a different namespace, nor
     symbols which have not yet been defined since they are typically
     unique, nor do we merge tags with non-tags.  */

  /* Two cases for functions.  Either debug followed by definition or
     definition followed by debug.  For definition first, we will
     merge the debug symbol into the definition.  For debug first, the
     lineno entry MUST point to the definition function or else it
     will point off into space when obj_crawl_symbol_chain() merges
     the debug symbol into the real symbol.  Therefor, let's presume
     the debug symbol is a real function reference.  */

  /* FIXME-SOON If for some reason the definition label/symbol is
     never seen, this will probably leave an undefined symbol at link
     time.  */

  if (S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_EFCN
      || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_LABEL
      || (streq (bfd_get_section_name (stdoutput,
				       S_GET_SEGMENT (def_symbol_in_progress)),
		 "*DEBUG*")
	  && !SF_GET_TAG (def_symbol_in_progress))
      || S_GET_SEGMENT (def_symbol_in_progress) == absolute_section
      || ! symbol_constant_p (def_symbol_in_progress)
      || (symbolP = symbol_find (S_GET_NAME (def_symbol_in_progress))) == NULL
      || SF_GET_TAG (def_symbol_in_progress) != SF_GET_TAG (symbolP))
    {
      /* If it already is at the end of the symbol list, do nothing */
      if (def_symbol_in_progress != symbol_lastP)
	{
	  symbol_remove (def_symbol_in_progress, &symbol_rootP, &symbol_lastP);
	  symbol_append (def_symbol_in_progress, symbol_lastP, &symbol_rootP,
			 &symbol_lastP);
	}
    }
  else
    {
      /* This symbol already exists, merge the newly created symbol
	 into the old one.  This is not mandatory. The linker can
	 handle duplicate symbols correctly. But I guess that it save
	 a *lot* of space if the assembly file defines a lot of
	 symbols. [loic]  */

      /* The debug entry (def_symbol_in_progress) is merged into the
	 previous definition.  */

      c_symbol_merge (def_symbol_in_progress, symbolP);
      symbol_remove (def_symbol_in_progress, &symbol_rootP, &symbol_lastP);

      def_symbol_in_progress = symbolP;

      if (SF_GET_FUNCTION (def_symbol_in_progress)
	  || SF_GET_TAG (def_symbol_in_progress)
	  || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_STAT)
	{
	  /* For functions, and tags, and static symbols, the symbol
	     *must* be where the debug symbol appears.  Move the
	     existing symbol to the current place.  */
	  /* If it already is at the end of the symbol list, do nothing.  */
	  if (def_symbol_in_progress != symbol_lastP)
	    {
	      symbol_remove (def_symbol_in_progress, &symbol_rootP, &symbol_lastP);
	      symbol_append (def_symbol_in_progress, symbol_lastP, &symbol_rootP, &symbol_lastP);
	    }
	}
    }

  if (SF_GET_TAG (def_symbol_in_progress))
    {
      symbolS *oldtag;

      oldtag = symbol_find (S_GET_NAME (def_symbol_in_progress));
      if (oldtag == NULL || ! SF_GET_TAG (oldtag))
	tag_insert (S_GET_NAME (def_symbol_in_progress),
		    def_symbol_in_progress);
    }

  if (SF_GET_FUNCTION (def_symbol_in_progress))
    {
      set_function (def_symbol_in_progress);
      SF_SET_PROCESS (def_symbol_in_progress);

      if (symbolP == NULL)
	/* That is, if this is the first time we've seen the
	   function.  */
	symbol_table_insert (def_symbol_in_progress);

    }

  def_symbol_in_progress = NULL;
  demand_empty_rest_of_line ();
}

static void
obj_coff_dim (int ignore ATTRIBUTE_UNUSED)
{
  int d_index;

  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".dim pseudo-op used outside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);

  for (d_index = 0; d_index < DIMNUM; d_index++)
    {
      SKIP_WHITESPACES ();
      SA_SET_SYM_DIMEN (def_symbol_in_progress, d_index,
			get_absolute_expression ());

      switch (*input_line_pointer)
	{
	case ',':
	  input_line_pointer++;
	  break;

	default:
	  as_warn (_("badly formed .dim directive ignored"));
	  /* Fall through.  */
	case '\n':
	case ';':
	  d_index = DIMNUM;
	  break;
	}
    }

  demand_empty_rest_of_line ();
}

static void
obj_coff_line (int ignore ATTRIBUTE_UNUSED)
{
  int this_base;

  if (def_symbol_in_progress == NULL)
    {
      /* Probably stabs-style line?  */
      obj_coff_ln (0);
      return;
    }

  this_base = get_absolute_expression ();
  if (streq (".bf", S_GET_NAME (def_symbol_in_progress)))
    coff_line_base = this_base;

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  SA_SET_SYM_LNNO (def_symbol_in_progress, this_base);

  demand_empty_rest_of_line ();

#ifndef NO_LISTING
  if (streq (".bf", S_GET_NAME (def_symbol_in_progress)))
    {
      extern int listing;

      if (listing)
	listing_source_line ((unsigned int) this_base);
    }
#endif
}

static void
obj_coff_size (int ignore ATTRIBUTE_UNUSED)
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".size pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  SA_SET_SYM_SIZE (def_symbol_in_progress, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
obj_coff_scl (int ignore ATTRIBUTE_UNUSED)
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".scl pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_STORAGE_CLASS (def_symbol_in_progress, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
obj_coff_tag (int ignore ATTRIBUTE_UNUSED)
{
  char *symbol_name;
  char name_end;

  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".tag pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  symbol_name = input_line_pointer;
  name_end = get_symbol_end ();

#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif

  /* Assume that the symbol referred to by .tag is always defined.
     This was a bad assumption.  I've added find_or_make. xoxorich.  */
  SA_SET_SYM_TAGNDX (def_symbol_in_progress,
		     tag_find_or_make (symbol_name));
  if (SA_GET_SYM_TAGNDX (def_symbol_in_progress) == 0L)
    as_warn (_("tag not found for .tag %s"), symbol_name);

  SF_SET_TAGGED (def_symbol_in_progress);
  *input_line_pointer = name_end;

  demand_empty_rest_of_line ();
}

static void
obj_coff_type (int ignore ATTRIBUTE_UNUSED)
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".type pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_DATA_TYPE (def_symbol_in_progress, get_absolute_expression ());

  if (ISFCN (S_GET_DATA_TYPE (def_symbol_in_progress)) &&
      S_GET_STORAGE_CLASS (def_symbol_in_progress) != C_TPDEF)
    SF_SET_FUNCTION (def_symbol_in_progress);

  demand_empty_rest_of_line ();
}

static void
obj_coff_val (int ignore ATTRIBUTE_UNUSED)
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".val pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  if (is_name_beginner (*input_line_pointer))
    {
      char *symbol_name = input_line_pointer;
      char name_end = get_symbol_end ();

#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif
      if (streq (symbol_name, "."))
	{
	  /* If the .val is != from the .def (e.g. statics).  */
	  symbol_set_frag (def_symbol_in_progress, frag_now);
	  S_SET_VALUE (def_symbol_in_progress, (valueT) frag_now_fix ());
	}
      else if (! streq (S_GET_NAME (def_symbol_in_progress), symbol_name))
	{
	  expressionS exp;

	  exp.X_op = O_symbol;
	  exp.X_add_symbol = symbol_find_or_make (symbol_name);
	  exp.X_op_symbol = NULL;
	  exp.X_add_number = 0;
	  symbol_set_value_expression (def_symbol_in_progress, &exp);

	  /* If the segment is undefined when the forward reference is
	     resolved, then copy the segment id from the forward
	     symbol.  */
	  SF_SET_GET_SEGMENT (def_symbol_in_progress);

	  /* FIXME: gcc can generate address expressions here in
	     unusual cases (search for "obscure" in sdbout.c).  We
	     just ignore the offset here, thus generating incorrect
	     debugging information.  We ignore the rest of the line
	     just below.  */
	}
      /* Otherwise, it is the name of a non debug symbol and its value
         will be calculated later.  */
      *input_line_pointer = name_end;
    }
  else
    {
      S_SET_VALUE (def_symbol_in_progress, get_absolute_expression ());
    }

  demand_empty_rest_of_line ();
}

#ifdef TE_PE

/* Return nonzero if name begins with weak alternate symbol prefix.  */

static int
weak_is_altname (const char * name)
{
  return strneq (name, weak_altprefix, sizeof (weak_altprefix) - 1);
}

/* Return the name of the alternate symbol
   name corresponding to a weak symbol's name.  */

static const char *
weak_name2altname (const char * name)
{
  char *alt_name;

  alt_name = xmalloc (sizeof (weak_altprefix) + strlen (name));
  strcpy (alt_name, weak_altprefix);
  return strcat (alt_name, name);
}

/* Return the name of the weak symbol corresponding to an
   alternate symbol.  */

static const char *
weak_altname2name (const char * name)
{
  gas_assert (weak_is_altname (name));
  return xstrdup (name + 6);
}

/* Make a weak symbol name unique by
   appending the name of an external symbol.  */

static const char *
weak_uniquify (const char * name)
{
  char *ret;
  const char * unique = "";

#ifdef TE_PE
  if (an_external_name != NULL)
    unique = an_external_name;
#endif
  gas_assert (weak_is_altname (name));

  ret = xmalloc (strlen (name) + strlen (unique) + 2);
  strcpy (ret, name);
  strcat (ret, ".");
  strcat (ret, unique);
  return ret;
}

void
pecoff_obj_set_weak_hook (symbolS *symbolP)
{
  symbolS *alternateP;

  /* See _Microsoft Portable Executable and Common Object
     File Format Specification_, section 5.5.3.
     Create a symbol representing the alternate value.
     coff_frob_symbol will set the value of this symbol from
     the value of the weak symbol itself.  */
  S_SET_STORAGE_CLASS (symbolP, C_NT_WEAK);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);
  SA_SET_SYM_FSIZE (symbolP, IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY);

  alternateP = symbol_find_or_make (weak_name2altname (S_GET_NAME (symbolP)));
  S_SET_EXTERNAL (alternateP);
  S_SET_STORAGE_CLASS (alternateP, C_NT_WEAK);

  SA_SET_SYM_TAGNDX (symbolP, alternateP);
}

void
pecoff_obj_clear_weak_hook (symbolS *symbolP)
{
  symbolS *alternateP;

  S_SET_STORAGE_CLASS (symbolP, 0);
  SA_SET_SYM_FSIZE (symbolP, 0);

  alternateP = symbol_find (weak_name2altname (S_GET_NAME (symbolP)));
  S_CLEAR_EXTERNAL (alternateP);
}

#endif  /* TE_PE */

/* Handle .weak.  This is a GNU extension in formats other than PE. */

static void
obj_coff_weak (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  int c;
  symbolS *symbolP;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      if (*name == 0)
	{
	  as_warn (_("badly formed .weak directive ignored"));
	  ignore_rest_of_line ();
	  return;
	}
      c = 0;
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();
      S_SET_WEAK (symbolP);

      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}

    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

void
coff_obj_read_begin_hook (void)
{
  /* These had better be the same.  Usually 18 bytes.  */
  know (sizeof (SYMENT) == sizeof (AUXENT));
  know (SYMESZ == AUXESZ);
  tag_init ();
}

symbolS *coff_last_function;
#ifndef OBJ_XCOFF
static symbolS *coff_last_bf;
#endif

void
coff_frob_symbol (symbolS *symp, int *punt)
{
  static symbolS *last_tagP;
  static stack *block_stack;
  static symbolS *set_end;
  symbolS *next_set_end = NULL;

  if (symp == &abs_symbol)
    {
      *punt = 1;
      return;
    }

  if (current_lineno_sym)
    coff_add_linesym (NULL);

  if (!block_stack)
    block_stack = stack_init (512, sizeof (symbolS*));

#ifdef TE_PE
  if (S_GET_STORAGE_CLASS (symp) == C_NT_WEAK
      && ! S_IS_WEAK (symp)
      && weak_is_altname (S_GET_NAME (symp)))
    {
      /* This is a weak alternate symbol.  All processing of
	 PECOFFweak symbols is done here, through the alternate.  */
      symbolS *weakp = symbol_find_noref (weak_altname2name
					  (S_GET_NAME (symp)), 1);

      gas_assert (weakp);
      gas_assert (S_GET_NUMBER_AUXILIARY (weakp) == 1);

      if (! S_IS_WEAK (weakp))
	{
	  /* The symbol was turned from weak to strong.  Discard altname.  */
	  *punt = 1;
	  return;
	}
      else if (symbol_equated_p (weakp))
	{
	  /* The weak symbol has an alternate specified; symp is unneeded.  */
	  S_SET_STORAGE_CLASS (weakp, C_NT_WEAK);
	  SA_SET_SYM_TAGNDX (weakp,
	    symbol_get_value_expression (weakp)->X_add_symbol);

	  S_CLEAR_EXTERNAL (symp);
	  *punt = 1;
	  return;
	}
      else
	{
	  /* The weak symbol has been assigned an alternate value.
             Copy this value to symp, and set symp as weakp's alternate.  */
	  if (S_GET_STORAGE_CLASS (weakp) != C_NT_WEAK)
	    {
	      S_SET_STORAGE_CLASS (symp, S_GET_STORAGE_CLASS (weakp));
	      S_SET_STORAGE_CLASS (weakp, C_NT_WEAK);
	    }

	  if (S_IS_DEFINED (weakp))
	    {
	      /* This is a defined weak symbol.  Copy value information
	         from the weak symbol itself to the alternate symbol.  */
	      symbol_set_value_expression (symp,
					   symbol_get_value_expression (weakp));
	      symbol_set_frag (symp, symbol_get_frag (weakp));
	      S_SET_SEGMENT (symp, S_GET_SEGMENT (weakp));
	    }
	  else
	    {
	      /* This is an undefined weak symbol.
		 Define the alternate symbol to zero.  */
	      S_SET_VALUE (symp, 0);
	      S_SET_SEGMENT (symp, absolute_section);
	    }

	  S_SET_NAME (symp, weak_uniquify (S_GET_NAME (symp)));
	  S_SET_STORAGE_CLASS (symp, C_EXT);

	  S_SET_VALUE (weakp, 0);
	  S_SET_SEGMENT (weakp, undefined_section);
	}
    }
#else /* TE_PE */
  if (S_IS_WEAK (symp))
    S_SET_STORAGE_CLASS (symp, C_WEAKEXT);
#endif /* TE_PE */

  if (!S_IS_DEFINED (symp)
      && !S_IS_WEAK (symp)
      && S_GET_STORAGE_CLASS (symp) != C_STAT)
    S_SET_STORAGE_CLASS (symp, C_EXT);

  if (!SF_GET_DEBUG (symp))
    {
      symbolS * real;

      if (!SF_GET_LOCAL (symp)
	  && !SF_GET_STATICS (symp)
	  && S_GET_STORAGE_CLASS (symp) != C_LABEL
	  && symbol_constant_p (symp)
	  && (real = symbol_find_noref (S_GET_NAME (symp), 1))
	  && S_GET_STORAGE_CLASS (real) == C_NULL
	  && real != symp)
	{
	  c_symbol_merge (symp, real);
	  *punt = 1;
	  return;
	}

      if (!S_IS_DEFINED (symp) && !SF_GET_LOCAL (symp))
	{
	  gas_assert (S_GET_VALUE (symp) == 0);
	  if (S_IS_WEAKREFD (symp))
	    *punt = 1;
	  else
	    S_SET_EXTERNAL (symp);
	}
      else if (S_GET_STORAGE_CLASS (symp) == C_NULL)
	{
	  if (S_GET_SEGMENT (symp) == text_section
	      && symp != seg_info (text_section)->sym)
	    S_SET_STORAGE_CLASS (symp, C_LABEL);
	  else
	    S_SET_STORAGE_CLASS (symp, C_STAT);
	}

      if (SF_GET_PROCESS (symp))
	{
	  if (S_GET_STORAGE_CLASS (symp) == C_BLOCK)
	    {
	      if (streq (S_GET_NAME (symp), ".bb"))
		stack_push (block_stack, (char *) &symp);
	      else
		{
		  symbolS *begin;

		  begin = *(symbolS **) stack_pop (block_stack);
		  if (begin == 0)
		    as_warn (_("mismatched .eb"));
		  else
		    next_set_end = begin;
		}
	    }

	  if (coff_last_function == 0 && SF_GET_FUNCTION (symp)
	      && S_IS_DEFINED (symp))
	    {
	      union internal_auxent *auxp;

	      coff_last_function = symp;
	      if (S_GET_NUMBER_AUXILIARY (symp) < 1)
		S_SET_NUMBER_AUXILIARY (symp, 1);
	      auxp = SYM_AUXENT (symp);
	      memset (auxp->x_sym.x_fcnary.x_ary.x_dimen, 0,
		      sizeof (auxp->x_sym.x_fcnary.x_ary.x_dimen));
	    }

	  if (S_GET_STORAGE_CLASS (symp) == C_EFCN
	      && S_IS_DEFINED (symp))
	    {
	      if (coff_last_function == 0)
		as_fatal (_("C_EFCN symbol for %s out of scope"),
			  S_GET_NAME (symp));
	      SA_SET_SYM_FSIZE (coff_last_function,
				(long) (S_GET_VALUE (symp)
					- S_GET_VALUE (coff_last_function)));
	      next_set_end = coff_last_function;
	      coff_last_function = 0;
	    }
	}

      if (S_IS_EXTERNAL (symp))
	S_SET_STORAGE_CLASS (symp, C_EXT);
      else if (SF_GET_LOCAL (symp))
	*punt = 1;

      if (SF_GET_FUNCTION (symp))
	symbol_get_bfdsym (symp)->flags |= BSF_FUNCTION;
    }

  /* Double check weak symbols.  */
  if (S_IS_WEAK (symp) && S_IS_COMMON (symp))
    as_bad (_("Symbol `%s' can not be both weak and common"),
	    S_GET_NAME (symp));

  if (SF_GET_TAG (symp))
    last_tagP = symp;
  else if (S_GET_STORAGE_CLASS (symp) == C_EOS)
    next_set_end = last_tagP;

#ifdef OBJ_XCOFF
  /* This is pretty horrible, but we have to set *punt correctly in
     order to call SA_SET_SYM_ENDNDX correctly.  */
  if (! symbol_used_in_reloc_p (symp)
      && ((symbol_get_bfdsym (symp)->flags & BSF_SECTION_SYM) != 0
	  || (! (S_IS_EXTERNAL (symp) || S_IS_WEAK (symp))
	      && ! symbol_get_tc (symp)->output
	      && S_GET_STORAGE_CLASS (symp) != C_FILE)))
    *punt = 1;
#endif

  if (set_end != (symbolS *) NULL
      && ! *punt
      && ((symbol_get_bfdsym (symp)->flags & BSF_NOT_AT_END) != 0
	  || (S_IS_DEFINED (symp)
	      && ! S_IS_COMMON (symp)
	      && (! S_IS_EXTERNAL (symp) || SF_GET_FUNCTION (symp)))))
    {
      SA_SET_SYM_ENDNDX (set_end, symp);
      set_end = NULL;
    }

  if (next_set_end != NULL)
    {
      if (set_end != NULL)
	as_warn (_("Warning: internal error: forgetting to set endndx of %s"),
		 S_GET_NAME (set_end));
      set_end = next_set_end;
    }

#ifndef OBJ_XCOFF
  if (! *punt
      && S_GET_STORAGE_CLASS (symp) == C_FCN
      && streq (S_GET_NAME (symp), ".bf"))
    {
      if (coff_last_bf != NULL)
	SA_SET_SYM_ENDNDX (coff_last_bf, symp);
      coff_last_bf = symp;
    }
#endif
  if (coffsymbol (symbol_get_bfdsym (symp))->lineno)
    {
      int i;
      struct line_no *lptr;
      alent *l;

      lptr = (struct line_no *) coffsymbol (symbol_get_bfdsym (symp))->lineno;
      for (i = 0; lptr; lptr = lptr->next)
	i++;
      lptr = (struct line_no *) coffsymbol (symbol_get_bfdsym (symp))->lineno;

      /* We need i entries for line numbers, plus 1 for the first
	 entry which BFD will override, plus 1 for the last zero
	 entry (a marker for BFD).  */
      l = xmalloc ((i + 2) * sizeof (* l));
      coffsymbol (symbol_get_bfdsym (symp))->lineno = l;
      l[i + 1].line_number = 0;
      l[i + 1].u.sym = NULL;
      for (; i > 0; i--)
	{
	  if (lptr->frag)
	    lptr->l.u.offset += lptr->frag->fr_address / OCTETS_PER_BYTE;
	  l[i] = lptr->l;
	  lptr = lptr->next;
	}
    }
}

void
coff_adjust_section_syms (bfd *abfd ATTRIBUTE_UNUSED,
			  asection *sec,
			  void * x ATTRIBUTE_UNUSED)
{
  symbolS *secsym;
  segment_info_type *seginfo = seg_info (sec);
  int nlnno, nrelocs = 0;

  /* RS/6000 gas creates a .debug section manually in ppc_frob_file in
     tc-ppc.c.  Do not get confused by it.  */
  if (seginfo == NULL)
    return;

  if (streq (sec->name, ".text"))
    nlnno = coff_n_line_nos;
  else
    nlnno = 0;
  {
    /* @@@@ Hope that none of the fixups expand to more than one reloc
       entry...  */
    fixS *fixp = seginfo->fix_root;
    while (fixp)
      {
	if (! fixp->fx_done)
	  nrelocs++;
	fixp = fixp->fx_next;
      }
  }
  if (bfd_get_section_size (sec) == 0
      && nrelocs == 0
      && nlnno == 0
      && sec != text_section
      && sec != data_section
      && sec != bss_section)
    return;

  secsym = section_symbol (sec);
  /* This is an estimate; we'll plug in the real value using
     SET_SECTION_RELOCS later */
  SA_SET_SCN_NRELOC (secsym, nrelocs);
  SA_SET_SCN_NLINNO (secsym, nlnno);
}

void
coff_frob_file_after_relocs (void)
{
  bfd_map_over_sections (stdoutput, coff_adjust_section_syms, NULL);
}

/* Implement the .section pseudo op:
  	.section name {, "flags"}
                  ^         ^
                  |         +--- optional flags: 'b' for bss
                  |                              'i' for info
                  +-- section name               'l' for lib
                                                 'n' for noload
                                                 'o' for over
                                                 'w' for data
  						 'd' (apparently m88k for data)
						 'e' for exclude
                                                 'x' for text
  						 'r' for read-only data
  						 's' for shared data (PE)
						 'y' for noread
					   '0' - '9' for power-of-two alignment (GNU extension).
   But if the argument is not a quoted string, treat it as a
   subsegment number.

   Note the 'a' flag is silently ignored.  This allows the same
   .section directive to be parsed in both ELF and COFF formats.  */

void
obj_coff_section (int ignore ATTRIBUTE_UNUSED)
{
  /* Strip out the section name.  */
  char *section_name;
  char c;
  int alignment = -1;
  char *name;
  unsigned int exp;
  flagword flags, oldflags;
  asection *sec;

  if (flag_mri)
    {
      char type;

      s_mri_sect (&type);
      return;
    }

  section_name = input_line_pointer;
  c = get_symbol_end ();

  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);

  *input_line_pointer = c;

  SKIP_WHITESPACE ();

  exp = 0;
  flags = SEC_NO_FLAGS;

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (*input_line_pointer != '"')
	exp = get_absolute_expression ();
      else
	{
	  unsigned char attr;
	  int readonly_removed = 0;
	  int load_removed = 0;

	  while (attr = *++input_line_pointer,
		 attr != '"'
		 && ! is_end_of_line[attr])
	    {
	      if (ISDIGIT (attr))
		{
		  alignment = attr - '0';
		  continue;
		}
	      switch (attr)
		{
		case 'e':
		  /* Exclude section from linking.  */
		  flags |= SEC_EXCLUDE;
		  break;

		case 'b':
		  /* Uninitialised data section.  */
		  flags |= SEC_ALLOC;
		  flags &=~ SEC_LOAD;
		  break;

		case 'n':
		  /* Section not loaded.  */
		  flags &=~ SEC_LOAD;
		  flags |= SEC_NEVER_LOAD;
		  load_removed = 1;
		  break;

		case 's':
		  /* Shared section.  */
		  flags |= SEC_COFF_SHARED;
		  /* Fall through.  */
		case 'd':
		  /* Data section.  */
		  flags |= SEC_DATA;
		  if (! load_removed)
		    flags |= SEC_LOAD;
		  flags &=~ SEC_READONLY;
		  break;

		case 'w':
		  /* Writable section.  */
		  flags &=~ SEC_READONLY;
		  readonly_removed = 1;
		  break;

		case 'a':
		  /* Ignore.  Here for compatibility with ELF.  */
		  break;

		case 'r': /* Read-only section.  Implies a data section.  */
		  readonly_removed = 0;
		  /* Fall through.  */
		case 'x': /* Executable section.  */
		  /* If we are setting the 'x' attribute or if the 'r'
		     attribute is being used to restore the readonly status
		     of a code section (eg "wxr") then set the SEC_CODE flag,
		     otherwise set the SEC_DATA flag.  */
		  flags |= (attr == 'x' || (flags & SEC_CODE) ? SEC_CODE : SEC_DATA);
		  if (! load_removed)
		    flags |= SEC_LOAD;
		  /* Note - the READONLY flag is set here, even for the 'x'
		     attribute in order to be compatible with the MSVC
		     linker.  */
		  if (! readonly_removed)
		    flags |= SEC_READONLY;
		  break;

		case 'y':
		  flags |= SEC_COFF_NOREAD | SEC_READONLY;
		  break;

		case 'i': /* STYP_INFO */
		case 'l': /* STYP_LIB */
		case 'o': /* STYP_OVER */
		  as_warn (_("unsupported section attribute '%c'"), attr);
		  break;

		default:
		  as_warn (_("unknown section attribute '%c'"), attr);
		  break;
		}
	    }
	  if (attr == '"')
	    ++input_line_pointer;
	}
    }

  sec = subseg_new (name, (subsegT) exp);

  if (alignment >= 0)
    sec->alignment_power = alignment;

  oldflags = bfd_get_section_flags (stdoutput, sec);
  if (oldflags == SEC_NO_FLAGS)
    {
      /* Set section flags for a new section just created by subseg_new.
         Provide a default if no flags were parsed.  */
      if (flags == SEC_NO_FLAGS)
	flags = TC_COFF_SECTION_DEFAULT_ATTRIBUTES;

#ifdef COFF_LONG_SECTION_NAMES
      /* Add SEC_LINK_ONCE and SEC_LINK_DUPLICATES_DISCARD to .gnu.linkonce
         sections so adjust_reloc_syms in write.c will correctly handle
         relocs which refer to non-local symbols in these sections.  */
      if (strneq (name, ".gnu.linkonce", sizeof (".gnu.linkonce") - 1))
	flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
#endif

      if (! bfd_set_section_flags (stdoutput, sec, flags))
	as_warn (_("error setting flags for \"%s\": %s"),
		 bfd_section_name (stdoutput, sec),
		 bfd_errmsg (bfd_get_error ()));
    }
  else if (flags != SEC_NO_FLAGS)
    {
      /* This section's attributes have already been set.  Warn if the
         attributes don't match.  */
      flagword matchflags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
			     | SEC_DATA | SEC_COFF_SHARED | SEC_NEVER_LOAD
			     | SEC_COFF_NOREAD);
      if ((flags ^ oldflags) & matchflags)
	as_warn (_("Ignoring changed section attributes for %s"), name);
    }

  demand_empty_rest_of_line ();
}

void
coff_adjust_symtab (void)
{
  if (symbol_rootP == NULL
      || S_GET_STORAGE_CLASS (symbol_rootP) != C_FILE)
    c_dot_file_symbol ("fake", 0);
}

void
coff_frob_section (segT sec)
{
  segT strsec;
  char *p;
  fragS *fragp;
  bfd_vma n_entries;

  /* The COFF back end in BFD requires that all section sizes be
     rounded up to multiples of the corresponding section alignments,
     supposedly because standard COFF has no other way of encoding alignment
     for sections.  If your COFF flavor has a different way of encoding
     section alignment, then skip this step, as TICOFF does.  */
  bfd_vma size = bfd_get_section_size (sec);
#if !defined(TICOFF)
  bfd_vma align_power = (bfd_vma) sec->alignment_power + OCTETS_PER_BYTE_POWER;
  bfd_vma mask = ((bfd_vma) 1 << align_power) - 1;

  if (size & mask)
    {
      bfd_vma new_size;
      fragS *last;

      new_size = (size + mask) & ~mask;
      bfd_set_section_size (stdoutput, sec, new_size);

      /* If the size had to be rounded up, add some padding in
         the last non-empty frag.  */
      fragp = seg_info (sec)->frchainP->frch_root;
      last = seg_info (sec)->frchainP->frch_last;
      while (fragp->fr_next != last)
	fragp = fragp->fr_next;
      last->fr_address = size;
      fragp->fr_offset += new_size - size;
    }
#endif

  /* If the section size is non-zero, the section symbol needs an aux
     entry associated with it, indicating the size.  We don't know
     all the values yet; coff_frob_symbol will fill them in later.  */
#ifndef TICOFF
  if (size != 0
      || sec == text_section
      || sec == data_section
      || sec == bss_section)
#endif
    {
      symbolS *secsym = section_symbol (sec);
      unsigned char sclass = C_STAT;

#ifdef OBJ_XCOFF
      if (bfd_get_section_flags (stdoutput, sec) & SEC_DEBUGGING)
        sclass = C_DWARF;
#endif
      S_SET_STORAGE_CLASS (secsym, sclass);
      S_SET_NUMBER_AUXILIARY (secsym, 1);
      SF_SET_STATICS (secsym);
      SA_SET_SCN_SCNLEN (secsym, size);
    }
  /* FIXME: These should be in a "stabs.h" file, or maybe as.h.  */
#ifndef STAB_SECTION_NAME
#define STAB_SECTION_NAME ".stab"
#endif
#ifndef STAB_STRING_SECTION_NAME
#define STAB_STRING_SECTION_NAME ".stabstr"
#endif
  if (! streq (STAB_STRING_SECTION_NAME, sec->name))
    return;

  strsec = sec;
  sec = subseg_get (STAB_SECTION_NAME, 0);
  /* size is already rounded up, since other section will be listed first */
  size = bfd_get_section_size (strsec);

  n_entries = bfd_get_section_size (sec) / 12 - 1;

  /* Find first non-empty frag.  It should be large enough.  */
  fragp = seg_info (sec)->frchainP->frch_root;
  while (fragp && fragp->fr_fix == 0)
    fragp = fragp->fr_next;
  gas_assert (fragp != 0 && fragp->fr_fix >= 12);

  /* Store the values.  */
  p = fragp->fr_literal;
  bfd_h_put_16 (stdoutput, n_entries, (bfd_byte *) p + 6);
  bfd_h_put_32 (stdoutput, size, (bfd_byte *) p + 8);
}

void
obj_coff_init_stab_section (segT seg)
{
  char *file;
  char *p;
  char *stabstr_name;
  unsigned int stroff;

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  as_where (&file, (unsigned int *) NULL);
  stabstr_name = xmalloc (strlen (seg->name) + 4);
  strcpy (stabstr_name, seg->name);
  strcat (stabstr_name, "str");
  stroff = get_stab_string_offset (file, stabstr_name);
  know (stroff == 1);
  md_number_to_chars (p, stroff, 4);
}

#ifdef DEBUG
const char * s_get_name (symbolS *);

const char *
s_get_name (symbolS *s)
{
  return ((s == NULL) ? "(NULL)" : S_GET_NAME (s));
}

void symbol_dump (void);

void
symbol_dump (void)
{
  symbolS *symbolP;

  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    printf (_("0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n"),
	    (unsigned long) symbolP,
	    S_GET_NAME (symbolP),
	    (long) S_GET_DATA_TYPE (symbolP),
	    S_GET_STORAGE_CLASS (symbolP),
	    (int) S_GET_SEGMENT (symbolP));
}

#endif /* DEBUG */

const pseudo_typeS coff_pseudo_table[] =
{
  {"ABORT", s_abort, 0},
  {"appline", obj_coff_ln, 1},
  /* We accept the .bss directive for backward compatibility with
     earlier versions of gas.  */
  {"bss", obj_coff_bss, 0},
#ifdef TE_PE
  /* PE provides an enhanced version of .comm with alignment.  */
  {"comm", obj_coff_comm, 0},
#endif /* TE_PE */
  {"def", obj_coff_def, 0},
  {"dim", obj_coff_dim, 0},
  {"endef", obj_coff_endef, 0},
  {"ident", obj_coff_ident, 0},
  {"line", obj_coff_line, 0},
  {"ln", obj_coff_ln, 0},
  {"scl", obj_coff_scl, 0},
  {"sect", obj_coff_section, 0},
  {"sect.s", obj_coff_section, 0},
  {"section", obj_coff_section, 0},
  {"section.s", obj_coff_section, 0},
  /* FIXME: We ignore the MRI short attribute.  */
  {"size", obj_coff_size, 0},
  {"tag", obj_coff_tag, 0},
  {"type", obj_coff_type, 0},
  {"val", obj_coff_val, 0},
  {"version", s_ignore, 0},
  {"loc", obj_coff_loc, 0},
  {"optim", s_ignore, 0},	/* For sun386i cc (?) */
  {"weak", obj_coff_weak, 0},
#if defined TC_TIC4X
  /* The tic4x uses sdef instead of def.  */
  {"sdef", obj_coff_def, 0},
#endif
#if defined(SEH_CMDS)
  SEH_CMDS
#endif
  {NULL, NULL, 0}
};


/* Support for a COFF emulation.  */

static void
coff_pop_insert (void)
{
  pop_insert (coff_pseudo_table);
}

static int
coff_separate_stab_sections (void)
{
  return 1;
}

const struct format_ops coff_format_ops =
{
  bfd_target_coff_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  0,    /* begin */
  c_dot_file_symbol,
  coff_frob_symbol,
  0,	/* frob_file */
  0,	/* frob_file_before_adjust */
  0,	/* frob_file_before_fix */
  coff_frob_file_after_relocs,
  0,	/* s_get_size */
  0,	/* s_set_size */
  0,	/* s_get_align */
  0,	/* s_set_align */
  0,	/* s_get_other */
  0,	/* s_set_other */
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  0,	/* copy_symbol_attributes */
  0,	/* generate_asm_lineno */
  0,	/* process_stab */
  coff_separate_stab_sections,
  obj_coff_init_stab_section,
  0,	/* sec_sym_ok_for_reloc */
  coff_pop_insert,
  0,	/* ecoff_set_ext */
  coff_obj_read_begin_hook,
  coff_obj_symbol_new_hook,
  coff_obj_symbol_clone_hook,
  coff_adjust_symtab
};
@


1.112
log
@2011-09-27  Kai Tietz  <ktietz@@redhat.com>

       * config/obj-coff.c (obj_coff_section): Add 'e' as specifier
       for marking section SEC_EXCLUDE.

2011-09-27  Kai Tietz  <ktietz@@redhat.com>

       * gas/pe/pe.exp: Add new testcase.
       * gas/pe/section-exclude.d: New file.
       * gas/pe/section-exclude.s: New file.
@
text
@d29 1
d1363 2
a1364 1
	  if (coff_last_function == 0 && SF_GET_FUNCTION (symp))
d1376 2
a1377 1
	  if (S_GET_STORAGE_CLASS (symp) == C_EFCN)
d1684 1
@


1.111
log
@bfd
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* libxcoff.h (struct xcoff_dwsect_name): New type.
	(XCOFF_DWSECT_NBR_NAMES): New macro.
	(xcoff_dwsect_names): Declare.
	* coffcode.h (sec_to_styp_flags): Handle xcoff dwarf sections.
	(styp_to_sec_flags): Ditto.
	(coff_new_section_hook): Ditto.
	(coff_slurp_symbol_table): Handle C_DWARF and C_INFO.
	* coff-rs6000.c (xcoff_dwsect_name): New variable.

gas
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ppc.h (ppc_tc_sy): Reorder fields.
	Put size into an union with dw.
	(OBJ_COPY_SYMBOL_ATTRIBUTES): Adjust.
	(ppc_xcoff_end): Declare.
	(md_end): Define.
	* config/tc-ppc.c: Add includes for xcoff.
	(ppc_dwsect): New function.
	(md_pseudo_table): Add dwsect.
	(struct dw_subsection): New.
	(dw_sections): New.
	(ppc_change_debug_section): New function.
	(ppc_xcoff_end): Ditto.
	(ppc_function): Adjust for ppc_tc_sy.
	(ppc_symbol_new_hook): Ditto.
	(ppc_frob_symbol): Ditto.
	(ppc_frob_section): Do not set vma for debug sections.
	(ppc_fix_adjustable): Return true for debug sections.
	* config/obj-coff.c: Add includes for xcoff.
	(coff_frob_section): Handle dwarf section.

gas/testsuite
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* gas/ppc/xcoff-dwsect-1-32.d: New test.
	* gas/ppc/xcoff-dwsect-1-64.d: Ditto.
	* gas/ppc/xcoff-dwsect-1.s: New file.
	* gas/ppc/aix.exp (do_align_test): Add tests.
@
text
@d1534 1
d1602 5
@


1.110
log
@	* config/obj-coff.c (weak_altname2name): Don't infer from the presence
	of a period that the symbol has been already uniquify-d.
	(weak_uniquify): Don't worry that the symbol might have been already
	uniquify-d.
@
text
@d34 4
d1769 1
d1771 5
a1775 1
      S_SET_STORAGE_CLASS (secsym, C_STAT);
@


1.109
log
@	* config/obj-coff.c (coff_format_ops): Fix typo.
@
text
@a1097 3
  char * weak_name;
  char * dot;

d1099 1
a1099 5

  weak_name = xstrdup (name + 6);
  if ((dot = strchr (weak_name, '.')))
    *dot = 0;
  return weak_name;
a1116 3
  if (strchr (name + sizeof (weak_altprefix), '.'))
    return name;

@


1.108
log
@	* obj.h (struct format_ops): Add adjust_symtab.
	* config/obj-multi.h (obj_adjust_symtab): Define.
	* config/obj-aout.c (aout_format_ops): Init new field.
	* config/obj-coff.c (coff_format_ops): Likewise.
	* config/obj-ecoff.c (ecoff_format_ops): Likewise.
	* config/obj-elf.c (elf_format_ops): Likewise.
@
text
@d1947 1
a1947 1
  coff_obj_adjust_symtab
@


1.107
log
@Fix build with -DDEBUG=7
@
text
@d1946 2
a1947 1
  coff_obj_symbol_clone_hook
@


1.106
log
@2010-07-11  Kai Tietz  <kai.tietz@@onevision.com>

	PR ld/11612
	* config/obj-coff.c (obj_common_parse): Quote symbol-name.

2010-07-11  Kai Tietz  <kai.tietz@@onevision.com>

	* gas/pe/aligncomm-b.d: Regenerated content dump.
	* gas/pe/aligncomm-d,d: Regenerated content dump.
	* gas/i386/i386.exp: Disable for mingw 64-bit the intel-got64 test.
@
text
@d1832 2
d1840 2
@


1.105
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d221 1
a221 1
      pfxlen = strlen (" -aligncomm:") + strlen (S_GET_NAME (symbolP)) + 1;
d224 1
a224 1
      (void) sprintf (frag, " -aligncomm:%s,", S_GET_NAME (symbolP));
@


1.104
log
@gas/ChangeLog:

	* NEWS: Mention new feature.
	* config/obj-coff.c (obj_coff_section): Accept digits and use
	to override default section alignment power if specified.
	* doc/as.texinfo (.section directive): Update documentation.

gas/testsuite/ChangeLog:

	* gas/pe/section-align-1.s: New test source file.
	* gas/pe/section-align-1.d: Likewise control script.
	* gas/pe/section-align-2.s: Likewise ...
	* gas/pe/section-align-2.d: ... and likewise.
	* gas/pe/pe.exp: Invoke new testcases.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
d1733 1
a1733 2
  bfd_vma size, n_entries, mask;
  bfd_vma align_power = (bfd_vma)sec->alignment_power + OCTETS_PER_BYTE_POWER;
d1740 1
a1740 2
  size = bfd_get_section_size (sec);
  mask = ((bfd_vma) 1 << align_power) - 1;
d1742 3
@


1.103
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d26 1
d1544 1
d1557 1
d1600 5
d1681 2
@


1.102
log
@	* ecoff.c (ecoff_symbol_clone_hook): New function.
	* ecoff.h (ecoff_symbol_clone_hook): Declare.
	* obj.h (struct format_ops): Add symbol_clone_hook.
	* config/obj-aout.c (aout_format_ops): Init new field.
	* config/obj-coff.c (coff_format_ops): Likewise.
	* config/obj-ecoff.c (ecoff_format_ops): Likewise.
	* config/obj-elf.c (elf_format_ops): Likewise.
	* config/obj-ecoff.h (obj_symbol_clone_hook): Define.
	* config/obj-multi.h (obj_symbol_clone_hook): Define.
@
text
@a623 2
unsigned int dim_index;

a628 1
  dim_index = 0;
d861 1
a861 1
  int dim_index;
d872 1
a872 1
  for (dim_index = 0; dim_index < DIMNUM; dim_index++)
d875 1
a875 1
      SA_SET_SYM_DIMEN (def_symbol_in_progress, dim_index,
d889 1
a889 1
	  dim_index = DIMNUM;
@


1.101
log
@	* config/obj-coff.h (USE_UNIQUE): Don't define.
	* config/obj-coff.c (weak_uniquify): Use an_external_name when TE_PE.
	* symbols.c (an_external_name): Define when TE_PE.
	(S_SET_EXTERNAL): Assign an_external_name when TE_PE.
	* tc.h (an_external_name): Declare when TE_PE.
@
text
@d1933 2
a1934 1
  coff_obj_symbol_new_hook
@


1.100
log
@update copyright dates
@
text
@d1120 1
a1120 1
#ifdef USE_UNIQUE
@


1.100.2.1
log
@	* config/obj-coff.h (USE_UNIQUE): Don't define.
	* config/obj-coff.c (weak_uniquify): Use an_external_name when TE_PE.
	* symbols.c (an_external_name): Define when TE_PE.
	(S_SET_EXTERNAL): Assign an_external_name when TE_PE.
	* tc.h (an_external_name): Declare when TE_PE.
@
text
@d1120 1
a1120 1
#ifdef TE_PE
@


1.100.2.2
log
@Backported (actually more-or-less simultaneously applied) from trunk:

gas/ChangeLog:

	* NEWS: Mention new feature.
	* config/obj-coff.c (obj_coff_section): Accept digits and use
	to override default section alignment power if specified.
	* doc/as.texinfo (.section directive): Update documentation.

gas/testsuite/ChangeLog:

	* gas/pe/section-align-1.s: New test source file.
	* gas/pe/section-align-1.d: Likewise control script.
	* gas/pe/section-align-2.s: Likewise ...
	* gas/pe/section-align-2.d: ... and likewise.
	* gas/pe/pe.exp: Invoke new testcases.
@
text
@a25 1
#include "safe-ctype.h"
a1545 1
					   '0' - '9' for power-of-two alignment (GNU extension).
a1557 1
  int alignment = -1;
a1599 5
	      if (ISDIGIT (attr))
		{
		  alignment = attr - '0';
		  continue;
		}
a1675 2
  if (alignment >= 0)
    sec->alignment_power = alignment;
@


1.99
log
@2009-08-17  Kai Tietz  <kai.tietz@@onevision.com>

        * config/obj-coff-seh.c: New file.
        * config/obj-coff-seh.h: Likewise.
        * config/obj-coff.c (obj-coff-seh.c): Add include.
        (coff_pseudo_table): Add new .seh... commands.
        * config/obj-coff.h (obj_coff_seh_do_final): Add new
        function prototype.
        (obj_coff_generate_pdata): New obj-coff hook.
        * gas/write.c (size_seg): Avoid sizing of already sized
        sections.
        (write_object_file): Call conditional hook
        objc_coff_generate_pdata.
        * Makefile.am: Add dependencies for new files.
        * Makefile.in: Regenerated.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009
@


1.98
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d56 2
a1772 1

d1881 3
@


1.97
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
d1437 1
a1437 1
	as_warn ("Warning: internal error: forgetting to set endndx of %s",
@


1.96
log
@==> bfd/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* cofflink.c (process_embedded_commands):  Ignore "-aligncomm".

==> gas/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* NEWS:  Mention new feature.
	* config/obj-coff.c (obj_coff_common_parse):  New function.
	(obj_coff_comm):  Likewise.
	(coff_pseudo_table):  Override default ".comm" definition on PE.
	* doc/as.texinfo:  Document new feature.

==> gas/testsuite/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* gas/pe/:  New directory for PE format-specific tests.
	* gas/pe/aligncomm-a.d:  New test pattern file.
	* gas/pe/aligncomm-a.s:  New test source file.
	* gas/pe/aligncomm-b.d:  New test pattern file.
	* gas/pe/aligncomm-b.s:  New test source file.
	* gas/pe/aligncomm-c.d:  New test pattern file.
	* gas/pe/aligncomm-c.s:  New test source file.
	* gas/pe/aligncomm-d.d:  New test pattern file.
	* gas/pe/aligncomm-d.s:  New test source file.
	* gas/pe/pe.exp:  New test control script.
	* lib/gas-defs.exp (is_pecoff_format):  New function.

==> ld/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* NEWS:  Mention new feature.
	* deffile.h (def_file_aligncomm):  Add new struct definition.
	(def_file):  Add new def_file_aligncomm member.
	* deffilep.y (%token):  Add new ALIGNCOMM token.
	(command):  Add production rule for ALIGNCOMM.
	(def_file_free):  Free any chained def_file_aligncomm structs.
	(diropts[]):  Add entry for '-aligncomm' .drectve command.
	(def_aligncomm):  New grammar function.
	* ld.texinfo:  Document new feature.
	* pe-dll.c (process_def_file):  Rename from this ...
	(process_def_file_and_drectve):  ... to this, updating all callers,
	and process any aligncomms chained to the def file after scanning
	all .drectve sections.
	(generate_edata):  Updated to match.
	(pe_dll_build_sections):  Likewise.

==> ld/testsuite/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* ld-pe/aligncomm-1.c:  New test source file.
	* ld-pe/aligncomm-2.c:  Likewise.
	* ld-pe/aligncomm-3.c:  Likewise.
	* ld-pe/aligncomm-4.c:  Likewise.
	* ld-pe/aligncomm.d:  New test pattern file.

	* ld-pe/direct.exp:  Deleted, and content moved into ...
	* ld-pe/pe-run.exp:  ... New common file for all PE run tests.

	* ld-pe/vers-script.exp:  Deleted, and content merged into ...
	* ld-pe/pe-compile.exp:  ... New common file for PE tests needing
	a compiler, adding aligned common tests.

	* ld-pe/pe.exp:  Update header comment.
@
text
@d251 1
a251 1
      assert (s != 0);
d1101 1
a1101 1
  assert (weak_is_altname (name));
d1122 1
a1122 1
  assert (weak_is_altname (name));
d1252 2
a1253 2
      assert (weakp);
      assert (S_GET_NUMBER_AUXILIARY (weakp) == 1);
d1335 1
a1335 1
	  assert (S_GET_VALUE (symp) == 0);
d1793 1
a1793 1
  assert (fragp != 0 && fragp->fr_fix >= 12);
@


1.95
log
@2009-05-17  Kai Tietz  <kai.tietz@@onevision.com>

        * config/obj-coff.c (obj_coff_section): Add 'y' as
        specifier for SEC_COFF_NOREAD section flag.
        * doc/as.texinfo: Add documentation about .section flag 'y'.
@
text
@d172 65
d1852 4
@


1.94
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@d1478 1
d1588 4
d1636 2
a1637 1
			     | SEC_DATA | SEC_COFF_SHARED | SEC_NEVER_LOAD);
@


1.93
log
@2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5035
	* config/obj-coff.c (obj_coff_endef): Remove checking size of
	def_symbol_in_progress.
@
text
@d500 1
a500 1
  stringer (1);
@


1.92
log
@Switch to GPLv3
@
text
@a779 1
      know (sizeof (def_symbol_in_progress) <= sizeof (long));
@


1.91
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.90
log
@PR binutils/1568
* config/obj-coff.c (obj_coff_section): Set readonly flag with the 'x'
attribute.  Remember the actions of the 'w' and 'n' attributes and do not
allow the 'x','s' or 'd' attributes to change them.
@
text
@d1029 1
a1029 1
   alterate symbol.  */
d1582 1
a1582 1
		     attrbiute in order to be compatible with the MSVC
@


1.89
log
@gas/
2005-10-27  Jan Beulich  <jbeulich@@novell.com>

	* read.c (assign_symbol): Also consider equates already defined.
	* symbols.c (symbol_clone): Also clone the underlying BFD symbol.
	* config/obj-coff.h (obj_symbol_clone_hook): New.
	(coff_obj_symbol_clone_hook): Declare.
	* config/obj-coff.c (coff_obj_symbol_clone_hook): New.

gas/testsuite/
2005-10-27  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/gas.exp: Don't xfail equiv1 test anymore.
@
text
@d1525 7
a1531 3
	  ++input_line_pointer;
	  while (*input_line_pointer != '"'
		 && ! is_end_of_line[(unsigned char) *input_line_pointer])
d1533 1
a1533 1
	      switch (*input_line_pointer)
d1535 24
a1558 2
		case 'b': flags |= SEC_ALLOC; flags &=~ SEC_LOAD; break;
		case 'n': flags &=~ SEC_LOAD; flags |= SEC_NEVER_LOAD; break;
d1560 27
a1586 7
		case 's': flags |= SEC_COFF_SHARED; /* Fall through.  */
		case 'd': flags |= SEC_DATA | SEC_LOAD; /* Fall through.  */
		case 'w': flags &=~ SEC_READONLY; break;

		case 'a': break; /* For compatibility with ELF.  */
		case 'x': flags |= SEC_CODE | SEC_LOAD; break;
		case 'r': flags |= SEC_DATA | SEC_LOAD | SEC_READONLY; break;
d1591 1
a1591 2
		  as_warn (_("unsupported section attribute '%c'"),
			   *input_line_pointer);
d1595 1
a1595 2
		  as_warn (_("unknown section attribute '%c'"),
			   *input_line_pointer);
a1597 1
	      ++input_line_pointer;
d1599 1
a1599 1
	  if (*input_line_pointer == '"')
@


1.88
log
@gas/ChangeLog:
* read.c (potable): Add weakref.
(s_weakref): New.
* read.h (s_weakref): Declare.
* struc-symbol.h (struct symbol): Add sy_weakrefr and sy_weakrefd.
* symbols.c (colon): Clear weakrefr.
(symbol_find_exact): Rename to, and reimplement in terms of...
(symbol_find_exact_noref): ... new function.
(symbol_find): Likewise...
(symbol_find_noref): ... ditto.
(resolve_symbol_value): Resolve weakrefr without setting their
values.
(S_SET_WEAK): Call hook.
(S_GET_VALUE): Follow weakref link.
(S_SET_VALUE): Clear weakrefr.
(S_IS_WEAK): Follow weakref link.
(S_IS_WEAKREFR, S_SET_WEAKREFR, S_CLEAR_WEAKREFR): New.
(S_IS_WEAKREFD, S_SET_WEAKREFD, S_CLEAR_WEAKREFD): New.
(symbol_set_value_expression, symbol_set_frag): Clear weakrefr.
(symbol_mark_used): Follow weakref link.
(print_symbol_value_1): Print weak, weakrefr and weakrefd.
* symbols.h (symbol_find_noref, symbol_find_exact_noref): Declare.
(S_IS_WEAKREFR, S_SET_WEAKREFR, S_CLEAR_WEAKREFR): Declare.
(S_IS_WEAKREFD, S_SET_WEAKREFD, S_CLEAR_WEAKREFD): Declare.
* write.c (adust_reloc_syms): Follow weakref link.  Do not
complain if target is undefined.
(write_object_file): Likewise.  Remove weakrefr symbols.  Drop
unreferenced weakrefd symbols.
* config/obj-coff.c (obj_frob_symbol): Do not force WEAKREFD
symbols EXTERNAL.
(pecoff_obj_set_weak_hook, pecoff_obj_clear_weak_hook): New.
* config/obj-coff.h (obj_set_weak_hook, obj_clear_weak_hook): Define.
* doc/as.texinfo: Document weakref.
* doc/internals.texi: Document new struct members, internal
functions and hooks.
gas/testsuite/ChangeLog:
* gas/all/weakref1.s, gas/all/weakref1.d: New test.
* gas/all/weakref1g.d, gas/all/weakref1l.d: New tests.
* gas/all/weakref1u.d, gas/all/weakref1w.d: New tests.
* gas/all/weakref2.s, gas/all/weakref3.s: New tests.
* gas/all/gas.exp: Run new tests.
@
text
@d332 12
@


1.87
log
@bfd
	* cofflink.c (_bfd_coff_generic_relocate_section): Correct
	comment.

gas
	* config/obj-coff.c (obj_coff_weak): Set auxiliary record
	of NT weak externals to IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY.
@
text
@d1058 33
a1100 3
#ifdef TE_PE
  symbolS *alternateP;
#endif
a1117 17
#ifdef TE_PE
      /* See _Microsoft Portable Executable and Common Object
         File Format Specification_, section 5.5.3.
         Create a symbol representing the alternate value.
         coff_frob_symbol will set the value of this symbol from
         the value of the weak symbol itself.  */
      S_SET_STORAGE_CLASS (symbolP, C_NT_WEAK);
      S_SET_NUMBER_AUXILIARY (symbolP, 1);
      SA_SET_SYM_FSIZE (symbolP, IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY);

      alternateP = symbol_find_or_make (weak_name2altname (name));
      S_SET_EXTERNAL (alternateP);
      S_SET_STORAGE_CLASS (alternateP, C_NT_WEAK);

      SA_SET_SYM_TAGNDX (symbolP, alternateP);
#endif

d1173 2
a1174 1
      symbolS *weakp = symbol_find (weak_altname2name (S_GET_NAME (symp)));
d1179 7
a1185 1
      if (symbol_equated_p (weakp))
d1248 1
a1248 1
	  && (real = symbol_find (S_GET_NAME (symp)))
d1260 4
a1263 1
	  S_SET_EXTERNAL (symp);
@


1.86
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d1096 1
a1096 1
      SA_SET_SYM_FSIZE (symbolP, IMAGE_WEAK_EXTERN_SEARCH_LIBRARY);
@


1.85
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d41 3
a43 3
/* The BFD_ASSEMBLER version of obj_coff_section will use this macro to set
   a new section's attributes when a directive has no valid flags or the
   "w" flag is used. This default should be appropriate for most.  */
a153 1
#ifdef BFD_ASSEMBLER
a154 1
#endif
a171 2
#ifdef BFD_ASSEMBLER

a1085 2

#if defined BFD_ASSEMBLER || defined S_SET_WEAK
a1086 1
#endif
a1122 1
#ifndef BFD_HEADERS
a1124 1
#endif
d1697 30
a1726 13
#else /* not BFD_ASSEMBLER */

#include "frags.h"
/* This is needed because we include internal bfd things.  */
#include <time.h>

#include "libbfd.h"
#include "libcoff.h"

/* The NOP_OPCODE is for the alignment fill value.  Fill with nop so
   that we can stick sections together without causing trouble.  */
#ifndef NOP_OPCODE
#define NOP_OPCODE 0x00
d1728 1
a1728 24

/* The zeroes if symbol name is longer than 8 chars */
#define S_SET_ZEROES(s,v)		((s)->sy_symbol.ost_entry.n_zeroes = (v))

#define MIN(a,b) ((a) < (b)? (a) : (b))

/* This vector is used to turn a gas internal segment number into a
   section number suitable for insertion into a coff symbol table.
   This must correspond to seg_info_off_by_4.  */

const short seg_N_TYPE[] =
{				/* in: segT   out: N_TYPE bits */
  C_ABS_SECTION,
  1,    2,  3,   4,    5,   6,   7,   8,   9,  10,
  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,
  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,
  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
  C_UNDEF_SECTION,		/* SEG_UNKNOWN */
  C_UNDEF_SECTION,		/* SEG_GOOF */
  C_UNDEF_SECTION,		/* SEG_EXPR */
  C_DEBUG_SECTION,		/* SEG_DEBUG */
  C_NTV_SECTION,		/* SEG_NTV */
  C_PTV_SECTION,		/* SEG_PTV */
  C_REGISTER_SECTION,		/* SEG_REGISTER */
d1730 1
d1732 1
a1732 180
int function_lineoff = -1;	/* Offset in line#s where the last function
				   started (the odd entry for line #0) */

/* Structure used to keep the filenames which
   are too long around so that we can stick them
   into the string table.  */
struct filename_list
{
  const char *filename;
  struct filename_list *next;
};

static struct filename_list *filename_list_head;
static struct filename_list *filename_list_tail;

static symbolS *last_line_symbol;

/* Add 4 to the real value to get the index and compensate the
   negatives. This vector is used by S_GET_SEGMENT to turn a coff
   section number into a segment number.  */

bfd *abfd;
static symbolS *previous_file_symbol;
static int line_base;

/* When not using BFD_ASSEMBLER, we permit up to 40 sections.

   This array maps a COFF section number into a gas section number.
   Because COFF uses negative section numbers, you must add 4 to the
   COFF section number when indexing into this array; this is done via
   the SEG_INFO_FROM_SECTION_NUMBER macro.  This must correspond to
   seg_N_TYPE.  */

static const segT seg_info_off_by_4[] =
{
 SEG_PTV,
 SEG_NTV,
 SEG_DEBUG,
 SEG_ABSOLUTE,
 SEG_UNKNOWN,
 SEG_E0,  SEG_E1,  SEG_E2,  SEG_E3,  SEG_E4,
 SEG_E5,  SEG_E6,  SEG_E7,  SEG_E8,  SEG_E9,
 SEG_E10, SEG_E11, SEG_E12, SEG_E13, SEG_E14,
 SEG_E15, SEG_E16, SEG_E17, SEG_E18, SEG_E19,
 SEG_E20, SEG_E21, SEG_E22, SEG_E23, SEG_E24,
 SEG_E25, SEG_E26, SEG_E27, SEG_E28, SEG_E29,
 SEG_E30, SEG_E31, SEG_E32, SEG_E33, SEG_E34,
 SEG_E35, SEG_E36, SEG_E37, SEG_E38, SEG_E39,
 (segT) 40,
 (segT) 41,
 (segT) 42,
 (segT) 43,
 (segT) 44,
 (segT) 45,
 (segT) 0,
 (segT) 0,
 (segT) 0,
 SEG_REGISTER
};

#define SEG_INFO_FROM_SECTION_NUMBER(x) (seg_info_off_by_4[(x)+4])

static relax_addressT
relax_align (relax_addressT address, long alignment)
{
  relax_addressT mask;
  relax_addressT new_address;

  mask = ~((~0) << alignment);
  new_address = (address + mask) & (~mask);

  return new_address - address;
}

segT
s_get_segment (symbolS * x)
{
  return SEG_INFO_FROM_SECTION_NUMBER (x->sy_symbol.ost_entry.n_scnum);
}

/* Calculate the size of the frag chain and fill in the section header
   to contain all of it, also fill in the addr of the sections.  */

static unsigned int
size_section (bfd *abfd ATTRIBUTE_UNUSED, unsigned int idx)
{
  unsigned int size = 0;
  fragS *frag = segment_info[idx].frchainP->frch_root;

  while (frag)
    {
      size = frag->fr_address;
      if (frag->fr_address != size)
	{
	  fprintf (stderr, _("Out of step\n"));
	  size = frag->fr_address;
	}

      switch (frag->fr_type)
	{
#ifdef TC_COFF_SIZEMACHDEP
	case rs_machine_dependent:
	  size += TC_COFF_SIZEMACHDEP (frag);
	  break;
#endif
	case rs_space:
	case rs_fill:
	case rs_org:
	  size += frag->fr_fix;
	  size += frag->fr_offset * frag->fr_var;
	  break;
	case rs_align:
	case rs_align_code:
	case rs_align_test:
	  {
	    addressT off;

	    size += frag->fr_fix;
	    off = relax_align (size, frag->fr_offset);
	    if (frag->fr_subtype != 0 && off > frag->fr_subtype)
	      off = 0;
	    size += off;
	  }
	  break;
	default:
	  BAD_CASE (frag->fr_type);
	  break;
	}
      frag = frag->fr_next;
    }
  segment_info[idx].scnhdr.s_size = size;
  return size;
}

static unsigned int
count_entries_in_chain (unsigned int idx)
{
  unsigned int nrelocs;
  fixS *fixup_ptr;

  /* Count the relocations.  */
  fixup_ptr = segment_info[idx].fix_root;
  nrelocs = 0;
  while (fixup_ptr != (fixS *) NULL)
    {
      if (fixup_ptr->fx_done == 0 && TC_COUNT_RELOC (fixup_ptr))
	{
#if defined(TC_A29K) || defined(TC_OR32)
	  if (fixup_ptr->fx_r_type == RELOC_CONSTH)
	    nrelocs += 2;
	  else
	    nrelocs++;
#else
	  nrelocs++;
#endif
	}

      fixup_ptr = fixup_ptr->fx_next;
    }
  return nrelocs;
}

#ifdef TE_AUX

/* AUX's ld expects relocations to be sorted.  */

static int
compare_external_relocs (const void * x, const void * y)
{
  struct external_reloc *a = (struct external_reloc *) x;
  struct external_reloc *b = (struct external_reloc *) y;
  bfd_vma aadr = bfd_getb32 (a->r_vaddr);
  bfd_vma badr = bfd_getb32 (b->r_vaddr);

  return (aadr < badr ? -1 : badr < aadr ? 1 : 0);
}

#endif

/* Output all the relocations for a section.  */
d1735 1
a1735 1
do_relocs_for (bfd * abfd, object_headers * h, unsigned long *file_cursor)
d1737 1
a1737 403
  unsigned int nrelocs;
  unsigned int idx;
  unsigned long reloc_start = *file_cursor;

  for (idx = SEG_E0; idx < SEG_LAST; idx++)
    {
      if (segment_info[idx].scnhdr.s_name[0])
	{
	  struct external_reloc *ext_ptr;
	  struct external_reloc *external_reloc_vec;
	  unsigned int external_reloc_size;
	  unsigned int base = segment_info[idx].scnhdr.s_paddr;
	  fixS *fix_ptr = segment_info[idx].fix_root;

	  nrelocs = count_entries_in_chain (idx);

	  if (nrelocs)
	    /* Bypass this stuff if no relocs.  This also incidentally
	       avoids a SCO bug, where free(malloc(0)) tends to crash.  */
	    {
	      external_reloc_size = nrelocs * RELSZ;
	      external_reloc_vec = malloc (external_reloc_size);

	      ext_ptr = external_reloc_vec;

	      /* Fill in the internal coff style reloc struct from the
		 internal fix list.  */
	      while (fix_ptr)
		{
		  struct internal_reloc intr;

		  /* Only output some of the relocations.  */
		  if (fix_ptr->fx_done == 0 && TC_COUNT_RELOC (fix_ptr))
		    {
#ifdef TC_RELOC_MANGLE
		      TC_RELOC_MANGLE (&segment_info[idx], fix_ptr, &intr,
				       base);
#else
		      symbolS *dot;
		      symbolS *symbol_ptr = fix_ptr->fx_addsy;

		      intr.r_type = TC_COFF_FIX2RTYPE (fix_ptr);
		      intr.r_vaddr =
			base + fix_ptr->fx_frag->fr_address + fix_ptr->fx_where;

#ifdef TC_KEEP_FX_OFFSET
		      intr.r_offset = fix_ptr->fx_offset;
#else
		      intr.r_offset = 0;
#endif

		      while (symbol_ptr->sy_value.X_op == O_symbol
			     && (! S_IS_DEFINED (symbol_ptr)
				 || S_IS_COMMON (symbol_ptr)))
			{
			  symbolS *n;

			  /* We must avoid looping, as that can occur
                             with a badly written program.  */
			  n = symbol_ptr->sy_value.X_add_symbol;
			  if (n == symbol_ptr)
			    break;
			  symbol_ptr = n;
			}

		      /* Turn the segment of the symbol into an offset.  */
		      if (symbol_ptr)
			{
			  resolve_symbol_value (symbol_ptr);
			  if (! symbol_ptr->sy_resolved)
			    {
			      char *file;
			      unsigned int line;

			      if (expr_symbol_where (symbol_ptr, &file, &line))
				as_bad_where (file, line,
					      _("unresolved relocation"));
			      else
				as_bad (_("bad relocation: symbol `%s' not in symbol table"),
					S_GET_NAME (symbol_ptr));
			    }

			  dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
			  if (dot)
			    intr.r_symndx = dot->sy_number;
			  else
			    intr.r_symndx = symbol_ptr->sy_number;
			}
		      else
			intr.r_symndx = -1;
#endif
		      (void) bfd_coff_swap_reloc_out (abfd, &intr, ext_ptr);
		      ext_ptr++;
#if defined(TC_A29K)
		      /* The 29k has a special kludge for the high 16 bit
			 reloc.  Two relocations are emitted, R_IHIHALF,
			 and R_IHCONST. The second one doesn't contain a
			 symbol, but uses the value for offset.  */
		      if (intr.r_type == R_IHIHALF)
			{
			  /* Now emit the second bit.  */
			  intr.r_type = R_IHCONST;
			  intr.r_symndx = fix_ptr->fx_addnumber;
			  (void) bfd_coff_swap_reloc_out (abfd, &intr, ext_ptr);
			  ext_ptr++;
			}
#endif
#if defined(TC_OR32)
		      /* The or32 has a special kludge for the high 16 bit
			 reloc.  Two relocations are emitted, R_IHIHALF,
			 and R_IHCONST. The second one doesn't contain a
			 symbol, but uses the value for offset.  */
		      if (intr.r_type == R_IHIHALF)
			{
			  /* Now emit the second bit.  */
			  intr.r_type = R_IHCONST;
			  intr.r_symndx = fix_ptr->fx_addnumber;
			  (void) bfd_coff_swap_reloc_out (abfd, & intr, ext_ptr);
			  ext_ptr ++;
			}
#endif
		    }

		  fix_ptr = fix_ptr->fx_next;
		}
#ifdef TE_AUX
	      /* Sort the reloc table.  */
	      qsort ((void *) external_reloc_vec, nrelocs,
		     sizeof (struct external_reloc), compare_external_relocs);
#endif
	      /* Write out the reloc table.  */
	      bfd_bwrite ((void *) external_reloc_vec,
			  (bfd_size_type) external_reloc_size, abfd);
	      free (external_reloc_vec);

	      /* Fill in section header info.  */
	      segment_info[idx].scnhdr.s_relptr = *file_cursor;
	      *file_cursor += external_reloc_size;
	      segment_info[idx].scnhdr.s_nreloc = nrelocs;
	    }
	  else
	    {
	      /* No relocs.  */
	      segment_info[idx].scnhdr.s_relptr = 0;
	    }
	}
    }

  /* Set relocation_size field in file headers.  */
  H_SET_RELOCATION_SIZE (h, *file_cursor - reloc_start, 0);
}

/* Run through a frag chain and write out the data to go with it, fill
   in the scnhdrs with the info on the file positions.  */

static void
fill_section (bfd * abfd,
	      object_headers *h ATTRIBUTE_UNUSED,
	      unsigned long *file_cursor)
{
  unsigned int i;
  unsigned int paddr = 0;

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      unsigned int offset = 0;
      struct internal_scnhdr *s = &(segment_info[i].scnhdr);

      PROGRESS (1);

      if (s->s_name[0])
	{
	  fragS *frag = segment_info[i].frchainP->frch_root;
	  char *buffer = NULL;

	  if (s->s_size == 0)
	    s->s_scnptr = 0;
	  else
	    {
	      buffer = xmalloc (s->s_size);
	      s->s_scnptr = *file_cursor;
	    }
	  know (s->s_paddr == paddr);

	  if (streq (s->s_name, ".text"))
	    s->s_flags |= STYP_TEXT;
	  else if (streq (s->s_name, ".data"))
	    s->s_flags |= STYP_DATA;
	  else if (streq (s->s_name, ".bss"))
	    {
	      s->s_scnptr = 0;
	      s->s_flags |= STYP_BSS;

	      /* @@@@ Should make the i386 and a29k coff targets define
		 COFF_NOLOAD_PROBLEM, and have only one test here.  */
#ifndef TC_I386
#ifndef TC_A29K
#ifndef TC_OR32
#ifndef COFF_NOLOAD_PROBLEM
	      /* Apparently the SVR3 linker (and exec syscall) and UDI
		 mondfe progrem are confused by noload sections.  */
	      s->s_flags |= STYP_NOLOAD;
#endif
#endif
#endif
#endif
	    }
	  else if (streq (s->s_name, ".lit"))
	    s->s_flags = STYP_LIT | STYP_TEXT;
	  else if (streq (s->s_name, ".init"))
	    s->s_flags |= STYP_TEXT;
	  else if (streq (s->s_name, ".fini"))
	    s->s_flags |= STYP_TEXT;
	  else if (strneq (s->s_name, ".comment", 8))
	    s->s_flags |= STYP_INFO;

	  while (frag)
	    {
	      unsigned int fill_size;

	      switch (frag->fr_type)
		{
		case rs_machine_dependent:
		  if (frag->fr_fix)
		    {
		      memcpy (buffer + frag->fr_address,
			      frag->fr_literal,
			      (unsigned int) frag->fr_fix);
		      offset += frag->fr_fix;
		    }

		  break;
		case rs_space:
		case rs_fill:
		case rs_align:
		case rs_align_code:
		case rs_align_test:
		case rs_org:
		  if (frag->fr_fix)
		    {
		      memcpy (buffer + frag->fr_address,
			      frag->fr_literal,
			      (unsigned int) frag->fr_fix);
		      offset += frag->fr_fix;
		    }

		  fill_size = frag->fr_var;
		  if (fill_size && frag->fr_offset > 0)
		    {
		      unsigned int count;
		      unsigned int off = frag->fr_fix;

		      for (count = frag->fr_offset; count; count--)
			{
			  if (fill_size + frag->fr_address + off <= s->s_size)
			    {
			      memcpy (buffer + frag->fr_address + off,
				      frag->fr_literal + frag->fr_fix,
				      fill_size);
			      off += fill_size;
			      offset += fill_size;
			    }
			}
		    }
		  break;
		case rs_broken_word:
		  break;
		default:
		  abort ();
		}
	      frag = frag->fr_next;
	    }

	  if (s->s_size != 0)
	    {
	      if (s->s_scnptr != 0)
		{
		  bfd_bwrite (buffer, s->s_size, abfd);
		  *file_cursor += s->s_size;
		}
	      free (buffer);
	    }
	  paddr += s->s_size;
	}
    }
}

/* Coff file generation & utilities.  */

static void
coff_header_append (bfd * abfd, object_headers * h)
{
  unsigned int i;
  char buffer[1000];
  char buffero[1000];
#ifdef COFF_LONG_SECTION_NAMES
  unsigned long string_size = 4;
#endif

  bfd_seek (abfd, 0, 0);

#ifndef OBJ_COFF_OMIT_OPTIONAL_HEADER
  H_SET_MAGIC_NUMBER (h, COFF_MAGIC);
  H_SET_VERSION_STAMP (h, 0);
  H_SET_ENTRY_POINT (h, 0);
  H_SET_TEXT_START (h, segment_info[SEG_E0].frchainP->frch_root->fr_address);
  H_SET_DATA_START (h, segment_info[SEG_E1].frchainP->frch_root->fr_address);
  H_SET_SIZEOF_OPTIONAL_HEADER (h, bfd_coff_swap_aouthdr_out (abfd, &h->aouthdr,
							      buffero));
#else /* defined (OBJ_COFF_OMIT_OPTIONAL_HEADER) */
  H_SET_SIZEOF_OPTIONAL_HEADER (h, 0);
#endif /* defined (OBJ_COFF_OMIT_OPTIONAL_HEADER) */

  i = bfd_coff_swap_filehdr_out (abfd, &h->filehdr, buffer);

  bfd_bwrite (buffer, (bfd_size_type) i, abfd);
  bfd_bwrite (buffero, (bfd_size_type) H_GET_SIZEOF_OPTIONAL_HEADER (h), abfd);

  for (i = SEG_E0; i < SEG_LAST; i++)
    {
      if (segment_info[i].scnhdr.s_name[0])
	{
	  unsigned int size;

#ifdef COFF_LONG_SECTION_NAMES
	  /* Support long section names as found in PE.  This code
             must coordinate with that in write_object_file and
             w_strings.  */
	  if (strlen (segment_info[i].name) > SCNNMLEN)
	    {
	      memset (segment_info[i].scnhdr.s_name, 0, SCNNMLEN);
	      sprintf (segment_info[i].scnhdr.s_name, "/%lu", string_size);
	      string_size += strlen (segment_info[i].name) + 1;
	    }
#endif
	  size = bfd_coff_swap_scnhdr_out (abfd,
					   &(segment_info[i].scnhdr),
					   buffer);
	  if (size == 0)
	    as_bad (_("bfd_coff_swap_scnhdr_out failed"));
	  bfd_bwrite (buffer, (bfd_size_type) size, abfd);
	}
    }
}

static char *
symbol_to_chars (bfd * abfd, char * where, symbolS * symbolP)
{
  unsigned int numaux = symbolP->sy_symbol.ost_entry.n_numaux;
  unsigned int i;
  valueT val;

  /* Turn any symbols with register attributes into abs symbols.  */
  if (S_GET_SEGMENT (symbolP) == reg_section)
    S_SET_SEGMENT (symbolP, absolute_section);

  /* At the same time, relocate all symbols to their output value.  */
#ifndef TE_PE
  val = (segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_paddr
	 + S_GET_VALUE (symbolP));
#else
  val = S_GET_VALUE (symbolP);
#endif

  S_SET_VALUE (symbolP, val);

  symbolP->sy_symbol.ost_entry.n_value = val;

  where += bfd_coff_swap_sym_out (abfd, &symbolP->sy_symbol.ost_entry,
				  where);

  for (i = 0; i < numaux; i++)
    {
      where += bfd_coff_swap_aux_out (abfd,
				      &symbolP->sy_symbol.ost_auxent[i],
				      S_GET_DATA_TYPE (symbolP),
				      S_GET_STORAGE_CLASS (symbolP),
				      i, numaux, where);
    }

  return where;
}

void
coff_obj_symbol_new_hook (symbolS *symbolP)
{
  char underscore = 0;		/* Symbol has leading _  */

  /* Effective symbol.  */
  /* Store the pointer in the offset.  */
  S_SET_ZEROES (symbolP, 0L);
  S_SET_DATA_TYPE (symbolP, T_NULL);
  S_SET_STORAGE_CLASS (symbolP, 0);
  S_SET_NUMBER_AUXILIARY (symbolP, 0);
  /* Additional information.  */
  symbolP->sy_symbol.ost_flags = 0;
  /* Auxiliary entries.  */
  memset ((char *) &symbolP->sy_symbol.ost_auxent[0], 0, AUXESZ);

  if (S_IS_STRING (symbolP))
    SF_SET_STRING (symbolP);
  if (!underscore && S_IS_LOCAL (symbolP))
    SF_SET_LOCAL (symbolP);
d1741 1
a1741 1
c_line_new (symbolS * symbol, long paddr, int line_number, fragS * frag)
d1743 1
a1743 25
  struct lineno_list *new_line = xmalloc (sizeof (* new_line));

  segment_info_type *s = segment_info + now_seg;
  new_line->line.l_lnno = line_number;

  if (line_number == 0)
    {
      last_line_symbol = symbol;
      new_line->line.l_addr.l_symndx = (long) symbol;
    }
  else
    {
      new_line->line.l_addr.l_paddr = paddr;
    }

  new_line->frag = (char *) frag;
  new_line->next = NULL;

  if (s->lineno_list_head == NULL)
    s->lineno_list_head = new_line;
  else
    s->lineno_list_tail->next = new_line;

  s->lineno_list_tail = new_line;
  return LINESZ * s->scnhdr.s_nlnno++;
d1746 1
a1746 4
/* Handle .ln directives.  */

static void
obj_coff_ln (int appline)
d1748 22
a1769 2122
  int l;

  if (! appline && def_symbol_in_progress != NULL)
    {
      /* Wrong context.  */
      as_warn (_(".ln pseudo-op inside .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  l = get_absolute_expression ();
  c_line_new (0, frag_now_fix (), l, frag_now);

  if (appline)
    new_logical_line ((char *) NULL, l - 1);

#ifndef NO_LISTING
  {
    extern int listing;

    if (listing)
      {
	if (! appline)
	  l += line_base - 1;
	listing_source_line ((unsigned int) l);
      }
  }
#endif
  demand_empty_rest_of_line ();
}

/* Handle .def directives.

  One might ask : why can't we symbol_new if the symbol does not
  already exist and fill it with debug information.  Because of
  the C_EFCN special symbol. It would clobber the value of the
  function symbol before we have a chance to notice that it is
  a C_EFCN. And a second reason is that the code is more clear this
  way. (at least I think it is :-).  */

#define SKIP_SEMI_COLON()	while (*input_line_pointer++ != ';')
#define SKIP_WHITESPACES()	while (*input_line_pointer == ' ' || \
				       *input_line_pointer == '\t')  \
                                  input_line_pointer++;

static void
obj_coff_def (int what ATTRIBUTE_UNUSED)
{
  char name_end;		/* Char after the end of name.  */
  char *symbol_name;		/* Name of the debug symbol.  */
  char *symbol_name_copy;	/* Temporary copy of the name.  */
  unsigned int symbol_name_length;

  if (def_symbol_in_progress != NULL)
    {
      as_warn (_(".def pseudo-op used inside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  SKIP_WHITESPACES ();

  def_symbol_in_progress = obstack_alloc (&notes, sizeof (*def_symbol_in_progress));
  memset (def_symbol_in_progress, 0, sizeof (*def_symbol_in_progress));

  symbol_name = input_line_pointer;
  name_end = get_symbol_end ();
  symbol_name_length = strlen (symbol_name);
  symbol_name_copy = xmalloc (symbol_name_length + 1);
  strcpy (symbol_name_copy, symbol_name);
#ifdef tc_canonicalize_symbol_name
  symbol_name_copy = tc_canonicalize_symbol_name (symbol_name_copy);
#endif

  /* Initialize the new symbol.  */
  S_SET_NAME (def_symbol_in_progress, symbol_name_copy);
  /* free(symbol_name_copy); */
  def_symbol_in_progress->sy_name_offset = (unsigned long) ~0;
  def_symbol_in_progress->sy_number = ~0;
  def_symbol_in_progress->sy_frag = &zero_address_frag;
  S_SET_VALUE (def_symbol_in_progress, 0);

  if (S_IS_STRING (def_symbol_in_progress))
    SF_SET_STRING (def_symbol_in_progress);

  *input_line_pointer = name_end;

  demand_empty_rest_of_line ();
}

static void
c_symbol_merge (symbolS *debug, symbolS *normal)
{
  S_SET_DATA_TYPE (normal, S_GET_DATA_TYPE (debug));
  S_SET_STORAGE_CLASS (normal, S_GET_STORAGE_CLASS (debug));

  if (S_GET_NUMBER_AUXILIARY (debug) > S_GET_NUMBER_AUXILIARY (normal))
    S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));

  if (S_GET_NUMBER_AUXILIARY (debug) > 0)
    memcpy ((char *) &normal->sy_symbol.ost_auxent[0],
	    (char *) &debug->sy_symbol.ost_auxent[0],
	    (unsigned int) (S_GET_NUMBER_AUXILIARY (debug) * AUXESZ));

  /* Move the debug flags.  */
  SF_SET_DEBUG_FIELD (normal, SF_GET_DEBUG_FIELD (debug));
}

static unsigned int dim_index;

static void
obj_coff_endef (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = 0;

  dim_index = 0;
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".endef pseudo-op used outside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  /* Set the section number according to storage class.  */
  switch (S_GET_STORAGE_CLASS (def_symbol_in_progress))
    {
    case C_STRTAG:
    case C_ENTAG:
    case C_UNTAG:
      SF_SET_TAG (def_symbol_in_progress);
      /* Fall through.  */

    case C_FILE:
    case C_TPDEF:
      SF_SET_DEBUG (def_symbol_in_progress);
      S_SET_SEGMENT (def_symbol_in_progress, SEG_DEBUG);
      break;

    case C_EFCN:
      /* Do not emit this symbol.  */
      SF_SET_LOCAL (def_symbol_in_progress);
      /* Fall through.  */

    case C_BLOCK:
      /* Will need processing before writing.  */
      SF_SET_PROCESS (def_symbol_in_progress);
      /* Fall through.  */

    case C_FCN:
      S_SET_SEGMENT (def_symbol_in_progress, SEG_E0);

      if (streq (S_GET_NAME (def_symbol_in_progress), ".bf"))
	{
	  if (function_lineoff < 0)
	    fprintf (stderr, _("`.bf' symbol without preceding function\n"));

	  SA_GET_SYM_LNNOPTR (last_line_symbol) = function_lineoff;

	  SF_SET_PROCESS (last_line_symbol);
	  SF_SET_ADJ_LNNOPTR (last_line_symbol);
	  SF_SET_PROCESS (def_symbol_in_progress);
	  function_lineoff = -1;
	}

      /* Value is always set to .  */
      def_symbol_in_progress->sy_frag = frag_now;
      S_SET_VALUE (def_symbol_in_progress, (valueT) frag_now_fix ());
      break;

#ifdef C_AUTOARG
    case C_AUTOARG:
#endif /* C_AUTOARG */
    case C_AUTO:
    case C_REG:
    case C_MOS:
    case C_MOE:
    case C_MOU:
    case C_ARG:
    case C_REGPARM:
    case C_FIELD:
    case C_EOS:
      SF_SET_DEBUG (def_symbol_in_progress);
      S_SET_SEGMENT (def_symbol_in_progress, absolute_section);
      break;

    case C_EXT:
    case C_WEAKEXT:
#ifdef TE_PE
    case C_NT_WEAK:
#endif
    case C_STAT:
    case C_LABEL:
      /* Valid but set somewhere else (s_comm, s_lcomm, colon).  */
      break;

    case C_USTATIC:
    case C_EXTDEF:
    case C_ULABEL:
      as_warn (_("unexpected storage class %d"), S_GET_STORAGE_CLASS (def_symbol_in_progress));
      break;
    }

  /* Now that we have built a debug symbol, try to find if we should
     merge with an existing symbol or not.  If a symbol is C_EFCN or
     absolute_section or untagged SEG_DEBUG it never merges.  We also
     don't merge labels, which are in a different namespace, nor
     symbols which have not yet been defined since they are typically
     unique, nor do we merge tags with non-tags.  */

  /* Two cases for functions.  Either debug followed by definition or
     definition followed by debug.  For definition first, we will
     merge the debug symbol into the definition.  For debug first, the
     lineno entry MUST point to the definition function or else it
     will point off into space when crawl_symbols() merges the debug
     symbol into the real symbol.  Therefor, let's presume the debug
     symbol is a real function reference.  */

  /* FIXME-SOON If for some reason the definition label/symbol is
     never seen, this will probably leave an undefined symbol at link
     time.  */

  if (S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_EFCN
      || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_LABEL
      || (S_GET_SEGMENT (def_symbol_in_progress) == SEG_DEBUG
	  && !SF_GET_TAG (def_symbol_in_progress))
      || S_GET_SEGMENT (def_symbol_in_progress) == absolute_section
      || def_symbol_in_progress->sy_value.X_op != O_constant
      || (symbolP = symbol_find (S_GET_NAME (def_symbol_in_progress))) == NULL
      || (SF_GET_TAG (def_symbol_in_progress) != SF_GET_TAG (symbolP)))
    {
      symbol_append (def_symbol_in_progress, symbol_lastP, &symbol_rootP,
		     &symbol_lastP);
    }
  else
    {
      /* This symbol already exists, merge the newly created symbol
	 into the old one.  This is not mandatory. The linker can
	 handle duplicate symbols correctly. But I guess that it save
	 a *lot* of space if the assembly file defines a lot of
	 symbols. [loic] */

      /* The debug entry (def_symbol_in_progress) is merged into the
	 previous definition.  */

      c_symbol_merge (def_symbol_in_progress, symbolP);
      /* FIXME-SOON Should *def_symbol_in_progress be free'd? xoxorich.  */
      def_symbol_in_progress = symbolP;

      if (SF_GET_FUNCTION (def_symbol_in_progress)
	  || SF_GET_TAG (def_symbol_in_progress)
	  || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_STAT)
	{
	  /* For functions, and tags, and static symbols, the symbol
	     *must* be where the debug symbol appears.  Move the
	     existing symbol to the current place.  */
	  /* If it already is at the end of the symbol list, do nothing.  */
	  if (def_symbol_in_progress != symbol_lastP)
	    {
	      symbol_remove (def_symbol_in_progress, &symbol_rootP,
			     &symbol_lastP);
	      symbol_append (def_symbol_in_progress, symbol_lastP,
			     &symbol_rootP, &symbol_lastP);
	    }
	}
    }

  if (SF_GET_TAG (def_symbol_in_progress))
    {
      symbolS *oldtag;

      oldtag = symbol_find (S_GET_NAME (def_symbol_in_progress));
      if (oldtag == NULL || ! SF_GET_TAG (oldtag))
	tag_insert (S_GET_NAME (def_symbol_in_progress),
		    def_symbol_in_progress);
    }

  if (SF_GET_FUNCTION (def_symbol_in_progress))
    {
      know (sizeof (def_symbol_in_progress) <= sizeof (long));
      function_lineoff
	= c_line_new (def_symbol_in_progress, 0, 0, &zero_address_frag);

      SF_SET_PROCESS (def_symbol_in_progress);

      if (symbolP == NULL)
	/* That is, if this is the first time we've seen the function.  */
	symbol_table_insert (def_symbol_in_progress);
    }

  def_symbol_in_progress = NULL;
  demand_empty_rest_of_line ();
}

static void
obj_coff_dim (int ignore ATTRIBUTE_UNUSED)
{
  int dim_index;

  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".dim pseudo-op used outside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);

  for (dim_index = 0; dim_index < DIMNUM; dim_index++)
    {
      SKIP_WHITESPACES ();
      SA_SET_SYM_DIMEN (def_symbol_in_progress, dim_index,
			get_absolute_expression ());

      switch (*input_line_pointer)
	{
	case ',':
	  input_line_pointer++;
	  break;

	default:
	  as_warn (_("badly formed .dim directive ignored"));
	  /* Fall through.  */

	case '\n':
	case ';':
	  dim_index = DIMNUM;
	  break;
	}
    }

  demand_empty_rest_of_line ();
}

static void
obj_coff_line (int ignore ATTRIBUTE_UNUSED)
{
  int this_base;
  const char *name;

  if (def_symbol_in_progress == NULL)
    {
      obj_coff_ln (0);
      return;
    }

  name = S_GET_NAME (def_symbol_in_progress);
  this_base = get_absolute_expression ();

  /* Only .bf symbols indicate the use of a new base line number; the
     line numbers associated with .ef, .bb, .eb are relative to the
     start of the containing function.  */
  if (streq (".bf", name))
    {
	line_base = this_base;

#ifndef NO_LISTING
      {
	extern int listing;
	if (listing)
	  listing_source_line ((unsigned int) line_base);
      }
#endif
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  SA_SET_SYM_LNNO (def_symbol_in_progress, this_base);

  demand_empty_rest_of_line ();
}

static void
obj_coff_size (int ignore ATTRIBUTE_UNUSED)
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".size pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  SA_SET_SYM_SIZE (def_symbol_in_progress, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
obj_coff_scl (int ignore ATTRIBUTE_UNUSED)
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".scl pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_STORAGE_CLASS (def_symbol_in_progress, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
obj_coff_tag (int ignore ATTRIBUTE_UNUSED)
{
  char *symbol_name;
  char name_end;

  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".tag pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  symbol_name = input_line_pointer;
  name_end = get_symbol_end ();
#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif

  /* Assume that the symbol referred to by .tag is always defined.
     This was a bad assumption.  I've added find_or_make. xoxorich.  */
  SA_SET_SYM_TAGNDX (def_symbol_in_progress,
		     (long) tag_find_or_make (symbol_name));
  if (SA_GET_SYM_TAGNDX (def_symbol_in_progress) == 0L)
    as_warn (_("tag not found for .tag %s"), symbol_name);

  SF_SET_TAGGED (def_symbol_in_progress);
  *input_line_pointer = name_end;

  demand_empty_rest_of_line ();
}

static void
obj_coff_type (int ignore ATTRIBUTE_UNUSED)
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".type pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_DATA_TYPE (def_symbol_in_progress, get_absolute_expression ());

  if (ISFCN (S_GET_DATA_TYPE (def_symbol_in_progress)) &&
      S_GET_STORAGE_CLASS (def_symbol_in_progress) != C_TPDEF)
    SF_SET_FUNCTION (def_symbol_in_progress);

  demand_empty_rest_of_line ();
}

static void
obj_coff_val (int ignore ATTRIBUTE_UNUSED)
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".val pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  if (is_name_beginner (*input_line_pointer))
    {
      char *symbol_name = input_line_pointer;
      char name_end = get_symbol_end ();

#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif

      if (streq (symbol_name, "."))
	{
	  def_symbol_in_progress->sy_frag = frag_now;
	  S_SET_VALUE (def_symbol_in_progress, (valueT) frag_now_fix ());
	  /* If the .val is != from the .def (e.g. statics).  */
	}
      else if (! streq (S_GET_NAME (def_symbol_in_progress), symbol_name))
	{
	  def_symbol_in_progress->sy_value.X_op = O_symbol;
	  def_symbol_in_progress->sy_value.X_add_symbol =
	    symbol_find_or_make (symbol_name);
	  def_symbol_in_progress->sy_value.X_op_symbol = NULL;
	  def_symbol_in_progress->sy_value.X_add_number = 0;

	  /* If the segment is undefined when the forward reference is
	     resolved, then copy the segment id from the forward
	     symbol.  */
	  SF_SET_GET_SEGMENT (def_symbol_in_progress);

	  /* FIXME: gcc can generate address expressions here in
	     unusual cases (search for "obscure" in sdbout.c).  We
	     just ignore the offset here, thus generating incorrect
	     debugging information.  We ignore the rest of the line
	     just below.  */
	}
      /* Otherwise, it is the name of a non debug symbol and
	 its value will be calculated later.  */
      *input_line_pointer = name_end;

      /* FIXME: this is to avoid an error message in the
	 FIXME case mentioned just above.  */
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }
  else
    {
      S_SET_VALUE (def_symbol_in_progress,
		   (valueT) get_absolute_expression ());
    }

  demand_empty_rest_of_line ();
}

#ifdef TE_PE

/* Handle the .linkonce pseudo-op.  This is parsed by s_linkonce in
   read.c, which then calls this object file format specific routine.  */

void
obj_coff_pe_handle_link_once (enum linkonce_type type)
{
  seg_info (now_seg)->scnhdr.s_flags |= IMAGE_SCN_LNK_COMDAT;

  /* We store the type in the seg_info structure, and use it to set up
     the auxiliary entry for the section symbol in c_section_symbol.  */
  seg_info (now_seg)->linkonce = type;
}

#endif /* TE_PE */

void
coff_obj_read_begin_hook (void)
{
  /* These had better be the same.  Usually 18 bytes.  */
#ifndef BFD_HEADERS
  know (sizeof (SYMENT) == sizeof (AUXENT));
  know (SYMESZ == AUXESZ);
#endif
  tag_init ();
}

/* This function runs through the symbol table and puts all the
   externals onto another chain.  */

/* The chain of globals.  */
symbolS *symbol_globalP;
symbolS *symbol_global_lastP;

/* The chain of externals.  */
symbolS *symbol_externP;
symbolS *symbol_extern_lastP;

stack *block_stack;
symbolS *last_functionP;
static symbolS *last_bfP;
symbolS *last_tagP;

static unsigned int
yank_symbols (void)
{
  symbolS *symbolP;
  unsigned int symbol_number = 0;
  unsigned int last_file_symno = 0;
  struct filename_list *filename_list_scan = filename_list_head;

  for (symbolP = symbol_rootP;
       symbolP;
       symbolP = symbolP ? symbol_next (symbolP) : symbol_rootP)
    {
      if (symbolP->sy_mri_common)
	{
	  if (S_GET_STORAGE_CLASS (symbolP) == C_EXT
#ifdef TE_PE
	      || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK
#endif
	      || S_GET_STORAGE_CLASS (symbolP) == C_WEAKEXT)
	    as_bad (_("%s: global symbols not supported in common sections"),
		    S_GET_NAME (symbolP));
	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	  continue;
	}

      if (!SF_GET_DEBUG (symbolP))
	{
	  /* Debug symbols do not need all this rubbish.  */
	  symbolS *real_symbolP;

	  /* L* and C_EFCN symbols never merge.  */
	  if (!SF_GET_LOCAL (symbolP)
	      && !SF_GET_STATICS (symbolP)
	      && S_GET_STORAGE_CLASS (symbolP) != C_LABEL
	      && symbolP->sy_value.X_op == O_constant
	      && (real_symbolP = symbol_find (S_GET_NAME (symbolP)))
	      && real_symbolP != symbolP)
	    {
	      /* FIXME-SOON: where do dups come from?
		 Maybe tag references before definitions? xoxorich.  */
	      /* Move the debug data from the debug symbol to the
		 real symbol. Do NOT do the opposite (i.e. move from
		 real symbol to debug symbol and remove real symbol from the
		 list.) Because some pointers refer to the real symbol
		 whereas no pointers refer to the debug symbol.  */
	      c_symbol_merge (symbolP, real_symbolP);
	      /* Replace the current symbol by the real one.  */
	      /* The symbols will never be the last or the first
		 because : 1st symbol is .file and 3 last symbols are
		 .text, .data, .bss.  */
	      symbol_remove (real_symbolP, &symbol_rootP, &symbol_lastP);
	      symbol_insert (real_symbolP, symbolP, &symbol_rootP, &symbol_lastP);
	      symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	      symbolP = real_symbolP;
	    }

	  if (flag_readonly_data_in_text && (S_GET_SEGMENT (symbolP) == SEG_E1))
	    S_SET_SEGMENT (symbolP, SEG_E0);

	  resolve_symbol_value (symbolP);

	  if (S_GET_STORAGE_CLASS (symbolP) == C_NULL)
	    {
	      if (!S_IS_DEFINED (symbolP) && !SF_GET_LOCAL (symbolP))
		S_SET_EXTERNAL (symbolP);

	      else if (S_GET_SEGMENT (symbolP) == SEG_E0)
		S_SET_STORAGE_CLASS (symbolP, C_LABEL);

	      else
		S_SET_STORAGE_CLASS (symbolP, C_STAT);
	    }

	  /* Mainly to speed up if not -g.  */
	  if (SF_GET_PROCESS (symbolP))
	    {
	      /* Handle the nested blocks auxiliary info.  */
	      if (S_GET_STORAGE_CLASS (symbolP) == C_BLOCK)
		{
		  if (streq (S_GET_NAME (symbolP), ".bb"))
		    stack_push (block_stack, (char *) &symbolP);
		  else
		    {
		      /* .eb */
		      symbolS *begin_symbolP;

		      begin_symbolP = *(symbolS **) stack_pop (block_stack);
		      if (begin_symbolP == NULL)
			as_warn (_("mismatched .eb"));
		      else
			SA_SET_SYM_ENDNDX (begin_symbolP, symbol_number + 2);
		    }
		}

	      /* If we are able to identify the type of a function, and we
	       are out of a function (last_functionP == 0) then, the
	       function symbol will be associated with an auxiliary
	       entry.  */
	      if (last_functionP == NULL && SF_GET_FUNCTION (symbolP))
		{
		  last_functionP = symbolP;

		  if (S_GET_NUMBER_AUXILIARY (symbolP) < 1)
		    S_SET_NUMBER_AUXILIARY (symbolP, 1);
		}

	      if (S_GET_STORAGE_CLASS (symbolP) == C_FCN)
		{
		  if (streq (S_GET_NAME (symbolP), ".bf"))
		    {
		      if (last_bfP != NULL)
			SA_SET_SYM_ENDNDX (last_bfP, symbol_number);
		      last_bfP = symbolP;
		    }
		}
	      else if (S_GET_STORAGE_CLASS (symbolP) == C_EFCN)
		{
		  /* I don't even know if this is needed for sdb. But
		     the standard assembler generates it, so...  */
		  if (last_functionP == NULL)
		    as_fatal (_("C_EFCN symbol out of scope"));
		  SA_SET_SYM_FSIZE (last_functionP,
				    (long) (S_GET_VALUE (symbolP) -
					    S_GET_VALUE (last_functionP)));
		  SA_SET_SYM_ENDNDX (last_functionP, symbol_number);
		 last_functionP = NULL;
		}
	    }
	}
      else if (SF_GET_TAG (symbolP))
	/* First descriptor of a structure must point to
	   the first slot after the structure description.  */
	last_tagP = symbolP;

      else if (S_GET_STORAGE_CLASS (symbolP) == C_EOS)
	/* +2 take in account the current symbol.  */
	SA_SET_SYM_ENDNDX (last_tagP, symbol_number + 2);

      else if (S_GET_STORAGE_CLASS (symbolP) == C_FILE)
	{
	  /* If the filename was too long to fit in the
	     auxent, put it in the string table.  */
	  if (SA_GET_FILE_FNAME_ZEROS (symbolP) == 0
	      && SA_GET_FILE_FNAME_OFFSET (symbolP) != 0)
	    {
	      SA_SET_FILE_FNAME_OFFSET (symbolP, string_byte_count);
	      string_byte_count += strlen (filename_list_scan->filename) + 1;
	      filename_list_scan = filename_list_scan->next;
	    }
	  if (S_GET_VALUE (symbolP))
	    {
	      S_SET_VALUE (symbolP, last_file_symno);
	      last_file_symno = symbol_number;
	    }
	}

#ifdef tc_frob_coff_symbol
      tc_frob_coff_symbol (symbolP);
#endif

      /* We must put the external symbols apart. The loader
	 does not bomb if we do not. But the references in
	 the endndx field for a .bb symbol are not corrected
	 if an external symbol is removed between .bb and .be.
	 I.e in the following case :
	 [20] .bb endndx = 22
	 [21] foo external
	 [22] .be
	 ld will move the symbol 21 to the end of the list but
	 endndx will still be 22 instead of 21.  */

      if (SF_GET_LOCAL (symbolP))
	/* Remove C_EFCN and LOCAL (L...) symbols.  */
	/* Next pointer remains valid.  */
	symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);

      else if (symbolP->sy_value.X_op == O_symbol
	       && (! S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP)))
	/* Skip symbols which were equated to undefined or common
	   symbols.  */
	symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);

      else if (!S_IS_DEFINED (symbolP)
	       && !S_IS_DEBUG (symbolP)
	       && !SF_GET_STATICS (symbolP)
	       && (S_GET_STORAGE_CLASS (symbolP) == C_EXT
#ifdef TE_PE
		   || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK
#endif
		   || S_GET_STORAGE_CLASS (symbolP) == C_WEAKEXT))
	{
	  /* If external, Remove from the list.  */
	  symbolS *hold = symbol_previous (symbolP);

	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	  symbol_clear_list_pointers (symbolP);
	  symbol_append (symbolP, symbol_extern_lastP, &symbol_externP, &symbol_extern_lastP);
	  symbolP = hold;
	}
      else if (! S_IS_DEBUG (symbolP)
	       && ! SF_GET_STATICS (symbolP)
	       && ! SF_GET_FUNCTION (symbolP)
	       && (S_GET_STORAGE_CLASS (symbolP) == C_EXT
#ifdef TE_PE
		   || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK
#endif
		   || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK))
	{
	  symbolS *hold = symbol_previous (symbolP);

	  /* The O'Reilly COFF book says that defined global symbols
             come at the end of the symbol table, just before
             undefined global symbols.  */
	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	  symbol_clear_list_pointers (symbolP);
	  symbol_append (symbolP, symbol_global_lastP, &symbol_globalP,
			 &symbol_global_lastP);
	  symbolP = hold;
	}
      else
	{
	  if (SF_GET_STRING (symbolP))
	    {
	      symbolP->sy_name_offset = string_byte_count;
	      string_byte_count += strlen (S_GET_NAME (symbolP)) + 1;
	    }
	  else
	    symbolP->sy_name_offset = 0;

	  symbolP->sy_number = symbol_number;
	  symbol_number += 1 + S_GET_NUMBER_AUXILIARY (symbolP);
	}
    }

  return symbol_number;
}

static unsigned int
glue_symbols (symbolS **head, symbolS **tail)
{
  unsigned int symbol_number = 0;

  while (*head != NULL)
    {
      symbolS *tmp = *head;

      /* Append.  */
      symbol_remove (tmp, head, tail);
      symbol_append (tmp, symbol_lastP, &symbol_rootP, &symbol_lastP);

      /* Process.  */
      if (SF_GET_STRING (tmp))
	{
	  tmp->sy_name_offset = string_byte_count;
	  string_byte_count += strlen (S_GET_NAME (tmp)) + 1;
	}
      else
	/* Fix "long" names.  */
	tmp->sy_name_offset = 0;

      tmp->sy_number = symbol_number;
      symbol_number += 1 + S_GET_NUMBER_AUXILIARY (tmp);
    }

  return symbol_number;
}

static unsigned int
tie_tags (void)
{
  unsigned int symbol_number = 0;
  symbolS *symbolP;

  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      symbolP->sy_number = symbol_number;

      if (SF_GET_TAGGED (symbolP))
	{
	  SA_SET_SYM_TAGNDX
	    (symbolP,
	     ((symbolS *) SA_GET_SYM_TAGNDX (symbolP))->sy_number);
	}

      symbol_number += 1 + S_GET_NUMBER_AUXILIARY (symbolP);
    }

  return symbol_number;
}


/* Build a 'section static' symbol.  */

static symbolS *
c_section_symbol (char *name, int idx)
{
  symbolS *symbolP;

  symbolP = symbol_find (name);
  if (symbolP == NULL)
    symbolP = symbol_new (name, idx, 0, &zero_address_frag);
  else
    {
      /* Mmmm.  I just love violating interfaces.  Makes me feel...dirty.  */
      S_SET_SEGMENT (symbolP, idx);
      symbolP->sy_frag = &zero_address_frag;
    }

  S_SET_STORAGE_CLASS (symbolP, C_STAT);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);

  SF_SET_STATICS (symbolP);

#ifdef TE_DELTA
  /* manfred@@s-direktnet.de: section symbols *must* have the LOCAL bit cleared,
     which is set by the new definition of LOCAL_LABEL in tc-m68k.h.  */
  SF_CLEAR_LOCAL (symbolP);
#endif
#ifdef TE_PE
  /* If the .linkonce pseudo-op was used for this section, we must
     store the information in the auxiliary entry for the section
     symbol.  */
  if (segment_info[idx].linkonce != LINKONCE_UNSET)
    {
      int type;

      switch (segment_info[idx].linkonce)
	{
	default:
	  abort ();
	case LINKONCE_DISCARD:
	  type = IMAGE_COMDAT_SELECT_ANY;
	  break;
	case LINKONCE_ONE_ONLY:
	  type = IMAGE_COMDAT_SELECT_NODUPLICATES;
	  break;
	case LINKONCE_SAME_SIZE:
	  type = IMAGE_COMDAT_SELECT_SAME_SIZE;
	  break;
	case LINKONCE_SAME_CONTENTS:
	  type = IMAGE_COMDAT_SELECT_EXACT_MATCH;
	  break;
	}

      SYM_AUXENT (symbolP)->x_scn.x_comdat = type;
    }
#endif /* TE_PE */

  return symbolP;
}

static void
crawl_symbols (object_headers *h, bfd *abfd ATTRIBUTE_UNUSED)
{
  unsigned int i;

  /* Initialize the stack used to keep track of the matching .bb .be.  */
  block_stack = stack_init (512, sizeof (symbolS *));

  /* The symbol list should be ordered according to the following sequence
     order :
     . .file symbol
     . debug entries for functions
     . fake symbols for the sections, including .text .data and .bss
     . defined symbols
     . undefined symbols
     But this is not mandatory. The only important point is to put the
     undefined symbols at the end of the list.  */

  /* Is there a .file symbol ? If not insert one at the beginning.  */
  if (symbol_rootP == NULL
      || S_GET_STORAGE_CLASS (symbol_rootP) != C_FILE)
    c_dot_file_symbol ("fake", 0);

  /* Build up static symbols for the sections, they are filled in later.  */
  for (i = SEG_E0; i < SEG_LAST; i++)
    if (segment_info[i].scnhdr.s_name[0])
      segment_info[i].dot = c_section_symbol ((char *) segment_info[i].name,
					      i - SEG_E0 + 1);

  /* Take all the externals out and put them into another chain.  */
  H_SET_SYMBOL_TABLE_SIZE (h, yank_symbols ());
  /* Take the externals and glue them onto the end.  */
  H_SET_SYMBOL_TABLE_SIZE (h,
			   (H_GET_SYMBOL_COUNT (h)
			    + glue_symbols (&symbol_globalP,
					    &symbol_global_lastP)
			    + glue_symbols (&symbol_externP,
					    &symbol_extern_lastP)));

  H_SET_SYMBOL_TABLE_SIZE (h, tie_tags ());
  know (symbol_globalP == NULL);
  know (symbol_global_lastP == NULL);
  know (symbol_externP == NULL);
  know (symbol_extern_lastP == NULL);
}

/* Find strings by crawling along symbol table chain.  */

static void
w_strings (char *where)
{
  symbolS *symbolP;
  struct filename_list *filename_list_scan = filename_list_head;

  /* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK.  */
  md_number_to_chars (where, (valueT) string_byte_count, 4);
  where += 4;

#ifdef COFF_LONG_SECTION_NAMES
  /* Support long section names as found in PE.  This code must
     coordinate with that in coff_header_append and write_object_file.  */
  {
    unsigned int i;

    for (i = SEG_E0; i < SEG_LAST; i++)
      {
	if (segment_info[i].scnhdr.s_name[0]
	    && strlen (segment_info[i].name) > SCNNMLEN)
	  {
	    unsigned int size;

	    size = strlen (segment_info[i].name) + 1;
	    memcpy (where, segment_info[i].name, size);
	    where += size;
	  }
      }
  }
#endif /* COFF_LONG_SECTION_NAMES */

  for (symbolP = symbol_rootP;
       symbolP;
       symbolP = symbol_next (symbolP))
    {
      unsigned int size;

      if (SF_GET_STRING (symbolP))
	{
	  size = strlen (S_GET_NAME (symbolP)) + 1;
	  memcpy (where, S_GET_NAME (symbolP), size);
	  where += size;
	}
      if (S_GET_STORAGE_CLASS (symbolP) == C_FILE
	  && SA_GET_FILE_FNAME_ZEROS (symbolP) == 0
	  && SA_GET_FILE_FNAME_OFFSET (symbolP) != 0)
	{
	  size = strlen (filename_list_scan->filename) + 1;
	  memcpy (where, filename_list_scan->filename, size);
	  filename_list_scan = filename_list_scan ->next;
	  where += size;
	}
    }
}

static void
do_linenos_for (bfd * abfd,
		object_headers * h,
		unsigned long *file_cursor)
{
  unsigned int idx;
  unsigned long start = *file_cursor;

  for (idx = SEG_E0; idx < SEG_LAST; idx++)
    {
      segment_info_type *s = segment_info + idx;

      if (s->scnhdr.s_nlnno != 0)
	{
	  struct lineno_list *line_ptr;
	  struct external_lineno *buffer = xmalloc (s->scnhdr.s_nlnno * LINESZ);
	  struct external_lineno *dst = buffer;

	  /* Run through the table we've built and turn it into its external
	     form, take this chance to remove duplicates.  */

	  for (line_ptr = s->lineno_list_head;
	       line_ptr != (struct lineno_list *) NULL;
	       line_ptr = line_ptr->next)
	    {
	      if (line_ptr->line.l_lnno == 0)
		{
		  /* Turn a pointer to a symbol into the symbols' index,
		     provided that it has been initialised.  */
		  if (line_ptr->line.l_addr.l_symndx)
		    line_ptr->line.l_addr.l_symndx =
		      ((symbolS *) line_ptr->line.l_addr.l_symndx)->sy_number;
		}
	      else
		line_ptr->line.l_addr.l_paddr += ((struct frag *) (line_ptr->frag))->fr_address;

	      (void) bfd_coff_swap_lineno_out (abfd, &(line_ptr->line), dst);
	      dst++;
	    }

	  s->scnhdr.s_lnnoptr = *file_cursor;

	  bfd_bwrite (buffer, (bfd_size_type) s->scnhdr.s_nlnno * LINESZ, abfd);
	  free (buffer);

	  *file_cursor += s->scnhdr.s_nlnno * LINESZ;
	}
    }

  H_SET_LINENO_SIZE (h, *file_cursor - start);
}

/* Now we run through the list of frag chains in a segment and
   make all the subsegment frags appear at the end of the
   list, as if the seg 0 was extra long.  */

static void
remove_subsegs (void)
{
  unsigned int i;

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      frchainS *head = segment_info[i].frchainP;
      fragS dummy;
      fragS *prev_frag = &dummy;

      while (head && head->frch_seg == i)
	{
	  prev_frag->fr_next = head->frch_root;
	  prev_frag = head->frch_last;
	  head = head->frch_next;
	}
      prev_frag->fr_next = 0;
    }
}

unsigned long machine;
int coff_flags;

#ifndef SUB_SEGMENT_ALIGN
#ifdef HANDLE_ALIGN
/* The last subsegment gets an alignment corresponding to the alignment
   of the section.  This allows proper nop-filling at the end of
   code-bearing sections.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
   ? get_recorded_alignment (SEG) : 0)
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 1
#endif
#endif

static void
w_symbols (bfd * abfd, char *where, symbolS * symbol_rootP)
{
  symbolS *symbolP;
  unsigned int i;

  /* First fill in those values we have only just worked out.  */
  for (i = SEG_E0; i < SEG_LAST; i++)
    {
      symbolP = segment_info[i].dot;
      if (symbolP)
	{
	  SA_SET_SCN_SCNLEN (symbolP, segment_info[i].scnhdr.s_size);
	  SA_SET_SCN_NRELOC (symbolP, segment_info[i].scnhdr.s_nreloc);
	  SA_SET_SCN_NLINNO (symbolP, segment_info[i].scnhdr.s_nlnno);
	}
    }

  /* Emit all symbols left in the symbol chain.  */
  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      /* Used to save the offset of the name. It is used to point
	 to the string in memory but must be a file offset.  */
      char *temp;

      /* We can't fix the lnnoptr field in yank_symbols with the other
         adjustments, because we have to wait until we know where they
         go in the file.  */
      if (SF_GET_ADJ_LNNOPTR (symbolP))
	SA_GET_SYM_LNNOPTR (symbolP) +=
	  segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_lnnoptr;

      tc_coff_symbol_emit_hook (symbolP);

      temp = S_GET_NAME (symbolP);
      if (SF_GET_STRING (symbolP))
	{
	  S_SET_OFFSET (symbolP, symbolP->sy_name_offset);
	  S_SET_ZEROES (symbolP, 0);
	}
      else
	{
	  memset (symbolP->sy_symbol.ost_entry.n_name, 0, SYMNMLEN);
	  strncpy (symbolP->sy_symbol.ost_entry.n_name, temp, SYMNMLEN);
	}
      where = symbol_to_chars (abfd, where, symbolP);
      S_SET_NAME (symbolP, temp);
    }
}

static void
fixup_mdeps (fragS *frags,
	     object_headers *h ATTRIBUTE_UNUSED,
	     segT this_segment)
{
  subseg_change (this_segment, 0);

  while (frags)
    {
      switch (frags->fr_type)
	{
	case rs_align:
	case rs_align_code:
	case rs_align_test:
	case rs_org:
#ifdef HANDLE_ALIGN
	  HANDLE_ALIGN (frags);
#endif
	  frags->fr_type = rs_fill;
	  frags->fr_offset =
	    ((frags->fr_next->fr_address - frags->fr_address - frags->fr_fix)
	     / frags->fr_var);
	  break;
	case rs_machine_dependent:
	  md_convert_frag (h, this_segment, frags);
	  frag_wane (frags);
	  break;
	default:
	  ;
	}
      frags = frags->fr_next;
    }
}

#ifndef TC_FORCE_RELOCATION
#define TC_FORCE_RELOCATION(fix) 0
#endif

static void
fixup_segment (segment_info_type * segP, segT this_segment_type)
{
  fixS * fixP;
  symbolS *add_symbolP;
  symbolS *sub_symbolP;
  long add_number;
  int size;
  char *place;
  long where;
  char pcrel;
  fragS *fragP;
  segT add_symbol_segment = absolute_section;

  for (fixP = segP->fix_root; fixP; fixP = fixP->fx_next)
    {
      fragP = fixP->fx_frag;
      know (fragP);
      where = fixP->fx_where;
      place = fragP->fr_literal + where;
      size = fixP->fx_size;
      add_symbolP = fixP->fx_addsy;
      sub_symbolP = fixP->fx_subsy;
      add_number = fixP->fx_offset;
      pcrel = fixP->fx_pcrel;

      /* We want function-relative stabs to work on systems which
	 may use a relaxing linker; thus we must handle the sym1-sym2
	 fixups function-relative stabs generates.

	 Of course, if you actually enable relaxing in the linker, the
	 line and block scoping information is going to be incorrect
	 in some cases.  The only way to really fix this is to support
	 a reloc involving the difference of two symbols.  */
      if (linkrelax
	  && (!sub_symbolP || pcrel))
	continue;

#ifdef TC_I960
      if (fixP->fx_tcbit && SF_GET_CALLNAME (add_symbolP))
	{
	  /* Relocation should be done via the associated 'bal' entry
	     point symbol.  */
	  if (!SF_GET_BALNAME (tc_get_bal_of_call (add_symbolP)))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("No 'bal' entry point for leafproc %s"),
			    S_GET_NAME (add_symbolP));
	      continue;
	    }
	  fixP->fx_addsy = add_symbolP = tc_get_bal_of_call (add_symbolP);
	}
#endif

      /* Make sure the symbols have been resolved; this may not have
         happened if these are expression symbols.  */
      if (add_symbolP != NULL && ! add_symbolP->sy_resolved)
	resolve_symbol_value (add_symbolP);

      if (add_symbolP != NULL)
	{
	  /* If this fixup is against a symbol which has been equated
	     to another symbol, convert it to the other symbol.  */
	  if (add_symbolP->sy_value.X_op == O_symbol
	      && (! S_IS_DEFINED (add_symbolP)
		  || S_IS_COMMON (add_symbolP)))
	    {
	      while (add_symbolP->sy_value.X_op == O_symbol
		     && (! S_IS_DEFINED (add_symbolP)
			 || S_IS_COMMON (add_symbolP)))
		{
		  symbolS *n;

		  /* We must avoid looping, as that can occur with a
		     badly written program.  */
		  n = add_symbolP->sy_value.X_add_symbol;
		  if (n == add_symbolP)
		    break;
		  add_number += add_symbolP->sy_value.X_add_number;
		  add_symbolP = n;
		}
	      fixP->fx_addsy = add_symbolP;
	      fixP->fx_offset = add_number;
	    }
	}

      if (sub_symbolP != NULL && ! sub_symbolP->sy_resolved)
	resolve_symbol_value (sub_symbolP);

      if (add_symbolP != NULL
	  && add_symbolP->sy_mri_common)
	{
	  add_number += S_GET_VALUE (add_symbolP);
	  fixP->fx_offset = add_number;
	  add_symbolP = fixP->fx_addsy = add_symbolP->sy_value.X_add_symbol;
	}

      if (add_symbolP)
	add_symbol_segment = S_GET_SEGMENT (add_symbolP);

      if (sub_symbolP)
	{
	  if (add_symbolP == NULL || add_symbol_segment == absolute_section)
	    {
	      if (add_symbolP != NULL)
		{
		  add_number += S_GET_VALUE (add_symbolP);
		  add_symbolP = NULL;
		  fixP->fx_addsy = NULL;
		}

	      /* It's just -sym.  */
	      if (S_GET_SEGMENT (sub_symbolP) == absolute_section)
		{
		  add_number -= S_GET_VALUE (sub_symbolP);
		  fixP->fx_subsy = 0;
		  fixP->fx_done = 1;
		}
	      else
		{
#ifndef TC_M68K
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("Negative of non-absolute symbol %s"),
				S_GET_NAME (sub_symbolP));
#endif
		  add_number -= S_GET_VALUE (sub_symbolP);
		}		/* not absolute */

	      /* If sub_symbol is in the same segment that add_symbol
		 and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE.  */
	    }
	  else if (S_GET_SEGMENT (sub_symbolP) == add_symbol_segment
		   && SEG_NORMAL (add_symbol_segment))
	    {
	      /* Difference of 2 symbols from same segment.  Can't
		 make difference of 2 undefineds: 'value' means
		 something different for N_UNDF.  */
#ifdef TC_I960
	      /* Makes no sense to use the difference of 2 arbitrary symbols
	         as the target of a call instruction.  */
	      if (fixP->fx_tcbit)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("callj to difference of 2 symbols"));
#endif /* TC_I960 */
	      add_number += S_GET_VALUE (add_symbolP) -
		S_GET_VALUE (sub_symbolP);
	      add_symbolP = NULL;

	      if (!TC_FORCE_RELOCATION (fixP))
		{
		  fixP->fx_addsy = NULL;
		  fixP->fx_subsy = NULL;
		  fixP->fx_done = 1;
#ifdef TC_M68K /* FIXME: Is this right?  */
		  pcrel = 0;
		  fixP->fx_pcrel = 0;
#endif
		}
	    }
	  else
	    {
	      /* Different segments in subtraction.  */
	      know (!(S_IS_EXTERNAL (sub_symbolP) && (S_GET_SEGMENT (sub_symbolP) == absolute_section)));

	      if ((S_GET_SEGMENT (sub_symbolP) == absolute_section))
		add_number -= S_GET_VALUE (sub_symbolP);

#ifdef DIFF_EXPR_OK
	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type)
		{
		  /* Make it pc-relative.  */
		  add_number += (md_pcrel_from (fixP)
				 - S_GET_VALUE (sub_symbolP));
		  pcrel = 1;
		  fixP->fx_pcrel = 1;
		  sub_symbolP = 0;
		  fixP->fx_subsy = 0;
		}
#endif
	      else
		{
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("Can't emit reloc {- %s-seg symbol \"%s\"} @@ file address %ld."),
				segment_name (S_GET_SEGMENT (sub_symbolP)),
				S_GET_NAME (sub_symbolP),
				(long) (fragP->fr_address + where));
		}
	    }
	}

      if (add_symbolP)
	{
	  if (add_symbol_segment == this_segment_type && pcrel)
	    {
	      /* This fixup was made when the symbol's segment was
	         SEG_UNKNOWN, but it is now in the local segment.
	         So we know how to do the address without relocation.  */
#ifdef TC_I960
	      /* reloc_callj() may replace a 'call' with a 'calls' or a 'bal',
	         in which cases it modifies *fixP as appropriate.  In the case
	         of a 'calls', no further work is required, and *fixP has been
	         set up to make the rest of the code below a no-op.  */
	      reloc_callj (fixP);
#endif

	      add_number += S_GET_VALUE (add_symbolP);
	      add_number -= md_pcrel_from (fixP);

	      /* We used to do
		   add_number -= segP->scnhdr.s_vaddr;
		 if defined (TC_I386) || defined (TE_LYNX).  I now
		 think that was an error propagated from the case when
		 we are going to emit the relocation.  If we are not
		 going to emit the relocation, then we just want to
		 set add_number to the difference between the symbols.
		 This is a case that would only arise when there is a
		 PC relative reference from a section other than .text
		 to a symbol defined in the same section, and the
		 reference is not relaxed.  Since jump instructions on
		 the i386 are relaxed, this could only arise with a
		 call instruction.  */

	      /* Lie. Don't want further pcrel processing.  */
	      pcrel = 0;
	      if (!TC_FORCE_RELOCATION (fixP))
		{
		  fixP->fx_addsy = NULL;
		  fixP->fx_done = 1;
		}
	    }
	  else
	    {
	      switch (add_symbol_segment)
		{
		case absolute_section:
#ifdef TC_I960
		  /* See comment about reloc_callj() above.  */
		  reloc_callj (fixP);
#endif /* TC_I960 */
		  add_number += S_GET_VALUE (add_symbolP);
		  add_symbolP = NULL;

		  if (!TC_FORCE_RELOCATION (fixP))
		    {
		      fixP->fx_addsy = NULL;
		      fixP->fx_done = 1;
		    }
		  break;
		default:

#if defined(TC_A29K) || (defined(TE_PE) && defined(TC_I386)) || defined(TC_M88K) || defined(TC_OR32)
		  /* This really should be handled in the linker, but
		     backward compatibility forbids.  */
		  add_number += S_GET_VALUE (add_symbolP);
#else
		  add_number += S_GET_VALUE (add_symbolP) +
		    segment_info[S_GET_SEGMENT (add_symbolP)].scnhdr.s_paddr;
#endif
		  break;

		case SEG_UNKNOWN:
#ifdef TC_I960
		  if ((int) fixP->fx_bit_fixP == 13)
		    {
		      /* This is a COBR instruction.  They have only a
		         13-bit displacement and are only to be used
		         for local branches: flag as error, don't generate
		         relocation.  */
		      as_bad_where (fixP->fx_file, fixP->fx_line,
				    _("can't use COBR format with external label"));
		      fixP->fx_addsy = NULL;
		      fixP->fx_done = 1;
		      continue;
		    }
#endif /* TC_I960 */
#if ((defined (TC_I386) || defined (TE_LYNX) || defined (TE_AUX)) && !defined(TE_PE)) || defined (COFF_COMMON_ADDEND)
		  /* 386 COFF uses a peculiar format in which the
		     value of a common symbol is stored in the .text
		     segment (I've checked this on SVR3.2 and SCO
		     3.2.2) Ian Taylor <ian@@cygnus.com>.  */
		  /* This is also true for 68k COFF on sysv machines
		     (Checked on Motorola sysv68 R3V6 and R3V7.1, and also on
		     UNIX System V/M68000, Release 1.0 from ATT/Bell Labs)
		     Philippe De Muyter <phdm@@info.ucl.ac.be>.  */
		  if (S_IS_COMMON (add_symbolP))
		    add_number += S_GET_VALUE (add_symbolP);
#endif
		  break;

		}
	    }
	}

      if (pcrel)
	{
#if !defined(TC_M88K) && !(defined(TE_PE) && defined(TC_I386)) && !defined(TC_A29K) && !defined(TC_OR32)
	  /* This adjustment is not correct on the m88k, for which the
	     linker does all the computation.  */
	  add_number -= md_pcrel_from (fixP);
#endif
	  if (add_symbolP == 0)
	    fixP->fx_addsy = &abs_symbol;
#if defined (TC_I386) || defined (TE_LYNX) || defined (TC_I960) || defined (TC_M68K)
	  /* On the 386 we must adjust by the segment vaddr as well.
	     Ian Taylor.

	     I changed the i960 to work this way as well.  This is
	     compatible with the current GNU linker behaviour.  I do
	     not know what other i960 COFF assemblers do.  This is not
	     a common case: normally, only assembler code will contain
	     a PC relative reloc, and only branches which do not
	     originate in the .text section will have a non-zero
	     address.

	     I changed the m68k to work this way as well.  This will
	     break existing PC relative relocs from sections which do
	     not start at address 0, but it will make ld -r work.
	     Ian Taylor, 4 Oct 96.  */

	  add_number -= segP->scnhdr.s_vaddr;
#endif
	}

      md_apply_fix (fixP, (valueT *) & add_number, this_segment_type);

      if (!fixP->fx_bit_fixP && ! fixP->fx_no_overflow)
	{
#ifndef TC_M88K
	  /* The m88k uses the offset field of the reloc to get around
	     this problem.  */
	  if ((size == 1
	       && ((add_number & ~0xFF)
		   || (fixP->fx_signed && (add_number & 0x80)))
	       && ((add_number & ~0xFF) != (-1 & ~0xFF)
		   || (add_number & 0x80) == 0))
	      || (size == 2
		  && ((add_number & ~0xFFFF)
		      || (fixP->fx_signed && (add_number & 0x8000)))
		  && ((add_number & ~0xFFFF) != (-1 & ~0xFFFF)
		      || (add_number & 0x8000) == 0)))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("Value of %ld too large for field of %d bytes at 0x%lx"),
			    (long) add_number, size,
			    (unsigned long) (fragP->fr_address + where));
	    }
#endif
#ifdef WARN_SIGNED_OVERFLOW_WORD
	  /* Warn if a .word value is too large when treated as a
	     signed number.  We already know it is not too negative.
	     This is to catch over-large switches generated by gcc on
	     the 68k.  */
	  if (!flag_signed_overflow_ok
	      && size == 2
	      && add_number > 0x7fff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("Signed .word overflow; switch may be too large; %ld at 0x%lx"),
			  (long) add_number,
			  (unsigned long) (fragP->fr_address + where));
#endif
	}
    }
}

/* Fill in the counts in the first entry in a .stab section.  */

static void
adjust_stab_section (bfd *abfd, segT seg)
{
  segT stabstrseg = SEG_UNKNOWN;
  const char *secname, *name2;
  char *name;
  char *p = NULL;
  int i, strsz = 0, nsyms;
  fragS *frag = segment_info[seg].frchainP->frch_root;

  /* Look for the associated string table section.  */

  secname = segment_info[seg].name;
  name = alloca (strlen (secname) + 4);
  strcpy (name, secname);
  strcat (name, "str");

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      name2 = segment_info[i].name;
      if (name2 != NULL && strneq (name2, name, 8))
	{
	  stabstrseg = i;
	  break;
	}
    }

  /* If we found the section, get its size.  */
  if (stabstrseg != SEG_UNKNOWN)
    strsz = size_section (abfd, stabstrseg);

  nsyms = size_section (abfd, seg) / 12 - 1;

  /* Look for the first frag of sufficient size for the initial stab
     symbol, and collect a pointer to it.  */
  while (frag && frag->fr_fix < 12)
    frag = frag->fr_next;
  assert (frag != 0);
  p = frag->fr_literal;
  assert (p != 0);

  /* Write in the number of stab symbols and the size of the string
     table.  */
  bfd_h_put_16 (abfd, (bfd_vma) nsyms, (bfd_byte *) p + 6);
  bfd_h_put_32 (abfd, (bfd_vma) strsz, (bfd_byte *) p + 8);
}

void
write_object_file (void)
{
  int i;
  const char *name;
  struct frchain *frchain_ptr;
  object_headers headers;
  unsigned long file_cursor;
  bfd *abfd;
  unsigned int addr;
  abfd = bfd_openw (out_file_name, TARGET_FORMAT);

  if (abfd == 0)
    {
      as_perror (_("FATAL: Can't create %s"), out_file_name);
      exit (EXIT_FAILURE);
    }
  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, BFD_ARCH, machine);

  string_byte_count = 4;

  /* Run through all the sub-segments and align them up.  Also
     close any open frags.  We tack a .fill onto the end of the
     frag chain so that any .align's size can be worked by looking
     at the next frag.  */
  for (frchain_ptr = frchain_root;
       frchain_ptr != (struct frchain *) NULL;
       frchain_ptr = frchain_ptr->frch_next)
    {
      int alignment;

      subseg_set (frchain_ptr->frch_seg, frchain_ptr->frch_subseg);

      alignment = SUB_SEGMENT_ALIGN (now_seg, frchain_ptr);

#ifdef md_do_align
      md_do_align (alignment, NULL, 0, 0, alignment_done);
#endif
      if (subseg_text_p (now_seg))
	frag_align_code (alignment, 0);
      else
	frag_align (alignment, 0, 0);

#ifdef md_do_align
    alignment_done:
#endif

      frag_wane (frag_now);
      frag_now->fr_fix = 0;
      know (frag_now->fr_next == NULL);
    }

  remove_subsegs ();

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    relax_segment (segment_info[i].frchainP->frch_root, i);

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;

  H_SET_NUMBER_OF_SECTIONS (&headers, 0);

  /* Find out how big the sections are, and set the addresses.  */
  addr = 0;
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      long size;

      segment_info[i].scnhdr.s_paddr = addr;
      segment_info[i].scnhdr.s_vaddr = addr;

      if (segment_info[i].scnhdr.s_name[0])
	{
	  H_SET_NUMBER_OF_SECTIONS (&headers,
				    H_GET_NUMBER_OF_SECTIONS (&headers) + 1);

#ifdef COFF_LONG_SECTION_NAMES
	  /* Support long section names as found in PE.  This code
	     must coordinate with that in coff_header_append and
	     w_strings.  */
	  {
	    unsigned int len;

	    len = strlen (segment_info[i].name);
	    if (len > SCNNMLEN)
	      string_byte_count += len + 1;
	  }
#endif /* COFF_LONG_SECTION_NAMES */
	}

      size = size_section (abfd, (unsigned int) i);
      addr += size;

      /* I think the section alignment is only used on the i960; the
	 i960 needs it, and it should do no harm on other targets.  */
#ifdef ALIGNMENT_IN_S_FLAGS
      segment_info[i].scnhdr.s_flags |= (section_alignment[i] & 0xF) << 8;
#else
      segment_info[i].scnhdr.s_align = 1 << section_alignment[i];
#endif

      if (i == SEG_E0)
	H_SET_TEXT_SIZE (&headers, size);
      else if (i == SEG_E1)
	H_SET_DATA_SIZE (&headers, size);
      else if (i == SEG_E2)
	H_SET_BSS_SIZE (&headers, size);
    }

  /* Turn the gas native symbol table shape into a coff symbol table.  */
  crawl_symbols (&headers, abfd);

  if (string_byte_count == 4)
    string_byte_count = 0;

  H_SET_STRING_SIZE (&headers, string_byte_count);

#ifdef tc_frob_file
  tc_frob_file ();
#endif

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      fixup_mdeps (segment_info[i].frchainP->frch_root, &headers, i);
      fixup_segment (&segment_info[i], i);
    }

  /* Look for ".stab" segments and fill in their initial symbols
     correctly.  */
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      name = segment_info[i].name;

      if (name != NULL
	  && strneq (".stab", name, 5)
	  && ! strneq (".stabstr", name, 8))
	adjust_stab_section (abfd, i);
    }

  file_cursor = H_GET_TEXT_FILE_OFFSET (&headers);

  bfd_seek (abfd, (file_ptr) file_cursor, 0);

  /* Plant the data.  */
  fill_section (abfd, &headers, &file_cursor);

  do_relocs_for (abfd, &headers, &file_cursor);

  do_linenos_for (abfd, &headers, &file_cursor);

  H_SET_FILE_MAGIC_NUMBER (&headers, COFF_MAGIC);
#ifndef OBJ_COFF_OMIT_TIMESTAMP
  H_SET_TIME_STAMP (&headers, (long) time (NULL));
#else
  H_SET_TIME_STAMP (&headers, 0);
#endif
#ifdef TC_COFF_SET_MACHINE
  TC_COFF_SET_MACHINE (&headers);
#endif

#ifndef COFF_FLAGS
#define COFF_FLAGS 0
#endif

#ifdef KEEP_RELOC_INFO
  H_SET_FLAGS (&headers, ((H_GET_LINENO_SIZE (&headers) ? 0 : F_LNNO) |
			  COFF_FLAGS | coff_flags));
#else
  H_SET_FLAGS (&headers, ((H_GET_LINENO_SIZE (&headers)     ? 0 : F_LNNO)   |
			  (H_GET_RELOCATION_SIZE (&headers) ? 0 : F_RELFLG) |
			  COFF_FLAGS | coff_flags));
#endif

  {
    unsigned int symtable_size = H_GET_SYMBOL_TABLE_SIZE (&headers);
    char *buffer1 = xmalloc (symtable_size + string_byte_count + 1);

    H_SET_SYMBOL_TABLE_POINTER (&headers, bfd_tell (abfd));
    w_symbols (abfd, buffer1, symbol_rootP);
    if (string_byte_count > 0)
      w_strings (buffer1 + symtable_size);
    bfd_bwrite (buffer1, (bfd_size_type) symtable_size + string_byte_count,
		abfd);
    free (buffer1);
  }

  coff_header_append (abfd, &headers);

  {
    extern bfd *stdoutput;
    stdoutput = abfd;
  }
}

/* Add a new segment.  This is called from subseg_new via the
   obj_new_segment macro.  */

segT
obj_coff_add_segment (const char *name)
{
  unsigned int i;

#ifndef COFF_LONG_SECTION_NAMES
  char buf[SCNNMLEN + 1];

  strncpy (buf, name, SCNNMLEN);
  buf[SCNNMLEN] = '\0';
  name = buf;
#endif

  for (i = SEG_E0; i < SEG_LAST && segment_info[i].scnhdr.s_name[0]; i++)
    if (streq (name, segment_info[i].name))
      return (segT) i;

  if (i == SEG_LAST)
    {
      as_bad (_("Too many new sections; can't add \"%s\""), name);
      return now_seg;
    }

  /* Add a new section.  */
  strncpy (segment_info[i].scnhdr.s_name, name,
	   sizeof (segment_info[i].scnhdr.s_name));
  segment_info[i].scnhdr.s_flags = STYP_REG;
  segment_info[i].name = xstrdup (name);

  return (segT) i;
}

/* Implement the .section pseudo op:
  	.section name {, "flags"}
                  ^         ^
                  |         +--- optional flags: 'b' for bss
                  |                              'i' for info
                  +-- section name               'l' for lib
                                                 'n' for noload
                                                 'o' for over
                                                 'w' for data
  						 'd' (apparently m88k for data)
                                                 'x' for text
  						 'r' for read-only data
   But if the argument is not a quoted string, treat it as a
   subsegment number.  */

void
obj_coff_section (int ignore ATTRIBUTE_UNUSED)
{
  /* Strip out the section name.  */
  char *section_name, *name;
  char c;
  unsigned int exp;
  long flags;

  if (flag_mri)
    {
      char type;

      s_mri_sect (&type);
      flags = 0;
      if (type == 'C')
	flags = STYP_TEXT;
      else if (type == 'D')
	flags = STYP_DATA;
      segment_info[now_seg].scnhdr.s_flags |= flags;

      return;
    }

  section_name = input_line_pointer;
  c = get_symbol_end ();

  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);

  *input_line_pointer = c;

  exp = 0;
  flags = 0;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (*input_line_pointer != '"')
	exp = get_absolute_expression ();
      else
	{
	  ++input_line_pointer;
	  while (*input_line_pointer != '"'
		 && ! is_end_of_line[(unsigned char) *input_line_pointer])
	    {
	      switch (*input_line_pointer)
		{
		case 'b': flags |= STYP_BSS;    break;
		case 'i': flags |= STYP_INFO;   break;
		case 'l': flags |= STYP_LIB;    break;
		case 'n': flags |= STYP_NOLOAD; break;
		case 'o': flags |= STYP_OVER;   break;
		case 'd':
		case 'w': flags |= STYP_DATA;   break;
		case 'x': flags |= STYP_TEXT;   break;
		case 'r': flags |= STYP_LIT;	break;
		default:
		  as_warn (_("unknown section attribute '%c'"),
			   *input_line_pointer);
		  break;
		}
	      ++input_line_pointer;
	    }
	  if (*input_line_pointer == '"')
	    ++input_line_pointer;
	}
    }

  subseg_new (name, (subsegT) exp);

  segment_info[now_seg].scnhdr.s_flags |= flags;

  demand_empty_rest_of_line ();
}

static void
obj_coff_text (int ignore ATTRIBUTE_UNUSED)
{
  subseg_new (".text", get_absolute_expression ());
}

static void
obj_coff_data (int ignore ATTRIBUTE_UNUSED)
{
  if (flag_readonly_data_in_text)
    subseg_new (".text", get_absolute_expression () + 1000);
  else
    subseg_new (".data", get_absolute_expression ());
}

static void
obj_coff_ident (int ignore ATTRIBUTE_UNUSED)
{
  segT current_seg = now_seg;		/* Save current seg.  */
  subsegT current_subseg = now_subseg;

  subseg_new (".comment", 0);		/* .comment seg.  */
  stringer (1);				/* Read string.  */
  subseg_set (current_seg, current_subseg);	/* Restore current seg.  */
}

void
c_dot_file_symbol (const char *filename, int appfile ATTRIBUTE_UNUSED)
{
  symbolS *symbolP;

  symbolP = symbol_new (".file", SEG_DEBUG, 0, & zero_address_frag);

  S_SET_STORAGE_CLASS (symbolP, C_FILE);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);

  if (strlen (filename) > FILNMLEN)
    {
      /* Filename is too long to fit into an auxent,
	 we stick it into the string table instead.  We keep
	 a linked list of the filenames we find so we can emit
	 them later.  */
      struct filename_list *f = xmalloc (sizeof (* f));

      f->filename = filename;
      f->next = 0;

      SA_SET_FILE_FNAME_ZEROS (symbolP, 0);
      SA_SET_FILE_FNAME_OFFSET (symbolP, 1);

      if (filename_list_tail)
	filename_list_tail->next = f;
      else
	filename_list_head = f;
      filename_list_tail = f;
    }
  else
    SA_SET_FILE_FNAME (symbolP, filename);

#ifndef NO_LISTING
  {
    extern int listing;
    if (listing)
      listing_source_file (filename);
  }
#endif

  SF_SET_DEBUG (symbolP);
  S_SET_VALUE (symbolP, (valueT) previous_file_symbol);

  previous_file_symbol = symbolP;

  /* Make sure that the symbol is first on the symbol chain.  */
  if (symbol_rootP != symbolP)
    {
      symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
      symbol_insert (symbolP, symbol_rootP, &symbol_rootP, &symbol_lastP);
    }
}

static void
obj_coff_lcomm (int ignore ATTRIBUTE_UNUSED)
{
  s_lcomm (0);
  return;
}

/* The first entry in a .stab section is special.  */

void
obj_coff_init_stab_section (segT seg)
{
  char *file;
  char *p;
  char *stabstr_name;
  unsigned int stroff;

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  as_where (&file, (unsigned int *) NULL);
  stabstr_name = alloca (strlen (segment_info[seg].name) + 4);
  strcpy (stabstr_name, segment_info[seg].name);
  strcat (stabstr_name, "str");
  stroff = get_stab_string_offset (file, stabstr_name);
  know (stroff == 1);
  md_number_to_chars (p, stroff, 4);
}

#endif /* not BFD_ASSEMBLER */

const pseudo_typeS coff_pseudo_table[] =
{
  {"ABORT", s_abort, 0},
  {"appline", obj_coff_ln, 1},
  /* We accept the .bss directive for backward compatibility with
     earlier versions of gas.  */
  {"bss", obj_coff_bss, 0},
  {"def", obj_coff_def, 0},
  {"dim", obj_coff_dim, 0},
  {"endef", obj_coff_endef, 0},
  {"ident", obj_coff_ident, 0},
  {"line", obj_coff_line, 0},
  {"ln", obj_coff_ln, 0},
  {"scl", obj_coff_scl, 0},
  {"sect", obj_coff_section, 0},
  {"sect.s", obj_coff_section, 0},
  {"section", obj_coff_section, 0},
  {"section.s", obj_coff_section, 0},
  /* FIXME: We ignore the MRI short attribute.  */
  {"size", obj_coff_size, 0},
  {"tag", obj_coff_tag, 0},
  {"type", obj_coff_type, 0},
  {"val", obj_coff_val, 0},
  {"version", s_ignore, 0},
#ifdef BFD_ASSEMBLER
  {"loc", obj_coff_loc, 0},
  {"optim", s_ignore, 0},	/* For sun386i cc (?) */
  {"weak", obj_coff_weak, 0},
#else
  {"data", obj_coff_data, 0},
  {"lcomm", obj_coff_lcomm, 0},
  {"text", obj_coff_text, 0},
  {"use", obj_coff_section, 0},
#endif
#if defined TC_M88K || defined TC_TIC4X
  /* The m88k and tic4x uses sdef instead of def.  */
  {"sdef", obj_coff_def, 0},
#endif
  {NULL, NULL, 0}
};

#ifdef BFD_ASSEMBLER

/* Support for a COFF emulation.  */

static void
coff_pop_insert (void)
{
  pop_insert (coff_pseudo_table);
}

static int
coff_separate_stab_sections (void)
{
  return 1;
}

const struct format_ops coff_format_ops =
{
  bfd_target_coff_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  0,    /* begin */
  c_dot_file_symbol,
  coff_frob_symbol,
  0,	/* frob_file */
  0,	/* frob_file_before_adjust */
  0,	/* frob_file_before_fix */
  coff_frob_file_after_relocs,
  0,	/* s_get_size */
  0,	/* s_set_size */
  0,	/* s_get_align */
  0,	/* s_set_align */
  0,	/* s_get_other */
  0,	/* s_set_other */
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  0,	/* copy_symbol_attributes */
  0,	/* generate_asm_lineno */
a1778 2

#endif
@


1.84
log
@Update the address and phone number of the FSF
@
text
@d3885 1
a3885 1
      md_apply_fix3 (fixP, (valueT *) & add_number, this_segment_type);
@


1.83
log
@	* Makefile.am (GAS_CFILES): Remove bignum-copy.c.
	(GENERIC_OBJS): Likewise, remove bignum-copy.o.
	(bignum-copy.o): Remove.
	* Makefile.in: Regenerate.
	* makefile.vms (OBJS): Remove bignum-copy.obj.
	* symbols.h (local_symbol_make): Remove declaration.
	(verify_symbol_chain_2): Likewise.
	* symbols.c (local_symbol_make): Make static.
	(max_indent_level): Likewise.
	(verify_symbol_chain_2): Remove.
	* macro.c (macro_hash): Make static.
	* messages.c (fprint_value): Remove.
	* read.h (get_absolute_expr): Remove.
	(emit_leb128_expr): Likewise.
	(do_s_func): Likewise.
	* read.c (do_s_func): Make static.
	(emit_leb128_expr): Likewise.
	(get_absolute_expr): Likewise.
	* as.h (as_howmuch): Remove declaration.
	(fprint_value): Likewise.
	* as.c (myname): Make static.
	* input-scrub.c (as_howmuch): Remove.
	(as_1_char): Likewise.
	* input-file.h (input_file_is_open): Remove.
	* input-file.c (input_file_is_open): Likewise.
	* expr.h (expr_build_unary): Remove declaration.
	(expr_build_binary): Likewise.
	* expr.c (expr_build_unary): Remove.
	(expr_build_binary): Likewise.
	* hash.h (hash_replace): Remove declaration.
	(hash_delete): Likewise.
	* hash.c (hash_replace): Remove.
	(hash_delete): Likewise.
	* bignum-copy.c (bignum_copy): Move from here ..
	* config/tc-vax.c (bignum_copy): .. to here.
	* bignum.h (LOG_TO_BASE_2_OF_10): Remove.
	(bignum_copy): Remove extern declaration.
	* sb.h (string_count): Remove extern declaration.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* sb.c (dsize): Replace preprocessor macro with static int.
	(string_count): Make static.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* config/obj-coff.c (dim_index): Make static.
	* config/tc-i386.c (GOT_symbol): Likewise.
	(output_invalid_buf): Likewise.
	* doc/internals.texi (Warning and error messages): Remove the
	prototype for fprint_value.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.82
log
@gas/
2005-04-19  Jan Beulich  <jbeulich@@novell.com>

	* symbols.h (symbol_find_base): Remove prototype.
	* symbols.c (save_symbol_name): Remove code section conditional upon
	STRIP_UNDERSCORE.
	(symbol_find): Remove.
	(symbol_find_base): Rename to symbol_find.
	* subsegs.c (section_symbol): Replace use of symbol_find_base with
	symbol_find.
	* config/obj-coff.c (tag_insert): Remove code section conditional
	upon STRIP_UNDERSCORE.
	(obj_coff_def): Likewise.
	(obj_coff_endef): Replace use of symbol_find_base with symbol_find.
	(coff_frob_symbol): Likewise.
	(yank_symbols): Likewise.
	(c_section_symbol): Likewise.
	* config/obj-coff.h (DO_NOT_STRIP): Remove.
	* config/tc-arm.c (symbol_locate): Remove code section conditional
	upon STRIP_UNDERSCORE.
	* config/tc-h8300.h (DO_NOT_STRIP): Remove.
	* config/tc-h8500.h (DO_NOT_STRIP): Remove.
	* config/tc-sh.h (DO_NOT_STRIP): Remove.
	* config/tc-w65.h (DO_NOT_STRIP): Remove.
	* config/tc-z8k.h (DO_NOT_STRIP): Remove.
@
text
@d2478 1
a2478 1
unsigned int dim_index;
@


1.81
log
@	* config/obj-coff.c (coff_frob_symbol): When crashing because of a
	bad C_EFCN symbol, print its name.
@
text
@a139 4
#ifdef STRIP_UNDERSCORE
  if (*name == '_')
    name++;
#endif /* STRIP_UNDERSCORE */
a527 5
#ifdef STRIP_UNDERSCORE
  if (symbol_name[0] == '_' && symbol_name[1] != 0)
    symbol_name++;
#endif

d717 1
a717 2
      || (symbolP = symbol_find_base (S_GET_NAME (def_symbol_in_progress),
				      DO_NOT_STRIP)) == NULL
d764 1
a764 2
      oldtag = symbol_find_base (S_GET_NAME (def_symbol_in_progress),
				 DO_NOT_STRIP);
d1237 1
a1237 1
	  && (real = symbol_find_base (S_GET_NAME (symp), DO_NOT_STRIP))
a2444 5
#ifdef STRIP_UNDERSCORE
  S_SET_NAME (def_symbol_in_progress, (*symbol_name_copy == '_'
				       ? symbol_name_copy + 1
				       : symbol_name_copy));
#else /* STRIP_UNDERSCORE */
a2445 1
#endif /* STRIP_UNDERSCORE */
d2597 1
a2597 1
      || (symbolP = symbol_find_base (S_GET_NAME (def_symbol_in_progress), DO_NOT_STRIP)) == NULL
d2640 1
a2640 2
      oldtag = symbol_find_base (S_GET_NAME (def_symbol_in_progress),
				 DO_NOT_STRIP);
d2962 1
a2962 1
	      && (real_symbolP = symbol_find_base (S_GET_NAME (symbolP), DO_NOT_STRIP))
d3225 1
a3225 1
  symbolP = symbol_find_base (name, DO_NOT_STRIP);
@


1.80
log
@Convert to ISO C90 formatting
@
text
@d1304 2
a1305 1
		as_fatal (_("C_EFCN symbol out of scope"));
@


1.79
log
@	* config/obj-coff.c (fixup_segment): Delete sy_mri_common assertion.
@
text
@d33 3
a65 26
static stack *stack_init PARAMS ((unsigned long, unsigned long));
static char *stack_push PARAMS ((stack *, char *));
static char *stack_pop PARAMS ((stack *));
static void tag_init PARAMS ((void));
static void tag_insert PARAMS ((const char *, symbolS *));
static symbolS *tag_find PARAMS ((char *));
static symbolS *tag_find_or_make PARAMS ((char *));
static void obj_coff_bss PARAMS ((int));
#ifdef BFD_ASSEMBLER
static void obj_coff_weak PARAMS ((int));
#endif
const char *s_get_name PARAMS ((symbolS * s));
static void obj_coff_ln PARAMS ((int));
static void obj_coff_def PARAMS ((int));
static void obj_coff_endef PARAMS ((int));
static void obj_coff_dim PARAMS ((int));
static void obj_coff_line PARAMS ((int));
static void obj_coff_size PARAMS ((int));
static void obj_coff_scl PARAMS ((int));
static void obj_coff_tag PARAMS ((int));
static void obj_coff_val PARAMS ((int));
static void obj_coff_type PARAMS ((int));
static void obj_coff_ident PARAMS ((int));
#ifdef BFD_ASSEMBLER
static void obj_coff_loc PARAMS((int));
#endif
d67 1
a67 1
/* stack stuff */
d70 2
a71 3
stack_init (chunk_size, element_size)
     unsigned long chunk_size;
     unsigned long element_size;
d75 1
a75 1
  st = (stack *) malloc (sizeof (stack));
d77 1
a77 1
    return 0;
d82 1
a82 1
      return 0;
d92 1
a92 3
stack_push (st, element)
     stack *st;
     char *element;
d97 2
a98 2
      if ((st->data = xrealloc (st->data, st->size)) == (char *) 0)
	return (char *) 0;
d106 1
a106 2
stack_pop (st)
     stack *st;
d111 1
a111 1
      return (char *) 0;
d117 1
a117 3
/*
 * Maintain a list of the tagnames of the structures.
 */
d122 1
a122 1
tag_init ()
d128 1
a128 3
tag_insert (name, symbolP)
     const char *name;
     symbolS *symbolP;
d133 2
a134 4
    {
      as_fatal (_("Inserting \"%s\" into structure table failed: %s"),
		name, error_string);
    }
d138 1
a138 2
tag_find (name)
     char *name;
d148 1
a148 2
tag_find_or_make (name)
     char *name;
d161 1
a161 1
    }				/* not found */
d170 1
a170 2
obj_coff_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
a179 6
static segT fetch_coff_debug_section PARAMS ((void));
static void SA_SET_SYM_TAGNDX PARAMS ((symbolS *, symbolS *));
static int S_GET_DATA_TYPE PARAMS ((symbolS *));
void c_symbol_merge PARAMS ((symbolS *, symbolS *));
static void add_lineno PARAMS ((fragS *, addressT, int));

d181 1
a181 1
((char*) (&((X)->sy_symbol.ost_auxent->x_file.x_n.x_offset))[1])
d185 1
a185 1
fetch_coff_debug_section ()
d188 1
d192 2
a193 1
      s = bfd_make_debug_symbol (stdoutput, (char *) 0, 0);
d201 1
a201 3
SA_SET_SYM_ENDNDX (sym, val)
     symbolS *sym;
     symbolS *val;
d212 1
a212 3
SA_SET_SYM_TAGNDX (sym, val)
     symbolS *sym;
     symbolS *val;
d223 1
a223 2
S_GET_DATA_TYPE (sym)
     symbolS *sym;
d229 1
a229 3
S_SET_DATA_TYPE (sym, val)
     symbolS *sym;
     int val;
d236 1
a236 2
S_GET_STORAGE_CLASS (sym)
     symbolS *sym;
d242 1
a242 3
S_SET_STORAGE_CLASS (sym, val)
     symbolS *sym;
     int val;
d250 2
a251 4
void
c_symbol_merge (debug, normal)
     symbolS *debug;
     symbolS *normal;
d257 2
a258 4
    {
      /* take the most we have */
      S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));
    }
d261 4
a264 6
    {
      /* Move all the auxiliary information.  */
      memcpy (SYM_AUXINFO (normal), SYM_AUXINFO (debug),
	      (S_GET_NUMBER_AUXILIARY (debug)
	       * sizeof (*SYM_AUXINFO (debug))));
    }
d287 1
d289 1
a289 3
      {
	listing_source_file (filename);
      }
d293 1
a293 1
  /* Make sure that the symbol is first on the symbol chain */
d298 1
a298 1
    }				/* if not first on the list */
d301 1
a301 1
/* Line number handling */
d303 2
a304 1
struct line_no {
d321 1
a321 2
coff_obj_symbol_new_hook (symbolP)
     symbolS *symbolP;
d324 1
a324 1
  char * s  = (char *) xmalloc (sz);
d341 1
a341 3
/*
 * Handle .ln directives.
 */
d345 1
a345 1
/* @@@@ Blindly assume all .ln directives will be in the .text section...  */
d349 1
a349 4
add_lineno (frag, offset, num)
     fragS *frag;
     addressT offset;
     int num;
d351 2
a352 2
  struct line_no *new_line =
    (struct line_no *) xmalloc (sizeof (struct line_no));
d354 1
a354 3
    {
      abort ();
    }
d357 1
a357 1
  /* The native aix assembler accepts negative line number */
d375 1
a375 2
coff_add_linesym (sym)
     symbolS *sym;
d388 1
a388 2
obj_coff_ln (appline)
     int appline;
d428 1
a428 2
obj_coff_loc (ignore)
     int ignore ATTRIBUTE_UNUSED;
d475 1
a475 2
obj_coff_ident (ignore)
     int ignore ATTRIBUTE_UNUSED;
d500 8
a507 13
/*
 *			def()
 *
 * Handle .def directives.
 *
 * One might ask : why can't we symbol_new if the symbol does not
 * already exist and fill it with debug information.  Because of
 * the C_EFCN special symbol. It would clobber the value of the
 * function symbol before we have a chance to notice that it is
 * a C_EFCN. And a second reason is that the code is more clear this
 * way. (at least I think it is :-).
 *
 */
d511 2
a512 2
				       *input_line_pointer == '\t') \
    input_line_pointer++;
d515 1
a515 2
obj_coff_def (what)
     int what ATTRIBUTE_UNUSED;
d517 3
a519 3
  char name_end;		/* Char after the end of name */
  char *symbol_name;		/* Name of the debug symbol */
  char *symbol_name_copy;	/* Temporary copy of the name */
d527 1
a527 1
    }				/* if not inside .def/.endef */
d535 1
a535 1
#endif /* STRIP_UNDERSCORE */
d545 1
a545 1
  /* Initialize the new symbol */
d561 1
a561 2
obj_coff_endef (ignore)
     int ignore ATTRIBUTE_UNUSED;
a564 1
  /* DIM BUG FIX sac@@cygnus.com */
d571 1
a571 1
    }				/* if not inside .def/.endef */
d580 1
a580 1
      /* intentional fallthrough */
d589 1
a589 1
      /* intentional fallthrough */
d591 2
a592 2
      SF_SET_PROCESS (def_symbol_in_progress);	/* Will need processing before writing */
      /* intentional fallthrough */
d596 1
d687 1
a687 1
      /* Valid but set somewhere else (s_comm, s_lcomm, colon) */
d697 1
a697 1
    }				/* switch on storage class */
d720 3
a722 3
      || (!strcmp (bfd_get_section_name (stdoutput,
					 S_GET_SEGMENT (def_symbol_in_progress)),
		   "*DEBUG*")
d744 1
a744 1
	 symbols. [loic] */
d761 1
a761 1
	  /* If it already is at the end of the symbol list, do nothing */
d788 5
a792 6
	{
	  /* That is, if this is the first time we've seen the
	     function...  */
	  symbol_table_insert (def_symbol_in_progress);
	} /* definition follows debug */
    } /* Create the line number entry pointing to the function being defined */
d799 1
a799 2
obj_coff_dim (ignore)
     int ignore ATTRIBUTE_UNUSED;
d808 1
a808 1
    }				/* if not inside .def/.endef */
d826 1
a826 1
	  /* intentional fallthrough */
d838 1
a838 2
obj_coff_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
d850 1
a850 1
  if (!strcmp (".bf", S_GET_NAME (def_symbol_in_progress)))
d859 1
a859 1
  if (strcmp (".bf", S_GET_NAME (def_symbol_in_progress)) == 0)
d870 1
a870 2
obj_coff_size (ignore)
     int ignore ATTRIBUTE_UNUSED;
d877 1
a877 1
    }				/* if not inside .def/.endef */
d885 1
a885 2
obj_coff_scl (ignore)
     int ignore ATTRIBUTE_UNUSED;
d892 1
a892 1
    }				/* if not inside .def/.endef */
d899 1
a899 2
obj_coff_tag (ignore)
     int ignore ATTRIBUTE_UNUSED;
d924 1
a924 3
    {
      as_warn (_("tag not found for .tag %s"), symbol_name);
    }				/* not defined */
d933 1
a933 2
obj_coff_type (ignore)
     int ignore ATTRIBUTE_UNUSED;
d940 1
a940 1
    }				/* if not inside .def/.endef */
d946 1
a946 3
    {
      SF_SET_FUNCTION (def_symbol_in_progress);
    }				/* is a function */
d952 1
a952 2
obj_coff_val (ignore)
     int ignore ATTRIBUTE_UNUSED;
d959 1
a959 1
    }				/* if not inside .def/.endef */
d969 1
a969 1
      if (!strcmp (symbol_name, "."))
d971 1
a973 1
	  /* If the .val is != from the .def (e.g. statics) */
d975 1
a975 1
      else if (strcmp (S_GET_NAME (def_symbol_in_progress), symbol_name))
d1003 1
a1003 1
    }				/* if symbol based */
d1015 1
a1015 1
  return ! strncmp (name, weak_altprefix, sizeof (weak_altprefix) - 1);
d1031 1
a1031 1
/* Return the name of the weak symbol corresponding to an 
d1138 1
a1138 1
coff_obj_read_begin_hook ()
d1154 1
a1154 3
coff_frob_symbol (symp, punt)
     symbolS *symp;
     int *punt;
d1168 1
a1168 1
    coff_add_linesym ((symbolS *) 0);
d1247 1
a1247 1
	  && symbol_constant_p(symp)
d1275 1
a1275 1
	      if (!strcmp (S_GET_NAME (symp), ".bb"))
a1319 2

      /* more ...  */
d1365 1
a1365 1
      && strcmp (S_GET_NAME (symp), ".bf") == 0)
d1386 1
a1386 1
      l = (alent *) xmalloc ((i + 2) * sizeof (alent));
d1401 3
a1403 4
coff_adjust_section_syms (abfd, sec, x)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR x ATTRIBUTE_UNUSED;
d1414 1
a1414 1
  if (!strcmp (sec->name, ".text"))
d1436 1
d1445 1
a1445 1
coff_frob_file_after_relocs ()
d1447 1
a1447 1
  bfd_map_over_sections (stdoutput, coff_adjust_section_syms, (char*) 0);
d1470 1
a1470 2
obj_coff_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1472 1
a1472 1
  /* Strip out the section name */
d1518 2
a1519 2
		case 's': flags |= SEC_COFF_SHARED; /* fall through */
		case 'd': flags |= SEC_DATA | SEC_LOAD; /* fall through */
d1534 2
a1535 2
		  as_warn(_("unknown section attribute '%c'"),
			  *input_line_pointer);
d1559 1
a1559 1
      if (strncmp (name, ".gnu.linkonce", sizeof (".gnu.linkonce") - 1) == 0)
d1570 1
a1570 1
      /* This section's attributes have already been set. Warn if the
d1582 1
a1582 1
coff_adjust_symtab ()
d1590 1
a1590 2
coff_frob_section (sec)
     segT sec;
d1643 1
a1643 1
  /* @@@@ these should be in a "stabs.h" file, or maybe as.h */
d1650 1
a1650 1
  if (strcmp (STAB_STRING_SECTION_NAME, sec->name))
d1673 1
a1673 2
obj_coff_init_stab_section (seg)
     segT seg;
d1685 1
a1685 1
  stabstr_name = (char *) xmalloc (strlen (seg->name) + 4);
a1693 1
/* for debugging */
d1695 1
a1695 2
s_get_name (s)
     symbolS *s;
d1701 1
a1701 1
symbol_dump ()
d1706 6
a1711 8
    {
      printf (_("0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n"),
	     (unsigned long) symbolP,
	     S_GET_NAME(symbolP),
	     (long) S_GET_DATA_TYPE(symbolP),
	     S_GET_STORAGE_CLASS(symbolP),
	     (int) S_GET_SEGMENT(symbolP));
    }
a1780 27
void c_symbol_merge PARAMS ((symbolS *, symbolS *));
symbolS *c_section_symbol PARAMS ((char *, int));
void obj_coff_section PARAMS ((int));
void do_relocs_for PARAMS ((bfd *, object_headers *, unsigned long *));
char * symbol_to_chars PARAMS ((bfd *, char *, symbolS *));
void w_strings PARAMS ((char *));

static void fixup_segment PARAMS ((segment_info_type *, segT));
static void fixup_mdeps PARAMS ((fragS *, object_headers *, segT));
static void fill_section PARAMS ((bfd *,  object_headers *, unsigned long *));
static int c_line_new PARAMS ((symbolS *, long, int, fragS *));
static void w_symbols PARAMS ((bfd *, char *, symbolS *));
static void adjust_stab_section PARAMS ((bfd *, segT));
static void obj_coff_lcomm PARAMS ((int));
static void obj_coff_text PARAMS ((int));
static void obj_coff_data PARAMS ((int));
static unsigned int count_entries_in_chain PARAMS ((unsigned int));
static void coff_header_append PARAMS ((bfd *, object_headers *));
static unsigned int yank_symbols PARAMS ((void));
static unsigned int glue_symbols PARAMS ((symbolS **, symbolS **));
static unsigned int tie_tags PARAMS ((void));
static void crawl_symbols PARAMS ((object_headers *, bfd *));
static void do_linenos_for PARAMS ((bfd *, object_headers *, unsigned long *));
static void remove_subsegs PARAMS ((void));



a1817 2
static relax_addressT relax_align PARAMS ((relax_addressT, long));

d1819 1
a1819 3
relax_align (address, alignment)
     relax_addressT address;
     long alignment;
d1826 2
a1827 1
  return (new_address - address);
d1831 1
a1831 2
s_get_segment (x)
     symbolS * x;
a1835 2
static unsigned int size_section PARAMS ((bfd *, unsigned int));

d1840 1
a1840 3
size_section (abfd, idx)
     bfd *abfd ATTRIBUTE_UNUSED;
     unsigned int idx;
d1891 1
a1891 2
count_entries_in_chain (idx)
     unsigned int idx;
a1919 2
static int compare_external_relocs PARAMS ((const PTR, const PTR));

d1923 1
a1923 3
compare_external_relocs (x, y)
     const PTR x;
     const PTR y;
d1929 1
d1937 2
a1938 5
void
do_relocs_for (abfd, h, file_cursor)
     bfd * abfd;
     object_headers * h;
     unsigned long *file_cursor;
d1953 1
d1961 1
a1961 2
	      external_reloc_vec =
		(struct external_reloc *) malloc (external_reloc_size);
d2067 1
a2067 1
	      qsort ((PTR) external_reloc_vec, nrelocs,
d2071 1
a2071 1
	      bfd_bwrite ((PTR) external_reloc_vec,
d2096 3
a2098 4
fill_section (abfd, h, file_cursor)
     bfd * abfd;
     object_headers *h ATTRIBUTE_UNUSED;
     unsigned long *file_cursor;
d2124 1
a2124 1
	  if (strcmp (s->s_name, ".text") == 0)
d2126 1
a2126 1
	  else if (strcmp (s->s_name, ".data") == 0)
d2128 1
a2128 1
	  else if (strcmp (s->s_name, ".bss") == 0)
d2147 1
a2147 1
	  else if (strcmp (s->s_name, ".lit") == 0)
d2149 1
a2149 1
	  else if (strcmp (s->s_name, ".init") == 0)
d2151 1
a2151 1
	  else if (strcmp (s->s_name, ".fini") == 0)
d2153 1
a2153 1
	  else if (strncmp (s->s_name, ".comment", 8) == 0)
d2159 1
d2191 1
d2230 1
a2230 3
coff_header_append (abfd, h)
     bfd * abfd;
     object_headers * h;
d2239 1
a2239 1
  bfd_seek (abfd, (file_ptr) 0, 0);
d2247 2
a2248 2
  H_SET_SIZEOF_OPTIONAL_HEADER (h, bfd_coff_swap_aouthdr_out(abfd, &h->aouthdr,
							     buffero));
d2285 2
a2286 5
char *
symbol_to_chars (abfd, where, symbolP)
     bfd * abfd;
     char *where;
     symbolS * symbolP;
d2324 1
a2324 2
coff_obj_symbol_new_hook (symbolP)
     symbolS *symbolP;
d2345 30
d2378 1
a2378 2
obj_coff_ln (appline)
     int appline;
a2405 1

d2412 1
a2412 1
 
d2422 2
a2423 2
				      *input_line_pointer == '\t') \
                                         input_line_pointer++;
d2426 1
a2426 2
obj_coff_def (what)
     int what ATTRIBUTE_UNUSED;
d2442 1
a2442 1
  def_symbol_in_progress = (symbolS *) obstack_alloc (&notes, sizeof (*def_symbol_in_progress));
d2476 18
d2497 1
a2497 2
obj_coff_endef (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2500 1
a2500 1
  /* DIM BUG FIX sac@@cygnus.com */
d2516 1
a2516 1
      /* Intentional fallthrough.  */
d2527 2
a2528 2
      /* Intentional fallthrough. */
      
d2532 1
a2532 1
      /* Intentional fallthrough.  */
d2537 2
a2538 2
      if (strcmp (S_GET_NAME (def_symbol_in_progress), ".bf") == 0)
	{			/* .bf */
d2672 2
a2673 5
	{
	  /* That is, if this is the first time we've seen the
	     function...  */
	  symbol_table_insert (def_symbol_in_progress);
	}
d2681 1
a2681 2
obj_coff_dim (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2708 1
a2708 1
	  /* Intentional fallthrough.  */
d2721 1
a2721 2
obj_coff_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2738 1
a2738 1
  if (!strcmp (".bf", name))
d2758 1
a2758 2
obj_coff_size (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2773 1
a2773 2
obj_coff_scl (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2787 1
a2787 2
obj_coff_tag (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2820 1
a2820 2
obj_coff_type (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2839 1
a2839 2
obj_coff_val (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2857 1
a2857 1
      if (!strcmp (symbol_name, "."))
d2863 1
a2863 1
      else if (strcmp (S_GET_NAME (def_symbol_in_progress), symbol_name))
d2895 1
a2895 1
    }				/* if symbol based */
d2906 1
a2906 2
obj_coff_pe_handle_link_once (type)
     enum linkonce_type type;
d2918 1
a2918 1
coff_obj_read_begin_hook ()
d2945 1
a2945 1
yank_symbols ()
a2949 1

d3008 1
a3008 3
		{
		  S_SET_EXTERNAL (symbolP);
		}
d3023 1
a3023 1
		  if (!strcmp (S_GET_NAME (symbolP), ".bb"))
d3031 1
a3031 1
		      if (begin_symbolP == (symbolS *) 0)
d3037 1
d3042 1
a3042 2
	      if (last_functionP == (symbolS *) 0 &&
		  SF_GET_FUNCTION (symbolP))
d3049 1
d3052 1
a3052 1
		  if (strcmp (S_GET_NAME (symbolP), ".bf") == 0)
d3063 1
a3063 1
		  if (last_functionP == (symbolS *) 0)
d3069 1
a3069 1
		 last_functionP = (symbolS *) 0;
d3074 3
a3076 4
	{
	  /* First descriptor of a structure must point to
	     the first slot after the structure description.  */
	  last_tagP = symbolP;
a3077 1
	}
d3079 3
a3081 4
	{
	  /* +2 take in account the current symbol.  */
	  SA_SET_SYM_ENDNDX (last_tagP, symbol_number + 2);
	}
d3116 3
a3118 4
	{
	  /* Remove C_EFCN and LOCAL (L...) symbols.  */
	  /* Next pointer remains valid.  */
	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
a3119 1
	}
d3122 4
a3125 5
	{
	  /* Skip symbols which were equated to undefined or common
	     symbols.  */
	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	}
d3171 1
a3171 3
	    {
	      symbolP->sy_name_offset = 0;
	    }
d3182 1
a3182 3
glue_symbols (head, tail)
     symbolS **head;
     symbolS **tail;
d3201 2
a3202 4
	{
	  /* Fix "long" names.  */
	  tmp->sy_name_offset = 0;
	}
d3212 1
a3212 1
tie_tags ()
d3235 60
d3296 1
a3296 3
crawl_symbols (h, abfd)
     object_headers *h;
     bfd *abfd ATTRIBUTE_UNUSED;
a3300 1

a3318 1

d3343 2
a3344 3
void
w_strings (where)
     char *where;
d3399 3
a3401 4
do_linenos_for (abfd, h, file_cursor)
     bfd * abfd;
     object_headers * h;
     unsigned long *file_cursor;
d3413 1
a3413 4

	  struct external_lineno *buffer =
	  (struct external_lineno *) xmalloc (s->scnhdr.s_nlnno * LINESZ);

d3455 1
a3455 1
remove_subsegs ()
d3491 2
a3492 2
extern void
write_object_file ()
d3494 2
a3495 3
  int i;
  const char *name;
  struct frchain *frchain_ptr;
d3497 2
a3498 7
  object_headers headers;
  unsigned long file_cursor;
  bfd *abfd;
  unsigned int addr;
  abfd = bfd_openw (out_file_name, TARGET_FORMAT);

  if (abfd == 0)
d3500 7
a3506 2
      as_perror (_("FATAL: Can't create %s"), out_file_name);
      exit (EXIT_FAILURE);
a3507 2
  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, BFD_ARCH, machine);
d3509 2
a3510 9
  string_byte_count = 4;

  /* Run through all the sub-segments and align them up.  Also
     close any open frags.  We tack a .fill onto the end of the
     frag chain so that any .align's size can be worked by looking
     at the next frag.  */
  for (frchain_ptr = frchain_root;
       frchain_ptr != (struct frchain *) NULL;
       frchain_ptr = frchain_ptr->frch_next)
d3512 3
a3514 1
      int alignment;
d3516 6
a3521 1
      subseg_set (frchain_ptr->frch_seg, frchain_ptr->frch_subseg);
d3523 1
a3523 1
      alignment = SUB_SEGMENT_ALIGN (now_seg, frchain_ptr);
d3525 6
a3530 5
#ifdef md_do_align
      md_do_align (alignment, (char *) NULL, 0, 0, alignment_done);
#endif
      if (subseg_text_p (now_seg))
	frag_align_code (alignment, 0);
d3532 6
a3537 9
	frag_align (alignment, 0, 0);

#ifdef md_do_align
    alignment_done:
#endif

      frag_wane (frag_now);
      frag_now->fr_fix = 0;
      know (frag_now->fr_next == NULL);
d3539 1
d3541 6
a3546 1
  remove_subsegs ();
d3548 1
a3548 11
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    relax_segment (segment_info[i].frchainP->frch_root, i);

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;

  H_SET_NUMBER_OF_SECTIONS (&headers, 0);

  /* Find out how big the sections are, and set the addresses.  */
  addr = 0;
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
d3550 1
a3550 6
      long size;

      segment_info[i].scnhdr.s_paddr = addr;
      segment_info[i].scnhdr.s_vaddr = addr;

      if (segment_info[i].scnhdr.s_name[0])
d3552 18
a3569 15
	  H_SET_NUMBER_OF_SECTIONS (&headers,
				    H_GET_NUMBER_OF_SECTIONS (&headers) + 1);

#ifdef COFF_LONG_SECTION_NAMES
	  /* Support long section names as found in PE.  This code
	     must coordinate with that in coff_header_append and
	     w_strings.  */
	  {
	    unsigned int len;

	    len = strlen (segment_info[i].name);
	    if (len > SCNNMLEN)
	      string_byte_count += len + 1;
	  }
#endif /* COFF_LONG_SECTION_NAMES */
d3571 3
d3575 2
a3576 9
      size = size_section (abfd, (unsigned int) i);
      addr += size;

      /* I think the section alignment is only used on the i960; the
	 i960 needs it, and it should do no harm on other targets.  */
#ifdef ALIGNMENT_IN_S_FLAGS
      segment_info[i].scnhdr.s_flags |= (section_alignment[i] & 0xF) << 8;
#else
      segment_info[i].scnhdr.s_align = 1 << section_alignment[i];
d3579 13
a3591 7
      if (i == SEG_E0)
	H_SET_TEXT_SIZE (&headers, size);
      else if (i == SEG_E1)
	H_SET_DATA_SIZE (&headers, size);
      else if (i == SEG_E2)
	H_SET_BSS_SIZE (&headers, size);
    }
d3593 11
a3603 2
  /* Turn the gas native symbol table shape into a coff symbol table.  */
  crawl_symbols (&headers, abfd);
d3605 3
a3607 2
  if (string_byte_count == 4)
    string_byte_count = 0;
d3609 7
a3615 1
  H_SET_STRING_SIZE (&headers, string_byte_count);
d3617 14
a3630 2
#ifdef tc_frob_file
  tc_frob_file ();
d3633 4
a3636 5
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      fixup_mdeps (segment_info[i].frchainP->frch_root, &headers, i);
      fixup_segment (&segment_info[i], i);
    }
d3638 13
a3650 5
  /* Look for ".stab" segments and fill in their initial symbols
     correctly.  */
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      name = segment_info[i].name;
d3652 12
a3663 5
      if (name != NULL
	  && strncmp (".stab", name, 5) == 0
	  && strncmp (".stabstr", name, 8) != 0)
	adjust_stab_section (abfd, i);
    }
d3665 2
a3666 1
  file_cursor = H_GET_TEXT_FILE_OFFSET (&headers);
d3668 7
a3674 1
  bfd_seek (abfd, (file_ptr) file_cursor, 0);
d3676 2
a3677 2
  /* Plant the data.  */
  fill_section (abfd, &headers, &file_cursor);
d3679 10
a3688 1
  do_relocs_for (abfd, &headers, &file_cursor);
d3690 16
a3705 1
  do_linenos_for (abfd, &headers, &file_cursor);
d3707 28
a3734 5
  H_SET_FILE_MAGIC_NUMBER (&headers, COFF_MAGIC);
#ifndef OBJ_COFF_OMIT_TIMESTAMP
  H_SET_TIME_STAMP (&headers, (long)time((time_t *)0));
#else
  H_SET_TIME_STAMP (&headers, 0);
d3736 21
a3756 2
#ifdef TC_COFF_SET_MACHINE
  TC_COFF_SET_MACHINE (&headers);
d3758 10
d3769 13
a3781 2
#ifndef COFF_FLAGS
#define COFF_FLAGS 0
d3784 49
a3832 3
#ifdef KEEP_RELOC_INFO
  H_SET_FLAGS (&headers, ((H_GET_LINENO_SIZE(&headers) ? 0 : F_LNNO) |
			  COFF_FLAGS | coff_flags));
d3834 2
a3835 3
  H_SET_FLAGS (&headers, ((H_GET_LINENO_SIZE(&headers)     ? 0 : F_LNNO)   |
			  (H_GET_RELOCATION_SIZE(&headers) ? 0 : F_RELFLG) |
			  COFF_FLAGS | coff_flags));
d3837 1
d3839 28
a3866 3
  {
    unsigned int symtable_size = H_GET_SYMBOL_TABLE_SIZE (&headers);
    char *buffer1 = xmalloc (symtable_size + string_byte_count + 1);
d3868 3
a3870 8
    H_SET_SYMBOL_TABLE_POINTER (&headers, bfd_tell (abfd));
    w_symbols (abfd, buffer1, symbol_rootP);
    if (string_byte_count > 0)
      w_strings (buffer1 + symtable_size);
    bfd_bwrite (buffer1, (bfd_size_type) symtable_size + string_byte_count,
		abfd);
    free (buffer1);
  }
d3872 12
a3883 6
  coff_header_append (abfd, &headers);
  {
    extern bfd *stdoutput;
    stdoutput = abfd;
  }
}
d3885 7
a3891 2
/* Add a new segment.  This is called from subseg_new via the
   obj_new_segment macro.  */
d3893 4
a3896 5
segT
obj_coff_add_segment (name)
     const char *name;
{
  unsigned int i;
d3898 1
a3898 6
#ifndef COFF_LONG_SECTION_NAMES
  char buf[SCNNMLEN + 1];

  strncpy (buf, name, SCNNMLEN);
  buf[SCNNMLEN] = '\0';
  name = buf;
d3900 1
d3902 1
a3902 3
  for (i = SEG_E0; i < SEG_LAST && segment_info[i].scnhdr.s_name[0]; i++)
    if (strcmp (name, segment_info[i].name) == 0)
      return (segT) i;
d3904 36
a3939 4
  if (i == SEG_LAST)
    {
      as_bad (_("Too many new sections; can't add \"%s\""), name);
      return now_seg;
a3940 8

  /* Add a new section.  */
  strncpy (segment_info[i].scnhdr.s_name, name,
	   sizeof (segment_info[i].scnhdr.s_name));
  segment_info[i].scnhdr.s_flags = STYP_REG;
  segment_info[i].name = xstrdup (name);

  return (segT) i;
d3943 1
a3943 14
/* Implement the .section pseudo op:
  	.section name {, "flags"}
                  ^         ^
                  |         +--- optional flags: 'b' for bss
                  |                              'i' for info
                  +-- section name               'l' for lib
                                                 'n' for noload
                                                 'o' for over
                                                 'w' for data
  						 'd' (apparently m88k for data)
                                                 'x' for text
  						 'r' for read-only data
   But if the argument is not a quoted string, treat it as a
   subsegment number.  */
d3945 2
a3946 3
void
obj_coff_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3948 6
a3953 5
  /* Strip out the section name.  */
  char *section_name, *name;
  char c;
  unsigned int exp;
  long flags;
d3955 1
a3955 3
  if (flag_mri)
    {
      char type;
d3957 4
a3960 7
      s_mri_sect (&type);
      flags = 0;
      if (type == 'C')
	flags = STYP_TEXT;
      else if (type == 'D')
	flags = STYP_DATA;
      segment_info[now_seg].scnhdr.s_flags |= flags;
d3962 8
a3969 1
      return;
d3972 5
a3976 2
  section_name = input_line_pointer;
  c = get_symbol_end ();
d3978 7
a3984 2
  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);
d3986 5
a3990 1
  *input_line_pointer = c;
d3992 11
a4002 2
  exp = 0;
  flags = 0;
d4004 1
a4004 2
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
d4006 2
a4007 32
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (*input_line_pointer != '"')
	exp = get_absolute_expression ();
      else
	{
	  ++input_line_pointer;
	  while (*input_line_pointer != '"'
		 && ! is_end_of_line[(unsigned char) *input_line_pointer])
	    {
	      switch (*input_line_pointer)
		{
		case 'b': flags |= STYP_BSS;    break;
		case 'i': flags |= STYP_INFO;   break;
		case 'l': flags |= STYP_LIB;    break;
		case 'n': flags |= STYP_NOLOAD; break;
		case 'o': flags |= STYP_OVER;   break;
		case 'd':
		case 'w': flags |= STYP_DATA;   break;
		case 'x': flags |= STYP_TEXT;   break;
		case 'r': flags |= STYP_LIT;	break;
		default:
		  as_warn(_("unknown section attribute '%c'"),
			  *input_line_pointer);
		  break;
		}
	      ++input_line_pointer;
	    }
	  if (*input_line_pointer == '"')
	    ++input_line_pointer;
	}
d4009 2
d4012 1
a4012 1
  subseg_new (name, (subsegT) exp);
d4014 9
a4022 1
  segment_info[now_seg].scnhdr.s_flags |= flags;
d4024 1
a4024 2
  demand_empty_rest_of_line ();
}
d4026 1
a4026 6
static void
obj_coff_text (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  subseg_new (".text", get_absolute_expression ());
}
d4028 7
a4034 9
static void
obj_coff_data (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (flag_readonly_data_in_text)
    subseg_new (".text", get_absolute_expression () + 1000);
  else
    subseg_new (".data", get_absolute_expression ());
}
d4036 3
a4038 6
static void
obj_coff_ident (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  segT current_seg = now_seg;		/* Save current seg.  */
  subsegT current_subseg = now_subseg;
d4040 4
a4043 4
  subseg_new (".comment", 0);		/* .comment seg.  */
  stringer (1);				/* Read string.  */
  subseg_set (current_seg, current_subseg);	/* Restore current seg.  */
}
d4045 1
a4045 7
void
c_symbol_merge (debug, normal)
     symbolS *debug;
     symbolS *normal;
{
  S_SET_DATA_TYPE (normal, S_GET_DATA_TYPE (debug));
  S_SET_STORAGE_CLASS (normal, S_GET_STORAGE_CLASS (debug));
d4047 2
a4048 2
  if (S_GET_NUMBER_AUXILIARY (debug) > S_GET_NUMBER_AUXILIARY (normal))
    S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));
d4050 2
a4051 4
  if (S_GET_NUMBER_AUXILIARY (debug) > 0)
    memcpy ((char *) &normal->sy_symbol.ost_auxent[0],
	    (char *) &debug->sy_symbol.ost_auxent[0],
	    (unsigned int) (S_GET_NUMBER_AUXILIARY (debug) * AUXESZ));
d4053 1
a4053 3
  /* Move the debug flags.  */
  SF_SET_DEBUG_FIELD (normal, SF_GET_DEBUG_FIELD (debug));
}
d4055 5
a4059 9
static int
c_line_new (symbol, paddr, line_number, frag)
     symbolS * symbol;
     long paddr;
     int line_number;
     fragS * frag;
{
  struct lineno_list *new_line =
  (struct lineno_list *) xmalloc (sizeof (struct lineno_list));
d4061 2
a4062 2
  segment_info_type *s = segment_info + now_seg;
  new_line->line.l_lnno = line_number;
d4064 4
a4067 9
  if (line_number == 0)
    {
      last_line_symbol = symbol;
      new_line->line.l_addr.l_symndx = (long) symbol;
    }
  else
    {
      new_line->line.l_addr.l_paddr = paddr;
    }
d4069 6
a4074 2
  new_line->frag = (char *) frag;
  new_line->next = (struct lineno_list *) NULL;
d4076 6
a4081 4
  if (s->lineno_list_head == (struct lineno_list *) NULL)
    s->lineno_list_head = new_line;
  else
    s->lineno_list_tail->next = new_line;
d4083 2
a4084 3
  s->lineno_list_tail = new_line;
  return LINESZ * s->scnhdr.s_nlnno++;
}
d4086 7
a4092 4
void
c_dot_file_symbol (const char *filename, int appfile ATTRIBUTE_UNUSED)
{
  symbolS *symbolP;
d4094 7
a4100 4
  symbolP = symbol_new (".file",
			SEG_DEBUG,
			0,
			&zero_address_frag);
d4102 2
a4103 2
  S_SET_STORAGE_CLASS (symbolP, C_FILE);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);
d4105 2
a4106 8
  if (strlen (filename) > FILNMLEN)
    {
      /* Filename is too long to fit into an auxent,
	 we stick it into the string table instead.  We keep
	 a linked list of the filenames we find so we can emit
	 them later.  */
      struct filename_list *f = ((struct filename_list *)
				 xmalloc (sizeof (struct filename_list)));
d4108 1
a4108 2
      f->filename = filename;
      f->next = 0;
d4110 3
a4112 2
      SA_SET_FILE_FNAME_ZEROS (symbolP, 0);
      SA_SET_FILE_FNAME_OFFSET (symbolP, 1);
d4114 1
a4114 7
      if (filename_list_tail)
	filename_list_tail->next = f;
      else
	filename_list_head = f;
      filename_list_tail = f;
    }
  else
d4116 2
a4117 1
      SA_SET_FILE_FNAME (symbolP, filename);
a4118 9
#ifndef NO_LISTING
  {
    extern int listing;
    if (listing)
      listing_source_file (filename);
  }
#endif
  SF_SET_DEBUG (symbolP);
  S_SET_VALUE (symbolP, (valueT) previous_file_symbol);
d4120 5
a4124 1
  previous_file_symbol = symbolP;
d4126 4
a4129 5
  /* Make sure that the symbol is first on the symbol chain.  */
  if (symbol_rootP != symbolP)
    {
      symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
      symbol_insert (symbolP, symbol_rootP, &symbol_rootP, &symbol_lastP);
a4130 1
}
d4132 1
a4132 1
/* Build a 'section static' symbol.  */
d4134 1
a4134 6
symbolS *
c_section_symbol (name, idx)
     char *name;
     int idx;
{
  symbolS *symbolP;
d4136 2
a4137 9
  symbolP = symbol_find_base (name, DO_NOT_STRIP);
  if (symbolP == NULL)
    symbolP = symbol_new (name, idx, 0, &zero_address_frag);
  else
    {
      /* Mmmm.  I just love violating interfaces.  Makes me feel...dirty.  */
      S_SET_SEGMENT (symbolP, idx);
      symbolP->sy_frag = &zero_address_frag;
    }
d4139 1
a4139 2
  S_SET_STORAGE_CLASS (symbolP, C_STAT);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);
d4141 1
a4141 1
  SF_SET_STATICS (symbolP);
d4143 8
a4150 4
#ifdef TE_DELTA
  /* manfred@@s-direktnet.de: section symbols *must* have the LOCAL bit cleared,
     which is set by the new definition of LOCAL_LABEL in tc-m68k.h.  */
  SF_CLEAR_LOCAL (symbolP);
a4151 7
#ifdef TE_PE
  /* If the .linkonce pseudo-op was used for this section, we must
     store the information in the auxiliary entry for the section
     symbol.  */
  if (segment_info[idx].linkonce != LINKONCE_UNSET)
    {
      int type;
d4153 3
a4155 17
      switch (segment_info[idx].linkonce)
	{
	default:
	  abort ();
	case LINKONCE_DISCARD:
	  type = IMAGE_COMDAT_SELECT_ANY;
	  break;
	case LINKONCE_ONE_ONLY:
	  type = IMAGE_COMDAT_SELECT_NODUPLICATES;
	  break;
	case LINKONCE_SAME_SIZE:
	  type = IMAGE_COMDAT_SELECT_SAME_SIZE;
	  break;
	case LINKONCE_SAME_CONTENTS:
	  type = IMAGE_COMDAT_SELECT_EXACT_MATCH;
	  break;
	}
d4157 8
a4164 3
      SYM_AUXENT (symbolP)->x_scn.x_comdat = type;
    }
#endif /* TE_PE */
d4166 3
a4168 2
  return symbolP;
}
d4170 8
a4177 8
static void
w_symbols (abfd, where, symbol_rootP)
     bfd * abfd;
     char *where;
     symbolS * symbol_rootP;
{
  symbolS *symbolP;
  unsigned int i;
d4179 1
a4179 11
  /* First fill in those values we have only just worked out.  */
  for (i = SEG_E0; i < SEG_LAST; i++)
    {
      symbolP = segment_info[i].dot;
      if (symbolP)
	{
	  SA_SET_SCN_SCNLEN (symbolP, segment_info[i].scnhdr.s_size);
	  SA_SET_SCN_NRELOC (symbolP, segment_info[i].scnhdr.s_nreloc);
	  SA_SET_SCN_NLINNO (symbolP, segment_info[i].scnhdr.s_nlnno);
	}
    }
d4181 5
a4185 6
  /* Emit all symbols left in the symbol chain.  */
  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      /* Used to save the offset of the name. It is used to point
	 to the string in memory but must be a file offset.  */
      char *temp;
d4187 2
a4188 6
      /* We can't fix the lnnoptr field in yank_symbols with the other
         adjustments, because we have to wait until we know where they
         go in the file.  */
      if (SF_GET_ADJ_LNNOPTR (symbolP))
	SA_GET_SYM_LNNOPTR (symbolP) +=
	  segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_lnnoptr;
d4190 4
a4193 1
      tc_coff_symbol_emit_hook (symbolP);
d4195 2
a4196 15
      temp = S_GET_NAME (symbolP);
      if (SF_GET_STRING (symbolP))
	{
	  S_SET_OFFSET (symbolP, symbolP->sy_name_offset);
	  S_SET_ZEROES (symbolP, 0);
	}
      else
	{
	  memset (symbolP->sy_symbol.ost_entry.n_name, 0, SYMNMLEN);
	  strncpy (symbolP->sy_symbol.ost_entry.n_name, temp, SYMNMLEN);
	}
      where = symbol_to_chars (abfd, where, symbolP);
      S_SET_NAME (symbolP, temp);
    }
}
d4198 4
a4201 7
static void
obj_coff_lcomm (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  s_lcomm (0);
  return;
}
d4203 3
a4205 7
static void
fixup_mdeps (frags, h, this_segment)
     fragS *frags;
     object_headers *h ATTRIBUTE_UNUSED;
     segT this_segment;
{
  subseg_change (this_segment, 0);
d4207 1
a4207 1
  while (frags)
d4209 2
a4210 22
      switch (frags->fr_type)
	{
	case rs_align:
	case rs_align_code:
	case rs_align_test:
	case rs_org:
#ifdef HANDLE_ALIGN
	  HANDLE_ALIGN (frags);
#endif
	  frags->fr_type = rs_fill;
	  frags->fr_offset =
	    ((frags->fr_next->fr_address - frags->fr_address - frags->fr_fix)
	     / frags->fr_var);
	  break;
	case rs_machine_dependent:
	  md_convert_frag (h, this_segment, frags);
	  frag_wane (frags);
	  break;
	default:
	  ;
	}
      frags = frags->fr_next;
a4211 1
}
d4213 5
a4217 1
#if 1
d4219 2
a4220 3
#ifndef TC_FORCE_RELOCATION
#define TC_FORCE_RELOCATION(fix) 0
#endif
d4222 14
a4235 27
static void
fixup_segment (segP, this_segment_type)
     segment_info_type * segP;
     segT this_segment_type;
{
  fixS * fixP;
  symbolS *add_symbolP;
  symbolS *sub_symbolP;
  long add_number;
  int size;
  char *place;
  long where;
  char pcrel;
  fragS *fragP;
  segT add_symbol_segment = absolute_section;

  for (fixP = segP->fix_root; fixP; fixP = fixP->fx_next)
    {
      fragP = fixP->fx_frag;
      know (fragP);
      where = fixP->fx_where;
      place = fragP->fr_literal + where;
      size = fixP->fx_size;
      add_symbolP = fixP->fx_addsy;
      sub_symbolP = fixP->fx_subsy;
      add_number = fixP->fx_offset;
      pcrel = fixP->fx_pcrel;
d4237 8
a4244 3
      /* We want function-relative stabs to work on systems which
	 may use a relaxing linker; thus we must handle the sym1-sym2
	 fixups function-relative stabs generates.
d4246 3
a4248 7
	 Of course, if you actually enable relaxing in the linker, the
	 line and block scoping information is going to be incorrect
	 in some cases.  The only way to really fix this is to support
	 a reloc involving the difference of two symbols.  */
      if (linkrelax
	  && (!sub_symbolP || pcrel))
	continue;
d4250 7
a4256 5
#ifdef TC_I960
      if (fixP->fx_tcbit && SF_GET_CALLNAME (add_symbolP))
	{
	  /* Relocation should be done via the associated 'bal' entry
	     point symbol.  */
d4258 2
a4259 10
	  if (!SF_GET_BALNAME (tc_get_bal_of_call (add_symbolP)))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("No 'bal' entry point for leafproc %s"),
			    S_GET_NAME (add_symbolP));
	      continue;
	    }
	  fixP->fx_addsy = add_symbolP = tc_get_bal_of_call (add_symbolP);
	}
#endif
d4261 2
a4262 4
      /* Make sure the symbols have been resolved; this may not have
         happened if these are expression symbols.  */
      if (add_symbolP != NULL && ! add_symbolP->sy_resolved)
	resolve_symbol_value (add_symbolP);
d4264 2
a4265 13
      if (add_symbolP != NULL)
	{
	  /* If this fixup is against a symbol which has been equated
	     to another symbol, convert it to the other symbol.  */
	  if (add_symbolP->sy_value.X_op == O_symbol
	      && (! S_IS_DEFINED (add_symbolP)
		  || S_IS_COMMON (add_symbolP)))
	    {
	      while (add_symbolP->sy_value.X_op == O_symbol
		     && (! S_IS_DEFINED (add_symbolP)
			 || S_IS_COMMON (add_symbolP)))
		{
		  symbolS *n;
d4267 1
a4267 12
		  /* We must avoid looping, as that can occur with a
		     badly written program.  */
		  n = add_symbolP->sy_value.X_add_symbol;
		  if (n == add_symbolP)
		    break;
		  add_number += add_symbolP->sy_value.X_add_number;
		  add_symbolP = n;
		}
	      fixP->fx_addsy = add_symbolP;
	      fixP->fx_offset = add_number;
	    }
	}
d4269 2
a4270 2
      if (sub_symbolP != NULL && ! sub_symbolP->sy_resolved)
	resolve_symbol_value (sub_symbolP);
d4272 5
a4276 7
      if (add_symbolP != NULL
	  && add_symbolP->sy_mri_common)
	{
	  add_number += S_GET_VALUE (add_symbolP);
	  fixP->fx_offset = add_number;
	  add_symbolP = fixP->fx_addsy = add_symbolP->sy_value.X_add_symbol;
	}
d4278 3
a4280 4
      if (add_symbolP)
	add_symbol_segment = S_GET_SEGMENT (add_symbolP);

      if (sub_symbolP)
d4282 3
a4284 1
	  if (add_symbolP == NULL || add_symbol_segment == absolute_section)
d4286 1
a4286 1
	      if (add_symbolP != NULL)
d4288 13
a4300 3
		  add_number += S_GET_VALUE (add_symbolP);
		  add_symbolP = NULL;
		  fixP->fx_addsy = NULL;
d4302 1
a4302 20

	      /* It's just -sym.  */
	      if (S_GET_SEGMENT (sub_symbolP) == absolute_section)
		{
		  add_number -= S_GET_VALUE (sub_symbolP);
		  fixP->fx_subsy = 0;
		  fixP->fx_done = 1;
		}
	      else
		{
#ifndef TC_M68K
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("Negative of non-absolute symbol %s"),
				S_GET_NAME (sub_symbolP));
#endif
		  add_number -= S_GET_VALUE (sub_symbolP);
		}		/* not absolute */

	      /* if sub_symbol is in the same segment that add_symbol
		 and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE.  */
d4304 4
a4307 16
	  else if (S_GET_SEGMENT (sub_symbolP) == add_symbol_segment
		   && SEG_NORMAL (add_symbol_segment))
	    {
	      /* Difference of 2 symbols from same segment.  Can't
		 make difference of 2 undefineds: 'value' means
		 something different for N_UNDF.  */
#ifdef TC_I960
	      /* Makes no sense to use the difference of 2 arbitrary symbols
	         as the target of a call instruction.  */
	      if (fixP->fx_tcbit)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("callj to difference of 2 symbols"));
#endif /* TC_I960 */
	      add_number += S_GET_VALUE (add_symbolP) -
		S_GET_VALUE (sub_symbolP);
	      add_symbolP = NULL;
d4309 1
a4309 15
	      if (!TC_FORCE_RELOCATION (fixP))
		{
		  fixP->fx_addsy = NULL;
		  fixP->fx_subsy = NULL;
		  fixP->fx_done = 1;
#ifdef TC_M68K /* is this right? */
		  pcrel = 0;
		  fixP->fx_pcrel = 0;
#endif
		}
	    }
	  else
	    {
	      /* Different segments in subtraction.  */
	      know (!(S_IS_EXTERNAL (sub_symbolP) && (S_GET_SEGMENT (sub_symbolP) == absolute_section)));
d4311 1
a4311 2
	      if ((S_GET_SEGMENT (sub_symbolP) == absolute_section))
		add_number -= S_GET_VALUE (sub_symbolP);
d4313 2
a4314 22
#ifdef DIFF_EXPR_OK
	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type)
		{
		  /* Make it pc-relative.  */
		  add_number += (md_pcrel_from (fixP)
				 - S_GET_VALUE (sub_symbolP));
		  pcrel = 1;
		  fixP->fx_pcrel = 1;
		  sub_symbolP = 0;
		  fixP->fx_subsy = 0;
		}
#endif
	      else
		{
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("Can't emit reloc {- %s-seg symbol \"%s\"} @@ file address %ld."),
				segment_name (S_GET_SEGMENT (sub_symbolP)),
				S_GET_NAME (sub_symbolP),
				(long) (fragP->fr_address + where));
		}
	    }
	}
d4316 5
a4320 14
      if (add_symbolP)
	{
	  if (add_symbol_segment == this_segment_type && pcrel)
	    {
	      /* This fixup was made when the symbol's segment was
	         SEG_UNKNOWN, but it is now in the local segment.
	         So we know how to do the address without relocation.  */
#ifdef TC_I960
	      /* reloc_callj() may replace a 'call' with a 'calls' or a 'bal',
	         in which cases it modifies *fixP as appropriate.  In the case
	         of a 'calls', no further work is required, and *fixP has been
	         set up to make the rest of the code below a no-op.  */
	      reloc_callj (fixP);
#endif /* TC_I960 */
d4322 8
a4329 2
	      add_number += S_GET_VALUE (add_symbolP);
	      add_number -= md_pcrel_from (fixP);
d4331 5
a4335 13
	      /* We used to do
		   add_number -= segP->scnhdr.s_vaddr;
		 if defined (TC_I386) || defined (TE_LYNX).  I now
		 think that was an error propagated from the case when
		 we are going to emit the relocation.  If we are not
		 going to emit the relocation, then we just want to
		 set add_number to the difference between the symbols.
		 This is a case that would only arise when there is a
		 PC relative reference from a section other than .text
		 to a symbol defined in the same section, and the
		 reference is not relaxed.  Since jump instructions on
		 the i386 are relaxed, this could only arise with a
		 call instruction.  */
d4337 4
a4340 18
	      pcrel = 0;	/* Lie. Don't want further pcrel processing.  */
	      if (!TC_FORCE_RELOCATION (fixP))
		{
		  fixP->fx_addsy = NULL;
		  fixP->fx_done = 1;
		}
	    }
	  else
	    {
	      switch (add_symbol_segment)
		{
		case absolute_section:
#ifdef TC_I960
		  /* See comment about reloc_callj() above.  */
		  reloc_callj (fixP);
#endif /* TC_I960 */
		  add_number += S_GET_VALUE (add_symbolP);
		  add_symbolP = NULL;
d4342 4
a4345 7
		  if (!TC_FORCE_RELOCATION (fixP))
		    {
		      fixP->fx_addsy = NULL;
		      fixP->fx_done = 1;
		    }
		  break;
		default:
d4347 1
a4347 9
#if defined(TC_A29K) || (defined(TE_PE) && defined(TC_I386)) || defined(TC_M88K) || defined(TC_OR32)
		  /* This really should be handled in the linker, but
		     backward compatibility forbids.  */
		  add_number += S_GET_VALUE (add_symbolP);
#else
		  add_number += S_GET_VALUE (add_symbolP) +
		    segment_info[S_GET_SEGMENT (add_symbolP)].scnhdr.s_paddr;
#endif
		  break;
d4349 2
a4350 28
		case SEG_UNKNOWN:
#ifdef TC_I960
		  if ((int) fixP->fx_bit_fixP == 13)
		    {
		      /* This is a COBR instruction.  They have only a
		         13-bit displacement and are only to be used
		         for local branches: flag as error, don't generate
		         relocation.  */
		      as_bad_where (fixP->fx_file, fixP->fx_line,
				    _("can't use COBR format with external label"));
		      fixP->fx_addsy = NULL;
		      fixP->fx_done = 1;
		      continue;
		    }
#endif /* TC_I960 */
#if ((defined (TC_I386) || defined (TE_LYNX) || defined (TE_AUX)) && !defined(TE_PE)) || defined (COFF_COMMON_ADDEND)
		  /* 386 COFF uses a peculiar format in which the
		     value of a common symbol is stored in the .text
		     segment (I've checked this on SVR3.2 and SCO
		     3.2.2) Ian Taylor <ian@@cygnus.com>.  */
		  /* This is also true for 68k COFF on sysv machines
		     (Checked on Motorola sysv68 R3V6 and R3V7.1, and also on
		     UNIX System V/M68000, Release 1.0 from ATT/Bell Labs)
		     Philippe De Muyter <phdm@@info.ucl.ac.be>.  */
		  if (S_IS_COMMON (add_symbolP))
		    add_number += S_GET_VALUE (add_symbolP);
#endif
		  break;
d4352 7
a4358 3
		}
	    }
	}
d4360 2
a4361 12
      if (pcrel)
	{
#if !defined(TC_M88K) && !(defined(TE_PE) && defined(TC_I386)) && !defined(TC_A29K) && !defined(TC_OR32)
	  /* This adjustment is not correct on the m88k, for which the
	     linker does all the computation.  */
	  add_number -= md_pcrel_from (fixP);
#endif
	  if (add_symbolP == 0)
	    fixP->fx_addsy = &abs_symbol;
#if defined (TC_I386) || defined (TE_LYNX) || defined (TC_I960) || defined (TC_M68K)
	  /* On the 386 we must adjust by the segment vaddr as well.
	     Ian Taylor.
d4363 2
a4364 7
	     I changed the i960 to work this way as well.  This is
	     compatible with the current GNU linker behaviour.  I do
	     not know what other i960 COFF assemblers do.  This is not
	     a common case: normally, only assembler code will contain
	     a PC relative reloc, and only branches which do not
	     originate in the .text section will have a non-zero
	     address.
d4366 8
a4373 4
	     I changed the m68k to work this way as well.  This will
	     break existing PC relative relocs from sections which do
	     not start at address 0, but it will make ld -r work.
	     Ian Taylor, 4 Oct 96.  */
d4375 6
a4380 1
	  add_number -= segP->scnhdr.s_vaddr;
a4381 1
	}
d4383 4
a4386 1
      md_apply_fix3 (fixP, (valueT *) & add_number, this_segment_type);
d4388 5
a4392 36
      if (!fixP->fx_bit_fixP && ! fixP->fx_no_overflow)
	{
#ifndef TC_M88K
	  /* The m88k uses the offset field of the reloc to get around
	     this problem.  */
	  if ((size == 1
	       && ((add_number & ~0xFF)
		   || (fixP->fx_signed && (add_number & 0x80)))
	       && ((add_number & ~0xFF) != (-1 & ~0xFF)
		   || (add_number & 0x80) == 0))
	      || (size == 2
		  && ((add_number & ~0xFFFF)
		      || (fixP->fx_signed && (add_number & 0x8000)))
		  && ((add_number & ~0xFFFF) != (-1 & ~0xFFFF)
		      || (add_number & 0x8000) == 0)))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("Value of %ld too large for field of %d bytes at 0x%lx"),
			    (long) add_number, size,
			    (unsigned long) (fragP->fr_address + where));
	    }
#endif
#ifdef WARN_SIGNED_OVERFLOW_WORD
	  /* Warn if a .word value is too large when treated as a
	     signed number.  We already know it is not too negative.
	     This is to catch over-large switches generated by gcc on
	     the 68k.  */
	  if (!flag_signed_overflow_ok
	      && size == 2
	      && add_number > 0x7fff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("Signed .word overflow; switch may be too large; %ld at 0x%lx"),
			  (long) add_number,
			  (unsigned long) (fragP->fr_address + where));
#endif
	}
d4396 6
a4401 1
#endif
d4406 1
a4406 2
obj_coff_init_stab_section (seg)
     segT seg;
d4418 1
a4418 1
  stabstr_name = (char *) alloca (strlen (segment_info[seg].name) + 4);
a4425 51
/* Fill in the counts in the first entry in a .stab section.  */

static void
adjust_stab_section(abfd, seg)
     bfd *abfd;
     segT seg;
{
  segT stabstrseg = SEG_UNKNOWN;
  const char *secname, *name2;
  char *name;
  char *p = NULL;
  int i, strsz = 0, nsyms;
  fragS *frag = segment_info[seg].frchainP->frch_root;

  /* Look for the associated string table section.  */

  secname = segment_info[seg].name;
  name = (char *) alloca (strlen (secname) + 4);
  strcpy (name, secname);
  strcat (name, "str");

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      name2 = segment_info[i].name;
      if (name2 != NULL && strncmp(name2, name, 8) == 0)
	{
	  stabstrseg = i;
	  break;
	}
    }

  /* If we found the section, get its size.  */
  if (stabstrseg != SEG_UNKNOWN)
    strsz = size_section (abfd, stabstrseg);

  nsyms = size_section (abfd, seg) / 12 - 1;

  /* Look for the first frag of sufficient size for the initial stab
     symbol, and collect a pointer to it.  */
  while (frag && frag->fr_fix < 12)
    frag = frag->fr_next;
  assert (frag != 0);
  p = frag->fr_literal;
  assert (p != 0);

  /* Write in the number of stab symbols and the size of the string
     table.  */
  bfd_h_put_16 (abfd, (bfd_vma) nsyms, (bfd_byte *) p + 6);
  bfd_h_put_32 (abfd, (bfd_vma) strsz, (bfd_byte *) p + 8);
}

d4430 5
d4438 1
a4440 4
#ifdef BFD_ASSEMBLER
  {"loc", obj_coff_loc, 0},
#endif
  {"appline", obj_coff_ln, 1},
d4442 5
d4451 6
a4456 12
  {"section", obj_coff_section, 0},
  {"sect", obj_coff_section, 0},
  /* FIXME: We ignore the MRI short attribute.  */
  {"section.s", obj_coff_section, 0},
  {"sect.s", obj_coff_section, 0},
  /* We accept the .bss directive for backward compatibility with
     earlier versions of gas.  */
  {"bss", obj_coff_bss, 0},
  {"ident", obj_coff_ident, 0},
#ifndef BFD_ASSEMBLER
  {"use", obj_coff_section, 0},
  {"text", obj_coff_text, 0},
d4459 2
a4460 3
#else
  {"weak", obj_coff_weak, 0},
  {"optim", s_ignore, 0},	/* For sun386i cc (?) */
d4462 1
a4462 3
  {"version", s_ignore, 0},
  {"ABORT", s_abort, 0},
#if defined( TC_M88K ) || defined ( TC_TIC4X )
d4466 2
a4467 2
  {NULL, NULL, 0}		/* end sentinel */
};				/* coff_pseudo_table */
a4472 3
static void coff_pop_insert PARAMS ((void));
static int coff_separate_stab_sections PARAMS ((void));

d4474 1
a4474 1
coff_pop_insert ()
d4480 1
a4480 1
coff_separate_stab_sections ()
@


1.78
log
@bfd/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* coffcode.h (sec_to_styp_flags): Replaced SEC_CLINK with
	SEC_TIC54X_CLINK. Replace SEC_BLOCK with SEC_TIC54X_BLOCK.
	Replace SEC_SHARED with SEC_COFF_SHARED.
	(styp_to_sec_flags): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Remove SEC_ARCH_BIT_0.
	(TARGET_LITTLE_SYM): Likewise.

	* section.c (SEC_ARCH_BIT_0): Removed.
	(SEC_LINK_DUPLICATES_SAME_CONTENTS): Defined with
	SEC_LINK_DUPLICATES_ONE_ONLY and SEC_LINK_DUPLICATES_SAME_SIZE.
	(SEC_SHARED): Renamed to ...
	(SEC_COFF_SHARED): This.
	(SEC_BLOCK): Renamed to ...
	(SEC_TIC54X_BLOCK): This.
	(SEC_CLINK): Renamed to ...
	(SEC_TIC54X_CLINK): This.
	(SEC_XXX): Rearranged. Move SEC_COFF_SHARED_LIBRARY,
	SEC_COFF_SHARED, SEC_TIC54X_BLOCK and SEC_TIC54X_CLINK to the
	end.
	* bfd-in2.h: Regenerated.

binutils/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (parse_flags): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* objdump.c (dump_section_header): Dump SEC_TIC54X_BLOCK and
	SEC_TIC54X_CLINK for TI c54x only. Remove SEC_ARCH_BIT_0. Dump
	SEC_COFF_SHARED for COFF only.

gas/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-coff.c (obj_coff_section): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* config/tc-tic54x.c (tic54x_bss): Replace SEC_BLOCK with
	SEC_TIC54X_BLOCK.
	(demand_empty_rest_of_line): Likewise.
	(tic54x_sblock): Likewise.
	(tic54x_clink): Replace with SEC_CLINK with SEC_TIC54X_CLINK.

ld/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_add_section): Check SEC_TIC54X_BLOCK for TI
	tic54x input only.
	(lang_size_sections_1): Check SEC_COFF_SHARED_LIBRARY for COFF
	and ECOFF output only.
@
text
@a4292 1
	  know (add_symbolP->sy_value.X_op == O_symbol);
@


1.77
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d1610 1
a1610 1
		case 's': flags |= SEC_SHARED; /* fall through */
d1665 1
a1665 1
			     | SEC_DATA | SEC_SHARED | SEC_NEVER_LOAD);
@


1.76
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004
d1862 1
a1862 1
  char *filename;
@


1.75
log
@	* config/obj-coff.c (c_dot_file_symbol): Add "app" param.
	(coff_adjust_symtab): Adjust call.
	(crawl_symbols): Likewise.
	* config/obj-coff.h (c_dot_file_symbol): Add "app" param.
	(obj_app_file): Adjust.
@
text
@a114 11
#if 0
/* Not currently used.  */
static void
stack_delete (st)
     stack *st;
{
  free (st->data);
  free (st);
}
#endif

a2845 3
#if 0 /* XXX Can we ever have line numbers going backwards?  */
      if (this_base > line_base)
#endif
a3162 7

		  /* Clobber possible stale .dim information.  */
#if 0
		  /* Iffed out by steve - this fries the lnnoptr info too.  */
		  bzero (symbolP->sy_symbol.ost_auxent[0].x_sym.x_fcnary.x_ary.x_dimen,
			 sizeof (symbolP->sy_symbol.ost_auxent[0].x_sym.x_fcnary.x_ary.x_dimen));
#endif
a3754 7
#if 0
  /* Recent changes to write need this, but where it should
     go is up to Ken..  */
  if (!bfd_close_all_done (abfd))
    as_fatal (_("Can't close %s: %s"), out_file_name,
	      bfd_errmsg (bfd_get_error ()));
#else
a3758 2
#endif

d4153 1
a4153 1
  s_lcomm(0);
a4154 60
#if 0
  char *name;
  char c;
  int temp;
  char *p;

  symbolS *symbolP;

  name = input_line_pointer;

  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after name"));
      ignore_rest_of_line ();
      return;
    }
  if (*input_line_pointer == '\n')
    {
      as_bad (_("Missing size expression"));
      return;
    }
  input_line_pointer++;
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_("lcomm length (%d.) <0! Ignored."), temp);
      ignore_rest_of_line ();
      return;
    }
  *p = 0;

  symbolP = symbol_find_or_make (name);

  if (S_GET_SEGMENT (symbolP) == SEG_UNKNOWN &&
      S_GET_VALUE (symbolP) == 0)
    {
      if (! need_pass_2)
	{
	  char *p;
	  segT current_seg = now_seg; 	/* Save current seg.  */
	  subsegT current_subseg = now_subseg;

	  subseg_set (SEG_E2, 1);
	  symbolP->sy_frag = frag_now;
	  p = frag_var(rs_org, 1, 1, (relax_substateT)0, symbolP,
		       (offsetT) temp, (char *) 0);
	  *p = 0;
	  subseg_set (current_seg, current_subseg); /* Restore current seg.  */
	  S_SET_SEGMENT (symbolP, SEG_E2);
	  S_SET_STORAGE_CLASS (symbolP, C_STAT);
	}
    }
  else
    as_bad (_("Symbol %s already defined"), name);

  demand_empty_rest_of_line ();
#endif
d4370 1
a4370 5
	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type
#if 0 /* Okay for 68k, at least...  */
		       && !pcrel
#endif
		       )
@


1.74
log
@Fix support for PECOFF weak symbols
@
text
@d338 1
a338 2
c_dot_file_symbol (filename)
     const char *filename;
d1689 1
a1689 1
    c_dot_file_symbol ("fake");
d3406 1
a3406 1
    c_dot_file_symbol ("fake");
d4007 1
a4007 2
c_dot_file_symbol (filename)
     char *filename;
@


1.73
log
@Add CRX insns: pushx, popx
Add support to GAS for expressions which are the difference of two symbols
@
text
@d29 4
d48 4
d1107 67
d1175 1
d1177 1
a1177 2
obj_coff_weak (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1182 3
d1196 1
d1207 4
a1210 4
       * File Format Specification_, section 5.5.3.
       * Note that weak symbols without aux records are a GNU
       * extension.
       */
d1212 2
d1215 3
a1217 22
      if (c == '=')
	{
	  symbolS *alternateP;
	  long characteristics = 2;
	  ++input_line_pointer;
	  if (*input_line_pointer == '=')
	    {
	      characteristics = 1;
	      ++input_line_pointer;
	    }

	  SKIP_WHITESPACE();
	  name = input_line_pointer;
	  c = get_symbol_end();
	  if (*name == 0)
	    {
	      as_warn (_("alternate name missing in .weak directive"));
	      ignore_rest_of_line ();
	      return;
	    }
	  alternateP = symbol_find_or_make (name);
	  *input_line_pointer = c;
d1219 2
a1220 7
	  S_SET_NUMBER_AUXILIARY (symbolP, 1);
	  SA_SET_SYM_TAGNDX (symbolP, alternateP);
	  SA_SET_SYM_FSIZE (symbolP, characteristics);
	}
#else  /* TE_PE */
      S_SET_STORAGE_CLASS (symbolP, C_WEAKEXT);
#endif  /* TE_PE */
d1274 4
a1277 1
  if (S_IS_WEAK (symp))
d1279 51
a1329 5
#ifdef TE_PE
      S_SET_STORAGE_CLASS (symp, C_NT_WEAK);
#else
      S_SET_STORAGE_CLASS (symp, C_WEAKEXT);
#endif
d1331 4
a1834 4
#ifdef TE_PE
#include "coff/pe.h"
#endif

@


1.72
log
@(coff_pseudo_table): Only define the weak pseudo for BFD based assemblers.
@
text
@d1330 1
a1330 1
	  || (! S_IS_EXTERNAL (symp)
@


1.71
log
@2004-07-04  Aaron W. LaFramboise <aaron98wiridge9@@aaronwl.com>

* bfd/cofflink.c (_bfd_coff_generic_relocate_section): Resolve PE weak
externals properly.
* src/gas/config/obj-coff.c (obj_coff_weak): New .weak syntax for PE weak
externals.
* binutils/doc/binutils.texi (nm): Clarify weak symbol description.
* gas/config/tc-i386.c (tc_gen_reloc): Use addend for weak symbols in TE_PE.
* gas/doc/as.texinfo (Weak): Document PE weak symbols.
* ld/ld.texinfo (WIN32): Document PE weak symbols.
@
text
@d63 1
d65 1
a1880 1

a4657 1
  {"weak", obj_coff_weak, 0},
d4665 1
@


1.70
log
@	* config/obj-coff.c (coff_adjust_section_syms): Use
	bfd_get_section_size instead of bfd_get_section_size_before_reloc.
	(coff_frob_section): Likewise.
	* config/tc-mips.c (md_apply_fix3): Likewise.
	* config/obj-elf.c (elf_frob_file): Use bfd_set_section_size.
	(elf_frob_file_after_relocs): Likewise.
@
text
@a214 41
/* Handle .weak.  This is a GNU extension.  */

static void
obj_coff_weak (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  int c;
  symbolS *symbolP;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();

#if defined BFD_ASSEMBLER || defined S_SET_WEAK
      S_SET_WEAK (symbolP);
#endif

#ifdef TE_PE
      S_SET_STORAGE_CLASS (symbolP, C_NT_WEAK);
#else
      S_SET_STORAGE_CLASS (symbolP, C_WEAKEXT);
#endif

      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

d1097 80
@


1.69
log
@	* config/obj-aout.h: Fix comment typos.
	* config/obj-bout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-elf.c: Likewise.
	* config/obj-ieee.c: Likewise.
	* config/obj-som.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/obj-vms.h: Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002
d1382 1
a1382 1
  if (bfd_get_section_size_before_reloc (sec) == 0
d1557 1
a1557 1
  size = bfd_get_section_size_before_reloc (sec);
d1610 1
a1610 1
  size = bfd_get_section_size_before_reloc (strsec);
d1612 1
a1612 1
  n_entries = bfd_get_section_size_before_reloc (sec) / 12 - 1;
@


1.68
log
@(obj_coff_section [BEF_ASSEMBLER]): Make 'r' mean readonly data.
@
text
@d146 1
a146 1
 * Maintain a list of the tagnames of the structres.
d1475 1
a1475 1
		case 'a': break; /* For compatability with ELF.  */
d2041 1
a2041 1
			 reloc.  Two relocations are emited, R_IHIHALF,
d2055 1
a2055 1
			 reloc.  Two relocations are emited, R_IHIHALF,
d2099 1
a2099 1
   in the scnhdrs with the info on the file postions.  */
d2967 1
a2967 1
		 real symbol. Do NOT do the oposite (i.e. move from
d3431 1
a3431 1
/* The last subsegment gets an aligment corresponding to the alignment
@


1.67
log
@	* write.c (write_object_file): Fix signed/unsigned warning.
	* config/e-crisaout.c (crisaout_bfd_name): Prototype.
	* config/e-criself.c (criself_bfd_name): Prototype.
	* config/obj-aout.c (s_sect): Remove unused function.
	* config/obj-bout.c (obj_bout_line <ignore>): Add ATTRIBUTE_UNUSED.
	* config/obj-coff.c (coff_last_bf): Don't declare for OBJ_XCOFF.
	(fixup_mdeps <h>): Add ATTRIBUTE_UNUSED.
	* config/obj-ecoff.c (ecoff_frob_file <addr>): Likewise.
	* config/obj-vms.c (setup_basic_type <spnt>): Likewise.
	(VMS_RSYM_Parse <Current_Routine>): Likewise.
	(vms_fixup_text_section <text_siz>): Likewise.
	(synthesize_data_segment <data_size>): Likewise.
	(vms_fixup_xtors_section <sect_no>): Likewise.
	(structure_count): Don't use implicit int type.
@
text
@d1477 1
a1477 1
		case 'r': flags |= SEC_READONLY; break;
@


1.66
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1150 1
d1152 1
d4105 2
a4106 2
     fragS * frags;
     object_headers * h;
@


1.65
log
@Set SEC_DATA and SEC_LOAD flags for sections marked as 's'.
@
text
@d3632 1
a3632 1
  if (bfd_close_all_done (abfd) == false)
@


1.64
log
@gas reloc rewrite.
@
text
@d1468 2
d1472 1
a1475 1
		case 's': flags |= SEC_SHARED; break;
@


1.63
log
@Add TMS320C4x support
@
text
@d4662 1
@


1.62
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d4626 2
a4627 2
#ifdef TC_M88K
  /* The m88k uses sdef instead of def.  */
@


1.61
log
@Add missing semicolon
@
text
@d274 1
a274 1
      CONST asymbol *s;
d714 1
a714 1
	CONST char *name;
@


1.60
log
@Silently ignore an 'a' flag in a COFF .section directive.
@
text
@d3473 1
a3473 1
      alignment = SUB_SEGMENT_ALIGN (now_seg, frchain_ptr)
@


1.59
log
@	* write.c (size_seg): Check adjustment to last frag.
	(SUB_SEGMENT_ALIGN): If HANDLE_ALIGN defined, pad out last frag to
	section alignment.
	* config/obj-coff.c (SUB_SEGMENT_ALIGN): Likewise.
	* config/obj-ieee.c (SUB_SEGMENT_ALIGN): Likewise.
	(write_object_file): Invoke md_do_align if available, and use
	frag_align_code on text sections.
	* config/obj-vms.h (SUB_SEGMENT_ALIGN): Now two args.
	* config/tc-m88k.h (SUB_SEGMENT_ALIGN): Likewise.
	* config/tc-ppc.h (SUB_SEGMENT_ALIGN): Likewise.
	* config/tc-sh.h (SUB_SEGMENT_ALIGN): Likewise.
	* config/tc-i386.h (SUB_SEGMENT_ALIGN): Likewise.  Define for
	BFD_ASSEMBLER too.
@
text
@d1400 18
a1417 17
/*
 * implement the .section pseudo op:
 *	.section name {, "flags"}
 *                ^         ^
 *                |         +--- optional flags: 'b' for bss
 *                |                              'i' for info
 *                +-- section name               'l' for lib
 *                                               'n' for noload
 *                                               'o' for over
 *                                               'w' for data
 *						 'd' (apparently m88k for data)
 *                                               'x' for text
 *						 'r' for read-only data
 *						 's' for shared data (PE)
 * But if the argument is not a quoted string, treat it as a
 * subsegment number.
 */
d1470 1
@


1.58
log
@Fix formatting and compile tine warnings when compiling without BFD_ASSEMBLER
defined.
@
text
@d3423 13
d3459 4
d3467 1
a3467 4
      /* Run through all the sub-segments and align them up.  Also
	 close any open frags.  We tack a .fill onto the end of the
	 frag chain so that any .align's size can be worked by looking
	 at the next frag.  */
d3471 2
a3472 3
#ifndef SUB_SEGMENT_ALIGN
#define SUB_SEGMENT_ALIGN(SEG) 1
#endif
d3474 1
a3474 2
      md_do_align (SUB_SEGMENT_ALIGN (now_seg), (char *) NULL, 0, 0,
		   alignment_done);
d3477 1
a3477 1
	frag_align_code (SUB_SEGMENT_ALIGN (now_seg), 0);
d3479 1
a3479 1
	frag_align (SUB_SEGMENT_ALIGN (now_seg), 0, 0);
@


1.57
log
@	* config/obj-coff.c: Fix formatting.
	* config/obj-elf.c: Likewise.
	* config/tc-alpha.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-hppa.c: Likewise.
@
text
@d1716 1
a1716 1
/* structure used to keep the filenames which
d1718 1
a1718 1
   into the string table */
d1732 3
a1734 2
   section number into a segment number
*/
a1735 1
void c_symbol_merge ();
d1738 13
a1750 23
symbolS *c_section_symbol ();
bfd *abfd;

static void fixup_segment PARAMS ((segment_info_type *segP,
				   segT this_segment_type));

static void fixup_mdeps PARAMS ((fragS *,
				 object_headers *,
				 segT));

static void fill_section PARAMS ((bfd * abfd,
				  object_headers *,
				  unsigned long *));

static int c_line_new PARAMS ((symbolS * symbol, long paddr,
			       int line_number,
			       fragS * frag));

static void w_symbols PARAMS ((bfd * abfd, char *where,
			       symbolS * symbol_rootP));

static void adjust_stab_section PARAMS ((bfd *abfd, segT seg));

d1754 10
a1763 1
void obj_coff_section PARAMS ((int));
d1802 2
d1824 5
a1828 2
/* calculate the size of the frag chain and fill in the section header
   to contain all of it, also fill in the addr of the sections */
d1837 1
d1890 1
a1890 1
  /* Count the relocations */
d1916 2
a1917 1
/* AUX's ld expects relocations to be sorted */
d1932 2
a1933 1
/* output all the relocations for a section */
d1971 1
a1971 1
		  /* Only output some of the relocations */
a1976 1

d2021 1
d2024 1
a2024 3
			    {
			      intr.r_symndx = dot->sy_number;
			    }
d2026 1
a2026 4
			    {
			      intr.r_symndx = symbol_ptr->sy_number;
			    }

d2029 1
a2029 3
			{
			  intr.r_symndx = -1;
			}
a2030 1

a2032 1

a2033 1

a2037 1

d2040 1
a2040 1
			  /* now emit the second bit */
a2064 1

d2066 1
a2066 1
	      /* Sort the reloc table */
d2070 1
a2070 2

	      /* Write out the reloc table */
d2082 1
a2082 1
	      /* No relocs */
d2087 2
a2088 1
  /* Set relocation_size field in file headers */
d2092 3
a2094 3
/* run through a frag chain and write out the data to go with it, fill
   in the scnhdrs with the info on the file postions
*/
a2100 1

d2226 1
a2226 1
/* Coff file generation & utilities */
a2275 1

d2296 1
a2296 1
  /* Turn any symbols with register attributes into abs symbols */
d2298 1
a2298 4
    {
      S_SET_SEGMENT (symbolP, absolute_section);
    }
  /* At the same time, relocate all symbols to their output value */
d2300 1
d2323 1
a2324 1

d2331 1
a2331 1
  char underscore = 0;		/* Symbol has leading _ */
d2333 1
a2333 1
  /* Effective symbol */
d2339 1
a2339 1
  /* Additional information */
d2341 1
a2341 1
  /* Auxiliary entries */
d2350 1
a2350 3
/*
 * Handle .ln directives.
 */
d2360 1
d2364 1
a2364 1
    }				/* wrong context */
d2388 8
a2395 13
/*
 *			def()
 *
 * Handle .def directives.
 *
 * One might ask : why can't we symbol_new if the symbol does not
 * already exist and fill it with debug information.  Because of
 * the C_EFCN special symbol. It would clobber the value of the
 * function symbol before we have a chance to notice that it is
 * a C_EFCN. And a second reason is that the code is more clear this
 * way. (at least I think it is :-).
 *
 */
d2406 3
a2408 3
  char name_end;		/* Char after the end of name */
  char *symbol_name;		/* Name of the debug symbol */
  char *symbol_name_copy;	/* Temporary copy of the name */
d2416 1
a2416 1
    }				/* if not inside .def/.endef */
d2432 1
a2432 1
  /* Initialize the new symbol */
d2468 1
a2468 1
    }				/* if not inside .def/.endef */
d2477 2
a2478 1
      /* intentional fallthrough */
d2486 4
a2489 2
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol.  */
      /* intentional fallthrough */
d2491 4
a2494 2
      SF_SET_PROCESS (def_symbol_in_progress);	/* Will need processing before writing */
      /* intentional fallthrough */
d2501 2
a2502 3
	    {
	      fprintf (stderr, _("`.bf' symbol without preceding function\n"));
	    }			/* missing function symbol */
d2510 1
d2539 1
a2539 1
      /* Valid but set somewhere else (s_comm, s_lcomm, colon) */
d2547 1
a2547 1
    }				/* switch on storage class */
d2602 1
a2602 1
	  /* If it already is at the end of the symbol list, do nothing */
d2609 3
a2611 3
	    }			/* if not already in place */
	}			/* if function */
    }				/* normal or mergable */
d2637 2
a2638 2
	}			/* definition follows debug */
    }				/* Create the line number entry pointing to the function being defined */
d2655 1
a2655 1
    }				/* if not inside .def/.endef */
d2673 2
a2674 1
	  /* intentional fallthrough */
d2709 1
a2709 3
	{
	  line_base = this_base;
	}
d2715 1
a2715 3
	  {
	    listing_source_line ((unsigned int) line_base);
	  }
d2735 1
a2735 1
    }				/* if not inside .def/.endef */
d2751 1
a2751 1
    }				/* if not inside .def/.endef */
d2783 1
a2783 3
    {
      as_warn (_("tag not found for .tag %s"), symbol_name);
    }				/* not defined */
d2800 1
a2800 1
    }				/* if not inside .def/.endef */
d2806 1
a2806 3
    {
      SF_SET_FUNCTION (def_symbol_in_progress);
    }				/* is a function */
d2820 1
a2820 1
    }				/* if not inside .def/.endef */
d2835 1
a2835 1
	  /* If the .val is != from the .def (e.g. statics) */
d2904 1
a2904 1
   externals onto another chain */
d2910 1
a2910 1
/* The chain of externals */
d2947 1
a2947 1
	  /* Debug symbols do not need all this rubbish */
d2966 1
a2966 1
	      /* Replace the current symbol by the real one */
d2969 1
a2969 1
		 .text, .data, .bss */
d2974 1
a2974 1
	    }			/* if not local but dup'd */
d2977 1
a2977 3
	    {
	      S_SET_SEGMENT (symbolP, SEG_E0);
	    }			/* push data into text */
d2987 1
d2989 2
a2990 3
		{
		  S_SET_STORAGE_CLASS (symbolP, C_LABEL);
		}
d2992 1
a2992 3
		{
		  S_SET_STORAGE_CLASS (symbolP, C_STAT);
		}
d2995 1
a2995 1
	  /* Mainly to speed up if not -g */
d3004 4
a3007 2
		    {		/* .eb */
		      register symbolS *begin_symbolP;
d3025 1
a3025 3
		    {
		      S_SET_NUMBER_AUXILIARY (symbolP, 1);
		    }		/* make it at least 1 */
d3029 1
a3029 1
		  /* Iffed out by steve - this fries the lnnoptr info too */
d3060 1
a3060 1
	       the first slot after the structure description.  */
d3066 1
a3066 1
	  /* +2 take in account the current symbol */
d3072 1
a3072 1
	     auxent, put it in the string table */
d3084 2
a3085 2
	    }			/* no one points at the first .file symbol */
	}			/* if debug or tag or eos or file */
d3104 2
a3105 2
	  /* remove C_EFCN and LOCAL (L...) symbols */
	  /* next pointer remains valid */
d3125 1
a3125 1
	  /* if external, Remove from the list */
a3146 1

d3163 1
a3163 1
	    }			/* fix "long" names */
d3167 3
a3169 2
	}			/* if local symbol */
    }				/* traverse the symbol list */
a3170 1

d3184 1
a3184 1
      /* append */
d3188 1
a3188 1
      /* and process */
d3196 1
d3198 1
a3198 1
	}			/* fix "long" names */
d3202 1
a3202 1
    }				/* append the entire extern chain */
d3230 1
d3238 1
a3238 1
  /* Initialize the stack used to keep track of the matching .bb .be */
d3243 8
a3250 9
   * order :
   * . .file symbol
   * . debug entries for functions
   * . fake symbols for the sections, including .text .data and .bss
   * . defined symbols
   * . undefined symbols
   * But this is not mandatory. The only important point is to put the
   * undefined symbols at the end of the list.
   */
d3255 1
a3255 3
    {
      c_dot_file_symbol ("fake");
    }
d3257 1
a3257 3
  /*
   * Build up static symbols for the sections, they are filled in later
   */
d3261 1
a3261 1
      segment_info[i].dot = c_section_symbol (segment_info[i].name,
d3264 1
a3264 1
  /* Take all the externals out and put them into another chain */
d3266 1
a3266 1
  /* Take the externals and glue them onto the end.*/
d3281 1
a3281 3
/*
 * Find strings by crawling along symbol table chain.
 */
d3290 1
a3290 1
  /* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
d3362 1
a3362 1
	 form, take this chance to remove duplicates */
d3377 1
a3377 3
		{
		  line_ptr->line.l_addr.l_paddr += ((struct frag *) (line_ptr->frag))->fr_address;
		}
a3380 1

d3391 1
d3397 1
a3397 1
   list, as if the seg 0 was extra long */
d3422 1
d3481 1
a3481 3
    {
      relax_segment (segment_info[i].frchainP->frch_root, i);
    }
d3535 1
a3535 1
  /* Turn the gas native symbol table shape into a coff symbol table */
d3569 1
a3569 2
  /* Plant the data */

d3664 14
a3677 16
/*
 * implement the .section pseudo op:
 *	.section name {, "flags"}
 *                ^         ^
 *                |         +--- optional flags: 'b' for bss
 *                |                              'i' for info
 *                +-- section name               'l' for lib
 *                                               'n' for noload
 *                                               'o' for over
 *                                               'w' for data
 *						 'd' (apparently m88k for data)
 *                                               'x' for text
 *						 'r' for read-only data
 * But if the argument is not a quoted string, treat it as a
 * subsegment number.
 */
d3683 1
a3683 1
  /* Strip out the section name */
d3780 1
a3780 1
  segT current_seg = now_seg;		/* save current seg	*/
d3782 4
a3785 3
  subseg_new (".comment", 0);		/* .comment seg		*/
  stringer (1);				/* read string		*/
  subseg_set (current_seg, current_subseg);	/* restore current seg	*/
d3797 1
a3797 3
    {
      S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));
    }				/* take the most we have */
d3800 3
a3802 5
    {
      memcpy ((char *) &normal->sy_symbol.ost_auxent[0],
	      (char *) &debug->sy_symbol.ost_auxent[0],
	      (unsigned int) (S_GET_NUMBER_AUXILIARY (debug) * AUXESZ));
    }				/* Move all the auxiliary information */
d3806 1
a3806 1
}				/* c_symbol_merge() */
d3835 1
a3835 3
    {
      s->lineno_list_head = new_line;
    }
d3837 2
a3838 3
    {
      s->lineno_list_tail->next = new_line;
    }
d3862 1
a3862 1
	 them later.*/
d3886 1
a3886 4
      {
	listing_source_file (filename);
      }

a3887 1

d3894 1
a3894 1
  /* Make sure that the symbol is first on the symbol chain */
d3900 1
a3900 1
}				/* c_dot_file_symbol() */
d3902 1
a3902 3
/*
 * Build a 'section static' symbol.
 */
d3962 1
a3962 1
}				/* c_section_symbol() */
d3973 1
a3973 1
  /* First fill in those values we have only just worked out */
d3985 1
a3985 3
  /*
     * Emit all symbols left in the symbol chain.
     */
d3989 2
a3990 2
	       to the string in memory but must be a file offset.  */
      register char *temp;
d3996 2
a3997 4
	{
	  SA_GET_SYM_LNNOPTR (symbolP) +=
	    segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_lnnoptr;
	}
d4015 1
a4015 2

}				/* w_symbols() */
d4065 1
a4065 1
	  segT current_seg = now_seg; 	/* save current seg     */
d4073 1
a4073 1
	  subseg_set (current_seg, current_subseg); /* restore current seg */
d4092 1
d4131 3
a4133 3
  register fixS * fixP;
  register symbolS *add_symbolP;
  register symbolS *sub_symbolP;
d4135 6
a4140 6
  register int size;
  register char *place;
  register long where;
  register char pcrel;
  register fragS *fragP;
  register segT add_symbol_segment = absolute_section;
d4228 1
a4228 3
	{
	  add_symbol_segment = S_GET_SEGMENT (add_symbolP);
	}			/* if there is an addend */
d4259 1
a4259 1
		 and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE */
d4271 2
a4272 4
		{
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("callj to difference of 2 symbols"));
		}
d4295 2
a4296 3
		{
		  add_number -= S_GET_VALUE (sub_symbolP);
		}
d4320 1
a4320 1
		}		/* if absolute */
d4322 1
a4322 1
	}			/* if sub_symbolP */
d4328 3
a4330 5
	      /*
	       * This fixup was made when the symbol's segment was
	       * SEG_UNKNOWN, but it is now in the local segment.
	       * So we know how to do the address without relocation.
	       */
d4333 3
a4335 4
	       * in which cases it modifies *fixP as appropriate.  In the case
	       * of a 'calls', no further work is required, and *fixP has been
	       * set up to make the rest of the code below a no-op.
	       */
d4369 2
a4370 1
		  reloc_callj (fixP);	/* See comment about reloc_callj() above*/
d4398 3
a4400 4
		       * 13-bit displacement and are only to be used
		       * for local branches: flag as error, don't generate
		       * relocation.
		       */
d4406 1
a4406 1
		    }		/* COBR */
d4422 3
a4424 3
		}		/* switch on symbol seg */
	    }			/* if not in local seg */
	}			/* if there was a + symbol */
d4434 1
a4434 3
	    {
	      fixP->fx_addsy = &abs_symbol;
	    }			/* if there's an add_symbol */
d4454 1
a4454 1
	}			/* if pcrel */
d4493 3
a4495 3
	}			/* not a bit fix */
    }				/* For each fixS in this segment.  */
}				/* fixup_segment() */
@


1.56
log
@Add support for OpenRISC 32-bit embedded processor
@
text
@d571 1
a571 1
        lineno += coff_line_base - 1;
d719 1
a719 1
  	  {
d845 1
a845 1
                                      DO_NOT_STRIP)) == NULL
d850 1
a850 1
        {
d854 1
a854 1
        }
d1507 1
a1507 1
        flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
d1511 3
a1513 3
        as_warn (_("error setting flags for \"%s\": %s"),
                 bfd_section_name (stdoutput, sec),
                 bfd_errmsg (bfd_get_error ()));
d1567 1
a1567 1
        fragp = fragp->fr_next;
@


1.56.2.1
log
@2002-05-11  Daniel Jacobowitz  <drow@@mvista.com>

        Merge from mainline:
        2002-05-11  Nick Clifton  <nickc@@cambridge.redhat.com>
        * config/obj-coff.c: Fix compile time warnings when compiling
        without BFD_ASSEMBLER defined.
        Fix formatting.

        * config/tc-sh.c (md_pcrel_from): Define for use with sh-hms
        target.
        (md_pcrel_from_section): Use md_pcrel_from().
@
text
@d1716 1
a1716 1
/* Structure used to keep the filenames which
d1718 1
a1718 1
   into the string table.  */
d1732 5
a1736 1
   section number into a segment number.  */
d1738 1
a1739 2
static symbolS *previous_file_symbol;
static int line_base;
d1741 20
a1760 13
void c_symbol_merge PARAMS ((symbolS *, symbolS *));
symbolS *c_section_symbol PARAMS ((char *, int));
void obj_coff_section PARAMS ((int));
void do_relocs_for PARAMS ((bfd *, object_headers *, unsigned long *));
char * symbol_to_chars PARAMS ((bfd *, char *, symbolS *));
void w_strings PARAMS ((char *));

static void fixup_segment PARAMS ((segment_info_type *, segT));
static void fixup_mdeps PARAMS ((fragS *, object_headers *, segT));
static void fill_section PARAMS ((bfd *,  object_headers *, unsigned long *));
static int c_line_new PARAMS ((symbolS *, long, int, fragS *));
static void w_symbols PARAMS ((bfd *, char *, symbolS *));
static void adjust_stab_section PARAMS ((bfd *, segT));
d1764 1
a1764 10
static unsigned int count_entries_in_chain PARAMS ((unsigned int));
static void coff_header_append PARAMS ((bfd *, object_headers *));
static unsigned int yank_symbols PARAMS ((void));
static unsigned int glue_symbols PARAMS ((symbolS **, symbolS **));
static unsigned int tie_tags PARAMS ((void));
static void crawl_symbols PARAMS ((object_headers *, bfd *));
static void do_linenos_for PARAMS ((bfd *, object_headers *, unsigned long *));
static void remove_subsegs PARAMS ((void));


a1802 2
static relax_addressT relax_align PARAMS ((relax_addressT, long));

d1823 2
a1824 5
static unsigned int size_section PARAMS ((bfd *, unsigned int));

/* Calculate the size of the frag chain and fill in the section header
   to contain all of it, also fill in the addr of the sections.  */

a1832 1

d1885 1
a1885 1
  /* Count the relocations.  */
d1911 1
a1911 2
/* AUX's ld expects relocations to be sorted.  */

d1926 1
a1926 2
/* Output all the relocations for a section.  */

d1964 1
a1964 1
		  /* Only output some of the relocations.  */
d1970 1
a2014 1

d2017 3
a2019 1
			    intr.r_symndx = dot->sy_number;
d2021 4
a2024 1
			    intr.r_symndx = symbol_ptr->sy_number;
d2027 3
a2029 1
			intr.r_symndx = -1;
d2031 1
d2034 1
d2036 1
d2041 1
d2044 1
a2044 1
			  /* Now emit the second bit.  */
d2069 1
d2071 1
a2071 1
	      /* Sort the reloc table.  */
d2075 2
a2076 1
	      /* Write out the reloc table.  */
d2088 1
a2088 1
	      /* No relocs.  */
d2093 1
a2093 2

  /* Set relocation_size field in file headers.  */
d2097 3
a2099 3
/* Run through a frag chain and write out the data to go with it, fill
   in the scnhdrs with the info on the file postions.  */

d2106 1
d2232 1
a2232 1
/* Coff file generation & utilities.  */
d2282 1
d2303 1
a2303 1
  /* Turn any symbols with register attributes into abs symbols.  */
d2305 4
a2308 1
    S_SET_SEGMENT (symbolP, absolute_section);
a2309 1
  /* At the same time, relocate all symbols to their output value.  */
d2332 1
a2333 1
  return where;
d2340 1
a2340 1
  char underscore = 0;		/* Symbol has leading _  */
d2342 1
a2342 1
  /* Effective symbol.  */
d2348 1
a2348 1
  /* Additional information.  */
d2350 1
a2350 1
  /* Auxiliary entries.  */
d2359 3
a2361 1
/* Handle .ln directives.  */
a2370 1
      /* Wrong context.  */
d2374 1
a2374 1
    }
d2398 13
a2410 8
/* Handle .def directives.
 
  One might ask : why can't we symbol_new if the symbol does not
  already exist and fill it with debug information.  Because of
  the C_EFCN special symbol. It would clobber the value of the
  function symbol before we have a chance to notice that it is
  a C_EFCN. And a second reason is that the code is more clear this
  way. (at least I think it is :-).  */
d2421 3
a2423 3
  char name_end;		/* Char after the end of name.  */
  char *symbol_name;		/* Name of the debug symbol.  */
  char *symbol_name_copy;	/* Temporary copy of the name.  */
d2431 1
a2431 1
    }
d2447 1
a2447 1
  /* Initialize the new symbol.  */
d2483 1
a2483 1
    }
d2492 1
a2492 2
      /* Intentional fallthrough.  */

d2500 2
a2501 4
      /* Do not emit this symbol.  */
      SF_SET_LOCAL (def_symbol_in_progress);
      /* Intentional fallthrough. */
      
d2503 2
a2504 4
      /* Will need processing before writing.  */
      SF_SET_PROCESS (def_symbol_in_progress);
      /* Intentional fallthrough.  */

d2511 3
a2513 2
	    fprintf (stderr, _("`.bf' symbol without preceding function\n"));

a2520 1

d2549 1
a2549 1
      /* Valid but set somewhere else (s_comm, s_lcomm, colon).  */
d2557 1
a2557 1
    }
d2612 1
a2612 1
	  /* If it already is at the end of the symbol list, do nothing.  */
d2619 3
a2621 3
	    }
	}
    }
d2647 2
a2648 2
	}
    }
d2665 1
a2665 1
    }
d2683 1
a2683 2
	  /* Intentional fallthrough.  */

d2718 3
a2720 1
	line_base = this_base;
d2726 3
a2728 1
	  listing_source_line ((unsigned int) line_base);
d2748 1
a2748 1
    }
d2764 1
a2764 1
    }
d2796 3
a2798 1
    as_warn (_("tag not found for .tag %s"), symbol_name);
d2815 1
a2815 1
    }
d2821 3
a2823 1
    SF_SET_FUNCTION (def_symbol_in_progress);
d2837 1
a2837 1
    }
d2852 1
a2852 1
	  /* If the .val is != from the .def (e.g. statics).  */
d2921 1
a2921 1
   externals onto another chain.  */
d2927 1
a2927 1
/* The chain of externals.  */
d2964 1
a2964 1
	  /* Debug symbols do not need all this rubbish.  */
d2983 1
a2983 1
	      /* Replace the current symbol by the real one.  */
d2986 1
a2986 1
		 .text, .data, .bss.  */
d2991 1
a2991 1
	    }
d2994 3
a2996 1
	    S_SET_SEGMENT (symbolP, SEG_E0);
a3005 1

d3007 3
a3009 2
		S_SET_STORAGE_CLASS (symbolP, C_LABEL);

d3011 3
a3013 1
		S_SET_STORAGE_CLASS (symbolP, C_STAT);
d3016 1
a3016 1
	  /* Mainly to speed up if not -g.  */
d3025 2
a3026 4
		    {
		      /* .eb */
		      symbolS *begin_symbolP;

d3044 3
a3046 1
		    S_SET_NUMBER_AUXILIARY (symbolP, 1);
d3050 1
a3050 1
		  /* Iffed out by steve - this fries the lnnoptr info too.  */
d3081 1
a3081 1
	     the first slot after the structure description.  */
d3087 1
a3087 1
	  /* +2 take in account the current symbol.  */
d3093 1
a3093 1
	     auxent, put it in the string table.  */
d3105 2
a3106 2
	    }
	}
d3125 2
a3126 2
	  /* Remove C_EFCN and LOCAL (L...) symbols.  */
	  /* Next pointer remains valid.  */
d3146 1
a3146 1
	  /* If external, Remove from the list.  */
d3168 1
d3185 1
a3185 1
	    }
d3189 3
a3191 2
	}
    }
a3192 1
  return symbol_number;
d3206 1
a3206 1
      /* Append.  */
d3210 1
a3210 1
      /* Process.  */
a3217 1
	  /* Fix "long" names.  */
d3219 1
a3219 1
	}
d3223 1
a3223 1
    }
a3250 1

d3258 1
a3258 1
  /* Initialize the stack used to keep track of the matching .bb .be.  */
d3263 9
a3271 8
     order :
     . .file symbol
     . debug entries for functions
     . fake symbols for the sections, including .text .data and .bss
     . defined symbols
     . undefined symbols
     But this is not mandatory. The only important point is to put the
     undefined symbols at the end of the list.  */
d3276 3
a3278 1
    c_dot_file_symbol ("fake");
d3280 3
a3282 1
  /* Build up static symbols for the sections, they are filled in later.  */
d3286 1
a3286 1
      segment_info[i].dot = c_section_symbol ((char *) segment_info[i].name,
d3289 1
a3289 1
  /* Take all the externals out and put them into another chain.  */
d3291 1
a3291 1
  /* Take the externals and glue them onto the end.  */
d3306 3
a3308 1
/* Find strings by crawling along symbol table chain.  */
d3317 1
a3317 1
  /* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK.  */
d3389 1
a3389 1
	     form, take this chance to remove duplicates.  */
d3404 3
a3406 1
		line_ptr->line.l_addr.l_paddr += ((struct frag *) (line_ptr->frag))->fr_address;
d3410 1
a3420 1

d3426 1
a3426 1
   list, as if the seg 0 was extra long.  */
a3450 1

d3509 3
a3511 1
    relax_segment (segment_info[i].frchainP->frch_root, i);
d3565 1
a3565 1
  /* Turn the gas native symbol table shape into a coff symbol table.  */
d3599 2
a3600 1
  /* Plant the data.  */
d3695 16
a3710 14
/* Implement the .section pseudo op:
  	.section name {, "flags"}
                  ^         ^
                  |         +--- optional flags: 'b' for bss
                  |                              'i' for info
                  +-- section name               'l' for lib
                                                 'n' for noload
                                                 'o' for over
                                                 'w' for data
  						 'd' (apparently m88k for data)
                                                 'x' for text
  						 'r' for read-only data
   But if the argument is not a quoted string, treat it as a
   subsegment number.  */
d3716 1
a3716 1
  /* Strip out the section name.  */
d3813 1
a3813 1
  segT current_seg = now_seg;		/* Save current seg.  */
d3815 3
a3817 4

  subseg_new (".comment", 0);		/* .comment seg.  */
  stringer (1);				/* Read string.  */
  subseg_set (current_seg, current_subseg);	/* Restore current seg.  */
d3829 3
a3831 1
    S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));
d3834 5
a3838 3
    memcpy ((char *) &normal->sy_symbol.ost_auxent[0],
	    (char *) &debug->sy_symbol.ost_auxent[0],
	    (unsigned int) (S_GET_NUMBER_AUXILIARY (debug) * AUXESZ));
d3842 1
a3842 1
}
d3871 3
a3873 1
    s->lineno_list_head = new_line;
d3875 3
a3877 2
    s->lineno_list_tail->next = new_line;

d3901 1
a3901 1
	 them later.  */
d3925 4
a3928 1
      listing_source_file (filename);
d3930 1
d3937 1
a3937 1
  /* Make sure that the symbol is first on the symbol chain.  */
d3943 1
a3943 1
}
d3945 3
a3947 1
/* Build a 'section static' symbol.  */
d4007 1
a4007 1
}
d4018 1
a4018 1
  /* First fill in those values we have only just worked out.  */
d4030 3
a4032 1
  /* Emit all symbols left in the symbol chain.  */
d4036 2
a4037 2
	 to the string in memory but must be a file offset.  */
      char *temp;
d4043 4
a4046 2
	SA_GET_SYM_LNNOPTR (symbolP) +=
	  segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_lnnoptr;
d4064 2
a4065 1
}
d4115 1
a4115 1
	  segT current_seg = now_seg; 	/* Save current seg.  */
d4123 1
a4123 1
	  subseg_set (current_seg, current_subseg); /* Restore current seg.  */
a4141 1

d4180 3
a4182 3
  fixS * fixP;
  symbolS *add_symbolP;
  symbolS *sub_symbolP;
d4184 6
a4189 6
  int size;
  char *place;
  long where;
  char pcrel;
  fragS *fragP;
  segT add_symbol_segment = absolute_section;
d4277 3
a4279 1
	add_symbol_segment = S_GET_SEGMENT (add_symbolP);
d4310 1
a4310 1
		 and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE.  */
d4322 4
a4325 2
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("callj to difference of 2 symbols"));
d4348 3
a4350 2
		add_number -= S_GET_VALUE (sub_symbolP);

d4374 1
a4374 1
		}
d4376 1
a4376 1
	}
d4382 5
a4386 3
	      /* This fixup was made when the symbol's segment was
	         SEG_UNKNOWN, but it is now in the local segment.
	         So we know how to do the address without relocation.  */
d4389 4
a4392 3
	         in which cases it modifies *fixP as appropriate.  In the case
	         of a 'calls', no further work is required, and *fixP has been
	         set up to make the rest of the code below a no-op.  */
d4426 1
a4426 2
		  /* See comment about reloc_callj() above.  */
		  reloc_callj (fixP);
d4454 4
a4457 3
		         13-bit displacement and are only to be used
		         for local branches: flag as error, don't generate
		         relocation.  */
d4463 1
a4463 1
		    }
d4479 3
a4481 3
		}
	    }
	}
d4491 3
a4493 1
	    fixP->fx_addsy = &abs_symbol;
d4513 1
a4513 1
	}
d4552 3
a4554 3
	}
    }
}
@


1.55
log
@* config/obj-coff.c (obj_coff_init_stab_section): Make the
stabstr_name allocation permanent, as it will be referenced from
the section hash.
@
text
@d3 1
a3 1
   1999, 2000, 2001
d1892 1
a1892 1
#ifdef TC_A29K
d2051 14
d2144 1
d2152 1
d4439 1
a4439 1
#if defined(TC_A29K) || (defined(TE_PE) && defined(TC_I386)) || defined(TC_M88K)
d4485 1
a4485 1
#if !defined(TC_M88K) && !(defined(TE_PE) && defined(TC_I386)) && !defined(TC_A29K)
@


1.54
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d1634 1
a1634 1
  stabstr_name = (char *) alloca (strlen (seg->name) + 4);
@


1.53
log
@Fix 2 xcoff line number problems
@
text
@d4499 1
a4499 5
#ifdef MD_APPLY_FIX3
      md_apply_fix3 (fixP, (valueT *) &add_number, this_segment_type);
#else
      md_apply_fix (fixP, add_number);
#endif
@


1.52
log
@	* dwarf2dbg.c (dwarf2_directive_file): Avoid signed/unsigned warning.

	* write.c (set_symtab): Update bfd_alloc declaration.  Use a temp
	var to ensure bfd_alloc arg is the right type.
	(write_object_file): Cast args of bfd_seek.  Replace bfd_write with
	bfd_bwrite.

	* config/obj-coff.c: Replace calls to bfd_write with calls to
	bfd_bwrite.  Cast args of bfd_seek.

	* config/obj-elf.c (obj_elf_change_section): Avoid signed/unsigned
	warning.

	* config/tc-mn10300.c (set_arch_mach): Make param unsigned.

	* config/tc-tic54x.c (tic54x_mlib): Replace bfd_read call with
	call to bfd_bread.
@
text
@d1312 1
d1321 1
a1321 1

@


1.51
log
@	* symbols.c: Add missing prototypes.
	* config/e-i386elf.c: Likewise.
	* config/e-i386coff.c: Likewise.
	* config/e-i386aout.c: Likewise.
	* config/obj-coff.c: Likewise.
	(def_symbol_in_progress, stack): Move definition.
	* config/obj-elf.c: Add missing prototypes.
	(obj_elf_change_section): Make static.
	(obj_elf_parse_section_letters): Likewise.
	(obj_elf_section_word): Likewise.
	(obj_elf_section_type): Likewise.
@
text
@d2062 2
a2063 2
	      bfd_write ((PTR) external_reloc_vec, 1, external_reloc_size,
			 abfd);
d2205 1
a2205 1
		  bfd_write (buffer, s->s_size, 1, abfd);
d2229 1
a2229 1
  bfd_seek (abfd, 0, 0);
d2245 2
a2246 2
  bfd_write (buffer, i, 1, abfd);
  bfd_write (buffero, H_GET_SIZEOF_OPTIONAL_HEADER (h), 1, abfd);
d2271 1
a2271 1
	  bfd_write (buffer, size, 1, abfd);
d3398 1
a3398 1
	  bfd_write (buffer, 1, s->scnhdr.s_nlnno * LINESZ, abfd);
d3621 2
a3622 1
    bfd_write (buffer1, 1, symtable_size + string_byte_count, abfd);
@


1.50
log
@Don't merge if the storage class of the non-debug symbol is C_NULL.
@
text
@d41 21
d63 1
a78 4

/* This is used to hold the symbol built by a sequence of pseudo-ops
   from .def and .endef.  */
static symbolS *def_symbol_in_progress;
a80 9
typedef struct
  {
    unsigned long chunk_size;
    unsigned long element_size;
    unsigned long size;
    char *data;
    unsigned long pointer;
  }
stack;
d258 1
d260 3
@


1.49
log
@Treat a .ln directive outside of a function as a .appline directive.
@
text
@d1177 2
a1178 1
      symbolS *real;
d1184 1
d1191 1
d1205 1
d1215 1
d1223 1
d1227 1
d1235 1
d1247 1
@


1.48
log
@Branch hints for Pentium4 as insn modifiers, and some minor tweaks
to formatting.
@
text
@a495 4
  if (!appline)
    {
      add_lineno (frag_now, frag_now_fix (), l);
    }
d497 3
a499 1
  if (appline)
d501 2
@


1.47
log
@	* config/obj-ieee.c (write_object_file): Set finalize_syms.
	* config/obj-coff.c (write_object_file): Likewise.
	* (size_section): Remove rs_space assert as fr_symbol is no longer
	removed.
	(fill_section): Likewise.
@
text
@d1496 2
a1497 2
      flagword matchflags = SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	                  | SEC_DATA | SEC_SHARED | SEC_NEVER_LOAD;
@


1.46
log
@Fix for gas seg fault and neg line numbers
@
text
@a1826 1
	  assert (frag->fr_symbol == 0);
a2139 1
		  assert (frag->fr_symbol == 0);
d3473 3
@


1.45
log
@	* symbols.c (resolve_symbol_value): Remove "finalize" param,
	instead use finalize_syms directly.  Don't treat expressions
	specially with regard to finalize_syms.  Update calls to self.
	(resolve_local_symbol): Update call to resolve_symbol_value.
	(S_GET_VALUE): Likewise.  Return resolve_symbol_value if
	!finalize_syms.
	* symbols.h (resolve_symbol_value): Update prototype.
	* config/obj-aout.c (obj_crawl_symbol_chain): Update call
	to resolve_symbol_value.
	* config/obj-bout.c (obj_crawl_symbol_chain): Likewise.
	* config/obj-coff.c (do_relocs_for): Likewise.
	(yank_symbols): Likewise.
	(fixup_segment): Likewise.
	* config/obj-vms.c (obj_crawl_symbol_chain): Likewise.
	* config/tc-mips.c (md_convert_frag): Likewise.
	* config/tc-ppc.c (ppc_frob_symbol): Likewise.
	(ppc_fix_adjustable): Likewise.
	* dwarf2dbg.c (dwarf2dbg_estimate_size_before_relax): Likewise.
	(dwarf2dbg_convert_frag): Likewise.
	* ehopt.c (eh_frame_estimate_size_before_relax): Likewise.
	(eh_frame_convert_frag): Likewise.
	* expr.c (make_expr_symbol): Likewise.
	* write.c (adjust_reloc_syms): Likewise.
	(write_object_file): Likewise.
	(relax_segment): Likewise.
	(fixup_segment): Likewise.
	(finalize_syms): Init to zero, and update comment.
	(write_object_file): Set finalize_syms to 1 rather than 2.
	* doc/internals.texi (sy_value): Mention finalize_syms.
	(S_GET_VALUE): Remove restriction on when S_GET_VALUE can be called.
@
text
@d449 4
d459 1
@


1.44
log
@Check to see if the filename symbol has been initialised before extracting
its symbol index.
@
text
@d1975 1
a1975 1
			  resolve_symbol_value (symbol_ptr, finalize_syms);
d2956 1
a2956 1
	  resolve_symbol_value (symbolP, finalize_syms);
d4189 1
a4189 1
	resolve_symbol_value (add_symbolP, finalize_syms);
d4219 1
a4219 1
	resolve_symbol_value (sub_symbolP, finalize_syms);
@


1.43
log
@Pass finalize_syms on calls to resolve_symbol_value.
@
text
@d2079 1
a2079 1
	  char *buffer;
a3352 1

d3355 5
a3359 3
		  /* Turn a pointer to a symbol into the symbols' index */
		  line_ptr->line.l_addr.l_symndx =
		    ((symbolS *) line_ptr->line.l_addr.l_symndx)->sy_number;
@


1.42
log
@Fix copyright notices
@
text
@d1975 1
a1975 1
			  resolve_symbol_value (symbol_ptr, 1);
d2956 1
a2956 1
	  resolve_symbol_value (symbolP, 1);
d4188 1
a4188 1
	resolve_symbol_value (add_symbolP, 1);
d4218 1
a4218 1
	resolve_symbol_value (sub_symbolP, 1);
@


1.41
log
@Set SEC_NEVER_LOAD when the 'n' flag is used.
@
text
@d2 2
a3 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.40
log
@fix formatting
@
text
@d1437 1
a1437 1
		case 'n': flags &=~ SEC_LOAD; break;
d1491 1
a1491 1
                           | SEC_DATA | SEC_SHARED;
@


1.39
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d4059 1
a4059 1
  symbolP = symbol_find_or_make(name);
d4061 2
a4062 2
  if (S_GET_SEGMENT(symbolP) == SEG_UNKNOWN &&
      S_GET_VALUE(symbolP) == 0)
d4076 2
a4077 2
	  S_SET_SEGMENT(symbolP, SEG_E2);
	  S_SET_STORAGE_CLASS(symbolP, C_STAT);
d4081 1
a4081 1
    as_bad(_("Symbol %s already defined"), name);
d4083 1
a4083 1
  demand_empty_rest_of_line();
@


1.39.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001
@


1.39.2.2
log
@Merge from mainline.
@
text
@a448 4

#ifndef OBJ_XCOFF
  /* The native aix assembler accepts negative line number */

a454 1
#endif /* OBJ_XCOFF */
d1438 1
a1438 1
		case 'n': flags &=~ SEC_LOAD; flags |= SEC_NEVER_LOAD; break;
d1491 2
a1492 2
      flagword matchflags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
			     | SEC_DATA | SEC_SHARED | SEC_NEVER_LOAD);
d2079 1
a2079 1
	  char *buffer = NULL;
d3353 1
d3356 3
a3358 5
		  /* Turn a pointer to a symbol into the symbols' index,
		     provided that it has been initialised.  */
		  if (line_ptr->line.l_addr.l_symndx)
		    line_ptr->line.l_addr.l_symndx =
		      ((symbolS *) line_ptr->line.l_addr.l_symndx)->sy_number;
d4060 1
a4060 1
  symbolP = symbol_find_or_make (name);
d4062 2
a4063 2
  if (S_GET_SEGMENT (symbolP) == SEG_UNKNOWN &&
      S_GET_VALUE (symbolP) == 0)
d4077 2
a4078 2
	  S_SET_SEGMENT (symbolP, SEG_E2);
	  S_SET_STORAGE_CLASS (symbolP, C_STAT);
d4082 1
a4082 1
    as_bad (_("Symbol %s already defined"), name);
d4084 1
a4084 1
  demand_empty_rest_of_line ();
@


1.38
log
@2000-11-30  Philip Blundell  <pb@@futuretv.com>

	* config/obj-coff.c (obj_coff_weak): Use S_SET_WEAK if it exists,
	even in non BFD_ASSEMBLER case.
@
text
@d1829 1
d2139 1
d3448 5
a3452 3
      frag_align (SUB_SEGMENT_ALIGN (now_seg),
		  subseg_text_p (now_seg) ? NOP_OPCODE : 0,
		  0);
d3456 1
d4100 1
@


1.37
log
@2000-11-27  Kazu Hirata  <kazu@@hxi.com>

	* config/obj-aout.h: Fix formatting.
	* config/obj-bout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-elf.h: Likewise.
	* config/obj-som.h: Likewise.
	* config/obj-vms.c: Likewise.
	* config/obj-vms.h: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-z8k.h: Likewise.
@
text
@d223 1
a223 1
#ifdef BFD_ASSEMBLER
@


1.36
log
@2000-11-07  H.J. Lu  <hjl@@gnu.org>

	* doc/as.texinfo (.symver): Updated for versioned symbol
	reference.

	* obj.h (format_ops): Add the frob_file_before_adjust field.

	* config/obj-aout.c (aout_format_ops): Set the
	frob_file_before_adjust field to 0.
	* config/obj-coff.c (coff_format_ops): Likewise.
	* config/obj-ecoff.c (ecoff_format_ops): Likewise.

	* config/obj-elf.c (obj_elf_symver): Allow duplicated version
	name.
	(elf_frob_file_before_adjust): New function to remove unneeded
	versioned symbols from the symbol table.
	(elf_format_ops): Set the frob_file_before_adjust field to
	elf_frob_file_before_adjust.

	* config/obj-elf.h (obj_frob_file_before_adjust): Defined if
	not defined.

	* config/obj-multi.h (obj_frob_file_before_adjust): Defined.
@
text
@d251 1
a251 1
((char*)(&((X)->sy_symbol.ost_auxent->x_file.x_n.x_offset))[1])
d1477 1
a1477 1
      if (strncmp (name, ".gnu.linkonce", sizeof(".gnu.linkonce") - 1) == 0)
d1629 1
a1629 1
      printf(_("0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n"),
@


1.35
log
@2000-09-12  Kazu Hirata  <kazu@@hxi.com>

	* config/obj-aout.c: Fix formatting.
	* config/obj-aout.h: Likewise.
	* config/obj-bout.c: Likewise.
	* config/obj-bout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
@
text
@d4656 1
@


1.34
log
@2000-08-22  H.J. Lu  <hjl@@gnu.org>

	* config.in (STRICTCOFF): New for strict COFF.

	* configure.in: Define STRICTCOFF for i386-*-msdosdjgpp*,
	i386-*-go32* and i386-go32-rtems*.
	* configure: Rebuilt.

	* config/obj-coff.c (obj_coff_endef): Follow the historical
	behavior if STRICTCOFF is not defined.

	* doc/internals.texi: Document STRICTCOFF.
@
text
@d214 1
a214 1
 
d326 1
a326 1
/* Merge a debug symbol containing debug information into a normal symbol. */
d350 1
a350 1
  /* Move the debug flags. */
d411 1
a411 1
  
d421 1
a421 1
  
d448 1
a448 1
  if (num <= 0) 
d673 1
a673 1
  /* Set the section number according to storage class. */
d688 1
a688 1
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol. */
d703 1
a703 1
	      case 'b':  
d712 1
a712 1
	      case 'e':  
d717 1
a717 1
		SA_SET_SYM_LNNO (def_symbol_in_progress, 
d742 1
a742 1
       the name of the file. A section number of -1 indicates that the 
d744 2
a745 2
       absolute-valued symbols include automatic and register variables, 
       function arguments, and .eos symbols. 
d759 1
a759 1
       follow the documented behavior. */
d811 1
a811 1
     the debug symbol is a real function reference. */
d815 1
a815 1
     time. */
d846 1
a846 1
	 previous definition. */
d859 1
a859 1
	     existing symbol to the current place. */
d889 1
a889 1
	     function... */
d1025 1
a1025 1
     This was a bad assumption.  I've added find_or_make. xoxorich. */
d1108 1
a1108 1
         will be calculated later. */
d1122 1
a1122 1
  /* These had better be the same.  Usually 18 bytes. */
a1129 1

d1241 1
a1241 1
      /* more ... */
d1472 1
a1472 1
          
d1521 1
a1521 1
     section alignment, then skip this step, as TICOFF does. */
d1529 1
a1529 1
      
d1600 1
a1600 1
  /* Make space for this first symbol. */
d1602 1
a1602 1
  /* Zero it out. */
d1643 1
a1643 1
/* This is needed because we include internal bfd things. */
d1690 1
a1690 1
struct filename_list 
a1714 1

a1718 1

a1722 1

a1726 1

a1786 1

a1848 1

a2053 1

a2247 1

d2298 1
a2298 1
  /* Store the pointer in the offset. */
a2425 1

d2440 1
a2440 1
  /* Set the section number according to storage class. */
d2455 1
a2455 1
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol. */
d2476 1
a2476 1
      /* Value is always set to . */
d2527 1
a2527 1
     symbol is a real function reference. */
d2531 1
a2531 1
     time. */
d2557 1
a2557 1
      /* FIXME-SOON Should *def_symbol_in_progress be free'd? xoxorich. */
d2566 1
a2566 1
	     existing symbol to the current place. */
d2600 1
a2600 1
	     function... */
d2747 1
a2747 1
     This was a bad assumption.  I've added find_or_make. xoxorich. */
d2829 1
a2829 1
	 its value will be calculated later. */
d2867 1
a2867 1
  /* These had better be the same.  Usually 18 bytes. */
d2922 1
a2922 1
	  /* L* and C_EFCN symbols never merge. */
d2931 1
a2931 1
		 Maybe tag references before definitions? xoxorich. */
d2936 1
a2936 1
		 whereas no pointers refer to the debug symbol. */
d2974 1
a2974 1
	      /* Handle the nested blocks auxiliary info. */
d2992 1
a2992 1
	       entry. */
d3003 1
a3003 1
		  /* Clobber possible stale .dim information. */
d3036 1
a3036 1
	       the first slot after the structure description. */
d3076 1
a3076 2
	 endndx will still be 22 instead of 21. */

a3149 1

d3228 1
a3228 1
  /* Is there a .file symbol ? If not insert one at the beginning. */
a3238 1

a3333 1

a3361 1

a3377 1

a3417 1

a3456 1

a3458 1

d3532 1
a3532 1
     correctly. */
d3593 1
a3593 1
     go is up to Ken.. */
a3738 1

a3745 1

d3787 1
a3787 1
  /* Move the debug flags. */
a3816 1

d3858 1
a3858 1
      if (filename_list_tail) 
d3862 1
a3862 1
      filename_list_tail = f;      
d3864 1
a3864 1
  else 
d3983 1
a3983 1
	       to the string in memory but must be a file offset. */
d4165 1
a4165 1
	     point symbol. */
d4263 1
a4263 1
		 something different for N_UNDF. */
d4290 1
a4290 1
	      /* Different segments in subtraction. */
d4299 1
a4299 1
#if 0 /* Okay for 68k, at least... */
d4359 1
a4359 1
	      pcrel = 0;	/* Lie. Don't want further pcrel processing. */
a4384 1

d4419 1
a4419 1
		     Philippe De Muyter <phdm@@info.ucl.ac.be>. */
a4424 1

d4503 1
a4503 1
    }				/* For each fixS in this segment. */
d4519 1
a4519 1
  /* Make space for this first symbol. */
d4521 1
a4521 1
  /* Zero it out. */
d4546 1
a4546 1
  /* Look for the associated string table section. */
d4563 1
a4563 1
  /* If we found the section, get its size. */
d4570 1
a4570 1
     symbol, and collect a pointer to it. */
d4578 1
a4578 1
     table. */
@


1.33
log
@Set the debug flag for storage types C_ARG, C_REGPARM, C_FIELD, C_MOS, C_MOE,
C_MOU, and C_EOS.
@
text
@d735 26
d765 1
d769 9
@


1.32
log
@* config/obj-coff.c (obj_frob_symbol): Don't merge
labels. Don't merge if the symbol isn't constant. Return
immediately if a symbol is merged.
@
text
@a734 4
      SF_SET_DEBUG (def_symbol_in_progress);
      S_SET_SEGMENT (def_symbol_in_progress, absolute_section);
      break;

d739 1
@


1.31
log
@* config/obj-coff.c (obj_frob_symbol): revert previous change,
it breaks linking against DLLs.
@
text
@d1142 2
d1149 1
@


1.30
log
@Don't merge labels. Don't merge if the symbol isn't constant. Don't call
S_SET_EXTERNAL if the storage class is already set.
@
text
@a1141 2
	  && S_GET_STORAGE_CLASS (symp) != C_LABEL
	  && symbol_constant_p(symp)
d1148 1
a1148 1
	if (S_GET_STORAGE_CLASS (symp) == C_NULL)
d1150 8
a1157 10
	  if (!S_IS_DEFINED (symp) && !SF_GET_LOCAL (symp))
	    {
	      assert (S_GET_VALUE (symp) == 0);
	      S_SET_EXTERNAL (symp);
	    }
	  else if (S_GET_SEGMENT (symp) == text_section
	           && symp != seg_info (text_section)->sym)
	    {
	      S_SET_STORAGE_CLASS (symp, C_LABEL);
	    }
d1159 1
a1159 3
	    {
	      S_SET_STORAGE_CLASS (symp, C_STAT);
	    }
@


1.29
log
@ Add padding to the last section when aligning it increases its size.
@
text
@d1142 2
d1150 1
a1150 1
      if (!S_IS_DEFINED (symp) && !SF_GET_LOCAL (symp))
d1152 10
a1161 8
	  assert (S_GET_VALUE (symp) == 0);
	  S_SET_EXTERNAL (symp);
	}
      else if (S_GET_STORAGE_CLASS (symp) == C_NULL)
	{
	  if (S_GET_SEGMENT (symp) == text_section
	      && symp != seg_info (text_section)->sym)
	    S_SET_STORAGE_CLASS (symp, C_LABEL);
d1163 3
a1165 1
	    S_SET_STORAGE_CLASS (symp, C_STAT);
@


1.28
log
@oops - omitted frpom previous delta
@
text
@d1492 14
a1505 2
      size = (size + mask) & ~mask;
      bfd_set_section_size (stdoutput, sec, size);
@


1.27
log
@Applied Mark Elbrecht <snowball3@@bigfoot.com>'s patch to implement
TC_COFF_SECTION_DEFAULT_ATTRIBUTES.
@
text
@d1436 1
a1436 1
        flags = SEC_LOAD;
@


1.26
log
@Do not change an existing section's attributes if a flags argument isn't
present.  Warn if the new attributes don't match the section's current
attributes.
@
text
@d33 7
@


1.25
log
@Typo fix: Change BFD_ASSEMLER to BFD_ASSEMBLER.
@
text
@d655 1
a655 1
  symbolS *symbolP;
d1356 1
a1356 1
  flagword flags;
d1378 1
a1378 1
  flags = SEC_LOAD;
d1423 2
a1424 1
  if (flags != SEC_NO_FLAGS)
d1426 12
a1437 5
      flagword oldflags;

      oldflags = bfd_get_section_flags (stdoutput, sec);
      oldflags &= SEC_LINK_ONCE | SEC_LINK_DUPLICATES;
      flags |= oldflags;
d1440 12
a1451 3
	as_warn (_("error setting flags for \"%s\": %s"),
		 bfd_section_name (stdoutput, sec),
		 bfd_errmsg (bfd_get_error ()));
@


1.24
log
@	* obj.h (struct format_ops): New members begin, app_file,
	s_set_other, s_set_desc, s_get_type, s_set_type,
	separate_stab_sections, init_stab_section.

	* config/obj-multi.h: Update GPL notice to v2.
	(obj_begin): New.
	(obj_app_file): New.
	(S_SET_SIZE): Test s_set_size for NULL before calling.
	(S_SET_ALIGN): Similar for s_set_align.
	(S_SET_OTHER): New.
	(S_SET_DESC): New.
	(S_GET_TYPE): New.
	(S_SET_TYPE): New.
	(SEPARATE_STAB_SECTIONS): New.
	(INIT_STAB_SECTION): New.
	(EMIT_SECTION_SYMBOLS): New.
	(AOUT_STABS) [OBJ_MAYBE_AOUT]: Define.

	* config/obj-elf.h: Update GPL notice to v2.
	Mention that this file is included from obj-multi.h.
	(obj_begin): Wrap definition in ifndef.
	(elf_file_symbol): Constify declaration.
	(obj_app_file): Ditto.
	(SEPARATE_STAB_SECTIONS, INIT_STAB_SECTION, OBJ_PROCESS_STAB):
	Wrap in ifndef SEPARATE_STAB_SECTIONS.

	* config/obj-elf.c (elf_s_set_other): New.
	(elf_file_symbol): Constify argument.
	(elf_separate_stab_sections): New.
	(elf_init_stab_section): New.
	(elf_format_ops): Add new members.  Remove comma at end.

	* config/obj-ecoff.c (ecoff_separate_stab_sections): New.
	(ecoff_format_ops): Add new fields.  Remove comma at end.
	Mention inconsistency for emit_section_symbols.

	* config/obj-coff.h (c_dot_file_symbol): Constify declaration.

	* config/obj-coff.c (c_dot_file_symbol): Constify argument.
	(coff_separate_stab_sections): New.
	(coff_format_ops): Add new members.

	* config/obj-aout.c (obj_aout_sec_sym_ok_for_reloc): New.
	(obj_aout_s_set_other): New.
	(obj_aout_s_set_desc): New.
	(obj_aout_s_get_type): New.
	(obj_aout_s_set_type): New.
	(obj_aout_separate_stab_sections): New.
	(aout_format_ops): New members added.  Use obj_aout_process_stab,
	not 0.  Use obj_aout_sec_sym_ok_for_reloc, not 0.
	(obj_aout_frob_symbol): Add ATTRIBUTE_UNUSED to args as
	appropriate.
	(obj_aout_line, obj_aout_weak, obj_aout_type): Ditto.
@
text
@d216 1
a216 1
#ifdef BFD_ASSEMLER
@


1.23
log
@	Add XCOFF64 support.

	bfd:
	* Makefile.am (coff64-rs6000.lo): New rule.
	* Makefile.in: Regenerate.
	* coff-rs6000.c (xcoff_mkobject, xcoff_copy_private_bfd_data,
	xcoff_is_local_label_name, xcoff_rtype2howto,
	xcoff_reloc_type_lookup, xcoff_slurp_armap, xcoff_archive_p,
	xcoff_read_ar_hdr, xcoff_openr_next_archived_file, xcoff_write_armap,
	xcoff_write_archive_contents): No longer static, and prefix with _bfd_.
	(NO_COFF_SYMBOLS): Define.
	(xcoff64_swap_sym_in, xcoff64_swap_sym_out, xcoff64_swap_aux_in,
	xcoff64_swap_aux_out): New functions; handle xcoff symbol tables
	internally.
	(MINUS_ONE): New macro.
	(xcoff_howto_tabl, xcoff_reloc_type_lookup): Add 64 bit POS
	relocation.
	(coff_SWAP_sym_in, coff_SWAP_sym_out, coff_SWAP_aux_in,
	coff_SWAP_aux_out): Map to the new functions.
	* coff64-rs6000.c: New file.
	* libcoff.h (bfd_coff_backend_data): Add new fields
	_bfd_coff_force_symnames_in_strings and
	_bfd_coff_debug_string_prefix_length.
	(bfd_coff_force_symnames_in_strings,
	bfd_coff_debug_string_prefix_length): New macros for above fields.
	* coffcode.h (coff_set_arch_mach_hook): Handle XCOFF64 magic.
	Set machine to 620 for XCOFF64.  Use bfd_coff_swap_sym_in instead
	of using coff_swap_sym_in directly.
	(FORCE_SYMNAMES_IN_STRINGS): New macro, defined for XCOFF64.
	(coff_set_flags) Set magic for XCOFF64.
	(coff_compute_section_file_positions): Add symbol name length to
	string section length if bfd_coff_debug_string_prefix_length is
	true.
	(coff_write_object_contents): Don't do reloc overflow for XCOFF64.
	(coff_slurp_line_table): Use bfd_coff_swap_lineno_in instead of
	using coff_swap_lineno_in directly.
	(bfd_coff_backend_data): Add _bfd_coff_force_symnames_in_strings
	and _bfd_coff_debug_string_prefix_length fields.
	* coffgen.c (coff_fix_symbol_name, coff_write_symbols): Force
	symbol names into strings table when
	bfd_coff_force_symnames_in_strings is true.
	* coffswap.h (MAX_SCNHDR_NRELOC, MAX_SCNHDR_NLNNO, GET_RELOC_VADDR,
	SET_RELOC_VADDR): New macros.
	(coff_swap_reloc_in, coff_swap_reloc_out): Use above macros.
	(coff_swap_aux_in, coff_swap_aux_out): Remove RS6000COFF_C
	code.
	(coff_swap_aouthdr_in, coff_swap_aouthdr_out): Handle XCOFF64
	changes within RS6000COFF_C specific code.
	(coff_swap_scnhdr_out): Use PUT_SCNHDR_NLNNO, PUT_SCNHDR_NRELOC,
	MAX_SCNHDR_NRELOC, and MAX_SCNHDR_NLNNO.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Extend existing hack on target name.
	* xcofflink.c (XCOFF_XVECP): Extend existing hack on
	target name.
	* coff-tic54x.c (ticof): Keep up to date with new fields
	in bfd_coff_backend_data.
	* config.bfd: Add bfd_powerpc_64_arch to targ_arch and define
	targ_selvecs to include rs6000coff64_vec for rs6000.
	* configure.in: Add rs6000coff64_vec case.
 	* cpu-powerpc.c: New bfd_arch_info_type.

	gas:
	* as.c (parse_args): Allow md_parse_option to override -a listing
	option.
	* config/obj-coff.c (add_lineno): Change type of offset parameter
	from "int" to "bfd_vma."
	* config/tc-ppc.c (md_pseudo_table): Add "llong" and "machine."
	(ppc_mach, ppc_subseg_align, ppc_target_format): New.
	(ppc_change_csect): Align correctly for XCOFF64.
	(ppc_machine): New function, which discards "ppc_machine" line.
	(ppc_tc): Cons for 8 when code is 64 bit.
	(md_apply_fix3): Don't check operand->insert.  Handle 64 bit
	relocations.
	(md_parse_option): Handle -a64 and -a32.
	(ppc_xcoff64): New.
	* config/tc-ppc.h (TARGET_MACH): Define.
	(TARGET_FORMAT): Move to function.
	(SUB_SEGMENT_ALIGN): Use ppc_subseg_align.

	include:
	* include/coff/rs6k64.h: New file.

	opcodes:
	* configure.in: Add bfd_powerpc_64_arch.
	* disassemble.c (disassembler): Use print_insn_big_powerpc for
	64 bit code.
@
text
@d349 1
a349 1
     char *filename;
d4585 1
d4593 6
d4604 2
d4614 1
d4616 3
d4622 2
@


1.22
log
@2000-02-22  Alexandre Oliva  <oliva@@lsd.ic.unicamp.br>

	* config/obj-coff.c (add_lineno): Accept non-positive lineno with
	warning, and bump it to 1.
@
text
@d432 1
a432 1
     int offset;
@


1.22.2.1
log
@Merge from mainline
@
text
@d216 1
a216 1
#ifdef BFD_ASSEMBLER
@


1.21
log
@octets vs bytes changes for GAS
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d444 2
a445 2
      as_bad (_("Line numbers must be positive integers\n"));
      return;
@


1.20
log
@This set of patches add support for aout emulation on the x86
assembler.  ie. You will be able to do "as --em=i386aout" on an x86
linux-elf assembler to generate aout format object files, rather than
using a separate assembler.  The aout emulation is enabled by giving
"--enable-targets=i386-linuxaout" to configure.
Oh yeah, there's a couple of fixes too.  Error messages shouldn't be
passed to printf in the format arg just in case someone puts a `%' in
the message.
@
text
@d1272 1
a1272 1
	    lptr->l.u.offset += lptr->frag->fr_address;
d1456 1
d1459 4
a1462 2
     rounded up to multiples of the corresponding section alignments.
     Seems kinda silly to me, but that's the way it is.  */
d1464 2
a1465 1
  mask = ((bfd_vma) 1 << (bfd_vma) sec->alignment_power) - 1;
d1471 1
d1476 1
d1481 1
@


1.19
log
@	* write.c (write_relocs): Call SET_SECTION_RELOCS if it is
	defined.
	* config/obj-coff.h (SET_SECTION_RELOCS): Define.
	* doc/internals.texi (Object format backend): Document
	SET_SECTION_RELOCS.
@
text
@d4530 1
a4530 1
const pseudo_typeS obj_pseudo_table[] =
d4571 1
a4571 1
};				/* obj_pseudo_table */
d4575 2
a4577 3
static int coff_sec_sym_ok_for_reloc PARAMS ((asection *));

/* Support for a COFF emulation.  */
d4582 1
a4582 8
  pop_insert (obj_pseudo_table);
}

static int
coff_sec_sym_ok_for_reloc (sec)
     asection *sec ATTRIBUTE_UNUSED;
{
  return 0;
d4588 2
a4589 2
  0,
  1,
d4591 1
a4591 1
  0,
d4593 10
a4602 14
  0, 0,
  0, 0,
  0,
#if 0
  obj_generate_asm_lineno,
#else
  0,
#endif
#if 0
  obj_stab,
#else
  0,
#endif
  coff_sec_sym_ok_for_reloc,
d4604 1
a4604 5
#if 0
  obj_set_ext,
#else
  0,
#endif
d4606 1
a4606 1
  coff_obj_symbol_new_hook,
@


1.18
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/obj-coff.c (obj_coff_ident): Add BFD_ASSEMBLER version.
	(obj_pseudo_table): Always handle ".ident" with obj-coff_ident.
@
text
@d1317 2
@


1.17
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/obj-coff.c (coff_frob_symbol): Prohibit weak common
	symbols.
@
text
@d45 1
d556 29
a1658 1
static void obj_coff_ident PARAMS ((int));
d4553 1
a4558 1
  {"ident", obj_coff_ident, 0},
a4560 1
  {"ident", s_ignore, 0},	/* we don't yet handle this. */
@


1.16
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/obj-coff.c (obj_coff_endef): Don't merge labels, or
	symbols which do not have a constant value, or tags with
	non-tags.  Remove the symbol from the list before adding it at the
	end.
@
text
@d1172 5
@


1.15
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/obj-coff.c (obj_coff_endef) [BFD_ASSEMBLER]: Handle .ef
	C_FCN symbol differently if TE_PE.
	(obj_coff_line) [BFD_ASSEMBLER]: Always use the line number which
	appears in the pseudo-op, rather coff_line_base which is only set
	for a .bf symbol.
@
text
@d730 4
a733 1
     SEG_ABSOLUTE or untagged SEG_DEBUG it never merges. */
d748 1
d754 4
a757 1
      || (symbolP = symbol_find_base (S_GET_NAME (def_symbol_in_progress), DO_NOT_STRIP)) == NULL)
d759 1
d761 5
a765 2
	symbol_append (def_symbol_in_progress, symbol_lastP, &symbol_rootP,
		       &symbol_lastP);
@


1.14
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/obj-coff.c (obj_coff_loc): New static function.
	(obj_pseudo_table): Add "loc".
@
text
@d662 24
a685 8
	if (name[1] == 'b' && name[2] == 'f')
	  {
	    if (! in_function ())
	      as_warn (_("`%s' symbol without preceding function"), name);
/*	    SA_SET_SYM_LNNO (def_symbol_in_progress, 12345);*/
	    /* Will need relocating */
	    SF_SET_PROCESS (def_symbol_in_progress);
	    clear_function ();
d875 1
a875 1
  SA_SET_SYM_LNNO (def_symbol_in_progress, coff_line_base);
d885 1
a885 1
	listing_source_line ((unsigned int) coff_line_base);
@


1.13
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/obj-coff.c (add_lineno): Check that the line number is
	positive.
@
text
@d45 3
d506 49
d4474 3
@


1.12
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* expr.c (expr): Change first parameter to int.
	* config/obj-coff.c: Add declarations for static functions.
	(coff_frob_symbol): Use SYM_AUXENT.
	* config/tc-i386.h (flag_16bit_code): Don't declare.
@
text
@d437 6
@


1.11
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/obj-coff.c (obj_coff_section): Default to setting
	SEC_LOAD.  Don't set SEC_DATA for 'w' modifier.
@
text
@d35 13
a48 1

d349 2
d945 6
d952 2
a953 1
      /* Otherwise, it is the name of a non debug symbol and its value will be calculated later. */
d1061 1
a1061 2
	      auxp =
		&coffsymbol (symbol_get_bfdsym (symp))->native[1].u.auxent;
d2632 5
a2636 6
	  /* FIXME: gcc can generate address expressions
	     here in unusual cases (search for "obscure"
	     in sdbout.c).  We just ignore the offset
	     here, thus generating incorrect debugging
	     information.  We ignore the rest of the
	     line just below.  */
d4451 3
@


1.10
log
@	* config/obj-coff.c: Add ATTRIBUTE_UNUSED as needed for
	BFD_ASSEMBLER code.
@
text
@d1236 1
a1236 1
  flags = SEC_NO_FLAGS;
d1254 3
a1256 3
		case 'd':
		case 'w': flags |= SEC_DATA; flags &=~ SEC_READONLY; break;
		case 'x': flags |= SEC_CODE; break;
@


1.9
log
@
Enable --emulation={i386coff,i386elf} for i386 gas.
@
text
@d504 1
a504 1
     int what;
d551 1
a551 1
     int ignore;
d731 1
a731 1
     int ignore;
d771 1
a771 1
     int ignore;
d804 1
a804 1
     int ignore;
d820 1
a820 1
     int ignore;
d835 1
a835 1
     int ignore;
d872 1
a872 1
     int ignore;
d894 1
a894 1
     int ignore;
d1141 1
a1141 1
     bfd *abfd;
d1143 1
a1143 1
     PTR x;
d1207 1
a1207 1
     int ignore;
d4443 1
a4443 1
     asection *sec;
@


1.8
log
@	* doc/as.texinfo (Section): Document 's' flag for COFF version.

1999-08-08  Mumit Khan  <khan@@xraylith.wisc.edu>

	* config/obj-coff.c (obj_coff_section): Handle 's' (shared)
	section flag.
@
text
@a4447 6
static void
no_func ()
{
  abort ();
}

d4454 1
a4454 1
  no_func,
d4462 1
a4462 1
  no_func,
d4467 1
a4467 1
  no_func,
d4474 1
a4474 1
  no_func,
@


1.7
log
@	* config/obj-coff.c (coff_frob_symbol): Always update set_end with
	next_set_end even if the end symbol is being discarded.

	* gasp.c: Add ATTRIBUTE_UNUSED as needed for non-BFD_ASSEMBLER.
	* output-file.c, symbols.c, config/tc-i386.c: Likewise.
	* config/obj-coff.c: Likewise.
	(seg_info_type): Remove.
	(seg_info_off_by_4): Change to array of segT.
	(s_get_segment): Adjust accordingly.
	(obj_pseudo_table): Fully initialize sentinel entry.
@
text
@d1200 1
d1258 1
@


1.6
log
@1999-06-26  Mumit Khan  <khan@@xraylith.wisc.edu>
	* config/obj-coff.c (obj_coff_section): Mark writable sections as
	data.
@
text
@d174 1
a174 1
     int ignore;
d186 1
a186 1
     int ignore;
d1094 7
a1100 3
  if (next_set_end != NULL
      && ! *punt)
    set_end = next_set_end;
d1441 4
a1444 3
/* This vector is used to turn an internal segment into a section #
   suitable for insertion into a coff symbol table
 */
d1520 1
a1520 7
/* Section stuff

   We allow more than just the standard 3 sections, infact, we allow
   40 sections, (though the usual three have to be there).

   This structure performs the mappings for us:
*/
d1522 31
a1552 32

typedef struct
{
  segT seg_t;
  int i;
} seg_info_type;

static const seg_info_type seg_info_off_by_4[] =
{
 {SEG_PTV,  },
 {SEG_NTV,  },
 {SEG_DEBUG, },
 {SEG_ABSOLUTE,  },
 {SEG_UNKNOWN,	 },
 {SEG_E0}, {SEG_E1}, {SEG_E2}, {SEG_E3}, {SEG_E4},
 {SEG_E5}, {SEG_E6}, {SEG_E7}, {SEG_E8}, {SEG_E9},
 {SEG_E10},{SEG_E11},{SEG_E12},{SEG_E13},{SEG_E14},
 {SEG_E15},{SEG_E16},{SEG_E17},{SEG_E18},{SEG_E19},
 {SEG_E20},{SEG_E21},{SEG_E22},{SEG_E23},{SEG_E24},
 {SEG_E25},{SEG_E26},{SEG_E27},{SEG_E28},{SEG_E29},
 {SEG_E30},{SEG_E31},{SEG_E32},{SEG_E33},{SEG_E34},
 {SEG_E35},{SEG_E36},{SEG_E37},{SEG_E38},{SEG_E39},
 {(segT)40},
 {(segT)41},
 {(segT)42},
 {(segT)43},
 {(segT)44},
 {(segT)45},
 {(segT)0},
 {(segT)0},
 {(segT)0},
 {SEG_REGISTER}
a1554 2


d1575 1
a1575 1
  return SEG_INFO_FROM_SECTION_NUMBER (x->sy_symbol.ost_entry.n_scnum).seg_t;
d1582 1
a1582 1
     bfd * abfd;
d1846 1
a1846 1
     object_headers *h;
d2161 1
a2161 1
     int what;
d2216 1
a2216 1
     int ignore;
d2399 1
a2399 1
     int ignore;
d2439 1
a2439 1
     int ignore;
d2484 1
a2484 1
     int ignore;
d2500 1
a2500 1
     int ignore;
d2515 1
a2515 1
     int ignore;
d2551 1
a2551 1
     int ignore;
d2573 1
a2573 1
     int ignore;
d3000 1
a3000 1
     bfd * abfd;
d3459 1
a3459 1
     int ignore;
d3540 1
a3540 1
     int ignore;
d3548 1
a3548 1
     int ignore;
d3558 1
a3558 1
     int ignore;
d3817 1
a3817 1
     int ignore;
d4426 1
a4426 1
  {NULL}			/* end sentinel */
@


1.5
log
@	* config/tc-ppc.c: Update for symbol handling changes.
	* config/obj-coff.c: Likewise.
@
text
@d1250 1
a1250 1
		case 'w': flags &=~ SEC_READONLY; break;
@


1.4
log
@	* subsegs.c (subseg_text_p): New function.
	* as.h (subseg_text_p): Declare.
	* read.c (do_align): Use subseg_text_p to set the default fill.
	* write.c (subsegs_finish): Likewise.
	* config/obj-coff.c (write_object_file): Likewise.
	* config/tc-i386.h (md_maybe_text): Don't define.
	(md_do_align): Use subseg_text_p to set the default fill.
	* config/tc-m32r.c (m32r_do_align): Likewise.
	* config/tc-sh.c (sh_do_align): Likewise.
	* config/tc-sparc.h (md_do_align): Likewise.
@
text
@d1075 1
a1075 1
  if (! symp->sy_used_in_reloc
d1078 1
a1078 1
	      && ! symp->sy_tc.output
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d3238 1
d3246 3
a3248 1
      frag_align (SUB_SEGMENT_ALIGN (now_seg), NOP_OPCODE, 0);
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 1998
d252 2
a253 2
  entry = &coffsymbol (sym->bsym)->native[1];
  p = coffsymbol (val->bsym)->native;
d265 2
a266 2
  entry = &coffsymbol (sym->bsym)->native[1];
  p = coffsymbol (val->bsym)->native;
d275 1
a275 1
  return coffsymbol (sym->bsym)->native->u.syment.n_type;
d283 1
a283 1
  coffsymbol (sym->bsym)->native->u.syment.n_type = val;
d291 1
a291 1
  return coffsymbol (sym->bsym)->native->u.syment.n_sclass;
d299 1
a299 1
  coffsymbol (sym->bsym)->native->u.syment.n_sclass = val;
d342 1
a342 1
  symbolP->bsym->flags = BSF_DEBUGGING;
d388 1
a388 1
  coffsymbol (symbolP->bsym)->native = (combined_entry_type *) s;
d437 2
a438 1
      coffsymbol (current_lineno_sym->bsym)->lineno = (alent *) line_nos;
d536 1
a536 1
  def_symbol_in_progress->sy_frag = &zero_address_frag;
d589 1
a589 1
	name = bfd_asymbol_name (def_symbol_in_progress->bsym);
d913 1
a913 1
	  def_symbol_in_progress->sy_frag = frag_now;
d919 7
a925 5
	  def_symbol_in_progress->sy_value.X_op = O_symbol;
	  def_symbol_in_progress->sy_value.X_add_symbol =
	    symbol_find_or_make (symbol_name);
	  def_symbol_in_progress->sy_value.X_op_symbol = NULL;
	  def_symbol_in_progress->sy_value.X_add_number = 0;
d1040 2
a1041 1
	      auxp = &coffsymbol (symp->bsym)->native[1].u.auxent;
d1062 1
a1062 1
	symp->bsym->flags |= BSF_FUNCTION;
d1076 1
a1076 1
      && ((symp->bsym->flags & BSF_SECTION_SYM) != 0
d1085 1
a1085 1
      && ((symp->bsym->flags & BSF_NOT_AT_END) != 0
d1107 1
a1107 1
  if (coffsymbol (symp->bsym)->lineno)
d1113 1
a1113 1
      lptr = (struct line_no *) coffsymbol (symp->bsym)->lineno;
d1116 1
a1116 1
      lptr = (struct line_no *) coffsymbol (symp->bsym)->lineno;
d1122 1
a1122 1
      coffsymbol (symp->bsym)->lineno = l;
@


1.1
log
@Initial revision
@
text
@d4261 6
a4302 7
      /* Once this fix has been applied, we don't have to output
	 anything nothing more need be done.  */
#ifdef MD_APPLY_FIX3
      md_apply_fix3 (fixP, (valueT *) &add_number, this_segment_type);
#else
      md_apply_fix (fixP, add_number);
#endif
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

