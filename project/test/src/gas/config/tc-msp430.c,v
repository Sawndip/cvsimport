head	1.39;
access;
symbols
	binutils-2_24-branch:1.38.0.2
	binutils-2_24-branchpoint:1.38
	binutils-2_21_1:1.33
	binutils-2_23_2:1.34
	binutils-2_23_1:1.34
	binutils-2_23:1.34
	binutils-2_23-branch:1.34.0.2
	binutils-2_23-branchpoint:1.34
	binutils-2_22_branch:1.33.0.6
	binutils-2_22:1.33
	binutils-2_22-branch:1.33.0.4
	binutils-2_22-branchpoint:1.33
	binutils-2_21:1.33
	binutils-2_21-branch:1.33.0.2
	binutils-2_21-branchpoint:1.33
	binutils-2_20_1:1.32
	binutils-2_20:1.32
	binutils-arc-20081103-branch:1.30.0.8
	binutils-arc-20081103-branchpoint:1.30
	binutils-2_20-branch:1.32.0.2
	binutils-2_20-branchpoint:1.32
	dje-cgen-play1-branch:1.30.0.6
	dje-cgen-play1-branchpoint:1.30
	arc-20081103-branch:1.30.0.4
	arc-20081103-branchpoint:1.30
	binutils-2_19_1:1.30
	binutils-2_19:1.30
	binutils-2_19-branch:1.30.0.2
	binutils-2_19-branchpoint:1.30
	binutils-2_18:1.28
	binutils-2_18-branch:1.28.0.2
	binutils-2_18-branchpoint:1.28
	binutils-csl-coldfire-4_1-32:1.22
	binutils-csl-sourcerygxx-4_1-32:1.22
	binutils-csl-innovasic-fido-3_4_4-33:1.22
	binutils-csl-sourcerygxx-3_4_4-32:1.15
	binutils-csl-coldfire-4_1-30:1.22
	binutils-csl-sourcerygxx-4_1-30:1.22
	binutils-csl-coldfire-4_1-28:1.22
	binutils-csl-sourcerygxx-4_1-29:1.22
	binutils-csl-sourcerygxx-4_1-28:1.22
	binutils-csl-arm-2006q3-27:1.22
	binutils-csl-sourcerygxx-4_1-27:1.22
	binutils-csl-arm-2006q3-26:1.22
	binutils-csl-sourcerygxx-4_1-26:1.22
	binutils-csl-sourcerygxx-4_1-25:1.22
	binutils-csl-sourcerygxx-4_1-24:1.22
	binutils-csl-sourcerygxx-4_1-23:1.22
	binutils-csl-sourcerygxx-4_1-21:1.22
	binutils-csl-arm-2006q3-21:1.22
	binutils-csl-sourcerygxx-4_1-22:1.22
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.22
	binutils-csl-sourcerygxx-4_1-20:1.22
	binutils-csl-arm-2006q3-19:1.22
	binutils-csl-sourcerygxx-4_1-19:1.22
	binutils-csl-sourcerygxx-4_1-18:1.22
	binutils-csl-renesas-4_1-9:1.22
	binutils-csl-sourcerygxx-3_4_4-25:1.15
	binutils-csl-renesas-4_1-8:1.22
	binutils-csl-renesas-4_1-7:1.22
	binutils-csl-renesas-4_1-6:1.22
	binutils-csl-sourcerygxx-4_1-17:1.22
	binutils-csl-sourcerygxx-4_1-14:1.22
	binutils-csl-sourcerygxx-4_1-15:1.22
	binutils-csl-sourcerygxx-4_1-13:1.22
	binutils-2_17:1.22
	binutils-csl-sourcerygxx-4_1-12:1.22
	binutils-csl-sourcerygxx-3_4_4-21:1.22
	binutils-csl-wrs-linux-3_4_4-24:1.15
	binutils-csl-wrs-linux-3_4_4-23:1.15
	binutils-csl-sourcerygxx-4_1-9:1.22
	binutils-csl-sourcerygxx-4_1-8:1.22
	binutils-csl-sourcerygxx-4_1-7:1.22
	binutils-csl-arm-2006q1-6:1.22
	binutils-csl-sourcerygxx-4_1-6:1.22
	binutils-csl-wrs-linux-3_4_4-22:1.15
	binutils-csl-coldfire-4_1-11:1.22
	binutils-csl-sourcerygxx-3_4_4-19:1.22
	binutils-csl-coldfire-4_1-10:1.22
	binutils-csl-sourcerygxx-4_1-5:1.22
	binutils-csl-sourcerygxx-4_1-4:1.22
	binutils-csl-wrs-linux-3_4_4-21:1.15
	binutils-csl-morpho-4_1-4:1.22
	binutils-csl-sourcerygxx-3_4_4-17:1.22
	binutils-csl-wrs-linux-3_4_4-20:1.15
	binutils-2_17-branch:1.22.0.4
	binutils-2_17-branchpoint:1.22
	binutils-csl-2_17-branch:1.22.0.2
	binutils-csl-2_17-branchpoint:1.22
	binutils-csl-gxxpro-3_4-branch:1.15.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.15
	binutils-2_16_1:1.15
	binutils-csl-arm-2005q1b:1.15
	binutils-2_16:1.15
	binutils-csl-arm-2005q1a:1.15
	binutils-csl-arm-2005q1-branch:1.15.0.4
	binutils-csl-arm-2005q1-branchpoint:1.15
	binutils-2_16-branch:1.15.0.2
	binutils-2_16-branchpoint:1.15
	csl-arm-2004-q3d:1.11
	csl-arm-2004-q3:1.11
	binutils-2_15:1.9
	binutils-2_15-branchpoint:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	binutils-2_15-branch:1.9.0.6
	cagney_bfdfile-20040213-branch:1.9.0.4
	cagney_bfdfile-20040213-branchpoint:1.9
	cagney_bigcore-20040122-branch:1.9.0.2
	cagney_bigcore-20040122-branchpoint:1.9
	csl-arm-2003-q4:1.9
	binutils-2_14:1.3
	binutils-2_14-branch:1.3.0.2
	binutils-2_14-branchpoint:1.3
	binutils_latest_snapshot:1.39;
locks; strict;
comment	@ * @;


1.39
date	2013.10.08.08.06.34;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2013.09.18.07.50.34;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2013.06.25.08.21.43;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2013.05.16.13.19.40;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2013.05.02.21.06.13;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2012.05.17.15.13.16;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.11.13.48.39;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.28.10.02.37;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.01.14.12.18;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.08.17.08.34;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.09.08.46.19;	author diwil;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.01.12.41.25;	author diwil;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.12.11.54.23;	author diwil;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.08.17.08.04;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.05.09.13.02;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.23.12.28.05;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.31.23.18.32;	author bje;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.04.10.20.36;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.19.12.28.03;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.25.12.54.09;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.26.12.29.02;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.17.11.27.39;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.08.10.14.51;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.01.03.48.55;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.07.08.58.33;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.04.16.34.40;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.28.11.02.40;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.30.19.25.07;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.39
log
@	* config/tc-msp430.c (msp430_operands): Accept "<foo>.a" as an alias
	for "<foo>a".  Issue error messages for unrecognised or corrrupt
	size extensions.

	* gas/msp430/bad.s: New test: Checks erroneous size extensions.
	* gas/msp430/bad.d: New test command file.
	* gas/msp430/bad.l: New file: Expected error messages.
	* gas/msp430/msp430.exp: Run the new test.
	* gas/msp430/msp430x.s: Add "<foo>.a" aliases of "<foo>a"
	instructions.
	* gas/msp430/msp430x.d: Update expected disassembly.
@
text
@/* tc-msp430.c -- Assembler code for the Texas Instruments MSP430

  Copyright (C) 2002-2013 Free Software Foundation, Inc.
  Contributed by Dmitry Diky <diwil@@mail.ru>

  This file is part of GAS, the GNU Assembler.

  GAS is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3, or (at your option)
  any later version.

  GAS is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with GAS; see the file COPYING.  If not, write to
  the Free Software Foundation, 51 Franklin Street - Fifth Floor,
  Boston, MA 02110-1301, USA.  */

#include "as.h"
#include <limits.h>
#define PUSH_1X_WORKAROUND
#include "subsegs.h"
#include "opcode/msp430.h"
#include "safe-ctype.h"
#include "dwarf2dbg.h"
#include "elf/msp430.h"

/* We will disable polymorphs by default because it is dangerous.
   The potential problem here is the following: assume we got the
   following code:

	jump .l1
	nop
	jump  subroutine	; external symbol
      .l1:
	nop
	ret

   In case of assembly time relaxation we'll get:
	0: jmp .l1 <.text +0x08> (reloc deleted)
	2: nop
	4: br subroutine
    .l1:
	8: nop
	10: ret

   If the 'subroutine' is within +-1024 bytes range then linker
   will produce:
	0: jmp .text +0x08
	2: nop
	4: jmp subroutine
	.l1:
	6: nop
	8: ret	; 'jmp .text +0x08' will land here. WRONG!!!

   The workaround is the following:
   1. Declare global var enable_polymorphs which set to 1 via option -mp.
   2. Declare global var enable_relax	which set to 1 via option -mQ.

   If polymorphs are enabled, and relax isn't, treat all jumps as long jumps,
   do not delete any relocs and leave them for linker.

   If relax is enabled, relax at assembly time and kill relocs as necessary.  */

int msp430_enable_relax;
int msp430_enable_polys;

/*  Set linkrelax here to avoid fixups in most sections.  */
int linkrelax = 1;

/* GCC uses the some condition codes which we'll
   implement as new polymorph instructions.

   COND	EXPL	   SHORT JUMP	LONG JUMP
   ===============================================
   eq	==	   jeq 		jne +4; br lab
   ne	!=	   jne 		jeq +4; br lab

   ltn honours no-overflow flag
   ltn	<	   jn 		jn +2;  jmp +4; br lab

   lt	<	   jl 		jge +4;	br lab
   ltu	<	   jlo 		lhs +4; br lab
   le	<= see below
   leu	<= see below

   gt	>  see below
   gtu	>  see below
   ge	>=	   jge 		jl +4; br lab
   geu	>=	   jhs 		jlo +4; br lab
   ===============================================

   Therefore, new opcodes are (BranchEQ -> beq; and so on...)
   beq,bne,blt,bltn,bltu,bge,bgeu
   'u' means unsigned compares

   Also, we add 'jump' instruction:
   jump	UNCOND	-> jmp		br lab

   They will have fmt == 4, and insn_opnumb == number of instruction.  */

struct rcodes_s
{
  char * name;
  int    index;	/* Corresponding insn_opnumb.  */
  int    sop;	/* Opcode if jump length is short.  */
  long   lpos;	/* Label position.  */
  long   lop0;	/* Opcode 1 _word_ (16 bits).  */
  long   lop1;	/* Opcode second word.  */
  long   lop2;	/* Opcode third word.  */
};

#define MSP430_RLC(n,i,sop,o1) \
  {#n, i, sop, 2, (o1 + 2), 0x4010, 0}

static struct rcodes_s msp430_rcodes[] =
{
  MSP430_RLC (beq,  0, 0x2400, 0x2000),
  MSP430_RLC (bne,  1, 0x2000, 0x2400),
  MSP430_RLC (blt,  2, 0x3800, 0x3400),
  MSP430_RLC (bltu, 3, 0x2800, 0x2c00),
  MSP430_RLC (bge,  4, 0x3400, 0x3800),
  MSP430_RLC (bgeu, 5, 0x2c00, 0x2800),
  {"bltn",          6, 0x3000, 3, 0x3000 + 1, 0x3c00 + 2,0x4010},
  {"jump",          7, 0x3c00, 1, 0x4010, 0, 0},
  {0,0,0,0,0,0,0}
};

#undef  MSP430_RLC
#define MSP430_RLC(n,i,sop,o1) \
  {#n, i, sop, 2, (o1 + 2), 0x0030, 0}

static struct rcodes_s msp430x_rcodes[] =
{
  MSP430_RLC (beq,  0, 0x2400,    0x2000),
  MSP430_RLC (bne,  1, 0x2000,    0x2400),
  MSP430_RLC (blt,  2, 0x3800,    0x3400),
  MSP430_RLC (bltu, 3, 0x2800,    0x2c00),
  MSP430_RLC (bge,  4, 0x3400,    0x3800),
  MSP430_RLC (bgeu, 5, 0x2c00,    0x2800),
  {"bltn",          6, 0x3000, 3, 0x0030 + 1, 0x3c00 + 2, 0x3000},
  {"jump",          7, 0x3c00, 1, 0x0030,     0,          0},
  {0,0,0,0,0,0,0}
};
#undef MSP430_RLC

/* More difficult than above and they have format 5.

   COND	EXPL	SHORT			LONG
   =================================================================
   gt	>	jeq +2; jge label	jeq +6; jl  +4; br label
   gtu	>	jeq +2; jhs label	jeq +6; jlo +4; br label
   leu	<=	jeq label; jlo label	jeq +2; jhs +4; br label
   le	<=	jeq label; jl  label	jeq +2; jge +4; br label
   =================================================================  */

struct hcodes_s
{
  char * name;
  int    index;		/* Corresponding insn_opnumb.  */
  int    tlab;		/* Number of labels in short mode.  */
  int    op0;		/* Opcode for first word of short jump.  */
  int    op1;		/* Opcode for second word of short jump.  */
  int    lop0;		/* Opcodes for long jump mode.  */
  int    lop1;
  int    lop2;
};

static struct hcodes_s msp430_hcodes[] =
{
  {"bgt",  0, 1, 0x2401, 0x3400, 0x2403, 0x3802, 0x4010 },
  {"bgtu", 1, 1, 0x2401, 0x2c00, 0x2403, 0x2802, 0x4010 },
  {"bleu", 2, 2, 0x2400, 0x2800, 0x2401, 0x2c02, 0x4010 },
  {"ble",  3, 2, 0x2400, 0x3800, 0x2401, 0x3402, 0x4010 },
  {0,0,0,0,0,0,0,0}
};

static struct hcodes_s msp430x_hcodes[] =
{
  {"bgt",  0, 1, 0x2401, 0x3400, 0x2403, 0x3802, 0x0030 },
  {"bgtu", 1, 1, 0x2401, 0x2c00, 0x2403, 0x2802, 0x0030 },
  {"bleu", 2, 2, 0x2400, 0x2800, 0x2401, 0x2c02, 0x0030 },
  {"ble",  3, 2, 0x2400, 0x3800, 0x2401, 0x3402, 0x0030 },
  {0,0,0,0,0,0,0,0}
};

const char comment_chars[] = ";";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = "{";
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "dD";

/* Handle  long expressions.  */
extern LITTLENUM_TYPE generic_bignum[];

static struct hash_control *msp430_hash;

/* Relaxations.  */
#define STATE_UNCOND_BRANCH	1	/* jump */
#define STATE_NOOV_BRANCH	3	/* bltn */
#define STATE_SIMPLE_BRANCH	2	/* bne, beq, etc... */
#define STATE_EMUL_BRANCH	4

#define CNRL	2
#define CUBL	4
#define CNOL	8
#define CSBL	6
#define CEBL	4

/* Length.  */
#define STATE_BITS10	1	/* wild guess. short jump */
#define STATE_WORD	2	/* 2 bytes pc rel. addr. more */
#define STATE_UNDEF	3	/* cannot handle this yet. convert to word mode */

#define ENCODE_RELAX(what,length) (((what) << 2) + (length))
#define RELAX_STATE(s)            ((s) & 3)
#define RELAX_LEN(s)	          ((s) >> 2)
#define RELAX_NEXT(a,b)	          ENCODE_RELAX (a, b + 1)

relax_typeS md_relax_table[] =
{
  /* Unused.  */
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  /* Unconditional jump.  */
  {1, 1, 8, 5},
  {1024, -1024, CNRL, RELAX_NEXT (STATE_UNCOND_BRANCH, STATE_BITS10)},	/* state 10 bits displ */
  {0, 0, CUBL, RELAX_NEXT (STATE_UNCOND_BRANCH, STATE_WORD)},		/* state word */
  {1, 1, CUBL, 0},							/* state undef */

  /* Simple branches.  */
  {0, 0, 8, 9},
  {1024, -1024, CNRL, RELAX_NEXT (STATE_SIMPLE_BRANCH, STATE_BITS10)},	/* state 10 bits displ */
  {0, 0, CSBL, RELAX_NEXT (STATE_SIMPLE_BRANCH, STATE_WORD)},		/* state word */
  {1, 1, CSBL, 0},

  /* blt no overflow branch.  */
  {1, 1, 8, 13},
  {1024, -1024, CNRL, RELAX_NEXT (STATE_NOOV_BRANCH, STATE_BITS10)},	/* state 10 bits displ */
  {0, 0, CNOL, RELAX_NEXT (STATE_NOOV_BRANCH, STATE_WORD)},		/* state word */
  {1, 1, CNOL, 0},

  /* Emulated branches.  */
  {1, 1, 8, 17},
  {1020, -1020, CEBL, RELAX_NEXT (STATE_EMUL_BRANCH, STATE_BITS10)},	/* state 10 bits displ */
  {0, 0, CNOL, RELAX_NEXT (STATE_EMUL_BRANCH, STATE_WORD)},		/* state word */
  {1, 1, CNOL, 0}
};


#define MAX_OP_LEN	256

typedef enum msp_isa
{
  MSP_ISA_430,
  MSP_ISA_430X,
  MSP_ISA_430Xv2
} msp_isa;

struct mcu_type_s
{
  char *  name;
  msp_isa isa;
};

static struct mcu_type_s mcu_types[] =
{
  {"msp430afe221", MSP_ISA_430},
  {"msp430afe222", MSP_ISA_430},
  {"msp430afe223", MSP_ISA_430},
  {"msp430afe231", MSP_ISA_430},
  {"msp430afe232", MSP_ISA_430},
  {"msp430afe233", MSP_ISA_430},
  {"msp430afe251", MSP_ISA_430},
  {"msp430afe252", MSP_ISA_430},
  {"msp430afe253", MSP_ISA_430},
  {"msp430c091",   MSP_ISA_430},
  {"msp430c092",   MSP_ISA_430},
  {"msp430c111",   MSP_ISA_430},
  {"msp430c1111",  MSP_ISA_430},
  {"msp430c112",   MSP_ISA_430},
  {"msp430c1121",  MSP_ISA_430},
  {"msp430e112",   MSP_ISA_430},
  {"msp430c1331", MSP_ISA_430},
  {"msp430c1351", MSP_ISA_430},
  {"msp430c311s", MSP_ISA_430},
  {"msp430c312",  MSP_ISA_430},
  {"msp430c313",  MSP_ISA_430},
  {"msp430c314",  MSP_ISA_430},
  {"msp430c315", MSP_ISA_430},
  {"msp430c323", MSP_ISA_430},
  {"msp430c325", MSP_ISA_430},
  {"msp430c336", MSP_ISA_430},
  {"msp430c337", MSP_ISA_430},
  {"msp430c412", MSP_ISA_430},
  {"msp430c413", MSP_ISA_430},
  {"msp430e313", MSP_ISA_430},
  {"msp430e315", MSP_ISA_430},
  {"msp430e325", MSP_ISA_430},
  {"msp430e337", MSP_ISA_430},
  {"msp430f110", MSP_ISA_430},
  {"msp430f1101", MSP_ISA_430},
  {"msp430f1101a", MSP_ISA_430},
  {"msp430f1111", MSP_ISA_430},
  {"msp430f1111a", MSP_ISA_430},
  {"msp430f112", MSP_ISA_430},
  {"msp430f1121", MSP_ISA_430},
  {"msp430f1121a", MSP_ISA_430},
  {"msp430f1122", MSP_ISA_430},
  {"msp430f1132", MSP_ISA_430},
  {"msp430f122", MSP_ISA_430},
  {"msp430f1222", MSP_ISA_430},
  {"msp430f123", MSP_ISA_430},
  {"msp430f1232", MSP_ISA_430},
  {"msp430f133", MSP_ISA_430},
  {"msp430f135", MSP_ISA_430},
  {"msp430f147", MSP_ISA_430},
  {"msp430f1471", MSP_ISA_430},
  {"msp430f148", MSP_ISA_430},
  {"msp430f1481", MSP_ISA_430},
  {"msp430f149", MSP_ISA_430},
  {"msp430f1491", MSP_ISA_430},
  {"msp430f155", MSP_ISA_430},
  {"msp430f156", MSP_ISA_430},
  {"msp430f157", MSP_ISA_430},
  {"msp430f1610", MSP_ISA_430},
  {"msp430f1611", MSP_ISA_430},
  {"msp430f1612", MSP_ISA_430},
  {"msp430f167", MSP_ISA_430},
  {"msp430f168", MSP_ISA_430},
  {"msp430f169", MSP_ISA_430},
  {"msp430f2001", MSP_ISA_430},
  {"msp430f2002", MSP_ISA_430},
  {"msp430f2003", MSP_ISA_430},
  {"msp430f2011", MSP_ISA_430},
  {"msp430f2012", MSP_ISA_430},
  {"msp430f2013", MSP_ISA_430},
  {"msp430f2101", MSP_ISA_430},
  {"msp430f2111", MSP_ISA_430},
  {"msp430f2112", MSP_ISA_430},
  {"msp430f2121", MSP_ISA_430},
  {"msp430f2122", MSP_ISA_430},
  {"msp430f2131", MSP_ISA_430},
  {"msp430f2132", MSP_ISA_430},
  {"msp430f2232", MSP_ISA_430},
  {"msp430f2234", MSP_ISA_430},
  {"msp430f2252", MSP_ISA_430},
  {"msp430f2254", MSP_ISA_430},
  {"msp430f2272", MSP_ISA_430},
  {"msp430f2274", MSP_ISA_430},
  {"msp430f233", MSP_ISA_430},
  {"msp430f2330", MSP_ISA_430},
  {"msp430f235", MSP_ISA_430},
  {"msp430f2350", MSP_ISA_430},
  {"msp430f2370", MSP_ISA_430},
  {"msp430f2410", MSP_ISA_430},
  {"msp430f247", MSP_ISA_430},
  {"msp430f2471", MSP_ISA_430},
  {"msp430f248", MSP_ISA_430},
  {"msp430f2481", MSP_ISA_430},
  {"msp430f249", MSP_ISA_430},
  {"msp430f2491", MSP_ISA_430},
  {"msp430f412", MSP_ISA_430},
  {"msp430f413", MSP_ISA_430},
  {"msp430f4132", MSP_ISA_430},
  {"msp430f415", MSP_ISA_430},
  {"msp430f4152", MSP_ISA_430},
  {"msp430f417", MSP_ISA_430},
  {"msp430f423", MSP_ISA_430},
  {"msp430f423a", MSP_ISA_430},
  {"msp430f425",  MSP_ISA_430},
  {"msp430f4250", MSP_ISA_430},
  {"msp430f425a", MSP_ISA_430},
  {"msp430f4260", MSP_ISA_430},
  {"msp430f427",  MSP_ISA_430},
  {"msp430f4270", MSP_ISA_430},
  {"msp430f427a", MSP_ISA_430},
  {"msp430f435", MSP_ISA_430},
  {"msp430f4351", MSP_ISA_430},
  {"msp430f436", MSP_ISA_430},
  {"msp430f4361", MSP_ISA_430},
  {"msp430f437", MSP_ISA_430},
  {"msp430f4371", MSP_ISA_430},
  {"msp430f438", MSP_ISA_430},
  {"msp430f439", MSP_ISA_430},
  {"msp430f447", MSP_ISA_430},
  {"msp430f448", MSP_ISA_430},
  {"msp430f4481", MSP_ISA_430},
  {"msp430f449", MSP_ISA_430},
  {"msp430f4491", MSP_ISA_430},
  {"msp430f477", MSP_ISA_430},
  {"msp430f478", MSP_ISA_430},
  {"msp430f4783", MSP_ISA_430},
  {"msp430f4784", MSP_ISA_430},
  {"msp430f479", MSP_ISA_430},
  {"msp430f4793", MSP_ISA_430},
  {"msp430f4794", MSP_ISA_430},
  {"msp430fe423", MSP_ISA_430},
  {"msp430fe4232", MSP_ISA_430},
  {"msp430fe423a", MSP_ISA_430},
  {"msp430fe4242", MSP_ISA_430},
  {"msp430fe425", MSP_ISA_430},
  {"msp430fe4252", MSP_ISA_430},
  {"msp430fe425a", MSP_ISA_430},
  {"msp430fe427", MSP_ISA_430},
  {"msp430fe4272", MSP_ISA_430},
  {"msp430fe427a", MSP_ISA_430},
  {"msp430fg4250", MSP_ISA_430},
  {"msp430fg4260", MSP_ISA_430},
  {"msp430fg4270", MSP_ISA_430},
  {"msp430fg437", MSP_ISA_430},
  {"msp430fg438", MSP_ISA_430},
  {"msp430fg439", MSP_ISA_430},
  {"msp430fg477", MSP_ISA_430},
  {"msp430fg478", MSP_ISA_430},
  {"msp430fg479", MSP_ISA_430},
  {"msp430fw423", MSP_ISA_430},
  {"msp430fw425", MSP_ISA_430},
  {"msp430fw427", MSP_ISA_430},
  {"msp430fw428", MSP_ISA_430},
  {"msp430fw429", MSP_ISA_430},
  {"msp430g2001", MSP_ISA_430},
  {"msp430g2101", MSP_ISA_430},
  {"msp430g2102", MSP_ISA_430},
  {"msp430g2111", MSP_ISA_430},
  {"msp430g2112", MSP_ISA_430},
  {"msp430g2113", MSP_ISA_430},
  {"msp430g2121", MSP_ISA_430},
  {"msp430g2131", MSP_ISA_430},
  {"msp430g2132", MSP_ISA_430},
  {"msp430g2152", MSP_ISA_430},
  {"msp430g2153", MSP_ISA_430},
  {"msp430g2201", MSP_ISA_430},
  {"msp430g2202", MSP_ISA_430},
  {"msp430g2203", MSP_ISA_430},
  {"msp430g2210", MSP_ISA_430},
  {"msp430g2211", MSP_ISA_430},
  {"msp430g2212", MSP_ISA_430},
  {"msp430g2213", MSP_ISA_430},
  {"msp430g2221", MSP_ISA_430},
  {"msp430g2230", MSP_ISA_430},
  {"msp430g2231", MSP_ISA_430},
  {"msp430g2232", MSP_ISA_430},
  {"msp430g2233", MSP_ISA_430},
  {"msp430g2252", MSP_ISA_430},
  {"msp430g2253", MSP_ISA_430},
  {"msp430g2302", MSP_ISA_430},
  {"msp430g2303", MSP_ISA_430},
  {"msp430g2312", MSP_ISA_430},
  {"msp430g2313", MSP_ISA_430},
  {"msp430g2332", MSP_ISA_430},
  {"msp430g2333", MSP_ISA_430},
  {"msp430g2352", MSP_ISA_430},
  {"msp430g2353", MSP_ISA_430},
  {"msp430g2402", MSP_ISA_430},
  {"msp430g2403", MSP_ISA_430},
  {"msp430g2412", MSP_ISA_430},
  {"msp430g2413", MSP_ISA_430},
  {"msp430g2432", MSP_ISA_430},
  {"msp430g2433", MSP_ISA_430},
  {"msp430g2444", MSP_ISA_430},
  {"msp430g2452", MSP_ISA_430},
  {"msp430g2453", MSP_ISA_430},
  {"msp430g2513", MSP_ISA_430},
  {"msp430g2533", MSP_ISA_430},
  {"msp430g2544", MSP_ISA_430},
  {"msp430g2553", MSP_ISA_430},
  {"msp430g2744", MSP_ISA_430},
  {"msp430g2755", MSP_ISA_430},
  {"msp430g2855", MSP_ISA_430},
  {"msp430g2955", MSP_ISA_430},
  {"msp430l092",  MSP_ISA_430},
  {"msp430p112",  MSP_ISA_430},
  {"msp430p313",  MSP_ISA_430},
  {"msp430p315",  MSP_ISA_430},
  {"msp430p315s", MSP_ISA_430},
  {"msp430p325",  MSP_ISA_430},
  {"msp430p337",  MSP_ISA_430},
  {"msp430tch5e", MSP_ISA_430},

  /* NB/ This section of the list should be kept in sync with the ones in:
       gcc/config/msp430/t-msp430
       gcc/config/msp430/msp430.c  */

  {"msp430cg4616", MSP_ISA_430X},
  {"msp430cg4617", MSP_ISA_430X},
  {"msp430cg4618", MSP_ISA_430X},
  {"msp430cg4619", MSP_ISA_430X},
  {"msp430f2416", MSP_ISA_430X},
  {"msp430f2417", MSP_ISA_430X},
  {"msp430f2418", MSP_ISA_430X},
  {"msp430f2419", MSP_ISA_430X},
  {"msp430f2616", MSP_ISA_430X},
  {"msp430f2617", MSP_ISA_430X},
  {"msp430f2618", MSP_ISA_430X},
  {"msp430f2619", MSP_ISA_430X},
  {"msp430f47126", MSP_ISA_430X},
  {"msp430f47127", MSP_ISA_430X},
  {"msp430f47163", MSP_ISA_430X},
  {"msp430f47173", MSP_ISA_430X},
  {"msp430f47183", MSP_ISA_430X},
  {"msp430f47193", MSP_ISA_430X},
  {"msp430f47166", MSP_ISA_430X},
  {"msp430f47176", MSP_ISA_430X},
  {"msp430f47186", MSP_ISA_430X},
  {"msp430f47196", MSP_ISA_430X},
  {"msp430f47167", MSP_ISA_430X},
  {"msp430f47177", MSP_ISA_430X},
  {"msp430f47187", MSP_ISA_430X},
  {"msp430f47197", MSP_ISA_430X},
  {"msp430f46161", MSP_ISA_430X},
  {"msp430f46171", MSP_ISA_430X},
  {"msp430f46181", MSP_ISA_430X},
  {"msp430f46191", MSP_ISA_430X},
  {"msp430f4616", MSP_ISA_430X},
  {"msp430f4617", MSP_ISA_430X},
  {"msp430f4618", MSP_ISA_430X},
  {"msp430f4619", MSP_ISA_430X},
  {"msp430fg4616", MSP_ISA_430X},
  {"msp430fg4617", MSP_ISA_430X},
  {"msp430fg4618", MSP_ISA_430X},
  {"msp430fg4619", MSP_ISA_430X},

  {"msp430f5418", MSP_ISA_430Xv2},
  {"msp430f5419", MSP_ISA_430Xv2},
  {"msp430f5435", MSP_ISA_430Xv2},
  {"msp430f5436", MSP_ISA_430Xv2},
  {"msp430f5437", MSP_ISA_430Xv2},
  {"msp430f5438", MSP_ISA_430Xv2},
  {"msp430f5418a", MSP_ISA_430Xv2},
  {"msp430f5419a", MSP_ISA_430Xv2},
  {"msp430f5435a", MSP_ISA_430Xv2},
  {"msp430f5436a", MSP_ISA_430Xv2},
  {"msp430f5437a", MSP_ISA_430Xv2},
  {"msp430f5438a", MSP_ISA_430Xv2},
  {"msp430f5212", MSP_ISA_430Xv2},
  {"msp430f5213", MSP_ISA_430Xv2},
  {"msp430f5214", MSP_ISA_430Xv2},
  {"msp430f5217", MSP_ISA_430Xv2},
  {"msp430f5218", MSP_ISA_430Xv2},
  {"msp430f5219", MSP_ISA_430Xv2},
  {"msp430f5222", MSP_ISA_430Xv2},
  {"msp430f5223", MSP_ISA_430Xv2},
  {"msp430f5224", MSP_ISA_430Xv2},
  {"msp430f5227", MSP_ISA_430Xv2},
  {"msp430f5228", MSP_ISA_430Xv2},
  {"msp430f5229", MSP_ISA_430Xv2},
  {"msp430f5304", MSP_ISA_430Xv2},
  {"msp430f5308", MSP_ISA_430Xv2},
  {"msp430f5309", MSP_ISA_430Xv2},
  {"msp430f5310", MSP_ISA_430Xv2},
  {"msp430f5340", MSP_ISA_430Xv2},
  {"msp430f5341", MSP_ISA_430Xv2},
  {"msp430f5342", MSP_ISA_430Xv2},
  {"msp430f5324", MSP_ISA_430Xv2},
  {"msp430f5325", MSP_ISA_430Xv2},
  {"msp430f5326", MSP_ISA_430Xv2},
  {"msp430f5327", MSP_ISA_430Xv2},
  {"msp430f5328", MSP_ISA_430Xv2},
  {"msp430f5329", MSP_ISA_430Xv2},
  {"msp430f5500", MSP_ISA_430Xv2},
  {"msp430f5501", MSP_ISA_430Xv2},
  {"msp430f5502", MSP_ISA_430Xv2},
  {"msp430f5503", MSP_ISA_430Xv2},
  {"msp430f5504", MSP_ISA_430Xv2},
  {"msp430f5505", MSP_ISA_430Xv2},
  {"msp430f5506", MSP_ISA_430Xv2},
  {"msp430f5507", MSP_ISA_430Xv2},
  {"msp430f5508", MSP_ISA_430Xv2},
  {"msp430f5509", MSP_ISA_430Xv2},
  {"msp430f5510", MSP_ISA_430Xv2},
  {"msp430f5513", MSP_ISA_430Xv2},
  {"msp430f5514", MSP_ISA_430Xv2},
  {"msp430f5515", MSP_ISA_430Xv2},
  {"msp430f5517", MSP_ISA_430Xv2},
  {"msp430f5519", MSP_ISA_430Xv2},
  {"msp430f5521", MSP_ISA_430Xv2},
  {"msp430f5522", MSP_ISA_430Xv2},
  {"msp430f5524", MSP_ISA_430Xv2},
  {"msp430f5525", MSP_ISA_430Xv2},
  {"msp430f5526", MSP_ISA_430Xv2},
  {"msp430f5527", MSP_ISA_430Xv2},
  {"msp430f5528", MSP_ISA_430Xv2},
  {"msp430f5529", MSP_ISA_430Xv2},
  {"cc430f5133", MSP_ISA_430Xv2},
  {"cc430f5135", MSP_ISA_430Xv2},
  {"cc430f5137", MSP_ISA_430Xv2},
  {"cc430f6125", MSP_ISA_430Xv2},
  {"cc430f6126", MSP_ISA_430Xv2},
  {"cc430f6127", MSP_ISA_430Xv2},
  {"cc430f6135", MSP_ISA_430Xv2},
  {"cc430f6137", MSP_ISA_430Xv2},
  {"cc430f5123", MSP_ISA_430Xv2},
  {"cc430f5125", MSP_ISA_430Xv2},
  {"cc430f5143", MSP_ISA_430Xv2},
  {"cc430f5145", MSP_ISA_430Xv2},
  {"cc430f5147", MSP_ISA_430Xv2},
  {"cc430f6143", MSP_ISA_430Xv2},
  {"cc430f6145", MSP_ISA_430Xv2},
  {"cc430f6147", MSP_ISA_430Xv2},
  {"msp430f5333", MSP_ISA_430Xv2},
  {"msp430f5335", MSP_ISA_430Xv2},
  {"msp430f5336", MSP_ISA_430Xv2},
  {"msp430f5338", MSP_ISA_430Xv2},
  {"msp430f5630", MSP_ISA_430Xv2},
  {"msp430f5631", MSP_ISA_430Xv2},
  {"msp430f5632", MSP_ISA_430Xv2},
  {"msp430f5633", MSP_ISA_430Xv2},
  {"msp430f5634", MSP_ISA_430Xv2},
  {"msp430f5635", MSP_ISA_430Xv2},
  {"msp430f5636", MSP_ISA_430Xv2},
  {"msp430f5637", MSP_ISA_430Xv2},
  {"msp430f5638", MSP_ISA_430Xv2},
  {"msp430f6433", MSP_ISA_430Xv2},
  {"msp430f6435", MSP_ISA_430Xv2},
  {"msp430f6436", MSP_ISA_430Xv2},
  {"msp430f6438", MSP_ISA_430Xv2},
  {"msp430f6630", MSP_ISA_430Xv2},
  {"msp430f6631", MSP_ISA_430Xv2},
  {"msp430f6632", MSP_ISA_430Xv2},
  {"msp430f6633", MSP_ISA_430Xv2},
  {"msp430f6634", MSP_ISA_430Xv2},
  {"msp430f6635", MSP_ISA_430Xv2},
  {"msp430f6636", MSP_ISA_430Xv2},
  {"msp430f6637", MSP_ISA_430Xv2},
  {"msp430f6638", MSP_ISA_430Xv2},
  {"msp430f5358", MSP_ISA_430Xv2},
  {"msp430f5359", MSP_ISA_430Xv2},
  {"msp430f5658", MSP_ISA_430Xv2},
  {"msp430f5659", MSP_ISA_430Xv2},
  {"msp430f6458", MSP_ISA_430Xv2},
  {"msp430f6459", MSP_ISA_430Xv2},
  {"msp430f6658", MSP_ISA_430Xv2},
  {"msp430f6659", MSP_ISA_430Xv2},
  {"msp430f5131", MSP_ISA_430Xv2},
  {"msp430f5151", MSP_ISA_430Xv2},
  {"msp430f5171", MSP_ISA_430Xv2},
  {"msp430f5132", MSP_ISA_430Xv2},
  {"msp430f5152", MSP_ISA_430Xv2},
  {"msp430f5172", MSP_ISA_430Xv2},
  {"msp430f6720", MSP_ISA_430Xv2},
  {"msp430f6721", MSP_ISA_430Xv2},
  {"msp430f6723", MSP_ISA_430Xv2},
  {"msp430f6724", MSP_ISA_430Xv2},
  {"msp430f6725", MSP_ISA_430Xv2},
  {"msp430f6726", MSP_ISA_430Xv2},
  {"msp430f6730", MSP_ISA_430Xv2},
  {"msp430f6731", MSP_ISA_430Xv2},
  {"msp430f6733", MSP_ISA_430Xv2},
  {"msp430f6734", MSP_ISA_430Xv2},
  {"msp430f6735", MSP_ISA_430Xv2},
  {"msp430f6736", MSP_ISA_430Xv2},
  {"msp430f67451", MSP_ISA_430Xv2},
  {"msp430f67651", MSP_ISA_430Xv2},
  {"msp430f67751", MSP_ISA_430Xv2},
  {"msp430f67461", MSP_ISA_430Xv2},
  {"msp430f67661", MSP_ISA_430Xv2},
  {"msp430f67761", MSP_ISA_430Xv2},
  {"msp430f67471", MSP_ISA_430Xv2},
  {"msp430f67671", MSP_ISA_430Xv2},
  {"msp430f67771", MSP_ISA_430Xv2},
  {"msp430f67481", MSP_ISA_430Xv2},
  {"msp430f67681", MSP_ISA_430Xv2},
  {"msp430f67781", MSP_ISA_430Xv2},
  {"msp430f67491", MSP_ISA_430Xv2},
  {"msp430f67691", MSP_ISA_430Xv2},
  {"msp430f67791", MSP_ISA_430Xv2},
  {"msp430f6745", MSP_ISA_430Xv2},
  {"msp430f6765", MSP_ISA_430Xv2},
  {"msp430f6775", MSP_ISA_430Xv2},
  {"msp430f6746", MSP_ISA_430Xv2},
  {"msp430f6766", MSP_ISA_430Xv2},
  {"msp430f6776", MSP_ISA_430Xv2},
  {"msp430f6747", MSP_ISA_430Xv2},
  {"msp430f6767", MSP_ISA_430Xv2},
  {"msp430f6777", MSP_ISA_430Xv2},
  {"msp430f6748", MSP_ISA_430Xv2},
  {"msp430f6768", MSP_ISA_430Xv2},
  {"msp430f6778", MSP_ISA_430Xv2},
  {"msp430f6749", MSP_ISA_430Xv2},
  {"msp430f6769", MSP_ISA_430Xv2},
  {"msp430f6779", MSP_ISA_430Xv2},
  {"msp430fr5720", MSP_ISA_430Xv2},
  {"msp430fr5721", MSP_ISA_430Xv2},
  {"msp430fr5722", MSP_ISA_430Xv2},
  {"msp430fr5723", MSP_ISA_430Xv2},
  {"msp430fr5724", MSP_ISA_430Xv2},
  {"msp430fr5725", MSP_ISA_430Xv2},
  {"msp430fr5726", MSP_ISA_430Xv2},
  {"msp430fr5727", MSP_ISA_430Xv2},
  {"msp430fr5728", MSP_ISA_430Xv2},
  {"msp430fr5729", MSP_ISA_430Xv2},
  {"msp430fr5730", MSP_ISA_430Xv2},
  {"msp430fr5731", MSP_ISA_430Xv2},
  {"msp430fr5732", MSP_ISA_430Xv2},
  {"msp430fr5733", MSP_ISA_430Xv2},
  {"msp430fr5734", MSP_ISA_430Xv2},
  {"msp430fr5735", MSP_ISA_430Xv2},
  {"msp430fr5736", MSP_ISA_430Xv2},
  {"msp430fr5737", MSP_ISA_430Xv2},
  {"msp430fr5738", MSP_ISA_430Xv2},
  {"msp430fr5739", MSP_ISA_430Xv2},
  {"msp430bt5190", MSP_ISA_430Xv2},
  {"msp430fr5949", MSP_ISA_430Xv2},
  {"msp430fr5969", MSP_ISA_430Xv2},
  {"msp430sl5438a", MSP_ISA_430Xv2},

  /* Generic names.  */
  {"msp430",    MSP_ISA_430},
  {"msp430X",   MSP_ISA_430X},
  {"msp430Xv2", MSP_ISA_430Xv2},

  {NULL, 0}
};

static struct mcu_type_s default_mcu   = { "msp430x11", MSP_ISA_430 };
static struct mcu_type_s msp430x_mcu   = { "msp430x",   MSP_ISA_430X };
static struct mcu_type_s msp430xv2_mcu = { "msp430xv2", MSP_ISA_430Xv2 };

static struct mcu_type_s * msp430_mcu = & default_mcu;

static inline bfd_boolean
target_is_430x (void)
{
  return msp430_mcu->isa >= MSP_ISA_430X;
}

static inline bfd_boolean
target_is_430xv2 (void)
{
  return msp430_mcu->isa == MSP_ISA_430Xv2;
}

/* Generate a 16-bit relocation.
   For the 430X we generate a relocation without linkwer range checking
   if the value is being used in an extended (ie 20-bit) instruction.
   For the 430 we generate a relocation without assembler range checking
   if we are handling an immediate value or a byte-width instruction.  */
#undef  CHECK_RELOC_MSP430
#define CHECK_RELOC_MSP430				     \
  (target_is_430x ()					     \
   ? (extended_op ? BFD_RELOC_16 : BFD_RELOC_MSP430X_ABS16)  \
   : ((imm_op || byte_op)				     \
      ? BFD_RELOC_MSP430_16_BYTE : BFD_RELOC_MSP430_16))

/* Generate a 16-bit pc-relative relocation.
   For the 430X we generate a relocation without linkwer range checking.
   For the 430 we generate a relocation without assembler range checking
   if we are handling an immediate value or a byte-width instruction.  */
#undef  CHECK_RELOC_MSP430_PCREL
#define CHECK_RELOC_MSP430_PCREL			     \
  (target_is_430x ()					     \
   ? BFD_RELOC_MSP430X_PCR16				     \
   : (imm_op || byte_op)				     \
   ? BFD_RELOC_MSP430_16_PCREL_BYTE : BFD_RELOC_MSP430_16_PCREL)

/* Profiling capability:
   It is a performance hit to use gcc's profiling approach for this tiny target.
   Even more -- jtag hardware facility does not perform any profiling functions.
   However we've got gdb's built-in simulator where we can do anything.
   Therefore my suggestion is:

   We define new section ".profiler" which holds all profiling information.
   We define new pseudo operation .profiler which will instruct assembler to
   add new profile entry to the object file. Profile should take place at the
   present address.

   Pseudo-op format:

      .profiler flags,function_to_profile [, cycle_corrector, extra]

   where 'flags' is a combination of the following chars:
	    s - function Start
	    x - function eXit
	    i - function is in Init section
	    f - function is in Fini section
	    l - Library call
	    c - libC standard call
	    d - stack value Demand (saved at run-time in simulator)
	    I - Interrupt service routine
	    P - Prologue start
	    p - Prologue end
	    E - Epilogue start
	    e - Epilogue end
	    j - long Jump/ sjlj unwind
	    a - an Arbitrary code fragment
	    t - exTra parameter saved (constant value like frame size)
	  '""' optional: "sil" == sil

      function_to_profile - function's address
      cycle_corrector     - a value which should be added to the cycle
			      counter, zero if omitted
      extra - some extra parameter, zero if omitted.

      For example:
      ------------------------------
	.global fxx
	.type fxx,@@function
      fxx:
      .LFrameOffset_fxx=0x08
      .profiler "scdP", fxx	; function entry.
				; we also demand stack value to be displayed
	push r11
	push r10
	push r9
	push r8
      .profiler "cdp",fxx,0, .LFrameOffset_fxx	; check stack value at this point
						; (this is a prologue end)
						; note, that spare var filled with the frame size
	mov r15,r8
	....
      .profiler cdE,fxx		; check stack
	pop r8
	pop r9
	pop r10
	pop r11
      .profiler xcde,fxx,3	; exit adds 3 to the cycle counter
      ret			; cause 'ret' insn takes 3 cycles
      -------------------------------

      This profiling approach does not produce any overhead and
      absolutely harmless.
      So, even profiled code can be uploaded to the MCU.  */
#define MSP430_PROFILER_FLAG_ENTRY	1	/* s */
#define MSP430_PROFILER_FLAG_EXIT	2	/* x */
#define MSP430_PROFILER_FLAG_INITSECT	4	/* i */
#define MSP430_PROFILER_FLAG_FINISECT	8	/* f */
#define MSP430_PROFILER_FLAG_LIBCALL	0x10	/* l */
#define MSP430_PROFILER_FLAG_STDCALL	0x20	/* c */
#define MSP430_PROFILER_FLAG_STACKDMD	0x40	/* d */
#define MSP430_PROFILER_FLAG_ISR	0x80	/* I */
#define MSP430_PROFILER_FLAG_PROLSTART	0x100	/* P */
#define MSP430_PROFILER_FLAG_PROLEND	0x200	/* p */
#define MSP430_PROFILER_FLAG_EPISTART	0x400	/* E */
#define MSP430_PROFILER_FLAG_EPIEND	0x800	/* e */
#define MSP430_PROFILER_FLAG_JUMP	0x1000	/* j */
#define MSP430_PROFILER_FLAG_FRAGMENT	0x2000	/* a */
#define MSP430_PROFILER_FLAG_EXTRA	0x4000	/* t */
#define MSP430_PROFILER_FLAG_notyet	0x8000	/* ? */

static int
pow2value (int y)
{
  int n = 0;
  unsigned int x;

  x = y;

  if (!x)
    return 1;

  for (; x; x = x >> 1)
    if (x & 1)
      n++;

  return n == 1;
}

/* Parse ordinary expression.  */

static char *
parse_exp (char * s, expressionS * op)
{
  input_line_pointer = s;
  expression (op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  return input_line_pointer;
}


/* Delete spaces from s: X ( r 1  2)  => X(r12).  */

static void
del_spaces (char * s)
{
  while (*s)
    {
      if (ISSPACE (*s))
	{
	  char *m = s + 1;

	  while (ISSPACE (*m) && *m)
	    m++;
	  memmove (s, m, strlen (m) + 1);
	}
      else
	s++;
    }
}

static inline char *
skip_space (char * s)
{
  while (ISSPACE (*s))
    ++s;
  return s;
}

/* Extract one word from FROM and copy it to TO. Delimiters are ",;\n"  */

static char *
extract_operand (char * from, char * to, int limit)
{
  int size = 0;

  /* Drop leading whitespace.  */
  from = skip_space (from);

  while (size < limit && *from)
    {
      *(to + size) = *from;
      if (*from == ',' || *from == ';' || *from == '\n')
	break;
      from++;
      size++;
    }

  *(to + size) = 0;
  del_spaces (to);

  from++;

  return from;
}

static void
msp430_profiler (int dummy ATTRIBUTE_UNUSED)
{
  char   buffer[1024];
  char   f[32];
  char * str = buffer;
  char * flags = f;
  int    p_flags = 0;
  char * halt;
  int    ops = 0;
  int    left;
  char * s;
  segT   seg;
  int    subseg;
  char * end = 0;
  expressionS exp;
  expressionS exp1;

  s = input_line_pointer;
  end = input_line_pointer;

  while (*end && *end != '\n')
    end++;

  while (*s && *s != '\n')
    {
      if (*s == ',')
	ops++;
      s++;
    }

  left = 3 - ops;

  if (ops < 1)
    {
      as_bad (_(".profiler pseudo requires at least two operands."));
      input_line_pointer = end;
      return;
    }

  input_line_pointer = extract_operand (input_line_pointer, flags, 32);

  while (*flags)
    {
      switch (*flags)
	{
	case '"':
	  break;
	case 'a':
	  p_flags |= MSP430_PROFILER_FLAG_FRAGMENT;
	  break;
	case 'j':
	  p_flags |= MSP430_PROFILER_FLAG_JUMP;
	  break;
	case 'P':
	  p_flags |= MSP430_PROFILER_FLAG_PROLSTART;
	  break;
	case 'p':
	  p_flags |= MSP430_PROFILER_FLAG_PROLEND;
	  break;
	case 'E':
	  p_flags |= MSP430_PROFILER_FLAG_EPISTART;
	  break;
	case 'e':
	  p_flags |= MSP430_PROFILER_FLAG_EPIEND;
	  break;
	case 's':
	  p_flags |= MSP430_PROFILER_FLAG_ENTRY;
	  break;
	case 'x':
	  p_flags |= MSP430_PROFILER_FLAG_EXIT;
	  break;
	case 'i':
	  p_flags |= MSP430_PROFILER_FLAG_INITSECT;
	  break;
	case 'f':
	  p_flags |= MSP430_PROFILER_FLAG_FINISECT;
	  break;
	case 'l':
	  p_flags |= MSP430_PROFILER_FLAG_LIBCALL;
	  break;
	case 'c':
	  p_flags |= MSP430_PROFILER_FLAG_STDCALL;
	  break;
	case 'd':
	  p_flags |= MSP430_PROFILER_FLAG_STACKDMD;
	  break;
	case 'I':
	  p_flags |= MSP430_PROFILER_FLAG_ISR;
	  break;
	case 't':
	  p_flags |= MSP430_PROFILER_FLAG_EXTRA;
	  break;
	default:
	  as_warn (_("unknown profiling flag - ignored."));
	  break;
	}
      flags++;
    }

  if (p_flags
      && (   ! pow2value (p_flags & (  MSP430_PROFILER_FLAG_ENTRY
				     | MSP430_PROFILER_FLAG_EXIT))
	  || ! pow2value (p_flags & (  MSP430_PROFILER_FLAG_PROLSTART
				     | MSP430_PROFILER_FLAG_PROLEND
				     | MSP430_PROFILER_FLAG_EPISTART
				     | MSP430_PROFILER_FLAG_EPIEND))
	  || ! pow2value (p_flags & (  MSP430_PROFILER_FLAG_INITSECT
				     | MSP430_PROFILER_FLAG_FINISECT))))
    {
      as_bad (_("ambiguous flags combination - '.profiler' directive ignored."));
      input_line_pointer = end;
      return;
    }

  /* Generate temp symbol which denotes current location.  */
  if (now_seg == absolute_section)	/* Paranoia ?  */
    {
      exp1.X_op = O_constant;
      exp1.X_add_number = abs_section_offset;
      as_warn (_("profiling in absolute section?"));
    }
  else
    {
      exp1.X_op = O_symbol;
      exp1.X_add_symbol = symbol_temp_new_now ();
      exp1.X_add_number = 0;
    }

  /* Generate a symbol which holds flags value.  */
  exp.X_op = O_constant;
  exp.X_add_number = p_flags;

  /* Save current section.  */
  seg = now_seg;
  subseg = now_subseg;

  /* Now go to .profiler section.  */
  obj_elf_change_section (".profiler", SHT_PROGBITS, 0, 0, 0, 0, 0);

  /* Save flags.  */
  emit_expr (& exp, 2);

  /* Save label value.  */
  emit_expr (& exp1, 2);

  while (ops--)
    {
      /* Now get profiling info.  */
      halt = extract_operand (input_line_pointer, str, 1024);
      /* Process like ".word xxx" directive.  */
      parse_exp (str, & exp);
      emit_expr (& exp, 2);
      input_line_pointer = halt;
    }

  /* Fill the rest with zeros.  */
  exp.X_op = O_constant;
  exp.X_add_number = 0;
  while (left--)
    emit_expr (& exp, 2);

  /* Return to current section.  */
  subseg_set (seg, subseg);
}

static char *
extract_word (char * from, char * to, int limit)
{
  char *op_end;
  int size = 0;

  /* Drop leading whitespace.  */
  from = skip_space (from);
  *to = 0;

  /* Find the op code end.  */
  for (op_end = from; *op_end != 0 && is_part_of_name (*op_end);)
    {
      to[size++] = *op_end++;
      if (size + 1 >= limit)
	break;
    }

  to[size] = 0;
  return op_end;
}

#define OPTION_MMCU 'm'
#define OPTION_RELAX 'Q'
#define OPTION_POLYMORPHS 'P'
#define OPTION_LARGE 'l'
static bfd_boolean large_model = FALSE;
#define OPTION_NO_INTR_NOPS 'N'
static bfd_boolean gen_interrupt_nops = TRUE;
#define OPTION_MCPU 'c'
#define OPTION_MOVE_DATA 'd'
static bfd_boolean move_data = FALSE;

static void
msp430_set_arch (int option)
{
  char *str = (char *) alloca (32);	/* 32 for good measure.  */

  input_line_pointer = extract_word (input_line_pointer, str, 32);

  md_parse_option (option, str);
  bfd_set_arch_mach (stdoutput, TARGET_ARCH,
		     target_is_430x () ? bfd_mach_msp430x : bfd_mach_msp11);
}

static void
show_mcu_list (FILE * stream)
{
  int i;

  fprintf (stream, _("Known MCU names:\n"));

  for (i = 0; mcu_types[i].name; i++)
    {
      fprintf (stream, "%14.14s", mcu_types[i].name);
      if ((i % 6) == 5)
	fprintf (stream, "\n");
    }

  fprintf (stream, "\n");
}

int
md_parse_option (int c, char * arg)
{
  int i;

  switch (c)
    {
    case OPTION_MMCU:
      if (arg == NULL)
	as_fatal (_("MCU option requires a name\n"));

      for (i = 0; mcu_types[i].name; ++i)
	if (strcasecmp (mcu_types[i].name, arg) == 0)
	  break;

      if (mcu_types[i].name == NULL)
	{
	  show_mcu_list (stderr);
	  as_fatal (_("unknown MCU: %s\n"), arg);
	}

      /* Allow switching to the same or a lesser architecture.  */
      if (msp430_mcu == &default_mcu || msp430_mcu->isa >= mcu_types[i].isa)
	msp430_mcu = mcu_types + i;
      else
	as_fatal (_("redefinition of mcu type '%s' to '%s'"),
		  msp430_mcu->name, mcu_types[i].name);
      return 1;

    case OPTION_MCPU:
      if (strcmp (arg, "430") == 0)
	msp430_mcu = & default_mcu;
      else if (strcmp (arg, "430x") == 0
	       || strcmp (arg, "430X") == 0)
	msp430_mcu = & msp430x_mcu;
      else if (strcasecmp (arg, "430xv2") == 0)
	msp430_mcu = & msp430xv2_mcu;
      else
	as_fatal (_("unrecognised argument to -mcpu option '%s'"), arg);

      return 1;

    case OPTION_RELAX:
      msp430_enable_relax = 1;
      return 1;

    case OPTION_POLYMORPHS:
      msp430_enable_polys = 1;
      return 1;

    case OPTION_LARGE:
      large_model = TRUE;
      return 1;

    case OPTION_NO_INTR_NOPS:
      gen_interrupt_nops = FALSE;
      return 1;

    case OPTION_MOVE_DATA:
      move_data = TRUE;
      return 1;
    }

  return 0;
}

static void
msp430_section (int arg)
{
  char * saved_ilp = input_line_pointer;
  char * name = obj_elf_section_name ();

  if (strncmp (name, ".bss", 4) == 0
      || strncmp (name, ".gnu.linkonce.b.", 16) == 0)
    (void) symbol_find_or_make ("__crt0_init_bss");

  if (move_data
      && (strncmp (name, ".data", 5) == 0
	  || strncmp (name, ".gnu.linkonce.d.", 16) == 0))
    (void) symbol_find_or_make ("__crt0_movedata");

  input_line_pointer = saved_ilp;
  obj_elf_section (arg);
}

const pseudo_typeS md_pseudo_table[] =
{
  {"arch", msp430_set_arch, OPTION_MMCU},
  {"cpu", msp430_set_arch, OPTION_MCPU},
  {"profiler", msp430_profiler, 0},
  {"section", msp430_section, 0},
  {"section.s", msp430_section, 0},
  {"sect", msp430_section, 0},
  {"sect.s", msp430_section, 0},
  {"pushsection", msp430_section, 1},
  {NULL, NULL, 0}
};

const char *md_shortopts = "mm:,mP,mQ,ml,mN";

struct option md_longopts[] =
{
  {"mmcu", required_argument, NULL, OPTION_MMCU},
  {"mcpu", required_argument, NULL, OPTION_MCPU},
  {"mP", no_argument, NULL, OPTION_POLYMORPHS},
  {"mQ", no_argument, NULL, OPTION_RELAX},
  {"ml", no_argument, NULL, OPTION_LARGE},
  {"mN", no_argument, NULL, OPTION_NO_INTR_NOPS},
  {"md", no_argument, NULL, OPTION_MOVE_DATA},
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

void
md_show_usage (FILE * stream)
{
  fprintf (stream,
	   _("MSP430 options:\n"
	     "  -mmcu=<msp430-name>     - select microcontroller type\n"
             "  -mcpu={430|430x|430xv2} - select microcontroller architecture\n"));
  fprintf (stream,
	   _("  -mQ - enable relaxation at assembly time. DANGEROUS!\n"
	     "  -mP - enable polymorph instructions\n"));
  fprintf (stream,
	   _("  -ml - enable large code model\n"));
  fprintf (stream,
	   _("  -mN - disable generation of NOP after changing interrupts\n"));
  fprintf (stream,
	   _("  -md - Force copying of data from ROM to RAM at startup\n"));

  show_mcu_list (stream);
}

symbolS *
md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
{
  return NULL;
}

static char *
extract_cmd (char * from, char * to, int limit)
{
  int size = 0;

  while (*from && ! ISSPACE (*from) && *from != '.' && limit > size)
    {
      *(to + size) = *from;
      from++;
      size++;
    }

  *(to + size) = 0;

  return from;
}

char *
md_atof (int type, char * litP, int * sizeP)
{
  return ieee_md_atof (type, litP, sizeP, FALSE);
}

void
md_begin (void)
{
  struct msp430_opcode_s * opcode;
  msp430_hash = hash_new ();

  for (opcode = msp430_opcodes; opcode->name; opcode++)
    hash_insert (msp430_hash, opcode->name, (char *) opcode);

  bfd_set_arch_mach (stdoutput, TARGET_ARCH,
		     target_is_430x () ? bfd_mach_msp430x : bfd_mach_msp11);
}

/* Returns the register number equivalent to the string T.
   Returns -1 if there is no such register.
   Skips a leading 'r' or 'R' character if there is one.
   Handles the register aliases PC and SP.  */

static signed int
check_reg (char * t)
{
  signed int val;

  if (t == NULL)
    return -1;

  if (*t == 'r' || *t == 'R')
    ++t;

  if (strncasecmp (t, "pc", 2) == 0)
    return 0;

  if (strncasecmp (t, "sp", 2) == 0)
    return 1;

  if (strncasecmp (t, "sr", 2) == 0)
    return 2;

  if (*t == '0')
    return 0;

  val = atoi (t);

  if (val < 1 || val > 15)
    return -1;

  return val;
}

static int
msp430_srcoperand (struct msp430_operand_s * op,
		   char * l,
		   int bin,
		   int * imm_op,
		   bfd_boolean allow_20bit_values,
		   bfd_boolean constants_allowed)
{
  char *__tl = l;

  /* Check if an immediate #VALUE.  The hash sign should be only at the beginning!  */
  if (*l == '#')
    {
      char *h = l;
      int vshift = -1;
      int rval = 0;

      /* Check if there is:
	 llo(x) - least significant 16 bits, x &= 0xffff
	 lhi(x) - x = (x >> 16) & 0xffff,
	 hlo(x) - x = (x >> 32) & 0xffff,
	 hhi(x) - x = (x >> 48) & 0xffff
	 The value _MUST_ be constant expression: #hlo(1231231231).  */

      *imm_op = 1;

      if (strncasecmp (h, "#llo(", 5) == 0)
	{
	  vshift = 0;
	  rval = 3;
	}
      else if (strncasecmp (h, "#lhi(", 5) == 0)
	{
	  vshift = 1;
	  rval = 3;
	}
      else if (strncasecmp (h, "#hlo(", 5) == 0)
	{
	  vshift = 2;
	  rval = 3;
	}
      else if (strncasecmp (h, "#hhi(", 5) == 0)
	{
	  vshift = 3;
	  rval = 3;
	}
      else if (strncasecmp (h, "#lo(", 4) == 0)
	{
	  vshift = 0;
	  rval = 2;
	}
      else if (strncasecmp (h, "#hi(", 4) == 0)
	{
	  vshift = 1;
	  rval = 2;
	}

      op->reg = 0;		/* Reg PC.  */
      op->am = 3;
      op->ol = 1;		/* Immediate  will follow an instruction.  */
      __tl = h + 1 + rval;
      op->mode = OP_EXP;

      parse_exp (__tl, &(op->exp));
      if (op->exp.X_op == O_constant)
	{
	  int x = op->exp.X_add_number;

	  if (vshift == 0)
	    {
	      x = x & 0xffff;
	      op->exp.X_add_number = x;
	    }
	  else if (vshift == 1)
	    {
	      x = (x >> 16) & 0xffff;
	      op->exp.X_add_number = x;
	    }
	  else if (vshift > 1)
	    {
	      if (x < 0)
		op->exp.X_add_number = -1;
	      else
		op->exp.X_add_number = 0;	/* Nothing left.  */
	      x = op->exp.X_add_number;
	    }

	  if (allow_20bit_values)
	    {
	      if (op->exp.X_add_number > 0xfffff || op->exp.X_add_number < - (0x7ffff))
		{
		  as_bad (_("value 0x%x out of extended range."), x);
		  return 1;
		}
	    }
	  else if (op->exp.X_add_number > 65535 || op->exp.X_add_number < -32768)
	    {
	      as_bad (_("value %d out of range. Use #lo() or #hi()"), x);
	      return 1;
	    }

	  /* Now check constants.  */
	  /* Substitute register mode with a constant generator if applicable.  */

	  if (!allow_20bit_values)
	    x = (short) x;	/* Extend sign.  */

	  if (! constants_allowed)
	    ;
	  else if (x == 0)
	    {
	      op->reg = 3;
	      op->am = 0;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 1)
	    {
	      op->reg = 3;
	      op->am = 1;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 2)
	    {
	      op->reg = 3;
	      op->am = 2;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == -1)
	    {
	      op->reg = 3;
	      op->am = 3;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 4)
	    {
#ifdef PUSH_1X_WORKAROUND
	      if (bin == 0x1200)
		{
		  /* Remove warning as confusing.
		     as_warn (_("Hardware push bug workaround")); */
		}
	      else
#endif
		{
		  op->reg = 2;
		  op->am = 2;
		  op->ol = 0;
		  op->mode = OP_REG;
		}
	    }
	  else if (x == 8)
	    {
#ifdef PUSH_1X_WORKAROUND
	      if (bin == 0x1200)
		{
		  /* Remove warning as confusing.
		     as_warn (_("Hardware push bug workaround")); */
		}
	      else
#endif
		{
		  op->reg = 2;
		  op->am = 3;
		  op->ol = 0;
		  op->mode = OP_REG;
		}
	    }
	}
      else if (op->exp.X_op == O_symbol)
	{
	  op->mode = OP_EXP;
	}
      else if (op->exp.X_op == O_big)
	{
	  short x;
	  if (vshift != -1)
	    {
	      op->exp.X_op = O_constant;
	      op->exp.X_add_number = 0xffff & generic_bignum[vshift];
	      x = op->exp.X_add_number;
	    }
	  else
	    {
	      as_bad (_
		      ("unknown expression in operand %s. use #llo() #lhi() #hlo() #hhi() "),
		      l);
	      return 1;
	    }

	  if (x == 0)
	    {
	      op->reg = 3;
	      op->am = 0;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 1)
	    {
	      op->reg = 3;
	      op->am = 1;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 2)
	    {
	      op->reg = 3;
	      op->am = 2;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == -1)
	    {
	      op->reg = 3;
	      op->am = 3;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 4)
	    {
	      op->reg = 2;
	      op->am = 2;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 8)
	    {
	      op->reg = 2;
	      op->am = 3;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	}
      /* Redundant (yet) check.  */
      else if (op->exp.X_op == O_register)
	as_bad
	  (_("Registers cannot be used within immediate expression [%s]"), l);
      else
	as_bad (_("unknown operand %s"), l);

      return 0;
    }

  /* Check if absolute &VALUE (assume that we can construct something like ((a&b)<<7 + 25).  */
  if (*l == '&')
    {
      char *h = l;

      op->reg = 2;		/* reg 2 in absolute addr mode.  */
      op->am = 1;		/* mode As == 01 bin.  */
      op->ol = 1;		/* Immediate value followed by instruction.  */
      __tl = h + 1;
      parse_exp (__tl, &(op->exp));
      op->mode = OP_EXP;
      if (op->exp.X_op == O_constant)
	{
	  int x = op->exp.X_add_number;

	  if (allow_20bit_values)
	    {
	      if (x > 0xfffff || x < -(0x7ffff))
		{
		  as_bad (_("value 0x%x out of extended range."), x);
		  return 1;
		}
	    }
	  else if (x > 65535 || x < -32768)
	    {
	      as_bad (_("value out of range: 0x%x"), x);
	      return 1;
	    }
	}
      else if (op->exp.X_op == O_symbol)
	;
      else
	{
	  /* Redundant (yet) check.  */
	  if (op->exp.X_op == O_register)
	    as_bad
	      (_("Registers cannot be used within absolute expression [%s]"), l);
	  else
	    as_bad (_("unknown expression in operand %s"), l);
	  return 1;
	}
      return 0;
    }

  /* Check if indirect register mode @@Rn / postincrement @@Rn+.  */
  if (*l == '@@')
    {
      char *t = l;
      char *m = strchr (l, '+');

      if (t != l)
	{
	  as_bad (_("unknown addressing mode %s"), l);
	  return 1;
	}

      t++;

      if ((op->reg = check_reg (t)) == -1)
	{
	  as_bad (_("Bad register name %s"), t);
	  return 1;
	}

      op->mode = OP_REG;
      op->am = m ? 3 : 2;
      op->ol = 0;

      /* PC cannot be used in indirect addressing.  */
      if (target_is_430xv2 () && op->reg == 0)
	{
	  as_bad (_("cannot use indirect addressing with the PC"));
	  return 1;
	}
      return 0;
    }

  /* Check if register indexed X(Rn).  */
  do
    {
      char *h = strrchr (l, '(');
      char *m = strrchr (l, ')');
      char *t;

      *imm_op = 1;

      if (!h)
	break;
      if (!m)
	{
	  as_bad (_("')' required"));
	  return 1;
	}

      t = h;
      op->am = 1;
      op->ol = 1;

      /* Extract a register.  */
      if ((op->reg = check_reg (t + 1)) == -1)
	{
	  as_bad (_
		  ("unknown operator %s. Did you mean X(Rn) or #[hl][hl][oi](CONST) ?"),
		  l);
	  return 1;
	}

      if (op->reg == 2)
	{
	  as_bad (_("r2 should not be used in indexed addressing mode"));
	  return 1;
	}

      /* Extract constant.  */
      __tl = l;
      *h = 0;
      op->mode = OP_EXP;
      parse_exp (__tl, &(op->exp));
      if (op->exp.X_op == O_constant)
	{
	  int x = op->exp.X_add_number;

	  if (allow_20bit_values)
	    {
	      if (x > 0xfffff || x < - (0x7ffff))
		{
		  as_bad (_("value 0x%x out of extended range."), x);
		  return 1;
		}
	    }
	  else if (x > 65535 || x < -32768)
	    {
	      as_bad (_("value out of range: 0x%x"), x);
	      return 1;
	    }

	  if (x == 0)
	    {
	      op->mode = OP_REG;
	      op->am = 2;
	      op->ol = 0;
	      return 0;
	    }
	}
      else if (op->exp.X_op == O_symbol)
	;
      else
	{
	  /* Redundant (yet) check.  */
	  if (op->exp.X_op == O_register)
	    as_bad
	      (_("Registers cannot be used as a prefix of indexed expression [%s]"), l);
	  else
	    as_bad (_("unknown expression in operand %s"), l);
	  return 1;
	}

      return 0;
    }
  while (0);

  /* Possibly register mode 'mov r1,r2'.  */
  if ((op->reg = check_reg (l)) != -1)
    {
      op->mode = OP_REG;
      op->am = 0;
      op->ol = 0;
      return 0;
    }

  /* Symbolic mode 'mov a, b' == 'mov x(pc), y(pc)'.  */
  do
    {
      op->mode = OP_EXP;
      op->reg = 0;		/* PC relative... be careful.  */
      /* An expression starting with a minus sign is a constant, not an address.  */
      op->am = (*l == '-' ? 3 : 1);
      op->ol = 1;
      __tl = l;
      parse_exp (__tl, &(op->exp));
      return 0;
    }
  while (0);

  /* Unreachable.  */
  as_bad (_("unknown addressing mode for operand %s"), l);
  return 1;
}


static int
msp430_dstoperand (struct msp430_operand_s * op,
		   char * l,
		   int bin,
		   bfd_boolean allow_20bit_values,
		   bfd_boolean constants_allowed)
{
  int dummy;
  int ret = msp430_srcoperand (op, l, bin, & dummy,
			       allow_20bit_values,
			       constants_allowed);

  if (ret)
    return ret;

  if (op->am == 2)
    {
      char *__tl = "0";

      op->mode = OP_EXP;
      op->am = 1;
      op->ol = 1;
      parse_exp (__tl, &(op->exp));

      if (op->exp.X_op != O_constant || op->exp.X_add_number != 0)
	{
	  as_bad (_("Internal bug. Try to use 0(r%d) instead of @@r%d"),
		  op->reg, op->reg);
	  return 1;
	}
      return 0;
    }

  if (op->am > 1)
    {
      as_bad (_
	      ("this addressing mode is not applicable for destination operand"));
      return 1;
    }
  return 0;
}


/* Attempt to encode a MOVA instruction with the given operands.
   Returns the length of the encoded instruction if successful
   or 0 upon failure.  If the encoding fails, an error message
   will be returned if a pointer is provided.  */

static int
try_encode_mova (bfd_boolean imm_op,
		 int bin,
		 struct msp430_operand_s * op1,
		 struct msp430_operand_s * op2,
		 const char ** error_message_return)
{
  short ZEROS = 0;
  char *frag;
  int where;

  /* Only a restricted subset of the normal MSP430 addressing modes
     are supported here, so check for the ones that are allowed.  */
  if (imm_op)
    {
      if (op1->mode == OP_EXP)
	{
	  if (op2->mode != OP_REG)
	    {
	      if (error_message_return != NULL)
		* error_message_return = _("expected register as second argument of %s");
	      return 0;
	    }

	  if (op1->am == 3)
	    {
	      /* MOVA #imm20, Rdst.  */
	      bin |= 0x80 | op2->reg;
	      frag = frag_more (4);
	      where = frag - frag_now->fr_literal;
	      if (op1->exp.X_op == O_constant)
		{
		  bin |= ((op1->exp.X_add_number >> 16) & 0xf) << 8;
		  bfd_putl16 ((bfd_vma) bin, frag);
		  bfd_putl16 (op1->exp.X_add_number & 0xffff, frag + 2);
		}
	      else
		{
		  bfd_putl16 ((bfd_vma) bin, frag);
		  fix_new_exp (frag_now, where, 4, &(op1->exp), FALSE,
			       BFD_RELOC_MSP430X_ABS20_ADR_SRC);
		  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
		}

	      return 4;
	    }
	  else if (op1->am == 1)
	    {
	      /* MOVA z16(Rsrc), Rdst.  */
	      bin |= 0x30 | (op1->reg << 8) | op2->reg;
	      frag = frag_more (4);
	      where = frag - frag_now->fr_literal;
	      bfd_putl16 ((bfd_vma) bin, frag);
	      if (op1->exp.X_op == O_constant)
		{
		  if (op1->exp.X_add_number > 0xffff
		      || op1->exp.X_add_number < -(0x7fff))
		    {
		      if (error_message_return != NULL)
			* error_message_return = _("index value too big for %s");
		      return 0;
		    }
		  bfd_putl16 (op1->exp.X_add_number & 0xffff, frag + 2);
		}
	      else
		{
		  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
		  fix_new_exp (frag_now, where + 2, 2, &(op1->exp), FALSE,
			       op1->reg == 0 ?
			       BFD_RELOC_MSP430X_PCR16 :
			       BFD_RELOC_MSP430X_ABS16);
		}
	      return 4;
	    }

	  if (error_message_return != NULL)
	    * error_message_return = _("unexpected addressing mode for %s");
	  return 0;
	}
      else if (op1->am == 0)
	{
	  /* MOVA Rsrc, ... */
	  if (op2->mode == OP_REG)
	    {
	      bin |= 0xc0 | (op1->reg << 8) | op2->reg;
	      frag = frag_more (2);
	      where = frag - frag_now->fr_literal;
	      bfd_putl16 ((bfd_vma) bin, frag);
	      return 2;
	    }
	  else if (op2->am == 1)
	    {
	      if (op2->reg == 2)
		{
		  /* MOVA Rsrc, &abs20.  */
		  bin |= 0x60 | (op1->reg << 8);
		  frag = frag_more (4);
		  where = frag - frag_now->fr_literal;
		  if (op2->exp.X_op == O_constant)
		    {
		      bin |= (op2->exp.X_add_number >> 16) & 0xf;
		      bfd_putl16 ((bfd_vma) bin, frag);
		      bfd_putl16 (op2->exp.X_add_number & 0xffff, frag + 2);
		    }
		  else
		    {
		      bfd_putl16 ((bfd_vma) bin, frag);
		      bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
		      fix_new_exp (frag_now, where, 4, &(op2->exp), FALSE,
				   BFD_RELOC_MSP430X_ABS20_ADR_DST);
		    }
		  return 4;
		}

	      /* MOVA Rsrc, z16(Rdst).  */
	      bin |= 0x70 | (op1->reg << 8) | op2->reg;
	      frag = frag_more (4);
	      where = frag - frag_now->fr_literal;
	      bfd_putl16 ((bfd_vma) bin, frag);
	      if (op2->exp.X_op == O_constant)
		{
		  if (op2->exp.X_add_number > 0xffff
		      || op2->exp.X_add_number < -(0x7fff))
		    {
		      if (error_message_return != NULL)
			* error_message_return = _("index value too big for %s");
		      return 0;
		    }
		  bfd_putl16 (op2->exp.X_add_number & 0xffff, frag + 2);
		}
	      else
		{
		  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
		  fix_new_exp (frag_now, where + 2, 2, &(op2->exp), FALSE,
			       op2->reg == 0 ?
			       BFD_RELOC_MSP430X_PCR16 :
			       BFD_RELOC_MSP430X_ABS16);
		}
	      return 4;
	    }

	  if (error_message_return != NULL)
	    * error_message_return = _("unexpected addressing mode for %s");
	  return 0;
	}
    }

  /* imm_op == FALSE.  */

  if (op1->reg == 2 && op1->am == 1 && op1->mode == OP_EXP)
    {
      /* MOVA &abs20, Rdst.  */
      if (op2->mode != OP_REG)
	{
	  if (error_message_return != NULL)
	    * error_message_return = _("expected register as second argument of %s");
	  return 0;
	}

      if (op2->reg == 2 || op2->reg == 3)
	{
	  if (error_message_return != NULL)
	    * error_message_return = _("constant generator destination register found in %s");
	  return 0;
	}

      bin |= 0x20 | op2->reg;
      frag = frag_more (4);
      where = frag - frag_now->fr_literal;
      if (op1->exp.X_op == O_constant)
	{
	  bin |= ((op1->exp.X_add_number >> 16) & 0xf) << 8;
	  bfd_putl16 ((bfd_vma) bin, frag);
	  bfd_putl16 (op1->exp.X_add_number & 0xffff, frag + 2);
	}
      else
	{
	  bfd_putl16 ((bfd_vma) bin, frag);
	  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
	  fix_new_exp (frag_now, where, 4, &(op1->exp), FALSE,
		       BFD_RELOC_MSP430X_ABS20_ADR_SRC);
	}
      return 4;
    }
  else if (op1->mode == OP_REG)
    {
      if (op1->am == 3)
	{
	  /* MOVA @@Rsrc+, Rdst.  */
	  if (op2->mode != OP_REG)
	    {
	      if (error_message_return != NULL)
		* error_message_return = _("expected register as second argument of %s");
	      return 0;
	    }

	  if (op2->reg == 2 || op2->reg == 3)
	    {
	      if (error_message_return != NULL)
		* error_message_return = _("constant generator destination register found in %s");
	      return 0;
	    }

	  if (op1->reg == 2 || op1->reg == 3)
	    {
	      if (error_message_return != NULL)
		* error_message_return = _("constant generator source register found in %s");
	      return 0;
	    }

	  bin |= 0x10 | (op1->reg << 8) | op2->reg;
	  frag = frag_more (2);
	  where = frag - frag_now->fr_literal;
	  bfd_putl16 ((bfd_vma) bin, frag);
	  return 2;
	}
      else if (op1->am == 2)
	{
	  /* MOVA @@Rsrc,Rdst */
	  if (op2->mode != OP_REG)
	    {
	      if (error_message_return != NULL)
		* error_message_return = _("expected register as second argument of %s");
	      return 0;
	    }

	  if (op2->reg == 2 || op2->reg == 3)
	    {
	      if (error_message_return != NULL)
		* error_message_return = _("constant generator destination register found in %s");
	      return 0;
	    }

	  if (op1->reg == 2 || op1->reg == 3)
	    {
	      if (error_message_return != NULL)
		* error_message_return = _("constant generator source register found in %s");
	      return 0;
	    }

	  bin |= (op1->reg << 8) | op2->reg;
	  frag = frag_more (2);
	  where = frag - frag_now->fr_literal;
	  bfd_putl16 ((bfd_vma) bin, frag);
	  return 2;
	}
    }

  if (error_message_return != NULL)
    * error_message_return = _("unexpected addressing mode for %s");

  return 0;
}

#define is_opcode(NAME) (strcmp (opcode->name, NAME) == 0)

/* Parse instruction operands.
   Return binary opcode.  */

static unsigned int
msp430_operands (struct msp430_opcode_s * opcode, char * line)
{
  int bin = opcode->bin_opcode;	/* Opcode mask.  */
  int insn_length = 0;
  char l1[MAX_OP_LEN], l2[MAX_OP_LEN];
  char *frag;
  int where;
  struct msp430_operand_s op1, op2;
  int res = 0;
  static short ZEROS = 0;
  int byte_op, imm_op;
  int op_length = 0;
  int fmt;
  int extended = 0x1800;
  bfd_boolean extended_op = FALSE;
  bfd_boolean addr_op;
  const char * error_message;
  static signed int repeat_count = 0;
  bfd_boolean fix_emitted;

  /* Opcode is the one from opcodes table
     line contains something like
     [.w] @@r2+, 5(R1)
     or
     .b @@r2+, 5(R1).  */

  byte_op = 0;
  addr_op = FALSE;
  if (*line == '.')
    {
      bfd_boolean check = FALSE;
      ++ line;

      switch (TOLOWER (* line))
	{
	case 'b':
	  /* Byte operation.  */
	  bin |= BYTE_OPERATION;
	  byte_op = 1;
	  check = TRUE;
	  break;

	case 'a':
	  /* "Address" ops work on 20-bit values.  */
	  addr_op = TRUE;
	  bin |= BYTE_OPERATION;
	  check = TRUE;
	  break;

	case 'w':
	  /* Word operation - this is the default.  */
	  check = TRUE;
	  break;

	case 0:
	case ' ':
	case '\n':
	case '\r':
	  as_warn (_("no size modifier after period, .w assumed"));
	  break;

	default:
	  as_bad (_("unrecognised instruction size modifier .%c"),
		   * line);
	  return 0;
	}

      if (check)
	{
	  ++ line;

	}
    }

  if (*line && ! ISSPACE (*line))
    {
      as_bad (_("junk found after instruction: %s.%s"),
	      opcode->name, line);
      return 0;
    }

  /* Catch the case where the programmer has used a ".a" size modifier on an
     instruction that does not support it.  Look for an alternative extended
     instruction that has the same name without the period.  Eg: "add.a"
     becomes "adda".  Although this not an officially supported way of
     specifing instruction aliases other MSP430 assemblers allow it.  So we
     support it for compatibility purposes.  */
  if (addr_op && opcode->fmt >= 0)
    {
      char * old_name = opcode->name;
      char real_name[32];

      sprintf (real_name, "%sa", old_name);
      opcode = hash_find (msp430_hash, real_name);
      if (opcode == NULL)
	{
	  as_bad (_("instruction %s.a does not exist"), old_name);
	  return 0;
	}
#if 0 /* Enable for debugging.  */
      as_warn ("treating %s.a as %s", old_name, real_name);
#endif
      addr_op = FALSE;
      bin = opcode->bin_opcode;
    }

  if (opcode->fmt != -1
      && opcode->insn_opnumb
      && (!*line || *line == '\n'))
    {
      as_bad (_("instruction %s requires %d operand(s)"),
	      opcode->name, opcode->insn_opnumb);
      return 0;
    }

  memset (l1, 0, sizeof (l1));
  memset (l2, 0, sizeof (l2));
  memset (&op1, 0, sizeof (op1));
  memset (&op2, 0, sizeof (op2));

  imm_op = 0;

  if ((fmt = opcode->fmt) < 0)
    {
      if (! target_is_430x ())
	{
	  as_bad (_("instruction %s requires MSP430X mcu"),
		  opcode->name);
	  return 0;
	}
	
      fmt = (-fmt) - 1;
      extended_op = TRUE;
    }

  if (repeat_count)
    {
      /* If requested set the extended instruction repeat count.  */
      if (extended_op)
	{
	  if (repeat_count > 0)
	    extended |= (repeat_count - 1);
	  else
	    extended |= (1 << 7) | (- repeat_count);
	}
      else
	as_bad (_("unable to repeat %s insn"), opcode->name);

      repeat_count = 0;
    }

  switch (fmt)
    {
    case 0:			/* Emulated.  */
      switch (opcode->insn_opnumb)
	{
	case 0:
	  /* Set/clear bits instructions.  */
	  if (extended_op)
	    {
	      if (!addr_op)
		extended |= BYTE_OPERATION;

	      /* Emit the extension word.  */
	      insn_length += 2;
	      frag = frag_more (insn_length);
	      bfd_putl16 (extended, frag);
	    }

	  insn_length += 2;
	  frag = frag_more (insn_length);
	  bfd_putl16 ((bfd_vma) bin, frag);

	  if (gen_interrupt_nops
	      && target_is_430xv2 ()
	      && (is_opcode ("eint") || is_opcode ("dint")))
	    {
	      /* Emit a NOP following interrupt enable/disable.
		 See 1.3.4.1 of the MSP430x5xx User Guide.  */
	      insn_length += 2;
	      frag = frag_more (2);
	      as_warn (_("a NOP instruction has been inserted after %s"),
		       opcode->name);
	      bfd_putl16 ((bfd_vma) 0x4303 /* NOP */, frag);
	    }
	  dwarf2_emit_insn (insn_length);
	  break;

	case 1:
	  /* Something which works with destination operand.  */
	  line = extract_operand (line, l1, sizeof (l1));
	  res = msp430_dstoperand (&op1, l1, opcode->bin_opcode, extended_op, TRUE);
	  if (res)
	    break;

	  /* Compute the entire instruction length, in bytes.  */
	  insn_length = (extended_op ? 2 : 0) + 2 + (op1.ol * 2);
	  frag = frag_more (insn_length);
	  where = frag - frag_now->fr_literal;

	  if (extended_op)
	    {
	      if (!addr_op)
		extended |= BYTE_OPERATION;

	      if (op1.ol != 0 && ((extended & 0xf) != 0))
		{
		  as_bad (_("repeat instruction used with non-register mode instruction"));
		  extended &= ~ 0xf;
		}

	      if (op1.mode == OP_EXP)
		{
		  if (op1.exp.X_op == O_constant)
		    extended |= ((op1.exp.X_add_number >> 16) & 0xf) << 7;

		  else if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
		    fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,
				 BFD_RELOC_MSP430X_ABS20_EXT_SRC);
		  else
		    fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,
				 BFD_RELOC_MSP430X_PCR20_EXT_SRC);
		}

	      /* Emit the extension word.  */
	      bfd_putl16 (extended, frag);
	      frag += 2;
	      where += 2;
	    }

	  bin |= (op1.reg | (op1.am << 7));
	  bfd_putl16 ((bfd_vma) bin, frag);
	  frag += 2;
	  where += 2;

	  if (op1.mode == OP_EXP)
	    {
	      if (op1.exp.X_op == O_constant)
		{
		  bfd_putl16 (op1.exp.X_add_number & 0xffff, frag);
		}
	      else
		{
		  bfd_putl16 ((bfd_vma) ZEROS, frag);

		  if (!extended_op)
		    {
		      if (op1.reg)
			fix_new_exp (frag_now, where, 2,
				     &(op1.exp), FALSE, CHECK_RELOC_MSP430);
		      else
			fix_new_exp (frag_now, where, 2,
				     &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
		    }
		}
	    }

	  if (gen_interrupt_nops
	      && target_is_430xv2 ()
	      && is_opcode ("clr")
	      && bin == 0x4302 /* CLR R2*/)
	    {
	      /* Emit a NOP following interrupt enable/disable.
		 See 1.3.4.1 of the MSP430x5xx User Guide.  */
	      insn_length += 2;
	      frag = frag_more (2);
	      bfd_putl16 ((bfd_vma) 0x4303 /* NOP */, frag);
	      as_warn (_("a NOP instruction has been inserted after %s"),
		       opcode->name);
	    }

	  dwarf2_emit_insn (insn_length);
	  break;

	case 2:
	  /* Shift instruction.  */
	  line = extract_operand (line, l1, sizeof (l1));
	  strncpy (l2, l1, sizeof (l2));
	  l2[sizeof (l2) - 1] = '\0';
	  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op, extended_op, TRUE);
	  res += msp430_dstoperand (&op2, l2, opcode->bin_opcode, extended_op, TRUE);

	  if (res)
	    break;	/* An error occurred.  All warnings were done before.  */

	  insn_length = (extended_op ? 2 : 0) + 2 + (op1.ol * 2) + (op2.ol * 2);
	  frag = frag_more (insn_length);
	  where = frag - frag_now->fr_literal;

	  if (target_is_430xv2 ()
	      && op1.mode == OP_REG
	      && op1.reg == 0
	      && (is_opcode ("rlax")
		  || is_opcode ("rlcx")
		  || is_opcode ("rla")
		  || is_opcode ("rlc")))
	    {
	      as_bad (_("%s: attempt to rotate the PC register"), opcode->name);
	      return 0;
	    }

	  if (extended_op)
	    {
	      if (!addr_op)
		extended |= BYTE_OPERATION;

	      if ((op1.ol != 0 || op2.ol != 0) && ((extended & 0xf) != 0))
		{
		  as_bad (_("repeat instruction used with non-register mode instruction"));
		  extended &= ~ 0xf;
		}

	      if (op1.mode == OP_EXP)
		{
		  if (op1.exp.X_op == O_constant)
		    extended |= ((op1.exp.X_add_number >> 16) & 0xf) << 7;

		  else if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
		    fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,
				 BFD_RELOC_MSP430X_ABS20_EXT_SRC);
		  else
		    fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,
				 BFD_RELOC_MSP430X_PCR20_EXT_SRC);
		}

	      if (op2.mode == OP_EXP)
		{
		  if (op2.exp.X_op == O_constant)
		    extended |= (op2.exp.X_add_number >> 16) & 0xf;

		  else if (op1.mode == OP_EXP)
		    fix_new_exp (frag_now, where, 8, &(op2.exp), FALSE,
				 op2.reg ? BFD_RELOC_MSP430X_ABS20_EXT_ODST
				 : BFD_RELOC_MSP430X_PCR20_EXT_ODST);
		  else
		    fix_new_exp (frag_now, where, 6, &(op2.exp), FALSE,
				 op2.reg ? BFD_RELOC_MSP430X_ABS20_EXT_DST
				 : BFD_RELOC_MSP430X_PCR20_EXT_DST);
		}

	      /* Emit the extension word.  */
	      bfd_putl16 (extended, frag);
	      frag += 2;
	      where += 2;
	    }

	  bin |= (op2.reg | (op1.reg << 8) | (op1.am << 4) | (op2.am << 7));
	  bfd_putl16 ((bfd_vma) bin, frag);
	  frag += 2;
	  where += 2;

	  if (op1.mode == OP_EXP)
	    {
	      if (op1.exp.X_op == O_constant)
		{
		  bfd_putl16 (op1.exp.X_add_number & 0xffff, frag);
		}
	      else
		{
		  bfd_putl16 ((bfd_vma) ZEROS, frag);

		  if (!extended_op)
		    {
		      if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
			fix_new_exp (frag_now, where, 2,
				     &(op1.exp), FALSE, CHECK_RELOC_MSP430);
		      else
			fix_new_exp (frag_now, where, 2,
				     &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
		    }
		}
	      frag += 2;
	      where += 2;
	    }

	  if (op2.mode == OP_EXP)
	    {
	      if (op2.exp.X_op == O_constant)
		{
		  bfd_putl16 (op2.exp.X_add_number & 0xffff, frag);
		}
	      else
		{
		  bfd_putl16 ((bfd_vma) ZEROS, frag);

		  if (!extended_op)
		    {
		      if (op2.reg)	/* Not PC relative.  */
			fix_new_exp (frag_now, where, 2,
				     &(op2.exp), FALSE, CHECK_RELOC_MSP430);
		      else
			fix_new_exp (frag_now, where, 2,
				     &(op2.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
		    }
		}
	    }

	  dwarf2_emit_insn (insn_length);
	  break;

	case 3:
	  /* Branch instruction => mov dst, r0.  */
	  if (extended_op)
	    {
	      as_bad ("Internal error: state 0/3 not coded for extended instructions");
	      return 0;
	    }

	  line = extract_operand (line, l1, sizeof (l1));
	  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op, extended_op, FALSE);
	  if (res)
	    break;

	  byte_op = 0;
	  imm_op = 0;
	  bin |= ((op1.reg << 8) | (op1.am << 4));
	  op_length = 2 + 2 * op1.ol;
	  frag = frag_more (op_length);
	  where = frag - frag_now->fr_literal;
	  bfd_putl16 ((bfd_vma) bin, frag);

	  if (op1.mode == OP_EXP)
	    {
	      if (op1.exp.X_op == O_constant)
		{
		  bfd_putl16 (op1.exp.X_add_number & 0xffff, frag + 2);
		}
	      else
		{
		  where += 2;

		  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);

		  if (op1.reg || (op1.reg == 0 && op1.am == 3))
		    fix_new_exp (frag_now, where, 2,
				 &(op1.exp), FALSE, CHECK_RELOC_MSP430);
		  else
		    fix_new_exp (frag_now, where, 2,
				 &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
		}
	    }

	  dwarf2_emit_insn (insn_length + op_length);
	  break;

	case 4:
	  /* CALLA instructions.  */
	  fix_emitted = FALSE;

	  line = extract_operand (line, l1, sizeof (l1));
	  imm_op = 0;

	  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op,
				   extended_op, FALSE);
	  if (res)
	    break;

	  byte_op = 0;

	  op_length = 2 + 2 * op1.ol;
	  frag = frag_more (op_length);
	  where = frag - frag_now->fr_literal;

	  if (imm_op)
	    {
	      if (op1.am == 3)
		{
		  bin |= 0xb0;

		  fix_new_exp (frag_now, where, 4, &(op1.exp), FALSE,
			       BFD_RELOC_MSP430X_ABS20_ADR_DST);
		  fix_emitted = TRUE;
		}
	      else if (op1.am == 1)
		{
		  if (op1.reg == 0)
		    {
		      bin |=  0x90;

		      fix_new_exp (frag_now, where, 4, &(op1.exp), FALSE,
				   BFD_RELOC_MSP430X_PCR20_CALL);
		      fix_emitted = TRUE;
		    }
		  else
		    bin |=  0x50 | op1.reg;
		}
	      else if (op1.am == 0)
		bin |= 0x40 | op1.reg;
	    }
	  else if (op1.am == 1)
	    {
	      bin |= 0x80;

	      fix_new_exp (frag_now, where, 4, &(op1.exp), FALSE,
			   BFD_RELOC_MSP430X_ABS20_ADR_DST);
	      fix_emitted = TRUE;
	    }
	  else if (op1.am == 2)
	    bin |= 0x60 | op1.reg;
	  else if (op1.am == 3)
	    bin |= 0x70 | op1.reg;

	  bfd_putl16 ((bfd_vma) bin, frag);

	  if (op1.mode == OP_EXP)
	    {
	      if (op1.ol != 1)
		{
		  as_bad ("Internal error: unexpected CALLA instruction length: %d\n", op1.ol);
		  return 0;
		}

	      bfd_putl16 ((bfd_vma) ZEROS, frag + 2);

	      if (! fix_emitted)
		fix_new_exp (frag_now, where + 2, 2,
			     &(op1.exp), FALSE, BFD_RELOC_16);
	    }

	  dwarf2_emit_insn (insn_length + op_length);
	  break;

	case 5:
	  {
	    int n;
	    int reg;

	    /* [POP|PUSH]M[.A] #N, Rd */
	    line = extract_operand (line, l1, sizeof (l1));
	    line = extract_operand (line, l2, sizeof (l2));

	    if (*l1 != '#')
	      {
		as_bad (_("expected #n as first argument of %s"), opcode->name);
		return 0;
	      }
	    parse_exp (l1 + 1, &(op1.exp));
	    if (op1.exp.X_op != O_constant)
	      {
		as_bad (_("expected constant expression for first argument of %s"),
			opcode->name);
		return 0;
	      }

	    if ((reg = check_reg (l2)) == -1)
	      {
		as_bad (_("expected register as second argument of %s"),
			opcode->name);
		return 0;
	      }

	    op_length = 2;
	    frag = frag_more (op_length);
	    where = frag - frag_now->fr_literal;
	    bin = opcode->bin_opcode;
	    if (! addr_op)
	      bin |= 0x100;
	    n = op1.exp.X_add_number;
	    bin |= (n - 1) << 4;
	    if (is_opcode ("pushm"))
	      bin |= reg;
	    else
	      {
		if (reg - n + 1 < 0)
		  {
		    as_bad (_("Too many registers popped"));
		    return 0;
		  }

		/* CPU21 parts cannot use POPM to restore the SR register.  */
		if (target_is_430xv2 ()
		    && (reg - n + 1 < 3)
		    && reg >= 2
		    && is_opcode ("popm"))
		  {
		    as_bad (_("Cannot use POPM to restore the SR register"));
		    return 0;
		  }

		bin |= (reg - n + 1);
	      }

	    bfd_putl16 ((bfd_vma) bin, frag);
	    dwarf2_emit_insn (op_length);
	    break;
	  }

	case 6:
	  {
	    int n;
	    int reg;

	    /* Bit rotation instructions. RRCM, RRAM, RRUM, RLAM.  */
	    if (extended & 0xff)
	      {
		as_bad (_("repeat count cannot be used with %s"), opcode->name);
		return 0;
	      }

	    line = extract_operand (line, l1, sizeof (l1));
	    line = extract_operand (line, l2, sizeof (l2));

	    if (*l1 != '#')
	      {
		as_bad (_("expected #n as first argument of %s"), opcode->name);
		return 0;
	      }
	    parse_exp (l1 + 1, &(op1.exp));
	    if (op1.exp.X_op != O_constant)
	      {
		as_bad (_("expected constant expression for first argument of %s"),
			opcode->name);
		return 0;
	      }
	    n = op1.exp.X_add_number;
	    if (n > 4 || n < 1)
	      {
		as_bad (_("expected first argument of %s to be in the range 1-4"),
			opcode->name);
		return 0;
	      }

	    if ((reg = check_reg (l2)) == -1)
	      {
		as_bad (_("expected register as second argument of %s"),
			opcode->name);
		return 0;
	      }

	    if (target_is_430xv2 () && reg == 0)
	      {
		as_bad (_("%s: attempt to rotate the PC register"), opcode->name);
		return 0;
	      }

	    op_length = 2;
	    frag = frag_more (op_length);
	    where = frag - frag_now->fr_literal;

	    bin = opcode->bin_opcode;
	    if (! addr_op)
	      bin |= 0x10;
	    bin |= (n - 1) << 10;
	    bin |= reg;

	    bfd_putl16 ((bfd_vma) bin, frag);
	    dwarf2_emit_insn (op_length);
	    break;
	  }

	case 7:
	  {
	    int reg;

	    /* RRUX: Synthetic unsigned right shift of a register by one bit.  */
	    if (extended & 0xff)
	      {
		as_bad (_("repeat count cannot be used with %s"), opcode->name);
		return 0;
	      }

	    line = extract_operand (line, l1, sizeof (l1));
	    if ((reg = check_reg (l1)) == -1)
	      {
		as_bad (_("expected register as argument of %s"),
			opcode->name);
		return 0;
	      }

	    if (target_is_430xv2 () && reg == 0)
	      {
		as_bad (_("%s: attempt to rotate the PC register"), opcode->name);
		return 0;
	      }

	    if (byte_op)
	      {
		/* Tricky - there is no single instruction that will do this.
		   Encode as: RRA.B rN { BIC.B #0x80, rN  */
		op_length = 6;
		frag = frag_more (op_length);
		where = frag - frag_now->fr_literal;
		bin = 0x1140 | reg;
		bfd_putl16 ((bfd_vma) bin, frag);
		dwarf2_emit_insn (2);
		bin = 0xc070 | reg;
		bfd_putl16 ((bfd_vma) bin, frag + 2);
		bin = 0x0080;
		bfd_putl16 ((bfd_vma) bin, frag + 4);
		dwarf2_emit_insn (4);
	      }
	    else
	      {
		/* Encode as RRUM[.A] rN.  */
		bin = opcode->bin_opcode;
		if (! addr_op)
		  bin |= 0x10;
		bin |= reg;
		op_length = 2;
		frag = frag_more (op_length);
		where = frag - frag_now->fr_literal;
		bfd_putl16 ((bfd_vma) bin, frag);
		dwarf2_emit_insn (op_length);
	      }
	    break;
	  }

	case 8:
	  {
	    bfd_boolean need_reloc = FALSE;
	    int n;
	    int reg;

	    /* ADDA, CMPA and SUBA address instructions.  */
	    if (extended & 0xff)
	      {
		as_bad (_("repeat count cannot be used with %s"), opcode->name);
		return 0;
	      }

	    line = extract_operand (line, l1, sizeof (l1));
	    line = extract_operand (line, l2, sizeof (l2));

	    bin = opcode->bin_opcode;

	    if (*l1 == '#')
	      {
		parse_exp (l1 + 1, &(op1.exp));

		if (op1.exp.X_op == O_constant)
		  {
		    n = op1.exp.X_add_number;
		    if (n > 0xfffff || n < - (0x7ffff))
		      {
			as_bad (_("expected value of first argument of %s to fit into 20-bits"),
				opcode->name);
			return 0;
		      }

		    bin |= ((n >> 16) & 0xf) << 8;
		  }
		else
		  {
		    n = 0;
		    need_reloc = TRUE;
		  }

		op_length = 4;
	      }
	    else
	      {
		if ((n = check_reg (l1)) == -1)
		  {
		    as_bad (_("expected register name or constant as first argument of %s"),
			    opcode->name);
		    return 0;
		  }

		bin |= (n << 8) | (1 << 6);
		op_length = 2;
	      }

	    if ((reg = check_reg (l2)) == -1)
	      {
		as_bad (_("expected register as second argument of %s"),
			opcode->name);
		return 0;
	      }

	    frag = frag_more (op_length);
	    where = frag - frag_now->fr_literal;
	    bin |= reg;
	    if (need_reloc)
	      fix_new_exp (frag_now, where, 4, &(op1.exp), FALSE,
			   BFD_RELOC_MSP430X_ABS20_ADR_SRC);

	    bfd_putl16 ((bfd_vma) bin, frag);
	    if (op_length == 4)
	      bfd_putl16 ((bfd_vma) (n & 0xffff), frag + 2);
	    dwarf2_emit_insn (op_length);
	    break;
	  }

	case 9: /* MOVA, BRA, RETA.  */
	  imm_op = 0;
	  bin = opcode->bin_opcode;

	  if (is_opcode ("reta"))
	    {
	      /* The RETA instruction does not take any arguments.
		 The implicit first argument is @@SP+.
		 The implicit second argument is PC.  */
	      op1.mode = OP_REG;
	      op1.am = 3;
	      op1.reg = 1;

	      op2.mode = OP_REG;
	      op2.reg = 0;
	    }
	  else
	    {
	      line = extract_operand (line, l1, sizeof (l1));
	      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode,
				       &imm_op, extended_op, FALSE);

	      if (is_opcode ("bra"))
		{
		  /* This is the BRA synthetic instruction.
		     The second argument is always PC.  */
		  op2.mode = OP_REG;
		  op2.reg = 0;
		}
	      else
		{
		  line = extract_operand (line, l2, sizeof (l2));
		  res += msp430_dstoperand (&op2, l2, opcode->bin_opcode,
					    extended_op, TRUE);
		}

	      if (res)
		break;	/* Error occurred.  All warnings were done before.  */
	    }

	  /* Only a restricted subset of the normal MSP430 addressing modes
	     are supported here, so check for the ones that are allowed.  */
	  if ((op_length = try_encode_mova (imm_op, bin, & op1, & op2,
					    & error_message)) == 0)
	    {
	      as_bad (error_message, opcode->name);
	      return 0;
	    }
	  dwarf2_emit_insn (op_length);
	  break;

	case 10: /* RPT */
	  line = extract_operand (line, l1, sizeof l1);
	  /* The RPT instruction only accepted immediates and registers.  */
	  if (*l1 == '#')
	    {
	      parse_exp (l1 + 1, &(op1.exp));
	      if (op1.exp.X_op != O_constant)
		{
		  as_bad (_("expected constant value as argument to RPT"));
		  return 0;
		}
	      if (op1.exp.X_add_number < 1
		  || op1.exp.X_add_number > (1 << 4))
		{
		  as_bad (_("expected constant in the range 2..16"));
		  return 0;
		}

	      /* We silently accept and ignore a repeat count of 1.  */
	      if (op1.exp.X_add_number > 1)
		repeat_count = op1.exp.X_add_number;
	    }
	  else
	    {
	      int reg;

	      if ((reg = check_reg (l1)) != -1)
		{
		  if (reg == 0)
		    as_warn (_("PC used as an argument to RPT"));
		  else
		    repeat_count = - reg;
		}
	      else
		{
		  as_bad (_("expected constant or register name as argument to RPT insn"));
		  return 0;
		}
	    }
	  break;

	default:
	  as_bad (_("Illegal emulated instruction "));
	  break;
	}
      break;

    case 1:			/* Format 1, double operand.  */
      line = extract_operand (line, l1, sizeof (l1));
      line = extract_operand (line, l2, sizeof (l2));
      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op, extended_op, TRUE);
      res += msp430_dstoperand (&op2, l2, opcode->bin_opcode, extended_op, TRUE);

      if (res)
	break;			/* Error occurred.  All warnings were done before.  */

      if (extended_op
	  && is_opcode ("movx")
	  && addr_op
	  && msp430_enable_relax)
	{
	  /* This is the MOVX.A instruction.  See if we can convert
	     it into the MOVA instruction instead.  This saves 2 bytes.  */
	  if ((op_length = try_encode_mova (imm_op, 0x0000, & op1, & op2,
					    NULL)) != 0)
	    {
	      dwarf2_emit_insn (op_length);
	      break;
	    }
	}

      /* Compute the entire length of the instruction in bytes.  */
      insn_length =
	(extended_op ? 2 : 0)	/* The extension word.  */
	+ 2 			/* The opcode */
	+ (2 * op1.ol)		/* The first operand. */
	+ (2 * op2.ol);		/* The second operand.  */

      frag = frag_more (insn_length);
      where = frag - frag_now->fr_literal;

      if (extended_op)
	{
	  if (!addr_op)
	    extended |= BYTE_OPERATION;

	  if ((op1.ol != 0 || op2.ol != 0) && ((extended & 0xf) != 0))
	    {
	      as_bad (_("repeat instruction used with non-register mode instruction"));
	      extended &= ~ 0xf;
	    }

	  /* If necessary, emit a reloc to update the extension word.  */
	  if (op1.mode == OP_EXP)
	    {
	      if (op1.exp.X_op == O_constant)
		extended |= ((op1.exp.X_add_number >> 16) & 0xf) << 7;

	      else  if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
		fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,
			     BFD_RELOC_MSP430X_ABS20_EXT_SRC);
	      else
		fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,
			     BFD_RELOC_MSP430X_PCR20_EXT_SRC);
	    }

	  if (op2.mode == OP_EXP)
	    {
	      if (op2.exp.X_op == O_constant)
		extended |= (op2.exp.X_add_number >> 16) & 0xf;

	      else if (op1.mode == OP_EXP)
		fix_new_exp (frag_now, where, 8, &(op2.exp), FALSE,
			     op2.reg ? BFD_RELOC_MSP430X_ABS20_EXT_ODST
			     : BFD_RELOC_MSP430X_PCR20_EXT_ODST);

	      else
		fix_new_exp (frag_now, where, 6, &(op2.exp), FALSE,
			     op2.reg ? BFD_RELOC_MSP430X_ABS20_EXT_DST
			     : BFD_RELOC_MSP430X_PCR20_EXT_DST);
	    }

	  /* Emit the extension word.  */
	  bfd_putl16 (extended, frag);
	  where += 2;
	  frag += 2;
	}

      bin |= (op2.reg | (op1.reg << 8) | (op1.am << 4) | (op2.am << 7));
      bfd_putl16 ((bfd_vma) bin, frag);
      where += 2;
      frag += 2;

      if (op1.mode == OP_EXP)
	{
	  if (op1.exp.X_op == O_constant)
	    {
	      bfd_putl16 (op1.exp.X_add_number & 0xffff, frag);
	    }
	  else
	    {
	      bfd_putl16 ((bfd_vma) ZEROS, frag);

	      if (!extended_op)
		{
		  if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
		    fix_new_exp (frag_now, where, 2,
				 &(op1.exp), FALSE, CHECK_RELOC_MSP430);
		  else
		    fix_new_exp (frag_now, where, 2,
				 &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
		}
	    }

	  where += 2;
	  frag += 2;
	}

      if (op2.mode == OP_EXP)
	{
	  if (op2.exp.X_op == O_constant)
	    {
	      bfd_putl16 (op2.exp.X_add_number & 0xffff, frag);
	    }
	  else
	    {
	      bfd_putl16 ((bfd_vma) ZEROS, frag);

	      if (!extended_op)
		{
		  if (op2.reg)		/* Not PC relative.  */
		    fix_new_exp (frag_now, where, 2,
			     &(op2.exp), FALSE, CHECK_RELOC_MSP430);
		  else
		    fix_new_exp (frag_now, where, 2,
				 &(op2.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
		}
	    }
	}

      if (gen_interrupt_nops
	  && target_is_430xv2 ()
	  && (   (is_opcode ("bic") && bin == 0xc232)
	      || (is_opcode ("bis") && bin == 0xd232)
	      || (is_opcode ("mov") && op2.mode == OP_REG && op2.reg == 2)))
	{
	  /* Emit a NOP following interrupt enable/disable.
	     See 1.3.4.1 of the MSP430x5xx User Guide.  */
	  insn_length += 2;
	  frag = frag_more (2);
	  bfd_putl16 ((bfd_vma) 0x4303 /* NOP */, frag);
	  as_warn (_("a NOP instruction has been inserted after %s"),
		   opcode->name);
	}

      dwarf2_emit_insn (insn_length);
      break;

    case 2:			/* Single-operand mostly instr.  */
      if (opcode->insn_opnumb == 0)
	{
	  /* reti instruction.  */
	  insn_length += 2;
	  frag = frag_more (2);
	  bfd_putl16 ((bfd_vma) bin, frag);
	  dwarf2_emit_insn (insn_length);
	  break;
	}

      line = extract_operand (line, l1, sizeof (l1));
      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode,
			       &imm_op, extended_op, TRUE);
      if (res)
	break;		/* Error in operand.  */

      if (target_is_430xv2 ()
	  && op1.mode == OP_REG
	  && op1.reg == 0
	  && (is_opcode ("rrax")
	      || is_opcode ("rrcx")
	      || is_opcode ("rra")
	      || is_opcode ("rrc")))
	{
	  as_bad (_("%s: attempt to rotate the PC register"), opcode->name);
	  return 0;
	}

      insn_length = (extended_op ? 2 : 0) + 2 + (op1.ol * 2);
      frag = frag_more (insn_length);
      where = frag - frag_now->fr_literal;

      if (extended_op)
	{
	  if (is_opcode ("swpbx") || is_opcode ("sxtx"))
	    {
	      /* These two instructions use a special
		 encoding of the A/L and B/W bits.  */
	      bin &= ~ BYTE_OPERATION;

	      if (byte_op)
		{
		  as_bad (_("%s instruction does not accept a .b suffix"),
			  opcode->name);
		  return 0;
		}
	      else if (! addr_op)
		extended |= BYTE_OPERATION;
	    }
	  else if (! addr_op)
	    extended |= BYTE_OPERATION;

	  if (op1.ol != 0 && ((extended & 0xf) != 0))
	    {
	      as_bad (_("repeat instruction used with non-register mode instruction"));
	      extended &= ~ 0xf;
	    }

	  if (op1.mode == OP_EXP)
	    {
	      if (op1.exp.X_op == O_constant)
		extended |= ((op1.exp.X_add_number >> 16) & 0xf) << 7;

	      else if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
		fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,
			     BFD_RELOC_MSP430X_ABS20_EXT_SRC);
	      else
		fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,
			     BFD_RELOC_MSP430X_PCR20_EXT_SRC);
	    }

	  /* Emit the extension word.  */
	  bfd_putl16 (extended, frag);
	  frag += 2;
	  where += 2;
	}

      bin |= op1.reg | (op1.am << 4);
      bfd_putl16 ((bfd_vma) bin, frag);
      frag += 2;
      where += 2;

      if (op1.mode == OP_EXP)
	{
	  if (op1.exp.X_op == O_constant)
	    {
	      bfd_putl16 (op1.exp.X_add_number & 0xffff, frag);
	    }
	  else
	    {
	      bfd_putl16 ((bfd_vma) ZEROS, frag);

	      if (!extended_op)
		{
		  if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
		    fix_new_exp (frag_now, where, 2,
				 &(op1.exp), FALSE, CHECK_RELOC_MSP430);
		  else
		    fix_new_exp (frag_now, where, 2,
				 &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
		}
	    }
	}

      dwarf2_emit_insn (insn_length);
      break;

    case 3:			/* Conditional jumps instructions.  */
      line = extract_operand (line, l1, sizeof (l1));
      /* l1 is a label.  */
      if (l1[0])
	{
	  char *m = l1;
	  expressionS exp;

	  if (*m == '$')
	    m++;

	  parse_exp (m, &exp);

	  /* In order to handle something like:

	     and #0x8000, r5
	     tst r5
	     jz   4     ;       skip next 4 bytes
	     inv r5
	     inc r5
	     nop        ;       will jump here if r5 positive or zero

	     jCOND      -n      ;assumes jump n bytes backward:

	     mov r5,r6
	     jmp -2

	     is equal to:
	     lab:
	     mov r5,r6
	     jmp lab

	     jCOND      $n      ; jump from PC in either direction.  */

	  if (exp.X_op == O_constant)
	    {
	      int x = exp.X_add_number;

	      if (x & 1)
		{
		  as_warn (_("Even number required. Rounded to %d"), x + 1);
		  x++;
		}

	      if ((*l1 == '$' && x > 0) || x < 0)
		x -= 2;

	      x >>= 1;

	      if (x > 512 || x < -511)
		{
		  as_bad (_("Wrong displacement  %d"), x << 1);
		  break;
		}

	      insn_length += 2;
	      frag = frag_more (2);	/* Instr size is 1 word.  */

	      bin |= x & 0x3ff;
	      bfd_putl16 ((bfd_vma) bin, frag);
	    }
	  else if (exp.X_op == O_symbol && *l1 != '$')
	    {
	      insn_length += 2;
	      frag = frag_more (2);	/* Instr size is 1 word.  */
	      where = frag - frag_now->fr_literal;
	      fix_new_exp (frag_now, where, 2,
			   &exp, TRUE, BFD_RELOC_MSP430_10_PCREL);

	      bfd_putl16 ((bfd_vma) bin, frag);
	    }
	  else if (*l1 == '$')
	    {
	      as_bad (_("instruction requires label sans '$'"));
	    }
	  else
	    as_bad (_
		    ("instruction requires label or value in range -511:512"));
	  dwarf2_emit_insn (insn_length);
	  break;
	}
      else
	{
	  as_bad (_("instruction requires label"));
	  break;
	}
      break;

    case 4:	/* Extended jumps.  */
      if (!msp430_enable_polys)
	{
	  as_bad (_("polymorphs are not enabled. Use -mP option to enable."));
	  break;
	}
	
      line = extract_operand (line, l1, sizeof (l1));
      if (l1[0])
	{
	  char *m = l1;
	  expressionS exp;

	  /* Ignore absolute addressing. make it PC relative anyway.  */
	  if (*m == '#' || *m == '$')
	    m++;

	  parse_exp (m, & exp);
	  if (exp.X_op == O_symbol)
	    {
	      /* Relaxation required.  */
	      struct rcodes_s rc = msp430_rcodes[opcode->insn_opnumb];

	      if (target_is_430x ())
		rc = msp430x_rcodes[opcode->insn_opnumb];

	      /* The parameter to dwarf2_emit_insn is actually the offset to
		 the start of the insn from the fix piece of instruction that
		 was emitted.  Since next fragments may have variable size we
		 tie debug info to the beginning of the instruction.  */
	      insn_length += 8;
	      frag = frag_more (8);
	      dwarf2_emit_insn (0);
	      bfd_putl16 ((bfd_vma) rc.sop, frag);
	      frag = frag_variant (rs_machine_dependent, 8, 2,
				    /* Wild guess.  */
				   ENCODE_RELAX (rc.lpos, STATE_BITS10),
				   exp.X_add_symbol,
				   0,	/* Offset is zero if jump dist less than 1K.  */
				   (char *) frag);
	      break;
	    }
	}

      as_bad (_("instruction requires label"));
      break;

    case 5:	/* Emulated extended branches.  */
      if (!msp430_enable_polys)
	{
	  as_bad (_("polymorphs are not enabled. Use -mP option to enable."));
	  break;
	}
      line = extract_operand (line, l1, sizeof (l1));
      if (l1[0])
	{
	  char * m = l1;
	  expressionS exp;

	  /* Ignore absolute addressing. make it PC relative anyway.  */
	  if (*m == '#' || *m == '$')
	    m++;

	  parse_exp (m, & exp);
	  if (exp.X_op == O_symbol)
	    {
	      /* Relaxation required.  */
	      struct hcodes_s hc = msp430_hcodes[opcode->insn_opnumb];

	      if (target_is_430x ())
		hc = msp430x_hcodes[opcode->insn_opnumb];

	      insn_length += 8;
	      frag = frag_more (8);
	      dwarf2_emit_insn (0);
	      bfd_putl16 ((bfd_vma) hc.op0, frag);
	      bfd_putl16 ((bfd_vma) hc.op1, frag+2);

	      frag = frag_variant (rs_machine_dependent, 8, 2,
				   ENCODE_RELAX (STATE_EMUL_BRANCH, STATE_BITS10), /* Wild guess.  */
				   exp.X_add_symbol,
				   0,	/* Offset is zero if jump dist less than 1K.  */
				   (char *) frag);
	      break;
	    }
	}

      as_bad (_("instruction requires label"));
      break;

    default:
      as_bad (_("Illegal instruction or not implemented opcode."));
    }

  input_line_pointer = line;
  return 0;
}

void
md_assemble (char * str)
{
  struct msp430_opcode_s * opcode;
  char cmd[32];
  unsigned int i = 0;

  str = skip_space (str);	/* Skip leading spaces.  */
  str = extract_cmd (str, cmd, sizeof (cmd));

  while (cmd[i] && i < sizeof (cmd))
    {
      char a = TOLOWER (cmd[i]);
      cmd[i] = a;
      i++;
    }

  if (!cmd[0])
    {
      as_bad (_("can't find opcode "));
      return;
    }

  opcode = (struct msp430_opcode_s *) hash_find (msp430_hash, cmd);

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode `%s'"), cmd);
      return;
    }

  {
    char *__t = input_line_pointer;

    msp430_operands (opcode, str);
    input_line_pointer = __t;
  }
}

/* GAS will call this function for each section at the end of the assembly,
   to permit the CPU backend to adjust the alignment of a section.  */

valueT
md_section_align (asection * seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);

  return ((addr + (1 << align) - 1) & (-1 << align));
}

/* If you define this macro, it should return the offset between the
   address of a PC relative fixup and the position from which the PC
   relative adjustment should be made.  On many processors, the base
   of a PC relative instruction is the next instruction, so this
   macro would return the length of an instruction.  */

long
md_pcrel_from_section (fixS * fixp, segT sec)
{
  if (fixp->fx_addsy != (symbolS *) NULL
      && (!S_IS_DEFINED (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
    return 0;

  return fixp->fx_frag->fr_address + fixp->fx_where;
}

/* Replaces standard TC_FORCE_RELOCATION_LOCAL.
   Now it handles the situation when relocations
   have to be passed to linker.  */
int
msp430_force_relocation_local (fixS *fixp)
{
  if (fixp->fx_r_type == BFD_RELOC_MSP430_10_PCREL)
    return 1;
  if (fixp->fx_pcrel)
    return 1;
  if (msp430_enable_polys
        && !msp430_enable_relax)
    return 1;

  return (!fixp->fx_pcrel
	  || generic_force_reloc (fixp));
}


/* GAS will call this for each fixup.  It should store the correct
   value in the object file.  */
void
md_apply_fix (fixS * fixp, valueT * valuep, segT seg)
{
  unsigned char * where;
  unsigned long insn;
  long value;

  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    {
      segT s = S_GET_SEGMENT (fixp->fx_addsy);

      if (fixp->fx_addsy && (s == seg || s == absolute_section))
	{
	  /* FIXME: We can appear here only in case if we perform a pc
	     relative jump to the label which is i) global, ii) locally
	     defined or this is a jump to an absolute symbol.
	     If this is an absolute symbol -- everything is OK.
	     If this is a global label, we've got a symbol value defined
	     twice:
               1. S_GET_VALUE (fixp->fx_addsy) will contain a symbol offset
	          from this section start
               2. *valuep will contain the real offset from jump insn to the
	          label
	     So, the result of S_GET_VALUE (fixp->fx_addsy) + (* valuep);
	     will be incorrect. Therefore remove s_get_value.  */
	  value = /* S_GET_VALUE (fixp->fx_addsy) + */ * valuep;
	  fixp->fx_done = 1;
	}
      else
	value = *valuep;
    }
  else
    {
      value = fixp->fx_offset;

      if (fixp->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    {
	      value -= S_GET_VALUE (fixp->fx_subsy);
	      fixp->fx_done = 1;
	    }
	}
    }

  fixp->fx_no_overflow = 1;

  /* If polymorphs are enabled and relax disabled.
     do not kill any relocs and pass them to linker.  */
  if (msp430_enable_polys
      && !msp430_enable_relax)
    {
      if (!fixp->fx_addsy || (fixp->fx_addsy
	  && S_GET_SEGMENT (fixp->fx_addsy) == absolute_section))
	fixp->fx_done = 1;	/* It is ok to kill 'abs' reloc.  */
      else
      	fixp->fx_done = 0;
    }

  if (fixp->fx_done)
    {
      /* Fetch the instruction, insert the fully resolved operand
	 value, and stuff the instruction back again.  */
      where = (unsigned char *) fixp->fx_frag->fr_literal + fixp->fx_where;

      insn = bfd_getl16 (where);

      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_MSP430_10_PCREL:
	  if (value & 1)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("odd address operand: %ld"), value);

	  /* Jumps are in words.  */
	  value >>= 1;
	  --value;		/* Correct PC.  */

	  if (value < -512 || value > 511)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("operand out of range: %ld"), value);

	  value &= 0x3ff;	/* get rid of extended sign */
	  bfd_putl16 ((bfd_vma) (value | insn), where);
	  break;

	case BFD_RELOC_MSP430X_PCR16:
	case BFD_RELOC_MSP430_RL_PCREL:
	case BFD_RELOC_MSP430_16_PCREL:
	  if (value & 1)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("odd address operand: %ld"), value);
	  /* Fall through.  */

	case BFD_RELOC_MSP430_16_PCREL_BYTE:
	  /* Nothing to be corrected here.  */
	  if (value < -32768 || value > 65536)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("operand out of range: %ld"), value);
	  /* Fall through.  */

	case BFD_RELOC_MSP430X_ABS16:
	case BFD_RELOC_MSP430_16:
	case BFD_RELOC_16:
	case BFD_RELOC_MSP430_16_BYTE:
	  value &= 0xffff;	/* Get rid of extended sign.  */
	  bfd_putl16 ((bfd_vma) value, where);
	  break;

	case BFD_RELOC_32:
	  bfd_putl16 ((bfd_vma) value, where);
	  break;

	case BFD_RELOC_MSP430_ABS8:
	case BFD_RELOC_8:
	  bfd_put_8 (NULL, (bfd_vma) value, where);
	  break;

	case BFD_RELOC_MSP430X_ABS20_EXT_SRC:
	case BFD_RELOC_MSP430X_PCR20_EXT_SRC:
	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 4);
	  value >>= 16;
	  bfd_putl16 ((bfd_vma) (((value & 0xf) << 7) | insn), where);
	  break;

	case BFD_RELOC_MSP430X_ABS20_ADR_SRC:
	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 2);
	  value >>= 16;
	  bfd_putl16 ((bfd_vma) (((value & 0xf) << 8) | insn), where);
	  break;

	case BFD_RELOC_MSP430X_ABS20_EXT_ODST:
	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 6);
	  value >>= 16;
	  bfd_putl16 ((bfd_vma) ((value & 0xf) | insn), where);
	  break;

	case BFD_RELOC_MSP430X_PCR20_CALL:
	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 2);
	  value >>= 16;
	  bfd_putl16 ((bfd_vma) ((value & 0xf) | insn), where);
	  break;

	case BFD_RELOC_MSP430X_ABS20_EXT_DST:
	case BFD_RELOC_MSP430X_PCR20_EXT_DST:
	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 4);
	  value >>= 16;
	  bfd_putl16 ((bfd_vma) ((value & 0xf) | insn), where);
	  break;

	case BFD_RELOC_MSP430X_PCR20_EXT_ODST:
	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 6);
	  value >>= 16;
	  bfd_putl16 ((bfd_vma) ((value & 0xf) | insn), where);
	  break;

	case BFD_RELOC_MSP430X_ABS20_ADR_DST:
	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 2);
	  value >>= 16;
	  bfd_putl16 ((bfd_vma) ((value & 0xf) | insn), where);
	  break;

	default:
	  as_fatal (_("line %d: unknown relocation type: 0x%x"),
		    fixp->fx_line, fixp->fx_r_type);
	  break;
	}
    }
  else
    {
      fixp->fx_addnumber = value;
    }
}

static bfd_boolean
S_IS_GAS_LOCAL (symbolS * s)
{
  const char * name;
  unsigned int len;

  if (s == NULL)
    return FALSE;
  name = S_GET_NAME (s);
  len = strlen (name) - 1;

  return name[len] == 1 || name[len] == 2;
}

/* GAS will call this to generate a reloc, passing the resulting reloc
   to `bfd_install_relocation'.  This currently works poorly, as
   `bfd_install_relocation' often does the wrong thing, and instances of
   `tc_gen_reloc' have been written to work around the problems, which
   in turns makes it difficult to fix `bfd_install_relocation'.  */

/* If while processing a fixup, a reloc really needs to be created
   then it is done here.  */

arelent **
tc_gen_reloc (asection * seg ATTRIBUTE_UNUSED, fixS * fixp)
{
  static arelent * no_relocs = NULL;
  static arelent * relocs[MAX_RELOC_EXPANSION + 1];
  arelent *reloc;

  reloc = xmalloc (sizeof (arelent));
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      free (reloc);
      return & no_relocs;
    }

  relocs[0] = reloc;
  relocs[1] = NULL;

  if (fixp->fx_subsy
      && S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
    {
      fixp->fx_offset -= S_GET_VALUE (fixp->fx_subsy);
      fixp->fx_subsy = NULL;
    }

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      asection *asec, *ssec;

      asec = S_GET_SEGMENT (fixp->fx_addsy);
      ssec = S_GET_SEGMENT (fixp->fx_subsy);

      /* If we have a difference between two different, non-absolute symbols
	 we must generate two relocs (one for each symbol) and allow the
	 linker to resolve them - relaxation may change the distances between
	 symbols, even local symbols defined in the same section.

	 Unfortunately we cannot do this with assembler generated local labels
	 because there can be multiple incarnations of the same label, with
	 exactly the same name, in any given section and the linker will have
	 no way to identify the correct one.  Instead we just have to hope
	 that no relaxtion will occur between the local label and the other
	 symbol in the expression.

	 Similarly we have to compute differences between symbols in the .eh_frame
	 section as the linker is not smart enough to apply relocations there
	 before attempting to process it.  */
      if ((ssec != absolute_section || asec != absolute_section)
	  && (fixp->fx_addsy != fixp->fx_subsy)
	  && strcmp (ssec->name, ".eh_frame") != 0
	  && ! S_IS_GAS_LOCAL (fixp->fx_addsy)
	  && ! S_IS_GAS_LOCAL (fixp->fx_subsy))
	{
	  arelent * reloc2 = xmalloc (sizeof * reloc);

	  relocs[0] = reloc2;
	  relocs[1] = reloc;

	  reloc2->address = reloc->address;
	  reloc2->howto = bfd_reloc_type_lookup (stdoutput,
						 BFD_RELOC_MSP430_SYM_DIFF);
	  reloc2->addend = - S_GET_VALUE (fixp->fx_subsy);

	  if (ssec == absolute_section)
	    reloc2->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	  else
	    {
	      reloc2->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	      *reloc2->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_subsy);
	    }

	  reloc->addend = fixp->fx_offset;
	  if (asec == absolute_section)
	    {
	      reloc->addend += S_GET_VALUE (fixp->fx_addsy);
	      reloc->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	    }
	  else
	    {
	      reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
	    }

	  fixp->fx_pcrel = 0;
	  fixp->fx_done = 1;
	  return relocs;
	}
      else
	{
	  char *fixpos = fixp->fx_where + fixp->fx_frag->fr_literal;

	  reloc->addend = (S_GET_VALUE (fixp->fx_addsy)
			   - S_GET_VALUE (fixp->fx_subsy) + fixp->fx_offset);

	  switch (fixp->fx_r_type)
	    {
	    case BFD_RELOC_8:
	      md_number_to_chars (fixpos, reloc->addend, 1);
	      break;

	    case BFD_RELOC_16:
	      md_number_to_chars (fixpos, reloc->addend, 2);
	      break;

	    case BFD_RELOC_24:
	      md_number_to_chars (fixpos, reloc->addend, 3);
	      break;

	    case BFD_RELOC_32:
	      md_number_to_chars (fixpos, reloc->addend, 4);
	      break;

	    default:
	      reloc->sym_ptr_ptr
		= (asymbol **) bfd_abs_section_ptr->symbol_ptr_ptr;
	      return relocs;
	    }

	  free (reloc);
	  return & no_relocs;
	}
    }
  else
    {
#if 0
      if (fixp->fx_r_type == BFD_RELOC_MSP430X_ABS16
	  && S_GET_SEGMENT (fixp->fx_addsy) == absolute_section)
	{
	  bfd_vma amount = S_GET_VALUE (fixp->fx_addsy);
	  char *fixpos = fixp->fx_where + fixp->fx_frag->fr_literal;

	  md_number_to_chars (fixpos, amount, 2);
	  free (reloc);
	  return & no_relocs;
	}
#endif
      reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->addend = fixp->fx_offset;

      if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
	  || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
	reloc->address = fixp->fx_offset;
    }

  return relocs;
}

int
md_estimate_size_before_relax (fragS * fragP ATTRIBUTE_UNUSED,
			       asection * segment_type ATTRIBUTE_UNUSED)
{
  if (fragP->fr_symbol && S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
    {
      /* This is a jump -> pcrel mode. Nothing to do much here.
         Return value == 2.  */
      fragP->fr_subtype =
	  ENCODE_RELAX (RELAX_LEN (fragP->fr_subtype), STATE_BITS10);
    }
  else if (fragP->fr_symbol)
    {
      /* Its got a segment, but its not ours.   Even if fr_symbol is in
	 an absolute segment, we don't know a displacement until we link
	 object files. So it will always be long. This also applies to
	 labels in a subsegment of current. Liker may relax it to short
	 jump later. Return value == 8.  */
      fragP->fr_subtype =
	  ENCODE_RELAX (RELAX_LEN (fragP->fr_subtype), STATE_WORD);
    }
  else
    {
      /* We know the abs value. may be it is a jump to fixed address.
         Impossible in our case, cause all constants already handled. */
      fragP->fr_subtype =
	  ENCODE_RELAX (RELAX_LEN (fragP->fr_subtype), STATE_UNDEF);
    }

  return md_relax_table[fragP->fr_subtype].rlx_length;
}

void
md_convert_frag (bfd * abfd ATTRIBUTE_UNUSED,
		 asection * sec ATTRIBUTE_UNUSED,
		 fragS * fragP)
{
  char * where = 0;
  int rela = -1;
  int i;
  struct rcodes_s * cc = NULL;
  struct hcodes_s * hc = NULL;

  switch (fragP->fr_subtype)
    {
    case ENCODE_RELAX (STATE_UNCOND_BRANCH, STATE_BITS10):
    case ENCODE_RELAX (STATE_SIMPLE_BRANCH, STATE_BITS10):
    case ENCODE_RELAX (STATE_NOOV_BRANCH, STATE_BITS10):
      /* We do not have to convert anything here.
         Just apply a fix.  */
      rela = BFD_RELOC_MSP430_10_PCREL;
      break;

    case ENCODE_RELAX (STATE_UNCOND_BRANCH, STATE_WORD):
    case ENCODE_RELAX (STATE_UNCOND_BRANCH, STATE_UNDEF):
      /* Convert uncond branch jmp lab -> br lab.  */
      if (target_is_430x ())
	cc = msp430x_rcodes + 7;
      else
	cc = msp430_rcodes + 7;
      where = fragP->fr_literal + fragP->fr_fix;
      bfd_putl16 (cc->lop0, where);
      rela = BFD_RELOC_MSP430_RL_PCREL;
      fragP->fr_fix += 2;
      break;

    case ENCODE_RELAX (STATE_SIMPLE_BRANCH, STATE_WORD):
    case ENCODE_RELAX (STATE_SIMPLE_BRANCH, STATE_UNDEF):
      {
	/* Other simple branches.  */
	int insn = bfd_getl16 (fragP->fr_opcode);

	insn &= 0xffff;
	/* Find actual instruction.  */
	if (target_is_430x ())
	  {
	    for (i = 0; i < 7 && !cc; i++)
	      if (msp430x_rcodes[i].sop == insn)
		cc = msp430x_rcodes + i;
	  }
	else
	  {
	    for (i = 0; i < 7 && !cc; i++)
	      if (msp430_rcodes[i].sop == insn)
		cc = & msp430_rcodes[i];
	  }

	if (!cc || !cc->name)
	  as_fatal (_("internal inconsistency problem in %s: insn %04lx"),
		    __FUNCTION__, (long) insn);
	where = fragP->fr_literal + fragP->fr_fix;
	bfd_putl16 (cc->lop0, where);
	bfd_putl16 (cc->lop1, where + 2);
	rela = BFD_RELOC_MSP430_RL_PCREL;
	fragP->fr_fix += 4;
      }
      break;

    case ENCODE_RELAX (STATE_NOOV_BRANCH, STATE_WORD):
    case ENCODE_RELAX (STATE_NOOV_BRANCH, STATE_UNDEF):
      if (target_is_430x ())
	cc = msp430x_rcodes + 6;
      else
	cc = msp430_rcodes + 6;
      where = fragP->fr_literal + fragP->fr_fix;
      bfd_putl16 (cc->lop0, where);
      bfd_putl16 (cc->lop1, where + 2);
      bfd_putl16 (cc->lop2, where + 4);
      rela = BFD_RELOC_MSP430_RL_PCREL;
      fragP->fr_fix += 6;
      break;

    case ENCODE_RELAX (STATE_EMUL_BRANCH, STATE_BITS10):
      {
	int insn = bfd_getl16 (fragP->fr_opcode + 2);

	insn &= 0xffff;
	if (target_is_430x ())
	  {
	    for (i = 0; i < 4 && !hc; i++)
	      if (msp430x_hcodes[i].op1 == insn)
		hc = msp430x_hcodes + i;
	  }
	else
	  {
	    for (i = 0; i < 4 && !hc; i++)
	      if (msp430_hcodes[i].op1 == insn)
		hc = &msp430_hcodes[i];
	  }
	if (!hc || !hc->name)
	  as_fatal (_("internal inconsistency problem in %s: ext. insn %04lx"),
	      __FUNCTION__, (long) insn);
	rela = BFD_RELOC_MSP430_10_PCREL;
	/* Apply a fix for a first label if necessary.
	   another fix will be applied to the next word of insn anyway.  */
	if (hc->tlab == 2)
	  fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		   fragP->fr_offset, TRUE, rela);
	fragP->fr_fix += 2;
      }

      break;

    case ENCODE_RELAX (STATE_EMUL_BRANCH, STATE_WORD):
    case ENCODE_RELAX (STATE_EMUL_BRANCH, STATE_UNDEF):
      {
	int insn = bfd_getl16 (fragP->fr_opcode + 2);

	insn &= 0xffff;
	if (target_is_430x ())
	  {
	    for (i = 0; i < 4 && !hc; i++)
	      if (msp430x_hcodes[i].op1 == insn)
		hc = msp430x_hcodes + i;
	  }
	else
	  {
	    for (i = 0; i < 4 && !hc; i++)
	      if (msp430_hcodes[i].op1 == insn)
		hc = & msp430_hcodes[i];
	  }
	if (!hc || !hc->name)
	  as_fatal (_("internal inconsistency problem in %s: ext. insn %04lx"),
	      __FUNCTION__, (long) insn);
	rela = BFD_RELOC_MSP430_RL_PCREL;
	where = fragP->fr_literal + fragP->fr_fix;
	bfd_putl16 (hc->lop0, where);
	bfd_putl16 (hc->lop1, where + 2);
	bfd_putl16 (hc->lop2, where + 4);
	fragP->fr_fix += 6;
      }
      break;

    default:
      as_fatal (_("internal inconsistency problem in %s:  %lx"),
		__FUNCTION__, (long) fragP->fr_subtype);
      break;
    }

  /* Now apply fix.  */
  fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
	   fragP->fr_offset, TRUE, rela);
  /* Just fixed 2 bytes.  */
  fragP->fr_fix += 2;
}

/* Relax fragment. Mostly stolen from hc11 and mcore
   which arches I think I know.  */

long
msp430_relax_frag (segT seg ATTRIBUTE_UNUSED, fragS * fragP,
		   long stretch ATTRIBUTE_UNUSED)
{
  long growth;
  offsetT aim = 0;
  symbolS *symbolP;
  const relax_typeS *this_type;
  const relax_typeS *start_type;
  relax_substateT next_state;
  relax_substateT this_state;
  const relax_typeS *table = md_relax_table;

  /* Nothing to be done if the frag has already max size.  */
  if (RELAX_STATE (fragP->fr_subtype) == STATE_UNDEF
      || RELAX_STATE (fragP->fr_subtype) == STATE_WORD)
    return 0;

  if (RELAX_STATE (fragP->fr_subtype) == STATE_BITS10)
    {
      symbolP = fragP->fr_symbol;
      if (symbol_resolved_p (symbolP))
	as_fatal (_("internal inconsistency problem in %s: resolved symbol"),
		  __FUNCTION__);
      /* We know the offset. calculate a distance.  */
      aim = S_GET_VALUE (symbolP) - fragP->fr_address - fragP->fr_fix;
    }

  if (!msp430_enable_relax)
    {
      /* Relaxation is not enabled. So, make all jump as long ones
         by setting 'aim' to quite high value.  */
      aim = 0x7fff;
    }

  this_state = fragP->fr_subtype;
  start_type = this_type = table + this_state;

  if (aim < 0)
    {
      /* Look backwards.  */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim >= this_type->rlx_backward || !this_type->rlx_backward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state.  */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }
  else
    {
      /* Look forwards.  */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim <= this_type->rlx_forward || !this_type->rlx_forward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state.  */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }

  growth = this_type->rlx_length - start_type->rlx_length;
  if (growth != 0)
    fragP->fr_subtype = this_state;
  return growth;
}

/* Return FALSE if the fixup in fixp should be left alone and not
   adjusted.   We return FALSE here so that linker relaxation will
   work.  */

bfd_boolean
msp430_fix_adjustable (struct fix *fixp ATTRIBUTE_UNUSED)
{
  /* If the symbol is in a non-code section then it should be OK.  */
  if (fixp->fx_addsy
      && ((S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_CODE) == 0))
    return TRUE;

  return FALSE;
}

/* Set the contents of the .MSP430.attributes section.  */

void
msp430_md_end (void)
{
  bfd_elf_add_proc_attr_int (stdoutput, OFBA_MSPABI_Tag_ISA,
			     target_is_430x () ? 2 : 1);

  bfd_elf_add_proc_attr_int (stdoutput, OFBA_MSPABI_Tag_Code_Model,
			     large_model ? 2 : 1);

  bfd_elf_add_proc_attr_int (stdoutput, OFBA_MSPABI_Tag_Data_Model,
			     large_model ? 2 : 1);
}

/* Returns FALSE if there is a msp430 specific reason why the
   subtraction of two same-section symbols cannot be computed by
   the assembler.  */

bfd_boolean
msp430_allow_local_subtract (expressionS * left,
			     expressionS * right,
			     segT section)
{
  /* If the symbols are not in a code section then they are OK.  */
  if ((section->flags & SEC_CODE) == 0)
    return TRUE;

  if (S_IS_GAS_LOCAL (left->X_add_symbol) || S_IS_GAS_LOCAL (right->X_add_symbol))
    return TRUE;

  if (left->X_add_symbol == right->X_add_symbol)
    return TRUE;

  /* We have to assume that there may be instructions between the
     two symbols and that relaxation may increase the distance between
     them.  */
  return FALSE;
}
@


1.38
log
@	* config/tc-msp430.c (OPTION_MOVE_DATA): Define.
	(move_data): New variable.
	(md_parse_option): Parse -md.
	(msp430_section): New function.  Catch references to the .bss or
	.data sections and generate a special symbol for use by the libcrt
	library.
	(md_pseudo_table): Intercept .section directives.
	(md_longopt): Add -md
	(md_show_usage): Likewise.
	(msp430_operands): Generate a warning message if a NOP is inserted
	into the instruction stream.
	* doc/c-msp430.texi (node MSP430 Options): Document -md option.
@
text
@d488 4
d719 1
a719 1
    
d1203 1
a1203 1
      
d2144 46
a2189 5
  /* Check if byte or word operation.  */
  if (*line == '.' && TOLOWER (*(line + 1)) == 'b')
    {
      bin |= BYTE_OPERATION;
      byte_op = 1;
a2190 2
  else
    byte_op = 0;
d2192 1
a2192 2
  /* "Address" ops work on 20-bit values.  */
  if (*line == '.' && TOLOWER (*(line + 1)) == 'a')
d2194 3
a2196 2
      addr_op = TRUE;
      bin |= BYTE_OPERATION;
a2197 2
  else
    addr_op = FALSE;
d2199 24
a2222 3
  /* skip .[aAbwBW].  */
  while (! ISSPACE (*line) && *line)
    line++;
d2317 1
a2317 1
	  
d2328 1
a2328 1
	      
d2341 1
a2341 1
	  
d2409 1
a2409 1
	      && op1.reg == 0 
d2418 1
a2418 1
	  
d2429 1
a2429 1
	      
d2548 1
a2548 1
	      
d2619 1
a2619 1
	  
d2821 1
a2821 1
	      }	    
d2900 1
a2900 1
	  
d2936 1
a2936 1
	  
d3032 1
a3032 1
      
d3057 1
a3057 1
	  
d3067 1
a3067 1
	    
d3169 1
a3169 1
	  && op1.reg == 0 
d3178 1
a3178 1
      
d3182 1
a3182 1
      
d3213 1
a3213 1
	  
d3221 1
a3221 1
	  
d3584 1
a3584 1
  /* If polymorphs are enabled and relax disabled. 
d3586 1
a3586 1
  if (msp430_enable_polys 
d3589 1
a3589 1
      if (!fixp->fx_addsy || (fixp->fx_addsy 
d3658 1
a3658 1
	  value >>= 16;	  
d3664 1
a3664 1
	  value >>= 16;	  
d3698 1
a3698 1
	  
d3721 1
a3721 1
  
d3810 1
a3810 1
	  reloc->addend = fixp->fx_offset; 
d4110 1
a4110 1
  
d4160 1
a4160 1
	   
@


1.37
log
@	* config/tc-msp430.c (msp430_srcoperand): Do not allow the use of
	the PC in indirect addressing on 430xv2 parts.
	(msp430_operands): Add version test to hardware bug encoding
	restrictions.
@
text
@d1126 2
d1215 4
d1224 19
d1248 5
d1266 1
d1286 2
d2237 2
d2323 2
d3081 2
@


1.36
log
@	* config/tc-msp430.c: Make -mmcu recognise more part numbers.
	Add -mcpu command to specify core type.
	* doc/c-msp430.c: Update documentation.
	* gas/msp430/opcodes.s: Use correct value for .arch pseudo.
	* gas/msp430/msp430x.d: Use correct value for -mcpu option.
@
text
@a1217 1

d1651 6
d2308 2
a2309 2
	  /* Issue 3831743.  */
	  if (op1.mode == OP_REG
d2588 2
a2589 2
		/* Issue 3831713:  CPU21 parts cannot use POPM to restore the SR register.  */
		if (target_is_430x ()
d2648 1
a2648 2
	    /* Issue 3831743.  */
	    if (reg == 0)
d2688 1
a2688 2
	    /* Issue 3831743.  */
	    if (reg == 0)
d3066 2
a3067 2
      /* Issue 3831743.  */
      if (op1.mode == OP_REG
@


1.35
log
@	* archures.c: Add some more MSP430 machine numbers.
	* config.bfd (msp430): Define targ_selvecs.
	* configure.in: Add bfd_elf32_msp430_ti_vec.
	* cpu-msp430.c: Add some more MSP430 machine numbers.
	* elf32-msp430.c Add support for MSP430X relocations.
	Add support for TI compiler generated relocations.
	Add support for sym_diff relocations.
	Add support for relaxing out of range short branches into long
	branches.
	Add support for MSP430 attribute section.
	* reloc.c: Add MSP430X relocations.
	* targets.c: Add bfd_elf32_msp430_ti_vec.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* libbfd.h: Regenerate.

	* readelf.c: Add support for MSP430X architecture.

	* readelf.exp: Expect -wi test to fail for the MSP430.

	* config/tc-msp430.c: Add support for the MSP430X architecture.
	Add code to insert a NOP instruction after any instruction that
	might change the interrupt state.
	Add support for the LARGE memory model.
	Add code to initialise the .MSP430.attributes section.
	* config/tc-msp430.h: Add support for the MSP430X architecture.
	* doc/c-msp430.texi: Document the new -mL and -mN command line
	options.
	* NEWS: Mention support for the MSP430X architecture.

	* gas/all/gas.exp: Skip the DIFF1 test for the MSP430.
	Expect the FORWARD test to pass for the MSP430.
	Skip the REDEF tests for the MSP430.
	Expect the 930509A test to fail for the MSP430.
	* gas/all/sleb128-4.d: Skip for the MSP430.
	* gas/elf/elf.exp: Set target_machine to msp430 for the MSP430.
	Skip the EHOPT0 test for the MSP430.
	Skip the REDEF and EQU-RELOC tests for the MSP430.
	* gas/elf/section2.e-msp430: New file.
	* gas/lns/lns-big-delta.d: Remove expectation of 20-bit
	addresses.
	* gas/lns/lns.exp: Use alternate LNS COMMON test for the MSP430.
	* gas/msp430/msp430x.s: New test.
	* gas/msp430/msp430x.d: Expected disassembly.
	* gas/msp430/msp430.exp: Run new test.
	* gas/msp430/opcode.d: Update expected disassembly.

	* msp430.h: Add MSP430X relocs.
	Add some more MSP430 machine numbers.
	Add values used by .MSP430.attributes section.

	* msp430.h: Add patterns for MSP430X instructions.

	* Makefile.am: Add emsp430X.c
	* Makefine.in: Regenerate.
	* configure.tgt (msp430): Add msp430X emulation.
	* ldmain.c (multiple_definition): Only disable relaxation if it
	was enabled by the user.
	* ldmain.h (RELAXATION_ENABLED_BY_USER): New macro.
	* emulparams/msp430all.sh: Add support for MSP430X.
	* emultempl/generic.em: (before_parse): Enable relaxation for the
	MSP430.
	* scripttempl/msp430.sc: Reorganize sections.  Add .rodata
	section.
	* scripttempl/msp430_3.sc: Likewise.
	* NEWS: Mention support for MSP430X.

	* ld-elf/flags1.d: Expect this test to pass on the MSP430.
	* ld-elf/init-fini-arrays.d: Expect this test to fail on the
	MSP430.
	* ld-elf/merge.d: Expect this test to pass on the MSP430.
	* ld-elf/sec64k.exp: Skip these tests for the MSP430.
	* ld-gc/pr13683.d: Expect this test to fail on the MSP430.
	* ld-srec/srec.exp: Expect these tests to fail on the MSP430.
	* ld-undefined/undefined.exp: Expect the UNDEFINED LINE test to
	fail on the MSP430.

	* msp430-dis.c: Add support for MSP430X instructions.
@
text
@d260 7
d269 448
a716 3
  char * name;
  int isa;
  int mach;
d719 17
a735 24
#define MSP430_ISA_11   11
#define MSP430_ISA_110	110
#define MSP430_ISA_12   12
#define MSP430_ISA_13   13
#define MSP430_ISA_14   14
#define MSP430_ISA_15   15
#define MSP430_ISA_16   16
#define MSP430_ISA_20   20
#define MSP430_ISA_21   21
#define MSP430_ISA_22   22
#define MSP430_ISA_23   23
#define MSP430_ISA_24   24
#define MSP430_ISA_26   26
#define MSP430_ISA_31   31
#define MSP430_ISA_32   32
#define MSP430_ISA_33   33
#define MSP430_ISA_41   41
#define MSP430_ISA_42   42
#define MSP430_ISA_43   43
#define MSP430_ISA_44   44
#define MSP430X_ISA     45
#define MSP430_ISA_46   46
#define MSP430_ISA_47   47
#define MSP430_ISA_54   54
d744 1
a744 1
  (msp430_mcu->isa == MSP430X_ISA			     \
d755 1
a755 1
  (msp430_mcu->isa == MSP430X_ISA			     \
a759 175
static struct mcu_type_s mcu_types[] =
{
  {"msp1",        MSP430_ISA_11, bfd_mach_msp11},
  {"msp2",        MSP430_ISA_14, bfd_mach_msp14},
  {"msp3",        MSP430_ISA_20, bfd_mach_msp20},
  {"msp4",        MSP430_ISA_24, bfd_mach_msp24},
  {"msp5",        MSP430_ISA_31, bfd_mach_msp31},
  {"msp6",        MSP430_ISA_42, bfd_mach_msp42},

  {"msp430x110",  MSP430_ISA_11, bfd_mach_msp11},
  {"msp430x112",  MSP430_ISA_11, bfd_mach_msp11},
  {"msp430x1101", MSP430_ISA_110, bfd_mach_msp110},
  {"msp430x1111", MSP430_ISA_110, bfd_mach_msp110},
  {"msp430x1121", MSP430_ISA_110, bfd_mach_msp110},
  {"msp430x1122", MSP430_ISA_11, bfd_mach_msp110},
  {"msp430x1132", MSP430_ISA_11, bfd_mach_msp110},

  {"msp430x122",  MSP430_ISA_12, bfd_mach_msp12},
  {"msp430x123",  MSP430_ISA_12, bfd_mach_msp12},
  {"msp430x1222", MSP430_ISA_12, bfd_mach_msp12},
  {"msp430x1232", MSP430_ISA_12, bfd_mach_msp12},

  {"msp430x133",  MSP430_ISA_13, bfd_mach_msp13},
  {"msp430x135",  MSP430_ISA_13, bfd_mach_msp13},
  {"msp430x1331", MSP430_ISA_13, bfd_mach_msp13},
  {"msp430x1351", MSP430_ISA_13, bfd_mach_msp13},
  {"msp430x147",  MSP430_ISA_14, bfd_mach_msp14},
  {"msp430x148",  MSP430_ISA_14, bfd_mach_msp14},
  {"msp430x149",  MSP430_ISA_14, bfd_mach_msp14},
  {"msp430x1471", MSP430_ISA_14, bfd_mach_msp14},
  {"msp430x1481", MSP430_ISA_14, bfd_mach_msp14},
  {"msp430x1491", MSP430_ISA_14, bfd_mach_msp14},

  {"msp430x155",  MSP430_ISA_15, bfd_mach_msp15},
  {"msp430x156",  MSP430_ISA_15, bfd_mach_msp15},
  {"msp430x157",  MSP430_ISA_15, bfd_mach_msp15},
  {"msp430x167",  MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x168",  MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x169",  MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x1610", MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x1611", MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x1612", MSP430_ISA_16, bfd_mach_msp16},

  {"msp430x2001", MSP430_ISA_20, bfd_mach_msp20},
  {"msp430x2011", MSP430_ISA_20, bfd_mach_msp20},
  {"msp430x2002", MSP430_ISA_20, bfd_mach_msp20},
  {"msp430x2012", MSP430_ISA_20, bfd_mach_msp20},
  {"msp430x2003", MSP430_ISA_20, bfd_mach_msp20},
  {"msp430x2013", MSP430_ISA_20, bfd_mach_msp20 },

  {"msp430x2101", MSP430_ISA_21, bfd_mach_msp21},
  {"msp430x2111", MSP430_ISA_21, bfd_mach_msp21},
  {"msp430x2112", MSP430_ISA_21, bfd_mach_msp21},
  {"msp430x2121", MSP430_ISA_21, bfd_mach_msp21},
  {"msp430x2131", MSP430_ISA_21, bfd_mach_msp21},
  {"msp430x2132", MSP430_ISA_21, bfd_mach_msp21},

  {"msp430x2232", MSP430_ISA_22, bfd_mach_msp22},
  {"msp430x2234", MSP430_ISA_22, bfd_mach_msp22},
  {"msp430x2252", MSP430_ISA_22, bfd_mach_msp22},
  {"msp430x2254", MSP430_ISA_22, bfd_mach_msp22},
  {"msp430x2272", MSP430_ISA_22, bfd_mach_msp22},
  {"msp430x2274", MSP430_ISA_22, bfd_mach_msp22},

  {"msp430x233",  MSP430_ISA_23, bfd_mach_msp23},
  {"msp430x235",  MSP430_ISA_23, bfd_mach_msp23},
  {"msp430x2330", MSP430_ISA_23, bfd_mach_msp23},
  {"msp430x2350", MSP430_ISA_23, bfd_mach_msp23},
  {"msp430x2370", MSP430_ISA_23, bfd_mach_msp23},

  {"msp430x247",  MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x2471", MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x248",  MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x2481", MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x249",  MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x2491", MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x2410", MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x2416", MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x2417", MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x2418", MSP430_ISA_24, bfd_mach_msp24},
  {"msp430x2419", MSP430_ISA_24, bfd_mach_msp24},

  {"msp430x2616", MSP430_ISA_26, bfd_mach_msp26},
  {"msp430x2617", MSP430_ISA_26, bfd_mach_msp26},
  {"msp430x2618", MSP430_ISA_26, bfd_mach_msp26},
  {"msp430x2619", MSP430_ISA_26, bfd_mach_msp26},

  {"msp430x311",  MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x312",  MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x313",  MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x314",  MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x315",  MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x323",  MSP430_ISA_32, bfd_mach_msp32},
  {"msp430x325",  MSP430_ISA_32, bfd_mach_msp32},
  {"msp430x336",  MSP430_ISA_33, bfd_mach_msp33},
  {"msp430x337",  MSP430_ISA_33, bfd_mach_msp33},

  {"msp430x412",  MSP430_ISA_41, bfd_mach_msp41},
  {"msp430x413",  MSP430_ISA_41, bfd_mach_msp41},
  {"msp430x415",  MSP430_ISA_41, bfd_mach_msp41},
  {"msp430x417",  MSP430_ISA_41, bfd_mach_msp41},

  {"msp430x423",  MSP430_ISA_42, bfd_mach_msp42},
  {"msp430x425",  MSP430_ISA_42, bfd_mach_msp42},
  {"msp430x427",  MSP430_ISA_42, bfd_mach_msp42},
  {"msp430x4250", MSP430_ISA_42, bfd_mach_msp42},
  {"msp430x4260", MSP430_ISA_42, bfd_mach_msp42},
  {"msp430x4270", MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xG4250",MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xG4260",MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xG4270",MSP430_ISA_42, bfd_mach_msp42},

  {"msp430xE423", MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xE4232",MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xE4242",MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xE4252",MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xE425", MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xE427", MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xE4272",MSP430_ISA_42, bfd_mach_msp42},

  {"msp430xW423", MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xW425", MSP430_ISA_42, bfd_mach_msp42},
  {"msp430xW427", MSP430_ISA_42, bfd_mach_msp42},

  {"msp430xG437", MSP430_ISA_43, bfd_mach_msp43},
  {"msp430xG438", MSP430_ISA_43, bfd_mach_msp43},
  {"msp430xG439", MSP430_ISA_43, bfd_mach_msp43},

  {"msp430x435",  MSP430_ISA_43, bfd_mach_msp43},
  {"msp430x4351", MSP430_ISA_43, bfd_mach_msp43},
  {"msp430x436",  MSP430_ISA_43, bfd_mach_msp43},
  {"msp430x4361", MSP430_ISA_43, bfd_mach_msp43},
  {"msp430x437",  MSP430_ISA_43, bfd_mach_msp43},
  {"msp430x4371", MSP430_ISA_43, bfd_mach_msp43},

  {"msp430x447",  MSP430_ISA_44, bfd_mach_msp44},
  {"msp430x448",  MSP430_ISA_44, bfd_mach_msp44},
  {"msp430x449",  MSP430_ISA_44, bfd_mach_msp44},

  {"msp430xG4616",MSP430_ISA_46, bfd_mach_msp46},
  {"msp430xG4617",MSP430_ISA_46, bfd_mach_msp46},
  {"msp430xG4618",MSP430_ISA_46, bfd_mach_msp46},
  {"msp430xG4619",MSP430_ISA_46, bfd_mach_msp46},

  {"msp430x4783", MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x4784", MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x4793", MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x4794", MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x47166",MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x47176",MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x47186",MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x47196",MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x47167",MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x47177",MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x47187",MSP430_ISA_47, bfd_mach_msp47},
  {"msp430x47197",MSP430_ISA_47, bfd_mach_msp47},

  {"msp430x5418", MSP430_ISA_54, bfd_mach_msp54},
  {"msp430x5419", MSP430_ISA_54, bfd_mach_msp54},
  {"msp430x5435", MSP430_ISA_54, bfd_mach_msp54},
  {"msp430x5436", MSP430_ISA_54, bfd_mach_msp54},
  {"msp430x5437", MSP430_ISA_54, bfd_mach_msp54},
  {"msp430x5438", MSP430_ISA_54, bfd_mach_msp54},

  {"msp430X",     MSP430X_ISA,   bfd_mach_msp430x},

  {NULL, 0, 0}
};


static struct mcu_type_s default_mcu =
    { "msp430x11", MSP430_ISA_11, bfd_mach_msp11 };

static struct mcu_type_s * msp430_mcu = & default_mcu;

d1125 1
d1128 1
a1128 1
msp430_set_arch (int dummy ATTRIBUTE_UNUSED)
d1134 3
a1136 2
  md_parse_option (OPTION_MMCU, str);
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, msp430_mcu->mach);
d1148 1
a1148 1
      fprintf (stream, "%13.13s", mcu_types[i].name);
d1164 3
d1168 1
a1168 1
	if (strcmp (mcu_types[i].name, arg) == 0)
d1171 1
a1171 1
      if (!mcu_types[i].name)
d1177 2
a1178 4
      if (msp430_mcu == &default_mcu || msp430_mcu->mach == mcu_types[i].mach)
	msp430_mcu = &mcu_types[i];
      else if (msp430_mcu->mach == bfd_mach_msp430x)
	/* Allow switching to a lesser architecture.  */
d1181 1
a1181 1
	as_fatal (_("redefinition of mcu type %s' to %s'"),
d1185 13
d1221 2
a1222 1
  {"arch", msp430_set_arch, 0},
d1227 1
a1227 1
const char *md_shortopts = "m:";
d1232 1
d1247 2
a1248 1
	     "  -mmcu=<msp430-name> select microcontroller type\n"));
d1298 2
a1299 1
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, msp430_mcu->mach);
d2070 2
d2142 1
a2142 1
      if (msp430_mcu->isa != MSP430X_ISA)
d2148 1
a2148 1

d2186 1
d2192 2
a2193 3
	      && msp430_mcu->isa == MSP430_ISA_54
	      && (strcmp (opcode->name, "eint") == 0
		  || strcmp (opcode->name, "dint") == 0))
a2200 1

d2215 1
a2215 1

d2226 1
a2226 1

d2239 1
a2239 1

d2274 2
a2275 2
	      && msp430_mcu->isa == MSP430_ISA_54
	      && strcmp (opcode->name, "clr") == 0
d2303 12
d2325 1
a2325 1

d2444 1
a2444 1

d2515 1
a2515 1

d2547 1
a2547 1
		as_bad (_("expected #n as first argument of POPM"));
d2573 1
a2573 1
	    if (strcmp (opcode->name, "pushm") == 0)
d2582 11
d2643 7
d2684 7
d2719 1
a2719 1
	      }
d2798 1
a2798 1

d2803 1
a2803 1
	  if (strcmp (opcode->name, "reta") == 0)
d2821 1
a2821 1
	      if (strcmp (opcode->name, "bra") == 0)
d2834 1
a2834 1

d2907 1
a2907 1
	  && strcmp (opcode->name, "movx") == 0
d2930 1
a2930 1

d2955 1
a2955 1

d2965 1
a2965 1

d3031 4
a3034 4
	  && msp430_mcu->isa == MSP430_ISA_54
	  && (   (strcmp (opcode->name, "bic") == 0 && bin == 0xc232)
	      || (strcmp (opcode->name, "bis") == 0 && bin == 0xd232)
	      || (strcmp (opcode->name, "mov") == 0 && op2.mode == OP_REG && op2.reg == 2)))
d3063 12
d3078 1
a3078 1

d3081 1
a3081 2
	  if (strcmp (opcode->name, "swpbx") == 0
	      || strcmp (opcode->name, "sxtx") == 0)
d3109 1
a3109 1

d3117 1
a3117 1

d3248 1
a3248 1

d3265 1
a3265 1
	      if (msp430_mcu->isa == MSP430X_ISA)
d3311 1
a3311 1
	      if (msp430_mcu->isa == MSP430X_ISA)
a3414 1

a3416 1

d3480 1
a3480 1
  /* If polymorphs are enabled and relax disabled.
d3482 1
a3482 1
  if (msp430_enable_polys
d3485 1
a3485 1
      if (!fixp->fx_addsy || (fixp->fx_addsy
d3554 1
a3554 1
	  value >>= 16;
d3560 1
a3560 1
	  value >>= 16;
d3594 1
a3594 1

d3617 1
a3617 1

d3706 1
a3706 1
	  reloc->addend = fixp->fx_offset;
d3839 1
a3839 2
      cc = & msp430_rcodes[7];
      if (msp430_mcu->isa == MSP430X_ISA)
d3841 2
d3857 1
a3857 1
	if (msp430_mcu->isa == MSP430X_ISA)
d3883 1
a3883 3
      cc = & msp430_rcodes[6];

      if (msp430_mcu->isa == MSP430X_ISA)
d3885 2
a3886 1

d3900 1
a3900 1
	if (msp430_mcu->isa == MSP430X_ISA)
a3911 1

d3932 1
a3932 1
	if (msp430_mcu->isa == MSP430X_ISA)
d4006 1
a4006 1

d4056 1
a4056 1

d4066 1
a4066 1
			     msp430_mcu->isa == MSP430X_ISA ? 2 : 1);
@


1.34
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d3 1
a3 2
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2012
  Free Software Foundation, Inc.
d30 1
d42 1
a42 1
   
d66 1
a66 1
   
d72 3
d77 1
a77 1
  
d86 1
a86 1
   lt	<	   jl 		jge +4;	br lab 
d99 2
a100 2
   'u' means unsigned compares 
  
d106 1
a106 1
struct rcodes_s 
d120 1
a120 1
static struct rcodes_s msp430_rcodes[] = 
d132 17
d151 1
a152 2
/* More difficult than above and they have format 5.
   
d161 1
a161 1
struct hcodes_s 
d163 1
a163 1
  char * name;	
d173 1
a173 1
static struct hcodes_s msp430_hcodes[] = 
d182 9
d274 1
d276 4
d287 27
a313 3

#define CHECK_RELOC_MSP430 		((imm_op || byte_op)?BFD_RELOC_MSP430_16_BYTE:BFD_RELOC_MSP430_16)
#define CHECK_RELOC_MSP430_PCREL	((imm_op || byte_op)?BFD_RELOC_MSP430_16_PCREL_BYTE:BFD_RELOC_MSP430_16_PCREL)
d319 5
d344 3
d358 7
d367 1
d370 32
a401 1
  
d417 10
d428 3
d433 1
d444 1
d446 1
d448 2
d454 27
d851 4
d875 5
a879 1
    fprintf (stream, _("\t %s\n"), mcu_types[i].name);
d904 3
d911 1
a911 2
      break;
      
d913 1
a913 1
      msp430_enable_relax = 1; 
d915 1
a915 2
      break;
      
d919 8
a926 1
      break;
d947 2
d959 1
a959 21
	     "  -mmcu=[msp430-name] select microcontroller type\n"
	     "                  msp430x110  msp430x112\n"
	     "                  msp430x1101 msp430x1111\n"
	     "                  msp430x1121 msp430x1122 msp430x1132\n"
	     "                  msp430x122  msp430x123\n"
	     "                  msp430x1222 msp430x1232\n"
	     "                  msp430x133  msp430x135\n"
	     "                  msp430x1331 msp430x1351\n"
	     "                  msp430x147  msp430x148  msp430x149\n"
	     "                  msp430x155  msp430x156  msp430x157\n"
	     "                  msp430x167  msp430x168  msp430x169\n"
	     "                  msp430x1610 msp430x1611 msp430x1612\n"
	     "                  msp430x311  msp430x312  msp430x313  msp430x314  msp430x315\n"
	     "                  msp430x323  msp430x325\n"
	     "                  msp430x336  msp430x337\n"
	     "                  msp430x412  msp430x413  msp430x415  msp430x417\n"
	     "                  msp430xE423 msp430xE425 msp430E427\n"
	     "                  msp430xW423 msp430xW425 msp430W427\n"
	     "                  msp430xG437 msp430xG438 msp430G439\n"
	     "                  msp430x435  msp430x436  msp430x437\n"
	     "                  msp430x447  msp430x448  msp430x449\n"));
d963 4
d974 1
a974 1
  return 0;
d1012 6
a1017 1
static int
d1020 4
a1023 1
  /* If this is a reg numb, str 't' must be a number from 0 - 15.  */
d1025 7
a1031 1
  if (strlen (t) > 2 && *(t + 2) != '+')
d1034 7
a1040 6
  while (*t)
    {
      if ((*t < '0' || *t > '9') && *t != '+')
	break;
      t++;
    }
d1042 2
a1043 2
  if (*t)
    return 1;
d1045 1
a1045 1
  return 0;
a1047 1

d1050 5
a1054 1
		   char * l, int bin, int * imm_op)
d1135 9
a1143 1
	  if (op->exp.X_add_number > 65535 || op->exp.X_add_number < -32768)
d1152 2
a1153 1
	  x = (short) x;	/* Extend sign.  */
d1155 3
a1157 1
	  if (x == 0)
d1309 9
a1317 1
	  if (x > 65535 || x < -32768)
d1319 1
a1319 1
	      as_bad (_("value out of range: %d"), x);
a1350 5
      if (*t != 'r' && *t != 'R')
	{
	  as_bad (_("unknown addressing mode %s"), l);
	  return 1;
	}
d1352 1
a1352 3
      t++;	/* Points to the reg value.  */

      if (check_reg (t))
d1354 1
a1354 1
	  as_bad (_("Bad register name r%s"), t);
a1360 8
      if (m)
	*m = 0;			/* strip '+' */
      op->reg = atoi (t);
      if (op->reg < 0 || op->reg > 15)
	{
	  as_bad (_("MSP430 does not have %d registers"), op->reg);
	  return 1;
	}
d1385 1
d1387 1
a1387 3
      t++;	/* Advance pointer.  */

      if (*t != 'r' && *t != 'R')
a1393 1
      t++;
d1395 1
a1395 2
      op->reg = *t - '0';
      if (op->reg > 9 || op->reg < 0)
d1397 1
a1397 2
	  as_bad (_("unknown operator (r%s substituted as a register name"),
		  t);
a1399 23
      t++;
      if (*t != ')')
	{
	  op->reg = op->reg * 10;
	  op->reg += *t - '0';

	  if (op->reg > 15)
	    {
	      as_bad (_("unknown operator %s"), l);
	      return 1;
	    }
	  if (op->reg == 2)
	    {
	      as_bad (_("r2 should not be used in indexed addressing mode"));
	      return 1;
	    }

	  if (*(t + 1) != ')')
	    {
	      as_bad (_("unknown operator %s"), l);
	      return 1;
	    }
	}
d1410 9
a1418 1
	  if (x > 65535 || x < -32768)
d1420 1
a1420 1
	      as_bad (_("value out of range: %d"), x);
d1449 2
a1450 2
  /* Register mode 'mov r1,r2'.  */
  do
d1452 4
a1455 19
      char *t = l;

      /* Operand should be a register.  */
      if (*t == 'r' || *t == 'R')
	{
	  int x = atoi (t + 1);

	  if (check_reg (t + 1))
	    break;

	  if (x < 0 || x > 15)
	    break;		/* Symbolic mode.  */

	  op->mode = OP_REG;
	  op->am = 0;
	  op->ol = 0;
	  op->reg = x;
	  return 0;
	}
a1456 1
  while (0);
d1463 2
a1464 1
      op->am = 1;
d1479 5
a1483 1
msp430_dstoperand (struct msp430_operand_s * op, char * l, int bin)
d1486 3
a1488 1
  int ret = msp430_srcoperand (op, l, bin, & dummy);
d1521 259
d1787 1
a1787 1
  int __is = 0;
d1795 8
d1819 10
a1828 1
  /* skip .[bwBW].  */
d1832 3
a1834 1
  if (opcode->insn_opnumb && (!*line || *line == '\n'))
d1848 30
a1877 1
  switch (opcode->fmt)
d1884 12
a1895 2
	  __is = 2;
	  frag = frag_more (__is);
d1897 14
a1910 1
	  dwarf2_emit_insn (__is);
d1912 1
d1916 1
a1916 1
	  res = msp430_dstoperand (&op1, l1, opcode->bin_opcode);
d1920 3
a1922 3
	  bin |= (op1.reg | (op1.am << 7));
	  __is = 1 + op1.ol;
	  frag = frag_more (2 * __is);
a1923 2
	  bfd_putl16 ((bfd_vma) bin, frag);
	  dwarf2_emit_insn (2 * __is);
d1925 1
a1925 1
	  if (op1.mode == OP_EXP)
d1927 25
d1953 6
a1958 1
	      bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
d1960 6
a1965 3
	      if (op1.reg)
		fix_new_exp (frag_now, where, 2,
			     &(op1.exp), FALSE, CHECK_RELOC_MSP430);
d1967 25
a1991 2
		fix_new_exp (frag_now, where, 2,
			     &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
d1993 2
d1998 236
d2235 4
a2238 1
	    /* Shift instruction.  */
d2240 1
a2240 4
	    strncpy (l2, l1, sizeof (l2));
	    l2[sizeof (l2) - 1] = '\0';
	    res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
	    res += msp430_dstoperand (&op2, l2, opcode->bin_opcode);
d2242 12
a2253 2
	    if (res)
	      break;	/* An error occurred.  All warnings were done before.  */
d2255 6
a2260 1
	    bin |= (op2.reg | (op1.reg << 8) | (op1.am << 4) | (op2.am << 7));
d2262 2
a2263 2
	    __is = 1 + op1.ol + op2.ol;	/* insn size in words.  */
	    frag = frag_more (2 * __is);
d2265 17
d2283 11
a2293 3
	    dwarf2_emit_insn (2 * __is);
	    
	    if (op1.mode == OP_EXP)
d2295 37
a2331 2
		where += 2;	/* Advance 'where' as we do not know _where_.  */
		bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
d2333 20
a2352 6
		if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
		  fix_new_exp (frag_now, where, 2,
			       &(op1.exp), FALSE, CHECK_RELOC_MSP430);
		else
		  fix_new_exp (frag_now, where, 2,
			       &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
d2355 2
a2356 1
	    if (op2.mode == OP_EXP)
d2358 4
a2361 2
		imm_op = 0;
		bfd_putl16 ((bfd_vma) ZEROS, frag + 2 + ((__is == 3) ? 2 : 0));
d2363 28
a2390 6
		if (op2.reg)	/* Not PC relative.  */
		  fix_new_exp (frag_now, where + 2, 2,
			       &(op2.exp), FALSE, CHECK_RELOC_MSP430);
		else
		  fix_new_exp (frag_now, where + 2, 2,
			       &(op2.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
a2393 3
	case 3:
	  /* Branch instruction => mov dst, r0.  */
	  line = extract_operand (line, l1, sizeof (l1));
d2395 73
a2467 2
	  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
	  if (res)
d2469 1
d2471 1
a2471 1
	  byte_op = 0;
d2473 19
d2493 46
a2538 6
	  bin |= ((op1.reg << 8) | (op1.am << 4));
	  __is = 1 + op1.ol;
	  frag = frag_more (2 * __is);
	  where = frag - frag_now->fr_literal;
	  bfd_putl16 ((bfd_vma) bin, frag);
	  dwarf2_emit_insn (2 * __is);
d2540 5
a2544 1
	  if (op1.mode == OP_EXP)
d2546 1
a2546 2
	      where += 2;
	      bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
d2548 7
a2554 3
	      if (op1.reg || (op1.reg == 0 && op1.am == 3))
		fix_new_exp (frag_now, where, 2,
			     &(op1.exp), FALSE, CHECK_RELOC_MSP430);
d2556 4
a2559 2
		fix_new_exp (frag_now, where, 2,
			     &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
d2562 4
d2572 2
a2573 2
      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
      res += msp430_dstoperand (&op2, l2, opcode->bin_opcode);
d2578 21
a2598 1
      bin |= (op2.reg | (op1.reg << 8) | (op1.am << 4) | (op2.am << 7));
d2600 1
a2600 2
      __is = 1 + op1.ol + op2.ol;	/* insn size in words.  */
      frag = frag_more (2 * __is);
d2602 49
d2652 2
a2653 1
      dwarf2_emit_insn (2 * __is);
d2657 18
a2674 2
	  where += 2;		/* Advance where as we do not know _where_.  */
	  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
d2676 2
a2677 6
	  if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
	    fix_new_exp (frag_now, where, 2,
			 &(op1.exp), FALSE, CHECK_RELOC_MSP430);
	  else
	    fix_new_exp (frag_now, where, 2,
			 &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
d2682 19
a2700 2
	  imm_op = 0;
	  bfd_putl16 ((bfd_vma) ZEROS, frag + 2 + ((__is == 3) ? 2 : 0));
d2702 11
a2712 6
	  if (op2.reg)		/* Not PC relative.  */
	    fix_new_exp (frag_now, where + 2, 2,
			 &(op2.exp), FALSE, CHECK_RELOC_MSP430);
	  else
	    fix_new_exp (frag_now, where + 2, 2,
			 &(op2.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
d2714 2
d2722 1
d2725 1
a2725 1
	  dwarf2_emit_insn (2);
d2730 2
a2731 1
      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
d2735 50
a2785 3
      __is = 1 + op1.ol;
      frag = frag_more (2 * __is);
      where = frag - frag_now->fr_literal;
d2787 2
a2788 1
      dwarf2_emit_insn (2 * __is);
d2792 7
a2798 1
	  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
d2800 10
a2809 6
	  if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
	    fix_new_exp (frag_now, where + 2, 2,
			 &(op1.exp), FALSE, CHECK_RELOC_MSP430);
	  else
	    fix_new_exp (frag_now, where + 2, 2,
			 &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
d2811 2
a2826 1
	  frag = frag_more (2);	/* Instr size is 1 word.  */
d2870 3
d2878 2
d2891 3
a2893 5
	    {
	      as_bad (_
		      ("instruction requires label or value in range -511:512"));
	    }
	  dwarf2_emit_insn (2 * __is);
d2909 1
a2909 1
	
d2926 8
a2933 4
	      /* The parameter to dwarf2_emit_insn is actually the offset to the start
		 of the insn from the fix piece of instruction that was emitted.
		 Since next fragments may have variable size we tie debug info
	         to the beginning of the instruction. */
d2938 2
a2939 1
				   ENCODE_RELAX (rc.lpos, STATE_BITS10), /* Wild guess.  */
d2972 4
d3070 1
a3070 1
   have to be passed to linker. */
d3072 1
a3072 1
msp430_force_relocation_local(fixS *fixp)
d3074 6
d3083 3
a3085 3
  else
    return (!fixp->fx_pcrel
	    || generic_force_reloc(fixp));
a3137 6
	  else
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("expression too complex"));
	    }
d3143 3
a3145 3
  /* if polymorphs are enabled and relax disabled. 
     do not kill any relocs and pass them to linker. */
  if (msp430_enable_polys 
d3148 1
a3148 1
      if (!fixp->fx_addsy || (fixp->fx_addsy 
a3158 1

d3182 1
d3188 1
d3190 1
d3195 1
d3197 4
d3205 33
a3237 5
	case BFD_RELOC_MSP430_16_PCREL_BYTE:
	  /* Nothing to be corrected here.  */
	  if (value < -32768 || value > 65536)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("operand out of range: %ld"), value);
d3239 5
a3243 2
	  value &= 0xffff;	/* Get rid of extended sign.  */
	  bfd_putl16 ((bfd_vma) value, where);
d3246 4
a3249 2
	case BFD_RELOC_32:
	  bfd_putl16 ((bfd_vma) value, where);
d3252 4
a3255 5
	case BFD_RELOC_MSP430_16:
	case BFD_RELOC_16:
	case BFD_RELOC_MSP430_16_BYTE:
	  value &= 0xffff;
	  bfd_putl16 ((bfd_vma) value, where);
d3270 14
d3293 1
a3293 1
arelent *
d3296 3
a3298 1
  arelent * reloc;
a3300 4

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);

d3303 1
d3309 12
a3320 1
      return NULL;
d3323 11
a3333 3
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;
d3335 6
a3340 1
  reloc->addend = fixp->fx_offset;
d3342 102
a3443 1
  return reloc;
d3503 2
d3519 13
a3531 3
	for (i = 0; i < 7 && !cc; i++)
	  if (msp430_rcodes[i].sop == insn)
	    cc = & msp430_rcodes[i];
d3546 4
d3563 13
a3575 3
	for (i = 0; i < 4 && !hc; i++)
	  if (msp430_hcodes[i].op1 == insn)
	    hc = &msp430_hcodes[i];
d3584 1
a3584 1
	      fragP->fr_offset, TRUE, rela);
d3596 12
a3607 3
	for (i = 0; i < 4 && !hc; i++)
	  if (msp430_hcodes[i].op1 == insn)
	    hc = & msp430_hcodes[i];
d3667 1
a3667 1
         by setting 'aim' to quite high value. */
d3670 1
a3670 1
  
d3708 55
@


1.33
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
d24 1
a25 1

a26 1
#include "as.h"
@


1.32
log
@update copyright dates
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2009
a680 1
  char *op_start;
d689 1
a689 1
  for (op_start = op_end = from; *op_end != 0 && is_part_of_name (*op_end);)
@


1.31
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007
@


1.30
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1013 1
a1013 1
		     as_warn(_("Hardware push bug workaround")); */
d1030 1
a1030 1
		     as_warn(_("Hardware push bug workaround")); */
d1716 1
a1716 1
	  as_bad(_("polymorphs are not enabled. Use -mP option to enable."));
d1758 1
a1758 1
	  as_bad(_("polymorphs are not enabled. Use -mP option to enable."));
@


1.29
log
@PR gas/5155
* config/tc-msp430.c: Fix spelling typos.
@
text
@a844 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d848 1
a848 32
  int prec;
  LITTLENUM_TYPE words[4];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;
    case 'd':
      prec = 4;
      break;
    default:
      *sizeP = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  /* This loop outputs the LITTLENUMs in REVERSE order.  */
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return NULL;
@


1.28
log
@Switch to GPLv3
@
text
@d33 1
a33 2
/*
   We will disable polymorphs by default because it is dangerous.
d52 2
a53 2
   If the 'subroutine' wiys thin +-1024 bytes range then linker
   will produce
a60 1

d62 1
a62 1
   1. Declare global var enable_polymorphs which set to 1 via option -mP.
d68 1
a68 2
   If relax is enabled, relax at assembly time and kill relocs as necessary.
 */
d394 1
a394 1
						; note, that spare var filled with the farme size
d622 1
a622 1
      as_bad (_("ambigious flags combination - '.profiler' directive ignored."));
d628 1
a628 1
  if (now_seg == absolute_section)	/* Paranoja ?  */
d632 1
a632 1
      as_warn (_("profiling in absolute section? Hm..."));
d1142 1
a1142 1
      /* Redudant (yet) check.  */
d1177 1
a1177 1
	  /* Redudant (yet) check.  */
d1265 1
a1265 1
	  as_bad (_("unknown operator (r%s substituded as a register name"),
d1320 1
a1320 1
	  /* Redudant (yet) check.  */
d1831 1
a1831 1
      as_bad (_("Ilegal instruction or not implmented opcode."));
d1987 1
a1987 1
	fixp->fx_done = 1;	/* it is ok to kill 'abs' reloc */
d2120 1
a2120 1
	 an absolute segment, we dont know a displacement until we link
d2130 1
a2130 1
         Impossible in our case, cause all constants already handeled. */
@


1.27
log
@PR gas/2623
* config/tc-msp430.c (line_separator_char): Change to '{'.
@
text
@d11 1
a11 1
  the Free Software Foundation; either version 2, or (at your option)
@


1.26
log
@	* write.h (struct fix <fx_pcrel_adjust, fx_size>): Move.
	(struct fix <fx_plt>): Rename to tcbit2.
	* write.c (fix_new_internal): Adjust.
	(TC_FORCE_RELOCATION_LOCAL): Don't test fx_plt.
	* config/tc-arm.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-cris.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-i960.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sh.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sparc.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-msp430.c (msp430_force_relocation_local): Likewise.
	* config/tc-ia64.c (emit_one_bundle): Don't set fx_plt.
	* config/tc-ia64.h (TC_FORCE_RELOCATION_LOCAL): Don't test fx_plt.
	Instead, compare fx_r_type.
	* config/tc-xtensa.c (xg_add_opcode_fix, md_apply_fix): Use
	fx_tcbit in place of fx_plt.
	* config/tc-xtensa.h (TC_FORCE_RELOCATION_LOCAL): Define.
	* doc/internals.texi (TC_FORCE_RELOCATION_LOCAL): Remove reference
	to fx_plt.
@
text
@d169 1
a169 1
const char line_separator_chars[] = "|";
@


1.25
log
@remove some duplicate #include's.
@
text
@d3 2
a4 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
a1918 1
	    || fixp->fx_plt
@


1.24
log
@    PR gas/2623b
* config/tc-msp430.c (line_separator_character): Define as |.
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
a22 3
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
@


1.23
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@d171 1
a171 1
const char line_separator_chars[] = "";
@


1.22
log
@2005-09-09  Dmitry Diky  <diwil@@spec.ru>

        * config/tc-msp430.c (msp430_operands): Undo last changes. Instead...
	(msp430_relax_frag): add a guard check to ensure that final fr_subtype
	has been reached.
@
text
@d37 1
a37 1
   The potencial problem here is the following: assume we got the
d490 1
a490 1
/* Extract one word from FROM and copy it to TO. Delimeters are ",;\n"  */
@


1.21
log
@2005-09-01  Dmitry Diky  <diwil@@spec.ru>

	* config/tc-msp430.c (msp430_operands): Emit dwarf2_emit_insn()
	as appropriate. Change frag_variant() to frag_var() for relaxes.
@
text
@d1781 1
a1781 1
	      frag = frag_more (0);
d1783 2
a1784 1
	      frag = frag_var/*iant*/ (rs_machine_dependent, 8, 2,
a1788 1
	      bfd_putl16 ((bfd_vma) rc.sop, frag);
d1818 1
a1818 1
	      frag = frag_more (0);
d1820 4
a1823 1
	      frag = frag_var/*iant*/ (rs_machine_dependent, 8, 2,
a1827 2
	      bfd_putl16 ((bfd_vma) hc.op0, frag);
	      bfd_putl16 ((bfd_vma) hc.op1, frag+2);
d2309 1
a2309 1
	if (aim >= this_type->rlx_backward)
d2323 1
a2323 1
	if (aim <= this_type->rlx_forward)
@


1.20
log
@2005-08-12  Dmitry Diky <diwil@@spec.ru>
	* config/tc-msp430.c (msp430_enable_relax): New flag.
	(msp430_enable_polys): Likewise.
	(OPTION_RELAX): New option.
	(OPTION_POLYMORPHS): Likewise.
	(md_longopts): New long options.
	(md_show_usage): Updated.
	(md_parse_option): Add new options handler.
	(msp430_operands): Add check if polymorph insns are enabled.
	(msp430_force_relocation_local): New function.
	(md_apply_fix): Now delete relocs according to new flags combination.
	(msp430_relax_frag): Convert long branches to short branches only if
	flag msp430_enable_relax is set.
	* config/tc-msp430.h (TC_FORCE_RELOCATION_LOCAL): Defined.
	(msp430_force_relocation_local): Likewise.
	* doc/c-msp430.texi: Describe new options.
@
text
@d33 1
d1426 1
a1426 1
  int __is;
d1478 1
d1492 1
d1526 2
a1527 1

d1571 1
d1604 1
d1639 1
d1653 1
a1737 1
	      break;
a1742 1
	      break;
d1744 2
d1777 7
a1783 3
	      frag = frag_more (8);
	      bfd_putl16 ((bfd_vma) rc.sop, frag);
	      frag = frag_variant (rs_machine_dependent, 8, 2,
d1788 1
d1818 3
a1820 4
	      frag = frag_more (8);
	      bfd_putl16 ((bfd_vma) hc.op0, frag);
	      bfd_putl16 ((bfd_vma) hc.op1, frag+2);
	      frag = frag_variant (rs_machine_dependent, 8, 2,
d1825 2
@


1.19
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d34 43
d706 2
d757 11
d786 2
d819 3
d1747 6
d1784 5
d1895 16
a1912 1

d1969 12
a1980 7
  switch (fixp->fx_r_type)
    {
    default:
      fixp->fx_no_overflow = 1;
      break;
    case BFD_RELOC_MSP430_10_PCREL:
      break;
d2280 7
@


1.18
log
@Add support for msp430x21xx variants
@
text
@d1967 5
a1971 6
/* A `BFD_ASSEMBLER' GAS will call this to generate a reloc.  GAS
   will pass the resulting reloc to `bfd_install_relocation'.  This
   currently works poorly, as `bfd_install_relocation' often does the
   wrong thing, and instances of `tc_gen_reloc' have been written to
   work around the problems, which in turns makes it difficult to fix
   `bfd_install_relocation'.  */
@


1.17
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d208 1
d255 5
@


1.16
log
@Update the address and phone number of the FSF
@
text
@d1821 1
a1821 1
md_apply_fix3 (fixS * fixp, valueT * valuep, segT seg)
@


1.15
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d20 2
a21 2
  the Free Software Foundation, 59 Temple Place - Suite 330,
  Boston, MA 02111-1307, USA.  */
@


1.14
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d1890 1
a1890 1
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
@


1.13
log
@(md_apply_fix3): Fix offset calculation for global label.
@
text
@a1297 16
#if 0  /* Allow expression in operand like 'a+123*(1|2)'.  */
      char *t = l;

      __tl = l;

      while (*t)
	{
	  /* alpha/number    underline     dot for labels.  */
	  if (! ISALNUM (*t) && *t != '_' && *t != '.')
	    {
	      as_bad (_("unknown operand %s"), l);
	      return 1;
	    }
	  t++;
	}
#endif
@


1.12
log
@include/opcode/
	* msp430.h (struct rcodes_s, MSP430_RLC, msp430_rcodes,
	struct hcodes_s, msp430_hcodes): Move to gas/config/tc-msp430.c.
gas/
	* config/tc-msp430.c (struct rcodes_s, MSP430_RLC, msp430_rcodes,
	struct hcodes_s, msp430_hcodes): From include/opcode/msp430.h.
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
d1854 13
a1866 1
	  value = S_GET_VALUE (fixp->fx_addsy) + *valuep;
@


1.11
log
@Apply Dmitry Diky's patches to add relaxation to msp430.
@
text
@d34 91
@


1.10
log
@Add new subtargets: msp430x1610, msp430x1611, msp430x1612, msp430x415,
 msp430x417, msp430xG437, msp430xG438, msp430xG439.
@
text
@d45 55
a99 18
static unsigned int msp430_operands
  PARAMS ((struct msp430_opcode_s *, char *));
static int msp430_srcoperand
  PARAMS ((struct msp430_operand_s *, char *, int, int *));
static int msp430_dstoperand
  PARAMS ((struct msp430_operand_s *, char *, int));
static char *parse_exp
  PARAMS ((char *, expressionS *));
static inline char *skip_space
  PARAMS ((char *));
static int check_reg
  PARAMS ((char *));
static void msp430_set_arch
  PARAMS ((int));
static void show_mcu_list
  PARAMS ((FILE *));
static void del_spaces
  PARAMS ((char *));
d105 1
a105 1
  char *name;
d130 29
a158 29
  {"msp1",       MSP430_ISA_11, bfd_mach_msp11},
  {"msp2",       MSP430_ISA_14, bfd_mach_msp14},
  {"msp430x110", MSP430_ISA_11, bfd_mach_msp11},
  {"msp430x112", MSP430_ISA_11, bfd_mach_msp11},
  {"msp430x1101",MSP430_ISA_110, bfd_mach_msp110},
  {"msp430x1111",MSP430_ISA_110, bfd_mach_msp110},
  {"msp430x1121",MSP430_ISA_110, bfd_mach_msp110},
  {"msp430x1122",MSP430_ISA_11, bfd_mach_msp110},
  {"msp430x1132",MSP430_ISA_11, bfd_mach_msp110},

  {"msp430x122", MSP430_ISA_12, bfd_mach_msp12},
  {"msp430x123", MSP430_ISA_12, bfd_mach_msp12},
  {"msp430x1222",MSP430_ISA_12, bfd_mach_msp12},
  {"msp430x1232",MSP430_ISA_12, bfd_mach_msp12},

  {"msp430x133", MSP430_ISA_13, bfd_mach_msp13},
  {"msp430x135", MSP430_ISA_13, bfd_mach_msp13},
  {"msp430x1331",MSP430_ISA_13, bfd_mach_msp13},
  {"msp430x1351",MSP430_ISA_13, bfd_mach_msp13},
  {"msp430x147", MSP430_ISA_14, bfd_mach_msp14},
  {"msp430x148", MSP430_ISA_14, bfd_mach_msp14},
  {"msp430x149", MSP430_ISA_14, bfd_mach_msp14},

  {"msp430x155", MSP430_ISA_15, bfd_mach_msp15},
  {"msp430x156", MSP430_ISA_15, bfd_mach_msp15},
  {"msp430x157", MSP430_ISA_15, bfd_mach_msp15},
  {"msp430x167", MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x168", MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x169", MSP430_ISA_16, bfd_mach_msp16},
d163 14
a176 14
  {"msp430x311", MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x312", MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x313", MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x314", MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x315", MSP430_ISA_31, bfd_mach_msp31},
  {"msp430x323", MSP430_ISA_32, bfd_mach_msp32},
  {"msp430x325", MSP430_ISA_32, bfd_mach_msp32},
  {"msp430x336", MSP430_ISA_33, bfd_mach_msp33},
  {"msp430x337", MSP430_ISA_33, bfd_mach_msp33},

  {"msp430x412", MSP430_ISA_41, bfd_mach_msp41},
  {"msp430x413", MSP430_ISA_41, bfd_mach_msp41},
  {"msp430x415", MSP430_ISA_41, bfd_mach_msp41},
  {"msp430x417", MSP430_ISA_41, bfd_mach_msp41},
d190 6
a195 6
  {"msp430x435", MSP430_ISA_43, bfd_mach_msp43},
  {"msp430x436", MSP430_ISA_43, bfd_mach_msp43},
  {"msp430x437", MSP430_ISA_43, bfd_mach_msp43},
  {"msp430x447", MSP430_ISA_44, bfd_mach_msp44},
  {"msp430x448", MSP430_ISA_44, bfd_mach_msp44},
  {"msp430x449", MSP430_ISA_44, bfd_mach_msp44},
d204 1
a204 1
static struct mcu_type_s *msp430_mcu = &default_mcu;
d206 86
a291 1
const pseudo_typeS md_pseudo_table[] =
d293 11
a303 3
  {"arch", msp430_set_arch, 0},
  {NULL, NULL, 0}
};
d305 2
a306 1
#define OPTION_MMCU 'm'
d308 1
a308 1
const char *md_shortopts = "m:";
d310 2
a311 1
struct option md_longopts[] =
d313 7
a319 3
  {"mmcu", required_argument, NULL, OPTION_MMCU},
  {NULL, no_argument, NULL, 0}
};
d321 1
a321 1
size_t md_longopts_size = sizeof (md_longopts);
d324 29
a352 2
show_mcu_list (stream)
     FILE *stream;
d354 13
a366 1
  int i;
d368 2
a369 1
  fprintf (stream, _("Known MCU names:\n"));
d371 1
a371 2
  for (i = 0; mcu_types[i].name; i++)
    fprintf (stream, _("\t %s\n"), mcu_types[i].name);
d373 1
a373 1
  fprintf (stream, "\n");
d376 2
a377 2
void
md_show_usage (FILE *stream)
d379 158
a536 23
  fprintf (stream,
	   _("MSP430 options:\n"
	     "  -mmcu=[msp430-name] select microcontroller type\n"
	     "                  msp430x110  msp430x112\n"
	     "                  msp430x1101 msp430x1111\n"
	     "                  msp430x1121 msp430x1122 msp430x1132\n"
	     "                  msp430x122  msp430x123\n"
	     "                  msp430x1222 msp430x1232\n"
	     "                  msp430x133  msp430x135\n"
	     "                  msp430x1331 msp430x1351\n"
	     "                  msp430x147  msp430x148  msp430x149\n"
	     "                  msp430x155  msp430x156  msp430x157\n"
	     "                  msp430x167  msp430x168  msp430x169\n"
	     "                  msp430x1610 msp430x1611 msp430x1612\n"
	     "                  msp430x311  msp430x312  msp430x313  msp430x314  msp430x315\n"
	     "                  msp430x323  msp430x325\n"
	     "                  msp430x336  msp430x337\n"
	     "                  msp430x412  msp430x413  msp430x415  msp430x417\n"
	     "                  msp430xE423 msp430xE425 msp430E427\n"
	     "                  msp430xW423 msp430xW425 msp430W427\n"
	     "                  msp430xG437 msp430xG438 msp430G439\n"
	     "                  msp430x435  msp430x436  msp430x437\n"
	     "                  msp430x447  msp430x448  msp430x449\n"));
d538 2
a539 1
  show_mcu_list (stream);
d543 1
a543 1
extract_word (char *from, char *to, int limit)
d565 2
d568 1
a568 2
msp430_set_arch (dummy)
     int dummy ATTRIBUTE_UNUSED;
d578 13
d592 1
a592 3
md_parse_option (c, arg)
     int c;
     char *arg;
d620 2
a621 3
symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d623 6
a628 2
  return 0;
}
d630 1
a630 3
static inline char *
skip_space (s)
     char *s;
d632 3
a634 4
  while (ISSPACE (*s))
    ++s;
  return s;
}
d636 1
a636 1
/* Delete spaces from s: X ( r 1  2)  => X(r12).  */
d638 2
a639 3
static void
del_spaces (s)
     char *s;
d641 23
a663 5
  while (*s)
    {
      if (ISSPACE (*s))
	{
	  char *m = s + 1;
d665 1
a665 7
	  while (ISSPACE (*m) && *m)
	    m++;
	  memmove (s, m, strlen (m) + 1);
	}
      else
	s++;
    }
d668 2
a669 4
/* Extract one word from FROM and copy it to TO. Delimeters are ",;\n"  */

static char *
extract_operand (char *from, char *to, int limit)
d671 1
a671 20
  int size = 0;

  /* Drop leading whitespace.  */
  from = skip_space (from);

  while (size < limit && *from)
    {
      *(to + size) = *from;
      if (*from == ',' || *from == ';' || *from == '\n')
	break;
      from++;
      size++;
    }

  *(to + size) = 0;
  del_spaces (to);

  from++;

  return from;
d675 1
a675 1
extract_cmd (char *from, char *to, int limit)
d697 1
a697 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d734 1
a734 10
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
{
  abort ();
}

void
md_begin ()
d736 1
a736 1
  struct msp430_opcode_s *opcode;
d745 2
a746 3
void
md_assemble (str)
     char *str;
d748 1
a748 3
  struct msp430_opcode_s *opcode;
  char cmd[32];
  unsigned int i = 0;
d750 2
a751 2
  str = skip_space (str);	/* Skip leading spaces.  */
  str = extract_cmd (str, cmd, sizeof (cmd));
d753 1
a753 1
  while (cmd[i] && i < sizeof (cmd))
d755 3
a757 3
      char a = TOLOWER (cmd[i]);
      cmd[i] = a;
      i++;
d760 2
a761 5
  if (!cmd[0])
    {
      as_bad (_("can't find opcode "));
      return;
    }
d763 1
a763 13
  opcode = (struct msp430_opcode_s *) hash_find (msp430_hash, cmd);

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode `%s'"), cmd);
      return;
    }

  {
    char *__t = input_line_pointer;
    msp430_operands (opcode, str);
    input_line_pointer = __t;
  }
a765 2
/* Parse instruction operands.
   Return binary opcode.  */
d767 3
a769 4
static unsigned int
msp430_operands (opcode, line)
     struct msp430_opcode_s *opcode;
     char *line;
d771 1
a771 9
  int bin = opcode->bin_opcode;	/* opcode mask.  */
  int __is;
  char l1[MAX_OP_LEN], l2[MAX_OP_LEN];
  char *frag;
  int where;
  struct msp430_operand_s op1, op2;
  int res = 0;
  static short ZEROS = 0;
  int byte_op, imm_op;
d773 2
a774 8
  /* opcode is the one from opcodes table
     line contains something like
     [.w] @@r2+, 5(R1)
     or
     .b @@r2+, 5(R1).  */

  /* Check if byte or word operation.  */
  if (*line == '.' && TOLOWER (*(line + 1)) == 'b')
d776 3
a778 5
      bin |= BYTE_OPERATION;
      byte_op = 1;
    }
  else
    byte_op = 0;
d780 6
a785 3
  /* skip .[bwBW].  */
  while (! ISSPACE (*line) && *line)
    line++;
d787 1
a787 6
  if (opcode->insn_opnumb && (!*line || *line == '\n'))
    {
      as_bad (_("instruction %s requires %d operand(s)"),
	      opcode->name, opcode->insn_opnumb);
      return 0;
    }
d789 30
a818 4
  memset (l1, 0, sizeof (l1));
  memset (l2, 0, sizeof (l2));
  memset (&op1, 0, sizeof (op1));
  memset (&op2, 0, sizeof (op2));
d820 5
a824 1
  imm_op = 0;
d826 2
a827 4
  switch (opcode->fmt)
    {
    case 0:			/* Emulated.  */
      switch (opcode->insn_opnumb)
d829 1
a829 12
	case 0:
	  /* Set/clear bits instructions.  */
	  __is = 2;
	  frag = frag_more (__is);
	  bfd_putl16 ((bfd_vma) bin, frag);
	  break;
	case 1:
	  /* Something which works with destination operand.  */
	  line = extract_operand (line, l1, sizeof (l1));
	  res = msp430_dstoperand (&op1, l1, opcode->bin_opcode);
	  if (res)
	    break;
d831 11
a841 7
	  bin |= (op1.reg | (op1.am << 7));
	  __is = 1 + op1.ol;
	  frag = frag_more (2 * __is);
	  where = frag - frag_now->fr_literal;
	  bfd_putl16 ((bfd_vma) bin, frag);

	  if (op1.mode == OP_EXP)
d843 2
a844 6
	      where += 2;
	      bfd_putl16 ((bfd_vma) ZEROS, frag + 2);

	      if (op1.reg)
		fix_new_exp (frag_now, where, 2,
			     &(op1.exp), FALSE, CHECK_RELOC_MSP430);
d846 2
a847 2
		fix_new_exp (frag_now, where, 2,
			     &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
a848 1
	  break;
d850 5
a854 8
	case 2:
	  {
	    /* Shift instruction.  */
	    line = extract_operand (line, l1, sizeof (l1));
	    strncpy (l2, l1, sizeof (l2));
	    l2[sizeof (l2) - 1] = '\0';
	    res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
	    res += msp430_dstoperand (&op2, l2, opcode->bin_opcode);
d856 2
a857 2
	    if (res)
	      break;	/* An error occurred.  All warnings were done before.  */
d859 1
a859 1
	    bin |= (op2.reg | (op1.reg << 8) | (op1.am << 4) | (op2.am << 7));
d861 1
a861 50
	    __is = 1 + op1.ol + op2.ol;	/* insn size in words.  */
	    frag = frag_more (2 * __is);
	    where = frag - frag_now->fr_literal;
	    bfd_putl16 ((bfd_vma) bin, frag);

	    if (op1.mode == OP_EXP)
	      {
		where += 2;	/* Advance 'where' as we do not know _where_.  */
		bfd_putl16 ((bfd_vma) ZEROS, frag + 2);

		if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
		  fix_new_exp (frag_now, where, 2,
			       &(op1.exp), FALSE, CHECK_RELOC_MSP430);
		else
		  fix_new_exp (frag_now, where, 2,
			       &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
	      }

	    if (op2.mode == OP_EXP)
	      {
		imm_op = 0;
		bfd_putl16 ((bfd_vma) ZEROS, frag + 2 + ((__is == 3) ? 2 : 0));

		if (op2.reg)	/* Not PC relative.  */
		  fix_new_exp (frag_now, where + 2, 2,
			       &(op2.exp), FALSE, CHECK_RELOC_MSP430);
		else
		  fix_new_exp (frag_now, where + 2, 2,
			       &(op2.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
	      }
	    break;
	  }
	case 3:
	  /* Branch instruction => mov dst, r0.  */
	  line = extract_operand (line, l1, sizeof (l1));

	  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
	  if (res)
	    break;

	  byte_op = 0;
	  imm_op = 0;

	  bin |= ((op1.reg << 8) | (op1.am << 4));
	  __is = 1 + op1.ol;
	  frag = frag_more (2 * __is);
	  where = frag - frag_now->fr_literal;
	  bfd_putl16 ((bfd_vma) bin, frag);

	  if (op1.mode == OP_EXP)
d863 4
a866 9
	      where += 2;
	      bfd_putl16 ((bfd_vma) ZEROS, frag + 2);

	      if (op1.reg || (op1.reg == 0 && op1.am == 3))
		fix_new_exp (frag_now, where, 2,
			     &(op1.exp), FALSE, CHECK_RELOC_MSP430);
	      else
		fix_new_exp (frag_now, where, 2,
			     &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
d868 59
a926 1
	  break;
d928 16
a943 1
      break;
d945 49
a993 5
    case 1:			/* Format 1, double operand.  */
      line = extract_operand (line, l1, sizeof (l1));
      line = extract_operand (line, l2, sizeof (l2));
      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
      res += msp430_dstoperand (&op2, l2, opcode->bin_opcode);
d995 2
a996 2
      if (res)
	break;			/* Error occurred.  All warnings were done before.  */
d998 4
a1001 1
      bin |= (op2.reg | (op1.reg << 8) | (op1.am << 4) | (op2.am << 7));
d1003 9
a1011 4
      __is = 1 + op1.ol + op2.ol;	/* insn size in words.  */
      frag = frag_more (2 * __is);
      where = frag - frag_now->fr_literal;
      bfd_putl16 ((bfd_vma) bin, frag);
d1013 9
a1021 1
      if (op1.mode == OP_EXP)
d1023 4
a1026 6
	  where += 2;		/* Advance where as we do not know _where_.  */
	  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);

	  if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
	    fix_new_exp (frag_now, where, 2,
			 &(op1.exp), FALSE, CHECK_RELOC_MSP430);
d1028 2
a1029 2
	    fix_new_exp (frag_now, where, 2,
			 &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
d1031 8
d1040 1
a1040 1
      if (op2.mode == OP_EXP)
d1042 2
a1043 9
	  imm_op = 0;
	  bfd_putl16 ((bfd_vma) ZEROS, frag + 2 + ((__is == 3) ? 2 : 0));

	  if (op2.reg)		/* Not PC relative.  */
	    fix_new_exp (frag_now, where + 2, 2,
			 &(op2.exp), FALSE, CHECK_RELOC_MSP430);
	  else
	    fix_new_exp (frag_now, where + 2, 2,
			 &(op2.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
a1044 1
      break;
d1046 2
a1047 2
    case 2:			/* Single-operand mostly instr.  */
      if (opcode->insn_opnumb == 0)
d1049 2
a1050 4
	  /* reti instruction.  */
	  frag = frag_more (2);
	  bfd_putl16 ((bfd_vma) bin, frag);
	  break;
d1053 1
a1053 4
      line = extract_operand (line, l1, sizeof (l1));
      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
      if (res)
	break;		/* Error in operand.  */
d1055 1
a1055 7
      bin |= op1.reg | (op1.am << 4);
      __is = 1 + op1.ol;
      frag = frag_more (2 * __is);
      where = frag - frag_now->fr_literal;
      bfd_putl16 ((bfd_vma) bin, frag);

      if (op1.mode == OP_EXP)
d1057 2
a1058 8
	  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);

	  if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
	    fix_new_exp (frag_now, where + 2, 2,
			 &(op1.exp), FALSE, CHECK_RELOC_MSP430);
	  else
	    fix_new_exp (frag_now, where + 2, 2,
			 &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);
a1059 1
      break;
d1061 7
a1067 4
    case 3:			/* Conditional jumps instructions.  */
      line = extract_operand (line, l1, sizeof (l1));
      /* l1 is a label.  */
      if (l1[0])
d1069 3
a1071 2
	  char *m = l1;
	  expressionS exp;
d1073 2
a1074 2
	  if (*m == '$')
	    m++;
d1076 6
a1081 2
	  parse_exp (m, &exp);
	  frag = frag_more (2);	/* Instr size is 1 word.  */
d1083 1
a1083 1
	  /* In order to handle something like:
d1085 7
a1091 6
	     and #0x8000, r5
	     tst r5
	     jz   4     ;       skip next 4 bytes
	     inv r5
	     inc r5
	     nop        ;       will jump here if r5 positive or zero
d1093 5
a1097 1
	     jCOND      -n      ;assumes jump n bytes backward:
d1099 8
a1106 2
	     mov r5,r6
	     jmp -2
d1108 12
a1119 4
	     is equal to:
	     lab:
	     mov r5,r6
	     jmp lab
d1121 1
a1121 3
	     jCOND      $n      ; jump from PC in either direction.  */

	  if (exp.X_op == O_constant)
d1123 2
a1124 21
	      int x = exp.X_add_number;

	      if (x & 1)
		{
		  as_warn (_("Even number required. Rounded to %d"), x + 1);
		  x++;
		}

	      if ((*l1 == '$' && x > 0) || x < 0)
		x -= 2;

	      x >>= 1;

	      if (x > 512 || x < -511)
		{
		  as_bad (_("Wrong displacement  %d"), x << 1);
		  break;
		}

	      bin |= x & 0x3ff;
	      bfd_putl16 ((bfd_vma) bin, frag);
d1126 1
a1126 1
	  else if (exp.X_op == O_symbol && *l1 != '$')
d1128 3
a1130 3
	      where = frag - frag_now->fr_literal;
	      fix_new_exp (frag_now, where, 2,
			   &exp, TRUE, BFD_RELOC_MSP430_10_PCREL);
d1132 4
a1135 1
	      bfd_putl16 ((bfd_vma) bin, frag);
d1137 12
a1148 1
	  else if (*l1 == '$')
d1150 2
a1151 2
	      as_bad (_("instruction requires label sans '$'"));
	      break;
d1153 2
a1154 1
	  else
d1156 4
a1159 3
	      as_bad (_
		      ("instruction requires label or value in range -511:512"));
	      break;
d1162 2
d1166 34
a1199 2
	  as_bad (_("instruction requires label"));
	  break;
d1201 10
a1210 1
      break;
d1212 18
a1229 2
    default:
      as_bad (_("Ilegal instruction or not implmented opcode."));
d1231 1
d1233 3
a1235 2
  input_line_pointer = line;
  return 0;
d1238 1
d1240 1
a1240 4
msp430_dstoperand (op, l, bin)
     struct msp430_operand_s *op;
     char *l;
     int bin;
d1243 2
a1244 1
  int ret = msp430_srcoperand (op, l, bin, &dummy);
d1256 1
d1276 5
a1280 3
static int
check_reg (t)
     char *t;
d1282 9
a1290 1
  /* If this is a reg numb, str 't' must be a number from 0 - 15.  */
d1292 5
a1296 2
  if (strlen (t) > 2 && *(t + 2) != '+')
    return 1;
d1298 2
a1299 1
  while (*t)
d1301 2
a1302 3
      if ((*t < '0' || *t > '9') && *t != '+')
	break;
      t++;
d1304 2
d1307 3
a1309 2
  if (*t)
    return 1;
d1311 6
a1316 2
  return 0;
}
d1318 4
d1323 1
a1323 8
static int
msp430_srcoperand (op, l, bin, imm_op)
     struct msp430_operand_s *op;
     char *l;
     int bin;
     int *imm_op;
{
  char *__tl = l;
d1325 1
a1325 2
  /* Check if an immediate #VALUE.  The hash sign should be only at the beginning!  */
  if (*l == '#')
d1327 21
a1347 3
      char *h = l;
      int vshift = -1;
      int rval = 0;
d1349 32
a1380 6
      /* Check if there is:
	 llo(x) - least significant 16 bits, x &= 0xffff
	 lhi(x) - x = (x >> 16) & 0xffff,
	 hlo(x) - x = (x >> 32) & 0xffff,
	 hhi(x) - x = (x >> 48) & 0xffff
	 The value _MUST_ be constant expression: #hlo(1231231231).  */
d1382 4
a1385 1
      *imm_op = 1;
d1387 7
a1393 30
      if (strncasecmp (h, "#llo(", 5) == 0)
	{
	  vshift = 0;
	  rval = 3;
	}
      else if (strncasecmp (h, "#lhi(", 5) == 0)
	{
	  vshift = 1;
	  rval = 3;
	}
      else if (strncasecmp (h, "#hlo(", 5) == 0)
	{
	  vshift = 2;
	  rval = 3;
	}
      else if (strncasecmp (h, "#hhi(", 5) == 0)
	{
	  vshift = 3;
	  rval = 3;
	}
      else if (strncasecmp (h, "#lo(", 4) == 0)
	{
	  vshift = 0;
	  rval = 2;
	}
      else if (strncasecmp (h, "#hi(", 4) == 0)
	{
	  vshift = 1;
	  rval = 2;
	}
d1395 4
a1398 9
      op->reg = 0;		/* Reg PC.  */
      op->am = 3;
      op->ol = 1;		/* Immediate  will follow an instruction.  */
      __tl = h + 1 + rval;
      op->mode = OP_EXP;
      parse_exp (__tl, &(op->exp));
      if (op->exp.X_op == O_constant)
	{
	  int x = op->exp.X_add_number;
d1400 12
a1411 18
	  if (vshift == 0)
	    {
	      x = x & 0xffff;
	      op->exp.X_add_number = x;
	    }
	  else if (vshift == 1)
	    {
	      x = (x >> 16) & 0xffff;
	      op->exp.X_add_number = x;
	    }
	  else if (vshift > 1)
	    {
	      if (x < 0)
		op->exp.X_add_number = -1;
	      else
		op->exp.X_add_number = 0;	/* Nothing left.  */
	      x = op->exp.X_add_number;
	    }
d1413 3
a1415 5
	  if (op->exp.X_add_number > 65535 || op->exp.X_add_number < -32768)
	    {
	      as_bad (_("value %ld out of range. Use #lo() or #hi()"), x);
	      return 1;
	    }
d1417 2
a1418 2
	  /* Now check constants.  */
	  /* Substitute register mode with a constant generator if applicable.  */
d1420 5
a1424 1
	  x = (short) x;	/* Extend sign.  */
d1426 1
a1426 1
	  if (x == 0)
d1428 6
a1433 34
	      op->reg = 3;
	      op->am = 0;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 1)
	    {
	      op->reg = 3;
	      op->am = 1;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 2)
	    {
	      op->reg = 3;
	      op->am = 2;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == -1)
	    {
	      op->reg = 3;
	      op->am = 3;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 4)
	    {
#ifdef PUSH_1X_WORKAROUND
	      if (bin == 0x1200)
		{
		  /* Remove warning as confusing.
		     as_warn(_("Hardware push bug workaround")); */
		}
d1435 2
a1436 24
#endif
		{
		  op->reg = 2;
		  op->am = 2;
		  op->ol = 0;
		  op->mode = OP_REG;
		}
	    }
	  else if (x == 8)
	    {
#ifdef PUSH_1X_WORKAROUND
	      if (bin == 0x1200)
		{
		  /* Remove warning as confusing.
		     as_warn(_("Hardware push bug workaround")); */
		}
	      else
#endif
		{
		  op->reg = 2;
		  op->am = 3;
		  op->ol = 0;
		  op->mode = OP_REG;
		}
d1438 1
d1440 19
a1458 1
      else if (op->exp.X_op == O_symbol)
d1460 9
a1468 1
	  op->mode = OP_EXP;
d1470 2
a1471 1
      else if (op->exp.X_op == O_big)
d1473 6
a1478 7
	  short x;
	  if (vshift != -1)
	    {
	      op->exp.X_op = O_constant;
	      op->exp.X_add_number = 0xffff & generic_bignum[vshift];
	      x = op->exp.X_add_number;
	    }
d1480 4
a1483 6
	    {
	      as_bad (_
		      ("unknown expression in operand %s. use #llo() #lhi() #hlo() #hhi() "),
		      l);
	      return 1;
	    }
d1485 2
a1486 44
	  if (x == 0)
	    {
	      op->reg = 3;
	      op->am = 0;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 1)
	    {
	      op->reg = 3;
	      op->am = 1;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 2)
	    {
	      op->reg = 3;
	      op->am = 2;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == -1)
	    {
	      op->reg = 3;
	      op->am = 3;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 4)
	    {
	      op->reg = 2;
	      op->am = 2;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	  else if (x == 8)
	    {
	      op->reg = 2;
	      op->am = 3;
	      op->ol = 0;
	      op->mode = OP_REG;
	    }
	}
      else
d1488 4
a1491 1
	  as_bad (_("unknown operand %s"), l);
a1492 2
      return 0;
    }
d1494 10
a1503 4
  /* Check if absolute &VALUE (assume that we can construct something like ((a&b)<<7 + 25).  */
  if (*l == '&')
    {
      char *h = l;
d1505 1
a1505 7
      op->reg = 2;		/* reg 2 in absolute addr mode.  */
      op->am = 1;		/* mode As == 01 bin.  */
      op->ol = 1;		/* Immediate value followed by instruction.  */
      __tl = h + 1;
      parse_exp (__tl, &(op->exp));
      op->mode = OP_EXP;
      if (op->exp.X_op == O_constant)
d1507 8
a1514 6
	  int x = op->exp.X_add_number;
	  if (x > 65535 || x < -32768)
	    {
	      as_bad (_("value out of range: %d"), x);
	      return 1;
	    }
d1516 6
a1521 1
      else if (op->exp.X_op == O_symbol)
d1523 19
a1541 8
	}
      else
	{
	  as_bad (_("unknown expression in operand %s"), l);
	  return 1;
	}
      return 0;
    }
d1543 2
a1544 5
  /* Check if indirect register mode @@Rn / postincrement @@Rn+.  */
  if (*l == '@@')
    {
      char *t = l;
      char *m = strchr (l, '+');
d1546 4
a1549 5
      if (t != l)
	{
	  as_bad (_("unknown addressing mode %s"), l);
	  return 1;
	}
d1551 1
a1551 6
      t++;
      if (*t != 'r' && *t != 'R')
	{
	  as_bad (_("unknown addressing mode %s"), l);
	  return 1;
	}
d1553 3
a1555 1
      t++;	/* Points to the reg value.  */
d1557 5
a1561 5
      if (check_reg (t))
	{
	  as_bad (_("Bad register name r%s"), t);
	  return 1;
	}
d1563 2
a1564 11
      op->mode = OP_REG;
      op->am = m ? 3 : 2;
      op->ol = 0;
      if (m)
	*m = 0;			/* strip '+' */
      op->reg = atoi (t);
      if (op->reg < 0 || op->reg > 15)
	{
	  as_bad (_("MSP430 does not have %d registers"), op->reg);
	  return 1;
	}
d1566 1
a1566 2
      return 0;
    }
d1568 5
a1572 6
  /* Check if register indexed X(Rn).  */
  do
    {
      char *h = strrchr (l, '(');
      char *m = strrchr (l, ')');
      char *t;
d1574 8
a1581 1
      *imm_op = 1;
d1583 15
a1597 3
      if (!h)
	break;
      if (!m)
d1599 2
a1600 2
	  as_bad (_("')' required"));
	  return 1;
d1602 1
d1604 3
a1606 7
      t = h;
      op->am = 1;
      op->ol = 1;
      /* Extract a register.  */
      t++;	/* Advance pointer.  */

      if (*t != 'r' && *t != 'R')
d1608 2
a1609 6
	  as_bad (_
		  ("unknown operator %s. Did you mean X(Rn) or #[hl][hl][oi](CONST) ?"),
		  l);
	  return 1;
	}
      t++;
d1611 3
a1613 12
      op->reg = *t - '0';
      if (op->reg > 9 || op->reg < 0)
	{
	  as_bad (_("unknown operator (r%s substituded as a register name"),
		  t);
	  return 1;
	}
      t++;
      if (*t != ')')
	{
	  op->reg = op->reg * 10;
	  op->reg += *t - '0';
d1615 2
a1616 6
	  if (op->reg > 15)
	    {
	      as_bad (_("unknown operator %s"), l);
	      return 1;
	    }
	  if (op->reg == 2)
d1618 2
a1619 3
	      as_bad (_("r2 should not be used in indexed addressing mode"));
	      return 1;
	    }
d1621 8
a1628 4
	  if (*(t + 1) != ')')
	    {
	      as_bad (_("unknown operator %s"), l);
	      return 1;
d1632 6
a1637 6
      /* Extract constant.  */
      __tl = l;
      *h = 0;
      op->mode = OP_EXP;
      parse_exp (__tl, &(op->exp));
      if (op->exp.X_op == O_constant)
d1639 6
a1644 1
	  int x = op->exp.X_add_number;
d1646 2
a1647 1
	  if (x > 65535 || x < -32768)
d1649 2
a1650 3
	      as_bad (_("value out of range: %d"), x);
	      return 1;
	    }
d1652 9
a1660 6
	  if (x == 0)
	    {
	      op->mode = OP_REG;
	      op->am = 2;
	      op->ol = 0;
	      return 0;
a1662 8
      else if (op->exp.X_op == O_symbol)
	{
	}
      else
	{
	  as_bad (_("unknown expression in operand %s"), l);
	  return 1;
	}
d1664 5
a1668 1
      return 0;
a1669 1
  while (0);
d1671 3
a1673 4
  /* Register mode 'mov r1,r2'.  */
  do
    {
      char *t = l;
d1675 6
a1680 4
      /* Operand should be a register.  */
      if (*t == 'r' || *t == 'R')
	{
	  int x = atoi (t + 1);
d1682 2
a1683 2
	  if (check_reg (t + 1))
	    break;
d1685 5
a1689 9
	  if (x < 0 || x > 15)
	    break;		/* Symbolic mode.  */

	  op->mode = OP_REG;
	  op->am = 0;
	  op->ol = 0;
	  op->reg = x;
	  return 0;
	}
a1690 1
  while (0);
d1692 1
a1692 2
  /* Symbolic mode 'mov a, b' == 'mov x(pc), y(pc)'.  */
  do
d1694 3
a1696 1
      char *t = l;
d1698 1
a1698 1
      __tl = l;
d1700 5
a1704 10
      while (*t)
	{
	  /* alpha/number    underline     dot for labels.  */
	  if (! ISALNUM (*t) && *t != '_' && *t != '.')
	    {
	      as_bad (_("unknown operand %s"), l);
	      return 1;
	    }
	  t++;
	}
d1706 2
a1707 9
      op->mode = OP_EXP;
      op->reg = 0;		/* PC relative... be careful.  */
      op->am = 1;
      op->ol = 1;
      __tl = l;
      parse_exp (__tl, &(op->exp));
      return 0;
    }
  while (0);
d1709 3
a1711 3
  /* Unreachable.  */
  as_bad (_("unknown addressing mode for operand %s"), l);
  return 1;
a1713 1

d1718 1
a1718 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d1732 1
a1732 3
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec;
d1746 1
a1746 4
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
     segT seg;
d1748 1
a1748 1
  unsigned char *where;
d1826 1
d1885 1
a1885 3
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d1887 1
a1887 1
  arelent *reloc;
d1889 1
a1889 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d1891 1
a1891 1
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d1913 31
a1943 1
/* Parse ordinary expression.  */
d1945 4
a1948 4
static char *
parse_exp (s, op)
     char *s;
     expressionS *op;
d1950 113
a2062 5
  input_line_pointer = s;
  expression (op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  return input_line_pointer;
d2065 2
d2068 3
a2070 4
int
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
d2072 60
a2131 2
  abort ();
  return 0;
@


1.9
log
@Remove redundant returns in void functions.
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003 Free Software Foundation, Inc.
d122 3
d138 2
d144 1
d149 4
d202 1
a202 2
md_show_usage (stream)
     FILE *stream;
d217 1
d221 1
a221 1
	     "                  msp430x412  msp430x413\n"
d224 1
@


1.8
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@a1495 1
  return;
@


1.7
log
@	* config/tc-msp430.c (MAX_OP_LEN): Set to 256.
	(msp430_operands): Remove redundant l2[16] within switch-case.
@
text
@d571 1
a571 1
	      break;	/* An error occured.  All warnings were done before.  */
d647 1
a647 1
	break;			/* Error occured.  All warnings were done before.  */
d744 1
a744 1
	     is equial to:
d963 1
a963 1
	  /* Substitude register mode with a constant generator if applicable.  */
d1132 1
a1132 1
  /* Check if inderect register mode @@Rn / postincrement @@Rn+.  */
@


1.6
log
@Add MSP430 variants
@
text
@d64 1
a64 1
#define MAX_OP_LEN	64
d202 2
a203 2
             "                  msp430x1222 msp430x1232\n"
             "                  msp430x133  msp430x135\n"
d212 2
a213 2
             "                  msp430xE423 msp430xE425 msp430E427\n"
             "                  msp430xW423 msp430xW425 msp430W427\n"
a562 2
	    char l2[16];

d565 2
a566 1
	    strncpy (l2, l1, 16);
d684 1
a684 1
      if (opcode->insn_opnumb == 0)	
d686 1
a686 1
	  /* reti instruction.  */	  
d888 5
a892 5
         llo(x) - least significant 16 bits, x &= 0xffff
         lhi(x) - x = (x >> 16) & 0xffff,
         hlo(x) - x = (x >> 32) & 0xffff,
         hhi(x) - x = (x >> 48) & 0xffff
         The value _MUST_ be constant expression: #hlo(1231231231).  */
d1426 1
a1426 1
         value, and stuff the instruction back again.  */
@


1.5
log
@	* config/tc-msp430.c (msp430_srcoperand): Extend 'push' bug workaround
	to all arches.
@
text
@d74 1
d78 2
a79 1
#define MSP430_ISA_41   41
d83 2
a84 1
#define MSP430_ISA_110	110
a86 2
#define MSP430_ISA_15   15
#define MSP430_ISA_16   16
d97 3
a99 3
  {"msp430x122", MSP430_ISA_12, bfd_mach_msp12},
  {"msp430x122", MSP430_ISA_12, bfd_mach_msp12},
  {"msp430x1222",MSP430_ISA_12, bfd_mach_msp12},
d102 2
d105 1
d107 1
d110 2
d115 8
a122 2
  {"msp430x412", MSP430_ISA_41, bfd_mach_msp41},
  {"msp430x413", MSP430_ISA_41, bfd_mach_msp41},
d132 11
a142 5
  {"msp430x1101",MSP430_ISA_110, bfd_mach_msp110},
  {"msp430x1111",MSP430_ISA_110, bfd_mach_msp110},
  {"msp430x1121",MSP430_ISA_110, bfd_mach_msp110},
  {"msp430x1331",MSP430_ISA_13, bfd_mach_msp13},
  {"msp430x1351",MSP430_ISA_13, bfd_mach_msp13},
a148 6
  {"msp430x167", MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x168", MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x169", MSP430_ISA_16, bfd_mach_msp16},
  {"msp430x155", MSP430_ISA_15, bfd_mach_msp15},
  {"msp430x156", MSP430_ISA_15, bfd_mach_msp15},
  {"msp430x157", MSP430_ISA_15, bfd_mach_msp15},
d212 2
@


1.4
log
@(md_show_usage): Add missing lines to known cpus list.
@
text
@d984 1
a984 5
	      if (bin == 0x1200
		  && (msp430_mcu->isa == MSP430_ISA_11
		      || msp430_mcu->isa == MSP430_ISA_12
		      || msp430_mcu->isa == MSP430_ISA_13
		      || msp430_mcu->isa == MSP430_ISA_14))
d1001 1
a1001 5
	      if (bin == 0x1200
		  && (msp430_mcu->isa == MSP430_ISA_11
		      || msp430_mcu->isa == MSP430_ISA_12
		      || msp430_mcu->isa == MSP430_ISA_13
		      || msp430_mcu->isa == MSP430_ISA_14))
@


1.3
log
@(mcu_types): Add recenly announced x1122 and x1123 devices, add missed x437.
(md_show_usage): Sort device list.
@
text
@d189 2
@


1.2
log
@Replace occurences of 'tolower' with 'TOLOWER'.
@
text
@d99 2
d126 1
d185 14
a198 15
	     "			msp430x1101 msp430x1111 msp430x1121\n"
	     "			msp430x1331 msp430x1351\n"
	     "			msp430x1222 msp430x1232\n"
	     "			msp430x311 msp430x312 msp430x313 msp430x314 msp430x315\n"
	     "			msp430x323 msp430x325\n"
	     "			msp430x336 msp430x337\n"
	     "			msp430x412 msp430x413\n"
	     "			msp430x110 msp430x112\n"
	     "			msp430x122 msp430x123\n"
	     "			msp430x133 msp430x135\n"
	     "			msp430x147 msp430x148 msp430x149\n"
	     "			msp430x167 msp430x168 msp430x169\n"
	     "			msp430x155 msp430x156 msp430x157\n"
	     "			msp430x447 msp430x448 msp430x449\n"
	     "			msp430x435 msp430x436\n"));
@


1.1
log
@Add support for msp430.
@
text
@d3 1
a3 1
  Copyright (C) 2002 Free Software Foundation, Inc.
d427 1
a427 1
      char a = tolower (cmd[i]);
d478 1
a478 1
  if (*line == '.' && tolower (*(line + 1)) == 'b')
@

