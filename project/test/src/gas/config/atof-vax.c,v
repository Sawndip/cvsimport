head	1.13;
access;
symbols
	binutils-2_24-branch:1.13.0.2
	binutils-2_24-branchpoint:1.13
	binutils-2_21_1:1.12
	binutils-2_23_2:1.12
	binutils-2_23_1:1.12
	binutils-2_23:1.12
	binutils-2_23-branch:1.12.0.18
	binutils-2_23-branchpoint:1.12
	binutils-2_22_branch:1.12.0.16
	binutils-2_22:1.12
	binutils-2_22-branch:1.12.0.14
	binutils-2_22-branchpoint:1.12
	binutils-2_21:1.12
	binutils-2_21-branch:1.12.0.12
	binutils-2_21-branchpoint:1.12
	binutils-2_20_1:1.12
	binutils-2_20:1.12
	binutils-arc-20081103-branch:1.12.0.10
	binutils-arc-20081103-branchpoint:1.12
	binutils-2_20-branch:1.12.0.8
	binutils-2_20-branchpoint:1.12
	dje-cgen-play1-branch:1.12.0.6
	dje-cgen-play1-branchpoint:1.12
	arc-20081103-branch:1.12.0.4
	arc-20081103-branchpoint:1.12
	binutils-2_19_1:1.12
	binutils-2_19:1.12
	binutils-2_19-branch:1.12.0.2
	binutils-2_19-branchpoint:1.12
	binutils-2_18:1.11
	binutils-2_18-branch:1.11.0.2
	binutils-2_18-branchpoint:1.11
	binutils-csl-coldfire-4_1-32:1.8
	binutils-csl-sourcerygxx-4_1-32:1.8
	binutils-csl-innovasic-fido-3_4_4-33:1.8
	binutils-csl-sourcerygxx-3_4_4-32:1.5
	binutils-csl-coldfire-4_1-30:1.8
	binutils-csl-sourcerygxx-4_1-30:1.8
	binutils-csl-coldfire-4_1-28:1.8
	binutils-csl-sourcerygxx-4_1-29:1.8
	binutils-csl-sourcerygxx-4_1-28:1.8
	binutils-csl-arm-2006q3-27:1.8
	binutils-csl-sourcerygxx-4_1-27:1.8
	binutils-csl-arm-2006q3-26:1.8
	binutils-csl-sourcerygxx-4_1-26:1.8
	binutils-csl-sourcerygxx-4_1-25:1.8
	binutils-csl-sourcerygxx-4_1-24:1.8
	binutils-csl-sourcerygxx-4_1-23:1.8
	binutils-csl-sourcerygxx-4_1-21:1.8
	binutils-csl-arm-2006q3-21:1.8
	binutils-csl-sourcerygxx-4_1-22:1.8
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.8
	binutils-csl-sourcerygxx-4_1-20:1.8
	binutils-csl-arm-2006q3-19:1.8
	binutils-csl-sourcerygxx-4_1-19:1.8
	binutils-csl-sourcerygxx-4_1-18:1.8
	binutils-csl-renesas-4_1-9:1.8
	binutils-csl-sourcerygxx-3_4_4-25:1.5
	binutils-csl-renesas-4_1-8:1.8
	binutils-csl-renesas-4_1-7:1.8
	binutils-csl-renesas-4_1-6:1.8
	binutils-csl-sourcerygxx-4_1-17:1.8
	binutils-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-15:1.8
	binutils-csl-sourcerygxx-4_1-13:1.8
	binutils-2_17:1.8
	binutils-csl-sourcerygxx-4_1-12:1.8
	binutils-csl-sourcerygxx-3_4_4-21:1.8
	binutils-csl-wrs-linux-3_4_4-24:1.5
	binutils-csl-wrs-linux-3_4_4-23:1.5
	binutils-csl-sourcerygxx-4_1-9:1.8
	binutils-csl-sourcerygxx-4_1-8:1.8
	binutils-csl-sourcerygxx-4_1-7:1.8
	binutils-csl-arm-2006q1-6:1.8
	binutils-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-wrs-linux-3_4_4-22:1.5
	binutils-csl-coldfire-4_1-11:1.8
	binutils-csl-sourcerygxx-3_4_4-19:1.8
	binutils-csl-coldfire-4_1-10:1.8
	binutils-csl-sourcerygxx-4_1-5:1.8
	binutils-csl-sourcerygxx-4_1-4:1.8
	binutils-csl-wrs-linux-3_4_4-21:1.5
	binutils-csl-morpho-4_1-4:1.8
	binutils-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-wrs-linux-3_4_4-20:1.5
	binutils-2_17-branch:1.8.0.4
	binutils-2_17-branchpoint:1.8
	binutils-csl-2_17-branch:1.8.0.2
	binutils-csl-2_17-branchpoint:1.8
	binutils-csl-gxxpro-3_4-branch:1.5.0.18
	binutils-csl-gxxpro-3_4-branchpoint:1.5
	binutils-2_16_1:1.5
	binutils-csl-arm-2005q1b:1.5
	binutils-2_16:1.5
	binutils-csl-arm-2005q1a:1.5
	binutils-csl-arm-2005q1-branch:1.5.0.16
	binutils-csl-arm-2005q1-branchpoint:1.5
	binutils-2_16-branch:1.5.0.14
	binutils-2_16-branchpoint:1.5
	csl-arm-2004-q3d:1.5
	csl-arm-2004-q3:1.5
	binutils-2_15:1.5
	binutils-2_15-branchpoint:1.5
	csl-arm-2004-q1a:1.5
	csl-arm-2004-q1:1.5
	binutils-2_15-branch:1.5.0.12
	cagney_bfdfile-20040213-branch:1.5.0.10
	cagney_bfdfile-20040213-branchpoint:1.5
	cagney_bigcore-20040122-branch:1.5.0.8
	cagney_bigcore-20040122-branchpoint:1.5
	csl-arm-2003-q4:1.5
	binutils-2_14:1.5
	binutils-2_14-branch:1.5.0.6
	binutils-2_14-branchpoint:1.5
	binutils-2_13_2_1:1.5
	binutils-2_13_2:1.5
	binutils-2_13_1:1.5
	binutils-2_13:1.5
	binutils-2_13-branchpoint:1.5
	binutils-2_13-branch:1.5.0.4
	binutils-2_12_1:1.5
	binutils-2_12:1.5
	binutils-2_12-branch:1.5.0.2
	binutils-2_12-branchpoint:1.5
	cygnus_cvs_20020108_pre:1.5
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.13
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2012.11.09.08.29.32;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.17.16.45.54;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.21.13.04.14;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.21.12.50.49;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.05.09.12.52;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.01.14.17.16;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.23.11.18.13;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.14.20.57.30;	author kazu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.12.03.34.29;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.09.12.02.12.38;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.4.2.1
date	2001.06.07.03.15.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@/* atof_vax.c - turn a Flonum into a VAX floating point number
   Copyright 1987, 1992, 1993, 1995, 1997, 1999, 2000, 2005, 2007
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"

/* Precision in LittleNums.  */
#define MAX_PRECISION	8
#define H_PRECISION	8
#define G_PRECISION	4
#define D_PRECISION	4
#define F_PRECISION	2

/* Length in LittleNums of guard bits.  */
#define GUARD		2

int flonum_gen2vax (int, FLONUM_TYPE *, LITTLENUM_TYPE *);

/* Number of chars in flonum type 'letter'.  */

static unsigned int
atof_vax_sizeof (int letter)
{
  int return_value;

  /* Permitting uppercase letters is probably a bad idea.
     Please use only lower-cased letters in case the upper-cased
     ones become unsupported!  */
  switch (letter)
    {
    case 'f':
    case 'F':
      return_value = 4;
      break;

    case 'd':
    case 'D':
    case 'g':
    case 'G':
      return_value = 8;
      break;

    case 'h':
    case 'H':
      return_value = 16;
      break;

    default:
      return_value = 0;
      break;
    }

  return return_value;
}

static const long mask[] =
{
  0x00000000,
  0x00000001,
  0x00000003,
  0x00000007,
  0x0000000f,
  0x0000001f,
  0x0000003f,
  0x0000007f,
  0x000000ff,
  0x000001ff,
  0x000003ff,
  0x000007ff,
  0x00000fff,
  0x00001fff,
  0x00003fff,
  0x00007fff,
  0x0000ffff,
  0x0001ffff,
  0x0003ffff,
  0x0007ffff,
  0x000fffff,
  0x001fffff,
  0x003fffff,
  0x007fffff,
  0x00ffffff,
  0x01ffffff,
  0x03ffffff,
  0x07ffffff,
  0x0fffffff,
  0x1fffffff,
  0x3fffffff,
  0x7fffffff,
  0xffffffff
};


/* Shared between flonum_gen2vax and next_bits.  */
static int bits_left_in_littlenum;
static LITTLENUM_TYPE *littlenum_pointer;
static LITTLENUM_TYPE *littlenum_end;

static int
next_bits (int number_of_bits)
{
  int return_value;

  if (littlenum_pointer < littlenum_end)
    return 0;
  if (number_of_bits >= bits_left_in_littlenum)
    {
      return_value = mask[bits_left_in_littlenum] & *littlenum_pointer;
      number_of_bits -= bits_left_in_littlenum;
      return_value <<= number_of_bits;
      bits_left_in_littlenum = LITTLENUM_NUMBER_OF_BITS - number_of_bits;
      littlenum_pointer--;
      if (littlenum_pointer >= littlenum_end)
	return_value |= ((*littlenum_pointer) >> (bits_left_in_littlenum)) & mask[number_of_bits];
    }
  else
    {
      bits_left_in_littlenum -= number_of_bits;
      return_value = mask[number_of_bits] & ((*littlenum_pointer) >> bits_left_in_littlenum);
    }
  return return_value;
}

static void
make_invalid_floating_point_number (LITTLENUM_TYPE *words)
{
  *words = 0x8000;		/* Floating Reserved Operand Code.  */
}


static int			/* 0 means letter is OK.  */
what_kind_of_float (int letter,			/* In: lowercase please. What kind of float?  */
		    int *precisionP,		/* Number of 16-bit words in the float.  */
		    long *exponent_bitsP)	/* Number of exponent bits.  */
{
  int retval;

  retval = 0;
  switch (letter)
    {
    case 'f':
      *precisionP = F_PRECISION;
      *exponent_bitsP = 8;
      break;

    case 'd':
      *precisionP = D_PRECISION;
      *exponent_bitsP = 8;
      break;

    case 'g':
      *precisionP = G_PRECISION;
      *exponent_bitsP = 11;
      break;

    case 'h':
      *precisionP = H_PRECISION;
      *exponent_bitsP = 15;
      break;

    default:
      retval = 69;
      break;
    }
  return retval;
}

/* Warning: this returns 16-bit LITTLENUMs, because that is
   what the VAX thinks in. It is up to the caller to figure
   out any alignment problems and to conspire for the bytes/word
   to be emitted in the right order. Bigendians beware!  */

static char *
atof_vax (char *str,			/* Text to convert to binary.  */
	  int what_kind,		/* 'd', 'f', 'g', 'h'  */
	  LITTLENUM_TYPE *words)	/* Build the binary here.  */
{
  FLONUM_TYPE f;
  LITTLENUM_TYPE bits[MAX_PRECISION + MAX_PRECISION + GUARD];
  /* Extra bits for zeroed low-order bits.
     The 1st MAX_PRECISION are zeroed,
     the last contain flonum bits.  */
  char *return_value;
  int precision;		/* Number of 16-bit words in the format.  */
  long exponent_bits;

  return_value = str;
  f.low = bits + MAX_PRECISION;
  f.high = NULL;
  f.leader = NULL;
  f.exponent = 0;
  f.sign = '\0';

  if (what_kind_of_float (what_kind, &precision, &exponent_bits))
    {
      return_value = NULL;
      make_invalid_floating_point_number (words);
    }

  if (return_value)
    {
      memset (bits, '\0', sizeof (LITTLENUM_TYPE) * MAX_PRECISION);

      /* Use more LittleNums than seems
         necessary: the highest flonum may have
         15 leading 0 bits, so could be useless.  */
      f.high = f.low + precision - 1 + GUARD;

      if (atof_generic (&return_value, ".", "eE", &f))
	{
	  make_invalid_floating_point_number (words);
	  return_value = NULL;
	}
      else if (flonum_gen2vax (what_kind, &f, words))
	return_value = NULL;
    }

  return return_value;
}

/* In: a flonum, a vax floating point format.
   Out: a vax floating-point bit pattern.  */

int
flonum_gen2vax (int format_letter,	/* One of 'd' 'f' 'g' 'h'.  */
		FLONUM_TYPE *f,
		LITTLENUM_TYPE *words)	/* Deliver answer here.  */
{
  LITTLENUM_TYPE *lp;
  int precision;
  long exponent_bits;
  int return_value;		/* 0 == OK.  */

  return_value = what_kind_of_float (format_letter, &precision, &exponent_bits);

  if (return_value != 0)
    make_invalid_floating_point_number (words);

  else
    {
      if (f->low > f->leader)
	/* 0.0e0 seen.  */
	memset (words, '\0', sizeof (LITTLENUM_TYPE) * precision);

      else
	{
	  long exponent_1;
	  long exponent_2;
	  long exponent_3;
	  long exponent_4;
	  int exponent_skippage;
	  LITTLENUM_TYPE word1;

	  /* JF: Deal with new Nan, +Inf and -Inf codes.  */
	  if (f->sign != '-' && f->sign != '+')
	    {
	      make_invalid_floating_point_number (words);
	      return return_value;
	    }

	  /* All vaxen floating_point formats (so far) have:
	     Bit 15 is sign bit.
	     Bits 14:n are excess-whatever exponent.
	     Bits n-1:0 (if any) are most significant bits of fraction.
	     Bits 15:0 of the next word are the next most significant bits.
	     And so on for each other word.

	     All this to be compatible with a KF11?? (Which is still faster
	     than lots of vaxen I can think of, but it also has higher
	     maintenance costs ... sigh).

	     So we need: number of bits of exponent, number of bits of
	     mantissa.  */

	  bits_left_in_littlenum = LITTLENUM_NUMBER_OF_BITS;
	  littlenum_pointer = f->leader;
	  littlenum_end = f->low;
	  /* Seek (and forget) 1st significant bit.  */
	  for (exponent_skippage = 0;
	       !next_bits (1);
	       exponent_skippage++);

	  exponent_1 = f->exponent + f->leader + 1 - f->low;
	  /* Radix LITTLENUM_RADIX, point just higher than f->leader.  */
	  exponent_2 = exponent_1 * LITTLENUM_NUMBER_OF_BITS;
	  /* Radix 2.  */
	  exponent_3 = exponent_2 - exponent_skippage;
	  /* Forget leading zeros, forget 1st bit.  */
	  exponent_4 = exponent_3 + (1 << (exponent_bits - 1));
	  /* Offset exponent.  */

	  if (exponent_4 & ~mask[exponent_bits])
	    {
	      /* Exponent overflow. Lose immediately.  */
	      make_invalid_floating_point_number (words);

	      /* We leave return_value alone: admit we read the
	         number, but return a floating exception
	         because we can't encode the number.  */
	    }
	  else
	    {
	      lp = words;

	      /* Word 1. Sign, exponent and perhaps high bits.
	         Assume 2's complement integers.  */
	      word1 = (((exponent_4 & mask[exponent_bits]) << (15 - exponent_bits))
		       | ((f->sign == '+') ? 0 : 0x8000)
		       | next_bits (15 - exponent_bits));
	      *lp++ = word1;

	      /* The rest of the words are just mantissa bits.  */
	      for (; lp < words + precision; lp++)
		*lp = next_bits (LITTLENUM_NUMBER_OF_BITS);

	      if (next_bits (1))
		{
		  /* Since the NEXT bit is a 1, round UP the mantissa.
		     The cunning design of these hidden-1 floats permits
		     us to let the mantissa overflow into the exponent, and
		     it 'does the right thing'. However, we lose if the
		     highest-order bit of the lowest-order word flips.
		     Is that clear?  */
		  unsigned long carry;

		  /*
		    #if (sizeof(carry)) < ((sizeof(bits[0]) * BITS_PER_CHAR) + 2)
		    Please allow at least 1 more bit in carry than is in a LITTLENUM.
		    We need that extra bit to hold a carry during a LITTLENUM carry
		    propagation. Another extra bit (kept 0) will assure us that we
		    don't get a sticky sign bit after shifting right, and that
		    permits us to propagate the carry without any masking of bits.
		    #endif   */
		  for (carry = 1, lp--;
		       carry && (lp >= words);
		       lp--)
		    {
		      carry = *lp + carry;
		      *lp = carry;
		      carry >>= LITTLENUM_NUMBER_OF_BITS;
		    }

		  if ((word1 ^ *words) & (1 << (LITTLENUM_NUMBER_OF_BITS - 1)))
		    {
		      make_invalid_floating_point_number (words);
		      /* We leave return_value alone: admit we read the
		         number, but return a floating exception
		         because we can't encode the number.  */
		    }
		}
	    }
	}
    }
  return return_value;
}

/* JF this used to be in vax.c but this looks like a better place for it.  */

/* In:	input_line_pointer->the 1st character of a floating-point
  		number.
  	1 letter denoting the type of statement that wants a
  		binary floating point number returned.
  	Address of where to build floating point literal.
  		Assumed to be 'big enough'.
  	Address of where to return size of literal (in chars).
  
   Out:	Input_line_pointer->of next char after floating number.
  	Error message, or 0.
  	Floating point literal.
  	Number of chars we used for the literal.  */

#define MAXIMUM_NUMBER_OF_LITTLENUMS  8 	/* For .hfloats.  */

char *
vax_md_atof (int what_statement_type,
	     char *literalP,
	     int *sizeP)
{
  LITTLENUM_TYPE words[MAXIMUM_NUMBER_OF_LITTLENUMS];
  char kind_of_float;
  unsigned int number_of_chars;
  LITTLENUM_TYPE *littlenumP;

  switch (what_statement_type)
    {
    case 'F':
    case 'f':
      kind_of_float = 'f';
      break;

    case 'D':
    case 'd':
      kind_of_float = 'd';
      break;

    case 'g':
      kind_of_float = 'g';
      break;

    case 'h':
      kind_of_float = 'h';
      break;

    default:
      kind_of_float = 0;
      break;
    };

  if (kind_of_float)
    {
      LITTLENUM_TYPE *limit;

      input_line_pointer = atof_vax (input_line_pointer,
				     kind_of_float,
				     words);
      /* The atof_vax() builds up 16-bit numbers.
         Since the assembler may not be running on
         a little-endian machine, be very careful about
         converting words to chars.  */
      number_of_chars = atof_vax_sizeof (kind_of_float);
      know (number_of_chars <= MAXIMUM_NUMBER_OF_LITTLENUMS * sizeof (LITTLENUM_TYPE));
      limit = words + (number_of_chars / sizeof (LITTLENUM_TYPE));
      for (littlenumP = words; littlenumP < limit; littlenumP++)
	{
	  md_number_to_chars (literalP, *littlenumP, sizeof (LITTLENUM_TYPE));
	  literalP += sizeof (LITTLENUM_TYPE);
	};
    }
  else
    number_of_chars = 0;

  *sizeP = number_of_chars;
  return kind_of_float ? NULL : _("Unrecognized or unsupported floating point constant");
}
@


1.12
log
@Remove duplicate definitions of the md_atof() function
@
text
@d298 1
a298 1
	       exponent_skippage++);;
@


1.11
log
@Switch to GPLv3
@
text
@d392 3
a394 3
md_atof (int what_statement_type,
	 char *literalP,
	 int *sizeP)
d450 1
a450 1
  return kind_of_float ? NULL : _("Bad call to md_atof()");
@


1.10
log
@	* config/atof-vax.c (atof_vax_sizeof): Change return type to unsigned.
	(md_atof): Make number_of_chars unsigned.  Revert last change.
	* config/tc-or32.c (md_apply_fix): Delete bogus assertions.
	* config/tc-sh.c (sh_optimize_expr): Only define for OBJ_ELF.
	* config/tc-sh.h (md_optimize_expr): Likewise.
	* config/tc-sh64.c (shmedia_md_pcrel_from_section): Delete bogus
	assertion.
	* config/tc-xtensa.c (convert_frag_immed_finish_loop): Likewise.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.9
log
@* config/atof-vax.c (md_atof): Fix comparison inside know().
@
text
@d2 1
a2 1
   Copyright 1987, 1992, 1993, 1995, 1997, 1999, 2000, 2005
d38 1
a38 1
static int
d398 1
a398 1
  int number_of_chars;
d438 1
a438 1
      know (number_of_chars <= (int)(MAXIMUM_NUMBER_OF_LITTLENUMS * sizeof (LITTLENUM_TYPE)));
@


1.8
log
@Update the address and phone number of the FSF
@
text
@d438 1
a438 1
      know (number_of_chars <= MAXIMUM_NUMBER_OF_LITTLENUMS * sizeof (LITTLENUM_TYPE));
@


1.7
log
@Support the .f_floating, .d_floating, .g_floating and .h_floating directives
for the VAX target in order to be more compatible with the VAX MACRO assembler.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.6
log
@Convert to ISO C90 formatting
@
text
@d32 1
a32 1
#define GUARD 		2
@


1.5
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1987, 1992, 1993, 1995, 1997, 1999, 2000
a23 6
static int atof_vax_sizeof PARAMS ((int));
static int next_bits PARAMS ((int));
static void make_invalid_floating_point_number PARAMS ((LITTLENUM_TYPE *));
static int what_kind_of_float PARAMS ((int, int *, long *));
static char *atof_vax PARAMS ((char *, int, LITTLENUM_TYPE *));

d25 5
a29 5
#define MAX_PRECISION (8)
#define H_PRECISION (8)
#define G_PRECISION (4)
#define D_PRECISION (4)
#define F_PRECISION (2)
d32 1
a32 1
#define GUARD (2)
d34 1
a34 2
int flonum_gen2vax PARAMS ((int format_letter, FLONUM_TYPE * f,
			    LITTLENUM_TYPE * words));
d37 1
d39 1
a39 2
atof_vax_sizeof (letter)
     int letter;
d43 3
a45 5
  /*
   * Permitting uppercase letters is probably a bad idea.
   * Please use only lower-cased letters in case the upper-cased
   * ones become unsupported!
   */
d69 3
a71 2
  return (return_value);
}				/* atof_vax_sizeof */
d111 1
a111 1
/* Shared between flonum_gen2vax and next_bits */
d117 1
a117 2
next_bits (number_of_bits)
     int number_of_bits;
d138 1
a138 1
  return (return_value);
d142 1
a142 2
make_invalid_floating_point_number (words)
     LITTLENUM_TYPE *words;
d144 1
a144 1
  *words = 0x8000;		/* Floating Reserved Operand Code */
d146 1
d149 3
a151 4
what_kind_of_float (letter, precisionP, exponent_bitsP)
     int letter;		/* In: lowercase please. What kind of float? */
     int *precisionP;		/* Number of 16-bit words in the float.  */
     long *exponent_bitsP;	/* Number of exponent bits.  */
d153 1
a153 1
  int retval;			/* 0: OK.  */
d182 1
a182 1
  return (retval);
d185 9
a193 14
/***********************************************************************\
 *									*
 *	Warning: this returns 16-bit LITTLENUMs, because that is	*
 *	what the VAX thinks in. It is up to the caller to figure	*
 *	out any alignment problems and to conspire for the bytes/word	*
 *	to be emitted in the right order. Bigendians beware!		*
 *									*
 \***********************************************************************/

static char *				/* Return pointer past text consumed.  */
atof_vax (str, what_kind, words)
     char *str;			/* Text to convert to binary.  */
     int what_kind;		/* 'd', 'f', 'g', 'h' */
     LITTLENUM_TYPE *words;	/* Build the binary here.  */
d197 3
a199 3
  /* Extra bits for zeroed low-order bits.  */
  /* The 1st MAX_PRECISION are zeroed, */
  /* the last contain flonum bits.  */
d213 1
a213 1
      return_value = NULL;	/* We lost.  */
d221 3
a223 3
      /* Use more LittleNums than seems */
      /* necessary: the highest flonum may have */
      /* 15 leading 0 bits, so could be useless.  */
d229 1
a229 8
	  return_value = NULL;	/* we lost */
	}
      else
	{
	  if (flonum_gen2vax (what_kind, &f, words))
	    {
	      return_value = NULL;
	    }
d231 2
d234 3
a236 2
  return (return_value);
}				/* atof_vax() */
d238 7
a244 10
/*
 * In: a flonum, a vax floating point format.
 * Out: a vax floating-point bit pattern.
 */

int				/* 0: OK.  */
flonum_gen2vax (format_letter, f, words)
     int format_letter;		/* One of 'd' 'f' 'g' 'h'.  */
     FLONUM_TYPE *f;
     LITTLENUM_TYPE *words;	/* Deliver answer here.  */
d254 2
a255 3
    {
      make_invalid_floating_point_number (words);
    }
d259 3
a261 4
	{
	  /* 0.0e0 seen.  */
	  memset (words, '\0', sizeof (LITTLENUM_TYPE) * precision);
	}
d271 1
a271 1
	  /* JF: Deal with new Nan, +Inf and -Inf codes */
d277 14
a290 32
	  /*
			 * All vaxen floating_point formats (so far) have:
			 * Bit 15 is sign bit.
			 * Bits 14:n are excess-whatever exponent.
			 * Bits n-1:0 (if any) are most significant bits of fraction.
			 * Bits 15:0 of the next word are the next most significant bits.
			 * And so on for each other word.
			 *
			 * All this to be compatible with a KF11?? (Which is still faster
			 * than lots of vaxen I can think of, but it also has higher
			 * maintenance costs ... sigh).
			 *
			 * So we need: number of bits of exponent, number of bits of
			 * mantissa.
			 */

#ifdef NEVER			/******* This zeroing seems redundant - Dean 3may86 **********/
	  /*
			 * No matter how few bits we got back from the atof()
			 * routine, add enough zero littlenums so the rest of the
			 * code won't run out of "significant" bits in the mantissa.
			 */
	  {
	    LITTLENUM_TYPE *ltp;
	    for (ltp = f->leader + 1;
		 ltp <= f->low + precision;
		 ltp++)
	      {
		*ltp = 0;
	      }
	  }
#endif
d295 1
a295 1
	  /* Seek (and forget) 1st significant bit */
d311 1
a311 4
	      /*
				 * Exponent overflow. Lose immediately.
				 */

d314 3
a316 5
	      /*
				 * We leave return_value alone: admit we read the
				 * number, but return a floating exception
				 * because we can't encode the number.
				 */
d322 2
a323 2
	      /* Word 1. Sign, exponent and perhaps high bits.  */
	      /* Assume 2's complement integers.  */
d331 1
a331 3
		{
		  *lp = next_bits (LITTLENUM_NUMBER_OF_BITS);
		}
d335 6
a340 9
		  /*
					 * Since the NEXT bit is a 1, round UP the mantissa.
					 * The cunning design of these hidden-1 floats permits
					 * us to let the mantissa overflow into the exponent, and
					 * it 'does the right thing'. However, we lose if the
					 * highest-order bit of the lowest-order word flips.
					 * Is that clear?
					 */

d344 7
a350 8
					  #if (sizeof(carry)) < ((sizeof(bits[0]) * BITS_PER_CHAR) + 2)
					  Please allow at least 1 more bit in carry than is in a LITTLENUM.
					  We need that extra bit to hold a carry during a LITTLENUM carry
					  propagation. Another extra bit (kept 0) will assure us that we
					  don't get a sticky sign bit after shifting right, and that
					  permits us to propagate the carry without any masking of bits.
					  #endif
					  */
d363 3
a365 5
		      /*
						 * We leave return_value alone: admit we read the
						 * number, but return a floating exception
						 * because we can't encode the number.
						 */
d367 8
a374 25
		}		/* if (we needed to round up) */
	    }			/* if (exponent overflow) */
	}			/* if (0.0e0) */
    }				/* if (float_type was OK) */
  return (return_value);
}				/* flonum_gen2vax() */

/* JF this used to be in vax.c but this looks like a better place for it */

/*
 *		md_atof()
 *
 * In:	input_line_pointer->the 1st character of a floating-point
 *		number.
 *	1 letter denoting the type of statement that wants a
 *		binary floating point number returned.
 *	Address of where to build floating point literal.
 *		Assumed to be 'big enough'.
 *	Address of where to return size of literal (in chars).
 *
 * Out:	Input_line_pointer->of next char after floating number.
 *	Error message, or 0.
 *	Floating point literal.
 *	Number of chars we used for the literal.
 */
d376 14
a389 1
#define MAXIMUM_NUMBER_OF_LITTLENUMS (8)	/* For .hfloats.  */
d392 3
a394 4
md_atof (what_statement_type, literalP, sizeP)
     int what_statement_type;
     char *literalP;
     int *sizeP;
d397 3
a399 3
  register char kind_of_float;
  register int number_of_chars;
  register LITTLENUM_TYPE *littlenumP;
d403 2
a404 2
    case 'F':			/* .float */
    case 'f':			/* .ffloat */
d408 2
a409 2
    case 'D':			/* .double */
    case 'd':			/* .dfloat */
d413 1
a413 1
    case 'g':			/* .gfloat */
d417 1
a417 1
    case 'h':			/* .hfloat */
d428 1
a428 1
      register LITTLENUM_TYPE *limit;
d433 4
a436 6
      /*
       * The atof_vax() builds up 16-bit numbers.
       * Since the assembler may not be running on
       * a little-endian machine, be very careful about
       * converting words to chars.
       */
d447 1
a447 3
    {
      number_of_chars = 0;
    };
a451 2

/* end of atof-vax.c */
@


1.4
log
@2000-11-14  Kazu Hirata  <kazu@@hxi.com>

	* config/aout_gnu.h: Fix formatting.
	* config/atof-vax.c: Likewise.
	* config/m68k-parse.h: Likewise.
	* config/m88k-opcode.h: Likewise.
	* config/obj-elf.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/te-386bsd.h: Likewise.
	* config/te-hppa.h: Likewise.
	* config/te-nbsd.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-sparcaout.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/vax-inst.h: Likewise.
	* config/vms-conf.h: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1992, 93, 95, 97, 98, 1999
@


1.4.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1987, 1992, 1993, 1995, 1997, 1999, 2000
@


1.3
log
@fix copyright
@
text
@d30 1
a30 1
/* Precision in LittleNums. */
d37 1
a37 1
/* Length in LittleNums of guard bits. */
d43 1
a43 1
/* Number of chars in flonum type 'letter'. */
d157 1
a157 1
static int			/* 0 means letter is OK. */
d160 2
a161 2
     int *precisionP;		/* Number of 16-bit words in the float. */
     long *exponent_bitsP;	/* Number of exponent bits. */
d163 1
a163 1
  int retval;			/* 0: OK. */
d204 1
a204 1
static char *				/* Return pointer past text consumed. */
d206 1
a206 1
     char *str;			/* Text to convert to binary. */
d208 1
a208 1
     LITTLENUM_TYPE *words;	/* Build the binary here. */
d212 1
a212 1
  /* Extra bits for zeroed low-order bits. */
d214 1
a214 1
  /* the last contain flonum bits. */
d216 1
a216 1
  int precision;		/* Number of 16-bit words in the format. */
d228 1
a228 1
      return_value = NULL;	/* We lost. */
d238 1
a238 1
      /* 15 leading 0 bits, so could be useless. */
d262 1
a262 1
int				/* 0: OK. */
d264 1
a264 1
     int format_letter;		/* One of 'd' 'f' 'g' 'h'. */
d266 1
a266 1
     LITTLENUM_TYPE *words;	/* Deliver answer here. */
d271 1
a271 1
  int return_value;		/* 0 == OK. */
d283 1
a283 1
	  /* 0.0e0 seen. */
d343 1
a343 1
	  /* Radix LITTLENUM_RADIX, point just higher than f->leader. */
d345 1
a345 1
	  /* Radix 2. */
d347 1
a347 1
	  /* Forget leading zeros, forget 1st bit. */
d349 1
a349 1
	  /* Offset exponent. */
d369 2
a370 2
	      /* Word 1. Sign, exponent and perhaps high bits. */
	      /* Assume 2's complement integers. */
d376 1
a376 1
	      /* The rest of the words are just mantissa bits. */
a428 1

d448 1
a448 1
#define MAXIMUM_NUMBER_OF_LITTLENUMS (8)	/* For .hfloats. */
@


1.2
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/atof-ieee.c (atof_ieee): Change what_kind to int.
	* config/atof-vax.c (flonum_gen2vax): Change format_letter to
	int.
	(md_atof): Return NULL rather than 0.
	* config/tc-i386.c (md_atof): Change type to int.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 1992, 93, 95, 1997, 1998 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d263 1
a263 1
     char format_letter;	/* One of 'd' 'f' 'g' 'h'. */
d514 1
a514 1
  return kind_of_float ? 0 : _("Bad call to md_atof()");
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

