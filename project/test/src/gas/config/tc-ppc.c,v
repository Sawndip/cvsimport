head	1.206;
access;
symbols
	binutils-2_24-branch:1.206.0.2
	binutils-2_24-branchpoint:1.206
	binutils-2_21_1:1.175.2.1
	binutils-2_23_2:1.184.2.1
	binutils-2_23_1:1.184
	binutils-2_23:1.184
	binutils-2_23-branch:1.184.0.2
	binutils-2_23-branchpoint:1.184
	binutils-2_22_branch:1.180.0.4
	binutils-2_22:1.180
	binutils-2_22-branch:1.180.0.2
	binutils-2_22-branchpoint:1.180
	binutils-2_21:1.175
	binutils-2_21-branch:1.175.0.2
	binutils-2_21-branchpoint:1.175
	binutils-2_20_1:1.154.4.6
	binutils-2_20:1.154.4.4
	binutils-arc-20081103-branch:1.142.0.4
	binutils-arc-20081103-branchpoint:1.142
	binutils-2_20-branch:1.154.0.4
	binutils-2_20-branchpoint:1.154
	dje-cgen-play1-branch:1.154.0.2
	dje-cgen-play1-branchpoint:1.154
	arc-20081103-branch:1.142.0.2
	arc-20081103-branchpoint:1.142
	binutils-2_19_1:1.141
	binutils-2_19:1.141
	binutils-2_19-branch:1.141.0.2
	binutils-2_19-branchpoint:1.141
	binutils-2_18:1.125
	binutils-2_18-branch:1.125.0.2
	binutils-2_18-branchpoint:1.125
	binutils-csl-coldfire-4_1-32:1.109
	binutils-csl-sourcerygxx-4_1-32:1.109
	binutils-csl-innovasic-fido-3_4_4-33:1.109
	binutils-csl-sourcerygxx-3_4_4-32:1.95
	binutils-csl-coldfire-4_1-30:1.109
	binutils-csl-sourcerygxx-4_1-30:1.109
	binutils-csl-coldfire-4_1-28:1.109
	binutils-csl-sourcerygxx-4_1-29:1.109
	binutils-csl-sourcerygxx-4_1-28:1.109
	binutils-csl-arm-2006q3-27:1.109
	binutils-csl-sourcerygxx-4_1-27:1.109
	binutils-csl-arm-2006q3-26:1.109
	binutils-csl-sourcerygxx-4_1-26:1.109
	binutils-csl-sourcerygxx-4_1-25:1.109
	binutils-csl-sourcerygxx-4_1-24:1.109
	binutils-csl-sourcerygxx-4_1-23:1.109
	binutils-csl-sourcerygxx-4_1-21:1.109
	binutils-csl-arm-2006q3-21:1.109
	binutils-csl-sourcerygxx-4_1-22:1.109
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.109
	binutils-csl-sourcerygxx-4_1-20:1.109
	binutils-csl-arm-2006q3-19:1.109
	binutils-csl-sourcerygxx-4_1-19:1.109
	binutils-csl-sourcerygxx-4_1-18:1.109
	binutils-csl-renesas-4_1-9:1.109
	binutils-csl-sourcerygxx-3_4_4-25:1.95
	binutils-csl-renesas-4_1-8:1.109
	binutils-csl-renesas-4_1-7:1.109
	binutils-csl-renesas-4_1-6:1.109
	binutils-csl-sourcerygxx-4_1-17:1.109
	binutils-csl-sourcerygxx-4_1-14:1.109
	binutils-csl-sourcerygxx-4_1-15:1.109
	binutils-csl-sourcerygxx-4_1-13:1.109
	binutils-2_17:1.109
	binutils-csl-sourcerygxx-4_1-12:1.109
	binutils-csl-sourcerygxx-3_4_4-21:1.109
	binutils-csl-wrs-linux-3_4_4-24:1.95
	binutils-csl-wrs-linux-3_4_4-23:1.95
	binutils-csl-sourcerygxx-4_1-9:1.109
	binutils-csl-sourcerygxx-4_1-8:1.109
	binutils-csl-sourcerygxx-4_1-7:1.109
	binutils-csl-arm-2006q1-6:1.109
	binutils-csl-sourcerygxx-4_1-6:1.109
	binutils-csl-wrs-linux-3_4_4-22:1.95
	binutils-csl-coldfire-4_1-11:1.109
	binutils-csl-sourcerygxx-3_4_4-19:1.109
	binutils-csl-coldfire-4_1-10:1.109
	binutils-csl-sourcerygxx-4_1-5:1.109
	binutils-csl-sourcerygxx-4_1-4:1.109
	binutils-csl-wrs-linux-3_4_4-21:1.95
	binutils-csl-morpho-4_1-4:1.109
	binutils-csl-sourcerygxx-3_4_4-17:1.109
	binutils-csl-wrs-linux-3_4_4-20:1.95
	binutils-2_17-branch:1.109.0.4
	binutils-2_17-branchpoint:1.109
	binutils-csl-2_17-branch:1.109.0.2
	binutils-csl-2_17-branchpoint:1.109
	binutils-csl-gxxpro-3_4-branch:1.95.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.95
	binutils-2_16_1:1.95
	binutils-csl-arm-2005q1b:1.95
	binutils-2_16:1.95
	binutils-csl-arm-2005q1a:1.95
	binutils-csl-arm-2005q1-branch:1.95.0.4
	binutils-csl-arm-2005q1-branchpoint:1.95
	binutils-2_16-branch:1.95.0.2
	binutils-2_16-branchpoint:1.95
	csl-arm-2004-q3d:1.93
	csl-arm-2004-q3:1.92
	binutils-2_15:1.86.6.1
	binutils-2_15-branchpoint:1.86
	csl-arm-2004-q1a:1.87
	csl-arm-2004-q1:1.87
	binutils-2_15-branch:1.86.0.6
	cagney_bfdfile-20040213-branch:1.86.0.4
	cagney_bfdfile-20040213-branchpoint:1.86
	cagney_bigcore-20040122-branch:1.86.0.2
	cagney_bigcore-20040122-branchpoint:1.86
	csl-arm-2003-q4:1.86
	binutils-2_14:1.68.2.1
	binutils-2_14-branch:1.68.0.2
	binutils-2_14-branchpoint:1.68
	binutils-2_13_2_1:1.51.2.3
	binutils-2_13_2:1.51.2.3
	binutils-2_13_1:1.51.2.2
	binutils-2_13:1.51.2.1
	binutils-2_13-branchpoint:1.51
	binutils-2_13-branch:1.51.0.2
	binutils-2_12_1:1.42.2.3
	binutils-2_12:1.42.2.2
	binutils-2_12-branch:1.42.0.2
	binutils-2_12-branchpoint:1.42
	cygnus_cvs_20020108_pre:1.42
	binutils-2_11_2:1.18.2.2
	binutils-2_11_1:1.18.2.2
	binutils-2_11:1.18
	x86_64versiong3:1.18
	binutils-2_11-branch:1.18.0.2
	binutils-2_10_1:1.9
	binutils-2_10:1.9
	binutils-2_10-branch:1.9.0.2
	binutils-2_10-branchpoint:1.9
	binutils_latest_snapshot:1.206
	repo-unification-2000-02-06:1.8
	binu_ss_19990721:1.6
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.206
date	2013.09.04.12.28.11;	author gingold;	state Exp;
branches;
next	1.205;

1.205
date	2013.08.16.12.59.32;	author amodra;	state Exp;
branches;
next	1.204;

1.204
date	2013.08.16.12.34.46;	author amodra;	state Exp;
branches;
next	1.203;

1.203
date	2013.08.14.20.52.55;	author dje;	state Exp;
branches;
next	1.202;

1.202
date	2013.07.24.14.12.41;	author gingold;	state Exp;
branches;
next	1.201;

1.201
date	2013.07.02.00.25.08;	author amodra;	state Exp;
branches;
next	1.200;

1.200
date	2013.05.21.01.36.45;	author bergner;	state Exp;
branches;
next	1.199;

1.199
date	2013.05.20.10.16.31;	author amodra;	state Exp;
branches;
next	1.198;

1.198
date	2013.05.16.15.41.40;	author gingold;	state Exp;
branches;
next	1.197;

1.197
date	2013.05.09.04.01.53;	author amodra;	state Exp;
branches;
next	1.196;

1.196
date	2013.05.06.23.36.48;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2013.01.25.02.02.21;	author jsm28;	state Exp;
branches;
next	1.194;

1.194
date	2013.01.16.06.12.46;	author amodra;	state Exp;
branches;
next	1.193;

1.193
date	2013.01.11.02.25.32;	author bergner;	state Exp;
branches;
next	1.192;

1.192
date	2012.11.23.03.28.12;	author amodra;	state Exp;
branches;
next	1.191;

1.191
date	2012.11.14.13.44.44;	author uweigand;	state Exp;
branches;
next	1.190;

1.190
date	2012.11.06.05.18.03;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2012.11.06.03.20.31;	author amodra;	state Exp;
branches;
next	1.188;

1.188
date	2012.11.05.10.00.12;	author amodra;	state Exp;
branches;
next	1.187;

1.187
date	2012.10.29.10.09.29;	author amodra;	state Exp;
branches;
next	1.186;

1.186
date	2012.10.26.03.40.37;	author amodra;	state Exp;
branches;
next	1.185;

1.185
date	2012.08.01.13.46.56;	author jwlemke;	state Exp;
branches;
next	1.184;

1.184
date	2012.05.18.05.42.24;	author amodra;	state Exp;
branches
	1.184.2.1;
next	1.183;

1.183
date	2012.05.14.19.45.23;	author jwlemke;	state Exp;
branches;
next	1.182;

1.182
date	2012.03.09.23.39.04;	author amodra;	state Exp;
branches;
next	1.181;

1.181
date	2011.11.21.13.19.33;	author amodra;	state Exp;
branches;
next	1.180;

1.180
date	2011.06.14.09.03.51;	author gingold;	state Exp;
branches;
next	1.179;

1.179
date	2011.06.02.13.43.20;	author nickc;	state Exp;
branches;
next	1.178;

1.178
date	2011.05.18.07.58.35;	author gingold;	state Exp;
branches;
next	1.177;

1.177
date	2011.03.30.12.43.35;	author gingold;	state Exp;
branches;
next	1.176;

1.176
date	2011.02.10.11.59.11;	author amodra;	state Exp;
branches;
next	1.175;

1.175
date	2010.11.04.03.30.05;	author amodra;	state Exp;
branches
	1.175.2.1;
next	1.174;

1.174
date	2010.07.29.07.48.43;	author amodra;	state Exp;
branches;
next	1.173;

1.173
date	2010.07.28.05.21.38;	author amodra;	state Exp;
branches;
next	1.172;

1.172
date	2010.07.20.05.07.23;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2010.07.03.08.27.23;	author schwab;	state Exp;
branches;
next	1.170;

1.170
date	2010.07.03.06.51.56;	author amodra;	state Exp;
branches;
next	1.169;

1.169
date	2010.07.01.04.50.21;	author amodra;	state Exp;
branches;
next	1.168;

1.168
date	2010.06.14.14.48.03;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2010.05.25.00.51.49;	author amodra;	state Exp;
branches;
next	1.166;

1.166
date	2010.05.18.03.31.04;	author hjl;	state Exp;
branches;
next	1.165;

1.165
date	2010.04.10.14.12.56;	author amodra;	state Exp;
branches;
next	1.164;

1.164
date	2010.02.10.19.59.07;	author rsandifo;	state Exp;
branches;
next	1.163;

1.163
date	2010.02.08.01.59.37;	author amodra;	state Exp;
branches;
next	1.162;

1.162
date	2010.01.23.12.05.32;	author rsandifo;	state Exp;
branches;
next	1.161;

1.161
date	2010.01.04.02.32.56;	author amodra;	state Exp;
branches;
next	1.160;

1.160
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.159;

1.159
date	2009.11.18.12.42.52;	author amodra;	state Exp;
branches;
next	1.158;

1.158
date	2009.10.02.14.42.41;	author bergner;	state Exp;
branches;
next	1.157;

1.157
date	2009.10.01.19.24.47;	author bergner;	state Exp;
branches;
next	1.156;

1.156
date	2009.09.21.10.29.06;	author bje;	state Exp;
branches;
next	1.155;

1.155
date	2009.09.05.07.56.24;	author nickc;	state Exp;
branches;
next	1.154;

1.154
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches
	1.154.4.1;
next	1.153;

1.153
date	2009.04.01.01.41.06;	author bergner;	state Exp;
branches;
next	1.152;

1.152
date	2009.03.14.09.34.27;	author rsandifo;	state Exp;
branches;
next	1.151;

1.151
date	2009.03.14.09.16.31;	author rsandifo;	state Exp;
branches;
next	1.150;

1.150
date	2009.03.10.06.53.46;	author amodra;	state Exp;
branches;
next	1.149;

1.149
date	2009.03.04.05.50.49;	author amodra;	state Exp;
branches;
next	1.148;

1.148
date	2009.03.03.23.15.04;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2009.02.26.22.07.32;	author bergner;	state Exp;
branches;
next	1.146;

1.146
date	2009.02.10.08.07.31;	author nathan;	state Exp;
branches;
next	1.145;

1.145
date	2009.01.15.12.42.52;	author nickc;	state Exp;
branches;
next	1.144;

1.144
date	2009.01.09.18.50.57;	author bergner;	state Exp;
branches;
next	1.143;

1.143
date	2008.12.04.10.29.15;	author bje;	state Exp;
branches;
next	1.142;

1.142
date	2008.09.09.13.25.05;	author bergner;	state Exp;
branches;
next	1.141;

1.141
date	2008.08.02.04.38.50;	author bergner;	state Exp;
branches
	1.141.2.1;
next	1.140;

1.140
date	2008.08.01.02.44.11;	author bergner;	state Exp;
branches;
next	1.139;

1.139
date	2008.07.30.06.29.22;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2008.06.25.16.49.02;	author bergner;	state Exp;
branches;
next	1.137;

1.137
date	2008.06.13.20.16.00;	author bergner;	state Exp;
branches;
next	1.136;

1.136
date	2008.04.14.11.01.38;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2008.03.06.23.01.00;	author amodra;	state Exp;
branches;
next	1.134;

1.134
date	2008.03.01.07.24.47;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2008.01.04.14.53.50;	author nickc;	state Exp;
branches;
next	1.132;

1.132
date	2007.12.03.23.14.24;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2007.11.12.00.27.53;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2007.11.07.14.10.48;	author gingold;	state Exp;
branches;
next	1.129;

1.129
date	2007.10.19.10.48.17;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2007.10.16.02.26.30;	author bergner;	state Exp;
branches;
next	1.126;

1.126
date	2007.08.24.00.56.29;	author bje;	state Exp;
branches;
next	1.125;

1.125
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.124;

1.124
date	2007.07.02.02.11.56;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2007.05.29.01.57.08;	author amodra;	state Exp;
branches;
next	1.122;

1.122
date	2007.05.26.14.49.39;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2007.05.02.11.24.16;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2007.04.30.00.27.57;	author amodra;	state Exp;
branches;
next	1.119;

1.119
date	2007.04.21.06.54.56;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2007.04.21.05.15.41;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2007.04.20.13.42.03;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2007.04.20.12.25.15;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2006.10.24.01.27.28;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2006.09.22.13.54.06;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2006.09.22.11.05.27;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2006.06.07.05.23.59;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2006.05.19.11.26.11;	author ths;	state Exp;
branches;
next	1.109;

1.109
date	2005.11.17.13.32.27;	author aoliva;	state Exp;
branches;
next	1.108;

1.108
date	2005.11.16.01.49.48;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2005.09.20.18.24.47;	author rth;	state Exp;
branches;
next	1.106;

1.106
date	2005.08.23.06.18.45;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2005.08.16.03.17.53;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2005.08.15.15.37.14;	author drow;	state Exp;
branches;
next	1.103;

1.103
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2005.08.02.03.28.43;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2005.07.05.13.25.52;	author pbrook;	state Exp;
branches;
next	1.100;

1.100
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.99;

1.99
date	2005.05.19.08.27.34;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2005.05.19.07.02.14;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2005.05.11.14.10.37;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2005.05.05.09.13.02;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2005.03.02.13.24.01;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2005.02.23.12.28.05;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2004.10.02.00.18.31;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2004.08.16.03.04.47;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2004.07.27.13.56.55;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2004.07.27.11.37.08;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2004.07.02.06.40.19;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2004.05.06.11.01.48;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.07.04.50.15;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.20.08.01.47;	author nickc;	state Exp;
branches
	1.86.6.1;
next	1.85;

1.85
date	2003.12.10.22.12.50;	author zack;	state Exp;
branches;
next	1.84;

1.84
date	2003.11.22.02.35.31;	author kazu;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.21.15.05.15;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2003.09.04.01.52.18;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2003.08.19.15.48.53;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2003.08.19.07.09.44;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2003.07.29.06.48.30;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2003.07.10.16.46.38;	author jakub;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.25.06.40.25;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.24.06.41.56;	author mmitchel;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.18.23.05.44;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2003.06.18.03.27.18;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.17.00.14.24;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.10.07.44.11;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2003.05.03.16.04.11;	author hjl;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.02.02.29.22;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2003.04.24.10.22.34;	author nickc;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2003.04.08.23.01.47;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2003.02.06.01.24.17;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2003.02.04.14.51.13;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2002.12.03.18.24.32;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2002.10.12.10.23.17;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2002.09.13.09.16.02;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2002.09.04.13.43.43;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2002.09.04.13.21.18;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2002.09.04.12.37.30;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2002.08.21.23.37.34;	author ezannoni;	state Exp;
branches;
next	1.54;

1.54
date	2002.08.19.21.08.55;	author ezannoni;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.06.02.30.06;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.26.04.18.42;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.11.01.07.49;	author amodra;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2002.07.11.01.06.58;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.12.16.14.02;	author trix;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.23.13.12.48;	author jakub;	state Exp;
branches;
next	1.47;

1.47
date	2002.05.11.09.53.50;	author kazu;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.02.12.41.35;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2002.03.18.12.46.11;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.25.03.44.56;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.12.03.59.33;	author trix;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.03.02.07.17;	author mrg;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2001.12.20.07.34.44;	author mrg;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.15.21.28.58;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.15.01.08.51;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.17.13.13.15;	author mrg;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.17.06.03.41;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.13.01.59.08;	author mrg;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.08.18.14.43;	author trix;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.04.05.03.44;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.02.09.28.53;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.19.05.33.29;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.11.16.46.38;	author jakub;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.27.10.42.16;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.10.01.34.47;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.08.13.23.07;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.31.19.24.57;	author geoffk;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.30.06.15.49;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.02.10.54.49;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.20.13.34.08;	author trix;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.29.14.53.22;	author trix;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.24.21.39.09;	author trix;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.22.10.23.49;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.30.07.07.11;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2000.12.12.20.05.16;	author geoffk;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.26.07.09.18;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.31.06.48.48;	author geoffk;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.19.00.59.43;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.03.22.23.01;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.26.15.09.43;	author cpopetz;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.02.06.27.51;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.31.19.13.47;	author geoffk;	state Exp;
branches;
next	1.7;

1.7
date	99.08.17.18.26.49;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.22.14.17.54;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.19.14.04.45;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.05.23.15.33;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.39;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.08.23.31.09;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.184.2.1
date	2013.01.21.13.48.44;	author amodra;	state Exp;
branches;
next	;

1.175.2.1
date	2011.03.19.00.27.26;	author amodra;	state Exp;
branches;
next	;

1.154.4.1
date	2009.09.05.08.00.20;	author nickc;	state Exp;
branches;
next	1.154.4.2;

1.154.4.2
date	2009.09.21.10.29.08;	author bje;	state Exp;
branches;
next	1.154.4.3;

1.154.4.3
date	2009.10.01.19.49.38;	author bergner;	state Exp;
branches;
next	1.154.4.4;

1.154.4.4
date	2009.10.02.14.51.22;	author bergner;	state Exp;
branches;
next	1.154.4.5;

1.154.4.5
date	2010.01.30.09.58.02;	author rsandifo;	state Exp;
branches;
next	1.154.4.6;

1.154.4.6
date	2010.02.10.20.00.41;	author rsandifo;	state Exp;
branches;
next	;

1.141.2.1
date	2009.03.02.13.28.15;	author amodra;	state Exp;
branches;
next	1.141.2.2;

1.141.2.2
date	2009.03.02.13.43.13;	author amodra;	state Exp;
branches;
next	1.141.2.3;

1.141.2.3
date	2009.03.02.13.47.14;	author amodra;	state Exp;
branches;
next	1.141.2.4;

1.141.2.4
date	2009.03.02.13.59.36;	author amodra;	state Exp;
branches;
next	1.141.2.5;

1.141.2.5
date	2009.03.03.23.16.02;	author amodra;	state Exp;
branches;
next	;

1.86.6.1
date	2004.04.09.18.28.12;	author drow;	state Exp;
branches;
next	;

1.68.2.1
date	2003.04.30.08.45.54;	author amodra;	state Exp;
branches;
next	;

1.51.2.1
date	2002.07.26.04.23.02;	author amodra;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2002.09.23.22.14.23;	author drow;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2002.11.13.03.01.24;	author amodra;	state Exp;
branches;
next	;

1.42.2.1
date	2002.02.12.05.32.59;	author trix;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2002.02.25.05.05.30;	author amodra;	state Exp;
branches;
next	1.42.2.3;

1.42.2.3
date	2002.05.09.11.54.11;	author amodra;	state Exp;
branches;
next	;

1.18.2.1
date	2001.06.07.03.15.32;	author amodra;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2001.06.11.10.04.50;	author amodra;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2001.06.20.14.45.51;	author trix;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;


desc
@@


1.206
log
@gas/
	* config/tc-ppc.c (md_apply_fix): Handle defined after use toc
	symbols.

gas/testsuite/
	* gas/ppc/aix.exp: Run xcoff-toc-1 test.
	* gas/ppc/xcoff-toc-1.s, gas/ppc/xcoff-toc-1.d: New test.
@
text
@/* tc-ppc.c -- Assemble for the PowerPC or POWER (RS/6000)
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "dw2gencfi.h"
#include "opcode/ppc.h"

#ifdef OBJ_ELF
#include "elf/ppc.h"
#include "dwarf2dbg.h"
#endif

#ifdef TE_PE
#include "coff/pe.h"
#endif

#ifdef OBJ_XCOFF
#include "coff/xcoff.h"
#include "libxcoff.h"
#endif

/* This is the assembler for the PowerPC or POWER (RS/6000) chips.  */

/* Tell the main code what the endianness is.  */
extern int target_big_endian;

/* Whether or not, we've set target_big_endian.  */
static int set_target_endian = 0;

/* Whether to use user friendly register names.  */
#ifndef TARGET_REG_NAMES_P
#ifdef TE_PE
#define TARGET_REG_NAMES_P TRUE
#else
#define TARGET_REG_NAMES_P FALSE
#endif
#endif

/* Macros for calculating LO, HI, HA, HIGHER, HIGHERA, HIGHEST,
   HIGHESTA.  */

/* #lo(value) denotes the least significant 16 bits of the indicated.  */
#define PPC_LO(v) ((v) & 0xffff)

/* #hi(value) denotes bits 16 through 31 of the indicated value.  */
#define PPC_HI(v) (((v) >> 16) & 0xffff)

/* #ha(value) denotes the high adjusted value: bits 16 through 31 of
  the indicated value, compensating for #lo() being treated as a
  signed number.  */
#define PPC_HA(v) PPC_HI ((v) + 0x8000)

/* #higher(value) denotes bits 32 through 47 of the indicated value.  */
#define PPC_HIGHER(v) (((v) >> 16 >> 16) & 0xffff)

/* #highera(value) denotes bits 32 through 47 of the indicated value,
   compensating for #lo() being treated as a signed number.  */
#define PPC_HIGHERA(v) PPC_HIGHER ((v) + 0x8000)

/* #highest(value) denotes bits 48 through 63 of the indicated value.  */
#define PPC_HIGHEST(v) (((v) >> 24 >> 24) & 0xffff)

/* #highesta(value) denotes bits 48 through 63 of the indicated value,
   compensating for #lo being treated as a signed number.  */
#define PPC_HIGHESTA(v) PPC_HIGHEST ((v) + 0x8000)

#define SEX16(val) ((((val) & 0xffff) ^ 0x8000) - 0x8000)

static bfd_boolean reg_names_p = TARGET_REG_NAMES_P;

static void ppc_macro (char *, const struct powerpc_macro *);
static void ppc_byte (int);

#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
static void ppc_tc (int);
static void ppc_machine (int);
#endif

#ifdef OBJ_XCOFF
static void ppc_comm (int);
static void ppc_bb (int);
static void ppc_bc (int);
static void ppc_bf (int);
static void ppc_biei (int);
static void ppc_bs (int);
static void ppc_eb (int);
static void ppc_ec (int);
static void ppc_ef (int);
static void ppc_es (int);
static void ppc_csect (int);
static void ppc_dwsect (int);
static void ppc_change_csect (symbolS *, offsetT);
static void ppc_function (int);
static void ppc_extern (int);
static void ppc_lglobl (int);
static void ppc_ref (int);
static void ppc_section (int);
static void ppc_named_section (int);
static void ppc_stabx (int);
static void ppc_rename (int);
static void ppc_toc (int);
static void ppc_xcoff_cons (int);
static void ppc_vbyte (int);
#endif

#ifdef OBJ_ELF
static void ppc_elf_cons (int);
static void ppc_elf_rdata (int);
static void ppc_elf_lcomm (int);
#endif

#ifdef TE_PE
static void ppc_previous (int);
static void ppc_pdata (int);
static void ppc_ydata (int);
static void ppc_reldata (int);
static void ppc_rdata (int);
static void ppc_ualong (int);
static void ppc_znop (int);
static void ppc_pe_comm (int);
static void ppc_pe_section (int);
static void ppc_pe_function (int);
static void ppc_pe_tocd (int);
#endif

/* Generic assembler global variables which must be defined by all
   targets.  */

#ifdef OBJ_ELF
/* This string holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  The macro
   tc_comment_chars points to this.  We use this, rather than the
   usual comment_chars, so that we can switch for Solaris conventions.  */
static const char ppc_solaris_comment_chars[] = "#!";
static const char ppc_eabi_comment_chars[] = "#";

#ifdef TARGET_SOLARIS_COMMENT
const char *ppc_comment_chars = ppc_solaris_comment_chars;
#else
const char *ppc_comment_chars = ppc_eabi_comment_chars;
#endif
#else
const char comment_chars[] = "#";
#endif

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";

/* Anything that can start an operand needs to be mentioned here,
   to stop the input scrubber eating whitespace.  */
const char ppc_symbol_chars[] = "%[";

/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
int ppc_cie_data_alignment;

/* The dwarf2 minimum instruction length.  */
int ppc_dwarf2_line_min_insn_length;

/* More than this number of nops in an alignment op gets a branch
   instead.  */
unsigned long nop_limit = 4;

/* The type of processor we are assembling for.  This is one or more
   of the PPC_OPCODE flags defined in opcode/ppc.h.  */
ppc_cpu_t ppc_cpu = 0;
ppc_cpu_t sticky = 0;

/* Flags set on encountering toc relocs.  */
enum {
  has_large_toc_reloc = 1,
  has_small_toc_reloc = 2
} toc_reloc_types;

/* The target specific pseudo-ops which we support.  */

const pseudo_typeS md_pseudo_table[] =
{
  /* Pseudo-ops which must be overridden.  */
  { "byte",	ppc_byte,	0 },

#ifdef OBJ_XCOFF
  /* Pseudo-ops specific to the RS/6000 XCOFF format.  Some of these
     legitimately belong in the obj-*.c file.  However, XCOFF is based
     on COFF, and is only implemented for the RS/6000.  We just use
     obj-coff.c, and add what we need here.  */
  { "comm",	ppc_comm,	0 },
  { "lcomm",	ppc_comm,	1 },
  { "bb",	ppc_bb,		0 },
  { "bc",	ppc_bc,		0 },
  { "bf",	ppc_bf,		0 },
  { "bi",	ppc_biei,	0 },
  { "bs",	ppc_bs,		0 },
  { "csect",	ppc_csect,	0 },
  { "dwsect",	ppc_dwsect,	0 },
  { "data",	ppc_section,	'd' },
  { "eb",	ppc_eb,		0 },
  { "ec",	ppc_ec,		0 },
  { "ef",	ppc_ef,		0 },
  { "ei",	ppc_biei,	1 },
  { "es",	ppc_es,		0 },
  { "extern",	ppc_extern,	0 },
  { "function",	ppc_function,	0 },
  { "lglobl",	ppc_lglobl,	0 },
  { "ref",	ppc_ref,	0 },
  { "rename",	ppc_rename,	0 },
  { "section",	ppc_named_section, 0 },
  { "stabx",	ppc_stabx,	0 },
  { "text",	ppc_section,	't' },
  { "toc",	ppc_toc,	0 },
  { "long",	ppc_xcoff_cons,	2 },
  { "llong",	ppc_xcoff_cons,	3 },
  { "word",	ppc_xcoff_cons,	1 },
  { "short",	ppc_xcoff_cons,	1 },
  { "vbyte",    ppc_vbyte,	0 },
#endif

#ifdef OBJ_ELF
  { "llong",	ppc_elf_cons,	8 },
  { "quad",	ppc_elf_cons,	8 },
  { "long",	ppc_elf_cons,	4 },
  { "word",	ppc_elf_cons,	2 },
  { "short",	ppc_elf_cons,	2 },
  { "rdata",	ppc_elf_rdata,	0 },
  { "rodata",	ppc_elf_rdata,	0 },
  { "lcomm",	ppc_elf_lcomm,	0 },
#endif

#ifdef TE_PE
  /* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format.  */
  { "previous", ppc_previous,   0 },
  { "pdata",    ppc_pdata,      0 },
  { "ydata",    ppc_ydata,      0 },
  { "reldata",  ppc_reldata,    0 },
  { "rdata",    ppc_rdata,      0 },
  { "ualong",   ppc_ualong,     0 },
  { "znop",     ppc_znop,       0 },
  { "comm",	ppc_pe_comm,	0 },
  { "lcomm",	ppc_pe_comm,	1 },
  { "section",  ppc_pe_section, 0 },
  { "function",	ppc_pe_function,0 },
  { "tocd",     ppc_pe_tocd,    0 },
#endif

#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
  { "tc",	ppc_tc,		0 },
  { "machine",  ppc_machine,    0 },
#endif

  { NULL,	NULL,		0 }
};


/* Predefined register names if -mregnames (or default for Windows NT).
   In general, there are lots of them, in an attempt to be compatible
   with a number of other Windows NT assemblers.  */

/* Structure to hold information about predefined registers.  */
struct pd_reg
  {
    char *name;
    int value;
  };

/* List of registers that are pre-defined:

   Each general register has predefined names of the form:
   1. r<reg_num> which has the value <reg_num>.
   2. r.<reg_num> which has the value <reg_num>.

   Each floating point register has predefined names of the form:
   1. f<reg_num> which has the value <reg_num>.
   2. f.<reg_num> which has the value <reg_num>.

   Each vector unit register has predefined names of the form:
   1. v<reg_num> which has the value <reg_num>.
   2. v.<reg_num> which has the value <reg_num>.

   Each condition register has predefined names of the form:
   1. cr<reg_num> which has the value <reg_num>.
   2. cr.<reg_num> which has the value <reg_num>.

   There are individual registers as well:
   sp or r.sp     has the value 1
   rtoc or r.toc  has the value 2
   fpscr          has the value 0
   xer            has the value 1
   lr             has the value 8
   ctr            has the value 9
   pmr            has the value 0
   dar            has the value 19
   dsisr          has the value 18
   dec            has the value 22
   sdr1           has the value 25
   srr0           has the value 26
   srr1           has the value 27

   The table is sorted. Suitable for searching by a binary search.  */

static const struct pd_reg pre_defined_registers[] =
{
  { "cr.0", 0 },    /* Condition Registers */
  { "cr.1", 1 },
  { "cr.2", 2 },
  { "cr.3", 3 },
  { "cr.4", 4 },
  { "cr.5", 5 },
  { "cr.6", 6 },
  { "cr.7", 7 },

  { "cr0", 0 },
  { "cr1", 1 },
  { "cr2", 2 },
  { "cr3", 3 },
  { "cr4", 4 },
  { "cr5", 5 },
  { "cr6", 6 },
  { "cr7", 7 },

  { "ctr", 9 },

  { "dar", 19 },    /* Data Access Register */
  { "dec", 22 },    /* Decrementer */
  { "dsisr", 18 },  /* Data Storage Interrupt Status Register */

  { "f.0", 0 },     /* Floating point registers */
  { "f.1", 1 },
  { "f.10", 10 },
  { "f.11", 11 },
  { "f.12", 12 },
  { "f.13", 13 },
  { "f.14", 14 },
  { "f.15", 15 },
  { "f.16", 16 },
  { "f.17", 17 },
  { "f.18", 18 },
  { "f.19", 19 },
  { "f.2", 2 },
  { "f.20", 20 },
  { "f.21", 21 },
  { "f.22", 22 },
  { "f.23", 23 },
  { "f.24", 24 },
  { "f.25", 25 },
  { "f.26", 26 },
  { "f.27", 27 },
  { "f.28", 28 },
  { "f.29", 29 },
  { "f.3", 3 },
  { "f.30", 30 },
  { "f.31", 31 },

  { "f.32", 32 },    /* Extended floating point scalar registers (ISA 2.06).  */
  { "f.33", 33 },
  { "f.34", 34 },
  { "f.35", 35 },
  { "f.36", 36 },
  { "f.37", 37 },
  { "f.38", 38 },
  { "f.39", 39 },
  { "f.4", 4 },
  { "f.40", 40 },
  { "f.41", 41 },
  { "f.42", 42 },
  { "f.43", 43 },
  { "f.44", 44 },
  { "f.45", 45 },
  { "f.46", 46 },
  { "f.47", 47 },
  { "f.48", 48 },
  { "f.49", 49 },
  { "f.5", 5 },
  { "f.50", 50 },
  { "f.51", 51 },
  { "f.52", 52 },
  { "f.53", 53 },
  { "f.54", 54 },
  { "f.55", 55 },
  { "f.56", 56 },
  { "f.57", 57 },
  { "f.58", 58 },
  { "f.59", 59 },
  { "f.6", 6 },
  { "f.60", 60 },
  { "f.61", 61 },
  { "f.62", 62 },
  { "f.63", 63 },
  { "f.7", 7 },
  { "f.8", 8 },
  { "f.9", 9 },

  { "f0", 0 },
  { "f1", 1 },
  { "f10", 10 },
  { "f11", 11 },
  { "f12", 12 },
  { "f13", 13 },
  { "f14", 14 },
  { "f15", 15 },
  { "f16", 16 },
  { "f17", 17 },
  { "f18", 18 },
  { "f19", 19 },
  { "f2", 2 },
  { "f20", 20 },
  { "f21", 21 },
  { "f22", 22 },
  { "f23", 23 },
  { "f24", 24 },
  { "f25", 25 },
  { "f26", 26 },
  { "f27", 27 },
  { "f28", 28 },
  { "f29", 29 },
  { "f3", 3 },
  { "f30", 30 },
  { "f31", 31 },

  { "f32", 32 },    /* Extended floating point scalar registers (ISA 2.06).  */
  { "f33", 33 },
  { "f34", 34 },
  { "f35", 35 },
  { "f36", 36 },
  { "f37", 37 },
  { "f38", 38 },
  { "f39", 39 },
  { "f4", 4 },
  { "f40", 40 },
  { "f41", 41 },
  { "f42", 42 },
  { "f43", 43 },
  { "f44", 44 },
  { "f45", 45 },
  { "f46", 46 },
  { "f47", 47 },
  { "f48", 48 },
  { "f49", 49 },
  { "f5", 5 },
  { "f50", 50 },
  { "f51", 51 },
  { "f52", 52 },
  { "f53", 53 },
  { "f54", 54 },
  { "f55", 55 },
  { "f56", 56 },
  { "f57", 57 },
  { "f58", 58 },
  { "f59", 59 },
  { "f6", 6 },
  { "f60", 60 },
  { "f61", 61 },
  { "f62", 62 },
  { "f63", 63 },
  { "f7", 7 },
  { "f8", 8 },
  { "f9", 9 },

  { "fpscr", 0 },

  /* Quantization registers used with pair single instructions.  */
  { "gqr.0", 0 },
  { "gqr.1", 1 },
  { "gqr.2", 2 },
  { "gqr.3", 3 },
  { "gqr.4", 4 },
  { "gqr.5", 5 },
  { "gqr.6", 6 },
  { "gqr.7", 7 },
  { "gqr0", 0 },
  { "gqr1", 1 },
  { "gqr2", 2 },
  { "gqr3", 3 },
  { "gqr4", 4 },
  { "gqr5", 5 },
  { "gqr6", 6 },
  { "gqr7", 7 },

  { "lr", 8 },     /* Link Register */

  { "pmr", 0 },

  { "r.0", 0 },    /* General Purpose Registers */
  { "r.1", 1 },
  { "r.10", 10 },
  { "r.11", 11 },
  { "r.12", 12 },
  { "r.13", 13 },
  { "r.14", 14 },
  { "r.15", 15 },
  { "r.16", 16 },
  { "r.17", 17 },
  { "r.18", 18 },
  { "r.19", 19 },
  { "r.2", 2 },
  { "r.20", 20 },
  { "r.21", 21 },
  { "r.22", 22 },
  { "r.23", 23 },
  { "r.24", 24 },
  { "r.25", 25 },
  { "r.26", 26 },
  { "r.27", 27 },
  { "r.28", 28 },
  { "r.29", 29 },
  { "r.3", 3 },
  { "r.30", 30 },
  { "r.31", 31 },
  { "r.4", 4 },
  { "r.5", 5 },
  { "r.6", 6 },
  { "r.7", 7 },
  { "r.8", 8 },
  { "r.9", 9 },

  { "r.sp", 1 },   /* Stack Pointer */

  { "r.toc", 2 },  /* Pointer to the table of contents */

  { "r0", 0 },     /* More general purpose registers */
  { "r1", 1 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "r16", 16 },
  { "r17", 17 },
  { "r18", 18 },
  { "r19", 19 },
  { "r2", 2 },
  { "r20", 20 },
  { "r21", 21 },
  { "r22", 22 },
  { "r23", 23 },
  { "r24", 24 },
  { "r25", 25 },
  { "r26", 26 },
  { "r27", 27 },
  { "r28", 28 },
  { "r29", 29 },
  { "r3", 3 },
  { "r30", 30 },
  { "r31", 31 },
  { "r4", 4 },
  { "r5", 5 },
  { "r6", 6 },
  { "r7", 7 },
  { "r8", 8 },
  { "r9", 9 },

  { "rtoc", 2 },  /* Table of contents */

  { "sdr1", 25 }, /* Storage Description Register 1 */

  { "sp", 1 },

  { "srr0", 26 }, /* Machine Status Save/Restore Register 0 */
  { "srr1", 27 }, /* Machine Status Save/Restore Register 1 */

  { "v.0", 0 },     /* Vector (Altivec/VMX) registers */
  { "v.1", 1 },
  { "v.10", 10 },
  { "v.11", 11 },
  { "v.12", 12 },
  { "v.13", 13 },
  { "v.14", 14 },
  { "v.15", 15 },
  { "v.16", 16 },
  { "v.17", 17 },
  { "v.18", 18 },
  { "v.19", 19 },
  { "v.2", 2 },
  { "v.20", 20 },
  { "v.21", 21 },
  { "v.22", 22 },
  { "v.23", 23 },
  { "v.24", 24 },
  { "v.25", 25 },
  { "v.26", 26 },
  { "v.27", 27 },
  { "v.28", 28 },
  { "v.29", 29 },
  { "v.3", 3 },
  { "v.30", 30 },
  { "v.31", 31 },
  { "v.4", 4 },
  { "v.5", 5 },
  { "v.6", 6 },
  { "v.7", 7 },
  { "v.8", 8 },
  { "v.9", 9 },

  { "v0", 0 },
  { "v1", 1 },
  { "v10", 10 },
  { "v11", 11 },
  { "v12", 12 },
  { "v13", 13 },
  { "v14", 14 },
  { "v15", 15 },
  { "v16", 16 },
  { "v17", 17 },
  { "v18", 18 },
  { "v19", 19 },
  { "v2", 2 },
  { "v20", 20 },
  { "v21", 21 },
  { "v22", 22 },
  { "v23", 23 },
  { "v24", 24 },
  { "v25", 25 },
  { "v26", 26 },
  { "v27", 27 },
  { "v28", 28 },
  { "v29", 29 },
  { "v3", 3 },
  { "v30", 30 },
  { "v31", 31 },
  { "v4", 4 },
  { "v5", 5 },
  { "v6", 6 },
  { "v7", 7 },
  { "v8", 8 },
  { "v9", 9 },

  { "vs.0", 0 },     /* Vector Scalar (VSX) registers (ISA 2.06).  */
  { "vs.1", 1 },
  { "vs.10", 10 },
  { "vs.11", 11 },
  { "vs.12", 12 },
  { "vs.13", 13 },
  { "vs.14", 14 },
  { "vs.15", 15 },
  { "vs.16", 16 },
  { "vs.17", 17 },
  { "vs.18", 18 },
  { "vs.19", 19 },
  { "vs.2", 2 },
  { "vs.20", 20 },
  { "vs.21", 21 },
  { "vs.22", 22 },
  { "vs.23", 23 },
  { "vs.24", 24 },
  { "vs.25", 25 },
  { "vs.26", 26 },
  { "vs.27", 27 },
  { "vs.28", 28 },
  { "vs.29", 29 },
  { "vs.3", 3 },
  { "vs.30", 30 },
  { "vs.31", 31 },
  { "vs.32", 32 },
  { "vs.33", 33 },
  { "vs.34", 34 },
  { "vs.35", 35 },
  { "vs.36", 36 },
  { "vs.37", 37 },
  { "vs.38", 38 },
  { "vs.39", 39 },
  { "vs.4", 4 },
  { "vs.40", 40 },
  { "vs.41", 41 },
  { "vs.42", 42 },
  { "vs.43", 43 },
  { "vs.44", 44 },
  { "vs.45", 45 },
  { "vs.46", 46 },
  { "vs.47", 47 },
  { "vs.48", 48 },
  { "vs.49", 49 },
  { "vs.5", 5 },
  { "vs.50", 50 },
  { "vs.51", 51 },
  { "vs.52", 52 },
  { "vs.53", 53 },
  { "vs.54", 54 },
  { "vs.55", 55 },
  { "vs.56", 56 },
  { "vs.57", 57 },
  { "vs.58", 58 },
  { "vs.59", 59 },
  { "vs.6", 6 },
  { "vs.60", 60 },
  { "vs.61", 61 },
  { "vs.62", 62 },
  { "vs.63", 63 },
  { "vs.7", 7 },
  { "vs.8", 8 },
  { "vs.9", 9 },

  { "vs0", 0 },
  { "vs1", 1 },
  { "vs10", 10 },
  { "vs11", 11 },
  { "vs12", 12 },
  { "vs13", 13 },
  { "vs14", 14 },
  { "vs15", 15 },
  { "vs16", 16 },
  { "vs17", 17 },
  { "vs18", 18 },
  { "vs19", 19 },
  { "vs2", 2 },
  { "vs20", 20 },
  { "vs21", 21 },
  { "vs22", 22 },
  { "vs23", 23 },
  { "vs24", 24 },
  { "vs25", 25 },
  { "vs26", 26 },
  { "vs27", 27 },
  { "vs28", 28 },
  { "vs29", 29 },
  { "vs3", 3 },
  { "vs30", 30 },
  { "vs31", 31 },
  { "vs32", 32 },
  { "vs33", 33 },
  { "vs34", 34 },
  { "vs35", 35 },
  { "vs36", 36 },
  { "vs37", 37 },
  { "vs38", 38 },
  { "vs39", 39 },
  { "vs4", 4 },
  { "vs40", 40 },
  { "vs41", 41 },
  { "vs42", 42 },
  { "vs43", 43 },
  { "vs44", 44 },
  { "vs45", 45 },
  { "vs46", 46 },
  { "vs47", 47 },
  { "vs48", 48 },
  { "vs49", 49 },
  { "vs5", 5 },
  { "vs50", 50 },
  { "vs51", 51 },
  { "vs52", 52 },
  { "vs53", 53 },
  { "vs54", 54 },
  { "vs55", 55 },
  { "vs56", 56 },
  { "vs57", 57 },
  { "vs58", 58 },
  { "vs59", 59 },
  { "vs6", 6 },
  { "vs60", 60 },
  { "vs61", 61 },
  { "vs62", 62 },
  { "vs63", 63 },
  { "vs7", 7 },
  { "vs8", 8 },
  { "vs9", 9 },

  { "xer", 1 },

};

#define REG_NAME_CNT	(sizeof (pre_defined_registers) / sizeof (struct pd_reg))

/* Given NAME, find the register number associated with that name, return
   the integer value associated with the given name or -1 on failure.  */

static int
reg_name_search (const struct pd_reg *regs, int regcount, const char *name)
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return regs[middle].value;
    }
  while (low <= high);

  return -1;
}

/*
 * Summary of register_name.
 *
 * in:	Input_line_pointer points to 1st char of operand.
 *
 * out:	A expressionS.
 *      The operand may have been a register: in this case, X_op == O_register,
 *      X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in its
 *      original state.
 */

static bfd_boolean
register_name (expressionS *expressionP)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;
  if (name[0] == '%' && ISALPHA (name[1]))
    name = ++input_line_pointer;

  else if (!reg_names_p || !ISALPHA (name[0]))
    return FALSE;

  c = get_symbol_end ();
  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

/* This function is called for each symbol seen in an expression.  It
   handles the special parsing which PowerPC assemblers are supposed
   to use for condition codes.  */

/* Whether to do the special parsing.  */
static bfd_boolean cr_operand;

/* Names to recognize in a condition code.  This table is sorted.  */
static const struct pd_reg cr_names[] =
{
  { "cr0", 0 },
  { "cr1", 1 },
  { "cr2", 2 },
  { "cr3", 3 },
  { "cr4", 4 },
  { "cr5", 5 },
  { "cr6", 6 },
  { "cr7", 7 },
  { "eq", 2 },
  { "gt", 1 },
  { "lt", 0 },
  { "so", 3 },
  { "un", 3 }
};

/* Parsing function.  This returns non-zero if it recognized an
   expression.  */

int
ppc_parse_name (const char *name, expressionS *exp)
{
  int val;

  if (! cr_operand)
    return 0;

  if (*name == '%')
    ++name;
  val = reg_name_search (cr_names, sizeof cr_names / sizeof cr_names[0],
			 name);
  if (val < 0)
    return 0;

  exp->X_op = O_constant;
  exp->X_add_number = val;

  return 1;
}

/* Local variables.  */

/* Whether to target xcoff64/elf64.  */
static unsigned int ppc_obj64 = BFD_DEFAULT_TARGET_SIZE == 64;

/* Opcode hash table.  */
static struct hash_control *ppc_hash;

/* Macro hash table.  */
static struct hash_control *ppc_macro_hash;

#ifdef OBJ_ELF
/* What type of shared library support to use.  */
static enum { SHLIB_NONE, SHLIB_PIC, SHLIB_MRELOCATABLE } shlib = SHLIB_NONE;

/* Flags to set in the elf header.  */
static flagword ppc_flags = 0;

/* Whether this is Solaris or not.  */
#ifdef TARGET_SOLARIS_COMMENT
#define SOLARIS_P TRUE
#else
#define SOLARIS_P FALSE
#endif

static bfd_boolean msolaris = SOLARIS_P;
#endif

#ifdef OBJ_XCOFF

/* The RS/6000 assembler uses the .csect pseudo-op to generate code
   using a bunch of different sections.  These assembler sections,
   however, are all encompassed within the .text or .data sections of
   the final output file.  We handle this by using different
   subsegments within these main segments.  */

/* Next subsegment to allocate within the .text segment.  */
static subsegT ppc_text_subsegment = 2;

/* Linked list of csects in the text section.  */
static symbolS *ppc_text_csects;

/* Next subsegment to allocate within the .data segment.  */
static subsegT ppc_data_subsegment = 2;

/* Linked list of csects in the data section.  */
static symbolS *ppc_data_csects;

/* The current csect.  */
static symbolS *ppc_current_csect;

/* The RS/6000 assembler uses a TOC which holds addresses of functions
   and variables.  Symbols are put in the TOC with the .tc pseudo-op.
   A special relocation is used when accessing TOC entries.  We handle
   the TOC as a subsegment within the .data segment.  We set it up if
   we see a .toc pseudo-op, and save the csect symbol here.  */
static symbolS *ppc_toc_csect;

/* The first frag in the TOC subsegment.  */
static fragS *ppc_toc_frag;

/* The first frag in the first subsegment after the TOC in the .data
   segment.  NULL if there are no subsegments after the TOC.  */
static fragS *ppc_after_toc_frag;

/* The current static block.  */
static symbolS *ppc_current_block;

/* The COFF debugging section; set by md_begin.  This is not the
   .debug section, but is instead the secret BFD section which will
   cause BFD to set the section number of a symbol to N_DEBUG.  */
static asection *ppc_coff_debug_section;

/* Structure to set the length field of the dwarf sections.  */
struct dw_subsection {
  /* Subsections are simply linked.  */
  struct dw_subsection *link;

  /* The subsection number.  */
  subsegT subseg;

  /* Expression to compute the length of the section.  */
  expressionS end_exp;
};

static struct dw_section {
  /* Corresponding section.  */
  segT sect;

  /* Simply linked list of subsections with a label.  */
  struct dw_subsection *list_subseg;

  /* The anonymous subsection.  */
  struct dw_subsection *anon_subseg;
} dw_sections[XCOFF_DWSECT_NBR_NAMES];
#endif /* OBJ_XCOFF */

#ifdef TE_PE

/* Various sections that we need for PE coff support.  */
static segT ydata_section;
static segT pdata_section;
static segT reldata_section;
static segT rdata_section;
static segT tocdata_section;

/* The current section and the previous section. See ppc_previous.  */
static segT ppc_previous_section;
static segT ppc_current_section;

#endif /* TE_PE */

#ifdef OBJ_ELF
symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE" */
#define PPC_APUINFO_ISEL	0x40
#define PPC_APUINFO_PMR		0x41
#define PPC_APUINFO_RFMCI	0x42
#define PPC_APUINFO_CACHELCK	0x43
#define PPC_APUINFO_SPE		0x100
#define PPC_APUINFO_EFS		0x101
#define PPC_APUINFO_BRLOCK	0x102
#define PPC_APUINFO_VLE		0x104

/*
 * We keep a list of APUinfo
 */
unsigned long *ppc_apuinfo_list;
unsigned int ppc_apuinfo_num;
unsigned int ppc_apuinfo_num_alloc;
#endif /* OBJ_ELF */

#ifdef OBJ_ELF
const char *const md_shortopts = "b:l:usm:K:VQ:";
#else
const char *const md_shortopts = "um:";
#endif
#define OPTION_NOPS (OPTION_MD_BASE + 0)
const struct option md_longopts[] = {
  {"nops", required_argument, NULL, OPTION_NOPS},
  {NULL, no_argument, NULL, 0}
};
const size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg)
{
  ppc_cpu_t new_cpu;

  switch (c)
    {
    case 'u':
      /* -u means that any undefined symbols should be treated as
	 external, which is the default for gas anyhow.  */
      break;

#ifdef OBJ_ELF
    case 'l':
      /* Solaris as takes -le (presumably for little endian).  For completeness
	 sake, recognize -be also.  */
      if (strcmp (arg, "e") == 0)
	{
	  target_big_endian = 0;
	  set_target_endian = 1;
	  if (ppc_cpu & PPC_OPCODE_VLE)
	    as_bad (_("the use of -mvle requires big endian."));
	}
      else
	return 0;

      break;

    case 'b':
      if (strcmp (arg, "e") == 0)
	{
	  target_big_endian = 1;
	  set_target_endian = 1;
	}
      else
	return 0;

      break;

    case 'K':
      /* Recognize -K PIC.  */
      if (strcmp (arg, "PIC") == 0 || strcmp (arg, "pic") == 0)
	{
	  shlib = SHLIB_PIC;
	  ppc_flags |= EF_PPC_RELOCATABLE_LIB;
	}
      else
	return 0;

      break;
#endif

      /* a64 and a32 determine whether to use XCOFF64 or XCOFF32.  */
    case 'a':
      if (strcmp (arg, "64") == 0)
	{
#ifdef BFD64
	  ppc_obj64 = 1;
	  if (ppc_cpu & PPC_OPCODE_VLE)
	    as_bad (_("the use of -mvle requires -a32."));
#else
	  as_fatal (_("%s unsupported"), "-a64");
#endif
	}
      else if (strcmp (arg, "32") == 0)
	ppc_obj64 = 0;
      else
	return 0;
      break;

    case 'm':
      new_cpu = ppc_parse_cpu (ppc_cpu, &sticky, arg);
      if (new_cpu != 0)
	{
	  ppc_cpu = new_cpu;
	  if (strcmp (arg, "vle") == 0)
	    {
	      if (set_target_endian && target_big_endian == 0)
		as_bad (_("the use of -mvle requires big endian."));
	      if (ppc_obj64)
		as_bad (_("the use of -mvle requires -a32."));
	    }
	}

      else if (strcmp (arg, "regnames") == 0)
	reg_names_p = TRUE;

      else if (strcmp (arg, "no-regnames") == 0)
	reg_names_p = FALSE;

#ifdef OBJ_ELF
      /* -mrelocatable/-mrelocatable-lib -- warn about initializations
	 that require relocation.  */
      else if (strcmp (arg, "relocatable") == 0)
	{
	  shlib = SHLIB_MRELOCATABLE;
	  ppc_flags |= EF_PPC_RELOCATABLE;
	}

      else if (strcmp (arg, "relocatable-lib") == 0)
	{
	  shlib = SHLIB_MRELOCATABLE;
	  ppc_flags |= EF_PPC_RELOCATABLE_LIB;
	}

      /* -memb, set embedded bit.  */
      else if (strcmp (arg, "emb") == 0)
	ppc_flags |= EF_PPC_EMB;

      /* -mlittle/-mbig set the endianness.  */
      else if (strcmp (arg, "little") == 0
	       || strcmp (arg, "little-endian") == 0)
	{
	  target_big_endian = 0;
	  set_target_endian = 1;
	  if (ppc_cpu & PPC_OPCODE_VLE)
	    as_bad (_("the use of -mvle requires big endian."));
	}

      else if (strcmp (arg, "big") == 0 || strcmp (arg, "big-endian") == 0)
	{
	  target_big_endian = 1;
	  set_target_endian = 1;
	}

      else if (strcmp (arg, "solaris") == 0)
	{
	  msolaris = TRUE;
	  ppc_comment_chars = ppc_solaris_comment_chars;
	}

      else if (strcmp (arg, "no-solaris") == 0)
	{
	  msolaris = FALSE;
	  ppc_comment_chars = ppc_eabi_comment_chars;
	}
#endif
      else
	{
	  as_bad (_("invalid switch -m%s"), arg);
	  return 0;
	}
      break;

#ifdef OBJ_ELF
      /* -V: SVR4 argument to print version ID.  */
    case 'V':
      print_version_id ();
      break;

      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

      /* Solaris takes -s to specify that .stabs go in a .stabs section,
	 rather than .stabs.excl, which is ignored by the linker.
	 FIXME: Not implemented.  */
    case 's':
      if (arg)
	return 0;

      break;
#endif

    case OPTION_NOPS:
      {
	char *end;
	nop_limit = strtoul (optarg, &end, 0);
	if (*end)
	  as_bad (_("--nops needs a numeric argument"));
      }
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
PowerPC options:\n\
-a32                    generate ELF32/XCOFF32\n\
-a64                    generate ELF64/XCOFF64\n\
-u                      ignored\n\
-mpwrx, -mpwr2          generate code for POWER/2 (RIOS2)\n\
-mpwr                   generate code for POWER (RIOS1)\n\
-m601                   generate code for PowerPC 601\n\
-mppc, -mppc32, -m603, -m604\n\
                        generate code for PowerPC 603/604\n\
-m403                   generate code for PowerPC 403\n\
-m405                   generate code for PowerPC 405\n\
-m440                   generate code for PowerPC 440\n\
-m464                   generate code for PowerPC 464\n\
-m476                   generate code for PowerPC 476\n\
-m7400, -m7410, -m7450, -m7455\n\
                        generate code for PowerPC 7400/7410/7450/7455\n\
-m750cl                 generate code for PowerPC 750cl\n"));
  fprintf (stream, _("\
-mppc64, -m620          generate code for PowerPC 620/625/630\n\
-mppc64bridge           generate code for PowerPC 64, including bridge insns\n\
-mbooke                 generate code for 32-bit PowerPC BookE\n\
-ma2                    generate code for A2 architecture\n\
-mpower4, -mpwr4        generate code for Power4 architecture\n\
-mpower5, -mpwr5, -mpwr5x\n\
                        generate code for Power5 architecture\n\
-mpower6, -mpwr6        generate code for Power6 architecture\n\
-mpower7, -mpwr7        generate code for Power7 architecture\n\
-mpower8, -mpwr8        generate code for Power8 architecture\n\
-mcell                  generate code for Cell Broadband Engine architecture\n\
-mcom                   generate code Power/PowerPC common instructions\n\
-many                   generate code for any architecture (PWR/PWRX/PPC)\n"));
  fprintf (stream, _("\
-maltivec               generate code for AltiVec\n\
-mvsx                   generate code for Vector-Scalar (VSX) instructions\n\
-mhtm                   generate code for Hardware Transactional Memory\n\
-me300                  generate code for PowerPC e300 family\n\
-me500, -me500x2        generate code for Motorola e500 core complex\n\
-me500mc,               generate code for Freescale e500mc core complex\n\
-me500mc64,             generate code for Freescale e500mc64 core complex\n\
-me5500,                generate code for Freescale e5500 core complex\n\
-me6500,                generate code for Freescale e6500 core complex\n\
-mspe                   generate code for Motorola SPE instructions\n\
-mvle                   generate code for Freescale VLE instructions\n\
-mtitan                 generate code for AppliedMicro Titan core complex\n\
-mregnames              Allow symbolic names for registers\n\
-mno-regnames           Do not allow symbolic names for registers\n"));
#ifdef OBJ_ELF
  fprintf (stream, _("\
-mrelocatable           support for GCC's -mrelocatble option\n\
-mrelocatable-lib       support for GCC's -mrelocatble-lib option\n\
-memb                   set PPC_EMB bit in ELF flags\n\
-mlittle, -mlittle-endian, -le\n\
                        generate code for a little endian machine\n\
-mbig, -mbig-endian, -be\n\
                        generate code for a big endian machine\n\
-msolaris               generate code for Solaris\n\
-mno-solaris            do not generate code for Solaris\n\
-K PIC                  set EF_PPC_RELOCATABLE_LIB in ELF flags\n\
-V                      print assembler version number\n\
-Qy, -Qn                ignored\n"));
#endif
  fprintf (stream, _("\
-nops=count             when aligning, more than COUNT nops uses a branch\n"));
}

/* Set ppc_cpu if it is not already set.  */

static void
ppc_set_cpu (void)
{
  const char *default_os  = TARGET_OS;
  const char *default_cpu = TARGET_CPU;

  if ((ppc_cpu & ~(ppc_cpu_t) PPC_OPCODE_ANY) == 0)
    {
      if (ppc_obj64)
	ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_64;
      else if (strncmp (default_os, "aix", 3) == 0
	       && default_os[3] >= '4' && default_os[3] <= '9')
	ppc_cpu |= PPC_OPCODE_COMMON;
      else if (strncmp (default_os, "aix3", 4) == 0)
	ppc_cpu |= PPC_OPCODE_POWER;
      else if (strcmp (default_cpu, "rs6000") == 0)
	ppc_cpu |= PPC_OPCODE_POWER;
      else if (strncmp (default_cpu, "powerpc", 7) == 0)
	ppc_cpu |= PPC_OPCODE_PPC;
      else
	as_fatal (_("unknown default cpu = %s, os = %s"),
		  default_cpu, default_os);
    }
}

/* Figure out the BFD architecture to use.  This function and ppc_mach
   are called well before md_begin, when the output file is opened.  */

enum bfd_architecture
ppc_arch (void)
{
  const char *default_cpu = TARGET_CPU;
  ppc_set_cpu ();

  if ((ppc_cpu & PPC_OPCODE_PPC) != 0)
    return bfd_arch_powerpc;
  if ((ppc_cpu & PPC_OPCODE_VLE) != 0)
    return bfd_arch_powerpc;
  if ((ppc_cpu & PPC_OPCODE_POWER) != 0)
    return bfd_arch_rs6000;
  if ((ppc_cpu & (PPC_OPCODE_COMMON | PPC_OPCODE_ANY)) != 0)
    {
      if (strcmp (default_cpu, "rs6000") == 0)
	return bfd_arch_rs6000;
      else if (strncmp (default_cpu, "powerpc", 7) == 0)
	return bfd_arch_powerpc;
    }

  as_fatal (_("neither Power nor PowerPC opcodes were selected."));
  return bfd_arch_unknown;
}

unsigned long
ppc_mach (void)
{
  if (ppc_obj64)
    return bfd_mach_ppc64;
  else if (ppc_arch () == bfd_arch_rs6000)
    return bfd_mach_rs6k;
  else if (ppc_cpu & PPC_OPCODE_TITAN)
    return bfd_mach_ppc_titan;
  else if (ppc_cpu & PPC_OPCODE_VLE)
    return bfd_mach_ppc_vle;
  else
    return bfd_mach_ppc;
}

extern char*
ppc_target_format (void)
{
#ifdef OBJ_COFF
#ifdef TE_PE
  return target_big_endian ? "pe-powerpc" : "pe-powerpcle";
#elif TE_POWERMAC
  return "xcoff-powermac";
#else
#  ifdef TE_AIX5
  return (ppc_obj64 ? "aix5coff64-rs6000" : "aixcoff-rs6000");
#  else
  return (ppc_obj64 ? "aixcoff64-rs6000" : "aixcoff-rs6000");
#  endif
#endif
#endif
#ifdef OBJ_ELF
# ifdef TE_FreeBSD
  return (ppc_obj64 ? "elf64-powerpc-freebsd" : "elf32-powerpc-freebsd");
# elif defined (TE_VXWORKS)
  return "elf32-powerpc-vxworks";
# else
  return (target_big_endian
	  ? (ppc_obj64 ? "elf64-powerpc" : "elf32-powerpc")
	  : (ppc_obj64 ? "elf64-powerpcle" : "elf32-powerpcle"));
# endif
#endif
}

/* Validate one entry in powerpc_opcodes[] or vle_opcodes[].
   Return TRUE if there's a problem, otherwise FALSE.  */

static bfd_boolean
insn_validate (const struct powerpc_opcode *op)
{
  const unsigned char *o;
  unsigned long omask = op->mask;

  /* The mask had better not trim off opcode bits.  */
  if ((op->opcode & omask) != op->opcode)
    {
      as_bad (_("mask trims opcode bits for %s"), op->name);
      return TRUE;
    }

  /* The operands must not overlap the opcode or each other.  */
  for (o = op->operands; *o; ++o)
    {
      if (*o >= num_powerpc_operands)
        {
	  as_bad (_("operand index error for %s"), op->name);
	  return TRUE;
        }
      else
        {
	  const struct powerpc_operand *operand = &powerpc_operands[*o];
	  if (operand->shift != PPC_OPSHIFT_INV)
	    {
	      unsigned long mask;

	      if (operand->shift >= 0)
		mask = operand->bitm << operand->shift;
	      else
		mask = operand->bitm >> -operand->shift;
	      if (omask & mask)
		{
		  as_bad (_("operand %d overlap in %s"),
			  (int) (o - op->operands), op->name);
		  return TRUE;
		}
	      omask |= mask;
	    }
        }
    }
  return FALSE;
}

/* Insert opcodes and macros into hash tables.  Called at startup and
   for .machine pseudo.  */

static void
ppc_setup_opcodes (void)
{
  const struct powerpc_opcode *op;
  const struct powerpc_opcode *op_end;
  const struct powerpc_macro *macro;
  const struct powerpc_macro *macro_end;
  bfd_boolean bad_insn = FALSE;

  if (ppc_hash != NULL)
    hash_die (ppc_hash);
  if (ppc_macro_hash != NULL)
    hash_die (ppc_macro_hash);

  /* Insert the opcodes into a hash table.  */
  ppc_hash = hash_new ();

  if (ENABLE_CHECKING)
    {
      unsigned int i;

      /* An index into powerpc_operands is stored in struct fix
	 fx_pcrel_adjust which is 8 bits wide.  */
      gas_assert (num_powerpc_operands < 256);

      /* Check operand masks.  Code here and in the disassembler assumes
	 all the 1's in the mask are contiguous.  */
      for (i = 0; i < num_powerpc_operands; ++i)
	{
	  unsigned long mask = powerpc_operands[i].bitm;
	  unsigned long right_bit;
	  unsigned int j;

	  right_bit = mask & -mask;
	  mask += right_bit;
	  right_bit = mask & -mask;
	  if (mask != right_bit)
	    {
	      as_bad (_("powerpc_operands[%d].bitm invalid"), i);
	      bad_insn = TRUE;
	    }
	  for (j = i + 1; j < num_powerpc_operands; ++j)
	    if (memcmp (&powerpc_operands[i], &powerpc_operands[j],
			sizeof (powerpc_operands[0])) == 0)
	      {
		as_bad (_("powerpc_operands[%d] duplicates powerpc_operands[%d]"),
			j, i);
		bad_insn = TRUE;
	      }
	}
    }

  op_end = powerpc_opcodes + powerpc_num_opcodes;
  for (op = powerpc_opcodes; op < op_end; op++)
    {
      if (ENABLE_CHECKING)
	{
	  if (op != powerpc_opcodes)
	    {
	      int old_opcode = PPC_OP (op[-1].opcode);
	      int new_opcode = PPC_OP (op[0].opcode);

#ifdef PRINT_OPCODE_TABLE
	      printf ("%-14s\t#%04u\tmajor op: 0x%x\top: 0x%x\tmask: 0x%x\tflags: 0x%llx\n",
		      op->name, (unsigned int) (op - powerpc_opcodes),
		      (unsigned int) new_opcode, (unsigned int) op->opcode,
		      (unsigned int) op->mask, (unsigned long long) op->flags);
#endif

	      /* The major opcodes had better be sorted.  Code in the
		 disassembler assumes the insns are sorted according to
		 major opcode.  */
	      if (new_opcode < old_opcode)
		{
		  as_bad (_("major opcode is not sorted for %s"),
			  op->name);
		  bad_insn = TRUE;
		}
	    }
	  bad_insn |= insn_validate (op);
	}

      if ((ppc_cpu & op->flags) != 0
	  && !(ppc_cpu & op->deprecated))
	{
	  const char *retval;

	  retval = hash_insert (ppc_hash, op->name, (void *) op);
	  if (retval != NULL)
	    {
	      as_bad (_("duplicate instruction %s"),
		      op->name);
	      bad_insn = TRUE;
	    }
	}
    }

  if ((ppc_cpu & PPC_OPCODE_ANY) != 0)
    for (op = powerpc_opcodes; op < op_end; op++)
      hash_insert (ppc_hash, op->name, (void *) op);

  op_end = vle_opcodes + vle_num_opcodes;
  for (op = vle_opcodes; op < op_end; op++)
    {
      if (ENABLE_CHECKING)
	{
	  if (op != vle_opcodes)
	    {
	      unsigned old_seg, new_seg;

	      old_seg = VLE_OP (op[-1].opcode, op[-1].mask);
	      old_seg = VLE_OP_TO_SEG (old_seg);
	      new_seg = VLE_OP (op[0].opcode, op[0].mask);
	      new_seg = VLE_OP_TO_SEG (new_seg);

#ifdef PRINT_OPCODE_TABLE
	      printf ("%-14s\t#%04u\tmajor op: 0x%x\top: 0x%x\tmask: 0x%x\tflags: 0x%llx\n",
		      op->name, (unsigned int) (op - powerpc_opcodes),
		      (unsigned int) new_seg, (unsigned int) op->opcode,
		      (unsigned int) op->mask, (unsigned long long) op->flags);
#endif
	      /* The major opcodes had better be sorted.  Code in the
		 disassembler assumes the insns are sorted according to
		 major opcode.  */
	      if (new_seg < old_seg)
		{
		  as_bad (_("major opcode is not sorted for %s"),
			  op->name);
		  bad_insn = TRUE;
		}
	    }

	  bad_insn |= insn_validate (op);
	}

      if ((ppc_cpu & op->flags) != 0
	  && !(ppc_cpu & op->deprecated))
	{
	  const char *retval;

	  retval = hash_insert (ppc_hash, op->name, (void *) op);
	  if (retval != NULL)
	    {
	      as_bad (_("duplicate instruction %s"),
		      op->name);
	      bad_insn = TRUE;
	    }
	}
    }

  if ((ppc_cpu & PPC_OPCODE_VLE) != 0)
    for (op = vle_opcodes; op < op_end; op++)
      hash_insert (ppc_hash, op->name, (void *) op);

  /* Insert the macros into a hash table.  */
  ppc_macro_hash = hash_new ();

  macro_end = powerpc_macros + powerpc_num_macros;
  for (macro = powerpc_macros; macro < macro_end; macro++)
    {
      if ((macro->flags & ppc_cpu) != 0 || (ppc_cpu & PPC_OPCODE_ANY) != 0)
	{
	  const char *retval;

	  retval = hash_insert (ppc_macro_hash, macro->name, (void *) macro);
	  if (retval != (const char *) NULL)
	    {
	      as_bad (_("duplicate macro %s"), macro->name);
	      bad_insn = TRUE;
	    }
	}
    }

  if (bad_insn)
    abort ();
}

/* This function is called when the assembler starts up.  It is called
   after the options have been parsed and the output file has been
   opened.  */

void
md_begin (void)
{
  ppc_set_cpu ();

  ppc_cie_data_alignment = ppc_obj64 ? -8 : -4;
  ppc_dwarf2_line_min_insn_length = (ppc_cpu & PPC_OPCODE_VLE) ? 2 : 4;

#ifdef OBJ_ELF
  /* Set the ELF flags if desired.  */
  if (ppc_flags && !msolaris)
    bfd_set_private_flags (stdoutput, ppc_flags);
#endif

  ppc_setup_opcodes ();

  /* Tell the main code what the endianness is if it is not overridden
     by the user.  */
  if (!set_target_endian)
    {
      set_target_endian = 1;
      target_big_endian = PPC_BIG_ENDIAN;
    }

#ifdef OBJ_XCOFF
  ppc_coff_debug_section = coff_section_from_bfd_index (stdoutput, N_DEBUG);

  /* Create dummy symbols to serve as initial csects.  This forces the
     text csects to precede the data csects.  These symbols will not
     be output.  */
  ppc_text_csects = symbol_make ("dummy\001");
  symbol_get_tc (ppc_text_csects)->within = ppc_text_csects;
  ppc_data_csects = symbol_make ("dummy\001");
  symbol_get_tc (ppc_data_csects)->within = ppc_data_csects;
#endif

#ifdef TE_PE

  ppc_current_section = text_section;
  ppc_previous_section = 0;

#endif
}

void
ppc_cleanup (void)
{
#ifdef OBJ_ELF
  if (ppc_apuinfo_list == NULL)
    return;

  /* Ok, so write the section info out.  We have this layout:

  byte	data		what
  ----	----		----
  0	8		length of "APUinfo\0"
  4	(n*4)		number of APU's (4 bytes each)
  8	2		note type 2
  12	"APUinfo\0"	name
  20	APU#1		first APU's info
  24	APU#2		second APU's info
  ...	...
  */
  {
    char *p;
    asection *seg = now_seg;
    subsegT subseg = now_subseg;
    asection *apuinfo_secp = (asection *) NULL;
    unsigned int i;

    /* Create the .PPC.EMB.apuinfo section.  */
    apuinfo_secp = subseg_new (".PPC.EMB.apuinfo", 0);
    bfd_set_section_flags (stdoutput,
			   apuinfo_secp,
			   SEC_HAS_CONTENTS | SEC_READONLY);

    p = frag_more (4);
    md_number_to_chars (p, (valueT) 8, 4);

    p = frag_more (4);
    md_number_to_chars (p, (valueT) ppc_apuinfo_num * 4, 4);

    p = frag_more (4);
    md_number_to_chars (p, (valueT) 2, 4);

    p = frag_more (8);
    strcpy (p, "APUinfo");

    for (i = 0; i < ppc_apuinfo_num; i++)
      {
	p = frag_more (4);
	md_number_to_chars (p, (valueT) ppc_apuinfo_list[i], 4);
      }

    frag_align (2, 0, 0);

    /* We probably can't restore the current segment, for there likely
       isn't one yet...  */
    if (seg && subseg)
      subseg_set (seg, subseg);
  }
#endif
}

/* Insert an operand value into an instruction.  */

static unsigned long
ppc_insert_operand (unsigned long insn,
		    const struct powerpc_operand *operand,
		    offsetT val,
		    ppc_cpu_t cpu,
		    char *file,
		    unsigned int line)
{
  long min, max, right;

  max = operand->bitm;
  right = max & -max;
  min = 0;

  if ((operand->flags & PPC_OPERAND_SIGNED) != 0)
    {
      if ((operand->flags & PPC_OPERAND_SIGNOPT) == 0)
	max = (max >> 1) & -right;
      min = ~max & -right;
    }

  if ((operand->flags & PPC_OPERAND_PLUS1) != 0)
    max++;

  if ((operand->flags & PPC_OPERAND_NEGATIVE) != 0)
    {
      long tmp = min;
      min = -max;
      max = -tmp;
    }

  if (min <= max)
    {
      /* Some people write constants with the sign extension done by
	 hand but only up to 32 bits.  This shouldn't really be valid,
	 but, to permit this code to assemble on a 64-bit host, we
	 sign extend the 32-bit value to 64 bits if so doing makes the
	 value valid.  */
      if (val > max
	  && (offsetT) (val - 0x80000000 - 0x80000000) >= min
	  && (offsetT) (val - 0x80000000 - 0x80000000) <= max
	  && ((val - 0x80000000 - 0x80000000) & (right - 1)) == 0)
	val = val - 0x80000000 - 0x80000000;

      /* Similarly, people write expressions like ~(1<<15), and expect
	 this to be OK for a 32-bit unsigned value.  */
      else if (val < min
	       && (offsetT) (val + 0x80000000 + 0x80000000) >= min
	       && (offsetT) (val + 0x80000000 + 0x80000000) <= max
	       && ((val + 0x80000000 + 0x80000000) & (right - 1)) == 0)
	val = val + 0x80000000 + 0x80000000;

      else if (val < min
	       || val > max
	       || (val & (right - 1)) != 0)
	as_bad_value_out_of_range (_("operand"), val, min, max, file, line);
    }

  if (operand->insert)
    {
      const char *errmsg;

      errmsg = NULL;
      insn = (*operand->insert) (insn, (long) val, cpu, &errmsg);
      if (errmsg != (const char *) NULL)
	as_bad_where (file, line, "%s", errmsg);
    }
  else if (operand->shift >= 0)
    insn |= ((long) val & operand->bitm) << operand->shift;
  else
    insn |= ((long) val & operand->bitm) >> -operand->shift;

  return insn;
}


#ifdef OBJ_ELF
/* Parse @@got, etc. and return the desired relocation.  */
static bfd_reloc_code_real_type
ppc_elf_suffix (char **str_p, expressionS *exp_p)
{
  struct map_bfd {
    char *string;
    unsigned int length : 8;
    unsigned int valid32 : 1;
    unsigned int valid64 : 1;
    unsigned int reloc;
  };

  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;
  const struct map_bfd *ptr;

#define MAP(str, reloc)   { str, sizeof (str) - 1, 1, 1, reloc }
#define MAP32(str, reloc) { str, sizeof (str) - 1, 1, 0, reloc }
#define MAP64(str, reloc) { str, sizeof (str) - 1, 0, 1, reloc }

  static const struct map_bfd mapping[] = {
    MAP ("l",			BFD_RELOC_LO16),
    MAP ("h",			BFD_RELOC_HI16),
    MAP ("ha",			BFD_RELOC_HI16_S),
    MAP ("brtaken",		BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",		BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",			BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",		BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",		BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",		BFD_RELOC_HI16_S_GOTOFF),
    MAP ("plt@@l",		BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",		BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",		BFD_RELOC_HI16_S_PLTOFF),
    MAP ("copy",		BFD_RELOC_PPC_COPY),
    MAP ("globdat",		BFD_RELOC_PPC_GLOB_DAT),
    MAP ("sectoff",		BFD_RELOC_16_BASEREL),
    MAP ("sectoff@@l",		BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",		BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",		BFD_RELOC_HI16_S_BASEREL),
    MAP ("tls",			BFD_RELOC_PPC_TLS),
    MAP ("dtpmod",		BFD_RELOC_PPC_DTPMOD),
    MAP ("dtprel",		BFD_RELOC_PPC_DTPREL),
    MAP ("dtprel@@l",		BFD_RELOC_PPC_DTPREL16_LO),
    MAP ("dtprel@@h",		BFD_RELOC_PPC_DTPREL16_HI),
    MAP ("dtprel@@ha",		BFD_RELOC_PPC_DTPREL16_HA),
    MAP ("tprel",		BFD_RELOC_PPC_TPREL),
    MAP ("tprel@@l",		BFD_RELOC_PPC_TPREL16_LO),
    MAP ("tprel@@h",		BFD_RELOC_PPC_TPREL16_HI),
    MAP ("tprel@@ha",		BFD_RELOC_PPC_TPREL16_HA),
    MAP ("got@@tlsgd",		BFD_RELOC_PPC_GOT_TLSGD16),
    MAP ("got@@tlsgd@@l",		BFD_RELOC_PPC_GOT_TLSGD16_LO),
    MAP ("got@@tlsgd@@h",		BFD_RELOC_PPC_GOT_TLSGD16_HI),
    MAP ("got@@tlsgd@@ha",	BFD_RELOC_PPC_GOT_TLSGD16_HA),
    MAP ("got@@tlsld",		BFD_RELOC_PPC_GOT_TLSLD16),
    MAP ("got@@tlsld@@l",		BFD_RELOC_PPC_GOT_TLSLD16_LO),
    MAP ("got@@tlsld@@h",		BFD_RELOC_PPC_GOT_TLSLD16_HI),
    MAP ("got@@tlsld@@ha",	BFD_RELOC_PPC_GOT_TLSLD16_HA),
    MAP ("got@@dtprel",		BFD_RELOC_PPC_GOT_DTPREL16),
    MAP ("got@@dtprel@@l",	BFD_RELOC_PPC_GOT_DTPREL16_LO),
    MAP ("got@@dtprel@@h",	BFD_RELOC_PPC_GOT_DTPREL16_HI),
    MAP ("got@@dtprel@@ha",	BFD_RELOC_PPC_GOT_DTPREL16_HA),
    MAP ("got@@tprel",		BFD_RELOC_PPC_GOT_TPREL16),
    MAP ("got@@tprel@@l",		BFD_RELOC_PPC_GOT_TPREL16_LO),
    MAP ("got@@tprel@@h",		BFD_RELOC_PPC_GOT_TPREL16_HI),
    MAP ("got@@tprel@@ha",	BFD_RELOC_PPC_GOT_TPREL16_HA),
    MAP32 ("fixup",		BFD_RELOC_CTOR),
    MAP32 ("plt",		BFD_RELOC_24_PLT_PCREL),
    MAP32 ("pltrel24",		BFD_RELOC_24_PLT_PCREL),
    MAP32 ("local24pc",		BFD_RELOC_PPC_LOCAL24PC),
    MAP32 ("local",		BFD_RELOC_PPC_LOCAL24PC),
    MAP32 ("pltrel",		BFD_RELOC_32_PLT_PCREL),
    MAP32 ("sdarel",		BFD_RELOC_GPREL16),
    MAP32 ("sdarel@@l",		BFD_RELOC_PPC_VLE_SDAREL_LO16A),
    MAP32 ("sdarel@@h",		BFD_RELOC_PPC_VLE_SDAREL_HI16A),
    MAP32 ("sdarel@@ha",		BFD_RELOC_PPC_VLE_SDAREL_HA16A),
    MAP32 ("naddr",		BFD_RELOC_PPC_EMB_NADDR32),
    MAP32 ("naddr16",		BFD_RELOC_PPC_EMB_NADDR16),
    MAP32 ("naddr@@l",		BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP32 ("naddr@@h",		BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP32 ("naddr@@ha",		BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP32 ("sdai16",		BFD_RELOC_PPC_EMB_SDAI16),
    MAP32 ("sda2rel",		BFD_RELOC_PPC_EMB_SDA2REL),
    MAP32 ("sda2i16",		BFD_RELOC_PPC_EMB_SDA2I16),
    MAP32 ("sda21",		BFD_RELOC_PPC_EMB_SDA21),
    MAP32 ("sda21@@l",		BFD_RELOC_PPC_VLE_SDA21_LO),
    MAP32 ("mrkref",		BFD_RELOC_PPC_EMB_MRKREF),
    MAP32 ("relsect",		BFD_RELOC_PPC_EMB_RELSEC16),
    MAP32 ("relsect@@l",		BFD_RELOC_PPC_EMB_RELST_LO),
    MAP32 ("relsect@@h",		BFD_RELOC_PPC_EMB_RELST_HI),
    MAP32 ("relsect@@ha",	BFD_RELOC_PPC_EMB_RELST_HA),
    MAP32 ("bitfld",		BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP32 ("relsda",		BFD_RELOC_PPC_EMB_RELSDA),
    MAP32 ("xgot",		BFD_RELOC_PPC_TOC16),
    MAP64 ("higher",		BFD_RELOC_PPC64_HIGHER),
    MAP64 ("highera",		BFD_RELOC_PPC64_HIGHER_S),
    MAP64 ("highest",		BFD_RELOC_PPC64_HIGHEST),
    MAP64 ("highesta",		BFD_RELOC_PPC64_HIGHEST_S),
    MAP64 ("tocbase",		BFD_RELOC_PPC64_TOC),
    MAP64 ("toc",		BFD_RELOC_PPC_TOC16),
    MAP64 ("toc@@l",		BFD_RELOC_PPC64_TOC16_LO),
    MAP64 ("toc@@h",		BFD_RELOC_PPC64_TOC16_HI),
    MAP64 ("toc@@ha",		BFD_RELOC_PPC64_TOC16_HA),
    MAP64 ("dtprel@@higher",	BFD_RELOC_PPC64_DTPREL16_HIGHER),
    MAP64 ("dtprel@@highera",	BFD_RELOC_PPC64_DTPREL16_HIGHERA),
    MAP64 ("dtprel@@highest",	BFD_RELOC_PPC64_DTPREL16_HIGHEST),
    MAP64 ("dtprel@@highesta",	BFD_RELOC_PPC64_DTPREL16_HIGHESTA),
    MAP64 ("tprel@@higher",	BFD_RELOC_PPC64_TPREL16_HIGHER),
    MAP64 ("tprel@@highera",	BFD_RELOC_PPC64_TPREL16_HIGHERA),
    MAP64 ("tprel@@highest",	BFD_RELOC_PPC64_TPREL16_HIGHEST),
    MAP64 ("tprel@@highesta",	BFD_RELOC_PPC64_TPREL16_HIGHESTA),
    { (char *) 0, 0, 0, 0,	BFD_RELOC_UNUSED }
  };

  if (*str++ != '@@')
    return BFD_RELOC_UNUSED;

  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
	&& (ISALNUM (ch) || ch == '@@'));
       ch = *++str)
    {
      *str2++ = TOLOWER (ch);
    }

  *str2 = '\0';
  len = str2 - ident;

  ch = ident[0];
  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (ch == ptr->string[0]
	&& len == ptr->length
	&& memcmp (ident, ptr->string, ptr->length) == 0
	&& (ppc_obj64 ? ptr->valid64 : ptr->valid32))
      {
	int reloc = ptr->reloc;

	if (!ppc_obj64 && exp_p->X_add_number != 0)
	  {
	    switch (reloc)
	      {
	      case BFD_RELOC_16_GOTOFF:
	      case BFD_RELOC_LO16_GOTOFF:
	      case BFD_RELOC_HI16_GOTOFF:
	      case BFD_RELOC_HI16_S_GOTOFF:
		as_warn (_("identifier+constant@@got means "
			   "identifier@@got+constant"));
		break;

	      case BFD_RELOC_PPC_GOT_TLSGD16:
	      case BFD_RELOC_PPC_GOT_TLSGD16_LO:
	      case BFD_RELOC_PPC_GOT_TLSGD16_HI:
	      case BFD_RELOC_PPC_GOT_TLSGD16_HA:
	      case BFD_RELOC_PPC_GOT_TLSLD16:
	      case BFD_RELOC_PPC_GOT_TLSLD16_LO:
	      case BFD_RELOC_PPC_GOT_TLSLD16_HI:
	      case BFD_RELOC_PPC_GOT_TLSLD16_HA:
	      case BFD_RELOC_PPC_GOT_DTPREL16:
	      case BFD_RELOC_PPC_GOT_DTPREL16_LO:
	      case BFD_RELOC_PPC_GOT_DTPREL16_HI:
	      case BFD_RELOC_PPC_GOT_DTPREL16_HA:
	      case BFD_RELOC_PPC_GOT_TPREL16:
	      case BFD_RELOC_PPC_GOT_TPREL16_LO:
	      case BFD_RELOC_PPC_GOT_TPREL16_HI:
	      case BFD_RELOC_PPC_GOT_TPREL16_HA:
		as_bad (_("symbol+offset not supported for got tls"));
		break;
	      }
	  }

	/* Now check for identifier@@suffix+constant.  */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;

	    input_line_pointer = str;
	    expression (&new_exp);
	    if (new_exp.X_op == O_constant)
	      {
		exp_p->X_add_number += new_exp.X_add_number;
		str = input_line_pointer;
	      }

	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }
	*str_p = str;

	if (reloc == (int) BFD_RELOC_PPC64_TOC
	    && exp_p->X_op == O_symbol
	    && strcmp (S_GET_NAME (exp_p->X_add_symbol), ".TOC.") == 0)
	  {
	    /* Change the symbol so that the dummy .TOC. symbol can be
	       omitted from the object file.  */
	    exp_p->X_add_symbol = &abs_symbol;
	  }

	return (bfd_reloc_code_real_type) reloc;
      }

  return BFD_RELOC_UNUSED;
}

/* Like normal .long/.short/.word, except support @@got, etc.
   Clobbers input_line_pointer, checks end-of-line.  */
static void
ppc_elf_cons (int nbytes /* 1=.byte, 2=.word, 4=.long, 8=.llong */)
{
  expressionS exp;
  bfd_reloc_code_real_type reloc;

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);
      if (*input_line_pointer == '@@'
	  && (reloc = ppc_elf_suffix (&input_line_pointer,
				      &exp)) != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto;
	  int size;

	  reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  size = bfd_get_reloc_size (reloc_howto);

	  if (size > nbytes)
	    {
	      as_bad (_("%s relocations do not fit in %d bytes\n"),
		      reloc_howto->name, nbytes);
	    }
	  else
	    {
	      char *p;
	      int offset;

	      p = frag_more (nbytes);
	      memset (p, 0, nbytes);
	      offset = 0;
	      if (target_big_endian)
		offset = nbytes - size;
	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  input_line_pointer--;
  demand_empty_rest_of_line ();
}

/* Solaris pseduo op to change to the .rodata section.  */
static void
ppc_elf_rdata (int xxx)
{
  char *save_line = input_line_pointer;
  static char section[] = ".rodata\n";

  /* Just pretend this is .section .rodata  */
  input_line_pointer = section;
  obj_elf_section (xxx);

  input_line_pointer = save_line;
}

/* Pseudo op to make file scope bss items.  */
static void
ppc_elf_lcomm (int xxx ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char *p;
  offsetT size;
  symbolS *symbolP;
  offsetT align;
  segT old_sec;
  int old_subsec;
  char *pfrag;
  int align2;

  name = input_line_pointer;
  c = get_symbol_end ();

  /* just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after symbol-name: rest of line ignored."));
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ',' */
  if ((size = get_absolute_expression ()) < 0)
    {
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) size);
      ignore_rest_of_line ();
      return;
    }

  /* The third argument to .lcomm is the alignment.  */
  if (*input_line_pointer != ',')
    align = 8;
  else
    {
      ++input_line_pointer;
      align = get_absolute_expression ();
      if (align <= 0)
	{
	  as_warn (_("ignoring bad alignment"));
	  align = 8;
	}
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("ignoring attempt to re-define symbol `%s'."),
	      S_GET_NAME (symbolP));
      ignore_rest_of_line ();
      return;
    }

  if (S_GET_VALUE (symbolP) && S_GET_VALUE (symbolP) != (valueT) size)
    {
      as_bad (_("length of .lcomm \"%s\" is already %ld. Not changed to %ld."),
	      S_GET_NAME (symbolP),
	      (long) S_GET_VALUE (symbolP),
	      (long) size);

      ignore_rest_of_line ();
      return;
    }

  /* Allocate_bss.  */
  old_sec = now_seg;
  old_subsec = now_subseg;
  if (align)
    {
      /* Convert to a power of 2 alignment.  */
      for (align2 = 0; (align & 1) == 0; align >>= 1, ++align2);
      if (align != 1)
	{
	  as_bad (_("common alignment not a power of 2"));
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    align2 = 0;

  record_alignment (bss_section, align2);
  subseg_set (bss_section, 1);
  if (align2)
    frag_align (align2, 0, 0);
  if (S_GET_SEGMENT (symbolP) == bss_section)
    symbol_get_frag (symbolP)->fr_symbol = 0;
  symbol_set_frag (symbolP, frag_now);
  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP, size,
		    (char *) 0);
  *pfrag = 0;
  S_SET_SIZE (symbolP, size);
  S_SET_SEGMENT (symbolP, bss_section);
  subseg_set (old_sec, old_subsec);
  demand_empty_rest_of_line ();
}

/* Validate any relocations emitted for -mrelocatable, possibly adding
   fixups for word relocations in writable segments, so we can adjust
   them at runtime.  */
static void
ppc_elf_validate_fix (fixS *fixp, segT seg)
{
  if (fixp->fx_done || fixp->fx_pcrel)
    return;

  switch (shlib)
    {
    case SHLIB_NONE:
    case SHLIB_PIC:
      return;

    case SHLIB_MRELOCATABLE:
      if (fixp->fx_r_type <= BFD_RELOC_UNUSED
	  && fixp->fx_r_type != BFD_RELOC_16_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_HI16_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_LO16_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_HI16_S_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_16_BASEREL
	  && fixp->fx_r_type != BFD_RELOC_LO16_BASEREL
	  && fixp->fx_r_type != BFD_RELOC_HI16_BASEREL
	  && fixp->fx_r_type != BFD_RELOC_HI16_S_BASEREL
	  && (seg->flags & SEC_LOAD) != 0
	  && strcmp (segment_name (seg), ".got2") != 0
	  && strcmp (segment_name (seg), ".dtors") != 0
	  && strcmp (segment_name (seg), ".ctors") != 0
	  && strcmp (segment_name (seg), ".fixup") != 0
	  && strcmp (segment_name (seg), ".gcc_except_table") != 0
	  && strcmp (segment_name (seg), ".eh_frame") != 0
	  && strcmp (segment_name (seg), ".ex_shared") != 0)
	{
	  if ((seg->flags & (SEC_READONLY | SEC_CODE)) != 0
	      || fixp->fx_r_type != BFD_RELOC_CTOR)
	    {
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("relocation cannot be done when using -mrelocatable"));
	    }
	}
      return;
    }
}

/* Prevent elf_frob_file_before_adjust removing a weak undefined
   function descriptor sym if the corresponding code sym is used.  */

void
ppc_frob_file_before_adjust (void)
{
  symbolS *symp;
  asection *toc;

  if (!ppc_obj64)
    return;

  for (symp = symbol_rootP; symp; symp = symbol_next (symp))
    {
      const char *name;
      char *dotname;
      symbolS *dotsym;
      size_t len;

      name = S_GET_NAME (symp);
      if (name[0] == '.')
	continue;

      if (! S_IS_WEAK (symp)
	  || S_IS_DEFINED (symp))
	continue;

      len = strlen (name) + 1;
      dotname = xmalloc (len + 1);
      dotname[0] = '.';
      memcpy (dotname + 1, name, len);
      dotsym = symbol_find_noref (dotname, 1);
      free (dotname);
      if (dotsym != NULL && (symbol_used_p (dotsym)
			     || symbol_used_in_reloc_p (dotsym)))
	symbol_mark_used (symp);

    }

  toc = bfd_get_section_by_name (stdoutput, ".toc");
  if (toc != NULL
      && toc_reloc_types != has_large_toc_reloc
      && bfd_section_size (stdoutput, toc) > 0x10000)
    as_warn (_("TOC section size exceeds 64k"));
}

/* .TOC. used in an opd entry as .TOC.@@tocbase doesn't need to be
   emitted.  Other uses of .TOC. will cause the symbol to be marked
   with BSF_KEEP in md_apply_fix.  */

void
ppc_elf_adjust_symtab (void)
{
  if (ppc_obj64)
    {
      symbolS *symp;
      symp = symbol_find (".TOC.");
      if (symp != NULL)
	{
	  asymbol *bsym = symbol_get_bfdsym (symp);
	  if ((bsym->flags & BSF_KEEP) == 0)
	    symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	}
    }
}
#endif /* OBJ_ELF */

#ifdef TE_PE

/*
 * Summary of parse_toc_entry.
 *
 * in:	Input_line_pointer points to the '[' in one of:
 *
 *        [toc] [tocv] [toc32] [toc64]
 *
 *      Anything else is an error of one kind or another.
 *
 * out:
 *   return value: success or failure
 *   toc_kind:     kind of toc reference
 *   input_line_pointer:
 *     success: first char after the ']'
 *     failure: unchanged
 *
 * settings:
 *
 *     [toc]   - rv == success, toc_kind = default_toc
 *     [tocv]  - rv == success, toc_kind = data_in_toc
 *     [toc32] - rv == success, toc_kind = must_be_32
 *     [toc64] - rv == success, toc_kind = must_be_64
 *
 */

enum toc_size_qualifier
{
  default_toc, /* The toc cell constructed should be the system default size */
  data_in_toc, /* This is a direct reference to a toc cell                   */
  must_be_32,  /* The toc cell constructed must be 32 bits wide              */
  must_be_64   /* The toc cell constructed must be 64 bits wide              */
};

static int
parse_toc_entry (enum toc_size_qualifier *toc_kind)
{
  char *start;
  char *toc_spec;
  char c;
  enum toc_size_qualifier t;

  /* Save the input_line_pointer.  */
  start = input_line_pointer;

  /* Skip over the '[' , and whitespace.  */
  ++input_line_pointer;
  SKIP_WHITESPACE ();

  /* Find the spelling of the operand.  */
  toc_spec = input_line_pointer;
  c = get_symbol_end ();

  if (strcmp (toc_spec, "toc") == 0)
    {
      t = default_toc;
    }
  else if (strcmp (toc_spec, "tocv") == 0)
    {
      t = data_in_toc;
    }
  else if (strcmp (toc_spec, "toc32") == 0)
    {
      t = must_be_32;
    }
  else if (strcmp (toc_spec, "toc64") == 0)
    {
      t = must_be_64;
    }
  else
    {
      as_bad (_("syntax error: invalid toc specifier `%s'"), toc_spec);
      *input_line_pointer = c;
      input_line_pointer = start;
      return 0;
    }

  /* Now find the ']'.  */
  *input_line_pointer = c;

  SKIP_WHITESPACE ();	     /* leading whitespace could be there.  */
  c = *input_line_pointer++; /* input_line_pointer->past char in c.  */

  if (c != ']')
    {
      as_bad (_("syntax error: expected `]', found  `%c'"), c);
      input_line_pointer = start;
      return 0;
    }

  *toc_kind = t;
  return 1;
}
#endif

#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
/* See whether a symbol is in the TOC section.  */

static int
ppc_is_toc_sym (symbolS *sym)
{
#ifdef OBJ_XCOFF
  return (symbol_get_tc (sym)->symbol_class == XMC_TC
	  || symbol_get_tc (sym)->symbol_class == XMC_TC0);
#endif
#ifdef OBJ_ELF
  const char *sname = segment_name (S_GET_SEGMENT (sym));
  if (ppc_obj64)
    return strcmp (sname, ".toc") == 0;
  else
    return strcmp (sname, ".got") == 0;
#endif
}
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */


#ifdef OBJ_ELF
#define APUID(a,v)	((((a) & 0xffff) << 16) | ((v) & 0xffff))
static void
ppc_apuinfo_section_add (unsigned int apu, unsigned int version)
{
  unsigned int i;

  /* Check we don't already exist.  */
  for (i = 0; i < ppc_apuinfo_num; i++)
    if (ppc_apuinfo_list[i] == APUID (apu, version))
      return;

  if (ppc_apuinfo_num == ppc_apuinfo_num_alloc)
    {
      if (ppc_apuinfo_num_alloc == 0)
	{
	  ppc_apuinfo_num_alloc = 4;
	  ppc_apuinfo_list = (unsigned long *)
	      xmalloc (sizeof (unsigned long) * ppc_apuinfo_num_alloc);
	}
      else
	{
	  ppc_apuinfo_num_alloc += 4;
	  ppc_apuinfo_list = (unsigned long *) xrealloc (ppc_apuinfo_list,
	      sizeof (unsigned long) * ppc_apuinfo_num_alloc);
	}
    }
  ppc_apuinfo_list[ppc_apuinfo_num++] = APUID (apu, version);
}
#undef APUID
#endif


/* We need to keep a list of fixups.  We can't simply generate them as
   we go, because that would require us to first create the frag, and
   that would screw up references to ``.''.  */

struct ppc_fixup
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};

#define MAX_INSN_FIXUPS (5)

/* Form I16L.  */
#define E_OR2I_INSN		0x7000C000
#define E_AND2I_DOT_INSN	0x7000C800
#define E_OR2IS_INSN		0x7000D000
#define E_LIS_INSN		0x7000E000
#define	E_AND2IS_DOT_INSN	0x7000E800

/* Form I16A.  */
#define E_ADD2I_DOT_INSN	0x70008800
#define E_ADD2IS_INSN		0x70009000
#define E_CMP16I_INSN		0x70009800
#define E_MULL2I_INSN		0x7000A000
#define E_CMPL16I_INSN		0x7000A800
#define E_CMPH16I_INSN		0x7000B000
#define E_CMPHL16I_INSN		0x7000B800

/* This routine is called for each instruction to be assembled.  */

void
md_assemble (char *str)
{
  char *s;
  const struct powerpc_opcode *opcode;
  unsigned long insn;
  const unsigned char *opindex_ptr;
  int skip_optional;
  int need_paren;
  int next_opindex;
  struct ppc_fixup fixups[MAX_INSN_FIXUPS];
  int fc;
  char *f;
  int addr_mod;
  int i;
  unsigned int insn_length;

  /* Get the opcode.  */
  for (s = str; *s != '\0' && ! ISSPACE (*s); s++)
    ;
  if (*s != '\0')
    *s++ = '\0';

  /* Look up the opcode in the hash table.  */
  opcode = (const struct powerpc_opcode *) hash_find (ppc_hash, str);
  if (opcode == (const struct powerpc_opcode *) NULL)
    {
      const struct powerpc_macro *macro;

      macro = (const struct powerpc_macro *) hash_find (ppc_macro_hash, str);
      if (macro == (const struct powerpc_macro *) NULL)
	as_bad (_("unrecognized opcode: `%s'"), str);
      else
	ppc_macro (s, macro);

      return;
    }

  insn = opcode->opcode;

  str = s;
  while (ISSPACE (*str))
    ++str;

  /* PowerPC operands are just expressions.  The only real issue is
     that a few operand types are optional.  All cases which might use
     an optional operand separate the operands only with commas (in some
     cases parentheses are used, as in ``lwz 1,0(1)'' but such cases never
     have optional operands).  Most instructions with optional operands
     have only one.  Those that have more than one optional operand can
     take either all their operands or none.  So, before we start seriously
     parsing the operands, we check to see if we have optional operands,
     and if we do, we count the number of commas to see which operands
     have been omitted.  */
  skip_optional = 0;
  for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
    {
      const struct powerpc_operand *operand;

      operand = &powerpc_operands[*opindex_ptr];
      if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0)
	{
	  unsigned int opcount;
	  unsigned int num_operands_expected;

	  /* There is an optional operand.  Count the number of
	     commas in the input line.  */
	  if (*str == '\0')
	    opcount = 0;
	  else
	    {
	      opcount = 1;
	      s = str;
	      while ((s = strchr (s, ',')) != (char *) NULL)
		{
		  ++opcount;
		  ++s;
		}
	    }

	  /* Compute the number of expected operands.
	     Do not count fake operands.  */
	  for (num_operands_expected = 0, i = 0; opcode->operands[i]; i ++)
	    if ((powerpc_operands [opcode->operands[i]].flags & PPC_OPERAND_FAKE) == 0)
	      ++ num_operands_expected;

	  /* If there are fewer operands in the line then are called
	     for by the instruction, we want to skip the optional
	     operands.  */
	  if (opcount < num_operands_expected)
	    skip_optional = 1;

	  break;
	}
    }

  /* Gather the operands.  */
  need_paren = 0;
  next_opindex = 0;
  fc = 0;
  for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
    {
      const struct powerpc_operand *operand;
      const char *errmsg;
      char *hold;
      expressionS ex;
      char endc;

      if (next_opindex == 0)
	operand = &powerpc_operands[*opindex_ptr];
      else
	{
	  operand = &powerpc_operands[next_opindex];
	  next_opindex = 0;
	}
      errmsg = NULL;

      /* If this is a fake operand, then we do not expect anything
	 from the input.  */
      if ((operand->flags & PPC_OPERAND_FAKE) != 0)
	{
	  insn = (*operand->insert) (insn, 0L, ppc_cpu, &errmsg);
	  if (errmsg != (const char *) NULL)
	    as_bad ("%s", errmsg);
	  continue;
	}

      /* If this is an optional operand, and we are skipping it, just
	 insert a zero.  */
      if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0
	  && skip_optional)
	{
	  if (operand->insert)
	    {
	      insn = (*operand->insert) (insn, 0L, ppc_cpu, &errmsg);
	      if (errmsg != (const char *) NULL)
		as_bad ("%s", errmsg);
	    }
	  if ((operand->flags & PPC_OPERAND_NEXT) != 0)
	    next_opindex = *opindex_ptr + 1;
	  continue;
	}

      /* Gather the operand.  */
      hold = input_line_pointer;
      input_line_pointer = str;

#ifdef TE_PE
      if (*input_line_pointer == '[')
	{
	  /* We are expecting something like the second argument here:
	   *
	   *    lwz r4,[toc].GS.0.static_int(rtoc)
	   *           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
	   * The argument following the `]' must be a symbol name, and the
	   * register must be the toc register: 'rtoc' or '2'
	   *
	   * The effect is to 0 as the displacement field
	   * in the instruction, and issue an IMAGE_REL_PPC_TOCREL16 (or
	   * the appropriate variation) reloc against it based on the symbol.
	   * The linker will build the toc, and insert the resolved toc offset.
	   *
	   * Note:
	   * o The size of the toc entry is currently assumed to be
	   *   32 bits. This should not be assumed to be a hard coded
	   *   number.
	   * o In an effort to cope with a change from 32 to 64 bits,
	   *   there are also toc entries that are specified to be
	   *   either 32 or 64 bits:
	   *     lwz r4,[toc32].GS.0.static_int(rtoc)
	   *     lwz r4,[toc64].GS.0.static_int(rtoc)
	   *   These demand toc entries of the specified size, and the
	   *   instruction probably requires it.
	   */

	  int valid_toc;
	  enum toc_size_qualifier toc_kind;
	  bfd_reloc_code_real_type toc_reloc;

	  /* Go parse off the [tocXX] part.  */
	  valid_toc = parse_toc_entry (&toc_kind);

	  if (!valid_toc)
	    {
	      ignore_rest_of_line ();
	      break;
	    }

	  /* Now get the symbol following the ']'.  */
	  expression (&ex);

	  switch (toc_kind)
	    {
	    case default_toc:
	      /* In this case, we may not have seen the symbol yet,
		 since  it is allowed to appear on a .extern or .globl
		 or just be a label in the .data section.  */
	      toc_reloc = BFD_RELOC_PPC_TOC16;
	      break;
	    case data_in_toc:
	      /* 1. The symbol must be defined and either in the toc
		 section, or a global.
		 2. The reloc generated must have the TOCDEFN flag set
		 in upper bit mess of the reloc type.
		 FIXME: It's a little confusing what the tocv
		 qualifier can be used for.  At the very least, I've
		 seen three uses, only one of which I'm sure I can
		 explain.  */
	      if (ex.X_op == O_symbol)
		{
		  gas_assert (ex.X_add_symbol != NULL);
		  if (symbol_get_bfdsym (ex.X_add_symbol)->section
		      != tocdata_section)
		    {
		      as_bad (_("[tocv] symbol is not a toc symbol"));
		    }
		}

	      toc_reloc = BFD_RELOC_PPC_TOC16;
	      break;
	    case must_be_32:
	      /* FIXME: these next two specifically specify 32/64 bit
		 toc entries.  We don't support them today.  Is this
		 the right way to say that?  */
	      toc_reloc = BFD_RELOC_UNUSED;
	      as_bad (_("unimplemented toc32 expression modifier"));
	      break;
	    case must_be_64:
	      /* FIXME: see above.  */
	      toc_reloc = BFD_RELOC_UNUSED;
	      as_bad (_("unimplemented toc64 expression modifier"));
	      break;
	    default:
	      fprintf (stderr,
		       _("Unexpected return value [%d] from parse_toc_entry!\n"),
		       toc_kind);
	      abort ();
	      break;
	    }

	  /* We need to generate a fixup for this expression.  */
	  if (fc >= MAX_INSN_FIXUPS)
	    as_fatal (_("too many fixups"));

	  fixups[fc].reloc = toc_reloc;
	  fixups[fc].exp = ex;
	  fixups[fc].opindex = *opindex_ptr;
	  ++fc;

	  /* Ok. We've set up the fixup for the instruction. Now make it
	     look like the constant 0 was found here.  */
	  ex.X_unsigned = 1;
	  ex.X_op = O_constant;
	  ex.X_add_number = 0;
	  ex.X_add_symbol = NULL;
	  ex.X_op_symbol = NULL;
	}

      else
#endif		/* TE_PE */
	{
	  if ((reg_names_p
               && (((operand->flags & PPC_OPERAND_CR_BIT) != 0)
		   || ((operand->flags & PPC_OPERAND_CR_REG) != 0)))
	      || !register_name (&ex))
	    {
	      char save_lex = lex_type['%'];

	      if (((operand->flags & PPC_OPERAND_CR_REG) != 0)
		  || (operand->flags & PPC_OPERAND_CR_BIT) != 0)
		{
		  cr_operand = TRUE;
		  lex_type['%'] |= LEX_BEGIN_NAME;
		}
	      expression (&ex);
	      cr_operand = FALSE;
	      lex_type['%'] = save_lex;
	    }
	}

      str = input_line_pointer;
      input_line_pointer = hold;

      if (ex.X_op == O_illegal)
	as_bad (_("illegal operand"));
      else if (ex.X_op == O_absent)
	as_bad (_("missing operand"));
      else if (ex.X_op == O_register)
	{
	  insn = ppc_insert_operand (insn, operand, ex.X_add_number,
				     ppc_cpu, (char *) NULL, 0);
	}
      else if (ex.X_op == O_constant)
	{
#ifdef OBJ_ELF
	  /* Allow @@HA, @@L, @@H on constants.  */
	  bfd_reloc_code_real_type reloc;
	  char *orig_str = str;

	  if ((reloc = ppc_elf_suffix (&str, &ex)) != BFD_RELOC_UNUSED)
	    switch (reloc)
	      {
	      default:
		str = orig_str;
		break;

	      case BFD_RELOC_LO16:
		/* X_unsigned is the default, so if the user has done
		   something which cleared it, we always produce a
		   signed value.  */
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number &= 0xffff;
		else
		  ex.X_add_number = SEX16 (ex.X_add_number);
		break;

	      case BFD_RELOC_HI16:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HI (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HI (ex.X_add_number));
		break;

	      case BFD_RELOC_HI16_S:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HA (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HA (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHER:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHER (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHER (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHER_S:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHERA (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHERA (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHEST:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHEST (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHEST (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHEST_S:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHESTA (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHESTA (ex.X_add_number));
		break;
	      }
#endif /* OBJ_ELF */
	  insn = ppc_insert_operand (insn, operand, ex.X_add_number,
				     ppc_cpu, (char *) NULL, 0);
	}
      else
	{
	  bfd_reloc_code_real_type reloc = BFD_RELOC_UNUSED;
#ifdef OBJ_ELF
	  if (ex.X_op == O_symbol && str[0] == '(')
	    {
	      const char *sym_name = S_GET_NAME (ex.X_add_symbol);
	      if (sym_name[0] == '.')
		++sym_name;

	      if (strcasecmp (sym_name, "__tls_get_addr") == 0)
		{
		  expressionS tls_exp;

		  hold = input_line_pointer;
		  input_line_pointer = str + 1;
		  expression (&tls_exp);
		  if (tls_exp.X_op == O_symbol)
		    {
		      reloc = BFD_RELOC_UNUSED;
		      if (strncasecmp (input_line_pointer, "@@tlsgd)", 7) == 0)
			{
			  reloc = BFD_RELOC_PPC_TLSGD;
			  input_line_pointer += 7;
			}
		      else if (strncasecmp (input_line_pointer, "@@tlsld)", 7) == 0)
			{
			  reloc = BFD_RELOC_PPC_TLSLD;
			  input_line_pointer += 7;
			}
		      if (reloc != BFD_RELOC_UNUSED)
			{
			  SKIP_WHITESPACE ();
			  str = input_line_pointer;

			  if (fc >= MAX_INSN_FIXUPS)
			    as_fatal (_("too many fixups"));
			  fixups[fc].exp = tls_exp;
			  fixups[fc].opindex = *opindex_ptr;
			  fixups[fc].reloc = reloc;
			  ++fc;
			}
		    }
		  input_line_pointer = hold;
		}
	    }

	  if ((reloc = ppc_elf_suffix (&str, &ex)) != BFD_RELOC_UNUSED)
	    {
	      /* Some TLS tweaks.  */
	      switch (reloc)
		{
		default:
		  break;

		case BFD_RELOC_PPC_TLS:
		  if (!_bfd_elf_ppc_at_tls_transform (opcode->opcode, 0))
		    as_bad (_("@@tls may not be used with \"%s\" operands"),
			    opcode->name);
		  else if (operand->shift != 11)
		    as_bad (_("@@tls may only be used in last operand"));
		  else
		    insn = ppc_insert_operand (insn, operand,
					       ppc_obj64 ? 13 : 2,
					       ppc_cpu, (char *) NULL, 0);
		  break;

		  /* We'll only use the 32 (or 64) bit form of these relocations
		     in constants.  Instructions get the 16 bit form.  */
		case BFD_RELOC_PPC_DTPREL:
		  reloc = BFD_RELOC_PPC_DTPREL16;
		  break;
		case BFD_RELOC_PPC_TPREL:
		  reloc = BFD_RELOC_PPC_TPREL16;
		  break;
		}

	      /* If VLE-mode convert LO/HI/HA relocations.  */
      	      if (opcode->flags & PPC_OPCODE_VLE)
		{
		  int tmp_insn = insn & opcode->mask;
		  
		  int use_d_reloc = (tmp_insn == E_OR2I_INSN
				     || tmp_insn == E_AND2I_DOT_INSN
				     || tmp_insn == E_OR2IS_INSN
				     || tmp_insn == E_LIS_INSN
				     || tmp_insn == E_AND2IS_DOT_INSN);


		  int use_a_reloc = (tmp_insn == E_ADD2I_DOT_INSN
				     || tmp_insn == E_ADD2IS_INSN
				     || tmp_insn == E_CMP16I_INSN
				     || tmp_insn == E_MULL2I_INSN
				     || tmp_insn == E_CMPL16I_INSN
				     || tmp_insn == E_CMPH16I_INSN
				     || tmp_insn == E_CMPHL16I_INSN);

		  switch (reloc)
		    {
		    default:
		      break;

		    case BFD_RELOC_PPC_EMB_SDA21:
		      reloc = BFD_RELOC_PPC_VLE_SDA21;
		      break;

		    case BFD_RELOC_LO16:
		      if (use_d_reloc)
			reloc = BFD_RELOC_PPC_VLE_LO16D;
		      else if (use_a_reloc)
			reloc = BFD_RELOC_PPC_VLE_LO16A;
		      break;

		    case BFD_RELOC_HI16:
		      if (use_d_reloc)
			reloc = BFD_RELOC_PPC_VLE_HI16D;
		      else if (use_a_reloc)
			reloc = BFD_RELOC_PPC_VLE_HI16A;
		      break;
	 
		    case BFD_RELOC_HI16_S:
		      if (use_d_reloc)
			reloc = BFD_RELOC_PPC_VLE_HA16D;
		      else if (use_a_reloc)
			reloc = BFD_RELOC_PPC_VLE_HA16A;
		      break;

		    case BFD_RELOC_PPC_VLE_SDAREL_LO16A:
		      if (use_d_reloc)
			reloc = BFD_RELOC_PPC_VLE_SDAREL_LO16D;
		      break;

		    case BFD_RELOC_PPC_VLE_SDAREL_HI16A:
		      if (use_d_reloc)
			reloc = BFD_RELOC_PPC_VLE_SDAREL_HI16D;
		      break;

		    case BFD_RELOC_PPC_VLE_SDAREL_HA16A:
		      if (use_d_reloc)
			reloc = BFD_RELOC_PPC_VLE_SDAREL_HA16D;
		      break;
		    }
		}

	      /* For the absolute forms of branches, convert the PC
		 relative form back into the absolute.  */
	      if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
		{
		  switch (reloc)
		    {
		    case BFD_RELOC_PPC_B26:
		      reloc = BFD_RELOC_PPC_BA26;
		      break;
		    case BFD_RELOC_PPC_B16:
		      reloc = BFD_RELOC_PPC_BA16;
		      break;
		    case BFD_RELOC_PPC_B16_BRTAKEN:
		      reloc = BFD_RELOC_PPC_BA16_BRTAKEN;
		      break;
		    case BFD_RELOC_PPC_B16_BRNTAKEN:
		      reloc = BFD_RELOC_PPC_BA16_BRNTAKEN;
		      break;
		    default:
		      break;
		    }
		}

	      switch (reloc)
		{
		case BFD_RELOC_PPC_TOC16:
		  toc_reloc_types |= has_small_toc_reloc;
		  break;
		case BFD_RELOC_PPC64_TOC16_LO:
		case BFD_RELOC_PPC64_TOC16_HI:
		case BFD_RELOC_PPC64_TOC16_HA:
		  toc_reloc_types |= has_large_toc_reloc;
		  break;
		default:
		  break;
		}

	      if ((operand->flags & (PPC_OPERAND_DS | PPC_OPERAND_DQ)) != 0)
		{
		  switch (reloc)
		    {
		    case BFD_RELOC_16:
		      reloc = BFD_RELOC_PPC64_ADDR16_DS;
		      break;
		    case BFD_RELOC_LO16:
		      reloc = BFD_RELOC_PPC64_ADDR16_LO_DS;
		      break;
		    case BFD_RELOC_16_GOTOFF:
		      reloc = BFD_RELOC_PPC64_GOT16_DS;
		      break;
		    case BFD_RELOC_LO16_GOTOFF:
		      reloc = BFD_RELOC_PPC64_GOT16_LO_DS;
		      break;
		    case BFD_RELOC_LO16_PLTOFF:
		      reloc = BFD_RELOC_PPC64_PLT16_LO_DS;
		      break;
		    case BFD_RELOC_16_BASEREL:
		      reloc = BFD_RELOC_PPC64_SECTOFF_DS;
		      break;
		    case BFD_RELOC_LO16_BASEREL:
		      reloc = BFD_RELOC_PPC64_SECTOFF_LO_DS;
		      break;
		    case BFD_RELOC_PPC_TOC16:
		      reloc = BFD_RELOC_PPC64_TOC16_DS;
		      break;
		    case BFD_RELOC_PPC64_TOC16_LO:
		      reloc = BFD_RELOC_PPC64_TOC16_LO_DS;
		      break;
		    case BFD_RELOC_PPC64_PLTGOT16:
		      reloc = BFD_RELOC_PPC64_PLTGOT16_DS;
		      break;
		    case BFD_RELOC_PPC64_PLTGOT16_LO:
		      reloc = BFD_RELOC_PPC64_PLTGOT16_LO_DS;
		      break;
		    case BFD_RELOC_PPC_DTPREL16:
		      reloc = BFD_RELOC_PPC64_DTPREL16_DS;
		      break;
		    case BFD_RELOC_PPC_DTPREL16_LO:
		      reloc = BFD_RELOC_PPC64_DTPREL16_LO_DS;
		      break;
		    case BFD_RELOC_PPC_TPREL16:
		      reloc = BFD_RELOC_PPC64_TPREL16_DS;
		      break;
		    case BFD_RELOC_PPC_TPREL16_LO:
		      reloc = BFD_RELOC_PPC64_TPREL16_LO_DS;
		      break;
		    case BFD_RELOC_PPC_GOT_DTPREL16:
		    case BFD_RELOC_PPC_GOT_DTPREL16_LO:
		    case BFD_RELOC_PPC_GOT_TPREL16:
		    case BFD_RELOC_PPC_GOT_TPREL16_LO:
		      break;
		    default:
		      as_bad (_("unsupported relocation for DS offset field"));
		      break;
		    }
		}
	    }
#endif /* OBJ_ELF */

	  if (reloc != BFD_RELOC_UNUSED)
	    ;
	  /* Determine a BFD reloc value based on the operand information.
	     We are only prepared to turn a few of the operands into
	     relocs.  */
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0x3fffffc
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_B26;
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0xfffc
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_B16;
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0x1fe
		   && operand->shift == -1)
	    reloc = BFD_RELOC_PPC_VLE_REL8;
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0xfffe
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_VLE_REL15;
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0x1fffffe
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_VLE_REL24;
	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
		   && operand->bitm == 0x3fffffc
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_BA26;
	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
		   && operand->bitm == 0xfffc
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_BA16;
#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
	  else if ((operand->flags & PPC_OPERAND_PARENS) != 0
		   && (operand->bitm & 0xfff0) == 0xfff0
		   && operand->shift == 0)
	    {
	      /* Note: the symbol may be not yet defined.  */
	      if (ppc_is_toc_sym (ex.X_add_symbol))
		{
		  reloc = BFD_RELOC_PPC_TOC16;
#ifdef OBJ_ELF
		  if (ppc_obj64
		      && (operand->flags & PPC_OPERAND_DS) != 0)
		    reloc = BFD_RELOC_PPC64_TOC16_DS;
#endif
		}
	      else
		{
		  reloc = BFD_RELOC_16;
#ifdef OBJ_ELF
		  if (ppc_obj64
		      && (operand->flags & PPC_OPERAND_DS) != 0)
		    reloc = BFD_RELOC_PPC64_ADDR16_DS;
#endif
		}
	    }
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */

	  /* We need to generate a fixup for this expression.  */
	  if (fc >= MAX_INSN_FIXUPS)
	    as_fatal (_("too many fixups"));
	  fixups[fc].exp = ex;
	  fixups[fc].opindex = *opindex_ptr;
	  fixups[fc].reloc = reloc;
	  ++fc;
	}

      if (need_paren)
	{
	  endc = ')';
	  need_paren = 0;
	  /* If expecting more operands, then we want to see "),".  */
	  if (*str == endc && opindex_ptr[1] != 0)
	    {
	      do
		++str;
	      while (ISSPACE (*str));
	      endc = ',';
	    }
	}
      else if ((operand->flags & PPC_OPERAND_PARENS) != 0)
	{
	  endc = '(';
	  need_paren = 1;
	}
      else
	endc = ',';

      /* The call to expression should have advanced str past any
	 whitespace.  */
      if (*str != endc
	  && (endc != ',' || *str != '\0'))
	{
	  if (*str == '\0')
	    as_bad (_("syntax error; end of line, expected `%c'"), endc);
	  else
	    as_bad (_("syntax error; found `%c', expected `%c'"), *str, endc);
	  break;
	}

      if (*str != '\0')
	++str;
    }

  while (ISSPACE (*str))
    ++str;

  if (*str != '\0')
    as_bad (_("junk at end of line: `%s'"), str);

#ifdef OBJ_ELF
  /* Do we need/want an APUinfo section? */
  if ((ppc_cpu & (PPC_OPCODE_E500 | PPC_OPCODE_E500MC | PPC_OPCODE_VLE)) != 0
      && !ppc_obj64)
    {
      /* These are all version "1".  */
      if (opcode->flags & PPC_OPCODE_SPE)
	ppc_apuinfo_section_add (PPC_APUINFO_SPE, 1);
      if (opcode->flags & PPC_OPCODE_ISEL)
	ppc_apuinfo_section_add (PPC_APUINFO_ISEL, 1);
      if (opcode->flags & PPC_OPCODE_EFS)
	ppc_apuinfo_section_add (PPC_APUINFO_EFS, 1);
      if (opcode->flags & PPC_OPCODE_BRLOCK)
	ppc_apuinfo_section_add (PPC_APUINFO_BRLOCK, 1);
      if (opcode->flags & PPC_OPCODE_PMR)
	ppc_apuinfo_section_add (PPC_APUINFO_PMR, 1);
      if (opcode->flags & PPC_OPCODE_CACHELCK)
	ppc_apuinfo_section_add (PPC_APUINFO_CACHELCK, 1);
      if (opcode->flags & PPC_OPCODE_RFMCI)
	ppc_apuinfo_section_add (PPC_APUINFO_RFMCI, 1);
      if (opcode->flags & PPC_OPCODE_VLE)
	ppc_apuinfo_section_add (PPC_APUINFO_VLE, 1);
    }
#endif

  /* Write out the instruction.  */
  /* Differentiate between two and four byte insns.  */
  if (ppc_mach () == bfd_mach_ppc_vle)
    {
      if (PPC_OP_SE_VLE (insn))
        insn_length = 2;
      else
        insn_length = 4;
      addr_mod = frag_now_fix () & 1;
    }
  else
    {
      insn_length = 4;
      addr_mod = frag_now_fix () & 3;
    }
  /* All instructions can start on a 2 byte boundary for VLE.  */
  f = frag_more (insn_length);
  if (frag_now->has_code && frag_now->insn_addr != addr_mod)
    {
      if (ppc_mach() == bfd_mach_ppc_vle)
        as_bad (_("instruction address is not a multiple of 2"));
      else
        as_bad (_("instruction address is not a multiple of 4"));
    }
  frag_now->insn_addr = addr_mod;
  frag_now->has_code = 1;
  md_number_to_chars (f, insn, insn_length);

#ifdef OBJ_ELF
  dwarf2_emit_insn (insn_length);
#endif

  /* Create any fixups.  */
  for (i = 0; i < fc; i++)
    {
      fixS *fixP;
      if (fixups[i].reloc != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto;
	  int size;
	  int offset;

	  reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
	  if (!reloc_howto)
	    abort ();

	  size = bfd_get_reloc_size (reloc_howto);
	  offset = target_big_endian ? (insn_length - size) : 0;

	  if (size < 1 || size > 4)
	    abort ();

	  fixP = fix_new_exp (frag_now,
			      f - frag_now->fr_literal + offset,
			      size,
			      &fixups[i].exp,
			      reloc_howto->pc_relative,
			      fixups[i].reloc);
	}
      else
	{
	  const struct powerpc_operand *operand;

	  operand = &powerpc_operands[fixups[i].opindex];
	  fixP = fix_new_exp (frag_now,
			      f - frag_now->fr_literal,
			      insn_length,
			      &fixups[i].exp,
			      (operand->flags & PPC_OPERAND_RELATIVE) != 0,
			      BFD_RELOC_UNUSED);
	}
      fixP->fx_pcrel_adjust = fixups[i].opindex;
    }
}

/* Handle a macro.  Gather all the operands, transform them as
   described by the macro, and call md_assemble recursively.  All the
   operands are separated by commas; we don't accept parentheses
   around operands here.  */

static void
ppc_macro (char *str, const struct powerpc_macro *macro)
{
  char *operands[10];
  unsigned int count;
  char *s;
  unsigned int len;
  const char *format;
  unsigned int arg;
  char *send;
  char *complete;

  /* Gather the users operands into the operands array.  */
  count = 0;
  s = str;
  while (1)
    {
      if (count >= sizeof operands / sizeof operands[0])
	break;
      operands[count++] = s;
      s = strchr (s, ',');
      if (s == (char *) NULL)
	break;
      *s++ = '\0';
    }

  if (count != macro->operands)
    {
      as_bad (_("wrong number of operands"));
      return;
    }

  /* Work out how large the string must be (the size is unbounded
     because it includes user input).  */
  len = 0;
  format = macro->format;
  while (*format != '\0')
    {
      if (*format != '%')
	{
	  ++len;
	  ++format;
	}
      else
	{
	  arg = strtol (format + 1, &send, 10);
	  know (send != format && arg < count);
	  len += strlen (operands[arg]);
	  format = send;
	}
    }

  /* Put the string together.  */
  complete = s = (char *) alloca (len + 1);
  format = macro->format;
  while (*format != '\0')
    {
      if (*format != '%')
	*s++ = *format++;
      else
	{
	  arg = strtol (format + 1, &send, 10);
	  strcpy (s, operands[arg]);
	  s += strlen (s);
	  format = send;
	}
    }
  *s = '\0';

  /* Assemble the constructed instruction.  */
  md_assemble (complete);
}

#ifdef OBJ_ELF
/* For ELF, add support for SHT_ORDERED.  */

int
ppc_section_type (char *str, size_t len)
{
  if (len == 7 && strncmp (str, "ordered", 7) == 0)
    return SHT_ORDERED;

  return -1;
}

int
ppc_section_flags (flagword flags, bfd_vma attr ATTRIBUTE_UNUSED, int type)
{
  if (type == SHT_ORDERED)
    flags |= SEC_ALLOC | SEC_LOAD | SEC_SORT_ENTRIES;

  return flags;
}
#endif /* OBJ_ELF */


/* Pseudo-op handling.  */

/* The .byte pseudo-op.  This is similar to the normal .byte
   pseudo-op, but it can also take a single ASCII string.  */

static void
ppc_byte (int ignore ATTRIBUTE_UNUSED)
{
  if (*input_line_pointer != '\"')
    {
      cons (1);
      return;
    }

  /* Gather characters.  A real double quote is doubled.  Unusual
     characters are not permitted.  */
  ++input_line_pointer;
  while (1)
    {
      char c;

      c = *input_line_pointer++;

      if (c == '\"')
	{
	  if (*input_line_pointer != '\"')
	    break;
	  ++input_line_pointer;
	}

      FRAG_APPEND_1_CHAR (c);
    }

  demand_empty_rest_of_line ();
}

#ifdef OBJ_XCOFF

/* XCOFF specific pseudo-op handling.  */

/* This is set if we are creating a .stabx symbol, since we don't want
   to handle symbol suffixes for such symbols.  */
static bfd_boolean ppc_stab_symbol;

/* The .comm and .lcomm pseudo-ops for XCOFF.  XCOFF puts common
   symbols in the .bss segment as though they were local common
   symbols, and uses a different smclas.  The native Aix 4.3.3 assembler
   aligns .comm and .lcomm to 4 bytes.  */

static void
ppc_comm (int lcomm)
{
  asection *current_seg = now_seg;
  subsegT current_subseg = now_subseg;
  char *name;
  char endc;
  char *end_name;
  offsetT size;
  offsetT align;
  symbolS *lcomm_sym = NULL;
  symbolS *sym;
  char *pfrag;

  name = input_line_pointer;
  endc = get_symbol_end ();
  end_name = input_line_pointer;
  *end_name = endc;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing size"));
      ignore_rest_of_line ();
      return;
    }
  ++input_line_pointer;

  size = get_absolute_expression ();
  if (size < 0)
    {
      as_bad (_("negative size"));
      ignore_rest_of_line ();
      return;
    }

  if (! lcomm)
    {
      /* The third argument to .comm is the alignment.  */
      if (*input_line_pointer != ',')
	align = 2;
      else
	{
	  ++input_line_pointer;
	  align = get_absolute_expression ();
	  if (align <= 0)
	    {
	      as_warn (_("ignoring bad alignment"));
	      align = 2;
	    }
	}
    }
  else
    {
      char *lcomm_name;
      char lcomm_endc;

      /* The third argument to .lcomm appears to be the real local
	 common symbol to create.  References to the symbol named in
	 the first argument are turned into references to the third
	 argument.  */
      if (*input_line_pointer != ',')
	{
	  as_bad (_("missing real symbol name"));
	  ignore_rest_of_line ();
	  return;
	}
      ++input_line_pointer;

      lcomm_name = input_line_pointer;
      lcomm_endc = get_symbol_end ();

      lcomm_sym = symbol_find_or_make (lcomm_name);

      *input_line_pointer = lcomm_endc;

      /* The fourth argument to .lcomm is the alignment.  */
      if (*input_line_pointer != ',')
	{
	  if (size <= 4)
	    align = 2;
	  else
	    align = 3;
	}
      else
	{
	  ++input_line_pointer;
	  align = get_absolute_expression ();
	  if (align <= 0)
	    {
	      as_warn (_("ignoring bad alignment"));
	      align = 2;
	    }
	}
    }

  *end_name = '\0';
  sym = symbol_find_or_make (name);
  *end_name = endc;

  if (S_IS_DEFINED (sym)
      || S_GET_VALUE (sym) != 0)
    {
      as_bad (_("attempt to redefine symbol"));
      ignore_rest_of_line ();
      return;
    }

  record_alignment (bss_section, align);

  if (! lcomm
      || ! S_IS_DEFINED (lcomm_sym))
    {
      symbolS *def_sym;
      offsetT def_size;

      if (! lcomm)
	{
	  def_sym = sym;
	  def_size = size;
	  S_SET_EXTERNAL (sym);
	}
      else
	{
	  symbol_get_tc (lcomm_sym)->output = 1;
	  def_sym = lcomm_sym;
	  def_size = 0;
	}

      subseg_set (bss_section, 1);
      frag_align (align, 0, 0);

      symbol_set_frag (def_sym, frag_now);
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, def_sym,
			def_size, (char *) NULL);
      *pfrag = 0;
      S_SET_SEGMENT (def_sym, bss_section);
      symbol_get_tc (def_sym)->align = align;
    }
  else if (lcomm)
    {
      /* Align the size of lcomm_sym.  */
      symbol_get_frag (lcomm_sym)->fr_offset =
	((symbol_get_frag (lcomm_sym)->fr_offset + (1 << align) - 1)
	 &~ ((1 << align) - 1));
      if (align > symbol_get_tc (lcomm_sym)->align)
	symbol_get_tc (lcomm_sym)->align = align;
    }

  if (lcomm)
    {
      /* Make sym an offset from lcomm_sym.  */
      S_SET_SEGMENT (sym, bss_section);
      symbol_set_frag (sym, symbol_get_frag (lcomm_sym));
      S_SET_VALUE (sym, symbol_get_frag (lcomm_sym)->fr_offset);
      symbol_get_frag (lcomm_sym)->fr_offset += size;
    }

  subseg_set (current_seg, current_subseg);

  demand_empty_rest_of_line ();
}

/* The .csect pseudo-op.  This switches us into a different
   subsegment.  The first argument is a symbol whose value is the
   start of the .csect.  In COFF, csect symbols get special aux
   entries defined by the x_csect field of union internal_auxent.  The
   optional second argument is the alignment (the default is 2).  */

static void
ppc_csect (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char endc;
  symbolS *sym;
  offsetT align;

  name = input_line_pointer;
  endc = get_symbol_end ();

  sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  if (S_GET_NAME (sym)[0] == '\0')
    {
      /* An unnamed csect is assumed to be [PR].  */
      symbol_get_tc (sym)->symbol_class = XMC_PR;
    }

  align = 2;
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      align = get_absolute_expression ();
    }

  ppc_change_csect (sym, align);

  demand_empty_rest_of_line ();
}

/* Change to a different csect.  */

static void
ppc_change_csect (symbolS *sym, offsetT align)
{
  if (S_IS_DEFINED (sym))
    subseg_set (S_GET_SEGMENT (sym), symbol_get_tc (sym)->subseg);
  else
    {
      symbolS **list_ptr;
      int after_toc;
      int hold_chunksize;
      symbolS *list;
      int is_code;
      segT sec;

      /* This is a new csect.  We need to look at the symbol class to
	 figure out whether it should go in the text section or the
	 data section.  */
      after_toc = 0;
      is_code = 0;
      switch (symbol_get_tc (sym)->symbol_class)
	{
	case XMC_PR:
	case XMC_RO:
	case XMC_DB:
	case XMC_GL:
	case XMC_XO:
	case XMC_SV:
	case XMC_TI:
	case XMC_TB:
	  S_SET_SEGMENT (sym, text_section);
	  symbol_get_tc (sym)->subseg = ppc_text_subsegment;
	  ++ppc_text_subsegment;
	  list_ptr = &ppc_text_csects;
	  is_code = 1;
	  break;
	case XMC_RW:
	case XMC_TC0:
	case XMC_TC:
	case XMC_DS:
	case XMC_UA:
	case XMC_BS:
	case XMC_UC:
	  if (ppc_toc_csect != NULL
	      && (symbol_get_tc (ppc_toc_csect)->subseg + 1
		  == ppc_data_subsegment))
	    after_toc = 1;
	  S_SET_SEGMENT (sym, data_section);
	  symbol_get_tc (sym)->subseg = ppc_data_subsegment;
	  ++ppc_data_subsegment;
	  list_ptr = &ppc_data_csects;
	  break;
	default:
	  abort ();
	}

      /* We set the obstack chunk size to a small value before
	 changing subsegments, so that we don't use a lot of memory
	 space for what may be a small section.  */
      hold_chunksize = chunksize;
      chunksize = 64;

      sec = subseg_new (segment_name (S_GET_SEGMENT (sym)),
			symbol_get_tc (sym)->subseg);

      chunksize = hold_chunksize;

      if (after_toc)
	ppc_after_toc_frag = frag_now;

      record_alignment (sec, align);
      if (is_code)
	frag_align_code (align, 0);
      else
	frag_align (align, 0, 0);

      symbol_set_frag (sym, frag_now);
      S_SET_VALUE (sym, (valueT) frag_now_fix ());

      symbol_get_tc (sym)->align = align;
      symbol_get_tc (sym)->output = 1;
      symbol_get_tc (sym)->within = sym;

      for (list = *list_ptr;
	   symbol_get_tc (list)->next != (symbolS *) NULL;
	   list = symbol_get_tc (list)->next)
	;
      symbol_get_tc (list)->next = sym;

      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_append (sym, symbol_get_tc (list)->within, &symbol_rootP,
		     &symbol_lastP);
    }

  ppc_current_csect = sym;
}

static void
ppc_change_debug_section (unsigned int idx, subsegT subseg)
{
  segT sec;
  flagword oldflags;
  const struct xcoff_dwsect_name *dw = &xcoff_dwsect_names[idx];

  sec = subseg_new (dw->name, subseg);
  oldflags = bfd_get_section_flags (stdoutput, sec);
  if (oldflags == SEC_NO_FLAGS)
    {
      /* Just created section.  */
      gas_assert (dw_sections[idx].sect == NULL);

      bfd_set_section_flags (stdoutput, sec, SEC_DEBUGGING);
      bfd_set_section_alignment (stdoutput, sec, 0);
      dw_sections[idx].sect = sec;
    }

  /* Not anymore in a csect.  */
  ppc_current_csect = NULL;
}

/* The .dwsect pseudo-op.  Defines a DWARF section.  Syntax is:
     .dwsect flag [, opt-label ]
*/

static void
ppc_dwsect (int ignore ATTRIBUTE_UNUSED)
{
  offsetT flag;
  symbolS *opt_label;
  const struct xcoff_dwsect_name *dw;
  struct dw_subsection *subseg;
  struct dw_section *dws;
  int i;

  /* Find section.  */
  flag = get_absolute_expression ();
  dw = NULL;
  for (i = 0; i < XCOFF_DWSECT_NBR_NAMES; i++)
    if (xcoff_dwsect_names[i].flag == flag)
      {
        dw = &xcoff_dwsect_names[i];
        break;
      }

  /* Parse opt-label.  */
  if (*input_line_pointer == ',')
    {
      const char *label;
      char c;

      ++input_line_pointer;

      label = input_line_pointer;
      c = get_symbol_end ();
      opt_label = symbol_find_or_make (label);
      *input_line_pointer = c;
    }
  else
    opt_label = NULL;

  demand_empty_rest_of_line ();

  /* Return now in case of unknown subsection.  */
  if (dw == NULL)
    {
      as_bad (_("no known dwarf XCOFF section for flag 0x%08x\n"),
              (unsigned)flag);
      return;
    }

  /* Find the subsection.  */
  dws = &dw_sections[i];
  subseg = NULL;
  if (opt_label != NULL && S_IS_DEFINED (opt_label))
    {
      /* Sanity check (note that in theory S_GET_SEGMENT mustn't be null).  */
      if (dws->sect == NULL || S_GET_SEGMENT (opt_label) != dws->sect)
        {
          as_bad (_("label %s was not defined in this dwarf section"),
                  S_GET_NAME (opt_label));
          subseg = dws->anon_subseg;
          opt_label = NULL;
        }
      else
        subseg = symbol_get_tc (opt_label)->u.dw;
    }

  if (subseg != NULL)
    {
      /* Switch to the subsection.  */
      ppc_change_debug_section (i, subseg->subseg);
    }
  else
    {
      /* Create a new dw subsection.  */
      subseg = (struct dw_subsection *)
        xmalloc (sizeof (struct dw_subsection));

      if (opt_label == NULL)
        {
          /* The anonymous one.  */
          subseg->subseg = 0;
          subseg->link = NULL;
          dws->anon_subseg = subseg;
        }
      else
        {
          /* A named one.  */
          if (dws->list_subseg != NULL)
            subseg->subseg = dws->list_subseg->subseg + 1;
          else
            subseg->subseg = 1;

          subseg->link = dws->list_subseg;
          dws->list_subseg = subseg;
          symbol_get_tc (opt_label)->u.dw = subseg;
        }

      ppc_change_debug_section (i, subseg->subseg);

      if (dw->def_size)
        {
          /* Add the length field.  */
          expressionS *exp = &subseg->end_exp;
          int sz;

          if (opt_label != NULL)
            symbol_set_value_now (opt_label);

          /* Add the length field.  Note that according to the AIX assembler
             manual, the size of the length field is 4 for powerpc32 but
             12 for powerpc64.  */
          if (ppc_obj64)
            {
              /* Write the 64bit marker.  */
              md_number_to_chars (frag_more (4), -1, 4);
            }

          exp->X_op = O_subtract;
          exp->X_op_symbol = symbol_temp_new_now ();
          exp->X_add_symbol = symbol_temp_make ();

          sz = ppc_obj64 ? 8 : 4;
          exp->X_add_number = -sz;
          emit_expr (exp, sz);
        }
    }
}

/* This function handles the .text and .data pseudo-ops.  These
   pseudo-ops aren't really used by XCOFF; we implement them for the
   convenience of people who aren't used to XCOFF.  */

static void
ppc_section (int type)
{
  const char *name;
  symbolS *sym;

  if (type == 't')
    name = ".text[PR]";
  else if (type == 'd')
    name = ".data[RW]";
  else
    abort ();

  sym = symbol_find_or_make (name);

  ppc_change_csect (sym, 2);

  demand_empty_rest_of_line ();
}

/* This function handles the .section pseudo-op.  This is mostly to
   give an error, since XCOFF only supports .text, .data and .bss, but
   we do permit the user to name the text or data section.  */

static void
ppc_named_section (int ignore ATTRIBUTE_UNUSED)
{
  char *user_name;
  const char *real_name;
  char c;
  symbolS *sym;

  user_name = input_line_pointer;
  c = get_symbol_end ();

  if (strcmp (user_name, ".text") == 0)
    real_name = ".text[PR]";
  else if (strcmp (user_name, ".data") == 0)
    real_name = ".data[RW]";
  else
    {
      as_bad (_("the XCOFF file format does not support arbitrary sections"));
      *input_line_pointer = c;
      ignore_rest_of_line ();
      return;
    }

  *input_line_pointer = c;

  sym = symbol_find_or_make (real_name);

  ppc_change_csect (sym, 2);

  demand_empty_rest_of_line ();
}

/* The .extern pseudo-op.  We create an undefined symbol.  */

static void
ppc_extern (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char endc;

  name = input_line_pointer;
  endc = get_symbol_end ();

  (void) symbol_find_or_make (name);

  *input_line_pointer = endc;

  demand_empty_rest_of_line ();
}

/* The .lglobl pseudo-op.  Keep the symbol in the symbol table.  */

static void
ppc_lglobl (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char endc;
  symbolS *sym;

  name = input_line_pointer;
  endc = get_symbol_end ();

  sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  symbol_get_tc (sym)->output = 1;

  demand_empty_rest_of_line ();
}

/* The .ref pseudo-op.  It takes a list of symbol names and inserts R_REF
   relocations at the beginning of the current csect.

   (In principle, there's no reason why the relocations _have_ to be at
   the beginning.  Anywhere in the csect would do.  However, inserting
   at the beginning is what the native assmebler does, and it helps to
   deal with cases where the .ref statements follow the section contents.)

   ??? .refs don't work for empty .csects.  However, the native assembler
   doesn't report an error in this case, and neither yet do we.  */

static void
ppc_ref (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c;

  if (ppc_current_csect == NULL)
    {
      as_bad (_(".ref outside .csect"));
      ignore_rest_of_line ();
      return;
    }

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();

      fix_at_start (symbol_get_frag (ppc_current_csect), 0,
		    symbol_find_or_make (name), 0, FALSE, BFD_RELOC_NONE);

      *input_line_pointer = c;
      SKIP_WHITESPACE ();
      c = *input_line_pointer;
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (is_end_of_line[(unsigned char) *input_line_pointer])
	    {
	      as_bad (_("missing symbol name"));
	      ignore_rest_of_line ();
	      return;
	    }
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

/* The .rename pseudo-op.  The RS/6000 assembler can rename symbols,
   although I don't know why it bothers.  */

static void
ppc_rename (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char endc;
  symbolS *sym;
  int len;

  name = input_line_pointer;
  endc = get_symbol_end ();

  sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing rename string"));
      ignore_rest_of_line ();
      return;
    }
  ++input_line_pointer;

  symbol_get_tc (sym)->real_name = demand_copy_C_string (&len);

  demand_empty_rest_of_line ();
}

/* The .stabx pseudo-op.  This is similar to a normal .stabs
   pseudo-op, but slightly different.  A sample is
       .stabx "main:F-1",.main,142,0
   The first argument is the symbol name to create.  The second is the
   value, and the third is the storage class.  The fourth seems to be
   always zero, and I am assuming it is the type.  */

static void
ppc_stabx (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  int len;
  symbolS *sym;
  expressionS exp;

  name = demand_copy_C_string (&len);

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing value"));
      return;
    }
  ++input_line_pointer;

  ppc_stab_symbol = TRUE;
  sym = symbol_make (name);
  ppc_stab_symbol = FALSE;

  symbol_get_tc (sym)->real_name = name;

  (void) expression (&exp);

  switch (exp.X_op)
    {
    case O_illegal:
    case O_absent:
    case O_big:
      as_bad (_("illegal .stabx expression; zero assumed"));
      exp.X_add_number = 0;
      /* Fall through.  */
    case O_constant:
      S_SET_VALUE (sym, (valueT) exp.X_add_number);
      symbol_set_frag (sym, &zero_address_frag);
      break;

    case O_symbol:
      if (S_GET_SEGMENT (exp.X_add_symbol) == undefined_section)
	symbol_set_value_expression (sym, &exp);
      else
	{
	  S_SET_VALUE (sym,
		       exp.X_add_number + S_GET_VALUE (exp.X_add_symbol));
	  symbol_set_frag (sym, symbol_get_frag (exp.X_add_symbol));
	}
      break;

    default:
      /* The value is some complex expression.  This will probably
	 fail at some later point, but this is probably the right
	 thing to do here.  */
      symbol_set_value_expression (sym, &exp);
      break;
    }

  S_SET_SEGMENT (sym, ppc_coff_debug_section);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing class"));
      return;
    }
  ++input_line_pointer;

  S_SET_STORAGE_CLASS (sym, get_absolute_expression ());

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing type"));
      return;
    }
  ++input_line_pointer;

  S_SET_DATA_TYPE (sym, get_absolute_expression ());

  symbol_get_tc (sym)->output = 1;

  if (S_GET_STORAGE_CLASS (sym) == C_STSYM)
    {
      /* In this case :

         .bs name
         .stabx	"z",arrays_,133,0
         .es

         .comm arrays_,13768,3

         resolve_symbol_value will copy the exp's "within" into sym's when the
         offset is 0.  Since this seems to be corner case problem,
         only do the correction for storage class C_STSYM.  A better solution
         would be to have the tc field updated in ppc_symbol_new_hook.  */

      if (exp.X_op == O_symbol)
        {
          if (ppc_current_block == NULL)
            as_bad (_(".stabx of storage class stsym must be within .bs/.es"));

          symbol_get_tc (sym)->within = ppc_current_block;
          symbol_get_tc (exp.X_add_symbol)->within = ppc_current_block;
        }
    }

  if (exp.X_op != O_symbol
      || ! S_IS_EXTERNAL (exp.X_add_symbol)
      || S_GET_SEGMENT (exp.X_add_symbol) != bss_section)
    ppc_frob_label (sym);
  else
    {
      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_append (sym, exp.X_add_symbol, &symbol_rootP, &symbol_lastP);
      if (symbol_get_tc (ppc_current_csect)->within == exp.X_add_symbol)
	symbol_get_tc (ppc_current_csect)->within = sym;
    }

  demand_empty_rest_of_line ();
}

/* The .function pseudo-op.  This takes several arguments.  The first
   argument seems to be the external name of the symbol.  The second
   argument seems to be the label for the start of the function.  gcc
   uses the same name for both.  I have no idea what the third and
   fourth arguments are meant to be.  The optional fifth argument is
   an expression for the size of the function.  In COFF this symbol
   gets an aux entry like that used for a csect.  */

static void
ppc_function (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char endc;
  char *s;
  symbolS *ext_sym;
  symbolS *lab_sym;

  name = input_line_pointer;
  endc = get_symbol_end ();

  /* Ignore any [PR] suffix.  */
  name = ppc_canonicalize_symbol_name (name);
  s = strchr (name, '[');
  if (s != (char *) NULL
      && strcmp (s + 1, "PR]") == 0)
    *s = '\0';

  ext_sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing symbol name"));
      ignore_rest_of_line ();
      return;
    }
  ++input_line_pointer;

  name = input_line_pointer;
  endc = get_symbol_end ();

  lab_sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  if (ext_sym != lab_sym)
    {
      expressionS exp;

      exp.X_op = O_symbol;
      exp.X_add_symbol = lab_sym;
      exp.X_op_symbol = NULL;
      exp.X_add_number = 0;
      exp.X_unsigned = 0;
      symbol_set_value_expression (ext_sym, &exp);
    }

  if (symbol_get_tc (ext_sym)->symbol_class == -1)
    symbol_get_tc (ext_sym)->symbol_class = XMC_PR;
  symbol_get_tc (ext_sym)->output = 1;

  if (*input_line_pointer == ',')
    {
      expressionS exp;

      /* Ignore the third argument.  */
      ++input_line_pointer;
      expression (& exp);
      if (*input_line_pointer == ',')
	{
	  /* Ignore the fourth argument.  */
	  ++input_line_pointer;
	  expression (& exp);
	  if (*input_line_pointer == ',')
	    {
	      /* The fifth argument is the function size.  */
	      ++input_line_pointer;
	      symbol_get_tc (ext_sym)->u.size = symbol_new
                ("L0\001", absolute_section,(valueT) 0, &zero_address_frag);
	      pseudo_set (symbol_get_tc (ext_sym)->u.size);
	    }
	}
    }

  S_SET_DATA_TYPE (ext_sym, DT_FCN << N_BTSHFT);
  SF_SET_FUNCTION (ext_sym);
  SF_SET_PROCESS (ext_sym);
  coff_add_linesym (ext_sym);

  demand_empty_rest_of_line ();
}

/* The .bf pseudo-op.  This is just like a COFF C_FCN symbol named
   ".bf".  If the pseudo op .bi was seen before .bf, patch the .bi sym
   with the correct line number */

static symbolS *saved_bi_sym = 0;

static void
ppc_bf (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym;

  sym = symbol_make (".bf");
  S_SET_SEGMENT (sym, text_section);
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, frag_now_fix ());
  S_SET_STORAGE_CLASS (sym, C_FCN);

  coff_line_base = get_absolute_expression ();

  S_SET_NUMBER_AUXILIARY (sym, 1);
  SA_SET_SYM_LNNO (sym, coff_line_base);

  /* Line number for bi.  */
  if (saved_bi_sym)
    {
      S_SET_VALUE (saved_bi_sym, coff_n_line_nos);
      saved_bi_sym = 0;
    }


  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .ef pseudo-op.  This is just like a COFF C_FCN symbol named
   ".ef", except that the line number is absolute, not relative to the
   most recent ".bf" symbol.  */

static void
ppc_ef (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym;

  sym = symbol_make (".ef");
  S_SET_SEGMENT (sym, text_section);
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, frag_now_fix ());
  S_SET_STORAGE_CLASS (sym, C_FCN);
  S_SET_NUMBER_AUXILIARY (sym, 1);
  SA_SET_SYM_LNNO (sym, get_absolute_expression ());
  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .bi and .ei pseudo-ops.  These take a string argument and
   generates a C_BINCL or C_EINCL symbol, which goes at the start of
   the symbol list.  The value of .bi will be know when the next .bf
   is encountered.  */

static void
ppc_biei (int ei)
{
  static symbolS *last_biei;

  char *name;
  int len;
  symbolS *sym;
  symbolS *look;

  name = demand_copy_C_string (&len);

  /* The value of these symbols is actually file offset.  Here we set
     the value to the index into the line number entries.  In
     ppc_frob_symbols we set the fix_line field, which will cause BFD
     to do the right thing.  */

  sym = symbol_make (name);
  /* obj-coff.c currently only handles line numbers correctly in the
     .text section.  */
  S_SET_SEGMENT (sym, text_section);
  S_SET_VALUE (sym, coff_n_line_nos);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;

  S_SET_STORAGE_CLASS (sym, ei ? C_EINCL : C_BINCL);
  symbol_get_tc (sym)->output = 1;

  /* Save bi.  */
  if (ei)
    saved_bi_sym = 0;
  else
    saved_bi_sym = sym;

  for (look = last_biei ? last_biei : symbol_rootP;
       (look != (symbolS *) NULL
	&& (S_GET_STORAGE_CLASS (look) == C_FILE
	    || S_GET_STORAGE_CLASS (look) == C_BINCL
	    || S_GET_STORAGE_CLASS (look) == C_EINCL));
       look = symbol_next (look))
    ;
  if (look != (symbolS *) NULL)
    {
      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_insert (sym, look, &symbol_rootP, &symbol_lastP);
      last_biei = sym;
    }

  demand_empty_rest_of_line ();
}

/* The .bs pseudo-op.  This generates a C_BSTAT symbol named ".bs".
   There is one argument, which is a csect symbol.  The value of the
   .bs symbol is the index of this csect symbol.  */

static void
ppc_bs (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char endc;
  symbolS *csect;
  symbolS *sym;

  if (ppc_current_block != NULL)
    as_bad (_("nested .bs blocks"));

  name = input_line_pointer;
  endc = get_symbol_end ();

  csect = symbol_find_or_make (name);

  *input_line_pointer = endc;

  sym = symbol_make (".bs");
  S_SET_SEGMENT (sym, now_seg);
  S_SET_STORAGE_CLASS (sym, C_BSTAT);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  symbol_get_tc (sym)->output = 1;

  symbol_get_tc (sym)->within = csect;

  ppc_frob_label (sym);

  ppc_current_block = sym;

  demand_empty_rest_of_line ();
}

/* The .es pseudo-op.  Generate a C_ESTART symbol named .es.  */

static void
ppc_es (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym;

  if (ppc_current_block == NULL)
    as_bad (_(".es without preceding .bs"));

  sym = symbol_make (".es");
  S_SET_SEGMENT (sym, now_seg);
  S_SET_STORAGE_CLASS (sym, C_ESTAT);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  ppc_current_block = NULL;

  demand_empty_rest_of_line ();
}

/* The .bb pseudo-op.  Generate a C_BLOCK symbol named .bb, with a
   line number.  */

static void
ppc_bb (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym;

  sym = symbol_make (".bb");
  S_SET_SEGMENT (sym, text_section);
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, frag_now_fix ());
  S_SET_STORAGE_CLASS (sym, C_BLOCK);

  S_SET_NUMBER_AUXILIARY (sym, 1);
  SA_SET_SYM_LNNO (sym, get_absolute_expression ());

  symbol_get_tc (sym)->output = 1;

  SF_SET_PROCESS (sym);

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .eb pseudo-op.  Generate a C_BLOCK symbol named .eb, with a
   line number.  */

static void
ppc_eb (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym;

  sym = symbol_make (".eb");
  S_SET_SEGMENT (sym, text_section);
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, frag_now_fix ());
  S_SET_STORAGE_CLASS (sym, C_BLOCK);
  S_SET_NUMBER_AUXILIARY (sym, 1);
  SA_SET_SYM_LNNO (sym, get_absolute_expression ());
  symbol_get_tc (sym)->output = 1;

  SF_SET_PROCESS (sym);

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .bc pseudo-op.  This just creates a C_BCOMM symbol with a
   specified name.  */

static void
ppc_bc (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  int len;
  symbolS *sym;

  name = demand_copy_C_string (&len);
  sym = symbol_make (name);
  S_SET_SEGMENT (sym, ppc_coff_debug_section);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  S_SET_STORAGE_CLASS (sym, C_BCOMM);
  S_SET_VALUE (sym, 0);
  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .ec pseudo-op.  This just creates a C_ECOMM symbol.  */

static void
ppc_ec (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym;

  sym = symbol_make (".ec");
  S_SET_SEGMENT (sym, ppc_coff_debug_section);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  S_SET_STORAGE_CLASS (sym, C_ECOMM);
  S_SET_VALUE (sym, 0);
  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .toc pseudo-op.  Switch to the .toc subsegment.  */

static void
ppc_toc (int ignore ATTRIBUTE_UNUSED)
{
  if (ppc_toc_csect != (symbolS *) NULL)
    subseg_set (data_section, symbol_get_tc (ppc_toc_csect)->subseg);
  else
    {
      subsegT subseg;
      symbolS *sym;
      symbolS *list;

      subseg = ppc_data_subsegment;
      ++ppc_data_subsegment;

      subseg_new (segment_name (data_section), subseg);
      ppc_toc_frag = frag_now;

      sym = symbol_find_or_make ("TOC[TC0]");
      symbol_set_frag (sym, frag_now);
      S_SET_SEGMENT (sym, data_section);
      S_SET_VALUE (sym, (valueT) frag_now_fix ());
      symbol_get_tc (sym)->subseg = subseg;
      symbol_get_tc (sym)->output = 1;
      symbol_get_tc (sym)->within = sym;

      ppc_toc_csect = sym;

      for (list = ppc_data_csects;
	   symbol_get_tc (list)->next != (symbolS *) NULL;
	   list = symbol_get_tc (list)->next)
	;
      symbol_get_tc (list)->next = sym;

      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_append (sym, symbol_get_tc (list)->within, &symbol_rootP,
		     &symbol_lastP);
    }

  ppc_current_csect = ppc_toc_csect;

  demand_empty_rest_of_line ();
}

/* The AIX assembler automatically aligns the operands of a .long or
   .short pseudo-op, and we want to be compatible.  */

static void
ppc_xcoff_cons (int log_size)
{
  frag_align (log_size, 0, 0);
  record_alignment (now_seg, log_size);
  cons (1 << log_size);
}

static void
ppc_vbyte (int dummy ATTRIBUTE_UNUSED)
{
  expressionS exp;
  int byte_count;

  (void) expression (&exp);

  if (exp.X_op != O_constant)
    {
      as_bad (_("non-constant byte count"));
      return;
    }

  byte_count = exp.X_add_number;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing value"));
      return;
    }

  ++input_line_pointer;
  cons (byte_count);
}

void
ppc_xcoff_end (void)
{
  int i;

  for (i = 0; i < XCOFF_DWSECT_NBR_NAMES; i++)
    {
      struct dw_section *dws = &dw_sections[i];
      struct dw_subsection *dwss;

      if (dws->anon_subseg)
        {
          dwss = dws->anon_subseg;
          dwss->link = dws->list_subseg;
        }
      else
        dwss = dws->list_subseg;

      for (; dwss != NULL; dwss = dwss->link)
        if (dwss->end_exp.X_add_symbol != NULL)
          {
            subseg_set (dws->sect, dwss->subseg);
            symbol_set_value_now (dwss->end_exp.X_add_symbol);
          }
    }
}

#endif /* OBJ_XCOFF */
#if defined (OBJ_XCOFF) || defined (OBJ_ELF)

/* The .tc pseudo-op.  This is used when generating either XCOFF or
   ELF.  This takes two or more arguments.

   When generating XCOFF output, the first argument is the name to
   give to this location in the toc; this will be a symbol with class
   TC.  The rest of the arguments are N-byte values to actually put at
   this location in the TOC; often there is just one more argument, a
   relocatable symbol reference.  The size of the value to store
   depends on target word size.  A 32-bit target uses 4-byte values, a
   64-bit target uses 8-byte values.

   When not generating XCOFF output, the arguments are the same, but
   the first argument is simply ignored.  */

static void
ppc_tc (int ignore ATTRIBUTE_UNUSED)
{
#ifdef OBJ_XCOFF

  /* Define the TOC symbol name.  */
  {
    char *name;
    char endc;
    symbolS *sym;

    if (ppc_toc_csect == (symbolS *) NULL
	|| ppc_toc_csect != ppc_current_csect)
      {
	as_bad (_(".tc not in .toc section"));
	ignore_rest_of_line ();
	return;
      }

    name = input_line_pointer;
    endc = get_symbol_end ();

    sym = symbol_find_or_make (name);

    *input_line_pointer = endc;

    if (S_IS_DEFINED (sym))
      {
	symbolS *label;

	label = symbol_get_tc (ppc_current_csect)->within;
	if (symbol_get_tc (label)->symbol_class != XMC_TC0)
	  {
	    as_bad (_(".tc with no label"));
	    ignore_rest_of_line ();
	    return;
	  }

	S_SET_SEGMENT (label, S_GET_SEGMENT (sym));
	symbol_set_frag (label, symbol_get_frag (sym));
	S_SET_VALUE (label, S_GET_VALUE (sym));

	while (! is_end_of_line[(unsigned char) *input_line_pointer])
	  ++input_line_pointer;

	return;
      }

    S_SET_SEGMENT (sym, now_seg);
    symbol_set_frag (sym, frag_now);
    S_SET_VALUE (sym, (valueT) frag_now_fix ());
    symbol_get_tc (sym)->symbol_class = XMC_TC;
    symbol_get_tc (sym)->output = 1;

    ppc_frob_label (sym);
  }

#endif /* OBJ_XCOFF */
#ifdef OBJ_ELF
  int align;

  /* Skip the TOC symbol name.  */
  while (is_part_of_name (*input_line_pointer)
	 || *input_line_pointer == ' '
	 || *input_line_pointer == '['
	 || *input_line_pointer == ']'
	 || *input_line_pointer == '{'
	 || *input_line_pointer == '}')
    ++input_line_pointer;

  /* Align to a four/eight byte boundary.  */
  align = ppc_obj64 ? 3 : 2;
  frag_align (align, 0, 0);
  record_alignment (now_seg, align);
#endif /* OBJ_ELF */

  if (*input_line_pointer != ',')
    demand_empty_rest_of_line ();
  else
    {
      ++input_line_pointer;
      cons (ppc_obj64 ? 8 : 4);
    }
}

/* Pseudo-op .machine.  */

static void
ppc_machine (int ignore ATTRIBUTE_UNUSED)
{
  char *cpu_string;
#define MAX_HISTORY 100
  static ppc_cpu_t *cpu_history;
  static int curr_hist;

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '"')
    {
      int len;
      cpu_string = demand_copy_C_string (&len);
    }
  else
    {
      char c;
      cpu_string = input_line_pointer;
      c = get_symbol_end ();
      cpu_string = xstrdup (cpu_string);
      *input_line_pointer = c;
    }

  if (cpu_string != NULL)
    {
      ppc_cpu_t old_cpu = ppc_cpu;
      ppc_cpu_t new_cpu;
      char *p;

      for (p = cpu_string; *p != 0; p++)
	*p = TOLOWER (*p);

      if (strcmp (cpu_string, "push") == 0)
	{
	  if (cpu_history == NULL)
	    cpu_history = xmalloc (MAX_HISTORY * sizeof (*cpu_history));

	  if (curr_hist >= MAX_HISTORY)
	    as_bad (_(".machine stack overflow"));
	  else
	    cpu_history[curr_hist++] = ppc_cpu;
	}
      else if (strcmp (cpu_string, "pop") == 0)
	{
	  if (curr_hist <= 0)
	    as_bad (_(".machine stack underflow"));
	  else
	    ppc_cpu = cpu_history[--curr_hist];
	}
      else if ((new_cpu = ppc_parse_cpu (ppc_cpu, &sticky, cpu_string)) != 0)
	ppc_cpu = new_cpu;
      else
	as_bad (_("invalid machine `%s'"), cpu_string);

      if (ppc_cpu != old_cpu)
	ppc_setup_opcodes ();
    }

  demand_empty_rest_of_line ();
}
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */

#ifdef TE_PE

/* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format.  */

/* Set the current section.  */
static void
ppc_set_current_section (segT new)
{
  ppc_previous_section = ppc_current_section;
  ppc_current_section = new;
}

/* pseudo-op: .previous
   behaviour: toggles the current section with the previous section.
   errors:    None
   warnings:  "No previous section"  */

static void
ppc_previous (int ignore ATTRIBUTE_UNUSED)
{
  if (ppc_previous_section == NULL)
    {
      as_warn (_("no previous section to return to, ignored."));
      return;
    }

  subseg_set (ppc_previous_section, 0);

  ppc_set_current_section (ppc_previous_section);
}

/* pseudo-op: .pdata
   behaviour: predefined read only data section
	      double word aligned
   errors:    None
   warnings:  None
   initial:   .section .pdata "adr3"
	      a - don't know -- maybe a misprint
	      d - initialized data
	      r - readable
	      3 - double word aligned (that would be 4 byte boundary)

   commentary:
   Tag index tables (also known as the function table) for exception
   handling, debugging, etc.  */

static void
ppc_pdata (int ignore ATTRIBUTE_UNUSED)
{
  if (pdata_section == 0)
    {
      pdata_section = subseg_new (".pdata", 0);

      bfd_set_section_flags (stdoutput, pdata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_READONLY | SEC_DATA ));

      bfd_set_section_alignment (stdoutput, pdata_section, 2);
    }
  else
    {
      pdata_section = subseg_new (".pdata", 0);
    }
  ppc_set_current_section (pdata_section);
}

/* pseudo-op: .ydata
   behaviour: predefined read only data section
	      double word aligned
   errors:    None
   warnings:  None
   initial:   .section .ydata "drw3"
	      a - don't know -- maybe a misprint
	      d - initialized data
	      r - readable
	      3 - double word aligned (that would be 4 byte boundary)
   commentary:
   Tag tables (also known as the scope table) for exception handling,
   debugging, etc.  */

static void
ppc_ydata (int ignore ATTRIBUTE_UNUSED)
{
  if (ydata_section == 0)
    {
      ydata_section = subseg_new (".ydata", 0);
      bfd_set_section_flags (stdoutput, ydata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_READONLY | SEC_DATA ));

      bfd_set_section_alignment (stdoutput, ydata_section, 3);
    }
  else
    {
      ydata_section = subseg_new (".ydata", 0);
    }
  ppc_set_current_section (ydata_section);
}

/* pseudo-op: .reldata
   behaviour: predefined read write data section
	      double word aligned (4-byte)
	      FIXME: relocation is applied to it
	      FIXME: what's the difference between this and .data?
   errors:    None
   warnings:  None
   initial:   .section .reldata "drw3"
	      d - initialized data
	      r - readable
	      w - writeable
	      3 - double word aligned (that would be 8 byte boundary)

   commentary:
   Like .data, but intended to hold data subject to relocation, such as
   function descriptors, etc.  */

static void
ppc_reldata (int ignore ATTRIBUTE_UNUSED)
{
  if (reldata_section == 0)
    {
      reldata_section = subseg_new (".reldata", 0);

      bfd_set_section_flags (stdoutput, reldata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_DATA));

      bfd_set_section_alignment (stdoutput, reldata_section, 2);
    }
  else
    {
      reldata_section = subseg_new (".reldata", 0);
    }
  ppc_set_current_section (reldata_section);
}

/* pseudo-op: .rdata
   behaviour: predefined read only data section
	      double word aligned
   errors:    None
   warnings:  None
   initial:   .section .rdata "dr3"
	      d - initialized data
	      r - readable
	      3 - double word aligned (that would be 4 byte boundary)  */

static void
ppc_rdata (int ignore ATTRIBUTE_UNUSED)
{
  if (rdata_section == 0)
    {
      rdata_section = subseg_new (".rdata", 0);
      bfd_set_section_flags (stdoutput, rdata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_READONLY | SEC_DATA ));

      bfd_set_section_alignment (stdoutput, rdata_section, 2);
    }
  else
    {
      rdata_section = subseg_new (".rdata", 0);
    }
  ppc_set_current_section (rdata_section);
}

/* pseudo-op: .ualong
   behaviour: much like .int, with the exception that no alignment is
	      performed.
	      FIXME: test the alignment statement
   errors:    None
   warnings:  None  */

static void
ppc_ualong (int ignore ATTRIBUTE_UNUSED)
{
  /* Try for long.  */
  cons (4);
}

/* pseudo-op: .znop  <symbol name>
   behaviour: Issue a nop instruction
	      Issue a IMAGE_REL_PPC_IFGLUE relocation against it, using
	      the supplied symbol name.
   errors:    None
   warnings:  Missing symbol name  */

static void
ppc_znop (int ignore ATTRIBUTE_UNUSED)
{
  unsigned long insn;
  const struct powerpc_opcode *opcode;
  char *f;
  symbolS *sym;
  char *symbol_name;
  char c;
  char *name;

  /* Strip out the symbol name.  */
  symbol_name = input_line_pointer;
  c = get_symbol_end ();

  name = xmalloc (input_line_pointer - symbol_name + 1);
  strcpy (name, symbol_name);

  sym = symbol_find_or_make (name);

  *input_line_pointer = c;

  SKIP_WHITESPACE ();

  /* Look up the opcode in the hash table.  */
  opcode = (const struct powerpc_opcode *) hash_find (ppc_hash, "nop");

  /* Stick in the nop.  */
  insn = opcode->opcode;

  /* Write out the instruction.  */
  f = frag_more (4);
  md_number_to_chars (f, insn, 4);
  fix_new (frag_now,
	   f - frag_now->fr_literal,
	   4,
	   sym,
	   0,
	   0,
	   BFD_RELOC_16_GOT_PCREL);

}

/* pseudo-op:
   behaviour:
   errors:
   warnings:  */

static void
ppc_pe_comm (int lcomm)
{
  char *name;
  char c;
  char *p;
  offsetT temp;
  symbolS *symbolP;
  offsetT align;

  name = input_line_pointer;
  c = get_symbol_end ();

  /* just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after symbol-name: rest of line ignored."));
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ',' */
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
      ignore_rest_of_line ();
      return;
    }

  if (! lcomm)
    {
      /* The third argument to .comm is the alignment.  */
      if (*input_line_pointer != ',')
	align = 3;
      else
	{
	  ++input_line_pointer;
	  align = get_absolute_expression ();
	  if (align <= 0)
	    {
	      as_warn (_("ignoring bad alignment"));
	      align = 3;
	    }
	}
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);

  *p = c;
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("ignoring attempt to re-define symbol `%s'."),
	      S_GET_NAME (symbolP));
      ignore_rest_of_line ();
      return;
    }

  if (S_GET_VALUE (symbolP))
    {
      if (S_GET_VALUE (symbolP) != (valueT) temp)
	as_bad (_("length of .comm \"%s\" is already %ld. Not changed to %ld."),
		S_GET_NAME (symbolP),
		(long) S_GET_VALUE (symbolP),
		(long) temp);
    }
  else
    {
      S_SET_VALUE (symbolP, (valueT) temp);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
    }

  demand_empty_rest_of_line ();
}

/*
 * implement the .section pseudo op:
 *	.section name {, "flags"}
 *                ^         ^
 *                |         +--- optional flags: 'b' for bss
 *                |                              'i' for info
 *                +-- section name               'l' for lib
 *                                               'n' for noload
 *                                               'o' for over
 *                                               'w' for data
 *						 'd' (apparently m88k for data)
 *                                               'x' for text
 * But if the argument is not a quoted string, treat it as a
 * subsegment number.
 *
 * FIXME: this is a copy of the section processing from obj-coff.c, with
 * additions/changes for the moto-pas assembler support. There are three
 * categories:
 *
 * FIXME: I just noticed this. This doesn't work at all really. It it
 *        setting bits that bfd probably neither understands or uses. The
 *        correct approach (?) will have to incorporate extra fields attached
 *        to the section to hold the system specific stuff. (krk)
 *
 * Section Contents:
 * 'a' - unknown - referred to in documentation, but no definition supplied
 * 'c' - section has code
 * 'd' - section has initialized data
 * 'u' - section has uninitialized data
 * 'i' - section contains directives (info)
 * 'n' - section can be discarded
 * 'R' - remove section at link time
 *
 * Section Protection:
 * 'r' - section is readable
 * 'w' - section is writeable
 * 'x' - section is executable
 * 's' - section is sharable
 *
 * Section Alignment:
 * '0' - align to byte boundary
 * '1' - align to halfword undary
 * '2' - align to word boundary
 * '3' - align to doubleword boundary
 * '4' - align to quadword boundary
 * '5' - align to 32 byte boundary
 * '6' - align to 64 byte boundary
 *
 */

void
ppc_pe_section (int ignore ATTRIBUTE_UNUSED)
{
  /* Strip out the section name.  */
  char *section_name;
  char c;
  char *name;
  unsigned int exp;
  flagword flags;
  segT sec;
  int align;

  section_name = input_line_pointer;
  c = get_symbol_end ();

  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);

  *input_line_pointer = c;

  SKIP_WHITESPACE ();

  exp = 0;
  flags = SEC_NO_FLAGS;

  if (strcmp (name, ".idata$2") == 0)
    {
      align = 0;
    }
  else if (strcmp (name, ".idata$3") == 0)
    {
      align = 0;
    }
  else if (strcmp (name, ".idata$4") == 0)
    {
      align = 2;
    }
  else if (strcmp (name, ".idata$5") == 0)
    {
      align = 2;
    }
  else if (strcmp (name, ".idata$6") == 0)
    {
      align = 1;
    }
  else
    /* Default alignment to 16 byte boundary.  */
    align = 4;

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (*input_line_pointer != '"')
	exp = get_absolute_expression ();
      else
	{
	  ++input_line_pointer;
	  while (*input_line_pointer != '"'
		 && ! is_end_of_line[(unsigned char) *input_line_pointer])
	    {
	      switch (*input_line_pointer)
		{
		  /* Section Contents */
		case 'a': /* unknown */
		  as_bad (_("unsupported section attribute -- 'a'"));
		  break;
		case 'c': /* code section */
		  flags |= SEC_CODE;
		  break;
		case 'd': /* section has initialized data */
		  flags |= SEC_DATA;
		  break;
		case 'u': /* section has uninitialized data */
		  /* FIXME: This is IMAGE_SCN_CNT_UNINITIALIZED_DATA
		     in winnt.h */
		  flags |= SEC_ROM;
		  break;
		case 'i': /* section contains directives (info) */
		  /* FIXME: This is IMAGE_SCN_LNK_INFO
		     in winnt.h */
		  flags |= SEC_HAS_CONTENTS;
		  break;
		case 'n': /* section can be discarded */
		  flags &=~ SEC_LOAD;
		  break;
		case 'R': /* Remove section at link time */
		  flags |= SEC_NEVER_LOAD;
		  break;
#if IFLICT_BRAIN_DAMAGE
		  /* Section Protection */
		case 'r': /* section is readable */
		  flags |= IMAGE_SCN_MEM_READ;
		  break;
		case 'w': /* section is writeable */
		  flags |= IMAGE_SCN_MEM_WRITE;
		  break;
		case 'x': /* section is executable */
		  flags |= IMAGE_SCN_MEM_EXECUTE;
		  break;
		case 's': /* section is sharable */
		  flags |= IMAGE_SCN_MEM_SHARED;
		  break;

		  /* Section Alignment */
		case '0': /* align to byte boundary */
		  flags |= IMAGE_SCN_ALIGN_1BYTES;
		  align = 0;
		  break;
		case '1':  /* align to halfword boundary */
		  flags |= IMAGE_SCN_ALIGN_2BYTES;
		  align = 1;
		  break;
		case '2':  /* align to word boundary */
		  flags |= IMAGE_SCN_ALIGN_4BYTES;
		  align = 2;
		  break;
		case '3':  /* align to doubleword boundary */
		  flags |= IMAGE_SCN_ALIGN_8BYTES;
		  align = 3;
		  break;
		case '4':  /* align to quadword boundary */
		  flags |= IMAGE_SCN_ALIGN_16BYTES;
		  align = 4;
		  break;
		case '5':  /* align to 32 byte boundary */
		  flags |= IMAGE_SCN_ALIGN_32BYTES;
		  align = 5;
		  break;
		case '6':  /* align to 64 byte boundary */
		  flags |= IMAGE_SCN_ALIGN_64BYTES;
		  align = 6;
		  break;
#endif
		default:
		  as_bad (_("unknown section attribute '%c'"),
			  *input_line_pointer);
		  break;
		}
	      ++input_line_pointer;
	    }
	  if (*input_line_pointer == '"')
	    ++input_line_pointer;
	}
    }

  sec = subseg_new (name, (subsegT) exp);

  ppc_set_current_section (sec);

  if (flags != SEC_NO_FLAGS)
    {
      if (! bfd_set_section_flags (stdoutput, sec, flags))
	as_bad (_("error setting flags for \"%s\": %s"),
		bfd_section_name (stdoutput, sec),
		bfd_errmsg (bfd_get_error ()));
    }

  bfd_set_section_alignment (stdoutput, sec, align);
}

static void
ppc_pe_function (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char endc;
  symbolS *ext_sym;

  name = input_line_pointer;
  endc = get_symbol_end ();

  ext_sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  S_SET_DATA_TYPE (ext_sym, DT_FCN << N_BTSHFT);
  SF_SET_FUNCTION (ext_sym);
  SF_SET_PROCESS (ext_sym);
  coff_add_linesym (ext_sym);

  demand_empty_rest_of_line ();
}

static void
ppc_pe_tocd (int ignore ATTRIBUTE_UNUSED)
{
  if (tocdata_section == 0)
    {
      tocdata_section = subseg_new (".tocd", 0);
      /* FIXME: section flags won't work.  */
      bfd_set_section_flags (stdoutput, tocdata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_READONLY | SEC_DATA));

      bfd_set_section_alignment (stdoutput, tocdata_section, 2);
    }
  else
    {
      rdata_section = subseg_new (".tocd", 0);
    }

  ppc_set_current_section (tocdata_section);

  demand_empty_rest_of_line ();
}

/* Don't adjust TOC relocs to use the section symbol.  */

int
ppc_pe_fix_adjustable (fixS *fix)
{
  return fix->fx_r_type != BFD_RELOC_PPC_TOC16;
}

#endif

#ifdef OBJ_XCOFF

/* XCOFF specific symbol and file handling.  */

/* Canonicalize the symbol name.  We use the to force the suffix, if
   any, to use square brackets, and to be in upper case.  */

char *
ppc_canonicalize_symbol_name (char *name)
{
  char *s;

  if (ppc_stab_symbol)
    return name;

  for (s = name; *s != '\0' && *s != '{' && *s != '['; s++)
    ;
  if (*s != '\0')
    {
      char brac;

      if (*s == '[')
	brac = ']';
      else
	{
	  *s = '[';
	  brac = '}';
	}

      for (s++; *s != '\0' && *s != brac; s++)
	*s = TOUPPER (*s);

      if (*s == '\0' || s[1] != '\0')
	as_bad (_("bad symbol suffix"));

      *s = ']';
    }

  return name;
}

/* Set the class of a symbol based on the suffix, if any.  This is
   called whenever a new symbol is created.  */

void
ppc_symbol_new_hook (symbolS *sym)
{
  struct ppc_tc_sy *tc;
  const char *s;

  tc = symbol_get_tc (sym);
  tc->next = NULL;
  tc->output = 0;
  tc->symbol_class = -1;
  tc->real_name = NULL;
  tc->subseg = 0;
  tc->align = 0;
  tc->u.size = NULL;
  tc->u.dw = NULL;
  tc->within = NULL;

  if (ppc_stab_symbol)
    return;

  s = strchr (S_GET_NAME (sym), '[');
  if (s == (const char *) NULL)
    {
      /* There is no suffix.  */
      return;
    }

  ++s;

  switch (s[0])
    {
    case 'B':
      if (strcmp (s, "BS]") == 0)
	tc->symbol_class = XMC_BS;
      break;
    case 'D':
      if (strcmp (s, "DB]") == 0)
	tc->symbol_class = XMC_DB;
      else if (strcmp (s, "DS]") == 0)
	tc->symbol_class = XMC_DS;
      break;
    case 'G':
      if (strcmp (s, "GL]") == 0)
	tc->symbol_class = XMC_GL;
      break;
    case 'P':
      if (strcmp (s, "PR]") == 0)
	tc->symbol_class = XMC_PR;
      break;
    case 'R':
      if (strcmp (s, "RO]") == 0)
	tc->symbol_class = XMC_RO;
      else if (strcmp (s, "RW]") == 0)
	tc->symbol_class = XMC_RW;
      break;
    case 'S':
      if (strcmp (s, "SV]") == 0)
	tc->symbol_class = XMC_SV;
      break;
    case 'T':
      if (strcmp (s, "TC]") == 0)
	tc->symbol_class = XMC_TC;
      else if (strcmp (s, "TI]") == 0)
	tc->symbol_class = XMC_TI;
      else if (strcmp (s, "TB]") == 0)
	tc->symbol_class = XMC_TB;
      else if (strcmp (s, "TC0]") == 0 || strcmp (s, "T0]") == 0)
	tc->symbol_class = XMC_TC0;
      break;
    case 'U':
      if (strcmp (s, "UA]") == 0)
	tc->symbol_class = XMC_UA;
      else if (strcmp (s, "UC]") == 0)
	tc->symbol_class = XMC_UC;
      break;
    case 'X':
      if (strcmp (s, "XO]") == 0)
	tc->symbol_class = XMC_XO;
      break;
    }

  if (tc->symbol_class == -1)
    as_bad (_("unrecognized symbol suffix"));
}

/* Set the class of a label based on where it is defined.  This
   handles symbols without suffixes.  Also, move the symbol so that it
   follows the csect symbol.  */

void
ppc_frob_label (symbolS *sym)
{
  if (ppc_current_csect != (symbolS *) NULL)
    {
      if (symbol_get_tc (sym)->symbol_class == -1)
	symbol_get_tc (sym)->symbol_class = symbol_get_tc (ppc_current_csect)->symbol_class;

      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_append (sym, symbol_get_tc (ppc_current_csect)->within,
		     &symbol_rootP, &symbol_lastP);
      symbol_get_tc (ppc_current_csect)->within = sym;
      symbol_get_tc (sym)->within = ppc_current_csect;
    }

#ifdef OBJ_ELF
  dwarf2_emit_label (sym);
#endif
}

/* This variable is set by ppc_frob_symbol if any absolute symbols are
   seen.  It tells ppc_adjust_symtab whether it needs to look through
   the symbols.  */

static bfd_boolean ppc_saw_abs;

/* Change the name of a symbol just before writing it out.  Set the
   real name if the .rename pseudo-op was used.  Otherwise, remove any
   class suffix.  Return 1 if the symbol should not be included in the
   symbol table.  */

int
ppc_frob_symbol (symbolS *sym)
{
  static symbolS *ppc_last_function;
  static symbolS *set_end;

  /* Discard symbols that should not be included in the output symbol
     table.  */
  if (! symbol_used_in_reloc_p (sym)
      && ((symbol_get_bfdsym (sym)->flags & BSF_SECTION_SYM) != 0
	  || (! (S_IS_EXTERNAL (sym) || S_IS_WEAK (sym))
	      && ! symbol_get_tc (sym)->output
	      && S_GET_STORAGE_CLASS (sym) != C_FILE)))
    return 1;

  /* This one will disappear anyway.  Don't make a csect sym for it.  */
  if (sym == abs_section_sym)
    return 1;

  if (symbol_get_tc (sym)->real_name != (char *) NULL)
    S_SET_NAME (sym, symbol_get_tc (sym)->real_name);
  else
    {
      const char *name;
      const char *s;

      name = S_GET_NAME (sym);
      s = strchr (name, '[');
      if (s != (char *) NULL)
	{
	  unsigned int len;
	  char *snew;

	  len = s - name;
	  snew = xmalloc (len + 1);
	  memcpy (snew, name, len);
	  snew[len] = '\0';

	  S_SET_NAME (sym, snew);
	}
    }

  if (set_end != (symbolS *) NULL)
    {
      SA_SET_SYM_ENDNDX (set_end, sym);
      set_end = NULL;
    }

  if (SF_GET_FUNCTION (sym))
    {
      if (ppc_last_function != (symbolS *) NULL)
	as_bad (_("two .function pseudo-ops with no intervening .ef"));
      ppc_last_function = sym;
      if (symbol_get_tc (sym)->u.size != (symbolS *) NULL)
	{
	  resolve_symbol_value (symbol_get_tc (sym)->u.size);
	  SA_SET_SYM_FSIZE (sym,
			    (long) S_GET_VALUE (symbol_get_tc (sym)->u.size));
	}
    }
  else if (S_GET_STORAGE_CLASS (sym) == C_FCN
	   && strcmp (S_GET_NAME (sym), ".ef") == 0)
    {
      if (ppc_last_function == (symbolS *) NULL)
	as_bad (_(".ef with no preceding .function"));
      else
	{
	  set_end = ppc_last_function;
	  ppc_last_function = NULL;

	  /* We don't have a C_EFCN symbol, but we need to force the
	     COFF backend to believe that it has seen one.  */
	  coff_last_function = NULL;
	}
    }

  if (! (S_IS_EXTERNAL (sym) || S_IS_WEAK (sym))
      && (symbol_get_bfdsym (sym)->flags & BSF_SECTION_SYM) == 0
      && S_GET_STORAGE_CLASS (sym) != C_FILE
      && S_GET_STORAGE_CLASS (sym) != C_FCN
      && S_GET_STORAGE_CLASS (sym) != C_BLOCK
      && S_GET_STORAGE_CLASS (sym) != C_BSTAT
      && S_GET_STORAGE_CLASS (sym) != C_ESTAT
      && S_GET_STORAGE_CLASS (sym) != C_BINCL
      && S_GET_STORAGE_CLASS (sym) != C_EINCL
      && S_GET_SEGMENT (sym) != ppc_coff_debug_section)
    S_SET_STORAGE_CLASS (sym, C_HIDEXT);

  if (S_GET_STORAGE_CLASS (sym) == C_EXT
      || S_GET_STORAGE_CLASS (sym) == C_AIX_WEAKEXT
      || S_GET_STORAGE_CLASS (sym) == C_HIDEXT)
    {
      int i;
      union internal_auxent *a;

      /* Create a csect aux.  */
      i = S_GET_NUMBER_AUXILIARY (sym);
      S_SET_NUMBER_AUXILIARY (sym, i + 1);
      a = &coffsymbol (symbol_get_bfdsym (sym))->native[i + 1].u.auxent;
      if (symbol_get_tc (sym)->symbol_class == XMC_TC0)
	{
	  /* This is the TOC table.  */
	  know (strcmp (S_GET_NAME (sym), "TOC") == 0);
	  a->x_csect.x_scnlen.l = 0;
	  a->x_csect.x_smtyp = (2 << 3) | XTY_SD;
	}
      else if (symbol_get_tc (sym)->subseg != 0)
	{
	  /* This is a csect symbol.  x_scnlen is the size of the
	     csect.  */
	  if (symbol_get_tc (sym)->next == (symbolS *) NULL)
	    a->x_csect.x_scnlen.l = (bfd_section_size (stdoutput,
						       S_GET_SEGMENT (sym))
				     - S_GET_VALUE (sym));
	  else
	    {
	      resolve_symbol_value (symbol_get_tc (sym)->next);
	      a->x_csect.x_scnlen.l = (S_GET_VALUE (symbol_get_tc (sym)->next)
				       - S_GET_VALUE (sym));
	    }
	  a->x_csect.x_smtyp = (symbol_get_tc (sym)->align << 3) | XTY_SD;
	}
      else if (S_GET_SEGMENT (sym) == bss_section)
	{
	  /* This is a common symbol.  */
	  a->x_csect.x_scnlen.l = symbol_get_frag (sym)->fr_offset;
	  a->x_csect.x_smtyp = (symbol_get_tc (sym)->align << 3) | XTY_CM;
	  if (S_IS_EXTERNAL (sym))
	    symbol_get_tc (sym)->symbol_class = XMC_RW;
	  else
	    symbol_get_tc (sym)->symbol_class = XMC_BS;
	}
      else if (S_GET_SEGMENT (sym) == absolute_section)
	{
	  /* This is an absolute symbol.  The csect will be created by
	     ppc_adjust_symtab.  */
	  ppc_saw_abs = TRUE;
	  a->x_csect.x_smtyp = XTY_LD;
	  if (symbol_get_tc (sym)->symbol_class == -1)
	    symbol_get_tc (sym)->symbol_class = XMC_XO;
	}
      else if (! S_IS_DEFINED (sym))
	{
	  /* This is an external symbol.  */
	  a->x_csect.x_scnlen.l = 0;
	  a->x_csect.x_smtyp = XTY_ER;
	}
      else if (symbol_get_tc (sym)->symbol_class == XMC_TC)
	{
	  symbolS *next;

	  /* This is a TOC definition.  x_scnlen is the size of the
	     TOC entry.  */
	  next = symbol_next (sym);
	  while (symbol_get_tc (next)->symbol_class == XMC_TC0)
	    next = symbol_next (next);
	  if (next == (symbolS *) NULL
	      || symbol_get_tc (next)->symbol_class != XMC_TC)
	    {
	      if (ppc_after_toc_frag == (fragS *) NULL)
		a->x_csect.x_scnlen.l = (bfd_section_size (stdoutput,
							   data_section)
					 - S_GET_VALUE (sym));
	      else
		a->x_csect.x_scnlen.l = (ppc_after_toc_frag->fr_address
					 - S_GET_VALUE (sym));
	    }
	  else
	    {
	      resolve_symbol_value (next);
	      a->x_csect.x_scnlen.l = (S_GET_VALUE (next)
				       - S_GET_VALUE (sym));
	    }
	  a->x_csect.x_smtyp = (2 << 3) | XTY_SD;
	}
      else
	{
	  symbolS *csect;

	  /* This is a normal symbol definition.  x_scnlen is the
	     symbol index of the containing csect.  */
	  if (S_GET_SEGMENT (sym) == text_section)
	    csect = ppc_text_csects;
	  else if (S_GET_SEGMENT (sym) == data_section)
	    csect = ppc_data_csects;
	  else
	    abort ();

	  /* Skip the initial dummy symbol.  */
	  csect = symbol_get_tc (csect)->next;

	  if (csect == (symbolS *) NULL)
	    {
	      as_warn (_("warning: symbol %s has no csect"), S_GET_NAME (sym));
	      a->x_csect.x_scnlen.l = 0;
	    }
	  else
	    {
	      while (symbol_get_tc (csect)->next != (symbolS *) NULL)
		{
		  resolve_symbol_value (symbol_get_tc (csect)->next);
		  if (S_GET_VALUE (symbol_get_tc (csect)->next)
		      > S_GET_VALUE (sym))
		    break;
		  csect = symbol_get_tc (csect)->next;
		}

	      a->x_csect.x_scnlen.p =
		coffsymbol (symbol_get_bfdsym (csect))->native;
	      coffsymbol (symbol_get_bfdsym (sym))->native[i + 1].fix_scnlen =
		1;
	    }
	  a->x_csect.x_smtyp = XTY_LD;
	}

      a->x_csect.x_parmhash = 0;
      a->x_csect.x_snhash = 0;
      if (symbol_get_tc (sym)->symbol_class == -1)
	a->x_csect.x_smclas = XMC_PR;
      else
	a->x_csect.x_smclas = symbol_get_tc (sym)->symbol_class;
      a->x_csect.x_stab = 0;
      a->x_csect.x_snstab = 0;

      /* Don't let the COFF backend resort these symbols.  */
      symbol_get_bfdsym (sym)->flags |= BSF_NOT_AT_END;
    }
  else if (S_GET_STORAGE_CLASS (sym) == C_BSTAT)
    {
      /* We want the value to be the symbol index of the referenced
	 csect symbol.  BFD will do that for us if we set the right
	 flags.  */
      asymbol *bsym = symbol_get_bfdsym (symbol_get_tc (sym)->within);
      combined_entry_type *c = coffsymbol (bsym)->native;

      S_SET_VALUE (sym, (valueT) (size_t) c);
      coffsymbol (symbol_get_bfdsym (sym))->native->fix_value = 1;
    }
  else if (S_GET_STORAGE_CLASS (sym) == C_STSYM)
    {
      symbolS *block;
      valueT base;

      block = symbol_get_tc (sym)->within;
      if (block)
        {
          /* The value is the offset from the enclosing csect.  */
          symbolS *csect;

          csect = symbol_get_tc (block)->within;
          resolve_symbol_value (csect);
          base = S_GET_VALUE (csect);
        }
      else
        base = 0;

      S_SET_VALUE (sym, S_GET_VALUE (sym) - base);
    }
  else if (S_GET_STORAGE_CLASS (sym) == C_BINCL
	   || S_GET_STORAGE_CLASS (sym) == C_EINCL)
    {
      /* We want the value to be a file offset into the line numbers.
	 BFD will do that for us if we set the right flags.  We have
	 already set the value correctly.  */
      coffsymbol (symbol_get_bfdsym (sym))->native->fix_line = 1;
    }

  return 0;
}

/* Adjust the symbol table.  This creates csect symbols for all
   absolute symbols.  */

void
ppc_adjust_symtab (void)
{
  symbolS *sym;

  if (! ppc_saw_abs)
    return;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      symbolS *csect;
      int i;
      union internal_auxent *a;

      if (S_GET_SEGMENT (sym) != absolute_section)
	continue;

      csect = symbol_create (".abs[XO]", absolute_section,
			     S_GET_VALUE (sym), &zero_address_frag);
      symbol_get_bfdsym (csect)->value = S_GET_VALUE (sym);
      S_SET_STORAGE_CLASS (csect, C_HIDEXT);
      i = S_GET_NUMBER_AUXILIARY (csect);
      S_SET_NUMBER_AUXILIARY (csect, i + 1);
      a = &coffsymbol (symbol_get_bfdsym (csect))->native[i + 1].u.auxent;
      a->x_csect.x_scnlen.l = 0;
      a->x_csect.x_smtyp = XTY_SD;
      a->x_csect.x_parmhash = 0;
      a->x_csect.x_snhash = 0;
      a->x_csect.x_smclas = XMC_XO;
      a->x_csect.x_stab = 0;
      a->x_csect.x_snstab = 0;

      symbol_insert (csect, sym, &symbol_rootP, &symbol_lastP);

      i = S_GET_NUMBER_AUXILIARY (sym);
      a = &coffsymbol (symbol_get_bfdsym (sym))->native[i].u.auxent;
      a->x_csect.x_scnlen.p = coffsymbol (symbol_get_bfdsym (csect))->native;
      coffsymbol (symbol_get_bfdsym (sym))->native[i].fix_scnlen = 1;
    }

  ppc_saw_abs = FALSE;
}

/* Set the VMA for a section.  This is called on all the sections in
   turn.  */

void
ppc_frob_section (asection *sec)
{
  static bfd_vma vma = 0;

  /* Dwarf sections start at 0.  */
  if (bfd_get_section_flags (NULL, sec) & SEC_DEBUGGING)
    return;

  vma = md_section_align (sec, vma);
  bfd_set_section_vma (stdoutput, sec, vma);
  vma += bfd_section_size (stdoutput, sec);
}

#endif /* OBJ_XCOFF */

char *
md_atof (int type, char *litp, int *sizep)
{
  return ieee_md_atof (type, litp, sizep, target_big_endian);
}

/* Write a value out to the object file, using the appropriate
   endianness.  */

void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

/* Align a section (I don't know why this is machine dependent).  */

valueT
md_section_align (asection *seg ATTRIBUTE_UNUSED, valueT addr)
{
#ifdef OBJ_ELF
  return addr;
#else
  int align = bfd_get_section_alignment (stdoutput, seg);

  return ((addr + (1 << align) - 1) & (-1 << align));
#endif
}

/* We don't have any form of relaxing.  */

int
md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
			       asection *seg ATTRIBUTE_UNUSED)
{
  abort ();
  return 0;
}

/* Convert a machine dependent frag.  We never generate these.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec ATTRIBUTE_UNUSED,
		 fragS *fragp ATTRIBUTE_UNUSED)
{
  abort ();
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Functions concerning relocs.  */

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from_section (fixS *fixp, segT sec ATTRIBUTE_UNUSED)
{
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

#ifdef OBJ_XCOFF

/* This is called to see whether a fixup should be adjusted to use a
   section symbol.  We take the opportunity to change a fixup against
   a symbol in the TOC subsegment into a reloc against the
   corresponding .tc symbol.  */

int
ppc_fix_adjustable (fixS *fix)
{
  valueT val = resolve_symbol_value (fix->fx_addsy);
  segT symseg = S_GET_SEGMENT (fix->fx_addsy);
  TC_SYMFIELD_TYPE *tc;

  if (symseg == absolute_section)
    return 0;

  /* Always adjust symbols in debugging sections.  */
  if (bfd_get_section_flags (stdoutput, symseg) & SEC_DEBUGGING)
    return 1;

  if (ppc_toc_csect != (symbolS *) NULL
      && fix->fx_addsy != ppc_toc_csect
      && symseg == data_section
      && val >= ppc_toc_frag->fr_address
      && (ppc_after_toc_frag == (fragS *) NULL
	  || val < ppc_after_toc_frag->fr_address))
    {
      symbolS *sy;

      for (sy = symbol_next (ppc_toc_csect);
	   sy != (symbolS *) NULL;
	   sy = symbol_next (sy))
	{
	  TC_SYMFIELD_TYPE *sy_tc = symbol_get_tc (sy);

	  if (sy_tc->symbol_class == XMC_TC0)
	    continue;
	  if (sy_tc->symbol_class != XMC_TC)
	    break;
	  if (val == resolve_symbol_value (sy))
	    {
	      fix->fx_addsy = sy;
	      fix->fx_addnumber = val - ppc_toc_frag->fr_address;
	      return 0;
	    }
	}

      as_bad_where (fix->fx_file, fix->fx_line,
		    _("symbol in .toc does not match any .tc"));
    }

  /* Possibly adjust the reloc to be against the csect.  */
  tc = symbol_get_tc (fix->fx_addsy);
  if (tc->subseg == 0
      && tc->symbol_class != XMC_TC0
      && tc->symbol_class != XMC_TC
      && symseg != bss_section
      /* Don't adjust if this is a reloc in the toc section.  */
      && (symseg != data_section
	  || ppc_toc_csect == NULL
	  || val < ppc_toc_frag->fr_address
	  || (ppc_after_toc_frag != NULL
	      && val >= ppc_after_toc_frag->fr_address)))
    {
      symbolS *csect = tc->within;

      /* If the symbol was not declared by a label (eg: a section symbol),
         use the section instead of the csect.  This doesn't happen in
         normal AIX assembly code.  */
      if (csect == NULL)
        csect = seg_info (symseg)->sym;

      fix->fx_offset += val - symbol_get_frag (csect)->fr_address;
      fix->fx_addsy = csect;

      return 0;
    }

  /* Adjust a reloc against a .lcomm symbol to be against the base
     .lcomm.  */
  if (symseg == bss_section
      && ! S_IS_EXTERNAL (fix->fx_addsy))
    {
      symbolS *sy = symbol_get_frag (fix->fx_addsy)->fr_symbol;

      fix->fx_offset += val - resolve_symbol_value (sy);
      fix->fx_addsy = sy;
    }

  return 0;
}

/* A reloc from one csect to another must be kept.  The assembler
   will, of course, keep relocs between sections, and it will keep
   absolute relocs, but we need to force it to keep PC relative relocs
   between two csects in the same section.  */

int
ppc_force_relocation (fixS *fix)
{
  /* At this point fix->fx_addsy should already have been converted to
     a csect symbol.  If the csect does not include the fragment, then
     we need to force the relocation.  */
  if (fix->fx_pcrel
      && fix->fx_addsy != NULL
      && symbol_get_tc (fix->fx_addsy)->subseg != 0
      && ((symbol_get_frag (fix->fx_addsy)->fr_address
	   > fix->fx_frag->fr_address)
	  || (symbol_get_tc (fix->fx_addsy)->next != NULL
	      && (symbol_get_frag (symbol_get_tc (fix->fx_addsy)->next)->fr_address
		  <= fix->fx_frag->fr_address))))
    return 1;

  return generic_force_reloc (fix);
}

void
ppc_new_dot_label (symbolS *sym)
{
  /* Anchor this label to the current csect for relocations.  */
  symbol_get_tc (sym)->within = ppc_current_csect;
}

#endif /* OBJ_XCOFF */

#ifdef OBJ_ELF
/* If this function returns non-zero, it guarantees that a relocation
   will be emitted for a fixup.  */

int
ppc_force_relocation (fixS *fix)
{
  /* Branch prediction relocations must force a relocation, as must
     the vtable description relocs.  */
  switch (fix->fx_r_type)
    {
    case BFD_RELOC_PPC_B16_BRTAKEN:
    case BFD_RELOC_PPC_B16_BRNTAKEN:
    case BFD_RELOC_PPC_BA16_BRTAKEN:
    case BFD_RELOC_PPC_BA16_BRNTAKEN:
    case BFD_RELOC_24_PLT_PCREL:
    case BFD_RELOC_PPC64_TOC:
      return 1;
    default:
      break;
    }

  if (fix->fx_r_type >= BFD_RELOC_PPC_TLS
      && fix->fx_r_type <= BFD_RELOC_PPC64_DTPREL16_HIGHESTA)
    return 1;

  return generic_force_reloc (fix);
}

int
ppc_fix_adjustable (fixS *fix)
{
  return (fix->fx_r_type != BFD_RELOC_16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_LO16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_HI16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_HI16_S_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_PPC64_GOT16_DS
	  && fix->fx_r_type != BFD_RELOC_PPC64_GOT16_LO_DS
	  && fix->fx_r_type != BFD_RELOC_GPREL16
	  && fix->fx_r_type != BFD_RELOC_VTABLE_INHERIT
	  && fix->fx_r_type != BFD_RELOC_VTABLE_ENTRY
	  && !(fix->fx_r_type >= BFD_RELOC_PPC_TLS
	       && fix->fx_r_type <= BFD_RELOC_PPC64_DTPREL16_HIGHESTA));
}
#endif

void
ppc_frag_check (struct frag *fragP)
{
  if (!fragP->has_code)
    return;

  if (ppc_mach() == bfd_mach_ppc_vle)
    {
      if (((fragP->fr_address + fragP->insn_addr) & 1) != 0)
        as_bad (_("instruction address is not a multiple of 2"));
    }
  else
    {
      if (((fragP->fr_address + fragP->insn_addr) & 3) != 0)
        as_bad (_("instruction address is not a multiple of 4"));
    }
}

/* Implement HANDLE_ALIGN.  This writes the NOP pattern into an
   rs_align_code frag.  */

void
ppc_handle_align (struct frag *fragP)
{
  valueT count = (fragP->fr_next->fr_address
		  - (fragP->fr_address + fragP->fr_fix));

  if (ppc_mach() == bfd_mach_ppc_vle && count != 0 && (count & 1) == 0)
    {
      char *dest = fragP->fr_literal + fragP->fr_fix;

      fragP->fr_var = 2;
      md_number_to_chars (dest, 0x4400, 2);
    }
  else if (count != 0 && (count & 3) == 0)
    {
      char *dest = fragP->fr_literal + fragP->fr_fix;

      fragP->fr_var = 4;

      if (count > 4 * nop_limit && count < 0x2000000)
	{
	  struct frag *rest;

	  /* Make a branch, then follow with nops.  Insert another
	     frag to handle the nops.  */
	  md_number_to_chars (dest, 0x48000000 + count, 4);
	  count -= 4;
	  if (count == 0)
	    return;

	  rest = xmalloc (SIZEOF_STRUCT_FRAG + 4);
	  memcpy (rest, fragP, SIZEOF_STRUCT_FRAG);
	  fragP->fr_next = rest;
	  fragP = rest;
	  rest->fr_address += rest->fr_fix + 4;
	  rest->fr_fix = 0;
	  /* If we leave the next frag as rs_align_code we'll come here
	     again, resulting in a bunch of branches rather than a
	     branch followed by nops.  */
	  rest->fr_type = rs_align;
	  dest = rest->fr_literal;
	}

      md_number_to_chars (dest, 0x60000000, 4);

      if ((ppc_cpu & PPC_OPCODE_POWER6) != 0
	  || (ppc_cpu & PPC_OPCODE_POWER7) != 0
	  || (ppc_cpu & PPC_OPCODE_POWER8) != 0)
	{
	  /* For power6, power7 and power8, we want the last nop to be a group
	     terminating one.  Do this by inserting an rs_fill frag immediately
	     after this one, with its address set to the last nop location.
	     This will automatically reduce the number of nops in the current
	     frag by one.  */
	  if (count > 4)
	    {
	      struct frag *group_nop = xmalloc (SIZEOF_STRUCT_FRAG + 4);

	      memcpy (group_nop, fragP, SIZEOF_STRUCT_FRAG);
	      group_nop->fr_address = group_nop->fr_next->fr_address - 4;
	      group_nop->fr_fix = 0;
	      group_nop->fr_offset = 1;
	      group_nop->fr_type = rs_fill;
	      fragP->fr_next = group_nop;
	      dest = group_nop->fr_literal;
	    }

	  if ((ppc_cpu & PPC_OPCODE_POWER7) != 0
	      || (ppc_cpu & PPC_OPCODE_POWER8) != 0)
	    {
	      if (ppc_cpu & PPC_OPCODE_E500MC)
		/* e500mc group terminating nop: "ori 0,0,0".  */
		md_number_to_chars (dest, 0x60000000, 4);
	      else
		/* power7/power8 group terminating nop: "ori 2,2,0".  */
		md_number_to_chars (dest, 0x60420000, 4);
	    }
	  else
	    /* power6 group terminating nop: "ori 1,1,0".  */
	    md_number_to_chars (dest, 0x60210000, 4);
	}
    }
}

/* Apply a fixup to the object code.  This is called for all the
   fixups we generated by the calls to fix_new_exp, above.  */

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  valueT value = * valP;
  offsetT fieldval;
  const struct powerpc_operand *operand;

#ifdef OBJ_ELF
  if (fixP->fx_addsy != NULL)
    {
      /* Hack around bfd_install_relocation brain damage.  */
      if (fixP->fx_pcrel)
	value += fixP->fx_frag->fr_address + fixP->fx_where;
    }
  else
    fixP->fx_done = 1;
#else
  /* FIXME FIXME FIXME: The value we are passed in *valP includes
     the symbol values.  If we are doing this relocation the code in
     write.c is going to call bfd_install_relocation, which is also
     going to use the symbol value.  That means that if the reloc is
     fully resolved we want to use *valP since bfd_install_relocation is
     not being used.
     However, if the reloc is not fully resolved we do not want to
     use *valP, and must use fx_offset instead.  If the relocation
     is PC-relative, we then need to re-apply md_pcrel_from_section
     to this new relocation value.  */
  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  else
    {
      value = fixP->fx_offset;
      if (fixP->fx_pcrel)
	value -= md_pcrel_from_section (fixP, seg);
    }
#endif

  if (fixP->fx_subsy != (symbolS *) NULL)
    {
      /* We can't actually support subtracting a symbol.  */
      as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));
    }

  operand = NULL;
  if (fixP->fx_pcrel_adjust != 0)
    {
      /* This is a fixup on an instruction.  */
      int opindex = fixP->fx_pcrel_adjust & 0xff;

      operand = &powerpc_operands[opindex];
#ifdef OBJ_XCOFF
      /* An instruction like `lwz 9,sym(30)' when `sym' is not a TOC symbol
	 does not generate a reloc.  It uses the offset of `sym' within its
	 csect.  Other usages, such as `.long sym', generate relocs.  This
	 is the documented behaviour of non-TOC symbols.  */
      if ((operand->flags & PPC_OPERAND_PARENS) != 0
	  && (operand->bitm & 0xfff0) == 0xfff0
	  && operand->shift == 0
	  && (operand->insert == NULL || ppc_obj64)
	  && fixP->fx_addsy != NULL
	  && symbol_get_tc (fixP->fx_addsy)->subseg != 0
	  && symbol_get_tc (fixP->fx_addsy)->symbol_class != XMC_TC
	  && symbol_get_tc (fixP->fx_addsy)->symbol_class != XMC_TC0
	  && S_GET_SEGMENT (fixP->fx_addsy) != bss_section)
	{
	  value = fixP->fx_offset;
	  fixP->fx_done = 1;
	}

       /* During parsing of instructions, a TOC16 reloc is generated for
          instructions such as 'lwz RT,SYM(RB)' if SYM is a symbol defined
          in the toc.  But at parse time, SYM may be not yet defined, so
          check again here.  */
       if (fixP->fx_r_type == BFD_RELOC_16
           && fixP->fx_addsy != NULL
           && ppc_is_toc_sym (fixP->fx_addsy))
         fixP->fx_r_type = BFD_RELOC_PPC_TOC16;
#endif
    }

  /* Calculate value to be stored in field.  */
  fieldval = value;
  switch (fixP->fx_r_type)
    {
#ifdef OBJ_ELF
    case BFD_RELOC_PPC64_ADDR16_LO_DS:
    case BFD_RELOC_PPC_VLE_LO16A:
    case BFD_RELOC_PPC_VLE_LO16D:
#endif
    case BFD_RELOC_LO16:
    case BFD_RELOC_LO16_PCREL:
      fieldval = value & 0xffff;
    sign_extend_16:
      if (operand != NULL && (operand->flags & PPC_OPERAND_SIGNED) != 0)
	fieldval = (fieldval ^ 0x8000) - 0x8000;
      fixP->fx_no_overflow = 1;
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_PPC_VLE_HI16A:
    case BFD_RELOC_PPC_VLE_HI16D:
#endif
    case BFD_RELOC_HI16:
    case BFD_RELOC_HI16_PCREL:
      fieldval = PPC_HI (value);
      goto sign_extend_16;

#ifdef OBJ_ELF
    case BFD_RELOC_PPC_VLE_HA16A:
    case BFD_RELOC_PPC_VLE_HA16D:
#endif
    case BFD_RELOC_HI16_S:
    case BFD_RELOC_HI16_S_PCREL:
      fieldval = PPC_HA (value);
      goto sign_extend_16;

#ifdef OBJ_ELF
    case BFD_RELOC_PPC64_HIGHER:
      fieldval = PPC_HIGHER (value);
      goto sign_extend_16;

    case BFD_RELOC_PPC64_HIGHER_S:
      fieldval = PPC_HIGHERA (value);
      goto sign_extend_16;

    case BFD_RELOC_PPC64_HIGHEST:
      fieldval = PPC_HIGHEST (value);
      goto sign_extend_16;

    case BFD_RELOC_PPC64_HIGHEST_S:
      fieldval = PPC_HIGHESTA (value);
      goto sign_extend_16;
#endif

    default:
      break;
    }

  if (operand != NULL)
    {
      /* Handle relocs in an insn.  */
      char *where;
      unsigned long insn;

      switch (fixP->fx_r_type)
	{
#ifdef OBJ_ELF
	  /* The following relocs can't be calculated by the assembler.
	     Leave the field zero.  */
	case BFD_RELOC_PPC_TPREL16:
	case BFD_RELOC_PPC_TPREL16_LO:
	case BFD_RELOC_PPC_TPREL16_HI:
	case BFD_RELOC_PPC_TPREL16_HA:
	case BFD_RELOC_PPC_DTPREL16:
	case BFD_RELOC_PPC_DTPREL16_LO:
	case BFD_RELOC_PPC_DTPREL16_HI:
	case BFD_RELOC_PPC_DTPREL16_HA:
	case BFD_RELOC_PPC_GOT_TLSGD16:
	case BFD_RELOC_PPC_GOT_TLSGD16_LO:
	case BFD_RELOC_PPC_GOT_TLSGD16_HI:
	case BFD_RELOC_PPC_GOT_TLSGD16_HA:
	case BFD_RELOC_PPC_GOT_TLSLD16:
	case BFD_RELOC_PPC_GOT_TLSLD16_LO:
	case BFD_RELOC_PPC_GOT_TLSLD16_HI:
	case BFD_RELOC_PPC_GOT_TLSLD16_HA:
	case BFD_RELOC_PPC_GOT_TPREL16:
	case BFD_RELOC_PPC_GOT_TPREL16_LO:
	case BFD_RELOC_PPC_GOT_TPREL16_HI:
	case BFD_RELOC_PPC_GOT_TPREL16_HA:
	case BFD_RELOC_PPC_GOT_DTPREL16:
	case BFD_RELOC_PPC_GOT_DTPREL16_LO:
	case BFD_RELOC_PPC_GOT_DTPREL16_HI:
	case BFD_RELOC_PPC_GOT_DTPREL16_HA:
	case BFD_RELOC_PPC64_TPREL16_DS:
	case BFD_RELOC_PPC64_TPREL16_LO_DS:
	case BFD_RELOC_PPC64_TPREL16_HIGHER:
	case BFD_RELOC_PPC64_TPREL16_HIGHERA:
	case BFD_RELOC_PPC64_TPREL16_HIGHEST:
	case BFD_RELOC_PPC64_TPREL16_HIGHESTA:
	case BFD_RELOC_PPC64_DTPREL16_DS:
	case BFD_RELOC_PPC64_DTPREL16_LO_DS:
	case BFD_RELOC_PPC64_DTPREL16_HIGHER:
	case BFD_RELOC_PPC64_DTPREL16_HIGHERA:
	case BFD_RELOC_PPC64_DTPREL16_HIGHEST:
	case BFD_RELOC_PPC64_DTPREL16_HIGHESTA:
	  gas_assert (fixP->fx_addsy != NULL);
	  S_SET_THREAD_LOCAL (fixP->fx_addsy);
	  fieldval = 0;
	  break;

	  /* These also should leave the field zero for the same
	     reason.  Note that older versions of gas wrote values
	     here.  If we want to go back to the old behaviour, then
	     all _LO and _LO_DS cases will need to be treated like
	     BFD_RELOC_LO16_PCREL above.  Similarly for _HI etc.  */
	case BFD_RELOC_16_GOTOFF:
	case BFD_RELOC_LO16_GOTOFF:
	case BFD_RELOC_HI16_GOTOFF:
	case BFD_RELOC_HI16_S_GOTOFF:
	case BFD_RELOC_LO16_PLTOFF:
	case BFD_RELOC_HI16_PLTOFF:
	case BFD_RELOC_HI16_S_PLTOFF:
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_16_BASEREL:
	case BFD_RELOC_LO16_BASEREL:
	case BFD_RELOC_HI16_BASEREL:
	case BFD_RELOC_HI16_S_BASEREL:
	case BFD_RELOC_PPC_TOC16:
	case BFD_RELOC_PPC64_TOC16_LO:
	case BFD_RELOC_PPC64_TOC16_HI:
	case BFD_RELOC_PPC64_TOC16_HA:
	case BFD_RELOC_PPC64_PLTGOT16:
	case BFD_RELOC_PPC64_PLTGOT16_LO:
	case BFD_RELOC_PPC64_PLTGOT16_HI:
	case BFD_RELOC_PPC64_PLTGOT16_HA:
	case BFD_RELOC_PPC64_GOT16_DS:
	case BFD_RELOC_PPC64_GOT16_LO_DS:
	case BFD_RELOC_PPC64_PLT16_LO_DS:
	case BFD_RELOC_PPC64_SECTOFF_DS:
	case BFD_RELOC_PPC64_SECTOFF_LO_DS:
	case BFD_RELOC_PPC64_TOC16_DS:
	case BFD_RELOC_PPC64_TOC16_LO_DS:
	case BFD_RELOC_PPC64_PLTGOT16_DS:
	case BFD_RELOC_PPC64_PLTGOT16_LO_DS:
	case BFD_RELOC_PPC_EMB_NADDR16:
	case BFD_RELOC_PPC_EMB_NADDR16_LO:
	case BFD_RELOC_PPC_EMB_NADDR16_HI:
	case BFD_RELOC_PPC_EMB_NADDR16_HA:
	case BFD_RELOC_PPC_EMB_SDAI16:
	case BFD_RELOC_PPC_EMB_SDA2I16:
	case BFD_RELOC_PPC_EMB_SDA2REL:
	case BFD_RELOC_PPC_EMB_SDA21:
	case BFD_RELOC_PPC_EMB_MRKREF:
	case BFD_RELOC_PPC_EMB_RELSEC16:
	case BFD_RELOC_PPC_EMB_RELST_LO:
	case BFD_RELOC_PPC_EMB_RELST_HI:
	case BFD_RELOC_PPC_EMB_RELST_HA:
	case BFD_RELOC_PPC_EMB_BIT_FLD:
	case BFD_RELOC_PPC_EMB_RELSDA:
	case BFD_RELOC_PPC_VLE_SDA21:
	case BFD_RELOC_PPC_VLE_SDA21_LO:
	case BFD_RELOC_PPC_VLE_SDAREL_LO16A:
	case BFD_RELOC_PPC_VLE_SDAREL_LO16D:
	case BFD_RELOC_PPC_VLE_SDAREL_HI16A:
	case BFD_RELOC_PPC_VLE_SDAREL_HI16D:
	case BFD_RELOC_PPC_VLE_SDAREL_HA16A:
	case BFD_RELOC_PPC_VLE_SDAREL_HA16D:
	  gas_assert (fixP->fx_addsy != NULL);
	  /* Fall thru */

	case BFD_RELOC_PPC_TLS:
	case BFD_RELOC_PPC_TLSGD:
	case BFD_RELOC_PPC_TLSLD:
	  fieldval = 0;
	  break;
#endif

#ifdef OBJ_XCOFF
	case BFD_RELOC_PPC_B16:
	  /* Adjust the offset to the instruction boundary.  */
	  fieldval += 2;
	  break;
#endif

	default:
	  break;
	}

#ifdef OBJ_ELF
/* powerpc uses RELA style relocs, so if emitting a reloc the field
   contents can stay at zero.  */
#define APPLY_RELOC fixP->fx_done
#else
#define APPLY_RELOC 1
#endif
      if ((fieldval != 0 && APPLY_RELOC) || operand->insert != NULL)
	{
	  /* Fetch the instruction, insert the fully resolved operand
	     value, and stuff the instruction back again.  */
	  where = fixP->fx_frag->fr_literal + fixP->fx_where;
	  if (target_big_endian)
	    {
	      if (fixP->fx_size == 4)
		insn = bfd_getb32 ((unsigned char *) where);
	      else
		insn = bfd_getb16 ((unsigned char *) where);
	    }
	  else
	    {
	      if (fixP->fx_size == 4)
		insn = bfd_getl32 ((unsigned char *) where);
	      else
		insn = bfd_getl16 ((unsigned char *) where);
	    }
	  insn = ppc_insert_operand (insn, operand, fieldval,
				     fixP->tc_fix_data.ppc_cpu,
				     fixP->fx_file, fixP->fx_line);
	  if (target_big_endian)
	    {
	      if (fixP->fx_size == 4)
		bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	      else
		bfd_putb16 ((bfd_vma) insn, (unsigned char *) where);
	    }
	  else
	    {
	      if (fixP->fx_size == 4)
		bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
	      else
		bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);
	    }
	}

      if (fixP->fx_done)
	/* Nothing else to do here.  */
	return;

      gas_assert (fixP->fx_addsy != NULL);
      if (fixP->fx_r_type == BFD_RELOC_UNUSED)
	{
	  char *sfile;
	  unsigned int sline;

	  /* Use expr_symbol_where to see if this is an expression
	     symbol.  */
	  if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unresolved expression that must be resolved"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unsupported relocation against %s"),
			  S_GET_NAME (fixP->fx_addsy));
	  fixP->fx_done = 1;
	  return;
	}
    }
  else
    {
      /* Handle relocs in data.  */
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_VTABLE_INHERIT:
	  if (fixP->fx_addsy
	      && !S_IS_DEFINED (fixP->fx_addsy)
	      && !S_IS_WEAK (fixP->fx_addsy))
	    S_SET_WEAK (fixP->fx_addsy);
	  /* Fall thru */

	case BFD_RELOC_VTABLE_ENTRY:
	  fixP->fx_done = 0;
	  break;

#ifdef OBJ_ELF
	  /* These can appear with @@l etc. in data.  */
	case BFD_RELOC_LO16:
	case BFD_RELOC_LO16_PCREL:
	case BFD_RELOC_HI16:
	case BFD_RELOC_HI16_PCREL:
	case BFD_RELOC_HI16_S:
	case BFD_RELOC_HI16_S_PCREL:
	case BFD_RELOC_PPC64_HIGHER:
	case BFD_RELOC_PPC64_HIGHER_S:
	case BFD_RELOC_PPC64_HIGHEST:
	case BFD_RELOC_PPC64_HIGHEST_S:
	  break;

	case BFD_RELOC_PPC_DTPMOD:
	case BFD_RELOC_PPC_TPREL:
	case BFD_RELOC_PPC_DTPREL:
	  S_SET_THREAD_LOCAL (fixP->fx_addsy);
	  break;

	  /* Just punt all of these to the linker.  */
	case BFD_RELOC_PPC_B16_BRTAKEN:
	case BFD_RELOC_PPC_B16_BRNTAKEN:
	case BFD_RELOC_16_GOTOFF:
	case BFD_RELOC_LO16_GOTOFF:
	case BFD_RELOC_HI16_GOTOFF:
	case BFD_RELOC_HI16_S_GOTOFF:
	case BFD_RELOC_LO16_PLTOFF:
	case BFD_RELOC_HI16_PLTOFF:
	case BFD_RELOC_HI16_S_PLTOFF:
	case BFD_RELOC_PPC_COPY:
	case BFD_RELOC_PPC_GLOB_DAT:
	case BFD_RELOC_16_BASEREL:
	case BFD_RELOC_LO16_BASEREL:
	case BFD_RELOC_HI16_BASEREL:
	case BFD_RELOC_HI16_S_BASEREL:
	case BFD_RELOC_PPC_TLS:
	case BFD_RELOC_PPC_DTPREL16_LO:
	case BFD_RELOC_PPC_DTPREL16_HI:
	case BFD_RELOC_PPC_DTPREL16_HA:
	case BFD_RELOC_PPC_TPREL16_LO:
	case BFD_RELOC_PPC_TPREL16_HI:
	case BFD_RELOC_PPC_TPREL16_HA:
	case BFD_RELOC_PPC_GOT_TLSGD16:
	case BFD_RELOC_PPC_GOT_TLSGD16_LO:
	case BFD_RELOC_PPC_GOT_TLSGD16_HI:
	case BFD_RELOC_PPC_GOT_TLSGD16_HA:
	case BFD_RELOC_PPC_GOT_TLSLD16:
	case BFD_RELOC_PPC_GOT_TLSLD16_LO:
	case BFD_RELOC_PPC_GOT_TLSLD16_HI:
	case BFD_RELOC_PPC_GOT_TLSLD16_HA:
	case BFD_RELOC_PPC_GOT_DTPREL16:
	case BFD_RELOC_PPC_GOT_DTPREL16_LO:
	case BFD_RELOC_PPC_GOT_DTPREL16_HI:
	case BFD_RELOC_PPC_GOT_DTPREL16_HA:
	case BFD_RELOC_PPC_GOT_TPREL16:
	case BFD_RELOC_PPC_GOT_TPREL16_LO:
	case BFD_RELOC_PPC_GOT_TPREL16_HI:
	case BFD_RELOC_PPC_GOT_TPREL16_HA:
	case BFD_RELOC_24_PLT_PCREL:
	case BFD_RELOC_PPC_LOCAL24PC:
	case BFD_RELOC_32_PLT_PCREL:
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_PPC_VLE_SDAREL_LO16A:
	case BFD_RELOC_PPC_VLE_SDAREL_HI16A:
	case BFD_RELOC_PPC_VLE_SDAREL_HA16A:
	case BFD_RELOC_PPC_EMB_NADDR32:
	case BFD_RELOC_PPC_EMB_NADDR16:
	case BFD_RELOC_PPC_EMB_NADDR16_LO:
	case BFD_RELOC_PPC_EMB_NADDR16_HI:
	case BFD_RELOC_PPC_EMB_NADDR16_HA:
	case BFD_RELOC_PPC_EMB_SDAI16:
	case BFD_RELOC_PPC_EMB_SDA2REL:
	case BFD_RELOC_PPC_EMB_SDA2I16:
	case BFD_RELOC_PPC_EMB_SDA21:
	case BFD_RELOC_PPC_VLE_SDA21_LO:
	case BFD_RELOC_PPC_EMB_MRKREF:
	case BFD_RELOC_PPC_EMB_RELSEC16:
	case BFD_RELOC_PPC_EMB_RELST_LO:
	case BFD_RELOC_PPC_EMB_RELST_HI:
	case BFD_RELOC_PPC_EMB_RELST_HA:
	case BFD_RELOC_PPC_EMB_BIT_FLD:
	case BFD_RELOC_PPC_EMB_RELSDA:
	case BFD_RELOC_PPC64_TOC:
	case BFD_RELOC_PPC_TOC16:
	case BFD_RELOC_PPC64_TOC16_LO:
	case BFD_RELOC_PPC64_TOC16_HI:
	case BFD_RELOC_PPC64_TOC16_HA:
	case BFD_RELOC_PPC64_DTPREL16_HIGHER:
	case BFD_RELOC_PPC64_DTPREL16_HIGHERA:
	case BFD_RELOC_PPC64_DTPREL16_HIGHEST:
	case BFD_RELOC_PPC64_DTPREL16_HIGHESTA:
	case BFD_RELOC_PPC64_TPREL16_HIGHER:
	case BFD_RELOC_PPC64_TPREL16_HIGHERA:
	case BFD_RELOC_PPC64_TPREL16_HIGHEST:
	case BFD_RELOC_PPC64_TPREL16_HIGHESTA:
	  fixP->fx_done = 0;
	  break;
#endif

#ifdef OBJ_XCOFF
	case BFD_RELOC_NONE:
#endif
	case BFD_RELOC_CTOR:
	case BFD_RELOC_32:
	case BFD_RELOC_32_PCREL:
	case BFD_RELOC_RVA:
	case BFD_RELOC_64:
	case BFD_RELOC_64_PCREL:
	case BFD_RELOC_16:
	case BFD_RELOC_16_PCREL:
	case BFD_RELOC_8:
	  break;

	default:
	  fprintf (stderr,
		   _("Gas failure, reloc value %d\n"), fixP->fx_r_type);
	  fflush (stderr);
	  abort ();
	}

      if (fixP->fx_size && APPLY_RELOC)
	md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			    fieldval, fixP->fx_size);
    }

  /* We are only able to convert some relocs to pc-relative.  */
  if (!fixP->fx_done && fixP->fx_pcrel)
    {
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_LO16:
	  fixP->fx_r_type = BFD_RELOC_LO16_PCREL;
	  break;

	case BFD_RELOC_HI16:
	  fixP->fx_r_type = BFD_RELOC_HI16_PCREL;
	  break;

	case BFD_RELOC_HI16_S:
	  fixP->fx_r_type = BFD_RELOC_HI16_S_PCREL;
	  break;

	case BFD_RELOC_64:
	  fixP->fx_r_type = BFD_RELOC_64_PCREL;
	  break;

	case BFD_RELOC_32:
	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  break;

	case BFD_RELOC_16:
	  fixP->fx_r_type = BFD_RELOC_16_PCREL;
	  break;

	  /* Some of course are already pc-relative.  */
	case BFD_RELOC_LO16_PCREL:
	case BFD_RELOC_HI16_PCREL:
	case BFD_RELOC_HI16_S_PCREL:
	case BFD_RELOC_64_PCREL:
	case BFD_RELOC_32_PCREL:
	case BFD_RELOC_16_PCREL:
	case BFD_RELOC_PPC_B16:
	case BFD_RELOC_PPC_B16_BRTAKEN:
	case BFD_RELOC_PPC_B16_BRNTAKEN:
	case BFD_RELOC_PPC_B26:
	case BFD_RELOC_PPC_LOCAL24PC:
	case BFD_RELOC_24_PLT_PCREL:
	case BFD_RELOC_32_PLT_PCREL:
	case BFD_RELOC_64_PLT_PCREL:
	case BFD_RELOC_PPC_VLE_REL8:
	case BFD_RELOC_PPC_VLE_REL15:
	case BFD_RELOC_PPC_VLE_REL24:
	  break;

	default:
	  if (fixP->fx_addsy)
	    {
	      char *sfile;
	      unsigned int sline;

	      /* Use expr_symbol_where to see if this is an
		 expression symbol.  */
	      if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("unresolved expression that must"
				" be resolved"));
	      else
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("cannot emit PC relative %s relocation"
				" against %s"),
			      bfd_get_reloc_code_name (fixP->fx_r_type),
			      S_GET_NAME (fixP->fx_addsy));
	    }
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unable to resolve expression"));
	  fixP->fx_done = 1;
	  break;
	}
    }

#ifdef OBJ_ELF
  ppc_elf_validate_fix (fixP, seg);
  fixP->fx_addnumber = value;

  /* PowerPC uses RELA relocs, ie. the reloc addend is stored separately
     from the section contents.  If we are going to be emitting a reloc
     then the section contents are immaterial, so don't warn if they
     happen to overflow.  Leave such warnings to ld.  */
  if (!fixP->fx_done)
    {
      fixP->fx_no_overflow = 1;

      /* Arrange to emit .TOC. as a normal symbol if used in anything
	 but .TOC.@@tocbase.  */
      if (ppc_obj64
	  && fixP->fx_r_type != BFD_RELOC_PPC64_TOC
	  && fixP->fx_addsy != NULL
	  && strcmp (S_GET_NAME (fixP->fx_addsy), ".TOC.") == 0)
	symbol_get_bfdsym (fixP->fx_addsy)->flags |= BSF_KEEP;
    }
#else
  if (fixP->fx_r_type != BFD_RELOC_PPC_TOC16)
    fixP->fx_addnumber = 0;
  else
    {
#ifdef TE_PE
      fixP->fx_addnumber = 0;
#else
      /* We want to use the offset within the toc, not the actual VMA
	 of the symbol.  */
      fixP->fx_addnumber =
	- bfd_get_section_vma (stdoutput, S_GET_SEGMENT (fixP->fx_addsy))
	- S_GET_VALUE (ppc_toc_csect);
      /* Set *valP to avoid errors.  */
      *valP = value;
#endif
    }
#endif
}

/* Generate a reloc for a fixup.  */

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;

  reloc = (arelent *) xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }
  reloc->addend = fixp->fx_addnumber;

  return reloc;
}

void
ppc_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (1, 0);
}

int
tc_ppc_regname_to_dw2regnum (char *regname)
{
  unsigned int regnum = -1;
  unsigned int i;
  const char *p;
  char *q;
  static struct { char *name; int dw2regnum; } regnames[] =
    {
      { "sp", 1 }, { "r.sp", 1 }, { "rtoc", 2 }, { "r.toc", 2 },
      { "mq", 64 }, { "lr", 65 }, { "ctr", 66 }, { "ap", 67 },
      { "cr", 70 }, { "xer", 76 }, { "vrsave", 109 }, { "vscr", 110 },
      { "spe_acc", 111 }, { "spefscr", 112 }
    };

  for (i = 0; i < ARRAY_SIZE (regnames); ++i)
    if (strcmp (regnames[i].name, regname) == 0)
      return regnames[i].dw2regnum;

  if (regname[0] == 'r' || regname[0] == 'f' || regname[0] == 'v')
    {
      p = regname + 1 + (regname[1] == '.');
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 32)
	return -1;
      if (regname[0] == 'f')
	regnum += 32;
      else if (regname[0] == 'v')
	regnum += 77;
    }
  else if (regname[0] == 'c' && regname[1] == 'r')
    {
      p = regname + 2 + (regname[2] == '.');
      if (p[0] < '0' || p[0] > '7' || p[1])
	return -1;
      regnum = p[0] - '0' + 68;
    }
  return regnum;
}
@


1.205
log
@	* config/tc-ppc.c (ppc_elf_cons): Allow @@l and other reloc
	modifiers generally.
@
text
@d3149 1
d6367 9
d6886 2
@


1.204
log
@	* config/tc-ppc.c (ppc_elf_lcomm): Use subsection 1.
@
text
@d2053 1
a2053 2
      if (exp.X_op == O_symbol
	  && *input_line_pointer == '@@'
@


1.203
log
@        * config/tc-ppc.c (ppc_comm): Accept optional fourth .lcomm
        argument as alignment.
@
text
@d2199 1
a2199 1
  subseg_set (bss_section, 0);
@


1.202
log
@bfd/
2013-07-24  Tristan Gingold  <gingold@@adacore.com>

        * coff-rs6000.c (xcoff_howto_table): Fix masks and pc_relative for
        R_RBR.  Add numbers in comments.
        (_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_PPC_B16.
        * coff64-rs6000.c: Likewise.

gas/
2013-07-24  Tristan Gingold  <gingold@@adacore.com>

        * config/tc-ppc.c (md_apply_fix): Adjust BFD_RELOC_PPC_B16 on
        xcoff targets.

gas/testsuite/
2013-07-24  Tristan Gingold  <gingold@@adacore.com>

        * gas/ppc/test2xcoff32.s, gas/ppc/test2xcoff32.d: New files
        * gas/ppc/ppc.exp: Add new test.
        * gas/ppc/xcoff-br16-1.s, gas/ppc/xcoff-br16-1.d,
        gas/ppc/xcoff-br16-2.s, gas/ppc/xcoff-br16-2.d: New files
        * gas/ppc/aix.exp: Add new tests.
@
text
@a3528 5
      if (size <= 4)
	align = 2;
      else
	align = 3;

d3547 19
@


1.201
log
@bfd/
	* elf64-ppc.c (ppc64_elf_relocate_section): Set "relocation" for
	.TOC. after relocatable check.
gas/
	* config/tc-ppc.c (ppc_elf_adjust_symtab): Don't make .TOC. weak.
@
text
@a6419 1
#ifdef OBJ_ELF
d6422 1
d6531 8
a6542 1
#endif
@


1.200
log
@opcodes/
	* ppc-dis.c (powerpc_init_dialect): Set default dialect to power8.
	* ppc-opc.c (BHRBE, ST, SIX, PS, SXL, VXPS_MASK, XX1RB_MASK,
	XLS_MASK, PPCVSX2): New defines.
	(powerpc_opcodes) <bcdadd., bcdsub., bctar, bctar, bctarl, clrbhrb,
	fmrgew, fmrgow, lqarx, lxsiwax, lxsiwzx, lxsspx, mfbhrbe,
	mffprd, mffprwz, mfvrd, mfvrwz, mfvsrd, mfvsrwz, msgclrp, msgsndp,
	mtfprd, mtfprwa, mtfprwz, mtsle, mtvrd, mtvrwa, mtvrwz, mtvsrd,
	mtvsrwa, mtvsrwz, pbt., rfebb, stqcx., stxsiwx, stxsspx,
	vaddcuq, vaddecuq, vaddeuqm, vaddudm, vadduqm, vbpermq, vcipher,
	vcipherlast, vclzb, vclzd, vclzh, vclzw, vcmpequd, vcmpequd.,
	vcmpgtsd, vcmpgtsd., vcmpgtud, vcmpgtud., veqv, vgbbd, vmaxsd,
	vmaxud, vminsd, vminud, vmrgew, vmrgow, vmulesw, vmuleuw, vmulosw,
	vmulouw, vmuluwm, vnand, vncipher, vncipherlast, vorc, vpermxor,
	vpksdss, vpksdus, vpkudum, vpkudus, vpmsumb, vpmsumd, vpmsumh,
	vpmsumw, vpopcntb, vpopcntd, vpopcnth, vpopcntw, vrld, vsbox,
	vshasigmad, vshasigmaw, vsld, vsrad, vsrd, vsubcuq, vsubecuq,
	vsubeuqm, vsubudm, vsubuqm, vupkhsw, vupklsw, waitasec, xsaddsp,
	xscvdpspn, xscvspdpn, xscvsxdsp, xscvuxdsp, xsdivsp, xsmaddasp,
	xsmaddmsp, xsmsubasp, xsmsubmsp, xsmulsp, xsnmaddasp, xsnmaddmsp,
	xsnmsubasp, xsnmsubmsp, xsresp, xsrsp, xsrsqrtesp, xssqrtsp,
	xssubsp, xxleqv, xxlnand, xxlorc>: New instructions.
	<lxvx, stxvx>: New extended mnemonics.

gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Use new_seg to fix error
	and clean up warning when using PRINT_OPCODE_TABLE.

gas/testsuite/
	* gas/ppc/altivec2.d <bcdadd., bcdadd., vaddcuq, vaddecuq, vaddeuqm,
	vaddudm, vadduqm, vbpermq, vcipher, vcipherlast, vclzb, vclzd, vclzh,
	vclzw, vcmpequd, vcmpequd., vcmpgtsd, vcmpgtsd., vcmpgtud, vcmpgtud.,
	veqv, vgbbd, vmaxsd, vmaxud, vminsd, vminud, vmrgew, vmrgow, vmulesw,
	vmuleuw, vmulosw, vmulouw, vmuluwm, vnand, vncipher, vncipherlast,
	vorc, vpermxor, vpksdss, vpksdus, vpkudum, vpkudus, vpmsumb, vpmsumd,
	vpmsumh, vpmsumw, vpopcntb, vpopcntd, vpopcnth, vpopcntw, vrld, vsbox,
	vshasigmad, vshasigmaw, vsld, vsrad, vsrd, vsubcuq, vsubecuq, vsubeuqm,
	vsubudm, vsubuqm, vupkhsw, vupklsw>: Add new tests.
	* gas/ppc/altivec2.s: Likewise.
	* gas/ppc/power8.d <bcdadd., bcdsub., bctar, bctarl, clrbhrb, fmrgew,
	fmrgow, lqarx, lxsiwax, lxsiwzx, lxsspx, mfbhrbe, mfvsrd, mfvsrwz,
	msgclrp, msgsndp, mtsle, mtvsrd, mtvsrwa, mtvsrwz, pbt., rfebb,
	stqcx., stxsiwx, stxsspx, vaddcuq, vaddecuq, vaddeuqm, vaddudm,
	vadduqm, vbpermq, vcipher, vcipherlast, vclzb, vclzd, vclzh, vclzw,
	vcmpequd, vcmpequd., vcmpgtsd, vcmpgtsd., vcmpgtud, vcmpgtud., veqv,
	vgbbd, vmaxsd, vmaxud, vminsd, vminud, vmrgow, vmulesw, vmuleuw,
	vmulosw, vmulouw, vmuluwm, vnand, vncipher, vncipherlast, vorc,
	vpermxor, vpksdss, vpksdus, vpkudum, vpkudus, vpmsumb, vpmsumd,
	vpmsumh, vpmsumw, vpopcntb, vpopcntd, vpopcnth, vpopcntw, vrld, vsbox,
	vshasigmad, vshasigmaw, vsld, vsrad, vsrd, vsubcuq, vsubecuq, vsubeuqm,
	vsubuqm, vupkhsw, vupklsw, waitasec, xsaddsp, xscvdpspn, xscvspdpn,
	xscvsxdsp, xscvuxdsp, xsdivsp, xsmaddasp, xsmaddmsp, xsmsubasp,
	xsmsubmsp, xsmulsp, xsnmaddasp, xsnmaddmsp, xsnmsubasp, xsnmsubmsp,
	xsresp, xsrsp, xsrsqrtesp, xssqrtsp, xssubsp, xxleqv, xxlnand,
	xxlorc>: Add new tests.
	* gas/ppc/power8.s Likewise.
	* gas/ppc/vsx.d <lxvd2x, stxvd2x>: Add new tests.
	* gas/ppc/vsx.s Likewise.
	* gas/ppc/vsx2.d: New test file.
	* gas/ppc/vsx2.s: Likewise.
	* gas/ppc/ppc.exp: Run it.
@
text
@a2320 2
	  else
	    S_SET_WEAK (symp);
@


1.199
log
@	* config/tc-ppc.c (md_apply_fix): Hoist code common to insn
	and data fixups performing shift/high adjust/sign extension on
	fieldval.  Sink fx_pcrel handling and checks.  Use fixP->fx_size
	when writing data fixups rather than recalculating size.
@
text
@d1529 4
a1532 4
	      printf ("%-14s\t#%04d\tmajor op: 0x%x\top: 0x%x\tmask: 0x%x\tflags: 0x%llx\n",
		      op->name, op - powerpc_opcodes, (unsigned int) new_opcode,
		      (unsigned int) op->opcode, (unsigned int) op->mask,
		      (unsigned long long) op->flags);
d1582 4
a1585 4
	      printf ("%-14s\t#%04d\tmajor op: 0x%x\top: 0x%x\tmask: 0x%x\tflags: 0x%llx\n",
		      op->name, op - powerpc_opcodes, (unsigned int) new_opcode,
		      (unsigned int) op->opcode, (unsigned int) op->mask,
		      (unsigned long long) op->flags);
@


1.198
log
@bfd/
2013-05-16  Tristan Gingold  <gingold@@adacore.com>

	* coff-rs6000.c (_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_16.
	* coff64-rs6000.c (xcoff64_reloc_type_lookup): Likewise.


gas/
2013-05-16  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ppc.c (ppc_is_toc_sym): Symbols of class XMC_TC
	are also TOC symbols.
@
text
@d6290 2
d6330 1
d6333 1
a6333 2
      /* Handle relocs in an insn.  */

a6334 4
      const struct powerpc_operand *operand = &powerpc_operands[opindex];
      char *where;
      unsigned long insn;
      offsetT fieldval;
d6336 1
d6356 6
a6361 3
      fieldval = value;
      switch (fixP->fx_r_type)
	{
d6363 3
a6365 4
	case BFD_RELOC_PPC64_ADDR16_LO_DS:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  /* fall through */
d6367 8
a6374 13
	case BFD_RELOC_LO16:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_LO16_PCREL;
	  /* fall through */
	case BFD_RELOC_LO16_PCREL:
	case BFD_RELOC_PPC_VLE_LO16A:
	case BFD_RELOC_PPC_VLE_LO16D:
	  fieldval = value & 0xffff;
	sign_extend_16:
	  if ((operand->flags & PPC_OPERAND_SIGNED) != 0)
	    fieldval = (fieldval ^ 0x8000) - 0x8000;
	  fixP->fx_no_overflow = 1;
	  break;
d6376 8
a6383 9
	case BFD_RELOC_HI16:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_HI16_PCREL;
	  /* fall through */
	case BFD_RELOC_HI16_PCREL:
	case BFD_RELOC_PPC_VLE_HI16A:
	case BFD_RELOC_PPC_VLE_HI16D:
	  fieldval = PPC_HI (value);
	  goto sign_extend_16;
d6385 8
a6392 9
	case BFD_RELOC_HI16_S:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_HI16_S_PCREL;
	  /* fall through */
	case BFD_RELOC_HI16_S_PCREL:
	case BFD_RELOC_PPC_VLE_HA16A:
	case BFD_RELOC_PPC_VLE_HA16D:
	  fieldval = PPC_HA (value);
	  goto sign_extend_16;
d6395 16
a6410 5
	case BFD_RELOC_PPC64_HIGHER:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  fieldval = PPC_HIGHER (value);
	  goto sign_extend_16;
d6412 3
a6414 5
	case BFD_RELOC_PPC64_HIGHER_S:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  fieldval = PPC_HIGHERA (value);
	  goto sign_extend_16;
d6416 5
a6420 11
	case BFD_RELOC_PPC64_HIGHEST:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  fieldval = PPC_HIGHEST (value);
	  goto sign_extend_16;

	case BFD_RELOC_PPC64_HIGHEST_S:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  fieldval = PPC_HIGHESTA (value);
	  goto sign_extend_16;
d6422 3
a6465 2
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
a6531 2
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
a6532 1
#endif
d6537 1
a6608 3
      int size = 0;
      offsetT fieldval = value;

a6611 67
	case BFD_RELOC_CTOR:
	  if (ppc_obj64)
	    goto ctor64;
	  /* fall through */

	case BFD_RELOC_32:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  /* fall through */

	case BFD_RELOC_32_PCREL:
	case BFD_RELOC_RVA:
	  size = 4;
	  break;

	case BFD_RELOC_64:
	ctor64:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_64_PCREL;
	  /* fall through */

	case BFD_RELOC_64_PCREL:
	  size = 8;
	  break;

	case BFD_RELOC_16:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_16_PCREL;
	  /* fall through */

	case BFD_RELOC_16_PCREL:
	  size = 2;
	  break;

	case BFD_RELOC_8:
	  if (fixP->fx_pcrel)
	    {
#ifdef OBJ_ELF
	    bad_pcrel:
#endif
	      if (fixP->fx_addsy)
		{
		  char *sfile;
		  unsigned int sline;

		  /* Use expr_symbol_where to see if this is an
		     expression symbol.  */
		  if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
		    as_bad_where (fixP->fx_file, fixP->fx_line,
				  _("unresolved expression that must"
				    " be resolved"));
		  else
		    as_bad_where (fixP->fx_file, fixP->fx_line,
				  _("cannot emit PC relative %s relocation"
				    " against %s"),
				  bfd_get_reloc_code_name (fixP->fx_r_type),
				  S_GET_NAME (fixP->fx_addsy));
		}
	      else
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("unable to resolve expression"));
	      fixP->fx_done = 1;
	    }
	  else
	    size = 1;
	  break;

a6625 2
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_LO16_PCREL;
a6626 3
	  size = 2;
	  break;

a6627 2
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_HI16_PCREL;
a6628 4
	  size = 2;
	  fieldval = PPC_HI (value);
	  break;

a6629 2
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_HI16_S_PCREL;
a6630 4
	  size = 2;
	  fieldval = PPC_HA (value);
	  break;

a6631 6
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  size = 2;
	  fieldval = PPC_HIGHER (value);
	  break;

a6632 6
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  size = 2;
	  fieldval = PPC_HIGHERA (value);
	  break;

a6633 6
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  size = 2;
	  fieldval = PPC_HIGHEST (value);
	  break;

a6634 4
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  size = 2;
	  fieldval = PPC_HIGHESTA (value);
d6725 10
a6735 1
#endif
d6744 1
a6744 1
      if (size && APPLY_RELOC)
d6746 77
a6822 1
			    fieldval, size);
@


1.197
log
@	* config/tc-ppc.c (md_apply_fix): Sign extend fieldval under
	control of operand flag bits.
@
text
@d2431 2
a2432 1
  return symbol_get_tc (sym)->symbol_class == XMC_TC;
@


1.196
log
@	* config/tc-ppc.c (PPC_VLE_SPLIT16A): Delete unused macro.
	(PPC_VLE_SPLIT16D, PPC_VLE_LO16A, PPC_VLE_LO16D): Likewise.
	(PPC_VLE_HI16A, PPC_VLE_HI16D): Likewise.
	(PPC_VLE_HA16A, PPC_VLE_HA16D): Likewise.
	(md_apply_fix): Set fx_no_overflow for assorted relocations.
	Shift and sign-extend fieldval for use by some VLE reloc
	operand->insert functions.
@
text
@d6372 4
a6375 1
	  fieldval = SEX16 (value);
d6386 2
a6387 3
	  fieldval = SEX16 (PPC_HI (value));
	  fixP->fx_no_overflow = 1;
	  break;
d6396 2
a6397 3
	  fieldval = SEX16 (PPC_HA (value));
	  fixP->fx_no_overflow = 1;
	  break;
d6403 2
a6404 3
	  fieldval = SEX16 (PPC_HIGHER (value));
	  fixP->fx_no_overflow = 1;
	  break;
d6409 2
a6410 3
	  fieldval = SEX16 (PPC_HIGHERA (value));
	  fixP->fx_no_overflow = 1;
	  break;
d6415 2
a6416 3
	  fieldval = SEX16 (PPC_HIGHEST (value));
	  fixP->fx_no_overflow = 1;
	  break;
d6421 2
a6422 3
	  fieldval = SEX16 (PPC_HIGHESTA (value));
	  fixP->fx_no_overflow = 1;
	  break;
@


1.195
log
@	* config/tc-ppc.c (md_assemble): Do not generate APUinfo sections
	for 64-bit output.
@
text
@a66 14
/* Split the indicated value with the msbs in bits 11-15
   and the lsbs in bits 21-31.  */
#define PPC_VLE_SPLIT16A(v) ((v & 0xf800) << 11) | (v & 0x7ff)

/* Split the indicated value with the msbs in bits 6-10
   and the lsbs in bits 21-31.  */
#define PPC_VLE_SPLIT16D(v) ((v & 0xf800) << 5) | (v & 0x7ff)

/* #lo(value) denotes the lsb 16 bits in split16a format.  */
#define PPC_VLE_LO16A(v) PPC_VLE_SPLIT16A(PPC_LO(v))

/* #lo(value) denotes the lsb 16 bits in split16d format.  */
#define PPC_VLE_LO16D(v) PPC_VLE_SPLIT16D(PPC_LO(v))

a69 6
/* #lo(value) denotes the msb 16 bits in split16a format.  */
#define PPC_VLE_HI16A(v) PPC_VLE_SPLIT16A(PPC_HI(v))

/* #lo(value) denotes the msb 16 bits in split16d format.  */
#define PPC_VLE_HI16D(v) PPC_VLE_SPLIT16D(PPC_HI(v))

a74 6
/* #ha(value) denotes the high adjusted value in split16a format.  */
#define PPC_VLE_HA16A(v) PPC_VLE_SPLIT16A(PPC_HA(v))

/* #ha(value) denotes the high adjusted value in split16d format.  */
#define PPC_VLE_HA16D(v) PPC_VLE_SPLIT16D(PPC_HA(v))

d6370 2
d6373 1
d6381 2
d6384 1
d6392 2
d6395 1
d6403 1
d6410 1
d6417 1
d6424 1
@


1.194
log
@	* config/tc-ppc.c (md_assemble <TE_PE>): Ignore line after
	finding some sort of toc syntax error, and break to avoid
	compiler uninit warning.
@
text
@d3252 2
a3253 1
  if ((ppc_cpu & (PPC_OPCODE_E500 | PPC_OPCODE_E500MC | PPC_OPCODE_VLE)) != 0)
@


1.193
log
@include/opcode/
	* ppc.h (PPC_OPCODE_POWER8): New define.
	(PPC_OPCODE_HTM): Likewise.

opcodes/
	* ppc-dis.c (ppc_opts): Add "power8", "pwr8" and "htm" entries.
	* ppc-opc.c (HTM_R, HTM_SI, XRTRB_MASK, XRTRARB_MASK, XRTLRARB_MASK,
	XRTARARB_MASK, XRTBFRARB_MASK, XRCL, POWER8, PPCHTM): New defines.
	(SH6): Update.
	<"tabort.", "tabortdc.", "tabortdci.", "tabortwc.",
	"tabortwci.", "tbegin.", "tcheck", "tend.", "trechkpt.",
	"treclaim.", "tsr.">: Add POWER8 HTM opcodes.
	<"tendall.", "tresume.", "tsuspend.">: Add POWER8 HTM extended opcodes.

gas/
	* doc/as.texinfo (Target PowerPC): Document -mpower8 and -mhtm.
	* doc/c-ppc.texi (PowerPC-Opts):  Likewise.
	* config/tc-ppc.c (md_show_usage): Likewise.
	(ppc_handle_align): Handle power8's group ending nop.

gas/testsuite/
	* gas/ppc/htm.d: New test.
	* gas/ppc/htm.s: Likewise.
	* gas/ppc/power8.d: Likewise.
	* gas/ppc/power8.s: Likewise.
	* gas/ppc/ppc.exp: Run them.
@
text
@d2718 2
a2719 3
	      /* Note: message has already been issued.
		 FIXME: what sort of recovery should we do?
		 demand_rest_of_line (); return; ?  */
@


1.192
log
@include/opcode/
	* ppc.h (ppc_parse_cpu): Update prototype.
opcodes/
	* ppc-dis.c (ppc_parse_cpu): Add "sticky" param.  Track bits
	set from ppc_opts.sticky in it.  Delete "retain_mask".
	(powerpc_init_dialect): Choose default dialect from info->mach
	before parsing -M options.  Handle more bfd_mach_ppc variants.
	Update common default to power7.
gas/
	* config/tc-ppc.c (sticky): New var.
	(md_parse_option, ppc_machine): Update ppc_parse_cpu calls.
gas/testsuite/
	* gas/ppc/astest2.d: Pass -Mppc to objdump.
ld/testsuite/
	* ld-powerpc/plt1.d: Update for default "at" branch hints.
	* ld-powerpc/tlsexe.d: Likewise.
	* ld-powerpc/tlsexetoc.d: Likewise.
	* ld-powerpc/tlsopt1.d: Likewise.
	* ld-powerpc/tlsopt1_32.d: Likewise.
	* ld-powerpc/tlsopt2.d: Likewise.
	* ld-powerpc/tlsopt2_32.d: Likewise.
	* ld-powerpc/tlsopt4.d: Likewise.
	* ld-powerpc/tlsopt4_32.d: Likewise.
	* ld-powerpc/tlsso.d: Likewise.
	* ld-powerpc/tlstocso.d: Likewise.
@
text
@d1305 1
d1312 1
d6270 2
a6271 1
	  || (ppc_cpu & PPC_OPCODE_POWER7) != 0)
d6273 1
a6273 1
	  /* For power6 and power7, we want the last nop to be a group
d6291 2
a6292 1
	  if ((ppc_cpu & PPC_OPCODE_POWER7) != 0)
d6298 1
a6298 1
		/* power7 group terminating nop: "ori 2,2,0".  */
@


1.191
log
@gas/ChangeLog:

	* config/tc-ppc.c (md_apply_fix): Leave field zero when emitting
	an ELF reloc on data as well.

gas/testsuite/ChangeLog:

	* gas/ppc/astest.d: Update for fixup changes.
	* gas/ppc/astest64.d: Likewise.
	* gas/ppc/astest2.d: Likewise.
	* gas/ppc/astest2_64.d: Likewise.
	* gas/ppc/test1elf32.d: Likewise.
	* gas/ppc/test1elf64.d: Likewise.
@
text
@d226 1
d1164 1
a1164 1
      new_cpu = ppc_parse_cpu (ppc_cpu, arg);
d4867 1
a4867 1
      else if ((new_cpu = ppc_parse_cpu (ppc_cpu, cpu_string)) != 0)
@


1.190
log
@bfd/
	* elf64-ppc.c (struct ppc_link_hash_table): Add dot_toc_dot.
	(ppc64_elf_size_stubs): Lookup ".TOC.".
	(ppc64_elf_relocate_section): Resolve special symbol ".TOC.".
gas/
	* config/tc-ppc.c (ppc_elf_adjust_symtab): New function, split out..
	(ppc_frob_file_before_adjust): ..from here.
	(md_apply_fix): Set BSF_KEEP on .TOC. if not @@tocbase.
	* config/tc-ppc.h (ppc_elf_adjust_symtab): Declare.
	(tc_adjust_symtab): Define.
@
text
@d6623 3
d6641 1
a6641 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 4);
d6651 1
a6651 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 8);
d6660 1
a6660 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 2);
d6693 1
a6693 2
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
				value, 1);
d6713 1
a6713 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 2);
d6720 2
a6721 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HI (value), 2);
d6728 2
a6729 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HA (value), 2);
d6735 2
a6736 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHER (value), 2);
d6742 2
a6743 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHERA (value), 2);
d6749 2
a6750 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHEST (value), 2);
d6756 2
a6757 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHESTA (value), 2);
d6857 4
@


1.189
log
@	* config/tc-ppc.c (md_apply_fix): Fix xcoff build breakage from
	last patch.
@
text
@d2326 5
d2332 16
a2347 4
  /* Don't emit .TOC. symbol.  */
  symp = symbol_find (".TOC.");
  if (symp != NULL)
    symbol_remove (symp, &symbol_rootP, &symbol_lastP);
d6870 11
a6880 1
    fixP->fx_no_overflow = 1;
@


1.188
log
@	* config/tc-ppc.c (md_chars_to_number): Delete.
	(ppc_setup_opcodes): Assert num_powerpc_operands fit.
	(ppc_is_toc_sym): Move earlier in file.
	(md_assemble): Move code setting reloc from md_apply_fix.  Combine
	non-ELF code setting fixup with ELF code.  Stash opindex in
	fx_pcrel_adjust.  Adjust fixup offset for VLE.  Don't set
	fx_no_overflow here.
	(md_apply_fix): Rewrite to use ppc_insert_operand for all
	resolved instruction fields.  Leave insn field zero when
	emitting an ELF reloc in most cases.
@
text
@d6363 1
d6368 1
@


1.187
log
@binutils/
	* dlltool.c (INIT_SEC_DATA): Move.
	(secdata <DLLTOOL_PPC>): Use here too.
binutils/testsuite/
	* binutils-all/copy-3.d: Exclude all cygwin and mingw targets,
	and rs6000.
gas/
	* config/tc-ppc.c (ppc_znop): Remove unused vars.
ld/
	* configure.tgt (powerpcle-pe,winnt,cygwin): Add deffilep.o
	and pe-dll.o.
@
text
@a1091 29
/* Convert the target integer stored in N bytes in BUF to a host
   integer, returning that value.  */

static valueT
md_chars_to_number (char *buf, int n)
{
  valueT result = 0;
  unsigned char *p = (unsigned char *) buf;

  if (target_big_endian)
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (*p++ & 0xff);
	}
    }
  else
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (p[n] & 0xff);
	}
    }

  return result;
}

d1510 4
d2429 19
a2529 3
#ifdef OBJ_ELF
  bfd_reloc_code_real_type reloc;
#endif
d2811 1
a2876 1
#ifdef OBJ_ELF
d2879 2
d3118 60
a3186 12
#else /* OBJ_ELF */
      else
	{
	  /* We need to generate a fixup for this expression.  */
	  if (fc >= MAX_INSN_FIXUPS)
	    as_fatal (_("too many fixups"));
	  fixups[fc].exp = ex;
	  fixups[fc].opindex = *opindex_ptr;
	  fixups[fc].reloc = BFD_RELOC_UNUSED;
	  ++fc;
	}
#endif /* OBJ_ELF */
d3287 1
a3287 6
  /* Create any fixups.  At this point we do not use a
     bfd_reloc_code_real_type, but instead just use the
     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
     handle fixups for any operand type, although that is admittedly
     not a very exciting feature.  We pick a BFD reloc type in
     md_apply_fix.  */
d3290 1
a3295 1
	  fixS *fixP;
d3302 1
a3302 1
	  offset = target_big_endian ? (4 - size) : 0;
a3312 27

	  /* Turn off complaints that the addend is too large for things like
	     foo+100000@@ha.  */
	  switch (fixups[i].reloc)
	    {
	    case BFD_RELOC_16_GOTOFF:
	    case BFD_RELOC_PPC_TOC16:
	    case BFD_RELOC_LO16:
	    case BFD_RELOC_HI16:
	    case BFD_RELOC_HI16_S:
	    case BFD_RELOC_PPC_VLE_LO16A:
	    case BFD_RELOC_PPC_VLE_LO16D:
	    case BFD_RELOC_PPC_VLE_HI16A:
	    case BFD_RELOC_PPC_VLE_HI16D:
	    case BFD_RELOC_PPC_VLE_HA16A:
	    case BFD_RELOC_PPC_VLE_HA16D:
#ifdef OBJ_ELF
	    case BFD_RELOC_PPC64_HIGHER:
	    case BFD_RELOC_PPC64_HIGHER_S:
	    case BFD_RELOC_PPC64_HIGHEST:
	    case BFD_RELOC_PPC64_HIGHEST_S:
#endif
	      fixP->fx_no_overflow = 1;
	      break;
	    default:
	      break;
	    }
d3319 6
a3324 7
	  fix_new_exp (frag_now,
		       f - frag_now->fr_literal,
		       insn_length,
		       &fixups[i].exp,
		       (operand->flags & PPC_OPERAND_RELATIVE) != 0,
		       ((bfd_reloc_code_real_type)
			(fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
d3326 1
a4859 17

/* See whether a symbol is in the TOC section.  */

static int
ppc_is_toc_sym (symbolS *sym)
{
#ifdef OBJ_XCOFF
  return symbol_get_tc (sym)->symbol_class == XMC_TC;
#endif
#ifdef OBJ_ELF
  const char *sname = segment_name (S_GET_SEGMENT (sym));
  if (ppc_obj64)
    return strcmp (sname, ".toc") == 0;
  else
    return strcmp (sname, ".got") == 0;
#endif
}
d6287 1
a6287 7
   fixups we generated by the call to fix_new_exp, above.  In the call
   above we used a reloc code which was the largest legal reloc code
   plus the operand index.  Here we undo that to recover the operand
   index.  At this point all symbol values should be fully resolved,
   and we attempt to completely resolve the reloc.  If we can not do
   that, we determine the correct reloc code and put it back in the
   fixup.  */
d6331 1
a6331 1
  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
d6333 4
a6336 2
      int opindex;
      const struct powerpc_operand *operand;
d6339 1
a6339 4

      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;

      operand = &powerpc_operands[opindex];
d6360 1
a6360 138

      /* Fetch the instruction, insert the fully resolved operand
	 value, and stuff the instruction back again.  */
      where = fixP->fx_frag->fr_literal + fixP->fx_where;
      if (target_big_endian)
	{
	  if (fixP->fx_size == 4)
	    insn = bfd_getb32 ((unsigned char *) where);
	  else
	    insn = bfd_getb16 ((unsigned char *) where);
	}
      else
	{
	  if (fixP->fx_size == 4)
	    insn = bfd_getl32 ((unsigned char *) where);
	  else
	    insn = bfd_getl16 ((unsigned char *) where);
	}
      insn = ppc_insert_operand (insn, operand, (offsetT) value,
				 fixP->tc_fix_data.ppc_cpu,
				 fixP->fx_file, fixP->fx_line);
      if (target_big_endian)
	{
	  if (fixP->fx_size == 4)
	    bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	  else
	    bfd_putb16 ((bfd_vma) insn, (unsigned char *) where);
	}
      else
	{
	  if (fixP->fx_size == 4)
	    bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
	  else
	    bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);
	}

      if (fixP->fx_done)
	/* Nothing else to do here.  */
	return;

      gas_assert (fixP->fx_addsy != NULL);

      /* Determine a BFD reloc value based on the operand information.
	 We are only prepared to turn a few of the operands into
	 relocs.  */
      if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
	  && operand->bitm == 0x3fffffc
	  && operand->shift == 0)
	fixP->fx_r_type = BFD_RELOC_PPC_B26;
      else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
	  && operand->bitm == 0xfffc
	  && operand->shift == 0)
	{
	  fixP->fx_r_type = BFD_RELOC_PPC_B16;
#ifdef OBJ_XCOFF
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
#endif
	}
      else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
	  && operand->bitm == 0x1fe
	  && operand->shift == -1)
	fixP->fx_r_type = BFD_RELOC_PPC_VLE_REL8;
      else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
	  && operand->bitm == 0xfffe
	  && operand->shift == 0)
	fixP->fx_r_type = BFD_RELOC_PPC_VLE_REL15;
      else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
	  && operand->bitm == 0x1fffffe
	  && operand->shift == 0)
	fixP->fx_r_type = BFD_RELOC_PPC_VLE_REL24;
      else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
	       && operand->bitm == 0x3fffffc
	       && operand->shift == 0)
	fixP->fx_r_type = BFD_RELOC_PPC_BA26;
      else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
	       && operand->bitm == 0xfffc
	       && operand->shift == 0)
	{
	  fixP->fx_r_type = BFD_RELOC_PPC_BA16;
#ifdef OBJ_XCOFF
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
#endif
	}
#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
      else if ((operand->flags & PPC_OPERAND_PARENS) != 0
	       && (operand->bitm & 0xfff0) == 0xfff0
	       && operand->shift == 0)
	{
	  if (ppc_is_toc_sym (fixP->fx_addsy))
	    {
	      fixP->fx_r_type = BFD_RELOC_PPC_TOC16;
#ifdef OBJ_ELF
	      if (ppc_obj64
		  && (operand->flags & PPC_OPERAND_DS) != 0)
		fixP->fx_r_type = BFD_RELOC_PPC64_TOC16_DS;
#endif
	    }
	  else
	    {
	      fixP->fx_r_type = BFD_RELOC_16;
#ifdef OBJ_ELF
	      if (ppc_obj64
		  && (operand->flags & PPC_OPERAND_DS) != 0)
		fixP->fx_r_type = BFD_RELOC_PPC64_ADDR16_DS;
#endif
	    }
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
	}
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */
      else
	{
	  char *sfile;
	  unsigned int sline;

	  /* Use expr_symbol_where to see if this is an expression
	     symbol.  */
	  if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unresolved expression that must be resolved"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unsupported relocation against %s"),
			  S_GET_NAME (fixP->fx_addsy));
	  fixP->fx_done = 1;
	  return;
	}
    }
  else
    {
#ifdef OBJ_ELF
      ppc_elf_validate_fix (fixP, seg);
#endif
d6363 1
a6363 74
	case BFD_RELOC_CTOR:
	  if (ppc_obj64)
	    goto ctor64;
	  /* fall through */

	case BFD_RELOC_32:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  /* fall through */

	case BFD_RELOC_RVA:
	case BFD_RELOC_32_PCREL:
	case BFD_RELOC_PPC_EMB_NADDR32:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 4);
	  break;

	case BFD_RELOC_64:
	ctor64:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_64_PCREL;
	  /* fall through */

	case BFD_RELOC_64_PCREL:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 8);
	  break;

	case BFD_RELOC_GPREL16:
	case BFD_RELOC_16_GOT_PCREL:
	case BFD_RELOC_16_GOTOFF:
	case BFD_RELOC_LO16_GOTOFF:
	case BFD_RELOC_HI16_GOTOFF:
	case BFD_RELOC_HI16_S_GOTOFF:
	case BFD_RELOC_16_BASEREL:
	case BFD_RELOC_LO16_BASEREL:
	case BFD_RELOC_HI16_BASEREL:
	case BFD_RELOC_HI16_S_BASEREL:
	case BFD_RELOC_PPC_EMB_NADDR16:
	case BFD_RELOC_PPC_EMB_NADDR16_LO:
	case BFD_RELOC_PPC_EMB_NADDR16_HI:
	case BFD_RELOC_PPC_EMB_NADDR16_HA:
	case BFD_RELOC_PPC_EMB_SDAI16:
	case BFD_RELOC_PPC_EMB_SDA2REL:
	case BFD_RELOC_PPC_EMB_SDA2I16:
	case BFD_RELOC_PPC_EMB_RELSEC16:
	case BFD_RELOC_PPC_EMB_RELST_LO:
	case BFD_RELOC_PPC_EMB_RELST_HI:
	case BFD_RELOC_PPC_EMB_RELST_HA:
	case BFD_RELOC_PPC_EMB_RELSDA:
	case BFD_RELOC_PPC_TOC16:
#ifdef OBJ_ELF
	case BFD_RELOC_PPC64_TOC16_LO:
	case BFD_RELOC_PPC64_TOC16_HI:
	case BFD_RELOC_PPC64_TOC16_HA:
#endif
	  if (fixP->fx_pcrel)
	    {
	      if (fixP->fx_addsy != NULL)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("cannot emit PC relative %s relocation against %s"),
			      bfd_get_reloc_code_name (fixP->fx_r_type),
			      S_GET_NAME (fixP->fx_addsy));
	      else
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("cannot emit PC relative %s relocation"),
			      bfd_get_reloc_code_name (fixP->fx_r_type));
	    }

	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 2);
	  break;

	case BFD_RELOC_16:
d6365 1
a6365 1
	    fixP->fx_r_type = BFD_RELOC_16_PCREL;
a6366 6

	case BFD_RELOC_16_PCREL:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 2);
	  break;

a6370 1

d6372 1
a6372 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 2);
a6374 3
	  /* This case happens when you write, for example,
	     lis %r3,(L1-L2)@@ha
	     where L1 and L2 are defined later.  */
a6378 1

d6380 1
a6380 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HI (value), 2);
a6386 1

d6388 1
a6388 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HA (value), 2);
d6391 5
a6395 96
	case BFD_RELOC_PPC_VLE_SDAREL_LO16A:
	case BFD_RELOC_PPC_VLE_LO16A:
	  {
	    int tval = PPC_VLE_LO16A (value);
  	    valueT oldval = md_chars_to_number (
				fixP->fx_frag->fr_literal + fixP->fx_where, 4);
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			        (oldval | tval), 4);
	  }
	  break;

	case BFD_RELOC_PPC_VLE_SDAREL_LO16D:
	case BFD_RELOC_PPC_VLE_LO16D:
	  {
	    int tval = PPC_VLE_LO16D (value);
  	    valueT oldval = md_chars_to_number (
				fixP->fx_frag->fr_literal + fixP->fx_where, 4);
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			        (oldval | tval), 4);
	  }
	  break;

	case BFD_RELOC_PPC_VLE_SDAREL_HI16A:
	case BFD_RELOC_PPC_VLE_HI16A:
	  {
	    int tval = PPC_VLE_HI16A (value);
  	    valueT oldval = md_chars_to_number (
				fixP->fx_frag->fr_literal + fixP->fx_where, 4);
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			        (oldval | tval), 4);
	  }
	  break;

	case BFD_RELOC_PPC_VLE_SDAREL_HI16D:
	case BFD_RELOC_PPC_VLE_HI16D:
	  {
	    int tval = PPC_VLE_HI16D (value);
  	    valueT oldval = md_chars_to_number (
				fixP->fx_frag->fr_literal + fixP->fx_where, 4);
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			        (oldval | tval), 4);
	  }
	  break;

	case BFD_RELOC_PPC_VLE_SDAREL_HA16A:
	case BFD_RELOC_PPC_VLE_HA16A:
	  {
	    int tval = PPC_VLE_HA16A (value);
  	    valueT oldval = md_chars_to_number (
				fixP->fx_frag->fr_literal + fixP->fx_where, 4);
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			        (oldval | tval), 4);
	  }
	  break;

	case BFD_RELOC_PPC_VLE_SDAREL_HA16D:
	case BFD_RELOC_PPC_VLE_HA16D:
	  {
	    int tval = PPC_VLE_HA16D (value);
  	    valueT oldval = md_chars_to_number (
				fixP->fx_frag->fr_literal + fixP->fx_where, 4);
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			        (oldval | tval), 4);
	  }
	  break;

	case BFD_RELOC_PPC_VLE_SDA21_LO:
	  {
	    int tval = PPC_LO (value);
  	    valueT oldval = md_chars_to_number (
			     fixP->fx_frag->fr_literal + fixP->fx_where, 4);
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			        (oldval | tval), 4);
	  }
	  break;

	case BFD_RELOC_PPC_VLE_SDA21:
	  {
  	    valueT oldval = md_chars_to_number (
			     fixP->fx_frag->fr_literal + fixP->fx_where, 4);
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			        (oldval | value), 4);
	  }
	  break;

#ifdef OBJ_XCOFF
	case BFD_RELOC_NONE:
	  break;
#endif

#ifdef OBJ_ELF
	case BFD_RELOC_PPC64_HIGHER:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHER (value), 2);
d6400 2
a6401 3
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHERA (value), 2);
d6406 2
a6407 3
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHEST (value), 2);
d6412 2
a6413 3
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHESTA (value), 2);
d6416 2
a6417 46
	case BFD_RELOC_PPC64_ADDR16_DS:
	case BFD_RELOC_PPC64_ADDR16_LO_DS:
	case BFD_RELOC_PPC64_GOT16_DS:
	case BFD_RELOC_PPC64_GOT16_LO_DS:
	case BFD_RELOC_PPC64_PLT16_LO_DS:
	case BFD_RELOC_PPC64_SECTOFF_DS:
	case BFD_RELOC_PPC64_SECTOFF_LO_DS:
	case BFD_RELOC_PPC64_TOC16_DS:
	case BFD_RELOC_PPC64_TOC16_LO_DS:
	case BFD_RELOC_PPC64_PLTGOT16_DS:
	case BFD_RELOC_PPC64_PLTGOT16_LO_DS:
	  if (fixP->fx_pcrel)
	    abort ();
	  {
	    char *where = fixP->fx_frag->fr_literal + fixP->fx_where;
	    unsigned long val, mask;

	    if (target_big_endian)
	      val = bfd_getb32 (where - 2);
	    else
	      val = bfd_getl32 (where);
	    mask = 0xfffc;
	    /* lq insns reserve the four lsbs.  */
	    if ((ppc_cpu & PPC_OPCODE_POWER4) != 0
		&& (val & (0x3f << 26)) == (56u << 26))
	      mask = 0xfff0;
	    val |= value & mask;
	    if (target_big_endian)
	      bfd_putb16 ((bfd_vma) val, where);
	    else
	      bfd_putl16 ((bfd_vma) val, where);
	  }
	  break;

	case BFD_RELOC_PPC_B16_BRTAKEN:
	case BFD_RELOC_PPC_B16_BRNTAKEN:
	case BFD_RELOC_PPC_BA16_BRTAKEN:
	case BFD_RELOC_PPC_BA16_BRNTAKEN:
	  break;

	case BFD_RELOC_PPC_TLS:
	case BFD_RELOC_PPC_TLSGD:
	case BFD_RELOC_PPC_TLSLD:
	  break;

	case BFD_RELOC_PPC_DTPMOD:
a6421 1
	case BFD_RELOC_PPC_TPREL:
a6425 1
	case BFD_RELOC_PPC_DTPREL:
d6454 1
d6456 3
d6460 42
a6501 3
#endif
	  /* Because SDA21 modifies the register field, the size is set to 4
	     bytes, rather than 2, so offset it here appropriately.  */
d6503 22
d6526 3
a6528 1
	    abort ();
d6530 1
a6530 3
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where
			      + ((target_big_endian) ? 2 : 0),
			      value, 2);
d6532 1
d6534 37
a6570 2
	case BFD_RELOC_8:
	  if (fixP->fx_pcrel)
d6572 2
a6573 5
	      /* This can occur if there is a bug in the input assembler, eg:
		 ".byte <undefined_symbol> - ."  */
	      if (fixP->fx_addsy)
		as_bad (_("unable to handle reference to symbol %s"),
			S_GET_NAME (fixP->fx_addsy));
d6575 1
a6575 2
		as_bad (_("unable to resolve expression"));
	      fixP->fx_done = 1;
d6577 17
d6595 37
a6631 2
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
				value, 1);
d6634 9
a6642 4
	case BFD_RELOC_24_PLT_PCREL:
	case BFD_RELOC_PPC_LOCAL24PC:
	  if (!fixP->fx_pcrel && !fixP->fx_done)
	    abort ();
d6644 2
a6645 1
	  if (fixP->fx_done)
d6647 7
a6653 2
	      char *where;
	      unsigned long insn;
d6655 7
a6661 10
	      /* Fetch the instruction, insert the fully resolved operand
		 value, and stuff the instruction back again.  */
	      where = fixP->fx_frag->fr_literal + fixP->fx_where;
	      if (target_big_endian)
		insn = bfd_getb32 ((unsigned char *) where);
	      else
		insn = bfd_getl32 ((unsigned char *) where);
	      if (ppc_mach() == bfd_mach_ppc_vle)
		{
		  if ((value & 1) != 0)
d6663 4
a6666 1
			          _("branch address must be a multiple of 2"));
a6668 7
		{
		  if ((value & 3) != 0)
		    as_bad_where (fixP->fx_file, fixP->fx_line,
			          _("branch address must be a multiple of 4"));
		}
	      if ((offsetT) value < -0x40000000
		  || (offsetT) value >= 0x40000000)
d6670 2
a6671 7
			      _("@@local or @@plt branch destination is too far away, %ld bytes"),
			      (long) value);
	      insn = insn | (value & 0x03fffffc);
	      if (target_big_endian)
		bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	      else
		bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
d6673 3
a6678 1
	  fixP->fx_done = 0;
d6683 1
a6683 1
	  break;
d6690 122
a6811 2
	  /* Generated by reference to `sym@@tocbase'.  The sym is
	     ignored by the linker.  */
d6813 12
d6828 6
d6843 1
@


1.186
log
@	PR target/14758
bfd/
	* elf32-ppc.c (ppc_elf_reloc_type_lookup): Decode ppc64 _DS
	bfd_reloc values.  Map to corresponding D-form relocs.
	(is_insn_ds_form, is_insn_qs_form): New functions.
	(ppc_elf_relocate_section): Validate insn with DS-form or DQ-form
	fields using D-form reloc.
gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Fix comment.
	(md_assemble): Translate to _DS relocs for ppc32 as well as ppc64.
	(tc_gen_reloc): Handle _DS relocs in ppc32 mode.
@
text
@a4889 2
  symbolS *tmp;

a5060 1
  expressionS ex;
a5065 3
  unsigned int exp;
  flagword flags;
  asection *sec;
@


1.185
log
@gas/ChangeLog:
2012-08-01  James Lemke  <jwlemke@@codesourcery.com>

	* gas/dwarf2dbg.c (out_set_addr): Allow for non-constant value of
	DWARF2_LINE_MIN_INSN_LENGTH
	* gas/config/tc-ppc.c (ppc_dwarf2_line_min_insn_length): Declare
	and initialize.
	(md_apply_fix): Branch addr can be a multiple of 2 or 4.
	* gas/config/tc-ppc.h (DWARF2_LINE_MIN_INSN_LENGTH): Now a
	variable reference.

gas/testsuite/ChangeLog:
2012-08-01  James Lemke  <jwlemke@@codesourcery.com>

	* gas/cfi/cfi-ppc-1.d: Allow for code alignment of 2 or 4.

ld/ChangeLog:
2012-08-01  James Lemke  <jwlemke@@codesourcery.com>

	* ld/testsuite/ld-gc/pr13683.d: XFAIL for powerpc*-*-eabivle.
@
text
@d1516 1
a1516 1
   for .cpu pseudo.  */
d3065 1
a3065 2
	      if (ppc_obj64
		  && (operand->flags & (PPC_OPERAND_DS | PPC_OPERAND_DQ)) != 0)
@


1.184
log
@	* config/tc-ppc.c: Don't capitalise error and warning messages.
	(md_parse_option): Add checks for -a32 -mvle.
@
text
@d216 3
d1701 1
d6889 12
a6900 3
	      if ((value & 3) != 0)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("must branch to an address a multiple of 4"));
@


1.184.2.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@a215 3
/* The dwarf2 minimum instruction length.  */
int ppc_dwarf2_line_min_insn_length;

a222 1
ppc_cpu_t sticky = 0;
d1089 29
d1189 1
a1189 1
      new_cpu = ppc_parse_cpu (ppc_cpu, &sticky, arg);
d1513 1
a1513 1
   for .machine pseudo.  */
a1535 4
      /* An index into powerpc_operands is stored in struct fix
	 fx_pcrel_adjust which is 8 bits wide.  */
      gas_assert (num_powerpc_operands < 256);

a1697 1
  ppc_dwarf2_line_min_insn_length = (ppc_cpu & PPC_OPCODE_VLE) ? 2 : 4;
a2449 19

#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
/* See whether a symbol is in the TOC section.  */

static int
ppc_is_toc_sym (symbolS *sym)
{
#ifdef OBJ_XCOFF
  return symbol_get_tc (sym)->symbol_class == XMC_TC;
#endif
#ifdef OBJ_ELF
  const char *sname = segment_name (S_GET_SEGMENT (sym));
  if (ppc_obj64)
    return strcmp (sname, ".toc") == 0;
  else
    return strcmp (sname, ".got") == 0;
#endif
}
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */
d2532 3
a2815 1
	  bfd_reloc_code_real_type reloc;
d2881 1
a2883 2
	  bfd_reloc_code_real_type reloc = BFD_RELOC_UNUSED;
#ifdef OBJ_ELF
d3061 2
a3062 1
	      if ((operand->flags & (PPC_OPERAND_DS | PPC_OPERAND_DQ)) != 0)
a3121 60
#endif /* OBJ_ELF */

	  if (reloc != BFD_RELOC_UNUSED)
	    ;
	  /* Determine a BFD reloc value based on the operand information.
	     We are only prepared to turn a few of the operands into
	     relocs.  */
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0x3fffffc
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_B26;
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0xfffc
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_B16;
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0x1fe
		   && operand->shift == -1)
	    reloc = BFD_RELOC_PPC_VLE_REL8;
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0xfffe
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_VLE_REL15;
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
		   && operand->bitm == 0x1fffffe
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_VLE_REL24;
	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
		   && operand->bitm == 0x3fffffc
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_BA26;
	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
		   && operand->bitm == 0xfffc
		   && operand->shift == 0)
	    reloc = BFD_RELOC_PPC_BA16;
#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
	  else if ((operand->flags & PPC_OPERAND_PARENS) != 0
		   && (operand->bitm & 0xfff0) == 0xfff0
		   && operand->shift == 0)
	    {
	      if (ppc_is_toc_sym (ex.X_add_symbol))
		{
		  reloc = BFD_RELOC_PPC_TOC16;
#ifdef OBJ_ELF
		  if (ppc_obj64
		      && (operand->flags & PPC_OPERAND_DS) != 0)
		    reloc = BFD_RELOC_PPC64_TOC16_DS;
#endif
		}
	      else
		{
		  reloc = BFD_RELOC_16;
#ifdef OBJ_ELF
		  if (ppc_obj64
		      && (operand->flags & PPC_OPERAND_DS) != 0)
		    reloc = BFD_RELOC_PPC64_ADDR16_DS;
#endif
		}
	    }
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */
d3131 12
d3243 6
a3248 1
  /* Create any fixups.  */
a3250 1
      fixS *fixP;
d3256 1
d3263 1
a3263 1
	  offset = target_big_endian ? (insn_length - size) : 0;
d3274 27
d3307 7
a3313 6
	  fixP = fix_new_exp (frag_now,
			      f - frag_now->fr_literal,
			      insn_length,
			      &fixups[i].exp,
			      (operand->flags & PPC_OPERAND_RELATIVE) != 0,
			      BFD_RELOC_UNUSED);
a3314 1
      fixP->fx_pcrel_adjust = fixups[i].opindex;
d4837 1
a4837 1
      else if ((new_cpu = ppc_parse_cpu (ppc_cpu, &sticky, cpu_string)) != 0)
d4848 17
d6298 7
a6304 1
   fixups we generated by the calls to fix_new_exp, above.  */
d6348 1
a6348 1
  if (fixP->fx_pcrel_adjust != 0)
d6350 2
a6351 4
      /* Handle relocs in an insn.  */

      int opindex = fixP->fx_pcrel_adjust & 0xff;
      const struct powerpc_operand *operand = &powerpc_operands[opindex];
d6354 4
a6357 1
      offsetT fieldval;
d6378 138
a6515 1
      fieldval = value;
d6518 51
d6570 22
a6591 1
	case BFD_RELOC_PPC64_ADDR16_LO_DS:
d6593 1
a6593 1
	    goto bad_pcrel;
d6595 6
a6600 1
#endif
d6605 1
d6607 2
a6608 1
	  fieldval = SEX16 (value);
d6611 3
d6618 1
d6620 2
a6621 1
	  fieldval = SEX16 (PPC_HI (value));
d6628 1
d6630 2
a6631 1
	  fieldval = SEX16 (PPC_HA (value));
d6634 9
a6642 5
#ifdef OBJ_ELF
	case BFD_RELOC_PPC64_HIGHER:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  fieldval = SEX16 (PPC_HIGHER (value));
d6645 9
a6653 4
	case BFD_RELOC_PPC64_HIGHER_S:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  fieldval = SEX16 (PPC_HIGHERA (value));
d6656 88
a6743 4
	case BFD_RELOC_PPC64_HIGHEST:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  fieldval = SEX16 (PPC_HIGHEST (value));
d6748 37
a6784 2
	    goto bad_pcrel;
	  fieldval = SEX16 (PPC_HIGHESTA (value));
d6787 12
a6798 2
	  /* The following relocs can't be calculated by the assembler.
	     Leave the field zero.  */
d6803 1
d6808 1
a6836 1
	  gas_assert (fixP->fx_addsy != NULL);
a6837 3
	  fieldval = 0;
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
d6839 3
a6841 42

	  /* These also should leave the field zero for the same
	     reason.  Note that older versions of gas wrote values
	     here.  If we want to go back to the old behaviour, then
	     all _LO and _LO_DS cases will need to be treated like
	     BFD_RELOC_LO16_PCREL above.  Similarly for _HI etc.  */
	case BFD_RELOC_16_GOTOFF:
	case BFD_RELOC_LO16_GOTOFF:
	case BFD_RELOC_HI16_GOTOFF:
	case BFD_RELOC_HI16_S_GOTOFF:
	case BFD_RELOC_LO16_PLTOFF:
	case BFD_RELOC_HI16_PLTOFF:
	case BFD_RELOC_HI16_S_PLTOFF:
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_16_BASEREL:
	case BFD_RELOC_LO16_BASEREL:
	case BFD_RELOC_HI16_BASEREL:
	case BFD_RELOC_HI16_S_BASEREL:
	case BFD_RELOC_PPC_TOC16:
	case BFD_RELOC_PPC64_TOC16_LO:
	case BFD_RELOC_PPC64_TOC16_HI:
	case BFD_RELOC_PPC64_TOC16_HA:
	case BFD_RELOC_PPC64_PLTGOT16:
	case BFD_RELOC_PPC64_PLTGOT16_LO:
	case BFD_RELOC_PPC64_PLTGOT16_HI:
	case BFD_RELOC_PPC64_PLTGOT16_HA:
	case BFD_RELOC_PPC64_GOT16_DS:
	case BFD_RELOC_PPC64_GOT16_LO_DS:
	case BFD_RELOC_PPC64_PLT16_LO_DS:
	case BFD_RELOC_PPC64_SECTOFF_DS:
	case BFD_RELOC_PPC64_SECTOFF_LO_DS:
	case BFD_RELOC_PPC64_TOC16_DS:
	case BFD_RELOC_PPC64_TOC16_LO_DS:
	case BFD_RELOC_PPC64_PLTGOT16_DS:
	case BFD_RELOC_PPC64_PLTGOT16_LO_DS:
	case BFD_RELOC_PPC_EMB_NADDR16:
	case BFD_RELOC_PPC_EMB_NADDR16_LO:
	case BFD_RELOC_PPC_EMB_NADDR16_HI:
	case BFD_RELOC_PPC_EMB_NADDR16_HA:
	case BFD_RELOC_PPC_EMB_SDAI16:
	case BFD_RELOC_PPC_EMB_SDA2I16:
	case BFD_RELOC_PPC_EMB_SDA2REL:
a6842 22
	case BFD_RELOC_PPC_EMB_MRKREF:
	case BFD_RELOC_PPC_EMB_RELSEC16:
	case BFD_RELOC_PPC_EMB_RELST_LO:
	case BFD_RELOC_PPC_EMB_RELST_HI:
	case BFD_RELOC_PPC_EMB_RELST_HA:
	case BFD_RELOC_PPC_EMB_BIT_FLD:
	case BFD_RELOC_PPC_EMB_RELSDA:
	case BFD_RELOC_PPC_VLE_SDA21:
	case BFD_RELOC_PPC_VLE_SDA21_LO:
	case BFD_RELOC_PPC_VLE_SDAREL_LO16A:
	case BFD_RELOC_PPC_VLE_SDAREL_LO16D:
	case BFD_RELOC_PPC_VLE_SDAREL_HI16A:
	case BFD_RELOC_PPC_VLE_SDAREL_HI16D:
	case BFD_RELOC_PPC_VLE_SDAREL_HA16A:
	case BFD_RELOC_PPC_VLE_SDAREL_HA16D:
	  gas_assert (fixP->fx_addsy != NULL);
	  /* Fall thru */

	case BFD_RELOC_PPC_TLS:
	case BFD_RELOC_PPC_TLSGD:
	case BFD_RELOC_PPC_TLSLD:
	  fieldval = 0;
d6844 1
a6844 3
	    goto bad_pcrel;
	  break;
#endif
d6846 3
a6848 1
	default:
a6849 1
	}
d6851 2
a6852 13
#ifdef OBJ_ELF
/* powerpc uses RELA style relocs, so if emitting a reloc the field
   contents can stay at zero.  */
#define APPLY_RELOC fixP->fx_done
#else
#define APPLY_RELOC 1
#endif
      if ((fieldval != 0 && APPLY_RELOC) || operand->insert != NULL)
	{
	  /* Fetch the instruction, insert the fully resolved operand
	     value, and stuff the instruction back again.  */
	  where = fixP->fx_frag->fr_literal + fixP->fx_where;
	  if (target_big_endian)
d6854 5
a6858 2
	      if (fixP->fx_size == 4)
		insn = bfd_getb32 ((unsigned char *) where);
d6860 2
a6861 18
		insn = bfd_getb16 ((unsigned char *) where);
	    }
	  else
	    {
	      if (fixP->fx_size == 4)
		insn = bfd_getl32 ((unsigned char *) where);
	      else
		insn = bfd_getl16 ((unsigned char *) where);
	    }
	  insn = ppc_insert_operand (insn, operand, fieldval,
				     fixP->tc_fix_data.ppc_cpu,
				     fixP->fx_file, fixP->fx_line);
	  if (target_big_endian)
	    {
	      if (fixP->fx_size == 4)
		bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	      else
		bfd_putb16 ((bfd_vma) insn, (unsigned char *) where);
d6864 2
a6865 52
	    {
	      if (fixP->fx_size == 4)
		bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
	      else
		bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);
	    }
	}

      if (fixP->fx_done)
	/* Nothing else to do here.  */
	return;

      gas_assert (fixP->fx_addsy != NULL);
      if (fixP->fx_r_type == BFD_RELOC_UNUSED)
	{
	  char *sfile;
	  unsigned int sline;

	  /* Use expr_symbol_where to see if this is an expression
	     symbol.  */
	  if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unresolved expression that must be resolved"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unsupported relocation against %s"),
			  S_GET_NAME (fixP->fx_addsy));
	  fixP->fx_done = 1;
	  return;
	}
    }
  else
    {
      int size = 0;
      offsetT fieldval = value;

      /* Handle relocs in data.  */
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_CTOR:
	  if (ppc_obj64)
	    goto ctor64;
	  /* fall through */

	case BFD_RELOC_32:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  /* fall through */

	case BFD_RELOC_32_PCREL:
	case BFD_RELOC_RVA:
	  size = 4;
d6868 4
a6871 5
	case BFD_RELOC_64:
	ctor64:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_64_PCREL;
	  /* fall through */
d6873 1
a6873 15
	case BFD_RELOC_64_PCREL:
	  size = 8;
	  break;

	case BFD_RELOC_16:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_16_PCREL;
	  /* fall through */

	case BFD_RELOC_16_PCREL:
	  size = 2;
	  break;

	case BFD_RELOC_8:
	  if (fixP->fx_pcrel)
d6875 2
a6876 7
#ifdef OBJ_ELF
	    bad_pcrel:
#endif
	      if (fixP->fx_addsy)
		{
		  char *sfile;
		  unsigned int sline;
d6878 5
a6882 13
		  /* Use expr_symbol_where to see if this is an
		     expression symbol.  */
		  if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
		    as_bad_where (fixP->fx_file, fixP->fx_line,
				  _("unresolved expression that must"
				    " be resolved"));
		  else
		    as_bad_where (fixP->fx_file, fixP->fx_line,
				  _("cannot emit PC relative %s relocation"
				    " against %s"),
				  bfd_get_reloc_code_name (fixP->fx_r_type),
				  S_GET_NAME (fixP->fx_addsy));
		}
d6884 2
d6887 11
a6897 2
			      _("unable to resolve expression"));
	      fixP->fx_done = 1;
a6898 2
	  else
	    size = 1;
d6902 1
d6907 1
a6907 1
	  /* Fall thru */
d6914 2
a6915 121
	  /* These can appear with @@l etc. in data.  */
	case BFD_RELOC_LO16:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_LO16_PCREL;
	case BFD_RELOC_LO16_PCREL:
	  size = 2;
	  break;

	case BFD_RELOC_HI16:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_HI16_PCREL;
	case BFD_RELOC_HI16_PCREL:
	  size = 2;
	  fieldval = PPC_HI (value);
	  break;

	case BFD_RELOC_HI16_S:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_HI16_S_PCREL;
	case BFD_RELOC_HI16_S_PCREL:
	  size = 2;
	  fieldval = PPC_HA (value);
	  break;

	case BFD_RELOC_PPC64_HIGHER:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  size = 2;
	  fieldval = PPC_HIGHER (value);
	  break;

	case BFD_RELOC_PPC64_HIGHER_S:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  size = 2;
	  fieldval = PPC_HIGHERA (value);
	  break;

	case BFD_RELOC_PPC64_HIGHEST:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  size = 2;
	  fieldval = PPC_HIGHEST (value);
	  break;

	case BFD_RELOC_PPC64_HIGHEST_S:
	  if (fixP->fx_pcrel)
	    goto bad_pcrel;
	  size = 2;
	  fieldval = PPC_HIGHESTA (value);
	  break;

	case BFD_RELOC_PPC_DTPMOD:
	case BFD_RELOC_PPC_TPREL:
	case BFD_RELOC_PPC_DTPREL:
	  S_SET_THREAD_LOCAL (fixP->fx_addsy);
	  break;

	  /* Just punt all of these to the linker.  */
	case BFD_RELOC_PPC_B16_BRTAKEN:
	case BFD_RELOC_PPC_B16_BRNTAKEN:
	case BFD_RELOC_16_GOTOFF:
	case BFD_RELOC_LO16_GOTOFF:
	case BFD_RELOC_HI16_GOTOFF:
	case BFD_RELOC_HI16_S_GOTOFF:
	case BFD_RELOC_LO16_PLTOFF:
	case BFD_RELOC_HI16_PLTOFF:
	case BFD_RELOC_HI16_S_PLTOFF:
	case BFD_RELOC_PPC_COPY:
	case BFD_RELOC_PPC_GLOB_DAT:
	case BFD_RELOC_16_BASEREL:
	case BFD_RELOC_LO16_BASEREL:
	case BFD_RELOC_HI16_BASEREL:
	case BFD_RELOC_HI16_S_BASEREL:
	case BFD_RELOC_PPC_TLS:
	case BFD_RELOC_PPC_DTPREL16_LO:
	case BFD_RELOC_PPC_DTPREL16_HI:
	case BFD_RELOC_PPC_DTPREL16_HA:
	case BFD_RELOC_PPC_TPREL16_LO:
	case BFD_RELOC_PPC_TPREL16_HI:
	case BFD_RELOC_PPC_TPREL16_HA:
	case BFD_RELOC_PPC_GOT_TLSGD16:
	case BFD_RELOC_PPC_GOT_TLSGD16_LO:
	case BFD_RELOC_PPC_GOT_TLSGD16_HI:
	case BFD_RELOC_PPC_GOT_TLSGD16_HA:
	case BFD_RELOC_PPC_GOT_TLSLD16:
	case BFD_RELOC_PPC_GOT_TLSLD16_LO:
	case BFD_RELOC_PPC_GOT_TLSLD16_HI:
	case BFD_RELOC_PPC_GOT_TLSLD16_HA:
	case BFD_RELOC_PPC_GOT_DTPREL16:
	case BFD_RELOC_PPC_GOT_DTPREL16_LO:
	case BFD_RELOC_PPC_GOT_DTPREL16_HI:
	case BFD_RELOC_PPC_GOT_DTPREL16_HA:
	case BFD_RELOC_PPC_GOT_TPREL16:
	case BFD_RELOC_PPC_GOT_TPREL16_LO:
	case BFD_RELOC_PPC_GOT_TPREL16_HI:
	case BFD_RELOC_PPC_GOT_TPREL16_HA:
	case BFD_RELOC_24_PLT_PCREL:
	case BFD_RELOC_PPC_LOCAL24PC:
	case BFD_RELOC_32_PLT_PCREL:
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_PPC_VLE_SDAREL_LO16A:
	case BFD_RELOC_PPC_VLE_SDAREL_HI16A:
	case BFD_RELOC_PPC_VLE_SDAREL_HA16A:
	case BFD_RELOC_PPC_EMB_NADDR32:
	case BFD_RELOC_PPC_EMB_NADDR16:
	case BFD_RELOC_PPC_EMB_NADDR16_LO:
	case BFD_RELOC_PPC_EMB_NADDR16_HI:
	case BFD_RELOC_PPC_EMB_NADDR16_HA:
	case BFD_RELOC_PPC_EMB_SDAI16:
	case BFD_RELOC_PPC_EMB_SDA2REL:
	case BFD_RELOC_PPC_EMB_SDA2I16:
	case BFD_RELOC_PPC_EMB_SDA21:
	case BFD_RELOC_PPC_VLE_SDA21_LO:
	case BFD_RELOC_PPC_EMB_MRKREF:
	case BFD_RELOC_PPC_EMB_RELSEC16:
	case BFD_RELOC_PPC_EMB_RELST_LO:
	case BFD_RELOC_PPC_EMB_RELST_HI:
	case BFD_RELOC_PPC_EMB_RELST_HA:
	case BFD_RELOC_PPC_EMB_BIT_FLD:
	case BFD_RELOC_PPC_EMB_RELSDA:
a6916 12
	case BFD_RELOC_PPC_TOC16:
	case BFD_RELOC_PPC64_TOC16_LO:
	case BFD_RELOC_PPC64_TOC16_HI:
	case BFD_RELOC_PPC64_TOC16_HA:
	case BFD_RELOC_PPC64_DTPREL16_HIGHER:
	case BFD_RELOC_PPC64_DTPREL16_HIGHERA:
	case BFD_RELOC_PPC64_DTPREL16_HIGHEST:
	case BFD_RELOC_PPC64_DTPREL16_HIGHESTA:
	case BFD_RELOC_PPC64_TPREL16_HIGHER:
	case BFD_RELOC_PPC64_TPREL16_HIGHERA:
	case BFD_RELOC_PPC64_TPREL16_HIGHEST:
	case BFD_RELOC_PPC64_TPREL16_HIGHESTA:
a6919 6

#ifdef OBJ_XCOFF
	case BFD_RELOC_NONE:
	  break;
#endif

a6925 4

      if (size && APPLY_RELOC)
	md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			    fieldval, size);
a6928 1
  ppc_elf_validate_fix (fixP, seg);
@


1.183
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d1139 1
a1139 1
	    as_bad (_("The use of -mvle requires big endian."));
d1176 2
d1193 7
a1199 2
	  if (set_target_endian && target_big_endian == 0)
	    as_bad (_("The use of -mvle requires big endian."));
d1234 1
a1234 1
	    as_bad (_("The use of -mvle requires big endian."));
d1388 1
a1388 1
	as_fatal (_("Unknown default cpu = %s, os = %s"),
d1416 1
a1416 1
  as_fatal (_("Neither Power nor PowerPC opcodes were selected."));
d2175 1
a2175 1
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
d2208 1
a2208 1
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
d2216 1
a2216 1
      as_bad (_("Length of .lcomm \"%s\" is already %ld. Not changed to %ld."),
d2234 1
a2234 1
	  as_bad (_("Common alignment not a power of 2"));
d2296 1
a2296 1
			    _("Relocation cannot be done when using -mrelocatable"));
d2550 1
a2550 1
	as_bad (_("Unrecognized opcode: `%s'"), str);
d2745 1
a2745 1
	      as_bad (_("Unimplemented toc32 expression modifier"));
d2750 1
a2750 1
	      as_bad (_("Unimplemented toc64 expression modifier"));
d3821 1
a3821 1
      as_bad (_("No known dwarf XCOFF section for flag 0x%08x\n"),
d3950 1
a3950 1
      as_bad (_("The XCOFF file format does not support arbitrary sections"));
d4891 1
a4891 1
      as_warn (_("No previous section to return to. Directive ignored."));
d5126 1
a5126 1
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
d5162 1
a5162 1
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
d5171 1
a5171 1
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
d5301 1
a5301 1
		  as_bad (_("Unsupported section attribute -- 'a'"));
d5578 1
a5578 1
    as_bad (_("Unrecognized symbol suffix"));
d6857 1
a6857 1
		as_bad (_("Unable to handle reference to symbol %s"),
d6860 1
a6860 1
		as_bad (_("Unable to resolve expression"));
@


1.182
log
@include/opcode/
	* ppc.h: Add PPC_OPCODE_ALTIVEC2, PPC_OPCODE_E6500, PPC_OPCODE_TMR.
opcodes/
	* ppc-dis.c (ppc_opts): Add entries for "e5500" and "e6500".
	* ppc-opc.c (insert_ls, TMR, ESYNC, XSYNCLE_MASK): New.
	(PPCVEC2, PPCTMR, E6500): New short names.
	(powerpc_opcodes): Add vabsdub, vabsduh, vabsduw, dni, mvidsplt,
	mviwsplt, icblq., mftmr, mttmr, dcblq., miso, lvexbx, lvexhx,
	lvexwx, stvexbx, stvexhx, stvexwx, lvepx, lvepxl, stvepx, stvepxl,
	lvtrx, lvtrxl, lvtlx, lvtlxl, stvfrx, stvfrxl, stvflx, stvflxl,
	lvswx, lvswxl, stvswx, stvswxl, lvsm mnemonics. Accept LS, ESYNC
	optional operands on sync instruction for E6500 target.
bfd/
	* archures.c: Add bfd_mach_ppc_e5500 and bfd_mach_ppc_e6500.
	* bfd-in2.h: Regenerate.
	* cpu-powerpc.c (bfd_powerpc_archs): Add entryies for
	bfd_mach_ppc_e5500 and bfd_mach_ppc_e6500.
gas/
	* config/tc-ppc.c (md_show_usage): Document -me5500 and -me6500.
	(ppc_handle_align): Add termination nop opcode for e500mc family.
	* doc/as.texinfo: Document options -me5500 and -me6500.
	* doc/c-ppc.texi: Likewise.
gas/testsuite/
	* gas/ppc/e500mc64_nop.s: New test case for e500mc family
	termination nops.
	* gas/ppc/e500mc64_nop.d: Likewise.
	* gas/ppc/e5500_nop.s: Likewise.
	* gas/ppc/e5500_nop.d: Likewise.
	* gas/ppc/e6500_nop.s: Likewise.
	* gas/ppc/e6500_nop.d: Likewise.
	* gas/ppc/e6500.s: New.
	* gas/ppc/e6500.d: Likewise.
	* gas/ppc/ppc.exp: Run e6500, e500mc64_nop, e5500_nop, and e6500_nop.
@
text
@d67 14
d84 6
d95 6
d1067 1
d1089 29
d1138 2
d1187 7
a1193 2
      if ((new_cpu = ppc_parse_cpu (ppc_cpu, arg)) != 0)
	ppc_cpu = new_cpu;
d1226 2
d1336 1
d1397 3
a1399 1
  else if ((ppc_cpu & PPC_OPCODE_POWER) != 0)
d1401 1
a1401 1
  else if ((ppc_cpu & (PPC_OPCODE_COMMON | PPC_OPCODE_ANY)) != 0)
d1422 2
d1457 48
a1560 3
	  const unsigned char *o;
	  unsigned long omask = op->mask;

d1563 10
d1576 1
a1576 1
	      if (PPC_OP (op[0].opcode) < PPC_OP (op[-1].opcode))
d1582 3
d1586 4
a1589 20
	      /* Warn if the table isn't more strictly ordered.
		 Unfortunately it doesn't seem possible to order the
		 table on much more than the major opcode, which makes
		 it difficult to implement a binary search in the
		 disassembler.  The problem is that we have multiple
		 ways to disassemble instructions, and we usually want
		 to choose a more specific form (with more bits set in
		 the opcode) than a more general form.  eg. all of the
		 following are equivalent:
		 bne label	# opcode = 0x40820000, mask = 0xff830003
		 bf  2,label	# opcode = 0x40800000, mask = 0xff800003
		 bc  4,2,label	# opcode = 0x40000000, mask = 0xfc000003

		 There are also cases where the table needs to be out
		 of order to disassemble the correct instruction for
		 processor variants.  */
	      else if (0)
		{
		  unsigned long t1 = op[0].opcode;
		  unsigned long t2 = op[-1].opcode;
d1591 6
a1596 14
		  if (((t1 ^ t2) & 0xfc0007ff) == 0
		      && (t1 & 0xfc0006df) == 0x7c000286)
		    {
		      /* spr field is split.  */
		      t1 = ((t1 & ~0x1ff800)
			    | ((t1 & 0xf800) << 5) | ((t1 & 0x1f0000) >> 5));
		      t2 = ((t2 & ~0x1ff800)
			    | ((t2 & 0xf800) << 5) | ((t2 & 0x1f0000) >> 5));
		    }
		  if (t1 < t2)
		    as_warn (_("%s (%08lx %08lx) after %s (%08lx %08lx)"),
			     op[0].name, op[0].opcode, op[0].mask,
			     op[-1].name, op[-1].opcode, op[-1].mask);
		}
d1598 2
d1601 10
a1610 2
	  /* The mask had better not trim off opcode bits.  */
	  if ((op->opcode & omask) != op->opcode)
d1612 22
a1633 3
	      as_bad (_("mask trims opcode bits for %s"),
		      op->name);
	      bad_insn = TRUE;
d1636 1
a1636 23
	  /* The operands must not overlap the opcode or each other.  */
	  for (o = op->operands; *o; ++o)
	    if (*o >= num_powerpc_operands)
	      {
		as_bad (_("operand index error for %s"),
			op->name);
		bad_insn = TRUE;
	      }
	    else
	      {
		const struct powerpc_operand *operand = &powerpc_operands[*o];
		if (operand->shift >= 0)
		  {
		    unsigned long mask = operand->bitm << operand->shift;
		    if (omask & mask)
		      {
			as_bad (_("operand %d overlap in %s"),
				(int) (o - op->operands), op->name);
			bad_insn = TRUE;
		      }
		    omask |= mask;
		  }
	      }
d1654 2
a1655 2
  if ((ppc_cpu & PPC_OPCODE_ANY) != 0)
    for (op = powerpc_opcodes; op < op_end; op++)
d1857 2
d1860 1
a1860 1
    insn |= ((long) val & operand->bitm) << operand->shift;
d1942 3
d1954 1
d2491 16
d2524 1
d2774 3
a2776 1
	  if ((reg_names_p && (operand->flags & PPC_OPERAND_CR) != 0)
d2781 2
a2782 1
	      if ((operand->flags & PPC_OPERAND_CR) != 0)
d2950 67
d3181 2
a3182 2
  /* Do we need/want a APUinfo section? */
  if ((ppc_cpu & (PPC_OPCODE_E500 | PPC_OPCODE_E500MC)) != 0)
d3199 2
d3205 16
a3220 2
  f = frag_more (4);
  addr_mod = frag_now_fix () & 3;
d3222 6
a3227 1
    as_bad (_("instruction address is not a multiple of 4"));
d3230 1
a3230 1
  md_number_to_chars (f, insn, 4);
d3233 1
a3233 1
  dwarf2_emit_insn (4);
d3277 6
d3302 1
a3302 1
		       4,
d6187 18
d6214 8
a6221 1
  if (count != 0 && (count & 3) == 0)
d6376 6
a6381 1
	insn = bfd_getb32 ((unsigned char *) where);
d6383 6
a6388 1
	insn = bfd_getl32 ((unsigned char *) where);
d6393 6
a6398 1
	bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
d6400 6
a6405 1
	bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
d6431 12
d6627 85
@


1.181
log
@	* config/tc-ppc.c (ppc_target_format): Add format for powerpc*-freebsd.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d1268 2
d6019 8
a6026 2
	    /* power7 group terminating nop: "ori 2,2,0".  */
	    md_number_to_chars (dest, 0x60420000, 4);
@


1.180
log
@gas/
2011-06-14  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ppc.h (struct ppc_tc_sy): Complete comment on within.
	(tc_new_dot_label): Define.
	(ppc_new_dot_label): Declare.
	* config/tc-ppc.c (ppc_frob_label): Set within target field.
	(ppc_fix_adjustable): Use this field to adjust the reloc.
	(ppc_new_dot_label): New function.


gas/testsuite/
2011-06-14  Tristan Gingold  <gingold@@adacore.com>

	* gas/ppc/test1xcoff32.d: Adjust for csect anchor.
@
text
@d1366 1
a1366 1
    return (ppc_obj64 ? "aix5coff64-rs6000" : "aixcoff-rs6000");
d1368 1
a1368 1
    return (ppc_obj64 ? "aixcoff64-rs6000" : "aixcoff-rs6000");
d1373 3
a1375 1
# ifdef TE_VXWORKS
@


1.179
log
@Fix spelling mistakes.
@
text
@d5355 1
d5845 1
a5845 26
      symbolS *csect;
      symbolS *next_csect;

      if (symseg == text_section)
	csect = ppc_text_csects;
      else if (symseg == data_section)
	csect = ppc_data_csects;
      else
	abort ();

      /* Skip the initial dummy symbol.  */
      csect = symbol_get_tc (csect)->next;

      if (csect != (symbolS *) NULL)
	{
	  while ((next_csect = symbol_get_tc (csect)->next) != (symbolS *) NULL
		 && (symbol_get_frag (next_csect)->fr_address <= val))
	    {
	      /* If the csect address equals the symbol value, then we
		 have to look through the full symbol table to see
		 whether this is the csect we want.  Note that we will
		 only get here if the csect has zero length.  */
	      if (symbol_get_frag (csect)->fr_address == val
		  && S_GET_VALUE (csect) == val)
		{
		  symbolS *scan;
d5847 5
a5851 15
		  for (scan = symbol_next (csect);
		       scan != NULL;
		       scan = symbol_next (scan))
		    {
		      if (symbol_get_tc (scan)->subseg != 0)
			break;
		      if (scan == fix->fx_addsy)
			break;
		    }

		  /* If we found the symbol before the next csect
		     symbol, then this is the csect we want.  */
		  if (scan == fix->fx_addsy)
		    break;
		}
d5853 2
a5854 2
	      csect = next_csect;
	    }
a5855 3
	  fix->fx_offset += val - symbol_get_frag (csect)->fr_address;
	  fix->fx_addsy = csect;
	}
d5897 7
@


1.178
log
@bfd
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* libxcoff.h (struct xcoff_dwsect_name): New type.
	(XCOFF_DWSECT_NBR_NAMES): New macro.
	(xcoff_dwsect_names): Declare.
	* coffcode.h (sec_to_styp_flags): Handle xcoff dwarf sections.
	(styp_to_sec_flags): Ditto.
	(coff_new_section_hook): Ditto.
	(coff_slurp_symbol_table): Handle C_DWARF and C_INFO.
	* coff-rs6000.c (xcoff_dwsect_name): New variable.

gas
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ppc.h (ppc_tc_sy): Reorder fields.
	Put size into an union with dw.
	(OBJ_COPY_SYMBOL_ATTRIBUTES): Adjust.
	(ppc_xcoff_end): Declare.
	(md_end): Define.
	* config/tc-ppc.c: Add includes for xcoff.
	(ppc_dwsect): New function.
	(md_pseudo_table): Add dwsect.
	(struct dw_subsection): New.
	(dw_sections): New.
	(ppc_change_debug_section): New function.
	(ppc_xcoff_end): Ditto.
	(ppc_function): Adjust for ppc_tc_sy.
	(ppc_symbol_new_hook): Ditto.
	(ppc_frob_symbol): Ditto.
	(ppc_frob_section): Do not set vma for debug sections.
	(ppc_fix_adjustable): Return true for debug sections.
	* config/obj-coff.c: Add includes for xcoff.
	(coff_frob_section): Handle dwarf section.

gas/testsuite
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* gas/ppc/xcoff-dwsect-1-32.d: New test.
	* gas/ppc/xcoff-dwsect-1-64.d: Ditto.
	* gas/ppc/xcoff-dwsect-1.s: New file.
	* gas/ppc/aix.exp (do_align_test): Add tests.
@
text
@d3 2
a4 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d1157 1
a1157 1
      /* -mlittle/-mbig set the endianess.  */
@


1.177
log
@2011-03-30  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ppc.c (ppc_frob_symbol): Convert stsym symbols value
	to offset only if within is set.
	(ppc_stabx): Reformat.  For stsym stabs, add a check and set
	within only for symbols.
@
text
@d38 5
d112 1
d223 1
d992 22
d1218 1
a1218 1
      
d3510 152
d4049 3
a4051 5
	      symbol_get_tc (ext_sym)->size = symbol_new ("L0\001",
							  absolute_section,
							  (valueT) 0,
							  &zero_address_frag);
	      pseudo_set (symbol_get_tc (ext_sym)->size);
d4413 27
d5266 2
a5267 1
  tc->size = NULL;
d5425 1
a5425 1
      if (symbol_get_tc (sym)->size != (symbolS *) NULL)
d5427 1
a5427 1
	  resolve_symbol_value (symbol_get_tc (sym)->size);
d5429 1
a5429 1
			    (long) S_GET_VALUE (symbol_get_tc (sym)->size));
d5696 4
d5795 4
@


1.176
log
@	* config/tc-ppc.c (md_show_usage): Remove -l and -b.  Add -K PIC.
	* doc/as.texinfo: Refer to and include c-ppc.texi for PowerPC options.
	(Overview <Target PowerPC options>): Add a number of missing options.
	* doc/c-ppc.texi: Likewise.  Add markup for use in manpage generation.
@
text
@d3750 3
a3752 1
  if (S_GET_STORAGE_CLASS (sym) == C_STSYM) {
d3754 3
a3756 1
    symbol_get_tc (sym)->within = ppc_current_block;
d3758 1
a3758 1
    /* In this case :
d3760 4
a3763 3
       .bs name
       .stabx	"z",arrays_,133,0
       .es
d3765 4
a3768 1
       .comm arrays_,13768,3
d3770 4
a3773 10
       resolve_symbol_value will copy the exp's "within" into sym's when the
       offset is 0.  Since this seems to be corner case problem,
       only do the correction for storage class C_STSYM.  A better solution
       would be to have the tc field updated in ppc_symbol_new_hook.  */

    if (exp.X_op == O_symbol)
      {
	symbol_get_tc (exp.X_add_symbol)->within = ppc_current_block;
      }
  }
d5406 1
a5406 1
      symbolS *csect;
a5407 1
      /* The value is the offset from the enclosing csect.  */
d5409 13
a5421 3
      csect = symbol_get_tc (block)->within;
      resolve_symbol_value (csect);
      S_SET_VALUE (sym, S_GET_VALUE (sym) - S_GET_VALUE (csect));
@


1.175
log
@	* config/tc-ppc.c (nop_limit): New var.
	(OPTION_NOPS): Define.
	(md_longopts): Add --nops.
	(md_parse_option): Handle it.
	(md_show_usage): Publish.
	(ppc_handle_align): Pad with a branch followed by nops if more
	than nop_limit nops.
@
text
@d1247 1
a1247 1
-mlittle, -mlittle-endian, -l, -le\n\
d1249 1
a1249 1
-mbig, -mbig-endian, -b, -be\n\
d1253 1
@


1.175.2.1
log
@	* config/tc-ppc.c (md_show_usage): Remove -l and -b.  Add -K PIC.
	* doc/as.texinfo (Overview <Target PowerPC options>): Add a number
	of missing options.
	* doc/c-ppc.texi: Likewise.
@
text
@d3 1
a3 2
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
d1247 1
a1247 1
-mlittle, -mlittle-endian, -le\n\
d1249 1
a1249 1
-mbig, -mbig-endian, -be\n\
a1252 1
-K PIC                  set EF_PPC_RELOCATABLE_LIB in ELF flags\n\
@


1.174
log
@	* config/tc-ppc.c (ppc_fix_adjustable): Add got reloc types used
	in large toc code.
@
text
@d183 4
d1025 1
d1027 1
d1181 9
d1256 2
d5768 25
@


1.173
log
@	* config/tc-ppc.c (md_assemble): Don't attempt to print NUL in
	syntax error message.
@
text
@d5727 2
@


1.172
log
@	* config/tc-ppc.c (ppc_setup_opcodes): Add all macros for -many.
@
text
@d2907 4
a2910 1
	  as_bad (_("syntax error; found `%c' but expected `%c'"), *str, endc);
@


1.171
log
@gas/:
* config/tc-ppc.c (ppc_set_cpu): Cast PPC_OPCODE_xxx to ppc_cpu_t
before inverting.

binutils/:
* ppc-dis.c (powerpc_init_dialect): Cast PPC_OPCODE_xxx to
ppc_cpu_t before inverting.
@
text
@d1501 1
a1501 1
      if ((macro->flags & ppc_cpu) != 0)
@


1.170
log
@include/opcode/
	* ppc.h (PPC_OPCODE_32, PPC_OPCODE_BOOKE64, PPC_OPCODE_CLASSIC): Delete.
	Renumber other PPC_OPCODE defines.
gas/
	* config/tc-ppc.c (ppc_set_cpu): Remove old opcode flags.
	(ppc_setup_opcodes): Likewise.  Simplify opcode selection.
opcodes/
	* ppc-dis.c (ppc_opts, powerpc_init_dialect): Remove old opcode flags.
	* ppc-opc.c (PPC32, POWER32, COM32, CLASSIC): Delete.
	(PPC64, MFDEC2): Update.
	(NON32, NO371): Define.
	(powerpc_opcode): Update to not use old opcode flags, and avoid
	-m601 duplicates.
@
text
@d1251 1
a1251 1
  if ((ppc_cpu & ~PPC_OPCODE_ANY) == 0)
@


1.169
log
@	* config/tc-ppc.c (toc_reloc_types): New variable.
	(md_assemble): Set it.
	(ppc_frob_file_before_adjust): Don't warn about toc section size
	if we have large toc relocs and no small toc relocs.
@
text
@d1254 1
a1254 1
	ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
d1257 1
a1257 1
	ppc_cpu |= PPC_OPCODE_COMMON | PPC_OPCODE_32;
d1259 1
a1259 1
	ppc_cpu |= PPC_OPCODE_POWER | PPC_OPCODE_32;
d1261 1
a1261 1
	ppc_cpu |= PPC_OPCODE_POWER | PPC_OPCODE_32;
d1263 1
a1263 1
	ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
d1476 1
a1476 5
      if ((op->flags & ppc_cpu & ~(PPC_OPCODE_32 | PPC_OPCODE_64)) != 0
	  && ((op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64)) == 0
	      || ((op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64))
		  == (ppc_cpu & (PPC_OPCODE_32 | PPC_OPCODE_64)))
	      || (ppc_cpu & PPC_OPCODE_64_BRIDGE) != 0)
a1483 5
	      /* Ignore Power duplicates for -m601.  */
	      if ((ppc_cpu & PPC_OPCODE_601) != 0
		  && (op->flags & PPC_OPCODE_POWER) != 0)
		continue;

@


1.168
log
@gas/
	* config/tc-ppc.c (md_assemble): Emit APUinfo section for
	PPC_OPCODE_E500.
gas/testsuite/
	* gas/ppc/e500.s: Add eieio, mbar and lwsync
	* gas/ppc/e500.d: Likewise.
include/opcode/
	* ppc.h (PPC_OPCODE_E500): Define.
opcodes/
	* ppc-dis.c (ppc_opts):  Remove PPC_OPCODE_E500MC from e500 and
	e500x2. Add PPC_OPCODE_E500 to e500 and e500x2
	* ppc-opc.c (powerpc_opcodes): Deprecate all opcodes on EFS which
	touch floating point regs and are enabled by COM, PPC or PPCCOM.
	Treat sync as msync on e500.  Treat eieio as mbar 1 on e500.
	Treat lwsync as msync on e500.
@
text
@d186 6
d2177 1
d2793 14
@


1.167
log
@	* config/tc-ppc.c (ppc_section_flags): Add ATTRIBUTE_UNUSED to "attr".
@
text
@d2911 1
a2911 1
  if ((ppc_cpu & PPC_OPCODE_E500MC) != 0)
@


1.166
log
@Implement generic SHF_EXCLUDE.

bfd/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* elf.c (_bfd_elf_make_section_from_shdr): Handle SHF_EXCLUDE
	(elf_fake_sections): Likewise.

	* elf32-i370.c (i370_elf_section_from_shdr): Don't handle
	SHF_EXCLUDE here.
	* elf32-ppc.c (ppc_elf_fake_sections): Likewise.

binutils/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* readelf.c (get_elf_section_flags): Treat SHF_EXCLUDE as a
	generic flag.

binutils/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* binutils-all/objcopy.exp: Run exclude-1a and exclude-1b for
	ELF targets.

	* binutils-all/exclude-1.s: New.
	* binutils-all/exclude-1a.d: Likewise.
	* binutils-all/exclude-1b.d: Likewise.

gas/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* obj-elf.c (obj_elf_change_section): Handle SHF_EXCLUDE.
	(obj_elf_parse_section_letters): Likewise.
	(obj_elf_section_word): Likewise.

	* config/tc-ppc.c (ppc_section_letter): Removed.
	(ppc_section_word): Likewise.
	* config/tc-ppc.h (ppc_section_letter): Likewise.
	(ppc_section_word): Likewise.
	(md_elf_section_letter): Likewise.
	(md_elf_section_word): Likewise.

	* doc/as.texinfo: Document `e' and `#exclude'.

gas/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* gas/elf/elf.exp: Run section8.

	* gas/elf/section8.d: New.
	* gas/elf/section8.s: Likewise.

include/elf/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* common.h (SHF_EXCLUDE): New.

	* i370.h (SHF_EXCLUDE): Removed.
	* or32.h (SHF_EXCLUDE): Likewise.
	* ppc.h (SHF_EXCLUDE): Likewise.
	* sparc.h (SHF_EXCLUDE): Likewise.

ld/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* ld-elf/exclude3.s: New.
	* ld-elf/exclude3a.d: Likewise.
	* ld-elf/exclude3b.d: Likewise.
	* ld-elf/exclude3c.d: Likewise.
@
text
@d3104 1
a3104 1
ppc_section_flags (flagword flags, bfd_vma attr, int type)
@


1.165
log
@	PR gas/11486
	* config/tc-ppc.c (ppc_elf_cons): Clear frag contents.
@
text
@d3092 1
a3092 20
/* For ELF, add support for SHF_EXCLUDE and SHT_ORDERED.  */

bfd_vma
ppc_section_letter (int letter, char **ptr_msg)
{
  if (letter == 'e')
    return SHF_EXCLUDE;

  *ptr_msg = _("Bad .section directive: want a,e,w,x,M,S,G,T in string");
  return -1;
}

bfd_vma
ppc_section_word (char *str, size_t len)
{
  if (len == 7 && strncmp (str, "exclude", 7) == 0)
    return SHF_EXCLUDE;

  return -1;
}
a3108 3
  if (attr & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;

@


1.164
log
@gas/
	* config/tc-ppc.c (md_show_usage): Add -mpwr4, -mpwr5, -mpwr5x,
	-mpwr6 and -mpwr7.

opcodes/
	* ppc-dis.c (ppc_opts): Add "pwr4", "pwr5", "pwr5x", "pwr6"
	and "pwr7".  Move "a2" into alphabetical order.
@
text
@d1946 1
@


1.163
log
@include/
	* opcode/ppc.h (PPC_OPCODE_TITAN): Define.
bfd/
	* archures.c (bfd_mach_ppc_titan): Define.
	* bfd-in2.h: Regenerate.
	* cpu-powerpc.c (bfd_powerpc_archs): Add titan entry.
opcodes/
	* ppc-dis.c (ppc_opts): Add titan entry.
	* ppc-opc.c (TITAN, MULHW): Define.
	(powerpc_opcodes): Support AppliedMicro Titan core (APM83xxx).
gas/
	* config/tc-ppc.c (md_show_usage): Mention -mtitan.  Don't use tabs.
	(ppc_mach): Handle titan.
	* doc/c-ppc.texi: Mention -mtitan.
gas/testsuite/
	* gas/ppc/titan.d, * gas/ppc/titan.s: New test.
	* gas/ppc/ppc.exp: Run it.
@
text
@d1202 5
a1206 4
-mpower4                generate code for Power4 architecture\n\
-mpower5                generate code for Power5 architecture\n\
-mpower6                generate code for Power6 architecture\n\
-mpower7                generate code for Power7 architecture\n\
@


1.162
log
@bfd/
	* coff-rs6000.c (xcoff_howto_table): Change size to 0 and bitsize to 1.
	(_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_NONE.
	* coff64-rs6000.c (xcoff64_howto_table): Change size to 0 and
	bitsize to 1.
	(xcoff64_reloc_type_lookup): Handle BFD_RELOC_NONE.

gas/
	* write.h (fix_at_start): Declare.
	* write.c (fix_new_internal): Add at_beginning parameter.
	Use it instead of REVERSE_SORT_RELOCS.  Fix the handling of
	seg_fix_tailP for the at_beginning/REVERSE_SORT_RELOCS case.
	(fix_new, fix_new_exp): Update accordingly.
	(fix_at_start): New function.
	* config/tc-ppc.c (md_pseudo_table): Add .ref to the OBJ_XCOFF section.
	(ppc_ref): New function, for OBJ_XCOFF.
	(md_apply_fix): Handle BFD_RELOC_NONE for OBJ_XCOFF.
	* config/te-i386aix.h (REVERSE_SORT_RELOCS): Remove #undef.

gas/testsuite/
	* gas/ppc/xcoff-ref-1.s, gas/ppc/xcoff-ref-1.l: New test.
	* gas/ppc/aix.exp: Run it.


ld/testsuite/
	* ld-powerpc/aix-ref-1-32.od, ld-powerpc/aix-ref-1-64.od,
	ld-powerpc/aix-ref-1.s: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d1181 6
a1186 6
-a32			generate ELF32/XCOFF32\n\
-a64			generate ELF64/XCOFF64\n\
-u			ignored\n\
-mpwrx, -mpwr2		generate code for POWER/2 (RIOS2)\n\
-mpwr			generate code for POWER (RIOS1)\n\
-m601			generate code for PowerPC 601\n\
d1188 6
a1193 6
			generate code for PowerPC 603/604\n\
-m403			generate code for PowerPC 403\n\
-m405			generate code for PowerPC 405\n\
-m440			generate code for PowerPC 440\n\
-m464			generate code for PowerPC 464\n\
-m476			generate code for PowerPC 476\n\
d1195 2
a1196 2
			generate code for PowerPC 7400/7410/7450/7455\n\
-m750cl			generate code for PowerPC 750cl\n"));
d1198 11
a1208 11
-mppc64, -m620		generate code for PowerPC 620/625/630\n\
-mppc64bridge		generate code for PowerPC 64, including bridge insns\n\
-mbooke			generate code for 32-bit PowerPC BookE\n\
-ma2			generate code for A2 architecture\n\
-mpower4		generate code for Power4 architecture\n\
-mpower5		generate code for Power5 architecture\n\
-mpower6		generate code for Power6 architecture\n\
-mpower7		generate code for Power7 architecture\n\
-mcell			generate code for Cell Broadband Engine architecture\n\
-mcom			generate code Power/PowerPC common instructions\n\
-many			generate code for any architecture (PWR/PWRX/PPC)\n"));
d1210 10
a1219 9
-maltivec		generate code for AltiVec\n\
-mvsx			generate code for Vector-Scalar (VSX) instructions\n\
-me300			generate code for PowerPC e300 family\n\
-me500, -me500x2	generate code for Motorola e500 core complex\n\
-me500mc,		generate code for Freescale e500mc core complex\n\
-me500mc64,		generate code for Freescale e500mc64 core complex\n\
-mspe			generate code for Motorola SPE instructions\n\
-mregnames		Allow symbolic names for registers\n\
-mno-regnames		Do not allow symbolic names for registers\n"));
d1222 3
a1224 3
-mrelocatable		support for GCC's -mrelocatble option\n\
-mrelocatable-lib	support for GCC's -mrelocatble-lib option\n\
-memb			set PPC_EMB bit in ELF flags\n\
d1226 1
a1226 1
			generate code for a little endian machine\n\
d1228 5
a1232 5
			generate code for a big endian machine\n\
-msolaris		generate code for Solaris\n\
-mno-solaris		do not generate code for Solaris\n\
-V			print assembler version number\n\
-Qy, -Qn		ignored\n"));
d1295 2
@


1.161
log
@bfd/
	* archures.c: Add bfd_mach_ppc_e500mc64.
	* bfd-in2.h: Regenerate.
	* cpu-powerpc.c (bfd_powerpc_archs): Add entry for
	bfd_mach_ppc_e500mc64.
gas/
	* config/tc-ppc.c (md_show_usage): Document -me500mc64.
opcodes/
	* ppc-dis.c (ppc_opts): Add entry for "e500mc64".
@
text
@d111 1
d216 1
d3564 52
d6089 5
@


1.160
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d1212 2
a1213 1
-me500mc,               generate code for Freescale e500mc core complex\n\
@


1.159
log
@bfd/
	* bfd-in.h (_bfd_elf_ppc_at_tls_transform): Declare.
	* bfd-in2.h: Regenerate.
	* elf64-ppc.c (ppc64_elf_relocate_section): Move code for R_PPC64_TLS
	insn optimisation to..
	* elf32-ppc.c (_bfd_elf_ppc_at_tls_transform): ..here.  New function.
	(ppc_elf_relocate_section): Use it.
gas/
	* config/tc-ppc.c (md_assemble): Report error on invalid @@tls operands
	and opcode.
@
text
@d880 1
a880 1
ppc_parse_name (const char *name, expressionS *expr)
d894 2
a895 2
  expr->X_op = O_constant;
  expr->X_add_number = val;
d1627 1
a1627 1
		    ppc_cpu_t ppc_cpu,
d1686 1
a1686 1
      insn = (*operand->insert) (insn, (long) val, ppc_cpu, &errmsg);
a2383 1
	  unsigned int i;
d3781 1
a3781 1
      expressionS ignore;
d3785 1
a3785 1
      expression (&ignore);
d3790 1
a3790 1
	  expression (&ignore);
@


1.158
log
@gas/
	* config/tc-ppc.c (md_show_usage): Document -m476.
	* doc/c-ppc.texi (PowerPC-Opts): Document -m476.

gas/testsuite/
	* gas/ppc/476.s: New test.
	* gas/ppc/476.d: Likewise.
	* gas/ppc/ppc.exp: Run the 476 test.

include/opcode/
	* ppc.h (PPC_OPCODE_476): Define.

opcodes/
	* ppc-dis.c (ppc_opts): Add "476" entry.
	* ppc-opc.c (PPC476): Define.
	(powerpc_opcodes): Update mnemonics where required for 476.
@
text
@d2735 9
a2743 2
		  insn = ppc_insert_operand (insn, operand, ppc_obj64 ? 13 : 2,
					     ppc_cpu, (char *) NULL, 0);
@


1.157
log
@gas/
	* config/tc-ppc.c (md_show_usage): Rename "ppca2" to "a2".
	* doc/c-ppc.texi (PowerPC-Opts): Likewise.

gas/testsuite/
	* gas/ppc/a2.d: Rename "ppca2" to "a2".

include/opcode/
	* ppc.h (PPC_OPCODE_A2): Rename from PPC_OPCODE_PPCA2.

opcodes/
	* ppc-opc.c (PPCA2): Use renamed mask PPC_OPCODE_A2.
	* ppc-dis.c (ppc_opts): Likewise.
	Rename "ppca2" to "a2".
@
text
@d1191 1
@


1.156
log
@gas/
	* config/tc-ppc.c (md_show_usage): Document -mpcca2.
	* doc/c-ppc.texi (PowerPC-Opts): Document -mppca2.

gas/testsuite/
	* gas/ppc/a2.s: New.
	* gas/ppc/a2.d: Likewise.
	* gas/ppc/ppc.exp: Run the a2 dump test.

include/opcode/
	* ppc.h (PPC_OPCODE_PPCA2): New.

opcodes/
	* ppc-dis.c (ppc_opts): Add "ppca2" entry.
	* ppc-opc.c (powerpc_opcodes): Add eratilx, eratsx, eratsx.,
	eratre, wchkall, eratwe, ldawx., mdfcrx., mfdcr. mtdcrx., icswx,
	icswx., mtdcr., dci, wclrone, wclrall, wclr, erativax, tlbsrx.,
	ici mnemonics.
	(ERAT_T): New operand.
	(XWC_MASK): New mask.
	(XOPL2): New macro.
	(PPCA2): Define.
@
text
@d1198 1
a1198 1
-mppca2			generate code for A2 architecture\n\
@


1.155
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d1198 1
@


1.154
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3341 1
a3341 1
      symbol_get_tc (sym)->class = XMC_PR;
d3377 1
a3377 1
      switch (symbol_get_tc (sym)->class)
d3767 2
a3768 2
  if (symbol_get_tc (ext_sym)->class == -1)
    symbol_get_tc (ext_sym)->class = XMC_PR;
d4201 1
a4201 1
	if (symbol_get_tc (label)->class != XMC_TC0)
d4221 1
a4221 1
    symbol_get_tc (sym)->class = XMC_TC;
d4325 1
a4325 1
  return symbol_get_tc (sym)->class == XMC_TC;
d4975 1
a4975 1
  tc->class = -1;
d4998 1
a4998 1
	tc->class = XMC_BS;
d5002 1
a5002 1
	tc->class = XMC_DB;
d5004 1
a5004 1
	tc->class = XMC_DS;
d5008 1
a5008 1
	tc->class = XMC_GL;
d5012 1
a5012 1
	tc->class = XMC_PR;
d5016 1
a5016 1
	tc->class = XMC_RO;
d5018 1
a5018 1
	tc->class = XMC_RW;
d5022 1
a5022 1
	tc->class = XMC_SV;
d5026 1
a5026 1
	tc->class = XMC_TC;
d5028 1
a5028 1
	tc->class = XMC_TI;
d5030 1
a5030 1
	tc->class = XMC_TB;
d5032 1
a5032 1
	tc->class = XMC_TC0;
d5036 1
a5036 1
	tc->class = XMC_UA;
d5038 1
a5038 1
	tc->class = XMC_UC;
d5042 1
a5042 1
	tc->class = XMC_XO;
d5046 1
a5046 1
  if (tc->class == -1)
d5059 2
a5060 2
      if (symbol_get_tc (sym)->class == -1)
	symbol_get_tc (sym)->class = symbol_get_tc (ppc_current_csect)->class;
d5183 1
a5183 1
      if (symbol_get_tc (sym)->class == XMC_TC0)
d5212 1
a5212 1
	    symbol_get_tc (sym)->class = XMC_RW;
d5214 1
a5214 1
	    symbol_get_tc (sym)->class = XMC_BS;
d5222 2
a5223 2
	  if (symbol_get_tc (sym)->class == -1)
	    symbol_get_tc (sym)->class = XMC_XO;
d5231 1
a5231 1
      else if (symbol_get_tc (sym)->class == XMC_TC)
d5238 1
a5238 1
	  while (symbol_get_tc (next)->class == XMC_TC0)
d5241 1
a5241 1
	      || symbol_get_tc (next)->class != XMC_TC)
d5301 1
a5301 1
      if (symbol_get_tc (sym)->class == -1)
d5304 1
a5304 1
	a->x_csect.x_smclas = symbol_get_tc (sym)->class;
d5509 1
a5509 1
	  if (sy_tc->class == XMC_TC0)
d5511 1
a5511 1
	  if (sy_tc->class != XMC_TC)
d5528 2
a5529 2
      && tc->class != XMC_TC0
      && tc->class != XMC_TC
d5794 2
a5795 2
	  && symbol_get_tc (fixP->fx_addsy)->class != XMC_TC
	  && symbol_get_tc (fixP->fx_addsy)->class != XMC_TC0
@


1.154.4.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d3341 1
a3341 1
      symbol_get_tc (sym)->symbol_class = XMC_PR;
d3377 1
a3377 1
      switch (symbol_get_tc (sym)->symbol_class)
d3767 2
a3768 2
  if (symbol_get_tc (ext_sym)->symbol_class == -1)
    symbol_get_tc (ext_sym)->symbol_class = XMC_PR;
d4201 1
a4201 1
	if (symbol_get_tc (label)->symbol_class != XMC_TC0)
d4221 1
a4221 1
    symbol_get_tc (sym)->symbol_class = XMC_TC;
d4325 1
a4325 1
  return symbol_get_tc (sym)->symbol_class == XMC_TC;
d4975 1
a4975 1
  tc->symbol_class = -1;
d4998 1
a4998 1
	tc->symbol_class = XMC_BS;
d5002 1
a5002 1
	tc->symbol_class = XMC_DB;
d5004 1
a5004 1
	tc->symbol_class = XMC_DS;
d5008 1
a5008 1
	tc->symbol_class = XMC_GL;
d5012 1
a5012 1
	tc->symbol_class = XMC_PR;
d5016 1
a5016 1
	tc->symbol_class = XMC_RO;
d5018 1
a5018 1
	tc->symbol_class = XMC_RW;
d5022 1
a5022 1
	tc->symbol_class = XMC_SV;
d5026 1
a5026 1
	tc->symbol_class = XMC_TC;
d5028 1
a5028 1
	tc->symbol_class = XMC_TI;
d5030 1
a5030 1
	tc->symbol_class = XMC_TB;
d5032 1
a5032 1
	tc->symbol_class = XMC_TC0;
d5036 1
a5036 1
	tc->symbol_class = XMC_UA;
d5038 1
a5038 1
	tc->symbol_class = XMC_UC;
d5042 1
a5042 1
	tc->symbol_class = XMC_XO;
d5046 1
a5046 1
  if (tc->symbol_class == -1)
d5059 2
a5060 2
      if (symbol_get_tc (sym)->symbol_class == -1)
	symbol_get_tc (sym)->symbol_class = symbol_get_tc (ppc_current_csect)->symbol_class;
d5183 1
a5183 1
      if (symbol_get_tc (sym)->symbol_class == XMC_TC0)
d5212 1
a5212 1
	    symbol_get_tc (sym)->symbol_class = XMC_RW;
d5214 1
a5214 1
	    symbol_get_tc (sym)->symbol_class = XMC_BS;
d5222 2
a5223 2
	  if (symbol_get_tc (sym)->symbol_class == -1)
	    symbol_get_tc (sym)->symbol_class = XMC_XO;
d5231 1
a5231 1
      else if (symbol_get_tc (sym)->symbol_class == XMC_TC)
d5238 1
a5238 1
	  while (symbol_get_tc (next)->symbol_class == XMC_TC0)
d5241 1
a5241 1
	      || symbol_get_tc (next)->symbol_class != XMC_TC)
d5301 1
a5301 1
      if (symbol_get_tc (sym)->symbol_class == -1)
d5304 1
a5304 1
	a->x_csect.x_smclas = symbol_get_tc (sym)->symbol_class;
d5509 1
a5509 1
	  if (sy_tc->symbol_class == XMC_TC0)
d5511 1
a5511 1
	  if (sy_tc->symbol_class != XMC_TC)
d5528 2
a5529 2
      && tc->symbol_class != XMC_TC0
      && tc->symbol_class != XMC_TC
d5794 2
a5795 2
	  && symbol_get_tc (fixP->fx_addsy)->symbol_class != XMC_TC
	  && symbol_get_tc (fixP->fx_addsy)->symbol_class != XMC_TC0
@


1.154.4.2
log
@gas/
	* config/tc-ppc.c (md_show_usage): Document -mpcca2.
	* doc/c-ppc.texi (PowerPC-Opts): Document -mppca2.

gas/testsuite/
	* gas/ppc/a2.s: New.
	* gas/ppc/a2.d: Likewise.
	* gas/ppc/ppc.exp: Run the a2 dump test.

include/opcode/
	* ppc.h (PPC_OPCODE_PPCA2): New.

opcodes/
	* ppc-dis.c (ppc_opts): Add "ppca2" entry.
	* ppc-opc.c (powerpc_opcodes): Add eratilx, eratsx, eratsx.,
	eratre, wchkall, eratwe, ldawx., mdfcrx., mfdcr. mtdcrx., icswx,
	icswx., mtdcr., dci, wclrone, wclrall, wclr, erativax, tlbsrx.,
	ici mnemonics.
	(ERAT_T): New operand.
	(XWC_MASK): New mask.
	(XOPL2): New macro.
	(PPCA2): Define.
@
text
@a1197 1
-mppca2			generate code for A2 architecture\n\
@


1.154.4.3
log
@gas/
	* config/tc-ppc.c (md_show_usage): Rename "ppca2" to "a2".
	* doc/c-ppc.texi (PowerPC-Opts): Likewise.

gas/testsuite/
	* gas/ppc/a2.d: Rename "ppca2" to "a2".

include/opcode/
	* ppc.h (PPC_OPCODE_A2): Rename from PPC_OPCODE_PPCA2.

opcodes/
	* ppc-opc.c (PPCA2): Use renamed mask PPC_OPCODE_A2.
	* ppc-dis.c (ppc_opts): Likewise.
	Rename "ppca2" to "a2".
@
text
@d1198 1
a1198 1
-ma2			generate code for A2 architecture\n\
@


1.154.4.4
log
@gas/
	* config/tc-ppc.c (md_show_usage): Document -m476.
	* doc/c-ppc.texi (PowerPC-Opts): Document -m476.

gas/testsuite/
	* gas/ppc/476.s: New test.
	* gas/ppc/476.d: Likewise.
	* gas/ppc/ppc.exp: Run the 476 test.

include/opcode/
	* ppc.h (PPC_OPCODE_476): Define.

opcodes/
	* ppc-dis.c (ppc_opts): Add "476" entry.
	* ppc-opc.c (PPC476): Define.
	(powerpc_opcodes): Update mnemonics where required for 476.
@
text
@a1190 1
-m476			generate code for PowerPC 476\n\
@


1.154.4.5
log
@bfd/
	* coff-rs6000.c (xcoff_howto_table): Change size to 0 and bitsize to 1.
	(_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_NONE.
	* coff64-rs6000.c (xcoff64_howto_table): Change size to 0 and
	bitsize to 1.
	(xcoff64_reloc_type_lookup): Handle BFD_RELOC_NONE.

gas/
	* write.h (fix_at_start): Declare.
	* write.c (fix_new_internal): Add at_beginning parameter.
	Use it instead of REVERSE_SORT_RELOCS.  Fix the handling of
	seg_fix_tailP for the at_beginning/REVERSE_SORT_RELOCS case.
	(fix_new, fix_new_exp): Update accordingly.
	(fix_at_start): New function.
	* config/tc-ppc.c (md_pseudo_table): Add .ref to the OBJ_XCOFF section.
	(ppc_ref): New function, for OBJ_XCOFF.
	(md_apply_fix): Handle BFD_RELOC_NONE for OBJ_XCOFF.
	* config/te-i386aix.h (REVERSE_SORT_RELOCS): Remove #undef.

gas/testsuite/
	* gas/ppc/xcoff-ref-1.s, gas/ppc/xcoff-ref-1.l: New test.
	* gas/ppc/aix.exp: Run it.


ld/testsuite/
	* ld-powerpc/aix-ref-1-32.od, ld-powerpc/aix-ref-1-64.od,
	ld-powerpc/aix-ref-1.s: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@a110 1
static void ppc_ref (int);
a214 1
  { "ref",	ppc_ref,	0 },
a3554 52
/* The .ref pseudo-op.  It takes a list of symbol names and inserts R_REF
   relocations at the beginning of the current csect.

   (In principle, there's no reason why the relocations _have_ to be at
   the beginning.  Anywhere in the csect would do.  However, inserting
   at the beginning is what the native assmebler does, and it helps to
   deal with cases where the .ref statements follow the section contents.)

   ??? .refs don't work for empty .csects.  However, the native assembler
   doesn't report an error in this case, and neither yet do we.  */

static void
ppc_ref (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c;

  if (ppc_current_csect == NULL)
    {
      as_bad (_(".ref outside .csect"));
      ignore_rest_of_line ();
      return;
    }

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();

      fix_at_start (symbol_get_frag (ppc_current_csect), 0,
		    symbol_find_or_make (name), 0, FALSE, BFD_RELOC_NONE);

      *input_line_pointer = c;
      SKIP_WHITESPACE ();
      c = *input_line_pointer;
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (is_end_of_line[(unsigned char) *input_line_pointer])
	    {
	      as_bad (_("missing symbol name"));
	      ignore_rest_of_line ();
	      return;
	    }
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

a6027 5
#ifdef OBJ_XCOFF
	case BFD_RELOC_NONE:
	  break;
#endif

@


1.154.4.6
log
@gas/
	* config/tc-ppc.c (md_show_usage): Add -mpwr4, -mpwr5, -mpwr5x,
	-mpwr6 and -mpwr7.

opcodes/
	* ppc-dis.c (ppc_opts): Add "pwr4", "pwr5", "pwr5x", "pwr6"
	and "pwr7".  Move "a2" into alphabetical order.
@
text
@d1202 4
a1205 5
-mpower4, -mpwr4	generate code for Power4 architecture\n\
-mpower5, -mpwr5, -mpwr5x\n\
			generate code for Power5 architecture\n\
-mpower6, -mpwr6	generate code for Power6 architecture\n\
-mpower7, -mpwr7	generate code for Power7 architecture\n\
@


1.153
log
@gas/
	* config/tc-ppc.c (ppc_handle_align): Handle power7's group ending nop.

gas/testsuite/
	* gas/ppc/power7.d ("ori", ".p2align"): Add tests for group ending nop.
	* gas/ppc/power7.s: Likewise.
	* gas/ppc/power6.d: Likewise.
	* gas/ppc/power6.s: Likewise.
@
text
@d2530 1
a2530 1
		  assert (ex.X_add_symbol != NULL);
d5822 1
a5822 1
      assert (fixP->fx_addsy != NULL);
@


1.152
log
@include/coff/
	* internal.h (C_AIX_WEAKEXT): New macro.
	(C_WEAKEXT): Use the GNU definition in the generic part of the file,
	and conditionally reset it to C_AIX_WEAKEXT in the XCOFF part of
	the file.
	(CSECT_SYM_P): New macro.
	* xcoff.h (L_WEAK): Define.
	(EXTERN_SYM_P): New macro.

bfd/
	* coffcode.h (coff_pointerize_aux_hook): Update CSECT_SYM_P to
	check whether a symbol has csect information.
	(coff_print_aux): Likewise.
	* coff-rs6000.c (_bfd_xcoff_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff_swap_aux_out): Likewise.
	(xcoff_reloc_type_br): Handle defweak symbols too.
	* coff64-rs6000.c (_bfd_xcoff64_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff64_swap_aux_out): Likewise.
	(xcoff64_reloc_type_br): Handle defweak symbols too.
	* coffgen.c (coff_print_symbol): Handle auxillary function
	information for C_AIX_WEAKEXT too.
	* xcofflink.c (_bfd_xcoff_canonicalize_dynamic_symtab): Set BSF_WEAK
	instead of BSF_GLOBAL if the L_WEAK flag is set.
	(xcoff_dynamic_definition_p): New function.
	(xcoff_link_add_dynamic_symbols): Use it to decide whether ldsym
	defines h.  Don't change h if ldsym isn't the definition.  Otherwise,
	always take the symbol class from the ldsym.  Use weak bfd symbol
	types for weak ldsyms.
	(xcoff_link_add_symbols): Use CSECT_SYM_P and EXTERN_SYM_P.
	Fix the check for whether a definition is from a shared object.
	Allow redefinitions of weak symbols.
	(xcoff_link_check_ar_symbols): Use EXTERN_SYM_P.
	(xcoff_keep_symbol_p): Likewise.
	(bfd_xcoff_size_dynamic_sections): Use CSECT_SYM_P.
	(xcoff_link_input_bfd): Use CSECT_SYM_P and EXTERN_SYM_P.
	Add .loader entries for C_AIX_WEAKEXT as well as C_EXT symbols,
	but mark them as L_WEAK.
	(xcoff_write_global_symbol): Treat weak symbols as C_AIX_WEAKEXT
	instead of C_EXT if C_AIX_WEAKEXT == C_WEAKEXT.

gas/
	* config/tc-ppc.c (ppc_frob_symbol): Add csect information for
	C_AIX_WEAKEXT too.

ld/testsuite/
	* ld-powerpc/aix-glink-2a.s, ld-powerpc/aix-glink-2a.ex,
	ld-powerpc/aix-glink-2b.s, ld-powerpc/aix-glink-2c.s,
	ld-powerpc/aix-glink-2c.ex, ld-powerpc/aix-glink-2d.s,
	ld-powerpc/aix-glink-2-32.dd, ld-powerpc/aix-glink-2-64.dd,
	ld-powerpc/aix-weak-1a.s, ld-powerpc/aix-weak-1b.s,
	ld-powerpc/aix-weak-1-rel.hd, ld-powerpc/aix-weak-1-rel.nd,
	ld-powerpc/aix-weak-1-dso.hd, ld-powerpc/aix-weak-1-dso.nd,
	ld-powerpc/aix-weak-1-dso.dnd, ld-powerpc/aix-weak-1.ex,
	ld-powerpc/aix-weak-2a.s, ld-powerpc/aix-weak-2a.ex,
	ld-powerpc/aix-weak-2a.nd, ld-powerpc/aix-weak-2b.s,
	ld-powerpc/aix-weak-2b.nd, ld-powerpc/aix-weak-2c.s,
	ld-powerpc/aix-weak-2c.ex, ld-powerpc/aix-weak-2c.nd,
	ld-powerpc/aix-weak-2c.od, ld-powerpc/aix-weak-3a.s,
	ld-powerpc/aix-weak-3a.ex, ld-powerpc/aix-weak-3b.s,
	ld-powerpc/aix-weak-3b.ex, ld-powerpc/aix-weak-3-32.d,
	ld-powerpc/aix-weak-3-32.dd, ld-powerpc/aix-weak-3-64.d,
	ld-powerpc/aix-weak-3-64.dd: New tests.
	* ld-powerpc/aix52.exp: Run them.  Replace tmp/aix-* with
	tmp/aix64-* in 64-bit ld options.
@
text
@d5690 2
a5691 1
      if ((ppc_cpu & PPC_OPCODE_POWER6) != 0)
d5693 5
a5697 5
	  /* For power6, we want the last nop to be a group terminating
	     one, "ori 1,1,0".  Do this by inserting an rs_fill frag
	     immediately after this one, with its address set to the last
	     nop location.  This will automatically reduce the number of
	     nops in the current frag by one.  */
d5711 6
a5716 1
	  md_number_to_chars (dest, 0x60210000, 4);
@


1.151
log
@gas/
	* config/tc-ppc.c (md_apply_fix): On COFF targets, always reread
	"value" from fx_offset.  Manually resubtract md_pcrel_from_section
	where necessary.

gas/testsuite/
	* gas/ppc/xcoff-branch-1.s, gas/ppc/xcoff-branch-1-32.d,
	gas/ppc/xcoff-branch-1-64.d: New tests.
	* gas/ppc/aix.exp: Run them.
@
text
@d5173 1
@


1.150
log
@include/opcode/
	* ppc.h (ppc_parse_cpu): Declare.
opcodes/
	* ppc-dis.c: Include "opintl.h".
	(struct ppc_mopt, ppc_opts): New.
	(ppc_parse_cpu): New function.
	(powerpc_init_dialect): Use it.
	(print_ppc_disassembler_options): Dump options from ppc_opts.
	Internationalize message.
gas/
	* config/tc-ppc.c (parse_cpu): Delete.
	(md_parse_option, ppc_machine): Use ppc_parse_cpu.
gas/testsuite/
	* gas/ppc/altivec_and_spe.d (objdump): Add -Maltivec.
	* gas/ppc/common.d: Adjust for -Mcom not including -Mppc.
@
text
@d5744 4
a5747 4
     However, if the reloc is not fully resolved we do not want to use
     *valP, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valP since it includes the
     result of md_pcrel_from.  This is confusing.  */
a5750 3
  else if (fixP->fx_pcrel)
    ;

d5752 5
a5756 1
    value = fixP->fx_offset;
@


1.149
log
@include/elf/
	* ppc.h (R_PPC_TLSGD, R_PPC_TLSLD): Add new relocs.
	* ppc64.h (R_PPC64_TLSGD, R_PPC64_TLSLD): Add new relocs.
bfd/
	* reloc.c (BFD_RELOC_PPC_TLSGD, BFD_RELOC_PPC_TLSLD): New.
	* section.c (struct bfd_section): Add has_tls_get_addr_call.
	(BFD_FAKE_SECTION): Init new flag.
	* ecoff.c (bfd_debug_section): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* elf32-ppc.c (ppc_elf_howto_raw): Add R_PPC_TLSGD and R_PPC_TLSLD.
	(ppc_elf_reloc_type_lookup): Handle new relocs.
	(ppc_elf_check_relocs): Set has_tls_get_addr_call on finding such
	without marker relocs.
	(ppc_elf_tls_optimize): Allow out-of-order __tls_get_addr relocs
	if section has no old-style calls.
	(ppc_elf_relocate_section): Set tls_mask for non-tls relocs too.
	Don't try to optimize new-style __tls_get_addr call when handling
	arg setup relocs.  Instead do so for R_PPC_TLSGD and R_PPC_TLSLD
	relocs.
	* elf64-ppc.c (ppc64_elf_howto_raw): Add R_PPC64_TLSGD, R_PPC64_TLSLD.
	(ppc64_elf_reloc_type_lookup): Handle new relocs.
	(ppc64_elf_check_relocs): Set has_tls_get_addr_call on finding such
	without marker relocs.
	(ppc64_elf_tls_optimize): Allow out-of-order __tls_get_addr relocs
	if section has no old-style calls.  Set toc_ref for new relocs as
	appropriate.
	(ppc64_elf_relocate_section): Set tls_mask for non-tls relocs too.
	Don't try to optimize new-style __tls_get_addr call when handling
	arg setup relocs.  Instead do so for R_PPC_TLSGD and R_PPC_TLSLD
	relocs.
gas/
	* config/tc-ppc.c (ppc_elf_suffix): Error if ppc32 tls got relocs
	have non-zero addend.
	(md_assemble): Parse args of __tls_get_addr calls.
	(md_apply_fix): Handle BFD_RELOC_PPC_TLSGD and BFD_RELOC_PPC_TLSLD.
ld/testsuite/
	* ld-powerpc/tlsmark.s, * ld-powerpc/tlsmark.d: New test.
	* ld-powerpc/tlsmark32.s, * ld-powerpc/tlsmark32.d: New test.
	* ld-powerpc/powerpc.exp: Run them.
@
text
@a1017 148

/* Handle -m options that set cpu type, and .machine arg.  */

static int
parse_cpu (const char *arg)
{
  ppc_cpu_t retain_flags =
    ppc_cpu & (PPC_OPCODE_ALTIVEC | PPC_OPCODE_VSX | PPC_OPCODE_SPE);

  /* -mpwrx and -mpwr2 mean to assemble for the IBM POWER/2
     (RIOS2).  */
  if (strcmp (arg, "pwrx") == 0 || strcmp (arg, "pwr2") == 0)
    ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_POWER2 | PPC_OPCODE_32;
  /* -mpwr means to assemble for the IBM POWER (RIOS1).  */
  else if (strcmp (arg, "pwr") == 0)
    ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
  /* -m601 means to assemble for the PowerPC 601, which includes
     instructions that are holdovers from the Power.  */
  else if (strcmp (arg, "601") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_601 | PPC_OPCODE_32);
  /* -mppc, -mppc32, -m603, and -m604 mean to assemble for the
     PowerPC 603/604.  */
  else if (strcmp (arg, "ppc") == 0
	   || strcmp (arg, "ppc32") == 0
	   || strcmp (arg, "603") == 0
	   || strcmp (arg, "604") == 0)
    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
  /* Do all PPC750s have paired single ops?  */
  else if (strcmp (arg, "750cl") == 0)
    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_PPCPS;
  else if (strcmp (arg, "403") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_403 | PPC_OPCODE_32);
  else if (strcmp (arg, "405") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_403 | PPC_OPCODE_405 | PPC_OPCODE_32);
  else if (strcmp (arg, "440") == 0
	   || strcmp (arg, "464") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32
	       | PPC_OPCODE_440 | PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI);
  else if (strcmp (arg, "7400") == 0
	   || strcmp (arg, "7410") == 0
	   || strcmp (arg, "7450") == 0
	   || strcmp (arg, "7455") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_ALTIVEC | PPC_OPCODE_32);
  else if (strcmp (arg, "e300") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32
	       | PPC_OPCODE_E300);
  else if (strcmp (arg, "altivec") == 0)
    {
      if (ppc_cpu == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC;

      retain_flags |= PPC_OPCODE_ALTIVEC;
    }
  else if (strcmp (arg, "vsx") == 0)
    {
      if (ppc_cpu == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC;

      retain_flags |= PPC_OPCODE_VSX;
    }
  else if (strcmp (arg, "e500") == 0 || strcmp (arg, "e500x2") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
		 | PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
		 | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
		 | PPC_OPCODE_RFMCI | PPC_OPCODE_E500MC);
    }
  else if (strcmp (arg, "e500mc") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_ISEL
		 | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
		 | PPC_OPCODE_RFMCI | PPC_OPCODE_E500MC);
    }
  else if (strcmp (arg, "spe") == 0)
    {
      if (ppc_cpu == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_EFS;

      retain_flags |= PPC_OPCODE_SPE;
    }
  /* -mppc64 and -m620 mean to assemble for the 64-bit PowerPC
     620.  */
  else if (strcmp (arg, "ppc64") == 0 || strcmp (arg, "620") == 0)
    {
      ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
    }
  else if (strcmp (arg, "ppc64bridge") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_64_BRIDGE | PPC_OPCODE_64);
    }
  /* -mbooke/-mbooke32 mean enable 32-bit BookE support.  */
  else if (strcmp (arg, "booke") == 0 || strcmp (arg, "booke32") == 0)
    {
      ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32;
    }
  else if (strcmp (arg, "power4") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_64 | PPC_OPCODE_POWER4);
    }
  else if (strcmp (arg, "power5") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_64 | PPC_OPCODE_POWER4
		 | PPC_OPCODE_POWER5);
    }
  else if (strcmp (arg, "power6") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_64 | PPC_OPCODE_POWER4
		 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
		 | PPC_OPCODE_ALTIVEC);
    }
  else if (strcmp (arg, "power7") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_ISEL | PPC_OPCODE_64
		 | PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5
		 | PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7
		 | PPC_OPCODE_ALTIVEC | PPC_OPCODE_VSX);
    }
  else if (strcmp (arg, "cell") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_64 | PPC_OPCODE_POWER4
		 | PPC_OPCODE_CELL | PPC_OPCODE_ALTIVEC);
    }
  /* -mcom means assemble for the common intersection between Power
     and PowerPC.  At present, we just allow the union, rather
     than the intersection.  */
  else if (strcmp (arg, "com") == 0)
    ppc_cpu = PPC_OPCODE_COMMON | PPC_OPCODE_32;
  /* -many means to assemble for any architecture (PWR/PWRX/PPC).  */
  else if (strcmp (arg, "any") == 0)
    ppc_cpu |= PPC_OPCODE_ANY;
  else
    return 0;

  /* Make sure the the Altivec, VSX and SPE bits are not lost.  */
  ppc_cpu |= retain_flags;
  return 1;
}

d1021 2
d1085 2
a1086 2
      if (parse_cpu (arg))
	;
d4284 1
d4307 2
a4308 2
      else if (parse_cpu (cpu_string))
	;
@


1.148
log
@	* config/tc-ppc.c (md_assemble): APUinfo only for e500.
@
text
@d1977 32
a2008 7
	if (!ppc_obj64)
	  if (exp_p->X_add_number != 0
	      && (reloc == (int) BFD_RELOC_16_GOTOFF
		  || reloc == (int) BFD_RELOC_LO16_GOTOFF
		  || reloc == (int) BFD_RELOC_HI16_GOTOFF
		  || reloc == (int) BFD_RELOC_HI16_S_GOTOFF))
	    as_warn (_("identifier+constant@@got means identifier@@got+constant"));
d2825 1
a2825 1
      else if ((reloc = ppc_elf_suffix (&str, &ex)) != BFD_RELOC_UNUSED)
d2827 1
a2827 2
	  /* Some TLS tweaks.  */
	  switch (reloc)
d2829 39
a2867 14
	    default:
	      break;
	    case BFD_RELOC_PPC_TLS:
	      insn = ppc_insert_operand (insn, operand, ppc_obj64 ? 13 : 2,
					 ppc_cpu, (char *) NULL, 0);
	      break;
	  /* We'll only use the 32 (or 64) bit form of these relocations
	     in constants.  Instructions get the 16 bit form.  */
	    case BFD_RELOC_PPC_DTPREL:
	      reloc = BFD_RELOC_PPC_DTPREL16;
	      break;
	    case BFD_RELOC_PPC_TPREL:
	      reloc = BFD_RELOC_PPC_TPREL16;
	      break;
d2870 1
a2870 3
	  /* For the absolute forms of branches, convert the PC
	     relative form back into the absolute.  */
	  if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
d2872 1
d2875 1
a2875 2
		case BFD_RELOC_PPC_B26:
		  reloc = BFD_RELOC_PPC_BA26;
d2877 4
a2880 2
		case BFD_RELOC_PPC_B16:
		  reloc = BFD_RELOC_PPC_BA16;
d2882 5
a2886 2
		case BFD_RELOC_PPC_B16_BRTAKEN:
		  reloc = BFD_RELOC_PPC_BA16_BRTAKEN;
d2888 2
a2889 4
		case BFD_RELOC_PPC_B16_BRNTAKEN:
		  reloc = BFD_RELOC_PPC_BA16_BRNTAKEN;
		  break;
		default:
a2891 1
	    }
d2893 25
a2917 4
	  if (ppc_obj64
	      && (operand->flags & (PPC_OPERAND_DS | PPC_OPERAND_DQ)) != 0)
	    {
	      switch (reloc)
d2919 56
a2974 53
		case BFD_RELOC_16:
		  reloc = BFD_RELOC_PPC64_ADDR16_DS;
		  break;
		case BFD_RELOC_LO16:
		  reloc = BFD_RELOC_PPC64_ADDR16_LO_DS;
		  break;
		case BFD_RELOC_16_GOTOFF:
		  reloc = BFD_RELOC_PPC64_GOT16_DS;
		  break;
		case BFD_RELOC_LO16_GOTOFF:
		  reloc = BFD_RELOC_PPC64_GOT16_LO_DS;
		  break;
		case BFD_RELOC_LO16_PLTOFF:
		  reloc = BFD_RELOC_PPC64_PLT16_LO_DS;
		  break;
		case BFD_RELOC_16_BASEREL:
		  reloc = BFD_RELOC_PPC64_SECTOFF_DS;
		  break;
		case BFD_RELOC_LO16_BASEREL:
		  reloc = BFD_RELOC_PPC64_SECTOFF_LO_DS;
		  break;
		case BFD_RELOC_PPC_TOC16:
		  reloc = BFD_RELOC_PPC64_TOC16_DS;
		  break;
		case BFD_RELOC_PPC64_TOC16_LO:
		  reloc = BFD_RELOC_PPC64_TOC16_LO_DS;
		  break;
		case BFD_RELOC_PPC64_PLTGOT16:
		  reloc = BFD_RELOC_PPC64_PLTGOT16_DS;
		  break;
		case BFD_RELOC_PPC64_PLTGOT16_LO:
		  reloc = BFD_RELOC_PPC64_PLTGOT16_LO_DS;
		  break;
		case BFD_RELOC_PPC_DTPREL16:
		  reloc = BFD_RELOC_PPC64_DTPREL16_DS;
		  break;
		case BFD_RELOC_PPC_DTPREL16_LO:
		  reloc = BFD_RELOC_PPC64_DTPREL16_LO_DS;
		  break;
		case BFD_RELOC_PPC_TPREL16:
		  reloc = BFD_RELOC_PPC64_TPREL16_DS;
		  break;
		case BFD_RELOC_PPC_TPREL16_LO:
		  reloc = BFD_RELOC_PPC64_TPREL16_LO_DS;
		  break;
		case BFD_RELOC_PPC_GOT_DTPREL16:
		case BFD_RELOC_PPC_GOT_DTPREL16_LO:
		case BFD_RELOC_PPC_GOT_TPREL16:
		case BFD_RELOC_PPC_GOT_TPREL16_LO:
		  break;
		default:
		  as_bad (_("unsupported relocation for DS offset field"));
		  break;
d2982 1
a2982 1
	  fixups[fc].opindex = 0;
d2986 1
a2986 2
#endif /* OBJ_ELF */

d2997 1
a3081 3
      const struct powerpc_operand *operand;

      operand = &powerpc_operands[fixups[i].opindex];
d3128 12
a3139 7
	fix_new_exp (frag_now,
		     f - frag_now->fr_literal,
		     4,
		     &fixups[i].exp,
		     (operand->flags & PPC_OPERAND_RELATIVE) != 0,
		     ((bfd_reloc_code_real_type)
		      (fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
d6233 2
@


1.147
log
@gas/
	* config/tc-ppc.c (pre_defined_registers): Add "f32" to "f63",
	"f.32" to "f.63", "vs0" to "vs63" and "vs.0" to "vs.63".
	(parse_cpu): Extend -mpower7 to accept power7 and isel instructions.

gas/testsuite/
	* gas/ppc/e500mc.d ("wait", "waitsrv", "waitimpl"): Add tests.
	* gas/ppc/e500mc.s: Likewise.
	* gas/ppc/power6.d ("cdtbcd", "cbcdtd", "addg6s"): Add tests.
	* gas/ppc/power6.s: Likewise.
	* gas/ppc/power7.d ("lfdpx", "mffgpr", "mftgpr"): Remove invalid tests.
	("wait", "waitsrv", "waitimpl", "divwe", "divwe.", "divweo", "divweo.",
	"divweu", "divweu.", "divweuo", "divweuo.", "bpermd", "popcntw",
	"popcntd", "ldbrx", "stdbrx", "lfiwzx", "lfiwzx", "fcfids", "fcfids.",
	"fcfidus", "fcfidus.", "fctiwu", "fctiwu.", "fctiwuz", "fctiwuz.",
	"fctidu", "fctidu.", "fctiduz", "fctiduz.", "fcfidu", "fcfidu.",
	"ftdiv", "ftdiv", "ftsqrt", "ftsqrt", "dcbtt", "dcbtstt", "dcffix",
	"dcffix.", "lbarx", "lbarx", "lbarx", "lharx", "lharx", "lharx",
	"stbcx.", "sthcx.", "fre", "fre.", "fres", "fres.", "frsqrte",
	"frsqrte.", "frsqrtes", "frsqrtes.", "isel"): Add tests.
	* gas/ppc/power7.s: Likewise.
	* gas/ppc/vsx.d: New test.
	* gas/ppc/vsx.s: Likewise.
	* gas/ppc/ppc.exp: Run it.

include/opcode/
	* ppc.h (PPC_OPCODE_POWER7): New.

opcodes/
	* ppc-dis.c (powerpc_init_dialect): Extend -Mpower7 to disassemble
	the power7 and the isel instructions.
	* ppc-opc.c (insert_xc6, extract_xc6): New static functions.
	(insert_dm, extract_dm): Likewise.
	(XB6): Update comment to include XX2 form.
	(WC, XC6, SHW, DMEX, UIM, XX2, XX3RC, XX4, XX2_MASK, XX2UIM_MASK,
	XX2BF_MASK, XX3BF_MASK, XX3SHW_MASK, XX4_MASK, XWC_MASK, POWER7): New.
	(RemoveXX3DM): Delete.
	(powerpc_opcodes): <"lfdp", "lfdpx", "mcrxr", "mftb", "mffgpr",
	"mftgpr">: Deprecate for POWER7.
	<"fres", "fres.", "frsqrtes", "frsqrtes.", "fre", "fre.", "frsqrte",
	"frsqrte.">: Deprecate the three operand form and enable the two
	operand form for POWER7 and later.
	<"wait">: Extend to accept optional parameter.  Enable for POWER7.
	<"waitsrv", "waitimpl">: Add extended opcodes.
	<"ldbrx", "stdbrx">: Enable for POWER7.
	<"cdtbcd", "cbcdtd", "addg6s">: Add POWER6 opcodes.
	<"bpermd", "dcbtstt", "dcbtt", "dcffix.", "dcffix", "divde.", "divde",
	"divdeo.", "divdeo", "divdeu.", "divdeu", "divdeuo.", "divdeuo",
	"divwe.", "divwe", "divweo.", "divweo", "divweu.", "divweu", "divweuo.",
	"divweuo", "fcfids.", "fcfids", "fcfidu.", "fcfidu", "fcfidus.",
	"fcfidus", "fctidu.", "fctidu", "fctiduz.", "fctiduz", "fctiwu.",
	"fctiwu", "fctiwuz.", "fctiwuz", "ftdiv", "ftsqrt", "lbarx", "lfiwzx",
	"lharx", "popcntd", "popcntw", "stbcx.", "sthcx.">: Add POWER7 opcodes.
	<"lxsdux", "lxsdx", "lxvdsx", "lxvw4ux", "lxvw4x", "stxsdux", "stxsdx",
	"stxvw4ux", "stxvw4x", "xsabsdp", "xsadddp", "xscmpodp", "xscmpudp",
	"xscpsgndp", "xscvdpsp", "xscvdpsxds", "xscvdpsxws", "xscvdpuxds",
	"xscvdpuxws", "xscvspdp", "xscvsxddp", "xscvuxddp", "xsdivdp",
	"xsmaddadp", "xsmaddmdp", "xsmaxdp", "xsmindp", "xsmsubadp",
	"xsmsubmdp", "xsmuldp", "xsnabsdp", "xsnegdp", "xsnmaddadp",
	"xsnmaddmdp", "xsnmsubadp", "xsnmsubmdp", "xsrdpi", "xsrdpic",
	"xsrdpim", "xsrdpip", "xsrdpiz", "xsredp", "xsrsqrtedp", "xssqrtdp",
	"xssubdp", "xstdivdp", "xstsqrtdp", "xvabsdp", "xvabssp", "xvadddp",
	"xvaddsp", "xvcmpeqdp.", "xvcmpeqdp", "xvcmpeqsp.", "xvcmpeqsp",
	"xvcmpgedp.", "xvcmpgedp", "xvcmpgesp.", "xvcmpgesp", "xvcmpgtdp.",
	"xvcmpgtdp", "xvcmpgtsp.", "xvcmpgtsp", "xvcpsgnsp", "xvcvdpsp",
	"xvcvdpsxds", "xvcvdpsxws", "xvcvdpuxds", "xvcvdpuxws", "xvcvspdp",
	"xvcvspsxds", "xvcvspsxws", "xvcvspuxds", "xvcvspuxws", "xvcvsxddp",
	"xvcvsxdsp", "xvcvsxwdp", "xvcvsxwsp", "xvcvuxddp", "xvcvuxdsp",
	"xvcvuxwdp", "xvcvuxwsp", "xvdivdp", "xvdivsp", "xvmaddadp",
	"xvmaddasp", "xvmaddmdp", "xvmaddmsp", "xvmaxdp", "xvmaxsp",
	"xvmindp", "xvminsp", "xvmovsp", "xvmsubadp", "xvmsubasp", "xvmsubmdp",
	"xvmsubmsp", "xvmuldp", "xvmulsp", "xvnabsdp", "xvnabssp", "xvnegdp",
	"xvnegsp", "xvnmaddadp", "xvnmaddasp", "xvnmaddmdp", "xvnmaddmsp",
	"xvnmsubadp", "xvnmsubasp", "xvnmsubmdp", "xvnmsubmsp", "xvrdpi",
	"xvrdpic", "xvrdpim", "xvrdpip", "xvrdpiz", "xvredp", "xvresp",
	"xvrspi", "xvrspic", "xvrspim", "xvrspip", "xvrspiz", "xvrsqrtedp",
	"xvrsqrtesp", "xvsqrtdp", "xvsqrtsp", "xvsubdp", "xvsubsp", "xvtdivdp",
	"xvtdivsp", "xvtsqrtdp", "xvtsqrtsp", "xxland", "xxlandc", "xxlnor",
	"xxlor", "xxlxor", "xxmrghw", "xxmrglw", "xxsel", "xxsldwi", "xxspltd",
	"xxspltw", "xxswapd">: Add VSX opcodes.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d2968 1
a2968 4
  if (ppc_cpu & (PPC_OPCODE_SPE
   	       | PPC_OPCODE_ISEL | PPC_OPCODE_EFS
	       | PPC_OPCODE_BRLOCK | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
	       | PPC_OPCODE_RFMCI))
@


1.146
log
@	* config/tc-ppc.c (ppc_insert_operand, md_assemble): Use '%s' for
	as_bad calls to silence compiler warning.
@
text
@d361 9
d371 10
d382 10
d393 4
d427 9
d437 10
d448 10
d459 4
d570 1
a570 1
  { "v.0", 0 },     /* Vector registers */
d636 130
d1139 3
a1141 2
		 | PPC_OPCODE_64 | PPC_OPCODE_POWER4
		 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
@


1.145
log
@        * include/elf/ia64.h (SHT_IA_64_VMS_DISPLAY_NAME_INFO,
        EF_IA_64_ARCHVER_1): New macros. Minor reformatting.

        * bfd/Makefile.am (BFD32_BACKENDS): Add new object vmsutil.lo
        (BFD32_BACKENDS_CFILES): Add new file vmsutil.c
        (vmsutil.lo): Add dependency rule
        * bfd/Makefile.in: Regenerate
        * bfd/config.bfd (ia64*-*-*vms*): Add case.
        * bfd/configure.in (bfd_elf64_ia64_vms_vec): Add case.
        * bfd/configure: Regenerate
        * bfd/vmsutil.[ch]: New files
        * bfd/elf-bfd.h (struct bfd_elf_special_section): Change type of
        attr to bfd_vma.
        * bfd/elfxx-ia64.c (elfNN_vms_post_process_headers,
        elfNN_vms_section_processing, elfNN_vms_final_write_processing,
        elfNN_vms_close_and_cleanup, elfNN_vms_section_from_shdr,
        elfNN_vms_object_p): New functions
        * bfd/targets.c (bfd_elf64_ia64_vms_vec): New target.

        * gas/configure.tgt(ia64-*-*vms*): New target.
        * gas/dwarf2dbg.h (dwarf2_loc_mark_labels): Make extern.
        * gas/tc.h (md_number_to_chars): Declare iff undefined.
        * gas/config/obj-elf.c (obj_elf_change_section): Change type of
        arg attr to bfd_vma.
        (obj_elf_parse_section_letters): Return a bfd_vma. Change type of
        variables attr, md_attr to bfd_vma.
        (obj_elf_section_word): Likewise.
        (obj_elf_section): Change type of variable attr to bfd_vma
        * gas/config/obj-elf.h (obj_elf_change_section): Change type of
        arg attr to bfd_vma
        * gas/config/tc-ia64.c (bfdver.h,time.h): Include.
        (ia64_elf_section_letter): Now returns a bfd_vma.
        Handle VMS specific attributes.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (ia64_init): Don't turn on dependency checking for VMS.
        (ia64_target_format): Check for VMS flag bit.
        (do_alias): Hande decc$ functions.
        (get_vms_time): New function.
        (ia64_vms_note): New function.
        * gas/config/tc-ia64.h (ia64_elf_section_letter): Now returns a bfd_vma.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (tc_init_after_args): Define for VMS.
        * gas/config/tc-alpha.c (alpha_elf_section_letter): Return a bfd_vma.
        (alpha_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-alpha.h: Likewise.
        * gas/config/tc-i386.c (x86_64_section_letter): Return a bfd_vma.
        (x86_64_section_word): Return a bfd_vma.
        * gas/config/tc-i386.h: Likewise.
        * gas/config/tc-ip2k.c (ip2k_elf_section_flags): Change type of arg
        attr to bfd_vma.
        * gas/config/tc-ip2k.h: Likewise.
        * gas/config/tc-mep.c (mep_elf_section_letter): Return a bfd_vma.
        (mep_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-mep.h: Likewise.
        * gas/config/tc-ppc.c  (ppc_section_letter): Return a bfd_vma.
        (ppc_section_word): Return a bfd_vma.
        (ppc_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-ppc.h: Likewise.
        * gas/config/te-vms.h (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,
        DWAR2_FILE_TIME_NAME, DWARF2_FILE_SIZE_NAME, DWARF2_FILEN_NAME):
        New file with new macros
        * gas/dwarf2dbg.c (get_filenum, out_file_list): Default and call new
        macros.
@
text
@d1635 1
a1635 1
	as_bad_where (file, line, errmsg);
d2366 1
a2366 1
	    as_bad (errmsg);
d2379 1
a2379 1
		as_bad (errmsg);
@


1.144
log
@gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Remove PPC_OPCODE_NOPOWER4 test.
	Test the new "deprecated" opcode field.

include/opcode/
	* ppc.h (struct powerpc_opcode): New field "deprecated".
	(PPC_OPCODE_NOPOWER4): Delete.

opcodes/
	* ppc-opc.c (PPCNONE): Define.
	(NOPOWER4): Delete.
	(powerpc_opcodes): Initialize the new "deprecated" field.
@
text
@d2955 1
a2955 1
int
d2965 1
a2965 1
int
d2984 1
a2984 1
ppc_section_flags (int flags, int attr, int type)
@


1.143
log
@opcodes/
	* ppc-dis.c (powerpc_init_dialect): Do not set PPC_OPCODE_BOOKE
	for -Mbooke.
	(print_ppc_disassembler_options): Update usage.
	* ppc-opc.c (DE, DES, DEO, DE_MASK): Remove.
	(BOOKE64): Remove.
	(PPCCHLK64): Likewise.
	(powerpc_opcodes): Remove all BOOKE64 instructions.

gas/
	* config/tc-ppc.c (parse_cpu): Remove booke64 support. Update
	usage strings.
	(ppc_setup_opcodes): Likewise, remove booke64 support.
	* doc/c-ppc.texi (PowerPC-Opts): Remove -mbooke32 and -mbooke64.
	* doc/as.texinfo (Overview): Likewise.

binutils/
	* doc/binutils.texi (objdump): Update booke documentation.
	* NEWS: Document user-visible changes to command line options.
@
text
@d1415 1
a1415 2
	  && ((ppc_cpu & PPC_OPCODE_POWER4) == 0
	      || (op->flags & PPC_OPCODE_NOPOWER4) == 0))
@


1.142
log
@gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Simplify POWER4/NOPOWER4 test.
	Remove POWER5 and POWER6 tests.

gas/testsuite/
	* gas/ppc/common.s: New test.
	* gas/ppc/common.d: Likewise.
	* gas/ppc/power4_32.s: Likewise.
	* gas/ppc/power4_32.d: Likewise.
	* gas/ppc/power6.s: Add attn, mtcr, mtcrf, mfcr, dcbz.
	* gas/ppc/power6.d: Likewise.
	* gas/ppc/ppc.exp: Run power4_32 test.
@
text
@a921 6
  /* -mbooke64 means enable 64-bit BookE support.  */
  else if (strcmp (arg, "booke64") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE
		 | PPC_OPCODE_BOOKE64 | PPC_OPCODE_64);
    }
d1146 1
a1146 2
-mbooke64		generate code for 64-bit PowerPC BookE\n\
-mbooke, mbooke32	generate code for 32-bit PowerPC BookE\n\
d1355 1
a1355 2
		 processor variants.  eg. "lhae" booke64 insn must be
		 found before "ld" ppc64 insn.  */
a1414 8
	  /* Certain instructions (eg: extsw) do not exist in the
	     32-bit BookE instruction set, but they do exist in the
	     64-bit BookE instruction set, and other PPC instruction
	     sets.  Check to see if the opcode has the BOOKE64 flag set.
	     If it does make sure that the target CPU is not the BookE32.  */
	  && ((op->flags & PPC_OPCODE_BOOKE64) == 0
	      || (ppc_cpu & PPC_OPCODE_BOOKE64) == PPC_OPCODE_BOOKE64
	      || (ppc_cpu & PPC_OPCODE_BOOKE) == 0)
@


1.141
log
@gas/
	* config/tc-ppc.c (parse_cpu): Rename altivec_or_spe to retain_flags.
	Handle -mvsx and -mpower7.
	(md_show_usage): Document -mpower7 and -mvsx.
	* doc/as.texinfo (Target PowerPC): Document -mvsx.
	* doc/c-ppc.texi (PowerPC-Opts): Document -mvsx and -mpower7.

gas/testsuite/
	* gas/ppc/power7.d: New.
	* gas/ppc/power7.s: Likewise.
	* gas/ppc/ppc.exp: Run power7 test.

include/opcode/
	* ppc.h (PPC_OPCODE_VSX, PPC_OPERAND_VSR): New.

opcodes/
	* ppc-dis.c (powerpc_init_dialect): Handle power7 and vsx options.
	(print_insn_powerpc): Prepend 'vs' when printing VSX registers.
	(print_ppc_disassembler_options): Document -Mpower7 and -Mvsx.
	* ppc-opc.c (insert_xt6): New static function.
	(extract_xt6): Likewise.
	(insert_xa6): Likewise.
	(extract_xa6: Likewise.
	(insert_xb6): Likewise.
	(extract_xb6): Likewise.
	(insert_xb6s): Likewise.
	(extract_xb6s): Likewise.
	(XS6, XT6, XA6, XB6, XB6S, DM, XX3, XX3DM, XX1_MASK, XX3_MASK,
	XX3DM_MASK, PPCVSX): New.
	(powerpc_opcodes): Add opcodes "lxvd2x", "lxvd2ux", "stxvd2x",
	"stxvd2ux", "xxmrghd", "xxmrgld", "xxpermdi", "xvmovdp", "xvcpsgndp".
@
text
@d1431 2
a1432 9
	  && ((op->flags & (PPC_OPCODE_POWER4 | PPC_OPCODE_NOPOWER4)) == 0
	      || ((op->flags & PPC_OPCODE_POWER4)
		  == (ppc_cpu & PPC_OPCODE_POWER4)))
	  && ((op->flags & PPC_OPCODE_POWER5) == 0
	      || ((op->flags & PPC_OPCODE_POWER5)
		  == (ppc_cpu & PPC_OPCODE_POWER5)))
	  && ((op->flags & PPC_OPCODE_POWER6) == 0
	      || ((op->flags & PPC_OPCODE_POWER6)
		  == (ppc_cpu & PPC_OPCODE_POWER6))))
@


1.141.2.1
log
@backport 2008-09-09  Peter Bergner  <bergner@@vnet.ibm.com>
@
text
@d1431 9
a1439 2
	  && ((ppc_cpu & PPC_OPCODE_POWER4) == 0
	      || (op->flags & PPC_OPCODE_NOPOWER4) == 0))
@


1.141.2.2
log
@backport 2008-12-04  Ben Elliston  <bje@@au.ibm.com>
@
text
@d922 6
d1152 2
a1153 1
-mbooke			generate code for 32-bit PowerPC BookE\n\
d1362 2
a1363 1
		 processor variants.  */
d1423 8
@


1.141.2.3
log
@backport 2009-01-09  Peter Bergner  <bergner@@vnet.ibm.com>
@
text
@d1415 2
a1416 1
	  && !(ppc_cpu & op->deprecated))
@


1.141.2.4
log
@backport 2009-02-26  Peter Bergner  <bergner@@vnet.ibm.com>
@
text
@a360 9

  { "f.32", 32 },    /* Extended floating point scalar registers (ISA 2.06).  */
  { "f.33", 33 },
  { "f.34", 34 },
  { "f.35", 35 },
  { "f.36", 36 },
  { "f.37", 37 },
  { "f.38", 38 },
  { "f.39", 39 },
a361 10
  { "f.40", 40 },
  { "f.41", 41 },
  { "f.42", 42 },
  { "f.43", 43 },
  { "f.44", 44 },
  { "f.45", 45 },
  { "f.46", 46 },
  { "f.47", 47 },
  { "f.48", 48 },
  { "f.49", 49 },
a362 10
  { "f.50", 50 },
  { "f.51", 51 },
  { "f.52", 52 },
  { "f.53", 53 },
  { "f.54", 54 },
  { "f.55", 55 },
  { "f.56", 56 },
  { "f.57", 57 },
  { "f.58", 58 },
  { "f.59", 59 },
a363 4
  { "f.60", 60 },
  { "f.61", 61 },
  { "f.62", 62 },
  { "f.63", 63 },
a393 9

  { "f32", 32 },    /* Extended floating point scalar registers (ISA 2.06).  */
  { "f33", 33 },
  { "f34", 34 },
  { "f35", 35 },
  { "f36", 36 },
  { "f37", 37 },
  { "f38", 38 },
  { "f39", 39 },
a394 10
  { "f40", 40 },
  { "f41", 41 },
  { "f42", 42 },
  { "f43", 43 },
  { "f44", 44 },
  { "f45", 45 },
  { "f46", 46 },
  { "f47", 47 },
  { "f48", 48 },
  { "f49", 49 },
a395 10
  { "f50", 50 },
  { "f51", 51 },
  { "f52", 52 },
  { "f53", 53 },
  { "f54", 54 },
  { "f55", 55 },
  { "f56", 56 },
  { "f57", 57 },
  { "f58", 58 },
  { "f59", 59 },
a396 4
  { "f60", 60 },
  { "f61", 61 },
  { "f62", 62 },
  { "f63", 63 },
d504 1
a504 1
  { "v.0", 0 },     /* Vector (Altivec/VMX) registers */
a569 130
  { "vs.0", 0 },     /* Vector Scalar (VSX) registers (ISA 2.06).  */
  { "vs.1", 1 },
  { "vs.10", 10 },
  { "vs.11", 11 },
  { "vs.12", 12 },
  { "vs.13", 13 },
  { "vs.14", 14 },
  { "vs.15", 15 },
  { "vs.16", 16 },
  { "vs.17", 17 },
  { "vs.18", 18 },
  { "vs.19", 19 },
  { "vs.2", 2 },
  { "vs.20", 20 },
  { "vs.21", 21 },
  { "vs.22", 22 },
  { "vs.23", 23 },
  { "vs.24", 24 },
  { "vs.25", 25 },
  { "vs.26", 26 },
  { "vs.27", 27 },
  { "vs.28", 28 },
  { "vs.29", 29 },
  { "vs.3", 3 },
  { "vs.30", 30 },
  { "vs.31", 31 },
  { "vs.32", 32 },
  { "vs.33", 33 },
  { "vs.34", 34 },
  { "vs.35", 35 },
  { "vs.36", 36 },
  { "vs.37", 37 },
  { "vs.38", 38 },
  { "vs.39", 39 },
  { "vs.4", 4 },
  { "vs.40", 40 },
  { "vs.41", 41 },
  { "vs.42", 42 },
  { "vs.43", 43 },
  { "vs.44", 44 },
  { "vs.45", 45 },
  { "vs.46", 46 },
  { "vs.47", 47 },
  { "vs.48", 48 },
  { "vs.49", 49 },
  { "vs.5", 5 },
  { "vs.50", 50 },
  { "vs.51", 51 },
  { "vs.52", 52 },
  { "vs.53", 53 },
  { "vs.54", 54 },
  { "vs.55", 55 },
  { "vs.56", 56 },
  { "vs.57", 57 },
  { "vs.58", 58 },
  { "vs.59", 59 },
  { "vs.6", 6 },
  { "vs.60", 60 },
  { "vs.61", 61 },
  { "vs.62", 62 },
  { "vs.63", 63 },
  { "vs.7", 7 },
  { "vs.8", 8 },
  { "vs.9", 9 },

  { "vs0", 0 },
  { "vs1", 1 },
  { "vs10", 10 },
  { "vs11", 11 },
  { "vs12", 12 },
  { "vs13", 13 },
  { "vs14", 14 },
  { "vs15", 15 },
  { "vs16", 16 },
  { "vs17", 17 },
  { "vs18", 18 },
  { "vs19", 19 },
  { "vs2", 2 },
  { "vs20", 20 },
  { "vs21", 21 },
  { "vs22", 22 },
  { "vs23", 23 },
  { "vs24", 24 },
  { "vs25", 25 },
  { "vs26", 26 },
  { "vs27", 27 },
  { "vs28", 28 },
  { "vs29", 29 },
  { "vs3", 3 },
  { "vs30", 30 },
  { "vs31", 31 },
  { "vs32", 32 },
  { "vs33", 33 },
  { "vs34", 34 },
  { "vs35", 35 },
  { "vs36", 36 },
  { "vs37", 37 },
  { "vs38", 38 },
  { "vs39", 39 },
  { "vs4", 4 },
  { "vs40", 40 },
  { "vs41", 41 },
  { "vs42", 42 },
  { "vs43", 43 },
  { "vs44", 44 },
  { "vs45", 45 },
  { "vs46", 46 },
  { "vs47", 47 },
  { "vs48", 48 },
  { "vs49", 49 },
  { "vs5", 5 },
  { "vs50", 50 },
  { "vs51", 51 },
  { "vs52", 52 },
  { "vs53", 53 },
  { "vs54", 54 },
  { "vs55", 55 },
  { "vs56", 56 },
  { "vs57", 57 },
  { "vs58", 58 },
  { "vs59", 59 },
  { "vs6", 6 },
  { "vs60", 60 },
  { "vs61", 61 },
  { "vs62", 62 },
  { "vs63", 63 },
  { "vs7", 7 },
  { "vs8", 8 },
  { "vs9", 9 },

d943 2
a944 3
		 | PPC_OPCODE_ISEL | PPC_OPCODE_64
		 | PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5
		 | PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7
@


1.141.2.5
log
@       * config/tc-ppc.c (md_assemble): APUinfo only for e500.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d2968 4
a2971 1
  if ((ppc_cpu & PPC_OPCODE_E500MC) != 0)
@


1.140
log
@gas/
	* config/tc-ppc.c (parse_cpu) <power6>: Accept Altivec instructions.
	<cell>: Likewise.

gas/testsuite/
	* gas/ppc/cell.s: Add altivec instructions.
	* gas/ppc/cell.d: Update expected output.
	* gas/ppc/power6.d: New.
	* gas/ppc/power6.s: Likewise.
	* gas/ppc/ppc.exp (powerpc64*-*-*): Move cell from here to...
	(powerpc*-*-*): Here.  Run power6 test.
@
text
@d828 2
a829 1
  ppc_cpu_t altivec_or_spe = ppc_cpu & (PPC_OPCODE_ALTIVEC | PPC_OPCODE_SPE);
d877 8
a884 1
      altivec_or_spe |= PPC_OPCODE_ALTIVEC;
d904 1
a904 1
      altivec_or_spe |= PPC_OPCODE_SPE;
d946 7
d970 2
a971 2
  /* Make sure the the Altivec and SPE bits are not lost.  */
  ppc_cpu |= altivec_or_spe;
d1157 1
d1163 1
@


1.139
log
@include/opcode/
	* ppc.h (PPC_OPCODE_405): Define.
	(PPC_OPERAND_FSL, PPC_OPERAND_FCR, PPC_OPERAND_UDI): Define.
gas/
	* config/tc-ppc.c (parse_cpu): Separate handling of -m403/405.
	(md_show_usage): Likewise.
opcodes/
	* ppc-dis.c (print_insn_powerpc): Disassemble FSL/FCR/UDI fields.
	* ppc-opc.c (powerpc_operands): Add Xilinx APU related operands.
	(insert_sprg, PPC405): Use PPC_OPCODE_405.
	(powerpc_opcodes): Add Xilinx APU related opcodes.
@
text
@d935 2
a936 1
		 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6);
d942 1
a942 1
		 | PPC_OPCODE_CELL);
@


1.138
log
@gas/
	* config/tc-ppc.c (parse_cpu): Handle -m464.
	(md_show_usage): Likewise.

opcodes/
	* ppc-dis.c (powerpc_init_dialect): Handle -M464.
	(print_ppc_disassembler_options): Likewise.
	* ppc-opc.c (PPC464): Define.
	(powerpc_opcodes): Add mfdcrux and mtdcrux.
@
text
@d852 1
a852 3
  /* -m403 and -m405 mean to assemble for the PowerPC 403/405.  */
  else if (strcmp (arg, "403") == 0
	   || strcmp (arg, "405") == 0)
d855 3
d1126 2
a1127 1
-m403, -m405		generate code for PowerPC 403/405\n\
@


1.137
log
@include/opcode/
	* ppc.h (ppc_cpu_t): New typedef.
	(struct powerpc_opcode <flags>): Use it.
	(struct powerpc_operand <insert, extract>): Likewise.
	(struct powerpc_macro <flags>): Likewise.

gas/
	* config/tc-ppc.c (ppc_cpu): Use ppc_cpu_t typedef.
	(ppc_insert_operand): Likewise.
	(ppc_machine): Likewise.
	* config/tc-ppc.h: #include "opcode/ppc.h"
	(struct _ppc_fix_extra <ppc_cpu>): Use ppc_cpu_t typedef.
	(ppc_cpu): Update extern decl.

opcodes/
	* ppc-dis.c (print_insn_powerpc): Update prototye to use new
	ppc_cpu_t typedef.
	(struct dis_private): New.
	(POWERPC_DIALECT): New define.
	(powerpc_dialect): Renamed to...
	(powerpc_init_dialect): This.  Update to use ppc_cpu_t and
	struct dis_private.
	(print_insn_big_powerpc): Update for using structure in
	info->private_data.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Change type of dialect param to ppc_cpu_t.
	(skip_optional_operands): Likewise.
	(print_insn_powerpc): Likewise.  Remove initialization of dialect.
	* ppc-opc.c (extract_bat, extract_bba, extract_bdm, extract_bdp,
	extract_bo, extract_boe, extract_fxm, extract_mb6, extract_mbe,
	extract_nb, extract_nsi, extract_rbs, extract_sh6, extract_spr,
	extract_sprg, extract_tbr insert_bat, insert_bba, insert_bdm,
	insert_bdp, insert_bo, insert_boe, insert_fxm, insert_mb6, insert_mbe,
	insert_nsi, insert_ral, insert_ram, insert_raq, insert_ras, insert_rbs,
	insert_sh6, insert_spr, insert_sprg, insert_tbr): Change the dialect
	param to be of type ppc_cpu_t.  Update prototype.
@
text
@d857 2
a858 1
  else if (strcmp (arg, "440") == 0)
d1127 1
@


1.136
log
@ppc e500mc support
@
text
@d184 1
a184 1
unsigned long ppc_cpu = 0;
d828 1
a828 1
  unsigned long altivec_or_spe = ppc_cpu & (PPC_OPCODE_ALTIVEC | PPC_OPCODE_SPE);
d1576 1
a1576 1
		    unsigned long ppc_cpu,
d4141 1
a4141 1
  static unsigned long *cpu_history;
d4162 1
a4162 1
      unsigned long old_cpu = ppc_cpu;
@


1.135
log
@	* config/tc-ppc.c (ppc_setup_opcodes): Tidy.  Add code to test
	for strict ordering of powerpc_opcodes, but disable for now.
@
text
@d881 7
a887 1
		 | PPC_OPCODE_RFMCI);
d1144 1
@


1.134
log
@	* config/tc-ppc.h (struct _ppc_fix_extra): New.
	(ppc_cpu): Declare.
	(TC_FIX_TYPE, TC_INIT_FIX_DATA): Define.
	* config/tc-ppc.c (ppu_cpu): Make global.
	(ppc_insert_operand): Add ppu_cpu parameter.
	(md_assemble): Adjust for above change.
	(md_apply_fix): Pass tc_fix_data.ppc_cpu to ppc_insert_operand.
@
text
@a1257 1
  unsigned long prev_opcode = 0;
a1304 1
	  unsigned long major_opcode = PPC_OP (op->opcode);
d1306 1
a1306 3
	  /* The major opcodes had better be sorted.  Code in the disassembler
	     assumes the insns are sorted according to major opcode.  */
	  if (major_opcode < prev_opcode)
d1308 46
a1353 3
	      as_bad (_("major opcode is not sorted for %s"),
		      op->name);
	      bad_insn = TRUE;
a1354 1
	  prev_opcode = major_opcode;
@


1.133
log
@* config/tc-ppc.c (parse_cpu): Preserve the settings of the
  PPC_OPCODE_ALTIVEC and PPC_OPCODE_SPE flags.

* gas/ppc/altivec_and_spe.s: New test - checks that ISA extension
  command line options (-maltivec, -mspe) can be specified before
  CPU selection command line options.
* gas/ppc/altivec_and_spe.d: Expected disassembly.
* gas/ppc/ppc.exp: Run the new test
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d181 4
a705 4
/* The type of processor we are assembling for.  This is one or more
   of the PPC_OPCODE flags defined in opcode/ppc.h.  */
static unsigned long ppc_cpu = 0;

d1531 1
d2488 1
a2488 1
				     (char *) NULL, 0);
d2557 1
a2557 1
				     (char *) NULL, 0);
d2569 1
a2569 1
					 (char *) NULL, 0);
d5636 1
@


1.132
log
@	* config/tc-ppc.c (ppc_tc): Allow a space between toc symbol
	name and bracket.
@
text
@d828 2
d872 3
a874 3
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_ALTIVEC;
      else
	ppc_cpu |= PPC_OPCODE_ALTIVEC;
d886 3
a888 3
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_SPE | PPC_OPCODE_EFS;
      else
	ppc_cpu |= PPC_OPCODE_SPE;
d946 2
@


1.131
log
@	* config/tc-ppc.c (md_assemble): If -mregnames, when parsing
	PPC_OPERAND_CR always parse as expression to allow register name
	followed by an expression.
@
text
@d4062 1
@


1.130
log
@* config/tc-ppc.c (md_apply_fix): For PPC_TOC16 on XCOFF, uses offset
  within the TOC instead of the VMA.

* gas/ppc/test1xcoff32.d: Updated to match RTOC bug fix.
@
text
@d2457 2
a2458 1
	  if (! register_name (&ex))
@


1.129
log
@	* config/tc-ppc.c (ppc_parse_name): Skip leading '%'.
	(md_assemble): When parsing PPC_OPERAND_CR, add '%' to set of
	chars that can start a name.
@
text
@d6062 2
a6063 2
      /* We want to use the offset within the data segment of the
	 symbol, not the actual VMA of the symbol.  */
d6065 2
a6066 1
	- bfd_get_section_vma (stdoutput, S_GET_SEGMENT (fixP->fx_addsy));
@


1.128
log
@Remove duplicate definitions of the md_atof() function
@
text
@d687 2
d2459 2
d2462 4
a2465 1
		cr_operand = TRUE;
d2468 1
@


1.127
log
@gas/

	* config/tc-ppc.c (ppc_setup_opcodes): Verify instructions are sorted
	according to major opcode number.

opcodes/

	* ppc-opc.c (TE): Correct signedness.
	(powerpc_opcodes): Sort psq_st and psq_stu according to major
	opcode number.
@
text
@a5222 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d5226 1
a5226 44
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litp, (valueT) words[i], 2);
	  litp += 2;
	}
    }
  else
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litp, (valueT) words[i], 2);
	  litp += 2;
	}
    }

  return NULL;
@


1.126
log
@binutils/
	* doc/binutils.texi (objdump): Document -Mppcps.

gas/
	* config/tc-ppc.c (parse_cpu): Handle "750cl".
	(pre_defined_registers): Add "gqr0" to "gqr7", "gqr.0" to "gqr.7".
	(md_show_usage): Document -m750cl.
	(md_assemble): Handle two delimiters in succession (eg. `),').
	* doc/c-ppc.texi (PowerPC-Opts): Document -m750cl.
	* testsuite/gas/ppc/ppc.exp: Run ppc70ps dump tests.
	* testsuite/gas/ppc/ppc750ps.s: New file.
	* testsuite/gas/ppc/ppc750ps.d: Likewise.

include/opcode/
	* ppc.h (PPC_OPCODE_PPCPS): New.

opcodes/
	* ppc-opc.c (PSW, PSWM, PSQ, PSQM, PSD, MTMSRD_L): New.
	(XOPS, XOPS_MASK, XW, XW_MASK): Likewise.
	(PPCPS): Likewise.
	(powerpc_opcodes): Add all pair singles instructions.
	* ppc-dis.c (powerpc_dialect): Handle "ppcps".
	(print_ppc_disassembler_options): Document -Mppcps.
@
text
@d1252 1
d1300 11
@


1.125
log
@Switch to GPLv3
@
text
@d399 18
d845 3
d1115 2
a1116 1
			generate code For PowerPC 7400/7410/7450/7455\n"));
d2664 8
@


1.124
log
@	* config/tc-ppc.c (ppc_pe_section): Comment out code assigning
	coff section flag values to bfd section flag.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.123
log
@	* config/tc-ppc.c: Convert to ISO C.
	* config/tc-ppc.c: Likewise.
@
text
@d4571 1
a4571 1

d4615 1
a4615 1

a4640 1

@


1.122
log
@	* config/tc-ppc.c (ppc_insert_operand): Truncate sign bits in
	top 32 bits of 64 bit value if so doing results in passing
	range check.  Rewrite sign extension fudges similarly.  Enable
	fudges for powerpc64 too.  Report user value if range check
	fails rather than fudged value.  Negate PPC_OPERAND_NEGATIVE
	range rather than value, also to report user value on failure.
@
text
@d87 2
a88 4
static bfd_boolean register_name PARAMS ((expressionS *));
static void ppc_set_cpu PARAMS ((void));
static void ppc_macro PARAMS ((char *str, const struct powerpc_macro *macro));
static void ppc_byte PARAMS ((int));
d91 2
a92 3
static int ppc_is_toc_sym PARAMS ((symbolS *sym));
static void ppc_tc PARAMS ((int));
static void ppc_machine PARAMS ((int));
d96 22
a117 22
static void ppc_comm PARAMS ((int));
static void ppc_bb PARAMS ((int));
static void ppc_bc PARAMS ((int));
static void ppc_bf PARAMS ((int));
static void ppc_biei PARAMS ((int));
static void ppc_bs PARAMS ((int));
static void ppc_eb PARAMS ((int));
static void ppc_ec PARAMS ((int));
static void ppc_ef PARAMS ((int));
static void ppc_es PARAMS ((int));
static void ppc_csect PARAMS ((int));
static void ppc_change_csect PARAMS ((symbolS *, offsetT));
static void ppc_function PARAMS ((int));
static void ppc_extern PARAMS ((int));
static void ppc_lglobl PARAMS ((int));
static void ppc_section PARAMS ((int));
static void ppc_named_section PARAMS ((int));
static void ppc_stabx PARAMS ((int));
static void ppc_rename PARAMS ((int));
static void ppc_toc PARAMS ((int));
static void ppc_xcoff_cons PARAMS ((int));
static void ppc_vbyte PARAMS ((int));
d121 3
a123 6
static bfd_reloc_code_real_type ppc_elf_suffix PARAMS ((char **, expressionS *));
static void ppc_elf_cons PARAMS ((int));
static void ppc_elf_rdata PARAMS ((int));
static void ppc_elf_lcomm PARAMS ((int));
static void ppc_elf_validate_fix PARAMS ((fixS *, segT));
static void ppc_apuinfo_section_add PARAMS ((unsigned int apu, unsigned int version));
d127 11
a137 12
static void ppc_set_current_section PARAMS ((segT));
static void ppc_previous PARAMS ((int));
static void ppc_pdata PARAMS ((int));
static void ppc_ydata PARAMS ((int));
static void ppc_reldata PARAMS ((int));
static void ppc_rdata PARAMS ((int));
static void ppc_ualong PARAMS ((int));
static void ppc_znop PARAMS ((int));
static void ppc_pe_comm PARAMS ((int));
static void ppc_pe_section PARAMS ((int));
static void ppc_pe_function PARAMS ((int));
static void ppc_pe_tocd PARAMS ((int));
a556 3
static int reg_name_search
  PARAMS ((const struct pd_reg *, int, const char * name));

d558 1
a558 4
reg_name_search (regs, regcount, name)
     const struct pd_reg *regs;
     int regcount;
     const char *name;
d595 1
a595 2
register_name (expressionP)
     expressionS *expressionP;
d662 1
a662 3
ppc_parse_name (name, expr)
     const char *name;
     expressionS *expr;
d925 1
a925 3
md_parse_option (c, arg)
     int c;
     char *arg;
d1079 1
a1079 2
md_show_usage (stream)
     FILE *stream;
d1132 1
a1132 1
ppc_set_cpu ()
d1160 1
a1160 1
ppc_arch ()
d1182 1
a1182 1
ppc_mach ()
d1193 1
a1193 1
ppc_target_format ()
d1225 1
a1225 1
  register const struct powerpc_opcode *op;
d1336 1
a1336 1
	  retval = hash_insert (ppc_hash, op->name, (PTR) op);
d1353 1
a1353 1
      hash_insert (ppc_hash, op->name, (PTR) op);
d1365 1
a1365 1
	  retval = hash_insert (ppc_macro_hash, macro->name, (PTR) macro);
d1383 1
a1383 1
md_begin ()
d1426 1
a1426 1
ppc_cleanup ()
d1563 1
a1563 3
ppc_elf_suffix (str_p, exp_p)
     char **str_p;
     expressionS *exp_p;
d1741 1
a1741 2
ppc_elf_cons (nbytes)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long, 8=.llong.  */
d1796 1
a1796 2
ppc_elf_rdata (xxx)
     int xxx;
d1810 1
a1810 2
ppc_elf_lcomm (xxx)
     int xxx ATTRIBUTE_UNUSED;
d1812 3
a1814 3
  register char *name;
  register char c;
  register char *p;
d1816 1
a1816 1
  register symbolS *symbolP;
d1919 1
a1919 3
ppc_elf_validate_fix (fixp, seg)
     fixS *fixp;
     segT seg;
d1964 1
a1964 1
ppc_frob_file_before_adjust ()
d2047 1
a2047 2
parse_toc_entry (toc_kind)
     enum toc_size_qualifier *toc_kind;
d2111 1
a2111 2
ppc_apuinfo_section_add (apu, version)
      unsigned int apu, version;
d2157 1
a2157 2
md_assemble (str)
     char *str;
d2781 1
a2781 3
ppc_macro (str, macro)
     char *str;
     const struct powerpc_macro *macro;
d2857 1
a2857 3
ppc_section_letter (letter, ptr_msg)
     int letter;
     char **ptr_msg;
d2867 1
a2867 3
ppc_section_word (str, len)
     char *str;
     size_t len;
d2876 1
a2876 3
ppc_section_type (str, len)
     char *str;
     size_t len;
d2885 1
a2885 4
ppc_section_flags (flags, attr, type)
     int flags;
     int attr;
     int type;
d2904 1
a2904 2
ppc_byte (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2948 1
a2948 2
ppc_comm (lcomm)
     int lcomm;
d3102 1
a3102 2
ppc_csect (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3137 1
a3137 3
ppc_change_csect (sym, align)
     symbolS *sym;
     offsetT align;
d3237 1
a3237 2
ppc_section (type)
     int type;
d3261 1
a3261 2
ppc_named_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3295 1
a3295 2
ppc_extern (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3313 1
a3313 2
ppc_lglobl (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3335 1
a3335 2
ppc_rename (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3370 1
a3370 2
ppc_stabx (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3496 1
a3496 2
ppc_function (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3589 1
a3589 2
ppc_bf (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3624 1
a3624 2
ppc_ef (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3648 1
a3648 2
ppc_biei (ei)
     int ei;
d3702 1
a3702 2
ppc_bs (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3737 1
a3737 2
ppc_es (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3761 1
a3761 2
ppc_bb (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3787 1
a3787 2
ppc_eb (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3811 1
a3811 2
ppc_bc (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3833 1
a3833 2
ppc_ec (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3852 1
a3852 2
ppc_toc (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3898 1
a3898 2
ppc_xcoff_cons (log_size)
     int log_size;
d3906 1
a3906 2
ppc_vbyte (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3949 1
a3949 2
ppc_tc (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4035 1
a4035 2
ppc_machine (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4098 1
a4098 2
ppc_is_toc_sym (sym)
     symbolS *sym;
d4119 1
a4119 2
ppc_set_current_section (new)
     segT new;
d4131 1
a4131 2
ppc_previous (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4162 1
a4162 2
ppc_pdata (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4196 1
a4196 2
ppc_ydata (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4232 1
a4232 2
ppc_reldata (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4262 1
a4262 2
ppc_rdata (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4288 1
a4288 2
ppc_ualong (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4302 1
a4302 2
ppc_znop (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4354 1
a4354 2
ppc_pe_comm (lcomm)
     int lcomm;
d4356 3
a4358 3
  register char *name;
  register char c;
  register char *p;
d4360 1
a4360 1
  register symbolS *symbolP;
d4483 1
a4483 2
ppc_pe_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4645 1
a4645 2
ppc_pe_function (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4667 1
a4667 2
ppc_pe_tocd (ignore)
     int ignore ATTRIBUTE_UNUSED;
d4692 1
a4692 2
ppc_pe_fix_adjustable (fix)
     fixS *fix;
d4707 1
a4707 2
ppc_canonicalize_symbol_name (name)
     char *name;
d4744 1
a4744 2
ppc_symbol_new_hook (sym)
     symbolS *sym;
d4832 1
a4832 2
ppc_frob_label (sym)
     symbolS *sym;
d4862 1
a4862 2
ppc_frob_symbol (sym)
     symbolS *sym;
d5125 1
a5125 1
ppc_adjust_symtab ()
d5171 1
a5171 2
ppc_frob_section (sec)
     asection *sec;
d5188 1
a5188 4
md_atof (type, litp, sizep)
     int type;
     char *litp;
     int *sizep;
d5240 1
a5240 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d5265 2
a5266 3
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
d5275 3
a5277 4
md_convert_frag (abfd, sec, fragp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragp ATTRIBUTE_UNUSED;
d5285 1
a5285 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d5296 1
a5296 3
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec ATTRIBUTE_UNUSED;
d5309 1
a5309 2
ppc_fix_adjustable (fix)
     fixS *fix;
d5434 1
a5434 2
ppc_force_relocation (fix)
     fixS *fix;
d5459 1
a5459 2
ppc_force_relocation (fix)
     fixS *fix;
d5484 1
a5484 2
ppc_fix_adjustable (fix)
     fixS *fix;
d5549 1
a5549 4
md_apply_fix (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d6073 1
a6073 3
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d6096 1
a6096 1
ppc_cfi_frame_initial_instructions ()
@


1.121
log
@gas/
	PR 4448
	* config/tc-ppc.c (ppc_insert_operand): Don't increase min for
	PPC_OPERAND_PLUS1.
include/opcode/
	* ppc.h (PPC_OPERAND_PLUS1): Update comment.
@
text
@a88 3
static unsigned long ppc_insert_operand
  PARAMS ((unsigned long insn, const struct powerpc_operand *operand,
	   offsetT val, char *file, unsigned int line));
d1507 5
a1511 6
ppc_insert_operand (insn, operand, val, file, line)
     unsigned long insn;
     const struct powerpc_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
a1513 1
  offsetT test;
a1523 15

      if (!ppc_obj64)
	{
	  /* Some people write 32 bit hex constants with the sign
	     extension done by hand.  This shouldn't really be
	     valid, but, to permit this code to assemble on a 64
	     bit host, we sign extend the 32 bit value.  */
	  if (val > 0
	      && (val & (offsetT) 0x80000000) != 0
	      && (val & (offsetT) 0xffffffff) == val)
	    {
	      val -= 0x80000000;
	      val -= 0x80000000;
	    }
	}
d1530 32
a1561 8
    test = - val;
  else
    test = val;

  if ((min <= max && (test < (offsetT) min || test > (offsetT) max))
      || (test & (right - 1)) != 0)
    as_bad_value_out_of_range (_("operand"),
			       test, (offsetT) min, (offsetT) max, file, line);
@


1.120
log
@opcodes/
	PR 4436
	* ppc-opc.c (powerpc_operands): Correct bitm for second entry of MBE.
gas/
	PR 4436
	* config/tc-ppc.c (ppc_insert_operand): Disable range check if
	min > max.
@
text
@d1547 1
a1547 4
    {
      max++;
      min++;
    }
@


1.119
log
@gas/
	* expr.c (expr): Assert on rankarg, not rank which can be unsigned.
	* read.c (read_a_source_file): Remove buffer_limit[-1] assertion.
	Don't skip over NUL char.
	(pseudo_set): Set X_op for registers to O_register.
	* symbols.c (symbol_clone): Remove assertion that sym is defined.
	(resolve_symbol_value): Resolve O_register symbols.
	* config/tc-i386.c (parse_real_register): Don't use i386_float_regtab.
	Instead find st(0) by hash lookup.
	* config/tc-ppc.c (ppc_macro): Warning fix.
opcodes/
	* i386-opc.c (i386_float_regtab, i386_float_regtab_size): Delete.
	Move contents to..
	(i386_regtab): ..here.
	* i386-opc.h (i386_float_regtab, i386_float_regtab_size): Delete.
@
text
@d1519 1
a1519 1
  
d1557 1
a1557 2
  if (test < (offsetT) min
      || test > (offsetT) max
@


1.118
log
@	* as.h (ENABLE_CHECKING): Default define to 0.
	(know): Assert if ENABLE_CHECKING.
	(struct relax_type): Remove superfluous declaration.
	* configure.in (--enable-checking): New.
	* configure: Regenerate.
	* config.in: Regenerate.
	* config/tc-ppc.c (ppc_setup_opcodes): Do checks when ENABLE_CHECKING.
	Check for duplicate powerpc_operands entries.
@
text
@d2819 1
a2819 1
  int arg;
d2857 1
a2857 1
	  know (send != format && arg >= 0 && arg < count);
@


1.117
log
@	* messages.c (as_internal_value_out_of_range): Fix typo in
	error message.  Return after printing domain error.
	* config/tc-ppc.c (ppc_insert_operand): Preserve low zero bits
	in max when shifting right.
@
text
@a1250 1
  unsigned int i;
d1261 28
a1288 14
  /* Check operand masks.  Code here and in the disassembler assumes
     all the 1's in the mask are contiguous.  */
  for (i = 0; i < num_powerpc_operands; ++i)
    {
      unsigned long mask = powerpc_operands[i].bitm;
      unsigned long right_bit;

      right_bit = mask & -mask;
      mask += right_bit;
      right_bit = mask & -mask;
      if (mask != right_bit)
	{
	  as_bad (_("powerpc_operands[%d].bitm invalid"), i);
	  bad_insn = TRUE;
d1295 4
a1298 2
      const unsigned char *o;
      unsigned long omask = op->mask;
d1300 7
a1306 7
      /* The mask had better not trim off opcode bits.  */
      if ((op->opcode & omask) != op->opcode)
	{
	  as_bad (_("mask trims opcode bits for %s"),
		  op->name);
	  bad_insn = TRUE;
	}
d1308 9
a1316 12
      /* The operands must not overlap the opcode or each other.  */
      for (o = op->operands; *o; ++o)
	if (*o >= num_powerpc_operands)
	  {
	    as_bad (_("operand index error for %s"),
		    op->name);
	    bad_insn = TRUE;
	  }
	else
	  {
	    const struct powerpc_operand *operand = &powerpc_operands[*o];
	    if (operand->shift >= 0)
d1318 2
a1319 2
		unsigned long mask = operand->bitm << operand->shift;
		if (omask & mask)
d1321 8
a1328 3
		    as_bad (_("operand %d overlap in %s"),
			    (int) (o - op->operands), op->name);
		    bad_insn = TRUE;
a1329 1
		omask |= mask;
d1331 1
a1331 1
	  }
@


1.116
log
@include/opcode/
	* ppc.h (struct powerpc_operand): Replace "bits" with "bitm".
	(num_powerpc_operands): Declare.
	(PPC_OPERAND_SIGNED et al): Redefine as hex.
	(PPC_OPERAND_PLUS1): Define.
opcodes/
	* ppc-dis.c (print_insn_powerpc): Adjust for struct powerpc_operand
	change.
	* ppc-opc.c (powerpc_operands): Replace bit count with bit mask
	in all entries.  Add PPC_OPERAND_SIGNED to DE entry.  Remove
	references to following deleted functions.
	(insert_bd, extract_bd, insert_dq, extract_dq): Delete.
	(insert_ds, extract_ds, insert_de, extract_de): Delete.
	(insert_des, extract_des, insert_li, extract_li): Delete.
	(insert_nb, insert_rsq, insert_rtq, insert_ev2, extract_ev2): Delete.
	(insert_ev4, extract_ev4, insert_ev8, extract_ev8): Delete.
	(num_powerpc_operands): New constant.
	(XSPRG_MASK): Remove entire SPRG field.
	(powerpc_opcodes <bcctre, bcctrel>): Use XLBB_MASK not XLYBB_MASK.
gas/
	* messages.c (as_internal_value_out_of_range): Extend to report
	errors for values with invalid low bits set.
	* config/tc-ppc.c (ppc_setup_opcodes): Check powerpc_operands bitm
	fields.  Check that operands and opcode fields are disjoint.
	(ppc_insert_operand): Check operands using mask rather than bit
	count.   Check low bits too.  Handle PPC_OPERAND_PLUS1.  Adjust
	insertion code.
	(md_apply_fix): Adjust for struct powerpc_operand change.
@
text
@d1511 2
a1512 2
	max >>= 1;
      min = ~(max | ((max & -max) - 1)) ;
@


1.115
log
@Add powerpc cell support.
@
text
@d3 1
a3 1
   2004, 2005, 2006 Free Software Foundation, Inc.
d1251 2
a1252 1
  bfd_boolean dup_insn = FALSE;
d1262 17
d1282 34
a1315 1
      know ((op->opcode & op->mask) == op->opcode);
d1350 1
a1350 1
	      as_bad (_("Internal assembler error for instruction %s"),
d1352 1
a1352 1
	      dup_insn = TRUE;
d1374 2
a1375 2
	      as_bad (_("Internal assembler error for macro %s"), macro->name);
	      dup_insn = TRUE;
d1380 1
a1380 1
  if (dup_insn)
d1501 22
a1522 14
  if (operand->bits != 32)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & PPC_OPERAND_SIGNED) != 0)
	{
	  if ((operand->flags & PPC_OPERAND_SIGNOPT) != 0)
	    max = (1 << operand->bits) - 1;
	  else
	    max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));

	  if (!ppc_obj64)
d1524 2
a1525 11
	      /* Some people write 32 bit hex constants with the sign
		 extension done by hand.  This shouldn't really be
		 valid, but, to permit this code to assemble on a 64
		 bit host, we sign extend the 32 bit value.  */
	      if (val > 0
		  && (val & (offsetT) 0x80000000) != 0
		  && (val & (offsetT) 0xffffffff) == val)
		{
		  val -= 0x80000000;
		  val -= 0x80000000;
		}
d1528 7
a1534 5
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}
d1536 4
a1539 4
      if ((operand->flags & PPC_OPERAND_NEGATIVE) != 0)
	test = - val;
      else
	test = val;
d1541 5
a1545 3
      if (test < (offsetT) min || test > (offsetT) max)
	as_bad_value_out_of_range (_("operand"), test, (offsetT) min, (offsetT) max, file, line);
    }
d1557 1
a1557 2
    insn |= (((long) val & ((1 << operand->bits) - 1))
	     << operand->shift);
d5693 1
a5693 1
	  && operand->bits == 16
d5731 1
a5731 1
	  && operand->bits == 26
d5735 1
a5735 1
	  && operand->bits == 16
d5746 1
a5746 1
	       && operand->bits == 26
d5750 1
a5750 1
	       && operand->bits == 16
d5762 1
a5762 1
	       && operand->bits == 16
@


1.114
log
@	* config/tc-ppc.c (ppc_symbol_chars): Remove '+' and '-'.
@
text
@d923 6
d1125 1
@


1.113
log
@	* config/tc-ppc.c (md_section_align): Don't round up address for ELF.
	(ppc_handle_align): New function.
	* config/tc-ppc.h (HANDLE_ALIGN): Use ppc_handle_align.
	(SUB_SEGMENT_ALIGN): Define as zero.
@
text
@d185 1
a185 3
/* '+' and '-' can be used as postfix predicate predictors for conditional
   branches.  So they need to be accepted as symbol characters.
   Also, anything that can start an operand needs to be mentioned here,
d187 1
a187 1
const char ppc_symbol_chars[] = "+-%[";
@


1.112
log
@remove some duplicate #include's.
@
text
@d5268 1
a5268 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d5270 3
d5276 1
d5524 41
@


1.111
log
@include/opcode/
	* ppc.h (PPC_OPCODE_POWER6): Define.
	Adjust whitespace.
gas/
	* config/tc-ppc.c (parse_cpu): Handle "-mpower6".
	(md_show_usage): Document it.
	(ppc_setup_opcodes): Test power6 opcode flag bits.
	* doc/c-ppc.texi (PowerPC-Opts): Document "-mpower6".
opcodes/
	* ppc-dis.c (powerpc_dialect): Handle power6 option.
	(print_ppc_disassembler_options): Mention power6.
@
text
@a22 1
#include <stdio.h>
@


1.110
log
@	* config/tc-arm.c, config/tc-arm.h (tc_arm_regname_to_dw2regnum):
	Un-constify string argument.
	* config/tc-i386.c, config/tc-i386.h (tc_x86_regname_to_dw2regnum):
	Likewise.
	* config/tc-m68k.c, config/tc-m68k.h (tc_m68k_regname_to_dw2regnum):
	Likewise.
	* config/tc-ppc.c, config/tc-ppc.h (tc_ppc_regname_to_dw2regnum):
	Likewise.
	* config/tc-s390.c, config/tc-s390.h (tc_s390_regname_to_dw2regnum):
	Likewise.
	* config/tc-sh.c, config/tc-sh.h (sh_regname_to_dw2regnum):
	Likewise.
	* config/tc-sparc.c, config/tc-sparc.h (sparc_regname_to_dw2regnum):
	Likewise.
-------------------------------------------------------------------
@
text
@d3 1
a3 1
   2004, 2005 Free Software Foundation, Inc.
d920 6
d1121 1
d1280 4
a1283 1
		  == (ppc_cpu & PPC_OPCODE_POWER5))))
@


1.109
log
@* config/tc-ppc.c (ppc_frob_file_before_adjust): Do not reference
dotname.
* write.c (write_object_file): Do not remove used weakrefd.
@
text
@d6081 1
a6081 1
tc_ppc_regname_to_dw2regnum (const char *regname)
@


1.108
log
@	* config/tc-ppc.c (ppc_pe_comm): Set bfd_com_section segment.
	* config/tc-alpha.c (s_alpha_comm): Likewise.  Also, remove
	redundant check.
	* read.c (s_lsym): Remove non-BFD assembler sym handling.
@
text
@d1934 1
a1934 1
      dotsym = symbol_find (dotname);
@


1.107
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d4419 1
@


1.106
log
@	PR 1036
	* config/tc-ppc.c (ppc_symbol_chars): Add '%' and '['.
@
text
@d4843 4
@


1.105
log
@	* config/tc-ppc.c (ppc_set_cpu): Don't select 64-bit based on
	default cpu.
@
text
@d187 4
a190 2
   branches.  So they need to be accepted as symbol characters.  */
const char ppc_symbol_chars[] = "+-";
@


1.104
log
@gas/
	* config/tc-ppc.c (parse_cpu): Add -me300 support.
	(md_show_usage): Likewise.
	* doc/c-ppc.texi (PowerPC-Opts): Document it.
include/opcode/
	* ppc.h (PPC_OPCODE_E300): Define.
opcodes/
	* ppc-dis.c (powerpc_dialect): Handle e300.
	(print_ppc_disassembler_options): Likewise.
	* ppc-opc.c (PPCE300): Define.
	(powerpc_opcodes): Mark icbt as available for the e300.
binutils/
	* doc/binutils.texi (objdump): Document -M e300.
@
text
@d1158 1
a1158 6
	{
	  if (default_cpu[7] == '6' && default_cpu[8] == '4')
	    ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
	  else
	    ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
	}
@


1.103
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d861 3
d1117 1
@


1.102
log
@	* config/tc-ppc.c (md_apply_fix <ELF>): Don't warn on overflow
	if emitting a reloc.
@
text
@d5535 5
a5539 5
     the symbol values.  Since we are using BFD_ASSEMBLER, if we are
     doing this relocation the code in write.c is going to call
     bfd_install_relocation, which is also going to use the symbol
     value.  That means that if the reloc is fully resolved we want to
     use *valP since bfd_install_relocation is not being used.
@


1.101
log
@2005-05-07  Paul Brook  <paul@@codesourcery.com>

bfd/
	* config.bfd: Add separate case for ppc-vxworks.
	* configure: Regenerate.
	* configure.in: Include elf-vxworks.lo on ppc targets.
	* elf-vxworks.c (elf_vxworks_final_write_processing): Handle
	.rela.plt.unloaded.
	* elf32-ppc.c: Add VxWorks target vec.	Include elf-vxworks.h.
	(PLT_ENTRY_SIZE, PLT_INITIAL_ENTRY_SIZE, PLT_SLOT_SIZE): Remove.
	(VXWORKS_PLT_ENTRY_SIZE, ppc_elf_vxworks_plt_entry,
	ppc_elf_vxworks_pic_plt_entry, VXWORKS_PLT_INITIAL_ENTRY_SIZE,
	ppc_elf_vxworks_plt0_entry, ppc_elf_vxworks_pic_plt0_entry,
	VXWORKS_PLT_NON_JMP_SLOT_RELOCS, VXWORKS_PLTRESOLVE_RELOCS,
	VXWORKS_PLTRESOLVE_RELOCS_SHLIB): New.
	(ppc_elf_link_hash_table): Add srelplt2, sgotplt, hgot, hplt,
	is_vxworks, plt_entry_size, plt_slot_size, plt_initial_entry_size.
	(ppc_elf_link_hash_table_create): Initialize hadtab plt fields.
	(ppc_elf_create_got): Create .got.plt for VxWorks.
	(ppc_elf_create_dynamic_sections): Create unloaded plt relocation
	section for VxWorks.
	(ppc_elf_select_plt_layout): Handle VxWorks plt format.
	(allocate_got): VxWorks does not need a got header.
	(allocate_dynrelocs): Handle VxWorks plt format.
	(ppc_elf_size_dynamic_sections): Save _G_O_T_ and _P_L_T_ symbols for
	VxWorks.  Handle VxWorks plt/got.
	(ppc_elf_finish_dynamic_sections): Fill in VxWorks plt.
	(ppc_elf_vxworks_special_sections): New.
	(ppc_elf_vxworks_link_hash_table_create,
	ppc_elf_vxworks_add_symbol_hook,
	elf_i386_vxworks_link_output_symbol_hook,
	ppc_elf_vxworks_final_write_processing): New functions.
	* targets.c (bfd_elf32_powerpc_vxworks_vec): Declare.
	(_bfd_target_vector): Use it.
gas/
	* config/tc-ppc.c (ppc_target_format): Add VxWorks.
gas/testsuite/
	* gas/ppc/altivec.d: Match all powerpc target vecs.
	* gas/ppc/booke.d: Ditto.
	* gas/ppc/e500.d: Ditto.
ld/
	* Makefile.am (ALL_EMULATIONS): Add eelf32ppcvxworks.o.
	(eelf32ppcvxworks.o): Add dependencies.
	* Makefile.in: Regenerate.
	* configure.tgt: Add entry for powerpc-vxworks.
	* emulparams/elf32-ppc.c: Mention elf32ppcvxworks.sh in comment.
	* emulparams/elf32ppcvxworks.sh: New file.
	* emultempl/ppc32elf.em (bfd_elf32_powerpc_vxworks_vec): Declare.
	(is_ppc_elf32_vec): New function.
	(ppc_after_open, ppc_before_allocation,
	gld${EMULATION_NAME}_after_allocation): Use it.
@
text
@d6017 7
@


1.100
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d1219 3
d1225 1
@


1.99
log
@	* config/tc-ppc.c (ppc_force_relocation): Add BFD_RELOC_24_PLT_PCREL.
@
text
@d2654 1
a2654 1
     md_apply_fix3.  */
d5513 1
a5513 1
md_apply_fix3 (fixP, valP, seg)
@


1.98
log
@	* config/tc-ppc.c (parse_cpu): Handle "-mpower5".
	(md_show_usage): Document it.
	(ppc_setup_opcodes): Insert POWER5 mnemonics.
	* doc/c-ppc.texi (PowerPC-Opts): Document "-mpower5".
@
text
@d5473 1
@


1.97
log
@	* config/tc-ppc.c (md_apply_fix3): Allow pcrel forms of BFD_RELOC_16,
	BFD_RELOC_LO16, BFD_RELOC_HI16 and BFD_RELOC_HI16_S.
@
text
@d909 6
d1109 1
d1265 4
a1268 1
		  == (ppc_cpu & PPC_OPCODE_POWER4))))
@


1.96
log
@Update the address and phone number of the FSF
@
text
@a5709 2
	case BFD_RELOC_LO16:
	case BFD_RELOC_16:
d5755 20
d5780 4
a5783 1
	    abort ();
d5790 4
a5793 1
	    abort ();
@


1.95
log
@	* config/tc-ppc.c (ppc_fix_adjustable <ELF>): Remove bogus checks.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.94
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d5488 1
a5488 6
	       && fix->fx_r_type <= BFD_RELOC_PPC64_DTPREL16_HIGHESTA)
	  && (fix->fx_pcrel
	      || (fix->fx_subsy != NULL
		  && (S_GET_SEGMENT (fix->fx_subsy)
		      == S_GET_SEGMENT (fix->fx_addsy)))
	      || S_IS_LOCAL (fix->fx_addsy)));
@


1.93
log
@2004-10-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ppc.c (md_apply_fix3): Call S_SET_THREAD_LOCAL for
	TLS relocations.
	* config/tc-s390.c (md_apply_fix3): Likewise.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
@
text
@d3 1
a3 1
   2004 Free Software Foundation, Inc.
d5822 1
a5822 1
	    unsigned char *where = fixP->fx_frag->fr_literal + fixP->fx_where;
@


1.92
log
@	* config/tc-ppc.c (tc_ppc_regname_to_dw2regnum <regnames>): Replace
	{ "cc", 68 }, with { "cr", 70 }.
@
text
@d5849 2
d5890 1
@


1.91
log
@	* config/tc-ppc.c (ppc_frob_file_before_adjust): Warn if .toc too big.
	(ppc_arch): Expand comment.
@
text
@d6041 1
a6041 1
      { "cc", 68 }, { "xer", 76 }, { "vrsave", 109 }, { "vscr", 110 },
@


1.90
log
@Add CRX insns: pushx, popx
Add support to GAS for expressions which are the difference of two symbols
@
text
@d1159 2
a1160 1
/* Figure out the BFD architecture to use.  */
d1895 1
d1927 5
@


1.89
log
@	* frags.h (struct frag): Add has_code and insn_addr fields.
	* write.c (cvt_frag_to_fill): Invoke md_frag_check.
	* config/tc-ppc.c (md_assemble): Check and set insn_addr.
	* config/tc-ppc.h (md_frag_check): Define.
@
text
@d1921 2
a1922 3
	{
	  symbol_mark_used (symp);
	}
d4845 1
a4845 1
	  || (! S_IS_EXTERNAL (sym)
d4911 1
a4911 1
  if (! S_IS_EXTERNAL (sym)
@


1.88
log
@Remove duplicate code and provide a function for generating internally consistent 'value out of range' messages
@
text
@d2094 1
d2622 5
@


1.87
log
@	PR 96
	* config/tc-ppc.c (ppc_elf_suffix): Add valid32 and valid64 fields
	to struct map_bfd.  Adjust MAP macro, and define MAP32, MAP64.
	Update "mapping".  Restrict some @@ modifiers to 32 bit.
@
text
@d1460 1
a1460 8
	{
	  const char *err =
	    _("operand out of range (%s not between %ld and %ld)");
	  char buf[100];

	  sprint_value (buf, test);
	  as_bad_where (file, line, err, buf, min, max);
	}
@


1.86
log
@(md_apply_fix3): Handle the case where a .byte directive generates a
pc-relative relocation.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d186 1
a186 1
/* '+' and '-' can be used as postfix predicate predictors for conditional 
d1496 4
a1499 2
    int length;
    int reloc;
d1509 3
a1511 1
#define MAP(str,reloc) { str, sizeof (str)-1, reloc }
d1514 86
a1599 88
    MAP ("l",			(int) BFD_RELOC_LO16),
    MAP ("h",			(int) BFD_RELOC_HI16),
    MAP ("ha",			(int) BFD_RELOC_HI16_S),
    MAP ("brtaken",		(int) BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",		(int) BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",			(int) BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",		(int) BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",		(int) BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",		(int) BFD_RELOC_HI16_S_GOTOFF),
    MAP ("fixup",		(int) BFD_RELOC_CTOR),
    MAP ("plt",			(int) BFD_RELOC_24_PLT_PCREL),
    MAP ("pltrel24",		(int) BFD_RELOC_24_PLT_PCREL),
    MAP ("copy",		(int) BFD_RELOC_PPC_COPY),
    MAP ("globdat",		(int) BFD_RELOC_PPC_GLOB_DAT),
    MAP ("local24pc",		(int) BFD_RELOC_PPC_LOCAL24PC),
    MAP ("local",		(int) BFD_RELOC_PPC_LOCAL24PC),
    MAP ("pltrel",		(int) BFD_RELOC_32_PLT_PCREL),
    MAP ("plt@@l",		(int) BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",		(int) BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",		(int) BFD_RELOC_HI16_S_PLTOFF),
    MAP ("sdarel",		(int) BFD_RELOC_GPREL16),
    MAP ("sectoff",		(int) BFD_RELOC_16_BASEREL),
    MAP ("sectoff@@l",		(int) BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",		(int) BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",		(int) BFD_RELOC_HI16_S_BASEREL),
    MAP ("naddr",		(int) BFD_RELOC_PPC_EMB_NADDR32),
    MAP ("naddr16",		(int) BFD_RELOC_PPC_EMB_NADDR16),
    MAP ("naddr@@l",		(int) BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP ("naddr@@h",		(int) BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP ("naddr@@ha",		(int) BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP ("sdai16",		(int) BFD_RELOC_PPC_EMB_SDAI16),
    MAP ("sda2rel",		(int) BFD_RELOC_PPC_EMB_SDA2REL),
    MAP ("sda2i16",		(int) BFD_RELOC_PPC_EMB_SDA2I16),
    MAP ("sda21",		(int) BFD_RELOC_PPC_EMB_SDA21),
    MAP ("mrkref",		(int) BFD_RELOC_PPC_EMB_MRKREF),
    MAP ("relsect",		(int) BFD_RELOC_PPC_EMB_RELSEC16),
    MAP ("relsect@@l",		(int) BFD_RELOC_PPC_EMB_RELST_LO),
    MAP ("relsect@@h",		(int) BFD_RELOC_PPC_EMB_RELST_HI),
    MAP ("relsect@@ha",		(int) BFD_RELOC_PPC_EMB_RELST_HA),
    MAP ("bitfld",		(int) BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP ("relsda",		(int) BFD_RELOC_PPC_EMB_RELSDA),
    MAP ("xgot",		(int) BFD_RELOC_PPC_TOC16),
    MAP ("tls",			(int) BFD_RELOC_PPC_TLS),
    MAP ("dtpmod",		(int) BFD_RELOC_PPC_DTPMOD),
    MAP ("dtprel",		(int) BFD_RELOC_PPC_DTPREL),
    MAP ("dtprel@@l",		(int) BFD_RELOC_PPC_DTPREL16_LO),
    MAP ("dtprel@@h",		(int) BFD_RELOC_PPC_DTPREL16_HI),
    MAP ("dtprel@@ha",		(int) BFD_RELOC_PPC_DTPREL16_HA),
    MAP ("tprel",		(int) BFD_RELOC_PPC_TPREL),
    MAP ("tprel@@l",		(int) BFD_RELOC_PPC_TPREL16_LO),
    MAP ("tprel@@h",		(int) BFD_RELOC_PPC_TPREL16_HI),
    MAP ("tprel@@ha",		(int) BFD_RELOC_PPC_TPREL16_HA),
    MAP ("got@@tlsgd",		(int) BFD_RELOC_PPC_GOT_TLSGD16),
    MAP ("got@@tlsgd@@l",		(int) BFD_RELOC_PPC_GOT_TLSGD16_LO),
    MAP ("got@@tlsgd@@h",		(int) BFD_RELOC_PPC_GOT_TLSGD16_HI),
    MAP ("got@@tlsgd@@ha",	(int) BFD_RELOC_PPC_GOT_TLSGD16_HA),
    MAP ("got@@tlsld",		(int) BFD_RELOC_PPC_GOT_TLSLD16),
    MAP ("got@@tlsld@@l",		(int) BFD_RELOC_PPC_GOT_TLSLD16_LO),
    MAP ("got@@tlsld@@h",		(int) BFD_RELOC_PPC_GOT_TLSLD16_HI),
    MAP ("got@@tlsld@@ha",	(int) BFD_RELOC_PPC_GOT_TLSLD16_HA),
    MAP ("got@@dtprel",		(int) BFD_RELOC_PPC_GOT_DTPREL16),
    MAP ("got@@dtprel@@l",	(int) BFD_RELOC_PPC_GOT_DTPREL16_LO),
    MAP ("got@@dtprel@@h",	(int) BFD_RELOC_PPC_GOT_DTPREL16_HI),
    MAP ("got@@dtprel@@ha",	(int) BFD_RELOC_PPC_GOT_DTPREL16_HA),
    MAP ("got@@tprel",		(int) BFD_RELOC_PPC_GOT_TPREL16),
    MAP ("got@@tprel@@l",		(int) BFD_RELOC_PPC_GOT_TPREL16_LO),
    MAP ("got@@tprel@@h",		(int) BFD_RELOC_PPC_GOT_TPREL16_HI),
    MAP ("got@@tprel@@ha",	(int) BFD_RELOC_PPC_GOT_TPREL16_HA),
    /* The following are only valid for ppc64.  Negative values are
       used instead of a flag.  */
    MAP ("higher",		- (int) BFD_RELOC_PPC64_HIGHER),
    MAP ("highera",		- (int) BFD_RELOC_PPC64_HIGHER_S),
    MAP ("highest",		- (int) BFD_RELOC_PPC64_HIGHEST),
    MAP ("highesta",		- (int) BFD_RELOC_PPC64_HIGHEST_S),
    MAP ("tocbase",		- (int) BFD_RELOC_PPC64_TOC),
    MAP ("toc",			- (int) BFD_RELOC_PPC_TOC16),
    MAP ("toc@@l",		- (int) BFD_RELOC_PPC64_TOC16_LO),
    MAP ("toc@@h",		- (int) BFD_RELOC_PPC64_TOC16_HI),
    MAP ("toc@@ha",		- (int) BFD_RELOC_PPC64_TOC16_HA),
    MAP ("dtprel@@higher",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHER),
    MAP ("dtprel@@highera",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHERA),
    MAP ("dtprel@@highest",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHEST),
    MAP ("dtprel@@highesta",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHESTA),
    MAP ("tprel@@higher",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHER),
    MAP ("tprel@@highera",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHERA),
    MAP ("tprel@@highest",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHEST),
    MAP ("tprel@@highesta",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHESTA),
    { (char *) 0, 0,		(int) BFD_RELOC_UNUSED }
d1620 2
a1621 1
	&& memcmp (ident, ptr->string, ptr->length) == 0)
a1624 7
	if (reloc < 0)
	  {
	    if (!ppc_obj64)
	      return BFD_RELOC_UNUSED;
	    reloc = -reloc;
	  }

d5900 1
a5900 1
	         ".byte <undefined_symbol> - ."  */
d6051 1
a6051 1
        regnum += 32;
d6053 1
a6053 1
        regnum += 77;
d6059 1
a6059 1
        return -1;
@


1.86.6.1
log
@Merge to 2.15 branch.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d186 1
a186 1
/* '+' and '-' can be used as postfix predicate predictors for conditional
d1496 2
a1497 4
    unsigned int length : 8;
    unsigned int valid32 : 1;
    unsigned int valid64 : 1;
    unsigned int reloc;
d1507 1
a1507 3
#define MAP(str, reloc)   { str, sizeof (str) - 1, 1, 1, reloc }
#define MAP32(str, reloc) { str, sizeof (str) - 1, 1, 0, reloc }
#define MAP64(str, reloc) { str, sizeof (str) - 1, 0, 1, reloc }
d1510 88
a1597 86
    MAP ("l",			BFD_RELOC_LO16),
    MAP ("h",			BFD_RELOC_HI16),
    MAP ("ha",			BFD_RELOC_HI16_S),
    MAP ("brtaken",		BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",		BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",			BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",		BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",		BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",		BFD_RELOC_HI16_S_GOTOFF),
    MAP ("plt@@l",		BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",		BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",		BFD_RELOC_HI16_S_PLTOFF),
    MAP ("copy",		BFD_RELOC_PPC_COPY),
    MAP ("globdat",		BFD_RELOC_PPC_GLOB_DAT),
    MAP ("sectoff",		BFD_RELOC_16_BASEREL),
    MAP ("sectoff@@l",		BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",		BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",		BFD_RELOC_HI16_S_BASEREL),
    MAP ("tls",			BFD_RELOC_PPC_TLS),
    MAP ("dtpmod",		BFD_RELOC_PPC_DTPMOD),
    MAP ("dtprel",		BFD_RELOC_PPC_DTPREL),
    MAP ("dtprel@@l",		BFD_RELOC_PPC_DTPREL16_LO),
    MAP ("dtprel@@h",		BFD_RELOC_PPC_DTPREL16_HI),
    MAP ("dtprel@@ha",		BFD_RELOC_PPC_DTPREL16_HA),
    MAP ("tprel",		BFD_RELOC_PPC_TPREL),
    MAP ("tprel@@l",		BFD_RELOC_PPC_TPREL16_LO),
    MAP ("tprel@@h",		BFD_RELOC_PPC_TPREL16_HI),
    MAP ("tprel@@ha",		BFD_RELOC_PPC_TPREL16_HA),
    MAP ("got@@tlsgd",		BFD_RELOC_PPC_GOT_TLSGD16),
    MAP ("got@@tlsgd@@l",		BFD_RELOC_PPC_GOT_TLSGD16_LO),
    MAP ("got@@tlsgd@@h",		BFD_RELOC_PPC_GOT_TLSGD16_HI),
    MAP ("got@@tlsgd@@ha",	BFD_RELOC_PPC_GOT_TLSGD16_HA),
    MAP ("got@@tlsld",		BFD_RELOC_PPC_GOT_TLSLD16),
    MAP ("got@@tlsld@@l",		BFD_RELOC_PPC_GOT_TLSLD16_LO),
    MAP ("got@@tlsld@@h",		BFD_RELOC_PPC_GOT_TLSLD16_HI),
    MAP ("got@@tlsld@@ha",	BFD_RELOC_PPC_GOT_TLSLD16_HA),
    MAP ("got@@dtprel",		BFD_RELOC_PPC_GOT_DTPREL16),
    MAP ("got@@dtprel@@l",	BFD_RELOC_PPC_GOT_DTPREL16_LO),
    MAP ("got@@dtprel@@h",	BFD_RELOC_PPC_GOT_DTPREL16_HI),
    MAP ("got@@dtprel@@ha",	BFD_RELOC_PPC_GOT_DTPREL16_HA),
    MAP ("got@@tprel",		BFD_RELOC_PPC_GOT_TPREL16),
    MAP ("got@@tprel@@l",		BFD_RELOC_PPC_GOT_TPREL16_LO),
    MAP ("got@@tprel@@h",		BFD_RELOC_PPC_GOT_TPREL16_HI),
    MAP ("got@@tprel@@ha",	BFD_RELOC_PPC_GOT_TPREL16_HA),
    MAP32 ("fixup",		BFD_RELOC_CTOR),
    MAP32 ("plt",		BFD_RELOC_24_PLT_PCREL),
    MAP32 ("pltrel24",		BFD_RELOC_24_PLT_PCREL),
    MAP32 ("local24pc",		BFD_RELOC_PPC_LOCAL24PC),
    MAP32 ("local",		BFD_RELOC_PPC_LOCAL24PC),
    MAP32 ("pltrel",		BFD_RELOC_32_PLT_PCREL),
    MAP32 ("sdarel",		BFD_RELOC_GPREL16),
    MAP32 ("naddr",		BFD_RELOC_PPC_EMB_NADDR32),
    MAP32 ("naddr16",		BFD_RELOC_PPC_EMB_NADDR16),
    MAP32 ("naddr@@l",		BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP32 ("naddr@@h",		BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP32 ("naddr@@ha",		BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP32 ("sdai16",		BFD_RELOC_PPC_EMB_SDAI16),
    MAP32 ("sda2rel",		BFD_RELOC_PPC_EMB_SDA2REL),
    MAP32 ("sda2i16",		BFD_RELOC_PPC_EMB_SDA2I16),
    MAP32 ("sda21",		BFD_RELOC_PPC_EMB_SDA21),
    MAP32 ("mrkref",		BFD_RELOC_PPC_EMB_MRKREF),
    MAP32 ("relsect",		BFD_RELOC_PPC_EMB_RELSEC16),
    MAP32 ("relsect@@l",		BFD_RELOC_PPC_EMB_RELST_LO),
    MAP32 ("relsect@@h",		BFD_RELOC_PPC_EMB_RELST_HI),
    MAP32 ("relsect@@ha",	BFD_RELOC_PPC_EMB_RELST_HA),
    MAP32 ("bitfld",		BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP32 ("relsda",		BFD_RELOC_PPC_EMB_RELSDA),
    MAP32 ("xgot",		BFD_RELOC_PPC_TOC16),
    MAP64 ("higher",		BFD_RELOC_PPC64_HIGHER),
    MAP64 ("highera",		BFD_RELOC_PPC64_HIGHER_S),
    MAP64 ("highest",		BFD_RELOC_PPC64_HIGHEST),
    MAP64 ("highesta",		BFD_RELOC_PPC64_HIGHEST_S),
    MAP64 ("tocbase",		BFD_RELOC_PPC64_TOC),
    MAP64 ("toc",		BFD_RELOC_PPC_TOC16),
    MAP64 ("toc@@l",		BFD_RELOC_PPC64_TOC16_LO),
    MAP64 ("toc@@h",		BFD_RELOC_PPC64_TOC16_HI),
    MAP64 ("toc@@ha",		BFD_RELOC_PPC64_TOC16_HA),
    MAP64 ("dtprel@@higher",	BFD_RELOC_PPC64_DTPREL16_HIGHER),
    MAP64 ("dtprel@@highera",	BFD_RELOC_PPC64_DTPREL16_HIGHERA),
    MAP64 ("dtprel@@highest",	BFD_RELOC_PPC64_DTPREL16_HIGHEST),
    MAP64 ("dtprel@@highesta",	BFD_RELOC_PPC64_DTPREL16_HIGHESTA),
    MAP64 ("tprel@@higher",	BFD_RELOC_PPC64_TPREL16_HIGHER),
    MAP64 ("tprel@@highera",	BFD_RELOC_PPC64_TPREL16_HIGHERA),
    MAP64 ("tprel@@highest",	BFD_RELOC_PPC64_TPREL16_HIGHEST),
    MAP64 ("tprel@@highesta",	BFD_RELOC_PPC64_TPREL16_HIGHESTA),
    { (char *) 0, 0, 0, 0,	BFD_RELOC_UNUSED }
d1618 1
a1618 2
	&& memcmp (ident, ptr->string, ptr->length) == 0
	&& (ppc_obj64 ? ptr->valid64 : ptr->valid32))
d1622 7
d5904 1
a5904 1
		 ".byte <undefined_symbol> - ."  */
d6055 1
a6055 1
	regnum += 32;
d6057 1
a6057 1
	regnum += 77;
d6063 1
a6063 1
	return -1;
@


1.85
log
@opcodes:
	* ppc-opc.c (MO): Make optional.
	(RAO, RSO, SHO): New optional forms of RA, RS, SH operands.
	(tlbwe): Accept for both PPC403 and BOOKE.  Make all operands optional.
gas:
	* tc-ppc.c (md_assemble): Rewrite comment about optional operands
	to indicate that 'all or none' is also handled.  Pluralize a
	word in another comment.
gas/testsuite:
	* gas/ppc/booke.s: Add two more forms of the mbar instruction
	and three forms of the tlbwe instruction.
	* gas/ppc/booke.d: Update to match.
@
text
@d5902 13
a5914 4
	    abort ();

	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 1);
@


1.84
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d2139 8
a2146 7
     an optional operand separate the operands only with commas (in
     some cases parentheses are used, as in ``lwz 1,0(1)'' but such
     cases never have optional operands).  There is never more than
     one optional operand for an instruction.  So, before we start
     seriously parsing the operands, we check to see if we have an
     optional operand, and, if we do, we count the number of commas to
     see whether the operand should be omitted.  */
d2182 1
a2182 1
	     operand.  */
@


1.83
log
@	* config/tc-ppc.c (parse_cpu): New function, broken out from..
	(md_parse_option): ..here.
	(ppc_setup_opcodes): New function, broken out from..
	(md_begin): ..here.
	(ppc_machine): Implement .machine pseudo op.
@
text
@d1322 1
a1322 1
  /* Tell the main code what the endianness is if it is not overidden
d2885 1
a2885 1
   symbols, and uses a different smclas.  The native Aix 4.3.3 assember
d3440 1
a3440 1
   argment seems to be the label for the start of the function.  gcc
@


1.82
log
@	* config/tc-ppc.c (md_parse_option): Add PPC_OPCODE_ANY to existing
	ppc_cpu selection rather than replacing.
	(ppc_set_cpu): Ignore and preserve PPC_OPCODE_ANY in ppc_cpu.
	(md_begin): When PPC_OPCODE_ANY, insert all opcodes in ppc_hash.
@
text
@d822 101
d990 2
a991 89
      /* -mpwrx and -mpwr2 mean to assemble for the IBM POWER/2
	 (RIOS2).  */
      if (strcmp (arg, "pwrx") == 0 || strcmp (arg, "pwr2") == 0)
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_POWER2 | PPC_OPCODE_32;
      /* -mpwr means to assemble for the IBM POWER (RIOS1).  */
      else if (strcmp (arg, "pwr") == 0)
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
      /* -m601 means to assemble for the PowerPC 601, which includes
	 instructions that are holdovers from the Power.  */
      else if (strcmp (arg, "601") == 0)
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		   | PPC_OPCODE_601 | PPC_OPCODE_32);
      /* -mppc, -mppc32, -m603, and -m604 mean to assemble for the
	 PowerPC 603/604.  */
      else if (strcmp (arg, "ppc") == 0
	       || strcmp (arg, "ppc32") == 0
	       || strcmp (arg, "603") == 0
	       || strcmp (arg, "604") == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
      /* -m403 and -m405 mean to assemble for the PowerPC 403/405.  */
      else if (strcmp (arg, "403") == 0
	       || strcmp (arg, "405") == 0)
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		   | PPC_OPCODE_403 | PPC_OPCODE_32);
      else if (strcmp (arg, "440") == 0)
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32
		   | PPC_OPCODE_440 | PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI);
      else if (strcmp (arg, "7400") == 0
	       || strcmp (arg, "7410") == 0
	       || strcmp (arg, "7450") == 0
	       || strcmp (arg, "7455") == 0)
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		   | PPC_OPCODE_ALTIVEC | PPC_OPCODE_32);
      else if (strcmp (arg, "altivec") == 0)
	{
	  if (ppc_cpu == 0)
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_ALTIVEC;
	  else
	    ppc_cpu |= PPC_OPCODE_ALTIVEC;
	}
      else if (strcmp (arg, "e500") == 0 || strcmp (arg, "e500x2") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
		     | PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
		     | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
		     | PPC_OPCODE_RFMCI);
	}
      else if (strcmp (arg, "spe") == 0)
	{
	  if (ppc_cpu == 0)
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_SPE | PPC_OPCODE_EFS;
	  else
	    ppc_cpu |= PPC_OPCODE_SPE;
	}
      /* -mppc64 and -m620 mean to assemble for the 64-bit PowerPC
	 620.  */
      else if (strcmp (arg, "ppc64") == 0 || strcmp (arg, "620") == 0)
	{
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
	}
      else if (strcmp (arg, "ppc64bridge") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		     | PPC_OPCODE_64_BRIDGE | PPC_OPCODE_64);
	}
      /* -mbooke/-mbooke32 mean enable 32-bit BookE support.  */
      else if (strcmp (arg, "booke") == 0 || strcmp (arg, "booke32") == 0)
	{
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32;
	}
      /* -mbooke64 means enable 64-bit BookE support.  */
      else if (strcmp (arg, "booke64") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE
		     | PPC_OPCODE_BOOKE64 | PPC_OPCODE_64);
	}
      else if (strcmp (arg, "power4") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		     | PPC_OPCODE_64 | PPC_OPCODE_POWER4);
	}
      /* -mcom means assemble for the common intersection between Power
	 and PowerPC.  At present, we just allow the union, rather
	 than the intersection.  */
      else if (strcmp (arg, "com") == 0)
	ppc_cpu = PPC_OPCODE_COMMON | PPC_OPCODE_32;
      /* -many means to assemble for any architecture (PWR/PWRX/PPC).  */
      else if (strcmp (arg, "any") == 0)
	ppc_cpu |= PPC_OPCODE_ANY;
d1217 2
a1218 3
/* This function is called when the assembler starts up.  It is called
   after the options have been parsed and the output file has been
   opened.  */
d1220 2
a1221 2
void
md_begin ()
d1229 4
a1232 9
  ppc_set_cpu ();

  ppc_cie_data_alignment = ppc_obj64 ? -8 : -4;

#ifdef OBJ_ELF
  /* Set the ELF flags if desired.  */
  if (ppc_flags && !msolaris)
    bfd_set_private_flags (stdoutput, ppc_flags);
#endif
d1262 1
a1262 1
	  if (retval != (const char *) NULL)
d1301 20
a3997 6
/* FIXME: `.machine' is a nop for the moment.  It would be nice to
   accept this directive on the first line of input and set ppc_obj64
   and the target format accordingly.  Unfortunately, the target
   format is selected in output-file.c:output_file_create before we
   even get to md_begin, so it's not possible without changing
   as.c:main.  */
d4003 56
a4058 1
  discard_rest_of_line ();
@


1.81
log
@	* config/tc-ppc.c (md_parse_option): Add PPC_OPCODE_ISEL and
	PPC_OPCODE_RFMCI to -m440 selected ppc_cpu.
@
text
@d977 1
a977 1
	ppc_cpu = PPC_OPCODE_ANY | PPC_OPCODE_32;
d1121 1
a1121 1
  if (ppc_cpu == 0)
d1124 1
a1124 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
d1127 1
a1127 1
	ppc_cpu = PPC_OPCODE_COMMON | PPC_OPCODE_32;
d1129 1
a1129 1
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
d1131 1
a1131 1
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
d1135 1
a1135 1
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
d1137 1
a1137 1
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
d1267 4
@


1.80
log
@	* config/tc-ppc.c (md_parse_option): Handle -m440.
	(md_apply_fix3): Warning fix.
	(md_show_usage): Add -m440.
	* doc/c-ppc.texi: Document -m440.
@
text
@d915 1
a915 1
		   | PPC_OPCODE_440);
@


1.79
log
@	* config/tc-ppc.c (md_apply_fix3): Fix check for lq insns.
@
text
@d913 3
d1080 1
d5740 1
a5740 1
	    long val, mask;
@


1.78
log
@	* config/tc-ppc.h (DWARF2_LINE_MIN_INSN_LENGTH): Define always.
	(TARGET_USE_CFIPOP, tc_cfi_frame_initial_instructions,
	tc_regname_to_dw2regnum, DWARF2_DEFAULT_RETURN_COLUMN,
	DWARF2_CIE_DATA_ALIGNMENT): Define.
	(ppc_cfi_frame_initial_instructions, tc_ppc_regname_to_dw2regnum): New
	prototypes.
	(ppc_cie_data_alignment): Declare.
	* config/tc-ppc.c: Include dw2gencfi.h.
	(ppc_cie_data_alignment): Define.
	(md_begin): Initialize ppc_cie_data_alignment.
	(ppc_cfi_frame_initial_instructions, tc_ppc_regname_to_dw2regnum): New
	functions.
	* config/tc-s390.h (DWARF2_LINE_MIN_INSN_LENGTH): Define always.
	(TARGET_USE_CFIPOP, tc_cfi_frame_initial_instructions,
	tc_regname_to_dw2regnum, DWARF2_DEFAULT_RETURN_COLUMN,
	DWARF2_CIE_DATA_ALIGNMENT): Define.
	(s390_cfi_frame_initial_instructions, tc_s390_regname_to_dw2regnum):
	New prototypes.
	(s390_cie_data_alignment): Declare.
	* config/tc-s390.c: Include dw2gencfi.h.
	(s390_cie_data_alignment): Define.
	(md_begin): Initialize s390_cie_data_alignment.
	(s390_cfi_frame_initial_instructions, tc_s390_regname_to_dw2regnum):
	New functions.

	* gas/cfi/cfi-ppc-1.s: New test.
	* gas/cfi/cfi-ppc-1.d: New test.
	* gas/cfi/cfi-s390-1.s: New test.
	* gas/cfi/cfi-s390-1.s: New test.
	* gas/cfi/cfi-s390x-1.s: New test.
	* gas/cfi/cfi-s390x-1.s: New test.
	* gas/cfi/cfi.exp: Run them.
@
text
@d5745 1
a5745 1
		&& (val & (0x3f << 26)) == (56 << 26))
@


1.77
log
@Correct spelling of "relocatable".
@
text
@d27 1
a27 1

d189 3
d1214 2
d5926 46
@


1.76
log
@	* config/tc-ppc.c (ppc_cleanup): Use bytes to count APUinfo slots.
@
text
@d3864 1
a3864 1
   relocateable symbol reference.  The size of the value to store
@


1.75
log
@	* config/tc-ppc.c (ppc_csect): Pass alignment to ppc_change_csect.
	(ppc_change_csect): Add align param.  Align frag at start of csect.
	(ppc_section, ppc_named_section): Adjust ppc_change_csect calls.
	(ppc_frob_section): Align vma.
@
text
@d1345 1
a1345 1
    md_number_to_chars (p, (valueT) ppc_apuinfo_num, 4);
@


1.74
log
@	* config/tc-ppc.c (ppc_elf_suffix): Don't remove symbols other than
	".TOC." from PPC64_TOC relocs.
@
text
@d114 1
a114 1
static void ppc_change_csect PARAMS ((symbolS *));
d3009 1
d3024 1
a3024 2
  ppc_change_csect (sym);

d3028 1
a3028 1
      symbol_get_tc (sym)->align = get_absolute_expression ();
d3031 2
d3039 1
a3039 1
ppc_change_csect (sym)
d3041 1
d3051 2
d3058 1
d3073 1
d3101 2
a3102 2
      subseg_new (segment_name (S_GET_SEGMENT (sym)),
		  symbol_get_tc (sym)->subseg);
d3109 6
d3118 1
a3118 1
      symbol_get_tc (sym)->align = 2;
d3156 1
a3156 1
  ppc_change_csect (sym);
d3193 1
a3193 1
  ppc_change_csect (sym);
d5063 1
a5063 1
  static bfd_size_type vma = 0;
d5065 1
@


1.73
log
@	* config/tc-ppc.c (md_apply_fix3): Allow BRTAKEN, BRNTAKEN relocs.
@
text
@d1616 2
a1617 1
	    && exp_p->X_op == O_symbol)
d1619 2
a1620 3
	    /* This reloc type ignores the symbol.  Change the symbol
	       so that the dummy .TOC. symbol can be omitted from the
	       object file.  */
@


1.72
log
@Add "attn", "lq" and "stq" power4 insns.
@
text
@d5736 6
@


1.71
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d2450 1
a2450 1
	      && (operand->flags & PPC_OPERAND_DS) != 0)
d5717 1
a5717 1
	    unsigned long val;
d5720 1
a5720 1
	      val = bfd_getb16 (where);
d5722 7
a5728 2
	      val = bfd_getl16 (where);
	    val |= (value & 0xfffc);
@


1.70
log
@gas/

2003-05-03  H.J. Lu <hjl@@gnu.org>

	* config/obj-elf.c (obj_elf_parse_section_letters): Make it a
	fatal error for unknown section attribute.

	* config/tc-alpha.c (alpha_elf_section_letter): Return -1 for
	unknown section attribute.
	* config/tc-ia64.c (ia64_elf_section_letter): Likewise.
	* config/tc-ppc.c (ppc_section_letter): Likewise.

	* config/tc-ia64.c (ia64_elf_section_letter): Handle 'o'.
	(ia64_elf_section_type): Accept "unwind".

gas/testsuite/

2003-05-03  H.J. Lu <hjl@@gnu.org>

	* gas/ia64/ia64.exp: Add unwind.

	* gas/ia64/unwind.s: New. Test the new section attribute 'o'
	and the new section type "unwind".
	* gas/ia64/unwind.d: Likewise.
@
text
@a239 2
  { "file",	(void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  { "loc",	dwarf2_directive_loc, 0 },
@


1.69
log
@	* config/tc-ppc.c (md_show_usage): Mention -a32, -a64, -l, -le, -b,
	-be and split strings to below 509 bytes in length.
@
text
@d2757 1
a2757 1
  return 0;
@


1.68
log
@Add '+' and '-' as valid symbol characters for PPC port.
@
text
@d1067 2
d1075 1
a1075 1
-m403, -m405            generate code for PowerPC 403/405\n\
d1077 2
a1078 1
			generate code For PowerPC 7400/7410/7450/7455\n\
d1084 3
d1088 2
a1089 2
-mcom			generate code Power/PowerPC common instructions\n\
-many			generate code for any architecture (PWR/PWRX/PPC)\n\
a1091 3
  fprintf (stream, _("\
-me500, -me500x2	generate code for Motorola e500 core complex\n\
-mspe			generate code for Motorola SPE instructions\n"));
d1097 1
a1097 1
-mlittle, -mlittle-endian\n\
d1099 2
a1100 1
-mbig, -mbig-endian	generate code for a big endian machine\n\
@


1.68.2.1
log
@	* config/tc-hppa.c (hppa_symbol_chars): Revert 2003-04-28 change.
	* config/tc-hppa.h (tc_symbol_chars): Likewise.
	* config/tc-ppc.c (ppc_symbol_chars): Revert 2003-04-24 change.
	* config/tc-ppc.h (tc_symbol_chars): Likewise.
	* app.c (do_scrub_chars): Revert 2003-04-23 and 2003-04-22 changes.
@
text
@d185 4
@


1.67
log
@	* config/tc-ppc.c (md_apply_fix3): Generate ADDR16 relocs.
@
text
@d185 4
@


1.66
log
@	* config/tc-ppc.c (ppc_elf_suffix): Undo part of last change so that
	x@@toc+off works.
@
text
@d5525 1
a5525 2
	       && operand->shift == 0
	       && ppc_is_toc_sym (fixP->fx_addsy))
d5527 3
a5529 1
	  fixP->fx_r_type = BFD_RELOC_PPC_TOC16;
d5531 3
a5533 3
	  if (ppc_obj64
	      && (operand->flags & PPC_OPERAND_DS) != 0)
	    fixP->fx_r_type = BFD_RELOC_PPC64_TOC16_DS;
d5535 10
@


1.65
log
@	* config/tc-ppc.c (mapping): Handle new TLS reloc specs.
	(ppc_elf_suffix): Don't warn for x+off@@got when ppc64 and don't
	accept x@@got+off etc.
	(md_assemble): Handle TLS relocs.
	(ppc_force_relocation): Force for all TLS relocs.
	(ppc_fix_adjustable): Likewise.
	(md_apply_fix3): Handle TLS relocs.
@
text
@d1583 9
d1593 2
a1594 6
	    if (exp_p->X_add_number != 0
		&& (reloc == (int) BFD_RELOC_16_GOTOFF
		    || reloc == (int) BFD_RELOC_LO16_GOTOFF
		    || reloc == (int) BFD_RELOC_HI16_GOTOFF
		    || reloc == (int) BFD_RELOC_HI16_S_GOTOFF))
	      as_warn (_("identifier+constant@@got means identifier@@got+constant"));
d1596 3
a1598 2
	    /* Now check for identifier@@suffix+constant.  */
	    if (*str == '-' || *str == '+')
d1600 3
a1602 2
		char *orig_line = input_line_pointer;
		expressionS new_exp;
d1604 2
a1605 11
		input_line_pointer = str;
		expression (&new_exp);
		if (new_exp.X_op == O_constant)
		  {
		    exp_p->X_add_number += new_exp.X_add_number;
		    str = input_line_pointer;
		  }

		if (&input_line_pointer != str_p)
		  input_line_pointer = orig_line;
	      }
@


1.64
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d1463 68
a1530 42
    MAP ("l",		(int) BFD_RELOC_LO16),
    MAP ("h",		(int) BFD_RELOC_HI16),
    MAP ("ha",		(int) BFD_RELOC_HI16_S),
    MAP ("brtaken",	(int) BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",	(int) BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",		(int) BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",	(int) BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",	(int) BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",	(int) BFD_RELOC_HI16_S_GOTOFF),
    MAP ("fixup",	(int) BFD_RELOC_CTOR), /* warning with -mrelocatable */
    MAP ("plt",		(int) BFD_RELOC_24_PLT_PCREL),
    MAP ("pltrel24",	(int) BFD_RELOC_24_PLT_PCREL),
    MAP ("copy",	(int) BFD_RELOC_PPC_COPY),
    MAP ("globdat",	(int) BFD_RELOC_PPC_GLOB_DAT),
    MAP ("local24pc",	(int) BFD_RELOC_PPC_LOCAL24PC),
    MAP ("local",	(int) BFD_RELOC_PPC_LOCAL24PC),
    MAP ("pltrel",	(int) BFD_RELOC_32_PLT_PCREL),
    MAP ("plt@@l",	(int) BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",	(int) BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",	(int) BFD_RELOC_HI16_S_PLTOFF),
    MAP ("sdarel",	(int) BFD_RELOC_GPREL16),
    MAP ("sectoff",	(int) BFD_RELOC_16_BASEREL),
    MAP ("sectoff@@l",	(int) BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",	(int) BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",	(int) BFD_RELOC_HI16_S_BASEREL),
    MAP ("naddr",	(int) BFD_RELOC_PPC_EMB_NADDR32),
    MAP ("naddr16",	(int) BFD_RELOC_PPC_EMB_NADDR16),
    MAP ("naddr@@l",	(int) BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP ("naddr@@h",	(int) BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP ("naddr@@ha",	(int) BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP ("sdai16",	(int) BFD_RELOC_PPC_EMB_SDAI16),
    MAP ("sda2rel",	(int) BFD_RELOC_PPC_EMB_SDA2REL),
    MAP ("sda2i16",	(int) BFD_RELOC_PPC_EMB_SDA2I16),
    MAP ("sda21",	(int) BFD_RELOC_PPC_EMB_SDA21),
    MAP ("mrkref",	(int) BFD_RELOC_PPC_EMB_MRKREF),
    MAP ("relsect",	(int) BFD_RELOC_PPC_EMB_RELSEC16),
    MAP ("relsect@@l",	(int) BFD_RELOC_PPC_EMB_RELST_LO),
    MAP ("relsect@@h",	(int) BFD_RELOC_PPC_EMB_RELST_HI),
    MAP ("relsect@@ha",	(int) BFD_RELOC_PPC_EMB_RELST_HA),
    MAP ("bitfld",	(int) BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP ("relsda",	(int) BFD_RELOC_PPC_EMB_RELSDA),
    MAP ("xgot",	(int) BFD_RELOC_PPC_TOC16),
d1533 18
a1550 10
    MAP ("higher",	- (int) BFD_RELOC_PPC64_HIGHER),
    MAP ("highera",	- (int) BFD_RELOC_PPC64_HIGHER_S),
    MAP ("highest",	- (int) BFD_RELOC_PPC64_HIGHEST),
    MAP ("highesta",	- (int) BFD_RELOC_PPC64_HIGHEST_S),
    MAP ("tocbase",	- (int) BFD_RELOC_PPC64_TOC),
    MAP ("toc",		- (int) BFD_RELOC_PPC_TOC16),
    MAP ("toc@@l",	- (int) BFD_RELOC_PPC64_TOC16_LO),
    MAP ("toc@@h",	- (int) BFD_RELOC_PPC64_TOC16_HI),
    MAP ("toc@@ha",	- (int) BFD_RELOC_PPC64_TOC16_HA),
    { (char *) 0, 0,	(int) BFD_RELOC_UNUSED }
d1582 1
a1582 9
	if (exp_p->X_add_number != 0
	    && (reloc == (int) BFD_RELOC_16_GOTOFF
		|| reloc == (int) BFD_RELOC_LO16_GOTOFF
		|| reloc == (int) BFD_RELOC_HI16_GOTOFF
		|| reloc == (int) BFD_RELOC_HI16_S_GOTOFF))
	  as_warn (_("identifier+constant@@got means identifier@@got+constant"));

	/* Now check for identifier@@suffix+constant.  */
	if (*str == '-' || *str == '+')
d1584 6
a1589 2
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;
d1591 2
a1592 3
	    input_line_pointer = str;
	    expression (&new_exp);
	    if (new_exp.X_op == O_constant)
d1594 13
a1606 2
		exp_p->X_add_number += new_exp.X_add_number;
		str = input_line_pointer;
a1607 3

	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
d2403 19
d2483 17
d5359 4
d5377 2
d5714 42
@


1.63
log
@Fix the merging of .PPC.EMB.apuinfo sections.  Add a test to make sure that
the fix continues to work.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d5259 1
a5259 1
  return S_FORCE_RELOC (fix->fx_addsy);
a5280 2
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
d5286 1
a5286 1
  return S_FORCE_RELOC (fix->fx_addsy);
@


1.62
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1333 1
a1333 1
			   SEC_HAS_CONTENTS | SEC_READONLY | SEC_MERGE);
@


1.61
log
@	* config/tc-ppc.c (ppc_cleanup): Make 'i' unsigned int.
@
text
@d50 1
a50 1
#define TARGET_REG_NAMES_P true
d52 1
a52 1
#define TARGET_REG_NAMES_P false
d86 1
a86 1
static boolean reg_names_p = TARGET_REG_NAMES_P;
d88 1
a88 1
static boolean register_name PARAMS ((expressionS *));
d606 1
a606 1
static boolean
d621 1
a621 1
    return false;
d638 1
a638 1
      return true;
d643 1
a643 1
  return false;
d651 1
a651 1
static boolean cr_operand;
d719 1
a719 1
#define SOLARIS_P true
d721 1
a721 1
#define SOLARIS_P false
d724 1
a724 1
static boolean msolaris = SOLARIS_P;
d799 2
a800 2
/* 
 * We keep a list of APUinfo 
d894 2
a895 2
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	          | PPC_OPCODE_601 | PPC_OPCODE_32;
d905 3
a907 3
               || strcmp (arg, "405") == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
                  | PPC_OPCODE_403 | PPC_OPCODE_32;
d909 5
a913 5
               || strcmp (arg, "7410") == 0
               || strcmp (arg, "7450") == 0
               || strcmp (arg, "7455") == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
                  | PPC_OPCODE_ALTIVEC | PPC_OPCODE_32;
d915 6
a920 6
        {
          if (ppc_cpu == 0)
            ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_ALTIVEC;
          else
            ppc_cpu |= PPC_OPCODE_ALTIVEC;
        }
d923 5
a927 4
	  ppc_cpu = PPC_OPCODE_PPC  | PPC_OPCODE_BOOKE    | PPC_OPCODE_SPE
		  | PPC_OPCODE_ISEL | PPC_OPCODE_EFS      | PPC_OPCODE_BRLOCK
		  | PPC_OPCODE_PMR  | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI;
        }
d943 2
a944 2
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
                    | PPC_OPCODE_64_BRIDGE | PPC_OPCODE_64;
d954 2
a955 2
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE |
		    PPC_OPCODE_BOOKE64 | PPC_OPCODE_64;
d959 2
a960 2
	  ppc_cpu = PPC_OPCODE_PPC| PPC_OPCODE_CLASSIC
                    | PPC_OPCODE_64 | PPC_OPCODE_POWER4;
d972 1
a972 1
	reg_names_p = true;
d975 1
a975 1
	reg_names_p = false;
d1012 1
a1012 1
	  msolaris = true;
d1018 1
a1018 1
	  msolaris = false;
d1120 6
a1125 6
        {
          if (default_cpu[7] == '6' && default_cpu[8] == '4')
            ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
          else
            ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
        }
d1201 1
a1201 1
  boolean dup_insn = false;
d1248 1
a1248 1
	      dup_insn = true;
d1267 1
a1267 1
	      dup_insn = true;
d1349 2
a1350 2
        p = frag_more (4);
        md_number_to_chars (p, (valueT) ppc_apuinfo_list[i], 4);
d1972 1
a1972 1
    
d2276 1
a2276 1
		cr_operand = true;
d2278 1
a2278 1
	      cr_operand = false;
d2495 1
a2495 1
        ppc_apuinfo_section_add (PPC_APUINFO_SPE, 1);
d2497 1
a2497 1
        ppc_apuinfo_section_add (PPC_APUINFO_ISEL, 1);
d2499 1
a2499 1
        ppc_apuinfo_section_add (PPC_APUINFO_EFS, 1);
d2501 1
a2501 1
        ppc_apuinfo_section_add (PPC_APUINFO_BRLOCK, 1);
d2503 1
a2503 1
        ppc_apuinfo_section_add (PPC_APUINFO_PMR, 1);
d2505 1
a2505 1
        ppc_apuinfo_section_add (PPC_APUINFO_CACHELCK, 1);
d2507 1
a2507 1
        ppc_apuinfo_section_add (PPC_APUINFO_RFMCI, 1);
d2763 1
a2763 1
static boolean ppc_stab_symbol;
d3206 1
a3206 1
  ppc_stab_symbol = true;
d3208 1
a3208 1
  ppc_stab_symbol = false;
d3937 1
a3937 1
              double word aligned
d3941 1
a3941 1
              a - don't know -- maybe a misprint
d3973 1
a3973 1
              double word aligned
d3977 1
a3977 1
              a - don't know -- maybe a misprint
d4007 1
a4007 1
              double word aligned (4-byte)
d4045 1
a4045 1
              double word aligned
d4075 1
a4075 1
              performed.
d4090 1
a4090 1
              Issue a IMAGE_REL_PPC_IFGLUE relocation against it, using
d4652 1
a4652 1
static boolean ppc_saw_abs;
d4795 1
a4795 1
	  ppc_saw_abs = true;
d4963 1
a4963 1
  ppc_saw_abs = false;
@


1.60
log
@Do not count FAKE operands when deciding if any operands have been skipped.
@
text
@d1326 1
a1326 1
    int i;
@


1.59
log
@gas reloc rewrite.
@
text
@d2072 2
d2090 6
d2099 1
a2099 1
	  if (opcount < strlen (opcode->operands))
@


1.58
log
@	* config/tc-ppc.c (ppc_frob_symbol): Formatting, warning fix.
	(ppc_fix_adjustable <coff version>): Cleanup.
@
text
@d4666 4
d5250 1
a5250 1
  return 0;
d5256 26
a5292 2
	  && ! S_IS_EXTERNAL (fix->fx_addsy)
	  && ! S_IS_WEAK (fix->fx_addsy)
d5321 1
a5321 11
      /* `*valuep' may contain the value of the symbol on which the reloc
	 will be based; we have to remove it.  */
      if (symbol_used_in_reloc_p (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != absolute_section
	  && S_GET_SEGMENT (fixP->fx_addsy) != undefined_section
	  && ! bfd_is_com_section (S_GET_SEGMENT (fixP->fx_addsy)))
	value -= S_GET_VALUE (fixP->fx_addsy);

      /* FIXME: Why '+'?  Better yet, what exactly is '*valuep'
	 supposed to be?  I think this is related to various similar
	 FIXMEs in tc-i386.c and tc-sparc.c.  */
d5328 1
a5328 1
  /* FIXME FIXME FIXME: The value we are passed in *valuep includes
d5333 1
a5333 1
     use *valuep since bfd_install_relocation is not being used.
d5335 2
a5336 2
     *valuep, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valuep since it includes the
d5345 4
d5350 2
a5351 12
      value = fixP->fx_offset;
      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
	  else
	    {
	      /* We can't actually support subtracting a symbol.  */
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("expression too complex"));
	    }
	}
a5352 1
#endif
@


1.57
log
@	* config/tc-ppc.c (PPC_HIGHER, PPC_HIGHEST): Fix warning.
	(md_parse_option): No -a64 without BFD64.
	(ppc_set_cpu): Select appropriate cpu when ppc_obj64.
	(ppc_arch): Use bfd_mach_rs6k for bfd_arch_rs6000.
@
text
@d4878 4
a4881 4
      S_SET_VALUE (sym,
		   ((valueT)
		    coffsymbol (symbol_get_bfdsym
				(symbol_get_tc (sym)->within))->native));
d5107 6
a5112 1
  valueT val;
a5113 2
  resolve_symbol_value (fix->fx_addsy);
  val = S_GET_VALUE (fix->fx_addsy);
a5114 1
      && fix->fx_addsy != (symbolS *) NULL
d5116 1
a5116 1
      && S_GET_SEGMENT (fix->fx_addsy) == data_section
d5127 3
a5129 1
	  if (symbol_get_tc (sy)->class == XMC_TC0)
d5131 1
a5131 1
	  if (symbol_get_tc (sy)->class != XMC_TC)
d5133 1
a5133 2
	  resolve_symbol_value (sy);
	  if (val == S_GET_VALUE (sy))
d5146 5
a5150 5
  if (fix->fx_addsy != (symbolS *) NULL
      && symbol_get_tc (fix->fx_addsy)->subseg == 0
      && symbol_get_tc (fix->fx_addsy)->class != XMC_TC0
      && symbol_get_tc (fix->fx_addsy)->class != XMC_TC
      && S_GET_SEGMENT (fix->fx_addsy) != bss_section
d5152 1
a5152 1
      && (S_GET_SEGMENT (fix->fx_addsy) != data_section
d5159 1
d5161 1
a5161 1
      if (S_GET_SEGMENT (fix->fx_addsy) == text_section)
d5163 1
a5163 1
      else if (S_GET_SEGMENT (fix->fx_addsy) == data_section)
d5173 2
a5174 3
	  while (symbol_get_tc (csect)->next != (symbolS *) NULL
		 && (symbol_get_frag (symbol_get_tc (csect)->next)->fr_address
		     <= val))
d5180 2
a5181 2
	      if ((symbol_get_frag (csect)->fr_address == val)
		  && S_GET_VALUE (csect) == S_GET_VALUE (fix->fx_addsy))
d5201 1
a5201 1
	      csect = symbol_get_tc (csect)->next;
d5204 1
a5204 2
	  fix->fx_offset += (S_GET_VALUE (fix->fx_addsy)
			     - symbol_get_frag (csect)->fr_address);
d5207 1
d5212 1
a5212 2
  if (fix->fx_addsy != (symbolS *) NULL
      && S_GET_SEGMENT (fix->fx_addsy) == bss_section
d5215 4
a5218 5
      resolve_symbol_value (symbol_get_frag (fix->fx_addsy)->fr_symbol);
      fix->fx_offset +=
	(S_GET_VALUE (fix->fx_addsy)
	 - S_GET_VALUE (symbol_get_frag (fix->fx_addsy)->fr_symbol));
      fix->fx_addsy = symbol_get_frag (fix->fx_addsy)->fr_symbol;
@


1.56
log
@Do not insert non-BookE32 instructions into the hash table if the target cpu
is the BookE32. (case 107575)
@
text
@d71 1
a71 1
#define PPC_HIGHER(v) (((v) >> 32) & 0xffff)
d78 1
a78 1
#define PPC_HIGHEST(v) (((v) >> 48) & 0xffff)
d870 7
a876 1
	ppc_obj64 = 1;
d1109 4
a1112 2
      if (strncmp (default_os, "aix", 3) == 0
	  && default_os[3] >= '4' && default_os[3] <= '9')
d1158 6
a1163 1
  return ppc_obj64 ? bfd_mach_ppc64 : bfd_mach_ppc;
@


1.55
log
@2002-08-21  Elena Zannoni  <ezannoni@@redhat.com>

        * config/tc-ppc.c (ppc_cleanup): Do something only if format
        is ELF.
        (ppc_apuinfo_section_add): Define only if format is ELF.
        (md_assemble): Emit APUinfo section only if format is ELF.
        Fix formatting.
@
text
@d1210 8
@


1.54
log
@2002-08-19  Elena Zannoni  <ezannoni@@redhat.com>

        From matthew green  <mrg@@redhat.com>

        * config/tc-ppc.c (PPC_OPCODE_CLASSIC): Enable this everywhere
        PPC_OPCODE_PPC is, except for BookE architectures.
        (md_parse_option): Add support for -mspe.
        (md_show_usage): Add -mspe.
        (md_parse_option): Add support for -me500 and
        -me500x2 to generate code for Motorola e500 core complex.
        (md_show_usage): Add -me500 and -me500x2.

        (PPC_APUINFO_ISEL, PPC_APUINFO_PMR, PPC_APUINFO_RFMCI,
        PPC_APUINFO_CACHELCK, PPC_APUINFO_SPE, PPC_APUINFO_EFS,
        PPC_APUINFO_BRLOCK): New macros.

        (ppc_cleanup): New function.
        (ppc_apuinfo_section_add): New function.
        (APUID): New macro.
        (md_assemble): Collect info and write the APUinfo section.

        * config/tc-ppc.h (md_cleanup): Define.
        (ppc_cleanup): Export.
        (ELF_TC_SPECIAL_SECTIONS): Add .PPC.EMB.apuinfo section.
@
text
@d133 1
a133 1
static void ppc_apuinfo_section_add PARAMS((unsigned int apu, unsigned int version));
d1284 1
d1338 1
d1938 1
d1941 1
a1941 1
ppc_apuinfo_section_add(apu, version)
d1948 1
a1948 1
    if (ppc_apuinfo_list[i] == APUID(apu, version))
d1966 1
a1966 1
  ppc_apuinfo_list[ppc_apuinfo_num++] = APUID(apu, version);
d1969 1
d2456 1
d2465 1
a2465 1
        ppc_apuinfo_section_add(PPC_APUINFO_SPE, 1);
d2467 1
a2467 1
        ppc_apuinfo_section_add(PPC_APUINFO_ISEL, 1);
d2469 1
a2469 1
        ppc_apuinfo_section_add(PPC_APUINFO_EFS, 1);
d2471 1
a2471 1
        ppc_apuinfo_section_add(PPC_APUINFO_BRLOCK, 1);
d2473 1
a2473 1
        ppc_apuinfo_section_add(PPC_APUINFO_PMR, 1);
d2475 1
a2475 1
        ppc_apuinfo_section_add(PPC_APUINFO_CACHELCK, 1);
d2477 1
a2477 1
        ppc_apuinfo_section_add(PPC_APUINFO_RFMCI, 1);
d2479 1
@


1.53
log
@	* config/tc-ppc.c (md_apply_fix3): Adjust 16 bit XCOFF reloc offset.
@
text
@d133 1
d791 14
d888 2
a889 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_601 | PPC_OPCODE_32;
d896 1
a896 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_32;
d900 2
a901 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_403 | PPC_OPCODE_32;
d906 2
a907 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC | PPC_OPCODE_32;
d911 1
a911 1
            ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC;
d915 13
d932 1
a932 1
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64;
d936 2
a937 1
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64_BRIDGE | PPC_OPCODE_64;
d941 3
a943 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32;
d952 2
a953 1
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4;
d1075 3
d1111 6
a1116 6
	{
	  if (default_cpu[7] == '6' && default_cpu[8] == '4')
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64;
	  else
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_32;
	}
d1281 58
d1936 32
a2091 1

d2451 23
@


1.52
log
@	* config/tc-ppc.c (ppc_set_cpu): Use PPC_OPCODE_64 as the default
	rather than PPC_OPCODE_32 for powerpc64*.
@
text
@d5226 8
a5233 1
	fixP->fx_r_type = BFD_RELOC_PPC_B16;
d5241 8
a5248 1
	fixP->fx_r_type = BFD_RELOC_PPC_BA16;
@


1.51
log
@	* config/tc-ppc.c (ppc_elf_frob_symbol): Delete.
	(ppc_frob_file_before_adjust): New function.
	* config/tc-ppc.h (tc_frob_symbol): Don't define.
	(ppc_elf_frob_symbol): Don't declare.
	(tc_frob_file_before_adjust): Define.
	(ppc_frob_file_before_adjust): Declare.
@
text
@d1073 6
a1078 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_32;
@


1.51.2.1
log
@	* config/tc-ppc.c (ppc_set_cpu): Use PPC_OPCODE_64 as the default
	rather than PPC_OPCODE_32 for powerpc64*.
@
text
@d1073 1
a1073 6
	{
	  if (default_cpu[7] == '6' && default_cpu[8] == '4')
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64;
	  else
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_32;
	}
@


1.51.2.2
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* write.c: Delete set_segment_vma and prototype. Update all callers.

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (tc_i386_fix_adjustable): Handle
	BFD_RELOC_386_TLS_IE and BFD_RELOC_386_TLS_GOTIE.
	(BFD_RELOC_386_TLS_IE, BFD_RELOC_386_TLS_GOTIE): Define to 0
	if not defined.
	(lex_got): Handle @@GOTNTPOFF and @@INDNTPOFF.
	(md_apply_fix3, tc_gen_reloc): Handle BFD_RELOC_386_TLS_IE and
	BFD_RELOC_386_TLS_GOTIE.

	2002-09-16  Chris Demetriou  <cgd@@broadcom.com>
	* config/tc-mips.c (IS_SEXT_32BIT_NUM): Move closer to top of file.
	(IS_SEXT_16BIT_NUM): New macro.
	(macro_build_ldst_constoffset): New function, to build a set of
	instructions to do a load or store from a constant offset relative
	to a given register.
	(macro, s_cprestore): Use macro_build_ldst_constoffset to implement
	.cprestore pseudo-op.

	2002-09-16  Elias Athanasopoulos  <eathan@@otenet.gr>
	* dwarf2dbg.c (out_debug_abbrev): Add support for the DW_AT_name field.
	(out_debug_info): Likewise.

	2002-09-13  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_assemble): Do not count FAKE operands
	when deciding if any operands have been skipped.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (md_apply_fix3): Allow addend for
	BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_386_TLS_LE and
	BFD_RELOC_386_TLS_LE_32.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-09-04  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_begin): Do not insert non-BookE32
	instructions into the hash table if the target cpu is the BookE32.

	2002-08-20  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (macro2): Implement rotates by zero using shifts
	by zero.

	2002-08-15  Alexandre Oliva  <aoliva@@redhat.com>
	* config/tc-mips.c (macro_build_jalr): Make sure we generate
	the fix-up against on the right frag.
	(s_cpsetup): Likewise.  Parse third argument as expression, to
	handle global symbols and forward/backward labels correctly.

	2002-08-14  Nick Clifton  <nickc@@redhat.com>
	* read.c (stringer): Catch attempts to create strings in the abs
	section.

	2002-08-12  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (mips_ip): Don't work out the value of
	constant %hi()s here.

	2002-08-10  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_i386_fix_adjustable): Test OUTPUT_FLAVOR
	for ELF, and don't bother checking ELF relocs when non-ELF.
	(i386_immediate): Allow absolute_section expressions for aout.
	(i386_displacement): Likewise.  Also test bfd_is_com_section.
	(md_estimate_size_before_relax): Test OUTPUT_FLAVOR for ELF.
	(md_apply_fix3): Hack for bfd_install_relocation when fx_pcrel,
	not when fx_addsy.  Remove dead code.

	2002-08-06  George France <france@@handhelds.org>
	* config/tc-alpha.c (cpu_types): Enabled ev67, ev68,  -m21264a
	and m21264b processor names and cpu types.
	* doc/c-alpha.texi: Documented new types.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-ppc.c (md_apply_fix3): Adjust 16 bit XCOFF reloc offset.

	2002-08-03  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (output_insn): Save frag_now and frag_now_fix ()
	at start of insn, pass it to output_disp and output_imm.
	(output_disp): Added arguments.  If _GLOBAL_OFFSET_TABLE_ is seen
	in displacement for R_386_32 reloc, use R_386_GOTPC and compute
	properly addend.
	(output_imm): Added arguments.  Compute properly addend for
	R_386_GOTPC.
	(md_apply_fix3): Remove R_386_GOTPC handling.

	2002-07-31  Momchil Velikov  <velco@@fadata.bg>
	* config/tc-v850.c (md_assemble): Fix range check for immediate
	operand.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".
@
text
@a1171 8
	  /* Certain instructions (eg: extsw) do not exist in the
	     32-bit BookE instruction set, but they do exist in the
	     64-bit BookE instruction set, and other PPC instruction
	     sets.  Check to see if the opcode has the BOOKE64 flag set.
	     If it does make sure that the target CPU is not the BookE32.  */
	  && ((op->flags & PPC_OPCODE_BOOKE64) == 0
	      || (ppc_cpu & PPC_OPCODE_BOOKE64) == PPC_OPCODE_BOOKE64
	      || (ppc_cpu & PPC_OPCODE_BOOKE) == 0)
a1918 2
	  unsigned int num_operands_expected;
	  unsigned int i;
a1934 6
	  /* Compute the number of expected operands.
	     Do not count fake operands.  */
	  for (num_operands_expected = 0, i = 0; opcode->operands[i]; i ++)
	    if ((powerpc_operands [opcode->operands[i]].flags & PPC_OPERAND_FAKE) == 0)
	      ++ num_operands_expected;

d1938 1
a1938 1
	  if (opcount < num_operands_expected)
d5226 1
a5226 8
	{
	  fixP->fx_r_type = BFD_RELOC_PPC_B16;
#ifdef OBJ_XCOFF
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
#endif
	}
d5234 1
a5234 8
	{
	  fixP->fx_r_type = BFD_RELOC_PPC_BA16;
#ifdef OBJ_XCOFF
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
#endif
	}
@


1.51.2.3
log
@	Merge from mainline.
	2002-09-04  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-ppc.c (PPC_HIGHER, PPC_HIGHEST): Fix warning.
	(md_parse_option): No -a64 without BFD64.
	(ppc_set_cpu): Select appropriate cpu when ppc_obj64.
	(ppc_arch): Use bfd_mach_rs6k for bfd_arch_rs6000.
@
text
@d71 1
a71 1
#define PPC_HIGHER(v) (((v) >> 16 >> 16) & 0xffff)
d78 1
a78 1
#define PPC_HIGHEST(v) (((v) >> 24 >> 24) & 0xffff)
d855 1
a855 7
	{
#ifdef BFD64
	  ppc_obj64 = 1;
#else
	  as_fatal (_("%s unsupported"), "-a64");
#endif
	}
d1065 2
a1066 4
      if (ppc_obj64)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64;
      else if (strncmp (default_os, "aix", 3) == 0
	       && default_os[3] >= '4' && default_os[3] <= '9')
d1112 1
a1112 6
  if (ppc_obj64)
    return bfd_mach_ppc64;
  else if (ppc_arch () == bfd_arch_rs6000)
    return bfd_mach_rs6k;
  else
    return bfd_mach_ppc;
@


1.50
log
@	* config/tc-ppc.c (md_pseudo_table): Warning fix.
	(ppc_cpu): Make it unsigned long to agree with struct powerpc_opcode
	flags.
	(ppc_size): Delete.
	(ppc_xcoff64): Rename to ppc_obj64.
	(md_parse_option <m>): Encode old ppc_size value in ppc_cpu.
	(ppc_set_cpu): Set PPC_OPCODE_32 too.
	(ppc_arch): Use ppc_obj64 instead of ppc_size to select bfd_mach_ppc64
	or bfd_mach_ppc.
	(ppc_target_format): Use ppc_obj64 to select format.
	(md_begin): Adjust for PPC_OPCODE_32/64 in ppc_cpu.
	(ppc_insert_operand): Use ppc_obj64 instead of ppc_size.
	(ppc_elf_suffix): Likewise.  Don't depend on BFD_DEFAULT_TARGET_SIZE.
	(tc_frob_symbol): Likewise.
	(md_assemble): Use ppc_obj64 instead of ppc_size.  Don't depend on
	BFD_DEFAULT_TARGET_SIZE.
	(ppc_tc): Likewise.
	(ppc_is_toc_sym): Likewise.
	(md_apply_fix3): Likewise.
	* config/tc-ppc.h (TC_FORCE_RELOCATION): Don't depend on
	BFD_DEFAULT_TARGET_SIZE.
	(ELF_TC_SPECIAL_SECTIONS): Likewise.
	(tc_frob_symbol): Likewise.
@
text
@d1691 5
a1695 4
/* Don't emit .TOC. symbol.  */
int
ppc_elf_frob_symbol (sym)
     symbolS *sym;
d1697 4
a1700 1
  const char *name;
d1702 1
a1702 2
  name = S_GET_NAME (sym);
  if (name != NULL && strcmp (name, ".TOC.") == 0)
d1704 24
a1727 2
      S_CLEAR_EXTERNAL (sym);
      return 1;
d1730 4
a1733 1
  return 0;
@


1.49
log
@Change default csect alignment to 4 bytes.
@
text
@d235 1
a235 1
  { "file",	dwarf2_directive_file, 0 },
d698 1
a698 1
static int ppc_cpu = 0;
d700 2
a701 8
/* The size of the processor we are assembling for.  This is either
   PPC_OPCODE_32 or PPC_OPCODE_64.  */
static unsigned long ppc_size = (BFD_DEFAULT_TARGET_SIZE == 64
				 ? PPC_OPCODE_64
				 : PPC_OPCODE_32);

/* Whether to target xcoff64.  */
static int ppc_xcoff64 = 0;
d855 1
a855 1
	ppc_xcoff64 = 1;
d857 1
a857 1
	ppc_xcoff64 = 0;
a862 3
      /* Most CPU's are 32 bit.  Exceptions are listed below.  */
      ppc_size = PPC_OPCODE_32;

d866 1
a866 1
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_POWER2;
d869 1
a869 1
	ppc_cpu = PPC_OPCODE_POWER;
d873 1
a873 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_601;
d880 1
a880 1
	ppc_cpu = PPC_OPCODE_PPC;
d884 1
a884 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_403;
d889 1
a889 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC;
a901 1
	  ppc_size = PPC_OPCODE_64;
a905 1
	  ppc_size = PPC_OPCODE_64;
d909 1
a909 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE;
a914 1
	  ppc_size = PPC_OPCODE_64;
a918 1
	  ppc_size = PPC_OPCODE_64;
d924 1
a924 1
	ppc_cpu = PPC_OPCODE_COMMON;
d927 1
a927 1
	ppc_cpu = PPC_OPCODE_ANY;
d1067 1
a1067 1
	ppc_cpu = PPC_OPCODE_COMMON;
d1069 1
a1069 1
	ppc_cpu = PPC_OPCODE_POWER;
d1071 1
a1071 1
	ppc_cpu = PPC_OPCODE_POWER;
d1073 1
a1073 1
	ppc_cpu = PPC_OPCODE_PPC;
d1107 1
a1107 1
  return ppc_size == PPC_OPCODE_64 ? 620 : 0;
d1120 1
a1120 1
    return (ppc_xcoff64 ? "aix5coff64-rs6000" : "aixcoff-rs6000");
d1122 1
a1122 1
    return (ppc_xcoff64 ? "aixcoff64-rs6000" : "aixcoff-rs6000");
a1126 2
  boolean is64 = BFD_DEFAULT_TARGET_SIZE == 64 && ppc_size == PPC_OPCODE_64;

d1128 2
a1129 2
	  ? (is64 ? "elf64-powerpc" : "elf32-powerpc")
	  : (is64 ? "elf64-powerpcle" : "elf32-powerpcle"));
d1162 1
a1162 1
      if ((op->flags & ppc_cpu) != 0
d1164 2
a1165 1
	      || (op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64)) == ppc_size
d1261 1
a1261 1
	  if (ppc_size == PPC_OPCODE_32)
d1303 1
a1303 1
      insn = (*operand->insert) (insn, (long) val, ppc_cpu | ppc_size, &errmsg);
d1380 2
a1381 1
#if BFD_DEFAULT_TARGET_SIZE == 64
a1390 1
#endif
d1416 1
a1416 1
	if (BFD_DEFAULT_TARGET_SIZE == 64 && reloc < 0)
d1418 1
a1418 1
	    if (ppc_size != PPC_OPCODE_64)
d1449 1
a1449 2
	if (BFD_DEFAULT_TARGET_SIZE == 64
	    && reloc == (int) BFD_RELOC_PPC64_TOC
a1690 1
#if BFD_DEFAULT_TARGET_SIZE == 64
a1706 1
#endif
d1938 1
a1938 1
	  insn = (*operand->insert) (insn, 0L, ppc_cpu | ppc_size, &errmsg);
d1951 1
a1951 1
	      insn = (*operand->insert) (insn, 0L, ppc_cpu | ppc_size, &errmsg);
a2136 1
#if BFD_DEFAULT_TARGET_SIZE == 64
a2163 1
#endif /* BFD_DEFAULT_TARGET_SIZE == 64 */
d2195 1
a2195 2
	  if (BFD_DEFAULT_TARGET_SIZE == 64
	      && ppc_size == PPC_OPCODE_64
a2344 1
#if BFD_DEFAULT_TARGET_SIZE == 64
a2349 1
#endif
d3633 1
a3633 1
  align = BFD_DEFAULT_TARGET_SIZE == 64 && ppc_size == PPC_OPCODE_64 ? 3 : 2;
d3643 1
a3643 1
      cons ((ppc_size == PPC_OPCODE_64) ? 8 : 4);
d3649 1
a3649 1
   accept this directive on the first line of input and set ppc_size
d3673 1
a3673 1
  if (BFD_DEFAULT_TARGET_SIZE == 64 && ppc_size == PPC_OPCODE_64)
d5151 1
a5151 1
	  && (operand->insert == NULL || ppc_xcoff64)
d5210 1
a5210 2
	  if (BFD_DEFAULT_TARGET_SIZE == 64
	      && ppc_size == PPC_OPCODE_64
d5245 1
a5245 1
	  if (BFD_DEFAULT_TARGET_SIZE == 64 && ppc_size == PPC_OPCODE_64)
a5297 1
#if BFD_DEFAULT_TARGET_SIZE == 64
a5301 1
#endif
a5336 1
#if BFD_DEFAULT_TARGET_SIZE == 64
a5393 1
#endif
a5458 1
#if BFD_DEFAULT_TARGET_SIZE == 64
a5463 1
#endif
@


1.48
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@a1122 8
#ifdef OBJ_XCOFF
int
ppc_subseg_align ()
{
  return ppc_xcoff64 ? 3 : 2;
}
#endif

d2831 1
a2831 1
      symbol_get_tc (sym)->align = (ppc_xcoff64) ? 3 : 2;
@


1.47
log
@	* config/obj-coff.h: Fix formatting.
	* config/tc-mcore.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-openrisc.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-xstormy16.h: Likewise.
@
text
@d2488 1
a2488 1
  *ptr_msg = _("Bad .section directive: want a,e,w,x,M,S in string");
@


1.46
log
@	* config/tc-ppc.c (mapping): Map sectoff to BFD_RELOC_16_BASEREL.
	(ppc_elf_validate_fix): Replace BFD_RELOC_32_BASEREL with
	BFD_RELOC_16_BASEREL.
	(md_assemble): Likewise.
	(md_apply_fix3): Likewise.
@
text
@d924 1
a924 1
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | 
d3217 1
a3217 1
 
d3238 1
a3238 1
  if (saved_bi_sym) 
d3243 1
a3243 1
  
d3310 1
a3310 1
  if (ei) 
@


1.45
log
@Add AIX 64 shared library support and emulation layer for binutils
@
text
@d1381 1
a1381 1
    MAP ("sectoff",	(int) BFD_RELOC_32_BASEREL),
d1690 1
a1690 1
	  && fixp->fx_r_type != BFD_RELOC_32_BASEREL
d2243 1
a2243 1
		case BFD_RELOC_32_BASEREL:
a5286 1
	case BFD_RELOC_32_BASEREL:
d5311 1
@


1.44
log
@	* doc/c-ppc.texi (PowerPC-Opts): Add -mpower4 and -maltivec.
	Remove references to chip manufacturers.
	* config/tc-ppc.c (md_parse_option): Handle -mpower4 option.
	Correct comments.
	(md_show_usage): Remove references to chip manufacturers.  Mention
	-mpower4.
	(md_begin): Test power4 opcode flag bits.
@
text
@d1140 5
a1144 1
  return ppc_xcoff64 ? "aixcoff64-rs6000" : "aixcoff-rs6000";
@


1.43
log
@Fix minimal-toc with -maix64
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d879 1
a879 1
      /* -m601 means to assemble for the Motorola PowerPC 601, which includes
d884 1
a884 1
	 Motorola PowerPC 603/604.  */
d890 1
a890 1
      /* -m403 and -m405 mean to assemble for the Motorola PowerPC 403/405.  */
d928 5
d1035 3
a1037 3
-mpwrx, -mpwr2		generate code for IBM POWER/2 (RIOS2)\n\
-mpwr			generate code for IBM POWER (RIOS1)\n\
-m601			generate code for Motorola PowerPC 601\n\
d1039 2
a1040 2
			generate code for Motorola PowerPC 603/604\n\
-m403, -m405            generate code for Motorola PowerPC 403/405\n\
d1042 2
a1043 2
			generate code For Motorola PowerPC 7400/7410/7450/7455\n\
-mppc64, -m620		generate code for Motorola PowerPC 620\n\
d1047 1
d1184 4
a1187 1
	      || (ppc_cpu & PPC_OPCODE_64_BRIDGE) != 0))
@


1.42
log
@[gas/ChangeLog]
* config/tc-ppc.c (md_parse_option): BookE is not Motorola specific.

[include/opcode/ChangeLog]
* ppc.h (PPC_OPCODE_BOOKE): BookE is not Motorola specific.
(PPC_OPCODE_BOOKE64): Likewise.
@
text
@d5168 1
a5168 1
	  && operand->insert == NULL
@


1.42.2.1
log
@Fix minimal toc and 64 bit.
@
text
@d5168 1
a5168 1
 	  && (operand->insert == NULL || ppc_xcoff64)
@


1.42.2.2
log
@	* doc/c-ppc.texi (PowerPC-Opts): Add -mpower4, -maltivec and -m7400.
	Remove references to chip manufacturers.
	* config/tc-ppc.c (md_parse_option): Handle -mpower4 option.
	Correct comments.
	(md_show_usage): Remove references to chip manufacturers.  Mention
	-mpower4.
	(md_begin): Test power4 opcode flag bits.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d879 1
a879 1
      /* -m601 means to assemble for the PowerPC 601, which includes
d884 1
a884 1
	 PowerPC 603/604.  */
d890 1
a890 1
      /* -m403 and -m405 mean to assemble for the PowerPC 403/405.  */
a927 5
      else if (strcmp (arg, "power4") == 0)
	{
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4;
	  ppc_size = PPC_OPCODE_64;
	}
d1030 3
a1032 3
-mpwrx, -mpwr2		generate code for POWER/2 (RIOS2)\n\
-mpwr			generate code for POWER (RIOS1)\n\
-m601			generate code for PowerPC 601\n\
d1034 2
a1035 2
			generate code for PowerPC 603/604\n\
-m403, -m405            generate code for PowerPC 403/405\n\
d1037 2
a1038 2
			generate code For PowerPC 7400/7410/7450/7455\n\
-mppc64, -m620		generate code for PowerPC 620/625/630\n\
a1041 1
-mpower4		generate code for Power4 architecture\n\
d1178 1
a1178 4
	      || (ppc_cpu & PPC_OPCODE_64_BRIDGE) != 0)
	  && ((op->flags & (PPC_OPCODE_POWER4 | PPC_OPCODE_NOPOWER4)) == 0
	      || ((op->flags & PPC_OPCODE_POWER4)
		  == (ppc_cpu & PPC_OPCODE_POWER4))))
d5168 1
a5168 1
	  && (operand->insert == NULL || ppc_xcoff64)
@


1.42.2.3
log
@Merge from mainline
@
text
@d1377 1
a1377 1
    MAP ("sectoff",	(int) BFD_RELOC_16_BASEREL),
d1686 1
a1686 1
	  && fixp->fx_r_type != BFD_RELOC_16_BASEREL
d2239 1
a2239 1
		case BFD_RELOC_16_BASEREL:
d5283 1
a5307 1
	case BFD_RELOC_16_BASEREL:
@


1.41
log
@* config/tc-ppc.c (md_parse_option): Make -maltivec default
to generating PowerPC instructions.
@
text
@d1040 2
a1041 2
-mbooke64		generate code for 64-bit Motorola BookE\n\
-mbooke, mbooke32	generate code for 32-bit Motorola BookE\n\
@


1.40
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d900 6
a905 1
	ppc_cpu |= PPC_OPCODE_ALTIVEC;
@


1.39
log
@binutils/ChangeLog
	* doc/binutils.texi (objdump): Document ppc -M options.
gas/ChangeLog
	* config/tc-ppc.c (ppc_insert_operand): Pass (ppc_cpu | ppc_size)
	to operand->insert.
	(md_assemble): Likewise.
gas/testsuite/ChangeLog
	* gas/ppc/booke.d: Modify reloc and target matches for powerpc64.
include/opcode/ChangeLog
	* ppc.h (struct powerpc_operand <insert, extract>): Add dialect param.
opcodes/ChangeLog
	* ppc-opc.c (PPC64): Revert 2001-10-12. Do include PPC_OPCODE_PPC.
	(insert_bat, extract_bat, insert_bba, extract_bba,
	insert_bd, extract_bd, insert_bdm, extract_bdm,
	insert_bdp, extract_bdp, valid_bo,
	insert_bo, extract_bo, insert_boe, extract_boe,
	insert_ds, extract_ds, insert_de, extract_de,
	insert_des, extract_des, insert_li, extract_li,
	insert_mbe, extract_mbe, insert_mb6, extract_mb6,
	insert_nb, extract_nb, insert_nsi, extract_nsi,
	insert_ral, insert_ram, insert_ras,
	insert_rbs, extract_rbs, insert_sh6, extract_sh6,
	insert_spr, extract_spr, insert_tbr, extract_tbr): Add dialect param.
	(extract_bd, extract_bdm, extract_bdp,
	extract_ds, extract_des,
	extract_li, extract_nsi): Implement sign extension without conditional.
	(insert_bdm, extract_bdm,
	insert_bdp, extract_bdp, valid_bo): Handle 64 bit branch hints.
	(extract_bdm, extract_bdp): Correct 32 bit validation.
	(AT1_MASK, AT2_MASK): Define.
	(BBOAT_MASK): Define.
	(BBOATCB_MASK, BBOAT2CB_MASK, BBOATBI_MASK): Define.
	(BOFM64, BOFP64, BOTM64, BOTP64): Define.
	(BODNZM64, BODNZP64, BODZM64, BODZP64): Define.
	(PPCCOM32, PPCCOM64): Define.
	(powerpc_opcodes): Modify existing 32 bit insns with branch hints
	and add new patterns to implement 64 bit branches with hints.  Move
	booke instructions so they match before ppc64.
	* ppc-dis.c (powerpc_dialect): Set PPC_OPCODE_64 in dialect for
	64 bit default targets, and parse "32" and "64" in options.
	Formatting fixes.
	(print_insn_powerpc): Pass dialect to operand->extract.
@
text
@d2315 1
a2315 1
     md_apply_fix.  */
d5083 4
a5086 4
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
d5089 1
a5089 1
  valueT value;
d5092 1
a5092 2
  value = *valuep;
  if (fixp->fx_addsy != NULL)
d5096 5
a5100 5
      if (symbol_used_in_reloc_p (fixp->fx_addsy)
	  && S_GET_SEGMENT (fixp->fx_addsy) != absolute_section
	  && S_GET_SEGMENT (fixp->fx_addsy) != undefined_section
	  && ! bfd_is_com_section (S_GET_SEGMENT (fixp->fx_addsy)))
	value -= S_GET_VALUE (fixp->fx_addsy);
d5105 2
a5106 2
      if (fixp->fx_pcrel)
	value += fixp->fx_frag->fr_address + fixp->fx_where;
d5109 1
a5109 3
    {
      fixp->fx_done = 1;
    }
d5121 6
a5126 7
  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    value = *valuep;
d5129 2
a5130 2
      value = fixp->fx_offset;
      if (fixp->fx_subsy != (symbolS *) NULL)
d5132 2
a5133 2
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixp->fx_subsy);
d5137 1
a5137 1
	      as_bad_where (fixp->fx_file, fixp->fx_line,
d5144 1
a5144 1
  if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
d5151 1
a5151 1
      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
d5164 5
a5168 5
	  && fixp->fx_addsy != NULL
	  && symbol_get_tc (fixp->fx_addsy)->subseg != 0
	  && symbol_get_tc (fixp->fx_addsy)->class != XMC_TC
	  && symbol_get_tc (fixp->fx_addsy)->class != XMC_TC0
	  && S_GET_SEGMENT (fixp->fx_addsy) != bss_section)
d5170 2
a5171 2
	  value = fixp->fx_offset;
	  fixp->fx_done = 1;
d5177 1
a5177 1
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
d5183 1
a5183 1
				 fixp->fx_file, fixp->fx_line);
d5189 3
a5191 5
      if (fixp->fx_done)
	{
	  /* Nothing else to do here.  */
	  return 1;
	}
d5193 1
a5193 1
      assert (fixp->fx_addsy != NULL);
d5201 1
a5201 1
	fixp->fx_r_type = BFD_RELOC_PPC_B26;
d5205 1
a5205 1
	fixp->fx_r_type = BFD_RELOC_PPC_B16;
d5209 1
a5209 1
	fixp->fx_r_type = BFD_RELOC_PPC_BA26;
d5213 1
a5213 1
	fixp->fx_r_type = BFD_RELOC_PPC_BA16;
d5218 1
a5218 1
	       && ppc_is_toc_sym (fixp->fx_addsy))
d5220 1
a5220 1
	  fixp->fx_r_type = BFD_RELOC_PPC_TOC16;
d5225 1
a5225 1
	    fixp->fx_r_type = BFD_RELOC_PPC64_TOC16_DS;
d5227 1
a5227 1
	  fixp->fx_size = 2;
d5229 1
a5229 1
	    fixp->fx_where += 2;
d5239 2
a5240 2
	  if (expr_symbol_where (fixp->fx_addsy, &sfile, &sline))
	    as_bad_where (fixp->fx_file, fixp->fx_line,
d5243 1
a5243 1
	    as_bad_where (fixp->fx_file, fixp->fx_line,
d5245 3
a5247 3
			  S_GET_NAME (fixp->fx_addsy));
	  fixp->fx_done = 1;
	  return 1;
d5253 1
a5253 1
      ppc_elf_validate_fix (fixp, seg);
d5255 1
a5255 1
      switch (fixp->fx_r_type)
d5263 2
a5264 2
	  if (fixp->fx_pcrel)
	    fixp->fx_r_type = BFD_RELOC_32_PCREL;
d5271 1
a5271 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5277 2
a5278 2
	  if (fixp->fx_pcrel)
	    fixp->fx_r_type = BFD_RELOC_64_PCREL;
d5282 1
a5282 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5317 1
a5317 1
	  if (fixp->fx_pcrel)
d5319 2
a5320 2
	      if (fixp->fx_addsy != NULL)
		as_bad_where (fixp->fx_file, fixp->fx_line,
d5322 2
a5323 2
			      bfd_get_reloc_code_name (fixp->fx_r_type),
			      S_GET_NAME (fixp->fx_addsy));
d5325 1
a5325 1
		as_bad_where (fixp->fx_file, fixp->fx_line,
d5327 1
a5327 1
			      bfd_get_reloc_code_name (fixp->fx_r_type));
d5330 1
a5330 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5338 1
a5338 1
	  if (fixp->fx_pcrel)
d5340 1
a5340 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5345 1
a5345 1
	  if (fixp->fx_pcrel)
d5347 1
a5347 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5354 1
a5354 1
	  if (fixp->fx_pcrel)
d5356 1
a5356 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5361 1
a5361 1
	  if (fixp->fx_pcrel)
d5363 1
a5363 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5368 1
a5368 1
	  if (fixp->fx_pcrel)
d5370 1
a5370 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5375 1
a5375 1
	  if (fixp->fx_pcrel)
d5377 1
a5377 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5392 1
a5392 1
	  if (fixp->fx_pcrel)
d5395 1
a5395 1
	    unsigned char *where = fixp->fx_frag->fr_literal + fixp->fx_where;
d5414 1
a5414 1
	  if (fixp->fx_pcrel)
d5417 1
a5417 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where
d5423 1
a5423 1
	  if (fixp->fx_pcrel)
d5426 1
a5426 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5432 1
a5432 1
	  if (!fixp->fx_pcrel && !fixp->fx_done)
d5435 1
a5435 1
	  if (fixp->fx_done)
d5442 1
a5442 1
	      where = fixp->fx_frag->fr_literal + fixp->fx_where;
d5448 1
a5448 1
		as_bad_where (fixp->fx_file, fixp->fx_line,
d5452 1
a5452 1
		as_bad_where (fixp->fx_file, fixp->fx_line,
d5464 5
a5468 5
	  fixp->fx_done = 0;
	  if (fixp->fx_addsy
	      && !S_IS_DEFINED (fixp->fx_addsy)
	      && !S_IS_WEAK (fixp->fx_addsy))
	    S_SET_WEAK (fixp->fx_addsy);
d5472 1
a5472 1
	  fixp->fx_done = 0;
d5480 1
a5480 1
	  fixp->fx_done = 0;
d5486 1
a5486 1
		   _("Gas failure, reloc value %d\n"), fixp->fx_r_type);
d5493 1
a5493 1
  fixp->fx_addnumber = value;
d5495 2
a5496 2
  if (fixp->fx_r_type != BFD_RELOC_PPC_TOC16)
    fixp->fx_addnumber = 0;
d5500 1
a5500 1
      fixp->fx_addnumber = 0;
d5504 2
a5505 2
      fixp->fx_addnumber =
	- bfd_get_section_vma (stdoutput, S_GET_SEGMENT (fixp->fx_addsy));
a5508 2

  return 1;
@


1.38
log
@[gas/ChangeLog]
	* config/tc-ppc.c (md_show_usage): Add missing -maltivec, -m7400,
	-m7410, -m7450 and -m7455 options.

[gas/testsuite/ChangeLog]
	* gas/ppc/altivec.s: New test for AltiVec.
	* gas/ppc/altivec.d: New file.
	* gas/ppc/ppc.exp: Test altivec.s

[include/opcode/ChangeLog]
	* ppc.h (PPC_OPCODE_BOOKE64): Fix typo.

[opcodes/ChangeLog]
	* ppc-opc.c (STRM): New AltiVec operand.
	(XDSS): New AltiVec instruction form.
	(mtvscr): Correct operand list.
	(dst, dstt, dstst, dststt, dss, dssall): AltiVec instructions.
@
text
@d1307 1
a1307 1
      insn = (*operand->insert) (insn, (long) val, &errmsg);
d1945 1
a1945 1
	  insn = (*operand->insert) (insn, 0L, &errmsg);
d1958 1
a1958 1
	      insn = (*operand->insert) (insn, 0L, &errmsg);
@


1.37
log
@	* config/tc-ppc.c (PPC_HA, PPC_HIGHERA, PPC_HIGHESTA): Simplify.
	(ppc_size): Select PPC_OPCODE_64 if 64 bit.
	(md_begin): Don't set ppc_size here.
	(ppc_target_format): Test ppc_size as well as BFD_DEFAULT_TARGET_SIZE.
	(md_shortopts): Constify.
	(md_longopts): Likewise.
	(md_longopts_size): Likewise.
	(ppc_elf_suffix): Only allow 64-bit relocs when ppc_size specifies
	64-bit opcodes.
	(ppc_machine): Explain why this function is a nop.
@
text
@d1031 2
d1035 3
a1037 2
-mbooke64               generate code for 64-bit Motorola BookE\n\
-mbooke, mbooke32       generate code for 32-bit Motorola BookE\n\
@


1.36
log
@[gas/ChangeLog]
	* config/tc-ppc.c (md_parse_option): New -m7410, -m7450 and -m7455
	flags, equivalent to -m7400.  New -maltivec to enable AltiVec
	instructions.  New -mbook64 and -mbooke/-mbooke32 flags to enable
	64-bit and 32-bit BookE support, respectively.  Change -m403 and
	-m405 to set PPC403 option.
	(md_show_usage): Adjust for new options.
	* doc/all.texi: Set PPC.
	* doc/as.texinfo: Add PPC support and pull in c-ppc.texi.
	* doc/c-ppc.texi: New file.
	* doc/Makefile.am (CPU_DOCS): Add c-ppc.texi.
	* doc/Makefile.in: Regenerate.

[gas/testsuite/ChangeLog]
	* gas/ppc/booke.s: New test for Motorola BookE.
	* gas/ppc/booke.d: New file.
	* gas/ppc/ppc.exp: Test booke.s.

[include/opcode/ChangeLog]
	* ppc.h (PPC_OPCODE_BOOKE, PPC_OPCODE_403): New opcode flags for
	BookE and PowerPC403 instructions.

[opcodes/ChangeLog]
	* ppc-opc.c (insert_de, extract_de, insert_des, extract_des): New
	instruction field instruction/extraction functions for new BookE
	DE form instructions.
	(CT): New macro for CT field in an X form instruction.
	(DE, DES, DEO, DE_MASK): New macros for DE/DES fields in DE form
	instructions.
	(PPC64): Don't include PPC_OPCODE_PPC.
	(403): New opcode macro for PPC403 processors.
	(BOOKE): New opcode macro for BookE processors.
	(bce, bcel, bcea, bcela, bclre, bclrel: New BookE instructions.
	(bcctre, bcctrel, be, bel, bea, bela, icbt, icbte, lwzxe): Likewise.
	(dcbste, lwzuxe, luxe, dcbfe, lbzxe, lwarxe, lbzuxe): Likewise.
	(stwcxe, stwxe, stxe, stwuxe, stuxe, stbxe, dcbtste, stbuxe): Likewise.
	(mfapidi, dcbte, lhzxe, lhzuxe, lhaxe, lhauxe, subfe64): Likewise.
	(subfeo64, adde64, addeo64, sthxe, sthuxe, subfze64): Likewise.
	(subfzeo64, addze64, addzeo64, dcbie, subfme64, subfmeo64): Likewise.
	(addme64, addmeo64, stdcxe., mcrxr64, lwbrxe, lfsxe, lfsuxe): Likewise.
	(lfdxe, lfduxe, stwbrxe, stfsxe, stfsuxe, stfdxe, dcbae): Likewise.
	(stfduxe, tlbivax, tlbivaxe, lhbrxe, ldxe, lduxe, tlbsx): Likewise.
	(tlbsxe, sthbrxe, stdxe, stduxe, icbie, stfiwxe, dcbze, lbze): Likewise.
	(lbzue, ldue, lhze, lhzue, lhae, lhaue, lwze, lwzue): Likewise.
	(stbe, stbue, sthe, sthue, stwe, stwue, lfse, lfsue, lfde): Likewise.
	(lfdue, stde, stdue, stfse, stfsue, stfde, stfdue): Likewise.

	* ppc-dis.c (print_insn_big_powerpc, print_insn_little_powerpc): Look
	for a disassembler option of `booke', `booke32' or `booke64' to enable
	BookE support in the disassembler.
@
text
@d68 1
a68 1
#define PPC_HA(v) ((((v) >> 16) + (((v) >> 15) & 1)) & 0xffff)
d75 1
a75 2
#define PPC_HIGHERA(v) \
  ((((v) >> 32) + (((v) & 0xffff8000) == 0xffff8000)) & 0xffff)
d81 2
a82 6
   compensating for #lo being treated as a signed number.
   Generate 0xffffffff8000 with arithmetic here, for portability.  */
#define PPC_HIGHESTA(v) \
  ((((v) >> 48)								      \
    + (((v) & (((valueT) 1 << 48) - 0x8000)) == ((valueT) 1 << 48) - 0x8000)) \
   & 0xffff)
d702 3
a704 1
static unsigned long ppc_size = PPC_OPCODE_32;
d799 1
a799 1
CONST char *md_shortopts = "b:l:usm:K:VQ:";
d801 1
a801 1
CONST char *md_shortopts = "um:";
d803 1
a803 1
struct option md_longopts[] = {
d806 1
a806 1
size_t md_longopts_size = sizeof (md_longopts);
d1130 2
d1133 2
a1134 2
	  ? (BFD_DEFAULT_TARGET_SIZE == 64 ? "elf64-powerpc" : "elf32-powerpc")
	  : (BFD_DEFAULT_TARGET_SIZE == 64 ? "elf64-powerpcle" : "elf32-powerpcle"));
a1153 5
  /* If we're going to generate a 64-bit ABI file, then we need
     the 64-bit capable instructions.  */
  if (BFD_DEFAULT_TARGET_SIZE == 64)
    ppc_size = PPC_OPCODE_64;

d1326 1
a1326 1
    bfd_reloc_code_real_type reloc;
d1334 1
a1334 1
  struct map_bfd *ptr;
d1338 43
a1380 43
  static struct map_bfd mapping[] = {
    MAP ("l",		BFD_RELOC_LO16),
    MAP ("h",		BFD_RELOC_HI16),
    MAP ("ha",		BFD_RELOC_HI16_S),
    MAP ("brtaken",	BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",	BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",		BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",	BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",	BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",	BFD_RELOC_HI16_S_GOTOFF),
    MAP ("fixup",	BFD_RELOC_CTOR),   /* warnings with -mrelocatable */
    MAP ("plt",		BFD_RELOC_24_PLT_PCREL),
    MAP ("pltrel24",	BFD_RELOC_24_PLT_PCREL),
    MAP ("copy",	BFD_RELOC_PPC_COPY),
    MAP ("globdat",	BFD_RELOC_PPC_GLOB_DAT),
    MAP ("local24pc",	BFD_RELOC_PPC_LOCAL24PC),
    MAP ("local",	BFD_RELOC_PPC_LOCAL24PC),
    MAP ("pltrel",	BFD_RELOC_32_PLT_PCREL),
    MAP ("plt@@l",	BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",	BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",	BFD_RELOC_HI16_S_PLTOFF),
    MAP ("sdarel",	BFD_RELOC_GPREL16),
    MAP ("sectoff",	BFD_RELOC_32_BASEREL),
    MAP ("sectoff@@l",	BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",	BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",	BFD_RELOC_HI16_S_BASEREL),
    MAP ("naddr",	BFD_RELOC_PPC_EMB_NADDR32),
    MAP ("naddr16",	BFD_RELOC_PPC_EMB_NADDR16),
    MAP ("naddr@@l",	BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP ("naddr@@h",	BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP ("naddr@@ha",	BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP ("sdai16",	BFD_RELOC_PPC_EMB_SDAI16),
    MAP ("sda2rel",	BFD_RELOC_PPC_EMB_SDA2REL),
    MAP ("sda2i16",	BFD_RELOC_PPC_EMB_SDA2I16),
    MAP ("sda21",	BFD_RELOC_PPC_EMB_SDA21),
    MAP ("mrkref",	BFD_RELOC_PPC_EMB_MRKREF),
    MAP ("relsect",	BFD_RELOC_PPC_EMB_RELSEC16),
    MAP ("relsect@@l",	BFD_RELOC_PPC_EMB_RELST_LO),
    MAP ("relsect@@h",	BFD_RELOC_PPC_EMB_RELST_HI),
    MAP ("relsect@@ha",	BFD_RELOC_PPC_EMB_RELST_HA),
    MAP ("bitfld",	BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP ("relsda",	BFD_RELOC_PPC_EMB_RELSDA),
    MAP ("xgot",	BFD_RELOC_PPC_TOC16),
d1382 9
a1390 9
    MAP ("higher",	BFD_RELOC_PPC64_HIGHER),
    MAP ("highera",	BFD_RELOC_PPC64_HIGHER_S),
    MAP ("highest",	BFD_RELOC_PPC64_HIGHEST),
    MAP ("highesta",	BFD_RELOC_PPC64_HIGHEST_S),
    MAP ("tocbase",	BFD_RELOC_PPC64_TOC),
    MAP ("toc",		BFD_RELOC_PPC_TOC16),
    MAP ("toc@@l",       BFD_RELOC_PPC64_TOC16_LO),
    MAP ("toc@@h",       BFD_RELOC_PPC64_TOC16_HI),
    MAP ("toc@@ha",      BFD_RELOC_PPC64_TOC16_HA),
d1392 1
a1392 1
    { (char *) 0,	0,	BFD_RELOC_UNUSED }
d1415 9
d1425 4
a1428 4
	    && (ptr->reloc == BFD_RELOC_16_GOTOFF
		|| ptr->reloc == BFD_RELOC_LO16_GOTOFF
		|| ptr->reloc == BFD_RELOC_HI16_GOTOFF
		|| ptr->reloc == BFD_RELOC_HI16_S_GOTOFF))
d1451 1
a1451 1
	    && ptr->reloc == BFD_RELOC_PPC64_TOC
d1460 1
a1460 1
	return ptr->reloc;
d3657 6
a3662 1
/* FIXME: `.machine' is a nop for the moment.  */
@


1.35
log
@Fix 2 xcoff line number problems
@
text
@a889 2
	       || strcmp (arg, "403") == 0
	       || strcmp (arg, "405") == 0
d893 8
a900 1
      else if (strcmp (arg, "7400") == 0)
d902 2
d908 1
a908 1
	  ppc_cpu = PPC_OPCODE_PPC;
d913 11
a923 1
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64_BRIDGE;
d1031 1
a1031 1
-mppc, -mppc32, -m403, -m405, -m603, -m604\n\
d1033 1
d1036 2
@


1.34
log
@	* config/tc-ppc.c (md_assemble <DS relocs>): Test ppc_size as well
	as BFD_DEFAULT_TARGET_SIZE.
	(ppc_tc): Likewise.
	(ppc_is_toc_sym): Likewise.
	(md_apply_fix3): Likewise.
@
text
@d3171 4
a3174 1
   ".bf".  */
d3193 8
d3234 2
a3235 1
   the symbol list.  */
d3264 6
@


1.33
log
@	* config/tc-ppc.c (md_apply_fix3 <BFD_RELOC_CTOR>): Make it 64
	bits if target is 64 bit.
@
text
@d2179 1
d3590 1
d3601 3
a3603 2
  frag_align (BFD_DEFAULT_TARGET_SIZE == 64 ? 3 : 2, 0, 0);
  record_alignment (now_seg, BFD_DEFAULT_TARGET_SIZE == 64 ? 3 : 2);
d3636 1
a3636 1
  if (BFD_DEFAULT_TARGET_SIZE == 64)
d5180 1
a5213 1
#if BFD_DEFAULT_TARGET_SIZE != 64
d5215 4
a5218 1
#endif
a5231 3
#if BFD_DEFAULT_TARGET_SIZE == 64
	case BFD_RELOC_CTOR:
#endif
d5233 1
@


1.32
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d5210 1
d5212 1
a5212 1
	  /* FIXME: 32 bits even for 64-bit targets?  */
d5226 3
@


1.31
log
@	* config/obj-elf.c (obj_elf_parse_section_letters): Use 'M' instead
	of 'm', 'S' instead of 's'.  Update bad_msg.
	* config/tc-ppc.c (ppc_section_letter): Update bad_msg.
	* config/tc-i370.c (i370_sectioN_letter): Update bad_msg.
@
text
@a23 1
#include <ctype.h>
d25 1
d621 1
a621 1
  if (name[0] == '%' && isalpha (name[1]))
d624 1
a624 1
  else if (!reg_names_p || !isalpha (name[0]))
d1386 1
a1386 1
	&& (isalnum (ch) || ch == '@@'));
d1389 1
a1389 1
      *str2++ = (islower (ch)) ? ch : tolower (ch);
d1823 1
a1823 1
  for (s = str; *s != '\0' && ! isspace (*s); s++)
d1846 1
a1846 1
  while (isspace (*str))
d2269 1
a2269 1
  while (isspace (*str))
d4270 1
a4270 2
	if (islower (*s))
	  *s = toupper (*s);
@


1.30
log
@	* configure.in: Recognise powerpc*le*, not just powerpcle*.
	* configure: Regenerate.
	* config/tc-ppc.c (PPC_LO, PPC_HI, PPC_HA, PPC_HIGHER,
	PPC_HIGHERA, PPC_HIGHEST, PPC_HIGHESTA, SEX16): New macros.
	(md_assemble): Use them.
	(ppc_machine): Support stub for ELF64 as well as XCOFF.
	(md_pseudo_table): Add "llong", "quad".
	(md_parse_option): Match default_cpu of powerpc*.
	(ppc_arch): Likewise.
	(ppc_subseg_align): Only for OBJ_XCOFF.
	(ppc_target_format): Return elf64-powerpc strings for 64 bit ELF.
	(md_begin): Select PPC_OPCODE_64 for 64 bit.
	(ppc_insert_operand): Don't bother testing 'file' before calling
	as_bad_where.  Use as_bad_where for operand->insert errors.
	(mapping): Add ELF64 relocation modifiers.
	(ppc_elf_suffix): Replace symbol on BFD_RELOC_PPC64_TOC reloc
	expressions with abs_symbol.
	(ppc_elf_cons): Correct offset for little endian targets.
	(ppc_elf_frob_symbol): New.
	(md_assemble): Add support for 64 bit ELF relocs.
	(ppc_tc): Ensure 8 byte alignment when 64 bit.
	(ppc_is_toc_sym): Only define for OBJ_XCOFF and OBJ_ELF.  Match
	".toc" section for 64 bit ELF.
	(ppc_fix_adjustable): New.  Macro body moved from tc-ppc.h.
	(md_apply_fix3): Silence warning with ATTRIBUTE_UNUSED.  Only do
	the ppc_is_toc_sym check for OBJ_XCOFF and OBJ_ELF.  For 64 bit,
	use BFD_RELOC_PPC64_TOC16_DS instead of BFD_RELOC_PPC_TOC16.
	Expand on comments, error message.  Add support for 64 bit relocs,
	and use PPC_HI etc. macros.
	* config/tc-ppc.h (MAX_MEM_FOR_RS_ALIGN_CODE): Define.
	(HANDLE_ALIGN): Define to generate nops in code sections rather
	than zeros.
	(TC_FORCE_RELOCATION): Force for BFD_RELOC_PPC64_TOC.
	(ELF_TC_SPECIAL_SECTIONS): Add 64 bit ELF sections.
	(tc_fix_adjustable): Move body of macro to tc-ppc.c.
	(ppc_fix_adjustable): Declare.
	(tc_frob_symbol): Define.
	(ppc_elf_frob_symbol): Declare.
@
text
@d2443 1
a2443 1
  *ptr_msg = _("Bad .section directive: want a,w,x,e in string");
@


1.29
log
@Revert 2001-08-08 changes.
@
text
@d56 35
d100 2
d104 2
a128 1
static void ppc_machine PARAMS ((int));
a228 1
  { "machine",  ppc_machine,    0 },
d232 2
d260 1
a260 1
  /* This pseudo-op is used even when not generating XCOFF output.  */
d262 2
d872 3
d1054 1
a1054 2
      else if (strcmp (default_cpu, "powerpc") == 0
	       || strcmp (default_cpu, "powerpcle") == 0)
d1078 1
a1078 2
      else if (strcmp (default_cpu, "powerpc") == 0
	       || strcmp (default_cpu, "powerpcle") == 0)
d1092 1
d1098 1
d1107 1
a1110 3
#ifdef TE_POWERMAC
  return "xcoff-powermac";
#endif
d1113 3
a1115 1
  return target_big_endian ? "elf32-powerpc" : "elf32-powerpcle";
d1135 5
d1281 1
a1281 4
	  if (file == (char *) NULL)
	    as_bad (err, buf, min, max);
	  else
	    as_bad_where (file, line, err, buf, min, max);
d1292 1
a1292 1
	as_bad (errmsg);
d1367 11
a1377 1

d1425 11
a1436 1
	*str_p = str;
d1447 1
a1447 1
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
d1473 4
a1476 3
	    as_bad (_("%s relocations do not fit in %d bytes\n"),
		    reloc_howto->name, nbytes);

d1479 2
a1480 2
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;
d1482 4
d1669 19
d2096 3
a2098 4
                   something which cleared it, we always produce a
                   signed value.  */
		if (ex.X_unsigned
		    && (operand->flags & PPC_OPERAND_SIGNED) == 0)
d2101 1
a2101 3
		  ex.X_add_number = (((ex.X_add_number & 0xffff)
				      ^ 0x8000)
				     - 0x8000);
d2105 4
a2108 1
		ex.X_add_number = (ex.X_add_number >> 16) & 0xffff;
d2112 26
a2137 3
		ex.X_add_number = ((((ex.X_add_number >> 16) & 0xffff)
				    + ((ex.X_add_number >> 15) & 1))
				   & 0xffff);
d2139 8
d2148 1
a2148 1
#endif
d2178 44
d2327 8
d3050 1
a3050 1
       would be to have the tc	field updated in ppc_symbol_new_hook.  */
a3485 8
ppc_machine(dummy)
    int dummy ATTRIBUTE_UNUSED;
{
    discard_rest_of_line();
   /* What does aix use this for?  */
}

static void
d3513 1
d3520 1
a3520 1
   TC.  The rest of the arguments are 4 byte values to actually put at
d3522 3
a3524 1
   relocateable symbol reference.
d3587 2
a3588 1
#else /* ! defined (OBJ_XCOFF) */
d3598 4
a3601 5
  /* Align to a four byte boundary.  */
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

#endif /* ! defined (OBJ_XCOFF) */
d3611 29
d5001 4
a5004 5
/* See whether a symbol is in the TOC section.  */

static int
ppc_is_toc_sym (sym)
     symbolS *sym;
d5006 15
a5020 4
#ifdef OBJ_XCOFF
  return symbol_get_tc (sym)->class == XMC_TC;
#else
  return strcmp (segment_name (S_GET_SEGMENT (sym)), ".got") == 0;
a5021 1
}
d5036 1
a5036 1
     segT seg;
d5109 4
a5112 7
      /* It appears that an instruction like
	     l 9,LC..1(30)
	 when LC..1 is not a TOC symbol does not generate a reloc.  It
	 uses the offset of LC..1 within its csect.  However, .long
	 LC..1 will generate a reloc.  I can't find any documentation
	 on how these cases are to be distinguished, so this is a wild
	 guess.  These cases are generated by gcc -mminimal-toc.  */
d5148 2
d5152 1
a5152 4
	 relocs.
	 FIXME: We need to handle the DS field at the very least.
	 FIXME: Selecting the reloc type is a bit haphazard; perhaps
	 there should be a new field in the operand table.  */
d5169 1
a5172 1
	       && fixp->fx_addsy != NULL
d5175 6
a5183 1
	  fixp->fx_r_type = BFD_RELOC_PPC_TOC16;
d5185 1
d5192 1
a5192 1
             symbol.  */
d5198 2
a5199 1
			  _("unsupported relocation type"));
d5211 2
a5213 1
	case BFD_RELOC_CTOR:
d5230 1
d5235 1
d5260 7
d5291 1
a5291 1
			      value >> 16, 2);
d5293 1
d5298 24
a5321 1
			      (value + 0x8000) >> 16, 2);
d5324 37
d5425 9
@


1.28
log
@	* config/tc-ppc.c (md_apply_fix3): Replace haphazard code for
	determining reloc type with code reading operands->reloc field.
@
text
@d4948 31
a4978 2
	 For other operand types, give an error.  */
      if (operand->reloc == 0)
d4984 1
a4984 1
	     symbol.  */
a4993 22

      fixp->fx_r_type = operand->reloc;

      if ((operand->flags & PPC_OPERAND_PARENS) != 0 && fixp->fx_addsy != NULL)
	{
	  /* For ld/st/la reloc types (`la' == load address).
	     Instruction with D or DS field.  */
	  if (ppc_is_toc_sym (fixp->fx_addsy))
	    {
	      fixp->fx_size = 2;
	      if (target_big_endian)
		fixp->fx_where += 2;
	    }
	  else
	    {
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("unsupported relocation against %s"),
			    S_GET_NAME (fixp->fx_addsy));
	      fixp->fx_done = 1;
	      return 1;
	    }
	}
a5019 1

a5023 1

a5073 1

@


1.27
log
@	* config/tc-ppc.c (ppc_elf_validate_fix): It's OK to have
	any kind of relocation against a not-loaded section.
@
text
@d4948 2
a4949 31
	 FIXME: We need to handle the DS field at the very least.
	 FIXME: Selecting the reloc type is a bit haphazard; perhaps
	 there should be a new field in the operand table.  */
      if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
	  && operand->bits == 26
	  && operand->shift == 0)
	fixp->fx_r_type = BFD_RELOC_PPC_B26;
      else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
	  && operand->bits == 16
	  && operand->shift == 0)
	fixp->fx_r_type = BFD_RELOC_PPC_B16;
      else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
	       && operand->bits == 26
	       && operand->shift == 0)
	fixp->fx_r_type = BFD_RELOC_PPC_BA26;
      else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
	       && operand->bits == 16
	       && operand->shift == 0)
	fixp->fx_r_type = BFD_RELOC_PPC_BA16;
      else if ((operand->flags & PPC_OPERAND_PARENS) != 0
	       && operand->bits == 16
	       && operand->shift == 0
	       && fixp->fx_addsy != NULL
	       && ppc_is_toc_sym (fixp->fx_addsy))
	{
	  fixp->fx_size = 2;
	  if (target_big_endian)
	    fixp->fx_where += 2;
	  fixp->fx_r_type = BFD_RELOC_PPC_TOC16;
	}
      else
d4955 1
a4955 1
             symbol.  */
d4965 22
d5013 1
d5018 1
d5069 1
@


1.26
log
@	* config/obj-elf.c (obj_elf_symver): Temporarily modify lex_type
	to include '@@' in symbol names when parsing versioned symbols
	rather than calling get_symbol_end multiple times.
	* config/tc-i370.c (register_name): Format fixes.  Don't call
	get_symbol_end after parsing number.
	* config/tc-mn10200.c (data_register_name): Format fixes.  Hoist
	code out of conditional.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-mn10300.c (r_register_name): Likewise.
	(xr_register_name): Likewise.
	(data_register_name): Likewise.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-ppc.c (register_name): Likewise.
	* config/tc-s390.c (register_name): Likewise.
@
text
@d1579 1
a1583 1
	  && strcmp (segment_name (seg), ".stab") != 0
@


1.25
log
@	* config/tc-ppc.c: Formatting fixes.
@
text
@d589 3
a600 2
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d603 4
a606 7
  else
    {
      /* Reset the line as if we had not done anything.  */
      *input_line_pointer = c;
      input_line_pointer = start;
      return false;
    }
@


1.24
log
@Fix for problem with default alignment of .comm
@
text
@d206 1
a206 1
  /* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format */
d228 3
a230 3
/* Predefined register names if -mregnames (or default for Windows NT).  */
/* In general, there are lots of them, in an attempt to be compatible */
/* with a number of other Windows NT assemblers.                      */
d558 1
a558 1
 * Summary of register_name().
d578 1
a578 1
  /* Find the spelling of the operand */
d589 1
a589 1
  /* look to see if it's in the register table */
d595 1
a595 1
      /* make the rest nice */
d598 2
a599 1
      *input_line_pointer = c;   /* put back the delimiting char */
d604 3
a606 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d670 1
a670 1
/* Whether to target xcoff64 */
d680 1
a680 1
/* What type of shared library support to use */
d683 1
a683 1
/* Flags to set in the elf header */
d787 1
a787 1
         sake, recognize -be also.  */
d810 1
a810 1
      /* Recognize -K PIC */
d834 1
a834 1
         (RIOS2).  */
d841 1
a841 1
         instructions that are holdovers from the Power.  */
d845 1
a845 1
         Motorola PowerPC 603/604.  */
d854 1
a854 1
        ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC;
d856 1
a856 1
         620.  */
d883 2
a884 1
      /* -mrelocatable/-mrelocatable-lib -- warn about initializations that require relocation */
d897 1
a897 1
      /* -memb, set embedded bit */
d901 3
a903 2
      /* -mlittle/-mbig set the endianess */
      else if (strcmp (arg, "little") == 0 || strcmp (arg, "little-endian") == 0)
d1016 2
a1017 1
	as_fatal (_("Unknown default cpu = %s, os = %s"), default_cpu, default_os);
d1049 1
a1049 1
  return (ppc_size == PPC_OPCODE_64) ? 620 : 0;
d1053 1
a1053 1
ppc_subseg_align()
d1055 1
a1055 1
  return (ppc_xcoff64) ? 3 : 2;
d1059 1
a1059 1
ppc_target_format()
d1063 1
a1063 1
  return (target_big_endian ? "pe-powerpc" : "pe-powerpcle");
d1066 1
a1066 1
  return (ppc_xcoff64 ? "aixcoff64-rs6000" : "aixcoff-rs6000");
d1073 1
a1073 1
  return (target_big_endian ? "elf32-powerpc" : "elf32-powerpcle");
d1116 1
a1116 1
	      /* Ignore Power duplicates for -m601 */
d1121 2
a1122 1
	      as_bad (_("Internal assembler error for instruction %s"), op->name);
d1150 2
a1151 1
  /* Tell the main code what the endianness is if it is not overidden by the user.  */
d1290 1
a1290 1
    MAP ("fixup",	BFD_RELOC_CTOR),		/* warnings with -mrelocatable */
d1324 1
a1324 1
    { (char *)0,	0,	BFD_RELOC_UNUSED }
d1354 1
a1354 1
	/* Now check for identifier@@suffix+constant */
d1379 2
a1380 3
/* Like normal .long/.short/.word, except support @@got, etc.  */
/* clobbers input_line_pointer, checks */
/* end-of-line.  */
d1399 2
a1400 1
	  && (reloc = ppc_elf_suffix (&input_line_pointer, &exp)) != BFD_RELOC_UNUSED)
d1402 5
a1406 2
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  int size = bfd_get_reloc_size (reloc_howto);
d1409 2
a1410 1
	    as_bad (_("%s relocations do not fit in %d bytes\n"), reloc_howto->name, nbytes);
d1417 2
a1418 1
	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size, &exp, 0, reloc);
d1426 2
a1427 1
  input_line_pointer--;		/* Put terminator back into stream.  */
d1439 1
a1439 1
  /* Just pretend this is .section .rodata */
d1446 1
a1446 1
/* Pseudo op to make file scope bss items */
d1448 1
a1448 1
ppc_elf_lcomm(xxx)
d1465 1
a1465 1
  /* just after name is now '\0' */
d1521 1
a1521 1
  /* allocate_bss: */
d1526 1
a1526 1
      /* convert to a power of 2 alignment */
d1605 1
a1605 1
 * Summary of parse_toc_entry().
d1638 1
a1638 1
parse_toc_entry(toc_kind)
d1646 1
a1646 1
  /* save the input_line_pointer */
d1649 1
a1649 1
  /* skip over the '[' , and whitespace */
d1653 1
a1653 1
  /* find the spelling of the operand */
d1657 1
a1657 1
  if (strcmp(toc_spec, "toc") == 0)
d1661 1
a1661 1
  else if (strcmp(toc_spec, "tocv") == 0)
d1665 1
a1665 1
  else if (strcmp(toc_spec, "toc32") == 0)
d1669 1
a1669 1
  else if (strcmp(toc_spec, "toc64") == 0)
d1676 2
a1677 2
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d1681 2
a1682 2
  /* now find the ']' */
  *input_line_pointer = c;   /* put back the delimiting char */
d1690 1
a1690 1
      input_line_pointer = start; /* reset input_line pointer */
d1694 1
a1694 1
  *toc_kind = t;             /* set return value */
d1861 23
a1883 23

	        lwz r4,[toc].GS.0.static_int(rtoc)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
	     The argument following the `]' must be a symbol name, and the
             register must be the toc register: 'rtoc' or '2'

	     The effect is to 0 as the displacement field
	     in the instruction, and issue an IMAGE_REL_PPC_TOCREL16 (or
	     the appropriate variation) reloc against it based on the symbol.
	     The linker will build the toc, and insert the resolved toc offset.

	     Note:
	     o The size of the toc entry is currently assumed to be
	       32 bits. This should not be assumed to be a hard coded
	       number.
	     o In an effort to cope with a change from 32 to 64 bits,
	       there are also toc entries that are specified to be
	       either 32 or 64 bits:
                 lwz r4,[toc32].GS.0.static_int(rtoc)
	         lwz r4,[toc64].GS.0.static_int(rtoc)
	       These demand toc entries of the specified size, and the
	       instruction probably requires it.
          */
d1889 2
a1890 2
	  /* go parse off the [tocXX] part */
	  valid_toc = parse_toc_entry(&toc_kind);
d1894 3
a1896 3
	      /* Note: message has already been issued.     */
	      /* FIXME: what sort of recovery should we do? */
	      /*        demand_rest_of_line(); return; ?    */
d1899 2
a1900 2
	  /* Now get the symbol following the ']' */
	  expression(&ex);
d1905 3
a1907 3
	      /* In this case, we may not have seen the symbol yet, since  */
	      /* it is allowed to appear on a .extern or .globl or just be */
	      /* a label in the .data section.                             */
d1911 8
a1918 7
	      /* 1. The symbol must be defined and either in the toc        */
	      /*    section, or a global.                                   */
	      /* 2. The reloc generated must have the TOCDEFN flag set in   */
	      /*    upper bit mess of the reloc type.                       */
	      /* FIXME: It's a little confusing what the tocv qualifier can */
	      /*        be used for. At the very least, I've seen three     */
	      /*        uses, only one of which I'm sure I can explain.     */
d1925 1
a1925 1
		      as_bad(_("[tocv] symbol is not a toc symbol"));
d1932 3
a1934 3
	      /* FIXME: these next two specifically specify 32/64 bit toc   */
	      /*        entries. We don't support them today. Is this the   */
	      /*        right way to say that?                              */
d1939 1
a1939 1
	      /* FIXME: see above */
d1945 2
a1946 2
		      _("Unexpected return value [%d] from parse_toc_entry!\n"),
		      toc_kind);
d1960 2
a1961 2
          /* Ok. We've set up the fixup for the instruction. Now make it
	     look like the constant 0 was found here */
d2036 2
a2037 2
	  /* For the absoulte forms of branchs, convert the PC relative form back into
	     the absolute.  */
d2133 1
a2133 1
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
d2138 1
d2148 5
a2152 2
	  fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset, size,
			      &fixups[i].exp, reloc_howto->pc_relative,
d2171 3
a2173 1
	fix_new_exp (frag_now, f - frag_now->fr_literal, 4,
d2177 1
a2177 1
		       (fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
d2262 1
a2262 1
/* For ELF, add support for SHF_EXCLUDE and SHT_ORDERED */
d2607 2
a2608 2
         changing subsegments, so that we don't use a lot of memory
         space for what may be a small section.  */
d2835 2
a2836 2
         fail at some later point, but this is probably the right
         thing to do here.  */
d2865 1
a2865 1
	  
d2869 1
a2869 1
      
d2873 1
a2873 1
       
d2875 1
a2875 1
       
d2879 3
a2881 3
       would be to have the tc	field updated in ppc_symbol_new_hook. */
    
    if (exp.X_op == O_symbol) 
d2886 1
a2886 1
  
d3448 1
a3448 1
/* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format */
d3462 2
a3463 2
   warnings:  "No previous section"
*/
d3465 1
a3465 1
ppc_previous(ignore)
d3472 1
a3472 1
      as_warn(_("No previous section to return to. Directive ignored."));
d3476 1
a3476 1
  subseg_set(ppc_previous_section, 0);
d3478 1
a3478 1
  ppc_set_current_section(ppc_previous_section);
d3494 1
a3494 1
   handling, debugging, etc.
a3495 1
*/
d3497 1
a3497 1
ppc_pdata(ignore)
d3512 1
a3512 1
      pdata_section = subseg_new(".pdata", 0);
d3514 1
a3514 1
  ppc_set_current_section(pdata_section);
d3529 2
a3530 2
   debugging, etc.
*/
d3532 1
a3532 1
ppc_ydata(ignore)
d3539 2
a3540 2
			 (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_READONLY | SEC_DATA ));
d3548 1
a3548 1
  ppc_set_current_section(ydata_section);
d3566 2
a3567 2
   function descriptors, etc.
*/
d3569 1
a3569 1
ppc_reldata(ignore)
d3577 2
a3578 2
			     ( SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_DATA ));
d3586 1
a3586 1
  ppc_set_current_section(reldata_section);
d3597 2
a3598 2
	      3 - double word aligned (that would be 4 byte boundary)
*/
d3600 1
a3600 1
ppc_rdata(ignore)
d3616 1
a3616 1
  ppc_set_current_section(rdata_section);
d3624 2
a3625 2
   warnings:  None
*/
d3627 1
a3627 1
ppc_ualong(ignore)
d3630 2
a3631 2
  /* try for long */
  cons ( 4 );
d3639 2
a3640 2
   warnings:  Missing symbol name
*/
d3642 1
a3642 1
ppc_znop(ignore)
a3648 1

a3649 2

  /* Strip out the symbol name */
d3657 1
d3673 1
a3673 1
  /* stick in the nop */
d3692 2
a3693 2
   warnings:
*/
d3695 1
a3695 1
ppc_pe_comm(lcomm)
d3708 1
a3708 1
  /* just after name is now '\0' */
d3827 1
a3827 1
  /* Strip out the section name */
d3870 2
a3871 1
    align = 4; /* default alignment to 16 byte boundary */
d3959 2
a3960 2
		  as_bad(_("unknown section attribute '%c'"),
			 *input_line_pointer);
d3972 1
a3972 1
  ppc_set_current_section(sec);
d3982 1
a3982 1
  bfd_set_section_alignment(stdoutput, sec, align);
d4016 1
a4016 1
      /* FIXME: section flags won't work */
d4019 1
a4019 1
			      | SEC_READONLY | SEC_DATA ));
d4028 1
a4028 1
  ppc_set_current_section(tocdata_section);
d4337 1
a4337 1
             ppc_adjust_symtab.  */
d4455 2
a4456 2
         BFD will do that for us if we set the right flags.  We have
         already set the value correctly.  */
d4730 3
a4732 3
                 have to look through the full symbol table to see
                 whether this is the csect we want.  Note that we will
                 only get here if the csect has zero length.  */
d4749 1
a4749 1
                     symbol, then this is the csect we want.  */
d5008 1
a5008 1
					/* fall through */
d5021 1
a5021 1
					/* fall through */
d5084 1
a5084 1
	     bytes, rather than 2, so offset it here appropriately */
d5108 3
a5110 3
	  {
	    char *where;
	    unsigned long insn;
d5112 21
a5132 21
	    /* Fetch the instruction, insert the fully resolved operand
	       value, and stuff the instruction back again.  */
	    where = fixp->fx_frag->fr_literal + fixp->fx_where;
	    if (target_big_endian)
	      insn = bfd_getb32 ((unsigned char *) where);
	    else
	      insn = bfd_getl32 ((unsigned char *) where);
	    if ((value & 3) != 0)
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("must branch to an address a multiple of 4"));
	    if ((offsetT) value < -0x40000000
		|| (offsetT) value >= 0x40000000)
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("@@local or @@plt branch destination is too far away, %ld bytes"),
			    value);
	    insn = insn | (value & 0x03fffffc);
	    if (target_big_endian)
	      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	    else
	      bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
	  }
d5149 2
a5150 2
		  _("Gas failure, reloc value %d\n"), fixp->fx_r_type);
	  fflush(stderr);
d5194 2
a5195 1
		    _("reloc %d not supported by object file format"), (int)fixp->fx_r_type);
@


1.23
log
@formatting change
@
text
@d2343 2
a2344 1
   symbols, and uses a different smclas.  */
d2386 1
a2386 1
	align = 3;
d2394 1
a2394 1
	      align = 3;
d2403 1
a2403 5
      if (size <= 1)
	align = 0;
      else if (size <= 2)
	align = 1;
      else if (size <= 4)
@


1.22
log
@Fix for gas seg fault and neg line numbers
@
text
@d2852 1
a2852 2
    /*
      In this case :
d2854 15
a2868 16
      .bs name
      .stabx	"z",arrays_,133,0
      .es
      
      .comm arrays_,13768,3
      
      resolve_symbol_value will copy the exp's "within" into sym's when the
      offset is 0.  Since this seems to be corner case problem,
      only do the correction for storage class C_STSYM.  A better solution
      would be to have the tc	field updated in ppc_symbol_new_hook.
      
    */

    if (exp.X_op == O_symbol) {
		symbol_get_tc (exp.X_add_symbol)->within = ppc_current_block;
    }
@


1.21
log
@	* symbols.c (resolve_symbol_value): Remove "finalize" param,
	instead use finalize_syms directly.  Don't treat expressions
	specially with regard to finalize_syms.  Update calls to self.
	(resolve_local_symbol): Update call to resolve_symbol_value.
	(S_GET_VALUE): Likewise.  Return resolve_symbol_value if
	!finalize_syms.
	* symbols.h (resolve_symbol_value): Update prototype.
	* config/obj-aout.c (obj_crawl_symbol_chain): Update call
	to resolve_symbol_value.
	* config/obj-bout.c (obj_crawl_symbol_chain): Likewise.
	* config/obj-coff.c (do_relocs_for): Likewise.
	(yank_symbols): Likewise.
	(fixup_segment): Likewise.
	* config/obj-vms.c (obj_crawl_symbol_chain): Likewise.
	* config/tc-mips.c (md_convert_frag): Likewise.
	* config/tc-ppc.c (ppc_frob_symbol): Likewise.
	(ppc_fix_adjustable): Likewise.
	* dwarf2dbg.c (dwarf2dbg_estimate_size_before_relax): Likewise.
	(dwarf2dbg_convert_frag): Likewise.
	* ehopt.c (eh_frame_estimate_size_before_relax): Likewise.
	(eh_frame_convert_frag): Likewise.
	* expr.c (make_expr_symbol): Likewise.
	* write.c (adjust_reloc_syms): Likewise.
	(write_object_file): Likewise.
	(relax_segment): Likewise.
	(fixup_segment): Likewise.
	(finalize_syms): Init to zero, and update comment.
	(write_object_file): Set finalize_syms to 1 rather than 2.
	* doc/internals.texi (sy_value): Mention finalize_syms.
	(S_GET_VALUE): Remove restriction on when S_GET_VALUE can be called.
@
text
@d2848 2
a2849 1
  if (S_GET_STORAGE_CLASS (sym) == C_STSYM)
d2852 21
@


1.20
log
@Pass finalize_syms on calls to resolve_symbol_value.
@
text
@d4224 1
a4224 1
	  resolve_symbol_value (symbol_get_tc (sym)->size, finalize_syms);
d4284 1
a4284 1
	      resolve_symbol_value (symbol_get_tc (sym)->next, finalize_syms);
d4337 1
a4337 1
	      resolve_symbol_value (next, finalize_syms);
d4368 1
a4368 2
		  resolve_symbol_value (symbol_get_tc (csect)->next,
					finalize_syms);
d4414 1
a4414 1
      resolve_symbol_value (csect, finalize_syms);
d4631 1
a4631 1
  resolve_symbol_value (fix->fx_addsy, finalize_syms);
d4651 1
a4651 1
	  resolve_symbol_value (sy, finalize_syms);
d4735 1
a4735 2
      resolve_symbol_value (symbol_get_frag (fix->fx_addsy)->fr_symbol,
			    finalize_syms);
@


1.19
log
@Fix copyright notices
@
text
@d4224 1
a4224 1
	  resolve_symbol_value (symbol_get_tc (sym)->size, 1);
d4284 1
a4284 1
	      resolve_symbol_value (symbol_get_tc (sym)->next, 1);
d4337 1
a4337 1
	      resolve_symbol_value (next, 1);
d4368 2
a4369 1
		  resolve_symbol_value (symbol_get_tc (csect)->next, 1);
d4415 1
a4415 1
      resolve_symbol_value (csect, 1);
d4632 1
a4632 1
  resolve_symbol_value (fix->fx_addsy, 1);
d4652 1
a4652 1
	  resolve_symbol_value (sy, 1);
d4736 2
a4737 1
      resolve_symbol_value (symbol_get_frag (fix->fx_addsy)->fr_symbol, 1);
@


1.18
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000
@


1.18.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.18.2.2
log
@Merge from mainline.
@
text
@d2848 1
a2848 2
  if (S_GET_STORAGE_CLASS (sym) == C_STSYM) {
	  
a2849 19

    /* In this case :
      
       .bs name
       .stabx	"z",arrays_,133,0
       .es
       
       .comm arrays_,13768,3
       
       resolve_symbol_value will copy the exp's "within" into sym's when the
       offset is 0.  Since this seems to be corner case problem,
       only do the correction for storage class C_STSYM.  A better solution
       would be to have the tc	field updated in ppc_symbol_new_hook. */
    
    if (exp.X_op == O_symbol) 
      {
	symbol_get_tc (exp.X_add_symbol)->within = ppc_current_block;
      }
  }
@


1.18.2.3
log
@Fix for default alignment of .comm on aix ppc
@
text
@d2343 1
a2343 2
   symbols, and uses a different smclas.  The native Aix 4.3.3 assember
   aligns .comm and .lcomm to 4 bytes.  */
d2385 1
a2385 1
	align = 2;
d2393 1
a2393 1
	      align = 2;
d2402 5
a2406 1
      if (size <= 4)
@


1.17
log
@2000-12-12  Franz Sirl  <Franz.Sirl-kernel@@lauterbach.com>

	* config/tc-ppc.c (md_pseudo_table): Add .file and .loc.
	(md_assemble): Call dwarf2_emit_insn.
	(shlib): Fix typo SHILB -> SHLIB.
	(md_parse_option): Likewise.
	(ppc_elf_validate_fix): Likewise:
	* config/tc-ppc.h (DWARF2_LINE_MIN_INSN_LENGTH): New.
@
text
@a4597 1
/*ARGSUSED*/
@


1.16
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d32 1
d201 2
d680 1
a680 1
static enum { SHLIB_NONE, SHLIB_PIC, SHILB_MRELOCATABLE } shlib = SHLIB_NONE;
d885 1
a885 1
	  shlib = SHILB_MRELOCATABLE;
d891 1
a891 1
	  shlib = SHILB_MRELOCATABLE;
d1559 1
a1559 1
    case SHILB_MRELOCATABLE:
d2102 4
@


1.15
log
@2000-09-25  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-cris.c: Fix formatting.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.h: Likewise.
@
text
@d518 1
a518 1
#define REG_NAME_CNT	(sizeof(pre_defined_registers) / sizeof(struct pd_reg))
d766 1
a766 1
size_t md_longopts_size = sizeof(md_longopts);
d960 1
a960 1
  fprintf(stream, _("\
d975 1
a975 1
  fprintf(stream, _("\
d1269 1
a1269 1
#define MAP(str,reloc) { str, sizeof(str)-1, reloc }
d1928 1
a1928 1
	      fprintf(stderr,
d1931 1
a1931 1
	      abort();
d2125 1
a2125 1
	    abort();
d5108 1
a5108 1
	  fprintf(stderr,
@


1.14
log
@In src/gas/ChangeLog:
2000-08-30  Mark Hatle  <mhatle@@mvista.com>

	* config/tc-ppc.c (md_parse_option): Recognize -m405.

In src/opcodes/ChangeLog:
2000-08-30  Mark Hatle  <mhatle@@mvista.com>

	* ppc-opc.c Add XTLB macro for a few PPC 4xx extended mnemonics.
	(powerpc_opcodes): Add table entries for PPC 405 instructions.
	Changed rfci, icbt, mfdcr, dccci, mtdcr, iccci from PPC to PPC403
	instructions.
	Added extended mnemonic mftbl as defined in the 405GP manual
	for all PPCs.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000 
d21 1
a21 1
   02111-1307, USA. */
d269 1
a269 1
   The table is sorted. Suitable for searching by a binary search. */
d298 23
a320 23
  { "f.1", 1 }, 
  { "f.10", 10 }, 
  { "f.11", 11 }, 
  { "f.12", 12 }, 
  { "f.13", 13 }, 
  { "f.14", 14 }, 
  { "f.15", 15 }, 
  { "f.16", 16 }, 
  { "f.17", 17 }, 
  { "f.18", 18 }, 
  { "f.19", 19 }, 
  { "f.2", 2 }, 
  { "f.20", 20 }, 
  { "f.21", 21 }, 
  { "f.22", 22 }, 
  { "f.23", 23 }, 
  { "f.24", 24 }, 
  { "f.25", 25 }, 
  { "f.26", 26 }, 
  { "f.27", 27 }, 
  { "f.28", 28 }, 
  { "f.29", 29 }, 
  { "f.3", 3 }, 
d323 31
a353 31
  { "f.4", 4 }, 
  { "f.5", 5 }, 
  { "f.6", 6 }, 
  { "f.7", 7 }, 
  { "f.8", 8 }, 
  { "f.9", 9 }, 

  { "f0", 0 }, 
  { "f1", 1 }, 
  { "f10", 10 }, 
  { "f11", 11 }, 
  { "f12", 12 }, 
  { "f13", 13 }, 
  { "f14", 14 }, 
  { "f15", 15 }, 
  { "f16", 16 }, 
  { "f17", 17 }, 
  { "f18", 18 }, 
  { "f19", 19 }, 
  { "f2", 2 }, 
  { "f20", 20 }, 
  { "f21", 21 }, 
  { "f22", 22 }, 
  { "f23", 23 }, 
  { "f24", 24 }, 
  { "f25", 25 }, 
  { "f26", 26 }, 
  { "f27", 27 }, 
  { "f28", 28 }, 
  { "f29", 29 }, 
  { "f3", 3 }, 
d356 6
a361 6
  { "f4", 4 }, 
  { "f5", 5 }, 
  { "f6", 6 }, 
  { "f7", 7 }, 
  { "f8", 8 }, 
  { "f9", 9 }, 
d447 1
a447 1
  
d449 23
a471 23
  { "v.1", 1 }, 
  { "v.10", 10 }, 
  { "v.11", 11 }, 
  { "v.12", 12 }, 
  { "v.13", 13 }, 
  { "v.14", 14 }, 
  { "v.15", 15 }, 
  { "v.16", 16 }, 
  { "v.17", 17 }, 
  { "v.18", 18 }, 
  { "v.19", 19 }, 
  { "v.2", 2 }, 
  { "v.20", 20 }, 
  { "v.21", 21 }, 
  { "v.22", 22 }, 
  { "v.23", 23 }, 
  { "v.24", 24 }, 
  { "v.25", 25 }, 
  { "v.26", 26 }, 
  { "v.27", 27 }, 
  { "v.28", 28 }, 
  { "v.29", 29 }, 
  { "v.3", 3 }, 
d474 6
a479 6
  { "v.4", 4 }, 
  { "v.5", 5 }, 
  { "v.6", 6 }, 
  { "v.7", 7 }, 
  { "v.8", 8 }, 
  { "v.9", 9 }, 
d482 23
a504 23
  { "v1", 1 }, 
  { "v10", 10 }, 
  { "v11", 11 }, 
  { "v12", 12 }, 
  { "v13", 13 }, 
  { "v14", 14 }, 
  { "v15", 15 }, 
  { "v16", 16 }, 
  { "v17", 17 }, 
  { "v18", 18 }, 
  { "v19", 19 }, 
  { "v2", 2 }, 
  { "v20", 20 }, 
  { "v21", 21 }, 
  { "v22", 22 }, 
  { "v23", 23 }, 
  { "v24", 24 }, 
  { "v25", 25 }, 
  { "v26", 26 }, 
  { "v27", 27 }, 
  { "v28", 28 }, 
  { "v29", 29 }, 
  { "v3", 3 }, 
d507 5
a511 5
  { "v4", 4 }, 
  { "v5", 5 }, 
  { "v6", 6 }, 
  { "v7", 7 }, 
  { "v8", 8 }, 
d587 1
a587 1
  if (reg_number >= 0) 
d591 1
a591 1
      
d748 1
a748 1
/* The current section and the previous section. See ppc_previous. */
d827 1
a827 1
	
d837 1
a837 1
         instructions that are holdovers from the Power. */
d1051 1
a1051 1
extern char* 
d1086 1
a1086 1
  /* Set the ELF flags if desired. */
d1164 1
a1164 1
  ppc_previous_section = 0;  
d1370 1
a1370 1
/* Like normal .long/.short/.word, except support @@got, etc. */
d1372 1
a1372 1
/* end-of-line. */
d1412 1
a1412 1
  input_line_pointer--;		/* Put terminator back into stream. */
d1598 1
a1598 1
 * out:	
d1614 2
a1615 2
enum toc_size_qualifier 
{ 
d1637 1
a1637 1
  
d1642 1
a1642 1
  if (strcmp(toc_spec, "toc") == 0) 
d1646 1
a1646 1
  else if (strcmp(toc_spec, "tocv") == 0) 
d1650 1
a1650 1
  else if (strcmp(toc_spec, "toc32") == 0) 
d1654 1
a1654 1
  else if (strcmp(toc_spec, "toc64") == 0) 
d1669 2
a1670 2
  SKIP_WHITESPACE ();	     /* leading whitespace could be there. */
  c = *input_line_pointer++; /* input_line_pointer->past char in c. */
d1843 1
a1843 1
      if (*input_line_pointer == '[') 
d1849 1
a1849 1
	     The argument following the `]' must be a symbol name, and the 
d1877 1
a1877 1
	  if (!valid_toc) 
d1903 2
a1904 2
	      if (ex.X_op == O_symbol) 
		{		  
d1928 1
a1928 1
	      fprintf(stderr, 
d1980 1
a1980 1
	  /* Allow @@HA, @@L, @@H on constants. */
d2186 1
a2186 1
    }  
d2233 1
a2233 1
}  
d2418 1
a2418 1
      
d2435 1
a2435 1
    
d2437 1
a2437 1
	  
d2459 1
a2459 1
  
d2507 1
a2507 1
  
d2603 1
a2603 1
	  
d2609 1
a2609 1
	  
d3037 1
a3037 1
  
d3226 1
a3226 1
    
d3242 1
a3242 1
	  
d3272 1
a3272 1
ppc_machine(dummy) 
d3427 1
a3427 1
  if (ppc_previous_section == NULL) 
d3458 1
a3458 1
  if (pdata_section == 0) 
d3461 1
a3461 1
      
d3465 1
a3465 1
      
d3493 1
a3493 1
  if (ydata_section == 0) 
d3535 1
a3535 1
			     ( SEC_ALLOC | SEC_LOAD | SEC_RELOC 
d3578 1
a3578 1
   behaviour: much like .int, with the exception that no alignment is 
d3649 4
a3652 4
/* pseudo-op: 
   behaviour: 
   errors:    
   warnings:  
d3752 1
a3752 1
 * FIXME: I just noticed this. This doesn't work at all really. It it 
d3851 1
a3851 1
		  flags |= SEC_CODE; 
d3867 1
a3867 1
		  flags &=~ SEC_LOAD; 
d4375 1
a4375 1
	
d4536 1
a4536 1
     
d4985 1
a4985 1
	  break;  
d5071 1
a5071 1
	    
@


1.13
log
@Fix comments.
@
text
@d845 1
d966 1
a966 1
-mppc, -mppc32, -m403, -m603, -m604\n\
@


1.12
log
@Fix compile time warnings
@
text
@d4483 2
a4484 2
   of type type, and store the appropriate bytes in *litp.  The number
   of LITTLENUMS emitted is stored in *sizep .  An error message is
@


1.11
log
@* config/tc-ppc.c (pre_defined_registers): Add entries for vector
unit registers.
(md_parse_option): Recognize -m7400.
@
text
@d2498 1
a2498 1
     int ignore;
d2648 1
a2648 1
     int ignore;
d2683 1
a2683 1
     int ignore;
d2702 1
a2702 1
     int ignore;
d2725 1
a2725 1
     int ignore;
d2761 1
a2761 1
     int ignore;
d2868 1
a2868 1
     int ignore;
d2959 1
a2959 1
     int ignore;
d2987 1
a2987 1
     int ignore;
d3060 1
a3060 1
     int ignore;
d3096 1
a3096 1
     int ignore;
d3121 1
a3121 1
     int ignore;
d3148 1
a3148 1
     int ignore;
d3173 1
a3173 1
     int ignore;
d3196 1
a3196 1
     int ignore;
d3216 1
a3216 1
     int ignore;
d3272 1
a3272 1
    int dummy;
d3280 1
a3280 1
     int dummy;
d3422 1
a3422 1
     int ignore;
d3455 1
a3455 1
     int ignore;
d3490 1
a3490 1
     int ignore;
d3527 1
a3527 1
     int ignore;
d3558 1
a3558 1
     int ignore;
d3585 1
a3585 1
     int ignore;
d3600 1
a3600 1
     int ignore;
d3784 1
a3784 1
     int ignore;
d3946 1
a3946 1
     int ignore;
d3969 1
a3969 1
     int ignore;
@


1.10
log
@	Add XCOFF64 support.

	bfd:
	* Makefile.am (coff64-rs6000.lo): New rule.
	* Makefile.in: Regenerate.
	* coff-rs6000.c (xcoff_mkobject, xcoff_copy_private_bfd_data,
	xcoff_is_local_label_name, xcoff_rtype2howto,
	xcoff_reloc_type_lookup, xcoff_slurp_armap, xcoff_archive_p,
	xcoff_read_ar_hdr, xcoff_openr_next_archived_file, xcoff_write_armap,
	xcoff_write_archive_contents): No longer static, and prefix with _bfd_.
	(NO_COFF_SYMBOLS): Define.
	(xcoff64_swap_sym_in, xcoff64_swap_sym_out, xcoff64_swap_aux_in,
	xcoff64_swap_aux_out): New functions; handle xcoff symbol tables
	internally.
	(MINUS_ONE): New macro.
	(xcoff_howto_tabl, xcoff_reloc_type_lookup): Add 64 bit POS
	relocation.
	(coff_SWAP_sym_in, coff_SWAP_sym_out, coff_SWAP_aux_in,
	coff_SWAP_aux_out): Map to the new functions.
	* coff64-rs6000.c: New file.
	* libcoff.h (bfd_coff_backend_data): Add new fields
	_bfd_coff_force_symnames_in_strings and
	_bfd_coff_debug_string_prefix_length.
	(bfd_coff_force_symnames_in_strings,
	bfd_coff_debug_string_prefix_length): New macros for above fields.
	* coffcode.h (coff_set_arch_mach_hook): Handle XCOFF64 magic.
	Set machine to 620 for XCOFF64.  Use bfd_coff_swap_sym_in instead
	of using coff_swap_sym_in directly.
	(FORCE_SYMNAMES_IN_STRINGS): New macro, defined for XCOFF64.
	(coff_set_flags) Set magic for XCOFF64.
	(coff_compute_section_file_positions): Add symbol name length to
	string section length if bfd_coff_debug_string_prefix_length is
	true.
	(coff_write_object_contents): Don't do reloc overflow for XCOFF64.
	(coff_slurp_line_table): Use bfd_coff_swap_lineno_in instead of
	using coff_swap_lineno_in directly.
	(bfd_coff_backend_data): Add _bfd_coff_force_symnames_in_strings
	and _bfd_coff_debug_string_prefix_length fields.
	* coffgen.c (coff_fix_symbol_name, coff_write_symbols): Force
	symbol names into strings table when
	bfd_coff_force_symnames_in_strings is true.
	* coffswap.h (MAX_SCNHDR_NRELOC, MAX_SCNHDR_NLNNO, GET_RELOC_VADDR,
	SET_RELOC_VADDR): New macros.
	(coff_swap_reloc_in, coff_swap_reloc_out): Use above macros.
	(coff_swap_aux_in, coff_swap_aux_out): Remove RS6000COFF_C
	code.
	(coff_swap_aouthdr_in, coff_swap_aouthdr_out): Handle XCOFF64
	changes within RS6000COFF_C specific code.
	(coff_swap_scnhdr_out): Use PUT_SCNHDR_NLNNO, PUT_SCNHDR_NRELOC,
	MAX_SCNHDR_NRELOC, and MAX_SCNHDR_NLNNO.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Extend existing hack on target name.
	* xcofflink.c (XCOFF_XVECP): Extend existing hack on
	target name.
	* coff-tic54x.c (ticof): Keep up to date with new fields
	in bfd_coff_backend_data.
	* config.bfd: Add bfd_powerpc_64_arch to targ_arch and define
	targ_selvecs to include rs6000coff64_vec for rs6000.
	* configure.in: Add rs6000coff64_vec case.
 	* cpu-powerpc.c: New bfd_arch_info_type.

	gas:
	* as.c (parse_args): Allow md_parse_option to override -a listing
	option.
	* config/obj-coff.c (add_lineno): Change type of offset parameter
	from "int" to "bfd_vma."
	* config/tc-ppc.c (md_pseudo_table): Add "llong" and "machine."
	(ppc_mach, ppc_subseg_align, ppc_target_format): New.
	(ppc_change_csect): Align correctly for XCOFF64.
	(ppc_machine): New function, which discards "ppc_machine" line.
	(ppc_tc): Cons for 8 when code is 64 bit.
	(md_apply_fix3): Don't check operand->insert.  Handle 64 bit
	relocations.
	(md_parse_option): Handle -a64 and -a32.
	(ppc_xcoff64): New.
	* config/tc-ppc.h (TARGET_MACH): Define.
	(TARGET_FORMAT): Move to function.
	(SUB_SEGMENT_ALIGN): Use ppc_subseg_align.

	include:
	* include/coff/rs6k64.h: New file.

	opcodes:
	* configure.in: Add bfd_powerpc_64_arch.
	* disassemble.c (disassembler): Use print_insn_big_powerpc for
	64 bit code.
@
text
@a241 1

d246 4
d447 66
d848 2
@


1.9
log
@	* app.c: Add ATTRIBUTE_UNUSED as needed.
	* config/tc-ppc.c: Likewise.
	(ppc_size): Make unsigned long.
	(ppc_insert_operand): Add casts to avoid warnings.
@
text
@d89 1
d186 1
d190 1
d597 3
d749 10
d967 31
d2528 1
a2528 1
      symbol_get_tc (sym)->align = 2;
d3200 8
d3327 1
a3327 1
      cons (4);
a4859 1
	       && operand->insert == NULL
d4906 8
@


1.8
log
@* config/obj-coff.h (OBJ_COPY_SYMBOL_ATTRIBUTES): Don't define if
already defined.
* config/tc-ppc.h [OBJ_XCOFF] (OBJ_COPY_SYMBOL_ATTRIBUTES):
New macro.
* config/tc-ppc.c (ppc_fix_adjustable): Don't look at the frag
of a symbol when we really care about its value.
@
text
@d592 1
a592 1
static int ppc_size = PPC_OPCODE_32;
d1080 2
a1081 2
		  && (val & 0x80000000) != 0
		  && (val & 0xffffffff) == val)
d1315 1
a1315 1
     int xxx;
d2177 1
a2177 1
     int ignore;
d3195 1
a3195 1
     int ignore;
d4444 2
a4445 2
     fragS *fragp;
     asection *seg;
d4455 3
a4457 3
     bfd *abfd;
     asection *sec;
     fragS *fragp;
d4467 1
a4467 1
     char *name;
d4480 1
a4480 1
     segT sec;
d5006 1
a5006 1
     asection *seg;
@


1.7
log
@	* config/tc-ppc.c (md_assemble): Trim @@ha constant to 16 bits, to
	handle 0xffffNNNN constants correctly.
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d4560 1
a4560 1
		     <= symbol_get_frag (fix->fx_addsy)->fr_address))
d4566 1
a4566 2
	      if ((symbol_get_frag (csect)->fr_address
		   == symbol_get_frag (fix->fx_addsy)->fr_address)
@


1.6
log
@	* config/obj-ecoff.c (obj_ecoff_set_ext): Change uses of bsym to
	use symbol_get_bfdsym instead.
	* config/tc-ppc.c (md_assemble): Likewise.
	* config/tc-v850.c (v850_comm): Likewise.
@
text
@d1888 3
a1890 2
		ex.X_add_number = (((ex.X_add_number >> 16) & 0xffff)
				   + ((ex.X_add_number >> 15) & 1));
@


1.5
log
@	* config/tc-ppc.c: Update for symbol handling changes.
	* config/obj-coff.c: Likewise.
@
text
@d1786 2
a1787 1
		  if (ex.X_add_symbol->bsym->section != tocdata_section)
@


1.4
log
@        * dwarf2dbg.c (dwarf2_gen_line_info): Mirror the section symbol
        creation logic from obj_elf_create_section.
        * config/obj-elf.c (elf_pseudo_tab): Add pushsection/popsection.
        (section_stack): New.
        (special_sections): Make const.
        (obj_elf_section): Gut and rewrite parsing.
        (obj_elf_change_section): New function broken out of obj_elf_section.
        (obj_elf_parse_section_letters): Likewise.
        (obj_elf_section_word): Likewise.
        (obj_elf_section_type): Likewise.
        (obj_elf_previous): Treat as a toggle.
        (obj_elf_popsection): New.
        * config/tc-ppc.c (ppc_section_word): Take str+len not ptr_str.
        (ppc_section_type): Likewise.
        * config/tc-ppc.h: Likewise.
        * expr.h (struct expressionS): Don't make X_op a bitfield.
        * config/tc-alpha.c: Update for symbol handling changes.
        (md_apply_fix) [case GPREL]: Use now_seg instead of absolute_section.
        (load_expression, emit_ir_load, emit_loadstore, emit_jsrjmp): Likewise.
@
text
@d1036 1
a1036 1
  ppc_text_csects->sy_tc.within = ppc_text_csects;
d1038 1
a1038 1
  ppc_data_csects->sy_tc.within = ppc_data_csects;
d2330 1
a2330 1
	  lcomm_sym->sy_tc.output = 1;
d2338 1
a2338 1
      def_sym->sy_frag = frag_now;
d2343 1
a2343 1
      def_sym->sy_tc.align = align;
d2348 2
a2349 2
      lcomm_sym->sy_frag->fr_offset =
	((lcomm_sym->sy_frag->fr_offset + (1 << align) - 1)
d2351 2
a2352 2
      if (align > lcomm_sym->sy_tc.align)
	lcomm_sym->sy_tc.align = align;
d2359 3
a2361 3
      sym->sy_frag = lcomm_sym->sy_frag;
      S_SET_VALUE (sym, lcomm_sym->sy_frag->fr_offset);
      lcomm_sym->sy_frag->fr_offset += size;
d2393 1
a2393 1
      sym->sy_tc.class = XMC_PR;
d2401 1
a2401 1
      sym->sy_tc.align = get_absolute_expression ();
d2414 1
a2414 1
    subseg_set (S_GET_SEGMENT (sym), sym->sy_tc.subseg);
d2426 1
a2426 1
      switch (sym->sy_tc.class)
d2437 1
a2437 1
	  sym->sy_tc.subseg = ppc_text_subsegment;
d2449 2
a2450 1
	      && ppc_toc_csect->sy_tc.subseg + 1 == ppc_data_subsegment)
d2453 1
a2453 1
	  sym->sy_tc.subseg = ppc_data_subsegment;
d2467 2
a2468 1
      subseg_new (segment_name (S_GET_SEGMENT (sym)), sym->sy_tc.subseg);
d2475 1
a2475 1
      sym->sy_frag = frag_now;
d2478 3
a2480 3
      sym->sy_tc.align = 2;
      sym->sy_tc.output = 1;
      sym->sy_tc.within = sym;
d2483 2
a2484 2
	   list->sy_tc.next != (symbolS *) NULL;
	   list = list->sy_tc.next)
d2486 1
a2486 1
      list->sy_tc.next = sym;
d2489 2
a2490 1
      symbol_append (sym, list->sy_tc.within, &symbol_rootP, &symbol_lastP);
d2594 1
a2594 1
  sym->sy_tc.output = 1;
d2626 1
a2626 1
  sym->sy_tc.real_name = demand_copy_C_string (&len);
d2660 1
a2660 1
  sym->sy_tc.real_name = name;
d2674 1
a2674 1
      sym->sy_frag = &zero_address_frag;
d2679 1
a2679 1
	sym->sy_value = exp;
d2684 1
a2684 1
	  sym->sy_frag = exp.X_add_symbol->sy_frag;
d2692 1
a2692 1
      sym->sy_value = exp;
d2697 1
a2697 1
  sym->bsym->flags |= BSF_DEBUGGING;
d2717 1
a2717 1
  sym->sy_tc.output = 1;
d2720 1
a2720 1
    sym->sy_tc.within = ppc_current_block;
d2730 2
a2731 2
      if (ppc_current_csect->sy_tc.within == exp.X_add_symbol)
	ppc_current_csect->sy_tc.within = sym;
d2786 8
a2793 4
      ext_sym->sy_value.X_op = O_symbol;
      ext_sym->sy_value.X_add_symbol = lab_sym;
      ext_sym->sy_value.X_op_symbol = NULL;
      ext_sym->sy_value.X_add_number = 0;
d2796 3
a2798 3
  if (ext_sym->sy_tc.class == -1)
    ext_sym->sy_tc.class = XMC_PR;
  ext_sym->sy_tc.output = 1;
d2816 5
a2820 5
	      ext_sym->sy_tc.size = symbol_new ("L0\001",
						absolute_section,
						(valueT) 0,
						&zero_address_frag);
	      pseudo_set (ext_sym->sy_tc.size);
d2844 1
a2844 1
  sym->sy_frag = frag_now;
d2853 1
a2853 1
  sym->sy_tc.output = 1;
d2872 1
a2872 1
  sym->sy_frag = frag_now;
d2877 1
a2877 1
  sym->sy_tc.output = 1;
d2911 1
a2911 1
  sym->bsym->flags |= BSF_DEBUGGING;
d2914 1
a2914 1
  sym->sy_tc.output = 1;
d2959 2
a2960 2
  sym->bsym->flags |= BSF_DEBUGGING;
  sym->sy_tc.output = 1;
d2962 1
a2962 1
  sym->sy_tc.within = csect;
d2985 2
a2986 2
  sym->bsym->flags |= BSF_DEBUGGING;
  sym->sy_tc.output = 1;
d3006 1
a3006 1
  sym->sy_frag = frag_now;
d3013 1
a3013 1
  sym->sy_tc.output = 1;
d3033 1
a3033 1
  sym->sy_frag = frag_now;
d3038 1
a3038 1
  sym->sy_tc.output = 1;
d3061 1
a3061 1
  sym->bsym->flags |= BSF_DEBUGGING;
d3064 1
a3064 1
  sym->sy_tc.output = 1;
d3081 1
a3081 1
  sym->bsym->flags |= BSF_DEBUGGING;
d3084 1
a3084 1
  sym->sy_tc.output = 1;
d3098 1
a3098 1
    subseg_set (data_section, ppc_toc_csect->sy_tc.subseg);
d3112 1
a3112 1
      sym->sy_frag = frag_now;
d3115 3
a3117 3
      sym->sy_tc.subseg = subseg;
      sym->sy_tc.output = 1;
      sym->sy_tc.within = sym;
d3122 2
a3123 2
	   list->sy_tc.next != (symbolS *) NULL;
	   list = list->sy_tc.next)
d3125 1
a3125 1
      list->sy_tc.next = sym;
d3128 2
a3129 1
      symbol_append (sym, list->sy_tc.within, &symbol_rootP, &symbol_lastP);
d3221 2
a3222 2
	label = ppc_current_csect->sy_tc.within;
	if (label->sy_tc.class != XMC_TC0)
d3230 1
a3230 1
	label->sy_frag = sym->sy_frag;
d3240 1
a3240 1
    sym->sy_frag = frag_now;
d3242 2
a3243 2
    sym->sy_tc.class = XMC_TC;
    sym->sy_tc.output = 1;
d3923 1
d3926 9
a3934 8
  sym->sy_tc.next = NULL;
  sym->sy_tc.output = 0;
  sym->sy_tc.class = -1;
  sym->sy_tc.real_name = NULL;
  sym->sy_tc.subseg = 0;
  sym->sy_tc.align = 0;
  sym->sy_tc.size = NULL;
  sym->sy_tc.within = NULL;
d3952 1
a3952 1
	sym->sy_tc.class = XMC_BS;
d3956 1
a3956 1
	sym->sy_tc.class = XMC_DB;
d3958 1
a3958 1
	sym->sy_tc.class = XMC_DS;
d3962 1
a3962 1
	sym->sy_tc.class = XMC_GL;
d3966 1
a3966 1
	sym->sy_tc.class = XMC_PR;
d3970 1
a3970 1
	sym->sy_tc.class = XMC_RO;
d3972 1
a3972 1
	sym->sy_tc.class = XMC_RW;
d3976 1
a3976 1
	sym->sy_tc.class = XMC_SV;
d3980 1
a3980 1
	sym->sy_tc.class = XMC_TC;
d3982 1
a3982 1
	sym->sy_tc.class = XMC_TI;
d3984 1
a3984 1
	sym->sy_tc.class = XMC_TB;
d3986 1
a3986 1
	sym->sy_tc.class = XMC_TC0;
d3990 1
a3990 1
	sym->sy_tc.class = XMC_UA;
d3992 1
a3992 1
	sym->sy_tc.class = XMC_UC;
d3996 1
a3996 1
	sym->sy_tc.class = XMC_XO;
d4000 1
a4000 1
  if (sym->sy_tc.class == -1)
d4014 2
a4015 2
      if (sym->sy_tc.class == -1)
	sym->sy_tc.class = ppc_current_csect->sy_tc.class;
d4018 3
a4020 3
      symbol_append (sym, ppc_current_csect->sy_tc.within, &symbol_rootP,
		     &symbol_lastP);
      ppc_current_csect->sy_tc.within = sym;
d4044 2
a4045 2
  if (! sym->sy_used_in_reloc
      && ((sym->bsym->flags & BSF_SECTION_SYM) != 0
d4047 1
a4047 1
	      && ! sym->sy_tc.output
d4051 2
a4052 2
  if (sym->sy_tc.real_name != (char *) NULL)
    S_SET_NAME (sym, sym->sy_tc.real_name);
d4085 1
a4085 1
      if (sym->sy_tc.size != (symbolS *) NULL)
d4087 3
a4089 2
	  resolve_symbol_value (sym->sy_tc.size, 1);
	  SA_SET_SYM_FSIZE (sym, (long) S_GET_VALUE (sym->sy_tc.size));
d4109 1
a4109 1
      && (sym->bsym->flags & BSF_SECTION_SYM) == 0
d4129 2
a4130 2
      a = &coffsymbol (sym->bsym)->native[i + 1].u.auxent;
      if (sym->sy_tc.class == XMC_TC0)
d4137 1
a4137 1
      else if (sym->sy_tc.subseg != 0)
d4141 1
a4141 1
	  if (sym->sy_tc.next == (symbolS *) NULL)
d4147 2
a4148 2
	      resolve_symbol_value (sym->sy_tc.next, 1);
	      a->x_csect.x_scnlen.l = (S_GET_VALUE (sym->sy_tc.next)
d4151 1
a4151 1
	  a->x_csect.x_smtyp = (sym->sy_tc.align << 3) | XTY_SD;
d4156 2
a4157 2
	  a->x_csect.x_scnlen.l = sym->sy_frag->fr_offset;
	  a->x_csect.x_smtyp = (sym->sy_tc.align << 3) | XTY_CM;
d4159 1
a4159 1
	    sym->sy_tc.class = XMC_RW;
d4161 1
a4161 1
	    sym->sy_tc.class = XMC_BS;
d4169 2
a4170 2
	  if (sym->sy_tc.class == -1)
	    sym->sy_tc.class = XMC_XO;
d4178 1
a4178 1
      else if (sym->sy_tc.class == XMC_TC)
d4185 1
a4185 1
	  while (next->sy_tc.class == XMC_TC0)
d4188 1
a4188 1
	      || next->sy_tc.class != XMC_TC)
d4220 1
a4220 1
	  csect = csect->sy_tc.next;
d4229 1
a4229 1
	      while (csect->sy_tc.next != (symbolS *) NULL)
d4231 3
a4233 2
		  resolve_symbol_value (csect->sy_tc.next, 1);
		  if (S_GET_VALUE (csect->sy_tc.next) > S_GET_VALUE (sym))
d4235 1
a4235 1
		  csect = csect->sy_tc.next;
d4238 4
a4241 2
	      a->x_csect.x_scnlen.p = coffsymbol (csect->bsym)->native;
	      coffsymbol (sym->bsym)->native[i + 1].fix_scnlen = 1;
d4248 1
a4248 1
      if (sym->sy_tc.class == -1)
d4251 1
a4251 1
	a->x_csect.x_smclas = sym->sy_tc.class;
d4256 1
a4256 1
      sym->bsym->flags |= BSF_NOT_AT_END;
d4264 4
a4267 2
		   (valueT) coffsymbol (sym->sy_tc.within->bsym)->native);
      coffsymbol (sym->bsym)->native->fix_value = 1;
d4275 2
a4276 2
      block = sym->sy_tc.within;
      csect = block->sy_tc.within;
d4286 1
a4286 1
      coffsymbol (sym->bsym)->native->fix_line = 1;
d4314 1
a4314 1
      csect->bsym->value = S_GET_VALUE (sym);
d4318 1
a4318 1
      a = &coffsymbol (csect->bsym)->native[i + 1].u.auxent;
d4330 3
a4332 3
      a = &coffsymbol (sym->bsym)->native[i].u.auxent;
      a->x_csect.x_scnlen.p = coffsymbol (csect->bsym)->native;
      coffsymbol (sym->bsym)->native[i].fix_scnlen = 1;
d4511 1
a4511 1
	  if (sy->sy_tc.class == XMC_TC0)
d4513 1
a4513 1
	  if (sy->sy_tc.class != XMC_TC)
d4530 3
a4532 3
      && fix->fx_addsy->sy_tc.subseg == 0
      && fix->fx_addsy->sy_tc.class != XMC_TC0
      && fix->fx_addsy->sy_tc.class != XMC_TC
d4551 1
a4551 1
      csect = csect->sy_tc.next;
d4555 3
a4557 3
	  while (csect->sy_tc.next != (symbolS *) NULL
		 && (csect->sy_tc.next->sy_frag->fr_address
		     <= fix->fx_addsy->sy_frag->fr_address))
d4563 2
a4564 2
	      if ((csect->sy_frag->fr_address
		   == fix->fx_addsy->sy_frag->fr_address)
d4569 1
a4569 1
		  for (scan = csect->sy_next;
d4571 1
a4571 1
		       scan = scan->sy_next)
d4573 1
a4573 1
		      if (scan->sy_tc.subseg != 0)
d4585 1
a4585 1
	      csect = csect->sy_tc.next;
d4589 1
a4589 1
			     - csect->sy_frag->fr_address);
d4600 5
a4604 4
      resolve_symbol_value (fix->fx_addsy->sy_frag->fr_symbol, 1);
      fix->fx_offset += (S_GET_VALUE (fix->fx_addsy)
			 - S_GET_VALUE (fix->fx_addsy->sy_frag->fr_symbol));
      fix->fx_addsy = fix->fx_addsy->sy_frag->fr_symbol;
d4624 5
a4628 4
      && fix->fx_addsy->sy_tc.subseg != 0
      && (fix->fx_addsy->sy_frag->fr_address > fix->fx_frag->fr_address
	  || (fix->fx_addsy->sy_tc.next != NULL
	      && (fix->fx_addsy->sy_tc.next->sy_frag->fr_address
d4644 1
a4644 1
  return sym->sy_tc.class == XMC_TC;
d4748 3
a4750 3
	  && fixp->fx_addsy->sy_tc.subseg != 0
	  && fixp->fx_addsy->sy_tc.class != XMC_TC
	  && fixp->fx_addsy->sy_tc.class != XMC_TC0
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d2129 3
a2131 2
ppc_section_word (ptr_str)
     char **ptr_str;
d2133 2
a2134 5
  if (strncmp (*ptr_str, "exclude", sizeof ("exclude")-1) == 0)
    {
      *ptr_str += sizeof ("exclude")-1;
      return SHF_EXCLUDE;
    }
d2136 1
a2136 1
  return 0;
d2140 3
a2142 2
ppc_section_type (ptr_str)
     char **ptr_str;
d2144 2
a2145 5
  if (strncmp (*ptr_str, "ordered", sizeof ("ordered")-1) == 0)
    {
      *ptr_str += sizeof ("ordered")-1;
      return SHT_ORDERED;
    }
d2147 1
a2147 1
  return 0;
@


1.2
log
@        * config/tc-ppc.c (md_parse_option): Recognize -mppc64bridge.
        (md_begin): Allow ppc32 insns in ppc64bridge mode.
        (ppc_insert_operand): Accept SIGNOPT in ppc64 mode.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
d1408 2
a1409 2
    symbolP->sy_frag->fr_symbol = 0;
  symbolP->sy_frag = frag_now;
d4659 1
a4659 1
      if (fixp->fx_addsy->sy_used_in_reloc
d4890 1
a4890 1
			      value + 0x8000 >> 16, 2);
d4997 2
a4998 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
@


1.1
log
@Initial revision
@
text
@d769 5
d880 1
d981 2
a982 1
	      || (op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64)) == ppc_size))
d1066 1
a1066 2
	  if ((operand->flags & PPC_OPERAND_SIGNOPT) != 0
	      && ppc_size == PPC_OPCODE_32)
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

