head	1.27;
access;
symbols
	binutils-2_24-branch:1.27.0.4
	binutils-2_24-branchpoint:1.27
	binutils-2_21_1:1.24
	binutils-2_23_2:1.27
	binutils-2_23_1:1.27
	binutils-2_23:1.27
	binutils-2_23-branch:1.27.0.2
	binutils-2_23-branchpoint:1.27
	binutils-2_22_branch:1.24.0.6
	binutils-2_22:1.24
	binutils-2_22-branch:1.24.0.4
	binutils-2_22-branchpoint:1.24
	binutils-2_21:1.24
	binutils-2_21-branch:1.24.0.2
	binutils-2_21-branchpoint:1.24
	binutils-2_20_1:1.22.2.1
	binutils-2_20:1.22.2.1
	binutils-arc-20081103-branch:1.19.0.6
	binutils-arc-20081103-branchpoint:1.19
	binutils-2_20-branch:1.22.0.2
	binutils-2_20-branchpoint:1.22
	dje-cgen-play1-branch:1.20.0.2
	dje-cgen-play1-branchpoint:1.20
	arc-20081103-branch:1.19.0.4
	arc-20081103-branchpoint:1.19
	binutils-2_19_1:1.19
	binutils-2_19:1.19
	binutils-2_19-branch:1.19.0.2
	binutils-2_19-branchpoint:1.19
	binutils-2_18:1.16
	binutils-2_18-branch:1.16.0.2
	binutils-2_18-branchpoint:1.16
	binutils-csl-coldfire-4_1-32:1.15
	binutils-csl-sourcerygxx-4_1-32:1.15
	binutils-csl-innovasic-fido-3_4_4-33:1.15
	binutils-csl-sourcerygxx-3_4_4-32:1.12
	binutils-csl-coldfire-4_1-30:1.15
	binutils-csl-sourcerygxx-4_1-30:1.15
	binutils-csl-coldfire-4_1-28:1.15
	binutils-csl-sourcerygxx-4_1-29:1.15
	binutils-csl-sourcerygxx-4_1-28:1.15
	binutils-csl-arm-2006q3-27:1.15
	binutils-csl-sourcerygxx-4_1-27:1.15
	binutils-csl-arm-2006q3-26:1.15
	binutils-csl-sourcerygxx-4_1-26:1.15
	binutils-csl-sourcerygxx-4_1-25:1.15
	binutils-csl-sourcerygxx-4_1-24:1.15
	binutils-csl-sourcerygxx-4_1-23:1.15
	binutils-csl-sourcerygxx-4_1-21:1.15
	binutils-csl-arm-2006q3-21:1.15
	binutils-csl-sourcerygxx-4_1-22:1.15
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.15
	binutils-csl-sourcerygxx-4_1-20:1.15
	binutils-csl-arm-2006q3-19:1.15
	binutils-csl-sourcerygxx-4_1-19:1.15
	binutils-csl-sourcerygxx-4_1-18:1.15
	binutils-csl-renesas-4_1-9:1.15
	binutils-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-renesas-4_1-8:1.15
	binutils-csl-renesas-4_1-7:1.15
	binutils-csl-renesas-4_1-6:1.15
	binutils-csl-sourcerygxx-4_1-17:1.15
	binutils-csl-sourcerygxx-4_1-14:1.15
	binutils-csl-sourcerygxx-4_1-15:1.15
	binutils-csl-sourcerygxx-4_1-13:1.15
	binutils-2_17:1.15
	binutils-csl-sourcerygxx-4_1-12:1.15
	binutils-csl-sourcerygxx-3_4_4-21:1.15
	binutils-csl-wrs-linux-3_4_4-24:1.12
	binutils-csl-wrs-linux-3_4_4-23:1.12
	binutils-csl-sourcerygxx-4_1-9:1.15
	binutils-csl-sourcerygxx-4_1-8:1.15
	binutils-csl-sourcerygxx-4_1-7:1.15
	binutils-csl-arm-2006q1-6:1.15
	binutils-csl-sourcerygxx-4_1-6:1.15
	binutils-csl-wrs-linux-3_4_4-22:1.12
	binutils-csl-coldfire-4_1-11:1.15
	binutils-csl-sourcerygxx-3_4_4-19:1.15
	binutils-csl-coldfire-4_1-10:1.15
	binutils-csl-sourcerygxx-4_1-5:1.15
	binutils-csl-sourcerygxx-4_1-4:1.15
	binutils-csl-wrs-linux-3_4_4-21:1.12
	binutils-csl-morpho-4_1-4:1.15
	binutils-csl-sourcerygxx-3_4_4-17:1.15
	binutils-csl-wrs-linux-3_4_4-20:1.12
	binutils-2_17-branch:1.15.0.4
	binutils-2_17-branchpoint:1.15
	binutils-csl-2_17-branch:1.15.0.2
	binutils-csl-2_17-branchpoint:1.15
	binutils-csl-gxxpro-3_4-branch:1.12.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.12
	binutils-2_16_1:1.12
	binutils-csl-arm-2005q1b:1.12
	binutils-2_16:1.12
	binutils-csl-arm-2005q1a:1.12
	binutils-csl-arm-2005q1-branch:1.12.0.4
	binutils-csl-arm-2005q1-branchpoint:1.12
	binutils-2_16-branch:1.12.0.2
	binutils-2_16-branchpoint:1.12
	csl-arm-2004-q3d:1.9
	csl-arm-2004-q3:1.9
	binutils-2_15:1.8.6.1
	binutils-2_15-branchpoint:1.8
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	binutils-2_15-branch:1.8.0.6
	cagney_bfdfile-20040213-branch:1.8.0.4
	cagney_bfdfile-20040213-branchpoint:1.8
	cagney_bigcore-20040122-branch:1.8.0.2
	cagney_bigcore-20040122-branchpoint:1.8
	csl-arm-2003-q4:1.8
	binutils-2_14:1.6
	binutils-2_14-branch:1.6.0.2
	binutils-2_14-branchpoint:1.6
	binutils-2_13_2_1:1.2
	binutils-2_13_2:1.2
	binutils-2_13_1:1.2
	binutils-2_13:1.2
	binutils-2_13-branchpoint:1.2
	binutils-2_13-branch:1.2.0.2
	binutils_latest_snapshot:1.27;
locks; strict;
comment	@ * @;


1.27
date	2012.05.18.23.21.49;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2012.05.18.05.48.50;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2012.05.17.15.13.16;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.08.10.36.39;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.08.15.35.33;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.05.09.12.55;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.24.20.40.26;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.03.11.47.49;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.01.02.00.15;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.31.23.18.27;	author bje;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.01.08.22.46;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2003.11.21.00.24.40;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.17.01.13.55;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.28.14.07.53;	author nickc;	state Exp;
branches;
next	;

1.22.2.1
date	2009.09.08.10.53.21;	author amodra;	state Exp;
branches;
next	;

1.8.6.1
date	2004.04.09.18.28.11;	author drow;	state Exp;
branches;
next	;


desc
@@


1.27
log
@	* config/tc-dlx.c (s_proc): Don't use asprintf.
@
text
@/* tc-dlx.c -- Assemble for the DLX
   Copyright 2002, 2003, 2004, 2005, 2007, 2009, 2010, 2012
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Initially created by Kuang Hwa Lin, 3/20/2002.  */

#include "as.h"
#include "safe-ctype.h"
#include "tc-dlx.h"
#include "opcode/dlx.h"

/* Make it easier to clone this machine desc into another one.  */
#define	machine_opcode      dlx_opcode
#define	machine_opcodes     dlx_opcodes
#define	machine_ip          dlx_ip
#define	machine_it          dlx_it

#define NO_RELOC            BFD_RELOC_NONE
#define RELOC_DLX_REL26     BFD_RELOC_DLX_JMP26
#define RELOC_DLX_16        BFD_RELOC_16
#define RELOC_DLX_REL16     BFD_RELOC_16_PCREL_S2
#define RELOC_DLX_HI16      BFD_RELOC_HI16_S
#define RELOC_DLX_LO16      BFD_RELOC_LO16
#define RELOC_DLX_VTINHERIT BFD_RELOC_VTABLE_INHERIT
#define RELOC_DLX_VTENTRY   BFD_RELOC_VTABLE_ENTRY

/* handle of the OPCODE hash table */
static struct hash_control *op_hash = NULL;

struct machine_it
{
  char *error;
  unsigned long opcode;
  struct nlist *nlistp;
  expressionS exp;
  int pcrel;
  int size;
  int reloc_offset;		/* Offset of reloc within insn.  */
  int reloc;
  int HI;
  int LO;
}
the_insn;

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = ";";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.  */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";

/* We needed an unused char for line separation to work around the
   lack of macros, using sed and such.  */
const char line_separator_chars[] = "@@";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

static void
insert_sreg (char *regname, int regnum)
{
  /* Must be large enough to hold the names of the special registers.  */
  char buf[80];
  int i;

  symbol_table_insert (symbol_new (regname, reg_section, (valueT) regnum,
				   &zero_address_frag));
  for (i = 0; regname[i]; i++)
    buf[i] = ISLOWER (regname[i]) ? TOUPPER (regname[i]) : regname[i];
  buf[i] = '\0';

  symbol_table_insert (symbol_new (buf, reg_section, (valueT) regnum,
				   &zero_address_frag));
}

/* Install symbol definitions for assorted special registers.
   See MIPS Assembly Language Programmer's Guide page 1-4   */

static void
define_some_regs (void)
{
  /* Software representation.  */
  insert_sreg ("zero",  0);
  insert_sreg ("at",    1);
  insert_sreg ("v0",    2);
  insert_sreg ("v1",    3);
  insert_sreg ("a0",    4);
  insert_sreg ("a1",    5);
  insert_sreg ("a2",    6);
  insert_sreg ("a3",    7);
  insert_sreg ("t0",    8);
  insert_sreg ("t1",    9);
  insert_sreg ("t2",    10);
  insert_sreg ("t3",    11);
  insert_sreg ("t4",    12);
  insert_sreg ("t5",    13);
  insert_sreg ("t6",    14);
  insert_sreg ("t7",    15);
  insert_sreg ("s0",    16);
  insert_sreg ("s1",    17);
  insert_sreg ("s2",    18);
  insert_sreg ("s3",    19);
  insert_sreg ("s4",    20);
  insert_sreg ("s5",    21);
  insert_sreg ("s6",    22);
  insert_sreg ("s7",    23);
  insert_sreg ("t8",    24);
  insert_sreg ("t9",    25);
  insert_sreg ("k0",    26);
  insert_sreg ("k1",    27);
  insert_sreg ("gp",    28);
  insert_sreg ("sp",    29);
  insert_sreg ("fp",    30);
  insert_sreg ("ra",    31);
  /* Special registers.  */
  insert_sreg ("pc",    0);
  insert_sreg ("npc",   1);
  insert_sreg ("iad",   2);
}

/* Subroutine check the string to match an register.  */

static int
match_sft_register (char *name)
{
#define MAX_REG_NO  35
/* Currently we have 35 software registers defined -
   we borrowed from MIPS.   */
  static char *soft_reg[] =
    {
      "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
      "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9",
      "s0", "s1", "s2", "s3", "s4", "s5", "s7", "k0", "k1",
      "gp", "sp", "fp", "ra", "pc", "npc", "iad",
      "EndofTab"  /* End of the Table indicator */
    };
  char low_name[21], *ptr;
  int idx;

  for (ptr = name,idx = 0; *ptr != '\0'; ptr++)
    low_name[idx++] = TOLOWER (*ptr);

  low_name[idx] = '\0';
  idx = 0;

  while (idx < MAX_REG_NO && strcmp (soft_reg[idx], & low_name [0]))
    idx += 1;

  return idx < MAX_REG_NO;
}

/* Subroutine check the string to match an register.  */

static int
is_ldst_registers (char *name)
{
  char *ptr = name;

  /* The first character of the register name got to be either %, $, r of R.  */
  if ((ptr[0] == '%' || ptr[0] == '$' || ptr[0] == 'r' || ptr[0] == 'R')
      && ISDIGIT ((unsigned char) ptr[1]))
    return 1;

  /* Now check the software register representation.  */
  return match_sft_register (ptr);
}

/* Subroutine of s_proc so targets can choose a different default prefix.
   If DEFAULT_PREFIX is NULL, use the target's "leading char".  */

static void
s_proc (int end_p)
{
  /* Record the current function so that we can issue an error message for
     misplaced .func,.endfunc, and also so that .endfunc needs no
     arguments.  */
  static char *current_name;
  static char *current_label;

  if (end_p)
    {
      if (current_name == NULL)
	{
	  as_bad (_("missing .proc"));
	  ignore_rest_of_line ();
	  return;
	}

      current_name = current_label = NULL;
      SKIP_WHITESPACE ();
      while (!is_end_of_line[(unsigned char) *input_line_pointer])
        input_line_pointer++;
    }
  else
    {
      char *name, *label;
      char delim1, delim2;

      if (current_name != NULL)
	{
	  as_bad (_(".endfunc missing for previous .proc"));
	  ignore_rest_of_line ();
	  return;
	}

      name = input_line_pointer;
      delim1 = get_symbol_end ();
      name = xstrdup (name);
      *input_line_pointer = delim1;
      SKIP_WHITESPACE ();

      if (*input_line_pointer != ',')
	{
	  char leading_char = 0;

	  leading_char = bfd_get_symbol_leading_char (stdoutput);
	  /* Missing entry point, use function's name with the leading
	     char prepended.  */
	  if (leading_char)
	    {
	      unsigned len = strlen (name) + 1;
	      label = xmalloc (len + 1);
	      label[0] = leading_char;
	      memcpy (label + 1, name, len);
	    }
	  else
	    label = name;
	}
      else
	{
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  label = input_line_pointer;
	  delim2 = get_symbol_end ();
	  label = xstrdup (label);
	  *input_line_pointer = delim2;
	}

      current_name = name;
      current_label = label;
    }
  demand_empty_rest_of_line ();
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc., that the MD part of the assembler will
   need.  */

void
md_begin (void)
{
  const char *retval = NULL;
  int lose = 0;
  unsigned int i;

  /* Create a new hash table.  */
  op_hash = hash_new ();

  /* Hash up all the opcodes for fast use later.  */
  for (i = 0; i < num_dlx_opcodes; i++)
    {
      const char *name = machine_opcodes[i].name;

      retval = hash_insert (op_hash, name, (void *) &machine_opcodes[i]);

      if (retval != NULL)
	{
	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
		   machine_opcodes[i].name, retval);
	  lose = 1;
	}
    }

  if (lose)
    as_fatal (_("Broken assembler.  No assembly attempted."));

  define_some_regs ();
}

/* This function will check the opcode and return 1 if the opcode is one
   of the load/store instruction, and it will fix the operand string to
   the standard form so we can use the standard parse_operand routine.  */

#define READ_OP     0x100
#define WRITE_OP    0x200
static char iBuf[81];

static char *
dlx_parse_loadop (char * str)
{
  char *ptr = str;
  int   idx = 0;

  /* The last pair of ()/[] is the register, all other are the
     reloc displacement, and if there is a register then it ought
     to have a pair of ()/[]
     This is not necessarily true, what if the load instruction come
     without the register and with %hi/%lo modifier?  */
  for (idx = 0; idx < 72 && ptr[idx] != '\0'; idx++)
    ;

  if (idx == 72)
    {
    badoperand_load:
      as_bad (_("Bad operand for a load instruction: <%s>"), str);
      return NULL;
    }
  else
    {
      int i, pb = 0;
      int m2 = 0;
      char rs1[7], rd[7], endm, match = '0';
      char imm[72];

      idx -= 1;
      switch (str[idx])
	{
	case ')':
	  match = '(';
	  endm  = ')';
	  break;
	case ']':
	  match = '[';
	  endm  = ']';
	  break;
	default:
	  /* No register indicated, fill in zero.  */
	  rs1[0] = 'r';
	  rs1[1] = '0';
	  rs1[2] = '\0';
	  match  = 0;
	  endm = 0;
	  m2 = 1;
	}

      if (!m2)
	{
	  /* Searching for (/[ which will match the ]/).  */
	  for (pb = idx - 1; str[pb] != match; pb -= 1)
	    /* Match can only be either '[' or '(', if it is
	       '(' then this can be a normal expression, we'll treat
	       it as an operand.  */
	    if (str[pb] == endm || pb < (idx - 5))
	      goto load_no_rs1;
	  pb += 1;

	  for (i = 0; (pb + i) < idx; i++)
	    rs1[i] = str[pb+i];

	  rs1[i] = '\0';

	  if (is_ldst_registers (& rs1[0]))
	    /* Point to the last character of the imm.  */
	    pb -= 1;
	  else
	    {
	    load_no_rs1:
	      if (match == '[')
		goto badoperand_load;
	      /* No register indicated, fill in zero and restore the imm.  */
	      rs1[0] = 'r';
	      rs1[1] = '0';
	      rs1[2] = '\0';
	      m2 = 1;
	    }
	}

      /* Duplicate the first register.  */
      for (i = 0; i < 7 && str[i] != ','; i++)
	rd[i] = ptr[i];

      if (str[i] != ',')
	goto badoperand_load;
      else
	rd[i] = '\0';

      /* Copy the immd.  */
      if (m2)
	/* Put the '\0' back in.  */
	pb = idx + 1;

      for (i++, m2 = 0; i < pb; m2++,i++)
	imm[m2] = ptr[i];

      imm[m2] = '\0';

      /* Assemble the instruction to gas internal format.  */
      for (i = 0; rd[i] != '\0'; i++)
	iBuf[i] = rd[i];

      iBuf[i++] = ',';

      for (pb = 0 ; rs1[pb] != '\0'; i++, pb++)
	iBuf[i] = rs1[pb];

      iBuf[i++] = ',';

      for (pb = 0; imm[pb] != '\0'; i++, pb++)
	iBuf[i] = imm[pb];

      iBuf[i] = '\0';
      return iBuf;
    }
}

static char *
dlx_parse_storeop (char * str)
{
  char *ptr = str;
  int   idx = 0;

  /* Search for the ','.  */
  for (idx = 0; idx < 72 && ptr[idx] != ','; idx++)
    ;

  if (idx == 72)
    {
    badoperand_store:
      as_bad (_("Bad operand for a store instruction: <%s>"), str);
      return NULL;
    }
  else
    {
      /* idx now points to the ','.  */
      int i, pb = 0;
      int comma = idx;
      int m2 = 0;
      char rs1[7], rd[7], endm, match = '0';
      char imm[72];

      /* Now parse the '(' and ')', and make idx point to ')'.  */
      idx -= 1;
      switch (str[idx])
	{
	case ')':
	  match = '(';
	  endm  = ')';
	  break;
	case ']':
	  match = '[';
	  endm  = ']';
	  break;
	default:
	  /* No register indicated, fill in zero.  */
	  rs1[0] = 'r';
	  rs1[1] = '0';
	  rs1[2] = '\0';
	  match  = 0;
	  endm = 0;
	  m2 = 1;
	}

      if (!m2)
	{
	  /* Searching for (/[ which will match the ]/).  */
	  for (pb = idx - 1; str[pb] != match; pb -= 1)
	    if (pb < (idx - 5) || str[pb] == endm)
	      goto store_no_rs1;
	  pb += 1;

	  for (i = 0; (pb + i) < idx; i++)
	    rs1[i] = str[pb + i];

	  rs1[i] = '\0';

	  if (is_ldst_registers (& rs1[0]))
	    /* Point to the last character of the imm.  */
	    pb -= 1;
	  else
	    {
	    store_no_rs1:
	      if (match == '[')
		goto badoperand_store;

	      /* No register indicated, fill in zero and restore the imm.  */
	      rs1[0] = 'r';
	      rs1[1] = '0';
	      rs1[2] = '\0';
	      pb = comma;
	    }
	}
      else
	/* No register was specified.  */
	pb = comma;

      /* Duplicate the first register.  */
      for (i = comma + 1; (str[i] == ' ' || str[i] == '\t'); i++)
	;

      for (m2 = 0; (m2 < 7 && str[i] != '\0'); i++, m2++)
	{
	  if (str[i] != ' ' && str[i] != '\t')
	    rd[m2] = str[i];
	  else
	    goto badoperand_store;
	}

      if (str[i] != '\0')
	goto badoperand_store;
      else
	rd[m2] = '\0';

      /* Copy the immd.  */
      for (i = 0; i < pb; i++)
	imm[i] = ptr[i];

      imm[i] = '\0';

      /* Assemble the instruction to gas internal format.  */
      for (i = 0; rd[i] != '\0'; i++)
	iBuf[i] = rd[i];
      iBuf[i++] = ',';
      for (pb = 0 ; rs1[pb] != '\0'; i++, pb++)
	iBuf[i] = rs1[pb];
      iBuf[i++] = ',';
      for (pb = 0; imm[pb] != '\0'; i++, pb++)
	iBuf[i] = imm[pb];
      iBuf[i] = '\0';
      return iBuf;
    }
}

static char *
fix_ld_st_operand (unsigned long opcode, char* str)
{
  /* Check the opcode.  */
  switch ((int) opcode)
    {
    case  LBOP:
    case  LBUOP:
    case  LSBUOP:
    case  LHOP:
    case  LHUOP:
    case  LSHUOP:
    case  LWOP:
    case  LSWOP:
      return dlx_parse_loadop (str);
    case  SBOP:
    case  SHOP:
    case  SWOP:
      return dlx_parse_storeop (str);
    default:
      return str;
    }
}

static int
hilo_modifier_ok (char *s)
{
  char *ptr = s;
  int   idx, count = 1;

  if (*ptr != '(')
    return 1;

  for (idx = 1; ptr[idx] != '\0' && ptr[idx] != '[' && idx < 73; idx += 1)
    {
      if (count == 0)
	return count;

      if (ptr[idx] == '(')
	count += 1;

      if (ptr[idx] == ')')
	count -= 1;
    }

  return (count == 0) ? 1:0;
}

static char *
parse_operand (char *s, expressionS *operandp)
{
  char *save = input_line_pointer;
  char *new_pos;

  the_insn.HI = the_insn.LO = 0;

  /* Search for %hi and %lo, make a mark and skip it.  */
  if (strncmp (s, "%hi", 3) == 0)
    {
      s += 3;
      the_insn.HI = 1;
    }
  else
    {
      if (strncmp (s, "%lo", 3) == 0)
	{
	  s += 3;
	  the_insn.LO = 1;
	}
      else
	the_insn.LO = 0;
    }

  if (the_insn.HI || the_insn.LO)
    {
      if (!hilo_modifier_ok (s))
	as_bad (_("Expression Error for operand modifier %%hi/%%lo\n"));
    }

  /* Check for the % and $ register representation    */
  if ((s[0] == '%' || s[0] == '$' || s[0] == 'r' || s[0] == 'R')
      && ISDIGIT ((unsigned char) s[1]))
    {
      /* We have a numeric register expression.  No biggy.  */
      s += 1;
      input_line_pointer = s;
      (void) expression (operandp);
      if (operandp->X_op != O_constant
	  || operandp->X_add_number > 31)
	as_bad (_("Invalid expression after %%%%\n"));
      operandp->X_op = O_register;
    }
  else
    {
      /* Normal operand parsing.  */
      input_line_pointer = s;
      (void) expression (operandp);
    }

  new_pos = input_line_pointer;
  input_line_pointer = save;
  return new_pos;
}

/* Instruction parsing.  Takes a string containing the opcode.
   Operands are at input_line_pointer.  Output is in the_insn.
   Warnings or errors are generated.  */

static void
machine_ip (char *str)
{
  char *s;
  const char *args;
  struct machine_opcode *insn;
  unsigned long opcode;
  expressionS the_operand;
  expressionS *operand = &the_operand;
  unsigned int reg, reg_shift = 0;

  /* Fixup the opcode string to all lower cases, and also
     allow numerical digits.  */
  s = str;

  if (ISALPHA (*s))
    for (; ISALNUM (*s); ++s)
      if (ISUPPER (*s))
	*s = TOLOWER (*s);

  switch (*s)
    {
    case '\0':
      break;

      /* FIXME-SOMEDAY more whitespace.  */
    case ' ':
      *s++ = '\0';
      break;

    default:
      as_bad (_("Unknown opcode: `%s'"), str);
      return;
    }

  /* Hash the opcode, insn will have the string from opcode table.
     also initialized the_insn struct.  */
  if ((insn = (struct machine_opcode *) hash_find (op_hash, str)) == NULL)
    {
      /* Handle the ret and return macro here.  */
      if ((strcmp (str, "ret") == 0) || (strcmp (str, "return") == 0))
	{
	  memset (&the_insn, '\0', sizeof (the_insn));
	  the_insn.reloc = NO_RELOC;
	  the_insn.pcrel = 0;
	  the_insn.opcode =
	    (unsigned long)(JROP | 0x03e00000);    /* 0x03e00000 = r31 << 21 */
	}
      else
	as_bad (_("Unknown opcode `%s'."), str);

      return;
    }

  opcode = insn->opcode;
  memset (&the_insn, '\0', sizeof (the_insn));
  the_insn.reloc = NO_RELOC;
  the_insn.pcrel = 0;

  /* Set the sip reloc HI16 flag.  */
  if (!set_dlx_skip_hi16_flag (1))
    as_bad (_("Can not set dlx_skip_hi16_flag"));

  /* Fix the operand string if it is one of load store instructions.  */
  s = fix_ld_st_operand (opcode, s);

  /* Build the opcode, checking as we go to make sure that the
     operands match.
     If an operand matches, we modify the_insn or opcode appropriately,
     and do a "continue".  If an operand fails to match, we "break".  */
  if (insn->args[0] != '\0' && insn->args[0] != 'N')
    {
      /* Prime the pump.  */
      if (*s == '\0')
	{
	  as_bad (_("Missing arguments for opcode <%s>."), str);
	  return;
	}
      else
	s = parse_operand (s, operand);
    }
  else if (insn->args[0] == 'N')
    {
      /* Clean up the insn and done!  */
      the_insn.opcode = opcode;
      return;
    }

  /* Parse through the args (this is from opcode table), *s point to
     the current character of the instruction stream.  */
  for (args = insn->args;; ++args)
    {
      switch (*args)
	{
	  /* End of Line.  */
	case '\0':
	  /* End of args.  */
	  if (*s == '\0')
	    {
	      /* We are truly done.  */
	      the_insn.opcode = opcode;
	      /* Clean up the HI and LO mark.  */
	      the_insn.HI = 0;
	      the_insn.LO = 0;
	      return;
	    }

	  the_insn.HI = 0;
	  the_insn.LO = 0;
	  as_bad (_("Too many operands: %s"), s);
	  break;

	  /* ',' Args separator */
	case ',':
	  /* Must match a comma.  */
	  if (*s++ == ',')
	    {
	      /* Parse next operand.  */
	      s = parse_operand (s, operand);
	      continue;
	    }
	  break;

	  /* It can be a 'a' register or 'i' operand.  */
	case 'P':
	  /* Macro move operand/reg.  */
	  if (operand->X_op == O_register)
	    {
	      /* Its a register.  */
	      reg_shift = 21;
	      goto general_reg;
	    }

	  /* The immediate 16 bits literal, bit 0-15.  */
	case 'i':
	  /* offset, unsigned.  */
	case 'I':
	  /* offset, signed.  */
	  if (operand->X_op == O_constant)
	    {
	      if (the_insn.HI)
		operand->X_add_number >>= 16;

	      opcode |= operand->X_add_number & 0xFFFF;

	      if (the_insn.HI && the_insn.LO)
		as_bad (_("Both the_insn.HI and the_insn.LO are set : %s"), s);
	      else
		{
		  the_insn.HI = 0;
		  the_insn.LO = 0;
		}
	      continue;
	    }

	  the_insn.reloc        = (the_insn.HI) ? RELOC_DLX_HI16 
	    : (the_insn.LO ? RELOC_DLX_LO16 : RELOC_DLX_16);
	  the_insn.reloc_offset = 2;
	  the_insn.size         = 2;
	  the_insn.pcrel        = 0;
	  the_insn.exp          = * operand;
	  the_insn.HI           = 0;
	  the_insn.LO           = 0;
	  continue;

	case 'd':
	  /* offset, signed.  */
	  if (operand->X_op == O_constant)
	    {
	      opcode |= operand->X_add_number & 0xFFFF;
	      continue;
	    }
	  the_insn.reloc        = RELOC_DLX_REL16;
	  the_insn.reloc_offset = 0;    /* BIG-ENDIAN Byte 3 of insn.  */
	  the_insn.size         = 4;
	  the_insn.pcrel        = 1;
	  the_insn.exp          = *operand;
	  continue;

	  /* The immediate 26 bits literal, bit 0-25.  */
	case 'D':
	  /* offset, signed.  */
	  if (operand->X_op == O_constant)
	    {
	      opcode |= operand->X_add_number & 0x3FFFFFF;
	      continue;
	    }
	  the_insn.reloc = RELOC_DLX_REL26;
	  the_insn.reloc_offset = 0;    /* BIG-ENDIAN Byte 3 of insn.  */
	  the_insn.size  = 4;
	  the_insn.pcrel = 1;
	  the_insn.exp = *operand;
	  continue;

	  /* Type 'a' Register.  */
	case 'a':
	  /* A general register at bits 21-25, rs1.  */
	  reg_shift = 21;
	  goto general_reg;

	  /* Type 'b' Register.  */
	case 'b':
	  /* A general register at bits 16-20, rs2/rd.  */
	  reg_shift = 16;
	  goto general_reg;

	  /* Type 'c' Register.  */
	case 'c':
	  /* A general register at bits 11-15, rd.  */
	  reg_shift = 11;

	general_reg:
	  know (operand->X_add_symbol == 0);
	  know (operand->X_op_symbol == 0);
	  reg = operand->X_add_number;
	  if (reg & 0xffffffe0)
	    as_fatal (_("failed regnum sanity check."));
	  else
	    /* Got the register, now figure out where it goes in the opcode.  */
	    opcode |= reg << reg_shift;

	  switch (*args)
	    {
	    case 'a':
	    case 'b':
	    case 'c':
	    case 'P':
	      continue;
	    }
	  as_fatal (_("failed general register sanity check."));
	  break;

	default:
	  BAD_CASE (*args);
	}

      /* Types or values of args don't match.  */
      as_bad (_("Invalid operands"));
      return;
    }
}

/* Assemble a single instruction.  Its label has already been handled
   by the generic front end.  We just parse opcode and operands, and
   produce the bytes of data and relocation.  */

void
md_assemble (char *str)
{
  char *toP;
  fixS *fixP;
  bit_fixS *bitP;

  know (str);
  machine_ip (str);
  toP = frag_more (4);
  dwarf2_emit_insn (4);

  /* Put out the opcode.  */
  md_number_to_chars (toP, the_insn.opcode, 4);

  /* Put out the symbol-dependent stuff.  */
  if (the_insn.reloc != NO_RELOC)
    {
      fixP = fix_new_exp (frag_now,
			  (toP - frag_now->fr_literal + the_insn.reloc_offset),
			  the_insn.size, & the_insn.exp, the_insn.pcrel,
			  the_insn.reloc);

      /* Turn off complaints that the addend is
	 too large for things like foo+100000@@ha.  */
      switch (the_insn.reloc)
	{
	case RELOC_DLX_HI16:
	case RELOC_DLX_LO16:
	  fixP->fx_no_overflow = 1;
	  break;
	default:
	  break;
	}

      switch (fixP->fx_r_type)
	{
	case RELOC_DLX_REL26:
	  bitP = malloc (sizeof (bit_fixS));
	  bitP->fx_bit_size = 26;
	  bitP->fx_bit_offset = 25;
	  bitP->fx_bit_base = the_insn.opcode & 0xFC000000;
	  bitP->fx_bit_base_adj = 0;
	  bitP->fx_bit_max = 0;
	  bitP->fx_bit_min = 0;
	  bitP->fx_bit_add = 0x03FFFFFF;
	  fixP->fx_bit_fixP = bitP;
	  break;
	case RELOC_DLX_LO16:
	case RELOC_DLX_REL16:
	  bitP = malloc (sizeof (bit_fixS));
	  bitP->fx_bit_size = 16;
	  bitP->fx_bit_offset = 15;
	  bitP->fx_bit_base = the_insn.opcode & 0xFFFF0000;
	  bitP->fx_bit_base_adj = 0;
	  bitP->fx_bit_max = 0;
	  bitP->fx_bit_min = 0;
	  bitP->fx_bit_add = 0x0000FFFF;
	  fixP->fx_bit_fixP = bitP;
	  break;
	case RELOC_DLX_HI16:
	  bitP = malloc (sizeof (bit_fixS));
	  bitP->fx_bit_size = 16;
	  bitP->fx_bit_offset = 15;
	  bitP->fx_bit_base = the_insn.opcode & 0xFFFF0000;
	  bitP->fx_bit_base_adj = 0;
	  bitP->fx_bit_max = 0;
	  bitP->fx_bit_min = 0;
	  bitP->fx_bit_add = 0x0000FFFF;
	  fixP->fx_bit_fixP = bitP;
	  break;
	default:
	  fixP->fx_bit_fixP = NULL;
	  break;
	}
    }
}

/* This is identical to the md_atof in m68k.c.  I think this is right,
   but I'm not sure.  Dlx will not use it anyway, so I just leave it
   here for now.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

/* Write out big-endian.  */
void
md_number_to_chars (char *buf, valueT val, int n)
{
  number_to_chars_bigendian (buf, val, n);
}

bfd_boolean
md_dlx_fix_adjustable (fixS *fixP)
{
  /* We need the symbol name for the VTABLE entries.  */
  return (fixP->fx_r_type != BFD_RELOC_VTABLE_INHERIT
          && fixP->fx_r_type != BFD_RELOC_VTABLE_ENTRY);
}

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  long val = *valP;
  char *place = fixP->fx_where + fixP->fx_frag->fr_literal;

  switch (fixP->fx_r_type)
    {
    case RELOC_DLX_LO16:
    case RELOC_DLX_REL16:
      if (fixP->fx_bit_fixP != NULL)
	{
	  val = (val & 0x0000FFFF) | fixP->fx_bit_fixP->fx_bit_base;
	  free (fixP->fx_bit_fixP);
	  fixP->fx_bit_fixP = NULL;
	}
#ifdef DEBUG
      else
	know ((fixP->fx_bit_fixP != NULL));
#endif
      break;

    case RELOC_DLX_HI16:
      if (fixP->fx_bit_fixP != NULL)
	{
	  val = (val >> 16) | fixP->fx_bit_fixP->fx_bit_base;
	  free (fixP->fx_bit_fixP);
	  fixP->fx_bit_fixP = NULL;
	}
#ifdef DEBUG
      else
	know ((fixP->fx_bit_fixP != NULL));
#endif
      break;

    case RELOC_DLX_REL26:
      if (fixP->fx_bit_fixP != NULL)
	{
	  val = (val & 0x03FFFFFF) | fixP->fx_bit_fixP->fx_bit_base;
	  free (fixP->fx_bit_fixP);
	  fixP->fx_bit_fixP = NULL;
	}
#ifdef DEBUG
      else
	know ((fixP->fx_bit_fixP != NULL));
#endif
      break;

    case BFD_RELOC_VTABLE_INHERIT:
      /* This borrowed from tc-ppc.c on a whim.  */
      fixP->fx_done = 0;
      if (fixP->fx_addsy
	  && !S_IS_DEFINED (fixP->fx_addsy)
	  && !S_IS_WEAK (fixP->fx_addsy))
	S_SET_WEAK (fixP->fx_addsy);
      return;

    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

    default:
      break;
    }

  number_to_chars_bigendian (place, val, fixP->fx_size);
  if (fixP->fx_addsy == NULL)
    fixP->fx_done = 1;
}

const char *md_shortopts = "";

struct option md_longopts[] =
  {
    {NULL, no_argument, NULL, 0}
  };

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c     ATTRIBUTE_UNUSED,
		 char *arg ATTRIBUTE_UNUSED)
{
  return 0;
}

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
}

/* This is called when a line is unrecognized.  */

int
dlx_unrecognized_line (int c)
{
  int lab;
  char *s;

  if (c != '$' || ! ISDIGIT ((unsigned char) input_line_pointer[0]))
    return 0;

  s = input_line_pointer;

  lab = 0;
  while (ISDIGIT ((unsigned char) *s))
    {
      lab = lab * 10 + *s - '0';
      ++s;
    }

  if (*s != ':')
    /* Not a label definition.  */
    return 0;

  if (dollar_label_defined (lab))
    {
      as_bad (_("label \"$%d\" redefined"), lab);
      return 0;
    }

  define_dollar_label (lab);
  colon (dollar_label_name (lab, 0));
  input_line_pointer = s + 1;

  return 1;
}

/* Default the values of symbols known that should be "predefined".  We
   don't bother to predefine them unless you actually use one, since there
   are a lot of them.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return NULL;
}

/* Parse an operand that is machine-specific, the function was called
   in expr.c by operand() function, when everything failed before it
   call a quit.  */

void
md_operand (expressionS* expressionP)
{
  /* Check for the #number representation    */
  if (input_line_pointer[0] == '#' &&
      ISDIGIT ((unsigned char) input_line_pointer[1]))
    {
      /* We have a numeric number expression.  No biggy.  */
      input_line_pointer += 1;	/* Skip # */

      (void) expression (expressionP);

      if (expressionP->X_op != O_constant)
	as_bad (_("Invalid expression after # number\n"));
    }

  return;
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED,
		  valueT size)
{
  /* Byte alignment is fine.  */
  return size;
}

/* Exactly what point is a PC-relative offset relative TO?
   On the 29000, they're relative to the address of the instruction,
   which we have set up as the address of the fixup too.  */

long
md_pcrel_from (fixS* fixP)
{
  return 4 + fixP->fx_where + fixP->fx_frag->fr_address;
}

/* Translate internal representation of relocation info to BFD target
   format.
   FIXME: To what extent can we get all relevant targets to use this?
   The above FIXME is from a29k, but I think it is also needed here.    */

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED,
	      fixS *fixP)
{
  arelent * reloc;

  reloc = xmalloc (sizeof (arelent));
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);

  if (reloc->howto == NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("internal error: can't export reloc type %d (`%s')"),
		    fixP->fx_r_type,
		    bfd_get_reloc_code_name (fixP->fx_r_type));
      return NULL;
    }

  gas_assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;

  if (fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixP->fx_offset;
  reloc->addend = 0;

  return reloc;
}

const pseudo_typeS
dlx_pseudo_table[] =
{
  /* Some additional ops that are used by gcc-dlx.  */
  {"asciiz", stringer, 8 + 1},
  {"half", cons, 2},
  {"dword", cons, 8},
  {"word", cons, 4},
  {"proc", s_proc, 0},
  {"endproc", s_proc, 1},
  {NULL, NULL, 0}
};

void
dlx_pop_insert (void)
{
  pop_insert (dlx_pseudo_table);
  return ;
}
@


1.26
log
@	* config/tc-dlx.c (s_proc): Avoid warning about ignoring asprintf
	return value.
@
text
@d249 4
a252 2
	      if (asprintf (&label, "%c%s", leading_char, name))
		{ /* Avoid warning */ }
@


1.25
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d248 4
a251 1
	    asprintf (&label, "%c%s", leading_char, name);
@


1.24
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d1 2
a2 2
/* tc-ldx.c -- Assemble for the DLX
   Copyright 2002, 2003, 2004, 2005, 2007, 2009, 2010
d24 1
a25 1
#include "as.h"
@


1.23
log
@	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2007, 2009
a659 1
  char *argsStart;
a707 1
  argsStart = s;
@


1.22
log
@update copyright dates
@
text
@d912 2
@


1.22.2.1
log
@gas/
	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
gas/testsuite/
	* gas/d30v/serial2.l: Adjust position of page break.
	* gas/lns/lns-common-1-alt.d: Match 2009-04-24 change.
	* gas/mt/ms1-16-003.d: Correct reloc name.
	* gas/mt/relocs.d: Elide incorrect file format strings.
@
text
@a911 2
  dwarf2_emit_insn (4);

@


1.21
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2 2
a3 1
   Copyright 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.20
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d597 1
a597 1
  char *new;
d644 1
a644 1
  new = input_line_pointer;
d646 1
a646 1
  return new;
@


1.19
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1206 1
a1206 1
  assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);
a1237 1

@


1.18
log
@PR 5142: Allow for translation of error messages
@
text
@d978 2
a979 10
   but I'm not sure.

   Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */
/* Dlx will not use it anyway, so I just leave it here for now.  */

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6
d984 1
a984 49
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
@


1.17
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@d290 1
a290 1
	  fprintf (stderr, "internal error: can't hash `%s': %s\n",
d892 1
a892 1
      as_bad ("Invalid operands");
d1025 1
a1025 1
      return "Bad call to MD_ATOF()";
d1256 1
a1256 1
		    "internal error: can't export reloc type %d (`%s')",
@


1.16
log
@Switch to GPLv3
@
text
@d1279 1
a1279 1
  {"asciiz", stringer, 1},
@


1.15
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d8 1
a8 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.14
log
@Update the address and phone number of the FSF
@
text
@d1059 1
a1059 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.13
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d18 2
a19 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.12
log
@update copyright dates
@
text
@a60 29
/* static void print_insn PARAMS ((struct machine_it *)); */
char * parse_operand    PARAMS ((char *, expressionS *));
int md_chars_to_number  PARAMS ((unsigned char *, int));

static void machine_ip          PARAMS ((char *));
static void s_proc              PARAMS ((int));
static void insert_sreg         PARAMS ((char *, int));
static int  hilo_modifier_ok    PARAMS ((char *));
static int  is_ldst_registers   PARAMS ((char *));
static int  match_sft_register  PARAMS ((char *));
static void define_some_regs    PARAMS ((void));
static char * dlx_parse_loadop  PARAMS ((char *));
static char * dlx_parse_storeop PARAMS ((char *));
static char * fix_ld_st_operand PARAMS ((unsigned long, char *));

const pseudo_typeS

dlx_pseudo_table[] =
  {
    /* Some additional ops that are used by gcc-dlx.  */
    {"asciiz", stringer, 1},
    {"half", cons, 2},
    {"dword", cons, 8},
    {"word", cons, 4},
    {"proc", s_proc, 0},
    {"endproc", s_proc, 1},
    {NULL, 0, 0},
  };

d87 1
a87 3
insert_sreg (regname, regnum)
     char *regname;
     int regnum;
d107 1
a107 1
define_some_regs ()
d148 1
a148 1
/* Subroutine check the string to match an register, */
d151 1
a151 2
match_sft_register (name)
     char *name;
d182 1
a182 2
is_ldst_registers (name)
     char *name;
d199 1
a199 2
s_proc (end_p)
     int end_p;
d272 1
a272 1
md_begin ()
d286 1
a286 1
      retval = hash_insert (op_hash, name, (PTR) &machine_opcodes[i]);
a301 164
/* Assemble a single instruction.  Its label has already been handled
   by the generic front end.  We just parse opcode and operands, and
   produce the bytes of data and relocation.  */

void
md_assemble (str)
     char *str;
{
  char *toP;
  fixS *fixP;
  bit_fixS *bitP;

  know (str);
  machine_ip (str);
  toP = frag_more (4);
  /* Put out the opcode.  */
  md_number_to_chars (toP, the_insn.opcode, 4);

  /* Put out the symbol-dependent stuff.  */
  if (the_insn.reloc != NO_RELOC)
    {
      fixP = fix_new_exp (frag_now,
			  (toP - frag_now->fr_literal + the_insn.reloc_offset),
			  the_insn.size, & the_insn.exp, the_insn.pcrel,
			  the_insn.reloc);

      /* Turn off complaints that the addend is
	 too large for things like foo+100000@@ha.  */
      switch (the_insn.reloc)
	{
	case RELOC_DLX_HI16:
	case RELOC_DLX_LO16:
	  fixP->fx_no_overflow = 1;
	  break;
	default:
	  break;
	}

      switch (fixP->fx_r_type)
	{
	case RELOC_DLX_REL26:
	  bitP = malloc (sizeof (bit_fixS));
	  bitP->fx_bit_size = 26;
	  bitP->fx_bit_offset = 25;
	  bitP->fx_bit_base = the_insn.opcode & 0xFC000000;
	  bitP->fx_bit_base_adj = 0;
	  bitP->fx_bit_max = 0;
	  bitP->fx_bit_min = 0;
	  bitP->fx_bit_add = 0x03FFFFFF;
	  fixP->fx_bit_fixP = bitP;
	  break;
	case RELOC_DLX_LO16:
	case RELOC_DLX_REL16:
	  bitP = malloc (sizeof (bit_fixS));
	  bitP->fx_bit_size = 16;
	  bitP->fx_bit_offset = 15;
	  bitP->fx_bit_base = the_insn.opcode & 0xFFFF0000;
	  bitP->fx_bit_base_adj = 0;
	  bitP->fx_bit_max = 0;
	  bitP->fx_bit_min = 0;
	  bitP->fx_bit_add = 0x0000FFFF;
	  fixP->fx_bit_fixP = bitP;
	  break;
	case RELOC_DLX_HI16:
	  bitP = malloc (sizeof (bit_fixS));
	  bitP->fx_bit_size = 16;
	  bitP->fx_bit_offset = 15;
	  bitP->fx_bit_base = the_insn.opcode & 0xFFFF0000;
	  bitP->fx_bit_base_adj = 0;
	  bitP->fx_bit_max = 0;
	  bitP->fx_bit_min = 0;
	  bitP->fx_bit_add = 0x0000FFFF;
	  fixP->fx_bit_fixP = bitP;
	  break;
	default:
	  fixP->fx_bit_fixP = (bit_fixS *)NULL;
	  break;
	}
    }
}

static int
hilo_modifier_ok (s)
     char *s;
{
  char *ptr = s;
  int   idx, count = 1;

  if (*ptr != '(')
    return 1;

  for (idx = 1; ptr[idx] != '\0' && ptr[idx] != '[' && idx < 73; idx += 1)
    {
      if (count == 0)
	return count;

      if (ptr[idx] == '(')
	count += 1;

      if (ptr[idx] == ')')
	count -= 1;
    }

  return (count == 0) ? 1:0;
}

char *
parse_operand (s, operandp)
     char *s;
     expressionS *operandp;
{
  char *save = input_line_pointer;
  char *new;

  the_insn.HI = the_insn.LO = 0;

  /* Search for %hi and %lo, make a mark and skip it.  */
  if (strncmp (s, "%hi", 3) == 0)
    {
      s += 3;
      the_insn.HI = 1;
    }
  else
    {
      if (strncmp (s, "%lo", 3) == 0)
	{
	  s += 3;
	  the_insn.LO = 1;
	}
      else
	the_insn.LO = 0;
    }

  if (the_insn.HI || the_insn.LO)
    {
      if (!hilo_modifier_ok (s))
	as_bad (_("Expression Error for operand modifier %%hi/%%lo\n"));
    }

  /* Check for the % and $ register representation    */
  if ((s[0] == '%' || s[0] == '$' || s[0] == 'r' || s[0] == 'R')
      && ISDIGIT ((unsigned char) s[1]))
    {
      /* We have a numeric register expression.  No biggy.  */
      s += 1;
      input_line_pointer = s;
      (void) expression (operandp);
      if (operandp->X_op != O_constant
	  || operandp->X_add_number > 31)
	as_bad (_("Invalid expression after %%%%\n"));
      operandp->X_op = O_register;
    }
  else
    {
      /* Normal operand parsing.  */
      input_line_pointer = s;
      (void) expression (operandp);
    }

  new = input_line_pointer;
  input_line_pointer = save;
  return new;
}

d311 1
a311 2
dlx_parse_loadop (str)
     char * str;
d429 1
a429 2
dlx_parse_storeop (str)
     char * str;
d546 1
a546 3
fix_ld_st_operand (opcode, str)
     unsigned long opcode;
     char* str;
d569 80
d654 1
a654 2
machine_ip (str)
     char *str;
d897 80
d990 1
a990 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d1045 1
a1045 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
a1049 18
/* md_chars_to_number:  convert from target byte order to host byte order.  */

int
md_chars_to_number (val, n)
     unsigned char *val;	/* Value in target byte order.  */
     int n;			/* Number of bytes in the input.  */
{
  int retval;

  for (retval = 0; n--;)
    {
      retval <<= 8;
      retval |= val[n];
    }

  return retval;
}

d1051 1
a1051 2
md_dlx_fix_adjustable (fixP)
   fixS *fixP;
d1059 1
a1059 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d1068 1
a1068 1
      if (fixP->fx_bit_fixP != (bit_fixS *) NULL)
d1072 1
a1072 1
	  fixP->fx_bit_fixP = (bit_fixS *) NULL;
d1076 1
a1076 1
	know ((fixP->fx_bit_fixP != (bit_fixS *) NULL));
d1081 1
a1081 1
      if (fixP->fx_bit_fixP != (bit_fixS *) NULL)
d1085 1
a1085 1
	  fixP->fx_bit_fixP = (bit_fixS *)NULL;
d1089 1
a1089 1
	know ((fixP->fx_bit_fixP != (bit_fixS *) NULL));
d1094 1
a1094 1
      if (fixP->fx_bit_fixP != (bit_fixS *) NULL)
d1098 1
a1098 1
	  fixP->fx_bit_fixP = (bit_fixS *) NULL;
d1102 1
a1102 1
	know ((fixP->fx_bit_fixP != (bit_fixS *) NULL));
d1138 2
a1139 3
md_parse_option (c, arg)
     int c     ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d1145 1
a1145 2
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
d1152 1
a1152 2
dlx_unrecognized_line (c)
     int c;
d1170 2
a1171 4
    {
      /* Not a label definition.  */
      return 0;
    }
d1191 1
a1191 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
a1195 1

d1201 1
a1201 2
md_operand (expressionP)
     expressionS* expressionP;
d1222 2
a1223 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d1234 1
a1234 2
md_pcrel_from (fixP)
     fixS* fixP;
d1245 2
a1246 3
tc_gen_reloc (section, fixP)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixP;
d1250 1
a1250 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d1253 1
a1253 1
  if (reloc->howto == (reloc_howto_type *) NULL)
d1264 1
a1264 1
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d1275 12
a1286 1
extern void pop_insert PARAMS ((const pseudo_typeS *));
d1289 1
a1289 1
dlx_pop_insert ()
d1294 1
@


1.11
log
@	* as.h (assert): Warning fix.
	* expr.c (expr): Correct assertion.
	* read.c (s_comm_internal): Remove assertion.
	* write.c (relax_segment): Enable vma assertion only for BFD_ASSEMBLER.
	(fixup_segment): Remove assertion.
	* config/tc-dlx.c (machine_ip): Remove untrue assertions.
	(md_apply_fix3): Likewise.
	* config/tc-i370.c (md_begin): Correct assertion.
	(i370_macro): Warning fix for assertion.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.10
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@a974 1
	  know (operand->X_op != O_register);
a980 1
	  know (operand->X_op != O_register);
a986 1
	  know (operand->X_op != O_register);
a1134 3
  know (fixP->fx_size == 4);
  know (fixP->fx_r_type < NO_RELOC);

@


1.9
log
@Correctly emit lo16 relocs for elf-dlx target, fixing bogus range checking bug.
@
text
@a26 3
#if 0
#include "elf/dlx.h"
#endif
a139 35
#if 0
  /* Hardware representation.  */
  insert_sreg ("r0",    0);
  insert_sreg ("r1",    1);
  insert_sreg ("r2",    2);
  insert_sreg ("r3",    3);
  insert_sreg ("r4",    4);
  insert_sreg ("r5",    5);
  insert_sreg ("r6",    6);
  insert_sreg ("r7",    7);
  insert_sreg ("r8",    8);
  insert_sreg ("r9",    9);
  insert_sreg ("r10",   10);
  insert_sreg ("r11",   11);
  insert_sreg ("r12",   12);
  insert_sreg ("r13",   13);
  insert_sreg ("r14",   14);
  insert_sreg ("r15",   15);
  insert_sreg ("r16",   16);
  insert_sreg ("r17",   17);
  insert_sreg ("r18",   18);
  insert_sreg ("r19",   19);
  insert_sreg ("r20",   20);
  insert_sreg ("r21",   21);
  insert_sreg ("r22",   22);
  insert_sreg ("r23",   23);
  insert_sreg ("r24",   24);
  insert_sreg ("r25",   25);
  insert_sreg ("r26",   26);
  insert_sreg ("r27",   27);
  insert_sreg ("r28",   28);
  insert_sreg ("r29",   29);
  insert_sreg ("r30",   30);
  insert_sreg ("r31",   31);
#endif
a1301 27
#if 0
  else if (input_line_pointer[0] == '$'
	   && ISDIGIT ((unsigned char) input_line_pointer[1]))
    {
      long lab;
      char *name;
      symbolS *sym;

      /* This is a local label.  */
      ++input_line_pointer;
      lab = (long) get_absolute_expression ();
      if (dollar_label_defined (lab))
	{
	  name = dollar_label_name (lab, 0);
	  sym = symbol_find (name);
	}
      else
	{
	  name = dollar_label_name (lab, 1);
	  sym = symbol_find_or_make (name);
	}

      expressionP->X_op = O_symbol;
      expressionP->X_add_symbol = sym;
      expressionP->X_add_number = 0;
    }
#endif
a1325 24
/* From cgen.c:  */

#if 0
static short
tc_bfd_fix2rtype (fixP)
     fixS* fixP;
{
#if 0
  if (fixP->fx_bsr)
    abort ();
#endif

  if (fixP->fx_pcrel == 0 && fixP->fx_size == 4)
    return BFD_RELOC_32;

  if (fixP->fx_pcrel != 0 && fixP->fx_size == 4)
    return BFD_RELOC_26_PCREL;

  abort ();

  return 0;
}
#endif

@


1.8
log
@Remove redundant returns in void functions.
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d400 12
d425 1
d971 2
a972 1
	  the_insn.reloc        = (the_insn.HI) ? RELOC_DLX_HI16 : RELOC_DLX_16;
d1181 1
@


1.8.6.1
log
@Merge to 2.15 branch.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
a399 12
      /* Turn off complaints that the addend is
	 too large for things like foo+100000@@ha.  */
      switch (the_insn.reloc)
	{
	case RELOC_DLX_HI16:
	case RELOC_DLX_LO16:
	  fixP->fx_no_overflow = 1;
	  break;
	default:
	  break;
	}

a412 1
	case RELOC_DLX_LO16:
d958 1
a958 2
	  the_insn.reloc        = (the_insn.HI) ? RELOC_DLX_HI16 
	    : (the_insn.LO ? RELOC_DLX_LO16 : RELOC_DLX_16);
a1166 1
    case RELOC_DLX_LO16:
@


1.7
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-alpha.c: Likewise.
	* config/tc-alpha.h: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-dlx.h: Likewise.
@
text
@a371 1
  return;
a1225 1
  return;
a1248 1
  return;
@


1.6
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d634 1
a634 1
      /* Assemble the instruction to gas intrernal format.  */
d757 1
a757 1
      /* Assemble the instruction to gas intrernal format.  */
d1307 1
a1307 1
   in expr.c by operand() function, when everything failed bdfore it
@


1.5
log
@	* ChangeLog-9295: Fix a typo.
	* README: Likewise.
	* config/tc-d10v.c: Fix a comment typo.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-h8500.h: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-tic80.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* testsuite/gas/h8300/cmpsi2.s: Likewise.
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation, Inc.
a1142 12
}

/* Definition of TC_FORCE_RELOCATION.
   we need this for gas to force relocation for VTABLE.  */

int
md_dlx_force_relocation (fixp)
     struct fix *fixp;
{
  return (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
	  || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
	  || S_FORCE_RELOC (fixp->fx_addsy));
@


1.4
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d588 1
a588 1
	       '(' then this can be an normal expression, we'll treat
@


1.3
log
@gas reloc rewrite.
@
text
@d1157 1
a1157 1
boolean
@


1.2
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d1153 2
a1154 1
          || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY);
d1162 2
a1163 3
  return !(fixP->fx_addsy != NULL &&
           (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
            || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)) ;
d1169 1
a1169 1
     valueT * valP;
d1237 1
a1237 1
  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
d1445 4
a1448 5
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT ||
      fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->addend = fixP->fx_offset;
  else
    reloc->addend = fixP->fx_addnumber;
@


1.1
log
@Add DLX target
@
text
@d1242 1
a1242 1
CONST char *md_shortopts = "";
@

