head	1.37;
access;
symbols
	binutils-2_24-branch:1.37.0.10
	binutils-2_24-branchpoint:1.37
	binutils-2_21_1:1.37
	binutils-2_23_2:1.37
	binutils-2_23_1:1.37
	binutils-2_23:1.37
	binutils-2_23-branch:1.37.0.8
	binutils-2_23-branchpoint:1.37
	binutils-2_22_branch:1.37.0.6
	binutils-2_22:1.37
	binutils-2_22-branch:1.37.0.4
	binutils-2_22-branchpoint:1.37
	binutils-2_21:1.37
	binutils-2_21-branch:1.37.0.2
	binutils-2_21-branchpoint:1.37
	binutils-2_20_1:1.36.2.1
	binutils-2_20:1.36.2.1
	binutils-arc-20081103-branch:1.34.0.6
	binutils-arc-20081103-branchpoint:1.34
	binutils-2_20-branch:1.36.0.2
	binutils-2_20-branchpoint:1.36
	dje-cgen-play1-branch:1.35.0.2
	dje-cgen-play1-branchpoint:1.35
	arc-20081103-branch:1.34.0.4
	arc-20081103-branchpoint:1.34
	binutils-2_19_1:1.34
	binutils-2_19:1.34
	binutils-2_19-branch:1.34.0.2
	binutils-2_19-branchpoint:1.34
	binutils-2_18:1.31
	binutils-2_18-branch:1.31.0.2
	binutils-2_18-branchpoint:1.31
	binutils-csl-coldfire-4_1-32:1.29
	binutils-csl-sourcerygxx-4_1-32:1.29
	binutils-csl-innovasic-fido-3_4_4-33:1.29
	binutils-csl-sourcerygxx-3_4_4-32:1.27
	binutils-csl-coldfire-4_1-30:1.29
	binutils-csl-sourcerygxx-4_1-30:1.29
	binutils-csl-coldfire-4_1-28:1.29
	binutils-csl-sourcerygxx-4_1-29:1.29
	binutils-csl-sourcerygxx-4_1-28:1.29
	binutils-csl-arm-2006q3-27:1.29
	binutils-csl-sourcerygxx-4_1-27:1.29
	binutils-csl-arm-2006q3-26:1.29
	binutils-csl-sourcerygxx-4_1-26:1.29
	binutils-csl-sourcerygxx-4_1-25:1.29
	binutils-csl-sourcerygxx-4_1-24:1.29
	binutils-csl-sourcerygxx-4_1-23:1.29
	binutils-csl-sourcerygxx-4_1-21:1.29
	binutils-csl-arm-2006q3-21:1.29
	binutils-csl-sourcerygxx-4_1-22:1.29
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.29
	binutils-csl-sourcerygxx-4_1-20:1.29
	binutils-csl-arm-2006q3-19:1.29
	binutils-csl-sourcerygxx-4_1-19:1.29
	binutils-csl-sourcerygxx-4_1-18:1.29
	binutils-csl-renesas-4_1-9:1.29
	binutils-csl-sourcerygxx-3_4_4-25:1.27
	binutils-csl-renesas-4_1-8:1.29
	binutils-csl-renesas-4_1-7:1.29
	binutils-csl-renesas-4_1-6:1.29
	binutils-csl-sourcerygxx-4_1-17:1.29
	binutils-csl-sourcerygxx-4_1-14:1.29
	binutils-csl-sourcerygxx-4_1-15:1.29
	binutils-csl-sourcerygxx-4_1-13:1.29
	binutils-2_17:1.29
	binutils-csl-sourcerygxx-4_1-12:1.29
	binutils-csl-sourcerygxx-3_4_4-21:1.29
	binutils-csl-wrs-linux-3_4_4-24:1.27
	binutils-csl-wrs-linux-3_4_4-23:1.27
	binutils-csl-sourcerygxx-4_1-9:1.29
	binutils-csl-sourcerygxx-4_1-8:1.29
	binutils-csl-sourcerygxx-4_1-7:1.29
	binutils-csl-arm-2006q1-6:1.29
	binutils-csl-sourcerygxx-4_1-6:1.29
	binutils-csl-wrs-linux-3_4_4-22:1.27
	binutils-csl-coldfire-4_1-11:1.29
	binutils-csl-sourcerygxx-3_4_4-19:1.29
	binutils-csl-coldfire-4_1-10:1.29
	binutils-csl-sourcerygxx-4_1-5:1.29
	binutils-csl-sourcerygxx-4_1-4:1.29
	binutils-csl-wrs-linux-3_4_4-21:1.27
	binutils-csl-morpho-4_1-4:1.29
	binutils-csl-sourcerygxx-3_4_4-17:1.29
	binutils-csl-wrs-linux-3_4_4-20:1.27
	binutils-2_17-branch:1.29.0.4
	binutils-2_17-branchpoint:1.29
	binutils-csl-2_17-branch:1.29.0.2
	binutils-csl-2_17-branchpoint:1.29
	binutils-csl-gxxpro-3_4-branch:1.27.0.12
	binutils-csl-gxxpro-3_4-branchpoint:1.27
	binutils-2_16_1:1.27
	binutils-csl-arm-2005q1b:1.27
	binutils-2_16:1.27
	binutils-csl-arm-2005q1a:1.27
	binutils-csl-arm-2005q1-branch:1.27.0.10
	binutils-csl-arm-2005q1-branchpoint:1.27
	binutils-2_16-branch:1.27.0.8
	binutils-2_16-branchpoint:1.27
	csl-arm-2004-q3d:1.27
	csl-arm-2004-q3:1.27
	binutils-2_15:1.27
	binutils-2_15-branchpoint:1.27
	csl-arm-2004-q1a:1.27
	csl-arm-2004-q1:1.27
	binutils-2_15-branch:1.27.0.6
	cagney_bfdfile-20040213-branch:1.27.0.4
	cagney_bfdfile-20040213-branchpoint:1.27
	cagney_bigcore-20040122-branch:1.27.0.2
	cagney_bigcore-20040122-branchpoint:1.27
	csl-arm-2003-q4:1.27
	binutils-2_14:1.14
	binutils-2_14-branch:1.14.0.2
	binutils-2_14-branchpoint:1.14
	binutils-2_13_2_1:1.12
	binutils-2_13_2:1.12
	binutils-2_13_1:1.12
	binutils-2_13:1.12
	binutils-2_13-branchpoint:1.12
	binutils-2_13-branch:1.12.0.2
	binutils-2_12_1:1.11
	binutils-2_12:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	cygnus_cvs_20020108_pre:1.11
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.37
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2009.09.08.10.36.39;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.18.13.03.12;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.05.09.12.57;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.31.21.33.59;	author cpg;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.25.02.48.14;	author jle;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.07.19.20.45;	author jle;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.07.04.05.42;	author jle;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.06.23.59.35;	author jle;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.06.19.53.19;	author jle;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.06.04.31.58;	author jle;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.05.22.58.00;	author jle;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.02.03.03.52;	author jle;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.30.20.24.55;	author jle;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.24.04.22.22;	author jle;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.18.21.24.32;	author jle;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.12.03.35.34;	author jle;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.12.22.27.07;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.15.21.28.55;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.19.05.33.24;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.09.16.00.56.47;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.21.23.26.19;	author jle;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.16.21.34.45;	author jle;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.09.03.33.42;	author jle;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.09.00.00.03;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.06.22.14.52.55;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.36.2.1
date	2009.09.08.10.53.21;	author amodra;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.15.29;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.37
log
@	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
@
text
@/* tc-i860.c -- Assembler for the Intel i860 architecture.
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002,
   2003, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.

   Brought back from the dead and completely reworked
   by Jason Eckhardt <jle@@cygnus.com>.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with GAS; see the file COPYING.  If not, write to the Free Software
   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/i860.h"
#include "elf/i860.h"


/* The opcode hash table.  */
static struct hash_control *op_hash = NULL;

/* These characters always start a comment.  */
const char comment_chars[] = "#!/";

/* These characters start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#/";

const char line_separator_chars[] = ";";

/* Characters that can be used to separate the mantissa from the exponent
   in floating point numbers.  */
const char EXP_CHARS[] = "eE";

/* Characters that indicate this number is a floating point constant.
   As in 0f12.456 or 0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* Register prefix (depends on syntax).  */
static char reg_prefix;

#define MAX_FIXUPS 2

struct i860_it
{
  char *error;
  unsigned long opcode;
  enum expand_type expand;
  struct i860_fi
  {
    expressionS exp;
    bfd_reloc_code_real_type reloc;
    int pcrel;
    valueT fup;
  } fi[MAX_FIXUPS];
} the_insn;

/* The current fixup count.  */
static int fc;

static char *expr_end;

/* Indicates error if a pseudo operation was expanded after a branch.  */
static char last_expand;

/* If true, then warn if any pseudo operations were expanded.  */
static int target_warn_expand = 0;

/* If true, then XP support is enabled.  */
static int target_xp = 0;

/* If true, then Intel syntax is enabled (default to AT&T/SVR4 syntax).  */
static int target_intel_syntax = 0;


/* Prototypes.  */
static void i860_process_insn (char *);
static void s_dual (int);
static void s_enddual (int);
static void s_atmp (int);
static void s_align_wrapper (int);
static int i860_get_expression (char *);
static bfd_reloc_code_real_type obtain_reloc_for_imm16 (fixS *, long *); 
#ifdef DEBUG_I860
static void print_insn (struct i860_it *);
#endif

const pseudo_typeS md_pseudo_table[] =
{
  {"align",   s_align_wrapper, 0},
  {"dual",    s_dual,          0},
  {"enddual", s_enddual,       0},
  {"atmp",    s_atmp,          0},
  {NULL,      0,               0},
};

/* Dual-instruction mode handling.  */
enum dual
{
  DUAL_OFF = 0, DUAL_ON, DUAL_DDOT, DUAL_ONDDOT,
};
static enum dual dual_mode = DUAL_OFF;

/* Handle ".dual" directive.  */
static void
s_dual (int ignore ATTRIBUTE_UNUSED)
{
  if (target_intel_syntax)
    dual_mode = DUAL_ON;
  else
    as_bad (_("Directive .dual available only with -mintel-syntax option"));
}

/* Handle ".enddual" directive.  */
static void
s_enddual (int ignore ATTRIBUTE_UNUSED)
{
  if (target_intel_syntax)
    dual_mode = DUAL_OFF;
  else
    as_bad (_("Directive .enddual available only with -mintel-syntax option"));
}

/* Temporary register used when expanding assembler pseudo operations.  */
static int atmp = 31;

static void
s_atmp (int ignore ATTRIBUTE_UNUSED)
{
  int temp;

  if (! target_intel_syntax)
    {
      as_bad (_("Directive .atmp available only with -mintel-syntax option"));
      demand_empty_rest_of_line ();
      return;
    }

  if (strncmp (input_line_pointer, "sp", 2) == 0)
    {
      input_line_pointer += 2;
      atmp = 2;
    }
  else if (strncmp (input_line_pointer, "fp", 2) == 0)
    {
      input_line_pointer += 2;
      atmp = 3;
    }
  else if (strncmp (input_line_pointer, "r", 1) == 0)
    {
      input_line_pointer += 1;
      temp = get_absolute_expression ();
      if (temp >= 0 && temp <= 31)
	atmp = temp;
      else
	as_bad (_("Unknown temporary pseudo register"));
    }
  else
    {
      as_bad (_("Unknown temporary pseudo register"));
    }
  demand_empty_rest_of_line ();
}

/* Handle ".align" directive depending on syntax mode.
   AT&T/SVR4 syntax uses the standard align directive.  However, 
   the Intel syntax additionally allows keywords for the alignment
   parameter: ".align type", where type is one of {.short, .long,
   .quad, .single, .double} representing alignments of 2, 4,
   16, 4, and 8, respectively.  */
static void
s_align_wrapper (int arg)
{
  char *parm = input_line_pointer;

  if (target_intel_syntax)
    {
      /* Replace a keyword with the equivalent integer so the
         standard align routine can parse the directive.  */
      if (strncmp (parm, ".short", 6) == 0)
        strncpy (parm, "     2", 6);
      else if (strncmp (parm, ".long", 5) == 0)
        strncpy (parm, "    4", 5);
      else if (strncmp (parm, ".quad", 5) == 0)
        strncpy (parm, "   16", 5);
      else if (strncmp (parm, ".single", 7) == 0)
        strncpy (parm, "      4", 7);
      else if (strncmp (parm, ".double", 7) == 0)
        strncpy (parm, "      8", 7);
     
      while (*input_line_pointer == ' ')
        ++input_line_pointer;
    }

  s_align_bytes (arg);
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables and data structures that the MD part of the
   assembler will need.  */
void
md_begin (void)
{
  const char *retval = NULL;
  int lose = 0;
  unsigned int i = 0;

  op_hash = hash_new ();

  while (i860_opcodes[i].name != NULL)
    {
      const char *name = i860_opcodes[i].name;
      retval = hash_insert (op_hash, name, (void *) &i860_opcodes[i]);
      if (retval != NULL)
	{
	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
		   i860_opcodes[i].name, retval);
	  lose = 1;
	}
      do
	{
	  if (i860_opcodes[i].match & i860_opcodes[i].lose)
	    {
	      fprintf (stderr,
		       _("internal error: losing opcode: `%s' \"%s\"\n"),
		       i860_opcodes[i].name, i860_opcodes[i].args);
	      lose = 1;
	    }
	  ++i;
	}
      while (i860_opcodes[i].name != NULL
	     && strcmp (i860_opcodes[i].name, name) == 0);
    }

  if (lose)
    as_fatal (_("Defective assembler.  No assembly attempted."));

  /* Set the register prefix for either Intel or AT&T/SVR4 syntax.  */
  reg_prefix = target_intel_syntax ? 0 : '%';
}

/* This is the core of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function emits the frags/bytes
   it assembles to.  */
void
md_assemble (char *str)
{
  char *destp;
  int num_opcodes = 1;
  int i;
  struct i860_it pseudo[3];

  gas_assert (str);
  fc = 0;

  /* Assemble the instruction.  */
  i860_process_insn (str);

  /* Check for expandable flag to produce pseudo-instructions.  This
     is an undesirable feature that should be avoided.  */
  if (the_insn.expand != 0 && the_insn.expand != XP_ONLY
      && ! (the_insn.fi[0].fup & (OP_SEL_HA | OP_SEL_H | OP_SEL_L | OP_SEL_GOT
			    | OP_SEL_GOTOFF | OP_SEL_PLT)))
    {
      for (i = 0; i < 3; i++)
	pseudo[i] = the_insn;

      fc = 1;
      switch (the_insn.expand)
	{

	case E_DELAY:
	  num_opcodes = 1;
	  break;

	case E_MOV:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 15)
		  && the_insn.fi[0].exp.X_add_number >= -(1 << 15)))
	    break;

	  /* Emit "or l%const,r0,ireg_dest".  */
	  pseudo[0].opcode = (the_insn.opcode & 0x001f0000) | 0xe4000000;
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);

	  /* Emit "orh h%const,ireg_dest,ireg_dest".  */
	  pseudo[1].opcode = (the_insn.opcode & 0x03ffffff) | 0xec000000
			      | ((the_insn.opcode & 0x001f0000) << 5);
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);

	  num_opcodes = 2;
	  break;

	case E_ADDR:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 15)
		  && the_insn.fi[0].exp.X_add_number >= -(1 << 15)))
	    break;

	  /* Emit "orh ha%addr_expr,ireg_src2,r31".  */
	  pseudo[0].opcode = 0xec000000 | (the_insn.opcode & 0x03e00000)
			     | (atmp << 16);
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_HA);

	  /* Emit "l%addr_expr(r31),ireg_dest".  We pick up the fixup
	     information from the original instruction.   */
	  pseudo[1].opcode = (the_insn.opcode & ~0x03e00000) | (atmp << 21);
	  pseudo[1].fi[0].fup = the_insn.fi[0].fup | OP_SEL_L;

	  num_opcodes = 2;
	  break;

	case E_U32:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 16)
		  && the_insn.fi[0].exp.X_add_number >= 0))
	    break;

	  /* Emit "$(opcode)h h%const,ireg_src2,r31".  */
	  pseudo[0].opcode = (the_insn.opcode & 0xf3e0ffff) | 0x0c000000
			      | (atmp << 16);
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);

	  /* Emit "$(opcode) l%const,r31,ireg_dest".  */
	  pseudo[1].opcode = (the_insn.opcode & 0xf01f0000) | 0x04000000
			      | (atmp << 21);
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);

	  num_opcodes = 2;
	  break;

	case E_AND:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 16)
		  && the_insn.fi[0].exp.X_add_number >= 0))
	    break;

	  /* Emit "andnot h%const,ireg_src2,r31".  */
	  pseudo[0].opcode = (the_insn.opcode & 0x03e0ffff) | 0xd4000000
			      | (atmp << 16);
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);
	  pseudo[0].fi[0].exp.X_add_number =
            -1 - the_insn.fi[0].exp.X_add_number;

	  /* Emit "andnot l%const,r31,ireg_dest".  */
	  pseudo[1].opcode = (the_insn.opcode & 0x001f0000) | 0xd4000000
			      | (atmp << 21);
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);
	  pseudo[1].fi[0].exp.X_add_number =
            -1 - the_insn.fi[0].exp.X_add_number;

	  num_opcodes = 2;
	  break;

	case E_S32:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 15)
		  && the_insn.fi[0].exp.X_add_number >= -(1 << 15)))
	    break;

	  /* Emit "orh h%const,r0,r31".  */
	  pseudo[0].opcode = 0xec000000 | (atmp << 16);
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);

	  /* Emit "or l%const,r31,r31".  */
	  pseudo[1].opcode = 0xe4000000 | (atmp << 21) | (atmp << 16);
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);

	  /* Emit "r31,ireg_src2,ireg_dest".  */
	  pseudo[2].opcode = (the_insn.opcode & ~0x0400ffff) | (atmp << 11);
	  pseudo[2].fi[0].fup = OP_IMM_S16;

	  num_opcodes = 3;
	  break;

	default:
	  as_fatal (_("failed sanity check."));
	}

      the_insn = pseudo[0];

      /* Warn if an opcode is expanded after a delayed branch.  */
      if (num_opcodes > 1 && last_expand == 1)
	as_warn (_("Expanded opcode after delayed branch: `%s'"), str);

      /* Warn if an opcode is expanded in dual mode.  */
      if (num_opcodes > 1 && dual_mode != DUAL_OFF)
	as_warn (_("Expanded opcode in dual mode: `%s'"), str);

      /* Notify if any expansions happen.  */
      if (target_warn_expand && num_opcodes > 1)
	as_warn (_("An instruction was expanded (%s)"), str);
    }

  dwarf2_emit_insn (0);
  i = 0;
  do
    {
      int tmp;

      /* Output the opcode.  Note that the i860 always reads instructions
	 as little-endian data.  */
      destp = frag_more (4);
      number_to_chars_littleendian (destp, the_insn.opcode, 4);

      /* Check for expanded opcode after branch or in dual mode.  */
      last_expand = the_insn.fi[0].pcrel;

      /* Output the symbol-dependent stuff.  Only btne and bte will ever
         loop more than once here, since only they (possibly) have more
         than one fixup.  */
      for (tmp = 0; tmp < fc; tmp++)
        {
          if (the_insn.fi[tmp].fup != OP_NONE)
	    {
	      fixS *fix;
	      fix = fix_new_exp (frag_now,
			         destp - frag_now->fr_literal,
			         4,
			         &the_insn.fi[tmp].exp,
			         the_insn.fi[tmp].pcrel,
			         the_insn.fi[tmp].reloc);

	     /* Despite the odd name, this is a scratch field.  We use
	        it to encode operand type information.  */
	     fix->fx_addnumber = the_insn.fi[tmp].fup;
	   }
        }
      the_insn = pseudo[++i];
    }
  while (--num_opcodes > 0);

}

/* Assemble the instruction pointed to by STR.  */
static void
i860_process_insn (char *str)
{
  char *s;
  const char *args;
  char c;
  struct i860_opcode *insn;
  char *args_start;
  unsigned long opcode;
  unsigned int mask;
  int match = 0;
  int comma = 0;

#if 1 /* For compiler warnings.  */
  args = 0;
  insn = 0;
  args_start = 0;
  opcode = 0;
#endif

  for (s = str; ISLOWER (*s) || *s == '.' || *s == '3'
       || *s == '2' || *s == '1'; ++s)
    ;

  switch (*s)
    {
    case '\0':
      break;

    case ',':
      comma = 1;

      /*FALLTHROUGH*/

    case ' ':
      *s++ = '\0';
      break;

    default:
      as_fatal (_("Unknown opcode: `%s'"), str);
    }

  /* Check for dual mode ("d.") opcode prefix.  */
  if (strncmp (str, "d.", 2) == 0)
    {
      if (dual_mode == DUAL_ON)
	dual_mode = DUAL_ONDDOT;
      else
	dual_mode = DUAL_DDOT;
      str += 2;
    }

  if ((insn = (struct i860_opcode *) hash_find (op_hash, str)) == NULL)
    {
      if (dual_mode == DUAL_DDOT || dual_mode == DUAL_ONDDOT)
	str -= 2;
      as_bad (_("Unknown opcode: `%s'"), str);
      return;
    }

  if (comma)
    *--s = ',';

  args_start = s;
  for (;;)
    {
      int t;
      opcode = insn->match;
      memset (&the_insn, '\0', sizeof (the_insn));
      fc = 0;
      for (t = 0; t < MAX_FIXUPS; t++)
        {
          the_insn.fi[t].reloc = BFD_RELOC_NONE;
          the_insn.fi[t].pcrel = 0;
          the_insn.fi[t].fup = OP_NONE;
        }

      /* Build the opcode, checking as we go that the operands match.  */
      for (args = insn->args; ; ++args)
	{
          if (fc > MAX_FIXUPS)
            abort ();

	  switch (*args)
	    {

	    /* End of args.  */
	    case '\0':
	      if (*s == '\0')
		match = 1;
	      break;

	    /* These must match exactly.  */
	    case '+':
	    case '(':
	    case ')':
	    case ',':
	    case ' ':
	      if (*s++ == *args)
		continue;
	      break;

	    /* Must be at least one digit.  */
	    case '#':
	      if (ISDIGIT (*s++))
		{
		  while (ISDIGIT (*s))
		    ++s;
		  continue;
		}
	      break;

	    /* Next operand must be a register.  */
	    case '1':
	    case '2':
	    case 'd':
	      /* Check for register prefix if necessary.  */
	      if (reg_prefix && *s != reg_prefix)
		goto error;
	      else if (reg_prefix)
		s++;

	      switch (*s)
		{
		/* Frame pointer.  */
		case 'f':
		  s++;
		  if (*s++ == 'p')
		    {
		      mask = 0x3;
		      break;
		    }
		  goto error;

		/* Stack pointer.  */
		case 's':
		  s++;
		  if (*s++ == 'p')
		    {
		      mask = 0x2;
		      break;
		    }
		  goto error;

		/* Any register r0..r31.  */
		case 'r':
		  s++;
		  if (!ISDIGIT (c = *s++))
		    {
		      goto error;
		    }
		  if (ISDIGIT (*s))
		    {
		      if ((c = 10 * (c - '0') + (*s++ - '0')) >= 32)
			goto error;
		    }
		  else
		    c -= '0';
		  mask = c;
		  break;

		/* Not this opcode.  */
		default:
		  goto error;
		}

	      /* Obtained the register, now place it in the opcode.  */
	      switch (*args)
		{
		case '1':
		  opcode |= mask << 11;
		  continue;

		case '2':
		  opcode |= mask << 21;
		  continue;

		case 'd':
		  opcode |= mask << 16;
		  continue;

		}
	      break;

	    /* Next operand is a floating point register.  */
	    case 'e':
	    case 'f':
	    case 'g':
	      /* Check for register prefix if necessary.  */
	      if (reg_prefix && *s != reg_prefix)
		goto error;
	      else if (reg_prefix)
		s++;

	      if (*s++ == 'f' && ISDIGIT (*s))
		{
		  mask = *s++;
		  if (ISDIGIT (*s))
		    {
		      mask = 10 * (mask - '0') + (*s++ - '0');
		      if (mask >= 32)
			{
			  break;
			}
		    }
		  else
		    mask -= '0';

		  switch (*args)
		    {

		    case 'e':
		      opcode |= mask << 11;
		      continue;

		    case 'f':
		      opcode |= mask << 21;
		      continue;

		    case 'g':
		      opcode |= mask << 16;
		      if ((opcode & (1 << 10)) && mask != 0
			  && (mask == ((opcode >> 11) & 0x1f)))
			as_warn (_("Pipelined instruction: fsrc1 = fdest"));
		      continue;
		    }
		}
	      break;

	    /* Next operand must be a control register.  */
	    case 'c':
	      /* Check for register prefix if necessary.  */
	      if (reg_prefix && *s != reg_prefix)
		goto error;
	      else if (reg_prefix)
		s++;

	      if (strncmp (s, "fir", 3) == 0)
		{
		  opcode |= 0x0 << 21;
		  s += 3;
		  continue;
		}
	      if (strncmp (s, "psr", 3) == 0)
		{
		  opcode |= 0x1 << 21;
		  s += 3;
		  continue;
		}
	      if (strncmp (s, "dirbase", 7) == 0)
		{
		  opcode |= 0x2 << 21;
		  s += 7;
		  continue;
		}
	      if (strncmp (s, "db", 2) == 0)
		{
		  opcode |= 0x3 << 21;
		  s += 2;
		  continue;
		}
	      if (strncmp (s, "fsr", 3) == 0)
		{
		  opcode |= 0x4 << 21;
		  s += 3;
		  continue;
		}
	      if (strncmp (s, "epsr", 4) == 0)
		{
		  opcode |= 0x5 << 21;
		  s += 4;
		  continue;
		}
	      /* The remaining control registers are XP only.  */
	      if (target_xp && strncmp (s, "bear", 4) == 0)
		{
		  opcode |= 0x6 << 21;
		  s += 4;
		  continue;
		}
	      if (target_xp && strncmp (s, "ccr", 3) == 0)
		{
		  opcode |= 0x7 << 21;
		  s += 3;
		  continue;
		}
	      if (target_xp && strncmp (s, "p0", 2) == 0)
		{
		  opcode |= 0x8 << 21;
		  s += 2;
		  continue;
		}
	      if (target_xp && strncmp (s, "p1", 2) == 0)
		{
		  opcode |= 0x9 << 21;
		  s += 2;
		  continue;
		}
	      if (target_xp && strncmp (s, "p2", 2) == 0)
		{
		  opcode |= 0xa << 21;
		  s += 2;
		  continue;
		}
	      if (target_xp && strncmp (s, "p3", 2) == 0)
		{
		  opcode |= 0xb << 21;
		  s += 2;
		  continue;
		}
	      break;

	    /* 5-bit immediate in src1.  */
	    case '5':
	      if (! i860_get_expression (s))
		{
		  s = expr_end;
		  the_insn.fi[fc].fup |= OP_IMM_U5;
		  fc++;
		  continue;
		}
	      break;

	    /* 26-bit immediate, relative branch (lbroff).  */
	    case 'l':
	      the_insn.fi[fc].pcrel = 1;
	      the_insn.fi[fc].fup |= OP_IMM_BR26;
	      goto immediate;

	    /* 16-bit split immediate, relative branch (sbroff).  */
	    case 'r':
	      the_insn.fi[fc].pcrel = 1;
	      the_insn.fi[fc].fup |= OP_IMM_BR16;
	      goto immediate;

	    /* 16-bit split immediate.  */
	    case 's':
	      the_insn.fi[fc].fup |= OP_IMM_SPLIT16;
	      goto immediate;

	    /* 16-bit split immediate, byte aligned (st.b).  */
	    case 'S':
	      the_insn.fi[fc].fup |= OP_IMM_SPLIT16;
	      goto immediate;

	    /* 16-bit split immediate, half-word aligned (st.s).  */
	    case 'T':
	      the_insn.fi[fc].fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN2);
	      goto immediate;

	    /* 16-bit split immediate, word aligned (st.l).  */
	    case 'U':
	      the_insn.fi[fc].fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN4);
	      goto immediate;

	    /* 16-bit immediate.  */
	    case 'i':
	      the_insn.fi[fc].fup |= OP_IMM_S16;
	      goto immediate;

	    /* 16-bit immediate, byte aligned (ld.b).  */
	    case 'I':
	      the_insn.fi[fc].fup |= OP_IMM_S16;
	      goto immediate;

	    /* 16-bit immediate, half-word aligned (ld.s).  */
	    case 'J':
	      the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN2);
	      goto immediate;

	    /* 16-bit immediate, word aligned (ld.l, {p}fld.l, fst.l).  */
	    case 'K':
	      if (insn->name[0] == 'l')
		the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN4);
	      else
		the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE2 | OP_ALIGN4);
	      goto immediate;

	    /* 16-bit immediate, double-word aligned ({p}fld.d, fst.d).  */
	    case 'L':
	      the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN8);
	      goto immediate;

	    /* 16-bit immediate, quad-word aligned (fld.q, fst.q).  */
	    case 'M':
	      the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN16);

	      /*FALLTHROUGH*/

	      /* Handle the immediate for either the Intel syntax or
		 SVR4 syntax. The Intel syntax is "ha%immediate"
		 whereas SVR4 syntax is "[immediate]@@ha".  */
	    immediate:
	      if (target_intel_syntax == 0)
		{
		  /* AT&T/SVR4 syntax.  */
	          if (*s == ' ')
		    s++;

	          /* Note that if i860_get_expression() fails, we will still
	  	     have created U entries in the symbol table for the
		     'symbols' in the input string.  Try not to create U
		     symbols for registers, etc.  */
	          if (! i860_get_expression (s))
		    s = expr_end;
	          else
		    goto error;

	          if (strncmp (s, "@@ha", 3) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_HA;
		      s += 3;
		    }
	          else if (strncmp (s, "@@h", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_H;
		      s += 2;
		    }
	          else if (strncmp (s, "@@l", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_L;
		      s += 2;
		    }
	          else if (strncmp (s, "@@gotoff", 7) == 0
		           || strncmp (s, "@@GOTOFF", 7) == 0)
		    {
		      as_bad (_("Assembler does not yet support PIC"));
		      the_insn.fi[fc].fup |= OP_SEL_GOTOFF;
		      s += 7;
		    }
	          else if (strncmp (s, "@@got", 4) == 0
		           || strncmp (s, "@@GOT", 4) == 0)
		    {
		      as_bad (_("Assembler does not yet support PIC"));
		      the_insn.fi[fc].fup |= OP_SEL_GOT;
		      s += 4;
		    }
	          else if (strncmp (s, "@@plt", 4) == 0
		           || strncmp (s, "@@PLT", 4) == 0)
		    {
		      as_bad (_("Assembler does not yet support PIC"));
		      the_insn.fi[fc].fup |= OP_SEL_PLT;
		      s += 4;
		    }

	          the_insn.expand = insn->expand;
                  fc++;
              
	          continue;
		}
	      else
		{
		  /* Intel syntax.  */
	          if (*s == ' ')
		    s++;
	          if (strncmp (s, "ha%", 3) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_HA;
		      s += 3;
		    }
	          else if (strncmp (s, "h%", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_H;
		      s += 2;
		    }
	          else if (strncmp (s, "l%", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_L;
		      s += 2;
		    }
	          the_insn.expand = insn->expand;

	          /* Note that if i860_get_expression() fails, we will still
		     have created U entries in the symbol table for the
		     'symbols' in the input string.  Try not to create U
		     symbols for registers, etc.  */
	          if (! i860_get_expression (s))
		    s = expr_end;
	          else
		    goto error;

                  fc++;
	          continue;
		}
	      break;

	    default:
	      as_fatal (_("failed sanity check."));
	    }
	  break;
	}
    error:
      if (match == 0)
	{
	  /* Args don't match.  */
	  if (insn[1].name != NULL
	      && ! strcmp (insn->name, insn[1].name))
	    {
	      ++insn;
	      s = args_start;
	      continue;
	    }
	  else
	    {
	      as_bad (_("Illegal operands for %s"), insn->name);
	      return;
	    }
	}
      break;
    }

  /* Set the dual bit on this instruction if necessary.  */
  if (dual_mode != DUAL_OFF)
    {
      if ((opcode & 0xfc000000) == 0x48000000 || opcode == 0xb0000000)
        {
	  /* The instruction is a flop or a fnop, so set its dual bit
	     (but check that it is 8-byte aligned).  */
	  if (((frag_now->fr_address + frag_now_fix_octets ()) & 7) == 0)
	    opcode |= (1 << 9);
	  else
            as_bad (_("'d.%s' must be 8-byte aligned"), insn->name);

          if (dual_mode == DUAL_DDOT)
	    dual_mode = DUAL_OFF;
          else if (dual_mode == DUAL_ONDDOT)
	    dual_mode = DUAL_ON;
        }
      else if (dual_mode == DUAL_DDOT || dual_mode == DUAL_ONDDOT)
        as_bad (_("Prefix 'd.' invalid for instruction `%s'"), insn->name);
    }

  the_insn.opcode = opcode;

  /* Only recognize XP instructions when the user has requested it.  */
  if (insn->expand == XP_ONLY && ! target_xp)
    as_bad (_("Unknown opcode: `%s'"), insn->name);
}

static int
i860_get_expression (char *str)
{
  char *save_in;
  segT seg;

  save_in = input_line_pointer;
  input_line_pointer = str;
  seg = expression (&the_insn.fi[fc].exp);
  if (seg != absolute_section
      && seg != undefined_section
      && ! SEG_NORMAL (seg))
    {
      the_insn.error = _("bad segment");
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

/* Write out in current endian mode.  */
void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

/* This should never be called for i860.  */
int
md_estimate_size_before_relax (register fragS *fragP ATTRIBUTE_UNUSED,
			       segT segtype ATTRIBUTE_UNUSED)
{
  as_fatal (_("relaxation not supported\n"));
}

#ifdef DEBUG_I860
static void
print_insn (struct i860_it *insn)
{
  if (insn->error)
    fprintf (stderr, "ERROR: %s\n", insn->error);

  fprintf (stderr, "opcode = 0x%08lx\t", insn->opcode);
  fprintf (stderr, "expand = 0x%x\t", insn->expand);
  fprintf (stderr, "reloc = %s\t\n",
	   bfd_get_reloc_code_name (insn->reloc));
  fprintf (stderr, "exp =  {\n");
  fprintf (stderr, "\t\tX_add_symbol = %s\n",
	   insn->exp.X_add_symbol ?
	   (S_GET_NAME (insn->exp.X_add_symbol) ?
	    S_GET_NAME (insn->exp.X_add_symbol) : "???") : "0");
  fprintf (stderr, "\t\tX_op_symbol = %s\n",
	   insn->exp.X_op_symbol ?
	   (S_GET_NAME (insn->exp.X_op_symbol) ?
	    S_GET_NAME (insn->exp.X_op_symbol) : "???") : "0");
  fprintf (stderr, "\t\tX_add_number = %lx\n",
	   insn->exp.X_add_number);
  fprintf (stderr, "}\n");
}
#endif /* DEBUG_I860 */


#ifdef OBJ_ELF
const char *md_shortopts = "VQ:";
#else
const char *md_shortopts = "";
#endif

#define OPTION_EB		(OPTION_MD_BASE + 0)
#define OPTION_EL		(OPTION_MD_BASE + 1)
#define OPTION_WARN_EXPAND	(OPTION_MD_BASE + 2)
#define OPTION_XP		(OPTION_MD_BASE + 3)
#define OPTION_INTEL_SYNTAX	(OPTION_MD_BASE + 4)

struct option md_longopts[] = {
  { "EB",	    no_argument, NULL, OPTION_EB },
  { "EL",	    no_argument, NULL, OPTION_EL },
  { "mwarn-expand", no_argument, NULL, OPTION_WARN_EXPAND },
  { "mxp",	    no_argument, NULL, OPTION_XP },
  { "mintel-syntax",no_argument, NULL, OPTION_INTEL_SYNTAX },
  { NULL,	    no_argument, NULL, 0 }
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    case OPTION_EB:
      target_big_endian = 1;
      break;

    case OPTION_EL:
      target_big_endian = 0;
      break;

    case OPTION_WARN_EXPAND:
      target_warn_expand = 1;
      break;

    case OPTION_XP:
      target_xp = 1;
      break;

    case OPTION_INTEL_SYNTAX:
      target_intel_syntax = 1;
      break;

#ifdef OBJ_ELF
    /* SVR4 argument compatibility (-V): print version ID.  */
    case 'V':
      print_version_id ();
      break;

    /* SVR4 argument compatibility (-Qy, -Qn): controls whether
       a .comment section should be emitted or not (ignored).  */
    case 'Q':
      break;
#endif

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
  -EL			  generate code for little endian mode (default)\n\
  -EB			  generate code for big endian mode\n\
  -mwarn-expand		  warn if pseudo operations are expanded\n\
  -mxp			  enable i860XP support (disabled by default)\n\
  -mintel-syntax	  enable Intel syntax (default to AT&T/SVR4)\n"));
#ifdef OBJ_ELF
  /* SVR4 compatibility flags.  */
  fprintf (stream, _("\
  -V			  print assembler version number\n\
  -Qy, -Qn		  ignored\n"));
#endif
}


/* We have no need to default values of symbols.  */
symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* The i860 denotes auto-increment with '++'.  */
void
md_operand (expressionS *exp)
{
  char *s;

  for (s = input_line_pointer; *s; s++)
    {
      if (s[0] == '+' && s[1] == '+')
	{
	  input_line_pointer += 2;
	  exp->X_op = O_register;
	  break;
	}
    }
}

/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segT segment ATTRIBUTE_UNUSED,
		  valueT size ATTRIBUTE_UNUSED)
{
  /* Byte alignment is fine.  */
  return size;
}

/* On the i860, a PC-relative offset is relative to the address of the
   offset plus its size.  */
long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

/* Determine the relocation needed for non PC-relative 16-bit immediates.
   Also adjust the given immediate as necessary.  Finally, check that
   all constraints (such as alignment) are satisfied.   */
static bfd_reloc_code_real_type
obtain_reloc_for_imm16 (fixS *fix, long *val)
{
  valueT fup = fix->fx_addnumber;
  bfd_reloc_code_real_type reloc;

  if (fix->fx_pcrel)
    abort ();

  /* Check alignment restrictions.  */
  if ((fup & OP_ALIGN2) && (*val & 0x1))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 2 alignment"));
  else if ((fup & OP_ALIGN4) && (*val & 0x3))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 4 alignment"));
  else if ((fup & OP_ALIGN8) && (*val & 0x7))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 8 alignment"));
  else if ((fup & OP_ALIGN16) && (*val & 0xf))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 16 alignment"));

  if (fup & OP_SEL_HA)
    {
      *val = (*val >> 16) + (*val & 0x8000 ? 1 : 0);
      reloc = BFD_RELOC_860_HIGHADJ;
    }
  else if (fup & OP_SEL_H)
    {
      *val >>= 16;
      reloc = BFD_RELOC_860_HIGH;
    }
  else if (fup & OP_SEL_L)
    {
      int num_encode;
      if (fup & OP_IMM_SPLIT16)
	{
	  if (fup & OP_ENCODE1)
	    {
	      num_encode = 1;
	      reloc = BFD_RELOC_860_SPLIT1;
	    }
	  else if (fup & OP_ENCODE2)
	    {
	      num_encode = 2;
	      reloc = BFD_RELOC_860_SPLIT2;
	    }
	  else
	    {
	      num_encode = 0;
	      reloc = BFD_RELOC_860_SPLIT0;
	    }
	}
      else
	{
	  if (fup & OP_ENCODE1)
	    {
	      num_encode = 1;
	      reloc = BFD_RELOC_860_LOW1;
	    }
	  else if (fup & OP_ENCODE2)
	    {
	      num_encode = 2;
	      reloc = BFD_RELOC_860_LOW2;
	    }
	  else if (fup & OP_ENCODE3)
	    {
	      num_encode = 3;
	      reloc = BFD_RELOC_860_LOW3;
	    }
	  else
	    {
	      num_encode = 0;
	      reloc = BFD_RELOC_860_LOW0;
	    }
	}

      /* Preserve size encode bits.  */
      *val &= ~((1 << num_encode) - 1);
    }
  else
    {
      /* No selector.  What reloc do we generate (???)?  */
      reloc = BFD_RELOC_32;
    }

  return reloc;
}

/* Attempt to simplify or eliminate a fixup. To indicate that a fixup
   has been eliminated, set fix->fx_done. If fix->fx_addsy is non-NULL,
   we will have to generate a reloc entry.  */

void
md_apply_fix (fixS *fix, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *buf;
  long val = *valP;
  unsigned long insn;
  valueT fup;

  buf = fix->fx_frag->fr_literal + fix->fx_where;

  /* Recall that earlier we stored the opcode little-endian.  */
  insn = bfd_getl32 (buf);

  /* We stored a fix-up in this oddly-named scratch field.  */
  fup = fix->fx_addnumber;

  /* Determine the necessary relocations as well as inserting an
     immediate into the instruction.   */
  if (fup & OP_IMM_U5)
    {
      if (val & ~0x1f)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("5-bit immediate too large"));
      if (fix->fx_addsy)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("5-bit field must be absolute"));

      insn |= (val & 0x1f) << 11;
      bfd_putl32 (insn, buf);
      fix->fx_r_type = BFD_RELOC_NONE;
      fix->fx_done = 1;
    }
  else if (fup & OP_IMM_S16)
    {
      fix->fx_r_type = obtain_reloc_for_imm16 (fix, &val);

      /* Insert the immediate.  */
      if (fix->fx_addsy)
	fix->fx_done = 0;
      else
	{
	  insn |= val & 0xffff;
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup & OP_IMM_U16)
    abort ();

  else if (fup & OP_IMM_SPLIT16)
    {
      fix->fx_r_type = obtain_reloc_for_imm16 (fix, &val);

      /* Insert the immediate.  */
      if (fix->fx_addsy)
	fix->fx_done = 0;
      else
	{
	  insn |= val & 0x7ff;
	  insn |= (val & 0xf800) << 5;
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup & OP_IMM_BR16)
    {
      if (val & 0x3)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("A branch offset requires 0 MOD 4 alignment"));

      val = val >> 2;

      /* Insert the immediate.  */
      if (fix->fx_addsy)
	{
	  fix->fx_done = 0;
	  fix->fx_r_type = BFD_RELOC_860_PC16;
	}
      else
	{
	  insn |= (val & 0x7ff);
	  insn |= ((val & 0xf800) << 5);
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup & OP_IMM_BR26)
    {
      if (val & 0x3)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("A branch offset requires 0 MOD 4 alignment"));

      val >>= 2;

      /* Insert the immediate.  */
      if (fix->fx_addsy)
	{
	  fix->fx_r_type = BFD_RELOC_860_PC26;
	  fix->fx_done = 0;
	}
      else
	{
	  insn |= (val & 0x3ffffff);
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup != OP_NONE)
    {
      as_bad_where (fix->fx_file, fix->fx_line,
		    _("Unrecognized fix-up (0x%08lx)"), (unsigned long) fup);
      abort ();
    }
  else
    {
      /* I believe only fix-ups such as ".long .ep.main-main+0xc8000000"
 	 reach here (???).  */
      if (fix->fx_addsy)
	{
	  fix->fx_r_type = BFD_RELOC_32;
	  fix->fx_done = 0;
	}
      else
	{
	  insn |= (val & 0xffffffff);
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
}

/* Generate a machine dependent reloc from a fixup.  */
arelent*
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED,
	      fixS *fixp)
{
  arelent *reloc;

  reloc = xmalloc (sizeof (*reloc));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->addend = fixp->fx_offset;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (! reloc->howto)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    "Cannot represent %s relocation in object file",
                    bfd_get_reloc_code_name (fixp->fx_r_type));
    }
  return reloc;
}

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
i860_handle_align (fragS *fragp)
{
  /* Instructions are always stored little-endian on the i860.  */
  static const unsigned char le_nop[] = { 0x00, 0x00, 0x00, 0xA0 };

  int bytes;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;

  /* Make sure we are on a 4-byte boundary, in case someone has been
     putting data into a text section.  */
  if (bytes & 3)
    {
      int fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      fragp->fr_fix += fix;
    }

  memcpy (p, le_nop, 4);
  fragp->fr_var = 4;
}

/* This is called after a user-defined label is seen.  We check
   if the label has a double colon (valid in Intel syntax mode only),
   in which case it should be externalized.  */

void
i860_check_label (symbolS *labelsym)
{
  /* At this point, the current line pointer is sitting on the character
     just after the first colon on the label.  */ 
  if (target_intel_syntax && *input_line_pointer == ':')
    {
      S_SET_EXTERNAL (labelsym);
      input_line_pointer++;
    }
}
@


1.36
log
@update copyright dates
@
text
@d411 1
@


1.36.2.1
log
@gas/
	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
gas/testsuite/
	* gas/d30v/serial2.l: Adjust position of page break.
	* gas/lns/lns-common-1-alt.d: Match 2009-04-24 change.
	* gas/mt/ms1-16-003.d: Correct reloc name.
	* gas/mt/relocs.d: Elide incorrect file format strings.
@
text
@a410 1
  dwarf2_emit_insn (0);
@


1.35
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2003, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.34
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d264 1
a264 1
  assert (str);
a1491 1

@


1.33
log
@PR gas/5172
* config/tc-arc.c (md_estimate_size_before_relax): Change error message.
  (md_convert_frag): Just call abort.
* config/tc-i860.c (md_estimate_size_before_relax): Change error message.
* config/tc-i860.h (md_convert_frag): Just call abort.
* config/tc-ip2k.c (md_estimate_size_before_relax): Change error message.
  (md_convert_frag): Just call abort.
* config/tc-m68k.c (m68k_ip): Do not attempt translation of architecture names.
@
text
@d3 1
a3 1
   2003, 2006, 2007 Free Software Foundation, Inc.
d224 1
a224 1
      retval = hash_insert (op_hash, name, (PTR)&i860_opcodes[i]);
@


1.32
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1034 1
a1034 1
  as_fatal (_("i860_estimate_size_before_relax\n"));
@


1.31
log
@Switch to GPLv3
@
text
@a1012 8
/* Turn a string in input_line_pointer into a floating point constant of
   type TYPE, and store the appropriate bytes in *LITP.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is returned,
   or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

d1016 1
a1016 45
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
@


1.30
log
@remove some duplicate #include's.
@
text
@d3 1
a3 1
   2003, 2006 Free Software Foundation, Inc.
d12 1
a12 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.29
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2 2
a3 2
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a23 2
#include <stdio.h>
#include <string.h>
@


1.28
log
@Update the address and phone number of the FSF
@
text
@d1341 1
a1341 1
md_apply_fix3 (fixS *fix, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.27
log
@	* config/tc-i860.c (md_pcrel_from): Fix typo in comment.
@
text
@d22 1
a22 1
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.26
log
@2003-08-24  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c (md_assemble): Use isrc2 from the original
        instruction when expanding E_ADDR.
@
text
@d1236 1
a1236 1
   of the offset plus its size.  */
@


1.25
log
@2003-08-07  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c (i860_check_label): New function.
        * config/tc-i860.h (i860_check_label): New prototype.
        (tc_check_label): Define macro as i860_check_label.
@
text
@d315 3
a317 2
	  /* Emit "orh ha%addr_expr,r0,r31".  */
	  pseudo[0].opcode = 0xec000000 | (atmp << 16);
@


1.24
log
@2003-08-01  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c (s_align_wrapper): New function and prototype.
        (md_pseudo_table): Change s_align_bytes to s_align_wrapper, remove
        surrounding OBJ_ELF ifdef, and re-format slightly.
        * doc/c-i860.texi: Document the special .align syntax available
        in Intel mode.
@
text
@d1530 16
@


1.23
log
@gas:
2003-08-06  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c (i860_handle_align): New function.
        * config/tc-i860.h (HANDLE_ALIGN): Define macro.
        (MAX_MEM_FOR_RS_ALIGN_CODE): Define macro.

gas/testsuite:
2003-08-06  Jason Eckhardt  <jle@@rice.edu>

        * gas/i860/dir-align01.{s,d}: New files.
        * gas/i860/i860.exp: Execute the new test above.
@
text
@d94 1
d103 5
a107 7
#ifdef OBJ_ELF
  {"align",   s_align_bytes, 0},
#endif
  {"dual",    s_dual,        0},
  {"enddual", s_enddual,     0},
  {"atmp",    s_atmp,        0},
  {NULL,      0,             0},
d176 33
@


1.22
log
@gas:
2003-08-06  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c (i860_process_insn): Check that instructions
        with their dual-bit set are 8-byte aligned.

gas/testsuite:
2003-08-06  Jason Eckhardt  <jle@@rice.edu>

        * gas/i860/dual02-err.l: Update expected error message.
        * gas/i860/README.i860: Remove dual02-err from known failure list.
@
text
@d1465 33
@


1.21
log
@2003-08-05  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c (i860_process_insn): Don't handle dual-bit
        setting during flop argument parsing.  Instead, do it after
        instruction is fully parsed.
@
text
@d936 7
a942 1
	  opcode |= (1 << 9);
@


1.20
log
@2003-08-05  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c (s_dual): Accept .dual directive only in
        the Intel syntax mode.
        (s_enddual): Likewise for .enddual.
        (s_atmp): Likewise for .atmp.
@
text
@a640 6
		      if (dual_mode != DUAL_OFF)
			opcode |= (1 << 9);
		      if (dual_mode == DUAL_DDOT)
			dual_mode = DUAL_OFF;
		      if (dual_mode == DUAL_ONDDOT)
			dual_mode = DUAL_ON;
d929 15
@


1.19
log
@2003-08-01  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c: Remove SYNTAX_SVR4 macro and occurrences.
        (target_intel_syntax): Declare variable.
        (OPTION_INTEL_SYNTAX): Declare macro.
        (md_longopts): Add option -mintel-syntax.
        (md_parse_option): Set target_intel_syntax.
        (md_show_usage): Add -mintel-syntax usage.
        (md_begin): Set reg_prefix based on target_intel_syntax.
        (i860_process_insn): Skip register prefix only if there is one.
        Parse relocatable expressions in either Intel or AT&T syntax based
        on target_intel_syntax instead of the SYNTAX_SVR4 macro.
        * doc/c-i860.texi: Document -mintel-syntax option and give blurb
        about the differences in syntax.
@
text
@d122 4
a125 1
  dual_mode = DUAL_ON;
d132 4
a135 1
  dual_mode = DUAL_OFF;
d144 9
a152 1
  register int temp;
@


1.18
log
@bfd:
2003-07-30  Jason Eckhardt  <jle@@rice.edu>

        * elf32-i860.c: Convert to ISO C90.  Remove superflous prototypes.

gas:
2003-07-30  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c: Convert to ISO C90.
@
text
@a31 5
/* Defined by default since this is primarily a SVR4/860 assembler.
   However, I'm trying to leave the door open for Intel syntax. Of course,
   if full support for anything other than SVR4 is done, then we should
   select this based on a command-line flag.  */
#define SYNTAX_SVR4
d52 2
a53 6
/* Register prefix.  */
#ifdef SYNTAX_SVR4
static const char reg_prefix = '%';
#else
static const char reg_prefix = 0;
#endif
d85 4
d204 3
d525 1
a525 1
	      else
d597 1
a597 1
	      else
d646 1
a646 1
	      else
d805 14
a818 3
#ifdef SYNTAX_SVR4
	      if (*s == ' ')
		s++;
d820 36
a855 8
	      /* Note that if i860_get_expression() fails, we will still
		 have created U entries in the symbol table for the
		 'symbols' in the input string.  Try not to create U
		 symbols for registers, etc.  */
	      if (! i860_get_expression (s))
		s = expr_end;
	      else
		goto error;
d857 2
a858 39
	      if (strncmp (s, "@@ha", 3) == 0)
		{
		  the_insn.fi[fc].fup |= OP_SEL_HA;
		  s += 3;
		}
	      else if (strncmp (s, "@@h", 2) == 0)
		{
		  the_insn.fi[fc].fup |= OP_SEL_H;
		  s += 2;
		}
	      else if (strncmp (s, "@@l", 2) == 0)
		{
		  the_insn.fi[fc].fup |= OP_SEL_L;
		  s += 2;
		}
	      else if (strncmp (s, "@@gotoff", 7) == 0
		       || strncmp (s, "@@GOTOFF", 7) == 0)
		{
		  as_bad (_("Assembler does not yet support PIC"));
		  the_insn.fi[fc].fup |= OP_SEL_GOTOFF;
		  s += 7;
		}
	      else if (strncmp (s, "@@got", 4) == 0
		       || strncmp (s, "@@GOT", 4) == 0)
		{
		  as_bad (_("Assembler does not yet support PIC"));
		  the_insn.fi[fc].fup |= OP_SEL_GOT;
		  s += 4;
		}
	      else if (strncmp (s, "@@plt", 4) == 0
		       || strncmp (s, "@@PLT", 4) == 0)
		{
		  as_bad (_("Assembler does not yet support PIC"));
		  the_insn.fi[fc].fup |= OP_SEL_PLT;
		  s += 4;
		}

	      the_insn.expand = insn->expand;
              fc++;
d860 1
a860 8
	      continue;
#else /* ! SYNTAX_SVR4 */
	      if (*s == ' ')
		s++;
	      if (strncmp (s, "ha%", 3) == 0)
		{
		  the_insn.fi[fc].fup |= OP_SEL_HA;
		  s += 3;
d862 1
a862 1
	      else if (strncmp (s, "h%", 2) == 0)
d864 19
a882 9
		  the_insn.fi[fc].fup |= OP_SEL_H;
		  s += 2;
		}
	      else if (strncmp (s, "l%", 2) == 0)
		{
		  the_insn.fi[fc].fup |= OP_SEL_L;
		  s += 2;
		}
	      the_insn.expand = insn->expand;
d884 8
a891 8
	      /* Note that if i860_get_expression() fails, we will still
		 have created U entries in the symbol table for the
		 'symbols' in the input string.  Try not to create U
		 symbols for registers, etc.  */
	      if (! i860_get_expression (s))
		s = expr_end;
	      else
		goto error;
d893 3
a895 3
              fc++;
	      continue;
#endif /* SYNTAX_SVR4 */
d1066 1
d1073 1
d1099 4
d1129 2
a1130 1
  -mxp			  enable i860XP support (disabled by default)\n"));
@


1.17
log
@2003-05-23  Jason Eckhardt  <jle@@rice.edu>
gas:
        * config/tc-i860.c (target_xp): Declare variable.
        (OPTION_XP): Declare macro.
        (md_longopts): Add option -mxp.
        (md_parse_option): Set target_xp.
        (md_show_usage): Add -mxp usage.
        (i860_process_insn): Recognize XP registers bear, ccr, p0-p3.
        (md_assemble): Don't try expansions if XP_ONLY is set.
        * doc/c-i860.texi: Document -mxp option.

gas/testsuite:
        * gas/i860/xp.s: New file.
        * gas/i860/xp.d: New file.

include/opcode:
        * i860.h (expand_type): Add XP_ONLY.
        (scyc.b): New XP instruction.
        (ldio.l): Likewise.
        (ldio.s): Likewise.
        (ldio.b): Likewise.
        (ldint.l): Likewise.
        (ldint.s): Likewise.
        (ldint.b): Likewise.
        (stio.l): Likewise.
        (stio.s): Likewise.
        (stio.b): Likewise.
        (pfld.q): Likewise.

opcodes:
        * i860-dis.c (crnames): Add bear, ccr, p0, p1, p2, p3.
        (print_insn_i860): Grab 4 bits of the control register field
        instead of 3.
@
text
@d95 6
a100 7
static void i860_process_insn	PARAMS ((char *));
static void s_dual		PARAMS ((int));
static void s_enddual		PARAMS ((int));
static void s_atmp		PARAMS ((int));
static int i860_get_expression	PARAMS ((char *));
static bfd_reloc_code_real_type obtain_reloc_for_imm16
  PARAMS ((fixS *, long *));
d102 1
a102 1
static void print_insn		PARAMS ((struct i860_it *));
d125 1
a125 2
s_dual (ignore)
     int ignore ATTRIBUTE_UNUSED;
d132 1
a132 2
s_enddual (ignore)
     int ignore ATTRIBUTE_UNUSED;
d141 1
a141 2
s_atmp (ignore)
     int ignore ATTRIBUTE_UNUSED;
d174 1
a174 1
md_begin ()
d215 1
a215 2
md_assemble (str)
     char *str;
d409 1
a409 2
i860_process_insn (str)
     char *str;
d928 1
a928 2
i860_get_expression (str)
     char *str;
d959 1
a959 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d1010 1
a1010 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d1020 2
a1021 3
md_estimate_size_before_relax (fragP, segtype)
     register fragS *fragP ATTRIBUTE_UNUSED;
     segT segtype ATTRIBUTE_UNUSED;
d1028 1
a1028 2
print_insn (insn)
     struct i860_it *insn;
d1074 1
a1074 3
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
d1114 1
a1114 2
md_show_usage (stream)
     FILE *stream;
d1132 1
a1132 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1139 1
a1139 2
md_operand (exp)
     expressionS *exp;
d1156 2
a1157 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size ATTRIBUTE_UNUSED;
d1166 1
a1166 2
md_pcrel_from (fixP)
     fixS *fixP;
d1175 1
a1175 3
obtain_reloc_for_imm16 (fix, val)
     fixS *fix;
     long *val;
d1269 1
a1269 4
md_apply_fix3 (fix, valP, seg)
     fixS * fix;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d1406 2
a1407 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
@


1.16
log
@2003-05-18  Jason Eckhardt  <jle@@rice.edu>
gas:
        * config/tc-i860.c (i860_process_insn): Initialize fc after
        each opcode mismatch.

include/opcode:
        * i860.h (form, pform): Add missing .dd suffix.

opcodes:
        * i860-dis.c (print_insn_i860): Instruction shrd has a dual bit,
        print it.

bfd:
        * elf32-i860.c (elf32_i860_relocate_highadj): Simplify calculation.
@
text
@d2 1
a2 1
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002
d91 3
d235 1
a235 1
  if (the_insn.expand != 0
d693 37
d927 4
d1077 1
d1083 1
d1107 4
d1137 2
a1138 1
  -mwarn-expand		  warn if pseudo operations are expanded\n"));
@


1.15
log
@2003-05-11  Jason Eckhardt  <jle@@rice.edu>

        * config/tc-i860.c (MAX_FIXUPS): Define.
        (struct i860_fi fi[]): New struct.
        (struct i860_it the_insn): Add above as member and move fields
        exp, reloc, pcrel and fup into i860_fi.
        (md_assemble): Replace all instances of exp, reloc, pcrel
        and fup with fi[].exp, fi[].reloc, fi[].pcrel, fi[].fup.
        Add a loop to possibly emit multiple fix-ups for each insn.
        (i860_process_insn): Likewise.
        (i860_get_expression): Likewise.
        (md_apply_fix3): Use a bitwise check for OP_IMM_U5, not equality.
@
text
@d480 1
@


1.14
log
@	* config/tc-i860.c (md_atof): Remove declaration of atof_ieee.
	(md_number_to_disp, md_number_to_field): Remove.
	(md_apply_fix3): Correct format string and cast "fup".
@
text
@d64 2
a69 1
  expressionS exp;
d71 7
a77 3
  bfd_reloc_code_real_type reloc;
  int pcrel;
  valueT fup;
d80 3
d225 1
d233 1
a233 1
      && ! (the_insn.fup & (OP_SEL_HA | OP_SEL_H | OP_SEL_L | OP_SEL_GOT
d239 1
d248 4
a251 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 15)
		  && the_insn.exp.X_add_number >= -(1 << 15)))
d256 1
a256 1
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_L);
d261 1
a261 1
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_H);
d267 4
a270 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 15)
		  && the_insn.exp.X_add_number >= -(1 << 15)))
d275 1
a275 1
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_HA);
d280 1
a280 1
	  pseudo[1].fup = the_insn.fup | OP_SEL_L;
d286 4
a289 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 16)
		  && the_insn.exp.X_add_number >= 0))
d295 1
a295 1
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_H);
d300 1
a300 1
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_L);
d306 4
a309 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 16)
		  && the_insn.exp.X_add_number >= 0))
d315 3
a317 2
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_H);
	  pseudo[0].exp.X_add_number = -1 - the_insn.exp.X_add_number;
d322 3
a324 2
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_L);
	  pseudo[1].exp.X_add_number = -1 - the_insn.exp.X_add_number;
d330 4
a333 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 15)
		  && the_insn.exp.X_add_number >= -(1 << 15)))
d338 1
a338 1
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_H);
d342 1
a342 1
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_L);
d346 1
a346 1
	  pseudo[2].fup = OP_IMM_S16;
d373 2
d381 1
a381 1
      last_expand = the_insn.pcrel;
d383 20
a402 15
      /* Output the symbol-dependent stuff.  */
      if (the_insn.fup != OP_NONE)
	{
	  fixS *fix;
	  fix = fix_new_exp (frag_now,
			     destp - frag_now->fr_literal,
			     4,
			     &the_insn.exp,
			     the_insn.pcrel,
			     the_insn.reloc);

	  /* Despite the odd name, this is a scratch field.  We use
	     it to encode operand type information.  */
	  fix->fx_addnumber = the_insn.fup;
	}
d477 1
d480 6
a485 3
      the_insn.reloc = BFD_RELOC_NONE;
      the_insn.pcrel = 0;
      the_insn.fup = OP_NONE;
d490 3
d696 2
a697 1
		  the_insn.fup |= OP_IMM_U5;
d704 2
a705 2
	      the_insn.pcrel = 1;
	      the_insn.fup |= OP_IMM_BR26;
d710 2
a711 2
	      the_insn.pcrel = 1;
	      the_insn.fup |= OP_IMM_BR16;
d716 1
a716 1
	      the_insn.fup |= OP_IMM_SPLIT16;
d721 1
a721 1
	      the_insn.fup |= OP_IMM_SPLIT16;
d726 1
a726 1
	      the_insn.fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN2);
d731 1
a731 1
	      the_insn.fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN4);
d736 1
a736 1
	      the_insn.fup |= OP_IMM_S16;
d741 1
a741 1
	      the_insn.fup |= OP_IMM_S16;
d746 1
a746 1
	      the_insn.fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN2);
d752 1
a752 1
		the_insn.fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN4);
d754 1
a754 1
		the_insn.fup |= (OP_IMM_S16 | OP_ENCODE2 | OP_ALIGN4);
d759 1
a759 1
	      the_insn.fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN8);
d764 1
a764 1
	      the_insn.fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN16);
d787 1
a787 1
		  the_insn.fup |= OP_SEL_HA;
d792 1
a792 1
		  the_insn.fup |= OP_SEL_H;
d797 1
a797 1
		  the_insn.fup |= OP_SEL_L;
d804 1
a804 1
		  the_insn.fup |= OP_SEL_GOTOFF;
d811 1
a811 1
		  the_insn.fup |= OP_SEL_GOT;
d818 1
a818 1
		  the_insn.fup |= OP_SEL_PLT;
d823 2
a824 1

d831 1
a831 1
		  the_insn.fup |= OP_SEL_HA;
d836 1
a836 1
		  the_insn.fup |= OP_SEL_H;
d841 1
a841 1
		  the_insn.fup |= OP_SEL_L;
d855 1
d897 1
a897 1
  seg = expression (&the_insn.exp);
d1261 1
a1261 1
  if (fup == OP_IMM_U5)
@


1.13
log
@gas reloc rewrite.
@
text
@a900 1
  char *atof_ieee ();
a957 20
void
md_number_to_disp (buf, val, n)
     char *buf ATTRIBUTE_UNUSED;
     long val ATTRIBUTE_UNUSED;
     int n ATTRIBUTE_UNUSED;
{
  as_fatal (_("md_number_to_disp\n"));
}

/* This should never be called for i860.  */
void
md_number_to_field (buf, val, fix)
     char *buf ATTRIBUTE_UNUSED;
     long val ATTRIBUTE_UNUSED;
     void *fix ATTRIBUTE_UNUSED;
{
  as_fatal (_("i860_number_to_field\n"));
}

/* This should never be called for i860.  */
d1328 1
a1328 1
		    _("Unrecognized fix-up (0x%08x)"), fup);
@


1.12
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d1239 1
a1239 1
  long val = * (long *) valP
@


1.11
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001
d1016 1
a1016 1
CONST char *md_shortopts = "VQ:";
d1018 1
a1018 1
CONST char *md_shortopts = "";
@


1.10
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1231 5
a1235 4
int
md_apply_fix3 (fix, valuep, seg)
     fixS *fix;
     valueT *valuep;
a1237 1

d1239 1
a1239 1
  long val = (long) (*valuep);
d1283 2
a1284 3
    {
      abort ();
    }
a1368 3

  /* Return value ignored.  */
  return 0;
@


1.9
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000
a23 1
#include <ctype.h>
d27 1
d412 1
a412 1
  for (s = str; islower (*s) || *s == '.' || *s == '3'
d488 1
a488 1
	      if (isdigit (*s++))
d490 1
a490 1
		  while (isdigit (*s))
d531 1
a531 1
		  if (!isdigit (c = *s++))
d535 1
a535 1
		  if (isdigit (*s))
d578 1
a578 1
	      if (*s++ == 'f' && isdigit (*s))
d581 1
a581 1
		  if (isdigit (*s))
@


1.8
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000
@


1.7
log
@2000-09-15  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-h8300.h: Fix formatting.
	* config/tc-h8500.c: Likewise.
	* config/tc-h8500.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
@
text
@d1239 1
a1239 1
  long val = (long)(*valuep);
@


1.6
log
@2000-08-21  Jason Eckhardt  <jle@@cygnus.com>
bfd:
	* elf32-i860.c (elf32_i860_relocate_pc16): Just write the immediate
	field with the newly relocated value instead of adding it to the
	existing immediate field.
	(elf32_i860_relocate_splitn): Likewise.
	(elf32_i860_relocate_highadj): Likewise.

gas:
	* config/tc-i860.c (md_apply_fix3): Do not insert the immediate
	if the fixup resulted in a relocation.
@
text
@a31 1

a37 1

a56 1

a63 1

a82 1

a94 1

a105 1

a112 1

a120 1

a128 1

a162 1

a203 1

d381 1
a381 1
	     it to encode operand type information.  */ 
a389 1

a858 1

a882 1

a944 1

a957 1

a967 1

a977 1

a986 1

a1013 1

a1020 1

a1032 1

a1070 1

a1095 1

a1113 1

a1123 1

a1132 1

d1142 1
a1142 1
  bfd_reloc_code_real_type reloc;  
a1227 1

d1301 1
a1301 1
    } 
d1349 1
a1349 1
      as_bad_where (fix->fx_file, fix->fx_line, 
a1374 1

a1397 1

@


1.5
log
@2000-08-16  Jason Eckhardt  <jle@@cygnus.com>

        * config/tc-i860.c (md_operand): Silly typo fixed.
@
text
@d1301 9
a1309 4
      insn |= val & 0xffff;
      bfd_putl32 (insn, buf);

      fix->fx_done = (fix->fx_addsy == 0);
d1320 10
a1329 5
      insn |= val & 0x7ff;
      insn |= (val & 0xf800) << 5;
      bfd_putl32 (insn, buf);

      fix->fx_done = (fix->fx_addsy == 0);
d1340 13
a1352 6
      insn |= (val & 0x7ff);
      insn |= ((val & 0xf800) << 5);
      bfd_putl32 (insn, buf);

      fix->fx_r_type = BFD_RELOC_860_PC16;
      fix->fx_done = (fix->fx_addsy == 0);
d1363 12
a1374 5
      insn |= (val & 0x3ffffff);
      bfd_putl32 (insn, buf);

      fix->fx_r_type = BFD_RELOC_860_PC26;
      fix->fx_done = (fix->fx_addsy == 0);
d1386 12
a1397 4
      insn |= (val & 0xffffffff);
      bfd_putl32 (insn, buf);
      fix->fx_r_type = BFD_RELOC_32;
      fix->fx_done = (fix->fx_addsy == 0);
@


1.4
log
@
gas:
2000-08-08  Jason Eckhardt  <jle@@cygnus.com>

	* config/tc-i860.h: Rework completely for BFD_ASSEMBLER.
	(i860_fix_info): New enum.
	(MD_APPLY_FIX3): Define.
	(WORKING_DOT_WORD): Define.
	(TC_HANDLES_FX_DONE): Define.
	(DIFF_EXPR_OK): Define.
	(LISTING_HEADER): Define.
	(TARGET_FORMAT): Select target format based on endian flag.
	(TARGET_BYTES_BIG_ENDIAN): Default to little endian.
	(target_big_endian): Add external declaration.

	* config/tc-i860.c: All existing code reworked completely. Other
	new code shown below.
	(SYNTAX_SVR4): Define.
	(target_warn_expand): New variable.
	(md_shortopts): Declare and define (-Qy, -Qn, and -V options).
	(md_longopts): Declare and define with new options (-EL, -EB,
	and -mwarn-expand).
	(md_show_usage): New function.
	(md_operand): New function.
	(obtain_reloc_for_imm16): New function.
	(md_apply_fix3): New function.
	(tc_gen_reloc): New function.

include:
2000-08-08  Jason Eckhardt  <jle@@cygnus.com>

	* opcode/i860.h: Small formatting adjustments.

opcode:
2000-08-08  Jason Eckhardt  <jle@@cygnus.com>

	* i860-dis.c (print_br_address): Change third argument from int
	to long.

bfd:
2000-08-08  Jason Eckhardt  <jle@@cygnus.com>
	* elf32-i860.c (elf32_i860_howto_table): Updated some fields.
@
text
@d1128 1
a1128 1
  for (s = input_line_pointer; s; s++)
@


1.3
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d1 6
a6 2
/* tc-i860.c -- Assemble for the I860
   Copyright (C) 1989, 92, 93, 94, 95, 98, 1999 Free Software Foundation, Inc.
d24 3
d28 1
a28 1

d30 1
a31 12
void md_begin ();
void md_number_to_chars ();
void md_assemble ();
char *md_atof ();
void md_convert_frag ();
int md_estimate_size_before_relax ();
void md_number_to_imm ();
void md_number_to_disp ();
void md_number_to_field ();
void md_ri_to_chars ();
static void i860_ip ();
/* void emit_machine_reloc(); */
d33 5
a37 1
const int md_reloc_size = sizeof (struct relocation_info);
a38 1
/* void (*md_emit_relocations)() = emit_machine_reloc; */
d40 1
a40 1
/* handle of the OPCODE hash table */
d43 2
a44 11
static void s_dual (), s_enddual ();
static void s_atmp ();

const pseudo_typeS
  md_pseudo_table[] =
{
  {"dual", s_dual, 4},
  {"enddual", s_enddual, 4},
  {"atmp", s_atmp, 4},
  {NULL, 0, 0},
};
d46 1
a46 11
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful */
const char comment_chars[] = "!/";	/* JF removed '|' from comment_chars */

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output. */
/* Also note that comments like this one will always work. */
d51 2
a52 1
/* Chars that can be used to separate mant from exp in floating point nums */
d55 2
a56 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d59 8
a66 9
/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c .  Ideally it shouldn't have to know about it at all,
   but nothing is ideal around here.
   */
int size_reloc_info = sizeof (struct relocation_info);

static unsigned char octal[256];
#define isoctal(c)  octal[c]
static unsigned char toHex[256];
d69 9
a77 15
  {
    char *error;
    unsigned long opcode;
    struct nlist *nlistp;
    expressionS exp;
    int pcrel;
    enum expand_type expand;
    enum highlow_type highlow;
    enum reloc_type reloc;
  } the_insn;

#if __STDC__ == 1

static void print_insn (struct i860_it *insn);
static int getExpression (char *str);
d79 20
a98 1
#else /* not __STDC__ */
a99 2
static void print_insn ();
static int getExpression ();
d101 10
a110 1
#endif /* not __STDC__ */
a111 2
static char *expr_end;
static char last_expand;	/* error if expansion after branch */
d113 1
d118 1
a118 1
static enum dual dual_mode = DUAL_OFF;	/* dual-instruction mode */
d120 2
d123 2
a124 1
s_dual ()			/* floating point instructions have dual set */
d129 2
d132 2
a133 1
s_enddual ()			/* floating point instructions have dual set */
d138 3
a140 1
static int atmp = 31;		/* temporary register for pseudo's */
d143 2
a144 1
s_atmp ()
d173 1
d175 2
a176 1
   set up all the tables, etc. that the MD part of the assembler will need.  */
d180 1
a180 1
  register char *retval = NULL;
d182 1
a182 1
  register unsigned int i = 0;
d186 1
a186 1
  while (i < NUMOPCODES)
d189 1
a189 1
      retval = hash_insert (op_hash, name, &i860_opcodes[i]);
d200 2
a201 1
	      fprintf (stderr, _("internal error: losing opcode: `%s' \"%s\"\n"),
d207 2
a208 2
      while (i < NUMOPCODES
	     && !strcmp (i860_opcodes[i].name, name));
d212 2
a213 1
    as_fatal (_("Broken assembler.  No assembly attempted."));
a214 9
  for (i = '0'; i < '8'; ++i)
    octal[i] = 1;
  for (i = '0'; i <= '9'; ++i)
    toHex[i] = i - '0';
  for (i = 'a'; i <= 'f'; ++i)
    toHex[i] = i + 10 - 'a';
  for (i = 'A'; i <= 'F'; ++i)
    toHex[i] = i + 10 - 'A';
}
d216 3
d223 2
a224 3
  char *toP;
  int rsd;
  int no_opcodes = 1;
a228 1
  i860_ip (str);
d230 8
a237 2
  /* check for expandable flag to produce pseudo-instructions */
  if (the_insn.expand != 0 && the_insn.highlow == NO_SPEC)
d246 1
a246 1
	  no_opcodes = 1;
d250 4
a253 4
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL &&
	      (the_insn.exp.X_add_number < (1 << 15) &&
	       the_insn.exp.X_add_number >= -(1 << 15)))
d255 2
a256 1
	  /* or l%const,r0,ireg_dest */
d258 8
a265 6
	  pseudo[0].highlow = PAIR;
	  /* orh h%const,ireg_dest,ireg_dest */
	  pseudo[1].opcode = (the_insn.opcode & 0x03ffffff) | 0xec000000 |
	    ((the_insn.opcode & 0x001f0000) << 5);
	  pseudo[1].highlow = HIGH;
	  no_opcodes = 2;
d269 4
a272 2
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL)
d274 2
a275 1
	  /* orh ha%addr_expr,r0,r31 */
d277 8
a284 6
	  pseudo[0].highlow = HIGHADJ;
	  pseudo[0].reloc = LOW0;	/* must overwrite */
	  /* l%addr_expr(r31),ireg_dest */
	  pseudo[1].opcode = (the_insn.opcode & ~0x003e0000) | (atmp << 21);
	  pseudo[1].highlow = PAIR;
	  no_opcodes = 2;
d287 5
a291 5
	case E_U32:		/* 2nd version emulates Intel as, not doc. */
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL &&
	      (the_insn.exp.X_add_number < (1 << 16) &&
	       the_insn.exp.X_add_number >= 0))
d293 12
a304 14
	  /* $(opcode)h h%const,ireg_src2,ireg_dest
			   pseudo[0].opcode = (the_insn.opcode & 0xf3ffffff) | 0x0c000000; */
	  /* $(opcode)h h%const,ireg_src2,r31 */
	  pseudo[0].opcode = (the_insn.opcode & 0xf3e0ffff) | 0x0c000000 |
	    (atmp << 16);
	  pseudo[0].highlow = HIGH;
	  /* $(opcode) l%const,ireg_dest,ireg_dest
			   pseudo[1].opcode = (the_insn.opcode & 0xf01f0000) | 0x04000000 |
			   ((the_insn.opcode & 0x001f0000) << 5); */
	  /* $(opcode) l%const,r31,ireg_dest */
	  pseudo[1].opcode = (the_insn.opcode & 0xf01f0000) | 0x04000000 |
	    (atmp << 21);
	  pseudo[1].highlow = PAIR;
	  no_opcodes = 2;
d307 5
a311 5
	case E_AND:		/* 2nd version emulates Intel as, not doc. */
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL &&
	      (the_insn.exp.X_add_number < (1 << 16) &&
	       the_insn.exp.X_add_number >= 0))
d313 5
a317 6
	  /* andnot h%const,ireg_src2,ireg_dest
			   pseudo[0].opcode = (the_insn.opcode & 0x03ffffff) | 0xd4000000; */
	  /* andnot h%const,ireg_src2,r31 */
	  pseudo[0].opcode = (the_insn.opcode & 0x03e0ffff) | 0xd4000000 |
	    (atmp << 16);
	  pseudo[0].highlow = HIGH;
d319 5
a323 7
	  /* andnot l%const,ireg_dest,ireg_dest
			   pseudo[1].opcode = (the_insn.opcode & 0x001f0000) | 0xd4000000 |
			   ((the_insn.opcode & 0x001f0000) << 5); */
	  /* andnot l%const,r31,ireg_dest */
	  pseudo[1].opcode = (the_insn.opcode & 0x001f0000) | 0xd4000000 |
	    (atmp << 21);
	  pseudo[1].highlow = PAIR;
d325 2
a326 1
	  no_opcodes = 2;
d330 4
a333 4
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL &&
	      (the_insn.exp.X_add_number < (1 << 15) &&
	       the_insn.exp.X_add_number >= -(1 << 15)))
d335 2
a336 1
	  /* orh h%const,r0,r31 */
d338 3
a340 2
	  pseudo[0].highlow = HIGH;
	  /* or l%const,r31,r31 */
d342 3
a344 2
	  pseudo[1].highlow = PAIR;
	  /* r31,ireg_src2,ireg_dest */
d346 3
a348 2
	  pseudo[2].reloc = NO_RELOC;
	  no_opcodes = 3;
d356 3
a358 2
      /* check for expanded opcode after branch or in dual */
      if (no_opcodes > 1 && last_expand == 1)
d360 3
a362 1
      if (no_opcodes > 1 && dual_mode != DUAL_OFF)
d364 4
d372 5
a376 4
    {				/* always produce at least one opcode */
      toP = frag_more (4);
      /* put out the opcode */
      md_number_to_chars (toP, the_insn.opcode, 4);
d378 1
a378 1
      /* check for expanded opcode after branch or in dual */
d381 2
a382 2
      /* put out the symbol-dependent stuff */
      if (the_insn.reloc != NO_RELOC)
d384 11
a394 7
	  fix_new (frag_now,	/* which frag */
		   (toP - frag_now->fr_literal),	/* where */
		   4,		/* size */
		   &the_insn.exp,
		   the_insn.pcrel,
	  /* merge bit fields into one argument */
	  (int) (((the_insn.highlow & 0x3) << 4) | (the_insn.reloc & 0xf)));
d398 1
a398 1
  while (--no_opcodes > 0);
d402 2
d405 1
a405 1
i860_ip (str)
a410 1
  unsigned long i;
d412 1
a412 1
  char *argsStart;
d418 6
d425 2
a426 1
  for (s = str; islower (*s) || *s == '.' || *s == '3'; ++s)
d428 1
a430 1

d447 1
d449 1
a449 1
    {				/* check for d. opcode prefix */
d464 1
d466 3
a468 4
    {
      *--s = ',';
    }
  argsStart = s;
d473 3
a475 1
      the_insn.reloc = NO_RELOC;
d477 2
a478 5
      /*
		 * Build the opcode, checking as we go to make
		 * sure that the operands match
		 */
      for (args = insn->args;; ++args)
d483 2
a484 1
	    case '\0':		/* end of args */
d486 1
a486 3
		{
		  match = 1;
		}
d489 1
d491 1
a491 1
	    case '(':		/* these must match exactly */
d499 2
a500 1
	    case '#':		/* must be at least one digit */
d504 1
a504 3
		    {
		      ++s;
		    }
d509 2
a510 1
	    case '1':		/* next operand must be a register */
d513 6
d521 2
a522 2

		case 'f':	/* frame pointer */
d531 2
a532 1
		case 's':	/* stack pointer */
d541 2
a542 1
		case 'r':	/* any register */
d551 1
a551 3
			{
			  goto error;
			}
d554 1
a554 3
		    {
		      c -= '0';
		    }
d558 2
a559 1
		default:	/* not this opcode */
d562 2
a563 4
	      /*
				 * Got the register, now figure out where
				 * it goes in the opcode.
				 */
a565 1

d581 2
a582 1
	    case 'e':		/* next operand is a floating point register */
d585 6
d603 2
a604 3
		    {
		      mask -= '0';
		    }
d619 1
a619 1
			opcode |= (1 << 9);	/* dual mode instruction */
d624 3
a626 2
		      if ((opcode & (1 << 10)) && (mask == ((opcode >> 11) & 0x1f)))
			as_warn (_("Fsr1 equals fdest with Pipelining"));
d632 8
a639 1
	    case 'c':		/* next operand must be a control register */
d678 3
a680 3
	    case '5':		/* 5 bit immediate in src1 */
	      memset (&the_insn, '\0', sizeof (the_insn));
	      if (!getExpression (s))
d683 1
a683 5
		  if (the_insn.exp.X_add_number & ~0x1f)
		    as_bad (_("5-bit immediate too large"));
		  opcode |= (the_insn.exp.X_add_number & 0x1f) << 11;
		  memset (&the_insn, '\0', sizeof (the_insn));
		  the_insn.reloc = NO_RELOC;
d688 2
a689 2
	    case 'l':		/* 26 bit immediate, relative branch */
	      the_insn.reloc = BRADDR;
d691 1
d694 2
a695 2
	    case 's':		/* 16 bit immediate, split relative branch */
	      /* upper 5 bits of offset in dest field */
d697 36
a732 1
	      the_insn.reloc = SPLIT0;
d735 4
a738 6
	    case 'S':		/* 16 bit immediate, split (st), aligned */
	      if (opcode & (1 << 28))
		if (opcode & 0x1)
		  the_insn.reloc = SPLIT2;
		else
		  the_insn.reloc = SPLIT1;
d740 1
a740 1
		the_insn.reloc = SPLIT0;
d743 3
a745 8
	    case 'I':		/* 16 bit immediate, aligned */
	      if (opcode & (1 << 28))
		if (opcode & 0x1)
		  the_insn.reloc = LOW2;
		else
		  the_insn.reloc = LOW1;
	      else
		the_insn.reloc = LOW0;
d748 3
a750 2
	    case 'i':		/* 16 bit immediate */
	      the_insn.reloc = LOW0;
d754 3
d758 54
d816 1
a816 1
		  the_insn.highlow = HIGHADJ;
d821 1
a821 1
		  the_insn.highlow = HIGH;
d826 1
a826 1
		  the_insn.highlow = PAIR;
d831 8
a838 4
	      /* Note that if the getExpression() fails, we will still have
				   created U entries in the symbol table for the 'symbols'
				   in the input string.  Try not to create U symbols for
				   registers, etc. */
d840 2
a841 5
	      if (!getExpression (s))
		{
		  s = expr_end;
		  continue;
		}
d853 2
a854 2
	  if (&insn[1] - i860_opcodes < NUMOPCODES
	      && !strcmp (insn->name, insn[1].name))
d857 1
a857 1
	      s = argsStart;
d862 1
a862 1
	      as_bad (_("Illegal operands"));
d872 1
d874 1
a874 1
getExpression (str)
d898 4
a901 8
/*
  This is identical to the md_atof in m68k.c.  I think this is right,
  but I'm not sure.

  Turn a string in input_line_pointer into a floating point constant of type
  type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
  emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
  */
d903 1
a903 1
/* Equal to MAX_PRECISION in atof-ieee.c */
a919 1

d960 2
a961 3
/*
 * Write out big-endian.
 */
d968 4
a971 1
  number_to_chars_bigendian (buf, val, n);
a973 29
void
md_number_to_imm (buf, val, n, fixP)
     char *buf;
     long val;
     int n;
     fixS *fixP;
{
  enum reloc_type reloc = fixP->fx_r_type & 0xf;
  enum highlow_type highlow = (fixP->fx_r_type >> 4) & 0x3;

  assert (buf);
  assert (n == 4);		/* always on i860 */

  switch (highlow)
    {

    case HIGHADJ:		/* adjusts the high-order 16-bits */
      if (val & (1 << 15))
	val += (1 << 16);

      /*FALLTHROUGH*/

    case HIGH:			/* selects the high-order 16-bits */
      val >>= 16;
      break;

    case PAIR:			/* selects the low-order 16-bits */
      val = val & 0xffff;
      break;
d975 1
a975 77
    default:
      break;
    }

  switch (reloc)
    {

    case BRADDR:		/* br,call,bc,bc.t,bnc,bnc.t w/26-bit immediate */
      if (fixP->fx_pcrel != 1)
	as_bad (_("26-bit branch w/o pc relative set: 0x%08x"), val);
      val >>= 2;		/* align pcrel offset, see manual */

      if (val >= (1 << 25) || val < -(1 << 25))	/* check for overflow */
	as_bad (_("26-bit branch offset overflow: 0x%08x"), val);
      buf[0] = (buf[0] & 0xfc) | ((val >> 24) & 0x3);
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case SPLIT2:		/* 16 bit immediate, 4-byte aligned */
      if (val & 0x3)
	as_bad (_("16-bit immediate 4-byte alignment error: 0x%08x"), val);
      val &= ~0x3;		/* 4-byte align value */
      /*FALLTHROUGH*/
    case SPLIT1:		/* 16 bit immediate, 2-byte aligned */
      if (val & 0x1)
	as_bad (_("16-bit immediate 2-byte alignment error: 0x%08x"), val);
      val &= ~0x1;		/* 2-byte align value */
      /*FALLTHROUGH*/
    case SPLIT0:		/* st,bla,bte,btne w/16-bit immediate */
      if (fixP->fx_pcrel == 1)
	val >>= 2;		/* align pcrel offset, see manual */
      /* check for bounds */
      if (highlow != PAIR && (val >= (1 << 16) || val < -(1 << 15)))
	as_bad (_("16-bit branch offset overflow: 0x%08x"), val);
      buf[1] = (buf[1] & ~0x1f) | ((val >> 11) & 0x1f);
      buf[2] = (buf[2] & ~0x7) | ((val >> 8) & 0x7);
      buf[3] |= val;		/* perserve bottom opcode bits */
      break;

    case LOW4:			/* fld,pfld,pst,flush 16-byte aligned */
      if (val & 0xf)
	as_bad (_("16-bit immediate 16-byte alignment error: 0x%08x"), val);
      val &= ~0xf;		/* 16-byte align value */
      /*FALLTHROUGH*/
    case LOW3:			/* fld,pfld,pst,flush 8-byte aligned */
      if (val & 0x7)
	as_bad (_("16-bit immediate 8-byte alignment error: 0x%08x"), val);
      val &= ~0x7;		/* 8-byte align value */
      /*FALLTHROUGH*/
    case LOW2:			/* 16 bit immediate, 4-byte aligned */
      if (val & 0x3)
	as_bad (_("16-bit immediate 4-byte alignment error: 0x%08x"), val);
      val &= ~0x3;		/* 4-byte align value */
      /*FALLTHROUGH*/
    case LOW1:			/* 16 bit immediate, 2-byte aligned */
      if (val & 0x1)
	as_bad (_("16-bit immediate 2-byte alignment error: 0x%08x"), val);
      val &= ~0x1;		/* 2-byte align value */
      /*FALLTHROUGH*/
    case LOW0:			/* 16 bit immediate, byte aligned */
      /* check for bounds */
      if (highlow != PAIR && (val >= (1 << 16) || val < -(1 << 15)))
	as_bad (_("16-bit immediate overflow: 0x%08x"), val);
      buf[2] = val >> 8;
      buf[3] |= val;		/* perserve bottom opcode bits */
      break;

    case NO_RELOC:
    default:
      as_bad (_("bad relocation type: 0x%02x"), reloc);
      break;
    }
}

/* should never be called for i860 */
d978 3
a980 2
     char *buf;
     long val;
d985 2
a986 1
/* should never be called for i860 */
d989 3
a991 3
     char *buf;
     long val;
     void *fix;
a995 39
/* the bit-field entries in the relocation_info struct plays hell
   with the byte-order problems of cross-assembly.  So as a hack,
   I added this mach. dependent ri twiddler.  Ugly, but it gets
   you there. -KWK */
/* on i860: first 4 bytes are normal unsigned long address, next three
   bytes are index, most sig. byte first.  Byte 7 is broken up with
   bit 7 as pcrel, bit 6 as extern, and the lower six bits as
   relocation type (highlow 5-4).  Next 4 bytes are long addend. */
/* Thanx and a tip of the hat to Michael Bloom, mb@@ttidca.tti.com */
void
md_ri_to_chars (ri_p, ri)
     struct relocation_info *ri_p, ri;
{
#if 0
  unsigned char the_bytes[sizeof (*ri_p)];

  /* this is easy */
  md_number_to_chars (the_bytes, ri.r_address, sizeof (ri.r_address));
  /* now the fun stuff */
  the_bytes[4] = (ri.r_index >> 16) & 0x0ff;
  the_bytes[5] = (ri.r_index >> 8) & 0x0ff;
  the_bytes[6] = ri.r_index & 0x0ff;
  the_bytes[7] = ((ri.r_extern << 7) & 0x80) | (0 & 0x60) | (ri.r_type & 0x1F);
  /* Also easy */
  md_number_to_chars (&the_bytes[8], ri.r_addend, sizeof (ri.r_addend));
  /* now put it back where you found it, Junior... */
  memcpy ((char *) ri_p, the_bytes, sizeof (*ri_p));
#endif
}

/* should never be called for i860 */
void
md_convert_frag (headers, seg, fragP)
     object_headers *headers;
     segT seg;
     register fragS *fragP;
{
  as_fatal (_("i860_convert_frag\n"));
}
d997 1
a997 1
/* should never be called for i860 */
d1000 2
a1001 2
     register fragS *fragP;
     segT segtype;
d1006 2
a1007 22
/* for debugging only, must match enum reloc_type */
static char *Reloc[] =
{
  "NO_RELOC",
  "BRADDR",
  "LOW0",
  "LOW1",
  "LOW2",
  "LOW3",
  "LOW4",
  "SPLIT0",
  "SPLIT1",
  "SPLIT2",
  "RELOC_32",
};
static char *Highlow[] =
{
  "NO_SPEC",
  "PAIR",
  "HIGH",
  "HIGHADJ",
};
d1013 6
a1018 7
    {
      fprintf (stderr, "ERROR: %s\n");
    }
  fprintf (stderr, "opcode=0x%08x\t", insn->opcode);
  fprintf (stderr, "expand=0x%08x\t", insn->expand);
  fprintf (stderr, "reloc = %s\t", Reloc[insn->reloc]);
  fprintf (stderr, "highlow = %s\n", Highlow[insn->highlow]);
d1028 1
a1028 1
  fprintf (stderr, "\t\tX_add_number = %d\n",
d1032 3
d1036 3
d1040 7
d1048 4
a1051 1
  {NULL, no_argument, NULL, 0}
d1053 2
a1054 1
size_t md_longopts_size = sizeof(md_longopts);
d1059 1
a1059 1
     char *arg;
d1061 31
a1091 1
  return 0;
d1094 1
d1099 10
d1110 1
d1112 10
a1121 5
#ifdef comment
/*
 * I860 relocations are completely different, so it needs
 * this machine dependent routine to emit them.
 */
d1123 2
a1124 3
emit_machine_reloc (fixP, segment_address_in_file)
     register fixS *fixP;
     relax_addressT segment_address_in_file;
d1126 1
a1126 4
  struct reloc_info_i860 ri;
  register symbolS *symbolP;
  extern char *next_object_file_charP;
  long add_number;
d1128 1
a1128 2
  memset ((char *) &ri, '\0', sizeof (ri));
  for (; fixP; fixP = fixP->fx_next)
d1130 1
a1130 2

      if (fixP->fx_r_type & ~0x3f)
d1132 3
a1134 1
	  as_fatal ("fixP->fx_r_type = %d\n", fixP->fx_r_type);
d1136 2
a1137 2
      ri.r_pcrel = fixP->fx_pcrel;
      ri.r_type = fixP->fx_r_type;
d1139 64
a1202 1
      if ((symbolP = fixP->fx_addsy) != NULL)
d1204 6
a1209 3
	  ri.r_address = fixP->fx_frag->fr_address +
	    fixP->fx_where - segment_address_in_file;
	  if (!S_IS_DEFINED (symbolP))
d1211 2
a1212 2
	      ri.r_extern = 1;
	      ri.r_symbolnum = symbolP->sy_number;
d1216 2
a1217 2
	      ri.r_extern = 0;
	      ri.r_symbolnum = S_GET_TYPE (symbolP);
d1219 9
a1227 1
	  if (symbolP && symbol_get_frag (symbolP))
d1229 2
a1230 1
	      ri.r_addend = symbol_get_frag (symbolP)->fr_address;
d1232 1
a1232 2
	  ri.r_type = fixP->fx_r_type;
	  if (fixP->fx_pcrel)
d1234 2
a1235 2
	      /* preserve actual offset vs. pc + 4 */
	      ri.r_addend -= (ri.r_address + 4);
d1239 2
a1240 1
	      ri.r_addend = fixP->fx_addnumber;
d1242 1
d1244 7
a1250 3
	  md_ri_to_chars ((char *) &ri, ri);
	  append (&next_object_file_charP, (char *) &ri, sizeof (ri));
	}
d1252 2
a1255 1
#endif /* comment */
d1257 9
a1265 1
#ifdef OBJ_AOUT
d1267 4
a1270 4
/* on i860: first 4 bytes are normal unsigned long address, next three
   bytes are index, most sig. byte first.  Byte 7 is broken up with
   bit 7 as pcrel, bit 6 as extern, and the lower six bits as
   relocation type (highlow 5-4).  Next 4 bytes are long addend. */
d1272 4
a1275 10
void
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  long r_index;
  long r_extern;
  long r_addend = 0;
  long r_address;
d1277 2
a1278 2
  know (fixP->fx_addsy);
  know (!(fixP->fx_r_type & ~0x3f));
d1280 3
a1282 1
  if (!S_IS_DEFINED (fixP->fx_addsy))
d1284 11
a1294 2
      r_extern = 1;
      r_index = fixP->fx_addsy->sy_number;
d1296 1
a1296 1
  else
d1298 1
a1298 7
      r_extern = 0;
      r_index = S_GET_TYPE (fixP->fx_addsy);
    }

  md_number_to_chars (where,
		      r_address = fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
		      4);
d1300 3
a1302 6
  where[4] = (r_index >> 16) & 0x0ff;
  where[5] = (r_index >> 8) & 0x0ff;
  where[6] = r_index & 0x0ff;
  where[7] = (((fixP->fx_pcrel << 7) & 0x80)
	      | ((r_extern << 6) & 0x40)
	      | (fixP->fx_r_type & 0x3F));
d1304 1
a1304 3
  if (symbol_get_frag (fixP->fx_addsy))
    {
      r_addend = symbol_get_frag (fixP->fx_addsy)->fr_address;
d1306 1
a1306 2

  if (fixP->fx_pcrel)
d1308 1
a1308 2
      /* preserve actual offset vs. pc + 4 */
      r_addend -= (r_address + 4);
d1310 1
a1310 1
  else
d1312 1
a1312 2
      r_addend = fixP->fx_addnumber;
    }
d1314 4
a1317 2
  md_number_to_chars (&where[8], r_addend, 4);
}
d1319 7
a1325 1
#endif /* OBJ_AOUT */
d1327 1
a1327 1
/* We have no need to default values of symbols.  */
d1329 4
a1332 7
/* ARGSUSED */
symbolS *
md_undefined_symbol (name)
     char *name;
{
  return 0;
}
d1334 8
a1341 8
/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
{
  return size;			/* Byte alignment is fine */
}
d1343 1
a1343 9
/* Exactly what point is a PC-relative offset relative TO?
   On the i860, they're relative to the address of the offset, plus
   its size. (??? Is this right?  FIXME-SOON!) */
long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}
d1345 3
a1347 6
void
md_apply_fix (fixP, val)
     fixS *fixP;
     long val;
{
  char *place = fixP->fx_where + fixP->fx_frag->fr_literal;
d1349 4
a1352 3
  /* looks to me like i860 never has bit fixes. Let's see. xoxorich. */
  know (fixP->fx_bit_fixP == NULL);
  if (!fixP->fx_bit_fixP)
d1354 3
a1356 2
      fixP->fx_addnumber = val;
      md_number_to_imm (place, val, fixP->fx_size, fixP);
d1360 6
a1365 1
      md_number_to_field (place, val, fixP->fx_bit_fixP);
d1367 3
a1371 6
/*
 * Local Variables:
 * fill-column: 131
 * comment-column: 0
 * End:
 */
d1373 24
a1396 1
/* end of tc-i860.c */
@


1.2
log
@	* config/tc-alpha.c: More use of symbol accessor functions.
	* config/tc-arc.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d69 1
a69 1
const char line_separator_chars[] = "";
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1989, 92, 93, 94, 95, 1998 Free Software Foundation, Inc.
d1121 1
a1121 1
	  if (symbolP && symbolP->sy_frag)
d1123 1
a1123 1
	      ri.r_addend = symbolP->sy_frag->fr_address;
d1187 1
a1187 1
  if (fixP->fx_addsy->sy_frag)
d1189 1
a1189 1
      r_addend = fixP->fx_addsy->sy_frag->fr_address;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

