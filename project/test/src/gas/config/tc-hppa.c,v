head	1.155;
access;
symbols
	binutils-2_24-branch:1.155.0.2
	binutils-2_24-branchpoint:1.155
	binutils-2_21_1:1.149.2.1
	binutils-2_23_2:1.152
	binutils-2_23_1:1.152
	binutils-2_23:1.152
	binutils-2_23-branch:1.152.0.2
	binutils-2_23-branchpoint:1.152
	binutils-2_22_branch:1.151.0.4
	binutils-2_22:1.151
	binutils-2_22-branch:1.151.0.2
	binutils-2_22-branchpoint:1.151
	binutils-2_21:1.149
	binutils-2_21-branch:1.149.0.2
	binutils-2_21-branchpoint:1.149
	binutils-2_20_1:1.145
	binutils-2_20:1.145
	binutils-arc-20081103-branch:1.142.0.4
	binutils-arc-20081103-branchpoint:1.142
	binutils-2_20-branch:1.145.0.2
	binutils-2_20-branchpoint:1.145
	dje-cgen-play1-branch:1.144.0.2
	dje-cgen-play1-branchpoint:1.144
	arc-20081103-branch:1.142.0.2
	arc-20081103-branchpoint:1.142
	binutils-2_19_1:1.141
	binutils-2_19:1.141
	binutils-2_19-branch:1.141.0.2
	binutils-2_19-branchpoint:1.141
	binutils-2_18:1.134
	binutils-2_18-branch:1.134.0.2
	binutils-2_18-branchpoint:1.134
	binutils-csl-coldfire-4_1-32:1.129
	binutils-csl-sourcerygxx-4_1-32:1.129
	binutils-csl-innovasic-fido-3_4_4-33:1.129
	binutils-csl-sourcerygxx-3_4_4-32:1.115
	binutils-csl-coldfire-4_1-30:1.129
	binutils-csl-sourcerygxx-4_1-30:1.129
	binutils-csl-coldfire-4_1-28:1.129
	binutils-csl-sourcerygxx-4_1-29:1.129
	binutils-csl-sourcerygxx-4_1-28:1.129
	binutils-csl-arm-2006q3-27:1.129
	binutils-csl-sourcerygxx-4_1-27:1.129
	binutils-csl-arm-2006q3-26:1.129
	binutils-csl-sourcerygxx-4_1-26:1.129
	binutils-csl-sourcerygxx-4_1-25:1.129
	binutils-csl-sourcerygxx-4_1-24:1.129
	binutils-csl-sourcerygxx-4_1-23:1.129
	binutils-csl-sourcerygxx-4_1-21:1.129
	binutils-csl-arm-2006q3-21:1.129
	binutils-csl-sourcerygxx-4_1-22:1.129
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.129
	binutils-csl-sourcerygxx-4_1-20:1.129
	binutils-csl-arm-2006q3-19:1.129
	binutils-csl-sourcerygxx-4_1-19:1.129
	binutils-csl-sourcerygxx-4_1-18:1.129
	binutils-csl-renesas-4_1-9:1.129
	binutils-csl-sourcerygxx-3_4_4-25:1.115
	binutils-csl-renesas-4_1-8:1.129
	binutils-csl-renesas-4_1-7:1.129
	binutils-csl-renesas-4_1-6:1.129
	binutils-csl-sourcerygxx-4_1-17:1.129
	binutils-csl-sourcerygxx-4_1-14:1.129
	binutils-csl-sourcerygxx-4_1-15:1.129
	binutils-csl-sourcerygxx-4_1-13:1.129
	binutils-2_17:1.129
	binutils-csl-sourcerygxx-4_1-12:1.129
	binutils-csl-sourcerygxx-3_4_4-21:1.129
	binutils-csl-wrs-linux-3_4_4-24:1.115
	binutils-csl-wrs-linux-3_4_4-23:1.115
	binutils-csl-sourcerygxx-4_1-9:1.129
	binutils-csl-sourcerygxx-4_1-8:1.129
	binutils-csl-sourcerygxx-4_1-7:1.129
	binutils-csl-arm-2006q1-6:1.129
	binutils-csl-sourcerygxx-4_1-6:1.129
	binutils-csl-wrs-linux-3_4_4-22:1.115
	binutils-csl-coldfire-4_1-11:1.129
	binutils-csl-sourcerygxx-3_4_4-19:1.129
	binutils-csl-coldfire-4_1-10:1.129
	binutils-csl-sourcerygxx-4_1-5:1.129
	binutils-csl-sourcerygxx-4_1-4:1.129
	binutils-csl-wrs-linux-3_4_4-21:1.115
	binutils-csl-morpho-4_1-4:1.129
	binutils-csl-sourcerygxx-3_4_4-17:1.129
	binutils-csl-wrs-linux-3_4_4-20:1.115
	binutils-2_17-branch:1.129.0.4
	binutils-2_17-branchpoint:1.129
	binutils-csl-2_17-branch:1.129.0.2
	binutils-csl-2_17-branchpoint:1.129
	binutils-csl-gxxpro-3_4-branch:1.115.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.115
	binutils-2_16_1:1.115
	binutils-csl-arm-2005q1b:1.115
	binutils-2_16:1.115
	binutils-csl-arm-2005q1a:1.115
	binutils-csl-arm-2005q1-branch:1.115.0.4
	binutils-csl-arm-2005q1-branchpoint:1.115
	binutils-2_16-branch:1.115.0.2
	binutils-2_16-branchpoint:1.115
	csl-arm-2004-q3d:1.114
	csl-arm-2004-q3:1.114
	binutils-2_15:1.109.6.1
	binutils-2_15-branchpoint:1.109
	csl-arm-2004-q1a:1.111
	csl-arm-2004-q1:1.110
	binutils-2_15-branch:1.109.0.6
	cagney_bfdfile-20040213-branch:1.109.0.4
	cagney_bfdfile-20040213-branchpoint:1.109
	cagney_bigcore-20040122-branch:1.109.0.2
	cagney_bigcore-20040122-branchpoint:1.109
	csl-arm-2003-q4:1.109
	binutils-2_14:1.102.2.2
	binutils-2_14-branch:1.102.0.2
	binutils-2_14-branchpoint:1.102
	binutils-2_13_2_1:1.97
	binutils-2_13_2:1.97
	binutils-2_13_1:1.97
	binutils-2_13:1.97
	binutils-2_13-branchpoint:1.97
	binutils-2_13-branch:1.97.0.2
	binutils-2_12_1:1.92.2.2
	binutils-2_12:1.92.2.1
	binutils-2_12-branch:1.92.0.2
	binutils-2_12-branchpoint:1.92
	cygnus_cvs_20020108_pre:1.92
	binutils-2_11_2:1.78.2.4
	binutils-2_11_1:1.78.2.4
	binutils-2_11:1.78.2.4
	x86_64versiong3:1.81
	binutils-2_11-branch:1.78.0.2
	binutils-2_10_1:1.53
	binutils-2_10:1.53
	binutils-2_10-branch:1.53.0.2
	binutils-2_10-branchpoint:1.53
	binutils_latest_snapshot:1.155
	repo-unification-2000-02-06:1.52
	binu_ss_19990721:1.10
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.155
date	2012.10.14.23.59.39;	author danglin;	state Exp;
branches;
next	1.154;

1.154
date	2012.10.14.23.27.38;	author danglin;	state Exp;
branches;
next	1.153;

1.153
date	2012.10.13.22.15.19;	author danglin;	state Exp;
branches;
next	1.152;

1.152
date	2012.05.05.03.05.27;	author amodra;	state Exp;
branches;
next	1.151;

1.151
date	2010.12.31.16.43.46;	author danglin;	state Exp;
branches;
next	1.150;

1.150
date	2010.12.27.02.05.13;	author danglin;	state Exp;
branches;
next	1.149;

1.149
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches
	1.149.2.1;
next	1.148;

1.148
date	2010.04.16.11.20.39;	author nickc;	state Exp;
branches;
next	1.147;

1.147
date	2009.12.18.18.11.56;	author sje;	state Exp;
branches;
next	1.146;

1.146
date	2009.10.30.17.05.58;	author danglin;	state Exp;
branches;
next	1.145;

1.145
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.144;

1.144
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.143;

1.143
date	2009.02.24.23.48.57;	author danglin;	state Exp;
branches;
next	1.142;

1.142
date	2008.09.09.00.53.35;	author danglin;	state Exp;
branches;
next	1.141;

1.141
date	2008.08.28.02.33.45;	author danglin;	state Exp;
branches;
next	1.140;

1.140
date	2008.08.22.00.41.37;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2008.08.21.19.49.22;	author rth;	state Exp;
branches;
next	1.138;

1.138
date	2008.03.16.23.16.03;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2007.10.18.13.33.57;	author carlos;	state Exp;
branches;
next	1.136;

1.136
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.135;

1.135
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.134;

1.134
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	2006.10.30.01.09.18;	author tausq;	state Exp;
branches;
next	1.132;

1.132
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2006.05.24.11.05.42;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	2006.05.03.14.26.41;	author amodra;	state Exp;
branches;
next	1.129;

1.129
date	2005.11.25.02.08.22;	author danglin;	state Exp;
branches;
next	1.128;

1.128
date	2005.11.16.08.00.31;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2005.11.07.18.53.10;	author danglin;	state Exp;
branches;
next	1.126;

1.126
date	2005.10.13.01.06.01;	author danglin;	state Exp;
branches;
next	1.125;

1.125
date	2005.10.08.19.01.28;	author danglin;	state Exp;
branches;
next	1.124;

1.124
date	2005.09.20.18.24.46;	author rth;	state Exp;
branches;
next	1.123;

1.123
date	2005.07.19.01.14.10;	author danglin;	state Exp;
branches;
next	1.122;

1.122
date	2005.07.17.00.33.45;	author danglin;	state Exp;
branches;
next	1.121;

1.121
date	2005.06.10.05.46.48;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.119;

1.119
date	2005.05.22.01.40.28;	author danglin;	state Exp;
branches;
next	1.118;

1.118
date	2005.05.10.15.10.08;	author matz;	state Exp;
branches;
next	1.117;

1.117
date	2005.05.05.09.12.56;	author nickc;	state Exp;
branches;
next	1.116;

1.116
date	2005.04.12.08.39.34;	author nickc;	state Exp;
branches;
next	1.115;

1.115
date	2005.03.03.11.47.50;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2004.07.20.03.07.08;	author danglin;	state Exp;
branches;
next	1.113;

1.113
date	2004.06.11.17.39.18;	author danglin;	state Exp;
branches;
next	1.112;

1.112
date	2004.06.11.17.36.32;	author danglin;	state Exp;
branches;
next	1.111;

1.111
date	2004.04.28.18.02.49;	author danglin;	state Exp;
branches;
next	1.110;

1.110
date	2004.03.19.19.19.53;	author danglin;	state Exp;
branches;
next	1.109;

1.109
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches
	1.109.6.1;
next	1.108;

1.108
date	2003.11.21.14.38.06;	author kazu;	state Exp;
branches;
next	1.107;

1.107
date	2003.10.06.11.01.36;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2003.09.27.18.19.29;	author danglin;	state Exp;
branches;
next	1.105;

1.105
date	2003.05.21.19.40.54;	author danglin;	state Exp;
branches;
next	1.104;

1.104
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.28.08.35.06;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2002.09.09.21.31.40;	author law;	state Exp;
branches;
next	1.99;

1.99
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2002.08.20.23.49.27;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2002.06.06.06.50.12;	author law;	state Exp;
branches;
next	1.96;

1.96
date	2002.05.09.13.12.57;	author kazu;	state Exp;
branches;
next	1.95;

1.95
date	2002.03.05.17.57.17;	author law;	state Exp;
branches;
next	1.94;

1.94
date	2002.02.25.05.10.11;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2002.02.12.11.08.54;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2001.12.31.23.47.02;	author law;	state Exp;
branches
	1.92.2.1;
next	1.91;

1.91
date	2001.11.16.07.27.59;	author hjl;	state Exp;
branches;
next	1.90;

1.90
date	2001.11.15.21.28.55;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2001.10.11.23.56.33;	author kazu;	state Exp;
branches;
next	1.88;

1.88
date	2001.09.19.05.33.23;	author hjl;	state Exp;
branches;
next	1.87;

1.87
date	2001.07.23.14.02.12;	author kazu;	state Exp;
branches;
next	1.86;

1.86
date	2001.07.23.12.50.22;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2001.06.22.08.17.57;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2001.06.21.06.12.10;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2001.03.28.14.13.46;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2001.02.08.00.15.36;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2001.02.06.02.52.09;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2001.01.30.13.13.29;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2001.01.16.13.52.16;	author amodra;	state Exp;
branches
	1.78.2.1;
next	1.77;

1.77
date	2001.01.16.13.06.14;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2001.01.14.07.03.49;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2001.01.14.05.14.44;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2000.12.13.06.23.56;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2000.12.03.06.49.21;	author kazu;	state Exp;
branches;
next	1.72;

1.72
date	2000.11.17.08.47.51;	author rth;	state Exp;
branches;
next	1.71;

1.71
date	2000.10.25.19.15.33;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2000.10.07.14.38.32;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2000.09.28.06.24.43;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2000.09.27.16.50.39;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2000.09.23.10.06.15;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2000.09.18.12.36.03;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2000.09.07.01.34.02;	author law;	state Exp;
branches;
next	1.64;

1.64
date	2000.09.05.03.45.17;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2000.09.05.03.23.05;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2000.07.28.05.05.20;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2000.07.19.06.30.49;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2000.07.15.12.57.14;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2000.07.10.15.15.01;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2000.07.09.08.16.21;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2000.06.14.02.58.49;	author law;	state Exp;
branches;
next	1.56;

1.56
date	2000.05.19.00.21.12;	author law;	state Exp;
branches;
next	1.55;

1.55
date	2000.05.02.00.12.52;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2000.04.21.20.34.00;	author law;	state Exp;
branches;
next	1.53;

1.53
date	2000.02.11.21.27.41;	author law;	state Exp;
branches;
next	1.52;

1.52
date	99.11.25.03.27.35;	author law;	state Exp;
branches;
next	1.51;

1.51
date	99.10.17.23.19.13;	author law;	state Exp;
branches;
next	1.50;

1.50
date	99.10.10.07.57.30;	author law;	state Exp;
branches;
next	1.49;

1.49
date	99.09.23.16.09.23;	author law;	state Exp;
branches;
next	1.48;

1.48
date	99.09.23.14.30.31;	author law;	state Exp;
branches;
next	1.47;

1.47
date	99.09.23.13.15.29;	author law;	state Exp;
branches;
next	1.46;

1.46
date	99.09.22.15.43.26;	author law;	state Exp;
branches;
next	1.45;

1.45
date	99.09.20.10.06.05;	author law;	state Exp;
branches;
next	1.44;

1.44
date	99.09.19.20.07.01;	author law;	state Exp;
branches;
next	1.43;

1.43
date	99.09.19.19.46.52;	author law;	state Exp;
branches;
next	1.42;

1.42
date	99.09.19.19.23.08;	author law;	state Exp;
branches;
next	1.41;

1.41
date	99.09.19.18.47.37;	author law;	state Exp;
branches;
next	1.40;

1.40
date	99.09.19.18.13.50;	author law;	state Exp;
branches;
next	1.39;

1.39
date	99.09.19.17.38.09;	author law;	state Exp;
branches;
next	1.38;

1.38
date	99.09.19.17.09.23;	author law;	state Exp;
branches;
next	1.37;

1.37
date	99.09.19.16.58.33;	author law;	state Exp;
branches;
next	1.36;

1.36
date	99.09.19.16.45.20;	author law;	state Exp;
branches;
next	1.35;

1.35
date	99.09.18.18.16.21;	author law;	state Exp;
branches;
next	1.34;

1.34
date	99.09.18.13.41.01;	author law;	state Exp;
branches;
next	1.33;

1.33
date	99.09.18.13.26.46;	author law;	state Exp;
branches;
next	1.32;

1.32
date	99.09.17.18.00.50;	author law;	state Exp;
branches;
next	1.31;

1.31
date	99.09.15.13.19.32;	author law;	state Exp;
branches;
next	1.30;

1.30
date	99.09.15.11.17.53;	author law;	state Exp;
branches;
next	1.29;

1.29
date	99.09.07.19.48.13;	author law;	state Exp;
branches;
next	1.28;

1.28
date	99.09.07.19.30.14;	author law;	state Exp;
branches;
next	1.27;

1.27
date	99.09.06.10.28.21;	author law;	state Exp;
branches;
next	1.26;

1.26
date	99.08.29.07.52.32;	author law;	state Exp;
branches;
next	1.25;

1.25
date	99.08.28.10.59.37;	author law;	state Exp;
branches;
next	1.24;

1.24
date	99.08.28.10.18.12;	author law;	state Exp;
branches;
next	1.23;

1.23
date	99.08.28.08.48.40;	author law;	state Exp;
branches;
next	1.22;

1.22
date	99.08.28.08.16.30;	author law;	state Exp;
branches;
next	1.21;

1.21
date	99.08.28.07.23.42;	author law;	state Exp;
branches;
next	1.20;

1.20
date	99.08.28.06.42.06;	author law;	state Exp;
branches;
next	1.19;

1.19
date	99.08.28.06.28.21;	author law;	state Exp;
branches;
next	1.18;

1.18
date	99.08.11.09.41.28;	author law;	state Exp;
branches;
next	1.17;

1.17
date	99.08.10.19.09.43;	author law;	state Exp;
branches;
next	1.16;

1.16
date	99.08.10.19.02.30;	author law;	state Exp;
branches;
next	1.15;

1.15
date	99.08.06.18.13.31;	author law;	state Exp;
branches;
next	1.14;

1.14
date	99.08.06.15.48.42;	author law;	state Exp;
branches;
next	1.13;

1.13
date	99.08.05.22.56.06;	author law;	state Exp;
branches;
next	1.12;

1.12
date	99.08.05.00.09.42;	author law;	state Exp;
branches;
next	1.11;

1.11
date	99.07.28.08.07.14;	author law;	state Exp;
branches;
next	1.10;

1.10
date	99.07.15.01.49.48;	author law;	state Exp;
branches;
next	1.9;

1.9
date	99.07.01.14.37.29;	author law;	state Exp;
branches;
next	1.8;

1.8
date	99.06.21.15.48.50;	author law;	state Exp;
branches;
next	1.7;

1.7
date	99.06.18.13.35.16;	author law;	state Exp;
branches;
next	1.6;

1.6
date	99.06.04.21.08.54;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.04.10.46.25;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.03.12.42.35;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.27;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.03.09.26.28;	author law;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.149.2.1
date	2011.03.14.16.28.08;	author danglin;	state Exp;
branches;
next	;

1.109.6.1
date	2004.04.09.18.28.11;	author drow;	state Exp;
branches;
next	;

1.102.2.1
date	2003.04.28.08.34.30;	author nickc;	state Exp;
branches;
next	1.102.2.2;

1.102.2.2
date	2003.04.30.08.45.54;	author amodra;	state Exp;
branches;
next	;

1.92.2.1
date	2002.02.17.23.12.09;	author amodra;	state Exp;
branches;
next	1.92.2.2;

1.92.2.2
date	2002.03.28.06.25.03;	author amodra;	state Exp;
branches;
next	;

1.78.2.1
date	2001.01.30.13.13.07;	author amodra;	state Exp;
branches;
next	1.78.2.2;

1.78.2.2
date	2001.02.06.02.58.28;	author amodra;	state Exp;
branches;
next	1.78.2.3;

1.78.2.3
date	2001.02.08.00.14.25;	author amodra;	state Exp;
branches;
next	1.78.2.4;

1.78.2.4
date	2001.03.28.14.18.02;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.155
log
@	* config/tc-hppa.c (pa_get_number): New.
	(pa_get_absolute_expression): Simplify.
	(pa_ip): Use pa_get_number instead of pa_get_absolute_expression
	to get SOP, SFU and COPR identifiers.
@
text
@/* tc-hppa.c -- Assemble for the PA
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* HP PA-RISC support was contributed by the Center for Software Science
   at the University of Utah.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "dw2gencfi.h"

#include "bfd/libhppa.h"

/* Be careful, this file includes data *declarations*.  */
#include "opcode/hppa.h"

#if defined (OBJ_ELF) && defined (OBJ_SOM)
error only one of OBJ_ELF and OBJ_SOM can be defined
#endif

/* If we are using ELF, then we probably can support dwarf2 debug
   records.  Furthermore, if we are supporting dwarf2 debug records,
   then we want to use the assembler support for compact line numbers.  */
#ifdef OBJ_ELF
#include "dwarf2dbg.h"

/* A "convenient" place to put object file dependencies which do
   not need to be seen outside of tc-hppa.c.  */

/* Object file formats specify relocation types.  */
typedef enum elf_hppa_reloc_type reloc_type;

/* Object file formats specify BFD symbol types.  */
typedef elf_symbol_type obj_symbol_type;
#define symbol_arg_reloc_info(sym)\
  (((obj_symbol_type *) symbol_get_bfdsym (sym))->tc_data.hppa_arg_reloc)

#if TARGET_ARCH_SIZE == 64
/* How to generate a relocation.  */
#define hppa_gen_reloc_type _bfd_elf64_hppa_gen_reloc_type
#define elf_hppa_reloc_final_type elf64_hppa_reloc_final_type
#else
#define hppa_gen_reloc_type _bfd_elf32_hppa_gen_reloc_type
#define elf_hppa_reloc_final_type elf32_hppa_reloc_final_type
#endif

/* ELF objects can have versions, but apparently do not have anywhere
   to store a copyright string.  */
#define obj_version obj_elf_version
#define obj_copyright obj_elf_version

#define UNWIND_SECTION_NAME ".PARISC.unwind"
#endif /* OBJ_ELF */

#ifdef OBJ_SOM
/* Names of various debugging spaces/subspaces.  */
#define GDB_DEBUG_SPACE_NAME "$GDB_DEBUG$"
#define GDB_STRINGS_SUBSPACE_NAME "$GDB_STRINGS$"
#define GDB_SYMBOLS_SUBSPACE_NAME "$GDB_SYMBOLS$"
#define UNWIND_SECTION_NAME "$UNWIND$"

/* Object file formats specify relocation types.  */
typedef int reloc_type;

/* SOM objects can have both a version string and a copyright string.  */
#define obj_version obj_som_version
#define obj_copyright obj_som_copyright

/* How to generate a relocation.  */
#define hppa_gen_reloc_type hppa_som_gen_reloc_type

/* Object file formats specify BFD symbol types.  */
typedef som_symbol_type obj_symbol_type;
#define symbol_arg_reloc_info(sym)\
  (((obj_symbol_type *) symbol_get_bfdsym (sym))->tc_data.ap.hppa_arg_reloc)

/* This apparently isn't in older versions of hpux reloc.h.  */
#ifndef R_DLT_REL
#define R_DLT_REL 0x78
#endif

#ifndef R_N0SEL
#define R_N0SEL 0xd8
#endif

#ifndef R_N1SEL
#define R_N1SEL 0xd9
#endif
#endif /* OBJ_SOM */

#if TARGET_ARCH_SIZE == 64
#define DEFAULT_LEVEL 25
#else
#define DEFAULT_LEVEL 10
#endif

/* Various structures and types used internally in tc-hppa.c.  */

/* Unwind table and descriptor.  FIXME: Sync this with GDB version.  */

struct unwind_desc
  {
    unsigned int cannot_unwind:1;
    unsigned int millicode:1;
    unsigned int millicode_save_rest:1;
    unsigned int region_desc:2;
    unsigned int save_sr:2;
    unsigned int entry_fr:4;
    unsigned int entry_gr:5;
    unsigned int args_stored:1;
    unsigned int call_fr:5;
    unsigned int call_gr:5;
    unsigned int save_sp:1;
    unsigned int save_rp:1;
    unsigned int save_rp_in_frame:1;
    unsigned int extn_ptr_defined:1;
    unsigned int cleanup_defined:1;

    unsigned int hpe_interrupt_marker:1;
    unsigned int hpux_interrupt_marker:1;
    unsigned int reserved:3;
    unsigned int frame_size:27;
  };

/* We can't rely on compilers placing bitfields in any particular
   place, so use these macros when dumping unwind descriptors to
   object files.  */
#define UNWIND_LOW32(U) \
  (((U)->cannot_unwind << 31)		\
   | ((U)->millicode << 30)		\
   | ((U)->millicode_save_rest << 29)	\
   | ((U)->region_desc << 27)		\
   | ((U)->save_sr << 25)		\
   | ((U)->entry_fr << 21)		\
   | ((U)->entry_gr << 16)		\
   | ((U)->args_stored << 15)		\
   | ((U)->call_fr << 10)		\
   | ((U)->call_gr << 5)		\
   | ((U)->save_sp << 4)		\
   | ((U)->save_rp << 3)		\
   | ((U)->save_rp_in_frame << 2)	\
   | ((U)->extn_ptr_defined << 1)	\
   | ((U)->cleanup_defined << 0))

#define UNWIND_HIGH32(U) \
  (((U)->hpe_interrupt_marker << 31)	\
   | ((U)->hpux_interrupt_marker << 30)	\
   | ((U)->frame_size << 0))

struct unwind_table
  {
    /* Starting and ending offsets of the region described by
       descriptor.  */
    unsigned int start_offset;
    unsigned int end_offset;
    struct unwind_desc descriptor;
  };

/* This structure is used by the .callinfo, .enter, .leave pseudo-ops to
   control the entry and exit code they generate. It is also used in
   creation of the correct stack unwind descriptors.

   NOTE:  GAS does not support .enter and .leave for the generation of
   prologues and epilogues.  FIXME.

   The fields in structure roughly correspond to the arguments available on the
   .callinfo pseudo-op.  */

struct call_info
  {
    /* The unwind descriptor being built.  */
    struct unwind_table ci_unwind;

    /* Name of this function.  */
    symbolS *start_symbol;

    /* (temporary) symbol used to mark the end of this function.  */
    symbolS *end_symbol;

    /* Next entry in the chain.  */
    struct call_info *ci_next;
  };

/* Operand formats for FP instructions.   Note not all FP instructions
   allow all four formats to be used (for example fmpysub only allows
   SGL and DBL).  */
typedef enum
  {
    SGL, DBL, ILLEGAL_FMT, QUAD, W, UW, DW, UDW, QW, UQW
  }
fp_operand_format;

/* This fully describes the symbol types which may be attached to
   an EXPORT or IMPORT directive.  Only SOM uses this formation
   (ELF has no need for it).  */
typedef enum
  {
    SYMBOL_TYPE_UNKNOWN,
    SYMBOL_TYPE_ABSOLUTE,
    SYMBOL_TYPE_CODE,
    SYMBOL_TYPE_DATA,
    SYMBOL_TYPE_ENTRY,
    SYMBOL_TYPE_MILLICODE,
    SYMBOL_TYPE_PLABEL,
    SYMBOL_TYPE_PRI_PROG,
    SYMBOL_TYPE_SEC_PROG,
  }
pa_symbol_type;

/* This structure contains information needed to assemble
   individual instructions.  */
struct pa_it
  {
    /* Holds the opcode after parsing by pa_ip.  */
    unsigned long opcode;

    /* Holds an expression associated with the current instruction.  */
    expressionS exp;

    /* Does this instruction use PC-relative addressing.  */
    int pcrel;

    /* Floating point formats for operand1 and operand2.  */
    fp_operand_format fpof1;
    fp_operand_format fpof2;

    /* Whether or not we saw a truncation request on an fcnv insn.  */
    int trunc;

    /* Holds the field selector for this instruction
       (for example L%, LR%, etc).  */
    long field_selector;

    /* Holds any argument relocation bits associated with this
       instruction.  (instruction should be some sort of call).  */
    unsigned int arg_reloc;

    /* The format specification for this instruction.  */
    int format;

    /* The relocation (if any) associated with this instruction.  */
    reloc_type reloc;
  };

/* PA-89 floating point registers are arranged like this:

   +--------------+--------------+
   |   0 or 16L   |  16 or 16R   |
   +--------------+--------------+
   |   1 or 17L   |  17 or 17R   |
   +--------------+--------------+
   |              |              |

   .              .              .
   .              .              .
   .              .              .

   |              |              |
   +--------------+--------------+
   |  14 or 30L   |  30 or 30R   |
   +--------------+--------------+
   |  15 or 31L   |  31 or 31R   |
   +--------------+--------------+  */

/* Additional information needed to build argument relocation stubs.  */
struct call_desc
  {
    /* The argument relocation specification.  */
    unsigned int arg_reloc;

    /* Number of arguments.  */
    unsigned int arg_count;
  };

#ifdef OBJ_SOM
/* This structure defines an entry in the subspace dictionary
   chain.  */

struct subspace_dictionary_chain
  {
    /* Nonzero if this space has been defined by the user code.  */
    unsigned int ssd_defined;

    /* Name of this subspace.  */
    char *ssd_name;

    /* GAS segment and subsegment associated with this subspace.  */
    asection *ssd_seg;
    int ssd_subseg;

    /* Next space in the subspace dictionary chain.  */
    struct subspace_dictionary_chain *ssd_next;
  };

typedef struct subspace_dictionary_chain ssd_chain_struct;

/* This structure defines an entry in the subspace dictionary
   chain.  */

struct space_dictionary_chain
  {
    /* Nonzero if this space has been defined by the user code or
       as a default space.  */
    unsigned int sd_defined;

    /* Nonzero if this spaces has been defined by the user code.  */
    unsigned int sd_user_defined;

    /* The space number (or index).  */
    unsigned int sd_spnum;

    /* The name of this subspace.  */
    char *sd_name;

    /* GAS segment to which this subspace corresponds.  */
    asection *sd_seg;

    /* Current subsegment number being used.  */
    int sd_last_subseg;

    /* The chain of subspaces contained within this space.  */
    ssd_chain_struct *sd_subspaces;

    /* The next entry in the space dictionary chain.  */
    struct space_dictionary_chain *sd_next;
  };

typedef struct space_dictionary_chain sd_chain_struct;

/* This structure defines attributes of the default subspace
   dictionary entries.  */

struct default_subspace_dict
  {
    /* Name of the subspace.  */
    char *name;

    /* FIXME.  Is this still needed?  */
    char defined;

    /* Nonzero if this subspace is loadable.  */
    char loadable;

    /* Nonzero if this subspace contains only code.  */
    char code_only;

    /* Nonzero if this is a comdat subspace.  */
    char comdat;

    /* Nonzero if this is a common subspace.  */
    char common;

    /* Nonzero if this is a common subspace which allows symbols
       to be multiply defined.  */
    char dup_common;

    /* Nonzero if this subspace should be zero filled.  */
    char zero;

    /* Sort key for this subspace.  */
    unsigned char sort;

    /* Access control bits for this subspace.  Can represent RWX access
       as well as privilege level changes for gateways.  */
    int access;

    /* Index of containing space.  */
    int space_index;

    /* Alignment (in bytes) of this subspace.  */
    int alignment;

    /* Quadrant within space where this subspace should be loaded.  */
    int quadrant;

    /* An index into the default spaces array.  */
    int def_space_index;

    /* Subsegment associated with this subspace.  */
    subsegT subsegment;
  };

/* This structure defines attributes of the default space
   dictionary entries.  */

struct default_space_dict
  {
    /* Name of the space.  */
    char *name;

    /* Space number.  It is possible to identify spaces within
       assembly code numerically!  */
    int spnum;

    /* Nonzero if this space is loadable.  */
    char loadable;

    /* Nonzero if this space is "defined".  FIXME is still needed */
    char defined;

    /* Nonzero if this space can not be shared.  */
    char private;

    /* Sort key for this space.  */
    unsigned char sort;

    /* Segment associated with this space.  */
    asection *segment;
  };
#endif

/* Structure for previous label tracking.  Needed so that alignments,
   callinfo declarations, etc can be easily attached to a particular
   label.  */
typedef struct label_symbol_struct
  {
    struct symbol *lss_label;
#ifdef OBJ_SOM
    sd_chain_struct *lss_space;
#endif
#ifdef OBJ_ELF
    segT lss_segment;
#endif
    struct label_symbol_struct *lss_next;
  }
label_symbol_struct;

/* Extra information needed to perform fixups (relocations) on the PA.  */
struct hppa_fix_struct
  {
    /* The field selector.  */
    enum hppa_reloc_field_selector_type_alt fx_r_field;

    /* Type of fixup.  */
    int fx_r_type;

    /* Format of fixup.  */
    int fx_r_format;

    /* Argument relocation bits.  */
    unsigned int fx_arg_reloc;

    /* The segment this fixup appears in.  */
    segT segment;
  };

/* Structure to hold information about predefined registers.  */

struct pd_reg
  {
    char *name;
    int value;
  };

/* This structure defines the mapping from a FP condition string
   to a condition number which can be recorded in an instruction.  */
struct fp_cond_map
  {
    char *string;
    int cond;
  };

/* This structure defines a mapping from a field selector
   string to a field selector type.  */
struct selector_entry
  {
    char *prefix;
    int field_selector;
  };

/* Prototypes for functions local to tc-hppa.c.  */

#ifdef OBJ_SOM
static void pa_check_current_space_and_subspace (void);
#endif

#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
static void pa_text (int);
static void pa_data (int);
static void pa_comm (int);
#endif
#ifdef OBJ_SOM
static int exact_log2 (int);
static void pa_compiler (int);
static void pa_align (int);
static void pa_space (int);
static void pa_spnum (int);
static void pa_subspace (int);
static sd_chain_struct *create_new_space (char *, int, int,
						  int, int, int,
						  asection *, int);
static ssd_chain_struct *create_new_subspace (sd_chain_struct *,
						      char *, int, int,
						      int, int, int, int,
						      int, int, int, int,
						      int, asection *);
static ssd_chain_struct *update_subspace (sd_chain_struct *,
						  char *, int, int, int,
						  int, int, int, int,
						  int, int, int, int,
						  asection *);
static sd_chain_struct *is_defined_space (char *);
static ssd_chain_struct *is_defined_subspace (char *);
static sd_chain_struct *pa_segment_to_space (asection *);
static ssd_chain_struct *pa_subsegment_to_subspace (asection *,
							    subsegT);
static sd_chain_struct *pa_find_space_by_number (int);
static unsigned int pa_subspace_start (sd_chain_struct *, int);
static sd_chain_struct *pa_parse_space_stmt (char *, int);
#endif

/* File and globally scoped variable declarations.  */

#ifdef OBJ_SOM
/* Root and final entry in the space chain.  */
static sd_chain_struct *space_dict_root;
static sd_chain_struct *space_dict_last;

/* The current space and subspace.  */
static sd_chain_struct *current_space;
static ssd_chain_struct *current_subspace;
#endif

/* Root of the call_info chain.  */
static struct call_info *call_info_root;

/* The last call_info (for functions) structure
   seen so it can be associated with fixups and
   function labels.  */
static struct call_info *last_call_info;

/* The last call description (for actual calls).  */
static struct call_desc last_call_desc;

/* handle of the OPCODE hash table */
static struct hash_control *op_hash = NULL;

/* These characters can be suffixes of opcode names and they may be
   followed by meaningful whitespace.  We don't include `,' and `!'
   as they never appear followed by meaningful whitespace.  */
const char hppa_symbol_chars[] = "*?=<>";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.

   Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.

   Also note that C style comments will always work.  */
const char line_comment_chars[] = "#";

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = ";";

/* This array holds the characters which act as line separators.  */
const char line_separator_chars[] = "!";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   As in 0f12.456 or 0d1.2345e12.

   Be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c.  Ideally it shouldn't have to know about it
   at all, but nothing is ideal around here.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

static struct pa_it the_insn;

/* Points to the end of an expression just parsed by get_expression
   and friends.  FIXME.  This shouldn't be handled with a file-global
   variable.  */
static char *expr_end;

/* Nonzero if a .callinfo appeared within the current procedure.  */
static int callinfo_found;

/* Nonzero if the assembler is currently within a .entry/.exit pair.  */
static int within_entry_exit;

/* Nonzero if the assembler is currently within a procedure definition.  */
static int within_procedure;

/* Handle on structure which keep track of the last symbol
   seen in each subspace.  */
static label_symbol_struct *label_symbols_rootp = NULL;

/* Holds the last field selector.  */
static int hppa_field_selector;

/* Nonzero when strict matching is enabled.  Zero otherwise.

   Each opcode in the table has a flag which indicates whether or
   not strict matching should be enabled for that instruction.

   Mainly, strict causes errors to be ignored when a match failure
   occurs.  However, it also affects the parsing of register fields
   by pa_parse_number.  */
static int strict;

/* pa_parse_number returns values in `pa_number'.  Mostly
   pa_parse_number is used to return a register number, with floating
   point registers being numbered from FP_REG_BASE upwards.
   The bit specified with FP_REG_RSEL is set if the floating point
   register has a `r' suffix.  */
#define FP_REG_BASE 64
#define FP_REG_RSEL 128
static int pa_number;

#ifdef OBJ_SOM
/* A dummy bfd symbol so that all relocations have symbols of some kind.  */
static symbolS *dummy_symbol;
#endif

/* Nonzero if errors are to be printed.  */
static int print_errors = 1;

/* List of registers that are pre-defined:

   Each general register has one predefined name of the form
   %r<REGNUM> which has the value <REGNUM>.

   Space and control registers are handled in a similar manner,
   but use %sr<REGNUM> and %cr<REGNUM> as their predefined names.

   Likewise for the floating point registers, but of the form
   %fr<REGNUM>.  Floating point registers have additional predefined
   names with 'L' and 'R' suffixes (e.g. %fr19L, %fr19R) which
   again have the value <REGNUM>.

   Many registers also have synonyms:

   %r26 - %r23 have %arg0 - %arg3 as synonyms
   %r28 - %r29 have %ret0 - %ret1 as synonyms
   %fr4 - %fr7 have %farg0 - %farg3 as synonyms
   %r30 has %sp as a synonym
   %r27 has %dp as a synonym
   %r2  has %rp as a synonym

   Almost every control register has a synonym; they are not listed
   here for brevity.

   The table is sorted. Suitable for searching by a binary search.  */

static const struct pd_reg pre_defined_registers[] =
{
  {"%arg0",  26},
  {"%arg1",  25},
  {"%arg2",  24},
  {"%arg3",  23},
  {"%cr0",    0},
  {"%cr10",  10},
  {"%cr11",  11},
  {"%cr12",  12},
  {"%cr13",  13},
  {"%cr14",  14},
  {"%cr15",  15},
  {"%cr16",  16},
  {"%cr17",  17},
  {"%cr18",  18},
  {"%cr19",  19},
  {"%cr20",  20},
  {"%cr21",  21},
  {"%cr22",  22},
  {"%cr23",  23},
  {"%cr24",  24},
  {"%cr25",  25},
  {"%cr26",  26},
  {"%cr27",  27},
  {"%cr28",  28},
  {"%cr29",  29},
  {"%cr30",  30},
  {"%cr31",  31},
  {"%cr8",    8},
  {"%cr9",    9},
  {"%dp",    27},
  {"%eiem",  15},
  {"%eirr",  23},
  {"%farg0",  4 + FP_REG_BASE},
  {"%farg1",  5 + FP_REG_BASE},
  {"%farg2",  6 + FP_REG_BASE},
  {"%farg3",  7 + FP_REG_BASE},
  {"%fr0",    0 + FP_REG_BASE},
  {"%fr0l",   0 + FP_REG_BASE},
  {"%fr0r",   0 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr1",    1 + FP_REG_BASE},
  {"%fr10",  10 + FP_REG_BASE},
  {"%fr10l", 10 + FP_REG_BASE},
  {"%fr10r", 10 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr11",  11 + FP_REG_BASE},
  {"%fr11l", 11 + FP_REG_BASE},
  {"%fr11r", 11 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr12",  12 + FP_REG_BASE},
  {"%fr12l", 12 + FP_REG_BASE},
  {"%fr12r", 12 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr13",  13 + FP_REG_BASE},
  {"%fr13l", 13 + FP_REG_BASE},
  {"%fr13r", 13 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr14",  14 + FP_REG_BASE},
  {"%fr14l", 14 + FP_REG_BASE},
  {"%fr14r", 14 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr15",  15 + FP_REG_BASE},
  {"%fr15l", 15 + FP_REG_BASE},
  {"%fr15r", 15 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr16",  16 + FP_REG_BASE},
  {"%fr16l", 16 + FP_REG_BASE},
  {"%fr16r", 16 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr17",  17 + FP_REG_BASE},
  {"%fr17l", 17 + FP_REG_BASE},
  {"%fr17r", 17 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr18",  18 + FP_REG_BASE},
  {"%fr18l", 18 + FP_REG_BASE},
  {"%fr18r", 18 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr19",  19 + FP_REG_BASE},
  {"%fr19l", 19 + FP_REG_BASE},
  {"%fr19r", 19 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr1l",   1 + FP_REG_BASE},
  {"%fr1r",   1 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr2",    2 + FP_REG_BASE},
  {"%fr20",  20 + FP_REG_BASE},
  {"%fr20l", 20 + FP_REG_BASE},
  {"%fr20r", 20 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr21",  21 + FP_REG_BASE},
  {"%fr21l", 21 + FP_REG_BASE},
  {"%fr21r", 21 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr22",  22 + FP_REG_BASE},
  {"%fr22l", 22 + FP_REG_BASE},
  {"%fr22r", 22 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr23",  23 + FP_REG_BASE},
  {"%fr23l", 23 + FP_REG_BASE},
  {"%fr23r", 23 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr24",  24 + FP_REG_BASE},
  {"%fr24l", 24 + FP_REG_BASE},
  {"%fr24r", 24 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr25",  25 + FP_REG_BASE},
  {"%fr25l", 25 + FP_REG_BASE},
  {"%fr25r", 25 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr26",  26 + FP_REG_BASE},
  {"%fr26l", 26 + FP_REG_BASE},
  {"%fr26r", 26 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr27",  27 + FP_REG_BASE},
  {"%fr27l", 27 + FP_REG_BASE},
  {"%fr27r", 27 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr28",  28 + FP_REG_BASE},
  {"%fr28l", 28 + FP_REG_BASE},
  {"%fr28r", 28 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr29",  29 + FP_REG_BASE},
  {"%fr29l", 29 + FP_REG_BASE},
  {"%fr29r", 29 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr2l",   2 + FP_REG_BASE},
  {"%fr2r",   2 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr3",    3 + FP_REG_BASE},
  {"%fr30",  30 + FP_REG_BASE},
  {"%fr30l", 30 + FP_REG_BASE},
  {"%fr30r", 30 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr31",  31 + FP_REG_BASE},
  {"%fr31l", 31 + FP_REG_BASE},
  {"%fr31r", 31 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr3l",   3 + FP_REG_BASE},
  {"%fr3r",   3 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr4",    4 + FP_REG_BASE},
  {"%fr4l",   4 + FP_REG_BASE},
  {"%fr4r",   4 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr5",    5 + FP_REG_BASE},
  {"%fr5l",   5 + FP_REG_BASE},
  {"%fr5r",   5 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr6",    6 + FP_REG_BASE},
  {"%fr6l",   6 + FP_REG_BASE},
  {"%fr6r",   6 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr7",    7 + FP_REG_BASE},
  {"%fr7l",   7 + FP_REG_BASE},
  {"%fr7r",   7 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr8",    8 + FP_REG_BASE},
  {"%fr8l",   8 + FP_REG_BASE},
  {"%fr8r",   8 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr9",    9 + FP_REG_BASE},
  {"%fr9l",   9 + FP_REG_BASE},
  {"%fr9r",   9 + FP_REG_BASE + FP_REG_RSEL},
  {"%fret",   4},
  {"%hta",   25},
  {"%iir",   19},
  {"%ior",   21},
  {"%ipsw",  22},
  {"%isr",   20},
  {"%itmr",  16},
  {"%iva",   14},
#if TARGET_ARCH_SIZE == 64
  {"%mrp",    2},
#else
  {"%mrp",   31},
#endif
  {"%pcoq",  18},
  {"%pcsq",  17},
  {"%pidr1",  8},
  {"%pidr2",  9},
  {"%pidr3", 12},
  {"%pidr4", 13},
  {"%ppda",  24},
  {"%r0",     0},
  {"%r1",     1},
  {"%r10",   10},
  {"%r11",   11},
  {"%r12",   12},
  {"%r13",   13},
  {"%r14",   14},
  {"%r15",   15},
  {"%r16",   16},
  {"%r17",   17},
  {"%r18",   18},
  {"%r19",   19},
  {"%r2",     2},
  {"%r20",   20},
  {"%r21",   21},
  {"%r22",   22},
  {"%r23",   23},
  {"%r24",   24},
  {"%r25",   25},
  {"%r26",   26},
  {"%r27",   27},
  {"%r28",   28},
  {"%r29",   29},
  {"%r3",     3},
  {"%r30",   30},
  {"%r31",   31},
  {"%r4",     4},
  {"%r5",     5},
  {"%r6",     6},
  {"%r7",     7},
  {"%r8",     8},
  {"%r9",     9},
  {"%rctr",   0},
  {"%ret0",  28},
  {"%ret1",  29},
  {"%rp",     2},
  {"%sar",   11},
  {"%sp",    30},
  {"%sr0",    0},
  {"%sr1",    1},
  {"%sr2",    2},
  {"%sr3",    3},
  {"%sr4",    4},
  {"%sr5",    5},
  {"%sr6",    6},
  {"%sr7",    7},
  {"%t1",    22},
  {"%t2",    21},
  {"%t3",    20},
  {"%t4",    19},
  {"%tf1",   11},
  {"%tf2",   10},
  {"%tf3",    9},
  {"%tf4",    8},
  {"%tr0",   24},
  {"%tr1",   25},
  {"%tr2",   26},
  {"%tr3",   27},
  {"%tr4",   28},
  {"%tr5",   29},
  {"%tr6",   30},
  {"%tr7",   31}
};

/* This table is sorted by order of the length of the string. This is
   so we check for <> before we check for <. If we had a <> and checked
   for < first, we would get a false match.  */
static const struct fp_cond_map fp_cond_map[] =
{
  {"false?", 0},
  {"false", 1},
  {"true?", 30},
  {"true", 31},
  {"!<=>", 3},
  {"!?>=", 8},
  {"!?<=", 16},
  {"!<>", 7},
  {"!>=", 11},
  {"!?>", 12},
  {"?<=", 14},
  {"!<=", 19},
  {"!?<", 20},
  {"?>=", 22},
  {"!?=", 24},
  {"!=t", 27},
  {"<=>", 29},
  {"=t", 5},
  {"?=", 6},
  {"?<", 10},
  {"<=", 13},
  {"!>", 15},
  {"?>", 18},
  {">=", 21},
  {"!<", 23},
  {"<>", 25},
  {"!=", 26},
  {"!?", 28},
  {"?", 2},
  {"=", 4},
  {"<", 9},
  {">", 17}
};

static const struct selector_entry selector_table[] =
{
  {"f", e_fsel},
  {"l", e_lsel},
  {"ld", e_ldsel},
  {"lp", e_lpsel},
  {"lr", e_lrsel},
  {"ls", e_lssel},
  {"lt", e_ltsel},
  {"ltp", e_ltpsel},
  {"n", e_nsel},
  {"nl", e_nlsel},
  {"nlr", e_nlrsel},
  {"p", e_psel},
  {"r", e_rsel},
  {"rd", e_rdsel},
  {"rp", e_rpsel},
  {"rr", e_rrsel},
  {"rs", e_rssel},
  {"rt", e_rtsel},
  {"rtp", e_rtpsel},
  {"t", e_tsel},
};

#ifdef OBJ_SOM
/* default space and subspace dictionaries */

#define GDB_SYMBOLS	GDB_SYMBOLS_SUBSPACE_NAME
#define GDB_STRINGS	GDB_STRINGS_SUBSPACE_NAME

/* pre-defined subsegments (subspaces) for the HPPA.  */
#define SUBSEG_CODE   0
#define SUBSEG_LIT    1
#define SUBSEG_MILLI  2
#define SUBSEG_DATA   0
#define SUBSEG_BSS    2
#define SUBSEG_UNWIND 3
#define SUBSEG_GDB_STRINGS 0
#define SUBSEG_GDB_SYMBOLS 1

static struct default_subspace_dict pa_def_subspaces[] =
{
  {"$CODE$", 1, 1, 1, 0, 0, 0, 0, 24, 0x2c, 0, 8, 0, 0, SUBSEG_CODE},
  {"$DATA$", 1, 1, 0, 0, 0, 0, 0, 24, 0x1f, 1, 8, 1, 1, SUBSEG_DATA},
  {"$LIT$", 1, 1, 0, 0, 0, 0, 0, 16, 0x2c, 0, 8, 0, 0, SUBSEG_LIT},
  {"$MILLICODE$", 1, 1, 0, 0, 0, 0, 0, 8, 0x2c, 0, 8, 0, 0, SUBSEG_MILLI},
  {"$BSS$", 1, 1, 0, 0, 0, 0, 1, 80, 0x1f, 1, 8, 1, 1, SUBSEG_BSS},
  {NULL, 0, 1, 0, 0, 0, 0, 0, 255, 0x1f, 0, 4, 0, 0, 0}
};

static struct default_space_dict pa_def_spaces[] =
{
  {"$TEXT$", 0, 1, 1, 0, 8, ASEC_NULL},
  {"$PRIVATE$", 1, 1, 1, 1, 16, ASEC_NULL},
  {NULL, 0, 0, 0, 0, 0, ASEC_NULL}
};

/* Misc local definitions used by the assembler.  */

/* These macros are used to maintain spaces/subspaces.  */
#define SPACE_DEFINED(space_chain)	(space_chain)->sd_defined
#define SPACE_USER_DEFINED(space_chain) (space_chain)->sd_user_defined
#define SPACE_SPNUM(space_chain)	(space_chain)->sd_spnum
#define SPACE_NAME(space_chain)		(space_chain)->sd_name

#define SUBSPACE_DEFINED(ss_chain)	(ss_chain)->ssd_defined
#define SUBSPACE_NAME(ss_chain)		(ss_chain)->ssd_name
#endif

/* Return nonzero if the string pointed to by S potentially represents
   a right or left half of a FP register  */
#define IS_R_SELECT(S)   (*(S) == 'R' || *(S) == 'r')
#define IS_L_SELECT(S)   (*(S) == 'L' || *(S) == 'l')

/* Store immediate values of shift/deposit/extract functions.  */

#define SAVE_IMMEDIATE(VALUE) \
  { \
    if (immediate_check) \
      { \
	if (pos == -1) \
	  pos = (VALUE); \
	else if (len == -1) \
	  len = (VALUE); \
      } \
  }

/* Insert FIELD into OPCODE starting at bit START.  Continue pa_ip
   main loop after insertion.  */

#define INSERT_FIELD_AND_CONTINUE(OPCODE, FIELD, START) \
  { \
    ((OPCODE) |= (FIELD) << (START)); \
    continue; \
  }

/* Simple range checking for FIELD against HIGH and LOW bounds.
   IGNORE is used to suppress the error message.  */

#define CHECK_FIELD(FIELD, HIGH, LOW, IGNORE) \
  { \
    if ((FIELD) > (HIGH) || (FIELD) < (LOW)) \
      { \
	if (! IGNORE) \
	  as_bad (_("Field out of range [%d..%d] (%d)."), (LOW), (HIGH), \
		  (int) (FIELD));\
	break; \
      } \
  }

/* Variant of CHECK_FIELD for use in md_apply_fix and other places where
   the current file and line number are not valid.  */

#define CHECK_FIELD_WHERE(FIELD, HIGH, LOW, FILENAME, LINE) \
  { \
    if ((FIELD) > (HIGH) || (FIELD) < (LOW)) \
      { \
	as_bad_where ((FILENAME), (LINE), \
		      _("Field out of range [%d..%d] (%d)."), (LOW), (HIGH), \
		      (int) (FIELD));\
	break; \
      } \
  }

/* Simple alignment checking for FIELD against ALIGN (a power of two).
   IGNORE is used to suppress the error message.  */

#define CHECK_ALIGN(FIELD, ALIGN, IGNORE) \
  { \
    if ((FIELD) & ((ALIGN) - 1)) \
      { \
	if (! IGNORE) \
	  as_bad (_("Field not properly aligned [%d] (%d)."), (ALIGN), \
		  (int) (FIELD));\
	break; \
      } \
  }

#define is_DP_relative(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$global$") == 0)

#define is_SB_relative(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$segrel$") == 0)

#define is_PC_relative(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$PIC_pcrel$0") == 0)

#define is_tls_gdidx(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_gdidx$") == 0)

#define is_tls_ldidx(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_ldidx$") == 0)

#define is_tls_dtpoff(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_dtpoff$") == 0)

#define is_tls_ieoff(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_ieoff$") == 0)

#define is_tls_leoff(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$tls_leoff$") == 0)

/* We need some complex handling for stabs (sym1 - sym2).  Luckily, we'll
   always be able to reduce the expression to a constant, so we don't
   need real complex handling yet.  */
#define is_complex(exp)				\
  ((exp).X_op != O_constant && (exp).X_op != O_symbol)

/* Actual functions to implement the PA specific code for the assembler.  */

/* Called before writing the object file.  Make sure entry/exit and
   proc/procend pairs match.  */

void
pa_check_eof (void)
{
  if (within_entry_exit)
    as_fatal (_("Missing .exit\n"));

  if (within_procedure)
    as_fatal (_("Missing .procend\n"));
}

/* Returns a pointer to the label_symbol_struct for the current space.
   or NULL if no label_symbol_struct exists for the current space.  */

static label_symbol_struct *
pa_get_label (void)
{
  label_symbol_struct *label_chain;

  for (label_chain = label_symbols_rootp;
       label_chain;
       label_chain = label_chain->lss_next)
    {
#ifdef OBJ_SOM
    if (current_space == label_chain->lss_space && label_chain->lss_label)
      return label_chain;
#endif
#ifdef OBJ_ELF
    if (now_seg == label_chain->lss_segment && label_chain->lss_label)
      return label_chain;
#endif
    }

  return NULL;
}

/* Defines a label for the current space.  If one is already defined,
   this function will replace it with the new label.  */

void
pa_define_label (symbolS *symbol)
{
  label_symbol_struct *label_chain = pa_get_label ();

  if (label_chain)
    label_chain->lss_label = symbol;
  else
    {
      /* Create a new label entry and add it to the head of the chain.  */
      label_chain = xmalloc (sizeof (label_symbol_struct));
      label_chain->lss_label = symbol;
#ifdef OBJ_SOM
      label_chain->lss_space = current_space;
#endif
#ifdef OBJ_ELF
      label_chain->lss_segment = now_seg;
#endif
      label_chain->lss_next = NULL;

      if (label_symbols_rootp)
	label_chain->lss_next = label_symbols_rootp;

      label_symbols_rootp = label_chain;
    }

#ifdef OBJ_ELF
  dwarf2_emit_label (symbol);
#endif
}

/* Removes a label definition for the current space.
   If there is no label_symbol_struct entry, then no action is taken.  */

static void
pa_undefine_label (void)
{
  label_symbol_struct *label_chain;
  label_symbol_struct *prev_label_chain = NULL;

  for (label_chain = label_symbols_rootp;
       label_chain;
       label_chain = label_chain->lss_next)
    {
      if (1
#ifdef OBJ_SOM
	  && current_space == label_chain->lss_space && label_chain->lss_label
#endif
#ifdef OBJ_ELF
	  && now_seg == label_chain->lss_segment && label_chain->lss_label
#endif
	  )
	{
	  /* Remove the label from the chain and free its memory.  */
	  if (prev_label_chain)
	    prev_label_chain->lss_next = label_chain->lss_next;
	  else
	    label_symbols_rootp = label_chain->lss_next;

	  free (label_chain);
	  break;
	}
      prev_label_chain = label_chain;
    }
}

/* An HPPA-specific version of fix_new.  This is required because the HPPA
   code needs to keep track of some extra stuff.  Each call to fix_new_hppa
   results in the creation of an instance of an hppa_fix_struct.  An
   hppa_fix_struct stores the extra information along with a pointer to the
   original fixS.  This is attached to the original fixup via the
   tc_fix_data field.  */

static void
fix_new_hppa (fragS *frag,
	      int where,
	      int size,
	      symbolS *add_symbol,
	      offsetT offset,
	      expressionS *exp,
	      int pcrel,
	      bfd_reloc_code_real_type r_type,
	      enum hppa_reloc_field_selector_type_alt r_field,
	      int r_format,
	      unsigned int arg_reloc,
	      int unwind_bits ATTRIBUTE_UNUSED)
{
  fixS *new_fix;
  struct hppa_fix_struct *hppa_fix = obstack_alloc (&notes, sizeof (struct hppa_fix_struct));

  if (exp != NULL)
    new_fix = fix_new_exp (frag, where, size, exp, pcrel, r_type);
  else
    new_fix = fix_new (frag, where, size, add_symbol, offset, pcrel, r_type);
  new_fix->tc_fix_data = (void *) hppa_fix;
  hppa_fix->fx_r_type = r_type;
  hppa_fix->fx_r_field = r_field;
  hppa_fix->fx_r_format = r_format;
  hppa_fix->fx_arg_reloc = arg_reloc;
  hppa_fix->segment = now_seg;
#ifdef OBJ_SOM
  if (r_type == R_ENTRY || r_type == R_EXIT)
    new_fix->fx_offset = unwind_bits;
#endif

  /* foo-$global$ is used to access non-automatic storage.  $global$
     is really just a marker and has served its purpose, so eliminate
     it now so as not to confuse write.c.  Ditto for $PIC_pcrel$0.  */
  if (new_fix->fx_subsy
      && (strcmp (S_GET_NAME (new_fix->fx_subsy), "$global$") == 0
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$segrel$") == 0
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$PIC_pcrel$0") == 0
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$tls_gdidx$") == 0
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$tls_ldidx$") == 0
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$tls_dtpoff$") == 0
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$tls_ieoff$") == 0
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$tls_leoff$") == 0))
    new_fix->fx_subsy = NULL;
}

/* This fix_new is called by cons via TC_CONS_FIX_NEW.
   hppa_field_selector is set by the parse_cons_expression_hppa.  */

void
cons_fix_new_hppa (fragS *frag, int where, int size, expressionS *exp)
{
  unsigned int rel_type;

  /* Get a base relocation type.  */
  if (is_DP_relative (*exp))
    rel_type = R_HPPA_GOTOFF;
  else if (is_PC_relative (*exp))
    rel_type = R_HPPA_PCREL_CALL;
#ifdef OBJ_ELF
  else if (is_SB_relative (*exp))
    rel_type = R_PARISC_SEGREL32;
  else if (is_tls_gdidx (*exp))
    rel_type = R_PARISC_TLS_GD21L;
  else if (is_tls_ldidx (*exp))
    rel_type = R_PARISC_TLS_LDM21L;
  else if (is_tls_dtpoff (*exp))
    rel_type = R_PARISC_TLS_LDO21L;
  else if (is_tls_ieoff (*exp))
    rel_type = R_PARISC_TLS_IE21L;
  else if (is_tls_leoff (*exp))
    rel_type = R_PARISC_TLS_LE21L;
#endif
  else if (is_complex (*exp))
    rel_type = R_HPPA_COMPLEX;
  else
    rel_type = R_HPPA;

  if (hppa_field_selector != e_psel && hppa_field_selector != e_fsel)
    {
      as_warn (_("Invalid field selector.  Assuming F%%."));
      hppa_field_selector = e_fsel;
    }

  fix_new_hppa (frag, where, size,
		(symbolS *) NULL, (offsetT) 0, exp, 0, rel_type,
		hppa_field_selector, size * 8, 0, 0);

  /* Reset field selector to its default state.  */
  hppa_field_selector = 0;
}

/* Mark (via expr_end) the end of an expression (I think).  FIXME.  */

static void
get_expression (char *str)
{
  char *save_in;
  asection *seg;

  save_in = input_line_pointer;
  input_line_pointer = str;
  seg = expression (&the_insn.exp);
  if (!(seg == absolute_section
	|| seg == undefined_section
	|| SEG_NORMAL (seg)))
    {
      as_warn (_("Bad segment in expression."));
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return;
    }
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
}

/* Parse a PA nullification completer (,n).  Return nonzero if the
   completer was found; return zero if no completer was found.  */

static int
pa_parse_nullif (char **s)
{
  int nullif;

  nullif = 0;
  if (**s == ',')
    {
      *s = *s + 1;
      if (strncasecmp (*s, "n", 1) == 0)
	nullif = 1;
      else
	{
	  as_bad (_("Invalid Nullification: (%c)"), **s);
	  nullif = 0;
	}
      *s = *s + 1;
    }

  return nullif;
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

/* Write out big-endian.  */

void
md_number_to_chars (char *buf, valueT val, int n)
{
  number_to_chars_bigendian (buf, val, n);
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent **
tc_gen_reloc (asection *section, fixS *fixp)
{
  arelent *reloc;
  struct hppa_fix_struct *hppa_fixp;
  static arelent *no_relocs = NULL;
  arelent **relocs;
  reloc_type **codes;
  reloc_type code;
  int n_relocs;
  int i;

  hppa_fixp = (struct hppa_fix_struct *) fixp->tc_fix_data;
  if (fixp->fx_addsy == 0)
    return &no_relocs;

  gas_assert (hppa_fixp != 0);
  gas_assert (section != 0);

  reloc = xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);

  /* Allow fixup_segment to recognize hand-written pc-relative relocations.
     When we went through cons_fix_new_hppa, we classified them as complex.  */
  /* ??? It might be better to hide this +8 stuff in tc_cfi_emit_pcrel_expr,
     undefine DIFF_EXPR_OK, and let these sorts of complex expressions fail
     when R_HPPA_COMPLEX == R_PARISC_UNIMPLEMENTED.  */
  if (fixp->fx_r_type == (bfd_reloc_code_real_type) R_HPPA_COMPLEX
      && fixp->fx_pcrel)
    {
      fixp->fx_r_type = R_HPPA_PCREL_CALL;
      fixp->fx_offset += 8;
    }

  codes = hppa_gen_reloc_type (stdoutput,
			       fixp->fx_r_type,
			       hppa_fixp->fx_r_format,
			       hppa_fixp->fx_r_field,
			       fixp->fx_subsy != NULL,
			       symbol_get_bfdsym (fixp->fx_addsy));

  if (codes == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line, _("Cannot handle fixup"));
      abort ();
    }

  for (n_relocs = 0; codes[n_relocs]; n_relocs++)
    ;

  relocs = xmalloc (sizeof (arelent *) * n_relocs + 1);
  reloc = xmalloc (sizeof (arelent) * n_relocs);
  for (i = 0; i < n_relocs; i++)
    relocs[i] = &reloc[i];

  relocs[n_relocs] = NULL;

#ifdef OBJ_ELF
  switch (fixp->fx_r_type)
    {
    default:
      gas_assert (n_relocs == 1);

      code = *codes[0];

      /* Now, do any processing that is dependent on the relocation type.  */
      switch (code)
	{
	case R_PARISC_DLTREL21L:
	case R_PARISC_DLTREL14R:
	case R_PARISC_DLTREL14F:
	case R_PARISC_PLABEL32:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL14R:
	  /* For plabel relocations, the addend of the
	     relocation should be either 0 (no static link) or 2
	     (static link required).  This adjustment is done in
	     bfd/elf32-hppa.c:elf32_hppa_relocate_section.

	     We also slam a zero addend into the DLT relative relocs;
	     it doesn't make a lot of sense to use any addend since
	     it gets you a different (eg unknown) DLT entry.  */
	  reloc->addend = 0;
	  break;

#ifdef ELF_ARG_RELOC
	case R_PARISC_PCREL17R:
	case R_PARISC_PCREL17F:
	case R_PARISC_PCREL17C:
	case R_PARISC_DIR17R:
	case R_PARISC_DIR17F:
	case R_PARISC_PCREL21L:
	case R_PARISC_DIR21L:
	  reloc->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc,
					 fixp->fx_offset);
	  break;
#endif

	case R_PARISC_DIR32:
	  /* Facilitate hand-crafted unwind info.  */
	  if (strcmp (section->name, UNWIND_SECTION_NAME) == 0)
	    code = R_PARISC_SEGREL32;
	  /* Fall thru */

	default:
	  reloc->addend = fixp->fx_offset;
	  break;
	}

      reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->howto = bfd_reloc_type_lookup (stdoutput,
					    (bfd_reloc_code_real_type) code);
      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

      gas_assert (reloc->howto && (unsigned int) code == reloc->howto->type);
      break;
    }
#else /* OBJ_SOM */

  /* Walk over reach relocation returned by the BFD backend.  */
  for (i = 0; i < n_relocs; i++)
    {
      code = *codes[i];

      relocs[i]->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
      *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      relocs[i]->howto =
	bfd_reloc_type_lookup (stdoutput,
			       (bfd_reloc_code_real_type) code);
      relocs[i]->address = fixp->fx_frag->fr_address + fixp->fx_where;

      switch (code)
	{
	case R_COMP2:
	  /* The only time we ever use a R_COMP2 fixup is for the difference
	     of two symbols.  With that in mind we fill in all four
	     relocs now and break out of the loop.  */
	  gas_assert (i == 1);
	  relocs[0]->sym_ptr_ptr
	    = (asymbol **) bfd_abs_section_ptr->symbol_ptr_ptr;
	  relocs[0]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[0]);
	  relocs[0]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[0]->addend = 0;
	  relocs[1]->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	  *relocs[1]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
	  relocs[1]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[1]);
	  relocs[1]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[1]->addend = 0;
	  relocs[2]->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	  *relocs[2]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_subsy);
	  relocs[2]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[2]);
	  relocs[2]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[2]->addend = 0;
	  relocs[3]->sym_ptr_ptr
	    = (asymbol **) bfd_abs_section_ptr->symbol_ptr_ptr;
	  relocs[3]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[3]);
	  relocs[3]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[3]->addend = 0;
	  relocs[4]->sym_ptr_ptr
	    = (asymbol **) bfd_abs_section_ptr->symbol_ptr_ptr;
	  relocs[4]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[4]);
	  relocs[4]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[4]->addend = 0;
	  goto done;
	case R_PCREL_CALL:
	case R_ABS_CALL:
	  relocs[i]->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc, 0);
	  break;

	case R_DLT_REL:
	case R_DATA_PLABEL:
	case R_CODE_PLABEL:
	  /* For plabel relocations, the addend of the
	     relocation should be either 0 (no static link) or 2
	     (static link required).

	     FIXME: We always assume no static link!

	     We also slam a zero addend into the DLT relative relocs;
	     it doesn't make a lot of sense to use any addend since
	     it gets you a different (eg unknown) DLT entry.  */
	  relocs[i]->addend = 0;
	  break;

	case R_N_MODE:
	case R_S_MODE:
	case R_D_MODE:
	case R_R_MODE:
	case R_FSEL:
	case R_LSEL:
	case R_RSEL:
	case R_BEGIN_BRTAB:
	case R_END_BRTAB:
	case R_BEGIN_TRY:
	case R_N0SEL:
	case R_N1SEL:
	  /* There is no symbol or addend associated with these fixups.  */
	  relocs[i]->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	  *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
	  relocs[i]->addend = 0;
	  break;

	case R_END_TRY:
	case R_ENTRY:
	case R_EXIT:
	  /* There is no symbol associated with these fixups.  */
	  relocs[i]->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
	  *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
	  relocs[i]->addend = fixp->fx_offset;
	  break;

	default:
	  relocs[i]->addend = fixp->fx_offset;
	}
    }

 done:
#endif

  return relocs;
}

/* Process any machine dependent frag types.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec ATTRIBUTE_UNUSED,
		 fragS *fragP)
{
  unsigned int address;

  if (fragP->fr_type == rs_machine_dependent)
    {
      switch ((int) fragP->fr_subtype)
	{
	case 0:
	  fragP->fr_type = rs_fill;
	  know (fragP->fr_var == 1);
	  know (fragP->fr_next);
	  address = fragP->fr_address + fragP->fr_fix;
	  if (address % fragP->fr_offset)
	    {
	      fragP->fr_offset =
		fragP->fr_next->fr_address
		- fragP->fr_address
		- fragP->fr_fix;
	    }
	  else
	    fragP->fr_offset = 0;
	  break;
	}
    }
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (asection *segment, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  int align2 = (1 << align) - 1;

  return (size + align2) & ~align2;
}

/* Return the approximate size of a frag before relaxation has occurred.  */

int
md_estimate_size_before_relax (fragS *fragP, asection *segment ATTRIBUTE_UNUSED)
{
  int size;

  size = 0;

  while ((fragP->fr_fix + size) % fragP->fr_offset)
    size++;

  return size;
}

#ifdef OBJ_ELF
# ifdef WARN_COMMENTS
const char *md_shortopts = "Vc";
# else
const char *md_shortopts = "V";
# endif
#else
# ifdef WARN_COMMENTS
const char *md_shortopts = "c";
# else
const char *md_shortopts = "";
# endif
#endif

struct option md_longopts[] =
{
#ifdef WARN_COMMENTS
  {"warn-comment", no_argument, NULL, 'c'},
#endif
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    default:
      return 0;

#ifdef OBJ_ELF
    case 'V':
      print_version_id ();
      break;
#endif
#ifdef WARN_COMMENTS
    case 'c':
      warn_comment = 1;
      break;
#endif
    }

  return 1;
}

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
#ifdef OBJ_ELF
  fprintf (stream, _("\
  -Q                      ignored\n"));
#endif
#ifdef WARN_COMMENTS
  fprintf (stream, _("\
  -c                      print a warning if a comment is found\n"));
#endif
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return NULL;
}

#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
#define nonzero_dibits(x) \
  ((x) | (((x) & 0x55555555) << 1) | (((x) & 0xAAAAAAAA) >> 1))
#define arg_reloc_stub_needed(CALLER, CALLEE) \
  (((CALLER) ^ (CALLEE)) & nonzero_dibits (CALLER) & nonzero_dibits (CALLEE))
#else
#define arg_reloc_stub_needed(CALLER, CALLEE) 0
#endif

/* Apply a fixup to an instruction.  */

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *fixpos;
  struct hppa_fix_struct *hppa_fixP;
  offsetT new_val;
  int insn, val, fmt;

  /* SOM uses R_HPPA_ENTRY and R_HPPA_EXIT relocations which can
     never be "applied" (they are just markers).  Likewise for
     R_HPPA_BEGIN_BRTAB and R_HPPA_END_BRTAB.  */
#ifdef OBJ_SOM
  if (fixP->fx_r_type == R_HPPA_ENTRY
      || fixP->fx_r_type == R_HPPA_EXIT
      || fixP->fx_r_type == R_HPPA_BEGIN_BRTAB
      || fixP->fx_r_type == R_HPPA_END_BRTAB
      || fixP->fx_r_type == R_HPPA_BEGIN_TRY)
    return;

  /* Disgusting.  We must set fx_offset ourselves -- R_HPPA_END_TRY
     fixups are considered not adjustable, which in turn causes
     adjust_reloc_syms to not set fx_offset.  Ugh.  */
  if (fixP->fx_r_type == R_HPPA_END_TRY)
    {
      fixP->fx_offset = * valP;
      return;
    }
#endif
#ifdef OBJ_ELF
  if (fixP->fx_r_type == (int) R_PARISC_GNU_VTENTRY
      || fixP->fx_r_type == (int) R_PARISC_GNU_VTINHERIT)
    return;
#endif

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;

  /* There should be a HPPA specific fixup associated with the GAS fixup.  */
  hppa_fixP = (struct hppa_fix_struct *) fixP->tc_fix_data;
  if (hppa_fixP == NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("no hppa_fixup entry for fixup type 0x%x"),
		    fixP->fx_r_type);
      return;
    }

  fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;

  if (fixP->fx_size != 4 || hppa_fixP->fx_r_format == 32)
    {
      /* Handle constant output. */
      number_to_chars_bigendian (fixpos, *valP, fixP->fx_size);
      return;
    }

  insn = bfd_get_32 (stdoutput, fixpos);
  fmt = bfd_hppa_insn2fmt (stdoutput, insn);

  /* If there is a symbol associated with this fixup, then it's something
     which will need a SOM relocation (except for some PC-relative relocs).
     In such cases we should treat the "val" or "addend" as zero since it
     will be added in as needed from fx_offset in tc_gen_reloc.  */
  if ((fixP->fx_addsy != NULL
       || fixP->fx_r_type == (int) R_HPPA_NONE)
#ifdef OBJ_SOM
      && fmt != 32
#endif
      )
    new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
#ifdef OBJ_SOM
  /* These field selectors imply that we do not want an addend.  */
  else if (hppa_fixP->fx_r_field == e_psel
	   || hppa_fixP->fx_r_field == e_rpsel
	   || hppa_fixP->fx_r_field == e_lpsel
	   || hppa_fixP->fx_r_field == e_tsel
	   || hppa_fixP->fx_r_field == e_rtsel
	   || hppa_fixP->fx_r_field == e_ltsel)
    new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
#endif
  else
    new_val = hppa_field_adjust (* valP, 0, hppa_fixP->fx_r_field);

  /* Handle pc-relative exceptions from above.  */
  if ((fmt == 12 || fmt == 17 || fmt == 22)
      && fixP->fx_addsy
      && fixP->fx_pcrel
      && !arg_reloc_stub_needed (symbol_arg_reloc_info (fixP->fx_addsy),
				 hppa_fixP->fx_arg_reloc)
#ifdef OBJ_ELF
      && (* valP - 8 + 8192 < 16384
	  || (fmt == 17 && * valP - 8 + 262144 < 524288)
	  || (fmt == 22 && * valP - 8 + 8388608 < 16777216))
#endif
#ifdef OBJ_SOM
      && (* valP - 8 + 262144 < 524288
	  || (fmt == 22 && * valP - 8 + 8388608 < 16777216))
#endif
      && !S_IS_EXTERNAL (fixP->fx_addsy)
      && !S_IS_WEAK (fixP->fx_addsy)
      && S_GET_SEGMENT (fixP->fx_addsy) == hppa_fixP->segment
      && !(fixP->fx_subsy
	   && S_GET_SEGMENT (fixP->fx_subsy) != hppa_fixP->segment))
    {
      new_val = hppa_field_adjust (* valP, 0, hppa_fixP->fx_r_field);
    }

  switch (fmt)
    {
    case 10:
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = (insn & ~ 0x3ff1) | (((val & 0x1ff8) << 1)
				  | ((val & 0x2000) >> 13));
      break;
    case -11:
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = (insn & ~ 0x3ff9) | (((val & 0x1ffc) << 1)
				  | ((val & 0x2000) >> 13));
      break;
      /* Handle all opcodes with the 'j' operand type.  */
    case 14:
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = ((insn & ~ 0x3fff) | low_sign_unext (val, 14));
      break;

      /* Handle all opcodes with the 'k' operand type.  */
    case 21:
      CHECK_FIELD_WHERE (new_val, 1048575, -1048576,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = (insn & ~ 0x1fffff) | re_assemble_21 (val);
      break;

      /* Handle all the opcodes with the 'i' operand type.  */
    case 11:
      CHECK_FIELD_WHERE (new_val, 1023, -1024,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = (insn & ~ 0x7ff) | low_sign_unext (val, 11);
      break;

      /* Handle all the opcodes with the 'w' operand type.  */
    case 12:
      CHECK_FIELD_WHERE (new_val - 8, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val - 8;

      insn = (insn & ~ 0x1ffd) | re_assemble_12 (val >> 2);
      break;

      /* Handle some of the opcodes with the 'W' operand type.  */
    case 17:
      {
	offsetT distance = * valP;

	/* If this is an absolute branch (ie no link) with an out of
	   range target, then we want to complain.  */
	if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
	    && (insn & 0xffe00000) == 0xe8000000)
	  CHECK_FIELD_WHERE (distance - 8, 262143, -262144,
			     fixP->fx_file, fixP->fx_line);

	CHECK_FIELD_WHERE (new_val - 8, 262143, -262144,
			   fixP->fx_file, fixP->fx_line);
	val = new_val - 8;

	insn = (insn & ~ 0x1f1ffd) | re_assemble_17 (val >> 2);
	break;
      }

    case 22:
      {
	offsetT distance = * valP;

	/* If this is an absolute branch (ie no link) with an out of
	   range target, then we want to complain.  */
	if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
	    && (insn & 0xffe00000) == 0xe8000000)
	  CHECK_FIELD_WHERE (distance - 8, 8388607, -8388608,
			     fixP->fx_file, fixP->fx_line);

	CHECK_FIELD_WHERE (new_val - 8, 8388607, -8388608,
			   fixP->fx_file, fixP->fx_line);
	val = new_val - 8;

	insn = (insn & ~ 0x3ff1ffd) | re_assemble_22 (val >> 2);
	break;
      }

    case -10:
      val = new_val;
      insn = (insn & ~ 0xfff1) | re_assemble_16 (val & -8);
      break;

    case -16:
      val = new_val;
      insn = (insn & ~ 0xfff9) | re_assemble_16 (val & -4);
      break;

    case 16:
      val = new_val;
      insn = (insn & ~ 0xffff) | re_assemble_16 (val);
      break;

    case 32:
      insn = new_val;
      break;

    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("Unknown relocation encountered in md_apply_fix."));
      return;
    }

#ifdef OBJ_ELF
  switch (fixP->fx_r_type)
    {
      case R_PARISC_TLS_GD21L:
      case R_PARISC_TLS_GD14R:
      case R_PARISC_TLS_LDM21L:
      case R_PARISC_TLS_LDM14R:
      case R_PARISC_TLS_LE21L:
      case R_PARISC_TLS_LE14R:
      case R_PARISC_TLS_IE21L:
      case R_PARISC_TLS_IE14R:
	if (fixP->fx_addsy)
	  S_SET_THREAD_LOCAL (fixP->fx_addsy);
	break;
      default:
	break;
    }
#endif

  /* Insert the relocation.  */
  bfd_put_32 (stdoutput, insn, fixpos);
}

/* Exactly what point is a PC-relative offset relative TO?
   On the PA, they're relative to the address of the offset.  */

long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_where + fixP->fx_frag->fr_address;
}

/* Return nonzero if the input line pointer is at the end of
   a statement.  */

static int
is_end_of_statement (void)
{
  return ((*input_line_pointer == '\n')
	  || (*input_line_pointer == ';')
	  || (*input_line_pointer == '!'));
}

#define REG_NAME_CNT	(sizeof (pre_defined_registers) / sizeof (struct pd_reg))

/* Given NAME, find the register number associated with that name, return
   the integer value associated with the given name or -1 on failure.  */

static int
reg_name_search (char *name)
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = REG_NAME_CNT - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, pre_defined_registers[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return pre_defined_registers[middle].value;
    }
  while (low <= high);

  return -1;
}

/* Read a number from S.  The number might come in one of many forms,
   the most common will be a hex or decimal constant, but it could be
   a pre-defined register (Yuk!), or an absolute symbol.

   Return 1 on success or 0 on failure.  If STRICT, then a missing
   register prefix will cause a failure.  The number itself is
   returned in `pa_number'.

   IS_FLOAT indicates that a PA-89 FP register number should be
   parsed;  A `l' or `r' suffix is checked for if but 2 of IS_FLOAT is
   not set.

   pa_parse_number can not handle negative constants and will fail
   horribly if it is passed such a constant.  */

static int
pa_parse_number (char **s, int is_float)
{
  int num;
  char *name;
  char c;
  symbolS *sym;
  int status;
  char *p = *s;
  bfd_boolean have_prefix;

  /* Skip whitespace before the number.  */
  while (*p == ' ' || *p == '\t')
    p = p + 1;

  pa_number = -1;
  have_prefix = 0;
  num = 0;
  if (!strict && ISDIGIT (*p))
    {
      /* Looks like a number.  */

      if (*p == '0' && (*(p + 1) == 'x' || *(p + 1) == 'X'))
	{
	  /* The number is specified in hex.  */
	  p += 2;
	  while (ISDIGIT (*p) || ((*p >= 'a') && (*p <= 'f'))
		 || ((*p >= 'A') && (*p <= 'F')))
	    {
	      if (ISDIGIT (*p))
		num = num * 16 + *p - '0';
	      else if (*p >= 'a' && *p <= 'f')
		num = num * 16 + *p - 'a' + 10;
	      else
		num = num * 16 + *p - 'A' + 10;
	      ++p;
	    }
	}
      else
	{
	  /* The number is specified in decimal.  */
	  while (ISDIGIT (*p))
	    {
	      num = num * 10 + *p - '0';
	      ++p;
	    }
	}

      pa_number = num;

      /* Check for a `l' or `r' suffix.  */
      if (is_float)
	{
	  pa_number += FP_REG_BASE;
	  if (! (is_float & 2))
	    {
	      if (IS_R_SELECT (p))
		{
		  pa_number += FP_REG_RSEL;
		  ++p;
		}
	      else if (IS_L_SELECT (p))
		{
		  ++p;
		}
	    }
	}
    }
  else if (*p == '%')
    {
      /* The number might be a predefined register.  */
      have_prefix = 1;
      name = p;
      p++;
      c = *p;
      /* Tege hack: Special case for general registers as the general
	 code makes a binary search with case translation, and is VERY
	 slow.  */
      if (c == 'r')
	{
	  p++;
	  if (*p == 'e' && *(p + 1) == 't'
	      && (*(p + 2) == '0' || *(p + 2) == '1'))
	    {
	      p += 2;
	      num = *p - '0' + 28;
	      p++;
	    }
	  else if (*p == 'p')
	    {
	      num = 2;
	      p++;
	    }
	  else if (!ISDIGIT (*p))
	    {
	      if (print_errors)
		as_bad (_("Undefined register: '%s'."), name);
	      num = -1;
	    }
	  else
	    {
	      do
		num = num * 10 + *p++ - '0';
	      while (ISDIGIT (*p));
	    }
	}
      else
	{
	  /* Do a normal register search.  */
	  while (is_part_of_name (c))
	    {
	      p = p + 1;
	      c = *p;
	    }
	  *p = 0;
	  status = reg_name_search (name);
	  if (status >= 0)
	    num = status;
	  else
	    {
	      if (print_errors)
		as_bad (_("Undefined register: '%s'."), name);
	      num = -1;
	    }
	  *p = c;
	}

      pa_number = num;
    }
  else
    {
      /* And finally, it could be a symbol in the absolute section which
	 is effectively a constant, or a register alias symbol.  */
      name = p;
      c = *p;
      while (is_part_of_name (c))
	{
	  p = p + 1;
	  c = *p;
	}
      *p = 0;
      if ((sym = symbol_find (name)) != NULL)
	{
	  if (S_GET_SEGMENT (sym) == reg_section)
	    {
	      num = S_GET_VALUE (sym);
	      /* Well, we don't really have one, but we do have a
		 register, so...  */
	      have_prefix = TRUE;
	    }
	  else if (S_GET_SEGMENT (sym) == bfd_abs_section_ptr)
	    num = S_GET_VALUE (sym);
	  else if (!strict)
	    {
	      if (print_errors)
		as_bad (_("Non-absolute symbol: '%s'."), name);
	      num = -1;
	    }
	}
      else if (!strict)
	{
	  /* There is where we'd come for an undefined symbol
	     or for an empty string.  For an empty string we
	     will return zero.  That's a concession made for
	     compatibility with the braindamaged HP assemblers.  */
	  if (*name == 0)
	    num = 0;
	  else
	    {
	      if (print_errors)
		as_bad (_("Undefined absolute constant: '%s'."), name);
	      num = -1;
	    }
	}
      *p = c;

      pa_number = num;
    }

  if (!strict || have_prefix)
    {
      *s = p;
      return 1;
    }
  return 0;
}

/* Return nonzero if the given INSN and L/R information will require
   a new PA-1.1 opcode.  */

static int
need_pa11_opcode (void)
{
  if ((pa_number & FP_REG_RSEL) != 0
      && !(the_insn.fpof1 == DBL && the_insn.fpof2 == DBL))
    {
      /* If this instruction is specific to a particular architecture,
	 then set a new architecture.  */
      if (bfd_get_mach (stdoutput) < pa11)
	{
	  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, pa11))
	    as_warn (_("could not update architecture and machine"));
	}
      return TRUE;
    }
  else
    return FALSE;
}

/* Parse a condition for a fcmp instruction.  Return the numerical
   code associated with the condition.  */

static int
pa_parse_fp_cmp_cond (char **s)
{
  int cond, i;

  cond = 0;

  for (i = 0; i < 32; i++)
    {
      if (strncasecmp (*s, fp_cond_map[i].string,
		       strlen (fp_cond_map[i].string)) == 0)
	{
	  cond = fp_cond_map[i].cond;
	  *s += strlen (fp_cond_map[i].string);
	  /* If not a complete match, back up the input string and
	     report an error.  */
	  if (**s != ' ' && **s != '\t')
	    {
	      *s -= strlen (fp_cond_map[i].string);
	      break;
	    }
	  while (**s == ' ' || **s == '\t')
	    *s = *s + 1;
	  return cond;
	}
    }

  as_bad (_("Invalid FP Compare Condition: %s"), *s);

  /* Advance over the bogus completer.  */
  while (**s != ',' && **s != ' ' && **s != '\t')
    *s += 1;

  return 0;
}

/* Parse a graphics test complete for ftest.  */

static int
pa_parse_ftest_gfx_completer (char **s)
{
  int value;

  value = 0;
  if (strncasecmp (*s, "acc8", 4) == 0)
    {
      value = 5;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc6", 4) == 0)
    {
      value = 9;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc4", 4) == 0)
    {
      value = 13;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc2", 4) == 0)
    {
      value = 17;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc", 3) == 0)
    {
      value = 1;
      *s += 3;
    }
  else if (strncasecmp (*s, "rej8", 4) == 0)
    {
      value = 6;
      *s += 4;
    }
  else if (strncasecmp (*s, "rej", 3) == 0)
    {
      value = 2;
      *s += 3;
    }
  else
    {
      value = 0;
      as_bad (_("Invalid FTEST completer: %s"), *s);
    }

  return value;
}

/* Parse an FP operand format completer returning the completer
   type.  */

static fp_operand_format
pa_parse_fp_cnv_format (char **s)
{
  int format;

  format = SGL;
  if (**s == ',')
    {
      *s += 1;
      if (strncasecmp (*s, "sgl", 3) == 0)
	{
	  format = SGL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "dbl", 3) == 0)
	{
	  format = DBL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "quad", 4) == 0)
	{
	  format = QUAD;
	  *s += 5;
	}
      else if (strncasecmp (*s, "w", 1) == 0)
	{
	  format = W;
	  *s += 2;
	}
      else if (strncasecmp (*s, "uw", 2) == 0)
	{
	  format = UW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "dw", 2) == 0)
	{
	  format = DW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "udw", 3) == 0)
	{
	  format = UDW;
	  *s += 4;
	}
      else if (strncasecmp (*s, "qw", 2) == 0)
	{
	  format = QW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "uqw", 3) == 0)
	{
	  format = UQW;
	  *s += 4;
	}
      else
	{
	  format = ILLEGAL_FMT;
	  as_bad (_("Invalid FP Operand Format: %3s"), *s);
	}
    }

  return format;
}

/* Parse an FP operand format completer returning the completer
   type.  */

static fp_operand_format
pa_parse_fp_format (char **s)
{
  int format;

  format = SGL;
  if (**s == ',')
    {
      *s += 1;
      if (strncasecmp (*s, "sgl", 3) == 0)
	{
	  format = SGL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "dbl", 3) == 0)
	{
	  format = DBL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "quad", 4) == 0)
	{
	  format = QUAD;
	  *s += 5;
	}
      else
	{
	  format = ILLEGAL_FMT;
	  as_bad (_("Invalid FP Operand Format: %3s"), *s);
	}
    }

  return format;
}

/* Convert from a selector string into a selector type.  */

static int
pa_chk_field_selector (char **str)
{
  int middle, low, high;
  int cmp;
  char name[4];

  /* Read past any whitespace.  */
  /* FIXME: should we read past newlines and formfeeds??? */
  while (**str == ' ' || **str == '\t' || **str == '\n' || **str == '\f')
    *str = *str + 1;

  if ((*str)[1] == '\'' || (*str)[1] == '%')
    name[0] = TOLOWER ((*str)[0]),
    name[1] = 0;
  else if ((*str)[2] == '\'' || (*str)[2] == '%')
    name[0] = TOLOWER ((*str)[0]),
    name[1] = TOLOWER ((*str)[1]),
    name[2] = 0;
  else if ((*str)[3] == '\'' || (*str)[3] == '%')
    name[0] = TOLOWER ((*str)[0]),
    name[1] = TOLOWER ((*str)[1]),
    name[2] = TOLOWER ((*str)[2]),
    name[3] = 0;
  else
    return e_fsel;

  low = 0;
  high = sizeof (selector_table) / sizeof (struct selector_entry) - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcmp (name, selector_table[middle].prefix);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	{
	  *str += strlen (name) + 1;
#ifndef OBJ_SOM
	  if (selector_table[middle].field_selector == e_nsel)
	    return e_fsel;
#endif
	  return selector_table[middle].field_selector;
	}
    }
  while (low <= high);

  return e_fsel;
}

/* Parse a .byte, .word, .long expression for the HPPA.  Called by
   cons via the TC_PARSE_CONS_EXPRESSION macro.  */

void
parse_cons_expression_hppa (expressionS *exp)
{
  hppa_field_selector = pa_chk_field_selector (&input_line_pointer);
  expression (exp);
}

/* Evaluate an absolute expression EXP which may be modified by
   the selector FIELD_SELECTOR.  Return the value of the expression.  */
static int
evaluate_absolute (struct pa_it *insn)
{
  offsetT value;
  expressionS exp;
  int field_selector = insn->field_selector;

  exp = insn->exp;
  value = exp.X_add_number;

  return hppa_field_adjust (0, value, field_selector);
}

/* Mark (via expr_end) the end of an absolute expression.  FIXME.  */

static int
pa_get_absolute_expression (struct pa_it *insn, char **strp)
{
  char *save_in;

  insn->field_selector = pa_chk_field_selector (strp);
  save_in = input_line_pointer;
  input_line_pointer = *strp;
  expression (&insn->exp);
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
  if (insn->exp.X_op != O_constant)
    {
      /* We have a non-match in strict mode.  */
      if (!strict)
	as_bad (_("Bad segment (should be absolute)."));
      return 0;
    }
  return evaluate_absolute (insn);
}

/* Get an absolute number.  The input string is terminated at the
   first whitespace character.  */

static int
pa_get_number (struct pa_it *insn, char **strp)
{
  char *save_in;
  char *s, c;
  int result;

  save_in = input_line_pointer;
  input_line_pointer = *strp;

  /* The PA assembly syntax is ambiguous in a variety of ways.  Consider
     this string "4 %r5"  Is that the number 4 followed by the register
     r5, or is that 4 MOD r5?  This situation occurs for example in the
     coprocessor load and store instructions.  Previously, calling
     pa_get_absolute_expression directly results in r5 being entered
     in the symbol table.

     So, when looking for an absolute number, we cut off the input string
     at the first whitespace character.  Thus, expressions should generally
     contain no whitespace.  */

  s = *strp;
  while (*s != ',' && *s != ' ' && *s != '\t')
    s++;

  c = *s;
  *s = 0;

  result = pa_get_absolute_expression (insn, strp);

  input_line_pointer = save_in;
  *s = c;
  return result;
}

/* Given an argument location specification return the associated
   argument location number.  */

static unsigned int
pa_build_arg_reloc (char *type_name)
{

  if (strncasecmp (type_name, "no", 2) == 0)
    return 0;
  if (strncasecmp (type_name, "gr", 2) == 0)
    return 1;
  else if (strncasecmp (type_name, "fr", 2) == 0)
    return 2;
  else if (strncasecmp (type_name, "fu", 2) == 0)
    return 3;
  else
    as_bad (_("Invalid argument location: %s\n"), type_name);

  return 0;
}

/* Encode and return an argument relocation specification for
   the given register in the location specified by arg_reloc.  */

static unsigned int
pa_align_arg_reloc (unsigned int reg, unsigned int arg_reloc)
{
  unsigned int new_reloc;

  new_reloc = arg_reloc;
  switch (reg)
    {
    case 0:
      new_reloc <<= 8;
      break;
    case 1:
      new_reloc <<= 6;
      break;
    case 2:
      new_reloc <<= 4;
      break;
    case 3:
      new_reloc <<= 2;
      break;
    default:
      as_bad (_("Invalid argument description: %d"), reg);
    }

  return new_reloc;
}

/* Parse a non-negated compare/subtract completer returning the
   number (for encoding in instructions) of the given completer.  */

static int
pa_parse_nonneg_cmpsub_cmpltr (char **s)
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "<<") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "<<=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "od") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
	 completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a negated compare/subtract completer returning the
   number (for encoding in instructions) of the given completer.  */

static int
pa_parse_neg_cmpsub_cmpltr (char **s)
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, ">>=") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, ">>") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "nsv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "ev") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
	 completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a 64 bit compare and branch completer returning the number (for
   encoding in instructions) of the given completer.

   Nonnegated comparisons are returned as 0-7, negated comparisons are
   returned as 8-15.  */

static int
pa_parse_cmpb_64_cmpltr (char **s)
{
  int cmpltr;
  char *name = *s + 1;
  char c;

  cmpltr = -1;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "*") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "*=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "*<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "*<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "*<<") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "*<<=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*od") == 0)
	{
	  cmpltr = 7;
	}
      else if (strcasecmp (name, "*tr") == 0)
	{
	  cmpltr = 8;
	}
      else if (strcmp (name, "*<>") == 0)
	{
	  cmpltr = 9;
	}
      else if (strcmp (name, "*>=") == 0)
	{
	  cmpltr = 10;
	}
      else if (strcmp (name, "*>") == 0)
	{
	  cmpltr = 11;
	}
      else if (strcmp (name, "*>>=") == 0)
	{
	  cmpltr = 12;
	}
      else if (strcmp (name, "*>>") == 0)
	{
	  cmpltr = 13;
	}
      else if (strcasecmp (name, "*nsv") == 0)
	{
	  cmpltr = 14;
	}
      else if (strcasecmp (name, "*ev") == 0)
	{
	  cmpltr = 15;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  return cmpltr;
}

/* Parse a 64 bit compare immediate and branch completer returning the number
   (for encoding in instructions) of the given completer.  */

static int
pa_parse_cmpib_64_cmpltr (char **s)
{
  int cmpltr;
  char *name = *s + 1;
  char c;

  cmpltr = -1;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "*<<") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "*=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "*<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "*<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "*>>=") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "*<>") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*>=") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*>") == 0)
	{
	  cmpltr = 7;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  return cmpltr;
}

/* Parse a non-negated addition completer returning the number
   (for encoding in instructions) of the given completer.  */

static int
pa_parse_nonneg_add_cmpltr (char **s)
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;
      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcasecmp (name, "nuv") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcasecmp (name, "znv") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "od") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
	 completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a negated addition completer returning the number
   (for encoding in instructions) of the given completer.  */

static int
pa_parse_neg_add_cmpltr (char **s)
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;
      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcasecmp (name, "uv") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcasecmp (name, "vnz") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "nsv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "ev") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
	 completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a 64 bit wide mode add and branch completer returning the number (for
   encoding in instructions) of the given completer.  */

static int
pa_parse_addb_64_cmpltr (char **s)
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;
      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcasecmp (name, "nuv") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcasecmp (name, "*=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*<") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*<=") == 0)
	{
	  cmpltr = 7;
	}
      else if (strcmp (name, "tr") == 0)
	{
	  cmpltr = 8;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 9;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 10;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 11;
	}
      else if (strcasecmp (name, "uv") == 0)
	{
	  cmpltr = 12;
	}
      else if (strcasecmp (name, "*<>") == 0)
	{
	  cmpltr = 13;
	}
      else if (strcasecmp (name, "*>=") == 0)
	{
	  cmpltr = 14;
	}
      else if (strcasecmp (name, "*>") == 0)
	{
	  cmpltr = 15;
	}
      /* If we have something like addb,n then there is no condition
	 completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Do the real work for assembling a single instruction.  Store results
   into the global "the_insn" variable.  */

static void
pa_ip (char *str)
{
  char *error_message = "";
  char *s, c, *argstart, *name, *save_s;
  const char *args;
  int match = FALSE;
  int comma = 0;
  int cmpltr, nullif, flag, cond, need_cond, num;
  int immediate_check = 0, pos = -1, len = -1;
  unsigned long opcode;
  struct pa_opcode *insn;

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  /* Convert everything up to the first whitespace character into lower
     case.  */
  for (s = str; *s != ' ' && *s != '\t' && *s != '\n' && *s != '\0'; s++)
    *s = TOLOWER (*s);

  /* Skip to something interesting.  */
  for (s = str;
       ISUPPER (*s) || ISLOWER (*s) || (*s >= '0' && *s <= '3');
       ++s)
    ;

  switch (*s)
    {

    case '\0':
      break;

    case ',':
      comma = 1;

      /*FALLTHROUGH */

    case ' ':
      *s++ = '\0';
      break;

    default:
      as_bad (_("Unknown opcode: `%s'"), str);
      return;
    }

  /* Look up the opcode in the hash table.  */
  if ((insn = (struct pa_opcode *) hash_find (op_hash, str)) == NULL)
    {
      as_bad (_("Unknown opcode: `%s'"), str);
      return;
    }

  if (comma)
    *--s = ',';

  /* Mark the location where arguments for the instruction start, then
     start processing them.  */
  argstart = s;
  for (;;)
    {
      /* Do some initialization.  */
      opcode = insn->match;
      strict = (insn->flags & FLAG_STRICT);
      memset (&the_insn, 0, sizeof (the_insn));
      need_cond = 1;

      the_insn.reloc = R_HPPA_NONE;

      if (insn->arch >= pa20
	  && bfd_get_mach (stdoutput) < insn->arch)
	goto failed;

      /* Build the opcode, checking as we go to make
	 sure that the operands match.  */
      for (args = insn->args;; ++args)
	{
	  /* Absorb white space in instruction.  */
	  while (*s == ' ' || *s == '\t')
	    s++;

	  switch (*args)
	    {
	    /* End of arguments.  */
	    case '\0':
	      if (*s == '\0')
		match = TRUE;
	      break;

	    case '+':
	      if (*s == '+')
		{
		  ++s;
		  continue;
		}
	      if (*s == '-')
		continue;
	      break;

	    /* These must match exactly.  */
	    case '(':
	    case ')':
	    case ',':
	    case ' ':
	      if (*s++ == *args)
		continue;
	      break;

	    /* Handle a 5 bit register or control register field at 10.  */
	    case 'b':
	    case '^':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);

	    /* Handle %sar or %cr11.  No bits get set, we just verify that it
	       is there.  */
	    case '!':
	      /* Skip whitespace before register.  */
	      while (*s == ' ' || *s == '\t')
		s = s + 1;

	      if (!strncasecmp (s, "%sar", 4))
		{
		  s += 4;
		  continue;
		}
	      else if (!strncasecmp (s, "%cr11", 5))
		{
		  s += 5;
		  continue;
		}
	      break;

	    /* Handle a 5 bit register field at 15.  */
	    case 'x':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

	    /* Handle a 5 bit register field at 31.  */
	    case 't':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 5 bit register field at 10 and 15.  */
	    case 'a':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      opcode |= num << 16;
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);

	    /* Handle a 5 bit field length at 31.  */
	    case 'T':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 32, 1, 0);
	      SAVE_IMMEDIATE(num);
	      INSERT_FIELD_AND_CONTINUE (opcode, 32 - num, 0);

	    /* Handle a 5 bit immediate at 15.  */
	    case '5':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      /* When in strict mode, we want to just reject this
		 match instead of giving an out of range error.  */
	      CHECK_FIELD (num, 15, -16, strict);
	      num = low_sign_unext (num, 5);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

	    /* Handle a 5 bit immediate at 31.  */
	    case 'V':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      /* When in strict mode, we want to just reject this
		 match instead of giving an out of range error.  */
	      CHECK_FIELD (num, 15, -16, strict);
	      num = low_sign_unext (num, 5);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle an unsigned 5 bit immediate at 31.  */
	    case 'r':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle an unsigned 5 bit immediate at 15.  */
	    case 'R':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

	    /* Handle an unsigned 10 bit immediate at 15.  */
	    case 'U':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1023, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

	    /* Handle a 2 bit space identifier at 17.  */
	    case 's':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 3, 0, 1);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 14);

	    /* Handle a 3 bit space identifier at 18.  */
	    case 'S':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 7, 0, 1);
	      opcode |= re_assemble_3 (num);
	      continue;

	    /* Handle all completers.  */
	    case 'c':
	      switch (*++args)
		{

		/* Handle a completer for an indexing load or store.  */
		case 'X':
		case 'x':
		  {
		    int uu = 0;
		    int m = 0;
		    int i = 0;
		    while (*s == ',' && i < 2)
		      {
			s++;
			if (strncasecmp (s, "sm", 2) == 0)
			  {
			    uu = 1;
			    m = 1;
			    s++;
			    i++;
			  }
			else if (strncasecmp (s, "m", 1) == 0)
			  m = 1;
			else if ((strncasecmp (s, "s ", 2) == 0)
				 || (strncasecmp (s, "s,", 2) == 0))
			  uu = 1;
			else if (strict)
			  {
			    /* This is a match failure.  */
			    s--;
			    break;
			  }
			else
			  as_bad (_("Invalid Indexed Load Completer."));
			s++;
			i++;
		      }
		    if (i > 2)
		      as_bad (_("Invalid Indexed Load Completer Syntax."));
		    opcode |= m << 5;
		    INSERT_FIELD_AND_CONTINUE (opcode, uu, 13);
		  }

		/* Handle a short load/store completer.  */
		case 'M':
		case 'm':
		case 'q':
		case 'J':
		case 'e':
		  {
		    int a = 0;
		    int m = 0;
		    if (*s == ',')
		      {
			s++;
			if (strncasecmp (s, "ma", 2) == 0)
			  {
			    a = 0;
			    m = 1;
			    s += 2;
			  }
			else if (strncasecmp (s, "mb", 2) == 0)
			  {
			    a = 1;
			    m = 1;
			    s += 2;
			  }
			else if (strict)
			  /* This is a match failure.  */
			  s--;
			else
			  {
			    as_bad (_("Invalid Short Load/Store Completer."));
			    s += 2;
			  }
		      }
		    /* If we did not get a ma/mb completer, then we do not
		       consider this a positive match for 'ce'.  */
		    else if (*args == 'e')
		      break;

		   /* 'J', 'm', 'M' and 'q' are the same, except for where they
		       encode the before/after field.  */
		   if (*args == 'm' || *args == 'M')
		      {
			opcode |= m << 5;
			INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
		      }
		    else if (*args == 'q')
		      {
			opcode |= m << 3;
			INSERT_FIELD_AND_CONTINUE (opcode, a, 2);
		      }
		    else if (*args == 'J')
		      {
			/* M bit is explicit in the major opcode.  */
			INSERT_FIELD_AND_CONTINUE (opcode, a, 2);
		      }
		    else if (*args == 'e')
		      {
			/* Stash the ma/mb flag temporarily in the
			   instruction.  We will use (and remove it)
			   later when handling 'J', 'K', '<' & '>'.  */
			opcode |= a;
			continue;
		      }
		  }

		/* Handle a stbys completer.  */
		case 'A':
		case 's':
		  {
		    int a = 0;
		    int m = 0;
		    int i = 0;
		    while (*s == ',' && i < 2)
		      {
			s++;
			if (strncasecmp (s, "m", 1) == 0)
			  m = 1;
			else if ((strncasecmp (s, "b ", 2) == 0)
				 || (strncasecmp (s, "b,", 2) == 0))
			  a = 0;
			else if (strncasecmp (s, "e", 1) == 0)
			  a = 1;
			/* In strict mode, this is a match failure.  */
			else if (strict)
			  {
			    s--;
			    break;
			  }
			else
			  as_bad (_("Invalid Store Bytes Short Completer"));
			s++;
			i++;
		      }
		    if (i > 2)
		      as_bad (_("Invalid Store Bytes Short Completer"));
		    opcode |= m << 5;
		    INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
		  }

		/* Handle load cache hint completer.  */
		case 'c':
		  cmpltr = 0;
		  if (!strncmp (s, ",sl", 3))
		    {
		      s += 3;
		      cmpltr = 2;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);

		/* Handle store cache hint completer.  */
		case 'C':
		  cmpltr = 0;
		  if (!strncmp (s, ",sl", 3))
		    {
		      s += 3;
		      cmpltr = 2;
		    }
		  else if (!strncmp (s, ",bc", 3))
		    {
		      s += 3;
		      cmpltr = 1;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);

		/* Handle load and clear cache hint completer.  */
		case 'd':
		  cmpltr = 0;
		  if (!strncmp (s, ",co", 3))
		    {
		      s += 3;
		      cmpltr = 1;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);

		/* Handle load ordering completer.  */
		case 'o':
		  if (strncmp (s, ",o", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle a branch gate completer.  */
		case 'g':
		  if (strncasecmp (s, ",gate", 5) != 0)
		    break;
		  s += 5;
		  continue;

		/* Handle a branch link and push completer.  */
		case 'p':
		  if (strncasecmp (s, ",l,push", 7) != 0)
		    break;
		  s += 7;
		  continue;

		/* Handle a branch link completer.  */
		case 'l':
		  if (strncasecmp (s, ",l", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle a branch pop completer.  */
		case 'P':
		  if (strncasecmp (s, ",pop", 4) != 0)
		    break;
		  s += 4;
		  continue;

		/* Handle a local processor completer.  */
		case 'L':
		  if (strncasecmp (s, ",l", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle a PROBE read/write completer.  */
		case 'w':
		  flag = 0;
		  if (!strncasecmp (s, ",w", 2))
		    {
		      flag = 1;
		      s += 2;
		    }
		  else if (!strncasecmp (s, ",r", 2))
		    {
		      flag = 0;
		      s += 2;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);

		/* Handle MFCTL wide completer.  */
		case 'W':
		  if (strncasecmp (s, ",w", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle an RFI restore completer.  */
		case 'r':
		  flag = 0;
		  if (!strncasecmp (s, ",r", 2))
		    {
		      flag = 5;
		      s += 2;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);

		/* Handle a system control completer.  */
		case 'Z':
		  if (*s == ',' && (*(s + 1) == 'm' || *(s + 1) == 'M'))
		    {
		      flag = 1;
		      s += 2;
		    }
		  else
		    flag = 0;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);

		/* Handle intermediate/final completer for DCOR.  */
		case 'i':
		  flag = 0;
		  if (!strncasecmp (s, ",i", 2))
		    {
		      flag = 1;
		      s += 2;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);

		/* Handle zero/sign extension completer.  */
		case 'z':
		  flag = 1;
		  if (!strncasecmp (s, ",z", 2))
		    {
		      flag = 0;
		      s += 2;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 10);

		/* Handle add completer.  */
		case 'a':
		  flag = 1;
		  if (!strncasecmp (s, ",l", 2))
		    {
		      flag = 2;
		      s += 2;
		    }
		  else if (!strncasecmp (s, ",tsv", 4))
		    {
		      flag = 3;
		      s += 4;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 10);

		/* Handle 64 bit carry for ADD.  */
		case 'Y':
		  flag = 0;
		  if (!strncasecmp (s, ",dc,tsv", 7) ||
		      !strncasecmp (s, ",tsv,dc", 7))
		    {
		      flag = 1;
		      s += 7;
		    }
		  else if (!strncasecmp (s, ",dc", 3))
		    {
		      flag = 0;
		      s += 3;
		    }
		  else
		    break;

		  /* Condition is not required with "dc".  */
		  need_cond = 0;
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle 32 bit carry for ADD.  */
		case 'y':
		  flag = 0;
		  if (!strncasecmp (s, ",c,tsv", 6) ||
		      !strncasecmp (s, ",tsv,c", 6))
		    {
		      flag = 1;
		      s += 6;
		    }
		  else if (!strncasecmp (s, ",c", 2))
		    {
		      flag = 0;
		      s += 2;
		    }
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle trap on signed overflow.  */
		case 'v':
		  flag = 0;
		  if (!strncasecmp (s, ",tsv", 4))
		    {
		      flag = 1;
		      s += 4;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle trap on condition and overflow.  */
		case 't':
		  flag = 0;
		  if (!strncasecmp (s, ",tc,tsv", 7) ||
		      !strncasecmp (s, ",tsv,tc", 7))
		    {
		      flag = 1;
		      s += 7;
		    }
		  else if (!strncasecmp (s, ",tc", 3))
		    {
		      flag = 0;
		      s += 3;
		    }
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle 64 bit borrow for SUB.  */
		case 'B':
		  flag = 0;
		  if (!strncasecmp (s, ",db,tsv", 7) ||
		      !strncasecmp (s, ",tsv,db", 7))
		    {
		      flag = 1;
		      s += 7;
		    }
		  else if (!strncasecmp (s, ",db", 3))
		    {
		      flag = 0;
		      s += 3;
		    }
		  else
		    break;

		  /* Condition is not required with "db".  */
		  need_cond = 0;
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle 32 bit borrow for SUB.  */
		case 'b':
		  flag = 0;
		  if (!strncasecmp (s, ",b,tsv", 6) ||
		      !strncasecmp (s, ",tsv,b", 6))
		    {
		      flag = 1;
		      s += 6;
		    }
		  else if (!strncasecmp (s, ",b", 2))
		    {
		      flag = 0;
		      s += 2;
		    }
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle trap condition completer for UADDCM.  */
		case 'T':
		  flag = 0;
		  if (!strncasecmp (s, ",tc", 3))
		    {
		      flag = 1;
		      s += 3;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);

		/* Handle signed/unsigned at 21.  */
		case 'S':
		  {
		    int sign = 1;
		    if (strncasecmp (s, ",s", 2) == 0)
		      {
			sign = 1;
			s += 2;
		      }
		    else if (strncasecmp (s, ",u", 2) == 0)
		      {
			sign = 0;
			s += 2;
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, sign, 10);
		  }

		/* Handle left/right combination at 17:18.  */
		case 'h':
		  if (*s++ == ',')
		    {
		      int lr = 0;
		      if (*s == 'r')
			lr = 2;
		      else if (*s == 'l')
			lr = 0;
		      else
			as_bad (_("Invalid left/right combination completer"));

		      s++;
		      INSERT_FIELD_AND_CONTINUE (opcode, lr, 13);
		    }
		  else
		    as_bad (_("Invalid left/right combination completer"));
		  break;

		/* Handle saturation at 24:25.  */
		case 'H':
		  {
		    int sat = 3;
		    if (strncasecmp (s, ",ss", 3) == 0)
		      {
			sat = 1;
			s += 3;
		      }
		    else if (strncasecmp (s, ",us", 3) == 0)
		      {
			sat = 0;
			s += 3;
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, sat, 6);
		  }

		/* Handle permutation completer.  */
		case '*':
		  if (*s++ == ',')
		    {
		      int permloc[4];
		      int perm = 0;
		      int i = 0;
		      permloc[0] = 13;
		      permloc[1] = 10;
		      permloc[2] = 8;
		      permloc[3] = 6;
		      for (; i < 4; i++)
			{
			  switch (*s++)
			    {
			    case '0':
			      perm = 0;
			      break;
			    case '1':
			      perm = 1;
			      break;
			    case '2':
			      perm = 2;
			      break;
			    case '3':
			      perm = 3;
			      break;
			    default:
			      as_bad (_("Invalid permutation completer"));
			    }
			  opcode |= perm << permloc[i];
			}
		      continue;
		    }
		  else
		    as_bad (_("Invalid permutation completer"));
		  break;

		default:
		  abort ();
		}
	      break;

	    /* Handle all conditions.  */
	    case '?':
	      {
		args++;
		switch (*args)
		  {
		  /* Handle FP compare conditions.  */
		  case 'f':
		    cond = pa_parse_fp_cmp_cond (&s);
		    INSERT_FIELD_AND_CONTINUE (opcode, cond, 0);

		  /* Handle an add condition.  */
		  case 'A':
		  case 'a':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'A')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "nuv") == 0)
			  cmpltr = 4;
			else if (strcasecmp (name, "znv") == 0)
			  cmpltr = 5;
			else if (strcasecmp (name, "sv") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, "uv") == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			  }
			else if (strcasecmp (name, "vnz") == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			  }
			else if (strcasecmp (name, "nsv") == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args == 'a' || *name)
			  as_bad (_("Invalid Add Condition: %s"), name);
			*s = c;
		      }
		    /* Except with "dc", we have a match failure with
		       'A' if we don't have a doubleword condition.  */
		    else if (*args == 'A' && need_cond)
		      break;

		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  /* Handle non-negated add and branch condition.  */
		  case 'd':
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Add and Branch Condition"));
			cmpltr = 0;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle 64 bit wide-mode add and branch condition.  */
		  case 'W':
		    cmpltr = pa_parse_addb_64_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Add and Branch Condition"));
			cmpltr = 0;
		      }
		    else
		      {
			/* Negated condition requires an opcode change.  */
			opcode |= (cmpltr & 8) << 24;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr & 7, 13);

		  /* Handle a negated or non-negated add and branch
		     condition.  */
		  case '@@':
		    save_s = s;
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			s = save_s;
			cmpltr = pa_parse_neg_add_cmpltr (&s);
			if (cmpltr < 0)
			  {
			    as_bad (_("Invalid Compare/Subtract Condition"));
			    cmpltr = 0;
			  }
			else
			  {
			    /* Negated condition requires an opcode change.  */
			    opcode |= 1 << 27;
			  }
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle branch on bit conditions.  */
		  case 'B':
		  case 'b':
		    cmpltr = 0;
		    if (*s == ',')
		      {
			s++;

			if (*args == 'B')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			if (strncmp (s, "<", 1) == 0)
			  {
			    cmpltr = 0;
			    s++;
			  }
			else if (strncmp (s, ">=", 2) == 0)
			  {
			    cmpltr = 1;
			    s += 2;
			  }
			else
			  as_bad (_("Invalid Branch On Bit Condition: %c"), *s);
		      }
		    else
		      as_bad (_("Missing Branch On Bit Condition"));

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 15);

		  /* Handle a compare/subtract condition.  */
		  case 'S':
		  case 's':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'S')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "<<") == 0)
			  cmpltr = 4;
			else if (strcasecmp (name, "<<=") == 0)
			  cmpltr = 5;
			else if (strcasecmp (name, "sv") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, ">>=") == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			  }
			else if (strcasecmp (name, ">>") == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			  }
			else if (strcasecmp (name, "nsv") == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'S' || *name)
			  as_bad (_("Invalid Compare/Subtract Condition: %s"),
				  name);
			*s = c;
		      }
		    /* Except with "db", we have a match failure with
		       'S' if we don't have a doubleword condition.  */
		    else if (*args == 'S' && need_cond)
		      break;

		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  /* Handle a non-negated compare condition.  */
		  case 't':
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Compare/Subtract Condition"));
			cmpltr = 0;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a 32 bit compare and branch condition.  */
		  case 'n':
		    save_s = s;
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			s = save_s;
			cmpltr = pa_parse_neg_cmpsub_cmpltr (&s);
			if (cmpltr < 0)
			  {
			    as_bad (_("Invalid Compare and Branch Condition"));
			    cmpltr = 0;
			  }
			else
			  {
			    /* Negated condition requires an opcode change.  */
			    opcode |= 1 << 27;
			  }
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a 64 bit compare and branch condition.  */
		  case 'N':
		    cmpltr = pa_parse_cmpb_64_cmpltr (&s);
		    if (cmpltr >= 0)
		      {
			/* Negated condition requires an opcode change.  */
			opcode |= (cmpltr & 8) << 26;
		      }
		    else
		      /* Not a 64 bit cond.  Give 32 bit a chance.  */
		      break;

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr & 7, 13);

		  /* Handle a 64 bit cmpib condition.  */
		  case 'Q':
		    cmpltr = pa_parse_cmpib_64_cmpltr (&s);
		    if (cmpltr < 0)
		      /* Not a 64 bit cond.  Give 32 bit a chance.  */
		      break;

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a logical instruction condition.  */
		  case 'L':
		  case 'l':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'L')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;

			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'L' || *name)
			  as_bad (_("Invalid Logical Instruction Condition."));
			*s = c;
		      }
		    /* 32-bit is default for no condition.  */
		    else if (*args == 'L')
		      break;

		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  /* Handle a shift/extract/deposit condition.  */
		  case 'X':
		  case 'x':
		  case 'y':
		    cmpltr = 0;
		    /* Check immediate values in shift/extract/deposit
		     * instructions if they will give undefined behaviour.  */
		    immediate_check = 1;
		    if (*s == ',')
		      {
			save_s = s++;

			/* 64 bit conditions.  */
			if (*args == 'X')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "tr") == 0)
			  cmpltr = 4;
			else if (strcmp (name, "<>") == 0)
			  cmpltr = 5;
			else if (strcmp (name, ">=") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "ev") == 0)
			  cmpltr = 7;
			/* Handle movb,n.  Put things back the way they were.
			   This includes moving s back to where it started.  */
			else if (strcasecmp (name, "n") == 0 && *args == 'y')
			  {
			    *s = c;
			    s = save_s;
			    continue;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'X' || *name)
			  as_bad (_("Invalid Shift/Extract/Deposit Condition."));
			*s = c;
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a unit instruction condition.  */
		  case 'U':
		  case 'u':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			int uxor;
			s++;

			/* 64 bit conditions.  */
			if (*args == 'U')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			/* The uxor instruction only supports unit conditions
			   not involving carries.  */
			uxor = (opcode & 0xfc000fc0) == 0x08000380;
			if (strncasecmp (s, "sbz", 3) == 0)
			  {
			    cmpltr = 2;
			    s += 3;
			  }
			else if (strncasecmp (s, "shz", 3) == 0)
			  {
			    cmpltr = 3;
			    s += 3;
			  }
			else if (!uxor && strncasecmp (s, "sdc", 3) == 0)
			  {
			    cmpltr = 4;
			    s += 3;
			  }
			else if (!uxor && strncasecmp (s, "sbc", 3) == 0)
			  {
			    cmpltr = 6;
			    s += 3;
			  }
			else if (!uxor && strncasecmp (s, "shc", 3) == 0)
			  {
			    cmpltr = 7;
			    s += 3;
			  }
			else if (strncasecmp (s, "tr", 2) == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			    s += 2;
			  }
			else if (strncasecmp (s, "nbz", 3) == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nhz", 3) == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			    s += 3;
			  }
			else if (!uxor && strncasecmp (s, "ndc", 3) == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			    s += 3;
			  }
			else if (!uxor && strncasecmp (s, "nbc", 3) == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			    s += 3;
			  }
			else if (!uxor && strncasecmp (s, "nhc", 3) == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "swz", 3) == 0)
			  {
			    cmpltr = 1;
			    flag = 0;
			    s += 3;
			  }
			else if (!uxor && strncasecmp (s, "swc", 3) == 0)
			  {
			    cmpltr = 5;
			    flag = 0;
			    s += 3;
			  }
			else if (strncasecmp (s, "nwz", 3) == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			    s += 3;
			  }
			else if (!uxor && strncasecmp (s, "nwc", 3) == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			    s += 3;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'U' || (*s != ' ' && *s != '\t'))
			  as_bad (_("Invalid Unit Instruction Condition."));
		      }
		    /* 32-bit is default for no condition.  */
		    else if (*args == 'U')
		      break;

		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  default:
		    abort ();
		  }
		break;
	      }

	    /* Handle a nullification completer for branch instructions.  */
	    case 'n':
	      nullif = pa_parse_nullif (&s);
	      INSERT_FIELD_AND_CONTINUE (opcode, nullif, 1);

	    /* Handle a nullification completer for copr and spop insns.  */
	    case 'N':
	      nullif = pa_parse_nullif (&s);
	      INSERT_FIELD_AND_CONTINUE (opcode, nullif, 5);

	    /* Handle ,%r2 completer for new syntax branches.  */
	    case 'L':
	      if (*s == ',' && strncasecmp (s + 1, "%r2", 3) == 0)
		s += 4;
	      else if (*s == ',' && strncasecmp (s + 1, "%rp", 3) == 0)
		s += 4;
	      else
		break;
	      continue;

	    /* Handle 3 bit entry into the fp compare array.   Valid values
	       are 0..6 inclusive.  */
	    case 'h':
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 6, 0, 0);
		  num++;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
		}
	      else
		break;

	    /* Handle 3 bit entry into the fp compare array.   Valid values
	       are 0..6 inclusive.  */
	    case 'm':
	      get_expression (s);
	      if (the_insn.exp.X_op == O_constant)
		{
		  s = expr_end;
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 6, 0, 0);
		  num = (num + 1) ^ 1;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
		}
	      else
		break;

	    /* Handle graphics test completers for ftest */
	    case '=':
	      {
		num = pa_parse_ftest_gfx_completer (&s);
		INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
	      }

	    /* Handle a 11 bit immediate at 31.  */
	    case 'i':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 1023, -1024, 0);
		  num = low_sign_unext (num, 11);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
#ifdef OBJ_ELF
		  else if (is_tls_gdidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_GD21L;
		  else if (is_tls_ldidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDM21L;
		  else if (is_tls_dtpoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDO21L;
		  else if (is_tls_ieoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_IE21L;
		  else if (is_tls_leoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LE21L;
#endif
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 11;
		  continue;
		}

	    /* Handle a 14 bit immediate at 31.  */
	    case 'J':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;

		  /* XXX the completer stored away tidbits of information
		     for us to extract.  We need a cleaner way to do this.
		     Now that we have lots of letters again, it would be
		     good to rethink this.  */
		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb != (num < 0))
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;

	    /* Handle a 14 bit immediate at 31.  */
	    case 'K':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;

		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb == (num < 0))
		    break;
		  if (num % 4)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;

	    /* Handle a 16 bit immediate at 31.  */
	    case '<':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;

		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb != (num < 0))
		    break;
		  CHECK_FIELD (num, 32767, -32768, 0);
		  num = re_assemble_16 (num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;

	    /* Handle a 16 bit immediate at 31.  */
	    case '>':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;

		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb == (num < 0))
		    break;
		  if (num % 4)
		    break;
		  CHECK_FIELD (num, 32767, -32768, 0);
		  num = re_assemble_16 (num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;

	    /* Handle 14 bit immediate, shifted left three times.  */
	    case '#':
	      if (bfd_get_mach (stdoutput) != pa20)
		break;
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  if (num & 0x7)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  if (num < 0)
		    opcode |= 1;
		  num &= 0x1fff;
		  num >>= 3;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 4);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
#ifdef OBJ_ELF
		  else if (is_tls_gdidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_GD21L;
		  else if (is_tls_ldidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDM21L;
		  else if (is_tls_dtpoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDO21L;
		  else if (is_tls_ieoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_IE21L;
		  else if (is_tls_leoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LE21L;
#endif
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}
	      break;

	    /* Handle 14 bit immediate, shifted left twice.  */
	    case 'd':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  if (num & 0x3)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  if (num < 0)
		    opcode |= 1;
		  num &= 0x1fff;
		  num >>= 2;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 3);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
#ifdef OBJ_ELF
		  else if (is_tls_gdidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_GD21L;
		  else if (is_tls_ldidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDM21L;
		  else if (is_tls_dtpoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDO21L;
		  else if (is_tls_ieoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_IE21L;
		  else if (is_tls_leoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LE21L;
#endif
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a 14 bit immediate at 31.  */
	    case 'j':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 8191, -8192, 0);
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
#ifdef OBJ_ELF
		  else if (is_tls_gdidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_GD21L;
		  else if (is_tls_ldidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDM21L;
		  else if (is_tls_dtpoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDO21L;
		  else if (is_tls_ieoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_IE21L;
		  else if (is_tls_leoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LE21L;
#endif
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a 21 bit immediate at 31.  */
	    case 'k':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num >> 11, 1048575, -1048576, 0);
		  opcode |= re_assemble_21 (num);
		  continue;
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
#ifdef OBJ_ELF
		  else if (is_tls_gdidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_GD21L;
		  else if (is_tls_ldidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDM21L;
		  else if (is_tls_dtpoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDO21L;
		  else if (is_tls_ieoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_IE21L;
		  else if (is_tls_leoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LE21L;
#endif
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 21;
		  continue;
		}

	    /* Handle a 16 bit immediate at 31 (PA 2.0 wide mode only).  */
	    case 'l':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
#ifdef OBJ_ELF
		  else if (is_tls_gdidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_GD21L;
		  else if (is_tls_ldidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDM21L;
		  else if (is_tls_dtpoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDO21L;
		  else if (is_tls_ieoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_IE21L;
		  else if (is_tls_leoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LE21L;
#endif
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a word-aligned 16-bit imm. at 31 (PA2.0 wide).  */
	    case 'y':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  CHECK_ALIGN (num, 4, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
#ifdef OBJ_ELF
		  else if (is_tls_gdidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_GD21L;
		  else if (is_tls_ldidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDM21L;
		  else if (is_tls_dtpoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDO21L;
		  else if (is_tls_ieoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_IE21L;
		  else if (is_tls_leoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LE21L;
#endif
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a dword-aligned 16-bit imm. at 31 (PA2.0 wide).  */
	    case '&':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  CHECK_ALIGN (num, 8, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
#ifdef OBJ_ELF
		  else if (is_tls_gdidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_GD21L;
		  else if (is_tls_ldidx (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDM21L;
		  else if (is_tls_dtpoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LDO21L;
		  else if (is_tls_ieoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_IE21L;
		  else if (is_tls_leoff (the_insn.exp))
		    the_insn.reloc = R_PARISC_TLS_LE21L;
#endif
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a 12 bit branch displacement.  */
	    case 'w':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  opcode |= re_assemble_12 (num >> 2);
		  continue;
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 12;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  s = expr_end;
		  continue;
		}

	    /* Handle a 17 bit branch displacement.  */
	    case 'W':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 262143, -262144, 0);
		  opcode |= re_assemble_17 (num >> 2);
		  continue;
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 17;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}

	    /* Handle a 22 bit branch displacement.  */
	    case 'X':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 8388607, -8388608, 0);
		  opcode |= re_assemble_22 (num >> 2);
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 22;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}

	    /* Handle an absolute 17 bit branch target.  */
	    case 'z':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 0;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 262143, -262144, 0);
		  opcode |= re_assemble_17 (num >> 2);
		  continue;
		}
	      else
		{
		  the_insn.reloc = R_HPPA_ABS_CALL;
		  the_insn.format = 17;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}

	    /* Handle '%r1' implicit operand of addil instruction.  */
	    case 'Z':
	      if (*s == ',' && *(s + 1) == '%' && *(s + 3) == '1'
		  && (*(s + 2) == 'r' || *(s + 2) == 'R'))
		{
		  s += 4;
		  continue;
		}
	      else
		break;

	    /* Handle '%sr0,%r31' implicit operand of be,l instruction.  */
	    case 'Y':
	      if (strncasecmp (s, "%sr0,%r31", 9) != 0)
		break;
	      s += 9;
	      continue;

	    /* Handle immediate value of 0 for ordered load/store instructions.  */
	    case '@@':
	      if (*s != '0')
		break;
	      s++;
	      continue;

	    /* Handle a 2 bit shift count at 25.  */
	    case '.':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 3, 1, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);

	    /* Handle a 4 bit shift count at 25.  */
	    case '*':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 15, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);

	    /* Handle a 5 bit shift count at 26.  */
	    case 'p':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      SAVE_IMMEDIATE(num);
	      INSERT_FIELD_AND_CONTINUE (opcode, 31 - num, 5);

	    /* Handle a 6 bit shift count at 20,22:26.  */
	    case '~':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      SAVE_IMMEDIATE(num);
	      num = 63 - num;
	      opcode |= (num & 0x20) << 6;
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 5);

	    /* Handle a 6 bit field length at 23,27:31.  */
	    case '%':
	      flag = 0;
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 64, 1, strict);
	      SAVE_IMMEDIATE(num);
	      num--;
	      opcode |= (num & 0x20) << 3;
	      num = 31 - (num & 0x1f);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 6 bit field length at 19,27:31.  */
	    case '|':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 64, 1, strict);
	      SAVE_IMMEDIATE(num);
	      num--;
	      opcode |= (num & 0x20) << 7;
	      num = 31 - (num & 0x1f);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 5 bit bit position at 26.  */
	    case 'P':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      SAVE_IMMEDIATE(num);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 5);

	    /* Handle a 6 bit bit position at 20,22:26.  */
	    case 'q':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      SAVE_IMMEDIATE(num);
	      opcode |= (num & 0x20) << 6;
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 5);

	    /* Handle a 5 bit immediate at 10 with 'd' as the complement
	       of the high bit of the immediate.  */
	    case 'B':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      if (num & 0x20)
		;
	      else
		opcode |= (1 << 13);
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 21);

	    /* Handle a 5 bit immediate at 10.  */
	    case 'Q':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);

	    /* Handle a 9 bit immediate at 28.  */
	    case '$':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 511, 1, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 3);

	    /* Handle a 13 bit immediate at 18.  */
	    case 'A':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 8191, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 13);

	    /* Handle a 26 bit immediate at 31.  */
	    case 'D':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 67108863, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 3 bit SFU identifier at 25.  */
	    case 'v':
	      if (*s++ != ',')
		as_bad (_("Invalid SFU identifier"));
	      num = pa_get_number (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 7, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);

	    /* Handle a 20 bit SOP field for spop0.  */
	    case 'O':
	      num = pa_get_number (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1048575, 0, strict);
	      num = (num & 0x1f) | ((num & 0x000fffe0) << 6);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 15bit SOP field for spop1.  */
	    case 'o':
	      num = pa_get_number (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 32767, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 11);

	    /* Handle a 10bit SOP field for spop3.  */
	    case '0':
	      num = pa_get_number (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1023, 0, strict);
	      num = (num & 0x1f) | ((num & 0x000003e0) << 6);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 15 bit SOP field for spop2.  */
	    case '1':
	      num = pa_get_number (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 32767, 0, strict);
	      num = (num & 0x1f) | ((num & 0x00007fe0) << 6);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 3-bit co-processor ID field.  */
	    case 'u':
	      if (*s++ != ',')
		as_bad (_("Invalid COPR identifier"));
	      num = pa_get_number (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 7, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);

	    /* Handle a 22bit SOP field for copr.  */
	    case '2':
	      num = pa_get_number (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 4194303, 0, strict);
	      num = (num & 0x1f) | ((num & 0x003fffe0) << 4);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a source FP operand format completer.  */
	    case '{':
	      if (*s == ',' && *(s+1) == 't')
		{
		  the_insn.trunc = 1;
		  s += 2;
		}
	      else
		the_insn.trunc = 0;
	      flag = pa_parse_fp_cnv_format (&s);
	      the_insn.fpof1 = flag;
	      if (flag == W || flag == UW)
		flag = SGL;
	      if (flag == DW || flag == UDW)
		flag = DBL;
	      if (flag == QW || flag == UQW)
		flag = QUAD;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

	    /* Handle a destination FP operand format completer.  */
	    case '_':
	      /* pa_parse_format needs the ',' prefix.  */
	      s--;
	      flag = pa_parse_fp_cnv_format (&s);
	      the_insn.fpof2 = flag;
	      if (flag == W || flag == UW)
		flag = SGL;
	      if (flag == DW || flag == UDW)
		flag = DBL;
	      if (flag == QW || flag == UQW)
		flag = QUAD;
	      opcode |= flag << 13;
	      if (the_insn.fpof1 == SGL
		  || the_insn.fpof1 == DBL
		  || the_insn.fpof1 == QUAD)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 0;
		  else if (the_insn.fpof2 == W
		      || the_insn.fpof2 == DW
		      || the_insn.fpof2 == QW)
		    flag = 2;
		  else if (the_insn.fpof2 == UW
		      || the_insn.fpof2 == UDW
		      || the_insn.fpof2 == UQW)
		    flag = 6;
		  else
		    abort ();
		}
	      else if (the_insn.fpof1 == W
		       || the_insn.fpof1 == DW
		       || the_insn.fpof1 == QW)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 1;
		  else
		    abort ();
		}
	      else if (the_insn.fpof1 == UW
		       || the_insn.fpof1 == UDW
		       || the_insn.fpof1 == UQW)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 5;
		  else
		    abort ();
		}
	      flag |= the_insn.trunc;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 15);

	    /* Handle a source FP operand format completer.  */
	    case 'F':
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof1 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

	    /* Handle a destination FP operand format completer.  */
	    case 'G':
	      /* pa_parse_format needs the ',' prefix.  */
	      s--;
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof2 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 13);

	    /* Handle a source FP operand format completer at 20.  */
	    case 'I':
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof1 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

	    /* Handle a floating point operand format at 26.
	       Only allows single and double precision.  */
	    case 'H':
	      flag = pa_parse_fp_format (&s);
	      switch (flag)
		{
		case SGL:
		  opcode |= 0x20;
		case DBL:
		  the_insn.fpof1 = flag;
		  continue;

		case QUAD:
		case ILLEGAL_FMT:
		default:
		  as_bad (_("Invalid Floating Point Operand Format."));
		}
	      break;

	    /* Handle all floating point registers.  */
	    case 'f':
	      switch (*++args)
		{
		/* Float target register.  */
		case 't':
		  if (!pa_parse_number (&s, 3))
		    break;
		  /* RSEL should not be set.  */
		  if (pa_number & FP_REG_RSEL)
		    break;
		  num = pa_number - FP_REG_BASE;
		  CHECK_FIELD (num, 31, 0, 0);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

		/* Float target register with L/R selection.  */
		case 'T':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num;

		    /* 0x30 opcodes are FP arithmetic operation opcodes
		       and need to be turned into 0x38 opcodes.  This
		       is not necessary for loads/stores.  */
		    if (need_pa11_opcode ()
			&& ((opcode & 0xfc000000) == 0x30000000))
		      opcode |= 1 << 27;

		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 6 : 0);
		    continue;
		  }

		/* Float operand 1.  */
		case 'a':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 21;
		    if (need_pa11_opcode ())
		      {
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 7 : 0);
			opcode |= 1 << 27;
		      }
		    continue;
		  }

		/* Float operand 1 with L/R selection.  */
		case 'X':
		case 'A':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 21;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 7 : 0);
		    continue;
		  }

		/* Float operand 2.  */
		case 'b':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    if (need_pa11_opcode ())
		      {
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 12 : 0);
			opcode |= 1 << 27;
		      }
		    continue;
		  }

		/* Float operand 2 with L/R selection.  */
		case 'B':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 12 : 0);
		    continue;
		  }

		/* Float operand 3 for fmpyfadd, fmpynfadd.  */
		case 'C':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= (num & 0x1c) << 11;
		    opcode |= (num & 0x03) << 9;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 8 : 0);
		    continue;
		  }

		/* Float mult operand 1 for fmpyadd, fmpysub */
		case 'i':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
			if (num < 16)
			  {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
			  }
			num &= 0xF;
			num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 21);
		  }

		/* Float mult operand 2 for fmpyadd, fmpysub */
		case 'j':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
			if (num < 16)
			  {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
			  }
			num &= 0xF;
			num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 16);
		  }

		/* Float mult target for fmpyadd, fmpysub */
		case 'k':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
			if (num < 16)
			  {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
			  }
			num &= 0xF;
			num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		  }

		/* Float add operand 1 for fmpyadd, fmpysub */
		case 'l':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
			if (num < 16)
			  {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
			  }
			num &= 0xF;
			num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 6);
		  }

		/* Float add target for fmpyadd, fmpysub */
		case 'm':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
			if (num < 16)
			  {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
			  }
			num &= 0xF;
			num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 11);
		  }

		/* Handle L/R register halves like 'x'.  */
		case 'E':
		case 'e':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    if (need_pa11_opcode ())
		      {
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 1 : 0);
		      }
		    continue;
		  }

		/* Float target register (PA 2.0 wide).  */
		case 'x':
		  if (!pa_parse_number (&s, 3))
		    break;
		  num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		  CHECK_FIELD (num, 31, 0, 0);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

		default:
		  abort ();
		}
	      break;

	    default:
	      abort ();
	    }
	  break;
	}

      /* If this instruction is specific to a particular architecture,
	 then set a new architecture.  This automatic promotion crud is
	 for compatibility with HP's old assemblers only.  */
      if (match == TRUE
	  && bfd_get_mach (stdoutput) < insn->arch
	  && !bfd_set_arch_mach (stdoutput, bfd_arch_hppa, insn->arch))
	{
	  as_warn (_("could not update architecture and machine"));
	  match = FALSE;
	}

 failed:
      /* Check if the args matched.  */
      if (!match)
	{
	  if (&insn[1] - pa_opcodes < (int) NUMOPCODES
	      && !strcmp (insn->name, insn[1].name))
	    {
	      ++insn;
	      s = argstart;
	      continue;
	    }
	  else
	    {
	      as_bad (_("Invalid operands %s"), error_message);
	      return;
	    }
	}
      break;
    }

  if (immediate_check)
    {
      if (pos != -1 && len != -1 && pos < len - 1)
        as_warn (_("Immediates %d and %d will give undefined behavior."),
			pos, len);
    }

  the_insn.opcode = opcode;
}

/* Assemble a single instruction storing it into a frag.  */

void
md_assemble (char *str)
{
  char *to;

  /* The had better be something to assemble.  */
  gas_assert (str);

  /* If we are within a procedure definition, make sure we've
     defined a label for the procedure; handle case where the
     label was defined after the .PROC directive.

     Note there's not need to diddle with the segment or fragment
     for the label symbol in this case.  We have already switched
     into the new $CODE$ subspace at this point.  */
  if (within_procedure && last_call_info->start_symbol == NULL)
    {
      label_symbol_struct *label_symbol = pa_get_label ();

      if (label_symbol)
	{
	  if (label_symbol->lss_label)
	    {
	      last_call_info->start_symbol = label_symbol->lss_label;
	      symbol_get_bfdsym (label_symbol->lss_label)->flags
		|= BSF_FUNCTION;
#ifdef OBJ_SOM
	      /* Also handle allocation of a fixup to hold the unwind
		 information when the label appears after the proc/procend.  */
	      if (within_entry_exit)
		{
		  char *where;
		  unsigned int u;

		  where = frag_more (0);
		  u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
		  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
				NULL, (offsetT) 0, NULL,
				0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
		}
#endif
	    }
	  else
	    as_bad (_("Missing function name for .PROC (corrupted label chain)"));
	}
      else
	as_bad (_("Missing function name for .PROC"));
    }

  /* Assemble the instruction.  Results are saved into "the_insn".  */
  pa_ip (str);

  /* Get somewhere to put the assembled instruction.  */
  to = frag_more (4);

  /* Output the opcode.  */
  md_number_to_chars (to, the_insn.opcode, 4);

  /* If necessary output more stuff.  */
  if (the_insn.reloc != R_HPPA_NONE)
    fix_new_hppa (frag_now, (to - frag_now->fr_literal), 4, NULL,
		  (offsetT) 0, &the_insn.exp, the_insn.pcrel,
		  the_insn.reloc, the_insn.field_selector,
		  the_insn.format, the_insn.arg_reloc, 0);

#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif
}

#ifdef OBJ_SOM
/* Handle an alignment directive.  Special so that we can update the
   alignment of the subspace if necessary.  */
static void
pa_align (int bytes)
{
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();

  /* Let the generic gas code do most of the work.  */
  s_align_bytes (bytes);

  /* If bytes is a power of 2, then update the current subspace's
     alignment if necessary.  */
  if (exact_log2 (bytes) != -1)
    record_alignment (current_subspace->ssd_seg, exact_log2 (bytes));
}
#endif

/* Handle a .BLOCK type pseudo-op.  */

static void
pa_block (int z ATTRIBUTE_UNUSED)
{
  unsigned int temp_size;

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  temp_size = get_absolute_expression ();

  if (temp_size > 0x3FFFFFFF)
    {
      as_bad (_("Argument to .BLOCK/.BLOCKZ must be between 0 and 0x3fffffff"));
      temp_size = 0;
    }
  else
    {
      /* Always fill with zeros, that's what the HP assembler does.  */
      char *p = frag_var (rs_fill, 1, 1, 0, NULL, temp_size, NULL);
      *p = 0;
    }

  pa_undefine_label ();
  demand_empty_rest_of_line ();
}

/* Handle a .begin_brtab and .end_brtab pseudo-op.  */

static void
pa_brtab (int begin ATTRIBUTE_UNUSED)
{

#ifdef OBJ_SOM
  /* The BRTAB relocations are only available in SOM (to denote
     the beginning and end of branch tables).  */
  char *where = frag_more (0);

  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
		NULL, (offsetT) 0, NULL,
		0, begin ? R_HPPA_BEGIN_BRTAB : R_HPPA_END_BRTAB,
		e_fsel, 0, 0, 0);
#endif

  demand_empty_rest_of_line ();
}

/* Handle a .begin_try and .end_try pseudo-op.  */

static void
pa_try (int begin ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  expressionS exp;
  char *where = frag_more (0);

  if (! begin)
    expression (&exp);

  /* The TRY relocations are only available in SOM (to denote
     the beginning and end of exception handling regions).  */

  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
		NULL, (offsetT) 0, begin ? NULL : &exp,
		0, begin ? R_HPPA_BEGIN_TRY : R_HPPA_END_TRY,
		e_fsel, 0, 0, 0);
#endif

  demand_empty_rest_of_line ();
}

/* Do the dirty work of building a call descriptor which describes
   where the caller placed arguments to a function call.  */

static void
pa_call_args (struct call_desc *call_desc)
{
  char *name, c, *p;
  unsigned int temp, arg_reloc;

  while (!is_end_of_statement ())
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      /* Process a source argument.  */
      if ((strncasecmp (name, "argw", 4) == 0))
	{
	  temp = atoi (name + 4);
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  name = input_line_pointer;
	  c = get_symbol_end ();
	  arg_reloc = pa_build_arg_reloc (name);
	  call_desc->arg_reloc |= pa_align_arg_reloc (temp, arg_reloc);
	}
      /* Process a return value.  */
      else if ((strncasecmp (name, "rtnval", 6) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  name = input_line_pointer;
	  c = get_symbol_end ();
	  arg_reloc = pa_build_arg_reloc (name);
	  call_desc->arg_reloc |= (arg_reloc & 0x3);
	}
      else
	{
	  as_bad (_("Invalid .CALL argument: %s"), name);
	}
      p = input_line_pointer;
      *p = c;
      if (!is_end_of_statement ())
	input_line_pointer++;
    }
}

/* Handle a .CALL pseudo-op.  This involves storing away information
   about where arguments are to be found so the linker can detect
   (and correct) argument location mismatches between caller and callee.  */

static void
pa_call (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  pa_call_args (&last_call_desc);
  demand_empty_rest_of_line ();
}

#ifdef OBJ_ELF
/* Build an entry in the UNWIND subspace from the given function
   attributes in CALL_INFO.  This is not needed for SOM as using
   R_ENTRY and R_EXIT relocations allow the linker to handle building
   of the unwind spaces.  */

static void
pa_build_unwind_subspace (struct call_info *call_info)
{
  asection *seg, *save_seg;
  subsegT save_subseg;
  unsigned int unwind;
  int reloc;
  char *name, *p;
  symbolS *symbolP;

  if ((bfd_get_section_flags (stdoutput, now_seg)
       & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
      != (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
    return;

  if (call_info->start_symbol == NULL)
    /* This can happen if there were errors earlier on in the assembly.  */
    return;

  /* Replace the start symbol with a local symbol that will be reduced
     to a section offset.  This avoids problems with weak functions with
     multiple definitions, etc.  */
  name = xmalloc (strlen ("L$\001start_")
		  + strlen (S_GET_NAME (call_info->start_symbol))
		  + 1);
  strcpy (name, "L$\001start_");
  strcat (name, S_GET_NAME (call_info->start_symbol));

  /* If we have a .procend preceded by a .exit, then the symbol will have
     already been defined.  In that case, we don't want another unwind
     entry.  */
  symbolP = symbol_find (name);
  if (symbolP)
    {
      xfree (name);
      return;
    }
  else
    {
      symbolP = symbol_new (name, now_seg,
			    S_GET_VALUE (call_info->start_symbol), frag_now);
      gas_assert (symbolP);
      S_CLEAR_EXTERNAL (symbolP);
      symbol_table_insert (symbolP);
    }

  reloc = R_PARISC_SEGREL32;
  save_seg = now_seg;
  save_subseg = now_subseg;
  /* Get into the right seg/subseg.  This may involve creating
     the seg the first time through.  Make sure to have the
     old seg/subseg so that we can reset things when we are done.  */
  seg = bfd_get_section_by_name (stdoutput, UNWIND_SECTION_NAME);
  if (seg == ASEC_NULL)
    {
      seg = subseg_new (UNWIND_SECTION_NAME, 0);
      bfd_set_section_flags (stdoutput, seg,
			     SEC_READONLY | SEC_HAS_CONTENTS
			     | SEC_LOAD | SEC_RELOC | SEC_ALLOC | SEC_DATA);
      bfd_set_section_alignment (stdoutput, seg, 2);
    }

  subseg_set (seg, 0);

  /* Get some space to hold relocation information for the unwind
     descriptor.  */
  p = frag_more (16);

  /* Relocation info. for start offset of the function.  */
  md_number_to_chars (p, 0, 4);
  fix_new_hppa (frag_now, p - frag_now->fr_literal, 4,
		symbolP, (offsetT) 0,
		(expressionS *) NULL, 0, reloc,
		e_fsel, 32, 0, 0);

  /* Relocation info. for end offset of the function.

     Because we allow reductions of 32bit relocations for ELF, this will be
     reduced to section_sym + offset which avoids putting the temporary
     symbol into the symbol table.  It (should) end up giving the same
     value as call_info->start_symbol + function size once the linker is
     finished with its work.  */
  md_number_to_chars (p + 4, 0, 4);
  fix_new_hppa (frag_now, p + 4 - frag_now->fr_literal, 4,
		call_info->end_symbol, (offsetT) 0,
		(expressionS *) NULL, 0, reloc,
		e_fsel, 32, 0, 0);

  /* Dump the descriptor.  */
  unwind = UNWIND_LOW32 (&call_info->ci_unwind.descriptor);
  md_number_to_chars (p + 8, unwind, 4);

  unwind = UNWIND_HIGH32 (&call_info->ci_unwind.descriptor);
  md_number_to_chars (p + 12, unwind, 4);

  /* Return back to the original segment/subsegment.  */
  subseg_set (save_seg, save_subseg);
}
#endif

/* Process a .CALLINFO pseudo-op.  This information is used later
   to build unwind descriptors and maybe one day to support
   .ENTER and .LEAVE.  */

static void
pa_callinfo (int unused ATTRIBUTE_UNUSED)
{
  char *name, c, *p;
  int temp;

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  /* .CALLINFO must appear within a procedure definition.  */
  if (!within_procedure)
    as_bad (_(".callinfo is not within a procedure definition"));

  /* Mark the fact that we found the .CALLINFO for the
     current procedure.  */
  callinfo_found = TRUE;

  /* Iterate over the .CALLINFO arguments.  */
  while (!is_end_of_statement ())
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      /* Frame size specification.  */
      if ((strncasecmp (name, "frame", 5) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = get_absolute_expression ();
	  if ((temp & 0x3) != 0)
	    {
	      as_bad (_("FRAME parameter must be a multiple of 8: %d\n"), temp);
	      temp = 0;
	    }

	  /* callinfo is in bytes and unwind_desc is in 8 byte units.  */
	  last_call_info->ci_unwind.descriptor.frame_size = temp / 8;

	}
      /* Entry register (GR, GR and SR) specifications.  */
      else if ((strncasecmp (name, "entry_gr", 8) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = get_absolute_expression ();
	  /* The HP assembler accepts 19 as the high bound for ENTRY_GR
	     even though %r19 is caller saved.  I think this is a bug in
	     the HP assembler, and we are not going to emulate it.  */
	  if (temp < 3 || temp > 18)
	    as_bad (_("Value for ENTRY_GR must be in the range 3..18\n"));
	  last_call_info->ci_unwind.descriptor.entry_gr = temp - 2;
	}
      else if ((strncasecmp (name, "entry_fr", 8) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = get_absolute_expression ();
	  /* Similarly the HP assembler takes 31 as the high bound even
	     though %fr21 is the last callee saved floating point register.  */
	  if (temp < 12 || temp > 21)
	    as_bad (_("Value for ENTRY_FR must be in the range 12..21\n"));
	  last_call_info->ci_unwind.descriptor.entry_fr = temp - 11;
	}
      else if ((strncasecmp (name, "entry_sr", 8) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = get_absolute_expression ();
	  if (temp != 3)
	    as_bad (_("Value for ENTRY_SR must be 3\n"));
	}
      /* Note whether or not this function performs any calls.  */
      else if ((strncasecmp (name, "calls", 5) == 0) ||
	       (strncasecmp (name, "caller", 6) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	}
      else if ((strncasecmp (name, "no_calls", 8) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	}
      /* Should RP be saved into the stack.  */
      else if ((strncasecmp (name, "save_rp", 7) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.save_rp = 1;
	}
      /* Likewise for SP.  */
      else if ((strncasecmp (name, "save_sp", 7) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.save_sp = 1;
	}
      /* Is this an unwindable procedure.  If so mark it so
	 in the unwind descriptor.  */
      else if ((strncasecmp (name, "no_unwind", 9) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.cannot_unwind = 1;
	}
      /* Is this an interrupt routine.  If so mark it in the
	 unwind descriptor.  */
      else if ((strncasecmp (name, "hpux_int", 7) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.hpux_interrupt_marker = 1;
	}
      /* Is this a millicode routine.  "millicode" isn't in my
	 assembler manual, but my copy is old.  The HP assembler
	 accepts it, and there's a place in the unwind descriptor
	 to drop the information, so we'll accept it too.  */
      else if ((strncasecmp (name, "millicode", 9) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.millicode = 1;
	}
      else
	{
	  as_bad (_("Invalid .CALLINFO argument: %s"), name);
	  *input_line_pointer = c;
	}
      if (!is_end_of_statement ())
	input_line_pointer++;
    }

  demand_empty_rest_of_line ();
}

#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
/* Switch to the text space.  Like s_text, but delete our
   label when finished.  */

static void
pa_text (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  current_space = is_defined_space ("$TEXT$");
  current_subspace
    = pa_subsegment_to_subspace (current_space->sd_seg, 0);
#endif

  s_text (0);
  pa_undefine_label ();
}

/* Switch to the data space.  As usual delete our label.  */

static void
pa_data (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  current_space = is_defined_space ("$PRIVATE$");
  current_subspace
    = pa_subsegment_to_subspace (current_space->sd_seg, 0);
#endif
  s_data (0);
  pa_undefine_label ();
}

/* This is different than the standard GAS s_comm(). On HP9000/800 machines,
   the .comm pseudo-op has the following syntax:

   <label> .comm <length>

   where <label> is optional and is a symbol whose address will be the start of
   a block of memory <length> bytes long. <length> must be an absolute
   expression.  <length> bytes will be allocated in the current space
   and subspace.

   Also note the label may not even be on the same line as the .comm.

   This difference in syntax means the colon function will be called
   on the symbol before we arrive in pa_comm.  colon will set a number
   of attributes of the symbol that need to be fixed here.  In particular
   the value, section pointer, fragment pointer, flags, etc.  What
   a pain.

   This also makes error detection all but impossible.  */

static void
pa_comm (int unused ATTRIBUTE_UNUSED)
{
  unsigned int size;
  symbolS *symbol;
  label_symbol_struct *label_symbol = pa_get_label ();

  if (label_symbol)
    symbol = label_symbol->lss_label;
  else
    symbol = NULL;

  SKIP_WHITESPACE ();
  size = get_absolute_expression ();

  if (symbol)
    {
      symbol_get_bfdsym (symbol)->flags |= BSF_OBJECT;
      S_SET_VALUE (symbol, size);
      S_SET_SEGMENT (symbol, bfd_com_section_ptr);
      S_SET_EXTERNAL (symbol);

      /* colon() has already set the frag to the current location in the
	 current subspace; we need to reset the fragment to the zero address
	 fragment.  We also need to reset the segment pointer.  */
      symbol_set_frag (symbol, &zero_address_frag);
    }
  demand_empty_rest_of_line ();
}
#endif /* !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD))) */

/* Process a .END pseudo-op.  */

static void
pa_end (int unused ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
}

/* Process a .ENTER pseudo-op.  This is not supported.  */

static void
pa_enter (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  as_bad (_("The .ENTER pseudo-op is not supported"));
  demand_empty_rest_of_line ();
}

/* Process a .ENTRY pseudo-op.  .ENTRY marks the beginning of the
   procedure.  */

static void
pa_entry (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  if (!within_procedure)
    as_bad (_("Misplaced .entry. Ignored."));
  else
    {
      if (!callinfo_found)
	as_bad (_("Missing .callinfo."));
    }
  demand_empty_rest_of_line ();
  within_entry_exit = TRUE;

#ifdef OBJ_SOM
  /* SOM defers building of unwind descriptors until the link phase.
     The assembler is responsible for creating an R_ENTRY relocation
     to mark the beginning of a region and hold the unwind bits, and
     for creating an R_EXIT relocation to mark the end of the region.

     FIXME.  ELF should be using the same conventions!  The problem
     is an unwind requires too much relocation space.  Hmmm.  Maybe
     if we split the unwind bits up between the relocations which
     denote the entry and exit points.  */
  if (last_call_info->start_symbol != NULL)
    {
      char *where;
      unsigned int u;

      where = frag_more (0);
      u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
      fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
		    NULL, (offsetT) 0, NULL,
		    0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
    }
#endif
}

/* Silly nonsense for pa_equ.  The only half-sensible use for this is
   being able to subtract two register symbols that specify a range of
   registers, to get the size of the range.  */
static int fudge_reg_expressions;

int
hppa_force_reg_syms_absolute (expressionS *resultP,
			      operatorT op ATTRIBUTE_UNUSED,
			      expressionS *rightP)
{
  if (fudge_reg_expressions
      && rightP->X_op == O_register
      && resultP->X_op == O_register)
    {
      rightP->X_op = O_constant;
      resultP->X_op = O_constant;
    }
  return 0;  /* Continue normal expr handling.  */
}

/* Handle a .EQU pseudo-op.  */

static void
pa_equ (int reg)
{
  label_symbol_struct *label_symbol = pa_get_label ();
  symbolS *symbol;

  if (label_symbol)
    {
      symbol = label_symbol->lss_label;
      if (reg)
	{
	  strict = 1;
	  if (!pa_parse_number (&input_line_pointer, 0))
	    as_bad (_(".REG expression must be a register"));
	  S_SET_VALUE (symbol, pa_number);
	  S_SET_SEGMENT (symbol, reg_section);
	}
      else
	{
	  expressionS exp;
	  segT seg;

	  fudge_reg_expressions = 1;
	  seg = expression (&exp);
	  fudge_reg_expressions = 0;
	  if (exp.X_op != O_constant
	      && exp.X_op != O_register)
	    {
	      if (exp.X_op != O_absent)
		as_bad (_("bad or irreducible absolute expression; zero assumed"));
	      exp.X_add_number = 0;
	      seg = absolute_section;
	    }
	  S_SET_VALUE (symbol, (unsigned int) exp.X_add_number);
	  S_SET_SEGMENT (symbol, seg);
	}
    }
  else
    {
      if (reg)
	as_bad (_(".REG must use a label"));
      else
	as_bad (_(".EQU must use a label"));
    }

  pa_undefine_label ();
  demand_empty_rest_of_line ();
}

#ifdef OBJ_ELF
/* Mark the end of a function so that it's possible to compute
   the size of the function in elf_hppa_final_processing.  */

static void
hppa_elf_mark_end_of_function (void)
{
  /* ELF does not have EXIT relocations.  All we do is create a
     temporary symbol marking the end of the function.  */
  char *name;

  if (last_call_info == NULL || last_call_info->start_symbol == NULL)
    {
      /* We have already warned about a missing label,
	 or other problems.  */
      return;
    }

  name = xmalloc (strlen ("L$\001end_")
		  + strlen (S_GET_NAME (last_call_info->start_symbol))
		  + 1);
  if (name)
    {
      symbolS *symbolP;

      strcpy (name, "L$\001end_");
      strcat (name, S_GET_NAME (last_call_info->start_symbol));

      /* If we have a .exit followed by a .procend, then the
	 symbol will have already been defined.  */
      symbolP = symbol_find (name);
      if (symbolP)
	{
	  /* The symbol has already been defined!  This can
	     happen if we have a .exit followed by a .procend.

	     This is *not* an error.  All we want to do is free
	     the memory we just allocated for the name and continue.  */
	  xfree (name);
	}
      else
	{
	  /* symbol value should be the offset of the
	     last instruction of the function */
	  symbolP = symbol_new (name, now_seg, (valueT) (frag_now_fix () - 4),
				frag_now);

	  gas_assert (symbolP);
	  S_CLEAR_EXTERNAL (symbolP);
	  symbol_table_insert (symbolP);
	}

      if (symbolP)
	last_call_info->end_symbol = symbolP;
      else
	as_bad (_("Symbol '%s' could not be created."), name);

    }
  else
    as_bad (_("No memory for symbol name."));
}
#endif

/* Helper function.  Does processing for the end of a function.  This
   usually involves creating some relocations or building special
   symbols to mark the end of the function.  */

static void
process_exit (void)
{
  char *where;

  where = frag_more (0);

#ifdef OBJ_ELF
  /* Mark the end of the function, stuff away the location of the frag
     for the end of the function, and finally call pa_build_unwind_subspace
     to add an entry in the unwind table.  */
  (void) where;
  hppa_elf_mark_end_of_function ();
  pa_build_unwind_subspace (last_call_info);
#else
  /* SOM defers building of unwind descriptors until the link phase.
     The assembler is responsible for creating an R_ENTRY relocation
     to mark the beginning of a region and hold the unwind bits, and
     for creating an R_EXIT relocation to mark the end of the region.

     FIXME.  ELF should be using the same conventions!  The problem
     is an unwind requires too much relocation space.  Hmmm.  Maybe
     if we split the unwind bits up between the relocations which
     denote the entry and exit points.  */
  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
		NULL, (offsetT) 0,
		NULL, 0, R_HPPA_EXIT, e_fsel, 0, 0,
		UNWIND_HIGH32 (&last_call_info->ci_unwind.descriptor));
#endif
}

/* Process a .EXIT pseudo-op.  */

static void
pa_exit (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  if (!within_procedure)
    as_bad (_(".EXIT must appear within a procedure"));
  else
    {
      if (!callinfo_found)
	as_bad (_("Missing .callinfo"));
      else
	{
	  if (!within_entry_exit)
	    as_bad (_("No .ENTRY for this .EXIT"));
	  else
	    {
	      within_entry_exit = FALSE;
	      process_exit ();
	    }
	}
    }
  demand_empty_rest_of_line ();
}

/* Helper function to process arguments to a .EXPORT pseudo-op.  */

static void
pa_type_args (symbolS *symbolP, int is_export)
{
  char *name, c, *p;
  unsigned int temp, arg_reloc;
  pa_symbol_type type = SYMBOL_TYPE_UNKNOWN;
  asymbol *bfdsym = symbol_get_bfdsym (symbolP);

  if (strncasecmp (input_line_pointer, "absolute", 8) == 0)
    {
      input_line_pointer += 8;
      bfdsym->flags &= ~BSF_FUNCTION;
      S_SET_SEGMENT (symbolP, bfd_abs_section_ptr);
      type = SYMBOL_TYPE_ABSOLUTE;
    }
  else if (strncasecmp (input_line_pointer, "code", 4) == 0)
    {
      input_line_pointer += 4;
      /* IMPORTing/EXPORTing CODE types for functions is meaningless for SOM,
	 instead one should be IMPORTing/EXPORTing ENTRY types.

	 Complain if one tries to EXPORT a CODE type since that's never
	 done.  Both GCC and HP C still try to IMPORT CODE types, so
	 silently fix them to be ENTRY types.  */
      if (S_IS_FUNCTION (symbolP))
	{
	  if (is_export)
	    as_tsktsk (_("Using ENTRY rather than CODE in export directive for %s"),
		       S_GET_NAME (symbolP));

	  bfdsym->flags |= BSF_FUNCTION;
	  type = SYMBOL_TYPE_ENTRY;
	}
      else
	{
	  bfdsym->flags &= ~BSF_FUNCTION;
	  type = SYMBOL_TYPE_CODE;
	}
    }
  else if (strncasecmp (input_line_pointer, "data", 4) == 0)
    {
      input_line_pointer += 4;
      bfdsym->flags &= ~BSF_FUNCTION;
      bfdsym->flags |= BSF_OBJECT;
      type = SYMBOL_TYPE_DATA;
    }
  else if ((strncasecmp (input_line_pointer, "entry", 5) == 0))
    {
      input_line_pointer += 5;
      bfdsym->flags |= BSF_FUNCTION;
      type = SYMBOL_TYPE_ENTRY;
    }
  else if (strncasecmp (input_line_pointer, "millicode", 9) == 0)
    {
      input_line_pointer += 9;
      bfdsym->flags |= BSF_FUNCTION;
#ifdef OBJ_ELF
      {
	elf_symbol_type *elfsym = (elf_symbol_type *) bfdsym;
	elfsym->internal_elf_sym.st_info =
	  ELF_ST_INFO (ELF_ST_BIND (elfsym->internal_elf_sym.st_info),
		       STT_PARISC_MILLI);
      }
#endif
      type = SYMBOL_TYPE_MILLICODE;
    }
  else if (strncasecmp (input_line_pointer, "plabel", 6) == 0)
    {
      input_line_pointer += 6;
      bfdsym->flags &= ~BSF_FUNCTION;
      type = SYMBOL_TYPE_PLABEL;
    }
  else if (strncasecmp (input_line_pointer, "pri_prog", 8) == 0)
    {
      input_line_pointer += 8;
      bfdsym->flags |= BSF_FUNCTION;
      type = SYMBOL_TYPE_PRI_PROG;
    }
  else if (strncasecmp (input_line_pointer, "sec_prog", 8) == 0)
    {
      input_line_pointer += 8;
      bfdsym->flags |= BSF_FUNCTION;
      type = SYMBOL_TYPE_SEC_PROG;
    }

  /* SOM requires much more information about symbol types
     than BFD understands.  This is how we get this information
     to the SOM BFD backend.  */
#ifdef obj_set_symbol_type
  obj_set_symbol_type (bfdsym, (int) type);
#else
  (void) type;
#endif

  /* Now that the type of the exported symbol has been handled,
     handle any argument relocation information.  */
  while (!is_end_of_statement ())
    {
      if (*input_line_pointer == ',')
	input_line_pointer++;
      name = input_line_pointer;
      c = get_symbol_end ();
      /* Argument sources.  */
      if ((strncasecmp (name, "argw", 4) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = atoi (name + 4);
	  name = input_line_pointer;
	  c = get_symbol_end ();
	  arg_reloc = pa_align_arg_reloc (temp, pa_build_arg_reloc (name));
#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
	  symbol_arg_reloc_info (symbolP) |= arg_reloc;
#else
	  (void) arg_reloc;
#endif
	  *input_line_pointer = c;
	}
      /* The return value.  */
      else if ((strncasecmp (name, "rtnval", 6)) == 0)
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  name = input_line_pointer;
	  c = get_symbol_end ();
	  arg_reloc = pa_build_arg_reloc (name);
#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
	  symbol_arg_reloc_info (symbolP) |= arg_reloc;
#else
	  (void) arg_reloc;
#endif
	  *input_line_pointer = c;
	}
      /* Privilege level.  */
      else if ((strncasecmp (name, "priv_lev", 8)) == 0)
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = atoi (input_line_pointer);
#ifdef OBJ_SOM
	  ((obj_symbol_type *) bfdsym)->tc_data.ap.hppa_priv_level = temp;
#endif
	  c = get_symbol_end ();
	  *input_line_pointer = c;
	}
      else
	{
	  as_bad (_("Undefined .EXPORT/.IMPORT argument (ignored): %s"), name);
	  p = input_line_pointer;
	  *p = c;
	}
      if (!is_end_of_statement ())
	input_line_pointer++;
    }
}

/* Process a .EXPORT directive.  This makes functions external
   and provides information such as argument relocation entries
   to callers.  */

static void
pa_export (int unused ATTRIBUTE_UNUSED)
{
  char *name, c, *p;
  symbolS *symbol;

  name = input_line_pointer;
  c = get_symbol_end ();
  /* Make sure the given symbol exists.  */
  if ((symbol = symbol_find_or_make (name)) == NULL)
    {
      as_bad (_("Cannot define export symbol: %s\n"), name);
      p = input_line_pointer;
      *p = c;
      input_line_pointer++;
    }
  else
    {
      /* OK.  Set the external bits and process argument relocations.
	 For the HP, weak and global are not mutually exclusive.
	 S_SET_EXTERNAL will not set BSF_GLOBAL if WEAK is set.
	 Call S_SET_EXTERNAL to get the other processing.  Manually
	 set BSF_GLOBAL when we get back.  */
      S_SET_EXTERNAL (symbol);
      symbol_get_bfdsym (symbol)->flags |= BSF_GLOBAL;
      p = input_line_pointer;
      *p = c;
      if (!is_end_of_statement ())
	{
	  input_line_pointer++;
	  pa_type_args (symbol, 1);
	}
    }

  demand_empty_rest_of_line ();
}

/* Handle an .IMPORT pseudo-op.  Any symbol referenced in a given
   assembly file must either be defined in the assembly file, or
   explicitly IMPORTED from another.  */

static void
pa_import (int unused ATTRIBUTE_UNUSED)
{
  char *name, c, *p;
  symbolS *symbol;

  name = input_line_pointer;
  c = get_symbol_end ();

  symbol = symbol_find (name);
  /* Ugh.  We might be importing a symbol defined earlier in the file,
     in which case all the code below will really screw things up
     (set the wrong segment, symbol flags & type, etc).  */
  if (symbol == NULL || !S_IS_DEFINED (symbol))
    {
      symbol = symbol_find_or_make (name);
      p = input_line_pointer;
      *p = c;

      if (!is_end_of_statement ())
	{
	  input_line_pointer++;
	  pa_type_args (symbol, 0);
	}
      else
	{
	  /* Sigh.  To be compatible with the HP assembler and to help
	     poorly written assembly code, we assign a type based on
	     the current segment.  Note only BSF_FUNCTION really
	     matters, we do not need to set the full SYMBOL_TYPE_* info.  */
	  if (now_seg == text_section)
	    symbol_get_bfdsym (symbol)->flags |= BSF_FUNCTION;

	  /* If the section is undefined, then the symbol is undefined
	     Since this is an import, leave the section undefined.  */
	  S_SET_SEGMENT (symbol, bfd_und_section_ptr);
	}
    }
  else
    {
      /* The symbol was already defined.  Just eat everything up to
	 the end of the current statement.  */
      while (!is_end_of_statement ())
	input_line_pointer++;
    }

  demand_empty_rest_of_line ();
}

/* Handle a .LABEL pseudo-op.  */

static void
pa_label (int unused ATTRIBUTE_UNUSED)
{
  char *name, c, *p;

  name = input_line_pointer;
  c = get_symbol_end ();

  if (strlen (name) > 0)
    {
      colon (name);
      p = input_line_pointer;
      *p = c;
    }
  else
    {
      as_warn (_("Missing label name on .LABEL"));
    }

  if (!is_end_of_statement ())
    {
      as_warn (_("extra .LABEL arguments ignored."));
      ignore_rest_of_line ();
    }
  demand_empty_rest_of_line ();
}

/* Handle a .LEAVE pseudo-op.  This is not supported yet.  */

static void
pa_leave (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  as_bad (_("The .LEAVE pseudo-op is not supported"));
  demand_empty_rest_of_line ();
}

/* Handle a .LEVEL pseudo-op.  */

static void
pa_level (int unused ATTRIBUTE_UNUSED)
{
  char *level;

  level = input_line_pointer;
  if (strncmp (level, "1.0", 3) == 0)
    {
      input_line_pointer += 3;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 10))
	as_warn (_("could not set architecture and machine"));
    }
  else if (strncmp (level, "1.1", 3) == 0)
    {
      input_line_pointer += 3;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 11))
	as_warn (_("could not set architecture and machine"));
    }
  else if (strncmp (level, "2.0w", 4) == 0)
    {
      input_line_pointer += 4;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 25))
	as_warn (_("could not set architecture and machine"));
    }
  else if (strncmp (level, "2.0", 3) == 0)
    {
      input_line_pointer += 3;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 20))
	as_warn (_("could not set architecture and machine"));
    }
  else
    {
      as_bad (_("Unrecognized .LEVEL argument\n"));
      ignore_rest_of_line ();
    }
  demand_empty_rest_of_line ();
}

/* Handle a .ORIGIN pseudo-op.  */

static void
pa_origin (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  s_org (0);
  pa_undefine_label ();
}

/* Handle a .PARAM pseudo-op.  This is much like a .EXPORT, except it
   is for static functions.  FIXME.  Should share more code with .EXPORT.  */

static void
pa_param (int unused ATTRIBUTE_UNUSED)
{
  char *name, c, *p;
  symbolS *symbol;

  name = input_line_pointer;
  c = get_symbol_end ();

  if ((symbol = symbol_find_or_make (name)) == NULL)
    {
      as_bad (_("Cannot define static symbol: %s\n"), name);
      p = input_line_pointer;
      *p = c;
      input_line_pointer++;
    }
  else
    {
      S_CLEAR_EXTERNAL (symbol);
      p = input_line_pointer;
      *p = c;
      if (!is_end_of_statement ())
	{
	  input_line_pointer++;
	  pa_type_args (symbol, 0);
	}
    }

  demand_empty_rest_of_line ();
}

/* Handle a .PROC pseudo-op.  It is used to mark the beginning
   of a procedure from a syntactical point of view.  */

static void
pa_proc (int unused ATTRIBUTE_UNUSED)
{
  struct call_info *call_info;

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  if (within_procedure)
    as_fatal (_("Nested procedures"));

  /* Reset global variables for new procedure.  */
  callinfo_found = FALSE;
  within_procedure = TRUE;

  /* Create another call_info structure.  */
  call_info = xmalloc (sizeof (struct call_info));

  if (!call_info)
    as_fatal (_("Cannot allocate unwind descriptor\n"));

  memset (call_info, 0, sizeof (struct call_info));

  call_info->ci_next = NULL;

  if (call_info_root == NULL)
    {
      call_info_root = call_info;
      last_call_info = call_info;
    }
  else
    {
      last_call_info->ci_next = call_info;
      last_call_info = call_info;
    }

  /* set up defaults on call_info structure */

  call_info->ci_unwind.descriptor.cannot_unwind = 0;
  call_info->ci_unwind.descriptor.region_desc = 1;
  call_info->ci_unwind.descriptor.hpux_interrupt_marker = 0;

  /* If we got a .PROC pseudo-op, we know that the function is defined
     locally.  Make sure it gets into the symbol table.  */
  {
    label_symbol_struct *label_symbol = pa_get_label ();

    if (label_symbol)
      {
	if (label_symbol->lss_label)
	  {
	    last_call_info->start_symbol = label_symbol->lss_label;
	    symbol_get_bfdsym (label_symbol->lss_label)->flags |= BSF_FUNCTION;
	  }
	else
	  as_bad (_("Missing function name for .PROC (corrupted label chain)"));
      }
    else
      last_call_info->start_symbol = NULL;
  }

  demand_empty_rest_of_line ();
}

/* Process the syntactical end of a procedure.  Make sure all the
   appropriate pseudo-ops were found within the procedure.  */

static void
pa_procend (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  /* If we are within a procedure definition, make sure we've
     defined a label for the procedure; handle case where the
     label was defined after the .PROC directive.

     Note there's not need to diddle with the segment or fragment
     for the label symbol in this case.  We have already switched
     into the new $CODE$ subspace at this point.  */
  if (within_procedure && last_call_info->start_symbol == NULL)
    {
      label_symbol_struct *label_symbol = pa_get_label ();

      if (label_symbol)
	{
	  if (label_symbol->lss_label)
	    {
	      last_call_info->start_symbol = label_symbol->lss_label;
	      symbol_get_bfdsym (label_symbol->lss_label)->flags
		|= BSF_FUNCTION;
#ifdef OBJ_SOM
	      /* Also handle allocation of a fixup to hold the unwind
		 information when the label appears after the proc/procend.  */
	      if (within_entry_exit)
		{
		  char *where;
		  unsigned int u;

		  where = frag_more (0);
		  u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
		  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
				NULL, (offsetT) 0, NULL,
				0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
		}
#endif
	    }
	  else
	    as_bad (_("Missing function name for .PROC (corrupted label chain)"));
	}
      else
	as_bad (_("Missing function name for .PROC"));
    }

  if (!within_procedure)
    as_bad (_("misplaced .procend"));

  if (!callinfo_found)
    as_bad (_("Missing .callinfo for this procedure"));

  if (within_entry_exit)
    as_bad (_("Missing .EXIT for a .ENTRY"));

#ifdef OBJ_ELF
  /* ELF needs to mark the end of each function so that it can compute
     the size of the function (apparently its needed in the symbol table).  */
  hppa_elf_mark_end_of_function ();
#endif

  within_procedure = FALSE;
  demand_empty_rest_of_line ();
  pa_undefine_label ();
}

#ifdef OBJ_SOM
/* If VALUE is an exact power of two between zero and 2^31, then
   return log2 (VALUE).  Else return -1.  */

static int
exact_log2 (int value)
{
  int shift = 0;

  while ((1 << shift) != value && shift < 32)
    shift++;

  if (shift >= 32)
    return -1;
  else
    return shift;
}

/* Check to make sure we have a valid space and subspace.  */

static void
pa_check_current_space_and_subspace (void)
{
  if (current_space == NULL)
    as_fatal (_("Not in a space.\n"));

  if (current_subspace == NULL)
    as_fatal (_("Not in a subspace.\n"));
}

/* Parse the parameters to a .SPACE directive; if CREATE_FLAG is nonzero,
   then create a new space entry to hold the information specified
   by the parameters to the .SPACE directive.  */

static sd_chain_struct *
pa_parse_space_stmt (char *space_name, int create_flag)
{
  char *name, *ptemp, c;
  char loadable, defined, private, sort;
  int spnum;
  asection *seg = NULL;
  sd_chain_struct *space;

  /* Load default values.  */
  spnum = 0;
  sort = 0;
  loadable = TRUE;
  defined = TRUE;
  private = FALSE;
  if (strcmp (space_name, "$TEXT$") == 0)
    {
      seg = pa_def_spaces[0].segment;
      defined = pa_def_spaces[0].defined;
      private = pa_def_spaces[0].private;
      sort = pa_def_spaces[0].sort;
      spnum = pa_def_spaces[0].spnum;
    }
  else if (strcmp (space_name, "$PRIVATE$") == 0)
    {
      seg = pa_def_spaces[1].segment;
      defined = pa_def_spaces[1].defined;
      private = pa_def_spaces[1].private;
      sort = pa_def_spaces[1].sort;
      spnum = pa_def_spaces[1].spnum;
    }

  if (!is_end_of_statement ())
    {
      print_errors = FALSE;
      ptemp = input_line_pointer + 1;
      /* First see if the space was specified as a number rather than
	 as a name.  According to the PA assembly manual the rest of
	 the line should be ignored.  */
      strict = 0;
      pa_parse_number (&ptemp, 0);
      if (pa_number >= 0)
	{
	  spnum = pa_number;
	  input_line_pointer = ptemp;
	}
      else
	{
	  while (!is_end_of_statement ())
	    {
	      input_line_pointer++;
	      name = input_line_pointer;
	      c = get_symbol_end ();
	      if ((strncasecmp (name, "spnum", 5) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  spnum = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "sort", 4) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  sort = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "unloadable", 10) == 0))
		{
		  *input_line_pointer = c;
		  loadable = FALSE;
		}
	      else if ((strncasecmp (name, "notdefined", 10) == 0))
		{
		  *input_line_pointer = c;
		  defined = FALSE;
		}
	      else if ((strncasecmp (name, "private", 7) == 0))
		{
		  *input_line_pointer = c;
		  private = TRUE;
		}
	      else
		{
		  as_bad (_("Invalid .SPACE argument"));
		  *input_line_pointer = c;
		  if (!is_end_of_statement ())
		    input_line_pointer++;
		}
	    }
	}
      print_errors = TRUE;
    }

  if (create_flag && seg == NULL)
    seg = subseg_new (space_name, 0);

  /* If create_flag is nonzero, then create the new space with
     the attributes computed above.  Else set the values in
     an already existing space -- this can only happen for
     the first occurrence of a built-in space.  */
  if (create_flag)
    space = create_new_space (space_name, spnum, loadable, defined,
			      private, sort, seg, 1);
  else
    {
      space = is_defined_space (space_name);
      SPACE_SPNUM (space) = spnum;
      SPACE_DEFINED (space) = defined & 1;
      SPACE_USER_DEFINED (space) = 1;
    }

#ifdef obj_set_section_attributes
  obj_set_section_attributes (seg, defined, private, sort, spnum);
#endif

  return space;
}

/* Handle a .SPACE pseudo-op; this switches the current space to the
   given space, creating the new space if necessary.  */

static void
pa_space (int unused ATTRIBUTE_UNUSED)
{
  char *name, c, *space_name, *save_s;
  sd_chain_struct *sd_chain;

  if (within_procedure)
    {
      as_bad (_("Can\'t change spaces within a procedure definition. Ignored"));
      ignore_rest_of_line ();
    }
  else
    {
      /* Check for some of the predefined spaces.   FIXME: most of the code
	 below is repeated several times, can we extract the common parts
	 and place them into a subroutine or something similar?  */
      /* FIXME Is this (and the next IF stmt) really right?
	 What if INPUT_LINE_POINTER points to "$TEXT$FOO"?  */
      if (strncmp (input_line_pointer, "$TEXT$", 6) == 0)
	{
	  input_line_pointer += 6;
	  sd_chain = is_defined_space ("$TEXT$");
	  if (sd_chain == NULL)
	    sd_chain = pa_parse_space_stmt ("$TEXT$", 1);
	  else if (SPACE_USER_DEFINED (sd_chain) == 0)
	    sd_chain = pa_parse_space_stmt ("$TEXT$", 0);

	  current_space = sd_chain;
	  subseg_set (text_section, sd_chain->sd_last_subseg);
	  current_subspace
	    = pa_subsegment_to_subspace (text_section,
					 sd_chain->sd_last_subseg);
	  demand_empty_rest_of_line ();
	  return;
	}
      if (strncmp (input_line_pointer, "$PRIVATE$", 9) == 0)
	{
	  input_line_pointer += 9;
	  sd_chain = is_defined_space ("$PRIVATE$");
	  if (sd_chain == NULL)
	    sd_chain = pa_parse_space_stmt ("$PRIVATE$", 1);
	  else if (SPACE_USER_DEFINED (sd_chain) == 0)
	    sd_chain = pa_parse_space_stmt ("$PRIVATE$", 0);

	  current_space = sd_chain;
	  subseg_set (data_section, sd_chain->sd_last_subseg);
	  current_subspace
	    = pa_subsegment_to_subspace (data_section,
					 sd_chain->sd_last_subseg);
	  demand_empty_rest_of_line ();
	  return;
	}
      if (!strncasecmp (input_line_pointer,
			GDB_DEBUG_SPACE_NAME,
			strlen (GDB_DEBUG_SPACE_NAME)))
	{
	  input_line_pointer += strlen (GDB_DEBUG_SPACE_NAME);
	  sd_chain = is_defined_space (GDB_DEBUG_SPACE_NAME);
	  if (sd_chain == NULL)
	    sd_chain = pa_parse_space_stmt (GDB_DEBUG_SPACE_NAME, 1);
	  else if (SPACE_USER_DEFINED (sd_chain) == 0)
	    sd_chain = pa_parse_space_stmt (GDB_DEBUG_SPACE_NAME, 0);

	  current_space = sd_chain;

	  {
	    asection *gdb_section
	    = bfd_make_section_old_way (stdoutput, GDB_DEBUG_SPACE_NAME);

	    subseg_set (gdb_section, sd_chain->sd_last_subseg);
	    current_subspace
	      = pa_subsegment_to_subspace (gdb_section,
					   sd_chain->sd_last_subseg);
	  }
	  demand_empty_rest_of_line ();
	  return;
	}

      /* It could be a space specified by number.  */
      print_errors = 0;
      save_s = input_line_pointer;
      strict = 0;
      pa_parse_number (&input_line_pointer, 0);
      if (pa_number >= 0)
	{
	  if ((sd_chain = pa_find_space_by_number (pa_number)))
	    {
	      current_space = sd_chain;

	      subseg_set (sd_chain->sd_seg, sd_chain->sd_last_subseg);
	      current_subspace
		= pa_subsegment_to_subspace (sd_chain->sd_seg,
					     sd_chain->sd_last_subseg);
	      demand_empty_rest_of_line ();
	      return;
	    }
	}

      /* Not a number, attempt to create a new space.  */
      print_errors = 1;
      input_line_pointer = save_s;
      name = input_line_pointer;
      c = get_symbol_end ();
      space_name = xmalloc (strlen (name) + 1);
      strcpy (space_name, name);
      *input_line_pointer = c;

      sd_chain = pa_parse_space_stmt (space_name, 1);
      current_space = sd_chain;

      subseg_set (sd_chain->sd_seg, sd_chain->sd_last_subseg);
      current_subspace = pa_subsegment_to_subspace (sd_chain->sd_seg,
						  sd_chain->sd_last_subseg);
      demand_empty_rest_of_line ();
    }
}

/* Switch to a new space.  (I think).  FIXME.  */

static void
pa_spnum (int unused ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char *p;
  sd_chain_struct *space;

  name = input_line_pointer;
  c = get_symbol_end ();
  space = is_defined_space (name);
  if (space)
    {
      p = frag_more (4);
      md_number_to_chars (p, SPACE_SPNUM (space), 4);
    }
  else
    as_warn (_("Undefined space: '%s' Assuming space number = 0."), name);

  *input_line_pointer = c;
  demand_empty_rest_of_line ();
}

/* Handle a .SUBSPACE pseudo-op; this switches the current subspace to the
   given subspace, creating the new subspace if necessary.

   FIXME.  Should mirror pa_space more closely, in particular how
   they're broken up into subroutines.  */

static void
pa_subspace (int create_new)
{
  char *name, *ss_name, c;
  char loadable, code_only, comdat, common, dup_common, zero, sort;
  int i, access_ctr, space_index, alignment, quadrant, applicable, flags;
  sd_chain_struct *space;
  ssd_chain_struct *ssd;
  asection *section;

  if (current_space == NULL)
    as_fatal (_("Must be in a space before changing or declaring subspaces.\n"));

  if (within_procedure)
    {
      as_bad (_("Can\'t change subspaces within a procedure definition. Ignored"));
      ignore_rest_of_line ();
    }
  else
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      ss_name = xmalloc (strlen (name) + 1);
      strcpy (ss_name, name);
      *input_line_pointer = c;

      /* Load default values.  */
      sort = 0;
      access_ctr = 0x7f;
      loadable = 1;
      comdat = 0;
      common = 0;
      dup_common = 0;
      code_only = 0;
      zero = 0;
      space_index = ~0;
      alignment = 1;
      quadrant = 0;

      space = current_space;
      if (create_new)
	ssd = NULL;
      else
	ssd = is_defined_subspace (ss_name);
      /* Allow user to override the builtin attributes of subspaces.  But
	 only allow the attributes to be changed once!  */
      if (ssd && SUBSPACE_DEFINED (ssd))
	{
	  subseg_set (ssd->ssd_seg, ssd->ssd_subseg);
	  current_subspace = ssd;
	  if (!is_end_of_statement ())
	    as_warn (_("Parameters of an existing subspace can\'t be modified"));
	  demand_empty_rest_of_line ();
	  return;
	}
      else
	{
	  /* A new subspace.  Load default values if it matches one of
	     the builtin subspaces.  */
	  i = 0;
	  while (pa_def_subspaces[i].name)
	    {
	      if (strcasecmp (pa_def_subspaces[i].name, ss_name) == 0)
		{
		  loadable = pa_def_subspaces[i].loadable;
		  comdat = pa_def_subspaces[i].comdat;
		  common = pa_def_subspaces[i].common;
		  dup_common = pa_def_subspaces[i].dup_common;
		  code_only = pa_def_subspaces[i].code_only;
		  zero = pa_def_subspaces[i].zero;
		  space_index = pa_def_subspaces[i].space_index;
		  alignment = pa_def_subspaces[i].alignment;
		  quadrant = pa_def_subspaces[i].quadrant;
		  access_ctr = pa_def_subspaces[i].access;
		  sort = pa_def_subspaces[i].sort;
		  break;
		}
	      i++;
	    }
	}

      /* We should be working with a new subspace now.  Fill in
	 any information as specified by the user.  */
      if (!is_end_of_statement ())
	{
	  input_line_pointer++;
	  while (!is_end_of_statement ())
	    {
	      name = input_line_pointer;
	      c = get_symbol_end ();
	      if ((strncasecmp (name, "quad", 4) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  quadrant = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "align", 5) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  alignment = get_absolute_expression ();
		  if (exact_log2 (alignment) == -1)
		    {
		      as_bad (_("Alignment must be a power of 2"));
		      alignment = 1;
		    }
		}
	      else if ((strncasecmp (name, "access", 6) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  access_ctr = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "sort", 4) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  sort = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "code_only", 9) == 0))
		{
		  *input_line_pointer = c;
		  code_only = 1;
		}
	      else if ((strncasecmp (name, "unloadable", 10) == 0))
		{
		  *input_line_pointer = c;
		  loadable = 0;
		}
	      else if ((strncasecmp (name, "comdat", 6) == 0))
		{
		  *input_line_pointer = c;
		  comdat = 1;
		}
	      else if ((strncasecmp (name, "common", 6) == 0))
		{
		  *input_line_pointer = c;
		  common = 1;
		}
	      else if ((strncasecmp (name, "dup_comm", 8) == 0))
		{
		  *input_line_pointer = c;
		  dup_common = 1;
		}
	      else if ((strncasecmp (name, "zero", 4) == 0))
		{
		  *input_line_pointer = c;
		  zero = 1;
		}
	      else if ((strncasecmp (name, "first", 5) == 0))
		as_bad (_("FIRST not supported as a .SUBSPACE argument"));
	      else
		as_bad (_("Invalid .SUBSPACE argument"));
	      if (!is_end_of_statement ())
		input_line_pointer++;
	    }
	}

      /* Compute a reasonable set of BFD flags based on the information
	 in the .subspace directive.  */
      applicable = bfd_applicable_section_flags (stdoutput);
      flags = 0;
      if (loadable)
	flags |= (SEC_ALLOC | SEC_LOAD);
      if (code_only)
	flags |= SEC_CODE;

      /* These flags are used to implement various flavors of initialized
	 common.  The SOM linker discards duplicate subspaces when they
	 have the same "key" symbol name.  This support is more like
	 GNU linkonce than BFD common.  Further, pc-relative relocations
	 are converted to section relative relocations in BFD common
	 sections.  This complicates the handling of relocations in
	 common sections containing text and isn't currently supported
	 correctly in the SOM BFD backend.  */
      if (comdat || common || dup_common)
	flags |= SEC_LINK_ONCE;

      flags |= SEC_RELOC | SEC_HAS_CONTENTS;

      /* This is a zero-filled subspace (eg BSS).  */
      if (zero)
	flags &= ~(SEC_LOAD | SEC_HAS_CONTENTS);

      applicable &= flags;

      /* If this is an existing subspace, then we want to use the
	 segment already associated with the subspace.

	 FIXME NOW!  ELF BFD doesn't appear to be ready to deal with
	 lots of sections.  It might be a problem in the PA ELF
	 code, I do not know yet.  For now avoid creating anything
	 but the "standard" sections for ELF.  */
      if (create_new)
	section = subseg_force_new (ss_name, 0);
      else if (ssd)
	section = ssd->ssd_seg;
      else
	section = subseg_new (ss_name, 0);

      if (zero)
	seg_info (section)->bss = 1;

      /* Now set the flags.  */
      bfd_set_section_flags (stdoutput, section, applicable);

      /* Record any alignment request for this section.  */
      record_alignment (section, exact_log2 (alignment));

      /* Set the starting offset for this section.  */
      bfd_set_section_vma (stdoutput, section,
			   pa_subspace_start (space, quadrant));

      /* Now that all the flags are set, update an existing subspace,
	 or create a new one.  */
      if (ssd)

	current_subspace = update_subspace (space, ss_name, loadable,
					    code_only, comdat, common,
					    dup_common, sort, zero, access_ctr,
					    space_index, alignment, quadrant,
					    section);
      else
	current_subspace = create_new_subspace (space, ss_name, loadable,
						code_only, comdat, common,
						dup_common, zero, sort,
						access_ctr, space_index,
						alignment, quadrant, section);

      demand_empty_rest_of_line ();
      current_subspace->ssd_seg = section;
      subseg_set (current_subspace->ssd_seg, current_subspace->ssd_subseg);
    }
  SUBSPACE_DEFINED (current_subspace) = 1;
}

/* Create default space and subspace dictionaries.  */

static void
pa_spaces_begin (void)
{
  int i;

  space_dict_root = NULL;
  space_dict_last = NULL;

  i = 0;
  while (pa_def_spaces[i].name)
    {
      char *name;

      /* Pick the right name to use for the new section.  */
      name = pa_def_spaces[i].name;

      pa_def_spaces[i].segment = subseg_new (name, 0);
      create_new_space (pa_def_spaces[i].name, pa_def_spaces[i].spnum,
			pa_def_spaces[i].loadable, pa_def_spaces[i].defined,
			pa_def_spaces[i].private, pa_def_spaces[i].sort,
			pa_def_spaces[i].segment, 0);
      i++;
    }

  i = 0;
  while (pa_def_subspaces[i].name)
    {
      char *name;
      int applicable, subsegment;
      asection *segment = NULL;
      sd_chain_struct *space;

      /* Pick the right name for the new section and pick the right
	 subsegment number.  */
      name = pa_def_subspaces[i].name;
      subsegment = 0;

      /* Create the new section.  */
      segment = subseg_new (name, subsegment);

      /* For SOM we want to replace the standard .text, .data, and .bss
	 sections with our own.   We also want to set BFD flags for
	 all the built-in subspaces.  */
      if (!strcmp (pa_def_subspaces[i].name, "$CODE$"))
	{
	  text_section = segment;
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC | SEC_CODE
					       | SEC_READONLY
					       | SEC_HAS_CONTENTS));
	}
      else if (!strcmp (pa_def_subspaces[i].name, "$DATA$"))
	{
	  data_section = segment;
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC
					       | SEC_HAS_CONTENTS));

	}
      else if (!strcmp (pa_def_subspaces[i].name, "$BSS$"))
	{
	  bss_section = segment;
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & SEC_ALLOC);
	}
      else if (!strcmp (pa_def_subspaces[i].name, "$LIT$"))
	{
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC
					       | SEC_READONLY
					       | SEC_HAS_CONTENTS));
	}
      else if (!strcmp (pa_def_subspaces[i].name, "$MILLICODE$"))
	{
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC
					       | SEC_READONLY
					       | SEC_HAS_CONTENTS));
	}
      else if (!strcmp (pa_def_subspaces[i].name, "$UNWIND$"))
	{
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC
					       | SEC_READONLY
					       | SEC_HAS_CONTENTS));
	}

      /* Find the space associated with this subspace.  */
      space = pa_segment_to_space (pa_def_spaces[pa_def_subspaces[i].
						 def_space_index].segment);
      if (space == NULL)
	{
	  as_fatal (_("Internal error: Unable to find containing space for %s."),
		    pa_def_subspaces[i].name);
	}

      create_new_subspace (space, name,
			   pa_def_subspaces[i].loadable,
			   pa_def_subspaces[i].code_only,
			   pa_def_subspaces[i].comdat,
			   pa_def_subspaces[i].common,
			   pa_def_subspaces[i].dup_common,
			   pa_def_subspaces[i].zero,
			   pa_def_subspaces[i].sort,
			   pa_def_subspaces[i].access,
			   pa_def_subspaces[i].space_index,
			   pa_def_subspaces[i].alignment,
			   pa_def_subspaces[i].quadrant,
			   segment);
      i++;
    }
}

/* Create a new space NAME, with the appropriate flags as defined
   by the given parameters.  */

static sd_chain_struct *
create_new_space (char *name,
		  int spnum,
		  int loadable ATTRIBUTE_UNUSED,
		  int defined,
		  int private,
		  int sort,
		  asection *seg,
		  int user_defined)
{
  sd_chain_struct *chain_entry;

  chain_entry = xmalloc (sizeof (sd_chain_struct));
  if (!chain_entry)
    as_fatal (_("Out of memory: could not allocate new space chain entry: %s\n"),
	      name);

  SPACE_NAME (chain_entry) = xmalloc (strlen (name) + 1);
  strcpy (SPACE_NAME (chain_entry), name);
  SPACE_DEFINED (chain_entry) = defined;
  SPACE_USER_DEFINED (chain_entry) = user_defined;
  SPACE_SPNUM (chain_entry) = spnum;

  chain_entry->sd_seg = seg;
  chain_entry->sd_last_subseg = -1;
  chain_entry->sd_subspaces = NULL;
  chain_entry->sd_next = NULL;

  /* Find spot for the new space based on its sort key.  */
  if (!space_dict_last)
    space_dict_last = chain_entry;

  if (space_dict_root == NULL)
    space_dict_root = chain_entry;
  else
    {
      sd_chain_struct *chain_pointer;
      sd_chain_struct *prev_chain_pointer;

      chain_pointer = space_dict_root;
      prev_chain_pointer = NULL;

      while (chain_pointer)
	{
	  prev_chain_pointer = chain_pointer;
	  chain_pointer = chain_pointer->sd_next;
	}

      /* At this point we've found the correct place to add the new
	 entry.  So add it and update the linked lists as appropriate.  */
      if (prev_chain_pointer)
	{
	  chain_entry->sd_next = chain_pointer;
	  prev_chain_pointer->sd_next = chain_entry;
	}
      else
	{
	  space_dict_root = chain_entry;
	  chain_entry->sd_next = chain_pointer;
	}

      if (chain_entry->sd_next == NULL)
	space_dict_last = chain_entry;
    }

  /* This is here to catch predefined spaces which do not get
     modified by the user's input.  Another call is found at
     the bottom of pa_parse_space_stmt to handle cases where
     the user modifies a predefined space.  */
#ifdef obj_set_section_attributes
  obj_set_section_attributes (seg, defined, private, sort, spnum);
#endif

  return chain_entry;
}

/* Create a new subspace NAME, with the appropriate flags as defined
   by the given parameters.

   Add the new subspace to the subspace dictionary chain in numerical
   order as defined by the SORT entries.  */

static ssd_chain_struct *
create_new_subspace (sd_chain_struct *space,
		     char *name,
		     int loadable ATTRIBUTE_UNUSED,
		     int code_only ATTRIBUTE_UNUSED,
		     int comdat,
		     int common,
		     int dup_common,
		     int is_zero ATTRIBUTE_UNUSED,
		     int sort,
		     int access_ctr,
		     int space_index ATTRIBUTE_UNUSED,
		     int alignment ATTRIBUTE_UNUSED,
		     int quadrant,
		     asection *seg)
{
  ssd_chain_struct *chain_entry;

  chain_entry = xmalloc (sizeof (ssd_chain_struct));
  if (!chain_entry)
    as_fatal (_("Out of memory: could not allocate new subspace chain entry: %s\n"), name);

  SUBSPACE_NAME (chain_entry) = xmalloc (strlen (name) + 1);
  strcpy (SUBSPACE_NAME (chain_entry), name);

  /* Initialize subspace_defined.  When we hit a .subspace directive
     we'll set it to 1 which "locks-in" the subspace attributes.  */
  SUBSPACE_DEFINED (chain_entry) = 0;

  chain_entry->ssd_subseg = 0;
  chain_entry->ssd_seg = seg;
  chain_entry->ssd_next = NULL;

  /* Find spot for the new subspace based on its sort key.  */
  if (space->sd_subspaces == NULL)
    space->sd_subspaces = chain_entry;
  else
    {
      ssd_chain_struct *chain_pointer;
      ssd_chain_struct *prev_chain_pointer;

      chain_pointer = space->sd_subspaces;
      prev_chain_pointer = NULL;

      while (chain_pointer)
	{
	  prev_chain_pointer = chain_pointer;
	  chain_pointer = chain_pointer->ssd_next;
	}

      /* Now we have somewhere to put the new entry.  Insert it and update
	 the links.  */
      if (prev_chain_pointer)
	{
	  chain_entry->ssd_next = chain_pointer;
	  prev_chain_pointer->ssd_next = chain_entry;
	}
      else
	{
	  space->sd_subspaces = chain_entry;
	  chain_entry->ssd_next = chain_pointer;
	}
    }

#ifdef obj_set_subsection_attributes
  obj_set_subsection_attributes (seg, space->sd_seg, access_ctr, sort,
				 quadrant, comdat, common, dup_common);
#endif

  return chain_entry;
}

/* Update the information for the given subspace based upon the
   various arguments.   Return the modified subspace chain entry.  */

static ssd_chain_struct *
update_subspace (sd_chain_struct *space,
		 char *name,
		 int loadable ATTRIBUTE_UNUSED,
		 int code_only ATTRIBUTE_UNUSED,
		 int comdat,
		 int common,
		 int dup_common,
		 int sort,
		 int zero ATTRIBUTE_UNUSED,
		 int access_ctr,
		 int space_index ATTRIBUTE_UNUSED,
		 int alignment ATTRIBUTE_UNUSED,
		 int quadrant,
		 asection *section)
{
  ssd_chain_struct *chain_entry;

  chain_entry = is_defined_subspace (name);

#ifdef obj_set_subsection_attributes
  obj_set_subsection_attributes (section, space->sd_seg, access_ctr, sort,
				 quadrant, comdat, common, dup_common);
#endif

  return chain_entry;
}

/* Return the space chain entry for the space with the name NAME or
   NULL if no such space exists.  */

static sd_chain_struct *
is_defined_space (char *name)
{
  sd_chain_struct *chain_pointer;

  for (chain_pointer = space_dict_root;
       chain_pointer;
       chain_pointer = chain_pointer->sd_next)
    if (strcmp (SPACE_NAME (chain_pointer), name) == 0)
      return chain_pointer;

  /* No mapping from segment to space was found.  Return NULL.  */
  return NULL;
}

/* Find and return the space associated with the given seg.  If no mapping
   from the given seg to a space is found, then return NULL.

   Unlike subspaces, the number of spaces is not expected to grow much,
   so a linear exhaustive search is OK here.  */

static sd_chain_struct *
pa_segment_to_space (asection *seg)
{
  sd_chain_struct *space_chain;

  /* Walk through each space looking for the correct mapping.  */
  for (space_chain = space_dict_root;
       space_chain;
       space_chain = space_chain->sd_next)
    if (space_chain->sd_seg == seg)
      return space_chain;

  /* Mapping was not found.  Return NULL.  */
  return NULL;
}

/* Return the first space chain entry for the subspace with the name
   NAME or NULL if no such subspace exists.

   When there are multiple subspaces with the same name, switching to
   the first (i.e., default) subspace is preferable in most situations.
   For example, it wouldn't be desirable to merge COMDAT data with non
   COMDAT data.

   Uses a linear search through all the spaces and subspaces, this may
   not be appropriate if we ever being placing each function in its
   own subspace.  */

static ssd_chain_struct *
is_defined_subspace (char *name)
{
  sd_chain_struct *space_chain;
  ssd_chain_struct *subspace_chain;

  /* Walk through each space.  */
  for (space_chain = space_dict_root;
       space_chain;
       space_chain = space_chain->sd_next)
    {
      /* Walk through each subspace looking for a name which matches.  */
      for (subspace_chain = space_chain->sd_subspaces;
	   subspace_chain;
	   subspace_chain = subspace_chain->ssd_next)
	if (strcmp (SUBSPACE_NAME (subspace_chain), name) == 0)
	  return subspace_chain;
    }

  /* Subspace wasn't found.  Return NULL.  */
  return NULL;
}

/* Find and return the subspace associated with the given seg.  If no
   mapping from the given seg to a subspace is found, then return NULL.

   If we ever put each procedure/function within its own subspace
   (to make life easier on the compiler and linker), then this will have
   to become more efficient.  */

static ssd_chain_struct *
pa_subsegment_to_subspace (asection *seg, subsegT subseg)
{
  sd_chain_struct *space_chain;
  ssd_chain_struct *subspace_chain;

  /* Walk through each space.  */
  for (space_chain = space_dict_root;
       space_chain;
       space_chain = space_chain->sd_next)
    {
      if (space_chain->sd_seg == seg)
	{
	  /* Walk through each subspace within each space looking for
	     the correct mapping.  */
	  for (subspace_chain = space_chain->sd_subspaces;
	       subspace_chain;
	       subspace_chain = subspace_chain->ssd_next)
	    if (subspace_chain->ssd_subseg == (int) subseg)
	      return subspace_chain;
	}
    }

  /* No mapping from subsegment to subspace found.  Return NULL.  */
  return NULL;
}

/* Given a number, try and find a space with the name number.

   Return a pointer to a space dictionary chain entry for the space
   that was found or NULL on failure.  */

static sd_chain_struct *
pa_find_space_by_number (int number)
{
  sd_chain_struct *space_chain;

  for (space_chain = space_dict_root;
       space_chain;
       space_chain = space_chain->sd_next)
    {
      if (SPACE_SPNUM (space_chain) == (unsigned int) number)
	return space_chain;
    }

  /* No appropriate space found.  Return NULL.  */
  return NULL;
}

/* Return the starting address for the given subspace.  If the starting
   address is unknown then return zero.  */

static unsigned int
pa_subspace_start (sd_chain_struct *space, int quadrant)
{
  /* FIXME.  Assumes everyone puts read/write data at 0x4000000, this
     is not correct for the PA OSF1 port.  */
  if ((strcmp (SPACE_NAME (space), "$PRIVATE$") == 0) && quadrant == 1)
    return 0x40000000;
  else if (space->sd_seg == data_section && quadrant == 1)
    return 0x40000000;
  else
    return 0;
  return 0;
}
#endif

/* Helper function for pa_stringer.  Used to find the end of
   a string.  */

static unsigned int
pa_stringer_aux (char *s)
{
  unsigned int c = *s & CHAR_MASK;

  switch (c)
    {
    case '\"':
      c = NOT_A_CHAR;
      break;
    default:
      break;
    }
  return c;
}

/* Handle a .STRING type pseudo-op.  */

static void
pa_stringer (int append_zero)
{
  char *s, num_buf[4];
  unsigned int c;
  int i;

  /* Preprocess the string to handle PA-specific escape sequences.
     For example, \xDD where DD is a hexadecimal number should be
     changed to \OOO where OOO is an octal number.  */

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  /* Skip the opening quote.  */
  s = input_line_pointer + 1;

  while (is_a_char (c = pa_stringer_aux (s++)))
    {
      if (c == '\\')
	{
	  c = *s;
	  switch (c)
	    {
	      /* Handle \x<num>.  */
	    case 'x':
	      {
		unsigned int number;
		int num_digit;
		char dg;
		char *s_start = s;

		/* Get past the 'x'.  */
		s++;
		for (num_digit = 0, number = 0, dg = *s;
		     num_digit < 2
		     && (ISDIGIT (dg) || (dg >= 'a' && dg <= 'f')
			 || (dg >= 'A' && dg <= 'F'));
		     num_digit++)
		  {
		    if (ISDIGIT (dg))
		      number = number * 16 + dg - '0';
		    else if (dg >= 'a' && dg <= 'f')
		      number = number * 16 + dg - 'a' + 10;
		    else
		      number = number * 16 + dg - 'A' + 10;

		    s++;
		    dg = *s;
		  }
		if (num_digit > 0)
		  {
		    switch (num_digit)
		      {
		      case 1:
			sprintf (num_buf, "%02o", number);
			break;
		      case 2:
			sprintf (num_buf, "%03o", number);
			break;
		      }
		    for (i = 0; i <= num_digit; i++)
		      s_start[i] = num_buf[i];
		  }
		break;
	      }
	    /* This might be a "\"", skip over the escaped char.  */
	    default:
	      s++;
	      break;
	    }
	}
    }
  stringer (8 + append_zero);
  pa_undefine_label ();
}

/* Handle a .VERSION pseudo-op.  */

static void
pa_version (int unused ATTRIBUTE_UNUSED)
{
  obj_version (0);
  pa_undefine_label ();
}

#ifdef OBJ_SOM

/* Handle a .COMPILER pseudo-op.  */

static void
pa_compiler (int unused ATTRIBUTE_UNUSED)
{
  obj_som_compiler (0);
  pa_undefine_label ();
}

#endif

/* Handle a .COPYRIGHT pseudo-op.  */

static void
pa_copyright (int unused ATTRIBUTE_UNUSED)
{
  obj_copyright (0);
  pa_undefine_label ();
}

/* Just like a normal cons, but when finished we have to undefine
   the latest space label.  */

static void
pa_cons (int nbytes)
{
  cons (nbytes);
  pa_undefine_label ();
}

/* Like float_cons, but we need to undefine our label.  */

static void
pa_float_cons (int float_type)
{
  float_cons (float_type);
  pa_undefine_label ();
}

/* Like s_fill, but delete our label when finished.  */

static void
pa_fill (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  s_fill (0);
  pa_undefine_label ();
}

/* Like lcomm, but delete our label when finished.  */

static void
pa_lcomm (int needs_align)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  s_lcomm (needs_align);
  pa_undefine_label ();
}

/* Like lsym, but delete our label when finished.  */

static void
pa_lsym (int unused ATTRIBUTE_UNUSED)
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  s_lsym (0);
  pa_undefine_label ();
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will need.  */

void
md_begin (void)
{
  const char *retval = NULL;
  int lose = 0;
  unsigned int i = 0;

  last_call_info = NULL;
  call_info_root = NULL;

  /* Set the default machine type.  */
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, DEFAULT_LEVEL))
    as_warn (_("could not set architecture and machine"));

  /* Folding of text and data segments fails miserably on the PA.
     Warn user and disable "-R" option.  */
  if (flag_readonly_data_in_text)
    {
      as_warn (_("-R option not supported on this target."));
      flag_readonly_data_in_text = 0;
    }

#ifdef OBJ_SOM
  pa_spaces_begin ();
#endif

  op_hash = hash_new ();

  while (i < NUMOPCODES)
    {
      const char *name = pa_opcodes[i].name;

      retval = hash_insert (op_hash, name, (struct pa_opcode *) &pa_opcodes[i]);
      if (retval != NULL && *retval != '\0')
	{
	  as_fatal (_("Internal error: can't hash `%s': %s\n"), name, retval);
	  lose = 1;
	}

      do
	{
	  if ((pa_opcodes[i].match & pa_opcodes[i].mask)
	      != pa_opcodes[i].match)
	    {
	      fprintf (stderr, _("internal error: losing opcode: `%s' \"%s\"\n"),
		       pa_opcodes[i].name, pa_opcodes[i].args);
	      lose = 1;
	    }
	  ++i;
	}
      while (i < NUMOPCODES && !strcmp (pa_opcodes[i].name, name));
    }

  if (lose)
    as_fatal (_("Broken assembler.  No assembly attempted."));

#ifdef OBJ_SOM
  /* SOM will change text_section.  To make sure we never put
     anything into the old one switch to the new one now.  */
  subseg_set (text_section, 0);
#endif

#ifdef OBJ_SOM
  dummy_symbol = symbol_find_or_make ("L$dummy");
  S_SET_SEGMENT (dummy_symbol, text_section);
  /* Force the symbol to be converted to a real symbol.  */
  symbol_get_bfdsym (dummy_symbol)->flags |= BSF_KEEP;
#endif
}

/* On the PA relocations which involve function symbols must not be
   adjusted.  This so that the linker can know when/how to create argument
   relocation stubs for indirect calls and calls to static functions.

   "T" field selectors create DLT relative fixups for accessing
   globals and statics in PIC code; each DLT relative fixup creates
   an entry in the DLT table.  The entries contain the address of
   the final target (eg accessing "foo" would create a DLT entry
   with the address of "foo").

   Unfortunately, the HP linker doesn't take into account any addend
   when generating the DLT; so accessing $LIT$+8 puts the address of
   $LIT$ into the DLT rather than the address of $LIT$+8.

   The end result is we can't perform relocation symbol reductions for
   any fixup which creates entries in the DLT (eg they use "T" field
   selectors).

   ??? Reject reductions involving symbols with external scope; such
   reductions make life a living hell for object file editors.  */

int
hppa_fix_adjustable (fixS *fixp)
{
#ifdef OBJ_ELF
  reloc_type code;
#endif
  struct hppa_fix_struct *hppa_fix;

  hppa_fix = (struct hppa_fix_struct *) fixp->tc_fix_data;

#ifdef OBJ_ELF
  /* LR/RR selectors are implicitly used for a number of different relocation
     types.  We must ensure that none of these types are adjusted (see below)
     even if they occur with a different selector.  */
  code = elf_hppa_reloc_final_type (stdoutput, fixp->fx_r_type,
		  		    hppa_fix->fx_r_format,
				    hppa_fix->fx_r_field);

  switch (code)
    {
    /* Relocation types which use e_lrsel.  */
    case R_PARISC_DIR21L:
    case R_PARISC_DLTREL21L:
    case R_PARISC_DPREL21L:
    case R_PARISC_PLTOFF21L:

    /* Relocation types which use e_rrsel.  */
    case R_PARISC_DIR14R:
    case R_PARISC_DIR14DR:
    case R_PARISC_DIR14WR:
    case R_PARISC_DIR17R:
    case R_PARISC_DLTREL14R:
    case R_PARISC_DLTREL14DR:
    case R_PARISC_DLTREL14WR:
    case R_PARISC_DPREL14R:
    case R_PARISC_DPREL14DR:
    case R_PARISC_DPREL14WR:
    case R_PARISC_PLTOFF14R:
    case R_PARISC_PLTOFF14DR:
    case R_PARISC_PLTOFF14WR:

    /* Other types that we reject for reduction.  */
    case R_PARISC_GNU_VTENTRY:
    case R_PARISC_GNU_VTINHERIT:
      return 0;
    default:
      break;
    }
#endif

  /* Reject reductions of symbols in sym1-sym2 expressions when
     the fixup will occur in a CODE subspace.

     XXX FIXME: Long term we probably want to reject all of these;
     for example reducing in the debug section would lose if we ever
     supported using the optimizing hp linker.  */
  if (fixp->fx_addsy
      && fixp->fx_subsy
      && (hppa_fix->segment->flags & SEC_CODE))
    return 0;

  /* We can't adjust any relocs that use LR% and RR% field selectors.

     If a symbol is reduced to a section symbol, the assembler will
     adjust the addend unless the symbol happens to reside right at
     the start of the section.  Additionally, the linker has no choice
     but to manipulate the addends when coalescing input sections for
     "ld -r".  Since an LR% field selector is defined to round the
     addend, we can't change the addend without risking that a LR% and
     it's corresponding (possible multiple) RR% field will no longer
     sum to the right value.

     eg. Suppose we have
     .		ldil	LR%foo+0,%r21
     .		ldw	RR%foo+0(%r21),%r26
     .		ldw	RR%foo+4(%r21),%r25

     If foo is at address 4092 (decimal) in section `sect', then after
     reducing to the section symbol we get
     .			LR%sect+4092 == (L%sect)+0
     .			RR%sect+4092 == (R%sect)+4092
     .			RR%sect+4096 == (R%sect)-4096
     and the last address loses because rounding the addend to 8k
     multiples takes us up to 8192 with an offset of -4096.

     In cases where the LR% expression is identical to the RR% one we
     will never have a problem, but is so happens that gcc rounds
     addends involved in LR% field selectors to work around a HP
     linker bug.  ie. We often have addresses like the last case
     above where the LR% expression is offset from the RR% one.  */

  if (hppa_fix->fx_r_field == e_lrsel
      || hppa_fix->fx_r_field == e_rrsel
      || hppa_fix->fx_r_field == e_nlrsel)
    return 0;

  /* Reject reductions of symbols in DLT relative relocs,
     relocations with plabels.  */
  if (hppa_fix->fx_r_field == e_tsel
      || hppa_fix->fx_r_field == e_ltsel
      || hppa_fix->fx_r_field == e_rtsel
      || hppa_fix->fx_r_field == e_psel
      || hppa_fix->fx_r_field == e_rpsel
      || hppa_fix->fx_r_field == e_lpsel)
    return 0;

  /* Reject absolute calls (jumps).  */
  if (hppa_fix->fx_r_type == R_HPPA_ABS_CALL)
    return 0;

  /* Reject reductions of function symbols.  */
  if (fixp->fx_addsy != 0 && S_IS_FUNCTION (fixp->fx_addsy))
    return 0;

  return 1;
}

/* Return nonzero if the fixup in FIXP will require a relocation,
   even it if appears that the fixup could be completely handled
   within GAS.  */

int
hppa_force_relocation (struct fix *fixp)
{
  struct hppa_fix_struct *hppa_fixp;

  hppa_fixp = (struct hppa_fix_struct *) fixp->tc_fix_data;
#ifdef OBJ_SOM
  if (fixp->fx_r_type == (int) R_HPPA_ENTRY
      || fixp->fx_r_type == (int) R_HPPA_EXIT
      || fixp->fx_r_type == (int) R_HPPA_BEGIN_BRTAB
      || fixp->fx_r_type == (int) R_HPPA_END_BRTAB
      || fixp->fx_r_type == (int) R_HPPA_BEGIN_TRY
      || fixp->fx_r_type == (int) R_HPPA_END_TRY
      || (fixp->fx_addsy != NULL && fixp->fx_subsy != NULL
	  && (hppa_fixp->segment->flags & SEC_CODE) != 0))
    return 1;
#endif
#ifdef OBJ_ELF
  if (fixp->fx_r_type == (int) R_PARISC_GNU_VTINHERIT
      || fixp->fx_r_type == (int) R_PARISC_GNU_VTENTRY)
    return 1;
#endif

  gas_assert (fixp->fx_addsy != NULL);

  /* Ensure we emit a relocation for global symbols so that dynamic
     linking works.  */
  if (S_FORCE_RELOC (fixp->fx_addsy, 1))
    return 1;

  /* It is necessary to force PC-relative calls/jumps to have a relocation
     entry if they're going to need either an argument relocation or long
     call stub.  */
  if (fixp->fx_pcrel
      && arg_reloc_stub_needed (symbol_arg_reloc_info (fixp->fx_addsy),
				hppa_fixp->fx_arg_reloc))
    return 1;

  /* Now check to see if we're going to need a long-branch stub.  */
  if (fixp->fx_r_type == (int) R_HPPA_PCREL_CALL)
    {
      long pc = md_pcrel_from (fixp);
      valueT distance, min_stub_distance;

      distance = fixp->fx_offset + S_GET_VALUE (fixp->fx_addsy) - pc - 8;

      /* Distance to the closest possible stub.  This will detect most
	 but not all circumstances where a stub will not work.  */
      min_stub_distance = pc + 16;
#ifdef OBJ_SOM
      if (last_call_info != NULL)
	min_stub_distance -= S_GET_VALUE (last_call_info->start_symbol);
#endif

      if ((distance + 8388608 >= 16777216
	   && min_stub_distance <= 8388608)
	  || (hppa_fixp->fx_r_format == 17
	      && distance + 262144 >= 524288
	      && min_stub_distance <= 262144)
	  || (hppa_fixp->fx_r_format == 12
	      && distance + 8192 >= 16384
	      && min_stub_distance <= 8192)
	  )
	return 1;
    }

  if (fixp->fx_r_type == (int) R_HPPA_ABS_CALL)
    return 1;

  /* No need (yet) to force another relocations to be emitted.  */
  return 0;
}

/* Now for some ELF specific code.  FIXME.  */
#ifdef OBJ_ELF
/* For ELF, this function serves one purpose:  to setup the st_size
   field of STT_FUNC symbols.  To do this, we need to scan the
   call_info structure list, determining st_size in by taking the
   difference in the address of the beginning/end marker symbols.  */

void
elf_hppa_final_processing (void)
{
  struct call_info *call_info_pointer;

  for (call_info_pointer = call_info_root;
       call_info_pointer;
       call_info_pointer = call_info_pointer->ci_next)
    {
      elf_symbol_type *esym
	= ((elf_symbol_type *)
	   symbol_get_bfdsym (call_info_pointer->start_symbol));
      esym->internal_elf_sym.st_size =
	S_GET_VALUE (call_info_pointer->end_symbol)
	- S_GET_VALUE (call_info_pointer->start_symbol) + 4;
    }
}

static void
pa_vtable_entry (int ignore ATTRIBUTE_UNUSED)
{
  struct fix *new_fix;

  new_fix = obj_elf_vtable_entry (0);

  if (new_fix)
    {
      struct hppa_fix_struct * hppa_fix = obstack_alloc (&notes, sizeof (struct hppa_fix_struct));

      hppa_fix->fx_r_type = R_HPPA;
      hppa_fix->fx_r_field = e_fsel;
      hppa_fix->fx_r_format = 32;
      hppa_fix->fx_arg_reloc = 0;
      hppa_fix->segment = now_seg;
      new_fix->tc_fix_data = (void *) hppa_fix;
      new_fix->fx_r_type = (int) R_PARISC_GNU_VTENTRY;
    }
}

static void
pa_vtable_inherit (int ignore ATTRIBUTE_UNUSED)
{
  struct fix *new_fix;

  new_fix = obj_elf_vtable_inherit (0);

  if (new_fix)
    {
      struct hppa_fix_struct * hppa_fix = obstack_alloc (&notes, sizeof (struct hppa_fix_struct));

      hppa_fix->fx_r_type = R_HPPA;
      hppa_fix->fx_r_field = e_fsel;
      hppa_fix->fx_r_format = 32;
      hppa_fix->fx_arg_reloc = 0;
      hppa_fix->segment = now_seg;
      new_fix->tc_fix_data = (void *) hppa_fix;
      new_fix->fx_r_type = (int) R_PARISC_GNU_VTINHERIT;
    }
}
#endif

/* Table of pseudo ops for the PA.  FIXME -- how many of these
   are now redundant with the overall GAS and the object file
   dependent tables?  */
const pseudo_typeS md_pseudo_table[] =
{
  /* align pseudo-ops on the PA specify the actual alignment requested,
     not the log2 of the requested alignment.  */
#ifdef OBJ_SOM
  {"align", pa_align, 8},
#endif
#ifdef OBJ_ELF
  {"align", s_align_bytes, 8},
#endif
  {"begin_brtab", pa_brtab, 1},
  {"begin_try", pa_try, 1},
  {"block", pa_block, 1},
  {"blockz", pa_block, 0},
  {"byte", pa_cons, 1},
  {"call", pa_call, 0},
  {"callinfo", pa_callinfo, 0},
#if defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD))
  {"code", obj_elf_text, 0},
#else
  {"code", pa_text, 0},
  {"comm", pa_comm, 0},
#endif
#ifdef OBJ_SOM
  {"compiler", pa_compiler, 0},
#endif
  {"copyright", pa_copyright, 0},
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
  {"data", pa_data, 0},
#endif
  {"double", pa_float_cons, 'd'},
  {"dword", pa_cons, 8},
  {"end", pa_end, 0},
  {"end_brtab", pa_brtab, 0},
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
  {"end_try", pa_try, 0},
#endif
  {"enter", pa_enter, 0},
  {"entry", pa_entry, 0},
  {"equ", pa_equ, 0},
  {"exit", pa_exit, 0},
  {"export", pa_export, 0},
  {"fill", pa_fill, 0},
  {"float", pa_float_cons, 'f'},
  {"half", pa_cons, 2},
  {"import", pa_import, 0},
  {"int", pa_cons, 4},
  {"label", pa_label, 0},
  {"lcomm", pa_lcomm, 0},
  {"leave", pa_leave, 0},
  {"level", pa_level, 0},
  {"long", pa_cons, 4},
  {"lsym", pa_lsym, 0},
#ifdef OBJ_SOM
  {"nsubspa", pa_subspace, 1},
#endif
  {"octa", pa_cons, 16},
  {"org", pa_origin, 0},
  {"origin", pa_origin, 0},
  {"param", pa_param, 0},
  {"proc", pa_proc, 0},
  {"procend", pa_procend, 0},
  {"quad", pa_cons, 8},
  {"reg", pa_equ, 1},
  {"short", pa_cons, 2},
  {"single", pa_float_cons, 'f'},
#ifdef OBJ_SOM
  {"space", pa_space, 0},
  {"spnum", pa_spnum, 0},
#endif
  {"string", pa_stringer, 0},
  {"stringz", pa_stringer, 1},
#ifdef OBJ_SOM
  {"subspa", pa_subspace, 0},
#endif
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
  {"text", pa_text, 0},
#endif
  {"version", pa_version, 0},
#ifdef OBJ_ELF
  {"vtable_entry", pa_vtable_entry, 0},
  {"vtable_inherit", pa_vtable_inherit, 0},
#endif
  {"word", pa_cons, 4},
  {NULL, 0, 0}
};

#ifdef OBJ_ELF
void
hppa_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (30, 0);
}

int
hppa_regname_to_dw2regnum (char *regname)
{
  unsigned int regnum = -1;
  unsigned int i;
  const char *p;
  char *q;
  static struct { char *name; int dw2regnum; } regnames[] =
    {
      { "sp", 30 }, { "rp", 2 },
    };

  for (i = 0; i < ARRAY_SIZE (regnames); ++i)
    if (strcmp (regnames[i].name, regname) == 0)
      return regnames[i].dw2regnum;

  if (regname[0] == 'r')
    {
      p = regname + 1;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 32)
	return -1;
    }
  else if (regname[0] == 'f' && regname[1] == 'r')
    {
      p = regname + 2;
      regnum = strtoul (p, &q, 10);
#if TARGET_ARCH_SIZE == 64
      if (p == q || *q || regnum <= 4 || regnum >= 32)
	return -1;
      regnum += 32 - 4;
#else
      if (p == q
	  || (*q  && ((*q != 'L' && *q != 'R') || *(q + 1)))
	  || regnum <= 4 || regnum >= 32)
	return -1;
      regnum = (regnum - 4) * 2 + 32;
      if (*q == 'R')
	regnum++;
#endif
    }
  return regnum;
}
#endif
@


1.154
log
@	* config/tc-hppa.c (pa_ip): Reject double floating point stores and
	loads that reference the right half of a floating point register.
@
text
@d2555 11
a2565 1
  /* This is not perfect, but is a huge improvement over doing nothing.
d2567 9
a2575 3
     The PA assembly syntax is ambiguous in a variety of ways.  Consider
     this string "4 %r5"  Is that the number 4 followed by the register
     r5, or is that 4 MOD r5?
d2577 2
a2578 5
     If we get a modulo expression when looking for an absolute, we try
     again cutting off the input string at the first whitespace character.  */
  if (insn->exp.X_op == O_modulus)
    {
      char *s, c;
d2580 14
a2593 4
      input_line_pointer = *strp;
      s = *strp;
      while (*s != ',' && *s != ' ' && *s != '\t')
	s++;
d2595 2
a2596 2
      c = *s;
      *s = 0;
d2598 1
a2598 1
      pa_get_absolute_expression (insn, strp);
a2599 20
      input_line_pointer = save_in;
      *s = c;
      return evaluate_absolute (insn);
    }
  /* When in strict mode we have a non-match, fix up the pointers
     and return to our caller.  */
  if (insn->exp.X_op != O_constant && strict)
    {
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 0;
    }
  if (insn->exp.X_op != O_constant)
    {
      as_bad (_("Bad segment (should be absolute)."));
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 0;
    }
  expr_end = input_line_pointer;
d2601 2
a2602 1
  return evaluate_absolute (insn);
d5299 1
a5299 1
	      num = pa_get_absolute_expression (&the_insn, &s);
d5308 1
a5308 1
	      num = pa_get_absolute_expression (&the_insn, &s);
d5318 1
a5318 1
	      num = pa_get_absolute_expression (&the_insn, &s);
d5327 1
a5327 1
	      num = pa_get_absolute_expression (&the_insn, &s);
d5337 1
a5337 1
	      num = pa_get_absolute_expression (&the_insn, &s);
d5349 1
a5349 1
	      num = pa_get_absolute_expression (&the_insn, &s);
d5358 1
a5358 1
	      num = pa_get_absolute_expression (&the_insn, &s);
@


1.153
log
@	* config/tc-hppa.c (pa_ip): Limit unit conditions for uxor to those
	not involving a carry.
@
text
@d5485 4
a5488 1
		  num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
@


1.152
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d4434 1
d4448 3
d4461 1
a4461 1
			else if (strncasecmp (s, "sdc", 3) == 0)
d4466 1
a4466 1
			else if (strncasecmp (s, "sbc", 3) == 0)
d4471 1
a4471 1
			else if (strncasecmp (s, "shc", 3) == 0)
d4494 1
a4494 1
			else if (strncasecmp (s, "ndc", 3) == 0)
d4500 1
a4500 1
			else if (strncasecmp (s, "nbc", 3) == 0)
d4506 1
a4506 1
			else if (strncasecmp (s, "nhc", 3) == 0)
d4518 1
a4518 1
			else if (strncasecmp (s, "swc", 3) == 0)
d4530 1
a4530 1
			else if (strncasecmp (s, "nwc", 3) == 0)
@


1.151
log
@	PR gas/11395
	* config/tc-hppa.c (pa_ip): Revert last change.  Add variable need_cond
	to determine whether a 64-bit condition is needed for 'A' and 'S'
	conditions.  Default to 32-bit never condition for logical and unit
	instructions.  Add error message for missing branch on bit condition.

	* hppa.h (pa_opcodes): Revert last change.  Exchange 32 and 64-bit
	"bb" entries.

	* hppa-dis.c (compare_cond_64_names): Change never condition to ",*".
	(add_cond_64_names): Likewise.
	(logical_cond_64_names): Likewise.
	(unit_cond_64_names): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d2210 1
a2210 1
	  else if (S_GET_SEGMENT (sym) == &bfd_abs_section)
@


1.150
log
@	PR gas/11395
	* config/tc-hppa.c (pa_ip): Set doubleword carry/borrow bit when a
	doubleword completer or doubleword condition is found in an add/sub
	instruction.  Reject match for 'A'/'S' only if there is no condition
	and d bit is not set.

	* gas/hppa/basic/add2.s: Add test for a simple doubleword carry
	instruction.
	* gas/hppa/basic/sub2.s: Add tests for simple word and doubleword
	borrow instructions.
	* gas/hppa/basic/basic.exp: Update regexps for above.

	* opcode/hppa.h: Clear "d" bit in "add" and "sub" patterns.
@
text
@d3207 1
a3207 1
  int cmpltr, nullif, flag, cond, num;
d3267 1
d3762 2
a3763 2
		  /* Set doubleword carry bit.  */
		  opcode |= 0x20;
d3832 2
a3833 2
		  /* Set doubleword borrow bit.  */
		  opcode |= 0x20;
a3976 8
		    /* PR gas/11395
		       If we don't have a ",*" condition or "dc" completer,
		       then we have a doubleword carry match failure.  */
		    if (*s != ',' && !(opcode & 0x20))
		      break;
		    opcode |= 0x20;
		    /* Fall through.  */

d4059 5
d4143 1
a4143 1
			  as_bad (_("Invalid Bit Branch Condition: %c"), *s);
d4145 3
a4151 8
		    /* PR gas/11395
		       If we don't have a ",*" condition or "dc" completer,
		       then we have a doubleword carry match failure.  */
		    if (*s != ',' && !(opcode & 0x20))
		      break;
		    opcode |= 0x20;
		    /* Fall through.  */

d4235 5
d4298 1
a4298 1
		    /* Handle a logical instruction condition.  */
d4362 4
d4424 1
d4536 4
@


1.149
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d3761 2
d3831 2
d3977 3
a3979 3
		       If we are looking for 64-bit add conditions and we
		       do not have the ",*" prefix, then we have no match.  */
		    if (*s != ',')
d3981 1
d3983 1
d4151 8
@


1.149.2.1
log
@	Backport from mainline:
	2010-12-26  John David Anglin  <dave.anglin@@nrc-cnrc.gc.ca>

	PR gas/11395
	* config/tc-hppa.c (pa_ip): Set doubleword carry/borrow bit when a
	doubleword completer or doubleword condition is found in an add/sub
	instruction.  Reject match for 'A'/'S' only if there is no condition
	and d bit is not set.
@
text
@d3207 1
a3207 1
  int cmpltr, nullif, flag, cond, need_cond, num;
a3266 1
      need_cond = 1;
a3760 2
		  /* Condition is not required with "dc".  */
		  need_cond = 0;
a3828 2
		  /* Condition is not required with "db".  */
		  need_cond = 0;
d3972 6
a4059 5
		    /* Except with "dc", we have a match failure with
		       'A' if we don't have a doubleword condition.  */
		    else if (*args == 'A' && need_cond)
		      break;

d4139 1
a4139 1
			  as_bad (_("Invalid Branch On Bit Condition: %c"), *s);
a4140 3
		    else
		      as_bad (_("Missing Branch On Bit Condition"));

a4227 5
		    /* Except with "db", we have a match failure with
		       'S' if we don't have a doubleword condition.  */
		    else if (*args == 'S' && need_cond)
		      break;

d4286 1
a4286 1
		  /* Handle a logical instruction condition.  */
a4349 4
		    /* 32-bit is default for no condition.  */
		    else if (*args == 'L')
		      break;

a4407 1

a4518 4
		    /* 32-bit is default for no condition.  */
		    else if (*args == 'U')
		      break;

@


1.148
log
@        PR gas/11395
        * config/tc-hppa.c (pa_ip): Do not allow 64-bit add condition
        matcher to accept and unconditional 32-bit add instruction.
        (pa_build_unwind_subspace): Cope with error conditions not
        allowing the start symbol to be set.

        * gas/hppa/basic/add2.s: Add test of simple 32-bit instruction.
        * gas/hppa/basic/basic.exp (do_add2): Add grep for expected
        disassembly.
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d1405 2
a1406 1
  if (fixp->fx_r_type == R_HPPA_COMPLEX && fixp->fx_pcrel)
a2565 1
      int retval;
d2575 1
a2575 1
      retval = pa_get_absolute_expression (insn, strp);
d6506 1
d6648 2
d6672 2
d6688 2
@


1.147
log
@2009-12-18  Steve Ellcey  <sje@@cup.hp.com>

	* config/tc-hppa.c: Change access to access_ctr.
@
text
@d3971 6
d5978 4
@


1.146
log
@	* config/tc-hppa.c (pa_build_unwind_subspace): Replace start symbol
	with local symbol.
@
text
@d7372 1
a7372 1
  int i, access, space_index, alignment, quadrant, applicable, flags;
d7395 1
a7395 1
      access = 0x7f;
d7440 1
a7440 1
		  access = pa_def_subspaces[i].access;
d7478 1
a7478 1
		  access = get_absolute_expression ();
d7586 1
a7586 1
					    dup_common, sort, zero, access,
d7593 1
a7593 1
						access, space_index,
d7824 1
a7824 1
		     int access,
d7879 1
a7879 1
  obj_set_subsection_attributes (seg, space->sd_seg, access, sort,
d7899 1
a7899 1
		 int access,
d7910 1
a7910 1
  obj_set_subsection_attributes (section, space->sd_seg, access, sort,
@


1.145
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d5964 2
a5965 1
  char *p;
d5972 27
d6024 1
a6024 1
		call_info->start_symbol, (offsetT) 0,
@


1.144
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3250 1
a3250 1
      as_bad ("Unknown opcode: `%s'", str);
@


1.143
log
@	* gas/config/tc-hppa.c (pa_ip): Add check of immediate values.
	(SAVE_IMMEDIATE): New define.
@
text
@d1391 2
a1392 2
  assert (hppa_fixp != 0);
  assert (section != 0);
d1437 1
a1437 1
      assert (n_relocs == 1);
d1491 1
a1491 1
      assert (reloc->howto && (unsigned int) code == reloc->howto->type);
d1514 1
a1514 1
	  assert (i == 1);
d5731 1
a5731 1
  assert (str);
d6436 1
a6436 1
	  assert (symbolP);
d8468 1
a8468 1
  assert (fixp->fx_addsy != NULL);
@


1.142
log
@	* config/tc-hppa.c (hppa_regname_to_dw2regnum): Add register name to
	number support for 32-bit targets.
@
text
@d2 2
a3 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d998 13
d3207 1
d3368 1
d4351 3
d5146 1
d5156 1
d5169 1
d5182 1
d5195 1
d5205 1
d5713 7
@


1.141
log
@	* elf-hppa.h (elf_hppa_reloc_final_type): Handle R_PARISC_GPREL64,
	R_PARISC_SEGREL32 and R_PARISC_SEGREL64.
	* som.c (som_fixup_formats): Add R_DATA_GPREL fixup.
	(som_hppa_howto_table): Likewise.
	(hppa_som_gen_reloc_type): In case R_HPPA_GOTOFF, detect R_DATA_GPREL
	final type.
	(som_write_fixups): Handle R_DATA_GPREL.

	* config/tc-hppa.c (is_SB_relative): New macro.
	(fix_new_hppa): Remove $segrel$ marker.
	(cons_fix_new_hppa): Set reloc type R_PARISC_SEGREL32 if expression is
	segment relative.
	* config/tc-hppa.h (tc_frob_symbol): Check for $segrel$.
@
text
@d8679 1
d8683 9
@


1.140
log
@	* config/tc-hppa.c (md_begin): Set BSF_KEEP for "dummy_symbol".
@
text
@d1053 4
d1240 1
d1264 2
@


1.139
log
@        * dw2gencfi.c (DWARF2_FDE_RELOC_SIZE): New.
        (output_cie, output_fde): Use it.
        (DWARF2_EH_FRAME_READ_ONLY): New.
        (cfi_finish): Use it.

        * config/tc-hppa.h (DWARF2_FDE_RELOC_SIZE): Set to 8 for 64-bit.
        (DWARF2_CIE_DATA_ALIGNMENT): Change sign.
        (DWARF2_EH_FRAME_READ_ONLY): New.
        * config/tc-hppa.c (tc_gen_reloc): Generate pc-relative relocations
        from the results of DIFF_EXPR_OK manipulation.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d951 2
a952 2
#define GDB_SYMBOLS          GDB_SYMBOLS_SUBSPACE_NAME
#define GDB_STRINGS          GDB_STRINGS_SUBSPACE_NAME
d1015 1
a1015 1
          as_bad (_("Field out of range [%d..%d] (%d)."), (LOW), (HIGH), \
d1017 1
a1017 1
        break; \
d1028 1
a1028 1
        as_bad_where ((FILENAME), (LINE), \
d1031 1
a1031 1
        break; \
d1043 1
a1043 1
          as_bad (_("Field not properly aligned [%d] (%d)."), (ALIGN), \
d1045 1
a1045 1
        break; \
d1961 1
a1961 1
        if (fixP->fx_addsy)
d2114 2
a2115 2
         code makes a binary search with case translation, and is VERY
         slow.  */
d2170 1
a2170 1
         is effectively a constant, or a register alias symbol.  */
d2681 1
a2681 1
         completer.  */
d2755 1
a2755 1
         completer.  */
d2981 1
a2981 1
         completer.  */
d3054 1
a3054 1
         completer.  */
d3155 1
a3155 1
         completer.  */
d3253 1
a3253 1
         sure that the operands match.  */
d3304 1
a3304 1
	        {
d3309 1
a3309 1
	        {
d3513 1
a3513 1
		        /* M bit is explicit in the major opcode.  */
d3905 1
a3905 1
		        {
d5080 1
a5080 1
	        break;
d5417 1
a5417 1
	        {
d5545 2
a5546 2
		        if (num < 16)
		          {
d5549 3
a5551 3
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
d5565 2
a5566 2
		        if (num < 16)
		          {
d5569 3
a5571 3
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
d5585 2
a5586 2
		        if (num < 16)
		          {
d5589 3
a5591 3
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
d5605 2
a5606 2
		        if (num < 16)
		          {
d5609 3
a5611 3
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
d6094 1
a6094 1
         in the unwind descriptor.  */
d6102 1
a6102 1
         unwind descriptor.  */
d6205 2
a6206 2
         current subspace; we need to reset the fragment to the zero address
         fragment.  We also need to reset the segment pointer.  */
d6499 1
a6499 1
         instead one should be IMPORTing/EXPORTing ENTRY types.
d6501 3
a6503 3
         Complain if one tries to EXPORT a CODE type since that's never
         done.  Both GCC and HP C still try to IMPORT CODE types, so
         silently fix them to be ENTRY types.  */
d6656 4
a6659 4
         For the HP, weak and global are not mutually exclusive.
         S_SET_EXTERNAL will not set BSF_GLOBAL if WEAK is set.
         Call S_SET_EXTERNAL to get the other processing.  Manually
         set BSF_GLOBAL when we get back.  */
d7070 2
a7071 2
         as a name.  According to the PA assembly manual the rest of
         the line should be ignored.  */
d7167 2
a7168 2
         below is repeated several times, can we extract the common parts
         and place them into a subroutine or something similar?  */
d7346 1
a7346 1
         only allow the attributes to be changed once!  */
d7383 1
a7383 1
         any information as specified by the user.  */
d7460 1
a7460 1
         in the .subspace directive.  */
d7488 1
a7488 1
         segment already associated with the subspace.
d7490 4
a7493 4
         FIXME NOW!  ELF BFD doesn't appear to be ready to deal with
         lots of sections.  It might be a problem in the PA ELF
         code, I do not know yet.  For now avoid creating anything
         but the "standard" sections for ELF.  */
d7515 1
a7515 1
         or create a new one.  */
d7572 1
a7572 1
         subsegment number.  */
d7580 1
a7580 1
         sections with our own.   We also want to set BFD flags for
d7715 1
a7715 1
         entry.  So add it and update the linked lists as appropriate.  */
d7799 1
a7799 1
         the links.  */
d8261 1
a8261 1
  (void) symbol_get_bfdsym (dummy_symbol);
@


1.138
log
@	PR 5946
	* config/tc-hppa.c (is_same_frag): Delete.
@
text
@d1378 12
@


1.137
log
@
gas/

2007-10-18  Carlos O'Donell  <carlos@@systemhalted.org>

	* config/tc-hppa.c (pa_ip): Fix comment typo.
	(pa_comm): Likewise.
@
text
@a5900 18
/* Return TRUE if FRAG1 and FRAG2 are the same.  */

static bfd_boolean
is_same_frag (fragS *frag1, fragS *frag2)
{

  if (frag1 == NULL)
    return FALSE;
  else if (frag2 == NULL)
    return FALSE;
  else if (frag1 == frag2)
    return TRUE;
  else if (frag2->fr_type == rs_fill && frag2->fr_fix == 0)
    return (is_same_frag (frag1, frag2->fr_next));
  else
    return FALSE;
}

@


1.136
log
@Remove duplicate definitions of the md_atof() function
@
text
@d3214 1
a3214 1
  /* Look up the opcode in the has table.  */
d6169 1
a6169 1
   the .comm pseudo-op has the following symtax:
@


1.135
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@d586 2
a587 2
   changed in read.c.  Ideally it shouldn't hae to know abou it at
   all, but nothing is ideal around here.  */
a1337 6
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message or NULL is returned.  */

#define MAX_LITTLENUMS 6

d1341 1
a1341 46
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {

    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return NULL;
@


1.134
log
@Switch to GPLv3
@
text
@d8153 1
a8153 1
  stringer (append_zero);
@


1.133
log
@2006-10-29  Randolph Chung  <tausq@@debian.org>

	* config/tc-hppa.c (hppa_cfi_frame_initial_instructions)
	(hppa_regname_to_dw2regnum): New funcions.
	* config/tc-hppa.h [OBJ_ELF] (TARGET_USE_CFIPOP): Define.
	(tc_cfi_frame_initial_instructions)
	(tc_regname_to_dw2regnum): Define.
	(hppa_cfi_frame_initial_instructions)
	(hppa_regname_to_dw2regnum): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH, DWARF2_DEFAULT_RETURN_COLUMN)
	(DWARF2_CIE_DATA_ALIGNMENT): Define.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.132
log
@remove some duplicate #include's.
@
text
@d28 1
d8694 42
@


1.131
log
@Add TLS support for hppa-linux
@
text
@a24 2
#include <stdio.h>

@


1.130
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d493 1
a493 1
static void pa_check_current_space_and_subspace PARAMS ((void));
d497 12
a508 60
static void pa_text PARAMS ((int));
static void pa_data PARAMS ((int));
static void pa_comm PARAMS ((int));
#endif
static fp_operand_format pa_parse_fp_format PARAMS ((char **s));
static void pa_cons PARAMS ((int));
static void pa_float_cons PARAMS ((int));
static void pa_fill PARAMS ((int));
static void pa_lcomm PARAMS ((int));
static void pa_lsym PARAMS ((int));
static void pa_stringer PARAMS ((int));
static void pa_version PARAMS ((int));
static int pa_parse_fp_cmp_cond PARAMS ((char **));
static int get_expression PARAMS ((char *));
static int pa_get_absolute_expression PARAMS ((struct pa_it *, char **));
static int evaluate_absolute PARAMS ((struct pa_it *));
static unsigned int pa_build_arg_reloc PARAMS ((char *));
static unsigned int pa_align_arg_reloc PARAMS ((unsigned int, unsigned int));
static int pa_parse_nullif PARAMS ((char **));
static int pa_parse_nonneg_cmpsub_cmpltr PARAMS ((char **));
static int pa_parse_neg_cmpsub_cmpltr PARAMS ((char **));
static int pa_parse_neg_add_cmpltr PARAMS ((char **));
static int pa_parse_nonneg_add_cmpltr PARAMS ((char **));
static int pa_parse_cmpb_64_cmpltr PARAMS ((char **));
static int pa_parse_cmpib_64_cmpltr PARAMS ((char **));
static int pa_parse_addb_64_cmpltr PARAMS ((char **));
static void pa_block PARAMS ((int));
static void pa_brtab PARAMS ((int));
static void pa_try PARAMS ((int));
static void pa_call PARAMS ((int));
static void pa_call_args PARAMS ((struct call_desc *));
static void pa_callinfo PARAMS ((int));
static void pa_copyright PARAMS ((int));
static void pa_end PARAMS ((int));
static void pa_enter PARAMS ((int));
static void pa_entry PARAMS ((int));
static void pa_equ PARAMS ((int));
static void pa_exit PARAMS ((int));
static void pa_export PARAMS ((int));
static void pa_type_args PARAMS ((symbolS *, int));
static void pa_import PARAMS ((int));
static void pa_label PARAMS ((int));
static void pa_leave PARAMS ((int));
static void pa_level PARAMS ((int));
static void pa_origin PARAMS ((int));
static void pa_proc PARAMS ((int));
static void pa_procend PARAMS ((int));
static void pa_param PARAMS ((int));
static void pa_undefine_label PARAMS ((void));
static int need_pa11_opcode PARAMS ((void));
static int pa_parse_number PARAMS ((char **, int));
static label_symbol_struct *pa_get_label PARAMS ((void));
#ifdef OBJ_SOM
static int exact_log2 PARAMS ((int));
static void pa_compiler PARAMS ((int));
static void pa_align PARAMS ((int));
static void pa_space PARAMS ((int));
static void pa_spnum PARAMS ((int));
static void pa_subspace PARAMS ((int));
static sd_chain_struct *create_new_space PARAMS ((char *, int, int,
d510 2
a511 2
						  asection *, int));
static ssd_chain_struct *create_new_subspace PARAMS ((sd_chain_struct *,
d515 2
a516 2
						      int, asection *));
static ssd_chain_struct *update_subspace PARAMS ((sd_chain_struct *,
d520 9
a528 31
						  asection *));
static sd_chain_struct *is_defined_space PARAMS ((char *));
static ssd_chain_struct *is_defined_subspace PARAMS ((char *));
static sd_chain_struct *pa_segment_to_space PARAMS ((asection *));
static ssd_chain_struct *pa_subsegment_to_subspace PARAMS ((asection *,
							    subsegT));
static sd_chain_struct *pa_find_space_by_number PARAMS ((int));
static unsigned int pa_subspace_start PARAMS ((sd_chain_struct *, int));
static sd_chain_struct *pa_parse_space_stmt PARAMS ((char *, int));
static void pa_spaces_begin PARAMS ((void));
#endif
static void pa_ip PARAMS ((char *));
static void fix_new_hppa PARAMS ((fragS *, int, int, symbolS *,
				  offsetT, expressionS *, int,
				  bfd_reloc_code_real_type,
				  enum hppa_reloc_field_selector_type_alt,
				  int, unsigned int, int));
static int is_end_of_statement PARAMS ((void));
static int reg_name_search PARAMS ((char *));
static int pa_chk_field_selector PARAMS ((char **));
static int is_same_frag PARAMS ((fragS *, fragS *));
static void process_exit PARAMS ((void));
static unsigned int pa_stringer_aux PARAMS ((char *));
static fp_operand_format pa_parse_fp_cnv_format PARAMS ((char **s));
static int pa_parse_ftest_gfx_completer PARAMS ((char **));

#ifdef OBJ_ELF
static void hppa_elf_mark_end_of_function PARAMS ((void));
static void pa_build_unwind_subspace PARAMS ((struct call_info *));
static void pa_vtable_entry PARAMS ((int));
static void pa_vtable_inherit  PARAMS ((int));
a561 90
/* Table of pseudo ops for the PA.  FIXME -- how many of these
   are now redundant with the overall GAS and the object file
   dependent tables?  */
const pseudo_typeS md_pseudo_table[] =
{
  /* align pseudo-ops on the PA specify the actual alignment requested,
     not the log2 of the requested alignment.  */
#ifdef OBJ_SOM
  {"align", pa_align, 8},
#endif
#ifdef OBJ_ELF
  {"align", s_align_bytes, 8},
#endif
  {"begin_brtab", pa_brtab, 1},
  {"begin_try", pa_try, 1},
  {"block", pa_block, 1},
  {"blockz", pa_block, 0},
  {"byte", pa_cons, 1},
  {"call", pa_call, 0},
  {"callinfo", pa_callinfo, 0},
#if defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD))
  {"code", obj_elf_text, 0},
#else
  {"code", pa_text, 0},
  {"comm", pa_comm, 0},
#endif
#ifdef OBJ_SOM
  {"compiler", pa_compiler, 0},
#endif
  {"copyright", pa_copyright, 0},
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
  {"data", pa_data, 0},
#endif
  {"double", pa_float_cons, 'd'},
  {"dword", pa_cons, 8},
  {"end", pa_end, 0},
  {"end_brtab", pa_brtab, 0},
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
  {"end_try", pa_try, 0},
#endif
  {"enter", pa_enter, 0},
  {"entry", pa_entry, 0},
  {"equ", pa_equ, 0},
  {"exit", pa_exit, 0},
  {"export", pa_export, 0},
  {"fill", pa_fill, 0},
  {"float", pa_float_cons, 'f'},
  {"half", pa_cons, 2},
  {"import", pa_import, 0},
  {"int", pa_cons, 4},
  {"label", pa_label, 0},
  {"lcomm", pa_lcomm, 0},
  {"leave", pa_leave, 0},
  {"level", pa_level, 0},
  {"long", pa_cons, 4},
  {"lsym", pa_lsym, 0},
#ifdef OBJ_SOM
  {"nsubspa", pa_subspace, 1},
#endif
  {"octa", pa_cons, 16},
  {"org", pa_origin, 0},
  {"origin", pa_origin, 0},
  {"param", pa_param, 0},
  {"proc", pa_proc, 0},
  {"procend", pa_procend, 0},
  {"quad", pa_cons, 8},
  {"reg", pa_equ, 1},
  {"short", pa_cons, 2},
  {"single", pa_float_cons, 'f'},
#ifdef OBJ_SOM
  {"space", pa_space, 0},
  {"spnum", pa_spnum, 0},
#endif
  {"string", pa_stringer, 0},
  {"stringz", pa_stringer, 1},
#ifdef OBJ_SOM
  {"subspa", pa_subspace, 0},
#endif
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
  {"text", pa_text, 0},
#endif
  {"version", pa_version, 0},
#ifdef OBJ_ELF
  {"vtable_entry", pa_vtable_entry, 0},
  {"vtable_inherit", pa_vtable_inherit, 0},
#endif
  {"word", pa_cons, 4},
  {NULL, 0, 0}
};

d1058 20
d1090 1
a1090 1
pa_check_eof ()
d1103 1
a1103 1
pa_get_label ()
d1128 1
a1128 2
pa_define_label (symbol)
     symbolS *symbol;
d1137 1
a1137 2
      label_chain
	= (label_symbol_struct *) xmalloc (sizeof (label_symbol_struct));
d1162 1
a1162 1
pa_undefine_label ()
d1201 12
a1212 14
fix_new_hppa (frag, where, size, add_symbol, offset, exp, pcrel,
	      r_type, r_field, r_format, arg_reloc, unwind_bits)
     fragS *frag;
     int where;
     int size;
     symbolS *add_symbol;
     offsetT offset;
     expressionS *exp;
     int pcrel;
     bfd_reloc_code_real_type r_type;
     enum hppa_reloc_field_selector_type_alt r_field;
     int r_format;
     unsigned int arg_reloc;
     int unwind_bits ATTRIBUTE_UNUSED;
d1215 1
a1215 3

  struct hppa_fix_struct *hppa_fix = (struct hppa_fix_struct *)
  obstack_alloc (&notes, sizeof (struct hppa_fix_struct));
d1237 6
a1242 1
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$PIC_pcrel$0") == 0))
a1245 11
/* Parse a .byte, .word, .long expression for the HPPA.  Called by
   cons via the TC_PARSE_CONS_EXPRESSION macro.  */

void
parse_cons_expression_hppa (exp)
     expressionS *exp;
{
  hppa_field_selector = pa_chk_field_selector (&input_line_pointer);
  expression (exp);
}

d1250 1
a1250 5
cons_fix_new_hppa (frag, where, size, exp)
     fragS *frag;
     int where;
     int size;
     expressionS *exp;
d1259 12
d1290 1
a1290 2
/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will need.  */
d1292 2
a1293 2
void
md_begin ()
d1295 2
a1296 3
  const char *retval = NULL;
  int lose = 0;
  unsigned int i = 0;
d1298 6
a1303 10
  last_call_info = NULL;
  call_info_root = NULL;

  /* Set the default machine type.  */
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, DEFAULT_LEVEL))
    as_warn (_("could not set architecture and machine"));

  /* Folding of text and data segments fails miserably on the PA.
     Warn user and disable "-R" option.  */
  if (flag_readonly_data_in_text)
d1305 4
a1308 2
      as_warn (_("-R option not supported on this target."));
      flag_readonly_data_in_text = 0;
d1310 3
d1314 2
a1315 3
#ifdef OBJ_SOM
  pa_spaces_begin ();
#endif
d1317 4
a1320 1
  op_hash = hash_new ();
d1322 2
a1323 1
  while (i < NUMOPCODES)
d1325 4
a1328 3
      const char *name = pa_opcodes[i].name;
      retval = hash_insert (op_hash, name, (struct pa_opcode *) &pa_opcodes[i]);
      if (retval != NULL && *retval != '\0')
d1330 2
a1331 2
	  as_fatal (_("Internal error: can't hash `%s': %s\n"), name, retval);
	  lose = 1;
d1333 1
a1333 12
      do
	{
	  if ((pa_opcodes[i].match & pa_opcodes[i].mask)
	      != pa_opcodes[i].match)
	    {
	      fprintf (stderr, _("internal error: losing opcode: `%s' \"%s\"\n"),
		       pa_opcodes[i].name, pa_opcodes[i].args);
	      lose = 1;
	    }
	  ++i;
	}
      while (i < NUMOPCODES && !strcmp (pa_opcodes[i].name, name));
d1336 2
a1337 2
  if (lose)
    as_fatal (_("Broken assembler.  No assembly attempted."));
d1339 3
a1341 5
#ifdef OBJ_SOM
  /* SOM will change text_section.  To make sure we never put
     anything into the old one switch to the new one now.  */
  subseg_set (text_section, 0);
#endif
d1343 1
a1343 7
#ifdef OBJ_SOM
  dummy_symbol = symbol_find_or_make ("L$dummy");
  S_SET_SEGMENT (dummy_symbol, text_section);
  /* Force the symbol to be converted to a real symbol.  */
  (void) symbol_get_bfdsym (dummy_symbol);
#endif
}
d1345 2
a1346 4
/* Assemble a single instruction storing it into a frag.  */
void
md_assemble (str)
     char *str;
d1348 14
a1361 1
  char *to;
d1363 6
a1368 2
  /* The had better be something to assemble.  */
  assert (str);
d1370 4
a1373 3
  /* If we are within a procedure definition, make sure we've
     defined a label for the procedure; handle case where the
     label was defined after the .PROC directive.
d1375 4
a1378 6
     Note there's not need to diddle with the segment or fragment
     for the label symbol in this case.  We have already switched
     into the new $CODE$ subspace at this point.  */
  if (within_procedure && last_call_info->start_symbol == NULL)
    {
      label_symbol_struct *label_symbol = pa_get_label ();
d1380 12
a1391 28
      if (label_symbol)
	{
	  if (label_symbol->lss_label)
	    {
	      last_call_info->start_symbol = label_symbol->lss_label;
	      symbol_get_bfdsym (label_symbol->lss_label)->flags
		|= BSF_FUNCTION;
#ifdef OBJ_SOM
	      /* Also handle allocation of a fixup to hold the unwind
		 information when the label appears after the proc/procend.  */
	      if (within_entry_exit)
		{
		  char *where;
		  unsigned int u;

		  where = frag_more (0);
		  u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
		  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
				NULL, (offsetT) 0, NULL,
				0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
		}
#endif
	    }
	  else
	    as_bad (_("Missing function name for .PROC (corrupted label chain)"));
	}
      else
	as_bad (_("Missing function name for .PROC"));
d1393 2
d1396 1
a1396 2
  /* Assemble the instruction.  Results are saved into "the_insn".  */
  pa_ip (str);
d1398 4
a1401 16
  /* Get somewhere to put the assembled instruction.  */
  to = frag_more (4);

  /* Output the opcode.  */
  md_number_to_chars (to, the_insn.opcode, 4);

  /* If necessary output more stuff.  */
  if (the_insn.reloc != R_HPPA_NONE)
    fix_new_hppa (frag_now, (to - frag_now->fr_literal), 4, NULL,
		  (offsetT) 0, &the_insn.exp, the_insn.pcrel,
		  the_insn.reloc, the_insn.field_selector,
		  the_insn.format, the_insn.arg_reloc, 0);

#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif
d1404 2
a1405 2
/* Do the real work for assembling a single instruction.  Store results
   into the global "the_insn" variable.  */
d1407 2
a1408 3
static void
pa_ip (str)
     char *str;
d1410 12
a1421 8
  char *error_message = "";
  char *s, c, *argstart, *name, *save_s;
  const char *args;
  int match = FALSE;
  int comma = 0;
  int cmpltr, nullif, flag, cond, num;
  unsigned long opcode;
  struct pa_opcode *insn;
d1423 2
a1424 4
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif
d1426 1
a1426 4
  /* Convert everything up to the first whitespace character into lower
     case.  */
  for (s = str; *s != ' ' && *s != '\t' && *s != '\n' && *s != '\0'; s++)
    *s = TOLOWER (*s);
d1428 8
a1435 5
  /* Skip to something interesting.  */
  for (s = str;
       ISUPPER (*s) || ISLOWER (*s) || (*s >= '0' && *s <= '3');
       ++s)
    ;
d1437 1
a1437 1
  switch (*s)
d1439 3
d1443 2
a1444 2
    case '\0':
      break;
d1446 4
a1449 2
    case ',':
      comma = 1;
d1451 1
a1451 5
      /*FALLTHROUGH */

    case ' ':
      *s++ = '\0';
      break;
d1453 3
d1457 1
a1457 3
      as_bad (_("Unknown opcode: `%s'"), str);
      return;
    }
d1459 1
a1459 6
  /* Look up the opcode in the has table.  */
  if ((insn = (struct pa_opcode *) hash_find (op_hash, str)) == NULL)
    {
      as_bad ("Unknown opcode: `%s'", str);
      return;
    }
d1461 13
a1473 4
  if (comma)
    {
      *--s = ',';
    }
d1475 5
a1479 9
  /* Mark the location where arguments for the instruction start, then
     start processing them.  */
  argstart = s;
  for (;;)
    {
      /* Do some initialization.  */
      opcode = insn->match;
      strict = (insn->flags & FLAG_STRICT);
      memset (&the_insn, 0, sizeof (the_insn));
d1481 12
a1492 1
      the_insn.reloc = R_HPPA_NONE;
d1494 5
a1498 3
      if (insn->arch >= pa20
	  && bfd_get_mach (stdoutput) < insn->arch)
	goto failed;
d1500 4
a1503 7
      /* Build the opcode, checking as we go to make
         sure that the operands match.  */
      for (args = insn->args;; ++args)
	{
	  /* Absorb white space in instruction.  */
	  while (*s == ' ' || *s == '\t')
	    s++;
d1505 5
a1509 2
	  switch (*args)
	    {
d1511 4
a1514 5
	    /* End of arguments.  */
	    case '\0':
	      if (*s == '\0')
		match = TRUE;
	      break;
d1516 4
a1519 9
	    case '+':
	      if (*s == '+')
		{
		  ++s;
		  continue;
		}
	      if (*s == '-')
		continue;
	      break;
d1521 6
a1526 8
	    /* These must match exactly.  */
	    case '(':
	    case ')':
	    case ',':
	    case ' ':
	      if (*s++ == *args)
		continue;
	      break;
d1528 89
a1616 8
	    /* Handle a 5 bit register or control register field at 10.  */
	    case 'b':
	    case '^':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);
d1618 4
a1621 6
	    /* Handle %sar or %cr11.  No bits get set, we just verify that it
	       is there.  */
	    case '!':
	      /* Skip whitespace before register.  */
	      while (*s == ' ' || *s == '\t')
		s = s + 1;
d1623 2
a1624 11
	      if (!strncasecmp (s, "%sar", 4))
	        {
		  s += 4;
		  continue;
		}
	      else if (!strncasecmp (s, "%cr11", 5))
	        {
		  s += 5;
		  continue;
		}
	      break;
d1626 2
a1627 7
	    /* Handle a 5 bit register field at 15.  */
	    case 'x':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);
d1629 1
a1629 7
	    /* Handle a 5 bit register field at 31.  */
	    case 't':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d1631 6
a1636 8
	    /* Handle a 5 bit register field at 10 and 15.  */
	    case 'a':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      opcode |= num << 16;
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);
d1638 22
a1659 8
	    /* Handle a 5 bit field length at 31.  */
	    case 'T':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 32, 1, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, 32 - num, 0);
d1661 1
a1661 11
	    /* Handle a 5 bit immediate at 15.  */
	    case '5':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      /* When in strict mode, we want to just reject this
		 match instead of giving an out of range error.  */
	      CHECK_FIELD (num, 15, -16, strict);
	      num = low_sign_unext (num, 5);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);
d1663 5
a1667 11
	    /* Handle a 5 bit immediate at 31.  */
	    case 'V':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      /* When in strict mode, we want to just reject this
		 match instead of giving an out of range error.  */
	      CHECK_FIELD (num, 15, -16, strict);
	      num = low_sign_unext (num, 5);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d1669 2
a1670 8
	    /* Handle an unsigned 5 bit immediate at 31.  */
	    case 'r':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d1672 1
a1672 8
	    /* Handle an unsigned 5 bit immediate at 15.  */
	    case 'R':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);
d1674 4
a1677 8
	    /* Handle an unsigned 10 bit immediate at 15.  */
	    case 'U':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1023, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);
d1679 1
a1679 7
	    /* Handle a 2 bit space identifier at 17.  */
	    case 's':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 3, 0, 1);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 14);
d1681 2
a1682 8
	    /* Handle a 3 bit space identifier at 18.  */
	    case 'S':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 7, 0, 1);
	      opcode |= re_assemble_3 (num);
	      continue;
d1684 16
a1699 4
	    /* Handle all completers.  */
	    case 'c':
	      switch (*++args)
		{
d1701 8
a1708 38
		/* Handle a completer for an indexing load or store.  */
		case 'X':
		case 'x':
		  {
		    int uu = 0;
		    int m = 0;
		    int i = 0;
		    while (*s == ',' && i < 2)
		      {
			s++;
			if (strncasecmp (s, "sm", 2) == 0)
			  {
			    uu = 1;
			    m = 1;
			    s++;
			    i++;
			  }
			else if (strncasecmp (s, "m", 1) == 0)
			  m = 1;
			else if ((strncasecmp (s, "s ", 2) == 0)
				 || (strncasecmp (s, "s,", 2) == 0))
			  uu = 1;
			else if (strict)
			  {
			    /* This is a match failure.  */
			    s--;
			    break;
			  }
			else
			  as_bad (_("Invalid Indexed Load Completer."));
			s++;
			i++;
		      }
		    if (i > 2)
		      as_bad (_("Invalid Indexed Load Completer Syntax."));
		    opcode |= m << 5;
		    INSERT_FIELD_AND_CONTINUE (opcode, uu, 13);
		  }
d1710 7
a1716 37
		/* Handle a short load/store completer.  */
		case 'M':
		case 'm':
		case 'q':
		case 'J':
		case 'e':
		  {
		    int a = 0;
		    int m = 0;
		    if (*s == ',')
		      {
			s++;
			if (strncasecmp (s, "ma", 2) == 0)
			  {
			    a = 0;
			    m = 1;
			    s += 2;
			  }
			else if (strncasecmp (s, "mb", 2) == 0)
			  {
			    a = 1;
			    m = 1;
			    s += 2;
			  }
			else if (strict)
			  /* This is a match failure.  */
			  s--;
			else
			  {
			    as_bad (_("Invalid Short Load/Store Completer."));
			    s += 2;
			  }
		      }
		    /* If we did not get a ma/mb completer, then we do not
		       consider this a positive match for 'ce'.  */
		    else if (*args == 'e')
		      break;
d1718 11
a1728 26
		   /* 'J', 'm', 'M' and 'q' are the same, except for where they
		       encode the before/after field.  */
		   if (*args == 'm' || *args == 'M')
		      {
			opcode |= m << 5;
			INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
		      }
		    else if (*args == 'q')
		      {
			opcode |= m << 3;
			INSERT_FIELD_AND_CONTINUE (opcode, a, 2);
		      }
		    else if (*args == 'J')
		      {
		        /* M bit is explicit in the major opcode.  */
			INSERT_FIELD_AND_CONTINUE (opcode, a, 2);
		      }
		    else if (*args == 'e')
		      {
			/* Stash the ma/mb flag temporarily in the
			   instruction.  We will use (and remove it)
			   later when handling 'J', 'K', '<' & '>'.  */
			opcode |= a;
			continue;
		      }
		  }
d1730 2
a1731 33
		/* Handle a stbys completer.  */
		case 'A':
		case 's':
		  {
		    int a = 0;
		    int m = 0;
		    int i = 0;
		    while (*s == ',' && i < 2)
		      {
			s++;
			if (strncasecmp (s, "m", 1) == 0)
			  m = 1;
			else if ((strncasecmp (s, "b ", 2) == 0)
				 || (strncasecmp (s, "b,", 2) == 0))
			  a = 0;
			else if (strncasecmp (s, "e", 1) == 0)
			  a = 1;
			/* In strict mode, this is a match failure.  */
			else if (strict)
			  {
			    s--;
			    break;
			  }
			else
			  as_bad (_("Invalid Store Bytes Short Completer"));
			s++;
			i++;
		      }
		    if (i > 2)
		      as_bad (_("Invalid Store Bytes Short Completer"));
		    opcode |= m << 5;
		    INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
		  }
d1733 14
a1746 9
		/* Handle load cache hint completer.  */
		case 'c':
		  cmpltr = 0;
		  if (!strncmp (s, ",sl", 3))
		    {
		      s += 3;
		      cmpltr = 2;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);
d1748 5
a1752 14
		/* Handle store cache hint completer.  */
		case 'C':
		  cmpltr = 0;
		  if (!strncmp (s, ",sl", 3))
		    {
		      s += 3;
		      cmpltr = 2;
		    }
		  else if (!strncmp (s, ",bc", 3))
		    {
		      s += 3;
		      cmpltr = 1;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);
d1754 8
a1761 9
		/* Handle load and clear cache hint completer.  */
		case 'd':
		  cmpltr = 0;
		  if (!strncmp (s, ",co", 3))
		    {
		      s += 3;
		      cmpltr = 1;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);
d1763 1
a1763 6
		/* Handle load ordering completer.  */
		case 'o':
		  if (strncmp (s, ",o", 2) != 0)
		    break;
		  s += 2;
		  continue;
d1765 7
a1771 6
		/* Handle a branch gate completer.  */
		case 'g':
		  if (strncasecmp (s, ",gate", 5) != 0)
		    break;
		  s += 5;
		  continue;
d1773 10
a1782 6
		/* Handle a branch link and push completer.  */
		case 'p':
		  if (strncasecmp (s, ",l,push", 7) != 0)
		    break;
		  s += 7;
		  continue;
d1784 17
a1800 6
		/* Handle a branch link completer.  */
		case 'l':
		  if (strncasecmp (s, ",l", 2) != 0)
		    break;
		  s += 2;
		  continue;
d1802 9
a1810 6
		/* Handle a branch pop completer.  */
		case 'P':
		  if (strncasecmp (s, ",pop", 4) != 0)
		    break;
		  s += 4;
		  continue;
d1812 1
a1812 6
		/* Handle a local processor completer.  */
		case 'L':
		  if (strncasecmp (s, ",l", 2) != 0)
		    break;
		  s += 2;
		  continue;
d1814 6
a1819 13
		/* Handle a PROBE read/write completer.  */
		case 'w':
		  flag = 0;
		  if (!strncasecmp (s, ",w", 2))
		    {
		      flag = 1;
		      s += 2;
		    }
		  else if (!strncasecmp (s, ",r", 2))
		    {
		      flag = 0;
		      s += 2;
		    }
d1821 2
a1822 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);
d1824 23
a1846 6
		/* Handle MFCTL wide completer.  */
		case 'W':
		  if (strncasecmp (s, ",w", 2) != 0)
		    break;
		  s += 2;
		  continue;
d1848 23
a1870 8
		/* Handle an RFI restore completer.  */
		case 'r':
		  flag = 0;
		  if (!strncasecmp (s, ",r", 2))
		    {
		      flag = 5;
		      s += 2;
		    }
d1872 6
a1877 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);
d1879 7
a1885 9
		/* Handle a system control completer.  */
		case 'Z':
		  if (*s == ',' && (*(s + 1) == 'm' || *(s + 1) == 'M'))
		    {
		      flag = 1;
		      s += 2;
		    }
		  else
		    flag = 0;
d1887 8
a1894 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);
d1896 2
a1897 8
		/* Handle intermediate/final completer for DCOR.  */
		case 'i':
		  flag = 0;
		  if (!strncasecmp (s, ",i", 2))
		    {
		      flag = 1;
		      s += 2;
		    }
d1899 5
a1903 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);
d1905 2
a1906 8
		/* Handle zero/sign extension completer.  */
		case 'z':
		  flag = 1;
		  if (!strncasecmp (s, ",z", 2))
		    {
		      flag = 0;
		      s += 2;
		    }
d1908 5
a1912 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 10);
d1914 2
a1915 13
		/* Handle add completer.  */
		case 'a':
		  flag = 1;
		  if (!strncasecmp (s, ",l", 2))
		    {
		      flag = 2;
		      s += 2;
		    }
		  else if (!strncasecmp (s, ",tsv", 4))
		    {
		      flag = 3;
		      s += 4;
		    }
d1917 5
a1921 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 10);
d1923 2
a1924 16
		/* Handle 64 bit carry for ADD.  */
		case 'Y':
		  flag = 0;
		  if (!strncasecmp (s, ",dc,tsv", 7) ||
		      !strncasecmp (s, ",tsv,dc", 7))
		    {
		      flag = 1;
		      s += 7;
		    }
		  else if (!strncasecmp (s, ",dc", 3))
		    {
		      flag = 0;
		      s += 3;
		    }
		  else
		    break;
d1926 4
a1929 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d1931 6
a1936 16
		/* Handle 32 bit carry for ADD.  */
		case 'y':
		  flag = 0;
		  if (!strncasecmp (s, ",c,tsv", 6) ||
		      !strncasecmp (s, ",tsv,c", 6))
		    {
		      flag = 1;
		      s += 6;
		    }
		  else if (!strncasecmp (s, ",c", 2))
		    {
		      flag = 0;
		      s += 2;
		    }
		  else
		    break;
d1938 3
a1940 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d1942 3
a1944 8
		/* Handle trap on signed overflow.  */
		case 'v':
		  flag = 0;
		  if (!strncasecmp (s, ",tsv", 4))
		    {
		      flag = 1;
		      s += 4;
		    }
d1946 3
a1948 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d1950 6
a1955 16
		/* Handle trap on condition and overflow.  */
		case 't':
		  flag = 0;
		  if (!strncasecmp (s, ",tc,tsv", 7) ||
		      !strncasecmp (s, ",tsv,tc", 7))
		    {
		      flag = 1;
		      s += 7;
		    }
		  else if (!strncasecmp (s, ",tc", 3))
		    {
		      flag = 0;
		      s += 3;
		    }
		  else
		    break;
d1957 3
a1959 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d1961 3
a1963 16
		/* Handle 64 bit borrow for SUB.  */
		case 'B':
		  flag = 0;
		  if (!strncasecmp (s, ",db,tsv", 7) ||
		      !strncasecmp (s, ",tsv,db", 7))
		    {
		      flag = 1;
		      s += 7;
		    }
		  else if (!strncasecmp (s, ",db", 3))
		    {
		      flag = 0;
		      s += 3;
		    }
		  else
		    break;
d1965 4
a1968 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d1970 4
a1973 16
		/* Handle 32 bit borrow for SUB.  */
		case 'b':
		  flag = 0;
		  if (!strncasecmp (s, ",b,tsv", 6) ||
		      !strncasecmp (s, ",tsv,b", 6))
		    {
		      flag = 1;
		      s += 6;
		    }
		  else if (!strncasecmp (s, ",b", 2))
		    {
		      flag = 0;
		      s += 2;
		    }
		  else
		    break;
d1975 4
a1978 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d1980 3
a1982 8
		/* Handle trap condition completer for UADDCM.  */
		case 'T':
		  flag = 0;
		  if (!strncasecmp (s, ",tc", 3))
		    {
		      flag = 1;
		      s += 3;
		    }
d1984 5
a1988 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);
d1990 18
a2007 14
		/* Handle signed/unsigned at 21.  */
		case 'S':
		  {
		    int sign = 1;
		    if (strncasecmp (s, ",s", 2) == 0)
		      {
			sign = 1;
			s += 2;
		      }
		    else if (strncasecmp (s, ",u", 2) == 0)
		      {
			sign = 0;
			s += 2;
		      }
d2009 3
a2011 2
		    INSERT_FIELD_AND_CONTINUE (opcode, sign, 10);
		  }
d2013 2
a2014 11
		/* Handle left/right combination at 17:18.  */
		case 'h':
		  if (*s++ == ',')
		    {
		      int lr = 0;
		      if (*s == 'r')
			lr = 2;
		      else if (*s == 'l')
			lr = 0;
		      else
			as_bad (_("Invalid left/right combination completer"));
d2016 5
a2020 6
		      s++;
		      INSERT_FIELD_AND_CONTINUE (opcode, lr, 13);
		    }
		  else
		    as_bad (_("Invalid left/right combination completer"));
		  break;
d2022 2
a2023 14
		/* Handle saturation at 24:25.  */
		case 'H':
		  {
		    int sat = 3;
		    if (strncasecmp (s, ",ss", 3) == 0)
		      {
			sat = 1;
			s += 3;
		      }
		    else if (strncasecmp (s, ",us", 3) == 0)
		      {
			sat = 0;
			s += 3;
		      }
d2025 7
a2031 2
		    INSERT_FIELD_AND_CONTINUE (opcode, sat, 6);
		  }
d2033 1
a2033 37
		/* Handle permutation completer.  */
		case '*':
		  if (*s++ == ',')
		    {
		      int permloc[4];
		      int perm = 0;
		      int i = 0;
		      permloc[0] = 13;
		      permloc[1] = 10;
		      permloc[2] = 8;
		      permloc[3] = 6;
		      for (; i < 4; i++)
		        {
			  switch (*s++)
			    {
			    case '0':
			      perm = 0;
			      break;
			    case '1':
			      perm = 1;
			      break;
			    case '2':
			      perm = 2;
			      break;
			    case '3':
			      perm = 3;
			      break;
			    default:
			      as_bad (_("Invalid permutation completer"));
			    }
			  opcode |= perm << permloc[i];
			}
		      continue;
		    }
		  else
		    as_bad (_("Invalid permutation completer"));
		  break;
d2035 2
a2036 4
		default:
		  abort ();
		}
	      break;
d2038 5
a2042 10
	    /* Handle all conditions.  */
	    case '?':
	      {
		args++;
		switch (*args)
		  {
		  /* Handle FP compare conditions.  */
		  case 'f':
		    cond = pa_parse_fp_cmp_cond (&s);
		    INSERT_FIELD_AND_CONTINUE (opcode, cond, 0);
d2044 2
a2045 8
		  /* Handle an add condition.  */
		  case 'A':
		  case 'a':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;
d2047 15
a2061 10
			/* 64 bit conditions.  */
			if (*args == 'A')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
d2063 3
a2065 66
			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "nuv") == 0)
			  cmpltr = 4;
			else if (strcasecmp (name, "znv") == 0)
			  cmpltr = 5;
			else if (strcasecmp (name, "sv") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, "uv") == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			  }
			else if (strcasecmp (name, "vnz") == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			  }
			else if (strcasecmp (name, "nsv") == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args == 'a' || *name)
			  as_bad (_("Invalid Add Condition: %s"), name);
			*s = c;
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);
d2067 3
a2069 9
		  /* Handle non-negated add and branch condition.  */
		  case 'd':
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Add and Branch Condition"));
			cmpltr = 0;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d2071 3
a2073 14
		  /* Handle 64 bit wide-mode add and branch condition.  */
		  case 'W':
		    cmpltr = pa_parse_addb_64_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Add and Branch Condition"));
			cmpltr = 0;
		      }
		    else
		      {
			/* Negated condition requires an opcode change.  */
			opcode |= (cmpltr & 8) << 24;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr & 7, 13);
d2075 2
a2076 21
		  /* Handle a negated or non-negated add and branch
		     condition.  */
		  case '@@':
		    save_s = s;
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			s = save_s;
			cmpltr = pa_parse_neg_add_cmpltr (&s);
			if (cmpltr < 0)
			  {
			    as_bad (_("Invalid Compare/Subtract Condition"));
			    cmpltr = 0;
			  }
			else
			  {
			    /* Negated condition requires an opcode change.  */
			    opcode |= 1 << 27;
			  }
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d2078 10
a2087 7
		  /* Handle branch on bit conditions.  */
		  case 'B':
		  case 'b':
		    cmpltr = 0;
		    if (*s == ',')
		      {
			s++;
d2089 3
a2091 9
			if (*args == 'B')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
d2093 6
a2098 14
			if (strncmp (s, "<", 1) == 0)
			  {
			    cmpltr = 0;
			    s++;
			  }
			else if (strncmp (s, ">=", 2) == 0)
			  {
			    cmpltr = 1;
			    s += 2;
			  }
			else
			  as_bad (_("Invalid Bit Branch Condition: %c"), *s);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 15);
d2100 25
a2124 8
		  /* Handle a compare/subtract condition.  */
		  case 'S':
		  case 's':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;
d2126 1
a2126 10
			/* 64 bit conditions.  */
			if (*args == 'S')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
d2128 76
a2203 67
			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "<<") == 0)
			  cmpltr = 4;
			else if (strcasecmp (name, "<<=") == 0)
			  cmpltr = 5;
			else if (strcasecmp (name, "sv") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, ">>=") == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			  }
			else if (strcasecmp (name, ">>") == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			  }
			else if (strcasecmp (name, "nsv") == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'S' || *name)
			  as_bad (_("Invalid Compare/Subtract Condition: %s"),
				  name);
			*s = c;
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);
d2205 48
a2252 9
		  /* Handle a non-negated compare condition.  */
		  case 't':
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Compare/Subtract Condition"));
			cmpltr = 0;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d2254 2
a2255 19
		  /* Handle a 32 bit compare and branch condition.  */
		  case 'n':
		    save_s = s;
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			s = save_s;
			cmpltr = pa_parse_neg_cmpsub_cmpltr (&s);
			if (cmpltr < 0)
			  {
			    as_bad (_("Invalid Compare and Branch Condition"));
			    cmpltr = 0;
			  }
			else
			  {
			    /* Negated condition requires an opcode change.  */
			    opcode |= 1 << 27;
			  }
		      }
d2257 7
a2263 1
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d2265 2
a2266 11
		  /* Handle a 64 bit compare and branch condition.  */
		  case 'N':
		    cmpltr = pa_parse_cmpb_64_cmpltr (&s);
		    if (cmpltr >= 0)
		      {
			/* Negated condition requires an opcode change.  */
			opcode |= (cmpltr & 8) << 26;
		      }
		    else
		      /* Not a 64 bit cond.  Give 32 bit a chance.  */
		      break;
d2268 18
a2285 1
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr & 7, 13);
d2287 2
a2288 6
		  /* Handle a 64 bit cmpib condition.  */
		  case 'Q':
		    cmpltr = pa_parse_cmpib_64_cmpltr (&s);
		    if (cmpltr < 0)
		      /* Not a 64 bit cond.  Give 32 bit a chance.  */
		      break;
d2290 4
a2293 1
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d2295 1
a2295 8
		    /* Handle a logical instruction condition.  */
		  case 'L':
		  case 'l':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;
d2297 25
a2321 10
			/* 64 bit conditions.  */
			if (*args == 'L')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
d2323 2
a2324 5
			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
d2326 1
a2326 40
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'L' || *name)
			  as_bad (_("Invalid Logical Instruction Condition."));
			*s = c;
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);
d2328 4
a2331 8
		  /* Handle a shift/extract/deposit condition.  */
		  case 'X':
		  case 'x':
		  case 'y':
		    cmpltr = 0;
		    if (*s == ',')
		      {
			save_s = s++;
d2333 41
a2373 10
			/* 64 bit conditions.  */
			if (*args == 'X')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
d2375 2
a2376 33
			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "tr") == 0)
			  cmpltr = 4;
			else if (strcmp (name, "<>") == 0)
			  cmpltr = 5;
			else if (strcmp (name, ">=") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "ev") == 0)
			  cmpltr = 7;
			/* Handle movb,n.  Put things back the way they were.
			   This includes moving s back to where it started.  */
			else if (strcasecmp (name, "n") == 0 && *args == 'y')
			  {
			    *s = c;
			    s = save_s;
			    continue;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'X' || *name)
			  as_bad (_("Invalid Shift/Extract/Deposit Condition."));
			*s = c;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d2378 2
a2379 8
		  /* Handle a unit instruction condition.  */
		  case 'U':
		  case 'u':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;
d2381 4
a2384 10
			/* 64 bit conditions.  */
			if (*args == 'U')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
d2386 55
a2440 91
			if (strncasecmp (s, "sbz", 3) == 0)
			  {
			    cmpltr = 2;
			    s += 3;
			  }
			else if (strncasecmp (s, "shz", 3) == 0)
			  {
			    cmpltr = 3;
			    s += 3;
			  }
			else if (strncasecmp (s, "sdc", 3) == 0)
			  {
			    cmpltr = 4;
			    s += 3;
			  }
			else if (strncasecmp (s, "sbc", 3) == 0)
			  {
			    cmpltr = 6;
			    s += 3;
			  }
			else if (strncasecmp (s, "shc", 3) == 0)
			  {
			    cmpltr = 7;
			    s += 3;
			  }
			else if (strncasecmp (s, "tr", 2) == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			    s += 2;
			  }
			else if (strncasecmp (s, "nbz", 3) == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nhz", 3) == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "ndc", 3) == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nbc", 3) == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nhc", 3) == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "swz", 3) == 0)
			  {
			    cmpltr = 1;
			    flag = 0;
			    s += 3;
			  }
			else if (strncasecmp (s, "swc", 3) == 0)
			  {
			    cmpltr = 5;
			    flag = 0;
			    s += 3;
			  }
			else if (strncasecmp (s, "nwz", 3) == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nwc", 3) == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			    s += 3;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'U' || (*s != ' ' && *s != '\t'))
			  as_bad (_("Invalid Unit Instruction Condition."));
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);
d2442 2
a2443 5
		  default:
		    abort ();
		  }
		break;
	      }
d2445 2
a2446 4
	    /* Handle a nullification completer for branch instructions.  */
	    case 'n':
	      nullif = pa_parse_nullif (&s);
	      INSERT_FIELD_AND_CONTINUE (opcode, nullif, 1);
d2448 4
a2451 4
	    /* Handle a nullification completer for copr and spop insns.  */
	    case 'N':
	      nullif = pa_parse_nullif (&s);
	      INSERT_FIELD_AND_CONTINUE (opcode, nullif, 5);
d2453 25
a2477 9
	    /* Handle ,%r2 completer for new syntax branches.  */
	    case 'L':
	      if (*s == ',' && strncasecmp (s + 1, "%r2", 3) == 0)
		s += 4;
	      else if (*s == ',' && strncasecmp (s + 1, "%rp", 3) == 0)
		s += 4;
	      else
		break;
	      continue;
d2479 2
a2480 14
	    /* Handle 3 bit entry into the fp compare array.   Valid values
	       are 0..6 inclusive.  */
	    case 'h':
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 6, 0, 0);
		  num++;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
		}
	      else
		break;
d2482 1
a2482 14
	    /* Handle 3 bit entry into the fp compare array.   Valid values
	       are 0..6 inclusive.  */
	    case 'm':
	      get_expression (s);
	      if (the_insn.exp.X_op == O_constant)
		{
		  s = expr_end;
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 6, 0, 0);
		  num = (num + 1) ^ 1;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
		}
	      else
		break;
d2484 6
a2489 6
	    /* Handle graphics test completers for ftest */
	    case '=':
	      {
		num = pa_parse_ftest_gfx_completer (&s);
		INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
	      }
d2491 4
a2494 23
	    /* Handle a 11 bit immediate at 31.  */
	    case 'i':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 1023, -1024, 0);
		  num = low_sign_unext (num, 11);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 11;
		  continue;
		}
d2496 14
a2509 8
	    /* Handle a 14 bit immediate at 31.  */
	    case 'J':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;
d2511 2
a2512 14
		  /* XXX the completer stored away tidbits of information
		     for us to extract.  We need a cleaner way to do this.
		     Now that we have lots of letters again, it would be
		     good to rethink this.  */
		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb != (num < 0))
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;
d2514 41
a2554 8
	    /* Handle a 14 bit immediate at 31.  */
	    case 'K':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;
d2556 2
a2557 12
		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb == (num < 0))
		    break;
		  if (num % 4)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;
d2559 2
a2560 8
	    /* Handle a 16 bit immediate at 31.  */
	    case '<':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;
d2562 1
a2562 10
		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb != (num < 0))
		    break;
		  CHECK_FIELD (num, 32767, -32768, 0);
		  num = re_assemble_16 (num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;
d2564 4
a2567 8
	    /* Handle a 16 bit immediate at 31.  */
	    case '>':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;
d2569 5
a2573 12
		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb == (num < 0))
		    break;
		  if (num % 4)
		    break;
		  CHECK_FIELD (num, 32767, -32768, 0);
		  num = re_assemble_16 (num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;
d2575 3
a2577 31
	    /* Handle 14 bit immediate, shifted left three times.  */
	    case '#':
	      if (bfd_get_mach (stdoutput) != pa20)
		break;
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  if (num & 0x7)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  if (num < 0)
		    opcode |= 1;
		  num &= 0x1fff;
		  num >>= 3;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 4);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}
	      break;
d2579 6
a2584 28
	    /* Handle 14 bit immediate, shifted left twice.  */
	    case 'd':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  if (num & 0x3)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  if (num < 0)
		    opcode |= 1;
		  num &= 0x1fff;
		  num >>= 2;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 3);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}
d2586 4
a2589 23
	    /* Handle a 14 bit immediate at 31.  */
	    case 'j':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 8191, -8192, 0);
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}
d2591 2
a2592 23
	    /* Handle a 21 bit immediate at 31.  */
	    case 'k':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num >> 11, 1048575, -1048576, 0);
		  opcode |= re_assemble_21 (num);
		  continue;
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 21;
		  continue;
		}
d2594 1
a2594 24
	    /* Handle a 16 bit immediate at 31 (PA 2.0 wide mode only).  */
	    case 'l':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}
d2596 26
a2621 25
	    /* Handle a word-aligned 16-bit imm. at 31 (PA2.0 wide).  */
	    case 'y':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  CHECK_ALIGN (num, 4, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}
d2623 3
a2625 25
	    /* Handle a dword-aligned 16-bit imm. at 31 (PA2.0 wide).  */
	    case '&':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  CHECK_ALIGN (num, 8, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}
d2627 10
a2636 31
	    /* Handle a 12 bit branch displacement.  */
	    case 'w':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  opcode |= re_assemble_12 (num >> 2);
		  continue;
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 12;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  s = expr_end;
		  continue;
		}
d2638 2
a2639 30
	    /* Handle a 17 bit branch displacement.  */
	    case 'W':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 262143, -262144, 0);
		  opcode |= re_assemble_17 (num >> 2);
		  continue;
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 17;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}
d2641 2
a2642 29
	    /* Handle a 22 bit branch displacement.  */
	    case 'X':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 8388607, -8388608, 0);
		  opcode |= re_assemble_22 (num >> 2);
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 22;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}
d2644 4
a2647 30
	    /* Handle an absolute 17 bit branch target.  */
	    case 'z':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 0;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 262143, -262144, 0);
		  opcode |= re_assemble_17 (num >> 2);
		  continue;
		}
	      else
		{
		  the_insn.reloc = R_HPPA_ABS_CALL;
		  the_insn.format = 17;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}
d2649 18
a2666 10
	    /* Handle '%r1' implicit operand of addil instruction.  */
	    case 'Z':
	      if (*s == ',' && *(s + 1) == '%' && *(s + 3) == '1'
		  && (*(s + 2) == 'r' || *(s + 2) == 'R'))
		{
		  s += 4;
		  continue;
		}
	      else
	        break;
d2668 2
a2669 6
	    /* Handle '%sr0,%r31' implicit operand of be,l instruction.  */
	    case 'Y':
	      if (strncasecmp (s, "%sr0,%r31", 9) != 0)
		break;
	      s += 9;
	      continue;
d2671 2
a2672 6
	    /* Handle immediate value of 0 for ordered load/store instructions.  */
	    case '@@':
	      if (*s != '0')
		break;
	      s++;
	      continue;
d2674 17
a2690 8
	    /* Handle a 2 bit shift count at 25.  */
	    case '.':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 3, 1, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);
d2692 41
a2732 8
	    /* Handle a 4 bit shift count at 25.  */
	    case '*':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 15, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);
d2734 3
a2736 8
	    /* Handle a 5 bit shift count at 26.  */
	    case 'p':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, 31 - num, 5);
d2738 2
a2739 10
	    /* Handle a 6 bit shift count at 20,22:26.  */
	    case '~':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      num = 63 - num;
	      opcode |= (num & 0x20) << 6;
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 5);
d2741 2
a2742 12
	    /* Handle a 6 bit field length at 23,27:31.  */
	    case '%':
	      flag = 0;
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 64, 1, strict);
	      num--;
	      opcode |= (num & 0x20) << 3;
	      num = 31 - (num & 0x1f);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d2744 8
a2751 11
	    /* Handle a 6 bit field length at 19,27:31.  */
	    case '|':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 64, 1, strict);
	      num--;
	      opcode |= (num & 0x20) << 7;
	      num = 31 - (num & 0x1f);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d2753 8
a2760 8
	    /* Handle a 5 bit bit position at 26.  */
	    case 'P':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 5);
d2762 45
a2806 9
	    /* Handle a 6 bit bit position at 20,22:26.  */
	    case 'q':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      opcode |= (num & 0x20) << 6;
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 5);
d2808 3
a2810 13
	    /* Handle a 5 bit immediate at 10 with 'd' as the complement
	       of the high bit of the immediate.  */
	    case 'B':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      if (num & 0x20)
		;
	      else
		opcode |= (1 << 13);
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 21);
d2812 2
a2813 8
	    /* Handle a 5 bit immediate at 10.  */
	    case 'Q':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);
d2815 2
a2816 8
	    /* Handle a 9 bit immediate at 28.  */
	    case '$':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 511, 1, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 3);
d2818 2
a2819 8
	    /* Handle a 13 bit immediate at 18.  */
	    case 'A':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 8191, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
d2821 6
a2826 8
	    /* Handle a 26 bit immediate at 31.  */
	    case 'D':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 67108863, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d2828 82
a2909 10
	    /* Handle a 3 bit SFU identifier at 25.  */
	    case 'v':
	      if (*s++ != ',')
		as_bad (_("Invalid SFU identifier"));
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 7, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);
d2911 2
a2912 9
	    /* Handle a 20 bit SOP field for spop0.  */
	    case 'O':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1048575, 0, strict);
	      num = (num & 0x1f) | ((num & 0x000fffe0) << 6);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d2914 6
a2919 8
	    /* Handle a 15bit SOP field for spop1.  */
	    case 'o':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 32767, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 11);
d2921 8
a2928 9
	    /* Handle a 10bit SOP field for spop3.  */
	    case '0':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1023, 0, strict);
	      num = (num & 0x1f) | ((num & 0x000003e0) << 6);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d2930 38
a2967 9
	    /* Handle a 15 bit SOP field for spop2.  */
	    case '1':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 32767, 0, strict);
	      num = (num & 0x1f) | ((num & 0x00007fe0) << 6);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d2969 2
a2970 10
	    /* Handle a 3-bit co-processor ID field.  */
	    case 'u':
	      if (*s++ != ',')
		as_bad (_("Invalid COPR identifier"));
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 7, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);
d2972 2
a2973 9
	    /* Handle a 22bit SOP field for copr.  */
	    case '2':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 4194303, 0, strict);
	      num = (num & 0x1f) | ((num & 0x003fffe0) << 4);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d2975 8
a2982 18
	    /* Handle a source FP operand format completer.  */
	    case '{':
	      if (*s == ',' && *(s+1) == 't')
		{
		  the_insn.trunc = 1;
		  s += 2;
		}
	      else
		the_insn.trunc = 0;
	      flag = pa_parse_fp_cnv_format (&s);
	      the_insn.fpof1 = flag;
	      if (flag == W || flag == UW)
		flag = SGL;
	      if (flag == DW || flag == UDW)
		flag = DBL;
	      if (flag == QW || flag == UQW)
		flag = QUAD;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d2984 49
a3032 56
	    /* Handle a destination FP operand format completer.  */
	    case '_':
	      /* pa_parse_format needs the ',' prefix.  */
	      s--;
	      flag = pa_parse_fp_cnv_format (&s);
	      the_insn.fpof2 = flag;
	      if (flag == W || flag == UW)
		flag = SGL;
	      if (flag == DW || flag == UDW)
		flag = DBL;
	      if (flag == QW || flag == UQW)
		flag = QUAD;
	      opcode |= flag << 13;
	      if (the_insn.fpof1 == SGL
		  || the_insn.fpof1 == DBL
		  || the_insn.fpof1 == QUAD)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 0;
		  else if (the_insn.fpof2 == W
		      || the_insn.fpof2 == DW
		      || the_insn.fpof2 == QW)
		    flag = 2;
		  else if (the_insn.fpof2 == UW
		      || the_insn.fpof2 == UDW
		      || the_insn.fpof2 == UQW)
		    flag = 6;
		  else
		    abort ();
		}
	      else if (the_insn.fpof1 == W
		       || the_insn.fpof1 == DW
		       || the_insn.fpof1 == QW)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 1;
		  else
		    abort ();
		}
	      else if (the_insn.fpof1 == UW
		       || the_insn.fpof1 == UDW
		       || the_insn.fpof1 == UQW)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 5;
		  else
		    abort ();
		}
	      flag |= the_insn.trunc;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 15);
d3034 3
a3036 5
	    /* Handle a source FP operand format completer.  */
	    case 'F':
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof1 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d3038 2
a3039 7
	    /* Handle a destination FP operand format completer.  */
	    case 'G':
	      /* pa_parse_format needs the ',' prefix.  */
	      s--;
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof2 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 13);
d3041 2
a3042 5
	    /* Handle a source FP operand format completer at 20.  */
	    case 'I':
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof1 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d3044 8
a3051 11
	    /* Handle a floating point operand format at 26.
	       Only allows single and double precision.  */
	    case 'H':
	      flag = pa_parse_fp_format (&s);
	      switch (flag)
		{
		case SGL:
		  opcode |= 0x20;
		case DBL:
		  the_insn.fpof1 = flag;
		  continue;
d3053 53
a3105 6
		case QUAD:
		case ILLEGAL_FMT:
		default:
		  as_bad (_("Invalid Floating Point Operand Format."));
		}
	      break;
d3107 3
a3109 11
	    /* Handle all floating point registers.  */
	    case 'f':
	      switch (*++args)
	        {
		/* Float target register.  */
		case 't':
		  if (!pa_parse_number (&s, 3))
		    break;
		  num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		  CHECK_FIELD (num, 31, 0, 0);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d3111 2
a3112 8
		/* Float target register with L/R selection.  */
		case 'T':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num;
d3114 2
a3115 6
		    /* 0x30 opcodes are FP arithmetic operation opcodes
		       and need to be turned into 0x38 opcodes.  This
		       is not necessary for loads/stores.  */
		    if (need_pa11_opcode ()
			&& ((opcode & 0xfc000000) == 0x30000000))
		      opcode |= 1 << 27;
d3117 8
a3124 3
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 6 : 0);
		    continue;
		  }
d3126 81
a3206 15
		/* Float operand 1.  */
		case 'a':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 21;
		    if (need_pa11_opcode ())
		      {
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 7 : 0);
			opcode |= 1 << 27;
		      }
		    continue;
		  }
d3208 3
a3210 12
		/* Float operand 1 with L/R selection.  */
		case 'X':
		case 'A':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 21;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 7 : 0);
		    continue;
		  }
d3212 2
a3213 15
		/* Float operand 2.  */
		case 'b':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    if (need_pa11_opcode ())
		      {
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 12 : 0);
			opcode |= 1 << 27;
		      }
		    continue;
		  }
d3215 2
a3216 11
		/* Float operand 2 with L/R selection.  */
		case 'B':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 12 : 0);
		    continue;
		  }
d3218 11
a3228 12
		/* Float operand 3 for fmpyfadd, fmpynfadd.  */
		case 'C':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= (num & 0x1c) << 11;
		    opcode |= (num & 0x03) << 9;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 8 : 0);
		    continue;
		  }
d3230 4
a3233 19
		/* Float mult operand 1 for fmpyadd, fmpysub */
		case 'i':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
			if (num < 16)
			  {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
			  }
			num &= 0xF;
			num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 21);
		  }
d3235 4
a3238 19
		/* Float mult operand 2 for fmpyadd, fmpysub */
		case 'j':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
		        if (num < 16)
		          {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 16);
		  }
d3240 5
a3244 19
		/* Float mult target for fmpyadd, fmpysub */
		case 'k':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
		        if (num < 16)
		          {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		  }
d3246 2
a3247 19
		/* Float add operand 1 for fmpyadd, fmpysub */
		case 'l':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
		        if (num < 16)
		          {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 6);
		  }
d3249 2
a3250 19
		/* Float add target for fmpyadd, fmpysub */
		case 'm':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
		        if (num < 16)
		          {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 11);
		  }
d3252 2
a3253 15
		/* Handle L/R register halves like 'x'.  */
		case 'E':
		case 'e':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    if (need_pa11_opcode ())
		      {
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 1 : 0);
		      }
		    continue;
		  }
d3255 1
a3255 7
		/* Float target register (PA 2.0 wide).  */
		case 'x':
		  if (!pa_parse_number (&s, 3))
		    break;
		  num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		  CHECK_FIELD (num, 31, 0, 0);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 16);
d3257 3
a3259 4
		default:
		  abort ();
		}
	      break;
d3261 4
a3264 5
	    default:
	      abort ();
	    }
	  break;
	}
d3266 5
a3270 29
      /* If this instruction is specific to a particular architecture,
	 then set a new architecture.  This automatic promotion crud is
	 for compatibility with HP's old assemblers only.  */
      if (match == TRUE
	  && bfd_get_mach (stdoutput) < insn->arch
	  && !bfd_set_arch_mach (stdoutput, bfd_arch_hppa, insn->arch))
	{
	  as_warn (_("could not update architecture and machine"));
	  match = FALSE;
	}

 failed:
      /* Check if the args matched.  */
      if (!match)
	{
	  if (&insn[1] - pa_opcodes < (int) NUMOPCODES
	      && !strcmp (insn->name, insn[1].name))
	    {
	      ++insn;
	      s = argstart;
	      continue;
	    }
	  else
	    {
	      as_bad (_("Invalid operands %s"), error_message);
	      return;
	    }
	}
      break;
d3273 2
a3274 2
  the_insn.opcode = opcode;
}
d3276 9
a3284 3
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message or NULL is returned.  */
d3286 1
a3286 1
#define MAX_LITTLENUMS 6
d3288 3
a3290 10
char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;
d3292 7
a3298 2
  switch (type)
    {
d3300 7
a3306 6
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;
d3308 9
a3316 6
    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;
d3318 8
a3325 4
    case 'x':
    case 'X':
      prec = 6;
      break;
d3327 8
a3334 4
    case 'p':
    case 'P':
      prec = 6;
      break;
d3336 6
a3341 15
    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return NULL;
}
d3343 11
a3353 1
/* Write out big-endian.  */
d3355 7
a3361 8
void
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
{
  number_to_chars_bigendian (buf, val, n);
}
d3363 7
a3369 2
/* Translate internal representation of relocation info to BFD target
   format.  */
d3371 8
a3378 13
arelent **
tc_gen_reloc (section, fixp)
     asection *section;
     fixS *fixp;
{
  arelent *reloc;
  struct hppa_fix_struct *hppa_fixp;
  static arelent *no_relocs = NULL;
  arelent **relocs;
  reloc_type **codes;
  reloc_type code;
  int n_relocs;
  int i;
d3380 8
a3387 3
  hppa_fixp = (struct hppa_fix_struct *) fixp->tc_fix_data;
  if (fixp->fx_addsy == 0)
    return &no_relocs;
d3389 11
a3399 2
  assert (hppa_fixp != 0);
  assert (section != 0);
d3401 11
a3411 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d3413 8
a3420 8
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  codes = hppa_gen_reloc_type (stdoutput,
			       fixp->fx_r_type,
			       hppa_fixp->fx_r_format,
			       hppa_fixp->fx_r_field,
			       fixp->fx_subsy != NULL,
			       symbol_get_bfdsym (fixp->fx_addsy));
d3422 8
a3429 5
  if (codes == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line, _("Cannot handle fixup"));
      abort ();
    }
d3431 8
a3438 2
  for (n_relocs = 0; codes[n_relocs]; n_relocs++)
    ;
d3440 7
a3446 4
  relocs = (arelent **) xmalloc (sizeof (arelent *) * n_relocs + 1);
  reloc = (arelent *) xmalloc (sizeof (arelent) * n_relocs);
  for (i = 0; i < n_relocs; i++)
    relocs[i] = &reloc[i];
d3448 8
a3455 1
  relocs[n_relocs] = NULL;
d3457 4
a3460 5
#ifdef OBJ_ELF
  switch (fixp->fx_r_type)
    {
    default:
      assert (n_relocs == 1);
d3462 38
a3499 1
      code = *codes[0];
d3501 37
a3537 13
      /* Now, do any processing that is dependent on the relocation type.  */
      switch (code)
	{
	case R_PARISC_DLTREL21L:
	case R_PARISC_DLTREL14R:
	case R_PARISC_DLTREL14F:
	case R_PARISC_PLABEL32:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL14R:
	  /* For plabel relocations, the addend of the
	     relocation should be either 0 (no static link) or 2
	     (static link required).  This adjustment is done in
	     bfd/elf32-hppa.c:elf32_hppa_relocate_section.
d3539 26
a3564 5
	     We also slam a zero addend into the DLT relative relocs;
	     it doesn't make a lot of sense to use any addend since
	     it gets you a different (eg unknown) DLT entry.  */
	  reloc->addend = 0;
	  break;
d3566 33
a3598 12
#ifdef ELF_ARG_RELOC
	case R_PARISC_PCREL17R:
	case R_PARISC_PCREL17F:
	case R_PARISC_PCREL17C:
	case R_PARISC_DIR17R:
	case R_PARISC_DIR17F:
	case R_PARISC_PCREL21L:
	case R_PARISC_DIR21L:
	  reloc->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc,
					 fixp->fx_offset);
	  break;
#endif
d3600 9
a3608 5
	case R_PARISC_DIR32:
	  /* Facilitate hand-crafted unwind info.  */
	  if (strcmp (section->name, UNWIND_SECTION_NAME) == 0)
	    code = R_PARISC_SEGREL32;
	  /* Fall thru */
d3610 14
a3623 4
	default:
	  reloc->addend = fixp->fx_offset;
	  break;
	}
d3625 16
a3640 5
      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->howto = bfd_reloc_type_lookup (stdoutput,
					    (bfd_reloc_code_real_type) code);
      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
d3642 6
a3647 4
      assert (reloc->howto && (unsigned int) code == reloc->howto->type);
      break;
    }
#else /* OBJ_SOM */
d3649 6
a3654 4
  /* Walk over reach relocation returned by the BFD backend.  */
  for (i = 0; i < n_relocs; i++)
    {
      code = *codes[i];
d3656 6
a3661 6
      relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      relocs[i]->howto =
	bfd_reloc_type_lookup (stdoutput,
			       (bfd_reloc_code_real_type) code);
      relocs[i]->address = fixp->fx_frag->fr_address + fixp->fx_where;
d3663 6
a3668 47
      switch (code)
	{
	case R_COMP2:
	  /* The only time we ever use a R_COMP2 fixup is for the difference
	     of two symbols.  With that in mind we fill in all four
	     relocs now and break out of the loop.  */
	  assert (i == 1);
	  relocs[0]->sym_ptr_ptr
	    = (asymbol **) bfd_abs_section_ptr->symbol_ptr_ptr;
	  relocs[0]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[0]);
	  relocs[0]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[0]->addend = 0;
	  relocs[1]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[1]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
	  relocs[1]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[1]);
	  relocs[1]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[1]->addend = 0;
	  relocs[2]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[2]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_subsy);
	  relocs[2]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[2]);
	  relocs[2]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[2]->addend = 0;
	  relocs[3]->sym_ptr_ptr
	    = (asymbol **) bfd_abs_section_ptr->symbol_ptr_ptr;
	  relocs[3]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[3]);
	  relocs[3]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[3]->addend = 0;
	  relocs[4]->sym_ptr_ptr
	    = (asymbol **) bfd_abs_section_ptr->symbol_ptr_ptr;
	  relocs[4]->howto
	    = bfd_reloc_type_lookup (stdoutput,
				     (bfd_reloc_code_real_type) *codes[4]);
	  relocs[4]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[4]->addend = 0;
	  goto done;
	case R_PCREL_CALL:
	case R_ABS_CALL:
	  relocs[i]->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc, 0);
	  break;
d3670 6
a3675 6
	case R_DLT_REL:
	case R_DATA_PLABEL:
	case R_CODE_PLABEL:
	  /* For plabel relocations, the addend of the
	     relocation should be either 0 (no static link) or 2
	     (static link required).
d3677 13
a3689 1
	     FIXME: We always assume no static link!
d3691 1
a3691 5
	     We also slam a zero addend into the DLT relative relocs;
	     it doesn't make a lot of sense to use any addend since
	     it gets you a different (eg unknown) DLT entry.  */
	  relocs[i]->addend = 0;
	  break;
d3693 6
a3698 17
	case R_N_MODE:
	case R_S_MODE:
	case R_D_MODE:
	case R_R_MODE:
	case R_FSEL:
	case R_LSEL:
	case R_RSEL:
	case R_BEGIN_BRTAB:
	case R_END_BRTAB:
	case R_BEGIN_TRY:
	case R_N0SEL:
	case R_N1SEL:
	  /* There is no symbol or addend associated with these fixups.  */
	  relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
	  relocs[i]->addend = 0;
	  break;
d3700 8
a3707 8
	case R_END_TRY:
	case R_ENTRY:
	case R_EXIT:
	  /* There is no symbol associated with these fixups.  */
	  relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
	  relocs[i]->addend = fixp->fx_offset;
	  break;
d3709 1
a3709 4
	default:
	  relocs[i]->addend = fixp->fx_offset;
	}
    }
d3711 9
a3719 2
 done:
#endif
d3721 1
a3721 2
  return relocs;
}
d3723 8
a3730 1
/* Process any machine dependent frag types.  */
d3732 1
a3732 7
void
md_convert_frag (abfd, sec, fragP)
     register bfd *abfd ATTRIBUTE_UNUSED;
     register asection *sec ATTRIBUTE_UNUSED;
     register fragS *fragP;
{
  unsigned int address;
d3734 8
a3741 22
  if (fragP->fr_type == rs_machine_dependent)
    {
      switch ((int) fragP->fr_subtype)
	{
	case 0:
	  fragP->fr_type = rs_fill;
	  know (fragP->fr_var == 1);
	  know (fragP->fr_next);
	  address = fragP->fr_address + fragP->fr_fix;
	  if (address % fragP->fr_offset)
	    {
	      fragP->fr_offset =
		fragP->fr_next->fr_address
		- fragP->fr_address
		- fragP->fr_fix;
	    }
	  else
	    fragP->fr_offset = 0;
	  break;
	}
    }
}
d3743 1
a3743 1
/* Round up a section size to the appropriate boundary.  */
d3745 13
a3757 7
valueT
md_section_align (segment, size)
     asection *segment;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  int align2 = (1 << align) - 1;
d3759 1
a3759 2
  return (size + align2) & ~align2;
}
d3761 16
a3776 7
/* Return the approximate size of a frag before relaxation has occurred.  */
int
md_estimate_size_before_relax (fragP, segment)
     register fragS *fragP;
     asection *segment ATTRIBUTE_UNUSED;
{
  int size;
d3778 1
a3778 1
  size = 0;
d3780 16
a3795 2
  while ((fragP->fr_fix + size) % fragP->fr_offset)
    size++;
d3797 1
a3797 16
  return size;
}

#ifdef OBJ_ELF
# ifdef WARN_COMMENTS
const char *md_shortopts = "Vc";
# else
const char *md_shortopts = "V";
# endif
#else
# ifdef WARN_COMMENTS
const char *md_shortopts = "c";
# else
const char *md_shortopts = "";
# endif
#endif
d3799 8
a3806 7
struct option md_longopts[] = {
#ifdef WARN_COMMENTS
  {"warn-comment", no_argument, NULL, 'c'},
#endif
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);
d3808 1
a3808 9
int
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
{
  switch (c)
    {
    default:
      return 0;
d3810 16
a3825 11
#ifdef OBJ_ELF
    case 'V':
      print_version_id ();
      break;
#endif
#ifdef WARN_COMMENTS
    case 'c':
      warn_comment = 1;
      break;
#endif
    }
d3827 1
a3827 2
  return 1;
}
d3829 16
a3844 15
void
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
{
#ifdef OBJ_ELF
  fprintf (stream, _("\
  -Q                      ignored\n"));
#endif
#ifdef WARN_COMMENTS
  fprintf (stream, _("\
  -c                      print a warning if a comment is found\n"));
#endif
}

/* We have no need to default values of symbols.  */
d3846 1
a3846 6
symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}
d3848 16
a3863 8
#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
#define nonzero_dibits(x) \
  ((x) | (((x) & 0x55555555) << 1) | (((x) & 0xAAAAAAAA) >> 1))
#define arg_reloc_stub_needed(CALLER, CALLEE) \
  (((CALLER) ^ (CALLEE)) & nonzero_dibits (CALLER) & nonzero_dibits (CALLEE))
#else
#define arg_reloc_stub_needed(CALLER, CALLEE) 0
#endif
d3865 1
a3865 1
/* Apply a fixup to an instruction.  */
d3867 8
a3874 10
void
md_apply_fix (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
{
  char *fixpos;
  struct hppa_fix_struct *hppa_fixP;
  offsetT new_val;
  int insn, val, fmt;
d3876 1
a3876 10
  /* SOM uses R_HPPA_ENTRY and R_HPPA_EXIT relocations which can
     never be "applied" (they are just markers).  Likewise for
     R_HPPA_BEGIN_BRTAB and R_HPPA_END_BRTAB.  */
#ifdef OBJ_SOM
  if (fixP->fx_r_type == R_HPPA_ENTRY
      || fixP->fx_r_type == R_HPPA_EXIT
      || fixP->fx_r_type == R_HPPA_BEGIN_BRTAB
      || fixP->fx_r_type == R_HPPA_END_BRTAB
      || fixP->fx_r_type == R_HPPA_BEGIN_TRY)
    return;
d3878 14
a3891 14
  /* Disgusting.  We must set fx_offset ourselves -- R_HPPA_END_TRY
     fixups are considered not adjustable, which in turn causes
     adjust_reloc_syms to not set fx_offset.  Ugh.  */
  if (fixP->fx_r_type == R_HPPA_END_TRY)
    {
      fixP->fx_offset = * valP;
      return;
    }
#endif
#ifdef OBJ_ELF
  if (fixP->fx_r_type == (int) R_PARISC_GNU_VTENTRY
      || fixP->fx_r_type == (int) R_PARISC_GNU_VTINHERIT)
    return;
#endif
d3893 2
a3894 2
  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
d3896 11
a3906 9
  /* There should be a HPPA specific fixup associated with the GAS fixup.  */
  hppa_fixP = (struct hppa_fix_struct *) fixP->tc_fix_data;
  if (hppa_fixP == NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("no hppa_fixup entry for fixup type 0x%x"),
		    fixP->fx_r_type);
      return;
    }
d3908 6
a3913 1
  fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;
d3915 14
a3928 6
  if (fixP->fx_size != 4 || hppa_fixP->fx_r_format == 32)
    {
      /* Handle constant output. */
      number_to_chars_bigendian (fixpos, *valP, fixP->fx_size);
      return;
    }
d3930 2
a3931 2
  insn = bfd_get_32 (stdoutput, fixpos);
  fmt = bfd_hppa_insn2fmt (stdoutput, insn);
d3933 37
a3969 23
  /* If there is a symbol associated with this fixup, then it's something
     which will need a SOM relocation (except for some PC-relative relocs).
     In such cases we should treat the "val" or "addend" as zero since it
     will be added in as needed from fx_offset in tc_gen_reloc.  */
  if ((fixP->fx_addsy != NULL
       || fixP->fx_r_type == (int) R_HPPA_NONE)
#ifdef OBJ_SOM
      && fmt != 32
#endif
      )
    new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
#ifdef OBJ_SOM
  /* These field selectors imply that we do not want an addend.  */
  else if (hppa_fixP->fx_r_field == e_psel
	   || hppa_fixP->fx_r_field == e_rpsel
	   || hppa_fixP->fx_r_field == e_lpsel
	   || hppa_fixP->fx_r_field == e_tsel
	   || hppa_fixP->fx_r_field == e_rtsel
	   || hppa_fixP->fx_r_field == e_ltsel)
    new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
#endif
  else
    new_val = hppa_field_adjust (* valP, 0, hppa_fixP->fx_r_field);
d3971 4
a3974 23
  /* Handle pc-relative exceptions from above.  */
  if ((fmt == 12 || fmt == 17 || fmt == 22)
      && fixP->fx_addsy
      && fixP->fx_pcrel
      && !arg_reloc_stub_needed (symbol_arg_reloc_info (fixP->fx_addsy),
				 hppa_fixP->fx_arg_reloc)
#ifdef OBJ_ELF
      && (* valP - 8 + 8192 < 16384
	  || (fmt == 17 && * valP - 8 + 262144 < 524288)
	  || (fmt == 22 && * valP - 8 + 8388608 < 16777216))
#endif
#ifdef OBJ_SOM
      && (* valP - 8 + 262144 < 524288
	  || (fmt == 22 && * valP - 8 + 8388608 < 16777216))
#endif
      && !S_IS_EXTERNAL (fixP->fx_addsy)
      && !S_IS_WEAK (fixP->fx_addsy)
      && S_GET_SEGMENT (fixP->fx_addsy) == hppa_fixP->segment
      && !(fixP->fx_subsy
	   && S_GET_SEGMENT (fixP->fx_subsy) != hppa_fixP->segment))
    {
      new_val = hppa_field_adjust (* valP, 0, hppa_fixP->fx_r_field);
    }
d3976 10
a3985 6
  switch (fmt)
    {
    case 10:
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;
d3987 8
a3994 7
      insn = (insn & ~ 0x3ff1) | (((val & 0x1ff8) << 1)
				  | ((val & 0x2000) >> 13));
      break;
    case -11:
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;
d3996 10
a4005 8
      insn = (insn & ~ 0x3ff9) | (((val & 0x1ffc) << 1)
				  | ((val & 0x2000) >> 13));
      break;
      /* Handle all opcodes with the 'j' operand type.  */
    case 14:
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;
d4007 66
a4072 2
      insn = ((insn & ~ 0x3fff) | low_sign_unext (val, 14));
      break;
d4074 9
a4082 5
      /* Handle all opcodes with the 'k' operand type.  */
    case 21:
      CHECK_FIELD_WHERE (new_val, 1048575, -1048576,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;
d4084 14
a4097 2
      insn = (insn & ~ 0x1fffff) | re_assemble_21 (val);
      break;
d4099 21
a4119 5
      /* Handle all the opcodes with the 'i' operand type.  */
    case 11:
      CHECK_FIELD_WHERE (new_val, 1023, -1024,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;
d4121 7
a4127 2
      insn = (insn & ~ 0x7ff) | low_sign_unext (val, 11);
      break;
d4129 9
a4137 5
      /* Handle all the opcodes with the 'w' operand type.  */
    case 12:
      CHECK_FIELD_WHERE (new_val - 8, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val - 8;
d4139 14
a4152 2
      insn = (insn & ~ 0x1ffd) | re_assemble_12 (val >> 2);
      break;
d4154 8
a4161 4
      /* Handle some of the opcodes with the 'W' operand type.  */
    case 17:
      {
	offsetT distance = * valP;
d4163 10
a4172 6
	/* If this is an absolute branch (ie no link) with an out of
	   range target, then we want to complain.  */
	if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
	    && (insn & 0xffe00000) == 0xe8000000)
	  CHECK_FIELD_WHERE (distance - 8, 262143, -262144,
			     fixP->fx_file, fixP->fx_line);
d4174 67
a4240 3
	CHECK_FIELD_WHERE (new_val - 8, 262143, -262144,
			   fixP->fx_file, fixP->fx_line);
	val = new_val - 8;
d4242 9
a4250 3
	insn = (insn & ~ 0x1f1ffd) | re_assemble_17 (val >> 2);
	break;
      }
d4252 19
a4270 3
    case 22:
      {
	offsetT distance = * valP;
d4272 1
a4272 6
	/* If this is an absolute branch (ie no link) with an out of
	   range target, then we want to complain.  */
	if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
	    && (insn & 0xffe00000) == 0xe8000000)
	  CHECK_FIELD_WHERE (distance - 8, 8388607, -8388608,
			     fixP->fx_file, fixP->fx_line);
d4274 11
a4284 3
	CHECK_FIELD_WHERE (new_val - 8, 8388607, -8388608,
			   fixP->fx_file, fixP->fx_line);
	val = new_val - 8;
d4286 1
a4286 3
	insn = (insn & ~ 0x3ff1ffd) | re_assemble_22 (val >> 2);
	break;
      }
d4288 6
a4293 4
    case -10:
      val = new_val;
      insn = (insn & ~ 0xfff1) | re_assemble_16 (val & -8);
      break;
d4295 1
a4295 4
    case -16:
      val = new_val;
      insn = (insn & ~ 0xfff9) | re_assemble_16 (val & -4);
      break;
d4297 8
a4304 4
    case 16:
      val = new_val;
      insn = (insn & ~ 0xffff) | re_assemble_16 (val);
      break;
d4306 16
a4321 3
    case 32:
      insn = new_val;
      break;
d4323 40
a4362 5
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("Unknown relocation encountered in md_apply_fix."));
      return;
    }
d4364 8
a4371 3
  /* Insert the relocation.  */
  bfd_put_32 (stdoutput, insn, fixpos);
}
d4373 10
a4382 2
/* Exactly what point is a PC-relative offset relative TO?
   On the PA, they're relative to the address of the offset.  */
d4384 33
a4416 6
long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_where + fixP->fx_frag->fr_address;
}
d4418 8
a4425 2
/* Return nonzero if the input line pointer is at the end of
   a statement.  */
d4427 10
a4436 7
static int
is_end_of_statement ()
{
  return ((*input_line_pointer == '\n')
	  || (*input_line_pointer == ';')
	  || (*input_line_pointer == '!'));
}
d4438 91
a4528 3
/* Read a number from S.  The number might come in one of many forms,
   the most common will be a hex or decimal constant, but it could be
   a pre-defined register (Yuk!), or an absolute symbol.
d4530 5
a4534 3
   Return 1 on success or 0 on failure.  If STRICT, then a missing
   register prefix will cause a failure.  The number itself is
   returned in `pa_number'.
d4536 4
a4539 3
   IS_FLOAT indicates that a PA-89 FP register number should be
   parsed;  A `l' or `r' suffix is checked for if but 2 of IS_FLOAT is
   not set.
d4541 4
a4544 2
   pa_parse_number can not handle negative constants and will fail
   horribly if it is passed such a constant.  */
d4546 9
a4554 12
static int
pa_parse_number (s, is_float)
     char **s;
     int is_float;
{
  int num;
  char *name;
  char c;
  symbolS *sym;
  int status;
  char *p = *s;
  bfd_boolean have_prefix;
d4556 14
a4569 3
  /* Skip whitespace before the number.  */
  while (*p == ' ' || *p == '\t')
    p = p + 1;
d4571 12
a4582 18
  pa_number = -1;
  have_prefix = 0;
  num = 0;
  if (!strict && ISDIGIT (*p))
    {
      /* Looks like a number.  */

      if (*p == '0' && (*(p + 1) == 'x' || *(p + 1) == 'X'))
	{
	  /* The number is specified in hex.  */
	  p += 2;
	  while (ISDIGIT (*p) || ((*p >= 'a') && (*p <= 'f'))
		 || ((*p >= 'A') && (*p <= 'F')))
	    {
	      if (ISDIGIT (*p))
		num = num * 16 + *p - '0';
	      else if (*p >= 'a' && *p <= 'f')
		num = num * 16 + *p - 'a' + 10;
d4584 1
a4584 13
		num = num * 16 + *p - 'A' + 10;
	      ++p;
	    }
	}
      else
	{
	  /* The number is specified in decimal.  */
	  while (ISDIGIT (*p))
	    {
	      num = num * 10 + *p - '0';
	      ++p;
	    }
	}
d4586 6
a4591 1
      pa_number = num;
d4593 6
a4598 7
      /* Check for a `l' or `r' suffix.  */
      if (is_float)
	{
	  pa_number += FP_REG_BASE;
	  if (! (is_float & 2))
	    {
	      if (IS_R_SELECT (p))
d4600 4
a4603 2
		  pa_number += FP_REG_RSEL;
		  ++p;
d4605 1
a4605 1
	      else if (IS_L_SELECT (p))
d4607 20
a4626 1
		  ++p;
a4627 61
	    }
	}
    }
  else if (*p == '%')
    {
      /* The number might be a predefined register.  */
      have_prefix = 1;
      name = p;
      p++;
      c = *p;
      /* Tege hack: Special case for general registers as the general
         code makes a binary search with case translation, and is VERY
         slow.  */
      if (c == 'r')
	{
	  p++;
	  if (*p == 'e' && *(p + 1) == 't'
	      && (*(p + 2) == '0' || *(p + 2) == '1'))
	    {
	      p += 2;
	      num = *p - '0' + 28;
	      p++;
	    }
	  else if (*p == 'p')
	    {
	      num = 2;
	      p++;
	    }
	  else if (!ISDIGIT (*p))
	    {
	      if (print_errors)
		as_bad (_("Undefined register: '%s'."), name);
	      num = -1;
	    }
	  else
	    {
	      do
		num = num * 10 + *p++ - '0';
	      while (ISDIGIT (*p));
	    }
	}
      else
	{
	  /* Do a normal register search.  */
	  while (is_part_of_name (c))
	    {
	      p = p + 1;
	      c = *p;
	    }
	  *p = 0;
	  status = reg_name_search (name);
	  if (status >= 0)
	    num = status;
	  else
	    {
	      if (print_errors)
		as_bad (_("Undefined register: '%s'."), name);
	      num = -1;
	    }
	  *p = c;
	}
d4629 8
a4636 48
      pa_number = num;
    }
  else
    {
      /* And finally, it could be a symbol in the absolute section which
         is effectively a constant, or a register alias symbol.  */
      name = p;
      c = *p;
      while (is_part_of_name (c))
	{
	  p = p + 1;
	  c = *p;
	}
      *p = 0;
      if ((sym = symbol_find (name)) != NULL)
	{
	  if (S_GET_SEGMENT (sym) == reg_section)
	    {
	      num = S_GET_VALUE (sym);
	      /* Well, we don't really have one, but we do have a
		 register, so...  */
	      have_prefix = TRUE;
	    }
	  else if (S_GET_SEGMENT (sym) == &bfd_abs_section)
	    num = S_GET_VALUE (sym);
	  else if (!strict)
	    {
	      if (print_errors)
		as_bad (_("Non-absolute symbol: '%s'."), name);
	      num = -1;
	    }
	}
      else if (!strict)
	{
	  /* There is where we'd come for an undefined symbol
	     or for an empty string.  For an empty string we
	     will return zero.  That's a concession made for
	     compatibility with the braindamaged HP assemblers.  */
	  if (*name == 0)
	    num = 0;
	  else
	    {
	      if (print_errors)
		as_bad (_("Undefined absolute constant: '%s'."), name);
	      num = -1;
	    }
	}
      *p = c;
d4638 14
a4651 2
      pa_number = num;
    }
d4653 8
a4660 7
  if (!strict || have_prefix)
    {
      *s = p;
      return 1;
    }
  return 0;
}
d4662 12
a4673 1
#define REG_NAME_CNT	(sizeof (pre_defined_registers) / sizeof (struct pd_reg))
d4675 8
a4682 2
/* Given NAME, find the register number associated with that name, return
   the integer value associated with the given name or -1 on failure.  */
d4684 10
a4693 6
static int
reg_name_search (name)
     char *name;
{
  int middle, low, high;
  int cmp;
d4695 8
a4702 2
  low = 0;
  high = REG_NAME_CNT - 1;
d4704 12
a4715 12
  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, pre_defined_registers[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return pre_defined_registers[middle].value;
    }
  while (low <= high);
d4717 43
a4759 2
  return -1;
}
d4761 40
a4800 2
/* Return nonzero if the given INSN and L/R information will require
   a new PA-1.1 opcode.  */
d4802 35
a4836 18
static int
need_pa11_opcode ()
{
  if ((pa_number & FP_REG_RSEL) != 0
      && !(the_insn.fpof1 == DBL && the_insn.fpof2 == DBL))
    {
      /* If this instruction is specific to a particular architecture,
	 then set a new architecture.  */
      if (bfd_get_mach (stdoutput) < pa11)
	{
	  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, pa11))
	    as_warn (_("could not update architecture and machine"));
	}
      return TRUE;
    }
  else
    return FALSE;
}
d4838 35
a4872 2
/* Parse a condition for a fcmp instruction.  Return the numerical
   code associated with the condition.  */
d4874 36
a4909 5
static int
pa_parse_fp_cmp_cond (s)
     char **s;
{
  int cond, i;
d4911 37
a4947 1
  cond = 0;
d4949 37
a4985 19
  for (i = 0; i < 32; i++)
    {
      if (strncasecmp (*s, fp_cond_map[i].string,
		       strlen (fp_cond_map[i].string)) == 0)
	{
	  cond = fp_cond_map[i].cond;
	  *s += strlen (fp_cond_map[i].string);
	  /* If not a complete match, back up the input string and
	     report an error.  */
	  if (**s != ' ' && **s != '\t')
	    {
	      *s -= strlen (fp_cond_map[i].string);
	      break;
	    }
	  while (**s == ' ' || **s == '\t')
	    *s = *s + 1;
	  return cond;
	}
    }
d4987 31
a5017 1
  as_bad (_("Invalid FP Compare Condition: %s"), *s);
d5019 30
a5048 3
  /* Advance over the bogus completer.  */
  while (**s != ',' && **s != ' ' && **s != '\t')
    *s += 1;
d5050 29
a5078 2
  return 0;
}
d5080 30
a5109 1
/* Parse a graphics test complete for ftest.  */
d5111 10
a5120 5
static int
pa_parse_ftest_gfx_completer (s)
     char **s;
{
  int value;
d5122 6
a5127 41
  value = 0;
  if (strncasecmp (*s, "acc8", 4) == 0)
    {
      value = 5;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc6", 4) == 0)
    {
      value = 9;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc4", 4) == 0)
    {
      value = 13;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc2", 4) == 0)
    {
      value = 17;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc", 3) == 0)
    {
      value = 1;
      *s += 3;
    }
  else if (strncasecmp (*s, "rej8", 4) == 0)
    {
      value = 6;
      *s += 4;
    }
  else if (strncasecmp (*s, "rej", 3) == 0)
    {
      value = 2;
      *s += 3;
    }
  else
    {
      value = 0;
      as_bad (_("Invalid FTEST completer: %s"), *s);
    }
d5129 15
a5143 2
  return value;
}
d5145 8
a5152 2
/* Parse an FP operand format completer returning the completer
   type.  */
d5154 8
a5161 5
static fp_operand_format
pa_parse_fp_cnv_format (s)
     char **s;
{
  int format;
d5163 10
a5172 55
  format = SGL;
  if (**s == ',')
    {
      *s += 1;
      if (strncasecmp (*s, "sgl", 3) == 0)
	{
	  format = SGL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "dbl", 3) == 0)
	{
	  format = DBL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "quad", 4) == 0)
	{
	  format = QUAD;
	  *s += 5;
	}
      else if (strncasecmp (*s, "w", 1) == 0)
	{
	  format = W;
	  *s += 2;
	}
      else if (strncasecmp (*s, "uw", 2) == 0)
	{
	  format = UW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "dw", 2) == 0)
	{
	  format = DW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "udw", 3) == 0)
	{
	  format = UDW;
	  *s += 4;
	}
      else if (strncasecmp (*s, "qw", 2) == 0)
	{
	  format = QW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "uqw", 3) == 0)
	{
	  format = UQW;
	  *s += 4;
	}
      else
	{
	  format = ILLEGAL_FMT;
	  as_bad (_("Invalid FP Operand Format: %3s"), *s);
	}
    }
d5174 12
a5185 2
  return format;
}
d5187 11
a5197 2
/* Parse an FP operand format completer returning the completer
   type.  */
d5199 8
a5206 5
static fp_operand_format
pa_parse_fp_format (s)
     char **s;
{
  int format;
d5208 9
a5216 25
  format = SGL;
  if (**s == ',')
    {
      *s += 1;
      if (strncasecmp (*s, "sgl", 3) == 0)
	{
	  format = SGL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "dbl", 3) == 0)
	{
	  format = DBL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "quad", 4) == 0)
	{
	  format = QUAD;
	  *s += 5;
	}
      else
	{
	  format = ILLEGAL_FMT;
	  as_bad (_("Invalid FP Operand Format: %3s"), *s);
	}
    }
d5218 13
a5230 2
  return format;
}
d5232 8
a5239 1
/* Convert from a selector string into a selector type.  */
d5241 8
a5248 7
static int
pa_chk_field_selector (str)
     char **str;
{
  int middle, low, high;
  int cmp;
  char name[4];
d5250 8
a5257 4
  /* Read past any whitespace.  */
  /* FIXME: should we read past newlines and formfeeds??? */
  while (**str == ' ' || **str == '\t' || **str == '\n' || **str == '\f')
    *str = *str + 1;
d5259 8
a5266 14
  if ((*str)[1] == '\'' || (*str)[1] == '%')
    name[0] = TOLOWER ((*str)[0]),
    name[1] = 0;
  else if ((*str)[2] == '\'' || (*str)[2] == '%')
    name[0] = TOLOWER ((*str)[0]),
    name[1] = TOLOWER ((*str)[1]),
    name[2] = 0;
  else if ((*str)[3] == '\'' || (*str)[3] == '%')
    name[0] = TOLOWER ((*str)[0]),
    name[1] = TOLOWER ((*str)[1]),
    name[2] = TOLOWER ((*str)[2]),
    name[3] = 0;
  else
    return e_fsel;
d5268 10
a5277 2
  low = 0;
  high = sizeof (selector_table) / sizeof (struct selector_entry) - 1;
d5279 9
a5287 19
  do
    {
      middle = (low + high) / 2;
      cmp = strcmp (name, selector_table[middle].prefix);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	{
	  *str += strlen (name) + 1;
#ifndef OBJ_SOM
	  if (selector_table[middle].field_selector == e_nsel)
	    return e_fsel;
#endif
	  return selector_table[middle].field_selector;
	}
    }
  while (low <= high);
d5289 8
a5296 2
  return e_fsel;
}
d5298 9
a5306 1
/* Mark (via expr_end) the end of an expression (I think).  FIXME.  */
d5308 9
a5316 6
static int
get_expression (str)
     char *str;
{
  char *save_in;
  asection *seg;
d5318 10
a5327 16
  save_in = input_line_pointer;
  input_line_pointer = str;
  seg = expression (&the_insn.exp);
  if (!(seg == absolute_section
	|| seg == undefined_section
	|| SEG_NORMAL (seg)))
    {
      as_warn (_("Bad segment in expression."));
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
}
d5329 9
a5337 7
/* Mark (via expr_end) the end of an absolute expression.  FIXME.  */
static int
pa_get_absolute_expression (insn, strp)
     struct pa_it *insn;
     char **strp;
{
  char *save_in;
d5339 18
a5356 5
  insn->field_selector = pa_chk_field_selector (strp);
  save_in = input_line_pointer;
  input_line_pointer = *strp;
  expression (&insn->exp);
  /* This is not perfect, but is a huge improvement over doing nothing.
d5358 56
a5413 3
     The PA assembly syntax is ambiguous in a variety of ways.  Consider
     this string "4 %r5"  Is that the number 4 followed by the register
     r5, or is that 4 MOD r5?
d5415 5
a5419 6
     If we get a modulo expression when looking for an absolute, we try
     again cutting off the input string at the first whitespace character.  */
  if (insn->exp.X_op == O_modulus)
    {
      char *s, c;
      int retval;
d5421 7
a5427 4
      input_line_pointer = *strp;
      s = *strp;
      while (*s != ',' && *s != ' ' && *s != '\t')
	s++;
d5429 5
a5433 2
      c = *s;
      *s = 0;
d5435 11
a5445 1
      retval = pa_get_absolute_expression (insn, strp);
d5447 6
a5452 23
      input_line_pointer = save_in;
      *s = c;
      return evaluate_absolute (insn);
    }
  /* When in strict mode we have a non-match, fix up the pointers
     and return to our caller.  */
  if (insn->exp.X_op != O_constant && strict)
    {
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 0;
    }
  if (insn->exp.X_op != O_constant)
    {
      as_bad (_("Bad segment (should be absolute)."));
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 0;
    }
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
  return evaluate_absolute (insn);
}
d5454 11
a5464 9
/* Evaluate an absolute expression EXP which may be modified by
   the selector FIELD_SELECTOR.  Return the value of the expression.  */
static int
evaluate_absolute (insn)
     struct pa_it *insn;
{
  offsetT value;
  expressionS exp;
  int field_selector = insn->field_selector;
d5466 8
a5473 2
  exp = insn->exp;
  value = exp.X_add_number;
d5475 6
a5480 2
  return hppa_field_adjust (0, value, field_selector);
}
d5482 3
a5484 2
/* Given an argument location specification return the associated
   argument location number.  */
d5486 15
a5500 4
static unsigned int
pa_build_arg_reloc (type_name)
     char *type_name;
{
d5502 12
a5513 10
  if (strncasecmp (type_name, "no", 2) == 0)
    return 0;
  if (strncasecmp (type_name, "gr", 2) == 0)
    return 1;
  else if (strncasecmp (type_name, "fr", 2) == 0)
    return 2;
  else if (strncasecmp (type_name, "fu", 2) == 0)
    return 3;
  else
    as_bad (_("Invalid argument location: %s\n"), type_name);
d5515 15
a5529 2
  return 0;
}
d5531 11
a5541 2
/* Encode and return an argument relocation specification for
   the given register in the location specified by arg_reloc.  */
d5543 12
a5554 6
static unsigned int
pa_align_arg_reloc (reg, arg_reloc)
     unsigned int reg;
     unsigned int arg_reloc;
{
  unsigned int new_reloc;
d5556 19
a5574 18
  new_reloc = arg_reloc;
  switch (reg)
    {
    case 0:
      new_reloc <<= 8;
      break;
    case 1:
      new_reloc <<= 6;
      break;
    case 2:
      new_reloc <<= 4;
      break;
    case 3:
      new_reloc <<= 2;
      break;
    default:
      as_bad (_("Invalid argument description: %d"), reg);
    }
d5576 19
a5594 2
  return new_reloc;
}
d5596 19
a5614 2
/* Parse a PA nullification completer (,n).  Return nonzero if the
   completer was found; return zero if no completer was found.  */
d5616 19
a5634 5
static int
pa_parse_nullif (s)
     char **s;
{
  int nullif;
d5636 19
a5654 13
  nullif = 0;
  if (**s == ',')
    {
      *s = *s + 1;
      if (strncasecmp (*s, "n", 1) == 0)
	nullif = 1;
      else
	{
	  as_bad (_("Invalid Nullification: (%c)"), **s);
	  nullif = 0;
	}
      *s = *s + 1;
    }
d5656 15
a5670 307
  return nullif;
}

/* Parse a non-negated compare/subtract completer returning the
   number (for encoding in instructions) of the given completer.  */

static int
pa_parse_nonneg_cmpsub_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "<<") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "<<=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "od") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a negated compare/subtract completer returning the
   number (for encoding in instructions) of the given completer.  */

static int
pa_parse_neg_cmpsub_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, ">>=") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, ">>") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "nsv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "ev") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a 64 bit compare and branch completer returning the number (for
   encoding in instructions) of the given completer.

   Nonnegated comparisons are returned as 0-7, negated comparisons are
   returned as 8-15.  */

static int
pa_parse_cmpb_64_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;

  cmpltr = -1;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "*") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "*=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "*<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "*<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "*<<") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "*<<=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*od") == 0)
	{
	  cmpltr = 7;
	}
      else if (strcasecmp (name, "*tr") == 0)
	{
	  cmpltr = 8;
	}
      else if (strcmp (name, "*<>") == 0)
	{
	  cmpltr = 9;
	}
      else if (strcmp (name, "*>=") == 0)
	{
	  cmpltr = 10;
	}
      else if (strcmp (name, "*>") == 0)
	{
	  cmpltr = 11;
	}
      else if (strcmp (name, "*>>=") == 0)
	{
	  cmpltr = 12;
	}
      else if (strcmp (name, "*>>") == 0)
	{
	  cmpltr = 13;
	}
      else if (strcasecmp (name, "*nsv") == 0)
	{
	  cmpltr = 14;
	}
      else if (strcasecmp (name, "*ev") == 0)
	{
	  cmpltr = 15;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  return cmpltr;
}

/* Parse a 64 bit compare immediate and branch completer returning the number
   (for encoding in instructions) of the given completer.  */

static int
pa_parse_cmpib_64_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;

  cmpltr = -1;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "*<<") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "*=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "*<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "*<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "*>>=") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "*<>") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*>=") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*>") == 0)
	{
	  cmpltr = 7;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  return cmpltr;
}
d5672 7
a5678 2
/* Parse a non-negated addition completer returning the number
   (for encoding in instructions) of the given completer.  */
d5680 4
a5683 9
static int
pa_parse_nonneg_add_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;
d5685 4
a5688 11
  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;
      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
d5690 7
a5696 1
      else if (strcmp (name, "<") == 0)
d5698 2
a5699 1
	  cmpltr = 2;
d5701 4
a5704 1
      else if (strcmp (name, "<=") == 0)
d5706 12
a5717 1
	  cmpltr = 3;
d5719 1
a5719 28
      else if (strcasecmp (name, "nuv") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcasecmp (name, "znv") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "od") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
d5722 1
a5722 5
  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
d5725 1
a5725 2
/* Parse a negated addition completer returning the number
   (for encoding in instructions) of the given completer.  */
d5727 2
a5728 3
static int
pa_parse_neg_add_cmpltr (s)
     char **s;
d5730 1
a5730 5
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;
d5732 2
a5733 53
  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;
      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcasecmp (name, "uv") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcasecmp (name, "vnz") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "nsv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "ev") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }
d5735 3
a5737 3
  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;
d5739 6
a5744 2
  return cmpltr;
}
d5746 1
a5746 78
/* Parse a 64 bit wide mode add and branch completer returning the number (for
   encoding in instructions) of the given completer.  */

static int
pa_parse_addb_64_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;
      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcasecmp (name, "nuv") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcasecmp (name, "*=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*<") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*<=") == 0)
	{
	  cmpltr = 7;
	}
      else if (strcmp (name, "tr") == 0)
	{
	  cmpltr = 8;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 9;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 10;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 11;
	}
      else if (strcasecmp (name, "uv") == 0)
	{
	  cmpltr = 12;
	}
      else if (strcasecmp (name, "*<>") == 0)
	{
	  cmpltr = 13;
	}
      else if (strcasecmp (name, "*>=") == 0)
	{
	  cmpltr = 14;
	}
      else if (strcasecmp (name, "*>") == 0)
d5748 23
a5770 8
	  cmpltr = 15;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
d5773 1
a5773 4
	{
	  cmpltr = -1;
	}
      **s = c;
d5776 15
a5790 3
  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;
d5792 3
a5794 1
  return cmpltr;
d5801 1
a5801 2
pa_align (bytes)
     int bytes;
d5819 1
a5819 2
pa_block (z)
     int z ATTRIBUTE_UNUSED;
d5849 1
a5849 2
pa_brtab (begin)
     int begin ATTRIBUTE_UNUSED;
d5869 1
a5869 2
pa_try (begin)
     int begin ATTRIBUTE_UNUSED;
a5889 17
/* Handle a .CALL pseudo-op.  This involves storing away information
   about where arguments are to be found so the linker can detect
   (and correct) argument location mismatches between caller and callee.  */

static void
pa_call (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  pa_call_args (&last_call_desc);
  demand_empty_rest_of_line ();
}

d5894 1
a5894 2
pa_call_args (call_desc)
     struct call_desc *call_desc;
d5937 16
d5955 2
a5956 4
static int
is_same_frag (frag1, frag2)
     fragS *frag1;
     fragS *frag2;
d5960 1
a5960 1
    return (FALSE);
d5962 1
a5962 1
    return (FALSE);
d5964 1
a5964 1
    return (TRUE);
d5968 1
a5968 1
    return (FALSE);
d5978 1
a5978 2
pa_build_unwind_subspace (call_info)
     struct call_info *call_info;
d6050 1
a6050 2
pa_callinfo (unused)
     int unused ATTRIBUTE_UNUSED;
d6192 1
d6194 1
a6194 2
pa_text (unused)
     int unused ATTRIBUTE_UNUSED;
d6207 1
d6209 1
a6209 2
pa_data (unused)
     int unused ATTRIBUTE_UNUSED;
d6241 1
a6241 2
pa_comm (unused)
     int unused ATTRIBUTE_UNUSED;
d6274 1
a6274 2
pa_end (unused)
     int unused ATTRIBUTE_UNUSED;
d6280 1
d6282 1
a6282 2
pa_enter (unused)
     int unused ATTRIBUTE_UNUSED;
d6295 1
d6297 1
a6297 2
pa_entry (unused)
     int unused ATTRIBUTE_UNUSED;
d6344 3
a6346 4
hppa_force_reg_syms_absolute (resultP, op, rightP)
     expressionS *resultP;
     operatorT op ATTRIBUTE_UNUSED;
     expressionS *rightP;
d6361 1
a6361 2
pa_equ (reg)
     int reg;
d6409 63
d6477 1
a6477 1
process_exit ()
d6509 1
a6509 2
pa_exit (unused)
     int unused ATTRIBUTE_UNUSED;
a6535 42
/* Process a .EXPORT directive.  This makes functions external
   and provides information such as argument relocation entries
   to callers.  */

static void
pa_export (unused)
     int unused ATTRIBUTE_UNUSED;
{
  char *name, c, *p;
  symbolS *symbol;

  name = input_line_pointer;
  c = get_symbol_end ();
  /* Make sure the given symbol exists.  */
  if ((symbol = symbol_find_or_make (name)) == NULL)
    {
      as_bad (_("Cannot define export symbol: %s\n"), name);
      p = input_line_pointer;
      *p = c;
      input_line_pointer++;
    }
  else
    {
      /* OK.  Set the external bits and process argument relocations.
         For the HP, weak and global are not mutually exclusive.
         S_SET_EXTERNAL will not set BSF_GLOBAL if WEAK is set.
         Call S_SET_EXTERNAL to get the other processing.  Manually
         set BSF_GLOBAL when we get back.  */
      S_SET_EXTERNAL (symbol);
      symbol_get_bfdsym (symbol)->flags |= BSF_GLOBAL;
      p = input_line_pointer;
      *p = c;
      if (!is_end_of_statement ())
	{
	  input_line_pointer++;
	  pa_type_args (symbol, 1);
	}
    }

  demand_empty_rest_of_line ();
}

d6539 1
a6539 3
pa_type_args (symbolP, is_export)
     symbolS *symbolP;
     int is_export;
a6546 1

d6662 61
a6722 7
#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
	  symbol_arg_reloc_info (symbolP) |= arg_reloc;
#endif
	  *input_line_pointer = c;
	}
      /* Privilege level.  */
      else if ((strncasecmp (name, "priv_lev", 8)) == 0)
a6723 2
	  p = input_line_pointer;
	  *p = c;
d6725 1
a6725 6
	  temp = atoi (input_line_pointer);
#ifdef OBJ_SOM
	  ((obj_symbol_type *) bfdsym)->tc_data.ap.hppa_priv_level = temp;
#endif
	  c = get_symbol_end ();
	  *input_line_pointer = c;
a6726 8
      else
	{
	  as_bad (_("Undefined .EXPORT/.IMPORT argument (ignored): %s"), name);
	  p = input_line_pointer;
	  *p = c;
	}
      if (!is_end_of_statement ())
	input_line_pointer++;
d6728 2
d6737 1
a6737 2
pa_import (unused)
     int unused ATTRIBUTE_UNUSED;
d6788 1
a6788 2
pa_label (unused)
     int unused ATTRIBUTE_UNUSED;
d6817 1
a6817 2
pa_leave (unused)
     int unused ATTRIBUTE_UNUSED;
d6831 1
a6831 2
pa_level (unused)
     int unused ATTRIBUTE_UNUSED;
d6871 1
a6871 2
pa_origin (unused)
     int unused ATTRIBUTE_UNUSED;
d6886 1
a6886 2
pa_param (unused)
     int unused ATTRIBUTE_UNUSED;
d6920 1
a6920 2
pa_proc (unused)
     int unused ATTRIBUTE_UNUSED;
d6937 1
a6937 1
  call_info = (struct call_info *) xmalloc (sizeof (struct call_info));
d6989 1
a6989 2
pa_procend (unused)
     int unused ATTRIBUTE_UNUSED;
a6990 1

d7062 1
a7062 2
exact_log2 (value)
     int value;
d7078 1
a7078 1
pa_check_current_space_and_subspace ()
d7092 1
a7092 3
pa_parse_space_stmt (space_name, create_flag)
     char *space_name;
     int create_flag;
d7100 1
a7100 1
  /* load default values */
d7212 1
a7212 2
pa_space (unused)
     int unused ATTRIBUTE_UNUSED;
d7331 1
a7331 2
pa_spnum (unused)
     int unused ATTRIBUTE_UNUSED;
d7360 1
a7360 2
pa_subspace (create_new)
     int create_new;
d7598 1
a7598 1
pa_spaces_begin ()
d7725 8
a7732 10
create_new_space (name, spnum, loadable, defined, private,
		  sort, seg, user_defined)
     char *name;
     int spnum;
     int loadable ATTRIBUTE_UNUSED;
     int defined;
     int private;
     int sort;
     asection *seg;
     int user_defined;
d7736 1
a7736 1
  chain_entry = (sd_chain_struct *) xmalloc (sizeof (sd_chain_struct));
d7741 1
a7741 1
  SPACE_NAME (chain_entry) = (char *) xmalloc (strlen (name) + 1);
d7807 14
a7820 15
create_new_subspace (space, name, loadable, code_only, comdat, common,
		     dup_common, is_zero, sort, access, space_index,
		     alignment, quadrant, seg)
     sd_chain_struct *space;
     char *name;
     int loadable ATTRIBUTE_UNUSED;
     int code_only ATTRIBUTE_UNUSED;
     int comdat, common, dup_common;
     int is_zero ATTRIBUTE_UNUSED;
     int sort;
     int access;
     int space_index ATTRIBUTE_UNUSED;
     int alignment ATTRIBUTE_UNUSED;
     int quadrant;
     asection *seg;
d7824 1
a7824 1
  chain_entry = (ssd_chain_struct *) xmalloc (sizeof (ssd_chain_struct));
d7828 1
a7828 1
  SUBSPACE_NAME (chain_entry) = (char *) xmalloc (strlen (name) + 1);
d7882 14
a7895 16
update_subspace (space, name, loadable, code_only, comdat, common, dup_common,
		 sort, zero, access, space_index, alignment, quadrant, section)
     sd_chain_struct *space;
     char *name;
     int loadable ATTRIBUTE_UNUSED;
     int code_only ATTRIBUTE_UNUSED;
     int comdat;
     int common;
     int dup_common;
     int zero ATTRIBUTE_UNUSED;
     int sort;
     int access;
     int space_index ATTRIBUTE_UNUSED;
     int alignment ATTRIBUTE_UNUSED;
     int quadrant;
     asection *section;
d7913 1
a7913 2
is_defined_space (name)
     char *name;
d7920 2
a7921 4
    {
      if (strcmp (SPACE_NAME (chain_pointer), name) == 0)
	return chain_pointer;
    }
d7934 1
a7934 2
pa_segment_to_space (seg)
     asection *seg;
d7942 2
a7943 4
    {
      if (space_chain->sd_seg == seg)
	return space_chain;
    }
d7956 1
a7956 1
    
d7962 1
a7962 2
is_defined_subspace (name)
     char *name;
d7992 1
a7992 3
pa_subsegment_to_subspace (seg, subseg)
     asection *seg;
     subsegT subseg;
d8024 1
a8024 2
pa_find_space_by_number (number)
     int number;
d8044 1
a8044 3
pa_subspace_start (space, quadrant)
     sd_chain_struct *space;
     int quadrant;
d8062 1
a8062 2
pa_stringer_aux (s)
     char *s;
d8080 1
a8080 2
pa_stringer (append_zero)
     int append_zero;
d8161 1
a8161 2
pa_version (unused)
     int unused ATTRIBUTE_UNUSED;
d8172 1
a8172 2
pa_compiler (unused)
     int unused ATTRIBUTE_UNUSED;
d8183 1
a8183 2
pa_copyright (unused)
     int unused ATTRIBUTE_UNUSED;
d8193 1
a8193 2
pa_cons (nbytes)
     int nbytes;
d8202 1
a8202 2
pa_float_cons (float_type)
     int float_type;
d8211 1
a8211 2
pa_fill (unused)
     int unused ATTRIBUTE_UNUSED;
d8225 1
a8225 2
pa_lcomm (needs_align)
     int needs_align;
d8239 1
a8239 2
pa_lsym (unused)
     int unused ATTRIBUTE_UNUSED;
d8250 73
d8345 1
a8345 2
hppa_fix_adjustable (fixp)
     fixS *fixp;
d8466 1
a8466 2
hppa_force_relocation (fixp)
     struct fix *fixp;
a8539 62
/* Mark the end of a function so that it's possible to compute
   the size of the function in elf_hppa_final_processing.  */

static void
hppa_elf_mark_end_of_function ()
{
  /* ELF does not have EXIT relocations.  All we do is create a
     temporary symbol marking the end of the function.  */
  char *name;

  if (last_call_info == NULL || last_call_info->start_symbol == NULL)
    {
      /* We have already warned about a missing label,
	 or other problems.  */
      return;
    }

  name = (char *) xmalloc (strlen ("L$\001end_")
			   + strlen (S_GET_NAME (last_call_info->start_symbol))
			   + 1);
  if (name)
    {
      symbolS *symbolP;

      strcpy (name, "L$\001end_");
      strcat (name, S_GET_NAME (last_call_info->start_symbol));

      /* If we have a .exit followed by a .procend, then the
	 symbol will have already been defined.  */
      symbolP = symbol_find (name);
      if (symbolP)
	{
	  /* The symbol has already been defined!  This can
	     happen if we have a .exit followed by a .procend.

	     This is *not* an error.  All we want to do is free
	     the memory we just allocated for the name and continue.  */
	  xfree (name);
	}
      else
	{
	  /* symbol value should be the offset of the
	     last instruction of the function */
	  symbolP = symbol_new (name, now_seg, (valueT) (frag_now_fix () - 4),
				frag_now);

	  assert (symbolP);
	  S_CLEAR_EXTERNAL (symbolP);
	  symbol_table_insert (symbolP);
	}

      if (symbolP)
	last_call_info->end_symbol = symbolP;
      else
	as_bad (_("Symbol '%s' could not be created."), name);

    }
  else
    as_bad (_("No memory for symbol name."));

}

d8546 1
a8546 1
elf_hppa_final_processing ()
d8564 1
a8564 2
pa_vtable_entry (ignore)
     int ignore ATTRIBUTE_UNUSED;
d8572 2
a8573 2
      struct hppa_fix_struct *hppa_fix = (struct hppa_fix_struct *)
	obstack_alloc (&notes, sizeof (struct hppa_fix_struct));
d8585 1
a8585 2
pa_vtable_inherit (ignore)
     int ignore ATTRIBUTE_UNUSED;
d8593 2
a8594 2
      struct hppa_fix_struct *hppa_fix = (struct hppa_fix_struct *)
	obstack_alloc (&notes, sizeof (struct hppa_fix_struct));
d8605 90
@


1.129
log
@	Bug gas/1896
	* config/tc-hppa.c (hppa_fix_adjustable): Don't reject for reduction
	R_HPPA relocations that are 32-bits wide.
	* gas/all/redef2.d: Allow "$DATA$" as well as ".data" in matches.
	* gas/all/weakref1.d: Allow "$CODE$" as well as ".text" in matches.
	* gas/hppa/reloc/reloc.exp: Adjust regexp for new output.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d4199 5
a4203 4
	  relocs[0]->sym_ptr_ptr = (asymbol **) &(bfd_abs_symbol);
	  relocs[0]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[0]);
d4208 3
a4210 3
	  relocs[1]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[1]);
d4215 3
a4217 3
	  relocs[2]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[2]);
d4220 5
a4224 4
	  relocs[3]->sym_ptr_ptr = (asymbol **) &(bfd_abs_symbol);
	  relocs[3]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[3]);
d4227 5
a4231 4
	  relocs[4]->sym_ptr_ptr = (asymbol **) &(bfd_abs_symbol);
	  relocs[4]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[4]);
@


1.128
log
@	* config/tc-hppa.c (pa_comm): Set bfd_com_section segment.
@
text
@d8399 2
a8400 6
   Reject reductions involving symbols with external scope; such
   reductions make life a living hell for object file editors.

   FIXME.  Also reject R_HPPA relocations which are 32bits wide in
   the code space.  The SOM BFD backend doesn't know how to pull the
   right bits out of an instruction.  */
a8412 11
#ifdef OBJ_SOM
  /* Reject reductions of symbols in 32bit relocs unless they
     are fake labels.  */
  if (fixp->fx_r_type == R_HPPA
      && hppa_fix->fx_r_format == 32
      && strncmp (S_GET_NAME (fixp->fx_addsy),
		  FAKE_LABEL_NAME,
		  strlen (FAKE_LABEL_NAME)))
    return 0;
#endif

@


1.127
log
@	PR gas/1804
	* config/tc-hppa.c (md_apply_fix): Use number_to_chars_bigendian to
	output constant data.
@
text
@d6403 1
a6403 1
      S_SET_SEGMENT (symbol, bfd_und_section_ptr);
@


1.126
log
@	PR binutils/941
	* config/tc-hppa.c (pa_ip): Use as_bad instead of as_fatal when an
	unknown opcode is found.
@
text
@d4439 1
a4439 1
  unsigned char *buf;
d4473 1
a4473 2
  /* There should have been an HPPA specific fixup associated
     with the GAS fixup.  */
d4483 10
a4492 2
  buf = (unsigned char *) (fixP->fx_frag->fr_literal + fixP->fx_where);
  insn = bfd_get_32 (stdoutput, buf);
d4662 1
a4662 1
  bfd_put_32 (stdoutput, insn, buf);
@


1.125
log
@	* config/tc-hppa.c (strict): Don't initialize.  Update comment.
	(pa_ip): Promote from PA 1.0 to 1.1 immediately when 1.1 match is
	found.  Simplify handling of "ma" and "mb" completers.

	* hppa.h (FLAG_STRICT): Revise comment.
	(pa_opcode): Revise ordering rules.  Add/move strict pa10 variants
	before corresponding pa11 opcodes.  Add strict pa10 register-immediate
	entries for "fdc".
@
text
@d1625 2
a1626 1
      as_fatal (_("Unknown opcode: `%s'"), str);
@


1.124
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d774 1
a774 1
/* Nonzero when strict syntax checking is enabled.  Zero otherwise.
d776 7
a782 3
   Each opcode in the table has a flag which indicates whether or not
   strict syntax checking should be enabled for that instruction.  */
static int strict = 0;
a1587 1
  int need_promotion = FALSE;
a1591 1
  struct pa_opcode *promoted_insn = NULL;
d1652 1
a1652 1
      if (insn->arch >= 20
a1848 1
			/* When in strict mode this is a match failure.  */
d1851 1
a1876 1
			int found = 0;
d1882 1
a1882 1
			    found = 1;
d1888 1
a1888 1
			    found = 1;
d1890 2
a1891 3

			/* When in strict mode, pass through for cache op.  */
			if (!found && strict)
d1895 1
a1895 2
			    if (!found)
			      as_bad (_("Invalid Short Load/Store Completer."));
d1948 1
a1948 1
			/* When in strict mode this is a match failure.  */
d3964 2
a3965 1
	  && bfd_get_mach (stdoutput) < insn->arch)
d3967 2
a3968 11
	  if (need_promotion)
	    {
	      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, insn->arch))
		as_warn (_("could not update architecture and machine"));
	    }
	  else
	    {
	      match = FALSE;
	      if (!promoted_insn)
		promoted_insn = insn;
	    }
a3983 7
	      if (promoted_insn)
		{
		  insn = promoted_insn;
		  need_promotion = TRUE;
		  s = argstart;
		  continue;
		}
@


1.123
log
@	* tc-hppa.c (pa_ip): Reject match for '#' immediate if not pa20.
@
text
@d1290 4
@


1.122
log
@	* config/tc-hppa.c (pa_ip): Search entire mnemonic before considering
	promoted match.
@
text
@d3069 2
@


1.121
log
@	* config/tc-hppa.c (pa_block): Allocate just one byte for the
	fill pattern.
@
text
@d1580 1
d1585 1
d3961 11
a3971 2
	  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, insn->arch))
	    as_warn (_("could not update architecture and machine"));
d3987 7
@


1.120
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
a5939 2
  char *p;
  long int temp_fill;
a5940 1
  unsigned int i;
d5954 1
a5954 11

  /* Always fill with zeros, that's what the HP assembler does.  */
  temp_fill = 0;

  p = frag_var (rs_fill, (int) temp_size, (int) temp_size,
		(relax_substateT) 0, (symbolS *) 0, (offsetT) 1, NULL);
  memset (p, 0, temp_size);

  /* Convert 2 bytes at a time.  */

  for (i = 0; i < temp_size; i += 2)
d5956 3
a5958 3
      md_number_to_chars (p + i,
			  (valueT) temp_fill,
			  (int) ((temp_size - i) > 2 ? 2 : (temp_size - i)));
@


1.119
log
@	* config/tc-hppa.c (pa_ip): Promote architecture from PA 1.0 to 1.1
	only if an instruction match is found.
@
text
@d1178 1
a1178 1
/* Variant of CHECK_FIELD for use in md_apply_fix3 and other places where
d4425 1
a4425 1
md_apply_fix3 (fixP, valP, seg)
@


1.118
log
@gas/
        * frags.c (frag_grow): Don't be too greedy in allocating memory.
        * config/tc-hppa.c (pa_block): Check arguments to .block[z].

gas/testsuite/
        * gas/hppa/parse/block1.s: Use official limit (0x3fffffff) for
        .block.
@
text
@d1644 1
a1644 5
      /* If this instruction is specific to a particular architecture,
	 then set a new architecture.  */
      /* But do not automatically promote to pa2.0.  The automatic promotion
	 crud is for compatibility with HP's old assemblers only.  */
      if (insn->arch < 20
d1646 1
a1646 9
	{
	  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, insn->arch))
	    as_warn (_("could not update architecture and machine"));
	}
      else if (bfd_get_mach (stdoutput) < insn->arch)
	{
	  match = FALSE;
	  goto failed;
	}
d3953 10
@


1.117
log
@Update the address and phone number of the FSF
@
text
@d5954 6
@


1.116
log
@PR gas/818
* config/tc-hppa.c (pre_defined_registers): Fix %farg[0-3] synonyms.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.115
log
@update copyright dates
@
text
@d814 1
d858 4
a861 4
  {"%farg0",  5},
  {"%farg1",  6},
  {"%farg2",  7},
  {"%farg3",  8},
@


1.114
log
@	* config/obj-som.c (adjust_stab_sections): Add prototype.
	(obj_som_compiler, obj_som_version, obj_som_copyright,
	adjust_stab_sections): Add ATTRIBUTE_UNUSED to unused arguments.
	* config/tc-hppa.c (update_subspace):  Likewise.
	(is_defined_subspace): Amplify comment.
	* config/obj-som.h (som_frob_file): Add prototype.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
@


1.113
log
@	* config/tc-hppa.c (log2): Rename to exact_log2.
	(pa_next_subseg): Delete unused function.
	(create_new_space): Mark unused arguments with ATTRIBUTE_UNUSED.
	(create_new_subspace): Likewise.
@
text
@d7985 2
a7986 2
     int loadable;
     int code_only;
d7990 1
a7990 1
     int zero;
d7993 2
a7994 2
     int space_index;
     int alignment;
d8056 2
a8057 2
/* Return the space chain entry for the subspace with the name NAME or
   NULL if no such subspace exists.
d8059 5
@


1.112
log
@	Bug gas/213
	* config/tc-hppa.c (hppa_fix_adjustable): Allow reduction of fake
	labels.  Fix warning.
@
text
@d550 1
a550 1
static int log2 PARAMS ((int));
a576 1
static int pa_next_subseg PARAMS ((sd_chain_struct *));
d5930 2
a5931 2
  if (log2 (bytes) != -1)
    record_alignment (current_subspace->ssd_seg, log2 (bytes));
d7152 1
a7152 1
log2 (value)
d7556 1
a7556 1
		  if (log2 (alignment) == -1)
d7662 1
a7662 1
      record_alignment (section, log2 (alignment));
d7825 1
a7825 1
     int loadable;
d7910 4
a7913 1
     int loadable, code_only, comdat, common, dup_common, is_zero;
d7916 2
a7917 2
     int space_index;
     int alignment;
a8163 10

/* FIXME.  Needs documentation.  */
static int
pa_next_subseg (space)
     sd_chain_struct *space;
{

  space->sd_last_subseg++;
  return space->sd_last_subseg;
}
@


1.111
log
@	* som.c (struct som_misc_symbol_info): Add is_comdat, is_common and
	dup_common fields.
	(setup_sections): Use som_subspace_dictionary_record struct instead
	subspace_dictionary_record.  Set SEC_LINK_ONCE if subspace is
	is_comdat, is_common or dup_common.
	(som_prep_headers): Use som_subspace_dictionary_record struct.  Set
	is_comdat, is_common and dup_common in section subspace_dict from
	copy_data.
	(som_begin_writing): Use som_subspace_dictionary_record struct.
	(som_finish_writing): Likewise.
	(som_bfd_derive_misc_symbol_info): Add support to set is_comdat,
	is_common and dup_common flags in info for symbol.  Add comment
	regarding linker support for these fields.  Slightly reorganize
	function.
	(som_build_and_write_symbol_table): Set is_comdat, is_common and
	dup_common fields in symbol table from symbol info.
	(bfd_som_set_subsection_attributes): Add comdat, common and dup_common
	arguments.  Set corresponding fields in copy_data.  Change all callers.
	(som_bfd_ar_write_symbol_stuff): Set dup_common flag in library
	symbol table.
	(som_vec): Add SEC_LINK_ONCE to applicable section flags.
	* som.h (som_subspace_dictionary_record): Define.
	(som_copyable_section_data_struct): Add is_comdat, is_common and
	dup_common fields.
	(som_section_data_struct): Use som_subspace_dictionary_record struct
	instead of subspace_dictionary_record.
	(bfd_boolean bfd_som_set_subsection_attributes): Adjust prototype.
	* config/obj-som.c (obj_som_init_stab_section): Add new arguments in
	call to obj_set_subsection_attributes.
	(obj_som_init_stab_section): Likewise.
	* config/tc-hppa.c (default_subspace_dict): Add comdat field.
	(pa_def_subspaces): Provide comdat default.
	(pa_subspace): Handle new "comdat" parameter.  Set SEC_LINK_ONCE and
	not SEC_IS_COMMON if section is comdat, common or dup_common.  Update
	calls to create_new_subspace and update_subspace to pass comdat flag.
	(create_new_subspace, update_subspace): Add new comdat argument.  Use
	it in calls to obj_set_subsection_attributes.
	* doc/c-hppa.texi (.subspa, .nsubspa): Document new comdat parameter
	and use of comdat, common and dup_comm parameters.
@
text
@d8405 1
d8407 1
d8413 7
a8419 2
  /* Reject reductions of symbols in 32bit relocs.  */
  if (fixp->fx_r_type == R_HPPA && hppa_fix->fx_r_format == 32)
@


1.110
log
@	* elf-hppa.h (elf_hppa_reloc_final_type): Handle selectors for
	R_PARISC_PCREL32 and R_PARISC_PCREL64 relocations.
	* tc-hppa.c (cons_fix_new_hppa): Check for PC relative base type.
	(pa_comm): Set BSF_OBJECT in symbol flags.
@
text
@d366 3
d561 1
a561 1
						      int, int, int,
d567 1
a567 1
						  int, int, int,
d1123 6
a1128 6
  {"$CODE$", 1, 1, 1, 0, 0, 0, 24, 0x2c, 0, 8, 0, 0, SUBSEG_CODE},
  {"$DATA$", 1, 1, 0, 0, 0, 0, 24, 0x1f, 1, 8, 1, 1, SUBSEG_DATA},
  {"$LIT$", 1, 1, 0, 0, 0, 0, 16, 0x2c, 0, 8, 0, 0, SUBSEG_LIT},
  {"$MILLICODE$", 1, 1, 0, 0, 0, 0, 8, 0x2c, 0, 8, 0, 0, SUBSEG_MILLI},
  {"$BSS$", 1, 1, 0, 0, 0, 1, 80, 0x1f, 1, 8, 1, 1, SUBSEG_BSS},
  {NULL, 0, 1, 0, 0, 0, 0, 255, 0x1f, 0, 4, 0, 0, 0}
d7460 1
a7460 1
  char loadable, code_only, common, dup_common, zero, sort;
d7486 1
d7521 1
d7585 5
d7622 11
a7632 2
      if (common || dup_common)
	flags |= SEC_IS_COMMON;
d7674 3
a7676 3
					    code_only, common, dup_common,
					    sort, zero, access, space_index,
					    alignment, quadrant,
d7680 1
a7680 1
						code_only, common,
d7683 1
a7683 1
					      alignment, quadrant, section);
d7804 1
d7906 1
a7906 1
create_new_subspace (space, name, loadable, code_only, common,
d7911 1
a7911 1
     int loadable, code_only, common, dup_common, is_zero;
d7968 2
a7969 2
  obj_set_subsection_attributes (seg, space->sd_seg, access,
				 sort, quadrant);
d7979 2
a7980 2
update_subspace (space, name, loadable, code_only, common, dup_common, sort,
		 zero, access, space_index, alignment, quadrant, section)
d7985 1
d8001 2
a8002 2
  obj_set_subsection_attributes (section, space->sd_seg, access,
				 sort, quadrant);
@


1.109
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d1402 2
d6391 1
@


1.109.6.1
log
@Merge to 2.15 branch.
@
text
@a1401 2
  else if (is_PC_relative (*exp))
    rel_type = R_HPPA_PCREL_CALL;
a6388 1
      symbol_get_bfdsym (symbol)->flags |= BSF_OBJECT;
@


1.108
log
@	* config/tc-hppa.c: Fix comment typos.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-iq2000.h: Likewise.
@
text
@d599 1
a599 1
/* File and gloally scoped variable declarations.  */
@


1.107
log
@Change target of hppa-netbsd port
@
text
@d46 1
a46 1
/* A "convient" place to put object file dependencies which do
d751 1
a751 1
/* Points to the end of an expression just parsed by get_expressoin
d1161 1
a1161 1
/* Simple range checking for FIELD againt HIGH and LOW bounds.
d1189 1
a1189 1
/* Simple alignment checking for FIELD againt ALIGN (a power of two).
d1546 1
a1546 1
  /* Get somewhere to put the assembled instrution.  */
d1642 1
a1642 1
	 crud is for compatability with HP's old assemblers only.  */
d4848 1
a4848 1
	     compatability with the braindamaged HP assemblers.  */
d5219 1
a5219 1
     The PA assembly syntax is ambigious in a variety of ways.  Consider
d5223 1
a5223 1
     If we get a modulo expresion When looking for an absolute, we try
d5361 1
a5361 1
   number (for encoding in instrutions) of the given completer.  */
d5432 1
a5432 1
   number (for encoding in instrutions) of the given completer.  */
d5507 1
a5507 1
   encoding in instrutions) of the given completer.
d5604 1
a5604 1
   (for encoding in instrutions) of the given completer.  */
d5666 1
a5666 1
   (for encoding in instrutions) of the given completer.  */
d5736 1
a5736 1
   (for encoding in instrutions) of the given completer.  */
d5810 1
a5810 1
   encoding in instrutions) of the given completer.  */
d5977 1
a5977 1
  /* The BRTAB relocations are only availble in SOM (to denote
d6003 1
a6003 1
  /* The TRY relocations are only availble in SOM (to denote
d6426 1
a6426 1
   procesure.  */
d6784 1
a6784 1
      /* Privelege level.  */
d6839 1
a6839 1
	  /* Sigh.  To be compatable with the HP assembler and to help
d7068 1
a7068 1
/* Process the syntatical end of a procedure.  Make sure all the
d7277 1
a7277 1
     the first occurence of a built-in space.  */
d8465 1
a8465 1
     mutiples takes us up to 8192 with an offset of -4096.
@


1.106
log
@	* config/tc-hppa.c (pa_ip): Check for invalid 64-bit conditions.
@
text
@d493 1
a493 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
d650 1
a650 1
#if defined (OBJ_ELF) && defined (TE_LINUX)
d660 1
a660 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
d667 1
a667 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
d708 1
a708 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
d855 4
d955 1
d1021 8
d6320 1
a6320 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
d6400 1
a6400 1
#endif /* !(defined (OBJ_ELF) && defined (TE_LINUX)) */
@


1.105
log
@	* config/tc-hppa.c (hppa_symbol_chars): Remove `,' and `!'.
	* testsuite/gas/hppa/parse/parse.exp: Add "space.s".
	* testsuite/gas/hppa/parse/space.s: New file to test spaces.
@
text
@a2359 1
			name = s;
d2421 1
a2421 1
			else if (*args == 'a')
a2526 1
			name = s;
d2588 1
a2588 1
			else if (*args != 'S')
d2711 1
a2711 1
			else if (*args != 'L')
d2766 1
a2766 1
			else if (*args != 'X')
d2878 1
a2878 1
			else if (*args != 'U')
@


1.104
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d625 4
a628 2
/* Those characters can be suffixes of opcode names.  */
const char hppa_symbol_chars[] = ",*!?=<>";
@


1.103
log
@* config/tc-hppa.c (hppa_symbol_chars): New.
* config/tc-hppa.h (tc_symbol_chars): Likewise.
@
text
@a672 3
#ifdef OBJ_ELF
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
#endif
a681 3
#ifdef OBJ_ELF
  {"loc", dwarf2_directive_loc, 0 },
#endif
@


1.102
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d625 3
@


1.102.2.1
log
@* config/tc-hppa.c (hppa_symbol_chars): New.
* config/tc-hppa.h (tc_symbol_chars): Likewise.
@
text
@a624 3
/* Those characters can be suffixes of opcode names.  */
const char hppa_symbol_chars[] = ",*!?=<>";

@


1.102.2.2
log
@	* config/tc-hppa.c (hppa_symbol_chars): Revert 2003-04-28 change.
	* config/tc-hppa.h (tc_symbol_chars): Likewise.
	* config/tc-ppc.c (ppc_symbol_chars): Revert 2003-04-24 change.
	* config/tc-ppc.h (tc_symbol_chars): Likewise.
	* app.c (do_scrub_chars): Revert 2003-04-23 and 2003-04-22 changes.
@
text
@d625 3
@


1.101
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2002 Free Software Foundation, Inc.
d8521 1
a8521 1
  if (S_FORCE_RELOC (fixp->fx_addsy))
@


1.100
log
@        * config/tc-hppa.c (md_apply_fix3): Don't set fx_done for
        marker relocations such as ENTRY/EXIT.
        * config/tc-hppa.h (MD_APPLY_SYM_VALUE): Definition applies
        to both OBJ_ELF and OBJ_SOM.
@
text
@d3952 1
a3952 1
      if (match == FALSE)
d4683 1
a4683 1
  boolean have_prefix;
d4822 1
a4822 1
	      have_prefix = true;
@


1.99
log
@gas reloc rewrite.
@
text
@a4421 3
  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;

d4447 3
@


1.98
log
@	* config/tc-arc.c (md_pseudo_table <dwarf2_directive_file>): Cast.
	* config/tc-frv.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@a4485 7
  /* This is truly disgusting.  The machine independent code blindly
     adds in the value of the symbol being relocated against.  Damn!  */
  else if (fmt == 32
	   && fixP->fx_addsy != NULL
	   && S_GET_SEGMENT (fixP->fx_addsy) != bfd_com_section_ptr)
    new_val = hppa_field_adjust (* valP - S_GET_VALUE (fixP->fx_addsy),
				 0, hppa_fixP->fx_r_field);
a8421 4
  if (fixp->fx_addsy && (S_IS_EXTERNAL (fixp->fx_addsy)
			 || S_IS_WEAK (fixp->fx_addsy)))
    return 0;

d8431 1
a8431 5
    {
      /* Apparently sy_used_in_reloc never gets set for sub symbols.  */
      symbol_mark_used_in_reloc (fixp->fx_subsy);
      return 0;
    }
d8521 1
a8521 1
  if (S_IS_EXTERNAL (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
@


1.97
log
@	* gas/config/tc-hppa.c (pa_ip): Replace "L$0\001" with FAKE_LABEL_NAME.
	(hppa_force_relocation): Check if a stub just before the start symbol
	of the last call_info is reachable before forcing relocation.  Fix
	typo.
@
text
@d671 1
a671 1
  {"file", dwarf2_directive_file, 0 },
@


1.96
log
@	* config/obj-coff.c: Fix formatting.
	* config/obj-elf.c: Likewise.
	* config/tc-alpha.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-hppa.c: Likewise.
@
text
@d3254 1
a3254 1
			      "L$0\001"))
d3286 1
a3286 1
			      "L$0\001"))
d3317 1
a3317 1
			      "L$0\001"))
d3347 1
a3347 1
			      "L$0\001"))
d8550 2
a8551 1
      valueT distance;
d8553 8
a8560 6
      distance = (fixp->fx_offset + S_GET_VALUE (fixp->fx_addsy)
		  - md_pcrel_from (fixp) - 8);
      if (distance + 8388608 >= 16777216
	  || (hppa_fixp->fx_r_format == 17 && distance + 262144 >= 524288)
#ifdef OBJ_ELF
	  || (hppa_fixp->fx_r_format == 12 && distance + 8192 >= 16384)
d8562 9
d8585 1
a8585 1
   the size of the function in hppa_elf_final_processing.  */
@


1.95
log
@2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>

        * config/tc-hppa.c (md_apply_fix3): Add cast.
        (hppa_fix_adjustable): Adjust list of selectors using e_lrsel and
        e_rrsel.
@
text
@d1292 1
a1292 1
 	  && current_space == label_chain->lss_space && label_chain->lss_label
d1295 1
a1295 1
 	  && now_seg == label_chain->lss_segment && label_chain->lss_label
d2337 4
a2340 4
 		  /* Handle FP compare conditions.  */
 		  case 'f':
 		    cond = pa_parse_fp_cmp_cond (&s);
 		    INSERT_FIELD_AND_CONTINUE (opcode, cond, 0);
d2345 2
a2346 2
 		    cmpltr = 0;
 		    flag = 0;
d4243 2
a4244 2
          relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
          *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
d4252 2
a4253 2
          relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
          *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
d5230 1
a5230 1
        s++;
@


1.94
log
@	* config/tc-hppa.c: Update copyright date.
@
text
@d4462 1
a4462 1
  buf = fixP->fx_frag->fr_literal + fixP->fx_where;
a8400 1
    case R_PARISC_DLTIND21L:
a8402 4
    case R_PARISC_LTOFF_FPTR21L:
    case R_PARISC_LTOFF_TP21L:
    case R_PARISC_PCREL21L:
    case R_PARISC_PLABEL21L:
a8409 3
    case R_PARISC_DLTIND14R:
    case R_PARISC_DLTIND14DR:
    case R_PARISC_DLTIND14WR:
d8416 3
a8418 9
    case R_PARISC_PCREL14R:
    case R_PARISC_PCREL17R:
    case R_PARISC_PLABEL14R:
    case R_PARISC_LTOFF_FPTR14R:
    case R_PARISC_LTOFF_FPTR14DR:
    case R_PARISC_LTOFF_FPTR14WR:
    case R_PARISC_LTOFF_TP14R:
    case R_PARISC_LTOFF_TP14DR:
    case R_PARISC_LTOFF_TP14WR:
@


1.93
log
@	* config/tc-hppa.c (hppa_fix_adjustable): Don't adjust final types
	that implicitly use LR and RR selectors.
@
text
@d2 2
a3 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.92
log
@        * config/tc-hppa.c (pa_ip): Handle new 'c' mode completers,
        'X', 'M', and 'A'.
@
text
@d60 1
d63 1
d8378 1
d8390 51
a8440 3
  if (fixp->fx_r_type == (int) R_PARISC_GNU_VTINHERIT
      || fixp->fx_r_type ==  (int) R_PARISC_GNU_VTENTRY)
    return 0;
@


1.92.2.1
log
@John David Anglin's 2002-02-12 mainline changes
@
text
@d2 2
a3 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002 Free Software Foundation, Inc.
a59 1
#define elf_hppa_reloc_final_type elf64_hppa_reloc_final_type
a61 1
#define elf_hppa_reloc_final_type elf32_hppa_reloc_final_type
a8375 1
  reloc_type code;
d8387 3
a8389 51
  /* LR/RR selectors are implicitly used for a number of different relocation
     types.  We must ensure that none of these types are adjusted (see below)
     even if they occur with a different selector.  */
  code = elf_hppa_reloc_final_type (stdoutput, fixp->fx_r_type,
		  		    hppa_fix->fx_r_format,
				    hppa_fix->fx_r_field);

  switch (code)
    {
    /* Relocation types which use e_lrsel.  */
    case R_PARISC_DIR21L:
    case R_PARISC_DLTIND21L:
    case R_PARISC_DLTREL21L:
    case R_PARISC_DPREL21L:
    case R_PARISC_LTOFF_FPTR21L:
    case R_PARISC_LTOFF_TP21L:
    case R_PARISC_PCREL21L:
    case R_PARISC_PLABEL21L:
    case R_PARISC_PLTOFF21L:

    /* Relocation types which use e_rrsel.  */
    case R_PARISC_DIR14R:
    case R_PARISC_DIR14DR:
    case R_PARISC_DIR14WR:
    case R_PARISC_DIR17R:
    case R_PARISC_DLTIND14R:
    case R_PARISC_DLTIND14DR:
    case R_PARISC_DLTIND14WR:
    case R_PARISC_DLTREL14R:
    case R_PARISC_DLTREL14DR:
    case R_PARISC_DLTREL14WR:
    case R_PARISC_DPREL14R:
    case R_PARISC_DPREL14DR:
    case R_PARISC_DPREL14WR:
    case R_PARISC_PCREL14R:
    case R_PARISC_PCREL17R:
    case R_PARISC_PLABEL14R:
    case R_PARISC_LTOFF_FPTR14R:
    case R_PARISC_LTOFF_FPTR14DR:
    case R_PARISC_LTOFF_FPTR14WR:
    case R_PARISC_LTOFF_TP14R:
    case R_PARISC_LTOFF_TP14DR:
    case R_PARISC_LTOFF_TP14WR:

    /* Other types that we reject for reduction.  */
    case R_PARISC_GNU_VTENTRY:
    case R_PARISC_GNU_VTINHERIT:
      return 0;
    default:
      break;
    }
@


1.92.2.2
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.

	Merge from mainline.
	2002-03-12  Andreas Schwab  <schwab@@suse.de>
	* config/tc-ia64.c (fixup_unw_records): Clear region when seeing a
	body record so that an error is given for misplaced .save
	pseudo-ops.

	2002-03-09  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.h (REX_OPCODE): Define.
	(REX_MODE64, REX_EXTX, REX_EXTY, REX_EXTZ): Define.
	(rex_byte): typedef to int.
	* config/tc-i386.c: Group prototypes and vars together.
	Formatting fixes.  Remove occurrences of "register" keyword.
	(true): Delete.
	(false): Delete.
	(mode_from_disp_size): Add INLINE keyword to prototype.
	(fits_in_signed_byte): Likewise.
	(fits_in_unsigned_byte): Likewise.
	(fits_in_unsigned_word): Likewise.
	(fits_in_signed_word): Likewise.
	(fits_in_unsigned_long): Likewise.
	(fits_in_signed_long): Likewise.
	(type_names): Constify.
	(intel_float_operand): Constify param.
	(add_prefix): Use REX_OPCODE.
	(md_assemble): Likewise.  Modify for changed rex_byte.
	(parse_insn): Split out of md_assemble.
	(parse_operands): Likewise.
	(swap_operands): Likewise.
	(optimize_imm): Likewise.
	(optimize_disp): Likewise.
	(match_template): Likewise.
	(check_string): Likewise.
	(process_suffix): Likewise.
	(check_byte_reg): Likewise.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
	(finalize_imm): Likewise.
	(process_operands): Likewise.
	(build_modrm_byte): Likewise.
	(output_insn): Likewise.
	(output_branch): Likewise.
	(output_jump): Likewise.
	(output_interseg_jump): Likewise.
	(output_disp): Likewise.
	(output_imm): Likewise.

	2002-03-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_gen_reloc): Don't attempt to handle 8 byte
	relocs except when BFD64.
	* write.c (number_to_chars_bigendian): Don't abort when N is
	larger than sizeof (VAL).
	(number_to_chars_littleendian): Likewise.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* config/tc-hppa.c (md_apply_fix3): Add cast.
	(hppa_fix_adjustable): Adjust list of selectors using e_lrsel and
	e_rrsel.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* config/obj-elf.c (special_section): Add .init_array,
	.fini_array and .preinit_array.
	* config/tc-ia64.h (ELF_TC_SPECIAL_SECTIONS): Remove
	.init_array and .fini_array.

	2002-03-01  Jakub Jelinek  <jakub@@redhat.com>
	* config/obj-elf.c (elf_copy_symbol_attributes): Don't copy
	visibility.
	(obj_frob_symbol): Copy visibility.
@
text
@d4462 1
a4462 1
  buf = (unsigned char *) (fixP->fx_frag->fr_literal + fixP->fx_where);
d8401 1
d8404 4
d8415 3
d8424 9
a8432 3
    case R_PARISC_PLTOFF14R:
    case R_PARISC_PLTOFF14DR:
    case R_PARISC_PLTOFF14WR:
@


1.91
log
@2001-11-15  H.J. Lu  <hjl@@gnu.org>

	* config/tc-hppa.c (md_apply_fix3): Fix a typo.
@
text
@d1813 1
d1852 1
d1892 1
a1892 1
		   /* 'J', 'm' and 'q' are the same, except for where they
d1894 1
a1894 1
		   if (*args == 'm')
d1920 1
@


1.90
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d4409 1
a4409 1
     valueT *valp;
@


1.89
log
@	* config/tc-alpha.c: Fix comment typos.
	* config/tc-cris.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mn10200.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d1161 1
a1161 1
/* Variant of CHECK_FIELD for use in md_apply_fix and other places where
d4406 2
a4407 2
int
md_apply_fix (fixP, valp)
d4410 1
d4417 3
d4429 1
a4429 1
    return 1;
d4436 2
a4437 2
      fixP->fx_offset = *valp;
      return 1;
d4443 1
a4443 1
    return 1;
d4454 1
a4454 1
      return 0;
d4486 1
a4486 1
    new_val = hppa_field_adjust (*valp - S_GET_VALUE (fixP->fx_addsy),
d4490 1
a4490 1
    new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);
d4499 3
a4501 3
      && (*valp - 8 + 8192 < 16384
	  || (fmt == 17 && *valp - 8 + 262144 < 524288)
	  || (fmt == 22 && *valp - 8 + 8388608 < 16777216))
d4504 2
a4505 2
      && (*valp - 8 + 262144 < 524288
	  || (fmt == 22 && *valp - 8 + 8388608 < 16777216))
d4513 1
a4513 1
      new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);
d4573 1
a4573 1
	offsetT distance = *valp;
d4592 1
a4592 1
	offsetT distance = *valp;
d4631 1
a4631 1
      return 0;
a4635 1
  return 1;
@


1.88
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d6830 1
a6830 1
	     the the current segment.  Note only BSF_FUNCTION really
d8497 1
a8497 1
     entry if they're going to need either a argument relocation or long
@


1.87
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@a25 1
#include <ctype.h>
d28 1
d1574 1
a1574 2
    if (isupper (*s))
      *s = tolower (*s);
d1577 3
a1579 1
  for (s = str; isupper (*s) || islower (*s) || (*s >= '0' && *s <= '3'); ++s)
d4691 1
a4691 1
  if (!strict && isdigit (*p))
d4699 1
a4699 1
	  while (isdigit (*p) || ((*p >= 'a') && (*p <= 'f'))
d4702 1
a4702 1
	      if (isdigit (*p))
d4714 1
a4714 1
	  while (isdigit (*p))
d4766 1
a4766 1
	  else if (!isdigit (*p))
d4776 1
a4776 1
	      while (isdigit (*p));
d5128 1
a5128 1
    name[0] = tolower ((*str)[0]),
d5131 2
a5132 2
    name[0] = tolower ((*str)[0]),
    name[1] = tolower ((*str)[1]),
d5135 3
a5137 3
    name[0] = tolower ((*str)[0]),
    name[1] = tolower ((*str)[1]),
    name[2] = tolower ((*str)[2]),
d8200 1
a8200 1
		     && (isdigit (dg) || (dg >= 'a' && dg <= 'f')
d8204 1
a8204 1
		    if (isdigit (dg))
@


1.86
log
@	* config/tc-hppa.c (pa_parse_nonneg_cmpsub_cmpltr): Remove
	"isbranch" param as all calls have it set.
	(pa_parse_neg_cmpsub_cmpltr): Likewise.
	(pa_parse_nonneg_add_cmpltr): Likewise.  Remember result of
	strcasecmp in "nullify" var.
	(pa_parse_neg_add_cmpltr): Likewise.
	(pa_ip): Don't "save_s" unnecessarily.  Update calls to above
	functions.  Don't print wrong conditions in error messages.
@
text
@d1692 1
a1692 1
	      if (!strncasecmp(s, "%sar", 4))
d1697 1
a1697 1
	      else if (!strncasecmp(s, "%cr11", 5))
d1952 1
a1952 1
		  if (!strncmp(s, ",sl", 3))
d1962 1
a1962 1
		  if (!strncmp(s, ",sl", 3))
d1967 1
a1967 1
		  else if (!strncmp(s, ",bc", 3))
d1977 1
a1977 1
		  if (!strncmp(s, ",co", 3))
d1986 1
a1986 1
		  if (strncmp(s, ",o", 2) != 0)
d2255 1
a2255 1
			as_bad(_("Invalid left/right combination completer"));
d2261 1
a2261 1
		    as_bad(_("Invalid left/right combination completer"));
d2310 1
a2310 1
			      as_bad(_("Invalid permutation completer"));
d2317 1
a2317 1
		    as_bad(_("Invalid permutation completer"));
@


1.85
log
@Add %mrp (millicode return pointer) alias for %r2 or %r31, depending on 32 or
64 bit architecture.
@
text
@d511 4
a514 4
static int pa_parse_nonneg_cmpsub_cmpltr PARAMS ((char **, int));
static int pa_parse_neg_cmpsub_cmpltr PARAMS ((char **, int));
static int pa_parse_neg_add_cmpltr PARAMS ((char **, int));
static int pa_parse_nonneg_add_cmpltr PARAMS ((char **, int));
a1599 2
  save_s = str;

d2426 1
a2426 1
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
d2429 1
a2429 1
			as_bad (_("Invalid Add and Branch Condition: %c"), *s);
d2439 1
a2439 1
			as_bad (_("Invalid Add and Branch Condition: %c"), *s);
d2453 1
a2453 1
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
d2457 1
a2457 1
			cmpltr = pa_parse_neg_add_cmpltr (&s, 1);
d2595 1
a2595 1
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
d2598 1
a2598 1
			as_bad (_("Invalid Compare/Subtract Condition: %c"), *s);
d2606 1
a2606 1
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
d2610 1
a2610 1
			cmpltr = pa_parse_neg_cmpsub_cmpltr (&s, 1);
d2613 1
a2613 1
			    as_bad (_("Invalid Compare and Branch Condition."));
d5349 1
a5349 5
   number (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction.  */
d5352 1
a5352 1
pa_parse_nonneg_cmpsub_cmpltr (s, isbranch)
a5353 1
     int isbranch;
d5400 1
a5400 1
      else if (strcasecmp (name, "n") == 0 && isbranch)
d5420 1
a5420 5
   number (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction.  */
d5423 1
a5423 1
pa_parse_neg_cmpsub_cmpltr (s, isbranch)
a5424 1
     int isbranch;
d5475 1
a5475 1
      else if (strcasecmp (name, "n") == 0 && isbranch)
d5654 1
a5654 5
   (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction.  */
d5657 1
a5657 1
pa_parse_nonneg_add_cmpltr (s, isbranch)
a5658 1
     int isbranch;
d5664 1
d5704 1
a5704 1
      else if (strcasecmp (name, "n") == 0 && isbranch)
d5707 1
d5717 1
a5717 1
  if (cmpltr == 0 && *name == 'n' && isbranch)
d5724 1
a5724 5
   (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction).  */
d5727 1
a5727 1
pa_parse_neg_add_cmpltr (s, isbranch)
a5728 1
     int isbranch;
d5734 1
d5778 1
a5778 1
      else if (strcasecmp (name, "n") == 0 && isbranch)
d5781 1
d5791 1
a5791 1
  if (cmpltr == 0 && *name == 'n' && isbranch)
@


1.84
log
@	* config/tc-hppa.c (CHECK_FIELD_WHERE): Define.
	(md_apply_fix): Use it here.  Replace printf with equivalent
	as_bad_where.
	(tc_gen_reloc): Use as_bad_where instead of as_bad.
	(md_apply_fix): Here too.
	* config/tc-i386.c (tc_gen_reloc): Use as_bad_where instead of as_bad.
	* config/tc-m68k.c (tc_gen_reloc): Likewise.
	(md_convert_frag_1): Likewise.
@
text
@d957 5
@


1.83
log
@Default hppa64 to ".level 2.0w"
@
text
@d1156 14
d4072 1
a4072 1
      as_bad (_("Cannot handle fixup at %s:%d"), fixp->fx_file, fixp->fx_line);
d4443 3
a4445 2
      printf (_("no hppa_fixup entry for fixup type 0x%x at %s:%d"),
	      fixP->fx_r_type, fixP->fx_file, fixP->fx_line);
d4511 2
a4512 1
      CHECK_FIELD (new_val, 8191, -8192, 0);
d4519 2
a4520 1
      CHECK_FIELD (new_val, 8191, -8192, 0);
d4528 2
a4529 1
      CHECK_FIELD (new_val, 8191, -8192, 0);
d4537 2
a4538 1
      CHECK_FIELD (new_val, 1048575, -1048576, 0);
d4546 2
a4547 1
      CHECK_FIELD (new_val, 1023, -1024, 0);
d4555 2
a4556 1
      CHECK_FIELD (new_val - 8, 8191, -8192, 0);
d4571 2
a4572 1
	  CHECK_FIELD (distance - 8, 262143, -262144, 0);
d4574 2
a4575 1
	CHECK_FIELD (new_val - 8, 262143, -262144, 0);
d4590 2
a4591 1
	  CHECK_FIELD (distance - 8, 8388607, -8388608, 0);
d4593 2
a4594 1
	CHECK_FIELD (new_val - 8, 8388607, -8388608, 0);
d4621 2
a4622 1
      as_bad (_("Unknown relocation encountered in md_apply_fix."));
@


1.82
log
@Fix copyright notices
@
text
@d108 6
d1402 1
a1402 1
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 10))
@


1.81
log
@(pa_build_unwind_subspace): Don't call
md_number_to_chars with size > sizeof (valueT).
@
text
@d2 1
a2 1
   Copyright 1989, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.80
log
@Fix unwind info when cross-compiling from little-endian machines.
@
text
@a6110 1
  md_number_to_chars (p, 0, 8);
d6113 1
d6126 1
a6126 1

@


1.79
log
@Fix a null-pointer dereference and some range checks.
@
text
@d136 25
d574 1
a574 1
				  int, unsigned int, int *));
d1306 1
a1306 1
     int* unwind_bits ATTRIBUTE_UNUSED;
d1325 1
a1325 1
    new_fix->fx_offset = *unwind_bits;
d1376 1
a1376 1
		hppa_field_selector, size * 8, 0, NULL);
d1486 2
a1487 1
		  char *where = frag_more (0);
d1489 2
d1493 1
a1493 2
				0, R_HPPA_ENTRY, e_fsel, 0, 0,
				(int *)&last_call_info->ci_unwind.descriptor);
d1518 1
a1518 1
		  the_insn.format, the_insn.arg_reloc, NULL);
d5953 1
a5953 1
		e_fsel, 0, 0, NULL);
d5978 1
a5978 1
		e_fsel, 0, 0, NULL);
a6078 1
  char *unwind;
d6081 1
a6081 1
  unsigned int i;
d6083 1
a6083 1
  char c, *p;
d6110 2
a6111 2
  p = frag_more (4);
  md_number_to_chars (p, 0, 4);
d6117 1
a6117 4
		e_fsel, 32, 0, NULL);

  p = frag_more (4);
  md_number_to_chars (p, 0, 4);
d6127 1
a6127 1
  fix_new_hppa (frag_now, p - frag_now->fr_literal, 4,
d6130 1
a6130 1
		e_fsel, 32, 0, NULL);
d6132 6
a6137 9
  /* Dump it.  */
  unwind = (char *) &call_info->ci_unwind;
  for (i = 8; i < sizeof (struct unwind_table); i++)
    {
      c = *(unwind + i);
      {
	FRAG_APPEND_1_CHAR (c);
      }
    }
d6427 2
a6428 1
      char *where = frag_more (0);
d6430 2
d6434 1
a6434 2
		    0, R_HPPA_ENTRY, e_fsel, 0, 0,
		    (int *) &last_call_info->ci_unwind.descriptor);
d6542 1
a6542 1
		(int *) &last_call_info->ci_unwind.descriptor + 1);
d7073 2
a7074 1
		  char *where = frag_more (0);
d7076 2
d7080 1
a7080 2
				0, R_HPPA_ENTRY, e_fsel, 0, 0,
				(int *) &last_call_info->ci_unwind.descriptor);
@


1.78
log
@Support hand-crafted .PARISC.unwind entries
@
text
@d3196 3
a3198 1
	      if (!strcmp (S_GET_NAME (the_insn.exp.X_add_symbol), "L$0\001"))
d3206 4
a3209 3
		  CHECK_FIELD (num, 8199, -8184, 0);

		  opcode |= re_assemble_12 ((num - 8) >> 2);
a3237 2
		  CHECK_FIELD (num, 262143, -262144, 0);

d3240 1
a3240 1

a3268 2
		  CHECK_FIELD (num, 8388607, -8388608, 0);

d3271 1
a3271 1

a3298 2
		  CHECK_FIELD (num, 262143, -262144, 0);

d3301 1
a3301 1

@


1.78.2.1
log
@Fix a null-pointer dereference and some range checks.
@
text
@d3196 1
a3196 3
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      "L$0\001"))
d3204 3
a3206 4
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  opcode |= re_assemble_12 (num >> 2);
d3235 2
d3239 1
a3239 1
		  CHECK_FIELD (num, 262143, -262144, 0);
d3268 2
d3272 1
a3272 1
		  CHECK_FIELD (num, 8388607, -8388608, 0);
d3300 2
d3304 1
a3304 1
		  CHECK_FIELD (num, 262143, -262144, 0);
@


1.78.2.2
log
@Fix unwind info when cross-compiling from little-endian machines.
@
text
@a135 25
/* We can't rely on compilers placing bitfields in any particular
   place, so use these macros when dumping unwind descriptors to
   object files.  */
#define UNWIND_LOW32(U) \
  (((U)->cannot_unwind << 31)		\
   | ((U)->millicode << 30)		\
   | ((U)->millicode_save_rest << 29)	\
   | ((U)->region_desc << 27)		\
   | ((U)->save_sr << 25)		\
   | ((U)->entry_fr << 21)		\
   | ((U)->entry_gr << 16)		\
   | ((U)->args_stored << 15)		\
   | ((U)->call_fr << 10)		\
   | ((U)->call_gr << 5)		\
   | ((U)->save_sp << 4)		\
   | ((U)->save_rp << 3)		\
   | ((U)->save_rp_in_frame << 2)	\
   | ((U)->extn_ptr_defined << 1)	\
   | ((U)->cleanup_defined << 0))

#define UNWIND_HIGH32(U) \
  (((U)->hpe_interrupt_marker << 31)	\
   | ((U)->hpux_interrupt_marker << 30)	\
   | ((U)->frame_size << 0))

d549 1
a549 1
				  int, unsigned int, int));
d1281 1
a1281 1
     int unwind_bits ATTRIBUTE_UNUSED;
d1300 1
a1300 1
    new_fix->fx_offset = unwind_bits;
d1351 1
a1351 1
		hppa_field_selector, size * 8, 0, 0);
d1461 1
a1461 2
		  char *where;
		  unsigned int u;
a1462 2
		  where = frag_more (0);
		  u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
d1465 2
a1466 1
				0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
d1491 1
a1491 1
		  the_insn.format, the_insn.arg_reloc, 0);
d5926 1
a5926 1
		e_fsel, 0, 0, 0);
d5951 1
a5951 1
		e_fsel, 0, 0, 0);
d6052 1
d6055 1
a6055 1
  unsigned int unwind;
d6057 1
a6057 1
  char *p;
d6084 2
a6085 2
  p = frag_more (16);
  md_number_to_chars (p, 0, 8);
d6091 4
a6094 1
		e_fsel, 32, 0, 0);
d6104 1
a6104 1
  fix_new_hppa (frag_now, p + 4 - frag_now->fr_literal, 4,
d6107 1
a6107 1
		e_fsel, 32, 0, 0);
d6109 9
a6117 6
  /* Dump the descriptor.  */
  unwind = UNWIND_LOW32 (&call_info->ci_unwind.descriptor);
  md_number_to_chars (p + 8, unwind, 4);

  unwind = UNWIND_HIGH32 (&call_info->ci_unwind.descriptor);
  md_number_to_chars (p + 12, unwind, 4);
d6407 1
a6407 2
      char *where;
      unsigned int u;
a6408 2
      where = frag_more (0);
      u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
d6411 2
a6412 1
		    0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
d6520 1
a6520 1
		UNWIND_HIGH32 (&last_call_info->ci_unwind.descriptor));
d7051 1
a7051 2
		  char *where;
		  unsigned int u;
a7052 2
		  where = frag_more (0);
		  u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
d7055 2
a7056 1
				0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
@


1.78.2.3
log
@(pa_build_unwind_subspace): Don't call
md_number_to_chars with size > sizeof (valueT).
@
text
@d6111 1
a6113 1
  md_number_to_chars (p, 0, 4);
d6126 1
a6126 1
  md_number_to_chars (p + 4, 0, 4);
@


1.78.2.4
log
@Default hppa64 to ".level 2.0w"
@
text
@d2 1
a2 1
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
a107 6
#if TARGET_ARCH_SIZE == 64
#define DEFAULT_LEVEL 25
#else
#define DEFAULT_LEVEL 10
#endif

d1396 1
a1396 1
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, DEFAULT_LEVEL))
@


1.77
log
@Build unwind info for more than just .text section.
@
text
@a4049 8
      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->howto = bfd_reloc_type_lookup (stdoutput,
					    (bfd_reloc_code_real_type) code);
      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

      assert (reloc->howto && (unsigned int) code == reloc->howto->type);

d4083 6
d4093 8
@


1.76
log
@Use SEGREL32 relocs for elf32-hppa unwind.
@
text
@d6056 3
a6058 1
  if (now_seg != text_section)
@


1.75
log
@Adds assembly and dis-assembly support for the HPPA wide
mode, 16 bit forms of ldi, ldo, ldw and stw instructions.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
d6059 1
a6059 5
  if (bfd_get_arch_info (stdoutput)->bits_per_address == 32)
    reloc = R_PARISC_DIR32;
  else
    reloc = R_PARISC_SEGREL32;

@


1.74
log
@Rodney Brown's CHECK_FIELD typo fixes.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 93, 94, 95, 96, 97, 98, 99, 2000
d1858 4
a1861 4
			/* Gross!  Hide these values in the immediate field
			   of the instruction, then pull them out later.  */
			opcode |= m << 8;
			opcode |= a << 9;
d2925 1
a2925 1
		  int a, m;
d2927 1
a2927 1
		  /* XXX the completer stored away tibits of information
d2931 2
a2932 3
		  m = (opcode & (1 << 8)) != 0;
		  a = (opcode & (1 << 9)) != 0;
		  opcode &= ~ (3 << 8);
d2934 1
a2934 1
		  if ((a == 1 && num >= 0) || (a == 0 && num < 0))
d2940 1
a2940 4
	      else
		{
		  break;
		}
d2949 1
a2949 1
		  int a, m;
d2951 2
a2952 7
		  /* XXX the completer stored away tibits of information
		     for us to extract.  We need a cleaner way to do this.
		     Now that we have lots of letters again, it would be
		     good to rethink this.  */
		  m = (opcode & (1 << 8)) != 0;
		  a = (opcode & (1 << 9)) != 0;
		  opcode &= ~ (3 << 8);
d2954 1
a2954 1
		  if ((a == 1 && num < 0) || (a == 0 && num > 0))
d2959 2
a2960 5
		  if (num < 0)
		    opcode |= 1;
                  num &= 0x1fff;
                  num >>= 2;
                  INSERT_FIELD_AND_CONTINUE (opcode, num, 3);
d2962 28
a2989 1
	      else
d2991 12
a3002 1
		  break;
d3004 1
@


1.73
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d3444 1
a3444 1
	      CHECK_FIELD (num, 671108864, 0, strict);
d4464 1
a4464 1
      CHECK_FIELD (new_val, 1023, -1023, 0);
@


1.72
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@d4264 1
a4264 1
size_t md_longopts_size = sizeof(md_longopts);
d4767 1
a4767 1
#define REG_NAME_CNT	(sizeof(pre_defined_registers) / sizeof(struct pd_reg))
@


1.71
log
@Add --gdwarf2 support to ARM toolchain
@
text
@d1494 1
a1494 2
  if (debug_type == DEBUG_DWARF2)
    dwarf2_generate_asm_lineno (4);
a8539 7
}

void
pa_end_of_source ()
{
  if (debug_type == DEBUG_DWARF2)
    dwarf2_finish ();
@


1.70
log
@(md_apply_fix): Remove bad assert added 2000-09-26.
@
text
@a44 1
struct dwarf2_line_info debug_line;
d1495 1
a1495 13
    {
      bfd_vma addr;

      /* First update the notion of the current source line.  */
      dwarf2_where (&debug_line);

      /* We want the offset of the start of this instruction within the
	 the current frag.  */
      addr = frag_now->fr_address + frag_now_fix () - 4;

      /* And record the information.  */
      dwarf2_gen_line_info (addr, &debug_line);
    }
@


1.69
log
@For SOM, don't force relocs on out-of-range 12 bit branches.
@
text
@d4344 1
a4344 1
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
d4347 1
a4347 1
  int insn, val;
a4348 1
  hppa_fixP = (struct hppa_fix_struct *) fixP->tc_fix_data;
a4374 1
  insn = bfd_get_32 (stdoutput, (unsigned char *) buf);
d4377 2
a4378 1
  if (hppa_fixP)
d4380 4
a4383 1
      int fmt = bfd_hppa_insn2fmt (stdoutput, insn);
d4385 10
a4394 8
      assert (fmt == hppa_fixP->fx_r_format);

      /* If there is a symbol associated with this fixup, then it's something
	 which will need a SOM relocation (except for some PC-relative relocs).
	 In such cases we should treat the "val" or "addend" as zero since it
	 will be added in as needed from fx_offset in tc_gen_reloc.  */
      if ((fixP->fx_addsy != NULL
	   || fixP->fx_r_type == (int) R_HPPA_NONE)
d4396 1
a4396 1
	  && fmt != 32
d4398 2
a4399 2
	  )
	new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
d4401 25
a4425 25
      /* These field selectors imply that we do not want an addend.  */
      else if (hppa_fixP->fx_r_field == e_psel
	       || hppa_fixP->fx_r_field == e_rpsel
	       || hppa_fixP->fx_r_field == e_lpsel
	       || hppa_fixP->fx_r_field == e_tsel
	       || hppa_fixP->fx_r_field == e_rtsel
	       || hppa_fixP->fx_r_field == e_ltsel)
	new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
      /* This is truely disgusting.  The machine independent code blindly
	 adds in the value of the symbol being relocated against.  Damn!  */
      else if (fmt == 32
	       && fixP->fx_addsy != NULL
	       && S_GET_SEGMENT (fixP->fx_addsy) != bfd_com_section_ptr)
	new_val = hppa_field_adjust (*valp - S_GET_VALUE (fixP->fx_addsy),
				     0, hppa_fixP->fx_r_field);
#endif
      else
	new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);

      /* Handle pc-relative exceptions from above.  */
      if ((fmt == 12 || fmt == 17 || fmt == 22)
	  && fixP->fx_addsy
	  && fixP->fx_pcrel
	  && !arg_reloc_stub_needed (symbol_arg_reloc_info (fixP->fx_addsy),
				     hppa_fixP->fx_arg_reloc)
d4427 3
a4429 3
	  && (*valp - 8 + 8192 < 16384
	      || (fmt == 17 && *valp - 8 + 262144 < 524288)
	      || (fmt == 22 && *valp - 8 + 8388608 < 16777216))
d4432 2
a4433 2
	  && (*valp - 8 + 262144 < 524288
	      || (fmt == 22 && *valp - 8 + 8388608 < 16777216))
d4435 8
a4442 115
	  && !S_IS_EXTERNAL (fixP->fx_addsy)
	  && !S_IS_WEAK (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) == hppa_fixP->segment
	  && !(fixP->fx_subsy
	       && S_GET_SEGMENT (fixP->fx_subsy) != hppa_fixP->segment))
	{
	  new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);
	}

      switch (fmt)
	{
	case 10:
	  CHECK_FIELD (new_val, 8191, -8192, 0);
	  val = new_val;

	  insn = (insn & ~ 0x3ff1) | (((val & 0x1ff8) << 1)
				      | ((val & 0x2000) >> 13));
	  break;
	case -11:
	  CHECK_FIELD (new_val, 8191, -8192, 0);
	  val = new_val;

	  insn = (insn & ~ 0x3ff9) | (((val & 0x1ffc) << 1)
				      | ((val & 0x2000) >> 13));
	  break;
	/* Handle all opcodes with the 'j' operand type.  */
	case 14:
	  CHECK_FIELD (new_val, 8191, -8192, 0);
	  val = new_val;

	  insn = ((insn & ~ 0x3fff) | low_sign_unext (val, 14));
	  break;

	/* Handle all opcodes with the 'k' operand type.  */
	case 21:
	  CHECK_FIELD (new_val, 1048575, -1048576, 0);
	  val = new_val;

	  insn = (insn & ~ 0x1fffff) | re_assemble_21 (val);
	  break;

	/* Handle all the opcodes with the 'i' operand type.  */
	case 11:
	  CHECK_FIELD (new_val, 1023, -1023, 0);
	  val = new_val;

	  insn = (insn & ~ 0x7ff) | low_sign_unext (val, 11);
	  break;

	/* Handle all the opcodes with the 'w' operand type.  */
	case 12:
	  CHECK_FIELD (new_val - 8, 8191, -8192, 0);
	  val = new_val - 8;

	  insn = (insn & ~ 0x1ffd) | re_assemble_12 (val >> 2);
	  break;

	/* Handle some of the opcodes with the 'W' operand type.  */
	case 17:
	  {
	    offsetT distance = *valp;

	    /* If this is an absolute branch (ie no link) with an out of
	       range target, then we want to complain.  */
	    if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
		&& (insn & 0xffe00000) == 0xe8000000)
	      CHECK_FIELD (distance - 8, 262143, -262144, 0);

	    CHECK_FIELD (new_val - 8, 262143, -262144, 0);
	    val = new_val - 8;

	    insn = (insn & ~ 0x1f1ffd) | re_assemble_17 (val >> 2);
	    break;
	  }

	case 22:
	  {
	    offsetT distance = *valp;

	    /* If this is an absolute branch (ie no link) with an out of
	       range target, then we want to complain.  */
	    if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
		&& (insn & 0xffe00000) == 0xe8000000)
	      CHECK_FIELD (distance - 8, 8388607, -8388608, 0);

	    CHECK_FIELD (new_val - 8, 8388607, -8388608, 0);
	    val = new_val - 8;

	    insn = (insn & ~ 0x3ff1ffd) | re_assemble_22 (val >> 2);
	    break;
	  }

	case -10:
	  val = new_val;
	  insn = (insn & ~ 0xfff1) | re_assemble_16 (val & -8);
	  break;

	case -16:
	  val = new_val;
	  insn = (insn & ~ 0xfff9) | re_assemble_16 (val & -4);
	  break;

	case 16:
	  val = new_val;
	  insn = (insn & ~ 0xffff) | re_assemble_16 (val);
	  break;

	case 32:
	  insn = new_val;
	  break;

	default:
	  as_bad (_("Unknown relocation encountered in md_apply_fix."));
	  return 0;
	}
d4444 1
a4444 5
      /* Insert the relocation.  */
      bfd_put_32 (stdoutput, insn, (unsigned char *) buf);
      return 1;
    }
  else
d4446 102
a4547 2
      printf (_("no hppa_fixup entry for this fixup (fixP = 0x%x, type = 0x%x)\n"),
	      (unsigned int) fixP, fixP->fx_r_type);
d4550 4
@


1.68
log
@External/weak SOM fixes, branch limit corrections.
@
text
@d4422 9
a4430 3
	  && ((*valp - 8 + 8192) < 16384
	      || (fmt == 17 && (*valp - 8 + 262144) < 524288)
	      || (fmt == 22 && (*valp - 8 + 8388608) < 16777216))
d8458 4
a8461 1
	  || (hppa_fixp->fx_r_format == 12 && distance + 8192 >= 16384))
@


1.67
log
@* config/tc-hppa.c (hppa_fix_adjustable): Do the external and weak
checks only for ELF.
(hppa_force_relocation): Likewise.
@
text
@d4014 4
a4017 1
    abort ();
d4329 2
d4332 1
a4332 1
  ((CALLEE) && (CALLER) && ((CALLEE) != (CALLER)))
d4383 2
d4422 5
a4426 3
	  && ((*valp + 8192) < 16384
	      || (fmt == 17 && (*valp + 262144) < 524288)
	      || (fmt == 22 && (*valp + 8388608) < 16777216))
d4476 2
a4477 2
	  CHECK_FIELD (new_val, 8199, -8184, 0);
	  val = new_val;
d4479 1
a4479 1
	  insn = (insn & ~ 0x1ffd) | re_assemble_12 ((val - 8) >> 2);
d4491 1
a4491 1
	      CHECK_FIELD (distance, 262143, -262144, 0);
d4493 2
a4494 2
	    CHECK_FIELD (new_val, 262143, -262144, 0);
	    val = new_val;
d4496 1
a4496 1
	    insn = (insn & ~ 0x1f1ffd) | re_assemble_17 ((val - 8) >> 2);
d4508 1
a4508 1
	      CHECK_FIELD (distance, 8388607, -8388608, 0);
d4510 2
a4511 2
	    CHECK_FIELD (new_val, 8388607, -8388608, 0);
	    val = new_val;
d4513 1
a4513 1
	    insn = (insn & ~ 0x3ff1ffd) | re_assemble_22 ((val - 8) >> 2);
d5839 1
d8323 1
a8327 1
#endif
d8394 2
a8395 2
  if (fixp->fx_addsy == 0 || ! S_IS_FUNCTION (fixp->fx_addsy))
    return 1;
d8397 1
a8397 1
  return 0;
a8408 1
  int distance;
d8426 3
d8432 1
a8432 2
  if (fixp->fx_addsy && (S_IS_EXTERNAL (fixp->fx_addsy)
			 || S_IS_WEAK (fixp->fx_addsy)))
a8433 1
#endif
d8438 3
a8440 3
  if (fixp->fx_pcrel && fixp->fx_addsy
      && (arg_reloc_stub_needed (symbol_arg_reloc_info (fixp->fx_addsy),
				 hppa_fixp->fx_arg_reloc)))
d8443 12
a8454 6
  distance = (fixp->fx_offset + S_GET_VALUE (fixp->fx_addsy)
	      - md_pcrel_from (fixp));
  /* Now check and see if we're going to need a long-branch stub.  */
  if (fixp->fx_r_type == (int) R_HPPA_PCREL_CALL
      && (distance > 262143 || distance < -262144))
    return 1;
@


1.66
log
@* config/tc-hppa.h (TC_FORCE_RELOCATION_SECTION): For ELF, allow
subtraction of two syms without emitting a relocation.
* config/tc-hppa.c (hppa_force_relocation): Force relocations for
global or weak symbols.
@
text
@d8313 4
a8378 4
  if (fixp->fx_addsy && (S_IS_EXTERNAL (fixp->fx_addsy)
			 || S_IS_WEAK (fixp->fx_addsy)))
    return 0;

a8416 1
#endif
d8423 1
@


1.65
log
@  > 	* config/tc-hppa.c: Fix formatting.
@
text
@d8419 6
d8427 1
a8427 1
     call stub.  FIXME.  Can't we need the same for absolute calls?  */
@


1.64
log
@.reg improvements.
@
text
@a21 1

a233 1

d697 1
a697 1
   Also note that C style comments will always work. */
d788 1
a788 1
   The table is sorted. Suitable for searching by a binary search. */
a1260 1

d1424 1
a1424 1
  /* Force the symbol to be converted to a real symbol. */
d1484 1
a1484 1
  /* Output the opcode. */
d1948 1
a1948 1
		/* Handle load ordering completer. */
d2408 1
a2408 1
			/* Negated condition requires an opcode change. */
d2429 1
a2429 1
			    /* Negated condition requires an opcode change. */
d2582 1
a2582 1
			    /* Negated condition requires an opcode change. */
d2594 1
a2594 1
			/* Negated condition requires an opcode change. */
d2598 1
a2598 1
		      /* Not a 64 bit cond.  Give 32 bit a chance. */
d2607 1
a2607 1
		      /* Not a 64 bit cond.  Give 32 bit a chance. */
d3192 1
a3192 1
		  
d4226 1
a4226 1
/* Round up a section size to the appropriate boundary. */
d4659 1
a4659 1
         slow. */
a4799 1

d5103 1
a5103 1
/* Mark (via expr_end) the end of an absolute expression.  FIXME. */
a5284 1

a5330 1

a5360 1

a5410 1

a5413 1

a5507 1

a5569 1

a6054 1

d6082 1
a6082 1
  /* Dump it. */
d6552 1
a6552 1
         For the HP, weak and global are not mutually exclusive. 
a7059 1

a7587 1

a7629 1

a7651 1

a7711 2


@


1.63
log
@Munge in vtable support for tc-hppa.c, inform elf back-end about
millicode, and make $PIC_pcrel$0 work.
@
text
@d252 1
a252 17
   +--------------+--------------+


   The following is a version of pa_parse_number that
   handles the L/R notation and returns the correct
   value to put into the instruction register field.
   The correct value to put into the instruction is
   encoded in the structure 'pa_11_fp_reg_struct'.  */

struct pa_11_fp_reg_struct
  {
    /* The register number.  */
    char number_part;

    /* L/R selector.  */
    char l_r_select;
  };
d513 2
a514 3
static int need_pa11_opcode PARAMS ((struct pa_it *,
				     struct pa_11_fp_reg_struct *));
static int pa_parse_number PARAMS ((char **, struct pa_11_fp_reg_struct *));
d749 9
d794 139
a932 139
  {"%arg0", 26},
  {"%arg1", 25},
  {"%arg2", 24},
  {"%arg3", 23},
  {"%cr0", 0},
  {"%cr10", 10},
  {"%cr11", 11},
  {"%cr12", 12},
  {"%cr13", 13},
  {"%cr14", 14},
  {"%cr15", 15},
  {"%cr16", 16},
  {"%cr17", 17},
  {"%cr18", 18},
  {"%cr19", 19},
  {"%cr20", 20},
  {"%cr21", 21},
  {"%cr22", 22},
  {"%cr23", 23},
  {"%cr24", 24},
  {"%cr25", 25},
  {"%cr26", 26},
  {"%cr27", 27},
  {"%cr28", 28},
  {"%cr29", 29},
  {"%cr30", 30},
  {"%cr31", 31},
  {"%cr8", 8},
  {"%cr9", 9},
  {"%dp", 27},
  {"%eiem", 15},
  {"%eirr", 23},
  {"%fr0", 0},
  {"%fr0l", 0},
  {"%fr0r", 0},
  {"%fr1", 1},
  {"%fr10", 10},
  {"%fr10l", 10},
  {"%fr10r", 10},
  {"%fr11", 11},
  {"%fr11l", 11},
  {"%fr11r", 11},
  {"%fr12", 12},
  {"%fr12l", 12},
  {"%fr12r", 12},
  {"%fr13", 13},
  {"%fr13l", 13},
  {"%fr13r", 13},
  {"%fr14", 14},
  {"%fr14l", 14},
  {"%fr14r", 14},
  {"%fr15", 15},
  {"%fr15l", 15},
  {"%fr15r", 15},
  {"%fr16", 16},
  {"%fr16l", 16},
  {"%fr16r", 16},
  {"%fr17", 17},
  {"%fr17l", 17},
  {"%fr17r", 17},
  {"%fr18", 18},
  {"%fr18l", 18},
  {"%fr18r", 18},
  {"%fr19", 19},
  {"%fr19l", 19},
  {"%fr19r", 19},
  {"%fr1l", 1},
  {"%fr1r", 1},
  {"%fr2", 2},
  {"%fr20", 20},
  {"%fr20l", 20},
  {"%fr20r", 20},
  {"%fr21", 21},
  {"%fr21l", 21},
  {"%fr21r", 21},
  {"%fr22", 22},
  {"%fr22l", 22},
  {"%fr22r", 22},
  {"%fr23", 23},
  {"%fr23l", 23},
  {"%fr23r", 23},
  {"%fr24", 24},
  {"%fr24l", 24},
  {"%fr24r", 24},
  {"%fr25", 25},
  {"%fr25l", 25},
  {"%fr25r", 25},
  {"%fr26", 26},
  {"%fr26l", 26},
  {"%fr26r", 26},
  {"%fr27", 27},
  {"%fr27l", 27},
  {"%fr27r", 27},
  {"%fr28", 28},
  {"%fr28l", 28},
  {"%fr28r", 28},
  {"%fr29", 29},
  {"%fr29l", 29},
  {"%fr29r", 29},
  {"%fr2l", 2},
  {"%fr2r", 2},
  {"%fr3", 3},
  {"%fr30", 30},
  {"%fr30l", 30},
  {"%fr30r", 30},
  {"%fr31", 31},
  {"%fr31l", 31},
  {"%fr31r", 31},
  {"%fr3l", 3},
  {"%fr3r", 3},
  {"%fr4", 4},
  {"%fr4l", 4},
  {"%fr4r", 4},
  {"%fr5", 5},
  {"%fr5l", 5},
  {"%fr5r", 5},
  {"%fr6", 6},
  {"%fr6l", 6},
  {"%fr6r", 6},
  {"%fr7", 7},
  {"%fr7l", 7},
  {"%fr7r", 7},
  {"%fr8", 8},
  {"%fr8l", 8},
  {"%fr8r", 8},
  {"%fr9", 9},
  {"%fr9l", 9},
  {"%fr9r", 9},
  {"%hta", 25},
  {"%iir", 19},
  {"%ior", 21},
  {"%ipsw", 22},
  {"%isr", 20},
  {"%itmr", 16},
  {"%iva", 14},
  {"%pcoq", 18},
  {"%pcsq", 17},
  {"%pidr1", 8},
  {"%pidr2", 9},
d935 55
a989 55
  {"%ppda", 24},
  {"%r0", 0},
  {"%r1", 1},
  {"%r10", 10},
  {"%r11", 11},
  {"%r12", 12},
  {"%r13", 13},
  {"%r14", 14},
  {"%r15", 15},
  {"%r16", 16},
  {"%r17", 17},
  {"%r18", 18},
  {"%r19", 19},
  {"%r2", 2},
  {"%r20", 20},
  {"%r21", 21},
  {"%r22", 22},
  {"%r23", 23},
  {"%r24", 24},
  {"%r25", 25},
  {"%r26", 26},
  {"%r27", 27},
  {"%r28", 28},
  {"%r29", 29},
  {"%r3", 3},
  {"%r30", 30},
  {"%r31", 31},
  {"%r4", 4},
  {"%r5", 5},
  {"%r6", 6},
  {"%r7", 7},
  {"%r8", 8},
  {"%r9", 9},
  {"%rctr", 0},
  {"%ret0", 28},
  {"%ret1", 29},
  {"%rp", 2},
  {"%sar", 11},
  {"%sp", 30},
  {"%sr0", 0},
  {"%sr1", 1},
  {"%sr2", 2},
  {"%sr3", 3},
  {"%sr4", 4},
  {"%sr5", 5},
  {"%sr6", 6},
  {"%sr7", 7},
  {"%tr0", 24},
  {"%tr1", 25},
  {"%tr2", 26},
  {"%tr3", 27},
  {"%tr4", 28},
  {"%tr5", 29},
  {"%tr6", 30},
  {"%tr7", 31}
d1646 1
a1646 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1648 1
a1648 1
	      num = pa_parse_number (&s, 0);
d1673 1
a1673 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1675 1
a1675 1
	      num = pa_parse_number (&s, 0);
d1681 1
a1681 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1683 1
a1683 1
	      num = pa_parse_number (&s, 0);
d1689 1
a1689 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1691 1
a1691 1
	      num = pa_parse_number (&s, 0);
d1758 1
a1758 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1760 1
a1760 1
	      num = pa_parse_number (&s, 0);
d1766 1
a1766 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1768 1
a1768 1
	      num = pa_parse_number (&s, 0);
a3432 2
	      if (the_insn.exp.X_op != O_constant)
		break;
d3656 1
a3656 2
		  /* This should be more strict.  Small steps.  */
		  if (strict && *s != '%')
d3658 1
a3658 1
		  num = pa_parse_number (&s, 0);
d3665 1
a3665 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3667 3
a3669 3
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= result.number_part;
d3674 1
a3674 1
		    if (need_pa11_opcode (&the_insn, &result)
d3678 2
a3679 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.l_r_select & 1, 6);
d3685 1
a3685 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3687 4
a3690 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= result.number_part << 21;
		    if (need_pa11_opcode (&the_insn, &result))
d3692 1
a3692 1
			opcode |= (result.l_r_select & 1) << 7;
d3702 1
a3702 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3704 4
a3707 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= result.number_part << 21;
		    opcode |= (result.l_r_select & 1) << 7;
d3714 1
a3714 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3716 4
a3719 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1f) << 16;
		    if (need_pa11_opcode (&the_insn, &result))
d3721 1
a3721 1
			opcode |= (result.l_r_select & 1) << 12;
d3730 1
a3730 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3732 4
a3735 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1f) << 16;
		    opcode |= (result.l_r_select & 1) << 12;
d3742 1
a3742 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3744 5
a3748 5
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1c) << 11;
		    opcode |= (result.number_part & 0x3) << 9;
		    opcode |= (result.l_r_select & 1) << 8;
d3755 1
a3755 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3757 2
a3758 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3761 1
a3761 1
			if (result.number_part < 16)
d3766 2
a3767 3

			result.number_part &= 0xF;
			result.number_part |= (result.l_r_select & 1) << 4;
d3769 1
a3769 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 21);
d3775 1
a3775 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3777 2
a3778 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3781 1
a3781 1
		        if (result.number_part < 16)
d3783 2
a3784 2
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
d3786 2
a3787 2
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d3789 1
a3789 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 16);
d3795 1
a3795 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3797 2
a3798 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3801 1
a3801 1
		        if (result.number_part < 16)
d3803 2
a3804 2
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
d3806 2
a3807 2
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d3809 1
a3809 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 0);
d3815 1
a3815 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3817 2
a3818 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3821 1
a3821 1
		        if (result.number_part < 16)
d3823 2
a3824 2
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
d3826 2
a3827 2
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d3829 1
a3829 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 6);
d3835 1
a3835 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3837 2
a3838 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3841 1
a3841 1
		        if (result.number_part < 16)
d3843 2
a3844 2
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
d3846 2
a3847 2
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d3849 1
a3849 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 11);
d3856 1
a3856 3
		    struct pa_11_fp_reg_struct result;

		    if (strict && *s != '%')
d3858 4
a3861 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1f) << 16;
		    if (need_pa11_opcode (&the_insn, &result))
d3863 1
a3863 1
			opcode |= (result.l_r_select & 1) << 1;
d3870 1
a3870 2
		  /* This should be more strict.  Small steps.  */
		  if (strict && *s != '%')
d3872 1
a3872 1
		  num = pa_parse_number (&s, 0);
d4572 7
a4578 5
   Return a number or -1 for failure.

   When parsing PA-89 FP register numbers RESULT will be
   the address of a structure to return information about
   L/R half of FP registers, store results there as appropriate.
d4584 1
a4584 1
pa_parse_number (s, result)
d4586 1
a4586 1
     struct pa_11_fp_reg_struct *result;
d4594 1
d4600 4
a4603 9
  /* Store info in RESULT if requested by caller.  */
  if (result)
    {
      result->number_part = -1;
      result->l_r_select = -1;
    }
  num = -1;

  if (isdigit (*p))
a4605 1
      num = 0;
d4633 4
a4636 2
      /* Store info in RESULT if requested by the caller.  */
      if (result)
d4638 2
a4639 3
	  result->number_part = num;

	  if (IS_R_SELECT (p))
d4641 9
a4649 7
	      result->l_r_select = 1;
	      ++p;
	    }
	  else if (IS_L_SELECT (p))
	    {
	      result->l_r_select = 0;
	      ++p;
a4650 2
	  else
	    result->l_r_select = 0;
d4656 1
a4656 1
      num = 0;
d4712 1
a4712 11
      /* Store info in RESULT if requested by caller.  */
      if (result)
	{
	  result->number_part = num;
	  if (IS_R_SELECT (p - 1))
	    result->l_r_select = 1;
	  else if (IS_L_SELECT (p - 1))
	    result->l_r_select = 0;
	  else
	    result->l_r_select = 0;
	}
d4717 1
a4717 2
         is effectively a constant.  */
      num = 0;
d4728 8
a4735 1
	  if (S_GET_SEGMENT (sym) == &bfd_abs_section)
d4737 1
a4737 1
	  else
d4744 1
a4744 1
      else
d4761 1
a4761 11
      /* Store info in RESULT if requested by caller.  */
      if (result)
	{
	  result->number_part = num;
	  if (IS_R_SELECT (p - 1))
	    result->l_r_select = 1;
	  else if (IS_L_SELECT (p - 1))
	    result->l_r_select = 0;
	  else
	    result->l_r_select = 0;
	}
d4764 6
a4769 2
  *s = p;
  return num;
d4808 1
a4808 3
need_pa11_opcode (insn, result)
     struct pa_it *insn;
     struct pa_11_fp_reg_struct *result;
d4810 2
a4811 1
  if (result->l_r_select == 1 && !(insn->fpof1 == DBL && insn->fpof2 == DBL))
d5123 1
a5123 1
     r5, or is that 4 MOD 5?
d6402 21
d6436 7
a6442 1
	S_SET_VALUE (symbol, pa_parse_number (&input_line_pointer, 0));
d6444 18
a6461 2
	S_SET_VALUE (symbol, (unsigned int) get_absolute_expression ());
      S_SET_SEGMENT (symbol, bfd_abs_section_ptr);
d7115 1
a7115 1
  int spnum, temp;
d7149 3
a7151 2
      temp = pa_parse_number (&ptemp, 0);
      if (temp >= 0)
d7153 1
a7153 1
	  spnum = temp;
a7234 1
  int temp;
d7312 3
a7314 1
      if ((temp = pa_parse_number (&input_line_pointer, 0)) >= 0)
d7316 1
a7316 1
	  if ((sd_chain = pa_find_space_by_number (temp)))
@


1.62
log
@comment-finding hack for hppa-linux.
@
text
@d582 2
d700 4
d1317 1
a1317 1
     it now so as not to confuse write.c.  */
d1319 2
a1320 1
      && !strcmp (S_GET_NAME (new_fix->fx_subsy), "$global$"))
d4109 2
a4110 3
	     (static link required).

	     FIXME: We always assume no static link!
a4123 22
	  {
	    char *buf = fixp->fx_where + fixp->fx_frag->fr_literal;
	    int insn = bfd_get_32 (stdoutput, buf);

#ifdef ELF_ARG_RELOC_INSN
	    /* Store the arg reloc in the instruction.  */
	    insn = ((insn & ~ 0x1ff8)
		    | ((hppa_fixp->fx_arg_reloc << 3) & 0x1ff8));
	    bfd_put_32 (stdoutput, insn, buf);
	    reloc->addend = fixp->fx_offset;
#else
	    /* The high 22 bits of the constant are stored in the
	       reloc.  The remaining 10 bits can be retrieved from the
	       instruction.  */
	    insn = (insn & ~ 0x7f8) | ((fixp->fx_offset & 0x3fc) << 1);
	    bfd_put_32 (stdoutput, insn, buf);
	    reloc->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc,
					   fixp->fx_offset >> 10);
#endif
	  }
	  break;

d4126 2
a4127 22
	  {
	    char *buf = fixp->fx_where + fixp->fx_frag->fr_literal;
	    int insn = bfd_get_32 (stdoutput, buf);

#ifdef ELF_ARG_RELOC_INSN
	    /* Store the arg reloc in the instruction.  */
	    insn = ((insn & ~ 0xff9)
		    | ((hppa_fixp->fx_arg_reloc >> 9) & 1)
		    | ((hppa_fixp->fx_arg_reloc << 3) & 0xff8));
	    bfd_put_32 (stdoutput, insn, buf);
	    reloc->addend = fixp->fx_offset;
#else
	    /* In this case, the instruction stores the high bits, so
	       the reloc stores the low 22 bits.  */
	    insn = ((insn & ~ 0xff9)
		    | ((fixp->fx_offset >> 31) & 1)
		    | ((fixp->fx_offset >> 19) & 0xff8));
	    bfd_put_32 (stdoutput, insn, buf);
	    reloc->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc,
					   fixp->fx_offset);
#endif
	  }
d4421 5
d6615 1
d6621 1
a6621 1
      symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
d6640 1
a6640 1
	  symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6645 1
a6645 1
	  symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
d6652 2
a6653 2
      symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
      symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
d6659 1
a6659 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6665 9
a6673 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6679 1
a6679 1
      symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
d6685 1
a6685 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6691 1
a6691 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6699 1
a6699 1
  obj_set_symbol_type (symbol_get_bfdsym (symbolP), (int) type);
d6747 1
a6747 2
	  ((obj_symbol_type *) symbol_get_bfdsym (symbolP))
	    ->tc_data.ap.hppa_priv_level = temp;
d8348 6
d8414 2
a8415 1
  if (fixp->fx_addsy && S_IS_EXTERNAL (fixp->fx_addsy))
d8452 5
d8572 44
@


1.61
log
@#ifdef OBJ_SOM, not #ifdef SOM
@
text
@d4348 3
d4352 1
d4354 3
d4358 1
d4362 3
d4384 5
d4398 8
@


1.60
log
@(hppa_fix_adjustable): Don't reduce certain symbols to section syms.
@
text
@d4393 1
a4393 1
#if defined (SOM) || defined (ELF_ARG_RELOC)
d6718 1
a6718 1
#if defined (SOM) || defined (ELF_ARG_RELOC)
d6732 1
a6732 1
#if defined (SOM) || defined (ELF_ARG_RELOC)
d8376 1
a8376 1
     .		ldw	RR%foo+10(%r21),%r25
d8378 12
a8389 11
     If foo is at address 4090 (decimal) in section `sect', then after
     reducing to the section symbol, we get
     .			LR%sect+4090 == L%sect+0
     .			RR%sect+4090 == R%sect+4090
     .			RR%sect+4100 == R%sect-4092 (4100 - 8192)
     and the last address loses.

     Obviously, in cases where the LR% expression is identical to the
     RR% one we will never have a problem, but is so happens that gcc
     rounds addends involved in LR% field selectors to work around a
     HP linker bug.  ie. We often have addresses like the last case
@


1.59
log
@More warning fixes, and a tweak in tc-hppa.c to check constant
branch offsets a little more thoroughly.
@
text
@d4434 1
a4434 1
  insn = bfd_get_32 (stdoutput, (unsigned char *)buf);
d8345 1
d8363 28
a8390 1
     That confuses the HP linker.  */
a8394 1
#endif
@


1.58
log
@Add linux-elf flavour to pseudos in tc-hppa.c and some tidying
and bug fixes.  Handle wide mode relocs.  Don't select target
size based on BFD64.
@
text
@d4478 3
a4480 1
	  && (*valp + 262144) < 524288
@


1.57
log
@
        * config/tc-hppa.c (pa_export): Weak symbols can be global.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 93, 94, 95, 96, 97, 98, 1999
a32 1
#include "bfd/libbfd.h"
a46 1
#endif
d50 1
a50 1
#ifdef OBJ_ELF
d52 1
a52 1
typedef elf_hppa_reloc_type reloc_type;
d56 2
d59 1
a59 1
#ifdef BFD64
d72 1
a72 1
#endif
d93 2
a99 1
#endif
d108 1
d224 1
a224 1
    long arg_reloc;
d443 1
a443 1
    long fx_arg_reloc;
d479 5
a485 1
static void pa_data PARAMS ((int));
a490 1
static void pa_text PARAMS ((int));
a511 2
static void pa_code PARAMS ((int));
static void pa_comm PARAMS ((int));
d566 1
a566 1
				  long, expressionS *, int,
d569 1
a569 1
				  int, long, int *));
a609 4
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = ";";

d630 4
a633 1
  {"code", pa_code, 0},
d635 1
d640 1
d642 1
d647 1
d649 1
d656 1
a656 1
  { "file", dwarf2_directive_file, 0 },
d668 1
a668 1
  { "loc", dwarf2_directive_loc, 0 },
d694 1
d696 1
d713 4
d747 1
a747 1
/* Handle on strucutre which keep track of the last symbol
d1280 1
a1280 1
     long offset;
d1286 1
a1286 1
     long arg_reloc;
d1349 4
a1352 1
    as_warn (_("Invalid field selector.  Assuming F%%."));
d1730 1
a1730 1
	      CHECK_FIELD (num, 15, -16, strict)
d1740 2
a1741 2
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, strict);
d1777 1
a1777 1
	      opcode = re_assemble_3 (opcode, num);
a2640 1
			name = s;
a2647 1

a2707 1
			name = s;
d3003 1
a3003 1
	    /* Handle 14 bit immediated, shifted left three times.  */
d3095 1
a3095 1
		  opcode = re_assemble_21 (opcode, num);
d3119 1
a3119 1
		  opcode = re_assemble_16 (opcode, num, 1);
d3145 1
a3145 1
		  opcode = re_assemble_16 (opcode, num, 1);
d3171 1
a3171 1
		  opcode = re_assemble_16 (opcode, num, 1);
d3203 1
a3203 1
		  opcode = re_assemble_12 (opcode, (num - 8) >> 2);
d3237 1
a3237 1
		  opcode = re_assemble_17 (opcode, num >> 2);
d3270 1
a3270 1
		  opcode = re_assemble_22 (opcode, num >> 2);
d3302 1
a3302 1
		  opcode = re_assemble_17 (opcode, num >> 2);
a4036 1
  bfd_reloc_code_real_type code;
d4039 2
a4040 1
  bfd_reloc_code_real_type **codes;
d4047 1
d4055 1
a4055 1
  codes = (bfd_reloc_code_real_type **) hppa_gen_reloc_type (stdoutput,
d4085 2
a4086 1
      reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
a4087 1
      reloc->addend = 0;	/* default */
d4089 1
a4089 1
      assert (reloc->howto && code == reloc->howto->type);
d4112 1
a4112 1
	case R_PARISC_PCREL21L:
d4116 22
a4137 4
	case R_PARISC_PCREL14R:
	case R_PARISC_PCREL14F:
	  /* The constant is stored in the instruction.  */
	  reloc->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc, 0);
d4139 28
d4182 3
a4184 1
      relocs[i]->howto = bfd_reloc_type_lookup (stdoutput, code);
d4195 3
a4197 1
	  relocs[0]->howto = bfd_reloc_type_lookup (stdoutput, *codes[0]);
d4202 3
a4204 1
	  relocs[1]->howto = bfd_reloc_type_lookup (stdoutput, *codes[1]);
d4209 3
a4211 1
	  relocs[2]->howto = bfd_reloc_type_lookup (stdoutput, *codes[2]);
d4215 3
a4217 1
	  relocs[3]->howto = bfd_reloc_type_lookup (stdoutput, *codes[3]);
d4221 3
a4223 1
	  relocs[4]->howto = bfd_reloc_type_lookup (stdoutput, *codes[4]);
d4347 6
a4352 1
CONST char *md_shortopts = "";
d4363 13
a4375 1
  return 0;
d4393 7
d4410 1
a4410 1
  unsigned int insn, val;
d4434 1
d4439 1
a4439 2
      unsigned long buf_wd = bfd_get_32 (stdoutput, buf);
      int fmt = bfd_hppa_insn2fmt (buf_wd);
d4446 1
a4446 1
	   || fixP->fx_r_type == R_HPPA_NONE)
a4472 2
#define arg_reloc_stub_needed(CALLER, CALLEE) \
  ((CALLEE) && (CALLER) && ((CALLEE) != (CALLER)))
d4476 3
a4478 6
#ifdef OBJ_SOM
	  && !arg_reloc_stub_needed ((long) ((obj_symbol_type *)
		symbol_get_bfdsym (fixP->fx_addsy))->tc_data.ap.hppa_arg_reloc,
		hppa_fixP->fx_arg_reloc)
#endif
	  && (((int)(*valp) > -262144 && (int)(*valp) < 262143) && fmt != 22)
d4482 3
a4484 3
	      
	new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);
#undef arg_reloc_stub_needed
a4485 1
      insn = bfd_get_32 (stdoutput, buf);
d4512 1
a4512 1
	  CHECK_FIELD (new_val, 1048576, -1048576, 0);
d4515 1
a4515 1
	  insn = re_assemble_21 (insn & ~ 0x1fffff, val);
d4531 1
a4531 1
	  insn = re_assemble_12 (insn & ~ 0x1ffd, (val - 8) >> 2);
d4541 1
a4541 1
	    if (fixP->fx_r_type == R_HPPA_PCREL_CALL
d4548 1
a4548 1
	    insn = re_assemble_17 (insn & ~ 0x1f1ffd, (val - 8) >> 2);
d4558 1
a4558 1
	    if (fixP->fx_r_type == R_HPPA_PCREL_CALL
d4565 1
a4565 1
	    insn = re_assemble_22 (insn & ~ 0x3ff1ffd, (val - 8) >> 2);
d4569 15
d4594 1
a4594 1
      bfd_put_32 (stdoutput, insn, buf);
d6325 3
a6327 2
/* Switch into the code subspace.  */

d6329 1
a6329 1
pa_code (unused)
d6337 1
d6342 14
d6405 1
a6619 3
#ifdef OBJ_SOM
  obj_symbol_type *symbol = (obj_symbol_type *) symbol_get_bfdsym (symbolP);
#endif
d6716 2
a6717 2
#ifdef OBJ_SOM
	  symbol->tc_data.ap.hppa_arg_reloc |= arg_reloc;
d6730 2
a6731 2
#ifdef OBJ_SOM
	  symbol->tc_data.ap.hppa_arg_reloc |= arg_reloc;
d6743 2
a6744 1
	  symbol->tc_data.ap.hppa_priv_level = temp;
d6951 1
a6951 1
   of a procedure from a syntatical point of view.  */
a8112 5
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

d8135 1
a8135 1
     For example, \xDD where DD is a hexidecimal number should be
d8138 5
d8161 1
a8161 1
		/* Get pas the 'x'.  */
a8250 15
/* Switch to the data space.  As usual delete our label.  */

static void
pa_data (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  current_space = is_defined_space ("$PRIVATE$");
  current_subspace
    = pa_subsegment_to_subspace (current_space->sd_seg, 0);
#endif
  s_data (0);
  pa_undefine_label ();
}

a8305 16
/* Switch to the text space.  Like s_text, but delete our
   label when finished.  */
static void
pa_text (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  current_space = is_defined_space ("$TEXT$");
  current_subspace
    = pa_subsegment_to_subspace (current_space->sd_seg, 0);
#endif

  s_text (0);
  pa_undefine_label ();
}

d8397 1
a8397 1
     fixS *fixp;
d8404 6
a8409 5
  if (fixp->fx_r_type == R_HPPA_ENTRY || fixp->fx_r_type == R_HPPA_EXIT
      || fixp->fx_r_type == R_HPPA_BEGIN_BRTAB
      || fixp->fx_r_type == R_HPPA_END_BRTAB
      || fixp->fx_r_type == R_HPPA_BEGIN_TRY
      || fixp->fx_r_type == R_HPPA_END_TRY
a8414 4
#define arg_reloc_stub_needed(CALLER, CALLEE) \
  ((CALLEE) && (CALLER) && ((CALLEE) != (CALLER)))

#ifdef OBJ_SOM
d8419 2
a8420 3
      && (arg_reloc_stub_needed ((long) ((obj_symbol_type *)
	symbol_get_bfdsym (fixp->fx_addsy))->tc_data.ap.hppa_arg_reloc,
	hppa_fixp->fx_arg_reloc)))
d8422 1
a8422 1
#endif
d8426 1
a8426 1
  if (fixp->fx_r_type == R_HPPA_PCREL_CALL
d8430 1
a8430 1
  if (fixp->fx_r_type == R_HPPA_ABS_CALL)
a8431 1
#undef arg_reloc_stub_needed
d8447 8
a8454 3
  char *name = (char *)
    xmalloc (strlen ("L$\001end_") +
	     strlen (S_GET_NAME (last_call_info->start_symbol)) + 1);
d8456 3
a8522 1
#endif
d8524 2
a8525 2
#ifdef OBJ_ELF
void pa_end_of_source ()
@


1.56
log
@        * config/tc-hppa.c (md_apply_fix): Mask out immediate bits of
        instruction to reflect change in re_assemble_*.
@
text
@d6469 5
a6473 1
      /* OK.  Set the external bits and process argument relocations.  */
d6475 1
@


1.55
log
@Assorted code cleanup and fixes for hppa.  Re-enable elf32-hppa as
it now compiles even if it doesn't work too well.
@
text
@d4425 1
a4425 1
	  insn = re_assemble_21 (insn, val);
d4441 1
a4441 1
	  insn = re_assemble_12 (insn, (val - 8) >> 2);
d4458 1
a4458 1
	    insn = re_assemble_17 (insn, (val - 8) >> 2);
d4475 1
a4475 1
	    insn = re_assemble_22 (insn, (val - 8) >> 2);
@


1.54
log
@        * config/tc-hppa.c (md_apply_fix): Handle new PA2.0 formats.

        * config/tc-hppa.c (CHECK_ALIGN): New macro.
        Added handling of new operand types l,y,&,fe,fE,fx.
@
text
@d531 1
a571 1
static int log2 PARAMS ((int));
d649 1
a649 1
  { "file", dwarf2_directive_file },
d661 1
a661 1
  { "loc", dwarf2_directive_loc },
d1274 1
a1274 1
     int* unwind_bits;
d1703 1
a1703 1
	      low_sign_unext (num, 5, &num);
d1715 1
a1715 1
	      low_sign_unext (num, 5, &num);
d1761 2
a1762 2
	      dis_assemble_3 (num, &num);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
d2914 1
a2914 1
		  low_sign_unext (num, 11, &num);
d2949 1
a2949 1
		  low_sign_unext (num, 14, &num);
d3058 1
a3058 1
		  low_sign_unext (num, 14, &num);
d3082 2
a3083 2
		  dis_assemble_21 (num, &num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
a3103 1
		  unsigned int result;
d3106 2
a3107 2
		  dis_assemble_16 (num, &result, 1);
		  INSERT_FIELD_AND_CONTINUE (opcode, result, 0);
a3128 1
		  unsigned int result;
d3132 2
a3133 2
		  dis_assemble_16 (num, &result, 1);
		  INSERT_FIELD_AND_CONTINUE (opcode, result, 0);
a3154 1
		  unsigned int result;
d3158 2
a3159 2
		  dis_assemble_16 (num, &result, 1);
		  INSERT_FIELD_AND_CONTINUE (opcode, result, 0);
a3181 2
		  unsigned int w1, w, result;

d3189 3
a3191 3
		  sign_unext ((num - 8) >> 2, 12, &result);
		  dis_assemble_12 (result, &w1, &w);
		  INSERT_FIELD_AND_CONTINUE (opcode, ((w1 << 2) | w), 0);
a3212 2
		  unsigned int w2, w1, w, result;

d3224 2
a3225 4
		  sign_unext (num >> 2, 17, &result);
		  dis_assemble_17 (result, &w1, &w2, &w);
		  INSERT_FIELD_AND_CONTINUE (opcode,
					   ((w2 << 2) | (w1 << 16) | w), 0);
a3245 2
		  unsigned int w3, w2, w1, w, result;

d3257 1
a3257 6
		  sign_unext (num >> 2, 22, &result);
		  dis_assemble_22 (result, &w3, &w1, &w2, &w);
		  INSERT_FIELD_AND_CONTINUE (opcode,
					     ((w3 << 21) | (w2 << 2)
					      | (w1 << 16) | w),
					     0);
a3277 2
		  unsigned int w2, w1, w, result;

d3289 2
a3290 4
		  sign_unext (num >> 2, 17, &result);
		  dis_assemble_17 (result, &w1, &w2, &w);
		  INSERT_FIELD_AND_CONTINUE (opcode,
					   ((w2 << 2) | (w1 << 16) | w), 0);
d4217 2
a4218 2
     register bfd *abfd;
     register asection *sec;
d4263 1
a4263 1
     asection *segment;
d4283 2
a4284 2
     int c;
     char *arg;
d4291 1
a4291 1
     FILE *stream;
d4299 1
a4299 1
     char *name;
d4313 2
a4314 2
  long new_val, result = 0;
  unsigned int w1, w2, w, resulti;
d4394 2
a4395 1
	
d4400 1
d4402 2
a4403 5
	  /* Mask off 11 bits to be changed.  */
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffffc00e,
		      buf);
	  result = ((new_val & 0x1fff) >> 2) | ((new_val & 0x2000) >> 13);
d4407 1
d4409 2
a4410 5
	  /* Mask off 14 bits to be changed.  */
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffffc006,
		      buf);
	  result = ((new_val & 0x1fff) >> 1) | ((new_val & 0x2000) >> 15);
d4415 1
d4417 1
a4417 6
	  /* Mask off 14 bits to be changed.  */
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffffc000,
		      buf);
	  low_sign_unext (new_val, 14, &resulti);
	  result = resulti;
d4422 2
a4423 1
	  CHECK_FIELD (new_val, 2097152, 0, 0);
d4425 1
a4425 6
	  /* Mask off 21 bits to be changed.  */
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffe00000,
		      buf);
	  dis_assemble_21 (new_val, &resulti);
	  result = resulti;
d4431 1
d4433 1
a4433 6
	  /* Mask off 11 bits to be changed.  */
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffff800,
		      buf);
	  low_sign_unext (new_val, 11, &resulti);
	  result = resulti;
d4439 1
d4441 1
a4441 8
	  /* Mask off 11 bits to be changed.  */
	  sign_unext ((new_val - 8) >> 2, 12, &resulti);
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffffe002,
		      buf);

	  dis_assemble_12 (resulti, &w1, &w);
	  result = ((w1 << 2) | w);
d4447 1
a4447 3
	    int distance = *valp;

	    CHECK_FIELD (new_val, 262143, -262144, 0);
d4452 1
a4452 2
		&& (distance > 262143 || distance < -262144)
		&& (bfd_get_32 (stdoutput, buf) & 0xffe00000) == 0xe8000000)
d4455 4
a4458 7
	    /* Mask off 17 bits to be changed.  */
	    bfd_put_32 (stdoutput,
			bfd_get_32 (stdoutput, buf) & 0xffe0e002,
			buf);
	    sign_unext ((new_val - 8) >> 2, 17, &resulti);
	    dis_assemble_17 (resulti, &w1, &w2, &w);
	    result = ((w2 << 2) | (w1 << 16) | w);
d4464 1
a4464 3
	    int distance = *valp, w3;

	    CHECK_FIELD (new_val, 8388607, -8388608, 0);
d4469 1
a4469 2
		&& (distance > 8388607 || distance < -8388608)
		&& (bfd_get_32 (stdoutput, buf) & 0xffe00000) == 0xe8000000)
d4472 4
a4475 7
	    /* Mask off 22 bits to be changed.  */
	    bfd_put_32 (stdoutput,
			bfd_get_32 (stdoutput, buf) & 0xfc00e002,
			buf);
	    sign_unext ((new_val - 8) >> 2, 22, &resulti);
	    dis_assemble_22 (resulti, &w3, &w1, &w2, &w);
	    result = ((w3 << 21) | (w2 << 2) | (w1 << 16) | w);
d4480 1
a4480 2
	  result = 0;
	  bfd_put_32 (stdoutput, new_val, buf);
d4489 1
a4489 1
      bfd_put_32 (stdoutput, bfd_get_32 (stdoutput, buf) | result, buf);
d5138 1
a5138 1
  int value;
d5145 1
a5145 57
  switch (field_selector)
    {
    /* No change.  */
    case e_fsel:
      break;

    /* If bit 21 is on then add 0x800 and arithmetic shift right 11 bits.  */
    case e_lssel:
      if (value & 0x00000400)
	value += 0x800;
      value = (value & 0xfffff800) >> 11;
      break;

    /* Sign extend from bit 21.  */
    case e_rssel:
      if (value & 0x00000400)
	value |= 0xfffff800;
      else
	value &= 0x7ff;
      break;

    /* Arithmetic shift right 11 bits.  */
    case e_lsel:
      value = (value & 0xfffff800) >> 11;
      break;

    /* Set bits 0-20 to zero.  */
    case e_rsel:
      value = value & 0x7ff;
      break;

    /* Add 0x800 and arithmetic shift right 11 bits.  */
    case e_ldsel:
      value += 0x800;
      value = (value & 0xfffff800) >> 11;
      break;

    /* Set bitgs 0-21 to one.  */
    case e_rdsel:
      value |= 0xfffff800;
      break;

#define RSEL_ROUND(c)  (((c) + 0x1000) & ~0x1fff)
    case e_rrsel:
      value = (RSEL_ROUND (value) & 0x7ff) + (value - RSEL_ROUND (value));
      break;

    case e_lrsel:
      value = (RSEL_ROUND (value) >> 11) & 0x1fffff;
      break;
#undef RSEL_ROUND

    default:
      BAD_CASE (field_selector);
      break;
    }
  return value;
a5401 1
  char *save_s = *s;
a5496 1
  char *save_s = *s;
d5825 1
a5825 1
     int z;
d5863 1
a5863 1
     int begin;
d5884 1
a5884 1
     int begin;
d5911 1
a5911 1
     int unused;
d6002 3
a6004 3
  asymbol *sym;
  subsegT subseg, save_subseg;
  int i, reloc;
d6081 1
a6081 1
     int unused;
d6224 1
a6224 1
     int unused;
d6257 1
a6257 1
     int unused;
d6289 1
a6289 1
     int unused;
d6297 1
a6297 1
     int unused;
d6312 1
a6312 1
     int unused;
d6419 1
a6419 1
     int unused;
d6452 1
a6452 1
     int unused;
d6493 1
d6495 1
d6641 1
a6641 1
     int unused;
d6693 1
a6693 1
     int unused;
d6723 1
a6723 1
     int unused;
d6738 1
a6738 1
     int unused;
d6779 1
a6779 1
     int unused;
d6795 1
a6795 1
     int unused;
d6830 1
a6830 1
     int unused;
d6900 1
a6900 1
     int unused;
d6967 2
a6986 2

#ifdef OBJ_SOM
d7126 1
a7126 1
     int unused;
d7245 1
a7245 1
     int unused;
d8085 1
a8085 1
     int unused;
d8097 1
a8097 1
     int unused;
d8109 1
a8109 1
     int unused;
d8130 1
a8130 1
     int unused;
d8155 1
a8155 1
     int unused;
d8185 1
a8185 1
     int unused;
d8200 1
a8200 1
     int unused;
d8429 1
a8429 1
pa_end_of_source ()
@


1.53
log
@
        * config/tc-hppa.c (pa_build_unwind_subspace): Use subseg_new to create
        the unwinder subspace.  Save the current seg/subseg before creating
        the new seg/subseg.
@
text
@d1117 14
d3097 80
d3903 1
d3919 10
d4411 1
a4411 1

d4414 1
a4414 1

d4417 18
@


1.52
log
@        * config/tc-hppa.c (pa_ip): Handle PA2.0 unit completers.  Handle
        'B' operand for PA2.0 bb instruction.
@
text
@d6004 2
d6012 1
a6012 1
      seg = bfd_make_section_old_way (stdoutput, UNWIND_SECTION_NAME);
a6018 2
  save_seg = now_seg;
  save_subseg = now_subseg;
@


1.51
log
@
        * config/tc-hppa.c (md_apply_fix): Make "fmt" an int.
@
text
@d2797 24
d3333 14
@


1.50
log
@       * config/tc-hppa.c (pa_ip):  Add new codes 'cc', 'cd', 'cC', 'co',
        '@@'.  Change autoincrement completers to fall through to cache control
        completers.

        * config/tc-hppa.c (pa_ip):  Remove unused args.  Add code to '?W'
        arg.
        (pa_parse_addb_64_cmpltr):  New function.

        * config/tc-hppa.c (pa_ip):  Change error message.
        (pa_ip,pa_parse_cmpb_64_cmpltr,pa_parse_cmpib_64_cmpltr)  Fix '?N' and
        '?Q' args to allow falling through.

        * config/tc-hppa.c (pa_ip):  Implement conditional codes "?N", "?Q".
        Remove unused conditional codes.
        (pa_parse_cmpb_64_cmpltr,pa_parse_cmpib_64_cmpltr):  New.
@
text
@d4220 1
a4220 1
      unsigned char fmt = bfd_hppa_insn2fmt (buf_wd);
@


1.49
log
@Remove accidental case duplication.
@
text
@d498 3
d1399 1
a1399 1
  (void) symbol_get_bfdsym (dummy_symbol); 
d1773 2
a1774 1
			else if (strncasecmp (s, "s", 1) == 0)
d1778 4
a1781 1
			  break;
d1797 1
a1797 1
		case 'c':
d1803 1
d1809 1
d1815 1
d1817 4
a1820 3
			/* When in strict mode this is a match failure.  */
			else if (strict)
			  break;
d1822 5
a1826 2
			  as_bad (_("Invalid Short Load/Store Completer."));
			s += 2;
d1829 2
a1830 2
		       consider this a positive match for 'cc'.  */
		    else if (*args == 'c')
d1850 1
a1850 1
		    else if (*args == 'c')
d1871 2
a1872 1
			else if (strncasecmp (s, "b", 1) == 0)
d1878 4
a1881 1
			  break;
d1893 42
d1987 1
a1987 1
		case 'W':	
d2051 1
a2051 1
		  
d2373 1
a2373 1
			as_bad (_("Invalid Compare/Subtract Condition: %c"), *s);
d2378 1
a2378 9
		  /* Handle negated add and branch condition.  */
		  case 'D':
		    abort ();

		  /* Handle wide-mode non-negated add and branch condition.  */
		  case 'w':
		    abort ();

		  /* Handle wide-mode negated add and branch condition.  */
d2380 12
a2391 1
		    abort();
d2393 1
a2393 1
		  /* Handle a negated or non-negated add and branch 
d2459 1
a2459 1
			  { 
d2464 1
a2464 1
			  } 
d2468 1
a2468 1
			    
d2547 1
a2547 18
		  /* Handle a negated compare condition.  */
		  case 'T':
		    abort ();
  
		  /* Handle a 64 bit non-negated compare condition.  */
		  case 'r':
		    abort ();
  
		  /* Handle a 64 bit negated compare condition.  */
		  case 'R':
		    abort ();
  
		  /* Handle a 64 bit cmpib condition.  */
		  case 'Q':
		    abort ();
  
		  /* Handle a negated or non-negated compare/subtract
		     condition.  */
d2557 1
a2557 1
			    as_bad (_("Invalid Compare/Subtract Condition."));
d2566 24
a2589 1
	    
d2612 1
a2612 1
			    
d2618 2
a2619 2
	    
	    
d2681 1
a2681 1
			    
d2724 1
a2724 1
	    
d2735 1
a2735 1
			    
d3221 7
d3329 1
a3329 1
  
d3452 1
a3452 1
		  || the_insn.fpof1 == DBL 
d3471 1
a3471 1
		       || the_insn.fpof1 == DW 
d3482 1
a3482 1
		       || the_insn.fpof1 == UDW 
d3682 1
a3682 1
		  
d3705 1
a3705 1
		  
d3728 1
a3728 1
		  
d3751 1
a3751 1
		  
d4268 1
a4268 1
	      
d4271 1
a4271 1
	
d5338 163
d5651 102
d5965 1
a5965 1
    
d8180 1
a8180 1
   reductions make life a living hell for object file editors. 
d8200 1
a8200 1
     the fixup will occur in a CODE subspace. 
@


1.48
log
@        * config/tc-hppa.c (pa_ip): Replace 'B', 'M', 'l' and 'g' handling
        with cleaner code using completer prefixes.   Add 'Y'.
@
text
@d3709 1
a3713 18

	    /* Handle L/R register halves like 'x'.  */
	    case 'e':
	      {
		struct pa_11_fp_reg_struct result;

		/* This should be more strict.  Small steps.  */
		if (strict && *s != '%')
		  break;
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= (result.number_part & 0x1f) << 16;
		if (need_pa11_opcode (&the_insn, &result))
		  {
		    opcode |= (result.l_r_select & 1) << 1;
		  }
		continue;
	      }
@


1.47
log
@        * config/tc-hppa.c (pa_ip):  Add parens to silence compiler.
@
text
@d1875 28
a2750 32
	    /* Handle ,gate completer for new syntax branches.  */
	    case 'g':
	      if (*s == ',' && strncasecmp (s + 1, "gate", 4) == 0)
		s += 5;
	      else
		break;
	      continue;

	    /* Handle ,l completer for new syntax branches.  */
	    case 'l':
	      if (*s == ',' && strncasecmp (s + 1, "l", 1) == 0)
		s += 2;
	      else
		break;
	      continue;

	    /* Handle ,push completer for new syntax branches.  */
	    case 'M':
	      if (*s == ',' && strncasecmp (s + 1, "push", 4) == 0)
		s += 5;
	      else
		break;
	      continue;

	    /* Handle ,pop completer for new syntax branches.  */
	    case 'B':
	      if (*s == ',' && strncasecmp (s + 1, "pop", 3) == 0)
		s += 4;
	      else
		break;
	      continue;

d3144 7
@


1.46
log
@        * config/tc-hppa.c (pa_ip): Avoid ANSI specific initialization.
        (pa_ip, case 'm'): Failure to get a CBIT specifier just means the
        insn does not match and we should try the next insn in the table.
@
text
@d2843 1
a2843 1
		  if (a == 1 && num >= 0 || (a == 0 && num < 0))
d2871 1
a2871 1
		  if (a == 1 && num < 0 || (a == 0 && num > 0))
a3562 1
		    int regnum;
@


1.45
log
@        * config/tc-hppa.c (pa_ip): Fix thinkos in recent cleanup
        of PA2.0 support.
@
text
@d2142 1
a2142 1
		      int permloc[4] = {13,10,8,6};
d2145 4
a2783 1
	      s = expr_end;
d2786 1
d2793 1
a2793 1
		as_bad (_("Invalid CBit Specification: %s"), s);
@


1.44
log
@        * config/tc-hppa.c (pa_ip): Handle 'J', 'K' and 'cc'
        operands.
@
text
@d2721 1
a2721 1
	      if (*s == ',' && strcasecmp (s + 1, "gate") == 0)
d2729 1
a2729 1
	      if (*s == ',' && strcasecmp (s + 1, "l") == 0)
d2737 1
a2737 1
	      if (*s == ',' && strcasecmp (s + 1, "push") == 0)
d2745 1
a2745 1
	      if (*s == ',' && strcasecmp (s + 1, "pop") == 0)
d2753 1
a2753 1
	      if (*s == ',' && strcasecmp (s + 1, "%r2") == 0)
d2755 1
a2755 1
	      else if (*s == ',' && strcasecmp (s + 1, "%rp") == 0)
@


1.43
log
@        * config/tc-hppa.c (pa_ip); Handle "fe", and 'cJ'.
@
text
@d1790 1
d1814 4
d1836 8
d2820 61
@


1.42
log
@        * config/tc-hppa.c (pa_ip): Handle 'd', '#' and 'cq'.
@
text
@d1789 1
d1814 2
a1815 2
		   /* 'm' and 'q' are the same, except for where they encode
		       the before/after field.  */
d1826 5
d3614 15
@


1.41
log
@        * config/tc-hppa.c (struct pa_it): New field "trunc".
        (pa_ip): Hadnle 'h', 'm', '=', '{', and '_' operands.
        (pa_parse_ftest_gfx_completer): New function
        (pa_parse_fp_cnv_format): New function.
@
text
@d1788 1
d1813 12
a1824 2
		    opcode |= m << 5;
		    INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
d2803 58
@


1.40
log
@        * config/tc-hppa.c (pa_ip): Handle 'X' operand.
        (md_apply_fix): Handle 22bit pc-rel branches.
@
text
@d213 2
d570 2
d2731 37
d3187 75
d4496 120
@


1.39
log
@        * config/tc-hppa.c (pa_ip): Handle 'B' operand.
@
text
@d2868 39
d4000 23
@


1.38
log
@        * config/tc-hppa.c (pa_ip): Handle 'L' and 'M' operands.
@
text
@d2709 8
@


1.37
log
@        * config/tc-hppa.c (pa_ip): Handle 'l' operand.
@
text
@d2701 18
@


1.36
log
@
        * config/tc-hppa.c (pa_ip): Handle 'g' operand.
@
text
@d2693 8
@


1.35
log
@
        * config/tc-hppa.c (md_assemble): Fix dwarf2 line handling.
        (pa_ip): Handle 'fX'.
@
text
@d2685 7
@


1.34
log
@Really fix the typo.
@
text
@d1466 6
a1471 4
      /* I haven't got a clue why the -8 is necessary, but this
	 seems to work.  Someone should really document what all
	 the frag nonsense does and more precisely what the dwarf2
	 code needs.  */
d1473 1
a1473 1
      addr = frag_now->fr_address + frag_now_fix () - 8;
a1474 1
      dwarf2_where (&debug_line);
d3161 1
@


1.33
log
@Fix typo in last change.
@
text
@d5123 1
a5123 1
  if (nowseg != text_section)
@


1.32
log
@
        * config/tc-hppa.c (pa_build_unwind_subspace): Do not build
        unwinds unless the function is in the text space.
        (pa_type_args): Set BSF_FUNCTION for an exproted data symbol.
@
text
@d5123 1
a5123 1
  if (seg != text_section)
@


1.31
log
@        * config/tc-hppa.c (pa_ip): Move dwarf2 stuff from here.
        (md_assemble): To here.  Tweak address generation.
@
text
@d5123 3
d5647 1
@


1.30
log
@
        * config/tc-hppa.c: Include dwarf2dbg.h if OBJ_ELF.  Declare
        debug_line.
        (md_pseudo_table): Add .file and .line pseudo-ops for OBJ_ELF.
        (md_assemble): Call dwarf2_where for OBJ_ELF.
        (pa_ip): Call dwarf2_gen_line_info for OBJ_ELF.
        (pa_end_of_source): New function.
        * tc-hppa.h (md_end): Define for OBJ_ELF.
@
text
@d1463 12
a1474 1
    dwarf2_where (&debug_line);
a1475 1

a3388 10

#ifdef OBJ_ELF
  if (debug_type == DEBUG_DWARF2)
    {
      bfd_vma addr;

      addr = frag_now->fr_address + frag_now_fix ();
      dwarf2_gen_line_info (addr, &debug_line);
    }
#endif
@


1.29
log
@        * config/tc-hppa.c (pa_ip): Support 'Z' argument.
@
text
@d42 8
d641 3
d653 3
d1460 6
d3380 10
d7535 8
@


1.28
log
@
        * config/tc-hppa.c (pa_ip): Put strict register checks before
        call to pa_parse_number.
@
text
@d2833 11
@


1.27
log
@        * config/tc-hppa.c (pa_ip): Get strict/non-strict mode from the
        candidate instruction.  Require registers for register arguments
        when in strict mode.  Require assemble-time constants for
        constants when in strict mode.
        (pa_get_absolute_expression): Require a constant when in strict
        mode.
@
text
@a1578 1
	      num = pa_parse_number (&s, 0);
d1582 1
a1606 1
	      num = pa_parse_number (&s, 0);
d1610 1
a1615 1
	      num = pa_parse_number (&s, 0);
d1619 1
a1624 1
	      num = pa_parse_number (&s, 0);
d1628 1
a1694 1
	      num = pa_parse_number (&s, 0);
d1698 1
a1703 1
	      num = pa_parse_number (&s, 0);
d1707 1
a3069 1
		  num = pa_parse_number (&s, 0);
d3073 1
a3081 1
		    pa_parse_number (&s, &result);
d3085 1
a3103 1
		    pa_parse_number (&s, &result);
d3107 1
a3122 1
		    pa_parse_number (&s, &result);
d3126 1
a3137 1
		    pa_parse_number (&s, &result);
d3141 1
a3156 1
		    pa_parse_number (&s, &result);
d3160 1
a3172 1
		    pa_parse_number (&s, &result);
d3176 1
a3188 1
		    pa_parse_number (&s, &result);
d3192 1
a3212 1
		    pa_parse_number (&s, &result);
d3216 1
a3235 1
		    pa_parse_number (&s, &result);
d3239 1
a3258 1
		    pa_parse_number (&s, &result);
d3262 1
a3281 1
		    pa_parse_number (&s, &result);
d3285 1
a3309 1
		pa_parse_number (&s, &result);
d3313 1
@


1.26
log
@        * config/tc-hppa.c (pa_ip): Replace 'f' by 'v'.  Prefix float register
        args by 'f'.
@
text
@d720 6
d1519 1
d1580 3
d1608 3
d1617 3
d1626 3
d1636 2
d1645 2
d1648 3
a1650 1
	      CHECK_FIELD (num, 15, -16, 0);
d1657 2
d1660 3
a1662 1
	      CHECK_FIELD (num, 15, -16, 0)
d1669 2
d1673 1
a1673 1
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d1678 2
d1681 1
a1681 1
	      CHECK_FIELD (num, 31, 0, 0);
d1687 2
d1690 1
a1690 1
	      CHECK_FIELD (num, 1023, 0, 0);
d1696 3
d1705 3
d1737 3
d1769 3
d1796 3
d2836 2
d2839 1
a2839 1
	      CHECK_FIELD (num, 3, 1, 0);
d2845 2
d2848 1
a2848 1
	      CHECK_FIELD (num, 15, 0, 0);
d2854 2
d2857 1
a2857 1
	      CHECK_FIELD (num, 31, 0, 0);
d2863 2
d2866 1
a2866 1
	      CHECK_FIELD (num, 63, 0, 0);
d2875 2
d2878 1
a2878 1
	      CHECK_FIELD (num, 64, 1, 0);
d2887 2
d2890 1
a2890 1
	      CHECK_FIELD (num, 64, 1, 0);
d2899 2
d2902 1
a2902 1
	      CHECK_FIELD (num, 31, 0, 0);
d2908 2
d2911 1
a2911 1
	      CHECK_FIELD (num, 63, 0, 0);
d2918 2
d2923 1
a2923 1
	      CHECK_FIELD (num, 31, 0, 0);
d2929 2
d2932 1
a2932 1
	      CHECK_FIELD (num, 511, 1, 0);
d2938 2
d2941 1
a2941 1
	      CHECK_FIELD (num, 8191, 0, 0);
d2947 2
d2950 1
a2950 1
	      CHECK_FIELD (num, 671108864, 0, 0);
d2958 2
d2961 1
a2961 1
	      CHECK_FIELD (num, 7, 0, 0);
d2967 2
d2970 1
a2970 1
	      CHECK_FIELD (num, 1048575, 0, 0);
d2977 2
d2980 1
a2980 1
	      CHECK_FIELD (num, 32767, 0, 0);
d2986 2
d2989 1
a2989 1
	      CHECK_FIELD (num, 1023, 0, 0);
d2996 2
d2999 1
a2999 1
	      CHECK_FIELD (num, 32767, 0, 0);
d3008 2
d3011 1
a3011 1
	      CHECK_FIELD (num, 7, 0, 0);
d3017 2
d3020 1
a3020 1
	      CHECK_FIELD (num, 4194303, 0, 0);
d3071 3
d3083 3
d3105 3
d3124 3
d3139 3
d3158 3
d3174 3
d3190 3
d3214 3
d3237 3
d3260 3
d3283 3
d3311 3
d4393 8
@


1.25
log
@        * config/tc-hppa.c (pa_ip): Add args q, %, and |.
@
text
@a1601 1
	    case 'y':
d2880 1
a2880 1
	    case 'f':
d2957 11
a2967 4
	    /* Handle L/R register halves like 't'.  */
	    case 'v':
	      {
		struct pa_11_fp_reg_struct result;
d2969 6
a2974 3
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= result.number_part;
d2976 9
a2984 6
		/* 0x30 opcodes are FP arithmetic operation opcodes
		   and need to be turned into 0x38 opcodes.  This
		   is not necessary for loads/stores.  */
		if (need_pa11_opcode (&the_insn, &result)
		    && ((opcode & 0xfc000000) == 0x30000000))
		  opcode |= 1 << 27;
d2986 4
a2989 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.l_r_select & 1, 6);
	      }
d2991 10
a3000 4
	    /* Handle L/R register halves like 'b'.  */
	    case 'E':
	      {
		struct pa_11_fp_reg_struct result;
d3002 1
a3002 7
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= result.number_part << 21;
		if (need_pa11_opcode (&the_insn, &result))
		  {
		    opcode |= (result.l_r_select & 1) << 7;
		    opcode |= 1 << 27;
a3003 2
		continue;
	      }
d3005 4
a3008 4
	    /* Float operand 1 similar to 'b' but with l/r registers.  */
	    case 'J':
	      {
		struct pa_11_fp_reg_struct result;
d3010 10
a3019 6
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= result.number_part << 21;
		opcode |= (result.l_r_select & 1) << 7;
		continue;
	      }
d3021 4
a3024 5
	    /* Handle L/R register halves like 'b'.  */
	    case '3':
	      {
		struct pa_11_fp_reg_struct result;
		int regnum;
d3026 6
a3031 7
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= (result.number_part & 0x1c) << 11;
		opcode |= (result.number_part & 0x3) << 9;
		opcode |= (result.l_r_select & 1) << 8;
		continue;
	      }
d3033 4
a3036 4
	    /* Handle L/R register halves like 'x'.  */
	    case 'e':
	      {
		struct pa_11_fp_reg_struct result;
d3038 9
a3046 6
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= (result.number_part & 0x1f) << 16;
		if (need_pa11_opcode (&the_insn, &result))
		  {
		    opcode |= (result.l_r_select & 1) << 1;
a3047 2
		continue;
	      }
d3049 4
a3052 4
	    /* Handle L/R register halves like 'x'.  */
	    case 'X':
	      {
		struct pa_11_fp_reg_struct result;
d3054 3
a3056 5
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= (result.number_part & 0x1f) << 16;
		if (need_pa11_opcode (&the_insn, &result))
		  {
d3058 1
a3058 1
		    opcode |= 1 << 27;
a3059 2
		continue;
	      }
d3061 5
a3065 4
	    /* Float operand 2, like 'x' but with l/r register halves.  */
	    case 'K':
	      {
		struct pa_11_fp_reg_struct result;
d3067 7
a3073 6
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= (result.number_part & 0x1f) << 16;
		opcode |= (result.l_r_select & 1) << 12;
		continue;
	      }
d3075 4
a3078 4
	    /* Handle a 5 bit register field at 10.  */
	    case '4':
	      {
		struct pa_11_fp_reg_struct result;
d3080 3
a3082 5
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		if (the_insn.fpof1 == SGL)
		  {
		    if (result.number_part < 16)
d3084 8
a3091 2
			as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			break;
d3093 2
d3096 18
a3113 2
		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
a3114 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 21);
	      }
d3116 2
a3117 8
	    /* Handle a 5 bit register field at 15.  */
	    case '6':
	      {
		struct pa_11_fp_reg_struct result;

		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		if (the_insn.fpof1 == SGL)
d3119 13
a3131 4
		    if (result.number_part < 16)
		      {
			as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			break;
d3133 1
a3133 2
		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
a3134 7
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 16);
	      }

	    /* Handle a 5 bit register field at 31.  */
	    case '7':
	      {
		struct pa_11_fp_reg_struct result;
d3136 2
a3137 3
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		if (the_insn.fpof1 == SGL)
d3139 13
a3151 4
		    if (result.number_part < 16)
		      {
			as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			break;
d3153 1
a3153 2
		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
a3154 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 0);
	      }
d3156 2
a3157 8
	    /* Handle a 5 bit register field at 20.  */
	    case '8':
	      {
		struct pa_11_fp_reg_struct result;

		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		if (the_insn.fpof1 == SGL)
d3159 13
a3171 4
		    if (result.number_part < 16)
		      {
			as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			break;
d3173 1
a3173 2
		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
a3174 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 11);
	      }
d3176 7
a3182 2
	    /* Handle a 5 bit register field at 25.  */
	    case '9':
d3188 2
a3189 1
		if (the_insn.fpof1 == SGL)
d3191 1
a3191 7
		    if (result.number_part < 16)
		      {
			as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			break;
		      }
		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
d3193 1
a3193 1
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 6);
a3194 19

	    /* Handle a floating point operand format at 26.
	       Only allows single and double precision.  */
	    case 'H':
	      flag = pa_parse_fp_format (&s);
	      switch (flag)
		{
		case SGL:
		  opcode |= 0x20;
		case DBL:
		  the_insn.fpof1 = flag;
		  continue;

		case QUAD:
		case ILLEGAL_FMT:
		default:
		  as_bad (_("Invalid Floating Point Operand Format."));
		}
	      break;
@


1.24
log
@       * config/tc-hppa.c (pa_ip):  Absorb white space in instructions
        between args.
        Add new completers.  Fix bug in 64 bit condition handling.
@
text
@d1825 11
d2814 21
d2842 8
a2851 1

@


1.23
log
@        * config/tc-hppa.c (pa_ip):  Add completer codes 'a', 'ch', 'cH',
        'cS', and 'c*'.
@
text
@d1537 4
d1652 7
d1761 41
d1814 144
d2084 1
d2249 1
d2387 1
d2456 1
@


1.22
log
@        * config/tc-hppa.c (pa_ip): Place completers behind prefix 'c'.
@
text
@d1604 7
d1762 89
d2578 7
@


1.21
log
@        * config/tc-hppa.c (pa_ip): Do not allow '*' in 32bit completers.
@
text
@d1654 1
a1654 1
	    /* Handle a completer for an indexing load or store.  */
d1656 5
a1660 5
	      {
		int uu = 0;
		int m = 0;
		int i = 0;
		while (*s == ',' && i < 2)
d1662 4
a1665 2
		    s++;
		    if (strncasecmp (s, "sm", 2) == 0)
d1667 14
a1680 2
			uu = 1;
			m = 1;
d1684 4
a1687 8
		    else if (strncasecmp (s, "m", 1) == 0)
		      m = 1;
		    else if (strncasecmp (s, "s", 1) == 0)
		      uu = 1;
		    else
		      as_bad (_("Invalid Indexed Load Completer."));
		    s++;
		    i++;
a1688 5
		if (i > 2)
		  as_bad (_("Invalid Indexed Load Completer Syntax."));
		opcode |= m << 5;
		INSERT_FIELD_AND_CONTINUE (opcode, uu, 13);
	      }
d1690 2
a1691 6
	    /* Handle a short load/store completer.  */
	    case 'C':
	      {
		int a = 0;
		int m = 0;
		if (*s == ',')
d1693 3
a1695 2
		    s++;
		    if (strncasecmp (s, "ma", 2) == 0)
d1697 14
a1710 2
			a = 0;
			m = 1;
a1711 9
		    else if (strncasecmp (s, "mb", 2) == 0)
		      {
			a = 1;
			m = 1;
		      }
		    else
		      as_bad (_("Invalid Short Load/Store Completer."));
		    s += 2;
		  }
a1712 2
		if (*args == 'C')
		  {
a1715 1
	      }
d1717 2
a1718 7
	    /* Handle a stbys completer.  */
	    case 'Y':
	      {
		int a = 0;
		int m = 0;
		int i = 0;
		while (*s == ',' && i < 2)
d1720 18
a1737 8
		    s++;
		    if (strncasecmp (s, "m", 1) == 0)
		      m = 1;
		    else if (strncasecmp (s, "b", 1) == 0)
		      a = 0;
		    else if (strncasecmp (s, "e", 1) == 0)
		      a = 1;
		    else
d1739 2
a1740 2
		    s++;
		    i++;
d1742 17
a1758 5
		if (i > 2)
		  as_bad (_("Invalid Store Bytes Short Completer"));
		opcode |= m << 5;
		INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
	      }
a2286 12

	    /* Handle a system control completer.  */
	    case 'Z':
	      if (*s == ',' && (*(s + 1) == 'm' || *(s + 1) == 'M'))
		{
		  flag = 1;
		  s += 2;
		}
	      else
		flag = 0;

	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);
@


1.20
log
@        * config/tc-hppa.c (pa_ip):  Add cases for '.', '~'. '$'. and '!'
@
text
@d1769 2
d1898 2
d1933 2
d2070 2
d2138 2
d2192 2
@


1.19
log
@        * config/tc-hppa.c (pa_ip):  Add case for 'I'.
@
text
@d1572 19
d2458 7
d2472 9
d2498 7
@


1.18
log
@        * config/tc-hppa.c (pa_build_unwind_subspace): Use sane section
        flags for the unwind subspace.
@
text
@d2549 6
@


1.17
log
@Fix typos in last change.
@
text
@d4538 2
a4539 1
			     | SEC_LOAD | SEC_RELOC);
@


1.16
log
@
        * config/tc-hppa.c (UNWIND_SECTION_NAME): Define for ELF.
        (pa_build_unwind_subspace): Remove #if 0 wrapper.  Select a
        suitable relocation based on the size of the target's pointer.
        Always Use subsegment zero for the unwinders.
        (pa_level): Handle "2.0w".
@
text
@d4524 2
a4525 2
  if (bfd_get_arch_info (abfd)->bits_per_address == 32)
    reloc = R_PARISC_DIR32
d4527 1
a4527 1
    reloc = R_PARISC_SEGREL32
@


1.15
log
@
        * config/tc-hppa.c (pa_ip, case '?'): Add missing break.
@
text
@d62 2
a4516 1
#if 0
d4519 1
d4521 1
a4521 1
  int i;
d4524 5
a4531 1
  subseg = SUBSEG_UNWIND;
d4543 1
a4543 1
  subseg_set (seg, subseg);
d4554 2
a4555 1
		(expressionS *) NULL, 0, R_PARISC_DIR32, e_fsel, 32, 0, NULL);
d4570 2
a4571 1
		(expressionS *) NULL, 0, R_PARISC_DIR32, e_fsel, 32, 0, NULL);
a4584 1
#endif
d5263 6
@


1.14
log
@
        * config/tc-hppa.c (pa_ip):  Add 64 bit condition completers.
@
text
@d2233 1
@


1.13
log
@
        * config/tc-hppa.c (pa_ip): Change condition args to have '?' prefix.
@
text
@d1732 1
d1739 9
d1749 1
d1808 2
a1809 1
			else
d1826 12
d1861 1
d1867 9
d1892 1
d1899 9
d1909 1
d1968 2
a1969 1
			else
d1986 16
d2027 1
d2034 9
d2044 1
d2084 2
a2085 1
			else
d2093 1
d2101 8
d2110 1
d2137 2
a2138 1
			else
d2145 2
a2146 1
		  case 'u':	/* unit */
d2153 9
d2223 2
a2224 1
			else
@


1.12
log
@
        * config/tc-hppa.c (pa_chk_field_selector): Allow 3 byte
        selectors for ELF too.
        (selector_table): Add "ltp" and "rtp" selectors.
@
text
@d1720 1
a1720 11
	    /* Handle a non-negated compare/stubtract condition.  */
	    case '<':
	      cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
	      if (cmpltr < 0)
		{
		  as_bad (_("Invalid Compare/Subtract Condition: %c"), *s);
		  cmpltr = 0;
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

	    /* Handle a negated or non-negated compare/subtract condition.  */
d1722 416
a2137 389
	      save_s = s;
	      cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
	      if (cmpltr < 0)
		{
		  s = save_s;
		  cmpltr = pa_parse_neg_cmpsub_cmpltr (&s, 1);
		  if (cmpltr < 0)
		    {
		      as_bad (_("Invalid Compare/Subtract Condition."));
		      cmpltr = 0;
		    }
		  else
		    {
		      /* Negated condition requires an opcode change.  */
		      opcode |= 1 << 27;
		    }
		}
	
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

	    /* Handle non-negated add condition.  */
	    case '!':
	      cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
	      if (cmpltr < 0)
		{
		  as_bad (_("Invalid Compare/Subtract Condition: %c"), *s);
		  cmpltr = 0;
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

	    /* Handle a negated or non-negated add condition.  */
	    case '@@':
	      save_s = s;
	      cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
	      if (cmpltr < 0)
		{
		  s = save_s;
		  cmpltr = pa_parse_neg_add_cmpltr (&s, 1);
		  if (cmpltr < 0)
		    {
		      as_bad (_("Invalid Compare/Subtract Condition"));
		      cmpltr = 0;
		    }
		  else
		    {
		      /* Negated condition requires an opcode change.  */
		      opcode |= 1 << 27;
		    }
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

	    /* Handle a compare/subtract condition.  */
	    case 'a':
	      cmpltr = 0;
	      flag = 0;
	      if (*s == ',')
		{
		  s++;
		  name = s;
		  while (*s != ',' && *s != ' ' && *s != '\t')
		    s += 1;
		  c = *s;
		  *s = 0x00;
		  if (strcmp (name, "=") == 0)
		    cmpltr = 1;
		  else if (strcmp (name, "<") == 0)
		    cmpltr = 2;
		  else if (strcmp (name, "<=") == 0)
		    cmpltr = 3;
		  else if (strcasecmp (name, "<<") == 0)
		    cmpltr = 4;
		  else if (strcasecmp (name, "<<=") == 0)
		    cmpltr = 5;
		  else if (strcasecmp (name, "sv") == 0)
		    cmpltr = 6;
		  else if (strcasecmp (name, "od") == 0)
		    cmpltr = 7;
		  else if (strcasecmp (name, "tr") == 0)
		    {
		      cmpltr = 0;
		      flag = 1;
		    }
		  else if (strcmp (name, "<>") == 0)
		    {
		      cmpltr = 1;
		      flag = 1;
		    }
		  else if (strcmp (name, ">=") == 0)
		    {
		      cmpltr = 2;
		      flag = 1;
		    }
		  else if (strcmp (name, ">") == 0)
		    {
		      cmpltr = 3;
		      flag = 1;
		    }
		  else if (strcasecmp (name, ">>=") == 0)
		    {
		      cmpltr = 4;
		      flag = 1;
		    }
		  else if (strcasecmp (name, ">>") == 0)
		    {
		      cmpltr = 5;
		      flag = 1;
		    }
		  else if (strcasecmp (name, "nsv") == 0)
		    {
		      cmpltr = 6;
		      flag = 1;
		    }
		  else if (strcasecmp (name, "ev") == 0)
		    {
		      cmpltr = 7;
		      flag = 1;
		    }
		  else
		    as_bad (_("Invalid Add Condition: %s"), name);
		  *s = c;
		}
	      opcode |= cmpltr << 13;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

	    /* Handle a non-negated add condition.  */
	    case 'd':
	      cmpltr = 0;
	      flag = 0;
	      if (*s == ',')
		{
		  s++;
		  name = s;
		  while (*s != ',' && *s != ' ' && *s != '\t')
		    s += 1;
		  c = *s;
		  *s = 0x00;
		  if (strcmp (name, "=") == 0)
		    cmpltr = 1;
		  else if (strcmp (name, "<") == 0)
		    cmpltr = 2;
		  else if (strcmp (name, "<=") == 0)
		    cmpltr = 3;
		  else if (strcasecmp (name, "nuv") == 0)
		    cmpltr = 4;
		  else if (strcasecmp (name, "znv") == 0)
		    cmpltr = 5;
		  else if (strcasecmp (name, "sv") == 0)
		    cmpltr = 6;
		  else if (strcasecmp (name, "od") == 0)
		    cmpltr = 7;
		  else if (strcasecmp (name, "tr") == 0)
		    {
		      cmpltr = 0;
		      flag = 1;
		    }
		  else if (strcmp (name, "<>") == 0)
		    {
		      cmpltr = 1;
		      flag = 1;
		    }
		  else if (strcmp (name, ">=") == 0)
		    {
		      cmpltr = 2;
		      flag = 1;
		    }
		  else if (strcmp (name, ">") == 0)
		    {
		      cmpltr = 3;
		      flag = 1;
		    }
		  else if (strcasecmp (name, "uv") == 0)
		    {
		      cmpltr = 4;
		      flag = 1;
		    }
		  else if (strcasecmp (name, "vnz") == 0)
		    {
		      cmpltr = 5;
		      flag = 1;
		    }
		  else if (strcasecmp (name, "nsv") == 0)
		    {
		      cmpltr = 6;
		      flag = 1;
		    }
		  else if (strcasecmp (name, "ev") == 0)
		    {
		      cmpltr = 7;
		      flag = 1;
		    }
		  else
		    as_bad (_("Invalid Add Condition: %s"), name);
		  *s = c;
		}
	      opcode |= cmpltr << 13;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

	    /* HANDLE a logical instruction condition.  */
	    case '&':
	      cmpltr = 0;
	      flag = 0;
	      if (*s == ',')
		{
		  s++;
		  name = s;
		  while (*s != ',' && *s != ' ' && *s != '\t')
		    s += 1;
		  c = *s;
		  *s = 0x00;


		  if (strcmp (name, "=") == 0)
		    cmpltr = 1;
		  else if (strcmp (name, "<") == 0)
		    cmpltr = 2;
		  else if (strcmp (name, "<=") == 0)
		    cmpltr = 3;
		  else if (strcasecmp (name, "od") == 0)
		    cmpltr = 7;
		  else if (strcasecmp (name, "tr") == 0)
		    {
		      cmpltr = 0;
		      flag = 1;
		    }
		  else if (strcmp (name, "<>") == 0)
		    {
		      cmpltr = 1;
		      flag = 1;
		    }
		  else if (strcmp (name, ">=") == 0)
		    {
		      cmpltr = 2;
		      flag = 1;
		    }
		  else if (strcmp (name, ">") == 0)
		    {
		      cmpltr = 3;
		      flag = 1;
		    }
		  else if (strcasecmp (name, "ev") == 0)
		    {
		      cmpltr = 7;
		      flag = 1;
		    }
		  else
		    as_bad (_("Invalid Logical Instruction Condition."));
		  *s = c;
		}
	      opcode |= cmpltr << 13;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

	    /* Handle a unit instruction condition.  */
	    case 'U':
	      cmpltr = 0;
	      flag = 0;
	      if (*s == ',')
		{
		  s++;


		  if (strncasecmp (s, "sbz", 3) == 0)
		    {
		      cmpltr = 2;
		      s += 3;
		    }
		  else if (strncasecmp (s, "shz", 3) == 0)
		    {
		      cmpltr = 3;
		      s += 3;
		    }
		  else if (strncasecmp (s, "sdc", 3) == 0)
		    {
		      cmpltr = 4;
		      s += 3;
		    }
		  else if (strncasecmp (s, "sbc", 3) == 0)
		    {
		      cmpltr = 6;
		      s += 3;
		    }
		  else if (strncasecmp (s, "shc", 3) == 0)
		    {
		      cmpltr = 7;
		      s += 3;
		    }
		  else if (strncasecmp (s, "tr", 2) == 0)
		    {
		      cmpltr = 0;
		      flag = 1;
		      s += 2;
		    }
		  else if (strncasecmp (s, "nbz", 3) == 0)
		    {
		      cmpltr = 2;
		      flag = 1;
		      s += 3;
		    }
		  else if (strncasecmp (s, "nhz", 3) == 0)
		    {
		      cmpltr = 3;
		      flag = 1;
		      s += 3;
		    }
		  else if (strncasecmp (s, "ndc", 3) == 0)
		    {
		      cmpltr = 4;
		      flag = 1;
		      s += 3;
		    }
		  else if (strncasecmp (s, "nbc", 3) == 0)
		    {
		      cmpltr = 6;
		      flag = 1;
		      s += 3;
		    }
		  else if (strncasecmp (s, "nhc", 3) == 0)
		    {
		      cmpltr = 7;
		      flag = 1;
		      s += 3;
		    }
		  else
		    as_bad (_("Invalid Logical Instruction Condition."));
		}
	      opcode |= cmpltr << 13;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

	    /* Handle a shift/extract/deposit condition.  */
	    case '|':
	    case '>':
	      cmpltr = 0;
	      if (*s == ',')
		{
		  save_s = s++;


		  name = s;
		  while (*s != ',' && *s != ' ' && *s != '\t')
		    s += 1;
		  c = *s;
		  *s = 0x00;
		  if (strcmp (name, "=") == 0)
		    cmpltr = 1;
		  else if (strcmp (name, "<") == 0)
		    cmpltr = 2;
		  else if (strcasecmp (name, "od") == 0)
		    cmpltr = 3;
		  else if (strcasecmp (name, "tr") == 0)
		    cmpltr = 4;
		  else if (strcmp (name, "<>") == 0)
		    cmpltr = 5;
		  else if (strcmp (name, ">=") == 0)
		    cmpltr = 6;
		  else if (strcasecmp (name, "ev") == 0)
		    cmpltr = 7;
		  /* Handle movb,n.  Put things back the way they were.
		     This includes moving s back to where it started.  */
		  else if (strcasecmp (name, "n") == 0 && *args == '|')
		    {
		      *s = c;
		      s = save_s;
		      continue;
		    }
		  else
		    as_bad (_("Invalid Shift/Extract/Deposit Condition."));
		  *s = c;
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

	    /* Handle bvb and bb conditions.  */
	    case '~':
	      cmpltr = 0;
	      if (*s == ',')
		{
		  s++;
		  if (strncmp (s, "<", 1) == 0)
		    {
		      cmpltr = 0;
		      s++;
		    }
		  else if (strncmp (s, ">=", 2) == 0)
		    {
		      cmpltr = 1;
		      s += 2;
		    }
		  else
		    as_bad (_("Invalid Bit Branch Condition: %c"), *s);
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 15);
a2448 5

	    /* Handle FP compare conditions.  */
	    case 'M':
	      cond = pa_parse_fp_cmp_cond (&s);
	      INSERT_FIELD_AND_CONTINUE (opcode, cond, 0);
@


1.11
log
@        * config/tc-hppa.c (pa_ip):  Add 'J' and 'K' code
        processing.
@
text
@d1000 1
d1011 1
a3633 1
#ifdef OBJ_SOM
a3638 1
#endif
@


1.10
log
@d
        * config/tc-hppa.c (md_pseudo_table): Add ".dword" pseudo-op.
        (cons_fix_new_hppa): Derive size of fixup from size of the object.
@
text
@d2471 12
d2525 12
@


1.9
log
@h
        * config/tc-hppa.c (pa_ip): Convert the opcode and all completers
        into lower case.
@
text
@d622 1
d1295 1
a1295 1
		hppa_field_selector, 32, 0, NULL);
@


1.8
log
@d
        * tc-hppa.c (elf_hppa_reloc_type): Renamed from elf32_hppa_reloc_type.
        (hppa_gen_reloc_type): Conditionalize on BFD64.
        (tc_gen_reloc): Re-enable ELF relocations.
        * tc-hppa.h (TARGET_FORMAT): Handle elf64-hppa format.
@
text
@d1458 6
a1487 8

  /* Convert everything into lower case.  */
  while (*save_s)
    {
      if (isupper (*save_s))
	*save_s = tolower (*save_s);
      save_s++;
    }
@


1.7
log
@        * tc-hppa.c: General cleanups of ELF support.  No more spaces
        and subspaces for ELF.
        (GDB_DEBUG_SPACE_NAME): Delete definition for ELF.
        (GDB_STRINGS_SUBSPACE_NAME): Likewise.
        (GDB_SYMBOLS_SUBSPACE_NAME): Likewise
        (UNWIND_SECTION_NAME): Likewise.
        (space/subspace related structures): Conditionalize definitions
        on OBJ_SOM.
        (space/subspace directives and support routines): Conditionalize
        definitions and references/uses on OBJ_SOM.
        (label_symbol_struct): For ELF, track the symbol's segment.  For
        SOM track its space.
        (pa_define_label, pa_undefine_label, pa_get_label): Corresponding
        changes.
        (USE_ALIASES): Kill for both SOM & ELF.
        (pa_def_subspaces, pa_def_spaces): Corresponding changes.
        (pa_space, pa_subspace): Corresponding changes.
        (pa_spaces_begin): Corresponding chagnes.
        (md_begin): Do not muck around with space/subspace stuff for
        OBJ_ELF.
        (md_apply_fix): Temporarily disable argument relocation stuff
        for OBJ_ELF.
        (tc_gen_reloc): Temporarily disable relocation generation for
        OBJ_ELF
        (pa_build_unwind_subspace): Similarly.
@
text
@d46 1
a46 1
typedef elf32_hppa_reloc_type reloc_type;
d51 1
d53 4
a56 1
#define hppa_gen_reloc_type hppa_elf_gen_reloc_type
a2784 1
#if 0
a2835 1
#endif
@


1.6
log
@1999-06-04  Mark Klein <mklein@@dis.com>
	* config/tc-hppa.c (md_begin): Convert local symbol dummy_symbol
	to real if OBJ_SOM
	(tc_gen_reloc): Still need bfd_abs_symbol in some relocs.
@
text
@d38 4
a44 7
/* Names of various debugging spaces/subspaces.  */
#define GDB_DEBUG_SPACE_NAME ".stab"
#define GDB_STRINGS_SUBSPACE_NAME ".stabstr"
#define GDB_SYMBOLS_SUBSPACE_NAME ".stab"
#define UNWIND_SECTION_NAME ".PARISC.unwind"
/* Nonzero if CODE is a fixup code needing further processing.  */

a57 3

/* Use space aliases.  */
#define USE_ALIASES 1
a73 3
/* Do not use space aliases.  */
#define USE_ALIASES 0

d262 1
a316 11
/* Structure for previous label tracking.  Needed so that alignments,
   callinfo declarations, etc can be easily attached to a particular
   label.  */
typedef struct label_symbol_struct
  {
    symbolS *lss_label;
    sd_chain_struct *lss_space;
    struct label_symbol_struct *lss_next;
  }
label_symbol_struct;

a362 3
    /* An alias for this section (or NULL if no alias exists).  */
    char *alias;

d393 2
d396 15
a410 3
    /* An alias for this section (or NULL if no alias exists).  */
    char *alias;
  };
d457 1
d459 2
a481 1
static void pa_align PARAMS ((int));
a489 3
#ifdef OBJ_SOM
static void pa_compiler PARAMS ((int));
#endif
a504 3
static void pa_space PARAMS ((int));
static void pa_spnum PARAMS ((int));
static void pa_subspace PARAMS ((int));
d511 6
d537 4
a551 1
static sd_chain_struct *pa_parse_space_stmt PARAMS ((char *, int));
a552 1
static int pa_next_subseg PARAMS ((sd_chain_struct *));
a553 1
static void pa_spaces_begin PARAMS ((void));
d562 1
d570 1
d597 1
d599 4
d637 1
d639 1
d650 1
d653 1
d656 1
d658 1
d1008 1
d1026 5
a1030 8
  {"$CODE$", 1, 1, 1, 0, 0, 0, 24, 0x2c, 0, 8, 0, 0, ".text", SUBSEG_CODE},
  {"$DATA$", 1, 1, 0, 0, 0, 0, 24, 0x1f, 1, 8, 1, 1, ".data", SUBSEG_DATA},
  {"$LIT$", 1, 1, 0, 0, 0, 0, 16, 0x2c, 0, 8, 0, 0, ".text", SUBSEG_LIT},
  {"$MILLICODE$", 1, 1, 0, 0, 0, 0, 8, 0x2c, 0, 8, 0, 0, ".text", SUBSEG_MILLI},
  {"$BSS$", 1, 1, 0, 0, 0, 1, 80, 0x1f, 1, 8, 1, 1, ".bss", SUBSEG_BSS},
#ifdef OBJ_ELF
  {"$UNWIND$", 1, 1, 0, 0, 0, 0, 64, 0x2c, 0, 4, 0, 0, ".PARISC.unwind", SUBSEG_UNWIND},
#endif
d1036 3
a1038 3
  {"$TEXT$", 0, 1, 1, 0, 8, ASEC_NULL, ".text"},
  {"$PRIVATE$", 1, 1, 1, 1, 16, ASEC_NULL, ".data"},
  {NULL, 0, 0, 0, 0, 0, ASEC_NULL, NULL}
a1042 5
/* Return nonzero if the string pointed to by S potentially represents
   a right or left half of a FP register  */
#define IS_R_SELECT(S)   (*(S) == 'R' || *(S) == 'r')
#define IS_L_SELECT(S)   (*(S) == 'L' || *(S) == 'l')

d1051 6
a1109 12
/* Check to make sure we have a valid space and subspace.  */

static void
pa_check_current_space_and_subspace ()
{
  if (current_space == NULL)
    as_fatal (_("Not in a space.\n"));

  if (current_subspace == NULL)
    as_fatal (_("Not in a subspace.\n"));
}

a1116 1
  sd_chain_struct *space_chain = current_space;
d1121 7
a1127 1
    if (space_chain == label_chain->lss_space && label_chain->lss_label)
d1129 2
a1142 1
  sd_chain_struct *space_chain = current_space;
d1152 6
a1157 1
      label_chain->lss_space = space_chain;
a1174 1
  sd_chain_struct *space_chain = current_space;
d1180 8
a1187 1
      if (space_chain == label_chain->lss_space && label_chain->lss_label)
d1321 1
d1323 1
d1353 1
d1357 1
d1449 1
d1452 1
d2781 1
d2833 1
d3103 1
d3107 1
d4183 1
d4200 1
d4213 1
d4216 1
d4294 1
d4297 1
d4381 1
d4443 1
d4458 1
d4461 1
d4598 1
d4602 1
d4671 1
d4674 1
d4686 1
d4689 1
d4793 1
d4796 1
d4961 1
d4963 1
d4975 1
d4977 1
d4987 1
d4989 1
d5094 1
d5097 1
d5144 1
d5147 1
d5197 1
d5200 1
d5266 1
d5269 1
d5330 32
a5629 18
/* If VALUE is an exact power of two between zero and 2^31, then
   return log2 (VALUE).  Else return -1.  */

static int
log2 (value)
     int value;
{
  int shift = 0;

  while ((1 << shift) != value && shift < 32)
    shift++;

  if (shift >= 32)
    return -1;
  else
    return shift;
}

d5640 1
a5640 1
  char *name, *ss_name, *alias, c;
a5673 1
      alias = NULL;
a5709 2
		  if (USE_ALIASES && pa_def_subspaces[i].alias)
		    alias = pa_def_subspaces[i].alias;
a5817 8
      else if (alias)
	section = subseg_new (alias, 0);
      else if (!alias && USE_ALIASES)
	{
	  as_warn (_("Ignoring subspace decl due to ELF BFD bugs."));
	  demand_empty_rest_of_line ();
	  return;
	}
d5874 1
a5874 4
      if (pa_def_spaces[i].alias && USE_ALIASES)
	name = pa_def_spaces[i].alias;
      else
	name = pa_def_spaces[i].name;
d5894 2
a5895 10
      if (pa_def_subspaces[i].alias && USE_ALIASES)
	{
	  name = pa_def_subspaces[i].alias;
	  subsegment = pa_def_subspaces[i].subsegment;
	}
      else
	{
	  name = pa_def_subspaces[i].name;
	  subsegment = 0;
	}
d5904 1
a5904 1
      if (!strcmp (pa_def_subspaces[i].name, "$CODE$") && !USE_ALIASES)
d5914 1
a5914 1
      else if (!strcmp (pa_def_subspaces[i].name, "$DATA$") && !USE_ALIASES)
d5925 1
a5925 1
      else if (!strcmp (pa_def_subspaces[i].name, "$BSS$") && !USE_ALIASES)
d5932 1
a5932 1
      else if (!strcmp (pa_def_subspaces[i].name, "$LIT$") && !USE_ALIASES)
d5941 1
a5941 2
      else if (!strcmp (pa_def_subspaces[i].name, "$MILLICODE$")
	       && !USE_ALIASES)
d5950 1
a5950 1
      else if (!strcmp (pa_def_subspaces[i].name, "$UNWIND$") && !USE_ALIASES)
d6101 1
a6101 1
  chain_entry->ssd_subseg = USE_ALIASES ? pa_next_subseg (space) : 0;
a6319 1
#ifdef OBJ_SOM
a6327 1
#endif
d6340 1
d6351 1
d6354 1
d6495 1
d6499 1
d6520 1
d6523 1
d6535 1
d6538 1
d6550 1
d6553 1
d6565 1
d6569 1
d6686 1
d6695 1
@


1.5
log
@1999-06-04  Mark Klein <mklein@@dis.com>
	* config/tc-hppa.c: Update for symbol handling changes.
@
text
@d705 1
a705 1

d708 1
d1343 1
d1346 3
d2833 1
a2833 2
    relocs[0]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
    *relocs[0]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2837 2
a2838 2
    relocs[1]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
    *relocs[1]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2842 2
a2843 2
    relocs[2]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
    *relocs[2]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2847 1
a2847 2
    relocs[3]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
    *relocs[3]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2851 1
a2851 2
    relocs[4]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
    *relocs[4]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2889 2
a2890 2
    relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
    *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
d2898 2
a2899 2
    relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
    *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
@


1.4
log
@	* config/tc-hppa.h: Update for symbol handling changes.
	* config/tc-hppa.c: Likewise.
@
text
@d2816 2
a2817 1
      relocs[i]->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d2828 2
a2829 1
	  relocs[0]->sym_ptr_ptr = (asymbol **) &bfd_abs_symbol;
d2833 2
a2834 1
	  relocs[1]->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d2838 2
a2839 1
	  relocs[2]->sym_ptr_ptr = &fixp->fx_subsy->bsym;
d2843 2
a2844 1
	  relocs[3]->sym_ptr_ptr = (asymbol **) &bfd_abs_symbol;
d2848 2
a2849 1
	  relocs[4]->sym_ptr_ptr = (asymbol **) &bfd_abs_symbol;
d2887 2
a2888 1
	  relocs[i]->sym_ptr_ptr = &dummy_symbol->bsym;
d2896 2
a2897 1
	  relocs[i]->sym_ptr_ptr = &dummy_symbol->bsym;
d6566 1
a6566 1
      fixp->fx_subsy->sy_used_in_reloc = 1;
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d1075 1
a1075 1
   && strcmp((exp).X_op_symbol->bsym->name, "$global$") == 0)
d1079 1
a1079 1
   && strcmp((exp).X_op_symbol->bsym->name, "$PIC_pcrel$0") == 0)
d1372 2
a1373 1
	      label_symbol->lss_label->bsym->flags |= BSF_FUNCTION;
d2735 2
a2736 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d2742 1
a2742 1
			       fixp->fx_addsy->bsym);
d2765 2
a2766 1
      reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d3074 2
a3075 2
			fixP->fx_addsy->bsym)->tc_data.ap.hppa_arg_reloc,
				    hppa_fixP->fx_arg_reloc)
d4608 1
a4608 1
      symbol->sy_frag = &zero_address_frag;
d4815 1
a4815 1
  obj_symbol_type *symbol = (obj_symbol_type *) symbolP->bsym;
d4821 1
a4821 1
      symbolP->bsym->flags &= ~BSF_FUNCTION;
d4834 1
a4834 1
      if (symbolP->bsym->flags & BSF_FUNCTION)
d4837 2
a4838 1
	    as_tsktsk (_("Using ENTRY rather than CODE in export directive for %s"), symbolP->bsym->name);
d4840 1
a4840 1
	  symbolP->bsym->flags |= BSF_FUNCTION;
d4845 1
a4845 1
	  symbolP->bsym->flags &= ~BSF_FUNCTION;
d4852 1
a4852 1
      symbolP->bsym->flags &= ~BSF_FUNCTION;
d4858 1
a4858 1
      symbolP->bsym->flags |= BSF_FUNCTION;
d4864 1
a4864 1
      symbolP->bsym->flags |= BSF_FUNCTION;
d4870 1
a4870 1
      symbolP->bsym->flags &= ~BSF_FUNCTION;
d4876 1
a4876 1
      symbolP->bsym->flags |= BSF_FUNCTION;
d4882 1
a4882 1
      symbolP->bsym->flags |= BSF_FUNCTION;
d4890 1
a4890 1
  obj_set_symbol_type (symbolP->bsym, (int) type);
d4984 1
a4984 1
	    symbol->bsym->flags |= BSF_FUNCTION;
d5184 1
a5184 1
	    label_symbol->lss_label->bsym->flags |= BSF_FUNCTION;
d5223 2
a5224 1
	      label_symbol->lss_label->bsym->flags |= BSF_FUNCTION;
d6580 1
a6580 1
  if (fixp->fx_addsy && fixp->fx_addsy->bsym->flags & BSF_GLOBAL)
d6588 1
a6588 2
  if (fixp->fx_addsy == 0
      || (fixp->fx_addsy->bsym->flags & BSF_FUNCTION) == 0)
d6625 2
a6626 3
				  fixp->fx_addsy->bsym)->tc_data.ap.hppa_arg_reloc,

				 hppa_fixp->fx_arg_reloc)))
d6684 1
a6684 1
	  symbolP->bsym->flags = BSF_LOCAL;
d6714 2
a6715 1
      = (elf_symbol_type *) call_info_pointer->start_symbol->bsym;
@


1.2
log
@        * config/tc-hppa.c (md_apply_fix): Handle 22 bit fmt insn like a
        17 bit fmt insn.
@
text
@d2 2
a3 1
   Copyright (C) 1989, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
d330 1
a330 1
    struct symbol *lss_label;
@


1.1
log
@Initial revision
@
text
@d3042 1
a3042 1
	new_val = ((fmt == 12 || fmt == 17) ? 8 : 0);
d3051 1
a3051 1
	new_val = ((fmt == 12 || fmt == 17) ? 8 : 0);
d3066 1
a3066 1
      if ((fmt == 12 || fmt == 17)
d3072 1
a3072 1
	  && ((int)(*valp) > -262144 && (int)(*valp) < 262143)
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

