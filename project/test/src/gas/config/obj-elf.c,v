head	1.150;
access;
symbols
	binutils-2_24-branch:1.150.0.2
	binutils-2_24-branchpoint:1.150
	binutils-2_21_1:1.133.2.5
	binutils-2_23_2:1.147
	binutils-2_23_1:1.147
	binutils-2_23:1.147
	binutils-2_23-branch:1.147.0.2
	binutils-2_23-branchpoint:1.147
	binutils-2_22_branch:1.143.0.4
	binutils-2_22:1.143
	binutils-2_22-branch:1.143.0.2
	binutils-2_22-branchpoint:1.143
	binutils-2_21:1.133.2.3
	binutils-2_21-branch:1.133.0.2
	binutils-2_21-branchpoint:1.133
	binutils-2_20_1:1.121.2.1
	binutils-2_20:1.121.2.1
	binutils-arc-20081103-branch:1.109.0.6
	binutils-arc-20081103-branchpoint:1.109
	binutils-2_20-branch:1.121.0.2
	binutils-2_20-branchpoint:1.121
	dje-cgen-play1-branch:1.114.0.2
	dje-cgen-play1-branchpoint:1.114
	arc-20081103-branch:1.109.0.4
	arc-20081103-branchpoint:1.109
	binutils-2_19_1:1.109
	binutils-2_19:1.109
	binutils-2_19-branch:1.109.0.2
	binutils-2_19-branchpoint:1.109
	binutils-2_18:1.103
	binutils-2_18-branch:1.103.0.2
	binutils-2_18-branchpoint:1.103
	binutils-csl-coldfire-4_1-32:1.96
	binutils-csl-sourcerygxx-4_1-32:1.96
	binutils-csl-innovasic-fido-3_4_4-33:1.96
	binutils-csl-sourcerygxx-3_4_4-32:1.91
	binutils-csl-coldfire-4_1-30:1.96
	binutils-csl-sourcerygxx-4_1-30:1.96
	binutils-csl-coldfire-4_1-28:1.96
	binutils-csl-sourcerygxx-4_1-29:1.96
	binutils-csl-sourcerygxx-4_1-28:1.96
	binutils-csl-arm-2006q3-27:1.96
	binutils-csl-sourcerygxx-4_1-27:1.96
	binutils-csl-arm-2006q3-26:1.96
	binutils-csl-sourcerygxx-4_1-26:1.96
	binutils-csl-sourcerygxx-4_1-25:1.96
	binutils-csl-sourcerygxx-4_1-24:1.96
	binutils-csl-sourcerygxx-4_1-23:1.96
	binutils-csl-sourcerygxx-4_1-21:1.96
	binutils-csl-arm-2006q3-21:1.96
	binutils-csl-sourcerygxx-4_1-22:1.96
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.96
	binutils-csl-sourcerygxx-4_1-20:1.96
	binutils-csl-arm-2006q3-19:1.96
	binutils-csl-sourcerygxx-4_1-19:1.96
	binutils-csl-sourcerygxx-4_1-18:1.96
	binutils-csl-renesas-4_1-9:1.96
	binutils-csl-sourcerygxx-3_4_4-25:1.91
	binutils-csl-renesas-4_1-8:1.96
	binutils-csl-renesas-4_1-7:1.96
	binutils-csl-renesas-4_1-6:1.96
	binutils-csl-sourcerygxx-4_1-17:1.96
	binutils-csl-sourcerygxx-4_1-14:1.96
	binutils-csl-sourcerygxx-4_1-15:1.96
	binutils-csl-sourcerygxx-4_1-13:1.96
	binutils-2_17:1.96
	binutils-csl-sourcerygxx-4_1-12:1.96
	binutils-csl-sourcerygxx-3_4_4-21:1.96
	binutils-csl-wrs-linux-3_4_4-24:1.91
	binutils-csl-wrs-linux-3_4_4-23:1.91
	binutils-csl-sourcerygxx-4_1-9:1.96
	binutils-csl-sourcerygxx-4_1-8:1.96
	binutils-csl-sourcerygxx-4_1-7:1.96
	binutils-csl-arm-2006q1-6:1.96
	binutils-csl-sourcerygxx-4_1-6:1.96
	binutils-csl-wrs-linux-3_4_4-22:1.91
	binutils-csl-coldfire-4_1-11:1.96
	binutils-csl-sourcerygxx-3_4_4-19:1.96
	binutils-csl-coldfire-4_1-10:1.96
	binutils-csl-sourcerygxx-4_1-5:1.96
	binutils-csl-sourcerygxx-4_1-4:1.96
	binutils-csl-wrs-linux-3_4_4-21:1.91
	binutils-csl-morpho-4_1-4:1.96
	binutils-csl-sourcerygxx-3_4_4-17:1.96
	binutils-csl-wrs-linux-3_4_4-20:1.91
	binutils-2_17-branch:1.96.0.4
	binutils-2_17-branchpoint:1.96
	binutils-csl-2_17-branch:1.96.0.2
	binutils-csl-2_17-branchpoint:1.96
	binutils-csl-gxxpro-3_4-branch:1.91.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.91
	binutils-2_16_1:1.91
	binutils-csl-arm-2005q1b:1.91
	binutils-2_16:1.91
	binutils-csl-arm-2005q1a:1.91
	binutils-csl-arm-2005q1-branch:1.91.0.4
	binutils-csl-arm-2005q1-branchpoint:1.91
	binutils-2_16-branch:1.91.0.2
	binutils-2_16-branchpoint:1.91
	csl-arm-2004-q3d:1.86
	csl-arm-2004-q3:1.86
	binutils-2_15:1.79.6.1
	binutils-2_15-branchpoint:1.79
	csl-arm-2004-q1a:1.84
	csl-arm-2004-q1:1.80
	binutils-2_15-branch:1.79.0.6
	cagney_bfdfile-20040213-branch:1.79.0.4
	cagney_bfdfile-20040213-branchpoint:1.79
	cagney_bigcore-20040122-branch:1.79.0.2
	cagney_bigcore-20040122-branchpoint:1.79
	csl-arm-2003-q4:1.79
	binutils-2_14:1.62.2.1
	binutils-2_14-branch:1.62.0.2
	binutils-2_14-branchpoint:1.62
	binutils-2_13_2_1:1.52.2.1
	binutils-2_13_2:1.52.2.1
	binutils-2_13_1:1.52
	binutils-2_13:1.52
	binutils-2_13-branchpoint:1.52
	binutils-2_13-branch:1.52.0.2
	binutils-2_12_1:1.46.2.1
	binutils-2_12:1.46
	binutils-2_12-branch:1.46.0.2
	binutils-2_12-branchpoint:1.46
	cygnus_cvs_20020108_pre:1.45
	binutils-2_11_2:1.28.2.1
	binutils-2_11_1:1.28.2.1
	binutils-2_11:1.28
	x86_64versiong3:1.28
	binutils-2_11-branch:1.28.0.2
	binutils-2_10_1:1.15
	binutils-2_10:1.15
	binutils-2_10-branch:1.15.0.2
	binutils-2_10-branchpoint:1.15
	binutils_latest_snapshot:1.150
	repo-unification-2000-02-06:1.13
	binu_ss_19990721:1.9
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.150
date	2013.02.06.23.22.13;	author sandra;	state Exp;
branches;
next	1.149;

1.149
date	2012.11.09.18.07.10;	author macro;	state Exp;
branches;
next	1.148;

1.148
date	2012.11.09.17.00.44;	author nickc;	state Exp;
branches;
next	1.147;

1.147
date	2012.06.30.06.32.29;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2012.05.19.10.36.32;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2012.02.02.09.26.04;	author nickc;	state Exp;
branches;
next	1.144;

1.144
date	2011.12.15.11.37.03;	author nickc;	state Exp;
branches;
next	1.143;

1.143
date	2011.08.04.07.44.44;	author gingold;	state Exp;
branches;
next	1.142;

1.142
date	2011.07.03.13.37.08;	author tschwinge;	state Exp;
branches;
next	1.141;

1.141
date	2011.03.30.15.06.51;	author nickc;	state Exp;
branches;
next	1.140;

1.140
date	2011.03.18.11.21.33;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2011.03.16.12.58.26;	author hjl;	state Exp;
branches;
next	1.138;

1.138
date	2011.03.06.14.05.24;	author hjl;	state Exp;
branches;
next	1.137;

1.137
date	2011.02.25.13.45.54;	author amodra;	state Exp;
branches;
next	1.136;

1.136
date	2010.11.18.16.00.25;	author ro;	state Exp;
branches;
next	1.135;

1.135
date	2010.11.15.18.12.42;	author hjl;	state Exp;
branches;
next	1.134;

1.134
date	2010.11.15.12.31.05;	author ro;	state Exp;
branches;
next	1.133;

1.133
date	2010.10.25.12.38.42;	author amodra;	state Exp;
branches
	1.133.2.1;
next	1.132;

1.132
date	2010.10.23.18.05.08;	author mmitchel;	state Exp;
branches;
next	1.131;

1.131
date	2010.09.16.23.55.09;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2010.08.31.05.34.46;	author amodra;	state Exp;
branches;
next	1.129;

1.129
date	2010.08.17.20.03.40;	author roland;	state Exp;
branches;
next	1.128;

1.128
date	2010.07.15.14.34.41;	author nathan;	state Exp;
branches;
next	1.127;

1.127
date	2010.05.18.03.31.04;	author hjl;	state Exp;
branches;
next	1.126;

1.126
date	2010.01.13.14.08.52;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2009.11.06.11.51.04;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2009.11.02.11.49.48;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2009.09.25.19.13.26;	author nickc;	state Exp;
branches;
next	1.122;

1.122
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.121;

1.121
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches
	1.121.2.1;
next	1.120;

1.120
date	2009.08.31.12.02.35;	author jbeulich;	state Exp;
branches;
next	1.119;

1.119
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.118;

1.118
date	2009.07.31.18.14.06;	author drow;	state Exp;
branches;
next	1.117;

1.117
date	2009.07.27.10.04.24;	author jbeulich;	state Exp;
branches;
next	1.116;

1.116
date	2009.07.24.23.49.51;	author roland;	state Exp;
branches;
next	1.115;

1.115
date	2009.07.23.13.00.27;	author nickc;	state Exp;
branches;
next	1.114;

1.114
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	2009.04.30.15.47.12;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2009.01.15.12.42.52;	author nickc;	state Exp;
branches;
next	1.111;

1.111
date	2008.12.23.09.01.47;	author nickc;	state Exp;
branches;
next	1.110;

1.110
date	2008.12.03.14.50.58;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	2008.04.23.13.54.56;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	2007.10.27.17.45.53;	author hjl;	state Exp;
branches;
next	1.107;

1.107
date	2007.10.16.14.42.14;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2007.10.11.20.20.55;	author nickc;	state Exp;
branches;
next	1.105;

1.105
date	2007.10.08.15.26.42;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2007.07.03.03.29.40;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2007.02.27.07.16.31;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2007.02.05.20.10.25;	author brolley;	state Exp;
branches;
next	1.99;

1.99
date	2006.11.22.03.35.36;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2006.11.10.07.47.14;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2006.05.05.18.24.45;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2005.09.20.18.24.44;	author rth;	state Exp;
branches;
next	1.95;

1.95
date	2005.07.25.15.41.07;	author hjl;	state Exp;
branches;
next	1.94;

1.94
date	2005.07.04.01.53.44;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2005.05.05.09.12.52;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	2005.04.15.11.38.57;	author jbeulich;	state Exp;
branches;
next	1.91;

1.91
date	2005.02.22.12.58.35;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2005.02.17.13.46.03;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2005.01.31.23.18.24;	author bje;	state Exp;
branches;
next	1.88;

1.88
date	2004.12.16.13.23.21;	author jbeulich;	state Exp;
branches;
next	1.87;

1.87
date	2004.11.10.03.28.45;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2004.09.08.20.52.48;	author pbrook;	state Exp;
branches;
next	1.85;

1.85
date	2004.06.15.01.16.35;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2004.05.03.04.08.32;	author hjl;	state Exp;
branches;
next	1.83;

1.83
date	2004.05.02.14.36.25;	author hjl;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.30.16.47.46;	author hjl;	state Exp;
branches;
next	1.81;

1.81
date	2004.04.27.03.59.09;	author hjl;	state Exp;
branches;
next	1.80;

1.80
date	2004.03.18.13.31.04;	author nathan;	state Exp;
branches;
next	1.79;

1.79
date	2003.12.13.12.57.40;	author amodra;	state Exp;
branches
	1.79.6.1;
next	1.78;

1.78
date	2003.12.13.08.59.24;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2003.12.13.08.23.05;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2003.12.03.03.20.13;	author kazu;	state Exp;
branches;
next	1.75;

1.75
date	2003.11.20.00.01.55;	author kazu;	state Exp;
branches;
next	1.74;

1.74
date	2003.10.24.15.41.23;	author hjl;	state Exp;
branches;
next	1.73;

1.73
date	2003.09.23.00.41.14;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2003.07.30.14.11.03;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2003.07.29.02.03.32;	author hjl;	state Exp;
branches;
next	1.70;

1.70
date	2003.07.26.01.06.27;	author hjl;	state Exp;
branches;
next	1.69;

1.69
date	2003.07.25.16.08.28;	author hjl;	state Exp;
branches;
next	1.68;

1.68
date	2003.07.25.14.35.54;	author hjl;	state Exp;
branches;
next	1.67;

1.67
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2003.05.03.16.04.11;	author hjl;	state Exp;
branches;
next	1.65;

1.65
date	2003.05.02.03.01.44;	author hjl;	state Exp;
branches;
next	1.64;

1.64
date	2003.05.02.02.46.36;	author hjl;	state Exp;
branches;
next	1.63;

1.63
date	2003.04.29.11.52.37;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2003.01.24.23.44.44;	author jakub;	state Exp;
branches;
next	1.60;

1.60
date	2003.01.11.06.24.12;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2003.01.01.16.56.34;	author danglin;	state Exp;
branches;
next	1.58;

1.58
date	2002.11.30.08.39.42;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2002.11.20.02.39.21;	author rth;	state Exp;
branches;
next	1.56;

1.56
date	2002.10.22.10.56.45;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2002.09.17.07.38.14;	author ths;	state Exp;
branches;
next	1.54;

1.54
date	2002.09.05.00.01.16;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.17.15.09.29;	author scox;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.07.14.57.50;	author amodra;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2002.06.04.01.06.16;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.23.13.12.47;	author jakub;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.09.13.12.57;	author kazu;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.04.20.40.48;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.01.18.36.08;	author jakub;	state Exp;
branches;
next	1.46;

1.46
date	2002.01.28.13.34.39;	author jakub;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2001.12.14.15.53.11;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.13.03.24.25;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.09.13.13.09;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.09.06.07.33;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.07.06.16.54;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2001.10.01.06.30.19;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.19.05.33.21;	author hjl;	state Exp;
branches;
next	1.38;

1.38
date	2001.09.18.10.08.15;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2001.09.11.16.46.38;	author jakub;	state Exp;
branches;
next	1.36;

1.36
date	2001.08.23.20.43.01;	author jakub;	state Exp;
branches;
next	1.35;

1.35
date	2001.08.09.14.42.07;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.08.13.11.58;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.30.06.15.49;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.11.19.35.17;	author jhealy;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.10.21.49.11;	author jhealy;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.13.00.34.36;	author jakub;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.16.19.29.12;	author hjl;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2000.11.14.20.57.30;	author kazu;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.13.21.23.33;	author hjl;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.13.01.12.31;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.08.00.24.23;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.11.07.05.02;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.07.12.52.15;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.14.11.48.26;	author kazu;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.05.03.23.05;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.29.03.20.54;	author jle;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.19.01.22.40;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.22.21.19.43;	author hp;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.20.01.43.32;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.28.04.17.36;	author ian;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.23.13.52.21;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.26.23.58.13;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.26.22.48.31;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.03.18.34.24;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	99.11.03.22.13.33;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.07.11.20.20.03;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.06.23.09.27.08;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.06.07.02.28.51;	author schwab;	state Exp;
branches;
next	1.6;

1.6
date	99.06.06.00.09.50;	author rth;	state Exp;
branches;
next	1.5;

1.5
date	99.06.05.23.15.30;	author rth;	state Exp;
branches;
next	1.4;

1.4
date	99.06.03.02.50.51;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.15;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.28.15.28.55;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.133.2.1
date	2010.11.15.16.02.40;	author ro;	state Exp;
branches;
next	1.133.2.2;

1.133.2.2
date	2010.11.15.18.49.37;	author ro;	state Exp;
branches;
next	1.133.2.3;

1.133.2.3
date	2010.11.18.16.02.08;	author ro;	state Exp;
branches;
next	1.133.2.4;

1.133.2.4
date	2011.02.25.13.46.36;	author amodra;	state Exp;
branches;
next	1.133.2.5;

1.133.2.5
date	2011.03.18.12.01.50;	author amodra;	state Exp;
branches;
next	;

1.121.2.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.79.6.1
date	2004.04.09.18.28.11;	author drow;	state Exp;
branches;
next	;

1.62.2.1
date	2003.04.29.11.57.08;	author nickc;	state Exp;
branches;
next	;

1.52.2.1
date	2002.11.20.02.40.55;	author rth;	state Exp;
branches;
next	;

1.46.2.1
date	2002.03.28.06.25.03;	author amodra;	state Exp;
branches;
next	;

1.28.2.1
date	2001.06.07.03.15.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.150
log
@2013-02-06  Sandra Loosemore  <sandra@@codesourcery.com>
            Andrew Jenner <andrew@@codesourcery.com>

	Based on patches from Altera Corporation.

	bfd/
	* Makefile.am (ALL_MACHINES): Add cpu-nios2.lo.
	(ALL_MACHINES_CFILES): Add cpu-nios2.c.
	(BFD_BACKENDS): Add elf32-nios2.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-nios2.c.
	* Makefile.in: Regenerated.
	* configure.in: Add entries for bfd_elf32_bignios2_vec and
	bfd_elf32_littlenios2_vec.
	* configure: Regenerated.
	* config.bfd: Add cases for nios2.
	* archures.c (enum bfd_architecture): Add bfd_arch_nios2.
	(bfd_mach_nios2): Define.
	(bfd_nios2_arch): Declare.
	(bfd_archures_list): Add bfd_nios2_arch.
	* targets.c (bfd_elf32_bignios2_vec): Declare.
	(bfd_elf32_littlenios2_vec): Declare.
	(_bfd_target_vector): Add entries for bfd_elf32_bignios2_vec and
	bfd_elf32_littlenios2_vec.
	* elf-bfd.h (enum elf_target_id): Add NIOS2_ELF_DATA.
	* reloc.c (enum bfd_reloc_code_real): Add Nios II relocations.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
	* cpu-nios2.c: New file.
	* elf32-nios2.c: New file.

	opcodes/
	* Makefile.am (TARGET_LIBOPCODES_CFILES): Add nios2-dis.c and
	nios2-opc.c.
	* Makefile.in: Regenerated.
	* configure.in: Add case for bfd_nios2_arch.
	* configure: Regenerated.
	* disassemble.c (ARCH_nios2): Define.
	(disassembler): Add case for bfd_arch_nios2.
	* nios2-dis.c: New file.
	* nios2-opc.c: New file.

	include/
	* dis-asm.h (print_insn_big_nios2): Declare.
	(print_insn_little_nios2): Declare.

	include/elf
	* nios2.h: New file.

	include/opcode/
	* nios2.h: New file.

	gas/
	* Makefile.am (TARGET_CPU_CFILES): Add config/tc-nios2.c.
	(TARGET_CPU_HFILES): Add config/tc-nios2.h.
	* Makefile.in: Regenerated.
	* configure.tgt: Add case for nios2*-linux*.
	* config/obj-elf.c: Conditionally include elf/nios2.h.
	* config/tc-nios2.c: New file.
	* config/tc-nios2.h: New file.
	* doc/Makefile.am (CPU_DOCS): Add c-nios2.texi.
	* doc/Makefile.in: Regenerated.
	* doc/all.texi: Set NIOSII.
	* doc/as.texinfo (Overview): Add Nios II options.
	(Machine Dependencies): Include c-nios2.texi.
	* doc/c-nios2.texi: New file.
	* NEWS: Note Altera Nios II support.

	gas/testsuite/
	* gas/nios2/add.d: New.
	* gas/nios2/add.s: New.
	* gas/nios2/align_fill.d: New.
	* gas/nios2/align_fill.s: New.
	* gas/nios2/align_text.d: New.
	* gas/nios2/align_text.s: New.
	* gas/nios2/and.d: New.
	* gas/nios2/and.s: New.
	* gas/nios2/branch.d: New.
	* gas/nios2/branch.s: New.
	* gas/nios2/break.d: New.
	* gas/nios2/break.s: New.
	* gas/nios2/bret.d: New.
	* gas/nios2/bret.s: New.
	* gas/nios2/cache.d: New.
	* gas/nios2/cache.s: New.
	* gas/nios2/call26.d: New.
	* gas/nios2/call26.s: New.
	* gas/nios2/call.d: New.
	* gas/nios2/call.s: New.
	* gas/nios2/cmp.d: New.
	* gas/nios2/cmp.s: New.
	* gas/nios2/comments.d: New.
	* gas/nios2/comments.s: New.
	* gas/nios2/complex.d: New.
	* gas/nios2/complex.s: New.
	* gas/nios2/ctl.d: New.
	* gas/nios2/ctl.s: New.
	* gas/nios2/custom.d: New.
	* gas/nios2/custom.s: New.
	* gas/nios2/etbt.d: New.
	* gas/nios2/etbt.s: New.
	* gas/nios2/flushda.d: New.
	* gas/nios2/flushda.s: New.
	* gas/nios2/illegal.l: New.
	* gas/nios2/illegal.s: New.
	* gas/nios2/jmp.d: New.
	* gas/nios2/jmp.s: New.
	* gas/nios2/ldb.d: New.
	* gas/nios2/ldb.s: New.
	* gas/nios2/ldh.d: New.
	* gas/nios2/ldh.s: New.
	* gas/nios2/ldw.d: New.
	* gas/nios2/ldw.s: New.
	* gas/nios2/lineseparator.d: New.
	* gas/nios2/lineseparator.s: New.
	* gas/nios2/mov.d: New.
	* gas/nios2/movia.d: New.
	* gas/nios2/movia.s: New.
	* gas/nios2/movi.d: New.
	* gas/nios2/movi.s: New.
	* gas/nios2/mov.s: New.
	* gas/nios2/mul.d: New.
	* gas/nios2/mul.s: New.
	* gas/nios2/nios2.exp: New.
	* gas/nios2/nor.d: New.
	* gas/nios2/nor.s: New.
	* gas/nios2/or.d: New.
	* gas/nios2/or.s: New.
	* gas/nios2/ret.d: New.
	* gas/nios2/ret.s: New.
	* gas/nios2/rol.d: New.
	* gas/nios2/rol.s: New.
	* gas/nios2/rotate.d: New.
	* gas/nios2/rotate.s: New.
	* gas/nios2/stb.d: New.
	* gas/nios2/stb.s: New.
	* gas/nios2/sth.d: New.
	* gas/nios2/sth.s: New.
	* gas/nios2/stw.d: New.
	* gas/nios2/stw.s: New.
	* gas/nios2/sub.d: New.
	* gas/nios2/sub.s: New.
	* gas/nios2/sync.d: New.
	* gas/nios2/sync.s: New.
	* gas/nios2/trap.d: New.
	* gas/nios2/trap.s: New.
	* gas/nios2/tret.d: New.
	* gas/nios2/tret.s: New.
	* gas/nios2/warn_noat.l: New.
	* gas/nios2/warn_noat.s: New.
	* gas/nios2/warn_nobreak.l: New.
	* gas/nios2/warn_nobreak.s: New.
	* gas/nios2/xor.d: New.
	* gas/nios2/xor.s: New.

	ld/
	* Makefile.am (enios2elf.c): New rule.
	* Makefile.in: Regenerated.
	* configure.tgt: Add case for nios2*-*-*.
	* emulparams/nios2elf.sh: New file.
	* NEWS: Note Altera Nios II support.

	ld/testsuite/
	* ld-nios2/emit-relocs-1a.s: New.
	* ld-nios2/emit-relocs-1b.s: New.
	* ld-nios2/emit-relocs-1.d: New.
	* ld-nios2/emit-relocs-1.ld: New.
	* ld-nios2/gprel.d: New.
	* ld-nios2/gprel.s: New.
	* ld-nios2/hilo16.d: New.
	* ld-nios2/hilo16.s: New.
	* ld-nios2/hilo16_symbol.s: New.
	* ld-nios2/imm5.d: New.
	* ld-nios2/imm5.s: New.
	* ld-nios2/imm5_symbol.s: New.
	* ld-nios2/nios2.exp: New.
	* ld-nios2/pcrel16.d: New.
	* ld-nios2/pcrel16_label.s: New.
	* ld-nios2/pcrel16.s: New.
	* ld-nios2/relax_callr.d: New.
	* ld-nios2/relax_callr.ld: New.
	* ld-nios2/relax_callr.s: New.
	* ld-nios2/relax_cjmp.d: New.
	* ld-nios2/relax_cjmp.s: New.
	* ld-nios2/relax_jmp.ld: New.
	* ld-nios2/relax_section.d: New.
	* ld-nios2/relax_section.s: New.
	* ld-nios2/relax_ujmp.d: New.
	* ld-nios2/relax_ujmp.s: New.
	* ld-nios2/reloc.d: New.
	* ld-nios2/reloc.s: New.
	* ld-nios2/reloc_symbol.s: New.
	* ld-nios2/s16.d: New.
	* ld-nios2/s16.s: New.
	* ld-nios2/s16_symbol.s: New.
	* ld-nios2/u16.d: New.
	* ld-nios2/u16.s: New.
	* ld-nios2/u16_symbol.s: New.
	* ld-elf/indirect.exp: Skip on targets that don't support
	-shared -fPIC.
	* ld-elfcomm/elfcomm.exp: Build with -G0 for nios2.
	* ld-plugin/lto.exp: Skip shared library tests on targets that
	don't support them.  Skip execution tests on non-native targets.

	binutils/
	* readelf.c: Include elf/nios2.h.
	(dump_relocations): Add case for EM_ALTERA_NIOS2.
	(get_nios2_dynamic_type): New.
	(get_dynamic_type): Add case for EM_ALTERA_NIOS2.
	(is_32bit_abs_reloc): Fix EM_ALTERA_NIOS2 case.
	(is_16bit_abs_reloc): Likewise.
	(is_none_reloc): Add EM_ALTERA_NIOS2 and EM_NIOS32 cases.
	* NEWS: Note Altera Nios II support.
	* MAINTAINERS: Add Nios II maintainers.
@
text
@/* ELF object file format
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 3,
   or (at your option) any later version.

   GAS is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#define OBJ_HEADER "obj-elf.h"
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "obstack.h"
#include "struc-symbol.h"
#include "dwarf2dbg.h"

#ifndef ECOFF_DEBUGGING
#define ECOFF_DEBUGGING 0
#else
#define NEED_ECOFF_DEBUG
#endif

#ifdef NEED_ECOFF_DEBUG
#include "ecoff.h"
#endif

#ifdef TC_ALPHA
#include "elf/alpha.h"
#endif

#ifdef TC_MIPS
#include "elf/mips.h"
#endif

#ifdef TC_PPC
#include "elf/ppc.h"
#endif

#ifdef TC_I370
#include "elf/i370.h"
#endif

#ifdef TC_I386
#include "elf/x86-64.h"
#endif

#ifdef TC_MEP
#include "elf/mep.h"
#endif

#ifdef TC_NIOS2
#include "elf/nios2.h"
#endif

static void obj_elf_line (int);
static void obj_elf_size (int);
static void obj_elf_type (int);
static void obj_elf_ident (int);
static void obj_elf_weak (int);
static void obj_elf_local (int);
static void obj_elf_visibility (int);
static void obj_elf_symver (int);
static void obj_elf_subsection (int);
static void obj_elf_popsection (int);
static void obj_elf_gnu_attribute (int);
static void obj_elf_tls_common (int);
static void obj_elf_lcomm (int);
static void obj_elf_struct (int);

static const pseudo_typeS elf_pseudo_table[] =
{
  {"comm", obj_elf_common, 0},
  {"common", obj_elf_common, 1},
  {"ident", obj_elf_ident, 0},
  {"lcomm", obj_elf_lcomm, 0},
  {"local", obj_elf_local, 0},
  {"previous", obj_elf_previous, 0},
  {"section", obj_elf_section, 0},
  {"section.s", obj_elf_section, 0},
  {"sect", obj_elf_section, 0},
  {"sect.s", obj_elf_section, 0},
  {"pushsection", obj_elf_section, 1},
  {"popsection", obj_elf_popsection, 0},
  {"size", obj_elf_size, 0},
  {"type", obj_elf_type, 0},
  {"version", obj_elf_version, 0},
  {"weak", obj_elf_weak, 0},

  /* These define symbol visibility.  */
  {"internal", obj_elf_visibility, STV_INTERNAL},
  {"hidden", obj_elf_visibility, STV_HIDDEN},
  {"protected", obj_elf_visibility, STV_PROTECTED},

  /* These are used for stabs-in-elf configurations.  */
  {"line", obj_elf_line, 0},

  /* This is a GNU extension to handle symbol versions.  */
  {"symver", obj_elf_symver, 0},

  /* A GNU extension to change subsection only.  */
  {"subsection", obj_elf_subsection, 0},

  /* These are GNU extensions to aid in garbage collecting C++ vtables.  */
  {"vtable_inherit", (void (*) (int)) &obj_elf_vtable_inherit, 0},
  {"vtable_entry", (void (*) (int)) &obj_elf_vtable_entry, 0},

  /* A GNU extension for object attributes.  */
  {"gnu_attribute", obj_elf_gnu_attribute, 0},

  /* These are used for dwarf.  */
  {"2byte", cons, 2},
  {"4byte", cons, 4},
  {"8byte", cons, 8},
  /* These are used for dwarf2.  */
  { "file", (void (*) (int)) dwarf2_directive_file, 0 },
  { "loc",  dwarf2_directive_loc,  0 },
  { "loc_mark_labels", dwarf2_directive_loc_mark_labels, 0 },

  /* We need to trap the section changing calls to handle .previous.  */
  {"data", obj_elf_data, 0},
  {"offset", obj_elf_struct, 0},
  {"struct", obj_elf_struct, 0},
  {"text", obj_elf_text, 0},

  {"tls_common", obj_elf_tls_common, 0},

  /* End sentinel.  */
  {NULL, NULL, 0},
};

static const pseudo_typeS ecoff_debug_pseudo_table[] =
{
#ifdef NEED_ECOFF_DEBUG
  /* COFF style debugging information for ECOFF. .ln is not used; .loc
     is used instead.  */
  { "def",	ecoff_directive_def,	0 },
  { "dim",	ecoff_directive_dim,	0 },
  { "endef",	ecoff_directive_endef,	0 },
  { "file",	ecoff_directive_file,	0 },
  { "scl",	ecoff_directive_scl,	0 },
  { "tag",	ecoff_directive_tag,	0 },
  { "val",	ecoff_directive_val,	0 },

  /* COFF debugging requires pseudo-ops .size and .type, but ELF
     already has meanings for those.  We use .esize and .etype
     instead.  These are only generated by gcc anyhow.  */
  { "esize",	ecoff_directive_size,	0 },
  { "etype",	ecoff_directive_type,	0 },

  /* ECOFF specific debugging information.  */
  { "begin",	ecoff_directive_begin,	0 },
  { "bend",	ecoff_directive_bend,	0 },
  { "end",	ecoff_directive_end,	0 },
  { "ent",	ecoff_directive_ent,	0 },
  { "fmask",	ecoff_directive_fmask,	0 },
  { "frame",	ecoff_directive_frame,	0 },
  { "loc",	ecoff_directive_loc,	0 },
  { "mask",	ecoff_directive_mask,	0 },

  /* Other ECOFF directives.  */
  { "extern",	ecoff_directive_extern,	0 },

  /* These are used on Irix.  I don't know how to implement them.  */
  { "alias",	s_ignore,		0 },
  { "bgnb",	s_ignore,		0 },
  { "endb",	s_ignore,		0 },
  { "lab",	s_ignore,		0 },
  { "noalias",	s_ignore,		0 },
  { "verstamp",	s_ignore,		0 },
  { "vreg",	s_ignore,		0 },
#endif

  {NULL, NULL, 0}			/* end sentinel */
};

#undef NO_RELOC
#include "aout/aout64.h"

/* This is called when the assembler starts.  */

asection *elf_com_section_ptr;

void
elf_begin (void)
{
  asection *s;

  /* Add symbols for the known sections to the symbol table.  */
  s = bfd_get_section_by_name (stdoutput, TEXT_SECTION_NAME);
  symbol_table_insert (section_symbol (s));
  s = bfd_get_section_by_name (stdoutput, DATA_SECTION_NAME);
  symbol_table_insert (section_symbol (s));
  s = bfd_get_section_by_name (stdoutput, BSS_SECTION_NAME);
  symbol_table_insert (section_symbol (s));
  elf_com_section_ptr = bfd_com_section_ptr;
}

void
elf_pop_insert (void)
{
  pop_insert (elf_pseudo_table);
  if (ECOFF_DEBUGGING)
    pop_insert (ecoff_debug_pseudo_table);
}

static bfd_vma
elf_s_get_size (symbolS *sym)
{
  return S_GET_SIZE (sym);
}

static void
elf_s_set_size (symbolS *sym, bfd_vma sz)
{
  S_SET_SIZE (sym, sz);
}

static bfd_vma
elf_s_get_align (symbolS *sym)
{
  return S_GET_ALIGN (sym);
}

static void
elf_s_set_align (symbolS *sym, bfd_vma align)
{
  S_SET_ALIGN (sym, align);
}

int
elf_s_get_other (symbolS *sym)
{
  return elf_symbol (symbol_get_bfdsym (sym))->internal_elf_sym.st_other;
}

static void
elf_s_set_other (symbolS *sym, int other)
{
  S_SET_OTHER (sym, other);
}

static int
elf_sec_sym_ok_for_reloc (asection *sec)
{
  return obj_sec_sym_ok_for_reloc (sec);
}

void
elf_file_symbol (const char *s, int appfile)
{
  if (!appfile
      || symbol_rootP == NULL
      || symbol_rootP->bsym == NULL
      || (symbol_rootP->bsym->flags & BSF_FILE) == 0)
    {
      symbolS *sym;
      unsigned int name_length;

      sym = symbol_new (s, absolute_section, 0, NULL);
      symbol_set_frag (sym, &zero_address_frag);

      name_length = strlen (s);
      if (name_length > strlen (S_GET_NAME (sym)))
	{
	  obstack_grow (&notes, s, name_length + 1);
	  S_SET_NAME (sym, (const char *) obstack_finish (&notes));
	}
      else
	strcpy ((char *) S_GET_NAME (sym), s);

      symbol_get_bfdsym (sym)->flags |= BSF_FILE;

      if (symbol_rootP != sym)
	{
	  symbol_remove (sym, &symbol_rootP, &symbol_lastP);
	  symbol_insert (sym, symbol_rootP, &symbol_rootP, &symbol_lastP);
#ifdef DEBUG
	  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif
	}
    }

#ifdef NEED_ECOFF_DEBUG
  ecoff_new_file (s, appfile);
#endif
}

/* Called from read.c:s_comm after we've parsed .comm symbol, size.
   Parse a possible alignment value.  */

symbolS *
elf_common_parse (int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT size)
{
  addressT align = 0;
  int is_local = symbol_get_obj (symbolP)->local;

  if (*input_line_pointer == ',')
    {
      char *save = input_line_pointer;

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '"')
	{
	  /* For sparc.  Accept .common symbol, length, "bss"  */
	  input_line_pointer++;
	  /* Some use the dot, some don't.  */
	  if (*input_line_pointer == '.')
	    input_line_pointer++;
	  /* Some say data, some say bss.  */
	  if (strncmp (input_line_pointer, "bss\"", 4) == 0)
	    input_line_pointer += 4;
	  else if (strncmp (input_line_pointer, "data\"", 5) == 0)
	    input_line_pointer += 5;
	  else
	    {
	      char *p = input_line_pointer;
	      char c;

	      while (*--p != '"')
		;
	      while (!is_end_of_line[(unsigned char) *input_line_pointer])
		if (*input_line_pointer++ == '"')
		  break;
	      c = *input_line_pointer;
	      *input_line_pointer = '\0';
	      as_bad (_("bad .common segment %s"), p);
	      *input_line_pointer = c;
	      ignore_rest_of_line ();
	      return NULL;
	    }
	  /* ??? Don't ask me why these are always global.  */
	  is_local = 0;
	}
      else
	{
	  input_line_pointer = save;
	  align = parse_align (is_local);
	  if (align == (addressT) -1)
	    return NULL;
	}
    }

  if (is_local)
    {
      bss_alloc (symbolP, size, align);
      S_CLEAR_EXTERNAL (symbolP);
    }
  else
    {
      S_SET_VALUE (symbolP, size);
      S_SET_ALIGN (symbolP, align);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, elf_com_section_ptr);
    }

  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  return symbolP;
}

void
obj_elf_common (int is_common)
{
  if (flag_mri && is_common)
    s_mri_common (0);
  else
    s_comm_internal (0, elf_common_parse);
}

static void
obj_elf_tls_common (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = s_comm_internal (0, elf_common_parse);

  if (symbolP)
    symbol_get_bfdsym (symbolP)->flags |= BSF_THREAD_LOCAL;
}

static void
obj_elf_lcomm (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = s_comm_internal (0, s_lcomm_internal);

  if (symbolP)
    symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
}

static symbolS *
get_sym_from_input_line_and_check (void)
{
  char *name;
  char c;
  symbolS *sym;

  name = input_line_pointer;
  c = get_symbol_end ();
  sym = symbol_find_or_make (name);
  *input_line_pointer = c;
  SKIP_WHITESPACE ();

  /* There is no symbol name if input_line_pointer has not moved.  */
  if (name == input_line_pointer)
    as_bad (_("Missing symbol name in directive"));
  return sym;
}

static void
obj_elf_local (int ignore ATTRIBUTE_UNUSED)
{
  int c;
  symbolS *symbolP;

  do
    {
      symbolP = get_sym_from_input_line_and_check ();
      c = *input_line_pointer;
      S_CLEAR_EXTERNAL (symbolP);
      symbol_get_obj (symbolP)->local = 1;
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');
  demand_empty_rest_of_line ();
}

static void
obj_elf_weak (int ignore ATTRIBUTE_UNUSED)
{
  int c;
  symbolS *symbolP;

  do
    {
      symbolP = get_sym_from_input_line_and_check ();
      c = *input_line_pointer;
      S_SET_WEAK (symbolP);
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');
  demand_empty_rest_of_line ();
}

static void
obj_elf_visibility (int visibility)
{
  int c;
  symbolS *symbolP;
  asymbol *bfdsym;
  elf_symbol_type *elfsym;

  do
    {
      symbolP = get_sym_from_input_line_and_check ();

      bfdsym = symbol_get_bfdsym (symbolP);
      elfsym = elf_symbol_from (bfd_asymbol_bfd (bfdsym), bfdsym);

      gas_assert (elfsym);

      elfsym->internal_elf_sym.st_other &= ~3;
      elfsym->internal_elf_sym.st_other |= visibility;

      c = *input_line_pointer;
      if (c == ',')
	{
	  input_line_pointer ++;

	  SKIP_WHITESPACE ();

	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

static segT previous_section;
static int previous_subsection;

struct section_stack
{
  struct section_stack *next;
  segT seg, prev_seg;
  int subseg, prev_subseg;
};

static struct section_stack *section_stack;

static bfd_boolean
get_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
{
  const char *gname = (const char *) inf;
  const char *group_name = elf_group_name (sec);

  return (group_name == gname
	  || (group_name != NULL
	      && gname != NULL
	      && strcmp (group_name, gname) == 0));
}

/* Handle the .section pseudo-op.  This code supports two different
   syntaxes.

   The first is found on Solaris, and looks like
       .section ".sec1",#alloc,#execinstr,#write
   Here the names after '#' are the SHF_* flags to turn on for the
   section.  I'm not sure how it determines the SHT_* type (BFD
   doesn't really give us control over the type, anyhow).

   The second format is found on UnixWare, and probably most SVR4
   machines, and looks like
       .section .sec1,"a",@@progbits
   The quoted string may contain any combination of a, w, x, and
   represents the SHF_* flags to turn on for the section.  The string
   beginning with '@@' can be progbits or nobits.  There should be
   other possibilities, but I don't know what they are.  In any case,
   BFD doesn't really let us set the section type.  */

void
obj_elf_change_section (const char *name,
			int type,
			bfd_vma attr,
			int entsize,
			const char *group_name,
			int linkonce,
			int push)
{
  asection *old_sec;
  segT sec;
  flagword flags;
  const struct elf_backend_data *bed;
  const struct bfd_elf_special_section *ssect;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  /* Switch to the section, creating it if necessary.  */
  if (push)
    {
      struct section_stack *elt;
      elt = (struct section_stack *) xmalloc (sizeof (struct section_stack));
      elt->next = section_stack;
      elt->seg = now_seg;
      elt->prev_seg = previous_section;
      elt->subseg = now_subseg;
      elt->prev_subseg = previous_subsection;
      section_stack = elt;
    }
  previous_section = now_seg;
  previous_subsection = now_subseg;

  old_sec = bfd_get_section_by_name_if (stdoutput, name, get_section,
					(void *) group_name);
  if (old_sec)
    {
      sec = old_sec;
      subseg_set (sec, 0);
    }
  else
    sec = subseg_force_new (name, 0);

  bed = get_elf_backend_data (stdoutput);
  ssect = (*bed->get_sec_type_attr) (stdoutput, sec);

  if (ssect != NULL)
    {
      bfd_boolean override = FALSE;

      if (type == SHT_NULL)
	type = ssect->type;
      else if (type != ssect->type)
	{
	  if (old_sec == NULL
	      /* Some older versions of gcc will emit

		 .section .init_array,"aw",@@progbits

		 for __attribute__ ((section (".init_array"))).
		 "@@progbits" is incorrect.  Also for x86-64 large bss
		 sections, some older versions of gcc will emit

		 .section .lbss,"aw",@@progbits

		 "@@progbits" is incorrect.  */
#ifdef TC_I386
	      && (bed->s->arch_size != 64
		  || !(ssect->attr & SHF_X86_64_LARGE))
#endif
	      && ssect->type != SHT_INIT_ARRAY
	      && ssect->type != SHT_FINI_ARRAY
	      && ssect->type != SHT_PREINIT_ARRAY)
	    {
	      /* We allow to specify any type for a .note section.  */
	      if (ssect->type != SHT_NOTE)
		as_warn (_("setting incorrect section type for %s"),
			 name);
	    }
	  else
	    {
	      as_warn (_("ignoring incorrect section type for %s"),
		       name);
	      type = ssect->type;
	    }
	}

      if (old_sec == NULL && (attr & ~ssect->attr) != 0)
	{
	  /* As a GNU extension, we permit a .note section to be
	     allocatable.  If the linker sees an allocatable .note
	     section, it will create a PT_NOTE segment in the output
	     file.  We also allow "x" for .note.GNU-stack.  */
	  if (ssect->type == SHT_NOTE
	      && (attr == SHF_ALLOC || attr == SHF_EXECINSTR))
	    ;
	  /* Allow different SHF_MERGE and SHF_STRINGS if we have
	     something like .rodata.str.  */
	  else if (ssect->suffix_length == -2
		   && name[ssect->prefix_length] == '.'
		   && (attr
		       & ~ssect->attr
		       & ~SHF_MERGE
		       & ~SHF_STRINGS) == 0)
	    ;
	  /* .interp, .strtab and .symtab can have SHF_ALLOC.  */
	  else if (attr == SHF_ALLOC
		   && (strcmp (name, ".interp") == 0
		       || strcmp (name, ".strtab") == 0
		       || strcmp (name, ".symtab") == 0))
	    override = TRUE;
	  /* .note.GNU-stack can have SHF_EXECINSTR.  */
	  else if (attr == SHF_EXECINSTR
		   && strcmp (name, ".note.GNU-stack") == 0)
	    override = TRUE;
#ifdef TC_ALPHA
	  /* A section on Alpha may have SHF_ALPHA_GPREL.  */
	  else if ((attr & ~ssect->attr) == SHF_ALPHA_GPREL)
	    override = TRUE;
#endif
#ifdef TC_RX
	  else if (attr == (SHF_EXECINSTR | SHF_WRITE | SHF_ALLOC)
		   && (ssect->type == SHT_INIT_ARRAY
		       || ssect->type == SHT_FINI_ARRAY
		       || ssect->type == SHT_PREINIT_ARRAY))
	    /* RX init/fini arrays can and should have the "awx" attributes set.  */
	    ;
#endif
	  else
	    {
	      if (group_name == NULL)
		as_warn (_("setting incorrect section attributes for %s"),
			 name);
	      override = TRUE;
	    }
	}
      if (!override && old_sec == NULL)
	attr |= ssect->attr;
    }

  /* Convert ELF type and flags to BFD flags.  */
  flags = (SEC_RELOC
	   | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
	   | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	   | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
	   | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0)
	   | ((attr & SHF_MERGE) ? SEC_MERGE : 0)
	   | ((attr & SHF_STRINGS) ? SEC_STRINGS : 0)
	   | ((attr & SHF_EXCLUDE) ? SEC_EXCLUDE: 0)
	   | ((attr & SHF_TLS) ? SEC_THREAD_LOCAL : 0));
#ifdef md_elf_section_flags
  flags = md_elf_section_flags (flags, attr, type);
#endif

  if (linkonce)
    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

  if (old_sec == NULL)
    {
      symbolS *secsym;

      if (type == SHT_NULL)
	type = bfd_elf_get_default_section_type (flags);
      elf_section_type (sec) = type;
      elf_section_flags (sec) = attr;

      /* Prevent SEC_HAS_CONTENTS from being inadvertently set.  */
      if (type == SHT_NOBITS)
	seg_info (sec)->bss = 1;

      bfd_set_section_flags (stdoutput, sec, flags);
      if (flags & SEC_MERGE)
	sec->entsize = entsize;
      elf_group_name (sec) = group_name;

      /* Add a symbol for this section to the symbol table.  */
      secsym = symbol_find (name);
      if (secsym != NULL)
	symbol_set_bfdsym (secsym, sec->symbol);
      else
	symbol_table_insert (section_symbol (sec));
    }
  else
    {
      if (type != SHT_NULL
	  && (unsigned) type != elf_section_type (old_sec))
	as_warn (_("ignoring changed section type for %s"), name);

      if (attr != 0)
	{
	  /* If section attributes are specified the second time we see a
	     particular section, then check that they are the same as we
	     saw the first time.  */
	  if (((old_sec->flags ^ flags)
	       & (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
		  | SEC_EXCLUDE | SEC_SORT_ENTRIES | SEC_MERGE | SEC_STRINGS
		  | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
		  | SEC_THREAD_LOCAL)))
	    as_warn (_("ignoring changed section attributes for %s"), name);
	  if ((flags & SEC_MERGE) && old_sec->entsize != (unsigned) entsize)
	    as_warn (_("ignoring changed section entity size for %s"), name);
	}
    }

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static bfd_vma
obj_elf_parse_section_letters (char *str, size_t len, bfd_boolean *is_clone)
{
  bfd_vma attr = 0;
  *is_clone = FALSE;

  while (len > 0)
    {
      switch (*str)
	{
	case 'a':
	  attr |= SHF_ALLOC;
	  break;
	case 'e':
	  attr |= SHF_EXCLUDE;
	  break;
	case 'w':
	  attr |= SHF_WRITE;
	  break;
	case 'x':
	  attr |= SHF_EXECINSTR;
	  break;
	case 'M':
	  attr |= SHF_MERGE;
	  break;
	case 'S':
	  attr |= SHF_STRINGS;
	  break;
	case 'G':
	  attr |= SHF_GROUP;
	  break;
	case 'T':
	  attr |= SHF_TLS;
	  break;
	case '?':
	  *is_clone = TRUE;
	  break;
	/* Compatibility.  */
	case 'm':
	  if (*(str - 1) == 'a')
	    {
	      attr |= SHF_MERGE;
	      if (len > 1 && str[1] == 's')
		{
		  attr |= SHF_STRINGS;
		  str++, len--;
		}
	      break;
	    }
	default:
	  {
	    char *bad_msg = _("unrecognized .section attribute: want a,e,w,x,M,S,G,T");
#ifdef md_elf_section_letter
	    bfd_vma md_attr = md_elf_section_letter (*str, &bad_msg);
	    if (md_attr != (bfd_vma) -1)
	      attr |= md_attr;
	    else
#endif
	      as_fatal ("%s", bad_msg);
	  }
	  break;
	}
      str++, len--;
    }

  return attr;
}

static int
obj_elf_section_type (char *str, size_t len, bfd_boolean warn)
{
  if (len == 8 && strncmp (str, "progbits", 8) == 0)
    return SHT_PROGBITS;
  if (len == 6 && strncmp (str, "nobits", 6) == 0)
    return SHT_NOBITS;
  if (len == 4 && strncmp (str, "note", 4) == 0)
    return SHT_NOTE;
  if (len == 10 && strncmp (str, "init_array", 10) == 0)
    return SHT_INIT_ARRAY;
  if (len == 10 && strncmp (str, "fini_array", 10) == 0)
    return SHT_FINI_ARRAY;
  if (len == 13 && strncmp (str, "preinit_array", 13) == 0)
    return SHT_PREINIT_ARRAY;

#ifdef md_elf_section_type
  {
    int md_type = md_elf_section_type (str, len);
    if (md_type >= 0)
      return md_type;
  }
#endif

  if (warn)
    as_warn (_("unrecognized section type"));
  return 0;
}

static bfd_vma
obj_elf_section_word (char *str, size_t len, int *type)
{
  int ret;

  if (len == 5 && strncmp (str, "write", 5) == 0)
    return SHF_WRITE;
  if (len == 5 && strncmp (str, "alloc", 5) == 0)
    return SHF_ALLOC;
  if (len == 9 && strncmp (str, "execinstr", 9) == 0)
    return SHF_EXECINSTR;
  if (len == 7 && strncmp (str, "exclude", 7) == 0)
    return SHF_EXCLUDE;
  if (len == 3 && strncmp (str, "tls", 3) == 0)
    return SHF_TLS;

#ifdef md_elf_section_word
  {
    bfd_vma md_attr = md_elf_section_word (str, len);
    if (md_attr > 0)
      return md_attr;
  }
#endif

  ret = obj_elf_section_type (str, len, FALSE);
  if (ret != 0)
    *type = ret;
  else
    as_warn (_("unrecognized section attribute"));

  return 0;
}

/* Get name of section.  */
char *
obj_elf_section_name (void)
{
  char *name;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      int dummy;

      name = demand_copy_C_string (&dummy);
      if (name == NULL)
	{
	  ignore_rest_of_line ();
	  return NULL;
	}
    }
  else
    {
      char *end = input_line_pointer;

      while (0 == strchr ("\n\t,; ", *end))
	end++;
      if (end == input_line_pointer)
	{
	  as_bad (_("missing name"));
	  ignore_rest_of_line ();
	  return NULL;
	}

      name = (char *) xmalloc (end - input_line_pointer + 1);
      memcpy (name, input_line_pointer, end - input_line_pointer);
      name[end - input_line_pointer] = '\0';
#ifdef tc_canonicalize_section_name
      name = tc_canonicalize_section_name (name);
#endif
      input_line_pointer = end;
    }
  SKIP_WHITESPACE ();
  return name;
}

void
obj_elf_section (int push)
{
  char *name, *group_name, *beg;
  int type, dummy;
  bfd_vma attr;
  int entsize;
  int linkonce;
  subsegT new_subsection = -1;

#ifndef TC_I370
  if (flag_mri)
    {
      char mri_type;

#ifdef md_flush_pending_output
      md_flush_pending_output ();
#endif

      previous_section = now_seg;
      previous_subsection = now_subseg;

      s_mri_sect (&mri_type);

#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif

      return;
    }
#endif /* ! defined (TC_I370) */

  name = obj_elf_section_name ();
  if (name == NULL)
    return;
  type = SHT_NULL;
  attr = 0;
  group_name = NULL;
  entsize = 0;
  linkonce = 0;

  if (*input_line_pointer == ',')
    {
      /* Skip the comma.  */
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (push && ISDIGIT (*input_line_pointer))
	{
	  /* .pushsection has an optional subsection.  */
	  new_subsection = (subsegT) get_absolute_expression ();

	  SKIP_WHITESPACE ();

	  /* Stop if we don't see a comma.  */
	  if (*input_line_pointer != ',')
	    goto done;

	  /* Skip the comma.  */
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	}

      if (*input_line_pointer == '"')
	{
	  bfd_boolean is_clone;

	  beg = demand_copy_C_string (&dummy);
	  if (beg == NULL)
	    {
	      ignore_rest_of_line ();
	      return;
	    }
	  attr |= obj_elf_parse_section_letters (beg, strlen (beg), &is_clone);

	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      char c;
	      char *save = input_line_pointer;

	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      c = *input_line_pointer;
	      if (c == '"')
		{
		  beg = demand_copy_C_string (&dummy);
		  if (beg == NULL)
		    {
		      ignore_rest_of_line ();
		      return;
		    }
		  type = obj_elf_section_type (beg, strlen (beg), TRUE);
		}
	      else if (c == '@@' || c == '%')
		{
		  beg = ++input_line_pointer;
		  c = get_symbol_end ();
		  *input_line_pointer = c;
		  type = obj_elf_section_type (beg, input_line_pointer - beg, TRUE);
		}
	      else
		input_line_pointer = save;
	    }

	  SKIP_WHITESPACE ();
	  if ((attr & SHF_MERGE) != 0 && *input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      entsize = get_absolute_expression ();
	      SKIP_WHITESPACE ();
	      if (entsize < 0)
		{
		  as_warn (_("invalid merge entity size"));
		  attr &= ~SHF_MERGE;
		  entsize = 0;
		}
	    }
	  else if ((attr & SHF_MERGE) != 0)
	    {
	      as_warn (_("entity size for SHF_MERGE not specified"));
	      attr &= ~SHF_MERGE;
	    }

	  if ((attr & SHF_GROUP) != 0 && is_clone)
	    {
	      as_warn (_("? section flag ignored with G present"));
	      is_clone = FALSE;
	    }
	  if ((attr & SHF_GROUP) != 0 && *input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      group_name = obj_elf_section_name ();
	      if (group_name == NULL)
		attr &= ~SHF_GROUP;
	      else if (*input_line_pointer == ',')
		{
		  ++input_line_pointer;
		  SKIP_WHITESPACE ();
		  if (strncmp (input_line_pointer, "comdat", 6) == 0)
		    {
		      input_line_pointer += 6;
		      linkonce = 1;
		    }
		}
	      else if (strncmp (name, ".gnu.linkonce", 13) == 0)
		linkonce = 1;
	    }
	  else if ((attr & SHF_GROUP) != 0)
	    {
	      as_warn (_("group name for SHF_GROUP not specified"));
	      attr &= ~SHF_GROUP;
	    }

	  if (is_clone)
	    {
	      const char *now_group = elf_group_name (now_seg);
	      if (now_group != NULL)
		{
		  group_name = xstrdup (now_group);
		  linkonce = (now_seg->flags & SEC_LINK_ONCE) != 0;
		}
	    }
	}
      else
	{
	  do
	    {
	      char c;

	      SKIP_WHITESPACE ();
	      if (*input_line_pointer != '#')
		{
		  as_bad (_("character following name is not '#'"));
		  ignore_rest_of_line ();
		  return;
		}
	      beg = ++input_line_pointer;
	      c = get_symbol_end ();
	      *input_line_pointer = c;

	      attr |= obj_elf_section_word (beg, input_line_pointer - beg, & type);

	      SKIP_WHITESPACE ();
	    }
	  while (*input_line_pointer++ == ',');
	  --input_line_pointer;
	}
    }

done:
  demand_empty_rest_of_line ();

  obj_elf_change_section (name, type, attr, entsize, group_name, linkonce, push);

  if (push && new_subsection != -1)
    subseg_set (now_seg, new_subsection);
}

/* Change to the .data section.  */

void
obj_elf_data (int i)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  previous_section = now_seg;
  previous_subsection = now_subseg;
  s_data (i);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* Change to the .text section.  */

void
obj_elf_text (int i)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  previous_section = now_seg;
  previous_subsection = now_subseg;
  s_text (i);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* Change to the *ABS* section.  */

void
obj_elf_struct (int i)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  previous_section = now_seg;
  previous_subsection = now_subseg;
  s_struct (i);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_subsection (int ignore ATTRIBUTE_UNUSED)
{
  int temp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  previous_section = now_seg;
  previous_subsection = now_subseg;

  temp = get_absolute_expression ();
  subseg_set (now_seg, (subsegT) temp);
  demand_empty_rest_of_line ();

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* This can be called from the processor backends if they change
   sections.  */

void
obj_elf_section_change_hook (void)
{
  previous_section = now_seg;
  previous_subsection = now_subseg;
}

void
obj_elf_previous (int ignore ATTRIBUTE_UNUSED)
{
  segT new_section;
  int new_subsection;

  if (previous_section == 0)
    {
      as_warn (_(".previous without corresponding .section; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  new_section = previous_section;
  new_subsection = previous_subsection;
  previous_section = now_seg;
  previous_subsection = now_subseg;
  subseg_set (new_section, new_subsection);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_popsection (int xxx ATTRIBUTE_UNUSED)
{
  struct section_stack *top = section_stack;

  if (top == NULL)
    {
      as_warn (_(".popsection without corresponding .pushsection; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  section_stack = top->next;
  previous_section = top->prev_seg;
  previous_subsection = top->prev_subseg;
  subseg_set (top->seg, top->subseg);
  free (top);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_line (int ignore ATTRIBUTE_UNUSED)
{
  /* Assume delimiter is part of expression.  BSD4.2 as fails with
     delightful bug, so we are not being incompatible here.  */
  new_logical_line (NULL, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

/* This handles the .symver pseudo-op, which is used to specify a
   symbol version.  The syntax is ``.symver NAME,SYMVERNAME''.
   SYMVERNAME may contain ELF_VER_CHR ('@@') characters.  This
   pseudo-op causes the assembler to emit a symbol named SYMVERNAME
   with the same value as the symbol NAME.  */

static void
obj_elf_symver (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char old_lexat;
  symbolS *sym;

  sym = get_sym_from_input_line_and_check ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .symver"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();
  name = input_line_pointer;

  /* Temporarily include '@@' in symbol names.  */
  old_lexat = lex_type[(unsigned char) '@@'];
  lex_type[(unsigned char) '@@'] |= LEX_NAME;
  c = get_symbol_end ();
  lex_type[(unsigned char) '@@'] = old_lexat;

  if (symbol_get_obj (sym)->versioned_name == NULL)
    {
      symbol_get_obj (sym)->versioned_name = xstrdup (name);

      *input_line_pointer = c;

      if (strchr (symbol_get_obj (sym)->versioned_name,
		  ELF_VER_CHR) == NULL)
	{
	  as_bad (_("missing version name in `%s' for symbol `%s'"),
		  symbol_get_obj (sym)->versioned_name,
		  S_GET_NAME (sym));
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    {
      if (strcmp (symbol_get_obj (sym)->versioned_name, name))
	{
	  as_bad (_("multiple versions [`%s'|`%s'] for symbol `%s'"),
		  name, symbol_get_obj (sym)->versioned_name,
		  S_GET_NAME (sym));
	  ignore_rest_of_line ();
	  return;
	}

      *input_line_pointer = c;
    }

  demand_empty_rest_of_line ();
}

/* This handles the .vtable_inherit pseudo-op, which is used to indicate
   to the linker the hierarchy in which a particular table resides.  The
   syntax is ".vtable_inherit CHILDNAME, PARENTNAME".  */

struct fix *
obj_elf_vtable_inherit (int ignore ATTRIBUTE_UNUSED)
{
  char *cname, *pname;
  symbolS *csym, *psym;
  char c, bad = 0;

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  cname = input_line_pointer;
  c = get_symbol_end ();
  csym = symbol_find (cname);

  /* GCFIXME: should check that we don't have two .vtable_inherits for
     the same child symbol.  Also, we can currently only do this if the
     child symbol is already exists and is placed in a fragment.  */

  if (csym == NULL || symbol_get_frag (csym) == NULL)
    {
      as_bad (_("expected `%s' to have already been set for .vtable_inherit"),
	      cname);
      bad = 1;
    }

  *input_line_pointer = c;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .vtable_inherit"));
      ignore_rest_of_line ();
      return NULL;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  if (input_line_pointer[0] == '0'
      && (input_line_pointer[1] == '\0'
	  || ISSPACE (input_line_pointer[1])))
    {
      psym = section_symbol (absolute_section);
      ++input_line_pointer;
    }
  else
    {
      pname = input_line_pointer;
      c = get_symbol_end ();
      psym = symbol_find_or_make (pname);
      *input_line_pointer = c;
    }

  demand_empty_rest_of_line ();

  if (bad)
    return NULL;

  gas_assert (symbol_get_value_expression (csym)->X_op == O_constant);
  return fix_new (symbol_get_frag (csym),
		  symbol_get_value_expression (csym)->X_add_number,
		  0, psym, 0, 0, BFD_RELOC_VTABLE_INHERIT);
}

/* This handles the .vtable_entry pseudo-op, which is used to indicate
   to the linker that a vtable slot was used.  The syntax is
   ".vtable_entry tablename, offset".  */

struct fix *
obj_elf_vtable_entry (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym;
  offsetT offset;

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  sym = get_sym_from_input_line_and_check ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .vtable_entry"));
      ignore_rest_of_line ();
      return NULL;
    }

  ++input_line_pointer;
  if (*input_line_pointer == '#')
    ++input_line_pointer;

  offset = get_absolute_expression ();

  demand_empty_rest_of_line ();

  return fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
		  BFD_RELOC_VTABLE_ENTRY);
}

#define skip_whitespace(str)  do { if (*(str) == ' ') ++(str); } while (0)

static inline int
skip_past_char (char ** str, char c)
{
  if (**str == c)
    {
      (*str)++;
      return 0;
    }
  else
    return -1;
}
#define skip_past_comma(str) skip_past_char (str, ',')

/* Parse an attribute directive for VENDOR.
   Returns the attribute number read, or zero on error.  */

int
obj_elf_vendor_attribute (int vendor)
{
  expressionS exp;
  int type;
  int tag;
  unsigned int i = 0;
  char *s = NULL;

  /* Read the first number or name.  */
  skip_whitespace (input_line_pointer);
  s = input_line_pointer;
  if (ISDIGIT (*input_line_pointer))
    {
      expression (& exp);
      if (exp.X_op != O_constant)
	goto bad;
      tag = exp.X_add_number;
    }
  else
    {
      char *name;

      /* A name may contain '_', but no other punctuation.  */
      for (; ISALNUM (*input_line_pointer) || *input_line_pointer == '_';
	   ++input_line_pointer)
	i++;
      if (i == 0)
	goto bad;

      name = (char *) alloca (i + 1);
      memcpy (name, s, i);
      name[i] = '\0';

#ifndef CONVERT_SYMBOLIC_ATTRIBUTE
#define CONVERT_SYMBOLIC_ATTRIBUTE(a) -1
#endif

      tag = CONVERT_SYMBOLIC_ATTRIBUTE (name);
      if (tag == -1)
	{
	  as_bad (_("Attribute name not recognised: %s"), name);
	  ignore_rest_of_line ();
	  return 0;
	}
    }

  type = _bfd_elf_obj_attrs_arg_type (stdoutput, vendor, tag);

  if (skip_past_comma (&input_line_pointer) == -1)
    goto bad;
  if (type & 1)
    {
      expression (& exp);
      if (exp.X_op != O_constant)
	{
	  as_bad (_("expected numeric constant"));
	  ignore_rest_of_line ();
	  return 0;
	}
      i = exp.X_add_number;
    }
  if ((type & 3) == 3
      && skip_past_comma (&input_line_pointer) == -1)
    {
      as_bad (_("expected comma"));
      ignore_rest_of_line ();
      return 0;
    }
  if (type & 2)
    {
      int len;

      skip_whitespace (input_line_pointer);
      if (*input_line_pointer != '"')
	goto bad_string;
      s = demand_copy_C_string (&len);
    }

  switch (type & 3)
    {
    case 3:
      bfd_elf_add_obj_attr_int_string (stdoutput, vendor, tag, i, s);
      break;
    case 2:
      bfd_elf_add_obj_attr_string (stdoutput, vendor, tag, s);
      break;
    case 1:
      bfd_elf_add_obj_attr_int (stdoutput, vendor, tag, i);
      break;
    default:
      abort ();
    }

  demand_empty_rest_of_line ();
  return tag;
bad_string:
  as_bad (_("bad string constant"));
  ignore_rest_of_line ();
  return 0;
bad:
  as_bad (_("expected <tag> , <value>"));
  ignore_rest_of_line ();
  return 0;
}

/* Parse a .gnu_attribute directive.  */

static void
obj_elf_gnu_attribute (int ignored ATTRIBUTE_UNUSED)
{
  obj_elf_vendor_attribute (OBJ_ATTR_GNU);
}

void
elf_obj_read_begin_hook (void)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_read_begin_hook ();
#endif
}

void
elf_obj_symbol_new_hook (symbolS *symbolP)
{
  struct elf_obj_sy *sy_obj;

  sy_obj = symbol_get_obj (symbolP);
  sy_obj->size = NULL;
  sy_obj->versioned_name = NULL;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_symbol_new_hook (symbolP);
#endif
}

/* When setting one symbol equal to another, by default we probably
   want them to have the same "size", whatever it means in the current
   context.  */

void
elf_copy_symbol_attributes (symbolS *dest, symbolS *src)
{
  struct elf_obj_sy *srcelf = symbol_get_obj (src);
  struct elf_obj_sy *destelf = symbol_get_obj (dest);
  if (srcelf->size)
    {
      if (destelf->size == NULL)
	destelf->size = (expressionS *) xmalloc (sizeof (expressionS));
      *destelf->size = *srcelf->size;
    }
  else
    {
      if (destelf->size != NULL)
	free (destelf->size);
      destelf->size = NULL;
    }
  S_SET_SIZE (dest, S_GET_SIZE (src));
  /* Don't copy visibility.  */
  S_SET_OTHER (dest, (ELF_ST_VISIBILITY (S_GET_OTHER (dest))
		      | (S_GET_OTHER (src) & ~ELF_ST_VISIBILITY (-1))));
}

void
obj_elf_version (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  unsigned int c;
  char *p;
  asection *seg = now_seg;
  subsegT subseg = now_subseg;
  Elf_Internal_Note i_note;
  Elf_External_Note e_note;
  asection *note_secp = NULL;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '\"')
    {
      unsigned int len;

      ++input_line_pointer;	/* -> 1st char of string.  */
      name = input_line_pointer;

      while (is_a_char (c = next_char_of_string ()))
	;
      c = *input_line_pointer;
      *input_line_pointer = '\0';
      *(input_line_pointer - 1) = '\0';
      *input_line_pointer = c;

      /* Create the .note section.  */
      note_secp = subseg_new (".note", 0);
      bfd_set_section_flags (stdoutput,
			     note_secp,
			     SEC_HAS_CONTENTS | SEC_READONLY);

      /* Process the version string.  */
      len = strlen (name) + 1;

      /* PR 3456: Although the name field is padded out to an 4-byte
	 boundary, the namesz field should not be adjusted.  */
      i_note.namesz = len;
      i_note.descsz = 0;	/* No description.  */
      i_note.type = NT_VERSION;
      p = frag_more (sizeof (e_note.namesz));
      md_number_to_chars (p, i_note.namesz, sizeof (e_note.namesz));
      p = frag_more (sizeof (e_note.descsz));
      md_number_to_chars (p, i_note.descsz, sizeof (e_note.descsz));
      p = frag_more (sizeof (e_note.type));
      md_number_to_chars (p, i_note.type, sizeof (e_note.type));
      p = frag_more (len);
      memcpy (p, name, len);

      frag_align (2, 0, 0);

      subseg_set (seg, subseg);
    }
  else
    as_bad (_("expected quoted string"));

  demand_empty_rest_of_line ();
}

static void
obj_elf_size (int ignore ATTRIBUTE_UNUSED)
{
  char *name = input_line_pointer;
  char c = get_symbol_end ();
  char *p;
  expressionS exp;
  symbolS *sym;

  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      *p = 0;
      as_bad (_("expected comma after name `%s' in .size directive"), name);
      *p = c;
      ignore_rest_of_line ();
      return;
    }
  input_line_pointer++;
  expression (&exp);
  if (exp.X_op == O_absent)
    {
      as_bad (_("missing expression in .size directive"));
      exp.X_op = O_constant;
      exp.X_add_number = 0;
    }
  *p = 0;
  sym = symbol_find_or_make (name);
  *p = c;
  if (exp.X_op == O_constant)
    {
      S_SET_SIZE (sym, exp.X_add_number);
      if (symbol_get_obj (sym)->size)
	{
	  xfree (symbol_get_obj (sym)->size);
	  symbol_get_obj (sym)->size = NULL;
	}
    }
  else
    {
      symbol_get_obj (sym)->size =
          (expressionS *) xmalloc (sizeof (expressionS));
      *symbol_get_obj (sym)->size = exp;
    }
  demand_empty_rest_of_line ();
}

/* Handle the ELF .type pseudo-op.  This sets the type of a symbol.
   There are six syntaxes:

   The first (used on Solaris) is
       .type SYM,#function
   The second (used on UnixWare) is
       .type SYM,@@function
   The third (reportedly to be used on Irix 6.0) is
       .type SYM STT_FUNC
   The fourth (used on NetBSD/Arm and Linux/ARM) is
       .type SYM,%function
   The fifth (used on SVR4/860) is
       .type SYM,"function"
   The sixth (emitted by recent SunPRO under Solaris) is
       .type SYM,[0-9]
   where the integer is the STT_* value.
   */

static char *
obj_elf_type_name (char *cp)
{
  char *p;

  p = input_line_pointer;
  if (*input_line_pointer >= '0'
      && *input_line_pointer <= '9')
    {
      while (*input_line_pointer >= '0'
	     && *input_line_pointer <= '9')
	++input_line_pointer;
      *cp = *input_line_pointer;
      *input_line_pointer = '\0';
    }
  else
    *cp = get_symbol_end ();

  return p;
}

static void
obj_elf_type (int ignore ATTRIBUTE_UNUSED)
{
  char c;
  int type;
  const char *type_name;
  symbolS *sym;
  elf_symbol_type *elfsym;

  sym = get_sym_from_input_line_and_check ();
  c = *input_line_pointer;
  elfsym = (elf_symbol_type *) symbol_get_bfdsym (sym);

  if (*input_line_pointer == ',')
    ++input_line_pointer;

  SKIP_WHITESPACE ();
  if (   *input_line_pointer == '#'
      || *input_line_pointer == '@@'
      || *input_line_pointer == '"'
      || *input_line_pointer == '%')
    ++input_line_pointer;

  type_name = obj_elf_type_name (& c);

  type = 0;
  if (strcmp (type_name, "function") == 0
      || strcmp (type_name, "2") == 0
      || strcmp (type_name, "STT_FUNC") == 0)
    type = BSF_FUNCTION;
  else if (strcmp (type_name, "object") == 0
	   || strcmp (type_name, "1") == 0
	   || strcmp (type_name, "STT_OBJECT") == 0)
    type = BSF_OBJECT;
  else if (strcmp (type_name, "tls_object") == 0
	   || strcmp (type_name, "6") == 0
	   || strcmp (type_name, "STT_TLS") == 0)
    type = BSF_OBJECT | BSF_THREAD_LOCAL;
  else if (strcmp (type_name, "notype") == 0
	   || strcmp (type_name, "0") == 0
	   || strcmp (type_name, "STT_NOTYPE") == 0)
    ;
  else if (strcmp (type_name, "common") == 0
	   || strcmp (type_name, "5") == 0
	   || strcmp (type_name, "STT_COMMON") == 0)
    {
      type = BSF_OBJECT;

      if (! S_IS_COMMON (sym))
	{
	  if (S_IS_VOLATILE (sym))
	    {
	      sym = symbol_clone (sym, 1);
	      S_SET_SEGMENT (sym, bfd_com_section_ptr);
	      S_SET_VALUE (sym, 0);
	      S_SET_EXTERNAL (sym);
	      symbol_set_frag (sym, &zero_address_frag);
	      S_CLEAR_VOLATILE (sym);
	    }
	  else if (S_IS_DEFINED (sym) || symbol_equated_p (sym))
	    as_bad (_("symbol '%s' is already defined"), S_GET_NAME (sym));
	  else
	    {
	      /* FIXME: Is it safe to just change the section ?  */
	      S_SET_SEGMENT (sym, bfd_com_section_ptr);
	      S_SET_VALUE (sym, 0);
	      S_SET_EXTERNAL (sym);
	    }
	}
    }
  else if (strcmp (type_name, "gnu_indirect_function") == 0
	   || strcmp (type_name, "10") == 0
	   || strcmp (type_name, "STT_GNU_IFUNC") == 0)
    {
      const struct elf_backend_data *bed;

      bed = get_elf_backend_data (stdoutput);
      if (!(bed->elf_osabi == ELFOSABI_GNU
	    || bed->elf_osabi == ELFOSABI_FREEBSD
	    /* GNU is still using the default value 0.  */
	    || bed->elf_osabi == ELFOSABI_NONE))
	as_bad (_("symbol type \"%s\" is supported only by GNU and FreeBSD targets"),
		type_name);
      type = BSF_FUNCTION | BSF_GNU_INDIRECT_FUNCTION;
    }
  else if (strcmp (type_name, "gnu_unique_object") == 0)
    {
      struct elf_backend_data *bed;

      bed = (struct elf_backend_data *) get_elf_backend_data (stdoutput);
      if (!(bed->elf_osabi == ELFOSABI_GNU
	    /* GNU is still using the default value 0.  */
	    || bed->elf_osabi == ELFOSABI_NONE))
	as_bad (_("symbol type \"%s\" is supported only by GNU targets"),
		type_name);
      type = BSF_OBJECT | BSF_GNU_UNIQUE;
      /* PR 10549: Always set OSABI field to GNU for objects containing unique symbols.  */
      bed->elf_osabi = ELFOSABI_GNU;
    }
#ifdef md_elf_symbol_type
  else if ((type = md_elf_symbol_type (type_name, sym, elfsym)) != -1)
    ;
#endif
  else
    as_bad (_("unrecognized symbol type \"%s\""), type_name);

  *input_line_pointer = c;

  if (*input_line_pointer == '"')
    ++input_line_pointer;

  elfsym->symbol.flags |= type;

  demand_empty_rest_of_line ();
}

static void
obj_elf_ident (int ignore ATTRIBUTE_UNUSED)
{
  static segT comment_section;
  segT old_section = now_seg;
  int old_subsection = now_subseg;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (!comment_section)
    {
      char *p;
      comment_section = subseg_new (".comment", 0);
      bfd_set_section_flags (stdoutput, comment_section,
			     SEC_READONLY | SEC_HAS_CONTENTS
			     | SEC_MERGE | SEC_STRINGS);
      comment_section->entsize = 1;
#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif
      p = frag_more (1);
      *p = 0;
    }
  else
    subseg_set (comment_section, 0);
  stringer (8 + 1);
  subseg_set (old_section, old_subsection);
}

#ifdef INIT_STAB_SECTION

/* The first entry in a .stabs section is special.  */

void
obj_elf_init_stab_section (segT seg)
{
  char *file;
  char *p;
  char *stabstr_name;
  unsigned int stroff;

  /* Force the section to align to a longword boundary.  Without this,
     UnixWare ar crashes.  */
  bfd_set_section_alignment (stdoutput, seg, 2);

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  as_where (&file, NULL);
  stabstr_name = (char *) xmalloc (strlen (segment_name (seg)) + 4);
  strcpy (stabstr_name, segment_name (seg));
  strcat (stabstr_name, "str");
  stroff = get_stab_string_offset (file, stabstr_name);
  know (stroff == 1 || (stroff == 0 && file[0] == '\0'));
  md_number_to_chars (p, stroff, 4);
  seg_info (seg)->stabu.p = p;
}

#endif

/* Fill in the counts in the first entry in a .stabs section.  */

static void
adjust_stab_sections (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)
{
  char *name;
  asection *strsec;
  char *p;
  int strsz, nsyms;

  if (strncmp (".stab", sec->name, 5))
    return;
  if (!strcmp ("str", sec->name + strlen (sec->name) - 3))
    return;

  name = (char *) alloca (strlen (sec->name) + 4);
  strcpy (name, sec->name);
  strcat (name, "str");
  strsec = bfd_get_section_by_name (abfd, name);
  if (strsec)
    strsz = bfd_section_size (abfd, strsec);
  else
    strsz = 0;
  nsyms = bfd_section_size (abfd, sec) / 12 - 1;

  p = seg_info (sec)->stabu.p;
  gas_assert (p != 0);

  bfd_h_put_16 (abfd, nsyms, p + 6);
  bfd_h_put_32 (abfd, strsz, p + 8);
}

#ifdef NEED_ECOFF_DEBUG

/* This function is called by the ECOFF code.  It is supposed to
   record the external symbol information so that the backend can
   write it out correctly.  The ELF backend doesn't actually handle
   this at the moment, so we do it ourselves.  We save the information
   in the symbol.  */

#ifdef OBJ_MAYBE_ELF
static
#endif
void
elf_ecoff_set_ext (symbolS *sym, struct ecoff_extr *ext)
{
  symbol_get_bfdsym (sym)->udata.p = ext;
}

/* This function is called by bfd_ecoff_debug_externals.  It is
   supposed to *EXT to the external symbol information, and return
   whether the symbol should be used at all.  */

static bfd_boolean
elf_get_extr (asymbol *sym, EXTR *ext)
{
  if (sym->udata.p == NULL)
    return FALSE;
  *ext = *(EXTR *) sym->udata.p;
  return TRUE;
}

/* This function is called by bfd_ecoff_debug_externals.  It has
   nothing to do for ELF.  */

static void
elf_set_index (asymbol *sym ATTRIBUTE_UNUSED,
	       bfd_size_type indx ATTRIBUTE_UNUSED)
{
}

#endif /* NEED_ECOFF_DEBUG */

void
elf_frob_symbol (symbolS *symp, int *puntp)
{
  struct elf_obj_sy *sy_obj;
  expressionS *size;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_frob_symbol (symp);
#endif

  sy_obj = symbol_get_obj (symp);

  size = sy_obj->size;
  if (size != NULL)
    {
      if (resolve_expression (size)
	  && size->X_op == O_constant)
	S_SET_SIZE (symp, size->X_add_number);
      else
	{
	  if (flag_size_check == size_check_error)
	    as_bad (_(".size expression for %s "
		      "does not evaluate to a constant"), S_GET_NAME (symp));
	  else
	    as_warn (_(".size expression for %s "
		       "does not evaluate to a constant"), S_GET_NAME (symp));
	}
      free (sy_obj->size);
      sy_obj->size = NULL;
    }

  if (sy_obj->versioned_name != NULL)
    {
      char *p;

      p = strchr (sy_obj->versioned_name, ELF_VER_CHR);
      know (p != NULL);

      /* This symbol was given a new name with the .symver directive.

	 If this is an external reference, just rename the symbol to
	 include the version string.  This will make the relocs be
	 against the correct versioned symbol.

	 If this is a definition, add an alias.  FIXME: Using an alias
	 will permit the debugging information to refer to the right
	 symbol.  However, it's not clear whether it is the best
	 approach.  */

      if (! S_IS_DEFINED (symp))
	{
	  /* Verify that the name isn't using the @@@@ syntax--this is
	     reserved for definitions of the default version to link
	     against.  */
	  if (p[1] == ELF_VER_CHR)
	    {
	      as_bad (_("invalid attempt to declare external version name as default in symbol `%s'"),
		      sy_obj->versioned_name);
	      *puntp = TRUE;
	    }
	  S_SET_NAME (symp, sy_obj->versioned_name);
	}
      else
	{
	  if (p[1] == ELF_VER_CHR && p[2] == ELF_VER_CHR)
	    {
	      size_t l;

	      /* The @@@@@@ syntax is a special case. It renames the
		 symbol name to versioned_name with one `@@' removed.  */
	      l = strlen (&p[3]) + 1;
	      memmove (&p[2], &p[3], l);
	      S_SET_NAME (symp, sy_obj->versioned_name);
	    }
	  else
	    {
	      symbolS *symp2;

	      /* FIXME: Creating a new symbol here is risky.  We're
		 in the final loop over the symbol table.  We can
		 get away with it only because the symbol goes to
		 the end of the list, where the loop will still see
		 it.  It would probably be better to do this in
		 obj_frob_file_before_adjust.  */

	      symp2 = symbol_find_or_make (sy_obj->versioned_name);

	      /* Now we act as though we saw symp2 = sym.  */

	      S_SET_SEGMENT (symp2, S_GET_SEGMENT (symp));

	      /* Subtracting out the frag address here is a hack
		 because we are in the middle of the final loop.  */
	      S_SET_VALUE (symp2,
			   (S_GET_VALUE (symp)
			    - symbol_get_frag (symp)->fr_address));

	      symbol_set_frag (symp2, symbol_get_frag (symp));

	      /* This will copy over the size information.  */
	      copy_symbol_attributes (symp2, symp);

	      S_SET_OTHER (symp2, S_GET_OTHER (symp));

	      if (S_IS_WEAK (symp))
		S_SET_WEAK (symp2);

	      if (S_IS_EXTERNAL (symp))
		S_SET_EXTERNAL (symp2);
	    }
	}
    }

  /* Double check weak symbols.  */
  if (S_IS_WEAK (symp))
    {
      if (S_IS_COMMON (symp))
	as_bad (_("symbol `%s' can not be both weak and common"),
		S_GET_NAME (symp));
    }

#ifdef TC_MIPS
  /* The Irix 5 and 6 assemblers set the type of any common symbol and
     any undefined non-function symbol to STT_OBJECT.  We try to be
     compatible, since newer Irix 5 and 6 linkers care.  However, we
     only set undefined symbols to be STT_OBJECT if we are on Irix,
     because that is the only time gcc will generate the necessary
     .global directives to mark functions.  */

  if (S_IS_COMMON (symp))
    symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;

  if (strstr (TARGET_OS, "irix") != NULL
      && ! S_IS_DEFINED (symp)
      && (symbol_get_bfdsym (symp)->flags & BSF_FUNCTION) == 0)
    symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;
#endif
}

struct group_list
{
  asection **head;		/* Section lists.  */
  unsigned int *elt_count;	/* Number of sections in each list.  */
  unsigned int num_group;	/* Number of lists.  */
  struct hash_control *indexes; /* Maps group name to index in head array.  */
};

/* Called via bfd_map_over_sections.  If SEC is a member of a group,
   add it to a list of sections belonging to the group.  INF is a
   pointer to a struct group_list, which is where we store the head of
   each list.  */

static void
build_group_lists (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
{
  struct group_list *list = (struct group_list *) inf;
  const char *group_name = elf_group_name (sec);
  unsigned int i;
  unsigned int *elem_idx;
  unsigned int *idx_ptr;

  if (group_name == NULL)
    return;

  /* If this group already has a list, add the section to the head of
     the list.  */
  elem_idx = (unsigned int *) hash_find (list->indexes, group_name);
  if (elem_idx != NULL)
    {
      elf_next_in_group (sec) = list->head[*elem_idx];
      list->head[*elem_idx] = sec;
      list->elt_count[*elem_idx] += 1;
      return;
    }

  /* New group.  Make the arrays bigger in chunks to minimize calls to
     realloc.  */
  i = list->num_group;
  if ((i & 127) == 0)
    {
      unsigned int newsize = i + 128;
      list->head = (asection **) xrealloc (list->head,
                                           newsize * sizeof (*list->head));
      list->elt_count = (unsigned int *)
          xrealloc (list->elt_count, newsize * sizeof (*list->elt_count));
    }
  list->head[i] = sec;
  list->elt_count[i] = 1;
  list->num_group += 1;

  /* Add index to hash.  */
  idx_ptr = (unsigned int *) xmalloc (sizeof (unsigned int));
  *idx_ptr = i;
  hash_insert (list->indexes, group_name, idx_ptr);
}

static void free_section_idx (const char *key ATTRIBUTE_UNUSED, void *val)
{
  free ((unsigned int *) val);
}

void
elf_adjust_symtab (void)
{
  struct group_list list;
  unsigned int i;

  /* Go find section groups.  */
  list.num_group = 0;
  list.head = NULL;
  list.elt_count = NULL;
  list.indexes = hash_new ();
  bfd_map_over_sections (stdoutput, build_group_lists, &list);
  
  /* Make the SHT_GROUP sections that describe each section group.  We
     can't set up the section contents here yet, because elf section
     indices have yet to be calculated.  elf.c:set_group_contents does
     the rest of the work.  */
 for (i = 0; i < list.num_group; i++)
    {
      const char *group_name = elf_group_name (list.head[i]);
      const char *sec_name;
      asection *s;
      flagword flags;
      struct symbol *sy;
      bfd_size_type size;

      flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP;
      for (s = list.head[i]; s != NULL; s = elf_next_in_group (s))
	if ((s->flags ^ flags) & SEC_LINK_ONCE)
	  {
	    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
	    if (s != list.head[i])
	      {
		as_warn (_("assuming all members of group `%s' are COMDAT"),
			 group_name);
		break;
	      }
	  }

      sec_name = ".group";
      s = subseg_force_new (sec_name, 0);
      if (s == NULL
	  || !bfd_set_section_flags (stdoutput, s, flags)
	  || !bfd_set_section_alignment (stdoutput, s, 2))
	{
	  as_fatal (_("can't create group: %s"),
		    bfd_errmsg (bfd_get_error ()));
	}
      elf_section_type (s) = SHT_GROUP;

      /* Pass a pointer to the first section in this group.  */
      elf_next_in_group (s) = list.head[i];
      /* Make sure that the signature symbol for the group has the
	 name of the group.  */
      sy = symbol_find_exact (group_name);
      if (!sy
	  || (sy != symbol_lastP
	      && (sy->sy_next == NULL
		  || sy->sy_next->sy_previous != sy)))
	{
	  /* Create the symbol now.  */
	  sy = symbol_new (group_name, now_seg, (valueT) 0, frag_now);
#ifdef TE_SOLARIS
	  /* Before Solaris 11 build 154, Sun ld rejects local group
	     signature symbols, so make them weak hidden instead.  */
	  symbol_get_bfdsym (sy)->flags |= BSF_WEAK;
	  S_SET_OTHER (sy, STV_HIDDEN);
#else
	  symbol_get_obj (sy)->local = 1;
#endif
	  symbol_table_insert (sy);
	}
      elf_group_id (s) = symbol_get_bfdsym (sy);

      size = 4 * (list.elt_count[i] + 1);
      bfd_set_section_size (stdoutput, s, size);
      s->contents = (unsigned char *) frag_more (size);
      frag_now->fr_fix = frag_now_fix_octets ();
      frag_wane (frag_now);
    }

  /* Cleanup hash.  */
  hash_traverse (list.indexes, free_section_idx);
  hash_die (list.indexes);
}

void
elf_frob_file (void)
{
  bfd_map_over_sections (stdoutput, adjust_stab_sections, NULL);

#ifdef elf_tc_final_processing
  elf_tc_final_processing ();
#endif
}

/* It removes any unneeded versioned symbols from the symbol table.  */

void
elf_frob_file_before_adjust (void)
{
  if (symbol_rootP)
    {
      symbolS *symp;

      for (symp = symbol_rootP; symp; symp = symbol_next (symp))
	if (!S_IS_DEFINED (symp))
	  {
	    if (symbol_get_obj (symp)->versioned_name)
	      {
		char *p;

		/* The @@@@@@ syntax is a special case. If the symbol is
		   not defined, 2 `@@'s will be removed from the
		   versioned_name.  */

		p = strchr (symbol_get_obj (symp)->versioned_name,
			    ELF_VER_CHR);
		know (p != NULL);
		if (p[1] == ELF_VER_CHR && p[2] == ELF_VER_CHR)
		  {
		    size_t l = strlen (&p[3]) + 1;
		    memmove (&p[1], &p[3], l);
		  }
		if (symbol_used_p (symp) == 0
		    && symbol_used_in_reloc_p (symp) == 0)
		  symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	      }

	    /* If there was .weak foo, but foo was neither defined nor
	       used anywhere, remove it.  */

	    else if (S_IS_WEAK (symp)
		     && symbol_used_p (symp) == 0
		     && symbol_used_in_reloc_p (symp) == 0)
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	  }
    }
}

/* It is required that we let write_relocs have the opportunity to
   optimize away fixups before output has begun, since it is possible
   to eliminate all fixups for a section and thus we never should
   have generated the relocation section.  */

void
elf_frob_file_after_relocs (void)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    /* Generate the ECOFF debugging information.  */
    {
      const struct ecoff_debug_swap *debug_swap;
      struct ecoff_debug_info debug;
      char *buf;
      asection *sec;

      debug_swap
	= get_elf_backend_data (stdoutput)->elf_backend_ecoff_debug_swap;
      know (debug_swap != NULL);
      ecoff_build_debug (&debug.symbolic_header, &buf, debug_swap);

      /* Set up the pointers in debug.  */
#define SET(ptr, offset, type) \
    debug.ptr = (type) (buf + debug.symbolic_header.offset)

      SET (line, cbLineOffset, unsigned char *);
      SET (external_dnr, cbDnOffset, void *);
      SET (external_pdr, cbPdOffset, void *);
      SET (external_sym, cbSymOffset, void *);
      SET (external_opt, cbOptOffset, void *);
      SET (external_aux, cbAuxOffset, union aux_ext *);
      SET (ss, cbSsOffset, char *);
      SET (external_fdr, cbFdOffset, void *);
      SET (external_rfd, cbRfdOffset, void *);
      /* ssext and external_ext are set up just below.  */

#undef SET

      /* Set up the external symbols.  */
      debug.ssext = debug.ssext_end = NULL;
      debug.external_ext = debug.external_ext_end = NULL;
      if (! bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, TRUE,
				       elf_get_extr, elf_set_index))
	as_fatal (_("failed to set up debugging information: %s"),
		  bfd_errmsg (bfd_get_error ()));

      sec = bfd_get_section_by_name (stdoutput, ".mdebug");
      gas_assert (sec != NULL);

      know (!stdoutput->output_has_begun);

      /* We set the size of the section, call bfd_set_section_contents
	 to force the ELF backend to allocate a file position, and then
	 write out the data.  FIXME: Is this really the best way to do
	 this?  */
      bfd_set_section_size
	(stdoutput, sec, bfd_ecoff_debug_size (stdoutput, &debug, debug_swap));

      /* Pass BUF to bfd_set_section_contents because this will
	 eventually become a call to fwrite, and ISO C prohibits
	 passing a NULL pointer to a stdio function even if the
	 pointer will not be used.  */
      if (! bfd_set_section_contents (stdoutput, sec, buf, 0, 0))
	as_fatal (_("can't start writing .mdebug section: %s"),
		  bfd_errmsg (bfd_get_error ()));

      know (stdoutput->output_has_begun);
      know (sec->filepos != 0);

      if (! bfd_ecoff_write_debug (stdoutput, &debug, debug_swap,
				   sec->filepos))
	as_fatal (_("could not write .mdebug section: %s"),
		  bfd_errmsg (bfd_get_error ()));
    }
#endif /* NEED_ECOFF_DEBUG */
}

#ifdef SCO_ELF

/* Heavily plagiarized from obj_elf_version.  The idea is to emit the
   SCO specific identifier in the .notes section to satisfy the SCO
   linker.

   This looks more complicated than it really is.  As opposed to the
   "obvious" solution, this should handle the cross dev cases
   correctly.  (i.e, hosting on a 64 bit big endian processor, but
   generating SCO Elf code) Efficiency isn't a concern, as there
   should be exactly one of these sections per object module.

   SCO OpenServer 5 identifies it's ELF modules with a standard ELF
   .note section.

   int_32 namesz  = 4 ;  Name size
   int_32 descsz  = 12 ; Descriptive information
   int_32 type    = 1 ;
   char   name[4] = "SCO" ; Originator name ALWAYS SCO + NULL
   int_32 version = (major ver # << 16)  | version of tools ;
   int_32 source  = (tool_id << 16 ) | 1 ;
   int_32 info    = 0 ;    These are set by the SCO tools, but we
			   don't know enough about the source
			   environment to set them.  SCO ld currently
			   ignores them, and recommends we set them
			   to zero.  */

#define SCO_MAJOR_VERSION 0x1
#define SCO_MINOR_VERSION 0x1

void
sco_id (void)
{

  char *name;
  unsigned int c;
  char ch;
  char *p;
  asection *seg = now_seg;
  subsegT subseg = now_subseg;
  Elf_Internal_Note i_note;
  Elf_External_Note e_note;
  asection *note_secp = NULL;
  int i, len;

  /* create the .note section */

  note_secp = subseg_new (".note", 0);
  bfd_set_section_flags (stdoutput,
			 note_secp,
			 SEC_HAS_CONTENTS | SEC_READONLY);

  /* process the version string */

  i_note.namesz = 4;
  i_note.descsz = 12;		/* 12 descriptive bytes */
  i_note.type = NT_VERSION;	/* Contains a version string */

  p = frag_more (sizeof (i_note.namesz));
  md_number_to_chars (p, i_note.namesz, 4);

  p = frag_more (sizeof (i_note.descsz));
  md_number_to_chars (p, i_note.descsz, 4);

  p = frag_more (sizeof (i_note.type));
  md_number_to_chars (p, i_note.type, 4);

  p = frag_more (4);
  strcpy (p, "SCO");

  /* Note: this is the version number of the ELF we're representing */
  p = frag_more (4);
  md_number_to_chars (p, (SCO_MAJOR_VERSION << 16) | (SCO_MINOR_VERSION), 4);

  /* Here, we pick a magic number for ourselves (yes, I "registered"
     it with SCO.  The bottom bit shows that we are compat with the
     SCO ABI.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x4c520000 | 0x0001, 4);

  /* If we knew (or cared) what the source language options were, we'd
     fill them in here.  SCO has given us permission to ignore these
     and just set them to zero.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x0000, 4);

  frag_align (2, 0, 0);

  /* We probably can't restore the current segment, for there likely
     isn't one yet...  */
  if (seg && subseg)
    subseg_set (seg, subseg);

}

#endif /* SCO_ELF */

static void
elf_generate_asm_lineno (void)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_generate_asm_lineno ();
#endif
}

static void
elf_process_stab (segT sec ATTRIBUTE_UNUSED,
		  int what ATTRIBUTE_UNUSED,
		  const char *string ATTRIBUTE_UNUSED,
		  int type ATTRIBUTE_UNUSED,
		  int other ATTRIBUTE_UNUSED,
		  int desc ATTRIBUTE_UNUSED)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_stab (sec, what, string, type, other, desc);
#endif
}

static int
elf_separate_stab_sections (void)
{
#ifdef NEED_ECOFF_DEBUG
  return (!ECOFF_DEBUGGING);
#else
  return 1;
#endif
}

static void
elf_init_stab_section (segT seg)
{
#ifdef NEED_ECOFF_DEBUG
  if (!ECOFF_DEBUGGING)
#endif
    obj_elf_init_stab_section (seg);
}

const struct format_ops elf_format_ops =
{
  bfd_target_elf_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  elf_begin,
  elf_file_symbol,
  elf_frob_symbol,
  elf_frob_file,
  elf_frob_file_before_adjust,
  0,	/* obj_frob_file_before_fix */
  elf_frob_file_after_relocs,
  elf_s_get_size, elf_s_set_size,
  elf_s_get_align, elf_s_set_align,
  elf_s_get_other,
  elf_s_set_other,
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  elf_copy_symbol_attributes,
  elf_generate_asm_lineno,
  elf_process_stab,
  elf_separate_stab_sections,
  elf_init_stab_section,
  elf_sec_sym_ok_for_reloc,
  elf_pop_insert,
#ifdef NEED_ECOFF_DEBUG
  elf_ecoff_set_ext,
#else
  0,	/* ecoff_set_ext */
#endif
  elf_obj_read_begin_hook,
  elf_obj_symbol_new_hook,
  0,
  elf_adjust_symtab
};
@


1.149
log
@	* read.h (s_vendor_attribute): Move to...
	* config/obj-elf.h (obj_elf_vendor_attribute): ... here.
	* read.c (potable): Remove "gnu_attribute".
	(skip_whitespace, skip_past_char, skip_past_comma): Delete, move
	to config/obj-elf.c.
	(s_vendor_attribute): Delete, move to obj_elf_vendor_attribute
	in config/obj-elf.c.
	(s_gnu_attribute): Delete, move to obj_elf_gnu_attribute in
	config/obj-elf.c.
	* config/obj-elf.c (elf_pseudo_table): Add "gnu_attribute".
	(skip_whitespace, skip_past_char, skip_past_comma): New, moved
	from read.c.
	(obj_elf_vendor_attribute): New, moved from s_vendor_attribute
	in read.c.
	(obj_elf_gnu_attribute): New, moved from s_gnu_attribute in
	read.c.
	* config/tc-arm.c (s_arm_eabi_attribute): Rename
	s_vendor_attribute to obj_elf_vendor_attribute.
	* config/tc-tic6x.c (s_tic6x_c6xabi_attribute): Likewise.
@
text
@d65 4
@


1.148
log
@2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* elf32-rx.c (describe_flags): New function.  Returns a buffer
	containing a description of the E_FLAG_RX_... values set.
	(rx_elf_merge_private_bfd_data): Use it.
	(rx_elf_print_private_bfd_data): Likewise.
	(elf32_rx_machine): Skip EF_RX_CPU_RX check.
	(elf32_rx_special_sections): Define.
	(elf_backend_special_sections): Define.

2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* readelf.c (get_machine_flags): Add support for E_FLAG_RX_ABI.

2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* config/obj-elf.c (obj_elf_change_section): Allow init array
	sections to have the SHF_EXECINSTR attribute for the RX target.
	* config/tc-rx.c (elf_flags): Initialise with E_FLAG_RX_ABI.
	(enum options): Add OPTION_USES_GCC_ABI and OPTION_USES_RX_ABI.
	(md_longopts): Add -mgcc-abi and -mrx-abi.
	(md_parse_option): Add support for OPTION_USES_GCC_ABI and
	OPTION_USES_RX_ABI.
	* doc/as.texinfo (RX Options): Add mention of remaining RX
	options.
	* doc/c-rx.texi: Document -mgcc-abi and -mrx-abi.

2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* rx.h (EF_RX_CPU_RX): Add comment.
	(E_FLAG_RX_ABI): Define.

2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* emultempl/rxelf.em (no_flag_mismatch_warnings): Initialise to
	true.
	(PARSE_AND_LIST_LONGOPTS): Add flag-mismatch-warnings.
	(PARSE_AND_LIST_ARG_CASES): Add support for
	--flag-mismatch-warnings.
@
text
@d75 1
d117 3
d1444 132
@


1.147
log
@	PR gas/14315
	* config/obj-elf.c (obj_elf_weak): Don't set local.
@
text
@d661 8
@


1.146
log
@	* config/obj-elf.c (obj_elf_section): Cater for TC_KEEP_OPERAND_SPACES
	targets when checking for "comdat".
@
text
@a449 1
      symbol_get_obj (symbolP)->local = 1;
@


1.145
log
@	PR gas/13224
	* config/obj-elf.c (obj_elf_parse_section_letters): Rename 'clone'
	to 'is_clone' to avoid shadowing a gloabl.
	(obj_elf_section): Likewise.
@
text
@d1052 1
a1052 1
	      else if (strncmp (input_line_pointer, ",comdat", 7) == 0)
d1054 7
a1060 2
		  input_line_pointer += 7;
		  linkonce = 1;
@


1.144
log
@	* readelf.c (get_symbol_type): Add ELFOSABI_FREEBSD to the
	supported abi's.

	* config/obj-elf.c (obj_elf_type): Add ELFOSABI_FREEBSD to the
	supported abi's.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d744 1
a744 1
obj_elf_parse_section_letters (char *str, size_t len, bfd_boolean *clone)
d747 1
a747 1
  *clone = FALSE;
d778 1
a778 1
	  *clone = TRUE;
d981 1
a981 1
	  bfd_boolean clone;
d989 1
a989 1
	  attr |= obj_elf_parse_section_letters (beg, strlen (beg), &clone);
d1041 1
a1041 1
	  if ((attr & SHF_GROUP) != 0 && clone)
d1044 1
a1044 1
	      clone = FALSE;
d1066 1
a1066 1
	  if (clone)
@


1.143
log
@2011-08-04  Tristan Gingold  <gingold@@adacore.com>

	* config/obj-elf.c (obj_elf_section): Do not free name.
@
text
@d1705 1
d1708 1
a1708 1
	as_bad (_("symbol type \"%s\" is supported only by GNU targets"),
@


1.142
log
@ELFOSABI_GNU

	bfd/
	* elf.c (_bfd_elf_set_osabi): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.

	binutils/
	* elfedit.c (osabis): Use ELFOSABI_GNU name instead of ELFOSABI_LINUX
	alias and ELFOSABI_HURD.  Add GNU alias.
	* readelf.c (get_osabi_name, get_symbol_binding, get_symbol_type):
	Likewise.
	* doc/binutils.texi <elfedit>: Update accordingly.

	elfcpp/
	* elfcpp.h (ELFOSABI): Add ELFOSABI_GNU with value of ELFOSABI_LINUX,
	keep ELFOSABI_LINUX as an alias.  Remove ELFOSABI_HURD.

	gas/
	* config/obj-elf.c (obj_elf_type): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* config/tc-ia64.c: Likewise.

	include/elf/
	* common.h (ELFOSABI_GNU): Define, replaces...
	(ELFOSABI_LINUX): ... this, kept as an alias.
	(ELFOSABI_HURD): Remove.

	ld/testsuite/
	* ld-ifunc/ifunc.exp: Update for changed output.
	* ld-unique/unique.exp: Likewise.
@
text
@a986 1
	      xfree (name);
a1005 1
		      xfree (name);
a1086 1
		  xfree (name);
@


1.141
log
@	* obj-elf.c (obj_elf_section): Free malloced name.
@
text
@d1707 2
a1708 2
      if (!(bed->elf_osabi == ELFOSABI_LINUX
	    /* GNU/Linux is still using the default value 0.  */
d1719 2
a1720 2
      if (!(bed->elf_osabi == ELFOSABI_LINUX
	    /* GNU/Linux is still using the default value 0.  */
d1725 2
a1726 2
      /* PR 10549: Always set OSABI field to LINUX for objects containing unique symbols.  */
      bed->elf_osabi = ELFOSABI_LINUX;
@


1.140
log
@	* config/obj-elf.c (elf_frob_symbol): Report S_SET_SIZE symbol
	on .size expression errors rather than symbols in the size expression.
@
text
@d987 1
d1007 1
d1089 1
@


1.139
log
@Add --size-check=[error|warning].

gas/

2011-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* as.c (show_usage): Add --size-check=.
	(parse_args): Add and handle OPTION_SIZE_CHECK.

	* as.h (flag_size_check): New.

	* config/obj-elf.c (elf_frob_symbol): Use as_bad to report
	bad .size directive only for --size-check=error.

	* doc/as.texinfo: Document --size-check=.

gas/testsuite/

2011-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/bad-size.d: New.
	* gas/i386/bad-size.s: Likewise.
	* gas/i386/bad-size.warn: Likewise.

	* gas/i386/i386.exp: Run bad-size for ELF targets.
@
text
@a1898 4
	  const char *op_name = NULL;
	  const char *add_name = NULL;
	  PRINTF_LIKE ((*as_error));

d1900 2
a1901 1
	    as_error = as_bad;
d1903 2
a1904 36
	    as_error = as_warn;

	  if (size->X_op == O_subtract)
	    {
	      op_name = S_GET_NAME (size->X_op_symbol);
	      add_name = S_GET_NAME (size->X_add_symbol);
	      if (strcmp (op_name, FAKE_LABEL_NAME) == 0)
		op_name = NULL;
	      if (strcmp (add_name, FAKE_LABEL_NAME) == 0)
		add_name = NULL;

	      if (op_name && add_name)
		as_error (_(".size expression with symbols `%s' and "
			    "`%s' does not evaluate to a constant"),
			  op_name, add_name);
	      else
		{
		  const char *name;

		  if (op_name)
		    name = op_name;
		  else if (add_name)
		    name = add_name;
		  else
		    name = NULL;

		  if (name)
		    as_error (_(".size expression with symbol `%s' "
				"does not evaluate to a constant"),
			      name);
		}
	    }
	  
	  if (!op_name && !add_name)
	    as_error (_(".size expression does not evaluate to a "
			"constant"));
@


1.138
log
@Mention symbol name in non-constant .size expression.

gas/

2011-03-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (elf_frob_symbol): Mention symbol name in
	non-constant .size expression.

gas/testsuite/

2011-03-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/elf/bad-size.err: Updated.
@
text
@d1901 6
d1918 3
a1920 3
		as_bad (_(".size expression with symbols `%s' and `%s' "
			  "does not evaluate to a constant"),
			op_name, add_name);
d1933 3
a1935 2
		    as_bad (_(".size expression with symbol `%s' "
			      "does not evaluate to a constant"), name);
d1940 2
a1941 1
	    as_bad (_(".size expression does not evaluate to a constant"));
@


1.137
log
@	PR gas/12519
	* config/obj-elf.c (elf_frob_symbol): Properly handle size expression.
	* ld-mn10300/i135409-3.s: Correct .size label reference.
	* ld-sh/sh64/stolib.s: Likewise.
@
text
@d1882 1
d1891 2
a1892 1
  if (sy_obj->size != NULL)
d1894 3
a1896 3
      if (resolve_expression (sy_obj->size)
	  && sy_obj->size->X_op == O_constant)
	S_SET_SIZE (symp, sy_obj->size->X_add_number);
d1898 37
a1934 1
	as_bad (_(".size expression does not evaluate to a constant"));
@


1.136
log
@	PR gas/12181
	* config/obj-elf.c (elf_adjust_symtab) [TE_SOLARIS]: Make sy
	weak hidden.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d1892 5
a1896 17
      switch (sy_obj->size->X_op)
	{
	case O_subtract:
	  S_SET_SIZE (symp,
		      (S_GET_VALUE (sy_obj->size->X_add_symbol)
		       + sy_obj->size->X_add_number
		       - S_GET_VALUE (sy_obj->size->X_op_symbol)));
	  break;
	case O_constant:
	  S_SET_SIZE (symp,
		      (S_GET_VALUE (sy_obj->size->X_add_symbol)
		       + sy_obj->size->X_add_number));
	  break;
	default:
	  as_bad (_(".size expression too complicated to fix up"));
	  break;
	}
@


1.135
log
@Mark parameters of elf_process_stab as ATTRIBUTE_UNUSED.

2010-11-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (elf_process_stab): Mark parameters as
	ATTRIBUTE_UNUSED.
@
text
@d2145 6
d2152 1
@


1.134
log
@	* config/obj-elf.c (elf_generate_asm_lineno): New function.
	(elf_process_stab): New function.
	(elf_format_ops): Always use them as generate_asm_lineno,
	process_stab members.
@
text
@d2401 6
a2406 6
elf_process_stab (segT sec,
		  int what,
		  const char *string,
		  int type,
		  int other,
		  int desc)
@


1.133
log
@	* obj.h (struct format_ops): Add adjust_symtab.
	* config/obj-multi.h (obj_adjust_symtab): Define.
	* config/obj-aout.c (aout_format_ops): Init new field.
	* config/obj-coff.c (coff_format_ops): Likewise.
	* config/obj-ecoff.c (ecoff_format_ops): Likewise.
	* config/obj-elf.c (elf_format_ops): Likewise.
@
text
@d2391 23
d2454 2
a2455 7
#ifdef NEED_ECOFF_DEBUG
  ecoff_generate_asm_lineno,
  ecoff_stab,
#else
  0,	/* generate_asm_lineno */
  0,	/* process_stab */
#endif
@


1.133.2.1
log
@        * config/obj-elf.c (elf_generate_asm_lineno): New function.
        (elf_process_stab): New function.
        (elf_format_ops): Always use them as generate_asm_lineno,
        process_stab members.
@
text
@a2390 23
static void
elf_generate_asm_lineno (void)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_generate_asm_lineno ();
#endif
}

static void
elf_process_stab (segT sec,
		  int what,
		  const char *string,
		  int type,
		  int other,
		  int desc)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_stab (sec, what, string, type, other, desc);
#endif
}

d2431 7
a2437 2
  elf_generate_asm_lineno,
  elf_process_stab,
@


1.133.2.2
log
@2010-11-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (elf_process_stab): Mark parameters as
	ATTRIBUTE_UNUSED.
@
text
@d2401 6
a2406 6
elf_process_stab (segT sec ATTRIBUTE_UNUSED,
		  int what ATTRIBUTE_UNUSED,
		  const char *string ATTRIBUTE_UNUSED,
		  int type ATTRIBUTE_UNUSED,
		  int other ATTRIBUTE_UNUSED,
		  int desc ATTRIBUTE_UNUSED)
@


1.133.2.3
log
@	PR gas/12181
	* config/obj-elf.c (elf_adjust_symtab) [TE_SOLARIS]: Make sy
	weak hidden.
@
text
@a2144 6
#ifdef TE_SOLARIS
	  /* Before Solaris 11 build 154, Sun ld rejects local group
	     signature symbols, so make them weak hidden instead.  */
	  symbol_get_bfdsym (sy)->flags |= BSF_WEAK;
	  S_SET_OTHER (sy, STV_HIDDEN);
#else
a2145 1
#endif
@


1.133.2.4
log
@	PR gas/12519
	* config/obj-elf.c (elf_frob_symbol): Properly handle size expression.
	* ld-mn10300/i135409-3.s: Correct .size label reference.
	* ld-sh/sh64/stolib.s: Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d1892 17
a1908 5
      if (resolve_expression (sy_obj->size)
	  && sy_obj->size->X_op == O_constant)
	S_SET_SIZE (symp, sy_obj->size->X_add_number);
      else
	as_bad (_(".size expression does not evaluate to a constant"));
@


1.133.2.5
log
@	* config/obj-elf.c (elf_frob_symbol): Report S_SET_SIZE symbol
	on .size expression errors rather than symbols in the size expression.

	Backport 2011-03-16  H.J. Lu  <hongjiu.lu@@intel.com>
	* as.c (show_usage): Add --size-check=.
	(parse_args): Add and handle OPTION_SIZE_CHECK.
	* as.h (flag_size_check): New.
	* config/obj-elf.c (elf_frob_symbol): Use as_bad to report
	bad .size directive only for --size-check=error.
	* doc/as.texinfo: Document --size-check=.
@
text
@d1896 1
a1896 8
	{
	  if (flag_size_check == size_check_error)
	    as_bad (_(".size expression for %s "
		      "does not evaluate to a constant"), S_GET_NAME (symp));
	  else
	    as_warn (_(".size expression for %s "
		       "does not evaluate to a constant"), S_GET_NAME (symp));
	}
@


1.132
log
@2010-10-23  Mark Mitchell  <mark@@codesourcery.com>

	* config/obj-elf.c (elf_adjust_symtab): New.  Move group section
	processing here from elf_frob_file.  Ensure that group signature
	symbols have the name of the group.
	(elf_frob_file): Move group section processing to
	elf_adjust_symtab.
	* config/obj-elf.h (elf_adjust_symtab): Declare.
	(obj_adjust_symtab): Define.
	* config/tc-arm.c (arm_adjust_symtab): Call elf_adjust_symtab.

2010-10-23  Mark Mitchell  <mark@@codesourcery.com>

	* gas/elf/elf.exp: Add group0c test.
	* gas/elf/group0c.d: New.
	* gas/elf/group0a.d: Expect ".group" for the name of group
	sections.
	* gas/elf/group0b.d: Likewise.
	* gas/elf/group1a.d: Likewise.
	* gas/elf/group1b.d: Likewise.
	* gas/elf/groupautoa.d: Likewise.
	* gas/elf/groupautob.d: Likewise.
	* gas/elf/section4.d: Likewise.
	* gas/ia64/group-1.d: Likewise.  Adjust hard-coded constants.

2010-10-22  Mark Mitchell  <mark@@codesourcery.com>

	* binutils-all/group-5.d: Expect ".group" for the name of group
	sections.
	* binutils-all/strip-2.d: Likewise.

2010-10-23  Mark Mitchell  <mark@@codesourcery.com>

	* ld-elf/group10.d: Expect ".group" for the name of group
	sections.
	* ld-elf/group2.d: Likewise.
	* ld-elf/group7.d: Likewise.
@
text
@d2449 2
a2450 1
  0
@


1.131
log
@	PR gas/12011
	* config/obj-elf.c (obj_elf_parse_section_letters): Correct test
	for error return from md_elf_section_letter.
	* config/tc-alpha.c (alpha_elf_section_letter): Correct error message.
	* config/tc-i386.c (x86_64_section_letter): Likewise.
	* config/tc-ia64.c (ia64_elf_section_letter): Likewise.
	* config/tc-mep.c (mep_elf_section_letter): Likewise.
	* gas/elf/bad-section-flag.d, * gas/elf/bad-section-flag.err,
	* gas/elf/bad-section-flag.s: New test.
	* gas/elf/elf.exp: Run it.
@
text
@d2084 1
a2084 1
elf_frob_file (void)
a2088 2
  bfd_map_over_sections (stdoutput, adjust_stab_sections, NULL);

d2093 1
a2093 1
  list.indexes  = hash_new ();
d2095 1
a2095 1

d2100 1
a2100 1
  for (i = 0; i < list.num_group; i++)
a2106 1
      int has_sym;
d2122 1
a2122 11
      sec_name = group_name;
      sy = symbol_find_exact (group_name);
      has_sym = 0;
      if (sy != NULL
	  && (sy == symbol_lastP
	      || (sy->sy_next != NULL
		  && sy->sy_next->sy_previous == sy)))
	{
	  has_sym = 1;
	  sec_name = ".group";
	}
d2135 14
a2148 2
      if (has_sym)
	elf_group_id (s) = sy->bsym;
d2157 10
a2169 4

  /* Cleanup hash.  */
  hash_traverse (list.indexes, free_section_idx);
  hash_die (list.indexes);
@


1.130
log
@	* config/obj-elf.c (obj_elf_init_stab_section): Fix assertion.
@
text
@d797 1
a797 1
	    if (md_attr > 0)
@


1.129
log
@Add "?" pseudo-flag to ELF .section/.pushsection directives.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d1798 1
a1798 1
  know (stroff == 1);
@


1.128
log
@	* config/obj-elf.c (get_sym_from_input_line_and_check): New
	function to catch missing pseudo-op arguments.
	(obj_elf_local): Call new function.
	(obj_elf_weak): Likewise.
	(obj_elf_visibility): Likewise.
	(obj_elf_vtable_entry): Likewise.
	(obj_elf_type): Likewise.

	testsuite/
	* gas/elf/pseudo.s: New.
	* gas/elf/pseudo.l: New.
	* gas/elf/pseudo.d: New.
	* gas/elf/elf.exp: Run the new test.
@
text
@d423 1
a423 1
      symbolP = get_sym_from_input_line_and_check (); 
d447 1
a447 1
      symbolP = get_sym_from_input_line_and_check (); 
d744 1
a744 1
obj_elf_parse_section_letters (char *str, size_t len)
d747 1
d777 3
d981 2
d989 1
a989 1
	  attr |= obj_elf_parse_section_letters (beg, strlen (beg));
d1041 5
d1065 10
@


1.127
log
@Implement generic SHF_EXCLUDE.

bfd/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* elf.c (_bfd_elf_make_section_from_shdr): Handle SHF_EXCLUDE
	(elf_fake_sections): Likewise.

	* elf32-i370.c (i370_elf_section_from_shdr): Don't handle
	SHF_EXCLUDE here.
	* elf32-ppc.c (ppc_elf_fake_sections): Likewise.

binutils/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* readelf.c (get_elf_section_flags): Treat SHF_EXCLUDE as a
	generic flag.

binutils/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* binutils-all/objcopy.exp: Run exclude-1a and exclude-1b for
	ELF targets.

	* binutils-all/exclude-1.s: New.
	* binutils-all/exclude-1a.d: Likewise.
	* binutils-all/exclude-1b.d: Likewise.

gas/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* obj-elf.c (obj_elf_change_section): Handle SHF_EXCLUDE.
	(obj_elf_parse_section_letters): Likewise.
	(obj_elf_section_word): Likewise.

	* config/tc-ppc.c (ppc_section_letter): Removed.
	(ppc_section_word): Likewise.
	* config/tc-ppc.h (ppc_section_letter): Likewise.
	(ppc_section_word): Likewise.
	(md_elf_section_letter): Likewise.
	(md_elf_section_word): Likewise.

	* doc/as.texinfo: Document `e' and `#exclude'.

gas/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* gas/elf/elf.exp: Run section8.

	* gas/elf/section8.d: New.
	* gas/elf/section8.s: Likewise.

include/elf/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* common.h (SHF_EXCLUDE): New.

	* i370.h (SHF_EXCLUDE): Removed.
	* or32.h (SHF_EXCLUDE): Likewise.
	* ppc.h (SHF_EXCLUDE): Likewise.
	* sparc.h (SHF_EXCLUDE): Likewise.

ld/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* ld-elf/exclude3.s: New.
	* ld-elf/exclude3a.d: Likewise.
	* ld-elf/exclude3b.d: Likewise.
	* ld-elf/exclude3c.d: Likewise.
@
text
@d396 19
a417 1
  char *name;
d423 2
a424 5
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();
a441 1
  char *name;
d447 2
a448 5
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();
a465 1
  char *name;
d473 1
a473 6
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;

      SKIP_WHITESPACE ();
d483 1
d1251 1
a1251 2
  name = input_line_pointer;
  c = get_symbol_end ();
a1252 5
  sym = symbol_find_or_make (name);

  *input_line_pointer = c;

  SKIP_WHITESPACE ();
a1380 1
  char *name;
a1382 1
  char c;
d1387 1
a1387 6
  name = input_line_pointer;
  c = get_symbol_end ();
  sym = symbol_find_or_make (name);
  *input_line_pointer = c;

  SKIP_WHITESPACE ();
a1608 1
  char *name;
d1615 2
a1616 3
  name = input_line_pointer;
  c = get_symbol_end ();
  sym = symbol_find_or_make (name);
a1617 1
  *input_line_pointer = c;
a1618 1
  SKIP_WHITESPACE ();
@


1.126
log
@        * config/tc-h8300.c (h8300_elf_section): New function - issue a
        warning message if a new section is created without setting any
        attributes for it.
        (md_pseudo_table): Intercept section creation pseudos.
        (md_pcrel_from): Replace abort with an error message.
        * config/obj-elf.c (obj_elf_section_name): Export this function.
        * config/obj-elf.h (obj_elf_section_name): Prototype.

        * gas/elf/section0.d: Skip this test for the h8300.
        * gas/elf/section1.d: Likewise.
        * gas/elf/section6.d: Likewise.
        * gas/elf/elf.exp: Skip section2 and section5 tests when the
        target is the h8300.

        * ld-scrips/sort.exp: Skip these tests when the target is the
        h8300.
@
text
@d676 1
d749 3
d784 1
a784 1
	    char *bad_msg = _("unrecognized .section attribute: want a,w,x,M,S,G,T");
d841 2
@


1.125
log
@	* config/obj-elf.c (obj_elf_change_section): Remove FIXME from
	comment.
@
text
@d858 1
a858 1
static char *
@


1.124
log
@	* ecoff.c (ecoff_symbol_clone_hook): New function.
	* ecoff.h (ecoff_symbol_clone_hook): Declare.
	* obj.h (struct format_ops): Add symbol_clone_hook.
	* config/obj-aout.c (aout_format_ops): Init new field.
	* config/obj-coff.c (coff_format_ops): Likewise.
	* config/obj-ecoff.c (ecoff_format_ops): Likewise.
	* config/obj-elf.c (elf_format_ops): Likewise.
	* config/obj-ecoff.h (obj_symbol_clone_hook): Define.
	* config/obj-multi.h (obj_symbol_clone_hook): Define.
@
text
@d591 1
a591 1
	      /* FIXME: gcc, as of 2002-10-22, will emit
d597 1
a597 1
		 sections, gcc, as of 2005-07-06, will emit
@


1.123
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d2427 2
a2428 1
  elf_obj_symbol_new_hook
@


1.122
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d2057 1
a2057 1
  idx_ptr = xmalloc (sizeof (unsigned int));
@


1.121
log
@update copyright dates
@
text
@d272 1
a272 1
	  S_SET_NAME (sym, obstack_finish (&notes));
d508 1
a508 1
  const char *gname = inf;
d558 1
a558 1
      elt = xmalloc (sizeof (struct section_stack));
d888 1
a888 1
      name = xmalloc (end - input_line_pointer + 1);
d1444 1
a1444 1
	destelf->size = xmalloc (sizeof (expressionS));
d1561 2
a1562 1
      symbol_get_obj (sym)->size = xmalloc (sizeof (expressionS));
d1613 1
a1613 1
  const char *typename;
d1634 1
a1634 1
  typename = obj_elf_type_name (& c);
d1637 3
a1639 3
  if (strcmp (typename, "function") == 0
      || strcmp (typename, "2") == 0
      || strcmp (typename, "STT_FUNC") == 0)
d1641 3
a1643 3
  else if (strcmp (typename, "object") == 0
	   || strcmp (typename, "1") == 0
	   || strcmp (typename, "STT_OBJECT") == 0)
d1645 3
a1647 3
  else if (strcmp (typename, "tls_object") == 0
	   || strcmp (typename, "6") == 0
	   || strcmp (typename, "STT_TLS") == 0)
d1649 3
a1651 3
  else if (strcmp (typename, "notype") == 0
	   || strcmp (typename, "0") == 0
	   || strcmp (typename, "STT_NOTYPE") == 0)
d1653 3
a1655 3
  else if (strcmp (typename, "common") == 0
	   || strcmp (typename, "5") == 0
	   || strcmp (typename, "STT_COMMON") == 0)
d1681 3
a1683 3
  else if (strcmp (typename, "gnu_indirect_function") == 0
	   || strcmp (typename, "10") == 0
	   || strcmp (typename, "STT_GNU_IFUNC") == 0)
d1692 1
a1692 1
		typename);
d1695 1
a1695 1
  else if (strcmp (typename, "gnu_unique_object") == 0)
d1704 1
a1704 1
		typename);
d1710 1
a1710 1
  else if ((type = md_elf_symbol_type (typename, sym, elfsym)) != -1)
d1714 1
a1714 1
    as_bad (_("unrecognized symbol type \"%s\""), typename);
d1778 1
a1778 1
  stabstr_name = xmalloc (strlen (segment_name (seg)) + 4);
d1804 1
a1804 1
  name = alloca (strlen (sec->name) + 4);
d2010 1
d2021 1
a2021 1
  struct group_list *list = inf;
d2024 2
d2032 2
a2033 1
  for (i = 0; i < list->num_group; i++)
d2035 4
a2038 7
      if (strcmp (group_name, elf_group_name (list->head[i])) == 0)
	{
	  elf_next_in_group (sec) = list->head[i];
	  list->head[i] = sec;
	  list->elt_count[i] += 1;
	  return;
	}
d2047 4
a2050 3
      list->head = xrealloc (list->head, newsize * sizeof (*list->head));
      list->elt_count = xrealloc (list->elt_count,
				  newsize * sizeof (*list->elt_count));
d2055 10
d2079 1
d2145 4
@


1.121.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d272 1
a272 1
	  S_SET_NAME (sym, (const char *) obstack_finish (&notes));
d508 1
a508 1
  const char *gname = (const char *) inf;
d558 1
a558 1
      elt = (struct section_stack *) xmalloc (sizeof (struct section_stack));
d888 1
a888 1
      name = (char *) xmalloc (end - input_line_pointer + 1);
d1444 1
a1444 1
	destelf->size = (expressionS *) xmalloc (sizeof (expressionS));
d1561 1
a1561 2
      symbol_get_obj (sym)->size =
          (expressionS *) xmalloc (sizeof (expressionS));
d1612 1
a1612 1
  const char *type_name;
d1633 1
a1633 1
  type_name = obj_elf_type_name (& c);
d1636 3
a1638 3
  if (strcmp (type_name, "function") == 0
      || strcmp (type_name, "2") == 0
      || strcmp (type_name, "STT_FUNC") == 0)
d1640 3
a1642 3
  else if (strcmp (type_name, "object") == 0
	   || strcmp (type_name, "1") == 0
	   || strcmp (type_name, "STT_OBJECT") == 0)
d1644 3
a1646 3
  else if (strcmp (type_name, "tls_object") == 0
	   || strcmp (type_name, "6") == 0
	   || strcmp (type_name, "STT_TLS") == 0)
d1648 3
a1650 3
  else if (strcmp (type_name, "notype") == 0
	   || strcmp (type_name, "0") == 0
	   || strcmp (type_name, "STT_NOTYPE") == 0)
d1652 3
a1654 3
  else if (strcmp (type_name, "common") == 0
	   || strcmp (type_name, "5") == 0
	   || strcmp (type_name, "STT_COMMON") == 0)
d1680 3
a1682 3
  else if (strcmp (type_name, "gnu_indirect_function") == 0
	   || strcmp (type_name, "10") == 0
	   || strcmp (type_name, "STT_GNU_IFUNC") == 0)
d1691 1
a1691 1
		type_name);
d1694 1
a1694 1
  else if (strcmp (type_name, "gnu_unique_object") == 0)
d1703 1
a1703 1
		type_name);
d1709 1
a1709 1
  else if ((type = md_elf_symbol_type (type_name, sym, elfsym)) != -1)
d1713 1
a1713 1
    as_bad (_("unrecognized symbol type \"%s\""), type_name);
d1777 1
a1777 1
  stabstr_name = (char *) xmalloc (strlen (segment_name (seg)) + 4);
d1803 1
a1803 1
  name = (char *) alloca (strlen (sec->name) + 4);
d2019 1
a2019 1
  struct group_list *list = (struct group_list *) inf;
d2045 3
a2047 4
      list->head = (asection **) xrealloc (list->head,
                                           newsize * sizeof (*list->head));
      list->elt_count = (unsigned int *)
          xrealloc (list->elt_count, newsize * sizeof (*list->elt_count));
@


1.120
log
@bfd/
2009-08-31  Jan Beulich  <jbeulich@@novell.com>

	* elf-bfd.h (bfd_elf_get_default_section_type): Declare.
	* elf.c (bfd_elf_get_default_section_type): New.
	(elf_fake_sections): Use bfd_elf_get_default_section_type.

gas/
2009-08-31  Jan Beulich  <jbeulich@@novell.com>

	* config/obj-elf.c (obj_elf_change_section): Set default type
	by calling bfd_elf_get_default_section_type.

gas/testsuite/
2009-08-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/elf/section5.l: Remove no longer issued warning pattern.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
@


1.119
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d688 2
@


1.118
log
@	binutils/testsuite/
	* binutils-all/arm/thumb2-cond.s: Use instructions instead of
	.short.

	gas/
	* config/obj-elf.c (obj_elf_ident): Notify section change to the hook.
	* config/tc-arm.c (make_mapping_symbol): New function, from
	mapping_state.  Save mapping symbols in the frag.
	(insert_data_mapping_symbol): New.
	(mapping_state): Use make_mapping_symbol, improve state transitions.
	(mapping_state_2): New.  Provide dummy definition.
	(opcode_select): Do not call mapping_state.
	(s_bss): Call md_elf_section_change_hook instead of mapping_state.
	(output_inst): Update use of tc_frag_data.
	(new_automatic_it_block): Call mapping_state before emitting the
	IT instruction.
	(md_assemble): Move mapping_state to just before outputting the
	new instruction.
	(arm_handle_align): Update use of tc_frag_data.
	Call insert_data_mapping_symbol.
	(arm_init_frag): Update use of tc_frag_data.  Call
	mapping_state_2.
	(arm_elf_change_section): Always update the mapping symbol FSM state.
	(check_mapping_symbols): New function.
	(arm_adjust_symtab): Use check_mapping_symbols.
	* config/tc-arm.h (struct arm_frag_type): New.
	(TC_FRAG_TYPE): Change to struct arm_frag_type.
	(TC_FRAG_INIT): Pass max_chars.
	(arm_init_frag): Update prototype.

	gas/testsuite/
	* gas/arm/mapdir.d, gas/arm/mapdir.s: New files.
	* gas/arm/mapping.d: Adapted to new symbols generation.
	* gas/arm/mapping2.d: New test case.
	* gas/arm/mapping2.s: New file.
	* gas/arm/mapping3.d: New test case.
	* gas/arm/mapping3.s: New file.
	* gas/arm/mapping4.d: New test case.
	* gas/arm/mapping4.s: New file.
	* gas/arm/mapshort-eabi.d: Adapted to new symbols generation.
	* gas/elf/section2.e-armeabi: Adapted to new symbols generation.
@
text
@d1694 1
a1694 1
      const struct elf_backend_data *bed;
d1696 1
a1696 1
      bed = get_elf_backend_data (stdoutput);
d1703 2
@


1.117
log
@gas/
2009-07-27  Jan Beulich  <jbeulich@@novell.com>

	* obj-elf.c (elf_file_symbol): Replace symbol name set up by
	symbol_new() with the passed in, unmodified one.

gas/testsuite/
2009-07-27  Jan Beulich  <jbeulich@@novell.com>

	* gas/elf/file.[ds]: New.
	* gas/elf/elf.exp: Run new test.
@
text
@d1740 3
@


1.116
log
@2009-07-24  Roland McGrath  <roland@@redhat.com>

	* config/obj-elf.c (obj_elf_ident): Set SEC_MERGE | SEC_STRINGS
	flags on .comment section.
@
text
@d263 1
d267 10
@


1.115
log
@        * config/obj-elf.c (obj_elf_type): Add code to support a type of
        gnu_unique_object.
        * doc/as.texinfo: Document new feature of .type directive.
        * NEWS: Mention support for gnu_unique_object symbol type.

        * common.h (STB_GNU_UNIQUE): Define.

        * NEWS: Mention the linker's support for symbols with a binding of
        STB_GNU_UNIQUE.

        * gas/elf/type.s: Add unique global symbol definition.
        * gas/elf/type.e: Add expected readelf output for global unique
        symbol.

        * elfcpp.h (enum STB): Add STB_GNU_UNIQUE.

        * readelf.c (get_symbol_binding): For Linux targeted files return
        UNIQUE for symbols with the STB_GNU_UNIQUE binding.
        * doc/binutils.texi: Document the meaning of the 'u' symbol
        binding in the output of nm and objdump --syms.

        * elf-bfd.h (struct elf_link_hash_entry): Add unique_global field.
        * elf.c (swap_out_syms): Set binding to STB_GNU_UNIQUE for symbols
        with the BSF_GNU_UNIQUE flag bit set.
        * elfcode.h (elf_slurp_symbol_table): Set the BSF_GNU_UNIQUE flag
        for symbols with STB_GNU_UNIQUE binding.
        * elflink.c (_bfd_elf_merge_symbol): Set unique_global for symbols
        with the STB_GNU_UNIQUE binding.
        (elf_link_add_object_symbols): Set the BSF_GNU_UNIQUE flag for
        symbols with STB_GNU_UNIQUE binding.  Set STB_GNU_UNIQUE for
        symbols with the unique_global field set.
        (elf_link_output_extsym): Set unique_global field for symbols with
        the STB_GNU_UNIQUE binding.
        * syms.c (struct bfd_symbol): Define BSF_GNU_UNIQUE flag bit.
        (bfd_print_symbol_vandf): Print a 'u' character for BSF_GNU_UNIQUE
        symbols.
        (bfd_decode_symclass): Return a 'u' character for BSF_GNU_UNIQUE
        symbols.
        * bfd-in2.h: Regenerate.
@
text
@d499 1
a499 1
  
d1726 3
a1728 1
			     SEC_READONLY | SEC_HAS_CONTENTS);
@


1.114
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d1668 2
a1669 2
      || strcmp (typename, "10") == 0
      || strcmp (typename, "STT_GNU_IFUNC") == 0)
d1681 12
@


1.113
log
@include/elf
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * common.h (STT_GNU_IFUNC): Define.

elfcpp
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * (enum STT): Add STT_GNU_IFUNC.

gas
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * config/obj-elf.c (obj_elf_type): Add support for a
        gnu_indirect_function type.
        * config/tc-i386.c (tc_i386_fix_adjustable): Do not adjust fixups
        against indirect function symbols.
        * doc/as.texinfo (.type): Document the support for the
        gnu_indirect_function symbol type.
        * NEWS: Mention the new feature.

gas/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * gas/elf/elf.exp: Extend type test to include an ifunc symbol.
        Provide an alternative test for targets which do not support ifunc
        symbols.
        (type.s): Add entry for an ifunc symbol.
        (type.e): Add ifunc entry to expected symbol dump.
        (section2.e-armelf): Add  entry for ifunc symbol.
        (type-noifunc.s): New file.
        (type-noifunc.e): New file.

bfd/
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs
        section pointer.
        (struct elf_obj_data): Add has_ifunc_symbols boolean.
        * elf.c (swap_out_syms): Convert BSF_GNU_INDIRECT_FUNCTION flags
        into a STT_GNU_IFUNC symbol type.
        (_bfd_elf_is_function_type): Accept STT_GNU_IFUNC as a function
        type.
        (_bfd_elf_set_osabi): Set the osasbi field to ELFOSABI_LINUX if
        the binary contains ifunc symbols.
        * elfcode.h (elf_slurp_symbol_table): Translate the STT_GNU_IFUNC
        symbol type into a BSF_GNU_INDIRECT_FUNCTION flag.
        * elf32-i386.c (is_indirect_function): New function.
        (elf_i386_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf_i386_relocate_section): Emit a reloc against an ifunc symbol
        if necessary.
        (elf_i386_add_symbol_hook): New function. Set the
        has_ifunc_symbols field of the elf_obj_data structure if an ifunc
        symbol is encountered.
        (elf_backend_post_process_headers): Define.
        (elf_backend_add_symbol_hook): Define.
        (elf_i386_post_process_headers): Rename to
        elf_i388_fbsd_post_process_headers.
        * elf64-x86_64.c (IS_X86_64_PCREL_TYPE): New macro.
        (is_indirect_function): New function.
        (elf64_x86_64_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf64_x86_64_relocate_section): Emit a reloc against an ifunc
        symbol if necessary.
        (elf_i386_add_symbol_hook): Set the has_ifunc_symbols field of the
        elf_obj_data structure if an ifunc symbol is encountered.
        (elf_backend_post_process_headers): Define.
        * elflink.c (_bfd_elf_adjust_dynamic_symbol): Always create a PLT
        if we have ifunc symbols to handle.
        (get_ifunc_reloc_section_name): New function.  Computes the name
        for an ifunc section.
        (_bfd_elf_make_ifunc_reloc_section): New function.  Creates a
        section to hold ifunc relocs.
        * syms.c (BSF_GNU_INDIRECT_FUNCTION): Define.
        (bfd_print_symbol_vandf): Handle ifunc symbols.
        (bfd_decode_symclass): Likewise.
        * bfd-in2.h: Regenerate.

binutils
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * readelf.c (dump_relocations): Display a relocation against an
        ifunc symbol as if it were a function invocation.
        (get_symbol_type): Handle STT_GNU_IFUNC.

ld
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * NEWS: Mention support for IFUNC symbols.

ld/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * ld-ifunc: New directory.
        * ld-ifunc/ifunc.exp: New file: Run the IFUNC tests.
        * ld-ifunc/prog.c: New file.
        * ld-ifunc/lib.c: New file.
@
text
@d462 1
a462 1
      assert (elfsym);
d1349 1
a1349 1
  assert (symbol_get_value_expression (csym)->X_op == O_constant);
d1782 1
a1782 1
  assert (p != 0);
d2193 1
a2193 1
      assert (sec != NULL);
@


1.112
log
@        * include/elf/ia64.h (SHT_IA_64_VMS_DISPLAY_NAME_INFO,
        EF_IA_64_ARCHVER_1): New macros. Minor reformatting.

        * bfd/Makefile.am (BFD32_BACKENDS): Add new object vmsutil.lo
        (BFD32_BACKENDS_CFILES): Add new file vmsutil.c
        (vmsutil.lo): Add dependency rule
        * bfd/Makefile.in: Regenerate
        * bfd/config.bfd (ia64*-*-*vms*): Add case.
        * bfd/configure.in (bfd_elf64_ia64_vms_vec): Add case.
        * bfd/configure: Regenerate
        * bfd/vmsutil.[ch]: New files
        * bfd/elf-bfd.h (struct bfd_elf_special_section): Change type of
        attr to bfd_vma.
        * bfd/elfxx-ia64.c (elfNN_vms_post_process_headers,
        elfNN_vms_section_processing, elfNN_vms_final_write_processing,
        elfNN_vms_close_and_cleanup, elfNN_vms_section_from_shdr,
        elfNN_vms_object_p): New functions
        * bfd/targets.c (bfd_elf64_ia64_vms_vec): New target.

        * gas/configure.tgt(ia64-*-*vms*): New target.
        * gas/dwarf2dbg.h (dwarf2_loc_mark_labels): Make extern.
        * gas/tc.h (md_number_to_chars): Declare iff undefined.
        * gas/config/obj-elf.c (obj_elf_change_section): Change type of
        arg attr to bfd_vma.
        (obj_elf_parse_section_letters): Return a bfd_vma. Change type of
        variables attr, md_attr to bfd_vma.
        (obj_elf_section_word): Likewise.
        (obj_elf_section): Change type of variable attr to bfd_vma
        * gas/config/obj-elf.h (obj_elf_change_section): Change type of
        arg attr to bfd_vma
        * gas/config/tc-ia64.c (bfdver.h,time.h): Include.
        (ia64_elf_section_letter): Now returns a bfd_vma.
        Handle VMS specific attributes.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (ia64_init): Don't turn on dependency checking for VMS.
        (ia64_target_format): Check for VMS flag bit.
        (do_alias): Hande decc$ functions.
        (get_vms_time): New function.
        (ia64_vms_note): New function.
        * gas/config/tc-ia64.h (ia64_elf_section_letter): Now returns a bfd_vma.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (tc_init_after_args): Define for VMS.
        * gas/config/tc-alpha.c (alpha_elf_section_letter): Return a bfd_vma.
        (alpha_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-alpha.h: Likewise.
        * gas/config/tc-i386.c (x86_64_section_letter): Return a bfd_vma.
        (x86_64_section_word): Return a bfd_vma.
        * gas/config/tc-i386.h: Likewise.
        * gas/config/tc-ip2k.c (ip2k_elf_section_flags): Change type of arg
        attr to bfd_vma.
        * gas/config/tc-ip2k.h: Likewise.
        * gas/config/tc-mep.c (mep_elf_section_letter): Return a bfd_vma.
        (mep_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-mep.h: Likewise.
        * gas/config/tc-ppc.c  (ppc_section_letter): Return a bfd_vma.
        (ppc_section_word): Return a bfd_vma.
        (ppc_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-ppc.h: Likewise.
        * gas/config/te-vms.h (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,
        DWAR2_FILE_TIME_NAME, DWARF2_FILE_SIZE_NAME, DWARF2_FILEN_NAME):
        New file with new macros
        * gas/dwarf2dbg.c (get_filenum, out_file_list): Default and call new
        macros.
@
text
@d1667 14
@


1.111
log
@Remove STT_IFUNC support.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007
d527 1
a527 1
			int attr,
d723 1
a723 1
static int
d726 1
a726 1
  int attr = 0;
d769 2
a770 2
	    int md_attr = md_elf_section_letter (*str, &bad_msg);
	    if (md_attr >= 0)
d813 1
a813 1
static int
d829 2
a830 2
    int md_attr = md_elf_section_word (str, len);
    if (md_attr >= 0)
d891 2
a892 1
  int type, attr, dummy;
@


1.110
log
@include/elf/
            * common.h (STT_IFUNC): Define.
elfcpp/
            * elfcpp.h (enum STT): Add STT_IFUNC.
bfd/
            * syms.c (struct bfd_symbol): Add new flag BSF_INDIRECT_FUNCTION.
            Remove redundant flag BFD_FORT_COMM_DEFAULT_VALUE.  Renumber flags
            to remove gaps.
            (bfd_print_symbol_vandf): Return 'i' for BSF_INDIRECT_FUNCTION.
            (bfd_decode_symclass): Likewise.
            * elf.c (swap_out_syms): Translate BSF_INDIRECT_FUNCTION into
            STT_IFUNC.
            (elf_find_function): Treat STT_IFUNC in the same way as STT_FUNC.
            (_bfd_elf_is_function_type): Likewise.
            * elf32-arm.c (arm_elf_find_function): Likewise.
            (elf32_arm_adjust_dynamic_symbol): Likewise.
            (elf32_arm_swap_symbol_in): Likewise.
            (elf32_arm_additional_program_headers): Likewise.
            * elf32-i386.c (is_indirect_symbol): New function.
            (elf_i386_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf_i386_relocate_section): Likewise.
            * elf64-x86-64.c (is_indirect_symbol): New function.
            (elf64_x86_64_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf64_x86_64_relocate_section): Likewise.
            * elfcode.h (elf_slurp_symbol_table): Translate STT_IFUNC into
            BSF_INDIRECT_FUNCTION.
            * elflink.c (_bfd_elf_adjust_dynamic_reloc_section): Add support
            for STT_IFUNC symbols.
            (get_ifunc_reloc_section_name): New function.
            (_bfd_elf_make_ifunc_reloc_section): New function.
            * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs field.
            * bfd-in2.h: Regenerate.
gas/
            * config/obj-elf.c (obj_elf_type): Add support for STT_IFUNC type.
            * doc/as.texinfo: Document new feature.
            * NEWS: Mention new feature.
gas/testsuite/
            * gas/elf/type.s: Add test of STT_IFUNC symbol type.
            * gas/elf/type.e: Update expected disassembly.
            * gas/elf/elf.exp: Update grep of symbol types.
ld/
            * NEWS: Mention new feature.
            * pe-dll.c (process_def_file): Replace use of redundant
            BFD_FORT_COMM_DEFAULT_VALUE with 0.
            * scripttempl/elf.sc: Add .rel.ifunc.dyn and .rela.ifunc.dyn
            sections.
ld/testsuite/
            * ld-mips-elf/reloc-1-n32.d: Updated expected output for reloc
            descriptions.
            * ld-mips-elf/reloc-1-n64.d: Likewise.
            * ld-i386/ifunc.d: New test.
            * ld-i386/ifunc.s: Source file for the new test.
            * ld-i386/i386.exp: Run the new test.
@
text
@a1665 14
  else if (strcmp (typename, "indirect_function") == 0
      || strcmp (typename, "10") == 0
      || strcmp (typename, "STT_IFUNC") == 0)
    {
      const struct elf_backend_data *bed;

      bed = get_elf_backend_data (stdoutput);
      if (!(bed->elf_osabi == ELFOSABI_LINUX
	    /* GNU/Linux is still using the default value 0.  */
	    || bed->elf_osabi == ELFOSABI_NONE))
	as_bad (_("symbol type \"%s\" is supported only by GNU targets"),
		typename);
      type = BSF_FUNCTION | BSF_INDIRECT_FUNCTION;
    }
@


1.109
log
@        * config/obj-elf.c (obj_elf_section_type): Add prototype
        before obj_elf_section_word and add 'warn' arg.
        (obj_elf_section_word): Add type pointer arg, and if no #SECTION
        is matched, try checking for #SECTION_TYPE.
        (obj_elf_section): Adjust for new args.
        (obj_elf_type_name): New function.
        (obj_elf_type): Call it, and accept STT_foo number strings
        in .type statements as output by SunPRO compiler.
@
text
@d1666 14
@


1.108
log
@gas/

2007-10-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5221
	* config/obj-elf.c (obj_elf_section): Handle optional
	parameters for .pushsection.

	* doc/as.texinfo: Document optional parameters for
	.pushsection.

gas/testsuite/

2007-10-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5221
	* gas/elf/elf.exp: Run section7.

	* gas/elf/section7.d: New.
	* gas/elf/section7.s: Likewise.
@
text
@d785 1
a785 25
obj_elf_section_word (char *str, size_t len)
{
  if (len == 5 && strncmp (str, "write", 5) == 0)
    return SHF_WRITE;
  if (len == 5 && strncmp (str, "alloc", 5) == 0)
    return SHF_ALLOC;
  if (len == 9 && strncmp (str, "execinstr", 9) == 0)
    return SHF_EXECINSTR;
  if (len == 3 && strncmp (str, "tls", 3) == 0)
    return SHF_TLS;

#ifdef md_elf_section_word
  {
    int md_attr = md_elf_section_word (str, len);
    if (md_attr >= 0)
      return md_attr;
  }
#endif

  as_warn (_("unrecognized section attribute"));
  return 0;
}

static int
obj_elf_section_type (char *str, size_t len)
d808 33
a840 1
  as_warn (_("unrecognized section type"));
d976 1
a976 1
		  type = obj_elf_section_type (beg, strlen (beg));
d983 1
a983 1
		  type = obj_elf_section_type (beg, input_line_pointer - beg);
d1046 1
a1046 1
	      attr |= obj_elf_section_word (beg, input_line_pointer - beg);
d1554 1
a1554 1
   There are five syntaxes:
d1566 3
d1571 21
d1619 1
a1619 2
  typename = input_line_pointer;
  c = get_symbol_end ();
d1623 1
d1627 1
d1631 1
d1635 1
d1639 1
@


1.107
log
@Support the use of the STT_COMMON type.  (In source and object files only at the moment)
@
text
@d925 1
a925 1
      if (push)
d927 1
d929 10
d940 2
a941 1
      else if (*input_line_pointer == '"')
d1047 1
@


1.106
log
@* config/obj-elf.c (obj_elf_section): When pushing a section, if there is a
  comma then the following argument must be a subsection number.
* testsuite/gas/elf/elf.exp (run_elf_list_test): Run section6 test.
* testsuite/gas/elf/section6.s: New file: Check behaviour of .pushsection with a subsection argument.
* testsuite/gas/elf/section6.d: New file: Expected disassembly.
@
text
@d1590 27
@


1.105
log
@PR gas/5121 gas/5122 gas/5123 gas/5124 gas/5125 gas/5126 gas/5129 gas/5131 gas/5132 gas/5137 gas/5143
* Makefile.am (CFILES): Add cgen.c
  (TARGET_CPU_CFILES): Add tc-iq2000.c, tc-maxq.c, tc-mt.c, tc-tic4x.c and xtensa-relax.c.
  (TARGET_CPU_HFILES): Add tc-iq2000.h, tc-maxq.h, tc-mt.h, tc-tic4x.h and xtensa-relax.h.
  (TARG_ENV_HFILES): Remove te-aux.h, te-delta.h, te-delt88.h, te-ic960.h, te-linux.h.
   Add te-aix5.h, te-armeabi.h, te-freebsd.h, te-gnu.h, te-interix.h, te-vxworks.h.
  (CONFIG_ATOF_CFILES): New variable.
  (POTFILES): Add CONFIG_ATOF_CFILES to dependencies.  Fix typo with dependency upon TARG_ENV_HFILES.
  (DEPTC): Do not put "#include opcodes/<foo>-desc.h" into cgen-desc.h when foo-desc.h does not exit.
   Run make dep-am.
* Makefile.in: Regenerate.
* doc/Makefile.in: Regenerate.
* po/POTFILES.in: Regenerate.
* po/es.po: Regenerate.
* po/fr.po: Regenerate.
* po/gas.pot: Regenerate.
* po/rw.po: Regenerate.
* po/tr.po: Regenerate.
* config/obj-elf.c (obj_elf_vtable_inherit): Allow for translation of error messages.
* config/obj-som.c: Likewise.
* config/tc-arc.c: Likewise.
* config/tc-arm.c: Likewise.
* config/tc-bfin.c: Likewise.
* config/tc-frv.c: Likewise.
@
text
@d886 1
d925 5
a929 1
      if (*input_line_pointer == '"')
d1038 3
d1100 1
a1100 1
  register int temp;
@


1.104
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@d1278 1
a1278 1
      as_bad ("expected `%s' to have already been set for .vtable_inherit",
d1288 1
a1288 1
      as_bad ("expected comma after name in .vtable_inherit");
d1348 1
a1348 1
      as_bad ("expected comma after name in .vtable_entry");
@


1.103
log
@Switch to GPLv3
@
text
@d1621 1
a1621 1
  stringer (1);
@


1.102
log
@	PR 4713
	* config/obj-elf.c (elf_ecoff_set_ext): Make static when OBJ_MAYBE_ELF.
	* config/obj-elf.h (obj_ecoff_set_ext): Comment.
@
text
@d10 1
a10 1
   published by the Free Software Foundation; either version 2,
@


1.101
log
@	* config/obj-elf.c (elf_frob_file): frag_wane any new frags.
@
text
@d3 2
a4 1
   2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d1697 3
@


1.100
log
@Support for Toshiba MeP and for complex relocations.
@
text
@d1990 1
@


1.99
log
@	* config/obj-elf.c (obj_elf_version): Use memcpy rather than strcpy.
@
text
@d60 4
@


1.98
log
@PR gas/3456:
* config/obj-elf.c (obj_elf_version): Do not include the name field's padding in the namesz value.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d1459 1
a1459 1
      strcpy (p, name);
@


1.97
log
@2006-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/2598
	* config/obj-elf.c (obj_elf_change_section): Allow user
	specified SHF_ALPHA_GPREL.
@
text
@a1421 1
  int len;
d1426 2
d1438 1
a1438 2
      /* create the .note section */

d1444 2
a1445 3
      /* process the version string */

      len = strlen (name);
d1447 4
a1450 2
      i_note.namesz = ((len + 1) + 3) & ~3; /* round this to word boundary */
      i_note.descsz = 0;	/* no description */
d1458 1
a1458 1
      p = frag_more (len + 1);
d1466 2
a1467 3
    {
      as_bad (_("expected quoted string"));
    }
@


1.96
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d635 5
@


1.95
log
@bfd/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_large_com_section): New.
	* elf.c (_bfd_elf_large_com_section): New. Defined.

	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): New.
	(elf64_x86_64_elf_section_from_bfd_section): New.
	(elf64_x86_64_symbol_processing): New.
	(elf64_x86_64_common_definition): New.
	(elf64_x86_64_common_section_index): New.
	(elf64_x86_64_common_section): New.
	(elf64_x86_64_merge_symbol): New.
	(elf64_x86_64_additional_program_headers): New.
	(elf64_x86_64_special_sections): New.
	(elf_backend_section_from_bfd_section): New. Defined.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_common_section_index): Likewise.
	(elf_backend_common_section): Likewise.
	(elf_backend_common_definition): Likewise.
	(elf_backend_merge_symbol): Likewise.
	(elf_backend_special_sections): Likewise.
	(elf_backend_additional_program_headers): Likewise.

binutils/

2005-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (dump_relocations): Handle SHN_X86_64_LCOMMON.
	(get_symbol_index_type): Likewise.
	(get_elf_section_flags): Handle SHF_X86_64_LARGE.

gas/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c: Include "elf/x86-64.h" if TC_I386 is
	defined.
	(elf_com_section_ptr): New.
	(elf_begin): Set elf_com_section_ptr to bfd_com_section_ptr.
	(elf_common_parse): Make it global. Use elf_com_section_ptr
	instead of bfd_com_section_ptr.
	(obj_elf_change_section): Handle x86-64 large bss sections.

	* config/obj-elf.h (elf_com_section_ptr): New.
	(elf_common_parse): New.

	* config/tc-i386.c (handle_large_common): New.
	(md_pseudo_table): Add "largecomm".
	(x86_64_section_letter): New.
	(x86_64_section_word): New.

	* config/tc-i386.h (x86_64_section_word): New.
	(x86_64_section_letter): New.
	(md_elf_section_letter): New. Defined.
	(md_elf_section_word): Likewise.

include/elf/

2005-07-25  Jan Hubicka  <jh@@suse.cz>

	* x86-64.h (SHN_X86_64_LCOMMON): New.
	(SHF_X86_64_LARGE): New.

ld/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/elf_x86_64.sh (LARGE_SECTIONS): New.

	* scripttempl/elf.sc: Updated for large section support.
@
text
@d118 1
@


1.94
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d56 4
d181 2
d195 1
d280 1
a280 1
static symbolS *
d344 1
a344 1
      S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
d579 5
d585 4
@


1.93
log
@Update the address and phone number of the FSF
@
text
@d523 1
d555 2
a556 1
  ssect = _bfd_elf_get_sec_type_attr (stdoutput, name);
@


1.92
log
@gas/
2005-04-15  Jan Beulich  <jbeulich@@novell.com>

	* config/obj-elf.c (obj_elf_struct): New.
	(elf_pseudo_table). Use it for .offset and .struct.

gas/testsuite/
2005-04-15  Jan Beulich  <jbeulich@@novell.com>

	* gas/elf/struct.[sd]: New.
	* gas/elf/elf.exp: Run new test.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.91
log
@	* read.c: Warning fixes.
	* config/obj-elf.c: Likewise.
@
text
@d68 1
d117 2
d1042 18
@


1.90
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d1939 1
a1939 1
      s->contents = frag_more (size);
@


1.89
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d263 1
a263 1
  ecoff_new_file (s);
@


1.88
log
@gas/
2004-12-15 Jan Beulich  <jbeulich@@novell.com>

	* config/obj-elf.c (obj_elf_change_section): Only set type and
	attributes on new sections. Emit warning when type of re-declared
	section doesn't match.

gas/testsuite/
2004-12-15 Jan Beulich  <jbeulich@@novell.com>

	* gas/elf/section5.[els]: New.
@
text
@a1817 11

#if 0 /* TC_PPC */
  /* If TC_PPC is defined, we used to force the type of a symbol to be
     BSF_OBJECT if it was otherwise unset.  This was required by some
     version of VxWorks.  Thomas de Lellis <tdel@@windriver.com> says
     that this is no longer needed, so it is now commented out.  */
  if ((symbol_get_bfdsym (symp)->flags
       & (BSF_FUNCTION | BSF_FILE | BSF_SECTION_SYM)) == 0
      && S_IS_DEFINED (symp))
    symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;
#endif
@


1.87
log
@	* obj.h (struct format_ops <app_file>): Add int param.
	* read.h (s_app_file_string): Likewise.
	* read.c (s_app_file_string): Likewise.
	(s_app_file): Adjust s_app_file_string call.
	* config/tc-mips.c (s_mips_file): Likewise.
	* config/obj-coff.h (obj_app_file): Add app param.
	* config/obj-ecoff.h (obj_app_file): Likewise.
	* config/obj-multi.h (obj_app_file): Likewise.
	* config/obj-elf.h (elf_file_symbol): Likewise.
	* config/obj-elf.c (elf_file_symbol): Only emit one file symbol
	if called for # preprocessor lines.
@
text
@a624 5
  if (type != SHT_NULL)
    elf_section_type (sec) = type;
  if (attr != 0)
    elf_section_flags (sec) = attr;

d645 3
d664 1
a664 1
  else if (attr != 0)
d666 18
a683 11
      /* If section attributes are specified the second time we see a
	 particular section, then check that they are the same as we
	 saw the first time.  */
      if (((old_sec->flags ^ flags)
	   & (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	      | SEC_EXCLUDE | SEC_SORT_ENTRIES | SEC_MERGE | SEC_STRINGS
	      | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
	      | SEC_THREAD_LOCAL)))
	as_warn (_("ignoring changed section attributes for %s"), name);
      if ((flags & SEC_MERGE) && old_sec->entsize != (unsigned) entsize)
	as_warn (_("ignoring changed section entity size for %s"), name);
@


1.86
log
@	* config/obj-elf.c (obj_elf_section_type): Handle init_array,
	fini_array and preinit_array section types.
	* config/tc-ia64.c (ia64_elf_section_type): Remove init_array
	and fini_array.
	* doc/as.texinfo: Document extra section types.
@
text
@d239 1
a239 1
elf_file_symbol (const char *s)
d241 6
a246 1
  symbolS *sym;
d248 3
a250 3
  sym = symbol_new (s, absolute_section, 0, NULL);
  symbol_set_frag (sym, &zero_address_frag);
  symbol_get_bfdsym (sym)->flags |= BSF_FILE;
d252 4
a255 4
  if (symbol_rootP != sym)
    {
      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_insert (sym, symbol_rootP, &symbol_rootP, &symbol_lastP);
d257 1
a257 1
      verify_symbol_chain (symbol_rootP, symbol_lastP);
d259 1
@


1.85
log
@	* config/obj-coff.c (coff_adjust_section_syms): Use
	bfd_get_section_size instead of bfd_get_section_size_before_reloc.
	(coff_frob_section): Likewise.
	* config/tc-mips.c (md_apply_fix3): Likewise.
	* config/obj-elf.c (elf_frob_file): Use bfd_set_section_size.
	(elf_frob_file_after_relocs): Likewise.
@
text
@d774 6
@


1.84
log
@2004-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (obj_elf_change_section): Allow the
	".note.GNU-stack" section has SHF_EXECINSTR.
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d1890 1
d1931 3
a1933 2
      s->_raw_size = 4 * (list.elt_count[i] + 1);
      s->contents = frag_more (s->_raw_size);
d2042 2
a2043 1
      sec->_raw_size = bfd_ecoff_debug_size (stdoutput, &debug, debug_swap);
@


1.83
log
@bfd/

2004-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_get_section_by_name_if): New.
	* bfd-in2.h: Regenerated.

gas/

2004-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (get_section): Return bfd_boolean.
	(obj_elf_change_section): Call bfd_get_section_by_name_if
	instead of bfd_map_over_sections.
@
text
@d603 4
@


1.82
log
@gas/

2004-04-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (get_section): New function.
	(obj_elf_change_section): Support multiple sections with same
	name.

gas/testsuite/

2004-04-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/elf/elf.exp: Remove group1, add group1a and group1b for
	section group.

	* gas/elf/group1a.d: New file.
	* gas/elf/group1b.d: Likewise.

	* gas/elf/group1.e: Removed.
@
text
@d472 1
a472 8
struct section_group
{
  const char *name;
  const char *group_name;
  asection *section;
};

static void
d475 1
a475 1
  struct section_group *group = inf;
d478 1
a478 9
  /* Check if we have found the section we are looking for.  */
  if (group->section)
    return;

  if ((sec->name == group->name
       || (sec->name != NULL
	   && group->name != NULL
	   && strcmp (sec->name, group->name) == 0))
      && (group_name == group->group_name
d480 2
a481 3
	      && group->group_name != NULL
	      && strcmp (group_name, group->group_name) == 0)))
    group->section = sec;
d511 1
a514 1
  struct section_group group;
d535 3
a537 6
  group.name = name;
  group.group_name = group_name;
  group.section = NULL;
  bfd_map_over_sections (stdoutput, get_section, &group);

  if (group.section)
d539 1
a539 1
      sec = group.section;
d555 1
a555 1
	  if (group.section == NULL
d579 1
a579 1
      if (group.section == NULL && (attr & ~ssect->attr) != 0)
d611 1
a611 1
      if (!override && group.section == NULL)
d636 1
a636 1
  if (group.section == NULL)
d661 1
a661 1
      if (((group.section->flags ^ flags)
d667 1
a667 2
      if ((flags & SEC_MERGE)
	  && group.section->entsize != (unsigned) entsize)
@


1.81
log
@binutils/

2004-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (do_section_groups): New.
	(options): Add --section-groups/-g.
	(usage): Mention --section-groups/-g.
	(parse_args): Support --section-groups/-g.
	(get_group_flags): New.
	(process_section_groups): New.
	(process_object): Call process_section_groups.

gas/

2004-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (obj_elf_change_section): Check if the old
	group name is NULL before comparison.

gas/testsuite/

2004-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/elf/elf.exp: Add group0a, group0b and group1 for section
	group.

	* gas/elf/group0.s: New file.
	* gas/elf/group0a.d: Likewise.
	* gas/elf/group0b.d: Likewise.
	* gas/elf/group1.e: Likewise.
	* gas/elf/group1.s: Likewise.
@
text
@d472 28
a526 1
  asection *old_sec;
d530 1
d551 13
a563 2
  old_sec = bfd_get_section_by_name (stdoutput, name);
  sec = subseg_new (name, 0);
d574 1
a574 1
	  if (old_sec == NULL
d598 1
a598 1
      if (old_sec == NULL && (attr & ~ssect->attr) != 0)
d624 3
a626 2
	      as_warn (_("setting incorrect section attributes for %s"),
		       name);
d630 1
a630 1
      if (!override && old_sec == NULL)
d652 4
a655 1
  if (old_sec == NULL)
a662 2
      if (linkonce)
	flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
d680 1
a680 1
      if (((old_sec->flags ^ flags)
d686 2
a687 1
      if ((flags & SEC_MERGE) && old_sec->entsize != (unsigned) entsize)
a688 4
      if ((attr & SHF_GROUP) != 0
	  && (elf_group_name (old_sec) == NULL
	      || strcmp (elf_group_name (old_sec), group_name) != 0))
	as_warn (_("ignoring new section group for %s"), name);
@


1.80
log
@	* read.c (read_a_source_file): Use demand_empty_rest_of_line.
	(demand_empty_rest_of_line): Issue an error here.
	(ignore_rest_of_line): Silently skip to end.
	(demand_copy_string): Issue an error, not warning.
	(equals): Likewise.
	* config/obj-elf.c (obj_elf_section_name): Likewise.
	(obj_elf_section): Likewise.
	* config/tc-arc.c (arc_extoper): Remove bogus NULL checks.
	(arc_extinst): Likewise.
	* config/tc-ia64.c (dot_saveb): Use demand_empty_rest_of_line.
	(dot_spill): Likewise.
	(dot_unwabi): Likewise.
	(dot_prologue): Likewise.
@
text
@d648 2
a649 1
	  && strcmp (elf_group_name (old_sec), group_name) != 0)
@


1.79
log
@	* config/obj-elf.c: Convert to C90, remove unneeded prototypes and
	casts.  Formatting.
	* config/obj-elf.h: Remove PARAMS.
@
text
@d790 1
a790 1
	  as_warn (_("missing name"));
d941 1
a941 1
		  as_warn (_("character following name is not '#'"));
@


1.79.6.1
log
@Merge to 2.15 branch.
@
text
@d790 1
a790 1
	  as_bad (_("missing name"));
d941 1
a941 1
		  as_bad (_("character following name is not '#'"));
@


1.78
log
@	* read.c (s_lcomm_internal): Make global.
	* read.h (s_lcomm_internal): Declare.
	* config/obj-elf.c (elf_pseudo_table): Handle lcomm.
	(obj_elf_lcomm): New function.
@
text
@d56 11
a66 32
static bfd_vma elf_s_get_size PARAMS ((symbolS *));
static void elf_s_set_size PARAMS ((symbolS *, bfd_vma));
static bfd_vma elf_s_get_align PARAMS ((symbolS *));
static void elf_s_set_align PARAMS ((symbolS *, bfd_vma));
static void elf_s_set_other PARAMS ((symbolS *, int));
static int elf_sec_sym_ok_for_reloc PARAMS ((asection *));
static void adjust_stab_sections PARAMS ((bfd *, asection *, PTR));
static void build_group_lists PARAMS ((bfd *, asection *, PTR));
static int elf_separate_stab_sections PARAMS ((void));
static void elf_init_stab_section PARAMS ((segT));

#ifdef NEED_ECOFF_DEBUG
static bfd_boolean elf_get_extr PARAMS ((asymbol *, EXTR *));
static void elf_set_index PARAMS ((asymbol *, bfd_size_type));
#endif

static void obj_elf_line PARAMS ((int));
void obj_elf_version PARAMS ((int));
static void obj_elf_size PARAMS ((int));
static void obj_elf_type PARAMS ((int));
static void obj_elf_ident PARAMS ((int));
static void obj_elf_weak PARAMS ((int));
static void obj_elf_local PARAMS ((int));
static void obj_elf_visibility PARAMS ((int));
static int obj_elf_parse_section_letters PARAMS ((char *, size_t));
static int obj_elf_section_word PARAMS ((char *, size_t));
static char *obj_elf_section_name PARAMS ((void));
static int obj_elf_section_type PARAMS ((char *, size_t));
static void obj_elf_symver PARAMS ((int));
static void obj_elf_subsection PARAMS ((int));
static void obj_elf_popsection PARAMS ((int));
static void obj_elf_tls_common PARAMS ((int));
d103 2
a104 2
  {"vtable_inherit", (void (*) PARAMS ((int))) &obj_elf_vtable_inherit, 0},
  {"vtable_entry", (void (*) PARAMS ((int))) &obj_elf_vtable_entry, 0},
d111 1
a111 1
  { "file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
d175 1
a175 1
elf_begin ()
d177 2
d180 6
a185 6
  symbol_table_insert (section_symbol (bfd_get_section_by_name (stdoutput,
								TEXT_SECTION_NAME)));
  symbol_table_insert (section_symbol (bfd_get_section_by_name (stdoutput,
								DATA_SECTION_NAME)));
  symbol_table_insert (section_symbol (bfd_get_section_by_name (stdoutput,
								BSS_SECTION_NAME)));
d189 1
a189 1
elf_pop_insert ()
d197 1
a197 2
elf_s_get_size (sym)
     symbolS *sym;
d203 1
a203 3
elf_s_set_size (sym, sz)
     symbolS *sym;
     bfd_vma sz;
d209 1
a209 2
elf_s_get_align (sym)
     symbolS *sym;
d215 1
a215 3
elf_s_set_align (sym, align)
     symbolS *sym;
     bfd_vma align;
d221 1
a221 2
elf_s_get_other (sym)
     symbolS *sym;
d227 1
a227 3
elf_s_set_other (sym, other)
     symbolS *sym;
     int other;
d233 1
a233 2
elf_sec_sym_ok_for_reloc (sec)
     asection *sec;
d239 1
a239 2
elf_file_symbol (s)
     const char *s;
d243 1
a243 1
  sym = symbol_new (s, absolute_section, (valueT) 0, (struct frag *) 0);
d337 1
a337 2
obj_elf_common (is_common)
     int is_common;
d346 1
a346 2
obj_elf_tls_common (ignore)
     int ignore ATTRIBUTE_UNUSED;
d364 1
a364 2
obj_elf_local (ignore)
     int ignore ATTRIBUTE_UNUSED;
d392 1
a392 2
obj_elf_weak (ignore)
     int ignore ATTRIBUTE_UNUSED;
d420 1
a420 2
obj_elf_visibility (visibility)
     int visibility;
d491 7
a497 8
obj_elf_change_section (name, type, attr, entsize, group_name, linkonce, push)
     const char *name;
     int type;
     int attr;
     int entsize;
     const char *group_name;
     int linkonce;
     int push;
d658 1
a658 3
obj_elf_parse_section_letters (str, len)
     char *str;
     size_t len;
d719 1
a719 3
obj_elf_section_word (str, len)
     char *str;
     size_t len;
d743 1
a743 3
obj_elf_section_type (str, len)
     char *str;
     size_t len;
d766 1
a766 1
obj_elf_section_name ()
d808 1
a808 2
obj_elf_section (push)
     int push;
d966 1
a966 2
obj_elf_data (i)
     int i;
d984 1
a984 2
obj_elf_text (i)
     int i;
d1000 1
a1000 2
obj_elf_subsection (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1024 1
a1024 1
obj_elf_section_change_hook ()
d1031 1
a1031 2
obj_elf_previous (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1058 1
a1058 2
obj_elf_popsection (xxx)
     int xxx ATTRIBUTE_UNUSED;
d1084 1
a1084 2
obj_elf_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1088 1
a1088 1
  new_logical_line ((char *) NULL, (int) (get_absolute_expression ()));
d1099 1
a1099 2
obj_elf_symver (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1169 1
a1169 2
obj_elf_vtable_inherit (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1240 1
a1240 2
obj_elf_vtable_entry (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1276 1
a1276 1
elf_obj_read_begin_hook ()
d1285 1
a1285 2
elf_obj_symbol_new_hook (symbolP)
     symbolS *symbolP;
d1304 1
a1304 2
elf_copy_symbol_attributes (dest, src)
     symbolS *dest, *src;
d1311 1
a1311 2
	destelf->size =
	  (expressionS *) xmalloc (sizeof (expressionS));
d1327 1
a1327 2
obj_elf_version (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1336 1
a1336 1
  asection *note_secp = (asection *) NULL;
d1367 1
a1367 1
      md_number_to_chars (p, (valueT) i_note.namesz, sizeof (e_note.namesz));
d1369 1
a1369 1
      md_number_to_chars (p, (valueT) i_note.descsz, sizeof (e_note.descsz));
d1371 1
a1371 1
      md_number_to_chars (p, (valueT) i_note.type, sizeof (e_note.type));
d1387 1
a1387 2
obj_elf_size (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1428 1
a1428 2
      symbol_get_obj (sym)->size =
	(expressionS *) xmalloc (sizeof (expressionS));
d1450 1
a1450 2
obj_elf_type (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1510 1
a1510 2
obj_elf_ident (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1540 1
a1540 2
obj_elf_init_stab_section (seg)
     segT seg;
d1555 2
a1556 2
  as_where (&file, (unsigned int *) NULL);
  stabstr_name = (char *) xmalloc (strlen (segment_name (seg)) + 4);
d1570 1
a1570 4
adjust_stab_sections (abfd, sec, xxx)
     bfd *abfd;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d1582 1
a1582 1
  name = (char *) alloca (strlen (sec->name) + 4);
d1595 2
a1596 2
  bfd_h_put_16 (abfd, (bfd_vma) nsyms, (bfd_byte *) p + 6);
  bfd_h_put_32 (abfd, (bfd_vma) strsz, (bfd_byte *) p + 8);
d1608 1
a1608 3
elf_ecoff_set_ext (sym, ext)
     symbolS *sym;
     struct ecoff_extr *ext;
d1610 1
a1610 1
  symbol_get_bfdsym (sym)->udata.p = (PTR) ext;
d1618 1
a1618 3
elf_get_extr (sym, ext)
     asymbol *sym;
     EXTR *ext;
d1630 2
a1631 3
elf_set_index (sym, indx)
     asymbol *sym ATTRIBUTE_UNUSED;
     bfd_size_type indx ATTRIBUTE_UNUSED;
d1638 1
a1638 3
elf_frob_symbol (symp, puntp)
     symbolS *symp;
     int *puntp;
d1705 1
a1705 1
	  if (p [1] == ELF_VER_CHR && p [2] == ELF_VER_CHR)
d1712 1
a1712 1
	      memmove (&p [2], &p[3], l);
d1804 1
a1804 4
build_group_lists (abfd, sec, inf)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR inf;
d1806 1
a1806 1
  struct group_list *list = (struct group_list *) inf;
d1842 1
a1842 1
elf_frob_file ()
d1847 1
a1847 1
  bfd_map_over_sections (stdoutput, adjust_stab_sections, (PTR) 0);
d1853 1
a1853 1
  bfd_map_over_sections (stdoutput, build_group_lists, (PTR) &list);
d1920 1
a1920 1
elf_frob_file_before_adjust ()
d1940 1
a1940 1
		if (p [1] == ELF_VER_CHR && p [2] == ELF_VER_CHR)
d1943 1
a1943 1
		    memmove (&p [1], &p[3], l);
d1967 1
a1967 1
elf_frob_file_after_relocs ()
d1980 1
a1980 1
      know (debug_swap != (const struct ecoff_debug_swap *) NULL);
d1988 4
a1991 4
      SET (external_dnr, cbDnOffset, PTR);
      SET (external_pdr, cbPdOffset, PTR);
      SET (external_sym, cbSymOffset, PTR);
      SET (external_opt, cbOptOffset, PTR);
d1994 2
a1995 2
      SET (external_fdr, cbFdOffset, PTR);
      SET (external_rfd, cbRfdOffset, PTR);
d2023 1
a2023 2
      if (! bfd_set_section_contents (stdoutput, sec, (PTR) buf,
				      (file_ptr) 0, (bfd_size_type) 0))
d2069 1
a2069 1
sco_id ()
d2080 1
a2080 1
  asection *note_secp = (asection *) NULL;
d2097 1
a2097 1
  md_number_to_chars (p, (valueT) i_note.namesz, 4);
d2100 1
a2100 1
  md_number_to_chars (p, (valueT) i_note.descsz, 4);
d2103 1
a2103 1
  md_number_to_chars (p, (valueT) i_note.type, 4);
d2136 1
a2136 1
elf_separate_stab_sections ()
d2146 1
a2146 2
elf_init_stab_section (seg)
     segT seg;
@


1.77
log
@	* read.c: Remove unneeded prototypes.
	(s_comm): Split out code to..
	(s_comm_internal): ..here.  Tidy error returns.  Rearrange so that
	"name" from input line may be used in more places.  Merge code
	testing for valid size from elf_common.  Merge code from
	s_lcomm_internal.  Call comm_parse_extra.
	(bss_alloc): New function, split out of s_lcomm_internal and
	elf_common.
	(parse_align): Likewise.
	(s_lcomm_internal): Rewrite.
	(s_lcomm, s_lcomm_bytes): Use s_comm_internal.
	* read.h (bss_alloc, parse_align, s_comm_internal): Declare.
	* config/obj-elf.c (elf_common): Split out code to..
	(elf_common_parse): ..here.  Remove code common to s_comm_internal,
	parse_align and bss_alloc.  Rearrange and Tidy.
	* config/tc-alpha.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Define.
@
text
@d88 1
d95 1
d387 9
d654 1
a654 1
        seg_info (sec)->bss = 1;
d668 1
a668 1
        symbol_table_insert (section_symbol (sec));
d1752 3
a1754 3
         If this is an external reference, just rename the symbol to
         include the version string.  This will make the relocs be
         against the correct versioned symbol.
d1764 2
a1765 2
             reserved for definitions of the default version to link
             against.  */
d2094 3
a2096 3
         eventually become a call to fwrite, and ISO C prohibits
         passing a NULL pointer to a stdio function even if the
         pointer will not be used.  */
d2135 1
a2135 1
                           don't know enough about the source
@


1.76
log
@	* config/obj-elf.c: Remove ARGSUSED.
@
text
@a65 1
static symbolS *elf_common PARAMS ((int));
d289 3
d293 1
a293 2
elf_common (is_common)
     int is_common;
d295 2
a296 7
  char *name;
  char c;
  char *p;
  offsetT temp, size, sign;
  symbolS *symbolP;
  int have_align;
  expressionS exp;
d298 1
a298 1
  if (flag_mri && is_common)
d300 1
a300 3
      s_mri_common (0);
      return NULL;
    }
a301 46
  name = input_line_pointer;
  c = get_symbol_end ();
  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after symbol-name"));
      ignore_rest_of_line ();
      return NULL;
    }
  input_line_pointer++;		/* skip ',' */
  temp = get_absolute_expr (&exp);
  sign = (offsetT) 1 << (stdoutput->arch_info->bits_per_address - 1);
  size = temp & ((sign << 1) - 1);
  if (temp != size || !exp.X_unsigned)
    {
      as_bad (_(".COMMon length (%ld) out of range, ignored."), (long) temp);
      ignore_rest_of_line ();
      return NULL;
    }
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));
      ignore_rest_of_line ();
      return NULL;
    }
  if (S_GET_VALUE (symbolP) != 0)
    {
      if (S_GET_VALUE (symbolP) != (valueT) size)
	{
	  as_warn (_("length of .comm \"%s\" is already %ld; not changed to %ld"),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP),
		   (long) size);
	}
    }
  know (symbolP->sy_frag == &zero_address_frag);
  if (*input_line_pointer != ',')
    have_align = 0;
  else
    {
      have_align = 1;
d304 2
a305 6
    }
  if (! have_align || *input_line_pointer != '"')
    {
      if (! have_align)
	temp = 0;
      else
d307 11
a317 2
	  temp = get_absolute_expr (&exp);
	  if (!exp.X_unsigned)
d319 14
a332 2
	      temp = 0;
	      as_warn (_("common alignment negative; 0 assumed"));
d334 2
a335 38
	}
      if (symbol_get_obj (symbolP)->local)
	{
	  segT old_sec;
	  int old_subsec;
	  char *pfrag;
	  int align;

	/* allocate_bss: */
	  old_sec = now_seg;
	  old_subsec = now_subseg;
	  if (temp)
	    {
	      /* convert to a power of 2 alignment */
	      for (align = 0; (temp & 1) == 0; temp >>= 1, ++align);
	      if (temp != 1)
		{
		  as_bad (_("common alignment not a power of 2"));
		  ignore_rest_of_line ();
		  return NULL;
		}
	    }
	  else
	    align = 0;
	  record_alignment (bss_section, align);
	  subseg_set (bss_section, 0);
	  if (align)
	    frag_align (align, 0, 0);
	  if (S_GET_SEGMENT (symbolP) == bss_section)
	    symbol_get_frag (symbolP)->fr_symbol = 0;
	  symbol_set_frag (symbolP, frag_now);
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			    (offsetT) size, (char *) 0);
	  *pfrag = 0;
	  S_SET_SIZE (symbolP, size);
	  S_SET_SEGMENT (symbolP, bss_section);
	  S_CLEAR_EXTERNAL (symbolP);
	  subseg_set (old_sec, old_subsec);
d339 4
a342 5
	allocate_common:
	  S_SET_VALUE (symbolP, (valueT) size);
	  S_SET_ALIGN (symbolP, temp);
	  S_SET_EXTERNAL (symbolP);
	  S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
d345 6
d353 4
a356 16
      input_line_pointer++;
      /* @@@@ Some use the dot, some don't.  Can we get some consistency??  */
      if (*input_line_pointer == '.')
	input_line_pointer++;
      /* @@@@ Some say data, some say bss.  */
      if (strncmp (input_line_pointer, "bss\"", 4)
	  && strncmp (input_line_pointer, "data\"", 5))
	{
	  while (*--input_line_pointer != '"')
	    ;
	  input_line_pointer--;
	  goto bad_common_segment;
	}
      while (*input_line_pointer++ != '"')
	;
      goto allocate_common;
a360 1
  demand_empty_rest_of_line ();
a361 14

  {
  bad_common_segment:
    p = input_line_pointer;
    while (*p && *p != '\n')
      p++;
    c = *p;
    *p = '\0';
    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
    *p = c;
    input_line_pointer = p;
    ignore_rest_of_line ();
    return NULL;
  }
d368 4
a371 1
  elf_common (is_common);
d378 1
a378 1
  symbolS *symbolP = elf_common (0);
@


1.75
log
@	* config/obj-aout.h: Fix comment typos.
	* config/obj-bout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-elf.c: Likewise.
	* config/obj-ieee.c: Likewise.
	* config/obj-som.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/obj-vms.h: Likewise.
@
text
@a1775 1
/*ARGSUSED*/
@


1.74
log
@2003-10-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (obj_elf_change_section): Allow SHF_ALLOC
	for .interp, .strtab and .symtab. Use specified section
	attributes.
@
text
@d2195 1
a2195 1
/* Heavily plagarized from obj_elf_version.  The idea is to emit the
@


1.73
log
@	* config/obj-elf.c (obj_elf_change_section): Adjust for
	_bfd_elf_get_sec_type_attr changes.  Allow SHF_MERGE and SHF_STRINGS
	to be set when defaults are not.  Don't set attr from defaults if
	old_sec.
@
text
@d644 2
d674 1
a674 1
      if (old_sec == NULL && (attr &~ ssect->attr) != 0)
d687 4
a690 1
		   && (attr &~ ssect->attr &~ SHF_MERGE &~ SHF_STRINGS) == 0)
d692 6
d699 5
a703 2
	    as_warn (_("setting incorrect section attributes for %s"),
		     name);
d705 1
a705 1
      if (old_sec == NULL)
@


1.72
log
@	* config/obj-elf.c (obj_elf_change_section): Allow "x" for .note*.
@
text
@d617 1
a617 2
  int def_type;
  int def_attr;
d640 1
d642 1
a642 2
  if (_bfd_elf_get_sec_type_attr (stdoutput, name, &def_type,
				  &def_attr))
d645 2
a646 2
	type = def_type;
      else if (type != def_type)
d655 3
a657 3
	      && def_type != SHT_INIT_ARRAY
	      && def_type != SHT_FINI_ARRAY
	      && def_type != SHT_PREINIT_ARRAY)
d660 1
a660 1
	      if (def_type != SHT_NOTE)
d668 1
a668 1
	      type = def_type;
d672 1
a672 1
      if (old_sec == NULL && (attr &~ def_attr) != 0)
d675 1
a675 1
	     allocatable.  If the linker sees an allocateable .note
d678 10
a687 2
	  if (!(def_type == SHT_NOTE
		&& (attr == SHF_ALLOC || attr == SHF_EXECINSTR)))
d691 2
a692 1
      attr |= def_attr;
@


1.71
log
@gas/

2003-07-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (obj_elf_section_type): Also accept "note".

gas/testsuite/

2003-07-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/elf/elf.exp: Add section3 for note section.

	* gas/elf/section3.d: New file.
	* gas/elf/section3.s: Likewise.
@
text
@d678 3
a680 2
	     file.  */
	  if (strcmp (name, ".note") != 0 || attr != SHF_ALLOC)
@


1.70
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_new_section_hook): Set the default section
	type to SHT_NULL.
	(elf_fake_sections): Set the section type based on asect->flags
	if it is SHT_NULL. Don't abort on processor specific section
	types.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (obj_elf_change_section): Update
	elf_section_type and elf_section_flags only when they are
	specified.
@
text
@d847 2
@


1.69
log
@2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (obj_elf_change_section): Always set section
	type and flags.
@
text
@d686 4
a689 2
  elf_section_type (sec) = type;
  elf_section_flags (sec) = attr;
@


1.68
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d684 1
d686 2
a687 3
      elf_section_type (sec) = type;
      elf_section_flags (sec) = attr;
    }
@


1.67
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@a603 57
/* Certain named sections have particular defined types, listed on p.
   4-19 of the ABI.  */
struct special_section
{
  const char *name;
  int type;
  int attributes;
};

static struct special_section const special_sections[] =
{
  { ".bss",	SHT_NOBITS,	SHF_ALLOC + SHF_WRITE		},
  { ".comment",	SHT_PROGBITS,	0				},
  { ".data",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
  { ".data1",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
  { ".debug",	SHT_PROGBITS,	0				},
#if defined (TC_HPPA) && !defined (TE_LINUX) && TARGET_ARCH_SIZE == 64
  { ".fini",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
  { ".init",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
#else
  { ".fini",	SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR	},
  { ".init",	SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR	},
#endif
  { ".line",	SHT_PROGBITS,	0				},
  { ".note",	SHT_NOTE,	0				},
  { ".rodata",	SHT_PROGBITS,	SHF_ALLOC			},
  { ".rodata1",	SHT_PROGBITS,	SHF_ALLOC			},
  { ".tbss",	SHT_NOBITS,	SHF_ALLOC + SHF_WRITE + SHF_TLS	},
  { ".tdata",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_TLS	},
  { ".text",	SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR	},
  { ".init_array",SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE         },
  { ".fini_array",SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE         },
  { ".preinit_array",SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE   },

#ifdef ELF_TC_SPECIAL_SECTIONS
  ELF_TC_SPECIAL_SECTIONS
#endif

#if 0
  /* The following section names are special, but they can not
     reasonably appear in assembler code.  Some of the attributes are
     processor dependent.  */
  { ".dynamic",	SHT_DYNAMIC,	SHF_ALLOC /* + SHF_WRITE */ 	},
  { ".dynstr",	SHT_STRTAB,	SHF_ALLOC			},
  { ".dynsym",	SHT_DYNSYM,	SHF_ALLOC			},
  { ".got",	SHT_PROGBITS,	0				},
  { ".hash",	SHT_HASH,	SHF_ALLOC			},
  { ".interp",	SHT_PROGBITS,	/* SHF_ALLOC */			},
  { ".plt",	SHT_PROGBITS,	0				},
  { ".shstrtab",SHT_STRTAB,	0				},
  { ".strtab",	SHT_STRTAB,	/* SHF_ALLOC */			},
  { ".symtab",	SHT_SYMTAB,	/* SHF_ALLOC */			},
#endif

  { NULL,	0,		0				}
};

d617 2
a618 1
  int i;
d642 9
a650 10
  /* See if this is one of the special sections.  */
  for (i = 0; special_sections[i].name != NULL; i++)
    if (strcmp (name, special_sections[i].name) == 0)
      {
	if (type == SHT_NULL)
	  type = special_sections[i].type;
	else if (type != special_sections[i].type)
	  {
	    if (old_sec == NULL
		/* FIXME: gcc, as of 2002-10-22, will emit
d652 1
a652 1
		   .section .init_array,"aw",@@progbits
d654 14
a667 24
		   for __attribute__ ((section (".init_array"))).
		   "@@progbits" is incorrect.  */
		&& special_sections[i].type != SHT_INIT_ARRAY
		&& special_sections[i].type != SHT_FINI_ARRAY
		&& special_sections[i].type != SHT_PREINIT_ARRAY)
	      {
		as_warn (_("setting incorrect section type for %s"), name);
	      }
	    else
	      {
		as_warn (_("ignoring incorrect section type for %s"), name);
		type = special_sections[i].type;
	      }
	  }
	if ((attr &~ special_sections[i].attributes) != 0
	    && old_sec == NULL)
	  {
	    /* As a GNU extension, we permit a .note section to be
	       allocatable.  If the linker sees an allocateable .note
	       section, it will create a PT_NOTE segment in the output
	       file.  */
	    if (strcmp (name, ".note") != 0
		|| attr != SHF_ALLOC)
	      as_warn (_("setting incorrect section attributes for %s"),
d669 19
a687 4
	  }
	attr |= special_sections[i].attributes;
	break;
      }
d2027 1
@


1.66
log
@gas/

2003-05-03  H.J. Lu <hjl@@gnu.org>

	* config/obj-elf.c (obj_elf_parse_section_letters): Make it a
	fatal error for unknown section attribute.

	* config/tc-alpha.c (alpha_elf_section_letter): Return -1 for
	unknown section attribute.
	* config/tc-ia64.c (ia64_elf_section_letter): Likewise.
	* config/tc-ppc.c (ppc_section_letter): Likewise.

	* config/tc-ia64.c (ia64_elf_section_letter): Handle 'o'.
	(ia64_elf_section_type): Accept "unwind".

gas/testsuite/

2003-05-03  H.J. Lu <hjl@@gnu.org>

	* gas/ia64/ia64.exp: Add unwind.

	* gas/ia64/unwind.s: New. Test the new section attribute 'o'
	and the new section type "unwind".
	* gas/ia64/unwind.d: Likewise.
@
text
@d28 1
d130 3
@


1.65
log
@2003-05-01  H.J. Lu <hjl@@gnu.org>

	* config/obj-elf.c (obj_elf_type): Accept "notype" and
	"STT_NOTYPE".
@
text
@d848 1
a848 4
	      {
		as_warn ("%s", bad_msg);
		attr = -1;
	      }
@


1.64
log
@gas/

2003-05-01  H.J. Lu <hjl@@gnu.org>

	* config/tc-ia64.h (tc_canonicalize_section_name): New.

	* config/obj-elf.c (obj_elf_section_name): Call
	tc_canonicalize_section_name if it is defined.

gas/testsuite/

2003-05-01  H.J. Lu <hjl@@gnu.org>

	* gas/ia64/ia64.exp: Add secname.

	* gas/ia64/secname.s: New. Test the trailing '#' in section
	name.
	* gas/ia64/secname.d: Likewise.
@
text
@d1651 3
@


1.63
log
@Fix problem parsing symbol version strings when they are preceeded by whitespace.
Add test to catch this problem in the future.
@
text
@d943 3
@


1.62
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d1272 1
@


1.62.2.1
log
@Skip whitespace before a symbol version string.
Add a test for this bug.
@
text
@a1271 1
  SKIP_WHITESPACE ();
@


1.61
log
@bfd/
	* elf32-sparc.c (_bfd_sparc_elf_howto_table): Add TLS relocs.
	(elf32_sparc_rev32_howto): New variable.
	(sparc_reloc_map): Add TLS relocs.
	(elf32_sparc_reloc_type_lookup, elf32_sparc_info_to_howto):
	Handle REV32.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc, elf32_sparc_mkobject):
	New functions.
	(struct elf32_sparc_dyn_relocs, struct elf32_sparc_link_hash_entry,
	struct elf32_sparc_link_hash_table):
	New structures.
	(elf32_sparc_tdata, elf32_sparc_local_got_tls_type,
	elf32_sparc_hash_table): Define.
	(link_hash_newfunc, elf32_sparc_link_hash_table_create,
	create_got_section, elf32_sparc_create_dynamic_sections,
	elf32_sparc_copy_indirect_symbol, elf32_sparc_tls_transition): New
	functions.
	(elf32_sparc_check_relocs): Handle TLS relocs.  Add dynamic reloc
	reference counting.
	(elf32_sparc_gc_sweep_hook): Likewise.
	(elf32_sparc_adjust_dynamic_symbol): Likewise.
	(elf32_sparc_size_dynamic_sections): Likewise.
	(elf32_sparc_relocate_section): Likewise.
	(allocate_dynrelocs, readonly_dynrelocs, dtpoff_base, tpoff):
	New functions.
	(elf32_sparc_object_p): Allocate backend private object data.
	(bfd_elf32_bfd_link_hash_table_create,
	elf_backend_copy_indirect_symbol, bfd_elf32_mkobject,
	elf_backend_can_refcount): Define.
	(elf_backend_create_dynamic_sections): Define to
	elf32_sparc_create_dynamic_sections.
	* reloc.c: Add SPARC TLS relocs.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf64-sparc.c (sparc64_elf_howto_table): Add TLS relocs.
	(sparc_reloc_map): Likewise.
gas/
	* config/tc-sparc.c (sparc_ip): Handle TLS % operators.
	(tc_gen_reloc): Handle TLS relocs.
	(sparc_cons, cons_fix_new_sparc): Handle %r_tls_dtpoff.
	* config/tc-sparc.h (tc_fix_adjustable): Don't adjust TLS
	relocs.
	* config/obj-elf.c (obj_elf_section_word): Handle tls.
	(obj_elf_type): Handle tls_object.
include/
	* elf/sparc.h: Add TLS relocs.  Move R_SPARC_REV32 to 252.
ld/testsuite/
	* ld-sparc/sparc.exp: New.
	* ld-sparc/tlsg32.s: New test.
	* ld-sparc/tlsg32.sd: Likewise.
	* ld-sparc/tlsg64.s: Likewise.
	* ld-sparc/tlsg64.sd: Likewise.
	* ld-sparc/tlslib.s: Likewise.
	* ld-sparc/tlsnopic.s: Likewise.
	* ld-sparc/tlspic.s: Likewise.
	* ld-sparc/tlssunbin32.dd: Likewise.
	* ld-sparc/tlssunbin32.rd: Likewise.
	* ld-sparc/tlssunbin32.s: Likewise.
	* ld-sparc/tlssunbin32.sd: Likewise.
	* ld-sparc/tlssunbin32.td: Likewise.
	* ld-sparc/tlssunbin64.dd: Likewise.
	* ld-sparc/tlssunbin64.rd: Likewise.
	* ld-sparc/tlssunbin64.s: Likewise.
	* ld-sparc/tlssunbin64.sd: Likewise.
	* ld-sparc/tlssunbin64.td: Likewise.
	* ld-sparc/tlssunbinpic32.s: Likewise.
	* ld-sparc/tlssunbinpic64.s: Likewise.
	* ld-sparc/tlssunnopic32.dd: Likewise.
	* ld-sparc/tlssunnopic32.rd: Likewise.
	* ld-sparc/tlssunnopic32.s: Likewise.
	* ld-sparc/tlssunnopic32.sd: Likewise.
	* ld-sparc/tlssunnopic64.dd: Likewise.
	* ld-sparc/tlssunnopic64.rd: Likewise.
	* ld-sparc/tlssunnopic64.s: Likewise.
	* ld-sparc/tlssunnopic64.sd: Likewise.
	* ld-sparc/tlssunpic32.dd: Likewise.
	* ld-sparc/tlssunpic32.rd: Likewise.
	* ld-sparc/tlssunpic32.s: Likewise.
	* ld-sparc/tlssunpic32.sd: Likewise.
	* ld-sparc/tlssunpic32.td: Likewise.
	* ld-sparc/tlssunpic64.dd: Likewise.
	* ld-sparc/tlssunpic64.rd: Likewise.
	* ld-sparc/tlssunpic64.s: Likewise.
	* ld-sparc/tlssunpic64.sd: Likewise.
	* ld-sparc/tlssunpic64.td: Likewise.
@
text
@d758 2
a763 1
      elf_linkonce_p (sec) = linkonce;
d780 2
a781 2
	      | SEC_THREAD_LOCAL))
	  || linkonce != elf_linkonce_p (sec))
d2041 1
a2041 1
	if (elf_linkonce_p (s) != ((flags & SEC_LINK_ONCE) != 0))
@


1.60
log
@	* read.c (get_absolute_expr): New, split out from..
	(get_absolute_expression): ..here.
	* read.h (get_absolute_expr): Declare.
	* config/obj-elf.c (elf_common): Use offsetT for "temp" and "size".
	Trim size to arch bits_per_address, and test for negative input
	via get_absolute_expr.
@
text
@d871 2
d1643 3
@


1.59
log
@        * config/obj-elf.c (special_sections): Work around HP's incorrect usage
        of .init and .fini sections for array initializers and finalizers.
@
text
@d3 1
a3 1
   2001, 2002 Free Software Foundation, Inc.
d293 1
a293 1
  int temp, size;
d296 1
d317 4
a320 1
  if ((temp = get_absolute_expression ()) < 0)
d322 1
a322 1
      as_bad (_(".COMMon length (%d.) <0! Ignored."), temp);
a325 1
  size = temp;
d339 3
a341 2
	  as_warn (_("length of .comm \"%s\" is already %ld; not changed to %d"),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
d359 2
a360 2
	  temp = get_absolute_expression ();
	  if (temp < 0)
@


1.58
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d612 4
d618 1
@


1.57
log
@        * config/obj-elf.c (obj_elf_visibility): Overwrite only the
        visibility portion of st_other.
@
text
@d68 1
a68 1
static boolean elf_get_extr PARAMS ((asymbol *, EXTR *));
d1764 1
a1764 1
static boolean
d1770 1
a1770 1
    return false;
d1772 1
a1772 1
  return true;
d1852 1
a1852 1
	      *puntp = true;
d2158 1
a2158 1
      if (! bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, true,
d2166 1
a2166 1
      know (stdoutput->output_has_begun == false);
d2183 1
a2183 1
      know (stdoutput->output_has_begun == true);
@


1.56
log
@	* config/obj-elf.c (special_sections): Use correct types for init
	array sections.
	(obj_elf_change_section): Don't mess with init array section type.
@
text
@d548 2
a549 1
      elfsym->internal_elf_sym.st_other = visibility;
@


1.55
log
@	* config/obj-elf.c (obj_elf_change_section): Move prototype to
	obj-elf.h
	* config/obj-elf.h (obj_elf_change_section): Likewise.
@
text
@a619 13
#if 0
  /* FIXME: The current gcc, as of 2002-03-03, will emit

	.section .init_array,"aw",@@progbits

     for __attribute__ ((section (".init_array"))). "@@progbits" marks
     the incorrect section type. For now, we make them with
     SHT_PROGBITS. BFD will fix the section type. Gcc should be changed
     to emit

	.section .init_array

   */
a622 5
#else
  { ".init_array",SHT_PROGBITS, SHF_ALLOC + SHF_WRITE         },
  { ".fini_array",SHT_PROGBITS, SHF_ALLOC + SHF_WRITE         },
  { ".preinit_array",SHT_PROGBITS, SHF_ALLOC + SHF_WRITE   },
#endif
d692 10
a701 1
	    if (old_sec == NULL)
@


1.54
log
@gas reloc rewrite.
@
text
@a79 2
void obj_elf_change_section
  PARAMS ((const char *, int, int, int, const char *, int, int));
@


1.53
log
@	* config/obj-elf.c (obj_elf_change_section): Make non-static.
	config/tc-mips.c (s_change_section): New function to support
	IRIX .section pseudo-op.
@
text
@d2331 1
@


1.52
log
@	* symbols.c: Replace CONST by const throughout.
	(symbol_find_exact): Split out from..
	(symbol_find_base): ..here.
	* symbols.h: Replace CONST by const throughout.
	(symbol_find_exact): Declare.
	* config/obj-elf.c: #include "struc-symbol.h".
	(elf_frob_file): If group name matches an exported symbol, use that
	symbol for the signature and ".group" as the section name.
@
text
@d80 1
a80 1
static void obj_elf_change_section
d667 1
a667 1
static void
@


1.52.2.1
log
@        * config/obj-elf.c (obj_elf_visibility): Overwrite only the
        visibility portion of st_other.
@
text
@d550 1
a550 2
      elfsym->internal_elf_sym.st_other &= ~3;
      elfsym->internal_elf_sym.st_other |= visibility;
@


1.51
log
@	* config/obj-elf.c (obj_elf_change_section): Set and check elf
	linkonce flag.  Print all warnings.
	(obj_elf_section): Parse ",comdat" for groups.
	(elf_frob_file): Set SEC_LINK_ONCE on COMDAT groups.  Check
	consistency of comdat flag.
@
text
@d27 1
d2028 1
d2031 2
d2047 12
a2058 1
      s = subseg_force_new (group_name, 0);
d2069 2
@


1.50
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d80 1
a80 1
  PARAMS ((const char *, int, int, int, const char *, int));
d667 1
a667 1
obj_elf_change_section (name, type, attr, entsize, group_name, push)
d673 1
d762 1
d776 5
a780 4
      if ((old_sec->flags ^ flags)
	  & (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	     | SEC_EXCLUDE | SEC_SORT_ENTRIES | SEC_MERGE | SEC_STRINGS
	     | SEC_THREAD_LOCAL))
d782 1
a782 1
      else if ((flags & SEC_MERGE) && old_sec->entsize != (unsigned) entsize)
d784 2
a785 2
      else if ((attr & SHF_GROUP) != 0
	       && strcmp (elf_group_name (old_sec), group_name) != 0)
d953 1
d984 1
d1058 7
d1100 1
a1100 1
  obj_elf_change_section (name, type, attr, entsize, group_name, push);
d2030 13
a2043 1
      flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP;
@


1.49
log
@	* config/obj-coff.c: Fix formatting.
	* config/obj-elf.c: Likewise.
	* config/tc-alpha.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-hppa.c: Likewise.
@
text
@d64 1
d88 1
d135 2
d287 2
a288 2
void
obj_elf_common (is_common)
d301 1
a301 1
      return;
d314 1
a314 1
      return;
d321 1
a321 1
      return;
d331 1
a331 1
      return;
d381 1
a381 1
		  return;
d433 1
a433 1
  return;
d446 1
a446 1
    return;
d450 17
d618 2
d743 2
a744 1
	   | ((attr & SHF_STRINGS) ? SEC_STRINGS : 0));
d776 2
a777 1
	     | SEC_EXCLUDE | SEC_SORT_ENTRIES | SEC_MERGE | SEC_STRINGS))
d820 3
d837 1
a837 1
	    char *bad_msg = _("unrecognized .section attribute: want a,w,x,M,S,G");
@


1.48
log
@2002-03-04  H.J. Lu <hjl@@gnu.org>

	* config/obj-elf.c (special_section): Add .init_array,
	.fini_array and .preinit_array.

	* config/tc-ia64.h (ELF_TC_SPECIAL_SECTIONS): Remove
	.init_array and .fini_array.
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d611 1
a611 1
  { ".init_array",SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE         }, 
d613 1
a613 1
  { ".preinit_array",SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE   }, 
d615 1
a615 1
  { ".init_array",SHT_PROGBITS, SHF_ALLOC + SHF_WRITE         }, 
d617 1
a617 1
  { ".preinit_array",SHT_PROGBITS, SHF_ALLOC + SHF_WRITE   }, 
@


1.47
log
@	* config/obj-elf.c (elf_copy_symbol_attributes): Don't copy
	visibility.
	(obj_frob_symbol): Copy visibility.
@
text
@d598 21
@


1.46
log
@	* config/obj-elf.c (elf_frob_file_before_adjust): Remove symbols
	made because of .weak, if they are neither defined nor used in any
	way.
@
text
@d1411 3
a1413 1
  S_SET_OTHER (dest, S_GET_OTHER (src));
d1843 2
@


1.46.2.1
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.

	Merge from mainline.
	2002-03-12  Andreas Schwab  <schwab@@suse.de>
	* config/tc-ia64.c (fixup_unw_records): Clear region when seeing a
	body record so that an error is given for misplaced .save
	pseudo-ops.

	2002-03-09  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.h (REX_OPCODE): Define.
	(REX_MODE64, REX_EXTX, REX_EXTY, REX_EXTZ): Define.
	(rex_byte): typedef to int.
	* config/tc-i386.c: Group prototypes and vars together.
	Formatting fixes.  Remove occurrences of "register" keyword.
	(true): Delete.
	(false): Delete.
	(mode_from_disp_size): Add INLINE keyword to prototype.
	(fits_in_signed_byte): Likewise.
	(fits_in_unsigned_byte): Likewise.
	(fits_in_unsigned_word): Likewise.
	(fits_in_signed_word): Likewise.
	(fits_in_unsigned_long): Likewise.
	(fits_in_signed_long): Likewise.
	(type_names): Constify.
	(intel_float_operand): Constify param.
	(add_prefix): Use REX_OPCODE.
	(md_assemble): Likewise.  Modify for changed rex_byte.
	(parse_insn): Split out of md_assemble.
	(parse_operands): Likewise.
	(swap_operands): Likewise.
	(optimize_imm): Likewise.
	(optimize_disp): Likewise.
	(match_template): Likewise.
	(check_string): Likewise.
	(process_suffix): Likewise.
	(check_byte_reg): Likewise.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
	(finalize_imm): Likewise.
	(process_operands): Likewise.
	(build_modrm_byte): Likewise.
	(output_insn): Likewise.
	(output_branch): Likewise.
	(output_jump): Likewise.
	(output_interseg_jump): Likewise.
	(output_disp): Likewise.
	(output_imm): Likewise.

	2002-03-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_gen_reloc): Don't attempt to handle 8 byte
	relocs except when BFD64.
	* write.c (number_to_chars_bigendian): Don't abort when N is
	larger than sizeof (VAL).
	(number_to_chars_littleendian): Likewise.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* config/tc-hppa.c (md_apply_fix3): Add cast.
	(hppa_fix_adjustable): Adjust list of selectors using e_lrsel and
	e_rrsel.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* config/obj-elf.c (special_section): Add .init_array,
	.fini_array and .preinit_array.
	* config/tc-ia64.h (ELF_TC_SPECIAL_SECTIONS): Remove
	.init_array and .fini_array.

	2002-03-01  Jakub Jelinek  <jakub@@redhat.com>
	* config/obj-elf.c (elf_copy_symbol_attributes): Don't copy
	visibility.
	(obj_frob_symbol): Copy visibility.
@
text
@a597 21
#if 0
  /* FIXME: The current gcc, as of 2002-03-03, will emit

	.section .init_array,"aw",@@progbits

     for __attribute__ ((section (".init_array"))). "@@progbits" marks
     the incorrect section type. For now, we make them with
     SHT_PROGBITS. BFD will fix the section type. Gcc should be changed
     to emit

	.section .init_array

   */
  { ".init_array",SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE         }, 
  { ".fini_array",SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE         },
  { ".preinit_array",SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE   }, 
#else
  { ".init_array",SHT_PROGBITS, SHF_ALLOC + SHF_WRITE         }, 
  { ".fini_array",SHT_PROGBITS, SHF_ALLOC + SHF_WRITE         },
  { ".preinit_array",SHT_PROGBITS, SHF_ALLOC + SHF_WRITE   }, 
#endif
d1411 1
a1411 3
  /* Don't copy visibility.  */
  S_SET_OTHER (dest, (ELF_ST_VISIBILITY (S_GET_OTHER (dest))
		      | (S_GET_OTHER (src) & ~ELF_ST_VISIBILITY (-1))));
a1840 2

	      S_SET_OTHER (symp2, S_GET_OTHER (symp));
@


1.45
log
@	* config/obj-elf.c (obj_elf_init_stab_section): References are
	kept to section name strings.  Don't alloca them!
@
text
@d1998 1
a1998 1
	if (symbol_get_obj (symp)->versioned_name)
d2000 1
a2000 1
	    if (!S_IS_DEFINED (symp))
d2020 8
@


1.44
log
@	* config/obj-elf.c (obj_elf_version): Ensure terminating NUL is
	put in note section.  Use sizeof instead of hard-coded constants.
@
text
@d1644 1
a1644 1
  stabstr_name = (char *) alloca (strlen (segment_name (seg)) + 4);
@


1.43
log
@	* config/obj-elf.c: Make use of elf_group_name and elf_next_in_group
	throughout file.
	(obj_elf_change_section): Rename "group" to "group_name".
	(obj_elf_section): Likewise.
	(elf_frob_file): Don't use sec->lineno for SHT_GROUP section to store
	first member section; Instead use elf_next_in_group.
@
text
@a1419 1
  char ch;
d1426 1
a1426 1
  int i, len;
d1456 1
a1456 1
      md_number_to_chars (p, (valueT) i_note.namesz, 4);
d1458 1
a1458 1
      md_number_to_chars (p, (valueT) i_note.descsz, 4);
d1460 3
a1462 1
      md_number_to_chars (p, (valueT) i_note.type, 4);
a1463 7
      for (i = 0; i < len; i++)
	{
	  ch = *(name + i);
	  {
	    FRAG_APPEND_1_CHAR (ch);
	  }
	}
@


1.42
log
@	* config/obj-elf.c: (obj_elf_change_section): Add "group" param.
	Set elf_section_data group from it.  Warn if group name changed.
	(obj_elf_parse_section_letters): Parse 'G' too.
	(obj_elf_section): Parse group name.
	(struct group_list): New.
	(build_group_lists): New function.
	(elf_frob_file): Create SEC_GROUP section(s).

	* config/obj-elf.c: (elf_copy_symbol_attributes): Zap trailing
	whitespace.
@
text
@d623 1
a623 1
obj_elf_change_section (name, type, attr, entsize, group, push)
d628 1
a628 1
     const char *group;
d715 1
a715 1
      elf_section_data (sec)->group = group;
d736 1
a736 1
	       && strcmp (elf_section_data (old_sec)->group, group) != 0)
d898 1
a898 1
  char *name, *group, *beg;
d929 1
a929 1
  group = NULL;
d1001 2
a1002 2
	      group = obj_elf_section_name ();
	      if (group == NULL)
d1039 1
a1039 1
  obj_elf_change_section (name, type, attr, entsize, group, push);
d1913 1
a1913 1
  const char *group_name = elf_section_data (sec)->group;
d1923 1
a1923 1
      if (strcmp (group_name, elf_section_data (list->head[i])->group) == 0)
d1925 1
a1925 1
	  elf_section_data (sec)->next_in_group = list->head[i];
d1967 1
a1967 1
      const char *group_name = elf_section_data (list.head[i])->group;
d1981 2
a1982 4
      /* Pass a pointer to the first section in this group.  This
	 seems as good a field to use as any;  It's not used otherwise
	 by the ELF code.  */
      s->lineno = (alent *) list.head[i];
@


1.41
log
@	* config/obj-elf.c: Standardize error/warning messages - don't
	capitalise, no final period or newline, don't say "ignoring" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	(obj_elf_section_name): New function, split out from ..
	(obj_elf_section): .. here.  Correctly mask off SHF_MERGE if
	entsize not specified.
@
text
@d61 1
d78 2
a79 1
static void obj_elf_change_section PARAMS ((char *, int, int, int, int));
d623 7
a629 3
obj_elf_change_section (name, type, attr, entsize, push)
     char *name;
     int type, attr, entsize, push;
d715 1
d735 3
d771 3
d788 1
a788 1
	    char *bad_msg = _("unrecognized .section attribute: want a,w,x,M,S");
d898 1
a898 1
  char *name, *beg;
d929 1
d952 2
d974 2
d997 13
d1039 1
a1039 1
  obj_elf_change_section (name, type, attr, entsize, push);
d1395 17
a1411 17
  struct elf_obj_sy *srcelf = symbol_get_obj (src);		
  struct elf_obj_sy *destelf = symbol_get_obj (dest);		
  if (srcelf->size)						
    {								
      if (destelf->size == NULL)				
	destelf->size =					
	  (expressionS *) xmalloc (sizeof (expressionS));	
      *destelf->size = *srcelf->size;				
    }								
  else							
    {								
      if (destelf->size != NULL)				
	free (destelf->size);					
      destelf->size = NULL;					
    }								
  S_SET_SIZE (dest, S_GET_SIZE (src));			
  S_SET_OTHER (dest, S_GET_OTHER (src));			
d1894 53
d1950 3
d1954 36
@


1.40
log
@2001-09-30  H.J. Lu  <hjl@@gnu.org>

	* config/obj-elf.c (obj_elf_parse_section_letters): Accept "am"
	and "ams" for compatibility.
@
text
@d80 1
d306 1
a306 1
      as_bad (_("Expected comma after symbol-name"));
d323 1
a323 1
      as_bad (_("Ignoring attempt to re-define symbol"));
d331 1
a331 1
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
d354 1
a354 1
	      as_warn (_("Common alignment negative; 0 assumed"));
d373 1
a373 1
		  as_bad (_("Common alignment not a power of 2"));
d662 1
a662 1
		as_warn (_("Setting incorrect section type for %s"), name);
d666 1
a666 1
		as_warn (_("Ignoring incorrect section type for %s"), name);
d679 1
a679 1
	      as_warn (_("Setting incorrect section attributes for %s"),
d725 1
a725 1
	as_warn (_("Ignoring changed section attributes for %s"), name);
d727 1
a727 1
	as_warn (_("Ignoring changed section entity size for %s"), name);
d775 1
a775 1
	    char *bad_msg = _("Unrecognized .section attribute: want a,w,x,M,S");
d815 1
a815 1
  as_warn (_("Unrecognized section attribute"));
d837 1
a837 1
  as_warn (_("Unrecognized section type"));
d841 40
d885 1
a885 1
  char *name, *beg, *end;
d911 3
a913 30
  /* Get name of section.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      name = demand_copy_C_string (&dummy);
      if (name == NULL)
	{
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    {
      end = input_line_pointer;
      while (0 == strchr ("\n\t,; ", *end))
	end++;
      if (end == input_line_pointer)
	{
	  as_warn (_("Missing section name"));
	  ignore_rest_of_line ();
	  return;
	}

      name = xmalloc (end - input_line_pointer + 1);
      memcpy (name, input_line_pointer, end - input_line_pointer);
      name[end - input_line_pointer] = '\0';
      input_line_pointer = end;
    }
  SKIP_WHITESPACE ();

d961 1
a961 1
	  if ((attr & SHF_MERGE) && *input_line_pointer == ',')
d966 1
d969 1
a969 1
		  as_warn (_("Bad .section directive - invalid merge entity size"));
d974 5
d989 1
a989 1
		  as_warn (_("Bad .section directive - character following name is not '#'"));
a1007 6
  if ((attr & SHF_MERGE) && entsize == 0)
    {
      as_warn (_("Entity size for SHF_MERGE not specified.\nSpecify entity size as 4th argument"));
      attr &= SHF_MERGE;
    }

d1090 1
a1090 1
      as_bad (_(".previous without corresponding .section; ignored"));
d1117 1
a1117 1
      as_bad (_(".popsection without corresponding .pushsection; ignored"));
d1445 1
a1445 1
      as_bad (_("Expected quoted string"));
d1558 1
a1558 1
    as_bad (_("ignoring unrecognized symbol type \"%s\""), typename);
d1830 1
a1830 1
	as_bad (_("Symbol `%s' can not be both weak and common"),
d1953 1
a1953 1
	as_fatal (_("Failed to set up debugging information: %s"),
d1973 1
a1973 1
	as_fatal (_("Can't start writing .mdebug section: %s"),
d1981 1
a1981 1
	as_fatal (_("Could not write .mdebug section: %s"),
@


1.39
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d760 12
@


1.38
log
@	* dwarf2dbg.c (dwarf2_directive_file): Avoid signed/unsigned warning.

	* write.c (set_symtab): Update bfd_alloc declaration.  Use a temp
	var to ensure bfd_alloc arg is the right type.
	(write_object_file): Cast args of bfd_seek.  Replace bfd_write with
	bfd_bwrite.

	* config/obj-coff.c: Replace calls to bfd_write with calls to
	bfd_bwrite.  Cast args of bfd_seek.

	* config/obj-elf.c (obj_elf_change_section): Avoid signed/unsigned
	warning.

	* config/tc-mn10300.c (set_arch_mach): Make param unsigned.

	* config/tc-tic54x.c (tic54x_mlib): Replace bfd_read call with
	call to bfd_bread.
@
text
@d24 1
d1240 1
a1240 1
	  || isspace ((unsigned char) input_line_pointer[1])))
@


1.37
log
@	* config/obj-elf.c (obj_elf_parse_section_letters): Use 'M' instead
	of 'm', 'S' instead of 's'.  Update bad_msg.
	* config/tc-ppc.c (ppc_section_letter): Update bad_msg.
	* config/tc-i370.c (i370_sectioN_letter): Update bad_msg.
@
text
@d724 1
a724 1
      else if ((flags & SEC_MERGE) && old_sec->entsize != entsize)
@


1.36
log
@	* config/tc-ia64.c (dot_endp): Set function symbol sizes.
	* config/obj-elf.c (obj_elf_size): When size is constant, free
	and clear symbol_get_obj(sym)->size if any.
@
text
@d753 1
a753 1
	case 'm':
d756 1
a756 1
	case 's':
d761 1
a761 1
	    char *bad_msg = _("Unrecognized .section attribute: want a,m,s,w,x");
@


1.35
log
@	* symbols.c: Add missing prototypes.
	* config/e-i386elf.c: Likewise.
	* config/e-i386coff.c: Likewise.
	* config/e-i386aout.c: Likewise.
	* config/obj-coff.c: Likewise.
	(def_symbol_in_progress, stack): Move definition.
	* config/obj-elf.c: Add missing prototypes.
	(obj_elf_change_section): Make static.
	(obj_elf_parse_section_letters): Likewise.
	(obj_elf_section_word): Likewise.
	(obj_elf_section_type): Likewise.
@
text
@d1456 8
a1463 1
    S_SET_SIZE (sym, exp.X_add_number);
@


1.34
log
@	* config/obj-elf.c (elf_copy_symbol_attributes): Make it a global
	function, and expand old obj-elf.h OBJ_COPY_SYMBOL_ATTRIBUTES here.
	* config/obj-elf.h (elf_copy_symbol_attributes): Declare.
	(OBJ_COPY_SYMBOL_ATTRIBUTES): Call elf_copy_symbol_attributes.
@
text
@d76 4
d618 1
a618 1
void
d733 1
a733 1
int
d781 1
a781 1
int
d805 1
a805 1
int
@


1.33
log
@	* config/obj-elf.c (obj_elf_symver): Temporarily modify lex_type
	to include '@@' in symbol names when parsing versioned symbols
	rather than calling get_symbol_end multiple times.
	* config/tc-i370.c (register_name): Format fixes.  Don't call
	get_symbol_end after parsing number.
	* config/tc-mn10200.c (data_register_name): Format fixes.  Hoist
	code out of conditional.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-mn10300.c (r_register_name): Likewise.
	(xr_register_name): Likewise.
	(data_register_name): Likewise.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-ppc.c (register_name): Likewise.
	* config/tc-s390.c (register_name): Likewise.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
a57 1
static void elf_copy_symbol_attributes PARAMS ((symbolS *, symbolS *));
a243 7
static void
elf_copy_symbol_attributes (dest, src)
     symbolS *dest, *src;
{
  OBJ_COPY_SYMBOL_ATTRIBUTES (dest, src);
}

d1323 27
@


1.32
log
@*** empty log message ***
@
text
@d1135 1
d1155 6
a1160 7
  while (1)
    {
      c = get_symbol_end ();
      if (c != ELF_VER_CHR)
	break;
      *input_line_pointer++ = c;
    }
@


1.31
log
@2001-07-10  John Healy  <jhealy@@redhat.com>

	* config/obj-elf.c (obj_elf_section): md_elf_section_change_data_hook
	added to grab section information after it's been extracted from the
	.section directive.
@
text
@a984 4
#ifdef md_elf_section_change_data_hook
      md_elf_section_change_data_hook (name, type, attr, entsize, push);
#endif

@


1.30
log
@bfd/
	* libbfd-in.h (_bfd_merge_section): New.
	(_bfd_write_merged_section): New.
	(_bfd_merged_section_offset): New.
	* libbfd.h: Rebuilt.
	* linker.c (_bfd_generic_link_output_symbols): Handle
	discard_sec_merge.
	* aoutx.h (aout_link_write_symbols): Likewise.
	* pdp11.c (aout_link_write_symbols): Likewise.
	* elflink.h (elf_link_add_object_symbols): Call _bfd_merge_section.
	(elf_bfd_final_link): Adjust global symbols pointing into SEC_MERGE
	sections.
	(elf_link_sec_merge_syms): New.
	(elf_link_input_bfd): Call _bfd_merged_section_offset
	and _bfd_write_merged_section.
	Handle discard_sec_merge.
	* elf-bfd.h (struct elf_link_hash_table): Add merge_info
	field.
	(struct bfd_elf_section_data): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_MERGE and
	SEC_STRINGS section flags and entsize from their ELF counterparts.
	(_bfd_elf_link_hash_table_init): Initialize merge_info.
	(elf_fake_sections): Set SHF_MERGE, SHF_STRINGS and sh_entsize
	from their BFD counterparts.
	* merge.c: New file.
	* Makefile.am: Add strtab.lo.
	* Makefile.in: Rebuilt.
include/
	* bfdlink.h (bfd_link_discard): Add discard_sec_merge.
gas/
	* config/obj-elf.c (obj_elf_change_section): Add entsize argument,
	handle SHF_MERGE and SHF_STRINGS.
	(obj_elf_parse_section_letters): Set SHF_MERGE and SHF_STRINGS.
	(obj_elf_section): Allow additional argument specifying entity size.
	* write.c (adjust_reloc_syms): Keep relocations against local symbols
	in SEC_MERGE sections.
ld/
	* ldmain.c (main): Default to discard_sec_merge.
	* lexsup.c (OPTION_DISCARD_NONE): Define.
	(ld_options): Add --discard-none.
	(parse_args): Handle OPTION_DISCARD_NONE.
	* ldlang.c (wild_doit): SEC_MERGE should be set in the output
	section only if SEC_MERGE and SEC_STRINGS flags and entsize of
	all its input sections match.
@
text
@d985 4
@


1.29
log
@Fix copyright notices
@
text
@d623 1
a623 1
obj_elf_change_section (name, type, attr, push)
d625 1
a625 1
     int type, attr, push;
d693 3
a695 1
	   | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0));
d709 2
d726 1
a726 1
	     | SEC_EXCLUDE | SEC_SORT_ENTRIES))
d728 2
d757 6
d765 1
a765 1
	    char *bad_msg = _("Unrecognized .section attribute: want a,w,x");
d837 1
d893 1
d936 14
d979 7
a985 1
  obj_elf_change_section (name, type, attr, push);
@


1.28
log
@2000-11-16  H.J. Lu  <hjl@@gnu.org>

	* config/obj-elf.c (obj_elf_symver): Don't check the missing
	version name.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.28.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
@


1.27
log
@2000-11-14  Kazu Hirata  <kazu@@hxi.com>

	* config/aout_gnu.h: Fix formatting.
	* config/atof-vax.c: Likewise.
	* config/m68k-parse.h: Likewise.
	* config/m88k-opcode.h: Likewise.
	* config/obj-elf.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/te-386bsd.h: Likewise.
	* config/te-hppa.h: Likewise.
	* config/te-nbsd.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-sparcaout.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/vax-inst.h: Likewise.
	* config/vms-conf.h: Likewise.
@
text
@a1129 2
      char *p, *rp;

d1134 2
a1135 4
      p = strchr (symbol_get_obj (sym)->versioned_name, ELF_VER_CHR);
      if (p)
	rp = strrchr (p, ELF_VER_CHR);
      if (!p || p [1] == '\0' || rp [1] == '\0')
@


1.26
log
@2000-11-13  H.J. Lu  <hjl@@gnu.org>

	* config/obj-elf.c (elf_frob_symbol): Support
	".symver name,name2@@@@@@nodename".
	(elf_frob_file_before_adjust): Likewise.

	* doc/as.texinfo: Updated for ".symver name,name2@@@@@@nodename"
	and ".symver name,name2@@@@@@nodename".
	Fix a typo.
@
text
@d1139 1
a1139 1
      if (!p || p [1] == '\0' || rp [1] == '\0') 
d1786 1
a1786 1
/* It removes any unneeded versioned symbols from the symbol table. */
@


1.25
log
@2000-11-12  H.J. Lu  (hjl@@gnu.org)

	* config/obj-elf.c (obj_elf_symver): Check missing version
	name.
@
text
@d1661 5
a1678 2
	  char *p;

a1681 2
	  p = strchr (sy_obj->versioned_name, ELF_VER_CHR);
	  know (p != NULL);
d1692 3
a1694 1
	  symbolS *symp2;
d1696 9
a1704 5
	  /* FIXME: Creating a new symbol here is risky.  We're in the
             final loop over the symbol table.  We can get away with
             it only because the symbol goes to the end of the list,
             where the loop will still see it.  It would probably be
             better to do this in obj_frob_file_before_adjust.  */
d1706 6
a1711 1
	  symp2 = symbol_find_or_make (sy_obj->versioned_name);
d1713 1
a1713 1
	  /* Now we act as though we saw symp2 = sym.  */
d1715 1
a1715 1
	  S_SET_SEGMENT (symp2, S_GET_SEGMENT (symp));
d1717 1
a1717 5
	  /* Subtracting out the frag address here is a hack because
             we are in the middle of the final loop.  */
	  S_SET_VALUE (symp2,
		       (S_GET_VALUE (symp)
			- symbol_get_frag (symp)->fr_address));
d1719 5
a1723 1
	  symbol_set_frag (symp2, symbol_get_frag (symp));
d1725 1
a1725 2
	  /* This will copy over the size information.  */
	  copy_symbol_attributes (symp2, symp);
d1727 2
a1728 2
	  if (S_IS_WEAK (symp))
	    S_SET_WEAK (symp2);
d1730 6
a1735 2
	  if (S_IS_EXTERNAL (symp))
	    S_SET_EXTERNAL (symp2);
d1796 23
a1818 5
	if (symbol_get_obj (symp)->versioned_name
	    && !S_IS_DEFINED (symp)
	    && symbol_used_p (symp) == 0
	    && symbol_used_in_reloc_p (symp) == 0)
	  symbol_remove (symp, &symbol_rootP, &symbol_lastP);
@


1.24
log
@2000-11-07  H.J. Lu  <hjl@@gnu.org>

	* doc/as.texinfo (.symver): Updated for versioned symbol
	reference.

	* obj.h (format_ops): Add the frob_file_before_adjust field.

	* config/obj-aout.c (aout_format_ops): Set the
	frob_file_before_adjust field to 0.
	* config/obj-coff.c (coff_format_ops): Likewise.
	* config/obj-ecoff.c (ecoff_format_ops): Likewise.

	* config/obj-elf.c (obj_elf_symver): Allow duplicated version
	name.
	(elf_frob_file_before_adjust): New function to remove unneeded
	versioned symbols from the symbol table.
	(elf_format_ops): Set the frob_file_before_adjust field to
	elf_frob_file_before_adjust.

	* config/obj-elf.h (obj_frob_file_before_adjust): Defined if
	not defined.

	* config/obj-multi.h (obj_frob_file_before_adjust): Defined.
@
text
@d1130 2
d1136 4
a1139 2
      if (strchr (symbol_get_obj (sym)->versioned_name,
				  ELF_VER_CHR) == NULL)
@


1.23
log
@Revert 2000-10-07 link-once section symbol changes.
@
text
@a1109 8
  if (symbol_get_obj (sym)->versioned_name != NULL)
    {
      as_bad (_("multiple .symver directives for symbol `%s'"),
	      S_GET_NAME (sym));
      ignore_rest_of_line ();
      return;
    }

d1128 3
a1130 1
  symbol_get_obj (sym)->versioned_name = xstrdup (name);
d1132 1
a1132 1
  *input_line_pointer = c;
d1134 11
a1144 1
  if (strchr (symbol_get_obj (sym)->versioned_name, ELF_VER_CHR) == NULL)
d1146 10
a1155 4
      as_bad (_("missing version name in `%s' for symbol `%s'"),
	      symbol_get_obj (sym)->versioned_name, S_GET_NAME (sym));
      ignore_rest_of_line ();
      return;
d1767 18
d1989 1
@


1.22
log
@Make elf section symbols global for link-once sections.
@
text
@a1744 15

  if (symbol_section_p (symp))
    {
      asection *symsec = S_GET_SEGMENT (symp);

      if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE) != 0
	  || strncmp (segment_name (symsec), ".gnu.linkonce",
		      sizeof ".gnu.linkonce" - 1) == 0)
	{
	  /* Make section syms global on ELF linkonce sections.
	     This way, any reference to the section symbol will
	     resolve to the section that actually stays in.  */
	  S_SET_EXTERNAL (symp);
	}
    }
@


1.21
log
@2000-09-13  Kazu Hirata  <kazu@@hxi.com>

	* config/obj-ecoff.c: Fix formatting.
	* config/obj-elf.c: Likewise.
	* config/obj-elf.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-generic.h: Likewise.
	* config/obj-hp300.c: Likewise.
	* config/obj-hp300.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/obj-vms.c: Likewise.
	* config/obj-vms.h: Likewise.
@
text
@d1745 15
@


1.20
log
@Munge in vtable support for tc-hppa.c, inform elf back-end about
millicode, and make $PIC_pcrel$0 work.
@
text
@d20 1
a20 1
   02111-1307, USA. */
d99 1
a99 1
  /* These define symbol visibility. */
d117 1
a117 1
  /* These are used for dwarf. */
a544 1

a556 1

d1084 1
a1084 1
     delightful bug, so we are not being incompatible here. */
d1307 1
a1307 1
      ++input_line_pointer;	/* -> 1st char of string. */
d1513 1
a1513 1
  /* Make space for this first symbol. */
d1515 1
a1515 1
  /* Zero it out. */
d1683 1
a1683 1
             better to do this in obj_frob_file_before_adjust. */
@


1.19
log
@2000-07-28  Jason Eckhardt  <jle@@cygnus.com>

	* configure.in: Add bits for i860-stardent-{sysv4, elf}*.
	* configure: Regenerated.
	* config/obj-elf.c (obj_elf_type): Recognize a fifth type
	of operand to the .type directive (.e.g, "type").
@
text
@a77 2
static void obj_elf_vtable_inherit PARAMS ((int));
static void obj_elf_vtable_entry PARAMS ((int));
d114 2
a115 2
  {"vtable_inherit", obj_elf_vtable_inherit, 0},
  {"vtable_entry", obj_elf_vtable_entry, 0},
d1157 1
a1157 1
static void
d1190 1
a1190 1
      return;
d1217 1
a1217 1
    return;
d1220 3
a1222 3
  fix_new (symbol_get_frag (csym),
	   symbol_get_value_expression (csym)->X_add_number, 0, psym, 0, 0,
	   BFD_RELOC_VTABLE_INHERIT);
d1229 1
a1229 1
static void
d1251 1
a1251 1
      return;
d1260 1
a1260 2
  fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
	   BFD_RELOC_VTABLE_ENTRY);
d1262 2
a1263 1
  demand_empty_rest_of_line ();
d1425 1
d1430 1
d1454 4
d1466 1
a1466 1
  symbol_get_bfdsym (sym)->flags |= type;
@


1.18
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d1404 1
a1404 1
   There are four syntaxes:
d1414 2
d1440 1
d1458 3
@


1.17
log
@	* obj.h (struct format_ops): New members begin, app_file,
	s_set_other, s_set_desc, s_get_type, s_set_type,
	separate_stab_sections, init_stab_section.

	* config/obj-multi.h: Update GPL notice to v2.
	(obj_begin): New.
	(obj_app_file): New.
	(S_SET_SIZE): Test s_set_size for NULL before calling.
	(S_SET_ALIGN): Similar for s_set_align.
	(S_SET_OTHER): New.
	(S_SET_DESC): New.
	(S_GET_TYPE): New.
	(S_SET_TYPE): New.
	(SEPARATE_STAB_SECTIONS): New.
	(INIT_STAB_SECTION): New.
	(EMIT_SECTION_SYMBOLS): New.
	(AOUT_STABS) [OBJ_MAYBE_AOUT]: Define.

	* config/obj-elf.h: Update GPL notice to v2.
	Mention that this file is included from obj-multi.h.
	(obj_begin): Wrap definition in ifndef.
	(elf_file_symbol): Constify declaration.
	(obj_app_file): Ditto.
	(SEPARATE_STAB_SECTIONS, INIT_STAB_SECTION, OBJ_PROCESS_STAB):
	Wrap in ifndef SEPARATE_STAB_SECTIONS.

	* config/obj-elf.c (elf_s_set_other): New.
	(elf_file_symbol): Constify argument.
	(elf_separate_stab_sections): New.
	(elf_init_stab_section): New.
	(elf_format_ops): Add new members.  Remove comma at end.

	* config/obj-ecoff.c (ecoff_separate_stab_sections): New.
	(ecoff_format_ops): Add new fields.  Remove comma at end.
	Mention inconsistency for emit_section_symbols.

	* config/obj-coff.h (c_dot_file_symbol): Constify declaration.

	* config/obj-coff.c (c_dot_file_symbol): Constify argument.
	(coff_separate_stab_sections): New.
	(coff_format_ops): Add new members.

	* config/obj-aout.c (obj_aout_sec_sym_ok_for_reloc): New.
	(obj_aout_s_set_other): New.
	(obj_aout_s_set_desc): New.
	(obj_aout_s_get_type): New.
	(obj_aout_s_set_type): New.
	(obj_aout_separate_stab_sections): New.
	(aout_format_ops): New members added.  Use obj_aout_process_stab,
	not 0.  Use obj_aout_sec_sym_ok_for_reloc, not 0.
	(obj_aout_frob_symbol): Add ATTRIBUTE_UNUSED to args as
	appropriate.
	(obj_aout_line, obj_aout_weak, obj_aout_type): Ditto.
@
text
@d836 1
a836 1
  md_flush_pending_output ();
@


1.16
log
@Check for changed section attributes.
@
text
@d57 1
d61 2
d240 8
d263 1
a263 1
     char *s;
d1924 20
d1949 2
d1957 1
d1959 3
d1970 2
d1980 1
a1980 1
  elf_obj_symbol_new_hook,
@


1.15
log
@2000-02-27  Thomas de Lellis  <tdel@@windriver.com>

	* config/obj-elf.c (elf_frob_symbol): Remove code which when
	TC_PPC was defined forced the type of a symbol with no other type
	to be BSF_OBJECT.
@
text
@d620 1
a620 1
  int new_sec;
d622 2
d644 1
a644 1
  new_sec = bfd_get_section_by_name (stdoutput, name) == NULL;
d647 13
a659 16
  if (new_sec)
    {
      flagword flags;
      symbolS *secsym;
      int i;

      /* See if this is one of the special sections.  */
      for (i = 0; special_sections[i].name != NULL; i++)
        if (strcmp (name, special_sections[i].name) == 0)
          {
	    if (type == SHT_NULL)
	      type = special_sections[i].type;
	    else if (type != special_sections[i].type)
	      as_warn (_("Setting incorrect section type for %s"), name);

	    if ((attr &~ special_sections[i].attributes) != 0)
d661 2
a662 8
	        /* As a GNU extension, we permit a .note section to be
		   allocatable.  If the linker sees an allocateable .note
		   section, it will create a PT_NOTE segment in the output
		   file.  */
		if (strcmp (name, ".note") != 0
		    || attr != SHF_ALLOC)
		  as_warn (_("Setting incorrect section attributes for %s"),
			   name);
a663 2
	    attr |= special_sections[i].attributes;
	    break;
d665 22
a686 7

      /* Convert ELF type and flags to BFD flags.  */
      flags = (SEC_RELOC
	       | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
	       | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	       | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
	       | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0));
d688 1
a688 1
      flags = md_elf_section_flags (flags, attr, type);
d691 4
d708 10
d720 1
a720 1
      md_elf_section_change_hook ();
@


1.14
log
@Add IBM 370 support.
@
text
@d1696 5
a1700 3
#ifdef TC_PPC
  /* Frob the PowerPC, so that the symbol always has object type
     if it is not some other type.  VxWorks needs this.  */
@


1.13
log
@Make copyright date lists comply with GNU requirement
@
text
@d49 4
d799 1
d819 1
@


1.12
log
@This set of patches add support for aout emulation on the x86
assembler.  ie. You will be able to do "as --em=i386aout" on an x86
linux-elf assembler to generate aout format object files, rather than
using a separate assembler.  The aout emulation is enabled by giving
"--enable-targets=i386-linuxaout" to configure.
Oh yeah, there's a couple of fixes too.  Error messages shouldn't be
passed to printf in the format arg just in case someone puts a `%' in
the message.
@
text
@d2 2
a3 1
   Copyright (C) 1992, 93-99, 2000 Free Software Foundation, Inc.
d507 1
a507 1
      
d509 1
a509 1
      
d512 1
a512 1
      
d514 1
a514 1
      
d516 1
a516 1
      
d520 1
a520 1
	  
d522 1
a522 1
	  
d528 1
a528 1
  
d837 1
a837 1
    
d1189 1
a1189 1
  
d1368 1
a1368 1
   
d1803 4
a1806 4
   int_32 namesz  = 4 ;  Name size 
   int_32 descsz  = 12 ; Descriptive information 
   int_32 type    = 1 ;  
   char   name[4] = "SCO" ; Originator name ALWAYS SCO + NULL 
d1810 1
a1810 1
                           don't know enough about the source 
d1842 1
a1842 1
  i_note.namesz = 4; 
d1856 1
a1856 1
  strcpy (p, "SCO"); 
d1873 1
a1873 1
 
@


1.11
log
@ELF visibility patch from Martin Loewis
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.
d224 7
d729 1
a729 1
		as_warn (bad_msg);
d1231 1
a1231 1
obj_read_begin_hook ()
d1240 1
a1240 1
obj_symbol_new_hook (symbolP)
d1887 2
a1888 2
  0,
  1,
d1894 2
d1901 2
a1902 2
  0,
  0,				/* process_stab */
d1909 1
a1909 1
  0,
d1911 2
a1912 2
  obj_read_begin_hook,
  obj_symbol_new_hook,
@


1.10
log
@	* config/obj-elf.c (obj_elf_ident): Call md_flush_pending_output
	if it is defined.

	* config/obj-elf.c (elf_set_index): Add ATTRIBUTE_UNUSED.

	* config/obj-elf.c (elf_frob_file_after_relocs): Don't pass NULL
	to bfd_set_section_contents.
@
text
@d68 1
d93 5
d482 42
@


1.9
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d1376 4
d1500 2
a1501 2
     asymbol *sym;
     bfd_size_type indx;
d1712 5
a1716 1
      if (! bfd_set_section_contents (stdoutput, sec, (PTR) NULL,
@


1.8
log
@Make the mcore even more paranoid about section switching
@
text
@d115 1
a115 1
  {NULL},
d160 1
a160 1
  {NULL}			/* end sentinel */
d304 1
a304 1
      if (S_GET_VALUE (symbolP) != size)
d421 1
a421 1
     int ignore;
d450 1
a450 1
     int ignore;
d905 1
a905 1
     int ignore;
d937 1
a937 1
     int ignore;
d965 1
a965 1
     int xxx;
d992 1
a992 1
     int ignore;
d1008 1
a1008 1
     int ignore;
d1068 1
d1140 1
d1202 1
a1202 1
     int ignore;
d1269 1
a1269 1
     int ignore;
d1325 1
a1325 1
     int ignore;
d1370 1
a1370 1
     int ignore;
d1430 1
a1430 1
     PTR xxx;
@


1.7
log
@	* config/obj-elf.c (obj_elf_common): In MRI mode if called as
	`common' pass on to s_mri_common.
	(elf_pseudo_table): Pass 1 to obj_elf_common for `common'.
@
text
@a67 1
static void obj_elf_common PARAMS ((int));
a70 2
static void obj_elf_data PARAMS ((int));
static void obj_elf_text PARAMS ((int));
d256 1
a256 1
static void
d867 1
a867 1
static void
d886 1
a886 1
static void
@


1.6
log
@        * config/obj-elf.c (obj_elf_section): Don't free the return
        value of demand_copy_C_string.
@
text
@d80 1
a80 1
  {"common", obj_elf_common, 0},
d260 2
a261 2
obj_elf_common (ignore)
     int ignore;
d269 6
@


1.5
log
@        * dwarf2dbg.c (dwarf2_gen_line_info): Mirror the section symbol
        creation logic from obj_elf_create_section.
        * config/obj-elf.c (elf_pseudo_tab): Add pushsection/popsection.
        (section_stack): New.
        (special_sections): Make const.
        (obj_elf_section): Gut and rewrite parsing.
        (obj_elf_change_section): New function broken out of obj_elf_section.
        (obj_elf_parse_section_letters): Likewise.
        (obj_elf_section_word): Likewise.
        (obj_elf_section_type): Likewise.
        (obj_elf_previous): Treat as a toggle.
        (obj_elf_popsection): New.
        * config/tc-ppc.c (ppc_section_word): Take str+len not ptr_str.
        (ppc_section_type): Likewise.
        * config/tc-ppc.h: Likewise.
        * expr.h (struct expressionS): Don't make X_op a bitfield.
        * config/tc-alpha.c: Update for symbol handling changes.
        (md_apply_fix) [case GPREL]: Use now_seg instead of absolute_section.
        (load_expression, emit_ir_load, emit_loadstore, emit_jsrjmp): Likewise.
@
text
@a803 1
	  free (beg);
a820 1
		  free (beg);
@


1.4
log
@        * config/obj-elf.c (elf_pseudo_table): Add `common'.
@
text
@d2 1
a2 2
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d75 1
d88 2
d477 10
d514 1
a514 1
static struct special_section special_sections[] =
d553 3
a555 2
obj_elf_section (xxx)
     int xxx;
a556 1
  char *string;
a558 4
  int type, attr;
  int i;
  flagword flags;
  symbolS *secsym;
d564 172
d740 4
d760 2
a761 2
      string = demand_copy_C_string (&xxx);
      if (string == NULL)
d769 4
a772 5
      char *p = input_line_pointer;
      char c;
      while (0 == strchr ("\n\t,; ", *p))
	p++;
      if (p == input_line_pointer)
d778 5
a782 28
      c = *p;
      *p = 0;
      string = xmalloc ((unsigned long) (p - input_line_pointer + 1));
      strcpy (string, input_line_pointer);
      *p = c;
      input_line_pointer = p;
    }

  /* Switch to the section, creating it if necessary.  */
  previous_section = now_seg;
  previous_subsection = now_subseg;

  new_sec = bfd_get_section_by_name (stdoutput, string) == NULL;
  sec = subseg_new (string, 0);

  /* If this section already existed, we don't bother to change the
     flag values.  */
  if (! new_sec)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
      ++input_line_pointer;

#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif

      return;
a783 1

a792 1

d797 2
a798 3
	  /* Pick up a string with a combination of a, w, x.  */
	  ++input_line_pointer;
	  while (*input_line_pointer != '"')
d800 2
a801 28
	      switch (*input_line_pointer)
		{
		case 'a':
		  attr |= SHF_ALLOC;
		  break;
		case 'w':
		  attr |= SHF_WRITE;
		  break;
		case 'x':
		  attr |= SHF_EXECINSTR;
		  break;
		default:
		  {
		    char *bad_msg = _("Bad .section directive: want a,w,x in string");
#ifdef md_elf_section_letter
		    int md_attr = md_elf_section_letter (*input_line_pointer, &bad_msg);
		    if (md_attr)
		      attr |= md_attr;
		    else
#endif
		      {
			as_warn (bad_msg);
			ignore_rest_of_line ();
			return;
		      }
		  }
		}
	      ++input_line_pointer;
d803 2
a804 3

	  /* Skip the closing quote.  */
	  ++input_line_pointer;
d809 1
d812 2
a813 1
	      if (*input_line_pointer == '@@' || *input_line_pointer == '%')
d815 2
a816 3
		  ++input_line_pointer;
		  if (strncmp (input_line_pointer, "progbits",
			       sizeof "progbits" - 1) == 0)
d818 2
a819 21
		      type = SHT_PROGBITS;
		      input_line_pointer += sizeof "progbits" - 1;
		    }
		  else if (strncmp (input_line_pointer, "nobits",
				    sizeof "nobits" - 1) == 0)
		    {
		      type = SHT_NOBITS;
		      input_line_pointer += sizeof "nobits" - 1;
		    }
		  else
		    {
#ifdef md_elf_section_type
		    int md_type = md_elf_section_type (&input_line_pointer);
		    if (md_type)
		      type = md_type;
		    else
#endif
		      {
			as_warn (_("Unrecognized section type"));
			ignore_rest_of_line ();
		      }
d821 9
d837 2
d846 6
a851 33
	      ++input_line_pointer;
	      if (strncmp (input_line_pointer, "write",
			   sizeof "write" - 1) == 0)
		{
		  attr |= SHF_WRITE;
		  input_line_pointer += sizeof "write" - 1;
		}
	      else if (strncmp (input_line_pointer, "alloc",
				sizeof "alloc" - 1) == 0)
		{
		  attr |= SHF_ALLOC;
		  input_line_pointer += sizeof "alloc" - 1;
		}
	      else if (strncmp (input_line_pointer, "execinstr",
				sizeof "execinstr" - 1) == 0)
		{
		  attr |= SHF_EXECINSTR;
		  input_line_pointer += sizeof "execinstr" - 1;
		}
	      else
		{
#ifdef md_elf_section_word
		  int md_attr = md_elf_section_word (&input_line_pointer);
		  if (md_attr)
		    attr |= md_attr;
		  else
#endif
		    {
		      as_warn (_("Unrecognized section attribute"));
		      ignore_rest_of_line ();
		      return;
		    }
		}
d859 1
a859 10
  /* See if this is one of the special sections.  */
  for (i = 0; special_sections[i].name != NULL; i++)
    {
      if (string[1] == special_sections[i].name[1]
	  && strcmp (string, special_sections[i].name) == 0)
	{
	  if (type == SHT_NULL)
	    type = special_sections[i].type;
	  else if (type != special_sections[i].type)
	    as_warn (_("Setting incorrect section type for %s"), string);
d861 1
a861 55
	  if ((attr &~ special_sections[i].attributes) != 0)
	    {
	      /* As a GNU extension, we permit a .note section to be
                 allocatable.  If the linker sees an allocateable
                 .note section, it will create a PT_NOTE segment in
                 the output file.  */
	      if (strcmp (string, ".note") != 0
		  || attr != SHF_ALLOC)
		as_warn (_("Setting incorrect section attributes for %s"),
			 string);
	    }
	  attr |= special_sections[i].attributes;

	  break;
	}
    }

  flags = (SEC_RELOC
	   | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
	   | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	   | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
	   | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0));
  if (special_sections[i].name == NULL)
    {
      if (type == SHT_PROGBITS)
	flags |= SEC_ALLOC | SEC_LOAD;
      else if (type == SHT_NOBITS)
	{
	  flags |= SEC_ALLOC;
	  flags &=~ SEC_LOAD;
	}

#ifdef md_elf_section_flags
      flags = md_elf_section_flags (flags, attr, type);
#endif
    }

  /* Prevent SEC_HAS_CONTENTS from being inadvertently set.  */
  if (type == SHT_NOBITS)
    seg_info (sec)->bss = 1;

  bfd_set_section_flags (stdoutput, sec, flags);

  /* Add a symbol for this section to the symbol table.  */
  secsym = symbol_find (string);
  if (secsym != NULL)
    symbol_set_bfdsym (secsym, sec->symbol);
  else
    symbol_table_insert (section_symbol (sec));

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif

  demand_empty_rest_of_line ();
d938 3
d951 32
a982 2
  subseg_set (previous_section, previous_subsection);
  previous_section = 0;
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d80 1
@


1.2
log
@	-Wchar-subscripts cleanup
	* listing.c (listing_newline): Use unsigned char variable, so
 	calls to isascii,iscntrl are correct.
	* atof-generic.c (atof_generic): Cast arg to isdigit, et. al. with
	(unsigned char).
	* ecoff.c (ecoff_directive_ent,ecoff_stab): Ditto.
	* config/obj-elf.c (obj_elf_vtable_inherit): Ditto.
	* config/tc-mips.c (mips_ip,mips16_ip): Ditto.
	(my_getSmallExpression,get_number,s_mips_ent): Ditto.
@
text
@d2 2
a3 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d239 2
a240 2
  sym->sy_frag = &zero_address_frag;
  sym->bsym->flags |= BSF_FILE;
d326 1
a326 1
      if (symbolP->local)
d354 2
a355 2
	    symbolP->sy_frag->fr_symbol = 0;
	  symbolP->sy_frag = frag_now;
d393 1
a393 1
  symbolP->bsym->flags |= BSF_OBJECT;
d429 1
a429 1
      symbolP->local = 1;
d458 1
a458 1
      symbolP->local = 1;
d819 1
a819 1
    secsym->bsym = sec->symbol;
d953 1
a953 1
  if (sym->sy_obj.versioned_name != NULL)
d979 1
a979 1
  sym->sy_obj.versioned_name = xstrdup (name);
d983 1
a983 1
  if (strchr (sym->sy_obj.versioned_name, ELF_VER_CHR) == NULL)
d986 1
a986 1
	      sym->sy_obj.versioned_name, S_GET_NAME (sym));
d1016 1
a1016 1
  if (csym == NULL || csym->sy_frag == NULL)
d1059 3
a1061 2
  assert (csym->sy_value.X_op == O_constant);
  fix_new (csym->sy_frag, csym->sy_value.X_add_number, 0, psym, 0, 0,
d1118 5
a1122 2
  symbolP->sy_obj.size = NULL;
  symbolP->sy_obj.versioned_name = NULL;
d1233 3
a1235 2
      sym->sy_obj.size = (expressionS *) xmalloc (sizeof (expressionS));
      *sym->sy_obj.size = exp;
d1293 1
a1293 1
  sym->bsym->flags |= type;
d1402 1
a1402 1
  sym->bsym->udata.p = (PTR) ext;
d1438 2
d1445 3
a1447 1
  if (symp->sy_obj.size != NULL)
d1449 1
a1449 1
      switch (symp->sy_obj.size->X_op)
d1453 3
a1455 3
		      (S_GET_VALUE (symp->sy_obj.size->X_add_symbol)
		       + symp->sy_obj.size->X_add_number
		       - S_GET_VALUE (symp->sy_obj.size->X_op_symbol)));
d1459 2
a1460 2
		      (S_GET_VALUE (symp->sy_obj.size->X_add_symbol)
		       + symp->sy_obj.size->X_add_number));
d1466 2
a1467 2
      free (symp->sy_obj.size);
      symp->sy_obj.size = NULL;
d1470 1
a1470 1
  if (symp->sy_obj.versioned_name != NULL)
d1490 1
a1490 1
	  p = strchr (symp->sy_obj.versioned_name, ELF_VER_CHR);
d1495 1
a1495 1
		      symp->sy_obj.versioned_name);
d1498 1
a1498 1
	  S_SET_NAME (symp, symp->sy_obj.versioned_name);
d1510 1
a1510 1
	  symp2 = symbol_find_or_make (symp->sy_obj.versioned_name);
d1518 3
a1520 1
	  S_SET_VALUE (symp2, S_GET_VALUE (symp) - symp->sy_frag->fr_address);
d1522 1
a1522 1
	  symp2->sy_frag = symp->sy_frag;
d1536 1
a1536 1
  if (symp->bsym->flags & BSF_WEAK)
d1552 1
a1552 1
    symp->bsym->flags |= BSF_OBJECT;
d1555 3
a1557 2
      && (! S_IS_DEFINED (symp) && ((symp->bsym->flags & BSF_FUNCTION) == 0)))
    symp->bsym->flags |= BSF_OBJECT;
d1563 2
a1564 1
  if ((symp->bsym->flags & (BSF_FUNCTION | BSF_FILE | BSF_SECTION_SYM)) == 0
d1566 1
a1566 1
    symp->bsym->flags |= BSF_OBJECT;
@


1.1
log
@Initial revision
@
text
@d1040 1
a1040 1
	  || isspace(input_line_pointer[1])))
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

