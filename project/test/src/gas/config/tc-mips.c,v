head	1.595;
access;
symbols
	binutils-2_24-branch:1.593.0.2
	binutils-2_24-branchpoint:1.593
	binutils-2_21_1:1.431.2.2
	binutils-2_23_2:1.506.2.2
	binutils-2_23_1:1.506.2.2
	binutils-2_23:1.506.2.2
	binutils-2_23-branch:1.506.0.2
	binutils-2_23-branchpoint:1.506
	binutils-2_22_branch:1.488.2.1.0.2
	binutils-2_22:1.488.2.1
	binutils-2_22-branch:1.488.0.2
	binutils-2_22-branchpoint:1.488
	binutils-2_21:1.431.2.1
	binutils-2_21-branch:1.431.0.2
	binutils-2_21-branchpoint:1.431
	binutils-2_20_1:1.412.2.2
	binutils-2_20:1.412.2.2
	binutils-arc-20081103-branch:1.396.0.4
	binutils-arc-20081103-branchpoint:1.396
	binutils-2_20-branch:1.412.0.2
	binutils-2_20-branchpoint:1.412
	dje-cgen-play1-branch:1.409.0.2
	dje-cgen-play1-branchpoint:1.409
	arc-20081103-branch:1.396.0.2
	arc-20081103-branchpoint:1.396
	binutils-2_19_1:1.394.2.1
	binutils-2_19:1.394
	binutils-2_19-branch:1.394.0.2
	binutils-2_19-branchpoint:1.394
	binutils-2_18:1.373
	binutils-2_18-branch:1.373.0.2
	binutils-2_18-branchpoint:1.373
	binutils-csl-coldfire-4_1-32:1.327.2.1
	binutils-csl-sourcerygxx-4_1-32:1.327.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.327.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.291.2.20
	binutils-csl-coldfire-4_1-30:1.327.2.1
	binutils-csl-sourcerygxx-4_1-30:1.327.2.1
	binutils-csl-coldfire-4_1-28:1.327.2.1
	binutils-csl-sourcerygxx-4_1-29:1.327.2.1
	binutils-csl-sourcerygxx-4_1-28:1.327.2.1
	binutils-csl-arm-2006q3-27:1.327.2.1
	binutils-csl-sourcerygxx-4_1-27:1.327.2.1
	binutils-csl-arm-2006q3-26:1.327.2.1
	binutils-csl-sourcerygxx-4_1-26:1.327.2.1
	binutils-csl-sourcerygxx-4_1-25:1.327.2.1
	binutils-csl-sourcerygxx-4_1-24:1.327.2.1
	binutils-csl-sourcerygxx-4_1-23:1.327.2.1
	binutils-csl-sourcerygxx-4_1-21:1.327.2.1
	binutils-csl-arm-2006q3-21:1.327.2.1
	binutils-csl-sourcerygxx-4_1-22:1.327.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.327.2.1
	binutils-csl-sourcerygxx-4_1-20:1.327.2.1
	binutils-csl-arm-2006q3-19:1.327.2.1
	binutils-csl-sourcerygxx-4_1-19:1.327.2.1
	binutils-csl-sourcerygxx-4_1-18:1.327.2.1
	binutils-csl-renesas-4_1-9:1.327.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.291.2.20
	binutils-csl-renesas-4_1-8:1.327
	binutils-csl-renesas-4_1-7:1.327
	binutils-csl-renesas-4_1-6:1.327
	binutils-csl-sourcerygxx-4_1-17:1.327
	binutils-csl-sourcerygxx-4_1-14:1.327
	binutils-csl-sourcerygxx-4_1-15:1.327
	binutils-csl-sourcerygxx-4_1-13:1.327
	binutils-2_17:1.328.2.1
	binutils-csl-sourcerygxx-4_1-12:1.327
	binutils-csl-sourcerygxx-3_4_4-21:1.327
	binutils-csl-wrs-linux-3_4_4-24:1.291.2.14
	binutils-csl-wrs-linux-3_4_4-23:1.291.2.14
	binutils-csl-sourcerygxx-4_1-9:1.327
	binutils-csl-sourcerygxx-4_1-8:1.327
	binutils-csl-sourcerygxx-4_1-7:1.327
	binutils-csl-arm-2006q1-6:1.327
	binutils-csl-sourcerygxx-4_1-6:1.327
	binutils-csl-wrs-linux-3_4_4-22:1.291.2.14
	binutils-csl-coldfire-4_1-11:1.327
	binutils-csl-sourcerygxx-3_4_4-19:1.327
	binutils-csl-coldfire-4_1-10:1.327
	binutils-csl-sourcerygxx-4_1-5:1.327
	binutils-csl-sourcerygxx-4_1-4:1.327
	binutils-csl-wrs-linux-3_4_4-21:1.291.2.14
	binutils-csl-morpho-4_1-4:1.327
	binutils-csl-sourcerygxx-3_4_4-17:1.327
	binutils-csl-wrs-linux-3_4_4-20:1.291.2.14
	binutils-2_17-branch:1.328.0.2
	binutils-2_17-branchpoint:1.328
	binutils-csl-2_17-branch:1.327.0.2
	binutils-csl-2_17-branchpoint:1.327
	binutils-csl-gxxpro-3_4-branch:1.291.2.20.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.291.2.20
	binutils-2_16_1:1.291.2.20
	binutils-csl-arm-2005q1b:1.291.2.14
	binutils-2_16:1.291.2.19
	binutils-csl-arm-2005q1a:1.291.2.14
	binutils-csl-arm-2005q1-branch:1.291.2.14.0.2
	binutils-csl-arm-2005q1-branchpoint:1.291.2.14
	binutils-2_16-branch:1.291.0.2
	binutils-2_16-branchpoint:1.291
	csl-arm-2004-q3d:1.273
	csl-arm-2004-q3:1.270
	binutils-2_15:1.253.4.3
	binutils-2_15-branchpoint:1.253
	csl-arm-2004-q1a:1.263
	csl-arm-2004-q1:1.254
	binutils-2_15-branch:1.253.0.4
	cagney_bfdfile-20040213-branch:1.253.0.2
	cagney_bfdfile-20040213-branchpoint:1.253
	cagney_bigcore-20040122-branch:1.247.0.2
	cagney_bigcore-20040122-branchpoint:1.247
	csl-arm-2003-q4:1.242
	binutils-2_14:1.204.2.3
	binutils-2_14-branch:1.204.0.2
	binutils-2_14-branchpoint:1.204
	binutils-2_13_2_1:1.147.2.6
	binutils-2_13_2:1.147.2.6
	binutils-2_13_1:1.147.2.6
	binutils-2_13:1.147.2.2
	binutils-2_13-branchpoint:1.147
	binutils-2_13-branch:1.147.0.2
	binutils-2_12_1:1.107.2.6
	binutils-2_12:1.107.2.5
	binutils-2_12-branch:1.107.0.2
	binutils-2_12-branchpoint:1.107
	cygnus_cvs_20020108_pre:1.104
	binutils-2_11_2:1.34.2.2
	binutils-2_11_1:1.34.2.2
	binutils-2_11:1.34
	x86_64versiong3:1.36
	binutils-2_11-branch:1.34.0.2
	binutils-2_10_1:1.13
	binutils-2_10:1.13
	binutils-2_10-branch:1.13.0.2
	binutils-2_10-branchpoint:1.13
	binutils_latest_snapshot:1.595
	repo-unification-2000-02-06:1.9
	binu_ss_19990721:1.4
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.595
date	2013.10.18.21.14.25;	author chaoyingfu;	state Exp;
branches;
next	1.594;

1.594
date	2013.10.14.18.50.54;	author chaoyingfu;	state Exp;
branches;
next	1.593;

1.593
date	2013.09.17.21.08.30;	author sje;	state Exp;
branches;
next	1.592;

1.592
date	2013.09.12.21.41.09;	author chaoyingfu;	state Exp;
branches;
next	1.591;

1.591
date	2013.08.19.20.07.09;	author rsandifo;	state Exp;
branches;
next	1.590;

1.590
date	2013.08.19.19.58.47;	author rsandifo;	state Exp;
branches;
next	1.589;

1.589
date	2013.08.19.19.56.44;	author rsandifo;	state Exp;
branches;
next	1.588;

1.588
date	2013.08.19.19.54.40;	author rsandifo;	state Exp;
branches;
next	1.587;

1.587
date	2013.08.19.19.42.50;	author rsandifo;	state Exp;
branches;
next	1.586;

1.586
date	2013.08.19.19.30.37;	author rsandifo;	state Exp;
branches;
next	1.585;

1.585
date	2013.08.19.19.26.10;	author rsandifo;	state Exp;
branches;
next	1.584;

1.584
date	2013.08.19.19.09.00;	author rsandifo;	state Exp;
branches;
next	1.583;

1.583
date	2013.08.19.19.00.32;	author rsandifo;	state Exp;
branches;
next	1.582;

1.582
date	2013.08.19.18.56.59;	author rsandifo;	state Exp;
branches;
next	1.581;

1.581
date	2013.08.06.19.27.06;	author rsandifo;	state Exp;
branches;
next	1.580;

1.580
date	2013.08.05.08.31.47;	author rsandifo;	state Exp;
branches;
next	1.579;

1.579
date	2013.08.04.07.31.38;	author rsandifo;	state Exp;
branches;
next	1.578;

1.578
date	2013.08.03.11.11.46;	author rsandifo;	state Exp;
branches;
next	1.577;

1.577
date	2013.08.03.10.49.48;	author rsandifo;	state Exp;
branches;
next	1.576;

1.576
date	2013.08.03.10.41.12;	author rsandifo;	state Exp;
branches;
next	1.575;

1.575
date	2013.08.01.20.55.24;	author rsandifo;	state Exp;
branches;
next	1.574;

1.574
date	2013.08.01.20.40.24;	author rsandifo;	state Exp;
branches;
next	1.573;

1.573
date	2013.08.01.20.32.59;	author rsandifo;	state Exp;
branches;
next	1.572;

1.572
date	2013.07.15.18.36.57;	author rsandifo;	state Exp;
branches;
next	1.571;

1.571
date	2013.07.14.14.16.02;	author rsandifo;	state Exp;
branches;
next	1.570;

1.570
date	2013.07.14.13.53.47;	author rsandifo;	state Exp;
branches;
next	1.569;

1.569
date	2013.07.14.13.52.52;	author rsandifo;	state Exp;
branches;
next	1.568;

1.568
date	2013.07.14.13.51.52;	author rsandifo;	state Exp;
branches;
next	1.567;

1.567
date	2013.07.14.13.49.14;	author rsandifo;	state Exp;
branches;
next	1.566;

1.566
date	2013.07.14.13.44.25;	author rsandifo;	state Exp;
branches;
next	1.565;

1.565
date	2013.07.14.13.37.50;	author rsandifo;	state Exp;
branches;
next	1.564;

1.564
date	2013.07.14.13.28.56;	author rsandifo;	state Exp;
branches;
next	1.563;

1.563
date	2013.07.14.13.17.55;	author rsandifo;	state Exp;
branches;
next	1.562;

1.562
date	2013.07.14.13.15.24;	author rsandifo;	state Exp;
branches;
next	1.561;

1.561
date	2013.07.14.13.13.43;	author rsandifo;	state Exp;
branches;
next	1.560;

1.560
date	2013.07.14.13.11.02;	author rsandifo;	state Exp;
branches;
next	1.559;

1.559
date	2013.07.12.15.58.14;	author macro;	state Exp;
branches;
next	1.558;

1.558
date	2013.07.08.08.39.31;	author rsandifo;	state Exp;
branches;
next	1.557;

1.557
date	2013.07.07.11.32.31;	author rsandifo;	state Exp;
branches;
next	1.556;

1.556
date	2013.07.07.10.15.08;	author rsandifo;	state Exp;
branches;
next	1.555;

1.555
date	2013.07.07.10.00.43;	author rsandifo;	state Exp;
branches;
next	1.554;

1.554
date	2013.07.07.09.50.42;	author rsandifo;	state Exp;
branches;
next	1.553;

1.553
date	2013.07.07.09.41.04;	author rsandifo;	state Exp;
branches;
next	1.552;

1.552
date	2013.07.07.09.32.55;	author rsandifo;	state Exp;
branches;
next	1.551;

1.551
date	2013.06.26.07.04.57;	author rsandifo;	state Exp;
branches;
next	1.550;

1.550
date	2013.06.25.18.02.33;	author macro;	state Exp;
branches;
next	1.549;

1.549
date	2013.06.23.20.12.52;	author rsandifo;	state Exp;
branches;
next	1.548;

1.548
date	2013.06.23.20.08.23;	author rsandifo;	state Exp;
branches;
next	1.547;

1.547
date	2013.06.22.16.49.07;	author rsandifo;	state Exp;
branches;
next	1.546;

1.546
date	2013.06.22.16.44.14;	author rsandifo;	state Exp;
branches;
next	1.545;

1.545
date	2013.06.20.19.25.20;	author rsandifo;	state Exp;
branches;
next	1.544;

1.544
date	2013.06.18.19.38.48;	author rsandifo;	state Exp;
branches;
next	1.543;

1.543
date	2013.06.18.19.37.21;	author rsandifo;	state Exp;
branches;
next	1.542;

1.542
date	2013.06.18.19.34.17;	author rsandifo;	state Exp;
branches;
next	1.541;

1.541
date	2013.06.17.22.59.09;	author clm;	state Exp;
branches;
next	1.540;

1.540
date	2013.06.14.13.30.28;	author rsandifo;	state Exp;
branches;
next	1.539;

1.539
date	2013.06.13.20.58.44;	author chaoyingfu;	state Exp;
branches;
next	1.538;

1.538
date	2013.06.10.18.15.47;	author macro;	state Exp;
branches;
next	1.537;

1.537
date	2013.06.08.10.22.55;	author rsandifo;	state Exp;
branches;
next	1.536;

1.536
date	2013.05.31.17.04.52;	author clm;	state Exp;
branches;
next	1.535;

1.535
date	2013.05.30.20.27.21;	author clm;	state Exp;
branches;
next	1.534;

1.534
date	2013.05.28.22.19.33;	author macro;	state Exp;
branches;
next	1.533;

1.533
date	2013.05.22.18.08.25;	author rsandifo;	state Exp;
branches;
next	1.532;

1.532
date	2013.05.10.01.08.48;	author pinskia;	state Exp;
branches;
next	1.531;

1.531
date	2013.05.06.15.25.45;	author clm;	state Exp;
branches;
next	1.530;

1.530
date	2013.05.06.15.00.01;	author clm;	state Exp;
branches;
next	1.529;

1.529
date	2013.05.02.22.30.11;	author rsandifo;	state Exp;
branches;
next	1.528;

1.528
date	2013.05.01.01.02.01;	author chaoyingfu;	state Exp;
branches;
next	1.527;

1.527
date	2013.02.18.23.27.23;	author macro;	state Exp;
branches;
next	1.526;

1.526
date	2013.02.18.14.02.02;	author macro;	state Exp;
branches;
next	1.525;

1.525
date	2013.02.09.10.24.18;	author rsandifo;	state Exp;
branches;
next	1.524;

1.524
date	2013.01.09.18.31.21;	author sje;	state Exp;
branches;
next	1.523;

1.523
date	2013.01.04.17.22.48;	author nickc;	state Exp;
branches;
next	1.522;

1.522
date	2012.11.08.18.21.24;	author macro;	state Exp;
branches;
next	1.521;

1.521
date	2012.11.01.23.03.16;	author macro;	state Exp;
branches;
next	1.520;

1.520
date	2012.11.01.22.54.11;	author macro;	state Exp;
branches;
next	1.519;

1.519
date	2012.11.01.22.49.27;	author macro;	state Exp;
branches;
next	1.518;

1.518
date	2012.09.23.11.14.25;	author rsandifo;	state Exp;
branches;
next	1.517;

1.517
date	2012.09.23.10.46.37;	author rsandifo;	state Exp;
branches;
next	1.516;

1.516
date	2012.09.23.10.41.23;	author rsandifo;	state Exp;
branches;
next	1.515;

1.515
date	2012.09.23.09.59.24;	author rsandifo;	state Exp;
branches;
next	1.514;

1.514
date	2012.09.23.09.56.47;	author rsandifo;	state Exp;
branches;
next	1.513;

1.513
date	2012.09.23.09.31.14;	author rsandifo;	state Exp;
branches;
next	1.512;

1.512
date	2012.09.23.09.23.23;	author rsandifo;	state Exp;
branches;
next	1.511;

1.511
date	2012.08.13.14.26.09;	author macro;	state Exp;
branches;
next	1.510;

1.510
date	2012.08.13.14.09.44;	author macro;	state Exp;
branches;
next	1.509;

1.509
date	2012.08.06.20.32.59;	author macro;	state Exp;
branches;
next	1.508;

1.508
date	2012.08.01.19.59.43;	author sandra;	state Exp;
branches;
next	1.507;

1.507
date	2012.07.31.21.38.53;	author macro;	state Exp;
branches;
next	1.506;

1.506
date	2012.05.22.01.55.16;	author vapier;	state Exp;
branches
	1.506.2.1;
next	1.505;

1.505
date	2012.05.05.03.05.27;	author amodra;	state Exp;
branches;
next	1.504;

1.504
date	2012.03.24.01.09.27;	author mkuvyrkov;	state Exp;
branches;
next	1.503;

1.503
date	2012.01.08.12.33.53;	author rsandifo;	state Exp;
branches;
next	1.502;

1.502
date	2012.01.08.12.11.39;	author rsandifo;	state Exp;
branches;
next	1.501;

1.501
date	2011.12.19.07.58.01;	author cltang;	state Exp;
branches;
next	1.500;

1.500
date	2011.12.08.20.47.25;	author pinskia;	state Exp;
branches;
next	1.499;

1.499
date	2011.11.29.20.28.54;	author pinskia;	state Exp;
branches;
next	1.498;

1.498
date	2011.11.16.12.34.33;	author macro;	state Exp;
branches;
next	1.497;

1.497
date	2011.11.16.12.29.56;	author macro;	state Exp;
branches;
next	1.496;

1.496
date	2011.11.16.12.27.06;	author macro;	state Exp;
branches;
next	1.495;

1.495
date	2011.11.16.12.21.34;	author macro;	state Exp;
branches;
next	1.494;

1.494
date	2011.11.14.13.43.21;	author macro;	state Exp;
branches;
next	1.493;

1.493
date	2011.10.24.14.25.01;	author macro;	state Exp;
branches;
next	1.492;

1.492
date	2011.10.24.14.17.10;	author macro;	state Exp;
branches;
next	1.491;

1.491
date	2011.10.24.14.08.23;	author macro;	state Exp;
branches;
next	1.490;

1.490
date	2011.10.24.14.04.42;	author macro;	state Exp;
branches;
next	1.489;

1.489
date	2011.10.19.23.09.11;	author amodra;	state Exp;
branches;
next	1.488;

1.488
date	2011.08.10.22.55.57;	author macro;	state Exp;
branches
	1.488.2.1;
next	1.487;

1.487
date	2011.08.09.15.25.31;	author macro;	state Exp;
branches;
next	1.486;

1.486
date	2011.08.09.15.20.01;	author macro;	state Exp;
branches;
next	1.485;

1.485
date	2011.08.09.14.25.28;	author macro;	state Exp;
branches;
next	1.484;

1.484
date	2011.08.09.13.39.39;	author macro;	state Exp;
branches;
next	1.483;

1.483
date	2011.08.06.10.25.01;	author rsandifo;	state Exp;
branches;
next	1.482;

1.482
date	2011.08.06.10.02.03;	author rsandifo;	state Exp;
branches;
next	1.481;

1.481
date	2011.07.30.06.28.21;	author rsandifo;	state Exp;
branches;
next	1.480;

1.480
date	2011.07.29.22.46.28;	author macro;	state Exp;
branches;
next	1.479;

1.479
date	2011.07.24.14.20.08;	author rsandifo;	state Exp;
branches;
next	1.478;

1.478
date	2011.07.24.14.05.27;	author rsandifo;	state Exp;
branches;
next	1.477;

1.477
date	2011.07.24.14.04.50;	author rsandifo;	state Exp;
branches;
next	1.476;

1.476
date	2011.07.06.18.01.51;	author rsandifo;	state Exp;
branches;
next	1.475;

1.475
date	2011.07.04.20.22.52;	author rsandifo;	state Exp;
branches;
next	1.474;

1.474
date	2011.07.04.19.27.28;	author macro;	state Exp;
branches;
next	1.473;

1.473
date	2011.06.29.21.05.29;	author rsandifo;	state Exp;
branches;
next	1.472;

1.472
date	2011.06.29.20.48.10;	author rsandifo;	state Exp;
branches;
next	1.471;

1.471
date	2011.06.29.20.46.09;	author rsandifo;	state Exp;
branches;
next	1.470;

1.470
date	2011.06.29.20.42.47;	author rsandifo;	state Exp;
branches;
next	1.469;

1.469
date	2011.06.29.20.38.59;	author rsandifo;	state Exp;
branches;
next	1.468;

1.468
date	2011.06.29.20.35.04;	author rsandifo;	state Exp;
branches;
next	1.467;

1.467
date	2011.06.26.09.19.17;	author rsandifo;	state Exp;
branches;
next	1.466;

1.466
date	2011.06.26.09.16.35;	author rsandifo;	state Exp;
branches;
next	1.465;

1.465
date	2011.06.26.08.32.49;	author rsandifo;	state Exp;
branches;
next	1.464;

1.464
date	2011.06.25.10.11.45;	author rsandifo;	state Exp;
branches;
next	1.463;

1.463
date	2011.06.23.20.21.37;	author rsandifo;	state Exp;
branches;
next	1.462;

1.462
date	2011.04.20.16.45.35;	author clm;	state Exp;
branches;
next	1.461;

1.461
date	2011.02.28.16.26.45;	author macro;	state Exp;
branches;
next	1.460;

1.460
date	2011.02.28.16.06.50;	author macro;	state Exp;
branches;
next	1.459;

1.459
date	2011.02.28.15.52.24;	author macro;	state Exp;
branches;
next	1.458;

1.458
date	2011.02.28.15.44.53;	author macro;	state Exp;
branches;
next	1.457;

1.457
date	2011.02.28.15.33.23;	author macro;	state Exp;
branches;
next	1.456;

1.456
date	2011.02.21.23.27.02;	author macro;	state Exp;
branches;
next	1.455;

1.455
date	2011.01.11.07.22.06;	author xmj;	state Exp;
branches;
next	1.454;

1.454
date	2010.12.31.11.00.56;	author rsandifo;	state Exp;
branches;
next	1.453;

1.453
date	2010.12.18.11.14.13;	author rsandifo;	state Exp;
branches;
next	1.452;

1.452
date	2010.12.16.18.48.28;	author macro;	state Exp;
branches;
next	1.451;

1.451
date	2010.12.10.14.25.04;	author macro;	state Exp;
branches;
next	1.450;

1.450
date	2010.12.09.23.59.12;	author macro;	state Exp;
branches;
next	1.449;

1.449
date	2010.12.09.23.57.21;	author macro;	state Exp;
branches;
next	1.448;

1.448
date	2010.12.09.23.46.06;	author macro;	state Exp;
branches;
next	1.447;

1.447
date	2010.12.09.23.43.32;	author macro;	state Exp;
branches;
next	1.446;

1.446
date	2010.12.09.23.33.24;	author macro;	state Exp;
branches;
next	1.445;

1.445
date	2010.12.09.23.21.51;	author macro;	state Exp;
branches;
next	1.444;

1.444
date	2010.12.09.23.19.22;	author macro;	state Exp;
branches;
next	1.443;

1.443
date	2010.12.09.22.56.46;	author macro;	state Exp;
branches;
next	1.442;

1.442
date	2010.12.09.22.52.54;	author macro;	state Exp;
branches;
next	1.441;

1.441
date	2010.12.09.22.45.13;	author macro;	state Exp;
branches;
next	1.440;

1.440
date	2010.12.09.22.29.18;	author macro;	state Exp;
branches;
next	1.439;

1.439
date	2010.12.09.22.17.27;	author macro;	state Exp;
branches;
next	1.438;

1.438
date	2010.12.09.22.09.40;	author macro;	state Exp;
branches;
next	1.437;

1.437
date	2010.12.09.22.04.42;	author macro;	state Exp;
branches;
next	1.436;

1.436
date	2010.12.09.19.07.07;	author macro;	state Exp;
branches;
next	1.435;

1.435
date	2010.12.01.20.30.04;	author macro;	state Exp;
branches;
next	1.434;

1.434
date	2010.11.23.17.04.10;	author nickc;	state Exp;
branches;
next	1.433;

1.433
date	2010.11.13.11.59.20;	author rsandifo;	state Exp;
branches;
next	1.432;

1.432
date	2010.11.11.10.23.36;	author nickc;	state Exp;
branches;
next	1.431;

1.431
date	2010.11.01.09.53.55;	author macro;	state Exp;
branches
	1.431.2.1;
next	1.430;

1.430
date	2010.10.25.21.15.14;	author rsandifo;	state Exp;
branches;
next	1.429;

1.429
date	2010.10.18.00.17.43;	author macro;	state Exp;
branches;
next	1.428;

1.428
date	2010.10.18.00.15.33;	author macro;	state Exp;
branches;
next	1.427;

1.427
date	2010.10.18.00.11.08;	author macro;	state Exp;
branches;
next	1.426;

1.426
date	2010.10.04.15.24.48;	author daney;	state Exp;
branches;
next	1.425;

1.425
date	2010.07.27.21.04.59;	author macro;	state Exp;
branches;
next	1.424;

1.424
date	2010.07.27.21.02.34;	author macro;	state Exp;
branches;
next	1.423;

1.423
date	2010.07.24.01.51.52;	author macro;	state Exp;
branches;
next	1.422;

1.422
date	2010.07.22.07.39.20;	author tschwinge;	state Exp;
branches;
next	1.421;

1.421
date	2010.07.06.00.12.41;	author macro;	state Exp;
branches;
next	1.420;

1.420
date	2010.07.06.00.02.43;	author macro;	state Exp;
branches;
next	1.419;

1.419
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.418;

1.418
date	2010.05.26.12.59.55;	author clm;	state Exp;
branches;
next	1.417;

1.417
date	2010.02.25.11.15.47;	author nickc;	state Exp;
branches;
next	1.416;

1.416
date	2009.12.19.00.21.28;	author macro;	state Exp;
branches;
next	1.415;

1.415
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.414;

1.414
date	2009.09.13.19.18.11;	author rsandifo;	state Exp;
branches;
next	1.413;

1.413
date	2009.09.05.07.56.24;	author nickc;	state Exp;
branches;
next	1.412;

1.412
date	2009.08.05.21.22.15;	author chaoyingfu;	state Exp;
branches
	1.412.2.1;
next	1.411;

1.411
date	2009.08.05.00.44.01;	author sandra;	state Exp;
branches;
next	1.410;

1.410
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.409;

1.409
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.408;

1.408
date	2009.05.27.14.14.42;	author clm;	state Exp;
branches;
next	1.407;

1.407
date	2009.05.23.08.28.21;	author rsandifo;	state Exp;
branches;
next	1.406;

1.406
date	2009.04.22.11.40.25;	author nathan;	state Exp;
branches;
next	1.405;

1.405
date	2009.04.09.15.55.59;	author clm;	state Exp;
branches;
next	1.404;

1.404
date	2009.04.09.15.28.56;	author nemet;	state Exp;
branches;
next	1.403;

1.403
date	2009.02.03.18.16.03;	author jsm28;	state Exp;
branches;
next	1.402;

1.402
date	2009.01.27.13.48.14;	author nickc;	state Exp;
branches;
next	1.401;

1.401
date	2009.01.23.14.56.38;	author schwab;	state Exp;
branches;
next	1.400;

1.400
date	2009.01.06.19.22.11;	author chaoyingfu;	state Exp;
branches;
next	1.399;

1.399
date	2008.11.28.18.02.17;	author ths;	state Exp;
branches;
next	1.398;

1.398
date	2008.11.06.19.49.26;	author nemet;	state Exp;
branches;
next	1.397;

1.397
date	2008.11.06.19.36.38;	author chaoyingfu;	state Exp;
branches;
next	1.396;

1.396
date	2008.10.24.19.11.38;	author macro;	state Exp;
branches;
next	1.395;

1.395
date	2008.10.20.01.03.50;	author amodra;	state Exp;
branches;
next	1.394;

1.394
date	2008.08.08.19.24.49;	author drow;	state Exp;
branches
	1.394.2.1;
next	1.393;

1.393
date	2008.08.06.19.44.47;	author rsandifo;	state Exp;
branches;
next	1.392;

1.392
date	2008.08.04.10.55.48;	author amodra;	state Exp;
branches;
next	1.391;

1.391
date	2008.07.22.10.44.50;	author nickc;	state Exp;
branches;
next	1.390;

1.390
date	2008.07.10.19.05.29;	author rsandifo;	state Exp;
branches;
next	1.389;

1.389
date	2008.07.07.19.16.23;	author nemet;	state Exp;
branches;
next	1.388;

1.388
date	2008.06.12.21.44.53;	author nickc;	state Exp;
branches;
next	1.387;

1.387
date	2008.06.12.16.14.51;	author nickc;	state Exp;
branches;
next	1.386;

1.386
date	2008.05.29.16.03.41;	author nemet;	state Exp;
branches;
next	1.385;

1.385
date	2008.05.09.19.28.47;	author clm;	state Exp;
branches;
next	1.384;

1.384
date	2008.05.09.18.18.22;	author chaoyingfu;	state Exp;
branches;
next	1.383;

1.383
date	2008.04.28.17.06.28;	author nemet;	state Exp;
branches;
next	1.382;

1.382
date	2008.02.04.19.20.16;	author nemet;	state Exp;
branches;
next	1.381;

1.381
date	2008.01.02.20.58.06;	author clm;	state Exp;
branches;
next	1.380;

1.380
date	2007.12.10.10.36.00;	author rsandifo;	state Exp;
branches;
next	1.379;

1.379
date	2007.11.29.12.23.43;	author shinwell;	state Exp;
branches;
next	1.378;

1.378
date	2007.11.17.14.19.19;	author ths;	state Exp;
branches;
next	1.377;

1.377
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.376;

1.376
date	2007.10.08.16.09.34;	author macro;	state Exp;
branches;
next	1.375;

1.375
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.374;

1.374
date	2007.09.24.22.08.20;	author carlos;	state Exp;
branches;
next	1.373;

1.373
date	2007.07.11.15.11.15;	author drow;	state Exp;
branches;
next	1.372;

1.372
date	2007.07.04.19.55.18;	author rsandifo;	state Exp;
branches;
next	1.371;

1.371
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.370;

1.370
date	2007.07.02.10.49.42;	author jsm28;	state Exp;
branches;
next	1.369;

1.369
date	2007.06.25.10.13.57;	author rsandifo;	state Exp;
branches;
next	1.368;

1.368
date	2007.05.18.19.03.53;	author jsm28;	state Exp;
branches;
next	1.367;

1.367
date	2007.05.14.12.28.45;	author ths;	state Exp;
branches;
next	1.366;

1.366
date	2007.04.28.22.12.58;	author ths;	state Exp;
branches;
next	1.365;

1.365
date	2007.04.02.14.25.27;	author rsandifo;	state Exp;
branches;
next	1.364;

1.364
date	2007.02.20.14.48.28;	author ths;	state Exp;
branches;
next	1.363;

1.363
date	2007.02.20.13.28.52;	author ths;	state Exp;
branches;
next	1.362;

1.362
date	2007.01.03.18.12.52;	author daney;	state Exp;
branches;
next	1.361;

1.361
date	2006.11.09.13.04.39;	author ths;	state Exp;
branches;
next	1.360;

1.360
date	2006.11.07.23.55.36;	author daney;	state Exp;
branches;
next	1.359;

1.359
date	2006.11.06.14.28.21;	author ths;	state Exp;
branches;
next	1.358;

1.358
date	2006.11.03.16.32.04;	author ths;	state Exp;
branches;
next	1.357;

1.357
date	2006.11.03.16.27.41;	author ths;	state Exp;
branches;
next	1.356;

1.356
date	2006.11.03.12.36.39;	author ths;	state Exp;
branches;
next	1.355;

1.355
date	2006.08.12.23.00.34;	author ths;	state Exp;
branches;
next	1.354;

1.354
date	2006.08.01.07.58.22;	author ths;	state Exp;
branches;
next	1.353;

1.353
date	2006.08.01.05.49.02;	author ths;	state Exp;
branches;
next	1.352;

1.352
date	2006.07.31.17.23.31;	author ths;	state Exp;
branches;
next	1.351;

1.351
date	2006.07.20.16.51.38;	author ths;	state Exp;
branches;
next	1.350;

1.350
date	2006.07.20.16.46.30;	author ths;	state Exp;
branches;
next	1.349;

1.349
date	2006.07.17.10.40.11;	author ths;	state Exp;
branches;
next	1.348;

1.348
date	2006.07.07.23.17.55;	author wilson;	state Exp;
branches;
next	1.347;

1.347
date	2006.07.04.17.22.11;	author ths;	state Exp;
branches;
next	1.346;

1.346
date	2006.06.23.18.31.17;	author ths;	state Exp;
branches;
next	1.345;

1.345
date	2006.06.23.16.26.13;	author ths;	state Exp;
branches;
next	1.344;

1.344
date	2006.06.22.14.09.40;	author ths;	state Exp;
branches;
next	1.343;

1.343
date	2006.06.09.12.55.00;	author ths;	state Exp;
branches;
next	1.342;

1.342
date	2006.06.08.15.28.26;	author ths;	state Exp;
branches;
next	1.341;

1.341
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.340;

1.340
date	2006.06.06.10.49.48;	author ths;	state Exp;
branches;
next	1.339;

1.339
date	2006.06.05.16.28.36;	author ths;	state Exp;
branches;
next	1.338;

1.338
date	2006.05.23.15.37.20;	author ths;	state Exp;
branches;
next	1.337;

1.337
date	2006.05.19.13.03.05;	author ths;	state Exp;
branches;
next	1.336;

1.336
date	2006.05.19.12.34.09;	author ths;	state Exp;
branches;
next	1.335;

1.335
date	2006.05.14.15.35.21;	author ths;	state Exp;
branches;
next	1.334;

1.334
date	2006.05.11.14.30.57;	author ths;	state Exp;
branches;
next	1.333;

1.333
date	2006.05.09.14.16.49;	author ths;	state Exp;
branches;
next	1.332;

1.332
date	2006.05.08.15.57.05;	author ths;	state Exp;
branches;
next	1.331;

1.331
date	2006.05.05.15.41.23;	author ths;	state Exp;
branches;
next	1.330;

1.330
date	2006.04.30.18.34.39;	author ths;	state Exp;
branches;
next	1.329;

1.329
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.328;

1.328
date	2006.03.22.09.28.13;	author rsandifo;	state Exp;
branches
	1.328.2.1;
next	1.327;

1.327
date	2005.11.23.14.04.17;	author drow;	state Exp;
branches
	1.327.2.1;
next	1.326;

1.326
date	2005.11.14.02.25.39;	author ths;	state Exp;
branches;
next	1.325;

1.325
date	2005.11.01.01.59.28;	author ths;	state Exp;
branches;
next	1.324;

1.324
date	2005.10.19.18.47.09;	author davidu;	state Exp;
branches;
next	1.323;

1.323
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.322;

1.322
date	2005.09.20.18.24.47;	author rth;	state Exp;
branches;
next	1.321;

1.321
date	2005.09.07.11.39.17;	author davidu;	state Exp;
branches;
next	1.320;

1.320
date	2005.09.06.18.53.02;	author chaoyingfu;	state Exp;
branches;
next	1.319;

1.319
date	2005.09.01.16.35.41;	author davidu;	state Exp;
branches;
next	1.318;

1.318
date	2005.08.25.18.17.36;	author chaoyingfu;	state Exp;
branches;
next	1.317;

1.317
date	2005.08.23.11.32.42;	author davidu;	state Exp;
branches;
next	1.316;

1.316
date	2005.07.30.13.53.11;	author ths;	state Exp;
branches;
next	1.315;

1.315
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.314;

1.314
date	2005.06.07.12.09.26;	author macro;	state Exp;
branches;
next	1.313;

1.313
date	2005.06.01.19.23.57;	author macro;	state Exp;
branches;
next	1.312;

1.312
date	2005.05.05.09.12.59;	author nickc;	state Exp;
branches;
next	1.311;

1.311
date	2005.04.20.14.35.40;	author nickc;	state Exp;
branches;
next	1.310;

1.310
date	2005.04.18.14.16.10;	author macro;	state Exp;
branches;
next	1.309;

1.309
date	2005.04.15.19.16.44;	author macro;	state Exp;
branches;
next	1.308;

1.308
date	2005.04.14.15.32.58;	author macro;	state Exp;
branches;
next	1.307;

1.307
date	2005.04.13.18.17.09;	author macro;	state Exp;
branches;
next	1.306;

1.306
date	2005.04.10.16.25.51;	author hjl;	state Exp;
branches;
next	1.305;

1.305
date	2005.03.21.21.59.34;	author macro;	state Exp;
branches;
next	1.304;

1.304
date	2005.03.15.05.28.14;	author echristo;	state Exp;
branches;
next	1.303;

1.303
date	2005.03.09.11.56.15;	author rsandifo;	state Exp;
branches;
next	1.302;

1.302
date	2005.03.09.09.39.30;	author rsandifo;	state Exp;
branches;
next	1.301;

1.301
date	2005.03.09.09.34.56;	author rsandifo;	state Exp;
branches;
next	1.300;

1.300
date	2005.03.09.09.22.24;	author rsandifo;	state Exp;
branches;
next	1.299;

1.299
date	2005.03.09.09.21.18;	author rsandifo;	state Exp;
branches;
next	1.298;

1.298
date	2005.03.09.09.20.27;	author rsandifo;	state Exp;
branches;
next	1.297;

1.297
date	2005.03.09.09.17.41;	author rsandifo;	state Exp;
branches;
next	1.296;

1.296
date	2005.03.09.09.17.02;	author rsandifo;	state Exp;
branches;
next	1.295;

1.295
date	2005.03.09.09.15.35;	author rsandifo;	state Exp;
branches;
next	1.294;

1.294
date	2005.03.09.09.14.20;	author rsandifo;	state Exp;
branches;
next	1.293;

1.293
date	2005.03.09.09.13.18;	author rsandifo;	state Exp;
branches;
next	1.292;

1.292
date	2005.03.09.09.12.29;	author rsandifo;	state Exp;
branches;
next	1.291;

1.291
date	2005.03.05.00.01.39;	author ths;	state Exp;
branches
	1.291.2.1;
next	1.290;

1.290
date	2005.03.04.09.51.07;	author rsandifo;	state Exp;
branches;
next	1.289;

1.289
date	2005.03.03.19.53.18;	author ths;	state Exp;
branches;
next	1.288;

1.288
date	2005.03.02.21.23.33;	author drow;	state Exp;
branches;
next	1.287;

1.287
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.286;

1.286
date	2005.02.22.23.54.41;	author echristo;	state Exp;
branches;
next	1.285;

1.285
date	2005.02.22.12.32.24;	author macro;	state Exp;
branches;
next	1.284;

1.284
date	2005.02.18.22.12.50;	author ths;	state Exp;
branches;
next	1.283;

1.283
date	2005.02.17.13.46.04;	author amodra;	state Exp;
branches;
next	1.282;

1.282
date	2005.02.16.15.49.13;	author ths;	state Exp;
branches;
next	1.281;

1.281
date	2005.02.15.19.57.52;	author macro;	state Exp;
branches;
next	1.280;

1.280
date	2005.01.31.23.18.30;	author bje;	state Exp;
branches;
next	1.279;

1.279
date	2005.01.19.23.33.33;	author fnf;	state Exp;
branches;
next	1.278;

1.278
date	2004.12.11.03.41.31;	author ian;	state Exp;
branches;
next	1.277;

1.277
date	2004.12.10.19.48.18;	author ian;	state Exp;
branches;
next	1.276;

1.276
date	2004.12.09.15.51.32;	author ian;	state Exp;
branches;
next	1.275;

1.275
date	2004.12.09.06.17.14;	author ian;	state Exp;
branches;
next	1.274;

1.274
date	2004.11.10.03.28.45;	author amodra;	state Exp;
branches;
next	1.273;

1.273
date	2004.10.07.22.29.18;	author rsandifo;	state Exp;
branches;
next	1.272;

1.272
date	2004.10.07.19.12.52;	author rsandifo;	state Exp;
branches;
next	1.271;

1.271
date	2004.10.04.23.25.28;	author echristo;	state Exp;
branches;
next	1.270;

1.270
date	2004.08.18.15.58.11;	author ths;	state Exp;
branches;
next	1.269;

1.269
date	2004.07.20.17.55.02;	author macro;	state Exp;
branches;
next	1.268;

1.268
date	2004.07.08.15.39.42;	author rsandifo;	state Exp;
branches;
next	1.267;

1.267
date	2004.07.03.15.20.52;	author rsandifo;	state Exp;
branches;
next	1.266;

1.266
date	2004.06.15.01.16.35;	author amodra;	state Exp;
branches;
next	1.265;

1.265
date	2004.05.20.10.10.43;	author rsandifo;	state Exp;
branches;
next	1.264;

1.264
date	2004.05.07.16.39.26;	author rsandifo;	state Exp;
branches;
next	1.263;

1.263
date	2004.04.29.05.14.21;	author cgd;	state Exp;
branches;
next	1.262;

1.262
date	2004.04.23.17.25.50;	author ths;	state Exp;
branches;
next	1.261;

1.261
date	2004.04.23.04.50.53;	author cgd;	state Exp;
branches;
next	1.260;

1.260
date	2004.04.23.02.07.14;	author ths;	state Exp;
branches;
next	1.259;

1.259
date	2004.04.22.22.00.47;	author ths;	state Exp;
branches;
next	1.258;

1.258
date	2004.04.22.18.13.55;	author ths;	state Exp;
branches;
next	1.257;

1.257
date	2004.04.22.17.58.56;	author ths;	state Exp;
branches;
next	1.256;

1.256
date	2004.04.19.21.08.43;	author echristo;	state Exp;
branches;
next	1.255;

1.255
date	2004.04.14.07.48.49;	author rsandifo;	state Exp;
branches;
next	1.254;

1.254
date	2004.02.26.21.27.32;	author echristo;	state Exp;
branches;
next	1.253;

1.253
date	2004.02.02.12.48.19;	author macro;	state Exp;
branches
	1.253.4.1;
next	1.252;

1.252
date	2004.01.25.06.01.03;	author cgd;	state Exp;
branches;
next	1.251;

1.251
date	2004.01.23.13.11.00;	author rsandifo;	state Exp;
branches;
next	1.250;

1.250
date	2004.01.23.13.02.28;	author rsandifo;	state Exp;
branches;
next	1.249;

1.249
date	2004.01.23.13.00.18;	author rsandifo;	state Exp;
branches;
next	1.248;

1.248
date	2004.01.23.12.58.21;	author rsandifo;	state Exp;
branches;
next	1.247;

1.247
date	2004.01.21.23.25.38;	author ths;	state Exp;
branches;
next	1.246;

1.246
date	2004.01.14.18.01.07;	author macro;	state Exp;
branches;
next	1.245;

1.245
date	2004.01.12.09.30.49;	author rsandifo;	state Exp;
branches;
next	1.244;

1.244
date	2004.01.09.02.34.04;	author ian;	state Exp;
branches;
next	1.243;

1.243
date	2004.01.09.02.16.30;	author ian;	state Exp;
branches;
next	1.242;

1.242
date	2003.12.18.10.23.09;	author rsandifo;	state Exp;
branches;
next	1.241;

1.241
date	2003.12.18.10.18.17;	author rsandifo;	state Exp;
branches;
next	1.240;

1.240
date	2003.12.06.13.52.23;	author rsandifo;	state Exp;
branches;
next	1.239;

1.239
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches;
next	1.238;

1.238
date	2003.11.18.21.22.52;	author macro;	state Exp;
branches;
next	1.237;

1.237
date	2003.11.15.15.57.14;	author macro;	state Exp;
branches;
next	1.236;

1.236
date	2003.10.19.21.50.43;	author ths;	state Exp;
branches;
next	1.235;

1.235
date	2003.10.15.11.12.53;	author ths;	state Exp;
branches;
next	1.234;

1.234
date	2003.10.01.18.57.16;	author ths;	state Exp;
branches;
next	1.233;

1.233
date	2003.10.01.06.09.31;	author cgd;	state Exp;
branches;
next	1.232;

1.232
date	2003.10.01.02.07.48;	author ths;	state Exp;
branches;
next	1.231;

1.231
date	2003.09.30.21.02.07;	author cgd;	state Exp;
branches;
next	1.230;

1.230
date	2003.09.30.16.17.12;	author cgd;	state Exp;
branches;
next	1.229;

1.229
date	2003.09.18.05.20.04;	author ths;	state Exp;
branches;
next	1.228;

1.228
date	2003.09.14.15.24.49;	author ths;	state Exp;
branches;
next	1.227;

1.227
date	2003.07.28.20.06.26;	author ro;	state Exp;
branches;
next	1.226;

1.226
date	2003.07.15.07.50.38;	author rsandifo;	state Exp;
branches;
next	1.225;

1.225
date	2003.07.09.01.27.30;	author cgd;	state Exp;
branches;
next	1.224;

1.224
date	2003.06.30.21.54.19;	author cgd;	state Exp;
branches;
next	1.223;

1.223
date	2003.06.30.12.44.25;	author ths;	state Exp;
branches;
next	1.222;

1.222
date	2003.06.30.04.10.48;	author amodra;	state Exp;
branches;
next	1.221;

1.221
date	2003.06.29.19.41.33;	author ths;	state Exp;
branches;
next	1.220;

1.220
date	2003.06.24.11.10.42;	author nickc;	state Exp;
branches;
next	1.219;

1.219
date	2003.06.21.21.38.03;	author ths;	state Exp;
branches;
next	1.218;

1.218
date	2003.06.19.16.43.38;	author ths;	state Exp;
branches;
next	1.217;

1.217
date	2003.06.16.12.13.10;	author ths;	state Exp;
branches;
next	1.216;

1.216
date	2003.06.12.05.45.50;	author rsandifo;	state Exp;
branches;
next	1.215;

1.215
date	2003.06.11.20.59.09;	author ths;	state Exp;
branches;
next	1.214;

1.214
date	2003.06.11.20.53.32;	author ths;	state Exp;
branches;
next	1.213;

1.213
date	2003.06.11.16.22.26;	author ths;	state Exp;
branches;
next	1.212;

1.212
date	2003.06.04.06.38.38;	author cgd;	state Exp;
branches;
next	1.211;

1.211
date	2003.05.23.22.26.20;	author echristo;	state Exp;
branches;
next	1.210;

1.210
date	2003.05.22.09.19.33;	author ths;	state Exp;
branches;
next	1.209;

1.209
date	2003.05.22.09.15.12;	author ths;	state Exp;
branches;
next	1.208;

1.208
date	2003.05.21.21.53.33;	author echristo;	state Exp;
branches;
next	1.207;

1.207
date	2003.05.07.05.10.45;	author aoliva;	state Exp;
branches;
next	1.206;

1.206
date	2003.05.06.00.28.25;	author hjl;	state Exp;
branches;
next	1.205;

1.205
date	2003.05.06.00.16.12;	author drow;	state Exp;
branches;
next	1.204;

1.204
date	2003.04.25.04.40.09;	author echristo;	state Exp;
branches
	1.204.2.1;
next	1.203;

1.203
date	2003.04.11.01.56.49;	author aoliva;	state Exp;
branches;
next	1.202;

1.202
date	2003.04.09.03.09.12;	author aoliva;	state Exp;
branches;
next	1.201;

1.201
date	2003.04.09.03.07.48;	author aoliva;	state Exp;
branches;
next	1.200;

1.200
date	2003.04.06.03.16.20;	author aoliva;	state Exp;
branches;
next	1.199;

1.199
date	2003.04.02.18.43.16;	author cgd;	state Exp;
branches;
next	1.198;

1.198
date	2003.03.26.23.32.06;	author echristo;	state Exp;
branches;
next	1.197;

1.197
date	2003.03.12.23.07.37;	author aoliva;	state Exp;
branches;
next	1.196;

1.196
date	2003.03.12.23.06.08;	author aoliva;	state Exp;
branches;
next	1.195;

1.195
date	2003.03.09.16.16.31;	author ths;	state Exp;
branches;
next	1.194;

1.194
date	2003.03.02.21.30.15;	author ths;	state Exp;
branches;
next	1.193;

1.193
date	2003.02.21.10.28.27;	author rsandifo;	state Exp;
branches;
next	1.192;

1.192
date	2003.02.08.17.05.54;	author rsandifo;	state Exp;
branches;
next	1.191;

1.191
date	2003.02.07.15.06.33;	author rsandifo;	state Exp;
branches;
next	1.190;

1.190
date	2003.02.02.19.37.20;	author rsandifo;	state Exp;
branches;
next	1.189;

1.189
date	2003.01.27.22.45.58;	author aoliva;	state Exp;
branches;
next	1.188;

1.188
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches;
next	1.187;

1.187
date	2003.01.02.20.03.07;	author cgd;	state Exp;
branches;
next	1.186;

1.186
date	2002.12.31.08.11.17;	author cgd;	state Exp;
branches;
next	1.185;

1.185
date	2002.12.31.07.29.27;	author cgd;	state Exp;
branches;
next	1.184;

1.184
date	2002.12.18.22.52.46;	author cgd;	state Exp;
branches;
next	1.183;

1.183
date	2002.12.17.01.13.55;	author kazu;	state Exp;
branches;
next	1.182;

1.182
date	2002.12.12.04.40.07;	author aoliva;	state Exp;
branches;
next	1.181;

1.181
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.180;

1.180
date	2002.11.18.21.08.53;	author kevinb;	state Exp;
branches;
next	1.179;

1.179
date	2002.11.18.20.45.48;	author aoliva;	state Exp;
branches;
next	1.178;

1.178
date	2002.11.18.20.41.03;	author aoliva;	state Exp;
branches;
next	1.177;

1.177
date	2002.11.07.02.29.32;	author aoliva;	state Exp;
branches;
next	1.176;

1.176
date	2002.11.05.21.53.13;	author hjl;	state Exp;
branches;
next	1.175;

1.175
date	2002.10.21.14.59.30;	author rsandifo;	state Exp;
branches;
next	1.174;

1.174
date	2002.10.19.00.37.50;	author aoliva;	state Exp;
branches;
next	1.173;

1.173
date	2002.10.13.21.22.49;	author aoliva;	state Exp;
branches;
next	1.172;

1.172
date	2002.10.12.05.23.32;	author aoliva;	state Exp;
branches;
next	1.171;

1.171
date	2002.09.30.12.04.51;	author rsandifo;	state Exp;
branches;
next	1.170;

1.170
date	2002.09.30.06.32.00;	author hjl;	state Exp;
branches;
next	1.169;

1.169
date	2002.09.26.09.56.32;	author ths;	state Exp;
branches;
next	1.168;

1.168
date	2002.09.26.09.00.06;	author ths;	state Exp;
branches;
next	1.167;

1.167
date	2002.09.18.21.33.06;	author cgd;	state Exp;
branches;
next	1.166;

1.166
date	2002.09.18.21.05.59;	author cgd;	state Exp;
branches;
next	1.165;

1.165
date	2002.09.18.08.02.22;	author ths;	state Exp;
branches;
next	1.164;

1.164
date	2002.09.18.02.25.19;	author scox;	state Exp;
branches;
next	1.163;

1.163
date	2002.09.17.07.43.25;	author ths;	state Exp;
branches;
next	1.162;

1.162
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.161;

1.161
date	2002.08.20.08.28.34;	author rsandifo;	state Exp;
branches;
next	1.160;

1.160
date	2002.08.17.15.09.29;	author scox;	state Exp;
branches;
next	1.159;

1.159
date	2002.08.16.00.58.11;	author aoliva;	state Exp;
branches;
next	1.158;

1.158
date	2002.08.12.08.30.49;	author rsandifo;	state Exp;
branches;
next	1.157;

1.157
date	2002.08.09.11.07.23;	author macro;	state Exp;
branches;
next	1.156;

1.156
date	2002.08.01.20.14.46;	author rsandifo;	state Exp;
branches;
next	1.155;

1.155
date	2002.07.31.05.48.31;	author cgd;	state Exp;
branches;
next	1.154;

1.154
date	2002.07.30.23.56.28;	author ths;	state Exp;
branches;
next	1.153;

1.153
date	2002.07.30.19.27.31;	author macro;	state Exp;
branches;
next	1.152;

1.152
date	2002.07.30.19.24.54;	author macro;	state Exp;
branches;
next	1.151;

1.151
date	2002.07.25.11.07.47;	author rsandifo;	state Exp;
branches;
next	1.150;

1.150
date	2002.07.25.09.48.06;	author rsandifo;	state Exp;
branches;
next	1.149;

1.149
date	2002.07.19.21.30.26;	author ths;	state Exp;
branches;
next	1.148;

1.148
date	2002.07.19.21.28.49;	author ths;	state Exp;
branches;
next	1.147;

1.147
date	2002.07.09.14.21.40;	author ths;	state Exp;
branches
	1.147.2.1;
next	1.146;

1.146
date	2002.07.09.00.42.57;	author macro;	state Exp;
branches;
next	1.145;

1.145
date	2002.07.08.22.42.09;	author macro;	state Exp;
branches;
next	1.144;

1.144
date	2002.06.14.14.08.51;	author drow;	state Exp;
branches;
next	1.143;

1.143
date	2002.06.13.10.10.51;	author macro;	state Exp;
branches;
next	1.142;

1.142
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2002.06.08.05.37.29;	author drow;	state Exp;
branches;
next	1.140;

1.140
date	2002.06.07.23.26.54;	author ths;	state Exp;
branches;
next	1.139;

1.139
date	2002.06.07.22.54.47;	author ths;	state Exp;
branches;
next	1.138;

1.138
date	2002.06.06.16.38.01;	author drow;	state Exp;
branches;
next	1.137;

1.137
date	2002.06.04.16.33.55;	author macro;	state Exp;
branches;
next	1.136;

1.136
date	2002.05.31.02.27.15;	author ths;	state Exp;
branches;
next	1.135;

1.135
date	2002.05.31.02.20.04;	author ths;	state Exp;
branches;
next	1.134;

1.134
date	2002.05.31.02.04.55;	author ths;	state Exp;
branches;
next	1.133;

1.133
date	2002.05.31.01.58.18;	author ths;	state Exp;
branches;
next	1.132;

1.132
date	2002.05.31.01.17.13;	author cgd;	state Exp;
branches;
next	1.131;

1.131
date	2002.05.30.23.38.18;	author ths;	state Exp;
branches;
next	1.130;

1.130
date	2002.05.30.23.32.47;	author ths;	state Exp;
branches;
next	1.129;

1.129
date	2002.05.30.22.29.20;	author ths;	state Exp;
branches;
next	1.128;

1.128
date	2002.05.30.21.06.14;	author ths;	state Exp;
branches;
next	1.127;

1.127
date	2002.05.28.19.23.09;	author ths;	state Exp;
branches;
next	1.126;

1.126
date	2002.05.26.18.46.37;	author ths;	state Exp;
branches;
next	1.125;

1.125
date	2002.05.22.00.13.13;	author ths;	state Exp;
branches;
next	1.124;

1.124
date	2002.05.21.23.54.41;	author ths;	state Exp;
branches;
next	1.123;

1.123
date	2002.05.14.23.35.59;	author ths;	state Exp;
branches;
next	1.122;

1.122
date	2002.05.14.23.29.23;	author ths;	state Exp;
branches;
next	1.121;

1.121
date	2002.05.14.23.27.35;	author ths;	state Exp;
branches;
next	1.120;

1.120
date	2002.05.14.23.19.39;	author ths;	state Exp;
branches;
next	1.119;

1.119
date	2002.05.04.17.38.00;	author kazu;	state Exp;
branches;
next	1.118;

1.118
date	2002.04.24.21.52.47;	author cgd;	state Exp;
branches;
next	1.117;

1.117
date	2002.04.22.21.50.44;	author cgd;	state Exp;
branches;
next	1.116;

1.116
date	2002.04.22.21.21.06;	author echristo;	state Exp;
branches;
next	1.115;

1.115
date	2002.04.04.07.43.11;	author ths;	state Exp;
branches;
next	1.114;

1.114
date	2002.03.18.18.56.18;	author aoliva;	state Exp;
branches;
next	1.113;

1.113
date	2002.03.16.03.09.14;	author cgd;	state Exp;
branches;
next	1.112;

1.112
date	2002.02.26.22.18.51;	author cgd;	state Exp;
branches;
next	1.111;

1.111
date	2002.02.25.13.21.33;	author ths;	state Exp;
branches;
next	1.110;

1.110
date	2002.02.19.22.59.30;	author ths;	state Exp;
branches;
next	1.109;

1.109
date	2002.02.15.23.00.34;	author cgd;	state Exp;
branches;
next	1.108;

1.108
date	2002.02.14.07.29.22;	author cgd;	state Exp;
branches;
next	1.107;

1.107
date	2002.02.08.22.25.36;	author cgd;	state Exp;
branches
	1.107.2.1;
next	1.106;

1.106
date	2002.01.30.02.14.19;	author cgd;	state Exp;
branches;
next	1.105;

1.105
date	2002.01.16.21.30.47;	author ths;	state Exp;
branches;
next	1.104;

1.104
date	2002.01.05.19.06.52;	author drow;	state Exp;
branches;
next	1.103;

1.103
date	2001.12.20.21.11.26;	author drow;	state Exp;
branches;
next	1.102;

1.102
date	2001.12.04.14.38.48;	author ths;	state Exp;
branches;
next	1.101;

1.101
date	2001.12.04.14.05.54;	author ths;	state Exp;
branches;
next	1.100;

1.100
date	2001.12.04.13.27.56;	author ths;	state Exp;
branches;
next	1.99;

1.99
date	2001.12.04.00.51.33;	author echristo;	state Exp;
branches;
next	1.98;

1.98
date	2001.12.02.13.14.48;	author ths;	state Exp;
branches;
next	1.97;

1.97
date	2001.11.21.11.24.13;	author rsandifo;	state Exp;
branches;
next	1.96;

1.96
date	2001.11.15.21.28.56;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2001.11.15.09.50.00;	author ths;	state Exp;
branches;
next	1.94;

1.94
date	2001.11.12.22.22.20;	author ths;	state Exp;
branches;
next	1.93;

1.93
date	2001.11.12.22.20.44;	author ths;	state Exp;
branches;
next	1.92;

1.92
date	2001.11.12.22.19.30;	author ths;	state Exp;
branches;
next	1.91;

1.91
date	2001.11.12.16.54.54;	author ths;	state Exp;
branches;
next	1.90;

1.90
date	2001.11.08.19.32.24;	author ths;	state Exp;
branches;
next	1.89;

1.89
date	2001.11.06.21.39.06;	author echristo;	state Exp;
branches;
next	1.88;

1.88
date	2001.11.01.01.33.46;	author cgd;	state Exp;
branches;
next	1.87;

1.87
date	2001.10.24.21.08.34;	author cgd;	state Exp;
branches;
next	1.86;

1.86
date	2001.10.21.05.58.55;	author cgd;	state Exp;
branches;
next	1.85;

1.85
date	2001.10.17.05.51.11;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2001.10.15.19.48.04;	author ths;	state Exp;
branches;
next	1.83;

1.83
date	2001.10.11.23.56.33;	author kazu;	state Exp;
branches;
next	1.82;

1.82
date	2001.10.10.01.08.35;	author ths;	state Exp;
branches;
next	1.81;

1.81
date	2001.10.10.00.54.53;	author ths;	state Exp;
branches;
next	1.80;

1.80
date	2001.10.10.00.43.36;	author ths;	state Exp;
branches;
next	1.79;

1.79
date	2001.10.04.20.07.00;	author ths;	state Exp;
branches;
next	1.78;

1.78
date	2001.10.03.20.30.15;	author ths;	state Exp;
branches;
next	1.77;

1.77
date	2001.09.19.05.33.27;	author hjl;	state Exp;
branches;
next	1.76;

1.76
date	2001.09.14.20.18.54;	author echristo;	state Exp;
branches;
next	1.75;

1.75
date	2001.09.12.21.19.37;	author ths;	state Exp;
branches;
next	1.74;

1.74
date	2001.09.09.14.01.17;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2001.09.07.05.54.11;	author ths;	state Exp;
branches;
next	1.72;

1.72
date	2001.09.07.05.00.36;	author ths;	state Exp;
branches;
next	1.71;

1.71
date	2001.08.31.21.06.40;	author echristo;	state Exp;
branches;
next	1.70;

1.70
date	2001.08.27.18.48.27;	author ths;	state Exp;
branches;
next	1.69;

1.69
date	2001.08.26.10.42.12;	author ths;	state Exp;
branches;
next	1.68;

1.68
date	2001.08.21.01.13.05;	author ths;	state Exp;
branches;
next	1.67;

1.67
date	2001.08.21.00.59.48;	author ths;	state Exp;
branches;
next	1.66;

1.66
date	2001.08.18.18.03.24;	author hjl;	state Exp;
branches;
next	1.65;

1.65
date	2001.08.18.17.24.52;	author ths;	state Exp;
branches;
next	1.64;

1.64
date	2001.08.16.21.48.28;	author ths;	state Exp;
branches;
next	1.63;

1.63
date	2001.08.16.15.12.08;	author ths;	state Exp;
branches;
next	1.62;

1.62
date	2001.08.11.15.15.15;	author kazu;	state Exp;
branches;
next	1.61;

1.61
date	2001.08.10.16.24.32;	author rsandifo;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.07.13.22.46;	author ths;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.07.13.15.26;	author ths;	state Exp;
branches;
next	1.58;

1.58
date	2001.08.07.12.46.22;	author ths;	state Exp;
branches;
next	1.57;

1.57
date	2001.08.03.18.33.34;	author rsandifo;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.02.10.15.24;	author rsandifo;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.25.22.27.46;	author hjl;	state Exp;
branches;
next	1.54;

1.54
date	2001.07.25.20.34.39;	author cgd;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.23.13.03.40;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.22.18.11.29;	author hjl;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.04.12.32.07;	author echristo;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.04.09.49.28;	author rsandifo;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.29.21.27.41;	author echristo;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.11.20.40.34;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.09.05.24.39;	author hjl;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.09.05.01.29;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.09.03.28.04;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.08.06.07.13;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.07.16.52.19;	author hjl;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.23.17.26.38;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.22.10.23.49;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2001.04.29.17.58.39;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.08.05.09.21;	author hjl;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.30.07.07.10;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.11.23.11.41;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.10.21.41.12;	author cgd;	state Exp;
branches;
next	1.34;

1.34
date	2000.12.28.10.07.56;	author rth;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.12.12.19.29.24;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.05.18.51.08;	author kazu;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.02.01.10.32;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2000.12.02.00.52.55;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2000.12.01.21.35.36;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2000.12.01.20.05.31;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.01.19.06.15;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.20.22.05.08;	author kazu;	state Exp;
branches;
next	1.25;

1.25
date	2000.09.14.01.47.34;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2000.09.07.12.45.56;	author kazu;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.14.22.28.24;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.14.22.23.33;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.02.01.18.49;	author ulfc;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.28.19.06.25;	author aldyh;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.16.19.11.27;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.09.00.00.03;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.29.22.05.27;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.11.01.48.09;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.25.10.02.20;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.11.02.16.25;	author geoffk;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.24.19.46.28;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.22.14.43.54;	author aph;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.21.20.00.33;	author clm;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.14.17.58.29;	author cpopetz;	state Exp;
branches;
next	1.8;

1.8
date	99.11.01.19.29.55;	author gavin;	state Exp;
branches;
next	1.7;

1.7
date	99.10.21.13.23.31;	author gavin;	state Exp;
branches;
next	1.6;

1.6
date	99.09.28.04.13.25;	author geoffk;	state Exp;
branches;
next	1.5;

1.5
date	99.08.03.15.22.38;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.10.20.35.50;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.36;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.28.15.28.56;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.506.2.1
date	2012.09.04.14.01.38;	author gingold;	state Exp;
branches;
next	1.506.2.2;

1.506.2.2
date	2012.09.04.14.37.55;	author gingold;	state Exp;
branches;
next	;

1.488.2.1
date	2011.11.14.13.46.17;	author macro;	state Exp;
branches;
next	1.488.2.2;

1.488.2.2
date	2011.12.19.10.49.26;	author cltang;	state Exp;
branches;
next	1.488.2.3;

1.488.2.3
date	2012.01.08.12.34.30;	author rsandifo;	state Exp;
branches;
next	;

1.431.2.1
date	2010.11.15.21.56.50;	author rsandifo;	state Exp;
branches;
next	1.431.2.2;

1.431.2.2
date	2011.02.01.12.25.41;	author amodra;	state Exp;
branches;
next	;

1.412.2.1
date	2009.09.05.08.00.20;	author nickc;	state Exp;
branches;
next	1.412.2.2;

1.412.2.2
date	2009.09.21.19.32.47;	author rsandifo;	state Exp;
branches;
next	;

1.394.2.1
date	2009.01.09.00.16.12;	author nemet;	state Exp;
branches;
next	;

1.328.2.1
date	2006.05.11.14.57.17;	author ths;	state Exp;
branches;
next	;

1.327.2.1
date	2006.08.22.15.08.35;	author jsm28;	state Exp;
branches;
next	;

1.291.2.1
date	2005.03.09.09.41.00;	author rsandifo;	state Exp;
branches;
next	1.291.2.2;

1.291.2.2
date	2005.03.09.09.41.42;	author rsandifo;	state Exp;
branches;
next	1.291.2.3;

1.291.2.3
date	2005.03.09.09.42.24;	author rsandifo;	state Exp;
branches;
next	1.291.2.4;

1.291.2.4
date	2005.03.09.09.43.14;	author rsandifo;	state Exp;
branches;
next	1.291.2.5;

1.291.2.5
date	2005.03.09.09.43.54;	author rsandifo;	state Exp;
branches;
next	1.291.2.6;

1.291.2.6
date	2005.03.09.09.44.38;	author rsandifo;	state Exp;
branches;
next	1.291.2.7;

1.291.2.7
date	2005.03.09.09.45.27;	author rsandifo;	state Exp;
branches;
next	1.291.2.8;

1.291.2.8
date	2005.03.09.09.46.16;	author rsandifo;	state Exp;
branches;
next	1.291.2.9;

1.291.2.9
date	2005.03.09.09.47.34;	author rsandifo;	state Exp;
branches;
next	1.291.2.10;

1.291.2.10
date	2005.03.09.09.50.09;	author rsandifo;	state Exp;
branches;
next	1.291.2.11;

1.291.2.11
date	2005.03.09.09.51.33;	author rsandifo;	state Exp;
branches;
next	1.291.2.12;

1.291.2.12
date	2005.03.09.11.57.23;	author rsandifo;	state Exp;
branches;
next	1.291.2.13;

1.291.2.13
date	2005.03.15.05.37.48;	author echristo;	state Exp;
branches;
next	1.291.2.14;

1.291.2.14
date	2005.03.21.16.22.55;	author macro;	state Exp;
branches;
next	1.291.2.15;

1.291.2.15
date	2005.04.13.18.17.48;	author macro;	state Exp;
branches;
next	1.291.2.16;

1.291.2.16
date	2005.04.14.15.45.38;	author macro;	state Exp;
branches;
next	1.291.2.17;

1.291.2.17
date	2005.04.15.19.19.02;	author macro;	state Exp;
branches;
next	1.291.2.18;

1.291.2.18
date	2005.04.18.14.16.46;	author macro;	state Exp;
branches;
next	1.291.2.19;

1.291.2.19
date	2005.04.20.17.26.27;	author nickc;	state Exp;
branches;
next	1.291.2.20;

1.291.2.20
date	2005.06.12.18.30.57;	author drow;	state Exp;
branches;
next	;

1.253.4.1
date	2004.02.26.21.27.07;	author echristo;	state Exp;
branches;
next	1.253.4.2;

1.253.4.2
date	2004.04.14.16.18.41;	author rsandifo;	state Exp;
branches;
next	1.253.4.3;

1.253.4.3
date	2004.04.19.21.07.44;	author echristo;	state Exp;
branches;
next	1.253.4.4;

1.253.4.4
date	2004.08.18.18.30.48;	author ths;	state Exp;
branches;
next	;

1.204.2.1
date	2003.05.06.01.16.15;	author drow;	state Exp;
branches;
next	1.204.2.2;

1.204.2.2
date	2003.05.15.19.20.05;	author drow;	state Exp;
branches;
next	1.204.2.3;

1.204.2.3
date	2003.05.24.19.27.59;	author ths;	state Exp;
branches;
next	;

1.147.2.1
date	2002.07.31.14.23.59;	author drow;	state Exp;
branches;
next	1.147.2.2;

1.147.2.2
date	2002.08.02.02.03.09;	author drow;	state Exp;
branches;
next	1.147.2.3;

1.147.2.3
date	2002.08.20.17.56.05;	author macro;	state Exp;
branches;
next	1.147.2.4;

1.147.2.4
date	2002.09.23.22.14.22;	author drow;	state Exp;
branches;
next	1.147.2.5;

1.147.2.5
date	2002.10.28.18.45.49;	author drow;	state Exp;
branches;
next	1.147.2.6;

1.147.2.6
date	2002.11.05.22.03.43;	author drow;	state Exp;
branches;
next	;

1.107.2.1
date	2002.02.14.07.31.11;	author cgd;	state Exp;
branches;
next	1.107.2.2;

1.107.2.2
date	2002.02.15.23.13.42;	author cgd;	state Exp;
branches;
next	1.107.2.3;

1.107.2.3
date	2002.02.21.05.01.07;	author ths;	state Exp;
branches;
next	1.107.2.4;

1.107.2.4
date	2002.02.25.10.14.25;	author ths;	state Exp;
branches;
next	1.107.2.5;

1.107.2.5
date	2002.02.26.22.25.38;	author cgd;	state Exp;
branches;
next	1.107.2.6;

1.107.2.6
date	2002.03.19.05.44.50;	author aoliva;	state Exp;
branches;
next	;

1.34.2.1
date	2001.06.07.03.15.31;	author amodra;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.06.11.10.04.49;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.595
log
@2013-10-18  Chao-ying Fu  <Chao-ying.Fu@@imgtec.com>

	* config/tc-mips.c (fpr_read_mask): Test MSA registers.
	(fpr_write_mask): Test MSA registers.
	(can_swap_branch_p): Check fpr write followed by fpr read.
@
text
@/* tc-mips.c -- assemble code for a MIPS chip.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
   Contributed by the OSF and Ralph Campbell.
   Written by Keith Knowles and Ralph Campbell, working independently.
   Modified for ECOFF and R4000 support by Ian Lance Taylor of Cygnus
   Support.

   This file is part of GAS.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "config.h"
#include "subsegs.h"
#include "safe-ctype.h"

#include "opcode/mips.h"
#include "itbl-ops.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"

/* Check assumptions made in this file.  */
typedef char static_assert1[sizeof (offsetT) < 8 ? -1 : 1];
typedef char static_assert2[sizeof (valueT) < 8 ? -1 : 1];

#ifdef DEBUG
#define DBG(x) printf x
#else
#define DBG(x)
#endif

#define SKIP_SPACE_TABS(S) \
  do { while (*(S) == ' ' || *(S) == '\t') ++(S); } while (0)

/* Clean up namespace so we can include obj-elf.h too.  */
static int mips_output_flavor (void);
static int mips_output_flavor (void) { return OUTPUT_FLAVOR; }
#undef OBJ_PROCESS_STAB
#undef OUTPUT_FLAVOR
#undef S_GET_ALIGN
#undef S_GET_SIZE
#undef S_SET_ALIGN
#undef S_SET_SIZE
#undef obj_frob_file
#undef obj_frob_file_after_relocs
#undef obj_frob_symbol
#undef obj_pop_insert
#undef obj_sec_sym_ok_for_reloc
#undef OBJ_COPY_SYMBOL_ATTRIBUTES

#include "obj-elf.h"
/* Fix any of them that we actually care about.  */
#undef OUTPUT_FLAVOR
#define OUTPUT_FLAVOR mips_output_flavor()

#include "elf/mips.h"

#ifndef ECOFF_DEBUGGING
#define NO_ECOFF_DEBUGGING
#define ECOFF_DEBUGGING 0
#endif

int mips_flag_mdebug = -1;

/* Control generation of .pdr sections.  Off by default on IRIX: the native
   linker doesn't know about and discards them, but relocations against them
   remain, leading to rld crashes.  */
#ifdef TE_IRIX
int mips_flag_pdr = FALSE;
#else
int mips_flag_pdr = TRUE;
#endif

#include "ecoff.h"

static char *mips_regmask_frag;

#define ZERO 0
#define ATREG 1
#define S0  16
#define S7  23
#define TREG 24
#define PIC_CALL_REG 25
#define KT0 26
#define KT1 27
#define GP  28
#define SP  29
#define FP  30
#define RA  31

#define ILLEGAL_REG (32)

#define AT  mips_opts.at

extern int target_big_endian;

/* The name of the readonly data section.  */
#define RDATA_SECTION_NAME ".rodata"

/* Ways in which an instruction can be "appended" to the output.  */
enum append_method {
  /* Just add it normally.  */
  APPEND_ADD,

  /* Add it normally and then add a nop.  */
  APPEND_ADD_WITH_NOP,

  /* Turn an instruction with a delay slot into a "compact" version.  */
  APPEND_ADD_COMPACT,

  /* Insert the instruction before the last one.  */
  APPEND_SWAP
};

/* Information about an instruction, including its format, operands
   and fixups.  */
struct mips_cl_insn
{
  /* The opcode's entry in mips_opcodes or mips16_opcodes.  */
  const struct mips_opcode *insn_mo;

  /* The 16-bit or 32-bit bitstring of the instruction itself.  This is
     a copy of INSN_MO->match with the operands filled in.  If we have
     decided to use an extended MIPS16 instruction, this includes the
     extension.  */
  unsigned long insn_opcode;

  /* The frag that contains the instruction.  */
  struct frag *frag;

  /* The offset into FRAG of the first instruction byte.  */
  long where;

  /* The relocs associated with the instruction, if any.  */
  fixS *fixp[3];

  /* True if this entry cannot be moved from its current position.  */
  unsigned int fixed_p : 1;

  /* True if this instruction occurred in a .set noreorder block.  */
  unsigned int noreorder_p : 1;

  /* True for mips16 instructions that jump to an absolute address.  */
  unsigned int mips16_absolute_jump_p : 1;

  /* True if this instruction is complete.  */
  unsigned int complete_p : 1;

  /* True if this instruction is cleared from history by unconditional
     branch.  */
  unsigned int cleared_p : 1;
};

/* The ABI to use.  */
enum mips_abi_level
{
  NO_ABI = 0,
  O32_ABI,
  O64_ABI,
  N32_ABI,
  N64_ABI,
  EABI_ABI
};

/* MIPS ABI we are using for this output file.  */
static enum mips_abi_level mips_abi = NO_ABI;

/* Whether or not we have code that can call pic code.  */
int mips_abicalls = FALSE;

/* Whether or not we have code which can be put into a shared
   library.  */
static bfd_boolean mips_in_shared = TRUE;

/* This is the set of options which may be modified by the .set
   pseudo-op.  We use a struct so that .set push and .set pop are more
   reliable.  */

struct mips_set_options
{
  /* MIPS ISA (Instruction Set Architecture) level.  This is set to -1
     if it has not been initialized.  Changed by `.set mipsN', and the
     -mipsN command line option, and the default CPU.  */
  int isa;
  /* Enabled Application Specific Extensions (ASEs).  Changed by `.set
     <asename>', by command line options, and based on the default
     architecture.  */
  int ase;
  /* Whether we are assembling for the mips16 processor.  0 if we are
     not, 1 if we are, and -1 if the value has not been initialized.
     Changed by `.set mips16' and `.set nomips16', and the -mips16 and
     -nomips16 command line options, and the default CPU.  */
  int mips16;
  /* Whether we are assembling for the mipsMIPS ASE.  0 if we are not,
     1 if we are, and -1 if the value has not been initialized.  Changed
     by `.set micromips' and `.set nomicromips', and the -mmicromips
     and -mno-micromips command line options, and the default CPU.  */
  int micromips;
  /* Non-zero if we should not reorder instructions.  Changed by `.set
     reorder' and `.set noreorder'.  */
  int noreorder;
  /* Non-zero if we should not permit the register designated "assembler
     temporary" to be used in instructions.  The value is the register
     number, normally $at ($1).  Changed by `.set at=REG', `.set noat'
     (same as `.set at=$0') and `.set at' (same as `.set at=$1').  */
  unsigned int at;
  /* Non-zero if we should warn when a macro instruction expands into
     more than one machine instruction.  Changed by `.set nomacro' and
     `.set macro'.  */
  int warn_about_macros;
  /* Non-zero if we should not move instructions.  Changed by `.set
     move', `.set volatile', `.set nomove', and `.set novolatile'.  */
  int nomove;
  /* Non-zero if we should not optimize branches by moving the target
     of the branch into the delay slot.  Actually, we don't perform
     this optimization anyhow.  Changed by `.set bopt' and `.set
     nobopt'.  */
  int nobopt;
  /* Non-zero if we should not autoextend mips16 instructions.
     Changed by `.set autoextend' and `.set noautoextend'.  */
  int noautoextend;
  /* True if we should only emit 32-bit microMIPS instructions.
     Changed by `.set insn32' and `.set noinsn32', and the -minsn32
     and -mno-insn32 command line options.  */
  bfd_boolean insn32;
  /* Restrict general purpose registers and floating point registers
     to 32 bit.  This is initially determined when -mgp32 or -mfp32
     is passed but can changed if the assembler code uses .set mipsN.  */
  int gp32;
  int fp32;
  /* MIPS architecture (CPU) type.  Changed by .set arch=FOO, the -march
     command line option, and the default CPU.  */
  int arch;
  /* True if ".set sym32" is in effect.  */
  bfd_boolean sym32;
  /* True if floating-point operations are not allowed.  Changed by .set
     softfloat or .set hardfloat, by command line options -msoft-float or
     -mhard-float.  The default is false.  */
  bfd_boolean soft_float;

  /* True if only single-precision floating-point operations are allowed.
     Changed by .set singlefloat or .set doublefloat, command-line options
     -msingle-float or -mdouble-float.  The default is false.  */
  bfd_boolean single_float;
};

/* This is the struct we use to hold the current set of options.  Note
   that we must set the isa field to ISA_UNKNOWN and the ASE fields to
   -1 to indicate that they have not been initialized.  */

/* True if -mgp32 was passed.  */
static int file_mips_gp32 = -1;

/* True if -mfp32 was passed.  */
static int file_mips_fp32 = -1;

/* 1 if -msoft-float, 0 if -mhard-float.  The default is 0.  */
static int file_mips_soft_float = 0;

/* 1 if -msingle-float, 0 if -mdouble-float.  The default is 0.   */
static int file_mips_single_float = 0;

/* True if -mnan=2008, false if -mnan=legacy.  */
static bfd_boolean mips_flag_nan2008 = FALSE;

static struct mips_set_options mips_opts =
{
  /* isa */ ISA_UNKNOWN, /* ase */ 0, /* mips16 */ -1, /* micromips */ -1,
  /* noreorder */ 0,  /* at */ ATREG, /* warn_about_macros */ 0,
  /* nomove */ 0, /* nobopt */ 0, /* noautoextend */ 0, /* insn32 */ FALSE,
  /* gp32 */ 0, /* fp32 */ 0, /* arch */ CPU_UNKNOWN, /* sym32 */ FALSE,
  /* soft_float */ FALSE, /* single_float */ FALSE
};

/* The set of ASEs that were selected on the command line, either
   explicitly via ASE options or implicitly through things like -march.  */
static unsigned int file_ase;

/* Which bits of file_ase were explicitly set or cleared by ASE options.  */
static unsigned int file_ase_explicit;

/* These variables are filled in with the masks of registers used.
   The object format code reads them and puts them in the appropriate
   place.  */
unsigned long mips_gprmask;
unsigned long mips_cprmask[4];

/* MIPS ISA we are using for this output file.  */
static int file_mips_isa = ISA_UNKNOWN;

/* True if any MIPS16 code was produced.  */
static int file_ase_mips16;

#define ISA_SUPPORTS_MIPS16E (mips_opts.isa == ISA_MIPS32		\
			      || mips_opts.isa == ISA_MIPS32R2		\
			      || mips_opts.isa == ISA_MIPS64		\
			      || mips_opts.isa == ISA_MIPS64R2)

/* True if any microMIPS code was produced.  */
static int file_ase_micromips;

/* True if we want to create R_MIPS_JALR for jalr $25.  */
#ifdef TE_IRIX
#define MIPS_JALR_HINT_P(EXPR) HAVE_NEWABI
#else
/* As a GNU extension, we use R_MIPS_JALR for o32 too.  However,
   because there's no place for any addend, the only acceptable
   expression is a bare symbol.  */
#define MIPS_JALR_HINT_P(EXPR) \
  (!HAVE_IN_PLACE_ADDENDS \
   || ((EXPR)->X_op == O_symbol && (EXPR)->X_add_number == 0))
#endif

/* The argument of the -march= flag.  The architecture we are assembling.  */
static int file_mips_arch = CPU_UNKNOWN;
static const char *mips_arch_string;

/* The argument of the -mtune= flag.  The architecture for which we
   are optimizing.  */
static int mips_tune = CPU_UNKNOWN;
static const char *mips_tune_string;

/* True when generating 32-bit code for a 64-bit processor.  */
static int mips_32bitmode = 0;

/* True if the given ABI requires 32-bit registers.  */
#define ABI_NEEDS_32BIT_REGS(ABI) ((ABI) == O32_ABI)

/* Likewise 64-bit registers.  */
#define ABI_NEEDS_64BIT_REGS(ABI)	\
  ((ABI) == N32_ABI 			\
   || (ABI) == N64_ABI			\
   || (ABI) == O64_ABI)

/*  Return true if ISA supports 64 bit wide gp registers.  */
#define ISA_HAS_64BIT_REGS(ISA)		\
  ((ISA) == ISA_MIPS3			\
   || (ISA) == ISA_MIPS4		\
   || (ISA) == ISA_MIPS5		\
   || (ISA) == ISA_MIPS64		\
   || (ISA) == ISA_MIPS64R2)

/*  Return true if ISA supports 64 bit wide float registers.  */
#define ISA_HAS_64BIT_FPRS(ISA)		\
  ((ISA) == ISA_MIPS3			\
   || (ISA) == ISA_MIPS4		\
   || (ISA) == ISA_MIPS5		\
   || (ISA) == ISA_MIPS32R2		\
   || (ISA) == ISA_MIPS64		\
   || (ISA) == ISA_MIPS64R2)

/* Return true if ISA supports 64-bit right rotate (dror et al.)
   instructions.  */
#define ISA_HAS_DROR(ISA)		\
  ((ISA) == ISA_MIPS64R2		\
   || (mips_opts.micromips		\
       && ISA_HAS_64BIT_REGS (ISA))	\
   )

/* Return true if ISA supports 32-bit right rotate (ror et al.)
   instructions.  */
#define ISA_HAS_ROR(ISA)		\
  ((ISA) == ISA_MIPS32R2		\
   || (ISA) == ISA_MIPS64R2		\
   || (mips_opts.ase & ASE_SMARTMIPS)	\
   || mips_opts.micromips		\
   )

/* Return true if ISA supports single-precision floats in odd registers.  */
#define ISA_HAS_ODD_SINGLE_FPR(ISA)	\
  ((ISA) == ISA_MIPS32			\
   || (ISA) == ISA_MIPS32R2		\
   || (ISA) == ISA_MIPS64		\
   || (ISA) == ISA_MIPS64R2)

/* Return true if ISA supports move to/from high part of a 64-bit
   floating-point register. */
#define ISA_HAS_MXHC1(ISA)		\
  ((ISA) == ISA_MIPS32R2		\
   || (ISA) == ISA_MIPS64R2)

#define HAVE_32BIT_GPRS		                   \
    (mips_opts.gp32 || !ISA_HAS_64BIT_REGS (mips_opts.isa))

#define HAVE_32BIT_FPRS                            \
    (mips_opts.fp32 || !ISA_HAS_64BIT_FPRS (mips_opts.isa))

#define HAVE_64BIT_GPRS (!HAVE_32BIT_GPRS)
#define HAVE_64BIT_FPRS (!HAVE_32BIT_FPRS)

#define HAVE_NEWABI (mips_abi == N32_ABI || mips_abi == N64_ABI)

#define HAVE_64BIT_OBJECTS (mips_abi == N64_ABI)

/* True if relocations are stored in-place.  */
#define HAVE_IN_PLACE_ADDENDS (!HAVE_NEWABI)

/* The ABI-derived address size.  */
#define HAVE_64BIT_ADDRESSES \
  (HAVE_64BIT_GPRS && (mips_abi == EABI_ABI || mips_abi == N64_ABI))
#define HAVE_32BIT_ADDRESSES (!HAVE_64BIT_ADDRESSES)

/* The size of symbolic constants (i.e., expressions of the form
   "SYMBOL" or "SYMBOL + OFFSET").  */
#define HAVE_32BIT_SYMBOLS \
  (HAVE_32BIT_ADDRESSES || !HAVE_64BIT_OBJECTS || mips_opts.sym32)
#define HAVE_64BIT_SYMBOLS (!HAVE_32BIT_SYMBOLS)

/* Addresses are loaded in different ways, depending on the address size
   in use.  The n32 ABI Documentation also mandates the use of additions
   with overflow checking, but existing implementations don't follow it.  */
#define ADDRESS_ADD_INSN						\
   (HAVE_32BIT_ADDRESSES ? "addu" : "daddu")

#define ADDRESS_ADDI_INSN						\
   (HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu")

#define ADDRESS_LOAD_INSN						\
   (HAVE_32BIT_ADDRESSES ? "lw" : "ld")

#define ADDRESS_STORE_INSN						\
   (HAVE_32BIT_ADDRESSES ? "sw" : "sd")

/* Return true if the given CPU supports the MIPS16 ASE.  */
#define CPU_HAS_MIPS16(cpu)						\
   (strncmp (TARGET_CPU, "mips16", sizeof ("mips16") - 1) == 0		\
    || strncmp (TARGET_CANONICAL, "mips-lsi-elf", sizeof ("mips-lsi-elf") - 1) == 0)

/* Return true if the given CPU supports the microMIPS ASE.  */
#define CPU_HAS_MICROMIPS(cpu)	0

/* True if CPU has a dror instruction.  */
#define CPU_HAS_DROR(CPU)	((CPU) == CPU_VR5400 || (CPU) == CPU_VR5500)

/* True if CPU has a ror instruction.  */
#define CPU_HAS_ROR(CPU)	CPU_HAS_DROR (CPU)

/* True if CPU is in the Octeon family */
#define CPU_IS_OCTEON(CPU) ((CPU) == CPU_OCTEON || (CPU) == CPU_OCTEONP || (CPU) == CPU_OCTEON2)

/* True if CPU has seq/sne and seqi/snei instructions.  */
#define CPU_HAS_SEQ(CPU)	(CPU_IS_OCTEON (CPU))

/* True, if CPU has support for ldc1 and sdc1. */
#define CPU_HAS_LDC1_SDC1(CPU)	\
   ((mips_opts.isa != ISA_MIPS1) && ((CPU) != CPU_R5900))

/* True if mflo and mfhi can be immediately followed by instructions
   which write to the HI and LO registers.

   According to MIPS specifications, MIPS ISAs I, II, and III need
   (at least) two instructions between the reads of HI/LO and
   instructions which write them, and later ISAs do not.  Contradicting
   the MIPS specifications, some MIPS IV processor user manuals (e.g.
   the UM for the NEC Vr5000) document needing the instructions between
   HI/LO reads and writes, as well.  Therefore, we declare only MIPS32,
   MIPS64 and later ISAs to have the interlocks, plus any specific
   earlier-ISA CPUs for which CPU documentation declares that the
   instructions are really interlocked.  */
#define hilo_interlocks \
  (mips_opts.isa == ISA_MIPS32                        \
   || mips_opts.isa == ISA_MIPS32R2                   \
   || mips_opts.isa == ISA_MIPS64                     \
   || mips_opts.isa == ISA_MIPS64R2                   \
   || mips_opts.arch == CPU_R4010                     \
   || mips_opts.arch == CPU_R5900                     \
   || mips_opts.arch == CPU_R10000                    \
   || mips_opts.arch == CPU_R12000                    \
   || mips_opts.arch == CPU_R14000                    \
   || mips_opts.arch == CPU_R16000                    \
   || mips_opts.arch == CPU_RM7000                    \
   || mips_opts.arch == CPU_VR5500                    \
   || mips_opts.micromips                             \
   )

/* Whether the processor uses hardware interlocks to protect reads
   from the GPRs after they are loaded from memory, and thus does not
   require nops to be inserted.  This applies to instructions marked
   INSN_LOAD_MEMORY_DELAY.  These nops are only required at MIPS ISA
   level I and microMIPS mode instructions are always interlocked.  */
#define gpr_interlocks                                \
  (mips_opts.isa != ISA_MIPS1                         \
   || mips_opts.arch == CPU_R3900                     \
   || mips_opts.arch == CPU_R5900                     \
   || mips_opts.micromips                             \
   )

/* Whether the processor uses hardware interlocks to avoid delays
   required by coprocessor instructions, and thus does not require
   nops to be inserted.  This applies to instructions marked
   INSN_LOAD_COPROC_DELAY, INSN_COPROC_MOVE_DELAY, and to delays
   between instructions marked INSN_WRITE_COND_CODE and ones marked
   INSN_READ_COND_CODE.  These nops are only required at MIPS ISA
   levels I, II, and III and microMIPS mode instructions are always
   interlocked.  */
/* Itbl support may require additional care here.  */
#define cop_interlocks                                \
  ((mips_opts.isa != ISA_MIPS1                        \
    && mips_opts.isa != ISA_MIPS2                     \
    && mips_opts.isa != ISA_MIPS3)                    \
   || mips_opts.arch == CPU_R4300                     \
   || mips_opts.micromips                             \
   )

/* Whether the processor uses hardware interlocks to protect reads
   from coprocessor registers after they are loaded from memory, and
   thus does not require nops to be inserted.  This applies to
   instructions marked INSN_COPROC_MEMORY_DELAY.  These nops are only
   requires at MIPS ISA level I and microMIPS mode instructions are
   always interlocked.  */
#define cop_mem_interlocks                            \
  (mips_opts.isa != ISA_MIPS1                         \
   || mips_opts.micromips                             \
   )

/* Is this a mfhi or mflo instruction?  */
#define MF_HILO_INSN(PINFO) \
  ((PINFO & INSN_READ_HI) || (PINFO & INSN_READ_LO))

/* Whether code compression (either of the MIPS16 or the microMIPS ASEs)
   has been selected.  This implies, in particular, that addresses of text
   labels have their LSB set.  */
#define HAVE_CODE_COMPRESSION						\
  ((mips_opts.mips16 | mips_opts.micromips) != 0)

/* The minimum and maximum signed values that can be stored in a GPR.  */
#define GPR_SMAX ((offsetT) (((valueT) 1 << (HAVE_64BIT_GPRS ? 63 : 31)) - 1))
#define GPR_SMIN (-GPR_SMAX - 1)

/* MIPS PIC level.  */

enum mips_pic_level mips_pic;

/* 1 if we should generate 32 bit offsets from the $gp register in
   SVR4_PIC mode.  Currently has no meaning in other modes.  */
static int mips_big_got = 0;

/* 1 if trap instructions should used for overflow rather than break
   instructions.  */
static int mips_trap = 0;

/* 1 if double width floating point constants should not be constructed
   by assembling two single width halves into two single width floating
   point registers which just happen to alias the double width destination
   register.  On some architectures this aliasing can be disabled by a bit
   in the status register, and the setting of this bit cannot be determined
   automatically at assemble time.  */
static int mips_disable_float_construction;

/* Non-zero if any .set noreorder directives were used.  */

static int mips_any_noreorder;

/* Non-zero if nops should be inserted when the register referenced in
   an mfhi/mflo instruction is read in the next two instructions.  */
static int mips_7000_hilo_fix;

/* The size of objects in the small data section.  */
static unsigned int g_switch_value = 8;
/* Whether the -G option was used.  */
static int g_switch_seen = 0;

#define N_RMASK 0xc4
#define N_VFP   0xd4

/* If we can determine in advance that GP optimization won't be
   possible, we can skip the relaxation stuff that tries to produce
   GP-relative references.  This makes delay slot optimization work
   better.

   This function can only provide a guess, but it seems to work for
   gcc output.  It needs to guess right for gcc, otherwise gcc
   will put what it thinks is a GP-relative instruction in a branch
   delay slot.

   I don't know if a fix is needed for the SVR4_PIC mode.  I've only
   fixed it for the non-PIC mode.  KR 95/04/07  */
static int nopic_need_relax (symbolS *, int);

/* handle of the OPCODE hash table */
static struct hash_control *op_hash = NULL;

/* The opcode hash table we use for the mips16.  */
static struct hash_control *mips16_op_hash = NULL;

/* The opcode hash table we use for the microMIPS ASE.  */
static struct hash_control *micromips_op_hash = NULL;

/* This array holds the chars that always start a comment.  If the
    pre-processor is disabled, these aren't very useful */
const char comment_chars[] = "#";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that C style comments are always supported.  */
const char line_comment_chars[] = "#";

/* This array holds machine specific line separator characters.  */
const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point nums */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c .  Ideally it shouldn't have to know about it at all,
   but nothing is ideal around here.
 */

/* Types of printf format used for instruction-related error messages.
   "I" means int ("%d") and "S" means string ("%s"). */
enum mips_insn_error_format {
  ERR_FMT_PLAIN,
  ERR_FMT_I,
  ERR_FMT_SS,
};

/* Information about an error that was found while assembling the current
   instruction.  */
struct mips_insn_error {
  /* We sometimes need to match an instruction against more than one
     opcode table entry.  Errors found during this matching are reported
     against a particular syntactic argument rather than against the
     instruction as a whole.  We grade these messages so that errors
     against argument N have a greater priority than an error against
     any argument < N, since the former implies that arguments up to N
     were acceptable and that the opcode entry was therefore a closer match.
     If several matches report an error against the same argument,
     we only use that error if it is the same in all cases.

     min_argnum is the minimum argument number for which an error message
     should be accepted.  It is 0 if MSG is against the instruction as
     a whole.  */
  int min_argnum;

  /* The printf()-style message, including its format and arguments.  */
  enum mips_insn_error_format format;
  const char *msg;
  union {
    int i;
    const char *ss[2];
  } u;
};

/* The error that should be reported for the current instruction.  */
static struct mips_insn_error insn_error;

static int auto_align = 1;

/* When outputting SVR4 PIC code, the assembler needs to know the
   offset in the stack frame from which to restore the $gp register.
   This is set by the .cprestore pseudo-op, and saved in this
   variable.  */
static offsetT mips_cprestore_offset = -1;

/* Similar for NewABI PIC code, where $gp is callee-saved.  NewABI has some
   more optimizations, it can use a register value instead of a memory-saved
   offset and even an other register than $gp as global pointer.  */
static offsetT mips_cpreturn_offset = -1;
static int mips_cpreturn_register = -1;
static int mips_gp_register = GP;
static int mips_gprel_offset = 0;

/* Whether mips_cprestore_offset has been set in the current function
   (or whether it has already been warned about, if not).  */
static int mips_cprestore_valid = 0;

/* This is the register which holds the stack frame, as set by the
   .frame pseudo-op.  This is needed to implement .cprestore.  */
static int mips_frame_reg = SP;

/* Whether mips_frame_reg has been set in the current function
   (or whether it has already been warned about, if not).  */
static int mips_frame_reg_valid = 0;

/* To output NOP instructions correctly, we need to keep information
   about the previous two instructions.  */

/* Whether we are optimizing.  The default value of 2 means to remove
   unneeded NOPs and swap branch instructions when possible.  A value
   of 1 means to not swap branches.  A value of 0 means to always
   insert NOPs.  */
static int mips_optimize = 2;

/* Debugging level.  -g sets this to 2.  -gN sets this to N.  -g0 is
   equivalent to seeing no -g option at all.  */
static int mips_debug = 0;

/* The maximum number of NOPs needed to avoid the VR4130 mflo/mfhi errata.  */
#define MAX_VR4130_NOPS 4

/* The maximum number of NOPs needed to fill delay slots.  */
#define MAX_DELAY_NOPS 2

/* The maximum number of NOPs needed for any purpose.  */
#define MAX_NOPS 4

/* A list of previous instructions, with index 0 being the most recent.
   We need to look back MAX_NOPS instructions when filling delay slots
   or working around processor errata.  We need to look back one
   instruction further if we're thinking about using history[0] to
   fill a branch delay slot.  */
static struct mips_cl_insn history[1 + MAX_NOPS];

/* Arrays of operands for each instruction.  */
#define MAX_OPERANDS 6
struct mips_operand_array {
  const struct mips_operand *operand[MAX_OPERANDS];
};
static struct mips_operand_array *mips_operands;
static struct mips_operand_array *mips16_operands;
static struct mips_operand_array *micromips_operands;

/* Nop instructions used by emit_nop.  */
static struct mips_cl_insn nop_insn;
static struct mips_cl_insn mips16_nop_insn;
static struct mips_cl_insn micromips_nop16_insn;
static struct mips_cl_insn micromips_nop32_insn;

/* The appropriate nop for the current mode.  */
#define NOP_INSN (mips_opts.mips16					\
		  ? &mips16_nop_insn					\
		  : (mips_opts.micromips				\
		     ? (mips_opts.insn32				\
			? &micromips_nop32_insn				\
			: &micromips_nop16_insn)			\
		     : &nop_insn))

/* The size of NOP_INSN in bytes.  */
#define NOP_INSN_SIZE ((mips_opts.mips16				\
			|| (mips_opts.micromips && !mips_opts.insn32))	\
		       ? 2 : 4)

/* If this is set, it points to a frag holding nop instructions which
   were inserted before the start of a noreorder section.  If those
   nops turn out to be unnecessary, the size of the frag can be
   decreased.  */
static fragS *prev_nop_frag;

/* The number of nop instructions we created in prev_nop_frag.  */
static int prev_nop_frag_holds;

/* The number of nop instructions that we know we need in
   prev_nop_frag.  */
static int prev_nop_frag_required;

/* The number of instructions we've seen since prev_nop_frag.  */
static int prev_nop_frag_since;

/* Relocations against symbols are sometimes done in two parts, with a HI
   relocation and a LO relocation.  Each relocation has only 16 bits of
   space to store an addend.  This means that in order for the linker to
   handle carries correctly, it must be able to locate both the HI and
   the LO relocation.  This means that the relocations must appear in
   order in the relocation table.

   In order to implement this, we keep track of each unmatched HI
   relocation.  We then sort them so that they immediately precede the
   corresponding LO relocation.  */

struct mips_hi_fixup
{
  /* Next HI fixup.  */
  struct mips_hi_fixup *next;
  /* This fixup.  */
  fixS *fixp;
  /* The section this fixup is in.  */
  segT seg;
};

/* The list of unmatched HI relocs.  */

static struct mips_hi_fixup *mips_hi_fixup_list;

/* The frag containing the last explicit relocation operator.
   Null if explicit relocations have not been used.  */

static fragS *prev_reloc_op_frag;

/* Map mips16 register numbers to normal MIPS register numbers.  */

static const unsigned int mips16_to_32_reg_map[] =
{
  16, 17, 2, 3, 4, 5, 6, 7
};

/* Map microMIPS register numbers to normal MIPS register numbers.  */

#define micromips_to_32_reg_d_map	mips16_to_32_reg_map

/* The microMIPS registers with type h.  */
static const unsigned int micromips_to_32_reg_h_map1[] =
{
  5, 5, 6, 4, 4, 4, 4, 4
};
static const unsigned int micromips_to_32_reg_h_map2[] =
{
  6, 7, 7, 21, 22, 5, 6, 7
};

/* The microMIPS registers with type m.  */
static const unsigned int micromips_to_32_reg_m_map[] =
{
  0, 17, 2, 3, 16, 18, 19, 20
};

#define micromips_to_32_reg_n_map      micromips_to_32_reg_m_map

/* Classifies the kind of instructions we're interested in when
   implementing -mfix-vr4120.  */
enum fix_vr4120_class
{
  FIX_VR4120_MACC,
  FIX_VR4120_DMACC,
  FIX_VR4120_MULT,
  FIX_VR4120_DMULT,
  FIX_VR4120_DIV,
  FIX_VR4120_MTHILO,
  NUM_FIX_VR4120_CLASSES
};

/* ...likewise -mfix-loongson2f-jump.  */
static bfd_boolean mips_fix_loongson2f_jump;

/* ...likewise -mfix-loongson2f-nop.  */
static bfd_boolean mips_fix_loongson2f_nop;

/* True if -mfix-loongson2f-nop or -mfix-loongson2f-jump passed.  */
static bfd_boolean mips_fix_loongson2f;

/* Given two FIX_VR4120_* values X and Y, bit Y of element X is set if
   there must be at least one other instruction between an instruction
   of type X and an instruction of type Y.  */
static unsigned int vr4120_conflicts[NUM_FIX_VR4120_CLASSES];

/* True if -mfix-vr4120 is in force.  */
static int mips_fix_vr4120;

/* ...likewise -mfix-vr4130.  */
static int mips_fix_vr4130;

/* ...likewise -mfix-24k.  */
static int mips_fix_24k;

/* ...likewise -mfix-cn63xxp1 */
static bfd_boolean mips_fix_cn63xxp1;

/* We don't relax branches by default, since this causes us to expand
   `la .l2 - .l1' if there's a branch between .l1 and .l2, because we
   fail to compute the offset before expanding the macro to the most
   efficient expansion.  */

static int mips_relax_branch;

/* The expansion of many macros depends on the type of symbol that
   they refer to.  For example, when generating position-dependent code,
   a macro that refers to a symbol may have two different expansions,
   one which uses GP-relative addresses and one which uses absolute
   addresses.  When generating SVR4-style PIC, a macro may have
   different expansions for local and global symbols.

   We handle these situations by generating both sequences and putting
   them in variant frags.  In position-dependent code, the first sequence
   will be the GP-relative one and the second sequence will be the
   absolute one.  In SVR4 PIC, the first sequence will be for global
   symbols and the second will be for local symbols.

   The frag's "subtype" is RELAX_ENCODE (FIRST, SECOND), where FIRST and
   SECOND are the lengths of the two sequences in bytes.  These fields
   can be extracted using RELAX_FIRST() and RELAX_SECOND().  In addition,
   the subtype has the following flags:

   RELAX_USE_SECOND
	Set if it has been decided that we should use the second
	sequence instead of the first.

   RELAX_SECOND_LONGER
	Set in the first variant frag if the macro's second implementation
	is longer than its first.  This refers to the macro as a whole,
	not an individual relaxation.

   RELAX_NOMACRO
	Set in the first variant frag if the macro appeared in a .set nomacro
	block and if one alternative requires a warning but the other does not.

   RELAX_DELAY_SLOT
	Like RELAX_NOMACRO, but indicates that the macro appears in a branch
	delay slot.

   RELAX_DELAY_SLOT_16BIT
	Like RELAX_DELAY_SLOT, but indicates that the delay slot requires a
	16-bit instruction.

   RELAX_DELAY_SLOT_SIZE_FIRST
	Like RELAX_DELAY_SLOT, but indicates that the first implementation of
	the macro is of the wrong size for the branch delay slot.

   RELAX_DELAY_SLOT_SIZE_SECOND
	Like RELAX_DELAY_SLOT, but indicates that the second implementation of
	the macro is of the wrong size for the branch delay slot.

   The frag's "opcode" points to the first fixup for relaxable code.

   Relaxable macros are generated using a sequence such as:

      relax_start (SYMBOL);
      ... generate first expansion ...
      relax_switch ();
      ... generate second expansion ...
      relax_end ();

   The code and fixups for the unwanted alternative are discarded
   by md_convert_frag.  */
#define RELAX_ENCODE(FIRST, SECOND) (((FIRST) << 8) | (SECOND))

#define RELAX_FIRST(X) (((X) >> 8) & 0xff)
#define RELAX_SECOND(X) ((X) & 0xff)
#define RELAX_USE_SECOND 0x10000
#define RELAX_SECOND_LONGER 0x20000
#define RELAX_NOMACRO 0x40000
#define RELAX_DELAY_SLOT 0x80000
#define RELAX_DELAY_SLOT_16BIT 0x100000
#define RELAX_DELAY_SLOT_SIZE_FIRST 0x200000
#define RELAX_DELAY_SLOT_SIZE_SECOND 0x400000

/* Branch without likely bit.  If label is out of range, we turn:

 	beq reg1, reg2, label
	delay slot

   into

        bne reg1, reg2, 0f
        nop
        j label
     0: delay slot

   with the following opcode replacements:

	beq <-> bne
	blez <-> bgtz
	bltz <-> bgez
	bc1f <-> bc1t

	bltzal <-> bgezal  (with jal label instead of j label)

   Even though keeping the delay slot instruction in the delay slot of
   the branch would be more efficient, it would be very tricky to do
   correctly, because we'd have to introduce a variable frag *after*
   the delay slot instruction, and expand that instead.  Let's do it
   the easy way for now, even if the branch-not-taken case now costs
   one additional instruction.  Out-of-range branches are not supposed
   to be common, anyway.

   Branch likely.  If label is out of range, we turn:

	beql reg1, reg2, label
	delay slot (annulled if branch not taken)

   into

        beql reg1, reg2, 1f
        nop
        beql $0, $0, 2f
        nop
     1: j[al] label
        delay slot (executed only if branch taken)
     2:

   It would be possible to generate a shorter sequence by losing the
   likely bit, generating something like:

	bne reg1, reg2, 0f
	nop
	j[al] label
	delay slot (executed only if branch taken)
     0:

	beql -> bne
	bnel -> beq
	blezl -> bgtz
	bgtzl -> blez
	bltzl -> bgez
	bgezl -> bltz
	bc1fl -> bc1t
	bc1tl -> bc1f

	bltzall -> bgezal  (with jal label instead of j label)
	bgezall -> bltzal  (ditto)


   but it's not clear that it would actually improve performance.  */
#define RELAX_BRANCH_ENCODE(at, uncond, likely, link, toofar)	\
  ((relax_substateT)						\
   (0xc0000000							\
    | ((at) & 0x1f)						\
    | ((toofar) ? 0x20 : 0)					\
    | ((link) ? 0x40 : 0)					\
    | ((likely) ? 0x80 : 0)					\
    | ((uncond) ? 0x100 : 0)))
#define RELAX_BRANCH_P(i) (((i) & 0xf0000000) == 0xc0000000)
#define RELAX_BRANCH_UNCOND(i) (((i) & 0x100) != 0)
#define RELAX_BRANCH_LIKELY(i) (((i) & 0x80) != 0)
#define RELAX_BRANCH_LINK(i) (((i) & 0x40) != 0)
#define RELAX_BRANCH_TOOFAR(i) (((i) & 0x20) != 0)
#define RELAX_BRANCH_AT(i) ((i) & 0x1f)

/* For mips16 code, we use an entirely different form of relaxation.
   mips16 supports two versions of most instructions which take
   immediate values: a small one which takes some small value, and a
   larger one which takes a 16 bit value.  Since branches also follow
   this pattern, relaxing these values is required.

   We can assemble both mips16 and normal MIPS code in a single
   object.  Therefore, we need to support this type of relaxation at
   the same time that we support the relaxation described above.  We
   use the high bit of the subtype field to distinguish these cases.

   The information we store for this type of relaxation is the
   argument code found in the opcode file for this relocation, whether
   the user explicitly requested a small or extended form, and whether
   the relocation is in a jump or jal delay slot.  That tells us the
   size of the value, and how it should be stored.  We also store
   whether the fragment is considered to be extended or not.  We also
   store whether this is known to be a branch to a different section,
   whether we have tried to relax this frag yet, and whether we have
   ever extended a PC relative fragment because of a shift count.  */
#define RELAX_MIPS16_ENCODE(type, small, ext, dslot, jal_dslot)	\
  (0x80000000							\
   | ((type) & 0xff)						\
   | ((small) ? 0x100 : 0)					\
   | ((ext) ? 0x200 : 0)					\
   | ((dslot) ? 0x400 : 0)					\
   | ((jal_dslot) ? 0x800 : 0))
#define RELAX_MIPS16_P(i) (((i) & 0xc0000000) == 0x80000000)
#define RELAX_MIPS16_TYPE(i) ((i) & 0xff)
#define RELAX_MIPS16_USER_SMALL(i) (((i) & 0x100) != 0)
#define RELAX_MIPS16_USER_EXT(i) (((i) & 0x200) != 0)
#define RELAX_MIPS16_DSLOT(i) (((i) & 0x400) != 0)
#define RELAX_MIPS16_JAL_DSLOT(i) (((i) & 0x800) != 0)
#define RELAX_MIPS16_EXTENDED(i) (((i) & 0x1000) != 0)
#define RELAX_MIPS16_MARK_EXTENDED(i) ((i) | 0x1000)
#define RELAX_MIPS16_CLEAR_EXTENDED(i) ((i) &~ 0x1000)
#define RELAX_MIPS16_LONG_BRANCH(i) (((i) & 0x2000) != 0)
#define RELAX_MIPS16_MARK_LONG_BRANCH(i) ((i) | 0x2000)
#define RELAX_MIPS16_CLEAR_LONG_BRANCH(i) ((i) &~ 0x2000)

/* For microMIPS code, we use relaxation similar to one we use for
   MIPS16 code.  Some instructions that take immediate values support
   two encodings: a small one which takes some small value, and a
   larger one which takes a 16 bit value.  As some branches also follow
   this pattern, relaxing these values is required.

   We can assemble both microMIPS and normal MIPS code in a single
   object.  Therefore, we need to support this type of relaxation at
   the same time that we support the relaxation described above.  We
   use one of the high bits of the subtype field to distinguish these
   cases.

   The information we store for this type of relaxation is the argument
   code found in the opcode file for this relocation, the register
   selected as the assembler temporary, whether the branch is
   unconditional, whether it is compact, whether it stores the link
   address implicitly in $ra, whether relaxation of out-of-range 32-bit
   branches to a sequence of instructions is enabled, and whether the
   displacement of a branch is too large to fit as an immediate argument
   of a 16-bit and a 32-bit branch, respectively.  */
#define RELAX_MICROMIPS_ENCODE(type, at, uncond, compact, link,	\
			       relax32, toofar16, toofar32)	\
  (0x40000000							\
   | ((type) & 0xff)						\
   | (((at) & 0x1f) << 8)					\
   | ((uncond) ? 0x2000 : 0)					\
   | ((compact) ? 0x4000 : 0)					\
   | ((link) ? 0x8000 : 0)					\
   | ((relax32) ? 0x10000 : 0)					\
   | ((toofar16) ? 0x20000 : 0)					\
   | ((toofar32) ? 0x40000 : 0))
#define RELAX_MICROMIPS_P(i) (((i) & 0xc0000000) == 0x40000000)
#define RELAX_MICROMIPS_TYPE(i) ((i) & 0xff)
#define RELAX_MICROMIPS_AT(i) (((i) >> 8) & 0x1f)
#define RELAX_MICROMIPS_UNCOND(i) (((i) & 0x2000) != 0)
#define RELAX_MICROMIPS_COMPACT(i) (((i) & 0x4000) != 0)
#define RELAX_MICROMIPS_LINK(i) (((i) & 0x8000) != 0)
#define RELAX_MICROMIPS_RELAX32(i) (((i) & 0x10000) != 0)

#define RELAX_MICROMIPS_TOOFAR16(i) (((i) & 0x20000) != 0)
#define RELAX_MICROMIPS_MARK_TOOFAR16(i) ((i) | 0x20000)
#define RELAX_MICROMIPS_CLEAR_TOOFAR16(i) ((i) & ~0x20000)
#define RELAX_MICROMIPS_TOOFAR32(i) (((i) & 0x40000) != 0)
#define RELAX_MICROMIPS_MARK_TOOFAR32(i) ((i) | 0x40000)
#define RELAX_MICROMIPS_CLEAR_TOOFAR32(i) ((i) & ~0x40000)

/* Sign-extend 16-bit value X.  */
#define SEXT_16BIT(X) ((((X) + 0x8000) & 0xffff) - 0x8000)

/* Is the given value a sign-extended 32-bit value?  */
#define IS_SEXT_32BIT_NUM(x)						\
  (((x) &~ (offsetT) 0x7fffffff) == 0					\
   || (((x) &~ (offsetT) 0x7fffffff) == ~ (offsetT) 0x7fffffff))

/* Is the given value a sign-extended 16-bit value?  */
#define IS_SEXT_16BIT_NUM(x)						\
  (((x) &~ (offsetT) 0x7fff) == 0					\
   || (((x) &~ (offsetT) 0x7fff) == ~ (offsetT) 0x7fff))

/* Is the given value a sign-extended 12-bit value?  */
#define IS_SEXT_12BIT_NUM(x)						\
  (((((x) & 0xfff) ^ 0x800LL) - 0x800LL) == (x))

/* Is the given value a sign-extended 9-bit value?  */
#define IS_SEXT_9BIT_NUM(x)						\
  (((((x) & 0x1ff) ^ 0x100LL) - 0x100LL) == (x))

/* Is the given value a zero-extended 32-bit value?  Or a negated one?  */
#define IS_ZEXT_32BIT_NUM(x)						\
  (((x) &~ (offsetT) 0xffffffff) == 0					\
   || (((x) &~ (offsetT) 0xffffffff) == ~ (offsetT) 0xffffffff))

/* Extract bits MASK << SHIFT from STRUCT and shift them right
   SHIFT places.  */
#define EXTRACT_BITS(STRUCT, MASK, SHIFT) \
  (((STRUCT) >> (SHIFT)) & (MASK))

/* Extract the operand given by FIELD from mips_cl_insn INSN.  */
#define EXTRACT_OPERAND(MICROMIPS, FIELD, INSN) \
  (!(MICROMIPS) \
   ? EXTRACT_BITS ((INSN).insn_opcode, OP_MASK_##FIELD, OP_SH_##FIELD) \
   : EXTRACT_BITS ((INSN).insn_opcode, \
		   MICROMIPSOP_MASK_##FIELD, MICROMIPSOP_SH_##FIELD))
#define MIPS16_EXTRACT_OPERAND(FIELD, INSN) \
  EXTRACT_BITS ((INSN).insn_opcode, \
		MIPS16OP_MASK_##FIELD, \
		MIPS16OP_SH_##FIELD)

/* The MIPS16 EXTEND opcode, shifted left 16 places.  */
#define MIPS16_EXTEND (0xf000U << 16)

/* Whether or not we are emitting a branch-likely macro.  */
static bfd_boolean emit_branch_likely_macro = FALSE;

/* Global variables used when generating relaxable macros.  See the
   comment above RELAX_ENCODE for more details about how relaxation
   is used.  */
static struct {
  /* 0 if we're not emitting a relaxable macro.
     1 if we're emitting the first of the two relaxation alternatives.
     2 if we're emitting the second alternative.  */
  int sequence;

  /* The first relaxable fixup in the current frag.  (In other words,
     the first fixup that refers to relaxable code.)  */
  fixS *first_fixup;

  /* sizes[0] says how many bytes of the first alternative are stored in
     the current frag.  Likewise sizes[1] for the second alternative.  */
  unsigned int sizes[2];

  /* The symbol on which the choice of sequence depends.  */
  symbolS *symbol;
} mips_relax;

/* Global variables used to decide whether a macro needs a warning.  */
static struct {
  /* True if the macro is in a branch delay slot.  */
  bfd_boolean delay_slot_p;

  /* Set to the length in bytes required if the macro is in a delay slot
     that requires a specific length of instruction, otherwise zero.  */
  unsigned int delay_slot_length;

  /* For relaxable macros, sizes[0] is the length of the first alternative
     in bytes and sizes[1] is the length of the second alternative.
     For non-relaxable macros, both elements give the length of the
     macro in bytes.  */
  unsigned int sizes[2];

  /* For relaxable macros, first_insn_sizes[0] is the length of the first
     instruction of the first alternative in bytes and first_insn_sizes[1]
     is the length of the first instruction of the second alternative.
     For non-relaxable macros, both elements give the length of the first
     instruction in bytes.

     Set to zero if we haven't yet seen the first instruction.  */
  unsigned int first_insn_sizes[2];

  /* For relaxable macros, insns[0] is the number of instructions for the
     first alternative and insns[1] is the number of instructions for the
     second alternative.

     For non-relaxable macros, both elements give the number of
     instructions for the macro.  */
  unsigned int insns[2];

  /* The first variant frag for this macro.  */
  fragS *first_frag;
} mips_macro_warning;

/* Prototypes for static functions.  */

enum mips_regclass { MIPS_GR_REG, MIPS_FP_REG, MIPS16_REG };

static void append_insn
  (struct mips_cl_insn *, expressionS *, bfd_reloc_code_real_type *,
   bfd_boolean expansionp);
static void mips_no_prev_insn (void);
static void macro_build (expressionS *, const char *, const char *, ...);
static void mips16_macro_build
  (expressionS *, const char *, const char *, va_list *);
static void load_register (int, expressionS *, int);
static void macro_start (void);
static void macro_end (void);
static void macro (struct mips_cl_insn *ip, char *str);
static void mips16_macro (struct mips_cl_insn * ip);
static void mips_ip (char *str, struct mips_cl_insn * ip);
static void mips16_ip (char *str, struct mips_cl_insn * ip);
static void mips16_immed
  (char *, unsigned int, int, bfd_reloc_code_real_type, offsetT,
   unsigned int, unsigned long *);
static size_t my_getSmallExpression
  (expressionS *, bfd_reloc_code_real_type *, char *);
static void my_getExpression (expressionS *, char *);
static void s_align (int);
static void s_change_sec (int);
static void s_change_section (int);
static void s_cons (int);
static void s_float_cons (int);
static void s_mips_globl (int);
static void s_option (int);
static void s_mipsset (int);
static void s_abicalls (int);
static void s_cpload (int);
static void s_cpsetup (int);
static void s_cplocal (int);
static void s_cprestore (int);
static void s_cpreturn (int);
static void s_dtprelword (int);
static void s_dtpreldword (int);
static void s_tprelword (int);
static void s_tpreldword (int);
static void s_gpvalue (int);
static void s_gpword (int);
static void s_gpdword (int);
static void s_ehword (int);
static void s_cpadd (int);
static void s_insn (int);
static void s_nan (int);
static void md_obj_begin (void);
static void md_obj_end (void);
static void s_mips_ent (int);
static void s_mips_end (int);
static void s_mips_frame (int);
static void s_mips_mask (int reg_type);
static void s_mips_stab (int);
static void s_mips_weakext (int);
static void s_mips_file (int);
static void s_mips_loc (int);
static bfd_boolean pic_need_relax (symbolS *, asection *);
static int relaxed_branch_length (fragS *, asection *, int);
static int relaxed_micromips_16bit_branch_length (fragS *, asection *, int);
static int relaxed_micromips_32bit_branch_length (fragS *, asection *, int);

/* Table and functions used to map between CPU/ISA names, and
   ISA levels, and CPU numbers.  */

struct mips_cpu_info
{
  const char *name;           /* CPU or ISA name.  */
  int flags;                  /* MIPS_CPU_* flags.  */
  int ase;                    /* Set of ASEs implemented by the CPU.  */
  int isa;                    /* ISA level.  */
  int cpu;                    /* CPU number (default CPU if ISA).  */
};

#define MIPS_CPU_IS_ISA		0x0001	/* Is this an ISA?  (If 0, a CPU.) */

static const struct mips_cpu_info *mips_parse_cpu (const char *, const char *);
static const struct mips_cpu_info *mips_cpu_info_from_isa (int);
static const struct mips_cpu_info *mips_cpu_info_from_arch (int);

/* Command-line options.  */
const char *md_shortopts = "O::g::G:";

enum options
  {
    OPTION_MARCH = OPTION_MD_BASE,
    OPTION_MTUNE,
    OPTION_MIPS1,
    OPTION_MIPS2,
    OPTION_MIPS3,
    OPTION_MIPS4,
    OPTION_MIPS5,
    OPTION_MIPS32,
    OPTION_MIPS64,
    OPTION_MIPS32R2,
    OPTION_MIPS64R2,
    OPTION_MIPS16,
    OPTION_NO_MIPS16,
    OPTION_MIPS3D,
    OPTION_NO_MIPS3D,
    OPTION_MDMX,
    OPTION_NO_MDMX,
    OPTION_DSP,
    OPTION_NO_DSP,
    OPTION_MT,
    OPTION_NO_MT,
    OPTION_VIRT,
    OPTION_NO_VIRT,
    OPTION_MSA,
    OPTION_NO_MSA,
    OPTION_SMARTMIPS,
    OPTION_NO_SMARTMIPS,
    OPTION_DSPR2,
    OPTION_NO_DSPR2,
    OPTION_EVA,
    OPTION_NO_EVA,
    OPTION_MICROMIPS,
    OPTION_NO_MICROMIPS,
    OPTION_MCU,
    OPTION_NO_MCU,
    OPTION_COMPAT_ARCH_BASE,
    OPTION_M4650,
    OPTION_NO_M4650,
    OPTION_M4010,
    OPTION_NO_M4010,
    OPTION_M4100,
    OPTION_NO_M4100,
    OPTION_M3900,
    OPTION_NO_M3900,
    OPTION_M7000_HILO_FIX,
    OPTION_MNO_7000_HILO_FIX,
    OPTION_FIX_24K,
    OPTION_NO_FIX_24K,
    OPTION_FIX_LOONGSON2F_JUMP,
    OPTION_NO_FIX_LOONGSON2F_JUMP,
    OPTION_FIX_LOONGSON2F_NOP,
    OPTION_NO_FIX_LOONGSON2F_NOP,
    OPTION_FIX_VR4120,
    OPTION_NO_FIX_VR4120,
    OPTION_FIX_VR4130,
    OPTION_NO_FIX_VR4130,
    OPTION_FIX_CN63XXP1,
    OPTION_NO_FIX_CN63XXP1,
    OPTION_TRAP,
    OPTION_BREAK,
    OPTION_EB,
    OPTION_EL,
    OPTION_FP32,
    OPTION_GP32,
    OPTION_CONSTRUCT_FLOATS,
    OPTION_NO_CONSTRUCT_FLOATS,
    OPTION_FP64,
    OPTION_GP64,
    OPTION_RELAX_BRANCH,
    OPTION_NO_RELAX_BRANCH,
    OPTION_INSN32,
    OPTION_NO_INSN32,
    OPTION_MSHARED,
    OPTION_MNO_SHARED,
    OPTION_MSYM32,
    OPTION_MNO_SYM32,
    OPTION_SOFT_FLOAT,
    OPTION_HARD_FLOAT,
    OPTION_SINGLE_FLOAT,
    OPTION_DOUBLE_FLOAT,
    OPTION_32,
    OPTION_CALL_SHARED,
    OPTION_CALL_NONPIC,
    OPTION_NON_SHARED,
    OPTION_XGOT,
    OPTION_MABI,
    OPTION_N32,
    OPTION_64,
    OPTION_MDEBUG,
    OPTION_NO_MDEBUG,
    OPTION_PDR,
    OPTION_NO_PDR,
    OPTION_MVXWORKS_PIC,
    OPTION_NAN,
    OPTION_END_OF_ENUM
  };

struct option md_longopts[] =
{
  /* Options which specify architecture.  */
  {"march", required_argument, NULL, OPTION_MARCH},
  {"mtune", required_argument, NULL, OPTION_MTUNE},
  {"mips0", no_argument, NULL, OPTION_MIPS1},
  {"mips1", no_argument, NULL, OPTION_MIPS1},
  {"mips2", no_argument, NULL, OPTION_MIPS2},
  {"mips3", no_argument, NULL, OPTION_MIPS3},
  {"mips4", no_argument, NULL, OPTION_MIPS4},
  {"mips5", no_argument, NULL, OPTION_MIPS5},
  {"mips32", no_argument, NULL, OPTION_MIPS32},
  {"mips64", no_argument, NULL, OPTION_MIPS64},
  {"mips32r2", no_argument, NULL, OPTION_MIPS32R2},
  {"mips64r2", no_argument, NULL, OPTION_MIPS64R2},

  /* Options which specify Application Specific Extensions (ASEs).  */
  {"mips16", no_argument, NULL, OPTION_MIPS16},
  {"no-mips16", no_argument, NULL, OPTION_NO_MIPS16},
  {"mips3d", no_argument, NULL, OPTION_MIPS3D},
  {"no-mips3d", no_argument, NULL, OPTION_NO_MIPS3D},
  {"mdmx", no_argument, NULL, OPTION_MDMX},
  {"no-mdmx", no_argument, NULL, OPTION_NO_MDMX},
  {"mdsp", no_argument, NULL, OPTION_DSP},
  {"mno-dsp", no_argument, NULL, OPTION_NO_DSP},
  {"mmt", no_argument, NULL, OPTION_MT},
  {"mno-mt", no_argument, NULL, OPTION_NO_MT},
  {"msmartmips", no_argument, NULL, OPTION_SMARTMIPS},
  {"mno-smartmips", no_argument, NULL, OPTION_NO_SMARTMIPS},
  {"mdspr2", no_argument, NULL, OPTION_DSPR2},
  {"mno-dspr2", no_argument, NULL, OPTION_NO_DSPR2},
  {"meva", no_argument, NULL, OPTION_EVA},
  {"mno-eva", no_argument, NULL, OPTION_NO_EVA},
  {"mmicromips", no_argument, NULL, OPTION_MICROMIPS},
  {"mno-micromips", no_argument, NULL, OPTION_NO_MICROMIPS},
  {"mmcu", no_argument, NULL, OPTION_MCU},
  {"mno-mcu", no_argument, NULL, OPTION_NO_MCU},
  {"mvirt", no_argument, NULL, OPTION_VIRT},
  {"mno-virt", no_argument, NULL, OPTION_NO_VIRT},
  {"mmsa", no_argument, NULL, OPTION_MSA},
  {"mno-msa", no_argument, NULL, OPTION_NO_MSA},

  /* Old-style architecture options.  Don't add more of these.  */
  {"m4650", no_argument, NULL, OPTION_M4650},
  {"no-m4650", no_argument, NULL, OPTION_NO_M4650},
  {"m4010", no_argument, NULL, OPTION_M4010},
  {"no-m4010", no_argument, NULL, OPTION_NO_M4010},
  {"m4100", no_argument, NULL, OPTION_M4100},
  {"no-m4100", no_argument, NULL, OPTION_NO_M4100},
  {"m3900", no_argument, NULL, OPTION_M3900},
  {"no-m3900", no_argument, NULL, OPTION_NO_M3900},

  /* Options which enable bug fixes.  */
  {"mfix7000", no_argument, NULL, OPTION_M7000_HILO_FIX},
  {"no-fix-7000", no_argument, NULL, OPTION_MNO_7000_HILO_FIX},
  {"mno-fix7000", no_argument, NULL, OPTION_MNO_7000_HILO_FIX},
  {"mfix-loongson2f-jump", no_argument, NULL, OPTION_FIX_LOONGSON2F_JUMP},
  {"mno-fix-loongson2f-jump", no_argument, NULL, OPTION_NO_FIX_LOONGSON2F_JUMP},
  {"mfix-loongson2f-nop", no_argument, NULL, OPTION_FIX_LOONGSON2F_NOP},
  {"mno-fix-loongson2f-nop", no_argument, NULL, OPTION_NO_FIX_LOONGSON2F_NOP},
  {"mfix-vr4120",    no_argument, NULL, OPTION_FIX_VR4120},
  {"mno-fix-vr4120", no_argument, NULL, OPTION_NO_FIX_VR4120},
  {"mfix-vr4130",    no_argument, NULL, OPTION_FIX_VR4130},
  {"mno-fix-vr4130", no_argument, NULL, OPTION_NO_FIX_VR4130},
  {"mfix-24k",    no_argument, NULL, OPTION_FIX_24K},
  {"mno-fix-24k", no_argument, NULL, OPTION_NO_FIX_24K},
  {"mfix-cn63xxp1", no_argument, NULL, OPTION_FIX_CN63XXP1},
  {"mno-fix-cn63xxp1", no_argument, NULL, OPTION_NO_FIX_CN63XXP1},

  /* Miscellaneous options.  */
  {"trap", no_argument, NULL, OPTION_TRAP},
  {"no-break", no_argument, NULL, OPTION_TRAP},
  {"break", no_argument, NULL, OPTION_BREAK},
  {"no-trap", no_argument, NULL, OPTION_BREAK},
  {"EB", no_argument, NULL, OPTION_EB},
  {"EL", no_argument, NULL, OPTION_EL},
  {"mfp32", no_argument, NULL, OPTION_FP32},
  {"mgp32", no_argument, NULL, OPTION_GP32},
  {"construct-floats", no_argument, NULL, OPTION_CONSTRUCT_FLOATS},
  {"no-construct-floats", no_argument, NULL, OPTION_NO_CONSTRUCT_FLOATS},
  {"mfp64", no_argument, NULL, OPTION_FP64},
  {"mgp64", no_argument, NULL, OPTION_GP64},
  {"relax-branch", no_argument, NULL, OPTION_RELAX_BRANCH},
  {"no-relax-branch", no_argument, NULL, OPTION_NO_RELAX_BRANCH},
  {"minsn32", no_argument, NULL, OPTION_INSN32},
  {"mno-insn32", no_argument, NULL, OPTION_NO_INSN32},
  {"mshared", no_argument, NULL, OPTION_MSHARED},
  {"mno-shared", no_argument, NULL, OPTION_MNO_SHARED},
  {"msym32", no_argument, NULL, OPTION_MSYM32},
  {"mno-sym32", no_argument, NULL, OPTION_MNO_SYM32},
  {"msoft-float", no_argument, NULL, OPTION_SOFT_FLOAT},
  {"mhard-float", no_argument, NULL, OPTION_HARD_FLOAT},
  {"msingle-float", no_argument, NULL, OPTION_SINGLE_FLOAT},
  {"mdouble-float", no_argument, NULL, OPTION_DOUBLE_FLOAT},

  /* Strictly speaking this next option is ELF specific,
     but we allow it for other ports as well in order to
     make testing easier.  */
  {"32", no_argument, NULL, OPTION_32},

  /* ELF-specific options.  */
  {"KPIC", no_argument, NULL, OPTION_CALL_SHARED},
  {"call_shared", no_argument, NULL, OPTION_CALL_SHARED},
  {"call_nonpic", no_argument, NULL, OPTION_CALL_NONPIC},
  {"non_shared",  no_argument, NULL, OPTION_NON_SHARED},
  {"xgot", no_argument, NULL, OPTION_XGOT},
  {"mabi", required_argument, NULL, OPTION_MABI},
  {"n32", no_argument, NULL, OPTION_N32},
  {"64", no_argument, NULL, OPTION_64},
  {"mdebug", no_argument, NULL, OPTION_MDEBUG},
  {"no-mdebug", no_argument, NULL, OPTION_NO_MDEBUG},
  {"mpdr", no_argument, NULL, OPTION_PDR},
  {"mno-pdr", no_argument, NULL, OPTION_NO_PDR},
  {"mvxworks-pic", no_argument, NULL, OPTION_MVXWORKS_PIC},
  {"mnan", required_argument, NULL, OPTION_NAN},

  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

/* Information about either an Application Specific Extension or an
   optional architecture feature that, for simplicity, we treat in the
   same way as an ASE.  */
struct mips_ase
{
  /* The name of the ASE, used in both the command-line and .set options.  */
  const char *name;

  /* The associated ASE_* flags.  If the ASE is available on both 32-bit
     and 64-bit architectures, the flags here refer to the subset that
     is available on both.  */
  unsigned int flags;

  /* The ASE_* flag used for instructions that are available on 64-bit
     architectures but that are not included in FLAGS.  */
  unsigned int flags64;

  /* The command-line options that turn the ASE on and off.  */
  int option_on;
  int option_off;

  /* The minimum required architecture revisions for MIPS32, MIPS64,
     microMIPS32 and microMIPS64, or -1 if the extension isn't supported.  */
  int mips32_rev;
  int mips64_rev;
  int micromips32_rev;
  int micromips64_rev;
};

/* A table of all supported ASEs.  */
static const struct mips_ase mips_ases[] = {
  { "dsp", ASE_DSP, ASE_DSP64,
    OPTION_DSP, OPTION_NO_DSP,
    2, 2, 2, 2 },

  { "dspr2", ASE_DSP | ASE_DSPR2, 0,
    OPTION_DSPR2, OPTION_NO_DSPR2,
    2, 2, 2, 2 },

  { "eva", ASE_EVA, 0,
    OPTION_EVA, OPTION_NO_EVA,
    2, 2, 2, 2 },

  { "mcu", ASE_MCU, 0,
    OPTION_MCU, OPTION_NO_MCU,
    2, 2, 2, 2 },

  /* Deprecated in MIPS64r5, but we don't implement that yet.  */
  { "mdmx", ASE_MDMX, 0,
    OPTION_MDMX, OPTION_NO_MDMX,
    -1, 1, -1, -1 },

  /* Requires 64-bit FPRs, so the minimum MIPS32 revision is 2.  */
  { "mips3d", ASE_MIPS3D, 0,
    OPTION_MIPS3D, OPTION_NO_MIPS3D,
    2, 1, -1, -1 },

  { "mt", ASE_MT, 0,
    OPTION_MT, OPTION_NO_MT,
    2, 2, -1, -1 },

  { "smartmips", ASE_SMARTMIPS, 0,
    OPTION_SMARTMIPS, OPTION_NO_SMARTMIPS,
    1, -1, -1, -1 },

  { "virt", ASE_VIRT, ASE_VIRT64,
    OPTION_VIRT, OPTION_NO_VIRT,
    2, 2, 2, 2 },

  { "msa", ASE_MSA, ASE_MSA64,
    OPTION_MSA, OPTION_NO_MSA,
    2, 2, 2, 2 }
};

/* The set of ASEs that require -mfp64.  */
#define FP64_ASES (ASE_MIPS3D | ASE_MDMX)

/* Groups of ASE_* flags that represent different revisions of an ASE.  */
static const unsigned int mips_ase_groups[] = {
  ASE_DSP | ASE_DSPR2
};

/* Pseudo-op table.

   The following pseudo-ops from the Kane and Heinrich MIPS book
   should be defined here, but are currently unsupported: .alias,
   .galive, .gjaldef, .gjrlive, .livereg, .noalias.

   The following pseudo-ops from the Kane and Heinrich MIPS book are
   specific to the type of debugging information being generated, and
   should be defined by the object format: .aent, .begin, .bend,
   .bgnb, .end, .endb, .ent, .fmask, .frame, .loc, .mask, .verstamp,
   .vreg.

   The following pseudo-ops from the Kane and Heinrich MIPS book are
   not MIPS CPU specific, but are also not specific to the object file
   format.  This file is probably the best place to define them, but
   they are not currently supported: .asm0, .endr, .lab, .struct.  */

static const pseudo_typeS mips_pseudo_table[] =
{
  /* MIPS specific pseudo-ops.  */
  {"option", s_option, 0},
  {"set", s_mipsset, 0},
  {"rdata", s_change_sec, 'r'},
  {"sdata", s_change_sec, 's'},
  {"livereg", s_ignore, 0},
  {"abicalls", s_abicalls, 0},
  {"cpload", s_cpload, 0},
  {"cpsetup", s_cpsetup, 0},
  {"cplocal", s_cplocal, 0},
  {"cprestore", s_cprestore, 0},
  {"cpreturn", s_cpreturn, 0},
  {"dtprelword", s_dtprelword, 0},
  {"dtpreldword", s_dtpreldword, 0},
  {"tprelword", s_tprelword, 0},
  {"tpreldword", s_tpreldword, 0},
  {"gpvalue", s_gpvalue, 0},
  {"gpword", s_gpword, 0},
  {"gpdword", s_gpdword, 0},
  {"ehword", s_ehword, 0},
  {"cpadd", s_cpadd, 0},
  {"insn", s_insn, 0},
  {"nan", s_nan, 0},

  /* Relatively generic pseudo-ops that happen to be used on MIPS
     chips.  */
  {"asciiz", stringer, 8 + 1},
  {"bss", s_change_sec, 'b'},
  {"err", s_err, 0},
  {"half", s_cons, 1},
  {"dword", s_cons, 3},
  {"weakext", s_mips_weakext, 0},
  {"origin", s_org, 0},
  {"repeat", s_rept, 0},

  /* For MIPS this is non-standard, but we define it for consistency.  */
  {"sbss", s_change_sec, 'B'},

  /* These pseudo-ops are defined in read.c, but must be overridden
     here for one reason or another.  */
  {"align", s_align, 0},
  {"byte", s_cons, 0},
  {"data", s_change_sec, 'd'},
  {"double", s_float_cons, 'd'},
  {"float", s_float_cons, 'f'},
  {"globl", s_mips_globl, 0},
  {"global", s_mips_globl, 0},
  {"hword", s_cons, 1},
  {"int", s_cons, 2},
  {"long", s_cons, 2},
  {"octa", s_cons, 4},
  {"quad", s_cons, 3},
  {"section", s_change_section, 0},
  {"short", s_cons, 1},
  {"single", s_float_cons, 'f'},
  {"stabd", s_mips_stab, 'd'},
  {"stabn", s_mips_stab, 'n'},
  {"stabs", s_mips_stab, 's'},
  {"text", s_change_sec, 't'},
  {"word", s_cons, 2},

  { "extern", ecoff_directive_extern, 0},

  { NULL, NULL, 0 },
};

static const pseudo_typeS mips_nonecoff_pseudo_table[] =
{
  /* These pseudo-ops should be defined by the object file format.
     However, a.out doesn't support them, so we have versions here.  */
  {"aent", s_mips_ent, 1},
  {"bgnb", s_ignore, 0},
  {"end", s_mips_end, 0},
  {"endb", s_ignore, 0},
  {"ent", s_mips_ent, 0},
  {"file", s_mips_file, 0},
  {"fmask", s_mips_mask, 'F'},
  {"frame", s_mips_frame, 0},
  {"loc", s_mips_loc, 0},
  {"mask", s_mips_mask, 'R'},
  {"verstamp", s_ignore, 0},
  { NULL, NULL, 0 },
};

/* Export the ABI address size for use by TC_ADDRESS_BYTES for the
   purpose of the `.dc.a' internal pseudo-op.  */

int
mips_address_bytes (void)
{
  return HAVE_64BIT_ADDRESSES ? 8 : 4;
}

extern void pop_insert (const pseudo_typeS *);

void
mips_pop_insert (void)
{
  pop_insert (mips_pseudo_table);
  if (! ECOFF_DEBUGGING)
    pop_insert (mips_nonecoff_pseudo_table);
}

/* Symbols labelling the current insn.  */

struct insn_label_list
{
  struct insn_label_list *next;
  symbolS *label;
};

static struct insn_label_list *free_insn_labels;
#define label_list tc_segment_info_data.labels

static void mips_clear_insn_labels (void);
static void mips_mark_labels (void);
static void mips_compressed_mark_labels (void);

static inline void
mips_clear_insn_labels (void)
{
  register struct insn_label_list **pl;
  segment_info_type *si;

  if (now_seg)
    {
      for (pl = &free_insn_labels; *pl != NULL; pl = &(*pl)->next)
	;
      
      si = seg_info (now_seg);
      *pl = si->label_list;
      si->label_list = NULL;
    }
}

/* Mark instruction labels in MIPS16/microMIPS mode.  */

static inline void
mips_mark_labels (void)
{
  if (HAVE_CODE_COMPRESSION)
    mips_compressed_mark_labels ();
}

static char *expr_end;

/* An expression in a macro instruction.  This is set by mips_ip and
   mips16_ip and when populated is always an O_constant.  */

static expressionS imm_expr;

/* The relocatable field in an instruction and the relocs associated
   with it.  These variables are used for instructions like LUI and
   JAL as well as true offsets.  They are also used for address
   operands in macros.  */

static expressionS offset_expr;
static bfd_reloc_code_real_type offset_reloc[3]
  = {BFD_RELOC_UNUSED, BFD_RELOC_UNUSED, BFD_RELOC_UNUSED};

/* This is set to the resulting size of the instruction to be produced
   by mips16_ip if an explicit extension is used or by mips_ip if an
   explicit size is supplied.  */

static unsigned int forced_insn_length;

/* True if we are assembling an instruction.  All dot symbols defined during
   this time should be treated as code labels.  */

static bfd_boolean mips_assembling_insn;

/* The pdr segment for per procedure frame/regmask info.  Not used for
   ECOFF debugging.  */

static segT pdr_seg;

/* The default target format to use.  */

#if defined (TE_FreeBSD)
#define ELF_TARGET(PREFIX, ENDIAN) PREFIX "trad" ENDIAN "mips-freebsd"
#elif defined (TE_TMIPS)
#define ELF_TARGET(PREFIX, ENDIAN) PREFIX "trad" ENDIAN "mips"
#else
#define ELF_TARGET(PREFIX, ENDIAN) PREFIX ENDIAN "mips"
#endif

const char *
mips_target_format (void)
{
  switch (OUTPUT_FLAVOR)
    {
    case bfd_target_elf_flavour:
#ifdef TE_VXWORKS
      if (!HAVE_64BIT_OBJECTS && !HAVE_NEWABI)
	return (target_big_endian
		? "elf32-bigmips-vxworks"
		: "elf32-littlemips-vxworks");
#endif
      return (target_big_endian
	      ? (HAVE_64BIT_OBJECTS
		 ? ELF_TARGET ("elf64-", "big")
		 : (HAVE_NEWABI
		    ? ELF_TARGET ("elf32-n", "big")
		    : ELF_TARGET ("elf32-", "big")))
	      : (HAVE_64BIT_OBJECTS
		 ? ELF_TARGET ("elf64-", "little")
		 : (HAVE_NEWABI
		    ? ELF_TARGET ("elf32-n", "little")
		    : ELF_TARGET ("elf32-", "little"))));
    default:
      abort ();
      return NULL;
    }
}

/* Return the ISA revision that is currently in use, or 0 if we are
   generating code for MIPS V or below.  */

static int
mips_isa_rev (void)
{
  if (mips_opts.isa == ISA_MIPS32R2 || mips_opts.isa == ISA_MIPS64R2)
    return 2;

  /* microMIPS implies revision 2 or above.  */
  if (mips_opts.micromips)
    return 2;

  if (mips_opts.isa == ISA_MIPS32 || mips_opts.isa == ISA_MIPS64)
    return 1;

  return 0;
}

/* Return the mask of all ASEs that are revisions of those in FLAGS.  */

static unsigned int
mips_ase_mask (unsigned int flags)
{
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (mips_ase_groups); i++)
    if (flags & mips_ase_groups[i])
      flags |= mips_ase_groups[i];
  return flags;
}

/* Check whether the current ISA supports ASE.  Issue a warning if
   appropriate.  */

static void
mips_check_isa_supports_ase (const struct mips_ase *ase)
{
  const char *base;
  int min_rev, size;
  static unsigned int warned_isa;
  static unsigned int warned_fp32;

  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
    min_rev = mips_opts.micromips ? ase->micromips64_rev : ase->mips64_rev;
  else
    min_rev = mips_opts.micromips ? ase->micromips32_rev : ase->mips32_rev;
  if ((min_rev < 0 || mips_isa_rev () < min_rev)
      && (warned_isa & ase->flags) != ase->flags)
    {
      warned_isa |= ase->flags;
      base = mips_opts.micromips ? "microMIPS" : "MIPS";
      size = ISA_HAS_64BIT_REGS (mips_opts.isa) ? 64 : 32;
      if (min_rev < 0)
	as_warn (_("the %d-bit %s architecture does not support the"
		   " `%s' extension"), size, base, ase->name);
      else
	as_warn (_("the `%s' extension requires %s%d revision %d or greater"),
		 ase->name, base, size, min_rev);
    }
  if ((ase->flags & FP64_ASES)
      && mips_opts.fp32
      && (warned_fp32 & ase->flags) != ase->flags)
    {
      warned_fp32 |= ase->flags;
      as_warn (_("the `%s' extension requires 64-bit FPRs"), ase->name);
    }
}

/* Check all enabled ASEs to see whether they are supported by the
   chosen architecture.  */

static void
mips_check_isa_supports_ases (void)
{
  unsigned int i, mask;

  for (i = 0; i < ARRAY_SIZE (mips_ases); i++)
    {
      mask = mips_ase_mask (mips_ases[i].flags);
      if ((mips_opts.ase & mask) == mips_ases[i].flags)
	mips_check_isa_supports_ase (&mips_ases[i]);
    }
}

/* Set the state of ASE to ENABLED_P.  Return the mask of ASE_* flags
   that were affected.  */

static unsigned int
mips_set_ase (const struct mips_ase *ase, bfd_boolean enabled_p)
{
  unsigned int mask;

  mask = mips_ase_mask (ase->flags);
  mips_opts.ase &= ~mask;
  if (enabled_p)
    mips_opts.ase |= ase->flags;
  return mask;
}

/* Return the ASE called NAME, or null if none.  */

static const struct mips_ase *
mips_lookup_ase (const char *name)
{
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (mips_ases); i++)
    if (strcmp (name, mips_ases[i].name) == 0)
      return &mips_ases[i];
  return NULL;
}

/* Return the length of a microMIPS instruction in bytes.  If bits of
   the mask beyond the low 16 are 0, then it is a 16-bit instruction.
   Otherwise assume a 32-bit instruction; 48-bit instructions (0x1f
   major opcode) will require further modifications to the opcode
   table.  */

static inline unsigned int
micromips_insn_length (const struct mips_opcode *mo)
{
  return (mo->mask >> 16) == 0 ? 2 : 4;
}

/* Return the length of MIPS16 instruction OPCODE.  */

static inline unsigned int
mips16_opcode_length (unsigned long opcode)
{
  return (opcode >> 16) == 0 ? 2 : 4;
}

/* Return the length of instruction INSN.  */

static inline unsigned int
insn_length (const struct mips_cl_insn *insn)
{
  if (mips_opts.micromips)
    return micromips_insn_length (insn->insn_mo);
  else if (mips_opts.mips16)
    return mips16_opcode_length (insn->insn_opcode);
  else
    return 4;
}

/* Initialise INSN from opcode entry MO.  Leave its position unspecified.  */

static void
create_insn (struct mips_cl_insn *insn, const struct mips_opcode *mo)
{
  size_t i;

  insn->insn_mo = mo;
  insn->insn_opcode = mo->match;
  insn->frag = NULL;
  insn->where = 0;
  for (i = 0; i < ARRAY_SIZE (insn->fixp); i++)
    insn->fixp[i] = NULL;
  insn->fixed_p = (mips_opts.noreorder > 0);
  insn->noreorder_p = (mips_opts.noreorder > 0);
  insn->mips16_absolute_jump_p = 0;
  insn->complete_p = 0;
  insn->cleared_p = 0;
}

/* Get a list of all the operands in INSN.  */

static const struct mips_operand_array *
insn_operands (const struct mips_cl_insn *insn)
{
  if (insn->insn_mo >= &mips_opcodes[0]
      && insn->insn_mo < &mips_opcodes[NUMOPCODES])
    return &mips_operands[insn->insn_mo - &mips_opcodes[0]];

  if (insn->insn_mo >= &mips16_opcodes[0]
      && insn->insn_mo < &mips16_opcodes[bfd_mips16_num_opcodes])
    return &mips16_operands[insn->insn_mo - &mips16_opcodes[0]];

  if (insn->insn_mo >= &micromips_opcodes[0]
      && insn->insn_mo < &micromips_opcodes[bfd_micromips_num_opcodes])
    return &micromips_operands[insn->insn_mo - &micromips_opcodes[0]];

  abort ();
}

/* Get a description of operand OPNO of INSN.  */

static const struct mips_operand *
insn_opno (const struct mips_cl_insn *insn, unsigned opno)
{
  const struct mips_operand_array *operands;

  operands = insn_operands (insn);
  if (opno >= MAX_OPERANDS || !operands->operand[opno])
    abort ();
  return operands->operand[opno];
}

/* Install UVAL as the value of OPERAND in INSN.  */

static inline void
insn_insert_operand (struct mips_cl_insn *insn,
		     const struct mips_operand *operand, unsigned int uval)
{
  insn->insn_opcode = mips_insert_operand (operand, insn->insn_opcode, uval);
}

/* Extract the value of OPERAND from INSN.  */

static inline unsigned
insn_extract_operand (const struct mips_cl_insn *insn,
		      const struct mips_operand *operand)
{
  return mips_extract_operand (operand, insn->insn_opcode);
}

/* Record the current MIPS16/microMIPS mode in now_seg.  */

static void
mips_record_compressed_mode (void)
{
  segment_info_type *si;

  si = seg_info (now_seg);
  if (si->tc_segment_info_data.mips16 != mips_opts.mips16)
    si->tc_segment_info_data.mips16 = mips_opts.mips16;
  if (si->tc_segment_info_data.micromips != mips_opts.micromips)
    si->tc_segment_info_data.micromips = mips_opts.micromips;
}

/* Read a standard MIPS instruction from BUF.  */

static unsigned long
read_insn (char *buf)
{
  if (target_big_endian)
    return bfd_getb32 ((bfd_byte *) buf);
  else
    return bfd_getl32 ((bfd_byte *) buf);
}

/* Write standard MIPS instruction INSN to BUF.  Return a pointer to
   the next byte.  */

static char *
write_insn (char *buf, unsigned int insn)
{
  md_number_to_chars (buf, insn, 4);
  return buf + 4;
}

/* Read a microMIPS or MIPS16 opcode from BUF, given that it
   has length LENGTH.  */

static unsigned long
read_compressed_insn (char *buf, unsigned int length)
{
  unsigned long insn;
  unsigned int i;

  insn = 0;
  for (i = 0; i < length; i += 2)
    {
      insn <<= 16;
      if (target_big_endian)
	insn |= bfd_getb16 ((char *) buf);
      else
	insn |= bfd_getl16 ((char *) buf);
      buf += 2;
    }
  return insn;
}

/* Write microMIPS or MIPS16 instruction INSN to BUF, given that the
   instruction is LENGTH bytes long.  Return a pointer to the next byte.  */

static char *
write_compressed_insn (char *buf, unsigned int insn, unsigned int length)
{
  unsigned int i;

  for (i = 0; i < length; i += 2)
    md_number_to_chars (buf + i, insn >> ((length - i - 2) * 8), 2);
  return buf + length;
}

/* Install INSN at the location specified by its "frag" and "where" fields.  */

static void
install_insn (const struct mips_cl_insn *insn)
{
  char *f = insn->frag->fr_literal + insn->where;
  if (HAVE_CODE_COMPRESSION)
    write_compressed_insn (f, insn->insn_opcode, insn_length (insn));
  else
    write_insn (f, insn->insn_opcode);
  mips_record_compressed_mode ();
}

/* Move INSN to offset WHERE in FRAG.  Adjust the fixups accordingly
   and install the opcode in the new location.  */

static void
move_insn (struct mips_cl_insn *insn, fragS *frag, long where)
{
  size_t i;

  insn->frag = frag;
  insn->where = where;
  for (i = 0; i < ARRAY_SIZE (insn->fixp); i++)
    if (insn->fixp[i] != NULL)
      {
	insn->fixp[i]->fx_frag = frag;
	insn->fixp[i]->fx_where = where;
      }
  install_insn (insn);
}

/* Add INSN to the end of the output.  */

static void
add_fixed_insn (struct mips_cl_insn *insn)
{
  char *f = frag_more (insn_length (insn));
  move_insn (insn, frag_now, f - frag_now->fr_literal);
}

/* Start a variant frag and move INSN to the start of the variant part,
   marking it as fixed.  The other arguments are as for frag_var.  */

static void
add_relaxed_insn (struct mips_cl_insn *insn, int max_chars, int var,
		  relax_substateT subtype, symbolS *symbol, offsetT offset)
{
  frag_grow (max_chars);
  move_insn (insn, frag_now, frag_more (0) - frag_now->fr_literal);
  insn->fixed_p = 1;
  frag_var (rs_machine_dependent, max_chars, var,
	    subtype, symbol, offset, NULL);
}

/* Insert N copies of INSN into the history buffer, starting at
   position FIRST.  Neither FIRST nor N need to be clipped.  */

static void
insert_into_history (unsigned int first, unsigned int n,
		     const struct mips_cl_insn *insn)
{
  if (mips_relax.sequence != 2)
    {
      unsigned int i;

      for (i = ARRAY_SIZE (history); i-- > first;)
	if (i >= first + n)
	  history[i] = history[i - n];
	else
	  history[i] = *insn;
    }
}

/* Clear the error in insn_error.  */

static void
clear_insn_error (void)
{
  memset (&insn_error, 0, sizeof (insn_error));
}

/* Possibly record error message MSG for the current instruction.
   If the error is about a particular argument, ARGNUM is the 1-based
   number of that argument, otherwise it is 0.  FORMAT is the format
   of MSG.  Return true if MSG was used, false if the current message
   was kept.  */

static bfd_boolean
set_insn_error_format (int argnum, enum mips_insn_error_format format,
		       const char *msg)
{
  if (argnum == 0)
    {
      /* Give priority to errors against specific arguments, and to
	 the first whole-instruction message.  */
      if (insn_error.msg)
	return FALSE;
    }
  else
    {
      /* Keep insn_error if it is against a later argument.  */
      if (argnum < insn_error.min_argnum)
	return FALSE;

      /* If both errors are against the same argument but are different,
	 give up on reporting a specific error for this argument.
	 See the comment about mips_insn_error for details.  */
      if (argnum == insn_error.min_argnum
	  && insn_error.msg
	  && strcmp (insn_error.msg, msg) != 0)
	{
	  insn_error.msg = 0;
	  insn_error.min_argnum += 1;
	  return FALSE;
	}
    }
  insn_error.min_argnum = argnum;
  insn_error.format = format;
  insn_error.msg = msg;
  return TRUE;
}

/* Record an instruction error with no % format fields.  ARGNUM and MSG are
   as for set_insn_error_format.  */

static void
set_insn_error (int argnum, const char *msg)
{
  set_insn_error_format (argnum, ERR_FMT_PLAIN, msg);
}

/* Record an instruction error with one %d field I.  ARGNUM and MSG are
   as for set_insn_error_format.  */

static void
set_insn_error_i (int argnum, const char *msg, int i)
{
  if (set_insn_error_format (argnum, ERR_FMT_I, msg))
    insn_error.u.i = i;
}

/* Record an instruction error with two %s fields S1 and S2.  ARGNUM and MSG
   are as for set_insn_error_format.  */

static void
set_insn_error_ss (int argnum, const char *msg, const char *s1, const char *s2)
{
  if (set_insn_error_format (argnum, ERR_FMT_SS, msg))
    {
      insn_error.u.ss[0] = s1;
      insn_error.u.ss[1] = s2;
    }
}

/* Report the error in insn_error, which is against assembly code STR.  */

static void
report_insn_error (const char *str)
{
  const char *msg;

  msg = ACONCAT ((insn_error.msg, " `%s'", NULL));
  switch (insn_error.format)
    {
    case ERR_FMT_PLAIN:
      as_bad (msg, str);
      break;

    case ERR_FMT_I:
      as_bad (msg, insn_error.u.i, str);
      break;

    case ERR_FMT_SS:
      as_bad (msg, insn_error.u.ss[0], insn_error.u.ss[1], str);
      break;
    }
}

/* Initialize vr4120_conflicts.  There is a bit of duplication here:
   the idea is to make it obvious at a glance that each errata is
   included.  */

static void
init_vr4120_conflicts (void)
{
#define CONFLICT(FIRST, SECOND) \
    vr4120_conflicts[FIX_VR4120_##FIRST] |= 1 << FIX_VR4120_##SECOND

  /* Errata 21 - [D]DIV[U] after [D]MACC */
  CONFLICT (MACC, DIV);
  CONFLICT (DMACC, DIV);

  /* Errata 23 - Continuous DMULT[U]/DMACC instructions.  */
  CONFLICT (DMULT, DMULT);
  CONFLICT (DMULT, DMACC);
  CONFLICT (DMACC, DMULT);
  CONFLICT (DMACC, DMACC);

  /* Errata 24 - MT{LO,HI} after [D]MACC */
  CONFLICT (MACC, MTHILO);
  CONFLICT (DMACC, MTHILO);

  /* VR4181A errata MD(1): "If a MULT, MULTU, DMULT or DMULTU
     instruction is executed immediately after a MACC or DMACC
     instruction, the result of [either instruction] is incorrect."  */
  CONFLICT (MACC, MULT);
  CONFLICT (MACC, DMULT);
  CONFLICT (DMACC, MULT);
  CONFLICT (DMACC, DMULT);

  /* VR4181A errata MD(4): "If a MACC or DMACC instruction is
     executed immediately after a DMULT, DMULTU, DIV, DIVU,
     DDIV or DDIVU instruction, the result of the MACC or
     DMACC instruction is incorrect.".  */
  CONFLICT (DMULT, MACC);
  CONFLICT (DMULT, DMACC);
  CONFLICT (DIV, MACC);
  CONFLICT (DIV, DMACC);

#undef CONFLICT
}

struct regname {
  const char *name;
  unsigned int num;
};

#define RNUM_MASK	0x00000ff
#define RTYPE_MASK	0x0ffff00
#define RTYPE_NUM	0x0000100
#define RTYPE_FPU	0x0000200
#define RTYPE_FCC	0x0000400
#define RTYPE_VEC	0x0000800
#define RTYPE_GP	0x0001000
#define RTYPE_CP0	0x0002000
#define RTYPE_PC	0x0004000
#define RTYPE_ACC	0x0008000
#define RTYPE_CCC	0x0010000
#define RTYPE_VI	0x0020000
#define RTYPE_VF	0x0040000
#define RTYPE_R5900_I	0x0080000
#define RTYPE_R5900_Q	0x0100000
#define RTYPE_R5900_R	0x0200000
#define RTYPE_R5900_ACC	0x0400000
#define RTYPE_MSA	0x0800000
#define RWARN		0x8000000

#define GENERIC_REGISTER_NUMBERS \
    {"$0",	RTYPE_NUM | 0},  \
    {"$1",	RTYPE_NUM | 1},  \
    {"$2",	RTYPE_NUM | 2},  \
    {"$3",	RTYPE_NUM | 3},  \
    {"$4",	RTYPE_NUM | 4},  \
    {"$5",	RTYPE_NUM | 5},  \
    {"$6",	RTYPE_NUM | 6},  \
    {"$7",	RTYPE_NUM | 7},  \
    {"$8",	RTYPE_NUM | 8},  \
    {"$9",	RTYPE_NUM | 9},  \
    {"$10",	RTYPE_NUM | 10}, \
    {"$11",	RTYPE_NUM | 11}, \
    {"$12",	RTYPE_NUM | 12}, \
    {"$13",	RTYPE_NUM | 13}, \
    {"$14",	RTYPE_NUM | 14}, \
    {"$15",	RTYPE_NUM | 15}, \
    {"$16",	RTYPE_NUM | 16}, \
    {"$17",	RTYPE_NUM | 17}, \
    {"$18",	RTYPE_NUM | 18}, \
    {"$19",	RTYPE_NUM | 19}, \
    {"$20",	RTYPE_NUM | 20}, \
    {"$21",	RTYPE_NUM | 21}, \
    {"$22",	RTYPE_NUM | 22}, \
    {"$23",	RTYPE_NUM | 23}, \
    {"$24",	RTYPE_NUM | 24}, \
    {"$25",	RTYPE_NUM | 25}, \
    {"$26",	RTYPE_NUM | 26}, \
    {"$27",	RTYPE_NUM | 27}, \
    {"$28",	RTYPE_NUM | 28}, \
    {"$29",	RTYPE_NUM | 29}, \
    {"$30",	RTYPE_NUM | 30}, \
    {"$31",	RTYPE_NUM | 31} 

#define FPU_REGISTER_NAMES       \
    {"$f0",	RTYPE_FPU | 0},  \
    {"$f1",	RTYPE_FPU | 1},  \
    {"$f2",	RTYPE_FPU | 2},  \
    {"$f3",	RTYPE_FPU | 3},  \
    {"$f4",	RTYPE_FPU | 4},  \
    {"$f5",	RTYPE_FPU | 5},  \
    {"$f6",	RTYPE_FPU | 6},  \
    {"$f7",	RTYPE_FPU | 7},  \
    {"$f8",	RTYPE_FPU | 8},  \
    {"$f9",	RTYPE_FPU | 9},  \
    {"$f10",	RTYPE_FPU | 10}, \
    {"$f11",	RTYPE_FPU | 11}, \
    {"$f12",	RTYPE_FPU | 12}, \
    {"$f13",	RTYPE_FPU | 13}, \
    {"$f14",	RTYPE_FPU | 14}, \
    {"$f15",	RTYPE_FPU | 15}, \
    {"$f16",	RTYPE_FPU | 16}, \
    {"$f17",	RTYPE_FPU | 17}, \
    {"$f18",	RTYPE_FPU | 18}, \
    {"$f19",	RTYPE_FPU | 19}, \
    {"$f20",	RTYPE_FPU | 20}, \
    {"$f21",	RTYPE_FPU | 21}, \
    {"$f22",	RTYPE_FPU | 22}, \
    {"$f23",	RTYPE_FPU | 23}, \
    {"$f24",	RTYPE_FPU | 24}, \
    {"$f25",	RTYPE_FPU | 25}, \
    {"$f26",	RTYPE_FPU | 26}, \
    {"$f27",	RTYPE_FPU | 27}, \
    {"$f28",	RTYPE_FPU | 28}, \
    {"$f29",	RTYPE_FPU | 29}, \
    {"$f30",	RTYPE_FPU | 30}, \
    {"$f31",	RTYPE_FPU | 31}

#define FPU_CONDITION_CODE_NAMES \
    {"$fcc0",	RTYPE_FCC | 0},  \
    {"$fcc1",	RTYPE_FCC | 1},  \
    {"$fcc2",	RTYPE_FCC | 2},  \
    {"$fcc3",	RTYPE_FCC | 3},  \
    {"$fcc4",	RTYPE_FCC | 4},  \
    {"$fcc5",	RTYPE_FCC | 5},  \
    {"$fcc6",	RTYPE_FCC | 6},  \
    {"$fcc7",	RTYPE_FCC | 7}

#define COPROC_CONDITION_CODE_NAMES         \
    {"$cc0",	RTYPE_FCC | RTYPE_CCC | 0}, \
    {"$cc1",	RTYPE_FCC | RTYPE_CCC | 1}, \
    {"$cc2",	RTYPE_FCC | RTYPE_CCC | 2}, \
    {"$cc3",	RTYPE_FCC | RTYPE_CCC | 3}, \
    {"$cc4",	RTYPE_FCC | RTYPE_CCC | 4}, \
    {"$cc5",	RTYPE_FCC | RTYPE_CCC | 5}, \
    {"$cc6",	RTYPE_FCC | RTYPE_CCC | 6}, \
    {"$cc7",	RTYPE_FCC | RTYPE_CCC | 7}

#define N32N64_SYMBOLIC_REGISTER_NAMES \
    {"$a4",	RTYPE_GP | 8},  \
    {"$a5",	RTYPE_GP | 9},  \
    {"$a6",	RTYPE_GP | 10}, \
    {"$a7",	RTYPE_GP | 11}, \
    {"$ta0",	RTYPE_GP | 8},  /* alias for $a4 */ \
    {"$ta1",	RTYPE_GP | 9},  /* alias for $a5 */ \
    {"$ta2",	RTYPE_GP | 10}, /* alias for $a6 */ \
    {"$ta3",	RTYPE_GP | 11}, /* alias for $a7 */ \
    {"$t0",	RTYPE_GP | 12}, \
    {"$t1",	RTYPE_GP | 13}, \
    {"$t2",	RTYPE_GP | 14}, \
    {"$t3",	RTYPE_GP | 15}

#define O32_SYMBOLIC_REGISTER_NAMES \
    {"$t0",	RTYPE_GP | 8},  \
    {"$t1",	RTYPE_GP | 9},  \
    {"$t2",	RTYPE_GP | 10}, \
    {"$t3",	RTYPE_GP | 11}, \
    {"$t4",	RTYPE_GP | 12}, \
    {"$t5",	RTYPE_GP | 13}, \
    {"$t6",	RTYPE_GP | 14}, \
    {"$t7",	RTYPE_GP | 15}, \
    {"$ta0",	RTYPE_GP | 12}, /* alias for $t4 */ \
    {"$ta1",	RTYPE_GP | 13}, /* alias for $t5 */ \
    {"$ta2",	RTYPE_GP | 14}, /* alias for $t6 */ \
    {"$ta3",	RTYPE_GP | 15}  /* alias for $t7 */ 

/* Remaining symbolic register names */
#define SYMBOLIC_REGISTER_NAMES \
    {"$zero",	RTYPE_GP | 0},  \
    {"$at",	RTYPE_GP | 1},  \
    {"$AT",	RTYPE_GP | 1},  \
    {"$v0",	RTYPE_GP | 2},  \
    {"$v1",	RTYPE_GP | 3},  \
    {"$a0",	RTYPE_GP | 4},  \
    {"$a1",	RTYPE_GP | 5},  \
    {"$a2",	RTYPE_GP | 6},  \
    {"$a3",	RTYPE_GP | 7},  \
    {"$s0",	RTYPE_GP | 16}, \
    {"$s1",	RTYPE_GP | 17}, \
    {"$s2",	RTYPE_GP | 18}, \
    {"$s3",	RTYPE_GP | 19}, \
    {"$s4",	RTYPE_GP | 20}, \
    {"$s5",	RTYPE_GP | 21}, \
    {"$s6",	RTYPE_GP | 22}, \
    {"$s7",	RTYPE_GP | 23}, \
    {"$t8",	RTYPE_GP | 24}, \
    {"$t9",	RTYPE_GP | 25}, \
    {"$k0",	RTYPE_GP | 26}, \
    {"$kt0",	RTYPE_GP | 26}, \
    {"$k1",	RTYPE_GP | 27}, \
    {"$kt1",	RTYPE_GP | 27}, \
    {"$gp",	RTYPE_GP | 28}, \
    {"$sp",	RTYPE_GP | 29}, \
    {"$s8",	RTYPE_GP | 30}, \
    {"$fp",	RTYPE_GP | 30}, \
    {"$ra",	RTYPE_GP | 31}

#define MIPS16_SPECIAL_REGISTER_NAMES \
    {"$pc",	RTYPE_PC | 0}

#define MDMX_VECTOR_REGISTER_NAMES \
    /* {"$v0",	RTYPE_VEC | 0},  clash with REG 2 above */ \
    /* {"$v1",	RTYPE_VEC | 1},  clash with REG 3 above */ \
    {"$v2",	RTYPE_VEC | 2},  \
    {"$v3",	RTYPE_VEC | 3},  \
    {"$v4",	RTYPE_VEC | 4},  \
    {"$v5",	RTYPE_VEC | 5},  \
    {"$v6",	RTYPE_VEC | 6},  \
    {"$v7",	RTYPE_VEC | 7},  \
    {"$v8",	RTYPE_VEC | 8},  \
    {"$v9",	RTYPE_VEC | 9},  \
    {"$v10",	RTYPE_VEC | 10}, \
    {"$v11",	RTYPE_VEC | 11}, \
    {"$v12",	RTYPE_VEC | 12}, \
    {"$v13",	RTYPE_VEC | 13}, \
    {"$v14",	RTYPE_VEC | 14}, \
    {"$v15",	RTYPE_VEC | 15}, \
    {"$v16",	RTYPE_VEC | 16}, \
    {"$v17",	RTYPE_VEC | 17}, \
    {"$v18",	RTYPE_VEC | 18}, \
    {"$v19",	RTYPE_VEC | 19}, \
    {"$v20",	RTYPE_VEC | 20}, \
    {"$v21",	RTYPE_VEC | 21}, \
    {"$v22",	RTYPE_VEC | 22}, \
    {"$v23",	RTYPE_VEC | 23}, \
    {"$v24",	RTYPE_VEC | 24}, \
    {"$v25",	RTYPE_VEC | 25}, \
    {"$v26",	RTYPE_VEC | 26}, \
    {"$v27",	RTYPE_VEC | 27}, \
    {"$v28",	RTYPE_VEC | 28}, \
    {"$v29",	RTYPE_VEC | 29}, \
    {"$v30",	RTYPE_VEC | 30}, \
    {"$v31",	RTYPE_VEC | 31}

#define R5900_I_NAMES \
    {"$I",	RTYPE_R5900_I | 0}

#define R5900_Q_NAMES \
    {"$Q",	RTYPE_R5900_Q | 0}

#define R5900_R_NAMES \
    {"$R",	RTYPE_R5900_R | 0}

#define R5900_ACC_NAMES \
    {"$ACC",	RTYPE_R5900_ACC | 0 }

#define MIPS_DSP_ACCUMULATOR_NAMES \
    {"$ac0",	RTYPE_ACC | 0}, \
    {"$ac1",	RTYPE_ACC | 1}, \
    {"$ac2",	RTYPE_ACC | 2}, \
    {"$ac3",	RTYPE_ACC | 3}

static const struct regname reg_names[] = {
  GENERIC_REGISTER_NUMBERS,
  FPU_REGISTER_NAMES,
  FPU_CONDITION_CODE_NAMES,
  COPROC_CONDITION_CODE_NAMES,

  /* The $txx registers depends on the abi,
     these will be added later into the symbol table from
     one of the tables below once mips_abi is set after 
     parsing of arguments from the command line. */
  SYMBOLIC_REGISTER_NAMES,

  MIPS16_SPECIAL_REGISTER_NAMES,
  MDMX_VECTOR_REGISTER_NAMES,
  R5900_I_NAMES,
  R5900_Q_NAMES,
  R5900_R_NAMES,
  R5900_ACC_NAMES,
  MIPS_DSP_ACCUMULATOR_NAMES,
  {0, 0}
};

static const struct regname reg_names_o32[] = {
  O32_SYMBOLIC_REGISTER_NAMES,
  {0, 0}
};

static const struct regname reg_names_n32n64[] = {
  N32N64_SYMBOLIC_REGISTER_NAMES,
  {0, 0}
};

/* Register symbols $v0 and $v1 map to GPRs 2 and 3, but they can also be
   interpreted as vector registers 0 and 1.  If SYMVAL is the value of one
   of these register symbols, return the associated vector register,
   otherwise return SYMVAL itself.  */

static unsigned int
mips_prefer_vec_regno (unsigned int symval)
{
  if ((symval & -2) == (RTYPE_GP | 2))
    return RTYPE_VEC | (symval & 1);
  return symval;
}

/* Return true if string [S, E) is a valid register name, storing its
   symbol value in *SYMVAL_PTR if so.  */

static bfd_boolean
mips_parse_register_1 (char *s, char *e, unsigned int *symval_ptr)
{
  char save_c;
  symbolS *symbol;

  /* Terminate name.  */
  save_c = *e;
  *e = '\0';

  /* Look up the name.  */
  symbol = symbol_find (s);
  *e = save_c;

  if (!symbol || S_GET_SEGMENT (symbol) != reg_section)
    return FALSE;

  *symval_ptr = S_GET_VALUE (symbol);
  return TRUE;
}

/* Return true if the string at *SPTR is a valid register name.  Allow it
   to have a VU0-style channel suffix of the form x?y?z?w? if CHANNELS_PTR
   is nonnull.

   When returning true, move *SPTR past the register, store the
   register's symbol value in *SYMVAL_PTR and the channel mask in
   *CHANNELS_PTR (if nonnull).  The symbol value includes the register
   number (RNUM_MASK) and register type (RTYPE_MASK).  The channel mask
   is a 4-bit value of the form XYZW and is 0 if no suffix was given.  */

static bfd_boolean
mips_parse_register (char **sptr, unsigned int *symval_ptr,
		     unsigned int *channels_ptr)
{
  char *s, *e, *m;
  const char *q;
  unsigned int channels, symval, bit;

  /* Find end of name.  */
  s = e = *sptr;
  if (is_name_beginner (*e))
    ++e;
  while (is_part_of_name (*e))
    ++e;

  channels = 0;
  if (!mips_parse_register_1 (s, e, &symval))
    {
      if (!channels_ptr)
	return FALSE;

      /* Eat characters from the end of the string that are valid
	 channel suffixes.  The preceding register must be $ACC or
	 end with a digit, so there is no ambiguity.  */
      bit = 1;
      m = e;
      for (q = "wzyx"; *q; q++, bit <<= 1)
	if (m > s && m[-1] == *q)
	  {
	    --m;
	    channels |= bit;
	  }

      if (channels == 0
	  || !mips_parse_register_1 (s, m, &symval)
	  || (symval & (RTYPE_VI | RTYPE_VF | RTYPE_R5900_ACC)) == 0)
	return FALSE;
    }

  *sptr = e;
  *symval_ptr = symval;
  if (channels_ptr)
    *channels_ptr = channels;
  return TRUE;
}

/* Check if SPTR points at a valid register specifier according to TYPES.
   If so, then return 1, advance S to consume the specifier and store
   the register's number in REGNOP, otherwise return 0.  */

static int
reg_lookup (char **s, unsigned int types, unsigned int *regnop)
{
  unsigned int regno;

  if (mips_parse_register (s, &regno, NULL))
    {
      if (types & RTYPE_VEC)
	regno = mips_prefer_vec_regno (regno);
      if (regno & types)
	regno &= RNUM_MASK;
      else
	regno = ~0;
    }
  else
    {
      if (types & RWARN)
	as_warn (_("unrecognized register name `%s'"), *s);
      regno = ~0;
    }
  if (regnop)
    *regnop = regno;
  return regno <= RNUM_MASK;
}

/* Parse a VU0 "x?y?z?w?" channel mask at S and store the associated
   mask in *CHANNELS.  Return a pointer to the first unconsumed character.  */

static char *
mips_parse_vu0_channels (char *s, unsigned int *channels)
{
  unsigned int i;

  *channels = 0;
  for (i = 0; i < 4; i++)
    if (*s == "xyzw"[i])
      {
	*channels |= 1 << (3 - i);
	++s;
      }
  return s;
}

/* Token types for parsed operand lists.  */
enum mips_operand_token_type {
  /* A plain register, e.g. $f2.  */
  OT_REG,

  /* A 4-bit XYZW channel mask.  */
  OT_CHANNELS,

  /* A constant vector index, e.g. [1].  */
  OT_INTEGER_INDEX,

  /* A register vector index, e.g. [$2].  */
  OT_REG_INDEX,

  /* A continuous range of registers, e.g. $s0-$s4.  */
  OT_REG_RANGE,

  /* A (possibly relocated) expression.  */
  OT_INTEGER,

  /* A floating-point value.  */
  OT_FLOAT,

  /* A single character.  This can be '(', ')' or ',', but '(' only appears
     before OT_REGs.  */
  OT_CHAR,

  /* A doubled character, either "--" or "++".  */
  OT_DOUBLE_CHAR,

  /* The end of the operand list.  */
  OT_END
};

/* A parsed operand token.  */
struct mips_operand_token
{
  /* The type of token.  */
  enum mips_operand_token_type type;
  union
  {
    /* The register symbol value for an OT_REG or OT_REG_INDEX.  */
    unsigned int regno;

    /* The 4-bit channel mask for an OT_CHANNEL_SUFFIX.  */
    unsigned int channels;

    /* The integer value of an OT_INTEGER_INDEX.  */
    addressT index;

    /* The two register symbol values involved in an OT_REG_RANGE.  */
    struct {
      unsigned int regno1;
      unsigned int regno2;
    } reg_range;

    /* The value of an OT_INTEGER.  The value is represented as an
       expression and the relocation operators that were applied to
       that expression.  The reloc entries are BFD_RELOC_UNUSED if no
       relocation operators were used.  */
    struct {
      expressionS value;
      bfd_reloc_code_real_type relocs[3];
    } integer;

    /* The binary data for an OT_FLOAT constant, and the number of bytes
       in the constant.  */
    struct {
      unsigned char data[8];
      int length;
    } flt;

    /* The character represented by an OT_CHAR or OT_DOUBLE_CHAR.  */
    char ch;
  } u;
};

/* An obstack used to construct lists of mips_operand_tokens.  */
static struct obstack mips_operand_tokens;

/* Give TOKEN type TYPE and add it to mips_operand_tokens.  */

static void
mips_add_token (struct mips_operand_token *token,
		enum mips_operand_token_type type)
{
  token->type = type;
  obstack_grow (&mips_operand_tokens, token, sizeof (*token));
}

/* Check whether S is '(' followed by a register name.  Add OT_CHAR
   and OT_REG tokens for them if so, and return a pointer to the first
   unconsumed character.  Return null otherwise.  */

static char *
mips_parse_base_start (char *s)
{
  struct mips_operand_token token;
  unsigned int regno, channels;
  bfd_boolean decrement_p;

  if (*s != '(')
    return 0;

  ++s;
  SKIP_SPACE_TABS (s);

  /* Only match "--" as part of a base expression.  In other contexts "--X"
     is a double negative.  */
  decrement_p = (s[0] == '-' && s[1] == '-');
  if (decrement_p)
    {
      s += 2;
      SKIP_SPACE_TABS (s);
    }

  /* Allow a channel specifier because that leads to better error messages
     than treating something like "$vf0x++" as an expression.  */
  if (!mips_parse_register (&s, &regno, &channels))
    return 0;

  token.u.ch = '(';
  mips_add_token (&token, OT_CHAR);

  if (decrement_p)
    {
      token.u.ch = '-';
      mips_add_token (&token, OT_DOUBLE_CHAR);
    }

  token.u.regno = regno;
  mips_add_token (&token, OT_REG);

  if (channels)
    {
      token.u.channels = channels;
      mips_add_token (&token, OT_CHANNELS);
    }

  /* For consistency, only match "++" as part of base expressions too.  */
  SKIP_SPACE_TABS (s);
  if (s[0] == '+' && s[1] == '+')
    {
      s += 2;
      token.u.ch = '+';
      mips_add_token (&token, OT_DOUBLE_CHAR);
    }

  return s;
}

/* Parse one or more tokens from S.  Return a pointer to the first
   unconsumed character on success.  Return null if an error was found
   and store the error text in insn_error.  FLOAT_FORMAT is as for
   mips_parse_arguments.  */

static char *
mips_parse_argument_token (char *s, char float_format)
{
  char *end, *save_in, *err;
  unsigned int regno1, regno2, channels;
  struct mips_operand_token token;

  /* First look for "($reg", since we want to treat that as an
     OT_CHAR and OT_REG rather than an expression.  */
  end = mips_parse_base_start (s);
  if (end)
    return end;

  /* Handle other characters that end up as OT_CHARs.  */
  if (*s == ')' || *s == ',')
    {
      token.u.ch = *s;
      mips_add_token (&token, OT_CHAR);
      ++s;
      return s;
    }

  /* Handle tokens that start with a register.  */
  if (mips_parse_register (&s, &regno1, &channels))
    {
      if (channels)
	{
	  /* A register and a VU0 channel suffix.  */
	  token.u.regno = regno1;
	  mips_add_token (&token, OT_REG);

	  token.u.channels = channels;
	  mips_add_token (&token, OT_CHANNELS);
	  return s;
	}

      SKIP_SPACE_TABS (s);
      if (*s == '-')
	{
	  /* A register range.  */
	  ++s;
	  SKIP_SPACE_TABS (s);
	  if (!mips_parse_register (&s, &regno2, NULL))
	    {
	      set_insn_error (0, _("invalid register range"));
	      return 0;
	    }

	  token.u.reg_range.regno1 = regno1;
	  token.u.reg_range.regno2 = regno2;
	  mips_add_token (&token, OT_REG_RANGE);
	  return s;
	}

      /* Add the register itself.  */
      token.u.regno = regno1;
      mips_add_token (&token, OT_REG);

      /* Check for a vector index.  */
      if (*s == '[')
	{
	  ++s;
	  SKIP_SPACE_TABS (s);
	  if (mips_parse_register (&s, &token.u.regno, NULL))
	    mips_add_token (&token, OT_REG_INDEX);
	  else
	    {
	      expressionS element;

	      my_getExpression (&element, s);
	      if (element.X_op != O_constant)
		{
		  set_insn_error (0, _("vector element must be constant"));
		  return 0;
		}
	      s = expr_end;
	      token.u.index = element.X_add_number;
	      mips_add_token (&token, OT_INTEGER_INDEX);
	    }
	  SKIP_SPACE_TABS (s);
	  if (*s != ']')
	    {
	      set_insn_error (0, _("missing `]'"));
	      return 0;
	    }
	  ++s;
	}
      return s;
    }

  if (float_format)
    {
      /* First try to treat expressions as floats.  */
      save_in = input_line_pointer;
      input_line_pointer = s;
      err = md_atof (float_format, (char *) token.u.flt.data,
		     &token.u.flt.length);
      end = input_line_pointer;
      input_line_pointer = save_in;
      if (err && *err)
	{
	  set_insn_error (0, err);
	  return 0;
	}
      if (s != end)
	{
	  mips_add_token (&token, OT_FLOAT);
	  return end;
	}
    }

  /* Treat everything else as an integer expression.  */
  token.u.integer.relocs[0] = BFD_RELOC_UNUSED;
  token.u.integer.relocs[1] = BFD_RELOC_UNUSED;
  token.u.integer.relocs[2] = BFD_RELOC_UNUSED;
  my_getSmallExpression (&token.u.integer.value, token.u.integer.relocs, s);
  s = expr_end;
  mips_add_token (&token, OT_INTEGER);
  return s;
}

/* S points to the operand list for an instruction.  FLOAT_FORMAT is 'f'
   if expressions should be treated as 32-bit floating-point constants,
   'd' if they should be treated as 64-bit floating-point constants,
   or 0 if they should be treated as integer expressions (the usual case).

   Return a list of tokens on success, otherwise return 0.  The caller
   must obstack_free the list after use.  */

static struct mips_operand_token *
mips_parse_arguments (char *s, char float_format)
{
  struct mips_operand_token token;

  SKIP_SPACE_TABS (s);
  while (*s)
    {
      s = mips_parse_argument_token (s, float_format);
      if (!s)
	{
	  obstack_free (&mips_operand_tokens,
			obstack_finish (&mips_operand_tokens));
	  return 0;
	}
      SKIP_SPACE_TABS (s);
    }
  mips_add_token (&token, OT_END);
  return (struct mips_operand_token *) obstack_finish (&mips_operand_tokens);
}

/* Return TRUE if opcode MO is valid on the currently selected ISA, ASE
   and architecture.  Use is_opcode_valid_16 for MIPS16 opcodes.  */

static bfd_boolean
is_opcode_valid (const struct mips_opcode *mo)
{
  int isa = mips_opts.isa;
  int ase = mips_opts.ase;
  int fp_s, fp_d;
  unsigned int i;

  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
    for (i = 0; i < ARRAY_SIZE (mips_ases); i++)
      if ((ase & mips_ases[i].flags) == mips_ases[i].flags)
	ase |= mips_ases[i].flags64;

  if (!opcode_is_member (mo, isa, ase, mips_opts.arch))
    return FALSE;

  /* Check whether the instruction or macro requires single-precision or
     double-precision floating-point support.  Note that this information is
     stored differently in the opcode table for insns and macros.  */
  if (mo->pinfo == INSN_MACRO)
    {
      fp_s = mo->pinfo2 & INSN2_M_FP_S;
      fp_d = mo->pinfo2 & INSN2_M_FP_D;
    }
  else
    {
      fp_s = mo->pinfo & FP_S;
      fp_d = mo->pinfo & FP_D;
    }

  if (fp_d && (mips_opts.soft_float || mips_opts.single_float))
    return FALSE;

  if (fp_s && mips_opts.soft_float)
    return FALSE;

  return TRUE;
}

/* Return TRUE if the MIPS16 opcode MO is valid on the currently
   selected ISA and architecture.  */

static bfd_boolean
is_opcode_valid_16 (const struct mips_opcode *mo)
{
  return opcode_is_member (mo, mips_opts.isa, 0, mips_opts.arch);
}

/* Return TRUE if the size of the microMIPS opcode MO matches one
   explicitly requested.  Always TRUE in the standard MIPS mode.  */

static bfd_boolean
is_size_valid (const struct mips_opcode *mo)
{
  if (!mips_opts.micromips)
    return TRUE;

  if (mips_opts.insn32)
    {
      if (mo->pinfo != INSN_MACRO && micromips_insn_length (mo) != 4)
	return FALSE;
      if ((mo->pinfo2 & INSN2_BRANCH_DELAY_16BIT) != 0)
	return FALSE;
    }
  if (!forced_insn_length)
    return TRUE;
  if (mo->pinfo == INSN_MACRO)
    return FALSE;
  return forced_insn_length == micromips_insn_length (mo);
}

/* Return TRUE if the microMIPS opcode MO is valid for the delay slot
   of the preceding instruction.  Always TRUE in the standard MIPS mode.

   We don't accept macros in 16-bit delay slots to avoid a case where
   a macro expansion fails because it relies on a preceding 32-bit real
   instruction to have matched and does not handle the operands correctly.
   The only macros that may expand to 16-bit instructions are JAL that
   cannot be placed in a delay slot anyway, and corner cases of BALIGN
   and BGT (that likewise cannot be placed in a delay slot) that decay to
   a NOP.  In all these cases the macros precede any corresponding real
   instruction definitions in the opcode table, so they will match in the
   second pass where the size of the delay slot is ignored and therefore
   produce correct code.  */

static bfd_boolean
is_delay_slot_valid (const struct mips_opcode *mo)
{
  if (!mips_opts.micromips)
    return TRUE;

  if (mo->pinfo == INSN_MACRO)
    return (history[0].insn_mo->pinfo2 & INSN2_BRANCH_DELAY_16BIT) == 0;
  if ((history[0].insn_mo->pinfo2 & INSN2_BRANCH_DELAY_32BIT) != 0
      && micromips_insn_length (mo) != 4)
    return FALSE;
  if ((history[0].insn_mo->pinfo2 & INSN2_BRANCH_DELAY_16BIT) != 0
      && micromips_insn_length (mo) != 2)
    return FALSE;

  return TRUE;
}

/* For consistency checking, verify that all bits of OPCODE are specified
   either by the match/mask part of the instruction definition, or by the
   operand list.  Also build up a list of operands in OPERANDS.

   INSN_BITS says which bits of the instruction are significant.
   If OPCODE is a standard or microMIPS instruction, DECODE_OPERAND
   provides the mips_operand description of each operand.  DECODE_OPERAND
   is null for MIPS16 instructions.  */

static int
validate_mips_insn (const struct mips_opcode *opcode,
		    unsigned long insn_bits,
		    const struct mips_operand *(*decode_operand) (const char *),
		    struct mips_operand_array *operands)
{
  const char *s;
  unsigned long used_bits, doubled, undefined, opno, mask;
  const struct mips_operand *operand;

  mask = (opcode->pinfo == INSN_MACRO ? 0 : opcode->mask);
  if ((mask & opcode->match) != opcode->match)
    {
      as_bad (_("internal: bad mips opcode (mask error): %s %s"),
	      opcode->name, opcode->args);
      return 0;
    }
  used_bits = 0;
  opno = 0;
  if (opcode->pinfo2 & INSN2_VU0_CHANNEL_SUFFIX)
    used_bits = mips_insert_operand (&mips_vu0_channel_mask, used_bits, -1);
  for (s = opcode->args; *s; ++s)
    switch (*s)
      {
      case ',':
      case '(':
      case ')':
	break;

      case '#':
	s++;
	break;

      default:
	if (!decode_operand)
	  operand = decode_mips16_operand (*s, FALSE);
	else
	  operand = decode_operand (s);
	if (!operand && opcode->pinfo != INSN_MACRO)
	  {
	    as_bad (_("internal: unknown operand type: %s %s"),
		    opcode->name, opcode->args);
	    return 0;
	  }
	gas_assert (opno < MAX_OPERANDS);
	operands->operand[opno] = operand;
	if (operand && operand->type != OP_VU0_MATCH_SUFFIX)
	  {
	    used_bits = mips_insert_operand (operand, used_bits, -1);
	    if (operand->type == OP_MDMX_IMM_REG)
	      /* Bit 5 is the format selector (OB vs QH).  The opcode table
		 has separate entries for each format.  */
	      used_bits &= ~(1 << (operand->lsb + 5));
	    if (operand->type == OP_ENTRY_EXIT_LIST)
	      used_bits &= ~(mask & 0x700);
	  }
	/* Skip prefix characters.  */
	if (decode_operand && (*s == '+' || *s == 'm'))
	  ++s;
	opno += 1;
	break;
      }
  doubled = used_bits & mask & insn_bits;
  if (doubled)
    {
      as_bad (_("internal: bad mips opcode (bits 0x%08lx doubly defined):"
		" %s %s"), doubled, opcode->name, opcode->args);
      return 0;
    }
  used_bits |= mask;
  undefined = ~used_bits & insn_bits;
  if (opcode->pinfo != INSN_MACRO && undefined)
    {
      as_bad (_("internal: bad mips opcode (bits 0x%08lx undefined): %s %s"),
	      undefined, opcode->name, opcode->args);
      return 0;
    }
  used_bits &= ~insn_bits;
  if (used_bits)
    {
      as_bad (_("internal: bad mips opcode (bits 0x%08lx defined): %s %s"),
	      used_bits, opcode->name, opcode->args);
      return 0;
    }
  return 1;
}

/* The MIPS16 version of validate_mips_insn.  */

static int
validate_mips16_insn (const struct mips_opcode *opcode,
		      struct mips_operand_array *operands)
{
  if (opcode->args[0] == 'a' || opcode->args[0] == 'i')
    {
      /* In this case OPCODE defines the first 16 bits in a 32-bit jump
	 instruction.  Use TMP to describe the full instruction.  */
      struct mips_opcode tmp;

      tmp = *opcode;
      tmp.match <<= 16;
      tmp.mask <<= 16;
      return validate_mips_insn (&tmp, 0xffffffff, 0, operands);
    }
  return validate_mips_insn (opcode, 0xffff, 0, operands);
}

/* The microMIPS version of validate_mips_insn.  */

static int
validate_micromips_insn (const struct mips_opcode *opc,
			 struct mips_operand_array *operands)
{
  unsigned long insn_bits;
  unsigned long major;
  unsigned int length;

  if (opc->pinfo == INSN_MACRO)
    return validate_mips_insn (opc, 0xffffffff, decode_micromips_operand,
			       operands);

  length = micromips_insn_length (opc);
  if (length != 2 && length != 4)
    {
      as_bad (_("internal error: bad microMIPS opcode (incorrect length: %u): "
		"%s %s"), length, opc->name, opc->args);
      return 0;
    }
  major = opc->match >> (10 + 8 * (length - 2));
  if ((length == 2 && (major & 7) != 1 && (major & 6) != 2)
      || (length == 4 && (major & 7) != 0 && (major & 4) != 4))
    {
      as_bad (_("internal error: bad microMIPS opcode "
		"(opcode/length mismatch): %s %s"), opc->name, opc->args);
      return 0;
    }

  /* Shift piecewise to avoid an overflow where unsigned long is 32-bit.  */
  insn_bits = 1 << 4 * length;
  insn_bits <<= 4 * length;
  insn_bits -= 1;
  return validate_mips_insn (opc, insn_bits, decode_micromips_operand,
			     operands);
}

/* This function is called once, at assembler startup time.  It should set up
   all the tables, etc. that the MD part of the assembler will need.  */

void
md_begin (void)
{
  const char *retval = NULL;
  int i = 0;
  int broken = 0;

  if (mips_pic != NO_PIC)
    {
      if (g_switch_seen && g_switch_value != 0)
	as_bad (_("-G may not be used in position-independent code"));
      g_switch_value = 0;
    }

  if (! bfd_set_arch_mach (stdoutput, bfd_arch_mips, file_mips_arch))
    as_warn (_("could not set architecture and machine"));

  op_hash = hash_new ();

  mips_operands = XCNEWVEC (struct mips_operand_array, NUMOPCODES);
  for (i = 0; i < NUMOPCODES;)
    {
      const char *name = mips_opcodes[i].name;

      retval = hash_insert (op_hash, name, (void *) &mips_opcodes[i]);
      if (retval != NULL)
	{
	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
		   mips_opcodes[i].name, retval);
	  /* Probably a memory allocation problem?  Give up now.  */
	  as_fatal (_("broken assembler, no assembly attempted"));
	}
      do
	{
	  if (!validate_mips_insn (&mips_opcodes[i], 0xffffffff,
				   decode_mips_operand, &mips_operands[i]))
	    broken = 1;
	  if (nop_insn.insn_mo == NULL && strcmp (name, "nop") == 0)
	    {
	      create_insn (&nop_insn, mips_opcodes + i);
	      if (mips_fix_loongson2f_nop)
		nop_insn.insn_opcode = LOONGSON2F_NOP_INSN;
	      nop_insn.fixed_p = 1;
	    }
	  ++i;
	}
      while ((i < NUMOPCODES) && !strcmp (mips_opcodes[i].name, name));
    }

  mips16_op_hash = hash_new ();
  mips16_operands = XCNEWVEC (struct mips_operand_array,
			      bfd_mips16_num_opcodes);

  i = 0;
  while (i < bfd_mips16_num_opcodes)
    {
      const char *name = mips16_opcodes[i].name;

      retval = hash_insert (mips16_op_hash, name, (void *) &mips16_opcodes[i]);
      if (retval != NULL)
	as_fatal (_("internal: can't hash `%s': %s"),
		  mips16_opcodes[i].name, retval);
      do
	{
	  if (!validate_mips16_insn (&mips16_opcodes[i], &mips16_operands[i]))
	    broken = 1;
	  if (mips16_nop_insn.insn_mo == NULL && strcmp (name, "nop") == 0)
	    {
	      create_insn (&mips16_nop_insn, mips16_opcodes + i);
	      mips16_nop_insn.fixed_p = 1;
	    }
	  ++i;
	}
      while (i < bfd_mips16_num_opcodes
	     && strcmp (mips16_opcodes[i].name, name) == 0);
    }

  micromips_op_hash = hash_new ();
  micromips_operands = XCNEWVEC (struct mips_operand_array,
				 bfd_micromips_num_opcodes);

  i = 0;
  while (i < bfd_micromips_num_opcodes)
    {
      const char *name = micromips_opcodes[i].name;

      retval = hash_insert (micromips_op_hash, name,
			    (void *) &micromips_opcodes[i]);
      if (retval != NULL)
	as_fatal (_("internal: can't hash `%s': %s"),
		  micromips_opcodes[i].name, retval);
      do
	{
	  struct mips_cl_insn *micromips_nop_insn;

	  if (!validate_micromips_insn (&micromips_opcodes[i],
					&micromips_operands[i]))
	    broken = 1;

	  if (micromips_opcodes[i].pinfo != INSN_MACRO)
	    {
	      if (micromips_insn_length (micromips_opcodes + i) == 2)
		micromips_nop_insn = &micromips_nop16_insn;
	      else if (micromips_insn_length (micromips_opcodes + i) == 4)
		micromips_nop_insn = &micromips_nop32_insn;
	      else
		continue;

	      if (micromips_nop_insn->insn_mo == NULL
		  && strcmp (name, "nop") == 0)
		{
		  create_insn (micromips_nop_insn, micromips_opcodes + i);
		  micromips_nop_insn->fixed_p = 1;
		}
	    }
	}
      while (++i < bfd_micromips_num_opcodes
	     && strcmp (micromips_opcodes[i].name, name) == 0);
    }

  if (broken)
    as_fatal (_("broken assembler, no assembly attempted"));

  /* We add all the general register names to the symbol table.  This
     helps us detect invalid uses of them.  */
  for (i = 0; reg_names[i].name; i++) 
    symbol_table_insert (symbol_new (reg_names[i].name, reg_section,
				     reg_names[i].num, /* & RNUM_MASK, */
				     &zero_address_frag));
  if (HAVE_NEWABI)
    for (i = 0; reg_names_n32n64[i].name; i++) 
      symbol_table_insert (symbol_new (reg_names_n32n64[i].name, reg_section,
				       reg_names_n32n64[i].num, /* & RNUM_MASK, */
				       &zero_address_frag));
  else
    for (i = 0; reg_names_o32[i].name; i++) 
      symbol_table_insert (symbol_new (reg_names_o32[i].name, reg_section,
				       reg_names_o32[i].num, /* & RNUM_MASK, */
				       &zero_address_frag));

  for (i = 0; i < 32; i++)
    {
      char regname[7];

      /* R5900 VU0 floating-point register.  */
      regname[sizeof (rename) - 1] = 0;
      snprintf (regname, sizeof (regname) - 1, "$vf%d", i);
      symbol_table_insert (symbol_new (regname, reg_section,
				       RTYPE_VF | i, &zero_address_frag));

      /* R5900 VU0 integer register.  */
      snprintf (regname, sizeof (regname) - 1, "$vi%d", i);
      symbol_table_insert (symbol_new (regname, reg_section,
				       RTYPE_VI | i, &zero_address_frag));

      /* MSA register.  */
      snprintf (regname, sizeof (regname) - 1, "$w%d", i);
      symbol_table_insert (symbol_new (regname, reg_section,
				       RTYPE_MSA | i, &zero_address_frag));
    }

  obstack_init (&mips_operand_tokens);

  mips_no_prev_insn ();

  mips_gprmask = 0;
  mips_cprmask[0] = 0;
  mips_cprmask[1] = 0;
  mips_cprmask[2] = 0;
  mips_cprmask[3] = 0;

  /* set the default alignment for the text section (2**2) */
  record_alignment (text_section, 2);

  bfd_set_gp_size (stdoutput, g_switch_value);

  /* On a native system other than VxWorks, sections must be aligned
     to 16 byte boundaries.  When configured for an embedded ELF
     target, we don't bother.  */
  if (strncmp (TARGET_OS, "elf", 3) != 0
      && strncmp (TARGET_OS, "vxworks", 7) != 0)
    {
      (void) bfd_set_section_alignment (stdoutput, text_section, 4);
      (void) bfd_set_section_alignment (stdoutput, data_section, 4);
      (void) bfd_set_section_alignment (stdoutput, bss_section, 4);
    }

  /* Create a .reginfo section for register masks and a .mdebug
     section for debugging information.  */
  {
    segT seg;
    subsegT subseg;
    flagword flags;
    segT sec;

    seg = now_seg;
    subseg = now_subseg;

    /* The ABI says this section should be loaded so that the
       running program can access it.  However, we don't load it
       if we are configured for an embedded target */
    flags = SEC_READONLY | SEC_DATA;
    if (strncmp (TARGET_OS, "elf", 3) != 0)
      flags |= SEC_ALLOC | SEC_LOAD;

    if (mips_abi != N64_ABI)
      {
	sec = subseg_new (".reginfo", (subsegT) 0);

	bfd_set_section_flags (stdoutput, sec, flags);
	bfd_set_section_alignment (stdoutput, sec, HAVE_NEWABI ? 3 : 2);

	mips_regmask_frag = frag_more (sizeof (Elf32_External_RegInfo));
      }
    else
      {
	/* The 64-bit ABI uses a .MIPS.options section rather than
	   .reginfo section.  */
	sec = subseg_new (".MIPS.options", (subsegT) 0);
	bfd_set_section_flags (stdoutput, sec, flags);
	bfd_set_section_alignment (stdoutput, sec, 3);

	/* Set up the option header.  */
	{
	  Elf_Internal_Options opthdr;
	  char *f;

	  opthdr.kind = ODK_REGINFO;
	  opthdr.size = (sizeof (Elf_External_Options)
			 + sizeof (Elf64_External_RegInfo));
	  opthdr.section = 0;
	  opthdr.info = 0;
	  f = frag_more (sizeof (Elf_External_Options));
	  bfd_mips_elf_swap_options_out (stdoutput, &opthdr,
					 (Elf_External_Options *) f);

	  mips_regmask_frag = frag_more (sizeof (Elf64_External_RegInfo));
	}
      }

    if (ECOFF_DEBUGGING)
      {
	sec = subseg_new (".mdebug", (subsegT) 0);
	(void) bfd_set_section_flags (stdoutput, sec,
				      SEC_HAS_CONTENTS | SEC_READONLY);
	(void) bfd_set_section_alignment (stdoutput, sec, 2);
      }
    else if (mips_flag_pdr)
      {
	pdr_seg = subseg_new (".pdr", (subsegT) 0);
	(void) bfd_set_section_flags (stdoutput, pdr_seg,
				      SEC_READONLY | SEC_RELOC
				      | SEC_DEBUGGING);
	(void) bfd_set_section_alignment (stdoutput, pdr_seg, 2);
      }

    subseg_set (seg, subseg);
  }

  if (! ECOFF_DEBUGGING)
    md_obj_begin ();

  if (mips_fix_vr4120)
    init_vr4120_conflicts ();
}

void
md_mips_end (void)
{
  mips_emit_delays ();
  if (! ECOFF_DEBUGGING)
    md_obj_end ();
}

void
md_assemble (char *str)
{
  struct mips_cl_insn insn;
  bfd_reloc_code_real_type unused_reloc[3]
    = {BFD_RELOC_UNUSED, BFD_RELOC_UNUSED, BFD_RELOC_UNUSED};

  imm_expr.X_op = O_absent;
  offset_expr.X_op = O_absent;
  offset_reloc[0] = BFD_RELOC_UNUSED;
  offset_reloc[1] = BFD_RELOC_UNUSED;
  offset_reloc[2] = BFD_RELOC_UNUSED;

  mips_mark_labels ();
  mips_assembling_insn = TRUE;
  clear_insn_error ();

  if (mips_opts.mips16)
    mips16_ip (str, &insn);
  else
    {
      mips_ip (str, &insn);
      DBG ((_("returned from mips_ip(%s) insn_opcode = 0x%x\n"),
	    str, insn.insn_opcode));
    }

  if (insn_error.msg)
    report_insn_error (str);
  else if (insn.insn_mo->pinfo == INSN_MACRO)
    {
      macro_start ();
      if (mips_opts.mips16)
	mips16_macro (&insn);
      else
	macro (&insn, str);
      macro_end ();
    }
  else
    {
      if (offset_expr.X_op != O_absent)
	append_insn (&insn, &offset_expr, offset_reloc, FALSE);
      else
	append_insn (&insn, NULL, unused_reloc, FALSE);
    }

  mips_assembling_insn = FALSE;
}

/* Convenience functions for abstracting away the differences between
   MIPS16 and non-MIPS16 relocations.  */

static inline bfd_boolean
mips16_reloc_p (bfd_reloc_code_real_type reloc)
{
  switch (reloc)
    {
    case BFD_RELOC_MIPS16_JMP:
    case BFD_RELOC_MIPS16_GPREL:
    case BFD_RELOC_MIPS16_GOT16:
    case BFD_RELOC_MIPS16_CALL16:
    case BFD_RELOC_MIPS16_HI16_S:
    case BFD_RELOC_MIPS16_HI16:
    case BFD_RELOC_MIPS16_LO16:
      return TRUE;

    default:
      return FALSE;
    }
}

static inline bfd_boolean
micromips_reloc_p (bfd_reloc_code_real_type reloc)
{
  switch (reloc)
    {
    case BFD_RELOC_MICROMIPS_7_PCREL_S1:
    case BFD_RELOC_MICROMIPS_10_PCREL_S1:
    case BFD_RELOC_MICROMIPS_16_PCREL_S1:
    case BFD_RELOC_MICROMIPS_GPREL16:
    case BFD_RELOC_MICROMIPS_JMP:
    case BFD_RELOC_MICROMIPS_HI16:
    case BFD_RELOC_MICROMIPS_HI16_S:
    case BFD_RELOC_MICROMIPS_LO16:
    case BFD_RELOC_MICROMIPS_LITERAL:
    case BFD_RELOC_MICROMIPS_GOT16:
    case BFD_RELOC_MICROMIPS_CALL16:
    case BFD_RELOC_MICROMIPS_GOT_HI16:
    case BFD_RELOC_MICROMIPS_GOT_LO16:
    case BFD_RELOC_MICROMIPS_CALL_HI16:
    case BFD_RELOC_MICROMIPS_CALL_LO16:
    case BFD_RELOC_MICROMIPS_SUB:
    case BFD_RELOC_MICROMIPS_GOT_PAGE:
    case BFD_RELOC_MICROMIPS_GOT_OFST:
    case BFD_RELOC_MICROMIPS_GOT_DISP:
    case BFD_RELOC_MICROMIPS_HIGHEST:
    case BFD_RELOC_MICROMIPS_HIGHER:
    case BFD_RELOC_MICROMIPS_SCN_DISP:
    case BFD_RELOC_MICROMIPS_JALR:
      return TRUE;

    default:
      return FALSE;
    }
}

static inline bfd_boolean
jmp_reloc_p (bfd_reloc_code_real_type reloc)
{
  return reloc == BFD_RELOC_MIPS_JMP || reloc == BFD_RELOC_MICROMIPS_JMP;
}

static inline bfd_boolean
got16_reloc_p (bfd_reloc_code_real_type reloc)
{
  return (reloc == BFD_RELOC_MIPS_GOT16 || reloc == BFD_RELOC_MIPS16_GOT16
	  || reloc == BFD_RELOC_MICROMIPS_GOT16);
}

static inline bfd_boolean
hi16_reloc_p (bfd_reloc_code_real_type reloc)
{
  return (reloc == BFD_RELOC_HI16_S || reloc == BFD_RELOC_MIPS16_HI16_S
	  || reloc == BFD_RELOC_MICROMIPS_HI16_S);
}

static inline bfd_boolean
lo16_reloc_p (bfd_reloc_code_real_type reloc)
{
  return (reloc == BFD_RELOC_LO16 || reloc == BFD_RELOC_MIPS16_LO16
	  || reloc == BFD_RELOC_MICROMIPS_LO16);
}

static inline bfd_boolean
jalr_reloc_p (bfd_reloc_code_real_type reloc)
{
  return reloc == BFD_RELOC_MIPS_JALR || reloc == BFD_RELOC_MICROMIPS_JALR;
}

static inline bfd_boolean
gprel16_reloc_p (bfd_reloc_code_real_type reloc)
{
  return (reloc == BFD_RELOC_GPREL16 || reloc == BFD_RELOC_MIPS16_GPREL
	  || reloc == BFD_RELOC_MICROMIPS_GPREL16);
}

/* Return true if RELOC is a PC-relative relocation that does not have
   full address range.  */

static inline bfd_boolean
limited_pcrel_reloc_p (bfd_reloc_code_real_type reloc)
{
  switch (reloc)
    {
    case BFD_RELOC_16_PCREL_S2:
    case BFD_RELOC_MICROMIPS_7_PCREL_S1:
    case BFD_RELOC_MICROMIPS_10_PCREL_S1:
    case BFD_RELOC_MICROMIPS_16_PCREL_S1:
      return TRUE;

    case BFD_RELOC_32_PCREL:
      return HAVE_64BIT_ADDRESSES;

    default:
      return FALSE;
    }
}

/* Return true if the given relocation might need a matching %lo().
   This is only "might" because SVR4 R_MIPS_GOT16 relocations only
   need a matching %lo() when applied to local symbols.  */

static inline bfd_boolean
reloc_needs_lo_p (bfd_reloc_code_real_type reloc)
{
  return (HAVE_IN_PLACE_ADDENDS
	  && (hi16_reloc_p (reloc)
	      /* VxWorks R_MIPS_GOT16 relocs never need a matching %lo();
		 all GOT16 relocations evaluate to "G".  */
	      || (got16_reloc_p (reloc) && mips_pic != VXWORKS_PIC)));
}

/* Return the type of %lo() reloc needed by RELOC, given that
   reloc_needs_lo_p.  */

static inline bfd_reloc_code_real_type
matching_lo_reloc (bfd_reloc_code_real_type reloc)
{
  return (mips16_reloc_p (reloc) ? BFD_RELOC_MIPS16_LO16
	  : (micromips_reloc_p (reloc) ? BFD_RELOC_MICROMIPS_LO16
	     : BFD_RELOC_LO16));
}

/* Return true if the given fixup is followed by a matching R_MIPS_LO16
   relocation.  */

static inline bfd_boolean
fixup_has_matching_lo_p (fixS *fixp)
{
  return (fixp->fx_next != NULL
	  && fixp->fx_next->fx_r_type == matching_lo_reloc (fixp->fx_r_type)
	  && fixp->fx_addsy == fixp->fx_next->fx_addsy
	  && fixp->fx_offset == fixp->fx_next->fx_offset);
}

/* Move all labels in LABELS to the current insertion point.  TEXT_P
   says whether the labels refer to text or data.  */

static void
mips_move_labels (struct insn_label_list *labels, bfd_boolean text_p)
{
  struct insn_label_list *l;
  valueT val;

  for (l = labels; l != NULL; l = l->next)
    {
      gas_assert (S_GET_SEGMENT (l->label) == now_seg);
      symbol_set_frag (l->label, frag_now);
      val = (valueT) frag_now_fix ();
      /* MIPS16/microMIPS text labels are stored as odd.  */
      if (text_p && HAVE_CODE_COMPRESSION)
	++val;
      S_SET_VALUE (l->label, val);
    }
}

/* Move all labels in insn_labels to the current insertion point
   and treat them as text labels.  */

static void
mips_move_text_labels (void)
{
  mips_move_labels (seg_info (now_seg)->label_list, TRUE);
}

static bfd_boolean
s_is_linkonce (symbolS *sym, segT from_seg)
{
  bfd_boolean linkonce = FALSE;
  segT symseg = S_GET_SEGMENT (sym);

  if (symseg != from_seg && !S_IS_LOCAL (sym))
    {
      if ((bfd_get_section_flags (stdoutput, symseg) & SEC_LINK_ONCE))
	linkonce = TRUE;
      /* The GNU toolchain uses an extension for ELF: a section
	 beginning with the magic string .gnu.linkonce is a
	 linkonce section.  */
      if (strncmp (segment_name (symseg), ".gnu.linkonce",
		   sizeof ".gnu.linkonce" - 1) == 0)
	linkonce = TRUE;
    }
  return linkonce;
}

/* Mark MIPS16 or microMIPS instruction label LABEL.  This permits the
   linker to handle them specially, such as generating jalx instructions
   when needed.  We also make them odd for the duration of the assembly,
   in order to generate the right sort of code.  We will make them even
   in the adjust_symtab routine, while leaving them marked.  This is
   convenient for the debugger and the disassembler.  The linker knows
   to make them odd again.  */

static void
mips_compressed_mark_label (symbolS *label)
{
  gas_assert (HAVE_CODE_COMPRESSION);

  if (mips_opts.mips16)
    S_SET_OTHER (label, ELF_ST_SET_MIPS16 (S_GET_OTHER (label)));
  else
    S_SET_OTHER (label, ELF_ST_SET_MICROMIPS (S_GET_OTHER (label)));
  if ((S_GET_VALUE (label) & 1) == 0
      /* Don't adjust the address if the label is global or weak, or
	 in a link-once section, since we'll be emitting symbol reloc
	 references to it which will be patched up by the linker, and
	 the final value of the symbol may or may not be MIPS16/microMIPS.  */
      && !S_IS_WEAK (label)
      && !S_IS_EXTERNAL (label)
      && !s_is_linkonce (label, now_seg))
    S_SET_VALUE (label, S_GET_VALUE (label) | 1);
}

/* Mark preceding MIPS16 or microMIPS instruction labels.  */

static void
mips_compressed_mark_labels (void)
{
  struct insn_label_list *l;

  for (l = seg_info (now_seg)->label_list; l != NULL; l = l->next)
    mips_compressed_mark_label (l->label);
}

/* End the current frag.  Make it a variant frag and record the
   relaxation info.  */

static void
relax_close_frag (void)
{
  mips_macro_warning.first_frag = frag_now;
  frag_var (rs_machine_dependent, 0, 0,
	    RELAX_ENCODE (mips_relax.sizes[0], mips_relax.sizes[1]),
	    mips_relax.symbol, 0, (char *) mips_relax.first_fixup);

  memset (&mips_relax.sizes, 0, sizeof (mips_relax.sizes));
  mips_relax.first_fixup = 0;
}

/* Start a new relaxation sequence whose expansion depends on SYMBOL.
   See the comment above RELAX_ENCODE for more details.  */

static void
relax_start (symbolS *symbol)
{
  gas_assert (mips_relax.sequence == 0);
  mips_relax.sequence = 1;
  mips_relax.symbol = symbol;
}

/* Start generating the second version of a relaxable sequence.
   See the comment above RELAX_ENCODE for more details.  */

static void
relax_switch (void)
{
  gas_assert (mips_relax.sequence == 1);
  mips_relax.sequence = 2;
}

/* End the current relaxable sequence.  */

static void
relax_end (void)
{
  gas_assert (mips_relax.sequence == 2);
  relax_close_frag ();
  mips_relax.sequence = 0;
}

/* Return true if IP is a delayed branch or jump.  */

static inline bfd_boolean
delayed_branch_p (const struct mips_cl_insn *ip)
{
  return (ip->insn_mo->pinfo & (INSN_UNCOND_BRANCH_DELAY
				| INSN_COND_BRANCH_DELAY
				| INSN_COND_BRANCH_LIKELY)) != 0;
}

/* Return true if IP is a compact branch or jump.  */

static inline bfd_boolean
compact_branch_p (const struct mips_cl_insn *ip)
{
  return (ip->insn_mo->pinfo2 & (INSN2_UNCOND_BRANCH
				 | INSN2_COND_BRANCH)) != 0;
}

/* Return true if IP is an unconditional branch or jump.  */

static inline bfd_boolean
uncond_branch_p (const struct mips_cl_insn *ip)
{
  return ((ip->insn_mo->pinfo & INSN_UNCOND_BRANCH_DELAY) != 0
	  || (ip->insn_mo->pinfo2 & INSN2_UNCOND_BRANCH) != 0);
}

/* Return true if IP is a branch-likely instruction.  */

static inline bfd_boolean
branch_likely_p (const struct mips_cl_insn *ip)
{
  return (ip->insn_mo->pinfo & INSN_COND_BRANCH_LIKELY) != 0;
}

/* Return the type of nop that should be used to fill the delay slot
   of delayed branch IP.  */

static struct mips_cl_insn *
get_delay_slot_nop (const struct mips_cl_insn *ip)
{
  if (mips_opts.micromips
      && (ip->insn_mo->pinfo2 & INSN2_BRANCH_DELAY_32BIT))
    return &micromips_nop32_insn;
  return NOP_INSN;
}

/* Return a mask that has bit N set if OPCODE reads the register(s)
   in operand N.  */

static unsigned int
insn_read_mask (const struct mips_opcode *opcode)
{
  return (opcode->pinfo & INSN_READ_ALL) >> INSN_READ_SHIFT;
}

/* Return a mask that has bit N set if OPCODE writes to the register(s)
   in operand N.  */

static unsigned int
insn_write_mask (const struct mips_opcode *opcode)
{
  return (opcode->pinfo & INSN_WRITE_ALL) >> INSN_WRITE_SHIFT;
}

/* Return a mask of the registers specified by operand OPERAND of INSN.
   Ignore registers of type OP_REG_<t> unless bit OP_REG_<t> of TYPE_MASK
   is set.  */

static unsigned int
operand_reg_mask (const struct mips_cl_insn *insn,
		  const struct mips_operand *operand,
		  unsigned int type_mask)
{
  unsigned int uval, vsel;

  switch (operand->type)
    {
    case OP_INT:
    case OP_MAPPED_INT:
    case OP_MSB:
    case OP_PCREL:
    case OP_PERF_REG:
    case OP_ADDIUSP_INT:
    case OP_ENTRY_EXIT_LIST:
    case OP_REPEAT_DEST_REG:
    case OP_REPEAT_PREV_REG:
    case OP_PC:
    case OP_VU0_SUFFIX:
    case OP_VU0_MATCH_SUFFIX:
    case OP_IMM_INDEX:
      abort ();

    case OP_REG:
    case OP_OPTIONAL_REG:
      {
	const struct mips_reg_operand *reg_op;

	reg_op = (const struct mips_reg_operand *) operand;
	if (!(type_mask & (1 << reg_op->reg_type)))
	  return 0;
	uval = insn_extract_operand (insn, operand);
	return 1 << mips_decode_reg_operand (reg_op, uval);
      }

    case OP_REG_PAIR:
      {
	const struct mips_reg_pair_operand *pair_op;

	pair_op = (const struct mips_reg_pair_operand *) operand;
	if (!(type_mask & (1 << pair_op->reg_type)))
	  return 0;
	uval = insn_extract_operand (insn, operand);
	return (1 << pair_op->reg1_map[uval]) | (1 << pair_op->reg2_map[uval]);
      }

    case OP_CLO_CLZ_DEST:
      if (!(type_mask & (1 << OP_REG_GP)))
	return 0;
      uval = insn_extract_operand (insn, operand);
      return (1 << (uval & 31)) | (1 << (uval >> 5));

    case OP_LWM_SWM_LIST:
      abort ();

    case OP_SAVE_RESTORE_LIST:
      abort ();

    case OP_MDMX_IMM_REG:
      if (!(type_mask & (1 << OP_REG_VEC)))
	return 0;
      uval = insn_extract_operand (insn, operand);
      vsel = uval >> 5;
      if ((vsel & 0x18) == 0x18)
	return 0;
      return 1 << (uval & 31);

    case OP_REG_INDEX:
      if (!(type_mask & (1 << OP_REG_GP)))
	return 0;
      return 1 << insn_extract_operand (insn, operand);
    }
  abort ();
}

/* Return a mask of the registers specified by operands OPNO_MASK of INSN,
   where bit N of OPNO_MASK is set if operand N should be included.
   Ignore registers of type OP_REG_<t> unless bit OP_REG_<t> of TYPE_MASK
   is set.  */

static unsigned int
insn_reg_mask (const struct mips_cl_insn *insn,
	       unsigned int type_mask, unsigned int opno_mask)
{
  unsigned int opno, reg_mask;

  opno = 0;
  reg_mask = 0;
  while (opno_mask != 0)
    {
      if (opno_mask & 1)
	reg_mask |= operand_reg_mask (insn, insn_opno (insn, opno), type_mask);
      opno_mask >>= 1;
      opno += 1;
    }
  return reg_mask;
}

/* Return the mask of core registers that IP reads.  */

static unsigned int
gpr_read_mask (const struct mips_cl_insn *ip)
{
  unsigned long pinfo, pinfo2;
  unsigned int mask;

  mask = insn_reg_mask (ip, 1 << OP_REG_GP, insn_read_mask (ip->insn_mo));
  pinfo = ip->insn_mo->pinfo;
  pinfo2 = ip->insn_mo->pinfo2;
  if (pinfo & INSN_UDI)
    {
      /* UDI instructions have traditionally been assumed to read RS
	 and RT.  */
      mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RT, *ip);
      mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RS, *ip);
    }
  if (pinfo & INSN_READ_GPR_24)
    mask |= 1 << 24;
  if (pinfo2 & INSN2_READ_GPR_16)
    mask |= 1 << 16;
  if (pinfo2 & INSN2_READ_SP)
    mask |= 1 << SP;
  if (pinfo2 & INSN2_READ_GPR_31)
    mask |= 1 << 31;
  /* Don't include register 0.  */
  return mask & ~1;
}

/* Return the mask of core registers that IP writes.  */

static unsigned int
gpr_write_mask (const struct mips_cl_insn *ip)
{
  unsigned long pinfo, pinfo2;
  unsigned int mask;

  mask = insn_reg_mask (ip, 1 << OP_REG_GP, insn_write_mask (ip->insn_mo));
  pinfo = ip->insn_mo->pinfo;
  pinfo2 = ip->insn_mo->pinfo2;
  if (pinfo & INSN_WRITE_GPR_24)
    mask |= 1 << 24;
  if (pinfo & INSN_WRITE_GPR_31)
    mask |= 1 << 31;
  if (pinfo & INSN_UDI)
    /* UDI instructions have traditionally been assumed to write to RD.  */
    mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RD, *ip);
  if (pinfo2 & INSN2_WRITE_SP)
    mask |= 1 << SP;
  /* Don't include register 0.  */
  return mask & ~1;
}

/* Return the mask of floating-point registers that IP reads.  */

static unsigned int
fpr_read_mask (const struct mips_cl_insn *ip)
{
  unsigned long pinfo;
  unsigned int mask;

  mask = insn_reg_mask (ip, ((1 << OP_REG_FP) | (1 << OP_REG_VEC)
			     | (1 << OP_REG_MSA)),
			insn_read_mask (ip->insn_mo));
  pinfo = ip->insn_mo->pinfo;
  /* Conservatively treat all operands to an FP_D instruction are doubles.
     (This is overly pessimistic for things like cvt.d.s.)  */
  if (HAVE_32BIT_FPRS && (pinfo & FP_D))
    mask |= mask << 1;
  return mask;
}

/* Return the mask of floating-point registers that IP writes.  */

static unsigned int
fpr_write_mask (const struct mips_cl_insn *ip)
{
  unsigned long pinfo;
  unsigned int mask;

  mask = insn_reg_mask (ip, ((1 << OP_REG_FP) | (1 << OP_REG_VEC)
			     | (1 << OP_REG_MSA)),
			insn_write_mask (ip->insn_mo));
  pinfo = ip->insn_mo->pinfo;
  /* Conservatively treat all operands to an FP_D instruction are doubles.
     (This is overly pessimistic for things like cvt.s.d.)  */
  if (HAVE_32BIT_FPRS && (pinfo & FP_D))
    mask |= mask << 1;
  return mask;
}

/* Operand OPNUM of INSN is an odd-numbered floating-point register.
   Check whether that is allowed.  */

static bfd_boolean
mips_oddfpreg_ok (const struct mips_opcode *insn, int opnum)
{
  const char *s = insn->name;

  if (insn->pinfo == INSN_MACRO)
    /* Let a macro pass, we'll catch it later when it is expanded.  */
    return TRUE;

  if (ISA_HAS_ODD_SINGLE_FPR (mips_opts.isa) || mips_opts.arch == CPU_R5900)
    {
      /* Allow odd registers for single-precision ops.  */
      switch (insn->pinfo & (FP_S | FP_D))
	{
	case FP_S:
	case 0:
	  return TRUE;
	case FP_D:
	  return FALSE;
	default:
	  break;
	}

      /* Cvt.w.x and cvt.x.w allow an odd register for a 'w' or 's' operand.  */
      s = strchr (insn->name, '.');
      if (s != NULL && opnum == 2)
	s = strchr (s + 1, '.');
      return (s != NULL && (s[1] == 'w' || s[1] == 's'));
    }

  /* Single-precision coprocessor loads and moves are OK too.  */
  if ((insn->pinfo & FP_S)
      && (insn->pinfo & (INSN_COPROC_MEMORY_DELAY | INSN_STORE_MEMORY
			 | INSN_LOAD_COPROC_DELAY | INSN_COPROC_MOVE_DELAY)))
    return TRUE;

  return FALSE;
}

/* Information about an instruction argument that we're trying to match.  */
struct mips_arg_info
{
  /* The instruction so far.  */
  struct mips_cl_insn *insn;

  /* The first unconsumed operand token.  */
  struct mips_operand_token *token;

  /* The 1-based operand number, in terms of insn->insn_mo->args.  */
  int opnum;

  /* The 1-based argument number, for error reporting.  This does not
     count elided optional registers, etc..  */
  int argnum;

  /* The last OP_REG operand seen, or ILLEGAL_REG if none.  */
  unsigned int last_regno;

  /* If the first operand was an OP_REG, this is the register that it
     specified, otherwise it is ILLEGAL_REG.  */
  unsigned int dest_regno;

  /* The value of the last OP_INT operand.  Only used for OP_MSB,
     where it gives the lsb position.  */
  unsigned int last_op_int;

  /* If true, match routines should assume that no later instruction
     alternative matches and should therefore be as accomodating as
     possible.  Match routines should not report errors if something
     is only invalid for !LAX_MATCH.  */
  bfd_boolean lax_match;

  /* True if a reference to the current AT register was seen.  */
  bfd_boolean seen_at;
};

/* Record that the argument is out of range.  */

static void
match_out_of_range (struct mips_arg_info *arg)
{
  set_insn_error_i (arg->argnum, _("operand %d out of range"), arg->argnum);
}

/* Record that the argument isn't constant but needs to be.  */

static void
match_not_constant (struct mips_arg_info *arg)
{
  set_insn_error_i (arg->argnum, _("operand %d must be constant"),
		    arg->argnum);
}

/* Try to match an OT_CHAR token for character CH.  Consume the token
   and return true on success, otherwise return false.  */

static bfd_boolean
match_char (struct mips_arg_info *arg, char ch)
{
  if (arg->token->type == OT_CHAR && arg->token->u.ch == ch)
    {
      ++arg->token;
      if (ch == ',')
	arg->argnum += 1;
      return TRUE;
    }
  return FALSE;
}

/* Try to get an expression from the next tokens in ARG.  Consume the
   tokens and return true on success, storing the expression value in
   VALUE and relocation types in R.  */

static bfd_boolean
match_expression (struct mips_arg_info *arg, expressionS *value,
		  bfd_reloc_code_real_type *r)
{
  /* If the next token is a '(' that was parsed as being part of a base
     expression, assume we have an elided offset.  The later match will fail
     if this turns out to be wrong.  */
  if (arg->token->type == OT_CHAR && arg->token->u.ch == '(')
    {
      value->X_op = O_constant;
      value->X_add_number = 0;
      r[0] = r[1] = r[2] = BFD_RELOC_UNUSED;
      return TRUE;
    }

  /* Reject register-based expressions such as "0+$2" and "(($2))".
     For plain registers the default error seems more appropriate.  */
  if (arg->token->type == OT_INTEGER
      && arg->token->u.integer.value.X_op == O_register)
    {
      set_insn_error (arg->argnum, _("register value used as expression"));
      return FALSE;
    }

  if (arg->token->type == OT_INTEGER)
    {
      *value = arg->token->u.integer.value;
      memcpy (r, arg->token->u.integer.relocs, 3 * sizeof (*r));
      ++arg->token;
      return TRUE;
    }

  set_insn_error_i
    (arg->argnum, _("operand %d must be an immediate expression"),
     arg->argnum);
  return FALSE;
}

/* Try to get a constant expression from the next tokens in ARG.  Consume
   the tokens and return return true on success, storing the constant value
   in *VALUE.  Use FALLBACK as the value if the match succeeded with an
   error.  */

static bfd_boolean
match_const_int (struct mips_arg_info *arg, offsetT *value)
{
  expressionS ex;
  bfd_reloc_code_real_type r[3];

  if (!match_expression (arg, &ex, r))
    return FALSE;

  if (r[0] == BFD_RELOC_UNUSED && ex.X_op == O_constant)
    *value = ex.X_add_number;
  else
    {
      match_not_constant (arg);
      return FALSE;
    }
  return TRUE;
}

/* Return the RTYPE_* flags for a register operand of type TYPE that
   appears in instruction OPCODE.  */

static unsigned int
convert_reg_type (const struct mips_opcode *opcode,
		  enum mips_reg_operand_type type)
{
  switch (type)
    {
    case OP_REG_GP:
      return RTYPE_NUM | RTYPE_GP;

    case OP_REG_FP:
      /* Allow vector register names for MDMX if the instruction is a 64-bit
	 FPR load, store or move (including moves to and from GPRs).  */
      if ((mips_opts.ase & ASE_MDMX)
	  && (opcode->pinfo & FP_D)
	  && (opcode->pinfo & (INSN_COPROC_MOVE_DELAY
			       | INSN_COPROC_MEMORY_DELAY
			       | INSN_LOAD_COPROC_DELAY
			       | INSN_LOAD_MEMORY_DELAY
			       | INSN_STORE_MEMORY)))
	return RTYPE_FPU | RTYPE_VEC;
      return RTYPE_FPU;

    case OP_REG_CCC:
      if (opcode->pinfo & (FP_D | FP_S))
	return RTYPE_CCC | RTYPE_FCC;
      return RTYPE_CCC;

    case OP_REG_VEC:
      if (opcode->membership & INSN_5400)
	return RTYPE_FPU;
      return RTYPE_FPU | RTYPE_VEC;

    case OP_REG_ACC:
      return RTYPE_ACC;

    case OP_REG_COPRO:
      if (opcode->name[strlen (opcode->name) - 1] == '0')
	return RTYPE_NUM | RTYPE_CP0;
      return RTYPE_NUM;

    case OP_REG_HW:
      return RTYPE_NUM;

    case OP_REG_VI:
      return RTYPE_NUM | RTYPE_VI;

    case OP_REG_VF:
      return RTYPE_NUM | RTYPE_VF;

    case OP_REG_R5900_I:
      return RTYPE_R5900_I;

    case OP_REG_R5900_Q:
      return RTYPE_R5900_Q;

    case OP_REG_R5900_R:
      return RTYPE_R5900_R;

    case OP_REG_R5900_ACC:
      return RTYPE_R5900_ACC;

    case OP_REG_MSA:
      return RTYPE_MSA;

    case OP_REG_MSA_CTRL:
      return RTYPE_NUM;
    }
  abort ();
}

/* ARG is register REGNO, of type TYPE.  Warn about any dubious registers.  */

static void
check_regno (struct mips_arg_info *arg,
	     enum mips_reg_operand_type type, unsigned int regno)
{
  if (AT && type == OP_REG_GP && regno == AT)
    arg->seen_at = TRUE;

  if (type == OP_REG_FP
      && (regno & 1) != 0
      && HAVE_32BIT_FPRS
      && !mips_oddfpreg_ok (arg->insn->insn_mo, arg->opnum))
    as_warn (_("float register should be even, was %d"), regno);

  if (type == OP_REG_CCC)
    {
      const char *name;
      size_t length;

      name = arg->insn->insn_mo->name;
      length = strlen (name);
      if ((regno & 1) != 0
	  && ((length >= 3 && strcmp (name + length - 3, ".ps") == 0)
	      || (length >= 5 && strncmp (name + length - 5, "any2", 4) == 0)))
	as_warn (_("condition code register should be even for %s, was %d"),
		 name, regno);

      if ((regno & 3) != 0
	  && (length >= 5 && strncmp (name + length - 5, "any4", 4) == 0))
	as_warn (_("condition code register should be 0 or 4 for %s, was %d"),
		 name, regno);
    }
}

/* ARG is a register with symbol value SYMVAL.  Try to interpret it as
   a register of type TYPE.  Return true on success, storing the register
   number in *REGNO and warning about any dubious uses.  */

static bfd_boolean
match_regno (struct mips_arg_info *arg, enum mips_reg_operand_type type,
	     unsigned int symval, unsigned int *regno)
{
  if (type == OP_REG_VEC)
    symval = mips_prefer_vec_regno (symval);
  if (!(symval & convert_reg_type (arg->insn->insn_mo, type)))
    return FALSE;

  *regno = symval & RNUM_MASK;
  check_regno (arg, type, *regno);
  return TRUE;
}

/* Try to interpret the next token in ARG as a register of type TYPE.
   Consume the token and return true on success, storing the register
   number in *REGNO.  Return false on failure.  */

static bfd_boolean
match_reg (struct mips_arg_info *arg, enum mips_reg_operand_type type,
	   unsigned int *regno)
{
  if (arg->token->type == OT_REG
      && match_regno (arg, type, arg->token->u.regno, regno))
    {
      ++arg->token;
      return TRUE;
    }
  return FALSE;
}

/* Try to interpret the next token in ARG as a range of registers of type TYPE.
   Consume the token and return true on success, storing the register numbers
   in *REGNO1 and *REGNO2.  Return false on failure.  */

static bfd_boolean
match_reg_range (struct mips_arg_info *arg, enum mips_reg_operand_type type,
		 unsigned int *regno1, unsigned int *regno2)
{
  if (match_reg (arg, type, regno1))
    {
      *regno2 = *regno1;
      return TRUE;
    }
  if (arg->token->type == OT_REG_RANGE
      && match_regno (arg, type, arg->token->u.reg_range.regno1, regno1)
      && match_regno (arg, type, arg->token->u.reg_range.regno2, regno2)
      && *regno1 <= *regno2)
    {
      ++arg->token;
      return TRUE;
    }
  return FALSE;
}

/* OP_INT matcher.  */

static bfd_boolean
match_int_operand (struct mips_arg_info *arg,
		   const struct mips_operand *operand_base)
{
  const struct mips_int_operand *operand;
  unsigned int uval;
  int min_val, max_val, factor;
  offsetT sval;

  operand = (const struct mips_int_operand *) operand_base;
  factor = 1 << operand->shift;
  min_val = mips_int_operand_min (operand);
  max_val = mips_int_operand_max (operand);

  if (operand_base->lsb == 0
      && operand_base->size == 16
      && operand->shift == 0
      && operand->bias == 0
      && (operand->max_val == 32767 || operand->max_val == 65535))
    {
      /* The operand can be relocated.  */
      if (!match_expression (arg, &offset_expr, offset_reloc))
	return FALSE;

      if (offset_reloc[0] != BFD_RELOC_UNUSED)
	/* Relocation operators were used.  Accept the arguent and
	   leave the relocation value in offset_expr and offset_relocs
	   for the caller to process.  */
	return TRUE;

      if (offset_expr.X_op != O_constant)
	{
	  /* Accept non-constant operands if no later alternative matches,
	     leaving it for the caller to process.  */
	  if (!arg->lax_match)
	    return FALSE;
	  offset_reloc[0] = BFD_RELOC_LO16;
	  return TRUE;
	}

      /* Clear the global state; we're going to install the operand
	 ourselves.  */
      sval = offset_expr.X_add_number;
      offset_expr.X_op = O_absent;

      /* For compatibility with older assemblers, we accept
	 0x8000-0xffff as signed 16-bit numbers when only
	 signed numbers are allowed.  */
      if (sval > max_val)
	{
	  max_val = ((1 << operand_base->size) - 1) << operand->shift;
	  if (!arg->lax_match && sval <= max_val)
	    return FALSE;
	}
    }
  else
    {
      if (!match_const_int (arg, &sval))
	return FALSE;
    }

  arg->last_op_int = sval;

  if (sval < min_val || sval > max_val || sval % factor)
    {
      match_out_of_range (arg);
      return FALSE;
    }

  uval = (unsigned int) sval >> operand->shift;
  uval -= operand->bias;

  /* Handle -mfix-cn63xxp1.  */
  if (arg->opnum == 1
      && mips_fix_cn63xxp1
      && !mips_opts.micromips
      && strcmp ("pref", arg->insn->insn_mo->name) == 0)
    switch (uval)
      {
      case 5:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
	/* These are ok.  */
	break;

      default:
	/* The rest must be changed to 28.  */
	uval = 28;
	break;
      }

  insn_insert_operand (arg->insn, operand_base, uval);
  return TRUE;
}

/* OP_MAPPED_INT matcher.  */

static bfd_boolean
match_mapped_int_operand (struct mips_arg_info *arg,
			  const struct mips_operand *operand_base)
{
  const struct mips_mapped_int_operand *operand;
  unsigned int uval, num_vals;
  offsetT sval;

  operand = (const struct mips_mapped_int_operand *) operand_base;
  if (!match_const_int (arg, &sval))
    return FALSE;

  num_vals = 1 << operand_base->size;
  for (uval = 0; uval < num_vals; uval++)
    if (operand->int_map[uval] == sval)
      break;
  if (uval == num_vals)
    {
      match_out_of_range (arg);
      return FALSE;
    }

  insn_insert_operand (arg->insn, operand_base, uval);
  return TRUE;
}

/* OP_MSB matcher.  */

static bfd_boolean
match_msb_operand (struct mips_arg_info *arg,
		   const struct mips_operand *operand_base)
{
  const struct mips_msb_operand *operand;
  int min_val, max_val, max_high;
  offsetT size, sval, high;

  operand = (const struct mips_msb_operand *) operand_base;
  min_val = operand->bias;
  max_val = min_val + (1 << operand_base->size) - 1;
  max_high = operand->opsize;

  if (!match_const_int (arg, &size))
    return FALSE;

  high = size + arg->last_op_int;
  sval = operand->add_lsb ? high : size;

  if (size < 0 || high > max_high || sval < min_val || sval > max_val)
    {
      match_out_of_range (arg);
      return FALSE;
    }
  insn_insert_operand (arg->insn, operand_base, sval - min_val);
  return TRUE;
}

/* OP_REG matcher.  */

static bfd_boolean
match_reg_operand (struct mips_arg_info *arg,
		   const struct mips_operand *operand_base)
{
  const struct mips_reg_operand *operand;
  unsigned int regno, uval, num_vals;

  operand = (const struct mips_reg_operand *) operand_base;
  if (!match_reg (arg, operand->reg_type, &regno))
    return FALSE;

  if (operand->reg_map)
    {
      num_vals = 1 << operand->root.size;
      for (uval = 0; uval < num_vals; uval++)
	if (operand->reg_map[uval] == regno)
	  break;
      if (num_vals == uval)
	return FALSE;
    }
  else
    uval = regno;

  arg->last_regno = regno;
  if (arg->opnum == 1)
    arg->dest_regno = regno;
  insn_insert_operand (arg->insn, operand_base, uval);
  return TRUE;
}

/* OP_REG_PAIR matcher.  */

static bfd_boolean
match_reg_pair_operand (struct mips_arg_info *arg,
			const struct mips_operand *operand_base)
{
  const struct mips_reg_pair_operand *operand;
  unsigned int regno1, regno2, uval, num_vals;

  operand = (const struct mips_reg_pair_operand *) operand_base;
  if (!match_reg (arg, operand->reg_type, &regno1)
      || !match_char (arg, ',')
      || !match_reg (arg, operand->reg_type, &regno2))
    return FALSE;

  num_vals = 1 << operand_base->size;
  for (uval = 0; uval < num_vals; uval++)
    if (operand->reg1_map[uval] == regno1 && operand->reg2_map[uval] == regno2)
      break;
  if (uval == num_vals)
    return FALSE;

  insn_insert_operand (arg->insn, operand_base, uval);
  return TRUE;
}

/* OP_PCREL matcher.  The caller chooses the relocation type.  */

static bfd_boolean
match_pcrel_operand (struct mips_arg_info *arg)
{
  bfd_reloc_code_real_type r[3];

  return match_expression (arg, &offset_expr, r) && r[0] == BFD_RELOC_UNUSED;
}

/* OP_PERF_REG matcher.  */

static bfd_boolean
match_perf_reg_operand (struct mips_arg_info *arg,
			const struct mips_operand *operand)
{
  offsetT sval;

  if (!match_const_int (arg, &sval))
    return FALSE;

  if (sval != 0
      && (sval != 1
	  || (mips_opts.arch == CPU_R5900
	      && (strcmp (arg->insn->insn_mo->name, "mfps") == 0
		  || strcmp (arg->insn->insn_mo->name, "mtps") == 0))))
    {
      set_insn_error (arg->argnum, _("invalid performance register"));
      return FALSE;
    }

  insn_insert_operand (arg->insn, operand, sval);
  return TRUE;
}

/* OP_ADDIUSP matcher.  */

static bfd_boolean
match_addiusp_operand (struct mips_arg_info *arg,
		       const struct mips_operand *operand)
{
  offsetT sval;
  unsigned int uval;

  if (!match_const_int (arg, &sval))
    return FALSE;

  if (sval % 4)
    {
      match_out_of_range (arg);
      return FALSE;
    }

  sval /= 4;
  if (!(sval >= -258 && sval <= 257) || (sval >= -2 && sval <= 1))
    {
      match_out_of_range (arg);
      return FALSE;
    }

  uval = (unsigned int) sval;
  uval = ((uval >> 1) & ~0xff) | (uval & 0xff);
  insn_insert_operand (arg->insn, operand, uval);
  return TRUE;
}

/* OP_CLO_CLZ_DEST matcher.  */

static bfd_boolean
match_clo_clz_dest_operand (struct mips_arg_info *arg,
			    const struct mips_operand *operand)
{
  unsigned int regno;

  if (!match_reg (arg, OP_REG_GP, &regno))
    return FALSE;

  insn_insert_operand (arg->insn, operand, regno | (regno << 5));
  return TRUE;
}

/* OP_LWM_SWM_LIST matcher.  */

static bfd_boolean
match_lwm_swm_list_operand (struct mips_arg_info *arg,
			    const struct mips_operand *operand)
{
  unsigned int reglist, sregs, ra, regno1, regno2;
  struct mips_arg_info reset;

  reglist = 0;
  if (!match_reg_range (arg, OP_REG_GP, &regno1, &regno2))
    return FALSE;
  do
    {
      if (regno2 == FP && regno1 >= S0 && regno1 <= S7)
	{
	  reglist |= 1 << FP;
	  regno2 = S7;
	}
      reglist |= ((1U << regno2 << 1) - 1) & -(1U << regno1);
      reset = *arg;
    }
  while (match_char (arg, ',')
	 && match_reg_range (arg, OP_REG_GP, &regno1, &regno2));
  *arg = reset;

  if (operand->size == 2)
    {
      /* The list must include both ra and s0-sN, for 0 <= N <= 3.  E.g.:

	 s0, ra
	 s0, s1, ra, s2, s3
	 s0-s2, ra

	 and any permutations of these.  */
      if ((reglist & 0xfff1ffff) != 0x80010000)
	return FALSE;

      sregs = (reglist >> 17) & 7;
      ra = 0;
    }
  else
    {
      /* The list must include at least one of ra and s0-sN,
	 for 0 <= N <= 8.  (Note that there is a gap between s7 and s8,
	 which are $23 and $30 respectively.)  E.g.:

	 ra
	 s0
	 ra, s0, s1, s2
	 s0-s8
	 s0-s5, ra

	 and any permutations of these.  */
      if ((reglist & 0x3f00ffff) != 0)
	return FALSE;

      ra = (reglist >> 27) & 0x10;
      sregs = ((reglist >> 22) & 0x100) | ((reglist >> 16) & 0xff);
    }
  sregs += 1;
  if ((sregs & -sregs) != sregs)
    return FALSE;

  insn_insert_operand (arg->insn, operand, (ffs (sregs) - 1) | ra);
  return TRUE;
}

/* OP_ENTRY_EXIT_LIST matcher.  */

static unsigned int
match_entry_exit_operand (struct mips_arg_info *arg,
			  const struct mips_operand *operand)
{
  unsigned int mask;
  bfd_boolean is_exit;

  /* The format is the same for both ENTRY and EXIT, but the constraints
     are different.  */
  is_exit = strcmp (arg->insn->insn_mo->name, "exit") == 0;
  mask = (is_exit ? 7 << 3 : 0);
  do
    {
      unsigned int regno1, regno2;
      bfd_boolean is_freg;

      if (match_reg_range (arg, OP_REG_GP, &regno1, &regno2))
	is_freg = FALSE;
      else if (match_reg_range (arg, OP_REG_FP, &regno1, &regno2))
	is_freg = TRUE;
      else
	return FALSE;

      if (is_exit && is_freg && regno1 == 0 && regno2 < 2)
	{
	  mask &= ~(7 << 3);
	  mask |= (5 + regno2) << 3;
	}
      else if (!is_exit && regno1 == 4 && regno2 >= 4 && regno2 <= 7)
	mask |= (regno2 - 3) << 3;
      else if (regno1 == 16 && regno2 >= 16 && regno2 <= 17)
	mask |= (regno2 - 15) << 1;
      else if (regno1 == RA && regno2 == RA)
	mask |= 1;
      else
	return FALSE;
    }
  while (match_char (arg, ','));

  insn_insert_operand (arg->insn, operand, mask);
  return TRUE;
}

/* OP_SAVE_RESTORE_LIST matcher.  */

static bfd_boolean
match_save_restore_list_operand (struct mips_arg_info *arg)
{
  unsigned int opcode, args, statics, sregs;
  unsigned int num_frame_sizes, num_args, num_statics, num_sregs;
  offsetT frame_size;

  opcode = arg->insn->insn_opcode;
  frame_size = 0;
  num_frame_sizes = 0;
  args = 0;
  statics = 0;
  sregs = 0;
  do
    {
      unsigned int regno1, regno2;

      if (arg->token->type == OT_INTEGER)
	{
	  /* Handle the frame size.  */
	  if (!match_const_int (arg, &frame_size))
	    return FALSE;
	  num_frame_sizes += 1;
	}
      else
	{
	  if (!match_reg_range (arg, OP_REG_GP, &regno1, &regno2))
	    return FALSE;

	  while (regno1 <= regno2)
	    {
	      if (regno1 >= 4 && regno1 <= 7)
		{
		  if (num_frame_sizes == 0)
		    /* args $a0-$a3 */
		    args |= 1 << (regno1 - 4);
		  else
		    /* statics $a0-$a3 */
		    statics |= 1 << (regno1 - 4);
		}
	      else if (regno1 >= 16 && regno1 <= 23)
		/* $s0-$s7 */
		sregs |= 1 << (regno1 - 16);
	      else if (regno1 == 30)
		/* $s8 */
		sregs |= 1 << 8;
	      else if (regno1 == 31)
		/* Add $ra to insn.  */
		opcode |= 0x40;
	      else
		return FALSE;
	      regno1 += 1;
	      if (regno1 == 24)
		regno1 = 30;
	    }
	}
    }
  while (match_char (arg, ','));

  /* Encode args/statics combination.  */
  if (args & statics)
    return FALSE;
  else if (args == 0xf)
    /* All $a0-$a3 are args.  */
    opcode |= MIPS16_ALL_ARGS << 16;
  else if (statics == 0xf)
    /* All $a0-$a3 are statics.  */
    opcode |= MIPS16_ALL_STATICS << 16;
  else
    {
      /* Count arg registers.  */
      num_args = 0;
      while (args & 0x1)
	{
	  args >>= 1;
	  num_args += 1;
	}
      if (args != 0)
	return FALSE;

      /* Count static registers.  */
      num_statics = 0;
      while (statics & 0x8)
	{
	  statics = (statics << 1) & 0xf;
	  num_statics += 1;
	}
      if (statics != 0)
	return FALSE;

      /* Encode args/statics.  */
      opcode |= ((num_args << 2) | num_statics) << 16;
    }

  /* Encode $s0/$s1.  */
  if (sregs & (1 << 0))		/* $s0 */
    opcode |= 0x20;
  if (sregs & (1 << 1))		/* $s1 */
    opcode |= 0x10;
  sregs >>= 2;

  /* Encode $s2-$s8. */
  num_sregs = 0;
  while (sregs & 1)
    {
      sregs >>= 1;
      num_sregs += 1;
    }
  if (sregs != 0)
    return FALSE;
  opcode |= num_sregs << 24;

  /* Encode frame size.  */
  if (num_frame_sizes == 0)
    {
      set_insn_error (arg->argnum, _("missing frame size"));
      return FALSE;
    }
  if (num_frame_sizes > 1)
    {
      set_insn_error (arg->argnum, _("frame size specified twice"));
      return FALSE;
    }
  if ((frame_size & 7) != 0 || frame_size < 0 || frame_size > 0xff * 8)
    {
      set_insn_error (arg->argnum, _("invalid frame size"));
      return FALSE;
    }
  if (frame_size != 128 || (opcode >> 16) != 0)
    {
      frame_size /= 8;
      opcode |= (((frame_size & 0xf0) << 16)
		 | (frame_size & 0x0f));
    }

  /* Finally build the instruction.  */
  if ((opcode >> 16) != 0 || frame_size == 0)
    opcode |= MIPS16_EXTEND;
  arg->insn->insn_opcode = opcode;
  return TRUE;
}

/* OP_MDMX_IMM_REG matcher.  */

static bfd_boolean
match_mdmx_imm_reg_operand (struct mips_arg_info *arg,
			    const struct mips_operand *operand)
{
  unsigned int regno, uval;
  bfd_boolean is_qh;
  const struct mips_opcode *opcode;

  /* The mips_opcode records whether this is an octobyte or quadhalf
     instruction.  Start out with that bit in place.  */
  opcode = arg->insn->insn_mo;
  uval = mips_extract_operand (operand, opcode->match);
  is_qh = (uval != 0);

  if (arg->token->type == OT_REG)
    {
      if ((opcode->membership & INSN_5400)
	  && strcmp (opcode->name, "rzu.ob") == 0)
	{
	  set_insn_error_i (arg->argnum, _("operand %d must be an immediate"),
			    arg->argnum);
	  return FALSE;
	}

      if (!match_regno (arg, OP_REG_VEC, arg->token->u.regno, &regno))
	return FALSE;
      ++arg->token;

      /* Check whether this is a vector register or a broadcast of
	 a single element.  */
      if (arg->token->type == OT_INTEGER_INDEX)
	{
	  if (arg->token->u.index > (is_qh ? 3 : 7))
	    {
	      set_insn_error (arg->argnum, _("invalid element selector"));
	      return FALSE;
	    }
	  uval |= arg->token->u.index << (is_qh ? 2 : 1) << 5;
	  ++arg->token;
	}
      else
	{
	  /* A full vector.  */
	  if ((opcode->membership & INSN_5400)
	      && (strcmp (opcode->name, "sll.ob") == 0
		  || strcmp (opcode->name, "srl.ob") == 0))
	    {
	      set_insn_error_i (arg->argnum, _("operand %d must be scalar"),
				arg->argnum);
	      return FALSE;
	    }

	  if (is_qh)
	    uval |= MDMX_FMTSEL_VEC_QH << 5;
	  else
	    uval |= MDMX_FMTSEL_VEC_OB << 5;
	}
      uval |= regno;
    }
  else
    {
      offsetT sval;

      if (!match_const_int (arg, &sval))
	return FALSE;
      if (sval < 0 || sval > 31)
	{
	  match_out_of_range (arg);
	  return FALSE;
	}
      uval |= (sval & 31);
      if (is_qh)
	uval |= MDMX_FMTSEL_IMM_QH << 5;
      else
	uval |= MDMX_FMTSEL_IMM_OB << 5;
    }
  insn_insert_operand (arg->insn, operand, uval);
  return TRUE;
}

/* OP_IMM_INDEX matcher.  */

static bfd_boolean
match_imm_index_operand (struct mips_arg_info *arg,
			 const struct mips_operand *operand)
{
  unsigned int max_val;

  if (arg->token->type != OT_INTEGER_INDEX)
    return FALSE;

  max_val = (1 << operand->size) - 1;
  if (arg->token->u.index > max_val)
    {
      match_out_of_range (arg);
      return FALSE;
    }
  insn_insert_operand (arg->insn, operand, arg->token->u.index);
  ++arg->token;
  return TRUE;
}

/* OP_REG_INDEX matcher.  */

static bfd_boolean
match_reg_index_operand (struct mips_arg_info *arg,
			 const struct mips_operand *operand)
{
  unsigned int regno;

  if (arg->token->type != OT_REG_INDEX)
    return FALSE;

  if (!match_regno (arg, OP_REG_GP, arg->token->u.regno, &regno))
    return FALSE;

  insn_insert_operand (arg->insn, operand, regno);
  ++arg->token;
  return TRUE;
}

/* OP_PC matcher.  */

static bfd_boolean
match_pc_operand (struct mips_arg_info *arg)
{
  if (arg->token->type == OT_REG && (arg->token->u.regno & RTYPE_PC))
    {
      ++arg->token;
      return TRUE;
    }
  return FALSE;
}

/* OP_REPEAT_DEST_REG and OP_REPEAT_PREV_REG matcher.  OTHER_REGNO is the
   register that we need to match.  */

static bfd_boolean
match_tied_reg_operand (struct mips_arg_info *arg, unsigned int other_regno)
{
  unsigned int regno;

  return match_reg (arg, OP_REG_GP, &regno) && regno == other_regno;
}

/* Read a floating-point constant from S for LI.S or LI.D.  LENGTH is
   the length of the value in bytes (4 for float, 8 for double) and
   USING_GPRS says whether the destination is a GPR rather than an FPR.

   Return the constant in IMM and OFFSET as follows:

   - If the constant should be loaded via memory, set IMM to O_absent and
     OFFSET to the memory address.

   - Otherwise, if the constant should be loaded into two 32-bit registers,
     set IMM to the O_constant to load into the high register and OFFSET
     to the corresponding value for the low register.

   - Otherwise, set IMM to the full O_constant and set OFFSET to O_absent.

   These constants only appear as the last operand in an instruction,
   and every instruction that accepts them in any variant accepts them
   in all variants.  This means we don't have to worry about backing out
   any changes if the instruction does not match.  We just match
   unconditionally and report an error if the constant is invalid.  */

static bfd_boolean
match_float_constant (struct mips_arg_info *arg, expressionS *imm,
		      expressionS *offset, int length, bfd_boolean using_gprs)
{
  char *p;
  segT seg, new_seg;
  subsegT subseg;
  const char *newname;
  unsigned char *data;

  /* Where the constant is placed is based on how the MIPS assembler
     does things:

     length == 4 && using_gprs  -- immediate value only
     length == 8 && using_gprs  -- .rdata or immediate value
     length == 4 && !using_gprs -- .lit4 or immediate value
     length == 8 && !using_gprs -- .lit8 or immediate value

     The .lit4 and .lit8 sections are only used if permitted by the
     -G argument.  */
  if (arg->token->type != OT_FLOAT)
    {
      set_insn_error (arg->argnum, _("floating-point expression required"));
      return FALSE;
    }

  gas_assert (arg->token->u.flt.length == length);
  data = arg->token->u.flt.data;
  ++arg->token;

  /* Handle 32-bit constants for which an immediate value is best.  */
  if (length == 4
      && (using_gprs
	  || g_switch_value < 4
	  || (data[0] == 0 && data[1] == 0)
	  || (data[2] == 0 && data[3] == 0)))
    {
      imm->X_op = O_constant;
      if (!target_big_endian)
	imm->X_add_number = bfd_getl32 (data);
      else
	imm->X_add_number = bfd_getb32 (data);
      offset->X_op = O_absent;
      return TRUE;
    }

  /* Handle 64-bit constants for which an immediate value is best.  */
  if (length == 8
      && !mips_disable_float_construction
      /* Constants can only be constructed in GPRs and copied
	 to FPRs if the GPRs are at least as wide as the FPRs.
	 Force the constant into memory if we are using 64-bit FPRs
	 but the GPRs are only 32 bits wide.  */
      /* ??? No longer true with the addition of MTHC1, but this
	 is legacy code...  */
      && (using_gprs || !(HAVE_64BIT_FPRS && HAVE_32BIT_GPRS))
      && ((data[0] == 0 && data[1] == 0)
	  || (data[2] == 0 && data[3] == 0))
      && ((data[4] == 0 && data[5] == 0)
	  || (data[6] == 0 && data[7] == 0)))
    {
      /* The value is simple enough to load with a couple of instructions.
	 If using 32-bit registers, set IMM to the high order 32 bits and
	 OFFSET to the low order 32 bits.  Otherwise, set IMM to the entire
	 64 bit constant.  */
      if (using_gprs ? HAVE_32BIT_GPRS : HAVE_32BIT_FPRS)
	{
	  imm->X_op = O_constant;
	  offset->X_op = O_constant;
	  if (!target_big_endian)
	    {
	      imm->X_add_number = bfd_getl32 (data + 4);
	      offset->X_add_number = bfd_getl32 (data);
	    }
	  else
	    {
	      imm->X_add_number = bfd_getb32 (data);
	      offset->X_add_number = bfd_getb32 (data + 4);
	    }
	  if (offset->X_add_number == 0)
	    offset->X_op = O_absent;
	}
      else
	{
	  imm->X_op = O_constant;
	  if (!target_big_endian)
	    imm->X_add_number = bfd_getl64 (data);
	  else
	    imm->X_add_number = bfd_getb64 (data);
	  offset->X_op = O_absent;
	}
      return TRUE;
    }

  /* Switch to the right section.  */
  seg = now_seg;
  subseg = now_subseg;
  if (length == 4)
    {
      gas_assert (!using_gprs && g_switch_value >= 4);
      newname = ".lit4";
    }
  else
    {
      if (using_gprs || g_switch_value < 8)
	newname = RDATA_SECTION_NAME;
      else
	newname = ".lit8";
    }

  new_seg = subseg_new (newname, (subsegT) 0);
  bfd_set_section_flags (stdoutput, new_seg,
			 SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA);
  frag_align (length == 4 ? 2 : 3, 0, 0);
  if (strncmp (TARGET_OS, "elf", 3) != 0)
    record_alignment (new_seg, 4);
  else
    record_alignment (new_seg, length == 4 ? 2 : 3);
  if (seg == now_seg)
    as_bad (_("cannot use `%s' in this section"), arg->insn->insn_mo->name);

  /* Set the argument to the current address in the section.  */
  imm->X_op = O_absent;
  offset->X_op = O_symbol;
  offset->X_add_symbol = symbol_temp_new_now ();
  offset->X_add_number = 0;

  /* Put the floating point number into the section.  */
  p = frag_more (length);
  memcpy (p, data, length);

  /* Switch back to the original section.  */
  subseg_set (seg, subseg);
  return TRUE;
}

/* OP_VU0_SUFFIX and OP_VU0_MATCH_SUFFIX matcher; MATCH_P selects between
   them.  */

static bfd_boolean
match_vu0_suffix_operand (struct mips_arg_info *arg,
			  const struct mips_operand *operand,
			  bfd_boolean match_p)
{
  unsigned int uval;

  /* The operand can be an XYZW mask or a single 2-bit channel index
     (with X being 0).  */
  gas_assert (operand->size == 2 || operand->size == 4);

  /* The suffix can be omitted when it is already part of the opcode.  */
  if (arg->token->type != OT_CHANNELS)
    return match_p;

  uval = arg->token->u.channels;
  if (operand->size == 2)
    {
      /* Check that a single bit is set and convert it into a 2-bit index.  */
      if ((uval & -uval) != uval)
	return FALSE;
      uval = 4 - ffs (uval);
    }

  if (match_p && insn_extract_operand (arg->insn, operand) != uval)
    return FALSE;

  ++arg->token;
  if (!match_p)
    insn_insert_operand (arg->insn, operand, uval);
  return TRUE;
}

/* S is the text seen for ARG.  Match it against OPERAND.  Return the end
   of the argument text if the match is successful, otherwise return null.  */

static bfd_boolean
match_operand (struct mips_arg_info *arg,
	       const struct mips_operand *operand)
{
  switch (operand->type)
    {
    case OP_INT:
      return match_int_operand (arg, operand);

    case OP_MAPPED_INT:
      return match_mapped_int_operand (arg, operand);

    case OP_MSB:
      return match_msb_operand (arg, operand);

    case OP_REG:
    case OP_OPTIONAL_REG:
      return match_reg_operand (arg, operand);

    case OP_REG_PAIR:
      return match_reg_pair_operand (arg, operand);

    case OP_PCREL:
      return match_pcrel_operand (arg);

    case OP_PERF_REG:
      return match_perf_reg_operand (arg, operand);

    case OP_ADDIUSP_INT:
      return match_addiusp_operand (arg, operand);

    case OP_CLO_CLZ_DEST:
      return match_clo_clz_dest_operand (arg, operand);

    case OP_LWM_SWM_LIST:
      return match_lwm_swm_list_operand (arg, operand);

    case OP_ENTRY_EXIT_LIST:
      return match_entry_exit_operand (arg, operand);

    case OP_SAVE_RESTORE_LIST:
      return match_save_restore_list_operand (arg);

    case OP_MDMX_IMM_REG:
      return match_mdmx_imm_reg_operand (arg, operand);

    case OP_REPEAT_DEST_REG:
      return match_tied_reg_operand (arg, arg->dest_regno);

    case OP_REPEAT_PREV_REG:
      return match_tied_reg_operand (arg, arg->last_regno);

    case OP_PC:
      return match_pc_operand (arg);

    case OP_VU0_SUFFIX:
      return match_vu0_suffix_operand (arg, operand, FALSE);

    case OP_VU0_MATCH_SUFFIX:
      return match_vu0_suffix_operand (arg, operand, TRUE);

    case OP_IMM_INDEX:
      return match_imm_index_operand (arg, operand);

    case OP_REG_INDEX:
      return match_reg_index_operand (arg, operand);
    }
  abort ();
}

/* ARG is the state after successfully matching an instruction.
   Issue any queued-up warnings.  */

static void
check_completed_insn (struct mips_arg_info *arg)
{
  if (arg->seen_at)
    {
      if (AT == ATREG)
	as_warn (_("used $at without \".set noat\""));
      else
	as_warn (_("used $%u with \".set at=$%u\""), AT, AT);
    }
}

/* Return true if modifying general-purpose register REG needs a delay.  */

static bfd_boolean
reg_needs_delay (unsigned int reg)
{
  unsigned long prev_pinfo;

  prev_pinfo = history[0].insn_mo->pinfo;
  if (!mips_opts.noreorder
      && (((prev_pinfo & INSN_LOAD_MEMORY_DELAY) && !gpr_interlocks)
	  || ((prev_pinfo & INSN_LOAD_COPROC_DELAY) && !cop_interlocks))
      && (gpr_write_mask (&history[0]) & (1 << reg)))
    return TRUE;

  return FALSE;
}

/* Classify an instruction according to the FIX_VR4120_* enumeration.
   Return NUM_FIX_VR4120_CLASSES if the instruction isn't affected
   by VR4120 errata.  */

static unsigned int
classify_vr4120_insn (const char *name)
{
  if (strncmp (name, "macc", 4) == 0)
    return FIX_VR4120_MACC;
  if (strncmp (name, "dmacc", 5) == 0)
    return FIX_VR4120_DMACC;
  if (strncmp (name, "mult", 4) == 0)
    return FIX_VR4120_MULT;
  if (strncmp (name, "dmult", 5) == 0)
    return FIX_VR4120_DMULT;
  if (strstr (name, "div"))
    return FIX_VR4120_DIV;
  if (strcmp (name, "mtlo") == 0 || strcmp (name, "mthi") == 0)
    return FIX_VR4120_MTHILO;
  return NUM_FIX_VR4120_CLASSES;
}

#define INSN_ERET  0x42000018
#define INSN_DERET 0x4200001f

/* Return the number of instructions that must separate INSN1 and INSN2,
   where INSN1 is the earlier instruction.  Return the worst-case value
   for any INSN2 if INSN2 is null.  */

static unsigned int
insns_between (const struct mips_cl_insn *insn1,
	       const struct mips_cl_insn *insn2)
{
  unsigned long pinfo1, pinfo2;
  unsigned int mask;

  /* If INFO2 is null, pessimistically assume that all flags are set for
     the second instruction.  */
  pinfo1 = insn1->insn_mo->pinfo;
  pinfo2 = insn2 ? insn2->insn_mo->pinfo : ~0U;

  /* For most targets, write-after-read dependencies on the HI and LO
     registers must be separated by at least two instructions.  */
  if (!hilo_interlocks)
    {
      if ((pinfo1 & INSN_READ_LO) && (pinfo2 & INSN_WRITE_LO))
	return 2;
      if ((pinfo1 & INSN_READ_HI) && (pinfo2 & INSN_WRITE_HI))
	return 2;
    }

  /* If we're working around r7000 errata, there must be two instructions
     between an mfhi or mflo and any instruction that uses the result.  */
  if (mips_7000_hilo_fix
      && !mips_opts.micromips
      && MF_HILO_INSN (pinfo1)
      && (insn2 == NULL || (gpr_read_mask (insn2) & gpr_write_mask (insn1))))
    return 2;

  /* If we're working around 24K errata, one instruction is required
     if an ERET or DERET is followed by a branch instruction.  */
  if (mips_fix_24k && !mips_opts.micromips)
    {
      if (insn1->insn_opcode == INSN_ERET
	  || insn1->insn_opcode == INSN_DERET)
	{
	  if (insn2 == NULL
	      || insn2->insn_opcode == INSN_ERET
	      || insn2->insn_opcode == INSN_DERET
	      || delayed_branch_p (insn2))
	    return 1;
	}
    }

  /* If working around VR4120 errata, check for combinations that need
     a single intervening instruction.  */
  if (mips_fix_vr4120 && !mips_opts.micromips)
    {
      unsigned int class1, class2;

      class1 = classify_vr4120_insn (insn1->insn_mo->name);
      if (class1 != NUM_FIX_VR4120_CLASSES && vr4120_conflicts[class1] != 0)
	{
	  if (insn2 == NULL)
	    return 1;
	  class2 = classify_vr4120_insn (insn2->insn_mo->name);
	  if (vr4120_conflicts[class1] & (1 << class2))
	    return 1;
	}
    }

  if (!HAVE_CODE_COMPRESSION)
    {
      /* Check for GPR or coprocessor load delays.  All such delays
	 are on the RT register.  */
      /* Itbl support may require additional care here.  */
      if ((!gpr_interlocks && (pinfo1 & INSN_LOAD_MEMORY_DELAY))
	  || (!cop_interlocks && (pinfo1 & INSN_LOAD_COPROC_DELAY)))
	{
	  if (insn2 == NULL || (gpr_read_mask (insn2) & gpr_write_mask (insn1)))
	    return 1;
	}

      /* Check for generic coprocessor hazards.

	 This case is not handled very well.  There is no special
	 knowledge of CP0 handling, and the coprocessors other than
	 the floating point unit are not distinguished at all.  */
      /* Itbl support may require additional care here. FIXME!
	 Need to modify this to include knowledge about
	 user specified delays!  */
      else if ((!cop_interlocks && (pinfo1 & INSN_COPROC_MOVE_DELAY))
	       || (!cop_mem_interlocks && (pinfo1 & INSN_COPROC_MEMORY_DELAY)))
	{
	  /* Handle cases where INSN1 writes to a known general coprocessor
	     register.  There must be a one instruction delay before INSN2
	     if INSN2 reads that register, otherwise no delay is needed.  */
	  mask = fpr_write_mask (insn1);
	  if (mask != 0)
	    {
	      if (!insn2 || (mask & fpr_read_mask (insn2)) != 0)
		return 1;
	    }
	  else
	    {
	      /* Read-after-write dependencies on the control registers
		 require a two-instruction gap.  */
	      if ((pinfo1 & INSN_WRITE_COND_CODE)
		  && (pinfo2 & INSN_READ_COND_CODE))
		return 2;

	      /* We don't know exactly what INSN1 does.  If INSN2 is
		 also a coprocessor instruction, assume there must be
		 a one instruction gap.  */
	      if (pinfo2 & INSN_COP)
		return 1;
	    }
	}

      /* Check for read-after-write dependencies on the coprocessor
	 control registers in cases where INSN1 does not need a general
	 coprocessor delay.  This means that INSN1 is a floating point
	 comparison instruction.  */
      /* Itbl support may require additional care here.  */
      else if (!cop_interlocks
	       && (pinfo1 & INSN_WRITE_COND_CODE)
	       && (pinfo2 & INSN_READ_COND_CODE))
	return 1;
    }

  return 0;
}

/* Return the number of nops that would be needed to work around the
   VR4130 mflo/mfhi errata if instruction INSN immediately followed
   the MAX_VR4130_NOPS instructions described by HIST.  Ignore hazards
   that are contained within the first IGNORE instructions of HIST.  */

static int
nops_for_vr4130 (int ignore, const struct mips_cl_insn *hist,
		 const struct mips_cl_insn *insn)
{
  int i, j;
  unsigned int mask;

  /* Check if the instruction writes to HI or LO.  MTHI and MTLO
     are not affected by the errata.  */
  if (insn != 0
      && ((insn->insn_mo->pinfo & (INSN_WRITE_HI | INSN_WRITE_LO)) == 0
	  || strcmp (insn->insn_mo->name, "mtlo") == 0
	  || strcmp (insn->insn_mo->name, "mthi") == 0))
    return 0;

  /* Search for the first MFLO or MFHI.  */
  for (i = 0; i < MAX_VR4130_NOPS; i++)
    if (MF_HILO_INSN (hist[i].insn_mo->pinfo))
      {
	/* Extract the destination register.  */
	mask = gpr_write_mask (&hist[i]);

	/* No nops are needed if INSN reads that register.  */
	if (insn != NULL && (gpr_read_mask (insn) & mask) != 0)
	  return 0;

	/* ...or if any of the intervening instructions do.  */
	for (j = 0; j < i; j++)
	  if (gpr_read_mask (&hist[j]) & mask)
	    return 0;

	if (i >= ignore)
	  return MAX_VR4130_NOPS - i;
      }
  return 0;
}

#define BASE_REG_EQ(INSN1, INSN2) 	\
  ((((INSN1) >> OP_SH_RS) & OP_MASK_RS) \
      == (((INSN2) >> OP_SH_RS) & OP_MASK_RS))

/* Return the minimum alignment for this store instruction.  */

static int
fix_24k_align_to (const struct mips_opcode *mo)
{
  if (strcmp (mo->name, "sh") == 0)
    return 2;

  if (strcmp (mo->name, "swc1") == 0
      || strcmp (mo->name, "swc2") == 0
      || strcmp (mo->name, "sw") == 0
      || strcmp (mo->name, "sc") == 0
      || strcmp (mo->name, "s.s") == 0)
    return 4;

  if (strcmp (mo->name, "sdc1") == 0
      || strcmp (mo->name, "sdc2") == 0
      || strcmp (mo->name, "s.d") == 0)
    return 8;

  /* sb, swl, swr */
  return 1;
}

struct fix_24k_store_info
  {
    /* Immediate offset, if any, for this store instruction.  */
    short off;
    /* Alignment required by this store instruction.  */
    int align_to;
    /* True for register offsets.  */
    int register_offset;
  };

/* Comparison function used by qsort.  */

static int
fix_24k_sort (const void *a, const void *b)
{
  const struct fix_24k_store_info *pos1 = a;
  const struct fix_24k_store_info *pos2 = b;

  return (pos1->off - pos2->off);
}

/* INSN is a store instruction.  Try to record the store information
   in STINFO.  Return false if the information isn't known.  */

static bfd_boolean
fix_24k_record_store_info (struct fix_24k_store_info *stinfo,
			   const struct mips_cl_insn *insn)
{
  /* The instruction must have a known offset.  */
  if (!insn->complete_p || !strstr (insn->insn_mo->args, "o("))
    return FALSE;

  stinfo->off = (insn->insn_opcode >> OP_SH_IMMEDIATE) & OP_MASK_IMMEDIATE;
  stinfo->align_to = fix_24k_align_to (insn->insn_mo);
  return TRUE;
}

/* Return the number of nops that would be needed to work around the 24k
   "lost data on stores during refill" errata if instruction INSN
   immediately followed the 2 instructions described by HIST.
   Ignore hazards that are contained within the first IGNORE
   instructions of HIST.

   Problem: The FSB (fetch store buffer) acts as an intermediate buffer
   for the data cache refills and store data. The following describes
   the scenario where the store data could be lost.

   * A data cache miss, due to either a load or a store, causing fill
     data to be supplied by the memory subsystem
   * The first three doublewords of fill data are returned and written
     into the cache
   * A sequence of four stores occurs in consecutive cycles around the
     final doubleword of the fill:
   * Store A
   * Store B
   * Store C
   * Zero, One or more instructions
   * Store D

   The four stores A-D must be to different doublewords of the line that
   is being filled. The fourth instruction in the sequence above permits
   the fill of the final doubleword to be transferred from the FSB into
   the cache. In the sequence above, the stores may be either integer
   (sb, sh, sw, swr, swl, sc) or coprocessor (swc1/swc2, sdc1/sdc2,
   swxc1, sdxc1, suxc1) stores, as long as the four stores are to
   different doublewords on the line. If the floating point unit is
   running in 1:2 mode, it is not possible to create the sequence above
   using only floating point store instructions.

   In this case, the cache line being filled is incorrectly marked
   invalid, thereby losing the data from any store to the line that
   occurs between the original miss and the completion of the five
   cycle sequence shown above.

   The workarounds are:

   * Run the data cache in write-through mode.
   * Insert a non-store instruction between
     Store A and Store B or Store B and Store C.  */
  
static int
nops_for_24k (int ignore, const struct mips_cl_insn *hist,
	      const struct mips_cl_insn *insn)
{
  struct fix_24k_store_info pos[3];
  int align, i, base_offset;

  if (ignore >= 2)
    return 0;

  /* If the previous instruction wasn't a store, there's nothing to
     worry about.  */
  if ((hist[0].insn_mo->pinfo & INSN_STORE_MEMORY) == 0)
    return 0;

  /* If the instructions after the previous one are unknown, we have
     to assume the worst.  */
  if (!insn)
    return 1;

  /* Check whether we are dealing with three consecutive stores.  */
  if ((insn->insn_mo->pinfo & INSN_STORE_MEMORY) == 0
      || (hist[1].insn_mo->pinfo & INSN_STORE_MEMORY) == 0)
    return 0;

  /* If we don't know the relationship between the store addresses,
     assume the worst.  */
  if (!BASE_REG_EQ (insn->insn_opcode, hist[0].insn_opcode)
      || !BASE_REG_EQ (insn->insn_opcode, hist[1].insn_opcode))
    return 1;

  if (!fix_24k_record_store_info (&pos[0], insn)
      || !fix_24k_record_store_info (&pos[1], &hist[0])
      || !fix_24k_record_store_info (&pos[2], &hist[1]))
    return 1;

  qsort (&pos, 3, sizeof (struct fix_24k_store_info), fix_24k_sort);

  /* Pick a value of ALIGN and X such that all offsets are adjusted by
     X bytes and such that the base register + X is known to be aligned
     to align bytes.  */

  if (((insn->insn_opcode >> OP_SH_RS) & OP_MASK_RS) == SP)
    align = 8;
  else
    {
      align = pos[0].align_to;
      base_offset = pos[0].off;
      for (i = 1; i < 3; i++)
	if (align < pos[i].align_to)
	  {
	    align = pos[i].align_to;
	    base_offset = pos[i].off;
	  }
      for (i = 0; i < 3; i++)
	pos[i].off -= base_offset;
    }

  pos[0].off &= ~align + 1;
  pos[1].off &= ~align + 1;
  pos[2].off &= ~align + 1;

  /* If any two stores write to the same chunk, they also write to the
     same doubleword.  The offsets are still sorted at this point.  */
  if (pos[0].off == pos[1].off || pos[1].off == pos[2].off)
    return 0;

  /* A range of at least 9 bytes is needed for the stores to be in
     non-overlapping doublewords.  */
  if (pos[2].off - pos[0].off <= 8)
    return 0;

  if (pos[2].off - pos[1].off >= 24
      || pos[1].off - pos[0].off >= 24
      || pos[2].off - pos[0].off >= 32)
    return 0;

  return 1;
}

/* Return the number of nops that would be needed if instruction INSN
   immediately followed the MAX_NOPS instructions given by HIST,
   where HIST[0] is the most recent instruction.  Ignore hazards
   between INSN and the first IGNORE instructions in HIST.

   If INSN is null, return the worse-case number of nops for any
   instruction.  */

static int
nops_for_insn (int ignore, const struct mips_cl_insn *hist,
	       const struct mips_cl_insn *insn)
{
  int i, nops, tmp_nops;

  nops = 0;
  for (i = ignore; i < MAX_DELAY_NOPS; i++)
    {
      tmp_nops = insns_between (hist + i, insn) - i;
      if (tmp_nops > nops)
	nops = tmp_nops;
    }

  if (mips_fix_vr4130 && !mips_opts.micromips)
    {
      tmp_nops = nops_for_vr4130 (ignore, hist, insn);
      if (tmp_nops > nops)
	nops = tmp_nops;
    }

  if (mips_fix_24k && !mips_opts.micromips)
    {
      tmp_nops = nops_for_24k (ignore, hist, insn);
      if (tmp_nops > nops)
	nops = tmp_nops;
    }

  return nops;
}

/* The variable arguments provide NUM_INSNS extra instructions that
   might be added to HIST.  Return the largest number of nops that
   would be needed after the extended sequence, ignoring hazards
   in the first IGNORE instructions.  */

static int
nops_for_sequence (int num_insns, int ignore,
		   const struct mips_cl_insn *hist, ...)
{
  va_list args;
  struct mips_cl_insn buffer[MAX_NOPS];
  struct mips_cl_insn *cursor;
  int nops;

  va_start (args, hist);
  cursor = buffer + num_insns;
  memcpy (cursor, hist, (MAX_NOPS - num_insns) * sizeof (*cursor));
  while (cursor > buffer)
    *--cursor = *va_arg (args, const struct mips_cl_insn *);

  nops = nops_for_insn (ignore, buffer, NULL);
  va_end (args);
  return nops;
}

/* Like nops_for_insn, but if INSN is a branch, take into account the
   worst-case delay for the branch target.  */

static int
nops_for_insn_or_target (int ignore, const struct mips_cl_insn *hist,
			 const struct mips_cl_insn *insn)
{
  int nops, tmp_nops;

  nops = nops_for_insn (ignore, hist, insn);
  if (delayed_branch_p (insn))
    {
      tmp_nops = nops_for_sequence (2, ignore ? ignore + 2 : 0,
				    hist, insn, get_delay_slot_nop (insn));
      if (tmp_nops > nops)
	nops = tmp_nops;
    }
  else if (compact_branch_p (insn))
    {
      tmp_nops = nops_for_sequence (1, ignore ? ignore + 1 : 0, hist, insn);
      if (tmp_nops > nops)
	nops = tmp_nops;
    }
  return nops;
}

/* Fix NOP issue: Replace nops by "or at,at,zero".  */

static void
fix_loongson2f_nop (struct mips_cl_insn * ip)
{
  gas_assert (!HAVE_CODE_COMPRESSION);
  if (strcmp (ip->insn_mo->name, "nop") == 0)
    ip->insn_opcode = LOONGSON2F_NOP_INSN;
}

/* Fix Jump Issue: Eliminate instruction fetch from outside 256M region
                   jr target pc &= 'hffff_ffff_cfff_ffff.  */

static void
fix_loongson2f_jump (struct mips_cl_insn * ip)
{
  gas_assert (!HAVE_CODE_COMPRESSION);
  if (strcmp (ip->insn_mo->name, "j") == 0
      || strcmp (ip->insn_mo->name, "jr") == 0
      || strcmp (ip->insn_mo->name, "jalr") == 0)
    {
      int sreg;
      expressionS ep;

      if (! mips_opts.at)
        return;

      sreg = EXTRACT_OPERAND (0, RS, *ip);
      if (sreg == ZERO || sreg == KT0 || sreg == KT1 || sreg == ATREG)
        return;

      ep.X_op = O_constant;
      ep.X_add_number = 0xcfff0000;
      macro_build (&ep, "lui", "t,u", ATREG, BFD_RELOC_HI16);
      ep.X_add_number = 0xffff;
      macro_build (&ep, "ori", "t,r,i", ATREG, ATREG, BFD_RELOC_LO16);
      macro_build (NULL, "and", "d,v,t", sreg, sreg, ATREG);
    }
}

static void
fix_loongson2f (struct mips_cl_insn * ip)
{
  if (mips_fix_loongson2f_nop)
    fix_loongson2f_nop (ip);

  if (mips_fix_loongson2f_jump)
    fix_loongson2f_jump (ip);
}

/* IP is a branch that has a delay slot, and we need to fill it
   automatically.   Return true if we can do that by swapping IP
   with the previous instruction.
   ADDRESS_EXPR is an operand of the instruction to be used with
   RELOC_TYPE.  */

static bfd_boolean
can_swap_branch_p (struct mips_cl_insn *ip, expressionS *address_expr,
		   bfd_reloc_code_real_type *reloc_type)
{
  unsigned long pinfo, pinfo2, prev_pinfo, prev_pinfo2;
  unsigned int gpr_read, gpr_write, prev_gpr_read, prev_gpr_write;
  unsigned int fpr_read, prev_fpr_write;

  /* -O2 and above is required for this optimization.  */
  if (mips_optimize < 2)
    return FALSE;

  /* If we have seen .set volatile or .set nomove, don't optimize.  */
  if (mips_opts.nomove)
    return FALSE;

  /* We can't swap if the previous instruction's position is fixed.  */
  if (history[0].fixed_p)
    return FALSE;

  /* If the previous previous insn was in a .set noreorder, we can't
     swap.  Actually, the MIPS assembler will swap in this situation.
     However, gcc configured -with-gnu-as will generate code like

	.set	noreorder
	lw	$4,XXX
	.set	reorder
	INSN
	bne	$4,$0,foo

     in which we can not swap the bne and INSN.  If gcc is not configured
     -with-gnu-as, it does not output the .set pseudo-ops.  */
  if (history[1].noreorder_p)
    return FALSE;

  /* If the previous instruction had a fixup in mips16 mode, we can not swap.
     This means that the previous instruction was a 4-byte one anyhow.  */
  if (mips_opts.mips16 && history[0].fixp[0])
    return FALSE;

  /* If the branch is itself the target of a branch, we can not swap.
     We cheat on this; all we check for is whether there is a label on
     this instruction.  If there are any branches to anything other than
     a label, users must use .set noreorder.  */
  if (seg_info (now_seg)->label_list)
    return FALSE;

  /* If the previous instruction is in a variant frag other than this
     branch's one, we cannot do the swap.  This does not apply to
     MIPS16 code, which uses variant frags for different purposes.  */
  if (!mips_opts.mips16
      && history[0].frag
      && history[0].frag->fr_type == rs_machine_dependent)
    return FALSE;

  /* We do not swap with instructions that cannot architecturally
     be placed in a branch delay slot, such as SYNC or ERET.  We
     also refrain from swapping with a trap instruction, since it
     complicates trap handlers to have the trap instruction be in
     a delay slot.  */
  prev_pinfo = history[0].insn_mo->pinfo;
  if (prev_pinfo & INSN_NO_DELAY_SLOT)
    return FALSE;

  /* Check for conflicts between the branch and the instructions
     before the candidate delay slot.  */
  if (nops_for_insn (0, history + 1, ip) > 0)
    return FALSE;

  /* Check for conflicts between the swapped sequence and the
     target of the branch.  */
  if (nops_for_sequence (2, 0, history + 1, ip, history) > 0)
    return FALSE;

  /* If the branch reads a register that the previous
     instruction sets, we can not swap.  */
  gpr_read = gpr_read_mask (ip);
  prev_gpr_write = gpr_write_mask (&history[0]);
  if (gpr_read & prev_gpr_write)
    return FALSE;

  fpr_read = fpr_read_mask (ip);
  prev_fpr_write = fpr_write_mask (&history[0]);
  if (fpr_read & prev_fpr_write)
    return FALSE;

  /* If the branch writes a register that the previous
     instruction sets, we can not swap.  */
  gpr_write = gpr_write_mask (ip);
  if (gpr_write & prev_gpr_write)
    return FALSE;

  /* If the branch writes a register that the previous
     instruction reads, we can not swap.  */
  prev_gpr_read = gpr_read_mask (&history[0]);
  if (gpr_write & prev_gpr_read)
    return FALSE;

  /* If one instruction sets a condition code and the
     other one uses a condition code, we can not swap.  */
  pinfo = ip->insn_mo->pinfo;
  if ((pinfo & INSN_READ_COND_CODE)
      && (prev_pinfo & INSN_WRITE_COND_CODE))
    return FALSE;
  if ((pinfo & INSN_WRITE_COND_CODE)
      && (prev_pinfo & INSN_READ_COND_CODE))
    return FALSE;

  /* If the previous instruction uses the PC, we can not swap.  */
  prev_pinfo2 = history[0].insn_mo->pinfo2;
  if (prev_pinfo2 & INSN2_READ_PC)
    return FALSE;

  /* If the previous instruction has an incorrect size for a fixed
     branch delay slot in microMIPS mode, we cannot swap.  */
  pinfo2 = ip->insn_mo->pinfo2;
  if (mips_opts.micromips
      && (pinfo2 & INSN2_BRANCH_DELAY_16BIT)
      && insn_length (history) != 2)
    return FALSE;
  if (mips_opts.micromips
      && (pinfo2 & INSN2_BRANCH_DELAY_32BIT)
      && insn_length (history) != 4)
    return FALSE;

  /* On R5900 short loops need to be fixed by inserting a nop in
     the branch delay slots.
     A short loop can be terminated too early.  */
  if (mips_opts.arch == CPU_R5900
      /* Check if instruction has a parameter, ignore "j $31". */
      && (address_expr != NULL)
      /* Parameter must be 16 bit. */
      && (*reloc_type == BFD_RELOC_16_PCREL_S2)
      /* Branch to same segment. */
      && (S_GET_SEGMENT(address_expr->X_add_symbol) == now_seg)
      /* Branch to same code fragment. */
      && (symbol_get_frag(address_expr->X_add_symbol) == frag_now)
      /* Can only calculate branch offset if value is known. */
      && symbol_constant_p(address_expr->X_add_symbol)
      /* Check if branch is really conditional. */
      && !((ip->insn_opcode & 0xffff0000) == 0x10000000   /* beq $0,$0 */
	|| (ip->insn_opcode & 0xffff0000) == 0x04010000   /* bgez $0 */
	|| (ip->insn_opcode & 0xffff0000) == 0x04110000)) /* bgezal $0 */
    {
      int distance;
      /* Check if loop is shorter than 6 instructions including
         branch and delay slot.  */
      distance = frag_now_fix() - S_GET_VALUE(address_expr->X_add_symbol);
      if (distance <= 20)
        {
          int i;
          int rv;

          rv = FALSE;
          /* When the loop includes branches or jumps,
             it is not a short loop. */
          for (i = 0; i < (distance / 4); i++)
            {
              if ((history[i].cleared_p)
                  || delayed_branch_p(&history[i]))
                {
                  rv = TRUE;
                  break;
                }
            }
          if (rv == FALSE)
            {
              /* Insert nop after branch to fix short loop. */
              return FALSE;
            }
        }
    }

  return TRUE;
}

/* Decide how we should add IP to the instruction stream.
   ADDRESS_EXPR is an operand of the instruction to be used with
   RELOC_TYPE.  */

static enum append_method
get_append_method (struct mips_cl_insn *ip, expressionS *address_expr,
		   bfd_reloc_code_real_type *reloc_type)
{
  /* The relaxed version of a macro sequence must be inherently
     hazard-free.  */
  if (mips_relax.sequence == 2)
    return APPEND_ADD;

  /* We must not dabble with instructions in a ".set norerorder" block.  */
  if (mips_opts.noreorder)
    return APPEND_ADD;

  /* Otherwise, it's our responsibility to fill branch delay slots.  */
  if (delayed_branch_p (ip))
    {
      if (!branch_likely_p (ip)
	  && can_swap_branch_p (ip, address_expr, reloc_type))
	return APPEND_SWAP;

      if (mips_opts.mips16
	  && ISA_SUPPORTS_MIPS16E
	  && gpr_read_mask (ip) != 0)
	return APPEND_ADD_COMPACT;

      return APPEND_ADD_WITH_NOP;
    }

  return APPEND_ADD;
}

/* IP is a MIPS16 instruction whose opcode we have just changed.
   Point IP->insn_mo to the new opcode's definition.  */

static void
find_altered_mips16_opcode (struct mips_cl_insn *ip)
{
  const struct mips_opcode *mo, *end;

  end = &mips16_opcodes[bfd_mips16_num_opcodes];
  for (mo = ip->insn_mo; mo < end; mo++)
    if ((ip->insn_opcode & mo->mask) == mo->match)
      {
	ip->insn_mo = mo;
	return;
      }
  abort ();
}

/* For microMIPS macros, we need to generate a local number label
   as the target of branches.  */
#define MICROMIPS_LABEL_CHAR		'\037'
static unsigned long micromips_target_label;
static char micromips_target_name[32];

static char *
micromips_label_name (void)
{
  char *p = micromips_target_name;
  char symbol_name_temporary[24];
  unsigned long l;
  int i;

  if (*p)
    return p;

  i = 0;
  l = micromips_target_label;
#ifdef LOCAL_LABEL_PREFIX
  *p++ = LOCAL_LABEL_PREFIX;
#endif
  *p++ = 'L';
  *p++ = MICROMIPS_LABEL_CHAR;
  do
    {
      symbol_name_temporary[i++] = l % 10 + '0';
      l /= 10;
    }
  while (l != 0);
  while (i > 0)
    *p++ = symbol_name_temporary[--i];
  *p = '\0';

  return micromips_target_name;
}

static void
micromips_label_expr (expressionS *label_expr)
{
  label_expr->X_op = O_symbol;
  label_expr->X_add_symbol = symbol_find_or_make (micromips_label_name ());
  label_expr->X_add_number = 0;
}

static void
micromips_label_inc (void)
{
  micromips_target_label++;
  *micromips_target_name = '\0';
}

static void
micromips_add_label (void)
{
  symbolS *s;

  s = colon (micromips_label_name ());
  micromips_label_inc ();
  S_SET_OTHER (s, ELF_ST_SET_MICROMIPS (S_GET_OTHER (s)));
}

/* If assembling microMIPS code, then return the microMIPS reloc
   corresponding to the requested one if any.  Otherwise return
   the reloc unchanged.  */

static bfd_reloc_code_real_type
micromips_map_reloc (bfd_reloc_code_real_type reloc)
{
  static const bfd_reloc_code_real_type relocs[][2] =
    {
      /* Keep sorted incrementally by the left-hand key.  */
      { BFD_RELOC_16_PCREL_S2, BFD_RELOC_MICROMIPS_16_PCREL_S1 },
      { BFD_RELOC_GPREL16, BFD_RELOC_MICROMIPS_GPREL16 },
      { BFD_RELOC_MIPS_JMP, BFD_RELOC_MICROMIPS_JMP },
      { BFD_RELOC_HI16, BFD_RELOC_MICROMIPS_HI16 },
      { BFD_RELOC_HI16_S, BFD_RELOC_MICROMIPS_HI16_S },
      { BFD_RELOC_LO16, BFD_RELOC_MICROMIPS_LO16 },
      { BFD_RELOC_MIPS_LITERAL, BFD_RELOC_MICROMIPS_LITERAL },
      { BFD_RELOC_MIPS_GOT16, BFD_RELOC_MICROMIPS_GOT16 },
      { BFD_RELOC_MIPS_CALL16, BFD_RELOC_MICROMIPS_CALL16 },
      { BFD_RELOC_MIPS_GOT_HI16, BFD_RELOC_MICROMIPS_GOT_HI16 },
      { BFD_RELOC_MIPS_GOT_LO16, BFD_RELOC_MICROMIPS_GOT_LO16 },
      { BFD_RELOC_MIPS_CALL_HI16, BFD_RELOC_MICROMIPS_CALL_HI16 },
      { BFD_RELOC_MIPS_CALL_LO16, BFD_RELOC_MICROMIPS_CALL_LO16 },
      { BFD_RELOC_MIPS_SUB, BFD_RELOC_MICROMIPS_SUB },
      { BFD_RELOC_MIPS_GOT_PAGE, BFD_RELOC_MICROMIPS_GOT_PAGE },
      { BFD_RELOC_MIPS_GOT_OFST, BFD_RELOC_MICROMIPS_GOT_OFST },
      { BFD_RELOC_MIPS_GOT_DISP, BFD_RELOC_MICROMIPS_GOT_DISP },
      { BFD_RELOC_MIPS_HIGHEST, BFD_RELOC_MICROMIPS_HIGHEST },
      { BFD_RELOC_MIPS_HIGHER, BFD_RELOC_MICROMIPS_HIGHER },
      { BFD_RELOC_MIPS_SCN_DISP, BFD_RELOC_MICROMIPS_SCN_DISP },
      { BFD_RELOC_MIPS_TLS_GD, BFD_RELOC_MICROMIPS_TLS_GD },
      { BFD_RELOC_MIPS_TLS_LDM, BFD_RELOC_MICROMIPS_TLS_LDM },
      { BFD_RELOC_MIPS_TLS_DTPREL_HI16, BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16 },
      { BFD_RELOC_MIPS_TLS_DTPREL_LO16, BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16 },
      { BFD_RELOC_MIPS_TLS_GOTTPREL, BFD_RELOC_MICROMIPS_TLS_GOTTPREL },
      { BFD_RELOC_MIPS_TLS_TPREL_HI16, BFD_RELOC_MICROMIPS_TLS_TPREL_HI16 },
      { BFD_RELOC_MIPS_TLS_TPREL_LO16, BFD_RELOC_MICROMIPS_TLS_TPREL_LO16 }
    };
  bfd_reloc_code_real_type r;
  size_t i;

  if (!mips_opts.micromips)
    return reloc;
  for (i = 0; i < ARRAY_SIZE (relocs); i++)
    {
      r = relocs[i][0];
      if (r > reloc)
	return reloc;
      if (r == reloc)
	return relocs[i][1];
    }
  return reloc;
}

/* Try to resolve relocation RELOC against constant OPERAND at assembly time.
   Return true on success, storing the resolved value in RESULT.  */

static bfd_boolean
calculate_reloc (bfd_reloc_code_real_type reloc, offsetT operand,
		 offsetT *result)
{
  switch (reloc)
    {
    case BFD_RELOC_MIPS_HIGHEST:
    case BFD_RELOC_MICROMIPS_HIGHEST:
      *result = ((operand + 0x800080008000ull) >> 48) & 0xffff;
      return TRUE;

    case BFD_RELOC_MIPS_HIGHER:
    case BFD_RELOC_MICROMIPS_HIGHER:
      *result = ((operand + 0x80008000ull) >> 32) & 0xffff;
      return TRUE;

    case BFD_RELOC_HI16_S:
    case BFD_RELOC_MICROMIPS_HI16_S:
    case BFD_RELOC_MIPS16_HI16_S:
      *result = ((operand + 0x8000) >> 16) & 0xffff;
      return TRUE;

    case BFD_RELOC_HI16:
    case BFD_RELOC_MICROMIPS_HI16:
    case BFD_RELOC_MIPS16_HI16:
      *result = (operand >> 16) & 0xffff;
      return TRUE;

    case BFD_RELOC_LO16:
    case BFD_RELOC_MICROMIPS_LO16:
    case BFD_RELOC_MIPS16_LO16:
      *result = operand & 0xffff;
      return TRUE;

    case BFD_RELOC_UNUSED:
      *result = operand;
      return TRUE;

    default:
      return FALSE;
    }
}

/* Output an instruction.  IP is the instruction information.
   ADDRESS_EXPR is an operand of the instruction to be used with
   RELOC_TYPE.  EXPANSIONP is true if the instruction is part of
   a macro expansion.  */

static void
append_insn (struct mips_cl_insn *ip, expressionS *address_expr,
	     bfd_reloc_code_real_type *reloc_type, bfd_boolean expansionp)
{
  unsigned long prev_pinfo2, pinfo;
  bfd_boolean relaxed_branch = FALSE;
  enum append_method method;
  bfd_boolean relax32;
  int branch_disp;

  if (mips_fix_loongson2f && !HAVE_CODE_COMPRESSION)
    fix_loongson2f (ip);

  file_ase_mips16 |= mips_opts.mips16;
  file_ase_micromips |= mips_opts.micromips;

  prev_pinfo2 = history[0].insn_mo->pinfo2;
  pinfo = ip->insn_mo->pinfo;

  if (mips_opts.micromips
      && !expansionp
      && (((prev_pinfo2 & INSN2_BRANCH_DELAY_16BIT) != 0
	   && micromips_insn_length (ip->insn_mo) != 2)
	  || ((prev_pinfo2 & INSN2_BRANCH_DELAY_32BIT) != 0
	      && micromips_insn_length (ip->insn_mo) != 4)))
    as_warn (_("wrong size instruction in a %u-bit branch delay slot"),
	     (prev_pinfo2 & INSN2_BRANCH_DELAY_16BIT) != 0 ? 16 : 32);

  if (address_expr == NULL)
    ip->complete_p = 1;
  else if (reloc_type[0] <= BFD_RELOC_UNUSED
	   && reloc_type[1] == BFD_RELOC_UNUSED
	   && reloc_type[2] == BFD_RELOC_UNUSED
	   && address_expr->X_op == O_constant)
    {
      switch (*reloc_type)
	{
	case BFD_RELOC_MIPS_JMP:
	  {
	    int shift;

	    shift = mips_opts.micromips ? 1 : 2;
	    if ((address_expr->X_add_number & ((1 << shift) - 1)) != 0)
	      as_bad (_("jump to misaligned address (0x%lx)"),
		      (unsigned long) address_expr->X_add_number);
	    ip->insn_opcode |= ((address_expr->X_add_number >> shift)
				& 0x3ffffff);
	    ip->complete_p = 1;
	  }
	  break;

	case BFD_RELOC_MIPS16_JMP:
	  if ((address_expr->X_add_number & 3) != 0)
	    as_bad (_("jump to misaligned address (0x%lx)"),
	            (unsigned long) address_expr->X_add_number);
	  ip->insn_opcode |=
	    (((address_expr->X_add_number & 0x7c0000) << 3)
	       | ((address_expr->X_add_number & 0xf800000) >> 7)
	       | ((address_expr->X_add_number & 0x3fffc) >> 2));
	  ip->complete_p = 1;
	  break;

	case BFD_RELOC_16_PCREL_S2:
	  {
	    int shift;

	    shift = mips_opts.micromips ? 1 : 2;
	    if ((address_expr->X_add_number & ((1 << shift) - 1)) != 0)
	      as_bad (_("branch to misaligned address (0x%lx)"),
		      (unsigned long) address_expr->X_add_number);
	    if (!mips_relax_branch)
	      {
		if ((address_expr->X_add_number + (1 << (shift + 15)))
		    & ~((1 << (shift + 16)) - 1))
		  as_bad (_("branch address range overflow (0x%lx)"),
			  (unsigned long) address_expr->X_add_number);
		ip->insn_opcode |= ((address_expr->X_add_number >> shift)
				    & 0xffff);
	      }
	  }
	  break;

	default:
	  {
	    offsetT value;

	    if (calculate_reloc (*reloc_type, address_expr->X_add_number,
				 &value))
	      {
		ip->insn_opcode |= value & 0xffff;
		ip->complete_p = 1;
	      }
	  }
	  break;
	}
    }

  if (mips_relax.sequence != 2 && !mips_opts.noreorder)
    {
      /* There are a lot of optimizations we could do that we don't.
	 In particular, we do not, in general, reorder instructions.
	 If you use gcc with optimization, it will reorder
	 instructions and generally do much more optimization then we
	 do here; repeating all that work in the assembler would only
	 benefit hand written assembly code, and does not seem worth
	 it.  */
      int nops = (mips_optimize == 0
		  ? nops_for_insn (0, history, NULL)
		  : nops_for_insn_or_target (0, history, ip));
      if (nops > 0)
	{
	  fragS *old_frag;
	  unsigned long old_frag_offset;
	  int i;

	  old_frag = frag_now;
	  old_frag_offset = frag_now_fix ();

	  for (i = 0; i < nops; i++)
	    add_fixed_insn (NOP_INSN);
	  insert_into_history (0, nops, NOP_INSN);

	  if (listing)
	    {
	      listing_prev_line ();
	      /* We may be at the start of a variant frag.  In case we
                 are, make sure there is enough space for the frag
                 after the frags created by listing_prev_line.  The
                 argument to frag_grow here must be at least as large
                 as the argument to all other calls to frag_grow in
                 this file.  We don't have to worry about being in the
                 middle of a variant frag, because the variants insert
                 all needed nop instructions themselves.  */
	      frag_grow (40);
	    }

	  mips_move_text_labels ();

#ifndef NO_ECOFF_DEBUGGING
	  if (ECOFF_DEBUGGING)
	    ecoff_fix_loc (old_frag, old_frag_offset);
#endif
	}
    }
  else if (mips_relax.sequence != 2 && prev_nop_frag != NULL)
    {
      int nops;

      /* Work out how many nops in prev_nop_frag are needed by IP,
	 ignoring hazards generated by the first prev_nop_frag_since
	 instructions.  */
      nops = nops_for_insn_or_target (prev_nop_frag_since, history, ip);
      gas_assert (nops <= prev_nop_frag_holds);

      /* Enforce NOPS as a minimum.  */
      if (nops > prev_nop_frag_required)
	prev_nop_frag_required = nops;

      if (prev_nop_frag_holds == prev_nop_frag_required)
	{
	  /* Settle for the current number of nops.  Update the history
	     accordingly (for the benefit of any future .set reorder code).  */
	  prev_nop_frag = NULL;
	  insert_into_history (prev_nop_frag_since,
			       prev_nop_frag_holds, NOP_INSN);
	}
      else
	{
	  /* Allow this instruction to replace one of the nops that was
	     tentatively added to prev_nop_frag.  */
	  prev_nop_frag->fr_fix -= NOP_INSN_SIZE;
	  prev_nop_frag_holds--;
	  prev_nop_frag_since++;
	}
    }

  method = get_append_method (ip, address_expr, reloc_type);
  branch_disp = method == APPEND_SWAP ? insn_length (history) : 0;

  dwarf2_emit_insn (0);
  /* We want MIPS16 and microMIPS debug info to use ISA-encoded addresses,
     so "move" the instruction address accordingly.

     Also, it doesn't seem appropriate for the assembler to reorder .loc
     entries.  If this instruction is a branch that we are going to swap
     with the previous instruction, the two instructions should be
     treated as a unit, and the debug information for both instructions
     should refer to the start of the branch sequence.  Using the
     current position is certainly wrong when swapping a 32-bit branch
     and a 16-bit delay slot, since the current position would then be
     in the middle of a branch.  */
  dwarf2_move_insn ((HAVE_CODE_COMPRESSION ? 1 : 0) - branch_disp);

  relax32 = (mips_relax_branch
	     /* Don't try branch relaxation within .set nomacro, or within
	        .set noat if we use $at for PIC computations.  If it turns
	        out that the branch was out-of-range, we'll get an error.  */
	     && !mips_opts.warn_about_macros
	     && (mips_opts.at || mips_pic == NO_PIC)
	     /* Don't relax BPOSGE32/64 or BC1ANY2T/F and BC1ANY4T/F
	        as they have no complementing branches.  */
	     && !(ip->insn_mo->ase & (ASE_MIPS3D | ASE_DSP64 | ASE_DSP)));

  if (!HAVE_CODE_COMPRESSION
      && address_expr
      && relax32
      && *reloc_type == BFD_RELOC_16_PCREL_S2
      && delayed_branch_p (ip))
    {
      relaxed_branch = TRUE;
      add_relaxed_insn (ip, (relaxed_branch_length
			     (NULL, NULL,
			      uncond_branch_p (ip) ? -1
			      : branch_likely_p (ip) ? 1
			      : 0)), 4,
			RELAX_BRANCH_ENCODE
			(AT,
			 uncond_branch_p (ip),
			 branch_likely_p (ip),
			 pinfo & INSN_WRITE_GPR_31,
			 0),
			address_expr->X_add_symbol,
			address_expr->X_add_number);
      *reloc_type = BFD_RELOC_UNUSED;
    }
  else if (mips_opts.micromips
	   && address_expr
	   && ((relax32 && *reloc_type == BFD_RELOC_16_PCREL_S2)
	       || *reloc_type > BFD_RELOC_UNUSED)
	   && (delayed_branch_p (ip) || compact_branch_p (ip))
	   /* Don't try branch relaxation when users specify
	      16-bit/32-bit instructions.  */
	   && !forced_insn_length)
    {
      bfd_boolean relax16 = *reloc_type > BFD_RELOC_UNUSED;
      int type = relax16 ? *reloc_type - BFD_RELOC_UNUSED : 0;
      int uncond = uncond_branch_p (ip) ? -1 : 0;
      int compact = compact_branch_p (ip);
      int al = pinfo & INSN_WRITE_GPR_31;
      int length32;

      gas_assert (address_expr != NULL);
      gas_assert (!mips_relax.sequence);

      relaxed_branch = TRUE;
      length32 = relaxed_micromips_32bit_branch_length (NULL, NULL, uncond);
      add_relaxed_insn (ip, relax32 ? length32 : 4, relax16 ? 2 : 4,
			RELAX_MICROMIPS_ENCODE (type, AT, uncond, compact, al,
						relax32, 0, 0),
			address_expr->X_add_symbol,
			address_expr->X_add_number);
      *reloc_type = BFD_RELOC_UNUSED;
    }
  else if (mips_opts.mips16 && *reloc_type > BFD_RELOC_UNUSED)
    {
      /* We need to set up a variant frag.  */
      gas_assert (address_expr != NULL);
      add_relaxed_insn (ip, 4, 0,
			RELAX_MIPS16_ENCODE
			(*reloc_type - BFD_RELOC_UNUSED,
			 forced_insn_length == 2, forced_insn_length == 4,
			 delayed_branch_p (&history[0]),
			 history[0].mips16_absolute_jump_p),
			make_expr_symbol (address_expr), 0);
    }
  else if (mips_opts.mips16 && insn_length (ip) == 2)
    {
      if (!delayed_branch_p (ip))
	/* Make sure there is enough room to swap this instruction with
	   a following jump instruction.  */
	frag_grow (6);
      add_fixed_insn (ip);
    }
  else
    {
      if (mips_opts.mips16
	  && mips_opts.noreorder
	  && delayed_branch_p (&history[0]))
	as_warn (_("extended instruction in delay slot"));

      if (mips_relax.sequence)
	{
	  /* If we've reached the end of this frag, turn it into a variant
	     frag and record the information for the instructions we've
	     written so far.  */
	  if (frag_room () < 4)
	    relax_close_frag ();
	  mips_relax.sizes[mips_relax.sequence - 1] += insn_length (ip);
	}

      if (mips_relax.sequence != 2)
	{
	  if (mips_macro_warning.first_insn_sizes[0] == 0)
	    mips_macro_warning.first_insn_sizes[0] = insn_length (ip);
	  mips_macro_warning.sizes[0] += insn_length (ip);
	  mips_macro_warning.insns[0]++;
	}
      if (mips_relax.sequence != 1)
	{
	  if (mips_macro_warning.first_insn_sizes[1] == 0)
	    mips_macro_warning.first_insn_sizes[1] = insn_length (ip);
	  mips_macro_warning.sizes[1] += insn_length (ip);
	  mips_macro_warning.insns[1]++;
	}

      if (mips_opts.mips16)
	{
	  ip->fixed_p = 1;
	  ip->mips16_absolute_jump_p = (*reloc_type == BFD_RELOC_MIPS16_JMP);
	}
      add_fixed_insn (ip);
    }

  if (!ip->complete_p && *reloc_type < BFD_RELOC_UNUSED)
    {
      bfd_reloc_code_real_type final_type[3];
      reloc_howto_type *howto0;
      reloc_howto_type *howto;
      int i;

      /* Perform any necessary conversion to microMIPS relocations
	 and find out how many relocations there actually are.  */
      for (i = 0; i < 3 && reloc_type[i] != BFD_RELOC_UNUSED; i++)
	final_type[i] = micromips_map_reloc (reloc_type[i]);

      /* In a compound relocation, it is the final (outermost)
	 operator that determines the relocated field.  */
      howto = howto0 = bfd_reloc_type_lookup (stdoutput, final_type[i - 1]);
      if (!howto)
	abort ();

      if (i > 1)
	howto0 = bfd_reloc_type_lookup (stdoutput, final_type[0]);
      ip->fixp[0] = fix_new_exp (ip->frag, ip->where,
				 bfd_get_reloc_size (howto),
				 address_expr,
				 howto0 && howto0->pc_relative,
				 final_type[0]);

      /* Tag symbols that have a R_MIPS16_26 relocation against them.  */
      if (final_type[0] == BFD_RELOC_MIPS16_JMP && ip->fixp[0]->fx_addsy)
	*symbol_get_tc (ip->fixp[0]->fx_addsy) = 1;

      /* These relocations can have an addend that won't fit in
	 4 octets for 64bit assembly.  */
      if (HAVE_64BIT_GPRS
	  && ! howto->partial_inplace
	  && (reloc_type[0] == BFD_RELOC_16
	      || reloc_type[0] == BFD_RELOC_32
	      || reloc_type[0] == BFD_RELOC_MIPS_JMP
	      || reloc_type[0] == BFD_RELOC_GPREL16
	      || reloc_type[0] == BFD_RELOC_MIPS_LITERAL
	      || reloc_type[0] == BFD_RELOC_GPREL32
	      || reloc_type[0] == BFD_RELOC_64
	      || reloc_type[0] == BFD_RELOC_CTOR
	      || reloc_type[0] == BFD_RELOC_MIPS_SUB
	      || reloc_type[0] == BFD_RELOC_MIPS_HIGHEST
	      || reloc_type[0] == BFD_RELOC_MIPS_HIGHER
	      || reloc_type[0] == BFD_RELOC_MIPS_SCN_DISP
	      || reloc_type[0] == BFD_RELOC_MIPS_REL16
	      || reloc_type[0] == BFD_RELOC_MIPS_RELGOT
	      || reloc_type[0] == BFD_RELOC_MIPS16_GPREL
	      || hi16_reloc_p (reloc_type[0])
	      || lo16_reloc_p (reloc_type[0])))
	ip->fixp[0]->fx_no_overflow = 1;

      /* These relocations can have an addend that won't fit in 2 octets.  */
      if (reloc_type[0] == BFD_RELOC_MICROMIPS_7_PCREL_S1
	  || reloc_type[0] == BFD_RELOC_MICROMIPS_10_PCREL_S1)
	ip->fixp[0]->fx_no_overflow = 1;

      if (mips_relax.sequence)
	{
	  if (mips_relax.first_fixup == 0)
	    mips_relax.first_fixup = ip->fixp[0];
	}
      else if (reloc_needs_lo_p (*reloc_type))
	{
	  struct mips_hi_fixup *hi_fixup;

	  /* Reuse the last entry if it already has a matching %lo.  */
	  hi_fixup = mips_hi_fixup_list;
	  if (hi_fixup == 0
	      || !fixup_has_matching_lo_p (hi_fixup->fixp))
	    {
	      hi_fixup = ((struct mips_hi_fixup *)
			  xmalloc (sizeof (struct mips_hi_fixup)));
	      hi_fixup->next = mips_hi_fixup_list;
	      mips_hi_fixup_list = hi_fixup;
	    }
	  hi_fixup->fixp = ip->fixp[0];
	  hi_fixup->seg = now_seg;
	}

      /* Add fixups for the second and third relocations, if given.
	 Note that the ABI allows the second relocation to be
	 against RSS_UNDEF, RSS_GP, RSS_GP0 or RSS_LOC.  At the
	 moment we only use RSS_UNDEF, but we could add support
	 for the others if it ever becomes necessary.  */
      for (i = 1; i < 3; i++)
	if (reloc_type[i] != BFD_RELOC_UNUSED)
	  {
	    ip->fixp[i] = fix_new (ip->frag, ip->where,
				   ip->fixp[0]->fx_size, NULL, 0,
				   FALSE, final_type[i]);

	    /* Use fx_tcbit to mark compound relocs.  */
	    ip->fixp[0]->fx_tcbit = 1;
	    ip->fixp[i]->fx_tcbit = 1;
	  }
    }
  install_insn (ip);

  /* Update the register mask information.  */
  mips_gprmask |= gpr_read_mask (ip) | gpr_write_mask (ip);
  mips_cprmask[1] |= fpr_read_mask (ip) | fpr_write_mask (ip);

  switch (method)
    {
    case APPEND_ADD:
      insert_into_history (0, 1, ip);
      break;

    case APPEND_ADD_WITH_NOP:
      {
	struct mips_cl_insn *nop;

	insert_into_history (0, 1, ip);
	nop = get_delay_slot_nop (ip);
	add_fixed_insn (nop);
	insert_into_history (0, 1, nop);
	if (mips_relax.sequence)
	  mips_relax.sizes[mips_relax.sequence - 1] += insn_length (nop);
      }
      break;

    case APPEND_ADD_COMPACT:
      /* Convert MIPS16 jr/jalr into a "compact" jump.  */
      gas_assert (mips_opts.mips16);
      ip->insn_opcode |= 0x0080;
      find_altered_mips16_opcode (ip);
      install_insn (ip);
      insert_into_history (0, 1, ip);
      break;

    case APPEND_SWAP:
      {
	struct mips_cl_insn delay = history[0];
	if (mips_opts.mips16)
	  {
	    know (delay.frag == ip->frag);
	    move_insn (ip, delay.frag, delay.where);
	    move_insn (&delay, ip->frag, ip->where + insn_length (ip));
	  }
	else if (relaxed_branch || delay.frag != ip->frag)
	  {
	    /* Add the delay slot instruction to the end of the
	       current frag and shrink the fixed part of the
	       original frag.  If the branch occupies the tail of
	       the latter, move it backwards to cover the gap.  */
	    delay.frag->fr_fix -= branch_disp;
	    if (delay.frag == ip->frag)
	      move_insn (ip, ip->frag, ip->where - branch_disp);
	    add_fixed_insn (&delay);
	  }
	else
	  {
	    move_insn (&delay, ip->frag,
		       ip->where - branch_disp + insn_length (ip));
	    move_insn (ip, history[0].frag, history[0].where);
	  }
	history[0] = *ip;
	delay.fixed_p = 1;
	insert_into_history (0, 1, &delay);
      }
      break;
    }

  /* If we have just completed an unconditional branch, clear the history.  */
  if ((delayed_branch_p (&history[1]) && uncond_branch_p (&history[1]))
      || (compact_branch_p (&history[0]) && uncond_branch_p (&history[0])))
    {
      unsigned int i;

      mips_no_prev_insn ();

      for (i = 0; i < ARRAY_SIZE (history); i++)
	history[i].cleared_p = 1;
    }

  /* We need to emit a label at the end of branch-likely macros.  */
  if (emit_branch_likely_macro)
    {
      emit_branch_likely_macro = FALSE;
      micromips_add_label ();
    }

  /* We just output an insn, so the next one doesn't have a label.  */
  mips_clear_insn_labels ();
}

/* Forget that there was any previous instruction or label.
   When BRANCH is true, the branch history is also flushed.  */

static void
mips_no_prev_insn (void)
{
  prev_nop_frag = NULL;
  insert_into_history (0, ARRAY_SIZE (history), NOP_INSN);
  mips_clear_insn_labels ();
}

/* This function must be called before we emit something other than
   instructions.  It is like mips_no_prev_insn except that it inserts
   any NOPS that might be needed by previous instructions.  */

void
mips_emit_delays (void)
{
  if (! mips_opts.noreorder)
    {
      int nops = nops_for_insn (0, history, NULL);
      if (nops > 0)
	{
	  while (nops-- > 0)
	    add_fixed_insn (NOP_INSN);
	  mips_move_text_labels ();
	}
    }
  mips_no_prev_insn ();
}

/* Start a (possibly nested) noreorder block.  */

static void
start_noreorder (void)
{
  if (mips_opts.noreorder == 0)
    {
      unsigned int i;
      int nops;

      /* None of the instructions before the .set noreorder can be moved.  */
      for (i = 0; i < ARRAY_SIZE (history); i++)
	history[i].fixed_p = 1;

      /* Insert any nops that might be needed between the .set noreorder
	 block and the previous instructions.  We will later remove any
	 nops that turn out not to be needed.  */
      nops = nops_for_insn (0, history, NULL);
      if (nops > 0)
	{
	  if (mips_optimize != 0)
	    {
	      /* Record the frag which holds the nop instructions, so
                 that we can remove them if we don't need them.  */
	      frag_grow (nops * NOP_INSN_SIZE);
	      prev_nop_frag = frag_now;
	      prev_nop_frag_holds = nops;
	      prev_nop_frag_required = 0;
	      prev_nop_frag_since = 0;
	    }

	  for (; nops > 0; --nops)
	    add_fixed_insn (NOP_INSN);

	  /* Move on to a new frag, so that it is safe to simply
	     decrease the size of prev_nop_frag.  */
	  frag_wane (frag_now);
	  frag_new (0);
	  mips_move_text_labels ();
	}
      mips_mark_labels ();
      mips_clear_insn_labels ();
    }
  mips_opts.noreorder++;
  mips_any_noreorder = 1;
}

/* End a nested noreorder block.  */

static void
end_noreorder (void)
{
  mips_opts.noreorder--;
  if (mips_opts.noreorder == 0 && prev_nop_frag != NULL)
    {
      /* Commit to inserting prev_nop_frag_required nops and go back to
	 handling nop insertion the .set reorder way.  */
      prev_nop_frag->fr_fix -= ((prev_nop_frag_holds - prev_nop_frag_required)
				* NOP_INSN_SIZE);
      insert_into_history (prev_nop_frag_since,
			   prev_nop_frag_required, NOP_INSN);
      prev_nop_frag = NULL;
    }
}

/* Sign-extend 32-bit mode constants that have bit 31 set and all
   higher bits unset.  */

static void
normalize_constant_expr (expressionS *ex)
{
  if (ex->X_op == O_constant
      && IS_ZEXT_32BIT_NUM (ex->X_add_number))
    ex->X_add_number = (((ex->X_add_number & 0xffffffff) ^ 0x80000000)
			- 0x80000000);
}

/* Sign-extend 32-bit mode address offsets that have bit 31 set and
   all higher bits unset.  */

static void
normalize_address_expr (expressionS *ex)
{
  if (((ex->X_op == O_constant && HAVE_32BIT_ADDRESSES)
	|| (ex->X_op == O_symbol && HAVE_32BIT_SYMBOLS))
      && IS_ZEXT_32BIT_NUM (ex->X_add_number))
    ex->X_add_number = (((ex->X_add_number & 0xffffffff) ^ 0x80000000)
			- 0x80000000);
}

/* Try to match TOKENS against OPCODE, storing the result in INSN.
   Return true if the match was successful.

   OPCODE_EXTRA is a value that should be ORed into the opcode
   (used for VU0 channel suffixes, etc.).  MORE_ALTS is true if
   there are more alternatives after OPCODE and SOFT_MATCH is
   as for mips_arg_info.  */

static bfd_boolean
match_insn (struct mips_cl_insn *insn, const struct mips_opcode *opcode,
	    struct mips_operand_token *tokens, unsigned int opcode_extra,
	    bfd_boolean lax_match, bfd_boolean complete_p)
{
  const char *args;
  struct mips_arg_info arg;
  const struct mips_operand *operand;
  char c;

  imm_expr.X_op = O_absent;
  offset_expr.X_op = O_absent;
  offset_reloc[0] = BFD_RELOC_UNUSED;
  offset_reloc[1] = BFD_RELOC_UNUSED;
  offset_reloc[2] = BFD_RELOC_UNUSED;

  create_insn (insn, opcode);
  /* When no opcode suffix is specified, assume ".xyzw". */
  if ((opcode->pinfo2 & INSN2_VU0_CHANNEL_SUFFIX) != 0 && opcode_extra == 0)
    insn->insn_opcode |= 0xf << mips_vu0_channel_mask.lsb;
  else
    insn->insn_opcode |= opcode_extra;
  memset (&arg, 0, sizeof (arg));
  arg.insn = insn;
  arg.token = tokens;
  arg.argnum = 1;
  arg.last_regno = ILLEGAL_REG;
  arg.dest_regno = ILLEGAL_REG;
  arg.lax_match = lax_match;
  for (args = opcode->args;; ++args)
    {
      if (arg.token->type == OT_END)
	{
	  /* Handle unary instructions in which only one operand is given.
	     The source is then the same as the destination.  */
	  if (arg.opnum == 1 && *args == ',')
	    {
	      operand = (mips_opts.micromips
			 ? decode_micromips_operand (args + 1)
			 : decode_mips_operand (args + 1));
	      if (operand && mips_optional_operand_p (operand))
		{
		  arg.token = tokens;
		  arg.argnum = 1;
		  continue;
		}
	    }

	  /* Treat elided base registers as $0.  */
	  if (strcmp (args, "(b)") == 0)
	    args += 3;

	  if (args[0] == '+')
	    switch (args[1])
	      {
	      case 'K':
	      case 'N':
		/* The register suffix is optional. */
		args += 2;
		break;
	      }

	  /* Fail the match if there were too few operands.  */
	  if (*args)
	    return FALSE;

	  /* Successful match.  */
	  if (!complete_p)
	    return TRUE;
	  clear_insn_error ();
	  if (arg.dest_regno == arg.last_regno
	      && strncmp (insn->insn_mo->name, "jalr", 4) == 0)
	    {
	      if (arg.opnum == 2)
		set_insn_error
		  (0, _("source and destination must be different"));
	      else if (arg.last_regno == 31)
		set_insn_error
		  (0, _("a destination register must be supplied"));
	    }
	  else if (arg.last_regno == 31
		   && (strncmp (insn->insn_mo->name, "bltzal", 6) == 0
		       || strncmp (insn->insn_mo->name, "bgezal", 6) == 0))
	    set_insn_error (0, _("the source register must not be $31"));
	  check_completed_insn (&arg);
	  return TRUE;
	}

      /* Fail the match if the line has too many operands.   */
      if (*args == 0)
	return FALSE;

      /* Handle characters that need to match exactly.  */
      if (*args == '(' || *args == ')' || *args == ',')
	{
	  if (match_char (&arg, *args))
	    continue;
	  return FALSE;
	}
      if (*args == '#')
	{
	  ++args;
	  if (arg.token->type == OT_DOUBLE_CHAR
	      && arg.token->u.ch == *args)
	    {
	      ++arg.token;
	      continue;
	    }
	  return FALSE;
	}

      /* Handle special macro operands.  Work out the properties of
	 other operands.  */
      arg.opnum += 1;
      switch (*args)
	{
	case '+':
	  switch (args[1])
	    {
	    case 'i':
	      *offset_reloc = BFD_RELOC_MIPS_JMP;
	      break;
	    }
	  break;

	case 'I':
	  if (!match_const_int (&arg, &imm_expr.X_add_number))
	    return FALSE;
	  imm_expr.X_op = O_constant;
	  if (HAVE_32BIT_GPRS)
	    normalize_constant_expr (&imm_expr);
	  continue;

	case 'A':
	  if (arg.token->type == OT_CHAR && arg.token->u.ch == '(')
	    {
	      /* Assume that the offset has been elided and that what
		 we saw was a base register.  The match will fail later
		 if that assumption turns out to be wrong.  */
	      offset_expr.X_op = O_constant;
	      offset_expr.X_add_number = 0;
	    }
	  else
	    {
	      if (!match_expression (&arg, &offset_expr, offset_reloc))
		return FALSE;
	      normalize_address_expr (&offset_expr);
	    }
	  continue;

	case 'F':
	  if (!match_float_constant (&arg, &imm_expr, &offset_expr,
				     8, TRUE))
	    return FALSE;
	  continue;

	case 'L':
	  if (!match_float_constant (&arg, &imm_expr, &offset_expr,
				     8, FALSE))
	    return FALSE;
	  continue;

	case 'f':
	  if (!match_float_constant (&arg, &imm_expr, &offset_expr,
				     4, TRUE))
	    return FALSE;
	  continue;

	case 'l':
	  if (!match_float_constant (&arg, &imm_expr, &offset_expr,
				     4, FALSE))
	    return FALSE;
	  continue;

	case 'p':
	  *offset_reloc = BFD_RELOC_16_PCREL_S2;
	  break;

	case 'a':
	  *offset_reloc = BFD_RELOC_MIPS_JMP;
	  break;

	case 'm':
	  gas_assert (mips_opts.micromips);
	  c = args[1];
	  switch (c)
	    {
	    case 'D':
	    case 'E':
	      if (!forced_insn_length)
		*offset_reloc = (int) BFD_RELOC_UNUSED + c;
	      else if (c == 'D')
		*offset_reloc = BFD_RELOC_MICROMIPS_10_PCREL_S1;
	      else
		*offset_reloc = BFD_RELOC_MICROMIPS_7_PCREL_S1;
	      break;
	    }
	  break;
	}

      operand = (mips_opts.micromips
		 ? decode_micromips_operand (args)
		 : decode_mips_operand (args));
      if (!operand)
	abort ();

      /* Skip prefixes.  */
      if (*args == '+' || *args == 'm')
	args++;

      if (mips_optional_operand_p (operand)
	  && args[1] == ','
	  && (arg.token[0].type != OT_REG
	      || arg.token[1].type == OT_END))
	{
	  /* Assume that the register has been elided and is the
	     same as the first operand.  */
	  arg.token = tokens;
	  arg.argnum = 1;
	}

      if (!match_operand (&arg, operand))
	return FALSE;
    }
}

/* Like match_insn, but for MIPS16.  */

static bfd_boolean
match_mips16_insn (struct mips_cl_insn *insn, const struct mips_opcode *opcode,
		   struct mips_operand_token *tokens)
{
  const char *args;
  const struct mips_operand *operand;
  const struct mips_operand *ext_operand;
  struct mips_arg_info arg;
  int relax_char;

  create_insn (insn, opcode);
  imm_expr.X_op = O_absent;
  offset_expr.X_op = O_absent;
  offset_reloc[0] = BFD_RELOC_UNUSED;
  offset_reloc[1] = BFD_RELOC_UNUSED;
  offset_reloc[2] = BFD_RELOC_UNUSED;
  relax_char = 0;

  memset (&arg, 0, sizeof (arg));
  arg.insn = insn;
  arg.token = tokens;
  arg.argnum = 1;
  arg.last_regno = ILLEGAL_REG;
  arg.dest_regno = ILLEGAL_REG;
  relax_char = 0;
  for (args = opcode->args;; ++args)
    {
      int c;

      if (arg.token->type == OT_END)
	{
	  offsetT value;

	  /* Handle unary instructions in which only one operand is given.
	     The source is then the same as the destination.  */
	  if (arg.opnum == 1 && *args == ',')
	    {
	      operand = decode_mips16_operand (args[1], FALSE);
	      if (operand && mips_optional_operand_p (operand))
		{
		  arg.token = tokens;
		  arg.argnum = 1;
		  continue;
		}
	    }

	  /* Fail the match if there were too few operands.  */
	  if (*args)
	    return FALSE;

	  /* Successful match.  Stuff the immediate value in now, if
	     we can.  */
	  clear_insn_error ();
	  if (opcode->pinfo == INSN_MACRO)
	    {
	      gas_assert (relax_char == 0 || relax_char == 'p');
	      gas_assert (*offset_reloc == BFD_RELOC_UNUSED);
	    }
	  else if (relax_char
		   && offset_expr.X_op == O_constant
		   && calculate_reloc (*offset_reloc,
				       offset_expr.X_add_number,
				       &value))
	    {
	      mips16_immed (NULL, 0, relax_char, *offset_reloc, value,
			    forced_insn_length, &insn->insn_opcode);
	      offset_expr.X_op = O_absent;
	      *offset_reloc = BFD_RELOC_UNUSED;
	    }
	  else if (relax_char && *offset_reloc != BFD_RELOC_UNUSED)
	    {
	      if (forced_insn_length == 2)
		set_insn_error (0, _("invalid unextended operand value"));
	      forced_insn_length = 4;
	      insn->insn_opcode |= MIPS16_EXTEND;
	    }
	  else if (relax_char)
	    *offset_reloc = (int) BFD_RELOC_UNUSED + relax_char;

	  check_completed_insn (&arg);
	  return TRUE;
	}

      /* Fail the match if the line has too many operands.   */
      if (*args == 0)
	return FALSE;

      /* Handle characters that need to match exactly.  */
      if (*args == '(' || *args == ')' || *args == ',')
	{
	  if (match_char (&arg, *args))
	    continue;
	  return FALSE;
	}

      arg.opnum += 1;
      c = *args;
      switch (c)
	{
	case 'p':
	case 'q':
	case 'A':
	case 'B':
	case 'E':
	  relax_char = c;
	  break;

	case 'I':
	  if (!match_const_int (&arg, &imm_expr.X_add_number))
	    return FALSE;
	  imm_expr.X_op = O_constant;
	  if (HAVE_32BIT_GPRS)
	    normalize_constant_expr (&imm_expr);
	  continue;

	case 'a':
	case 'i':
	  *offset_reloc = BFD_RELOC_MIPS16_JMP;
	  insn->insn_opcode <<= 16;
	  break;
	}

      operand = decode_mips16_operand (c, FALSE);
      if (!operand)
	abort ();

      /* '6' is a special case.  It is used for BREAK and SDBBP,
	 whose operands are only meaningful to the software that decodes
	 them.  This means that there is no architectural reason why
	 they cannot be prefixed by EXTEND, but in practice,
	 exception handlers will only look at the instruction
	 itself.  We therefore allow '6' to be extended when
	 disassembling but not when assembling.  */
      if (operand->type != OP_PCREL && c != '6')
	{
	  ext_operand = decode_mips16_operand (c, TRUE);
	  if (operand != ext_operand)
	    {
	      if (arg.token->type == OT_CHAR && arg.token->u.ch == '(')
		{
		  offset_expr.X_op = O_constant;
		  offset_expr.X_add_number = 0;
		  relax_char = c;
		  continue;
		}

	      /* We need the OT_INTEGER check because some MIPS16
		 immediate variants are listed before the register ones.  */
	      if (arg.token->type != OT_INTEGER
		  || !match_expression (&arg, &offset_expr, offset_reloc))
		return FALSE;

	      /* '8' is used for SLTI(U) and has traditionally not
		 been allowed to take relocation operators.  */
	      if (offset_reloc[0] != BFD_RELOC_UNUSED
		  && (ext_operand->size != 16 || c == '8'))
		return FALSE;

	      relax_char = c;
	      continue;
	    }
	}

      if (mips_optional_operand_p (operand)
	  && args[1] == ','
	  && (arg.token[0].type != OT_REG
	      || arg.token[1].type == OT_END))
	{
	  /* Assume that the register has been elided and is the
	     same as the first operand.  */
	  arg.token = tokens;
	  arg.argnum = 1;
	}

      if (!match_operand (&arg, operand))
	return FALSE;
    }
}

/* Record that the current instruction is invalid for the current ISA.  */

static void
match_invalid_for_isa (void)
{
  set_insn_error_ss
    (0, _("opcode not supported on this processor: %s (%s)"),
     mips_cpu_info_from_arch (mips_opts.arch)->name,
     mips_cpu_info_from_isa (mips_opts.isa)->name);
}

/* Try to match TOKENS against a series of opcode entries, starting at FIRST.
   Return true if a definite match or failure was found, storing any match
   in INSN.  OPCODE_EXTRA is a value that should be ORed into the opcode
   (to handle things like VU0 suffixes).  LAX_MATCH is true if we have already
   tried and failed to match under normal conditions and now want to try a
   more relaxed match.  */

static bfd_boolean
match_insns (struct mips_cl_insn *insn, const struct mips_opcode *first,
	     const struct mips_opcode *past, struct mips_operand_token *tokens,
	     int opcode_extra, bfd_boolean lax_match)
{
  const struct mips_opcode *opcode;
  const struct mips_opcode *invalid_delay_slot;
  bfd_boolean seen_valid_for_isa, seen_valid_for_size;

  /* Search for a match, ignoring alternatives that don't satisfy the
     current ISA or forced_length.  */
  invalid_delay_slot = 0;
  seen_valid_for_isa = FALSE;
  seen_valid_for_size = FALSE;
  opcode = first;
  do
    {
      gas_assert (strcmp (opcode->name, first->name) == 0);
      if (is_opcode_valid (opcode))
	{
	  seen_valid_for_isa = TRUE;
	  if (is_size_valid (opcode))
	    {
	      bfd_boolean delay_slot_ok;

	      seen_valid_for_size = TRUE;
	      delay_slot_ok = is_delay_slot_valid (opcode);
	      if (match_insn (insn, opcode, tokens, opcode_extra,
			      lax_match, delay_slot_ok))
		{
		  if (!delay_slot_ok)
		    {
		      if (!invalid_delay_slot)
			invalid_delay_slot = opcode;
		    }
		  else
		    return TRUE;
		}
	    }
	}
      ++opcode;
    }
  while (opcode < past && strcmp (opcode->name, first->name) == 0);

  /* If the only matches we found had the wrong length for the delay slot,
     pick the first such match.  We'll issue an appropriate warning later.  */
  if (invalid_delay_slot)
    {
      if (match_insn (insn, invalid_delay_slot, tokens, opcode_extra,
		      lax_match, TRUE))
	return TRUE;
      abort ();
    }

  /* Handle the case where we didn't try to match an instruction because
     all the alternatives were incompatible with the current ISA.  */
  if (!seen_valid_for_isa)
    {
      match_invalid_for_isa ();
      return TRUE;
    }

  /* Handle the case where we didn't try to match an instruction because
     all the alternatives were of the wrong size.  */
  if (!seen_valid_for_size)
    {
      if (mips_opts.insn32)
	set_insn_error (0, _("opcode not supported in the `insn32' mode"));
      else
	set_insn_error_i
	  (0, _("unrecognized %d-bit version of microMIPS opcode"),
	   8 * forced_insn_length);
      return TRUE;
    }

  return FALSE;
}

/* Like match_insns, but for MIPS16.  */

static bfd_boolean
match_mips16_insns (struct mips_cl_insn *insn, const struct mips_opcode *first,
		    struct mips_operand_token *tokens)
{
  const struct mips_opcode *opcode;
  bfd_boolean seen_valid_for_isa;

  /* Search for a match, ignoring alternatives that don't satisfy the
     current ISA.  There are no separate entries for extended forms so
     we deal with forced_length later.  */
  seen_valid_for_isa = FALSE;
  opcode = first;
  do
    {
      gas_assert (strcmp (opcode->name, first->name) == 0);
      if (is_opcode_valid_16 (opcode))
	{
	  seen_valid_for_isa = TRUE;
	  if (match_mips16_insn (insn, opcode, tokens))
	    return TRUE;
	}
      ++opcode;
    }
  while (opcode < &mips16_opcodes[bfd_mips16_num_opcodes]
	 && strcmp (opcode->name, first->name) == 0);

  /* Handle the case where we didn't try to match an instruction because
     all the alternatives were incompatible with the current ISA.  */
  if (!seen_valid_for_isa)
    {
      match_invalid_for_isa ();
      return TRUE;
    }

  return FALSE;
}

/* Set up global variables for the start of a new macro.  */

static void
macro_start (void)
{
  memset (&mips_macro_warning.sizes, 0, sizeof (mips_macro_warning.sizes));
  memset (&mips_macro_warning.first_insn_sizes, 0,
	  sizeof (mips_macro_warning.first_insn_sizes));
  memset (&mips_macro_warning.insns, 0, sizeof (mips_macro_warning.insns));
  mips_macro_warning.delay_slot_p = (mips_opts.noreorder
				     && delayed_branch_p (&history[0]));
  switch (history[0].insn_mo->pinfo2
	  & (INSN2_BRANCH_DELAY_32BIT | INSN2_BRANCH_DELAY_16BIT))
    {
    case INSN2_BRANCH_DELAY_32BIT:
      mips_macro_warning.delay_slot_length = 4;
      break;
    case INSN2_BRANCH_DELAY_16BIT:
      mips_macro_warning.delay_slot_length = 2;
      break;
    default:
      mips_macro_warning.delay_slot_length = 0;
      break;
    }
  mips_macro_warning.first_frag = NULL;
}

/* Given that a macro is longer than one instruction or of the wrong size,
   return the appropriate warning for it.  Return null if no warning is
   needed.  SUBTYPE is a bitmask of RELAX_DELAY_SLOT, RELAX_DELAY_SLOT_16BIT,
   RELAX_DELAY_SLOT_SIZE_FIRST, RELAX_DELAY_SLOT_SIZE_SECOND,
   and RELAX_NOMACRO.  */

static const char *
macro_warning (relax_substateT subtype)
{
  if (subtype & RELAX_DELAY_SLOT)
    return _("macro instruction expanded into multiple instructions"
	     " in a branch delay slot");
  else if (subtype & RELAX_NOMACRO)
    return _("macro instruction expanded into multiple instructions");
  else if (subtype & (RELAX_DELAY_SLOT_SIZE_FIRST
		      | RELAX_DELAY_SLOT_SIZE_SECOND))
    return ((subtype & RELAX_DELAY_SLOT_16BIT)
	    ? _("macro instruction expanded into a wrong size instruction"
		" in a 16-bit branch delay slot")
	    : _("macro instruction expanded into a wrong size instruction"
		" in a 32-bit branch delay slot"));
  else
    return 0;
}

/* Finish up a macro.  Emit warnings as appropriate.  */

static void
macro_end (void)
{
  /* Relaxation warning flags.  */
  relax_substateT subtype = 0;

  /* Check delay slot size requirements.  */
  if (mips_macro_warning.delay_slot_length == 2)
    subtype |= RELAX_DELAY_SLOT_16BIT;
  if (mips_macro_warning.delay_slot_length != 0)
    {
      if (mips_macro_warning.delay_slot_length
	  != mips_macro_warning.first_insn_sizes[0])
	subtype |= RELAX_DELAY_SLOT_SIZE_FIRST;
      if (mips_macro_warning.delay_slot_length
	  != mips_macro_warning.first_insn_sizes[1])
	subtype |= RELAX_DELAY_SLOT_SIZE_SECOND;
    }

  /* Check instruction count requirements.  */
  if (mips_macro_warning.insns[0] > 1 || mips_macro_warning.insns[1] > 1)
    {
      if (mips_macro_warning.insns[1] > mips_macro_warning.insns[0])
	subtype |= RELAX_SECOND_LONGER;
      if (mips_opts.warn_about_macros)
	subtype |= RELAX_NOMACRO;
      if (mips_macro_warning.delay_slot_p)
	subtype |= RELAX_DELAY_SLOT;
    }

  /* If both alternatives fail to fill a delay slot correctly,
     emit the warning now.  */
  if ((subtype & RELAX_DELAY_SLOT_SIZE_FIRST) != 0
      && (subtype & RELAX_DELAY_SLOT_SIZE_SECOND) != 0)
    {
      relax_substateT s;
      const char *msg;

      s = subtype & (RELAX_DELAY_SLOT_16BIT
		     | RELAX_DELAY_SLOT_SIZE_FIRST
		     | RELAX_DELAY_SLOT_SIZE_SECOND);
      msg = macro_warning (s);
      if (msg != NULL)
	as_warn ("%s", msg);
      subtype &= ~s;
    }

  /* If both implementations are longer than 1 instruction, then emit the
     warning now.  */
  if (mips_macro_warning.insns[0] > 1 && mips_macro_warning.insns[1] > 1)
    {
      relax_substateT s;
      const char *msg;

      s = subtype & (RELAX_SECOND_LONGER | RELAX_NOMACRO | RELAX_DELAY_SLOT);
      msg = macro_warning (s);
      if (msg != NULL)
	as_warn ("%s", msg);
      subtype &= ~s;
    }

  /* If any flags still set, then one implementation might need a warning
     and the other either will need one of a different kind or none at all.
     Pass any remaining flags over to relaxation.  */
  if (mips_macro_warning.first_frag != NULL)
    mips_macro_warning.first_frag->fr_subtype |= subtype;
}

/* Instruction operand formats used in macros that vary between
   standard MIPS and microMIPS code.  */

static const char * const brk_fmt[2][2] = { { "c", "c" }, { "mF", "c" } };
static const char * const cop12_fmt[2] = { "E,o(b)", "E,~(b)" };
static const char * const jalr_fmt[2] = { "d,s", "t,s" };
static const char * const lui_fmt[2] = { "t,u", "s,u" };
static const char * const mem12_fmt[2] = { "t,o(b)", "t,~(b)" };
static const char * const mfhl_fmt[2][2] = { { "d", "d" }, { "mj", "s" } };
static const char * const shft_fmt[2] = { "d,w,<", "t,r,<" };
static const char * const trap_fmt[2] = { "s,t,q", "s,t,|" };

#define BRK_FMT (brk_fmt[mips_opts.micromips][mips_opts.insn32])
#define COP12_FMT (cop12_fmt[mips_opts.micromips])
#define JALR_FMT (jalr_fmt[mips_opts.micromips])
#define LUI_FMT (lui_fmt[mips_opts.micromips])
#define MEM12_FMT (mem12_fmt[mips_opts.micromips])
#define MFHL_FMT (mfhl_fmt[mips_opts.micromips][mips_opts.insn32])
#define SHFT_FMT (shft_fmt[mips_opts.micromips])
#define TRAP_FMT (trap_fmt[mips_opts.micromips])

/* Read a macro's relocation codes from *ARGS and store them in *R.
   The first argument in *ARGS will be either the code for a single
   relocation or -1 followed by the three codes that make up a
   composite relocation.  */

static void
macro_read_relocs (va_list *args, bfd_reloc_code_real_type *r)
{
  int i, next;

  next = va_arg (*args, int);
  if (next >= 0)
    r[0] = (bfd_reloc_code_real_type) next;
  else
    {
      for (i = 0; i < 3; i++)
	r[i] = (bfd_reloc_code_real_type) va_arg (*args, int);
      /* This function is only used for 16-bit relocation fields.
	 To make the macro code simpler, treat an unrelocated value
	 in the same way as BFD_RELOC_LO16.  */
      if (r[0] == BFD_RELOC_UNUSED)
	r[0] = BFD_RELOC_LO16;
    }
}

/* Build an instruction created by a macro expansion.  This is passed
   a pointer to the count of instructions created so far, an
   expression, the name of the instruction to build, an operand format
   string, and corresponding arguments.  */

static void
macro_build (expressionS *ep, const char *name, const char *fmt, ...)
{
  const struct mips_opcode *mo = NULL;
  bfd_reloc_code_real_type r[3];
  const struct mips_opcode *amo;
  const struct mips_operand *operand;
  struct hash_control *hash;
  struct mips_cl_insn insn;
  va_list args;
  unsigned int uval;

  va_start (args, fmt);

  if (mips_opts.mips16)
    {
      mips16_macro_build (ep, name, fmt, &args);
      va_end (args);
      return;
    }

  r[0] = BFD_RELOC_UNUSED;
  r[1] = BFD_RELOC_UNUSED;
  r[2] = BFD_RELOC_UNUSED;
  hash = mips_opts.micromips ? micromips_op_hash : op_hash;
  amo = (struct mips_opcode *) hash_find (hash, name);
  gas_assert (amo);
  gas_assert (strcmp (name, amo->name) == 0);

  do
    {
      /* Search until we get a match for NAME.  It is assumed here that
	 macros will never generate MDMX, MIPS-3D, or MT instructions.
	 We try to match an instruction that fulfils the branch delay
	 slot instruction length requirement (if any) of the previous
	 instruction.  While doing this we record the first instruction
	 seen that matches all the other conditions and use it anyway
	 if the requirement cannot be met; we will issue an appropriate
	 warning later on.  */
      if (strcmp (fmt, amo->args) == 0
	  && amo->pinfo != INSN_MACRO
	  && is_opcode_valid (amo)
	  && is_size_valid (amo))
	{
	  if (is_delay_slot_valid (amo))
	    {
	      mo = amo;
	      break;
	    }
	  else if (!mo)
	    mo = amo;
	}

      ++amo;
      gas_assert (amo->name);
    }
  while (strcmp (name, amo->name) == 0);

  gas_assert (mo);
  create_insn (&insn, mo);
  for (; *fmt; ++fmt)
    {
      switch (*fmt)
	{
	case ',':
	case '(':
	case ')':
	case 'z':
	  break;

	case 'i':
	case 'j':
	  macro_read_relocs (&args, r);
	  gas_assert (*r == BFD_RELOC_GPREL16
		      || *r == BFD_RELOC_MIPS_HIGHER
		      || *r == BFD_RELOC_HI16_S
		      || *r == BFD_RELOC_LO16
		      || *r == BFD_RELOC_MIPS_GOT_OFST);
	  break;

	case 'o':
	  macro_read_relocs (&args, r);
	  break;

	case 'u':
	  macro_read_relocs (&args, r);
	  gas_assert (ep != NULL
		      && (ep->X_op == O_constant
			  || (ep->X_op == O_symbol
			      && (*r == BFD_RELOC_MIPS_HIGHEST
				  || *r == BFD_RELOC_HI16_S
				  || *r == BFD_RELOC_HI16
				  || *r == BFD_RELOC_GPREL16
				  || *r == BFD_RELOC_MIPS_GOT_HI16
				  || *r == BFD_RELOC_MIPS_CALL_HI16))));
	  break;

	case 'p':
	  gas_assert (ep != NULL);

	  /*
	   * This allows macro() to pass an immediate expression for
	   * creating short branches without creating a symbol.
	   *
	   * We don't allow branch relaxation for these branches, as
	   * they should only appear in ".set nomacro" anyway.
	   */
	  if (ep->X_op == O_constant)
	    {
	      /* For microMIPS we always use relocations for branches.
	         So we should not resolve immediate values.  */
	      gas_assert (!mips_opts.micromips);

	      if ((ep->X_add_number & 3) != 0)
		as_bad (_("branch to misaligned address (0x%lx)"),
			(unsigned long) ep->X_add_number);
	      if ((ep->X_add_number + 0x20000) & ~0x3ffff)
		as_bad (_("branch address range overflow (0x%lx)"),
			(unsigned long) ep->X_add_number);
	      insn.insn_opcode |= (ep->X_add_number >> 2) & 0xffff;
	      ep = NULL;
	    }
	  else
	    *r = BFD_RELOC_16_PCREL_S2;
	  break;

	case 'a':
	  gas_assert (ep != NULL);
	  *r = BFD_RELOC_MIPS_JMP;
	  break;

	default:
	  operand = (mips_opts.micromips
		     ? decode_micromips_operand (fmt)
		     : decode_mips_operand (fmt));
	  if (!operand)
	    abort ();

	  uval = va_arg (args, int);
	  if (operand->type == OP_CLO_CLZ_DEST)
	    uval |= (uval << 5);
	  insn_insert_operand (&insn, operand, uval);

	  if (*fmt == '+' || *fmt == 'm')
	    ++fmt;
	  break;
	}
    }
  va_end (args);
  gas_assert (*r == BFD_RELOC_UNUSED ? ep == NULL : ep != NULL);

  append_insn (&insn, ep, r, TRUE);
}

static void
mips16_macro_build (expressionS *ep, const char *name, const char *fmt,
		    va_list *args)
{
  struct mips_opcode *mo;
  struct mips_cl_insn insn;
  const struct mips_operand *operand;
  bfd_reloc_code_real_type r[3]
    = {BFD_RELOC_UNUSED, BFD_RELOC_UNUSED, BFD_RELOC_UNUSED};

  mo = (struct mips_opcode *) hash_find (mips16_op_hash, name);
  gas_assert (mo);
  gas_assert (strcmp (name, mo->name) == 0);

  while (strcmp (fmt, mo->args) != 0 || mo->pinfo == INSN_MACRO)
    {
      ++mo;
      gas_assert (mo->name);
      gas_assert (strcmp (name, mo->name) == 0);
    }

  create_insn (&insn, mo);
  for (; *fmt; ++fmt)
    {
      int c;

      c = *fmt;
      switch (c)
	{
	case ',':
	case '(':
	case ')':
	  break;

	case '0':
	case 'S':
	case 'P':
	case 'R':
	  break;

	case '<':
	case '>':
	case '4':
	case '5':
	case 'H':
	case 'W':
	case 'D':
	case 'j':
	case '8':
	case 'V':
	case 'C':
	case 'U':
	case 'k':
	case 'K':
	case 'p':
	case 'q':
	  {
	    offsetT value;

	    gas_assert (ep != NULL);

	    if (ep->X_op != O_constant)
	      *r = (int) BFD_RELOC_UNUSED + c;
	    else if (calculate_reloc (*r, ep->X_add_number, &value))
	      {
		mips16_immed (NULL, 0, c, *r, value, 0, &insn.insn_opcode);
		ep = NULL;
		*r = BFD_RELOC_UNUSED;
	      }
	  }
	  break;

	default:
	  operand = decode_mips16_operand (c, FALSE);
	  if (!operand)
	    abort ();

	  insn_insert_operand (&insn, operand, va_arg (*args, int));
	  break;
	}
    }

  gas_assert (*r == BFD_RELOC_UNUSED ? ep == NULL : ep != NULL);

  append_insn (&insn, ep, r, TRUE);
}

/*
 * Generate a "jalr" instruction with a relocation hint to the called
 * function.  This occurs in NewABI PIC code.
 */
static void
macro_build_jalr (expressionS *ep, int cprestore)
{
  static const bfd_reloc_code_real_type jalr_relocs[2]
    = { BFD_RELOC_MIPS_JALR, BFD_RELOC_MICROMIPS_JALR };
  bfd_reloc_code_real_type jalr_reloc = jalr_relocs[mips_opts.micromips];
  const char *jalr;
  char *f = NULL;

  if (MIPS_JALR_HINT_P (ep))
    {
      frag_grow (8);
      f = frag_more (0);
    }
  if (mips_opts.micromips)
    {
      jalr = ((mips_opts.noreorder && !cprestore) || mips_opts.insn32
	      ? "jalr" : "jalrs");
      if (MIPS_JALR_HINT_P (ep)
	  || mips_opts.insn32
	  || (history[0].insn_mo->pinfo2 & INSN2_BRANCH_DELAY_32BIT))
	macro_build (NULL, jalr, "t,s", RA, PIC_CALL_REG);
      else
	macro_build (NULL, jalr, "mj", PIC_CALL_REG);
    }
  else
    macro_build (NULL, "jalr", "d,s", RA, PIC_CALL_REG);
  if (MIPS_JALR_HINT_P (ep))
    fix_new_exp (frag_now, f - frag_now->fr_literal, 4, ep, FALSE, jalr_reloc);
}

/*
 * Generate a "lui" instruction.
 */
static void
macro_build_lui (expressionS *ep, int regnum)
{
  gas_assert (! mips_opts.mips16);

  if (ep->X_op != O_constant)
    {
      gas_assert (ep->X_op == O_symbol);
      /* _gp_disp is a special case, used from s_cpload.
	 __gnu_local_gp is used if mips_no_shared.  */
      gas_assert (mips_pic == NO_PIC
	      || (! HAVE_NEWABI
		  && strcmp (S_GET_NAME (ep->X_add_symbol), "_gp_disp") == 0)
	      || (! mips_in_shared
		  && strcmp (S_GET_NAME (ep->X_add_symbol),
                             "__gnu_local_gp") == 0));
    }

  macro_build (ep, "lui", LUI_FMT, regnum, BFD_RELOC_HI16_S);
}

/* Generate a sequence of instructions to do a load or store from a constant
   offset off of a base register (breg) into/from a target register (treg),
   using AT if necessary.  */
static void
macro_build_ldst_constoffset (expressionS *ep, const char *op,
			      int treg, int breg, int dbl)
{
  gas_assert (ep->X_op == O_constant);

  /* Sign-extending 32-bit constants makes their handling easier.  */
  if (!dbl)
    normalize_constant_expr (ep);

  /* Right now, this routine can only handle signed 32-bit constants.  */
  if (! IS_SEXT_32BIT_NUM(ep->X_add_number + 0x8000))
    as_warn (_("operand overflow"));

  if (IS_SEXT_16BIT_NUM(ep->X_add_number))
    {
      /* Signed 16-bit offset will fit in the op.  Easy!  */
      macro_build (ep, op, "t,o(b)", treg, BFD_RELOC_LO16, breg);
    }
  else
    {
      /* 32-bit offset, need multiple instructions and AT, like:
	   lui      $tempreg,const_hi       (BFD_RELOC_HI16_S)
	   addu     $tempreg,$tempreg,$breg
           <op>     $treg,const_lo($tempreg)   (BFD_RELOC_LO16)
         to handle the complete offset.  */
      macro_build_lui (ep, AT);
      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
      macro_build (ep, op, "t,o(b)", treg, BFD_RELOC_LO16, AT);

      if (!mips_opts.at)
	as_bad (_("macro used $at after \".set noat\""));
    }
}

/*			set_at()
 * Generates code to set the $at register to true (one)
 * if reg is less than the immediate expression.
 */
static void
set_at (int reg, int unsignedp)
{
  if (imm_expr.X_add_number >= -0x8000
      && imm_expr.X_add_number < 0x8000)
    macro_build (&imm_expr, unsignedp ? "sltiu" : "slti", "t,r,j",
		 AT, reg, BFD_RELOC_LO16);
  else
    {
      load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, unsignedp ? "sltu" : "slt", "d,v,t", AT, reg, AT);
    }
}

/* Count the leading zeroes by performing a binary chop. This is a
   bulky bit of source, but performance is a LOT better for the
   majority of values than a simple loop to count the bits:
       for (lcnt = 0; (lcnt < 32); lcnt++)
         if ((v) & (1 << (31 - lcnt)))
           break;
  However it is not code size friendly, and the gain will drop a bit
  on certain cached systems.
*/
#define COUNT_TOP_ZEROES(v)             \
  (((v) & ~0xffff) == 0                 \
   ? ((v) & ~0xff) == 0                 \
     ? ((v) & ~0xf) == 0                \
       ? ((v) & ~0x3) == 0              \
         ? ((v) & ~0x1) == 0            \
           ? !(v)                       \
             ? 32                       \
             : 31                       \
           : 30                         \
         : ((v) & ~0x7) == 0            \
           ? 29                         \
           : 28                         \
       : ((v) & ~0x3f) == 0             \
         ? ((v) & ~0x1f) == 0           \
           ? 27                         \
           : 26                         \
         : ((v) & ~0x7f) == 0           \
           ? 25                         \
           : 24                         \
     : ((v) & ~0xfff) == 0              \
       ? ((v) & ~0x3ff) == 0            \
         ? ((v) & ~0x1ff) == 0          \
           ? 23                         \
           : 22                         \
         : ((v) & ~0x7ff) == 0          \
           ? 21                         \
           : 20                         \
       : ((v) & ~0x3fff) == 0           \
         ? ((v) & ~0x1fff) == 0         \
           ? 19                         \
           : 18                         \
         : ((v) & ~0x7fff) == 0         \
           ? 17                         \
           : 16                         \
   : ((v) & ~0xffffff) == 0             \
     ? ((v) & ~0xfffff) == 0            \
       ? ((v) & ~0x3ffff) == 0          \
         ? ((v) & ~0x1ffff) == 0        \
           ? 15                         \
           : 14                         \
         : ((v) & ~0x7ffff) == 0        \
           ? 13                         \
           : 12                         \
       : ((v) & ~0x3fffff) == 0         \
         ? ((v) & ~0x1fffff) == 0       \
           ? 11                         \
           : 10                         \
         : ((v) & ~0x7fffff) == 0       \
           ? 9                          \
           : 8                          \
     : ((v) & ~0xfffffff) == 0          \
       ? ((v) & ~0x3ffffff) == 0        \
         ? ((v) & ~0x1ffffff) == 0      \
           ? 7                          \
           : 6                          \
         : ((v) & ~0x7ffffff) == 0      \
           ? 5                          \
           : 4                          \
       : ((v) & ~0x3fffffff) == 0       \
         ? ((v) & ~0x1fffffff) == 0     \
           ? 3                          \
           : 2                          \
         : ((v) & ~0x7fffffff) == 0     \
           ? 1                          \
           : 0)

/*			load_register()
 *  This routine generates the least number of instructions necessary to load
 *  an absolute expression value into a register.
 */
static void
load_register (int reg, expressionS *ep, int dbl)
{
  int freg;
  expressionS hi32, lo32;

  if (ep->X_op != O_big)
    {
      gas_assert (ep->X_op == O_constant);

      /* Sign-extending 32-bit constants makes their handling easier.  */
      if (!dbl)
	normalize_constant_expr (ep);

      if (IS_SEXT_16BIT_NUM (ep->X_add_number))
	{
	  /* We can handle 16 bit signed values with an addiu to
	     $zero.  No need to ever use daddiu here, since $zero and
	     the result are always correct in 32 bit mode.  */
	  macro_build (ep, "addiu", "t,r,j", reg, 0, BFD_RELOC_LO16);
	  return;
	}
      else if (ep->X_add_number >= 0 && ep->X_add_number < 0x10000)
	{
	  /* We can handle 16 bit unsigned values with an ori to
             $zero.  */
	  macro_build (ep, "ori", "t,r,i", reg, 0, BFD_RELOC_LO16);
	  return;
	}
      else if ((IS_SEXT_32BIT_NUM (ep->X_add_number)))
	{
	  /* 32 bit values require an lui.  */
	  macro_build (ep, "lui", LUI_FMT, reg, BFD_RELOC_HI16);
	  if ((ep->X_add_number & 0xffff) != 0)
	    macro_build (ep, "ori", "t,r,i", reg, reg, BFD_RELOC_LO16);
	  return;
	}
    }

  /* The value is larger than 32 bits.  */

  if (!dbl || HAVE_32BIT_GPRS)
    {
      char value[32];

      sprintf_vma (value, ep->X_add_number);
      as_bad (_("number (0x%s) larger than 32 bits"), value);
      macro_build (ep, "addiu", "t,r,j", reg, 0, BFD_RELOC_LO16);
      return;
    }

  if (ep->X_op != O_big)
    {
      hi32 = *ep;
      hi32.X_add_number = (valueT) hi32.X_add_number >> 16;
      hi32.X_add_number = (valueT) hi32.X_add_number >> 16;
      hi32.X_add_number &= 0xffffffff;
      lo32 = *ep;
      lo32.X_add_number &= 0xffffffff;
    }
  else
    {
      gas_assert (ep->X_add_number > 2);
      if (ep->X_add_number == 3)
	generic_bignum[3] = 0;
      else if (ep->X_add_number > 4)
	as_bad (_("number larger than 64 bits"));
      lo32.X_op = O_constant;
      lo32.X_add_number = generic_bignum[0] + (generic_bignum[1] << 16);
      hi32.X_op = O_constant;
      hi32.X_add_number = generic_bignum[2] + (generic_bignum[3] << 16);
    }

  if (hi32.X_add_number == 0)
    freg = 0;
  else
    {
      int shift, bit;
      unsigned long hi, lo;

      if (hi32.X_add_number == (offsetT) 0xffffffff)
	{
	  if ((lo32.X_add_number & 0xffff8000) == 0xffff8000)
	    {
	      macro_build (&lo32, "addiu", "t,r,j", reg, 0, BFD_RELOC_LO16);
	      return;
	    }
	  if (lo32.X_add_number & 0x80000000)
	    {
	      macro_build (&lo32, "lui", LUI_FMT, reg, BFD_RELOC_HI16);
	      if (lo32.X_add_number & 0xffff)
		macro_build (&lo32, "ori", "t,r,i", reg, reg, BFD_RELOC_LO16);
	      return;
	    }
	}

      /* Check for 16bit shifted constant.  We know that hi32 is
         non-zero, so start the mask on the first bit of the hi32
         value.  */
      shift = 17;
      do
	{
	  unsigned long himask, lomask;

	  if (shift < 32)
	    {
	      himask = 0xffff >> (32 - shift);
	      lomask = (0xffff << shift) & 0xffffffff;
	    }
	  else
	    {
	      himask = 0xffff << (shift - 32);
	      lomask = 0;
	    }
	  if ((hi32.X_add_number & ~(offsetT) himask) == 0
	      && (lo32.X_add_number & ~(offsetT) lomask) == 0)
	    {
	      expressionS tmp;

	      tmp.X_op = O_constant;
	      if (shift < 32)
		tmp.X_add_number = ((hi32.X_add_number << (32 - shift))
				    | (lo32.X_add_number >> shift));
	      else
		tmp.X_add_number = hi32.X_add_number >> (shift - 32);
	      macro_build (&tmp, "ori", "t,r,i", reg, 0, BFD_RELOC_LO16);
	      macro_build (NULL, (shift >= 32) ? "dsll32" : "dsll", SHFT_FMT,
			   reg, reg, (shift >= 32) ? shift - 32 : shift);
	      return;
	    }
	  ++shift;
	}
      while (shift <= (64 - 16));

      /* Find the bit number of the lowest one bit, and store the
         shifted value in hi/lo.  */
      hi = (unsigned long) (hi32.X_add_number & 0xffffffff);
      lo = (unsigned long) (lo32.X_add_number & 0xffffffff);
      if (lo != 0)
	{
	  bit = 0;
	  while ((lo & 1) == 0)
	    {
	      lo >>= 1;
	      ++bit;
	    }
	  lo |= (hi & (((unsigned long) 1 << bit) - 1)) << (32 - bit);
	  hi >>= bit;
	}
      else
	{
	  bit = 32;
	  while ((hi & 1) == 0)
	    {
	      hi >>= 1;
	      ++bit;
	    }
	  lo = hi;
	  hi = 0;
	}

      /* Optimize if the shifted value is a (power of 2) - 1.  */
      if ((hi == 0 && ((lo + 1) & lo) == 0)
	  || (lo == 0xffffffff && ((hi + 1) & hi) == 0))
	{
	  shift = COUNT_TOP_ZEROES ((unsigned int) hi32.X_add_number);
	  if (shift != 0)
	    {
	      expressionS tmp;

	      /* This instruction will set the register to be all
                 ones.  */
	      tmp.X_op = O_constant;
	      tmp.X_add_number = (offsetT) -1;
	      macro_build (&tmp, "addiu", "t,r,j", reg, 0, BFD_RELOC_LO16);
	      if (bit != 0)
		{
		  bit += shift;
		  macro_build (NULL, (bit >= 32) ? "dsll32" : "dsll", SHFT_FMT,
			       reg, reg, (bit >= 32) ? bit - 32 : bit);
		}
	      macro_build (NULL, (shift >= 32) ? "dsrl32" : "dsrl", SHFT_FMT,
			   reg, reg, (shift >= 32) ? shift - 32 : shift);
	      return;
	    }
	}

      /* Sign extend hi32 before calling load_register, because we can
         generally get better code when we load a sign extended value.  */
      if ((hi32.X_add_number & 0x80000000) != 0)
	hi32.X_add_number |= ~(offsetT) 0xffffffff;
      load_register (reg, &hi32, 0);
      freg = reg;
    }
  if ((lo32.X_add_number & 0xffff0000) == 0)
    {
      if (freg != 0)
	{
	  macro_build (NULL, "dsll32", SHFT_FMT, reg, freg, 0);
	  freg = reg;
	}
    }
  else
    {
      expressionS mid16;

      if ((freg == 0) && (lo32.X_add_number == (offsetT) 0xffffffff))
	{
	  macro_build (&lo32, "lui", LUI_FMT, reg, BFD_RELOC_HI16);
	  macro_build (NULL, "dsrl32", SHFT_FMT, reg, reg, 0);
	  return;
	}

      if (freg != 0)
	{
	  macro_build (NULL, "dsll", SHFT_FMT, reg, freg, 16);
	  freg = reg;
	}
      mid16 = lo32;
      mid16.X_add_number >>= 16;
      macro_build (&mid16, "ori", "t,r,i", reg, freg, BFD_RELOC_LO16);
      macro_build (NULL, "dsll", SHFT_FMT, reg, reg, 16);
      freg = reg;
    }
  if ((lo32.X_add_number & 0xffff) != 0)
    macro_build (&lo32, "ori", "t,r,i", reg, freg, BFD_RELOC_LO16);
}

static inline void
load_delay_nop (void)
{
  if (!gpr_interlocks)
    macro_build (NULL, "nop", "");
}

/* Load an address into a register.  */

static void
load_address (int reg, expressionS *ep, int *used_at)
{
  if (ep->X_op != O_constant
      && ep->X_op != O_symbol)
    {
      as_bad (_("expression too complex"));
      ep->X_op = O_constant;
    }

  if (ep->X_op == O_constant)
    {
      load_register (reg, ep, HAVE_64BIT_ADDRESSES);
      return;
    }

  if (mips_pic == NO_PIC)
    {
      /* If this is a reference to a GP relative symbol, we want
	   addiu	$reg,$gp,<sym>		(BFD_RELOC_GPREL16)
	 Otherwise we want
	   lui		$reg,<sym>		(BFD_RELOC_HI16_S)
	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16)
	 If we have an addend, we always use the latter form.

	 With 64bit address space and a usable $at we want
	   lui		$reg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	   lui		$at,<sym>		(BFD_RELOC_HI16_S)
	   daddiu	$reg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	   daddiu	$at,<sym>		(BFD_RELOC_LO16)
	   dsll32	$reg,0
	   daddu	$reg,$reg,$at

	 If $at is already in use, we use a path which is suboptimal
	 on superscalar processors.
	   lui		$reg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	   daddiu	$reg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	   dsll		$reg,16
	   daddiu	$reg,<sym>		(BFD_RELOC_HI16_S)
	   dsll		$reg,16
	   daddiu	$reg,<sym>		(BFD_RELOC_LO16)

	 For GP relative symbols in 64bit address space we can use
	 the same sequence as in 32bit address space.  */
      if (HAVE_64BIT_SYMBOLS)
	{
	  if ((valueT) ep->X_add_number <= MAX_GPREL_OFFSET
	      && !nopic_need_relax (ep->X_add_symbol, 1))
	    {
	      relax_start (ep->X_add_symbol);
	      macro_build (ep, ADDRESS_ADDI_INSN, "t,r,j", reg,
			   mips_gp_register, BFD_RELOC_GPREL16);
	      relax_switch ();
	    }

	  if (*used_at == 0 && mips_opts.at)
	    {
	      macro_build (ep, "lui", LUI_FMT, reg, BFD_RELOC_MIPS_HIGHEST);
	      macro_build (ep, "lui", LUI_FMT, AT, BFD_RELOC_HI16_S);
	      macro_build (ep, "daddiu", "t,r,j", reg, reg,
			   BFD_RELOC_MIPS_HIGHER);
	      macro_build (ep, "daddiu", "t,r,j", AT, AT, BFD_RELOC_LO16);
	      macro_build (NULL, "dsll32", SHFT_FMT, reg, reg, 0);
	      macro_build (NULL, "daddu", "d,v,t", reg, reg, AT);
	      *used_at = 1;
	    }
	  else
	    {
	      macro_build (ep, "lui", LUI_FMT, reg, BFD_RELOC_MIPS_HIGHEST);
	      macro_build (ep, "daddiu", "t,r,j", reg, reg,
			   BFD_RELOC_MIPS_HIGHER);
	      macro_build (NULL, "dsll", SHFT_FMT, reg, reg, 16);
	      macro_build (ep, "daddiu", "t,r,j", reg, reg, BFD_RELOC_HI16_S);
	      macro_build (NULL, "dsll", SHFT_FMT, reg, reg, 16);
	      macro_build (ep, "daddiu", "t,r,j", reg, reg, BFD_RELOC_LO16);
	    }

	  if (mips_relax.sequence)
	    relax_end ();
	}
      else
	{
	  if ((valueT) ep->X_add_number <= MAX_GPREL_OFFSET
	      && !nopic_need_relax (ep->X_add_symbol, 1))
	    {
	      relax_start (ep->X_add_symbol);
	      macro_build (ep, ADDRESS_ADDI_INSN, "t,r,j", reg,
			   mips_gp_register, BFD_RELOC_GPREL16);
	      relax_switch ();
	    }
	  macro_build_lui (ep, reg);
	  macro_build (ep, ADDRESS_ADDI_INSN, "t,r,j",
		       reg, reg, BFD_RELOC_LO16);
	  if (mips_relax.sequence)
	    relax_end ();
	}
    }
  else if (!mips_big_got)
    {
      expressionS ex;

      /* If this is a reference to an external symbol, we want
	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
	 Otherwise we want
	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
	   nop
	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16)
	 If there is a constant, it must be added in after.

	 If we have NewABI, we want
	   lw		$reg,<sym+cst>($gp)	(BFD_RELOC_MIPS_GOT_DISP)
         unless we're referencing a global symbol with a non-zero
         offset, in which case cst must be added separately.  */
      if (HAVE_NEWABI)
	{
	  if (ep->X_add_number)
	    {
	      ex.X_add_number = ep->X_add_number;
	      ep->X_add_number = 0;
	      relax_start (ep->X_add_symbol);
	      macro_build (ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
			   BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);
	      if (ex.X_add_number < -0x8000 || ex.X_add_number >= 0x8000)
		as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	      ex.X_op = O_constant;
	      macro_build (&ex, ADDRESS_ADDI_INSN, "t,r,j",
			   reg, reg, BFD_RELOC_LO16);
	      ep->X_add_number = ex.X_add_number;
	      relax_switch ();
	    }
	  macro_build (ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
		       BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);
	  if (mips_relax.sequence)
	    relax_end ();
	}
      else
	{
	  ex.X_add_number = ep->X_add_number;
	  ep->X_add_number = 0;
	  macro_build (ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
		       BFD_RELOC_MIPS_GOT16, mips_gp_register);
	  load_delay_nop ();
	  relax_start (ep->X_add_symbol);
	  relax_switch ();
	  macro_build (ep, ADDRESS_ADDI_INSN, "t,r,j", reg, reg,
		       BFD_RELOC_LO16);
	  relax_end ();

	  if (ex.X_add_number != 0)
	    {
	      if (ex.X_add_number < -0x8000 || ex.X_add_number >= 0x8000)
		as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	      ex.X_op = O_constant;
	      macro_build (&ex, ADDRESS_ADDI_INSN, "t,r,j",
			   reg, reg, BFD_RELOC_LO16);
	    }
	}
    }
  else if (mips_big_got)
    {
      expressionS ex;

      /* This is the large GOT case.  If this is a reference to an
	 external symbol, we want
	   lui		$reg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	   addu		$reg,$reg,$gp
	   lw		$reg,<sym>($reg)	(BFD_RELOC_MIPS_GOT_LO16)

	 Otherwise, for a reference to a local symbol in old ABI, we want
	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
	   nop
	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16)
	 If there is a constant, it must be added in after.

	 In the NewABI, for local symbols, with or without offsets, we want:
	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT_PAGE)
	   addiu	$reg,$reg,<sym>		(BFD_RELOC_MIPS_GOT_OFST)
      */
      if (HAVE_NEWABI)
	{
	  ex.X_add_number = ep->X_add_number;
	  ep->X_add_number = 0;
	  relax_start (ep->X_add_symbol);
	  macro_build (ep, "lui", LUI_FMT, reg, BFD_RELOC_MIPS_GOT_HI16);
	  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
		       reg, reg, mips_gp_register);
	  macro_build (ep, ADDRESS_LOAD_INSN, "t,o(b)",
		       reg, BFD_RELOC_MIPS_GOT_LO16, reg);
	  if (ex.X_add_number < -0x8000 || ex.X_add_number >= 0x8000)
	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	  else if (ex.X_add_number)
	    {
	      ex.X_op = O_constant;
	      macro_build (&ex, ADDRESS_ADDI_INSN, "t,r,j", reg, reg,
			   BFD_RELOC_LO16);
	    }

	  ep->X_add_number = ex.X_add_number;
	  relax_switch ();
	  macro_build (ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
		       BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
	  macro_build (ep, ADDRESS_ADDI_INSN, "t,r,j", reg, reg,
		       BFD_RELOC_MIPS_GOT_OFST);
	  relax_end ();
	}
      else
	{
	  ex.X_add_number = ep->X_add_number;
	  ep->X_add_number = 0;
	  relax_start (ep->X_add_symbol);
	  macro_build (ep, "lui", LUI_FMT, reg, BFD_RELOC_MIPS_GOT_HI16);
	  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
		       reg, reg, mips_gp_register);
	  macro_build (ep, ADDRESS_LOAD_INSN, "t,o(b)",
		       reg, BFD_RELOC_MIPS_GOT_LO16, reg);
	  relax_switch ();
	  if (reg_needs_delay (mips_gp_register))
	    {
	      /* We need a nop before loading from $gp.  This special
		 check is required because the lui which starts the main
		 instruction stream does not refer to $gp, and so will not
		 insert the nop which may be required.  */
	      macro_build (NULL, "nop", "");
	    }
	  macro_build (ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
		       BFD_RELOC_MIPS_GOT16, mips_gp_register);
	  load_delay_nop ();
	  macro_build (ep, ADDRESS_ADDI_INSN, "t,r,j", reg, reg,
		       BFD_RELOC_LO16);
	  relax_end ();

	  if (ex.X_add_number != 0)
	    {
	      if (ex.X_add_number < -0x8000 || ex.X_add_number >= 0x8000)
		as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	      ex.X_op = O_constant;
	      macro_build (&ex, ADDRESS_ADDI_INSN, "t,r,j", reg, reg,
			   BFD_RELOC_LO16);
	    }
	}
    }
  else
    abort ();

  if (!mips_opts.at && *used_at == 1)
    as_bad (_("macro used $at after \".set noat\""));
}

/* Move the contents of register SOURCE into register DEST.  */

static void
move_register (int dest, int source)
{
  /* Prefer to use a 16-bit microMIPS instruction unless the previous
     instruction specifically requires a 32-bit one.  */
  if (mips_opts.micromips
      && !mips_opts.insn32
      && !(history[0].insn_mo->pinfo2 & INSN2_BRANCH_DELAY_32BIT))
    macro_build (NULL, "move", "mp,mj", dest, source);
  else
    macro_build (NULL, HAVE_32BIT_GPRS ? "addu" : "daddu", "d,v,t",
		 dest, source, 0);
}

/* Emit an SVR4 PIC sequence to load address LOCAL into DEST, where
   LOCAL is the sum of a symbol and a 16-bit or 32-bit displacement.
   The two alternatives are:

   Global symbol		Local sybmol
   -------------		------------
   lw DEST,%got(SYMBOL)		lw DEST,%got(SYMBOL + OFFSET)
   ...				...
   addiu DEST,DEST,OFFSET	addiu DEST,DEST,%lo(SYMBOL + OFFSET)

   load_got_offset emits the first instruction and add_got_offset
   emits the second for a 16-bit offset or add_got_offset_hilo emits
   a sequence to add a 32-bit offset using a scratch register.  */

static void
load_got_offset (int dest, expressionS *local)
{
  expressionS global;

  global = *local;
  global.X_add_number = 0;

  relax_start (local->X_add_symbol);
  macro_build (&global, ADDRESS_LOAD_INSN, "t,o(b)", dest,
	       BFD_RELOC_MIPS_GOT16, mips_gp_register);
  relax_switch ();
  macro_build (local, ADDRESS_LOAD_INSN, "t,o(b)", dest,
	       BFD_RELOC_MIPS_GOT16, mips_gp_register);
  relax_end ();
}

static void
add_got_offset (int dest, expressionS *local)
{
  expressionS global;

  global.X_op = O_constant;
  global.X_op_symbol = NULL;
  global.X_add_symbol = NULL;
  global.X_add_number = local->X_add_number;

  relax_start (local->X_add_symbol);
  macro_build (&global, ADDRESS_ADDI_INSN, "t,r,j",
	       dest, dest, BFD_RELOC_LO16);
  relax_switch ();
  macro_build (local, ADDRESS_ADDI_INSN, "t,r,j", dest, dest, BFD_RELOC_LO16);
  relax_end ();
}

static void
add_got_offset_hilo (int dest, expressionS *local, int tmp)
{
  expressionS global;
  int hold_mips_optimize;

  global.X_op = O_constant;
  global.X_op_symbol = NULL;
  global.X_add_symbol = NULL;
  global.X_add_number = local->X_add_number;

  relax_start (local->X_add_symbol);
  load_register (tmp, &global, HAVE_64BIT_ADDRESSES);
  relax_switch ();
  /* Set mips_optimize around the lui instruction to avoid
     inserting an unnecessary nop after the lw.  */
  hold_mips_optimize = mips_optimize;
  mips_optimize = 2;
  macro_build_lui (&global, tmp);
  mips_optimize = hold_mips_optimize;
  macro_build (local, ADDRESS_ADDI_INSN, "t,r,j", tmp, tmp, BFD_RELOC_LO16);
  relax_end ();

  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", dest, dest, tmp);
}

/* Emit a sequence of instructions to emulate a branch likely operation.
   BR is an ordinary branch corresponding to one to be emulated.  BRNEG
   is its complementing branch with the original condition negated.
   CALL is set if the original branch specified the link operation.
   EP, FMT, SREG and TREG specify the usual macro_build() parameters.

   Code like this is produced in the noreorder mode:

	BRNEG	<args>, 1f
	 nop
	b	<sym>
	 delay slot (executed only if branch taken)
    1:

   or, if CALL is set:

	BRNEG	<args>, 1f
	 nop
	bal	<sym>
	 delay slot (executed only if branch taken)
    1:

   In the reorder mode the delay slot would be filled with a nop anyway,
   so code produced is simply:

	BR	<args>, <sym>
	 nop

   This function is used when producing code for the microMIPS ASE that
   does not implement branch likely instructions in hardware.  */

static void
macro_build_branch_likely (const char *br, const char *brneg,
			   int call, expressionS *ep, const char *fmt,
			   unsigned int sreg, unsigned int treg)
{
  int noreorder = mips_opts.noreorder;
  expressionS expr1;

  gas_assert (mips_opts.micromips);
  start_noreorder ();
  if (noreorder)
    {
      micromips_label_expr (&expr1);
      macro_build (&expr1, brneg, fmt, sreg, treg);
      macro_build (NULL, "nop", "");
      macro_build (ep, call ? "bal" : "b", "p");

      /* Set to true so that append_insn adds a label.  */
      emit_branch_likely_macro = TRUE;
    }
  else
    {
      macro_build (ep, br, fmt, sreg, treg);
      macro_build (NULL, "nop", "");
    }
  end_noreorder ();
}

/* Emit a coprocessor branch-likely macro specified by TYPE, using CC as
   the condition code tested.  EP specifies the branch target.  */

static void
macro_build_branch_ccl (int type, expressionS *ep, unsigned int cc)
{
  const int call = 0;
  const char *brneg;
  const char *br;

  switch (type)
    {
    case M_BC1FL:
      br = "bc1f";
      brneg = "bc1t";
      break;
    case M_BC1TL:
      br = "bc1t";
      brneg = "bc1f";
      break;
    case M_BC2FL:
      br = "bc2f";
      brneg = "bc2t";
      break;
    case M_BC2TL:
      br = "bc2t";
      brneg = "bc2f";
      break;
    default:
      abort ();
    }
  macro_build_branch_likely (br, brneg, call, ep, "N,p", cc, ZERO);
}

/* Emit a two-argument branch macro specified by TYPE, using SREG as
   the register tested.  EP specifies the branch target.  */

static void
macro_build_branch_rs (int type, expressionS *ep, unsigned int sreg)
{
  const char *brneg = NULL;
  const char *br;
  int call = 0;

  switch (type)
    {
    case M_BGEZ:
      br = "bgez";
      break;
    case M_BGEZL:
      br = mips_opts.micromips ? "bgez" : "bgezl";
      brneg = "bltz";
      break;
    case M_BGEZALL:
      gas_assert (mips_opts.micromips);
      br = mips_opts.insn32 ? "bgezal" : "bgezals";
      brneg = "bltz";
      call = 1;
      break;
    case M_BGTZ:
      br = "bgtz";
      break;
    case M_BGTZL:
      br = mips_opts.micromips ? "bgtz" : "bgtzl";
      brneg = "blez";
      break;
    case M_BLEZ:
      br = "blez";
      break;
    case M_BLEZL:
      br = mips_opts.micromips ? "blez" : "blezl";
      brneg = "bgtz";
      break;
    case M_BLTZ:
      br = "bltz";
      break;
    case M_BLTZL:
      br = mips_opts.micromips ? "bltz" : "bltzl";
      brneg = "bgez";
      break;
    case M_BLTZALL:
      gas_assert (mips_opts.micromips);
      br = mips_opts.insn32 ? "bltzal" : "bltzals";
      brneg = "bgez";
      call = 1;
      break;
    default:
      abort ();
    }
  if (mips_opts.micromips && brneg)
    macro_build_branch_likely (br, brneg, call, ep, "s,p", sreg, ZERO);
  else
    macro_build (ep, br, "s,p", sreg);
}

/* Emit a three-argument branch macro specified by TYPE, using SREG and
   TREG as the registers tested.  EP specifies the branch target.  */

static void
macro_build_branch_rsrt (int type, expressionS *ep,
			 unsigned int sreg, unsigned int treg)
{
  const char *brneg = NULL;
  const int call = 0;
  const char *br;

  switch (type)
    {
    case M_BEQ:
    case M_BEQ_I:
      br = "beq";
      break;
    case M_BEQL:
    case M_BEQL_I:
      br = mips_opts.micromips ? "beq" : "beql";
      brneg = "bne";
      break;
    case M_BNE:
    case M_BNE_I:
      br = "bne";
      break;
    case M_BNEL:
    case M_BNEL_I:
      br = mips_opts.micromips ? "bne" : "bnel";
      brneg = "beq";
      break;
    default:
      abort ();
    }
  if (mips_opts.micromips && brneg)
    macro_build_branch_likely (br, brneg, call, ep, "s,t,p", sreg, treg);
  else
    macro_build (ep, br, "s,t,p", sreg, treg);
}

/* Return the high part that should be loaded in order to make the low
   part of VALUE accessible using an offset of OFFBITS bits.  */

static offsetT
offset_high_part (offsetT value, unsigned int offbits)
{
  offsetT bias;
  addressT low_mask;

  if (offbits == 0)
    return value;
  bias = 1 << (offbits - 1);
  low_mask = bias * 2 - 1;
  return (value + bias) & ~low_mask;
}

/* Return true if the value stored in offset_expr and offset_reloc
   fits into a signed offset of OFFBITS bits.  RANGE is the maximum
   amount that the caller wants to add without inducing overflow
   and ALIGN is the known alignment of the value in bytes.  */

static bfd_boolean
small_offset_p (unsigned int range, unsigned int align, unsigned int offbits)
{
  if (offbits == 16)
    {
      /* Accept any relocation operator if overflow isn't a concern.  */
      if (range < align && *offset_reloc != BFD_RELOC_UNUSED)
	return TRUE;

      /* These relocations are guaranteed not to overflow in correct links.  */
      if (*offset_reloc == BFD_RELOC_MIPS_LITERAL
	  || gprel16_reloc_p (*offset_reloc))
	return TRUE;
    }
  if (offset_expr.X_op == O_constant
      && offset_high_part (offset_expr.X_add_number, offbits) == 0
      && offset_high_part (offset_expr.X_add_number + range, offbits) == 0)
    return TRUE;
  return FALSE;
}

/*
 *			Build macros
 *   This routine implements the seemingly endless macro or synthesized
 * instructions and addressing modes in the mips assembly language. Many
 * of these macros are simple and are similar to each other. These could
 * probably be handled by some kind of table or grammar approach instead of
 * this verbose method. Others are not simple macros but are more like
 * optimizing code generation.
 *   One interesting optimization is when several store macros appear
 * consecutively that would load AT with the upper half of the same address.
 * The ensuing load upper instructions are ommited. This implies some kind
 * of global optimization. We currently only optimize within a single macro.
 *   For many of the load and store macros if the address is specified as a
 * constant expression in the first 64k of memory (ie ld $2,0x4000c) we
 * first load register 'at' with zero and use it as the base register. The
 * mips assembler simply uses register $zero. Just one tiny optimization
 * we're missing.
 */
static void
macro (struct mips_cl_insn *ip, char *str)
{
  const struct mips_operand_array *operands;
  unsigned int breg, i;
  unsigned int tempreg;
  int mask;
  int used_at = 0;
  expressionS label_expr;
  expressionS expr1;
  expressionS *ep;
  const char *s;
  const char *s2;
  const char *fmt;
  int likely = 0;
  int coproc = 0;
  int offbits = 16;
  int call = 0;
  int jals = 0;
  int dbl = 0;
  int imm = 0;
  int ust = 0;
  int lp = 0;
  bfd_boolean large_offset;
  int off;
  int hold_mips_optimize;
  unsigned int align;
  unsigned int op[MAX_OPERANDS];

  gas_assert (! mips_opts.mips16);

  operands = insn_operands (ip);
  for (i = 0; i < MAX_OPERANDS; i++)
    if (operands->operand[i])
      op[i] = insn_extract_operand (ip, operands->operand[i]);
    else
      op[i] = -1;

  mask = ip->insn_mo->mask;

  label_expr.X_op = O_constant;
  label_expr.X_op_symbol = NULL;
  label_expr.X_add_symbol = NULL;
  label_expr.X_add_number = 0;

  expr1.X_op = O_constant;
  expr1.X_op_symbol = NULL;
  expr1.X_add_symbol = NULL;
  expr1.X_add_number = 1;
  align = 1;

  switch (mask)
    {
    case M_DABS:
      dbl = 1;
    case M_ABS:
      /*    bgez    $a0,1f
	    move    v0,$a0
	    sub     v0,$zero,$a0
	 1:
       */

      start_noreorder ();

      if (mips_opts.micromips)
	micromips_label_expr (&label_expr);
      else
	label_expr.X_add_number = 8;
      macro_build (&label_expr, "bgez", "s,p", op[1]);
      if (op[0] == op[1])
	macro_build (NULL, "nop", "");
      else
	move_register (op[0], op[1]);
      macro_build (NULL, dbl ? "dsub" : "sub", "d,v,t", op[0], 0, op[1]);
      if (mips_opts.micromips)
	micromips_add_label ();

      end_noreorder ();
      break;

    case M_ADD_I:
      s = "addi";
      s2 = "add";
      goto do_addi;
    case M_ADDU_I:
      s = "addiu";
      s2 = "addu";
      goto do_addi;
    case M_DADD_I:
      dbl = 1;
      s = "daddi";
      s2 = "dadd";
      if (!mips_opts.micromips)
	goto do_addi;
      if (imm_expr.X_add_number >= -0x200
	  && imm_expr.X_add_number < 0x200)
	{
	  macro_build (NULL, s, "t,r,.", op[0], op[1],
		       (int) imm_expr.X_add_number);
	  break;
	}
      goto do_addi_i;
    case M_DADDU_I:
      dbl = 1;
      s = "daddiu";
      s2 = "daddu";
    do_addi:
      if (imm_expr.X_add_number >= -0x8000
	  && imm_expr.X_add_number < 0x8000)
	{
	  macro_build (&imm_expr, s, "t,r,j", op[0], op[1], BFD_RELOC_LO16);
	  break;
	}
    do_addi_i:
      used_at = 1;
      load_register (AT, &imm_expr, dbl);
      macro_build (NULL, s2, "d,v,t", op[0], op[1], AT);
      break;

    case M_AND_I:
      s = "andi";
      s2 = "and";
      goto do_bit;
    case M_OR_I:
      s = "ori";
      s2 = "or";
      goto do_bit;
    case M_NOR_I:
      s = "";
      s2 = "nor";
      goto do_bit;
    case M_XOR_I:
      s = "xori";
      s2 = "xor";
    do_bit:
      if (imm_expr.X_add_number >= 0
	  && imm_expr.X_add_number < 0x10000)
	{
	  if (mask != M_NOR_I)
	    macro_build (&imm_expr, s, "t,r,i", op[0], op[1], BFD_RELOC_LO16);
	  else
	    {
	      macro_build (&imm_expr, "ori", "t,r,i",
			   op[0], op[1], BFD_RELOC_LO16);
	      macro_build (NULL, "nor", "d,v,t", op[0], op[0], 0);
	    }
	  break;
	}

      used_at = 1;
      load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, s2, "d,v,t", op[0], op[1], AT);
      break;

    case M_BALIGN:
      switch (imm_expr.X_add_number)
	{
	case 0:
	  macro_build (NULL, "nop", "");
	  break;
	case 2:
	  macro_build (NULL, "packrl.ph", "d,s,t", op[0], op[0], op[1]);
	  break;
	case 1:
	case 3:
	  macro_build (NULL, "balign", "t,s,2", op[0], op[1],
		       (int) imm_expr.X_add_number);
	  break;
	default:
	  as_bad (_("BALIGN immediate not 0, 1, 2 or 3 (%lu)"),
		  (unsigned long) imm_expr.X_add_number);
	  break;
	}
      break;

    case M_BC1FL:
    case M_BC1TL:
    case M_BC2FL:
    case M_BC2TL:
      gas_assert (mips_opts.micromips);
      macro_build_branch_ccl (mask, &offset_expr,
			      EXTRACT_OPERAND (1, BCC, *ip));
      break;

    case M_BEQ_I:
    case M_BEQL_I:
    case M_BNE_I:
    case M_BNEL_I:
      if (imm_expr.X_add_number == 0)
	op[1] = 0;
      else
	{
	  op[1] = AT;
	  used_at = 1;
	  load_register (op[1], &imm_expr, HAVE_64BIT_GPRS);
	}
      /* Fall through.  */
    case M_BEQL:
    case M_BNEL:
      macro_build_branch_rsrt (mask, &offset_expr, op[0], op[1]);
      break;

    case M_BGEL:
      likely = 1;
    case M_BGE:
      if (op[1] == 0)
	macro_build_branch_rs (likely ? M_BGEZL : M_BGEZ, &offset_expr, op[0]);
      else if (op[0] == 0)
	macro_build_branch_rs (likely ? M_BLEZL : M_BLEZ, &offset_expr, op[1]);
      else
	{
	  used_at = 1;
	  macro_build (NULL, "slt", "d,v,t", AT, op[0], op[1]);
	  macro_build_branch_rsrt (likely ? M_BEQL : M_BEQ,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BGEZL:
    case M_BGEZALL:
    case M_BGTZL:
    case M_BLEZL:
    case M_BLTZL:
    case M_BLTZALL:
      macro_build_branch_rs (mask, &offset_expr, op[0]);
      break;

    case M_BGTL_I:
      likely = 1;
    case M_BGT_I:
      /* Check for > max integer.  */
      if (imm_expr.X_add_number >= GPR_SMAX)
	{
	do_false:
	  /* Result is always false.  */
	  if (! likely)
	    macro_build (NULL, "nop", "");
	  else
	    macro_build_branch_rsrt (M_BNEL, &offset_expr, ZERO, ZERO);
	  break;
	}
      ++imm_expr.X_add_number;
      /* FALLTHROUGH */
    case M_BGE_I:
    case M_BGEL_I:
      if (mask == M_BGEL_I)
	likely = 1;
      if (imm_expr.X_add_number == 0)
	{
	  macro_build_branch_rs (likely ? M_BGEZL : M_BGEZ,
				 &offset_expr, op[0]);
	  break;
	}
      if (imm_expr.X_add_number == 1)
	{
	  macro_build_branch_rs (likely ? M_BGTZL : M_BGTZ,
				 &offset_expr, op[0]);
	  break;
	}
      if (imm_expr.X_add_number <= GPR_SMIN)
	{
	do_true:
	  /* result is always true */
	  as_warn (_("branch %s is always true"), ip->insn_mo->name);
	  macro_build (&offset_expr, "b", "p");
	  break;
	}
      used_at = 1;
      set_at (op[0], 0);
      macro_build_branch_rsrt (likely ? M_BEQL : M_BEQ,
			       &offset_expr, AT, ZERO);
      break;

    case M_BGEUL:
      likely = 1;
    case M_BGEU:
      if (op[1] == 0)
	goto do_true;
      else if (op[0] == 0)
	macro_build_branch_rsrt (likely ? M_BEQL : M_BEQ,
				 &offset_expr, ZERO, op[1]);
      else
	{
	  used_at = 1;
	  macro_build (NULL, "sltu", "d,v,t", AT, op[0], op[1]);
	  macro_build_branch_rsrt (likely ? M_BEQL : M_BEQ,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BGTUL_I:
      likely = 1;
    case M_BGTU_I:
      if (op[0] == 0
	  || (HAVE_32BIT_GPRS
	      && imm_expr.X_add_number == -1))
	goto do_false;
      ++imm_expr.X_add_number;
      /* FALLTHROUGH */
    case M_BGEU_I:
    case M_BGEUL_I:
      if (mask == M_BGEUL_I)
	likely = 1;
      if (imm_expr.X_add_number == 0)
	goto do_true;
      else if (imm_expr.X_add_number == 1)
	macro_build_branch_rsrt (likely ? M_BNEL : M_BNE,
				 &offset_expr, op[0], ZERO);
      else
	{
	  used_at = 1;
	  set_at (op[0], 1);
	  macro_build_branch_rsrt (likely ? M_BEQL : M_BEQ,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BGTL:
      likely = 1;
    case M_BGT:
      if (op[1] == 0)
	macro_build_branch_rs (likely ? M_BGTZL : M_BGTZ, &offset_expr, op[0]);
      else if (op[0] == 0)
	macro_build_branch_rs (likely ? M_BLTZL : M_BLTZ, &offset_expr, op[1]);
      else
	{
	  used_at = 1;
	  macro_build (NULL, "slt", "d,v,t", AT, op[1], op[0]);
	  macro_build_branch_rsrt (likely ? M_BNEL : M_BNE,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BGTUL:
      likely = 1;
    case M_BGTU:
      if (op[1] == 0)
	macro_build_branch_rsrt (likely ? M_BNEL : M_BNE,
				 &offset_expr, op[0], ZERO);
      else if (op[0] == 0)
	goto do_false;
      else
	{
	  used_at = 1;
	  macro_build (NULL, "sltu", "d,v,t", AT, op[1], op[0]);
	  macro_build_branch_rsrt (likely ? M_BNEL : M_BNE,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BLEL:
      likely = 1;
    case M_BLE:
      if (op[1] == 0)
	macro_build_branch_rs (likely ? M_BLEZL : M_BLEZ, &offset_expr, op[0]);
      else if (op[0] == 0)
	macro_build_branch_rs (likely ? M_BGEZL : M_BGEZ, &offset_expr, op[1]);
      else
	{
	  used_at = 1;
	  macro_build (NULL, "slt", "d,v,t", AT, op[1], op[0]);
	  macro_build_branch_rsrt (likely ? M_BEQL : M_BEQ,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BLEL_I:
      likely = 1;
    case M_BLE_I:
      if (imm_expr.X_add_number >= GPR_SMAX)
	goto do_true;
      ++imm_expr.X_add_number;
      /* FALLTHROUGH */
    case M_BLT_I:
    case M_BLTL_I:
      if (mask == M_BLTL_I)
	likely = 1;
      if (imm_expr.X_add_number == 0)
	macro_build_branch_rs (likely ? M_BLTZL : M_BLTZ, &offset_expr, op[0]);
      else if (imm_expr.X_add_number == 1)
	macro_build_branch_rs (likely ? M_BLEZL : M_BLEZ, &offset_expr, op[0]);
      else
	{
	  used_at = 1;
	  set_at (op[0], 0);
	  macro_build_branch_rsrt (likely ? M_BNEL : M_BNE,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BLEUL:
      likely = 1;
    case M_BLEU:
      if (op[1] == 0)
	macro_build_branch_rsrt (likely ? M_BEQL : M_BEQ,
				 &offset_expr, op[0], ZERO);
      else if (op[0] == 0)
	goto do_true;
      else
	{
	  used_at = 1;
	  macro_build (NULL, "sltu", "d,v,t", AT, op[1], op[0]);
	  macro_build_branch_rsrt (likely ? M_BEQL : M_BEQ,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BLEUL_I:
      likely = 1;
    case M_BLEU_I:
      if (op[0] == 0
	  || (HAVE_32BIT_GPRS
	      && imm_expr.X_add_number == -1))
	goto do_true;
      ++imm_expr.X_add_number;
      /* FALLTHROUGH */
    case M_BLTU_I:
    case M_BLTUL_I:
      if (mask == M_BLTUL_I)
	likely = 1;
      if (imm_expr.X_add_number == 0)
	goto do_false;
      else if (imm_expr.X_add_number == 1)
	macro_build_branch_rsrt (likely ? M_BEQL : M_BEQ,
				 &offset_expr, op[0], ZERO);
      else
	{
	  used_at = 1;
	  set_at (op[0], 1);
	  macro_build_branch_rsrt (likely ? M_BNEL : M_BNE,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BLTL:
      likely = 1;
    case M_BLT:
      if (op[1] == 0)
	macro_build_branch_rs (likely ? M_BLTZL : M_BLTZ, &offset_expr, op[0]);
      else if (op[0] == 0)
	macro_build_branch_rs (likely ? M_BGTZL : M_BGTZ, &offset_expr, op[1]);
      else
	{
	  used_at = 1;
	  macro_build (NULL, "slt", "d,v,t", AT, op[0], op[1]);
	  macro_build_branch_rsrt (likely ? M_BNEL : M_BNE,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_BLTUL:
      likely = 1;
    case M_BLTU:
      if (op[1] == 0)
	goto do_false;
      else if (op[0] == 0)
	macro_build_branch_rsrt (likely ? M_BNEL : M_BNE,
				 &offset_expr, ZERO, op[1]);
      else
	{
	  used_at = 1;
	  macro_build (NULL, "sltu", "d,v,t", AT, op[0], op[1]);
	  macro_build_branch_rsrt (likely ? M_BNEL : M_BNE,
				   &offset_expr, AT, ZERO);
	}
      break;

    case M_DDIV_3:
      dbl = 1;
    case M_DIV_3:
      s = "mflo";
      goto do_div3;
    case M_DREM_3:
      dbl = 1;
    case M_REM_3:
      s = "mfhi";
    do_div3:
      if (op[2] == 0)
	{
	  as_warn (_("divide by zero"));
	  if (mips_trap)
	    macro_build (NULL, "teq", TRAP_FMT, ZERO, ZERO, 7);
	  else
	    macro_build (NULL, "break", BRK_FMT, 7);
	  break;
	}

      start_noreorder ();
      if (mips_trap)
	{
	  macro_build (NULL, "teq", TRAP_FMT, op[2], ZERO, 7);
	  macro_build (NULL, dbl ? "ddiv" : "div", "z,s,t", op[1], op[2]);
	}
      else
	{
	  if (mips_opts.micromips)
	    micromips_label_expr (&label_expr);
	  else
	    label_expr.X_add_number = 8;
	  macro_build (&label_expr, "bne", "s,t,p", op[2], ZERO);
	  macro_build (NULL, dbl ? "ddiv" : "div", "z,s,t", op[1], op[2]);
	  macro_build (NULL, "break", BRK_FMT, 7);
	  if (mips_opts.micromips)
	    micromips_add_label ();
	}
      expr1.X_add_number = -1;
      used_at = 1;
      load_register (AT, &expr1, dbl);
      if (mips_opts.micromips)
	micromips_label_expr (&label_expr);
      else
	label_expr.X_add_number = mips_trap ? (dbl ? 12 : 8) : (dbl ? 20 : 16);
      macro_build (&label_expr, "bne", "s,t,p", op[2], AT);
      if (dbl)
	{
	  expr1.X_add_number = 1;
	  load_register (AT, &expr1, dbl);
	  macro_build (NULL, "dsll32", SHFT_FMT, AT, AT, 31);
	}
      else
	{
	  expr1.X_add_number = 0x80000000;
	  macro_build (&expr1, "lui", LUI_FMT, AT, BFD_RELOC_HI16);
	}
      if (mips_trap)
	{
	  macro_build (NULL, "teq", TRAP_FMT, op[1], AT, 6);
	  /* We want to close the noreorder block as soon as possible, so
	     that later insns are available for delay slot filling.  */
	  end_noreorder ();
	}
      else
	{
	  if (mips_opts.micromips)
	    micromips_label_expr (&label_expr);
	  else
	    label_expr.X_add_number = 8;
	  macro_build (&label_expr, "bne", "s,t,p", op[1], AT);
	  macro_build (NULL, "nop", "");

	  /* We want to close the noreorder block as soon as possible, so
	     that later insns are available for delay slot filling.  */
	  end_noreorder ();

	  macro_build (NULL, "break", BRK_FMT, 6);
	}
      if (mips_opts.micromips)
	micromips_add_label ();
      macro_build (NULL, s, MFHL_FMT, op[0]);
      break;

    case M_DIV_3I:
      s = "div";
      s2 = "mflo";
      goto do_divi;
    case M_DIVU_3I:
      s = "divu";
      s2 = "mflo";
      goto do_divi;
    case M_REM_3I:
      s = "div";
      s2 = "mfhi";
      goto do_divi;
    case M_REMU_3I:
      s = "divu";
      s2 = "mfhi";
      goto do_divi;
    case M_DDIV_3I:
      dbl = 1;
      s = "ddiv";
      s2 = "mflo";
      goto do_divi;
    case M_DDIVU_3I:
      dbl = 1;
      s = "ddivu";
      s2 = "mflo";
      goto do_divi;
    case M_DREM_3I:
      dbl = 1;
      s = "ddiv";
      s2 = "mfhi";
      goto do_divi;
    case M_DREMU_3I:
      dbl = 1;
      s = "ddivu";
      s2 = "mfhi";
    do_divi:
      if (imm_expr.X_add_number == 0)
	{
	  as_warn (_("divide by zero"));
	  if (mips_trap)
	    macro_build (NULL, "teq", TRAP_FMT, ZERO, ZERO, 7);
	  else
	    macro_build (NULL, "break", BRK_FMT, 7);
	  break;
	}
      if (imm_expr.X_add_number == 1)
	{
	  if (strcmp (s2, "mflo") == 0)
	    move_register (op[0], op[1]);
	  else
	    move_register (op[0], ZERO);
	  break;
	}
      if (imm_expr.X_add_number == -1 && s[strlen (s) - 1] != 'u')
	{
	  if (strcmp (s2, "mflo") == 0)
	    macro_build (NULL, dbl ? "dneg" : "neg", "d,w", op[0], op[1]);
	  else
	    move_register (op[0], ZERO);
	  break;
	}

      used_at = 1;
      load_register (AT, &imm_expr, dbl);
      macro_build (NULL, s, "z,s,t", op[1], AT);
      macro_build (NULL, s2, MFHL_FMT, op[0]);
      break;

    case M_DIVU_3:
      s = "divu";
      s2 = "mflo";
      goto do_divu3;
    case M_REMU_3:
      s = "divu";
      s2 = "mfhi";
      goto do_divu3;
    case M_DDIVU_3:
      s = "ddivu";
      s2 = "mflo";
      goto do_divu3;
    case M_DREMU_3:
      s = "ddivu";
      s2 = "mfhi";
    do_divu3:
      start_noreorder ();
      if (mips_trap)
	{
	  macro_build (NULL, "teq", TRAP_FMT, op[2], ZERO, 7);
	  macro_build (NULL, s, "z,s,t", op[1], op[2]);
	  /* We want to close the noreorder block as soon as possible, so
	     that later insns are available for delay slot filling.  */
	  end_noreorder ();
	}
      else
	{
	  if (mips_opts.micromips)
	    micromips_label_expr (&label_expr);
	  else
	    label_expr.X_add_number = 8;
	  macro_build (&label_expr, "bne", "s,t,p", op[2], ZERO);
	  macro_build (NULL, s, "z,s,t", op[1], op[2]);

	  /* We want to close the noreorder block as soon as possible, so
	     that later insns are available for delay slot filling.  */
	  end_noreorder ();
	  macro_build (NULL, "break", BRK_FMT, 7);
	  if (mips_opts.micromips)
	    micromips_add_label ();
	}
      macro_build (NULL, s2, MFHL_FMT, op[0]);
      break;

    case M_DLCA_AB:
      dbl = 1;
    case M_LCA_AB:
      call = 1;
      goto do_la;
    case M_DLA_AB:
      dbl = 1;
    case M_LA_AB:
    do_la:
      /* Load the address of a symbol into a register.  If breg is not
	 zero, we then add a base register to it.  */

      breg = op[2];
      if (dbl && HAVE_32BIT_GPRS)
	as_warn (_("dla used to load 32-bit register"));

      if (!dbl && HAVE_64BIT_OBJECTS)
	as_warn (_("la used to load 64-bit address"));

      if (small_offset_p (0, align, 16))
	{
	  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j", op[0], breg,
		       -1, offset_reloc[0], offset_reloc[1], offset_reloc[2]);
	  break;
	}

      if (mips_opts.at && (op[0] == breg))
	{
	  tempreg = AT;
	  used_at = 1;
	}
      else
	tempreg = op[0];

      if (offset_expr.X_op != O_symbol
	  && offset_expr.X_op != O_constant)
	{
	  as_bad (_("expression too complex"));
	  offset_expr.X_op = O_constant;
	}

      if (offset_expr.X_op == O_constant)
	load_register (tempreg, &offset_expr, HAVE_64BIT_ADDRESSES);
      else if (mips_pic == NO_PIC)
	{
	  /* If this is a reference to a GP relative symbol, we want
	       addiu	$tempreg,$gp,<sym>	(BFD_RELOC_GPREL16)
	     Otherwise we want
	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S)
	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)
	     If we have a constant, we need two instructions anyhow,
	     so we may as well always use the latter form.

	     With 64bit address space and a usable $at we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	       lui	$at,<sym>		(BFD_RELOC_HI16_S)
	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	       daddiu	$at,<sym>		(BFD_RELOC_LO16)
	       dsll32	$tempreg,0
	       daddu	$tempreg,$tempreg,$at

	     If $at is already in use, we use a path which is suboptimal
	     on superscalar processors.
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	       dsll	$tempreg,16
	       daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S)
	       dsll	$tempreg,16
	       daddiu	$tempreg,<sym>		(BFD_RELOC_LO16)

	     For GP relative symbols in 64bit address space we can use
	     the same sequence as in 32bit address space.  */
	  if (HAVE_64BIT_SYMBOLS)
	    {
	      if ((valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
		  && !nopic_need_relax (offset_expr.X_add_symbol, 1))
		{
		  relax_start (offset_expr.X_add_symbol);
		  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			       tempreg, mips_gp_register, BFD_RELOC_GPREL16);
		  relax_switch ();
		}

	      if (used_at == 0 && mips_opts.at)
		{
		  macro_build (&offset_expr, "lui", LUI_FMT,
			       tempreg, BFD_RELOC_MIPS_HIGHEST);
		  macro_build (&offset_expr, "lui", LUI_FMT,
			       AT, BFD_RELOC_HI16_S);
		  macro_build (&offset_expr, "daddiu", "t,r,j",
			       tempreg, tempreg, BFD_RELOC_MIPS_HIGHER);
		  macro_build (&offset_expr, "daddiu", "t,r,j",
			       AT, AT, BFD_RELOC_LO16);
		  macro_build (NULL, "dsll32", SHFT_FMT, tempreg, tempreg, 0);
		  macro_build (NULL, "daddu", "d,v,t", tempreg, tempreg, AT);
		  used_at = 1;
		}
	      else
		{
		  macro_build (&offset_expr, "lui", LUI_FMT,
			       tempreg, BFD_RELOC_MIPS_HIGHEST);
		  macro_build (&offset_expr, "daddiu", "t,r,j",
			       tempreg, tempreg, BFD_RELOC_MIPS_HIGHER);
		  macro_build (NULL, "dsll", SHFT_FMT, tempreg, tempreg, 16);
		  macro_build (&offset_expr, "daddiu", "t,r,j",
			       tempreg, tempreg, BFD_RELOC_HI16_S);
		  macro_build (NULL, "dsll", SHFT_FMT, tempreg, tempreg, 16);
		  macro_build (&offset_expr, "daddiu", "t,r,j",
			       tempreg, tempreg, BFD_RELOC_LO16);
		}

	      if (mips_relax.sequence)
		relax_end ();
	    }
	  else
	    {
	      if ((valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
		  && !nopic_need_relax (offset_expr.X_add_symbol, 1))
		{
		  relax_start (offset_expr.X_add_symbol);
		  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			       tempreg, mips_gp_register, BFD_RELOC_GPREL16);
		  relax_switch ();
		}
	      if (!IS_SEXT_32BIT_NUM (offset_expr.X_add_number))
		as_bad (_("offset too large"));
	      macro_build_lui (&offset_expr, tempreg);
	      macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			   tempreg, tempreg, BFD_RELOC_LO16);
	      if (mips_relax.sequence)
		relax_end ();
	    }
	}
      else if (!mips_big_got && !HAVE_NEWABI)
	{
	  int lw_reloc_type = (int) BFD_RELOC_MIPS_GOT16;

	  /* If this is a reference to an external symbol, and there
	     is no constant, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	     or for lca or if tempreg is PIC_CALL_REG
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_CALL16)
	     For a local symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	       nop
	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)

	     If we have a small constant, and this is a reference to
	     an external symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	       nop
	       addiu	$tempreg,$tempreg,<constant>
	     For a local symbol, we want the same instruction
	     sequence, but we output a BFD_RELOC_LO16 reloc on the
	     addiu instruction.

	     If we have a large constant, and this is a reference to
	     an external symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	       lui	$at,<hiconstant>
	       addiu	$at,$at,<loconstant>
	       addu	$tempreg,$tempreg,$at
	     For a local symbol, we want the same instruction
	     sequence, but we output a BFD_RELOC_LO16 reloc on the
	     addiu instruction.
	   */

	  if (offset_expr.X_add_number == 0)
	    {
	      if (mips_pic == SVR4_PIC
		  && breg == 0
		  && (call || tempreg == PIC_CALL_REG))
		lw_reloc_type = (int) BFD_RELOC_MIPS_CALL16;

	      relax_start (offset_expr.X_add_symbol);
	      macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   lw_reloc_type, mips_gp_register);
	      if (breg != 0)
		{
		  /* We're going to put in an addu instruction using
		     tempreg, so we may as well insert the nop right
		     now.  */
		  load_delay_nop ();
		}
	      relax_switch ();
	      macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
			   tempreg, BFD_RELOC_MIPS_GOT16, mips_gp_register);
	      load_delay_nop ();
	      macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			   tempreg, tempreg, BFD_RELOC_LO16);
	      relax_end ();
	      /* FIXME: If breg == 0, and the next instruction uses
		 $tempreg, then if this variant case is used an extra
		 nop will be generated.  */
	    }
	  else if (offset_expr.X_add_number >= -0x8000
		   && offset_expr.X_add_number < 0x8000)
	    {
	      load_got_offset (tempreg, &offset_expr);
	      load_delay_nop ();
	      add_got_offset (tempreg, &offset_expr);
	    }
	  else
	    {
	      expr1.X_add_number = offset_expr.X_add_number;
	      offset_expr.X_add_number =
		SEXT_16BIT (offset_expr.X_add_number);
	      load_got_offset (tempreg, &offset_expr);
	      offset_expr.X_add_number = expr1.X_add_number;
	      /* If we are going to add in a base register, and the
		 target register and the base register are the same,
		 then we are using AT as a temporary register.  Since
		 we want to load the constant into AT, we add our
		 current AT (from the global offset table) and the
		 register into the register now, and pretend we were
		 not using a base register.  */
	      if (breg == op[0])
		{
		  load_delay_nop ();
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			       op[0], AT, breg);
		  breg = 0;
		  tempreg = op[0];
		}
	      add_got_offset_hilo (tempreg, &offset_expr, AT);
	      used_at = 1;
	    }
	}
      else if (!mips_big_got && HAVE_NEWABI)
	{
	  int add_breg_early = 0;

	  /* If this is a reference to an external, and there is no
	     constant, or local symbol (*), with or without a
	     constant, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP)
	     or for lca or if tempreg is PIC_CALL_REG
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_CALL16)

	     If we have a small constant, and this is a reference to
	     an external symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP)
	       addiu	$tempreg,$tempreg,<constant>

	     If we have a large constant, and this is a reference to
	     an external symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP)
	       lui	$at,<hiconstant>
	       addiu	$at,$at,<loconstant>
	       addu	$tempreg,$tempreg,$at

	     (*) Other assemblers seem to prefer GOT_PAGE/GOT_OFST for
	     local symbols, even though it introduces an additional
	     instruction.  */

	  if (offset_expr.X_add_number)
	    {
	      expr1.X_add_number = offset_expr.X_add_number;
	      offset_expr.X_add_number = 0;

	      relax_start (offset_expr.X_add_symbol);
	      macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);

	      if (expr1.X_add_number >= -0x8000
		  && expr1.X_add_number < 0x8000)
		{
		  macro_build (&expr1, ADDRESS_ADDI_INSN, "t,r,j",
			       tempreg, tempreg, BFD_RELOC_LO16);
		}
	      else if (IS_SEXT_32BIT_NUM (expr1.X_add_number + 0x8000))
		{
		  unsigned int dreg;

		  /* If we are going to add in a base register, and the
		     target register and the base register are the same,
		     then we are using AT as a temporary register.  Since
		     we want to load the constant into AT, we add our
		     current AT (from the global offset table) and the
		     register into the register now, and pretend we were
		     not using a base register.  */
		  if (breg != op[0])
		    dreg = tempreg;
		  else
		    {
		      gas_assert (tempreg == AT);
		      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
				   op[0], AT, breg);
		      dreg = op[0];
		      add_breg_early = 1;
		    }

		  load_register (AT, &expr1, HAVE_64BIT_ADDRESSES);
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			       dreg, dreg, AT);

		  used_at = 1;
		}
	      else
		as_bad (_("PIC code offset overflow (max 32 signed bits)"));

	      relax_switch ();
	      offset_expr.X_add_number = expr1.X_add_number;

	      macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);
	      if (add_breg_early)
		{
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			       op[0], tempreg, breg);
		  breg = 0;
		  tempreg = op[0];
		}
	      relax_end ();
	    }
	  else if (breg == 0 && (call || tempreg == PIC_CALL_REG))
	    {
	      relax_start (offset_expr.X_add_symbol);
	      macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   BFD_RELOC_MIPS_CALL16, mips_gp_register);
	      relax_switch ();
	      macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);
	      relax_end ();
	    }
	  else
	    {
	      macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);
	    }
	}
      else if (mips_big_got && !HAVE_NEWABI)
	{
	  int gpdelay;
	  int lui_reloc_type = (int) BFD_RELOC_MIPS_GOT_HI16;
	  int lw_reloc_type = (int) BFD_RELOC_MIPS_GOT_LO16;
	  int local_reloc_type = (int) BFD_RELOC_MIPS_GOT16;

	  /* This is the large GOT case.  If this is a reference to an
	     external symbol, and there is no constant, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	       addu	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
	     or for lca or if tempreg is PIC_CALL_REG
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_CALL_HI16)
	       addu	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_CALL_LO16)
	     For a local symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	       nop
	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)

	     If we have a small constant, and this is a reference to
	     an external symbol, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	       addu	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
	       nop
	       addiu	$tempreg,$tempreg,<constant>
	     For a local symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	       nop
	       addiu	$tempreg,$tempreg,<constant> (BFD_RELOC_LO16)

	     If we have a large constant, and this is a reference to
	     an external symbol, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	       addu	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
	       lui	$at,<hiconstant>
	       addiu	$at,$at,<loconstant>
	       addu	$tempreg,$tempreg,$at
	     For a local symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	       lui	$at,<hiconstant>
	       addiu	$at,$at,<loconstant>	(BFD_RELOC_LO16)
	       addu	$tempreg,$tempreg,$at
	  */

	  expr1.X_add_number = offset_expr.X_add_number;
	  offset_expr.X_add_number = 0;
	  relax_start (offset_expr.X_add_symbol);
	  gpdelay = reg_needs_delay (mips_gp_register);
	  if (expr1.X_add_number == 0 && breg == 0
	      && (call || tempreg == PIC_CALL_REG))
	    {
	      lui_reloc_type = (int) BFD_RELOC_MIPS_CALL_HI16;
	      lw_reloc_type = (int) BFD_RELOC_MIPS_CALL_LO16;
	    }
	  macro_build (&offset_expr, "lui", LUI_FMT, tempreg, lui_reloc_type);
	  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
		       tempreg, tempreg, mips_gp_register);
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, lw_reloc_type, tempreg);
	  if (expr1.X_add_number == 0)
	    {
	      if (breg != 0)
		{
		  /* We're going to put in an addu instruction using
		     tempreg, so we may as well insert the nop right
		     now.  */
		  load_delay_nop ();
		}
	    }
	  else if (expr1.X_add_number >= -0x8000
		   && expr1.X_add_number < 0x8000)
	    {
	      load_delay_nop ();
	      macro_build (&expr1, ADDRESS_ADDI_INSN, "t,r,j",
			   tempreg, tempreg, BFD_RELOC_LO16);
	    }
	  else
	    {
	      unsigned int dreg;

	      /* If we are going to add in a base register, and the
		 target register and the base register are the same,
		 then we are using AT as a temporary register.  Since
		 we want to load the constant into AT, we add our
		 current AT (from the global offset table) and the
		 register into the register now, and pretend we were
		 not using a base register.  */
	      if (breg != op[0])
		dreg = tempreg;
	      else
		{
		  gas_assert (tempreg == AT);
		  load_delay_nop ();
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			       op[0], AT, breg);
		  dreg = op[0];
		}

	      load_register (AT, &expr1, HAVE_64BIT_ADDRESSES);
	      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", dreg, dreg, AT);

	      used_at = 1;
	    }
	  offset_expr.X_add_number = SEXT_16BIT (expr1.X_add_number);
	  relax_switch ();

	  if (gpdelay)
	    {
	      /* This is needed because this instruction uses $gp, but
		 the first instruction on the main stream does not.  */
	      macro_build (NULL, "nop", "");
	    }

	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
		       local_reloc_type, mips_gp_register);
	  if (expr1.X_add_number >= -0x8000
	      && expr1.X_add_number < 0x8000)
	    {
	      load_delay_nop ();
	      macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			   tempreg, tempreg, BFD_RELOC_LO16);
	      /* FIXME: If add_number is 0, and there was no base
		 register, the external symbol case ended with a load,
		 so if the symbol turns out to not be external, and
		 the next instruction uses tempreg, an unnecessary nop
		 will be inserted.  */
	    }
	  else
	    {
	      if (breg == op[0])
		{
		  /* We must add in the base register now, as in the
		     external symbol case.  */
		  gas_assert (tempreg == AT);
		  load_delay_nop ();
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			       op[0], AT, breg);
		  tempreg = op[0];
		  /* We set breg to 0 because we have arranged to add
		     it in in both cases.  */
		  breg = 0;
		}

	      macro_build_lui (&expr1, AT);
	      macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			   AT, AT, BFD_RELOC_LO16);
	      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			   tempreg, tempreg, AT);
	      used_at = 1;
	    }
	  relax_end ();
	}
      else if (mips_big_got && HAVE_NEWABI)
	{
	  int lui_reloc_type = (int) BFD_RELOC_MIPS_GOT_HI16;
	  int lw_reloc_type = (int) BFD_RELOC_MIPS_GOT_LO16;
	  int add_breg_early = 0;

	  /* This is the large GOT case.  If this is a reference to an
	     external symbol, and there is no constant, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	       add	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
	     or for lca or if tempreg is PIC_CALL_REG
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_CALL_HI16)
	       add	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_CALL_LO16)

	     If we have a small constant, and this is a reference to
	     an external symbol, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	       add	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
	       addi	$tempreg,$tempreg,<constant>

	     If we have a large constant, and this is a reference to
	     an external symbol, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	       addu	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
	       lui	$at,<hiconstant>
	       addi	$at,$at,<loconstant>
	       add	$tempreg,$tempreg,$at

	     If we have NewABI, and we know it's a local symbol, we want
	       lw	$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT_PAGE)
	       addiu	$reg,$reg,<sym>		(BFD_RELOC_MIPS_GOT_OFST)
	     otherwise we have to resort to GOT_HI16/GOT_LO16.  */

	  relax_start (offset_expr.X_add_symbol);

	  expr1.X_add_number = offset_expr.X_add_number;
	  offset_expr.X_add_number = 0;

	  if (expr1.X_add_number == 0 && breg == 0
	      && (call || tempreg == PIC_CALL_REG))
	    {
	      lui_reloc_type = (int) BFD_RELOC_MIPS_CALL_HI16;
	      lw_reloc_type = (int) BFD_RELOC_MIPS_CALL_LO16;
	    }
	  macro_build (&offset_expr, "lui", LUI_FMT, tempreg, lui_reloc_type);
	  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
		       tempreg, tempreg, mips_gp_register);
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, lw_reloc_type, tempreg);

	  if (expr1.X_add_number == 0)
	    ;
	  else if (expr1.X_add_number >= -0x8000
		   && expr1.X_add_number < 0x8000)
	    {
	      macro_build (&expr1, ADDRESS_ADDI_INSN, "t,r,j",
			   tempreg, tempreg, BFD_RELOC_LO16);
	    }
	  else if (IS_SEXT_32BIT_NUM (expr1.X_add_number + 0x8000))
	    {
	      unsigned int dreg;

	      /* If we are going to add in a base register, and the
		 target register and the base register are the same,
		 then we are using AT as a temporary register.  Since
		 we want to load the constant into AT, we add our
		 current AT (from the global offset table) and the
		 register into the register now, and pretend we were
		 not using a base register.  */
	      if (breg != op[0])
		dreg = tempreg;
	      else
		{
		  gas_assert (tempreg == AT);
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			       op[0], AT, breg);
		  dreg = op[0];
		  add_breg_early = 1;
		}

	      load_register (AT, &expr1, HAVE_64BIT_ADDRESSES);
	      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", dreg, dreg, AT);

	      used_at = 1;
	    }
	  else
	    as_bad (_("PIC code offset overflow (max 32 signed bits)"));

	  relax_switch ();
	  offset_expr.X_add_number = expr1.X_add_number;
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
		       BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
	  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j", tempreg,
		       tempreg, BFD_RELOC_MIPS_GOT_OFST);
	  if (add_breg_early)
	    {
	      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			   op[0], tempreg, breg);
	      breg = 0;
	      tempreg = op[0];
	    }
	  relax_end ();
	}
      else
	abort ();

      if (breg != 0)
	macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", op[0], tempreg, breg);
      break;

    case M_MSGSND:
      gas_assert (!mips_opts.micromips);
      macro_build (NULL, "c2", "C", (op[0] << 16) | 0x01);
      break;

    case M_MSGLD:
      gas_assert (!mips_opts.micromips);
      macro_build (NULL, "c2", "C", 0x02);
      break;

    case M_MSGLD_T:
      gas_assert (!mips_opts.micromips);
      macro_build (NULL, "c2", "C", (op[0] << 16) | 0x02);
      break;

    case M_MSGWAIT:
      gas_assert (!mips_opts.micromips);
      macro_build (NULL, "c2", "C", 3);
      break;

    case M_MSGWAIT_T:
      gas_assert (!mips_opts.micromips);
      macro_build (NULL, "c2", "C", (op[0] << 16) | 0x03);
      break;

    case M_J_A:
      /* The j instruction may not be used in PIC code, since it
	 requires an absolute address.  We convert it to a b
	 instruction.  */
      if (mips_pic == NO_PIC)
	macro_build (&offset_expr, "j", "a");
      else
	macro_build (&offset_expr, "b", "p");
      break;

      /* The jal instructions must be handled as macros because when
	 generating PIC code they expand to multi-instruction
	 sequences.  Normally they are simple instructions.  */
    case M_JALS_1:
      op[1] = op[0];
      op[0] = RA;
      /* Fall through.  */
    case M_JALS_2:
      gas_assert (mips_opts.micromips);
      if (mips_opts.insn32)
	{
	  as_bad (_("opcode not supported in the `insn32' mode `%s'"), str);
	  break;
	}
      jals = 1;
      goto jal;
    case M_JAL_1:
      op[1] = op[0];
      op[0] = RA;
      /* Fall through.  */
    case M_JAL_2:
    jal:
      if (mips_pic == NO_PIC)
	{
	  s = jals ? "jalrs" : "jalr";
	  if (mips_opts.micromips
	      && !mips_opts.insn32
	      && op[0] == RA
	      && !(history[0].insn_mo->pinfo2 & INSN2_BRANCH_DELAY_32BIT))
	    macro_build (NULL, s, "mj", op[1]);
	  else
	    macro_build (NULL, s, JALR_FMT, op[0], op[1]);
	}
      else
	{
	  int cprestore = (mips_pic == SVR4_PIC && !HAVE_NEWABI
			   && mips_cprestore_offset >= 0);

	  if (op[1] != PIC_CALL_REG)
	    as_warn (_("MIPS PIC call to register other than $25"));

	  s = ((mips_opts.micromips
		&& !mips_opts.insn32
		&& (!mips_opts.noreorder || cprestore))
	       ? "jalrs" : "jalr");
	  if (mips_opts.micromips
	      && !mips_opts.insn32
	      && op[0] == RA
	      && !(history[0].insn_mo->pinfo2 & INSN2_BRANCH_DELAY_32BIT))
	    macro_build (NULL, s, "mj", op[1]);
	  else
	    macro_build (NULL, s, JALR_FMT, op[0], op[1]);
	  if (mips_pic == SVR4_PIC && !HAVE_NEWABI)
	    {
	      if (mips_cprestore_offset < 0)
		as_warn (_("no .cprestore pseudo-op used in PIC code"));
	      else
		{
		  if (!mips_frame_reg_valid)
		    {
		      as_warn (_("no .frame pseudo-op used in PIC code"));
		      /* Quiet this warning.  */
		      mips_frame_reg_valid = 1;
		    }
		  if (!mips_cprestore_valid)
		    {
		      as_warn (_("no .cprestore pseudo-op used in PIC code"));
		      /* Quiet this warning.  */
		      mips_cprestore_valid = 1;
		    }
		  if (mips_opts.noreorder)
		    macro_build (NULL, "nop", "");
		  expr1.X_add_number = mips_cprestore_offset;
  		  macro_build_ldst_constoffset (&expr1, ADDRESS_LOAD_INSN,
						mips_gp_register,
						mips_frame_reg,
						HAVE_64BIT_ADDRESSES);
		}
	    }
	}

      break;

    case M_JALS_A:
      gas_assert (mips_opts.micromips);
      if (mips_opts.insn32)
	{
	  as_bad (_("opcode not supported in the `insn32' mode `%s'"), str);
	  break;
	}
      jals = 1;
      /* Fall through.  */
    case M_JAL_A:
      if (mips_pic == NO_PIC)
	macro_build (&offset_expr, jals ? "jals" : "jal", "a");
      else if (mips_pic == SVR4_PIC)
	{
	  /* If this is a reference to an external symbol, and we are
	     using a small GOT, we want
	       lw	$25,<sym>($gp)		(BFD_RELOC_MIPS_CALL16)
	       nop
	       jalr	$ra,$25
	       nop
	       lw	$gp,cprestore($sp)
	     The cprestore value is set using the .cprestore
	     pseudo-op.  If we are using a big GOT, we want
	       lui	$25,<sym>		(BFD_RELOC_MIPS_CALL_HI16)
	       addu	$25,$25,$gp
	       lw	$25,<sym>($25)		(BFD_RELOC_MIPS_CALL_LO16)
	       nop
	       jalr	$ra,$25
	       nop
	       lw	$gp,cprestore($sp)
	     If the symbol is not external, we want
	       lw	$25,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
	       nop
	       addiu	$25,$25,<sym>		(BFD_RELOC_LO16)
	       jalr	$ra,$25
	       nop
	       lw $gp,cprestore($sp)

	     For NewABI, we use the same CALL16 or CALL_HI16/CALL_LO16
	     sequences above, minus nops, unless the symbol is local,
	     which enables us to use GOT_PAGE/GOT_OFST (big got) or
	     GOT_DISP.  */
	  if (HAVE_NEWABI)
	    {
	      if (!mips_big_got)
		{
		  relax_start (offset_expr.X_add_symbol);
		  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
			       PIC_CALL_REG, BFD_RELOC_MIPS_CALL16,
			       mips_gp_register);
		  relax_switch ();
		  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
			       PIC_CALL_REG, BFD_RELOC_MIPS_GOT_DISP,
			       mips_gp_register);
		  relax_end ();
		}
	      else
		{
		  relax_start (offset_expr.X_add_symbol);
		  macro_build (&offset_expr, "lui", LUI_FMT, PIC_CALL_REG,
			       BFD_RELOC_MIPS_CALL_HI16);
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", PIC_CALL_REG,
			       PIC_CALL_REG, mips_gp_register);
		  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
			       PIC_CALL_REG, BFD_RELOC_MIPS_CALL_LO16,
			       PIC_CALL_REG);
		  relax_switch ();
		  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
			       PIC_CALL_REG, BFD_RELOC_MIPS_GOT_PAGE,
			       mips_gp_register);
		  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			       PIC_CALL_REG, PIC_CALL_REG,
			       BFD_RELOC_MIPS_GOT_OFST);
		  relax_end ();
		}

	      macro_build_jalr (&offset_expr, 0);
	    }
	  else
	    {
	      relax_start (offset_expr.X_add_symbol);
	      if (!mips_big_got)
		{
		  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
			       PIC_CALL_REG, BFD_RELOC_MIPS_CALL16,
			       mips_gp_register);
		  load_delay_nop ();
		  relax_switch ();
		}
	      else
		{
		  int gpdelay;

		  gpdelay = reg_needs_delay (mips_gp_register);
		  macro_build (&offset_expr, "lui", LUI_FMT, PIC_CALL_REG,
			       BFD_RELOC_MIPS_CALL_HI16);
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", PIC_CALL_REG,
			       PIC_CALL_REG, mips_gp_register);
		  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
			       PIC_CALL_REG, BFD_RELOC_MIPS_CALL_LO16,
			       PIC_CALL_REG);
		  load_delay_nop ();
		  relax_switch ();
		  if (gpdelay)
		    macro_build (NULL, "nop", "");
		}
	      macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
			   PIC_CALL_REG, BFD_RELOC_MIPS_GOT16,
			   mips_gp_register);
	      load_delay_nop ();
	      macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			   PIC_CALL_REG, PIC_CALL_REG, BFD_RELOC_LO16);
	      relax_end ();
	      macro_build_jalr (&offset_expr, mips_cprestore_offset >= 0);

	      if (mips_cprestore_offset < 0)
		as_warn (_("no .cprestore pseudo-op used in PIC code"));
	      else
		{
		  if (!mips_frame_reg_valid)
		    {
		      as_warn (_("no .frame pseudo-op used in PIC code"));
		      /* Quiet this warning.  */
		      mips_frame_reg_valid = 1;
		    }
		  if (!mips_cprestore_valid)
		    {
		      as_warn (_("no .cprestore pseudo-op used in PIC code"));
		      /* Quiet this warning.  */
		      mips_cprestore_valid = 1;
		    }
		  if (mips_opts.noreorder)
		    macro_build (NULL, "nop", "");
		  expr1.X_add_number = mips_cprestore_offset;
  		  macro_build_ldst_constoffset (&expr1, ADDRESS_LOAD_INSN,
						mips_gp_register,
						mips_frame_reg,
						HAVE_64BIT_ADDRESSES);
		}
	    }
	}
      else if (mips_pic == VXWORKS_PIC)
	as_bad (_("non-PIC jump used in PIC library"));
      else
	abort ();

      break;

    case M_LBUE_AB:
      s = "lbue";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_LHUE_AB:
      s = "lhue";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_LBE_AB:
      s = "lbe";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_LHE_AB:
      s = "lhe";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_LLE_AB:
      s = "lle";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_LWE_AB:
      s = "lwe";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_LWLE_AB:
      s = "lwle";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_LWRE_AB:
      s = "lwre";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_SBE_AB:
      s = "sbe";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_SCE_AB:
      s = "sce";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_SHE_AB:
      s = "she";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_SWE_AB:
      s = "swe";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_SWLE_AB:
      s = "swle";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_SWRE_AB:
      s = "swre";
      fmt = "t,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_ACLR_AB:
      s = "aclr";
      fmt = "\\,~(b)";
      offbits = 12;
      goto ld_st;
    case M_ASET_AB:
      s = "aset";
      fmt = "\\,~(b)";
      offbits = 12;
      goto ld_st;
    case M_LB_AB:
      s = "lb";
      fmt = "t,o(b)";
      goto ld;
    case M_LBU_AB:
      s = "lbu";
      fmt = "t,o(b)";
      goto ld;
    case M_LH_AB:
      s = "lh";
      fmt = "t,o(b)";
      goto ld;
    case M_LHU_AB:
      s = "lhu";
      fmt = "t,o(b)";
      goto ld;
    case M_LW_AB:
      s = "lw";
      fmt = "t,o(b)";
      goto ld;
    case M_LWC0_AB:
      gas_assert (!mips_opts.micromips);
      s = "lwc0";
      fmt = "E,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_LWC1_AB:
      s = "lwc1";
      fmt = "T,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_LWC2_AB:
      s = "lwc2";
      fmt = COP12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_LWC3_AB:
      gas_assert (!mips_opts.micromips);
      s = "lwc3";
      fmt = "E,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_LWL_AB:
      s = "lwl";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_LWR_AB:
      s = "lwr";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_LDC1_AB:
      s = "ldc1";
      fmt = "T,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_LDC2_AB:
      s = "ldc2";
      fmt = COP12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_LQC2_AB:
      s = "lqc2";
      fmt = "+7,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_LDC3_AB:
      s = "ldc3";
      fmt = "E,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_LDL_AB:
      s = "ldl";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_LDR_AB:
      s = "ldr";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_LL_AB:
      s = "ll";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld;
    case M_LLD_AB:
      s = "lld";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld;
    case M_LWU_AB:
      s = "lwu";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld;
    case M_LWP_AB:
      gas_assert (mips_opts.micromips);
      s = "lwp";
      fmt = "t,~(b)";
      offbits = 12;
      lp = 1;
      goto ld;
    case M_LDP_AB:
      gas_assert (mips_opts.micromips);
      s = "ldp";
      fmt = "t,~(b)";
      offbits = 12;
      lp = 1;
      goto ld;
    case M_LWM_AB:
      gas_assert (mips_opts.micromips);
      s = "lwm";
      fmt = "n,~(b)";
      offbits = 12;
      goto ld_st;
    case M_LDM_AB:
      gas_assert (mips_opts.micromips);
      s = "ldm";
      fmt = "n,~(b)";
      offbits = 12;
      goto ld_st;

    ld:
      /* We don't want to use $0 as tempreg.  */
      if (op[2] == op[0] + lp || op[0] + lp == ZERO)
	goto ld_st;
      else
	tempreg = op[0] + lp;
      goto ld_noat;

    case M_SB_AB:
      s = "sb";
      fmt = "t,o(b)";
      goto ld_st;
    case M_SH_AB:
      s = "sh";
      fmt = "t,o(b)";
      goto ld_st;
    case M_SW_AB:
      s = "sw";
      fmt = "t,o(b)";
      goto ld_st;
    case M_SWC0_AB:
      gas_assert (!mips_opts.micromips);
      s = "swc0";
      fmt = "E,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_SWC1_AB:
      s = "swc1";
      fmt = "T,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_SWC2_AB:
      s = "swc2";
      fmt = COP12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_SWC3_AB:
      gas_assert (!mips_opts.micromips);
      s = "swc3";
      fmt = "E,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_SWL_AB:
      s = "swl";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_SWR_AB:
      s = "swr";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_SC_AB:
      s = "sc";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_SCD_AB:
      s = "scd";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_CACHE_AB:
      s = "cache";
      fmt = mips_opts.micromips ? "k,~(b)" : "k,o(b)";
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_CACHEE_AB:
      s = "cachee";
      fmt = "k,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_PREF_AB:
      s = "pref";
      fmt = !mips_opts.micromips ? "k,o(b)" : "k,~(b)";
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_PREFE_AB:
      s = "prefe";
      fmt = "k,+j(b)";
      offbits = 9;
      goto ld_st;
    case M_SDC1_AB:
      s = "sdc1";
      fmt = "T,o(b)";
      coproc = 1;
      /* Itbl support may require additional care here.  */
      goto ld_st;
    case M_SDC2_AB:
      s = "sdc2";
      fmt = COP12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_SQC2_AB:
      s = "sqc2";
      fmt = "+7,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_SDC3_AB:
      gas_assert (!mips_opts.micromips);
      s = "sdc3";
      fmt = "E,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
      goto ld_st;
    case M_SDL_AB:
      s = "sdl";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_SDR_AB:
      s = "sdr";
      fmt = MEM12_FMT;
      offbits = (mips_opts.micromips ? 12 : 16);
      goto ld_st;
    case M_SWP_AB:
      gas_assert (mips_opts.micromips);
      s = "swp";
      fmt = "t,~(b)";
      offbits = 12;
      goto ld_st;
    case M_SDP_AB:
      gas_assert (mips_opts.micromips);
      s = "sdp";
      fmt = "t,~(b)";
      offbits = 12;
      goto ld_st;
    case M_SWM_AB:
      gas_assert (mips_opts.micromips);
      s = "swm";
      fmt = "n,~(b)";
      offbits = 12;
      goto ld_st;
    case M_SDM_AB:
      gas_assert (mips_opts.micromips);
      s = "sdm";
      fmt = "n,~(b)";
      offbits = 12;

    ld_st:
      tempreg = AT;
    ld_noat:
      breg = op[2];
      if (small_offset_p (0, align, 16))
	{
	  /* The first case exists for M_LD_AB and M_SD_AB, which are
	     macros for o32 but which should act like normal instructions
	     otherwise.  */
	  if (offbits == 16)
	    macro_build (&offset_expr, s, fmt, op[0], -1, offset_reloc[0],
			 offset_reloc[1], offset_reloc[2], breg);
	  else if (small_offset_p (0, align, offbits))
	    {
	      if (offbits == 0)
		macro_build (NULL, s, fmt, op[0], breg);
	      else
		macro_build (NULL, s, fmt, op[0],
			     (int) offset_expr.X_add_number, breg);
	    }
	  else
	    {
	      if (tempreg == AT)
		used_at = 1;
	      macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			   tempreg, breg, -1, offset_reloc[0],
			   offset_reloc[1], offset_reloc[2]);
	      if (offbits == 0)
		macro_build (NULL, s, fmt, op[0], tempreg);
	      else
		macro_build (NULL, s, fmt, op[0], 0, tempreg);
	    }
	  break;
	}

      if (tempreg == AT)
	used_at = 1;

      if (offset_expr.X_op != O_constant
	  && offset_expr.X_op != O_symbol)
	{
	  as_bad (_("expression too complex"));
	  offset_expr.X_op = O_constant;
	}

      if (HAVE_32BIT_ADDRESSES
	  && !IS_SEXT_32BIT_NUM (offset_expr.X_add_number))
	{
	  char value [32];

	  sprintf_vma (value, offset_expr.X_add_number);
	  as_bad (_("number (0x%s) larger than 32 bits"), value);
	}

      /* A constant expression in PIC code can be handled just as it
	 is in non PIC code.  */
      if (offset_expr.X_op == O_constant)
	{
	  expr1.X_add_number = offset_high_part (offset_expr.X_add_number,
						 offbits == 0 ? 16 : offbits);
	  offset_expr.X_add_number -= expr1.X_add_number;

	  load_register (tempreg, &expr1, HAVE_64BIT_ADDRESSES);
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			 tempreg, tempreg, breg);
	  if (offbits == 0)
	    {
	      if (offset_expr.X_add_number != 0)
		macro_build (&offset_expr, ADDRESS_ADDI_INSN,
			     "t,r,j", tempreg, tempreg, BFD_RELOC_LO16);
	      macro_build (NULL, s, fmt, op[0], tempreg);
	    }
	  else if (offbits == 16)
	    macro_build (&offset_expr, s, fmt, op[0], BFD_RELOC_LO16, tempreg);
	  else
	    macro_build (NULL, s, fmt, op[0],
			 (int) offset_expr.X_add_number, tempreg);
	}
      else if (offbits != 16)
	{
	  /* The offset field is too narrow to be used for a low-part
	     relocation, so load the whole address into the auxillary
	     register.  */
	  load_address (tempreg, &offset_expr, &used_at);
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			 tempreg, tempreg, breg);
	  if (offbits == 0)
	    macro_build (NULL, s, fmt, op[0], tempreg);
	  else
	    macro_build (NULL, s, fmt, op[0], 0, tempreg);
	}
      else if (mips_pic == NO_PIC)
	{
	  /* If this is a reference to a GP relative symbol, and there
	     is no base register, we want
	       <op>	op[0],<sym>($gp)	(BFD_RELOC_GPREL16)
	     Otherwise, if there is no base register, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S)
	       <op>	op[0],<sym>($tempreg)	(BFD_RELOC_LO16)
	     If we have a constant, we need two instructions anyhow,
	     so we always use the latter form.

	     If we have a base register, and this is a reference to a
	     GP relative symbol, we want
	       addu	$tempreg,$breg,$gp
	       <op>	op[0],<sym>($tempreg)	(BFD_RELOC_GPREL16)
	     Otherwise we want
	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S)
	       addu	$tempreg,$tempreg,$breg
	       <op>	op[0],<sym>($tempreg)	(BFD_RELOC_LO16)
	     With a constant we always use the latter case.

	     With 64bit address space and no base register and $at usable,
	     we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	       lui	$at,<sym>		(BFD_RELOC_HI16_S)
	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	       dsll32	$tempreg,0
	       daddu	$tempreg,$at
	       <op>	op[0],<sym>($tempreg)	(BFD_RELOC_LO16)
	     If we have a base register, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	       lui	$at,<sym>		(BFD_RELOC_HI16_S)
	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	       daddu	$at,$breg
	       dsll32	$tempreg,0
	       daddu	$tempreg,$at
	       <op>	op[0],<sym>($tempreg)	(BFD_RELOC_LO16)

	     Without $at we can't generate the optimal path for superscalar
	     processors here since this would require two temporary registers.
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	       dsll	$tempreg,16
	       daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S)
	       dsll	$tempreg,16
	       <op>	op[0],<sym>($tempreg)	(BFD_RELOC_LO16)
	     If we have a base register, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	       dsll	$tempreg,16
	       daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S)
	       dsll	$tempreg,16
	       daddu	$tempreg,$tempreg,$breg
	       <op>	op[0],<sym>($tempreg)	(BFD_RELOC_LO16)

	     For GP relative symbols in 64bit address space we can use
	     the same sequence as in 32bit address space.  */
	  if (HAVE_64BIT_SYMBOLS)
	    {
	      if ((valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
		  && !nopic_need_relax (offset_expr.X_add_symbol, 1))
		{
		  relax_start (offset_expr.X_add_symbol);
		  if (breg == 0)
		    {
		      macro_build (&offset_expr, s, fmt, op[0],
				   BFD_RELOC_GPREL16, mips_gp_register);
		    }
		  else
		    {
		      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
				   tempreg, breg, mips_gp_register);
		      macro_build (&offset_expr, s, fmt, op[0],
				   BFD_RELOC_GPREL16, tempreg);
		    }
		  relax_switch ();
		}

	      if (used_at == 0 && mips_opts.at)
		{
		  macro_build (&offset_expr, "lui", LUI_FMT, tempreg,
			       BFD_RELOC_MIPS_HIGHEST);
		  macro_build (&offset_expr, "lui", LUI_FMT, AT,
			       BFD_RELOC_HI16_S);
		  macro_build (&offset_expr, "daddiu", "t,r,j", tempreg,
			       tempreg, BFD_RELOC_MIPS_HIGHER);
		  if (breg != 0)
		    macro_build (NULL, "daddu", "d,v,t", AT, AT, breg);
		  macro_build (NULL, "dsll32", SHFT_FMT, tempreg, tempreg, 0);
		  macro_build (NULL, "daddu", "d,v,t", tempreg, tempreg, AT);
		  macro_build (&offset_expr, s, fmt, op[0], BFD_RELOC_LO16,
			       tempreg);
		  used_at = 1;
		}
	      else
		{
		  macro_build (&offset_expr, "lui", LUI_FMT, tempreg,
			       BFD_RELOC_MIPS_HIGHEST);
		  macro_build (&offset_expr, "daddiu", "t,r,j", tempreg,
			       tempreg, BFD_RELOC_MIPS_HIGHER);
		  macro_build (NULL, "dsll", SHFT_FMT, tempreg, tempreg, 16);
		  macro_build (&offset_expr, "daddiu", "t,r,j", tempreg,
			       tempreg, BFD_RELOC_HI16_S);
		  macro_build (NULL, "dsll", SHFT_FMT, tempreg, tempreg, 16);
		  if (breg != 0)
		    macro_build (NULL, "daddu", "d,v,t",
				 tempreg, tempreg, breg);
		  macro_build (&offset_expr, s, fmt, op[0],
			       BFD_RELOC_LO16, tempreg);
		}

	      if (mips_relax.sequence)
		relax_end ();
	      break;
	    }

	  if (breg == 0)
	    {
	      if ((valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
		  && !nopic_need_relax (offset_expr.X_add_symbol, 1))
		{
		  relax_start (offset_expr.X_add_symbol);
		  macro_build (&offset_expr, s, fmt, op[0], BFD_RELOC_GPREL16,
			       mips_gp_register);
		  relax_switch ();
		}
	      macro_build_lui (&offset_expr, tempreg);
	      macro_build (&offset_expr, s, fmt, op[0],
			   BFD_RELOC_LO16, tempreg);
	      if (mips_relax.sequence)
		relax_end ();
	    }
	  else
	    {
	      if ((valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
		  && !nopic_need_relax (offset_expr.X_add_symbol, 1))
		{
		  relax_start (offset_expr.X_add_symbol);
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			       tempreg, breg, mips_gp_register);
		  macro_build (&offset_expr, s, fmt, op[0],
			       BFD_RELOC_GPREL16, tempreg);
		  relax_switch ();
		}
	      macro_build_lui (&offset_expr, tempreg);
	      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			   tempreg, tempreg, breg);
	      macro_build (&offset_expr, s, fmt, op[0],
			   BFD_RELOC_LO16, tempreg);
	      if (mips_relax.sequence)
		relax_end ();
	    }
	}
      else if (!mips_big_got)
	{
	  int lw_reloc_type = (int) BFD_RELOC_MIPS_GOT16;

	  /* If this is a reference to an external symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	       nop
	       <op>	op[0],0($tempreg)
	     Otherwise we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	       nop
	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)
	       <op>	op[0],0($tempreg)

	     For NewABI, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_PAGE)
	       <op>	op[0],<sym>($tempreg)   (BFD_RELOC_MIPS_GOT_OFST)

	     If there is a base register, we add it to $tempreg before
	     the <op>.  If there is a constant, we stick it in the
	     <op> instruction.  We don't handle constants larger than
	     16 bits, because we have no way to load the upper 16 bits
	     (actually, we could handle them for the subset of cases
	     in which we are not using $at).  */
	  gas_assert (offset_expr.X_op == O_symbol);
	  if (HAVE_NEWABI)
	    {
	      macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
	      if (breg != 0)
		macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			     tempreg, tempreg, breg);
	      macro_build (&offset_expr, s, fmt, op[0],
			   BFD_RELOC_MIPS_GOT_OFST, tempreg);
	      break;
	    }
	  expr1.X_add_number = offset_expr.X_add_number;
	  offset_expr.X_add_number = 0;
	  if (expr1.X_add_number < -0x8000
	      || expr1.X_add_number >= 0x8000)
	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
		       lw_reloc_type, mips_gp_register);
	  load_delay_nop ();
	  relax_start (offset_expr.X_add_symbol);
	  relax_switch ();
	  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j", tempreg,
		       tempreg, BFD_RELOC_LO16);
	  relax_end ();
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			 tempreg, tempreg, breg);
	  macro_build (&expr1, s, fmt, op[0], BFD_RELOC_LO16, tempreg);
	}
      else if (mips_big_got && !HAVE_NEWABI)
	{
	  int gpdelay;

	  /* If this is a reference to an external symbol, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	       addu	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
	       <op>	op[0],0($tempreg)
	     Otherwise we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
	       nop
	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)
	       <op>	op[0],0($tempreg)
	     If there is a base register, we add it to $tempreg before
	     the <op>.  If there is a constant, we stick it in the
	     <op> instruction.  We don't handle constants larger than
	     16 bits, because we have no way to load the upper 16 bits
	     (actually, we could handle them for the subset of cases
	     in which we are not using $at).  */
	  gas_assert (offset_expr.X_op == O_symbol);
	  expr1.X_add_number = offset_expr.X_add_number;
	  offset_expr.X_add_number = 0;
	  if (expr1.X_add_number < -0x8000
	      || expr1.X_add_number >= 0x8000)
	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	  gpdelay = reg_needs_delay (mips_gp_register);
	  relax_start (offset_expr.X_add_symbol);
	  macro_build (&offset_expr, "lui", LUI_FMT, tempreg,
		       BFD_RELOC_MIPS_GOT_HI16);
	  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg,
		       mips_gp_register);
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
		       BFD_RELOC_MIPS_GOT_LO16, tempreg);
	  relax_switch ();
	  if (gpdelay)
	    macro_build (NULL, "nop", "");
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
		       BFD_RELOC_MIPS_GOT16, mips_gp_register);
	  load_delay_nop ();
	  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j", tempreg,
		       tempreg, BFD_RELOC_LO16);
	  relax_end ();

	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			 tempreg, tempreg, breg);
	  macro_build (&expr1, s, fmt, op[0], BFD_RELOC_LO16, tempreg);
	}
      else if (mips_big_got && HAVE_NEWABI)
	{
	  /* If this is a reference to an external symbol, we want
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	       add	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
	       <op>	op[0],<ofst>($tempreg)
	     Otherwise, for local symbols, we want:
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_PAGE)
	       <op>	op[0],<sym>($tempreg)   (BFD_RELOC_MIPS_GOT_OFST)  */
	  gas_assert (offset_expr.X_op == O_symbol);
	  expr1.X_add_number = offset_expr.X_add_number;
	  offset_expr.X_add_number = 0;
	  if (expr1.X_add_number < -0x8000
	      || expr1.X_add_number >= 0x8000)
	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	  relax_start (offset_expr.X_add_symbol);
	  macro_build (&offset_expr, "lui", LUI_FMT, tempreg,
		       BFD_RELOC_MIPS_GOT_HI16);
	  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg,
		       mips_gp_register);
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
		       BFD_RELOC_MIPS_GOT_LO16, tempreg);
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			 tempreg, tempreg, breg);
	  macro_build (&expr1, s, fmt, op[0], BFD_RELOC_LO16, tempreg);

	  relax_switch ();
	  offset_expr.X_add_number = expr1.X_add_number;
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
		       BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			 tempreg, tempreg, breg);
	  macro_build (&offset_expr, s, fmt, op[0],
		       BFD_RELOC_MIPS_GOT_OFST, tempreg);
	  relax_end ();
	}
      else
	abort ();

      break;

    case M_JRADDIUSP:
      gas_assert (mips_opts.micromips);
      gas_assert (mips_opts.insn32);
      start_noreorder ();
      macro_build (NULL, "jr", "s", RA);
      expr1.X_add_number = op[0] << 2;
      macro_build (&expr1, "addiu", "t,r,j", SP, SP, BFD_RELOC_LO16);
      end_noreorder ();
      break;

    case M_JRC:
      gas_assert (mips_opts.micromips);
      gas_assert (mips_opts.insn32);
      macro_build (NULL, "jr", "s", op[0]);
      if (mips_opts.noreorder)
	macro_build (NULL, "nop", "");
      break;

    case M_LI:
    case M_LI_S:
      load_register (op[0], &imm_expr, 0);
      break;

    case M_DLI:
      load_register (op[0], &imm_expr, 1);
      break;

    case M_LI_SS:
      if (imm_expr.X_op == O_constant)
	{
	  used_at = 1;
	  load_register (AT, &imm_expr, 0);
	  macro_build (NULL, "mtc1", "t,G", AT, op[0]);
	  break;
	}
      else
	{
	  gas_assert (imm_expr.X_op == O_absent
		      && offset_expr.X_op == O_symbol
		      && strcmp (segment_name (S_GET_SEGMENT
					       (offset_expr.X_add_symbol)),
				 ".lit4") == 0
		      && offset_expr.X_add_number == 0);
	  macro_build (&offset_expr, "lwc1", "T,o(b)", op[0],
		       BFD_RELOC_MIPS_LITERAL, mips_gp_register);
	  break;
	}

    case M_LI_D:
      /* Check if we have a constant in IMM_EXPR.  If the GPRs are 64 bits
         wide, IMM_EXPR is the entire value.  Otherwise IMM_EXPR is the high
         order 32 bits of the value and the low order 32 bits are either
         zero or in OFFSET_EXPR.  */
      if (imm_expr.X_op == O_constant)
	{
	  if (HAVE_64BIT_GPRS)
	    load_register (op[0], &imm_expr, 1);
	  else
	    {
	      int hreg, lreg;

	      if (target_big_endian)
		{
		  hreg = op[0];
		  lreg = op[0] + 1;
		}
	      else
		{
		  hreg = op[0] + 1;
		  lreg = op[0];
		}

	      if (hreg <= 31)
		load_register (hreg, &imm_expr, 0);
	      if (lreg <= 31)
		{
		  if (offset_expr.X_op == O_absent)
		    move_register (lreg, 0);
		  else
		    {
		      gas_assert (offset_expr.X_op == O_constant);
		      load_register (lreg, &offset_expr, 0);
		    }
		}
	    }
	  break;
	}
      gas_assert (imm_expr.X_op == O_absent);

      /* We know that sym is in the .rdata section.  First we get the
	 upper 16 bits of the address.  */
      if (mips_pic == NO_PIC)
	{
	  macro_build_lui (&offset_expr, AT);
	  used_at = 1;
	}
      else
	{
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", AT,
		       BFD_RELOC_MIPS_GOT16, mips_gp_register);
	  used_at = 1;
	}

      /* Now we load the register(s).  */
      if (HAVE_64BIT_GPRS)
	{
	  used_at = 1;
	  macro_build (&offset_expr, "ld", "t,o(b)", op[0],
		       BFD_RELOC_LO16, AT);
	}
      else
	{
	  used_at = 1;
	  macro_build (&offset_expr, "lw", "t,o(b)", op[0],
		       BFD_RELOC_LO16, AT);
	  if (op[0] != RA)
	    {
	      /* FIXME: How in the world do we deal with the possible
		 overflow here?  */
	      offset_expr.X_add_number += 4;
	      macro_build (&offset_expr, "lw", "t,o(b)",
			   op[0] + 1, BFD_RELOC_LO16, AT);
	    }
	}
      break;

    case M_LI_DD:
      /* Check if we have a constant in IMM_EXPR.  If the FPRs are 64 bits
         wide, IMM_EXPR is the entire value and the GPRs are known to be 64
         bits wide as well.  Otherwise IMM_EXPR is the high order 32 bits of
         the value and the low order 32 bits are either zero or in
         OFFSET_EXPR.  */
      if (imm_expr.X_op == O_constant)
	{
	  used_at = 1;
	  load_register (AT, &imm_expr, HAVE_64BIT_FPRS);
	  if (HAVE_64BIT_FPRS)
	    {
	      gas_assert (HAVE_64BIT_GPRS);
	      macro_build (NULL, "dmtc1", "t,S", AT, op[0]);
	    }
	  else
	    {
	      macro_build (NULL, "mtc1", "t,G", AT, op[0] + 1);
	      if (offset_expr.X_op == O_absent)
		macro_build (NULL, "mtc1", "t,G", 0, op[0]);
	      else
		{
		  gas_assert (offset_expr.X_op == O_constant);
		  load_register (AT, &offset_expr, 0);
		  macro_build (NULL, "mtc1", "t,G", AT, op[0]);
		}
	    }
	  break;
	}

      gas_assert (imm_expr.X_op == O_absent
		  && offset_expr.X_op == O_symbol
		  && offset_expr.X_add_number == 0);
      s = segment_name (S_GET_SEGMENT (offset_expr.X_add_symbol));
      if (strcmp (s, ".lit8") == 0)
 	{
 	  op[2] = mips_gp_register;
	  offset_reloc[0] = BFD_RELOC_MIPS_LITERAL;
	  offset_reloc[1] = BFD_RELOC_UNUSED;
	  offset_reloc[2] = BFD_RELOC_UNUSED;
	}
      else
	{
	  gas_assert (strcmp (s, RDATA_SECTION_NAME) == 0);
	  used_at = 1;
	  if (mips_pic != NO_PIC)
	    macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", AT,
			 BFD_RELOC_MIPS_GOT16, mips_gp_register);
	  else
	    {
	      /* FIXME: This won't work for a 64 bit address.  */
	      macro_build_lui (&offset_expr, AT);
	    }

	  op[2] = AT;
	  offset_reloc[0] = BFD_RELOC_LO16;
	  offset_reloc[1] = BFD_RELOC_UNUSED;
	  offset_reloc[2] = BFD_RELOC_UNUSED;
 	}
      align = 8;
      /* Fall through */

    case M_L_DAB:
      /*
       * The MIPS assembler seems to check for X_add_number not
       * being double aligned and generating:
       *	lui	at,%hi(foo+1)
       *	addu	at,at,v1
       *	addiu	at,at,%lo(foo+1)
       *	lwc1	f2,0(at)
       *	lwc1	f3,4(at)
       * But, the resulting address is the same after relocation so why
       * generate the extra instruction?
       */
      /* Itbl support may require additional care here.  */
      coproc = 1;
      fmt = "T,o(b)";
      if (CPU_HAS_LDC1_SDC1 (mips_opts.arch))
	{
	  s = "ldc1";
	  goto ld_st;
	}
      s = "lwc1";
      goto ldd_std;

    case M_S_DAB:
      gas_assert (!mips_opts.micromips);
      /* Itbl support may require additional care here.  */
      coproc = 1;
      fmt = "T,o(b)";
      if (CPU_HAS_LDC1_SDC1 (mips_opts.arch))
	{
	  s = "sdc1";
	  goto ld_st;
	}
      s = "swc1";
      goto ldd_std;

    case M_LQ_AB:
      fmt = "t,o(b)";
      s = "lq";
      goto ld;

    case M_SQ_AB:
      fmt = "t,o(b)";
      s = "sq";
      goto ld_st;

    case M_LD_AB:
      fmt = "t,o(b)";
      if (HAVE_64BIT_GPRS)
	{
	  s = "ld";
	  goto ld;
	}
      s = "lw";
      goto ldd_std;

    case M_SD_AB:
      fmt = "t,o(b)";
      if (HAVE_64BIT_GPRS)
	{
	  s = "sd";
	  goto ld_st;
	}
      s = "sw";

    ldd_std:
      /* Even on a big endian machine $fn comes before $fn+1.  We have
	 to adjust when loading from memory.  We set coproc if we must
	 load $fn+1 first.  */
      /* Itbl support may require additional care here.  */
      if (!target_big_endian)
	coproc = 0;

      breg = op[2];
      if (small_offset_p (0, align, 16))
	{
	  ep = &offset_expr;
	  if (!small_offset_p (4, align, 16))
	    {
	      macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j", AT, breg,
			   -1, offset_reloc[0], offset_reloc[1],
			   offset_reloc[2]);
	      expr1.X_add_number = 0;
	      ep = &expr1;
	      breg = AT;
	      used_at = 1;
	      offset_reloc[0] = BFD_RELOC_LO16;
	      offset_reloc[1] = BFD_RELOC_UNUSED;
	      offset_reloc[2] = BFD_RELOC_UNUSED;
	    }
	  if (strcmp (s, "lw") == 0 && op[0] == breg)
	    {
	      ep->X_add_number += 4;
	      macro_build (ep, s, fmt, op[0] + 1, -1, offset_reloc[0],
			   offset_reloc[1], offset_reloc[2], breg);
	      ep->X_add_number -= 4;
	      macro_build (ep, s, fmt, op[0], -1, offset_reloc[0],
			   offset_reloc[1], offset_reloc[2], breg);
	    }
	  else
	    {
	      macro_build (ep, s, fmt, coproc ? op[0] + 1 : op[0], -1,
			   offset_reloc[0], offset_reloc[1], offset_reloc[2],
			   breg);
	      ep->X_add_number += 4;
	      macro_build (ep, s, fmt, coproc ? op[0] : op[0] + 1, -1,
			   offset_reloc[0], offset_reloc[1], offset_reloc[2],
			   breg);
	    }
	  break;
	}

      if (offset_expr.X_op != O_symbol
	  && offset_expr.X_op != O_constant)
	{
	  as_bad (_("expression too complex"));
	  offset_expr.X_op = O_constant;
	}

      if (HAVE_32BIT_ADDRESSES
	  && !IS_SEXT_32BIT_NUM (offset_expr.X_add_number))
	{
	  char value [32];

	  sprintf_vma (value, offset_expr.X_add_number);
	  as_bad (_("number (0x%s) larger than 32 bits"), value);
	}

      if (mips_pic == NO_PIC || offset_expr.X_op == O_constant)
	{
	  /* If this is a reference to a GP relative symbol, we want
	       <op>	op[0],<sym>($gp)	(BFD_RELOC_GPREL16)
	       <op>	op[0]+1,<sym>+4($gp)	(BFD_RELOC_GPREL16)
	     If we have a base register, we use this
	       addu	$at,$breg,$gp
	       <op>	op[0],<sym>($at)	(BFD_RELOC_GPREL16)
	       <op>	op[0]+1,<sym>+4($at)	(BFD_RELOC_GPREL16)
	     If this is not a GP relative symbol, we want
	       lui	$at,<sym>		(BFD_RELOC_HI16_S)
	       <op>	op[0],<sym>($at)	(BFD_RELOC_LO16)
	       <op>	op[0]+1,<sym>+4($at)	(BFD_RELOC_LO16)
	     If there is a base register, we add it to $at after the
	     lui instruction.  If there is a constant, we always use
	     the last case.  */
	  if (offset_expr.X_op == O_symbol
	      && (valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
	      && !nopic_need_relax (offset_expr.X_add_symbol, 1))
	    {
	      relax_start (offset_expr.X_add_symbol);
	      if (breg == 0)
		{
		  tempreg = mips_gp_register;
		}
	      else
		{
		  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			       AT, breg, mips_gp_register);
		  tempreg = AT;
		  used_at = 1;
		}

	      /* Itbl support may require additional care here.  */
	      macro_build (&offset_expr, s, fmt, coproc ? op[0] + 1 : op[0],
			   BFD_RELOC_GPREL16, tempreg);
	      offset_expr.X_add_number += 4;

	      /* Set mips_optimize to 2 to avoid inserting an
                 undesired nop.  */
	      hold_mips_optimize = mips_optimize;
	      mips_optimize = 2;
	      /* Itbl support may require additional care here.  */
	      macro_build (&offset_expr, s, fmt, coproc ? op[0] : op[0] + 1,
			   BFD_RELOC_GPREL16, tempreg);
	      mips_optimize = hold_mips_optimize;

	      relax_switch ();

	      offset_expr.X_add_number -= 4;
	    }
	  used_at = 1;
	  if (offset_high_part (offset_expr.X_add_number, 16)
	      != offset_high_part (offset_expr.X_add_number + 4, 16))
	    {
	      load_address (AT, &offset_expr, &used_at);
	      offset_expr.X_op = O_constant;
	      offset_expr.X_add_number = 0;
	    }
	  else
	    macro_build_lui (&offset_expr, AT);
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, breg, AT);
	  /* Itbl support may require additional care here.  */
	  macro_build (&offset_expr, s, fmt, coproc ? op[0] + 1 : op[0],
		       BFD_RELOC_LO16, AT);
	  /* FIXME: How do we handle overflow here?  */
	  offset_expr.X_add_number += 4;
	  /* Itbl support may require additional care here.  */
	  macro_build (&offset_expr, s, fmt, coproc ? op[0] : op[0] + 1,
		       BFD_RELOC_LO16, AT);
	  if (mips_relax.sequence)
	    relax_end ();
	}
      else if (!mips_big_got)
	{
	  /* If this is a reference to an external symbol, we want
	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
	       nop
	       <op>	op[0],0($at)
	       <op>	op[0]+1,4($at)
	     Otherwise we want
	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
	       nop
	       <op>	op[0],<sym>($at)	(BFD_RELOC_LO16)
	       <op>	op[0]+1,<sym>+4($at)	(BFD_RELOC_LO16)
	     If there is a base register we add it to $at before the
	     lwc1 instructions.  If there is a constant we include it
	     in the lwc1 instructions.  */
	  used_at = 1;
	  expr1.X_add_number = offset_expr.X_add_number;
	  if (expr1.X_add_number < -0x8000
	      || expr1.X_add_number >= 0x8000 - 4)
	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	  load_got_offset (AT, &offset_expr);
	  load_delay_nop ();
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, breg, AT);

	  /* Set mips_optimize to 2 to avoid inserting an undesired
             nop.  */
	  hold_mips_optimize = mips_optimize;
	  mips_optimize = 2;

	  /* Itbl support may require additional care here.  */
	  relax_start (offset_expr.X_add_symbol);
	  macro_build (&expr1, s, fmt, coproc ? op[0] + 1 : op[0],
		       BFD_RELOC_LO16, AT);
	  expr1.X_add_number += 4;
	  macro_build (&expr1, s, fmt, coproc ? op[0] : op[0] + 1,
		       BFD_RELOC_LO16, AT);
	  relax_switch ();
	  macro_build (&offset_expr, s, fmt, coproc ? op[0] + 1 : op[0],
		       BFD_RELOC_LO16, AT);
	  offset_expr.X_add_number += 4;
	  macro_build (&offset_expr, s, fmt, coproc ? op[0] : op[0] + 1,
		       BFD_RELOC_LO16, AT);
	  relax_end ();

	  mips_optimize = hold_mips_optimize;
	}
      else if (mips_big_got)
	{
	  int gpdelay;

	  /* If this is a reference to an external symbol, we want
	       lui	$at,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
	       addu	$at,$at,$gp
	       lw	$at,<sym>($at)		(BFD_RELOC_MIPS_GOT_LO16)
	       nop
	       <op>	op[0],0($at)
	       <op>	op[0]+1,4($at)
	     Otherwise we want
	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
	       nop
	       <op>	op[0],<sym>($at)	(BFD_RELOC_LO16)
	       <op>	op[0]+1,<sym>+4($at)	(BFD_RELOC_LO16)
	     If there is a base register we add it to $at before the
	     lwc1 instructions.  If there is a constant we include it
	     in the lwc1 instructions.  */
	  used_at = 1;
	  expr1.X_add_number = offset_expr.X_add_number;
	  offset_expr.X_add_number = 0;
	  if (expr1.X_add_number < -0x8000
	      || expr1.X_add_number >= 0x8000 - 4)
	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	  gpdelay = reg_needs_delay (mips_gp_register);
	  relax_start (offset_expr.X_add_symbol);
	  macro_build (&offset_expr, "lui", LUI_FMT,
		       AT, BFD_RELOC_MIPS_GOT_HI16);
	  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
		       AT, AT, mips_gp_register);
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       AT, BFD_RELOC_MIPS_GOT_LO16, AT);
	  load_delay_nop ();
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, breg, AT);
	  /* Itbl support may require additional care here.  */
	  macro_build (&expr1, s, fmt, coproc ? op[0] + 1 : op[0],
		       BFD_RELOC_LO16, AT);
	  expr1.X_add_number += 4;

	  /* Set mips_optimize to 2 to avoid inserting an undesired
             nop.  */
	  hold_mips_optimize = mips_optimize;
	  mips_optimize = 2;
	  /* Itbl support may require additional care here.  */
	  macro_build (&expr1, s, fmt, coproc ? op[0] : op[0] + 1,
		       BFD_RELOC_LO16, AT);
	  mips_optimize = hold_mips_optimize;
	  expr1.X_add_number -= 4;

	  relax_switch ();
	  offset_expr.X_add_number = expr1.X_add_number;
	  if (gpdelay)
	    macro_build (NULL, "nop", "");
	  macro_build (&offset_expr, ADDRESS_LOAD_INSN, "t,o(b)", AT,
		       BFD_RELOC_MIPS_GOT16, mips_gp_register);
	  load_delay_nop ();
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, breg, AT);
	  /* Itbl support may require additional care here.  */
	  macro_build (&offset_expr, s, fmt, coproc ? op[0] + 1 : op[0],
		       BFD_RELOC_LO16, AT);
	  offset_expr.X_add_number += 4;

	  /* Set mips_optimize to 2 to avoid inserting an undesired
             nop.  */
	  hold_mips_optimize = mips_optimize;
	  mips_optimize = 2;
	  /* Itbl support may require additional care here.  */
	  macro_build (&offset_expr, s, fmt, coproc ? op[0] : op[0] + 1,
		       BFD_RELOC_LO16, AT);
	  mips_optimize = hold_mips_optimize;
	  relax_end ();
	}
      else
	abort ();

      break;
	
    case M_SAA_AB:
      s = "saa";
      offbits = 0;
      fmt = "t,(b)";
      goto ld_st;
    case M_SAAD_AB:
      s = "saad";
      offbits = 0;
      fmt = "t,(b)";
      goto ld_st;

   /* New code added to support COPZ instructions.
      This code builds table entries out of the macros in mip_opcodes.
      R4000 uses interlocks to handle coproc delays.
      Other chips (like the R3000) require nops to be inserted for delays.

      FIXME: Currently, we require that the user handle delays.
      In order to fill delay slots for non-interlocked chips,
      we must have a way to specify delays based on the coprocessor.
      Eg. 4 cycles if load coproc reg from memory, 1 if in cache, etc.
      What are the side-effects of the cop instruction?
      What cache support might we have and what are its effects?
      Both coprocessor & memory require delays. how long???
      What registers are read/set/modified?

      If an itbl is provided to interpret cop instructions,
      this knowledge can be encoded in the itbl spec.  */

    case M_COP0:
      s = "c0";
      goto copz;
    case M_COP1:
      s = "c1";
      goto copz;
    case M_COP2:
      s = "c2";
      goto copz;
    case M_COP3:
      s = "c3";
    copz:
      gas_assert (!mips_opts.micromips);
      /* For now we just do C (same as Cz).  The parameter will be
         stored in insn_opcode by mips_ip.  */
      macro_build (NULL, s, "C", (int) ip->insn_opcode);
      break;

    case M_MOVE:
      move_register (op[0], op[1]);
      break;

    case M_MOVEP:
      gas_assert (mips_opts.micromips);
      gas_assert (mips_opts.insn32);
      move_register (micromips_to_32_reg_h_map1[op[0]],
		     micromips_to_32_reg_m_map[op[1]]);
      move_register (micromips_to_32_reg_h_map2[op[0]],
		     micromips_to_32_reg_n_map[op[2]]);
      break;

    case M_DMUL:
      dbl = 1;
    case M_MUL:
      if (mips_opts.arch == CPU_R5900)
	macro_build (NULL, dbl ? "dmultu" : "multu", "d,s,t", op[0], op[1],
		     op[2]);
      else
        {
	  macro_build (NULL, dbl ? "dmultu" : "multu", "s,t", op[1], op[2]);
	  macro_build (NULL, "mflo", MFHL_FMT, op[0]);
        }
      break;

    case M_DMUL_I:
      dbl = 1;
    case M_MUL_I:
      /* The MIPS assembler some times generates shifts and adds.  I'm
	 not trying to be that fancy. GCC should do this for us
	 anyway.  */
      used_at = 1;
      load_register (AT, &imm_expr, dbl);
      macro_build (NULL, dbl ? "dmult" : "mult", "s,t", op[1], AT);
      macro_build (NULL, "mflo", MFHL_FMT, op[0]);
      break;

    case M_DMULO_I:
      dbl = 1;
    case M_MULO_I:
      imm = 1;
      goto do_mulo;

    case M_DMULO:
      dbl = 1;
    case M_MULO:
    do_mulo:
      start_noreorder ();
      used_at = 1;
      if (imm)
	load_register (AT, &imm_expr, dbl);
      macro_build (NULL, dbl ? "dmult" : "mult", "s,t",
		   op[1], imm ? AT : op[2]);
      macro_build (NULL, "mflo", MFHL_FMT, op[0]);
      macro_build (NULL, dbl ? "dsra32" : "sra", SHFT_FMT, op[0], op[0], 31);
      macro_build (NULL, "mfhi", MFHL_FMT, AT);
      if (mips_trap)
	macro_build (NULL, "tne", TRAP_FMT, op[0], AT, 6);
      else
	{
	  if (mips_opts.micromips)
	    micromips_label_expr (&label_expr);
	  else
	    label_expr.X_add_number = 8;
	  macro_build (&label_expr, "beq", "s,t,p", op[0], AT);
	  macro_build (NULL, "nop", "");
	  macro_build (NULL, "break", BRK_FMT, 6);
	  if (mips_opts.micromips)
	    micromips_add_label ();
	}
      end_noreorder ();
      macro_build (NULL, "mflo", MFHL_FMT, op[0]);
      break;

    case M_DMULOU_I:
      dbl = 1;
    case M_MULOU_I:
      imm = 1;
      goto do_mulou;

    case M_DMULOU:
      dbl = 1;
    case M_MULOU:
    do_mulou:
      start_noreorder ();
      used_at = 1;
      if (imm)
	load_register (AT, &imm_expr, dbl);
      macro_build (NULL, dbl ? "dmultu" : "multu", "s,t",
		   op[1], imm ? AT : op[2]);
      macro_build (NULL, "mfhi", MFHL_FMT, AT);
      macro_build (NULL, "mflo", MFHL_FMT, op[0]);
      if (mips_trap)
	macro_build (NULL, "tne", TRAP_FMT, AT, ZERO, 6);
      else
	{
	  if (mips_opts.micromips)
	    micromips_label_expr (&label_expr);
	  else
	    label_expr.X_add_number = 8;
	  macro_build (&label_expr, "beq", "s,t,p", AT, ZERO);
	  macro_build (NULL, "nop", "");
	  macro_build (NULL, "break", BRK_FMT, 6);
	  if (mips_opts.micromips)
	    micromips_add_label ();
	}
      end_noreorder ();
      break;

    case M_DROL:
      if (ISA_HAS_DROR (mips_opts.isa) || CPU_HAS_DROR (mips_opts.arch))
	{
	  if (op[0] == op[1])
	    {
	      tempreg = AT;
	      used_at = 1;
	    }
	  else
	    tempreg = op[0];
	  macro_build (NULL, "dnegu", "d,w", tempreg, op[2]);
	  macro_build (NULL, "drorv", "d,t,s", op[0], op[1], tempreg);
	  break;
	}
      used_at = 1;
      macro_build (NULL, "dsubu", "d,v,t", AT, ZERO, op[2]);
      macro_build (NULL, "dsrlv", "d,t,s", AT, op[1], AT);
      macro_build (NULL, "dsllv", "d,t,s", op[0], op[1], op[2]);
      macro_build (NULL, "or", "d,v,t", op[0], op[0], AT);
      break;

    case M_ROL:
      if (ISA_HAS_ROR (mips_opts.isa) || CPU_HAS_ROR (mips_opts.arch))
	{
	  if (op[0] == op[1])
	    {
	      tempreg = AT;
	      used_at = 1;
	    }
	  else
	    tempreg = op[0];
	  macro_build (NULL, "negu", "d,w", tempreg, op[2]);
	  macro_build (NULL, "rorv", "d,t,s", op[0], op[1], tempreg);
	  break;
	}
      used_at = 1;
      macro_build (NULL, "subu", "d,v,t", AT, ZERO, op[2]);
      macro_build (NULL, "srlv", "d,t,s", AT, op[1], AT);
      macro_build (NULL, "sllv", "d,t,s", op[0], op[1], op[2]);
      macro_build (NULL, "or", "d,v,t", op[0], op[0], AT);
      break;

    case M_DROL_I:
      {
	unsigned int rot;
	char *l;
	char *rr;

	rot = imm_expr.X_add_number & 0x3f;
	if (ISA_HAS_DROR (mips_opts.isa) || CPU_HAS_DROR (mips_opts.arch))
	  {
	    rot = (64 - rot) & 0x3f;
	    if (rot >= 32)
	      macro_build (NULL, "dror32", SHFT_FMT, op[0], op[1], rot - 32);
	    else
	      macro_build (NULL, "dror", SHFT_FMT, op[0], op[1], rot);
	    break;
	  }
	if (rot == 0)
	  {
	    macro_build (NULL, "dsrl", SHFT_FMT, op[0], op[1], 0);
	    break;
	  }
	l = (rot < 0x20) ? "dsll" : "dsll32";
	rr = ((0x40 - rot) < 0x20) ? "dsrl" : "dsrl32";
	rot &= 0x1f;
	used_at = 1;
	macro_build (NULL, l, SHFT_FMT, AT, op[1], rot);
	macro_build (NULL, rr, SHFT_FMT, op[0], op[1], (0x20 - rot) & 0x1f);
	macro_build (NULL, "or", "d,v,t", op[0], op[0], AT);
      }
      break;

    case M_ROL_I:
      {
	unsigned int rot;

	rot = imm_expr.X_add_number & 0x1f;
	if (ISA_HAS_ROR (mips_opts.isa) || CPU_HAS_ROR (mips_opts.arch))
	  {
	    macro_build (NULL, "ror", SHFT_FMT, op[0], op[1],
			 (32 - rot) & 0x1f);
	    break;
	  }
	if (rot == 0)
	  {
	    macro_build (NULL, "srl", SHFT_FMT, op[0], op[1], 0);
	    break;
	  }
	used_at = 1;
	macro_build (NULL, "sll", SHFT_FMT, AT, op[1], rot);
	macro_build (NULL, "srl", SHFT_FMT, op[0], op[1], (0x20 - rot) & 0x1f);
	macro_build (NULL, "or", "d,v,t", op[0], op[0], AT);
      }
      break;

    case M_DROR:
      if (ISA_HAS_DROR (mips_opts.isa) || CPU_HAS_DROR (mips_opts.arch))
	{
	  macro_build (NULL, "drorv", "d,t,s", op[0], op[1], op[2]);
	  break;
	}
      used_at = 1;
      macro_build (NULL, "dsubu", "d,v,t", AT, ZERO, op[2]);
      macro_build (NULL, "dsllv", "d,t,s", AT, op[1], AT);
      macro_build (NULL, "dsrlv", "d,t,s", op[0], op[1], op[2]);
      macro_build (NULL, "or", "d,v,t", op[0], op[0], AT);
      break;

    case M_ROR:
      if (ISA_HAS_ROR (mips_opts.isa) || CPU_HAS_ROR (mips_opts.arch))
	{
	  macro_build (NULL, "rorv", "d,t,s", op[0], op[1], op[2]);
	  break;
	}
      used_at = 1;
      macro_build (NULL, "subu", "d,v,t", AT, ZERO, op[2]);
      macro_build (NULL, "sllv", "d,t,s", AT, op[1], AT);
      macro_build (NULL, "srlv", "d,t,s", op[0], op[1], op[2]);
      macro_build (NULL, "or", "d,v,t", op[0], op[0], AT);
      break;

    case M_DROR_I:
      {
	unsigned int rot;
	char *l;
	char *rr;

	rot = imm_expr.X_add_number & 0x3f;
	if (ISA_HAS_DROR (mips_opts.isa) || CPU_HAS_DROR (mips_opts.arch))
	  {
	    if (rot >= 32)
	      macro_build (NULL, "dror32", SHFT_FMT, op[0], op[1], rot - 32);
	    else
	      macro_build (NULL, "dror", SHFT_FMT, op[0], op[1], rot);
	    break;
	  }
	if (rot == 0)
	  {
	    macro_build (NULL, "dsrl", SHFT_FMT, op[0], op[1], 0);
	    break;
	  }
	rr = (rot < 0x20) ? "dsrl" : "dsrl32";
	l = ((0x40 - rot) < 0x20) ? "dsll" : "dsll32";
	rot &= 0x1f;
	used_at = 1;
	macro_build (NULL, rr, SHFT_FMT, AT, op[1], rot);
	macro_build (NULL, l, SHFT_FMT, op[0], op[1], (0x20 - rot) & 0x1f);
	macro_build (NULL, "or", "d,v,t", op[0], op[0], AT);
      }
      break;

    case M_ROR_I:
      {
	unsigned int rot;

	rot = imm_expr.X_add_number & 0x1f;
	if (ISA_HAS_ROR (mips_opts.isa) || CPU_HAS_ROR (mips_opts.arch))
	  {
	    macro_build (NULL, "ror", SHFT_FMT, op[0], op[1], rot);
	    break;
	  }
	if (rot == 0)
	  {
	    macro_build (NULL, "srl", SHFT_FMT, op[0], op[1], 0);
	    break;
	  }
	used_at = 1;
	macro_build (NULL, "srl", SHFT_FMT, AT, op[1], rot);
	macro_build (NULL, "sll", SHFT_FMT, op[0], op[1], (0x20 - rot) & 0x1f);
	macro_build (NULL, "or", "d,v,t", op[0], op[0], AT);
      }
      break;

    case M_SEQ:
      if (op[1] == 0)
	macro_build (&expr1, "sltiu", "t,r,j", op[0], op[2], BFD_RELOC_LO16);
      else if (op[2] == 0)
	macro_build (&expr1, "sltiu", "t,r,j", op[0], op[1], BFD_RELOC_LO16);
      else
	{
	  macro_build (NULL, "xor", "d,v,t", op[0], op[1], op[2]);
	  macro_build (&expr1, "sltiu", "t,r,j", op[0], op[0], BFD_RELOC_LO16);
	}
      break;

    case M_SEQ_I:
      if (imm_expr.X_add_number == 0)
	{
	  macro_build (&expr1, "sltiu", "t,r,j", op[0], op[1], BFD_RELOC_LO16);
	  break;
	}
      if (op[1] == 0)
	{
	  as_warn (_("instruction %s: result is always false"),
		   ip->insn_mo->name);
	  move_register (op[0], 0);
	  break;
	}
      if (CPU_HAS_SEQ (mips_opts.arch)
	  && -512 <= imm_expr.X_add_number
	  && imm_expr.X_add_number < 512)
	{
	  macro_build (NULL, "seqi", "t,r,+Q", op[0], op[1],
		       (int) imm_expr.X_add_number);
	  break;
	}
      if (imm_expr.X_add_number >= 0
	  && imm_expr.X_add_number < 0x10000)
	macro_build (&imm_expr, "xori", "t,r,i", op[0], op[1], BFD_RELOC_LO16);
      else if (imm_expr.X_add_number > -0x8000
	       && imm_expr.X_add_number < 0)
	{
	  imm_expr.X_add_number = -imm_expr.X_add_number;
	  macro_build (&imm_expr, HAVE_32BIT_GPRS ? "addiu" : "daddiu",
		       "t,r,j", op[0], op[1], BFD_RELOC_LO16);
	}
      else if (CPU_HAS_SEQ (mips_opts.arch))
	{
	  used_at = 1;
	  load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
	  macro_build (NULL, "seq", "d,v,t", op[0], op[1], AT);
	  break;
	}
      else
	{
	  load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
	  macro_build (NULL, "xor", "d,v,t", op[0], op[1], AT);
	  used_at = 1;
	}
      macro_build (&expr1, "sltiu", "t,r,j", op[0], op[0], BFD_RELOC_LO16);
      break;

    case M_SGE:		/* X >= Y  <==>  not (X < Y) */
      s = "slt";
      goto sge;
    case M_SGEU:
      s = "sltu";
    sge:
      macro_build (NULL, s, "d,v,t", op[0], op[1], op[2]);
      macro_build (&expr1, "xori", "t,r,i", op[0], op[0], BFD_RELOC_LO16);
      break;

    case M_SGE_I:	/* X >= I  <==>  not (X < I) */
    case M_SGEU_I:
      if (imm_expr.X_add_number >= -0x8000
	  && imm_expr.X_add_number < 0x8000)
	macro_build (&imm_expr, mask == M_SGE_I ? "slti" : "sltiu", "t,r,j",
		     op[0], op[1], BFD_RELOC_LO16);
      else
	{
	  load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
	  macro_build (NULL, mask == M_SGE_I ? "slt" : "sltu", "d,v,t",
		       op[0], op[1], AT);
	  used_at = 1;
	}
      macro_build (&expr1, "xori", "t,r,i", op[0], op[0], BFD_RELOC_LO16);
      break;

    case M_SGT:		/* X > Y  <==>  Y < X */
      s = "slt";
      goto sgt;
    case M_SGTU:
      s = "sltu";
    sgt:
      macro_build (NULL, s, "d,v,t", op[0], op[2], op[1]);
      break;

    case M_SGT_I:	/* X > I  <==>  I < X */
      s = "slt";
      goto sgti;
    case M_SGTU_I:
      s = "sltu";
    sgti:
      used_at = 1;
      load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, s, "d,v,t", op[0], AT, op[1]);
      break;

    case M_SLE:		/* X <= Y  <==>  Y >= X  <==>  not (Y < X) */
      s = "slt";
      goto sle;
    case M_SLEU:
      s = "sltu";
    sle:
      macro_build (NULL, s, "d,v,t", op[0], op[2], op[1]);
      macro_build (&expr1, "xori", "t,r,i", op[0], op[0], BFD_RELOC_LO16);
      break;

    case M_SLE_I:	/* X <= I  <==>  I >= X  <==>  not (I < X) */
      s = "slt";
      goto slei;
    case M_SLEU_I:
      s = "sltu";
    slei:
      used_at = 1;
      load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, s, "d,v,t", op[0], AT, op[1]);
      macro_build (&expr1, "xori", "t,r,i", op[0], op[0], BFD_RELOC_LO16);
      break;

    case M_SLT_I:
      if (imm_expr.X_add_number >= -0x8000
	  && imm_expr.X_add_number < 0x8000)
	{
	  macro_build (&imm_expr, "slti", "t,r,j", op[0], op[1],
		       BFD_RELOC_LO16);
	  break;
	}
      used_at = 1;
      load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, "slt", "d,v,t", op[0], op[1], AT);
      break;

    case M_SLTU_I:
      if (imm_expr.X_add_number >= -0x8000
	  && imm_expr.X_add_number < 0x8000)
	{
	  macro_build (&imm_expr, "sltiu", "t,r,j", op[0], op[1],
		       BFD_RELOC_LO16);
	  break;
	}
      used_at = 1;
      load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, "sltu", "d,v,t", op[0], op[1], AT);
      break;

    case M_SNE:
      if (op[1] == 0)
	macro_build (NULL, "sltu", "d,v,t", op[0], 0, op[2]);
      else if (op[2] == 0)
	macro_build (NULL, "sltu", "d,v,t", op[0], 0, op[1]);
      else
	{
	  macro_build (NULL, "xor", "d,v,t", op[0], op[1], op[2]);
	  macro_build (NULL, "sltu", "d,v,t", op[0], 0, op[0]);
	}
      break;

    case M_SNE_I:
      if (imm_expr.X_add_number == 0)
	{
	  macro_build (NULL, "sltu", "d,v,t", op[0], 0, op[1]);
	  break;
	}
      if (op[1] == 0)
	{
	  as_warn (_("instruction %s: result is always true"),
		   ip->insn_mo->name);
	  macro_build (&expr1, HAVE_32BIT_GPRS ? "addiu" : "daddiu", "t,r,j",
		       op[0], 0, BFD_RELOC_LO16);
	  break;
	}
      if (CPU_HAS_SEQ (mips_opts.arch)
	  && -512 <= imm_expr.X_add_number
	  && imm_expr.X_add_number < 512)
	{
	  macro_build (NULL, "snei", "t,r,+Q", op[0], op[1],
		       (int) imm_expr.X_add_number);
	  break;
	}
      if (imm_expr.X_add_number >= 0
	  && imm_expr.X_add_number < 0x10000)
	{
	  macro_build (&imm_expr, "xori", "t,r,i", op[0], op[1],
		       BFD_RELOC_LO16);
	}
      else if (imm_expr.X_add_number > -0x8000
	       && imm_expr.X_add_number < 0)
	{
	  imm_expr.X_add_number = -imm_expr.X_add_number;
	  macro_build (&imm_expr, HAVE_32BIT_GPRS ? "addiu" : "daddiu",
		       "t,r,j", op[0], op[1], BFD_RELOC_LO16);
	}
      else if (CPU_HAS_SEQ (mips_opts.arch))
	{
	  used_at = 1;
	  load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
	  macro_build (NULL, "sne", "d,v,t", op[0], op[1], AT);
	  break;
	}
      else
	{
	  load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
	  macro_build (NULL, "xor", "d,v,t", op[0], op[1], AT);
	  used_at = 1;
	}
      macro_build (NULL, "sltu", "d,v,t", op[0], 0, op[0]);
      break;

    case M_SUB_I:
      s = "addi";
      s2 = "sub";
      goto do_subi;
    case M_SUBU_I:
      s = "addiu";
      s2 = "subu";
      goto do_subi;
    case M_DSUB_I:
      dbl = 1;
      s = "daddi";
      s2 = "dsub";
      if (!mips_opts.micromips)
	goto do_subi;
      if (imm_expr.X_add_number > -0x200
	  && imm_expr.X_add_number <= 0x200)
	{
	  macro_build (NULL, s, "t,r,.", op[0], op[1],
		       (int) -imm_expr.X_add_number);
	  break;
	}
      goto do_subi_i;
    case M_DSUBU_I:
      dbl = 1;
      s = "daddiu";
      s2 = "dsubu";
    do_subi:
      if (imm_expr.X_add_number > -0x8000
	  && imm_expr.X_add_number <= 0x8000)
	{
	  imm_expr.X_add_number = -imm_expr.X_add_number;
	  macro_build (&imm_expr, s, "t,r,j", op[0], op[1], BFD_RELOC_LO16);
	  break;
	}
    do_subi_i:
      used_at = 1;
      load_register (AT, &imm_expr, dbl);
      macro_build (NULL, s2, "d,v,t", op[0], op[1], AT);
      break;

    case M_TEQ_I:
      s = "teq";
      goto trap;
    case M_TGE_I:
      s = "tge";
      goto trap;
    case M_TGEU_I:
      s = "tgeu";
      goto trap;
    case M_TLT_I:
      s = "tlt";
      goto trap;
    case M_TLTU_I:
      s = "tltu";
      goto trap;
    case M_TNE_I:
      s = "tne";
    trap:
      used_at = 1;
      load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, s, "s,t", op[0], AT);
      break;

    case M_TRUNCWS:
    case M_TRUNCWD:
      gas_assert (!mips_opts.micromips);
      gas_assert (mips_opts.isa == ISA_MIPS1);
      used_at = 1;

      /*
       * Is the double cfc1 instruction a bug in the mips assembler;
       * or is there a reason for it?
       */
      start_noreorder ();
      macro_build (NULL, "cfc1", "t,G", op[2], RA);
      macro_build (NULL, "cfc1", "t,G", op[2], RA);
      macro_build (NULL, "nop", "");
      expr1.X_add_number = 3;
      macro_build (&expr1, "ori", "t,r,i", AT, op[2], BFD_RELOC_LO16);
      expr1.X_add_number = 2;
      macro_build (&expr1, "xori", "t,r,i", AT, AT, BFD_RELOC_LO16);
      macro_build (NULL, "ctc1", "t,G", AT, RA);
      macro_build (NULL, "nop", "");
      macro_build (NULL, mask == M_TRUNCWD ? "cvt.w.d" : "cvt.w.s", "D,S",
		   op[0], op[1]);
      macro_build (NULL, "ctc1", "t,G", op[2], RA);
      macro_build (NULL, "nop", "");
      end_noreorder ();
      break;

    case M_ULH_AB:
      s = "lb";
      s2 = "lbu";
      off = 1;
      goto uld_st;
    case M_ULHU_AB:
      s = "lbu";
      s2 = "lbu";
      off = 1;
      goto uld_st;
    case M_ULW_AB:
      s = "lwl";
      s2 = "lwr";
      offbits = (mips_opts.micromips ? 12 : 16);
      off = 3;
      goto uld_st;
    case M_ULD_AB:
      s = "ldl";
      s2 = "ldr";
      offbits = (mips_opts.micromips ? 12 : 16);
      off = 7;
      goto uld_st;
    case M_USH_AB:
      s = "sb";
      s2 = "sb";
      off = 1;
      ust = 1;
      goto uld_st;
    case M_USW_AB:
      s = "swl";
      s2 = "swr";
      offbits = (mips_opts.micromips ? 12 : 16);
      off = 3;
      ust = 1;
      goto uld_st;
    case M_USD_AB:
      s = "sdl";
      s2 = "sdr";
      offbits = (mips_opts.micromips ? 12 : 16);
      off = 7;
      ust = 1;

    uld_st:
      breg = op[2];
      large_offset = !small_offset_p (off, align, offbits);
      ep = &offset_expr;
      expr1.X_add_number = 0;
      if (large_offset)
	{
	  used_at = 1;
	  tempreg = AT;
	  if (small_offset_p (0, align, 16))
	    macro_build (ep, ADDRESS_ADDI_INSN, "t,r,j", tempreg, breg, -1,
			 offset_reloc[0], offset_reloc[1], offset_reloc[2]);
	  else
	    {
	      load_address (tempreg, ep, &used_at);
	      if (breg != 0)
		macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			     tempreg, tempreg, breg);
	    }
	  offset_reloc[0] = BFD_RELOC_LO16;
	  offset_reloc[1] = BFD_RELOC_UNUSED;
	  offset_reloc[2] = BFD_RELOC_UNUSED;
	  breg = tempreg;
	  tempreg = op[0];
	  ep = &expr1;
	}
      else if (!ust && op[0] == breg)
	{
	  used_at = 1;
	  tempreg = AT;
	}
      else
	tempreg = op[0];

      if (off == 1)
	goto ulh_sh;

      if (!target_big_endian)
	ep->X_add_number += off;
      if (offbits == 12)
	macro_build (NULL, s, "t,~(b)", tempreg, (int) ep->X_add_number, breg);
      else
	macro_build (ep, s, "t,o(b)", tempreg, -1,
		     offset_reloc[0], offset_reloc[1], offset_reloc[2], breg);

      if (!target_big_endian)
	ep->X_add_number -= off;
      else
	ep->X_add_number += off;
      if (offbits == 12)
	macro_build (NULL, s2, "t,~(b)",
		     tempreg, (int) ep->X_add_number, breg);
      else
	macro_build (ep, s2, "t,o(b)", tempreg, -1,
		     offset_reloc[0], offset_reloc[1], offset_reloc[2], breg);

      /* If necessary, move the result in tempreg to the final destination.  */
      if (!ust && op[0] != tempreg)
        {
	  /* Protect second load's delay slot.  */
	  load_delay_nop ();
	  move_register (op[0], tempreg);
	}
      break;

    ulh_sh:
      used_at = 1;
      if (target_big_endian == ust)
	ep->X_add_number += off;
      tempreg = ust || large_offset ? op[0] : AT;
      macro_build (ep, s, "t,o(b)", tempreg, -1,
		   offset_reloc[0], offset_reloc[1], offset_reloc[2], breg);

      /* For halfword transfers we need a temporary register to shuffle
         bytes.  Unfortunately for M_USH_A we have none available before
         the next store as AT holds the base address.  We deal with this
         case by clobbering TREG and then restoring it as with ULH.  */
      tempreg = ust == large_offset ? op[0] : AT;
      if (ust)
	macro_build (NULL, "srl", SHFT_FMT, tempreg, op[0], 8);

      if (target_big_endian == ust)
	ep->X_add_number -= off;
      else
	ep->X_add_number += off;
      macro_build (ep, s2, "t,o(b)", tempreg, -1,
		   offset_reloc[0], offset_reloc[1], offset_reloc[2], breg);

      /* For M_USH_A re-retrieve the LSB.  */
      if (ust && large_offset)
	{
	  if (target_big_endian)
	    ep->X_add_number += off;
	  else
	    ep->X_add_number -= off;
	  macro_build (&expr1, "lbu", "t,o(b)", AT, -1,
		       offset_reloc[0], offset_reloc[1], offset_reloc[2], AT);
	}
      /* For ULH and M_USH_A OR the LSB in.  */
      if (!ust || large_offset)
	{
	  tempreg = !large_offset ? AT : op[0];
	  macro_build (NULL, "sll", SHFT_FMT, tempreg, tempreg, 8);
	  macro_build (NULL, "or", "d,v,t", op[0], op[0], AT);
	}
      break;

    default:
      /* FIXME: Check if this is one of the itbl macros, since they
	 are added dynamically.  */
      as_bad (_("macro %s not implemented yet"), ip->insn_mo->name);
      break;
    }
  if (!mips_opts.at && used_at)
    as_bad (_("macro used $at after \".set noat\""));
}

/* Implement macros in mips16 mode.  */

static void
mips16_macro (struct mips_cl_insn *ip)
{
  const struct mips_operand_array *operands;
  int mask;
  int tmp;
  expressionS expr1;
  int dbl;
  const char *s, *s2, *s3;
  unsigned int op[MAX_OPERANDS];
  unsigned int i;

  mask = ip->insn_mo->mask;

  operands = insn_operands (ip);
  for (i = 0; i < MAX_OPERANDS; i++)
    if (operands->operand[i])
      op[i] = insn_extract_operand (ip, operands->operand[i]);
    else
      op[i] = -1;

  expr1.X_op = O_constant;
  expr1.X_op_symbol = NULL;
  expr1.X_add_symbol = NULL;
  expr1.X_add_number = 1;

  dbl = 0;

  switch (mask)
    {
    default:
      abort ();

    case M_DDIV_3:
      dbl = 1;
    case M_DIV_3:
      s = "mflo";
      goto do_div3;
    case M_DREM_3:
      dbl = 1;
    case M_REM_3:
      s = "mfhi";
    do_div3:
      start_noreorder ();
      macro_build (NULL, dbl ? "ddiv" : "div", "0,x,y", op[1], op[2]);
      expr1.X_add_number = 2;
      macro_build (&expr1, "bnez", "x,p", op[2]);
      macro_build (NULL, "break", "6", 7);

      /* FIXME: The normal code checks for of -1 / -0x80000000 here,
         since that causes an overflow.  We should do that as well,
         but I don't see how to do the comparisons without a temporary
         register.  */
      end_noreorder ();
      macro_build (NULL, s, "x", op[0]);
      break;

    case M_DIVU_3:
      s = "divu";
      s2 = "mflo";
      goto do_divu3;
    case M_REMU_3:
      s = "divu";
      s2 = "mfhi";
      goto do_divu3;
    case M_DDIVU_3:
      s = "ddivu";
      s2 = "mflo";
      goto do_divu3;
    case M_DREMU_3:
      s = "ddivu";
      s2 = "mfhi";
    do_divu3:
      start_noreorder ();
      macro_build (NULL, s, "0,x,y", op[1], op[2]);
      expr1.X_add_number = 2;
      macro_build (&expr1, "bnez", "x,p", op[2]);
      macro_build (NULL, "break", "6", 7);
      end_noreorder ();
      macro_build (NULL, s2, "x", op[0]);
      break;

    case M_DMUL:
      dbl = 1;
    case M_MUL:
      macro_build (NULL, dbl ? "dmultu" : "multu", "x,y", op[1], op[2]);
      macro_build (NULL, "mflo", "x", op[0]);
      break;

    case M_DSUBU_I:
      dbl = 1;
      goto do_subu;
    case M_SUBU_I:
    do_subu:
      imm_expr.X_add_number = -imm_expr.X_add_number;
      macro_build (&imm_expr, dbl ? "daddiu" : "addiu", "y,x,4", op[0], op[1]);
      break;

    case M_SUBU_I_2:
      imm_expr.X_add_number = -imm_expr.X_add_number;
      macro_build (&imm_expr, "addiu", "x,k", op[0]);
      break;

    case M_DSUBU_I_2:
      imm_expr.X_add_number = -imm_expr.X_add_number;
      macro_build (&imm_expr, "daddiu", "y,j", op[0]);
      break;

    case M_BEQ:
      s = "cmp";
      s2 = "bteqz";
      goto do_branch;
    case M_BNE:
      s = "cmp";
      s2 = "btnez";
      goto do_branch;
    case M_BLT:
      s = "slt";
      s2 = "btnez";
      goto do_branch;
    case M_BLTU:
      s = "sltu";
      s2 = "btnez";
      goto do_branch;
    case M_BLE:
      s = "slt";
      s2 = "bteqz";
      goto do_reverse_branch;
    case M_BLEU:
      s = "sltu";
      s2 = "bteqz";
      goto do_reverse_branch;
    case M_BGE:
      s = "slt";
      s2 = "bteqz";
      goto do_branch;
    case M_BGEU:
      s = "sltu";
      s2 = "bteqz";
      goto do_branch;
    case M_BGT:
      s = "slt";
      s2 = "btnez";
      goto do_reverse_branch;
    case M_BGTU:
      s = "sltu";
      s2 = "btnez";

    do_reverse_branch:
      tmp = op[1];
      op[1] = op[0];
      op[0] = tmp;

    do_branch:
      macro_build (NULL, s, "x,y", op[0], op[1]);
      macro_build (&offset_expr, s2, "p");
      break;

    case M_BEQ_I:
      s = "cmpi";
      s2 = "bteqz";
      s3 = "x,U";
      goto do_branch_i;
    case M_BNE_I:
      s = "cmpi";
      s2 = "btnez";
      s3 = "x,U";
      goto do_branch_i;
    case M_BLT_I:
      s = "slti";
      s2 = "btnez";
      s3 = "x,8";
      goto do_branch_i;
    case M_BLTU_I:
      s = "sltiu";
      s2 = "btnez";
      s3 = "x,8";
      goto do_branch_i;
    case M_BLE_I:
      s = "slti";
      s2 = "btnez";
      s3 = "x,8";
      goto do_addone_branch_i;
    case M_BLEU_I:
      s = "sltiu";
      s2 = "btnez";
      s3 = "x,8";
      goto do_addone_branch_i;
    case M_BGE_I:
      s = "slti";
      s2 = "bteqz";
      s3 = "x,8";
      goto do_branch_i;
    case M_BGEU_I:
      s = "sltiu";
      s2 = "bteqz";
      s3 = "x,8";
      goto do_branch_i;
    case M_BGT_I:
      s = "slti";
      s2 = "bteqz";
      s3 = "x,8";
      goto do_addone_branch_i;
    case M_BGTU_I:
      s = "sltiu";
      s2 = "bteqz";
      s3 = "x,8";

    do_addone_branch_i:
      ++imm_expr.X_add_number;

    do_branch_i:
      macro_build (&imm_expr, s, s3, op[0]);
      macro_build (&offset_expr, s2, "p");
      break;

    case M_ABS:
      expr1.X_add_number = 0;
      macro_build (&expr1, "slti", "x,8", op[1]);
      if (op[0] != op[1])
	macro_build (NULL, "move", "y,X", op[0], mips16_to_32_reg_map[op[1]]);
      expr1.X_add_number = 2;
      macro_build (&expr1, "bteqz", "p");
      macro_build (NULL, "neg", "x,w", op[0], op[0]);
      break;
    }
}

/* Look up instruction [START, START + LENGTH) in HASH.  Record any extra
   opcode bits in *OPCODE_EXTRA.  */

static struct mips_opcode *
mips_lookup_insn (struct hash_control *hash, const char *start,
		  ssize_t length, unsigned int *opcode_extra)
{
  char *name, *dot, *p;
  unsigned int mask, suffix;
  ssize_t opend;
  struct mips_opcode *insn;

  /* Make a copy of the instruction so that we can fiddle with it.  */
  name = alloca (length + 1);
  memcpy (name, start, length);
  name[length] = '\0';

  /* Look up the instruction as-is.  */
  insn = (struct mips_opcode *) hash_find (hash, name);
  if (insn)
    return insn;

  dot = strchr (name, '.');
  if (dot && dot[1])
    {
      /* Try to interpret the text after the dot as a VU0 channel suffix.  */
      p = mips_parse_vu0_channels (dot + 1, &mask);
      if (*p == 0 && mask != 0)
	{
	  *dot = 0;
	  insn = (struct mips_opcode *) hash_find (hash, name);
	  *dot = '.';
	  if (insn && (insn->pinfo2 & INSN2_VU0_CHANNEL_SUFFIX) != 0)
	    {
	      *opcode_extra |= mask << mips_vu0_channel_mask.lsb;
	      return insn;
	    }
	}
    }

  if (mips_opts.micromips)
    {
      /* See if there's an instruction size override suffix,
	 either `16' or `32', at the end of the mnemonic proper,
	 that defines the operation, i.e. before the first `.'
	 character if any.  Strip it and retry.  */
      opend = dot != NULL ? dot - name : length;
      if (opend >= 3 && name[opend - 2] == '1' && name[opend - 1] == '6')
	suffix = 2;
      else if (name[opend - 2] == '3' && name[opend - 1] == '2')
	suffix = 4;
      else
	suffix = 0;
      if (suffix)
	{
	  memcpy (name + opend - 2, name + opend, length - opend + 1);
	  insn = (struct mips_opcode *) hash_find (hash, name);
	  if (insn)
	    {
	      forced_insn_length = suffix;
	      return insn;
	    }
	}
    }

  return NULL;
}

/* Assemble an instruction into its binary format.  If the instruction
   is a macro, set imm_expr and offset_expr to the values associated
   with "I" and "A" operands respectively.  Otherwise store the value
   of the relocatable field (if any) in offset_expr.  In both cases
   set offset_reloc to the relocation operators applied to offset_expr.  */

static void
mips_ip (char *str, struct mips_cl_insn *insn)
{
  const struct mips_opcode *first, *past;
  struct hash_control *hash;
  char format;
  size_t end;
  struct mips_operand_token *tokens;
  unsigned int opcode_extra;

  if (mips_opts.micromips)
    {
      hash = micromips_op_hash;
      past = &micromips_opcodes[bfd_micromips_num_opcodes];
    }
  else
    {
      hash = op_hash;
      past = &mips_opcodes[NUMOPCODES];
    }
  forced_insn_length = 0;
  opcode_extra = 0;

  /* We first try to match an instruction up to a space or to the end.  */
  for (end = 0; str[end] != '\0' && !ISSPACE (str[end]); end++)
    continue;

  first = mips_lookup_insn (hash, str, end, &opcode_extra);
  if (first == NULL)
    {
      set_insn_error (0, _("unrecognized opcode"));
      return;
    }

  if (strcmp (first->name, "li.s") == 0)
    format = 'f';
  else if (strcmp (first->name, "li.d") == 0)
    format = 'd';
  else
    format = 0;
  tokens = mips_parse_arguments (str + end, format);
  if (!tokens)
    return;

  if (!match_insns (insn, first, past, tokens, opcode_extra, FALSE)
      && !match_insns (insn, first, past, tokens, opcode_extra, TRUE))
    set_insn_error (0, _("invalid operands"));

  obstack_free (&mips_operand_tokens, tokens);
}

/* As for mips_ip, but used when assembling MIPS16 code.
   Also set forced_insn_length to the resulting instruction size in
   bytes if the user explicitly requested a small or extended instruction.  */

static void
mips16_ip (char *str, struct mips_cl_insn *insn)
{
  char *end, *s, c;
  struct mips_opcode *first;
  struct mips_operand_token *tokens;

  forced_insn_length = 0;

  for (s = str; ISLOWER (*s); ++s)
    ;
  end = s;
  c = *end;
  switch (c)
    {
    case '\0':
      break;

    case ' ':
      s++;
      break;

    case '.':
      if (s[1] == 't' && s[2] == ' ')
	{
	  forced_insn_length = 2;
	  s += 3;
	  break;
	}
      else if (s[1] == 'e' && s[2] == ' ')
	{
	  forced_insn_length = 4;
	  s += 3;
	  break;
	}
      /* Fall through.  */
    default:
      set_insn_error (0, _("unrecognized opcode"));
      return;
    }

  if (mips_opts.noautoextend && !forced_insn_length)
    forced_insn_length = 2;

  *end = 0;
  first = (struct mips_opcode *) hash_find (mips16_op_hash, str);
  *end = c;

  if (!first)
    {
      set_insn_error (0, _("unrecognized opcode"));
      return;
    }

  tokens = mips_parse_arguments (s, 0);
  if (!tokens)
    return;

  if (!match_mips16_insns (insn, first, tokens))
    set_insn_error (0, _("invalid operands"));

  obstack_free (&mips_operand_tokens, tokens);
}

/* Marshal immediate value VAL for an extended MIPS16 instruction.
   NBITS is the number of significant bits in VAL.  */

static unsigned long
mips16_immed_extend (offsetT val, unsigned int nbits)
{
  int extval;
  if (nbits == 16)
    {
      extval = ((val >> 11) & 0x1f) | (val & 0x7e0);
      val &= 0x1f;
    }
  else if (nbits == 15)
    {
      extval = ((val >> 11) & 0xf) | (val & 0x7f0);
      val &= 0xf;
    }
  else
    {
      extval = ((val & 0x1f) << 6) | (val & 0x20);
      val = 0;
    }
  return (extval << 16) | val;
}

/* Like decode_mips16_operand, but require the operand to be defined and
   require it to be an integer.  */

static const struct mips_int_operand *
mips16_immed_operand (int type, bfd_boolean extended_p)
{
  const struct mips_operand *operand;

  operand = decode_mips16_operand (type, extended_p);
  if (!operand || (operand->type != OP_INT && operand->type != OP_PCREL))
    abort ();
  return (const struct mips_int_operand *) operand;
}

/* Return true if SVAL fits OPERAND.  RELOC is as for mips16_immed.  */

static bfd_boolean
mips16_immed_in_range_p (const struct mips_int_operand *operand,
			 bfd_reloc_code_real_type reloc, offsetT sval)
{
  int min_val, max_val;

  min_val = mips_int_operand_min (operand);
  max_val = mips_int_operand_max (operand);
  if (reloc != BFD_RELOC_UNUSED)
    {
      if (min_val < 0)
	sval = SEXT_16BIT (sval);
      else
	sval &= 0xffff;
    }

  return (sval >= min_val
	  && sval <= max_val
	  && (sval & ((1 << operand->shift) - 1)) == 0);
}

/* Install immediate value VAL into MIPS16 instruction *INSN,
   extending it if necessary.  The instruction in *INSN may
   already be extended.

   RELOC is the relocation that produced VAL, or BFD_RELOC_UNUSED
   if none.  In the former case, VAL is a 16-bit number with no
   defined signedness.

   TYPE is the type of the immediate field.  USER_INSN_LENGTH
   is the length that the user requested, or 0 if none.  */

static void
mips16_immed (char *file, unsigned int line, int type,
	      bfd_reloc_code_real_type reloc, offsetT val,
	      unsigned int user_insn_length, unsigned long *insn)
{
  const struct mips_int_operand *operand;
  unsigned int uval, length;

  operand = mips16_immed_operand (type, FALSE);
  if (!mips16_immed_in_range_p (operand, reloc, val))
    {
      /* We need an extended instruction.  */
      if (user_insn_length == 2)
	as_bad_where (file, line, _("invalid unextended operand value"));
      else
	*insn |= MIPS16_EXTEND;
    }
  else if (user_insn_length == 4)
    {
      /* The operand doesn't force an unextended instruction to be extended.
	 Warn if the user wanted an extended instruction anyway.  */
      *insn |= MIPS16_EXTEND;
      as_warn_where (file, line,
		     _("extended operand requested but not required"));
    }

  length = mips16_opcode_length (*insn);
  if (length == 4)
    {
      operand = mips16_immed_operand (type, TRUE);
      if (!mips16_immed_in_range_p (operand, reloc, val))
	as_bad_where (file, line,
		      _("operand value out of range for instruction"));
    }
  uval = ((unsigned int) val >> operand->shift) - operand->bias;
  if (length == 2)
    *insn = mips_insert_operand (&operand->root, *insn, uval);
  else
    *insn |= mips16_immed_extend (uval, operand->root.size);
}

struct percent_op_match
{
  const char *str;
  bfd_reloc_code_real_type reloc;
};

static const struct percent_op_match mips_percent_op[] =
{
  {"%lo", BFD_RELOC_LO16},
  {"%call_hi", BFD_RELOC_MIPS_CALL_HI16},
  {"%call_lo", BFD_RELOC_MIPS_CALL_LO16},
  {"%call16", BFD_RELOC_MIPS_CALL16},
  {"%got_disp", BFD_RELOC_MIPS_GOT_DISP},
  {"%got_page", BFD_RELOC_MIPS_GOT_PAGE},
  {"%got_ofst", BFD_RELOC_MIPS_GOT_OFST},
  {"%got_hi", BFD_RELOC_MIPS_GOT_HI16},
  {"%got_lo", BFD_RELOC_MIPS_GOT_LO16},
  {"%got", BFD_RELOC_MIPS_GOT16},
  {"%gp_rel", BFD_RELOC_GPREL16},
  {"%half", BFD_RELOC_16},
  {"%highest", BFD_RELOC_MIPS_HIGHEST},
  {"%higher", BFD_RELOC_MIPS_HIGHER},
  {"%neg", BFD_RELOC_MIPS_SUB},
  {"%tlsgd", BFD_RELOC_MIPS_TLS_GD},
  {"%tlsldm", BFD_RELOC_MIPS_TLS_LDM},
  {"%dtprel_hi", BFD_RELOC_MIPS_TLS_DTPREL_HI16},
  {"%dtprel_lo", BFD_RELOC_MIPS_TLS_DTPREL_LO16},
  {"%tprel_hi", BFD_RELOC_MIPS_TLS_TPREL_HI16},
  {"%tprel_lo", BFD_RELOC_MIPS_TLS_TPREL_LO16},
  {"%gottprel", BFD_RELOC_MIPS_TLS_GOTTPREL},
  {"%hi", BFD_RELOC_HI16_S}
};

static const struct percent_op_match mips16_percent_op[] =
{
  {"%lo", BFD_RELOC_MIPS16_LO16},
  {"%gprel", BFD_RELOC_MIPS16_GPREL},
  {"%got", BFD_RELOC_MIPS16_GOT16},
  {"%call16", BFD_RELOC_MIPS16_CALL16},
  {"%hi", BFD_RELOC_MIPS16_HI16_S},
  {"%tlsgd", BFD_RELOC_MIPS16_TLS_GD},
  {"%tlsldm", BFD_RELOC_MIPS16_TLS_LDM},
  {"%dtprel_hi", BFD_RELOC_MIPS16_TLS_DTPREL_HI16},
  {"%dtprel_lo", BFD_RELOC_MIPS16_TLS_DTPREL_LO16},
  {"%tprel_hi", BFD_RELOC_MIPS16_TLS_TPREL_HI16},
  {"%tprel_lo", BFD_RELOC_MIPS16_TLS_TPREL_LO16},
  {"%gottprel", BFD_RELOC_MIPS16_TLS_GOTTPREL}
};


/* Return true if *STR points to a relocation operator.  When returning true,
   move *STR over the operator and store its relocation code in *RELOC.
   Leave both *STR and *RELOC alone when returning false.  */

static bfd_boolean
parse_relocation (char **str, bfd_reloc_code_real_type *reloc)
{
  const struct percent_op_match *percent_op;
  size_t limit, i;

  if (mips_opts.mips16)
    {
      percent_op = mips16_percent_op;
      limit = ARRAY_SIZE (mips16_percent_op);
    }
  else
    {
      percent_op = mips_percent_op;
      limit = ARRAY_SIZE (mips_percent_op);
    }

  for (i = 0; i < limit; i++)
    if (strncasecmp (*str, percent_op[i].str, strlen (percent_op[i].str)) == 0)
      {
	int len = strlen (percent_op[i].str);

	if (!ISSPACE ((*str)[len]) && (*str)[len] != '(')
	  continue;

	*str += strlen (percent_op[i].str);
	*reloc = percent_op[i].reloc;

	/* Check whether the output BFD supports this relocation.
	   If not, issue an error and fall back on something safe.  */
	if (!bfd_reloc_type_lookup (stdoutput, percent_op[i].reloc))
	  {
	    as_bad (_("relocation %s isn't supported by the current ABI"),
		    percent_op[i].str);
	    *reloc = BFD_RELOC_UNUSED;
	  }
	return TRUE;
      }
  return FALSE;
}


/* Parse string STR as a 16-bit relocatable operand.  Store the
   expression in *EP and the relocations in the array starting
   at RELOC.  Return the number of relocation operators used.

   On exit, EXPR_END points to the first character after the expression.  */

static size_t
my_getSmallExpression (expressionS *ep, bfd_reloc_code_real_type *reloc,
		       char *str)
{
  bfd_reloc_code_real_type reversed_reloc[3];
  size_t reloc_index, i;
  int crux_depth, str_depth;
  char *crux;

  /* Search for the start of the main expression, recoding relocations
     in REVERSED_RELOC.  End the loop with CRUX pointing to the start
     of the main expression and with CRUX_DEPTH containing the number
     of open brackets at that point.  */
  reloc_index = -1;
  str_depth = 0;
  do
    {
      reloc_index++;
      crux = str;
      crux_depth = str_depth;

      /* Skip over whitespace and brackets, keeping count of the number
	 of brackets.  */
      while (*str == ' ' || *str == '\t' || *str == '(')
	if (*str++ == '(')
	  str_depth++;
    }
  while (*str == '%'
	 && reloc_index < (HAVE_NEWABI ? 3 : 1)
	 && parse_relocation (&str, &reversed_reloc[reloc_index]));

  my_getExpression (ep, crux);
  str = expr_end;

  /* Match every open bracket.  */
  while (crux_depth > 0 && (*str == ')' || *str == ' ' || *str == '\t'))
    if (*str++ == ')')
      crux_depth--;

  if (crux_depth > 0)
    as_bad (_("unclosed '('"));

  expr_end = str;

  if (reloc_index != 0)
    {
      prev_reloc_op_frag = frag_now;
      for (i = 0; i < reloc_index; i++)
	reloc[i] = reversed_reloc[reloc_index - 1 - i];
    }

  return reloc_index;
}

static void
my_getExpression (expressionS *ep, char *str)
{
  char *save_in;

  save_in = input_line_pointer;
  input_line_pointer = str;
  expression (ep);
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, target_big_endian);
}

void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

static int support_64bit_objects(void)
{
  const char **list, **l;
  int yes;

  list = bfd_target_list ();
  for (l = list; *l != NULL; l++)
    if (strcmp (*l, ELF_TARGET ("elf64-", "big")) == 0
	|| strcmp (*l, ELF_TARGET ("elf64-", "little")) == 0)
      break;
  yes = (*l != NULL);
  free (list);
  return yes;
}

/* Set STRING_PTR (either &mips_arch_string or &mips_tune_string) to
   NEW_VALUE.  Warn if another value was already specified.  Note:
   we have to defer parsing the -march and -mtune arguments in order
   to handle 'from-abi' correctly, since the ABI might be specified
   in a later argument.  */

static void
mips_set_option_string (const char **string_ptr, const char *new_value)
{
  if (*string_ptr != 0 && strcasecmp (*string_ptr, new_value) != 0)
    as_warn (_("a different %s was already specified, is now %s"),
	     string_ptr == &mips_arch_string ? "-march" : "-mtune",
	     new_value);

  *string_ptr = new_value;
}

int
md_parse_option (int c, char *arg)
{
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (mips_ases); i++)
    if (c == mips_ases[i].option_on || c == mips_ases[i].option_off)
      {
	file_ase_explicit |= mips_set_ase (&mips_ases[i],
					   c == mips_ases[i].option_on);
	return 1;
      }

  switch (c)
    {
    case OPTION_CONSTRUCT_FLOATS:
      mips_disable_float_construction = 0;
      break;

    case OPTION_NO_CONSTRUCT_FLOATS:
      mips_disable_float_construction = 1;
      break;

    case OPTION_TRAP:
      mips_trap = 1;
      break;

    case OPTION_BREAK:
      mips_trap = 0;
      break;

    case OPTION_EB:
      target_big_endian = 1;
      break;

    case OPTION_EL:
      target_big_endian = 0;
      break;

    case 'O':
      if (arg == NULL)
	mips_optimize = 1;
      else if (arg[0] == '0')
	mips_optimize = 0;
      else if (arg[0] == '1')
	mips_optimize = 1;
      else
	mips_optimize = 2;
      break;

    case 'g':
      if (arg == NULL)
	mips_debug = 2;
      else
	mips_debug = atoi (arg);
      break;

    case OPTION_MIPS1:
      file_mips_isa = ISA_MIPS1;
      break;

    case OPTION_MIPS2:
      file_mips_isa = ISA_MIPS2;
      break;

    case OPTION_MIPS3:
      file_mips_isa = ISA_MIPS3;
      break;

    case OPTION_MIPS4:
      file_mips_isa = ISA_MIPS4;
      break;

    case OPTION_MIPS5:
      file_mips_isa = ISA_MIPS5;
      break;

    case OPTION_MIPS32:
      file_mips_isa = ISA_MIPS32;
      break;

    case OPTION_MIPS32R2:
      file_mips_isa = ISA_MIPS32R2;
      break;

    case OPTION_MIPS64R2:
      file_mips_isa = ISA_MIPS64R2;
      break;

    case OPTION_MIPS64:
      file_mips_isa = ISA_MIPS64;
      break;

    case OPTION_MTUNE:
      mips_set_option_string (&mips_tune_string, arg);
      break;

    case OPTION_MARCH:
      mips_set_option_string (&mips_arch_string, arg);
      break;

    case OPTION_M4650:
      mips_set_option_string (&mips_arch_string, "4650");
      mips_set_option_string (&mips_tune_string, "4650");
      break;

    case OPTION_NO_M4650:
      break;

    case OPTION_M4010:
      mips_set_option_string (&mips_arch_string, "4010");
      mips_set_option_string (&mips_tune_string, "4010");
      break;

    case OPTION_NO_M4010:
      break;

    case OPTION_M4100:
      mips_set_option_string (&mips_arch_string, "4100");
      mips_set_option_string (&mips_tune_string, "4100");
      break;

    case OPTION_NO_M4100:
      break;

    case OPTION_M3900:
      mips_set_option_string (&mips_arch_string, "3900");
      mips_set_option_string (&mips_tune_string, "3900");
      break;

    case OPTION_NO_M3900:
      break;

    case OPTION_MICROMIPS:
      if (mips_opts.mips16 == 1)
	{
	  as_bad (_("-mmicromips cannot be used with -mips16"));
	  return 0;
	}
      mips_opts.micromips = 1;
      mips_no_prev_insn ();
      break;

    case OPTION_NO_MICROMIPS:
      mips_opts.micromips = 0;
      mips_no_prev_insn ();
      break;

    case OPTION_MIPS16:
      if (mips_opts.micromips == 1)
	{
	  as_bad (_("-mips16 cannot be used with -micromips"));
	  return 0;
	}
      mips_opts.mips16 = 1;
      mips_no_prev_insn ();
      break;

    case OPTION_NO_MIPS16:
      mips_opts.mips16 = 0;
      mips_no_prev_insn ();
      break;

    case OPTION_FIX_24K:
      mips_fix_24k = 1;
      break;

    case OPTION_NO_FIX_24K:
      mips_fix_24k = 0;
      break;

    case OPTION_FIX_LOONGSON2F_JUMP:
      mips_fix_loongson2f_jump = TRUE;
      break;

    case OPTION_NO_FIX_LOONGSON2F_JUMP:
      mips_fix_loongson2f_jump = FALSE;
      break;

    case OPTION_FIX_LOONGSON2F_NOP:
      mips_fix_loongson2f_nop = TRUE;
      break;

    case OPTION_NO_FIX_LOONGSON2F_NOP:
      mips_fix_loongson2f_nop = FALSE;
      break;

    case OPTION_FIX_VR4120:
      mips_fix_vr4120 = 1;
      break;

    case OPTION_NO_FIX_VR4120:
      mips_fix_vr4120 = 0;
      break;

    case OPTION_FIX_VR4130:
      mips_fix_vr4130 = 1;
      break;

    case OPTION_NO_FIX_VR4130:
      mips_fix_vr4130 = 0;
      break;

    case OPTION_FIX_CN63XXP1:
      mips_fix_cn63xxp1 = TRUE;
      break;

    case OPTION_NO_FIX_CN63XXP1:
      mips_fix_cn63xxp1 = FALSE;
      break;

    case OPTION_RELAX_BRANCH:
      mips_relax_branch = 1;
      break;

    case OPTION_NO_RELAX_BRANCH:
      mips_relax_branch = 0;
      break;

    case OPTION_INSN32:
      mips_opts.insn32 = TRUE;
      break;

    case OPTION_NO_INSN32:
      mips_opts.insn32 = FALSE;
      break;

    case OPTION_MSHARED:
      mips_in_shared = TRUE;
      break;

    case OPTION_MNO_SHARED:
      mips_in_shared = FALSE;
      break;

    case OPTION_MSYM32:
      mips_opts.sym32 = TRUE;
      break;

    case OPTION_MNO_SYM32:
      mips_opts.sym32 = FALSE;
      break;

      /* When generating ELF code, we permit -KPIC and -call_shared to
	 select SVR4_PIC, and -non_shared to select no PIC.  This is
	 intended to be compatible with Irix 5.  */
    case OPTION_CALL_SHARED:
      mips_pic = SVR4_PIC;
      mips_abicalls = TRUE;
      break;

    case OPTION_CALL_NONPIC:
      mips_pic = NO_PIC;
      mips_abicalls = TRUE;
      break;

    case OPTION_NON_SHARED:
      mips_pic = NO_PIC;
      mips_abicalls = FALSE;
      break;

      /* The -xgot option tells the assembler to use 32 bit offsets
         when accessing the got in SVR4_PIC mode.  It is for Irix
         compatibility.  */
    case OPTION_XGOT:
      mips_big_got = 1;
      break;

    case 'G':
      g_switch_value = atoi (arg);
      g_switch_seen = 1;
      break;

      /* The -32, -n32 and -64 options are shortcuts for -mabi=32, -mabi=n32
	 and -mabi=64.  */
    case OPTION_32:
      mips_abi = O32_ABI;
      break;

    case OPTION_N32:
      mips_abi = N32_ABI;
      break;

    case OPTION_64:
      mips_abi = N64_ABI;
      if (!support_64bit_objects())
	as_fatal (_("no compiled in support for 64 bit object file format"));
      break;

    case OPTION_GP32:
      file_mips_gp32 = 1;
      break;

    case OPTION_GP64:
      file_mips_gp32 = 0;
      break;

    case OPTION_FP32:
      file_mips_fp32 = 1;
      break;

    case OPTION_FP64:
      file_mips_fp32 = 0;
      break;

    case OPTION_SINGLE_FLOAT:
      file_mips_single_float = 1;
      break;

    case OPTION_DOUBLE_FLOAT:
      file_mips_single_float = 0;
      break;

    case OPTION_SOFT_FLOAT:
      file_mips_soft_float = 1;
      break;

    case OPTION_HARD_FLOAT:
      file_mips_soft_float = 0;
      break;

    case OPTION_MABI:
      if (strcmp (arg, "32") == 0)
	mips_abi = O32_ABI;
      else if (strcmp (arg, "o64") == 0)
	mips_abi = O64_ABI;
      else if (strcmp (arg, "n32") == 0)
	mips_abi = N32_ABI;
      else if (strcmp (arg, "64") == 0)
	{
	  mips_abi = N64_ABI;
	  if (! support_64bit_objects())
	    as_fatal (_("no compiled in support for 64 bit object file "
			"format"));
	}
      else if (strcmp (arg, "eabi") == 0)
	mips_abi = EABI_ABI;
      else
	{
	  as_fatal (_("invalid abi -mabi=%s"), arg);
	  return 0;
	}
      break;

    case OPTION_M7000_HILO_FIX:
      mips_7000_hilo_fix = TRUE;
      break;

    case OPTION_MNO_7000_HILO_FIX:
      mips_7000_hilo_fix = FALSE;
      break;

    case OPTION_MDEBUG:
      mips_flag_mdebug = TRUE;
      break;

    case OPTION_NO_MDEBUG:
      mips_flag_mdebug = FALSE;
      break;

    case OPTION_PDR:
      mips_flag_pdr = TRUE;
      break;

    case OPTION_NO_PDR:
      mips_flag_pdr = FALSE;
      break;

    case OPTION_MVXWORKS_PIC:
      mips_pic = VXWORKS_PIC;
      break;

    case OPTION_NAN:
      if (strcmp (arg, "2008") == 0)
	mips_flag_nan2008 = TRUE;
      else if (strcmp (arg, "legacy") == 0)
	mips_flag_nan2008 = FALSE;
      else
	{
	  as_fatal (_("invalid NaN setting -mnan=%s"), arg);
	  return 0;
	}
      break;

    default:
      return 0;
    }

    mips_fix_loongson2f = mips_fix_loongson2f_nop || mips_fix_loongson2f_jump;

  return 1;
}

/* Set up globals to generate code for the ISA or processor
   described by INFO.  */

static void
mips_set_architecture (const struct mips_cpu_info *info)
{
  if (info != 0)
    {
      file_mips_arch = info->cpu;
      mips_opts.arch = info->cpu;
      mips_opts.isa = info->isa;
    }
}


/* Likewise for tuning.  */

static void
mips_set_tune (const struct mips_cpu_info *info)
{
  if (info != 0)
    mips_tune = info->cpu;
}


void
mips_after_parse_args (void)
{
  const struct mips_cpu_info *arch_info = 0;
  const struct mips_cpu_info *tune_info = 0;

  /* GP relative stuff not working for PE */
  if (strncmp (TARGET_OS, "pe", 2) == 0)
    {
      if (g_switch_seen && g_switch_value != 0)
	as_bad (_("-G not supported in this configuration"));
      g_switch_value = 0;
    }

  if (mips_abi == NO_ABI)
    mips_abi = MIPS_DEFAULT_ABI;

  /* The following code determines the architecture and register size.
     Similar code was added to GCC 3.3 (see override_options() in
     config/mips/mips.c).  The GAS and GCC code should be kept in sync
     as much as possible.  */

  if (mips_arch_string != 0)
    arch_info = mips_parse_cpu ("-march", mips_arch_string);

  if (file_mips_isa != ISA_UNKNOWN)
    {
      /* Handle -mipsN.  At this point, file_mips_isa contains the
	 ISA level specified by -mipsN, while arch_info->isa contains
	 the -march selection (if any).  */
      if (arch_info != 0)
	{
	  /* -march takes precedence over -mipsN, since it is more descriptive.
	     There's no harm in specifying both as long as the ISA levels
	     are the same.  */
	  if (file_mips_isa != arch_info->isa)
	    as_bad (_("-%s conflicts with the other architecture options,"
		      " which imply -%s"),
		    mips_cpu_info_from_isa (file_mips_isa)->name,
		    mips_cpu_info_from_isa (arch_info->isa)->name);
	}
      else
	arch_info = mips_cpu_info_from_isa (file_mips_isa);
    }

  if (arch_info == 0)
    {
      arch_info = mips_parse_cpu ("default CPU", MIPS_CPU_STRING_DEFAULT);
      gas_assert (arch_info);
    }

  if (ABI_NEEDS_64BIT_REGS (mips_abi) && !ISA_HAS_64BIT_REGS (arch_info->isa))
    as_bad (_("-march=%s is not compatible with the selected ABI"),
	    arch_info->name);

  mips_set_architecture (arch_info);

  /* Optimize for file_mips_arch, unless -mtune selects a different processor.  */
  if (mips_tune_string != 0)
    tune_info = mips_parse_cpu ("-mtune", mips_tune_string);

  if (tune_info == 0)
    mips_set_tune (arch_info);
  else
    mips_set_tune (tune_info);

  if (file_mips_gp32 >= 0)
    {
      /* The user specified the size of the integer registers.  Make sure
	 it agrees with the ABI and ISA.  */
      if (file_mips_gp32 == 0 && !ISA_HAS_64BIT_REGS (mips_opts.isa))
	as_bad (_("-mgp64 used with a 32-bit processor"));
      else if (file_mips_gp32 == 1 && ABI_NEEDS_64BIT_REGS (mips_abi))
	as_bad (_("-mgp32 used with a 64-bit ABI"));
      else if (file_mips_gp32 == 0 && ABI_NEEDS_32BIT_REGS (mips_abi))
	as_bad (_("-mgp64 used with a 32-bit ABI"));
    }
  else
    {
      /* Infer the integer register size from the ABI and processor.
	 Restrict ourselves to 32-bit registers if that's all the
	 processor has, or if the ABI cannot handle 64-bit registers.  */
      file_mips_gp32 = (ABI_NEEDS_32BIT_REGS (mips_abi)
			|| !ISA_HAS_64BIT_REGS (mips_opts.isa));
    }

  switch (file_mips_fp32)
    {
    default:
    case -1:
      /* No user specified float register size.
	 ??? GAS treats single-float processors as though they had 64-bit
	 float registers (although it complains when double-precision
	 instructions are used).  As things stand, saying they have 32-bit
	 registers would lead to spurious "register must be even" messages.
	 So here we assume float registers are never smaller than the
	 integer ones.  */
      if (file_mips_gp32 == 0)
	/* 64-bit integer registers implies 64-bit float registers.  */
	file_mips_fp32 = 0;
      else if ((mips_opts.ase & FP64_ASES)
	       && ISA_HAS_64BIT_FPRS (mips_opts.isa))
	/* -mips3d and -mdmx imply 64-bit float registers, if possible.  */
	file_mips_fp32 = 0;
      else
	/* 32-bit float registers.  */
	file_mips_fp32 = 1;
      break;

    /* The user specified the size of the float registers.  Check if it
       agrees with the ABI and ISA.  */
    case 0:
      if (!ISA_HAS_64BIT_FPRS (mips_opts.isa))
	as_bad (_("-mfp64 used with a 32-bit fpu"));
      else if (ABI_NEEDS_32BIT_REGS (mips_abi)
	       && !ISA_HAS_MXHC1 (mips_opts.isa))
	as_warn (_("-mfp64 used with a 32-bit ABI"));
      break;
    case 1:
      if (ABI_NEEDS_64BIT_REGS (mips_abi))
	as_warn (_("-mfp32 used with a 64-bit ABI"));
      break;
    }

  /* End of GCC-shared inference code.  */

  /* This flag is set when we have a 64-bit capable CPU but use only
     32-bit wide registers.  Note that EABI does not use it.  */
  if (ISA_HAS_64BIT_REGS (mips_opts.isa)
      && ((mips_abi == NO_ABI && file_mips_gp32 == 1)
	  || mips_abi == O32_ABI))
    mips_32bitmode = 1;

  if (mips_opts.isa == ISA_MIPS1 && mips_trap)
    as_bad (_("trap exception not supported at ISA 1"));

  /* If the selected architecture includes support for ASEs, enable
     generation of code for them.  */
  if (mips_opts.mips16 == -1)
    mips_opts.mips16 = (CPU_HAS_MIPS16 (file_mips_arch)) ? 1 : 0;
  if (mips_opts.micromips == -1)
    mips_opts.micromips = (CPU_HAS_MICROMIPS (file_mips_arch)) ? 1 : 0;

  /* MIPS3D and MDMX require 64-bit FPRs, so -mfp32 should stop those
     ASEs from being selected implicitly.  */
  if (file_mips_fp32 == 1)
    file_ase_explicit |= ASE_MIPS3D | ASE_MDMX;

  /* If the user didn't explicitly select or deselect a particular ASE,
     use the default setting for the CPU.  */
  mips_opts.ase |= (arch_info->ase & ~file_ase_explicit);

  file_mips_isa = mips_opts.isa;
  file_ase = mips_opts.ase;
  mips_opts.gp32 = file_mips_gp32;
  mips_opts.fp32 = file_mips_fp32;
  mips_opts.soft_float = file_mips_soft_float;
  mips_opts.single_float = file_mips_single_float;

  mips_check_isa_supports_ases ();

  if (mips_flag_mdebug < 0)
    mips_flag_mdebug = 0;
}

void
mips_init_after_args (void)
{
  /* initialize opcodes */
  bfd_mips_num_opcodes = bfd_mips_num_builtin_opcodes;
  mips_opcodes = (struct mips_opcode *) mips_builtin_opcodes;
}

long
md_pcrel_from (fixS *fixP)
{
  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_MICROMIPS_7_PCREL_S1:
    case BFD_RELOC_MICROMIPS_10_PCREL_S1:
      /* Return the address of the delay slot.  */
      return addr + 2;

    case BFD_RELOC_MICROMIPS_16_PCREL_S1:
    case BFD_RELOC_MICROMIPS_JMP:
    case BFD_RELOC_16_PCREL_S2:
    case BFD_RELOC_MIPS_JMP:
      /* Return the address of the delay slot.  */
      return addr + 4;

    case BFD_RELOC_32_PCREL:
      return addr;

    default:
      /* We have no relocation type for PC relative MIPS16 instructions.  */
      if (fixP->fx_addsy && S_GET_SEGMENT (fixP->fx_addsy) != now_seg)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("PC relative MIPS16 instruction references"
			" a different section"));
      return addr;
    }
}

/* This is called before the symbol table is processed.  In order to
   work with gcc when using mips-tfile, we must keep all local labels.
   However, in other cases, we want to discard them.  If we were
   called with -g, but we didn't see any debugging information, it may
   mean that gcc is smuggling debugging information through to
   mips-tfile, in which case we must generate all local labels.  */

void
mips_frob_file_before_adjust (void)
{
#ifndef NO_ECOFF_DEBUGGING
  if (ECOFF_DEBUGGING
      && mips_debug != 0
      && ! ecoff_debugging_seen)
    flag_keep_locals = 1;
#endif
}

/* Sort any unmatched HI16 and GOT16 relocs so that they immediately precede
   the corresponding LO16 reloc.  This is called before md_apply_fix and
   tc_gen_reloc.  Unmatched relocs can only be generated by use of explicit
   relocation operators.

   For our purposes, a %lo() expression matches a %got() or %hi()
   expression if:

      (a) it refers to the same symbol; and
      (b) the offset applied in the %lo() expression is no lower than
	  the offset applied in the %got() or %hi().

   (b) allows us to cope with code like:

	lui	$4,%hi(foo)
	lh	$4,%lo(foo+2)($4)

   ...which is legal on RELA targets, and has a well-defined behaviour
   if the user knows that adding 2 to "foo" will not induce a carry to
   the high 16 bits.

   When several %lo()s match a particular %got() or %hi(), we use the
   following rules to distinguish them:

     (1) %lo()s with smaller offsets are a better match than %lo()s with
         higher offsets.

     (2) %lo()s with no matching %got() or %hi() are better than those
         that already have a matching %got() or %hi().

     (3) later %lo()s are better than earlier %lo()s.

   These rules are applied in order.

   (1) means, among other things, that %lo()s with identical offsets are
   chosen if they exist.

   (2) means that we won't associate several high-part relocations with
   the same low-part relocation unless there's no alternative.  Having
   several high parts for the same low part is a GNU extension; this rule
   allows careful users to avoid it.

   (3) is purely cosmetic.  mips_hi_fixup_list is is in reverse order,
   with the last high-part relocation being at the front of the list.
   It therefore makes sense to choose the last matching low-part
   relocation, all other things being equal.  It's also easier
   to code that way.  */

void
mips_frob_file (void)
{
  struct mips_hi_fixup *l;
  bfd_reloc_code_real_type looking_for_rtype = BFD_RELOC_UNUSED;

  for (l = mips_hi_fixup_list; l != NULL; l = l->next)
    {
      segment_info_type *seginfo;
      bfd_boolean matched_lo_p;
      fixS **hi_pos, **lo_pos, **pos;

      gas_assert (reloc_needs_lo_p (l->fixp->fx_r_type));

      /* If a GOT16 relocation turns out to be against a global symbol,
	 there isn't supposed to be a matching LO.  Ignore %gots against
	 constants; we'll report an error for those later.  */
      if (got16_reloc_p (l->fixp->fx_r_type)
	  && !(l->fixp->fx_addsy
	       && pic_need_relax (l->fixp->fx_addsy, l->seg)))
	continue;

      /* Check quickly whether the next fixup happens to be a matching %lo.  */
      if (fixup_has_matching_lo_p (l->fixp))
	continue;

      seginfo = seg_info (l->seg);

      /* Set HI_POS to the position of this relocation in the chain.
	 Set LO_POS to the position of the chosen low-part relocation.
	 MATCHED_LO_P is true on entry to the loop if *POS is a low-part
	 relocation that matches an immediately-preceding high-part
	 relocation.  */
      hi_pos = NULL;
      lo_pos = NULL;
      matched_lo_p = FALSE;
      looking_for_rtype = matching_lo_reloc (l->fixp->fx_r_type);

      for (pos = &seginfo->fix_root; *pos != NULL; pos = &(*pos)->fx_next)
	{
	  if (*pos == l->fixp)
	    hi_pos = pos;

	  if ((*pos)->fx_r_type == looking_for_rtype
	      && symbol_same_p ((*pos)->fx_addsy, l->fixp->fx_addsy)
	      && (*pos)->fx_offset >= l->fixp->fx_offset
	      && (lo_pos == NULL
		  || (*pos)->fx_offset < (*lo_pos)->fx_offset
		  || (!matched_lo_p
		      && (*pos)->fx_offset == (*lo_pos)->fx_offset)))
	    lo_pos = pos;

	  matched_lo_p = (reloc_needs_lo_p ((*pos)->fx_r_type)
			  && fixup_has_matching_lo_p (*pos));
	}

      /* If we found a match, remove the high-part relocation from its
	 current position and insert it before the low-part relocation.
	 Make the offsets match so that fixup_has_matching_lo_p()
	 will return true.

	 We don't warn about unmatched high-part relocations since some
	 versions of gcc have been known to emit dead "lui ...%hi(...)"
	 instructions.  */
      if (lo_pos != NULL)
	{
	  l->fixp->fx_offset = (*lo_pos)->fx_offset;
	  if (l->fixp->fx_next != *lo_pos)
	    {
	      *hi_pos = l->fixp->fx_next;
	      l->fixp->fx_next = *lo_pos;
	      *lo_pos = l->fixp;
	    }
	}
    }
}

int
mips_force_relocation (fixS *fixp)
{
  if (generic_force_reloc (fixp))
    return 1;

  /* We want to keep BFD_RELOC_MICROMIPS_*_PCREL_S1 relocation,
     so that the linker relaxation can update targets.  */
  if (fixp->fx_r_type == BFD_RELOC_MICROMIPS_7_PCREL_S1
      || fixp->fx_r_type == BFD_RELOC_MICROMIPS_10_PCREL_S1
      || fixp->fx_r_type == BFD_RELOC_MICROMIPS_16_PCREL_S1)
    return 1;

  return 0;
}

/* Read the instruction associated with RELOC from BUF.  */

static unsigned int
read_reloc_insn (char *buf, bfd_reloc_code_real_type reloc)
{
  if (mips16_reloc_p (reloc) || micromips_reloc_p (reloc))
    return read_compressed_insn (buf, 4);
  else
    return read_insn (buf);
}

/* Write instruction INSN to BUF, given that it has been relocated
   by RELOC.  */

static void
write_reloc_insn (char *buf, bfd_reloc_code_real_type reloc,
		  unsigned long insn)
{
  if (mips16_reloc_p (reloc) || micromips_reloc_p (reloc))
    write_compressed_insn (buf, insn, 4);
  else
    write_insn (buf, insn);
}

/* Apply a fixup to the object file.  */

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *buf;
  unsigned long insn;
  reloc_howto_type *howto;

  /* We ignore generic BFD relocations we don't know about.  */
  howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
  if (! howto)
    return;

  gas_assert (fixP->fx_size == 2
	      || fixP->fx_size == 4
	      || fixP->fx_r_type == BFD_RELOC_16
	      || fixP->fx_r_type == BFD_RELOC_64
	      || fixP->fx_r_type == BFD_RELOC_CTOR
	      || fixP->fx_r_type == BFD_RELOC_MIPS_SUB
	      || fixP->fx_r_type == BFD_RELOC_MICROMIPS_SUB
	      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
	      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY
	      || fixP->fx_r_type == BFD_RELOC_MIPS_TLS_DTPREL64);

  buf = fixP->fx_frag->fr_literal + fixP->fx_where;

  gas_assert (!fixP->fx_pcrel || fixP->fx_r_type == BFD_RELOC_16_PCREL_S2
	      || fixP->fx_r_type == BFD_RELOC_MICROMIPS_7_PCREL_S1
	      || fixP->fx_r_type == BFD_RELOC_MICROMIPS_10_PCREL_S1
	      || fixP->fx_r_type == BFD_RELOC_MICROMIPS_16_PCREL_S1
	      || fixP->fx_r_type == BFD_RELOC_32_PCREL);

  /* Don't treat parts of a composite relocation as done.  There are two
     reasons for this:

     (1) The second and third parts will be against 0 (RSS_UNDEF) but
	 should nevertheless be emitted if the first part is.

     (2) In normal usage, composite relocations are never assembly-time
	 constants.  The easiest way of dealing with the pathological
	 exceptions is to generate a relocation against STN_UNDEF and
	 leave everything up to the linker.  */
  if (fixP->fx_addsy == NULL && !fixP->fx_pcrel && fixP->fx_tcbit == 0)
    fixP->fx_done = 1;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_MIPS_TLS_GD:
    case BFD_RELOC_MIPS_TLS_LDM:
    case BFD_RELOC_MIPS_TLS_DTPREL32:
    case BFD_RELOC_MIPS_TLS_DTPREL64:
    case BFD_RELOC_MIPS_TLS_DTPREL_HI16:
    case BFD_RELOC_MIPS_TLS_DTPREL_LO16:
    case BFD_RELOC_MIPS_TLS_GOTTPREL:
    case BFD_RELOC_MIPS_TLS_TPREL32:
    case BFD_RELOC_MIPS_TLS_TPREL64:
    case BFD_RELOC_MIPS_TLS_TPREL_HI16:
    case BFD_RELOC_MIPS_TLS_TPREL_LO16:
    case BFD_RELOC_MICROMIPS_TLS_GD:
    case BFD_RELOC_MICROMIPS_TLS_LDM:
    case BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16:
    case BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16:
    case BFD_RELOC_MICROMIPS_TLS_GOTTPREL:
    case BFD_RELOC_MICROMIPS_TLS_TPREL_HI16:
    case BFD_RELOC_MICROMIPS_TLS_TPREL_LO16:
    case BFD_RELOC_MIPS16_TLS_GD:
    case BFD_RELOC_MIPS16_TLS_LDM:
    case BFD_RELOC_MIPS16_TLS_DTPREL_HI16:
    case BFD_RELOC_MIPS16_TLS_DTPREL_LO16:
    case BFD_RELOC_MIPS16_TLS_GOTTPREL:
    case BFD_RELOC_MIPS16_TLS_TPREL_HI16:
    case BFD_RELOC_MIPS16_TLS_TPREL_LO16:
      if (!fixP->fx_addsy)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("TLS relocation against a constant"));
	  break;
	}
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* fall through */

    case BFD_RELOC_MIPS_JMP:
    case BFD_RELOC_MIPS_SHIFT5:
    case BFD_RELOC_MIPS_SHIFT6:
    case BFD_RELOC_MIPS_GOT_DISP:
    case BFD_RELOC_MIPS_GOT_PAGE:
    case BFD_RELOC_MIPS_GOT_OFST:
    case BFD_RELOC_MIPS_SUB:
    case BFD_RELOC_MIPS_INSERT_A:
    case BFD_RELOC_MIPS_INSERT_B:
    case BFD_RELOC_MIPS_DELETE:
    case BFD_RELOC_MIPS_HIGHEST:
    case BFD_RELOC_MIPS_HIGHER:
    case BFD_RELOC_MIPS_SCN_DISP:
    case BFD_RELOC_MIPS_REL16:
    case BFD_RELOC_MIPS_RELGOT:
    case BFD_RELOC_MIPS_JALR:
    case BFD_RELOC_HI16:
    case BFD_RELOC_HI16_S:
    case BFD_RELOC_LO16:
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_MIPS_LITERAL:
    case BFD_RELOC_MIPS_CALL16:
    case BFD_RELOC_MIPS_GOT16:
    case BFD_RELOC_GPREL32:
    case BFD_RELOC_MIPS_GOT_HI16:
    case BFD_RELOC_MIPS_GOT_LO16:
    case BFD_RELOC_MIPS_CALL_HI16:
    case BFD_RELOC_MIPS_CALL_LO16:
    case BFD_RELOC_MIPS16_GPREL:
    case BFD_RELOC_MIPS16_GOT16:
    case BFD_RELOC_MIPS16_CALL16:
    case BFD_RELOC_MIPS16_HI16:
    case BFD_RELOC_MIPS16_HI16_S:
    case BFD_RELOC_MIPS16_LO16:
    case BFD_RELOC_MIPS16_JMP:
    case BFD_RELOC_MICROMIPS_JMP:
    case BFD_RELOC_MICROMIPS_GOT_DISP:
    case BFD_RELOC_MICROMIPS_GOT_PAGE:
    case BFD_RELOC_MICROMIPS_GOT_OFST:
    case BFD_RELOC_MICROMIPS_SUB:
    case BFD_RELOC_MICROMIPS_HIGHEST:
    case BFD_RELOC_MICROMIPS_HIGHER:
    case BFD_RELOC_MICROMIPS_SCN_DISP:
    case BFD_RELOC_MICROMIPS_JALR:
    case BFD_RELOC_MICROMIPS_HI16:
    case BFD_RELOC_MICROMIPS_HI16_S:
    case BFD_RELOC_MICROMIPS_LO16:
    case BFD_RELOC_MICROMIPS_GPREL16:
    case BFD_RELOC_MICROMIPS_LITERAL:
    case BFD_RELOC_MICROMIPS_CALL16:
    case BFD_RELOC_MICROMIPS_GOT16:
    case BFD_RELOC_MICROMIPS_GOT_HI16:
    case BFD_RELOC_MICROMIPS_GOT_LO16:
    case BFD_RELOC_MICROMIPS_CALL_HI16:
    case BFD_RELOC_MICROMIPS_CALL_LO16:
    case BFD_RELOC_MIPS_EH:
      if (fixP->fx_done)
	{
	  offsetT value;

	  if (calculate_reloc (fixP->fx_r_type, *valP, &value))
	    {
	      insn = read_reloc_insn (buf, fixP->fx_r_type);
	      if (mips16_reloc_p (fixP->fx_r_type))
		insn |= mips16_immed_extend (value, 16);
	      else
		insn |= (value & 0xffff);
	      write_reloc_insn (buf, fixP->fx_r_type, insn);
	    }
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unsupported constant in relocation"));
	}
      break;

    case BFD_RELOC_64:
      /* This is handled like BFD_RELOC_32, but we output a sign
         extended value if we are only 32 bits.  */
      if (fixP->fx_done)
	{
	  if (8 <= sizeof (valueT))
	    md_number_to_chars (buf, *valP, 8);
	  else
	    {
	      valueT hiv;

	      if ((*valP & 0x80000000) != 0)
		hiv = 0xffffffff;
	      else
		hiv = 0;
	      md_number_to_chars (buf + (target_big_endian ? 4 : 0), *valP, 4);
	      md_number_to_chars (buf + (target_big_endian ? 0 : 4), hiv, 4);
	    }
	}
      break;

    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
    case BFD_RELOC_32_PCREL:
    case BFD_RELOC_16:
      /* If we are deleting this reloc entry, we must fill in the
	 value now.  This can happen if we have a .word which is not
	 resolved when it appears but is later defined.  */
      if (fixP->fx_done)
	md_number_to_chars (buf, *valP, fixP->fx_size);
      break;

    case BFD_RELOC_16_PCREL_S2:
      if ((*valP & 0x3) != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch to misaligned address (%lx)"), (long) *valP);

      /* We need to save the bits in the instruction since fixup_segment()
	 might be deleting the relocation entry (i.e., a branch within
	 the current segment).  */
      if (! fixP->fx_done)
	break;

      /* Update old instruction data.  */
      insn = read_insn (buf);

      if (*valP + 0x20000 <= 0x3ffff)
	{
	  insn |= (*valP >> 2) & 0xffff;
	  write_insn (buf, insn);
	}
      else if (mips_pic == NO_PIC
	       && fixP->fx_done
	       && fixP->fx_frag->fr_address >= text_section->vma
	       && (fixP->fx_frag->fr_address
		   < text_section->vma + bfd_get_section_size (text_section))
	       && ((insn & 0xffff0000) == 0x10000000	 /* beq $0,$0 */
		   || (insn & 0xffff0000) == 0x04010000	 /* bgez $0 */
		   || (insn & 0xffff0000) == 0x04110000)) /* bgezal $0 */
	{
	  /* The branch offset is too large.  If this is an
             unconditional branch, and we are not generating PIC code,
             we can convert it to an absolute jump instruction.  */
	  if ((insn & 0xffff0000) == 0x04110000)	 /* bgezal $0 */
	    insn = 0x0c000000;	/* jal */
	  else
	    insn = 0x08000000;	/* j */
	  fixP->fx_r_type = BFD_RELOC_MIPS_JMP;
	  fixP->fx_done = 0;
	  fixP->fx_addsy = section_symbol (text_section);
	  *valP += md_pcrel_from (fixP);
	  write_insn (buf, insn);
	}
      else
	{
	  /* If we got here, we have branch-relaxation disabled,
	     and there's nothing we can do to fix this instruction
	     without turning it into a longer sequence.  */
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	}
      break;

    case BFD_RELOC_MICROMIPS_7_PCREL_S1:
    case BFD_RELOC_MICROMIPS_10_PCREL_S1:
    case BFD_RELOC_MICROMIPS_16_PCREL_S1:
      /* We adjust the offset back to even.  */
      if ((*valP & 0x1) != 0)
	--(*valP);

      if (! fixP->fx_done)
	break;

      /* Should never visit here, because we keep the relocation.  */
      abort ();
      break;

    case BFD_RELOC_VTABLE_INHERIT:
      fixP->fx_done = 0;
      if (fixP->fx_addsy
          && !S_IS_DEFINED (fixP->fx_addsy)
          && !S_IS_WEAK (fixP->fx_addsy))
        S_SET_WEAK (fixP->fx_addsy);
      break;

    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      break;

    default:
      abort ();
    }

  /* Remember value for tc_gen_reloc.  */
  fixP->fx_addnumber = *valP;
}

static symbolS *
get_symbol (void)
{
  int c;
  char *name;
  symbolS *p;

  name = input_line_pointer;
  c = get_symbol_end ();
  p = (symbolS *) symbol_find_or_make (name);
  *input_line_pointer = c;
  return p;
}

/* Align the current frag to a given power of two.  If a particular
   fill byte should be used, FILL points to an integer that contains
   that byte, otherwise FILL is null.

   This function used to have the comment:

      The MIPS assembler also automatically adjusts any preceding label.

   The implementation therefore applied the adjustment to a maximum of
   one label.  However, other label adjustments are applied to batches
   of labels, and adjusting just one caused problems when new labels
   were added for the sake of debugging or unwind information.
   We therefore adjust all preceding labels (given as LABELS) instead.  */

static void
mips_align (int to, int *fill, struct insn_label_list *labels)
{
  mips_emit_delays ();
  mips_record_compressed_mode ();
  if (fill == NULL && subseg_text_p (now_seg))
    frag_align_code (to, 0);
  else
    frag_align (to, fill ? *fill : 0, 0);
  record_alignment (now_seg, to);
  mips_move_labels (labels, FALSE);
}

/* Align to a given power of two.  .align 0 turns off the automatic
   alignment used by the data creating pseudo-ops.  */

static void
s_align (int x ATTRIBUTE_UNUSED)
{
  int temp, fill_value, *fill_ptr;
  long max_alignment = 28;

  /* o Note that the assembler pulls down any immediately preceding label
       to the aligned address.
     o It's not documented but auto alignment is reinstated by
       a .align pseudo instruction.
     o Note also that after auto alignment is turned off the mips assembler
       issues an error on attempt to assemble an improperly aligned data item.
       We don't.  */

  temp = get_absolute_expression ();
  if (temp > max_alignment)
    as_bad (_("alignment too large, %d assumed"), temp = max_alignment);
  else if (temp < 0)
    {
      as_warn (_("alignment negative, 0 assumed"));
      temp = 0;
    }
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      fill_value = get_absolute_expression ();
      fill_ptr = &fill_value;
    }
  else
    fill_ptr = 0;
  if (temp)
    {
      segment_info_type *si = seg_info (now_seg);
      struct insn_label_list *l = si->label_list;
      /* Auto alignment should be switched on by next section change.  */
      auto_align = 1;
      mips_align (temp, fill_ptr, l);
    }
  else
    {
      auto_align = 0;
    }

  demand_empty_rest_of_line ();
}

static void
s_change_sec (int sec)
{
  segT seg;

  /* The ELF backend needs to know that we are changing sections, so
     that .previous works correctly.  We could do something like check
     for an obj_section_change_hook macro, but that might be confusing
     as it would not be appropriate to use it in the section changing
     functions in read.c, since obj-elf.c intercepts those.  FIXME:
     This should be cleaner, somehow.  */
  obj_elf_section_change_hook ();

  mips_emit_delays ();

  switch (sec)
    {
    case 't':
      s_text (0);
      break;
    case 'd':
      s_data (0);
      break;
    case 'b':
      subseg_set (bss_section, (subsegT) get_absolute_expression ());
      demand_empty_rest_of_line ();
      break;

    case 'r':
      seg = subseg_new (RDATA_SECTION_NAME,
			(subsegT) get_absolute_expression ());
      bfd_set_section_flags (stdoutput, seg, (SEC_ALLOC | SEC_LOAD
					      | SEC_READONLY | SEC_RELOC
					      | SEC_DATA));
      if (strncmp (TARGET_OS, "elf", 3) != 0)
	record_alignment (seg, 4);
      demand_empty_rest_of_line ();
      break;

    case 's':
      seg = subseg_new (".sdata", (subsegT) get_absolute_expression ());
      bfd_set_section_flags (stdoutput, seg,
			     SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);
      if (strncmp (TARGET_OS, "elf", 3) != 0)
	record_alignment (seg, 4);
      demand_empty_rest_of_line ();
      break;

    case 'B':
      seg = subseg_new (".sbss", (subsegT) get_absolute_expression ());
      bfd_set_section_flags (stdoutput, seg, SEC_ALLOC);
      if (strncmp (TARGET_OS, "elf", 3) != 0)
	record_alignment (seg, 4);
      demand_empty_rest_of_line ();
      break;
    }

  auto_align = 1;
}

void
s_change_section (int ignore ATTRIBUTE_UNUSED)
{
  char *section_name;
  char c;
  char next_c = 0;
  int section_type;
  int section_flag;
  int section_entry_size;
  int section_alignment;

  section_name = input_line_pointer;
  c = get_symbol_end ();
  if (c)
    next_c = *(input_line_pointer + 1);

  /* Do we have .section Name<,"flags">?  */
  if (c != ',' || (c == ',' && next_c == '"'))
    {
      /* just after name is now '\0'.  */
      *input_line_pointer = c;
      input_line_pointer = section_name;
      obj_elf_section (ignore);
      return;
    }
  input_line_pointer++;

  /* Do we have .section Name<,type><,flag><,entry_size><,alignment>  */
  if (c == ',')
    section_type = get_absolute_expression ();
  else
    section_type = 0;
  if (*input_line_pointer++ == ',')
    section_flag = get_absolute_expression ();
  else
    section_flag = 0;
  if (*input_line_pointer++ == ',')
    section_entry_size = get_absolute_expression ();
  else
    section_entry_size = 0;
  if (*input_line_pointer++ == ',')
    section_alignment = get_absolute_expression ();
  else
    section_alignment = 0;
  /* FIXME: really ignore?  */
  (void) section_alignment;

  section_name = xstrdup (section_name);

  /* When using the generic form of .section (as implemented by obj-elf.c),
     there's no way to set the section type to SHT_MIPS_DWARF.  Users have
     traditionally had to fall back on the more common @@progbits instead.

     There's nothing really harmful in this, since bfd will correct
     SHT_PROGBITS to SHT_MIPS_DWARF before writing out the file.  But it
     means that, for backwards compatibility, the special_section entries
     for dwarf sections must use SHT_PROGBITS rather than SHT_MIPS_DWARF.

     Even so, we shouldn't force users of the MIPS .section syntax to
     incorrectly label the sections as SHT_PROGBITS.  The best compromise
     seems to be to map SHT_MIPS_DWARF to SHT_PROGBITS before calling the
     generic type-checking code.  */
  if (section_type == SHT_MIPS_DWARF)
    section_type = SHT_PROGBITS;

  obj_elf_change_section (section_name, section_type, section_flag,
			  section_entry_size, 0, 0, 0);

  if (now_seg->name != section_name)
    free (section_name);
}

void
mips_enable_auto_align (void)
{
  auto_align = 1;
}

static void
s_cons (int log_size)
{
  segment_info_type *si = seg_info (now_seg);
  struct insn_label_list *l = si->label_list;

  mips_emit_delays ();
  if (log_size > 0 && auto_align)
    mips_align (log_size, 0, l);
  cons (1 << log_size);
  mips_clear_insn_labels ();
}

static void
s_float_cons (int type)
{
  segment_info_type *si = seg_info (now_seg);
  struct insn_label_list *l = si->label_list;

  mips_emit_delays ();

  if (auto_align)
    {
      if (type == 'd')
	mips_align (3, 0, l);
      else
	mips_align (2, 0, l);
    }

  float_cons (type);
  mips_clear_insn_labels ();
}

/* Handle .globl.  We need to override it because on Irix 5 you are
   permitted to say
       .globl foo .text
   where foo is an undefined symbol, to mean that foo should be
   considered to be the address of a function.  */

static void
s_mips_globl (int x ATTRIBUTE_UNUSED)
{
  char *name;
  int c;
  symbolS *symbolP;
  flagword flag;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      S_SET_EXTERNAL (symbolP);

      *input_line_pointer = c;
      SKIP_WHITESPACE ();

      /* On Irix 5, every global symbol that is not explicitly labelled as
         being a function is apparently labelled as being an object.  */
      flag = BSF_OBJECT;

      if (!is_end_of_line[(unsigned char) *input_line_pointer]
	  && (*input_line_pointer != ','))
	{
	  char *secname;
	  asection *sec;

	  secname = input_line_pointer;
	  c = get_symbol_end ();
	  sec = bfd_get_section_by_name (stdoutput, secname);
	  if (sec == NULL)
	    as_bad (_("%s: no such section"), secname);
	  *input_line_pointer = c;

	  if (sec != NULL && (sec->flags & SEC_CODE) != 0)
	    flag = BSF_FUNCTION;
	}

      symbol_get_bfdsym (symbolP)->flags |= flag;

      c = *input_line_pointer;
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (is_end_of_line[(unsigned char) *input_line_pointer])
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

static void
s_option (int x ATTRIBUTE_UNUSED)
{
  char *opt;
  char c;

  opt = input_line_pointer;
  c = get_symbol_end ();

  if (*opt == 'O')
    {
      /* FIXME: What does this mean?  */
    }
  else if (strncmp (opt, "pic", 3) == 0)
    {
      int i;

      i = atoi (opt + 3);
      if (i == 0)
	mips_pic = NO_PIC;
      else if (i == 2)
	{
	  mips_pic = SVR4_PIC;
	  mips_abicalls = TRUE;
	}
      else
	as_bad (_(".option pic%d not supported"), i);

      if (mips_pic == SVR4_PIC)
	{
	  if (g_switch_seen && g_switch_value != 0)
	    as_warn (_("-G may not be used with SVR4 PIC code"));
	  g_switch_value = 0;
	  bfd_set_gp_size (stdoutput, 0);
	}
    }
  else
    as_warn (_("unrecognized option \"%s\""), opt);

  *input_line_pointer = c;
  demand_empty_rest_of_line ();
}

/* This structure is used to hold a stack of .set values.  */

struct mips_option_stack
{
  struct mips_option_stack *next;
  struct mips_set_options options;
};

static struct mips_option_stack *mips_opts_stack;

/* Handle the .set pseudo-op.  */

static void
s_mipsset (int x ATTRIBUTE_UNUSED)
{
  char *name = input_line_pointer, ch;
  const struct mips_ase *ase;

  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    ++input_line_pointer;
  ch = *input_line_pointer;
  *input_line_pointer = '\0';

  if (strcmp (name, "reorder") == 0)
    {
      if (mips_opts.noreorder)
	end_noreorder ();
    }
  else if (strcmp (name, "noreorder") == 0)
    {
      if (!mips_opts.noreorder)
	start_noreorder ();
    }
  else if (strncmp (name, "at=", 3) == 0)
    {
      char *s = name + 3;

      if (!reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &mips_opts.at))
	as_bad (_("unrecognized register name `%s'"), s);
    }
  else if (strcmp (name, "at") == 0)
    {
      mips_opts.at = ATREG;
    }
  else if (strcmp (name, "noat") == 0)
    {
      mips_opts.at = ZERO;
    }
  else if (strcmp (name, "macro") == 0)
    {
      mips_opts.warn_about_macros = 0;
    }
  else if (strcmp (name, "nomacro") == 0)
    {
      if (mips_opts.noreorder == 0)
	as_bad (_("`noreorder' must be set before `nomacro'"));
      mips_opts.warn_about_macros = 1;
    }
  else if (strcmp (name, "move") == 0 || strcmp (name, "novolatile") == 0)
    {
      mips_opts.nomove = 0;
    }
  else if (strcmp (name, "nomove") == 0 || strcmp (name, "volatile") == 0)
    {
      mips_opts.nomove = 1;
    }
  else if (strcmp (name, "bopt") == 0)
    {
      mips_opts.nobopt = 0;
    }
  else if (strcmp (name, "nobopt") == 0)
    {
      mips_opts.nobopt = 1;
    }
  else if (strcmp (name, "gp=default") == 0)
    mips_opts.gp32 = file_mips_gp32;
  else if (strcmp (name, "gp=32") == 0)
    mips_opts.gp32 = 1;
  else if (strcmp (name, "gp=64") == 0)
    {
      if (!ISA_HAS_64BIT_REGS (mips_opts.isa))
	as_warn (_("%s isa does not support 64-bit registers"),
		 mips_cpu_info_from_isa (mips_opts.isa)->name);
      mips_opts.gp32 = 0;
    }
  else if (strcmp (name, "fp=default") == 0)
    mips_opts.fp32 = file_mips_fp32;
  else if (strcmp (name, "fp=32") == 0)
    mips_opts.fp32 = 1;
  else if (strcmp (name, "fp=64") == 0)
    {
      if (!ISA_HAS_64BIT_FPRS (mips_opts.isa))
	as_warn (_("%s isa does not support 64-bit floating point registers"),
		 mips_cpu_info_from_isa (mips_opts.isa)->name);
      mips_opts.fp32 = 0;
    }
  else if (strcmp (name, "softfloat") == 0)
    mips_opts.soft_float = 1;
  else if (strcmp (name, "hardfloat") == 0)
    mips_opts.soft_float = 0;
  else if (strcmp (name, "singlefloat") == 0)
    mips_opts.single_float = 1;
  else if (strcmp (name, "doublefloat") == 0)
    mips_opts.single_float = 0;
  else if (strcmp (name, "mips16") == 0
	   || strcmp (name, "MIPS-16") == 0)
    {
      if (mips_opts.micromips == 1)
	as_fatal (_("`mips16' cannot be used with `micromips'"));
      mips_opts.mips16 = 1;
    }
  else if (strcmp (name, "nomips16") == 0
	   || strcmp (name, "noMIPS-16") == 0)
    mips_opts.mips16 = 0;
  else if (strcmp (name, "micromips") == 0)
    {
      if (mips_opts.mips16 == 1)
	as_fatal (_("`micromips' cannot be used with `mips16'"));
      mips_opts.micromips = 1;
    }
  else if (strcmp (name, "nomicromips") == 0)
    mips_opts.micromips = 0;
  else if (name[0] == 'n'
	   && name[1] == 'o'
	   && (ase = mips_lookup_ase (name + 2)))
    mips_set_ase (ase, FALSE);
  else if ((ase = mips_lookup_ase (name)))
    mips_set_ase (ase, TRUE);
  else if (strncmp (name, "mips", 4) == 0 || strncmp (name, "arch=", 5) == 0)
    {
      int reset = 0;

      /* Permit the user to change the ISA and architecture on the fly.
	 Needless to say, misuse can cause serious problems.  */
      if (strcmp (name, "mips0") == 0 || strcmp (name, "arch=default") == 0)
	{
	  reset = 1;
	  mips_opts.isa = file_mips_isa;
	  mips_opts.arch = file_mips_arch;
	}
      else if (strncmp (name, "arch=", 5) == 0)
	{
	  const struct mips_cpu_info *p;

	  p = mips_parse_cpu("internal use", name + 5);
	  if (!p)
	    as_bad (_("unknown architecture %s"), name + 5);
	  else
	    {
	      mips_opts.arch = p->cpu;
	      mips_opts.isa = p->isa;
	    }
	}
      else if (strncmp (name, "mips", 4) == 0)
	{
	  const struct mips_cpu_info *p;

	  p = mips_parse_cpu("internal use", name);
	  if (!p)
	    as_bad (_("unknown ISA level %s"), name + 4);
	  else
	    {
	      mips_opts.arch = p->cpu;
	      mips_opts.isa = p->isa;
	    }
	}
      else
	as_bad (_("unknown ISA or architecture %s"), name);

      switch (mips_opts.isa)
	{
	case  0:
	  break;
	case ISA_MIPS1:
	case ISA_MIPS2:
	case ISA_MIPS32:
	case ISA_MIPS32R2:
	  mips_opts.gp32 = 1;
	  mips_opts.fp32 = 1;
	  break;
	case ISA_MIPS3:
	case ISA_MIPS4:
	case ISA_MIPS5:
	case ISA_MIPS64:
	case ISA_MIPS64R2:
	  mips_opts.gp32 = 0;
	  if (mips_opts.arch == CPU_R5900)
	    {
		mips_opts.fp32 = 1;
	    }
	  else
	    {
	  mips_opts.fp32 = 0;
	    }
	  break;
	default:
	  as_bad (_("unknown ISA level %s"), name + 4);
	  break;
	}
      if (reset)
	{
	  mips_opts.gp32 = file_mips_gp32;
	  mips_opts.fp32 = file_mips_fp32;
	}
    }
  else if (strcmp (name, "autoextend") == 0)
    mips_opts.noautoextend = 0;
  else if (strcmp (name, "noautoextend") == 0)
    mips_opts.noautoextend = 1;
  else if (strcmp (name, "insn32") == 0)
    mips_opts.insn32 = TRUE;
  else if (strcmp (name, "noinsn32") == 0)
    mips_opts.insn32 = FALSE;
  else if (strcmp (name, "push") == 0)
    {
      struct mips_option_stack *s;

      s = (struct mips_option_stack *) xmalloc (sizeof *s);
      s->next = mips_opts_stack;
      s->options = mips_opts;
      mips_opts_stack = s;
    }
  else if (strcmp (name, "pop") == 0)
    {
      struct mips_option_stack *s;

      s = mips_opts_stack;
      if (s == NULL)
	as_bad (_(".set pop with no .set push"));
      else
	{
	  /* If we're changing the reorder mode we need to handle
             delay slots correctly.  */
	  if (s->options.noreorder && ! mips_opts.noreorder)
	    start_noreorder ();
	  else if (! s->options.noreorder && mips_opts.noreorder)
	    end_noreorder ();

	  mips_opts = s->options;
	  mips_opts_stack = s->next;
	  free (s);
	}
    }
  else if (strcmp (name, "sym32") == 0)
    mips_opts.sym32 = TRUE;
  else if (strcmp (name, "nosym32") == 0)
    mips_opts.sym32 = FALSE;
  else if (strchr (name, ','))
    {
      /* Generic ".set" directive; use the generic handler.  */
      *input_line_pointer = ch;
      input_line_pointer = name;
      s_set (0);
      return;
    }
  else
    {
      as_warn (_("tried to set unrecognized symbol: %s\n"), name);
    }
  mips_check_isa_supports_ases ();
  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

/* Handle the .abicalls pseudo-op.  I believe this is equivalent to
   .option pic2.  It means to generate SVR4 PIC calls.  */

static void
s_abicalls (int ignore ATTRIBUTE_UNUSED)
{
  mips_pic = SVR4_PIC;
  mips_abicalls = TRUE;

  if (g_switch_seen && g_switch_value != 0)
    as_warn (_("-G may not be used with SVR4 PIC code"));
  g_switch_value = 0;

  bfd_set_gp_size (stdoutput, 0);
  demand_empty_rest_of_line ();
}

/* Handle the .cpload pseudo-op.  This is used when generating SVR4
   PIC code.  It sets the $gp register for the function based on the
   function address, which is in the register named in the argument.
   This uses a relocation against _gp_disp, which is handled specially
   by the linker.  The result is:
	lui	$gp,%hi(_gp_disp)
	addiu	$gp,$gp,%lo(_gp_disp)
	addu	$gp,$gp,.cpload argument
   The .cpload argument is normally $25 == $t9.

   The -mno-shared option changes this to:
	lui	$gp,%hi(__gnu_local_gp)
	addiu	$gp,$gp,%lo(__gnu_local_gp)
   and the argument is ignored.  This saves an instruction, but the
   resulting code is not position independent; it uses an absolute
   address for __gnu_local_gp.  Thus code assembled with -mno-shared
   can go into an ordinary executable, but not into a shared library.  */

static void
s_cpload (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex;
  int reg;
  int in_shared;

  /* If we are not generating SVR4 PIC code, or if this is NewABI code,
     .cpload is ignored.  */
  if (mips_pic != SVR4_PIC || HAVE_NEWABI)
    {
      s_ignore (0);
      return;
    }

  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cpload");
      ignore_rest_of_line ();
      return;
    }

  /* .cpload should be in a .set noreorder section.  */
  if (mips_opts.noreorder == 0)
    as_warn (_(".cpload not in noreorder section"));

  reg = tc_get_register (0);

  /* If we need to produce a 64-bit address, we are better off using
     the default instruction sequence.  */
  in_shared = mips_in_shared || HAVE_64BIT_SYMBOLS;

  ex.X_op = O_symbol;
  ex.X_add_symbol = symbol_find_or_make (in_shared ? "_gp_disp" :
                                         "__gnu_local_gp");
  ex.X_op_symbol = NULL;
  ex.X_add_number = 0;

  /* In ELF, this symbol is implicitly an STT_OBJECT symbol.  */
  symbol_get_bfdsym (ex.X_add_symbol)->flags |= BSF_OBJECT;

  mips_mark_labels ();
  mips_assembling_insn = TRUE;

  macro_start ();
  macro_build_lui (&ex, mips_gp_register);
  macro_build (&ex, "addiu", "t,r,j", mips_gp_register,
	       mips_gp_register, BFD_RELOC_LO16);
  if (in_shared)
    macro_build (NULL, "addu", "d,v,t", mips_gp_register,
		 mips_gp_register, reg);
  macro_end ();

  mips_assembling_insn = FALSE;
  demand_empty_rest_of_line ();
}

/* Handle the .cpsetup pseudo-op defined for NewABI PIC code.  The syntax is:
     .cpsetup $reg1, offset|$reg2, label

   If offset is given, this results in:
     sd		$gp, offset($sp)
     lui	$gp, %hi(%neg(%gp_rel(label)))
     addiu	$gp, $gp, %lo(%neg(%gp_rel(label)))
     daddu	$gp, $gp, $reg1

   If $reg2 is given, this results in:
     daddu	$reg2, $gp, $0
     lui	$gp, %hi(%neg(%gp_rel(label)))
     addiu	$gp, $gp, %lo(%neg(%gp_rel(label)))
     daddu	$gp, $gp, $reg1
   $reg1 is normally $25 == $t9.

   The -mno-shared option replaces the last three instructions with
	lui	$gp,%hi(_gp)
	addiu	$gp,$gp,%lo(_gp)  */

static void
s_cpsetup (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex_off;
  expressionS ex_sym;
  int reg1;

  /* If we are not generating SVR4 PIC code, .cpsetup is ignored.
     We also need NewABI support.  */
  if (mips_pic != SVR4_PIC || ! HAVE_NEWABI)
    {
      s_ignore (0);
      return;
    }

  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cpsetup");
      ignore_rest_of_line ();
      return;
    }

  reg1 = tc_get_register (0);
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("missing argument separator ',' for .cpsetup"));
      return;
    }
  else
    ++input_line_pointer;
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
    {
      mips_cpreturn_register = tc_get_register (0);
      mips_cpreturn_offset = -1;
    }
  else
    {
      mips_cpreturn_offset = get_absolute_expression ();
      mips_cpreturn_register = -1;
    }
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("missing argument separator ',' for .cpsetup"));
      return;
    }
  else
    ++input_line_pointer;
  SKIP_WHITESPACE ();
  expression (&ex_sym);

  mips_mark_labels ();
  mips_assembling_insn = TRUE;

  macro_start ();
  if (mips_cpreturn_register == -1)
    {
      ex_off.X_op = O_constant;
      ex_off.X_add_symbol = NULL;
      ex_off.X_op_symbol = NULL;
      ex_off.X_add_number = mips_cpreturn_offset;

      macro_build (&ex_off, "sd", "t,o(b)", mips_gp_register,
		   BFD_RELOC_LO16, SP);
    }
  else
    macro_build (NULL, "daddu", "d,v,t", mips_cpreturn_register,
		 mips_gp_register, 0);

  if (mips_in_shared || HAVE_64BIT_SYMBOLS)
    {
      macro_build (&ex_sym, "lui", LUI_FMT, mips_gp_register,
		   -1, BFD_RELOC_GPREL16, BFD_RELOC_MIPS_SUB,
		   BFD_RELOC_HI16_S);

      macro_build (&ex_sym, "addiu", "t,r,j", mips_gp_register,
		   mips_gp_register, -1, BFD_RELOC_GPREL16,
		   BFD_RELOC_MIPS_SUB, BFD_RELOC_LO16);

      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", mips_gp_register,
		   mips_gp_register, reg1);
    }
  else
    {
      expressionS ex;

      ex.X_op = O_symbol;
      ex.X_add_symbol = symbol_find_or_make ("__gnu_local_gp");
      ex.X_op_symbol = NULL;
      ex.X_add_number = 0;

      /* In ELF, this symbol is implicitly an STT_OBJECT symbol.  */
      symbol_get_bfdsym (ex.X_add_symbol)->flags |= BSF_OBJECT;

      macro_build_lui (&ex, mips_gp_register);
      macro_build (&ex, "addiu", "t,r,j", mips_gp_register,
		   mips_gp_register, BFD_RELOC_LO16);
    }

  macro_end ();

  mips_assembling_insn = FALSE;
  demand_empty_rest_of_line ();
}

static void
s_cplocal (int ignore ATTRIBUTE_UNUSED)
{
  /* If we are not generating SVR4 PIC code, or if this is not NewABI code,
     .cplocal is ignored.  */
  if (mips_pic != SVR4_PIC || ! HAVE_NEWABI)
    {
      s_ignore (0);
      return;
    }

  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cplocal");
      ignore_rest_of_line ();
      return;
    }

  mips_gp_register = tc_get_register (0);
  demand_empty_rest_of_line ();
}

/* Handle the .cprestore pseudo-op.  This stores $gp into a given
   offset from $sp.  The offset is remembered, and after making a PIC
   call $gp is restored from that location.  */

static void
s_cprestore (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex;

  /* If we are not generating SVR4 PIC code, or if this is NewABI code,
     .cprestore is ignored.  */
  if (mips_pic != SVR4_PIC || HAVE_NEWABI)
    {
      s_ignore (0);
      return;
    }

  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cprestore");
      ignore_rest_of_line ();
      return;
    }

  mips_cprestore_offset = get_absolute_expression ();
  mips_cprestore_valid = 1;

  ex.X_op = O_constant;
  ex.X_add_symbol = NULL;
  ex.X_op_symbol = NULL;
  ex.X_add_number = mips_cprestore_offset;

  mips_mark_labels ();
  mips_assembling_insn = TRUE;

  macro_start ();
  macro_build_ldst_constoffset (&ex, ADDRESS_STORE_INSN, mips_gp_register,
				SP, HAVE_64BIT_ADDRESSES);
  macro_end ();

  mips_assembling_insn = FALSE;
  demand_empty_rest_of_line ();
}

/* Handle the .cpreturn pseudo-op defined for NewABI PIC code. If an offset
   was given in the preceding .cpsetup, it results in:
     ld		$gp, offset($sp)

   If a register $reg2 was given there, it results in:
     daddu	$gp, $reg2, $0  */

static void
s_cpreturn (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex;

  /* If we are not generating SVR4 PIC code, .cpreturn is ignored.
     We also need NewABI support.  */
  if (mips_pic != SVR4_PIC || ! HAVE_NEWABI)
    {
      s_ignore (0);
      return;
    }

  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cpreturn");
      ignore_rest_of_line ();
      return;
    }

  mips_mark_labels ();
  mips_assembling_insn = TRUE;

  macro_start ();
  if (mips_cpreturn_register == -1)
    {
      ex.X_op = O_constant;
      ex.X_add_symbol = NULL;
      ex.X_op_symbol = NULL;
      ex.X_add_number = mips_cpreturn_offset;

      macro_build (&ex, "ld", "t,o(b)", mips_gp_register, BFD_RELOC_LO16, SP);
    }
  else
    macro_build (NULL, "daddu", "d,v,t", mips_gp_register,
		 mips_cpreturn_register, 0);
  macro_end ();

  mips_assembling_insn = FALSE;
  demand_empty_rest_of_line ();
}

/* Handle a .dtprelword, .dtpreldword, .tprelword, or .tpreldword
   pseudo-op; DIRSTR says which. The pseudo-op generates a BYTES-size
   DTP- or TP-relative relocation of type RTYPE, for use in either DWARF
   debug information or MIPS16 TLS.  */

static void
s_tls_rel_directive (const size_t bytes, const char *dirstr,
		     bfd_reloc_code_real_type rtype)
{
  expressionS ex;
  char *p;

  expression (&ex);

  if (ex.X_op != O_symbol)
    {
      as_bad (_("unsupported use of %s"), dirstr);
      ignore_rest_of_line ();
    }

  p = frag_more (bytes);
  md_number_to_chars (p, 0, bytes);
  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE, rtype);
  demand_empty_rest_of_line ();
  mips_clear_insn_labels ();
}

/* Handle .dtprelword.  */

static void
s_dtprelword (int ignore ATTRIBUTE_UNUSED)
{
  s_tls_rel_directive (4, ".dtprelword", BFD_RELOC_MIPS_TLS_DTPREL32);
}

/* Handle .dtpreldword.  */

static void
s_dtpreldword (int ignore ATTRIBUTE_UNUSED)
{
  s_tls_rel_directive (8, ".dtpreldword", BFD_RELOC_MIPS_TLS_DTPREL64);
}

/* Handle .tprelword.  */

static void
s_tprelword (int ignore ATTRIBUTE_UNUSED)
{
  s_tls_rel_directive (4, ".tprelword", BFD_RELOC_MIPS_TLS_TPREL32);
}

/* Handle .tpreldword.  */

static void
s_tpreldword (int ignore ATTRIBUTE_UNUSED)
{
  s_tls_rel_directive (8, ".tpreldword", BFD_RELOC_MIPS_TLS_TPREL64);
}

/* Handle the .gpvalue pseudo-op.  This is used when generating NewABI PIC
   code.  It sets the offset to use in gp_rel relocations.  */

static void
s_gpvalue (int ignore ATTRIBUTE_UNUSED)
{
  /* If we are not generating SVR4 PIC code, .gpvalue is ignored.
     We also need NewABI support.  */
  if (mips_pic != SVR4_PIC || ! HAVE_NEWABI)
    {
      s_ignore (0);
      return;
    }

  mips_gprel_offset = get_absolute_expression ();

  demand_empty_rest_of_line ();
}

/* Handle the .gpword pseudo-op.  This is used when generating PIC
   code.  It generates a 32 bit GP relative reloc.  */

static void
s_gpword (int ignore ATTRIBUTE_UNUSED)
{
  segment_info_type *si;
  struct insn_label_list *l;
  expressionS ex;
  char *p;

  /* When not generating PIC code, this is treated as .word.  */
  if (mips_pic != SVR4_PIC)
    {
      s_cons (2);
      return;
    }

  si = seg_info (now_seg);
  l = si->label_list;
  mips_emit_delays ();
  if (auto_align)
    mips_align (2, 0, l);

  expression (&ex);
  mips_clear_insn_labels ();

  if (ex.X_op != O_symbol || ex.X_add_number != 0)
    {
      as_bad (_("unsupported use of .gpword"));
      ignore_rest_of_line ();
    }

  p = frag_more (4);
  md_number_to_chars (p, 0, 4);
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, FALSE,
	       BFD_RELOC_GPREL32);

  demand_empty_rest_of_line ();
}

static void
s_gpdword (int ignore ATTRIBUTE_UNUSED)
{
  segment_info_type *si;
  struct insn_label_list *l;
  expressionS ex;
  char *p;

  /* When not generating PIC code, this is treated as .dword.  */
  if (mips_pic != SVR4_PIC)
    {
      s_cons (3);
      return;
    }

  si = seg_info (now_seg);
  l = si->label_list;
  mips_emit_delays ();
  if (auto_align)
    mips_align (3, 0, l);

  expression (&ex);
  mips_clear_insn_labels ();

  if (ex.X_op != O_symbol || ex.X_add_number != 0)
    {
      as_bad (_("unsupported use of .gpdword"));
      ignore_rest_of_line ();
    }

  p = frag_more (8);
  md_number_to_chars (p, 0, 8);
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, FALSE,
	       BFD_RELOC_GPREL32)->fx_tcbit = 1;

  /* GPREL32 composed with 64 gives a 64-bit GP offset.  */
  fix_new (frag_now, p - frag_now->fr_literal, 8, NULL, 0,
	   FALSE, BFD_RELOC_64)->fx_tcbit = 1;

  demand_empty_rest_of_line ();
}

/* Handle the .ehword pseudo-op.  This is used when generating unwinding
   tables.  It generates a R_MIPS_EH reloc.  */

static void
s_ehword (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex;
  char *p;

  mips_emit_delays ();

  expression (&ex);
  mips_clear_insn_labels ();

  if (ex.X_op != O_symbol || ex.X_add_number != 0)
    {
      as_bad (_("unsupported use of .ehword"));
      ignore_rest_of_line ();
    }

  p = frag_more (4);
  md_number_to_chars (p, 0, 4);
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, FALSE,
	       BFD_RELOC_MIPS_EH);

  demand_empty_rest_of_line ();
}

/* Handle the .cpadd pseudo-op.  This is used when dealing with switch
   tables in SVR4 PIC code.  */

static void
s_cpadd (int ignore ATTRIBUTE_UNUSED)
{
  int reg;

  /* This is ignored when not generating SVR4 PIC code.  */
  if (mips_pic != SVR4_PIC)
    {
      s_ignore (0);
      return;
    }

  mips_mark_labels ();
  mips_assembling_insn = TRUE;

  /* Add $gp to the register named as an argument.  */
  macro_start ();
  reg = tc_get_register (0);
  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", reg, reg, mips_gp_register);
  macro_end ();

  mips_assembling_insn = FALSE;
  demand_empty_rest_of_line ();
}

/* Handle the .insn pseudo-op.  This marks instruction labels in
   mips16/micromips mode.  This permits the linker to handle them specially,
   such as generating jalx instructions when needed.  We also make
   them odd for the duration of the assembly, in order to generate the
   right sort of code.  We will make them even in the adjust_symtab
   routine, while leaving them marked.  This is convenient for the
   debugger and the disassembler.  The linker knows to make them odd
   again.  */

static void
s_insn (int ignore ATTRIBUTE_UNUSED)
{
  mips_mark_labels ();

  demand_empty_rest_of_line ();
}

/* Handle the .nan pseudo-op.  */

static void
s_nan (int ignore ATTRIBUTE_UNUSED)
{
  static const char str_legacy[] = "legacy";
  static const char str_2008[] = "2008";
  size_t i;

  for (i = 0; !is_end_of_line[(unsigned char) input_line_pointer[i]]; i++);

  if (i == sizeof (str_2008) - 1
      && memcmp (input_line_pointer, str_2008, i) == 0)
    mips_flag_nan2008 = TRUE;
  else if (i == sizeof (str_legacy) - 1
	   && memcmp (input_line_pointer, str_legacy, i) == 0)
    mips_flag_nan2008 = FALSE;
  else
    as_bad (_("bad .nan directive"));

  input_line_pointer += i;
  demand_empty_rest_of_line ();
}

/* Handle a .stab[snd] directive.  Ideally these directives would be
   implemented in a transparent way, so that removing them would not
   have any effect on the generated instructions.  However, s_stab
   internally changes the section, so in practice we need to decide
   now whether the preceding label marks compressed code.  We do not
   support changing the compression mode of a label after a .stab*
   directive, such as in:

   foo:
   	.stabs ...
	.set mips16

   so the current mode wins.  */

static void
s_mips_stab (int type)
{
  mips_mark_labels ();
  s_stab (type);
}

/* Handle the .weakext pseudo-op as defined in Kane and Heinrich.  */

static void
s_mips_weakext (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  int c;
  symbolS *symbolP;
  expressionS exp;

  name = input_line_pointer;
  c = get_symbol_end ();
  symbolP = symbol_find_or_make (name);
  S_SET_WEAK (symbolP);
  *input_line_pointer = c;

  SKIP_WHITESPACE ();

  if (! is_end_of_line[(unsigned char) *input_line_pointer])
    {
      if (S_IS_DEFINED (symbolP))
	{
	  as_bad (_("ignoring attempt to redefine symbol %s"),
		  S_GET_NAME (symbolP));
	  ignore_rest_of_line ();
	  return;
	}

      if (*input_line_pointer == ',')
	{
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	}

      expression (&exp);
      if (exp.X_op != O_symbol)
	{
	  as_bad (_("bad .weakext directive"));
	  ignore_rest_of_line ();
	  return;
	}
      symbol_set_value_expression (symbolP, &exp);
    }

  demand_empty_rest_of_line ();
}

/* Parse a register string into a number.  Called from the ECOFF code
   to parse .frame.  The argument is non-zero if this is the frame
   register, so that we can record it in mips_frame_reg.  */

int
tc_get_register (int frame)
{
  unsigned int reg;

  SKIP_WHITESPACE ();
  if (! reg_lookup (&input_line_pointer, RWARN | RTYPE_NUM | RTYPE_GP, &reg))
    reg = 0;
  if (frame)
    {
      mips_frame_reg = reg != 0 ? reg : SP;
      mips_frame_reg_valid = 1;
      mips_cprestore_valid = 0;
    }
  return reg;
}

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);

  /* We don't need to align ELF sections to the full alignment.
     However, Irix 5 may prefer that we align them at least to a 16
     byte boundary.  We don't bother to align the sections if we
     are targeted for an embedded system.  */
  if (strncmp (TARGET_OS, "elf", 3) == 0)
    return addr;
  if (align > 4)
    align = 4;

  return ((addr + (1 << align) - 1) & (-1 << align));
}

/* Utility routine, called from above as well.  If called while the
   input file is still being read, it's only an approximation.  (For
   example, a symbol may later become defined which appeared to be
   undefined earlier.)  */

static int
nopic_need_relax (symbolS *sym, int before_relaxing)
{
  if (sym == 0)
    return 0;

  if (g_switch_value > 0)
    {
      const char *symname;
      int change;

      /* Find out whether this symbol can be referenced off the $gp
	 register.  It can be if it is smaller than the -G size or if
	 it is in the .sdata or .sbss section.  Certain symbols can
	 not be referenced off the $gp, although it appears as though
	 they can.  */
      symname = S_GET_NAME (sym);
      if (symname != (const char *) NULL
	  && (strcmp (symname, "eprol") == 0
	      || strcmp (symname, "etext") == 0
	      || strcmp (symname, "_gp") == 0
	      || strcmp (symname, "edata") == 0
	      || strcmp (symname, "_fbss") == 0
	      || strcmp (symname, "_fdata") == 0
	      || strcmp (symname, "_ftext") == 0
	      || strcmp (symname, "end") == 0
	      || strcmp (symname, "_gp_disp") == 0))
	change = 1;
      else if ((! S_IS_DEFINED (sym) || S_IS_COMMON (sym))
	       && (0
#ifndef NO_ECOFF_DEBUGGING
		   || (symbol_get_obj (sym)->ecoff_extern_size != 0
		       && (symbol_get_obj (sym)->ecoff_extern_size
			   <= g_switch_value))
#endif
		   /* We must defer this decision until after the whole
		      file has been read, since there might be a .extern
		      after the first use of this symbol.  */
		   || (before_relaxing
#ifndef NO_ECOFF_DEBUGGING
		       && symbol_get_obj (sym)->ecoff_extern_size == 0
#endif
		       && S_GET_VALUE (sym) == 0)
		   || (S_GET_VALUE (sym) != 0
		       && S_GET_VALUE (sym) <= g_switch_value)))
	change = 0;
      else
	{
	  const char *segname;

	  segname = segment_name (S_GET_SEGMENT (sym));
	  gas_assert (strcmp (segname, ".lit8") != 0
		  && strcmp (segname, ".lit4") != 0);
	  change = (strcmp (segname, ".sdata") != 0
		    && strcmp (segname, ".sbss") != 0
		    && strncmp (segname, ".sdata.", 7) != 0
		    && strncmp (segname, ".sbss.", 6) != 0
		    && strncmp (segname, ".gnu.linkonce.sb.", 17) != 0
		    && strncmp (segname, ".gnu.linkonce.s.", 16) != 0);
	}
      return change;
    }
  else
    /* We are not optimizing for the $gp register.  */
    return 1;
}


/* Return true if the given symbol should be considered local for SVR4 PIC.  */

static bfd_boolean
pic_need_relax (symbolS *sym, asection *segtype)
{
  asection *symsec;

  /* Handle the case of a symbol equated to another symbol.  */
  while (symbol_equated_reloc_p (sym))
    {
      symbolS *n;

      /* It's possible to get a loop here in a badly written program.  */
      n = symbol_get_value_expression (sym)->X_add_symbol;
      if (n == sym)
	break;
      sym = n;
    }

  if (symbol_section_p (sym))
    return TRUE;

  symsec = S_GET_SEGMENT (sym);

  /* This must duplicate the test in adjust_reloc_syms.  */
  return (!bfd_is_und_section (symsec)
	  && !bfd_is_abs_section (symsec)
	  && !bfd_is_com_section (symsec)
	  && !s_is_linkonce (sym, segtype)
	  /* A global or weak symbol is treated as external.  */
	  && (!S_IS_WEAK (sym) && !S_IS_EXTERNAL (sym)));
}


/* Given a mips16 variant frag FRAGP, return non-zero if it needs an
   extended opcode.  SEC is the section the frag is in.  */

static int
mips16_extended_frag (fragS *fragp, asection *sec, long stretch)
{
  int type;
  const struct mips_int_operand *operand;
  offsetT val;
  segT symsec;
  fragS *sym_frag;

  if (RELAX_MIPS16_USER_SMALL (fragp->fr_subtype))
    return 0;
  if (RELAX_MIPS16_USER_EXT (fragp->fr_subtype))
    return 1;

  type = RELAX_MIPS16_TYPE (fragp->fr_subtype);
  operand = mips16_immed_operand (type, FALSE);

  sym_frag = symbol_get_frag (fragp->fr_symbol);
  val = S_GET_VALUE (fragp->fr_symbol);
  symsec = S_GET_SEGMENT (fragp->fr_symbol);

  if (operand->root.type == OP_PCREL)
    {
      const struct mips_pcrel_operand *pcrel_op;
      addressT addr;
      offsetT maxtiny;

      /* We won't have the section when we are called from
         mips_relax_frag.  However, we will always have been called
         from md_estimate_size_before_relax first.  If this is a
         branch to a different section, we mark it as such.  If SEC is
         NULL, and the frag is not marked, then it must be a branch to
         the same section.  */
      pcrel_op = (const struct mips_pcrel_operand *) operand;
      if (sec == NULL)
	{
	  if (RELAX_MIPS16_LONG_BRANCH (fragp->fr_subtype))
	    return 1;
	}
      else
	{
	  /* Must have been called from md_estimate_size_before_relax.  */
	  if (symsec != sec)
	    {
	      fragp->fr_subtype =
		RELAX_MIPS16_MARK_LONG_BRANCH (fragp->fr_subtype);

	      /* FIXME: We should support this, and let the linker
                 catch branches and loads that are out of range.  */
	      as_bad_where (fragp->fr_file, fragp->fr_line,
			    _("unsupported PC relative reference to different section"));

	      return 1;
	    }
	  if (fragp != sym_frag && sym_frag->fr_address == 0)
	    /* Assume non-extended on the first relaxation pass.
	       The address we have calculated will be bogus if this is
	       a forward branch to another frag, as the forward frag
	       will have fr_address == 0.  */
	    return 0;
	}

      /* In this case, we know for sure that the symbol fragment is in
	 the same section.  If the relax_marker of the symbol fragment
	 differs from the relax_marker of this fragment, we have not
	 yet adjusted the symbol fragment fr_address.  We want to add
	 in STRETCH in order to get a better estimate of the address.
	 This particularly matters because of the shift bits.  */
      if (stretch != 0
	  && sym_frag->relax_marker != fragp->relax_marker)
	{
	  fragS *f;

	  /* Adjust stretch for any alignment frag.  Note that if have
             been expanding the earlier code, the symbol may be
             defined in what appears to be an earlier frag.  FIXME:
             This doesn't handle the fr_subtype field, which specifies
             a maximum number of bytes to skip when doing an
             alignment.  */
	  for (f = fragp; f != NULL && f != sym_frag; f = f->fr_next)
	    {
	      if (f->fr_type == rs_align || f->fr_type == rs_align_code)
		{
		  if (stretch < 0)
		    stretch = - ((- stretch)
				 & ~ ((1 << (int) f->fr_offset) - 1));
		  else
		    stretch &= ~ ((1 << (int) f->fr_offset) - 1);
		  if (stretch == 0)
		    break;
		}
	    }
	  if (f != NULL)
	    val += stretch;
	}

      addr = fragp->fr_address + fragp->fr_fix;

      /* The base address rules are complicated.  The base address of
         a branch is the following instruction.  The base address of a
         PC relative load or add is the instruction itself, but if it
         is in a delay slot (in which case it can not be extended) use
         the address of the instruction whose delay slot it is in.  */
      if (pcrel_op->include_isa_bit)
	{
	  addr += 2;

	  /* If we are currently assuming that this frag should be
	     extended, then, the current address is two bytes
	     higher.  */
	  if (RELAX_MIPS16_EXTENDED (fragp->fr_subtype))
	    addr += 2;

	  /* Ignore the low bit in the target, since it will be set
             for a text label.  */
	  val &= -2;
	}
      else if (RELAX_MIPS16_JAL_DSLOT (fragp->fr_subtype))
	addr -= 4;
      else if (RELAX_MIPS16_DSLOT (fragp->fr_subtype))
	addr -= 2;

      val -= addr & -(1 << pcrel_op->align_log2);

      /* If any of the shifted bits are set, we must use an extended
         opcode.  If the address depends on the size of this
         instruction, this can lead to a loop, so we arrange to always
         use an extended opcode.  We only check this when we are in
         the main relaxation loop, when SEC is NULL.  */
      if ((val & ((1 << operand->shift) - 1)) != 0 && sec == NULL)
	{
	  fragp->fr_subtype =
	    RELAX_MIPS16_MARK_LONG_BRANCH (fragp->fr_subtype);
	  return 1;
	}

      /* If we are about to mark a frag as extended because the value
         is precisely the next value above maxtiny, then there is a
         chance of an infinite loop as in the following code:
	     la	$4,foo
	     .skip	1020
	     .align	2
	   foo:
	 In this case when the la is extended, foo is 0x3fc bytes
	 away, so the la can be shrunk, but then foo is 0x400 away, so
	 the la must be extended.  To avoid this loop, we mark the
	 frag as extended if it was small, and is about to become
	 extended with the next value above maxtiny.  */
      maxtiny = mips_int_operand_max (operand);
      if (val == maxtiny + (1 << operand->shift)
	  && ! RELAX_MIPS16_EXTENDED (fragp->fr_subtype)
	  && sec == NULL)
	{
	  fragp->fr_subtype =
	    RELAX_MIPS16_MARK_LONG_BRANCH (fragp->fr_subtype);
	  return 1;
	}
    }
  else if (symsec != absolute_section && sec != NULL)
    as_bad_where (fragp->fr_file, fragp->fr_line, _("unsupported relocation"));

  return !mips16_immed_in_range_p (operand, BFD_RELOC_UNUSED, val);
}

/* Compute the length of a branch sequence, and adjust the
   RELAX_BRANCH_TOOFAR bit accordingly.  If FRAGP is NULL, the
   worst-case length is computed, with UPDATE being used to indicate
   whether an unconditional (-1), branch-likely (+1) or regular (0)
   branch is to be computed.  */
static int
relaxed_branch_length (fragS *fragp, asection *sec, int update)
{
  bfd_boolean toofar;
  int length;

  if (fragp
      && S_IS_DEFINED (fragp->fr_symbol)
      && sec == S_GET_SEGMENT (fragp->fr_symbol))
    {
      addressT addr;
      offsetT val;

      val = S_GET_VALUE (fragp->fr_symbol) + fragp->fr_offset;

      addr = fragp->fr_address + fragp->fr_fix + 4;

      val -= addr;

      toofar = val < - (0x8000 << 2) || val >= (0x8000 << 2);
    }
  else if (fragp)
    /* If the symbol is not defined or it's in a different segment,
       assume the user knows what's going on and emit a short
       branch.  */
    toofar = FALSE;
  else
    toofar = TRUE;

  if (fragp && update && toofar != RELAX_BRANCH_TOOFAR (fragp->fr_subtype))
    fragp->fr_subtype
      = RELAX_BRANCH_ENCODE (RELAX_BRANCH_AT (fragp->fr_subtype),
			     RELAX_BRANCH_UNCOND (fragp->fr_subtype),
			     RELAX_BRANCH_LIKELY (fragp->fr_subtype),
			     RELAX_BRANCH_LINK (fragp->fr_subtype),
			     toofar);

  length = 4;
  if (toofar)
    {
      if (fragp ? RELAX_BRANCH_LIKELY (fragp->fr_subtype) : (update > 0))
	length += 8;

      if (mips_pic != NO_PIC)
	{
	  /* Additional space for PIC loading of target address.  */
	  length += 8;
	  if (mips_opts.isa == ISA_MIPS1)
	    /* Additional space for $at-stabilizing nop.  */
	    length += 4;
	}

      /* If branch is conditional.  */
      if (fragp ? !RELAX_BRANCH_UNCOND (fragp->fr_subtype) : (update >= 0))
	length += 8;
    }

  return length;
}

/* Compute the length of a branch sequence, and adjust the
   RELAX_MICROMIPS_TOOFAR32 bit accordingly.  If FRAGP is NULL, the
   worst-case length is computed, with UPDATE being used to indicate
   whether an unconditional (-1), or regular (0) branch is to be
   computed.  */

static int
relaxed_micromips_32bit_branch_length (fragS *fragp, asection *sec, int update)
{
  bfd_boolean toofar;
  int length;

  if (fragp
      && S_IS_DEFINED (fragp->fr_symbol)
      && sec == S_GET_SEGMENT (fragp->fr_symbol))
    {
      addressT addr;
      offsetT val;

      val = S_GET_VALUE (fragp->fr_symbol) + fragp->fr_offset;
      /* Ignore the low bit in the target, since it will be set
	 for a text label.  */
      if ((val & 1) != 0)
	--val;

      addr = fragp->fr_address + fragp->fr_fix + 4;

      val -= addr;

      toofar = val < - (0x8000 << 1) || val >= (0x8000 << 1);
    }
  else if (fragp)
    /* If the symbol is not defined or it's in a different segment,
       assume the user knows what's going on and emit a short
       branch.  */
    toofar = FALSE;
  else
    toofar = TRUE;

  if (fragp && update
      && toofar != RELAX_MICROMIPS_TOOFAR32 (fragp->fr_subtype))
    fragp->fr_subtype = (toofar
			 ? RELAX_MICROMIPS_MARK_TOOFAR32 (fragp->fr_subtype)
			 : RELAX_MICROMIPS_CLEAR_TOOFAR32 (fragp->fr_subtype));

  length = 4;
  if (toofar)
    {
      bfd_boolean compact_known = fragp != NULL;
      bfd_boolean compact = FALSE;
      bfd_boolean uncond;

      if (compact_known)
	compact = RELAX_MICROMIPS_COMPACT (fragp->fr_subtype);
      if (fragp)
	uncond = RELAX_MICROMIPS_UNCOND (fragp->fr_subtype);
      else
	uncond = update < 0;

      /* If label is out of range, we turn branch <br>:

		<br>	label			# 4 bytes
	    0:

         into:

		j	label			# 4 bytes
		nop				# 2 bytes if compact && !PIC
	    0:
       */
      if (mips_pic == NO_PIC && (!compact_known || compact))
	length += 2;

      /* If assembling PIC code, we further turn:

			j	label			# 4 bytes

         into:

			lw/ld	at, %got(label)(gp)	# 4 bytes
			d/addiu	at, %lo(label)		# 4 bytes
			jr/c	at			# 2 bytes
       */
      if (mips_pic != NO_PIC)
	length += 6;

      /* If branch <br> is conditional, we prepend negated branch <brneg>:

			<brneg>	0f			# 4 bytes
			nop				# 2 bytes if !compact
       */
      if (!uncond)
	length += (compact_known && compact) ? 4 : 6;
    }

  return length;
}

/* Compute the length of a branch, and adjust the RELAX_MICROMIPS_TOOFAR16
   bit accordingly.  */

static int
relaxed_micromips_16bit_branch_length (fragS *fragp, asection *sec, int update)
{
  bfd_boolean toofar;

  if (fragp
      && S_IS_DEFINED (fragp->fr_symbol)
      && sec == S_GET_SEGMENT (fragp->fr_symbol))
    {
      addressT addr;
      offsetT val;
      int type;

      val = S_GET_VALUE (fragp->fr_symbol) + fragp->fr_offset;
      /* Ignore the low bit in the target, since it will be set
	 for a text label.  */
      if ((val & 1) != 0)
	--val;

      /* Assume this is a 2-byte branch.  */
      addr = fragp->fr_address + fragp->fr_fix + 2;

      /* We try to avoid the infinite loop by not adding 2 more bytes for
	 long branches.  */

      val -= addr;

      type = RELAX_MICROMIPS_TYPE (fragp->fr_subtype);
      if (type == 'D')
	toofar = val < - (0x200 << 1) || val >= (0x200 << 1);
      else if (type == 'E')
	toofar = val < - (0x40 << 1) || val >= (0x40 << 1);
      else
	abort ();
    }
  else
    /* If the symbol is not defined or it's in a different segment,
       we emit a normal 32-bit branch.  */
    toofar = TRUE;

  if (fragp && update
      && toofar != RELAX_MICROMIPS_TOOFAR16 (fragp->fr_subtype))
    fragp->fr_subtype
      = toofar ? RELAX_MICROMIPS_MARK_TOOFAR16 (fragp->fr_subtype)
	       : RELAX_MICROMIPS_CLEAR_TOOFAR16 (fragp->fr_subtype);

  if (toofar)
    return 4;

  return 2;
}

/* Estimate the size of a frag before relaxing.  Unless this is the
   mips16, we are not really relaxing here, and the final size is
   encoded in the subtype information.  For the mips16, we have to
   decide whether we are using an extended opcode or not.  */

int
md_estimate_size_before_relax (fragS *fragp, asection *segtype)
{
  int change;

  if (RELAX_BRANCH_P (fragp->fr_subtype))
    {

      fragp->fr_var = relaxed_branch_length (fragp, segtype, FALSE);

      return fragp->fr_var;
    }

  if (RELAX_MIPS16_P (fragp->fr_subtype))
    /* We don't want to modify the EXTENDED bit here; it might get us
       into infinite loops.  We change it only in mips_relax_frag().  */
    return (RELAX_MIPS16_EXTENDED (fragp->fr_subtype) ? 4 : 2);

  if (RELAX_MICROMIPS_P (fragp->fr_subtype))
    {
      int length = 4;

      if (RELAX_MICROMIPS_TYPE (fragp->fr_subtype) != 0)
	length = relaxed_micromips_16bit_branch_length (fragp, segtype, FALSE);
      if (length == 4 && RELAX_MICROMIPS_RELAX32 (fragp->fr_subtype))
	length = relaxed_micromips_32bit_branch_length (fragp, segtype, FALSE);
      fragp->fr_var = length;

      return length;
    }

  if (mips_pic == NO_PIC)
    change = nopic_need_relax (fragp->fr_symbol, 0);
  else if (mips_pic == SVR4_PIC)
    change = pic_need_relax (fragp->fr_symbol, segtype);
  else if (mips_pic == VXWORKS_PIC)
    /* For vxworks, GOT16 relocations never have a corresponding LO16.  */
    change = 0;
  else
    abort ();

  if (change)
    {
      fragp->fr_subtype |= RELAX_USE_SECOND;
      return -RELAX_FIRST (fragp->fr_subtype);
    }
  else
    return -RELAX_SECOND (fragp->fr_subtype);
}

/* This is called to see whether a reloc against a defined symbol
   should be converted into a reloc against a section.  */

int
mips_fix_adjustable (fixS *fixp)
{
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  if (fixp->fx_addsy == NULL)
    return 1;

  /* If symbol SYM is in a mergeable section, relocations of the form
     SYM + 0 can usually be made section-relative.  The mergeable data
     is then identified by the section offset rather than by the symbol.

     However, if we're generating REL LO16 relocations, the offset is split
     between the LO16 and parterning high part relocation.  The linker will
     need to recalculate the complete offset in order to correctly identify
     the merge data.

     The linker has traditionally not looked for the parterning high part
     relocation, and has thus allowed orphaned R_MIPS_LO16 relocations to be
     placed anywhere.  Rather than break backwards compatibility by changing
     this, it seems better not to force the issue, and instead keep the
     original symbol.  This will work with either linker behavior.  */
  if ((lo16_reloc_p (fixp->fx_r_type)
       || reloc_needs_lo_p (fixp->fx_r_type))
      && HAVE_IN_PLACE_ADDENDS
      && (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_MERGE) != 0)
    return 0;

  /* There is no place to store an in-place offset for JALR relocations.
     Likewise an in-range offset of limited PC-relative relocations may
     overflow the in-place relocatable field if recalculated against the
     start address of the symbol's containing section.  */
  if (HAVE_IN_PLACE_ADDENDS
      && (limited_pcrel_reloc_p (fixp->fx_r_type)
	  || jalr_reloc_p (fixp->fx_r_type)))
    return 0;

  /* R_MIPS16_26 relocations against non-MIPS16 functions might resolve
     to a floating-point stub.  The same is true for non-R_MIPS16_26
     relocations against MIPS16 functions; in this case, the stub becomes
     the function's canonical address.

     Floating-point stubs are stored in unique .mips16.call.* or
     .mips16.fn.* sections.  If a stub T for function F is in section S,
     the first relocation in section S must be against F; this is how the
     linker determines the target function.  All relocations that might
     resolve to T must also be against F.  We therefore have the following
     restrictions, which are given in an intentionally-redundant way:

       1. We cannot reduce R_MIPS16_26 relocations against non-MIPS16
	  symbols.

       2. We cannot reduce a stub's relocations against non-MIPS16 symbols
	  if that stub might be used.

       3. We cannot reduce non-R_MIPS16_26 relocations against MIPS16
	  symbols.

       4. We cannot reduce a stub's relocations against MIPS16 symbols if
	  that stub might be used.

     There is a further restriction:

       5. We cannot reduce jump relocations (R_MIPS_26, R_MIPS16_26 or
	  R_MICROMIPS_26_S1) against MIPS16 or microMIPS symbols on
	  targets with in-place addends; the relocation field cannot
	  encode the low bit.

     For simplicity, we deal with (3)-(4) by not reducing _any_ relocation
     against a MIPS16 symbol.  We deal with (5) by by not reducing any
     such relocations on REL targets.

     We deal with (1)-(2) by saying that, if there's a R_MIPS16_26
     relocation against some symbol R, no relocation against R may be
     reduced.  (Note that this deals with (2) as well as (1) because
     relocations against global symbols will never be reduced on ELF
     targets.)  This approach is a little simpler than trying to detect
     stub sections, and gives the "all or nothing" per-symbol consistency
     that we have for MIPS16 symbols.  */
  if (fixp->fx_subsy == NULL
      && (ELF_ST_IS_MIPS16 (S_GET_OTHER (fixp->fx_addsy))
	  || *symbol_get_tc (fixp->fx_addsy)
	  || (HAVE_IN_PLACE_ADDENDS
	      && ELF_ST_IS_MICROMIPS (S_GET_OTHER (fixp->fx_addsy))
	      && jmp_reloc_p (fixp->fx_r_type))))
    return 0;

  return 1;
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent **
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  static arelent *retval[4];
  arelent *reloc;
  bfd_reloc_code_real_type code;

  memset (retval, 0, sizeof(retval));
  reloc = retval[0] = (arelent *) xcalloc (1, sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  if (fixp->fx_pcrel)
    {
      gas_assert (fixp->fx_r_type == BFD_RELOC_16_PCREL_S2
		  || fixp->fx_r_type == BFD_RELOC_MICROMIPS_7_PCREL_S1
		  || fixp->fx_r_type == BFD_RELOC_MICROMIPS_10_PCREL_S1
		  || fixp->fx_r_type == BFD_RELOC_MICROMIPS_16_PCREL_S1
		  || fixp->fx_r_type == BFD_RELOC_32_PCREL);

      /* At this point, fx_addnumber is "symbol offset - pcrel address".
	 Relocations want only the symbol offset.  */
      reloc->addend = fixp->fx_addnumber + reloc->address;
    }
  else
    reloc->addend = fixp->fx_addnumber;

  /* Since the old MIPS ELF ABI uses Rel instead of Rela, encode the vtable
     entry to be used in the relocation's section offset.  */
  if (! HAVE_NEWABI && fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    {
      reloc->address = reloc->addend;
      reloc->addend = 0;
    }

  code = fixp->fx_r_type;

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent %s relocation in this object file"
		      " format"),
		    bfd_get_reloc_code_name (code));
      retval[0] = NULL;
    }

  return retval;
}

/* Relax a machine dependent frag.  This returns the amount by which
   the current size of the frag should change.  */

int
mips_relax_frag (asection *sec, fragS *fragp, long stretch)
{
  if (RELAX_BRANCH_P (fragp->fr_subtype))
    {
      offsetT old_var = fragp->fr_var;

      fragp->fr_var = relaxed_branch_length (fragp, sec, TRUE);

      return fragp->fr_var - old_var;
    }

  if (RELAX_MICROMIPS_P (fragp->fr_subtype))
    {
      offsetT old_var = fragp->fr_var;
      offsetT new_var = 4;

      if (RELAX_MICROMIPS_TYPE (fragp->fr_subtype) != 0)
	new_var = relaxed_micromips_16bit_branch_length (fragp, sec, TRUE);
      if (new_var == 4 && RELAX_MICROMIPS_RELAX32 (fragp->fr_subtype))
	new_var = relaxed_micromips_32bit_branch_length (fragp, sec, TRUE);
      fragp->fr_var = new_var;

      return new_var - old_var;
    }

  if (! RELAX_MIPS16_P (fragp->fr_subtype))
    return 0;

  if (mips16_extended_frag (fragp, NULL, stretch))
    {
      if (RELAX_MIPS16_EXTENDED (fragp->fr_subtype))
	return 0;
      fragp->fr_subtype = RELAX_MIPS16_MARK_EXTENDED (fragp->fr_subtype);
      return 2;
    }
  else
    {
      if (! RELAX_MIPS16_EXTENDED (fragp->fr_subtype))
	return 0;
      fragp->fr_subtype = RELAX_MIPS16_CLEAR_EXTENDED (fragp->fr_subtype);
      return -2;
    }

  return 0;
}

/* Convert a machine dependent frag.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT asec, fragS *fragp)
{
  if (RELAX_BRANCH_P (fragp->fr_subtype))
    {
      char *buf;
      unsigned long insn;
      expressionS exp;
      fixS *fixp;

      buf = fragp->fr_literal + fragp->fr_fix;
      insn = read_insn (buf);

      if (!RELAX_BRANCH_TOOFAR (fragp->fr_subtype))
	{
	  /* We generate a fixup instead of applying it right now
	     because, if there are linker relaxations, we're going to
	     need the relocations.  */
	  exp.X_op = O_symbol;
	  exp.X_add_symbol = fragp->fr_symbol;
	  exp.X_add_number = fragp->fr_offset;

	  fixp = fix_new_exp (fragp, buf - fragp->fr_literal, 4, &exp, TRUE,
			      BFD_RELOC_16_PCREL_S2);
	  fixp->fx_file = fragp->fr_file;
	  fixp->fx_line = fragp->fr_line;

	  buf = write_insn (buf, insn);
	}
      else
	{
	  int i;

	  as_warn_where (fragp->fr_file, fragp->fr_line,
			 _("relaxed out-of-range branch into a jump"));

	  if (RELAX_BRANCH_UNCOND (fragp->fr_subtype))
	    goto uncond;

	  if (!RELAX_BRANCH_LIKELY (fragp->fr_subtype))
	    {
	      /* Reverse the branch.  */
	      switch ((insn >> 28) & 0xf)
		{
		case 4:
		  if ((insn & 0xff000000) == 0x47000000
		      || (insn & 0xff600000) == 0x45600000)
		    {
		      /* BZ.df/BNZ.df, BZ.V/BNZ.V can have the condition
			 reversed by tweaking bit 23.  */
		      insn ^= 0x00800000;
		    }
		  else
		    {
		      /* bc[0-3][tf]l? instructions can have the condition
			 reversed by tweaking a single TF bit, and their
			 opcodes all have 0x4???????.  */
		      gas_assert ((insn & 0xf3e00000) == 0x41000000);
		      insn ^= 0x00010000;
		    }
		  break;

		case 0:
		  /* bltz	0x04000000	bgez	0x04010000
		     bltzal	0x04100000	bgezal	0x04110000  */
		  gas_assert ((insn & 0xfc0e0000) == 0x04000000);
		  insn ^= 0x00010000;
		  break;

		case 1:
		  /* beq	0x10000000	bne	0x14000000
		     blez	0x18000000	bgtz	0x1c000000  */
		  insn ^= 0x04000000;
		  break;

		default:
		  abort ();
		}
	    }

	  if (RELAX_BRANCH_LINK (fragp->fr_subtype))
	    {
	      /* Clear the and-link bit.  */
	      gas_assert ((insn & 0xfc1c0000) == 0x04100000);

	      /* bltzal		0x04100000	bgezal	0x04110000
		 bltzall	0x04120000	bgezall	0x04130000  */
	      insn &= ~0x00100000;
	    }

	  /* Branch over the branch (if the branch was likely) or the
	     full jump (not likely case).  Compute the offset from the
	     current instruction to branch to.  */
	  if (RELAX_BRANCH_LIKELY (fragp->fr_subtype))
	    i = 16;
	  else
	    {
	      /* How many bytes in instructions we've already emitted?  */
	      i = buf - fragp->fr_literal - fragp->fr_fix;
	      /* How many bytes in instructions from here to the end?  */
	      i = fragp->fr_var - i;
	    }
	  /* Convert to instruction count.  */
	  i >>= 2;
	  /* Branch counts from the next instruction.  */
	  i--;
	  insn |= i;
	  /* Branch over the jump.  */
	  buf = write_insn (buf, insn);

	  /* nop */
	  buf = write_insn (buf, 0);

	  if (RELAX_BRANCH_LIKELY (fragp->fr_subtype))
	    {
	      /* beql $0, $0, 2f */
	      insn = 0x50000000;
	      /* Compute the PC offset from the current instruction to
		 the end of the variable frag.  */
	      /* How many bytes in instructions we've already emitted?  */
	      i = buf - fragp->fr_literal - fragp->fr_fix;
	      /* How many bytes in instructions from here to the end?  */
	      i = fragp->fr_var - i;
	      /* Convert to instruction count.  */
	      i >>= 2;
	      /* Don't decrement i, because we want to branch over the
		 delay slot.  */
	      insn |= i;

	      buf = write_insn (buf, insn);
	      buf = write_insn (buf, 0);
	    }

	uncond:
	  if (mips_pic == NO_PIC)
	    {
	      /* j or jal.  */
	      insn = (RELAX_BRANCH_LINK (fragp->fr_subtype)
		      ? 0x0c000000 : 0x08000000);
	      exp.X_op = O_symbol;
	      exp.X_add_symbol = fragp->fr_symbol;
	      exp.X_add_number = fragp->fr_offset;

	      fixp = fix_new_exp (fragp, buf - fragp->fr_literal, 4, &exp,
				  FALSE, BFD_RELOC_MIPS_JMP);
	      fixp->fx_file = fragp->fr_file;
	      fixp->fx_line = fragp->fr_line;

	      buf = write_insn (buf, insn);
	    }
	  else
	    {
	      unsigned long at = RELAX_BRANCH_AT (fragp->fr_subtype);

	      /* lw/ld $at, <sym>($gp)  R_MIPS_GOT16 */
	      insn = HAVE_64BIT_ADDRESSES ? 0xdf800000 : 0x8f800000;
	      insn |= at << OP_SH_RT;
	      exp.X_op = O_symbol;
	      exp.X_add_symbol = fragp->fr_symbol;
	      exp.X_add_number = fragp->fr_offset;

	      if (fragp->fr_offset)
		{
		  exp.X_add_symbol = make_expr_symbol (&exp);
		  exp.X_add_number = 0;
		}

	      fixp = fix_new_exp (fragp, buf - fragp->fr_literal, 4, &exp,
				  FALSE, BFD_RELOC_MIPS_GOT16);
	      fixp->fx_file = fragp->fr_file;
	      fixp->fx_line = fragp->fr_line;

	      buf = write_insn (buf, insn);

	      if (mips_opts.isa == ISA_MIPS1)
		/* nop */
		buf = write_insn (buf, 0);

	      /* d/addiu $at, $at, <sym>  R_MIPS_LO16 */
	      insn = HAVE_64BIT_ADDRESSES ? 0x64000000 : 0x24000000;
	      insn |= at << OP_SH_RS | at << OP_SH_RT;

	      fixp = fix_new_exp (fragp, buf - fragp->fr_literal, 4, &exp,
				  FALSE, BFD_RELOC_LO16);
	      fixp->fx_file = fragp->fr_file;
	      fixp->fx_line = fragp->fr_line;

	      buf = write_insn (buf, insn);

	      /* j(al)r $at.  */
	      if (RELAX_BRANCH_LINK (fragp->fr_subtype))
		insn = 0x0000f809;
	      else
		insn = 0x00000008;
	      insn |= at << OP_SH_RS;

	      buf = write_insn (buf, insn);
	    }
	}

      fragp->fr_fix += fragp->fr_var;
      gas_assert (buf == fragp->fr_literal + fragp->fr_fix);
      return;
    }

  /* Relax microMIPS branches.  */
  if (RELAX_MICROMIPS_P (fragp->fr_subtype))
    {
      char *buf = fragp->fr_literal + fragp->fr_fix;
      bfd_boolean compact = RELAX_MICROMIPS_COMPACT (fragp->fr_subtype);
      bfd_boolean al = RELAX_MICROMIPS_LINK (fragp->fr_subtype);
      int type = RELAX_MICROMIPS_TYPE (fragp->fr_subtype);
      bfd_boolean short_ds;
      unsigned long insn;
      expressionS exp;
      fixS *fixp;

      exp.X_op = O_symbol;
      exp.X_add_symbol = fragp->fr_symbol;
      exp.X_add_number = fragp->fr_offset;

      fragp->fr_fix += fragp->fr_var;

      /* Handle 16-bit branches that fit or are forced to fit.  */
      if (type != 0 && !RELAX_MICROMIPS_TOOFAR16 (fragp->fr_subtype))
	{
	  /* We generate a fixup instead of applying it right now,
	     because if there is linker relaxation, we're going to
	     need the relocations.  */
	  if (type == 'D')
	    fixp = fix_new_exp (fragp, buf - fragp->fr_literal, 2, &exp, TRUE,
				BFD_RELOC_MICROMIPS_10_PCREL_S1);
	  else if (type == 'E')
	    fixp = fix_new_exp (fragp, buf - fragp->fr_literal,	2, &exp, TRUE,
				BFD_RELOC_MICROMIPS_7_PCREL_S1);
	  else
	    abort ();

	  fixp->fx_file = fragp->fr_file;
	  fixp->fx_line = fragp->fr_line;

	  /* These relocations can have an addend that won't fit in
	     2 octets.  */
	  fixp->fx_no_overflow = 1;

	  return;
	}

      /* Handle 32-bit branches that fit or are forced to fit.  */
      if (!RELAX_MICROMIPS_RELAX32 (fragp->fr_subtype)
	  || !RELAX_MICROMIPS_TOOFAR32 (fragp->fr_subtype))
	{
	  /* We generate a fixup instead of applying it right now,
	     because if there is linker relaxation, we're going to
	     need the relocations.  */
	  fixp = fix_new_exp (fragp, buf - fragp->fr_literal, 4, &exp, TRUE,
			      BFD_RELOC_MICROMIPS_16_PCREL_S1);
	  fixp->fx_file = fragp->fr_file;
	  fixp->fx_line = fragp->fr_line;

	  if (type == 0)
	    return;
	}

      /* Relax 16-bit branches to 32-bit branches.  */
      if (type != 0)
	{
	  insn = read_compressed_insn (buf, 2);

	  if ((insn & 0xfc00) == 0xcc00)		/* b16  */
	    insn = 0x94000000;				/* beq  */
	  else if ((insn & 0xdc00) == 0x8c00)		/* beqz16/bnez16  */
	    {
	      unsigned long regno;

	      regno = (insn >> MICROMIPSOP_SH_MD) & MICROMIPSOP_MASK_MD;
	      regno = micromips_to_32_reg_d_map [regno];
	      insn = ((insn & 0x2000) << 16) | 0x94000000;	/* beq/bne  */
	      insn |= regno << MICROMIPSOP_SH_RS;
	    }
	  else
	    abort ();

	  /* Nothing else to do, just write it out.  */
	  if (!RELAX_MICROMIPS_RELAX32 (fragp->fr_subtype)
	      || !RELAX_MICROMIPS_TOOFAR32 (fragp->fr_subtype))
	    {
	      buf = write_compressed_insn (buf, insn, 4);
	      gas_assert (buf == fragp->fr_literal + fragp->fr_fix);
	      return;
	    }
	}
      else
	insn = read_compressed_insn (buf, 4);

      /* Relax 32-bit branches to a sequence of instructions.  */
      as_warn_where (fragp->fr_file, fragp->fr_line,
		     _("relaxed out-of-range branch into a jump"));

      /* Set the short-delay-slot bit.  */
      short_ds = al && (insn & 0x02000000) != 0;

      if (!RELAX_MICROMIPS_UNCOND (fragp->fr_subtype))
	{
	  symbolS *l;

	  /* Reverse the branch.  */
	  if ((insn & 0xfc000000) == 0x94000000			/* beq  */
	      || (insn & 0xfc000000) == 0xb4000000)		/* bne  */
	    insn ^= 0x20000000;
	  else if ((insn & 0xffe00000) == 0x40000000		/* bltz  */
		   || (insn & 0xffe00000) == 0x40400000		/* bgez  */
		   || (insn & 0xffe00000) == 0x40800000		/* blez  */
		   || (insn & 0xffe00000) == 0x40c00000		/* bgtz  */
		   || (insn & 0xffe00000) == 0x40a00000		/* bnezc  */
		   || (insn & 0xffe00000) == 0x40e00000		/* beqzc  */
		   || (insn & 0xffe00000) == 0x40200000		/* bltzal  */
		   || (insn & 0xffe00000) == 0x40600000		/* bgezal  */
		   || (insn & 0xffe00000) == 0x42200000		/* bltzals  */
		   || (insn & 0xffe00000) == 0x42600000)	/* bgezals  */
	    insn ^= 0x00400000;
	  else if ((insn & 0xffe30000) == 0x43800000		/* bc1f  */
		   || (insn & 0xffe30000) == 0x43a00000		/* bc1t  */
		   || (insn & 0xffe30000) == 0x42800000		/* bc2f  */
		   || (insn & 0xffe30000) == 0x42a00000)	/* bc2t  */
	    insn ^= 0x00200000;
	  else if ((insn & 0xff000000) == 0x83000000		/* BZ.df
								   BNZ.df  */
		    || (insn & 0xff600000) == 0x81600000)	/* BZ.V
								   BNZ.V */
	    insn ^= 0x00800000;
	  else
	    abort ();

	  if (al)
	    {
	      /* Clear the and-link and short-delay-slot bits.  */
	      gas_assert ((insn & 0xfda00000) == 0x40200000);

	      /* bltzal  0x40200000	bgezal  0x40600000  */
	      /* bltzals 0x42200000	bgezals 0x42600000  */
	      insn &= ~0x02200000;
	    }

	  /* Make a label at the end for use with the branch.  */
	  l = symbol_new (micromips_label_name (), asec, fragp->fr_fix, fragp);
	  micromips_label_inc ();
	  S_SET_OTHER (l, ELF_ST_SET_MICROMIPS (S_GET_OTHER (l)));

	  /* Refer to it.  */
	  fixp = fix_new (fragp, buf - fragp->fr_literal, 4, l, 0, TRUE,
			  BFD_RELOC_MICROMIPS_16_PCREL_S1);
	  fixp->fx_file = fragp->fr_file;
	  fixp->fx_line = fragp->fr_line;

	  /* Branch over the jump.  */
	  buf = write_compressed_insn (buf, insn, 4);
	  if (!compact)
	    /* nop */
	    buf = write_compressed_insn (buf, 0x0c00, 2);
	}

      if (mips_pic == NO_PIC)
	{
	  unsigned long jal = short_ds ? 0x74000000 : 0xf4000000; /* jal/s  */

	  /* j/jal/jals <sym>  R_MICROMIPS_26_S1  */
	  insn = al ? jal : 0xd4000000;

	  fixp = fix_new_exp (fragp, buf - fragp->fr_literal, 4, &exp, FALSE,
			      BFD_RELOC_MICROMIPS_JMP);
	  fixp->fx_file = fragp->fr_file;
	  fixp->fx_line = fragp->fr_line;

	  buf = write_compressed_insn (buf, insn, 4);
	  if (compact)
	    /* nop */
	    buf = write_compressed_insn (buf, 0x0c00, 2);
	}
      else
	{
	  unsigned long at = RELAX_MICROMIPS_AT (fragp->fr_subtype);
	  unsigned long jalr = short_ds ? 0x45e0 : 0x45c0;	/* jalr/s  */
	  unsigned long jr = compact ? 0x45a0 : 0x4580;		/* jr/c  */

	  /* lw/ld $at, <sym>($gp)  R_MICROMIPS_GOT16  */
	  insn = HAVE_64BIT_ADDRESSES ? 0xdc1c0000 : 0xfc1c0000;
	  insn |= at << MICROMIPSOP_SH_RT;

	  if (exp.X_add_number)
	    {
	      exp.X_add_symbol = make_expr_symbol (&exp);
	      exp.X_add_number = 0;
	    }

	  fixp = fix_new_exp (fragp, buf - fragp->fr_literal, 4, &exp, FALSE,
			      BFD_RELOC_MICROMIPS_GOT16);
	  fixp->fx_file = fragp->fr_file;
	  fixp->fx_line = fragp->fr_line;

	  buf = write_compressed_insn (buf, insn, 4);

	  /* d/addiu $at, $at, <sym>  R_MICROMIPS_LO16  */
	  insn = HAVE_64BIT_ADDRESSES ? 0x5c000000 : 0x30000000;
	  insn |= at << MICROMIPSOP_SH_RT | at << MICROMIPSOP_SH_RS;

	  fixp = fix_new_exp (fragp, buf - fragp->fr_literal, 4, &exp, FALSE,
			      BFD_RELOC_MICROMIPS_LO16);
	  fixp->fx_file = fragp->fr_file;
	  fixp->fx_line = fragp->fr_line;

	  buf = write_compressed_insn (buf, insn, 4);

	  /* jr/jrc/jalr/jalrs $at  */
	  insn = al ? jalr : jr;
	  insn |= at << MICROMIPSOP_SH_MJ;

	  buf = write_compressed_insn (buf, insn, 2);
	}

      gas_assert (buf == fragp->fr_literal + fragp->fr_fix);
      return;
    }

  if (RELAX_MIPS16_P (fragp->fr_subtype))
    {
      int type;
      const struct mips_int_operand *operand;
      offsetT val;
      char *buf;
      unsigned int user_length, length;
      unsigned long insn;
      bfd_boolean ext;

      type = RELAX_MIPS16_TYPE (fragp->fr_subtype);
      operand = mips16_immed_operand (type, FALSE);

      ext = RELAX_MIPS16_EXTENDED (fragp->fr_subtype);
      val = resolve_symbol_value (fragp->fr_symbol);
      if (operand->root.type == OP_PCREL)
	{
	  const struct mips_pcrel_operand *pcrel_op;
	  addressT addr;

	  pcrel_op = (const struct mips_pcrel_operand *) operand;
	  addr = fragp->fr_address + fragp->fr_fix;

	  /* The rules for the base address of a PC relative reloc are
             complicated; see mips16_extended_frag.  */
	  if (pcrel_op->include_isa_bit)
	    {
	      addr += 2;
	      if (ext)
		addr += 2;
	      /* Ignore the low bit in the target, since it will be
                 set for a text label.  */
	      val &= -2;
	    }
	  else if (RELAX_MIPS16_JAL_DSLOT (fragp->fr_subtype))
	    addr -= 4;
	  else if (RELAX_MIPS16_DSLOT (fragp->fr_subtype))
	    addr -= 2;

	  addr &= -(1 << pcrel_op->align_log2);
	  val -= addr;

	  /* Make sure the section winds up with the alignment we have
             assumed.  */
	  if (operand->shift > 0)
	    record_alignment (asec, operand->shift);
	}

      if (ext
	  && (RELAX_MIPS16_JAL_DSLOT (fragp->fr_subtype)
	      || RELAX_MIPS16_DSLOT (fragp->fr_subtype)))
	as_warn_where (fragp->fr_file, fragp->fr_line,
		       _("extended instruction in delay slot"));

      buf = fragp->fr_literal + fragp->fr_fix;

      insn = read_compressed_insn (buf, 2);
      if (ext)
	insn |= MIPS16_EXTEND;

      if (RELAX_MIPS16_USER_EXT (fragp->fr_subtype))
	user_length = 4;
      else if (RELAX_MIPS16_USER_SMALL (fragp->fr_subtype))
	user_length = 2;
      else
	user_length = 0;

      mips16_immed (fragp->fr_file, fragp->fr_line, type,
		    BFD_RELOC_UNUSED, val, user_length, &insn);

      length = (ext ? 4 : 2);
      gas_assert (mips16_opcode_length (insn) == length);
      write_compressed_insn (buf, insn, length);
      fragp->fr_fix += length;
    }
  else
    {
      relax_substateT subtype = fragp->fr_subtype;
      bfd_boolean second_longer = (subtype & RELAX_SECOND_LONGER) != 0;
      bfd_boolean use_second = (subtype & RELAX_USE_SECOND) != 0;
      int first, second;
      fixS *fixp;

      first = RELAX_FIRST (subtype);
      second = RELAX_SECOND (subtype);
      fixp = (fixS *) fragp->fr_opcode;

      /* If the delay slot chosen does not match the size of the instruction,
         then emit a warning.  */
      if ((!use_second && (subtype & RELAX_DELAY_SLOT_SIZE_FIRST) != 0)
	   || (use_second && (subtype & RELAX_DELAY_SLOT_SIZE_SECOND) != 0))
	{
	  relax_substateT s;
	  const char *msg;

	  s = subtype & (RELAX_DELAY_SLOT_16BIT
			 | RELAX_DELAY_SLOT_SIZE_FIRST
			 | RELAX_DELAY_SLOT_SIZE_SECOND);
	  msg = macro_warning (s);
	  if (msg != NULL)
	    as_warn_where (fragp->fr_file, fragp->fr_line, "%s", msg);
	  subtype &= ~s;
	}

      /* Possibly emit a warning if we've chosen the longer option.  */
      if (use_second == second_longer)
	{
	  relax_substateT s;
	  const char *msg;

	  s = (subtype
	       & (RELAX_SECOND_LONGER | RELAX_NOMACRO | RELAX_DELAY_SLOT));
	  msg = macro_warning (s);
	  if (msg != NULL)
	    as_warn_where (fragp->fr_file, fragp->fr_line, "%s", msg);
	  subtype &= ~s;
	}

      /* Go through all the fixups for the first sequence.  Disable them
	 (by marking them as done) if we're going to use the second
	 sequence instead.  */
      while (fixp
	     && fixp->fx_frag == fragp
	     && fixp->fx_where < fragp->fr_fix - second)
	{
	  if (subtype & RELAX_USE_SECOND)
	    fixp->fx_done = 1;
	  fixp = fixp->fx_next;
	}

      /* Go through the fixups for the second sequence.  Disable them if
	 we're going to use the first sequence, otherwise adjust their
	 addresses to account for the relaxation.  */
      while (fixp && fixp->fx_frag == fragp)
	{
	  if (subtype & RELAX_USE_SECOND)
	    fixp->fx_where -= first;
	  else
	    fixp->fx_done = 1;
	  fixp = fixp->fx_next;
	}

      /* Now modify the frag contents.  */
      if (subtype & RELAX_USE_SECOND)
	{
	  char *start;

	  start = fragp->fr_literal + fragp->fr_fix - first - second;
	  memmove (start, start + first, second);
	  fragp->fr_fix -= first;
	}
      else
	fragp->fr_fix -= second;
    }
}

/* This function is called after the relocs have been generated.
   We've been storing mips16 text labels as odd.  Here we convert them
   back to even for the convenience of the debugger.  */

void
mips_frob_file_after_relocs (void)
{
  asymbol **syms;
  unsigned int count, i;

  syms = bfd_get_outsymbols (stdoutput);
  count = bfd_get_symcount (stdoutput);
  for (i = 0; i < count; i++, syms++)
    if (ELF_ST_IS_COMPRESSED (elf_symbol (*syms)->internal_elf_sym.st_other)
	&& ((*syms)->value & 1) != 0)
      {
	(*syms)->value &= ~1;
	/* If the symbol has an odd size, it was probably computed
	   incorrectly, so adjust that as well.  */
	if ((elf_symbol (*syms)->internal_elf_sym.st_size & 1) != 0)
	  ++elf_symbol (*syms)->internal_elf_sym.st_size;
      }
}

/* This function is called whenever a label is defined, including fake
   labels instantiated off the dot special symbol.  It is used when
   handling branch delays; if a branch has a label, we assume we cannot
   move it.  This also bumps the value of the symbol by 1 in compressed
   code.  */

static void
mips_record_label (symbolS *sym)
{
  segment_info_type *si = seg_info (now_seg);
  struct insn_label_list *l;

  if (free_insn_labels == NULL)
    l = (struct insn_label_list *) xmalloc (sizeof *l);
  else
    {
      l = free_insn_labels;
      free_insn_labels = l->next;
    }

  l->label = sym;
  l->next = si->label_list;
  si->label_list = l;
}

/* This function is called as tc_frob_label() whenever a label is defined
   and adds a DWARF-2 record we only want for true labels.  */

void
mips_define_label (symbolS *sym)
{
  mips_record_label (sym);
  dwarf2_emit_label (sym);
}

/* This function is called by tc_new_dot_label whenever a new dot symbol
   is defined.  */

void
mips_add_dot_label (symbolS *sym)
{
  mips_record_label (sym);
  if (mips_assembling_insn && HAVE_CODE_COMPRESSION)
    mips_compressed_mark_label (sym);
}

/* Some special processing for a MIPS ELF file.  */

void
mips_elf_final_processing (void)
{
  /* Write out the register information.  */
  if (mips_abi != N64_ABI)
    {
      Elf32_RegInfo s;

      s.ri_gprmask = mips_gprmask;
      s.ri_cprmask[0] = mips_cprmask[0];
      s.ri_cprmask[1] = mips_cprmask[1];
      s.ri_cprmask[2] = mips_cprmask[2];
      s.ri_cprmask[3] = mips_cprmask[3];
      /* The gp_value field is set by the MIPS ELF backend.  */

      bfd_mips_elf32_swap_reginfo_out (stdoutput, &s,
				       ((Elf32_External_RegInfo *)
					mips_regmask_frag));
    }
  else
    {
      Elf64_Internal_RegInfo s;

      s.ri_gprmask = mips_gprmask;
      s.ri_pad = 0;
      s.ri_cprmask[0] = mips_cprmask[0];
      s.ri_cprmask[1] = mips_cprmask[1];
      s.ri_cprmask[2] = mips_cprmask[2];
      s.ri_cprmask[3] = mips_cprmask[3];
      /* The gp_value field is set by the MIPS ELF backend.  */

      bfd_mips_elf64_swap_reginfo_out (stdoutput, &s,
				       ((Elf64_External_RegInfo *)
					mips_regmask_frag));
    }

  /* Set the MIPS ELF flag bits.  FIXME: There should probably be some
     sort of BFD interface for this.  */
  if (mips_any_noreorder)
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_NOREORDER;
  if (mips_pic != NO_PIC)
    {
      elf_elfheader (stdoutput)->e_flags |= EF_MIPS_PIC;
      elf_elfheader (stdoutput)->e_flags |= EF_MIPS_CPIC;
    }
  if (mips_abicalls)
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_CPIC;

  /* Set MIPS ELF flags for ASEs.  Note that not all ASEs have flags
     defined at present; this might need to change in future.  */
  if (file_ase_mips16)
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_ARCH_ASE_M16;
  if (file_ase_micromips)
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_ARCH_ASE_MICROMIPS;
  if (file_ase & ASE_MDMX)
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_ARCH_ASE_MDMX;

  /* Set the MIPS ELF ABI flags.  */
  if (mips_abi == O32_ABI && USE_E_MIPS_ABI_O32)
    elf_elfheader (stdoutput)->e_flags |= E_MIPS_ABI_O32;
  else if (mips_abi == O64_ABI)
    elf_elfheader (stdoutput)->e_flags |= E_MIPS_ABI_O64;
  else if (mips_abi == EABI_ABI)
    {
      if (!file_mips_gp32)
	elf_elfheader (stdoutput)->e_flags |= E_MIPS_ABI_EABI64;
      else
	elf_elfheader (stdoutput)->e_flags |= E_MIPS_ABI_EABI32;
    }
  else if (mips_abi == N32_ABI)
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_ABI2;

  /* Nothing to do for N64_ABI.  */

  if (mips_32bitmode)
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_32BITMODE;

  if (mips_flag_nan2008)
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_NAN2008;

  /* 32 bit code with 64 bit FP registers.  */
  if (!file_mips_fp32 && ABI_NEEDS_32BIT_REGS (mips_abi))
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_FP64;
}

typedef struct proc {
  symbolS *func_sym;
  symbolS *func_end_sym;
  unsigned long reg_mask;
  unsigned long reg_offset;
  unsigned long fpreg_mask;
  unsigned long fpreg_offset;
  unsigned long frame_offset;
  unsigned long frame_reg;
  unsigned long pc_reg;
} procS;

static procS cur_proc;
static procS *cur_proc_ptr;
static int numprocs;

/* Implement NOP_OPCODE.  We encode a MIPS16 nop as "1", a microMIPS nop
   as "2", and a normal nop as "0".  */

#define NOP_OPCODE_MIPS		0
#define NOP_OPCODE_MIPS16	1
#define NOP_OPCODE_MICROMIPS	2

char
mips_nop_opcode (void)
{
  if (seg_info (now_seg)->tc_segment_info_data.micromips)
    return NOP_OPCODE_MICROMIPS;
  else if (seg_info (now_seg)->tc_segment_info_data.mips16)
    return NOP_OPCODE_MIPS16;
  else
    return NOP_OPCODE_MIPS;
}

/* Fill in an rs_align_code fragment.  Unlike elsewhere we want to use
   32-bit microMIPS NOPs here (if applicable).  */

void
mips_handle_align (fragS *fragp)
{
  char nop_opcode;
  char *p;
  int bytes, size, excess;
  valueT opcode;

  if (fragp->fr_type != rs_align_code)
    return;

  p = fragp->fr_literal + fragp->fr_fix;
  nop_opcode = *p;
  switch (nop_opcode)
    {
    case NOP_OPCODE_MICROMIPS:
      opcode = micromips_nop32_insn.insn_opcode;
      size = 4;
      break;
    case NOP_OPCODE_MIPS16:
      opcode = mips16_nop_insn.insn_opcode;
      size = 2;
      break;
    case NOP_OPCODE_MIPS:
    default:
      opcode = nop_insn.insn_opcode;
      size = 4;
      break;
    }

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  excess = bytes % size;

  /* Handle the leading part if we're not inserting a whole number of
     instructions, and make it the end of the fixed part of the frag.
     Try to fit in a short microMIPS NOP if applicable and possible,
     and use zeroes otherwise.  */
  gas_assert (excess < 4);
  fragp->fr_fix += excess;
  switch (excess)
    {
    case 3:
      *p++ = '\0';
      /* Fall through.  */
    case 2:
      if (nop_opcode == NOP_OPCODE_MICROMIPS && !mips_opts.insn32)
	{
	  p = write_compressed_insn (p, micromips_nop16_insn.insn_opcode, 2);
	  break;
	}
      *p++ = '\0';
      /* Fall through.  */
    case 1:
      *p++ = '\0';
      /* Fall through.  */
    case 0:
      break;
    }

  md_number_to_chars (p, opcode, size);
  fragp->fr_var = size;
}

static void
md_obj_begin (void)
{
}

static void
md_obj_end (void)
{
  /* Check for premature end, nesting errors, etc.  */
  if (cur_proc_ptr)
    as_warn (_("missing .end at end of assembly"));
}

static long
get_number (void)
{
  int negative = 0;
  long val = 0;

  if (*input_line_pointer == '-')
    {
      ++input_line_pointer;
      negative = 1;
    }
  if (!ISDIGIT (*input_line_pointer))
    as_bad (_("expected simple number"));
  if (input_line_pointer[0] == '0')
    {
      if (input_line_pointer[1] == 'x')
	{
	  input_line_pointer += 2;
	  while (ISXDIGIT (*input_line_pointer))
	    {
	      val <<= 4;
	      val |= hex_value (*input_line_pointer++);
	    }
	  return negative ? -val : val;
	}
      else
	{
	  ++input_line_pointer;
	  while (ISDIGIT (*input_line_pointer))
	    {
	      val <<= 3;
	      val |= *input_line_pointer++ - '0';
	    }
	  return negative ? -val : val;
	}
    }
  if (!ISDIGIT (*input_line_pointer))
    {
      printf (_(" *input_line_pointer == '%c' 0x%02x\n"),
	      *input_line_pointer, *input_line_pointer);
      as_warn (_("invalid number"));
      return -1;
    }
  while (ISDIGIT (*input_line_pointer))
    {
      val *= 10;
      val += *input_line_pointer++ - '0';
    }
  return negative ? -val : val;
}

/* The .file directive; just like the usual .file directive, but there
   is an initial number which is the ECOFF file index.  In the non-ECOFF
   case .file implies DWARF-2.  */

static void
s_mips_file (int x ATTRIBUTE_UNUSED)
{
  static int first_file_directive = 0;

  if (ECOFF_DEBUGGING)
    {
      get_number ();
      s_app_file (0);
    }
  else
    {
      char *filename;

      filename = dwarf2_directive_file (0);

      /* Versions of GCC up to 3.1 start files with a ".file"
	 directive even for stabs output.  Make sure that this
	 ".file" is handled.  Note that you need a version of GCC
         after 3.1 in order to support DWARF-2 on MIPS.  */
      if (filename != NULL && ! first_file_directive)
	{
	  (void) new_logical_line (filename, -1);
	  s_app_file_string (filename, 0);
	}
      first_file_directive = 1;
    }
}

/* The .loc directive, implying DWARF-2.  */

static void
s_mips_loc (int x ATTRIBUTE_UNUSED)
{
  if (!ECOFF_DEBUGGING)
    dwarf2_directive_loc (0);
}

/* The .end directive.  */

static void
s_mips_end (int x ATTRIBUTE_UNUSED)
{
  symbolS *p;

  /* Following functions need their own .frame and .cprestore directives.  */
  mips_frame_reg_valid = 0;
  mips_cprestore_valid = 0;

  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      p = get_symbol ();
      demand_empty_rest_of_line ();
    }
  else
    p = NULL;

  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) == 0)
    as_warn (_(".end not in text section"));

  if (!cur_proc_ptr)
    {
      as_warn (_(".end directive without a preceding .ent directive"));
      demand_empty_rest_of_line ();
      return;
    }

  if (p != NULL)
    {
      gas_assert (S_GET_NAME (p));
      if (strcmp (S_GET_NAME (p), S_GET_NAME (cur_proc_ptr->func_sym)))
	as_warn (_(".end symbol does not match .ent symbol"));

      if (debug_type == DEBUG_STABS)
	stabs_generate_asm_endfunc (S_GET_NAME (p),
				    S_GET_NAME (p));
    }
  else
    as_warn (_(".end directive missing or unknown symbol"));

  /* Create an expression to calculate the size of the function.  */
  if (p && cur_proc_ptr)
    {
      OBJ_SYMFIELD_TYPE *obj = symbol_get_obj (p);
      expressionS *exp = xmalloc (sizeof (expressionS));

      obj->size = exp;
      exp->X_op = O_subtract;
      exp->X_add_symbol = symbol_temp_new_now ();
      exp->X_op_symbol = p;
      exp->X_add_number = 0;

      cur_proc_ptr->func_end_sym = exp->X_add_symbol;
    }

  /* Generate a .pdr section.  */
  if (!ECOFF_DEBUGGING && mips_flag_pdr)
    {
      segT saved_seg = now_seg;
      subsegT saved_subseg = now_subseg;
      expressionS exp;
      char *fragp;

#ifdef md_flush_pending_output
      md_flush_pending_output ();
#endif

      gas_assert (pdr_seg);
      subseg_set (pdr_seg, 0);

      /* Write the symbol.  */
      exp.X_op = O_symbol;
      exp.X_add_symbol = p;
      exp.X_add_number = 0;
      emit_expr (&exp, 4);

      fragp = frag_more (7 * 4);

      md_number_to_chars (fragp, cur_proc_ptr->reg_mask, 4);
      md_number_to_chars (fragp + 4, cur_proc_ptr->reg_offset, 4);
      md_number_to_chars (fragp + 8, cur_proc_ptr->fpreg_mask, 4);
      md_number_to_chars (fragp + 12, cur_proc_ptr->fpreg_offset, 4);
      md_number_to_chars (fragp + 16, cur_proc_ptr->frame_offset, 4);
      md_number_to_chars (fragp + 20, cur_proc_ptr->frame_reg, 4);
      md_number_to_chars (fragp + 24, cur_proc_ptr->pc_reg, 4);

      subseg_set (saved_seg, saved_subseg);
    }

  cur_proc_ptr = NULL;
}

/* The .aent and .ent directives.  */

static void
s_mips_ent (int aent)
{
  symbolS *symbolP;

  symbolP = get_symbol ();
  if (*input_line_pointer == ',')
    ++input_line_pointer;
  SKIP_WHITESPACE ();
  if (ISDIGIT (*input_line_pointer)
      || *input_line_pointer == '-')
    get_number ();

  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) == 0)
    as_warn (_(".ent or .aent not in text section"));

  if (!aent && cur_proc_ptr)
    as_warn (_("missing .end"));

  if (!aent)
    {
      /* This function needs its own .frame and .cprestore directives.  */
      mips_frame_reg_valid = 0;
      mips_cprestore_valid = 0;

      cur_proc_ptr = &cur_proc;
      memset (cur_proc_ptr, '\0', sizeof (procS));

      cur_proc_ptr->func_sym = symbolP;

      ++numprocs;

      if (debug_type == DEBUG_STABS)
        stabs_generate_asm_func (S_GET_NAME (symbolP),
				 S_GET_NAME (symbolP));
    }

  symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;

  demand_empty_rest_of_line ();
}

/* The .frame directive. If the mdebug section is present (IRIX 5 native)
   then ecoff.c (ecoff_directive_frame) is used. For embedded targets,
   s_mips_frame is used so that we can set the PDR information correctly.
   We can't use the ecoff routines because they make reference to the ecoff
   symbol table (in the mdebug section).  */

static void
s_mips_frame (int ignore ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    s_ignore (ignore);
  else
    {
      long val;

      if (cur_proc_ptr == (procS *) NULL)
	{
	  as_warn (_(".frame outside of .ent"));
	  demand_empty_rest_of_line ();
	  return;
	}

      cur_proc_ptr->frame_reg = tc_get_register (1);

      SKIP_WHITESPACE ();
      if (*input_line_pointer++ != ','
	  || get_absolute_expression_and_terminator (&val) != ',')
	{
	  as_warn (_("bad .frame directive"));
	  --input_line_pointer;
	  demand_empty_rest_of_line ();
	  return;
	}

      cur_proc_ptr->frame_offset = val;
      cur_proc_ptr->pc_reg = tc_get_register (0);

      demand_empty_rest_of_line ();
    }
}

/* The .fmask and .mask directives. If the mdebug section is present
   (IRIX 5 native) then ecoff.c (ecoff_directive_mask) is used. For
   embedded targets, s_mips_mask is used so that we can set the PDR
   information correctly. We can't use the ecoff routines because they
   make reference to the ecoff symbol table (in the mdebug section).  */

static void
s_mips_mask (int reg_type)
{
  if (ECOFF_DEBUGGING)
    s_ignore (reg_type);
  else
    {
      long mask, off;

      if (cur_proc_ptr == (procS *) NULL)
	{
	  as_warn (_(".mask/.fmask outside of .ent"));
	  demand_empty_rest_of_line ();
	  return;
	}

      if (get_absolute_expression_and_terminator (&mask) != ',')
	{
	  as_warn (_("bad .mask/.fmask directive"));
	  --input_line_pointer;
	  demand_empty_rest_of_line ();
	  return;
	}

      off = get_absolute_expression ();

      if (reg_type == 'F')
	{
	  cur_proc_ptr->fpreg_mask = mask;
	  cur_proc_ptr->fpreg_offset = off;
	}
      else
	{
	  cur_proc_ptr->reg_mask = mask;
	  cur_proc_ptr->reg_offset = off;
	}

      demand_empty_rest_of_line ();
    }
}

/* A table describing all the processors gas knows about.  Names are
   matched in the order listed.

   To ease comparison, please keep this table in the same order as
   gcc's mips_cpu_info_table[].  */
static const struct mips_cpu_info mips_cpu_info_table[] =
{
  /* Entries for generic ISAs */
  { "mips1",          MIPS_CPU_IS_ISA, 0,	ISA_MIPS1,    CPU_R3000 },
  { "mips2",          MIPS_CPU_IS_ISA, 0,	ISA_MIPS2,    CPU_R6000 },
  { "mips3",          MIPS_CPU_IS_ISA, 0,	ISA_MIPS3,    CPU_R4000 },
  { "mips4",          MIPS_CPU_IS_ISA, 0,	ISA_MIPS4,    CPU_R8000 },
  { "mips5",          MIPS_CPU_IS_ISA, 0,	ISA_MIPS5,    CPU_MIPS5 },
  { "mips32",         MIPS_CPU_IS_ISA, 0,	ISA_MIPS32,   CPU_MIPS32 },
  { "mips32r2",       MIPS_CPU_IS_ISA, 0,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "mips64",         MIPS_CPU_IS_ISA, 0,	ISA_MIPS64,   CPU_MIPS64 },
  { "mips64r2",       MIPS_CPU_IS_ISA, 0,	ISA_MIPS64R2, CPU_MIPS64R2 },

  /* MIPS I */
  { "r3000",          0, 0,			ISA_MIPS1,    CPU_R3000 },
  { "r2000",          0, 0,			ISA_MIPS1,    CPU_R3000 },
  { "r3900",          0, 0,			ISA_MIPS1,    CPU_R3900 },

  /* MIPS II */
  { "r6000",          0, 0,			ISA_MIPS2,    CPU_R6000 },

  /* MIPS III */
  { "r4000",          0, 0,			ISA_MIPS3,    CPU_R4000 },
  { "r4010",          0, 0,			ISA_MIPS2,    CPU_R4010 },
  { "vr4100",         0, 0,			ISA_MIPS3,    CPU_VR4100 },
  { "vr4111",         0, 0,			ISA_MIPS3,    CPU_R4111 },
  { "vr4120",         0, 0,			ISA_MIPS3,    CPU_VR4120 },
  { "vr4130",         0, 0,			ISA_MIPS3,    CPU_VR4120 },
  { "vr4181",         0, 0,			ISA_MIPS3,    CPU_R4111 },
  { "vr4300",         0, 0,			ISA_MIPS3,    CPU_R4300 },
  { "r4400",          0, 0,			ISA_MIPS3,    CPU_R4400 },
  { "r4600",          0, 0,			ISA_MIPS3,    CPU_R4600 },
  { "orion",          0, 0,			ISA_MIPS3,    CPU_R4600 },
  { "r4650",          0, 0,			ISA_MIPS3,    CPU_R4650 },
  { "r5900",          0, 0,			ISA_MIPS3,    CPU_R5900 },
  /* ST Microelectronics Loongson 2E and 2F cores */
  { "loongson2e",     0, 0,			ISA_MIPS3,    CPU_LOONGSON_2E },
  { "loongson2f",     0, 0,			ISA_MIPS3,    CPU_LOONGSON_2F },

  /* MIPS IV */
  { "r8000",          0, 0,			ISA_MIPS4,    CPU_R8000 },
  { "r10000",         0, 0,			ISA_MIPS4,    CPU_R10000 },
  { "r12000",         0, 0,			ISA_MIPS4,    CPU_R12000 },
  { "r14000",         0, 0,			ISA_MIPS4,    CPU_R14000 },
  { "r16000",         0, 0,			ISA_MIPS4,    CPU_R16000 },
  { "vr5000",         0, 0,			ISA_MIPS4,    CPU_R5000 },
  { "vr5400",         0, 0,			ISA_MIPS4,    CPU_VR5400 },
  { "vr5500",         0, 0,			ISA_MIPS4,    CPU_VR5500 },
  { "rm5200",         0, 0,			ISA_MIPS4,    CPU_R5000 },
  { "rm5230",         0, 0,			ISA_MIPS4,    CPU_R5000 },
  { "rm5231",         0, 0,			ISA_MIPS4,    CPU_R5000 },
  { "rm5261",         0, 0,			ISA_MIPS4,    CPU_R5000 },
  { "rm5721",         0, 0,			ISA_MIPS4,    CPU_R5000 },
  { "rm7000",         0, 0,			ISA_MIPS4,    CPU_RM7000 },
  { "rm9000",         0, 0,			ISA_MIPS4,    CPU_RM9000 },

  /* MIPS 32 */
  { "4kc",            0, 0,			ISA_MIPS32,   CPU_MIPS32 },
  { "4km",            0, 0,			ISA_MIPS32,   CPU_MIPS32 },
  { "4kp",            0, 0,			ISA_MIPS32,   CPU_MIPS32 },
  { "4ksc",           0, ASE_SMARTMIPS,		ISA_MIPS32,   CPU_MIPS32 },

  /* MIPS 32 Release 2 */
  { "4kec",           0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  { "4kem",           0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  { "4kep",           0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  { "4ksd",           0, ASE_SMARTMIPS,		ISA_MIPS32R2, CPU_MIPS32R2 },
  { "m4k",            0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  { "m4kp",           0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  { "m14k",           0, ASE_MCU,		ISA_MIPS32R2, CPU_MIPS32R2 },
  { "m14kc",          0, ASE_MCU,		ISA_MIPS32R2, CPU_MIPS32R2 },
  { "m14ke",          0, ASE_DSP | ASE_DSPR2 | ASE_MCU,
						ISA_MIPS32R2, CPU_MIPS32R2 },
  { "m14kec",         0, ASE_DSP | ASE_DSPR2 | ASE_MCU,
						ISA_MIPS32R2, CPU_MIPS32R2 },
  { "24kc",           0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  { "24kf2_1",        0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  { "24kf",           0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  { "24kf1_1",        0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  /* Deprecated forms of the above.  */
  { "24kfx",          0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  { "24kx",           0, 0,			ISA_MIPS32R2, CPU_MIPS32R2 },
  /* 24KE is a 24K with DSP ASE, other ASEs are optional.  */
  { "24kec",          0, ASE_DSP,		ISA_MIPS32R2, CPU_MIPS32R2 },
  { "24kef2_1",       0, ASE_DSP,		ISA_MIPS32R2, CPU_MIPS32R2 },
  { "24kef",          0, ASE_DSP,		ISA_MIPS32R2, CPU_MIPS32R2 },
  { "24kef1_1",       0, ASE_DSP,		ISA_MIPS32R2, CPU_MIPS32R2 },
  /* Deprecated forms of the above.  */
  { "24kefx",         0, ASE_DSP,		ISA_MIPS32R2, CPU_MIPS32R2 },
  { "24kex",          0, ASE_DSP,		ISA_MIPS32R2, CPU_MIPS32R2 },
  /* 34K is a 24K with DSP and MT ASE, other ASEs are optional.  */
  { "34kc",           0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "34kf2_1",        0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "34kf",           0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "34kf1_1",        0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },
  /* Deprecated forms of the above.  */
  { "34kfx",          0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "34kx",           0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },
  /* 34Kn is a 34kc without DSP.  */
  { "34kn",           0, ASE_MT,		ISA_MIPS32R2, CPU_MIPS32R2 },
  /* 74K with DSP and DSPR2 ASE, other ASEs are optional.  */
  { "74kc",           0, ASE_DSP | ASE_DSPR2,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "74kf2_1",        0, ASE_DSP | ASE_DSPR2,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "74kf",           0, ASE_DSP | ASE_DSPR2,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "74kf1_1",        0, ASE_DSP | ASE_DSPR2,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "74kf3_2",        0, ASE_DSP | ASE_DSPR2,	ISA_MIPS32R2, CPU_MIPS32R2 },
  /* Deprecated forms of the above.  */
  { "74kfx",          0, ASE_DSP | ASE_DSPR2,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "74kx",           0, ASE_DSP | ASE_DSPR2,	ISA_MIPS32R2, CPU_MIPS32R2 },
  /* 1004K cores are multiprocessor versions of the 34K.  */
  { "1004kc",         0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "1004kf2_1",      0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "1004kf",         0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },
  { "1004kf1_1",      0, ASE_DSP | ASE_MT,	ISA_MIPS32R2, CPU_MIPS32R2 },

  /* MIPS 64 */
  { "5kc",            0, 0,			ISA_MIPS64,   CPU_MIPS64 },
  { "5kf",            0, 0,			ISA_MIPS64,   CPU_MIPS64 },
  { "20kc",           0, ASE_MIPS3D,		ISA_MIPS64,   CPU_MIPS64 },
  { "25kf",           0, ASE_MIPS3D,		ISA_MIPS64,   CPU_MIPS64 },

  /* Broadcom SB-1 CPU core */
  { "sb1",            0, ASE_MIPS3D | ASE_MDMX,	ISA_MIPS64,   CPU_SB1 },
  /* Broadcom SB-1A CPU core */
  { "sb1a",           0, ASE_MIPS3D | ASE_MDMX,	ISA_MIPS64,   CPU_SB1 },
  
  { "loongson3a",     0, 0,			ISA_MIPS64,   CPU_LOONGSON_3A },

  /* MIPS 64 Release 2 */

  /* Cavium Networks Octeon CPU core */
  { "octeon",	      0, 0,			ISA_MIPS64R2, CPU_OCTEON },
  { "octeon+",	      0, 0,			ISA_MIPS64R2, CPU_OCTEONP },
  { "octeon2",	      0, 0,			ISA_MIPS64R2, CPU_OCTEON2 },

  /* RMI Xlr */
  { "xlr",	      0, 0,			ISA_MIPS64,   CPU_XLR },

  /* Broadcom XLP.
     XLP is mostly like XLR, with the prominent exception that it is
     MIPS64R2 rather than MIPS64.  */
  { "xlp",	      0, 0,			ISA_MIPS64R2, CPU_XLR },

  /* End marker */
  { NULL, 0, 0, 0, 0 }
};


/* Return true if GIVEN is the same as CANONICAL, or if it is CANONICAL
   with a final "000" replaced by "k".  Ignore case.

   Note: this function is shared between GCC and GAS.  */

static bfd_boolean
mips_strict_matching_cpu_name_p (const char *canonical, const char *given)
{
  while (*given != 0 && TOLOWER (*given) == TOLOWER (*canonical))
    given++, canonical++;

  return ((*given == 0 && *canonical == 0)
	  || (strcmp (canonical, "000") == 0 && strcasecmp (given, "k") == 0));
}


/* Return true if GIVEN matches CANONICAL, where GIVEN is a user-supplied
   CPU name.  We've traditionally allowed a lot of variation here.

   Note: this function is shared between GCC and GAS.  */

static bfd_boolean
mips_matching_cpu_name_p (const char *canonical, const char *given)
{
  /* First see if the name matches exactly, or with a final "000"
     turned into "k".  */
  if (mips_strict_matching_cpu_name_p (canonical, given))
    return TRUE;

  /* If not, try comparing based on numerical designation alone.
     See if GIVEN is an unadorned number, or 'r' followed by a number.  */
  if (TOLOWER (*given) == 'r')
    given++;
  if (!ISDIGIT (*given))
    return FALSE;

  /* Skip over some well-known prefixes in the canonical name,
     hoping to find a number there too.  */
  if (TOLOWER (canonical[0]) == 'v' && TOLOWER (canonical[1]) == 'r')
    canonical += 2;
  else if (TOLOWER (canonical[0]) == 'r' && TOLOWER (canonical[1]) == 'm')
    canonical += 2;
  else if (TOLOWER (canonical[0]) == 'r')
    canonical += 1;

  return mips_strict_matching_cpu_name_p (canonical, given);
}


/* Parse an option that takes the name of a processor as its argument.
   OPTION is the name of the option and CPU_STRING is the argument.
   Return the corresponding processor enumeration if the CPU_STRING is
   recognized, otherwise report an error and return null.

   A similar function exists in GCC.  */

static const struct mips_cpu_info *
mips_parse_cpu (const char *option, const char *cpu_string)
{
  const struct mips_cpu_info *p;

  /* 'from-abi' selects the most compatible architecture for the given
     ABI: MIPS I for 32-bit ABIs and MIPS III for 64-bit ABIs.  For the
     EABIs, we have to decide whether we're using the 32-bit or 64-bit
     version.  Look first at the -mgp options, if given, otherwise base
     the choice on MIPS_DEFAULT_64BIT.

     Treat NO_ABI like the EABIs.  One reason to do this is that the
     plain 'mips' and 'mips64' configs have 'from-abi' as their default
     architecture.  This code picks MIPS I for 'mips' and MIPS III for
     'mips64', just as we did in the days before 'from-abi'.  */
  if (strcasecmp (cpu_string, "from-abi") == 0)
    {
      if (ABI_NEEDS_32BIT_REGS (mips_abi))
	return mips_cpu_info_from_isa (ISA_MIPS1);

      if (ABI_NEEDS_64BIT_REGS (mips_abi))
	return mips_cpu_info_from_isa (ISA_MIPS3);

      if (file_mips_gp32 >= 0)
	return mips_cpu_info_from_isa (file_mips_gp32 ? ISA_MIPS1 : ISA_MIPS3);

      return mips_cpu_info_from_isa (MIPS_DEFAULT_64BIT
				     ? ISA_MIPS3
				     : ISA_MIPS1);
    }

  /* 'default' has traditionally been a no-op.  Probably not very useful.  */
  if (strcasecmp (cpu_string, "default") == 0)
    return 0;

  for (p = mips_cpu_info_table; p->name != 0; p++)
    if (mips_matching_cpu_name_p (p->name, cpu_string))
      return p;

  as_bad (_("bad value (%s) for %s"), cpu_string, option);
  return 0;
}

/* Return the canonical processor information for ISA (a member of the
   ISA_MIPS* enumeration).  */

static const struct mips_cpu_info *
mips_cpu_info_from_isa (int isa)
{
  int i;

  for (i = 0; mips_cpu_info_table[i].name != NULL; i++)
    if ((mips_cpu_info_table[i].flags & MIPS_CPU_IS_ISA)
	&& isa == mips_cpu_info_table[i].isa)
      return (&mips_cpu_info_table[i]);

  return NULL;
}

static const struct mips_cpu_info *
mips_cpu_info_from_arch (int arch)
{
  int i;

  for (i = 0; mips_cpu_info_table[i].name != NULL; i++)
    if (arch == mips_cpu_info_table[i].cpu)
      return (&mips_cpu_info_table[i]);

  return NULL;
}

static void
show (FILE *stream, const char *string, int *col_p, int *first_p)
{
  if (*first_p)
    {
      fprintf (stream, "%24s", "");
      *col_p = 24;
    }
  else
    {
      fprintf (stream, ", ");
      *col_p += 2;
    }

  if (*col_p + strlen (string) > 72)
    {
      fprintf (stream, "\n%24s", "");
      *col_p = 24;
    }

  fprintf (stream, "%s", string);
  *col_p += strlen (string);

  *first_p = 0;
}

void
md_show_usage (FILE *stream)
{
  int column, first;
  size_t i;

  fprintf (stream, _("\
MIPS options:\n\
-EB			generate big endian output\n\
-EL			generate little endian output\n\
-g, -g2			do not remove unneeded NOPs or swap branches\n\
-G NUM			allow referencing objects up to NUM bytes\n\
			implicitly with the gp register [default 8]\n"));
  fprintf (stream, _("\
-mips1			generate MIPS ISA I instructions\n\
-mips2			generate MIPS ISA II instructions\n\
-mips3			generate MIPS ISA III instructions\n\
-mips4			generate MIPS ISA IV instructions\n\
-mips5                  generate MIPS ISA V instructions\n\
-mips32                 generate MIPS32 ISA instructions\n\
-mips32r2               generate MIPS32 release 2 ISA instructions\n\
-mips64                 generate MIPS64 ISA instructions\n\
-mips64r2               generate MIPS64 release 2 ISA instructions\n\
-march=CPU/-mtune=CPU	generate code/schedule for CPU, where CPU is one of:\n"));

  first = 1;

  for (i = 0; mips_cpu_info_table[i].name != NULL; i++)
    show (stream, mips_cpu_info_table[i].name, &column, &first);
  show (stream, "from-abi", &column, &first);
  fputc ('\n', stream);

  fprintf (stream, _("\
-mCPU			equivalent to -march=CPU -mtune=CPU. Deprecated.\n\
-no-mCPU		don't generate code specific to CPU.\n\
			For -mCPU and -no-mCPU, CPU must be one of:\n"));

  first = 1;

  show (stream, "3900", &column, &first);
  show (stream, "4010", &column, &first);
  show (stream, "4100", &column, &first);
  show (stream, "4650", &column, &first);
  fputc ('\n', stream);

  fprintf (stream, _("\
-mips16			generate mips16 instructions\n\
-no-mips16		do not generate mips16 instructions\n"));
  fprintf (stream, _("\
-mmicromips		generate microMIPS instructions\n\
-mno-micromips		do not generate microMIPS instructions\n"));
  fprintf (stream, _("\
-msmartmips		generate smartmips instructions\n\
-mno-smartmips		do not generate smartmips instructions\n"));  
  fprintf (stream, _("\
-mdsp			generate DSP instructions\n\
-mno-dsp		do not generate DSP instructions\n"));
  fprintf (stream, _("\
-mdspr2			generate DSP R2 instructions\n\
-mno-dspr2		do not generate DSP R2 instructions\n"));
  fprintf (stream, _("\
-mmt			generate MT instructions\n\
-mno-mt			do not generate MT instructions\n"));
  fprintf (stream, _("\
-mmcu			generate MCU instructions\n\
-mno-mcu		do not generate MCU instructions\n"));
  fprintf (stream, _("\
-mmsa			generate MSA instructions\n\
-mno-msa		do not generate MSA instructions\n"));
  fprintf (stream, _("\
-mvirt			generate Virtualization instructions\n\
-mno-virt		do not generate Virtualization instructions\n"));
  fprintf (stream, _("\
-minsn32		only generate 32-bit microMIPS instructions\n\
-mno-insn32		generate all microMIPS instructions\n"));
  fprintf (stream, _("\
-mfix-loongson2f-jump	work around Loongson2F JUMP instructions\n\
-mfix-loongson2f-nop	work around Loongson2F NOP errata\n\
-mfix-vr4120		work around certain VR4120 errata\n\
-mfix-vr4130		work around VR4130 mflo/mfhi errata\n\
-mfix-24k		insert a nop after ERET and DERET instructions\n\
-mfix-cn63xxp1		work around CN63XXP1 PREF errata\n\
-mgp32			use 32-bit GPRs, regardless of the chosen ISA\n\
-mfp32			use 32-bit FPRs, regardless of the chosen ISA\n\
-msym32			assume all symbols have 32-bit values\n\
-O0			remove unneeded NOPs, do not swap branches\n\
-O			remove unneeded NOPs and swap branches\n\
--trap, --no-break	trap exception on div by 0 and mult overflow\n\
--break, --no-trap	break exception on div by 0 and mult overflow\n"));
  fprintf (stream, _("\
-mhard-float		allow floating-point instructions\n\
-msoft-float		do not allow floating-point instructions\n\
-msingle-float		only allow 32-bit floating-point operations\n\
-mdouble-float		allow 32-bit and 64-bit floating-point operations\n\
--[no-]construct-floats	[dis]allow floating point values to be constructed\n\
--[no-]relax-branch	[dis]allow out-of-range branches to be relaxed\n\
-mnan=ENCODING		select an IEEE 754 NaN encoding convention, either of:\n"));

  first = 1;

  show (stream, "legacy", &column, &first);
  show (stream, "2008", &column, &first);

  fputc ('\n', stream);

  fprintf (stream, _("\
-KPIC, -call_shared	generate SVR4 position independent code\n\
-call_nonpic		generate non-PIC code that can operate with DSOs\n\
-mvxworks-pic		generate VxWorks position independent code\n\
-non_shared		do not generate code that can operate with DSOs\n\
-xgot			assume a 32 bit GOT\n\
-mpdr, -mno-pdr		enable/disable creation of .pdr sections\n\
-mshared, -mno-shared   disable/enable .cpload optimization for\n\
                        position dependent (non shared) code\n\
-mabi=ABI		create ABI conformant object file for:\n"));

  first = 1;

  show (stream, "32", &column, &first);
  show (stream, "o64", &column, &first);
  show (stream, "n32", &column, &first);
  show (stream, "64", &column, &first);
  show (stream, "eabi", &column, &first);

  fputc ('\n', stream);

  fprintf (stream, _("\
-32			create o32 ABI object file (default)\n\
-n32			create n32 ABI object file\n\
-64			create 64 ABI object file\n"));
}

#ifdef TE_IRIX
enum dwarf2_format
mips_dwarf2_format (asection *sec ATTRIBUTE_UNUSED)
{
  if (HAVE_64BIT_SYMBOLS)
    return dwarf2_format_64bit_irix;
  else
    return dwarf2_format_32bit;
}
#endif

int
mips_dwarf2_addr_size (void)
{
  if (HAVE_64BIT_OBJECTS)
    return 8;
  else
    return 4;
}

/* Standard calling conventions leave the CFA at SP on entry.  */
void
mips_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa_register (SP);
}

int
tc_mips_regname_to_dw2regnum (char *regname)
{
  unsigned int regnum = -1;
  unsigned int reg;

  if (reg_lookup (&regname, RTYPE_GP | RTYPE_NUM, &reg))
    regnum = reg;

  return regnum;
}
@


1.594
log
@2013-10-14  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Chao-ying Fu  <Chao-ying.Fu@@imgtec.com>

	* config/tc-mips.c (options): Add OPTION_MSA and OPTION_NO_MSA.
	(md_longopts): Add mmsa and mno-msa.
	(mips_ases): Add msa.
	(RTYPE_MASK): Update.
	(RTYPE_MSA): New define.
	(OT_REG_ELEMENT): Replace with...
	(OT_INTEGER_INDEX, OT_REG_INDEX): ...these new operand types.
	(mips_operand_token): Replace reg_element with index.
	(mips_parse_argument_token): Treat vector indices as separate tokens.
	Handle register indices.
	(md_begin): Add MSA register names.
	(operand_reg_mask): Handle cases for OP_IMM_INDEX and OP_REG_INDEX.
	(convert_reg_type): Handle cases for OP_REG_MSA and OP_REG_MSA_CTRL.
	(match_mdmx_imm_reg_operand): Update accordingly.
	(match_imm_index_operand): New function.
	(match_reg_index_operand): New function.
	(match_operand): Handle cases for OP_IMM_INDEX and OP_REG_INDEX.
	(md_convert_frag): Convert bz.b/h/w/d, bnz.b/h/w/d, bz.v bnz.v.
	(md_show_usage): Print -mmsa and -mno-msa.
	* doc/as.texinfo: Document -mmsa and -mno-msa.
	* doc/c-mips.texi: Document -mmsa and -mno-msa.
	Document .set msa and .set nomsa.
@
text
@d4164 2
a4165 1
  mask = insn_reg_mask (ip, (1 << OP_REG_FP) | (1 << OP_REG_VEC),
d4183 2
a4184 1
  mask = insn_reg_mask (ip, (1 << OP_REG_FP) | (1 << OP_REG_VEC),
d6075 1
d6150 5
@


1.593
log
@2013-09-17  Doug Gilmore  <Doug.Gilmore@@imgtec.com>

	* config/tc-mips.c (mips_elf_final_processing): Set
	EF_MIPS_FP64 for -mgp32 -mfp64, removing old FIXME.
@
text
@d1332 2
d1445 2
d1593 4
d2358 1
a2358 1
#define RTYPE_MASK	0x0efff00
d2374 1
d2759 5
a2763 2
  /* An element of a vector, e.g. $v0[1].  */
  OT_REG_ELEMENT,
d2792 1
a2792 1
    /* The register symbol value for an OT_REG.  */
d2798 2
a2799 5
    /* The register symbol value and index for an OT_REG_ELEMENT.  */
    struct {
      unsigned int regno;
      addressT index;
    } reg_element;
d2960 7
a2966 1
      else if (*s == '[')
a2967 3
	  /* A vector element.  */
	  expressionS element;

d2970 3
a2972 2
	  my_getExpression (&element, s);
	  if (element.X_op != O_constant)
d2974 11
a2984 2
	      set_insn_error (0, _("vector element must be constant"));
	      return 0;
a2985 1
	  s = expr_end;
a2992 5

	  token.u.reg_element.regno = regno1;
	  token.u.reg_element.index = element.X_add_number;
	  mips_add_token (&token, OT_REG_ELEMENT);
	  return s;
a2993 4

      /* Looks like just a plain register.  */
      token.u.regno = regno1;
      mips_add_token (&token, OT_REG);
d3475 4
d4024 1
d4070 5
d4433 6
d5109 1
a5109 1
  if (arg->token->type == OT_REG || arg->token->type == OT_REG_ELEMENT)
d5119 4
d5125 1
a5125 1
      if (arg->token->type == OT_REG_ELEMENT)
d5127 1
a5127 4
	  if (!match_regno (arg, OP_REG_VEC, arg->token->u.reg_element.regno,
			    &regno))
	    return FALSE;
	  if (arg->token->u.reg_element.index > (is_qh ? 3 : 7))
d5132 2
a5133 2
	  else
	    uval |= arg->token->u.reg_element.index << (is_qh ? 2 : 1) << 5;
a5146 2
	  if (!match_regno (arg, OP_REG_VEC, arg->token->u.regno, &regno))
	    return FALSE;
a5152 1
      ++arg->token;
d5175 41
d5496 6
d16615 15
a16629 5
		  /* bc[0-3][tf]l? instructions can have the condition
		     reversed by tweaking a single TF bit, and their
		     opcodes all have 0x4???????.  */
		  gas_assert ((insn & 0xf3e00000) == 0x41000000);
		  insn ^= 0x00010000;
d16896 5
d18112 3
@


1.592
log
@2013-09-12  Chao-ying Fu  <Chao-ying.Fu@@imgtec.com>

	* config/tc-mips.c (match_insn): Set error when $31 is used for
	bltzal* and bgezal*.
@
text
@a17213 1
#if 0 /* XXX FIXME */
d17216 1
a17216 2
    elf_elfheader (stdoutput)->e_flags |= ???;
#endif
@


1.591
log
@gas/
	* config/tc-mips.c (mips_check_isa_supports_ase, reg_lookup)
	(mips_parse_argument_token, validate_micromips_insn, md_begin)
	(check_regno, match_float_constant, check_completed_insn, append_insn)
	(match_insn, match_mips16_insn, match_insns, macro_start)
	(macro_build_ldst_constoffset, load_register, macro, mips_ip)
	(mips16_ip, mips_set_option_string, md_parse_option)
	(mips_after_parse_args, mips_after_parse_args, md_pcrel_from)
	(md_apply_fix, s_align, s_option, s_mipsset, s_tls_rel_directive)
	(s_gpword, s_gpdword, s_ehword, s_nan, tc_gen_reloc, md_convert_frag)
	(s_mips_end, s_mips_ent, s_mips_frame, s_mips_mask, mips_parse_cpu):
	Start error messages with a lower-case letter.  Do not end error
	messages with a period.  Wrap long messages to 80 character-lines.
	Use "cannot" instead of "can't" and "can not".

gas/testsuite/
	* gas/mips/ase-errors-1.l, gas/mips/ase-errors-2.l,
	gas/mips/ase-errors-3.l, gas/mips/ase-errors-4.l, gas/mips/at-2.l,
	gas/mips/baddata1.l, gas/mips/elf-rel30.l, gas/mips/illegal.l,
	gas/mips/jalr.l, gas/mips/ldstla-32-1.l, gas/mips/ldstla-32-mips3-1.l,
	gas/mips/lui-1.l, gas/mips/macro-warn-1.l, gas/mips/macro-warn-1-n32.l,
	gas/mips/macro-warn-2.l, gas/mips/macro-warn-3.l,
	gas/mips/macro-warn-4.l, gas/mips/micromips-branch-delay.l,
	gas/mips/micromips-branch-relax.l,
	gas/mips/micromips-branch-relax-pic.l, gas/mips/micromips-ill.l,
	gas/mips/micromips.l, gas/mips/micromips-size-0.l,
	gas/mips/micromips-size-1.l, gas/mips/micromips-warn-branch-delay.l,
	gas/mips/micromips-warn.l, gas/mips/mips16e-64.l,
	gas/mips/mips16e-save-err.l, gas/mips/mips1-fp.l,
	gas/mips/mips32r2-fp32.l, gas/mips/mips32r2-ill.l,
	gas/mips/mips32-sf32.l, gas/mips/mips4-branch-likely.l,
	gas/mips/mips4-fp.l, gas/mips/mips5-fp.l, gas/mips/mips64-mips3d.l,
	gas/mips/mips-double-float-flag.l, gas/mips/mips-gp64-fp32.l,
	gas/mips/mips-gp64-fp64.l, gas/mips/mips-hard-float-flag.l,
	gas/mips/mips-macro-ill-nofp.l, gas/mips/mips-macro-ill-sfp.l,
	gas/mips/nan-error-1.l, gas/mips/nan-error-2.l, gas/mips/noat-2.l,
	gas/mips/noat-3.l, gas/mips/noat-4.l, gas/mips/noat-5.l,
	gas/mips/noat-6.l, gas/mips/noat-7.l, gas/mips/octeon-ill.l,
	gas/mips/r5900-error-vu0.l, gas/mips/r5900-nollsc.l,
	gas/mips/relax-bc1any.l, gas/mips/relax-bposge.l, gas/mips/relax.l,
	gas/mips/relax-swap1.l, gas/mips/relax-swap2.l, gas/mips/set-arch.l,
	gas/mips/tls-ill.l, gas/mips/vr5400-ill.l: Adjust expected output.
@
text
@d7094 4
@


1.590
log
@gas/
	* config/tc-mips.c (imm_expr): Expand comment.
	(set_at, macro, mips16_macro): Expect imm_expr to be O_constant
	when populated.
@
text
@d1888 1
a1888 1
	as_warn (_("The %d-bit %s architecture does not support the"
d1891 1
a1891 1
	as_warn (_("The `%s' extension requires %s%d revision %d or greater"),
d1899 1
a1899 1
      as_warn (_("The `%s' extension requires 64-bit FPRs"), ase->name);
d2716 1
a2716 1
	as_warn (_("Unrecognized register name `%s'"), *s);
d2942 1
a2942 1
	      set_insn_error (0, _("Invalid register range"));
d2961 1
a2961 1
	      set_insn_error (0, _("Vector element must be constant"));
d2968 1
a2968 1
	      set_insn_error (0, _("Missing `]'"));
d3284 1
a3284 1
      as_bad (_("Internal error: bad microMIPS opcode (incorrect length: %u): "
d3292 1
a3292 1
      as_bad (_("Internal error: bad microMIPS opcode "
d3323 1
a3323 1
    as_warn (_("Could not set architecture and machine"));
d3338 1
a3338 1
	  as_fatal (_("Broken assembler.  No assembly attempted."));
d3429 1
a3429 1
    as_fatal (_("Broken assembler.  No assembly attempted."));
d4428 1
a4428 1
    as_warn (_("Float register should be even, was %d"), regno);
d4440 1
a4440 1
	as_warn (_("Condition code register should be even for %s, was %d"),
d4445 1
a4445 1
	as_warn (_("Condition code register should be 0 or 4 for %s, was %d"),
d5313 1
a5313 1
    as_bad (_("Can't use floating point insn in this section"));
d5442 1
a5442 1
	as_warn (_("Used $at without \".set noat\""));
d5444 1
a5444 1
	as_warn (_("Used $%u with \".set at=$%u\""), AT, AT);
d6409 1
a6409 1
    as_warn (_("Wrong size instruction in a %u-bit branch delay slot"),
d7089 1
a7089 1
		  (0, _("Source and destination must be different"));
d7092 1
a7092 1
		  (0, _("A destination register must be supplied"));
d7423 1
a7423 1
    (0, _("Opcode not supported on this processor: %s (%s)"),
d7502 1
a7502 1
	set_insn_error (0, _("Opcode not supported in the `insn32' mode"));
d7505 1
a7505 1
	  (0, _("Unrecognized %d-bit version of microMIPS opcode"),
d7589 1
a7589 1
    return _("Macro instruction expanded into multiple instructions"
d7592 1
a7592 1
    return _("Macro instruction expanded into multiple instructions");
d7596 1
a7596 1
	    ? _("Macro instruction expanded into a wrong size instruction"
d7598 1
a7598 1
	    : _("Macro instruction expanded into a wrong size instruction"
d8059 1
a8059 1
	as_bad (_("Macro used $at after \".set noat\""));
d8207 1
a8207 1
      as_bad (_("Number (0x%s) larger than 32 bits"), value);
d8227 1
a8227 1
	as_bad (_("Number larger than 64 bits"));
d8643 1
a8643 1
    as_bad (_("Macro used $at after \".set noat\""));
d9254 1
a9254 1
	  as_warn (_("Branch %s is always true"), ip->insn_mo->name);
d9470 1
a9470 1
	  as_warn (_("Divide by zero."));
d9580 1
a9580 1
	  as_warn (_("Divide by zero."));
d9691 1
a9691 1
	  as_bad (_("Expression too complex"));
d9779 1
a9779 1
		as_bad (_("Offset too large"));
d10301 1
a10301 1
	  as_bad (_("Opcode not supported in the `insn32' mode `%s'"), str);
d10345 1
a10345 1
		as_warn (_("No .cprestore pseudo-op used in PIC code"));
d10350 1
a10350 1
		      as_warn (_("No .frame pseudo-op used in PIC code"));
d10356 1
a10356 1
		      as_warn (_("No .cprestore pseudo-op used in PIC code"));
d10377 1
a10377 1
	  as_bad (_("Opcode not supported in the `insn32' mode `%s'"), str);
d10489 1
a10489 1
		as_warn (_("No .cprestore pseudo-op used in PIC code"));
d10494 1
a10494 1
		      as_warn (_("No .frame pseudo-op used in PIC code"));
d10500 1
a10500 1
		      as_warn (_("No .cprestore pseudo-op used in PIC code"));
d10515 1
a10515 1
	as_bad (_("Non-PIC jump used in PIC library"));
d10923 1
a10923 1
	  as_bad (_("Expression too complex"));
d10933 1
a10933 1
	  as_bad (_("Number (0x%s) larger than 32 bits"), value);
d11578 1
a11578 1
	  as_bad (_("Expression too complex"));
d11588 1
a11588 1
	  as_bad (_("Number (0x%s) larger than 32 bits"), value);
d12142 1
a12142 1
	  as_warn (_("Instruction %s: result is always false"),
d12295 1
a12295 1
	  as_warn (_("Instruction %s: result is always true"),
d12580 1
a12580 1
      as_bad (_("Macro %s not implemented yet"), ip->insn_mo->name);
d12584 1
a12584 1
    as_bad (_("Macro used $at after \".set noat\""));
d12921 1
a12921 1
      set_insn_error (0, _("Unrecognized opcode"));
d12937 1
a12937 1
    set_insn_error (0, _("Illegal operands"));
d12983 1
a12983 1
      set_insn_error (0, _("Unrecognized opcode"));
d12996 1
a12996 1
      set_insn_error (0, _("Unrecognized opcode"));
d13005 1
a13005 1
    set_insn_error (0, _("Illegal operands"));
d13332 1
a13332 1
    as_warn (_("A different %s was already specified, is now %s"),
d13625 1
a13625 1
	as_fatal (_("No compiled in support for 64 bit object file format"));
d13671 1
a13671 1
	    as_fatal (_("No compiled in support for 64 bit object file "
d13718 1
a13718 1
	  as_fatal (_("Invalid NaN setting -mnan=%s"), arg);
d13767 1
a13767 1
	as_bad (_("-G not supported in this configuration."));
d13793 2
a13794 1
	    as_bad (_("-%s conflicts with the other architecture options, which imply -%s"),
d13955 2
a13956 1
		      _("PC relative MIPS16 instruction references a different section"));
d14297 1
a14297 1
			  _("Unsupported constant in relocation"));
d14336 1
a14336 1
		      _("Branch to misaligned address (%lx)"), (long) *valP);
d14380 1
a14380 1
			_("Branch out of range"));
d14478 1
a14478 1
    as_bad (_("Alignment too large: %d. assumed."), temp = max_alignment);
d14481 1
a14481 1
      as_warn (_("Alignment negative: 0 assumed."));
d14777 1
a14777 1
    as_warn (_("Unrecognized option \"%s\""), opt);
d14821 1
a14821 1
	as_bad (_("Unrecognized register name `%s'"), s);
d15040 1
a15040 1
      as_warn (_("Tried to set unrecognized symbol: %s\n"), name);
d15397 1
a15397 1
      as_bad (_("Unsupported use of %s"), dirstr);
d15488 1
a15488 1
      as_bad (_("Unsupported use of .gpword"));
d15526 1
a15526 1
      as_bad (_("Unsupported use of .gpdword"));
d15558 1
a15558 1
      as_bad (_("Unsupported use of .ehword"));
d15633 1
a15633 1
    as_bad (_("Bad .nan directive"));
d16432 2
a16433 1
		    _("Can not represent %s relocation in this object file format"),
d16527 1
a16527 1
			 _("Relaxed out-of-range branch into a jump"));
d16780 1
a16780 1
		     _("Relaxed out-of-range branch into a jump"));
d17447 1
a17447 1
      as_warn (_(".end directive without a preceding .ent directive."));
d17456 1
a17456 1
	as_warn (_(".end symbol does not match .ent symbol."));
d17533 1
a17533 1
    as_warn (_(".ent or .aent not in text section."));
d17589 1
a17589 1
	  as_warn (_("Bad .frame directive"));
d17626 1
a17626 1
	  as_warn (_("Bad .mask/.fmask directive"));
d17897 1
a17897 1
  as_bad (_("Bad value (%s) for %s"), cpu_string, option);
@


1.589
log
@include/opcode/
	* mips.h: Remove references to "+I" and imm2_expr.

gas/
	* config/tc-mips.c (imm2_expr): Delete.
	(md_assemble, match_insn, imm2_expr.X_op, mips_ip): Update accordingly.
@
text
@d1766 1
a1766 1
   mips16_ip.  */
d8070 1
a8070 2
  if (imm_expr.X_op == O_constant
      && imm_expr.X_add_number >= -0x8000
d9085 1
a9085 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= -0x200
d9088 2
a9089 1
	  macro_build (NULL, s, "t,r,.", op[0], op[1], imm_expr.X_add_number);
d9098 1
a9098 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= -0x8000
d9126 1
a9126 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= 0
d9179 1
a9179 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
d9222 1
a9222 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number >= GPR_SMAX)
a9231 2
      if (imm_expr.X_op != O_constant)
	as_bad (_("Unsupported large constant"));
d9238 1
a9238 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
d9244 1
a9244 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
d9250 1
a9250 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number <= GPR_SMIN)
a9285 1
	      && imm_expr.X_op == O_constant
a9287 2
      if (imm_expr.X_op != O_constant)
	as_bad (_("Unsupported large constant"));
d9294 1
a9294 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
d9296 1
a9296 1
      else if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
d9360 1
a9360 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number >= GPR_SMAX)
a9361 2
      if (imm_expr.X_op != O_constant)
	as_bad (_("Unsupported large constant"));
d9368 1
a9368 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
d9370 1
a9370 1
      else if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
a9402 1
	      && imm_expr.X_op == O_constant
a9404 2
      if (imm_expr.X_op != O_constant)
	as_bad (_("Unsupported large constant"));
d9411 1
a9411 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
d9413 1
a9413 1
      else if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
d9578 1
a9578 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
d9587 1
a9587 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
d9595 1
a9595 3
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number == -1
	  && s[strlen (s) - 1] != 'u')
d11312 2
a11313 1
	  gas_assert (offset_expr.X_op == O_symbol
d11328 1
a11328 1
      if (imm_expr.X_op == O_constant || imm_expr.X_op == O_big)
d11362 1
d11407 1
a11407 1
      if (imm_expr.X_op == O_constant || imm_expr.X_op == O_big)
d11431 2
a11432 1
      gas_assert (offset_expr.X_op == O_symbol
a11995 2
	if (imm_expr.X_op != O_constant)
	  as_bad (_("Improper rotate count"));
a12024 2
	if (imm_expr.X_op != O_constant)
	  as_bad (_("Improper rotate count"));
a12075 2
	if (imm_expr.X_op != O_constant)
	  as_bad (_("Improper rotate count"));
a12103 2
	if (imm_expr.X_op != O_constant)
	  as_bad (_("Improper rotate count"));
d12135 1
a12135 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
d12155 1
a12155 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= 0
d12158 1
a12158 2
      else if (imm_expr.X_op == O_constant
	       && imm_expr.X_add_number > -0x8000
d12193 1
a12193 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= -0x8000
d12250 1
a12250 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= -0x8000
d12263 1
a12263 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= -0x8000
d12288 1
a12288 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
d12309 1
a12309 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= 0
d12315 1
a12315 2
      else if (imm_expr.X_op == O_constant
	       && imm_expr.X_add_number > -0x8000
d12352 1
a12352 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number > -0x200
d12355 2
a12356 1
	  macro_build (NULL, s, "t,r,.", op[0], op[1], -imm_expr.X_add_number);
d12365 1
a12365 2
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number > -0x8000
a12682 2
      if (imm_expr.X_op != O_constant)
	as_bad (_("Unsupported large constant"));
a12687 2
      if (imm_expr.X_op != O_constant)
	as_bad (_("Unsupported large constant"));
a12692 2
      if (imm_expr.X_op != O_constant)
	as_bad (_("Unsupported large constant"));
a12797 2
      if (imm_expr.X_op != O_constant)
	as_bad (_("Unsupported large constant"));
@


1.588
log
@include/opcode/
	* mips.h (M_DEXT, M_DINS): Delete.

opcodes/
	* micromips-opc.c (micromips_opcodes): Replace "dext" and "dins"
	macro entries with "dextm", "dextu", "dinsm" and "dinsu" aliases.
	Use +H rather than +C for the real "dext".
	* mips-opc.c (mips_builtin_opcodes): Likewise.

gas/
	* config/tc-mips.c (report_bad_range, report_bad_field): Delete.
	(macro): Remove M_DEXT and M_DINS handling.

gas/testsuite/
	* gas/mips/ext-ill.l, gas/mips/mips64r2-ill.l: Expect DEXT and DINS
	error messages to have the same form as the EXT and INS ones.
	* gas/mips/micromips-insn32.d, gas/mips/micromips-noinsn32.d,
	gas/mips/micromips-trap.d, gas/mips/micromips.d,
	gas/mips/micromips@@mips64r2.d, gas/mips/mips64r2.d: Expect
	"dext" and "dins" instead of "dextm", "dextu", "dinsm" and "dinsu".
@
text
@d1765 2
a1766 2
/* Expressions which appear in macro instructions.  These are set by
   mips_ip and read by macro.  */
a1768 1
static expressionS imm2_expr;
a3585 1
  imm2_expr.X_op = O_absent;
a7024 1
  imm2_expr.X_op = O_absent;
a7128 10
	    case 'I':
	      /* "+I" is like "I", except that imm2_expr is used.  */
	      if (!match_const_int (&arg, &imm2_expr.X_add_number))
		return FALSE;
	      imm2_expr.X_op = O_constant;
	      if (HAVE_32BIT_GPRS)
		normalize_constant_expr (&imm2_expr);
	      ++args;
	      continue;

a7249 1
  imm2_expr.X_op = O_absent;
d12922 4
a12925 5
   is a macro, set imm_expr, imm2_expr and offset_expr to the values
   associated with "I", "+I" and "A" operands respectively.  Otherwise
   store the value of the relocatable field (if any) in offset_expr.
   In both cases set offset_reloc to the relocation operators applied
   to offset_expr.  */
@


1.587
log
@gas/
	* config/tc-mips.c (mips_arg_info): Replace allow_nonconst and
	lax_max with lax_match.
	(match_int_operand): Update accordingly.  Don't report an error
	for !lax_match-only cases.
	(match_insn): Replace more_alts with lax_match and use it to
	initialize the mips_arg_info field.  Add a complete_p parameter.
	Handle implicit VU0 suffixes here.
	(match_invalid_for_isa, match_insns, match_mips16_insns): New
	functions.
	(mips_ip, mips16_ip): Use them.
@
text
@a4213 33
/* Report that user-supplied argument ARGNUM for INSN was VAL, but should
   have been in the range [MIN_VAL, MAX_VAL].  PRINT_HEX says whether
   this operand is normally printed in hex or decimal.  */

static void
report_bad_range (struct mips_cl_insn *insn, int argnum,
		  offsetT val, int min_val, int max_val,
		  bfd_boolean print_hex)
{
  if (print_hex && val >= 0)
    as_bad (_("Operand %d of `%s' must be in the range [0x%x, 0x%x],"
	      " was 0x%lx."),
	    argnum, insn->insn_mo->name, min_val, max_val, (unsigned long) val);
  else if (print_hex)
    as_bad (_("Operand %d of `%s' must be in the range [0x%x, 0x%x],"
	      " was %ld."),
	    argnum, insn->insn_mo->name, min_val, max_val, (unsigned long) val);
  else
    as_bad (_("Operand %d of `%s' must be in the range [%d, %d],"
	      " was %ld."),
	    argnum, insn->insn_mo->name, min_val, max_val, (unsigned long) val);
}

/* Report an invalid combination of position and size operands for a bitfield
   operation.  POS and SIZE are the values that were given.  */

static void
report_bad_field (offsetT pos, offsetT size)
{
  as_bad (_("Invalid field specification (position %ld, size %ld)"),
	  (unsigned long) pos, (unsigned long) size);
}

a9484 96
    case M_DEXT:
      {
	/* Use unsigned arithmetic.  */
	addressT pos;
	addressT size;

	if (imm_expr.X_op != O_constant || imm2_expr.X_op != O_constant)
	  {
	    as_bad (_("Unsupported large constant"));
	    pos = size = 1;
	  }
	else
	  {
	    pos = imm_expr.X_add_number;
	    size = imm2_expr.X_add_number;
	  }

	if (pos > 63)
	  {
	    report_bad_range (ip, 3, pos, 0, 63, FALSE);
	    pos = 1;
	  }
	if (size == 0 || size > 64 || (pos + size - 1) > 63)
	  {
	    report_bad_field (pos, size);
	    size = 1;
	  }

	if (size <= 32 && pos < 32)
	  {
	    s = "dext";
	    fmt = "t,r,+A,+C";
	  }
	else if (size <= 32)
	  {
	    s = "dextu";
	    fmt = "t,r,+E,+H";
	  }
	else
	  {
	    s = "dextm";
	    fmt = "t,r,+A,+G";
	  }
	macro_build ((expressionS *) NULL, s, fmt, op[0], op[1], (int) pos,
		     (int) (size - 1));
      }
      break;

    case M_DINS:
      {
	/* Use unsigned arithmetic.  */
	addressT pos;
	addressT size;

	if (imm_expr.X_op != O_constant || imm2_expr.X_op != O_constant)
	  {
	    as_bad (_("Unsupported large constant"));
	    pos = size = 1;
	  }
	else
	  {
	    pos = imm_expr.X_add_number;
	    size = imm2_expr.X_add_number;
	  }

	if (pos > 63)
	  {
	    report_bad_range (ip, 3, pos, 0, 63, FALSE);
	    pos = 1;
	  }
	if (size == 0 || size > 64 || (pos + size - 1) > 63)
	  {
	    report_bad_field (pos, size);
	    size = 1;
	  }

	if (pos < 32 && (pos + size - 1) < 32)
	  {
	    s = "dins";
	    fmt = "t,r,+A,+B";
	  }
	else if (pos >= 32)
	  {
	    s = "dinsu";
	    fmt = "t,r,+E,+F";
	  }
	else
	  {
	    s = "dinsm";
	    fmt = "t,r,+A,+F";
	  }
	macro_build ((expressionS *) NULL, s, fmt, op[0], op[1], (int) pos,
		     (int) (pos + size - 1));
      }
      break;

@


1.586
log
@gas/
	* config/tc-mips.c (match_expression):  Report uses of registers here.
	Add a "must be an immediate expression" error.  Handle elided offsets
	here rather than...
	(match_int_operand): ...here.

gas/testsuite/
	* gas/mips/octeon-ill.l: Adjust expected output.
	* gas/mips/lui-1.l, gas/mips/lui-1.s: Add more cases.
@
text
@d4274 5
a4278 8
  /* If true, the OP_INT match routine should treat plain symbolic operands
     as if a relocation operator like %lo(...) had been used.  This is only
     ever true if the operand can be relocated.  */
  bfd_boolean allow_nonconst;

  /* When true, the OP_INT match routine should allow unsigned N-bit
     arguments to be used where a signed N-bit operand is expected.  */
  bfd_boolean lax_max;
a4558 2
  if (arg->lax_max)
    max_val = ((1 << operand_base->size) - 1) << operand->shift;
d4578 4
a4581 7
	  /* If non-constant operands are allowed then leave them for
	     the caller to process, otherwise fail the match.  */
	  if (!arg->allow_nonconst)
	    {
	      match_not_constant (arg);
	      return FALSE;
	    }
d4590 10
d7052 1
a7052 1
	    bfd_boolean more_alts)
d7067 5
a7071 1
  insn->insn_opcode |= opcode_extra;
d7078 1
d7117 2
a7159 1
      arg.lax_max = FALSE;
a7229 26
	  /* ??? This is the traditional behavior, but is flaky if
	     there are alternative versions of the same instruction
	     for different subarchitectures.  The next alternative
	     might not be suitable.  */
	case 'j':
	  /* For compatibility with older assemblers, we accept
	     0x8000-0xffff as signed 16-bit numbers when only
	     signed numbers are allowed.  */
	  arg.lax_max = !more_alts;
	case 'i':
	  /* Only accept non-constant operands if this is the
	     final alternative.  Later alternatives might include
	     a macro implementation.  */
	  arg.allow_nonconst = !more_alts;
	  break;

	case 'u':
	  /* There are no macro implementations for out-of-range values.  */
	  arg.allow_nonconst = TRUE;
	  break;

	case 'o':
	  /* There should always be a macro implementation.  */
	  arg.allow_nonconst = FALSE;
	  break;

d7464 135
d13072 1
a13072 1
mips_ip (char *str, struct mips_cl_insn *ip)
d13074 1
a13074 4
  bfd_boolean wrong_delay_slot_insns = FALSE;
  bfd_boolean need_delay_slot_ok = TRUE;
  struct mips_opcode *firstinsn = NULL;
  const struct mips_opcode *past;
a13075 1
  struct mips_opcode *first, *insn;
a13091 1
  insn = NULL;
d13098 2
a13099 2
  first = insn = mips_lookup_insn (hash, str, end, &opcode_extra);
  if (insn == NULL)
a13103 3
  /* When no opcode suffix is specified, assume ".xyzw". */
  if ((insn->pinfo2 & INSN2_VU0_CHANNEL_SUFFIX) != 0 && opcode_extra == 0)
    opcode_extra = 0xf << mips_vu0_channel_mask.lsb;
d13105 1
a13105 1
  if (strcmp (insn->name, "li.s") == 0)
d13107 1
a13107 1
  else if (strcmp (insn->name, "li.d") == 0)
d13115 3
a13117 40
  /* For microMIPS instructions placed in a fixed-length branch delay slot
     we make up to two passes over the relevant fragment of the opcode
     table.  First we try instructions that meet the delay slot's length
     requirement.  If none matched, then we retry with the remaining ones
     and if one matches, then we use it and then issue an appropriate
     warning later on.  */
  for (;;)
    {
      bfd_boolean delay_slot_ok;
      bfd_boolean size_ok;
      bfd_boolean ok;
      bfd_boolean more_alts;

      gas_assert (strcmp (insn->name, first->name) == 0);

      ok = is_opcode_valid (insn);
      size_ok = is_size_valid (insn);
      delay_slot_ok = is_delay_slot_valid (insn);
      if (!delay_slot_ok && !wrong_delay_slot_insns)
	{
	  firstinsn = insn;
	  wrong_delay_slot_insns = TRUE;
	}
      more_alts = (insn + 1 < past
		   && strcmp (insn[0].name, insn[1].name) == 0);
      if (!ok || !size_ok || delay_slot_ok != need_delay_slot_ok)
	{
	  if (more_alts)
	    {
	      ++insn;
	      continue;
	    }
	  if (wrong_delay_slot_insns && need_delay_slot_ok)
	    {
	      gas_assert (firstinsn);
	      need_delay_slot_ok = FALSE;
	      past = insn + 1;
	      insn = firstinsn;
	      continue;
	    }
a13118 37
	  if (!ok)
	    set_insn_error_ss
	      (0, _("Opcode not supported on this processor: %s (%s)"),
	       mips_cpu_info_from_arch (mips_opts.arch)->name,
	       mips_cpu_info_from_isa (mips_opts.isa)->name);
	  else if (mips_opts.insn32)
	    set_insn_error
	      (0, _("Opcode not supported in the `insn32' mode"));
	  else
	    set_insn_error_i
	      (0, _("Unrecognized %d-bit version of microMIPS opcode"),
	       8 * forced_insn_length);
	  break;
	}

      if (match_insn (ip, insn, tokens, opcode_extra,
		      more_alts || (wrong_delay_slot_insns
				    && need_delay_slot_ok)))
	break;

      /* Args don't match.  */
      set_insn_error (0, _("Illegal operands"));
      if (more_alts)
	{
	  ++insn;
	  continue;
	}
      if (wrong_delay_slot_insns && need_delay_slot_ok)
	{
	  gas_assert (firstinsn);
	  need_delay_slot_ok = FALSE;
	  past = insn + 1;
	  insn = firstinsn;
	  continue;
	}
      break;
    }
d13127 1
a13127 1
mips16_ip (char *str, struct mips_cl_insn *ip)
d13130 1
a13130 1
  struct mips_opcode *insn, *first;
d13171 1
a13171 1
  first = insn = (struct mips_opcode *) hash_find (mips16_op_hash, str);
d13174 1
a13174 1
  if (!insn)
d13184 2
a13185 29
  for (;;)
    {
      bfd_boolean ok;
      bfd_boolean more_alts;

      gas_assert (strcmp (insn->name, first->name) == 0);

      ok = is_opcode_valid_16 (insn);
      more_alts = (insn + 1 < &mips16_opcodes[bfd_mips16_num_opcodes]
		   && strcmp (insn[0].name, insn[1].name) == 0);
      if (! ok)
	{
	  if (more_alts)
	    {
	      ++insn;
	      continue;
	    }
	  else
	    {
	      set_insn_error_ss
		(0, _("Opcode not supported on this processor: %s (%s)"),
		 mips_cpu_info_from_arch (mips_opts.arch)->name,
		 mips_cpu_info_from_isa (mips_opts.isa)->name);
	      break;
	    }
	}

      if (match_mips16_insn (ip, insn, tokens))
	break;
a13186 9
      /* Args don't match.  */
      set_insn_error (0, _("Illegal operands"));
      if (more_alts)
	{
	  ++insn;
	  continue;
	}
      break;
    }
@


1.585
log
@gas/
	* config/tc-mips.c (mips_arg_info): Remove soft_match.
	(match_out_of_range, match_not_constant): New functions.
	(match_const_int): Remove fallback parameter and check for soft_match.
	Use match_not_constant.
	(match_mapped_int_operand, match_addiusp_operand)
	(match_perf_reg_operand, match_save_restore_list_operand)
	(match_mdmx_imm_reg_operand): Update accordingly.  Use
	match_out_of_range and set_insn_error* instead of as_bad.
	(match_int_operand): Likewise.  Use match_not_constant in the
	!allows_nonconst case.
	(match_float_constant): Report invalid float constants.
	(match_insn, match_mips16_insn): Remove soft_match code.  Rely on
	match_float_constant to check for invalid constants.  Fail the
	match if match_const_int or match_float_constant return false.
	(mips_ip): Update accordingly.
	(mips16_ip): Likewise.  Undo null termination of instruction name
	once lookup is complete.

gas/testsuite/
	* gas/mips/ext-ill.l, gas/mips/lui-1.l, gas/mips/mips16e-64.l,
	gas/mips/mips32r2-ill-fp64.l, gas/mips/mips32r2-ill-nofp.l,
	gas/mips/mips32r2-ill.l, gas/mips/mips64r2-ill.l,
	gas/mips/octeon-ill.l, gas/mips/r5900-error-vu0.l,
	gas/mips/vr5400-ill.l: Adjust expected errors.
	* gas/mips/micromips-size-0.l,
	gas/mips/micromips-size-0.s: Likewise.  Add new tests.
	* gas/mips/mips16e-save-err.s, gas/mips/mips16e-save-err.l: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d4328 4
a4331 1
  if (arg->token->type == OT_INTEGER)
d4333 3
a4335 3
      *value = arg->token->u.integer.value;
      memcpy (r, arg->token->u.integer.relocs, 3 * sizeof (*r));
      ++arg->token;
d4339 4
a4342 4
  /* Error-reporting is more consistent if we treat registers as O_register
     rather than rejecting them outright.  "$1", "($1)" and "(($1))" are
     then handled in the same way.  */
  if (arg->token->type == OT_REG)
d4344 2
a4345 2
      value->X_add_number = arg->token->u.regno;
      ++arg->token;
d4347 2
a4348 5
  else if (arg->token[0].type == OT_CHAR
	   && arg->token[0].u.ch == '('
	   && arg->token[1].type == OT_REG
	   && arg->token[2].type == OT_CHAR
	   && arg->token[2].u.ch == ')')
d4350 4
a4353 2
      value->X_add_number = arg->token[1].u.regno;
      arg->token += 3;
a4354 2
  else
    return FALSE;
d4356 4
a4359 3
  value->X_op = O_register;
  r[0] = r[1] = r[2] = BFD_RELOC_UNUSED;
  return TRUE;
d4565 5
a4569 9
  if (arg->token->type == OT_CHAR && arg->token->u.ch == '(')
    /* Assume we have an elided offset.  The later match will fail
       if this turns out to be wrong.  */
    sval = 0;
  else if (operand_base->lsb == 0
	   && operand_base->size == 16
	   && operand->shift == 0
	   && operand->bias == 0
	   && (operand->max_val == 32767 || operand->max_val == 65535))
@


1.584
log
@gas/
	* config/tc-mips.c (mips_insn_error_format): New enum.
	(mips_insn_error): New struct.
	(insn_error): Change to a mips_insn_error.
	(clear_insn_error, set_insn_error_format, set_insn_error)
	(set_insn_error_i, set_insn_error_ss, report_insn_error): New
	functions.
	(mips_parse_argument_token, md_assemble, match_insn)
	(match_mips16_insn): Use them instead of manipulating insn_error
	directly.
	(mips_ip, mips16_ip): Likewise.  Simplify control flow.

gas/testsuite/
	* gas/mips/micromips-ill.l: Expect "floating-point expression required"
@
text
@a4273 7
  /* If true, match routines should silently reject invalid arguments.
     If false, match routines can accept invalid arguments as long as
     they report an appropriate error.  They still have the option of
     silently rejecting arguments, in which case a generic "Invalid operands"
     style of error will be used instead.  */
  bfd_boolean soft_match;

d4287 17
d4367 1
a4367 1
match_const_int (struct mips_arg_info *arg, offsetT *value, offsetT fallback)
d4379 2
a4380 5
      if (arg->soft_match)
	return FALSE;
      as_bad (_("Operand %d of `%s' must be constant"),
	      arg->argnum, arg->insn->insn_mo->name);
      *value = fallback;
a4555 1
  bfd_boolean print_hex;
d4589 4
a4592 1
	    return FALSE;
d4604 1
a4604 1
      if (!match_const_int (arg, &sval, min_val))
d4610 1
a4610 9
  /* Check the range.  If there's a problem, record the lowest acceptable
     value in arg->last_op_int in order to prevent an unhelpful error
     from OP_MSB too.

     Bit counts have traditionally been printed in hex by the disassembler
     but printed as decimal in error messages.  Only resort to hex if
     the operand is bigger than 6 bits.  */
  print_hex = operand->print_hex && operand_base->size > 6;
  if (sval < min_val || sval > max_val)
d4612 2
a4613 16
      if (arg->soft_match)
	return FALSE;
      report_bad_range (arg->insn, arg->argnum, sval, min_val, max_val,
			print_hex);
      arg->last_op_int = min_val;
    }
  else if (sval % factor)
    {
      if (arg->soft_match)
	return FALSE;
      as_bad (print_hex && sval >= 0
	      ? _("Operand %d of `%s' must be a factor of %d, was 0x%lx.")
	      : _("Operand %d of `%s' must be a factor of %d, was %ld."),
	      arg->argnum, arg->insn->insn_mo->name, factor,
	      (unsigned long) sval);
      arg->last_op_int = min_val;
d4658 1
a4658 1
  if (!match_const_int (arg, &sval, operand->int_map[0]))
d4666 4
a4669 1
    return FALSE;
d4690 1
a4690 1
  if (!match_const_int (arg, &size, 1))
d4698 2
a4699 4
      if (arg->soft_match)
	return FALSE;
      report_bad_field (arg->last_op_int, size);
      sval = min_val;
d4781 1
a4781 1
  if (!match_const_int (arg, &sval, 0))
d4790 2
a4791 3
      if (arg->soft_match)
	return FALSE;
      as_bad (_("Invalid performance register (%ld)"), (unsigned long) sval);
d4807 1
a4807 1
  if (!match_const_int (arg, &sval, -256))
d4811 4
a4814 1
    return FALSE;
d4818 4
a4821 1
    return FALSE;
a4964 1
  const char *error;
a4965 1
  error = 0;
d4979 1
a4979 1
	  if (!match_const_int (arg, &frame_size, 0))
d5073 15
a5087 6
    error = _("Missing frame size");
  else if (num_frame_sizes > 1)
    error = _("Frame size specified twice");
  else if ((frame_size & 7) != 0 || frame_size < 0 || frame_size > 0xff * 8)
    error = _("Invalid frame size");
  else if (frame_size != 128 || (opcode >> 16) != 0)
a5093 7
  if (error)
    {
      if (arg->soft_match)
	return FALSE;
      as_bad ("%s", error);
    }

d5122 3
a5124 4
	  if (arg->soft_match)
	    return FALSE;
	  as_bad (_("Operand %d of `%s' must be an immediate"),
		  arg->argnum, opcode->name);
d5136 2
a5137 3
	      if (arg->soft_match)
		return FALSE;
	      as_bad (_("Invalid element selector"));
d5149 3
a5151 4
	      if (arg->soft_match)
		return FALSE;
	      as_bad (_("Operand %d of `%s' must be scalar"),
		      arg->argnum, opcode->name);
d5168 1
a5168 1
      if (!match_const_int (arg, &sval, 0))
d5172 2
a5173 3
	  if (arg->soft_match)
	    return FALSE;
	  report_bad_range (arg->insn, arg->argnum, sval, 0, 31, FALSE);
d5251 4
a5254 1
    return FALSE;
d7053 1
a7053 1
	    bfd_boolean more_alts, bfd_boolean soft_match)
a7074 1
  arg.soft_match = soft_match;
a7159 20
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case 'B':
	    case 'C':
	    case 'F':
	    case 'G':
	    case 'H':
	    case 'J':
	    case 'Q':
	    case 'S':
	    case 's':
	      /* If these integer forms come last, there is no other
		 form of the instruction that could match.  Prefer to
		 give detailed error messages where possible.  */
	      if (args[2] == 0)
		arg.soft_match = FALSE;
	      break;

d7162 3
a7164 4
	      if (match_const_int (&arg, &imm2_expr.X_add_number, 0))
		imm2_expr.X_op = O_constant;
	      else
		set_insn_error (arg.argnum, _("absolute expression required"));
a7175 32
	case '\'':
	case ':':
	case '@@':
	case '^':
	case '$':
	case '\\':
	case '%':
	case '|':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '8':
	case 'B':
	case 'C':
	case 'J':
	case 'O':
	case 'P':
	case 'Q':
	case 'c':
	case 'h':
	case 'q':
	  /* If these integer forms come last, there is no other
	     form of the instruction that could match.  Prefer to
	     give detailed error messages where possible.  */
	  if (args[1] == 0)
	    arg.soft_match = FALSE;
	  break;

d7177 3
a7179 4
	  if (match_const_int (&arg, &imm_expr.X_add_number, 0))
	    imm_expr.X_op = O_constant;
	  else
	    set_insn_error (arg.argnum, _("absolute expression required"));
a7192 2
	  else if (match_expression (&arg, &offset_expr, offset_reloc))
	    normalize_address_expr (&offset_expr);
d7194 5
a7198 1
	    set_insn_error (arg.argnum, _("absolute expression required"));
d7204 1
a7204 2
	    set_insn_error (arg.argnum,
			    _("floating-point expression required"));
d7210 1
a7210 2
	    set_insn_error (arg.argnum,
			    _("floating-point expression required"));
d7216 1
a7216 2
	    set_insn_error (arg.argnum,
			    _("floating-point expression required"));
d7222 1
a7222 2
	    set_insn_error (arg.argnum,
			    _("floating-point expression required"));
d7307 1
a7307 1
		   struct mips_operand_token *tokens, bfd_boolean soft_match)
a7329 1
  arg.soft_match = soft_match;
d7414 3
a7416 4
	  if (match_const_int (&arg, &imm_expr.X_add_number, 0))
	    imm_expr.X_op = O_constant;
	  else
	    set_insn_error (arg.argnum, _("absolute expression required"));
d13065 1
a13065 1
      if (match_insn (ip, insn, tokens, opcode_extra, more_alts,
d13097 2
a13098 2
  char *s;
  struct mips_opcode *insn;
d13105 3
a13107 1
  switch (*s)
d13113 1
a13113 1
      *s++ = '\0';
a13118 1
	  *s = '\0';
a13124 1
	  *s = '\0';
d13138 5
a13142 1
  if ((insn = (struct mips_opcode *) hash_find (mips16_op_hash, str)) == NULL)
d13157 1
a13157 1
      gas_assert (strcmp (insn->name, str) == 0);
d13179 1
a13179 1
      if (match_mips16_insn (ip, insn, tokens, more_alts))
@


1.583
log
@gas/
	* config/tc-mips.c (normalize_constant_expr): Move further up file.
	(normalize_address_expr): Likewise.
	(match_insn, match_mips16_insn): New functions, split out from...
	(mips_ip, mips16_ip): ...here.
@
text
@d633 37
a669 1
static char *insn_error;
d2196 105
d2943 1
a2943 1
	      insn_error = _("Invalid register range");
d2962 1
a2962 1
	      insn_error = _("Vector element must be constant");
d2969 1
a2969 1
	      insn_error = _("Missing `]'");
d2997 1
a2997 1
	  insn_error = err;
d3595 1
d3606 2
a3607 2
  if (insn_error)
    as_bad ("%s `%s'", insn_error, str);
a7076 1
  insn_error = NULL;
d7122 1
d7127 2
a7128 1
		as_bad (_("Source and destination must be different"));
d7130 2
a7131 1
		as_bad (_("A destination register must be supplied"));
d7194 1
a7194 1
		insn_error = _("absolute expression required");
d7242 1
a7242 1
	    insn_error = _("absolute expression required");
d7259 1
a7259 1
	    insn_error = _("absolute expression required");
d7265 2
a7266 1
	    insn_error = _("floating-point expression required");
d7272 2
a7273 1
	    insn_error = _("floating-point expression required");
d7279 2
a7280 1
	    insn_error = _("floating-point expression required");
d7286 2
a7287 1
	    insn_error = _("floating-point expression required");
d7424 1
d7444 1
a7444 1
		as_bad (_("invalid unextended operand value"));
d7483 1
a7483 1
	    insn_error = _("absolute expression required");
a13037 2
  insn_error = NULL;

d13059 1
a13059 1
      insn_error = _("Unrecognized opcode");
a13102 2
	  static char buf[256];

a13116 4
	  obstack_free (&mips_operand_tokens, tokens);
	  if (insn_error)
	    return;

d13118 4
a13121 3
	    sprintf (buf, _("Opcode not supported on this processor: %s (%s)"),
		     mips_cpu_info_from_arch (mips_opts.arch)->name,
		     mips_cpu_info_from_isa (mips_opts.isa)->name);
d13123 2
a13124 1
	    sprintf (buf, _("Opcode not supported in the `insn32' mode"));
d13126 4
a13129 5
	    sprintf (buf, _("Unrecognized %u-bit version of microMIPS opcode"),
		     8 * forced_insn_length);
	  insn_error = buf;

	  return;
d13135 1
a13135 4
	{
	  obstack_free (&mips_operand_tokens, tokens);
	  return;
	}
d13138 1
a13138 1
      insn_error = _("Illegal operands");
d13152 1
a13152 2
      obstack_free (&mips_operand_tokens, tokens);
      return;
d13154 1
a13167 2
  insn_error = NULL;

d13198 1
a13198 1
      insn_error = _("unknown opcode");
d13207 1
a13207 1
      insn_error = _("unrecognized opcode");
d13234 5
a13238 11
	      if (!insn_error)
		{
		  static char buf[100];
		  sprintf (buf,
			   _("Opcode not supported on this processor: %s (%s)"),
			   mips_cpu_info_from_arch (mips_opts.arch)->name,
			   mips_cpu_info_from_isa (mips_opts.isa)->name);
		  insn_error = buf;
		}
	      obstack_free (&mips_operand_tokens, tokens);
	      return;
d13243 1
a13243 4
	{
	  obstack_free (&mips_operand_tokens, tokens);
	  return;
	}
d13246 1
d13252 1
a13252 5

      insn_error = _("illegal operands");

      obstack_free (&mips_operand_tokens, tokens);
      return;
d13254 1
@


1.582
log
@include/opcode/
	* mips.h (OP_OPTIONAL_REG): New mips_operand_type.
	(mips_optional_operand_p): New function.

opcodes/
	* mips-formats.h (OPTIONAL_REG, OPTIONAL_MAPPED_REG): New macros.
	* micromips-opc.c (decode_micromips_operand): Use OPTIONAL_REG
	and OPTIONAL_MAPPED_REG.
	* mips-opc.c (decode_mips_operand): Likewise.
	* mips16-opc.c (decode_mips16_operand): Likewise.
	* mips-dis.c (print_insn_arg): Handle OP_OPTIONAL_REG.

gas/
	* config/tc-mips.c (operand_reg_mask, match_operand): Handle
	OP_OPTIONAL_REG.
	(mips_ip, mips16_ip): Use mips_optional_operand_p to check
	for optional operands.
@
text
@d6883 520
a7817 27
 * Sign-extend 32-bit mode constants that have bit 31 set and all
 * higher bits unset.
 */
static void
normalize_constant_expr (expressionS *ex)
{
  if (ex->X_op == O_constant
      && IS_ZEXT_32BIT_NUM (ex->X_add_number))
    ex->X_add_number = (((ex->X_add_number & 0xffffffff) ^ 0x80000000)
			- 0x80000000);
}

/*
 * Sign-extend 32-bit mode address offsets that have bit 31 set and
 * all higher bits unset.
 */
static void
normalize_address_expr (expressionS *ex)
{
  if (((ex->X_op == O_constant && HAVE_32BIT_ADDRESSES)
	|| (ex->X_op == O_symbol && HAVE_32BIT_SYMBOLS))
      && IS_ZEXT_32BIT_NUM (ex->X_add_number))
    ex->X_add_number = (((ex->X_add_number & 0xffffffff) ^ 0x80000000)
			- 0x80000000);
}

/*
a12882 2
  const char *args;
  char c = 0;
a12885 2
  const struct mips_operand *operand;
  struct mips_arg_info arg;
d12990 7
a12996 199
      imm_expr.X_op = O_absent;
      imm2_expr.X_op = O_absent;
      offset_expr.X_op = O_absent;
      offset_reloc[0] = BFD_RELOC_UNUSED;
      offset_reloc[1] = BFD_RELOC_UNUSED;
      offset_reloc[2] = BFD_RELOC_UNUSED;

      create_insn (ip, insn);
      ip->insn_opcode |= opcode_extra;
      insn_error = NULL;
      memset (&arg, 0, sizeof (arg));
      arg.insn = ip;
      arg.token = tokens;
      arg.argnum = 1;
      arg.last_regno = ILLEGAL_REG;
      arg.dest_regno = ILLEGAL_REG;
      arg.soft_match = (more_alts
			|| (wrong_delay_slot_insns && need_delay_slot_ok));
      for (args = insn->args;; ++args)
	{
	  if (arg.token->type == OT_END)
	    {
	      /* Handle unary instructions in which only one operand is given.
		 The source is then the same as the destination.  */
	      if (arg.opnum == 1 && *args == ',')
		{
		  operand = (mips_opts.micromips
			     ? decode_micromips_operand (args + 1)
			     : decode_mips_operand (args + 1));
		  if (operand && mips_optional_operand_p (operand))
		    {
		      arg.token = tokens;
		      arg.argnum = 1;
		      continue;
		    }
		}

	      /* Treat elided base registers as $0.  */
	      if (strcmp (args, "(b)") == 0)
		args += 3;

	      if (args[0] == '+')
	        switch (args[1])
		  {
		    case 'K':
		    case 'N':
		      /* The register suffix is optional. */
		      args += 2;
		      break;
		  }

	      /* Fail the match if there were too few operands.  */
	      if (*args)
		break;

	      /* Successful match.  */
	      if (arg.dest_regno == arg.last_regno
		  && strncmp (ip->insn_mo->name, "jalr", 4) == 0)
		{
		  if (arg.opnum == 2)
		    as_bad (_("Source and destination must be different"));
		  else if (arg.last_regno == 31)
		    as_bad (_("A destination register must be supplied"));
		}
	      check_completed_insn (&arg);
	      obstack_free (&mips_operand_tokens, tokens);
	      return;
	    }

	  /* Fail the match if the line has too many operands.   */
	  if (*args == 0)
	    break;

	  /* Handle characters that need to match exactly.  */
	  if (*args == '(' || *args == ')' || *args == ',')
	    {
	      if (match_char (&arg, *args))
 		continue;
 	      break;
	    }
	  if (*args == '#')
	    {
	      ++args;
	      if (arg.token->type == OT_DOUBLE_CHAR
		  && arg.token->u.ch == *args)
		{
		  ++arg.token;
		  continue;
		}
 	      break;
	    }

	  /* Handle special macro operands.  Work out the properties of
	     other operands.  */
	  arg.opnum += 1;
	  arg.lax_max = FALSE;
	  switch (*args)
	    {
	    case '+':
	      switch (args[1])
		{
		case '1':
		case '2':
		case '3':
		case '4':
		case 'B':
		case 'C':
		case 'F':
		case 'G':
		case 'H':
		case 'J':
		case 'Q':
		case 'S':
		case 's':
		  /* If these integer forms come last, there is no other
		     form of the instruction that could match.  Prefer to
		     give detailed error messages where possible.  */
		  if (args[2] == 0)
		    arg.soft_match = FALSE;
		  break;

		case 'I':
		  /* "+I" is like "I", except that imm2_expr is used.  */
		  if (match_const_int (&arg, &imm2_expr.X_add_number, 0))
		    imm2_expr.X_op = O_constant;
		  else
		    insn_error = _("absolute expression required");
		  if (HAVE_32BIT_GPRS)
		    normalize_constant_expr (&imm2_expr);
		  ++args;
		  continue;

		case 'i':
		  *offset_reloc = BFD_RELOC_MIPS_JMP;
		  break;
		}
	      break;

	    case '\'':
	    case ':':
	    case '@@':
	    case '^':
	    case '$':
	    case '\\':
	    case '%':
	    case '|':
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '8':
	    case 'B':
	    case 'C':
	    case 'J':
	    case 'O':
	    case 'P':
	    case 'Q':
	    case 'c':
	    case 'h':
	    case 'q':
	      /* If these integer forms come last, there is no other
		 form of the instruction that could match.  Prefer to
		 give detailed error messages where possible.  */
	      if (args[1] == 0)
		arg.soft_match = FALSE;
	      break;

	    case 'I':
	      if (match_const_int (&arg, &imm_expr.X_add_number, 0))
		imm_expr.X_op = O_constant;
	      else
		insn_error = _("absolute expression required");
	      if (HAVE_32BIT_GPRS)
		normalize_constant_expr (&imm_expr);
	      continue;

	    case 'A':
	      if (arg.token->type == OT_CHAR && arg.token->u.ch == '(')
		{
		  /* Assume that the offset has been elided and that what
		     we saw was a base register.  The match will fail later
		     if that assumption turns out to be wrong.  */
		  offset_expr.X_op = O_constant;
		  offset_expr.X_add_number = 0;
		}
	      else if (match_expression (&arg, &offset_expr, offset_reloc))
		normalize_address_expr (&offset_expr);
	      else
		insn_error = _("absolute expression required");
	      continue;

	    case 'F':
	      if (!match_float_constant (&arg, &imm_expr, &offset_expr,
					 8, TRUE))
		insn_error = _("floating-point expression required");
	      continue;
a12997 96
	    case 'L':
	      if (!match_float_constant (&arg, &imm_expr, &offset_expr,
					 8, FALSE))
		insn_error = _("floating-point expression required");
	      continue;

	    case 'f':
	      if (!match_float_constant (&arg, &imm_expr, &offset_expr,
					 4, TRUE))
		insn_error = _("floating-point expression required");
	      continue;

	    case 'l':
	      if (!match_float_constant (&arg, &imm_expr, &offset_expr,
					 4, FALSE))
		insn_error = _("floating-point expression required");
	      continue;

	      /* ??? This is the traditional behavior, but is flaky if
		 there are alternative versions of the same instruction
		 for different subarchitectures.  The next alternative
		 might not be suitable.  */
	    case 'j':
	      /* For compatibility with older assemblers, we accept
		 0x8000-0xffff as signed 16-bit numbers when only
		 signed numbers are allowed.  */
	      arg.lax_max = !more_alts;
	    case 'i':
	      /* Only accept non-constant operands if this is the
		 final alternative.  Later alternatives might include
		 a macro implementation.  */
	      arg.allow_nonconst = !more_alts;
	      break;

	    case 'u':
	      /* There are no macro implementations for out-of-range values.  */
	      arg.allow_nonconst = TRUE;
	      break;

	    case 'o':
	      /* There should always be a macro implementation.  */
	      arg.allow_nonconst = FALSE;
	      break;

	    case 'p':
	      *offset_reloc = BFD_RELOC_16_PCREL_S2;
	      break;

	    case 'a':
	      *offset_reloc = BFD_RELOC_MIPS_JMP;
	      break;

	    case 'm':
	      gas_assert (mips_opts.micromips);
	      c = args[1];
	      switch (c)
		{
		case 'D':
		case 'E':
		  if (!forced_insn_length)
		    *offset_reloc = (int) BFD_RELOC_UNUSED + c;
		  else if (c == 'D')
		    *offset_reloc = BFD_RELOC_MICROMIPS_10_PCREL_S1;
		  else
		    *offset_reloc = BFD_RELOC_MICROMIPS_7_PCREL_S1;
		  break;
		}
	      break;
	    }

	  operand = (mips_opts.micromips
		     ? decode_micromips_operand (args)
		     : decode_mips_operand (args));
	  if (!operand)
	    abort ();

	  /* Skip prefixes.  */
	  if (*args == '+' || *args == 'm')
	    args++;

	  if (mips_optional_operand_p (operand)
	      && args[1] == ','
	      && (arg.token[0].type != OT_REG
		  || arg.token[1].type == OT_END))
	    {
	      /* Assume that the register has been elided and is the
		 same as the first operand.  */
	      arg.token = tokens;
	      arg.argnum = 1;
	    }

	  if (!match_operand (&arg, operand))
	    break;

	  continue;
	}
a13025 1
  const char *args;
a13026 3
  const struct mips_operand *operand;
  const struct mips_operand *ext_operand;
  struct mips_arg_info arg;
a13081 1
      char relax_char;
d13111 4
a13114 170
      create_insn (ip, insn);
      imm_expr.X_op = O_absent;
      imm2_expr.X_op = O_absent;
      offset_expr.X_op = O_absent;
      offset_reloc[0] = BFD_RELOC_UNUSED;
      offset_reloc[1] = BFD_RELOC_UNUSED;
      offset_reloc[2] = BFD_RELOC_UNUSED;
      relax_char = 0;

      memset (&arg, 0, sizeof (arg));
      arg.insn = ip;
      arg.token = tokens;
      arg.argnum = 1;
      arg.last_regno = ILLEGAL_REG;
      arg.dest_regno = ILLEGAL_REG;
      arg.soft_match = more_alts;
      relax_char = 0;
      for (args = insn->args; 1; ++args)
	{
	  int c;

	  if (arg.token->type == OT_END)
	    {
	      offsetT value;

	      /* Handle unary instructions in which only one operand is given.
		 The source is then the same as the destination.  */
	      if (arg.opnum == 1 && *args == ',')
		{
		  operand = decode_mips16_operand (args[1], FALSE);
		  if (operand && mips_optional_operand_p (operand))
		    {
		      arg.token = tokens;
		      arg.argnum = 1;
		      continue;
		    }
		}

	      /* Fail the match if there were too few operands.  */
	      if (*args)
		break;

	      /* Successful match.  Stuff the immediate value in now, if
		 we can.  */
	      if (insn->pinfo == INSN_MACRO)
		{
		  gas_assert (relax_char == 0 || relax_char == 'p');
		  gas_assert (*offset_reloc == BFD_RELOC_UNUSED);
		}
	      else if (relax_char
		       && offset_expr.X_op == O_constant
		       && calculate_reloc (*offset_reloc,
					   offset_expr.X_add_number,
					   &value))
		{
		  mips16_immed (NULL, 0, relax_char, *offset_reloc, value,
				forced_insn_length, &ip->insn_opcode);
		  offset_expr.X_op = O_absent;
		  *offset_reloc = BFD_RELOC_UNUSED;
		}
	      else if (relax_char && *offset_reloc != BFD_RELOC_UNUSED)
		{
		  if (forced_insn_length == 2)
		    as_bad (_("invalid unextended operand value"));
		  forced_insn_length = 4;
		  ip->insn_opcode |= MIPS16_EXTEND;
		}
	      else if (relax_char)
		*offset_reloc = (int) BFD_RELOC_UNUSED + relax_char;

	      check_completed_insn (&arg);
	      obstack_free (&mips_operand_tokens, tokens);
	      return;
	    }

	  /* Fail the match if the line has too many operands.   */
	  if (*args == 0)
	    break;

	  /* Handle characters that need to match exactly.  */
	  if (*args == '(' || *args == ')' || *args == ',')
	    {
	      if (match_char (&arg, *args))
 		continue;
 	      break;
	    }

	  arg.opnum += 1;
	  c = *args;
	  switch (c)
	    {
	    case 'p':
	    case 'q':
	    case 'A':
	    case 'B':
	    case 'E':
	      relax_char = c;
	      break;

	    case 'I':
	      if (match_const_int (&arg, &imm_expr.X_add_number, 0))
		imm_expr.X_op = O_constant;
	      else
		insn_error = _("absolute expression required");
	      if (HAVE_32BIT_GPRS)
		normalize_constant_expr (&imm_expr);
	      continue;

	    case 'a':
	    case 'i':
	      *offset_reloc = BFD_RELOC_MIPS16_JMP;
	      ip->insn_opcode <<= 16;
	      break;
	    }

	  operand = decode_mips16_operand (c, FALSE);
	  if (!operand)
	    abort ();

	  /* '6' is a special case.  It is used for BREAK and SDBBP,
	     whose operands are only meaningful to the software that decodes
	     them.  This means that there is no architectural reason why
	     they cannot be prefixed by EXTEND, but in practice,
	     exception handlers will only look at the instruction
	     itself.  We therefore allow '6' to be extended when
	     disassembling but not when assembling.  */
	  if (operand->type != OP_PCREL && c != '6')
	    {
	      ext_operand = decode_mips16_operand (c, TRUE);
	      if (operand != ext_operand)
		{
		  if (arg.token->type == OT_CHAR && arg.token->u.ch == '(')
		    {
		      offset_expr.X_op = O_constant;
		      offset_expr.X_add_number = 0;
		      relax_char = c;
		      continue;
		    }

		  /* We need the OT_INTEGER check because some MIPS16
		     immediate variants are listed before the register ones.  */
		  if (arg.token->type != OT_INTEGER
		      || !match_expression (&arg, &offset_expr, offset_reloc))
		    break;

		  /* '8' is used for SLTI(U) and has traditionally not
		     been allowed to take relocation operators.  */
		  if (offset_reloc[0] != BFD_RELOC_UNUSED
		      && (ext_operand->size != 16 || c == '8'))
		    break;

		  relax_char = c;
		  continue;
		}
	    }

	  if (mips_optional_operand_p (operand)
	      && args[1] == ','
	      && (arg.token[0].type != OT_REG
		  || arg.token[1].type == OT_END))
	    {
	      /* Assume that the register has been elided and is the
		 same as the first operand.  */
	      arg.token = tokens;
	      arg.argnum = 1;
	    }

	  if (!match_operand (&arg, operand))
	    break;
	  continue;
@


1.581
log
@opcodes/
2013-08-06  Jrgen Urban  <JuergenUrban@@gmx.de>

	* mips-opc.c (mips_builtin_opcodes): Add a suffixless version of
	VCLIPW.

gas/
2013-08-06  Jrgen Urban  <JuergenUrban@@gmx.de>

	* config/tc-mips.c (match_vu0_suffix_operand): Allow single-channel
	suffixes to be elided too.
	(mips_lookup_insn): Don't reject INSN2_VU0_CHANNEL_SUFFIX here.
	(mips_ip): Assume .xyzw if no VU0 suffix is specified.  Allow +N
	to be omitted too.

gas/testsuite/
2013-08-06  Jrgen Urban  <JuergenUrban@@gmx.de>

	* gas/mips/r5900-error-vu0.s, gas/mips/r5900-error-vu0.l,
	gas/mips/r5900-full-vu0.s, gas/mips/r5900-full-vu0.d: Allow
	single-channel suffixes to be elided.
@
text
@d3871 1
d5287 1
a12397 1
  bfd_boolean optional_reg;
d12526 11
a12536 11
		switch (args[1])
		  {
		  case 'r':
		  case 'v':
		  case 'w':
		  case 'W':
		  case 'V':
		    arg.token = tokens;
		    arg.argnum = 1;
		    continue;
		  }
a12596 1
	  optional_reg = FALSE;
a12670 11
	    case 'r':
	    case 'v':
	    case 'w':
	    case 'W':
	    case 'V':
	      /* We have already matched a comma by this point, so the register
		 is only optional if there is another operand to come.  */
	      gas_assert (arg.opnum == 2);
	      optional_reg = (args[1] == ',');
	      break;

a12757 10
		case 't':
		case 'c':
		case 'e':
		  /* We have already matched a comma by this point,
		     so the register is only optional if there is another
		     operand to come.  */
		  gas_assert (arg.opnum == 2);
		  optional_reg = (args[2] == ',');
		  break;

d12777 6
a12782 1
	  if (optional_reg
a12794 4
	  /* Skip prefixes.  */
	  if (*args == '+' || *args == 'm')
	    args++;

a12830 1
  bfd_boolean optional_reg;
d12943 9
a12951 8
		switch (args[1])
		  {
		  case 'v':
		  case 'w':
		    arg.token = tokens;
		    arg.argnum = 1;
		    continue;
		  }
a13002 1
	  optional_reg = FALSE;
a13005 5
	    case 'v':
	    case 'w':
	      optional_reg = (args[1] == ',');
	      break;

d13071 2
a13072 1
	  if (optional_reg
@


1.580
log
@gas/
	* config/tc-mips.c (mips_lookup_insn): Make length and opend signed.
@
text
@d5245 1
a5245 1
  /* The suffix can be omitted when matching a previous 4-bit mask.  */
d5247 1
a5247 1
    return operand->size == 4 && match_p;
d12324 1
a12324 1
  if (insn && (insn->pinfo2 & INSN2_VU0_CHANNEL_SUFFIX) == 0)
d12362 1
a12362 1
	  if (insn && (insn->pinfo2 & INSN2_VU0_CHANNEL_SUFFIX) == 0)
d12425 3
d12541 9
a12549 2
	      if (args[0] == '+' && args[1] == 'K')
		args += 2;
@


1.579
log
@include/opcode/
2013-08-04  Jrgen Urban  <JuergenUrban@@gmx.de>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* mips.h: Document new VU0 operand characters.
	(OP_VU0_SUFFIX, OP_VU0_MATCH_SUFFIX): New mips_operand_types.
	(OP_REG_VF, OP_REG_VI, OP_REG_R5900_I, OP_REG_R5900_Q, OP_REG_R5900_R)
	(OP_REG_R5900_ACC): New mips_reg_operand_types.
	(INSN2_VU0_CHANNEL_SUFFIX): New macro.
	(mips_vu0_channel_mask): Declare.

opcodes/
2013-08-04  Jrgen Urban  <JuergenUrban@@gmx.de>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* mips-dis.c (print_reg): Handle OP_REG_VI, OP_REG_VF, OP_REG_R5900_I,
	OP_REG_R5900_Q, OP_REG_R5900_R and OP_REG_R5900_ACC.
	(print_vu0_channel): New function.
	(print_insn_arg): Handle OP_VU0_SUFFIX and OP_VU0_MATCH_SUFFIX.
	(print_insn_args): Handle '#'.
	(print_insn_mips): Handle INSN2_VU0_CHANNEL_SUFFIX.
	* mips-opc.c (mips_vu0_channel_mask): New constant.
	(decode_mips_operand): Handle new VU0 operand types.
	(VU0, VU0CH): New macros.
	(mips_builtin_opcodes): Add VU0 opcodes.  Use "+7" rather than "E"
	for LQC2 and SQC2.  Use "+9" rather than "G" for EE CFC2 and CTC2.
	Use "+6" rather than "G" for QMFC2 and QMTC2.

gas/
2013-08-04  Jrgen Urban  <JuergenUrban@@gmx.de>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.c (MAX_OPERANDS): Bump to 6.
	(RWARN): Bump to 0x8000000.
	(RTYPE_VI, RTYPE_VF, RTYPE_R5900_I, RTYPE_R5900_Q, RTYPE_R5900_R)
	(RTYPE_R5900_ACC): New register types.
	(RTYPE_MASK): Include them.
	(R5900_I_NAMES, R5900_Q_NAMES, R5900_R_NAMES, R5900_ACC_NAMES): New
	macros.
	(reg_names): Include them.
	(mips_parse_register_1): New function, split out from...
	(mips_parse_register): ...here.  Add a channels_ptr parameter.
	Look for VU0 channel suffixes when nonnull.
	(reg_lookup): Update the call to mips_parse_register.
	(mips_parse_vu0_channels): New function.
	(OT_CHANNELS, OT_DOUBLE_CHAR): New mips_operand_token_types.
	(mips_operand_token): Add a "channels" field to the union.
	Extend the comment above "ch" to OT_DOUBLE_CHAR.
	(mips_parse_base_start): Match -- and ++.  Handle channel suffixes.
	(mips_parse_argument_token): Handle channel suffixes here too.
	(validate_mips_insn): Handle INSN2_VU0_CHANNEL_SUFFIX.
	Ignore OP_VU0_MATCH_SUFFIX when calculating the used bits.
	Handle '#' formats.
	(md_begin): Register $vfN and $vfI registers.
	(operand_reg_mask): Handle OP_VU0_SUFFIX and OP_VU0_MATCH_SUFFIX.
	(convert_reg_type): Handle OP_REG_VI, OP_REG_VF, OP_REG_R5900_I,
	OP_REG_R5900_Q, OP_REG_R5900_R and OP_REG_R5900_ACC.
	(match_vu0_suffix_operand): New function.
	(match_operand): Handle OP_VU0_SUFFIX and OP_VU0_MATCH_SUFFIX.
	(macro): Use "+7" rather than "E" for LDQ2 and STQ2.
	(mips_lookup_insn): New function.
	(mips_ip): Use it.  Allow "+K" operands to be elided at the end
	of an instruction.  Handle '#' sequences.

gas/testsuite/
2013-08-04  Jrgen Urban  <JuergenUrban@@gmx.de>

	* gas/mips/r5900-vu0.d: Expect $vfN and $viN instead of numeric
	coprocessor registers.
	* gas/mips/r5900-all-vu0.s, gas/mips/r5900-all-vu0.d,
	gas/mips/r5900-full-vu0.s, gas/mips/r5900-full-vu0.d,
	gas/mips/r5900-error-vu0.s, gas/mips/r5900-error-vu0.l: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d12310 1
a12310 1
		  unsigned int length, unsigned int *opcode_extra)
d12314 1
a12314 1
  size_t opend;
@


1.578
log
@gas/
	* config/tc-mips.c (macro, mips16_macro): Create an array of operand
	values and use it instead of sreg, treg, xreg, etc.
@
text
@d693 1
a693 1
#define MAX_OPERANDS 5
d2209 18
a2226 12
#define RTYPE_MASK	0x1ff00
#define RTYPE_NUM	0x00100
#define RTYPE_FPU	0x00200
#define RTYPE_FCC	0x00400
#define RTYPE_VEC	0x00800
#define RTYPE_GP	0x01000
#define RTYPE_CP0	0x02000
#define RTYPE_PC	0x04000
#define RTYPE_ACC	0x08000
#define RTYPE_CCC	0x10000
#define RNUM_MASK	0x000ff
#define RWARN		0x80000
d2412 12
d2444 4
d2475 2
a2476 4
/* Return true if the string at *SPTR is a valid register name.  If so,
   move *SPTR past the register and store the register's symbol value
   in *SYMVAL.  This symbol value includes the register number
   (RNUM_MASK) and register type (RTYPE_MASK).  */
d2479 1
a2479 1
mips_parse_register (char **sptr, unsigned int *symval)
d2481 1
a2482 9
  char *s, *e;
  char save_c;

  /* Find end of name.  */
  s = e = *sptr;
  if (is_name_beginner (*e))
    ++e;
  while (is_part_of_name (*e))
    ++e;
d2495 53
d2549 3
a2551 1
  *symval = S_GET_VALUE (symbol);
d2564 1
a2564 1
  if (mips_parse_register (s, &regno))
d2584 18
d2607 3
d2626 3
d2643 3
d2674 1
a2674 1
    /* The character represented by an OT_CHAR.  */
d2700 2
a2701 1
  unsigned int regno;
d2708 13
a2720 1
  if (!mips_parse_register (&s, &regno))
d2726 6
d2735 15
d2762 1
a2762 1
  unsigned int regno1, regno2;
d2781 1
a2781 1
  if (mips_parse_register (&s, &regno1))
d2783 11
d2800 1
a2800 1
	  if (!mips_parse_register (&s, &regno2))
d3039 2
d3049 4
d3066 1
a3066 1
	if (operand)
d3068 1
a3068 1
	    used_bits |= ((1 << operand->size) - 1) << operand->lsb;
d3308 17
d3866 2
d4280 18
d5231 36
d5323 6
d10140 1
a10140 1
      fmt = "E,o(b)";
d10304 1
a10304 1
      fmt = "E,o(b)";
d12305 68
d12390 1
a12390 4
  struct mips_opcode *insn;
  long opend;
  char *name;
  char *dot;
d12392 1
a12392 1
  long end;
d12397 1
d12413 1
d12419 1
a12419 30
  /* Make a copy of the instruction so that we can fiddle with it.  */
  name = alloca (end + 1);
  memcpy (name, str, end);
  name[end] = '\0';

  for (;;)
    {
      insn = (struct mips_opcode *) hash_find (hash, name);

      if (insn != NULL || !mips_opts.micromips)
	break;
      if (forced_insn_length)
	break;

      /* See if there's an instruction size override suffix,
         either `16' or `32', at the end of the mnemonic proper,
         that defines the operation, i.e. before the first `.'
         character if any.  Strip it and retry.  */
      dot = strchr (name, '.');
      opend = dot != NULL ? dot - name : end;
      if (opend < 3)
	break;
      if (name[opend - 2] == '1' && name[opend - 1] == '6')
	forced_insn_length = 2;
      else if (name[opend - 2] == '3' && name[opend - 1] == '2')
	forced_insn_length = 4;
      else
	break;
      memcpy (name + opend - 2, name + opend, end - opend + 1);
    }
d12426 1
a12426 1
  if (strcmp (name, "li.s") == 0)
d12428 1
a12428 1
  else if (strcmp (name, "li.d") == 0)
d12449 1
a12449 1
      gas_assert (strcmp (insn->name, name) == 0);
d12505 1
d12538 3
d12570 11
@


1.577
log
@include/opcode/
	* mips.h (mips_pcrel_operand): Inherit from mips_int_operand.
	(mips_int_operand_min, mips_int_operand_max): New functions.
	(mips_decode_pcrel_operand): Use mips_decode_int_operand.

opcodes/
	* mips-formats.h (PCREL): Reorder parameters and update the definition
	to match new mips_pcrel_operand layout.
	(JUMP, JALX, BRANCH): Update accordingly.
	* mips16-opc.c (decode_mips16_operand): Likewise.

gas/
	* config/tc-mips.c (match_int_operand): Use mips_int_operand_min
	and mips_int_operand_max.
	(mips16_immed_operand, mips16_immed_operands, MIPS16_NUM_IMMED):
	Delete.
	(mips16_immed_operand, mips16_immed_in_range_p): New functions.
	(mips16_immed, mips16_extended_frag): Use them.  Use mips_int_operand
	instead of mips16_immed_operand.
@
text
@d8127 2
a8128 1
  unsigned int treg, sreg, dreg, breg;
d8151 1
d8155 7
a8161 3
  treg = EXTRACT_OPERAND (mips_opts.micromips, RT, *ip);
  dreg = EXTRACT_OPERAND (mips_opts.micromips, RD, *ip);
  sreg = breg = EXTRACT_OPERAND (mips_opts.micromips, RS, *ip);
d8192 2
a8193 2
      macro_build (&label_expr, "bgez", "s,p", sreg);
      if (dreg == sreg)
d8196 2
a8197 2
	move_register (dreg, sreg);
      macro_build (NULL, dbl ? "dsub" : "sub", "d,v,t", dreg, 0, sreg);
d8222 1
a8222 1
	  macro_build (NULL, s, "t,r,.", treg, sreg, imm_expr.X_add_number);
d8235 1
a8235 1
	  macro_build (&imm_expr, s, "t,r,j", treg, sreg, BFD_RELOC_LO16);
d8241 1
a8241 1
      macro_build (NULL, s2, "d,v,t", treg, sreg, AT);
d8265 1
a8265 1
	    macro_build (&imm_expr, s, "t,r,i", treg, sreg, BFD_RELOC_LO16);
d8269 2
a8270 2
			   treg, sreg, BFD_RELOC_LO16);
	      macro_build (NULL, "nor", "d,v,t", treg, treg, 0);
d8277 1
a8277 1
      macro_build (NULL, s2, "d,v,t", treg, sreg, AT);
d8287 1
a8287 1
	  macro_build (NULL, "packrl.ph", "d,s,t", treg, treg, sreg);
d8291 1
a8291 1
	  macro_build (NULL, "balign", "t,s,2", treg, sreg,
d8315 1
a8315 1
	treg = 0;
d8318 1
a8318 1
	  treg = AT;
d8320 1
a8320 1
	  load_register (treg, &imm_expr, HAVE_64BIT_GPRS);
d8325 1
a8325 1
      macro_build_branch_rsrt (mask, &offset_expr, sreg, treg);
d8331 4
a8334 4
      if (treg == 0)
	macro_build_branch_rs (likely ? M_BGEZL : M_BGEZ, &offset_expr, sreg);
      else if (sreg == 0)
	macro_build_branch_rs (likely ? M_BLEZL : M_BLEZ, &offset_expr, treg);
d8338 1
a8338 1
	  macro_build (NULL, "slt", "d,v,t", AT, sreg, treg);
d8350 1
a8350 1
      macro_build_branch_rs (mask, &offset_expr, sreg);
d8378 1
a8378 1
				 &offset_expr, sreg);
d8384 1
a8384 1
				 &offset_expr, sreg);
d8396 1
a8396 1
      set_at (sreg, 0);
d8404 1
a8404 1
      if (treg == 0)
d8406 1
a8406 1
      else if (sreg == 0)
d8408 1
a8408 1
				 &offset_expr, ZERO, treg);
d8412 1
a8412 1
	  macro_build (NULL, "sltu", "d,v,t", AT, sreg, treg);
d8421 1
a8421 1
      if (sreg == 0
d8438 1
a8438 1
				 &offset_expr, sreg, ZERO);
d8442 1
a8442 1
	  set_at (sreg, 1);
d8451 4
a8454 4
      if (treg == 0)
	macro_build_branch_rs (likely ? M_BGTZL : M_BGTZ, &offset_expr, sreg);
      else if (sreg == 0)
	macro_build_branch_rs (likely ? M_BLTZL : M_BLTZ, &offset_expr, treg);
d8458 1
a8458 1
	  macro_build (NULL, "slt", "d,v,t", AT, treg, sreg);
d8467 1
a8467 1
      if (treg == 0)
d8469 2
a8470 2
				 &offset_expr, sreg, ZERO);
      else if (sreg == 0)
d8475 1
a8475 1
	  macro_build (NULL, "sltu", "d,v,t", AT, treg, sreg);
d8484 4
a8487 4
      if (treg == 0)
	macro_build_branch_rs (likely ? M_BLEZL : M_BLEZ, &offset_expr, sreg);
      else if (sreg == 0)
	macro_build_branch_rs (likely ? M_BGEZL : M_BGEZ, &offset_expr, treg);
d8491 1
a8491 1
	  macro_build (NULL, "slt", "d,v,t", AT, treg, sreg);
d8511 1
a8511 1
	macro_build_branch_rs (likely ? M_BLTZL : M_BLTZ, &offset_expr, sreg);
d8513 1
a8513 1
	macro_build_branch_rs (likely ? M_BLEZL : M_BLEZ, &offset_expr, sreg);
d8517 1
a8517 1
	  set_at (sreg, 0);
d8526 1
a8526 1
      if (treg == 0)
d8528 2
a8529 2
				 &offset_expr, sreg, ZERO);
      else if (sreg == 0)
d8534 1
a8534 1
	  macro_build (NULL, "sltu", "d,v,t", AT, treg, sreg);
d8543 1
a8543 1
      if (sreg == 0
d8560 1
a8560 1
				 &offset_expr, sreg, ZERO);
d8564 1
a8564 1
	  set_at (sreg, 1);
d8573 4
a8576 4
      if (treg == 0)
	macro_build_branch_rs (likely ? M_BLTZL : M_BLTZ, &offset_expr, sreg);
      else if (sreg == 0)
	macro_build_branch_rs (likely ? M_BGTZL : M_BGTZ, &offset_expr, treg);
d8580 1
a8580 1
	  macro_build (NULL, "slt", "d,v,t", AT, sreg, treg);
d8589 1
a8589 1
      if (treg == 0)
d8591 1
a8591 1
      else if (sreg == 0)
d8593 1
a8593 1
				 &offset_expr, ZERO, treg);
d8597 1
a8597 1
	  macro_build (NULL, "sltu", "d,v,t", AT, sreg, treg);
d8646 1
a8646 1
	macro_build ((expressionS *) NULL, s, fmt, treg, sreg, (int) pos,
d8694 1
a8694 1
	macro_build ((expressionS *) NULL, s, fmt, treg, sreg, (int) pos,
d8709 1
a8709 1
      if (treg == 0)
d8722 2
a8723 2
	  macro_build (NULL, "teq", TRAP_FMT, treg, ZERO, 7);
	  macro_build (NULL, dbl ? "ddiv" : "div", "z,s,t", sreg, treg);
d8731 2
a8732 2
	  macro_build (&label_expr, "bne", "s,t,p", treg, ZERO);
	  macro_build (NULL, dbl ? "ddiv" : "div", "z,s,t", sreg, treg);
d8744 1
a8744 1
      macro_build (&label_expr, "bne", "s,t,p", treg, AT);
d8758 1
a8758 1
	  macro_build (NULL, "teq", TRAP_FMT, sreg, AT, 6);
d8769 1
a8769 1
	  macro_build (&label_expr, "bne", "s,t,p", sreg, AT);
d8780 1
a8780 1
      macro_build (NULL, s, MFHL_FMT, dreg);
d8831 1
a8831 1
	    move_register (dreg, sreg);
d8833 1
a8833 1
	    move_register (dreg, ZERO);
d8841 1
a8841 3
	    {
	      macro_build (NULL, dbl ? "dneg" : "neg", "d,w", dreg, sreg);
	    }
d8843 1
a8843 1
	    move_register (dreg, ZERO);
d8849 2
a8850 2
      macro_build (NULL, s, "z,s,t", sreg, AT);
      macro_build (NULL, s2, MFHL_FMT, dreg);
d8872 2
a8873 2
	  macro_build (NULL, "teq", TRAP_FMT, treg, ZERO, 7);
	  macro_build (NULL, s, "z,s,t", sreg, treg);
d8884 2
a8885 2
	  macro_build (&label_expr, "bne", "s,t,p", treg, ZERO);
	  macro_build (NULL, s, "z,s,t", sreg, treg);
d8894 1
a8894 1
      macro_build (NULL, s2, MFHL_FMT, dreg);
d8909 1
d8918 1
a8918 1
	  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j", treg, breg,
d8923 1
a8923 1
      if (mips_opts.at && (treg == breg))
d8929 1
a8929 3
	{
	  tempreg = treg;
	}
d9113 1
a9113 1
	      if (breg == treg)
d9117 1
a9117 1
			       treg, AT, breg);
d9119 1
a9119 1
		  tempreg = treg;
d9169 2
d9178 1
a9178 1
		  if (breg != treg)
d9184 2
a9185 2
				   treg, AT, breg);
		      dreg = treg;
d9206 1
a9206 1
			       treg, tempreg, breg);
d9208 1
a9208 1
		  tempreg = treg;
d9310 2
d9319 1
a9319 1
	      if (breg != treg)
d9326 2
a9327 2
			       treg, AT, breg);
		  dreg = treg;
d9361 1
a9361 1
	      if (breg == treg)
d9368 2
a9369 2
			       treg, AT, breg);
		  tempreg = treg;
d9448 2
d9457 1
a9457 1
	      if (breg != treg)
d9463 2
a9464 2
			       treg, AT, breg);
		  dreg = treg;
d9485 1
a9485 1
			   treg, tempreg, breg);
d9487 1
a9487 1
	      tempreg = treg;
d9495 1
a9495 1
	macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", treg, tempreg, breg);
d9500 1
a9500 1
      macro_build (NULL, "c2", "C", (treg << 16) | 0x01);
d9510 1
a9510 1
      macro_build (NULL, "c2", "C", (treg << 16) | 0x02);
d9520 1
a9520 1
      macro_build (NULL, "c2", "C", (treg << 16) | 0x03);
d9537 2
a9538 1
      dreg = RA;
d9550 2
a9551 1
      dreg = RA;
d9560 1
a9560 1
	      && dreg == RA
d9562 1
a9562 1
	    macro_build (NULL, s, "mj", sreg);
d9564 1
a9564 1
	    macro_build (NULL, s, JALR_FMT, dreg, sreg);
d9571 1
a9571 1
	  if (sreg != PIC_CALL_REG)
d9580 1
a9580 1
	      && dreg == RA
d9582 1
a9582 1
	    macro_build (NULL, s, "mj", sreg);
d9584 1
a9584 1
	    macro_build (NULL, s, JALR_FMT, dreg, sreg);
a9835 1
      treg = EXTRACT_OPERAND (mips_opts.micromips, 3BITPOS, *ip);
a9840 1
      treg = EXTRACT_OPERAND (mips_opts.micromips, 3BITPOS, *ip);
d9980 1
a9980 1
      if (breg == treg + lp || treg + lp == ZERO)
d9983 1
a9983 1
	tempreg = treg + lp;
d10128 1
d10135 1
a10135 1
	    macro_build (&offset_expr, s, fmt, treg, -1, offset_reloc[0],
d10140 1
a10140 1
		macro_build (NULL, s, fmt, treg, breg);
d10142 1
a10142 1
		macro_build (NULL, s, fmt, treg,
d10153 1
a10153 1
		macro_build (NULL, s, fmt, treg, tempreg);
d10155 1
a10155 1
		macro_build (NULL, s, fmt, treg, 0, tempreg);
d10196 1
a10196 1
	      macro_build (NULL, s, fmt, treg, tempreg);
d10199 1
a10199 1
	    macro_build (&offset_expr, s, fmt, treg, BFD_RELOC_LO16, tempreg);
d10201 1
a10201 1
	    macro_build (NULL, s, fmt, treg,
d10214 1
a10214 1
	    macro_build (NULL, s, fmt, treg, tempreg);
d10216 1
a10216 1
	    macro_build (NULL, s, fmt, treg, 0, tempreg);
d10222 1
a10222 1
	       <op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16)
d10225 1
a10225 1
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)
d10232 1
a10232 1
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_GPREL16)
d10236 1
a10236 1
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)
d10246 1
a10246 1
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)
d10254 1
a10254 1
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)
d10263 1
a10263 1
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)
d10271 1
a10271 1
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)
d10283 1
a10283 1
		      macro_build (&offset_expr, s, fmt, treg,
d10290 1
a10290 1
		      macro_build (&offset_expr, s, fmt, treg,
d10308 1
a10308 1
		  macro_build (&offset_expr, s, fmt, treg, BFD_RELOC_LO16,
d10325 1
a10325 1
		  macro_build (&offset_expr, s, fmt, treg,
d10340 1
a10340 1
		  macro_build (&offset_expr, s, fmt, treg, BFD_RELOC_GPREL16,
d10345 1
a10345 1
	      macro_build (&offset_expr, s, fmt, treg,
d10358 1
a10358 1
		  macro_build (&offset_expr, s, fmt, treg,
d10365 1
a10365 1
	      macro_build (&offset_expr, s, fmt, treg,
d10378 1
a10378 1
	       <op>	$treg,0($tempreg)
d10383 1
a10383 1
	       <op>	$treg,0($tempreg)
d10387 1
a10387 1
	       <op>	$treg,<sym>($tempreg)   (BFD_RELOC_MIPS_GOT_OFST)
d10403 1
a10403 1
	      macro_build (&offset_expr, s, fmt, treg,
d10423 1
a10423 1
	  macro_build (&expr1, s, fmt, treg, BFD_RELOC_LO16, tempreg);
d10433 1
a10433 1
	       <op>	$treg,0($tempreg)
d10438 1
a10438 1
	       <op>	$treg,0($tempreg)
d10472 1
a10472 1
	  macro_build (&expr1, s, fmt, treg, BFD_RELOC_LO16, tempreg);
d10480 1
a10480 1
	       <op>	$treg,<ofst>($tempreg)
d10483 1
a10483 1
	       <op>	$treg,<sym>($tempreg)   (BFD_RELOC_MIPS_GOT_OFST)  */
d10500 1
a10500 1
	  macro_build (&expr1, s, fmt, treg, BFD_RELOC_LO16, tempreg);
d10509 1
a10509 1
	  macro_build (&offset_expr, s, fmt, treg,
d10523 1
a10523 1
      expr1.X_add_number = EXTRACT_OPERAND (1, IMMP, *ip) << 2;
d10531 1
a10531 1
      macro_build (NULL, "jr", "s", sreg);
d10538 1
a10538 1
      load_register (treg, &imm_expr, 0);
d10542 1
a10542 1
      load_register (treg, &imm_expr, 1);
d10550 1
a10550 1
	  macro_build (NULL, "mtc1", "t,G", AT, treg);
d10560 1
a10560 1
	  macro_build (&offset_expr, "lwc1", "T,o(b)", treg,
d10573 1
a10573 1
	    load_register (treg, &imm_expr, 1);
d10580 2
a10581 2
		  hreg = treg;
		  lreg = treg + 1;
d10585 2
a10586 2
		  hreg = treg + 1;
		  lreg = treg;
d10623 2
a10624 1
	  macro_build (&offset_expr, "ld", "t,o(b)", treg, BFD_RELOC_LO16, AT);
d10629 3
a10631 2
	  macro_build (&offset_expr, "lw", "t,o(b)", treg, BFD_RELOC_LO16, AT);
	  if (treg != RA)
d10637 1
a10637 1
			   treg + 1, BFD_RELOC_LO16, AT);
d10655 1
a10655 1
	      macro_build (NULL, "dmtc1", "t,S", AT, treg);
d10659 1
a10659 1
	      macro_build (NULL, "mtc1", "t,G", AT, treg + 1);
d10661 1
a10661 1
		macro_build (NULL, "mtc1", "t,G", 0, treg);
d10666 1
a10666 1
		  macro_build (NULL, "mtc1", "t,G", AT, treg);
d10677 1
a10677 1
 	  breg = mips_gp_register;
d10695 1
a10695 1
	  breg = AT;
d10776 1
d10793 1
a10793 1
	  if (strcmp (s, "lw") == 0 && treg == breg)
d10796 1
a10796 1
	      macro_build (ep, s, fmt, treg + 1, -1, offset_reloc[0],
d10799 1
a10799 1
	      macro_build (ep, s, fmt, treg, -1, offset_reloc[0],
d10804 1
a10804 1
	      macro_build (ep, s, fmt, coproc ? treg + 1 : treg, -1,
d10808 1
a10808 1
	      macro_build (ep, s, fmt, coproc ? treg : treg + 1, -1,
d10834 2
a10835 2
	       <op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16)
	       <op>	$treg+1,<sym>+4($gp)	(BFD_RELOC_GPREL16)
d10838 2
a10839 2
	       <op>	$treg,<sym>($at)	(BFD_RELOC_GPREL16)
	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_GPREL16)
d10842 2
a10843 2
	       <op>	$treg,<sym>($at)	(BFD_RELOC_LO16)
	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16)
d10865 1
a10865 1
	      macro_build (&offset_expr, s, fmt, coproc ? treg + 1 : treg,
d10874 1
a10874 1
	      macro_build (&offset_expr, s, fmt, coproc ? treg : treg + 1,
d10895 1
a10895 1
	  macro_build (&offset_expr, s, fmt, coproc ? treg + 1 : treg,
d10900 1
a10900 1
	  macro_build (&offset_expr, s, fmt, coproc ? treg : treg + 1,
d10910 2
a10911 2
	       <op>	$treg,0($at)
	       <op>	$treg+1,4($at)
d10915 2
a10916 2
	       <op>	$treg,<sym>($at)	(BFD_RELOC_LO16)
	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16)
d10937 1
a10937 1
	  macro_build (&expr1, s, fmt, coproc ? treg + 1 : treg,
d10940 1
a10940 1
	  macro_build (&expr1, s, fmt, coproc ? treg : treg + 1,
d10943 1
a10943 1
	  macro_build (&offset_expr, s, fmt, coproc ? treg + 1 : treg,
d10946 1
a10946 1
	  macro_build (&offset_expr, s, fmt, coproc ? treg : treg + 1,
d10961 2
a10962 2
	       <op>	$treg,0($at)
	       <op>	$treg+1,4($at)
d10966 2
a10967 2
	       <op>	$treg,<sym>($at)	(BFD_RELOC_LO16)
	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16)
d10989 1
a10989 1
	  macro_build (&expr1, s, fmt, coproc ? treg + 1 : treg,
d10998 1
a10998 1
	  macro_build (&expr1, s, fmt, coproc ? treg : treg + 1,
d11013 1
a11013 1
	  macro_build (&offset_expr, s, fmt, coproc ? treg + 1 : treg,
d11022 1
a11022 1
	  macro_build (&offset_expr, s, fmt, coproc ? treg : treg + 1,
d11079 1
a11079 1
      move_register (dreg, sreg);
d11085 4
a11088 6
      dreg = micromips_to_32_reg_h_map1[EXTRACT_OPERAND (1, MH, *ip)];
      breg = micromips_to_32_reg_h_map2[EXTRACT_OPERAND (1, MH, *ip)];
      sreg = micromips_to_32_reg_m_map[EXTRACT_OPERAND (1, MM, *ip)];
      treg = micromips_to_32_reg_n_map[EXTRACT_OPERAND (1, MN, *ip)];
      move_register (dreg, sreg);
      move_register (breg, treg);
d11095 2
a11096 3
        {
          macro_build (NULL, dbl ? "dmultu" : "multu", "d,s,t", dreg, sreg, treg);
        }
d11099 2
a11100 2
      macro_build (NULL, dbl ? "dmultu" : "multu", "s,t", sreg, treg);
      macro_build (NULL, "mflo", MFHL_FMT, dreg);
d11112 2
a11113 2
      macro_build (NULL, dbl ? "dmult" : "mult", "s,t", sreg, AT);
      macro_build (NULL, "mflo", MFHL_FMT, dreg);
d11130 4
a11133 3
      macro_build (NULL, dbl ? "dmult" : "mult", "s,t", sreg, imm ? AT : treg);
      macro_build (NULL, "mflo", MFHL_FMT, dreg);
      macro_build (NULL, dbl ? "dsra32" : "sra", SHFT_FMT, dreg, dreg, RA);
d11136 1
a11136 1
	macro_build (NULL, "tne", TRAP_FMT, dreg, AT, 6);
d11143 1
a11143 1
	  macro_build (&label_expr, "beq", "s,t,p", dreg, AT);
d11150 1
a11150 1
      macro_build (NULL, "mflo", MFHL_FMT, dreg);
d11168 1
a11168 1
		   sreg, imm ? AT : treg);
d11170 1
a11170 1
      macro_build (NULL, "mflo", MFHL_FMT, dreg);
d11191 1
a11191 1
	  if (dreg == sreg)
d11197 3
a11199 5
	    {
	      tempreg = dreg;
	    }
	  macro_build (NULL, "dnegu", "d,w", tempreg, treg);
	  macro_build (NULL, "drorv", "d,t,s", dreg, sreg, tempreg);
d11203 4
a11206 4
      macro_build (NULL, "dsubu", "d,v,t", AT, ZERO, treg);
      macro_build (NULL, "dsrlv", "d,t,s", AT, sreg, AT);
      macro_build (NULL, "dsllv", "d,t,s", dreg, sreg, treg);
      macro_build (NULL, "or", "d,v,t", dreg, dreg, AT);
d11212 1
a11212 1
	  if (dreg == sreg)
d11218 3
a11220 5
	    {
	      tempreg = dreg;
	    }
	  macro_build (NULL, "negu", "d,w", tempreg, treg);
	  macro_build (NULL, "rorv", "d,t,s", dreg, sreg, tempreg);
d11224 4
a11227 4
      macro_build (NULL, "subu", "d,v,t", AT, ZERO, treg);
      macro_build (NULL, "srlv", "d,t,s", AT, sreg, AT);
      macro_build (NULL, "sllv", "d,t,s", dreg, sreg, treg);
      macro_build (NULL, "or", "d,v,t", dreg, dreg, AT);
d11243 1
a11243 1
	      macro_build (NULL, "dror32", SHFT_FMT, dreg, sreg, rot - 32);
d11245 1
a11245 1
	      macro_build (NULL, "dror", SHFT_FMT, dreg, sreg, rot);
d11250 1
a11250 1
	    macro_build (NULL, "dsrl", SHFT_FMT, dreg, sreg, 0);
d11257 3
a11259 3
	macro_build (NULL, l, SHFT_FMT, AT, sreg, rot);
	macro_build (NULL, rr, SHFT_FMT, dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build (NULL, "or", "d,v,t", dreg, dreg, AT);
d11272 2
a11273 1
	    macro_build (NULL, "ror", SHFT_FMT, dreg, sreg, (32 - rot) & 0x1f);
d11278 1
a11278 1
	    macro_build (NULL, "srl", SHFT_FMT, dreg, sreg, 0);
d11282 3
a11284 3
	macro_build (NULL, "sll", SHFT_FMT, AT, sreg, rot);
	macro_build (NULL, "srl", SHFT_FMT, dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build (NULL, "or", "d,v,t", dreg, dreg, AT);
d11291 1
a11291 1
	  macro_build (NULL, "drorv", "d,t,s", dreg, sreg, treg);
d11295 4
a11298 4
      macro_build (NULL, "dsubu", "d,v,t", AT, ZERO, treg);
      macro_build (NULL, "dsllv", "d,t,s", AT, sreg, AT);
      macro_build (NULL, "dsrlv", "d,t,s", dreg, sreg, treg);
      macro_build (NULL, "or", "d,v,t", dreg, dreg, AT);
d11304 1
a11304 1
	  macro_build (NULL, "rorv", "d,t,s", dreg, sreg, treg);
d11308 4
a11311 4
      macro_build (NULL, "subu", "d,v,t", AT, ZERO, treg);
      macro_build (NULL, "sllv", "d,t,s", AT, sreg, AT);
      macro_build (NULL, "srlv", "d,t,s", dreg, sreg, treg);
      macro_build (NULL, "or", "d,v,t", dreg, dreg, AT);
d11326 1
a11326 1
	      macro_build (NULL, "dror32", SHFT_FMT, dreg, sreg, rot - 32);
d11328 1
a11328 1
	      macro_build (NULL, "dror", SHFT_FMT, dreg, sreg, rot);
d11333 1
a11333 1
	    macro_build (NULL, "dsrl", SHFT_FMT, dreg, sreg, 0);
d11340 3
a11342 3
	macro_build (NULL, rr, SHFT_FMT, AT, sreg, rot);
	macro_build (NULL, l, SHFT_FMT, dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build (NULL, "or", "d,v,t", dreg, dreg, AT);
d11355 1
a11355 1
	    macro_build (NULL, "ror", SHFT_FMT, dreg, sreg, rot);
d11360 1
a11360 1
	    macro_build (NULL, "srl", SHFT_FMT, dreg, sreg, 0);
d11364 3
a11366 3
	macro_build (NULL, "srl", SHFT_FMT, AT, sreg, rot);
	macro_build (NULL, "sll", SHFT_FMT, dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build (NULL, "or", "d,v,t", dreg, dreg, AT);
d11371 4
a11374 4
      if (sreg == 0)
	macro_build (&expr1, "sltiu", "t,r,j", dreg, treg, BFD_RELOC_LO16);
      else if (treg == 0)
	macro_build (&expr1, "sltiu", "t,r,j", dreg, sreg, BFD_RELOC_LO16);
d11377 2
a11378 2
	  macro_build (NULL, "xor", "d,v,t", dreg, sreg, treg);
	  macro_build (&expr1, "sltiu", "t,r,j", dreg, dreg, BFD_RELOC_LO16);
d11385 1
a11385 1
	  macro_build (&expr1, "sltiu", "t,r,j", dreg, sreg, BFD_RELOC_LO16);
d11388 1
a11388 1
      if (sreg == 0)
d11392 1
a11392 1
	  move_register (dreg, 0);
d11399 1
a11399 1
	  macro_build (NULL, "seqi", "t,r,+Q", dreg, sreg,
d11406 1
a11406 3
	{
	  macro_build (&imm_expr, "xori", "t,r,i", dreg, sreg, BFD_RELOC_LO16);
	}
d11413 1
a11413 1
		       "t,r,j", dreg, sreg, BFD_RELOC_LO16);
d11419 1
a11419 1
	  macro_build (NULL, "seq", "d,v,t", dreg, sreg, AT);
d11425 1
a11425 1
	  macro_build (NULL, "xor", "d,v,t", dreg, sreg, AT);
d11428 1
a11428 1
      macro_build (&expr1, "sltiu", "t,r,j", dreg, dreg, BFD_RELOC_LO16);
d11431 1
a11431 1
    case M_SGE:		/* sreg >= treg <==> not (sreg < treg) */
d11437 2
a11438 2
      macro_build (NULL, s, "d,v,t", dreg, sreg, treg);
      macro_build (&expr1, "xori", "t,r,i", dreg, dreg, BFD_RELOC_LO16);
d11441 1
a11441 1
    case M_SGE_I:		/* sreg >= I <==> not (sreg < I) */
d11446 2
a11447 4
	{
	  macro_build (&imm_expr, mask == M_SGE_I ? "slti" : "sltiu", "t,r,j",
		       dreg, sreg, BFD_RELOC_LO16);
	}
d11452 1
a11452 1
		       dreg, sreg, AT);
d11455 1
a11455 1
      macro_build (&expr1, "xori", "t,r,i", dreg, dreg, BFD_RELOC_LO16);
d11458 1
a11458 1
    case M_SGT:		/* sreg > treg  <==>  treg < sreg */
d11464 1
a11464 1
      macro_build (NULL, s, "d,v,t", dreg, treg, sreg);
d11467 1
a11467 1
    case M_SGT_I:		/* sreg > I  <==>  I < sreg */
d11475 1
a11475 1
      macro_build (NULL, s, "d,v,t", dreg, AT, sreg);
d11478 1
a11478 1
    case M_SLE:	/* sreg <= treg  <==>  treg >= sreg  <==>  not (treg < sreg) */
d11484 2
a11485 2
      macro_build (NULL, s, "d,v,t", dreg, treg, sreg);
      macro_build (&expr1, "xori", "t,r,i", dreg, dreg, BFD_RELOC_LO16);
d11488 1
a11488 1
    case M_SLE_I:	/* sreg <= I <==> I >= sreg <==> not (I < sreg) */
d11496 2
a11497 2
      macro_build (NULL, s, "d,v,t", dreg, AT, sreg);
      macro_build (&expr1, "xori", "t,r,i", dreg, dreg, BFD_RELOC_LO16);
d11505 2
a11506 1
	  macro_build (&imm_expr, "slti", "t,r,j", dreg, sreg, BFD_RELOC_LO16);
d11511 1
a11511 1
      macro_build (NULL, "slt", "d,v,t", dreg, sreg, AT);
d11519 1
a11519 1
	  macro_build (&imm_expr, "sltiu", "t,r,j", dreg, sreg,
d11525 1
a11525 1
      macro_build (NULL, "sltu", "d,v,t", dreg, sreg, AT);
d11529 4
a11532 4
      if (sreg == 0)
	macro_build (NULL, "sltu", "d,v,t", dreg, 0, treg);
      else if (treg == 0)
	macro_build (NULL, "sltu", "d,v,t", dreg, 0, sreg);
d11535 2
a11536 2
	  macro_build (NULL, "xor", "d,v,t", dreg, sreg, treg);
	  macro_build (NULL, "sltu", "d,v,t", dreg, 0, dreg);
d11543 1
a11543 1
	  macro_build (NULL, "sltu", "d,v,t", dreg, 0, sreg);
d11546 1
a11546 1
      if (sreg == 0)
d11551 1
a11551 1
		       dreg, 0, BFD_RELOC_LO16);
d11558 1
a11558 1
	  macro_build (NULL, "snei", "t,r,+Q", dreg, sreg,
d11566 2
a11567 1
	  macro_build (&imm_expr, "xori", "t,r,i", dreg, sreg, BFD_RELOC_LO16);
d11575 1
a11575 1
		       "t,r,j", dreg, sreg, BFD_RELOC_LO16);
d11581 1
a11581 1
	  macro_build (NULL, "sne", "d,v,t", dreg, sreg, AT);
d11587 1
a11587 1
	  macro_build (NULL, "xor", "d,v,t", dreg, sreg, AT);
d11590 1
a11590 1
      macro_build (NULL, "sltu", "d,v,t", dreg, 0, dreg);
d11611 1
a11611 1
	  macro_build (NULL, s, "t,r,.", dreg, sreg, -imm_expr.X_add_number);
d11625 1
a11625 1
	  macro_build (&imm_expr, s, "t,r,j", dreg, sreg, BFD_RELOC_LO16);
d11631 1
a11631 1
      macro_build (NULL, s2, "d,v,t", dreg, sreg, AT);
d11654 1
a11654 1
      macro_build (NULL, s, "s,t", sreg, AT);
a11661 2
      sreg = (ip->insn_opcode >> 11) & 0x1f;	/* floating reg */
      dreg = (ip->insn_opcode >> 06) & 0x1f;	/* floating reg */
d11668 2
a11669 2
      macro_build (NULL, "cfc1", "t,G", treg, RA);
      macro_build (NULL, "cfc1", "t,G", treg, RA);
d11672 1
a11672 1
      macro_build (&expr1, "ori", "t,r,i", AT, treg, BFD_RELOC_LO16);
d11678 2
a11679 2
		   dreg, sreg);
      macro_build (NULL, "ctc1", "t,G", treg, RA);
d11727 1
d11749 1
a11749 1
	  tempreg = treg;
d11752 1
a11752 1
      else if (!ust && treg == breg)
d11758 1
a11758 1
	tempreg = treg;
d11783 1
a11783 1
      if (!ust && treg != tempreg)
d11787 1
a11787 1
	  move_register (treg, tempreg);
d11795 1
a11795 1
      tempreg = ust || large_offset ? treg : AT;
d11803 1
a11803 1
      tempreg = ust == large_offset ? treg : AT;
d11805 1
a11805 1
	macro_build (NULL, "srl", SHFT_FMT, tempreg, treg, 8);
d11827 1
a11827 1
	  tempreg = !large_offset ? AT : treg;
d11829 1
a11829 1
	  macro_build (NULL, "or", "d,v,t", treg, treg, AT);
d11848 1
d11850 1
a11850 1
  int xreg, yreg, zreg, tmp;
d11854 2
d11859 6
a11864 3
  xreg = MIPS16_EXTRACT_OPERAND (RX, *ip);
  yreg = MIPS16_EXTRACT_OPERAND (RY, *ip);
  zreg = MIPS16_EXTRACT_OPERAND (RZ, *ip);
d11889 1
a11889 1
      macro_build (NULL, dbl ? "ddiv" : "div", "0,x,y", xreg, yreg);
d11891 1
a11891 1
      macro_build (&expr1, "bnez", "x,p", yreg);
d11899 1
a11899 1
      macro_build (NULL, s, "x", zreg);
d11919 1
a11919 1
      macro_build (NULL, s, "0,x,y", xreg, yreg);
d11921 1
a11921 1
      macro_build (&expr1, "bnez", "x,p", yreg);
d11924 1
a11924 1
      macro_build (NULL, s2, "x", zreg);
d11930 2
a11931 2
      macro_build (NULL, dbl ? "dmultu" : "multu", "x,y", xreg, yreg);
      macro_build (NULL, "mflo", "x", zreg);
d11942 1
a11942 1
      macro_build (&imm_expr, dbl ? "daddiu" : "addiu", "y,x,4", yreg, xreg);
d11949 1
a11949 1
      macro_build (&imm_expr, "addiu", "x,k", xreg);
d11956 1
a11956 1
      macro_build (&imm_expr, "daddiu", "y,j", yreg);
d12000 3
a12002 3
      tmp = xreg;
      xreg = yreg;
      yreg = tmp;
d12005 1
a12005 1
      macro_build (NULL, s, "x,y", xreg, yreg);
d12065 1
a12065 1
      macro_build (&imm_expr, s, s3, xreg);
d12071 3
a12073 3
      macro_build (&expr1, "slti", "x,8", yreg);
      if (xreg != yreg)
	macro_build (NULL, "move", "y,X", xreg, mips16_to_32_reg_map[yreg]);
d12076 1
a12076 1
      macro_build (NULL, "neg", "x,w", xreg, xreg);
@


1.576
log
@gas/
	* config/tc-mips.c (mips16_macro): Don't use move_register.
	(mips16_ip): Allow macros to use 'p'.

gas/testsuite/
	* gas/mips/mips16-macro.s, gas/mips/mips16-macro.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d4221 1
a4221 1
  unsigned int uval, mask;
d4228 2
a4229 3
  mask = (1 << operand_base->size) - 1;
  max_val = (operand->max_val + operand->bias) << operand->shift;
  min_val = max_val - (mask << operand->shift);
d4231 1
a4231 1
    max_val = mask << operand->shift;
a12827 55
/* This structure holds information we know about a mips16 immediate
   argument type.  */

struct mips16_immed_operand
{
  /* The type code used in the argument string in the opcode table.  */
  int type;
  /* The number of bits in the short form of the opcode.  */
  int nbits;
  /* The number of bits in the extended form of the opcode.  */
  int extbits;
  /* The amount by which the short form is shifted when it is used;
     for example, the sw instruction has a shift count of 2.  */
  int shift;
  /* The amount by which the short form is shifted when it is stored
     into the instruction code.  */
  int op_shift;
  /* Non-zero if the short form is unsigned.  */
  int unsp;
  /* Non-zero if the extended form is unsigned.  */
  int extu;
  /* Non-zero if the value is PC relative.  */
  int pcrel;
};

/* The mips16 immediate operand types.  */

static const struct mips16_immed_operand mips16_immed_operands[] =
{
  { '<',  3,  5, 0, MIPS16OP_SH_RZ,   1, 1, 0 },
  { '>',  3,  5, 0, MIPS16OP_SH_RX,   1, 1, 0 },
  { '[',  3,  6, 0, MIPS16OP_SH_RZ,   1, 1, 0 },
  { ']',  3,  6, 0, MIPS16OP_SH_RX,   1, 1, 0 },
  { '4',  4, 15, 0, MIPS16OP_SH_IMM4, 0, 0, 0 },
  { '5',  5, 16, 0, MIPS16OP_SH_IMM5, 1, 0, 0 },
  { 'H',  5, 16, 1, MIPS16OP_SH_IMM5, 1, 0, 0 },
  { 'W',  5, 16, 2, MIPS16OP_SH_IMM5, 1, 0, 0 },
  { 'D',  5, 16, 3, MIPS16OP_SH_IMM5, 1, 0, 0 },
  { 'j',  5, 16, 0, MIPS16OP_SH_IMM5, 0, 0, 0 },
  { '8',  8, 16, 0, MIPS16OP_SH_IMM8, 1, 0, 0 },
  { 'V',  8, 16, 2, MIPS16OP_SH_IMM8, 1, 0, 0 },
  { 'C',  8, 16, 3, MIPS16OP_SH_IMM8, 1, 0, 0 },
  { 'U',  8, 16, 0, MIPS16OP_SH_IMM8, 1, 1, 0 },
  { 'k',  8, 16, 0, MIPS16OP_SH_IMM8, 0, 0, 0 },
  { 'K',  8, 16, 3, MIPS16OP_SH_IMM8, 0, 0, 0 },
  { 'p',  8, 16, 0, MIPS16OP_SH_IMM8, 0, 0, 1 },
  { 'q', 11, 16, 0, MIPS16OP_SH_IMM8, 0, 0, 1 },
  { 'A',  8, 16, 2, MIPS16OP_SH_IMM8, 1, 0, 1 },
  { 'B',  5, 16, 3, MIPS16OP_SH_IMM5, 1, 0, 1 },
  { 'E',  5, 16, 2, MIPS16OP_SH_IMM5, 1, 0, 1 }
};

#define MIPS16_NUM_IMMED \
  (sizeof mips16_immed_operands / sizeof mips16_immed_operands[0])

d12853 37
d12906 2
a12907 32
  const struct mips16_immed_operand *op;
  int mintiny, maxtiny;

  op = mips16_immed_operands;
  while (op->type != type)
    {
      ++op;
      gas_assert (op < mips16_immed_operands + MIPS16_NUM_IMMED);
    }

  if (op->unsp)
    {
      if (type == '<' || type == '>' || type == '[' || type == ']')
	{
	  mintiny = 1;
	  maxtiny = 1 << op->nbits;
	}
      else
	{
	  mintiny = 0;
	  maxtiny = (1 << op->nbits) - 1;
	}
      if (reloc != BFD_RELOC_UNUSED)
	val &= 0xffff;
    }
  else
    {
      mintiny = - (1 << (op->nbits - 1));
      maxtiny = (1 << (op->nbits - 1)) - 1;
      if (reloc != BFD_RELOC_UNUSED)
	val = SEXT_16BIT (val);
    }
d12909 2
a12910 7
  /* Branch offsets have an implicit 0 in the lowest bit.  */
  if (type == 'p' || type == 'q')
    val /= 2;

  if ((val & ((1 << op->shift) - 1)) != 0
      || val < (mintiny << op->shift)
      || val > (maxtiny << op->shift))
d12927 2
a12928 1
  if (mips16_opcode_length (*insn) == 2)
d12930 8
a12937 6
      int insnval;

      insnval = ((val >> op->shift) & ((1 << op->nbits) - 1));
      insnval <<= op->op_shift;
      *insn |= insnval;
    }
d12939 1
a12939 22
    {
      long minext, maxext;

      if (reloc == BFD_RELOC_UNUSED)
	{
	  if (op->extu)
	    {
	      minext = 0;
	      maxext = (1 << op->extbits) - 1;
	    }
	  else
	    {
	      minext = - (1 << (op->extbits - 1));
	      maxext = (1 << (op->extbits - 1)) - 1;
	    }
	  if (val < minext || val > maxext)
	    as_bad_where (file, line,
			  _("operand value out of range for instruction"));
	}

      *insn |= mips16_immed_extend (val, op->extbits);
    }
d15675 1
a15675 1
  const struct mips16_immed_operand *op;
a15676 1
  int mintiny, maxtiny;
d15686 1
a15686 25
  op = mips16_immed_operands;
  while (op->type != type)
    {
      ++op;
      gas_assert (op < mips16_immed_operands + MIPS16_NUM_IMMED);
    }

  if (op->unsp)
    {
      if (type == '<' || type == '>' || type == '[' || type == ']')
	{
	  mintiny = 1;
	  maxtiny = 1 << op->nbits;
	}
      else
	{
	  mintiny = 0;
	  maxtiny = (1 << op->nbits) - 1;
	}
    }
  else
    {
      mintiny = - (1 << (op->nbits - 1));
      maxtiny = (1 << (op->nbits - 1)) - 1;
    }
d15692 1
a15692 1
  if (op->pcrel)
d15694 1
d15696 1
d15704 1
d15774 1
a15774 1
      if (type == 'p' || type == 'q')
d15786 1
a15786 2
	  if ((val & 1) != 0)
	    --val;
d15793 1
a15793 5
      val -= addr & ~ ((1 << op->shift) - 1);

      /* Branch offsets have an implicit 0 in the lowest bit.  */
      if (type == 'p' || type == 'q')
	val /= 2;
d15800 1
a15800 1
      if ((val & ((1 << op->shift) - 1)) != 0 && sec == NULL)
d15808 2
a15809 2
         is precisely maxtiny + 1, then there is a chance of an
         infinite loop as in the following code:
d15818 3
a15820 2
	 extended with a value of maxtiny + 1.  */
      if (val == ((maxtiny + 1) << op->shift)
d15832 1
a15832 6
  if ((val & ((1 << op->shift) - 1)) != 0
      || val < (mintiny << op->shift)
      || val > (maxtiny << op->shift))
    return 1;
  else
    return 0;
d16720 1
a16720 1
      const struct mips16_immed_operand *op;
d16728 1
a16728 3
      op = mips16_immed_operands;
      while (op->type != type)
	++op;
d16732 1
a16732 1
      if (op->pcrel)
d16734 1
d16737 1
d16742 1
a16742 1
	  if (type == 'p' || type == 'q')
d16749 1
a16749 2
	      if ((val & 1) != 0)
		--val;
d16756 1
a16756 1
	  addr &= ~ (addressT) ((1 << op->shift) - 1);
d16761 2
a16762 2
	  if (op->shift > 0)
	    record_alignment (asec, op->shift);
@


1.575
log
@include/opcode/
	* mips.h (mips_decode_reg_operand): New function.
	(INSN_WRITE_SHIFT, INSN_WRITE_1, INSN_WRITE_2, INSN_WRITE_ALL)
	(INSN_READ_SHIFT, INSN_READ_1, INSN_READ_2, INSN_READ_3, INSN_READ_4)
	(INSN_READ_ALL, INSN_READ_GPR_24, INSN_WRITE_GPR_24, INSN_UDI):
	New macros.
	(INSN_WRITE_GPR_D, INSN_WRITE_GPR_T, INSN_WRITE_FPR_D)
	(INSN_WRITE_FPR_S, INSN_WRITE_FPR_T, INSN_READ_GPR_S, INSN_READ_GPR_T)
	(INSN_READ_FPR_S, INSN_READ_FPR_T, INSN_READ_FPR_R, INSN_WRITE_GPR_S)
	(INSN2_WRITE_GPR_Z, INSN2_WRITE_FPR_Z, INSN2_READ_GPR_Z)
	(INSN2_READ_FPR_Z, INSN2_READ_GPR_D, INSN2_READ_FPR_D)
	(INSN2_WRITE_GPR_MB, INSN2_READ_GPR_MC, INSN2_MOD_GPR_MD)
	(INSN2_READ_GPR_ME, INSN2_MOD_GPR_MF, INSN2_READ_GPR_MG)
	(INSN2_READ_GPR_MJ, INSN2_WRITE_GPR_MJ, INSN2_READ_GPR_MP)
	(INSN2_WRITE_GPR_MP, INSN2_READ_GPR_MQ, INSN2_READ_GP)
	(INSN2_WRITE_GPR_MH, INSN2_READ_GPR_MMN): Delete.  Renumber other
	macros to cover the gaps.
	(INSN2_MOD_SP): Replace with...
	(INSN2_WRITE_SP, INSN2_READ_SP): ...these new macros.
	(MIPS16_INSN_WRITE_X, MIPS16_INSN_WRITE_Y, MIPS16_INSN_WRITE_Z)
	(MIPS16_INSN_WRITE_T, MIPS16_INSN_WRITE_31, MIPS16_INSN_WRITE_GPR_Y)
	(MIPS16_INSN_READ_X, MIPS16_INSN_READ_Y, MIPS16_INSN_READ_Z)
	(MIPS16_INSN_READ_T, MIPS16_INSN_READ_SP, MIPS16_INSN_READ_GPR_X):
	Delete.

opcodes/
	* mips-opc.c (WR_1, WR_2, RD_1, RD_2, RD_3, RD_4, MOD_1, MOD_2, UDI):
	New macros.
	(WR_d, WR_t, WR_D, WR_T, WR_S, RD_s, RD_b, RD_t, RD_S, RD_T, RD_R)
	(WR_z, WR_Z, RD_z, RD_Z, RD_d): Delete.
	(mips_builtin_opcodes): Use the new position-based read-write flags
	instead of field-based ones.  Use UDI for "udi..." instructions.
	* mips16-opc.c (WR_1, WR_2, RD_1, RD_2, RD_3, RD_4, MOD_1, MOD_2):
	New macros.
	(WR_x, WR_y, WR_z, WR_Y, RD_x, RD_y, RD_Z, RD_X): Delete.
	(RD_T, WR_T, WR_31): Redefine using generic INSN_* flags.
	(WR_SP, RD_16): New macros.
	(RD_SP): Redefine as an INSN2_* flag.
	(MOD_SP): Redefine in terms of RD_SP and WR_SP.
	(mips16_opcodes): Use the new position-based read-write flags
	instead of field-based ones.  Use RD_16 for "nop".  Move RD_SP to
	pinfo2 field.
	* micromips-opc.c (WR_1, WR_2, RD_1, RD_2, RD_3, RD_4, MOD_1, MOD_2):
	New macros.
	(WR_mb, RD_mc, RD_md, WR_md, RD_me, RD_mf, WR_mf, RD_mg, WR_mh, RD_mj)
	(WR_mj, RD_ml, RD_mmn, RD_mp, WR_mp, RD_mq, RD_gp, WR_d, WR_t, WR_D)
	(WR_T, WR_S, RD_s, RD_b, RD_t, RD_T, RD_S, RD_R, RD_D): Delete.
	(RD_sp, WR_sp): Redefine to INSN2_READ_SP and INSN2_WRITE_SP.
	(micromips_opcodes): Use the new position-based read-write flags
	instead of field-based ones.
	* mips-dis.c (print_insn_arg): Use mips_decode_reg_operand.
	(print_insn_mips, print_insn_micromips): Use INSN_WRITE_1 instead
	of field-based flags.

gas/
	* config/tc-mips.c (MAX_OPERANDS): New macro.
	(mips_operand_array): New structure.
	(mips_operands, mips16_operands, micromips_operands): New arrays.
	(micromips_to_32_reg_b_map, micromips_to_32_reg_c_map)
	(micromips_to_32_reg_e_map, micromips_to_32_reg_f_map)
	(micromips_to_32_reg_g_map, micromips_to_32_reg_l_map)
	(micromips_to_32_reg_q_map): Delete.
	(insn_operands, insn_opno, insn_extract_operand): New functions.
	(validate_mips_insn): Take a mips_operand_array as argument and
	use it to build up a list of operands.  Extend to handle INSN_MACRO
	and MIPS16.
	(validate_mips16_insn): New function.
	(validate_micromips_insn): Take a mips_operand_array as argument.
	Handle INSN_MACRO.
	(md_begin): Initialize mips_operands, mips16_operands and
	micromips_operands.  Call validate_mips_insn and
	validate_micromips_insn for macro instructions too.
	Call validate_mips16_insn for MIPS16 instructions.
	(insn_read_mask, insn_write_mask, operand_reg_mask, insn_reg_mask):
	New functions.
	(gpr_read_mask, gpr_write_mask, fpr_read_mask, fpr_write_mask): Use
	them.  Handle INSN_UDI.
	(get_append_method): Use gpr_read_mask.
@
text
@d12063 1
a12063 1
	move_register (xreg, yreg);
d12067 1
d12684 1
a12684 1
		  gas_assert (relax_char == 0);
@


1.574
log
@include/opcode/
	* mips.h (MIPS16_INSN_WRITE_SP, MIPS16_INSN_READ_31)
	(MIPS16_INSN_READ_PC, MIPS16_INSN_UNCOND_BRANCH)
	(MIPS16_INSN_COND_BRANCH): Delete.

opcodes/
	* mips16-opc.c (UBR, CBR, RD_31, RD_PC): Redefine as INSN2_* flags.
	(WR_SP): Replace with...
	(MOD_SP): ...this.
	(mips16_opcodes): Update accordingly.
	* mips-dis.c (print_insn_mips16): Likewise.

gas/
	* config/tc-mips.c (compact_branch_p, uncond_branch_p): Use the same
	flags for MIPS16 and non-MIPS16 instructions.
	(gpr_mod_mask): Move the INSN2_MOD_SP case outside the micromips block.
	(gpr_read_mask): Use INSN2_READ_GPR_31 for MIPS16 instructions too.
	(gpr_write_mask): Remove MIPS16_INSN_WRITE_SP handling.
	(can_swap_branch_p, get_append_method): Use the same flags for MIPS16
	and non-MIPS16 instructions.  Fix formatting.
@
text
@d692 9
a775 2
#define micromips_to_32_reg_b_map	mips16_to_32_reg_map
#define micromips_to_32_reg_c_map	mips16_to_32_reg_map
a776 3
#define micromips_to_32_reg_e_map	mips16_to_32_reg_map
#define micromips_to_32_reg_f_map	mips16_to_32_reg_map
#define micromips_to_32_reg_g_map	mips16_to_32_reg_map
a787 2
#define micromips_to_32_reg_l_map	mips16_to_32_reg_map

a795 6
/* The microMIPS registers with type q.  */
static const unsigned int micromips_to_32_reg_q_map[] =
{
  0, 17, 2, 3, 4, 5, 6, 7
};

d1965 33
d2007 9
d2872 8
a2879 5
/* For consistency checking, verify that all bits of OPCODE are
   specified either by the match/mask part of the instruction
   definition, or by the operand list.  INSN_BITS says which
   bits of the instruction are significant and DECODE_OPERAND
   provides the mips_operand description of each operand.  */
d2884 2
a2885 1
		    const struct mips_operand *(*decode_operand) (const char *))
d2888 1
a2888 1
  unsigned long used_bits, doubled, undefined;
d2891 2
a2892 1
  if ((opcode->mask & opcode->match) != opcode->match)
d2899 1
d2909 5
a2913 2
	operand = decode_operand (s);
	if (!operand)
d2919 12
a2930 5
	used_bits |= ((1 << operand->size) - 1) << operand->lsb;
	if (operand->type == OP_MDMX_IMM_REG)
	  /* Bit 5 is the format selector (OB vs QH).  The opcode table
	     has separate entries for each format.  */
	  used_bits &= ~(1 << (operand->lsb + 5));
d2932 1
a2932 1
	if (*s == '+' || *s == 'm')
d2934 1
d2937 1
a2937 1
  doubled = used_bits & opcode->mask & insn_bits;
d2944 1
a2944 1
  used_bits |= opcode->mask;
d2946 1
a2946 1
  if (undefined)
d2962 20
d2985 2
a2986 1
validate_micromips_insn (const struct mips_opcode *opc)
d2992 4
d3016 2
a3017 1
  return validate_mips_insn (opc, insn_bits, decode_micromips_operand);
d3042 1
d3057 9
a3065 12
	  if (mips_opcodes[i].pinfo != INSN_MACRO)
	    {
	      if (!validate_mips_insn (&mips_opcodes[i], 0xffffffff,
				       decode_mips_operand))
		broken = 1;
	      if (nop_insn.insn_mo == NULL && strcmp (name, "nop") == 0)
		{
		  create_insn (&nop_insn, mips_opcodes + i);
		  if (mips_fix_loongson2f_nop)
		    nop_insn.insn_opcode = LOONGSON2F_NOP_INSN;
		  nop_insn.fixed_p = 1;
		}
d3073 2
d3087 2
a3088 8
	  if (mips16_opcodes[i].pinfo != INSN_MACRO
	      && ((mips16_opcodes[i].match & mips16_opcodes[i].mask)
		  != mips16_opcodes[i].match))
	    {
	      fprintf (stderr, _("internal error: bad mips16 opcode: %s %s\n"),
		       mips16_opcodes[i].name, mips16_opcodes[i].args);
	      broken = 1;
	    }
d3101 2
d3115 15
a3129 13
        if (micromips_opcodes[i].pinfo != INSN_MACRO)
          {
            struct mips_cl_insn *micromips_nop_insn;

            if (!validate_micromips_insn (&micromips_opcodes[i]))
              broken = 1;

	    if (micromips_insn_length (micromips_opcodes + i) == 2)
	      micromips_nop_insn = &micromips_nop16_insn;
	    else if (micromips_insn_length (micromips_opcodes + i) == 4)
	      micromips_nop_insn = &micromips_nop32_insn;
	    else
	      continue;
d3131 8
a3138 7
            if (micromips_nop_insn->insn_mo == NULL
		&& strcmp (name, "nop") == 0)
              {
                create_insn (micromips_nop_insn, micromips_opcodes + i);
                micromips_nop_insn->fixed_p = 1;
              }
          }
d3663 11
a3673 1
/* Return the mask of core registers that IP reads or writes.  */
d3676 1
a3676 1
gpr_mod_mask (const struct mips_cl_insn *ip)
d3678 84
a3761 2
  unsigned long pinfo2;
  unsigned int mask;
d3763 3
a3765 3
  mask = 0;
  pinfo2 = ip->insn_mo->pinfo2;
  if (mips_opts.micromips)
d3767 4
a3770 4
      if (pinfo2 & INSN2_MOD_GPR_MD)
	mask |= 1 << micromips_to_32_reg_d_map[EXTRACT_OPERAND (1, MD, *ip)];
      if (pinfo2 & INSN2_MOD_GPR_MF)
	mask |= 1 << micromips_to_32_reg_f_map[EXTRACT_OPERAND (1, MF, *ip)];
d3772 1
a3772 3
  if (pinfo2 & INSN2_MOD_SP)
    mask |= 1 << SP;
  return mask;
d3783 1
a3783 1
  mask = gpr_mod_mask (ip);
d3786 1
a3786 1
  if (mips_opts.mips16)
d3788 11
a3798 27
      if (pinfo & MIPS16_INSN_READ_X)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, *ip)];
      if (pinfo & MIPS16_INSN_READ_Y)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RY, *ip)];
      if (pinfo & MIPS16_INSN_READ_T)
	mask |= 1 << TREG;
      if (pinfo & MIPS16_INSN_READ_SP)
	mask |= 1 << SP;
      if (pinfo & MIPS16_INSN_READ_Z)
	mask |= 1 << (mips16_to_32_reg_map
		      [MIPS16_EXTRACT_OPERAND (MOVE32Z, *ip)]);
      if (pinfo & MIPS16_INSN_READ_GPR_X)
	mask |= 1 << MIPS16_EXTRACT_OPERAND (REGR32, *ip);
    }
  else
    {
      if (pinfo2 & INSN2_READ_GPR_D)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RD, *ip);
      if (pinfo & INSN_READ_GPR_T)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RT, *ip);
      if (pinfo & INSN_READ_GPR_S)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RS, *ip);
      if (pinfo2 & INSN2_READ_GP)
	mask |= 1 << GP;
      if (pinfo2 & INSN2_READ_GPR_Z)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RZ, *ip);
    }
d3800 1
a3800 21
    mask |= 1 << RA;
  if (mips_opts.micromips)
    {
      if (pinfo2 & INSN2_READ_GPR_MC)
	mask |= 1 << micromips_to_32_reg_c_map[EXTRACT_OPERAND (1, MC, *ip)];
      if (pinfo2 & INSN2_READ_GPR_ME)
	mask |= 1 << micromips_to_32_reg_e_map[EXTRACT_OPERAND (1, ME, *ip)];
      if (pinfo2 & INSN2_READ_GPR_MG)
	mask |= 1 << micromips_to_32_reg_g_map[EXTRACT_OPERAND (1, MG, *ip)];
      if (pinfo2 & INSN2_READ_GPR_MJ)
	mask |= 1 << EXTRACT_OPERAND (1, MJ, *ip);
      if (pinfo2 & INSN2_READ_GPR_MMN)
	{
	  mask |= 1 << micromips_to_32_reg_m_map[EXTRACT_OPERAND (1, MM, *ip)];
	  mask |= 1 << micromips_to_32_reg_n_map[EXTRACT_OPERAND (1, MN, *ip)];
	}
      if (pinfo2 & INSN2_READ_GPR_MP)
	mask |= 1 << EXTRACT_OPERAND (1, MP, *ip);
      if (pinfo2 & INSN2_READ_GPR_MQ)
	mask |= 1 << micromips_to_32_reg_q_map[EXTRACT_OPERAND (1, MQ, *ip)];
    }
d3813 1
a3813 1
  mask = gpr_mod_mask (ip);
d3816 9
a3824 42
  if (mips_opts.mips16)
    {
      if (pinfo & MIPS16_INSN_WRITE_X)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, *ip)];
      if (pinfo & MIPS16_INSN_WRITE_Y)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RY, *ip)];
      if (pinfo & MIPS16_INSN_WRITE_Z)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RZ, *ip)];
      if (pinfo & MIPS16_INSN_WRITE_T)
	mask |= 1 << TREG;
      if (pinfo & MIPS16_INSN_WRITE_31)
	mask |= 1 << RA;
      if (pinfo & MIPS16_INSN_WRITE_GPR_Y)
	mask |= 1 << MIPS16OP_EXTRACT_REG32R (ip->insn_opcode);
    }
  else
    {
      if (pinfo & INSN_WRITE_GPR_D)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RD, *ip);
      if (pinfo & INSN_WRITE_GPR_T)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RT, *ip);
      if (pinfo & INSN_WRITE_GPR_S)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RS, *ip);
      if (pinfo & INSN_WRITE_GPR_31)
	mask |= 1 << RA;
      if (pinfo2 & INSN2_WRITE_GPR_Z)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, RZ, *ip);
    }
  if (mips_opts.micromips)
    {
      if (pinfo2 & INSN2_WRITE_GPR_MB)
	mask |= 1 << micromips_to_32_reg_b_map[EXTRACT_OPERAND (1, MB, *ip)];
      if (pinfo2 & INSN2_WRITE_GPR_MH)
	{
	  mask |= 1 << micromips_to_32_reg_h_map1[EXTRACT_OPERAND (1, MH, *ip)];
	  mask |= 1 << micromips_to_32_reg_h_map2[EXTRACT_OPERAND (1, MH, *ip)];
	}
      if (pinfo2 & INSN2_WRITE_GPR_MJ)
	mask |= 1 << EXTRACT_OPERAND (1, MJ, *ip);
      if (pinfo2 & INSN2_WRITE_GPR_MP)
	mask |= 1 << EXTRACT_OPERAND (1, MP, *ip);
    }
d3834 1
a3834 1
  unsigned long pinfo, pinfo2;
d3837 2
a3838 1
  mask = 0;
a3839 14
  pinfo2 = ip->insn_mo->pinfo2;
  if (!mips_opts.mips16)
    {
      if (pinfo2 & INSN2_READ_FPR_D)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, FD, *ip);
      if (pinfo & INSN_READ_FPR_S)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, FS, *ip);
      if (pinfo & INSN_READ_FPR_T)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, FT, *ip);
      if (pinfo & INSN_READ_FPR_R)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, FR, *ip);
      if (pinfo2 & INSN2_READ_FPR_Z)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, FZ, *ip);
    }
d3852 1
a3852 1
  unsigned long pinfo, pinfo2;
d3855 2
a3856 1
  mask = 0;
a3857 12
  pinfo2 = ip->insn_mo->pinfo2;
  if (!mips_opts.mips16)
    {
      if (pinfo & INSN_WRITE_FPR_D)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, FD, *ip);
      if (pinfo & INSN_WRITE_FPR_S)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, FS, *ip);
      if (pinfo & INSN_WRITE_FPR_T)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, FT, *ip);
      if (pinfo2 & INSN2_WRITE_FPR_Z)
	mask |= 1 << EXTRACT_OPERAND (mips_opts.micromips, FZ, *ip);
    }
a5848 2
  unsigned long pinfo, pinfo2;

a5864 2
      pinfo = ip->insn_mo->pinfo;
      pinfo2 = ip->insn_mo->pinfo2;
d5867 1
a5867 2
	  && ((pinfo & MIPS16_INSN_READ_X) != 0
	      || (pinfo2 & INSN2_READ_GPR_31) != 0))
@


1.573
log
@gas/
	* config/tc-mips.c (reg_needs_delay): Move later in file.
	Use gpr_write_mask.
	(insns_between): Use gpr_read_mask instead of EXTRACT_OPERAND.
@
text
@d3550 2
a3551 6
  if (mips_opts.mips16)
    return (ip->insn_mo->pinfo & (MIPS16_INSN_UNCOND_BRANCH
				  | MIPS16_INSN_COND_BRANCH)) != 0;
  else
    return (ip->insn_mo->pinfo2 & (INSN2_UNCOND_BRANCH
				   | INSN2_COND_BRANCH)) != 0;
d3560 1
a3560 3
	  || (mips_opts.mips16
	      ? (ip->insn_mo->pinfo & MIPS16_INSN_UNCOND_BRANCH) != 0
	      : (ip->insn_mo->pinfo2 & INSN2_UNCOND_BRANCH) != 0));
a3598 2
      if (pinfo2 & INSN2_MOD_SP)
	mask |= 1 << SP;
d3600 2
a3625 2
      if (pinfo & MIPS16_INSN_READ_31)
	mask |= 1 << RA;
a3641 2
      if (pinfo2 & INSN2_READ_GPR_31)
	mask |= 1 << RA;
d3645 2
a3691 2
      if (pinfo & MIPS16_INSN_WRITE_SP)
	mask |= 1 << SP;
d5596 1
a5596 1
  bfd_reloc_code_real_type *reloc_type)
d5698 1
a5698 3
  if (mips_opts.mips16 && (prev_pinfo & MIPS16_INSN_READ_PC))
    return FALSE;
  if (mips_opts.micromips && (prev_pinfo2 & INSN2_READ_PC))
d5770 1
a5770 1
  bfd_reloc_code_real_type *reloc_type)
d5772 1
a5772 1
  unsigned long pinfo;
d5791 1
d5794 2
a5795 1
	  && (pinfo & (MIPS16_INSN_READ_X | MIPS16_INSN_READ_31)))
@


1.572
log
@gas/
	* config/tc-mips.c (match_save_restore_list_operand): Avoid -Wformat
	error with older GCCs.
	(mips16_macro_build): Dereference args.
@
text
@a3399 26
/* This function returns true if modifying a register requires a
   delay.  */

static int
reg_needs_delay (unsigned int reg)
{
  unsigned long prev_pinfo;

  prev_pinfo = history[0].insn_mo->pinfo;
  if (! mips_opts.noreorder
      && (((prev_pinfo & INSN_LOAD_MEMORY_DELAY)
	   && ! gpr_interlocks)
	  || ((prev_pinfo & INSN_LOAD_COPROC_DELAY)
	      && ! cop_interlocks)))
    {
      /* A load from a coprocessor or from memory.  All load delays
	 delay the use of general register rt for one instruction.  */
      /* Itbl support may require additional care here.  */
      know (prev_pinfo & INSN_WRITE_GPR_T);
      if (reg == EXTRACT_OPERAND (mips_opts.micromips, RT, history[0]))
	return 1;
    }

  return 0;
}

d5058 17
d5111 2
a5112 4
  /* This function needs to know which pinfo flags are set for INSN2
     and which registers INSN2 uses.  The former is stored in PINFO2 and
     the latter is tested via INSN2_USES_GPR.  If INSN2 is null, PINFO2
     will have every flag set and INSN2_USES_GPR will always return true.  */
a5115 3
#define INSN2_USES_GPR(REG) \
  (insn2 == NULL || (gpr_read_mask (insn2) & (1U << (REG))) != 0)

d5131 1
a5131 1
      && INSN2_USES_GPR (EXTRACT_OPERAND (0, RD, *insn1)))
d5174 1
a5174 2
	  know (pinfo1 & INSN_WRITE_GPR_T);
	  if (INSN2_USES_GPR (EXTRACT_OPERAND (0, RT, *insn1)))
a5224 2
#undef INSN2_USES_GPR

@


1.571
log
@gas/
	* config/tc-mips.c (mips_prefer_vec_regno, mips_parse_register):
	New functions, split out from...
	(reg_lookup): ...here.  Remove itbl support.
	(reglist_lookup): Delete.
	(mips_operand_token_type): New enum.
	(mips_operand_token): New structure.
	(mips_operand_tokens): New variable.
	(mips_add_token, mips_parse_base_start, mips_parse_argument_token)
	(mips_parse_arguments): New functions.
	(md_begin): Initialize mips_operand_tokens.
	(mips_arg_info): Add a token field.  Remove optional_reg field.
	(match_char, match_expression): New functions.
	(match_const_int): Use match_expression.  Remove "s" argument
	and return a boolean result.  Remove O_register handling.
	(match_regno, match_reg, match_reg_range): New functions.
	(match_int_operand, match_mapped_int_operand, match_msb_operand)
	(match_reg_operand, match_reg_pair_operand, match_perf_reg_operand)
	(match_addiusp_operand, match_clo_clz_dest_operand)
	(match_lwm_swm_list_operand, match_entry_exit_operand)
	(match_save_restore_list_operand, match_mdmx_imm_reg_operand)
	(match_tied_reg_operand): Remove "s" argument and return a boolean
	result.  Match tokens rather than text.  Update calls to
	match_const_int.  Rely on match_regno to call check_regno.
	(match_pcrel_operand, match_pc_operand): Replace "s" argument with
	"arg" argument.  Return a boolean result.
	(parse_float_constant): Replace with...
	(match_float_constant): ...this new function.
	(match_operand): Remove "s" argument and return a boolean result.
	Update calls to subfunctions.
	(mips_ip, mips16_ip): Call mips_parse_arguments.  Use match routines
	rather than string-parsing routines.  Update handling of optional
	registers for token scheme.

gas/testsuite/
	* gas/mips/vr5400-ill.s, gas/mips/vr5400-ill.l: Add some more cases.
	* gas/mips/micromips-ill.s, gas/mips/micromips-ill.l: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d4733 1
a4733 1
      as_bad (error);
d7017 1
a7017 1
	  insn_insert_operand (&insn, operand, va_arg (args, int));
@


1.570
log
@gas/
	* config/tc-mips.c (parse_float_constant): Split out from...
	(mips_ip): ...here.
@
text
@d2402 17
a2418 3
/* Check if S points at a valid register specifier according to TYPES.
   If so, then return 1, advance S to consume the specifier and store
   the register's number in REGNOP, otherwise return 0.  */
d2420 2
a2421 2
static int
reg_lookup (char **s, unsigned int types, unsigned int *regnop)
d2423 2
a2424 2
  symbolS *symbolP;
  char *e;
a2425 1
  int reg = -1;
d2428 1
a2428 1
  e = *s;
d2438 31
a2468 2
  /* Look for a register symbol.  */
  if ((symbolP = symbol_find (*s)) && S_GET_SEGMENT (symbolP) == reg_section)
d2470 33
a2502 24
      int r = S_GET_VALUE (symbolP);
      if (r & types)
	reg = r & RNUM_MASK;
      else if ((types & RTYPE_VEC) && (r & ~1) == (RTYPE_GP | 2))
	/* Convert GP reg $v0/1 to MDMX reg $v0/1!  */
	reg = (r & RNUM_MASK) - 2;
    }
  /* Else see if this is a register defined in an itbl entry.  */
  else if ((types & RTYPE_GP) && itbl_have_entries)
    {
      char *n = *s;
      unsigned long r;

      if (*n == '$')
	++n;
      if (itbl_get_reg_val (n, &r))
	reg = r & RNUM_MASK;
    }

  /* Advance to next token if a register was recognised.  */
  if (reg >= 0)
    *s = e;
  else if (types & RWARN)
    as_warn (_("Unrecognized register name `%s'"), *s);
d2504 54
a2557 4
  *e = save_c;
  if (regnop)
    *regnop = reg;
  return reg >= 0;
d2560 3
a2562 11
/* Check if S points at a valid register list according to TYPES.
   If so, then return 1, advance S to consume the list and store
   the registers present on the list as a bitmask of ones in REGLISTP,
   otherwise return 0.  A valid list comprises a comma-separated
   enumeration of valid single registers and/or dash-separated
   contiguous register ranges as determined by their numbers.

   As a special exception if one of s0-s7 registers is specified as
   the range's lower delimiter and s8 (fp) is its upper one, then no
   registers whose numbers place them between s7 and s8 (i.e. $24-$29)
   are selected; they have to be listed separately if needed.  */
d2564 2
a2565 2
static int
reglist_lookup (char **s, unsigned int types, unsigned int *reglistp)
d2567 1
a2567 6
  unsigned int reglist = 0;
  unsigned int lastregno;
  bfd_boolean ok = TRUE;
  unsigned int regmask;
  char *s_endlist = *s;
  char *s_reset = *s;
d2570 37
a2606 1
  while (reg_lookup (s, types, &regno))
d2608 27
a2634 2
      lastregno = regno;
      if (**s == '-')
d2636 24
a2659 6
	  (*s)++;
	  ok = reg_lookup (s, types, &lastregno);
	  if (ok && lastregno < regno)
	    ok = FALSE;
	  if (!ok)
	    break;
d2662 21
a2682 1
      if (lastregno == FP && regno >= S0 && regno <= S7)
d2684 2
a2685 2
	  lastregno = S7;
	  reglist |= 1 << FP;
d2687 16
a2702 4
      regmask = 1 << lastregno;
      regmask = (regmask << 1) - 1;
      regmask ^= (1 << regno) - 1;
      reglist |= regmask;
d2704 19
a2722 4
      s_endlist = *s;
      if (**s != ',')
	break;
      (*s)++;
d2724 2
a2725 8

  if (ok)
    *s = s_endlist;
  else
    *s = s_reset;
  if (reglistp)
    *reglistp = reglist;
  return ok && reglist != 0;
d3083 2
d3905 3
a3941 5
  /* When true, the OP_REG match routine should assume that another operand
     appears after this one.  It should fail the match if the register it
     sees is at the end of the argument list.  */
  bfd_boolean optional_reg;

d3946 61
a4006 4
/* Match a constant integer at S for ARG.  Return null if the match failed.
   Otherwise return the end of the matched string and store the constant value
   in *VALUE.  In the latter case, use FALLBACK as the value if the match
   succeeded with an error.  */
d4008 2
a4009 3
static char *
match_const_int (struct mips_arg_info *arg, char *s, offsetT *value,
		 offsetT fallback)
a4012 1
  int num_relocs;
d4014 2
a4015 9
  num_relocs = my_getSmallExpression (&ex, r, s);
  if (*s == '(' && ex.X_op == O_register)
    {
      /* Assume that the constant has been elided and that S is a base
	 register.  The rest of the match will fail if the assumption
	 turns out to be wrong.  */
      *value = 0;
      return s;
    }
d4017 1
a4017 1
  if (num_relocs == 0 && ex.X_op == O_constant)
d4021 2
a4022 4
      /* If we got a register rather than an expression, the default
	 "Invalid operands" style of error seems more appropriate.  */
      if (arg->soft_match || ex.X_op == O_register)
	return 0;
d4027 1
a4027 1
  return expr_end;
d4114 59
d4175 1
a4175 1
static char *
d4177 1
a4177 1
		   const struct mips_operand *operand_base, char *s)
d4193 9
a4201 5
  if (operand_base->lsb == 0
      && operand_base->size == 16
      && operand->shift == 0
      && operand->bias == 0
      && (operand->max_val == 32767 || operand->max_val == 65535))
d4204 4
a4207 4
      offset_reloc[0] = BFD_RELOC_LO16;
      offset_reloc[1] = BFD_RELOC_UNUSED;
      offset_reloc[2] = BFD_RELOC_UNUSED;
      if (my_getSmallExpression (&offset_expr, offset_reloc, s) > 0)
d4211 3
a4213 7
	return expr_end;
      if (*s == '(' && offset_expr.X_op == O_register)
	/* Assume that the constant has been elided and that S is a base
	   register.  The rest of the match will fail if the assumption
	   turns out to be wrong.  */
	sval = 0;
      else
d4215 6
a4220 6
	  s = expr_end;
	  if (offset_expr.X_op != O_constant)
	    /* If non-constant operands are allowed then leave them for
	       the caller to process, otherwise fail the match.  */
	    return arg->allow_nonconst ? s : 0;
	  sval = offset_expr.X_add_number;
d4222 1
d4225 1
a4225 1
      offset_reloc[0] = BFD_RELOC_UNUSED;
d4230 2
a4231 3
      s = match_const_int (arg, s, &sval, min_val);
      if (!s)
	return 0;
d4247 1
a4247 1
	return 0;
d4255 1
a4255 1
	return 0;
d4292 1
a4292 1
  return s;
d4297 1
a4297 1
static char *
d4299 1
a4299 1
			  const struct mips_operand *operand_base, char *s)
d4306 2
a4307 3
  s = match_const_int (arg, s, &sval, operand->int_map[0]);
  if (!s)
    return 0;
d4314 1
a4314 1
    return 0;
d4317 1
a4317 1
  return s;
d4322 1
a4322 1
static char *
d4324 1
a4324 1
		   const struct mips_operand *operand_base, char *s)
d4335 2
a4336 3
  s = match_const_int (arg, s, &size, 1);
  if (!s)
    return 0;
d4344 1
a4344 1
	return 0;
d4349 1
a4349 1
  return s;
d4354 1
a4354 1
static char *
d4356 1
a4356 1
		   const struct mips_operand *operand_base, char *s)
d4359 1
a4359 1
  unsigned int regno, uval, num_vals, types;
d4362 2
a4363 7
  types = convert_reg_type (arg->insn->insn_mo, operand->reg_type);
  if (!reg_lookup (&s, types, &regno))
    return 0;

  SKIP_SPACE_TABS (s);
  if (arg->optional_reg && *s == 0)
    return 0;
d4372 1
a4372 1
	return 0;
a4376 1
  check_regno (arg, operand->reg_type, regno);
d4381 1
a4381 1
  return s;
d4386 1
a4386 1
static char *
d4388 1
a4388 1
			const struct mips_operand *operand_base, char *s)
d4391 1
a4391 1
  unsigned int regno1, regno2, uval, num_vals, types;
d4394 4
a4397 12
  types = convert_reg_type (arg->insn->insn_mo, operand->reg_type);

  if (!reg_lookup (&s, types, &regno1))
    return 0;

  SKIP_SPACE_TABS (s);
  if (*s++ != ',')
    return 0;
  arg->argnum += 1;

  if (!reg_lookup (&s, types, &regno2))
    return 0;
d4404 1
a4404 1
    return 0;
a4405 2
  check_regno (arg, operand->reg_type, regno1);
  check_regno (arg, operand->reg_type, regno2);
d4407 1
a4407 1
  return s;
d4412 2
a4413 2
static char *
match_pcrel_operand (char *s)
d4415 3
a4417 2
  my_getExpression (&offset_expr, s);
  return expr_end;
d4422 1
a4422 1
static char *
d4424 1
a4424 1
			const struct mips_operand *operand, char *s)
d4428 2
a4429 3
  s = match_const_int (arg, s, &sval, 0);
  if (!s)
    return 0;
d4438 1
a4438 1
	return 0;
d4443 1
a4443 1
  return s;
d4448 1
a4448 1
static char *
d4450 1
a4450 1
		       const struct mips_operand *operand, char *s)
d4455 2
a4456 3
  s = match_const_int (arg, s, &sval, -256);
  if (!s)
    return 0;
d4459 1
a4459 1
    return 0;
d4463 1
a4463 1
    return 0;
d4468 1
a4468 1
  return s;
d4473 1
a4473 1
static char *
d4475 1
a4475 1
			    const struct mips_operand *operand, char *s)
d4479 2
a4480 2
  if (!reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno))
    return 0;
a4481 1
  check_regno (arg, OP_REG_GP, regno);
d4483 1
a4483 1
  return s;
d4488 1
a4488 1
static char *
d4490 1
a4490 1
			    const struct mips_operand *operand, char *s)
d4492 2
a4493 1
  unsigned int reglist, sregs, ra;
d4495 16
a4510 2
  if (!reglist_lookup (&s, RTYPE_NUM | RTYPE_GP, &reglist))
    return 0;
d4522 1
a4522 1
	return 0;
d4541 1
a4541 1
	return 0;
d4548 1
a4548 1
    return 0;
d4551 1
a4551 1
  return s;
d4556 1
a4556 1
static char *
d4558 1
a4558 1
			  const struct mips_operand *operand, char *s)
d4567 1
a4567 1
  for (;;)
d4572 1
a4572 1
      if (reg_lookup (&s, RTYPE_GP | RTYPE_NUM, &regno1))
d4574 1
a4574 1
      else if (reg_lookup (&s, RTYPE_FPU, &regno1))
d4577 1
a4577 14
	return 0;

      SKIP_SPACE_TABS (s);
      if (*s == '-')
	{
	  ++s;
	  SKIP_SPACE_TABS (s);
	  if (!reg_lookup (&s, (is_freg ? RTYPE_FPU
				: RTYPE_GP | RTYPE_NUM), &regno2))
	    return 0;
	  SKIP_SPACE_TABS (s);
	}
      else
	regno2 = regno1;
d4591 3
a4593 1
	return 0;
a4594 8
      if (!*s)
	break;
      if (*s != ',')
	return 0;
      arg->argnum += 1;
      ++s;
      SKIP_SPACE_TABS (s);
    }
d4596 1
a4596 1
  return s;
d4601 2
a4602 2
static char *
match_save_restore_list_operand (struct mips_arg_info *arg, char *s)
a4605 1
  expressionS value;
d4616 1
a4616 1
  for (;;)
d4620 1
a4620 2
      my_getExpression (&value, s);
      if (value.X_op == O_constant)
d4623 2
a4625 3
	  frame_size = value.X_add_number;
	  s = expr_end;
	  SKIP_SPACE_TABS (s);
d4629 2
a4630 15
	  if (!reg_lookup (&s, RTYPE_GP | RTYPE_NUM, &regno1))
	    return 0;

	  SKIP_SPACE_TABS (s);
	  if (*s == '-')
	    {
	      ++s;
	      SKIP_SPACE_TABS (s);
	      if (!reg_lookup (&s, RTYPE_GP | RTYPE_NUM, &regno2)
		  || regno2 < regno1)
		return 0;
	      SKIP_SPACE_TABS (s);
	    }
	  else
	    regno2 = regno1;
d4653 1
a4653 1
		return 0;
a4658 7
      if (!*s)
	break;
      if (*s != ',')
	return 0;
      arg->argnum += 1;
      ++s;
      SKIP_SPACE_TABS (s);
d4660 1
d4664 1
a4664 1
    return 0;
d4681 1
a4681 1
	return 0;
d4691 1
a4691 1
	return 0;
d4712 1
a4712 1
    return 0;
d4732 1
a4732 1
	return 0;
d4740 1
a4740 1
  return s;
d4745 1
a4745 1
static char *
d4747 1
a4747 1
			    const struct mips_operand *operand, char *s)
d4749 1
a4749 1
  unsigned int regno, uval, types;
d4759 1
a4759 2
  types = convert_reg_type (arg->insn->insn_mo, OP_REG_VEC);
  if (reg_lookup (&s, types, &regno))
d4765 1
a4765 1
	    return 0;
d4772 1
a4772 2
      SKIP_SPACE_TABS (s);
      if (*s == '[')
d4774 4
a4777 10
	  /* Read the element number.  */
	  expressionS value;

	  ++s;
	  SKIP_SPACE_TABS (s);
	  my_getExpression (&value, s);
	  s = expr_end;
	  if (value.X_op != O_constant
	      || value.X_add_number < 0
	      || value.X_add_number > (is_qh ? 3 : 7))
d4780 1
a4780 1
		return 0;
a4781 1
	      value.X_add_number = 0;
a4782 4
	  uval |= (unsigned int) value.X_add_number << (is_qh ? 2 : 1) << 5;
	  SKIP_SPACE_TABS (s);
	  if (*s == ']')
	    ++s;
d4784 1
a4784 5
	    {
	      if (arg->soft_match)
		return 0;
	      as_bad (_("Expecting ']' found '%s'"), s);
	    }
d4794 1
a4794 1
		return 0;
d4799 2
a4805 1
      check_regno (arg, OP_REG_FP, regno);
d4807 1
d4813 2
a4814 3
      s = match_const_int (arg, s, &sval, 0);
      if (!s)
	return 0;
d4818 1
a4818 1
	    return 0;
d4828 1
a4828 1
  return s;
d4833 2
a4834 2
static char *
match_pc_operand (char *s)
d4836 6
a4841 5
  if (strncmp (s, "$pc", 3) != 0)
    return 0;
  s += 3;
  SKIP_SPACE_TABS (s);
  return s;
d4847 2
a4848 3
static char *
match_tied_reg_operand (struct mips_arg_info *arg, char *s,
			unsigned int other_regno)
d4852 1
a4852 7
  if (!reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno)
      || regno != other_regno)
    return 0;
  SKIP_SPACE_TABS (s);
  if (arg->optional_reg && *s == 0)
    return 0;
  return s;
d4876 3
a4878 3
static char *
parse_float_constant (char *s, expressionS *imm, expressionS *offset,
		      int length, bfd_boolean using_gprs)
d4880 1
a4880 3
  char *save_in, *p, *err;
  unsigned char data[8];
  int atof_length;
d4884 1
d4896 6
a4901 12
  save_in = input_line_pointer;
  input_line_pointer = s;
  err = md_atof (length == 8 ? 'd' : 'f', (char *) data, &atof_length);
  s = input_line_pointer;
  input_line_pointer = save_in;
  if (err && *err)
    {
      as_bad (_("Bad floating point constant: %s"), err);
      memset (data, '\0', sizeof (data));
    }
  else
    gas_assert (atof_length == length);
d4916 1
a4916 1
      return s;
d4964 1
a4964 1
      return s;
d5006 1
a5006 1
  return s;
d5012 1
a5012 1
static char *
d5014 1
a5014 1
	       const struct mips_operand *operand, char *s)
d5019 1
a5019 1
      return match_int_operand (arg, operand, s);
d5022 1
a5022 1
      return match_mapped_int_operand (arg, operand, s);
d5025 1
a5025 1
      return match_msb_operand (arg, operand, s);
d5028 1
a5028 1
      return match_reg_operand (arg, operand, s);
d5031 1
a5031 1
      return match_reg_pair_operand (arg, operand, s);
d5034 1
a5034 1
      return match_pcrel_operand (s);
d5037 1
a5037 1
      return match_perf_reg_operand (arg, operand, s);
d5040 1
a5040 1
      return match_addiusp_operand (arg, operand, s);
d5043 1
a5043 1
      return match_clo_clz_dest_operand (arg, operand, s);
d5046 1
a5046 1
      return match_lwm_swm_list_operand (arg, operand, s);
d5049 1
a5049 1
      return match_entry_exit_operand (arg, operand, s);
d5052 1
a5052 1
      return match_save_restore_list_operand (arg, s);
d5055 1
a5055 1
      return match_mdmx_imm_reg_operand (arg, operand, s);
d5058 1
a5058 1
      return match_tied_reg_operand (arg, s, arg->dest_regno);
d5061 1
a5061 1
      return match_tied_reg_operand (arg, s, arg->last_regno);
d5064 1
a5064 1
      return match_pc_operand (s);
a12039 1
  char *s;
a12042 1
  char *argsStart;
d12046 1
d12050 2
d12108 10
a12123 1
  argsStart = s = str + end;
d12161 1
d12190 1
d12198 1
a12198 2
	  SKIP_SPACE_TABS (s);
	  if (*s == 0)
d12210 1
a12211 1
		    s = argsStart;
d12233 1
d12244 3
a12246 6
	      if (*s != *args)
		break;
	      if (*s == ',')
		arg.argnum += 1;
	      ++s;
	      continue;
a12251 1
	  arg.optional_reg = FALSE;
d12253 1
d12281 4
a12284 4
		  my_getExpression (&imm2_expr, s);
		  if (imm2_expr.X_op != O_big
		      && imm2_expr.X_op != O_constant)
		  insn_error = _("absolute expression required");
a12286 1
		  s = expr_end;
d12336 1
a12336 1
	      arg.optional_reg = (args[1] == ',');
d12340 3
a12342 3
	      my_getExpression (&imm_expr, s);
	      if (imm_expr.X_op != O_big
		  && imm_expr.X_op != O_constant)
a12345 1
	      s = expr_end;
d12349 1
a12349 2
	      my_getSmallExpression (&offset_expr, offset_reloc, s);
	      if (offset_expr.X_op == O_register)
d12357 2
d12360 1
a12360 4
		{
		  normalize_address_expr (&offset_expr);
		  s = expr_end;
		}
d12364 3
a12366 1
	      s = parse_float_constant (s, &imm_expr, &offset_expr, 8, TRUE);
d12370 3
a12372 1
	      s = parse_float_constant (s, &imm_expr, &offset_expr, 8, FALSE);
d12376 3
a12378 1
	      s = parse_float_constant (s, &imm_expr, &offset_expr, 4, TRUE);
d12382 3
a12384 1
	      s = parse_float_constant (s, &imm_expr, &offset_expr, 4, FALSE);
d12433 1
a12433 1
		  arg.optional_reg = (args[2] == ',');
d12455 3
a12457 2
	  s = match_operand (&arg, operand, s);
	  if (!s && arg.optional_reg)
d12461 1
a12461 1
	      arg.optional_reg = FALSE;
a12462 3
	      s = argsStart;
	      SKIP_SPACE_TABS (s);
	      s = match_operand (&arg, operand, s);
d12464 2
a12465 1
	  if (!s)
a12474 1
      s = argsStart;
d12489 1
a12503 2
  char *argsstart;
  size_t i;
d12507 2
d12555 4
a12558 1
  argsstart = s;
d12588 1
d12604 1
d12614 1
a12614 2
	  SKIP_SPACE_TABS (s);
	  if (*s == 0)
d12625 1
a12626 1
		    s = argsstart;
d12663 1
d12674 3
a12676 6
	      if (*s != *args)
		break;
	      if (*s == ',')
		arg.argnum += 1;
	      ++s;
	      continue;
d12680 1
a12680 1
	  arg.optional_reg = FALSE;
d12686 1
a12686 1
	      arg.optional_reg = (args[1] == ',');
d12698 3
a12700 3
	      my_getExpression (&imm_expr, s);
	      if (imm_expr.X_op != O_big
		  && imm_expr.X_op != O_constant)
a12703 1
	      s = expr_end;
d12729 1
a12729 5
		  /* Parse the expression, allowing relocation operators.  */
		  i = my_getSmallExpression (&offset_expr, offset_reloc, s);
		  s = expr_end;

		  if (offset_expr.X_op == O_register)
d12731 4
a12734 10
		      /* Handle elided offsets, which are equivalent to 0.  */
		      if (*s == '(')
			{
			  offset_expr.X_op = O_constant;
			  offset_expr.X_add_number = 0;
			  relax_char = c;
			  continue;
			}
		      /* Fail the match.  */
		      break;
d12736 7
d12745 2
a12746 1
		  if (i > 0 && (ext_operand->size != 16 || c == '8'))
d12748 1
d12754 3
a12756 2
	  s = match_operand (&arg, operand, s);
	  if (!s && arg.optional_reg)
d12760 1
a12760 1
	      arg.optional_reg = FALSE;
a12761 3
	      s = argsstart;
	      SKIP_SPACE_TABS (s);
	      s = match_operand (&arg, operand, s);
d12763 2
a12764 1
	  if (!s)
a12772 1
	  s = argsstart;
d12778 1
@


1.569
log
@gas/
	* config/tc-mips.c (INSERT_BITS, INSERT_OPERAND, MIPS16_INSERT_OPERAND):
	Delete.
@
text
@d4610 161
d12121 3
d12125 3
d12129 3
d12133 1
a12133 163
	      {
		int f64;
		int using_gprs;
		char *save_in;
		char *err;
		unsigned char temp[8];
		int len;
		unsigned int length;
		segT seg;
		subsegT subseg;
		char *p;

		/* These only appear as the last operand in an
		   instruction, and every instruction that accepts
		   them in any variant accepts them in all variants.
		   This means we don't have to worry about backing out
		   any changes if the instruction does not match.

		   The difference between them is the size of the
		   floating point constant and where it goes.  For 'F'
		   and 'L' the constant is 64 bits; for 'f' and 'l' it
		   is 32 bits.  Where the constant is placed is based
		   on how the MIPS assembler does things:
		    F -- .rdata
		    L -- .lit8
		    f -- immediate value
		    l -- .lit4

		    The .lit4 and .lit8 sections are only used if
		    permitted by the -G argument.

		    The code below needs to know whether the target register
		    is 32 or 64 bits wide.  It relies on the fact 'f' and
		    'F' are used with GPR-based instructions and 'l' and
		    'L' are used with FPR-based instructions.  */

		f64 = *args == 'F' || *args == 'L';
		using_gprs = *args == 'F' || *args == 'f';

		save_in = input_line_pointer;
		input_line_pointer = s;
		err = md_atof (f64 ? 'd' : 'f', (char *) temp, &len);
		length = len;
		s = input_line_pointer;
		input_line_pointer = save_in;
		if (err != NULL && *err != '\0')
		  {
		    as_bad (_("Bad floating point constant: %s"), err);
		    memset (temp, '\0', sizeof temp);
		    length = f64 ? 8 : 4;
		  }

		gas_assert (length == (unsigned) (f64 ? 8 : 4));

		if (*args == 'f'
		    || (*args == 'l'
			&& (g_switch_value < 4
			    || (temp[0] == 0 && temp[1] == 0)
			    || (temp[2] == 0 && temp[3] == 0))))
		  {
		    imm_expr.X_op = O_constant;
		    if (!target_big_endian)
		      imm_expr.X_add_number = bfd_getl32 (temp);
		    else
		      imm_expr.X_add_number = bfd_getb32 (temp);
		  }
		else if (length > 4
			 && !mips_disable_float_construction
			 /* Constants can only be constructed in GPRs and
			    copied to FPRs if the GPRs are at least as wide
			    as the FPRs.  Force the constant into memory if
			    we are using 64-bit FPRs but the GPRs are only
			    32 bits wide.  */
			 && (using_gprs
			     || !(HAVE_64BIT_FPRS && HAVE_32BIT_GPRS))
			 && ((temp[0] == 0 && temp[1] == 0)
			     || (temp[2] == 0 && temp[3] == 0))
			 && ((temp[4] == 0 && temp[5] == 0)
			     || (temp[6] == 0 && temp[7] == 0)))
		  {
		    /* The value is simple enough to load with a couple of
		       instructions.  If using 32-bit registers, set
		       imm_expr to the high order 32 bits and offset_expr to
		       the low order 32 bits.  Otherwise, set imm_expr to
		       the entire 64 bit constant.  */
		    if (using_gprs ? HAVE_32BIT_GPRS : HAVE_32BIT_FPRS)
		      {
			imm_expr.X_op = O_constant;
			offset_expr.X_op = O_constant;
			if (!target_big_endian)
			  {
			    imm_expr.X_add_number = bfd_getl32 (temp + 4);
			    offset_expr.X_add_number = bfd_getl32 (temp);
			  }
			else
			  {
			    imm_expr.X_add_number = bfd_getb32 (temp);
			    offset_expr.X_add_number = bfd_getb32 (temp + 4);
			  }
			if (offset_expr.X_add_number == 0)
			  offset_expr.X_op = O_absent;
		      }
		    else
		      {
			imm_expr.X_op = O_constant;
			if (!target_big_endian)
			  imm_expr.X_add_number = bfd_getl64 (temp);
			else
			  imm_expr.X_add_number = bfd_getb64 (temp);
		      }
		  }
		else
		  {
		    const char *newname;
		    segT new_seg;

		    /* Switch to the right section.  */
		    seg = now_seg;
		    subseg = now_subseg;
		    switch (*args)
		      {
		      default: /* unused default case avoids warnings.  */
		      case 'L':
			newname = RDATA_SECTION_NAME;
			if (g_switch_value >= 8)
			  newname = ".lit8";
			break;
		      case 'F':
			newname = RDATA_SECTION_NAME;
			break;
		      case 'l':
			gas_assert (g_switch_value >= 4);
			newname = ".lit4";
			break;
		      }
		    new_seg = subseg_new (newname, (subsegT) 0);
		    bfd_set_section_flags (stdoutput, new_seg,
					   (SEC_ALLOC
					    | SEC_LOAD
					    | SEC_READONLY
					    | SEC_DATA));
		    frag_align (*args == 'l' ? 2 : 3, 0, 0);
		    if (strncmp (TARGET_OS, "elf", 3) != 0)
		      record_alignment (new_seg, 4);
		    else
		      record_alignment (new_seg, *args == 'l' ? 2 : 3);
		    if (seg == now_seg)
		      as_bad (_("Can't use floating point insn in this section"));

		    /* Set the argument to the current address in the
		       section.  */
		    offset_expr.X_op = O_symbol;
		    offset_expr.X_add_symbol = symbol_temp_new_now ();
		    offset_expr.X_add_number = 0;

		    /* Put the floating point number into the section.  */
		    p = frag_more ((int) length);
		    memcpy (p, temp, length);

		    /* Switch back to the original section.  */
		    subseg_set (seg, subseg);
		  }
	      }
@


1.568
log
@gas/
	* config/tc-mips.c (mips32_to_16_reg_map): Delete.
	(match_entry_exit_operand): New function.
	(match_save_restore_list_operand): Likewise.
	(match_operand): Use them.
	(check_absolute_expr): Delete.
	(mips16_ip): Rewrite main parsing loop to use mips_operands.
@
text
@a1110 6
/* Replace bits MASK << SHIFT of STRUCT with the equivalent bits in
   VALUE << SHIFT.  VALUE is evaluated exactly once.  */
#define INSERT_BITS(STRUCT, VALUE, MASK, SHIFT) \
  (STRUCT) = (((STRUCT) & ~((MASK) << (SHIFT))) \
	      | (((VALUE) & (MASK)) << (SHIFT)))

a1115 19
/* Change INSN's opcode so that the operand given by FIELD has value VALUE.
   INSN is a mips_cl_insn structure and VALUE is evaluated exactly once.

   include/opcode/mips.h specifies operand fields using the macros
   OP_MASK_<FIELD> and OP_SH_<FIELD>.  The MIPS16 equivalents start
   with "MIPS16OP" instead of "OP".  */
#define INSERT_OPERAND(MICROMIPS, FIELD, INSN, VALUE) \
  do \
    if (!(MICROMIPS)) \
      INSERT_BITS ((INSN).insn_opcode, VALUE, \
		   OP_MASK_##FIELD, OP_SH_##FIELD); \
    else \
      INSERT_BITS ((INSN).insn_opcode, VALUE, \
		   MICROMIPSOP_MASK_##FIELD, MICROMIPSOP_SH_##FIELD); \
  while (0)
#define MIPS16_INSERT_OPERAND(FIELD, INSN, VALUE) \
  INSERT_BITS ((INSN).insn_opcode, VALUE, \
		MIPS16OP_MASK_##FIELD, MIPS16OP_SH_##FIELD)

@


1.567
log
@gas/
	* config/tc-mips.c: Enable functions commented out in previous patch.
	(SKIP_SPACE_TABS): Move further up file.
	(mips32_to_micromips_reg_b_map, mips32_to_micromips_reg_c_map)
	(mips32_to_micromips_reg_d_map, mips32_to_micromips_reg_e_map)
	(ips32_to_micromips_reg_f_map, mips32_to_micromips_reg_g_map)
	(mips32_to_micromips_reg_l_map, mips32_to_micromips_reg_m_map)
	(mips32_to_micromips_reg_q_map, mips32_to_micromips_reg_n_map)
	(micromips_imm_b_map, micromips_imm_c_map): Delete.
	(mips_lookup_reg_pair): Delete.
	(macro): Use report_bad_range and report_bad_field.
	(mips_immed, expr_const_in_range): Delete.
	(mips_ip): Rewrite main parsing loop to use new functions.

gas/testsuite/
	* gas/mips/at-2.l: Remove duplicated $at warnings.
	* gas/mips/ext-ill.l, gas/mips/lui-1.l, gas/mips/mips32r2-ill.l,
	gas/mips/mips32r2-ill-nofp.l, gas/mips/mips32r2-ill-fp64.l,
	gas/mips/mips64r2-ill.l, gas/mips/octeon-ill.l: Update error
	messages.  Expect negative numbers to be printed as such,
	rather than as large unsigned positive numbers.
@
text
@a757 12
/* Map normal MIPS register numbers to mips16 register numbers.  */

#define X ILLEGAL_REG
static const int mips32_to_16_reg_map[] =
{
  X, X, 2, 3, 4, 5, 6, 7,
  X, X, X, X, X, X, X, X,
  0, 1, X, X, X, X, X, X,
  X, X, X, X, X, X, X, X
};
#undef X

d4271 230
d4675 2
d4678 1
a4678 1
      abort ();
a6795 15
/* Warn if an expression is not a constant.  */

static void
check_absolute_expr (struct mips_cl_insn *ip, expressionS *ex)
{
  if (ex->X_op == O_big)
    as_bad (_("unsupported large constant"));
  else if (ex->X_op != O_constant)
    as_bad (_("Instruction %s requires absolute expression"),
	    ip->insn_mo->name);

  if (HAVE_32BIT_GPRS)
    normalize_constant_expr (ex);
}

a12271 3
  unsigned int regno;
  unsigned int lastregno = 0;
  char *s_reset;
d12273 3
d12326 1
d12332 2
d12336 1
a12336 2
	  if (insn + 1 < &mips16_opcodes[bfd_mips16_num_opcodes]
	      && strcmp (insn->name, insn[1].name) == 0)
d12364 8
d12376 2
a12377 9
	  if (*s == ' ')
	    ++s;

	  /* In this switch statement we call break if we did not find
             a match, continue if we did find a match, or return if we
             are done.  */

	  c = *args;
	  switch (c)
d12379 1
a12379 4
	    case '\0':
	      if (*s == '\0')
		{
		  offsetT value;
d12381 11
a12391 26
		  /* Stuff the immediate value in now, if we can.  */
		  if (insn->pinfo == INSN_MACRO)
		    {
		      gas_assert (relax_char == 0);
		      gas_assert (*offset_reloc == BFD_RELOC_UNUSED);
		    }
		  else if (relax_char
			   && offset_expr.X_op == O_constant
			   && calculate_reloc (*offset_reloc,
					       offset_expr.X_add_number,
					       &value))
		    {
		      mips16_immed (NULL, 0, relax_char, *offset_reloc, value,
				    forced_insn_length, &ip->insn_opcode);
		      offset_expr.X_op = O_absent;
		      *offset_reloc = BFD_RELOC_UNUSED;
		    }
		  else if (relax_char && *offset_reloc != BFD_RELOC_UNUSED)
		    {
		      if (forced_insn_length == 2)
			as_bad (_("invalid unextended operand value"));
		      forced_insn_length = 4;
		      ip->insn_opcode |= MIPS16_EXTEND;
		    }
		  else if (relax_char)
		    *offset_reloc = (int) BFD_RELOC_UNUSED + relax_char;
d12393 3
a12395 3
		  return;
		}
	      break;
d12397 3
a12399 5
	    case ',':
	      if (*s++ == c)
		continue;
	      s--;
	      switch (*++args)
d12401 2
a12402 6
		case 'v':
		  MIPS16_INSERT_OPERAND (RX, *ip, lastregno);
		  continue;
		case 'w':
		  MIPS16_INSERT_OPERAND (RY, *ip, lastregno);
		  continue;
d12404 5
a12408 11
	      break;

	    case '(':
	    case ')':
	      if (*s++ == c)
		continue;
	      break;

	    case 'v':
	    case 'w':
	      if (s[0] != '$')
d12410 4
a12413 6
		  if (c == 'v')
		    MIPS16_INSERT_OPERAND (RX, *ip, lastregno);
		  else
		    MIPS16_INSERT_OPERAND (RY, *ip, lastregno);
		  ++args;
		  continue;
d12415 1
a12415 12
	      /* Fall through.  */
	    case 'x':
	    case 'y':
	    case 'z':
	    case 'Z':
	    case '0':
	    case 'S':
	    case 'R':
	    case 'X':
	    case 'Y':
  	      s_reset = s;
	      if (!reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno))
d12417 4
a12420 10
		  if (c == 'v' || c == 'w')
		    {
		      if (c == 'v')
			MIPS16_INSERT_OPERAND (RX, *ip, lastregno);
		      else
			MIPS16_INSERT_OPERAND (RY, *ip, lastregno);
		      ++args;
		      continue;
		    }
		  break;
d12422 2
d12425 3
a12427 11
	      if (*s == ' ')
		++s;
	      if (args[1] != *s)
		{
		  if (c == 'v' || c == 'w')
		    {
		      regno = mips16_to_32_reg_map[lastregno];
		      s = s_reset;
		      ++args;
		    }
		}
d12429 3
a12431 10
	      switch (c)
		{
		case 'x':
		case 'y':
		case 'z':
		case 'v':
		case 'w':
		case 'Z':
		  regno = mips32_to_16_reg_map[regno];
		  break;
d12433 4
a12436 32
		case '0':
		  if (regno != 0)
		    regno = ILLEGAL_REG;
		  break;

		case 'S':
		  if (regno != SP)
		    regno = ILLEGAL_REG;
		  break;

		case 'R':
		  if (regno != RA)
		    regno = ILLEGAL_REG;
		  break;

		case 'X':
		case 'Y':
		  if (regno == AT && mips_opts.at)
		    {
		      if (mips_opts.at == ATREG)
			as_warn (_("used $at without \".set noat\""));
		      else
			as_warn (_("used $%u with \".set at=$%u\""),
				 regno, mips_opts.at);
		    }
		  break;

		default:
		  abort ();
		}

	      if (regno == ILLEGAL_REG)
d12438 3
a12440 32

	      switch (c)
		{
		case 'x':
		case 'v':
		  MIPS16_INSERT_OPERAND (RX, *ip, regno);
		  break;
		case 'y':
		case 'w':
		  MIPS16_INSERT_OPERAND (RY, *ip, regno);
		  break;
		case 'z':
		  MIPS16_INSERT_OPERAND (RZ, *ip, regno);
		  break;
		case 'Z':
		  MIPS16_INSERT_OPERAND (MOVE32Z, *ip, regno);
		case '0':
		case 'S':
		case 'R':
		  break;
		case 'X':
		  MIPS16_INSERT_OPERAND (REGR32, *ip, regno);
		  break;
		case 'Y':
		  regno = ((regno & 7) << 2) | ((regno & 0x18) >> 3);
		  MIPS16_INSERT_OPERAND (REG32R, *ip, regno);
		  break;
		default:
		  abort ();
		}

	      lastregno = regno;
d12442 1
d12444 8
a12451 6
	    case 'P':
	      if (strncmp (s, "$pc", 3) == 0)
		{
		  s += 3;
		  continue;
		}
a12453 52
	    case '5':
	    case 'H':
	    case 'W':
	    case 'D':
	    case 'j':
	    case 'V':
	    case 'C':
	    case 'U':
	    case 'k':
	    case 'K':
	      i = my_getSmallExpression (&offset_expr, offset_reloc, s);
	      if (i > 0)
		{
		  relax_char = c;
		  s = expr_end;
		  continue;
		}
	      *offset_reloc = BFD_RELOC_UNUSED;
	      /* Fall through.  */
	    case '<':
	    case '>':
	    case '[':
	    case ']':
	    case '4':
	    case '8':
	      my_getExpression (&offset_expr, s);
	      if (offset_expr.X_op == O_register)
		{
		  /* What we thought was an expression turned out to
                     be a register.  */

		  if (s[0] == '(' && args[1] == '(')
		    {
		      /* It looks like the expression was omitted
			 before a register indirection, which means
			 that the expression is implicitly zero.  We
			 still set up offset_expr, so that we handle
			 explicit extensions correctly.  */
		      offset_expr.X_op = O_constant;
		      offset_expr.X_add_number = 0;
		      relax_char = c;
		      continue;
		    }

		  break;
		}

	      /* We need to relax this instruction.  */
	      relax_char = c;
	      s = expr_end;
	      continue;

a12458 9
	      /* We use offset_reloc rather than imm_reloc for the PC
                 relative operands.  This lets macros with both
                 immediate and address operands work correctly.  */
	      my_getExpression (&offset_expr, s);

	      if (offset_expr.X_op == O_register)
		break;

	      /* We need to relax this instruction.  */
d12460 1
a12460 14
	      s = expr_end;
	      continue;

	    case '6':		/* break code */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > 63)
		as_warn (_("Invalid value for `%s' (%lu)"),
			 ip->insn_mo->name,
			 (unsigned long) imm_expr.X_add_number);
	      MIPS16_INSERT_OPERAND (IMM6, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;
d12472 1
a12472 1
	    case 'a':		/* 26 bit address */
a12473 2
	      my_getExpression (&offset_expr, s);
	      s = expr_end;
d12476 2
a12477 1
	      continue;
d12479 3
a12481 4
	    case 'l':		/* register list for entry macro */
	    case 'L':		/* register list for exit macro */
	      {
		int mask;
d12483 15
a12497 7
		if (c == 'l')
		  mask = 0;
		else
		  mask = 7 << 3;
		while (*s != '\0')
		  {
		    unsigned int freg, reg1, reg2;
d12499 19
a12517 226
		    while (*s == ' ' || *s == ',')
		      ++s;
		    if (reg_lookup (&s, RTYPE_GP | RTYPE_NUM, &reg1))
		      freg = 0;
		    else if (reg_lookup (&s, RTYPE_FPU, &reg1))
		      freg = 1;
		    else
		      {
			as_bad (_("can't parse register list"));
			break;
		      }
		    if (*s == ' ')
		      ++s;
		    if (*s != '-')
		      reg2 = reg1;
		    else
		      {
			++s;
			if (!reg_lookup (&s, freg ? RTYPE_FPU 
					 : (RTYPE_GP | RTYPE_NUM), &reg2))
			  {
			    as_bad (_("invalid register list"));
			    break;
			  }
		      }
		    if (freg && reg1 == 0 && reg2 == 0 && c == 'L')
		      {
			mask &= ~ (7 << 3);
			mask |= 5 << 3;
		      }
		    else if (freg && reg1 == 0 && reg2 == 1 && c == 'L')
		      {
			mask &= ~ (7 << 3);
			mask |= 6 << 3;
		      }
		    else if (reg1 == 4 && reg2 >= 4 && reg2 <= 7 && c != 'L')
		      mask |= (reg2 - 3) << 3;
		    else if (reg1 == 16 && reg2 >= 16 && reg2 <= 17)
		      mask |= (reg2 - 15) << 1;
		    else if (reg1 == RA && reg2 == RA)
		      mask |= 1;
		    else
		      {
			as_bad (_("invalid register list"));
			break;
		      }
		  }
		/* The mask is filled in in the opcode table for the
                   benefit of the disassembler.  We remove it before
                   applying the actual mask.  */
		ip->insn_opcode &= ~ ((7 << 3) << MIPS16OP_SH_IMM6);
		ip->insn_opcode |= mask << MIPS16OP_SH_IMM6;
	      }
	    continue;

	    case 'm':		/* Register list for save insn.  */
	    case 'M':		/* Register list for restore insn.  */
	      {
		int opcode = ip->insn_opcode;
		int framesz = 0, seen_framesz = 0;
		int nargs = 0, statics = 0, sregs = 0;

		while (*s != '\0')
		  {
		    unsigned int reg1, reg2;

		    SKIP_SPACE_TABS (s);
		    while (*s == ',')
		      ++s;
		    SKIP_SPACE_TABS (s);

		    my_getExpression (&imm_expr, s);
		    if (imm_expr.X_op == O_constant)
		      {
			/* Handle the frame size.  */
			if (seen_framesz)
			  {
			    as_bad (_("more than one frame size in list"));
			    break;
			  }
			seen_framesz = 1;
			framesz = imm_expr.X_add_number;
			imm_expr.X_op = O_absent;
			s = expr_end;
			continue;
		      }

		    if (! reg_lookup (&s, RTYPE_GP | RTYPE_NUM, &reg1))
		      {
			as_bad (_("can't parse register list"));
			break;
		      }

		    while (*s == ' ')
		      ++s;

		    if (*s != '-')
		      reg2 = reg1;
		    else
		      {
			++s;
			if (! reg_lookup (&s, RTYPE_GP | RTYPE_NUM, &reg2)
			    || reg2 < reg1)
			  {
			    as_bad (_("can't parse register list"));
			    break;
			  }
		      }

		    while (reg1 <= reg2)
		      {
			if (reg1 >= 4 && reg1 <= 7)
			  {
			    if (!seen_framesz)
				/* args $a0-$a3 */
				nargs |= 1 << (reg1 - 4);
			    else
				/* statics $a0-$a3 */
				statics |= 1 << (reg1 - 4);
			  }
			else if ((reg1 >= 16 && reg1 <= 23) || reg1 == 30)
			  {
			    /* $s0-$s8 */
			    sregs |= 1 << ((reg1 == 30) ? 8 : (reg1 - 16));
			  }
			else if (reg1 == 31)
			  {
			    /* Add $ra to insn.  */
			    opcode |= 0x40;
			  }
			else
			  {
			    as_bad (_("unexpected register in list"));
			    break;
			  }
			if (++reg1 == 24)
			  reg1 = 30;
		      }
		  }

		/* Encode args/statics combination.  */
		if (nargs & statics)
		  as_bad (_("arg/static registers overlap"));
		else if (nargs == 0xf)
		  /* All $a0-$a3 are args.  */
		  opcode |= MIPS16_ALL_ARGS << 16;
		else if (statics == 0xf)
		  /* All $a0-$a3 are statics.  */
		  opcode |= MIPS16_ALL_STATICS << 16;
		else 
		  {
		    int narg = 0, nstat = 0;

		    /* Count arg registers.  */
		    while (nargs & 0x1)
		      {
			nargs >>= 1;
			narg++;
		      }
		    if (nargs != 0)
		      as_bad (_("invalid arg register list"));

		    /* Count static registers.  */
		    while (statics & 0x8)
		      {
			statics = (statics << 1) & 0xf;
			nstat++;
		      }
		    if (statics != 0) 
		      as_bad (_("invalid static register list"));

		    /* Encode args/statics.  */
		    opcode |= ((narg << 2) | nstat) << 16;
		  }

		/* Encode $s0/$s1.  */
		if (sregs & (1 << 0))		/* $s0 */
		  opcode |= 0x20;
		if (sregs & (1 << 1))		/* $s1 */
		  opcode |= 0x10;
		sregs >>= 2;

		if (sregs != 0)
		  {
		    /* Count regs $s2-$s8.  */
		    int nsreg = 0;
		    while (sregs & 1)
		      {
			sregs >>= 1;
			nsreg++;
		      }
		    if (sregs != 0)
		      as_bad (_("invalid static register list"));
		    /* Encode $s2-$s8. */
		    opcode |= nsreg << 24;
		  }

		/* Encode frame size.  */
		if (!seen_framesz)
		  as_bad (_("missing frame size"));
		else if ((framesz & 7) != 0 || framesz < 0
			 || framesz > 0xff * 8)
		  as_bad (_("invalid frame size"));
		else if (framesz != 128 || (opcode >> 16) != 0)
		  {
		    framesz /= 8;
		    opcode |= (((framesz & 0xf0) << 16)
			     | (framesz & 0x0f));
		  }

		/* Finally build the instruction.  */
		if ((opcode >> 16) != 0 || framesz == 0)
		  opcode |= MIPS16_EXTEND;
		ip->insn_opcode = opcode;
	      }
	    continue;

	    case 'e':		/* extend code */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > 0x7ff)
		{
		  as_warn (_("Invalid value for `%s' (%lu)"),
			   ip->insn_mo->name,
			   (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= 0x7ff;
d12519 1
a12519 4
	      ip->insn_opcode |= imm_expr.X_add_number;
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;
d12521 10
a12530 2
	    default:
	      abort ();
d12532 3
a12534 1
	  break;
d12538 1
a12538 2
      if (insn + 1 < &mips16_opcodes[bfd_mips16_num_opcodes] &&
	  strcmp (insn->name, insn[1].name) == 0)
@


1.566
log
@gas/
	* config/tc-mips.c (mips_oddfpreg_ok): Move further up file.
	Change return type to bfd_boolean.
	(report_bad_range, report_bad_field): New functions.
	(mips_arg_info): New structure.
	(match_const_int, convert_reg_type, check_regno, match_int_operand)
	(match_mapped_int_operand, match_msb_operand, match_reg_operand)
	(match_reg_pair_operand, match_pcrel_operand, match_perf_reg_operand)
	(match_addiusp_operand, match_clo_clz_dest_operand)
	(match_lwm_swm_list_operand, match_mdmx_imm_reg_operand)
	(match_pc_operand, match_tied_reg_operand, match_operand)
	(check_completed_insn): New functions, commented out for now.
@
text
@d47 3
a776 32
/* Map normal MIPS register numbers to microMIPS register numbers.  */

#define mips32_to_micromips_reg_b_map	mips32_to_16_reg_map
#define mips32_to_micromips_reg_c_map	mips32_to_16_reg_map
#define mips32_to_micromips_reg_d_map	mips32_to_16_reg_map
#define mips32_to_micromips_reg_e_map	mips32_to_16_reg_map
#define mips32_to_micromips_reg_f_map	mips32_to_16_reg_map
#define mips32_to_micromips_reg_g_map	mips32_to_16_reg_map
#define mips32_to_micromips_reg_l_map	mips32_to_16_reg_map

#define X ILLEGAL_REG
/* reg type m: 0, 17, 2, 3, 16, 18, 19, 20.  */
static const int mips32_to_micromips_reg_m_map[] =
{
  0, X, 2, 3, X, X, X, X,
  X, X, X, X, X, X, X, X,
  4, 1, 5, 6, 7, X, X, X,
  X, X, X, X, X, X, X, X
};

/* reg type q: 0, 2-7. 17.  */
static const int mips32_to_micromips_reg_q_map[] =
{
  0, X, 2, 3, 4, 5, 6, 7,
  X, X, X, X, X, X, X, X,
  X, 1, X, X, X, X, X, X,
  X, X, X, X, X, X, X, X
};

#define mips32_to_micromips_reg_n_map  mips32_to_micromips_reg_m_map
#undef X

a811 12
/* microMIPS imm type B.  */
static const int micromips_imm_b_map[] =
{
  1, 4, 8, 12, 16, 20, 24, -1
};

/* microMIPS imm type C.  */
static const int micromips_imm_c_map[] =
{
  128, 1, 2, 3, 4, 7, 8, 15, 16, 31, 32, 63, 64, 255, 32768, 65535
};

a2556 13
static unsigned int
mips_lookup_reg_pair (unsigned int regno1, unsigned int regno2,
		      const unsigned int *map1, const unsigned int *map2,
		      unsigned int count)
{
  unsigned int i;

  for (i = 0; i < count; i++)
    if (map1[i] == regno1 && map2[i] == regno2)
      return i;
  return ILLEGAL_REG;
}

a3692 1
#if 0
a4488 1
#endif
d7993 1
a7993 1
	    as_bad (_("Improper position (%lu)"), (unsigned long) pos);
d7998 1
a7998 2
	    as_bad (_("Improper extract size (%lu, position %lu)"),
		    (unsigned long) size, (unsigned long) pos);
d8041 1
a8041 1
	    as_bad (_("Improper position (%lu)"), (unsigned long) pos);
d8046 1
a8046 2
	    as_bad (_("Improper insert size (%lu, position %lu)"),
		    (unsigned long) size, (unsigned long) pos);
a11445 27
/* UDI immediates.  */
struct mips_immed {
  char		type;
  unsigned int	shift;
  unsigned long	mask;
  const char *	desc;
};

static const struct mips_immed mips_immed[] = {
  { '1',	OP_SH_UDI1,	OP_MASK_UDI1,		0},
  { '2',	OP_SH_UDI2,	OP_MASK_UDI2,		0},
  { '3',	OP_SH_UDI3,	OP_MASK_UDI3,		0},
  { '4',	OP_SH_UDI4,	OP_MASK_UDI4,		0},
  { 0,0,0,0 }
};

/* Check if EXPR is a constant between MIN (inclusive) and MAX (exclusive)
   taking bits from BIT up.  */
static int
expr_const_in_range (expressionS *ep, offsetT min, offsetT max, int bit)
{
  return (ep->X_op == O_constant
	  && (ep->X_add_number & ((1 << bit) - 1)) == 0
	  && ep->X_add_number >= min << bit
	  && ep->X_add_number < max << bit);
}

a11465 8
  unsigned int regno, regno2;
  unsigned int lastregno;
  unsigned int destregno = 0;
  unsigned int lastpos = 0;
  unsigned int limlo, limhi;
  int sizelo;
  char *s_reset;
  offsetT min_range, max_range;
a11467 2
  int argnum;
  unsigned int rtype;
d11470 2
d11540 1
d11552 2
d11558 1
a11558 1
	  if (insn + 1 < past && strcmp (insn->name, insn[1].name) == 0)
d11598 7
a11604 2
      argnum = 1;
      lastregno = 0xffffffff;
d11607 17
a11623 1
	  int is_mdmx;
d11625 7
a11631 8
	  s += strspn (s, " \t");
	  is_mdmx = 0;
	  switch (*args)
	    {
	    case '\0':		/* end of args */
	      if (*s == '\0')
		return;
	      break;
d11633 3
a11635 7
	    case '2':
	      /* DSP 2-bit unsigned immediate in bit 11 (for standard MIPS
	         code) or 14 (for microMIPS code).  */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number != 1
		  && (unsigned long) imm_expr.X_add_number != 3)
d11637 4
a11640 2
		  as_bad (_("BALIGN immediate not 1 or 3 (%lu)"),
			  (unsigned long) imm_expr.X_add_number);
d11642 3
a11644 5
	      INSERT_OPERAND (mips_opts.micromips,
			      BP, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;
d11646 3
a11648 6
	    case '3':
	      /* DSP 3-bit unsigned immediate in bit 21 (for standard MIPS
	         code) or 13 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_SA3 : OP_MASK_SA3);
d11650 8
a11657 10
		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				SA3, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
d11659 1
d11661 29
a11689 6
	    case '4':
	      /* DSP 4-bit unsigned immediate in bit 21 (for standard MIPS
	         code) or 12 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_SA4 : OP_MASK_SA4);
d11691 11
a11701 11
		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				SA4, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;
d11703 3
a11705 48
	    case '5':
	      /* DSP 8-bit unsigned immediate in bit 16 (for standard MIPS
	         code) or 13 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_IMM8 : OP_MASK_IMM8);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				IMM8, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;

	    case '6':
	      /* DSP 5-bit unsigned immediate in bit 21 (for standard MIPS
	         code) or 16 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_RS : OP_MASK_RS);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				RS, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;

	    case '7':
	      /* Four DSP accumulators in bit 11 (for standard MIPS code)
		 or 14 (for microMIPS code).  */
	      if (s[0] == '$' && s[1] == 'a' && s[2] == 'c'
		  && s[3] >= '0' && s[3] <= '3')
		{
		  regno = s[3] - '0';
		  s += 4;
		  INSERT_OPERAND (mips_opts.micromips, DSPACC, *ip, regno);
		  continue;
a11706 2
	      else
		as_bad (_("Invalid dsp acc register"));
d11709 15
d11725 15
a11739 18
	      /* DSP 6-bit unsigned immediate in bit 11 (for standard MIPS
	         code) or 14 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_WRDSP
				      : OP_MASK_WRDSP);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				WRDSP, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;
d11741 9
a11749 12
	    case '9': /* Four DSP accumulators in bits 21,22.  */
	      gas_assert (!mips_opts.micromips);
	      if (s[0] == '$' && s[1] == 'a' && s[2] == 'c'
		  && s[3] >= '0' && s[3] <= '3')
		{
		  regno = s[3] - '0';
		  s += 4;
		  INSERT_OPERAND (0, DSPACC_S, *ip, regno);
		  continue;
		}
	      else
		as_bad (_("Invalid dsp acc register"));
d11752 8
a11759 21
	    case '0':
	      /* DSP 6-bit signed immediate in bit 20 (for standard MIPS
	         code) or 16 (for microMIPS code).  */
	      {
		long mask = (mips_opts.micromips
			     ? MICROMIPSOP_MASK_DSPSFT : OP_MASK_DSPSFT);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		min_range = -((mask + 1) >> 1);
		max_range = ((mask + 1) >> 1) - 1;
		if (imm_expr.X_add_number < min_range
		    || imm_expr.X_add_number > max_range)
		  as_bad (_("DSP immediate not in range %ld..%ld (%ld)"),
			  (long) min_range, (long) max_range,
			  (long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				DSPSFT, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
d11762 3
a11764 5
	    case '\'': /* DSP 6-bit unsigned immediate in bit 16.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~OP_MASK_RDDSP)
d11766 5
a11770 3
		  as_bad (_("DSP immediate not in range 0..%d (%lu)"),
			  OP_MASK_RDDSP,
			  (unsigned long) imm_expr.X_add_number);
d11772 1
a11772 13
	      INSERT_OPERAND (0, RDDSP, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;

	    case ':': /* DSP 7-bit signed immediate in bit 19.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      min_range = -((OP_MASK_DSPSFT_7 + 1) >> 1);
	      max_range = ((OP_MASK_DSPSFT_7 + 1) >> 1) - 1;
	      if (imm_expr.X_add_number < min_range ||
		  imm_expr.X_add_number > max_range)
d11774 2
a11775 3
		  as_bad (_("DSP immediate not in range %ld..%ld (%ld)"),
			  (long) min_range, (long) max_range,
			  (long) imm_expr.X_add_number);
a11776 3
	      INSERT_OPERAND (0, DSPSFT_7, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d11779 4
a11782 1
	    case '@@': /* DSP 10-bit signed immediate in bit 16.  */
d11784 10
a11793 2
		long mask = (mips_opts.micromips
			     ? MICROMIPSOP_MASK_IMM10 : OP_MASK_IMM10);
d11795 5
a11799 15
		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		min_range = -((mask + 1) >> 1);
		max_range = ((mask + 1) >> 1) - 1;
		if (imm_expr.X_add_number < min_range
		    || imm_expr.X_add_number > max_range)
		  as_bad (_("DSP immediate not in range %ld..%ld (%ld)"),
			  (long) min_range, (long) max_range,
			  (long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				IMM10, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;
d11801 9
a11809 12
	    case '^': /* DSP 5-bit unsigned immediate in bit 11.  */
	      gas_assert (mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~MICROMIPSOP_MASK_RD)
		as_bad (_("DSP immediate not in range 0..%d (%lu)"),
			MICROMIPSOP_MASK_RD,
			(unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (1, RD, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;
d11811 2
a11812 11
            case '!': /* MT usermode flag bit.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~OP_MASK_MT_U)
		as_bad (_("MT usermode bit not 0 or 1 (%lu)"),
			(unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (0, MT_U, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;
d11814 4
a11817 11
            case '$': /* MT load high flag bit.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~OP_MASK_MT_H)
		as_bad (_("MT load high bit not 0 or 1 (%lu)"),
			(unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (0, MT_H, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;
d11819 2
a11820 13
	    case '*': /* Four DSP accumulators in bits 18,19.  */
	      gas_assert (!mips_opts.micromips);
	      if (s[0] == '$' && s[1] == 'a' && s[2] == 'c' &&
		  s[3] >= '0' && s[3] <= '3')
		{
		  regno = s[3] - '0';
		  s += 4;
		  INSERT_OPERAND (0, MTACC_T, *ip, regno);
		  continue;
		}
	      else
		as_bad (_("Invalid dsp/smartmips acc register"));
	      break;
d11822 12
a11833 13
	    case '&': /* Four DSP accumulators in bits 13,14.  */
	      gas_assert (!mips_opts.micromips);
	      if (s[0] == '$' && s[1] == 'a' && s[2] == 'c' &&
		  s[3] >= '0' && s[3] <= '3')
		{
		  regno = s[3] - '0';
		  s += 4;
		  INSERT_OPERAND (0, MTACC_D, *ip, regno);
		  continue;
		}
	      else
		as_bad (_("Invalid dsp/smartmips acc register"));
	      break;
d11835 1
a11835 1778
	    case '\\':		/* 3-bit bit position.  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_3BITPOS
				      : OP_MASK_3BITPOS);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_warn (_("Bit position for %s not in range 0..%lu (%lu)"),
			   ip->insn_mo->name,
			   mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				3BITPOS, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;

	    case ',':
	      ++argnum;
	      if (*s++ == *args)
		continue;
	      s--;
	      switch (*++args)
		{
		case 'r':
		case 'v':
		  INSERT_OPERAND (mips_opts.micromips, RS, *ip, lastregno);
		  continue;

		case 'w':
		  INSERT_OPERAND (mips_opts.micromips, RT, *ip, lastregno);
		  continue;

		case 'W':
		  gas_assert (!mips_opts.micromips);
		  INSERT_OPERAND (0, FT, *ip, lastregno);
		  continue;

		case 'V':
		  INSERT_OPERAND (mips_opts.micromips, FS, *ip, lastregno);
		  continue;
		}
	      break;

	    case '(':
	      /* Handle optional base register.
		 Either the base register is omitted or
		 we must have a left paren.  */
	      /* This is dependent on the next operand specifier
		 is a base register specification.  */
	      gas_assert (args[1] == 'b'
			  || (mips_opts.micromips
			      && args[1] == 'm'
			      && (args[2] == 'l' || args[2] == 'n'
				  || args[2] == 's' || args[2] == 'a')));
	      if (*s == '\0' && args[1] == 'b')
		return;
	      /* Fall through.  */

	    case ')':		/* These must match exactly.  */
	      if (*s++ == *args)
		continue;
	      break;

	    case '+':		/* Opcode extension character.  */
	      switch (*++args)
		{
		case '1':	/* UDI immediates.  */
		case '2':
		case '3':
		case '4':
		  gas_assert (!mips_opts.micromips);
		  {
		    const struct mips_immed *imm = mips_immed;

		    while (imm->type && imm->type != *args)
		      ++imm;
		    if (! imm->type)
		      abort ();
		    my_getExpression (&imm_expr, s);
		    check_absolute_expr (ip, &imm_expr);
		    if ((unsigned long) imm_expr.X_add_number & ~imm->mask)
		      {
		        as_warn (_("Illegal %s number (%lu, 0x%lx)"),
				 imm->desc ? imm->desc : ip->insn_mo->name,
				 (unsigned long) imm_expr.X_add_number,
				 (unsigned long) imm_expr.X_add_number);
			imm_expr.X_add_number &= imm->mask;
		      }
		    ip->insn_opcode |= ((unsigned long) imm_expr.X_add_number
					<< imm->shift);
		    imm_expr.X_op = O_absent;
		    s = expr_end;
		  }
		  continue;

		case 'J':		/* 10-bit hypcall code.  */
		  gas_assert (!mips_opts.micromips);
		  {
		    unsigned long mask = OP_MASK_CODE10;

		    my_getExpression (&imm_expr, s);
		    check_absolute_expr (ip, &imm_expr);
		    if ((unsigned long) imm_expr.X_add_number > mask)
		      as_warn (_("Code for %s not in range 0..%lu (%lu)"),
			       ip->insn_mo->name,
			       mask, (unsigned long) imm_expr.X_add_number);
		    INSERT_OPERAND (0, CODE10, *ip, imm_expr.X_add_number);
		    imm_expr.X_op = O_absent;
		    s = expr_end;
		  }
		  continue;

		case 'A':		/* ins/ext position, becomes LSB.  */
		  limlo = 0;
		  limhi = 31;
		  goto do_lsb;
		case 'E':
		  limlo = 32;
		  limhi = 63;
		  goto do_lsb;
		do_lsb:
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  if ((unsigned long) imm_expr.X_add_number < limlo
		      || (unsigned long) imm_expr.X_add_number > limhi)
		    {
		      as_bad (_("Improper position (%lu)"),
			      (unsigned long) imm_expr.X_add_number);
		      imm_expr.X_add_number = limlo;
		    }
		  lastpos = imm_expr.X_add_number;
		  INSERT_OPERAND (mips_opts.micromips,
				  EXTLSB, *ip, imm_expr.X_add_number);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'B':		/* ins size, becomes MSB.  */
		  limlo = 1;
		  limhi = 32;
		  goto do_msb;
		case 'F':
		  limlo = 33;
		  limhi = 64;
		  goto do_msb;
		do_msb:
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  /* Check for negative input so that small negative numbers
		     will not succeed incorrectly.  The checks against
		     (pos+size) transitively check "size" itself,
		     assuming that "pos" is reasonable.  */
		  if ((long) imm_expr.X_add_number < 0
		      || ((unsigned long) imm_expr.X_add_number
			  + lastpos) < limlo
		      || ((unsigned long) imm_expr.X_add_number
			  + lastpos) > limhi)
		    {
		      as_bad (_("Improper insert size (%lu, position %lu)"),
			      (unsigned long) imm_expr.X_add_number,
			      (unsigned long) lastpos);
		      imm_expr.X_add_number = limlo - lastpos;
		    }
		  INSERT_OPERAND (mips_opts.micromips, INSMSB, *ip,
				  lastpos + imm_expr.X_add_number - 1);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'C':		/* ext size, becomes MSBD.  */
		  limlo = 1;
		  limhi = 32;
		  sizelo = 1;
		  goto do_msbd;
		case 'G':
		  limlo = 33;
		  limhi = 64;
		  sizelo = 33;
		  goto do_msbd;
		case 'H':
		  limlo = 33;
		  limhi = 64;
		  sizelo = 1;
		  goto do_msbd;
		do_msbd:
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  /* The checks against (pos+size) don't transitively check
		     "size" itself, assuming that "pos" is reasonable.
		     We also need to check the lower bound of "size".  */
		  if ((long) imm_expr.X_add_number < sizelo
		      || ((unsigned long) imm_expr.X_add_number
			  + lastpos) < limlo
		      || ((unsigned long) imm_expr.X_add_number
			  + lastpos) > limhi)
		    {
		      as_bad (_("Improper extract size (%lu, position %lu)"),
			      (unsigned long) imm_expr.X_add_number,
			      (unsigned long) lastpos);
		      imm_expr.X_add_number = limlo - lastpos;
		    }
		  INSERT_OPERAND (mips_opts.micromips,
				  EXTMSBD, *ip, imm_expr.X_add_number - 1);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'I':
		  /* "+I" is like "I", except that imm2_expr is used.  */
		  my_getExpression (&imm2_expr, s);
		  if (imm2_expr.X_op != O_big
		      && imm2_expr.X_op != O_constant)
		  insn_error = _("absolute expression required");
		  if (HAVE_32BIT_GPRS)
		    normalize_constant_expr (&imm2_expr);
		  s = expr_end;
		  continue;

		case 't': /* Coprocessor register number.  */
		  gas_assert (!mips_opts.micromips);
		  if (s[0] == '$' && ISDIGIT (s[1]))
		    {
		      ++s;
		      regno = 0;
		      do
		        {
			  regno *= 10;
			  regno += *s - '0';
			  ++s;
			}
		      while (ISDIGIT (*s));
		      if (regno > 31)
			as_bad (_("Invalid register number (%d)"), regno);
		      else
			{
			  INSERT_OPERAND (0, RT, *ip, regno);
			  continue;
			}
		    }
		  else
		    as_bad (_("Invalid coprocessor 0 register number"));
		  break;

		case 'x':
		  /* bbit[01] and bbit[01]32 bit index.  Give error if index
		     is not in the valid range.  */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  if ((unsigned) imm_expr.X_add_number > 31)
		    {
		      as_bad (_("Improper bit index (%lu)"),
			      (unsigned long) imm_expr.X_add_number);
		      imm_expr.X_add_number = 0;
		    }
		  INSERT_OPERAND (0, BBITIND, *ip, imm_expr.X_add_number);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'X':
		  /* bbit[01] bit index when bbit is used but we generate
		     bbit[01]32 because the index is over 32.  Move to the
		     next candidate if index is not in the valid range.  */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  if ((unsigned) imm_expr.X_add_number < 32
		      || (unsigned) imm_expr.X_add_number > 63)
		    break;
		  INSERT_OPERAND (0, BBITIND, *ip, imm_expr.X_add_number - 32);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'p':
		  /* cins, cins32, exts and exts32 position field.  Give error
		     if it's not in the valid range.  */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  if ((unsigned) imm_expr.X_add_number > 31)
		    {
		      as_bad (_("Improper position (%lu)"),
			      (unsigned long) imm_expr.X_add_number);
		      imm_expr.X_add_number = 0;
		    }
 		  lastpos = imm_expr.X_add_number;
		  INSERT_OPERAND (0, CINSPOS, *ip, imm_expr.X_add_number);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'P':
		  /* cins, cins32, exts and exts32 position field.  Move to
		     the next candidate if it's not in the valid range.  */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  if ((unsigned) imm_expr.X_add_number < 32
		      || (unsigned) imm_expr.X_add_number > 63)
		    break;
 		  lastpos = imm_expr.X_add_number;
		  INSERT_OPERAND (0, CINSPOS, *ip, imm_expr.X_add_number - 32);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 's':
		  /* cins32 and exts32 length-minus-one field.  */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  if ((unsigned long) imm_expr.X_add_number > 31
		      || (unsigned long) imm_expr.X_add_number + lastpos > 31)
		    {
		      as_bad (_("Improper size (%lu)"),
			      (unsigned long) imm_expr.X_add_number);
		      imm_expr.X_add_number = 0;
		    }
		  INSERT_OPERAND (0, CINSLM1, *ip, imm_expr.X_add_number);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'S':
		  /* cins/exts length-minus-one field.  */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  if ((unsigned long) imm_expr.X_add_number > 31
		      || (unsigned long) imm_expr.X_add_number + lastpos > 63)
		    {
		      as_bad (_("Improper size (%lu)"),
			      (unsigned long) imm_expr.X_add_number);
		      imm_expr.X_add_number = 0;
		    }
		  INSERT_OPERAND (0, CINSLM1, *ip, imm_expr.X_add_number);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'Q':
		  /* seqi/snei immediate field.  */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  if ((long) imm_expr.X_add_number < -512
		      || (long) imm_expr.X_add_number >= 512)
		    {
		      as_bad (_("Improper immediate (%ld)"),
			       (long) imm_expr.X_add_number);
		      imm_expr.X_add_number = 0;
		    }
		  INSERT_OPERAND (0, SEQI, *ip, imm_expr.X_add_number);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'a': /* 8-bit signed offset in bit 6 */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  min_range = -((OP_MASK_OFFSET_A + 1) >> 1);
		  max_range = ((OP_MASK_OFFSET_A + 1) >> 1) - 1;
		  if (imm_expr.X_add_number < min_range
		      || imm_expr.X_add_number > max_range)
		    {
		      as_bad (_("Offset not in range %ld..%ld (%ld)"),
		              (long) min_range, (long) max_range,
		              (long) imm_expr.X_add_number);
		    }
		  INSERT_OPERAND (0, OFFSET_A, *ip, imm_expr.X_add_number);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'b': /* 8-bit signed offset in bit 3 */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  min_range = -((OP_MASK_OFFSET_B + 1) >> 1);
		  max_range = ((OP_MASK_OFFSET_B + 1) >> 1) - 1;
		  if (imm_expr.X_add_number < min_range
		      || imm_expr.X_add_number > max_range)
		    {
		      as_bad (_("Offset not in range %ld..%ld (%ld)"),
		              (long) min_range, (long) max_range,
		              (long) imm_expr.X_add_number);
		    }
		  INSERT_OPERAND (0, OFFSET_B, *ip, imm_expr.X_add_number);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'c': /* 9-bit signed offset in bit 6 */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  min_range = -((OP_MASK_OFFSET_C + 1) >> 1);
		  max_range = ((OP_MASK_OFFSET_C + 1) >> 1) - 1;
		  /* We check the offset range before adjusted.  */
		  min_range <<= 4;
		  max_range <<= 4;
		  if (imm_expr.X_add_number < min_range
		      || imm_expr.X_add_number > max_range)
		    {
		      as_bad (_("Offset not in range %ld..%ld (%ld)"),
		              (long) min_range, (long) max_range,
		              (long) imm_expr.X_add_number);
		    }
		  if (imm_expr.X_add_number & 0xf)
		    {
		      as_bad (_("Offset not 16 bytes alignment (%ld)"),
			      (long) imm_expr.X_add_number);
		    }
		  /* Right shift 4 bits to adjust the offset operand.  */
		  INSERT_OPERAND (0, OFFSET_C, *ip,
				  imm_expr.X_add_number >> 4);
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;

		case 'z':
		  gas_assert (!mips_opts.micromips);
		  if (!reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno))
		    break;
		  if (regno == AT && mips_opts.at)
		    {
		      if (mips_opts.at == ATREG)
			as_warn (_("used $at without \".set noat\""));
		      else
			as_warn (_("used $%u with \".set at=$%u\""),
				 regno, mips_opts.at);
		    }
		  INSERT_OPERAND (0, RZ, *ip, regno);
		  continue;

		case 'Z':
		  gas_assert (!mips_opts.micromips);
		  if (!reg_lookup (&s, RTYPE_FPU, &regno))
		    break;
		  INSERT_OPERAND (0, FZ, *ip, regno);
		  continue;

		case 'i':
		  goto jump;

		case 'j':
		  {
		    int shift = 8;
		    size_t i;
		    bfd_reloc_code_real_type r[3];

		    /* Check whether there is only a single bracketed expression
		       left.  If so, it must be the base register and the
		       constant must be zero.  */
		    if (*s == '(' && strchr (s + 1, '(') == 0)
		      continue;

		    /* If this value won't fit into the offset, then go find
		       a macro that will generate a 16- or 32-bit offset code
		       pattern.  */
		    i = my_getSmallExpression (&imm_expr, r, s);
		    if ((i == 0 && (imm_expr.X_op != O_constant
				    || imm_expr.X_add_number >= 1 << shift
				    || imm_expr.X_add_number < -1 << shift))
			|| i > 0)
		      {
			imm_expr.X_op = O_absent;
			break;
		      }
		    INSERT_OPERAND (mips_opts.micromips, EVAOFFSET, *ip,
				    imm_expr.X_add_number);
		    imm_expr.X_op = O_absent;
		    s = expr_end;
		  }
		  continue;

		default:
		  as_bad (_("Internal error: bad %s opcode "
			    "(unknown extension operand type `+%c'): %s %s"),
			  mips_opts.micromips ? "microMIPS" : "MIPS",
			  *args, insn->name, insn->args);
		  /* Further processing is fruitless.  */
		  return;
		}
	      break;

	    case '.':		/* 10-bit offset.  */
	      gas_assert (mips_opts.micromips);
	    case '~':		/* 12-bit offset.  */
	      {
		int shift = *args == '.' ? 9 : 11;
		size_t i;
		bfd_reloc_code_real_type r[3];

		/* Check whether there is only a single bracketed expression
		   left.  If so, it must be the base register and the
		   constant must be zero.  */
		if (*s == '(' && strchr (s + 1, '(') == 0)
		  continue;

		/* If this value won't fit into the offset, then go find
		   a macro that will generate a 16- or 32-bit offset code
		   pattern.  */
		i = my_getSmallExpression (&imm_expr, r, s);
		if ((i == 0 && (imm_expr.X_op != O_constant
				|| imm_expr.X_add_number >= 1 << shift
				|| imm_expr.X_add_number < -1 << shift))
		    || i > 0)
		  {
		    imm_expr.X_op = O_absent;
		    break;
		  }
		if (shift == 9)
		  INSERT_OPERAND (1, OFFSET10, *ip, imm_expr.X_add_number);
		else
		  INSERT_OPERAND (mips_opts.micromips,
				  OFFSET12, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;

	    case '<':		/* must be at least one digit */
	      /*
	       * According to the manual, if the shift amount is greater
	       * than 31 or less than 0, then the shift amount should be
	       * mod 32.  In reality the mips assembler issues an error.
	       * We issue a warning and mask out all but the low 5 bits.
	       */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > 31)
		as_warn (_("Improper shift amount (%lu)"),
			 (unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (mips_opts.micromips,
			      SHAMT, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;

	    case '>':		/* shift amount minus 32 */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number < 32
		  || (unsigned long) imm_expr.X_add_number > 63)
		break;
	      INSERT_OPERAND (mips_opts.micromips,
			      SHAMT, *ip, imm_expr.X_add_number - 32);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;

	    case 'k':		/* CACHE code.  */
	    case 'h':		/* PREFX code.  */
	    case '1':		/* SYNC type.  */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > 31)
		as_warn (_("Invalid value for `%s' (%lu)"),
			 ip->insn_mo->name,
			 (unsigned long) imm_expr.X_add_number);
	      switch (*args)
		{
		case 'k':
		  if (mips_fix_cn63xxp1
		      && !mips_opts.micromips
		      && strcmp ("pref", insn->name) == 0)
		    switch (imm_expr.X_add_number)
		      {
		      case 5:
		      case 25:
		      case 26:
		      case 27:
		      case 28:
		      case 29:
		      case 30:
		      case 31:  /* These are ok.  */
			break;

		      default:  /* The rest must be changed to 28.  */
			imm_expr.X_add_number = 28;
			break;
		      }
		  INSERT_OPERAND (mips_opts.micromips,
				  CACHE, *ip, imm_expr.X_add_number);
		  break;
		case 'h':
		  INSERT_OPERAND (mips_opts.micromips,
				  PREFX, *ip, imm_expr.X_add_number);
		  break;
		case '1':
		  INSERT_OPERAND (mips_opts.micromips,
				  STYPE, *ip, imm_expr.X_add_number);
		  break;
		}
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;

	    case 'c':		/* BREAK code.  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_CODE
				      : OP_MASK_CODE);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_warn (_("Code for %s not in range 0..%lu (%lu)"),
			   ip->insn_mo->name,
			   mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				CODE, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;

	    case 'q':		/* Lower BREAK code.  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_CODE2
				      : OP_MASK_CODE2);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_warn (_("Lower code for %s not in range 0..%lu (%lu)"),
			   ip->insn_mo->name,
			   mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				CODE2, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;

	    case 'B':		/* 20- or 10-bit syscall/break/wait code.  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_CODE10
				      : OP_MASK_CODE20);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_warn (_("Code for %s not in range 0..%lu (%lu)"),
			   ip->insn_mo->name,
			   mask, (unsigned long) imm_expr.X_add_number);
		if (mips_opts.micromips)
		  INSERT_OPERAND (1, CODE10, *ip, imm_expr.X_add_number);
		else
		  INSERT_OPERAND (0, CODE20, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;

	    case 'C':		/* 25- or 23-bit coprocessor code.  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_COPZ
				      : OP_MASK_COPZ);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_warn (_("Coproccesor code > %u bits (%lu)"),
			   mips_opts.micromips ? 23U : 25U,
			   (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				COPZ, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;

	    case 'J':		/* 19-bit WAIT code.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > OP_MASK_CODE19)
	        {
	          as_warn (_("Illegal 19-bit code (%lu)"),
			   (unsigned long) imm_expr.X_add_number);
	          imm_expr.X_add_number &= OP_MASK_CODE19;
	        }
	      INSERT_OPERAND (0, CODE19, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;

	    case 'P':		/* Performance register.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number != 0 && imm_expr.X_add_number != 1)
		as_warn (_("Invalid performance register (%lu)"),
			 (unsigned long) imm_expr.X_add_number);
	      if (imm_expr.X_add_number != 0 && mips_opts.arch == CPU_R5900
	        && (!strcmp(insn->name,"mfps") || !strcmp(insn->name,"mtps")))
	        as_warn (_("Invalid performance register (%lu)"),
	          (unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (0, PERFREG, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;

	    case 'G':		/* Coprocessor destination register.  */
	      {
		unsigned long opcode = ip->insn_opcode;
		unsigned long mask;
		unsigned int types;
		int cop0;

		if (mips_opts.micromips)
		  {
		    mask = ~((MICROMIPSOP_MASK_RT << MICROMIPSOP_SH_RT)
			     | (MICROMIPSOP_MASK_RS << MICROMIPSOP_SH_RS)
			     | (MICROMIPSOP_MASK_SEL << MICROMIPSOP_SH_SEL));
		    opcode &= mask;
		    switch (opcode)
		      {
		      case 0x000000fc:				/* mfc0  */
		      case 0x000002fc:				/* mtc0  */
		      case 0x580000fc:				/* dmfc0 */
		      case 0x580002fc:				/* dmtc0 */
			cop0 = 1;
			break;
		      default:
			cop0 = 0;
			break;
		      }
		  }
		else
		  {
		    opcode = (opcode >> OP_SH_OP) & OP_MASK_OP;
		    cop0 = opcode == OP_OP_COP0;
		  }
		types = RTYPE_NUM | (cop0 ? RTYPE_CP0 : RTYPE_GP);
		ok = reg_lookup (&s, types, &regno);
		if (mips_opts.micromips)
		  INSERT_OPERAND (1, RS, *ip, regno);
		else
		  INSERT_OPERAND (0, RD, *ip, regno);
		if (ok)
		  {
		    lastregno = regno;
		    continue;
		  }
	      }
	      break;

	    case 'y':		/* ALNV.PS source register.  */
	      gas_assert (mips_opts.micromips);
	      goto do_reg;
	    case 'x':		/* Ignore register name.  */
	    case 'U':           /* Destination register (CLO/CLZ).  */
	    case 'g':		/* Coprocessor destination register.  */
	      gas_assert (!mips_opts.micromips);
	    case 'b':		/* Base register.  */
	    case 'd':		/* Destination register.  */
	    case 's':		/* Source register.  */
	    case 't':		/* Target register.  */
	    case 'r':		/* Both target and source.  */
	    case 'v':		/* Both dest and source.  */
	    case 'w':		/* Both dest and target.  */
	    case 'E':		/* Coprocessor target register.  */
	    case 'K':		/* RDHWR destination register.  */
	    case 'z':		/* Must be zero register.  */
	    do_reg:
	      s_reset = s;
	      if (*args == 'E' || *args == 'K')
		ok = reg_lookup (&s, RTYPE_NUM, &regno);
	      else
		{
		  ok = reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno);
		  if (regno == AT && mips_opts.at)
		    {
		      if (mips_opts.at == ATREG)
			as_warn (_("Used $at without \".set noat\""));
		      else
			as_warn (_("Used $%u with \".set at=$%u\""),
				 regno, mips_opts.at);
		    }
		}
	      if (ok)
		{
		  c = *args;
		  if (*s == ' ')
		    ++s;
		  if (args[1] != *s)
		    {
		      if (c == 'r' || c == 'v' || c == 'w')
			{
			  regno = lastregno;
			  s = s_reset;
			  ++args;
			}
		    }
		  /* 'z' only matches $0.  */
		  if (c == 'z' && regno != 0)
		    break;

		  if (c == 's' && !strncmp (ip->insn_mo->name, "jalr", 4))
		    {
		      if (regno == lastregno)
			{
			  insn_error
			    = _("Source and destination must be different");
			  continue;
			}
		      if (regno == 31 && lastregno == 0xffffffff)
			{
			  insn_error
			    = _("A destination register must be supplied");
			  continue;
			}
		    }
		  /* Now that we have assembled one operand, we use the args
		     string to figure out where it goes in the instruction.  */
		  switch (c)
		    {
		    case 'r':
		    case 's':
		    case 'v':
		    case 'b':
		      INSERT_OPERAND (mips_opts.micromips, RS, *ip, regno);
		      break;

		    case 'K':
		      if (mips_opts.micromips)
			INSERT_OPERAND (1, RS, *ip, regno);
		      else
			INSERT_OPERAND (0, RD, *ip, regno);
		      break;

		    case 'd':
		    case 'g':
		      INSERT_OPERAND (mips_opts.micromips, RD, *ip, regno);
		      break;

		    case 'U':
		      gas_assert (!mips_opts.micromips);
		      INSERT_OPERAND (0, RD, *ip, regno);
		      INSERT_OPERAND (0, RT, *ip, regno);
		      break;

		    case 'w':
		    case 't':
		    case 'E':
		      INSERT_OPERAND (mips_opts.micromips, RT, *ip, regno);
		      break;

		    case 'y':
		      gas_assert (mips_opts.micromips);
		      INSERT_OPERAND (1, RS3, *ip, regno);
		      break;

		    case 'x':
		      /* This case exists because on the r3000 trunc
			 expands into a macro which requires a gp
			 register.  On the r6000 or r4000 it is
			 assembled into a single instruction which
			 ignores the register.  Thus the insn version
			 is MIPS_ISA2 and uses 'x', and the macro
			 version is MIPS_ISA1 and uses 't'.  */
		      break;

		    case 'z':
		      /* This case is for the div instruction, which
			 acts differently if the destination argument
			 is $0.  This only matches $0, and is checked
			 outside the switch.  */
		      break;
		    }
		  lastregno = regno;
		  continue;
		}
	      switch (*args++)
		{
		case 'r':
		case 'v':
		  INSERT_OPERAND (mips_opts.micromips, RS, *ip, lastregno);
		  continue;

		case 'w':
		  INSERT_OPERAND (mips_opts.micromips, RT, *ip, lastregno);
		  continue;
		}
	      break;

	    case 'O':		/* MDMX alignment immediate constant.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > OP_MASK_ALN)
		as_warn (_("Improper align amount (%ld), using low bits"),
			 (long) imm_expr.X_add_number);
	      INSERT_OPERAND (0, ALN, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;

	    case 'Q':		/* MDMX vector, element sel, or const.  */
	      if (s[0] != '$')
		{
		  /* MDMX Immediate.  */
		  gas_assert (!mips_opts.micromips);
		  my_getExpression (&imm_expr, s);
		  check_absolute_expr (ip, &imm_expr);
		  if ((unsigned long) imm_expr.X_add_number > OP_MASK_FT)
		    as_warn (_("Invalid MDMX Immediate (%ld)"),
			     (long) imm_expr.X_add_number);
		  INSERT_OPERAND (0, FT, *ip, imm_expr.X_add_number);
		  if (ip->insn_opcode & (OP_MASK_VSEL << OP_SH_VSEL))
		    ip->insn_opcode |= MDMX_FMTSEL_IMM_QH << OP_SH_VSEL;
		  else
		    ip->insn_opcode |= MDMX_FMTSEL_IMM_OB << OP_SH_VSEL;
		  imm_expr.X_op = O_absent;
		  s = expr_end;
		  continue;
		}
	      /* Not MDMX Immediate.  Fall through.  */
	    case 'X':           /* MDMX destination register.  */
	    case 'Y':           /* MDMX source register.  */
	    case 'Z':           /* MDMX target register.  */
	      is_mdmx = !(insn->membership & INSN_5400);
	    case 'W':
	      gas_assert (!mips_opts.micromips);
	    case 'D':		/* Floating point destination register.  */
	    case 'S':		/* Floating point source register.  */
	    case 'T':		/* Floating point target register.  */
	    case 'R':		/* Floating point source register.  */
	    case 'V':
	      rtype = RTYPE_FPU;
	      if (is_mdmx
		  || ((mips_opts.ase & ASE_MDMX)
		      && (ip->insn_mo->pinfo & FP_D)
		      && (ip->insn_mo->pinfo & (INSN_COPROC_MOVE_DELAY
						| INSN_COPROC_MEMORY_DELAY
						| INSN_LOAD_COPROC_DELAY
						| INSN_LOAD_MEMORY_DELAY
						| INSN_STORE_MEMORY))))
		rtype |= RTYPE_VEC;
	      s_reset = s;
	      if (reg_lookup (&s, rtype, &regno))
		{
		  if ((regno & 1) != 0
		      && HAVE_32BIT_FPRS
		      && !mips_oddfpreg_ok (ip->insn_mo, argnum))
		    as_warn (_("Float register should be even, was %d"),
			     regno);

		  c = *args;
		  if (*s == ' ')
		    ++s;
		  if (args[1] != *s)
		    {
		      if (c == 'V' || c == 'W')
			{
			  regno = lastregno;
			  s = s_reset;
			  ++args;
			}
		    }
		  switch (c)
		    {
		    case 'D':
		    case 'X':
		      INSERT_OPERAND (mips_opts.micromips, FD, *ip, regno);
		      break;

		    case 'V':
		    case 'S':
		    case 'Y':
		      INSERT_OPERAND (mips_opts.micromips, FS, *ip, regno);
		      break;

		    case 'Q':
		      /* This is like 'Z', but also needs to fix the MDMX
			 vector/scalar select bits.  Note that the
			 scalar immediate case is handled above.  */
		      if ((ip->insn_mo->membership & INSN_5400)
			  && strcmp (insn->name, "rzu.ob") == 0)
			as_bad (_("Operand %d of `%s' must be an immediate"),
				argnum, ip->insn_mo->name);

		      if (*s == '[')
			{
			  int is_qh = (ip->insn_opcode & (1 << OP_SH_VSEL));
			  int max_el = (is_qh ? 3 : 7);
			  s++;
			  my_getExpression(&imm_expr, s);
			  check_absolute_expr (ip, &imm_expr);
			  s = expr_end;
			  if (imm_expr.X_add_number > max_el)
			    as_bad (_("Bad element selector %ld"),
				    (long) imm_expr.X_add_number);
			  imm_expr.X_add_number &= max_el;
			  ip->insn_opcode |= (imm_expr.X_add_number
					      << (OP_SH_VSEL +
						  (is_qh ? 2 : 1)));
			  imm_expr.X_op = O_absent;
			  if (*s != ']')
			    as_warn (_("Expecting ']' found '%s'"), s);
			  else
			    s++;
			}
		      else
			{
			  if ((ip->insn_mo->membership & INSN_5400)
			      && (strcmp (insn->name, "sll.ob") == 0
				  || strcmp (insn->name, "srl.ob") == 0))
			    as_bad (_("Operand %d of `%s' must be scalar"),
				    argnum, ip->insn_mo->name);

                          if (ip->insn_opcode & (OP_MASK_VSEL << OP_SH_VSEL))
                            ip->insn_opcode |= (MDMX_FMTSEL_VEC_QH
						<< OP_SH_VSEL);
			  else
			    ip->insn_opcode |= (MDMX_FMTSEL_VEC_OB <<
						OP_SH_VSEL);
			}
                      /* Fall through.  */
		    case 'W':
		    case 'T':
		    case 'Z':
		      INSERT_OPERAND (mips_opts.micromips, FT, *ip, regno);
		      break;

		    case 'R':
		      INSERT_OPERAND (mips_opts.micromips, FR, *ip, regno);
		      break;
		    }
		  lastregno = regno;
		  continue;
		}

	      switch (*args++)
		{
		case 'V':
		  INSERT_OPERAND (mips_opts.micromips, FS, *ip, lastregno);
		  continue;

		case 'W':
		  INSERT_OPERAND (mips_opts.micromips, FT, *ip, lastregno);
		  continue;
		}
	      break;

	    case 'I':
	      my_getExpression (&imm_expr, s);
	      if (imm_expr.X_op != O_big
		  && imm_expr.X_op != O_constant)
		insn_error = _("absolute expression required");
	      if (HAVE_32BIT_GPRS)
		normalize_constant_expr (&imm_expr);
	      s = expr_end;
	      continue;

	    case 'A':
	      my_getSmallExpression (&offset_expr, offset_reloc, s);
	      if (offset_expr.X_op == O_register)
		{
		  /* Assume that the offset has been elided and that what
		     we saw was a base register.  The match will fail later
		     if that assumption turns out to be wrong.  */
		  offset_expr.X_op = O_constant;
		  offset_expr.X_add_number = 0;
		}
	      else
		{
		  normalize_address_expr (&offset_expr);
		  s = expr_end;
		}
	      continue;

	    case 'F':
	    case 'L':
	    case 'f':
	    case 'l':
	      {
		int f64;
		int using_gprs;
		char *save_in;
		char *err;
		unsigned char temp[8];
		int len;
		unsigned int length;
		segT seg;
		subsegT subseg;
		char *p;

		/* These only appear as the last operand in an
		   instruction, and every instruction that accepts
		   them in any variant accepts them in all variants.
		   This means we don't have to worry about backing out
		   any changes if the instruction does not match.

		   The difference between them is the size of the
		   floating point constant and where it goes.  For 'F'
		   and 'L' the constant is 64 bits; for 'f' and 'l' it
		   is 32 bits.  Where the constant is placed is based
		   on how the MIPS assembler does things:
		    F -- .rdata
		    L -- .lit8
		    f -- immediate value
		    l -- .lit4

		    The .lit4 and .lit8 sections are only used if
		    permitted by the -G argument.

		    The code below needs to know whether the target register
		    is 32 or 64 bits wide.  It relies on the fact 'f' and
		    'F' are used with GPR-based instructions and 'l' and
		    'L' are used with FPR-based instructions.  */

		f64 = *args == 'F' || *args == 'L';
		using_gprs = *args == 'F' || *args == 'f';

		save_in = input_line_pointer;
		input_line_pointer = s;
		err = md_atof (f64 ? 'd' : 'f', (char *) temp, &len);
		length = len;
		s = input_line_pointer;
		input_line_pointer = save_in;
		if (err != NULL && *err != '\0')
		  {
		    as_bad (_("Bad floating point constant: %s"), err);
		    memset (temp, '\0', sizeof temp);
		    length = f64 ? 8 : 4;
		  }

		gas_assert (length == (unsigned) (f64 ? 8 : 4));

		if (*args == 'f'
		    || (*args == 'l'
			&& (g_switch_value < 4
			    || (temp[0] == 0 && temp[1] == 0)
			    || (temp[2] == 0 && temp[3] == 0))))
		  {
		    imm_expr.X_op = O_constant;
		    if (!target_big_endian)
		      imm_expr.X_add_number = bfd_getl32 (temp);
		    else
		      imm_expr.X_add_number = bfd_getb32 (temp);
		  }
		else if (length > 4
			 && !mips_disable_float_construction
			 /* Constants can only be constructed in GPRs and
			    copied to FPRs if the GPRs are at least as wide
			    as the FPRs.  Force the constant into memory if
			    we are using 64-bit FPRs but the GPRs are only
			    32 bits wide.  */
			 && (using_gprs
			     || !(HAVE_64BIT_FPRS && HAVE_32BIT_GPRS))
			 && ((temp[0] == 0 && temp[1] == 0)
			     || (temp[2] == 0 && temp[3] == 0))
			 && ((temp[4] == 0 && temp[5] == 0)
			     || (temp[6] == 0 && temp[7] == 0)))
		  {
		    /* The value is simple enough to load with a couple of
		       instructions.  If using 32-bit registers, set
		       imm_expr to the high order 32 bits and offset_expr to
		       the low order 32 bits.  Otherwise, set imm_expr to
		       the entire 64 bit constant.  */
		    if (using_gprs ? HAVE_32BIT_GPRS : HAVE_32BIT_FPRS)
		      {
			imm_expr.X_op = O_constant;
			offset_expr.X_op = O_constant;
			if (!target_big_endian)
			  {
			    imm_expr.X_add_number = bfd_getl32 (temp + 4);
			    offset_expr.X_add_number = bfd_getl32 (temp);
			  }
			else
			  {
			    imm_expr.X_add_number = bfd_getb32 (temp);
			    offset_expr.X_add_number = bfd_getb32 (temp + 4);
			  }
			if (offset_expr.X_add_number == 0)
			  offset_expr.X_op = O_absent;
		      }
		    else
		      {
			imm_expr.X_op = O_constant;
			if (!target_big_endian)
			  imm_expr.X_add_number = bfd_getl64 (temp);
			else
			  imm_expr.X_add_number = bfd_getb64 (temp);
		      }
		  }
		else
		  {
		    const char *newname;
		    segT new_seg;

		    /* Switch to the right section.  */
		    seg = now_seg;
		    subseg = now_subseg;
		    switch (*args)
		      {
		      default: /* unused default case avoids warnings.  */
		      case 'L':
			newname = RDATA_SECTION_NAME;
			if (g_switch_value >= 8)
			  newname = ".lit8";
			break;
		      case 'F':
			newname = RDATA_SECTION_NAME;
			break;
		      case 'l':
			gas_assert (g_switch_value >= 4);
			newname = ".lit4";
			break;
		      }
		    new_seg = subseg_new (newname, (subsegT) 0);
		    bfd_set_section_flags (stdoutput, new_seg,
					   (SEC_ALLOC
					    | SEC_LOAD
					    | SEC_READONLY
					    | SEC_DATA));
		    frag_align (*args == 'l' ? 2 : 3, 0, 0);
		    if (strncmp (TARGET_OS, "elf", 3) != 0)
		      record_alignment (new_seg, 4);
		    else
		      record_alignment (new_seg, *args == 'l' ? 2 : 3);
		    if (seg == now_seg)
		      as_bad (_("Can't use floating point insn in this section"));

		    /* Set the argument to the current address in the
		       section.  */
		    offset_expr.X_op = O_symbol;
		    offset_expr.X_add_symbol = symbol_temp_new_now ();
		    offset_expr.X_add_number = 0;

		    /* Put the floating point number into the section.  */
		    p = frag_more ((int) length);
		    memcpy (p, temp, length);

		    /* Switch back to the original section.  */
		    subseg_set (seg, subseg);
		  }
	      }
	      continue;

	    case 'i':		/* 16-bit unsigned immediate.  */
	    case 'j':		/* 16-bit signed immediate.  */
	      *offset_reloc = BFD_RELOC_LO16;
	      if (my_getSmallExpression (&offset_expr, offset_reloc, s) == 0)
		{
		  int more;
		  offsetT minval, maxval;

		  more = (insn + 1 < past
			  && strcmp (insn->name, insn[1].name) == 0);

		  /* For compatibility with older assemblers, we accept
		     0x8000-0xffff as signed 16-bit numbers when only
		     signed numbers are allowed.  */
		  if (*args == 'i')
		    minval = 0, maxval = 0xffff;
		  else if (more)
		    minval = -0x8000, maxval = 0x7fff;
		  else
		    minval = -0x8000, maxval = 0xffff;

		  if (offset_expr.X_op != O_constant
		      || offset_expr.X_add_number < minval
		      || offset_expr.X_add_number > maxval)
		    {
		      if (more)
			break;
		      if (offset_expr.X_op == O_constant
			  || offset_expr.X_op == O_big)
			as_bad (_("Expression out of range"));
		    }
		}
	      s = expr_end;
	      continue;

	    case 'o':		/* 16-bit offset.  */
	      offset_reloc[0] = BFD_RELOC_LO16;
	      offset_reloc[1] = BFD_RELOC_UNUSED;
	      offset_reloc[2] = BFD_RELOC_UNUSED;

	      /* Check whether there is only a single bracketed expression
		 left.  If so, it must be the base register and the
		 constant must be zero.  */
	      if (*s == '(' && strchr (s + 1, '(') == 0)
		{
		  offset_expr.X_op = O_constant;
		  offset_expr.X_add_number = 0;
		  continue;
		}

	      /* If this value won't fit into a 16 bit offset, then go
		 find a macro that will generate the 32 bit offset
		 code pattern.  */
	      if (my_getSmallExpression (&offset_expr, offset_reloc, s) == 0
		  && (offset_expr.X_op != O_constant
		      || offset_expr.X_add_number >= 0x8000
		      || offset_expr.X_add_number < -0x8000))
		break;

	      s = expr_end;
	      continue;

	    case 'p':		/* PC-relative offset.  */
	      *offset_reloc = BFD_RELOC_16_PCREL_S2;
	      my_getExpression (&offset_expr, s);
	      s = expr_end;
	      continue;

	    case 'u':		/* Upper 16 bits.  */
	      *offset_reloc = BFD_RELOC_LO16;
	      if (my_getSmallExpression (&offset_expr, offset_reloc, s) == 0
		  && offset_expr.X_op == O_constant
		  && (offset_expr.X_add_number < 0
		      || offset_expr.X_add_number >= 0x10000))
		as_bad (_("lui expression (%lu) not in range 0..65535"),
			(unsigned long) offset_expr.X_add_number);
	      s = expr_end;
	      continue;

	    case 'a':		/* 26-bit address.  */
	    jump:
	      *offset_reloc = BFD_RELOC_MIPS_JMP;
	      my_getExpression (&offset_expr, s);
	      s = expr_end;
	      continue;

	    case 'N':		/* 3-bit branch condition code.  */
	    case 'M':		/* 3-bit compare condition code.  */
	      rtype = RTYPE_CCC;
	      if (ip->insn_mo->pinfo & (FP_D | FP_S))
		rtype |= RTYPE_FCC;
	      if (!reg_lookup (&s, rtype, &regno))
		break;
	      if ((strcmp (str + strlen (str) - 3, ".ps") == 0
		   || strcmp (str + strlen (str) - 5, "any2f") == 0
		   || strcmp (str + strlen (str) - 5, "any2t") == 0)
		  && (regno & 1) != 0)
		as_warn (_("Condition code register should be even for %s, "
			   "was %d"),
			 str, regno);
	      if ((strcmp (str + strlen (str) - 5, "any4f") == 0
		   || strcmp (str + strlen (str) - 5, "any4t") == 0)
		  && (regno & 3) != 0)
		as_warn (_("Condition code register should be 0 or 4 for %s, "
			   "was %d"),
			 str, regno);
	      if (*args == 'N')
		INSERT_OPERAND (mips_opts.micromips, BCC, *ip, regno);
	      else
		INSERT_OPERAND (mips_opts.micromips, CCC, *ip, regno);
	      continue;

	    case 'H':
	      if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
		s += 2;
	      if (ISDIGIT (*s))
		{
		  c = 0;
		  do
		    {
		      c *= 10;
		      c += *s - '0';
		      ++s;
		    }
		  while (ISDIGIT (*s));
		}
	      else
		c = 8; /* Invalid sel value.  */

	      if (c > 7)
		as_bad (_("Invalid coprocessor sub-selection value (0-7)"));
	      INSERT_OPERAND (mips_opts.micromips, SEL, *ip, c);
	      continue;

	    case 'e':
	      gas_assert (!mips_opts.micromips);
	      /* Must be at least one digit.  */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);

	      if ((unsigned long) imm_expr.X_add_number
		  > (unsigned long) OP_MASK_VECBYTE)
		{
		  as_bad (_("bad byte vector index (%ld)"),
			   (long) imm_expr.X_add_number);
		  imm_expr.X_add_number = 0;
		}

	      INSERT_OPERAND (0, VECBYTE, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;

	    case '%':
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);

	      if ((unsigned long) imm_expr.X_add_number
		  > (unsigned long) OP_MASK_VECALIGN)
		{
		  as_bad (_("bad byte vector index (%ld)"),
			   (long) imm_expr.X_add_number);
		  imm_expr.X_add_number = 0;
		}

	      INSERT_OPERAND (0, VECALIGN, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;

	    case 'm':		/* Opcode extension character.  */
	      gas_assert (mips_opts.micromips);
	      c = *++args;
	      switch (c)
		{
		case 'r':
		  if (strncmp (s, "$pc", 3) == 0)
		    {
		      s += 3;
		      continue;
		    }
		  break;

		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'j':
		case 'l':
		case 'm':
		case 'n':
		case 'p':
		case 'q':
		case 's':
		case 't':
		case 'x':
		case 'y':
		case 'z':
		  s_reset = s;
		  ok = reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno);
		  if (regno == AT && mips_opts.at)
		    {
		      if (mips_opts.at == ATREG)
			as_warn (_("Used $at without \".set noat\""));
		      else
			as_warn (_("Used $%u with \".set at=$%u\""),
				 regno, mips_opts.at);
		    }
		  if (!ok)
		    {
		      if (c == 'c')
			{
			  gas_assert (args[1] == ',');
			  regno = lastregno;
			  ++args;
			}
		      else if (c == 't')
			{
			  gas_assert (args[1] == ',');
			  ++args;
			  continue;			/* Nothing to do.  */
			}
		      else
			break;
		    }

		  if (c == 'j' && !strncmp (ip->insn_mo->name, "jalr", 4))
		    {
		      if (regno == lastregno)
			{
			  insn_error
			    = _("Source and destination must be different");
			  continue;
			}
		      if (regno == 31 && lastregno == 0xffffffff)
			{
			  insn_error
			    = _("A destination register must be supplied");
			  continue;
			}
		    }

		  if (*s == ' ')
		    ++s;
		  if (args[1] != *s)
		    {
		      if (c == 'e')
			{
			  gas_assert (args[1] == ',');
			  regno = lastregno;
			  s = s_reset;
			  ++args;
			}
		      else if (c == 't')
			{
			  gas_assert (args[1] == ',');
			  s = s_reset;
			  ++args;
			  continue;			/* Nothing to do.  */
			}
		    }

		  /* Make sure regno is the same as lastregno.  */
		  if (c == 't' && regno != lastregno)
		    break;

		  /* Make sure regno is the same as destregno.  */
		  if (c == 'x' && regno != destregno)
		    break;

		  /* We need to save regno, before regno maps to the
		     microMIPS register encoding.  */
		  lastregno = regno;

		  if (c == 'f')
		    destregno = regno;

		  switch (c)
		    {
		      case 'a':
			if (regno != GP)
			  regno = ILLEGAL_REG;
			break;

		      case 'b':
			regno = mips32_to_micromips_reg_b_map[regno];
			break;

		      case 'c':
			regno = mips32_to_micromips_reg_c_map[regno];
			break;

		      case 'd':
			regno = mips32_to_micromips_reg_d_map[regno];
			break;

		      case 'e':
			regno = mips32_to_micromips_reg_e_map[regno];
			break;

		      case 'f':
			regno = mips32_to_micromips_reg_f_map[regno];
			break;

		      case 'g':
			regno = mips32_to_micromips_reg_g_map[regno];
			break;

		      case 'h':
			s += strspn (s, " \t");
			if (*s != ',')
			  {
			    regno = ILLEGAL_REG;
			    break;
			  }
			++s;
			s += strspn (s, " \t");
			ok = reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno2);
			if (!ok)
			  {
			    regno = ILLEGAL_REG;
			    break;
			  }
			if (regno2 == AT && mips_opts.at)
			  {
			    if (mips_opts.at == ATREG)
			      as_warn (_("Used $at without \".set noat\""));
			    else
			      as_warn (_("Used $%u with \".set at=$%u\""),
				       regno2, mips_opts.at);
			  }
			regno = (mips_lookup_reg_pair
				 (regno, regno2,
				  micromips_to_32_reg_h_map1,
				  micromips_to_32_reg_h_map2, 8));
			break;

		      case 'l':
			regno = mips32_to_micromips_reg_l_map[regno];
			break;

		      case 'm':
			regno = mips32_to_micromips_reg_m_map[regno];
			break;

		      case 'n':
			regno = mips32_to_micromips_reg_n_map[regno];
			break;

		      case 'q':
			regno = mips32_to_micromips_reg_q_map[regno];
			break;

		      case 's':
			if (regno != SP)
			  regno = ILLEGAL_REG;
			break;

		      case 'y':
			if (regno != 31)
			  regno = ILLEGAL_REG;
			break;

		      case 'z':
			if (regno != ZERO)
			  regno = ILLEGAL_REG;
			break;

		      case 'j': /* Do nothing.  */
		      case 'p':
		      case 't':
		      case 'x':
			break;

		      default:
			abort ();
		    }

		  if (regno == ILLEGAL_REG)
		    break;

		  switch (c)
		    {
		      case 'b':
			INSERT_OPERAND (1, MB, *ip, regno);
			break;

		      case 'c':
			INSERT_OPERAND (1, MC, *ip, regno);
			break;

		      case 'd':
			INSERT_OPERAND (1, MD, *ip, regno);
			break;

		      case 'e':
			INSERT_OPERAND (1, ME, *ip, regno);
			break;

		      case 'f':
			INSERT_OPERAND (1, MF, *ip, regno);
			break;

		      case 'g':
			INSERT_OPERAND (1, MG, *ip, regno);
			break;

		      case 'h':
			INSERT_OPERAND (1, MH, *ip, regno);
			break;

		      case 'j':
			INSERT_OPERAND (1, MJ, *ip, regno);
			break;

		      case 'l':
			INSERT_OPERAND (1, ML, *ip, regno);
			break;

		      case 'm':
			INSERT_OPERAND (1, MM, *ip, regno);
			break;

		      case 'n':
			INSERT_OPERAND (1, MN, *ip, regno);
			break;

		      case 'p':
			INSERT_OPERAND (1, MP, *ip, regno);
			break;

		      case 'q':
			INSERT_OPERAND (1, MQ, *ip, regno);
			break;

		      case 'a':	/* Do nothing.  */
		      case 's':	/* Do nothing.  */
		      case 't':	/* Do nothing.  */
		      case 'x':	/* Do nothing.  */
		      case 'y':	/* Do nothing.  */
		      case 'z':	/* Do nothing.  */
			break;

		      default:
			abort ();
		    }
		  continue;

		case 'A':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    /* Check whether there is only a single bracketed
		       expression left.  If so, it must be the base register
		       and the constant must be zero.  */
		    if (*s == '(' && strchr (s + 1, '(') == 0)
		      {
			INSERT_OPERAND (1, IMMA, *ip, 0);
			continue;
		      }

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, -64, 64, 2))
		      break;

		    imm = ep.X_add_number >> 2;
		    INSERT_OPERAND (1, IMMA, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'B':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| ep.X_op != O_constant)
		      break;

		    for (imm = 0; imm < 8; imm++)
		      if (micromips_imm_b_map[imm] == ep.X_add_number)
			break;
		    if (imm >= 8)
		      break;

		    INSERT_OPERAND (1, IMMB, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'C':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| ep.X_op != O_constant)
		      break;

		    for (imm = 0; imm < 16; imm++)
		      if (micromips_imm_c_map[imm] == ep.X_add_number)
			break;
		    if (imm >= 16)
		      break;

		    INSERT_OPERAND (1, IMMC, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'D':	/* pc relative offset */
		case 'E':	/* pc relative offset */
		  my_getExpression (&offset_expr, s);
		  if (offset_expr.X_op == O_register)
		    break;
d11837 5
a11841 10
		  if (!forced_insn_length)
		    *offset_reloc = (int) BFD_RELOC_UNUSED + c;
		  else if (c == 'D')
		    *offset_reloc = BFD_RELOC_MICROMIPS_10_PCREL_S1;
		  else
		    *offset_reloc = BFD_RELOC_MICROMIPS_7_PCREL_S1;
		  s = expr_end;
		  continue;

		case 'F':
d11843 5
a11847 10
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 0, 16, 0))
		      break;

		    imm = ep.X_add_number;
		    INSERT_OPERAND (1, IMMF, *ip, imm);
d11849 13
a11861 4
		  s = expr_end;
		  continue;

		case 'G':
d11863 6
a11868 8
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    /* Check whether there is only a single bracketed
		       expression left.  If so, it must be the base register
		       and the constant must be zero.  */
		    if (*s == '(' && strchr (s + 1, '(') == 0)
d11870 14
a11883 2
			INSERT_OPERAND (1, IMMG, *ip, 0);
			continue;
d11885 1
a11885 21

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, -1, 15, 0))
		      break;

		    imm = ep.X_add_number & 15;
		    INSERT_OPERAND (1, IMMG, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'H':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    /* Check whether there is only a single bracketed
		       expression left.  If so, it must be the base register
		       and the constant must be zero.  */
		    if (*s == '(' && strchr (s + 1, '(') == 0)
d11887 5
a11891 2
			INSERT_OPERAND (1, IMMH, *ip, 0);
			continue;
a11892 7

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 0, 16, 1))
		      break;

		    imm = ep.X_add_number >> 1;
		    INSERT_OPERAND (1, IMMH, *ip, imm);
d11894 1
a11894 4
		  s = expr_end;
		  continue;

		case 'I':
d11896 2
a11897 7
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, -1, 127, 0))
		      break;
d11899 4
a11902 16
		    imm = ep.X_add_number & 127;
		    INSERT_OPERAND (1, IMMI, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'J':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    /* Check whether there is only a single bracketed
		       expression left.  If so, it must be the base register
		       and the constant must be zero.  */
		    if (*s == '(' && strchr (s + 1, '(') == 0)
d11904 13
a11916 2
			INSERT_OPERAND (1, IMMJ, *ip, 0);
			continue;
d11918 13
d11932 5
a11936 3
		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 0, 16, 2))
		      break;
d11938 3
a11940 5
		    imm = ep.X_add_number >> 2;
		    INSERT_OPERAND (1, IMMJ, *ip, imm);
		  }
		  s = expr_end;
		  continue;
d11942 2
a11943 21
		case 'L':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    /* Check whether there is only a single bracketed
		       expression left.  If so, it must be the base register
		       and the constant must be zero.  */
		    if (*s == '(' && strchr (s + 1, '(') == 0)
		      {
			INSERT_OPERAND (1, IMML, *ip, 0);
			continue;
		      }

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 0, 16, 0))
		      break;

		    imm = ep.X_add_number;
		    INSERT_OPERAND (1, IMML, *ip, imm);
d11945 2
a11946 2
		  s = expr_end;
		  continue;
d11948 15
a11962 9
		case 'M':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 1, 9, 0))
		      break;
d11964 4
a11967 5
		    imm = ep.X_add_number & 7;
		    INSERT_OPERAND (1, IMMM, *ip, imm);
		  }
		  s = expr_end;
		  continue;
d11969 4
a11972 26
		case 'N':	/* Register list for lwm and swm.  */
		  {
		    /* A comma-separated list of registers and/or
		       dash-separated contiguous ranges including
		       both ra and a set of one or more registers
		       starting at s0 up to s3 which have to be
		       consecutive, e.g.:

		       s0, ra
		       s0, s1, ra, s2, s3
		       s0-s2, ra

		       and any permutations of these.  */
		    unsigned int reglist;
		    int imm;

		    if (!reglist_lookup (&s, RTYPE_NUM | RTYPE_GP, &reglist))
		      break;

		    if ((reglist & 0xfff1ffff) != 0x80010000)
		      break;

		    reglist = (reglist >> 17) & 7;
		    reglist += 1;
		    if ((reglist & -reglist) != reglist)
		      break;
d11974 3
a11976 4
		    imm = ffs (reglist) - 1;
		    INSERT_OPERAND (1, IMMN, *ip, imm);
		  }
		  continue;
d11978 2
a11979 142
		case 'O':	/* sdbbp 4-bit code.  */
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 0, 16, 0))
		      break;

		    imm = ep.X_add_number;
		    INSERT_OPERAND (1, IMMO, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'P':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 0, 32, 2))
		      break;

		    imm = ep.X_add_number >> 2;
		    INSERT_OPERAND (1, IMMP, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'Q':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, -0x400000, 0x400000, 2))
		      break;

		    imm = ep.X_add_number >> 2;
		    INSERT_OPERAND (1, IMMQ, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'U':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    /* Check whether there is only a single bracketed
		       expression left.  If so, it must be the base register
		       and the constant must be zero.  */
		    if (*s == '(' && strchr (s + 1, '(') == 0)
		      {
			INSERT_OPERAND (1, IMMU, *ip, 0);
			continue;
		      }

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 0, 32, 2))
		      break;

		    imm = ep.X_add_number >> 2;
		    INSERT_OPERAND (1, IMMU, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'W':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 0, 64, 2))
		      break;

		    imm = ep.X_add_number >> 2;
		    INSERT_OPERAND (1, IMMW, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'X':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, -8, 8, 0))
		      break;

		    imm = ep.X_add_number;
		    INSERT_OPERAND (1, IMMX, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'Y':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;
		    int imm;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| expr_const_in_range (&ep, -2, 2, 2)
			|| !expr_const_in_range (&ep, -258, 258, 2))
		      break;

		    imm = ep.X_add_number >> 2;
		    imm = ((imm >> 1) & ~0xff) | (imm & 0xff);
		    INSERT_OPERAND (1, IMMY, *ip, imm);
		  }
		  s = expr_end;
		  continue;

		case 'Z':
		  {
		    bfd_reloc_code_real_type r[3];
		    expressionS ep;

		    if (my_getSmallExpression (&ep, r, s) > 0
			|| !expr_const_in_range (&ep, 0, 1, 0))
		      break;
		  }
		  s = expr_end;
		  continue;

		default:
		  as_bad (_("Internal error: bad microMIPS opcode "
			    "(unknown extension operand type `m%c'): %s %s"),
			  *args, insn->name, insn->args);
		  /* Further processing is fruitless.  */
		  return;
		}
d11982 1
a11982 1
	    case 'n':		/* Register list for 32-bit lwm and swm.  */
d11984 11
a11994 19
	      {
		/* A comma-separated list of registers and/or
		   dash-separated contiguous ranges including
		   at least one of ra and a set of one or more
		   registers starting at s0 up to s7 and then
		   s8 which have to be consecutive, e.g.:

		   ra
		   s0
		   ra, s0, s1, s2
		   s0-s8
		   s0-s5, ra

		   and any permutations of these.  */
		unsigned int reglist;
		int imm;
		int ra;

		if (!reglist_lookup (&s, RTYPE_NUM | RTYPE_GP, &reglist))
d11997 8
a12004 1
		if ((reglist & 0x3f00ffff) != 0)
d12006 3
d12010 5
a12014 5
		ra = (reglist >> 27) & 0x10;
		reglist = ((reglist >> 22) & 0x100) | ((reglist >> 16) & 0xff);
		reglist += 1;
		if ((reglist & -reglist) != reglist)
		  break;
d12016 13
a12028 5
		imm = (ffs (reglist) - 1) | ra;
		INSERT_OPERAND (1, RT, *ip, imm);
		imm_expr.X_op = O_absent;
	      }
	      continue;
d12030 3
a12032 13
	    case '|':		/* 4-bit trap code.  */
	      gas_assert (mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number
		  > MICROMIPSOP_MASK_TRAP)
		as_bad (_("Trap code (%lu) for %s not in 0..15 range"),
			(unsigned long) imm_expr.X_add_number,
			ip->insn_mo->name);
	      INSERT_OPERAND (1, TRAP, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
	      continue;
d12034 1
a12034 5
	    default:
	      as_bad (_("Bad char = '%c'\n"), *args);
	      abort ();
	    }
	  break;
d12039 1
a12039 1
      if (insn + 1 < past && !strcmp (insn->name, insn[1].name))
d12044 1
a12044 1
      else if (wrong_delay_slot_insns && need_delay_slot_ok)
a12055 2
#define SKIP_SPACE_TABS(S) { while (*(S) == ' ' || *(S) == '\t') ++(S); }

@


1.565
log
@gas/
	* config/tc-mips.c (insn_insert_operand): New function.
	(macro_build, mips16_macro_build): Put null character check
	in the for loop and convert continues to breaks.  Use operand
	structures to handle constant operands.
@
text
@d3705 841
a11519 40
/* Check whether an odd floating-point register is allowed.  */
static int
mips_oddfpreg_ok (const struct mips_opcode *insn, int argnum)
{
  const char *s = insn->name;

  if (insn->pinfo == INSN_MACRO)
    /* Let a macro pass, we'll catch it later when it is expanded.  */
    return 1;

  if (ISA_HAS_ODD_SINGLE_FPR (mips_opts.isa) || (mips_opts.arch == CPU_R5900))
    {
      /* Allow odd registers for single-precision ops.  */
      switch (insn->pinfo & (FP_S | FP_D))
	{
	case FP_S:
	case 0:
	  return 1;	/* both single precision - ok */
	case FP_D:
	  return 0;	/* both double precision - fail */
	default:
	  break;
	}

      /* Cvt.w.x and cvt.x.w allow an odd register for a 'w' or 's' operand.  */
      s = strchr (insn->name, '.');
      if (argnum == 2)
	s = s != NULL ? strchr (s + 1, '.') : NULL;
      return (s != NULL && (s[1] == 'w' || s[1] == 's'));
    } 

  /* Single-precision coprocessor loads and moves are OK too.  */
  if ((insn->pinfo & FP_S)
      && (insn->pinfo & (INSN_COPROC_MEMORY_DELAY | INSN_STORE_MEMORY
			 | INSN_LOAD_COPROC_DELAY | INSN_COPROC_MOVE_DELAY)))
    return 1;

  return 0;
}

@


1.564
log
@include/opcode/
	* mips.h (mips_operand_type, mips_reg_operand_type): New enums.
	(mips_operand, mips_int_operand, mips_mapped_int_operand)
	(mips_msb_operand, mips_reg_operand, mips_reg_pair_operand)
	(mips_pcrel_operand): New structures.
	(mips_insert_operand, mips_extract_operand, mips_signed_operand)
	(mips_decode_int_operand, mips_decode_pcrel_operand): New functions.
	(decode_mips_operand, decode_micromips_operand): Declare.

opcodes/
	* mips-formats.h: New file.
	* mips-opc.c: Include mips-formats.h.
	(reg_0_map): New static array.
	(decode_mips_operand): New function.
	* micromips-opc.c: Remove <stdio.h> include.  Include mips-formats.h.
	(reg_0_map, reg_28_map, reg_29_map, reg_31_map, reg_m16_map)
	(reg_mn_map, reg_q_map, reg_h_map1, reg_h_map2, int_b_map)
	(int_c_map): New static arrays.
	(decode_micromips_operand): New function.
	* mips-dis.c (micromips_to_32_reg_b_map, micromips_to_32_reg_c_map)
	(micromips_to_32_reg_d_map, micromips_to_32_reg_e_map)
	(micromips_to_32_reg_f_map, micromips_to_32_reg_g_map)
	(micromips_to_32_reg_h_map1, micromips_to_32_reg_h_map2)
	(micromips_to_32_reg_l_map, micromips_to_32_reg_m_map)
	(micromips_to_32_reg_n_map, micromips_to_32_reg_q_map)
	(micromips_imm_b_map, micromips_imm_c_map): Delete.
	(print_reg): New function.
	(mips_print_arg_state): New structure.
	(init_print_arg_state, print_insn_arg): New functions.
	(print_insn_args): Change interface and use mips_operand structures.
	Delete GET_OP_S.  Move GET_OP definition to...
	(print_insn_mips): ...here.  Update the call to print_insn_args.
	(print_insn_micromips): Use print_insn_args.

gas/
	* config/tc-mips.c (validate_mips_insn): Move further up file.
	Add insn_bits and decode_operand arguments.  Use the mips_operand
	fields to work out which bits an operand occupies.  Detect double
	definitions.
	(validate_micromips_insn): Move further up file.  Call into
	validate_mips_insn.
@
text
@d2047 9
d5413 1
d5417 1
d5467 1
a5467 1
  for (;;)
d5469 1
a5469 1
      switch (*fmt++)
a5470 3
	case '\0':
	  break;

a5473 102
	  continue;

	case '+':
	  switch (*fmt++)
	    {
	    case 'A':
	    case 'E':
	      INSERT_OPERAND (mips_opts.micromips,
			      EXTLSB, insn, va_arg (args, int));
	      continue;

	    case 'B':
	    case 'F':
	      /* Note that in the macro case, these arguments are already
		 in MSB form.  (When handling the instruction in the
		 non-macro case, these arguments are sizes from which
		 MSB values must be calculated.)  */
	      INSERT_OPERAND (mips_opts.micromips,
			      INSMSB, insn, va_arg (args, int));
	      continue;

	    case 'J':
	      gas_assert (!mips_opts.micromips);
	      INSERT_OPERAND (0, CODE10, insn, va_arg (args, int));
	      continue;

	    case 'C':
	    case 'G':
	    case 'H':
	      /* Note that in the macro case, these arguments are already
		 in MSBD form.  (When handling the instruction in the
		 non-macro case, these arguments are sizes from which
		 MSBD values must be calculated.)  */
	      INSERT_OPERAND (mips_opts.micromips,
			      EXTMSBD, insn, va_arg (args, int));
	      continue;

	    case 'Q':
	      gas_assert (!mips_opts.micromips);
	      INSERT_OPERAND (0, SEQI, insn, va_arg (args, int));
	      continue;

	    case 'j':
	      INSERT_OPERAND (mips_opts.micromips, EVAOFFSET, insn, va_arg (args, int));
	      continue;

	    default:
	      abort ();
	    }
	  continue;

	case '2':
	  INSERT_OPERAND (mips_opts.micromips, BP, insn, va_arg (args, int));
	  continue;

	case 'n':
	  gas_assert (mips_opts.micromips);
	case 't':
	case 'w':
	case 'E':
	  INSERT_OPERAND (mips_opts.micromips, RT, insn, va_arg (args, int));
	  continue;

	case 'c':
	  INSERT_OPERAND (mips_opts.micromips, CODE, insn, va_arg (args, int));
	  continue;

	case 'W':
	  gas_assert (!mips_opts.micromips);
	case 'T':
	  INSERT_OPERAND (mips_opts.micromips, FT, insn, va_arg (args, int));
	  continue;

	case 'G':
	  if (mips_opts.micromips)
	    INSERT_OPERAND (1, RS, insn, va_arg (args, int));
	  else
	    INSERT_OPERAND (0, RD, insn, va_arg (args, int));
	  continue;

	case 'K':
	  gas_assert (!mips_opts.micromips);
	case 'd':
	  INSERT_OPERAND (mips_opts.micromips, RD, insn, va_arg (args, int));
	  continue;

	case 'U':
	  gas_assert (!mips_opts.micromips);
	  {
	    int tmp = va_arg (args, int);

	    INSERT_OPERAND (0, RT, insn, tmp);
	    INSERT_OPERAND (0, RD, insn, tmp);
	  }
	  continue;

	case 'V':
	case 'S':
	  gas_assert (!mips_opts.micromips);
	  INSERT_OPERAND (0, FS, insn, va_arg (args, int));
	  continue;

d5475 1
a5475 33
	  continue;

	case '<':
	  INSERT_OPERAND (mips_opts.micromips,
			  SHAMT, insn, va_arg (args, int));
	  continue;

	case 'D':
	  gas_assert (!mips_opts.micromips);
	  INSERT_OPERAND (0, FD, insn, va_arg (args, int));
	  continue;

	case 'B':
	  gas_assert (!mips_opts.micromips);
	  INSERT_OPERAND (0, CODE20, insn, va_arg (args, int));
	  continue;

	case 'J':
	  gas_assert (!mips_opts.micromips);
	  INSERT_OPERAND (0, CODE19, insn, va_arg (args, int));
	  continue;

	case 'q':
	  gas_assert (!mips_opts.micromips);
	  INSERT_OPERAND (0, CODE2, insn, va_arg (args, int));
	  continue;

	case 'b':
	case 's':
	case 'r':
	case 'v':
	  INSERT_OPERAND (mips_opts.micromips, RS, insn, va_arg (args, int));
	  continue;
d5485 1
a5485 1
	  continue;
d5489 1
a5489 1
	  continue;
d5502 1
a5502 1
	  continue;
d5531 1
a5531 1
	  continue;
d5536 1
a5536 1
	  continue;
d5538 6
a5543 4
	case 'C':
	  gas_assert (!mips_opts.micromips);
	  INSERT_OPERAND (0, COPZ, insn, va_arg (args, int));
	  continue;
d5545 4
a5548 4
	case 'k':
	  INSERT_OPERAND (mips_opts.micromips,
			  CACHE, insn, va_arg (args, int));
	  continue;
d5550 3
a5552 48
	case '|':
	  gas_assert (mips_opts.micromips);
	  INSERT_OPERAND (1, TRAP, insn, va_arg (args, int));
	  continue;

	case '.':
	  gas_assert (mips_opts.micromips);
	  INSERT_OPERAND (1, OFFSET10, insn, va_arg (args, int));
	  continue;

	case '\\':
	  INSERT_OPERAND (mips_opts.micromips,
			  3BITPOS, insn, va_arg (args, int));
	  continue;

	case '~':
	  INSERT_OPERAND (mips_opts.micromips,
			  OFFSET12, insn, va_arg (args, int));
	  continue;

	case 'N':
	  gas_assert (mips_opts.micromips);
	  INSERT_OPERAND (1, BCC, insn, va_arg (args, int));
	  continue;

	case 'm':	/* Opcode extension character.  */
	  gas_assert (mips_opts.micromips);
	  switch (*fmt++)
	    {
	    case 'j':
	      INSERT_OPERAND (1, MJ, insn, va_arg (args, int));
	      break;

	    case 'p':
	      INSERT_OPERAND (1, MP, insn, va_arg (args, int));
	      break;

	    case 'F':
	      INSERT_OPERAND (1, IMMF, insn, va_arg (args, int));
	      break;

	    default:
	      abort ();
	    }
	  continue;

	default:
	  abort ();
a5553 1
      break;
d5567 1
d5583 1
a5583 1
  for (;;)
d5587 1
a5587 1
      c = *fmt++;
a5589 3
	case '\0':
	  break;

d5593 1
a5593 19
	  continue;

	case 'y':
	case 'w':
	  MIPS16_INSERT_OPERAND (RY, insn, va_arg (*args, int));
	  continue;

	case 'x':
	case 'v':
	  MIPS16_INSERT_OPERAND (RX, insn, va_arg (*args, int));
	  continue;

	case 'z':
	  MIPS16_INSERT_OPERAND (RZ, insn, va_arg (*args, int));
	  continue;

	case 'Z':
	  MIPS16_INSERT_OPERAND (MOVE32Z, insn, va_arg (*args, int));
	  continue;
d5599 1
a5599 5
	  continue;

	case 'X':
	  MIPS16_INSERT_OPERAND (REGR32, insn, va_arg (*args, int));
	  continue;
d5631 6
a5636 1
	  continue;
d5638 2
a5639 3
	case '6':
	  MIPS16_INSERT_OPERAND (IMM6, insn, va_arg (*args, int));
	  continue;
a5640 2

      break;
@


1.563
log
@gas/
	* config/tc-mips.c (mips16_macro_build): Remove 'Y' case.
@
text
@a1328 2
static int validate_mips_insn (const struct mips_opcode *);
static int validate_micromips_insn (const struct mips_opcode *);
d2708 105
d2851 2
a2852 1
	      if (!validate_mips_insn (&mips_opcodes[i]))
a10854 345
/* For consistency checking, verify that all bits are specified either
   by the match/mask part of the instruction definition, or by the
   operand list.  */
static int
validate_mips_insn (const struct mips_opcode *opc)
{
  const char *p = opc->args;
  char c;
  unsigned long used_bits = opc->mask;

  if ((used_bits & opc->match) != opc->match)
    {
      as_bad (_("internal: bad mips opcode (mask error): %s %s"),
	      opc->name, opc->args);
      return 0;
    }
#define USE_BITS(mask,shift)	(used_bits |= ((mask) << (shift)))
  while (*p)
    switch (c = *p++)
      {
      case ',': break;
      case '(': break;
      case ')': break;
      case '+':
    	switch (c = *p++)
	  {
	  case '1': USE_BITS (OP_MASK_UDI1,     OP_SH_UDI1); 	break;
	  case '2': USE_BITS (OP_MASK_UDI2,	OP_SH_UDI2); 	break;
	  case '3': USE_BITS (OP_MASK_UDI3,	OP_SH_UDI3); 	break;
	  case '4': USE_BITS (OP_MASK_UDI4,	OP_SH_UDI4); 	break;
	  case 'A': USE_BITS (OP_MASK_SHAMT,	OP_SH_SHAMT);	break;
	  case 'B': USE_BITS (OP_MASK_INSMSB,	OP_SH_INSMSB);	break;
	  case 'C': USE_BITS (OP_MASK_EXTMSBD,	OP_SH_EXTMSBD);	break;
	  case 'E': USE_BITS (OP_MASK_SHAMT,	OP_SH_SHAMT);	break;
	  case 'F': USE_BITS (OP_MASK_INSMSB,	OP_SH_INSMSB);	break;
	  case 'G': USE_BITS (OP_MASK_EXTMSBD,	OP_SH_EXTMSBD);	break;
	  case 'H': USE_BITS (OP_MASK_EXTMSBD,	OP_SH_EXTMSBD);	break;
	  case 'I': break;
	  case 'J': USE_BITS (OP_MASK_CODE10,	OP_SH_CODE10);	break;
	  case 't': USE_BITS (OP_MASK_RT,	OP_SH_RT);	break;
	  case 'x': USE_BITS (OP_MASK_BBITIND,	OP_SH_BBITIND);	break;
	  case 'X': USE_BITS (OP_MASK_BBITIND,	OP_SH_BBITIND);	break;
	  case 'p': USE_BITS (OP_MASK_CINSPOS,	OP_SH_CINSPOS);	break;
	  case 'P': USE_BITS (OP_MASK_CINSPOS,	OP_SH_CINSPOS);	break;
	  case 'Q': USE_BITS (OP_MASK_SEQI,	OP_SH_SEQI);	break;
	  case 's': USE_BITS (OP_MASK_CINSLM1,	OP_SH_CINSLM1);	break;
	  case 'S': USE_BITS (OP_MASK_CINSLM1,	OP_SH_CINSLM1);	break;
	  case 'z': USE_BITS (OP_MASK_RZ,	OP_SH_RZ);	break;
	  case 'Z': USE_BITS (OP_MASK_FZ,	OP_SH_FZ);	break;
	  case 'a': USE_BITS (OP_MASK_OFFSET_A,	OP_SH_OFFSET_A); break;
	  case 'b': USE_BITS (OP_MASK_OFFSET_B,	OP_SH_OFFSET_B); break;
	  case 'c': USE_BITS (OP_MASK_OFFSET_C,	OP_SH_OFFSET_C); break;
	  case 'i': USE_BITS (OP_MASK_TARGET,	OP_SH_TARGET);	break;
	  case 'j': USE_BITS (OP_MASK_EVAOFFSET, OP_SH_EVAOFFSET); break;

	  default:
	    as_bad (_("internal: bad mips opcode (unknown extension operand type `+%c'): %s %s"),
		    c, opc->name, opc->args);
	    return 0;
	  }
	break;
      case '<': USE_BITS (OP_MASK_SHAMT,	OP_SH_SHAMT);	break;
      case '>':	USE_BITS (OP_MASK_SHAMT,	OP_SH_SHAMT);	break;
      case 'A': break;
      case 'B': USE_BITS (OP_MASK_CODE20,       OP_SH_CODE20);  break;
      case 'C':	USE_BITS (OP_MASK_COPZ,		OP_SH_COPZ);	break;
      case 'D':	USE_BITS (OP_MASK_FD,		OP_SH_FD);	break;
      case 'E':	USE_BITS (OP_MASK_RT,		OP_SH_RT);	break;
      case 'F': break;
      case 'G':	USE_BITS (OP_MASK_RD,		OP_SH_RD);	break;
      case 'H': USE_BITS (OP_MASK_SEL,		OP_SH_SEL);	break;
      case 'I': break;
      case 'J': USE_BITS (OP_MASK_CODE19,       OP_SH_CODE19);  break;
      case 'K':	USE_BITS (OP_MASK_RD,		OP_SH_RD);	break;
      case 'L': break;
      case 'M':	USE_BITS (OP_MASK_CCC,		OP_SH_CCC);	break;
      case 'N':	USE_BITS (OP_MASK_BCC,		OP_SH_BCC);	break;
      case 'O':	USE_BITS (OP_MASK_ALN,		OP_SH_ALN);	break;
      case 'Q':	USE_BITS (OP_MASK_VSEL,		OP_SH_VSEL);
		USE_BITS (OP_MASK_FT,		OP_SH_FT);	break;
      case 'R':	USE_BITS (OP_MASK_FR,		OP_SH_FR);	break;
      case 'S':	USE_BITS (OP_MASK_FS,		OP_SH_FS);	break;
      case 'T':	USE_BITS (OP_MASK_FT,		OP_SH_FT);	break;
      case 'V':	USE_BITS (OP_MASK_FS,		OP_SH_FS);	break;
      case 'W':	USE_BITS (OP_MASK_FT,		OP_SH_FT);	break;
      case 'X':	USE_BITS (OP_MASK_FD,		OP_SH_FD);	break;
      case 'Y':	USE_BITS (OP_MASK_FS,		OP_SH_FS);	break;
      case 'Z':	USE_BITS (OP_MASK_FT,		OP_SH_FT);	break;
      case 'a':	USE_BITS (OP_MASK_TARGET,	OP_SH_TARGET);	break;
      case 'b':	USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
      case 'c':	USE_BITS (OP_MASK_CODE,		OP_SH_CODE);	break;
      case 'd':	USE_BITS (OP_MASK_RD,		OP_SH_RD);	break;
      case 'f': break;
      case 'h':	USE_BITS (OP_MASK_PREFX,	OP_SH_PREFX);	break;
      case 'i':	USE_BITS (OP_MASK_IMMEDIATE,	OP_SH_IMMEDIATE); break;
      case 'j':	USE_BITS (OP_MASK_DELTA,	OP_SH_DELTA);	break;
      case 'k':	USE_BITS (OP_MASK_CACHE,	OP_SH_CACHE);	break;
      case 'l': break;
      case 'o': USE_BITS (OP_MASK_DELTA,	OP_SH_DELTA);	break;
      case 'p':	USE_BITS (OP_MASK_DELTA,	OP_SH_DELTA);	break;
      case 'q':	USE_BITS (OP_MASK_CODE2,	OP_SH_CODE2);	break;
      case 'r': USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
      case 's':	USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
      case 't':	USE_BITS (OP_MASK_RT,		OP_SH_RT);	break;
      case 'u':	USE_BITS (OP_MASK_IMMEDIATE,	OP_SH_IMMEDIATE); break;
      case 'v':	USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
      case 'w':	USE_BITS (OP_MASK_RT,		OP_SH_RT);	break;
      case 'x': break;
      case 'z': break;
      case 'P': USE_BITS (OP_MASK_PERFREG,	OP_SH_PERFREG);	break;
      case 'U': USE_BITS (OP_MASK_RD,           OP_SH_RD);
	        USE_BITS (OP_MASK_RT,           OP_SH_RT);	break;
      case 'e': USE_BITS (OP_MASK_VECBYTE,	OP_SH_VECBYTE);	break;
      case '%': USE_BITS (OP_MASK_VECALIGN,	OP_SH_VECALIGN); break;
      case '1': USE_BITS (OP_MASK_STYPE,	OP_SH_STYPE);	break;
      case '2': USE_BITS (OP_MASK_BP,		OP_SH_BP);	break;
      case '3': USE_BITS (OP_MASK_SA3,  	OP_SH_SA3);	break;
      case '4': USE_BITS (OP_MASK_SA4,  	OP_SH_SA4);	break;
      case '5': USE_BITS (OP_MASK_IMM8, 	OP_SH_IMM8);	break;
      case '6': USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
      case '7': USE_BITS (OP_MASK_DSPACC,	OP_SH_DSPACC);	break;
      case '8': USE_BITS (OP_MASK_WRDSP,	OP_SH_WRDSP);	break;
      case '9': USE_BITS (OP_MASK_DSPACC_S,	OP_SH_DSPACC_S);break;
      case '0': USE_BITS (OP_MASK_DSPSFT,	OP_SH_DSPSFT);	break;
      case '\'': USE_BITS (OP_MASK_RDDSP,	OP_SH_RDDSP);	break;
      case ':': USE_BITS (OP_MASK_DSPSFT_7,	OP_SH_DSPSFT_7);break;
      case '@@': USE_BITS (OP_MASK_IMM10,	OP_SH_IMM10);	break;
      case '!': USE_BITS (OP_MASK_MT_U,		OP_SH_MT_U);	break;
      case '$': USE_BITS (OP_MASK_MT_H,		OP_SH_MT_H);	break;
      case '*': USE_BITS (OP_MASK_MTACC_T,	OP_SH_MTACC_T);	break;
      case '&': USE_BITS (OP_MASK_MTACC_D,	OP_SH_MTACC_D);	break;
      case '\\': USE_BITS (OP_MASK_3BITPOS,	OP_SH_3BITPOS);	break;
      case '~': USE_BITS (OP_MASK_OFFSET12,	OP_SH_OFFSET12); break;
      case 'g': USE_BITS (OP_MASK_RD,		OP_SH_RD);	break;
      default:
	as_bad (_("internal: bad mips opcode (unknown operand type `%c'): %s %s"),
		c, opc->name, opc->args);
	return 0;
      }
#undef USE_BITS
  if (used_bits != 0xffffffff)
    {
      as_bad (_("internal: bad mips opcode (bits 0x%lx undefined): %s %s"),
	      ~used_bits & 0xffffffff, opc->name, opc->args);
      return 0;
    }
  return 1;
}

/* For consistency checking, verify that the length implied matches the
   major opcode and that all bits are specified either by the match/mask
   part of the instruction definition, or by the operand list.  */

static int
validate_micromips_insn (const struct mips_opcode *opc)
{
  unsigned long match = opc->match;
  unsigned long mask = opc->mask;
  const char *p = opc->args;
  unsigned long insn_bits;
  unsigned long used_bits;
  unsigned long major;
  unsigned int length;
  char e;
  char c;

  if ((mask & match) != match)
    {
      as_bad (_("Internal error: bad microMIPS opcode (mask error): %s %s"),
	      opc->name, opc->args);
      return 0;
    }
  length = micromips_insn_length (opc);
  if (length != 2 && length != 4)
    {
      as_bad (_("Internal error: bad microMIPS opcode (incorrect length: %u): "
		"%s %s"), length, opc->name, opc->args);
      return 0;
    }
  major = match >> (10 + 8 * (length - 2));
  if ((length == 2 && (major & 7) != 1 && (major & 6) != 2)
      || (length == 4 && (major & 7) != 0 && (major & 4) != 4))
    {
      as_bad (_("Internal error: bad microMIPS opcode "
		"(opcode/length mismatch): %s %s"), opc->name, opc->args);
      return 0;
    }

  /* Shift piecewise to avoid an overflow where unsigned long is 32-bit.  */
  insn_bits = 1 << 4 * length;
  insn_bits <<= 4 * length;
  insn_bits -= 1;
  used_bits = mask;
#define USE_BITS(field) \
  (used_bits |= MICROMIPSOP_MASK_##field << MICROMIPSOP_SH_##field)
  while (*p)
    switch (c = *p++)
      {
      case ',': break;
      case '(': break;
      case ')': break;
      case '+':
	e = c;
    	switch (c = *p++)
	  {
	  case 'A': USE_BITS (EXTLSB);	break;
	  case 'B': USE_BITS (INSMSB);	break;
	  case 'C': USE_BITS (EXTMSBD);	break;
	  case 'E': USE_BITS (EXTLSB);	break;
	  case 'F': USE_BITS (INSMSB);	break;
	  case 'G': USE_BITS (EXTMSBD);	break;
	  case 'H': USE_BITS (EXTMSBD);	break;
	  case 'i': USE_BITS (TARGET);	break;
	  case 'j': USE_BITS (EVAOFFSET);	break;
	  default:
	    as_bad (_("Internal error: bad mips opcode "
		      "(unknown extension operand type `%c%c'): %s %s"),
		    e, c, opc->name, opc->args);
	    return 0;
	  }
	break;
      case 'm':
	e = c;
    	switch (c = *p++)
	  {
	  case 'A': USE_BITS (IMMA);	break;
	  case 'B': USE_BITS (IMMB);	break;
	  case 'C': USE_BITS (IMMC);	break;
	  case 'D': USE_BITS (IMMD);	break;
	  case 'E': USE_BITS (IMME);	break;
	  case 'F': USE_BITS (IMMF);	break;
	  case 'G': USE_BITS (IMMG);	break;
	  case 'H': USE_BITS (IMMH);	break;
	  case 'I': USE_BITS (IMMI);	break;
	  case 'J': USE_BITS (IMMJ);	break;
	  case 'L': USE_BITS (IMML);	break;
	  case 'M': USE_BITS (IMMM);	break;
	  case 'N': USE_BITS (IMMN);	break;
	  case 'O': USE_BITS (IMMO);	break;
	  case 'P': USE_BITS (IMMP);	break;
	  case 'Q': USE_BITS (IMMQ);	break;
	  case 'U': USE_BITS (IMMU);	break;
	  case 'W': USE_BITS (IMMW);	break;
	  case 'X': USE_BITS (IMMX);	break;
	  case 'Y': USE_BITS (IMMY);	break;
	  case 'Z': break;
	  case 'a': break;
	  case 'b': USE_BITS (MB);	break;
	  case 'c': USE_BITS (MC);	break;
	  case 'd': USE_BITS (MD);	break;
	  case 'e': USE_BITS (ME);	break;
	  case 'f': USE_BITS (MF);	break;
	  case 'g': USE_BITS (MG);	break;
	  case 'h': USE_BITS (MH);	break;
	  case 'j': USE_BITS (MJ);	break;
	  case 'l': USE_BITS (ML);	break;
	  case 'm': USE_BITS (MM);	break;
	  case 'n': USE_BITS (MN);	break;
	  case 'p': USE_BITS (MP);	break;
	  case 'q': USE_BITS (MQ);	break;
	  case 'r': break;
	  case 's': break;
	  case 't': break;
	  case 'x': break;
	  case 'y': break;
	  case 'z': break;
	  default:
	    as_bad (_("Internal error: bad mips opcode "
		      "(unknown extension operand type `%c%c'): %s %s"),
		    e, c, opc->name, opc->args);
	    return 0;
	  }
	break;
      case '.': USE_BITS (OFFSET10);	break;
      case '1': USE_BITS (STYPE);	break;
      case '2': USE_BITS (BP);		break;
      case '3': USE_BITS (SA3);		break;
      case '4': USE_BITS (SA4);		break;
      case '5': USE_BITS (IMM8);	break;
      case '6': USE_BITS (RS);		break;
      case '7': USE_BITS (DSPACC);	break;
      case '8': USE_BITS (WRDSP);	break;
      case '0': USE_BITS (DSPSFT);	break;
      case '<': USE_BITS (SHAMT);	break;
      case '>': USE_BITS (SHAMT);	break;
      case '@@': USE_BITS (IMM10);	break;
      case 'B': USE_BITS (CODE10);	break;
      case 'C': USE_BITS (COPZ);	break;
      case 'D': USE_BITS (FD);		break;
      case 'E': USE_BITS (RT);		break;
      case 'G': USE_BITS (RS);		break;
      case 'H': USE_BITS (SEL);		break;
      case 'K': USE_BITS (RS);		break;
      case 'M': USE_BITS (CCC);		break;
      case 'N': USE_BITS (BCC);		break;
      case 'R': USE_BITS (FR);		break;
      case 'S': USE_BITS (FS);		break;
      case 'T': USE_BITS (FT);		break;
      case 'V': USE_BITS (FS);		break;
      case '\\': USE_BITS (3BITPOS);	break;
      case '^': USE_BITS (RD);		break;
      case 'a': USE_BITS (TARGET);	break;
      case 'b': USE_BITS (RS);		break;
      case 'c': USE_BITS (CODE);	break;
      case 'd': USE_BITS (RD);		break;
      case 'h': USE_BITS (PREFX);	break;
      case 'i': USE_BITS (IMMEDIATE);	break;
      case 'j': USE_BITS (DELTA);	break;
      case 'k': USE_BITS (CACHE);	break;
      case 'n': USE_BITS (RT);		break;
      case 'o': USE_BITS (DELTA);	break;
      case 'p': USE_BITS (DELTA);	break;
      case 'q': USE_BITS (CODE2);	break;
      case 'r': USE_BITS (RS);		break;
      case 's': USE_BITS (RS);		break;
      case 't': USE_BITS (RT);		break;
      case 'u': USE_BITS (IMMEDIATE);	break;
      case 'v': USE_BITS (RS);		break;
      case 'w': USE_BITS (RT);		break;
      case 'y': USE_BITS (RS3);		break;
      case 'z': break;
      case '|': USE_BITS (TRAP);	break;
      case '~': USE_BITS (OFFSET12);	break;
      default:
	as_bad (_("Internal error: bad microMIPS opcode "
		  "(unknown operand type `%c'): %s %s"),
		c, opc->name, opc->args);
	return 0;
      }
#undef USE_BITS
  if (used_bits != insn_bits)
    {
      if (~used_bits & insn_bits)
	as_bad (_("Internal error: bad microMIPS opcode "
		  "(bits 0x%lx undefined): %s %s"),
		~used_bits & insn_bits, opc->name, opc->args);
      if (used_bits & ~insn_bits)
	as_bad (_("Internal error: bad microMIPS opcode "
		  "(bits 0x%lx defined): %s %s"),
		used_bits & ~insn_bits, opc->name, opc->args);
      return 0;
    }
  return 1;
}

@


1.562
log
@gas/
	* config/tc-mips.c (macro_build): Take an int for "C", "k", "\\"
	and "~".
	(macro): Update accordingly.
@
text
@a5690 10
	case 'Y':
	  {
	    int regno;

	    regno = va_arg (*args, int);
	    regno = ((regno & 7) << 2) | ((regno & 0x18) >> 3);
	    MIPS16_INSERT_OPERAND (REG32R, insn, regno);
	  }
	  continue;

@


1.561
log
@gas/
	* config/tc-mips.c (imm_expr, imm2_expr, offset_expr): Tweak commentary.
	(imm_reloc): Delete.
	(md_assemble): Remove imm_reloc handling.
	(mips_ip): Update commentary.  Use offset_expr and offset_reloc
	rather than imm_expr and imm_reloc for 'i', 'j' and 'u'.
	Use a temporary array rather than imm_reloc when parsing
	constant expressions.  Remove imm_reloc initialization.
	(mips16_ip): Update commentary.  Use offset_expr and offset_reloc
	for the relaxable field.  Use a relax_char variable to track the
	type of this field.  Remove imm_reloc initialization.
@
text
@d5562 1
a5562 1
	  INSERT_OPERAND (0, COPZ, insn, va_arg (args, unsigned long));
d5567 1
a5567 1
			  CACHE, insn, va_arg (args, unsigned long));
d5582 1
a5582 1
			  3BITPOS, insn, va_arg (args, unsigned int));
d5587 1
a5587 1
			  OFFSET12, insn, va_arg (args, unsigned long));
d8183 1
a8183 4
      {
	unsigned long temp = (treg << 16) | (0x01);
	macro_build (NULL, "c2", "C", temp);
      }
d8188 1
a8188 4
      {
	unsigned long temp = (0x02);
	macro_build (NULL, "c2", "C", temp);
      }
d8193 1
a8193 4
      {
	unsigned long temp = (treg << 16) | (0x02);
	macro_build (NULL, "c2", "C", temp);
      }
d8203 1
a8203 4
      {
	unsigned long temp = (treg << 16) | 0x03;
	macro_build (NULL, "c2", "C", temp);
      }
d8825 1
a8825 1
			     (unsigned long) offset_expr.X_add_number, breg);
d8837 1
a8837 1
		macro_build (NULL, s, fmt, treg, 0L, tempreg);
d8884 1
a8884 1
			 (unsigned long) offset_expr.X_add_number, tempreg);
d8898 1
a8898 1
	    macro_build (NULL, s, fmt, treg, 0L, tempreg);
d9754 1
a9754 1
      macro_build (NULL, s, "C", ip->insn_opcode);
d10453 1
a10453 2
	macro_build (NULL, s, "t,~(b)",
		     tempreg, (unsigned long) ep->X_add_number, breg);
d10464 1
a10464 1
		     tempreg, (unsigned long) ep->X_add_number, breg);
@


1.560
log
@include/opcode/
	* mips.h: Document MIPS16 "I" opcode.

opcodes/
	* mips16-opc.c (mips16_opcodes): Use "I" for immediate operands
	in macros.

gas/
	* config/tc-mips.c (mips16_ip): Handle "I".
@
text
@d1813 2
a1814 2
/* Expressions which appear in instructions.  These are set by
   mips_ip.  */
a1817 1
static expressionS offset_expr;
d1819 4
a1822 1
/* Relocs associated with imm_expr and offset_expr.  */
d1824 1
a1824 2
static bfd_reloc_code_real_type imm_reloc[3]
  = {BFD_RELOC_UNUSED, BFD_RELOC_UNUSED, BFD_RELOC_UNUSED};
a2973 3
  imm_reloc[0] = BFD_RELOC_UNUSED;
  imm_reloc[1] = BFD_RELOC_UNUSED;
  imm_reloc[2] = BFD_RELOC_UNUSED;
d3003 1
a3003 3
      if (imm_expr.X_op != O_absent)
	append_insn (&insn, &imm_expr, imm_reloc, FALSE);
      else if (offset_expr.X_op != O_absent)
d11186 6
a11191 4
/* This routine assembles an instruction into its binary format.  As a
   side effect, it sets one of the global variables imm_reloc or
   offset_reloc to the type of relocation to do if one of the operands
   is an address expression.  */
a11336 3
      imm_reloc[0] = BFD_RELOC_UNUSED;
      imm_reloc[1] = BFD_RELOC_UNUSED;
      imm_reloc[2] = BFD_RELOC_UNUSED;
d12097 2
d12108 1
a12108 1
		    i = my_getSmallExpression (&imm_expr, imm_reloc, s);
d12140 1
d12151 1
a12151 1
		i = my_getSmallExpression (&imm_expr, imm_reloc, s);
d12897 2
a12898 2
	      *imm_reloc = BFD_RELOC_LO16;
	      if (my_getSmallExpression (&imm_expr, imm_reloc, s) == 0)
d12916 3
a12918 3
		  if (imm_expr.X_op != O_constant
		      || imm_expr.X_add_number < minval
		      || imm_expr.X_add_number > maxval)
d12922 2
a12923 2
		      if (imm_expr.X_op == O_constant
			  || imm_expr.X_op == O_big)
d12964 5
a12968 5
	      *imm_reloc = BFD_RELOC_LO16;
	      if (my_getSmallExpression (&imm_expr, imm_reloc, s) == 0
		  && imm_expr.X_op == O_constant
		  && (imm_expr.X_add_number < 0
		      || imm_expr.X_add_number >= 0x10000))
d12970 1
a12970 1
			(unsigned long) imm_expr.X_add_number);
d13834 3
a13836 6
/* This routine assembles an instruction into its binary format when
   assembling for the mips16.  As a side effect, it sets one of the
   global variables imm_reloc or offset_reloc to the type of relocation
   to do if one of the operands is an address expression.  It also sets
   forced_insn_length to the resulting instruction size in bytes if the
   user explicitly requested a small or extended instruction.  */
d13899 1
a13928 3
      imm_reloc[0] = BFD_RELOC_UNUSED;
      imm_reloc[1] = BFD_RELOC_UNUSED;
      imm_reloc[2] = BFD_RELOC_UNUSED;
d13934 1
d13955 10
a13964 5
		  if (imm_expr.X_op == O_constant
		      && *imm_reloc > BFD_RELOC_UNUSED
		      && insn->pinfo != INSN_MACRO
		      && calculate_reloc (*offset_reloc,
					  imm_expr.X_add_number, &value))
d13966 3
a13968 5
		      mips16_immed (NULL, 0, *imm_reloc - BFD_RELOC_UNUSED,
				    *offset_reloc, value, forced_insn_length,
				    &ip->insn_opcode);
		      imm_expr.X_op = O_absent;
		      *imm_reloc = BFD_RELOC_UNUSED;
d13971 9
d14150 1
a14150 1
	      i = my_getSmallExpression (&imm_expr, imm_reloc, s);
d14153 1
a14153 11
		  if (imm_expr.X_op != O_constant)
		    {
		      forced_insn_length = 4;
		      ip->insn_opcode |= MIPS16_EXTEND;
		    }
		  else
		    {
		      /* We need to relax this instruction.  */
		      *offset_reloc = *imm_reloc;
		      *imm_reloc = (int) BFD_RELOC_UNUSED + c;
		    }
d14157 1
a14157 1
	      *imm_reloc = BFD_RELOC_UNUSED;
d14165 2
a14166 2
	      my_getExpression (&imm_expr, s);
	      if (imm_expr.X_op == O_register)
d14176 1
a14176 1
			 still set up imm_expr, so that we handle
d14178 3
a14180 3
		      imm_expr.X_op = O_constant;
		      imm_expr.X_add_number = 0;
		      *imm_reloc = (int) BFD_RELOC_UNUSED + c;
d14188 1
a14188 1
	      *imm_reloc = (int) BFD_RELOC_UNUSED + c;
d14206 1
a14206 1
	      *offset_reloc = (int) BFD_RELOC_UNUSED + c;
@


1.559
log
@	include/elf/
	* mips.h (EF_MIPS_NAN2008): New macro.

	bfd/
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Handle
	EF_MIPS_NAN2008.
	(_bfd_mips_elf_print_private_bfd_data): Likewise.

	binutils/
	* readelf.c (get_machine_flags): Handle EF_MIPS_NAN2008.

	gas/
	* config/tc-mips.c (mips_flag_nan2008): New variable.
	(options): Add OPTION_NAN enum value.
	(md_longopts): Handle it.
	(md_parse_option): Likewise.
	(s_nan): New function.
	(mips_elf_final_processing): Handle EF_MIPS_NAN2008.
	(md_show_usage): Add -mnan.

	* doc/as.texinfo (Overview): Add -mnan.
	* doc/c-mips.texi (MIPS Opts): Document -mnan.
	(MIPS NaN Encodings): New node.  Document .nan directive.
	(MIPS-Dependent): List the new node.

	gas/testsuite/
	* gas/mips/nan-2008-1.d: New test.
	* gas/mips/nan-2008-2.d: New test.
	* gas/mips/nan-2008-3.d: New test.
	* gas/mips/nan-2008-4.d: New test.
	* gas/mips/nan-legacy-1.d: New test.
	* gas/mips/nan-legacy-2.d: New test.
	* gas/mips/nan-legacy-3.d: New test.
	* gas/mips/nan-legacy-4.d: New test.
	* gas/mips/nan-legacy-5.d: New test.
	* gas/mips/nan-error-1.l: New list test.
	* gas/mips/nan-error-2.l: New list test.
	* gas/mips/nan-2008-override.s: New test source.
	* gas/mips/nan-2008.s: New test source.
	* gas/mips/nan-legacy-override.s: New test source.
	* gas/mips/nan-legacy.s: New test source.
	* gas/mips/nan-error-1.s: New test source.
	* gas/mips/nan-error-2.s: New test source.
	* gas/mips/mips.exp: Run the new tests.

	ld/testsuite/
	* ld-mips-elf/nan-2008.d: New test.
	* ld-mips-elf/nan-legacy.d: New test.
	* ld-mips-elf/nan-mixed-1.d: New test.
	* ld-mips-elf/nan-mixed-2.d: New test.
	* ld-mips-elf/nan-2008.s: New test source.
	* ld-mips-elf/nan-legacy.s: New test source.
@
text
@d14226 10
@


1.558
log
@gas/
	* config/tc-mips.c (mips_ip): Unconditionally parse an expression
	for 'A' and assume that the constant has been elided if the result
	is an O_register.

gas/testsuite/
	* gas/mips/la.s, gas/mips/la.d, gas/mips/la-svr4pic.d,
	gas/mips/la-xgot.d: Add tests for bracketed addresses.
@
text
@d275 3
d1316 1
d1448 1
d1564 1
d1689 1
d15272 12
d17174 24
d18797 3
d19637 10
a19646 2
--[no-]relax-branch	[dis]allow out-of-range branches to be relaxed\n"
		     ));
@


1.557
log
@include/opcode/
	* mips.h (M_ACLR_OB, M_ASET_OB, M_CACHE_OB, M_CACHEE_OB, M_L_DOB)
	(M_LB_A, M_LBE_OB, M_LBU_A, M_LBUE_OB, M_LD_A, M_LD_OB, M_LDC2_OB)
	(M_LDL_OB, M_LDM_OB, M_LDP_OB, M_LDR_OB, M_LH_A, M_LHE_OB, M_LHU_A)
	(M_LHUE_OB, M_LL_OB, M_LLD_OB, M_LLE_OB, M_LS_A, M_LW_A, M_LWE_OB)
	(M_LWC0_A, M_LWC1_A, M_LWC2_A, M_LWC2_OB, M_LWC3_A, M_LWL_A, M_LWL_OB)
	(M_LWLE_OB, M_LWM_OB, M_LWP_OB, M_LWR_A, M_LWR_OB, M_LWRE_OB, M_LWU_OB)
	(M_PREF_OB, M_PREFE_OB, M_S_DOB, M_SAA_OB, M_SAAD_OB, M_SC_OB)
	(M_SCD_OB, M_SCE_OB, M_SD_A, M_SD_OB, M_SDC2_OB, M_SDL_OB, M_SDM_OB)
	(M_SDP_OB, M_SDR_OB, M_SB_A, M_SBE_OB, M_SH_A, M_SHE_OB, M_SW_A)
	(M_SWE_OB, M_SWC0_A, M_SWC1_A, M_SWC2_A, M_SWC2_OB, M_SWC3_A, M_SWL_A)
	(M_SWL_OB, M_SWLE_OB, M_SWM_OB, M_SWP_OB, M_SWR_A, M_SWR_OB, M_SWRE_OB)
	(M_ULD, M_ULH, M_ULHU, M_ULW, M_USH, M_USW, M_USD): Delete.
	(M_ULD_A, M_ULH_A, M_ULHU_A, M_ULW_A, M_USH_A, M_USW_A, M_USD_A):
	Rename to...
	(M_ULD_AB, M_ULH_AB, M_ULHU_AB, M_ULW_AB, M_USH_AB, M_USW_AB)
	(M_USD_AB): ...these.

opcodes/
	* mips-opc.c (mips_builtin_opcodes): Remove o(b) macros.  Move LD
	and SD A(B) macros up.
	* micromips-opc.c (micromips_opcodes): Likewise.

gas/
	* config/tc-mips.c (gprel16_reloc_p): New function.
	(macro_read_relocs): Assume BFD_RELOC_LO16 if all relocs are
	BFD_RELOC_UNUSED.
	(offset_high_part, small_offset_p): New functions.
	(nacro): Use them.  Remove *_OB and *_DOB cases.  For single-
	register load and store macros, handle the 16-bit offset case first.
	If a 16-bit offset is not suitable for the instruction we're
	generating, load it into the temporary register using
	ADDRESS_ADDI_INSN.  Make the M_LI_DD code fall through into the
	M_L_DAB code once the address has been constructed.  For double load
	and store macros, again handle the 16-bit offset case first.
	If the second register cannot be accessed from the same high
	part as the first, load it into AT using ADDRESS_ADDI_INSN.
	Fix the handling of LD in cases where the first register is the
	same as the base.  Also handle the case where the offset is
	not 16 bits and the second register cannot be accessed from the
	same high part as the first.  For unaligned loads and stores,
	fuse the offbits == 12 and old "ab" handling.  Apply this handling
	whenever the second offset needs a different high part from the first.
	Construct the offset using ADDRESS_ADDI_INSN where possible,
	for offbits == 16 as well as offbits == 12.  Use offset_reloc
	when constructing the individual loads and stores.
	(mips_ip): Set up imm_expr, imm2_expr, offset_expr, imm_reloc
	and offset_reloc before matching against a particular opcode.
	Handle elided 'A' constants.  Allow 'A' constants to use
	relocation operators.

gas/testsuite/
	* gas/mips/ldstla-32.d: Avoid "lui at,0x0" sequences for
	truncated constants.
	* gas/mips/ldstla-32-shared.d: Likewise.
	* gas/mips/mcu.d: Use ADDIU in preference to LI+ADDU when adding
	16-bit constants to the base.
	* gas/mips/micromips@@mcu.d: Likewise.
	* gas/mips/micromips@@cache.d: Likewise.
	* gas/mips/micromips@@pref.d: Likewise.
	* gas/mips/micromips.d, gas/mips/micromips-insn32.d,
	gas/mips/micromips-noinsn32.d, gas/mips/micromips-trap.d: Likewise.
	Allow the full 16-bit offset range to be used for SB, LB and LBU in
	USH and ULH sequences.  Fix the expected output for LD and SD when
	the two LW and SW offsets need different high parts.
	* gas/mips/eva.s: Test PREFE with relocation operators.
	* gas/mips/eva.d: Use ADDIU in preference to LI+ADDU for 16-bit
	constants.  Update after eva.s change.
	* gas/mips/micromips@@eva.d: Likewise.
	* gas/mips/ld-reloc.s, gas/mips/ld-reloc.d, gas/mips/l_d-reloc.s,
	gas/mips/l_d-reloc.d, gas/mips/ulw-reloc.s, gas/mips/ulw-reloc.d,
	gas/mips/micromips@@ulw-reloc.d, gas/mips/ulh-reloc.s,
	gas/mips/ulh-reloc.d: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d12705 2
a12706 4
	      /* If we expect a base register, check whether there is only
		 a single bracketed expression left.  If so, it must be the
		 base register and the constant must be zero.  */
	      if (args[1] == '(' && *s == '(' && strchr (s + 1, '(') == 0)
d12708 3
a12715 1
		  my_getSmallExpression (&offset_expr, offset_reloc, s);
@


1.556
log
@include/opcode/
	* mips.h: Remove documentation of "[" and "]".  Update documentation
	of "k" and the MDMX formats.

opcodes/
	* mips-opc.c (mips_builtin_opcodes): Use "Q" for the INSN_5400
	MDMX-like instructions.
	* mips-dis.c (print_insn_arg): Use "$f" rather than "$v" when
	printing "Q" operands for INSN_5400 instructions.

gas/
	* config/tc-mips.c (validate_mips_insn): Remove "[" and "]" handling.
	(mips_ip): Likewise.  Do not set is_mdmx for INSN_5400 instructions.
	Check constraints on the VR5400 RZU.OB, SLL.OB and SRL.OB instructions.

gas/testsuite/
	* gas/mips/vr5400-ill.s, gas/mips/vr5400-ill.l: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d3099 7
d5275 9
a5283 2
    for (i = 0; i < 3; i++)
      r[i] = (bfd_reloc_code_real_type) va_arg (*args, int);
d6751 42
d6833 1
a6833 1
  int ab = 0;
a6834 1
  bfd_reloc_code_real_type r;
d6836 1
d6854 1
d7600 1
a7600 3
      if (offset_expr.X_op == O_constant
	  && offset_expr.X_add_number >= -0x8000
	  && offset_expr.X_add_number < 0x8000)
d7602 2
a7603 2
	  macro_build (&offset_expr, ADDRESS_ADDI_INSN,
		       "t,r,j", treg, sreg, BFD_RELOC_LO16);
a8454 2
      ab = 1;
    case M_LBUE_OB:
a8459 2
      ab = 1;
    case M_LHUE_OB:
a8464 2
      ab = 1;
    case M_LBE_OB:
a8469 2
      ab = 1;
    case M_LHE_OB:
a8474 2
      ab = 1;
    case M_LLE_OB:
a8479 2
      ab = 1;
    case M_LWE_OB:
a8484 2
      ab = 1;
    case M_LWLE_OB:
a8489 2
      ab = 1;
    case M_LWRE_OB:
a8494 2
      ab = 1;
    case M_SBE_OB:
a8499 2
      ab = 1;
    case M_SCE_OB:
a8504 2
      ab = 1;
    case M_SHE_OB:
a8509 2
      ab = 1;
    case M_SWE_OB:
a8514 2
      ab = 1;
    case M_SWLE_OB:
a8519 2
      ab = 1;
    case M_SWRE_OB:
a8524 2
      ab = 1;
    case M_ACLR_OB:
a8530 2
      ab = 1;
    case M_ASET_OB:
a8536 1
      ab = 1;
a8540 1
      ab = 1;
a8544 1
      ab = 1;
a8548 1
      ab = 1;
a8552 1
      ab = 1;
a8556 1
      ab = 1;
a8563 1
      ab = 1;
a8569 2
      ab = 1;
    case M_LWC2_OB:
a8576 1
      ab = 1;
a8583 2
      ab = 1;
    case M_LWL_OB:
a8588 2
      ab = 1;
    case M_LWR_OB:
a8593 1
      ab = 1;
a8599 2
      ab = 1;
    case M_LDC2_OB:
a8606 1
      ab = 1;
a8612 1
      ab = 1;
a8618 2
      ab = 1;
    case M_LDL_OB:
a8623 2
      ab = 1;
    case M_LDR_OB:
a8628 2
      ab = 1;
    case M_LL_OB:
a8633 2
      ab = 1;
    case M_LLD_OB:
a8638 2
      ab = 1;
    case M_LWU_OB:
a8643 2
      ab = 1;
    case M_LWP_OB:
a8650 2
      ab = 1;
    case M_LDP_OB:
a8657 2
      ab = 1;
    case M_LWM_OB:
a8663 2
      ab = 1;
    case M_LDM_OB:
a8678 1
      ab = 1;
a8682 1
      ab = 1;
a8686 1
      ab = 1;
a8690 1
      ab = 1;
a8697 1
      ab = 1;
a8703 2
      ab = 1;
    case M_SWC2_OB:
a8710 1
      ab = 1;
a8717 2
      ab = 1;
    case M_SWL_OB:
a8722 2
      ab = 1;
    case M_SWR_OB:
a8727 2
      ab = 1;
    case M_SC_OB:
a8732 2
      ab = 1;
    case M_SCD_OB:
a8737 2
      ab = 1;
    case M_CACHE_OB:
a8742 2
      ab = 1;
    case M_CACHEE_OB:
a8747 2
      ab = 1;
    case M_PREF_OB:
a8752 2
      ab = 1;
    case M_PREFE_OB:
a8757 1
      ab = 1;
a8763 2
      ab = 1;
    case M_SDC2_OB:
a8770 1
      ab = 1;
a8776 1
      ab = 1;
a8783 2
      ab = 1;
    case M_SDL_OB:
a8788 2
      ab = 1;
    case M_SDR_OB:
a8793 2
      ab = 1;
    case M_SWP_OB:
a8799 2
      ab = 1;
    case M_SDP_OB:
a8805 2
      ab = 1;
    case M_SWM_OB:
a8811 2
      ab = 1;
    case M_SDM_OB:
a8818 1
      used_at = 1;
d8820 34
d8874 3
a8876 1
	  int hipart = 0;
d8878 4
a8881 29
	  expr1.X_add_number = offset_expr.X_add_number;
	  normalize_address_expr (&expr1);
	  if ((offbits == 0 || offbits == 16)
	      && !IS_SEXT_16BIT_NUM (expr1.X_add_number))
	    {
	      expr1.X_add_number = ((expr1.X_add_number + 0x8000)
				    & ~(bfd_vma) 0xffff);
	      hipart = 1;
	    }
	  else if (offbits == 12 && !IS_SEXT_12BIT_NUM (expr1.X_add_number))
	    {
	      expr1.X_add_number = ((expr1.X_add_number + 0x800)
				    & ~(bfd_vma) 0xfff);
	      hipart = 1;
	    }
	  else if (offbits == 9 && !IS_SEXT_9BIT_NUM (expr1.X_add_number))
	    {
	      expr1.X_add_number = ((expr1.X_add_number + 0x100)
				    & ~(bfd_vma) 0x1ff);
	      hipart = 1;
	    }
	  if (hipart)
	    {
	      load_register (tempreg, &expr1, HAVE_64BIT_ADDRESSES);
	      if (breg != 0)
		macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			     tempreg, tempreg, breg);
	      breg = tempreg;
	    }
d8884 1
a8884 3
	      if (offset_expr.X_add_number == 0)
		tempreg = breg;
	      else
d8886 1
a8886 1
			     "t,r,j", tempreg, breg, BFD_RELOC_LO16);
d8890 1
a8890 1
	    macro_build (&offset_expr, s, fmt, treg, BFD_RELOC_LO16, breg);
d8892 2
a8893 2
	    macro_build (NULL, s, fmt,
			 treg, (unsigned long) offset_expr.X_add_number, breg);
d8899 5
a8903 18
	     register.  In the case of "A(b)" addresses, we first load
	     absolute address "A" into the register and then add base
	     register "b".  In the case of "o(b)" addresses, we simply
	     need to add 16-bit offset "o" to base register "b", and
	     offset_reloc already contains the relocations associated
	     with "o".  */
	  if (ab)
	    {
	      load_address (tempreg, &offset_expr, &used_at);
	      if (breg != 0)
		macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			     tempreg, tempreg, breg);
	    }
	  else
	    macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
			 tempreg, breg, -1,
			 offset_reloc[0], offset_reloc[1], offset_reloc[2]);
	  expr1.X_add_number = 0;
d8907 1
a8907 2
	    macro_build (NULL, s, fmt,
		         treg, (unsigned long) expr1.X_add_number, tempreg);
d9365 5
a9369 10
	{
	  if (CPU_HAS_LDC1_SDC1 (mips_opts.arch) || mips_opts.micromips)
	    {
	      macro_build (&offset_expr, "ldc1", "T,o(b)", treg,
			   BFD_RELOC_MIPS_LITERAL, mips_gp_register);
	      break;
	    }
	  breg = mips_gp_register;
	  r = BFD_RELOC_MIPS_LITERAL;
	  goto dob;
a9383 6
	  if (CPU_HAS_LDC1_SDC1 (mips_opts.arch) || mips_opts.micromips)
	    {
	      macro_build (&offset_expr, "ldc1", "T,o(b)",
			   treg, BFD_RELOC_LO16, AT);
	      break;
	    }
d9385 6
a9390 31
	  r = BFD_RELOC_LO16;
	  goto dob;
	}

    case M_L_DOB:
      /* Even on a big endian machine $fn comes before $fn+1.  We have
	 to adjust when loading from memory.  */
      r = BFD_RELOC_LO16;
    dob:
      gas_assert (!mips_opts.micromips);
      gas_assert (!CPU_HAS_LDC1_SDC1 (mips_opts.arch));
      macro_build (&offset_expr, "lwc1", "T,o(b)",
		   target_big_endian ? treg + 1 : treg, r, breg);
      /* FIXME: A possible overflow which I don't know how to deal
	 with.  */
      offset_expr.X_add_number += 4;
      macro_build (&offset_expr, "lwc1", "T,o(b)",
		   target_big_endian ? treg : treg + 1, r, breg);
      break;

    case M_S_DOB:
      gas_assert (!mips_opts.micromips);
      gas_assert (!CPU_HAS_LDC1_SDC1 (mips_opts.arch));
      /* Even on a big endian machine $fn comes before $fn+1.  We have
	 to adjust when storing to memory.  */
      macro_build (&offset_expr, "swc1", "T,o(b)",
		   target_big_endian ? treg + 1 : treg, BFD_RELOC_LO16, breg);
      offset_expr.X_add_number += 4;
      macro_build (&offset_expr, "swc1", "T,o(b)",
		   target_big_endian ? treg : treg + 1, BFD_RELOC_LO16, breg);
      break;
a9392 1
      gas_assert (!mips_opts.micromips);
d9458 45
a9518 7
      /* Even on a big endian machine $fn comes before $fn+1.  We have
	 to adjust when loading from memory.  We set coproc if we must
	 load $fn+1 first.  */
      /* Itbl support may require additional care here.  */
      if (!target_big_endian)
	coproc = 0;

d9571 9
a9579 1
	  macro_build_lui (&offset_expr, AT);
a9718 19

    case M_LD_OB:
      s = HAVE_64BIT_GPRS ? "ld" : "lw";
      goto sd_ob;
    case M_SD_OB:
      s = HAVE_64BIT_GPRS ? "sd" : "sw";
    sd_ob:
      macro_build (&offset_expr, s, "t,o(b)", treg,
		   -1, offset_reloc[0], offset_reloc[1], offset_reloc[2],
		   breg);
      if (!HAVE_64BIT_GPRS)
	{
	  offset_expr.X_add_number += 4;
	  macro_build (&offset_expr, s, "t,o(b)", treg + 1,
		       -1, offset_reloc[0], offset_reloc[1], offset_reloc[2],
		       breg);
	}
      break;

a9720 2
      ab = 1;
    case M_SAA_OB:
a9725 2
      ab = 1;
    case M_SAAD_OB:
d10381 1
a10381 3
    case M_ULH_A:
      ab = 1;
    case M_ULH:
d10386 1
a10386 3
    case M_ULHU_A:
      ab = 1;
    case M_ULHU:
d10391 1
a10391 3
    case M_ULW_A:
      ab = 1;
    case M_ULW:
d10397 1
a10397 3
    case M_ULD_A:
      ab = 1;
    case M_ULD:
d10403 1
a10403 3
    case M_USH_A:
      ab = 1;
    case M_USH:
d10409 1
a10409 3
    case M_USW_A:
      ab = 1;
    case M_USW:
d10416 1
a10416 3
    case M_USD_A:
      ab = 1;
    case M_USD:
d10424 1
a10424 3
      if (!ab && offset_expr.X_add_number >= 0x8000 - off)
	as_bad (_("Operand overflow"));

d10427 1
a10427 1
      if (ab)
d10431 13
a10443 17
	  load_address (tempreg, ep, &used_at);
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			 tempreg, tempreg, breg);
	  breg = tempreg;
	  tempreg = treg;
	  ep = &expr1;
	}
      else if (offbits == 12
	       && (offset_expr.X_op != O_constant
		   || !IS_SEXT_12BIT_NUM (offset_expr.X_add_number)
		   || !IS_SEXT_12BIT_NUM (offset_expr.X_add_number + off)))
	{
	  used_at = 1;
	  tempreg = AT;
	  macro_build (ep, ADDRESS_ADDI_INSN, "t,r,j", tempreg, breg,
		       -1, offset_reloc[0], offset_reloc[1], offset_reloc[2]);
d10461 1
a10461 3
      if (offbits != 12)
	macro_build (ep, s, "t,o(b)", tempreg, BFD_RELOC_LO16, breg);
      else
d10464 3
d10472 1
a10472 3
      if (offbits != 12)
	macro_build (ep, s2, "t,o(b)", tempreg, BFD_RELOC_LO16, breg);
      else
d10475 3
d10492 3
a10494 2
      tempreg = ust || ab ? treg : AT;
      macro_build (ep, s, "t,o(b)", tempreg, BFD_RELOC_LO16, breg);
d10500 1
a10500 1
      tempreg = ust == ab ? treg : AT;
d10508 2
a10509 1
      macro_build (ep, s2, "t,o(b)", tempreg, BFD_RELOC_LO16, breg);
d10512 1
a10512 1
      if (ust && ab)
d10518 2
a10519 1
	  macro_build (&expr1, "lbu", "t,o(b)", AT, BFD_RELOC_LO16, AT);
d10522 1
a10522 1
      if (!ust || ab)
d10524 1
a10524 1
	  tempreg = !ab ? AT : treg;
d11329 10
d12705 14
a12718 4
	      my_getExpression (&offset_expr, s);
	      normalize_address_expr (&offset_expr);
	      *imm_reloc = BFD_RELOC_32;
	      s = expr_end;
@


1.555
log
@include/opcode/
	* mips.h: Update documentation of "+s" and "+S".

opcodes/
	* mips-opc.c (mips_builtin_opcodes): Use "+s" for "cins32" and
	"+S" for "cins".
	* mips-dis.c (print_mips_arg): Update "+s" and "+S" comments.
	Combine cases.

gas/
	* config/tc-mips.c (mips_ip): Preserve the real bit number for "+p".
	Require the msb to be <= 31 for "+s".  Check that the size is <= 31
	for both "+s" and "+S".
@
text
@a10974 2
      case '[': break;
      case ']': break;
a11785 7
	    case '[':		/* These must match exactly.  */
	    case ']':
	      gas_assert (!mips_opts.micromips);
	      if (*s++ == *args)
		continue;
	      break;

d12650 1
a12650 1
	      is_mdmx = 1;
d12706 5
d12733 7
a12739 1
                        {
@


1.554
log
@include/opcode/
	* mips.h: Document "+i".

opcodes/
	* mips-opc.c (mips_builtin_opcodes): Use "+i" rather than "a" for
	"jalx".
	* mips16-opc.c (mips16_opcodes): Likewise.
	* micromips-opc.c (micromips_opcodes): Likewise.
	* mips-dis.c (print_insn_args, print_mips16_insn_arg)
	(print_insn_mips16): Handle "+i".
	(print_insn_micromips): Likewise.  Conditionally preserve the
	ISA bit for "a" but not for "+i".

gas/
	* config/tc-mips.c (validate_mips_insn, validate_micromips_insn):
	(mips_ip, mips16_ip): Handle "+i".
@
text
@d12019 1
a12019 2
		  /* Make the pos explicit to simplify +S.  */
		  lastpos = imm_expr.X_add_number + 32;
d12041 1
a12041 1
		  /* cins and exts length-minus-one field.  */
d12045 2
a12046 1
		  if ((unsigned long) imm_expr.X_add_number > 31)
d12058 1
a12058 2
		  /* cins32/exts32 and cins/exts aliasing cint32/exts32
		     length-minus-one field.  */
d12062 1
a12062 1
		  if ((long) imm_expr.X_add_number < 0
@


1.553
log
@include/opcode/
	* mips.h: Remove "mi" documentation.  Update "mh" documentation.
	(OP_MASK_MI, OP_SH_MI, MICROMIPSOP_MASK_MI, MICROMIPSOP_MASK_MI):
	Delete.
	(INSN2_WRITE_GPR_MHI): Rename to...
	(INSN2_WRITE_GPR_MH): ...this.

opcodes/
	* micromips-opc.c (WR_mhi): Rename to..
	(WR_mh): ...this.
	(micromips_opcodes): Update "movep" entry accordingly.  Replace
	"mh,mi" with "mh".
	* mips-dis.c (micromips_to_32_reg_h_map): Rename to...
	(micromips_to_32_reg_h_map1): ...this.
	(micromips_to_32_reg_i_map): Rename to...
	(micromips_to_32_reg_h_map2): ...this.
	(print_micromips_insn): Remove "mi" case.  Print both registers
	in the pair for "mh".

gas/
	* config/tc-mips.c (mips32_to_micromips_reg_h_map): Delete.
	(micromips_to_32_reg_h_map): Rename to...
	(micromips_to_32_reg_h_map1): ...this.
	(micromips_to_32_reg_i_map): Rename to...
	(micromips_to_32_reg_h_map2): ...this.
	(mips_lookup_reg_pair): New function.
	(gpr_write_mask, macro): Adjust after above renaming.
	(validate_micromips_insn): Remove "mi" handling.
	(mips_ip): Likewise.  Parse both registers in a pair for "mh".
@
text
@d10913 1
d11075 1
d12178 3
d13039 1
d14289 1
@


1.552
log
@include/opcode/
	* mips.h: Remove documentation of "+D" and "+T".

opcodes/
	* mips-opc.c (mips_builtin_opcodes): Remove "+D" and "+T" entries.
	* micromips-opc.c (micromips_opcodes): Likewise.
	* mips-dis.c (print_insn_args, print_insn_micromips): Remove "+D"
	and "+T" handling.  Check for a "0" suffix when deciding whether to
	use coprocessor 0 names.  In that case, also check for ",H" selectors.

gas/
	* config/tc-mips.c (validate_mips_insn, validate_micromips_insn)
	(mips_ip): Remove "+D" and "+T" handling.

gas/testsuite/
	* gas/mips/lb.d, gas/mips/sb.d: Use coprocessor register names
	for LWC0 and SWC0.
@
text
@a781 9
/* reg type h: 4, 5, 6.  */
static const int mips32_to_micromips_reg_h_map[] =
{
  X, X, X, X, 4, 5, 6, X,
  X, X, X, X, X, X, X, X,
  X, X, X, X, X, X, X, X,
  X, X, X, X, X, X, X, X
};

d813 1
a813 1
static const unsigned int micromips_to_32_reg_h_map[] =
d817 1
a817 3

/* The microMIPS registers with type i.  */
static const unsigned int micromips_to_32_reg_i_map[] =
d2583 13
d3508 1
a3508 1
      if (pinfo2 & INSN2_WRITE_GPR_MHI)
d3510 2
a3511 2
	  mask |= 1 << micromips_to_32_reg_h_map[EXTRACT_OPERAND (1, MH, *ip)];
	  mask |= 1 << micromips_to_32_reg_i_map[EXTRACT_OPERAND (1, MI, *ip)];
d9848 2
a9849 2
      dreg = micromips_to_32_reg_h_map[EXTRACT_OPERAND (1, MH, *ip)];
      breg = micromips_to_32_reg_i_map[EXTRACT_OPERAND (1, MI, *ip)];
a11114 1
	  case 'i': USE_BITS (MI);	break;
d11291 1
a11291 1
  unsigned int regno;
a13144 1
		case 'i':
d13267 15
a13281 5
			regno = mips32_to_micromips_reg_h_map[regno];
			break;

		      case 'i':
			switch (EXTRACT_OPERAND (1, MI, *ip))
d13283 5
a13287 34
			    case 4:
			      if (regno == 21)
				regno = 3;
			      else if (regno == 22)
				regno = 4;
			      else if (regno == 5)
				regno = 5;
			      else if (regno == 6)
				regno = 6;
			      else if (regno == 7)
				regno = 7;
			      else
				regno = ILLEGAL_REG;
			      break;

			    case 5:
			      if (regno == 6)
				regno = 0;
			      else if (regno == 7)
				regno = 1;
			      else
				regno = ILLEGAL_REG;
			      break;

			    case 6:
			      if (regno == 7)
				regno = 2;
			      else
				regno = ILLEGAL_REG;
			      break;

			    default:
			      regno = ILLEGAL_REG;
			      break;
d13289 4
a13368 4
		      case 'i':
			INSERT_OPERAND (1, MI, *ip, regno);
			break;

@


1.551
log
@include/opcode/
	* mips.h: Fix comment for "1": it is now STYPE rather than SHAMT.
	Use "source" rather than "destination" for microMIPS "G".

gas/
	* config/tc-mips.c (validate_mips_insn): Use STYPE rather than SHAMT.
@
text
@a10891 2
	  case 'D': USE_BITS (OP_MASK_RD,	OP_SH_RD);
		    USE_BITS (OP_MASK_SEL,	OP_SH_SEL);	break;
a10898 2
	  case 'T': USE_BITS (OP_MASK_RT,	OP_SH_RT);
		    USE_BITS (OP_MASK_SEL,	OP_SH_SEL);	break;
a11067 1
	  case 'D': USE_BITS (RS);	USE_BITS (SEL);	break;
a11935 4
		case 'D':
		  /* +D is for disassembly only; never match.  */
		  break;

a11946 5
		case 'T': /* Coprocessor register.  */
		  gas_assert (!mips_opts.micromips);
		  /* +T is for disassembly only; never match.  */
		  break;

@


1.550
log
@	bfd/
	* elfxx-mips.h (_bfd_mips_elf_insn32): New prototype.
	* elfxx-mips.c (mips_elf_link_hash_table): Add insn32 member.
	(STUB_MOVE32_MICROMIPS, STUB_JALR32_MICROMIPS): New macros.
	(MICROMIPS_INSN32_FUNCTION_STUB_NORMAL_SIZE): Likewise.
	(MICROMIPS_INSN32_FUNCTION_STUB_BIG_SIZE): Likewise.
	(micromips_insn32_o32_exec_plt0_entry): New variable.
	(micromips_insn32_o32_exec_plt_entry): Likewise.
	(_bfd_mips_elf_adjust_dynamic_symbol): Handle insn32 mode.
	(mips_elf_estimate_stub_size): Likewise.
	(_bfd_mips_elf_size_dynamic_sections): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	(mips_finish_exec_plt): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips_elf_insn32): New function.
	(_bfd_mips_elf_get_synthetic_symtab): Handle insn32 PLT.

	gas/
	* config/tc-mips.c (mips_set_options): Add insn32 member.
	(mips_opts): Initialize it.
	(NOP_INSN, NOP_INSN_SIZE): Handle insn32 mode.
	(options): Add OPTION_INSN32 and OPTION_NO_INSN32 enum values.
	(md_longopts): Add "minsn32" and "mno-insn32" options.
	(is_size_valid): Handle insn32 mode.
	(md_assemble): Pass instruction string down to macro.
	(brk_fmt): Add second dimension and insn32 mode initializers.
	(mfhl_fmt): Likewise.
	(BRK_FMT, MFHL_FMT): Handle insn32 mode.
	(macro_build) <'c'>: Handle microMIPS 32-bit BREAK encoding.
	(macro_build_jalr, move_register): Handle insn32 mode.
	(macro_build_branch_rs): Likewise.
	(macro): Handle insn32 mode.
	<M_JRADDIUSP>, <M_JRC>, <M_MOVEP>: New cases.
	(mips_ip): Handle insn32 mode.
	(md_parse_option): Handle OPTION_INSN32 and OPTION_NO_INSN32.
	(s_mipsset): Handle "insn32" and "noinsn32" pseudo-ops.
	(mips_handle_align): Handle insn32 mode.
	(md_show_usage): Add -minsn32 and -mno-insn32.

	* doc/as.texinfo (Target MIPS options): Add -minsn32 and
	-mno-insn32 options.
	(-minsn32, -mno-insn32): New options.
	* doc/c-mips.texi (MIPS Opts): Add -minsn32 and -mno-insn32
	options.
	(MIPS assembly options): New node.  Document .set insn32 and
	.set noinsn32.
	(MIPS-Dependent): List the new node.

	gas/testsuite/
	* gas/mips/micromips-insn32.d: New test.
	* gas/mips/micromips-noinsn32.d: Likewise.
	* gas/mips/micromips.l: Rename to...
	* gas/mips/micromips-warn.l: ... this.
	* gas/mips/micromips.d: Update accordingly.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips.l: New list test.
	* gas/mips/micromips.s: Add conditionals.
	* gas/mips/mips.exp: Run the new tests.

	include/opcode/
	* mips.h: Add M_JRADDIUSP, M_JRC and M_MOVEP anonymous enum
	values.

	ld/
	* emultempl/mipself.em (insn32): New variable.
	(mips_create_output_section_statements): Handle insn32 mode.
	(PARSE_AND_LIST_PROLOGUE): New macro.
	(PARSE_AND_LIST_LONGOPTS): Likewise.
	(PARSE_AND_LIST_OPTIONS): Likewise.

	* gen-doc.texi: Set MIPS.
	* ld.texinfo: Likewise.
	(Options specific to MIPS targets): New section.
	(ld and MIPS family): New node.
	(Top, Machine Dependent): List the new node.

	opcodes/
	* micromips-opc.c (micromips_opcodes): Add "jraddiusp", "jrc"
	and "movep" macros.
@
text
@d10978 1
a10978 1
      case '1':	USE_BITS (OP_MASK_SHAMT,	OP_SH_SHAMT);	break;
@


1.549
log
@include/opcode/
	* mips.h: Fix comment typo: "G" is _RS rather than _RD for microMIPS.

gas/
	* config/tc-mips.c (mips_ip): Fix swapped bit numbers in comments.
@
text
@d234 4
d279 2
a280 2
  /* nomove */ 0, /* nobopt */ 0, /* noautoextend */ 0, /* gp32 */ 0,
  /* fp32 */ 0, /* arch */ CPU_UNKNOWN, /* sym32 */ FALSE,
d693 7
a699 2
#define NOP_INSN (mips_opts.mips16 ? &mips16_nop_insn \
		  : (mips_opts.micromips ? &micromips_nop16_insn : &nop_insn))
d702 3
a704 1
#define NOP_INSN_SIZE (HAVE_CODE_COMPRESSION ? 2 : 4)
d1290 1
a1290 1
static void macro (struct mips_cl_insn * ip);
d1432 2
d1540 2
d2654 7
d2991 1
a2991 1
	macro (&insn);
d5234 1
a5234 1
static const char * const brk_fmt[2] = { "c", "mF" };
d5239 1
a5239 1
static const char * const mfhl_fmt[2] = { "d", "mj" };
d5243 1
a5243 1
#define BRK_FMT (brk_fmt[mips_opts.micromips])
d5248 1
a5248 1
#define MFHL_FMT (mfhl_fmt[mips_opts.micromips])
d5407 1
a5407 2
	  gas_assert (!mips_opts.micromips);
	  INSERT_OPERAND (0, CODE, insn, va_arg (args, int));
d5774 2
a5775 1
      jalr = mips_opts.noreorder && !cprestore ? "jalr" : "jalrs";
d5777 1
d6458 1
d6655 1
a6655 1
      br = "bgezals";
d6682 1
a6682 1
      br = "bltzals";
d6754 1
a6754 1
macro (struct mips_cl_insn *ip)
d8176 5
d8192 1
d8207 3
a8209 1
	  s = (mips_opts.micromips && (!mips_opts.noreorder || cprestore)
d8212 1
d8251 5
d9268 18
d9843 11
d11413 2
d15207 8
d16627 4
d18938 1
a18938 1
      if (nop_opcode == NOP_OPCODE_MICROMIPS)
d19664 3
@


1.548
log
@bfd/
	* Makefile.am (BFD32_BACKENDS, BFD32_BACKENDS_CFILES): Move MIPS ELF
	files to...
	(BFD64_BACKENDS, BFD64_BACKENDS_CFILES): ...here.
	* Makefile.in: Regenerate.
	* config.bfd: Enclose all MIPS ELF targets in #ifdef BFD64.
	Set want64 to true for them at the end.
	* targets.c (_bfd_target_vector): Protect MIPS ELF targets with
	#ifdef BFD64.

gas/
	* config/tc-mips.c: Assert that offsetT and valueT are at least
	8 bytes in size.
	(GPR_SMIN, GPR_SMAX): New macros.
	(macro, mips_ip): Remove code for 4-byte valueT and offsetT.

ld/
	* Makefile.am (ALL_EMULATION_SOURCES): Move MIPS ELF emulations to...
	(ALL_64_EMULATION_SOURCES): ...here.
	* Makefile.in: Regenerate.
@
text
@d11389 2
a11390 2
	      /* DSP 3-bit unsigned immediate in bit 13 (for standard MIPS
	         code) or 21 (for microMIPS code).  */
d11408 2
a11409 2
	      /* DSP 4-bit unsigned immediate in bit 12 (for standard MIPS
	         code) or 21 (for microMIPS code).  */
d11427 2
a11428 2
	      /* DSP 8-bit unsigned immediate in bit 13 (for standard MIPS
	         code) or 16 (for microMIPS code).  */
d11446 2
a11447 2
	      /* DSP 5-bit unsigned immediate in bit 16 (for standard MIPS
	         code) or 21 (for microMIPS code).  */
d11464 3
a11466 1
	    case '7': /* Four DSP accumulators in bits 11,12.  */
d11514 2
a11515 2
	      /* DSP 6-bit signed immediate in bit 16 (for standard MIPS
	         code) or 20 (for microMIPS code).  */
@


1.547
log
@gas/
	* config/tc-mips.c: Remove OBJ_ELF, OBJ_MAYBE_ELF and IS_ELF
	conditions.  Remove any code deselected by them.
	(s_mips_frame, s_mips_mask): Handle ECOFF_DEBUGGING case first.
@
text
@d37 4
d531 4
a6752 1
  offsetT maxnum;
d6955 1
a6955 11
      maxnum = 0x7fffffff;
      if (HAVE_64BIT_GPRS && sizeof (maxnum) > 4)
	{
	  maxnum <<= 16;
	  maxnum |= 0xffff;
	  maxnum <<= 16;
	  maxnum |= 0xffff;
	}
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= maxnum
	  && (HAVE_32BIT_GPRS || sizeof (maxnum) > 4))
d6985 1
a6985 12
      maxnum = 0x7fffffff;
      if (HAVE_64BIT_GPRS && sizeof (maxnum) > 4)
	{
	  maxnum <<= 16;
	  maxnum |= 0xffff;
	  maxnum <<= 16;
	  maxnum |= 0xffff;
	}
      maxnum = - maxnum - 1;
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number <= maxnum
	  && (HAVE_32BIT_GPRS || sizeof (maxnum) > 4))
d7098 1
a7098 11
      maxnum = 0x7fffffff;
      if (HAVE_64BIT_GPRS && sizeof (maxnum) > 4)
	{
	  maxnum <<= 16;
	  maxnum |= 0xffff;
	  maxnum <<= 16;
	  maxnum |= 0xffff;
	}
      if (imm_expr.X_op == O_constant
	  && imm_expr.X_add_number >= maxnum
	  && (HAVE_32BIT_GPRS || sizeof (maxnum) > 4))
d12833 1
a12833 1
		    else if (sizeof (imm_expr.X_add_number) > 4)
a12840 19
		    else
		      {
			imm_expr.X_op = O_big;
			imm_expr.X_add_number = 4;
			if (!target_big_endian)
			  {
			    generic_bignum[0] = bfd_getl16 (temp);
			    generic_bignum[1] = bfd_getl16 (temp + 2);
			    generic_bignum[2] = bfd_getl16 (temp + 4);
			    generic_bignum[3] = bfd_getl16 (temp + 6);
			  }
			else
			  {
			    generic_bignum[0] = bfd_getb16 (temp + 6);
			    generic_bignum[1] = bfd_getb16 (temp + 4);
			    generic_bignum[2] = bfd_getb16 (temp + 2);
			    generic_bignum[3] = bfd_getb16 (temp);
			  }
		      }
a12906 12
		  /* If the expression was written as an unsigned number,
		     only treat it as signed if there are no more
		     alternatives.  */
		  if (more
		      && *args == 'j'
		      && sizeof (imm_expr.X_add_number) <= 4
		      && imm_expr.X_op == O_constant
		      && imm_expr.X_add_number < 0
		      && imm_expr.X_unsigned
		      && HAVE_64BIT_GPRS)
		    break;

@


1.546
log
@	* configure.ac (mips*-*-bsd*, mips*-*-ultrix*, mips*-*-osf*)
	(mips*-*-ecoff*, mips*-*-pe*, mips*-*-irix* [v4 and earlier])
	(mips*-*-lnews*, mips*-*-riscos*): Add gas and ld to noconfigdirs.
	* configure: Regenerate.

gas/
	* NEWS: Note removal of ECOFF support.
	* doc/as.texinfo (--emulation): Update for the removal of MIPS ECOFF.
	* Makefile.am (TARG_ENV_HFILES): Remove config/te-lnews.h.
	(MULTI_CFILES): Remove config/e-mipsecoff.c.
	* Makefile.in: Regenerate.
	* configure.in: Remove MIPS ECOFF references.
	(mips-sony-bsd*, mips-*-bsd*, mips-*-lnews*-ecoff, mips-*-*-ecoff):
	Delete cases.
	(mips-*-irix5*-*, mips*-*-linux*-*, mips*-*-freebsd*)
	(mips*-*-kfreebsd*-gnu, mips-*-*-elf): Fold into...
	(mips-*-*): ...this single case.
	(mipsbecoff, mipslecoff, mipsecoff): Remove emulations.  Expect
	MIPS emulations to be e-mipself*.
	* configure: Regenerate.
	* configure.tgt (mips-sony-bsd*, mips-*-ultrix*, mips-*-osf*)
	(mips-*-ecoff*, mips-*-pe*, mips-*-irix*, ips-*-lnews*, mips-*-riscos*)
	(mips-*-sysv*): Remove coff and ecoff cases.
	* as.c (mipsbecoff, mipslecoff, mipsecoff): Remove.
	* ecoff.c: Remove reference to MIPS ECOFF.
	* config/e-mipsecoff.c, config/te-lnews.h: Delete files.
	* config/tc-mips.c (ECOFF_LITTLE_FORMAT): Delete.
	(RDATA_SECTION_NAME, mips_target_form): Remove COFF and ECOFF cases.
	(mips_hi_fixup): Tweak comment.
	(append_insn): Require a howto.
	(mips_after_parse_args): Remove OBJ_MAYBE_ECOFF code.

gas/testsuite/
	* gas/all/gas.exp: Remove reference to mips-ecoff.
	* gas/mips/branch-misc-1.d, gas/mips/branch-misc-2.d,
	gas/mips/branch-misc-2-64.d, gas/mips/branch-misc-2pic.d,
	gas/mips/branch-misc-2pic-64.d, gas/mips/branch-swap.d: Remove
	skips for mips-*-ecoff.

ld/
	* NEWS: Document the removal of MIPS ECOFF targets.
	* ld.texinfo (--gpsize=@@var{value}): Use MIPS ELF rather than
	MIPS ECOFF as an example of a target that supports small data.
	* ldmain.c (g_switch_value): Likewise.
	* configure.tgt (mips*-*-pe, mips*-dec-ultrix*, mips*-dec-osf*)
	(mips*-sgi-irix* [v4 and earlier], mips*el-*-ecoff*, mips*-*-ecoff*)
	(mips*-*-bsd*, mips*-*-lnews*): Remove cases.
	* Makefile.am (ALL_EMULATION_SOURCES): Remove emipsbig.c, emipsbsd.c,
	emipsidt.c, emipsidtl.c, emipslit.c, emipslnews.c and emipspe.c.
	(emipsbig.c, emipsbsd.c, emipsidt.c, emipsidtl.c, emipslit.c)
	(emipslnews.c, emipspe.c): Delete rules.
	* Makefile.in: Regenerate.
	* emulparams/mipsbig.sh, emulparams/mipsbsd.sh, emulparams/mipsidt.sh,
	emulparams/mipsidtl.sh, emulparams/mipslit.sh, emulparams/mipslnews.sh,
	emulparams/mipspe.sh, emultempl/mipsecoff.em: Delete.
	* emultempl/m68kcoff.em: Update comment to say that MIPS ECOFF support
	has now been removed.
	* emultempl/pe.em: Remove TARGET_IS_mipspe checks.
@
text
@a42 1
#ifdef OBJ_MAYBE_ELF
a62 1
#endif
a63 1
#if defined (OBJ_ELF)
a64 1
#endif
a83 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
a84 1
#endif
a1421 1
#ifdef OBJ_ELF
a1433 1
#endif /* OBJ_ELF */
a1533 1
#ifdef OBJ_ELF
a1546 1
#endif /* OBJ_ELF */
a1818 1
#ifdef OBJ_ELF
a1822 1
#endif
d2826 28
a2853 13
#ifdef OBJ_ELF
  if (IS_ELF)
    {
      /* On a native system other than VxWorks, sections must be aligned
	 to 16 byte boundaries.  When configured for an embedded ELF
	 target, we don't bother.  */
      if (strncmp (TARGET_OS, "elf", 3) != 0
	  && strncmp (TARGET_OS, "vxworks", 7) != 0)
	{
	  (void) bfd_set_section_alignment (stdoutput, text_section, 4);
	  (void) bfd_set_section_alignment (stdoutput, data_section, 4);
	  (void) bfd_set_section_alignment (stdoutput, bss_section, 4);
	}
d2855 1
a2855 2
      /* Create a .reginfo section for register masks and a .mdebug
	 section for debugging information.  */
d2857 1
a2857 14
	segT seg;
	subsegT subseg;
	flagword flags;
	segT sec;

	seg = now_seg;
	subseg = now_subseg;

	/* The ABI says this section should be loaded so that the
	   running program can access it.  However, we don't load it
	   if we are configured for an embedded target */
	flags = SEC_READONLY | SEC_DATA;
	if (strncmp (TARGET_OS, "elf", 3) != 0)
	  flags |= SEC_ALLOC | SEC_LOAD;
d2859 2
a2860 3
	if (mips_abi != N64_ABI)
	  {
	    sec = subseg_new (".reginfo", (subsegT) 0);
d2862 23
a2884 2
	    bfd_set_section_flags (stdoutput, sec, flags);
	    bfd_set_section_alignment (stdoutput, sec, HAVE_NEWABI ? 3 : 2);
d2886 3
a2888 23
	    mips_regmask_frag = frag_more (sizeof (Elf32_External_RegInfo));
	  }
	else
	  {
	    /* The 64-bit ABI uses a .MIPS.options section rather than
               .reginfo section.  */
	    sec = subseg_new (".MIPS.options", (subsegT) 0);
	    bfd_set_section_flags (stdoutput, sec, flags);
	    bfd_set_section_alignment (stdoutput, sec, 3);

	    /* Set up the option header.  */
	    {
	      Elf_Internal_Options opthdr;
	      char *f;

	      opthdr.kind = ODK_REGINFO;
	      opthdr.size = (sizeof (Elf_External_Options)
			     + sizeof (Elf64_External_RegInfo));
	      opthdr.section = 0;
	      opthdr.info = 0;
	      f = frag_more (sizeof (Elf_External_Options));
	      bfd_mips_elf_swap_options_out (stdoutput, &opthdr,
					     (Elf_External_Options *) f);
d2890 15
a2904 3
	      mips_regmask_frag = frag_more (sizeof (Elf64_External_RegInfo));
	    }
	  }
d2906 2
a2907 20
	if (ECOFF_DEBUGGING)
	  {
	    sec = subseg_new (".mdebug", (subsegT) 0);
	    (void) bfd_set_section_flags (stdoutput, sec,
					  SEC_HAS_CONTENTS | SEC_READONLY);
	    (void) bfd_set_section_alignment (stdoutput, sec, 2);
	  }
	else if (mips_flag_pdr)
	  {
	    pdr_seg = subseg_new (".pdr", (subsegT) 0);
	    (void) bfd_set_section_flags (stdoutput, pdr_seg,
					  SEC_READONLY | SEC_RELOC
					  | SEC_DEBUGGING);
	    (void) bfd_set_section_alignment (stdoutput, pdr_seg, 2);
	  }

	subseg_set (seg, subseg);
      }
    }
#endif /* OBJ_ELF */
a3191 1
#ifdef OBJ_ELF
a3197 1
#endif
d3215 4
a3218 9
#if defined(OBJ_ELF) || defined(OBJ_MAYBE_ELF)
  if (IS_ELF)
    {
      if (mips_opts.mips16)
	S_SET_OTHER (label, ELF_ST_SET_MIPS16 (S_GET_OTHER (label)));
      else
	S_SET_OTHER (label, ELF_ST_SET_MICROMIPS (S_GET_OTHER (label)));
    }
#endif
d4374 1
a4374 6
#if defined(OBJ_ELF) || defined(OBJ_MAYBE_ELF)
  if (IS_ELF)
    S_SET_OTHER (s, ELF_ST_SET_MICROMIPS (S_GET_OTHER (s)));
#else
  (void) s;
#endif
a4660 1
#ifdef OBJ_ELF
a4673 1
#endif
d12910 5
a12914 6
		    if (IS_ELF)
		      bfd_set_section_flags (stdoutput, new_seg,
					     (SEC_ALLOC
					      | SEC_LOAD
					      | SEC_READONLY
					      | SEC_DATA));
d12916 1
a12916 1
		    if (IS_ELF && strncmp (TARGET_OS, "elf", 3) != 0)
a14765 1
#ifdef OBJ_ELF
a14786 1
#endif
a14939 1
#ifdef OBJ_ELF
a14953 1
#endif /* OBJ_ELF */
a15206 1
#ifdef OBJ_ELF
a15210 5
      if (!IS_ELF)
	{
	  as_bad (_("-call_shared is supported only for ELF format"));
	  return 0;
	}
a15215 5
      if (!IS_ELF)
	{
	  as_bad (_("-call_nonpic is supported only for ELF format"));
	  return 0;
	}
a15220 5
      if (!IS_ELF)
	{
	  as_bad (_("-non_shared is supported only for ELF format"));
	  return 0;
	}
a15230 1
#endif /* OBJ_ELF */
d15240 1
a15240 4
      if (IS_ELF)
	mips_abi = O32_ABI;
      /* We silently ignore -32 for non-ELF targets.  This greatly
	 simplifies the construction of the MIPS GAS test cases.  */
a15242 1
#ifdef OBJ_ELF
a15243 5
      if (!IS_ELF)
	{
	  as_bad (_("-n32 is supported for ELF format only"));
	  return 0;
	}
a15247 5
      if (!IS_ELF)
	{
	  as_bad (_("-64 is supported for ELF format only"));
	  return 0;
	}
a15251 1
#endif /* OBJ_ELF */
a15284 1
#ifdef OBJ_ELF
a15285 5
      if (!IS_ELF)
	{
	  as_bad (_("-mabi is supported for ELF format only"));
	  return 0;
	}
a15306 1
#endif /* OBJ_ELF */
a15315 1
#ifdef OBJ_ELF
a15334 1
#endif /* OBJ_ELF */
a16123 1
#ifdef OBJ_ELF
d16130 1
a16130 3
  if (IS_ELF)
    obj_elf_section_change_hook ();
#endif
d16150 5
a16154 8
      if (IS_ELF)
	{
	  bfd_set_section_flags (stdoutput, seg, (SEC_ALLOC | SEC_LOAD
						  | SEC_READONLY | SEC_RELOC
						  | SEC_DATA));
	  if (strncmp (TARGET_OS, "elf", 3) != 0)
	    record_alignment (seg, 4);
	}
d16160 4
a16163 7
      if (IS_ELF)
	{
	  bfd_set_section_flags (stdoutput, seg,
				 SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);
	  if (strncmp (TARGET_OS, "elf", 3) != 0)
	    record_alignment (seg, 4);
	}
d16169 3
a16171 6
      if (IS_ELF)
	{
	  bfd_set_section_flags (stdoutput, seg, SEC_ALLOC);
	  if (strncmp (TARGET_OS, "elf", 3) != 0)
	    record_alignment (seg, 4);
	}
a16181 1
#ifdef OBJ_ELF
a16189 3
  if (!IS_ELF)
    return;

a16248 1
#endif /* OBJ_ELF */
d17316 8
a17323 11
  if (IS_ELF)
    {
      /* We don't need to align ELF sections to the full alignment.
	 However, Irix 5 may prefer that we align them at least to a 16
	 byte boundary.  We don't bother to align the sections if we
	 are targeted for an embedded system.  */
      if (strncmp (TARGET_OS, "elf", 3) == 0)
        return addr;
      if (align > 4)
        align = 4;
    }
a17429 1
#ifdef OBJ_ELF
d17431 1
a17431 3
	  && (!IS_ELF || (! S_IS_WEAK (sym) && ! S_IS_EXTERNAL (sym)))
#endif
	  );
a17947 1
#ifdef OBJ_ELF
d17990 1
a17990 2
  if (IS_ELF
      && fixp->fx_subsy == NULL
a17996 1
#endif
a18027 8
      if (!IS_ELF)
	{
	  /* A gruesome hack which is a result of the gruesome gas
	     reloc handling.  What's worse, for COFF (as opposed to
	     ECOFF), we might need yet another copy of reloc->address.
	     See bfd_install_relocation.  */
	  reloc->addend += reloc->address;
	}
d18438 1
a18438 4
#if defined(OBJ_ELF) || defined(OBJ_MAYBE_ELF)
	  if (IS_ELF)
	    S_SET_OTHER (l, ELF_ST_SET_MICROMIPS (S_GET_OTHER (l)));
#endif
a18671 2
#ifdef OBJ_ELF

a18681 3
  if (!IS_ELF)
    return;

a18695 2
#endif

a18727 1
#ifdef OBJ_ELF
a18728 1
#endif
a18741 2
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)

a18826 2

#endif /* OBJ_ELF || OBJ_MAYBE_ELF */
a19075 1
#ifdef OBJ_ELF
d19092 1
a19092 1
  if (IS_ELF && !ECOFF_DEBUGGING && mips_flag_pdr)
a19123 1
#endif /* OBJ_ELF */
d19181 3
a19183 2
#ifdef OBJ_ELF
  if (IS_ELF && !ECOFF_DEBUGGING)
a19210 3
  else
#endif /* OBJ_ELF */
    s_ignore (ignore);
d19222 3
a19224 2
#ifdef OBJ_ELF
  if (IS_ELF && !ECOFF_DEBUGGING)
a19257 3
  else
#endif /* OBJ_ELF */
    s_ignore (reg_type);
a19656 1
#ifdef OBJ_ELF
a19681 1
#endif
@


1.545
log
@gas/
	* config/tc-mips.c (ISA_SUPPORTS_SMARTMIPS, ISA_SUPPORTS_DSP_ASE)
	(ISA_SUPPORTS_DSP64_ASE, ISA_SUPPORTS_DSPR2_ASE, ISA_SUPPORTS_EVA_ASE)
	(ISA_SUPPORTS_MT_ASE, ISA_SUPPORTS_MCU_ASE, ISA_SUPPORTS_VIRT_ASE)
	(ISA_SUPPORTS_VIRT64_ASE): Delete.
	(mips_ase): New structure.
	(mips_ases): New table.
	(FP64_ASES): New macro.
	(mips_ase_groups): New array.
	(mips_isa_rev, mips_ase_mask, mips_check_isa_supports_ase)
	(mips_check_isa_supports_ases, mips_set_ase, mips_lookup_ase): New
	functions.
	(is_opcode_valid): Use mips_ases to get the 64-bit ASE flags.
	(md_parse_option): Use mips_ases and mips_set_ase instead of
	separate case statements for each ASE option.
	(mips_after_parse_args): Use FP64_ASES.  Use
	mips_check_isa_supports_ases to check the ASEs against
	other options.
	(s_mipsset): Use mips_ases and mips_set_ase instead of
	separate if statements for each ASE option.  Use
	mips_check_isa_supports_ases, even when a non-ASE option
	is specified.

gas/testsuite/
	* gas/mips/ase-errors-1.s, gas/mips/ase-errors-1.l,
	gas/mips/ase-errors-2.s, gas/mips/ase-errors-2.l,
	gas/mips/ase-errors-3.s, gas/mips/ase-errors-3.l,
	gas/mips/ase-errors-4.s, gas/mips/ase-errors-4.l: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@a108 6
/* Allow override of standard little-endian ECOFF format.  */

#ifndef ECOFF_LITTLE_FORMAT
#define ECOFF_LITTLE_FORMAT "ecoff-littlemips"
#endif

d112 1
a112 7
#define RDATA_SECTION_NAME (OUTPUT_FLAVOR == bfd_target_ecoff_flavour \
			    ? ".rdata" \
			    : OUTPUT_FLAVOR == bfd_target_coff_flavour \
			    ? ".rdata" \
			    : OUTPUT_FLAVOR == bfd_target_elf_flavour \
			    ? ".rodata" \
			    : (abort (), ""))
d709 6
a714 6
/* For ECOFF and ELF, relocations against symbols are done in two
   parts, with a HI relocation and a LO relocation.  Each relocation
   has only 16 bits of space to store an addend.  This means that in
   order for the linker to handle carries correctly, it must be able
   to locate both the HI and the LO relocation.  This means that the
   relocations must appear in order in the relocation table.
a1850 4
    case bfd_target_ecoff_flavour:
      return target_big_endian ? "ecoff-bigmips" : ECOFF_LITTLE_FORMAT;
    case bfd_target_coff_flavour:
      return "pe-mips";
d4841 2
a4842 10

      if (howto == NULL)
	{
	  /* To reproduce this failure try assembling gas/testsuites/
	     gas/mips/mips16-intermix.s with a mips-ecoff targeted
	     assembler.  */
	  as_bad (_("Unsupported MIPS relocation number %d"),
		  final_type[i - 1]);
	  howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_16);
	}
d15608 1
a15608 8
    {
#ifdef OBJ_MAYBE_ECOFF
      if (OUTPUT_FLAVOR == bfd_target_ecoff_flavour)
	mips_flag_mdebug = 1;
      else
#endif /* OBJ_MAYBE_ECOFF */
	mips_flag_mdebug = 0;
    }
@


1.544
log
@gas/
	* config/tc-mips.c (md_shortopts, options, md_longopts)
	(md_longopts_size): Move earlier in file.
@
text
@a332 32
#define ISA_SUPPORTS_SMARTMIPS (mips_opts.isa == ISA_MIPS32		\
				|| mips_opts.isa == ISA_MIPS32R2)

#define ISA_SUPPORTS_DSP_ASE (mips_opts.isa == ISA_MIPS32R2		\
			      || mips_opts.isa == ISA_MIPS64R2		\
			      || mips_opts.micromips)

#define ISA_SUPPORTS_DSP64_ASE (mips_opts.isa == ISA_MIPS64R2)

#define ISA_SUPPORTS_DSPR2_ASE (mips_opts.isa == ISA_MIPS32R2		\
			        || mips_opts.isa == ISA_MIPS64R2	\
				|| mips_opts.micromips)

#define ISA_SUPPORTS_EVA_ASE (mips_opts.isa == ISA_MIPS32R2		\
			      || mips_opts.isa == ISA_MIPS64R2		\
			      || mips_opts.micromips)

#define ISA_SUPPORTS_MT_ASE (mips_opts.isa == ISA_MIPS32R2		\
			     || mips_opts.isa == ISA_MIPS64R2)

#define ISA_SUPPORTS_MCU_ASE (mips_opts.isa == ISA_MIPS32R2		\
			      || mips_opts.isa == ISA_MIPS64R2		\
			      || mips_opts.micromips)

#define ISA_SUPPORTS_VIRT_ASE (mips_opts.isa == ISA_MIPS32R2		\
			       || mips_opts.isa == ISA_MIPS64R2		\
			       || mips_opts.micromips)

#define ISA_SUPPORTS_VIRT64_ASE (mips_opts.isa == ISA_MIPS64R2		\
				 || (mips_opts.micromips		\
				     && ISA_HAS_64BIT_REGS (mips_opts.isa)))

d1574 78
d1891 113
d2608 1
d2610 4
a2613 4
  if ((ase & ASE_DSP) && ISA_SUPPORTS_DSP64_ASE)
    ase |= ASE_DSP64;
  if ((ase & ASE_VIRT) && ISA_SUPPORTS_VIRT64_ASE)
    ase |= ASE_VIRT64;
d15035 10
a15164 57
    case OPTION_MDMX:
      mips_opts.ase |= ASE_MDMX;
      file_ase_explicit |= ASE_MDMX;
      break;

    case OPTION_NO_MDMX:
      mips_opts.ase &= ~ASE_MDMX;
      file_ase_explicit |= ASE_MDMX;
      break;

    case OPTION_DSP:
      mips_opts.ase |= ASE_DSP;
      mips_opts.ase &= ~ASE_DSPR2;
      file_ase_explicit |= ASE_DSP | ASE_DSPR2;
      break;

    case OPTION_DSPR2:
      mips_opts.ase |= ASE_DSP | ASE_DSPR2;
      file_ase_explicit |= ASE_DSP | ASE_DSPR2;
      break;

    case OPTION_NO_DSP:
    case OPTION_NO_DSPR2:
      mips_opts.ase &= ~(ASE_DSP | ASE_DSPR2);
      file_ase_explicit |= ASE_DSP | ASE_DSPR2;
      break;

    case OPTION_EVA:
      mips_opts.ase |= ASE_EVA;
      file_ase_explicit |= ASE_EVA;
      break;

    case OPTION_NO_EVA:
      mips_opts.ase &= ~ASE_EVA;
      file_ase_explicit |= ASE_EVA;
      break;

    case OPTION_MT:
      mips_opts.ase |= ASE_MT;
      file_ase_explicit |= ASE_MT;
      break;

    case OPTION_NO_MT:
      mips_opts.ase &= ~ASE_MT;
      file_ase_explicit |= ASE_MT;
      break;

    case OPTION_MCU:
      mips_opts.ase |= ASE_MCU;
      file_ase_explicit |= ASE_MCU;
      break;

    case OPTION_NO_MCU:
      mips_opts.ase &= ~ASE_MCU;
      file_ase_explicit |= ASE_MCU;
      break;

a15179 10
    case OPTION_VIRT:
      mips_opts.ase |= ASE_VIRT;
      file_ase_explicit |= ASE_VIRT;
      break;

    case OPTION_NO_VIRT:
      mips_opts.ase &= ~ASE_VIRT;
      file_ase_explicit |= ASE_VIRT;
      break;

a15194 20
    case OPTION_MIPS3D:
      mips_opts.ase |= ASE_MIPS3D;
      file_ase_explicit |= ASE_MIPS3D;
      break;

    case OPTION_NO_MIPS3D:
      mips_opts.ase &= ~ASE_MIPS3D;
      file_ase_explicit |= ASE_MIPS3D;
      break;

    case OPTION_SMARTMIPS:
      mips_opts.ase |= ASE_SMARTMIPS;
      file_ase_explicit |= ASE_SMARTMIPS;
      break;

    case OPTION_NO_SMARTMIPS:
      mips_opts.ase &= ~ASE_SMARTMIPS;
      file_ase_explicit |= ASE_SMARTMIPS;
      break;

d15570 1
a15570 1
      else if ((mips_opts.ase & (ASE_MIPS3D | ASE_MDMX))
a15621 34
  if ((mips_opts.ase & ASE_MIPS3D) && file_mips_fp32 == 1)
    as_bad (_("-mfp32 used with -mips3d"));

  if ((mips_opts.ase & ASE_MDMX) && file_mips_fp32 == 1)
    as_bad (_("-mfp32 used with -mdmx"));

  if ((mips_opts.ase & ASE_SMARTMIPS) && !ISA_SUPPORTS_SMARTMIPS)
    as_warn (_("%s ISA does not support SmartMIPS"), 
	     mips_cpu_info_from_isa (mips_opts.isa)->name);

  if ((mips_opts.ase & ASE_DSP) && !ISA_SUPPORTS_DSP_ASE)
    as_warn (_("%s ISA does not support DSP ASE"), 
	     mips_cpu_info_from_isa (mips_opts.isa)->name);

  if ((mips_opts.ase & ASE_DSPR2) && !ISA_SUPPORTS_DSPR2_ASE)
    as_warn (_("%s ISA does not support DSP R2 ASE"),
	     mips_cpu_info_from_isa (mips_opts.isa)->name);

  if ((mips_opts.ase & ASE_EVA) && !ISA_SUPPORTS_EVA_ASE)
    as_warn (_("%s ISA does not support EVA ASE"),
	     mips_cpu_info_from_isa (mips_opts.isa)->name);

  if ((mips_opts.ase & ASE_MT) && !ISA_SUPPORTS_MT_ASE)
    as_warn (_("%s ISA does not support MT ASE"),
	     mips_cpu_info_from_isa (mips_opts.isa)->name);

  if ((mips_opts.ase & ASE_MCU) && !ISA_SUPPORTS_MCU_ASE)
    as_warn (_("%s ISA does not support MCU ASE"),
	     mips_cpu_info_from_isa (mips_opts.isa)->name);

  if ((mips_opts.ase & ASE_VIRT) && !ISA_SUPPORTS_VIRT_ASE)
    as_warn (_("%s ISA does not support Virtualization ASE"),
	     mips_cpu_info_from_isa (mips_opts.isa)->name);

d15629 2
d16535 1
d16641 6
a16646 66
  else if (strcmp (name, "smartmips") == 0)
    {
      if (!ISA_SUPPORTS_SMARTMIPS)
	as_warn (_("%s ISA does not support SmartMIPS ASE"), 
		 mips_cpu_info_from_isa (mips_opts.isa)->name);
      mips_opts.ase |= ASE_SMARTMIPS;
    }
  else if (strcmp (name, "nosmartmips") == 0)
    mips_opts.ase &= ~ASE_SMARTMIPS;
  else if (strcmp (name, "mips3d") == 0)
    mips_opts.ase |= ASE_MIPS3D;
  else if (strcmp (name, "nomips3d") == 0)
    mips_opts.ase &= ~ASE_MIPS3D;
  else if (strcmp (name, "mdmx") == 0)
    mips_opts.ase |= ASE_MDMX;
  else if (strcmp (name, "nomdmx") == 0)
    mips_opts.ase &= ~ASE_MDMX;
  else if (strcmp (name, "dsp") == 0)
    {
      if (!ISA_SUPPORTS_DSP_ASE)
	as_warn (_("%s ISA does not support DSP ASE"), 
		 mips_cpu_info_from_isa (mips_opts.isa)->name);
      mips_opts.ase |= ASE_DSP;
      mips_opts.ase &= ~ASE_DSPR2;
    }
  else if (strcmp (name, "dspr2") == 0)
    {
      if (!ISA_SUPPORTS_DSPR2_ASE)
	as_warn (_("%s ISA does not support DSP R2 ASE"),
		 mips_cpu_info_from_isa (mips_opts.isa)->name);
      mips_opts.ase |= ASE_DSP | ASE_DSPR2;
    }
  else if (strcmp (name, "nodsp") == 0
	   || strcmp (name, "nodspr2") == 0)
    mips_opts.ase &= ~(ASE_DSP | ASE_DSPR2);
  else if (strcmp (name, "eva") == 0)
    {
      if (!ISA_SUPPORTS_EVA_ASE)
	as_warn (_("%s ISA does not support EVA ASE"),
		 mips_cpu_info_from_isa (mips_opts.isa)->name);
      mips_opts.ase |= ASE_EVA;
    }
  else if (strcmp (name, "noeva") == 0)
    mips_opts.ase &= ~ASE_EVA;
  else if (strcmp (name, "mt") == 0)
    {
      if (!ISA_SUPPORTS_MT_ASE)
	as_warn (_("%s ISA does not support MT ASE"), 
		 mips_cpu_info_from_isa (mips_opts.isa)->name);
      mips_opts.ase |= ASE_MT;
    }
  else if (strcmp (name, "nomt") == 0)
    mips_opts.ase &= ~ASE_MT;
  else if (strcmp (name, "mcu") == 0)
    mips_opts.ase |= ASE_MCU;
  else if (strcmp (name, "nomcu") == 0)
    mips_opts.ase &= ~ASE_MCU;
  else if (strcmp (name, "virt") == 0)
    {
      if (!ISA_SUPPORTS_VIRT_ASE)
	as_warn (_("%s ISA does not support Virtualization ASE"), 
		 mips_cpu_info_from_isa (mips_opts.isa)->name);
      mips_opts.ase |= ASE_VIRT;
    }
  else if (strcmp (name, "novirt") == 0)
    mips_opts.ase &= ~ASE_VIRT;
d16774 1
@


1.543
log
@gas/
	* config/tc-mips.c (mips_set_options): Replace separate "ase_*" fields
	with a single "ase" bitmask.
	(mips_opts): Update accordingly.
	(file_ase, file_ase_explicit): New variables.
	(file_ase_mips3d, file_ase_mdmx, file_ase_smartmips, file_ase_dsp)
	(file_ase_dspr2, file_ase_eva, file_ase_mt, file_ase_virt): Delete.
	(ISA_HAS_ROR): Adjust for mips_set_options change.
	(is_opcode_valid): Take the base ase mask directly from mips_opts.
	(mips_ip): Adjust for mips_set_options change.
	(md_parse_option): Likewise.  Update file_ase_explicit.
	(mips_after_parse_args): Adjust for mips_set_options change.
	Use bitmask operations to select the default ASEs.  Set file_ase
	rather than individual per-ASE variables.
	(s_mipsset): Adjust for mips_set_options change.
	(mips_elf_final_processing): Test file_ase rather than
	file_ase_mdmx.  Remove commented-out code.
@
text
@d1390 216
a14854 215
const char *md_shortopts = "O::g::G:";

enum options
  {
    OPTION_MARCH = OPTION_MD_BASE,
    OPTION_MTUNE,
    OPTION_MIPS1,
    OPTION_MIPS2,
    OPTION_MIPS3,
    OPTION_MIPS4,
    OPTION_MIPS5,
    OPTION_MIPS32,
    OPTION_MIPS64,
    OPTION_MIPS32R2,
    OPTION_MIPS64R2,
    OPTION_MIPS16,
    OPTION_NO_MIPS16,
    OPTION_MIPS3D,
    OPTION_NO_MIPS3D,
    OPTION_MDMX,
    OPTION_NO_MDMX,
    OPTION_DSP,
    OPTION_NO_DSP,
    OPTION_MT,
    OPTION_NO_MT,
    OPTION_VIRT,
    OPTION_NO_VIRT,
    OPTION_SMARTMIPS,
    OPTION_NO_SMARTMIPS,
    OPTION_DSPR2,
    OPTION_NO_DSPR2,
    OPTION_EVA,
    OPTION_NO_EVA,
    OPTION_MICROMIPS,
    OPTION_NO_MICROMIPS,
    OPTION_MCU,
    OPTION_NO_MCU,
    OPTION_COMPAT_ARCH_BASE,
    OPTION_M4650,
    OPTION_NO_M4650,
    OPTION_M4010,
    OPTION_NO_M4010,
    OPTION_M4100,
    OPTION_NO_M4100,
    OPTION_M3900,
    OPTION_NO_M3900,
    OPTION_M7000_HILO_FIX,
    OPTION_MNO_7000_HILO_FIX, 
    OPTION_FIX_24K,
    OPTION_NO_FIX_24K,
    OPTION_FIX_LOONGSON2F_JUMP,
    OPTION_NO_FIX_LOONGSON2F_JUMP,
    OPTION_FIX_LOONGSON2F_NOP,
    OPTION_NO_FIX_LOONGSON2F_NOP,
    OPTION_FIX_VR4120,
    OPTION_NO_FIX_VR4120,
    OPTION_FIX_VR4130,
    OPTION_NO_FIX_VR4130,
    OPTION_FIX_CN63XXP1,
    OPTION_NO_FIX_CN63XXP1,
    OPTION_TRAP,
    OPTION_BREAK,
    OPTION_EB,
    OPTION_EL,
    OPTION_FP32,
    OPTION_GP32,
    OPTION_CONSTRUCT_FLOATS,
    OPTION_NO_CONSTRUCT_FLOATS,
    OPTION_FP64,
    OPTION_GP64,
    OPTION_RELAX_BRANCH,
    OPTION_NO_RELAX_BRANCH,
    OPTION_MSHARED,
    OPTION_MNO_SHARED,
    OPTION_MSYM32,
    OPTION_MNO_SYM32,
    OPTION_SOFT_FLOAT,
    OPTION_HARD_FLOAT,
    OPTION_SINGLE_FLOAT,
    OPTION_DOUBLE_FLOAT,
    OPTION_32,
#ifdef OBJ_ELF
    OPTION_CALL_SHARED,
    OPTION_CALL_NONPIC,
    OPTION_NON_SHARED,
    OPTION_XGOT,
    OPTION_MABI,
    OPTION_N32,
    OPTION_64,
    OPTION_MDEBUG,
    OPTION_NO_MDEBUG,
    OPTION_PDR,
    OPTION_NO_PDR,
    OPTION_MVXWORKS_PIC,
#endif /* OBJ_ELF */
    OPTION_END_OF_ENUM    
  };
  
struct option md_longopts[] =
{
  /* Options which specify architecture.  */
  {"march", required_argument, NULL, OPTION_MARCH},
  {"mtune", required_argument, NULL, OPTION_MTUNE},
  {"mips0", no_argument, NULL, OPTION_MIPS1},
  {"mips1", no_argument, NULL, OPTION_MIPS1},
  {"mips2", no_argument, NULL, OPTION_MIPS2},
  {"mips3", no_argument, NULL, OPTION_MIPS3},
  {"mips4", no_argument, NULL, OPTION_MIPS4},
  {"mips5", no_argument, NULL, OPTION_MIPS5},
  {"mips32", no_argument, NULL, OPTION_MIPS32},
  {"mips64", no_argument, NULL, OPTION_MIPS64},
  {"mips32r2", no_argument, NULL, OPTION_MIPS32R2},
  {"mips64r2", no_argument, NULL, OPTION_MIPS64R2},

  /* Options which specify Application Specific Extensions (ASEs).  */
  {"mips16", no_argument, NULL, OPTION_MIPS16},
  {"no-mips16", no_argument, NULL, OPTION_NO_MIPS16},
  {"mips3d", no_argument, NULL, OPTION_MIPS3D},
  {"no-mips3d", no_argument, NULL, OPTION_NO_MIPS3D},
  {"mdmx", no_argument, NULL, OPTION_MDMX},
  {"no-mdmx", no_argument, NULL, OPTION_NO_MDMX},
  {"mdsp", no_argument, NULL, OPTION_DSP},
  {"mno-dsp", no_argument, NULL, OPTION_NO_DSP},
  {"mmt", no_argument, NULL, OPTION_MT},
  {"mno-mt", no_argument, NULL, OPTION_NO_MT},
  {"msmartmips", no_argument, NULL, OPTION_SMARTMIPS},
  {"mno-smartmips", no_argument, NULL, OPTION_NO_SMARTMIPS},
  {"mdspr2", no_argument, NULL, OPTION_DSPR2},
  {"mno-dspr2", no_argument, NULL, OPTION_NO_DSPR2},
  {"meva", no_argument, NULL, OPTION_EVA},
  {"mno-eva", no_argument, NULL, OPTION_NO_EVA},
  {"mmicromips", no_argument, NULL, OPTION_MICROMIPS},
  {"mno-micromips", no_argument, NULL, OPTION_NO_MICROMIPS},
  {"mmcu", no_argument, NULL, OPTION_MCU},
  {"mno-mcu", no_argument, NULL, OPTION_NO_MCU},
  {"mvirt", no_argument, NULL, OPTION_VIRT},
  {"mno-virt", no_argument, NULL, OPTION_NO_VIRT},

  /* Old-style architecture options.  Don't add more of these.  */
  {"m4650", no_argument, NULL, OPTION_M4650},
  {"no-m4650", no_argument, NULL, OPTION_NO_M4650},
  {"m4010", no_argument, NULL, OPTION_M4010},
  {"no-m4010", no_argument, NULL, OPTION_NO_M4010},
  {"m4100", no_argument, NULL, OPTION_M4100},
  {"no-m4100", no_argument, NULL, OPTION_NO_M4100},
  {"m3900", no_argument, NULL, OPTION_M3900},
  {"no-m3900", no_argument, NULL, OPTION_NO_M3900},

  /* Options which enable bug fixes.  */
  {"mfix7000", no_argument, NULL, OPTION_M7000_HILO_FIX},
  {"no-fix-7000", no_argument, NULL, OPTION_MNO_7000_HILO_FIX},
  {"mno-fix7000", no_argument, NULL, OPTION_MNO_7000_HILO_FIX},
  {"mfix-loongson2f-jump", no_argument, NULL, OPTION_FIX_LOONGSON2F_JUMP},
  {"mno-fix-loongson2f-jump", no_argument, NULL, OPTION_NO_FIX_LOONGSON2F_JUMP},
  {"mfix-loongson2f-nop", no_argument, NULL, OPTION_FIX_LOONGSON2F_NOP},
  {"mno-fix-loongson2f-nop", no_argument, NULL, OPTION_NO_FIX_LOONGSON2F_NOP},
  {"mfix-vr4120",    no_argument, NULL, OPTION_FIX_VR4120},
  {"mno-fix-vr4120", no_argument, NULL, OPTION_NO_FIX_VR4120},
  {"mfix-vr4130",    no_argument, NULL, OPTION_FIX_VR4130},
  {"mno-fix-vr4130", no_argument, NULL, OPTION_NO_FIX_VR4130},
  {"mfix-24k",    no_argument, NULL, OPTION_FIX_24K},
  {"mno-fix-24k", no_argument, NULL, OPTION_NO_FIX_24K},
  {"mfix-cn63xxp1", no_argument, NULL, OPTION_FIX_CN63XXP1},
  {"mno-fix-cn63xxp1", no_argument, NULL, OPTION_NO_FIX_CN63XXP1},

  /* Miscellaneous options.  */
  {"trap", no_argument, NULL, OPTION_TRAP},
  {"no-break", no_argument, NULL, OPTION_TRAP},
  {"break", no_argument, NULL, OPTION_BREAK},
  {"no-trap", no_argument, NULL, OPTION_BREAK},
  {"EB", no_argument, NULL, OPTION_EB},
  {"EL", no_argument, NULL, OPTION_EL},
  {"mfp32", no_argument, NULL, OPTION_FP32},
  {"mgp32", no_argument, NULL, OPTION_GP32},
  {"construct-floats", no_argument, NULL, OPTION_CONSTRUCT_FLOATS},
  {"no-construct-floats", no_argument, NULL, OPTION_NO_CONSTRUCT_FLOATS},
  {"mfp64", no_argument, NULL, OPTION_FP64},
  {"mgp64", no_argument, NULL, OPTION_GP64},
  {"relax-branch", no_argument, NULL, OPTION_RELAX_BRANCH},
  {"no-relax-branch", no_argument, NULL, OPTION_NO_RELAX_BRANCH},
  {"mshared", no_argument, NULL, OPTION_MSHARED},
  {"mno-shared", no_argument, NULL, OPTION_MNO_SHARED},
  {"msym32", no_argument, NULL, OPTION_MSYM32},
  {"mno-sym32", no_argument, NULL, OPTION_MNO_SYM32},
  {"msoft-float", no_argument, NULL, OPTION_SOFT_FLOAT},
  {"mhard-float", no_argument, NULL, OPTION_HARD_FLOAT},
  {"msingle-float", no_argument, NULL, OPTION_SINGLE_FLOAT},
  {"mdouble-float", no_argument, NULL, OPTION_DOUBLE_FLOAT},

  /* Strictly speaking this next option is ELF specific,
     but we allow it for other ports as well in order to
     make testing easier.  */
  {"32",          no_argument, NULL, OPTION_32},
  
  /* ELF-specific options.  */
#ifdef OBJ_ELF
  {"KPIC",        no_argument, NULL, OPTION_CALL_SHARED},
  {"call_shared", no_argument, NULL, OPTION_CALL_SHARED},
  {"call_nonpic", no_argument, NULL, OPTION_CALL_NONPIC},
  {"non_shared",  no_argument, NULL, OPTION_NON_SHARED},
  {"xgot",        no_argument, NULL, OPTION_XGOT},
  {"mabi", required_argument, NULL, OPTION_MABI},
  {"n32",         no_argument, NULL, OPTION_N32},
  {"64",          no_argument, NULL, OPTION_64},
  {"mdebug", no_argument, NULL, OPTION_MDEBUG},
  {"no-mdebug", no_argument, NULL, OPTION_NO_MDEBUG},
  {"mpdr", no_argument, NULL, OPTION_PDR},
  {"mno-pdr", no_argument, NULL, OPTION_NO_PDR},
  {"mvxworks-pic", no_argument, NULL, OPTION_MVXWORKS_PIC},
#endif /* OBJ_ELF */

  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

@


1.542
log
@gas/
	* config/tc-mips.c (mips_cpu_info): Add an "ase" field.
	(MIPS_CPU_ASE_SMARTMIPS, MIPS_CPU_ASE_DSP, MIPS_CPU_ASE_MT)
	(MIPS_CPU_ASE_MIPS3D, MIPS_CPU_ASE_MDMX, MIPS_CPU_ASE_DSPR2)
	(MIPS_CPU_ASE_MCU, MIPS_CPU_ASE_VIRT, MIPS_CPU_ASE_EVA): Delete.
	(mips_after_parse_args): Use the new "ase" field to choose
	the default ASEs.
	(mips_cpu_info_table): Move ASEs from the "flags" field to the
	"ase" field.
@
text
@d211 4
a214 12
  /* Enabled Application Specific Extensions (ASEs).  These are set to -1
     if they have not been initialized.  Changed by `.set <asename>', by
     command line options, and based on the default architecture.  */
  int ase_mips3d;
  int ase_mdmx;
  int ase_smartmips;
  int ase_dsp;
  int ase_dspr2;
  int ase_eva;
  int ase_mt;
  int ase_mcu;
  int ase_virt;
d287 1
a287 4
  /* isa */ ISA_UNKNOWN, /* ase_mips3d */ -1, /* ase_mdmx */ -1,
  /* ase_smartmips */ 0, /* ase_dsp */ -1, /* ase_dspr2 */ -1,
  /* ase_eva */ -1, /* ase_mt */ -1, /* ase_mcu */ -1,
  /* ase_virt */ -1, /* mips16 */ -1, /* micromips */ -1,
d294 7
a332 12
/* True if -mips3d was passed or implied by arguments passed on the
   command line (e.g., by -march).  */
static int file_ase_mips3d;

/* True if -mdmx was passed or implied by arguments passed on the
   command line (e.g., by -march).  */
static int file_ase_mdmx;

/* True if -msmartmips was passed or implied by arguments passed on the
   command line (e.g., by -march).  */
static int file_ase_smartmips;

a335 4
/* True if -mdsp was passed or implied by arguments passed on the
   command line (e.g., by -march).  */
static int file_ase_dsp;

a341 4
/* True if -mdspr2 was passed or implied by arguments passed on the
   command line (e.g., by -march).  */
static int file_ase_dspr2;

a345 4
/* True if -meva was passed or implied by arguments passed on the
   command line (e.g., by -march).  */
static int file_ase_eva;

a349 4
/* True if -mmt was passed or implied by arguments passed on the
   command line (e.g., by -march).  */
static int file_ase_mt;

a356 4
/* True if -mvirt was passed or implied by arguments passed on the
   command line (e.g., by -march). */
static int file_ase_virt;

d416 1
a416 1
   || mips_opts.ase_smartmips		\
d2231 1
a2231 1
  int ase = 0;
d2234 1
a2234 5
  if (mips_opts.ase_mdmx)
    ase |= ASE_MDMX;
  if (mips_opts.ase_dsp)
    ase |= ASE_DSP;
  if (mips_opts.ase_dsp && ISA_SUPPORTS_DSP64_ASE)
d2236 1
a2236 15
  if (mips_opts.ase_dspr2)
    ase |= ASE_DSPR2;
  if (mips_opts.ase_eva)
    ase |= ASE_EVA;
  if (mips_opts.ase_mt)
    ase |= ASE_MT;
  if (mips_opts.ase_mips3d)
    ase |= ASE_MIPS3D;
  if (mips_opts.ase_smartmips)
    ase |= ASE_SMARTMIPS;
  if (mips_opts.ase_mcu)
    ase |= ASE_MCU;
  if (mips_opts.ase_virt)
    ase |= ASE_VIRT;
  if (mips_opts.ase_virt && ISA_SUPPORTS_VIRT64_ASE)
d12310 1
a12310 1
		  || (mips_opts.ase_mdmx
d14995 2
a14996 1
      mips_opts.ase_mdmx = 1;
d15000 2
a15001 1
      mips_opts.ase_mdmx = 0;
d15005 3
a15007 7
      mips_opts.ase_dsp = 1;
      mips_opts.ase_dspr2 = 0;
      break;

    case OPTION_NO_DSP:
      mips_opts.ase_dsp = 0;
      mips_opts.ase_dspr2 = 0;
d15011 2
a15012 2
      mips_opts.ase_dspr2 = 1;
      mips_opts.ase_dsp = 1;
d15015 1
d15017 2
a15018 2
      mips_opts.ase_dspr2 = 0;
      mips_opts.ase_dsp = 0;
d15022 2
a15023 1
      mips_opts.ase_eva = 1;
d15027 2
a15028 1
      mips_opts.ase_eva = 0;
d15032 2
a15033 1
      mips_opts.ase_mt = 1;
d15037 2
a15038 1
      mips_opts.ase_mt = 0;
d15042 2
a15043 1
      mips_opts.ase_mcu = 1;
d15047 2
a15048 1
      mips_opts.ase_mcu = 0;
d15067 2
a15068 1
      mips_opts.ase_virt = 1;
d15072 2
a15073 1
      mips_opts.ase_virt = 0;
d15092 2
a15093 1
      mips_opts.ase_mips3d = 1;
d15097 2
a15098 1
      mips_opts.ase_mips3d = 0;
d15102 2
a15103 1
      mips_opts.ase_smartmips = 1;
d15107 2
a15108 1
      mips_opts.ase_smartmips = 0;
d15486 1
a15486 1
      else if ((mips_opts.ase_mips3d > 0 || mips_opts.ase_mdmx > 0)
d15528 11
a15538 4
  if (mips_opts.ase_mips3d == -1)
    mips_opts.ase_mips3d = ((arch_info->ase & ASE_MIPS3D)
			    && file_mips_fp32 == 0) ? 1 : 0;
  if (mips_opts.ase_mips3d && file_mips_fp32 == 1)
d15541 1
a15541 4
  if (mips_opts.ase_mdmx == -1)
    mips_opts.ase_mdmx = ((arch_info->ase & ASE_MDMX)
			  && file_mips_fp32 == 0) ? 1 : 0;
  if (mips_opts.ase_mdmx && file_mips_fp32 == 1)
d15544 1
a15544 3
  if (mips_opts.ase_smartmips == -1)
    mips_opts.ase_smartmips = (arch_info->ase & ASE_SMARTMIPS) ? 1 : 0;
  if (mips_opts.ase_smartmips && !ISA_SUPPORTS_SMARTMIPS)
d15548 1
a15548 3
  if (mips_opts.ase_dsp == -1)
    mips_opts.ase_dsp = (arch_info->ase & ASE_DSP) ? 1 : 0;
  if (mips_opts.ase_dsp && !ISA_SUPPORTS_DSP_ASE)
d15552 1
a15552 6
  if (mips_opts.ase_dspr2 == -1)
    {
      mips_opts.ase_dspr2 = (arch_info->ase & ASE_DSPR2) ? 1 : 0;
      mips_opts.ase_dsp = (arch_info->ase & ASE_DSP) ? 1 : 0;
    }
  if (mips_opts.ase_dspr2 && !ISA_SUPPORTS_DSPR2_ASE)
d15556 1
a15556 3
  if (mips_opts.ase_eva == -1)
     mips_opts.ase_eva = (arch_info->ase & ASE_EVA) ? 1 : 0;
  if (mips_opts.ase_eva && !ISA_SUPPORTS_EVA_ASE)
d15560 1
a15560 3
  if (mips_opts.ase_mt == -1)
    mips_opts.ase_mt = (arch_info->ase & ASE_MT) ? 1 : 0;
  if (mips_opts.ase_mt && !ISA_SUPPORTS_MT_ASE)
d15564 5
a15568 9
  if (mips_opts.ase_mcu == -1)
    mips_opts.ase_mcu = (arch_info->ase & ASE_MCU) ? 1 : 0;
  if (mips_opts.ase_mcu && !ISA_SUPPORTS_MCU_ASE)
      as_warn (_("%s ISA does not support MCU ASE"),
	       mips_cpu_info_from_isa (mips_opts.isa)->name);

  if (mips_opts.ase_virt == -1)
    mips_opts.ase_virt = (arch_info->ase & ASE_VIRT) ? 1 : 0;
  if (mips_opts.ase_virt && !ISA_SUPPORTS_VIRT_ASE)
d15573 1
a15573 8
  file_ase_mips3d = mips_opts.ase_mips3d;
  file_ase_mdmx = mips_opts.ase_mdmx;
  file_ase_smartmips = mips_opts.ase_smartmips;
  file_ase_dsp = mips_opts.ase_dsp;
  file_ase_dspr2 = mips_opts.ase_dspr2;
  file_ase_eva = mips_opts.ase_eva;
  file_ase_mt = mips_opts.ase_mt;
  file_ase_virt = mips_opts.ase_virt;
d16593 1
a16593 1
      mips_opts.ase_smartmips = 1;
d16596 1
a16596 1
    mips_opts.ase_smartmips = 0;
d16598 1
a16598 1
    mips_opts.ase_mips3d = 1;
d16600 1
a16600 1
    mips_opts.ase_mips3d = 0;
d16602 1
a16602 1
    mips_opts.ase_mdmx = 1;
d16604 1
a16604 1
    mips_opts.ase_mdmx = 0;
d16610 2
a16611 7
      mips_opts.ase_dsp = 1;
      mips_opts.ase_dspr2 = 0;
    }
  else if (strcmp (name, "nodsp") == 0)
    {
      mips_opts.ase_dsp = 0;
      mips_opts.ase_dspr2 = 0;
d16618 1
a16618 7
      mips_opts.ase_dspr2 = 1;
      mips_opts.ase_dsp = 1;
    }
  else if (strcmp (name, "nodspr2") == 0)
    {
      mips_opts.ase_dspr2 = 0;
      mips_opts.ase_dsp = 0;
d16620 3
d16628 1
a16628 1
      mips_opts.ase_eva = 1;
d16631 1
a16631 1
    mips_opts.ase_eva = 0;
d16637 1
a16637 1
      mips_opts.ase_mt = 1;
d16640 1
a16640 1
    mips_opts.ase_mt = 0;
d16642 1
a16642 1
    mips_opts.ase_mcu = 1;
d16644 1
a16644 1
    mips_opts.ase_mcu = 0;
d16650 1
a16650 1
      mips_opts.ase_virt = 1;
d16653 1
a16653 1
    mips_opts.ase_virt = 0;
d18960 1
a18960 5
#if 0 /* XXX FIXME */
  if (file_ase_mips3d)
    elf_elfheader (stdoutput)->e_flags |= ???;
#endif
  if (file_ase_mdmx)
@


1.541
log
@2013-06-17  Catherine Moore  <clm@@codesourcery.com>
	    Maciej W. Rozycki  <macro@@codesourcery.com>
	    Chao-Ying Fu  <fu@@mips.com>

	gas/testsuite/
	* gas/mips/mips.exp: Run new tests.
	* gas/mips/eva.d: New.
	* gas/mips/eva.s: New.
	* gas/mips/micromips@@eva.d: New.

	gas/
	* config/tc-mips.c (mips_set_options): Add ase_eva.
	(mips_set_options mips_opts): Add ase_eva.
	(file_ase_eva): Declare.
	(ISA_SUPPORTS_EVA_ASE): Define.
	(IS_SEXT_9BIT_NUM): Define.
	(MIPS_CPU_ASE_EVA): Define.
	(is_opcode_valid): Add support for ase_eva.
	(macro_build): Likewise.
	(macro): Likewise.
	(validate_mips_insn): Likewise.
	(validate_micromips_insn): Likewise.
	(mips_ip): Likewise.
	(options): Add OPTION_EVA and OPTION_NO_EVA.
	(md_longopts): Add -meva and -mno-eva.
	(md_parse_option): Process new options.
	(mips_after_parse_args): Check for valid EVA combinations.
	(s_mipsset): Likewise.

	include/
	* opcode/mips.h (OP_SH_EVAOFFSET): Define.
	(OP_MASK_EVAOFFSET): Define.
	(INSN_ASE_MASK): Delete.
	(ASE_EVA): Define.
	(M_CACHEE_AB, M_CACHEE_OB): New.
	(M_LBE_OB, M_LBE_AB): New.
	(M_LBUE_OB, M_LBUE_AB): New.
	(M_LHE_OB, M_LHE_AB): New.
	(M_LHUE_OB, M_LHUE_AB): New.
	(M_LLE_AB, M_LLE_OB): New.
	(M_LWE_OB, M_LWE_AB): New.
	(M_LWLE_AB, M_LWLE_OB): New.
	(M_LWRE_AB, M_LWRE_OB): New.
	(M_PREFE_AB, M_PREFE_OB): New.
	(M_SCE_AB, M_SCE_OB): New.
	(M_SBE_OB, M_SBE_AB): New.
	(M_SHE_OB, M_SHE_AB): New.
	(M_SWE_OB, M_SWE_AB): New.
	(M_SWLE_AB, M_SWLE_OB): New.
	(M_SWRE_AB, M_SWRE_OB): New.
	(MICROMIPSOP_SH_EVAOFFSET): Define.
	(MICROMIPSOP_MASK_EVAOFFSET): Define.

	opcodes/
	* micromips-opc.c (EVA): Define.
	(TLBINV): Define.
	(micromips_opcodes): Add EVA opcodes.
	* mips-dis.c (mips_arch_choices): Update for ASE_EVA.
	(print_insn_args): Handle EVA offsets.
	(print_insn_micromips): Likewise.
	* mips-opc.c (EVA): Define.
	(TLBINV): Define.
	(mips_builtin_opcodes): Add EVA opcodes.
@
text
@d1414 2
a1415 1
  int flags;                  /* ASEs available, or ISA flag.  */
a1420 9
#define MIPS_CPU_ASE_SMARTMIPS	0x0002	/* CPU implements SmartMIPS ASE */
#define MIPS_CPU_ASE_DSP	0x0004	/* CPU implements DSP ASE */
#define MIPS_CPU_ASE_MT		0x0008	/* CPU implements MT ASE */
#define MIPS_CPU_ASE_MIPS3D	0x0010	/* CPU implements MIPS-3D ASE */
#define MIPS_CPU_ASE_MDMX	0x0020	/* CPU implements MDMX ASE */
#define MIPS_CPU_ASE_DSPR2	0x0040	/* CPU implements DSP R2 ASE */
#define MIPS_CPU_ASE_MCU	0x0080	/* CPU implements MCU ASE */
#define MIPS_CPU_ASE_VIRT	0x0100  /* CPU implements Virtualization ASE */
#define MIPS_CPU_ASE_EVA	0x0200  /* CPU implements EVA ASE */
d15572 1
a15572 1
    mips_opts.ase_mips3d = ((arch_info->flags & MIPS_CPU_ASE_MIPS3D)
d15578 1
a15578 1
    mips_opts.ase_mdmx = ((arch_info->flags & MIPS_CPU_ASE_MDMX)
d15584 1
a15584 1
    mips_opts.ase_smartmips = (arch_info->flags & MIPS_CPU_ASE_SMARTMIPS) ? 1 : 0;
d15590 1
a15590 1
    mips_opts.ase_dsp = (arch_info->flags & MIPS_CPU_ASE_DSP) ? 1 : 0;
d15597 2
a15598 2
      mips_opts.ase_dspr2 = (arch_info->flags & MIPS_CPU_ASE_DSPR2) ? 1 : 0;
      mips_opts.ase_dsp = (arch_info->flags & MIPS_CPU_ASE_DSP) ? 1 : 0;
d15605 1
a15605 1
    mips_opts.ase_eva = (arch_info->flags & MIPS_CPU_ASE_EVA) ? 1 : 0;
d15611 1
a15611 1
    mips_opts.ase_mt = (arch_info->flags & MIPS_CPU_ASE_MT) ? 1 : 0;
d15617 1
a15617 1
    mips_opts.ase_mcu = (arch_info->flags & MIPS_CPU_ASE_MCU) ? 1 : 0;
d15623 1
a15623 1
    mips_opts.ase_virt = (arch_info->flags & MIPS_CPU_ASE_VIRT) ? 1 : 0;
d19513 9
a19521 9
  { "mips1",          MIPS_CPU_IS_ISA,		ISA_MIPS1,      CPU_R3000 },
  { "mips2",          MIPS_CPU_IS_ISA,		ISA_MIPS2,      CPU_R6000 },
  { "mips3",          MIPS_CPU_IS_ISA,		ISA_MIPS3,      CPU_R4000 },
  { "mips4",          MIPS_CPU_IS_ISA,		ISA_MIPS4,      CPU_R8000 },
  { "mips5",          MIPS_CPU_IS_ISA,		ISA_MIPS5,      CPU_MIPS5 },
  { "mips32",         MIPS_CPU_IS_ISA,		ISA_MIPS32,     CPU_MIPS32 },
  { "mips32r2",       MIPS_CPU_IS_ISA,		ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "mips64",         MIPS_CPU_IS_ISA,		ISA_MIPS64,     CPU_MIPS64 },
  { "mips64r2",       MIPS_CPU_IS_ISA,		ISA_MIPS64R2,   CPU_MIPS64R2 },
d19524 3
a19526 3
  { "r3000",          0,			ISA_MIPS1,      CPU_R3000 },
  { "r2000",          0,			ISA_MIPS1,      CPU_R3000 },
  { "r3900",          0,			ISA_MIPS1,      CPU_R3900 },
d19529 1
a19529 1
  { "r6000",          0,			ISA_MIPS2,      CPU_R6000 },
d19532 13
a19544 13
  { "r4000",          0,			ISA_MIPS3,      CPU_R4000 },
  { "r4010",          0,			ISA_MIPS2,      CPU_R4010 },
  { "vr4100",         0,			ISA_MIPS3,      CPU_VR4100 },
  { "vr4111",         0,			ISA_MIPS3,      CPU_R4111 },
  { "vr4120",         0,			ISA_MIPS3,      CPU_VR4120 },
  { "vr4130",         0,			ISA_MIPS3,      CPU_VR4120 },
  { "vr4181",         0,			ISA_MIPS3,      CPU_R4111 },
  { "vr4300",         0,			ISA_MIPS3,      CPU_R4300 },
  { "r4400",          0,			ISA_MIPS3,      CPU_R4400 },
  { "r4600",          0,			ISA_MIPS3,      CPU_R4600 },
  { "orion",          0,			ISA_MIPS3,      CPU_R4600 },
  { "r4650",          0,			ISA_MIPS3,      CPU_R4650 },
  { "r5900",          0,			ISA_MIPS3,      CPU_R5900 },
d19546 2
a19547 2
  { "loongson2e",     0,			ISA_MIPS3,   CPU_LOONGSON_2E },
  { "loongson2f",     0,			ISA_MIPS3,   CPU_LOONGSON_2F },
d19550 15
a19564 15
  { "r8000",          0,			ISA_MIPS4,      CPU_R8000 },
  { "r10000",         0,			ISA_MIPS4,      CPU_R10000 },
  { "r12000",         0,			ISA_MIPS4,      CPU_R12000 },
  { "r14000",         0,			ISA_MIPS4,      CPU_R14000 },
  { "r16000",         0,			ISA_MIPS4,      CPU_R16000 },
  { "vr5000",         0,			ISA_MIPS4,      CPU_R5000 },
  { "vr5400",         0,			ISA_MIPS4,      CPU_VR5400 },
  { "vr5500",         0,			ISA_MIPS4,      CPU_VR5500 },
  { "rm5200",         0,			ISA_MIPS4,      CPU_R5000 },
  { "rm5230",         0,			ISA_MIPS4,      CPU_R5000 },
  { "rm5231",         0,			ISA_MIPS4,      CPU_R5000 },
  { "rm5261",         0,			ISA_MIPS4,      CPU_R5000 },
  { "rm5721",         0,			ISA_MIPS4,      CPU_R5000 },
  { "rm7000",         0,			ISA_MIPS4,      CPU_RM7000 },
  { "rm9000",         0,			ISA_MIPS4,      CPU_RM9000 },
d19567 4
a19570 4
  { "4kc",            0,			ISA_MIPS32,	CPU_MIPS32 },
  { "4km",            0,			ISA_MIPS32,	CPU_MIPS32 },
  { "4kp",            0,			ISA_MIPS32,	CPU_MIPS32 },
  { "4ksc",           MIPS_CPU_ASE_SMARTMIPS,	ISA_MIPS32,	CPU_MIPS32 },
d19573 16
a19588 16
  { "4kec",           0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "4kem",           0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "4kep",           0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "4ksd",           MIPS_CPU_ASE_SMARTMIPS,	ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "m4k",            0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "m4kp",           0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "m14k",           MIPS_CPU_ASE_MCU,		ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "m14kc",          MIPS_CPU_ASE_MCU,		ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "m14ke",          MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_DSPR2 | MIPS_CPU_ASE_MCU,
						ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "m14kec",         MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_DSPR2 | MIPS_CPU_ASE_MCU,
						ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "24kc",           0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "24kf2_1",        0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "24kf",           0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "24kf1_1",        0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
d19590 2
a19591 2
  { "24kfx",          0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "24kx",           0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
d19593 4
a19596 4
  { "24kec",          MIPS_CPU_ASE_DSP,		ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "24kef2_1",       MIPS_CPU_ASE_DSP,		ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "24kef",          MIPS_CPU_ASE_DSP,		ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "24kef1_1",       MIPS_CPU_ASE_DSP,		ISA_MIPS32R2,	CPU_MIPS32R2 },
d19598 2
a19599 2
  { "24kefx",         MIPS_CPU_ASE_DSP,		ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "24kex",          MIPS_CPU_ASE_DSP,		ISA_MIPS32R2,	CPU_MIPS32R2 },
d19601 4
a19604 8
  { "34kc",           MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "34kf2_1",        MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "34kf",           MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "34kf1_1",        MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
d19606 2
a19607 4
  { "34kfx",          MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "34kx",           MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
d19609 1
a19609 1
  { "34kn",           MIPS_CPU_ASE_MT,		ISA_MIPS32R2,	CPU_MIPS32R2 },
d19611 5
a19615 10
  { "74kc",           MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_DSPR2,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "74kf2_1",        MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_DSPR2,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "74kf",           MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_DSPR2,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "74kf1_1",        MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_DSPR2,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "74kf3_2",        MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_DSPR2,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
d19617 2
a19618 4
  { "74kfx",          MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_DSPR2,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "74kx",           MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_DSPR2,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
d19620 4
a19623 8
  { "1004kc",         MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "1004kf2_1",      MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "1004kf",         MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "1004kf1_1",      MIPS_CPU_ASE_DSP | MIPS_CPU_ASE_MT,
						ISA_MIPS32R2,	CPU_MIPS32R2 },
d19626 4
a19629 4
  { "5kc",            0,			ISA_MIPS64,	CPU_MIPS64 },
  { "5kf",            0,			ISA_MIPS64,	CPU_MIPS64 },
  { "20kc",           MIPS_CPU_ASE_MIPS3D,	ISA_MIPS64,	CPU_MIPS64 },
  { "25kf",           MIPS_CPU_ASE_MIPS3D,	ISA_MIPS64,     CPU_MIPS64 },
d19632 1
a19632 2
  { "sb1",            MIPS_CPU_ASE_MIPS3D | MIPS_CPU_ASE_MDMX,
						ISA_MIPS64,	CPU_SB1 },
d19634 1
a19634 2
  { "sb1a",           MIPS_CPU_ASE_MIPS3D | MIPS_CPU_ASE_MDMX,
						ISA_MIPS64,	CPU_SB1 },
d19636 1
a19636 1
  { "loongson3a",     0,			ISA_MIPS64,	CPU_LOONGSON_3A },
d19641 3
a19643 3
  { "octeon",	      0,      ISA_MIPS64R2,   CPU_OCTEON },
  { "octeon+",	      0,      ISA_MIPS64R2,   CPU_OCTEONP },
  { "octeon2",	      0,      ISA_MIPS64R2,   CPU_OCTEON2 },
d19646 1
a19646 1
  { "xlr",	      0,      ISA_MIPS64,     CPU_XLR },
d19651 1
a19651 1
  { "xlp",	      0,      ISA_MIPS64R2,     CPU_XLR },
d19654 1
a19654 1
  { NULL, 0, 0, 0 }
@


1.540
log
@gas/
	* dwarf2dbg.h (dwarf2_move_insn): Declare.
	* dwarf2dbg.c (line_subseg): Add pmove_tail.
	(get_line_subseg): Add create_p argument.  Initialize pmove_tail.
	(dwarf2_gen_line_info_1): Update call accordingly.
	(dwarf2_move_insn): New function.
	* config/tc-mips.c (append_insn): Use dwarf2_move_insn.

gas/testsuite/
	* gas/mips/loc-swap-3.d, gas/mips/loc-swap-3.s: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d219 1
d296 3
a298 2
  /* ase_smartmips */ 0, /* ase_dsp */ -1, /* ase_dspr2 */ -1, /* ase_mt */ -1,
  /* ase_mcu */ -1, /* ase_virt */ -1, /* mips16 */ -1,/* micromips */ -1,
d370 8
d1230 4
d1428 1
d2286 2
d5096 4
d6477 1
a6477 1
  int off12 = 0;
a6484 1
  int off0 = 0;
d8124 98
d8228 1
a8228 1
      off12 = 1;
d8236 1
a8236 1
      off12 = 1;
d8283 1
a8283 1
      off12 = mips_opts.micromips;
d8300 1
a8300 1
      off12 = mips_opts.micromips;
d8307 1
a8307 1
      off12 = mips_opts.micromips;
d8321 1
a8321 1
      off12 = mips_opts.micromips;
d8344 1
a8344 1
      off12 = mips_opts.micromips;
d8351 1
a8351 1
      off12 = mips_opts.micromips;
d8358 1
a8358 1
      off12 = mips_opts.micromips;
d8365 1
a8365 1
      off12 = mips_opts.micromips;
d8372 1
a8372 1
      off12 = mips_opts.micromips;
d8380 1
a8380 1
      off12 = 1;
d8389 1
a8389 1
      off12 = 1;
d8398 1
a8398 1
      off12 = 1;
d8406 1
a8406 1
      off12 = 1;
d8452 1
a8452 1
      off12 = mips_opts.micromips;
d8469 1
a8469 1
      off12 = mips_opts.micromips;
d8476 1
a8476 1
      off12 = mips_opts.micromips;
d8483 1
a8483 1
      off12 = mips_opts.micromips;
d8490 1
a8490 1
      off12 = mips_opts.micromips;
d8497 8
a8504 1
      off12 = mips_opts.micromips;
d8511 8
a8518 1
      off12 = mips_opts.micromips;
d8532 1
a8532 1
      off12 = mips_opts.micromips;
d8556 1
a8556 1
      off12 = mips_opts.micromips;
d8563 1
a8563 1
      off12 = mips_opts.micromips;
d8571 1
a8571 1
      off12 = 1;
d8579 1
a8579 1
      off12 = 1;
d8587 1
a8587 1
      off12 = 1;
d8595 1
a8595 1
      off12 = 1;
d8625 2
a8626 1
	  if (!off12 && !IS_SEXT_16BIT_NUM (expr1.X_add_number))
d8632 1
a8632 1
	  else if (off12 && !IS_SEXT_12BIT_NUM (expr1.X_add_number))
d8638 6
d8652 1
a8652 1
	  if (off0)
d8661 1
a8661 1
	  else if (!off12)
d8667 1
a8667 1
      else if (off12 || off0)
d8669 6
a8674 6
	  /* A 12-bit or 0-bit offset field is too narrow to be used
	     for a low-part relocation, so load the whole address into
	     the auxillary register.  In the case of "A(b)" addresses,
	     we first load absolute address "A" into the register and
	     then add base register "b".  In the case of "o(b)" addresses,
	     we simply need to add 16-bit offset "o" to base register "b", and
d8689 1
a8689 1
	  if (off0)
d9502 1
a9502 1
      off0 = 1;
d9509 1
a9509 1
      off0 = 1;
d10171 1
a10171 1
      off12 = mips_opts.micromips;
d10179 1
a10179 1
      off12 = mips_opts.micromips;
d10195 1
a10195 1
      off12 = mips_opts.micromips;
d10204 1
a10204 1
      off12 = mips_opts.micromips;
d10226 1
a10226 1
      else if (off12
d10252 1
a10252 1
      if (!off12)
d10262 1
a10262 1
      if (!off12)
d10613 1
d10775 1
d11883 29
d14732 2
d14830 2
d15084 8
d15612 6
d15642 1
d16702 9
@


1.539
log
@2013-06-13  Chao-ying Fu  <Chao-ying.Fu@@imgtec.com>

	* config/tc-mips.c (ISA_SUPPORTS_VIRT_ASE): Support micromips.
	(ISA_SUPPORTS_VIRT64_ASE): Support 64-bit micromips.
@
text
@d4376 13
a4388 16
  /* The value passed to dwarf2_emit_insn is the distance between
     the beginning of the current instruction and the address that
     should be recorded in the debug tables.  This is normally the
     current address.

     For MIPS16/microMIPS debug info we want to use ISA-encoded
     addresses, so we use -1 for an address higher by one than the
     current one.

     If the instruction produced is a branch that we will swap with
     the preceding instruction, then we add the displacement by which
     the branch will be moved backwards.  This is more appropriate
     and for MIPS16/microMIPS code also prevents a debugger from
     placing a breakpoint in the middle of the branch (and corrupting
     code if software breakpoints are used).  */
  dwarf2_emit_insn ((HAVE_CODE_COMPRESSION ? -1 : 0) + branch_disp);
@


1.538
log
@	gas/
	* config/tc-mips.c (append_insn): Don't do branch relaxation for
	MIPS-3D instructions either.
	(md_convert_frag): Update the COPx branch mask accordingly.

	* config/tc-mips.c (md_show_usage): Document --[no-]relax-branch
	option.
	* doc/as.texinfo (Overview): Add --relax-branch and
	--no-relax-branch.
	* doc/c-mips.texi (MIPS Opts): Document --relax-branch and
	--no-relax-branch.

	gas/testsuite/
	* gas/mips/relax-bc1any.l: New test.
	* gas/mips/relax-bc1any.s: New test source.
	* gas/mips/mips.exp: Run the new test.
@
text
@d384 2
a385 1
			       || mips_opts.isa == ISA_MIPS64R2)
d387 3
a389 1
#define ISA_SUPPORTS_VIRT64_ASE (mips_opts.isa == ISA_MIPS64R2)
@


1.537
log
@gas/
2013-06-08  Catherine Moore  <clm@@codesourcery.com>

	* config/tc-mips.c (is_opcode_valid):  Build ASE mask.
	(is_opcode_valid_16): Pass ase value to opcode_is_member.
	(append_insn): Change INSN_xxxx to ASE_xxxx.

include/
2013-06-08  Catherine Moore  <clm@@codesourcery.com>

	* opcode/mips.h (mips_opcode): Add ase field.
	(INSN_ASE_MASK): Delete.
	(INSN_DSP): Rename to ASE_DSP.  Provide new value.
	(INSN_DSPR2): Rename to ASE_DSPR2.  Provide new value.
	(INSN_MCU): Rename to ASE_MCU.  Provide new value.
	(INSN_MDMX): Rename to ASE_MDMX.  Provide new value.
	(INSN_MIPS3d): Rename to ASE_MIPS3D.  Provide new value.
	(INSN_MT): Rename to ASE_MT.  Provide new value.
	(INSN_SMARTMIPS): Rename to ASE_SMARTMIPS.  Provide new value.
	(INSN_VIRT): Rename to ASE_VIRT.  Provide new value.
	(INSN_VIRT64): Rename to ASE_VIRT64.  Provide new value.
	(opcode_is_member): Add ase argument.  Check ase.

opcodes/
2013-06-08  Catherine Moore  <clm@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* micromips-opc.c (D32, D33, MC): Update definitions.
 	(micromips_opcodes):  Initialize ase field.
	* mips-dis.c (mips_arch_choice): Add ase field.
	(mips_arch_choices): Initialize ase field.
	(set_default_mips_dis_options): Declare and setup mips_ase.
	* mips-opc.c (M3D, SMT, MX, IVIRT, IVIRT64, D32, D33, D64,
	MT32, MC): Update definitions.
	(mips_builtin_opcodes): Initialize ase field.
@
text
@d4397 3
a4399 3
	     /* Don't relax BPOSGE32/64 as they have no complementing
	        branches.  */
	     && !(ip->insn_mo->ase & (ASE_DSP64 | ASE_DSP)));
d18180 4
a18183 4
		  /* bc[0-3][tf]l? and bc1any[24][ft] instructions can
		     have the condition reversed by tweaking a single
		     bit, and their opcodes all have 0x4???????.  */
		  gas_assert ((insn & 0xf1000000) == 0x41000000);
d19728 2
a19729 1
--[no-]construct-floats [dis]allow floating point values to be constructed\n"
@


1.536
log
@2013-05-31  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-mips.c (s_ehword): New.


2013-05-31  Catherine Moore  <clm@@codesourcery.com>

	gas/testsuite/
	* gas/mips/ehword.d: New.
	* gas/mips/ehword.s: New.
	* gas/mips/mips.exp: Run ehword test.
@
text
@d2250 2
a2251 2
/* Return TRUE if opcode MO is valid on the currently selected ISA and
   architecture.  Use is_opcode_valid_16 for MIPS16 opcodes.  */
d2257 1
d2261 1
a2261 1
    isa |= INSN_MDMX;
d2263 1
a2263 1
    isa |= INSN_DSP;
d2265 1
a2265 1
    isa |= INSN_DSP64;
d2267 1
a2267 1
    isa |= INSN_DSPR2;
d2269 1
a2269 1
    isa |= INSN_MT;
d2271 1
a2271 1
    isa |= INSN_MIPS3D;
d2273 1
a2273 1
    isa |= INSN_SMARTMIPS;
d2275 1
a2275 1
    isa |= INSN_MCU;
d2277 1
a2277 1
    isa |= INSN_VIRT;
d2279 1
a2279 1
    isa |= INSN_VIRT64;
d2281 1
a2281 1
  if (!opcode_is_member (mo, isa, mips_opts.arch))
d2313 1
a2313 1
  return opcode_is_member (mo, mips_opts.isa, mips_opts.arch);
d4399 1
a4399 1
	     && !(ip->insn_mo->membership & (INSN_DSP64 | INSN_DSP)));
@


1.535
log
@2013-05-30  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* bfd-in2.h: Regenerate.
	* elf32-mips.c (elf_mips_eh_howto): New.
	(bfd_elf32_bfd_reloc_type_lookup ): Support BFD_RELOC_MIPS_EH.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf32_rtype_to_howto): Support R_MIPS_EH.
	* elf64-mips.c (elf_mips_eh_howto): New.
	(bfd_elf64_bfd_reloc_type_lookup): Support BFD_RELOC_MIPS_EH.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Support R_MIPS_EH.
	* libbfd.h: Regenerate.
	* reloc.c (BFD_RELOC_MIPS_EH): New.

	gas/
	* config/tc-mips.c (md_apply_fix): Support BFD_RELOC_MIPS_EH.

	include/elf
	* mips.h (R_MIPS_EH): New.
@
text
@d1371 1
d1454 1
d17160 28
@


1.534
log
@	gas/
	* config/tc-mips.c (macro) <ld>: Don't use $zero for address
	calculation.

	gas/testsuite/
	* gas/mips/ld-zero.d: New test.
	* gas/mips/ld-zero-2.d: New test.
	* gas/mips/ld-zero-3.d: New test.
	* gas/mips/ld-zero-q.d: New test.
	* gas/mips/ld-zero-u.d: New test.
	* gas/mips/ecoff@@ld-zero-3.d: New test.
	* gas/mips/micromips@@ld-zero-2.d: New test.
	* gas/mips/micromips@@ld-zero-3.d: New test.
	* gas/mips/ld-zero.s: New test source.
	* gas/mips/ld-zero-2.s: New test source.
	* gas/mips/ld-zero-3.s: New test source.
	* gas/mips/ld-zero-q.s: New test source.
	* gas/mips/ld-zero-u.s: New test source.
	* gas/mips/mips.exp: Run the new tests.
@
text
@d15827 1
@


1.533
log
@include/opcode/
2013-05-22  Jrgen Urban  <JuergenUrban@@gmx.de>

	* mips.h (M_LQC2_AB, M_SQC2_AB): New macros.

opcodes/
2013-05-22  Jrgen Urban  <JuergenUrban@@gmx.de>

	* mips-opc.c (mips_builtin_opcodes): Add R5900 VU0 instructions.

gas/
2013-05-22  Jrgen Urban  <JuergenUrban@@gmx.de>

	* config/tc-mips.c (macro): Handle M_LQC2_AB and M_SQC2_AB.

gas/testsuite/
2013-05-22  Jrgen Urban  <JuergenUrban@@gmx.de>

	* gas/mips/r5900-full.s, gas/mips/r5900-full.d: Add tests for LQ
	and SQ macros.
	* gas/mips/r5900-vu0.s, gas/mips/r5900-vu0.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d8289 2
a8290 1
      if (breg == treg + lp)
@


1.532
log
@
binutils/ChangeLog:
* doc/binutils.texi: Document -Mvirt disassembler option.

gas/ChangeLog:
* config/tc-mips.c (struct mips_set_options): New ase_virt field.
(mips_opts): Update for the new field.
(file_ase_virt): New variable.
(ISA_SUPPORTS_VIRT_ASE): New macro.
(ISA_SUPPORTS_VIRT64_ASE): New macro.
(MIPS_CPU_ASE_VIRT): New define.
(is_opcode_valid): Handle ase_virt.
(macro_build): Handle "+J".
(validate_mips_insn): Likewise.
(mips_ip): Likewise.
(enum options): Add OPTION_VIRT and OPTION_NO_VIRT.
(md_longopts): Add mvirt and mnovirt
(md_parse_option): Handle OPTION_VIRT and OPTION_NO_VIRT.
(mips_after_parse_args): Handle ase_virt field.
(s_mipsset): Handle "virt" and "novirt".
(mips_elf_final_processing): Add a comment about virt ASE might need a new flag.
(md_show_usage): Print out the usage of -mvirt and mno-virt options.
* doc/c-mips.texi: Document -mvirt and -mno-virt.
Document ".set virt" and ".set novirt".

gas/testsuite/ChangeLog:
* gas/mips/mips.exp: Run virt and virt64 testcases.
* gas/mips/virt.d: New file.
* gas/mips/virt.s: New file.
* gas/mips/virt64.d: New file.
* gas/mips/virt64.s: New file.

include/opcode/ChangeLog:
* mips.h (OP_MASK_CODE10): Correct definition.
(OP_SH_CODE10): Likewise.
Add a comment that "+J" is used now for OP_*CODE10.
(INSN_ASE_MASK): Update.
(INSN_VIRT): New macro.
(INSN_VIRT64): New macro

opcodes/ChangeLog:
* mips-dis.c (mips_arch_choices): Add INSN_VIRT to mips32r2 .
Add INSN_VIRT and INSN_VIRT64 to mips64r2.
(parse_mips_dis_option): Handle the virt option.
(print_insn_args): Handle "+J".
(print_mips_disassembler_options): Print out message about virt64.
* mips-opc.c (IVIRT): New define.
(IVIRT64): New define.
(mips_builtin_opcodes): Add dmfgc0, dmtgc0, hypcall, mfgc0, mtgc0,
tlbgr, tlbgwi, tlbginv, tlbginvf, tlbgwr, tlbgp VIRT instructions.
Move rfe to the bottom as it conflicts with tlbgp.
@
text
@d8204 7
d8400 7
@


1.531
log
@2013-05-06  Paul Brook  <paul@@codesourcery.com>

        include/elf/
        * mips.h (R_MIPS_PC32): Update comment.

        * elf64-mips.c (elf_mips_gnu_pcrel32): New.
        (bfd_elf64_bfd_reloc_type_lookup, bfd_elf64_bfd_reloc_name_lookup,
        mips_elf64_rtype_to_howto): Handle R_MIPS_PC32.
        * elfn32-mips.c (elf_mips_gnu_pcrel32): New.
        (bfd_elfn32_bfd_reloc_type_lookup, bfd_elfn32_bfd_reloc_name_lookup,
        mips_elfn32_rtype_to_howto): Handle R_MIPS_PC32.

2013-05-06  Paul Brook  <paul@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

        gas/
        * config/tc-mips.c (md_pcrel_from): Handle BFD_RELOC_32_PCREL.
        (limited_pcrel_reloc_p): Likewise.
	(md_apply_fix): Likewise.
	(tc_gen_reloc): Likewise.
@
text
@d221 1
d296 5
a300 4
  /* ase_mcu */ -1, /* mips16 */ -1, /* micromips */ -1, /* noreorder */ 0,
  /* at */ ATREG, /* warn_about_macros */ 0, /* nomove */ 0, /* nobopt */ 0,
  /* noautoextend */ 0, /* gp32 */ 0, /* fp32 */ 0, /* arch */ CPU_UNKNOWN,
  /* sym32 */ FALSE, /* soft_float */ FALSE, /* single_float */ FALSE
d379 9
d1409 1
d2273 4
d5055 5
d10440 1
d11364 17
d14538 2
d14644 2
d14923 8
d15424 6
d15437 1
d16507 9
d18788 2
a18789 6
  /* Set MIPS ELF flags for ASEs.  */
  /* We may need to define a new flag for DSP ASE, and set this flag when
     file_ase_dsp is true.  */
  /* Same for DSP R2.  */
  /* We may need to define a new flag for MT ASE, and set this flag when
     file_ase_mt is true.  */
d19660 3
@


1.530
log
@2013-05-06  Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.c (limited_pcrel_reloc_p): New function.
	(mips_fix_adjustable): Adjust pc-relative check to use
	limited_pc_reloc_p.
@
text
@d2761 3
d2768 1
d15422 3
d15647 2
a15648 1
	      || fixP->fx_r_type == BFD_RELOC_MICROMIPS_16_PCREL_S1);
d15796 1
d17929 2
a17930 1
		  || fixp->fx_r_type == BFD_RELOC_MICROMIPS_16_PCREL_S1);
@


1.529
log
@gas/
	* config/tc-mips.c (mips_pseudo_table): Add stabd and stabs entries.
	(s_mips_stab): Do not restrict to stabn only.

gas/testsuite/
	* gas/mips/mips16-stabs.s, gas/mips/mips16-stabs.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d2747 18
d17835 3
a17837 3
     Likewise an in-range offset of PC-relative relocations may overflow
     the in-place relocatable field if recalculated against the start
     address of the symbol's containing section.  */
d17839 2
a17840 1
      && (fixp->fx_pcrel || jalr_reloc_p (fixp->fx_r_type)))
@


1.528
log
@2013-04-30  Chao-ying Fu  <Chao-ying.Fu@@imgtec.com>

	* config/tc-mips.c (mips_ip): Add sizelo.
	For "+C", "+G", and "+H", set sizelo and compare against it.
@
text
@d1475 1
d1477 1
d17093 13
a17105 5
/* Handle a .stabn directive.  We need these in order to mark a label
   as being a mips16 text label correctly.  Sometimes the compiler
   will emit a label, followed by a .stabn, and then switch sections.
   If the label and .stabn are in mips16 mode, then the label is
   really a mips16 text label.  */
d17110 1
a17110 3
  if (type == 'n')
    mips_mark_labels ();

@


1.527
log
@	* config/tc-mips.c (s_cpload): Call mips_mark_labels and set
	mips_assembling_insn appropriately.
	(s_cpsetup, s_cprestore, s_cpreturn, s_cpadd): Likewise.
@
text
@d10793 1
d11378 1
d11383 1
d11388 1
d11393 4
a11396 5
		  /* Check for negative input so that small negative numbers
		     will not succeed incorrectly.  The checks against
		     (pos+size) transitively check "size" itself,
		     assuming that "pos" is reasonable.  */
		  if ((long) imm_expr.X_add_number < 0
@


1.526
log
@	* config/tc-mips.c (append_insn): Correcting indentation, remove
	extraneous braces.
@
text
@d16624 3
d16636 1
d16713 3
d16763 1
d16821 3
d16829 1
d16860 3
d16878 1
d17058 3
d17067 1
@


1.525
log
@gas/
2013-02-09  Jrgen Urban  <JuergenUrban@@gmx.de>

	* config/tc-mips.c (CPU_HAS_LDC1_SDC1): New macro.
	(macro): Use it.  Assert that trunc.w.s is not used for r5900.

opcodes/
2013-02-09  Jrgen Urban  <JuergenUrban@@gmx.de>

	* mips-opc.c (mips_builtin_opcodes): Enable l.d and s.d macros for
	single-float.  Disable ll, lld, sc and scd for EE.  Disable the
	trunc.w.s macro for EE.

gas/testsuite/
2013-02-09  Jrgen Urban  <JuergenUrban@@gmx.de>

	* gas/mips/24k-triple-stores-2.d, gas/mips/24k-triple-stores-2.s,
	gas/mips/micromips@@24k-triple-stores-2.d: Move "sc" tests to...
	* gas/mips/24k-triple-stores-2-llsc.d,
	gas/mips/24k-triple-stores-2-llsc.s,
	gas/mips/micromips@@24k-triple-stores-2-llsc.d: ...these new tests.
	* gas/mips/r5900-full.d, gas/mips/r5900-full.s: Verify that the
	MIPS ISA level can be upgraded to support ll, sc, lld and scd.
	* gas/mips/l_d-single.d, gas/mips/s_d-single.d,
	gas/mips/r5900-nollsc.l, gas/mips/r5900-nollsc.s: New tests.
	* gas/mips/mips.exp: Update accordingly.  Add "nollsc" to r5900
	properties.
@
text
@d4647 1
a4647 1
    mips_no_prev_insn ();
d4650 1
a4650 3
      {
        history[i].cleared_p = 1;
      }
@


1.524
log
@2013-01-09  Steve Ellcey  <sellcey@@mips.com>

	* config/tc-i386.c (md_begin): Remove 'internal Error' from as_fatal
	calls.
	* config/tc-mips.c (internalError): Remove, replace with abort.
@
text
@d507 4
d8934 1
a8934 2
	  if ((mips_opts.isa != ISA_MIPS1 || mips_opts.micromips)
	    && (mips_opts.arch != CPU_R5900))
d8957 1
a8957 2
	  if ((mips_opts.isa != ISA_MIPS1 || mips_opts.micromips)
	    && (mips_opts.arch != CPU_R5900))
d8974 1
a8974 2
      gas_assert ((mips_opts.isa == ISA_MIPS1)
        || (mips_opts.arch == CPU_R5900));
d8986 1
a8986 1
      gas_assert (mips_opts.isa == ISA_MIPS1);
d9012 1
a9012 1
      if ((mips_opts.isa != ISA_MIPS1) && (mips_opts.arch != CPU_R5900))
d9025 1
a9025 1
      if ((mips_opts.isa != ISA_MIPS1) && (mips_opts.arch != CPU_R5900))
d9926 1
a9926 1
      gas_assert ((mips_opts.isa == ISA_MIPS1) || (mips_opts.arch == CPU_R5900));
@


1.523
log
@	* archures.c: Add support for MIPS r5900
	* bfd-in2.h: Add support for MIPS r5900
	* config.bfd: Add support for Sony Playstation 2
	* cpu-mips.c: Add support for MIPS r5900
	* elfxx-mips.c: Add support for MIPS r5900 (extension of r4000)

	* config/tc-mips.c: Add support for MIPS r5900
	Add M_LQ_AB and M_SQ_AB to support large values for instructions lq and sq.
	* config/tc-mips.c (can_swap_branch_p, get_append_method): Detect some conditional short loops to fix a bug on the r5900 by NOP in the branch delay slot.
	* config/tc-mips.c (M_MUL): Support 3 operands in multu on r5900.
	* config/tc-mips.c (M_TRUNCWS): Support trunc.w.s on r5900 in MIPS ISA I.
	* config/tc-mips.c (s_mipsset): Force 32 bit floating point on r5900.
	* configure.in: Detect CPU type when target string contains r5900 (e.g. mips64r5900el-linux-gnu).

	* config/tc-mips.c (mips_ip): Check parameter range of instructions mfps and mtps on r5900.

	* elf/mips.h: Add MIPS machine variant number for r5900 which is compatible with old Playstation 2 software.
	* opcode/mips.h: Add support for r5900 instructions including lq and sq.

	* configure.tgt: Support ELF files for Sony Playstation 2 (for ps2dev and ps2sdk).
	* emulparams/elf32lr5900n32.sh: Create linker script for Sony Playstation 2 ELF files using MIPS ABI n32.
	* emulparams/elf32lr5900.sh: Create linker script for Sony Playstation 2 ELF files using MIPS ABI o32.
	* Makefile.am: Add linker scripts for Sony Playstation 2 ELF files.

	* opcodes/mips-dis.c: Add names for CP0 registers of r5900.
	* opcodes/mips-opc.c: Add M_SQ_AB and M_LQ_AB to support larger range for instructions sq and lq.

	* opcodes/mips-opc.c: Add support for MIPS r5900 CPU.
	Add support for 128 bit MMI (Multimedia Instructions).
	Add support for EE instructions (Emotion Engine).
	Disable unsupported floating point instructions (64 bit and undefined compare operations).
	Enable instructions of MIPS ISA IV which are supported by r5900.
	Disable 64 bit co processor instructions.
	Disable 64 bit multiplication and division instructions.
	Disable instructions for co-processor 2 and 3, because these are not supported (preparation for later VU0 support (Vector Unit)).
	Disable cvt.w.s because this behaves like trunc.w.s and the correct execution can't be ensured on r5900.
	Add trunc.w.s using the opcode encoding of cvt.w.s on r5900. This will confuse less developers and compilers.
@
text
@a1312 3
#define internalError()							\
    as_fatal (_("internal Error, line %d, %s"), __LINE__, __FILE__)

d5030 1
a5030 1
	      internalError ();
d5234 1
a5234 1
	      internalError ();
d5239 1
a5239 1
	  internalError ();
d10152 1
a10152 1
      internalError ();
d11300 1
a11300 1
		      internalError ();
d12835 1
a12835 1
			internalError ();
d12908 1
a12908 1
			internalError ();
d13372 1
a13372 1
	      internalError ();
d13649 1
a13649 1
		  internalError ();
d13682 1
a13682 1
		  internalError ();
d14041 1
a14041 1
	      internalError ();
d15852 1
a15852 1
      internalError ();
@


1.522
log
@	gas/
	* config/tc-mips.c (mips_ip) <'u'>: Default to BFD_RELOC_LO16.

	gas/testsuite/
	* gas/mips/lui.d: New test.
	* gas/mips/micromips@@lui.d: New test.
	* gas/mips/lui-1.l: New list test.
	* gas/mips/lui-2.l: New list test.
	* gas/mips/lui.s: New test source.
	* gas/mips/lui-1.s: New test source.
	* gas/mips/lui-2.s: New test source.
	* gas/mips/mips.exp: Run the new tests.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d174 4
d525 1
d543 1
d1688 1
d3745 3
a3747 1
   with the previous instruction.  */
d3750 2
a3751 1
can_swap_branch_p (struct mips_cl_insn *ip)
d3870 48
d3921 3
a3923 1
/* Decide how we should add IP to the instruction stream.  */
d3926 2
a3927 1
get_append_method (struct mips_cl_insn *ip)
d3943 2
a3944 1
      if (!branch_likely_p (ip) && can_swap_branch_p (ip))
d4325 1
a4325 1
  method = get_append_method (ip);
d4643 3
d4648 6
d4665 2
a4666 1
/* Forget that there was any previous instruction or label.  */
d8933 2
a8934 1
	  if (mips_opts.isa != ISA_MIPS1 || mips_opts.micromips)
d8957 2
a8958 1
	  if (mips_opts.isa != ISA_MIPS1 || mips_opts.micromips)
d8975 2
a8976 1
      gas_assert (mips_opts.isa == ISA_MIPS1);
d9014 1
a9014 1
      if (mips_opts.isa != ISA_MIPS1)
d9027 1
a9027 1
      if (mips_opts.isa != ISA_MIPS1)
d9035 10
d9357 6
d9365 1
d9928 1
a9928 1
      gas_assert (mips_opts.isa == ISA_MIPS1);
d10733 1
a10733 1
  if (ISA_HAS_ODD_SINGLE_FPR (mips_opts.isa))
d11884 4
d16479 6
d16486 1
d19188 1
@


1.521
log
@	* config/tc-mips.c (is_delay_slot_valid): Simplify expression.
@
text
@d12416 1
@


1.520
log
@	gas/
	* config/tc-mips.c (append_insn): Set fx_no_overflow for 16-bit
	microMIPS branch relocations.

	gas/testsuite/
	* gas/mips/micromips-b16.d: New test.
	* gas/mips/micromips-b16.s: New test source.
	* gas/mips/mips.exp: Run the new test.
@
text
@d2324 1
a2324 2
    return ((history[0].insn_mo->pinfo2 & INSN2_BRANCH_DELAY_16BIT) == 0
	    ? TRUE : FALSE);
@


1.519
log
@	gas/
	* config/tc-mips.c (is_delay_slot_valid): Don't accept macros
	in 16-bit delay slots.
	(macro_build_jalr): Emit 32-bit JALR if placed in a 32-bit delay
	slot.
	(macro) <M_JAL_2>: Likewise

	gas/testsuite/
	* gas/mips/micromips-branch-delay.l: Update messages for 16-bit
	delay slot changes.
	* gas/mips/micromips-warn-branch-delay.d: New test.
	* gas/mips/micromips-warn-branch-delay.l: Stderr output for the
	new test.
	* gas/mips/micromips-warn-branch-delay-1.d: New test.
	* gas/mips/micromips-warn-branch-delay.s: New test source.
	* gas/mips/micromips-warn-branch-delay-1.s: New test source.
	* gas/mips/mips.exp: Run the new tests.
@
text
@d4467 5
@


1.518
log
@gas/
	* config/tc-mips.h (TC_FORCE_RELOCATION): Remove comment.
	* config/tc-mips.c (calculate_reloc): New function.
	(append_insn): Use it.  Do not resolve compound relocations here.
	(mips16_macro_build, mips16_ip): Use calculate_reloc.
	(mips16_immed_extend): New function, split out from...
	(mips16_immed): ...here.
	(mips_frob_file): Handle null symbols.
	(mips_force_relocation): Remove NEWABI handling.
	(read_reloc_insn, write_reloc_insn): New functions.
	(md_apply_fix): Report TLS relocations against constants.
	Use read_reloc_insn, calculate_reloc and write_reloc_insn.
	Report relocations against constants that can't be resolved
	at assembly time.

gas/testsuite/
	* gas/mips/elf-rel22.s, gas/mips/elf-rel22.d: Add more tests.
	* gas/mips/elf-rel29.s, gas/mips/elf-rel29.d,
	gas/mips/micromips@@elf-rel29.d, gas/mips/elf-rel30.s,
	gas/mips/elf-rel30.l: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d2304 12
a2315 1
   of the preceding instruction.  Always TRUE in the standard MIPS mode.  */
d2324 2
a2325 1
    return TRUE;
d5343 2
a5344 1
      if (MIPS_JALR_HINT_P (ep))
d7784 3
a7786 1
	  if (mips_opts.micromips && dreg == RA)
d7801 3
a7803 1
	  if (mips_opts.micromips && dreg == RA)
@


1.517
log
@gas/
2012-09-23  Maciej W. Rozycki  <macro@@codesourcery.com>

	* config/tc-mips.c (append_insn) <BFD_RELOC_MIPS_JMP>: Don't
	mark as incomplete for constant expressions.
	<BFD_RELOC_MIPS16_JMP>: Likewise.
@
text
@d4025 46
d4106 3
a4108 1
  else if (*reloc_type <= BFD_RELOC_UNUSED
a4110 3
      unsigned int tmp;

      ip->complete_p = 1;
a4112 29
	case BFD_RELOC_32:
	  ip->insn_opcode |= address_expr->X_add_number;
	  break;

	case BFD_RELOC_MIPS_HIGHEST:
	  tmp = (address_expr->X_add_number + 0x800080008000ull) >> 48;
	  ip->insn_opcode |= tmp & 0xffff;
	  break;

	case BFD_RELOC_MIPS_HIGHER:
	  tmp = (address_expr->X_add_number + 0x80008000ull) >> 32;
	  ip->insn_opcode |= tmp & 0xffff;
	  break;

	case BFD_RELOC_HI16_S:
	  tmp = (address_expr->X_add_number + 0x8000) >> 16;
	  ip->insn_opcode |= tmp & 0xffff;
	  break;

	case BFD_RELOC_HI16:
	  ip->insn_opcode |= (address_expr->X_add_number >> 16) & 0xffff;
	  break;

	case BFD_RELOC_UNUSED:
	case BFD_RELOC_LO16:
	case BFD_RELOC_MIPS_GOT_DISP:
	  ip->insn_opcode |= address_expr->X_add_number & 0xffff;
	  break;

a4154 1
	    ip->complete_p = 0;
d4159 12
a4170 2
	  internalError ();
	}	
d5255 2
d5261 1
a5261 1
	    else
d5263 1
a5263 2
		mips16_immed (NULL, 0, c, *r, ep->X_add_number,
			      0, &insn.insn_opcode);
d13405 2
d13410 3
a13412 3
		      && *imm_reloc != BFD_RELOC_MIPS16_GOT16
		      && *imm_reloc != BFD_RELOC_MIPS16_CALL16
		      && insn->pinfo != INSN_MACRO)
a13413 25
		      valueT tmp;

		      switch (*offset_reloc)
			{
			  case BFD_RELOC_MIPS16_HI16_S:
			    tmp = (imm_expr.X_add_number + 0x8000) >> 16;
			    break;

			  case BFD_RELOC_MIPS16_HI16:
			    tmp = imm_expr.X_add_number >> 16;
			    break;

			  case BFD_RELOC_MIPS16_LO16:
			    tmp = ((imm_expr.X_add_number + 0x8000) & 0xffff)
				  - 0x8000;
			    break;

			  case BFD_RELOC_UNUSED:
			    tmp = imm_expr.X_add_number;
			    break;

			  default:
			    internalError ();
			}

d13415 1
a13415 1
				    *offset_reloc, tmp, forced_insn_length,
d14001 25
a14108 1
      int extval;
d14127 1
a14127 17
      if (op->extbits == 16)
	{
	  extval = ((val >> 11) & 0x1f) | (val & 0x7e0);
	  val &= 0x1f;
	}
      else if (op->extbits == 15)
	{
	  extval = ((val >> 11) & 0xf) | (val & 0x7f0);
	  val &= 0xf;
	}
      else
	{
	  extval = ((val & 0x1f) << 6) | (val & 0x20);
	  val = 0;
	}

      *insn |= (extval << 16) | val;
d15371 2
a15372 1
	 there isn't supposed to be a matching LO.  */
d15374 2
a15375 1
	  && !pic_need_relax (l->fixp->fx_addsy, l->seg))
a15432 3
/* We may have combined relocations without symbols in the N32/N64 ABI.
   We have to prevent gas from dropping them.  */

d15446 16
a15461 6
  if (HAVE_NEWABI
      && S_GET_SEGMENT (fixp->fx_addsy) == bfd_abs_section_ptr
      && (fixp->fx_r_type == BFD_RELOC_MIPS_SUB
	  || hi16_reloc_p (fixp->fx_r_type)
	  || lo16_reloc_p (fixp->fx_r_type)))
    return 1;
d15463 8
a15470 1
  return 0;
d15479 1
a15479 1
  long insn;
d15545 6
d15572 1
d15587 1
d15600 1
d15609 17
a15625 1
      /* Nothing needed to do.  The value comes from the reloc entry.  */
a15658 21
    case BFD_RELOC_LO16:
    case BFD_RELOC_MIPS16_LO16:
    case BFD_RELOC_MICROMIPS_LO16:
      /* FIXME: Now that embedded-PIC is gone, some of this code/comment
	 may be safe to remove, but if so it's not obvious.  */
      /* When handling an embedded PIC switch statement, we can wind
	 up deleting a LO16 reloc.  See the 'o' case in mips_ip.  */
      if (fixP->fx_done)
	{
	  if (*valP + 0x8000 > 0xffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  /* 32-bit microMIPS instructions are divided into two halfwords.
	     Relocations always refer to the second halfword, regardless
	     of endianness.  */
	  if (target_big_endian || fixP->fx_r_type == BFD_RELOC_MICROMIPS_LO16)
	    buf += 2;
	  md_number_to_chars (buf, *valP, 2);
	}
      break;

@


1.516
log
@gas/
2012-09-23  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Maciej W. Rozycki  <macro@@codesourcery.com>

	* config/tc-mips.h (mips_record_label): Delete.
	(mips_add_dot_label): Declare.
	(tc_new_dot_label): Use it.
	* config/tc-mips.c (mips_assembling_insn): New variable.
	(md_assemble): Call mips_mark_labels.  Set mips_assembling_insn
	while the main part of the function is executing.
	(mips_compressed_mark_label): New function, split out from...
	(mips_compressed_mark_labels): ...here.
	(append_insn): Don't call mips_mark_labels here.
	(mips_record_label): Make local.
	(mips_add_dot_label): New function.

gas/testsuite/
	* gas/mips/dot-1.s, gas/mips/dot-1.d, gas/mips/micromips@@dot-1.d,
	gas/mips/mips16@@dot-1.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d4107 1
a4107 1
	    ip->complete_p = 0;
d4119 1
a4119 1
	  ip->complete_p = 0;
@


1.515
log
@Fix typo in previous commit.
@
text
@d1577 5
d2600 3
d2613 2
a2614 6
    {
      as_bad ("%s `%s'", insn_error, str);
      return;
    }

  if (insn.insn_mo->pinfo == INSN_MACRO)
d2632 2
d2841 1
a2841 1
/* Mark instruction labels in MIPS16/microMIPS mode.  This permits the
d2850 1
a2850 1
mips_compressed_mark_labels (void)
a2851 3
  segment_info_type *si = seg_info (now_seg);
  struct insn_label_list *l;

a2853 4
  for (l = si->label_list; l != NULL; l = l->next)
   {
      symbolS *label = l->label;

d2855 7
a2861 7
      if (IS_ELF)
	{
	  if (mips_opts.mips16)
	    S_SET_OTHER (label, ELF_ST_SET_MIPS16 (S_GET_OTHER (label)));
	  else
	    S_SET_OTHER (label, ELF_ST_SET_MICROMIPS (S_GET_OTHER (label)));
	}
d2863 20
a2882 10
      if ((S_GET_VALUE (label) & 1) == 0
	/* Don't adjust the address if the label is global or weak, or
	   in a link-once section, since we'll be emitting symbol reloc
	   references to it which will be patched up by the linker, and
	   the final value of the symbol may or may not be MIPS16/microMIPS.  */
	  && ! S_IS_WEAK (label)
	  && ! S_IS_EXTERNAL (label)
	  && ! s_is_linkonce (label, now_seg))
	S_SET_VALUE (label, S_GET_VALUE (label) | 1);
    }
a4042 2
  mips_mark_labels ();

d18415 1
a18415 1
void
d18445 11
@


1.514
log
@gas/
	* config/tc-mips.c (SEXT_16BIT): New macro.
	(mips16_immed): Take the reloc type as a parameter.  Do not impose
	a signed vs. unsigned distinction on the value when a relocation
	operator was used.
	(mips16_macro_build, mips16_ip, md_convert_frag): Pass the reloc
	type to mips16_immed.
	(macro): Use SEXT_16BIT.
@
text
@d18283 1
a18283 1
		    BFD_RELOC_NONE, val, user_length, &insn);
@


1.513
log
@gas/
	* config/tc-mips.c (read_insn, write_insn, read_compressed_insn):
	New functions.
	(install_insn, md_apply_fix, md_convert_frag, mips_handle_align):
	Use them, and write_compressed_insn.
@
text
@d1179 3
d1327 2
a1328 1
  (char *, unsigned int, int, offsetT, unsigned int, unsigned long *);
d5229 1
a5229 1
		mips16_immed (NULL, 0, c, ep->X_add_number,
d7284 1
a7284 1
		((offset_expr.X_add_number + 0x8000) & 0xffff) - 0x8000;
d7512 1
a7512 2
	  offset_expr.X_add_number =
	    ((expr1.X_add_number + 0x8000) & 0xffff) - 0x8000;
a13402 1
		      *offset_reloc = BFD_RELOC_UNUSED;
d13405 2
a13406 1
				    tmp, forced_insn_length, &ip->insn_opcode);
d13409 1
d13995 6
a14000 2
   TYPE is the type of the immediate field.  USER_INSN_LENGTH is the
   length that the user requested, or 0 if none.  */
d14003 2
a14004 1
mips16_immed (char *file, unsigned int line, int type, offsetT val,
d14029 2
d14036 2
d14076 1
a14076 1
      if (op->extu)
d14078 13
a14090 7
	  minext = 0;
	  maxext = (1 << op->extbits) - 1;
	}
      else
	{
	  minext = - (1 << (op->extbits - 1));
	  maxext = (1 << (op->extbits - 1)) - 1;
a14091 3
      if (val < minext || val > maxext)
	as_bad_where (file, line,
		      _("operand value out of range for instruction"));
d18282 2
a18283 2
      mips16_immed (fragp->fr_file, fragp->fr_line, type, val,
		    user_length, &insn);
@


1.512
log
@gas/
	* config/tc-mips.c (mips_cl_insn): Remove use_extend and extend.
	(MIPS16_EXTEND): New macro.
	(mips16_opcode_length): New function.
	(insn_length): Use it.
	(create_insn): Update after mips_cl_insn change.
	(write_compressed_insn): New function.
	(install_insn): Use it.
	(append_insn): Use insn_length to check for unextended MIPS16
	instructions.
	(mips16_macro_build): Update call to mips16_immed.
	(mips16_ip): Likewise.  Use MIPS16_EXTEND to force an extended
	instruction.
	(mips16_immed): Remove use_extend and extend; install EXTEND
	opcodes in the upper 16 bits of *INSN instead.  Keep the
	instruction extended if it already is.  Replace warn, small
	and ext with a forced_insn_length-like parameter.
	(md_convert_frag): Update call mips16_immed.
	Use write_compressed_insn.
@
text
@d1689 43
d1754 1
a1754 1
    md_number_to_chars (f, insn->insn_opcode, 4);
d15428 1
a15428 1
  bfd_byte *buf;
d15448 1
a15448 1
  buf = (bfd_byte *) (fixP->fx_frag->fr_literal + fixP->fx_where);
d15559 1
a15559 1
	    md_number_to_chars ((char *) buf, *valP, 8);
d15568 2
a15569 4
	      md_number_to_chars ((char *)(buf + (target_big_endian ? 4 : 0)),
				  *valP, 4);
	      md_number_to_chars ((char *)(buf + (target_big_endian ? 0 : 4)),
				  hiv, 4);
d15581 1
a15581 1
	md_number_to_chars ((char *) buf, *valP, fixP->fx_size);
d15601 1
a15601 1
	  md_number_to_chars ((char *) buf, *valP, 2);
d15617 1
a15617 4
      if (target_big_endian)
	insn = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
      else
	insn = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
d15622 1
a15622 1
	  md_number_to_chars ((char *) buf, insn, 4);
d15644 1
a15644 1
	  md_number_to_chars ((char *) buf, insn, 4);
d17791 1
a17791 1
      bfd_byte *buf;
d17796 2
a17797 6
      buf = (bfd_byte *)fragp->fr_literal + fragp->fr_fix;

      if (target_big_endian)
	insn = bfd_getb32 (buf);
      else
	insn = bfd_getl32 (buf);
d17808 2
a17809 2
	  fixp = fix_new_exp (fragp, buf - (bfd_byte *)fragp->fr_literal,
			      4, &exp, TRUE, BFD_RELOC_16_PCREL_S2);
d17813 1
a17813 2
	  md_number_to_chars ((char *) buf, insn, 4);
	  buf += 4;
d17874 1
a17874 1
	      i = buf - (bfd_byte *)fragp->fr_literal - fragp->fr_fix;
d17884 1
a17884 2
	  md_number_to_chars ((char *) buf, insn, 4);
	  buf += 4;
d17887 1
a17887 2
	  md_number_to_chars ((char *) buf, 0, 4);
	  buf += 4;
d17896 1
a17896 1
	      i = buf - (bfd_byte *)fragp->fr_literal - fragp->fr_fix;
a17902 1

a17903 2
	      md_number_to_chars ((char *) buf, insn, 4);
	      buf += 4;
d17905 2
a17906 2
	      md_number_to_chars ((char *) buf, 0, 4);
	      buf += 4;
d17919 2
a17920 2
	      fixp = fix_new_exp (fragp, buf - (bfd_byte *)fragp->fr_literal,
				  4, &exp, FALSE, BFD_RELOC_MIPS_JMP);
d17924 1
a17924 2
	      md_number_to_chars ((char *) buf, insn, 4);
	      buf += 4;
d17943 2
a17944 2
	      fixp = fix_new_exp (fragp, buf - (bfd_byte *)fragp->fr_literal,
				  4, &exp, FALSE, BFD_RELOC_MIPS_GOT16);
d17948 1
a17948 2
	      md_number_to_chars ((char *) buf, insn, 4);
	      buf += 4;
d17951 2
a17952 5
		{
		  /* nop */
		  md_number_to_chars ((char *) buf, 0, 4);
		  buf += 4;
		}
d17958 2
a17959 2
	      fixp = fix_new_exp (fragp, buf - (bfd_byte *)fragp->fr_literal,
				  4, &exp, FALSE, BFD_RELOC_LO16);
d17963 1
a17963 2
	      md_number_to_chars ((char *) buf, insn, 4);
	      buf += 4;
d17972 1
a17972 2
	      md_number_to_chars ((char *) buf, insn, 4);
	      buf += 4;
a17975 3
      gas_assert (buf == (bfd_byte *)fragp->fr_literal
	      + fragp->fr_fix + fragp->fr_var);

d17977 1
a17977 1

d17984 1
a17984 1
      bfd_byte *buf = (bfd_byte *) (fragp->fr_literal + fragp->fr_fix);
d18006 1
a18006 3
	    fixp = fix_new_exp (fragp,
				buf - (bfd_byte *) fragp->fr_literal,
				2, &exp, TRUE,
d18009 1
a18009 3
	    fixp = fix_new_exp (fragp,
				buf - (bfd_byte *) fragp->fr_literal,
				2, &exp, TRUE,
d18031 2
a18032 2
	  fixp = fix_new_exp (fragp, buf - (bfd_byte *) fragp->fr_literal,
			      4, &exp, TRUE, BFD_RELOC_MICROMIPS_16_PCREL_S1);
d18043 1
a18043 4
	  if (target_big_endian)
	    insn = bfd_getb16 (buf);
	  else
	    insn = bfd_getl16 (buf);
d18063 2
a18064 7
	      md_number_to_chars ((char *) buf, insn >> 16, 2);
	      buf += 2;
	      md_number_to_chars ((char *) buf, insn & 0xffff, 2);
	      buf += 2;

	      gas_assert (buf == ((bfd_byte *) fragp->fr_literal
				  + fragp->fr_fix));
d18069 1
a18069 15
	{
	  unsigned long next;

	  if (target_big_endian)
	    {
	      insn = bfd_getb16 (buf);
	      next = bfd_getb16 (buf + 2);
	    }
	  else
	    {
	      insn = bfd_getl16 (buf);
	      next = bfd_getl16 (buf + 2);
	    }
	  insn = (insn << 16) | next;
	}
d18124 2
a18125 2
	  fixp = fix_new (fragp, buf - (bfd_byte *) fragp->fr_literal,
			  4, l, 0, TRUE, BFD_RELOC_MICROMIPS_16_PCREL_S1);
d18130 1
a18130 5
	  md_number_to_chars ((char *) buf, insn >> 16, 2);
	  buf += 2;
	  md_number_to_chars ((char *) buf, insn & 0xffff, 2);
	  buf += 2;

d18132 2
a18133 6
	    {
	      /* nop  */
	      insn = 0x0c00;
	      md_number_to_chars ((char *) buf, insn, 2);
	      buf += 2;
	    }
d18143 2
a18144 2
	  fixp = fix_new_exp (fragp, buf - (bfd_byte *) fragp->fr_literal,
			      4, &exp, FALSE, BFD_RELOC_MICROMIPS_JMP);
d18148 1
a18148 5
	  md_number_to_chars ((char *) buf, insn >> 16, 2);
	  buf += 2;
	  md_number_to_chars ((char *) buf, insn & 0xffff, 2);
	  buf += 2;

d18150 2
a18151 6
	    {
	      /* nop  */
	      insn = 0x0c00;
	      md_number_to_chars ((char *) buf, insn, 2);
	      buf += 2;
	    }
d18169 2
a18170 2
	  fixp = fix_new_exp (fragp, buf - (bfd_byte *) fragp->fr_literal,
			      4, &exp, FALSE, BFD_RELOC_MICROMIPS_GOT16);
d18174 1
a18174 4
	  md_number_to_chars ((char *) buf, insn >> 16, 2);
	  buf += 2;
	  md_number_to_chars ((char *) buf, insn & 0xffff, 2);
	  buf += 2;
d18180 2
a18181 2
	  fixp = fix_new_exp (fragp, buf - (bfd_byte *) fragp->fr_literal,
			      4, &exp, FALSE, BFD_RELOC_MICROMIPS_LO16);
d18185 1
a18185 4
	  md_number_to_chars ((char *) buf, insn >> 16, 2);
	  buf += 2;
	  md_number_to_chars ((char *) buf, insn & 0xffff, 2);
	  buf += 2;
d18191 1
a18191 2
	  md_number_to_chars ((char *) buf, insn & 0xffff, 2);
	  buf += 2;
d18194 1
a18194 1
      gas_assert (buf == (bfd_byte *) fragp->fr_literal + fragp->fr_fix);
d18255 1
a18255 5
      if (target_big_endian)
	insn = bfd_getb16 ((bfd_byte *) buf);
      else
	insn = bfd_getl16 ((bfd_byte *) buf);

d18605 1
a18605 2
	  md_number_to_chars (p, micromips_nop16_insn.insn_opcode, 2);
	  p += 2;
@


1.511
log
@	include/opcode/
	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

	opcodes/
	* micromips-opc.c (micromips_opcodes): Update comment.
	* mips-opc.c (mips_builtin_opcodes): Likewise.  Mark coprocessor
	instructions for IOCT as appropriate.
	* mips-dis.c (print_insn_mips): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	* configure.in: Substitute NO_WMISSING_FIELD_INITIALIZERS with
	the result of a check for the -Wno-missing-field-initializers
	GCC option.
	* Makefile.am (NO_WMISSING_FIELD_INITIALIZERS): New variable.
	(mips-opc.lo): Pass $(NO_WMISSING_FIELD_INITIALIZERS) to
	compilation.
	(mips16-opc.lo): Likewise.
	(micromips-opc.lo): Likewise.
	* aclocal.m4: Regenerate.
	* configure: Regenerate.
	* Makefile.in: Regenerate.

	gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.
@
text
@a147 7
  /* True if this is a mips16 instruction and if we want the extended
     form of INSN_MO.  */
  bfd_boolean use_extend;

  /* The 16-bit extension instruction to use when USE_EXTEND is true.  */
  unsigned short extend;

d149 3
a151 1
     a copy of INSN_MO->match with the operands filled in.  */
d1238 3
d1324 1
a1324 2
  (char *, unsigned int, int, offsetT, bfd_boolean, bfd_boolean, bfd_boolean,
   unsigned long *, bfd_boolean *, unsigned short *);
d1635 8
d1651 1
a1651 1
    return insn->mips16_absolute_jump_p || insn->use_extend ? 4 : 2;
a1663 2
  insn->use_extend = FALSE;
  insn->extend = 0;
d1689 13
d1708 3
a1710 1
  if (!HAVE_CODE_COMPRESSION)
a1711 28
  else if (mips_opts.micromips)
    {
      unsigned int length = insn_length (insn);
      if (length == 2)
	md_number_to_chars (f, insn->insn_opcode, 2);
      else if (length == 4)
	{
	  md_number_to_chars (f, insn->insn_opcode >> 16, 2);
	  f += 2;
	  md_number_to_chars (f, insn->insn_opcode & 0xffff, 2);
	}
      else
	as_bad (_("48-bit microMIPS instructions are not supported"));
    }
  else if (insn->mips16_absolute_jump_p)
    {
      md_number_to_chars (f, insn->insn_opcode >> 16, 2);
      md_number_to_chars (f + 2, insn->insn_opcode & 0xffff, 2);
    }
  else
    {
      if (insn->use_extend)
	{
	  md_number_to_chars (f, 0xf000 | insn->extend, 2);
	  f += 2;
	}
      md_number_to_chars (f, insn->insn_opcode, 2);
    }
d4267 1
a4267 3
  else if (mips_opts.mips16
	   && ! ip->use_extend
	   && *reloc_type != BFD_RELOC_MIPS16_JMP)
d5182 2
a5183 3
		mips16_immed (NULL, 0, c, ep->X_add_number, FALSE, FALSE,
			      FALSE, &insn.insn_opcode, &insn.use_extend,
			      &insn.extend);
d13360 1
a13360 3
				    tmp, TRUE, forced_insn_length == 2,
				    forced_insn_length == 4, &ip->insn_opcode,
				    &ip->use_extend, &ip->extend);
d13540 1
a13540 2
		      ip->use_extend = TRUE;
		      ip->extend = 0;
d13694 1
a13694 1
		int opcode = 0;
d13848 2
a13849 5
		  {
		    ip->use_extend = TRUE;
		    ip->extend = opcode >> 16;
		  }
		ip->insn_opcode |= opcode & 0x7f;
d13944 6
a13949 7
/* Handle a mips16 instruction with an immediate value.  This or's the
   small immediate value into *INSN.  It sets *USE_EXTEND to indicate
   whether an extended value is needed; if one is needed, it sets
   *EXTEND to the value.  The argument type is TYPE.  The value is VAL.
   If SMALL is true, an unextended opcode was explicitly requested.
   If EXT is true, an extended opcode was explicitly requested.  If
   WARN is true, warn if EXT does not match reality.  */
d13953 1
a13953 3
	      bfd_boolean warn, bfd_boolean small, bfd_boolean ext,
	      unsigned long *insn, bfd_boolean *use_extend,
	      unsigned short *extend)
a13956 1
  bfd_boolean needext;
d13991 15
a14005 3
    needext = TRUE;
  else
    needext = FALSE;
d14007 1
a14007 7
  if (warn && ext && ! needext)
    as_warn_where (file, line,
		   _("extended operand requested but not required"));
  if (small && needext)
    as_bad_where (file, line, _("invalid unextended operand value"));

  if (small || (! ext && ! needext))
a14010 1
      *use_extend = FALSE;
a14033 1
      *use_extend = TRUE;
d14050 1
a14050 2
      *extend = (unsigned short) extval;
      *insn |= val;
a18232 1
      bfd_boolean small, ext;
d18234 2
a18235 1
      bfd_byte *buf;
d18237 1
a18237 2
      bfd_boolean use_extend;
      unsigned short extend;
d18244 1
a18244 11
      if (RELAX_MIPS16_EXTENDED (fragp->fr_subtype))
	{
	  small = FALSE;
	  ext = TRUE;
	}
      else
	{
	  small = TRUE;
	  ext = FALSE;
	}

d18284 1
a18284 1
      buf = (bfd_byte *) (fragp->fr_literal + fragp->fr_fix);
d18287 1
a18287 1
	insn = bfd_getb16 (buf);
d18289 11
a18299 1
	insn = bfd_getl16 (buf);
d18302 1
a18302 9
		    RELAX_MIPS16_USER_EXT (fragp->fr_subtype),
		    small, ext, &insn, &use_extend, &extend);

      if (use_extend)
	{
	  md_number_to_chars ((char *) buf, 0xf000 | extend, 2);
	  fragp->fr_fix += 2;
	  buf += 2;
	}
d18304 4
a18307 3
      md_number_to_chars ((char *) buf, insn, 2);
      fragp->fr_fix += 2;
      buf += 2;
@


1.510
log
@	* config/tc-mips.c (s_cpload, s_cpsetup): Fail if MIPS16 mode.
	(s_cplocal, s_cprestore, s_cpreturn): Likewise.
@
text
@a507 5
/* True if CPU does not implement the all the coprocessor insns.  For these
   CPUs only those COP insns are accepted that are explicitly marked to be
   available on the CPU.  ISA membership for COP insns is ignored.  */
#define NO_ISA_COP(CPU)		(CPU_IS_OCTEON (CPU))

a577 9
/* Returns true for a (non floating-point) coprocessor instruction.  Reading
   or writing the condition code is only possible on the coprocessors and
   these insns are not marked with INSN_COP.  Thus for these insns use the
   condition-code flags.  */
#define COP_INSN(PINFO)							\
  (PINFO != INSN_MACRO							\
   && ((PINFO) & (FP_S | FP_D)) == 0					\
   && ((PINFO) & (INSN_COP | INSN_READ_COND_CODE | INSN_WRITE_COND_CODE)))

d2210 1
a2210 7
  /* Don't accept instructions based on the ISA if the CPU does not implement
     all the coprocessor insns. */
  if (NO_ISA_COP (mips_opts.arch)
      && COP_INSN (mo->pinfo))
    isa = 0;

  if (!OPCODE_IS_MEMBER (mo, isa, mips_opts.arch))
d2242 1
a2242 1
  return OPCODE_IS_MEMBER (mo, mips_opts.isa, mips_opts.arch) ? TRUE : FALSE;
a8247 9
      if (coproc
	  && NO_ISA_COP (mips_opts.arch)
	  && (ip->insn_mo->pinfo2 & (INSN2_M_FP_S | INSN2_M_FP_D)) == 0)
	{
	  as_bad (_("Opcode not supported on this processor: %s"),
		  mips_cpu_info_from_arch (mips_opts.arch)->name);
	  break;
	}

a9172 8
      if (NO_ISA_COP (mips_opts.arch)
	  && (ip->insn_mo->pinfo2 & INSN2_M_FP_S) == 0)
	{
	  as_bad (_("Opcode not supported on this processor: %s"),
		  mips_cpu_info_from_arch (mips_opts.arch)->name);
	  break;
	}

@


1.509
log
@	gas/
	* config/tc-mips.c (append_insn): Also handle moving delay-slot
	instruction across frags for fixed branches.

	gas/testsuite/
	* gas/mips/branch-swap-2.l: New list test.
	* gas/mips/branch-swap-2.s: New test source.
	* gas/mips/mips.exp: Run the new test.
@
text
@d16442 7
d16515 7
d16614 7
d16642 7
d16685 7
@


1.508
log
@2012-08-01  Catherine Moore  <clm@@codesourcery.com>
	    Sandra Loosemore  <sandra@@codesourcery.com>

	gas/
	* config/mips/tc-mips.c (mips_cpu_info):  Add the 34kn.
	* doc/c-mips.texi (MIPS Opts): Document it.
@
text
@d4491 1
a4491 1
	else if (relaxed_branch)
@


1.507
log
@	include/opcode/
	* mips.h: Document microMIPS DSP ASE usage.
	(MICROMIPSOP_MASK_DSPACC, MICROMIPSOP_SH_DSPACC): Update for
	microMIPS DSP ASE support.
	(MICROMIPSOP_MASK_DSPSFT, MICROMIPSOP_SH_DSPSFT): Likewise.
	(MICROMIPSOP_MASK_SA3, MICROMIPSOP_SH_SA3): Likewise.
	(MICROMIPSOP_MASK_SA4, MICROMIPSOP_SH_SA4): Likewise.
	(MICROMIPSOP_MASK_IMM8, MICROMIPSOP_SH_IMM8): Likewise.
	(MICROMIPSOP_MASK_IMM10, MICROMIPSOP_SH_IMM10): Likewise.
	(MICROMIPSOP_MASK_WRDSP, MICROMIPSOP_SH_WRDSP): Likewise.
	(MICROMIPSOP_MASK_BP, MICROMIPSOP_SH_BP): Likewise.

	gas/
	* config/tc-mips.c (macro_build) <'2'>: Handle microMIPS.
	(macro) <M_BALIGN>: Update error handling.
	(validate_micromips_insn) <'2', '3', '4', '5', '6'>: New cases.
	<'7', '8', '0', '@@', '^'>: Likewise.
	(mips_ip) <'2', '3', '4', '5', '6', '7', '8'>: Handle microMIPS.
	<'9'>: Fix formatting.
	<'0', '@@'>: Handle microMIPS.
	<'^'>: New case.

	gas/testsuite/
	* gas/mips/micromips@@mips32-dsp.d: New.
	* gas/mips/micromips@@mips32-dspr2.d: New.
	* gas/mips/mips32-dsp.d: Remove -mips32r2.
	* gas/mips/mips32-dspr2.d: Likewise.
	* gas/mips/mips.exp: (mips_create_arch): Use -mips64r2
	for micromips.  Use run_dump_test_arches to run dsp tests.

	opcodes/
	* micromips-opc.c (WR_a, RD_a, MOD_a): New macros.
	(DSP_VOLA): Likewise.
	(D32, D33): Likewise.
	(micromips_opcodes): Add DSP ASE instructions.
	* micromips-dis.c (print_insn_micromips) <'2', '3'>: New cases.
	<'4', '5', '6', '7', '8', '0', '^', '@@'>: Likewise.
@
text
@d19133 2
@


1.506
log
@gas: mips: fix segfault with invalid default cpu strings

If you configure gas for a mips32el-* target, the default cpu calculation
gets mangled, and we end up passing and invalid value as the default cpu.

If you try executing gas after that, it segfaults.  This is because it
assumes that the default cpu value is always valid.
$ ./gas/as-new
Assembler messages:
Error: Bad value (2) for default CPU
Segmentation fault (core dumped)

I'm not debating that the target tuple is valid, just that gas shouldn't
crash.  So add a friendly assert to avoid that.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d354 2
a355 1
			      || mips_opts.isa == ISA_MIPS64R2)
d364 2
a365 1
			        || mips_opts.isa == ISA_MIPS64R2)
d4903 1
a4903 2
	  gas_assert (!mips_opts.micromips);
	  INSERT_OPERAND (0, BP, insn, va_arg (args, int));
d6418 2
a6419 1
	default:
d6423 4
d10495 8
d10505 1
d10520 1
d10792 3
a10794 2
	    case '2': /* DSP 2-bit unsigned immediate in bit 11.  */
	      gas_assert (!mips_opts.micromips);
d10803 2
a10804 1
	      INSERT_OPERAND (0, BP, *ip, imm_expr.X_add_number);
d10809 17
a10825 12
	    case '3': /* DSP 3-bit unsigned immediate in bit 21.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~OP_MASK_SA3)
		{
		  as_bad (_("DSP immediate not in range 0..%d (%lu)"),
			  OP_MASK_SA3, (unsigned long) imm_expr.X_add_number);
		}
	      INSERT_OPERAND (0, SA3, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d10828 17
a10844 12
	    case '4': /* DSP 4-bit unsigned immediate in bit 21.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~OP_MASK_SA4)
		{
		  as_bad (_("DSP immediate not in range 0..%d (%lu)"),
			  OP_MASK_SA4, (unsigned long) imm_expr.X_add_number);
		}
	      INSERT_OPERAND (0, SA4, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d10847 17
a10863 12
	    case '5': /* DSP 8-bit unsigned immediate in bit 16.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~OP_MASK_IMM8)
		{
		  as_bad (_("DSP immediate not in range 0..%d (%lu)"),
			  OP_MASK_IMM8, (unsigned long) imm_expr.X_add_number);
		}
	      INSERT_OPERAND (0, IMM8, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d10866 17
a10882 12
	    case '6': /* DSP 5-bit unsigned immediate in bit 21.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~OP_MASK_RS)
		{
		  as_bad (_("DSP immediate not in range 0..%d (%lu)"),
			  OP_MASK_RS, (unsigned long) imm_expr.X_add_number);
		}
	      INSERT_OPERAND (0, RS, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d10886 2
a10887 3
	      gas_assert (!mips_opts.micromips);
	      if (s[0] == '$' && s[1] == 'a' && s[2] == 'c' &&
		  s[3] >= '0' && s[3] <= '3')
d10891 1
a10891 1
		  INSERT_OPERAND (0, DSPACC, *ip, regno);
d10898 18
a10915 13
	    case '8': /* DSP 6-bit unsigned immediate in bit 11.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~OP_MASK_WRDSP)
		{
		  as_bad (_("DSP immediate not in range 0..%d (%lu)"),
			  OP_MASK_WRDSP,
			  (unsigned long) imm_expr.X_add_number);
		}
	      INSERT_OPERAND (0, WRDSP, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d10920 2
a10921 2
	      if (s[0] == '$' && s[1] == 'a' && s[2] == 'c' &&
		  s[3] >= '0' && s[3] <= '3')
d10932 13
a10944 9
	    case '0': /* DSP 6-bit signed immediate in bit 20.  */
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      min_range = -((OP_MASK_DSPSFT + 1) >> 1);
	      max_range = ((OP_MASK_DSPSFT + 1) >> 1) - 1;
	      if (imm_expr.X_add_number < min_range ||
		  imm_expr.X_add_number > max_range)
		{
d10948 5
a10952 4
		}
	      INSERT_OPERAND (0, DSPSFT, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d10989 10
a10998 8
	      gas_assert (!mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      min_range = -((OP_MASK_IMM10 + 1) >> 1);
	      max_range = ((OP_MASK_IMM10 + 1) >> 1) - 1;
	      if (imm_expr.X_add_number < min_range ||
		  imm_expr.X_add_number > max_range)
		{
d11002 16
a11017 2
		}
	      INSERT_OPERAND (0, IMM10, *ip, imm_expr.X_add_number);
@


1.506.2.1
log
@gas/
	* config/tc-mips.c (ISA_SUPPORTS_DSP_ASE): Also set if microMIPS
	mode.
	(ISA_SUPPORTS_DSPR2_ASE): Likewise.
	(macro_build) <'2'>: Handle microMIPS.
2012-07-31  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>

gas/
	* gas/mips/micromips@@mips32-dsp.d: New test.
	* gas/mips/micromips@@mips32-dspr2.d: New test.
	* gas/mips/mips32-dsp.s: Update padding.
	* gas/mips/mips32-dspr2.s: Likewise.
	* gas/mips/mips.exp: Use run_dump_test_arches to run MIPS32 DSP
	tests.
2012-07-31  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

include/
2012-07-31  Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

opcodes/
2012-08-01  Alan Modra  <amodra@@gmail.com>

	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d354 1
a354 2
			      || mips_opts.isa == ISA_MIPS64R2		\
			      || mips_opts.micromips)
d363 1
a363 2
			        || mips_opts.isa == ISA_MIPS64R2	\
				|| mips_opts.micromips)
d4901 2
a4902 1
	  INSERT_OPERAND (mips_opts.micromips, BP, insn, va_arg (args, int));
d6417 1
a6417 2
	case 1:
	case 3:
a6420 4
	default:
	  as_bad (_("BALIGN immediate not 0, 1, 2 or 3 (%lu)"),
		  (unsigned long) imm_expr.X_add_number);
	  break;
a10488 8
      case '2': USE_BITS (BP);		break;
      case '3': USE_BITS (SA3);		break;
      case '4': USE_BITS (SA4);		break;
      case '5': USE_BITS (IMM8);	break;
      case '6': USE_BITS (RS);		break;
      case '7': USE_BITS (DSPACC);	break;
      case '8': USE_BITS (WRDSP);	break;
      case '0': USE_BITS (DSPSFT);	break;
a10490 1
      case '@@': USE_BITS (IMM10);	break;
a10504 1
      case '^': USE_BITS (RD);		break;
d10776 2
a10777 3
	    case '2':
	      /* DSP 2-bit unsigned immediate in bit 11 (for standard MIPS
	         code) or 14 (for microMIPS code).  */
d10786 1
a10786 2
	      INSERT_OPERAND (mips_opts.micromips,
			      BP, *ip, imm_expr.X_add_number);
d10791 12
a10802 17
	    case '3':
	      /* DSP 3-bit unsigned immediate in bit 13 (for standard MIPS
	         code) or 21 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_SA3 : OP_MASK_SA3);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				SA3, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
d10805 12
a10816 17
	    case '4':
	      /* DSP 4-bit unsigned immediate in bit 12 (for standard MIPS
	         code) or 21 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_SA4 : OP_MASK_SA4);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				SA4, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
d10819 12
a10830 17
	    case '5':
	      /* DSP 8-bit unsigned immediate in bit 13 (for standard MIPS
	         code) or 16 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_IMM8 : OP_MASK_IMM8);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				IMM8, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
d10833 12
a10844 17
	    case '6':
	      /* DSP 5-bit unsigned immediate in bit 16 (for standard MIPS
	         code) or 21 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_RS : OP_MASK_RS);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				RS, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
d10848 3
a10850 2
	      if (s[0] == '$' && s[1] == 'a' && s[2] == 'c'
		  && s[3] >= '0' && s[3] <= '3')
d10854 1
a10854 1
		  INSERT_OPERAND (mips_opts.micromips, DSPACC, *ip, regno);
d10861 13
a10873 18
	    case '8':
	      /* DSP 6-bit unsigned immediate in bit 11 (for standard MIPS
	         code) or 14 (for microMIPS code).  */
	      {
		unsigned long mask = (mips_opts.micromips
				      ? MICROMIPSOP_MASK_WRDSP
				      : OP_MASK_WRDSP);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		if ((unsigned long) imm_expr.X_add_number > mask)
		  as_bad (_("DSP immediate not in range 0..%lu (%lu)"),
			  mask, (unsigned long) imm_expr.X_add_number);
		INSERT_OPERAND (mips_opts.micromips,
				WRDSP, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
d10878 2
a10879 2
	      if (s[0] == '$' && s[1] == 'a' && s[2] == 'c'
		  && s[3] >= '0' && s[3] <= '3')
d10890 9
a10898 13
	    case '0':
	      /* DSP 6-bit signed immediate in bit 16 (for standard MIPS
	         code) or 20 (for microMIPS code).  */
	      {
		long mask = (mips_opts.micromips
			     ? MICROMIPSOP_MASK_DSPSFT : OP_MASK_DSPSFT);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		min_range = -((mask + 1) >> 1);
		max_range = ((mask + 1) >> 1) - 1;
		if (imm_expr.X_add_number < min_range
		    || imm_expr.X_add_number > max_range)
d10902 4
a10905 5
		INSERT_OPERAND (mips_opts.micromips,
				DSPSFT, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
d10942 8
a10949 10
	      {
		long mask = (mips_opts.micromips
			     ? MICROMIPSOP_MASK_IMM10 : OP_MASK_IMM10);

		my_getExpression (&imm_expr, s);
		check_absolute_expr (ip, &imm_expr);
		min_range = -((mask + 1) >> 1);
		max_range = ((mask + 1) >> 1) - 1;
		if (imm_expr.X_add_number < min_range
		    || imm_expr.X_add_number > max_range)
d10953 2
a10954 16
		INSERT_OPERAND (mips_opts.micromips,
				IMM10, *ip, imm_expr.X_add_number);
		imm_expr.X_op = O_absent;
		s = expr_end;
	      }
	      continue;

	    case '^': /* DSP 5-bit unsigned immediate in bit 11.  */
	      gas_assert (mips_opts.micromips);
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if (imm_expr.X_add_number & ~MICROMIPSOP_MASK_RD)
		as_bad (_("DSP immediate not in range 0..%d (%lu)"),
			MICROMIPSOP_MASK_RD,
			(unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (1, RD, *ip, imm_expr.X_add_number);
@


1.506.2.2
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d508 5
d583 9
d2224 7
a2230 1
  if (!opcode_is_member (mo, isa, mips_opts.arch))
d2262 1
a2262 1
  return opcode_is_member (mo, mips_opts.isa, mips_opts.arch);
d4491 1
a4491 1
	else if (relaxed_branch || delay.frag != ip->frag)
d8268 9
d9202 8
a16441 7
  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cpload");
      ignore_rest_of_line ();
      return;
    }

a16507 7
  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cpsetup");
      ignore_rest_of_line ();
      return;
    }

a16599 7
  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cplocal");
      ignore_rest_of_line ();
      return;
    }

a16620 7
  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cprestore");
      ignore_rest_of_line ();
      return;
    }

a16656 7
  if (mips_opts.mips16)
    {
      as_bad (_("%s not supported in MIPS16 mode"), ".cpreturn");
      ignore_rest_of_line ();
      return;
    }

@


1.505
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d15008 4
a15011 1
    arch_info = mips_parse_cpu ("default CPU", MIPS_CPU_STRING_DEFAULT);
@


1.504
log
@	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add entry for Broadcom XLP.
	* doc/c-mips.texi: Mention XLP.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add entry for Broadcom XLP.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d17012 2
a17013 2
  return (symsec != &bfd_und_section
	  && symsec != &bfd_abs_section
@


1.503
log
@gas/
	* config/tc-mips.c (s_tls_rel_directive): Call mips_clear_insn_labels.

gas/testsuite/
	* gas/mips/tls-relw.s, gas/mips/tls-relw.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d19118 5
@


1.502
log
@gas/
2011-01-08  Andrew Pinski  <andrew.pinski@@caviumnetworks.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.c (mips_move_labels): Take the list of labels and
	textness as parameters.
	(mips_move_text_labels): New function.
	(append_insn): Use it instead of mips_move_labels.
	(mips_emit_delays, start_noreorder): Likewise.
	(mips_align): Take the labels rather than just one label.
	Move all labels to after the .align.
	(s_align): Change the last argument to mips_align.
	(s_cons): Likewise.
	(s_float_cons): Likewise.
	(s_gpword): Likewise.
	(s_gpdword): Likewise.

gas/testsuite/
	* gas/mips/align3.s, gas/mips/align3.d: New testcase.
	* gas/mips/mips.exp: Run it.
@
text
@d16633 1
@


1.501
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	gas/
	* config/tc-mips.c (mips_pseudo_table): Add tprelword/tpreldword
	entries.
	(mips16_percent_op): Add MIPS16 TLS relocation ops.
	(md_apply_fix): Add BFD_RELOC_MIPS16_TLS_* switch cases.
	(s_tls_rel_directive): Rename from s_dtprel_internal(). Abstract out
	directive string and reloc type as function parameters. Update
	comments.
	(s_dtprelword,s_dtpreldword): Change to use s_tls_rel_directive().
	(s_tprelword,s_tpreldword): New functions.

	include/
	* elf/mips.h (elf_mips_reloc_type): Add R_MIPS16_TLS_* entries.

	bfd/
	* reloc.c (BFD_RELOC_MIPS16_TLS_GD,BFD_RELOC_MIPS16_TLS_LDM,
	BFD_RELOC_MIPS16_TLS_DTPREL_HI16,BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
	BFD_RELOC_MIPS16_TLS_GOTTPREL,BFD_RELOC_MIPS16_TLS_TPREL_HI16,
	BFD_RELOC_MIPS16_TLS_TPREL_LO16): New relocations for MIPS16 TLS.
	* bfd-in2.h (bfd_reloc_code_real): Regenerate.
	* libbfd.h (bfd_reloc_code_real_names): Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Add R_MIPS16_TLS_*
	entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel,
	elf_mips16_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel,
	mips16_elf64_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfxx-mips.c (TLS_RELOC_P,mips16_reloc_p,
	_bfd_mips_elf_check_relocs): Add cases for R_MIPS16_TLS_* relocations.
	(tls_gd_reloc_p): Add R_MIPS16_TLS_GD case.
	(tls_ldm_reloc_p): Add R_MIPS16_TLS_LDM case.
	(tls_gottprel_reloc_p): Add R_MIPS16_TLS_GOTTPREL case.
	(mips_elf_calculate_relocation): Add cases for R_MIPS16_TLS_*,
	R_MIPS_TLS_DTPREL32/64, and R_MIPS_TLS_TPREL32/64 relocations.
@
text
@d2764 2
a2765 1
/* Move all labels in insn_labels to the current insertion point.  */
d2768 1
a2768 1
mips_move_labels (void)
a2769 1
  segment_info_type *si = seg_info (now_seg);
d2773 1
a2773 1
  for (l = si->label_list; l != NULL; l = l->next)
d2779 1
a2779 1
      if (HAVE_CODE_COMPRESSION)
d2785 9
d4161 1
a4161 1
	  mips_move_labels ();
d4553 1
a4553 1
	  mips_move_labels ();
d4597 1
a4597 1
	  mips_move_labels ();
d15661 9
a15669 2
   The MIPS assembler also automatically adjusts any preceding
   label.  */
d15672 1
a15672 1
mips_align (int to, int *fill, symbolS *label)
d15681 1
a15681 6
  if (label != NULL)
    {
      gas_assert (S_GET_SEGMENT (label) == now_seg);
      symbol_set_frag (label, frag_now);
      S_SET_VALUE (label, (valueT) frag_now_fix ());
    }
d15723 1
a15723 1
      mips_align (temp, fill_ptr, l != NULL ? l->label : NULL);
a15892 1
  symbolS *label;
a15893 1
  label = l != NULL ? l->label : NULL;
d15896 1
a15896 1
    mips_align (log_size, 0, label);
a15905 3
  symbolS *label;

  label = l != NULL ? l->label : NULL;
d15912 1
a15912 1
	mips_align (3, 0, label);
d15914 1
a15914 1
	mips_align (2, 0, label);
a16693 1
  symbolS *label;
a16705 1
  label = l != NULL ? l->label : NULL;
d16708 1
a16708 1
    mips_align (2, 0, label);
a16731 1
  symbolS *label;
a16743 1
  label = l != NULL ? l->label : NULL;
d16746 1
a16746 1
    mips_align (3, 0, label);
@


1.500
log
@bfd:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

	* archures.c (bfd_mach_mips_octeon2): New macro
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_mipsocteon2): New enum value.
	(arch_info_struct): Add bfd_mach_mips_octeon2.
	* elfxx-mips.c (_bfd_elf_mips_mach): Support E_MIPS_MACH_OCTEON2.
	(mips_set_isa_flags): Add bfd_mach_mips_octeon2.
	(mips_mach_extensions): Add bfd_mach_mips_octeon2.

gas:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

        * tc-mips.c (CPU_IS_OCTEON): Add Octeon2.
        (mips_cpu_info_table): Add Octeon2.
        * doc/c-mips.texi: Document octeon2 as an acceptable value for -march=.

gas/testsuite:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

        * gas/mips/mips.exp: Add Octeon2 for an architecture.
        Run octeon2 test.
        * gas/mips/octeon2.d: New file.
        * gas/mips/octeon2.s: New file.

include/opcode:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

        * mips.h (INSN_CHIP_MASK): Update according to INSN_OCTEON2.
        (INSN_OCTEON2): New macro.
        (CPU_OCTEON2): New macro.
        (OPCODE_IS_MEMBER): Add Octeon2.

opcodes:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

	* mips-dis.c (mips_arch_choices): Add Octeon2.
	For "octeon+", just include OcteonP for the insn.
	* mips-opc.c (IOCT): Include Octeon2.
	(IOCTP): Include Octeon2.
	(IOCT2): New macro.
	(mips_builtin_opcodes): Add "laa", "laad", "lac", "lacd", "lad",
	"ladd", "lai", "laid", "las", "lasd", "law", "lawd".
	Move "lbux", "ldx", "lhx", "lwx", and "lwux" up to where the standard
	loads are, and add IOCT2 to them.
	Add "lbx" and "lhux".
	Add "qmac.00", "qmac.01", "qmac.02", "qmac.03", "qmacs.00",
	"qmacs.01", "qmacs.01", "qmacs.02" and "qmacs.03".
	Add "zcb" and "zcbt".
@
text
@d1359 2
d1440 2
d14080 8
a14087 1
  {"%hi", BFD_RELOC_MIPS16_HI16_S}
d15416 2
d15427 7
d16603 4
a16606 3
/* Handle the .dtprelword and .dtpreldword pseudo-ops.  They generate
   a 32-bit or 64-bit DTP-relative relocation (BYTES says which) for
   use in DWARF debug information.  */
d16609 2
a16610 1
s_dtprel_internal (size_t bytes)
d16619 1
a16619 3
      as_bad (_("Unsupported use of %s"), (bytes == 8
					   ? ".dtpreldword"
					   : ".dtprelword"));
d16625 1
a16625 5
  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE,
	       (bytes == 8
		? BFD_RELOC_MIPS_TLS_DTPREL64
		: BFD_RELOC_MIPS_TLS_DTPREL32));

d16634 1
a16634 1
  s_dtprel_internal (4);
d16642 17
a16658 1
  s_dtprel_internal (8);
@


1.499
log
@opcode/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * mips-dis.c (mips_arch_choices): Add Octeon+.
        * mips-opc.c (IOCT): Include Octeon+.
        (IOCTP): New macro.
        (mips_builtin_opcodes): Add "saa" and "saad".
bfd/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * archures.c (bfd_mach_mips_octeonp): New macro.
        * bfd-in2.h: Regenerate.
        * bfd/cpu-mips.c (I_mipsocteonp): New enum value.
        (arch_info_struct): Add bfd_mach_mips_octeonp.
        * elfxx-mips.c (mips_set_isa_flags): Add bfd_mach_mips_octeonp.
        (mips_mach_extensions): Add bfd_mach_mips_octeonp.
include/opcodes/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * mips.h (INSN_CHIP_MASK): Update according to INSN_OCTEONP.
        (INSN_OCTEONP): New macro.
        (CPU_OCTEONP): New macro.
        (OPCODE_IS_MEMBER): Add Octeon+.
        (M_SAA_AB, M_SAAD_AB, M_SAA_OB, M_SAAD_OB): New enum values.
gas/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * config/tc-mips.c (CPU_IS_OCTEON): New macro function.
        (CPU_HAS_SEQ): Change to use CPU_IS_OCTEON.
        (NO_ISA_COP): Likewise.
        (macro) <ld_st>: Add support when off0 is true.
        Add support for M_SAA_AB, M_SAA_OB, M_SAAD_OB and M_SAAD_AB.
        (mips_cpu_info_table): Add octeon+.
        * doc/c-mips.texi: Document octeon+ as an acceptable value for -march=.
gas/testsuite/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * gas/mips/mips.exp: Add octeon+ for an architecture.
        Run octeon-saa-saad test.
        (run_dump_test_arch): For Octeon architectures, also try octeon@@.
        * gas/mips/octeon-pref.d: Remove -march=octeon from command line.
        * gas/mips/octeon.d: Likewise.
        * gas/mips/octeon-saa-saad.d: New file.
        * gas/mips/octeon-saa-saad.s: New file
@
text
@d501 1
a501 1
#define CPU_IS_OCTEON(CPU) ((CPU) == CPU_OCTEON || (CPU) == CPU_OCTEONP)
d19078 1
@


1.498
log
@	gas/
	* config/tc-mips.c (macro): Fix unsupported opcode message
	capitalization.
	(mips_ip, mips16_ip): Likewise.

	gas/testsuite/
	* gas/mips/mips-double-float-flag.l: Adjust according to
	unsupported opcode message capitalization fix.
	* gas/mips/mips-hard-float-flag.l: Likewise.
	* gas/mips/mips-macro-ill-nofp.l: Likewise.
	* gas/mips/mips-macro-ill-sfp.l: Likewise.
	* gas/mips/mips1-fp.l: Likewise.
	* gas/mips/mips16e-64.l: Likewise.
	* gas/mips/mips32-sf32.l: Likewise.
	* gas/mips/mips32r2-fp32.l: Likewise.
	* gas/mips/mips4-branch-likely.l: Likewise.
	* gas/mips/mips4-fp.l: Likewise.
	* gas/mips/octeon-ill.l: Likewise.
@
text
@d500 3
d504 1
a504 1
#define CPU_HAS_SEQ(CPU)	((CPU) == CPU_OCTEON)
d509 1
a509 1
#define NO_ISA_COP(CPU)		((CPU) == CPU_OCTEON)
d6267 1
d8302 10
a8311 1
	  if (!off12)
d8317 1
a8317 1
      else if (off12)
d8319 6
a8324 6
	  /* A 12-bit offset field is too narrow to be used for a low-part
	     relocation, so load the whole address into the auxillary
	     register.  In the case of "A(b)" addresses, we first load
	     absolute address "A" into the register and then add base
	     register "b".  In the case of "o(b)" addresses, we simply
	     need to add 16-bit offset "o" to base register "b", and
d8339 5
a8343 2
	  macro_build (NULL, s, fmt,
		       treg, (unsigned long) expr1.X_add_number, tempreg);
d9137 16
d19077 1
@


1.497
log
@	* config/tc-mips.c (ISA_SUPPORTS_MCU_ASE): Also set if microMIPS
	mode.
@
text
@d9154 1
a9154 1
	  as_bad (_("opcode not supported on this processor: %s"),
d10703 1
a10703 1
	    sprintf (buf, _("opcode not supported on this processor: %s (%s)"),
d13232 1
a13232 1
			   _("opcode not supported on this processor: %s (%s)"),
@


1.496
log
@	* config/tc-mips.c (macro_build_jalr): Reverse a negative
	conditional.
	(mips_ip): Likewise.
@
text
@d373 2
a374 1
			      || mips_opts.isa == ISA_MIPS64R2)
@


1.495
log
@	* config/tc-mips.c (mips_cpu_info_table): Add "m14ke" and
	"m14kec".
	* doc/c-mips.texi (MIPS architecture options): Add "m14ke" and
	"m14kec" to the list of -march options.
@
text
@d5263 1
a5263 3
  if (!mips_opts.micromips)
    macro_build (NULL, "jalr", "d,s", RA, PIC_CALL_REG);
  else
d5271 2
d10967 3
a10969 3
		unsigned long mask = (!mips_opts.micromips
				      ? OP_MASK_3BITPOS
				      : MICROMIPSOP_MASK_3BITPOS);
@


1.494
log
@	gas/
	* config/tc-mips.c (can_swap_branch_p): Exclude microMIPS
	variant frags too.

	gas/testsuite/
	* gas/mips/relax-swap3.d: New test.
	* gas/mips/mips16@@relax-swap3.d: Likewise.
	* gas/mips/micromips@@relax-swap3.d: Likewise.
	* gas/mips/relax-swap3.s: New test source.
	* gas/mips/mips.exp: Run the new tests.
@
text
@d18966 4
@


1.493
log
@	* config/tc-mips.c (move_register): Fix formatting.
@
text
@d3731 2
a3732 3
     MIPS16/microMIPS code, which uses variant frags for different
     purposes.  */
  if (!HAVE_CODE_COMPRESSION
@


1.492
log
@	* config/tc-mips.c (can_swap_branch_p): Remove empty line.
	(start_noreorder): Likewise.
@
text
@d5948 1
a5948 1
    macro_build (NULL, "move", "mp,mj", dest, source );
@


1.491
log
@	* config/tc-mips.c (s_option): Fix formatting.
	(mips_elf_final_processing): Likewise.
@
text
@a3689 1

a4594 1

@


1.490
log
@	* config/tc-mips.c (validate_micromips_insn): Fix formatting.
@
text
@d15948 1
a15948 1
	mips_pic = SVR4_PIC;
d18403 1
a18403 1
    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_PIC;
@


1.489
log
@	* config/tc-mips.c (micromips_add_label): Avoid gcc warning.
	(md_convert_frag): Likewise.
@
text
@d10453 1
a10453 1
      case 'H': USE_BITS (SEL);	break;
@


1.488
log
@	* config/tc-mips.c (can_swap_branch_p): Update the comment on
	MIPS16 fixups.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d3923 2
d18233 1
a18233 1
	    as_warn_where (fragp->fr_file, fragp->fr_line, msg);
d18247 1
a18247 1
	    as_warn_where (fragp->fr_file, fragp->fr_line, msg);
@


1.488.2.1
log
@	gas/
	Apply mainline patches
	2011-11-14  Maciej W. Rozycki  <macro@@codesourcery.com>
	* config/tc-mips.c (can_swap_branch_p): Exclude microMIPS
	variant frags too.

	gas/testsuite/
	Apply mainline patches
	2011-11-14  Maciej W. Rozycki  <macro@@codesourcery.com>
	* gas/mips/relax-swap3.d: New test.
	* gas/mips/mips16@@relax-swap3.d: Likewise.
	* gas/mips/micromips@@relax-swap3.d: Likewise.
	* gas/mips/relax-swap3.s: New test source.
	* gas/mips/mips.exp: Run the new tests.
@
text
@d3732 3
a3734 2
     MIPS16 code, which uses variant frags for different purposes.  */
  if (!mips_opts.mips16
@


1.488.2.2
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	Backport from mainline:

	2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	gas/
	* config/tc-mips.c (mips_pseudo_table): Add tprelword/tpreldword
	entries.
	(mips16_percent_op): Add MIPS16 TLS relocation ops.
	(md_apply_fix): Add BFD_RELOC_MIPS16_TLS_* switch cases.
	(s_tls_rel_directive): Rename from s_dtprel_internal(). Abstract out
	directive string and reloc type as function parameters. Update
	comments.
	(s_dtprelword,s_dtpreldword): Change to use s_tls_rel_directive().
	(s_tprelword,s_tpreldword): New functions.

	include/
	* elf/mips.h (elf_mips_reloc_type): Add R_MIPS16_TLS_* entries.

	bfd/
	* reloc.c (BFD_RELOC_MIPS16_TLS_GD,BFD_RELOC_MIPS16_TLS_LDM,
	BFD_RELOC_MIPS16_TLS_DTPREL_HI16,BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
	BFD_RELOC_MIPS16_TLS_GOTTPREL,BFD_RELOC_MIPS16_TLS_TPREL_HI16,
	BFD_RELOC_MIPS16_TLS_TPREL_LO16): New relocations for MIPS16 TLS.
	* bfd-in2.h (bfd_reloc_code_real): Regenerate.
	* libbfd.h (bfd_reloc_code_real_names): Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Add R_MIPS16_TLS_*
	entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel,
	elf_mips16_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel,
	mips16_elf64_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfxx-mips.c (TLS_RELOC_P,mips16_reloc_p,
	_bfd_mips_elf_check_relocs): Add cases for R_MIPS16_TLS_* relocations.
	(tls_gd_reloc_p): Add R_MIPS16_TLS_GD case.
	(tls_ldm_reloc_p): Add R_MIPS16_TLS_LDM case.
	(tls_gottprel_reloc_p): Add R_MIPS16_TLS_GOTTPREL case.
	(mips_elf_calculate_relocation): Add cases for R_MIPS16_TLS_*,
	R_MIPS_TLS_DTPREL32/64, and R_MIPS_TLS_TPREL32/64 relocations.
@
text
@a1354 2
static void s_tprelword (int);
static void s_tpreldword (int);
a1433 2
  {"tprelword", s_tprelword, 0},
  {"tpreldword", s_tpreldword, 0},
d14043 1
a14043 8
  {"%hi", BFD_RELOC_MIPS16_HI16_S},
  {"%tlsgd", BFD_RELOC_MIPS16_TLS_GD},
  {"%tlsldm", BFD_RELOC_MIPS16_TLS_LDM},
  {"%dtprel_hi", BFD_RELOC_MIPS16_TLS_DTPREL_HI16},
  {"%dtprel_lo", BFD_RELOC_MIPS16_TLS_DTPREL_LO16},
  {"%tprel_hi", BFD_RELOC_MIPS16_TLS_TPREL_HI16},
  {"%tprel_lo", BFD_RELOC_MIPS16_TLS_TPREL_LO16},
  {"%gottprel", BFD_RELOC_MIPS16_TLS_GOTTPREL}
a15371 2
    case BFD_RELOC_MIPS_TLS_TPREL32:
    case BFD_RELOC_MIPS_TLS_TPREL64:
a15380 7
    case BFD_RELOC_MIPS16_TLS_GD:
    case BFD_RELOC_MIPS16_TLS_LDM:
    case BFD_RELOC_MIPS16_TLS_DTPREL_HI16:
    case BFD_RELOC_MIPS16_TLS_DTPREL_LO16:
    case BFD_RELOC_MIPS16_TLS_GOTTPREL:
    case BFD_RELOC_MIPS16_TLS_TPREL_HI16:
    case BFD_RELOC_MIPS16_TLS_TPREL_LO16:
d16550 3
a16552 4
/* Handle a .dtprelword, .dtpreldword, .tprelword, or .tpreldword
   pseudo-op; DIRSTR says which. The pseudo-op generates a BYTES-size
   DTP- or TP-relative relocation of type RTYPE, for use in either DWARF
   debug information or MIPS16 TLS.  */
d16555 1
a16555 2
s_tls_rel_directive (const size_t bytes, const char *dirstr,
		     bfd_reloc_code_real_type rtype)
d16564 3
a16566 1
      as_bad (_("Unsupported use of %s"), dirstr);
d16572 5
a16576 1
  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE, rtype);
d16585 1
a16585 1
  s_tls_rel_directive (4, ".dtprelword", BFD_RELOC_MIPS_TLS_DTPREL32);
d16593 1
a16593 17
  s_tls_rel_directive (8, ".dtpreldword", BFD_RELOC_MIPS_TLS_DTPREL64);
}

/* Handle .tprelword.  */

static void
s_tprelword (int ignore ATTRIBUTE_UNUSED)
{
  s_tls_rel_directive (4, ".tprelword", BFD_RELOC_MIPS_TLS_TPREL32);
}

/* Handle .tpreldword.  */

static void
s_tpreldword (int ignore ATTRIBUTE_UNUSED)
{
  s_tls_rel_directive (8, ".tpreldword", BFD_RELOC_MIPS_TLS_TPREL64);
@


1.488.2.3
log
@gas/
	* config/tc-mips.c (s_tls_rel_directive): Call mips_clear_insn_labels.

gas/testsuite/
	* gas/mips/tls-relw.s, gas/mips/tls-relw.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@a16593 1
  mips_clear_insn_labels ();
@


1.487
log
@	* config/tc-mips.c (mips_cpu_info_table): Add "m14k" and
	"m14kc".
	* doc/c-mips.texi (MIPS architecture options): Add "m14k" and
	"m14kc" to the list of -march options.
@
text
@d3718 2
a3719 3
  /* If the previous instruction had a fixup in mips16 mode, we can not
     swap.  This normally means that the previous instruction was a 4
     byte branch anyhow.  */
@


1.486
log
@	gas/
	* config/tc-mips.c (mips_set_options): Add ase_mcu.
	(mips_opts): Initialise ase_mcu to -1.
	(ISA_SUPPORTS_MCU_ASE): New macro.
	(MIPS_CPU_ASE_MCU): Likewise.
	(is_opcode_valid): Handle MCU.
	(macro_build, macro): Likewise.
	(validate_mips_insn, validate_micromips_insn): Likewise.
	(mips_ip): Likewise.
	(options): Add OPTION_MCU and OPTION_NO_MCU.
	(md_longopts): Add mmcu and mno-mcu.
	(md_parse_option): Handle OPTION_MCU and OPTION_NO_MCU.
	(mips_after_parse_args): Handle MCU.
	(s_mipsset): Likewise.
	(md_show_usage): Handle MCU options.

	* doc/as.texinfo: Document -mmcu and -mno-mcu options.
	* doc/c-mips.texi: Likewise, and document ".set mcu" and
	".set nomcu" directives.

	gas/testsuite/
	* gas/mips/micromips@@mcu.d: New test.
	* gas/mips/mcu.d: Likewise.
	* gas/mips/mcu.s: New test source.
	* gas/mips/mips.exp: Run the new tests.

	include/opcode/
	* mips.h (OP_MASK_3BITPOS, OP_SH_3BITPOS): New macros.
	(OP_MASK_OFFSET12, OP_SH_OFFSET12): Redefine.
	(INSN_ASE_MASK): Add the MCU bit.
	(INSN_MCU): New macro.
	(M_ACLR_AB, M_ACLR_OB, M_ASET_AB, M_ASET_OB): New enum values.
	(MICROMIPSOP_MASK_3BITPOS, MICROMIPSOP_SH_3BITPOS): New macros.

	opcodes/
	* mips-dis.c (mips_arch_choices): Enable MCU for "mips32r2"
	and "mips64r2".
	(print_insn_args, print_insn_micromips): Handle MCU.
	* micromips-opc.c (MC): New macro.
	(micromips_opcodes): Add "aclr", "aset" and "iret".
	* mips-opc.c (MC): New macro.
	(mips_builtin_opcodes): Add "aclr", "aset" and "iret".
@
text
@d18966 2
@


1.485
log
@	include/opcode/
	* mips.h (INSN_WRITE_GPR_S, INSN2_WRITE_GPR_MB): New macros.
	(INSN2_READ_GPR_MC, INSN2_READ_GPR_ME): Likewise.
	(INSN2_WRITE_GPR_MF, INSN2_READ_GPR_MG): Likewise.
	(INSN2_READ_GPR_MJ, INSN2_WRITE_GPR_MJ): Likewise.
	(INSN2_READ_GPR_MP, INSN2_WRITE_GPR_MP): Likewise.
	(INSN2_READ_GPR_MQ, INSN2_WRITE_GPR_MHI): Likewise.
	(INSN2_READ_GPR_MMN): Likewise.
	(INSN2_READ_FPR_D): Change the bit used.
	(INSN2_MOD_GPR_MD, INSN2_MOD_GPR_MF): Likewise.
	(INSN2_MOD_SP, INSN2_READ_GPR_31, INSN2_READ_GP): Likewise.
	(INSN2_READ_PC, INSN2_UNCOND_BRANCH): Likewise.
	(INSN2_COND_BRANCH): Likewise.
	(INSN2_WRITE_GPR_S, INSN2_MOD_GPR_MB): Remove macros.
	(INSN2_MOD_GPR_MC, INSN2_MOD_GPR_ME, INSN2_MOD_GPR_MG): Likewise.
	(INSN2_MOD_GPR_MJ, INSN2_MOD_GPR_MP, INSN2_MOD_GPR_MQ): Likewise.
	(INSN2_MOD_GPR_MHI, INSN2_MOD_GPR_MM): Likewise.
	(INSN2_MOD_GPR_MN): Likewise.

	gas/
	* config/tc-mips.c (gpr_mod_mask): Remove INSN2_MOD_GPR_MB,
	INSN2_MOD_GPR_MC, INSN2_MOD_GPR_ME, INSN2_MOD_GPR_MG,
	INSN2_MOD_GPR_MHI, INSN2_MOD_GPR_MJ, INSN2_MOD_GPR_MM,
	INSN2_MOD_GPR_MN, INSN2_MOD_GPR_MP and INSN2_MOD_GPR_MQ opcode
	register use checks.
	(gpr_read_mask): Add INSN2_READ_GPR_MC, INSN2_READ_GPR_ME
	INSN2_READ_GPR_MG, INSN2_READ_GPR_MJ, INSN2_READ_GPR_MMN,
	INSN2_READ_GPR_MP and INSN2_READ_GPR_MQ opcode register use
	checks.
	(gpr_write_mask): Replace INSN2_WRITE_GPR_S opcode register
	use flag with INSN_WRITE_GPR_S.  Add INSN2_WRITE_GPR_MB,
	INSN2_WRITE_GPR_MHI, INSN2_WRITE_GPR_MJ and INSN2_WRITE_GPR_MP
	opcode register use checks.
	(can_swap_branch_p): Enable microMIPS branch swapping.
	(append_insn): Likewise.

	gas/testsuite/
	* gas/mips/micromips.d: Update according to changes to enable
	microMIPS branch swapping.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic.d: Likewise.
	* gas/mips/micromips@@loc-swap.d: Likewise.
	* gas/mips/micromips@@loc-swap-dis.d: Likewise.

	opcodes/
	* micromips-opc.c (MOD_mb, MOD_mc, MOD_md): Remove macros.
	(MOD_me, MOD_mf, MOD_mg, MOD_mhi, MOD_mj, MOD_ml): Likewise.
	(MOD_mm, MOD_mn, MOD_mp, MOD_mq, MOD_sp): Likewise.
	(WR_mb, RD_mc, RD_md, WR_md, RD_me, RD_mf, WR_mf): New macros.
	(RD_mg, WR_mhi, RD_mj, WR_mj, RD_ml, RD_mmn): Likewise.
	(RD_mp, WR_mp, RD_mq, RD_sp, WR_sp): Likewise.
	(WR_s): Update macro.
	(micromips_opcodes): Update register use flags of: "addiu",
	"addiupc", "addiur1sp", "addiur2", "addius5", "addiusp", "addu",
	"and", "andi", "beq", "beqz", "bne", "bnez", "di", "ei", "j",
	"jalr", "jalrs", "jr", "jraddiusp", "jrc", "lbu", "lhu", "li",
	"lui", "lw", "lwm", "mfhi", "mflo", "move", "movep", "not",
	"nor", "or", "ori", "sb", "sh", "sll", "srl", "subu", "sw",
	"swm" and "xor" instructions.
@
text
@d221 1
d296 2
a297 2
  /* mips16 */ -1, /* micromips */ -1, /* noreorder */ 0, /* at */ ATREG,
  /* warn_about_macros */ 0, /* nomove */ 0, /* nobopt */ 0,
d372 3
d1395 1
d2211 2
d5054 5
d5060 2
a5061 2
	  gas_assert (mips_opts.micromips);
	  INSERT_OPERAND (1, OFFSET12, insn, va_arg (args, unsigned long));
d7896 16
d10301 2
d10460 1
d10967 19
d11424 1
a11425 1
	      gas_assert (mips_opts.micromips);
d11451 2
a11452 1
		  INSERT_OPERAND (1, OFFSET12, *ip, imm_expr.X_add_number);
d14230 2
d14326 2
d14582 8
d15089 6
d16141 4
d19266 3
@


1.484
log
@	* config/tc-mips.c (RELAX_MICROMIPS_ENCODE): Remove forced 16-bit
	branch size information.
	(RELAX_MICROMIPS_U16BIT): Remove macro.
	(RELAX_MICROMIPS_UNCOND): Adjust accordingly.
	(RELAX_MICROMIPS_COMPACT, RELAX_MICROMIPS_LINK): Likewise.
	(RELAX_MICROMIPS_RELAX32): Likewise.
	(RELAX_MICROMIPS_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR32): Likewise.
	(append_insn): Always check forced_insn_length for microMIPS
	relaxation.  Adjust code for the removal of
	RELAX_MICROMIPS_U16BIT.
	(mips_ip) <'D', 'E'>: If forced_insn_length, then emit the
	relocation straight away.
	(relaxed_micromips_16bit_branch_length): Adjust code for the
	removal of RELAX_MICROMIPS_U16BIT.
@
text
@a2944 4
      if (pinfo2 & INSN2_MOD_GPR_MB)
	mask |= 1 << micromips_to_32_reg_b_map[EXTRACT_OPERAND (1, MB, *ip)];
      if (pinfo2 & INSN2_MOD_GPR_MC)
	mask |= 1 << micromips_to_32_reg_c_map[EXTRACT_OPERAND (1, MC, *ip)];
a2946 2
      if (pinfo2 & INSN2_MOD_GPR_ME)
	mask |= 1 << micromips_to_32_reg_e_map[EXTRACT_OPERAND (1, ME, *ip)];
a2948 17
      if (pinfo2 & INSN2_MOD_GPR_MG)
	mask |= 1 << micromips_to_32_reg_g_map[EXTRACT_OPERAND (1, MG, *ip)];
      if (pinfo2 & INSN2_MOD_GPR_MHI)
	{
	  mask |= 1 << micromips_to_32_reg_h_map[EXTRACT_OPERAND (1, MH, *ip)];
	  mask |= 1 << micromips_to_32_reg_i_map[EXTRACT_OPERAND (1, MI, *ip)];
	}
      if (pinfo2 & INSN2_MOD_GPR_MJ)
	mask |= 1 << EXTRACT_OPERAND (1, MJ, *ip);
      if (pinfo2 & INSN2_MOD_GPR_MM)
	mask |= 1 << micromips_to_32_reg_m_map[EXTRACT_OPERAND (1, MM, *ip)];
      if (pinfo2 & INSN2_MOD_GPR_MN)
	mask |= 1 << micromips_to_32_reg_n_map[EXTRACT_OPERAND (1, MN, *ip)];
      if (pinfo2 & INSN2_MOD_GPR_MP)
	mask |= 1 << EXTRACT_OPERAND (1, MP, *ip);
      if (pinfo2 & INSN2_MOD_GPR_MQ)
	mask |= 1 << micromips_to_32_reg_q_map[EXTRACT_OPERAND (1, MQ, *ip)];
d2999 20
d3057 1
a3057 1
      if (pinfo2 & INSN2_WRITE_GPR_S)
d3064 14
d3680 1
a3680 1
  unsigned long pinfo, pinfo2, prev_pinfo;
a3682 3
  /* For microMIPS, disable reordering.  */
  if (mips_opts.micromips)
    return FALSE;
d3782 1
d3785 2
d3987 1
d4179 1
d4197 1
a4197 2
  dwarf2_emit_insn ((HAVE_CODE_COMPRESSION ? -1 : 0)
		    + (method == APPEND_SWAP ? insn_length (history) : 0));
d4251 1
a4465 5
	else if (mips_opts.micromips)
	  {
	    /* We don't reorder for micromips.  */
	    abort ();
	  }
d4472 1
a4472 1
	    delay.frag->fr_fix -= 4;
d4474 1
a4474 1
	      move_insn (ip, ip->frag, ip->where - 4);
d4479 2
a4480 1
	    move_insn (&delay, ip->frag, ip->where);
@


1.483
log
@gas/
	* config/tc-mips.c (emit_nop): Delete.
	(get_delay_slot_nop): New function.
	(nops_for_insn_or_target): Use it.
	(append_insn): Likewise.  When avoiding hazards, call add_fixed_insn
	and insert_into_history directly.
@
text
@d1156 17
a1172 19
   selected as the assembler temporary, whether the user explicitly
   requested a 16-bit form, whether the branch is unconditional, whether
   it is compact, whether it stores the link address implicitly in $ra,
   whether relaxation of out-of-range 32-bit branches to a sequence of
   instructions is enabled, and whether the displacement of a branch is
   too large to fit as an immediate argument of a 16-bit and a 32-bit
   branch, respectively.  */
#define RELAX_MICROMIPS_ENCODE(type, at, u16bit, uncond, compact, link,	\
			       relax32, toofar16, toofar32)		\
  (0x40000000								\
   | ((type) & 0xff)							\
   | (((at) & 0x1f) << 8)						\
   | ((u16bit) ? 0x2000 : 0)						\
   | ((uncond) ? 0x4000 : 0)						\
   | ((compact) ? 0x8000 : 0)						\
   | ((link) ? 0x10000 : 0)						\
   | ((relax32) ? 0x20000 : 0)						\
   | ((toofar16) ? 0x40000 : 0)						\
   | ((toofar32) ? 0x80000 : 0))
d1176 11
a1186 12
#define RELAX_MICROMIPS_U16BIT(i) (((i) & 0x2000) != 0)
#define RELAX_MICROMIPS_UNCOND(i) (((i) & 0x4000) != 0)
#define RELAX_MICROMIPS_COMPACT(i) (((i) & 0x8000) != 0)
#define RELAX_MICROMIPS_LINK(i) (((i) & 0x10000) != 0)
#define RELAX_MICROMIPS_RELAX32(i) (((i) & 0x20000) != 0)

#define RELAX_MICROMIPS_TOOFAR16(i) (((i) & 0x40000) != 0)
#define RELAX_MICROMIPS_MARK_TOOFAR16(i) ((i) | 0x40000)
#define RELAX_MICROMIPS_CLEAR_TOOFAR16(i) ((i) & ~0x40000)
#define RELAX_MICROMIPS_TOOFAR32(i) (((i) & 0x80000) != 0)
#define RELAX_MICROMIPS_MARK_TOOFAR32(i) ((i) | 0x80000)
#define RELAX_MICROMIPS_CLEAR_TOOFAR32(i) ((i) & ~0x80000)
d4196 1
a4196 4
	     && !(ip->insn_mo->membership & (INSN_DSP64 | INSN_DSP))
	     /* Don't try 32-bit branch relaxation when users specify
	        16-bit/32-bit instructions.  */
	     && !forced_insn_length);
d4224 4
a4227 1
	   && (delayed_branch_p (ip) || compact_branch_p (ip)))
d4241 2
a4242 4
			RELAX_MICROMIPS_ENCODE (type, AT,
						forced_insn_length == 2,
						uncond, compact, al, relax32,
						0, 0),
d12674 6
a12679 1
		  *offset_reloc = (int) BFD_RELOC_UNUSED + c;
a17244 3
  if (RELAX_MICROMIPS_U16BIT (fragp->fr_subtype))
    return 2;

@


1.482
log
@gas/
	* config/tc-mips.c (delayed_branch_p, compact_branch_p)
	(uncond_branch_p, branch_likely_p): New functions.
	(insns_between, nops_for_insn_or_target, append_insn)
	(macro_start): Use them.
	(get_append_method): Likewise.  Remove redundant test.
@
text
@a1787 9
/* Emit a nop instruction, recording it in the history buffer.  */

static void
emit_nop (void)
{
  add_fixed_insn (NOP_INSN);
  insert_into_history (0, 1, NOP_INSN);
}

d2924 12
d3602 1
a3602 1
				    hist, insn, NOP_INSN);
d3975 1
a3975 1
  unsigned long prev_pinfo2, pinfo, pinfo2;
a3989 1
  pinfo2 = ip->insn_mo->pinfo2;
d4112 2
a4113 1
	    emit_nop ();
d4428 10
a4437 15
      insert_into_history (0, 1, ip);
      if (mips_opts.micromips
	  && (pinfo2 & INSN2_BRANCH_DELAY_32BIT))
	{
	  add_fixed_insn (&micromips_nop32_insn);
	  insert_into_history (0, 1, &micromips_nop32_insn);
	  if (mips_relax.sequence)
	    mips_relax.sizes[mips_relax.sequence - 1] += 4;
	}
      else
	{
	  emit_nop ();
	  if (mips_relax.sequence)
	    mips_relax.sizes[mips_relax.sequence - 1] += NOP_INSN_SIZE;
	}
@


1.481
log
@gas/
	* config/tc-mips.c (nops_for_vr4130): Revert previous commit.
@
text
@d2891 42
d3205 1
a3205 4
	      || (insn2->insn_mo->pinfo
		  & (INSN_UNCOND_BRANCH_DELAY
		     | INSN_COND_BRANCH_DELAY
		     | INSN_COND_BRANCH_LIKELY)) != 0)
d3596 1
a3596 3
  if (insn->insn_mo->pinfo & (INSN_UNCOND_BRANCH_DELAY
			      | INSN_COND_BRANCH_DELAY
			      | INSN_COND_BRANCH_LIKELY))
d3603 1
a3603 3
  else if (mips_opts.mips16
	   && (insn->insn_mo->pinfo & (MIPS16_INSN_UNCOND_BRANCH
				       | MIPS16_INSN_COND_BRANCH)))
d3809 1
a3809 3
  pinfo = ip->insn_mo->pinfo;
  if ((pinfo & INSN_UNCOND_BRANCH_DELAY)
      || (pinfo & INSN_COND_BRANCH_DELAY))
d3811 1
a3811 1
      if (can_swap_branch_p (ip))
d3814 1
a3816 1
	  && (pinfo & INSN_UNCOND_BRANCH_DELAY)
a3822 5
  /* We don't bother trying to track the target of branches, so there's
     nothing we can use to fill a branch-likely slot.  */
  if (pinfo & INSN_COND_BRANCH_LIKELY)
    return APPEND_ADD_WITH_NOP;

d3972 1
a3972 1
  unsigned long prev_pinfo, prev_pinfo2, pinfo, pinfo2;
a3984 1
  prev_pinfo = history[0].insn_mo->pinfo;
d4205 1
a4205 2
      && (pinfo & INSN_UNCOND_BRANCH_DELAY || pinfo & INSN_COND_BRANCH_DELAY
	  || pinfo & INSN_COND_BRANCH_LIKELY))
d4210 2
a4211 2
			      (pinfo & INSN_UNCOND_BRANCH_DELAY) ? -1
			      : (pinfo & INSN_COND_BRANCH_LIKELY) ? 1
d4215 2
a4216 2
			 pinfo & INSN_UNCOND_BRANCH_DELAY,
			 pinfo & INSN_COND_BRANCH_LIKELY,
d4227 1
a4227 4
	   && (pinfo & INSN_UNCOND_BRANCH_DELAY
	       || pinfo & INSN_COND_BRANCH_DELAY
	       || (pinfo2 & ~INSN2_ALIAS) == INSN2_UNCOND_BRANCH
	       || pinfo2 & INSN2_COND_BRANCH))
d4231 2
a4232 3
      int uncond = (pinfo & INSN_UNCOND_BRANCH_DELAY
		    || pinfo2 & INSN2_UNCOND_BRANCH) ? -1 : 0;
      int compact = pinfo2 & (INSN2_COND_BRANCH | INSN2_UNCOND_BRANCH);
d4257 1
a4257 1
			 prev_pinfo & INSN_UNCOND_BRANCH_DELAY,
d4265 1
a4265 1
      if ((pinfo & INSN_UNCOND_BRANCH_DELAY) == 0)
d4275 1
a4275 1
	  && (prev_pinfo & INSN_UNCOND_BRANCH_DELAY) != 0)
d4489 2
a4490 3
  if ((history[1].insn_mo->pinfo & INSN_UNCOND_BRANCH_DELAY)
      || (mips_opts.mips16
	  && (history[0].insn_mo->pinfo & MIPS16_INSN_UNCOND_BRANCH)))
d4610 1
a4610 4
				     && (history[0].insn_mo->pinfo
					 & (INSN_UNCOND_BRANCH_DELAY
					    | INSN_COND_BRANCH_DELAY
					    | INSN_COND_BRANCH_LIKELY)) != 0);
@


1.480
log
@	bfd/
	* elfxx-mips.c: Adjust comments throughout.
	(mips_elf_relax_delete_bytes): Reshape code.
	(_bfd_mips_elf_relax_section): Remove check for
	R_MICROMIPS_GPREL16 relocations.  Reshape code.

	gas/
	* config/tc-mips.c: Adjust comments throughout.
	(reglist_lookup): Reshape code.
	(jmp_reloc_p, jalr_reloc_p): Reformat.
	(got16_reloc_p, hi16_reloc_p, lo16_reloc_p): Handle microMIPS
	relocations.
	(gpr_mod_mask): Remove unused variable.
	(gpr_read_mask, gpr_write_mask): Reshape code.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(nops_for_vr4130): Ensure non-microMIPS mode.
	(can_swap_branch_p): Correct pinfo2 reference.  Reshape code.
	(append_insn): Skip Loongson 2F workaround in MIPS16 mode.  Use
	the outermost operator of a compound relocation to determines
	the relocated field.  Fix formatting.
	(md_convert_frag): Reshape code.

	include/opcode/
	* mips.h: Clarify the description of microMIPS instruction
	manipulation macros.
	(MICROMIPSOP_MASK_MAJOR, MICROMIPSOP_SH_MAJOR): Remove macros.
@
text
@a3277 1
	gas_assert (!mips_opts.micromips);
@


1.479
log
@bfd/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Ilie Garbacea  <ilie@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* archures.c (bfd_mach_mips_micromips): New macro.
	* cpu-mips.c (I_micromips): New enum value.
	(arch_info_struct): Add bfd_mach_mips_micromips.
	* elfxx-mips.h (_bfd_mips_elf_is_target_special_symbol): New
	prototype.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(gprel16_reloc_p): Handle microMIPS ASE.
	(literal_reloc_p): New function.
	* elf32-mips.c (elf_micromips_howto_table_rel): New variable.
	(_bfd_mips_elf32_gprel16_reloc): Handle microMIPS ASE.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(mips_elf_gprel32_reloc): Update comment.
	(micromips_reloc_map): New variable.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(mips_elf32_rtype_to_howto): Likewise.
	(mips_info_to_howto_rel): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	(bfd_elf32_bfd_relax_section): Likewise.
	* elf64-mips.c (micromips_elf64_howto_table_rel): New variable.
	(micromips_elf64_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf64_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Likewise.
	(bfd_elf64_bfd_is_target_special_symbol): Define.
	* elfn32-mips.c (elf_micromips_howto_table_rel): New variable.
	(elf_micromips_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf_n32_rtype_to_howto): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	* elfxx-mips.c (LA25_LUI_MICROMIPS_1): New macro.
	(LA25_LUI_MICROMIPS_2): Likewise.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise.
	(TLS_RELOC_P): Handle microMIPS ASE.
	(mips_elf_create_stub_symbol): Adjust value of stub symbol if
	target is a microMIPS function.
	(micromips_reloc_p): New function.
	(micromips_reloc_shuffle_p): Likewise.
	(got16_reloc_p, call16_reloc_p): Handle microMIPS ASE.
	(got_disp_reloc_p, got_page_reloc_p): New functions.
	(got_ofst_reloc_p): Likewise.
	(got_hi16_reloc_p, got_lo16_reloc_p): Likewise.
	(call_hi16_reloc_p, call_lo16_reloc_p): Likewise.
	(hi16_reloc_p, lo16_reloc_p, jal_reloc_p): Handle microMIPS ASE.
	(micromips_branch_reloc_p): New function.
	(tls_gd_reloc_p, tls_ldm_reloc_p): Likewise.
	(tls_gottprel_reloc_p): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(_bfd_mips_elf_lo16_reloc): Handle microMIPS ASE.
	(mips_tls_got_index, mips_elf_got_page): Likewise.
	(mips_elf_create_local_got_entry): Likewise.
	(mips_elf_relocation_needs_la25_stub): Likewise.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(_bfd_mips_elf_symbol_processing): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_link_output_symbol_hook): Likewise.
	(mips_elf_add_lo16_rel_addend): Likewise.
	(_bfd_mips_elf_check_relocs): Likewise.
	(mips_elf_adjust_addend): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_la25_stub): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_gc_sweep_hook): Likewise.
	(_bfd_mips_elf_is_target_special_symbol): New function.
	(mips_elf_relax_delete_bytes): Likewise.
	(opcode_descriptor): New structure.
	(RA): New macro.
	(OP32_SREG, OP32_TREG, OP16_VALID_REG): Likewise.
	(b_insns_32, bc_insn_32, bz_insn_32, bzal_insn_32): New variables.
	(beq_insn_32): Likewise.
	(b_insn_16, bz_insn_16): New variables.
	(BZC32_REG_FIELD): New macro.
	(bz_rs_insns_32, bz_rt_insns_32): New variables.
	(bzc_insns_32, bz_insns_16):Likewise.
	(BZ16_REG, BZ16_REG_FIELD): New macros.
	(jal_insn_32_bd16, jal_insn_32_bd32): New variables.
	(jal_x_insn_32_bd32): Likewise.
	(j_insn_32, jalr_insn_32): Likewise.
	(ds_insns_32_bd16, ds_insns_32_bd32): Likewise.
	(jalr_insn_16_bd16, jalr_insn_16_bd32, jr_insn_16): Likewise.
	(JR16_REG): New macro.
	(ds_insns_16_bd16): New variable.
	(lui_insn): Likewise.
	(addiu_insn, addiupc_insn): Likewise.
	(ADDIUPC_REG_FIELD): New macro.
	(MOVE32_RD, MOVE32_RS): Likewise.
	(MOVE16_RD_FIELD, MOVE16_RS_FIELD): Likewise.
	(move_insns_32, move_insns_16): New variables.
	(nop_insn_32, nop_insn_16): Likewise.
	(MATCH): New macro.
	(find_match): New function.
	(check_br16_dslot, check_br32_dslot): Likewise.
	(check_br16, check_br32): Likewise.
	(IS_BITSIZE): New macro.
	(check_4byte_branch): New function.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips_elf_merge_private_bfd_data): Disallow linking MIPS16
	and microMIPS modules together.
	(_bfd_mips_elf_print_private_bfd_data):	Handle microMIPS ASE.
	* reloc.c (BFD_RELOC_MICROMIPS_7_PCREL_S1): New relocation.
	(BFD_RELOC_MICROMIPS_10_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_16_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_GPREL16): Likewise.
	(BFD_RELOC_MICROMIPS_JMP, BFD_RELOC_MICROMIPS_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_HI16_S): Likewise.
	(BFD_RELOC_MICROMIPS_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_LITERAL): Likewise.
	(BFD_RELOC_MICROMIPS_GOT16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_SUB): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_PAGE): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_OFST): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHEST): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHER): Likewise.
	(BFD_RELOC_MICROMIPS_SCN_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_JALR): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GD): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_LDM): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GOTTPREL): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

binutils/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* readelf.c (get_machine_flags): Handle microMIPS ASE.
	(get_mips_symbol_other): Likewise.

gas/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.h (mips_segment_info): Add one bit for
	microMIPS.
	(TC_LABEL_IS_LOCAL): New macro.
	(mips_label_is_local): New prototype.
	* config/tc-mips.c (S0, S7): New macros.
	(emit_branch_likely_macro): New variable.
	(mips_set_options): Add micromips.
	(mips_opts): Initialise micromips to -1.
	(file_ase_micromips): New variable.
	(CPU_HAS_MICROMIPS): New macro.
	(hilo_interlocks): Set for microMIPS too.
	(gpr_interlocks): Likewise.
	(cop_interlocks): Likewise.
	(cop_mem_interlocks): Likewise.
	(HAVE_CODE_COMPRESSION): New macro.
	(micromips_op_hash): New variable.
	(micromips_nop16_insn, micromips_nop32_insn): New variables.
	(NOP_INSN): Handle microMIPS ASE.
	(mips32_to_micromips_reg_b_map): New macro.
	(mips32_to_micromips_reg_c_map): Likewise.
	(mips32_to_micromips_reg_d_map): Likewise.
	(mips32_to_micromips_reg_e_map): Likewise.
	(mips32_to_micromips_reg_f_map): Likewise.
	(mips32_to_micromips_reg_g_map): Likewise.
	(mips32_to_micromips_reg_l_map): Likewise.
	(mips32_to_micromips_reg_n_map): Likewise.
	(mips32_to_micromips_reg_h_map): New variable.
	(mips32_to_micromips_reg_m_map): Likewise.
	(mips32_to_micromips_reg_q_map): Likewise.
	(micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_to_32_reg_b_map): New macro.
	(micromips_to_32_reg_c_map): Likewise.
	(micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map): Likewise.
	(micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map): Likewise.
	(micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_n_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): New macros.
	(RELAX_DELAY_SLOT_16BIT): New macro.
	(RELAX_DELAY_SLOT_SIZE_FIRST): Likewise.
	(RELAX_DELAY_SLOT_SIZE_SECOND): Likewise.
	(RELAX_MICROMIPS_ENCODE, RELAX_MICROMIPS_P): New macros.
	(RELAX_MICROMIPS_TYPE, RELAX_MICROMIPS_AT): Likewise.
	(RELAX_MICROMIPS_U16BIT, RELAX_MICROMIPS_UNCOND): Likewise.
	(RELAX_MICROMIPS_COMPACT, RELAX_MICROMIPS_LINK): Likewise.
	(RELAX_MICROMIPS_RELAX32, RELAX_MICROMIPS_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR32): Likewise.
	(INSERT_OPERAND, EXTRACT_OPERAND): Handle microMIPS ASE.
	(mips_macro_warning): Add delay_slot_16bit_p, delay_slot_32bit_p,
	fsize and insns.
	(mips_mark_labels): New function.
	(mips16_small, mips16_ext): Remove variables, replacing with...
	(forced_insn_size): ... this.
	(append_insn, mips16_ip): Update accordingly.
	(micromips_insn_length): New function.
	(insn_length): Return the length of microMIPS instructions.
	(mips_record_mips16_mode): Rename to...
	(mips_record_compressed_mode): ... this.  Handle microMIPS ASE.
	(install_insn): Handle microMIPS ASE.
	(reglist_lookup): New function.
	(is_size_valid, is_delay_slot_valid): Likewise.
	(md_begin): Handle microMIPS ASE.
	(md_assemble): Likewise.  Update for append_insn interface change.
	(micromips_reloc_p): New function.
	(got16_reloc_p): Handle microMIPS ASE.
	(hi16_reloc_p): Likewise.
	(lo16_reloc_p): Likewise.
	(jmp_reloc_p): New function.
	(jalr_reloc_p): Likewise.
	(matching_lo_reloc): Handle microMIPS ASE.
	(insn_uses_reg, reg_needs_delay): Likewise.
	(mips_move_labels): Likewise.
	(mips16_mark_labels): Rename to...
	(mips_compressed_mark_labels): ... this.  Handle microMIPS ASE.
	(gpr_mod_mask): New function.
	(gpr_read_mask, gpr_write_mask): Handle microMIPS ASE.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(insns_between, nops_for_vr4130, nops_for_insn): Likewise.
	(fix_loongson2f_nop, fix_loongson2f_jump): Likewise.
	(MICROMIPS_LABEL_CHAR): New macro.
	(micromips_target_label, micromips_target_name): New variables.
	(micromips_label_name, micromips_label_expr): New functions.
	(micromips_label_inc, micromips_add_label): Likewise.
	(mips_label_is_local): Likewise.
	(micromips_map_reloc): Likewise.
	(can_swap_branch_p): Handle microMIPS ASE.
	(append_insn): Add expansionp argument.  Handle microMIPS ASE.
	(start_noreorder, end_noreorder): Handle microMIPS ASE.
	(macro_start, macro_warning, macro_end): Likewise.
	(brk_fmt, cop12_fmt, jalr_fmt, lui_fmt): New variables.
	(mem12_fmt, mfhl_fmt, shft_fmt, trap_fmt): Likewise.
	(BRK_FMT, COP12_FMT, JALR_FMT, LUI_FMT): New macros.
	(MEM12_FMT, MFHL_FMT, SHFT_FMT, TRAP_FMT): Likewise.
	(macro_build): Handle microMIPS ASE.  Update for append_insn
	interface change.
	(mips16_macro_build): Update for append_insn interface change.
	(macro_build_jalr): Handle microMIPS ASE.
	(macro_build_lui): Likewise.  Simplify.
	(load_register): Handle microMIPS ASE.
	(load_address): Likewise.
	(move_register): Likewise.
	(macro_build_branch_likely): New function.
	(macro_build_branch_ccl): Likewise.
	(macro_build_branch_rs): Likewise.
	(macro_build_branch_rsrt): Likewise.
	(macro): Handle microMIPS ASE.
	(validate_micromips_insn): New function.
	(expr_const_in_range): Likewise.
	(mips_ip): Handle microMIPS ASE.
	(options): Add OPTION_MICROMIPS and OPTION_NO_MICROMIPS.
	(md_longopts): Add mmicromips and mno-micromips.
	(md_parse_option): Handle OPTION_MICROMIPS and
	OPTION_NO_MICROMIPS.
	(mips_after_parse_args): Handle microMIPS ASE.
	(md_pcrel_from): Handle microMIPS relocations.
	(mips_force_relocation): Likewise.
	(md_apply_fix): Likewise.
	(mips_align): Handle microMIPS ASE.
	(s_mipsset): Likewise.
	(s_cpload, s_cpsetup, s_cpreturn): Use relocation wrappers.
	(s_dtprel_internal): Likewise.
	(s_gpword, s_gpdword): Likewise.
	(s_insn): Handle microMIPS ASE.
	(s_mips_stab): Likewise.
	(relaxed_micromips_32bit_branch_length): New function.
	(relaxed_micromips_16bit_branch_length): New function.
	(md_estimate_size_before_relax): Handle microMIPS ASE.
	(mips_fix_adjustable): Likewise.
	(tc_gen_reloc): Handle microMIPS relocations.
	(mips_relax_frag): Handle microMIPS ASE.
	(md_convert_frag): Likewise.
	(mips_frob_file_after_relocs): Likewise.
	(mips_elf_final_processing): Likewise.
	(mips_nop_opcode): Likewise.
	(mips_handle_align): Likewise.
	(md_show_usage): Handle microMIPS options.
	* symbols.c (TC_LABEL_IS_LOCAL): New macro.
	(S_IS_LOCAL): Add a TC_LABEL_IS_LOCAL check.

	* doc/as.texinfo (Target MIPS options): Add -mmicromips and
	-mno-micromips.
	(-mmicromips, -mno-micromips): New options.
	* doc/c-mips.texi (-mmicromips, -mno-micromips): New options.
	(MIPS ISA): Document .set micromips and .set nomicromips.
	(MIPS insn): Update for microMIPS support.

gas/testsuite/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/micromips.d: New test.
	* gas/mips/micromips-branch-delay.d: Likewise.
	* gas/mips/micromips-branch-relax.d: Likewise.
	* gas/mips/micromips-branch-relax-pic.d: Likewise.
	* gas/mips/micromips-size-1.d: Likewise.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips.l: New stderr output.
	* gas/mips/micromips-branch-delay.l: Likewise.
	* gas/mips/micromips-branch-relax.l: Likewise.
	* gas/mips/micromips-branch-relax-pic.l: Likewise.
	* gas/mips/micromips-size-0.l: New list test.
	* gas/mips/micromips-size-1.l: New stderr output.
	* gas/mips/micromips.s: New test source.
	* gas/mips/micromips-branch-delay.s: Likewise.
	* gas/mips/micromips-branch-relax.s: Likewise.
	* gas/mips/micromips-size-0.s: Likewise.
	* gas/mips/micromips-size-1.s: Likewise.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/dli.s: Use .p2align.
	* gas/mips/elf_ase_micromips.d: New test.
	* gas/mips/elf_ase_micromips-2.d: Likewise.
	* gas/mips/micromips@@abs.d: Likewise.
	* gas/mips/micromips@@add.d: Likewise.
	* gas/mips/micromips@@alnv_ps-swap.d: Likewise.
	* gas/mips/micromips@@and.d: Likewise.
	* gas/mips/micromips@@beq.d: Likewise.
	* gas/mips/micromips@@bge.d: Likewise.
	* gas/mips/micromips@@bgeu.d: Likewise.
	* gas/mips/micromips@@blt.d: Likewise.
	* gas/mips/micromips@@bltu.d: Likewise.
	* gas/mips/micromips@@branch-likely.d: Likewise.
	* gas/mips/micromips@@branch-misc-1.d: Likewise.
	* gas/mips/micromips@@branch-misc-2-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic.d: Likewise.
	* gas/mips/micromips@@branch-misc-4-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-4.d: Likewise.
	* gas/mips/micromips@@branch-self.d: Likewise.
	* gas/mips/micromips@@cache.d: Likewise.
	* gas/mips/micromips@@daddi.d: Likewise.
	* gas/mips/micromips@@dli.d: Likewise.
	* gas/mips/micromips@@elf-jal.d: Likewise.
	* gas/mips/micromips@@elf-rel2.d: Likewise.
	* gas/mips/micromips@@elfel-rel2.d: Likewise.
	* gas/mips/micromips@@elf-rel4.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic-noreorder.d: Likewise.
	* gas/mips/micromips@@lb-svr4pic-ilocks.d: Likewise.
	* gas/mips/micromips@@li.d: Likewise.
	* gas/mips/micromips@@loc-swap-dis.d: Likewise.
	* gas/mips/micromips@@loc-swap.d: Likewise.
	* gas/mips/micromips@@mips1-fp.d: Likewise.
	* gas/mips/micromips@@mips32-cp2.d: Likewise.
	* gas/mips/micromips@@mips32-imm.d: Likewise.
	* gas/mips/micromips@@mips32-sf32.d: Likewise.
	* gas/mips/micromips@@mips32.d: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.d: Likewise.
	* gas/mips/micromips@@mips32r2-fp32.d: Likewise.
	* gas/mips/micromips@@mips32r2-sync.d: Likewise.
	* gas/mips/micromips@@mips32r2.d: Likewise.
	* gas/mips/micromips@@mips4-branch-likely.d: Likewise.
	* gas/mips/micromips@@mips4-fp.d: Likewise.
	* gas/mips/micromips@@mips4.d: Likewise.
	* gas/mips/micromips@@mips5.d: Likewise.
	* gas/mips/micromips@@mips64-cp2.d: Likewise.
	* gas/mips/micromips@@mips64.d: Likewise.
	* gas/mips/micromips@@mips64r2.d: Likewise.
	* gas/mips/micromips@@pref.d: Likewise.
	* gas/mips/micromips@@relax-at.d: Likewise.
	* gas/mips/micromips@@relax.d: Likewise.
	* gas/mips/micromips@@rol-hw.d: Likewise.
	* gas/mips/micromips@@uld2-eb.d: Likewise.
	* gas/mips/micromips@@uld2-el.d: Likewise.
	* gas/mips/micromips@@ulh2-eb.d: Likewise.
	* gas/mips/micromips@@ulh2-el.d: Likewise.
	* gas/mips/micromips@@ulw2-eb-ilocks.d: Likewise.
	* gas/mips/micromips@@ulw2-el-ilocks.d: Likewise.
	* gas/mips/cache.d: Likewise.
	* gas/mips/daddi.d: Likewise.
	* gas/mips/mips32-imm.d: Likewise.
	* gas/mips/pref.d: Likewise.
	* gas/mips/elf-rel27.d: Handle microMIPS ASE.
	* gas/mips/l_d.d: Likewise.
	* gas/mips/l_d-n32.d: Likewise.
	* gas/mips/l_d-n64.d: Likewise.
	* gas/mips/ld.d: Likewise.
	* gas/mips/ld-n32.d: Likewise.
	* gas/mips/ld-n64.d: Likewise.
	* gas/mips/s_d.d: Likewise.
	* gas/mips/s_d-n32.d: Likewise.
	* gas/mips/s_d-n64.d: Likewise.
	* gas/mips/sd.d: Likewise.
	* gas/mips/sd-n32.d: Likewise.
	* gas/mips/sd-n64.d: Likewise.
	* gas/mips/mips32.d: Update immediates.
	* gas/mips/micromips@@mips32-cp2.s: New test source.
	* gas/mips/micromips@@mips32-imm.s: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.s: Likewise.
	* gas/mips/micromips@@mips64-cp2.s: Likewise.
	* gas/mips/cache.s: Likewise.
	* gas/mips/daddi.s: Likewise.
	* gas/mips/mips32-imm.s: Likewise.
	* gas/mips/elf-rel4.s: Handle microMIPS ASE.
	* gas/mips/lb-pic.s: Likewise.
	* gas/mips/ld.s: Likewise.
	* gas/mips/mips32.s: Likewise.
	* gas/mips/mips.exp: Add the micromips arch.  Exclude mips16e
	from micromips.  Run mips32-imm.

	* gas/mips/jal-mask-11.d: New test.
	* gas/mips/jal-mask-12.d: Likewise.
	* gas/mips/micromips@@jal-mask-11.d: Likewise.
	* gas/mips/jal-mask-1.s: Source for the new tests.
	* gas/mips/jal-mask-21.d: New test.
	* gas/mips/jal-mask-22.d: Likewise.
	* gas/mips/micromips@@jal-mask-12.d: Likewise.
	* gas/mips/jal-mask-2.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/mips16-e.d: Add --special-syms to `objdump'.
	* gas/mips/tmips16-e.d: Likewise.
	* gas/mips/mipsel16-e.d: Likewise.
	* gas/mips/tmipsel16-e.d: Likewise.

	* gas/mips/and.s: Adjust padding.
	* gas/mips/beq.s: Likewise.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.s: Likewise.
	* gas/mips/jal.s: Likewise.
	* gas/mips/li.s: Likewise.
	* gas/mips/mips4.s: Likewise.
	* gas/mips/mips4-fp.s: Likewise.
	* gas/mips/relax.s: Likewise.
	* gas/mips/and.d: Update accordingly.
	* gas/mips/elf-jal.d: Likewise.
	* gas/mips/jal.d: Likewise.
	* gas/mips/li.d: Likewise.
	* gas/mips/relax-at.d: Likewise.
	* gas/mips/relax.d: Likewise.

include/elf/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (R_MICROMIPS_min): New relocations.
	(R_MICROMIPS_26_S1): Likewise.
	(R_MICROMIPS_HI16, R_MICROMIPS_LO16): Likewise.
	(R_MICROMIPS_GPREL16, R_MICROMIPS_LITERAL): Likewise.
	(R_MICROMIPS_GOT16, R_MICROMIPS_PC7_S1): Likewise.
	(R_MICROMIPS_PC10_S1, R_MICROMIPS_PC16_S1): Likewise.
	(R_MICROMIPS_CALL16, R_MICROMIPS_GOT_DISP): Likewise.
	(R_MICROMIPS_GOT_PAGE, R_MICROMIPS_GOT_OFST): Likewise.
	(R_MICROMIPS_GOT_HI16, R_MICROMIPS_GOT_LO16): Likewise.
	(R_MICROMIPS_SUB, R_MICROMIPS_HIGHER): Likewise.
	(R_MICROMIPS_HIGHEST, R_MICROMIPS_CALL_HI16): Likewise.
	(R_MICROMIPS_CALL_LO16, R_MICROMIPS_SCN_DISP): Likewise.
	(R_MICROMIPS_JALR, R_MICROMIPS_HI0_LO16): Likewise.
	(R_MICROMIPS_TLS_GD, R_MICROMIPS_TLS_LDM): Likewise.
	(R_MICROMIPS_TLS_DTPREL_HI, R_MICROMIPS_TLS_DTPREL_LO): Likewise.
	(R_MICROMIPS_TLS_GOTTPREL): Likewise.
	(R_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(R_MICROMIPS_TLS_TPREL_LO16): Likewise.
	(R_MICROMIPS_GPREL7_S2, R_MICROMIPS_PC23_S2): Likewise.
	(R_MICROMIPS_max): Likewise.
	(EF_MIPS_ARCH_ASE_MICROMIPS): New macro.
	(STO_MIPS_ISA, STO_MIPS_FLAGS): Likewise.
	(ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT): Likewise.
	(STO_MICROMIPS): Likewise.
	(ELF_ST_IS_MICROMIPS, ELF_ST_SET_MICROMIPS): Likewise.
	(ELF_ST_IS_COMPRESSED): Likewise.
	(STO_MIPS_PLT, STO_MIPS_PIC): Rework.
	(ELF_ST_IS_MIPS_PIC, ELF_ST_SET_MIPS_PIC): Likewise.
	(STO_MIPS16, ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): Likewise.

include/opcode/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (OP_MASK_EXTLSB, OP_SH_EXTLSB): New macros.
	(OP_MASK_STYPE, OP_SH_STYPE): Likewise.
	(OP_MASK_CODE10, OP_SH_CODE10): Likewise.
	(OP_MASK_TRAP, OP_SH_TRAP): Likewise.
	(OP_MASK_OFFSET12, OP_SH_OFFSET12): Likewise.
	(OP_MASK_OFFSET10, OP_SH_OFFSET10): Likewise.
	(OP_MASK_RS3, OP_SH_RS3): Likewise.
	(OP_MASK_MB, OP_SH_MB, OP_MASK_MC, OP_SH_MC): Likewise.
	(OP_MASK_MD, OP_SH_MD, OP_MASK_ME, OP_SH_ME): Likewise.
	(OP_MASK_MF, OP_SH_MF, OP_MASK_MG, OP_SH_MG): Likewise.
	(OP_MASK_MJ, OP_SH_MJ, OP_MASK_ML, OP_SH_ML): Likewise.
	(OP_MASK_MP, OP_SH_MP, OP_MASK_MQ, OP_SH_MQ): Likewise.
	(OP_MASK_IMMA, OP_SH_IMMA, OP_MASK_IMMB, OP_SH_IMMB): Likewise.
	(OP_MASK_IMMC, OP_SH_IMMC, OP_MASK_IMMF, OP_SH_IMMF): Likewise.
	(OP_MASK_IMMG, OP_SH_IMMG, OP_MASK_IMMH, OP_SH_IMMH): Likewise.
	(OP_MASK_IMMI, OP_SH_IMMI, OP_MASK_IMMJ, OP_SH_IMMJ): Likewise.
	(OP_MASK_IMML, OP_SH_IMML, OP_MASK_IMMM, OP_SH_IMMM): Likewise.
	(OP_MASK_IMMN, OP_SH_IMMN, OP_MASK_IMMO, OP_SH_IMMO): Likewise.
	(OP_MASK_IMMP, OP_SH_IMMP, OP_MASK_IMMQ, OP_SH_IMMQ): Likewise.
	(OP_MASK_IMMU, OP_SH_IMMU, OP_MASK_IMMW, OP_SH_IMMW): Likewise.
	(OP_MASK_IMMX, OP_SH_IMMX, OP_MASK_IMMY, OP_SH_IMMY): Likewise.
	(INSN_WRITE_GPR_S): New macro.
	(INSN2_BRANCH_DELAY_16BIT, INSN2_BRANCH_DELAY_32BIT): Likewise.
	(INSN2_READ_FPR_D): Likewise.
	(INSN2_MOD_GPR_MB, INSN2_MOD_GPR_MC): Likewise.
	(INSN2_MOD_GPR_MD, INSN2_MOD_GPR_ME): Likewise.
	(INSN2_MOD_GPR_MF, INSN2_MOD_GPR_MG): Likewise.
	(INSN2_MOD_GPR_MJ, INSN2_MOD_GPR_MP): Likewise.
	(INSN2_MOD_GPR_MQ, INSN2_MOD_SP): Likewise.
	(INSN2_READ_GPR_31, INSN2_READ_GP, INSN2_READ_PC): Likewise.
	(INSN2_UNCOND_BRANCH, INSN2_COND_BRANCH): Likewise.
	(INSN2_MOD_GPR_MHI, INSN2_MOD_GPR_MM, INSN2_MOD_GPR_MN): Likewise.
	(CPU_MICROMIPS): New macro.
	(M_BC1FL, M_BC1TL, M_BC2FL, M_BC2TL): New enum values.
	(M_BEQL, M_BGEZ, M_BGEZL, M_BGEZALL, M_BGTZ, M_BGTZL): Likewise.
	(M_BLEZ, M_BLEZL, M_BLTZ, M_BLTZL, M_BLTZALL, M_BNEL): Likewise.
	(M_CACHE_OB, M_JALS_1, M_JALS_2, M_JALS_A): Likewise.
	(M_LDC2_OB, M_LDL_OB, M_LDM_AB, M_LDM_OB): Likewise.
	(M_LDP_AB, M_LDP_OB, M_LDR_OB, M_LL_OB, M_LLD_OB): Likewise.
	(M_LWC2_OB, M_LWL_OB, M_LWM_AB, M_LWM_OB): Likewise.
	(M_LWP_AB, M_LWP_OB, M_LWR_OB): Likewise.
	(M_LWU_OB, M_PREF_OB, M_SC_OB, M_SCD_OB): Likewise.
	(M_SDC2_OB, M_SDL_OB, M_SDM_AB, M_SDM_OB): Likewise.
	(M_SDP_AB, M_SDP_OB, M_SDR_OB): Likewise.
	(M_SWC2_OB, M_SWL_OB, M_SWM_AB, M_SWM_OB): Likewise.
	(M_SWP_AB, M_SWP_OB, M_SWR_OB): Likewise.
	(MICROMIPSOP_MASK_MAJOR, MICROMIPSOP_SH_MAJOR): New macros.
	(MICROMIPSOP_MASK_IMMEDIATE, MICROMIPSOP_SH_IMMEDIATE): Likewise.
	(MICROMIPSOP_MASK_DELTA, MICROMIPSOP_SH_DELTA): Likewise.
	(MICROMIPSOP_MASK_CODE10, MICROMIPSOP_SH_CODE10): Likewise.
	(MICROMIPSOP_MASK_TRAP, MICROMIPSOP_SH_TRAP): Likewise.
	(MICROMIPSOP_MASK_SHAMT, MICROMIPSOP_SH_SHAMT): Likewise.
	(MICROMIPSOP_MASK_TARGET, MICROMIPSOP_SH_TARGET): Likewise.
	(MICROMIPSOP_MASK_EXTLSB, MICROMIPSOP_SH_EXTLSB): Likewise.
	(MICROMIPSOP_MASK_EXTMSBD, MICROMIPSOP_SH_EXTMSBD): Likewise.
	(MICROMIPSOP_MASK_INSMSB, MICROMIPSOP_SH_INSMSB): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_SEL, MICROMIPSOP_SH_SEL): Likewise.
	(MICROMIPSOP_MASK_OFFSET12, MICROMIPSOP_SH_OFFSET12): Likewise.
	(MICROMIPSOP_MASK_3BITPOS, MICROMIPSOP_SH_3BITPOS): Likewise.
	(MICROMIPSOP_MASK_STYPE, MICROMIPSOP_SH_STYPE): Likewise.
	(MICROMIPSOP_MASK_OFFSET10, MICROMIPSOP_SH_OFFSET10): Likewise.
	(MICROMIPSOP_MASK_RS, MICROMIPSOP_SH_RS): Likewise.
	(MICROMIPSOP_MASK_RT, MICROMIPSOP_SH_RT): Likewise.
	(MICROMIPSOP_MASK_RD, MICROMIPSOP_SH_RD): Likewise.
	(MICROMIPSOP_MASK_FS, MICROMIPSOP_SH_FS): Likewise.
	(MICROMIPSOP_MASK_FT, MICROMIPSOP_SH_FT): Likewise.
	(MICROMIPSOP_MASK_FD, MICROMIPSOP_SH_FD): Likewise.
	(MICROMIPSOP_MASK_FR, MICROMIPSOP_SH_FR): Likewise.
	(MICROMIPSOP_MASK_RS3, MICROMIPSOP_SH_RS3): Likewise.
	(MICROMIPSOP_MASK_PREFX, MICROMIPSOP_SH_PREFX): Likewise.
	(MICROMIPSOP_MASK_BCC, MICROMIPSOP_SH_BCC): Likewise.
	(MICROMIPSOP_MASK_CCC, MICROMIPSOP_SH_CCC): Likewise.
	(MICROMIPSOP_MASK_COPZ, MICROMIPSOP_SH_COPZ): Likewise.
	(MICROMIPSOP_MASK_MB, MICROMIPSOP_SH_MB): Likewise.
	(MICROMIPSOP_MASK_MC, MICROMIPSOP_SH_MC): Likewise.
	(MICROMIPSOP_MASK_MD, MICROMIPSOP_SH_MD): Likewise.
	(MICROMIPSOP_MASK_ME, MICROMIPSOP_SH_ME): Likewise.
	(MICROMIPSOP_MASK_MF, MICROMIPSOP_SH_MF): Likewise.
	(MICROMIPSOP_MASK_MG, MICROMIPSOP_SH_MG): Likewise.
	(MICROMIPSOP_MASK_MH, MICROMIPSOP_SH_MH): Likewise.
	(MICROMIPSOP_MASK_MI, MICROMIPSOP_SH_MI): Likewise.
	(MICROMIPSOP_MASK_MJ, MICROMIPSOP_SH_MJ): Likewise.
	(MICROMIPSOP_MASK_ML, MICROMIPSOP_SH_ML): Likewise.
	(MICROMIPSOP_MASK_MM, MICROMIPSOP_SH_MM): Likewise.
	(MICROMIPSOP_MASK_MN, MICROMIPSOP_SH_MN): Likewise.
	(MICROMIPSOP_MASK_MP, MICROMIPSOP_SH_MP): Likewise.
	(MICROMIPSOP_MASK_MQ, MICROMIPSOP_SH_MQ): Likewise.
	(MICROMIPSOP_MASK_IMMA, MICROMIPSOP_SH_IMMA): Likewise.
	(MICROMIPSOP_MASK_IMMB, MICROMIPSOP_SH_IMMB): Likewise.
	(MICROMIPSOP_MASK_IMMC, MICROMIPSOP_SH_IMMC): Likewise.
	(MICROMIPSOP_MASK_IMMD, MICROMIPSOP_SH_IMMD): Likewise.
	(MICROMIPSOP_MASK_IMME, MICROMIPSOP_SH_IMME): Likewise.
	(MICROMIPSOP_MASK_IMMF, MICROMIPSOP_SH_IMMF): Likewise.
	(MICROMIPSOP_MASK_IMMG, MICROMIPSOP_SH_IMMG): Likewise.
	(MICROMIPSOP_MASK_IMMH, MICROMIPSOP_SH_IMMH): Likewise.
	(MICROMIPSOP_MASK_IMMI, MICROMIPSOP_SH_IMMI): Likewise.
	(MICROMIPSOP_MASK_IMMJ, MICROMIPSOP_SH_IMMJ): Likewise.
	(MICROMIPSOP_MASK_IMML, MICROMIPSOP_SH_IMML): Likewise.
	(MICROMIPSOP_MASK_IMMM, MICROMIPSOP_SH_IMMM): Likewise.
	(MICROMIPSOP_MASK_IMMN, MICROMIPSOP_SH_IMMN): Likewise.
	(MICROMIPSOP_MASK_IMMO, MICROMIPSOP_SH_IMMO): Likewise.
	(MICROMIPSOP_MASK_IMMP, MICROMIPSOP_SH_IMMP): Likewise.
	(MICROMIPSOP_MASK_IMMQ, MICROMIPSOP_SH_IMMQ): Likewise.
	(MICROMIPSOP_MASK_IMMU, MICROMIPSOP_SH_IMMU): Likewise.
	(MICROMIPSOP_MASK_IMMW, MICROMIPSOP_SH_IMMW): Likewise.
	(MICROMIPSOP_MASK_IMMX, MICROMIPSOP_SH_IMMX): Likewise.
	(MICROMIPSOP_MASK_IMMY, MICROMIPSOP_SH_IMMY): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_CODE20, MICROMIPSOP_SH_CODE20): Likewise.
	(MICROMIPSOP_MASK_PERFREG, MICROMIPSOP_SH_PERFREG): Likewise.
	(MICROMIPSOP_MASK_CODE19, MICROMIPSOP_SH_CODE19): Likewise.
	(MICROMIPSOP_MASK_ALN, MICROMIPSOP_SH_ALN): Likewise.
	(MICROMIPSOP_MASK_VECBYTE, MICROMIPSOP_SH_VECBYTE): Likewise.
	(MICROMIPSOP_MASK_VECALIGN, MICROMIPSOP_SH_VECALIGN): Likewise.
	(MICROMIPSOP_MASK_DSPACC, MICROMIPSOP_SH_DSPACC): Likewise.
	(MICROMIPSOP_MASK_DSPACC_S, MICROMIPSOP_SH_DSPACC_S): Likewise.
	(MICROMIPSOP_MASK_DSPSFT, MICROMIPSOP_SH_DSPSFT): Likewise.
	(MICROMIPSOP_MASK_DSPSFT_7, MICROMIPSOP_SH_DSPSFT_7): Likewise.
	(MICROMIPSOP_MASK_SA3, MICROMIPSOP_SH_SA3): Likewise.
	(MICROMIPSOP_MASK_SA4, MICROMIPSOP_SH_SA4): Likewise.
	(MICROMIPSOP_MASK_IMM8, MICROMIPSOP_SH_IMM8): Likewise.
	(MICROMIPSOP_MASK_IMM10, MICROMIPSOP_SH_IMM10): Likewise.
	(MICROMIPSOP_MASK_WRDSP, MICROMIPSOP_SH_WRDSP): Likewise.
	(MICROMIPSOP_MASK_RDDSP, MICROMIPSOP_SH_RDDSP): Likewise.
	(MICROMIPSOP_MASK_BP, MICROMIPSOP_SH_BP): Likewise.
	(MICROMIPSOP_MASK_MT_U, MICROMIPSOP_SH_MT_U): Likewise.
	(MICROMIPSOP_MASK_MT_H, MICROMIPSOP_SH_MT_H): Likewise.
	(MICROMIPSOP_MASK_MTACC_T, MICROMIPSOP_SH_MTACC_T): Likewise.
	(MICROMIPSOP_MASK_MTACC_D, MICROMIPSOP_SH_MTACC_D): Likewise.
	(MICROMIPSOP_MASK_BBITIND, MICROMIPSOP_SH_BBITIND): Likewise.
	(MICROMIPSOP_MASK_CINSPOS, MICROMIPSOP_SH_CINSPOS): Likewise.
	(MICROMIPSOP_MASK_CINSLM1, MICROMIPSOP_SH_CINSLM1): Likewise.
	(MICROMIPSOP_MASK_SEQI, MICROMIPSOP_SH_SEQI): Likewise.
	(micromips_opcodes): New declaration.
	(bfd_micromips_num_opcodes): Likewise.

ld/testsuite/
2011-02-25  Catherine Moore  <clm@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* lib/ld-lib.exp (run_dump_test): Support distinct assembler
	flags for the same source named multiple times.
	* ld-mips-elf/jalx-1.s: New test source.
	* ld-mips-elf/jalx-1.d: New test output.
	* ld-mips-elf/jalx-1.ld: New test linker script.
	* ld-mips-elf/jalx-2-main.s: New test source.
	* ld-mips-elf/jalx-2-ex.s: Likewise.
	* ld-mips-elf/jalx-2-printf.s: Likewise.
	* ld-mips-elf/jalx-2.dd: New test output.
	* ld-mips-elf/jalx-2.ld: New test linker script.
	* ld-mips-elf/mips16-and-micromips.d: New test.
	* ld-mips-elf/mips-elf.exp: Run the new tests

opcodes/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* micromips-opc.c: New file.
	* mips-dis.c (micromips_to_32_reg_b_map): New array.
	(micromips_to_32_reg_c_map, micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map, micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map, micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): Likewise.
	(micromips_ase): New variable.
	(is_micromips): New function.
	(set_default_mips_dis_options): Handle microMIPS ASE.
	(print_insn_micromips): New function.
	(is_compressed_mode_p): Likewise.
	(_print_insn_mips): Handle microMIPS instructions.
	* Makefile.am (CFILES): Add micromips-opc.c.
	* configure.in (bfd_mips_arch): Add micromips-opc.lo.
	* Makefile.in: Regenerate.
	* configure: Regenerate.

	* mips-dis.c (micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_n_map): New macro.
@
text
@d486 1
a486 1
/* Return true if the given CPU supports microMIPS.  */
d2144 1
a2144 1
   are selected; they have to be named separately if needed.  */
d2153 2
a2155 2
  char *s_reset = *s;
  char *s_end_of_list = *s;
d2180 1
a2180 1
      s_end_of_list = *s;
d2187 1
a2187 1
    *s = s_end_of_list;
d2666 6
d2674 1
a2674 2
  return (reloc == BFD_RELOC_MIPS_GOT16
	  || reloc == BFD_RELOC_MIPS16_GOT16
d2681 1
a2681 2
  return (reloc == BFD_RELOC_HI16_S
	  || reloc == BFD_RELOC_MIPS16_HI16_S
d2688 1
a2688 2
  return (reloc == BFD_RELOC_LO16
	  || reloc == BFD_RELOC_MIPS16_LO16
a2692 7
jmp_reloc_p (bfd_reloc_code_real_type reloc)
{
  return (reloc == BFD_RELOC_MIPS_JMP
	  || reloc == BFD_RELOC_MICROMIPS_JMP);
}

static inline bfd_boolean
d2695 1
a2695 2
  return (reloc == BFD_RELOC_MIPS_JALR
	  || reloc == BFD_RELOC_MICROMIPS_JALR);
d2891 1
a2891 2
/* Return the mask of core registers that instruction IP may
   read or write.  */
d2896 1
a2896 1
  unsigned long pinfo, pinfo2;
a2899 1
  pinfo = ip->insn_mo->pinfo;
d2965 1
a2965 1
  else if (mips_opts.micromips)
d2967 2
d2970 1
a2970 1
	mask |= 1 << EXTRACT_OPERAND (1, RT, *ip);
d2972 3
a2974 1
	mask |= 1 << EXTRACT_OPERAND (1, RS, *ip);
a2976 11
      if (pinfo2 & INSN2_READ_GP)
	mask |= 1 << GP;
    }
  else
    {
      if (pinfo2 & INSN2_READ_GPR_D)
	mask |= 1 << EXTRACT_OPERAND (0, RD, *ip);
      if (pinfo & INSN_READ_GPR_T)
	mask |= 1 << EXTRACT_OPERAND (0, RT, *ip);
      if (pinfo & INSN_READ_GPR_S)
	mask |= 1 << EXTRACT_OPERAND (0, RS, *ip);
d2978 1
a2978 1
	mask |= 1 << EXTRACT_OPERAND (0, RZ, *ip);
a3011 11
  else if (mips_opts.micromips)
    {
      if (pinfo & INSN_WRITE_GPR_D)
	mask |= 1 << EXTRACT_OPERAND (1, RD, *ip);
      if (pinfo & INSN_WRITE_GPR_T)
	mask |= 1 << EXTRACT_OPERAND (1, RT, *ip);
      if (pinfo2 & INSN2_WRITE_GPR_S)
	mask |= 1 << EXTRACT_OPERAND (1, RS, *ip);
      if (pinfo & INSN_WRITE_GPR_31)
	mask |= 1 << RA;
    }
d3018 2
d3040 1
a3040 1
  if (mips_opts.micromips)
d3043 1
a3043 10
	mask |= 1 << EXTRACT_OPERAND (1, FD, *ip);
      if (pinfo & INSN_READ_FPR_S)
	mask |= 1 << EXTRACT_OPERAND (1, FS, *ip);
      if (pinfo & INSN_READ_FPR_T)
	mask |= 1 << EXTRACT_OPERAND (1, FT, *ip);
      if (pinfo & INSN_READ_FPR_R)
	mask |= 1 << EXTRACT_OPERAND (1, FR, *ip);
    }
  else if (!mips_opts.mips16)
    {
d3071 1
a3071 10
  if (mips_opts.micromips)
    {
      if (pinfo2 & INSN_WRITE_FPR_D)
	mask |= 1 << EXTRACT_OPERAND (1, FD, *ip);
      if (pinfo & INSN_WRITE_FPR_S)
	mask |= 1 << EXTRACT_OPERAND (1, FS, *ip);
      if (pinfo & INSN_WRITE_FPR_T)
	mask |= 1 << EXTRACT_OPERAND (1, FT, *ip);
    }
  else if (!mips_opts.mips16)
d3278 1
d3683 3
a3685 2
     branch's one, we cannot do the swap.  This does not apply to the
     mips16, which uses variant frags for different purposes.  */
d3745 10
a3754 11
  if (mips_opts.micromips)
    {
      pinfo2 = ip->insn_mo->pinfo;
      if ((pinfo2 & INSN2_BRANCH_DELAY_16BIT)
	  && insn_length (history) != 2)
	return FALSE;

      if ((pinfo2 & INSN2_BRANCH_DELAY_32BIT)
	  && insn_length (history) != 4)
	return FALSE;
    }
d3947 1
a3948 1
  enum append_method method;
d3950 1
a3950 1
  if (mips_fix_loongson2f && !mips_opts.micromips)
d4155 3
a4157 3
     and for MIPS16/microMIPS code also prevents a debugger from placing
     a breakpoint in the middle of the branch (and corrupting code if
     software breakpoints are used).  */
d4293 1
d4304 2
a4305 1
      howto = bfd_reloc_type_lookup (stdoutput, final_type[i - 1]);
d4315 3
a4317 2
	  
      howto = bfd_reloc_type_lookup (stdoutput, final_type[0]);
d4321 2
a4322 1
				 howto->pc_relative, final_type[0]);
d4325 1
a4325 2
      if (reloc_type[0] == BFD_RELOC_MIPS16_JMP
	  && ip->fixp[0]->fx_addsy)
d17766 1
a17766 2
      unsigned long jal, jalr, jr;

d17806 1
a17806 1
      /* Handle 32-bit branches that fit or forced to fit.  */
d17879 2
a17880 12
      /* Check the short-delay-slot bit.  */
      if (al && (insn & 0x02000000) != 0)
	{
	  jal = 0x74000000;				/* jals  */
	  jalr = 0x45e0;				/* jalrs  */
	}
      else
	{
	  jal = 0xf4000000;				/* jal  */
	  jalr = 0x45c0;				/* jalr  */
	}
      jr = compact ? 0x45a0 : 0x4580;			/* jr/c  */
d17950 2
d17976 2
@


1.478
log
@gas/
2011-07-24  Maciej W. Rozycki  <macro@@codesourcery.com>

	* config/tc-mips.c (mips_ip): Make a copy of the instruction's
	mnemonic and use it for further processing.
@
text
@d94 2
d226 5
d295 1
a295 1
  /* mips16 */ -1, /* noreorder */ 0, /* at */ ATREG,
d318 3
d412 4
a415 1
  ((ISA) == ISA_MIPS64R2)
d422 3
a424 1
   || mips_opts.ase_smartmips)
d486 3
d527 1
d534 6
a539 4
   level I.  */
#define gpr_interlocks \
  (mips_opts.isa != ISA_MIPS1  \
   || mips_opts.arch == CPU_R3900)
d547 2
a548 1
   levels I, II, and III.  */
d555 1
d562 6
a567 2
   requires at MIPS ISA level I.  */
#define cop_mem_interlocks (mips_opts.isa != ISA_MIPS1)
d582 6
d644 3
d736 4
a739 1
static struct mips_cl_insn nop_insn, mips16_nop_insn;
d742 5
a746 1
#define NOP_INSN (mips_opts.mips16 ? &mips16_nop_insn : &nop_insn)
d813 90
d984 12
d1016 3
d1142 49
d1201 4
d1227 9
a1235 2
#define INSERT_OPERAND(FIELD, INSN, VALUE) \
  INSERT_BITS ((INSN).insn_opcode, VALUE, OP_MASK_##FIELD, OP_SH_##FIELD)
d1241 5
a1245 2
#define EXTRACT_OPERAND(FIELD, INSN) \
  EXTRACT_BITS ((INSN).insn_opcode, OP_MASK_##FIELD, OP_SH_##FIELD)
d1251 3
d1280 4
d1290 17
d1319 2
a1320 1
  (struct mips_cl_insn *, expressionS *, bfd_reloc_code_real_type *);
d1372 3
d1527 2
d1547 8
d1572 3
a1574 1
/* These are set by mips16_ip if an explicit extension is used.  */
d1576 1
a1576 1
static bfd_boolean mips16_small, mips16_ext;
d1628 12
d1645 5
a1649 1
  if (!mips_opts.mips16)
a1650 1
  return insn->mips16_absolute_jump_p || insn->use_extend ? 4 : 2;
d1674 1
a1674 1
/* Record the current MIPS16 mode in now_seg.  */
d1677 1
a1677 1
mips_record_mips16_mode (void)
d1684 2
d1694 1
a1694 1
  if (!mips_opts.mips16)
d1696 14
d1724 1
a1724 1
  mips_record_mips16_mode ();
d2077 4
d2134 61
d2260 37
d2382 38
d2600 1
a2600 1
	append_insn (&insn, &imm_expr, imm_reloc);
d2602 1
a2602 1
	append_insn (&insn, &offset_expr, offset_reloc);
d2604 1
a2604 1
	append_insn (&insn, NULL, unused_reloc);
d2631 35
d2668 3
a2670 1
  return reloc == BFD_RELOC_MIPS_GOT16 || reloc == BFD_RELOC_MIPS16_GOT16;
d2676 3
a2678 1
  return reloc == BFD_RELOC_HI16_S || reloc == BFD_RELOC_MIPS16_HI16_S;
d2684 17
a2700 1
  return reloc == BFD_RELOC_LO16 || reloc == BFD_RELOC_MIPS16_LO16;
d2723 3
a2725 1
  return mips16_reloc_p (reloc) ? BFD_RELOC_MIPS16_LO16 : BFD_RELOC_LO16;
d2759 1
a2759 1
      if (reg == EXTRACT_OPERAND (RT, history[0]))
d2780 2
a2781 2
      /* mips16 text labels are stored as odd.  */
      if (mips_opts.mips16)
d2809 4
a2812 4
/* Mark instruction labels in mips16 mode.  This permits the linker to
   handle them specially, such as generating jalx instructions when
   needed.  We also make them odd for the duration of the assembly, in
   order to generate the right sort of code.  We will make them even
d2818 1
a2818 1
mips16_mark_labels (void)
d2823 1
a2823 2
  if (!mips_opts.mips16)
    return;
d2831 6
a2836 1
	S_SET_OTHER (label, ELF_ST_SET_MIPS16 (S_GET_OTHER (label)));
d2842 1
a2842 1
	   the final value of the symbol may or may not be MIPS16.  */
d2896 47
d2951 1
a2951 1
  mask = 0;
d2972 11
d2986 1
a2986 1
	mask |= 1 << EXTRACT_OPERAND (RD, *ip);
d2988 1
a2988 1
	mask |= 1 << EXTRACT_OPERAND (RT, *ip);
d2990 1
a2990 1
	mask |= 1 << EXTRACT_OPERAND (RS, *ip);
d2992 1
a2992 1
	mask |= 1 << EXTRACT_OPERAND (RZ, *ip);
d3006 1
a3006 1
  mask = 0;
d3026 11
d3040 1
a3040 1
	mask |= 1 << EXTRACT_OPERAND (RD, *ip);
d3042 1
a3042 1
	mask |= 1 << EXTRACT_OPERAND (RT, *ip);
d3046 1
a3046 1
	mask |= 1 << EXTRACT_OPERAND (RZ, *ip);
d3063 12
a3074 1
  if (!mips_opts.mips16)
d3077 1
a3077 1
	mask |= 1 << EXTRACT_OPERAND (FS, *ip);
d3079 1
a3079 1
	mask |= 1 << EXTRACT_OPERAND (FT, *ip);
d3081 1
a3081 1
	mask |= 1 << EXTRACT_OPERAND (FR, *ip);
d3083 1
a3083 1
	mask |= 1 << EXTRACT_OPERAND (FZ, *ip);
d3103 10
a3112 1
  if (!mips_opts.mips16)
d3115 1
a3115 1
	mask |= 1 << EXTRACT_OPERAND (FD, *ip);
d3117 1
a3117 1
	mask |= 1 << EXTRACT_OPERAND (FS, *ip);
d3119 1
a3119 1
	mask |= 1 << EXTRACT_OPERAND (FT, *ip);
d3121 1
a3121 1
	mask |= 1 << EXTRACT_OPERAND (FZ, *ip);
d3189 1
d3191 1
a3191 1
      && INSN2_USES_GPR (EXTRACT_OPERAND (RD, *insn1)))
d3196 1
a3196 1
  if (mips_fix_24k)
d3214 1
a3214 1
  if (mips_fix_vr4120)
d3229 1
a3229 1
  if (!mips_opts.mips16)
d3238 1
a3238 1
	  if (INSN2_USES_GPR (EXTRACT_OPERAND (RT, *insn1)))
d3546 1
a3546 1
  if (mips_fix_vr4130)
d3553 1
a3553 1
  if (mips_fix_24k)
d3623 1
d3634 1
d3645 1
a3645 1
      sreg = EXTRACT_OPERAND (RS, *ip);
d3675 1
a3675 1
  unsigned long pinfo, prev_pinfo;
d3678 4
d3725 1
a3725 1
  if (!mips_opts.mips16
d3782 13
d3857 119
d3978 2
a3979 1
   RELOC_TYPE.  */
d3983 1
a3983 1
	     bfd_reloc_code_real_type *reloc_type)
d3985 1
a3985 1
  unsigned long prev_pinfo, pinfo;
d3987 1
d3990 1
a3990 1
  if (mips_fix_loongson2f)
d3993 1
a3993 2
  /* Mark instruction labels in mips16 mode.  */
  mips16_mark_labels ();
d3996 1
d3999 1
d4001 10
d4052 11
a4062 5
	  if ((address_expr->X_add_number & 3) != 0)
	    as_bad (_("jump to misaligned address (0x%lx)"),
	            (unsigned long) address_expr->X_add_number);
	  ip->insn_opcode |= (address_expr->X_add_number >> 2) & 0x3ffffff;
	  ip->complete_p = 0;
d4077 18
a4094 11
	  if ((address_expr->X_add_number & 3) != 0)
	    as_bad (_("branch to misaligned address (0x%lx)"),
	            (unsigned long) address_expr->X_add_number);
	  if (!mips_relax_branch)
	    {
	      if ((address_expr->X_add_number + 0x20000) & ~0x3ffff)
		as_bad (_("branch address range overflow (0x%lx)"),
			(unsigned long) address_expr->X_add_number);
	      ip->insn_opcode |= (address_expr->X_add_number >> 2) & 0xffff;
	    }
	  ip->complete_p = 0;
d4174 1
a4174 1
	  prev_nop_frag->fr_fix -= mips_opts.mips16 ? 2 : 4;
d4188 3
a4190 2
     For MIPS16 debug info we want to use ISA-encoded addresses,
     so we use -1 for an address higher by one than the current one.
d4195 2
a4196 2
     and for MIPS16 code also prevents a debugger from placing a
     breakpoint in the middle of the branch (and corrupting code if
d4198 1
a4198 1
  dwarf2_emit_insn ((mips_opts.mips16 ? -1 : 0)
d4202 16
a4217 1
  if (address_expr
d4220 1
a4220 10
	  || pinfo & INSN_COND_BRANCH_LIKELY)
      && mips_relax_branch
      /* Don't try branch relaxation within .set nomacro, or within
	 .set noat if we use $at for PIC computations.  If it turns
	 out that the branch was out-of-range, we'll get an error.  */
      && !mips_opts.warn_about_macros
      && (mips_opts.at || mips_pic == NO_PIC)
      /* Don't relax BPOSGE32/64 as they have no complementing branches.  */
      && !(ip->insn_mo->membership & (INSN_DSP64 | INSN_DSP))
      && !mips_opts.mips16)
d4238 31
a4268 1
  else if (*reloc_type > BFD_RELOC_UNUSED)
d4271 1
a4271 1
      gas_assert (mips_opts.mips16 && address_expr != NULL);
d4275 1
a4275 1
			 mips16_small, mips16_ext,
d4304 1
a4304 1
	  mips_relax.sizes[mips_relax.sequence - 1] += 4;
d4308 6
a4313 1
	mips_macro_warning.sizes[0] += 4;
d4315 6
a4320 1
	mips_macro_warning.sizes[1] += 4;
d4332 1
d4336 5
d4343 1
a4343 5
      for (i = 1; i < 3; i++)
	if (reloc_type[i] == BFD_RELOC_UNUSED)
	  break;

      howto = bfd_reloc_type_lookup (stdoutput, reloc_type[i - 1]);
d4349 2
a4350 1
	  as_bad (_("Unsupported MIPS relocation number %d"), reloc_type[i - 1]);
d4354 1
d4358 1
a4358 2
				 reloc_type[0] == BFD_RELOC_16_PCREL_S2,
				 reloc_type[0]);
d4421 1
a4421 1
				   FALSE, reloc_type[i]);
d4442 14
a4455 3
      emit_nop ();
      if (mips_relax.sequence)
	mips_relax.sizes[mips_relax.sequence - 1] += 4;
d4476 5
d4510 7
d4575 1
a4575 1
	      frag_grow (mips_opts.mips16 ? nops * 2 : nops * 4);
d4591 1
a4591 1
      mips16_mark_labels ();
d4610 1
a4610 1
				* (mips_opts.mips16 ? 2 : 4));
d4623 3
d4631 14
d4647 5
a4651 3
/* Given that a macro is longer than 4 bytes, return the appropriate warning
   for it.  Return null if no warning is needed.  SUBTYPE is a bitmask of
   RELAX_DELAY_SLOT and RELAX_NOMACRO.  */
d4661 7
d4677 18
a4694 1
  if (mips_macro_warning.sizes[0] > 4 || mips_macro_warning.sizes[1] > 4)
d4696 1
a4696 5
      relax_substateT subtype;

      /* Set up the relaxation warning flags.  */
      subtype = 0;
      if (mips_macro_warning.sizes[1] > mips_macro_warning.sizes[0])
d4702 1
d4704 58
a4761 17
      if (mips_macro_warning.sizes[0] > 4 && mips_macro_warning.sizes[1] > 4)
	{
	  /* Either the macro has a single implementation or both
	     implementations are longer than 4 bytes.  Emit the
	     warning now.  */
	  const char *msg = macro_warning (subtype);
	  if (msg != 0)
	    as_warn ("%s", msg);
	}
      else
	{
	  /* One implementation might need a warning but the other
	     definitely doesn't.  */
	  mips_macro_warning.first_frag->fr_subtype |= subtype;
	}
    }
}
d4789 4
a4792 1
  const struct mips_opcode *mo;
a4793 1
  bfd_reloc_code_real_type r[3];
d4808 4
a4811 3
  mo = (struct mips_opcode *) hash_find (op_hash, name);
  gas_assert (mo);
  gas_assert (strcmp (name, mo->name) == 0);
d4813 1
a4813 1
  while (1)
d4816 20
a4835 5
	 macros will never generate MDMX, MIPS-3D, or MT instructions.  */
      if (strcmp (fmt, mo->args) == 0
	  && mo->pinfo != INSN_MACRO
	  && is_opcode_valid (mo))
	break;
d4837 2
a4838 3
      ++mo;
      gas_assert (mo->name);
      gas_assert (strcmp (name, mo->name) == 0);
d4840 1
d4842 1
d4861 2
a4862 1
	      INSERT_OPERAND (SHAMT, insn, va_arg (args, int));
d4871 2
a4872 1
	      INSERT_OPERAND (INSMSB, insn, va_arg (args, int));
d4882 2
a4883 1
	      INSERT_OPERAND (EXTMSBD, insn, va_arg (args, int));
d4887 2
a4888 1
	      INSERT_OPERAND (SEQI, insn, va_arg (args, int));
d4897 2
a4898 1
	  INSERT_OPERAND (BP, insn, va_arg (args, int));
d4901 2
d4906 1
a4906 1
	  INSERT_OPERAND (RT, insn, va_arg (args, int));
d4910 2
a4911 1
	  INSERT_OPERAND (CODE, insn, va_arg (args, int));
d4914 2
d4917 1
a4917 2
	case 'W':
	  INSERT_OPERAND (FT, insn, va_arg (args, int));
a4919 1
	case 'd':
d4921 6
d4928 3
a4930 1
	  INSERT_OPERAND (RD, insn, va_arg (args, int));
d4934 1
d4938 2
a4939 3
	    INSERT_OPERAND (RT, insn, tmp);
	    INSERT_OPERAND (RD, insn, tmp);
	    continue;
d4941 1
d4945 2
a4946 1
	  INSERT_OPERAND (FS, insn, va_arg (args, int));
d4953 2
a4954 1
	  INSERT_OPERAND (SHAMT, insn, va_arg (args, int));
d4958 2
a4959 1
	  INSERT_OPERAND (FD, insn, va_arg (args, int));
d4963 2
a4964 1
	  INSERT_OPERAND (CODE20, insn, va_arg (args, int));
d4968 2
a4969 1
	  INSERT_OPERAND (CODE19, insn, va_arg (args, int));
d4973 2
a4974 1
	  INSERT_OPERAND (CODE2, insn, va_arg (args, int));
d4981 1
a4981 1
	  INSERT_OPERAND (RS, insn, va_arg (args, int));
d5023 4
d5046 2
a5047 1
	  INSERT_OPERAND (COPZ, insn, va_arg (args, unsigned long));
d5051 43
a5093 1
	  INSERT_OPERAND (CACHE, insn, va_arg (args, unsigned long));
d5104 1
a5104 1
  append_insn (&insn, ep, r);
d5223 1
a5223 1
  append_insn (&insn, ep, r);
d5258 1
a5258 1
macro_build_jalr (expressionS *ep)
d5260 4
d5271 10
a5280 1
  macro_build (NULL, "jalr", "d,s", RA, PIC_CALL_REG);
d5282 1
a5282 2
    fix_new_exp (frag_now, f - frag_now->fr_literal,
		 4, ep, FALSE, BFD_RELOC_MIPS_JALR);
a5290 8
  expressionS high_expr;
  const struct mips_opcode *mo;
  struct mips_cl_insn insn;
  bfd_reloc_code_real_type r[3]
    = {BFD_RELOC_UNUSED, BFD_RELOC_UNUSED, BFD_RELOC_UNUSED};
  const char *name = "lui";
  const char *fmt = "t,u";

d5293 1
a5293 10
  high_expr = *ep;

  if (high_expr.X_op == O_constant)
    {
      /* We can compute the instruction now without a relocation entry.  */
      high_expr.X_add_number = ((high_expr.X_add_number + 0x8000)
				>> 16) & 0xffff;
      *r = BFD_RELOC_UNUSED;
    }
  else
a5303 1
      *r = BFD_RELOC_HI16_S;
d5306 1
a5306 14
  mo = hash_find (op_hash, name);
  gas_assert (strcmp (name, mo->name) == 0);
  gas_assert (strcmp (fmt, mo->args) == 0);
  create_insn (&insn, mo);

  insn.insn_opcode = insn.insn_mo->match;
  INSERT_OPERAND (RT, insn, regnum);
  if (*r == BFD_RELOC_UNUSED)
    {
      insn.insn_opcode |= high_expr.X_add_number;
      append_insn (&insn, NULL, r);
    }
  else
    append_insn (&insn, &high_expr, r);
d5493 1
a5493 1
	  macro_build (ep, "lui", "t,u", reg, BFD_RELOC_HI16);
d5550 1
a5550 1
	      macro_build (&lo32, "lui", "t,u", reg, BFD_RELOC_HI16);
d5587 1
a5587 1
	      macro_build (NULL, (shift >= 32) ? "dsll32" : "dsll", "d,w,<",
d5639 1
a5639 1
		  macro_build (NULL, (bit >= 32) ? "dsll32" : "dsll", "d,w,<",
d5642 1
a5642 1
	      macro_build (NULL, (shift >= 32) ? "dsrl32" : "dsrl", "d,w,<",
d5659 1
a5659 1
	  macro_build (NULL, "dsll32", "d,w,<", reg, freg, 0);
d5669 2
a5670 2
	  macro_build (&lo32, "lui", "t,u", reg, BFD_RELOC_HI16);
	  macro_build (NULL, "dsrl32", "d,w,<", reg, reg, 0);
d5676 1
a5676 1
	  macro_build (NULL, "dsll", "d,w,<", reg, freg, 16);
d5682 1
a5682 1
      macro_build (NULL, "dsll", "d,w,<", reg, reg, 16);
d5755 2
a5756 2
	      macro_build (ep, "lui", "t,u", reg, BFD_RELOC_MIPS_HIGHEST);
	      macro_build (ep, "lui", "t,u", AT, BFD_RELOC_HI16_S);
d5760 1
a5760 1
	      macro_build (NULL, "dsll32", "d,w,<", reg, reg, 0);
d5766 1
a5766 1
	      macro_build (ep, "lui", "t,u", reg, BFD_RELOC_MIPS_HIGHEST);
d5769 1
a5769 1
	      macro_build (NULL, "dsll", "d,w,<", reg, reg, 16);
d5771 1
a5771 1
	      macro_build (NULL, "dsll", "d,w,<", reg, reg, 16);
d5881 1
a5881 1
	  macro_build (ep, "lui", "t,u", reg, BFD_RELOC_MIPS_GOT_HI16);
d5908 1
a5908 1
	  macro_build (ep, "lui", "t,u", reg, BFD_RELOC_MIPS_GOT_HI16);
d5951 8
a5958 2
  macro_build (NULL, HAVE_32BIT_GPRS ? "addu" : "daddu", "d,v,t",
	       dest, source, 0);
d6036 194
d6255 1
d6257 1
d6262 4
a6266 2
  int coproc = 0;
  int lr = 0;
d6268 3
a6270 1
  int call = 0;
d6278 3
a6280 3
  treg = EXTRACT_OPERAND (RT, *ip);
  dreg = EXTRACT_OPERAND (RD, *ip);
  sreg = breg = EXTRACT_OPERAND (RS, *ip);
d6283 5
d6298 5
a6302 4
      /* bgez $a0,.+12
	 move v0,$a0
	 sub v0,$zero,$a0
	 */
d6306 5
a6310 2
      expr1.X_add_number = 8;
      macro_build (&expr1, "bgez", "s,p", sreg);
d6316 2
d6334 10
a6343 1
      goto do_addi;
d6356 1
d6414 9
a6423 2
      s = "beq";
      goto beq_i;
a6424 3
      s = "beql";
      likely = 1;
      goto beq_i;
a6425 2
      s = "bne";
      goto beq_i;
a6426 3
      s = "bnel";
      likely = 1;
    beq_i:
d6428 2
d6431 3
a6433 2
	  macro_build (&offset_expr, s, "s,t,p", sreg, ZERO);
	  break;
d6435 4
a6438 3
      used_at = 1;
      load_register (AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (&offset_expr, s, "s,t,p", sreg, AT);
d6445 4
d6450 4
a6453 2
	  macro_build (&offset_expr, likely ? "bgezl" : "bgez", "s,p", sreg);
	  break;
d6455 9
a6463 8
      if (sreg == 0)
	{
	  macro_build (&offset_expr, likely ? "blezl" : "blez", "s,p", treg);
	  break;
	}
      used_at = 1;
      macro_build (NULL, "slt", "d,v,t", AT, sreg, treg);
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, ZERO);
d6487 1
a6487 1
	    macro_build (&offset_expr, "bnel", "s,t,p", ZERO, ZERO);
d6500 2
a6501 1
	  macro_build (&offset_expr, likely ? "bgezl" : "bgez", "s,p", sreg);
d6506 2
a6507 1
	  macro_build (&offset_expr, likely ? "bgtzl" : "bgtz", "s,p", sreg);
d6531 2
a6532 1
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, ZERO);
d6540 4
a6543 1
      if (sreg == 0)
d6545 4
a6548 3
	  macro_build (&offset_expr, likely ? "beql" : "beq",
		       "s,t,p", ZERO, treg);
	  break;
a6549 3
      used_at = 1;
      macro_build (NULL, "sltu", "d,v,t", AT, sreg, treg);
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, ZERO);
d6570 4
a6573 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
d6575 4
a6578 3
	  macro_build (&offset_expr, likely ? "bnel" : "bne",
		       "s,t,p", sreg, ZERO);
	  break;
a6579 3
      used_at = 1;
      set_at (sreg, 1);
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, ZERO);
d6586 4
d6591 4
a6594 7
	  macro_build (&offset_expr, likely ? "bgtzl" : "bgtz", "s,p", sreg);
	  break;
	}
      if (sreg == 0)
	{
	  macro_build (&offset_expr, likely ? "bltzl" : "bltz", "s,p", treg);
	  break;
a6595 3
      used_at = 1;
      macro_build (NULL, "slt", "d,v,t", AT, treg, sreg);
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, ZERO);
d6602 5
d6608 4
a6611 3
	  macro_build (&offset_expr, likely ? "bnel" : "bne",
		       "s,t,p", sreg, ZERO);
	  break;
a6612 5
      if (sreg == 0)
	goto do_false;
      used_at = 1;
      macro_build (NULL, "sltu", "d,v,t", AT, treg, sreg);
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, ZERO);
d6619 4
d6624 4
a6627 7
	  macro_build (&offset_expr, likely ? "blezl" : "blez", "s,p", sreg);
	  break;
	}
      if (sreg == 0)
	{
	  macro_build (&offset_expr, likely ? "bgezl" : "bgez", "s,p", treg);
	  break;
a6628 3
      used_at = 1;
      macro_build (NULL, "slt", "d,v,t", AT, treg, sreg);
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, ZERO);
d6655 4
d6660 4
a6663 2
	  macro_build (&offset_expr, likely ? "bltzl" : "bltz", "s,p", sreg);
	  break;
d6665 4
a6668 12
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
	{
	  macro_build (&offset_expr, likely ? "blezl" : "blez", "s,p", sreg);
	  break;
	}
      used_at = 1;
      set_at (sreg, 0);
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, ZERO);
      break;

    case M_BLEUL:
      likely = 1;
d6671 5
d6677 4
a6680 3
	  macro_build (&offset_expr, likely ? "beql" : "beq",
		       "s,t,p", sreg, ZERO);
	  break;
a6681 5
      if (sreg == 0)
	goto do_true;
      used_at = 1;
      macro_build (NULL, "sltu", "d,v,t", AT, treg, sreg);
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, ZERO);
d6702 4
a6705 1
      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
d6707 4
a6710 3
	  macro_build (&offset_expr, likely ? "beql" : "beq",
		       "s,t,p", sreg, ZERO);
	  break;
a6711 3
      used_at = 1;
      set_at (sreg, 1);
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, ZERO);
d6718 4
d6723 4
a6726 7
	  macro_build (&offset_expr, likely ? "bltzl" : "bltz", "s,p", sreg);
	  break;
	}
      if (sreg == 0)
	{
	  macro_build (&offset_expr, likely ? "bgtzl" : "bgtz", "s,p", treg);
	  break;
a6727 3
      used_at = 1;
      macro_build (NULL, "slt", "d,v,t", AT, sreg, treg);
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, ZERO);
d6735 4
a6738 1
      if (sreg == 0)
d6740 4
a6743 3
	  macro_build (&offset_expr, likely ? "bnel" : "bne",
		       "s,t,p", ZERO, treg);
	  break;
a6744 3
      used_at = 1;
      macro_build (NULL, "sltu", "d,v,t", AT, sreg, treg);
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, ZERO);
d6859 1
a6859 1
	    macro_build (NULL, "teq", "s,t,q", ZERO, ZERO, 7);
d6861 1
a6861 1
	    macro_build (NULL, "break", "c", 7);
d6868 1
a6868 1
	  macro_build (NULL, "teq", "s,t,q", treg, ZERO, 7);
d6873 5
a6877 2
	  expr1.X_add_number = 8;
	  macro_build (&expr1, "bne", "s,t,p", treg, ZERO);
d6879 3
a6881 1
	  macro_build (NULL, "break", "c", 7);
d6886 5
a6890 2
      expr1.X_add_number = mips_trap ? (dbl ? 12 : 8) : (dbl ? 20 : 16);
      macro_build (&expr1, "bne", "s,t,p", treg, AT);
d6895 1
a6895 1
	  macro_build (NULL, "dsll32", "d,w,<", AT, AT, 31);
d6900 1
a6900 1
	  macro_build (&expr1, "lui", "t,u", AT, BFD_RELOC_HI16);
d6904 1
a6904 1
	  macro_build (NULL, "teq", "s,t,q", sreg, AT, 6);
d6911 5
a6915 2
	  expr1.X_add_number = 8;
	  macro_build (&expr1, "bne", "s,t,p", sreg, AT);
d6922 1
a6922 1
	  macro_build (NULL, "break", "c", 6);
d6924 3
a6926 1
      macro_build (NULL, s, "d", dreg);
d6969 1
a6969 1
	    macro_build (NULL, "teq", "s,t,q", ZERO, ZERO, 7);
d6971 1
a6971 1
	    macro_build (NULL, "break", "c", 7);
d6998 1
a6998 1
      macro_build (NULL, s2, "d", dreg);
d7020 1
a7020 1
	  macro_build (NULL, "teq", "s,t,q", treg, ZERO, 7);
d7028 5
a7032 2
	  expr1.X_add_number = 8;
	  macro_build (&expr1, "bne", "s,t,p", treg, ZERO);
d7038 3
a7040 1
	  macro_build (NULL, "break", "c", 7);
d7042 1
a7042 1
      macro_build (NULL, s2, "d", dreg);
d7133 1
a7133 1
		  macro_build (&offset_expr, "lui", "t,u",
d7135 1
a7135 1
		  macro_build (&offset_expr, "lui", "t,u",
d7141 1
a7141 1
		  macro_build (NULL, "dsll32", "d,w,<", tempreg, tempreg, 0);
d7147 1
a7147 1
		  macro_build (&offset_expr, "lui", "t,u",
d7151 1
a7151 1
		  macro_build (NULL, "dsll", "d,w,<", tempreg, tempreg, 16);
d7154 1
a7154 1
		  macro_build (NULL, "dsll", "d,w,<", tempreg, tempreg, 16);
d7435 1
a7435 1
	  macro_build (&offset_expr, "lui", "t,u", tempreg, lui_reloc_type);
d7580 1
a7580 1
	  macro_build (&offset_expr, "lui", "t,u", tempreg, lui_reloc_type);
d7645 1
d7653 1
d7661 1
d7669 1
d7674 1
d7694 7
d7705 1
d7707 7
a7713 1
	macro_build (NULL, "jalr", "d,s", dreg, sreg);
d7716 3
d7722 6
a7727 1
	  macro_build (NULL, "jalr", "d,s", dreg, sreg);
d7759 4
d7765 1
a7765 1
	macro_build (&offset_expr, "jal", "a");
d7813 1
a7813 1
		  macro_build (&offset_expr, "lui", "t,u", PIC_CALL_REG,
d7830 1
a7830 1
	      macro_build_jalr (&offset_expr);
d7848 1
a7848 1
		  macro_build (&offset_expr, "lui", "t,u", PIC_CALL_REG,
d7867 1
a7867 1
	      macro_build_jalr (&offset_expr);
d7903 1
d7905 1
d7908 1
d7910 1
d7913 1
d7915 1
d7918 1
d7920 1
d7923 1
d7925 1
d7928 2
d7931 1
d7934 1
a7934 1
      goto ld;
d7936 1
d7938 1
d7941 1
a7941 1
      goto ld;
d7943 2
d7946 2
d7950 1
a7950 1
      goto ld;
d7952 2
d7955 1
d7958 1
a7958 1
      goto ld;
d7960 2
d7963 3
a7965 2
      lr = 1;
      goto ld;
d7967 2
d7970 3
a7972 2
      lr = 1;
      goto ld;
d7974 1
d7976 1
d7979 1
a7979 1
      goto ld;
d7981 2
d7984 2
d7988 1
a7988 1
      goto ld;
d7990 1
d7992 1
d7995 1
a7995 1
      goto ld;
d7997 2
d8000 3
a8002 2
      lr = 1;
      goto ld;
d8004 2
d8007 3
a8009 2
      lr = 1;
      goto ld;
d8011 2
d8014 2
d8018 2
d8021 2
d8025 2
d8028 38
d8067 2
a8068 5
      if (breg == treg || coproc || lr)
	{
	  tempreg = AT;
	  used_at = 1;
	}
d8070 3
a8072 4
	{
	  tempreg = treg;
	}
      goto ld_st;
d8074 1
d8076 2
a8077 1
      goto st;
d8079 1
d8081 2
a8082 1
      goto st;
d8084 1
d8086 2
a8087 1
      goto st;
d8089 2
d8092 1
d8095 1
a8095 1
      goto st;
d8097 1
d8099 1
d8102 1
a8102 1
      goto st;
d8104 2
d8107 2
d8111 1
a8111 1
      goto st;
d8113 2
d8116 1
d8119 1
a8119 1
      goto st;
d8121 2
d8124 3
a8126 1
      goto st;
d8128 2
d8131 3
a8133 1
      goto st;
d8135 2
d8138 3
a8140 1
      goto st;
d8142 2
d8145 3
a8147 1
      goto st;
d8149 2
d8152 3
a8154 1
      goto st;
d8156 2
d8159 3
a8161 1
      goto st;
d8163 1
d8165 1
d8168 1
a8168 1
      goto st;
d8170 2
d8173 2
d8177 1
a8177 1
      goto st;
d8179 2
d8182 1
d8185 1
a8185 1
      goto st;
d8187 2
d8190 3
a8192 1
      goto st;
d8194 2
d8197 36
a8232 1
    st:
d8235 1
a8235 1
    ld_st:
a8244 15
      /* Itbl support may require additional care here.  */
      if (mask == M_LWC1_AB
	  || mask == M_SWC1_AB
	  || mask == M_LDC1_AB
	  || mask == M_SDC1_AB
	  || mask == M_L_DAB
	  || mask == M_S_DAB)
	fmt = "T,o(b)";
      else if (mask == M_CACHE_AB || mask == M_PREF_AB)
	fmt = "k,o(b)";
      else if (coproc)
	fmt = "E,o(b)";
      else
	fmt = "t,o(b)";

d8265 2
d8269 1
a8269 1
	  if (!IS_SEXT_16BIT_NUM (expr1.X_add_number))
d8273 10
d8289 30
a8318 1
	  macro_build (&offset_expr, s, fmt, treg, BFD_RELOC_LO16, breg);
d8400 1
a8400 1
		  macro_build (&offset_expr, "lui", "t,u", tempreg,
d8402 1
a8402 1
		  macro_build (&offset_expr, "lui", "t,u", AT,
d8408 1
a8408 1
		  macro_build (NULL, "dsll32", "d,w,<", tempreg, tempreg, 0);
d8416 1
a8416 1
		  macro_build (&offset_expr, "lui", "t,u", tempreg,
d8420 1
a8420 1
		  macro_build (NULL, "dsll", "d,w,<", tempreg, tempreg, 16);
d8423 1
a8423 1
		  macro_build (NULL, "dsll", "d,w,<", tempreg, tempreg, 16);
d8555 1
a8555 1
	  macro_build (&offset_expr, "lui", "t,u", tempreg,
d8593 1
a8593 1
	  macro_build (&offset_expr, "lui", "t,u", tempreg,
d8759 1
a8759 1
	  if (mips_opts.isa != ISA_MIPS1)
d8782 1
a8782 1
	  if (mips_opts.isa != ISA_MIPS1)
d8798 1
d8810 1
d8822 1
d8836 1
d8840 1
a8840 1
	  goto ld;
a8841 1

a8842 1
      fmt = "T,o(b)";
d8846 4
d8853 1
a8853 1
	  goto st;
a8854 1

a8855 3
      fmt = "T,o(b)";
      /* Itbl support may require additional care here.  */
      coproc = 1;
d8859 1
a8864 1

a8865 1
      fmt = "t,o(b)";
d8869 1
d8873 1
a8873 1
	  goto st;
a8874 1

a8875 1
      fmt = "t,o(b)";
d9041 1
a9041 1
	  macro_build (&offset_expr, "lui", "t,u",
d9141 1
d9163 1
a9163 1
      macro_build (NULL, "mflo", "d", dreg);
d9175 1
a9175 1
      macro_build (NULL, "mflo", "d", dreg);
d9193 3
a9195 3
      macro_build (NULL, "mflo", "d", dreg);
      macro_build (NULL, dbl ? "dsra32" : "sra", "d,w,<", dreg, dreg, RA);
      macro_build (NULL, "mfhi", "d", AT);
d9197 1
a9197 1
	macro_build (NULL, "tne", "s,t,q", dreg, AT, 6);
d9200 5
a9204 2
	  expr1.X_add_number = 8;
	  macro_build (&expr1, "beq", "s,t,p", dreg, AT);
d9206 3
a9208 1
	  macro_build (NULL, "break", "c", 6);
d9211 1
a9211 1
      macro_build (NULL, "mflo", "d", dreg);
d9230 2
a9231 2
      macro_build (NULL, "mfhi", "d", AT);
      macro_build (NULL, "mflo", "d", dreg);
d9233 1
a9233 1
	macro_build (NULL, "tne", "s,t,q", AT, ZERO, 6);
d9236 5
a9240 2
	  expr1.X_add_number = 8;
	  macro_build (&expr1, "beq", "s,t,p", AT, ZERO);
d9242 3
a9244 1
	  macro_build (NULL, "break", "c", 6);
d9308 1
a9308 1
	      macro_build (NULL, "dror32", "d,w,<", dreg, sreg, rot - 32);
d9310 1
a9310 1
	      macro_build (NULL, "dror", "d,w,<", dreg, sreg, rot);
d9315 1
a9315 1
	    macro_build (NULL, "dsrl", "d,w,<", dreg, sreg, 0);
d9322 2
a9323 2
	macro_build (NULL, l, "d,w,<", AT, sreg, rot);
	macro_build (NULL, rr, "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
d9337 1
a9337 1
	    macro_build (NULL, "ror", "d,w,<", dreg, sreg, (32 - rot) & 0x1f);
d9342 1
a9342 1
	    macro_build (NULL, "srl", "d,w,<", dreg, sreg, 0);
d9346 2
a9347 2
	macro_build (NULL, "sll", "d,w,<", AT, sreg, rot);
	macro_build (NULL, "srl", "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
d9390 1
a9390 1
	      macro_build (NULL, "dror32", "d,w,<", dreg, sreg, rot - 32);
d9392 1
a9392 1
	      macro_build (NULL, "dror", "d,w,<", dreg, sreg, rot);
d9397 1
a9397 1
	    macro_build (NULL, "dsrl", "d,w,<", dreg, sreg, 0);
d9404 2
a9405 2
	macro_build (NULL, rr, "d,w,<", AT, sreg, rot);
	macro_build (NULL, l, "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
d9419 1
a9419 1
	    macro_build (NULL, "ror", "d,w,<", dreg, sreg, rot);
d9424 1
a9424 1
	    macro_build (NULL, "srl", "d,w,<", dreg, sreg, 0);
d9428 2
a9429 2
	macro_build (NULL, "srl", "d,w,<", AT, sreg, rot);
	macro_build (NULL, "sll", "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
d9659 8
d9669 4
a9672 1
    case M_SUB_I:
d9674 2
a9675 2
	  && imm_expr.X_add_number > -0x8000
	  && imm_expr.X_add_number <= 0x8000)
d9677 1
a9677 3
	  imm_expr.X_add_number = -imm_expr.X_add_number;
	  macro_build (&imm_expr, dbl ? "daddi" : "addi", "t,r,j",
		       dreg, sreg, BFD_RELOC_LO16);
d9680 1
a9680 5
      used_at = 1;
      load_register (AT, &imm_expr, dbl);
      macro_build (NULL, dbl ? "dsub" : "sub", "d,v,t", dreg, sreg, AT);
      break;

d9683 3
a9685 1
    case M_SUBU_I:
d9691 1
a9691 2
	  macro_build (&imm_expr, dbl ? "daddiu" : "addiu", "t,r,j",
		       dreg, sreg, BFD_RELOC_LO16);
d9694 1
d9697 1
a9697 1
      macro_build (NULL, dbl ? "dsubu" : "subu", "d,v,t", dreg, sreg, AT);
d9725 1
d9752 2
d9756 5
a9760 1
      goto ulh;
d9763 13
a9775 16
    ulh:
      used_at = 1;
      if (offset_expr.X_add_number >= 0x7fff)
	as_bad (_("Operand overflow"));
      if (!target_big_endian)
	++offset_expr.X_add_number;
      macro_build (&offset_expr, s, "t,o(b)", AT, BFD_RELOC_LO16, breg);
      if (!target_big_endian)
	--offset_expr.X_add_number;
      else
	++offset_expr.X_add_number;
      macro_build (&offset_expr, "lbu", "t,o(b)", treg, BFD_RELOC_LO16, breg);
      macro_build (NULL, "sll", "d,w,<", AT, AT, 8);
      macro_build (NULL, "or", "d,v,t", treg, treg, AT);
      break;

d9779 1
d9781 15
a9795 4
      goto ulw;
    case M_ULW:
      s = "lwl";
      s2 = "lwr";
d9797 13
a9809 2
    ulw:
      if (offset_expr.X_add_number >= 0x8000 - off)
d9811 29
a9839 3
      if (treg != breg)
	tempreg = treg;
      else
a9843 5
      if (!target_big_endian)
	offset_expr.X_add_number += off;
      macro_build (&offset_expr, s, "t,o(b)", tempreg, BFD_RELOC_LO16, breg);
      if (!target_big_endian)
	offset_expr.X_add_number -= off;
d9845 1
a9845 2
	offset_expr.X_add_number += off;
      macro_build (&offset_expr, s2, "t,o(b)", tempreg, BFD_RELOC_LO16, breg);
d9847 2
a9848 7
      /* If necessary, move the result in tempreg to the final destination.  */
      if (treg == tempreg)
        break;
      /* Protect second load's delay slot.  */
      load_delay_nop ();
      move_register (treg, tempreg);
      break;
a9849 14
    case M_ULD_A:
      s = "ldl";
      s2 = "ldr";
      off = 7;
      goto ulwa;
    case M_ULW_A:
      s = "lwl";
      s2 = "lwr";
      off = 3;
    ulwa:
      used_at = 1;
      load_address (AT, &offset_expr, &used_at);
      if (breg != 0)
	macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
d9851 3
a9853 1
	expr1.X_add_number = off;
d9855 3
a9857 2
	expr1.X_add_number = 0;
      macro_build (&expr1, s, "t,o(b)", treg, BFD_RELOC_LO16, AT);
d9859 5
a9863 1
	expr1.X_add_number = 0;
d9865 10
a9874 2
	expr1.X_add_number = off;
      macro_build (&expr1, s2, "t,o(b)", treg, BFD_RELOC_LO16, AT);
d9877 1
a9877 2
    case M_ULH_A:
    case M_ULHU_A:
d9879 15
a9893 9
      load_address (AT, &offset_expr, &used_at);
      if (breg != 0)
	macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
      if (target_big_endian)
	expr1.X_add_number = 0;
      macro_build (&expr1, mask == M_ULH_A ? "lb" : "lbu", "t,o(b)",
		   treg, BFD_RELOC_LO16, AT);
      if (target_big_endian)
	expr1.X_add_number = 1;
d9895 19
a9913 4
	expr1.X_add_number = 0;
      macro_build (&expr1, "lbu", "t,o(b)", AT, BFD_RELOC_LO16, AT);
      macro_build (NULL, "sll", "d,w,<", treg, treg, 8);
      macro_build (NULL, "or", "d,v,t", treg, treg, AT);
d9916 1
a9916 87
    case M_USH:
      used_at = 1;
      if (offset_expr.X_add_number >= 0x7fff)
	as_bad (_("Operand overflow"));
      if (target_big_endian)
	++offset_expr.X_add_number;
      macro_build (&offset_expr, "sb", "t,o(b)", treg, BFD_RELOC_LO16, breg);
      macro_build (NULL, "srl", "d,w,<", AT, treg, 8);
      if (target_big_endian)
	--offset_expr.X_add_number;
      else
	++offset_expr.X_add_number;
      macro_build (&offset_expr, "sb", "t,o(b)", AT, BFD_RELOC_LO16, breg);
      break;

    case M_USD:
      s = "sdl";
      s2 = "sdr";
      off = 7;
      goto usw;
    case M_USW:
      s = "swl";
      s2 = "swr";
      off = 3;
    usw:
      if (offset_expr.X_add_number >= 0x8000 - off)
	as_bad (_("Operand overflow"));
      if (!target_big_endian)
	offset_expr.X_add_number += off;
      macro_build (&offset_expr, s, "t,o(b)", treg, BFD_RELOC_LO16, breg);
      if (!target_big_endian)
	offset_expr.X_add_number -= off;
      else
	offset_expr.X_add_number += off;
      macro_build (&offset_expr, s2, "t,o(b)", treg, BFD_RELOC_LO16, breg);
      break;

    case M_USD_A:
      s = "sdl";
      s2 = "sdr";
      off = 7;
      goto uswa;
    case M_USW_A:
      s = "swl";
      s2 = "swr";
      off = 3;
    uswa:
      used_at = 1;
      load_address (AT, &offset_expr, &used_at);
      if (breg != 0)
	macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
      if (!target_big_endian)
	expr1.X_add_number = off;
      else
	expr1.X_add_number = 0;
      macro_build (&expr1, s, "t,o(b)", treg, BFD_RELOC_LO16, AT);
      if (!target_big_endian)
	expr1.X_add_number = 0;
      else
	expr1.X_add_number = off;
      macro_build (&expr1, s2, "t,o(b)", treg, BFD_RELOC_LO16, AT);
      break;

    case M_USH_A:
      used_at = 1;
      load_address (AT, &offset_expr, &used_at);
      if (breg != 0)
	macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
      if (!target_big_endian)
	expr1.X_add_number = 0;
      macro_build (&expr1, "sb", "t,o(b)", treg, BFD_RELOC_LO16, AT);
      macro_build (NULL, "srl", "d,w,<", treg, treg, 8);
      if (!target_big_endian)
	expr1.X_add_number = 1;
      else
	expr1.X_add_number = 0;
      macro_build (&expr1, "sb", "t,o(b)", treg, BFD_RELOC_LO16, AT);
      if (!target_big_endian)
	expr1.X_add_number = 0;
      else
	expr1.X_add_number = 1;
      macro_build (&expr1, "lbu", "t,o(b)", AT, BFD_RELOC_LO16, AT);
      macro_build (NULL, "sll", "d,w,<", treg, treg, 8);
      macro_build (NULL, "or", "d,v,t", treg, treg, AT);
      break;

    default:
d10307 185
d10548 11
d10567 5
d10579 1
d10584 1
d10588 1
d10593 11
d10606 1
a10606 1
  /* Try to match an instruction up to a space or to the end.  */
d10615 25
a10639 1
  insn = (struct mips_opcode *) hash_find (op_hash, name);
d10646 6
d10655 2
d10662 8
a10669 1
      if (! ok)
d10671 3
a10673 2
	  if (insn + 1 < &mips_opcodes[NUMOPCODES]
	      && strcmp (insn->name, insn[1].name) == 0)
d10678 1
a10678 1
	  else
d10680 5
a10684 10
	      if (!insn_error)
		{
		  static char buf[100];
		  sprintf (buf,
			   _("opcode not supported on this processor: %s (%s)"),
			   mips_cpu_info_from_arch (mips_opts.arch)->name,
			   mips_cpu_info_from_isa (mips_opts.isa)->name);
		  insn_error = buf;
		}
	      return;
d10686 14
d10720 1
d10729 1
a10729 1
	      INSERT_OPERAND (BP, *ip, imm_expr.X_add_number);
d10735 1
d10743 1
a10743 1
	      INSERT_OPERAND (SA3, *ip, imm_expr.X_add_number);
d10749 1
d10757 1
a10757 1
	      INSERT_OPERAND (SA4, *ip, imm_expr.X_add_number);
d10763 1
d10771 1
a10771 1
	      INSERT_OPERAND (IMM8, *ip, imm_expr.X_add_number);
d10777 1
d10785 1
a10785 1
	      INSERT_OPERAND (RS, *ip, imm_expr.X_add_number);
d10791 1
d10797 1
a10797 1
		  INSERT_OPERAND (DSPACC, *ip, regno);
d10805 1
d10814 1
a10814 1
	      INSERT_OPERAND (WRDSP, *ip, imm_expr.X_add_number);
d10820 1
d10826 1
a10826 1
		  INSERT_OPERAND (DSPACC_S, *ip, regno);
d10834 1
d10846 1
a10846 1
	      INSERT_OPERAND (DSPSFT, *ip, imm_expr.X_add_number);
d10852 1
d10861 1
a10861 1
	      INSERT_OPERAND (RDDSP, *ip, imm_expr.X_add_number);
d10867 1
d10879 1
a10879 1
	      INSERT_OPERAND (DSPSFT_7, *ip, imm_expr.X_add_number);
d10885 1
d10897 1
a10897 1
	      INSERT_OPERAND (IMM10, *ip, imm_expr.X_add_number);
d10903 1
d10909 1
a10909 1
	      INSERT_OPERAND (MT_U, *ip, imm_expr.X_add_number);
d10915 1
d10921 1
a10921 1
	      INSERT_OPERAND (MT_H, *ip, imm_expr.X_add_number);
d10927 1
d10933 1
a10933 1
		  INSERT_OPERAND (MTACC_T, *ip, regno);
d10941 1
d10947 1
a10947 1
		  INSERT_OPERAND (MTACC_D, *ip, regno);
d10963 1
a10963 1
		  INSERT_OPERAND (RS, *ip, lastregno);
d10967 1
a10967 1
		  INSERT_OPERAND (RT, *ip, lastregno);
d10971 2
a10972 1
		  INSERT_OPERAND (FT, *ip, lastregno);
d10976 1
a10976 1
		  INSERT_OPERAND (FS, *ip, lastregno);
d10987 6
a10992 2
	      gas_assert (args[1] == 'b');
	      if (*s == '\0')
d10994 1
d10997 5
a11001 1
	    case '[':
d11003 1
d11015 1
d11059 2
a11060 1
		  INSERT_OPERAND (SHAMT, *ip, imm_expr.X_add_number);
d11091 2
a11092 2
		  INSERT_OPERAND (INSMSB, *ip,
				 lastpos + imm_expr.X_add_number - 1);
d11127 2
a11128 1
		  INSERT_OPERAND (EXTMSBD, *ip, imm_expr.X_add_number - 1);
d11149 1
d11154 1
d11170 1
a11170 1
			  INSERT_OPERAND (RT, *ip, regno);
d11181 1
d11190 1
a11190 1
		  INSERT_OPERAND (BBITIND, *ip, imm_expr.X_add_number);
d11199 1
d11205 1
a11205 1
		  INSERT_OPERAND (BBITIND, *ip, imm_expr.X_add_number - 32);
d11213 1
d11224 1
a11224 1
		  INSERT_OPERAND (CINSPOS, *ip, imm_expr.X_add_number);
d11232 1
d11239 1
a11239 1
		  INSERT_OPERAND (CINSPOS, *ip, imm_expr.X_add_number - 32);
d11246 1
d11255 1
a11255 1
		  INSERT_OPERAND (CINSLM1, *ip, imm_expr.X_add_number);
d11263 1
d11273 1
a11273 1
		  INSERT_OPERAND (CINSLM1, *ip, imm_expr.X_add_number);
d11280 1
d11290 1
a11290 1
		  INSERT_OPERAND (SEQI, *ip, imm_expr.X_add_number);
d11296 1
d11308 1
a11308 1
		  INSERT_OPERAND (OFFSET_A, *ip, imm_expr.X_add_number);
d11314 1
d11326 1
a11326 1
		  INSERT_OPERAND (OFFSET_B, *ip, imm_expr.X_add_number);
d11332 1
d11353 2
a11354 1
		  INSERT_OPERAND (OFFSET_C, *ip, imm_expr.X_add_number >> 4);
d11360 1
d11371 1
a11371 1
		  INSERT_OPERAND (RZ, *ip, regno);
d11375 1
d11378 1
a11378 1
		  INSERT_OPERAND (FZ, *ip, regno);
d11382 1
a11382 1
		  as_bad (_("Internal error: bad mips opcode "
d11384 1
d11391 34
d11437 2
a11438 1
	      INSERT_OPERAND (SHAMT, *ip, imm_expr.X_add_number);
d11449 2
a11450 1
	      INSERT_OPERAND (SHAMT, *ip, imm_expr.X_add_number - 32);
d11464 1
a11464 1
	      if (*args == 'k')
d11466 4
a11469 1
		  if (mips_fix_cn63xxp1 && strcmp ("pref", insn->name) == 0)
d11486 11
a11496 1
		  INSERT_OPERAND (CACHE, *ip, imm_expr.X_add_number);
a11497 4
	      else if (*args == 'h')
		INSERT_OPERAND (PREFX, *ip, imm_expr.X_add_number);
	      else
		INSERT_OPERAND (SHAMT, *ip, imm_expr.X_add_number);
d11503 16
a11518 9
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > OP_MASK_CODE)
		as_warn (_("Code for %s not in range 0..1023 (%lu)"),
			 ip->insn_mo->name,
			 (unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (CODE, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d11522 16
a11537 9
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > OP_MASK_CODE2)
		as_warn (_("Lower code for %s not in range 0..1023 (%lu)"),
			 ip->insn_mo->name,
			 (unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (CODE2, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d11540 19
a11558 10
	    case 'B':		/* 20-bit SYSCALL/BREAK code.  */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > OP_MASK_CODE20)
		as_warn (_("Code for %s not in range 0..1048575 (%lu)"),
			 ip->insn_mo->name,
			 (unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (CODE20, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d11561 11
a11571 6
	    case 'C':		/* Coprocessor code.  */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
	      if ((unsigned long) imm_expr.X_add_number > OP_MASK_COPZ)
		{
		  as_warn (_("Coproccesor code > 25 bits (%lu)"),
d11573 5
a11577 5
		  imm_expr.X_add_number &= OP_MASK_COPZ;
		}
	      INSERT_OPERAND (COPZ, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d11580 2
a11581 1
	    case 'J':           /* 19-bit WAIT code.  */
d11585 2
a11586 2
		{
		  as_warn (_("Illegal 19-bit code (%lu)"),
d11588 3
a11590 3
		  imm_expr.X_add_number &= OP_MASK_CODE19;
		}
	      INSERT_OPERAND (CODE19, *ip, imm_expr.X_add_number);
d11596 1
d11602 1
a11602 1
	      INSERT_OPERAND (PERFREG, *ip, imm_expr.X_add_number);
d11608 43
a11650 12
	      if (((ip->insn_opcode >> OP_SH_OP) & OP_MASK_OP) == OP_OP_COP0)
		ok = reg_lookup (&s, RTYPE_NUM | RTYPE_CP0, &regno);
	      else
		ok = reg_lookup (&s, RTYPE_NUM | RTYPE_GP, &regno);
	      INSERT_OPERAND (RD, *ip, regno);
	      if (ok) 
		{
		  lastregno = regno;
		  continue;
		}
	      else
		break;
d11652 7
a11667 1
	    case 'x':		/* Ignore register name.  */
d11669 1
a11669 2
	    case 'U':           /* Destination register (CLO/CLZ).  */
	    case 'g':		/* Coprocessor destination register.  */
d11726 8
a11733 1
		      INSERT_OPERAND (RS, *ip, regno);
d11735 1
a11736 1
		    case 'K':
d11738 1
a11738 1
		      INSERT_OPERAND (RD, *ip, regno);
d11740 1
d11742 3
a11744 2
		      INSERT_OPERAND (RD, *ip, regno);
		      INSERT_OPERAND (RT, *ip, regno);
d11746 1
d11750 1
a11750 1
		      INSERT_OPERAND (RT, *ip, regno);
d11752 6
d11767 1
d11782 1
a11782 1
		  INSERT_OPERAND (RS, *ip, lastregno);
d11784 1
d11786 1
a11786 1
		  INSERT_OPERAND (RT, *ip, lastregno);
d11792 1
d11798 1
a11798 1
	      INSERT_OPERAND (ALN, *ip, imm_expr.X_add_number);
d11807 1
d11813 1
a11813 1
		  INSERT_OPERAND (FT, *ip, imm_expr.X_add_number);
d11827 2
a11833 1
	    case 'W':
d11869 1
a11869 1
		      INSERT_OPERAND (FD, *ip, regno);
d11871 1
d11875 1
a11875 1
		      INSERT_OPERAND (FS, *ip, regno);
d11877 1
d11916 1
a11916 1
		      INSERT_OPERAND (FT, *ip, regno);
d11918 1
d11920 1
a11920 1
		      INSERT_OPERAND (FR, *ip, regno);
d11930 1
a11930 1
		  INSERT_OPERAND (FS, *ip, lastregno);
d11932 1
d11934 1
a11934 1
		  INSERT_OPERAND (FT, *ip, lastregno);
d12117 783
a12899 11
					     (SEC_ALLOC
					      | SEC_LOAD
					      | SEC_READONLY
					      | SEC_DATA));
		    frag_align (*args == 'l' ? 2 : 3, 0, 0);
		    if (IS_ELF && strncmp (TARGET_OS, "elf", 3) != 0)
		      record_alignment (new_seg, 4);
		    else
		      record_alignment (new_seg, *args == 'l' ? 2 : 3);
		    if (seg == now_seg)
		      as_bad (_("Can't use floating point insn in this section"));
d12901 5
a12905 5
		    /* Set the argument to the current address in the
		       section.  */
		    offset_expr.X_op = O_symbol;
		    offset_expr.X_add_symbol = symbol_temp_new_now ();
		    offset_expr.X_add_number = 0;
d12907 3
a12909 3
		    /* Put the floating point number into the section.  */
		    p = frag_more ((int) length);
		    memcpy (p, temp, length);
d12911 2
a12912 2
		    /* Switch back to the original section.  */
		    subseg_set (seg, subseg);
d12914 12
a12925 2
	      }
	      continue;
d12927 5
a12931 7
	    case 'i':		/* 16-bit unsigned immediate.  */
	    case 'j':		/* 16-bit signed immediate.  */
	      *imm_reloc = BFD_RELOC_LO16;
	      if (my_getSmallExpression (&imm_expr, imm_reloc, s) == 0)
		{
		  int more;
		  offsetT minval, maxval;
d12933 14
a12946 2
		  more = (insn + 1 < &mips_opcodes[NUMOPCODES]
			  && strcmp (insn->name, insn[1].name) == 0);
d12948 3
a12950 11
		  /* If the expression was written as an unsigned number,
		     only treat it as signed if there are no more
		     alternatives.  */
		  if (more
		      && *args == 'j'
		      && sizeof (imm_expr.X_add_number) <= 4
		      && imm_expr.X_op == O_constant
		      && imm_expr.X_add_number < 0
		      && imm_expr.X_unsigned
		      && HAVE_64BIT_GPRS)
		    break;
d12952 5
a12956 9
		  /* For compatibility with older assemblers, we accept
		     0x8000-0xffff as signed 16-bit numbers when only
		     signed numbers are allowed.  */
		  if (*args == 'i')
		    minval = 0, maxval = 0xffff;
		  else if (more)
		    minval = -0x8000, maxval = 0x7fff;
		  else
		    minval = -0x8000, maxval = 0xffff;
d12958 5
a12962 13
		  if (imm_expr.X_op != O_constant
		      || imm_expr.X_add_number < minval
		      || imm_expr.X_add_number > maxval)
		    {
		      if (more)
			break;
		      if (imm_expr.X_op == O_constant
			  || imm_expr.X_op == O_big)
			as_bad (_("Expression out of range"));
		    }
		}
	      s = expr_end;
	      continue;
d12964 3
a12966 4
	    case 'o':		/* 16-bit offset.  */
	      offset_reloc[0] = BFD_RELOC_LO16;
	      offset_reloc[1] = BFD_RELOC_UNUSED;
	      offset_reloc[2] = BFD_RELOC_UNUSED;
d12968 4
a12971 7
	      /* Check whether there is only a single bracketed expression
		 left.  If so, it must be the base register and the
		 constant must be zero.  */
	      if (*s == '(' && strchr (s + 1, '(') == 0)
		{
		  offset_expr.X_op = O_constant;
		  offset_expr.X_add_number = 0;
a12972 1
		}
d12974 9
a12982 8
	      /* If this value won't fit into a 16 bit offset, then go
		 find a macro that will generate the 32 bit offset
		 code pattern.  */
	      if (my_getSmallExpression (&offset_expr, offset_reloc, s) == 0
		  && (offset_expr.X_op != O_constant
		      || offset_expr.X_add_number >= 0x8000
		      || offset_expr.X_add_number < -0x8000))
		break;
d12984 5
a12988 2
	      s = expr_end;
	      continue;
d12990 10
a12999 5
	    case 'p':		/* PC-relative offset.  */
	      *offset_reloc = BFD_RELOC_16_PCREL_S2;
	      my_getExpression (&offset_expr, s);
	      s = expr_end;
	      continue;
d13001 6
a13006 9
	    case 'u':		/* Upper 16 bits.  */
	      if (my_getSmallExpression (&imm_expr, imm_reloc, s) == 0
		  && imm_expr.X_op == O_constant
		  && (imm_expr.X_add_number < 0
		      || imm_expr.X_add_number >= 0x10000))
		as_bad (_("lui expression (%lu) not in range 0..65535"),
			(unsigned long) imm_expr.X_add_number);
	      s = expr_end;
	      continue;
d13008 4
a13011 5
	    case 'a':		/* 26-bit address.  */
	      my_getExpression (&offset_expr, s);
	      s = expr_end;
	      *offset_reloc = BFD_RELOC_MIPS_JMP;
	      continue;
d13013 6
a13018 25
	    case 'N':		/* 3-bit branch condition code.  */
	    case 'M':		/* 3-bit compare condition code.  */
	      rtype = RTYPE_CCC;
	      if (ip->insn_mo->pinfo & (FP_D | FP_S))
		rtype |= RTYPE_FCC;
	      if (!reg_lookup (&s, rtype, &regno))
		break;
	      if ((strcmp (str + strlen (str) - 3, ".ps") == 0
		   || strcmp (str + strlen (str) - 5, "any2f") == 0
		   || strcmp (str + strlen (str) - 5, "any2t") == 0)
		  && (regno & 1) != 0)
		as_warn (_("Condition code register should be even for %s, "
			   "was %d"),
			 str, regno);
	      if ((strcmp (str + strlen (str) - 5, "any4f") == 0
		   || strcmp (str + strlen (str) - 5, "any4t") == 0)
		  && (regno & 3) != 0)
		as_warn (_("Condition code register should be 0 or 4 for %s, "
			   "was %d"),
			 str, regno);
	      if (*args == 'N')
		INSERT_OPERAND (BCC, *ip, regno);
	      else
		INSERT_OPERAND (CCC, *ip, regno);
	      continue;
d13020 6
a13025 13
	    case 'H':
	      if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
		s += 2;
	      if (ISDIGIT (*s))
		{
		  c = 0;
		  do
		    {
		      c *= 10;
		      c += *s - '0';
		      ++s;
		    }
		  while (ISDIGIT (*s));
d13027 21
a13047 2
	      else
		c = 8; /* Invalid sel value.  */
d13049 2
a13050 4
	      if (c > 7)
		as_bad (_("Invalid coprocessor sub-selection value (0-7)"));
	      ip->insn_opcode |= c;
	      continue;
d13052 2
a13053 4
	    case 'e':
	      /* Must be at least one digit.  */
	      my_getExpression (&imm_expr, s);
	      check_absolute_expr (ip, &imm_expr);
d13055 5
a13059 7
	      if ((unsigned long) imm_expr.X_add_number
		  > (unsigned long) OP_MASK_VECBYTE)
		{
		  as_bad (_("bad byte vector index (%ld)"),
			   (long) imm_expr.X_add_number);
		  imm_expr.X_add_number = 0;
		}
d13061 4
a13064 3
	      INSERT_OPERAND (VECBYTE, *ip, imm_expr.X_add_number);
	      imm_expr.X_op = O_absent;
	      s = expr_end;
d13067 2
a13068 1
	    case '%':
a13070 1

d13072 5
a13076 8
		  > (unsigned long) OP_MASK_VECALIGN)
		{
		  as_bad (_("bad byte vector index (%ld)"),
			   (long) imm_expr.X_add_number);
		  imm_expr.X_add_number = 0;
		}

	      INSERT_OPERAND (VECALIGN, *ip, imm_expr.X_add_number);
d13088 3
a13090 2
      if (insn + 1 < &mips_opcodes[NUMOPCODES] &&
	  !strcmp (insn->name, insn[1].name))
a13092 2
	  s = argsStart;
	  insn_error = _("Illegal operands");
d13095 8
a13102 1
      insn_error = _("Illegal operands");
d13111 4
a13114 4
   global variables imm_reloc or offset_reloc to the type of
   relocation to do if one of the operands is an address expression.
   It also sets mips16_small and mips16_ext if the user explicitly
   requested a small or extended instruction.  */
d13130 1
a13130 2
  mips16_small = FALSE;
  mips16_ext = FALSE;
d13147 1
a13147 1
	  mips16_small = TRUE;
d13154 1
a13154 1
	  mips16_ext = TRUE;
d13164 2
a13165 2
  if (mips_opts.noautoextend && ! mips16_ext)
    mips16_small = TRUE;
d13265 2
a13266 2
				    tmp, TRUE, mips16_small,
				    mips16_ext, &ip->insn_opcode,
d13446 1
a13446 1
		      mips16_ext = TRUE;
d14190 2
d14284 2
d14540 15
d14556 5
d14998 2
d15076 7
d15087 1
d15247 7
d15278 2
a15279 1
  gas_assert (fixP->fx_size == 4
d15284 1
d15291 4
a15294 1
  gas_assert (!fixP->fx_pcrel || fixP->fx_r_type == BFD_RELOC_16_PCREL_S2);
d15320 7
d15363 19
d15420 1
d15430 4
a15433 1
	  if (target_big_endian)
d15489 16
a15504 2
			_("Branch out of range"));
	}
d15552 1
a15552 1
  mips_record_mips16_mode ();
d16017 5
a16021 1
    mips_opts.mips16 = 1;
d16025 8
d16373 1
a16373 1
      macro_build (&ex_sym, "lui", "t,u", mips_gp_register,
d16669 1
a16669 1
   mips16 mode.  This permits the linker to handle them specially,
d16680 1
a16680 1
  mips16_mark_labels ();
d16695 1
a16695 1
    mips16_mark_labels ();
d17161 156
d17340 13
d17410 1
a17410 1
      && (fixp->fx_pcrel || fixp->fx_r_type == BFD_RELOC_MIPS_JALR))
d17440 3
a17442 2
       5. We cannot reduce R_MIPS16_26 relocations against MIPS16 symbols
	  on targets with in-place addends; the relocation field cannot
d17445 3
a17447 2
     For simplicity, we deal with (3)-(5) by not reducing _any_ relocation
     against a MIPS16 symbol.
d17459 4
a17462 1
	  || *symbol_get_tc (fixp->fx_addsy)))
d17487 4
a17490 1
      gas_assert (fixp->fx_r_type == BFD_RELOC_16_PCREL_S2);
d17544 14
d17796 273
d18159 3
d18165 2
a18166 2
      first = RELAX_FIRST (fragp->fr_subtype);
      second = RELAX_SECOND (fragp->fr_subtype);
d18169 17
d18187 1
a18187 2
      if (((fragp->fr_subtype & RELAX_USE_SECOND) != 0)
	  == ((fragp->fr_subtype & RELAX_SECOND_LONGER) != 0))
d18189 9
a18197 3
	  const char *msg = macro_warning (fragp->fr_subtype);
	  if (msg != 0)
	    as_warn_where (fragp->fr_file, fragp->fr_line, "%s", msg);
d18207 1
a18207 1
	  if (fragp->fr_subtype & RELAX_USE_SECOND)
d18217 1
a18217 1
	  if (fragp->fr_subtype & RELAX_USE_SECOND)
d18225 1
a18225 1
      if (fragp->fr_subtype & RELAX_USE_SECOND)
d18256 9
a18264 11
    {
      if (ELF_ST_IS_MIPS16 (elf_symbol (*syms)->internal_elf_sym.st_other)
	  && ((*syms)->value & 1) != 0)
	{
	  (*syms)->value &= ~1;
	  /* If the symbol has an odd size, it was probably computed
	     incorrectly, so adjust that as well.  */
	  if ((elf_symbol (*syms)->internal_elf_sym.st_size & 1) != 0)
	    ++elf_symbol (*syms)->internal_elf_sym.st_size;
	}
    }
d18366 2
d18420 6
a18425 2
/* Implement NOP_OPCODE.  We encode a MIPS16 nop as "1" and a normal
   nop as "0".  */
d18430 6
a18435 1
  return seg_info (now_seg)->tc_segment_info_data.mips16;
d18438 2
a18439 2
/* Fill in an rs_align_code fragment.  This only needs to do something
   for MIPS16 code, where 0 is not a nop.  */
d18444 1
d18453 2
a18454 1
  if (*p)
d18456 5
d18463 3
a18465 3
    }
  else
    {
d18468 1
d18473 8
a18480 1
  if (excess != 0)
d18482 17
a18498 5
      /* If we're not inserting a whole number of instructions,
	 pad the end of the fixed part of the frag with zeros.  */
      memset (p, 0, excess);
      p += excess;
      fragp->fr_fix += excess;
d19201 3
@


1.477
log
@include/opcode/
2011-07-24  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (INSN_TRAP): Rename to...
	(INSN_NO_DELAY_SLOT): ... this.
	(INSN_SYNC): Remove macro.

gas/
2011-07-24  Maciej W. Rozycki  <macro@@codesourcery.com>

	* config/tc-mips.c (can_swap_branch_p): Adjust for the rename of
	INSN_TRAP to INSN_NO_DELAY_SLOT.  Remove the check for INSN_SYNC
	as well as explicit checks for ERET and DERET when scheduling
	branch delay slots.

opcodes/
2011-07-24  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-opc.c (NODS): New macro.
	(TRAP): Adjust for the rename of INSN_TRAP to INSN_NO_DELAY_SLOT.
	(DSP_VOLA): Likewise.
	(mips_builtin_opcodes): Add NODS annotation to "deret" and
	"eret". Replace INSN_SYNC with NODS throughout.  Use NODS in
	place of TRAP for "wait", "waiti" and "yield".
	* mips16-opc.c (NODS): New macro.
	(TRAP): Adjust for the rename of INSN_TRAP to INSN_NO_DELAY_SLOT.
	(mips16_opcodes):  Use NODS in place of TRAP for "jalrc", "jrc",
	"restore" and "save".
@
text
@a8933 1
  char save_c = 0;
d8935 1
d8938 1
a8941 2
  /* If the instruction contains a '.', we first try to match an instruction
     including the '.'.  Then we try again without the '.'.  */
d8943 3
a8945 1
  for (s = str; *s != '\0' && !ISSPACE (*s); ++s)
d8948 4
a8951 8
  /* If we stopped on whitespace, then replace the whitespace with null for
     the call to hash_find.  Save the character we replaced just in case we
     have to re-parse the instruction.  */
  if (ISSPACE (*s))
    {
      save_c = *s;
      *s++ = '\0';
    }
d8953 1
a8953 5
  insn = (struct mips_opcode *) hash_find (op_hash, str);

  /* If we didn't find the instruction in the opcode table, try again, but
     this time with just the instruction up to, but not including the
     first '.'.  */
d8956 2
a8957 24
      /* Restore the character we overwrite above (if any).  */
      if (save_c)
	*(--s) = save_c;

      /* Scan up to the first '.' or whitespace.  */
      for (s = str;
	   *s != '\0' && *s != '.' && !ISSPACE (*s);
	   ++s)
	continue;

      /* If we did not find a '.', then we can quit now.  */
      if (*s != '.')
	{
	  insn_error = _("Unrecognized opcode");
	  return;
	}

      /* Lookup the instruction in the hash table.  */
      *s++ = '\0';
      if ((insn = (struct mips_opcode *) hash_find (op_hash, str)) == NULL)
	{
	  insn_error = _("Unrecognized opcode");
	  return;
	}
d8960 1
a8960 1
  argsStart = s;
d8965 1
a8965 1
      gas_assert (strcmp (insn->name, str) == 0);
a8986 2
	      if (save_c)
		*(--s) = save_c;
a10445 2
      if (save_c)
	*(--argsStart) = save_c;
@


1.476
log
@gas/
2011-07-04  Aurelien Jarno  <aurelien@@aurel32.net>

	* config/tc-mips.c (append_insn): delete prev_pinfo2 and pinfo2.
@
text
@d3151 5
a3155 2
  /* We do not swap with a trap instruction, since it complicates trap
     handlers to have the trap instruction be in a delay slot.  */
d3157 1
a3157 12
  if (prev_pinfo & INSN_TRAP)
    return FALSE;

  /* If the previous instruction is a sync, sync.l, or sync.p, we can
     not swap.  */
  if (prev_pinfo & INSN_SYNC)
    return FALSE;

  /* If the previous instruction is an ERET or DERET, avoid the swap.  */
  if (history[0].insn_opcode == INSN_ERET)
    return FALSE;
  if (history[0].insn_opcode == INSN_DERET)
@


1.475
log
@gas/
	* config/tc-mips.c (gpr_read_mask, gpr_write_mask): Fix handling
	of register 0.
@
text
@a3281 1
  unsigned long prev_pinfo2, pinfo2;
a3293 1
  prev_pinfo2 = history[0].insn_mo->pinfo2;
a3294 1
  pinfo2 = ip->insn_mo->pinfo2;
@


1.474
log
@	gas/
	* config/tc-mips.c (append_insn): Make sure DWARF-2 location
	information is properly adjusted for branches that get swapped.

	gas/testsuite/
	* gas/mips/loc-swap.d: New test case for DWARF-2 location with
	branch swapping.
	* gas/mips/loc-swap-dis.d: Likewise.
	* gas/mips/mips16@@loc-swap.d: Likewise, MIPS16 version.
	* gas/mips/mips16@@loc-swap-dis.d: Likewise.
	* gas/mips/loc-swap.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.
@
text
@d2453 2
a2454 1
  return mask & ~0;
d2496 2
a2497 1
  return mask & ~0;
@


1.473
log
@gas/
	* config/tc-mips.c (append_method): New enum.
	(can_swap_branch_p, get_append_method): New functions.
	(append_insn): Use get_append_method to decide how the instruction
	should be added.
@
text
@d3457 14
a3470 4
     should be recorded in the debug tables.  For MIPS16 debug info
     we want to use ISA-encoded addresses, so we pass -1 for an
     address higher by one than the current.  */
  dwarf2_emit_insn (mips_opts.mips16 ? -1 : 0);
@


1.472
log
@gas/
	* config/tc-mips.c (append_insn): Remove bogus goto.
@
text
@d124 15
d3091 162
a3280 1
  relax_stateT prev_insn_frag_type = 0;
d3282 1
a3282 1
  segment_info_type *si = seg_info (now_seg);
d3452 2
a3462 4
  /* Record the frag type before frag_var.  */
  if (history[0].frag)
    prev_insn_frag_type = history[0].frag->fr_type;

d3646 1
a3646 1
  if (mips_relax.sequence != 2 && !mips_opts.noreorder)
d3648 50
a3697 147
      /* Filling the branch delay slot is more complex.  We try to
	 switch the branch with the previous instruction, which we can
	 do if the previous instruction does not set up a condition
	 that the branch tests and if the branch is not itself the
	 target of any branch.  */
      if ((pinfo & INSN_UNCOND_BRANCH_DELAY)
	  || (pinfo & INSN_COND_BRANCH_DELAY))
	{
	  if (mips_optimize < 2
	      /* If we have seen .set volatile or .set nomove, don't
		 optimize.  */
	      || mips_opts.nomove != 0
	      /* We can't swap if the previous instruction's position
		 is fixed.  */
	      || history[0].fixed_p
	      /* If the previous previous insn was in a .set
		 noreorder, we can't swap.  Actually, the MIPS
		 assembler will swap in this situation.  However, gcc
		 configured -with-gnu-as will generate code like
		   .set noreorder
		   lw	$4,XXX
		   .set	reorder
		   INSN
		   bne	$4,$0,foo
		 in which we can not swap the bne and INSN.  If gcc is
		 not configured -with-gnu-as, it does not output the
		 .set pseudo-ops.  */
	      || history[1].noreorder_p
	      /* If the branch is itself the target of a branch, we
		 can not swap.  We cheat on this; all we check for is
		 whether there is a label on this instruction.  If
		 there are any branches to anything other than a
		 label, users must use .set noreorder.  */
	      || si->label_list != NULL
	      /* If the previous instruction is in a variant frag
		 other than this branch's one, we cannot do the swap.
		 This does not apply to the mips16, which uses variant
		 frags for different purposes.  */
	      || (! mips_opts.mips16
		  && prev_insn_frag_type == rs_machine_dependent)
	      /* Check for conflicts between the branch and the instructions
		 before the candidate delay slot.  */
	      || nops_for_insn (0, history + 1, ip) > 0
	      /* Check for conflicts between the swapped sequence and the
		 target of the branch.  */
	      || nops_for_sequence (2, 0, history + 1, ip, history) > 0
	      /* We do not swap with a trap instruction, since it
		 complicates trap handlers to have the trap
		 instruction be in a delay slot.  */
	      || (prev_pinfo & INSN_TRAP)
	      /* If the branch reads a register that the previous
		 instruction sets, we can not swap.  */
	      || (gpr_read_mask (ip) & gpr_write_mask (&history[0])) != 0
	      /* If the branch writes a register that the previous
		 instruction sets, we can not swap.  */
	      || (gpr_write_mask (ip) & gpr_write_mask (&history[0])) != 0
	      /* If the branch writes a register that the previous
		 instruction reads, we can not swap.  */
	      || (gpr_write_mask (ip) & gpr_read_mask (&history[0])) != 0
	      /* If one instruction sets a condition code and the
                 other one uses a condition code, we can not swap.  */
	      || ((pinfo & INSN_READ_COND_CODE)
		  && (prev_pinfo & INSN_WRITE_COND_CODE))
	      || ((pinfo & INSN_WRITE_COND_CODE)
		  && (prev_pinfo & INSN_READ_COND_CODE))
	      /* If the previous instruction uses the PC, we can not
                 swap.  */
	      || (mips_opts.mips16
		  && (prev_pinfo & MIPS16_INSN_READ_PC))
	      /* If the previous instruction had a fixup in mips16
                 mode, we can not swap.  This normally means that the
                 previous instruction was a 4 byte branch anyhow.  */
	      || (mips_opts.mips16 && history[0].fixp[0])
	      /* If the previous instruction is a sync, sync.l, or
		 sync.p, we can not swap.  */
	      || (prev_pinfo & INSN_SYNC)
	      /* If the previous instruction is an ERET or
		 DERET, avoid the swap.  */
              || (history[0].insn_opcode == INSN_ERET)
              || (history[0].insn_opcode == INSN_DERET))
	    {
	      if (mips_opts.mips16
		  && (pinfo & INSN_UNCOND_BRANCH_DELAY)
		  && (pinfo & (MIPS16_INSN_READ_X | MIPS16_INSN_READ_31))
		  && ISA_SUPPORTS_MIPS16E)
		{
		  /* Convert MIPS16 jr/jalr into a "compact" jump.  */
		  ip->insn_opcode |= 0x0080;
		  find_altered_mips16_opcode (ip);
		  install_insn (ip);
		  insert_into_history (0, 1, ip);
		} 
	      else
		{
		  /* We could do even better for unconditional branches to
		     portions of this object file; we could pick up the
		     instruction at the destination, put it in the delay
		     slot, and bump the destination address.  */
		  insert_into_history (0, 1, ip);
		  emit_nop ();
		}
		
	      if (mips_relax.sequence)
		mips_relax.sizes[mips_relax.sequence - 1] += 4;
	    }
	  else
	    {
	      /* It looks like we can actually do the swap.  */
	      struct mips_cl_insn delay = history[0];
	      if (mips_opts.mips16)
		{
		  know (delay.frag == ip->frag);
                  move_insn (ip, delay.frag, delay.where);
		  move_insn (&delay, ip->frag, ip->where + insn_length (ip));
		}
	      else if (relaxed_branch)
		{
		  /* Add the delay slot instruction to the end of the
		     current frag and shrink the fixed part of the
		     original frag.  If the branch occupies the tail of
		     the latter, move it backwards to cover the gap.  */
		  delay.frag->fr_fix -= 4;
		  if (delay.frag == ip->frag)
		    move_insn (ip, ip->frag, ip->where - 4);
		  add_fixed_insn (&delay);
		}
	      else
		{
		  move_insn (&delay, ip->frag, ip->where);
		  move_insn (ip, history[0].frag, history[0].where);
		}
	      history[0] = *ip;
	      delay.fixed_p = 1;
	      insert_into_history (0, 1, &delay);
	    }
	}
      else if (pinfo & INSN_COND_BRANCH_LIKELY)
	{
	  /* We don't yet optimize a branch likely.  What we should do
	     is look at the target, copy the instruction found there
	     into the delay slot, and increment the branch to jump to
	     the next instruction.  */
	  insert_into_history (0, 1, ip);
	  emit_nop ();
	}
      else
	insert_into_history (0, 1, ip);
a3698 2
  else
    insert_into_history (0, 1, ip);
@


1.471
log
@gas/
	* config/tc-mips.c (append_insn): Always clear the history after an
	unconditional branch.
@
text
@d3183 7
a3189 6
	  if (mips_relax_branch)
	    goto need_reloc;
	  if ((address_expr->X_add_number + 0x20000) & ~0x3ffff)
	    as_bad (_("branch address range overflow (0x%lx)"),
	            (unsigned long) address_expr->X_add_number);
	  ip->insn_opcode |= (address_expr->X_add_number >> 2) & 0xffff;
d3371 1
a3371 1
  if (address_expr != NULL && *reloc_type <= BFD_RELOC_UNUSED)
d3373 2
a3374 6
      if (!ip->complete_p
          && *reloc_type < BFD_RELOC_UNUSED)
	need_reloc:
	{
	  reloc_howto_type *howto;
	  int i;
d3376 5
a3380 5
	  /* In a compound relocation, it is the final (outermost)
	     operator that determines the relocated field.  */
	  for (i = 1; i < 3; i++)
	    if (reloc_type[i] == BFD_RELOC_UNUSED)
	      break;
d3382 9
a3390 9
	  howto = bfd_reloc_type_lookup (stdoutput, reloc_type[i - 1]);
	  if (howto == NULL)
	    {
	      /* To reproduce this failure try assembling gas/testsuites/
		 gas/mips/mips16-intermix.s with a mips-ecoff targeted
		 assembler.  */
	      as_bad (_("Unsupported MIPS relocation number %d"), reloc_type[i - 1]);
	      howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_16);
	    }
d3392 33
a3424 33
	  ip->fixp[0] = fix_new_exp (ip->frag, ip->where,
				     bfd_get_reloc_size (howto),
				     address_expr,
				     reloc_type[0] == BFD_RELOC_16_PCREL_S2,
				     reloc_type[0]);

	  /* Tag symbols that have a R_MIPS16_26 relocation against them.  */
	  if (reloc_type[0] == BFD_RELOC_MIPS16_JMP
	      && ip->fixp[0]->fx_addsy)
	    *symbol_get_tc (ip->fixp[0]->fx_addsy) = 1;

	  /* These relocations can have an addend that won't fit in
	     4 octets for 64bit assembly.  */
	  if (HAVE_64BIT_GPRS
	      && ! howto->partial_inplace
	      && (reloc_type[0] == BFD_RELOC_16
		  || reloc_type[0] == BFD_RELOC_32
		  || reloc_type[0] == BFD_RELOC_MIPS_JMP
		  || reloc_type[0] == BFD_RELOC_GPREL16
		  || reloc_type[0] == BFD_RELOC_MIPS_LITERAL
		  || reloc_type[0] == BFD_RELOC_GPREL32
		  || reloc_type[0] == BFD_RELOC_64
		  || reloc_type[0] == BFD_RELOC_CTOR
		  || reloc_type[0] == BFD_RELOC_MIPS_SUB
		  || reloc_type[0] == BFD_RELOC_MIPS_HIGHEST
		  || reloc_type[0] == BFD_RELOC_MIPS_HIGHER
		  || reloc_type[0] == BFD_RELOC_MIPS_SCN_DISP
		  || reloc_type[0] == BFD_RELOC_MIPS_REL16
		  || reloc_type[0] == BFD_RELOC_MIPS_RELGOT
		  || reloc_type[0] == BFD_RELOC_MIPS16_GPREL
		  || hi16_reloc_p (reloc_type[0])
		  || lo16_reloc_p (reloc_type[0])))
	    ip->fixp[0]->fx_no_overflow = 1;
d3426 8
a3433 8
	  if (mips_relax.sequence)
	    {
	      if (mips_relax.first_fixup == 0)
		mips_relax.first_fixup = ip->fixp[0];
	    }
	  else if (reloc_needs_lo_p (*reloc_type))
	    {
	      struct mips_hi_fixup *hi_fixup;
d3435 30
a3464 31
	      /* Reuse the last entry if it already has a matching %lo.  */
	      hi_fixup = mips_hi_fixup_list;
	      if (hi_fixup == 0
		  || !fixup_has_matching_lo_p (hi_fixup->fixp))
		{
		  hi_fixup = ((struct mips_hi_fixup *)
			      xmalloc (sizeof (struct mips_hi_fixup)));
		  hi_fixup->next = mips_hi_fixup_list;
		  mips_hi_fixup_list = hi_fixup;
		}
	      hi_fixup->fixp = ip->fixp[0];
	      hi_fixup->seg = now_seg;
	    }

	  /* Add fixups for the second and third relocations, if given.
	     Note that the ABI allows the second relocation to be
	     against RSS_UNDEF, RSS_GP, RSS_GP0 or RSS_LOC.  At the
	     moment we only use RSS_UNDEF, but we could add support
	     for the others if it ever becomes necessary.  */
	  for (i = 1; i < 3; i++)
	    if (reloc_type[i] != BFD_RELOC_UNUSED)
	      {
		ip->fixp[i] = fix_new (ip->frag, ip->where,
				       ip->fixp[0]->fx_size, NULL, 0,
				       FALSE, reloc_type[i]);

		/* Use fx_tcbit to mark compound relocs.  */
		ip->fixp[0]->fx_tcbit = 1;
		ip->fixp[i]->fx_tcbit = 1;
	      }
	}
@


1.470
log
@gas/
	* config/tc-mips.c (find_altered_mips16_opcode): New function.
	(append_insn): Use it.

opcodes/
	* mips16-opc.c (jalrc, jrc): Move earlier in file.
@
text
@a3612 7

	  /* If that was an unconditional branch, forget the previous
	     insn information.  */
	  if (pinfo & INSN_UNCOND_BRANCH_DELAY)
	    {
	      mips_no_prev_insn ();
	    }
d3629 6
@


1.469
log
@gas/
	* config/tc-mips.c (insn_uses_reg): Delete.
	(gpr_read_mask, gpr_write_mask): New functions.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(insns_between, nops_for_vr4130, append_insn): Use them.

gas/testsuite/
	* gas/mips/mips16-e.d, gas/mips/mips16-f.d,
	gas/mips/mipsel16-e.d, gas/mips/mipsel16-f.d,
	gas/mips/tmips16-e.d, gas/mips/tmips16-f.d,
	gas/mips/tmipsel16-e.d, gas/mips/tmipsel16-f.d: Fix GPR mask.
	* gas/mips/reginfo-1.s, gas/mips/reginfo-1a.d,
	gas/mips/reginfo-1b.d: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d3076 18
d3566 1
@


1.468
log
@gas/
	* config/tc-mips.c (md_mips_end): Call mips_emit_delays.

gas/testsuite/
	* gas/mips/24k-triple-stores-9.d: Add -z to dump options and
	explicitly match one nop.
	* gas/mips/24k-triple-stores-10.d: Likewise.
	* gas/mips/24k-triple-stores-11.d: Likewise.
	* gas/mips/lifloat.d: Likewise.
	* gas/mips/trunc.d: Likewise 1 extra nop.
	* gas/mips/vr4111.d: Likewise 2 nops.
@
text
@a2245 82
/* See whether instruction IP reads register REG.  CLASS is the type
   of register.  */

static int
insn_uses_reg (const struct mips_cl_insn *ip, unsigned int reg,
	       enum mips_regclass regclass)
{
  if (regclass == MIPS16_REG)
    {
      gas_assert (mips_opts.mips16);
      reg = mips16_to_32_reg_map[reg];
      regclass = MIPS_GR_REG;
    }

  /* Don't report on general register ZERO, since it never changes.  */
  if (regclass == MIPS_GR_REG && reg == ZERO)
    return 0;

  if (regclass == MIPS_FP_REG)
    {
      gas_assert (! mips_opts.mips16);
      /* If we are called with either $f0 or $f1, we must check $f0.
	 This is not optimal, because it will introduce an unnecessary
	 NOP between "lwc1 $f0" and "swc1 $f1".  To fix this we would
	 need to distinguish reading both $f0 and $f1 or just one of
	 them.  Note that we don't have to check the other way,
	 because there is no instruction that sets both $f0 and $f1
	 and requires a delay.  */
      if ((ip->insn_mo->pinfo & INSN_READ_FPR_S)
	  && ((EXTRACT_OPERAND (FS, *ip) & ~(unsigned) 1)
	      == (reg &~ (unsigned) 1)))
	return 1;
      if ((ip->insn_mo->pinfo & INSN_READ_FPR_T)
	  && ((EXTRACT_OPERAND (FT, *ip) & ~(unsigned) 1)
	      == (reg &~ (unsigned) 1)))
	return 1;
      if ((ip->insn_mo->pinfo2 & INSN2_READ_FPR_Z)
	  && ((EXTRACT_OPERAND (FZ, *ip) & ~(unsigned) 1)
	      == (reg &~ (unsigned) 1)))
	return 1;
    }
  else if (! mips_opts.mips16)
    {
      if ((ip->insn_mo->pinfo & INSN_READ_GPR_S)
	  && EXTRACT_OPERAND (RS, *ip) == reg)
	return 1;
      if ((ip->insn_mo->pinfo & INSN_READ_GPR_T)
	  && EXTRACT_OPERAND (RT, *ip) == reg)
	return 1;
      if ((ip->insn_mo->pinfo2 & INSN2_READ_GPR_D)
	  && EXTRACT_OPERAND (RD, *ip) == reg)
	return 1;
      if ((ip->insn_mo->pinfo2 & INSN2_READ_GPR_Z)
	  && EXTRACT_OPERAND (RZ, *ip) == reg)
	return 1;
    }
  else
    {
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_X)
	  && mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, *ip)] == reg)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_Y)
	  && mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RY, *ip)] == reg)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_Z)
	  && (mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (MOVE32Z, *ip)]
	      == reg))
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_T) && reg == TREG)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_SP) && reg == SP)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_31) && reg == RA)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_GPR_X)
	  && MIPS16_EXTRACT_OPERAND (REGR32, *ip) == reg)
	return 1;
    }

  return 0;
}

d2398 143
d2575 1
d2579 2
a2580 2
     the latter is tested via INSN2_USES_REG.  If INSN2 is null, PINFO2
     will have every flag set and INSN2_USES_REG will always return true.  */
d2584 2
a2585 2
#define INSN2_USES_REG(REG, CLASS) \
   (insn2 == NULL || insn_uses_reg (insn2, REG, CLASS))
d2601 1
a2601 1
      && INSN2_USES_REG (EXTRACT_OPERAND (RD, *insn1), MIPS_GR_REG))
d2648 1
a2648 1
	  if (INSN2_USES_REG (EXTRACT_OPERAND (RT, *insn1), MIPS_GR_REG))
d2666 2
a2667 6
	  if (pinfo1 & INSN_WRITE_FPR_T)
	    {
	      if (INSN2_USES_REG (EXTRACT_OPERAND (FT, *insn1), MIPS_FP_REG))
		return 1;
	    }
	  else if (pinfo1 & INSN_WRITE_FPR_S)
d2669 1
a2669 1
	      if (INSN2_USES_REG (EXTRACT_OPERAND (FS, *insn1), MIPS_FP_REG))
d2699 1
a2699 1
#undef INSN2_USES_REG
d2713 2
a2714 1
  int i, j, reg;
d2729 1
a2729 4
	if (mips_opts.mips16)
	  reg = mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, hist[i])];
	else
	  reg = EXTRACT_OPERAND (RD, hist[i]);
d2732 1
a2732 1
	if (insn != NULL && insn_uses_reg (insn, reg, MIPS_GR_REG))
d2737 1
a2737 1
	  if (insn_uses_reg (&hist[j], reg, MIPS_GR_REG))
d3455 2
a3456 53
  if (! mips_opts.mips16)
    {
      if ((pinfo & INSN_WRITE_GPR_D) || (pinfo2 & INSN2_READ_GPR_D))
	mips_gprmask |= 1 << EXTRACT_OPERAND (RD, *ip);
      if ((pinfo & (INSN_WRITE_GPR_T | INSN_READ_GPR_T)) != 0)
	mips_gprmask |= 1 << EXTRACT_OPERAND (RT, *ip);
      if (pinfo & INSN_READ_GPR_S)
	mips_gprmask |= 1 << EXTRACT_OPERAND (RS, *ip);
      if (pinfo & INSN_WRITE_GPR_31)
	mips_gprmask |= 1 << RA;
      if (pinfo2 & (INSN2_WRITE_GPR_Z | INSN2_READ_GPR_Z))
	mips_gprmask |= 1 << EXTRACT_OPERAND (RZ, *ip);
      if (pinfo & INSN_WRITE_FPR_D)
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FD, *ip);
      if ((pinfo & (INSN_WRITE_FPR_S | INSN_READ_FPR_S)) != 0)
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FS, *ip);
      if ((pinfo & (INSN_WRITE_FPR_T | INSN_READ_FPR_T)) != 0)
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FT, *ip);
      if ((pinfo & INSN_READ_FPR_R) != 0)
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FR, *ip);
      if (pinfo2 & (INSN2_WRITE_FPR_Z | INSN2_READ_FPR_Z))
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FZ, *ip);
      if (pinfo & INSN_COP)
	{
	  /* We don't keep enough information to sort these cases out.
	     The itbl support does keep this information however, although
	     we currently don't support itbl fprmats as part of the cop
	     instruction.  May want to add this support in the future.  */
	}
      /* Never set the bit for $0, which is always zero.  */
      mips_gprmask &= ~1 << 0;
    }
  else
    {
      if (pinfo & (MIPS16_INSN_WRITE_X | MIPS16_INSN_READ_X))
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (RX, *ip);
      if (pinfo & (MIPS16_INSN_WRITE_Y | MIPS16_INSN_READ_Y))
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (RY, *ip);
      if (pinfo & MIPS16_INSN_WRITE_Z)
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (RZ, *ip);
      if (pinfo & (MIPS16_INSN_WRITE_T | MIPS16_INSN_READ_T))
	mips_gprmask |= 1 << TREG;
      if (pinfo & (MIPS16_INSN_WRITE_SP | MIPS16_INSN_READ_SP))
	mips_gprmask |= 1 << SP;
      if (pinfo & (MIPS16_INSN_WRITE_31 | MIPS16_INSN_READ_31))
	mips_gprmask |= 1 << RA;
      if (pinfo & MIPS16_INSN_WRITE_GPR_Y)
	mips_gprmask |= 1 << MIPS16OP_EXTRACT_REG32R (ip->insn_opcode);
      if (pinfo & MIPS16_INSN_READ_Z)
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (MOVE32Z, *ip);
      if (pinfo & MIPS16_INSN_READ_GPR_X)
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (REGR32, *ip);
    }
d3512 1
a3512 34
	      || (! mips_opts.mips16
		  && (prev_pinfo & INSN_WRITE_GPR_T)
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RT, history[0]),
				    MIPS_GR_REG))
	      || (! mips_opts.mips16
		  && (prev_pinfo & INSN_WRITE_GPR_D)
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RD, history[0]),
				    MIPS_GR_REG))
	      || (! mips_opts.mips16
		  && (prev_pinfo2 & INSN2_WRITE_GPR_Z)
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RZ, history[0]),
				    MIPS_GR_REG))
	      || (mips_opts.mips16
		  && (((prev_pinfo & MIPS16_INSN_WRITE_X)
		       && (insn_uses_reg
			   (ip, MIPS16_EXTRACT_OPERAND (RX, history[0]),
			    MIPS16_REG)))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_Y)
			  && (insn_uses_reg
			      (ip, MIPS16_EXTRACT_OPERAND (RY, history[0]),
			       MIPS16_REG)))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_Z)
			  && (insn_uses_reg
			      (ip, MIPS16_EXTRACT_OPERAND (RZ, history[0]),
			       MIPS16_REG)))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_T)
			  && insn_uses_reg (ip, TREG, MIPS_GR_REG))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_31)
			  && insn_uses_reg (ip, RA, MIPS_GR_REG))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_GPR_Y)
			  && insn_uses_reg (ip,
					    MIPS16OP_EXTRACT_REG32R
					      (history[0].insn_opcode),
					    MIPS_GR_REG))))
d3514 2
a3515 22
		 instruction sets, we can not swap (we know that
		 branches write only to RD or to $31).  */
	      || (! mips_opts.mips16
		  && (prev_pinfo & INSN_WRITE_GPR_T)
		  && (((pinfo & INSN_WRITE_GPR_D)
		       && (EXTRACT_OPERAND (RT, history[0])
			   == EXTRACT_OPERAND (RD, *ip)))
		      || ((pinfo & INSN_WRITE_GPR_31)
			  && EXTRACT_OPERAND (RT, history[0]) == RA)))
	      || (! mips_opts.mips16
		  && (prev_pinfo & INSN_WRITE_GPR_D)
		  && (((pinfo & INSN_WRITE_GPR_D)
		       && (EXTRACT_OPERAND (RD, history[0])
			   == EXTRACT_OPERAND (RD, *ip)))
		      || ((pinfo & INSN_WRITE_GPR_31)
			  && EXTRACT_OPERAND (RD, history[0]) == RA)))
	      || (mips_opts.mips16
		  && (pinfo & MIPS16_INSN_WRITE_31)
		  && ((prev_pinfo & MIPS16_INSN_WRITE_31)
		      || ((prev_pinfo & MIPS16_INSN_WRITE_GPR_Y)
			  && (MIPS16OP_EXTRACT_REG32R (history[0].insn_opcode)
			      == RA))))
d3517 2
a3518 13
		 instruction reads, we can not swap (we know that
		 branches only write to RD or to $31).  */
	      || (! mips_opts.mips16
		  && (pinfo & INSN_WRITE_GPR_D)
		  && insn_uses_reg (&history[0],
				    EXTRACT_OPERAND (RD, *ip),
				    MIPS_GR_REG))
	      || (! mips_opts.mips16
		  && (pinfo & INSN_WRITE_GPR_31)
		  && insn_uses_reg (&history[0], RA, MIPS_GR_REG))
	      || (mips_opts.mips16
		  && (pinfo & MIPS16_INSN_WRITE_31)
		  && insn_uses_reg (&history[0], RA, MIPS_GR_REG))
@


1.467
log
@Remove previous patch, committed in error.
@
text
@d2114 1
@


1.466
log
@gas/
	* config/tc-mips.c (insn_uses_reg): Delete.
	(gpr_read_mask, gpr_write_mask): New functions.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(insns_between, nops_for_vr4130, append_insn): Use them.

gas/testsuite/
	* gas/mips/mips16-e.d, gas/mips/mips16-f.d,
	gas/mips/mipsel16-e.d, gas/mips/mipsel16-f.d,
	gas/mips/tmips16-e.d, gas/mips/tmips16-f.d,
	gas/mips/tmipsel16-e.d, gas/mips/tmipsel16-f.d: Fix GPR mask.
@
text
@d2245 82
a2478 135
/* Return the mask of core registers that IP reads.  */

static unsigned int
gpr_read_mask (const struct mips_cl_insn *ip)
{
  unsigned long pinfo, pinfo2;
  unsigned int mask;

  mask = 0;
  pinfo = ip->insn_mo->pinfo;
  pinfo2 = ip->insn_mo->pinfo2;
  if (mips_opts.mips16)
    {
      if (pinfo & MIPS16_INSN_READ_X)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, *ip)];
      if (pinfo & MIPS16_INSN_READ_Y)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RY, *ip)];
      if (pinfo & MIPS16_INSN_READ_T)
	mask |= 1 << TREG;
      if (pinfo & MIPS16_INSN_READ_SP)
	mask |= 1 << SP;
      if (pinfo & MIPS16_INSN_READ_31)
	mask |= 1 << RA;
      if (pinfo & MIPS16_INSN_READ_Z)
	mask |= 1 << (mips16_to_32_reg_map
		      [MIPS16_EXTRACT_OPERAND (MOVE32Z, *ip)]);
      if (pinfo & MIPS16_INSN_READ_GPR_X)
	mask |= 1 << MIPS16_EXTRACT_OPERAND (REGR32, *ip);
    }
  else
    {
      if (pinfo2 & INSN2_READ_GPR_D)
	mask |= 1 << EXTRACT_OPERAND (RD, *ip);
      if (pinfo & INSN_READ_GPR_T)
	mask |= 1 << EXTRACT_OPERAND (RT, *ip);
      if (pinfo & INSN_READ_GPR_S)
	mask |= 1 << EXTRACT_OPERAND (RS, *ip);
      if (pinfo2 & INSN2_READ_GPR_Z)
	mask |= 1 << EXTRACT_OPERAND (RZ, *ip);
    }
  return mask & ~0;
}

/* Return the mask of core registers that IP writes.  */

static unsigned int
gpr_write_mask (const struct mips_cl_insn *ip)
{
  unsigned long pinfo, pinfo2;
  unsigned int mask;

  mask = 0;
  pinfo = ip->insn_mo->pinfo;
  pinfo2 = ip->insn_mo->pinfo2;
  if (mips_opts.mips16)
    {
      if (pinfo & MIPS16_INSN_WRITE_X)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, *ip)];
      if (pinfo & MIPS16_INSN_WRITE_Y)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RY, *ip)];
      if (pinfo & MIPS16_INSN_WRITE_Z)
	mask |= 1 << mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RZ, *ip)];
      if (pinfo & MIPS16_INSN_WRITE_T)
	mask |= 1 << TREG;
      if (pinfo & MIPS16_INSN_WRITE_SP)
	mask |= 1 << SP;
      if (pinfo & MIPS16_INSN_WRITE_31)
	mask |= 1 << RA;
      if (pinfo & MIPS16_INSN_WRITE_GPR_Y)
	mask |= 1 << MIPS16OP_EXTRACT_REG32R (ip->insn_opcode);
    }
  else
    {
      if (pinfo & INSN_WRITE_GPR_D)
	mask |= 1 << EXTRACT_OPERAND (RD, *ip);
      if (pinfo & INSN_WRITE_GPR_T)
	mask |= 1 << EXTRACT_OPERAND (RT, *ip);
      if (pinfo & INSN_WRITE_GPR_31)
	mask |= 1 << RA;
      if (pinfo2 & INSN2_WRITE_GPR_Z)
	mask |= 1 << EXTRACT_OPERAND (RZ, *ip);
    }
  return mask & ~0;
}

/* Return the mask of floating-point registers that IP reads.  */

static unsigned int
fpr_read_mask (const struct mips_cl_insn *ip)
{
  unsigned long pinfo, pinfo2;
  unsigned int mask;

  mask = 0;
  pinfo = ip->insn_mo->pinfo;
  pinfo2 = ip->insn_mo->pinfo2;
  if (!mips_opts.mips16)
    {
      if (pinfo & INSN_READ_FPR_S)
	mask |= 1 << EXTRACT_OPERAND (FS, *ip);
      if (pinfo & INSN_READ_FPR_T)
	mask |= 1 << EXTRACT_OPERAND (FT, *ip);
      if (pinfo & INSN_READ_FPR_R)
	mask |= 1 << EXTRACT_OPERAND (FR, *ip);
      if (pinfo2 & INSN2_READ_FPR_Z)
	mask |= 1 << EXTRACT_OPERAND (FZ, *ip);
    }
  return mask;
}

/* Return the mask of floating-point registers that IP writes.  */

static unsigned int
fpr_write_mask (const struct mips_cl_insn *ip)
{
  unsigned long pinfo, pinfo2;
  unsigned int mask;

  mask = 0;
  pinfo = ip->insn_mo->pinfo;
  pinfo2 = ip->insn_mo->pinfo2;
  if (!mips_opts.mips16)
    {
      if (pinfo & INSN_WRITE_FPR_D)
	mask |= 1 << EXTRACT_OPERAND (FD, *ip);
      if (pinfo & INSN_WRITE_FPR_S)
	mask |= 1 << EXTRACT_OPERAND (FS, *ip);
      if (pinfo & INSN_WRITE_FPR_T)
	mask |= 1 << EXTRACT_OPERAND (FT, *ip);
      if (pinfo2 & INSN2_WRITE_FPR_Z)
	mask |= 1 << EXTRACT_OPERAND (FZ, *ip);
    }
  return mask;
}

a2512 1
  unsigned int mask;
d2516 2
a2517 2
     the latter is tested via INSN2_USES_GPR.  If INSN2 is null, PINFO2
     will have every flag set and INSN2_USES_GPR will always return true.  */
d2521 2
a2522 2
#define INSN2_USES_GPR(REG) \
  (insn2 == NULL || (gpr_read_mask (insn2) & (1U << (REG))) != 0)
d2538 1
a2538 1
      && INSN2_USES_GPR (EXTRACT_OPERAND (RD, *insn1)))
d2585 1
a2585 1
	  if (INSN2_USES_GPR (EXTRACT_OPERAND (RT, *insn1)))
d2603 6
a2608 2
	  mask = fpr_write_mask (insn1);
	  if (mask != 0)
d2610 1
a2610 1
	      if (!insn2 || (mask & fpr_read_mask (insn2)) != 0)
d2640 1
a2640 1
#undef INSN2_USES_GPR
d2654 1
a2654 2
  int i, j;
  unsigned int mask;
d2669 4
a2672 1
	mask = gpr_write_mask (&hist[i]);
d2675 1
a2675 1
	if (insn != NULL && (gpr_read_mask (insn) & mask) != 0)
d2680 1
a2680 1
	  if (gpr_read_mask (&hist[j]) & mask)
d3398 53
a3450 2
  mips_gprmask |= gpr_read_mask (ip) | gpr_write_mask (ip);
  mips_cprmask[1] |= fpr_read_mask (ip) | fpr_write_mask (ip);
d3506 34
a3539 1
	      || (gpr_read_mask (ip) & gpr_write_mask (&history[0])) != 0
d3541 22
a3562 2
		 instruction sets, we can not swap.  */
	      || (gpr_write_mask (ip) & gpr_write_mask (&history[0])) != 0
d3564 13
a3576 2
		 instruction reads, we can not swap.  */
	      || (gpr_write_mask (ip) & gpr_read_mask (&history[0])) != 0
@


1.465
log
@gas/
	* config/tc-mips.c (fix_24k_record_store_info): If the previous
	instruction was a store, and the next instructions are unknown,
	assume the worst.

gas/testsuite/
	* gas/mips/24k-branch-delay-1.d: Do not allow stores to be put
	into delay slots.
	* gas/mips/24k-triple-stores-1.d: Put the first nop after the
	second store, rather than the first.
	* gas/mips/24k-triple-stores-2.d: Likewise.
	* gas/mips/24k-triple-stores-4.d: Likewise.
	* gas/mips/24k-triple-stores-8.d: Likewise.
	* gas/mips/24k-triple-stores-3.d: Remove first nop.
	* gas/mips/24k-triple-stores-5.d: Likewise.
	* gas/mips/24k-triple-stores-6.d: Likewise.
	* gas/mips/24k-triple-stores-7.d: Likewise.
	* gas/mips/24k-triple-stores-9.d: Add a nop after the second store.
	Expect a nop at the end.
	* gas/mips/24k-triple-stores-10.d: Put the first nop after the
	second store, rather than the first.  Expect a nop at the end.
@
text
@a2244 82
/* See whether instruction IP reads register REG.  CLASS is the type
   of register.  */

static int
insn_uses_reg (const struct mips_cl_insn *ip, unsigned int reg,
	       enum mips_regclass regclass)
{
  if (regclass == MIPS16_REG)
    {
      gas_assert (mips_opts.mips16);
      reg = mips16_to_32_reg_map[reg];
      regclass = MIPS_GR_REG;
    }

  /* Don't report on general register ZERO, since it never changes.  */
  if (regclass == MIPS_GR_REG && reg == ZERO)
    return 0;

  if (regclass == MIPS_FP_REG)
    {
      gas_assert (! mips_opts.mips16);
      /* If we are called with either $f0 or $f1, we must check $f0.
	 This is not optimal, because it will introduce an unnecessary
	 NOP between "lwc1 $f0" and "swc1 $f1".  To fix this we would
	 need to distinguish reading both $f0 and $f1 or just one of
	 them.  Note that we don't have to check the other way,
	 because there is no instruction that sets both $f0 and $f1
	 and requires a delay.  */
      if ((ip->insn_mo->pinfo & INSN_READ_FPR_S)
	  && ((EXTRACT_OPERAND (FS, *ip) & ~(unsigned) 1)
	      == (reg &~ (unsigned) 1)))
	return 1;
      if ((ip->insn_mo->pinfo & INSN_READ_FPR_T)
	  && ((EXTRACT_OPERAND (FT, *ip) & ~(unsigned) 1)
	      == (reg &~ (unsigned) 1)))
	return 1;
      if ((ip->insn_mo->pinfo2 & INSN2_READ_FPR_Z)
	  && ((EXTRACT_OPERAND (FZ, *ip) & ~(unsigned) 1)
	      == (reg &~ (unsigned) 1)))
	return 1;
    }
  else if (! mips_opts.mips16)
    {
      if ((ip->insn_mo->pinfo & INSN_READ_GPR_S)
	  && EXTRACT_OPERAND (RS, *ip) == reg)
	return 1;
      if ((ip->insn_mo->pinfo & INSN_READ_GPR_T)
	  && EXTRACT_OPERAND (RT, *ip) == reg)
	return 1;
      if ((ip->insn_mo->pinfo2 & INSN2_READ_GPR_D)
	  && EXTRACT_OPERAND (RD, *ip) == reg)
	return 1;
      if ((ip->insn_mo->pinfo2 & INSN2_READ_GPR_Z)
	  && EXTRACT_OPERAND (RZ, *ip) == reg)
	return 1;
    }
  else
    {
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_X)
	  && mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, *ip)] == reg)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_Y)
	  && mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RY, *ip)] == reg)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_Z)
	  && (mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (MOVE32Z, *ip)]
	      == reg))
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_T) && reg == TREG)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_SP) && reg == SP)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_31) && reg == RA)
	return 1;
      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_GPR_X)
	  && MIPS16_EXTRACT_OPERAND (REGR32, *ip) == reg)
	return 1;
    }

  return 0;
}

d2397 135
d2566 1
d2570 2
a2571 2
     the latter is tested via INSN2_USES_REG.  If INSN2 is null, PINFO2
     will have every flag set and INSN2_USES_REG will always return true.  */
d2575 2
a2576 2
#define INSN2_USES_REG(REG, CLASS) \
   (insn2 == NULL || insn_uses_reg (insn2, REG, CLASS))
d2592 1
a2592 1
      && INSN2_USES_REG (EXTRACT_OPERAND (RD, *insn1), MIPS_GR_REG))
d2639 1
a2639 1
	  if (INSN2_USES_REG (EXTRACT_OPERAND (RT, *insn1), MIPS_GR_REG))
d2657 2
a2658 6
	  if (pinfo1 & INSN_WRITE_FPR_T)
	    {
	      if (INSN2_USES_REG (EXTRACT_OPERAND (FT, *insn1), MIPS_FP_REG))
		return 1;
	    }
	  else if (pinfo1 & INSN_WRITE_FPR_S)
d2660 1
a2660 1
	      if (INSN2_USES_REG (EXTRACT_OPERAND (FS, *insn1), MIPS_FP_REG))
d2690 1
a2690 1
#undef INSN2_USES_REG
d2704 2
a2705 1
  int i, j, reg;
d2720 1
a2720 4
	if (mips_opts.mips16)
	  reg = mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, hist[i])];
	else
	  reg = EXTRACT_OPERAND (RD, hist[i]);
d2723 1
a2723 1
	if (insn != NULL && insn_uses_reg (insn, reg, MIPS_GR_REG))
d2728 1
a2728 1
	  if (insn_uses_reg (&hist[j], reg, MIPS_GR_REG))
d3446 2
a3447 53
  if (! mips_opts.mips16)
    {
      if ((pinfo & INSN_WRITE_GPR_D) || (pinfo2 & INSN2_READ_GPR_D))
	mips_gprmask |= 1 << EXTRACT_OPERAND (RD, *ip);
      if ((pinfo & (INSN_WRITE_GPR_T | INSN_READ_GPR_T)) != 0)
	mips_gprmask |= 1 << EXTRACT_OPERAND (RT, *ip);
      if (pinfo & INSN_READ_GPR_S)
	mips_gprmask |= 1 << EXTRACT_OPERAND (RS, *ip);
      if (pinfo & INSN_WRITE_GPR_31)
	mips_gprmask |= 1 << RA;
      if (pinfo2 & (INSN2_WRITE_GPR_Z | INSN2_READ_GPR_Z))
	mips_gprmask |= 1 << EXTRACT_OPERAND (RZ, *ip);
      if (pinfo & INSN_WRITE_FPR_D)
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FD, *ip);
      if ((pinfo & (INSN_WRITE_FPR_S | INSN_READ_FPR_S)) != 0)
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FS, *ip);
      if ((pinfo & (INSN_WRITE_FPR_T | INSN_READ_FPR_T)) != 0)
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FT, *ip);
      if ((pinfo & INSN_READ_FPR_R) != 0)
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FR, *ip);
      if (pinfo2 & (INSN2_WRITE_FPR_Z | INSN2_READ_FPR_Z))
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FZ, *ip);
      if (pinfo & INSN_COP)
	{
	  /* We don't keep enough information to sort these cases out.
	     The itbl support does keep this information however, although
	     we currently don't support itbl fprmats as part of the cop
	     instruction.  May want to add this support in the future.  */
	}
      /* Never set the bit for $0, which is always zero.  */
      mips_gprmask &= ~1 << 0;
    }
  else
    {
      if (pinfo & (MIPS16_INSN_WRITE_X | MIPS16_INSN_READ_X))
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (RX, *ip);
      if (pinfo & (MIPS16_INSN_WRITE_Y | MIPS16_INSN_READ_Y))
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (RY, *ip);
      if (pinfo & MIPS16_INSN_WRITE_Z)
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (RZ, *ip);
      if (pinfo & (MIPS16_INSN_WRITE_T | MIPS16_INSN_READ_T))
	mips_gprmask |= 1 << TREG;
      if (pinfo & (MIPS16_INSN_WRITE_SP | MIPS16_INSN_READ_SP))
	mips_gprmask |= 1 << SP;
      if (pinfo & (MIPS16_INSN_WRITE_31 | MIPS16_INSN_READ_31))
	mips_gprmask |= 1 << RA;
      if (pinfo & MIPS16_INSN_WRITE_GPR_Y)
	mips_gprmask |= 1 << MIPS16OP_EXTRACT_REG32R (ip->insn_opcode);
      if (pinfo & MIPS16_INSN_READ_Z)
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (MOVE32Z, *ip);
      if (pinfo & MIPS16_INSN_READ_GPR_X)
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (REGR32, *ip);
    }
d3503 1
a3503 34
	      || (! mips_opts.mips16
		  && (prev_pinfo & INSN_WRITE_GPR_T)
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RT, history[0]),
				    MIPS_GR_REG))
	      || (! mips_opts.mips16
		  && (prev_pinfo & INSN_WRITE_GPR_D)
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RD, history[0]),
				    MIPS_GR_REG))
	      || (! mips_opts.mips16
		  && (prev_pinfo2 & INSN2_WRITE_GPR_Z)
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RZ, history[0]),
				    MIPS_GR_REG))
	      || (mips_opts.mips16
		  && (((prev_pinfo & MIPS16_INSN_WRITE_X)
		       && (insn_uses_reg
			   (ip, MIPS16_EXTRACT_OPERAND (RX, history[0]),
			    MIPS16_REG)))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_Y)
			  && (insn_uses_reg
			      (ip, MIPS16_EXTRACT_OPERAND (RY, history[0]),
			       MIPS16_REG)))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_Z)
			  && (insn_uses_reg
			      (ip, MIPS16_EXTRACT_OPERAND (RZ, history[0]),
			       MIPS16_REG)))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_T)
			  && insn_uses_reg (ip, TREG, MIPS_GR_REG))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_31)
			  && insn_uses_reg (ip, RA, MIPS_GR_REG))
		      || ((prev_pinfo & MIPS16_INSN_WRITE_GPR_Y)
			  && insn_uses_reg (ip,
					    MIPS16OP_EXTRACT_REG32R
					      (history[0].insn_opcode),
					    MIPS_GR_REG))))
d3505 2
a3506 22
		 instruction sets, we can not swap (we know that
		 branches write only to RD or to $31).  */
	      || (! mips_opts.mips16
		  && (prev_pinfo & INSN_WRITE_GPR_T)
		  && (((pinfo & INSN_WRITE_GPR_D)
		       && (EXTRACT_OPERAND (RT, history[0])
			   == EXTRACT_OPERAND (RD, *ip)))
		      || ((pinfo & INSN_WRITE_GPR_31)
			  && EXTRACT_OPERAND (RT, history[0]) == RA)))
	      || (! mips_opts.mips16
		  && (prev_pinfo & INSN_WRITE_GPR_D)
		  && (((pinfo & INSN_WRITE_GPR_D)
		       && (EXTRACT_OPERAND (RD, history[0])
			   == EXTRACT_OPERAND (RD, *ip)))
		      || ((pinfo & INSN_WRITE_GPR_31)
			  && EXTRACT_OPERAND (RD, history[0]) == RA)))
	      || (mips_opts.mips16
		  && (pinfo & MIPS16_INSN_WRITE_31)
		  && ((prev_pinfo & MIPS16_INSN_WRITE_31)
		      || ((prev_pinfo & MIPS16_INSN_WRITE_GPR_Y)
			  && (MIPS16OP_EXTRACT_REG32R (history[0].insn_opcode)
			      == RA))))
d3508 2
a3509 13
		 instruction reads, we can not swap (we know that
		 branches only write to RD or to $31).  */
	      || (! mips_opts.mips16
		  && (pinfo & INSN_WRITE_GPR_D)
		  && insn_uses_reg (&history[0],
				    EXTRACT_OPERAND (RD, *ip),
				    MIPS_GR_REG))
	      || (! mips_opts.mips16
		  && (pinfo & INSN_WRITE_GPR_31)
		  && insn_uses_reg (&history[0], RA, MIPS_GR_REG))
	      || (mips_opts.mips16
		  && (pinfo & MIPS16_INSN_WRITE_31)
		  && insn_uses_reg (&history[0], RA, MIPS_GR_REG))
@


1.464
log
@gas/
	PR gas/12915
	* config/tc-mips.c (nops_for_vr4130, nops_for_24k, nops_for_insn)
	(nops_for_sequence, nops_for_insn_or_target): Add ignore parameters.
	(mips_emit_delays, start_noreorder): Update accordingly.
	(append_insn): Likewise.  Revert original fix for this PR
	and use the ignore parameter instead.

gas/testsuite/
	* gas/mips/vr4130.s: Add some more ".set noreorder" tests.
	* gas/mips/vr4130.d: Update accordingly.
@
text
@d2743 1
a2743 1
                      const struct mips_cl_insn *insn)
d2807 2
a2808 5
  /* If INSN is definitely not a store, there's nothing to worry about.  */
  if (insn && (insn->insn_mo->pinfo & INSN_STORE_MEMORY) == 0)
    return 0;

  /* Likewise, the previous instruction wasn't a store.  */
d2812 3
a2814 2
  /* If we don't know what came before, assume the worst.  */
  if (hist[1].frag == NULL)
d2817 3
a2819 2
  /* If the instruction was not a store, there's nothing to worry about.  */
  if ((hist[1].insn_mo->pinfo & INSN_STORE_MEMORY) == 0)
d2824 1
a2824 2
  if (insn == NULL
      || !BASE_REG_EQ (insn->insn_opcode, hist[0].insn_opcode)
@


1.463
log
@gas/
	PR gas/12915
	* config/tc-mips.c (append_insn): Only consider hazards between the
	pre-noreorder block and ip.

gas/testsuite/
	* gas/mips/pr12915.s, gas/mips/pr12915.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d2647 2
a2648 1
   the MAX_VR4130_NOPS instructions described by HIST.  */
d2651 1
a2651 1
nops_for_vr4130 (const struct mips_cl_insn *hist,
d2683 2
a2684 1
	return MAX_VR4130_NOPS - i;
d2754 31
a2784 27
/* 24K Errata: Lost Data on Stores During Refill. 
  
  Problem: The FSB (fetch store buffer) acts as an intermediate buffer
  for the data cache refills and store data. The following describes
  the scenario where the store data could be lost.
  
  * A data cache miss, due to either a load or a store, causing fill
    data to be supplied by the memory subsystem
  * The first three doublewords of fill data are returned and written
    into the cache
  * A sequence of four stores occurs in consecutive cycles around the
    final doubleword of the fill:
  * Store A
  * Store B
  * Store C
  * Zero, One or more instructions
  * Store D
  
  The four stores A-D must be to different doublewords of the line that
  is being filled. The fourth instruction in the sequence above permits
  the fill of the final doubleword to be transferred from the FSB into
  the cache. In the sequence above, the stores may be either integer
  (sb, sh, sw, swr, swl, sc) or coprocessor (swc1/swc2, sdc1/sdc2,
  swxc1, sdxc1, suxc1) stores, as long as the four stores are to
  different doublewords on the line. If the floating point unit is
  running in 1:2 mode, it is not possible to create the sequence above
  using only floating point store instructions.
d2791 1
a2791 1
  The workarounds are:
d2793 3
a2795 3
  * Run the data cache in write-through mode.
  * Insert a non-store instruction between
    Store A and Store B or Store B and Store C.  */
d2798 1
a2798 1
nops_for_24k (const struct mips_cl_insn *hist,
d2804 3
d2881 5
a2885 2
   where HIST[0] is the most recent instruction.  If INSN is null,
   return the worse-case number of nops for any instruction.  */
d2888 1
a2888 1
nops_for_insn (const struct mips_cl_insn *hist,
d2894 1
a2894 1
  for (i = 0; i < MAX_DELAY_NOPS; i++)
d2903 1
a2903 1
      tmp_nops = nops_for_vr4130 (hist, insn);
d2910 1
a2910 1
      tmp_nops = nops_for_24k (hist, insn);
d2920 2
a2921 1
   would be needed after the extended sequence.  */
d2924 2
a2925 1
nops_for_sequence (int num_insns, const struct mips_cl_insn *hist, ...)
d2938 1
a2938 1
  nops = nops_for_insn (buffer, NULL);
d2947 1
a2947 1
nops_for_insn_or_target (const struct mips_cl_insn *hist,
d2952 1
a2952 1
  nops = nops_for_insn (hist, insn);
d2957 2
a2958 1
      tmp_nops = nops_for_sequence (2, hist, insn, NOP_INSN);
d2966 1
a2966 1
      tmp_nops = nops_for_sequence (1, hist, insn);
d3134 2
a3135 2
		  ? nops_for_insn (history, NULL)
		  : nops_for_insn_or_target (history, ip));
d3172 1
a3172 2
      struct mips_cl_insn stubbed_history[ARRAY_SIZE (history)];
      int nops, i;
d3174 4
a3177 9
      /* Work out how many nops in prev_nop_frag are needed by IP.
	 Base this on a history in which all insns since prev_nop_frag
	 are stubbed out with nops.  */
      for (i = 0; i < (int) ARRAY_SIZE (history); i++)
	if (i < prev_nop_frag_since)
	  stubbed_history[i] = *NOP_INSN;
	else
	  stubbed_history[i] = history[i];
      nops = nops_for_insn_or_target (stubbed_history, ip);
d3498 1
a3498 1
	      || nops_for_insn (history + 1, ip) > 0
d3501 1
a3501 1
	      || nops_for_sequence (2, history + 1, ip, history) > 0
d3700 1
a3700 1
      int nops = nops_for_insn (history, NULL);
d3728 1
a3728 1
      nops = nops_for_insn (history, NULL);
@


1.462
log
@2011-04-20  Catherine Moore  <clm@@codesourcery.com>
            David Ung <davidu@@mips.com>

	* config/mips.c (mips_cl_insn): Add new field complete_p.
	(create_insn): Initialize complete_p to zero.
	(BASE_REG_EQ): New.
	(fix_24k_align_to): New.
	(fix_24k_store_info): Declare.
	(fix_24k_sort): New.
	(fix_24k_record_store_info): New.
	(nops_for_24k): New.
	(nops_for_insn): Call nops_for_24k.
	(append_insn): Move O_constant expression handling.
@
text
@d3157 12
a3168 2
      /* Work out how many nops in prev_nop_frag are needed by IP.  */
      int nops = nops_for_insn_or_target (history, ip);
@


1.461
log
@	gas/
	* config/tc-mips.c (append_insn): Disable branch relaxation for
	DSP instructions.

	gas/testsuite/
	* gas/mips/relax-bposge.l: New test for DSP branch relaxation.
	* gas/mips/relax-bposge.s: Source for the new test.
	* gas/mips/mips.exp: Run the new test.
@
text
@d159 3
d1390 1
d2687 183
d2896 7
d3033 76
d3280 2
a3281 69
      if (address_expr->X_op == O_constant)
	{
	  unsigned int tmp;

	  switch (*reloc_type)
	    {
	    case BFD_RELOC_32:
	      ip->insn_opcode |= address_expr->X_add_number;
	      break;

	    case BFD_RELOC_MIPS_HIGHEST:
	      tmp = (address_expr->X_add_number + 0x800080008000ull) >> 48;
	      ip->insn_opcode |= tmp & 0xffff;
	      break;

	    case BFD_RELOC_MIPS_HIGHER:
	      tmp = (address_expr->X_add_number + 0x80008000ull) >> 32;
	      ip->insn_opcode |= tmp & 0xffff;
	      break;

	    case BFD_RELOC_HI16_S:
	      tmp = (address_expr->X_add_number + 0x8000) >> 16;
	      ip->insn_opcode |= tmp & 0xffff;
	      break;

	    case BFD_RELOC_HI16:
	      ip->insn_opcode |= (address_expr->X_add_number >> 16) & 0xffff;
	      break;

	    case BFD_RELOC_UNUSED:
	    case BFD_RELOC_LO16:
	    case BFD_RELOC_MIPS_GOT_DISP:
	      ip->insn_opcode |= address_expr->X_add_number & 0xffff;
	      break;

	    case BFD_RELOC_MIPS_JMP:
	      if ((address_expr->X_add_number & 3) != 0)
		as_bad (_("jump to misaligned address (0x%lx)"),
			(unsigned long) address_expr->X_add_number);
	      ip->insn_opcode |= (address_expr->X_add_number >> 2) & 0x3ffffff;
	      break;

	    case BFD_RELOC_MIPS16_JMP:
	      if ((address_expr->X_add_number & 3) != 0)
		as_bad (_("jump to misaligned address (0x%lx)"),
			(unsigned long) address_expr->X_add_number);
	      ip->insn_opcode |=
		(((address_expr->X_add_number & 0x7c0000) << 3)
		 | ((address_expr->X_add_number & 0xf800000) >> 7)
		 | ((address_expr->X_add_number & 0x3fffc) >> 2));
	      break;

	    case BFD_RELOC_16_PCREL_S2:
	      if ((address_expr->X_add_number & 3) != 0)
		as_bad (_("branch to misaligned address (0x%lx)"),
			(unsigned long) address_expr->X_add_number);
	      if (mips_relax_branch)
		goto need_reloc;
	      if ((address_expr->X_add_number + 0x20000) & ~0x3ffff)
		as_bad (_("branch address range overflow (0x%lx)"),
			(unsigned long) address_expr->X_add_number);
	      ip->insn_opcode |= (address_expr->X_add_number >> 2) & 0xffff;
	      break;

	    default:
	      internalError ();
	    }
	}
      else if (*reloc_type < BFD_RELOC_UNUSED)
@


1.460
log
@	gas/
	* config/tc-mips.c (macro): Handle M_PREF_AB.

	include/opcode/
	* mips.h (M_PREF_AB): New enum value.

	opcodes/
	* mips-opc.c (mips_builtin_opcodes): Add "pref" macro.
@
text
@d2936 2
@


1.459
log
@	gas/
	* config/tc-mips.c (RELAX_BRANCH_ENCODE): Encode the temporary
	register to use.
	(RELAX_BRANCH_UNCOND): Adjust accordingly.
	(RELAX_BRANCH_LIKELY): Likewise.
	(RELAX_BRANCH_LINK): Likewise.
	(RELAX_BRANCH_TOOFAR): Likewise.
	(RELAX_BRANCH_AT): New macro.
	(append_insn): Encode the temporary register to use in standard
	MIPS branch relaxation.
	(relaxed_branch_length): Update according to changes to
	RELAX_BRANCH_ENCODE.
	(md_convert_frag): Use the encoded register as the temporary.

	gas/testsuite/
	* gas/mips/relax-at.d: New test for branch relaxation with .set
	at.
	* gas/mips/relax.s: Update to support the new test.
	* gas/mips/relax.l: Update accordingly.
	* gas/mips/relax.d: Update for multi-arch invocation.
	* gas/mips/mips.exp: Run the new test.  Adjust to run "relax"
	across all applicable architectures.
@
text
@d6529 3
d6573 1
a6573 1
      else if (mask == M_CACHE_AB)
@


1.458
log
@	gas/
	* config/tc-mips.c (mips_fix_adjustable): On REL targets also
	reject PC-relative relocations.

	gas/testsuite/
	* gas/mips/branch-misc-2.d: Adjust for relocation change.
	* gas/mips/branch-misc-2pic.d: Likewise.
	* gas/mips/branch-misc-4.d: New test for PC-relative relocation
	overflow.
	* gas/mips/branch-misc-4-64.d: Likewise.
	* gas/mips/branch-misc-4.s: Source for the new tests.
	* testsuite/gas/mips/mips.exp: Run the new tests.
@
text
@d921 8
a928 7
#define RELAX_BRANCH_ENCODE(uncond, likely, link, toofar) \
  ((relax_substateT) \
   (0xc0000000 \
    | ((toofar) ? 1 : 0) \
    | ((link) ? 2 : 0) \
    | ((likely) ? 4 : 0) \
    | ((uncond) ? 8 : 0)))
d930 5
a934 4
#define RELAX_BRANCH_UNCOND(i) (((i) & 8) != 0)
#define RELAX_BRANCH_LIKELY(i) (((i) & 4) != 0)
#define RELAX_BRANCH_LINK(i) (((i) & 2) != 0)
#define RELAX_BRANCH_TOOFAR(i) (((i) & 1) != 0)
d2945 2
a2946 1
			(pinfo & INSN_UNCOND_BRANCH_DELAY,
d14151 2
a14152 1
      = RELAX_BRANCH_ENCODE (RELAX_BRANCH_UNCOND (fragp->fr_subtype),
d14562 2
d14565 2
a14566 1
	      insn = HAVE_64BIT_ADDRESSES ? 0xdf810000 : 0x8f810000;
d14593 2
a14594 1
	      insn = HAVE_64BIT_ADDRESSES ? 0x64210000 : 0x24210000;
d14606 1
a14606 1
		insn = 0x0020f809;
d14608 2
a14609 1
		insn = 0x00200008;
@


1.457
log
@	gas/
	* config/tc-mips.c (md_convert_frag): Correct message
	capitalization.

	gas/testsuite/
	* gas/mips/relax-swap1.l: Adjust for message capitalization
	correction.
	* gas/mips/relax-swap2.l: Likewise.
	* gas/mips/relax.l: Likewise.
@
text
@d14251 6
a14256 2
  /* There is no place to store an in-place offset for JALR relocations.  */
  if (fixp->fx_r_type == BFD_RELOC_MIPS_JALR && HAVE_IN_PLACE_ADDENDS)
@


1.456
log
@	* config/tc-mips.c (mips_ip) <'o'>: Remove duplicate
	initialization of offset_reloc.
@
text
@d14440 1
a14440 1
			 _("relaxed out-of-range branch into a jump"));
@


1.455
log
@Take unadjusted offset for loongson3a specific instructions.
@
text
@a10077 3
	      offset_reloc[0] = BFD_RELOC_LO16;
	      offset_reloc[1] = BFD_RELOC_UNUSED;
	      offset_reloc[2] = BFD_RELOC_UNUSED;
@


1.454
log
@bfd/
2010-12-23  Robert Millan  <rmh@@gnu.org>

	* config.bfd: Recognize mips-freebsd and mips-kfreebsd-gnu.
	* configure.host: Likewise.
	* configure.in: Support for `bfd_elf32_ntradbigmips_freebsd_vec',
	`bfd_elf32_ntradlittlemips_freebsd_vec',
	`bfd_elf32_tradbigmips_freebsd_vec',
	`bfd_elf32_tradlittlemips_freebsd_vec',
	`bfd_elf64_tradbigmips_freebsd_vec' and
	`bfd_elf64_tradlittlemips_freebsd_vec'.
	* configure: Regenerate.
	* elf32-mips.c: New target for FreeBSD support
	(same as traditional MIPS but overrides ELF_OSABI
	with ELFOSABI_FREEBSD).
	* elf64-mips.c: Likewise.
	* elfn32-mips.c: Likewise.
	* targets.c (_bfd_target_vector): Add
	`bfd_elf32_ntradbigmips_freebsd_vec',
	`bfd_elf32_ntradlittlemips_freebsd_vec',
	`bfd_elf32_tradbigmips_freebsd_vec',
	`bfd_elf32_tradlittlemips_freebsd_vec',
	`bfd_elf64_tradbigmips_freebsd_vec' and
	`bfd_elf64_tradlittlemips_freebsd_vec'.

ld/
2010-12-14  Robert Millan  <rmh@@gnu.org>

	* configure.tgt: Recognize mips-freebsd and mips-kfreebsd-gnu.

	* emulparams/elf32btsmip_fbsd.sh: New file.
	* emulparams/elf32btsmipn32_fbsd.sh: Likewise.
	* emulparams/elf32ltsmip_fbsd.sh: Likewise.
	* emulparams/elf32ltsmipn32_fbsd.sh: Likewise.
	* emulparams/elf64btsmip_fbsd.sh: Likewise.
	* emulparams/elf64ltsmip_fbsd.sh: Likewise.

	* Makefile.am: Add build rules for `eelf32btsmip_fbsd.c',
	`eelf32btsmipn32_fbsd.c', `eelf32ltsmip_fbsd.c',
	`eelf32ltsmipn32_fbsd.c', `eelf64btsmip_fbsd.c' and
	`eelf64ltsmip_fbsd.c'.
	* Makefile.in: Regenerate.

gas/
2010-12-19  Robert Millan  <rmh@@gnu.org>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.c (ELF_TARGET): New macro.  Generates target
	names accordingly to whether TE_FreeBSD and whether TE_TMIPS
	are defined.
	(mips_target_format): Refactor code using ELF_TARGET().
	(support_64bit_objects): Likewise.

	* configure.in: Recognize mips-freebsd and mips-kfreebsd-gnu.
	* configure.tgt: Likewise.
	* configure: Regenerate.

binutils/testsuite/
	* binutils-all/readelf.exp: Handle MIPS FreeBSD targets.

gas/testsuite/
	* gas/mips/e32el-rel2.d: Accept any file format.
	* gas/mips/elf-rel.d: Likewise.
	* gas/mips/elf-rel2.d: Likewise.
	* gas/mips/elf-rel3.d: Likewise.
	* gas/mips/elfel-rel.d: Likewise.
	* gas/mips/elfel-rel2.d: Likewise.
	* gas/mips/elfel-rel3.d: Likewise.
	* gas/mips/ldstla-32-mips3-shared.d: Likewise.
	* gas/mips/ldstla-32-mips3.d: Likewise.
	* gas/mips/ldstla-32-shared.d: Likewise.
	* gas/mips/ldstla-32.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/noat-1.d: Likewise.
	* gas/mips/set-arch.d: Likewise.
	* gas/mips/tls-o32.d: Likewise.

ld/testsuite/
	* ld-mips-elf/mips-elf-flags.exp: Handle FreeBSD targets.
	* ld-mips-elf/mips-elf.exp: Likewise.
	* ld-mips-elf/mips16-call-global.d: Accept any file format.
	* ld-mips-elf/mips16-intermix.d: Likewise.
@
text
@d9324 1
a9324 1
		      as_bad (_("immediate not in range %ld..%ld (%ld)"),
d9341 1
a9341 1
		      as_bad (_("immediate not in range %ld..%ld (%ld)"),
d9355 3
d9361 1
a9361 1
		      as_bad (_("immediate not in range %ld..%ld (%ld)"),
d9365 7
a9371 1
		  INSERT_OPERAND (OFFSET_C, *ip, imm_expr.X_add_number);
@


1.453
log
@include/opcode/
2010-12-14  Mingjie Xing  <mingjie.xing@@gmail.com>

	* mips.h (OP_*_OFFSET_A, OP_*_OFFSET_B, OP_*_OFFSET_C)
	(OP_*_RZ, OP_*_FZ, INSN2_M_FP_D, INSN2_WRITE_GPR_Z, INSN2_WRITE_FPR_Z)
	(INSN2_READ_GPR_Z, INSN2_READ_FPR_Z, INSN2_READ_GPR_D): Define.

opcodes/
2010-12-14  Mingjie Xing  <mingjie.xing@@gmail.com>

	* mips-opc.c (WR_z, WR_Z, RD_z, RD_Z, RD_d): Define.
	(mips_builtin_opcodes): Add loongson3a specific instructions.
	* mips-dis.c (print_insn_args): Handle the new arguments +a|b|c|z|Z.

gas/
2010-12-14  Mingjie Xing  <mingjie.xing@@gmail.com>

	* config/tc-mips.c (insn_uses_reg): Handle the new flags
	INSN2_READ_FPR_Z, INSN2_READ_GPR_D and INSN2_READ_GPR_Z.
	(append_insn): Handle delay-slot filling for the new flags.
	(validate_mips_insn): Handle the new arguments +a|b|c|z|Z.
	(mips_ip): Handle the new arguments +a|b|c|z|Z.

gas/testsuite/
2010-12-14  Mingjie Xing  <mingjie.xing@@gmail.com>

	* gas/mips/loongson-3a-2.s, gas/mips/loongson-3a-2.d,
	gas/mips/loongson-3a-3.s, gas/mips/loongson-3a-3.d: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d1316 8
a1339 12
#ifdef TE_TMIPS
      /* This is traditional mips.  */
      return (target_big_endian
	      ? (HAVE_64BIT_OBJECTS
		 ? "elf64-tradbigmips"
		 : (HAVE_NEWABI
		    ? "elf32-ntradbigmips" : "elf32-tradbigmips"))
	      : (HAVE_64BIT_OBJECTS
		 ? "elf64-tradlittlemips"
		 : (HAVE_NEWABI
		    ? "elf32-ntradlittlemips" : "elf32-tradlittlemips")));
#else
d1342 1
a1342 1
		 ? "elf64-bigmips"
d1344 2
a1345 1
		    ? "elf32-nbigmips" : "elf32-bigmips"))
d1347 1
a1347 1
		 ? "elf64-littlemips"
d1349 2
a1350 2
		    ? "elf32-nlittlemips" : "elf32-littlemips")));
#endif
d11264 2
a11265 8
#ifdef TE_TMIPS
    /* This is traditional mips */
    if (strcmp (*l, "elf64-tradbigmips") == 0
	|| strcmp (*l, "elf64-tradlittlemips") == 0)
#else
    if (strcmp (*l, "elf64-bigmips") == 0
	|| strcmp (*l, "elf64-littlemips") == 0)
#endif
@


1.452
log
@	* symbols.c (symbol_clone_if_forward_ref): Call tc_new_dot_label
	for new fake labels created off the dot special symbol.
	* config/tc-mips.h (tc_new_dot_label): New macro.
	(mips_record_label): New prototype.
	* config/tc-mips.c (my_getExpression): Remove MIPS16 fake label
	annotation.
	(s_cons, s_float_cons, s_gpword, s_gpdword): Only clear labels
	recorded once data expressions have been evaluated.
	(mips_define_label): Move code to record labels over to...
	(mips_record_label): ... this new function.
	* doc/internals.texi: Document tc_new_dot_label.
@
text
@d2278 4
d2291 6
d2822 1
d2836 1
d2838 1
d3178 1
a3178 1
      if (pinfo & INSN_WRITE_GPR_D)
d3186 2
d3196 2
d3292 4
d8503 5
d9319 71
@


1.451
log
@	* config/tc-mips.h (TC_ADDRESS_BYTES): New macro.
	(mips_address_bytes): New prototype.
	* config/tc-mips.c (mips_address_bytes): New function.
@
text
@a11138 1
  valueT val;
a11144 13

  /* If we are in mips16 mode, and this is an expression based on `.',
     then we bump the value of the symbol by 1 since that is how other
     text symbols are handled.  We don't bother to handle complex
     expressions, just `.' plus or minus a constant.  */
  if (mips_opts.mips16
      && ep->X_op == O_symbol
      && strcmp (S_GET_NAME (ep->X_add_symbol), FAKE_LABEL_NAME) == 0
      && S_GET_SEGMENT (ep->X_add_symbol) == now_seg
      && symbol_get_frag (ep->X_add_symbol) == frag_now
      && symbol_constant_p (ep->X_add_symbol)
      && (val = S_GET_VALUE (ep->X_add_symbol)) == frag_now_fix ())
    S_SET_VALUE (ep->X_add_symbol, val + 1);
d12715 1
a12716 1
  cons (1 << log_size);
d12738 1
a12739 2

  float_cons (type);
a13503 1
  mips_clear_insn_labels ();
d13506 1
a13543 1
  mips_clear_insn_labels ();
d13546 1
d14694 5
a14698 3
/* This function is called whenever a label is defined.  It is used
   when handling branch delays; if a branch has a label, we assume we
   can not move it.  */
d14701 1
a14701 1
mips_define_label (symbolS *sym)
d14717 1
d14719 7
@


1.450
log
@	* config/tc-mips.c (mips_ip): Remove dead format specifier code.
@
text
@d1237 9
@


1.449
log
@	gas/
	* config/tc-mips.c (file_ase_mips16): Adjust comment.
	(append_insn): Update file_ase_mips16.
	(mips_after_parse_args): Don't set file_ase_mips16 here.

	gas/testsuite/
	* gas/mips/elf_ase_mips16.d: Update test for new MIPS16 ASE flag
	semantics.
	* gas/mips/elf_ase_mips16-2.d: New test.
	* gas/mips/nop.s: Source for the new test.
	* gas/mips/mips.exp: Run the new test.

	binutils/testsuite/
	* lib/binutils-common.exp (regexp_diff): Implement inverse
	matching, requested by `!'.
@
text
@a9519 1
		    case 'G':
a9547 5
		    case 'D':
		      /* Itbl operand; not yet implemented. FIXME ?? */
		      break;
		      /* What about all other operands like 'i', which
			 can be specified in the opcode table? */
@


1.448
log
@	* config/tc-mips.c (macro)
	<M_MSGSND, M_MSGLD, M_MSGLD_T, M_MSGWAIT, M_MSGWAIT_T>: Remove
	dedicated return points.
@
text
@d285 1
a285 2
/* True if -mips16 was passed or implied by arguments passed on the
   command line (e.g., by -march).  */
d2813 2
a12048 1
  file_ase_mips16 = mips_opts.mips16;
@


1.447
log
@	* config/tc-mips.c (macro) <M_DEXT, M_DINS>: Correct types used
	for pos and size.
@
text
@d6147 1
a6147 2
      /* AT is not used, just return */
      return;
d6154 1
a6154 2
      /* AT is not used, just return */
      return;
d6161 1
a6161 2
      /* AT is not used, just return */
      return;
d6165 1
a6165 2
      /* AT is not used, just return */
      return;
d6172 1
a6172 2
      /* AT is not used, just return */
      return;
@


1.446
log
@	gas/
	* config/tc-mips.c (macro) <ld_st>: Don't load a zero into an
	auxiliary register when using a signed 16-bit constant offset.

	gas/testsuite/
	* gas/mips/ldstla-32.d: Update according to a 16-bit constant
	offset optimization.
	* gas/mips/ldstla-32-mips3.d: Likewise.
	* gas/mips/ldstla-32-shared.d: Likewise.
	* gas/mips/ldstla-32-mips3-shared.d: Likewise.
@
text
@d5265 3
a5267 2
	unsigned long pos;
	unsigned long size;
d5276 2
a5277 2
	    pos = (unsigned long) imm_expr.X_add_number;
	    size = (unsigned long) imm2_expr.X_add_number;
d5282 1
a5282 1
	    as_bad (_("Improper position (%lu)"), pos);
d5288 1
a5288 1
		    size, pos);
d5307 2
a5308 1
	macro_build ((expressionS *) NULL, s, fmt, treg, sreg, pos, size - 1);
d5314 3
a5316 2
	unsigned long pos;
	unsigned long size;
d5325 2
a5326 2
	    pos = (unsigned long) imm_expr.X_add_number;
	    size = (unsigned long) imm2_expr.X_add_number;
d5331 1
a5331 1
	    as_bad (_("Improper position (%lu)"), pos);
d5337 1
a5337 1
		    size, pos);
@


1.445
log
@	* config/tc-mips.c (mips_ip): Remove lastregno's
	preinitialization.
@
text
@d6568 1
a6568 2
	  expr1.X_add_number = ((offset_expr.X_add_number + 0x8000)
				& ~(bfd_vma) 0xffff);
d6570 11
a6580 5
	  load_register (tempreg, &expr1, HAVE_64BIT_ADDRESSES);
	  if (breg != 0)
	    macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			 tempreg, tempreg, breg);
	  macro_build (&offset_expr, s, fmt, treg, BFD_RELOC_LO16, tempreg);
@


1.444
log
@	* config/tc-mips.c (mips_ip) <'('>: Don't let '4', '5' or '-'
	as a base register specifier.
@
text
@d8634 1
a8634 1
  unsigned int lastregno = 0;
@


1.443
log
@	* config/tc-mips.c (macro) <M_S_DOB>: Fix the placement of code.
@
text
@d8994 1
a8994 2
	      gas_assert (args[1] == 'b' || args[1] == '5'
		      || args[1] == '-' || args[1] == '4');
@


1.442
log
@	* config/tc-mips.c (mips_ip) <'u'>: Report the value of the LUI
	argument complained about; reword the message.
@
text
@d7065 11
a7679 11
    case M_S_DOB:
      gas_assert (mips_opts.isa == ISA_MIPS1);
      /* Even on a big endian machine $fn comes before $fn+1.  We have
	 to adjust when storing to memory.  */
      macro_build (&offset_expr, "swc1", "T,o(b)",
		   target_big_endian ? treg + 1 : treg, BFD_RELOC_LO16, breg);
      offset_expr.X_add_number += 4;
      macro_build (&offset_expr, "swc1", "T,o(b)",
		   target_big_endian ? treg : treg + 1, BFD_RELOC_LO16, breg);
      break;

@


1.441
log
@	* config/tc-mips.c (macro)
	<M_BGTUL_I, M_BGTU_I, M_BLEUL_I, M_BLEU_I>: Fix the constant
	used to compare against for the always-false/true case.
@
text
@d10002 2
a10003 1
		as_bad (_("lui expression not in range 0..65535"));
@


1.440
log
@	* config/tc-mips.c (macro): Remove a trailing 0 from NOP
	requests.
@
text
@d5071 1
a5071 1
	      && imm_expr.X_add_number == (offsetT) 0xffffffff))
d5206 1
a5206 1
	      && imm_expr.X_add_number == (offsetT) 0xffffffff))
@


1.439
log
@	* config/tc-mips.c (macro): Use EXTRACT_OPERAND to get register
	numbers.
@
text
@d4851 1
a4851 1
	macro_build (NULL, "nop", "", 0);
d5002 1
a5002 1
	    macro_build (NULL, "nop", "", 0);
d5418 1
a5418 1
	  macro_build (NULL, "nop", "", 0);
d7447 1
a7447 1
	  macro_build (NULL, "nop", "", 0);
d7478 1
a7478 1
	  macro_build (NULL, "nop", "", 0);
@


1.438
log
@	* config/tc-mips.c (macro): Replace 0 with ZERO in macro_build
	and move_register calls referring to $0.
@
text
@d4826 3
a4828 3
  treg = (ip->insn_opcode >> 16) & 0x1f;
  dreg = (ip->insn_opcode >> 11) & 0x1f;
  sreg = breg = (ip->insn_opcode >> 21) & 0x1f;
@


1.437
log
@	gas/
	* config/tc-mips.c (macro, mips_ip): Correct message
	capitalization.

	gas/testsuite/
	* gas/mips/at-2.l: Adjust according to message capitalization
	fixes.
	* gas/mips/illegal.l: Likewise.
	* gas/mips/jalr.l: Likewise.
	* gas/mips/octeon-ill.l: Likewise.
	* gas/mips/tls-ill.l: Likewise.
@
text
@d4957 1
a4957 1
	  macro_build (&offset_expr, s, "s,t,p", sreg, 0);
d4980 1
a4980 1
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, 0);
d5004 1
a5004 1
	    macro_build (&offset_expr, "bnel", "s,t,p", 0, 0);
d5046 1
a5046 1
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, 0);
d5057 1
a5057 1
		       "s,t,p", 0, treg);
d5062 1
a5062 1
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, 0);
d5086 1
a5086 1
		       "s,t,p", sreg, 0);
d5091 1
a5091 1
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, 0);
d5109 1
a5109 1
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, 0);
d5118 1
a5118 1
		       "s,t,p", sreg, 0);
d5125 1
a5125 1
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, 0);
d5143 1
a5143 1
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, 0);
d5181 1
a5181 1
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, 0);
d5190 1
a5190 1
		       "s,t,p", sreg, 0);
d5197 1
a5197 1
      macro_build (&offset_expr, likely ? "beql" : "beq", "s,t,p", AT, 0);
d5221 1
a5221 1
		       "s,t,p", sreg, 0);
d5226 1
a5226 1
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, 0);
d5244 1
a5244 1
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, 0);
d5255 1
a5255 1
		       "s,t,p", 0, treg);
d5260 1
a5260 1
      macro_build (&offset_expr, likely ? "bnel" : "bne", "s,t,p", AT, 0);
d5372 1
a5372 1
	    macro_build (NULL, "teq", "s,t,q", 0, 0, 7);
d5381 1
a5381 1
	  macro_build (NULL, "teq", "s,t,q", treg, 0, 7);
d5387 1
a5387 1
	  macro_build (&expr1, "bne", "s,t,p", treg, 0);
d5469 1
a5469 1
	    macro_build (NULL, "teq", "s,t,q", 0, 0, 7);
d5479 1
a5479 1
	    move_register (dreg, 0);
d5491 1
a5491 1
	    move_register (dreg, 0);
d5520 1
a5520 1
	  macro_build (NULL, "teq", "s,t,q", treg, 0, 7);
d5529 1
a5529 1
	  macro_build (&expr1, "bne", "s,t,p", treg, 0);
d7473 1
a7473 1
	macro_build (NULL, "tne", "s,t,q", AT, 0, 6);
d7477 1
a7477 1
	  macro_build (&expr1, "beq", "s,t,p", AT, 0);
d7501 1
a7501 1
      macro_build (NULL, "dsubu", "d,v,t", AT, 0, treg);
d7524 1
a7524 1
      macro_build (NULL, "subu", "d,v,t", AT, 0, treg);
d7594 1
a7594 1
      macro_build (NULL, "dsubu", "d,v,t", AT, 0, treg);
d7607 1
a7607 1
      macro_build (NULL, "subu", "d,v,t", AT, 0, treg);
@


1.436
log
@	* config/tc-mips.c (macro_build, macro, mips_ip, md_apply_fix):
	Fix formatting.
@
text
@d5580 1
a5580 1
	  as_bad (_("expression too complex"));
d5668 1
a5668 1
		as_bad (_("offset too large"));
d6528 1
a6528 1
	  as_bad (_("opcode not supported on this processor: %s"),
d6551 1
a6551 1
	  as_bad (_("expression too complex"));
d7127 1
a7127 1
	  as_bad (_("expression too complex"));
d7998 1
a7998 1
	as_bad (_("operand overflow"));
d8022 1
a8022 1
	as_bad (_("operand overflow"));
d8095 1
a8095 1
	as_bad (_("operand overflow"));
d8118 1
a8118 1
	as_bad (_("operand overflow"));
d8680 1
a8680 1
	  insn_error = _("unrecognized opcode");
d8688 1
a8688 1
	  insn_error = _("unrecognized opcode");
d9282 1
a9282 1
		  as_bad (_("Internal: bad mips opcode "
d9467 1
a9467 1
			as_warn (_("used $at without \".set noat\""));
d9469 1
a9469 1
			as_warn (_("used $%u with \".set at=$%u\""),
d9496 1
a9496 1
			    = _("source and destination must be different");
d9502 1
a9502 1
			    = _("a destination register must be supplied");
d9955 1
a9955 1
			as_bad (_("expression out of range"));
d10056 1
a10056 1
		as_bad (_("invalid coprocessor sub-selection value (0-7)"));
d10096 1
a10096 1
	      as_bad (_("bad char = '%c'\n"), *args);
d10107 1
a10107 1
	  insn_error = _("illegal operands");
d10112 1
a10112 1
      insn_error = _("illegal operands");
@


1.435
log
@	* config/tc-mips.c (md_convert_frag): Remove a call to
	S_GET_VALUE and use the result of resolve_symbol_value as the
	value of the symbol processed in MIPS16 relaxation.
@
text
@d3783 8
a3790 8
		  && (ep->X_op == O_constant
		      || (ep->X_op == O_symbol
			  && (*r == BFD_RELOC_MIPS_HIGHEST
			      || *r == BFD_RELOC_HI16_S
			      || *r == BFD_RELOC_HI16
			      || *r == BFD_RELOC_GPREL16
			      || *r == BFD_RELOC_MIPS_GOT_HI16
			      || *r == BFD_RELOC_MIPS_CALL_HI16))));
d4936 1
a4936 1
		       (int)imm_expr.X_add_number);
d4986 1
a4986 1
      /* check for > max integer */
d5000 1
a5000 1
	  /* result is always false */
d5268 1
a5268 1
        if (imm_expr.X_op != O_constant || imm2_expr.X_op != O_constant)
d5284 1
a5284 2
        if (size == 0 || size > 64
	    || (pos + size - 1) > 63)
d5315 1
a5315 1
        if (imm_expr.X_op != O_constant || imm2_expr.X_op != O_constant)
d5331 1
a5331 2
        if (size == 0 || size > 64
	    || (pos + size - 1) > 63)
d5555 1
a5555 1
      if (! dbl && HAVE_64BIT_OBJECTS)
d6207 1
a6207 1
		  if (! mips_frame_reg_valid)
d6213 1
a6213 1
		  if (! mips_cprestore_valid)
d6267 1
a6267 1
	      if (! mips_big_got)
d6304 1
a6304 1
	      if (! mips_big_got)
d6342 1
a6342 1
		  if (! mips_frame_reg_valid)
d6348 1
a6348 1
		  if (! mips_cprestore_valid)
d6897 4
a6900 4
		  && strcmp (segment_name (S_GET_SEGMENT
					   (offset_expr.X_add_symbol)),
			     ".lit4") == 0
		  && offset_expr.X_add_number == 0);
d7012 1
a7012 1
	      && offset_expr.X_add_number == 0);
d7144 1
a7144 1
      if (! target_big_endian)
d7147 1
a7147 2
      if (mips_pic == NO_PIC
	  || offset_expr.X_op == O_constant)
d7999 1
a7999 1
      if (! target_big_endian)
d8002 1
a8002 1
      if (! target_big_endian)
d8030 1
a8030 1
      if (! target_big_endian)
d8033 1
a8033 1
      if (! target_big_endian)
d8039 1
a8039 1
      /* If necessary, move the result in tempreg the final destination.  */
d8061 1
a8061 1
      if (! target_big_endian)
d8066 1
a8066 1
      if (! target_big_endian)
d8119 1
a8119 1
      if (! target_big_endian)
d8122 1
a8122 1
      if (! target_big_endian)
d8143 1
a8143 1
      if (! target_big_endian)
d8148 1
a8148 1
      if (! target_big_endian)
d8160 1
a8160 1
      if (! target_big_endian)
d8164 1
a8164 1
      if (! target_big_endian)
d8169 1
a8169 1
      if (! target_big_endian)
d8743 1
a8743 1
	    case '2': /* dsp 2-bit unsigned immediate in bit 11 */
d8757 1
a8757 1
	    case '3': /* dsp 3-bit unsigned immediate in bit 21 */
d8770 1
a8770 1
	    case '4': /* dsp 4-bit unsigned immediate in bit 21 */
d8783 1
a8783 1
	    case '5': /* dsp 8-bit unsigned immediate in bit 16 */
d8796 1
a8796 1
	    case '6': /* dsp 5-bit unsigned immediate in bit 21 */
d8809 1
a8809 1
	    case '7': /* four dsp accumulators in bits 11,12 */ 
d8822 1
a8822 1
	    case '8': /* dsp 6-bit unsigned immediate in bit 11 */
d8836 1
a8836 1
	    case '9': /* four dsp accumulators in bits 21,22 */
d8849 1
a8849 1
	    case '0': /* dsp 6-bit signed immediate in bit 20 */
d8866 1
a8866 1
	    case '\'': /* dsp 6-bit unsigned immediate in bit 16 */
d8880 1
a8880 1
	    case ':': /* dsp 7-bit signed immediate in bit 19 */
d8897 1
a8897 1
	    case '@@': /* dsp 10-bit signed immediate in bit 16 */
d8936 1
a8936 1
	    case '*': /* four dsp accumulators in bits 18,19 */ 
d8949 1
a8949 1
	    case '&': /* four dsp accumulators in bits 13,14 */ 
d8999 1
a8999 1
	    case ')':		/* these must match exactly */
d9028 1
a9028 1
			      imm_expr.X_add_number &= imm->mask;
d9036 1
a9036 1
		  
d9045 1
a9045 1
do_lsb:
d9069 1
a9069 1
do_msb:
d9105 1
a9105 1
do_msbd:
d9282 3
a9284 2
		  as_bad (_("internal: bad mips opcode (unknown extension operand type `+%c'): %s %s"),
		    *args, insn->name, insn->args);
d9318 3
a9320 3
	    case 'k':		/* cache code */
	    case 'h':		/* prefx code */
	    case '1':		/* sync type */
d9356 1
a9356 1
	    case 'c':		/* break code */
d9368 1
a9368 1
	    case 'q':		/* lower break code */
d9380 1
a9380 1
	    case 'B':           /* 20-bit syscall/break code.  */
d9392 1
a9392 1
	    case 'C':           /* Coprocessor code */
d9406 1
a9406 1
	    case 'J':           /* 19-bit wait code.  */
d9445 14
a9458 14
	    case 'b':		/* base register */
	    case 'd':		/* destination register */
	    case 's':		/* source register */
	    case 't':		/* target register */
	    case 'r':		/* both target and source */
	    case 'v':		/* both dest and source */
	    case 'w':		/* both dest and target */
	    case 'E':		/* coprocessor target register */
	    case 'K':		/* 'rdhwr' destination register */
	    case 'x':		/* ignore register name */
	    case 'z':		/* must be zero register */
	    case 'U':           /* destination register (clo/clz).  */
	    case 'g':		/* coprocessor destination register */
	      s_reset = s;	      
d9494 3
a9496 2
		        {
			  insn_error = _("source and destination must be different");
d9498 1
a9498 1
		        }
d9500 3
a9502 2
		        {
			  insn_error = _("a destination register must be supplied");
d9504 1
a9504 1
		        }
d9506 2
a9507 2
	/* Now that we have assembled one operand, we use the args string
	 * to figure out where it goes in the instruction.  */
d9601 4
a9604 4
	    case 'D':		/* floating point destination register */
	    case 'S':		/* floating point source register */
	    case 'T':		/* floating point target register */
	    case 'R':		/* floating point source register */
d9622 1
a9622 1
		      && ! mips_oddfpreg_ok (ip->insn_mo, argnum))
d9683 1
a9683 1
                      /* Fall through */
d9790 1
a9790 1
		    if (! target_big_endian)
d9796 1
a9796 1
			 && ! mips_disable_float_construction
d9803 1
a9803 1
			     || ! (HAVE_64BIT_FPRS && HAVE_32BIT_GPRS))
d9810 4
a9813 4
                       instructions.  If using 32-bit registers, set
                       imm_expr to the high order 32 bits and offset_expr to
                       the low order 32 bits.  Otherwise, set imm_expr to
                       the entire 64 bit constant.  */
d9818 1
a9818 1
			if (! target_big_endian)
d9834 1
a9834 1
			if (! target_big_endian)
d9843 1
a9843 1
			if (! target_big_endian)
d9914 2
a9915 2
	    case 'i':		/* 16 bit unsigned immediate */
	    case 'j':		/* 16 bit signed immediate */
d9961 1
a9961 1
	    case 'o':		/* 16 bit offset */
d9991 1
a9991 1
	    case 'p':		/* pc relative offset */
d9997 1
a9997 1
	    case 'u':		/* upper 16 bits */
d10006 1
a10006 1
	    case 'a':		/* 26 bit address */
d10012 2
a10013 2
	    case 'N':		/* 3 bit branch condition code */
	    case 'M':		/* 3 bit compare condition code */
d10015 1
a10015 1
	      if (ip->insn_mo->pinfo & (FP_D| FP_S))
d10019 3
a10021 3
	      if ((strcmp(str + strlen(str) - 3, ".ps") == 0
		   || strcmp(str + strlen(str) - 5, "any2f") == 0
		   || strcmp(str + strlen(str) - 5, "any2t") == 0)
d10023 2
a10024 1
		as_warn (_("Condition code register should be even for %s, was %d"),
d10026 2
a10027 2
	      if ((strcmp(str + strlen(str) - 5, "any4f") == 0
		   || strcmp(str + strlen(str) - 5, "any4t") == 0)
d10029 2
a10030 1
		as_warn (_("Condition code register should be 0 or 4 for %s, was %d"),
d12270 7
a12276 7
	  || fixP->fx_r_type == BFD_RELOC_16
	  || fixP->fx_r_type == BFD_RELOC_64
	  || fixP->fx_r_type == BFD_RELOC_CTOR
	  || fixP->fx_r_type == BFD_RELOC_MIPS_SUB
	  || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
	  || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY
	  || fixP->fx_r_type == BFD_RELOC_MIPS_TLS_DTPREL64);
@


1.434
log
@	* mips.h (INSN_CHIP_MASK): Update according to INSN_LOONGSON_3A.
	(INSN_LOONGSON_3A): Clear bit 31.

	* elfxx-mips.c (mips_set_isa_flags): Move bfd_mach_loongson_3a
	after bfd_mach_mips_sb1.

	* config/tc-mips.c (mips_cpu_info_table): Move loongson3a after sb1.
@
text
@d14551 1
a14551 2
      resolve_symbol_value (fragp->fr_symbol);
      val = S_GET_VALUE (fragp->fr_symbol);
@


1.433
log
@gas/
	* config/tc-mips.c (macro_build): Remove gas_assert from 'o' case.
	Use a restricted gas_assert for 'i' and 'j'.

gas/testsuite/
	* gas/mips/elf-rel28.s, gas/mips/elf-rel28-n32.d,
	gas/mips/elf-rel28-n64.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@a15360 1
  { "loongson3a",     0,			ISA_MIPS64,	CPU_LOONGSON_3A },
d15368 2
@


1.432
log
@	bfd/
	* archures.c (bfd_mach_mips_loongson_3a): Defined.
	* bfd-in2.h (bfd_mach_mips_loongson_3a): Defined.
	* cpu-mips.c (I_loongson_3a): New add.
	(arch_info_struct): Add loongson_3a.
	* elfxx-mips.c (_bfd_elf_mips_mach): Add loongson_3a.
	(mips_set_isa_flags): Add loongson_3a.
	(mips_mach_extensions): Add loongson_3a in MIPS64 extensions.

	binutils/
	* readelf.c (get_machine_flags): Add loongson-3a.

	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add loongson3a in MIPS 64.
	* doc/c-mips.texi (MIPS cpu): Add loongson3a.

	include/
	* elf/mips.h (E_MIPS_MACH_LS3A): Defined.
	* opcode/mips.h (INSN_LOONGSON_3A): Defined.
	(CPU_LOONGSON_3A): Defined.
	(OPCODE_IS_MEMBER): Add LOONGSON_3A.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add loongson3a.
	* mips-opc.c (IL3A): Defined as INSN_LOONGSON_3A.
	(mips_builtin_opcodes): Modify some instructions' membership from
	IL2F to IL2F|IL3A, since these instructions are supported by Loongson_3A.
@
text
@d3768 8
a3777 12
	  gas_assert (*r == BFD_RELOC_GPREL16
		  || *r == BFD_RELOC_MIPS_LITERAL
		  || *r == BFD_RELOC_MIPS_HIGHER
		  || *r == BFD_RELOC_HI16_S
		  || *r == BFD_RELOC_LO16
		  || *r == BFD_RELOC_MIPS_GOT16
		  || *r == BFD_RELOC_MIPS_CALL16
		  || *r == BFD_RELOC_MIPS_GOT_DISP
		  || *r == BFD_RELOC_MIPS_GOT_PAGE
		  || *r == BFD_RELOC_MIPS_GOT_OFST
		  || *r == BFD_RELOC_MIPS_GOT_LO16
		  || *r == BFD_RELOC_MIPS_CALL_LO16);
d9969 3
@


1.431
log
@	* config/tc-mips.c (macro)[M_LD_OB, M_SD_OB]: Use the offset
	reloc supplied.
	(mips_ip)['o']: Initialise offset_reloc.
@
text
@d15362 1
@


1.431.2.1
log
@gas/
	* config/tc-mips.c (macro_build): Remove gas_assert from 'o' case.
	Use a restricted gas_assert for 'i' and 'j'.

gas/testsuite/
	* gas/mips/elf-rel28.s, gas/mips/elf-rel28-n32.d,
	gas/mips/elf-rel28-n64.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d3768 1
d3771 11
a3781 8
		      || *r == BFD_RELOC_MIPS_HIGHER
		      || *r == BFD_RELOC_HI16_S
		      || *r == BFD_RELOC_LO16
		      || *r == BFD_RELOC_MIPS_GOT_OFST);
	  continue;

	case 'o':
	  macro_read_relocs (&args, r);
@


1.431.2.2
log
@backport from mainline
@
text
@d11127 1
d11134 13
d12718 1
a12719 1
  mips_clear_insn_labels ();
d12741 2
a12743 1
  mips_clear_insn_labels ();
d13508 1
a13510 1
  mips_clear_insn_labels ();
d13548 1
a13550 1
  mips_clear_insn_labels ();
d14699 3
a14701 5
/* This function is called whenever a label is defined, including fake
   labels instantiated off the dot special symbol.  It is used when
   handling branch delays; if a branch has a label, we assume we cannot
   move it.  This also bumps the value of the symbol by 1 in compressed
   code.  */
d14704 1
a14704 1
mips_record_label (symbolS *sym)
a14719 1
}
a14720 7
/* This function is called as tc_frob_label() whenever a label is defined
   and adds a DWARF-2 record we only want for true labels.  */

void
mips_define_label (symbolS *sym)
{
  mips_record_label (sym);
@


1.430
log
@gas/
	* config/tc-mips.c (macro2): Delete.
@
text
@d7353 3
a7355 1
      macro_build (&offset_expr, s, "t,o(b)", treg, BFD_RELOC_LO16, breg);
d7360 2
a7361 1
		       BFD_RELOC_LO16, breg);
d9966 4
@


1.429
log
@	* config/tc-mips.c (macro)[ldd_std]: Fix the relaxation variant
	for absolute addressing.
@
text
@a1074 3
#ifdef LOSING_COMPILER
static void macro2 (struct mips_cl_insn * ip);
#endif
a7407 60
#ifdef LOSING_COMPILER
    default:
      /* Try and see if this is a new itbl instruction.
         This code builds table entries out of the macros in mip_opcodes.
         FIXME: For now we just assemble the expression and pass it's
         value along as a 32-bit immediate.
         We may want to have the assembler assemble this value,
         so that we gain the assembler's knowledge of delay slots,
         symbols, etc.
         Would it be more efficient to use mask (id) here? */
      if (itbl_have_entries
	  && (immed_expr = itbl_assemble (ip->insn_mo->name, "")))
	{
	  s = ip->insn_mo->name;
	  s2 = "cop3";
	  coproc = ITBL_DECODE_PNUM (immed_expr);;
	  macro_build (&immed_expr, s, "C");
	  break;
	}
      macro2 (ip);
      break;
    }
  if (!mips_opts.at && used_at)
    as_bad (_("Macro used $at after \".set noat\""));
}

static void
macro2 (struct mips_cl_insn *ip)
{
  unsigned int treg, sreg, dreg, breg;
  unsigned int tempreg;
  int mask;
  int used_at;
  expressionS expr1;
  const char *s;
  const char *s2;
  const char *fmt;
  int likely = 0;
  int dbl = 0;
  int coproc = 0;
  int lr = 0;
  int imm = 0;
  int off;
  offsetT maxnum;
  bfd_reloc_code_real_type r;

  treg = (ip->insn_opcode >> 16) & 0x1f;
  dreg = (ip->insn_opcode >> 11) & 0x1f;
  sreg = breg = (ip->insn_opcode >> 21) & 0x1f;
  mask = ip->insn_mo->mask;

  expr1.X_op = O_constant;
  expr1.X_op_symbol = NULL;
  expr1.X_add_symbol = NULL;
  expr1.X_add_number = 1;

  switch (mask)
    {
#endif /* LOSING_COMPILER */

@


1.428
log
@	opcodes/
	* mips-opc.c (mips_builtin_opcodes): Move M_LD_OB and M_SD_OB
	macros before their corresponding MIPS III hardware instructions.

	gas/
	* config/tc-mips.c (macro)[M_LD_OB, M_SD_OB]: Handle 64-bit ABIs.

	gas/testsuite/
	* gas/mips/lineno.s: Convert to o32.
	* gas/mips/lineno.d: Adjust patterns accordingly.  Force the o32
	ABI.
@
text
@d7206 1
a7206 20
	      /* We just generated two relocs.  When tc_gen_reloc
		 handles this case, it will skip the first reloc and
		 handle the second.  The second reloc already has an
		 extra addend of 4, which we added above.  We must
		 subtract it out, and then subtract another 4 to make
		 the first reloc come out right.  The second reloc
		 will come out right because we are going to add 4 to
		 offset_expr when we build its instruction below.

		 If we have a symbol, then we don't want to include
		 the offset, because it will wind up being included
		 when we generate the reloc.  */

	      if (offset_expr.X_op == O_constant)
		offset_expr.X_add_number -= 8;
	      else
		{
		  offset_expr.X_add_number = -4;
		  offset_expr.X_op = O_constant;
		}
@


1.427
log
@	* config/tc-mips.c (mips_pseudo_table): Add "sbss".
	(s_change_sec): Handle it.
@
text
@d7370 1
a7370 1
      s = "lw";
d7373 1
a7373 1
      s = "sw";
a7374 1
      gas_assert (HAVE_32BIT_ADDRESSES);
d7376 6
a7381 2
      offset_expr.X_add_number += 4;
      macro_build (&offset_expr, s, "t,o(b)", treg + 1, BFD_RELOC_LO16, breg);
@


1.426
log
@2010-10-04  David Daney  <ddaney@@caviumnetworks.com>

	* config/tc-mips.c (mips_fix_cn63xxp1): New variable.
	(mips_ip):  Add errata work around when mips_fix_cn63xxp1 set.
	(OPTION_FIX_CN63XXP1, OPTION_NO_FIX_CN63XXP1): New enum options
	enumerations.
	(md_longopts): Add options for -mfix-cn63xxp1 and -mno-fix-cn63xxp1.
	(md_parse_option): Handle OPTION_FIX_CN63XXP1 and
	OPTION_NO_FIX_CN63XXP1.
	(md_show_usage): Add documentation for -mfix-cn63xxp1.
	* doc/c-mips.texi (-mfix-cn63xxp1, -mno-fix-cn63xxp1): Document
	the new options.

2010-10-04  David Daney  <ddaney@@caviumnetworks.com>

	* gas/mips/mips.exp (octeon-pref): Run the new test.
	* gas/mips/octeon-pref.s: New test.
	* gas/mips/octeon-pref.d: New expected results for the new test.
@
text
@d1194 3
d12684 11
@


1.425
log
@	* config/tc-mips.c (mips16_macro_build): Pass "args" by
	reference rather than value.
	(macro_build): Update accordingly.
@
text
@d789 3
d9407 20
a9426 1
		INSERT_OPERAND (CACHE, *ip, imm_expr.X_add_number);
d11310 2
d11406 2
d11701 8
d15660 1
@


1.424
log
@	* config/tc-mips.c (mips_ip): Use symbol_temp_new_now to create
	a fake label.
@
text
@d1066 1
a1066 1
  (expressionS *, const char *, const char *, va_list);
d3619 1
a3619 1
      mips16_macro_build (ep, name, fmt, args);
d3845 1
a3845 1
		    va_list args)
d3881 1
a3881 1
	  MIPS16_INSERT_OPERAND (RY, insn, va_arg (args, int));
d3886 1
a3886 1
	  MIPS16_INSERT_OPERAND (RX, insn, va_arg (args, int));
d3890 1
a3890 1
	  MIPS16_INSERT_OPERAND (RZ, insn, va_arg (args, int));
d3894 1
a3894 1
	  MIPS16_INSERT_OPERAND (MOVE32Z, insn, va_arg (args, int));
d3904 1
a3904 1
	  MIPS16_INSERT_OPERAND (REGR32, insn, va_arg (args, int));
d3911 1
a3911 1
	    regno = va_arg (args, int);
d3950 1
a3950 1
	  MIPS16_INSERT_OPERAND (IMM6, insn, va_arg (args, int));
@


1.423
log
@	gas/
	* config/tc-mips.c (macro)[M_JAL_1, M_JAL_2]: Handle the JALR
	delay slot in the noreorder mode with the o32 ABI.

	gas/testsuite/
	* gas/mips/jal-svr4pic-noreorder.d: New test case.
	* gas/mips/mips1@@jal-svr4pic-noreorder.d: New test
	subarchitecture.
	* gas/mips/r3000@@jal-svr4pic-noreorder.d: Likewise.
	* gas/mips/jal-svr4pic-noreorder.s: Source for the new test
	case.
	* gas/mips/mips.exp: Run the new test case.
@
text
@d9956 1
a9956 3
		    offset_expr.X_add_symbol =
		      symbol_new ("L0\001", now_seg,
				  (valueT) frag_now_fix (), frag_now);
@


1.422
log
@2010-07-22  Thomas Schwinge  <thomas@@codesourcery.com>

	Switch MIPS to 32-bit DWARF format.
	* config/tc-mips.h (DWARF2_FORMAT): Only define for [TE_IRIX].
	* config/tc-mips.c (mips_dwarf2_format): Likewise.
@
text
@d6222 2
@


1.421
log
@	gas/
	* config/tc-mips.c (mips_frob_file): Use symbol_same_p to match
	symbols.

	gas/testsuite/
	* gas/mips/elf-rel27.d: New test for HI16/LO16 relocation
	pairing.
	* gas/mips/elf-rel27.s: Source for the new test.
	* gas/mips/mips.exp: Create "mips16" architecture.  Adjust
	conditions involving negated properties throughout to require
	"mips1" as appropriate.  Run the new test.
	(mips_arch_destroy): New procedure.
@
text
@d15669 1
d15674 1
a15674 7
    {
#ifdef TE_IRIX
      return dwarf2_format_64bit_irix;
#else
      return dwarf2_format_64bit;
#endif
    }
d15678 1
@


1.420
log
@	gas/
	* config/tc-mips.c (nops_for_insn_or_target): Replace
	MIPS16_INSN_BRANCH with MIPS16_INSN_UNCOND_BRANCH and
	MIPS16_INSN_COND_BRANCH.

	include/opcode/
	* mips.h (MIPS16_INSN_UNCOND_BRANCH): New macro.
	(MIPS16_INSN_BRANCH): Rename to...
	(MIPS16_INSN_COND_BRANCH): ... this.

	opcodes/
	* mips-dis.c (print_mips16_insn_arg): Remove branch instruction
	type and delay slot determination.
	(print_insn_mips16): Extend branch instruction type and delay
	slot determination to cover all instructions.
	* mips16-opc.c (BR): Remove macro.
	(UBR, CBR): New macros.
	(mips16_opcodes): Update branch annotation for "b", "beqz",
	"bnez", "bteqz" and "btnez".  Add branch annotation for "jalrc"
	and "jrc".
@
text
@d12237 1
a12237 1
	      && (*pos)->fx_addsy == l->fixp->fx_addsy
@


1.419
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d2733 3
a2735 1
  else if (mips_opts.mips16 && (insn->insn_mo->pinfo & MIPS16_INSN_BRANCH))
@


1.418
log
@	gas/
	* config/tc-mips.c (is_opcode_valid): Remove expansionp.
	(macro_build): Change invocation of is_opcode_valid.
	(mips_ip): Likewise.

	gas/testsuite/
	* gas/mips/mips-no-jalx.l: Delete.
	* gas/mips/mips-no-jalx.s: Delete.
	* gas/mips/mips-jalx-2.d: New.
	* gas/mips/mips-jalx-2.s: New.
	* gas/mips/mips.exp (mips-jalx-2): Run new test.
	(mips-no-jalx): Remove deleted test.

	include/
	* opcode/mips.h (INSN_MIPS16): Remove.

	opcodes/
	* mips-dis.c (mips_arch): Remove INSN_MIPS16.
	* mips-opc.c (I16): Remove.
	(mips_builtin_op): Reclassify jalx.
@
text
@d12698 2
a15081 1
      valueT dot;
a15084 2
      dot = frag_now_fix ();

@


1.417
log
@        * config/tc-mips.c (mips_fix_loongson2f, mips_fix_loongson2f_nop,
        mips_fix_loongson2f_jump): New variables.
        (md_longopts): Add New options -mfix-loongson2f-nop/jump,
        -mno-fix-loongson2f-nop/jump.
        (md_parse_option): Initialize variables via above options.
        (options): New enums for the above options.
        (md_begin): Initialize nop_insn from LOONGSON2F_NOP_INSN.
        (fix_loongson2f, fix_loongson2f_nop, fix_loongson2f_jump):
        New functions.
        (append_insn): call fix_loongson2f().
        (mips_handle_align): Replace the implicit nops.
        * config/tc-mips.h (MAX_MEM_FOR_RS_ALIGN_CODE): Modified
        for the new mips_handle_align().
        * doc/c-mips.texi: Document the new options.

        * gas/mips/loongson-2f-2.s: New test of -mfix-loongson2f-nop.
        * gas/mips/loongson-2f-2.d: Likewise.
        * gas/mips/loongson-2f-3.s: New test of -mfix-loongson2f-jump.
        * gas/mips/loongson-2f-3.d: Likewise.
        * gas/mips/mips.exp: Run the new tests.

        * opcode/mips.h (LOONGSON2F_NOP_INSN): New macro.
@
text
@d1820 1
a1820 2
   architecture.  If EXPANSIONP is TRUE then this check is done while
   expanding a macro.  Use is_opcode_valid_16 for MIPS16 opcodes.  */
d1823 1
a1823 1
is_opcode_valid (const struct mips_opcode *mo, bfd_boolean expansionp)
a1842 5
  /* For user code we don't check for mips_opts.mips16 since we want
     to allow jalx if -mips16 was specified on the command line.  */
  if (expansionp ? mips_opts.mips16 : file_ase_mips16)
    isa |= INSN_MIPS16;

d3635 1
a3635 1
	  && is_opcode_valid (mo, TRUE))
d8773 1
a8773 1
      ok = is_opcode_valid (insn, FALSE);
@


1.416
log
@	gas/
	* config/tc-mips.c (s_mips_ent): Also set BSF_FUNCTION for
	".aent".

	gas/testsuite/
	* gas/mips/aent.d: New test.
	* gas/mips/aent.s: Source for the new test.
	* gas/mips/mips.exp: Run it.
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
d755 2
a756 1
enum fix_vr4120_class {
d766 9
d1062 1
a1062 1
  (struct mips_cl_insn *ip, expressionS *p, bfd_reloc_code_real_type *r);
d1064 1
d1933 2
d2748 48
d2809 3
d11284 4
d11376 4
d11647 16
d11877 2
d14884 2
d14893 8
a14900 1
      int bytes;
d14902 9
a14910 8
      bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
      if (bytes & 1)
	{
	  *p++ = 0;
	  fragp->fr_fix++;
	}
      md_number_to_chars (p, mips16_nop_insn.insn_opcode, 2);
      fragp->fr_var = 2;
d14912 3
d15626 2
@


1.415
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@a15049 2
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;

d15057 2
@


1.414
log
@gas/
	* config/tc-mips.c (MIPS_JALR_HINT_P): Take an expr argument.
	Require the target to be a bare symbol on targets with
	in-place addends.
	(macro_build_jalr): Update accordingly.
	(mips_fix_adjustable): Don't reduce R_MIPS_JALRs on targets
	with in-place addends.

gas/testsuite/
	* gas/mips/jalr2.s, gas/mips/jalr2.d: New test.
	* gas/mips/jal-svr4pic.d: Don't expect R_MIPS_JALRs to be reduced.
	* gas/mips/jal-xgot.d: Likewise.
	* gas/mips/mips-abi32-pic2.d: Likewise.
	* gas/mips/mips.exp: Run it.
@
text
@d2615 1
a2615 1
   the MAX_VR4130_NOPS instructions described by HISTORY.  */
d2618 1
a2618 1
nops_for_vr4130 (const struct mips_cl_insn *history,
d2633 1
a2633 1
    if (MF_HILO_INSN (history[i].insn_mo->pinfo))
d2637 1
a2637 1
	  reg = mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, history[i])];
d2639 1
a2639 1
	  reg = EXTRACT_OPERAND (RD, history[i]);
d2647 1
a2647 1
	  if (insn_uses_reg (&history[j], reg, MIPS_GR_REG))
d2656 2
a2657 2
   immediately followed the MAX_NOPS instructions given by HISTORY,
   where HISTORY[0] is the most recent instruction.  If INSN is null,
d2661 1
a2661 1
nops_for_insn (const struct mips_cl_insn *history,
d2669 1
a2669 1
      tmp_nops = insns_between (history + i, insn) - i;
d2676 1
a2676 1
      tmp_nops = nops_for_vr4130 (history, insn);
d2685 1
a2685 1
   might be added to HISTORY.  Return the largest number of nops that
d2689 1
a2689 1
nops_for_sequence (int num_insns, const struct mips_cl_insn *history, ...)
d2696 1
a2696 1
  va_start (args, history);
d2698 1
a2698 1
  memcpy (cursor, history, (MAX_NOPS - num_insns) * sizeof (*cursor));
d2711 1
a2711 1
nops_for_insn_or_target (const struct mips_cl_insn *history,
d2716 1
a2716 1
  nops = nops_for_insn (history, insn);
d2721 1
a2721 1
      tmp_nops = nops_for_sequence (2, history, insn, NOP_INSN);
d2727 1
a2727 1
      tmp_nops = nops_for_sequence (1, history, insn);
a5756 2
		  int dreg;

a5895 2
	      int dreg;

a6032 2
	      int dreg;

d7547 2
a7548 1
	char *l, *r;
d7568 1
a7568 1
	r = ((0x40 - rot) < 0x20) ? "dsrl" : "dsrl32";
d7572 1
a7572 1
	macro_build (NULL, r, "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
d7630 2
a7631 1
	char *l, *r;
d7649 1
a7649 1
	r = (rot < 0x20) ? "dsrl" : "dsrl32";
d7653 1
a7653 1
	macro_build (NULL, r, "d,w,<", AT, sreg, rot);
d10600 1
a10600 1
		int args = 0, statics = 0, sregs = 0;
d10655 1
a10655 1
				args |= 1 << (reg1 - 4);
d10681 1
a10681 1
		if (args & statics)
d10683 1
a10683 1
		else if (args == 0xf)
d10694 1
a10694 1
		    while (args & 0x1)
d10696 1
a10696 1
			args >>= 1;
d10699 1
a10699 1
		    if (args != 0)
@


1.413
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d295 1
a295 1
#define MIPS_JALR_HINT_P HAVE_NEWABI
d297 6
a302 2
/* As a GNU extension, we use R_MIPS_JALR for o32 too.  */
#define MIPS_JALR_HINT_P 1
d3937 1
a3937 1
  if (MIPS_JALR_HINT_P)
d3943 1
a3943 1
  if (MIPS_JALR_HINT_P)
d14104 4
@


1.412
log
@2009-08-05  Chao-ying Fu  <fu@@mips.com>

	* config/tc-mips.c (MIPS_JALR_HINT_P): New define. For IRIX, it is
	true for new abi.  For non-IRIX targets, it is always true.
	(macro_build_jalr): If MIPS_JALR_HINT_P, emit BFD_RELOC_MIPS_JALR.
@
text
@d2224 1
a2224 1
	       enum mips_regclass class)
d2226 1
a2226 1
  if (class == MIPS16_REG)
d2230 1
a2230 1
      class = MIPS_GR_REG;
d2234 1
a2234 1
  if (class == MIPS_GR_REG && reg == ZERO)
d2237 1
a2237 1
  if (class == MIPS_FP_REG)
@


1.412.2.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d2224 1
a2224 1
	       enum mips_regclass regclass)
d2226 1
a2226 1
  if (regclass == MIPS16_REG)
d2230 1
a2230 1
      regclass = MIPS_GR_REG;
d2234 1
a2234 1
  if (regclass == MIPS_GR_REG && reg == ZERO)
d2237 1
a2237 1
  if (regclass == MIPS_FP_REG)
@


1.412.2.2
log
@gas/
	* config/tc-mips.c (MIPS_JALR_HINT_P): Take an expr argument.
	Require the target to be a bare symbol on targets with
	in-place addends.
	(macro_build_jalr): Update accordingly.
	(mips_fix_adjustable): Don't reduce R_MIPS_JALRs on targets
	with in-place addends.

gas/testsuite/
	* gas/mips/jalr2.s, gas/mips/jalr2.d: New test.
	* gas/mips/jal-svr4pic.d: Don't expect R_MIPS_JALRs to be reduced.
	* gas/mips/jal-xgot.d: Likewise.
	* gas/mips/mips-abi32-pic2.d: Likewise.
	* gas/mips/mips.exp: Run it.
@
text
@d295 1
a295 1
#define MIPS_JALR_HINT_P(EXPR) HAVE_NEWABI
d297 2
a298 6
/* As a GNU extension, we use R_MIPS_JALR for o32 too.  However,
   because there's no place for any addend, the only acceptable
   expression is a bare symbol.  */
#define MIPS_JALR_HINT_P(EXPR) \
  (!HAVE_IN_PLACE_ADDENDS \
   || ((EXPR)->X_op == O_symbol && (EXPR)->X_add_number == 0))
d3933 1
a3933 1
  if (MIPS_JALR_HINT_P (ep))
d3939 1
a3939 1
  if (MIPS_JALR_HINT_P (ep))
a14099 4
  /* There is no place to store an in-place offset for JALR relocations.  */
  if (fixp->fx_r_type == BFD_RELOC_MIPS_JALR && HAVE_IN_PLACE_ADDENDS)
    return 0;

@


1.411
log
@2009-08-04  Sandra Loosemore  <sandra@@codesourcery.com>

	gas/
	* doc/c-mips.texi (MIPS Opts): List 1004K options for -march.
	* config/tc-mips.c (mips_cpu_info_table): Add 1004K cores.
@
text
@d293 8
d3933 1
a3933 1
  if (HAVE_NEWABI)
d3939 1
a3939 1
  if (HAVE_NEWABI)
@


1.410
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d15260 9
@


1.409
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d1787 1
a1787 1
    as_warn ("Unrecognized register name `%s'", *s);
d8686 1
a8686 1
	  insn_error = "unrecognized opcode";
d8694 1
a8694 1
	  insn_error = "unrecognized opcode";
d9555 1
a9555 1
		as_warn ("Improper align amount (%ld), using low bits",
d9646 2
a9647 2
			    as_bad(_("Bad element selector %ld"),
				   (long) imm_expr.X_add_number);
d9654 1
a9654 1
			    as_warn(_("Expecting ']' found '%s'"), s);
d10002 2
a10003 2
		as_warn(_("Condition code register should be even for %s, was %d"),
			str, regno);
d10007 2
a10008 2
		as_warn(_("Condition code register should be 0 or 4 for %s, was %d"),
			str, regno);
d11035 1
a11035 1
	    as_bad ("relocation %s isn't supported by the current ABI",
d11091 1
a11091 1
    as_bad ("unclosed '('");
d11856 1
a11856 1
    as_bad ("-march=%s is not compatible with the selected ABI",
d11959 2
a11960 2
      as_warn ("%s ISA does not support SmartMIPS", 
	       mips_cpu_info_from_isa (mips_opts.isa)->name);
d11965 2
a11966 2
      as_warn ("%s ISA does not support DSP ASE", 
	       mips_cpu_info_from_isa (mips_opts.isa)->name);
d11974 2
a11975 2
      as_warn ("%s ISA does not support DSP R2 ASE",
	       mips_cpu_info_from_isa (mips_opts.isa)->name);
d11980 2
a11981 2
      as_warn ("%s ISA does not support MT ASE",
	       mips_cpu_info_from_isa (mips_opts.isa)->name);
d12861 1
a12861 1
	as_warn ("%s isa does not support 64-bit registers",
d12872 1
a12872 1
	as_warn ("%s isa does not support 64-bit floating point registers",
d12893 1
a12893 1
	as_warn ("%s ISA does not support SmartMIPS ASE", 
d12910 1
a12910 1
	as_warn ("%s ISA does not support DSP ASE", 
d12923 1
a12923 1
	as_warn ("%s ISA does not support DSP R2 ASE",
d12936 1
a12936 1
	as_warn ("%s ISA does not support MT ASE", 
d13579 1
a13579 1
	  as_bad ("ignoring attempt to redefine symbol %s",
d13594 1
a13594 1
	  as_bad ("bad .weakext directive");
d15382 1
a15382 1
  as_bad ("Bad value (%s) for %s", cpu_string, option);
@


1.408
log
@2009-05-26  Catherine Moore  <clm@@codesourcery.com>

            gas/
            * config/tc-mips.c (check_for_24k_errata): Remove.
            (md_mips_end): Remove call to check_for_24k_errata.
            (start_noreorder): Likewise.
            (s_change_sec): Likewise.
            (s_change_section): Likewise.
            (insns_between): Add 24k errata checks.
            (append_insn): Remove declaration and references to nhdx_24k.
            Remove calls to check_for_24k_errata.

            gas/testsuite:
            * eret.s, eret.d eret.l: Remove.
            * eret-1.s, eret-1.d: New.
            * eret-2.s, eret-2.d: New.
            * eret-3.s, eret-3.d: New.
            * mips.exp: Run new tests.  Remove old tests.
@
text
@d2220 1
a2220 1
      assert (mips_opts.mips16);
d2231 1
a2231 1
      assert (! mips_opts.mips16);
d2320 1
a2320 1
      assert (S_GET_SEGMENT (l->label) == now_seg);
d2410 1
a2410 1
  assert (mips_relax.sequence == 0);
d2421 1
a2421 1
  assert (mips_relax.sequence == 1);
d2430 1
a2430 1
  assert (mips_relax.sequence == 2);
d2791 1
a2791 1
      assert (nops <= prev_nop_frag_holds);
d2858 1
a2858 1
      assert (mips_opts.mips16 && address_expr != NULL);
d3555 2
a3556 2
  assert (mo);
  assert (strcmp (name, mo->name) == 0);
d3568 2
a3569 2
      assert (mo->name);
      assert (strcmp (name, mo->name) == 0);
d3694 1
a3694 1
	  assert (*r == BFD_RELOC_GPREL16
d3710 1
a3710 1
	  assert (ep != NULL
d3722 1
a3722 1
	  assert (ep != NULL);
d3747 1
a3747 1
	  assert (ep != NULL);
d3765 1
a3765 1
  assert (*r == BFD_RELOC_UNUSED ? ep == NULL : ep != NULL);
d3780 2
a3781 2
  assert (mo);
  assert (strcmp (name, mo->name) == 0);
d3786 2
a3787 2
      assert (mo->name);
      assert (strcmp (name, mo->name) == 0);
d3861 1
a3861 1
	    assert (ep != NULL);
d3884 1
a3884 1
  assert (*r == BFD_RELOC_UNUSED ? ep == NULL : ep != NULL);
d3950 1
a3950 1
  assert (! mips_opts.mips16);
d3963 1
a3963 1
      assert (ep->X_op == O_symbol);
d3966 1
a3966 1
      assert (mips_pic == NO_PIC
d3976 2
a3977 2
  assert (strcmp (name, mo->name) == 0);
  assert (strcmp (fmt, mo->args) == 0);
d3998 1
a3998 1
  assert (ep->X_op == O_constant);
d4151 1
a4151 1
      assert (ep->X_op == O_constant);
d4205 1
a4205 1
      assert (ep->X_add_number > 2);
d4752 1
a4752 1
  assert (! mips_opts.mips16);
d5758 1
a5758 1
		      assert (tempreg == AT);
d5899 1
a5899 1
		  assert (tempreg == AT);
d5942 1
a5942 1
		  assert (tempreg == AT);
d6038 1
a6038 1
		  assert (tempreg == AT);
d6688 1
a6688 1
	  assert (offset_expr.X_op == O_symbol);
d6738 1
a6738 1
	  assert (offset_expr.X_op == O_symbol);
d6777 1
a6777 1
	  assert (offset_expr.X_op == O_symbol);
d6830 1
a6830 1
	  assert (offset_expr.X_op == O_symbol
d6872 1
a6872 1
		      assert (offset_expr.X_op == O_constant);
d6927 1
a6927 1
	      assert (HAVE_64BIT_GPRS);
d6937 1
a6937 1
		  assert (offset_expr.X_op == O_constant);
d6945 1
a6945 1
      assert (offset_expr.X_op == O_symbol
d6962 1
a6962 1
	  assert (strcmp (s, RDATA_SECTION_NAME) == 0);
d6989 1
a6989 1
      assert (mips_opts.isa == ISA_MIPS1);
d7300 1
a7300 1
      assert (HAVE_32BIT_ADDRESSES);
d7676 1
a7676 1
      assert (mips_opts.isa == ISA_MIPS1);
d7970 1
a7970 1
      assert (mips_opts.isa == ISA_MIPS1);
d8704 1
a8704 1
      assert (strcmp (insn->name, str) == 0);
d9000 1
a9000 1
	      assert (args[1] == 'b' || args[1] == '5'
d9765 1
a9765 1
		assert (length == (unsigned) (f64 ? 8 : 4));
d9863 1
a9863 1
			assert (g_switch_value >= 4);
d10166 1
a10166 1
      assert (strcmp (insn->name, str) == 0);
d10865 1
a10865 1
      assert (op < mips16_immed_operands + MIPS16_NUM_IMMED);
d12112 1
a12112 1
      assert (reloc_needs_lo_p (l->fixp->fx_r_type));
d12208 1
a12208 1
  assert (fixP->fx_size == 4
d12219 1
a12219 1
  assert (!fixP->fx_pcrel || fixP->fx_r_type == BFD_RELOC_16_PCREL_S2);
d12441 1
a12441 1
      assert (S_GET_SEGMENT (label) == now_seg);
d13701 1
a13701 1
	  assert (strcmp (segname, ".lit8") != 0
d13778 1
a13778 1
      assert (op < mips16_immed_operands + MIPS16_NUM_IMMED);
d14161 1
a14161 1
      assert (fixp->fx_r_type == BFD_RELOC_16_PCREL_S2);
d14291 1
a14291 1
		  assert ((insn & 0xf1000000) == 0x41000000);
d14298 1
a14298 1
		  assert ((insn & 0xfc0e0000) == 0x04000000);
d14316 1
a14316 1
	      assert ((insn & 0xfc1c0000) == 0x04100000);
d14440 1
a14440 1
      assert (buf == (bfd_byte *)fragp->fr_literal
d14938 1
a14938 1
      assert (S_GET_NAME (p));
d14980 1
a14980 1
      assert (pdr_seg);
@


1.407
log
@gas/
	* config/tc-mips.c (nops_for_vr4130): Don't check noreorder_p.
	(nops_for_insn): Likewise.

gas/testsuite/
	* gas/mips/vr4130.s, gas/mips/vr4130.d: Expect part A to have nops.
@
text
@a1794 79
#define INSN_ERET  0x42000018
#define INSN_DERET 0x4200001f

/*  Implement the ERET/DERET Errata for MIPS 24k.
 
    If an ERET/DERET is encountered in a noreorder block,
    warn if the ERET/DERET is followed by a branch instruction.
    Also warn if the ERET/DERET is the last instruction in the 
    noreorder block.

    IF an ERET/DERET is in a reorder block and is followed by a
    branch instruction, insert a nop.  */

static void
check_for_24k_errata (struct mips_cl_insn *insn, int eret_ndx)
{
  bfd_boolean next_insn_is_branch = FALSE;

  /* eret_ndx will be -1 for the last instruction in a section
     and the ERET/DERET will be in insn, not history.  */
  if (insn
      && eret_ndx == -1
      && (insn->insn_opcode == INSN_ERET
	  || insn->insn_opcode == INSN_DERET)
      && insn->noreorder_p)
    {
      as_warn (_("ERET and DERET must be followed by a NOP on the 24K."));
      return;
    }
   
  if (history[eret_ndx].insn_opcode != INSN_ERET
      && history[eret_ndx].insn_opcode != INSN_DERET)
    return;

  if (!insn)
    {
      if (history[eret_ndx].noreorder_p)
	as_warn (_("ERET and DERET must be followed by a NOP on the 24K."));
      return;
    }

  next_insn_is_branch = ((insn->insn_opcode == INSN_ERET)
			 || (insn->insn_opcode == INSN_DERET)
			 || (insn->insn_mo->pinfo
			     & (INSN_UNCOND_BRANCH_DELAY
				| INSN_COND_BRANCH_DELAY
				| INSN_COND_BRANCH_LIKELY)));

  if (next_insn_is_branch && history[eret_ndx].noreorder_p)
    {
      as_warn (_("ERET and DERET must be followed by a NOP on the 24K."));
      return;
    }

  /* Emit nop if the next instruction is a branch.  */ 
  if (next_insn_is_branch)
    {
      long nop_where, br_where;
      struct frag *nop_frag, *br_frag;
      struct mips_cl_insn br_insn, nop_insn;

      emit_nop ();

      nop_insn = history[eret_ndx - 1]; 
      nop_frag = history[eret_ndx - 1].frag;
      nop_where = history[eret_ndx - 1].where;

      br_insn = history[eret_ndx];
      br_frag = history[eret_ndx].frag;
      br_where = history[eret_ndx].where;

      move_insn (&nop_insn, br_frag, br_where);
      move_insn (&br_insn, nop_frag, nop_where);

      history[eret_ndx-1] = br_insn;
      history[eret_ndx] = nop_insn;
    }
}

a2079 3
  if (mips_fix_24k)
    check_for_24k_errata ((struct mips_cl_insn *) &history[0], -1);

d2457 3
d2497 18
a2730 1
  int hndx_24k = 0;
a3287 2
		  if (mips_fix_24k)
		    hndx_24k++;
a3327 5
	      /* Check for eret/deret before clearing history.  */
	      if (mips_fix_24k)
		check_for_24k_errata (
			(struct mips_cl_insn *) &history[hndx_24k],
			hndx_24k+1);
a3338 2
	  if (mips_fix_24k)
	    hndx_24k++;
a3345 4
  if (mips_fix_24k)
    check_for_24k_errata ((struct mips_cl_insn *) &history[hndx_24k],
			  hndx_24k+1);

a3431 2
  if (mips_fix_24k)
    check_for_24k_errata (NULL, 0);
a12513 3
  if (mips_fix_24k)
    check_for_24k_errata ((struct mips_cl_insn *) &history[0], -1);

a12571 3
  if (mips_fix_24k)
    check_for_24k_errata ((struct mips_cl_insn *) &history[0], -1);

@


1.406
log
@	* config/tc-mips.c (macro_end, md_convert_frag): Use '%s' for
	as_bad calls to silence compiler warning.
@
text
@d2682 1
a2682 1
    if (!history[i].noreorder_p && MF_HILO_INSN (history[i].insn_mo->pinfo))
d2717 5
a2721 6
    if (!history[i].noreorder_p)
      {
	tmp_nops = insns_between (history + i, insn) - i;
	if (tmp_nops > nops)
	  nops = tmp_nops;
      }
@


1.405
log
@2009-04-09  Catherine Moore  <clm@@codesourcery.com>

        * config/tc-mips.c (mips_fix_24k): Declare.
        (check_for_24k_errata): New.
        (mips_cleanup): Call check_for_24k_errata.
        (start_noreorder): Likewise.
        (md_mips_end): Likewise.
        (s_change_sec): Likewise.
        (s_change_section): Likewise.
        (append_insn): Call check_for_24k_errata.  Prevent
        ERET/DERET instructions from being moved into delay
        slots.
        (OPTION_FIX_24K): New.
        (OPTION_NO_FIX_24k) New.
        (md_longopts): Add "mfix-24k" and "mno-fix-24k".
        (md_parse_option): Handle fix-24k options.
        (md_show_usage): Display fix-24k options.
        * doc/c-mips.texi: Document.
        * testsuite/gas/mips/mips.exp: Run new tests.
        * testsuite/gas/mips/eret.s: New test.
        * testsuite/gas/mips/eret.d: New test output.
        * testsuite/gas/mips/eret.l: New test output.
@
text
@d3578 1
a3578 1
	    as_warn (msg);
d14636 1
a14636 1
	    as_warn_where (fragp->fr_file, fragp->fr_line, msg);
@


1.404
log
@	* config/tc-mips.c (mips_dwarf2_addr_size): Use HAVE_64BIT_OBJECTS
	instead of HAVE_64BIT_SYMBOLS.
@
text
@d763 3
d1795 79
d2159 3
d2793 1
d3327 5
a3331 1
	      || (prev_pinfo & INSN_SYNC))
d3351 2
d3392 8
a3399 1
	    mips_no_prev_insn ();
d3409 2
d3418 4
d3508 3
d11286 3
a11288 1
    OPTION_MNO_7000_HILO_FIX,
d11381 2
d11636 8
d12591 4
d12653 3
d15587 1
@


1.403
log
@bfd:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* aoutx.h (NAME (aout, machine_type)): Handle bfd_mach_mips_xlr.
	* archures.c (bfd_mach_mips_xlr): Define.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_xlr): Define.
	(arch_info_struct): Add XLR entry.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_XLR.
	(mips_set_isa_flags): Handle bfd_mach_mips_xlr
	(mips_mach_extensions): Add XLR entry.

binutils:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_XLR.

gas:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* config/tc-mips.c (macro): Handle M_MSGSND, M_MSGLD, M_MSGLD_T,
	M_MSGWAIT and M_MSGWAIT_T.
	(mips_cpu_info_table): Add XLR entry.
	* doc/c-mips.texi (-march): Document xlr.

gas/testsuite:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* gas/mips/mips.exp (xlr): New architecture.
	(xlr-ext): Run test.
	* gas/mips/xlr-ext.d, gas/mips/xlr-ext.s: New.

include/elf:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (E_MIPS_MACH_XLR): Define.

include/opcode:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (INSN_XLR): Define.
	(INSN_CHIP_MASK): Update.
	(CPU_XLR): Define.
	(OPCODE_IS_MEMBER): Update.
	(M_MSGSND, M_MSGLD, M_MSGLD_T, M_MSGWAIT, M_MSGWAIT_T): Define.

opcodes:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips-dis.c (mips_cp0_names_xlr, mips_cp0sel_names_xlr): Define.
	(mips_arch_choices): Add XLR entry.
	* mips-opc.c (XLR): Define.
	(mips_builtin_opcodes): Add XLR instructions.
@
text
@d15521 1
a15521 1
  if (HAVE_64BIT_SYMBOLS)
@


1.402
log
@        * config/tc-mips.c (append_insn): Cope with a complex reloc
        sequence containing an unsupported reloc type.
        (enum options): Replace computed #define's constants for option
        numbers with this enum.
        (struct md_longopts): Use the enum.  Allow OPTION_32 in a non-ELF
        environment.
        (md_parse_option): Allow -32 in a non-ELF environment.

        * gas/lib/gas-defs.exp: Update description of run_dump_test proc.

        * gas/mips/dli.d: Pass -64 to gas.
        * gas/mips/mips64-mips3d-incl.d: Likewise.
        * gas/mips/octeon.d: Likewise.
        * gas/mips/sb1-ext-mdmx.d: Likewise.
        * gas/mips/sb1-ext-ps.d: Likewise.
        * gas/mips/e32el-rel2.s: Pass -march=mips3 to gas.
        Update expected relocs.
        * gas/mips/ld-ilocks-addr32.d: Do not run for tx39 targets.
        * gas/mips/mips.exp: Remove 'ilocks' variable.
        Add ecoff targets to 'addr32' variable.
        Set 'no_mips16' for ecoff targets.
        Do not run div-ilocks or mul-ilocks test variants.
        * gas/mips/mips16-intermix.d: Use nm instead of objdump so that
        the symbol table output is sorted.  Update expecetd output.
@
text
@d6045 37
d15236 3
@


1.401
log
@* config/tc-mips.c (macro) [M_DINS, M_SEQ_I, M_SNE_I]: Cast
arguments to macro_build to match format.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d2967 9
d11104 80
a11186 2
#define OPTION_ARCH_BASE    (OPTION_MD_BASE)
#define OPTION_MARCH (OPTION_ARCH_BASE + 0)
a11187 1
#define OPTION_MTUNE (OPTION_ARCH_BASE + 1)
a11188 1
#define OPTION_MIPS1 (OPTION_ARCH_BASE + 2)
a11190 1
#define OPTION_MIPS2 (OPTION_ARCH_BASE + 3)
a11191 1
#define OPTION_MIPS3 (OPTION_ARCH_BASE + 4)
a11192 1
#define OPTION_MIPS4 (OPTION_ARCH_BASE + 5)
a11193 1
#define OPTION_MIPS5 (OPTION_ARCH_BASE + 6)
a11194 1
#define OPTION_MIPS32 (OPTION_ARCH_BASE + 7)
a11195 1
#define OPTION_MIPS64 (OPTION_ARCH_BASE + 8)
a11196 1
#define OPTION_MIPS32R2 (OPTION_ARCH_BASE + 9)
a11197 1
#define OPTION_MIPS64R2 (OPTION_ARCH_BASE + 10)
a11200 2
#define OPTION_ASE_BASE (OPTION_ARCH_BASE + 11)
#define OPTION_MIPS16 (OPTION_ASE_BASE + 0)
a11201 1
#define OPTION_NO_MIPS16 (OPTION_ASE_BASE + 1)
a11202 1
#define OPTION_MIPS3D (OPTION_ASE_BASE + 2)
a11203 1
#define OPTION_NO_MIPS3D (OPTION_ASE_BASE + 3)
a11204 1
#define OPTION_MDMX (OPTION_ASE_BASE + 4)
a11205 1
#define OPTION_NO_MDMX (OPTION_ASE_BASE + 5)
a11206 1
#define OPTION_DSP (OPTION_ASE_BASE + 6)
a11207 1
#define OPTION_NO_DSP (OPTION_ASE_BASE + 7)
a11208 1
#define OPTION_MT (OPTION_ASE_BASE + 8)
a11209 1
#define OPTION_NO_MT (OPTION_ASE_BASE + 9)
a11210 1
#define OPTION_SMARTMIPS (OPTION_ASE_BASE + 10)
a11211 1
#define OPTION_NO_SMARTMIPS (OPTION_ASE_BASE + 11)
a11212 1
#define OPTION_DSPR2 (OPTION_ASE_BASE + 12)
a11213 1
#define OPTION_NO_DSPR2 (OPTION_ASE_BASE + 13)
a11216 2
#define OPTION_COMPAT_ARCH_BASE (OPTION_ASE_BASE + 14)
#define OPTION_M4650 (OPTION_COMPAT_ARCH_BASE + 0)
a11217 1
#define OPTION_NO_M4650 (OPTION_COMPAT_ARCH_BASE + 1)
a11218 1
#define OPTION_M4010 (OPTION_COMPAT_ARCH_BASE + 2)
a11219 1
#define OPTION_NO_M4010 (OPTION_COMPAT_ARCH_BASE + 3)
a11220 1
#define OPTION_M4100 (OPTION_COMPAT_ARCH_BASE + 4)
a11221 1
#define OPTION_NO_M4100 (OPTION_COMPAT_ARCH_BASE + 5)
a11222 1
#define OPTION_M3900 (OPTION_COMPAT_ARCH_BASE + 6)
a11223 1
#define OPTION_NO_M3900 (OPTION_COMPAT_ARCH_BASE + 7)
a11226 2
#define OPTION_FIX_BASE    (OPTION_COMPAT_ARCH_BASE + 8)
#define OPTION_M7000_HILO_FIX (OPTION_FIX_BASE + 0)
a11227 1
#define OPTION_MNO_7000_HILO_FIX (OPTION_FIX_BASE + 1)
a11229 2
#define OPTION_FIX_VR4120 (OPTION_FIX_BASE + 2)
#define OPTION_NO_FIX_VR4120 (OPTION_FIX_BASE + 3)
a11231 2
#define OPTION_FIX_VR4130 (OPTION_FIX_BASE + 4)
#define OPTION_NO_FIX_VR4130 (OPTION_FIX_BASE + 5)
a11235 2
#define OPTION_MISC_BASE (OPTION_FIX_BASE + 6)
#define OPTION_TRAP (OPTION_MISC_BASE + 0)
a11237 1
#define OPTION_BREAK (OPTION_MISC_BASE + 1)
a11239 1
#define OPTION_EB (OPTION_MISC_BASE + 2)
a11240 1
#define OPTION_EL (OPTION_MISC_BASE + 3)
a11241 1
#define OPTION_FP32 (OPTION_MISC_BASE + 4)
a11242 1
#define OPTION_GP32 (OPTION_MISC_BASE + 5)
a11243 1
#define OPTION_CONSTRUCT_FLOATS (OPTION_MISC_BASE + 6)
a11244 1
#define OPTION_NO_CONSTRUCT_FLOATS (OPTION_MISC_BASE + 7)
a11245 1
#define OPTION_FP64 (OPTION_MISC_BASE + 8)
a11246 1
#define OPTION_GP64 (OPTION_MISC_BASE + 9)
a11247 2
#define OPTION_RELAX_BRANCH (OPTION_MISC_BASE + 10)
#define OPTION_NO_RELAX_BRANCH (OPTION_MISC_BASE + 11)
a11249 2
#define OPTION_MSHARED (OPTION_MISC_BASE + 12)
#define OPTION_MNO_SHARED (OPTION_MISC_BASE + 13)
a11251 2
#define OPTION_MSYM32 (OPTION_MISC_BASE + 14)
#define OPTION_MNO_SYM32 (OPTION_MISC_BASE + 15)
a11253 2
#define OPTION_SOFT_FLOAT (OPTION_MISC_BASE + 16)
#define OPTION_HARD_FLOAT (OPTION_MISC_BASE + 17)
a11255 2
#define OPTION_SINGLE_FLOAT (OPTION_MISC_BASE + 18)
#define OPTION_DOUBLE_FLOAT (OPTION_MISC_BASE + 19)
d11258 5
a11265 2
#define OPTION_ELF_BASE    (OPTION_MISC_BASE + 20)
#define OPTION_CALL_SHARED (OPTION_ELF_BASE + 0)
a11267 1
#define OPTION_CALL_NONPIC (OPTION_ELF_BASE + 1)
a11268 1
#define OPTION_NON_SHARED  (OPTION_ELF_BASE + 2)
a11269 1
#define OPTION_XGOT        (OPTION_ELF_BASE + 3)
a11270 1
#define OPTION_MABI        (OPTION_ELF_BASE + 4)
a11271 3
#define OPTION_32 	   (OPTION_ELF_BASE + 5)
  {"32",          no_argument, NULL, OPTION_32},
#define OPTION_N32 	   (OPTION_ELF_BASE + 6)
a11272 1
#define OPTION_64          (OPTION_ELF_BASE + 7)
a11273 1
#define OPTION_MDEBUG      (OPTION_ELF_BASE + 8)
a11274 1
#define OPTION_NO_MDEBUG   (OPTION_ELF_BASE + 9)
a11275 1
#define OPTION_PDR	   (OPTION_ELF_BASE + 10)
a11276 1
#define OPTION_NO_PDR	   (OPTION_ELF_BASE + 11)
a11277 1
#define OPTION_MVXWORKS_PIC (OPTION_ELF_BASE + 12)
a11573 1
#ifdef OBJ_ELF
d11577 4
a11580 6
      if (!IS_ELF)
	{
	  as_bad (_("-32 is supported for ELF format only"));
	  return 0;
	}
      mips_abi = O32_ABI;
d11583 1
@


1.400
log
@2009-01-06  Chao-ying Fu  <fu@@mips.com>

	* config/tc-mips.c (mips_ip): Set lastregno to 0xffffffff.
	Use strncmp to match jalr and jalr.hb.
	Fix a typo.
@
text
@d5244 2
a5245 2
	macro_build ((expressionS *) NULL, s, fmt, treg, sreg, pos,
		     pos + size - 1);
d7640 1
a7640 1
		       imm_expr.X_add_number);
d7802 1
a7802 1
		       imm_expr.X_add_number);
@


1.399
log
@	* aoutx.h (NAME): Add case statements for bfd_mach_mips14000,
	bfd_mach_mips16000.
	* archures.c (bfd_architecture): Add .#defines for bfd_mach_mips14000,
	bfd_mach_mips16000.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c: Add enums I_mips14000, I_mips16000.
	(arch_info_struct): Add refs to R14000, R16000.
	* elfxx-mips.c (mips_set_isa_flags): Handle bfd_mach_mips14000,
	bfd_mach_mips16000.
	(mips_mach_extensions): Map R14000, R16000 to R10000.

	* config/tc-mips.c (hilo_interlocks): Handle CPU_R14000, CPU_R16000.
	(mips_cpu_info_table): Add r14000, r16000.
	* doc/c-mips.texi: Add entries for 14000, 16000.

	* mips-dis.c (mips_arch_choices): Add r14000, r16000.

	* mips.h: Define CPU_R14000, CPU_R16000.
        (OPCODE_IS_MEMBER): Include R14000, R16000 in test.
@
text
@d8659 1
d9401 1
a9401 1
		  if (c == 's' && !strcmp (ip->insn_mo->name, "jalr"))
d9405 1
a9405 1
			  insn_error = _("source and destinationations must be different");
d9408 1
a9408 1
		      if (regno == 31 && lastregno == 0)
@


1.398
log
@	* config/tc-mips.c (COP_INSN): Change logic to always return false
	for FP instructions.

testsuite/
	* gas/mips/mips1-fp.s, testsuite/gas/mips/mips1-fp.d,
	testsuite/gas/mips/mips1-fp.l: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d475 2
d15095 2
@


1.397
log
@2008-11-06  Chao-ying Fu  <fu@@mips.com>

	* config/tc-mips.c (validate_mips_insn): Add case '1'.
	(mips_ip): Add case '1' to process sync type.
@
text
@d517 1
a517 1
   condition-code flags unless this is the floating-point coprocessor.  */
d520 2
a521 3
   && (((PINFO) & INSN_COP)						\
       || ((PINFO) & (INSN_READ_COND_CODE | INSN_WRITE_COND_CODE)	\
	   && ((PINFO) & (FP_S | FP_D)) == 0)))
@


1.396
log
@* config/tc-mips.c (mips_cpu_info_table): Move the MIPS64r2
comment so that Broadcom SB-1 cores are in the MIPS64 section.
@
text
@d8460 1
d9247 1
d9256 2
d9259 1
a9259 1
		INSERT_OPERAND (PREFX, *ip, imm_expr.X_add_number);
@


1.395
log
@	* config/bfin-parse.y: Use C style comments.
	* config/tc-bfin.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mips.c: Likewise.
@
text
@a15165 2
  /* MIPS 64 Release 2 */

d15173 2
@


1.394
log
@2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>
	    Maxim Kuvyrkov  <maxim@@codesourcery.com>

	* elf32-mips.c (mips_vxworks_copy_howto_rela): Replace with...
	(elf_mips_copy_howto): ...this howto.  Clear the size fields.
	(mips_vxworks_jump_slot_howto_rela): Replace with...
	(elf_mips_jump_slot_howto): ...this howto.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_plt_readonly): Define.
	(elf_backend_plt_sym_val): Define for non-VxWorks targets.
	(mips_vxworks_bfd_reloc_type_lookup): Delete.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(mips_vxworks_rtype_to_howto): Likewise.
	(elf_backend_want_dynbss): Don't define for VxWorks.
	(elf_backend_plt_readonly): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(elf_backend_mips_rtype_to_howto): Likewise.
	(elf_backend_adjust_dynamic_symbol): Likewise.
	(elf_backend_got_symbol_offset): Don't define.
	* elfn32-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_n32_rtype_to_howto): Handle R_MIPS_COPY and
	R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elf64-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf64_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf64_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf64_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elfxx-mips.h (_bfd_mips_vxworks_adjust_dynamic_symbol): Delete.
	(_bfd_mips_elf_use_plts_and_copy_relocs, _bfd_mips_elf_init_stubs)
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): Declare.
	* elfxx-mips.c (mips_elf_la25_stub): New structure.
	(LA25_LUI, LA25_J, LA25_ADDIU): New macros.
	(mips_elf_link_hash_entry): Add "la25_stubs", "has_static_relocs"
	and "has_nonpic_branches" fields.  Remove "is_relocation_target" and
	"is_branch_target".
	(mips_elf_link_hash_table): Add blank lines.  Add
	"use_plts_and_copy_relocs", "reserved_gotno", "strampoline",
	"la25_stubs" and "add_stub_section" fields.
	(mips_htab_traverse_info): New structure.
	(PIC_OBJECT_P, MIPS_ELF_LOAD_WORD): New macros.
	(MIPS_RESERVED_GOTNO): Delete.
	(mips_o32_exec_plt0_entry, mips_n32_exec_plt0_entry)
	(mips_n64_exec_plt0_entry, mips_exec_plt_entry): New tables.
	(mips_elf_link_hash_newfunc): Update after the changes to
	mips_elf_link_hash_entry.
	(mips_elf_check_mips16_stubs): Replace the DATA parameter with
	an INFO parameter.  Don't look through warnings symbols here;
	do it in mips_elf_check_symbols instead.
	(mips_elf_create_stub_symbol): New function.
	(mips_elf_la25_stub_hash, mips_elf_la25_stub_eq): New functions.
	(_bfd_mips_elf_init_stubs, mips_elf_local_pic_function_p): Likewise.
	(mips_elf_add_la25_intro, mips_elf_add_la25_trampoline): Likewise.
	(mips_elf_add_la25_stub, mips_elf_check_symbols): New functions.
	(mips_elf_gotplt_index): Check for VxWorks.
	(mips_elf_output_dynamic_relocation): Take the relocation index
	as an extra parameter.  Do not increment reloc_count here.
	(mips_elf_initialize_tls_slots): Update the calls to
	mips_elf_output_dynamic_relocation accordingly.
	(mips_elf_multi_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(mips_elf_create_got_section): Don't allocate reserved GOT
	entries here.  Unconditionally create .got.plt, but don't
	set its alignment here.
	(mips_elf_relocation_needs_la25_stub): New function.
	(mips_elf_calculate_relocation): Redirect branches and jumps to
	a non-PIC stub if one exists.  Check !h->has_static_relocs instead
	of !htab->is_vxworks when deciding whether to create dynamic
	relocations for R_MIPS_32, R_MIPS_REL32 and R_MIPS_64.
	(_bfd_mips_elf_create_dynamic_sections): Unconditionally call
	_bfd_elf_create_dynamic_sections.  Unconditionally set up
	htab->splt and htab->sdynbss.  Set htab->srelplt to ".rel.plt"
	if !htab->is_vxworks.  Add non-VxWorks values of
	htab->plt_header_size and htab->plt_entry_size.
	(_bfd_mips_elf_check_relocs): Set pointer_equality_needed for
	non-branch static relocations.  Set has_nonpic_branches when an la25
	stub might be required.  Set can_make_dynamic_p to TRUE if R_MIPS_32,
	R_MIPS_REL32 and R_MIPS_64 relocations can be made dynamic,
	rather than duplicating the condition.  Do not make them dynamic
	for read-only sections in non-PIC executable objects.
	Do not protect this code with dynobj == NULL || htab->sgot == NULL;
	handle each group of cases separately.  Add a default case that
	sets has_static_relocs for non-GOT relocations that cannot be
	made dynamic.  Don't set is_relocation_target and is_branch_target.
	Reject non-PIC static relocations in shared objects.
	(_bfd_mips_vxworks_adjust_dynamic_symbol): Fold into...
	(_bfd_mips_elf_adjust_dynamic_symbol): ...here, using
	htab->use_plts_and_copy_relocs instead of htab->is_vxworks
	to select PLT and copy-reloc handling.  Set the alignment of
	.plt and .got.plt when allocating the first entry.  Generalize
	code to handle REL as well as RELA sections and 64-bit as well as
	32-bit GOT entries.  Complain if we find a static-only reloc
	against an externally-defined symbol and if we cannot create
	dynamic relocations for it.  Allocate copy relocs using
	mips_elf_allocate_dynamic_relocations on non-VxWorks targets.
	Set possibly_dynamic_relocs to 0 when using PLTs or copy relocs.
	Skip reserved .got.plt entries.
	(_bfd_mips_elf_always_size_sections): Use mips_elf_check_symbols
	instead of mips_elf_check_mips16_stubs to process each symbol.
	Do the traversal for relocatable objects too.
	(mips_elf_lay_out_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(_bfd_mips_elf_size_dynamic_sections): Exclude sdynbss if it
	is empty.  Extend the DT_PLTREL, DT_JMPREL and DT_PLTRELSZ handling
	to non-VxWorks targets.  Only add DT_REL{,A}, DT_REL{,A}SZ and
	DT_REL{,A}ENT if .rel.dyn is nonempty.  Create a symbol for the
	PLT.  Allocate a nop at the end of the PLT.  Allocate DT_MIPS_PLTGOT.
	(mips_elf_create_la25_stub_info): New function.
	(_bfd_mips_elf_finish_dynamic_symbol): Write out PLT entries
	and copy relocs where necessary.  Check pointer_equality_needed.
	(mips_finish_exec_plt): New function.
	(_bfd_mips_elf_finish_dynamic_sections): Always set DT_PLTGOT
	to the beginning of htab->sgot.  Use htab->reserved_gotno instead
	of MIPS_RESERVED_GOTNO.  Assert htab->use_plts_and_copy_relocs
	instead of htab->is_vxworks for DT_PLTREL, DT_PLTRELSZ and DT_JMPREL.
	Set DT_PLTREL to DT_REL instead of DT_RELA on non-VxWorks targets.
	Use mips_finish_exec_plt to create non-VxWorks PLT headers.  Set
	DT_MIPS_PLTGOT.
	(_bfd_mips_elf_copy_indirect_symbol): Copy has_static_relocs
	from the indirect symbol to the direct symbol.  Also copy
	has_nonpic_branches for indirect symbols.
	(_bfd_mips_elf_get_target_dtag): Handle DT_MIPS_PLTGOT and
	DT_MIPS_RWPLT.
	(_bfd_mips_elf_link_hash_table_create): Initialize the new
	mips_elf_link_hash_table fields.
	(_bfd_mips_vxworks_link_hash_table_create): Set
	use_plts_and_copy_relocs to TRUE.  Use TRUE rather than 1
	when setting is_vxworks.
	(_bfd_mips_elf_use_plts_and_copy_relocs): New function.
	(_bfd_mips_elf_final_link): Call mips_elf_create_la25_stub for
	each la25_stub.
	(_bfd_mips_elf_merge_private_bfd_data): Treat dynamic objects
	as PIC.  Generalize message about linking PIC and non-PIC.
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): New
	functions.
	* reloc.c: Update comment near BFD_RELOC_MIPS_JUMP_SLOT.
	* bfd-in2.h: Regenerated.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* readelf.c (get_mips_symbol_other): Handle STO_MIPS_PLT and
	STO_MIPS_PIC.
	(slurp_rela_relocs, slurp_rel_relocs): Handle MIPS ELF64 here.
	(dump_relocations, debug_apply_relocations): Don't handle it here.
	(get_mips_dynamic_type): Handle DT_MIPS_PLTGOT and DT_MIPS_RWPLT.
	(print_mips_pltgot_entry): New function.
	(process_mips_specific): Dump the PLT GOT.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* config/tc-mips.c (OPTION_CALL_NONPIC): New macro.
	(OPTION_NON_SHARED, OPTION_XGOT, OPTION_MABI, OPTION_32)
	(OPTION_N32, OPTION_64, OPTION_MDEBUG, OPTION_NO_MDEBUG)
	(OPTION_PDR, OPTION_NO_PDR, OPTION_MVXWORKS_PIC): Bump by 1.
	(md_longopts): Add -call_nonpic.
	(md_parse_option): Handle OPTION_CALL_NONPIC.
	(md_show_usage): Add -call_nonpic.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/call-nonpic-1.s, gas/mips/call-nonpic-1.d: New test.
	* gas/mips/mips.exp: Run it.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* mips.h (STO_MIPS_PLT, ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT)
	(STO_MIPS_PIC, DT_MIPS_PLTGOT, DT_MIPS_RWPLT): New macros.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* emulparams/elf32bmip.sh (GOT): Define, moving .got.plt to...
	(OTHER_RELRO_SECTIONS, OTHER_READWRITE_SECTIONS): ...one of these
	two variables.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emultempl/mipself.em: Include ldctor.h, elf/mips.h and elfxx-mips.h.
	(is_mips_elf): New macro.
	(stub_file, stub_bfd): New variables.
	(hook_stub_info): New structure.
	(hook_in_stub): New function.
	(mips_add_stub_section): Likewise.
	(mips_create_output_section_statements): Likewise.
	(mips_before_allocation): Likewise.
	(real_func): New variable.
	(mips_for_each_input_file_wrapper): New function.
	(mips_lang_for_each_input_file): Likewise.
	(lang_for_each_input_file): Define.
	(LDEMUL_BEFORE_ALLOCATION): Likewise.
	(LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS): Likewise.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* ld-mips-elf/mips16-pic-3a.s,
	ld-mips-elf/mips16-pic-3b.s,
	ld-mips-elf/mips16-pic-3.dd,
	ld-mips-elf/mips16-pic-3.gd,
	ld-mips-elf/mips16-pic-3.rd,
	ld-mips-elf/mips16-pic-3.inc,
	ld-mips-elf/pic-and-nonpic-1a.s,
	ld-mips-elf/pic-and-nonpic-1b.s,
	ld-mips-elf/pic-and-nonpic-1.ld,
	ld-mips-elf/pic-and-nonpic-1.dd,
	ld-mips-elf/pic-and-nonpic-1.nd,
	ld-mips-elf/pic-and-nonpic-1-rel.dd,
	ld-mips-elf/pic-and-nonpic-1-rel.nd,
	ld-mips-elf/pic-and-nonpic-2a.s,
	ld-mips-elf/pic-and-nonpic-2b.s,
	ld-mips-elf/pic-and-nonpic-2.d,
	ld-mips-elf/pic-and-nonpic-3a.s,
	ld-mips-elf/pic-and-nonpic-3a.ld,
	ld-mips-elf/pic-and-nonpic-3a.dd,
	ld-mips-elf/pic-and-nonpic-3a.gd,
	ld-mips-elf/pic-and-nonpic-3a.sd,
	ld-mips-elf/pic-and-nonpic-3b.s,
	ld-mips-elf/pic-and-nonpic-3b.ld,
	ld-mips-elf/pic-and-nonpic-3b.ad,
	ld-mips-elf/pic-and-nonpic-3b.dd,
	ld-mips-elf/pic-and-nonpic-3b.gd,
	ld-mips-elf/pic-and-nonpic-3b.nd,
	ld-mips-elf/pic-and-nonpic-3b.pd,
	ld-mips-elf/pic-and-nonpic-3b.rd,
	ld-mips-elf/pic-and-nonpic-3b.sd,
	ld-mips-elf/pic-and-nonpic-3-error.d,
	ld-mips-elf/pic-and-nonpic-4a.s,
	ld-mips-elf/pic-and-nonpic-4b.s,
	ld-mips-elf/pic-and-nonpic-4b.ld,
	ld-mips-elf/pic-and-nonpic-4b.ad,
	ld-mips-elf/pic-and-nonpic-4b.dd,
	ld-mips-elf/pic-and-nonpic-4b.gd,
	ld-mips-elf/pic-and-nonpic-4b.nd,
	ld-mips-elf/pic-and-nonpic-4b.rd,
	ld-mips-elf/pic-and-nonpic-4b.sd,
	ld-mips-elf/pic-and-nonpic-4-error.d,
	ld-mips-elf/pic-and-nonpic-5a.s,
	ld-mips-elf/pic-and-nonpic-5b.s,
	ld-mips-elf/pic-and-nonpic-5b.ld,
	ld-mips-elf/pic-and-nonpic-5b.ad,
	ld-mips-elf/pic-and-nonpic-5b.dd,
	ld-mips-elf/pic-and-nonpic-5b.gd,
	ld-mips-elf/pic-and-nonpic-5b.nd,
	ld-mips-elf/pic-and-nonpic-5b.rd,
	ld-mips-elf/pic-and-nonpic-5b.sd,
	ld-mips-elf/pic-and-nonpic-5b.pd,
	ld-mips-elf/pic-and-nonpic-6.ld,
	ld-mips-elf/pic-and-nonpic-6-o32a.s,
	ld-mips-elf/pic-and-nonpic-6-o32b.s,
	ld-mips-elf/pic-and-nonpic-6-o32c.s,
	ld-mips-elf/pic-and-nonpic-6-o32.ad,
	ld-mips-elf/pic-and-nonpic-6-o32.dd,
	ld-mips-elf/pic-and-nonpic-6-o32.gd,
	ld-mips-elf/pic-and-nonpic-6-o32.nd,
	ld-mips-elf/pic-and-nonpic-6-o32.pd,
	ld-mips-elf/pic-and-nonpic-6-o32.rd,
	ld-mips-elf/pic-and-nonpic-6-o32.sd,
	ld-mips-elf/pic-and-nonpic-6-n32a.s,
	ld-mips-elf/pic-and-nonpic-6-n32b.s,
	ld-mips-elf/pic-and-nonpic-6-n32c.s,
	ld-mips-elf/pic-and-nonpic-6-n32.ad,
	ld-mips-elf/pic-and-nonpic-6-n32.dd,
	ld-mips-elf/pic-and-nonpic-6-n32.gd,
	ld-mips-elf/pic-and-nonpic-6-n32.nd,
	ld-mips-elf/pic-and-nonpic-6-n32.pd,
	ld-mips-elf/pic-and-nonpic-6-n32.rd,
	ld-mips-elf/pic-and-nonpic-6-n32.sd,
	ld-mips-elf/pic-and-nonpic-6-n64a.s,
	ld-mips-elf/pic-and-nonpic-6-n64b.s,
	ld-mips-elf/pic-and-nonpic-6-n64c.s,
	ld-mips-elf/pic-and-nonpic-6-n64.ad,
	ld-mips-elf/pic-and-nonpic-6-n64.dd,
	ld-mips-elf/pic-and-nonpic-6-n64.gd,
	ld-mips-elf/pic-and-nonpic-6-n64.nd,
	ld-mips-elf/pic-and-nonpic-6-n64.pd,
	ld-mips-elf/pic-and-nonpic-6-n64.rd,
	ld-mips-elf/pic-and-nonpic-6-n64.sd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d1952 1
a1952 1
				     reg_names[i].num, // & RNUM_MASK,
d1957 1
a1957 1
				       reg_names_n32n64[i].num, // & RNUM_MASK,
d1962 1
a1962 1
				       reg_names_o32[i].num, // & RNUM_MASK,
@


1.394.2.1
log
@	* config/tc-mips.c (NO_ISA_COP): New macro.
	(COP_INSN): New macro.
	(is_opcode_valid): Use them.
	(macro) <ld_st>: Use them.  Don't accept coprocessor load store
	insns based on the ISA if CPU is NO_ISA_COP.
	<copz>: Likewise for coprocessor operations.

testsuite/
	* gas/mips/mips1-fp.s, gas/mips/mips1-fp.d, gas/mips/mips1-fp.l:
	New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d517 1
a517 1
   condition-code flags.  */
d520 3
a522 2
   && ((PINFO) & (FP_S | FP_D)) == 0					\
   && ((PINFO) & (INSN_COP | INSN_READ_COND_CODE | INSN_WRITE_COND_CODE)))
@


1.393
log
@bfd/
	* reloc.c (BFD_RELOC_MIPS16_GOT16, BFD_RELOC_MIPS16_CALL16): Declare.
	* libbfd.h, bfd-in2.h: Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(mips16_reloc_map): Add mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(mips16_elf64_howto_table_rela): Likewise.
	(mips16_reloc_map): Add mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(elf_mips16_howto_table_rela): Likewise.
	(mips16_reloc_map): Add mappings.
	* elfxx-mips.c (mips_elf_create_shadow_symbol): New function.
	(section_allows_mips16_refs_p): Likewise.
	(mips16_stub_symndx): Likewise.
	(mips_elf_check_mips16_stubs): Treat the data argument as a
	bfd_link_info.  Mark every dynamic symbol as needing MIPS16 stubs
	and create a "shadow" symbol for the original MIPS16 definition.
	(mips16_reloc_p, got16_reloc_p, call16_reloc_p, hi16_reloc_p)
	(lo16_reloc_p, mips16_call_reloc_p): New functions.
	(_bfd_mips16_elf_reloc_unshuffle): Use mips16_reloc_p to generalize
	relocation checks.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	(_bfd_mips_elf_lo16_reloc): Handle R_MIPS16_GOT16.
	(mips_elf_got16_entry): Add comment.
	(mips_elf_calculate_relocation): Use hi16_reloc_p,
	lo16_reloc_p, mips16_call_reloc_p, call16_reloc_p and got16_reloc_p
	to generalize relocation checks.  Use section_allows_mips16_refs_p
	instead of mips16_stub_section_p.   Handle R_MIPS16_CALL16 and
	R_MIPS16_GOT16, allowing the former to refer directly to a
	MIPS16 function if its stub is not needed.
	(mips16_stub_section_p): Delete.
	(_bfd_mips_elf_symbol_processing): Convert odd-valued function
	symbols into even MIPS16 symbols.
	(mips_elf_add_lo16_rel_addend): Use mips16_reloc_p to generalize
	a relocation check.
	(_bfd_mips_elf_check_relocs): Calculate "bed" and "rel_end"
	earlier in the function.  Use mips16_stub_symndx to identify
	the target function.  Avoid out-of-bounds accesses when the
	stub has no relocations; report an error instead.  Use
	section_allows_mips16_refs_p instead of mips16_stub_section_p.
	Use mips16_call_reloc_p and got16_reloc_p to generalize relocation
	checks.  Handle R_MIPS16_CALL16 and R_MIPS16_GOT16.  Don't create
	dynamic relocations for absolute references to __gnu_local_gp.
	(_bfd_mips_elf_always_size_sections): Pass a bfd_link_info as
	the argument to mips_elf_check_mips16_stubs.  Generalize comment.
	(_bfd_mips_elf_relocate_section): Use hi16_reloc_p and got16_reloc_p
	to generalize relocation checks.
	(_bfd_mips_elf_finish_dynamic_symbol): If a dynamic MIPS16 function
	symbol has a non-MIPS16 stub, redirect the symbol to the stub.
	Fix an overly long line.  Don't give dynamic symbols type STO_MIPS16.
	(_bfd_mips_elf_gc_sweep_hook): Handle R_MIPS16_CALL16 and
	R_MIPS16_GOT16.

gas/
	* config/tc-mips.c (mips16_reloc_p, got16_reloc_p, hi16_reloc_p)
	(lo16_reloc_p): New functions.
	(reloc_needs_lo_p): Use hi16_reloc_p and got16_reloc_p to
	generalize relocation checks.
	(matching_lo_reloc): New function.
	(fixup_has_matching_lo_p): Use it.
	(mips16_mark_labels): Don't clobber a symbol's visibility.
	(append_insn): Use hi16_reloc_p and lo16_reloc_p.
	(mips16_ip): Handle BFD_RELOC_MIPS16_GOT16 and BFD_RELOC_MIPS16_CALL16.
	(md_apply_fix): Likewise.
	(mips16_percent_op): Add %got and %call16.
	(mips_frob_file): Use got16_reloc_p to generalize relocation checks.
	Use matching_lo_reloc.
	(mips_force_relocation): Use hi16_reloc_p and lo16_reloc_p to
	generalize relocation checks.
	(mips_fix_adjustable): Use lo16_reloc_p to generalize relocation
	checks.

gas/testsuite/
	* gas/mips/elf-rel8-mips16.d, gas/mips/elf-rel8-mips16.s,
	* gas/mips/elf-rel9-mips16.d, gas/mips/elf-rel9-mips16.s,
	* gas/mips/elf-rel13-mips16.d, gas/mips/elf-rel13-mips16.s: New tests.
	* gas/mips/mips.exp: Run them.

ld/testsuite/
	* ld-mips-elf/mips16-local-stubs-1.d: Remove stub_for_h3,
	which was only referenced by the .pdr section, and was not
	actually needed by code.
	* ld-mips-elf/mips16-intermix.d: Remove unused static function stubs.
	* ld-mips-elf/mips16-pic-1a.s,
	ld-mips-elf/mips16-pic-1b.s,
	ld-mips-elf/mips16-pic-1-dummy.s,
	ld-mips-elf/mips16-pic-1.dd,
	ld-mips-elf/mips16-pic-1.gd,
	ld-mips-elf/mips16-pic-1.inc,
	ld-mips-elf/mips16-pic-1.ld,
	ld-mips-elf/mips16-pic-2a.s,
	ld-mips-elf/mips16-pic-2b.s,
	ld-mips-elf/mips16-pic-2.ad,
	ld-mips-elf/mips16-pic-2.dd,
	ld-mips-elf/mips16-pic-2.gd,
	ld-mips-elf/mips16-pic-2.nd,
	ld-mips-elf/mips16-pic-2.rd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d11234 3
a11236 1
#define OPTION_NON_SHARED  (OPTION_ELF_BASE + 1)
d11238 1
a11238 1
#define OPTION_XGOT        (OPTION_ELF_BASE + 2)
d11240 1
a11240 1
#define OPTION_MABI        (OPTION_ELF_BASE + 3)
d11242 1
a11242 1
#define OPTION_32 	   (OPTION_ELF_BASE + 4)
d11244 1
a11244 1
#define OPTION_N32 	   (OPTION_ELF_BASE + 5)
d11246 1
a11246 1
#define OPTION_64          (OPTION_ELF_BASE + 6)
d11248 1
a11248 1
#define OPTION_MDEBUG      (OPTION_ELF_BASE + 7)
d11250 1
a11250 1
#define OPTION_NO_MDEBUG   (OPTION_ELF_BASE + 8)
d11252 1
a11252 1
#define OPTION_PDR	   (OPTION_ELF_BASE + 9)
d11254 1
a11254 1
#define OPTION_NO_PDR	   (OPTION_ELF_BASE + 10)
d11256 1
a11256 1
#define OPTION_MVXWORKS_PIC (OPTION_ELF_BASE + 11)
d11520 10
d15416 1
d15418 1
a15418 1
-non_shared		do not generate position independent code\n\
@


1.392
log
@	* dwarf2dbg.c: Remove superfluous forward function declarations.
	(DWARF2_FORMAT): Add section arg.
	(out_header): New function, split out from..
	(out_debug_line): ..here.
	(out_debug_aranges): Use out_header.
	(out_debug_abbrev): Add info_seg and line_seg args.  Use
	DW_FORM_data8 (for DW_AT_stmt_list) if line_seg is 64-bit.
	(out_debug_info): Use out_header.  Output 8 byte DW_AT_stmt_list
	if line_seg is 64-bit.
	(dwarf2_finish): Adjust out_debug_abbrev call.
	* config/tc-mips.h (DWARF2_FORMAT, mips_dwarf2_format): Add sec arg.
	* config/tc-mips.c (mips_dwarf2_format): Likewise.
@
text
@d2132 40
d2180 1
a2180 2
	  && (reloc == BFD_RELOC_HI16_S
	      || reloc == BFD_RELOC_MIPS16_HI16_S
d2183 10
a2192 1
	      || (reloc == BFD_RELOC_MIPS_GOT16 && mips_pic != VXWORKS_PIC)));
d2202 1
a2202 2
	  && (fixp->fx_next->fx_r_type == BFD_RELOC_LO16
	     || fixp->fx_next->fx_r_type == BFD_RELOC_MIPS16_LO16)
a2983 2
		  || reloc_type[0] == BFD_RELOC_HI16_S
		  || reloc_type[0] == BFD_RELOC_LO16
d2996 2
a2997 2
		  || reloc_type[0] == BFD_RELOC_MIPS16_HI16_S
		  || reloc_type[0] == BFD_RELOC_MIPS16_LO16))
d10140 2
d10911 2
d12006 1
a12006 1
      if (l->fixp->fx_r_type == BFD_RELOC_MIPS_GOT16
d12024 1
a12024 6
      
      if (l->fixp->fx_r_type == BFD_RELOC_MIPS16_HI16
	   || l->fixp->fx_r_type == BFD_RELOC_MIPS16_HI16_S)
        looking_for_rtype = BFD_RELOC_MIPS16_LO16;
      else
        looking_for_rtype = BFD_RELOC_LO16;
d12077 2
a12078 2
	  || fixp->fx_r_type == BFD_RELOC_HI16_S
	  || fixp->fx_r_type == BFD_RELOC_LO16))
d12166 2
d13975 1
a13975 2
  if ((fixp->fx_r_type == BFD_RELOC_LO16
       || fixp->fx_r_type == BFD_RELOC_MIPS16_LO16
@


1.391
log
@        * config/tc-mips.c (mips_ip): Reset s to argsStart.
        * gas/mips/tls-ill.l: Update error message.
        * gas/mips/octeon-ill.l: Likewise.
@
text
@d15385 1
a15385 1
mips_dwarf2_format (void)
@


1.390
log
@include/elf/
	* mips.h (ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): New macros.

bfd/
	* elfxx-mips.c (mips_elf_check_mips16_stubs): Use ELF_ST_IS_MIPS16.
	(mips_elf_calculate_relocation): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.

opcodes/
	* mips-dis.c (_print_insn_mips): Use ELF_ST_IS_MIPS16.

gas/
	* config/tc-mips.c (mips16_mark_labels): Use ELF_ST_SET_MIPS16.
	(mips_fix_adjustable): Likewise.
	(mips_frob_file_after_relocs): Likewise.

gas/testsuite/
	* gas/mips/mips16-vis-1.d, gas/mips/mips16-vis-1.s: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d9961 1
a9961 1
	*(--s) = save_c;
@


1.389
log
@	* config/tc-mips.c (NO_ISA_COP): New macro.
	(COP_INSN): New macro.
	(is_opcode_valid): Use them.
	(macro) <ld_st>: Use them.  Don't accept coprocessor load store
	insns based on the ISA if CPU is NO_ISA_COP.
	<copz>: Likewise for coprocessor operations.
@
text
@d2324 1
a2324 1
	S_SET_OTHER (label, STO_MIPS16);
d13979 1
a13979 1
      && (S_GET_OTHER (fixp->fx_addsy) == STO_MIPS16
d14456 1
a14456 1
      if (elf_symbol (*syms)->internal_elf_sym.st_other == STO_MIPS16
@


1.388
log
@        * mips.h: Document new field descriptors +Q.
        (OP_SH_SEQI, OP_MASK_SEQI): New bit mask and shift count for SEQI.

opcodes/

        * mips-dis.c (print_insn_args): Handle field descriptor +Q.
        * mips-opc.c (mips_builtin_opcodes): Add Octeon instructions seq,
        seqi, sne and snei.

gas/

        * config/tc-mips.c (validate_mips_insn): Handle field descriptor +Q.
        (mips_ip): Likewise.
        (macro_build): Likewise.
        (CPU_HAS_SEQ): New macro.
        (macro2) <M_SEQ_I, M_SNE_I>: Use it.  Emit seq/sne and seqi/snei.

gas/testsuite/

        * gas/mips/octeon.s, gas/mips/octeon.d: Add tests for seq* and sne*.
        * gas/mips/octeon-ill.s, gas/mips/octeon-ill.s: Add tests for seqi
        and snei.
@
text
@d450 5
d512 11
a522 1
          ((PINFO & INSN_READ_HI) || (PINFO & INSN_READ_LO))
d1821 6
d6336 9
d7213 8
@


1.387
log
@include/opcode/

        * mips.h: Document new field descriptors +x, +X, +p, +P, +s, +S.
        Update comment before MIPS16 field descriptors to mention MIPS16.
        (OP_SH_BBITIND, OP_MASK_BBITIND): New bit mask and shift count for
        BBIT.
        (OP_SH_CINSPOS, OP_MASK_CINSPOS, OP_SH_CINSLM1, OP_MASK_CINSLM1):
        New bit masks and shift counts for cins and exts.

gas/

        * config/tc-mips.c (validate_mips_insn): Handle field descriptors
        +x, +X, +p, +P, +s, +S.
        (mips_ip): Likewise.

opcodes/

        * mips-dis.c (print_insn_args): Handle field descriptors +x, +p,
        +s, +S.
        * mips-opc.c (mips_builtin_opcodes): Add Octeon instructions
        baddu, bbit*, cins*, dmul, pop, dpop, exts*, mtm*, mtp*, syncs,
        syncw, syncws, vm3mulu, vm0 and vmulu.

gas/testsuite/

        * gas/mips/octeon.s, gas/mips/octeon.d: Add tests for baddu,
        bbit*, cins*, dmul, pop, dpop, exts*, mtm*, mtp*, syncs, syncw,
        syncws, vm3mulu, vm0 and vmulu.
        * gas/mips/octeon-ill.s, gas/mips/octeon-ill.s: New test.
        * gas/mips/mips.exp: Run it.  Run octeon test with
        run_dump_test_arches.
@
text
@d447 3
d3506 4
d7551 8
d7573 7
d7713 8
d7735 7
d8312 1
d9109 16
@


1.386
log
@	* config/tc-mips.c (mips_cpu_info_table): Move records for
	ST Loongson-2E/2F processors to a better place.
@
text
@d8271 7
d8977 94
@


1.385
log
@	gas/
        * config/tc-mips.c (mips_frob_file): Don't match MIPS16 relocs
        with non-MIPS16 relocs.


        gas/testsuite/
        * gas/mips/mips16-hilo-match.s: New test.
        * gas/mips/mip16-hilo-match.d: New test output.Index: config/tc-mips.c
@
text
@d14832 3
a14924 4
  /* ST Microelectronics Loongson 2E and 2F cores */
  { "loongson2e",     0,      ISA_MIPS3,      CPU_LOONGSON_2E },
  { "loongson2f",     0,      ISA_MIPS3,      CPU_LOONGSON_2F },

@


1.384
log
@* config/tc-mips.c (md_begin): Use strncmp to compare TARGET_OS, in
case that some characters append at the end of the name.
(mips_ip): Likewise.
(s_change_sec): Likewise.
(md_section_align): Likewise.
@
text
@d11752 1
d11782 7
d11794 1
a11794 2
	  if (((*pos)->fx_r_type == BFD_RELOC_LO16
	       || (*pos)->fx_r_type == BFD_RELOC_MIPS16_LO16)
@


1.383
log
@	* config/tc-mips.c (file_mips_soft_float, file_mips_single_float):
	New statics.
	(OPTION_ELF_BASE): Make room for new option macros.
	(OPTION_SOFT_FLOAT, OPTION_HARD_FLOAT, OPTION_SINGLE_FLOAT,
	OPTION_DOUBLE_FLOAT): New option macros.
	(md_longopts): Add msoft-float, mhard-float, msingle-float and
	mdouble-float.
	(md_parse_option): Handle OPTION_SINGLE_FLOAT,
	OPTION_DOUBLE_FLOAT, OPTION_SOFT_FLOAT and OPTION_HARD_FLOAT.
	(md_show_usage): Add -msoft-float, -mhard-float, -msingle-float
	and -mdouble-float.
	(struct mips_set_options): New fields soft_float and single_float.
	(mips_opts): Initialized them.  Add comment for each field
	initializer.
	(mips_after_parse_args): Set them based on file_mips_soft_float
	and file_mips_single_float.
	(s_mipsset): Add support for `.set softfloat', `.set hardfloat',
	`.set singlefloat' and `.set doublefloat'.
	(is_opcode_valid): New function to invoke OPCODE_IS_MEMBER.
	Handle single-float and soft-float instructions here.
	(macro_build, mips_ip): Use it instead of OPCODE_IS_MEMBER.
	(is_opcode_valid_16): New function.
	(mips16_ip): Use it instead of OPCODE_IS_MEMBER.
	(macro) <M_LDC1_AB, M_SDC1_AB, M_L_DOB, M_L_DAB, M_S_DAB,
	M_S_DOB>: Remove special-casing of r4650.
	* doc/c-mips.texi (-march=): Add Octeon.
	(MIPS Opts): Document -msoft-float and -mhard-float.  Document
	-msingle-float and -mdouble-float.
	(MIPS floating-point): New section.  Document `.set softfloat' and
	`.set hardfloat'.  Document `.set singlefloat' and `.set
	doublefloat'.
@
text
@d1960 2
a1961 2
      if (strcmp (TARGET_OS, "elf") != 0
	  && strcmp (TARGET_OS, "vxworks") != 0)
d1983 1
a1983 1
	if (strcmp (TARGET_OS, "elf") != 0)
d9555 1
a9555 1
		    if (IS_ELF && strcmp (TARGET_OS, "elf") != 0)
d12178 1
a12178 1
	  if (strcmp (TARGET_OS, "elf") != 0)
d12190 1
a12190 1
	  if (strcmp (TARGET_OS, "elf") != 0)
d13279 1
a13279 1
      if (strcmp (TARGET_OS, "elf") == 0)
@


1.382
log
@	* config/tc-mips.c (mips_cpu_info_table): Add Octeon.
@
text
@d238 9
d249 4
d259 5
a263 3
/* This is the struct we use to hold the current set of options.  Note
   that we must set the isa field to ISA_UNKNOWN and the ASE fields to
   -1 to indicate that they have not been initialized.  */
d267 6
a272 1
  ISA_UNKNOWN, -1, -1, 0, -1, -1, -1, -1, 0, ATREG, 0, 0, 0, 0, 0, 0, CPU_UNKNOWN, FALSE
d1773 65
d3455 1
a3455 10
	  && OPCODE_IS_MEMBER (mo,
			       (mips_opts.isa
				| (mips_opts.mips16 ? INSN_MIPS16 : 0)
				| (mips_opts.ase_dsp ? INSN_DSP : 0)
				| ((mips_opts.ase_dsp && ISA_SUPPORTS_DSP64_ASE)
				   ? INSN_DSP64 : 0)
				| (mips_opts.ase_dspr2 ? INSN_DSPR2 : 0)
				| (mips_opts.ase_smartmips ? INSN_SMARTMIPS : 0)),
			       mips_opts.arch)
	  && (mips_opts.arch != CPU_R4650 || (mo->pinfo & FP_D) == 0))
a6198 5
      if (mips_opts.arch == CPU_R4650)
	{
	  as_bad (_("opcode not supported on this processor"));
	  break;
	}
a6284 5
      if (mips_opts.arch == CPU_R4650)
	{
	  as_bad (_("opcode not supported on this processor"));
	  break;
	}
a6825 5
      if (mips_opts.arch == CPU_R4650)
	{
	  as_bad (_("opcode not supported on this processor"));
	  break;
	}
a6851 5
      if (mips_opts.arch == CPU_R4650)
	{
	  as_bad (_("opcode not supported on this processor"));
	  break;
	}
a6864 6
      if (mips_opts.arch == CPU_R4650)
	{
	  as_bad (_("opcode not supported on this processor"));
	  break;
	}

a7508 5
      if (mips_opts.arch == CPU_R4650)
	{
	  as_bad (_("opcode not supported on this processor"));
	  break;
	}
d8500 1
a8500 25
      if (OPCODE_IS_MEMBER (insn,
			    (mips_opts.isa
			     /* We don't check for mips_opts.mips16 here since
			        we want to allow jalx if -mips16 was specified
			        on the command line.  */
			     | (file_ase_mips16 ? INSN_MIPS16 : 0)
	      		     | (mips_opts.ase_mdmx ? INSN_MDMX : 0)
	      		     | (mips_opts.ase_dsp ? INSN_DSP : 0)
	      		     | ((mips_opts.ase_dsp && ISA_SUPPORTS_DSP64_ASE)
				? INSN_DSP64 : 0)
	      		     | (mips_opts.ase_dspr2 ? INSN_DSPR2 : 0)
	      		     | (mips_opts.ase_mt ? INSN_MT : 0)
			     | (mips_opts.ase_mips3d ? INSN_MIPS3D : 0)
			     | (mips_opts.ase_smartmips ? INSN_SMARTMIPS : 0)),
			    mips_opts.arch))
	ok = TRUE;
      else
	ok = FALSE;

      if (insn->pinfo != INSN_MACRO)
	{
	  if (mips_opts.arch == CPU_R4650 && (insn->pinfo & FP_D) != 0)
	    ok = FALSE;
	}

d9848 1
a9848 5
      if (OPCODE_IS_MEMBER (insn, mips_opts.isa, mips_opts.arch))
	ok = TRUE;
      else
	ok = FALSE;

d10977 9
a10985 1

d10988 1
a10988 1
#define OPTION_ELF_BASE    (OPTION_MISC_BASE + 16)
d11348 16
d11641 2
d12519 8
a15147 1
--[no-]construct-floats [dis]allow floating point values to be constructed\n\
d15150 7
@


1.381
log
@    * gas/mips/jalr.s: New test.
    * gas/mips/jalr.l: New test output.
    * gas/mips/mips.exp: Run new test.
@
text
@d14868 3
@


1.380
log
@gas/
	* config/tc-mips.h (mips_nop_opcode): Declare.
	(NOP_OPCODE): Define.
	(mips_segment_info): New structure.
	(TC_SEGMENT_INFO_TYPE): Use it instead of insn_label_list.
	* config/tc-mips.c (label_list): Adjust for new TC_SEGMENT_INFO_TYPE.
	(mips_record_mips16_mode): New function.
	(install_insn): Call it.
	(mips_align): Likewise.  Turn the fill argument into an "int *".
	Use frag_align_code for code segments if no fill data is given.
	(s_align): Adjust call accordingly.
	(mips_nop_opcode): New function.
	(mips_handle_align): Use the first variable byte to decide which
	nop sequence is needed.  Use md_number_to_chars and mips16_nop_insn.

gas/testsuite/
	* gas/mips/align2.s, gas/mips/align2.d, gas/mips/align2-el.d: New
	tests.
	* gas/mips/mips.exp: Run them.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d9136 13
@


1.379
log
@	bfd/
	* archures.c (bfd_mach_mips_loongson_2e): New.
	(bfd_mach_mips_loongson_2f): New.
	* bfd-in2.h (bfd_mach_mips_loongson_2e): New.
	(bfd_mach_mips_loongson_2f): New.
	* cpu-mips.c: Add I_loongson_2e and I_loongson_2f to
	anonymous enum.
	(arch_info_struct): Add Loongson-2E and Loongson-2F entries.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle Loongson-2E
	and Loongson-2F flags.
	(mips_set_isa_flags): Likewise.
	(mips_mach_extensions): Add Loongson-2E and Loongson-2F
	entries.

	binutils/
	* readelf.c (get_machine_flags): Handle Loongson-2E and -2F
	flags.

	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add loongson2e
	and loongson2f entries.
	* doc/c-mips.texi: Document -march=loongson{2e,2f} options.

	gas/testsuite/
	* gas/mips/mips.exp: Add loongson-2e and -2f tests.
	* gas/mips/loongson-2e.d: New.
	* gas/mips/loongson-2e.s: New.
	* gas/mips/loongson-2f.d: New.
	* gas/mips/loongson-2f.s: New.

	include/elf/
	* mips.h (E_MIPS_MACH_LS2E): New.
	(E_MIPS_MACH_LS2F): New.

	include/opcode/
	* mips.h (INSN_LOONGSON_2E): New.
	(INSN_LOONGSON_2F): New.
	(CPU_LOONGSON_2E): New.
	(CPU_LOONGSON_2F): New.
	(OPCODE_IS_MEMBER): Update for Loongson-2E and -2F flags.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add Loongson-2E and -2F
	entries.
	* mips-opc.c (IL2E): New.
	(IL2F): New.
	(mips_builtin_opcodes): Add Loongson-2E and -2F instructions.
	Allow movz and movn for Loongson-2E and -2F.  Add movnz entry.
	Move coprocessor encodings to the end of the table.  Allow
	certain MIPS V .ps instructions on the Loongson-2E and -2F.
@
text
@d1188 1
a1188 1
#define label_list tc_segment_info_data
d1313 12
d1347 1
d12010 6
a12015 2
/* Align the current frag to a given power of two.  The MIPS assembler
   also automatically adjusts any preceding label.  */
d12018 1
a12018 1
mips_align (int to, int fill, symbolS *label)
d12021 5
a12025 1
  frag_align (to, fill, 0);
d12041 1
a12041 2
  int temp;
  long temp_fill;
d12063 2
a12064 1
      temp_fill = get_absolute_expression ();
d12067 1
a12067 1
    temp_fill = 0;
d12074 1
a12074 1
      mips_align (temp, (int) temp_fill, l != NULL ? l->label : NULL);
d14345 11
a14355 1
/* Fill in an rs_align_code fragment.  */
d14360 2
d14365 2
a14366 1
  if (mips_opts.mips16)
a14367 3
      static const unsigned char be_nop[] = { 0x65, 0x00 };
      static const unsigned char le_nop[] = { 0x00, 0x65 };

a14368 1
      char *p;
a14370 2
      p = fragp->fr_literal + fragp->fr_fix;

d14376 1
a14376 2

      memcpy (p, (target_big_endian ? be_nop : le_nop), 2);
a14378 2

  /* For mips32, a nop is a zero, which we trivially get by doing nothing.  */
@


1.378
log
@	* config/tc-mips.c (md_parse_option): Match mips_optimize to the -O
	option supplied, but still keep mips_optimize == 2 as default value.
@
text
@d14826 4
@


1.377
log
@Remove duplicate definitions of the md_atof() function
@
text
@d11016 5
a11020 1
      if (arg && arg[0] == '0')
@


1.376
log
@gas/:
* config/tc-mips.c (AT): Rename to...
(ATREG): ... this.
(AT): New definition.
(mips_set_options): Rename "noat" to "at"; change the type.
(mips_opts): Update accordingly.
(append_insn): Likewise.
(macro_build_ldst_constoffset): Likewise.
(load_address): Likewise.
(macro, macro2): Likewise.
(s_mipsset): Handle ".set at=REG".  Update handling of ".set at"
and ".set noat".

gas/testsuite/:
* gas/mips/at-1.d, gas/mips/at-2.l: New tests to check the ".set
at=REG" directive.
* gas/mips/at-1.s, gas/mips/at-2.s: Sources for the new tests.
* gas/mips/mips.exp: Run the new tests.
@
text
@a10763 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d10767 1
a10767 44
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * 2;

  if (! target_big_endian)
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litP, words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, words[i], 2);
	  litP += 2;
	}
    }

  return NULL;
@


1.375
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@d92 1
a92 1
#define AT  1
d104 2
d208 5
a212 3
  /* Non-zero if we should not permit the $at ($1) register to be used
     in instructions.  Changed by `.set at' and `.set noat'.  */
  int noat;
d252 1
a252 1
  ISA_UNKNOWN, -1, -1, 0, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, CPU_UNKNOWN, FALSE
d2644 1
a2644 1
      && !(mips_opts.noat && mips_pic != NO_PIC)
d3822 1
a3822 1
      if (mips_opts.noat)
d4233 1
a4233 1
	  if (*used_at == 0 && !mips_opts.noat)
d4422 1
a4422 1
  if (mips_opts.noat && *used_at == 1)
d4531 2
a4532 2
  int treg, sreg, dreg, breg;
  int tempreg;
d5295 1
a5295 1
      if (!mips_opts.noat && (treg == breg))
d5354 1
a5354 1
	      if (used_at == 0 && !mips_opts.noat)
d6351 1
a6351 1
	      if (used_at == 0 && !mips_opts.noat)
d7144 1
a7144 1
  if (mips_opts.noat && used_at)
d7151 2
a7152 2
  int treg, sreg, dreg, breg;
  int tempreg;
d7935 1
a7935 1
  if (mips_opts.noat && used_at)
d9096 8
a9103 2
		  if (regno == AT && ! mips_opts.noat)
		    as_warn ("Used $at without \".set noat\"");
d9996 8
a10003 2
		  if (regno == AT && ! mips_opts.noat)
		    as_warn (_("used $at without \".set noat\""));
d12423 7
d12432 1
a12432 1
      mips_opts.noat = 0;
d12436 1
a12436 1
      mips_opts.noat = 1;
@


1.374
log
@gas/

2007-09-24  Carlos O'Donell  <carlos@@codesourcery.com>

	* config/tc-mips.c (s_align): Set max_alignment to 28.

gas/testsuite/

2007-09-24  Carlos O'Donell  <carlos@@codesourcery.com>

	* gas/mips/align.s, gas/mips/align.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d1112 1
a1112 1
  {"asciiz", stringer, 1},
@


1.373
log
@	* config/tc-mips.c (mips_dwarf2_format, mips_dwarf2_addr_size): Use
	HAVE_64BIT_SYMBOLS.
@
text
@d12050 1
a12050 1
  long max_alignment = 15;
@


1.372
log
@gas/
	* config/tc-mips.c (mips_cpu_info_table): Add new entries for
	{24k,24ke,34k,74k}f{2_1,1_1,x}.  Also add an entry for 74kf3_2.
	Deprecate *x and *fx.
	* doc/c-mips.texi: Document the new CPU arguments.  Deprecate
	*x and *fx.
@
text
@d15107 1
a15107 1
  if (mips_abi == N64_ABI)
d15122 1
a15122 1
  if (mips_abi == N64_ABI)
@


1.371
log
@Switch to GPLv3
@
text
@d14787 1
d14789 3
d14795 1
d14797 3
d14804 2
d14808 5
d14818 2
d14822 7
@


1.370
log
@bfd:
	* elfxx-mips.c (mips_elf_calculate_relocation): Handle
	R_MIPS_TLS_DTPREL32 and R_MIPS_TLS_DTPREL64.
	* elf64-mips.c (mips_elf64_howto_table_rela): Support
	R_MIPS_TLS_DTPREL64.

gas:
	* config/tc-mips.c (s_dtprelword, s_dtpreldword,
	s_dtprel_internal): New.
	(mips_pseudo_table): Add .dtprelword and .dtpreldword.
	(md_apply_fix): Handle BFD_RELOC_MIPS_TLS_DTPREL32 and
	BFD_RELOC_MIPS_TLS_DTPREL64.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d13 1
a13 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.369
log
@bfd/
	* elfxx-mips.c (mips_elf_calculate_relocation): Allow local stubs
	to be used for calls from MIPS16 code.

gas/
	* config/tc-mips.h (TC_SYMFIELD_TYPE): New.
	* config/tc-mips.c (append_insn): Record which symbols have
	R_MIPS16_26 relocations against them.
	(mips_fix_adjustable): Don't reduce relocations against such symbols.

ld/testsuite/
	* ld-mips-elf/mips16-local-stubs-1.s,
	* ld-mips-elf/mips16-local-stubs-1.d: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d1027 2
d1102 2
d11819 2
a11820 1
	  || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY);
d11843 2
d12928 46
@


1.368
log
@	* config/tc-mips.c (s_mipsset): Use generic s_set for directives
	containing a comma.
@
text
@d2795 5
d13620 40
a13659 2
  /* Don't adjust relocations against mips16 symbols, so that the linker
     can find them if it needs to set up a stub.  */
d13661 3
a13663 2
      && S_GET_OTHER (fixp->fx_addsy) == STO_MIPS16
      && fixp->fx_subsy == NULL)
@


1.367
log
@	* config/tc-mips.c (md_parse_option): Fix parsing of -O option.
@
text
@d12617 8
@


1.366
log
@	* config/tc-mips.c: Fix comment.
@
text
@d11039 1
a11039 1
      if (arg && arg[1] == '0')
@


1.365
log
@gas/
	* doc/as.texinfo: Add -mvxworks-pic to the list of MIPS options.
	* doc/c-mips.texi (-KPIC, -mvxworks-pic): Document.
	* config/tc-mips.c (md_show_usage): Mention -mvxworks-pic.
@
text
@d510 1
a510 1
/* The size of the small data section.  */
@


1.364
log
@	* config/tc-mips.c (mips_cpu_info_table): Add 74K configurations.
@
text
@d14950 1
@


1.363
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (mips_set_options, mips_opts, file_ase_dspr2,
	ISA_SUPPORTS_DSPR2_ASE, MIPS_CPU_ASE_DSPR2): Add DSP R2 ASE support.
	(macro_build): Add case '2'.
	(macro): Expand M_BALIGN to nop, packrl.ph or balign.
	(validate_mips_insn): Add support for balign instruction.
	(mips_ip): Handle DSP R2 instructions. Support balign instruction.
	(OPTION_DSPR2, OPTION_NO_DSPR2, OPTION_COMPAT_ARCH_BASE,
	md_parse_option, mips_after_parse_args): Add -mdspr2 and -mno-dspr2
	command line options.
	(s_mipsset): Add support for .set dspr2 and .set nodspr2 directives.
	(md_show_usage): Add -mdspr2 and -mno-dspr2 help output.
	* doc/c-mips.texi, doc/as.texinfo: Document -mdspr2, -mno-dspr2,
	.set dspr2, .set nodspr2.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/mips32-dspr2.s, gas/mips/mips32-dspr2.d: New test for
	DSP R2.
	* gas/mips/mips.exp: Run new test.

	[ include/opcode/Changelog ]
	* mips.h (OP_SH_BP, OP_MASK_BP): Add support for balign instruction.
	(INSN_DSPR2): Add flag for DSP R2 instructions.
	(M_BALIGN): New macro.

	[ opcodes/ChangeLog ]
	* mips-dis.c (mips_arch_choices): Add DSP R2 support.
	(print_insn_args): Add support for balign instruction.
	* mips-opc.c (D33): New shortcut for DSP R2 instructions.
	(mips_builtin_opcodes): Add DSP R2 instructions.

	[ sim/mips/ChangeLog ]
	* Makefile.in (IGEN_INCLUDE): Add dsp2.igen.
	* configure.ac (mips*-sde-elf*, mipsisa32r2*-*-*, mipsisa64r2*-*-*):
	Add dsp2 to sim_igen_machine.
	* configure: Regenerate.
	* dsp.igen (do_ph_op): Add MUL support when op = 2.
	(do_ph_mulq): New function to support mulq_rs.ph and mulq_s.ph.
	(mulq_rs.ph): Use do_ph_mulq.
	(MFHI, MFLO, MTHI, MTLO): Move these instructions to mips.igen.
	* mips.igen: Add dsp2 model and include dsp2.igen.
	(MFHI, MFLO, MTHI, MTLO): Extend these instructions for
	for *mips32r2, *mips64r2, *dsp.
	(MADD, MADDU, MSUB, MSUBU, MULT, MULTU): Extend these instructions
	for *mips32r2, *mips64r2, *dsp2.
	* dsp2.igen: New file for MIPS DSP REV 2 ASE.

	[ sim/testsuite/sim/mips/ChangeLog ]
	* basic.exp: Run the dsp2 test.
	* utils-dsp.inc (dspckacc_astio, dspck_tsimm): New macro.
	* mips32-dsp2.s: New test.
@
text
@d14684 1
a14684 1
  /* 24ke is a 24k with DSP ASE, other ASEs are optional.  */
d14688 1
a14688 1
  /* 34k is a 24k with DSP and MT ASE, other ASEs are optional.  */
d14695 7
@


1.362
log
@	* config/tc-mips.c (md_show_usage):  Clean up -mno-shared
	documentation.
@
text
@d196 1
d248 1
a248 1
  ISA_UNKNOWN, -1, -1, 0, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, CPU_UNKNOWN, FALSE
d293 7
d1063 1
d3338 7
a3344 5
  /* Search until we get a match for NAME.  It is assumed here that
     macros will never generate MDMX, MIPS-3D, DSP or MT instructions.  */
  while (strcmp (fmt, mo->args) != 0
	 || mo->pinfo == INSN_MACRO
	 || !OPCODE_IS_MEMBER (mo,
d3347 4
d3353 3
a3355 2
	 || (mips_opts.arch == CPU_R4650 && (mo->pinfo & FP_D) != 0))
    {
d3406 4
d4638 16
d8261 1
d8439 1
d8495 14
d10881 4
d10887 1
a10887 1
#define OPTION_COMPAT_ARCH_BASE (OPTION_ASE_BASE + 12)
d11138 1
d11143 11
d11568 9
d11580 1
a11580 1
      as_warn ("%s ISA does not support MT ASE", 
d11589 1
d12480 1
d12483 17
a12499 1
    mips_opts.ase_dsp = 0;
d14183 1
d14924 3
@


1.361
log
@	* config/tc-mips.c: Fix outdated comment.
@
text
@a14834 1
-mno-shared		optimize output for executables\n\
d14848 1
a14848 1
                        non-shared code\n\
@


1.360
log
@gas:
	* config/tc-mips.c (pic_need_relax): Return true for section symbols.

gas/testsuite:
	* gas/mips/elf-rel26.s: New test.
	* gas/mips/elf-rel26.d: Ditto.
	* gas/mips/mips.exp: Run it.
@
text
@d1075 1
a1075 2
   they are not currently supported: .asm0, .endr, .lab, .repeat,
   .struct.  */
@


1.359
log
@	* config/tc-mips.c (mips_cpu_info_table): Remove 24k/24ke aliases.
	34k always has DSP ASE.
@
text
@d13156 3
@


1.358
log
@Fix typo in comment.
@
text
@a14582 1
  { "24k",            0,			ISA_MIPS32R2,   CPU_MIPS32R2 },
a14586 1
  { "24ke",           MIPS_CPU_ASE_DSP,		ISA_MIPS32R2,	CPU_MIPS32R2 },
d14590 7
a14596 4
  /* 34k is a 24k with MT ASE, other ASEs are optional.  */
  { "34kc",           MIPS_CPU_ASE_MT,		ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "34kf",           MIPS_CPU_ASE_MT,		ISA_MIPS32R2,	CPU_MIPS32R2 },
  { "34kx",           MIPS_CPU_ASE_MT,		ISA_MIPS32R2,	CPU_MIPS32R2 },
@


1.357
log
@	* config/tc-mips.c (md_pcrel_from_section): Disallow PC relative
	MIPS16 instructions referencing other sections, unless they are
	external branches.
@
text
@d11547 1
a11547 1
      /* We have no relocation type for PC relative MIPS16 intructions.  */
@


1.356
log
@	* config/tc-mips.c (mips_cpu_info_table): The 25Kf is a MIPS64
	release 1 CPU.
@
text
@d11547 4
@


1.355
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (mips16_ip): Fix argument register handling
	for restore instruction.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/mips16-save.d: Fix testcase.
@
text
@d14597 1
a14599 1
  { "25kf",           MIPS_CPU_ASE_MIPS3D,	ISA_MIPS64R2,   CPU_MIPS64R2 },
@


1.354
log
@	* config/tc-mips.c (md_section_align): Check ELF-ness at runtime.
@
text
@d10204 1
a10204 1
			    if (c == 'm' && !seen_framesz)
@


1.353
log
@	* config/tc-mips.c (macro_build_lui): Fix comment formatting.
	(md_apply_fix): Likewise. Unify handling of BFD_RELOC_RVA,
	BFD_RELOC_32 and BFD_RELOC_16.
	(s_align, s_cpload, s_cplocal, s_cprestore, s_mips_stab,
	md_convert_frag, md_obj_end): Fix comment formatting.
@
text
@d13045 11
a13055 10
#ifdef OBJ_ELF
  /* We don't need to align ELF sections to the full alignment.
     However, Irix 5 may prefer that we align them at least to a 16
     byte boundary.  We don't bother to align the sections if we are
     targeted for an embedded system.  */
  if (strcmp (TARGET_OS, "elf") == 0)
    return addr;
  if (align > 4)
    align = 4;
#endif
@


1.352
log
@	* config/tc-mips.c (md_apply_fix, tc_gen_reloc): Remove special
	handling for BFD_RELOC_MIPS16_JMP.
@
text
@d3722 1
a3722 1
      /* we can compute the instruction now without a relocation entry */
d11791 1
a11791 1
      /* Nothing needed to do. The value comes from the reloc entry */
d11819 1
d11822 1
a11822 1
	 resolved when it appears but is later defined.   */
d11824 1
a11824 8
	md_number_to_chars ((char *) buf, *valP, 4);
      break;

    case BFD_RELOC_16:
      /* If we are deleting this reloc entry, we must fill in the
         value now.  */
      if (fixP->fx_done)
	md_number_to_chars ((char *) buf, *valP, 2);
d11849 3
a11851 5
      /*
       * We need to save the bits in the instruction since fixup_segment()
       * might be deleting the relocation entry (i.e., a branch within
       * the current segment).
       */
d11855 1
a11855 1
      /* update old instruction data */
d11959 1
a11959 3
  /*

    o  Note that the assembler pulls down any immediately preceding label
d11961 1
a11961 1
    o  It's not documented but auto alignment is reinstated by
d11963 1
a11963 1
    o  Note also that after auto alignment is turned off the mips assembler
d11965 1
a11965 3
       We don't.

    */
d11986 1
a11986 1
      /* Auto alignment should be switched on by next section change */
d12626 1
a12626 2
	addiu	$gp,$gp,%lo(_gp)
   */
d12728 1
a12728 1
   .cplocal is ignored.  */
d12777 2
a12778 2
     daddu	$gp, $reg2, $0
 */
d12972 1
a12972 2
/* Handle the .weakext pseudo-op as defined in Kane and Heinrich.
 */
d13670 1
a13670 1
		     bltzal	0x04100000	bgezal	0x04110000 */
d13677 1
a13677 1
		     blez	0x18000000	bgtz	0x1c000000 */
d13691 2
a13692 2
	      /* bltzal	0x04100000	bgezal	0x04110000
		bltzall	0x04120000     bgezall	0x04130000 */
d13717 1
a13717 1
	  /* Nop */
d14177 1
a14177 1
  /* check for premature end, nesting errors, etc */
@


1.351
log
@	* config/tc-mips.c (md_parse_option): Don't infer optimisation
	options from debug options.
@
text
@d11790 1
a11793 7
    case BFD_RELOC_MIPS16_JMP:
      /* We currently always generate a reloc against a symbol, which
         means that we don't want an addend even if the symbol is
         defined.  */
      *valP = 0;
      break;

a13564 4
  /* Handle relocs adjusted against a section symbol.  */
  if (fixp->fx_r_type == BFD_RELOC_MIPS16_JMP)
    reloc->addend += fixp->fx_offset;

@


1.350
log
@	[ bfd/ChangeLog ]
	* elf32-mips.c (mips16_jump_reloc): Remove function.
	(elf_mips16_howto_table_rel): Use _bfd_mips_elf_generic_reloc
	instead of mips16_jump_reloc.
	* elf64_mips.c, wlfn32-mips.c (mips16_jump_reloc): Remove function.
	(elf_mips16_howto_table_rel, elf_mips16_howto_table_rela): Use
	_bfd_mips_elf_generic_reloc instead of mips16_jump_reloc.

	[ gas/ChangeLog ]
	* config/tc-mips.c (mips_fix_adjustable): Handle BFD_RELOC_MIPS16_JMP.
	(tc_gen_reloc): Handle mips16 jumps to section symbol offsets.

	[ ld/testsuite/ChangeLog ]
	* ld-mips-elf/mips16-call-global-1.s,
	ld-mips-elf/mips16-call-global-2.s,
	ld-mips-elf/mips16-call-global-3.s, ld-mips-elf/mips16-call-global.d:
	Test linking of external mips16 jumps.
	* ld-mips-elf/mips-elf.exp: Run new test.
@
text
@a10994 5
      /* When the MIPS assembler sees -g or -g2, it does not do
         optimizations which limit full symbolic debugging.  We take
         that to be equivalent to -O0.  */
      if (mips_debug == 2)
	mips_optimize = 1;
@


1.349
log
@	* read.c (s_struct): Use IS_ELF.
	* config/tc-mips.c (md_begin, mips16_mark_labels, mips_ip,
	md_parse_option, s_change_sec, pic_need_relax, mips_fix_adjustable,
	tc_gen_reloc, mips_frob_file_after_relocs, s_mips_end, s_mips_frame,
	s_mips_mask): Likewise.
@
text
@a13500 5
  /* Don't adjust MIPS16 jump relocations, so we don't have to worry
     about the format of the offset in the .o file. */
  if (fixp->fx_r_type == BFD_RELOC_MIPS16_JMP)
    return 0;

d13576 4
@


1.348
log
@Add Broadcom SB-1A support.
* config/tc-mips.c (mips_cpu_info_table): Add sb1a.
@
text
@d1841 1
a1841 1
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d1914 1
a1914 1
	else if (OUTPUT_FLAVOR == bfd_target_elf_flavour && mips_flag_pdr)
d2185 1
a2185 1
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d9431 1
a9431 1
		    if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d9438 1
a9438 2
		    if (OUTPUT_FLAVOR == bfd_target_elf_flavour
			&& strcmp (TARGET_OS, "elf") != 0)
d11173 1
a11173 1
      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d11183 1
a11183 1
      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d11209 1
a11209 1
      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d11218 1
a11218 1
      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d11227 1
a11227 1
      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d11233 1
a11233 1
      if (! support_64bit_objects())
d11256 1
a11256 1
      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d12033 2
a12034 1
  obj_elf_section_change_hook ();
d12054 1
a12054 1
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d12067 1
a12067 1
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d12093 1
a12093 1
  if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d13185 1
a13185 2
	  && (OUTPUT_FLAVOR != bfd_target_elf_flavour
	      || (! S_IS_WEAK (sym) && ! S_IS_EXTERNAL (sym)))
d13537 1
a13537 1
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
d13569 1
a13569 1
      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d14008 1
a14008 1
  if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
d14364 1
a14364 2
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour && ! ECOFF_DEBUGGING
      && mips_flag_pdr)
d14458 1
a14458 1
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour && ! ECOFF_DEBUGGING)
d14501 1
a14501 1
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour && ! ECOFF_DEBUGGING)
@


1.347
log
@	* config/tc-mips.c (s_is_linkonce): New function.
	(mips16_mark_labels): Don't adjust mips16 symbol addresses for
	weak, external, and linkonce symbols.
	(pic_need_relax): Use s_is_linkonce.
@
text
@d14635 3
@


1.346
log
@	* config/tc-mips.c (nopic_need_relax): Handle -fdata-sections
	generated .sbss.* and .gnu.linkonce.sb.*.
@
text
@d2141 22
d2188 8
a2195 1
      if ((S_GET_VALUE (label) & 1) == 0)
a13162 1
  bfd_boolean linkonce;
d13169 1
a13169 2
      /* It's possible to get a loop here in a badly written
	 program.  */
a13177 16
  /* duplicate the test for LINK_ONCE sections as in adjust_reloc_syms */
  linkonce = FALSE;
  if (symsec != segtype && ! S_IS_LOCAL (sym))
    {
      if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE)
	  != 0)
	linkonce = TRUE;

      /* The GNU toolchain uses an extension for ELF: a section
	 beginning with the magic string .gnu.linkonce is a linkonce
	 section.  */
      if (strncmp (segment_name (symsec), ".gnu.linkonce",
		   sizeof ".gnu.linkonce" - 1) == 0)
	linkonce = TRUE;
    }

d13181 2
a13182 2
	  && ! bfd_is_com_section (symsec)
	  && !linkonce
@


1.345
log
@	* config/tc-mips.h (TC_SEGMENT_INFO_TYPE): Declare per-segment
	label_list.
	* config/tc-mips.c (label_list): Define per-segment label_list.
	(mips_clear_insn_labels, mips_move_labels, mips16_mark_labels,
	append_insn, s_align, s_cons, s_float_cons, s_gpword, s_gpdword,
	mips_from_file_after_relocs, mips_define_label): Use per-segment
	label_list.
@
text
@d13116 2
@


1.344
log
@	* config/tc-mips.c (ISA_SUPPORTS_MIPS16E): New macro.
	(append_insn): Use it.
	(md_apply_fix): Whitespace formatting.
	(md_begin, append_insn, macro, macro2, mips16_immed, mips_align,
	mips16_extended_frag): Remove register specifier.
	(md_convert_frag): Likewise. Use TRUE ans FALSE instead of numeric
	constants.
@
text
@a1170 1
static struct insn_label_list *insn_labels;
d1172 1
d1180 1
d1182 9
a1190 4
  for (pl = &free_insn_labels; *pl != NULL; pl = &(*pl)->next)
    ;
  *pl = insn_labels;
  insn_labels = NULL;
d1192 1
d2125 1
d2129 1
a2129 1
  for (l = insn_labels; l != NULL; l = l->next)
d2152 9
a2160 4
  if (mips_opts.mips16)
    {
      struct insn_label_list *l;
      valueT val;
d2162 3
a2164 5
      for (l = insn_labels; l != NULL; l = l->next)
	{
#ifdef OBJ_ELF
	  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
	    S_SET_OTHER (l->label, STO_MIPS16);
d2166 2
a2167 4
	  val = S_GET_VALUE (l->label);
	  if ((val & 1) == 0)
	    S_SET_VALUE (l->label, val + 1);
	}
d2495 1
d2912 1
a2912 1
	      || insn_labels != NULL
d11979 3
d11983 1
a11983 2
      mips_align (temp, (int) temp_fill,
		  insn_labels != NULL ? insn_labels->label : NULL);
d12136 2
d12140 1
a12140 1
  label = insn_labels != NULL ? insn_labels->label : NULL;
d12151 2
d12155 1
a12155 1
  label = insn_labels != NULL ? insn_labels->label : NULL;
d12830 2
d12843 3
a12845 1
  label = insn_labels != NULL ? insn_labels->label : NULL;
d12870 2
d12883 3
a12885 1
  label = insn_labels != NULL ? insn_labels->label : NULL;
d14024 1
d14036 2
a14037 2
  l->next = insn_labels;
  insn_labels = l;
@


1.343
log
@Lost bit belonging to the last commit.
@
text
@d263 5
d1723 1
a1723 1
  register const char *retval = NULL;
d2483 1
a2483 1
  register unsigned long prev_pinfo, pinfo;
d3009 1
a3009 4
		  && (mips_opts.isa == ISA_MIPS32
		      || mips_opts.isa == ISA_MIPS32R2
		      || mips_opts.isa == ISA_MIPS64
		      || mips_opts.isa == ISA_MIPS64R2))
d4460 1
a4460 1
  register int treg, sreg, dreg, breg;
d7064 1
a7064 1
  register int treg, sreg, dreg, breg;
d10378 1
a10378 1
  register const struct mips16_immed_operand *op;
d11700 1
a11700 1
  assert (! fixP->fx_pcrel || fixP->fx_r_type == BFD_RELOC_16_PCREL_S2);
d11712 1
a11712 1
  if (fixP->fx_addsy == NULL && ! fixP->fx_pcrel && fixP->fx_tcbit == 0)
d11936 2
a11937 2
  register int temp;
  register long temp_fill;
d13162 1
a13162 1
  register const struct mips16_immed_operand *op;
d13632 1
a13632 1
			      4, &exp, 1, BFD_RELOC_16_PCREL_S2);
d13749 1
a13749 1
				  4, &exp, 0, BFD_RELOC_MIPS_JMP);
d13771 1
a13771 1
				  4, &exp, 0, BFD_RELOC_MIPS_GOT16);
d13789 1
a13789 1
				  4, &exp, 0, BFD_RELOC_LO16);
d13818 1
a13818 1
      register const struct mips16_immed_operand *op;
@


1.342
log
@	* config/tc-mips.c (mips_pseudo_table): Add "origin" and "repeat"
	aliases for better compatibility with SGI tools.
@
text
@d8623 1
@


1.341
log
@remove some duplicate #include's.
@
text
@d1101 2
@


1.340
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (ISA_SUPPORTS_DSP64): New macro.
	(CPU_HAS_MIPS3D, CPU_HAS_MDMX, CPU_HAS_DSP, CPU_HAS_MT): Delete.
	(macro_build): Update comment.
	(mips_ip): Allow DSP64 instructions for MIPS64R2.
	(mips_after_parse_args): Remove uses of CPU_HAS_MIPS3D and
	CPU_HAS_MDMX.
	(mips_cpu_info): Fix formatting. Add MIPS_CPU_ASE_MIPS3D and
	MIPS_CPU_ASE_MDMX flags for sb1.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/mips64-dsp.s, gas/mips/mips64-dsp.d: New DSP64 tests.
	* gas/mips/mips.exp: Run DSP64 tests.

	[ opcodes/ChangeLog ]
	* mips-dis.c: Disassemble DSP64 instructions for MIPS64R2.
	* mips-opc.c: Add DSP64 instructions.
@
text
@d3 1
a3 1
   2003, 2004, 2005 Free Software Foundation, Inc.
a30 2
#include <stdarg.h>

@


1.339
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (macro_build): Use INSERT_OPERAND wherew
	appropriate.
	(mips16_macro_build): Use MIPS16_INSERT_OPERAND where appropriate.
	(mips_ip): Make overflowed/underflowed constant arguments in DSP
	and MT instructions a fatal error. Use INSERT_OPERAND where
	appropriate. Improve warnings for break and wait code overflows.
	Use symbolic constant of OP_MASK_COPZ.
	(mips16_ip): Use MIPS16_INSERT_OPERAND where appropriate.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/mips32-dsp.d, gas/mips/mips32-dsp.s, gas/mips/mips32-mt.d,
	gas/mips/mips32-mt.s: Remove instructions with invalid arguments.
	* gas/mips/mips32-dsp.l, gas/mips/mips32-mt.l: Delete file.

	[ include/opcode/ChangeLog ]
	* mips.h: Improve description of MT flags.
@
text
@d287 2
a405 16
/* Return true if the given CPU supports the MIPS3D ASE.  */
#define CPU_HAS_MIPS3D(cpu)	((cpu) == CPU_SB1      \
				 )

/* Return true if the given CPU supports the MDMX ASE.  */
#define CPU_HAS_MDMX(cpu)	(FALSE                 \
				 )

/* Return true if the given CPU supports the DSP ASE.  */
#define CPU_HAS_DSP(cpu)	(FALSE                 \
				 )

/* Return true if the given CPU supports the MT ASE.  */
#define CPU_HAS_MT(cpu)		(FALSE                 \
				 )

d3290 1
a3290 1
     macros will never generate MDMX or MIPS-3D instructions.  */
d8360 2
d11442 1
a11442 2
    mips_opts.ase_mips3d = ((CPU_HAS_MIPS3D (file_mips_arch)
			     || (arch_info->flags & MIPS_CPU_ASE_MIPS3D))
d11448 1
a11448 2
    mips_opts.ase_mdmx = ((CPU_HAS_MDMX (file_mips_arch)
			   || (arch_info->flags & MIPS_CPU_ASE_MDMX))
d14577 1
a14577 1
  { "24kex",         MIPS_CPU_ASE_DSP,		ISA_MIPS32R2,	CPU_MIPS32R2 },
d14581 1
a14581 1
  { "34kx",          MIPS_CPU_ASE_MT,		ISA_MIPS32R2,	CPU_MIPS32R2 },
d14592 2
a14593 1
  { "sb1",            0,			ISA_MIPS64,	CPU_SB1 },
@


1.338
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (ISA_SUPPORTS_SMARTMIPS): Rename.
	(ISA_SUPPORTS_DSP_ASE, ISA_SUPPORTS_MT_ASE, ISA_HAS_64BIT_FPRS,
	ISA_HAS_MXHC1): New macros.
	(HAVE_32BIT_FPRS): Use ISA_HAS_64BIT_FPRS instead of
	ISA_HAS_64BIT_REGS.  Formatting fixes.  Improved comments.
	(mips_cpu_info): Change to use combined ASE/IS_ISA flag.
	(MIPS_CPU_IS_ISA, MIPS_CPU_ASE_SMARTMIPS, MIPS_CPU_ASE_DSP,
	MIPS_CPU_ASE_MT, MIPS_CPU_ASE_MIPS3D, MIPS_CPU_ASE_MDMX): New defines.
	(mips_after_parse_args): Change default handling of float register
	size to account for 32bit code with 64bit FP. Better sanity checking
	of ISA/ASE/ABI option combinations.
	(s_mipsset): Support switching of GPR and FPR sizes via
	.set {g,f}p={32,64,default}. Better sanity checking for .set ASE
	options.
	(mips_elf_final_processing): We should record the use of 64bit FP
	registers in 32bit code but we don't, because ELF header flags are
	a scarce ressource.
	(mips_cpu_info_table): Add ASE flags for CPUs with mandatory ASE
	extensions. Add 4ksc, 4kec, 4kem, 4kep, 4ksd, m4kp, 24kec, 24kef,
	24kex, 34kc, 34kf, 34kx, 25kf CPU definitions.
	(mips_cpu_info_from_isa): Use MIPS_CPU_IS_ISA.
	* doc/c-mips.texi: Document .set {g,f}p={32,64,default}. Document
	missing -march options. Document .set arch=CPU. Move .set smartmips
	to ASE page. Use @@code for .set FOO examples.

	[ gas/testsuite/Changelog ]
	* gas/mips/mips-gp32-fp64-pic.d, mips/mips-gp32-fp64.d,
	gas/mips/mips-gp64-fp32-pic.d, gas/mips/mips-gp64-fp32.l,
	gas/mips/mips-gp64-fp64.d: Adjust test cases to the changes assembler
	output.
	* gas/mips/mips-gp32-fp64.l, gas/mips/mips-gp64-fp32-pic.l: New files,
	catch assembler warnings.
@
text
@d3491 1
a3491 1
	  insn.insn_opcode |= va_arg (args, unsigned long);
d3495 1
a3495 1
	  insn.insn_opcode |= va_arg (args, unsigned long) << OP_SH_CACHE;
d3579 1
a3579 1
	    insn.insn_opcode |= regno << MIPS16OP_SH_REG32R;
d8434 2
a8435 3
		  as_warn (_("DSP immediate not in range 0..%d (%lu)"),
			   OP_MASK_SA3, (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_SA3;
d8437 1
a8437 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_SA3;
d8447 2
a8448 3
		  as_warn (_("DSP immediate not in range 0..%d (%lu)"),
			   OP_MASK_SA4, (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_SA4;
d8450 1
a8450 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_SA4;
d8460 2
a8461 3
		  as_warn (_("DSP immediate not in range 0..%d (%lu)"),
			   OP_MASK_IMM8, (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_IMM8;
d8463 1
a8463 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_IMM8;
d8473 2
a8474 3
		  as_warn (_("DSP immediate not in range 0..%d (%lu)"),
			   OP_MASK_RS, (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_RS;
d8476 1
a8476 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_RS;
d8487 1
a8487 1
		  ip->insn_opcode |= regno << OP_SH_DSPACC;
d8499 3
a8501 4
		  as_warn (_("DSP immediate not in range 0..%d (%lu)"),
			   OP_MASK_WRDSP,
			   (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_WRDSP;
d8503 1
a8503 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_WRDSP;
d8514 1
a8514 1
		  ip->insn_opcode |= regno << OP_SH_DSPACC_S;
d8529 3
a8531 3
		  as_warn (_("DSP immediate not in range %ld..%ld (%ld)"),
			   (long) min_range, (long) max_range,
			   (long) imm_expr.X_add_number);
d8533 1
a8533 3
	      imm_expr.X_add_number &= OP_MASK_DSPSFT;
	      ip->insn_opcode |= ((unsigned long) imm_expr.X_add_number
				  << OP_SH_DSPSFT);
d8543 3
a8545 4
		  as_warn (_("DSP immediate not in range 0..%d (%lu)"),
			   OP_MASK_RDDSP,
			   (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_RDDSP;
d8547 1
a8547 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_RDDSP;
d8560 3
a8562 3
		  as_warn (_("DSP immediate not in range %ld..%ld (%ld)"),
			   (long) min_range, (long) max_range,
			   (long) imm_expr.X_add_number);
d8564 1
a8564 3
	      imm_expr.X_add_number &= OP_MASK_DSPSFT_7;
	      ip->insn_opcode |= ((unsigned long) imm_expr.X_add_number
				  << OP_SH_DSPSFT_7);
d8577 3
a8579 3
		  as_warn (_("DSP immediate not in range %ld..%ld (%ld)"),
			   (long) min_range, (long) max_range,
			   (long) imm_expr.X_add_number);
d8581 1
a8581 3
	      imm_expr.X_add_number &= OP_MASK_IMM10;
	      ip->insn_opcode |= ((unsigned long) imm_expr.X_add_number
				  << OP_SH_IMM10);
d8586 1
a8586 1
            case '!': /* mt 1-bit unsigned immediate in bit 5 */
d8590 3
a8592 6
		{
		  as_warn (_("MT immediate not in range 0..%d (%lu)"),
			   OP_MASK_MT_U, (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_MT_U;
		}
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_MT_U;
d8597 1
a8597 1
            case '$': /* mt 1-bit unsigned immediate in bit 4 */
d8601 3
a8603 6
		{
		  as_warn (_("MT immediate not in range 0..%d (%lu)"),
			   OP_MASK_MT_H, (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_MT_H;
		}
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_MT_H;
d8614 1
a8614 1
		  ip->insn_opcode |= regno << OP_SH_MTACC_T;
d8627 1
a8627 1
		  ip->insn_opcode |= regno << OP_SH_MTACC_D;
d8834 1
a8834 1
			  ip->insn_opcode |= regno << OP_SH_RT;
d8897 3
a8899 2
	      if ((unsigned long) imm_expr.X_add_number > 1023)
		as_warn (_("Illegal break code (%lu)"),
d8909 3
a8911 2
	      if ((unsigned long) imm_expr.X_add_number > 1023)
		as_warn (_("Illegal lower break code (%lu)"),
d8922 2
a8923 1
		as_warn (_("Illegal 20-bit code (%lu)"),
d8933 1
a8933 1
	      if ((unsigned long) imm_expr.X_add_number >= (1 << 25))
d8937 1
a8937 1
		  imm_expr.X_add_number &= ((1 << 25) - 1);
d8939 1
a8939 1
	      ip->insn_opcode |= imm_expr.X_add_number;
d8948 5
a8952 2
		as_warn (_("Illegal 19-bit code (%lu)"),
			 (unsigned long) imm_expr.X_add_number);
d8974 1
a8974 1
	      ip->insn_opcode |= regno << OP_SH_RD;
d9848 1
a9848 1
			ip->insn_opcode |= lastregno << MIPS16OP_SH_RX;
d9850 1
a9850 1
			ip->insn_opcode |= lastregno << MIPS16OP_SH_RY;
@


1.337
log
@	* config/tc-mipc.c (ISA_HAS_ODD_SINGLE_FPR): New define.
	(mips_oddfpreg_ok): New function.
	(mips_ip): Use it.
-------------------------------------------------------------------
@
text
@d277 2
a278 2
#define ISA_SUPPORT_SMARTMIPS (mips_opts.isa == ISA_MIPS32       \
			       || mips_opts.isa == ISA_MIPS32R2)
d284 3
d291 3
d315 1
a315 1
/*  Return true if ISA supports 64 bit gp register instructions.  */
d323 9
d351 6
d358 1
a358 1
    (mips_opts.gp32 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
d361 1
a361 1
    (mips_opts.fp32 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
d363 2
a364 2
#define HAVE_64BIT_GPRS (! HAVE_32BIT_GPRS)
#define HAVE_64BIT_FPRS (! HAVE_32BIT_FPRS)
d1055 1
a1055 1
  int is_isa;                 /* Is this an ISA?  (If 0, a CPU.) */
d1060 7
d11411 37
a11447 8
  /* ??? GAS treats single-float processors as though they had 64-bit
     float registers (although it complains when double-precision
     instructions are used).  As things stand, saying they have 32-bit
     registers would lead to spurious "register must be even" messages.
     So here we assume float registers are always the same size as
     integer ones, unless the user says otherwise.  */
  if (file_mips_fp32 < 0)
    file_mips_fp32 = file_mips_gp32;
d11466 6
a11471 1
    mips_opts.ase_mips3d = (CPU_HAS_MIPS3D (file_mips_arch)) ? 1 : 0;
d11473 12
a11484 1
    mips_opts.ase_mdmx = (CPU_HAS_MDMX (file_mips_arch)) ? 1 : 0;
d11486 5
a11490 1
    mips_opts.ase_dsp = (CPU_HAS_DSP (file_mips_arch)) ? 1 : 0;
d11492 4
a11495 1
    mips_opts.ase_mt = (CPU_HAS_MT (file_mips_arch)) ? 1 : 0;
d12349 22
d12379 1
a12379 1
      if (!ISA_SUPPORT_SMARTMIPS)
d12395 6
a12400 1
    mips_opts.ase_dsp = 1;
d12404 6
a12409 1
    mips_opts.ase_mt = 1;
d14127 6
d14535 9
a14543 9
  { "mips1",          1,      ISA_MIPS1,      CPU_R3000 },
  { "mips2",          1,      ISA_MIPS2,      CPU_R6000 },
  { "mips3",          1,      ISA_MIPS3,      CPU_R4000 },
  { "mips4",          1,      ISA_MIPS4,      CPU_R8000 },
  { "mips5",          1,      ISA_MIPS5,      CPU_MIPS5 },
  { "mips32",         1,      ISA_MIPS32,     CPU_MIPS32 },
  { "mips32r2",       1,      ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "mips64",         1,      ISA_MIPS64,     CPU_MIPS64 },
  { "mips64r2",       1,      ISA_MIPS64R2,   CPU_MIPS64R2 },
d14546 3
a14548 3
  { "r3000",          0,      ISA_MIPS1,      CPU_R3000 },
  { "r2000",          0,      ISA_MIPS1,      CPU_R3000 },
  { "r3900",          0,      ISA_MIPS1,      CPU_R3900 },
d14551 1
a14551 1
  { "r6000",          0,      ISA_MIPS2,      CPU_R6000 },
d14554 12
a14565 12
  { "r4000",          0,      ISA_MIPS3,      CPU_R4000 },
  { "r4010",          0,      ISA_MIPS2,      CPU_R4010 },
  { "vr4100",         0,      ISA_MIPS3,      CPU_VR4100 },
  { "vr4111",         0,      ISA_MIPS3,      CPU_R4111 },
  { "vr4120",         0,      ISA_MIPS3,      CPU_VR4120 },
  { "vr4130",         0,      ISA_MIPS3,      CPU_VR4120 },
  { "vr4181",         0,      ISA_MIPS3,      CPU_R4111 },
  { "vr4300",         0,      ISA_MIPS3,      CPU_R4300 },
  { "r4400",          0,      ISA_MIPS3,      CPU_R4400 },
  { "r4600",          0,      ISA_MIPS3,      CPU_R4600 },
  { "orion",          0,      ISA_MIPS3,      CPU_R4600 },
  { "r4650",          0,      ISA_MIPS3,      CPU_R4650 },
d14568 13
a14580 13
  { "r8000",          0,      ISA_MIPS4,      CPU_R8000 },
  { "r10000",         0,      ISA_MIPS4,      CPU_R10000 },
  { "r12000",         0,      ISA_MIPS4,      CPU_R12000 },
  { "vr5000",         0,      ISA_MIPS4,      CPU_R5000 },
  { "vr5400",         0,      ISA_MIPS4,      CPU_VR5400 },
  { "vr5500",         0,      ISA_MIPS4,      CPU_VR5500 },
  { "rm5200",         0,      ISA_MIPS4,      CPU_R5000 },
  { "rm5230",         0,      ISA_MIPS4,      CPU_R5000 },
  { "rm5231",         0,      ISA_MIPS4,      CPU_R5000 },
  { "rm5261",         0,      ISA_MIPS4,      CPU_R5000 },
  { "rm5721",         0,      ISA_MIPS4,      CPU_R5000 },
  { "rm7000",         0,      ISA_MIPS4,      CPU_RM7000 },
  { "rm9000",         0,      ISA_MIPS4,      CPU_RM9000 },
d14583 25
a14607 10
  { "4kc",            0,      ISA_MIPS32,     CPU_MIPS32 },
  { "4km",            0,      ISA_MIPS32,     CPU_MIPS32 },
  { "4kp",            0,      ISA_MIPS32,     CPU_MIPS32 },

  /* MIPS32 Release 2 */
  { "m4k",            0,      ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "24k",            0,      ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "24kc",           0,      ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "24kf",           0,      ISA_MIPS32R2,   CPU_MIPS32R2 },
  { "24kx",           0,      ISA_MIPS32R2,   CPU_MIPS32R2 },
d14610 6
a14615 3
  { "5kc",            0,      ISA_MIPS64,     CPU_MIPS64 },
  { "5kf",            0,      ISA_MIPS64,     CPU_MIPS64 },
  { "20kc",           0,      ISA_MIPS64,     CPU_MIPS64 },
d14618 1
a14618 1
  { "sb1",            0,      ISA_MIPS64,     CPU_SB1 },
d14733 1
a14733 1
    if (mips_cpu_info_table[i].is_isa
@


1.336
log
@	* config/tc-mips.h (tc_mips_regname_to_dw2regnum): Declare.
	* config/tc-mipc.c (ABI_NEEDS_64BIT_REGS, ISA_HAS_64BIT_REGS,
	ISA_HAS_DROR, ISA_HAS_ROR): Reformat.
	(regname, RTYPE_MASK, RTYPE_NUM, RTYPE_FPU, RTYPE_FCC, RTYPE_VEC,
	RTYPE_GP, RTYPE_CP0, RTYPE_PC, RTYPE_ACC, RTYPE_CCC, RNUM_MASK,
	RWARN, GENERIC_REGISTER_NUMBERS, FPU_REGISTER_NAMES,
	FPU_CONDITION_CODE_NAMES, COPROC_CONDITION_CODE_NAMES,
	N32N64_SYMBOLIC_REGISTER_NAMES, O32_SYMBOLIC_REGISTER_NAMES,
	SYMBOLIC_REGISTER_NAMES, MIPS16_SPECIAL_REGISTER_NAMES,
	MDMX_VECTOR_REGISTER_NAMES, MIPS_DSP_ACCUMULATOR_NAMES, reg_names,
	reg_names_o32, reg_names_n32n64): Define register classes.
	(reg_lookup): New function, use register classes.
	(md_begin): Reserve register names in the symbol table. Simplify
	OBJ_ELF defines.
	(mips_ip): Fix comment formatting. Handle symbolic COP0 registers.
	Use reg_lookup.
	(mips16_ip): Use reg_lookup.
	(tc_get_register): Likewise.
	(tc_mips_regname_to_dw2regnum): New function.
-------------------------------------------------------------------
@
text
@d329 6
d8218 40
d9123 1
a9123 12
		      && ! (strcmp (str, "mtc1") == 0
			    || strcmp (str, "mfc1") == 0
			    || strcmp (str, "lwc1") == 0
			    || strcmp (str, "swc1") == 0
			    || strcmp (str, "l.s") == 0
			    || strcmp (str, "s.s") == 0
			    || strcmp (str, "mftc1") == 0
			    || strcmp (str, "mfthc1") == 0
			    || strcmp (str, "cftc1") == 0
			    || strcmp (str, "mttc1") == 0
			    || strcmp (str, "mtthc1") == 0
			    || strcmp (str, "cttc1") == 0))
@


1.335
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (macro_build): Test for currently active
	mips16 option.
	(mips16_ip): Reject invalid opcodes.

	[ opcodes/ChangeLog ]
	* mips16-opc.c (I1, I32, I64): New shortcut defines.
	(mips16_opcodes): Change membership of instructions to their
	lowest baseline ISA.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/mips.exp: Run new tests.
	* gas/mips/mips16e.s, gas/mips/mips16e.d, gas/mips/mips16e-64.s,
	gas/mips/mips16e-64.d, gas/mips/mips16e-64.l: New tests.
@
text
@d304 3
a306 3
#define ABI_NEEDS_64BIT_REGS(ABI) \
  ((ABI) == N32_ABI 		  \
   || (ABI) == N64_ABI		  \
d310 6
a315 7
#define ISA_HAS_64BIT_REGS(ISA) (    \
   (ISA) == ISA_MIPS3                \
   || (ISA) == ISA_MIPS4             \
   || (ISA) == ISA_MIPS5             \
   || (ISA) == ISA_MIPS64            \
   || (ISA) == ISA_MIPS64R2          \
   )
d319 2
a320 3
#define ISA_HAS_DROR(ISA) (	\
   (ISA) == ISA_MIPS64R2	\
   )
d324 5
a328 5
#define ISA_HAS_ROR(ISA) (	\
   (ISA) == ISA_MIPS32R2	\
   || (ISA) == ISA_MIPS64R2	\
   || mips_opts.ase_smartmips	\
   )
d1403 291
a1693 2
/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will need.  */
d1780 8
a1787 6
  for (i = 0; i < 32; i++)
    {
      char buf[5];

      sprintf (buf, "$%d", i);
      symbol_table_insert (symbol_new (buf, reg_section, i,
d1789 4
a1792 31
    }
  symbol_table_insert (symbol_new ("$ra", reg_section, RA,
				   &zero_address_frag));
  symbol_table_insert (symbol_new ("$fp", reg_section, FP,
				   &zero_address_frag));
  symbol_table_insert (symbol_new ("$sp", reg_section, SP,
				   &zero_address_frag));
  symbol_table_insert (symbol_new ("$gp", reg_section, GP,
				   &zero_address_frag));
  symbol_table_insert (symbol_new ("$at", reg_section, AT,
				   &zero_address_frag));
  symbol_table_insert (symbol_new ("$kt0", reg_section, KT0,
				   &zero_address_frag));
  symbol_table_insert (symbol_new ("$kt1", reg_section, KT1,
				   &zero_address_frag));
  symbol_table_insert (symbol_new ("$zero", reg_section, ZERO,
				   &zero_address_frag));
  symbol_table_insert (symbol_new ("$pc", reg_section, -1,
				   &zero_address_frag));

  /* If we don't add these register names to the symbol table, they
     may end up being added as regular symbols by operand(), and then
     make it to the object file as undefined in case they're not
     regarded as local symbols.  They're local in o32, since `$' is a
     local symbol prefix, but not in n32 or n64.  */
  for (i = 0; i < 8; i++)
    {
      char buf[6];

      sprintf (buf, "$fcc%i", i);
      symbol_table_insert (symbol_new (buf, reg_section, -1,
a1793 1
    }
d1808 1
a1846 1
#ifdef OBJ_ELF
a1847 1
#endif
a1856 1
#ifdef OBJ_ELF
a1872 1
#endif
a1881 1
#ifdef OBJ_ELF
a1889 1
#endif
d1894 1
d8232 2
d8341 1
d8758 1
a8758 1
		case 'T': /* Coprocessor register */
d8762 1
a8762 1
		case 't': /* Coprocessor register number */
d8896 1
a8896 1
	    case 'P':		/* Performance register */
d8907 14
a8928 1
	    case 'G':		/* coprocessor destination register */
d8934 10
a8943 2
	      s_reset = s;
	      if (s[0] == '$')
a8944 91
		  if (ISDIGIT (s[1]))
		    {
		      ++s;
		      regno = 0;
		      do
			{
			  regno *= 10;
			  regno += *s - '0';
			  ++s;
			}
		      while (ISDIGIT (*s));
		      if (regno > 31)
			as_bad (_("Invalid register number (%d)"), regno);
		    }
		  else if (*args == 'E' || *args == 'G' || *args == 'K')
		    goto notreg;
		  else
		    {
		      if (s[1] == 'r' && s[2] == 'a')
			{
			  s += 3;
			  regno = RA;
			}
		      else if (s[1] == 'f' && s[2] == 'p')
			{
			  s += 3;
			  regno = FP;
			}
		      else if (s[1] == 's' && s[2] == 'p')
			{
			  s += 3;
			  regno = SP;
			}
		      else if (s[1] == 'g' && s[2] == 'p')
			{
			  s += 3;
			  regno = GP;
			}
		      else if (s[1] == 'a' && s[2] == 't')
			{
			  s += 3;
			  regno = AT;
			}
		      else if (s[1] == 'k' && s[2] == 't' && s[3] == '0')
			{
			  s += 4;
			  regno = KT0;
			}
		      else if (s[1] == 'k' && s[2] == 't' && s[3] == '1')
			{
			  s += 4;
			  regno = KT1;
			}
		      else if (s[1] == 'z' && s[2] == 'e' && s[3] == 'r' && s[4] == 'o')
			{
			  s += 5;
			  regno = ZERO;
			}
		      else if (itbl_have_entries)
			{
			  char *p, *n;
			  unsigned long r;

			  p = s + 1; 	/* advance past '$' */
			  n = itbl_get_field (&p);  /* n is name */

			  /* See if this is a register defined in an
			     itbl entry.  */
			  if (itbl_get_reg_val (n, &r))
			    {
			      /* Get_field advances to the start of
				 the next field, so we need to back
				 rack to the end of the last field.  */
			      if (p)
				s = p - 1;
			      else
				s = strchr (s, '\0');
			      regno = r;
			    }
			  else
			    goto notreg;
			}
		      else
			goto notreg;
		    }
		  if (regno == AT
		      && ! mips_opts.noat
		      && *args != 'E'
		      && *args != 'G'
		      && *args != 'K')
		    as_warn (_("Used $at without \".set noat\""));
a9009 1
	    notreg:
d9062 10
d9073 1
a9073 5
	      /* Accept $fN for FP and MDMX register numbers, and in
                 addition accept $vN for MDMX register numbers.  */
	      if ((s[0] == '$' && s[1] == 'f' && ISDIGIT (s[2]))
		  || (is_mdmx != 0 && s[0] == '$' && s[1] == 'v'
		      && ISDIGIT (s[2])))
a9074 13
		  s += 2;
		  regno = 0;
		  do
		    {
		      regno *= 10;
		      regno += *s - '0';
		      ++s;
		    }
		  while (ISDIGIT (*s));

		  if (regno > 31)
		    as_bad (_("Invalid float register number (%d)"), regno);

d9476 4
a9479 1
	      if (strncmp (s, "$fcc", 4) != 0)
a9480 11
	      s += 4;
	      regno = 0;
	      do
		{
		  regno *= 10;
		  regno += *s - '0';
		  ++s;
		}
	      while (ISDIGIT (*s));
	      if (regno > 7)
		as_bad (_("Invalid condition code register $fcc%d"), regno);
d9791 2
a9792 4
	      if (s[0] != '$')
		break;
	      s_reset = s;
	      if (ISDIGIT (s[1]))
d9794 1
a9794 3
		  ++s;
		  regno = 0;
		  do
d9796 6
a9801 3
		      regno *= 10;
		      regno += *s - '0';
		      ++s;
d9803 1
a9803 51
		  while (ISDIGIT (*s));
		  if (regno > 31)
		    {
		      as_bad (_("invalid register number (%d)"), regno);
		      regno = 2;
		    }
		}
	      else
		{
		  if (s[1] == 'r' && s[2] == 'a')
		    {
		      s += 3;
		      regno = RA;
		    }
		  else if (s[1] == 'f' && s[2] == 'p')
		    {
		      s += 3;
		      regno = FP;
		    }
		  else if (s[1] == 's' && s[2] == 'p')
		    {
		      s += 3;
		      regno = SP;
		    }
		  else if (s[1] == 'g' && s[2] == 'p')
		    {
		      s += 3;
		      regno = GP;
		    }
		  else if (s[1] == 'a' && s[2] == 't')
		    {
		      s += 3;
		      regno = AT;
		    }
		  else if (s[1] == 'k' && s[2] == 't' && s[3] == '0')
		    {
		      s += 4;
		      regno = KT0;
		    }
		  else if (s[1] == 'k' && s[2] == 't' && s[3] == '1')
		    {
		      s += 4;
		      regno = KT1;
		    }
		  else if (s[1] == 'z' && s[2] == 'e' && s[3] == 'r' && s[4] == 'o')
		    {
		      s += 5;
		      regno = ZERO;
		    }
		  else
		    break;
d10009 1
a10009 1
		    int freg, reg1, reg2;
d10013 5
a10017 1
		    if (*s != '$')
a10021 15
		    ++s;
		    if (*s != 'f')
		      freg = 0;
		    else
		      {
			freg = 1;
			++s;
		      }
		    reg1 = 0;
		    while (ISDIGIT (*s))
		      {
			reg1 *= 10;
			reg1 += *s - '0';
			++s;
		      }
d10029 2
a10030 4
			if (*s != '$')
			  break;
			++s;
			if (freg)
d10032 2
a10033 14
			    if (*s == 'f')
			      ++s;
			    else
			      {
				as_bad (_("invalid register list"));
				break;
			      }
			  }
			reg2 = 0;
			while (ISDIGIT (*s))
			  {
			    reg2 *= 10;
			    reg2 += *s - '0';
			    ++s;
d10098 1
a10098 1
		    if (*s != '$')
a10102 1
		    ++s;
d10104 3
a10106 8
		    reg1 = 0;
		    while (ISDIGIT (*s))
		      {
			reg1 *= 10;
			reg1 += *s - '0';
			++s;
		      }
		    SKIP_SPACE_TABS (s);
d10112 2
a10113 1
			if (*s != '$')
a10117 8
			++s;
			reg2 = 0;
			while (ISDIGIT (*s))
			  {
			    reg2 *= 10;
			    reg2 += *s - '0';
			    ++s;
			  }
d12874 1
a12874 1
  int reg;
d12877 2
a12878 64
  if (*input_line_pointer++ != '$')
    {
      as_warn (_("expected `$'"));
      reg = ZERO;
    }
  else if (ISDIGIT (*input_line_pointer))
    {
      reg = get_absolute_expression ();
      if (reg < 0 || reg >= 32)
	{
	  as_warn (_("Bad register number"));
	  reg = ZERO;
	}
    }
  else
    {
      if (strncmp (input_line_pointer, "ra", 2) == 0)
	{
	  reg = RA;
	  input_line_pointer += 2;
	}
      else if (strncmp (input_line_pointer, "fp", 2) == 0)
	{
	  reg = FP;
	  input_line_pointer += 2;
	}
      else if (strncmp (input_line_pointer, "sp", 2) == 0)
	{
	  reg = SP;
	  input_line_pointer += 2;
	}
      else if (strncmp (input_line_pointer, "gp", 2) == 0)
	{
	  reg = GP;
	  input_line_pointer += 2;
	}
      else if (strncmp (input_line_pointer, "at", 2) == 0)
	{
	  reg = AT;
	  input_line_pointer += 2;
	}
      else if (strncmp (input_line_pointer, "kt0", 3) == 0)
	{
	  reg = KT0;
	  input_line_pointer += 3;
	}
      else if (strncmp (input_line_pointer, "kt1", 3) == 0)
	{
	  reg = KT1;
	  input_line_pointer += 3;
	}
      else if (strncmp (input_line_pointer, "zero", 4) == 0)
	{
	  reg = ZERO;
	  input_line_pointer += 4;
	}
      else
	{
	  as_warn (_("Unrecognized register name"));
	  reg = ZERO;
	  while (ISALNUM(*input_line_pointer))
	   input_line_pointer++;
	}
    }
d14734 11
@


1.334
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (append_insn): Don't check the range of j or
	jal addresses.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/jal-range.l: Don't check the range of j or jal
	addresses.
@
text
@d3018 1
a3018 1
				| (file_ase_mips16 ? INSN_MIPS16 : 0)
d8035 3
d9473 2
d9477 28
@


1.333
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (append_insn): Only warn about an out-of-range
	j or jal address.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/jal-range.l: Only warn about an out-of-range j or jal
        address.
@
text
@a2417 3
	      if (address_expr->X_add_number & ~0xfffffff)
		as_warn (_("jump address range overflow (0x%lx)"),
			 (unsigned long) address_expr->X_add_number);
a2424 3
	      if (address_expr->X_add_number & ~0xfffffff)
		as_warn (_("jump address range overflow (0x%lx)"),
			 (unsigned long) address_expr->X_add_number);
@


1.332
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (mips_set_options): Add ase_smartmips flag.
	(mips_opts): Likewise.
	(file_ase_smartmips): New variable.
	(ISA_HAS_ROR): SmartMIPS implements rotate instructions.
	(macro_build): Handle SmartMIPS instructions.
	(mips_ip): Likewise.
	(md_longopts): Add argument handling for smartmips.
	(md_parse_options, mips_after_parse_args): Likewise.
	(s_mipsset): Add .set smartmips support.
	(md_show_usage): Document -msmartmips/-mno-smartmips.
	* doc/as.texinfo: Document -msmartmips/-mno-smartmips and
	.set smartmips.
	* doc/c-mips.texi: Likewise.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/smartmips.s, gas/mips/smartmips.d: New smartmips test.
	* gas/mips/mips.exp: Run smartmips test.
@
text
@d2419 2
a2420 2
		as_bad (_("jump address range overflow (0x%lx)"),
			(unsigned long) address_expr->X_add_number);
d2429 2
a2430 2
		as_bad (_("jump address range overflow (0x%lx)"),
			(unsigned long) address_expr->X_add_number);
@


1.331
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (macro_build): Add case 'k' to handle cache
	instruction.
	(macro): Add new case M_CACHE_AB.

	[ opcodes/ChangeLog ]
	* mips-opc.c: Add macro for cache instruction.

	[ include/opcode/ChangeLog ]
	* mips.h (enum): Add macro M_CACHE_AB.
@
text
@d196 1
d249 1
a249 1
  ISA_UNKNOWN, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, CPU_UNKNOWN, FALSE
d273 7
d329 1
d3024 2
a3025 1
				| (file_ase_mips16 ? INSN_MIPS16 : 0)),
d8045 2
a8046 1
			     | (mips_opts.ase_mips3d ? INSN_MIPS3D : 0)),
d10634 4
d10640 1
a10640 1
#define OPTION_COMPAT_ARCH_BASE (OPTION_ASE_BASE + 10)
d10928 8
d11274 1
d12128 9
d14606 3
@


1.330
log
@[ gas/ChangeLog ]
2006-04-30  Thiemo Seufer  <ths@@mips.com>
            David Ung  <davidu@@mips.com>

        * config/tc-mips.c (validate_mips_insn): Handling of udi cases.
        (mips_immed): New table that records various handling of udi
        instruction patterns.
        (mips_ip): Adds udi handling.

[ include/opcode/ChangeLog ]
2006-04-30  Thiemo Seufer  <ths@@mips.com>
            David Ung  <davidu@@mips.com>

        * mips.h: Defines udi bits and masks.  Add description of
        characters which may appear in the args field of udi
        instructions.

[ opcodes/ChangeLog ]
2006-04-30  Thiemo Seufer  <ths@@mips.com>
            David Ung  <davidu@@mips.com>

        * mips-opc.c (mips_builtin_opcodes): Add udi instructions
        "udi0" to "udi15".
        * mips-dis.c (print_insn_args): Adds udi argument handling.
@
text
@d3199 4
d5827 3
d5867 2
@


1.329
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@d7817 4
d7926 16
d8347 28
@


1.328
log
@	Richard Sandiford  <richard@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>
	Phil Edwards  <phil@@codesourcery.com>
	Zack Weinberg  <zack@@codesourcery.com>
	Mark Mitchell  <mark@@codesourcery.com>
	Nathan Sidwell  <nathan@@codesourcery.com>

bfd/
	* bfd-in2.h: Regenerate.
	* config.bfd (mips*-*-vxworks*, mips*el-*-vxworks*): New stanzas.
	* configure.in (bfd_elf32_bigmips_vxworks_vec): New stanza.
	(bfd_elf32_littlemips_vxworks_vec): Likewise.
	(bfd_elf32_bigmips_vec): Add elf-vxworks.lo.
	(bfd_elf32_littlemips_vec): Likewise.
	(bfd_elf32_nbigmips_vec): Likewise.
	(bfd_elf32_nlittlemips_vec): Likewise.
	(bfd_elf32_ntradbigmips_vec): Likewise.
	(bfd_elf32_ntradlittlemips_vec): Likewise.
	(bfd_elf32_tradbigmips_vec): Likewise.
	(bfd_elf32_tradlittlemips_vec): Likewise.
	(bfd_elf64_bigmips_vec): Likewise.
	(bfd_elf64_littlemips_vec): Likewise.
	(bfd_elf64_tradbigmips_vec): Likewise.
	(bfd_elf64_tradlittlemips_vec): Likewise.
	* elf32-mips.c: Include elf-vxworks.h.
	(mips_info_to_howto_rel): Use elf_backend_mips_rtype_to_howto
	instead of calling mips_elf32_rtype_to_howto directly.
	(mips_vxworks_copy_howto_rela): New reloc howto.
	(mips_vxworks_jump_slot_howto_rela): Likewise.
	(mips_vxworks_bfd_reloc_type_lookup): New function.
	(mips_vxworks_rtype_to_howto): Likewise.
	(mips_vxworks_final_write_processing): Likewise.
	(TARGET_LITTLE_SYM, TARGET_LITTLE_NAME): Override for VxWorks.
	(TARGET_BIG_SYM, TARGET_BIG_NAME, elf_bed, ELF_MAXPAGESIZE): Likewise.
	(elf_backend_want_got_plt): Likewise.
	(elf_backend_want_plt_sym): Likewise.
	(elf_backend_got_symbol_offset): Likewise.
	(elf_backend_want_dynbss): Likewise.
	(elf_backend_may_use_rel_p): Likewise.
	(elf_backend_may_use_rela_p): Likewise.
	(elf_backend_default_use_rela_p): Likewise.
	(elf_backend_got_header_size: Likewise.
	(elf_backend_plt_readonly): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Likewise.
	(elf_backend_mips_rtype_to_howto): Likewise.
	(elf_backend_adjust_dynamic_symbol): Likewise.
	(elf_backend_finish_dynamic_symbol): Likewise.
	(bfd_elf32_bfd_link_hash_table_create): Likewise.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_link_output_symbol_hook): Likewise.
	(elf_backend_emit_relocs): Likewise.
	(elf_backend_final_write_processing: Likewise.
	(elf_backend_additional_program_headers): Likewise.
	(elf_backend_modify_segment_map): Likewise.
	(elf_backend_symbol_processing): Likewise.
	* elfxx-mips.c: Include elf-vxworks.h.
	(mips_elf_link_hash_entry): Add is_relocation_target and
	is_branch_target fields.
	(mips_elf_link_hash_table): Add is_vxworks, srelbss, sdynbss, srelplt,
	srelplt2, sgotplt, splt, plt_header_size and plt_entry_size fields.
	(MIPS_ELF_RELA_SIZE, MIPS_ELF_REL_DYN_NAME): New macros.
	(MIPS_RESERVED_GOTNO): Take a mips_elf_link_hash_table argument.
	Return 3 for VxWorks.
	(ELF_MIPS_GP_OFFSET): Change the argument from a bfd to a
	mips_elf_link_hash_table.  Return 0 for VxWorks.
	(MIPS_ELF_GOT_MAX_SIZE): Change the argument from a bfd to a
	mips_elf_link_hash_table.  Update the call to ELF_MIPS_GP_OFFSET.
	(mips_vxworks_exec_plt0_entry): New variable.
	(mips_vxworks_exec_plt_entry): Likewise.
	(mips_vxworks_shared_plt0_entry): Likewise.
	(mips_vxworks_shared_plt_entry): Likewise.
	(mips_elf_link_hash_newfunc): Initialize the new hash_entry fields.
	(mips_elf_rel_dyn_section): Change the bfd argument to a
	mips_elf_link_hash_table.  Use MIPS_ELF_REL_DYN_NAME to get
	the name of the section.
	(mips_elf_initialize_tls_slots): Update the call to
	mips_elf_rel_dyn_section.
	(mips_elf_gotplt_index): New function.
	(mips_elf_local_got_index): Add an input_section argument.
	Update the call to mips_elf_create_local_got_entry.
	(mips_elf_got_page): Likewise.
	(mips_elf_got16_entry): Likewise.
	(mips_elf_create_local_got_entry): Add bfd_link_info and input_section
	arguments.  Create dynamic relocations for each entry on VxWorks.
	(mips_elf_merge_gots): Update the use of MIPS_ELF_GOT_MAX_SIZE.
	(mips_elf_multi_got): Update the uses of MIPS_ELF_GOT_MAX_SIZE
	and MIPS_RESERVED_GOTNO.
	(mips_elf_create_got_section): Update the uses of
	MIPS_ELF_GOT_MAX_SIZE.  Create .got.plt on VxWorks.
	(is_gott_symbol): New function.
	(mips_elf_calculate_relocation): Use a dynobj local variable.
	Update the calls to mips_elf_local_got_index, mips_elf_got16_entry and
	mips_elf_got_page_entry.  Set G to the .got.plt entry when calculating
	VxWorks R_MIPS_CALL* relocations.  Calculate and use G for all GOT
	relocations on VxWorks.  Add dynamic relocations for references
	to the VxWorks __GOTT_BASE__ and __GOTT_INDEX__ symbols.  Don't
	create dynamic relocations for R_MIPS_32, R_MIPS_REL32 or R_MIPS_64
	in VxWorks executables.
	(mips_elf_allocate_dynamic_relocations): Add a bfd_link_info argument.
	Use MIPS_ELF_RELA_SIZE to calculate the size of a VxWorks entry.
	Don't allocate a null entry on VxWorks.
	(mips_elf_create_dynamic_relocation): Update the call to
	mips_elf_rel_dyn_section.  Use absolute rather than relative
	relocations for VxWorks, and make them RELA rather than REL.
	(_bfd_mips_elf_create_dynamic_sections): Don't make .dynamic
	read-only on VxWorks.  Update the call to mips_elf_rel_dyn_section.
	Create the .plt, .rela.plt, .dynbss and .rela.bss sections on
	VxWorks.  Likewise create the _PROCEDURE_LINKAGE_TABLE symbol.
	Call elf_vxworks_create_dynamic_sections for VxWorks and
	initialize the plt_header_size and plt_entry_size fields.
	(_bfd_mips_elf_check_relocs): Don't allow GOT relocations to be
	used in VxWorks executables.  Don't allocate dynamic relocations
	for R_MIPS_32, R_MIPS_REL32 or R_MIPS_64 in VxWorks executables.
	Set is_relocation_target for each symbol referenced by a relocation.
	Allocate .rela.dyn entries for relocations against the special
	VxWorks __GOTT_BASE__ and __GOTT_INDEX__ symbols.  Create GOT
	entries for all VxWorks R_MIPS_GOT16 relocations.  Don't allocate
	a global GOT entry for symbols mentioned in VxWorks R_MIPS_CALL*,
	R_MIPS_32, R_MIPS_REL32 or R_MIPS_64 relocations.  Update the calls
	to mips_elf_rel_dyn_section and mips_elf_allocate_dynamic_relocations.
	Set is_branch_target for symbols mentioned in R_MIPS_PC16 or R_MIPS_26
	relocations.  Don't set no_fn_stub on VxWorks.
	(_bfd_mips_elf_adjust_dynamic_symbol): Update the call to
	mips_elf_allocate_dynamic_relocations.
	(_bfd_mips_vxworks_adjust_dynamic_symbol): New function.
	(_bfd_mips_elf_always_size_sections): Do not allocate GOT page
	entries for VxWorks, and do not create multiple GOTs.
	(_bfd_mips_elf_size_dynamic_sections): Use MIPS_ELF_REL_DYN_NAME.
	Handle .got specially for VxWorks.  Update the uses of
	MIPS_RESERVED_GOTNO and mips_elf_allocate_dynamic_relocations.
	Check for sgotplt and splt.  Allocate the .rel(a).dyn contents last,
	once its final size is known.  Set DF_TEXTREL for VxWorks.  Add
	DT_RELA, DT_RELASZ, DT_RELAENT, DT_PLTREL, DT_PLTRELSZ and DT_JMPREL
	tags on VxWorks.  Do not add the MIPS-specific tags for VxWorks.
	(_bfd_mips_vxworks_finish_dynamic_symbol): New function.
	(mips_vxworks_finish_exec_plt): Likewise.
	(mips_vxworks_finish_shared_plt): Likewise.
	(_bfd_mips_elf_finish_dynamic_sections): Remove an unncessary call
	to mips_elf_rel_dyn_section.  Use a VxWorks-specific value of
	DT_PLTGOT.  Handle DT_RELA, DT_RELASZ, DT_RELAENT, DT_PLTREL,
	DT_PLTRELSZ and DT_JMPREL.  Update the uses of MIPS_RESERVED_GOTNO
	and mips_elf_rel_dyn_section.  Use a different GOT header for
	VxWorks.  Don't sort .rela.dyn on VxWorks.  Finish the PLT on VxWorks.
	(_bfd_mips_elf_link_hash_table_create): Initialize the new
	mips_elf_link_hash_table fields.
	(_bfd_mips_vxworks_link_hash_table_create): New function.
	(_bfd_mips_elf_final_link): Set the GP value to _GLOBAL_OFFSET_TABLE_
	on VxWorks.  Update the call to ELF_MIPS_GP_OFFSET.
	* elfxx-mips.h (_bfd_mips_vxworks_adjust_dynamic_symbol): Declare.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_vxworks_link_hash_table_create): Likewise.
	* libbfd.h: Regenerate.
	* Makefile.am (elfxx-mips.lo): Depend on elf-vxworks.h.
	(elf32-mips.lo): Likewise.
	* Makefile.in: Regenerate.
	* reloc.c (BFD_RELOC_MIPS_COPY, BFD_RELOC_MIPS_JUMP_SLOT): Declare.
	* targets.c (bfd_elf32_bigmips_vxworks_vec): Declare.
	(bfd_elf32_littlemips_vxworks_vec): Likewise.
	(_bfd_target_vector): Add entries for them.

gas/
	* config/tc-mips.c (mips_target_format): Handle vxworks targets.
	(md_begin): Complain about -G being used for PIC.  Don't change
	the text, data and bss alignments on VxWorks.
	(reloc_needs_lo_p): Don't return true for R_MIPS_GOT16 when
	generating VxWorks PIC.
	(load_address): Extend SVR4_PIC handling to VXWORKS_PIC.
	(macro): Likewise, but do not treat la $25 specially for
	VxWorks PIC, and do not handle jal.
	(OPTION_MVXWORKS_PIC): New macro.
	(md_longopts): Add -mvxworks-pic.
	(md_parse_option): Don't complain about using PIC and -G together here.
	Handle OPTION_MVXWORKS_PIC.
	(md_estimate_size_before_relax): Always use the first relaxation
	sequence on VxWorks.
	* config/tc-mips.h (VXWORKS_PIC): New.

gas/testsuite/
	* gas/mips/vxworks1.s, gas/mips/vxworks1.d,
	* gas/mips/vxworks1-xgot.d: New tests.
	* gas/mips/mips.exp: Run them.  Do not run other tests on VxWorks.

include/elf/
	* mips.h (R_MIPS_COPY, R_MIPS_JUMP_SLOT): New relocs.

ld/
	* configure.tgt (mips*el-*-vxworks*, mips*-*-vxworks*): Use
	separate VxWorks emulations.
	* emulparams/elf32ebmipvxworks.sh: New file.
	* emulparams/elf32elmipvxworks.sh: New file.
	* Makefile.am (ALL_EMULATIONS): Add eelf32ebmipvxworks.o and
	eelf32elmipvxworks.o.
	(eelf32ebmipvxworks.c, eelf32elmipvxworks.c): New rules.
	* Makefile.in: Regenerate.

ld/testsuite/
	* ld-mips/vxworks1.dd, ld-mips/vxworks1.ld, ld-mips/vxworks1-lib.dd,
	* ld-mips/vxworks1-lib.nd, ld-mips/vxworks1-lib.rd,
	* ld-mips/vxworks1-lib.s, ld-mips/vxworks1.rd, ld-mips/vxworks1.s,
	* ld-mips/vxworks1-static.d, ld-mips/vxworks2.s, ld-mips/vxworks2.sd,
	* ld-mips/vxworks2-static.sd: New tests.
	* ld-mips/mips-elf.exp: Run them.
@
text
@d153 1
a153 1
  /* True if this instruction occured in a .set noreorder block.  */
d11812 1
a11812 1
     means that, for backwards compatibiltiy, the special_section entries
@


1.328.2.1
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (append_insn): Don't check the range of j or
	jal addresses.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/jal-range.l: Don't check the range of j or jal
	addresses.
@
text
@d2409 3
d2419 3
@


1.327
log
@bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf32_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elf64-mips.c (mips_elf64_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(mips_elf64_howto_table_rela): Likewise.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf64_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elfn32-mips.c (elf_mips_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(elf_mips_howto_table_rela): Likewise.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf32_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elfxx-mips.c: Formatting fixes.
	(mips_elf_calculate_relocation): Handle R_MIPS_GNU_REL16_S2
	and R_MIPS_PC16 identically.
gas/
	* config/tc-mips.c (append_insn): Handle BFD_RELOC_16_PCREL_S2.
	(macro_build): Complain for invalid branch displacements.
	(mips_validate_fix): Delete.
	(md_apply_fix): Re-add pcrel support for branches.  Use consistent
	text for misaligned branch targets.
	(tc_gen_reloc: Re-add pcrel support for branches.  Handle strange
	BFD pcrel processing.  Remove error for unresolved branches.
	* config/tc-mips.h (TC_VALIDATE_FIX, mips_validate_fix): Delete.
gas/testsuite/
	* gas/mips/bge.d, gas/mips/bge.s, gas/mips/bgeu.d, gas/mips/bgeu.s,
	gas/mips/blt.d, gas/mips/blt.s, gas/mips/bltu.d,
	gas/mips/bltu.s: Reactivate external branch tests.
	* gas/mips/branch-misc-2.d, gas/mips/branch-misc-2pic.d,
	gas/mips/branch-misc-2-64.d, gas/mips/branch-misc-2pic-64.d: New
	tests.
	* gas/mips/branch-misc-2.l, gas/mips/branch-misc-2pic.l,
	gas/testsuite/gas/mips/branch-misc-2pic.s: Remove.
	* gas/mips/mips.exp: Adjust branch-misc-2 tests.  Add 64-bit
	variants.
@
text
@d1194 6
d1406 7
d1540 5
a1544 4
      /* On a native system, sections must be aligned to 16 byte
	 boundaries.  When configured for an embedded ELF target, we
	 don't bother.  */
      if (strcmp (TARGET_OS, "elf") != 0)
d1697 2
a1698 2
   Note that R_MIPS_GOT16 relocations only need a matching %lo() when
   applied to local symbols.  */
d1705 4
a1708 2
	      || reloc == BFD_RELOC_MIPS_GOT16
	      || reloc == BFD_RELOC_MIPS16_HI16_S));
d3917 1
a3917 1
  else if (mips_pic == SVR4_PIC && ! mips_big_got)
d3978 1
a3978 1
  else if (mips_pic == SVR4_PIC)
d5030 1
a5030 1
      else if (mips_pic == SVR4_PIC && ! mips_big_got && ! HAVE_NEWABI)
d5066 3
a5068 1
	      if (breg == 0 && (call || tempreg == PIC_CALL_REG))
d5125 1
a5125 1
      else if (mips_pic == SVR4_PIC && ! mips_big_got && HAVE_NEWABI)
d5228 1
a5228 1
      else if (mips_pic == SVR4_PIC && ! HAVE_NEWABI)
d5385 1
a5385 1
      else if (mips_pic == SVR4_PIC && HAVE_NEWABI)
d5518 1
a5518 1
      else if (mips_pic == SVR4_PIC)
d5524 1
a5524 1
	  if (! HAVE_NEWABI)
a5549 2
      else
	abort ();
d5685 2
d6047 1
a6047 1
      else if (mips_pic == SVR4_PIC && ! mips_big_got)
d6101 1
a6101 1
      else if (mips_pic == SVR4_PIC && ! HAVE_NEWABI)
d6150 1
a6150 1
      else if (mips_pic == SVR4_PIC && HAVE_NEWABI)
d6270 1
a6270 1
      else if (mips_pic == SVR4_PIC)
a6275 2
      else
	abort ();
d6347 1
a6347 1
	  if (mips_pic == SVR4_PIC)
d6566 1
a6566 1
      else if (mips_pic == SVR4_PIC && ! mips_big_got)
d6613 1
a6613 1
      else if (mips_pic == SVR4_PIC)
d10665 2
a10907 6
      if (g_switch_seen && g_switch_value != 0)
	{
	  as_bad (_("-G may not be used with SVR4 PIC code"));
	  return 0;
	}
      g_switch_value = 0;
a10930 5
      if (mips_pic == SVR4_PIC && g_switch_value != 0)
	{
	  as_bad (_("-G may not be used with SVR4 PIC code"));
	  return 0;
	}
d11036 4
d13180 3
@


1.327.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a1193 6
#ifdef TE_VXWORKS
      if (!HAVE_64BIT_OBJECTS && !HAVE_NEWABI)
	return (target_big_endian
		? "elf32-bigmips-vxworks"
		: "elf32-littlemips-vxworks");
#endif
a1399 7
  if (mips_pic != NO_PIC)
    {
      if (g_switch_seen && g_switch_value != 0)
	as_bad (_("-G may not be used in position-independent code"));
      g_switch_value = 0;
    }

d1527 4
a1530 5
      /* On a native system other than VxWorks, sections must be aligned
	 to 16 byte boundaries.  When configured for an embedded ELF
	 target, we don't bother.  */
      if (strcmp (TARGET_OS, "elf") != 0
	  && strcmp (TARGET_OS, "vxworks") != 0)
d1683 2
a1684 2
   This is only "might" because SVR4 R_MIPS_GOT16 relocations only
   need a matching %lo() when applied to local symbols.  */
d1691 2
a1692 4
	      || reloc == BFD_RELOC_MIPS16_HI16_S
	      /* VxWorks R_MIPS_GOT16 relocs never need a matching %lo();
		 all GOT16 relocations evaluate to "G".  */
	      || (reloc == BFD_RELOC_MIPS_GOT16 && mips_pic != VXWORKS_PIC)));
d2393 3
d2403 3
d3901 1
a3901 1
  else if (!mips_big_got)
d3962 1
a3962 1
  else if (mips_big_got)
d5014 1
a5014 1
      else if (!mips_big_got && !HAVE_NEWABI)
d5050 1
a5050 3
	      if (mips_pic == SVR4_PIC
		  && breg == 0
		  && (call || tempreg == PIC_CALL_REG))
d5107 1
a5107 1
      else if (!mips_big_got && HAVE_NEWABI)
d5210 1
a5210 1
      else if (mips_big_got && !HAVE_NEWABI)
d5367 1
a5367 1
      else if (mips_big_got && HAVE_NEWABI)
d5500 1
a5500 1
      else
d5506 1
a5506 1
	  if (mips_pic == SVR4_PIC && !HAVE_NEWABI)
d5532 2
a5668 2
      else if (mips_pic == VXWORKS_PIC)
	as_bad (_("Non-PIC jump used in PIC library"));
d6029 1
a6029 1
      else if (!mips_big_got)
d6083 1
a6083 1
      else if (mips_big_got && !HAVE_NEWABI)
d6132 1
a6132 1
      else if (mips_big_got && HAVE_NEWABI)
d6252 1
a6252 1
      else
d6258 2
d6331 1
a6331 1
	  if (mips_pic != NO_PIC)
d6550 1
a6550 1
      else if (!mips_big_got)
d6597 1
a6597 1
      else if (mips_big_got)
a10648 2
#define OPTION_MVXWORKS_PIC (OPTION_ELF_BASE + 11)
  {"mvxworks-pic", no_argument, NULL, OPTION_MVXWORKS_PIC},
d10890 6
d10919 5
a11028 4

    case OPTION_MVXWORKS_PIC:
      mips_pic = VXWORKS_PIC;
      break;
a13168 3
  else if (mips_pic == VXWORKS_PIC)
    /* For vxworks, GOT16 relocations never have a corresponding LO16.  */
    change = 0;
@


1.326
log
@        * mips.h: Assign 'm'/'M' codes to MIPS16e save/restore
        instructions.  Define MIPS16_ALL_ARGS and MIPS16_ALL_STATICS for
        save/restore encoding of the args field.

        * mips16-opc.c: Add MIPS16e save/restore opcodes.
        * mips-dis.c (print_mips16_insn_arg): Handle printing of 'm'/'M'
        codes for save/restore.

        * config/tc-mips.c (mips16_ip): Add handling of 'm' and 'M' codes
        for the MIPS16e save/restore instructions.

        * gas/mips/mips.exp: Run new save/restore tests.
        * gas/testsuite/gas/mips/mips16e-save.s: New test for generating
        different styles of save/restore instructions.
        * gas/testsuite/gas/mips/mips16e-save.d: New.
@
text
@d2413 10
a2422 1
	      goto need_reloc;
d3151 1
d3155 3
a3157 3
	   * Note that the expression still might come from the assembly
	   * input, in which case the value is not checked for range nor
	   * is a relocation entry generated (yuck).
d3161 6
a11379 77
/* This hook is called before a fix is simplified.  We don't really
   decide whether to skip a fix here.  Rather, we turn global symbols
   used as branch targets into local symbols, such that they undergo
   simplification.  We can only do this if the symbol is defined and
   it is in the same section as the branch.  If this doesn't hold, we
   emit a better error message than just saying the relocation is not
   valid for the selected object format.

   FIXP is the fix-up we're going to try to simplify, SEG is the
   segment in which the fix up occurs.  The return value should be
   non-zero to indicate the fix-up is valid for further
   simplifications.  */

int
mips_validate_fix (struct fix *fixP, asection *seg)
{
  /* There's a lot of discussion on whether it should be possible to
     use R_MIPS_PC16 to represent branch relocations.  The outcome
     seems to be that it can, but gas/bfd are very broken in creating
     RELA relocations for this, so for now we only accept branches to
     symbols in the same section.  Anything else is of dubious value,
     since there's no guarantee that at link time the symbol would be
     in range.  Even for branches to local symbols this is arguably
     wrong, since it we assume the symbol is not going to be
     overridden, which should be possible per ELF library semantics,
     but then, there isn't a dynamic relocation that could be used to
     this effect, and the target would likely be out of range as well.

     Unfortunately, it seems that there is too much code out there
     that relies on branches to symbols that are global to be resolved
     as if they were local, like the IRIX tools do, so we do it as
     well, but with a warning so that people are reminded to fix their
     code.  If we ever get back to using R_MIPS_PC16 for branch
     targets, this entire block should go away (and probably the
     whole function).  */

  if (fixP->fx_r_type == BFD_RELOC_16_PCREL_S2
      && ((OUTPUT_FLAVOR == bfd_target_ecoff_flavour
	   || OUTPUT_FLAVOR == bfd_target_elf_flavour)
	  || bfd_reloc_type_lookup (stdoutput, BFD_RELOC_16_PCREL_S2) == NULL)
      && fixP->fx_addsy)
    {
      if (! S_IS_DEFINED (fixP->fx_addsy))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("Cannot branch to undefined symbol."));
	  /* Avoid any further errors about this fixup.  */
	  fixP->fx_done = 1;
	}
      else if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("Cannot branch to symbol in another section."));
	  fixP->fx_done = 1;
	}
      else if (S_IS_EXTERNAL (fixP->fx_addsy))
	{
	  symbolS *sym = fixP->fx_addsy;

	  if (mips_pic == SVR4_PIC)
	    as_warn_where (fixP->fx_file, fixP->fx_line,
			   _("Pretending global symbol used as branch target is local."));

	  fixP->fx_addsy = symbol_create (S_GET_NAME (sym),
					  S_GET_SEGMENT (sym),
					  S_GET_VALUE (sym),
					  symbol_get_frag (sym));
	  copy_symbol_attributes (fixP->fx_addsy, sym);
	  S_CLEAR_EXTERNAL (fixP->fx_addsy);
	  assert (symbol_resolved_p (sym));
	  symbol_mark_resolved (fixP->fx_addsy);
	}
    }

  return 1;
}

d11404 1
a11404 1
  assert (! fixP->fx_pcrel);
d11416 1
a11416 1
  if (fixP->fx_addsy == NULL && fixP->fx_tcbit == 0)
a11460 1
      assert (! fixP->fx_pcrel);
d11530 1
a11530 1
		      _("Branch to odd address (%lx)"), (long) *valP);
d13248 18
a13265 2
  assert (! fixp->fx_pcrel);
  reloc->addend = fixp->fx_addnumber;
d13277 1
a13277 12
  /* To support a PC relative reloc, we used a Cygnus extension.
     We check for that here to make sure that we don't let such a
     reloc escape normally.  (FIXME: This was formerly used by
     embedded-PIC support, but is now used by branch handling in
     general.  That probably should be fixed.)  */
  if ((OUTPUT_FLAVOR == bfd_target_ecoff_flavour
       || OUTPUT_FLAVOR == bfd_target_elf_flavour)
      && code == BFD_RELOC_16_PCREL_S2)
    reloc->howto = NULL;
  else
    reloc->howto = bfd_reloc_type_lookup (stdoutput, code);

d13354 1
a13354 2
			      4, &exp, 1,
			      BFD_RELOC_16_PCREL_S2);
@


1.325
log
@	* config/tc-mips.c (md_parse_option): Fix typo in comment.
@
text
@d9306 2
d9841 178
@


1.324
log
@* config/tc-mips.c (append_insn): Convert MIPS16 jr/jalr jumps
into jrc/jalrc versions if ISA_MIPS32+ and not doing the swap,
hence avoiding to emit a nop.

* gas/mips/mips.exp: Run new test.
* gas/testsuite/gas/mips/mips16e-jrc.s: New test for converting
jalr/jr to the compact jalrc/jrc instructions.
* gas/testsuite/gas/mips/mips16e-jrc.d: New.
@
text
@d10712 2
a10713 2
      /* The -xgot option tells the assembler to use 32 offsets when
         accessing the got in SVR4_PIC mode.  It is for Irix
@


1.323
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d2696 23
a2718 6
	      /* We could do even better for unconditional branches to
		 portions of this object file; we could pick up the
		 instruction at the destination, put it in the delay
		 slot, and bump the destination address.  */
	      insert_into_history (0, 1, ip);
	      emit_nop ();
@


1.322
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d2315 1
a2315 1
    {     
a8549 1

@


1.321
log
@* config/tc-mips.c (append_insn): Undo last change.  Instead add
guard to suppress calling frag_grow if the current instruction is
one that allows a delay slot.
@
text
@d13597 4
@


1.320
log
@* config/tc-mips.c (mips_set_options): Add ase_mt for MT instructions.
(mips_opts): Add -1 to initialize ase_mt.
(file_ase_mt): New variable for -mmt.
(CPU_HAS_MT): New define.
(validate_mips_insn): Add supports for +t, +T, !, $, *, &, g operand
formats.
(mips_ip): Check ase_mt to enable MT instructions.
Handle !, $, *, &, +T, +t, g operand formats.
For "mftc1", "mfthc1", "cftc1", "mttc1", "mtthc1", "cttc1", we allow
odd float registers.
(OPTION_MT, OPTION_NO_MT): New define.
(OPTION_COMPAT_ARCH_BASE): Change because of inserting MT define.
(md_parse_option): Parse OPTION_MT and OPTION_NO_MT.
(mips_after_parse_args): Set ase_mt based on CPU.
(s_mipsset): Handle ".set mt" and ".set nomt".
(mips_elf_final_processing): Remind of adding new flag for MT ASE.
(md_show_usage): Show usage of -mmt and -mno-mt.
* doc/as.texinfo: Document -mmt and -mno-mt options.
* doc/c-mips.texi: Likewise, and document ".set mt" and ".set nomt"
directives.
@
text
@d2315 5
a2319 4
    {
      /* Make sure there is enough room to swap this instruction with
         a following jump instruction.  */
      frag_grow (6);
d2711 3
a2713 16
		  if (delay.frag == ip->frag)
		    {
		      move_insn (ip, delay.frag, delay.where);
		      move_insn (&delay, ip->frag, delay.where 
				 + insn_length (ip));
		    }
		  else if (insn_length (ip) == insn_length (&delay))
		    {
		      move_insn (&delay, ip->frag, ip->where);
		      move_insn (ip, history[0].frag, history[0].where);
		    }
		  else
		    {
		      add_fixed_insn (NOP_INSN);
		      delay = *NOP_INSN;
		    }
@


1.319
log
@* config/tc-mips.c (append_insn): Correctly handle mips16 case
when the frags are different for the 2 instructions we want to
swap.  If the lengths of the 2 instructions are not the same, we
won't do the swap but emit an nop.
@
text
@d197 1
d248 1
a248 1
  ISA_UNKNOWN, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, CPU_UNKNOWN, FALSE
d276 4
d382 4
d7790 3
d7865 5
d7968 1
d8190 54
d8396 28
d8558 1
d8683 1
d8799 7
a8805 1
			    || strcmp (str, "s.s") == 0))
d10346 4
d10352 1
a10352 1
#define OPTION_COMPAT_ARCH_BASE (OPTION_ASE_BASE + 8)
d10612 8
d10976 2
d10984 1
d11926 4
d13666 2
d14375 3
@


1.318
log
@* config/tc-mips.c (mips_set_options): Add ase_dsp for DSP instructions.
(mips_opts): Add -1 to initialize ase_dsp.
(file_ase_dsp): New variable for -mdsp.
(CPU_HAS_DSP): New define.
(validate_mips_insn): Add supports for 3, 4, 5, 6, 7, 8, 9, 0, ', :, @@
operand formats.
(mips_ip): Add min_range and max_range for checking singed numbers.
Check ase_dsp to enable DSP instructions.
Handle 3, 4, 5, 6, 7, 8, 9, 0, ', :, @@ operand formats.
(OPTION_DSP, OPTION_NO_DSP): New define.
(OPTION_COMPAT_ARCH_BASE): Change because of inserting DSP define.
(md_parse_option): Parse OPTION_DSP and OPTION_NO_DSP.
(mips_after_parse_args): Set ase_dsp based on CPU.
(s_mipsset): Handle ".set dsp" and ".set nodsp".
(mips_elf_final_processing): Remind of adding new flag for DSP ASE.
(md_show_usage): Show usage of -mdsp and -mno-dsp.
@
text
@d2701 16
a2716 3
		  know (delay.frag == ip->frag);
		  move_insn (ip, delay.frag, delay.where);
		  move_insn (&delay, ip->frag, ip->where + insn_length (ip));
@


1.317
log
@* config/tc-mips.c (mips_cpu_info_table): Add 5kf to the table of
cpu names.
@
text
@d196 1
d247 1
a247 1
  ISA_UNKNOWN, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, CPU_UNKNOWN, FALSE
d271 4
d373 4
d7829 11
d7874 1
d7937 1
d7990 169
d10221 4
d10227 1
a10227 1
#define OPTION_COMPAT_ARCH_BASE (OPTION_ASE_BASE + 6)
d10479 8
d10841 2
d10848 1
d11786 4
d13524 2
d14230 3
@


1.316
log
@	* config/tc-mips.c (s_mips_globl): Allow multiple symbols per .globl.
@
text
@d13805 1
@


1.315
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d11410 19
a11428 5
  name = input_line_pointer;
  c = get_symbol_end ();
  symbolP = symbol_find_or_make (name);
  *input_line_pointer = c;
  SKIP_WHITESPACE ();
d11430 6
a11435 3
  /* On Irix 5, every global symbol that is not explicitly labelled as
     being a function is apparently labelled as being an object.  */
  flag = BSF_OBJECT;
d11437 3
a11439 4
  if (! is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *secname;
      asection *sec;
d11441 1
a11441 6
      secname = input_line_pointer;
      c = get_symbol_end ();
      sec = bfd_get_section_by_name (stdoutput, secname);
      if (sec == NULL)
	as_bad (_("%s: no such section"), secname);
      *input_line_pointer = c;
d11443 8
a11450 2
      if (sec != NULL && (sec->flags & SEC_CODE) != 0)
	flag = BSF_FUNCTION;
d11452 1
a11453 3
  symbol_get_bfdsym (symbolP)->flags |= flag;

  S_SET_EXTERNAL (symbolP);
@


1.314
log
@* config/tc-mips.c (mips_cpu_info_table): Add cpu names m4k, 24k,
24kc, 24kf and 24kfx under MIPS32 release 2.
@
text
@d10699 1
a10699 1
   the corresponding LO16 reloc.  This is called before md_apply_fix3 and
d10918 1
a10918 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.313
log
@gas/:
* config/tc-mips.c (load_register): Add leading "0x" to the
output of sprintf_vma().
(macro): Likewise.

gas/testsuite/:
* gas/mips/ldstla-32-1.l: Update to handle leading zeroes.
* gas/mips/ldstla-32-mips3-1.l: Likewise.
@
text
@d13781 7
@


1.312
log
@Update the address and phone number of the FSF
@
text
@d3561 1
a3561 1
      as_bad (_("Number (%s) larger than 32 bits"), value);
d5808 1
a5808 1
	  as_bad (_("Number (%s) larger than 32 bits"), value);
d6402 1
a6402 1
	  as_bad (_("Number (%s) larger than 32 bits"), value);
@


1.311
log
@(macro): Use sprintf_vma to convert a > 32 bit number into a readable string.
(load_register): Likewise.
@
text
@d23 2
a24 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.310
log
@* config/tc-mips.c (normalize_constant_expr): Don't check for
HAVE_32BIT_GPRS.
(check_absolute_expr): Only call normalize_constant_expr() if
HAVE_32BIT_GPRS.
(mips_ip): Likewise.

* config/tc-mips.c (check_absolute_expr): Fix formatting.
@
text
@d3558 4
a3561 3
      as_bad (_("Number (0x%lx%08lx) larger than 32 bits"),
	      (unsigned long) (ep->X_add_number >> 32),
	      (unsigned long) (ep->X_add_number & 0xffffffff));
d5804 6
a5809 3
	as_bad (_("Number (0x%lx%08lx) larger than 32 bits"),
		(unsigned long) (offset_expr.X_add_number >> 32),
		(unsigned long) (offset_expr.X_add_number & 0xffffffff));
d6398 6
a6403 3
	as_bad (_("Number (0x%lx%08lx) larger than 32 bits"),
		(unsigned long) (offset_expr.X_add_number >> 32),
		(unsigned long) (offset_expr.X_add_number & 0xffffffff));
@


1.309
log
@* config/tc-mips.c (normalize_constant_expr): Fix formatting.
@
text
@d3268 1
a3268 1
  if ((ex->X_op == O_constant && HAVE_32BIT_GPRS)
d3428 2
a3429 1
    as_bad (_("Instruction %s requires absolute expression"), ip->insn_mo->name);
d3431 2
a3432 1
  normalize_constant_expr (ex);
d8108 2
a8109 1
		  normalize_constant_expr (&imm2_expr);
d8577 2
a8578 1
	      normalize_constant_expr (&imm_expr);
@


1.308
log
@* config/tc-mips.c (macro) [ldd_std]: Don't attempt the GP
optimization for constant addresses.
@
text
@a3260 1
static void
d3265 1
@


1.307
log
@gas/:
* config/tc-mips.c (IS_ZEXT_32BIT_NUM): New macro.
(normalize_address_expr): New function to sign-extend address
offsets that fit into 32 bits in 32-bit mode.
(macro_build_ldst_constoffset): Use normalize_address_expr()
instead of a handcoded sequence.
(load_register): Likewise.  Report oversized numbers in a useful
way.
(macro) [ld_st, ldd_std]: Reject all oversized offsets, not only
for constant addresses.  Report oversized numbers in a useful way.
(mips_ip): Use normalize_address_expr() for addresses.

gas/testsuite/:
* gas/mips/ldstla-32.s: Exclude offsets that are now meant to fail
and include more instructions/offsets that are meant to succeed.
Use $4 instead $3 to avoid register dependencies.
* gas/mips/ldstla-32.d: Update accordingly.
* gas/mips/ldstla-32-shared.d: Likewise.
* gas/mips/ldstla-32-mips3.d: New test based on the above, except
for mips3.
* gas/mips/ldstla-32-mips3-shared.d: Similarly, for PIC.
* gas/mips/ldstla-32-mips3.s: Source for the new tests.
* gas/mips/ldstla-32-1.s: New test for offsets that are meant to
fail.
* gas/mips/ldstla-32-mips3-1.s: Likewise, for mips3.
* gas/mips/ldstla-32-1.l: Stderr output for the new test.
* gas/mips/ldstla-32-mips3-1.l: Likewise.
* gas/mips/mips.exp: Run the new tests.
@
text
@d6420 2
a6421 1
	  if ((valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
@


1.306
log
@2005-04-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-mips.c (md_apply_fix3): Fix typos in BFD_RELOC_64.
@
text
@d864 5
d3261 27
d3373 2
a3374 9
  if (! dbl && ! ((ep->X_add_number & ~((bfd_vma) 0x7fffffff))
		  == ~((bfd_vma) 0x7fffffff)))
    {
      if (ep->X_add_number & ~((bfd_vma) 0xffffffff))
	as_bad (_("constant too large"));

      ep->X_add_number = (((ep->X_add_number & 0xffffffff) ^ 0x80000000)
			  - 0x80000000);
    }
a3419 8
static void
normalize_constant_expr (expressionS *ex)
{
  if (ex->X_op == O_constant && HAVE_32BIT_GPRS)
    ex->X_add_number = (((ex->X_add_number & 0xffffffff) ^ 0x80000000)
			- 0x80000000);
}

d3524 2
a3525 9
      if (! dbl && ! ((ep->X_add_number & ~((bfd_vma) 0x7fffffff))
		      == ~((bfd_vma) 0x7fffffff)))
	{
	  if (ep->X_add_number & ~((bfd_vma) 0xffffffff))
	    as_bad (_("constant too large"));

	  ep->X_add_number = (((ep->X_add_number & 0xffffffff) ^ 0x80000000)
			      - 0x80000000);
	}
d3554 1
a3554 1
  if (HAVE_32BIT_GPRS)
d3556 3
a3558 2
      as_bad (_("Number (0x%lx) larger than 32 bits"),
	      (unsigned long) ep->X_add_number);
d5799 6
a5808 4
	  if (HAVE_32BIT_ADDRESSES
	      && !IS_SEXT_32BIT_NUM (offset_expr.X_add_number))
	    as_bad (_("constant too large"));

d5811 1
d6390 6
d8579 1
@


1.305
log
@* config/tc-mips.c (mips_frob_file): Sort BFD_RELOC_MIPS16_LO16
relocations correctly as well.
(mips_fix_adjustable): Don't make BFD_RELOC_MIPS16_LO16
relocations in mergeable sections section-relative either.
@
text
@d10989 1
a10989 1
	      md_number_to_chars ((char *)(buf + target_big_endian ? 4 : 0),
d10991 1
a10991 1
	      md_number_to_chars ((char *)(buf + target_big_endian ? 0 : 4),
@


1.304
log
@==> ChangeLog <==
2005-03-14  Eric Christopher  <echristo@@redhat.com>

        * config/tc-mips.c: Include dw2gencfi.h.
        (mips_cfi_frame_initial_instructions): New.
        * config/tc-mips.h (TARGET_USE_CFIPOP): Define.
        (tc_cfi_frame_initial_instructions): Ditto.
        (DWARF2_DEFAULT_RETURN_COLUMN): Ditto.
        (DWARF2_CIE_DATA_ALIGNMENT): Ditto.
        * Makefile.am: Update dependencies.
        * Makefile.in: Regenerate.

==> testsuite/ChangeLog <==
2005-03-14  Eric Christopher  <echristo@@redhat.com>

        * gas/cfi/cfi-mips-1.d, gas/cfi/cfi-mips-1.s: New dump test.
        * gas/cfi/cfi.exp: Run it.
        * gas/cfi/cfi-common-1.d: Update.
        * gas/cfi/cfi-common-2.d: Ditto.
        * gas/cfi/cfi-common-3.d: Ditto.
        * gas/cfi/cfi-common-4.d: Ditto.
@
text
@d10751 2
a10752 1
	  if ((*pos)->fx_r_type == BFD_RELOC_LO16
d12693 3
a12695 1
  if ((fixp->fx_r_type == BFD_RELOC_LO16 || reloc_needs_lo_p (fixp->fx_r_type))
@


1.303
log
@	* config/tc-mips.c (s_cpsetup): Use '__gnu_local_gp' instead of '_gp'
	for -mno-shared optimization.
@
text
@d36 1
d14020 8
@


1.302
log
@	* config/tc-mips.c (MAX_VR4130_NOPS, MAX_DELAY_NOPS): New macros.
	(MAX_NOPS): Bump to 4.
	(mips_fix_vr4130): New variable.
	(nops_for_vr4130): New function.
	(nops_for_insn): Use MAX_DELAY_NOPS rather than MAX_NOPS.  Use
	nops_for_vr4130 if working around VR4130 errata.
	(OPTION_FIX_VR4130, OPTION_NO_FIX_VR4130): New macros.
	(md_longopts): Add -mfix-vr4130 and -mno-fix-vr4130.
	(md_parse_option): Handle them.
	(md_show_usage): Print them.
	* doc/c-mips.texi: Document -mfix-vr4130 and -mno-fix-vr4130.
@
text
@d11827 1
a11827 1
      ex.X_add_symbol = symbol_find_or_make ("_gp");
@


1.301
log
@	* config/tc-mips.c (append_insn): Remove cop_interlocks test from
	branch delay code.
@
text
@d560 8
a567 3
/* The maximum number of NOPs needed to satisfy a hardware hazard
   or processor errata.  */
#define MAX_NOPS 2
d667 3
d2022 42
d2076 1
a2076 1
  for (i = 0; i < MAX_NOPS; i++)
d2083 8
d10027 4
d10033 1
a10033 1
#define OPTION_MISC_BASE (OPTION_FIX_BASE + 4)
d10276 8
d13959 1
@


1.300
log
@	* config/tc-mips.h (mips_flush_pending_output): Delete.
	(mips_emit_delays): Declare.
	(md_flush_pending_output): Use mips_emit_delays.
	* config/tc-mips.c (mips_no_prev_insn): Remove parameter; always forget
	the previous instructions.
	(md_begin, append_insn, md_parse_option): Update callers.
	(mips_emit_delay): Remove parameter.  Move INSNS != 0 code to
	start_noreorder.
	(mips_align, s_change_sec, s_cons, s_float_cons, s_gpword)
	(s_gpdword): Update callers.
	(start_noreorder, end_noreorder): New functions.
	(macro, macro2, mips16_macro, s_mipsset): Use them instead of
	manipulating mips_opts or prev_nop_frag directly.
	(mips_flush_pending_output): Delete.
@
text
@a2515 11
	      /* If the branch reads the condition codes, we don't
		 even try to swap, because in the sequence
		   ctc1 $X,$31
		   INSN
		   INSN
		   bc1t LABEL
		 we can not swap, and I don't feel like handling that
		 case.  */
	      || (! mips_opts.mips16
		  && (pinfo & INSN_READ_COND_CODE)
		  && ! cop_interlocks)
@


1.299
log
@	* config/tc-mips.c (mips_move_labels): New function, taken from...
	(append_insn, mips_emit_delays): ...here.
@
text
@d931 1
a931 1
static void mips_no_prev_insn (int);
d1480 1
a1480 1
  mips_no_prev_insn (FALSE);
d2667 1
a2667 1
	    mips_no_prev_insn (FALSE);
d2688 1
a2688 3
/* This function forgets that there was any previous instruction or
   label.  If PRESERVE is non-zero, it remembers enough information to
   know whether nops are needed before a noreorder section.  */
d2691 1
a2691 1
mips_no_prev_insn (int preserve)
d2693 13
a2705 3
  size_t i;
 
  if (! preserve)
d2707 7
a2713 6
      prev_nop_frag = NULL;
      prev_nop_frag_holds = 0;
      prev_nop_frag_required = 0;
      prev_nop_frag_since = 0;
      for (i = 0; i < ARRAY_SIZE (history); i++)
	history[i] = (mips_opts.mips16 ? mips16_nop_insn : nop_insn);
d2715 1
a2715 8
  else
    for (i = 0; i < ARRAY_SIZE (history); i++)
      {
	history[i].fixed_p = 1;
	history[i].noreorder_p = 0;
	history[i].mips16_absolute_jump_p = 0;
      }
  mips_clear_insn_labels ();
d2718 1
a2718 5
/* This function must be called whenever we turn on noreorder or emit
   something other than instructions.  It inserts any NOPS which might
   be needed by the previous instruction, and clears the information
   kept for the previous instructions.  The INSNS parameter is true if
   instructions are to follow.  */
d2721 1
a2721 1
mips_emit_delays (bfd_boolean insns)
d2723 1
a2723 1
  if (! mips_opts.noreorder)
d2725 11
a2735 1
      int nops = nops_for_insn (history, NULL);
d2738 1
a2738 1
	  if (insns && mips_optimize != 0)
d2752 4
a2755 8
	  if (insns)
	    {
	      /* Move on to a new frag, so that it is safe to simply
                 decrease the size of prev_nop_frag.  */
	      frag_wane (frag_now);
	      frag_new (0);
	    }

d2758 2
d2761 3
d2765 1
a2765 3
  /* Mark instruction labels in mips16 mode.  */
  if (insns)
    mips16_mark_labels ();
d2767 14
a2780 1
  mips_no_prev_insn (insns);
d4084 1
a4084 3
      mips_emit_delays (TRUE);
      ++mips_opts.noreorder;
      mips_any_noreorder = 1;
d4094 1
a4094 1
      --mips_opts.noreorder;
d4602 1
a4602 3
      mips_emit_delays (TRUE);
      ++mips_opts.noreorder;
      mips_any_noreorder = 1;
d4636 1
a4636 1
	  --mips_opts.noreorder;
d4646 1
a4646 1
	  --mips_opts.noreorder;
d4741 1
a4741 3
      mips_emit_delays (TRUE);
      ++mips_opts.noreorder;
      mips_any_noreorder = 1;
d4748 1
a4748 1
	  --mips_opts.noreorder;
d4758 1
a4758 1
	  --mips_opts.noreorder;
d6686 1
a6686 3
      mips_emit_delays (TRUE);
      ++mips_opts.noreorder;
      mips_any_noreorder = 1;
d6703 1
a6703 1
      --mips_opts.noreorder;
d6717 1
a6717 3
      mips_emit_delays (TRUE);
      ++mips_opts.noreorder;
      mips_any_noreorder = 1;
d6734 1
a6734 1
      --mips_opts.noreorder;
d7199 1
a7199 3
      mips_emit_delays (TRUE);
      ++mips_opts.noreorder;
      mips_any_noreorder = 1;
d7213 1
a7213 1
      --mips_opts.noreorder;
d7453 1
a7453 3
      mips_emit_delays (TRUE);
      ++mips_opts.noreorder;
      mips_any_noreorder = 1;
d7463 1
a7463 1
      --mips_opts.noreorder;
d7483 1
a7483 3
      mips_emit_delays (TRUE);
      ++mips_opts.noreorder;
      mips_any_noreorder = 1;
d7488 1
a7488 1
      --mips_opts.noreorder;
d10201 1
a10201 1
      mips_no_prev_insn (FALSE);
d10206 1
a10206 1
      mips_no_prev_insn (FALSE);
d11065 1
a11065 1
  mips_emit_delays (FALSE);
a11126 7
void
mips_flush_pending_output (void)
{
  mips_emit_delays (FALSE);
  mips_clear_insn_labels ();
}

d11142 1
a11142 1
  mips_emit_delays (FALSE);
d11273 1
a11273 1
  mips_emit_delays (FALSE);
d11287 1
a11287 1
  mips_emit_delays (FALSE);
d11415 2
a11416 10
      if (mips_opts.noreorder && prev_nop_frag != NULL)
	{
	  /* If we still have pending nops, we can discard them.  The
	     usual nop handling will insert any that are still
	     needed.  */
	  prev_nop_frag->fr_fix -= (prev_nop_frag_holds
				    * (mips_opts.mips16 ? 2 : 4));
	  prev_nop_frag = NULL;
	}
      mips_opts.noreorder = 0;
d11420 2
a11421 3
      mips_emit_delays (TRUE);
      mips_opts.noreorder = 1;
      mips_any_noreorder = 1;
d11566 1
a11566 1
	    mips_emit_delays (TRUE);
d11568 1
a11568 8
	    {
	      if (prev_nop_frag != NULL)
		{
		  prev_nop_frag->fr_fix -= (prev_nop_frag_holds
					    * (mips_opts.mips16 ? 2 : 4));
		  prev_nop_frag = NULL;
		}
	    }
d11908 1
a11908 1
  mips_emit_delays (TRUE);
d11944 1
a11944 1
  mips_emit_delays (TRUE);
@


1.298
log
@	* config/tc-mips.c (MAX_NOPS): New macro.
	(history): Resize to 1 + MAX_NOPS.
	(fix_vr4120_class): New enumeration.
	(vr4120_conflicts): New variable.
	(init_vr4120_conflicts): New function.
	(md_begin): Call it.
	(insn_uses_reg): Constify first argument.
	(classify_vr4120_insn, insns_between, nops_for_insn, nops_for_sequence)
	(nops_for_insn_or_target): New functions.
	(append_insn): Use the new nops_for_* functions instead of inline
	delay checks.  Generalize prev_nop_frag handling to handle an
	arbitrary history length.  Insert nops into the history buffer
	once the number of nops in prev_nop_frag is fixed.
	(emit_delays): Use nops_for_insn instead of inline delay checks.
@
text
@d1774 20
a2120 1
	  struct insn_label_list *l;
d2142 1
a2142 12
	  for (l = insn_labels; l != NULL; l = l->next)
	    {
	      valueT val;

	      assert (S_GET_SEGMENT (l->label) == now_seg);
	      symbol_set_frag (l->label, frag_now);
	      val = (valueT) frag_now_fix ();
	      /* mips16 text labels are stored as odd.  */
	      if (mips_opts.mips16)
		++val;
	      S_SET_VALUE (l->label, val);
	    }
a2729 2
	  struct insn_label_list *l;

d2752 1
a2752 12
	  for (l = insn_labels; l != NULL; l = l->next)
	    {
	      valueT val;

	      assert (S_GET_SEGMENT (l->label) == now_seg);
	      symbol_set_frag (l->label, frag_now);
	      val = (valueT) frag_now_fix ();
	      /* mips16 text labels are stored as odd.  */
	      if (mips_opts.mips16)
		++val;
	      S_SET_VALUE (l->label, val);
	    }
@


1.297
log
@	* config/tc-mips.c (append_insn): Remove now-redundant nops != 0
	check from branch delay code.  Remove unnecessary check for branches.
@
text
@d560 10
a569 2
/* A list of previous instructions, with index 0 being the most recent.  */
static struct mips_cl_insn history[2];
d642 18
d1314 44
d1586 3
d1680 1
a1680 1
insn_uses_reg (struct mips_cl_insn *ip, unsigned int reg,
d1849 217
a2074 1
  int nops = 0;
d2084 1
a2084 2
  if (mips_relax.sequence != 2
      && (!mips_opts.noreorder || prev_nop_frag != NULL))
d2086 1
a2086 15
      int prev_prev_nop;

      /* If the previous insn required any delay slots, see if we need
	 to insert a NOP or two.  There are eight kinds of possible
	 hazards, of which an instruction can have at most one type.
	 (1) a load from memory delay
	 (2) a load from a coprocessor delay
	 (3) an unconditional branch delay
	 (4) a conditional branch delay
	 (5) a move to coprocessor register delay
	 (6) a load coprocessor register from memory delay
	 (7) a coprocessor condition code delay
	 (8) a HI/LO special register delay

	 There are a lot of optimizations we could do that we don't.
d2093 4
a2096 263

      /* The previous insn might require a delay slot, depending upon
	 the contents of the current insn.  */
      if (! mips_opts.mips16
	  && (((prev_pinfo & INSN_LOAD_MEMORY_DELAY)
	       && ! gpr_interlocks)
	      || ((prev_pinfo & INSN_LOAD_COPROC_DELAY)
		  && ! cop_interlocks)))
	{
	  /* A load from a coprocessor or from memory.  All load
	     delays delay the use of general register rt for one
	     instruction.  */
	  /* Itbl support may require additional care here.  */
	  know (prev_pinfo & INSN_WRITE_GPR_T);
	  if (mips_optimize == 0
	      || insn_uses_reg (ip, EXTRACT_OPERAND (RT, history[0]),
				MIPS_GR_REG))
	    ++nops;
	}
      else if (! mips_opts.mips16
	       && (((prev_pinfo & INSN_COPROC_MOVE_DELAY)
		    && ! cop_interlocks)
		   || ((prev_pinfo & INSN_COPROC_MEMORY_DELAY)
		       && ! cop_mem_interlocks)))
	{
	  /* A generic coprocessor delay.  The previous instruction
	     modified a coprocessor general or control register.  If
	     it modified a control register, we need to avoid any
	     coprocessor instruction (this is probably not always
	     required, but it sometimes is).  If it modified a general
	     register, we avoid using that register.

	     This case is not handled very well.  There is no special
	     knowledge of CP0 handling, and the coprocessors other
	     than the floating point unit are not distinguished at
	     all.  */
          /* Itbl support may require additional care here. FIXME!
             Need to modify this to include knowledge about
             user specified delays!  */
	  if (prev_pinfo & INSN_WRITE_FPR_T)
	    {
	      if (mips_optimize == 0
		  || insn_uses_reg (ip, EXTRACT_OPERAND (FT, history[0]),
				    MIPS_FP_REG))
		++nops;
	    }
	  else if (prev_pinfo & INSN_WRITE_FPR_S)
	    {
	      if (mips_optimize == 0
		  || insn_uses_reg (ip, EXTRACT_OPERAND (FS, history[0]),
				    MIPS_FP_REG))
		++nops;
	    }
	  else
	    {
	      /* We don't know exactly what the previous instruction
		 does.  If the current instruction uses a coprocessor
		 register, we must insert a NOP.  If previous
		 instruction may set the condition codes, and the
		 current instruction uses them, we must insert two
		 NOPS.  */
              /* Itbl support may require additional care here.  */
	      if (mips_optimize == 0
		  || ((prev_pinfo & INSN_WRITE_COND_CODE)
		      && (pinfo & INSN_READ_COND_CODE)))
		nops += 2;
	      else if (pinfo & INSN_COP)
		++nops;
	    }
	}
      else if (! mips_opts.mips16
	       && (prev_pinfo & INSN_WRITE_COND_CODE)
               && ! cop_interlocks)
	{
	  /* The previous instruction sets the coprocessor condition
	     codes, but does not require a general coprocessor delay
	     (this means it is a floating point comparison
	     instruction).  If this instruction uses the condition
	     codes, we need to insert a single NOP.  */
	  /* Itbl support may require additional care here.  */
	  if (mips_optimize == 0
	      || (pinfo & INSN_READ_COND_CODE))
	    ++nops;
	}

      /* If we're fixing up mfhi/mflo for the r7000 and the
	 previous insn was an mfhi/mflo and the current insn
	 reads the register that the mfhi/mflo wrote to, then
	 insert two nops.  */

      else if (mips_7000_hilo_fix
	       && MF_HILO_INSN (prev_pinfo)
	       && insn_uses_reg (ip, EXTRACT_OPERAND (RD, history[0]),
				 MIPS_GR_REG))
	{
	  nops += 2;
	}

      /* If we're fixing up mfhi/mflo for the r7000 and the
	 2nd previous insn was an mfhi/mflo and the current insn
	 reads the register that the mfhi/mflo wrote to, then
	 insert one nop.  */

      else if (mips_7000_hilo_fix
	       && MF_HILO_INSN (history[1].insn_opcode)
	       && insn_uses_reg (ip, EXTRACT_OPERAND (RD, history[1]),
				 MIPS_GR_REG))

	{
	  ++nops;
	}

      else if (prev_pinfo & INSN_READ_LO)
	{
	  /* The previous instruction reads the LO register; if the
	     current instruction writes to the LO register, we must
	     insert two NOPS.  Some newer processors have interlocks.
	     Also the tx39's multiply instructions can be executed
             immediately after a read from HI/LO (without the delay),
             though the tx39's divide insns still do require the
	     delay.  */
	  if (! (hilo_interlocks
		 || (mips_opts.arch == CPU_R3900 && (pinfo & INSN_MULT)))
	      && (mips_optimize == 0
		  || (pinfo & INSN_WRITE_LO)))
	    nops += 2;
	  /* Most mips16 branch insns don't have a delay slot.
	     If a read from LO is immediately followed by a branch
	     to a write to LO we have a read followed by a write
	     less than 2 insns away.  We assume the target of
	     a branch might be a write to LO, and insert a nop
	     between a read and an immediately following branch.  */
	  else if (mips_opts.mips16
		   && (mips_optimize == 0
		       || (pinfo & MIPS16_INSN_BRANCH)))
	    ++nops;
	}
      else if (history[0].insn_mo->pinfo & INSN_READ_HI)
	{
	  /* The previous instruction reads the HI register; if the
	     current instruction writes to the HI register, we must
	     insert a NOP.  Some newer processors have interlocks.
	     Also the note tx39's multiply above.  */
	  if (! (hilo_interlocks
		 || (mips_opts.arch == CPU_R3900 && (pinfo & INSN_MULT)))
	      && (mips_optimize == 0
		  || (pinfo & INSN_WRITE_HI)))
	    nops += 2;
	  /* Most mips16 branch insns don't have a delay slot.
	     If a read from HI is immediately followed by a branch
	     to a write to HI we have a read followed by a write
	     less than 2 insns away.  We assume the target of
	     a branch might be a write to HI, and insert a nop
	     between a read and an immediately following branch.  */
	  else if (mips_opts.mips16
		   && (mips_optimize == 0
		       || (pinfo & MIPS16_INSN_BRANCH)))
	    ++nops;
	}

      /* If the previous instruction was in a noreorder section, then
         we don't want to insert the nop after all.  */
      /* Itbl support may require additional care here.  */
      if (history[0].noreorder_p)
	nops = 0;

      /* There are two cases which require two intervening
	 instructions: 1) setting the condition codes using a move to
	 coprocessor instruction which requires a general coprocessor
	 delay and then reading the condition codes 2) reading the HI
	 or LO register and then writing to it (except on processors
	 which have interlocks).  If we are not already emitting a NOP
	 instruction, we must check for these cases compared to the
	 instruction previous to the previous instruction.  */
      if ((! mips_opts.mips16
	   && (history[1].insn_mo->pinfo & INSN_COPROC_MOVE_DELAY)
	   && (history[1].insn_mo->pinfo & INSN_WRITE_COND_CODE)
	   && (pinfo & INSN_READ_COND_CODE)
	   && ! cop_interlocks)
	  || ((history[1].insn_mo->pinfo & INSN_READ_LO)
	      && (pinfo & INSN_WRITE_LO)
	      && ! (hilo_interlocks
		    || (mips_opts.arch == CPU_R3900 && (pinfo & INSN_MULT))))
	  || ((history[1].insn_mo->pinfo & INSN_READ_HI)
	      && (pinfo & INSN_WRITE_HI)
	      && ! (hilo_interlocks
		    || (mips_opts.arch == CPU_R3900 && (pinfo & INSN_MULT)))))
	prev_prev_nop = 1;
      else
	prev_prev_nop = 0;

      if (history[1].noreorder_p)
	prev_prev_nop = 0;

      if (prev_prev_nop && nops == 0)
	++nops;

      if (mips_fix_vr4120 && history[0].insn_mo->name)
	{
	  /* We're out of bits in pinfo, so we must resort to string
	     ops here.  Shortcuts are selected based on opcodes being
	     limited to the VR4120 instruction set.  */
	  int min_nops = 0;
	  const char *pn = history[0].insn_mo->name;
	  const char *tn = ip->insn_mo->name;
	  if (strncmp (pn, "macc", 4) == 0
	      || strncmp (pn, "dmacc", 5) == 0)
	    {
	      /* Errata 21 - [D]DIV[U] after [D]MACC */
	      if (strstr (tn, "div"))
		min_nops = 1;

	      /* VR4181A errata MD(1): "If a MULT, MULTU, DMULT or DMULTU
		 instruction is executed immediately after a MACC or
		 DMACC instruction, the result of [either instruction]
		 is incorrect."  */
	      if (strncmp (tn, "mult", 4) == 0
		  || strncmp (tn, "dmult", 5) == 0)
		min_nops = 1;

	      /* Errata 23 - Continuous DMULT[U]/DMACC instructions.
		 Applies on top of VR4181A MD(1) errata.  */
	      if (pn[0] == 'd' && strncmp (tn, "dmacc", 5) == 0)
		min_nops = 1;

	      /* Errata 24 - MT{LO,HI} after [D]MACC */
	      if (strcmp (tn, "mtlo") == 0
		  || strcmp (tn, "mthi") == 0)
		min_nops = 1;
	    }
	  else if (strncmp (pn, "dmult", 5) == 0
		   && (strncmp (tn, "dmult", 5) == 0
		       || strncmp (tn, "dmacc", 5) == 0))
	    {
	      /* Here is the rest of errata 23.  */
	      min_nops = 1;
	    }
	  else if ((strncmp (pn, "dmult", 5) == 0 || strstr (pn, "div"))
		   && (strncmp (tn, "macc", 4) == 0
		       || strncmp (tn, "dmacc", 5) == 0))
	    {
	      /* VR4181A errata MD(4): "If a MACC or DMACC instruction is
		 executed immediately after a DMULT, DMULTU, DIV, DIVU,
		 DDIV or DDIVU instruction, the result of the MACC or
		 DMACC instruction is incorrect.".  This partly overlaps
		 the workaround for errata 23.  */
	      min_nops = 1;
	    }
	  if (nops < min_nops)
	    nops = min_nops;
	}

      /* If we are being given a nop instruction, don't bother with
	 one of the nops we would otherwise output.  This will only
	 happen when a nop instruction is used with mips_optimize set
	 to 0.  */
      if (nops > 0
	  && ! mips_opts.noreorder
	  && ip->insn_opcode == (unsigned) (mips_opts.mips16 ? 0x6500 : 0))
	--nops;

      /* Now emit the right number of NOP instructions.  */
      if (nops > 0 && ! mips_opts.noreorder)
d2141 6
a2146 26
      else if (prev_nop_frag != NULL)
	{
	  /* We have a frag holding nops we may be able to remove.  If
             we don't need any nops, we can decrease the size of
             prev_nop_frag by the size of one instruction.  If we do
             need some nops, we count them in prev_nops_required.  */
	  if (prev_nop_frag_since == 0)
	    {
	      if (nops == 0)
		{
		  prev_nop_frag->fr_fix -= mips_opts.mips16 ? 2 : 4;
		  --prev_nop_frag_holds;
		}
	      else
		prev_nop_frag_required += nops;
	    }
	  else
	    {
	      if (prev_prev_nop == 0)
		{
		  prev_nop_frag->fr_fix -= mips_opts.mips16 ? 2 : 4;
		  --prev_nop_frag_holds;
		}
	      else
		++prev_nop_frag_required;
	    }
d2148 3
a2150 2
	  if (prev_nop_frag_holds <= prev_nop_frag_required)
	    prev_nop_frag = NULL;
d2152 15
a2166 6
	  ++prev_nop_frag_since;

	  /* Sanity check: by the time we reach the second instruction
             after prev_nop_frag, we should have used up all the nops
             one way or another.  */
	  assert (prev_nop_frag_since <= 1 || prev_nop_frag == NULL);
d2519 6
a2524 22
	      /* We can not swap with an instruction that requires a
		 delay slot, because the target of the branch might
		 interfere with that instruction.  */
	      || (! mips_opts.mips16
		  && (prev_pinfo
              /* Itbl support may require additional care here.  */
		      & (INSN_LOAD_COPROC_DELAY
			 | INSN_COPROC_MOVE_DELAY
			 | INSN_WRITE_COND_CODE))
		  && ! cop_interlocks)
	      || (! (hilo_interlocks
		     || (mips_opts.arch == CPU_R3900 && (pinfo & INSN_MULT)))
		  && (prev_pinfo
		      & (INSN_READ_LO
			 | INSN_READ_HI)))
	      || (! mips_opts.mips16
		  && (prev_pinfo & INSN_LOAD_MEMORY_DELAY)
		  && ! gpr_interlocks)
	      || (! mips_opts.mips16
                  /* Itbl support may require additional care here.  */
		  && (prev_pinfo & INSN_COPROC_MEMORY_DELAY)
		  && ! cop_mem_interlocks)
a2597 12
	      /* If the previous previous instruction has a load
		 delay, and sets a register that the branch reads, we
		 can not swap.  */
	      || (! mips_opts.mips16
              /* Itbl support may require additional care here.  */
		  && (((history[1].insn_mo->pinfo & INSN_LOAD_COPROC_DELAY)
		       && ! cop_interlocks)
		      || ((history[1].insn_mo->pinfo
			   & INSN_LOAD_MEMORY_DELAY)
			  && ! gpr_interlocks))
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RT, history[1]),
				    MIPS_GR_REG))
d2719 1
a2719 58
      int nops;

      nops = 0;
      if ((! mips_opts.mips16
	   && ((history[0].insn_mo->pinfo
		& (INSN_LOAD_COPROC_DELAY
		   | INSN_COPROC_MOVE_DELAY
		   | INSN_WRITE_COND_CODE))
	       && ! cop_interlocks))
	  || (! hilo_interlocks
	      && (history[0].insn_mo->pinfo
		  & (INSN_READ_LO
		     | INSN_READ_HI)))
	  || (! mips_opts.mips16
	      && (history[0].insn_mo->pinfo & INSN_LOAD_MEMORY_DELAY)
	      && ! gpr_interlocks)
	  || (! mips_opts.mips16
	      && (history[0].insn_mo->pinfo & INSN_COPROC_MEMORY_DELAY)
	      && ! cop_mem_interlocks))
	{
	  /* Itbl support may require additional care here.  */
	  ++nops;
	  if ((! mips_opts.mips16
	       && ((history[0].insn_mo->pinfo & INSN_WRITE_COND_CODE)
		   && ! cop_interlocks))
	      || (! hilo_interlocks
		  && ((history[0].insn_mo->pinfo & INSN_READ_HI)
		      || (history[0].insn_mo->pinfo & INSN_READ_LO))))
	    ++nops;

	  if (history[0].noreorder_p)
	    nops = 0;
	}
      else if ((! mips_opts.mips16
		&& ((history[1].insn_mo->pinfo & INSN_WRITE_COND_CODE)
		    && ! cop_interlocks))
	       || (! hilo_interlocks
		   && ((history[1].insn_mo->pinfo & INSN_READ_HI)
		       || (history[1].insn_mo->pinfo & INSN_READ_LO))))
	{
	  /* Itbl support may require additional care here.  */
	  if (! history[1].noreorder_p)
	    ++nops;
	}

      if (mips_fix_vr4120 && history[0].insn_mo->name)
	{
	  int min_nops = 0;
	  const char *pn = history[0].insn_mo->name;
	  if (strncmp (pn, "macc", 4) == 0
	      || strncmp (pn, "dmacc", 5) == 0
	      || strncmp (pn, "dmult", 5) == 0
	      || strstr (pn, "div"))
	    min_nops = 1;
	  if (nops < min_nops)
	    nops = min_nops;
	}

d2724 1
a2724 1
	  if (insns)
@


1.296
log
@	* config/tc-mips.c (dummy_opcode): Delete.
	(nop_insn, mips16_nop_insn): New variables.
	(NOP_INSN): New macro.
	(insn_length, create_insn, install_insn, move_insn, add_fixed_insn)
	(add_relaxed_insn, insert_into_history, emit_nop): New functions.
	(md_begin): Initialize nop_insn and mips16_nop_insn.
	(append_insn): Use the new emit_nop function to add nops, recording
	them in the history buffer.  Use add_fixed_insn or add_relaxed_insn
	to reserve room for the instruction and install_insn to install the
	final form.  Use insert_into_history to record the instruction in
	the history buffer.  Use move_insn to do delay slot filling.
	(mips_emit_delays): Use add_fixed_insn instead of the emit_nop macro.
	(macro_build, mips16_macro_build, macro_build_lui, mips_ip)
	(mips16_ip): Use create_insn to initialize mips_cl_insns.
@
text
@a2474 3
	      /* If we had to emit any NOP instructions, then we
		 already know we can not swap.  */
	      || nops != 0
a2535 5
	      /* We can not swap with a branch instruction.  */
	      || (prev_pinfo
		  & (INSN_UNCOND_BRANCH_DELAY
		     | INSN_COND_BRANCH_DELAY
		     | INSN_COND_BRANCH_LIKELY))
@


1.295
log
@	* config/tc-mips.c (INSERT_BITS, EXTRACT_BITS, INSERT_OPERAND)
	(EXTRACT_OPERAND, MIPS16_INSERT_OPERAND, MIPS16_EXTRACT_OPERAND): New.
	(insn_uses_reg, reg_needs_delay, append_insn, macro_build)
	(mips16_macro_build, macro_build_lui, mips16_macro, mips_ip)
	(mips16_ip): Use the new macros instead of explicit masks and shifts.
@
text
@d563 5
a567 3
/* If we don't want information for a history[] entry, we
   point the insn_mo field at this dummy integer.  */
static const struct mips_opcode dummy_opcode = { NULL, NULL, 0, 0, 0, 0, 0 };
d1164 124
d1321 5
d1353 5
a1784 2
  char *f;
  fixS *fixp[3];
a1787 1
  bfd_boolean force_new_frag = FALSE;
a1819 6
      /* This is how a NOP is emitted.  */
#define emit_nop()					\
  (mips_opts.mips16					\
   ? md_number_to_chars (frag_more (2), 0x6500, 2)	\
   : md_number_to_chars (frag_more (4), 0, 4))

d2191 12
a2202 13
      f = frag_var (rs_machine_dependent,
		    relaxed_branch_length
		    (NULL, NULL,
		     (pinfo & INSN_UNCOND_BRANCH_DELAY) ? -1
		     : (pinfo & INSN_COND_BRANCH_LIKELY) ? 1 : 0), 4,
		    RELAX_BRANCH_ENCODE
		    (pinfo & INSN_UNCOND_BRANCH_DELAY,
		     pinfo & INSN_COND_BRANCH_LIKELY,
		     pinfo & INSN_WRITE_GPR_31,
		     0),
		    address_expr->X_add_symbol,
		    address_expr->X_add_number,
		    0);
d2209 7
a2215 7
      f = frag_var (rs_machine_dependent, 4, 0,
		    RELAX_MIPS16_ENCODE (*reloc_type - BFD_RELOC_UNUSED,
					 mips16_small, mips16_ext,
					 (prev_pinfo
					  & INSN_UNCOND_BRANCH_DELAY),
					 history[0].mips16_absolute_jump_p),
		    make_expr_symbol (address_expr), 0, NULL);
d2224 1
a2224 1
      f = frag_more (2);
d2248 6
a2253 1
      f = frag_more (4);
a2255 1
  fixp[0] = fixp[1] = fixp[2] = NULL;
d2336 5
a2340 5
	  fixp[0] = fix_new_exp (frag_now, f - frag_now->fr_literal,
				 bfd_get_reloc_size(howto),
				 address_expr,
				 reloc_type[0] == BFD_RELOC_16_PCREL_S2,
				 reloc_type[0]);
d2365 1
a2365 1
	    fixp[0]->fx_no_overflow = 1;
d2370 1
a2370 1
		mips_relax.first_fixup = fixp[0];
d2386 1
a2386 1
	      hi_fixup->fixp = fixp[0];
d2398 3
a2400 3
		fixp[i] = fix_new (frag_now, fixp[0]->fx_where,
				   fixp[0]->fx_size, NULL, 0,
				   FALSE, reloc_type[i]);
d2403 2
a2404 2
		fixp[0]->fx_tcbit = 1;
		fixp[i]->fx_tcbit = 1;
d2408 1
a2408 17

  if (! mips_opts.mips16)
    md_number_to_chars (f, ip->insn_opcode, 4);
  else if (*reloc_type == BFD_RELOC_MIPS16_JMP)
    {
      md_number_to_chars (f, ip->insn_opcode >> 16, 2);
      md_number_to_chars (f + 2, ip->insn_opcode & 0xffff, 2);
    }
  else
    {
      if (ip->use_extend)
	{
	  md_number_to_chars (f, 0xf000 | ip->extend, 2);
	  f += 2;
	}
      md_number_to_chars (f, ip->insn_opcode, 2);
    }
d2651 1
a2654 6
	      /* Update the previous insn information.  */
	      history[1].insn_mo = ip->insn_mo;
	      history[1].use_extend = ip->use_extend;
	      history[1].extend = ip->extend;
	      history[1].insn_opcode = ip->insn_opcode;
	      history[0].insn_mo = &dummy_opcode;
d2659 2
a2660 1
	      if (! mips_opts.mips16)
d2662 14
a2675 82
		  char *prev_f;
		  char temp[4];

		  prev_f = history[0].frag->fr_literal + history[0].where;
		  if (!relaxed_branch)
		    {
		      /* If this is not a relaxed branch, then just
			 swap the instructions.  */
		      memcpy (temp, prev_f, 4);
		      memcpy (prev_f, f, 4);
		      memcpy (f, temp, 4);
		    }
		  else
		    {
		      /* If this is a relaxed branch, then we move the
			 instruction to be placed in the delay slot to
			 the current frag, shrinking the fixed part of
			 the originating frag.  If the branch occupies
			 the tail of the latter, we move it backwards,
			 into the space freed by the moved instruction.  */
		      f = frag_more (4);
		      memcpy (f, prev_f, 4);
		      history[0].frag->fr_fix -= 4;
		      if (history[0].frag->fr_type == rs_machine_dependent)
			memmove (prev_f, prev_f + 4, history[0].frag->fr_var);
		    }

		  if (history[0].fixp[0])
		    {
		      history[0].fixp[0]->fx_frag = frag_now;
		      history[0].fixp[0]->fx_where = f - frag_now->fr_literal;
		    }
		  if (history[0].fixp[1])
		    {
		      history[0].fixp[1]->fx_frag = frag_now;
		      history[0].fixp[1]->fx_where = f - frag_now->fr_literal;
		    }
		  if (history[0].fixp[2])
		    {
		      history[0].fixp[2]->fx_frag = frag_now;
		      history[0].fixp[2]->fx_where = f - frag_now->fr_literal;
		    }
		  if (history[0].fixp[0] && HAVE_NEWABI
		      && history[0].frag != frag_now
		      && (history[0].fixp[0]->fx_r_type
			  == BFD_RELOC_MIPS_GOT_DISP
			  || (history[0].fixp[0]->fx_r_type
			      == BFD_RELOC_MIPS_CALL16)))
		    {
		      /* To avoid confusion in tc_gen_reloc, we must
			 ensure that this does not become a variant
			 frag.  */
		      force_new_frag = TRUE;
		    }

		  if (!relaxed_branch)
		    {
		      if (fixp[0])
			{
			  fixp[0]->fx_frag = history[0].frag;
			  fixp[0]->fx_where = history[0].where;
			}
		      if (fixp[1])
			{
			  fixp[1]->fx_frag = history[0].frag;
			  fixp[1]->fx_where = history[0].where;
			}
		      if (fixp[2])
			{
			  fixp[2]->fx_frag = history[0].frag;
			  fixp[2]->fx_where = history[0].where;
			}
		    }
		  else if (history[0].frag->fr_type == rs_machine_dependent)
		    {
		      if (fixp[0])
			fixp[0]->fx_where -= 4;
		      if (fixp[1])
			fixp[1]->fx_where -= 4;
		      if (fixp[2])
			fixp[2]->fx_where -= 4;
		    }
d2679 2
a2680 34
		  char *prev_f;
		  char temp[2];

		  assert (history[0].fixp[0] == NULL);
		  assert (history[0].fixp[1] == NULL);
		  assert (history[0].fixp[2] == NULL);
		  prev_f = history[0].frag->fr_literal + history[0].where;
		  memcpy (temp, prev_f, 2);
		  memcpy (prev_f, f, 2);
		  if (*reloc_type != BFD_RELOC_MIPS16_JMP)
		    {
		      assert (*reloc_type == BFD_RELOC_UNUSED);
		      memcpy (f, temp, 2);
		    }
		  else
		    {
		      memcpy (f, f + 2, 2);
		      memcpy (f + 2, temp, 2);
		    }
		  if (fixp[0])
		    {
		      fixp[0]->fx_frag = history[0].frag;
		      fixp[0]->fx_where = history[0].where;
		    }
		  if (fixp[1])
		    {
		      fixp[1]->fx_frag = history[0].frag;
		      fixp[1]->fx_where = history[0].where;
		    }
		  if (fixp[2])
		    {
		      fixp[2]->fx_frag = history[0].frag;
		      fixp[2]->fx_where = history[0].where;
		    }
d2682 3
a2684 7

	      /* Update the previous insn information; leave history[0]
		 unchanged.  */
	      history[1].insn_mo = ip->insn_mo;
	      history[1].use_extend = ip->use_extend;
	      history[1].extend = ip->extend;
	      history[1].insn_opcode = ip->insn_opcode;
a2685 1
	  history[0].fixed_p = 1;
d2690 1
a2690 9
	    {
	      history[1].insn_mo = &dummy_opcode;
	      history[0].insn_mo = &dummy_opcode;
	    }

	  history[0].fixp[0] = NULL;
	  history[0].fixp[1] = NULL;
	  history[0].fixp[2] = NULL;
	  history[0].mips16_absolute_jump_p = 0;
d2698 1
a2699 11
	  /* Update the previous insn information.  */
	  history[1].insn_mo = ip->insn_mo;
	  history[1].use_extend = ip->use_extend;
	  history[1].extend = ip->extend;
	  history[1].insn_opcode = ip->insn_opcode;
	  history[0].insn_mo = &dummy_opcode;
	  history[0].fixp[0] = NULL;
	  history[0].fixp[1] = NULL;
	  history[0].fixp[2] = NULL;
	  history[0].mips16_absolute_jump_p = 0;
	  history[0].fixed_p = 1;
d2702 1
a2702 48
	{
	  /* Update the previous insn information.  */
	  if (nops > 0)
	    history[1].insn_mo = &dummy_opcode;
	  else
	    {
	      history[1].insn_mo = history[0].insn_mo;
	      history[1].use_extend = history[0].use_extend;
	      history[1].extend = history[0].extend;
	      history[1].insn_opcode = history[0].insn_opcode;
	    }
	  history[0].insn_mo = ip->insn_mo;
	  history[0].use_extend = ip->use_extend;
	  history[0].extend = ip->extend;
	  history[0].insn_opcode = ip->insn_opcode;
	  history[0].fixed_p = (mips_opts.mips16
				&& (ip->use_extend
				    || *reloc_type > BFD_RELOC_UNUSED));
	  history[0].fixp[0] = fixp[0];
	  history[0].fixp[1] = fixp[1];
	  history[0].fixp[2] = fixp[2];
	  history[0].mips16_absolute_jump_p = (reloc_type[0]
					       == BFD_RELOC_MIPS16_JMP);
	}

      history[1].noreorder_p = history[0].noreorder_p;
      history[0].noreorder_p = 0;
      history[0].frag = frag_now;
      history[0].where = f - frag_now->fr_literal;
    }
  else if (mips_relax.sequence != 2)
    {
      /* We need to record a bit of information even when we are not
         reordering, in order to determine the base address for mips16
         PC relative relocs.  */
      history[1].insn_mo = history[0].insn_mo;
      history[1].use_extend = history[0].use_extend;
      history[1].extend = history[0].extend;
      history[1].insn_opcode = history[0].insn_opcode;
      history[0].insn_mo = ip->insn_mo;
      history[0].use_extend = ip->use_extend;
      history[0].extend = ip->extend;
      history[0].insn_opcode = ip->insn_opcode;
      history[0].mips16_absolute_jump_p = (reloc_type[0]
					   == BFD_RELOC_MIPS16_JMP);
      history[1].noreorder_p = history[0].noreorder_p;
      history[0].noreorder_p = 1;
      history[0].fixed_p = 1;
d2704 2
d2718 2
a2721 2
      history[0].insn_mo = &dummy_opcode;
      history[1].insn_mo = &dummy_opcode;
d2726 2
d2729 7
a2735 4
  history[0].fixed_p = 1;
  history[0].noreorder_p = 0;
  history[0].mips16_absolute_jump_p = 0;
  history[1].noreorder_p = 0;
d2824 1
a2824 1
	    emit_nop ();
d2947 1
d2964 11
a2974 14
  insn.insn_mo = (struct mips_opcode *) hash_find (op_hash, name);
  assert (insn.insn_mo);
  assert (strcmp (name, insn.insn_mo->name) == 0);

  /* Search until we get a match for NAME.  */
  while (1)
    {
      /* It is assumed here that macros will never generate
         MDMX or MIPS-3D instructions.  */
      if (strcmp (fmt, insn.insn_mo->args) == 0
	  && insn.insn_mo->pinfo != INSN_MACRO
  	  && OPCODE_IS_MEMBER (insn.insn_mo,
  			       (mips_opts.isa
	      		        | (file_ase_mips16 ? INSN_MIPS16 : 0)),
d2976 5
a2980 6
	  && (mips_opts.arch != CPU_R4650 || (insn.insn_mo->pinfo & FP_D) == 0))
	break;

      ++insn.insn_mo;
      assert (insn.insn_mo->name);
      assert (strcmp (name, insn.insn_mo->name) == 0);
d2983 1
a2983 1
  insn.insn_opcode = insn.insn_mo->match;
d3166 1
d3171 9
a3179 10
  insn.insn_mo = (struct mips_opcode *) hash_find (mips16_op_hash, name);
  assert (insn.insn_mo);
  assert (strcmp (name, insn.insn_mo->name) == 0);

  while (strcmp (fmt, insn.insn_mo->args) != 0
	 || insn.insn_mo->pinfo == INSN_MACRO)
    {
      ++insn.insn_mo;
      assert (insn.insn_mo->name);
      assert (strcmp (name, insn.insn_mo->name) == 0);
d3182 1
a3182 3
  insn.insn_opcode = insn.insn_mo->match;
  insn.use_extend = FALSE;

d3308 1
d3340 4
a3343 4
  insn.insn_mo = (struct mips_opcode *) hash_find (op_hash, name);
  assert (insn.insn_mo);
  assert (strcmp (name, insn.insn_mo->name) == 0);
  assert (strcmp (fmt, insn.insn_mo->args) == 0);
d7964 1
a7964 2
      ip->insn_mo = insn;
      ip->insn_opcode = insn->match;
d9068 1
a9068 3
      ip->insn_mo = insn;
      ip->insn_opcode = insn->match;
      ip->use_extend = FALSE;
@


1.294
log
@	* config/tc-mips.c (mips_cl_insn): Replace the valid_p, delay_slot_p
	and extended_p fields with a single fixed_p field.
	(append_insn, mips_no_prev_insn): Adjust accordingly.
@
text
@d827 30
d1496 1
a1496 1
	  && ((((ip->insn_opcode >> OP_SH_FS) & OP_MASK_FS) &~(unsigned)1)
d1500 1
a1500 1
	  && ((((ip->insn_opcode >> OP_SH_FT) & OP_MASK_FT) &~(unsigned)1)
d1507 1
a1507 1
	  && ((ip->insn_opcode >> OP_SH_RS) & OP_MASK_RS) == reg)
d1510 1
a1510 1
	  && ((ip->insn_opcode >> OP_SH_RT) & OP_MASK_RT) == reg)
d1516 1
a1516 3
	  && (mips16_to_32_reg_map[((ip->insn_opcode >> MIPS16OP_SH_RX)
				    & MIPS16OP_MASK_RX)]
	      == reg))
d1519 1
a1519 3
	  && (mips16_to_32_reg_map[((ip->insn_opcode >> MIPS16OP_SH_RY)
				    & MIPS16OP_MASK_RY)]
	      == reg))
d1522 1
a1522 2
	  && (mips16_to_32_reg_map[((ip->insn_opcode >> MIPS16OP_SH_MOVE32Z)
				    & MIPS16OP_MASK_MOVE32Z)]
d1532 1
a1532 2
	  && ((ip->insn_opcode >> MIPS16OP_SH_REGR32)
	      & MIPS16OP_MASK_REGR32) == reg)
d1558 1
a1558 1
      if (reg == ((history[0].insn_opcode >> OP_SH_RT) & OP_MASK_RT))
d1707 1
a1707 3
	      || insn_uses_reg (ip,
				((history[0].insn_opcode >> OP_SH_RT)
				 & OP_MASK_RT),
d1734 1
a1734 3
		  || insn_uses_reg (ip,
				    ((history[0].insn_opcode >> OP_SH_FT)
				     & OP_MASK_FT),
d1741 1
a1741 3
		  || insn_uses_reg (ip,
				    ((history[0].insn_opcode >> OP_SH_FS)
				     & OP_MASK_FS),
d1784 1
a1784 2
	       && insn_uses_reg (ip, ((history[0].insn_opcode >> OP_SH_RD)
				      & OP_MASK_RD),
d1797 2
a1798 3
	       && insn_uses_reg (ip, ((history[1].insn_opcode >> OP_SH_RD)
                                       & OP_MASK_RD),
                                    MIPS_GR_REG))
d2300 1
a2300 1
	mips_gprmask |= 1 << ((ip->insn_opcode >> OP_SH_RD) & OP_MASK_RD);
d2302 1
a2302 1
	mips_gprmask |= 1 << ((ip->insn_opcode >> OP_SH_RT) & OP_MASK_RT);
d2304 1
a2304 1
	mips_gprmask |= 1 << ((ip->insn_opcode >> OP_SH_RS) & OP_MASK_RS);
d2308 1
a2308 1
	mips_cprmask[1] |= 1 << ((ip->insn_opcode >> OP_SH_FD) & OP_MASK_FD);
d2310 1
a2310 1
	mips_cprmask[1] |= 1 << ((ip->insn_opcode >> OP_SH_FS) & OP_MASK_FS);
d2312 1
a2312 1
	mips_cprmask[1] |= 1 << ((ip->insn_opcode >> OP_SH_FT) & OP_MASK_FT);
d2314 1
a2314 1
	mips_cprmask[1] |= 1 << ((ip->insn_opcode >> OP_SH_FR) & OP_MASK_FR);
d2328 1
a2328 2
	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_RX)
			      & MIPS16OP_MASK_RX);
d2330 1
a2330 2
	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_RY)
			      & MIPS16OP_MASK_RY);
d2332 1
a2332 2
	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_RZ)
			      & MIPS16OP_MASK_RZ);
d2342 1
a2342 2
	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_MOVE32Z)
			      & MIPS16OP_MASK_MOVE32Z);
d2344 1
a2344 2
	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_REGR32)
			      & MIPS16OP_MASK_REGR32);
d2438 1
a2438 3
		  && insn_uses_reg (ip,
				    ((history[0].insn_opcode >> OP_SH_RT)
				     & OP_MASK_RT),
d2442 1
a2442 3
		  && insn_uses_reg (ip,
				    ((history[0].insn_opcode >> OP_SH_RD)
				     & OP_MASK_RD),
d2446 3
a2448 5
		       && insn_uses_reg (ip,
					 ((history[0].insn_opcode
					   >> MIPS16OP_SH_RX)
					  & MIPS16OP_MASK_RX),
					 MIPS16_REG))
d2450 3
a2452 5
			  && insn_uses_reg (ip,
					    ((history[0].insn_opcode
					      >> MIPS16OP_SH_RY)
					     & MIPS16OP_MASK_RY),
					    MIPS16_REG))
d2454 3
a2456 5
			  && insn_uses_reg (ip,
					    ((history[0].insn_opcode
					      >> MIPS16OP_SH_RZ)
					     & MIPS16OP_MASK_RZ),
					    MIPS16_REG))
d2472 2
a2473 2
		       && (((history[0].insn_opcode >> OP_SH_RT) & OP_MASK_RT)
			   == ((ip->insn_opcode >> OP_SH_RD) & OP_MASK_RD)))
d2475 1
a2475 3
			  && (((history[0].insn_opcode >> OP_SH_RT)
			       & OP_MASK_RT)
			      == RA))))
d2479 2
a2480 2
		       && (((history[0].insn_opcode >> OP_SH_RD) & OP_MASK_RD)
			   == ((ip->insn_opcode >> OP_SH_RD) & OP_MASK_RD)))
d2482 1
a2482 3
			  && (((history[0].insn_opcode >> OP_SH_RD)
			       & OP_MASK_RD)
			      == RA))))
d2495 1
a2495 2
				    ((ip->insn_opcode >> OP_SH_RD)
				     & OP_MASK_RD),
d2513 1
a2513 3
		  && insn_uses_reg (ip,
				    ((history[1].insn_opcode >> OP_SH_RT)
				     & OP_MASK_RT),
d3057 1
a3057 2
	      insn.insn_opcode |= (va_arg (args, int)
				   & OP_MASK_SHAMT) << OP_SH_SHAMT;
d3066 1
a3066 2
	      insn.insn_opcode |= (va_arg (args, int)
				   & OP_MASK_INSMSB) << OP_SH_INSMSB;
d3076 1
a3076 2
	      insn.insn_opcode |= (va_arg (args, int)
				   & OP_MASK_EXTMSBD) << OP_SH_EXTMSBD;
d3087 1
a3087 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_RT;
d3091 1
a3091 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_CODE;
d3096 1
a3096 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_FT;
d3102 1
a3102 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_RD;
d3109 2
a3110 2
	    insn.insn_opcode |= tmp << OP_SH_RT;
	    insn.insn_opcode |= tmp << OP_SH_RD;
d3116 1
a3116 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_FS;
d3123 1
a3123 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_SHAMT;
d3127 1
a3127 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_FD;
d3131 1
a3131 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_CODE20;
d3135 1
a3135 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_CODE19;
d3139 1
a3139 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_CODE2;
d3146 1
a3146 1
	  insn.insn_opcode |= va_arg (args, int) << OP_SH_RS;
d3258 1
a3258 1
	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_RY;
d3263 1
a3263 1
	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_RX;
d3267 1
a3267 1
	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_RZ;
d3271 1
a3271 1
	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_MOVE32Z;
d3281 1
a3281 1
	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_REGR32;
d3327 1
a3327 1
	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_IMM6;
d3402 2
a3403 1
  insn.insn_opcode = insn.insn_mo->match | (regnum << OP_SH_RT);
d7569 3
a7571 3
  xreg = (ip->insn_opcode >> MIPS16OP_SH_RX) & MIPS16OP_MASK_RX;
  yreg = (ip->insn_opcode >> MIPS16OP_SH_RY) & MIPS16OP_MASK_RY;
  zreg = (ip->insn_opcode >> MIPS16OP_SH_RZ) & MIPS16OP_MASK_RZ;
d8045 1
a8045 1
		  ip->insn_opcode |= lastregno << OP_SH_RS;
d8049 1
a8049 1
		  ip->insn_opcode |= lastregno << OP_SH_RT;
d8053 1
a8053 1
		  ip->insn_opcode |= lastregno << OP_SH_FT;
d8057 1
a8057 1
		  ip->insn_opcode |= lastregno << OP_SH_FS;
d8102 1
a8102 2
		  ip->insn_opcode |= (imm_expr.X_add_number
				      & OP_MASK_SHAMT) << OP_SH_SHAMT;
d8133 2
a8134 2
		  ip->insn_opcode |= ((lastpos + imm_expr.X_add_number - 1)
				      & OP_MASK_INSMSB) << OP_SH_INSMSB;
d8169 1
a8169 2
		  ip->insn_opcode |= ((imm_expr.X_add_number - 1)
				      & OP_MASK_EXTMSBD) << OP_SH_EXTMSBD;
d8206 3
a8208 6
		{
		  as_warn (_("Improper shift amount (%lu)"),
			   (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_SHAMT;
		}
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_SHAMT;
d8219 1
a8219 1
	      ip->insn_opcode |= (imm_expr.X_add_number - 32) << OP_SH_SHAMT;
d8229 3
a8231 6
		{
		  as_warn (_("Invalid value for `%s' (%lu)"),
			   ip->insn_mo->name,
			   (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= 0x1f;
		}
d8233 1
a8233 1
		ip->insn_opcode |= imm_expr.X_add_number << OP_SH_CACHE;
d8235 1
a8235 1
		ip->insn_opcode |= imm_expr.X_add_number << OP_SH_PREFX;
d8244 3
a8246 6
		{
		  as_warn (_("Illegal break code (%lu)"),
			   (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_CODE;
		}
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_CODE;
d8255 3
a8257 6
		{
		  as_warn (_("Illegal lower break code (%lu)"),
			   (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_CODE2;
		}
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_CODE2;
d8268 1
a8268 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_CODE20;
d8293 1
a8293 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_CODE19;
d8302 3
a8304 6
		{
		  as_warn (_("Invalid performance register (%lu)"),
			   (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_PERFREG;
		}
	      ip->insn_opcode |= (imm_expr.X_add_number << OP_SH_PERFREG);
d8441 1
a8441 1
		      ip->insn_opcode |= regno << OP_SH_RS;
d8446 1
a8446 1
		      ip->insn_opcode |= regno << OP_SH_RD;
d8449 2
a8450 2
		      ip->insn_opcode |= regno << OP_SH_RD;
		      ip->insn_opcode |= regno << OP_SH_RT;
d8455 1
a8455 1
		      ip->insn_opcode |= regno << OP_SH_RT;
d8486 1
a8486 1
		  ip->insn_opcode |= lastregno << OP_SH_RS;
d8489 1
a8489 1
		  ip->insn_opcode |= lastregno << OP_SH_RT;
d8498 3
a8500 6
		{
		  as_warn ("Improper align amount (%ld), using low bits",
			   (long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= OP_MASK_ALN;
		}
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_ALN;
d8512 3
a8514 6
		    {
		      as_warn (_("Invalid MDMX Immediate (%ld)"),
			       (long) imm_expr.X_add_number);
		      imm_expr.X_add_number &= OP_MASK_FT;
		    }
		  imm_expr.X_add_number &= OP_MASK_FT;
a8518 1
		  ip->insn_opcode |= imm_expr.X_add_number << OP_SH_FT;
d8581 1
a8581 1
		      ip->insn_opcode |= regno << OP_SH_FD;
d8586 1
a8586 1
		      ip->insn_opcode |= regno << OP_SH_FS;
d8626 1
a8626 1
		      ip->insn_opcode |= regno << OP_SH_FT;
d8629 1
a8629 1
		      ip->insn_opcode |= regno << OP_SH_FR;
d8639 1
a8639 1
		  ip->insn_opcode |= lastregno << OP_SH_FS;
d8642 1
a8642 1
		  ip->insn_opcode |= lastregno << OP_SH_FT;
d8972 1
a8972 1
		ip->insn_opcode |= regno << OP_SH_BCC;
d8974 1
a8974 1
		ip->insn_opcode |= regno << OP_SH_CCC;
d9012 1
a9012 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_VECBYTE;
d9029 1
a9029 1
	      ip->insn_opcode |= imm_expr.X_add_number << OP_SH_VECALIGN;
d9205 1
a9205 1
		  ip->insn_opcode |= lastregno << MIPS16OP_SH_RX;
d9208 1
a9208 1
		  ip->insn_opcode |= lastregno << MIPS16OP_SH_RY;
d9224 1
a9224 1
		    ip->insn_opcode |= lastregno << MIPS16OP_SH_RX;
d9226 1
a9226 1
		    ip->insn_opcode |= lastregno << MIPS16OP_SH_RY;
d9361 1
a9361 1
		  ip->insn_opcode |= regno << MIPS16OP_SH_RX;
d9365 1
a9365 1
		  ip->insn_opcode |= regno << MIPS16OP_SH_RY;
d9368 1
a9368 1
		  ip->insn_opcode |= regno << MIPS16OP_SH_RZ;
d9371 1
a9371 1
		  ip->insn_opcode |= regno << MIPS16OP_SH_MOVE32Z;
d9377 1
a9377 1
		  ip->insn_opcode |= regno << MIPS16OP_SH_REGR32;
d9381 1
a9381 1
		  ip->insn_opcode |= regno << MIPS16OP_SH_REG32R;
d9483 4
a9486 7
		{
		  as_warn (_("Invalid value for `%s' (%lu)"),
			   ip->insn_mo->name,
			   (unsigned long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= 0x3f;
		}
	      ip->insn_opcode |= imm_expr.X_add_number << MIPS16OP_SH_IMM6;
@


1.293
log
@	* config/tc-mips.c (mips_cl_insn): Replace reloc_type array with
	a single mips16_absolute_jump_p bit.
	(append_insn): Adjust accordingly.
@
text
@d149 2
a150 2
  /* True if this entry describes a real instruction.  */
  unsigned int valid_p : 1;
a154 7
  /* True if this instruction corresponds to an assembler-filled
     delay slot.  Always false if noreorder_p.  */
  unsigned int delay_slot_p : 1;

  /* True for extended mips16 instructions.  */
  unsigned int extended_p : 1;

d2353 3
a2355 6
	      /* If we don't even know the previous insn, we can not
		 swap.  */
	      || ! history[0].valid_p
	      /* If the previous insn is already in a branch delay
		 slot, then we can not swap.  */
	      || history[0].delay_slot_p
d2367 1
a2367 5
		 .set pseudo-ops.  We don't have to check
		 history[0].noreorder_p, because history[0].valid_p will
		 be 0 in that case.  We don't want to use
		 history[1].valid_p, because we do want to be able
		 to swap at the start of a function.  */
a2530 3
	      /* If the previous instruction was extended, we can not
                 swap.  */
	      || (mips_opts.mips16 && history[0].extended_p)
d2686 1
a2686 1
	  history[0].delay_slot_p = 1;
a2699 1
	  history[0].extended_p = 0;
d2718 1
a2718 2
	  history[0].extended_p = 0;
	  history[0].delay_slot_p = 1;
d2736 3
a2738 6

	  /* Any time we see a branch, we always fill the delay slot
	     immediately; since this insn is not a branch, we know it
	     is not in a delay slot.  */
	  history[0].delay_slot_p = 0;

a2743 3
	  if (mips_opts.mips16)
	    history[0].extended_p = (ip->use_extend
				     || *reloc_type > BFD_RELOC_UNUSED);
a2749 1
      history[0].valid_p = 1;
d2768 1
d2791 1
a2791 2
  history[0].valid_p = 0;
  history[0].delay_slot_p = 0;
a2792 1
  history[0].extended_p = 0;
@


1.292
log
@	* config/tc-mips.h (mips_cl_insn): Move definition to...
	* config/tc-mips.c (mips_cl_insn): ...here.  Add new fields:
	frag, where, fixp, reloc_type, valid_p, noreorder_p, delay_slot_p
	and extended_p.
	(history): New variable.
	(prev_insn, prev_prev_insn, prev_insn_valid, prev_insn_frag)
	(prev_insn_where, prev_insn_reloc_type, prev_insn_fixp)
	(prev_insn_is_delay_slot, prev_insn_unreordered, prev_insn_extended)
	(prev_prev_insn_unreordered): Delete.
	(reg_needs_delay, append_insn, mips_no_prev_insn, mips_emit_delays)
	(macro_start): Replace uses of prev_insn* with the equivalent history[]
	field.
@
text
@a148 3
  /* The reloc types associated with the instruction.  */
  bfd_reloc_code_real_type reloc_type[3];

d161 3
d2079 1
a2079 2
					 (*history[0].reloc_type
					  == BFD_RELOC_MIPS16_JMP)),
d2716 1
a2716 3
	  history[0].reloc_type[0] = BFD_RELOC_UNUSED;
	  history[0].reloc_type[1] = BFD_RELOC_UNUSED;
	  history[0].reloc_type[2] = BFD_RELOC_UNUSED;
d2735 1
a2735 3
	  history[0].reloc_type[0] = BFD_RELOC_UNUSED;
	  history[0].reloc_type[1] = BFD_RELOC_UNUSED;
	  history[0].reloc_type[2] = BFD_RELOC_UNUSED;
d2764 2
a2765 3
	  history[0].reloc_type[0] = reloc_type[0];
	  history[0].reloc_type[1] = reloc_type[1];
	  history[0].reloc_type[2] = reloc_type[2];
d2790 2
a2791 3
      history[0].reloc_type[0] = reloc_type[0];
      history[0].reloc_type[1] = reloc_type[1];
      history[0].reloc_type[2] = reloc_type[2];
d2820 1
a2820 3
  history[0].reloc_type[0] = BFD_RELOC_UNUSED;
  history[0].reloc_type[1] = BFD_RELOC_UNUSED;
  history[0].reloc_type[2] = BFD_RELOC_UNUSED;
@


1.291
log
@	bfd/ChangeLog
	* elfxx-mips.c (mips_elf_calculate_relocation): Handle special
	'__gnu_local_gp' symbol used by gas -mno-shared.

	gas/ChangeLog
	* config/tc-mips.c (macro_build_lui): Use '__gnu_local_gp'
	instead of '_gp' for -mno-shared optimization.
	(s_cpload): Ditto.
	(s_abicalls): Document it in the comment.
	(md_show_usage): Document the -mno-shared option.

	gas/testsuite/ChangeLog
	* gas/mips/elf-rel23b.d: Use '__gnu_local_gp' instead of '_gp'
	for -mno-shared optimization.
	* gas/mips/elf-rel25a.d: Ditto.

	ld/testsuite/ChangeLog
	* ld-mips-elf/multi-got-no-shared-1.s,
	ld-mips-elf/multi-got-no-shared-2.s,
	ld-mips-elf/multi-got-no-shared.d: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d122 44
d567 2
a568 2
/* The previous instruction.  */
static struct mips_cl_insn prev_insn;
d570 1
a570 4
/* The instruction before prev_insn.  */
static struct mips_cl_insn prev_prev_insn;

/* If we don't want information for prev_insn or prev_prev_insn, we
a573 29
/* Non-zero if prev_insn is valid.  */
static int prev_insn_valid;

/* The frag for the previous instruction.  */
static struct frag *prev_insn_frag;

/* The offset into prev_insn_frag for the previous instruction.  */
static long prev_insn_where;

/* The reloc type for the previous instruction, if any.  */
static bfd_reloc_code_real_type prev_insn_reloc_type[3];

/* The reloc for the previous instruction, if any.  */
static fixS *prev_insn_fixp[3];

/* Non-zero if the previous instruction was in a delay slot.  */
static int prev_insn_is_delay_slot;

/* Non-zero if the previous instruction was in a .set noreorder.  */
static int prev_insn_unreordered;

/* Non-zero if the previous instruction uses an extend opcode (if
   mips16).  */
static int prev_insn_extended;

/* Non-zero if the previous previous instruction was in a .set
   noreorder.  */
static int prev_prev_insn_unreordered;

d1530 1
a1530 1
  prev_pinfo = prev_insn.insn_mo->pinfo;
d1541 1
a1541 1
      if (reg == ((prev_insn.insn_opcode >> OP_SH_RT) & OP_MASK_RT))
d1642 1
a1642 1
  prev_pinfo = prev_insn.insn_mo->pinfo;
d1691 1
a1691 1
				((prev_insn.insn_opcode >> OP_SH_RT)
d1720 1
a1720 1
				    ((prev_insn.insn_opcode >> OP_SH_FT)
d1729 1
a1729 1
				    ((prev_insn.insn_opcode >> OP_SH_FS)
d1773 1
a1773 1
	       && insn_uses_reg (ip, ((prev_insn.insn_opcode >> OP_SH_RD)
d1786 2
a1787 2
	       && MF_HILO_INSN (prev_prev_insn.insn_opcode)
	       && insn_uses_reg (ip, ((prev_prev_insn.insn_opcode >> OP_SH_RD)
d1820 1
a1820 1
      else if (prev_insn.insn_mo->pinfo & INSN_READ_HI)
d1846 1
a1846 1
      if (prev_insn_unreordered)
d1858 2
a1859 2
	   && (prev_prev_insn.insn_mo->pinfo & INSN_COPROC_MOVE_DELAY)
	   && (prev_prev_insn.insn_mo->pinfo & INSN_WRITE_COND_CODE)
d1862 1
a1862 1
	  || ((prev_prev_insn.insn_mo->pinfo & INSN_READ_LO)
d1866 1
a1866 1
	  || ((prev_prev_insn.insn_mo->pinfo & INSN_READ_HI)
d1874 1
a1874 1
      if (prev_prev_insn_unreordered)
d1880 1
a1880 1
      if (mips_fix_vr4120 && prev_insn.insn_mo->name)
d1886 1
a1886 1
	  const char *pn = prev_insn.insn_mo->name;
d2039 2
a2040 2
  if (prev_insn_frag)
    prev_insn_frag_type = prev_insn_frag->fr_type;
d2079 1
a2079 1
					 (*prev_insn_reloc_type
d2363 1
a2363 1
	      || ! prev_insn_valid
d2366 1
a2366 1
	      || prev_insn_is_delay_slot
d2379 1
a2379 1
		 prev_insn_unreordered, because prev_insn_valid will
d2381 1
a2381 1
		 prev_prev_insn_valid, because we do want to be able
d2383 1
a2383 1
	      || prev_prev_insn_unreordered
d2443 1
a2443 1
				    ((prev_insn.insn_opcode >> OP_SH_RT)
d2449 1
a2449 1
				    ((prev_insn.insn_opcode >> OP_SH_RD)
d2455 1
a2455 1
					 ((prev_insn.insn_opcode
d2461 1
a2461 1
					    ((prev_insn.insn_opcode
d2467 1
a2467 1
					    ((prev_insn.insn_opcode
d2477 2
a2478 2
					    MIPS16OP_EXTRACT_REG32R (prev_insn.
								     insn_opcode),
d2486 1
a2486 1
		       && (((prev_insn.insn_opcode >> OP_SH_RT) & OP_MASK_RT)
d2489 1
a2489 1
			  && (((prev_insn.insn_opcode >> OP_SH_RT)
d2495 1
a2495 1
		       && (((prev_insn.insn_opcode >> OP_SH_RD) & OP_MASK_RD)
d2498 1
a2498 1
			  && (((prev_insn.insn_opcode >> OP_SH_RD)
d2505 1
a2505 1
			  && (MIPS16OP_EXTRACT_REG32R (prev_insn.insn_opcode)
d2512 1
a2512 1
		  && insn_uses_reg (&prev_insn,
d2518 1
a2518 1
		  && insn_uses_reg (&prev_insn, RA, MIPS_GR_REG))
d2521 1
a2521 1
		  && insn_uses_reg (&prev_insn, RA, MIPS_GR_REG))
d2527 1
a2527 1
		  && (((prev_prev_insn.insn_mo->pinfo & INSN_LOAD_COPROC_DELAY)
d2529 1
a2529 1
		      || ((prev_prev_insn.insn_mo->pinfo
d2533 1
a2533 1
				    ((prev_prev_insn.insn_opcode >> OP_SH_RT)
d2548 1
a2548 1
	      || (mips_opts.mips16 && prev_insn_extended)
d2552 1
a2552 1
	      || (mips_opts.mips16 && prev_insn_fixp[0])
d2565 5
a2569 2
	      prev_prev_insn = *ip;
	      prev_insn.insn_mo = &dummy_opcode;
d2579 1
a2579 1
		  prev_f = prev_insn_frag->fr_literal + prev_insn_where;
d2598 3
a2600 3
		      prev_insn_frag->fr_fix -= 4;
		      if (prev_insn_frag->fr_type == rs_machine_dependent)
			memmove (prev_f, prev_f + 4, prev_insn_frag->fr_var);
d2603 1
a2603 1
		  if (prev_insn_fixp[0])
d2605 2
a2606 2
		      prev_insn_fixp[0]->fx_frag = frag_now;
		      prev_insn_fixp[0]->fx_where = f - frag_now->fr_literal;
d2608 1
a2608 1
		  if (prev_insn_fixp[1])
d2610 2
a2611 2
		      prev_insn_fixp[1]->fx_frag = frag_now;
		      prev_insn_fixp[1]->fx_where = f - frag_now->fr_literal;
d2613 1
a2613 1
		  if (prev_insn_fixp[2])
d2615 2
a2616 2
		      prev_insn_fixp[2]->fx_frag = frag_now;
		      prev_insn_fixp[2]->fx_where = f - frag_now->fr_literal;
d2618 3
a2620 3
		  if (prev_insn_fixp[0] && HAVE_NEWABI
		      && prev_insn_frag != frag_now
		      && (prev_insn_fixp[0]->fx_r_type
d2622 1
a2622 1
			  || (prev_insn_fixp[0]->fx_r_type
d2635 2
a2636 2
			  fixp[0]->fx_frag = prev_insn_frag;
			  fixp[0]->fx_where = prev_insn_where;
d2640 2
a2641 2
			  fixp[1]->fx_frag = prev_insn_frag;
			  fixp[1]->fx_where = prev_insn_where;
d2645 2
a2646 2
			  fixp[2]->fx_frag = prev_insn_frag;
			  fixp[2]->fx_where = prev_insn_where;
d2649 1
a2649 1
		  else if (prev_insn_frag->fr_type == rs_machine_dependent)
d2664 4
a2667 4
		  assert (prev_insn_fixp[0] == NULL);
		  assert (prev_insn_fixp[1] == NULL);
		  assert (prev_insn_fixp[2] == NULL);
		  prev_f = prev_insn_frag->fr_literal + prev_insn_where;
d2682 2
a2683 2
		      fixp[0]->fx_frag = prev_insn_frag;
		      fixp[0]->fx_where = prev_insn_where;
d2687 2
a2688 2
		      fixp[1]->fx_frag = prev_insn_frag;
		      fixp[1]->fx_where = prev_insn_where;
d2692 2
a2693 2
		      fixp[2]->fx_frag = prev_insn_frag;
		      fixp[2]->fx_where = prev_insn_where;
d2697 1
a2697 1
	      /* Update the previous insn information; leave prev_insn
d2699 4
a2702 1
	      prev_prev_insn = *ip;
d2704 1
a2704 1
	  prev_insn_is_delay_slot = 1;
d2710 2
a2711 2
	      prev_prev_insn.insn_mo = &dummy_opcode;
	      prev_insn.insn_mo = &dummy_opcode;
d2714 7
a2720 7
	  prev_insn_fixp[0] = NULL;
	  prev_insn_fixp[1] = NULL;
	  prev_insn_fixp[2] = NULL;
	  prev_insn_reloc_type[0] = BFD_RELOC_UNUSED;
	  prev_insn_reloc_type[1] = BFD_RELOC_UNUSED;
	  prev_insn_reloc_type[2] = BFD_RELOC_UNUSED;
	  prev_insn_extended = 0;
d2730 13
a2742 10
	  prev_prev_insn = *ip;
	  prev_insn.insn_mo = &dummy_opcode;
	  prev_insn_fixp[0] = NULL;
	  prev_insn_fixp[1] = NULL;
	  prev_insn_fixp[2] = NULL;
	  prev_insn_reloc_type[0] = BFD_RELOC_UNUSED;
	  prev_insn_reloc_type[1] = BFD_RELOC_UNUSED;
	  prev_insn_reloc_type[2] = BFD_RELOC_UNUSED;
	  prev_insn_extended = 0;
	  prev_insn_is_delay_slot = 1;
d2748 1
a2748 1
	    prev_prev_insn.insn_mo = &dummy_opcode;
d2750 10
a2759 2
	    prev_prev_insn = prev_insn;
	  prev_insn = *ip;
d2764 1
a2764 1
	  prev_insn_is_delay_slot = 0;
d2766 6
a2771 6
	  prev_insn_fixp[0] = fixp[0];
	  prev_insn_fixp[1] = fixp[1];
	  prev_insn_fixp[2] = fixp[2];
	  prev_insn_reloc_type[0] = reloc_type[0];
	  prev_insn_reloc_type[1] = reloc_type[1];
	  prev_insn_reloc_type[2] = reloc_type[2];
d2773 2
a2774 2
	    prev_insn_extended = (ip->use_extend
				  || *reloc_type > BFD_RELOC_UNUSED);
d2777 5
a2781 5
      prev_prev_insn_unreordered = prev_insn_unreordered;
      prev_insn_unreordered = 0;
      prev_insn_frag = frag_now;
      prev_insn_where = f - frag_now->fr_literal;
      prev_insn_valid = 1;
d2788 13
a2800 7
      prev_prev_insn = prev_insn;
      prev_insn = *ip;
      prev_insn_reloc_type[0] = reloc_type[0];
      prev_insn_reloc_type[1] = reloc_type[1];
      prev_insn_reloc_type[2] = reloc_type[2];
      prev_prev_insn_unreordered = prev_insn_unreordered;
      prev_insn_unreordered = 1;
d2816 2
a2817 2
      prev_insn.insn_mo = &dummy_opcode;
      prev_prev_insn.insn_mo = &dummy_opcode;
d2823 8
a2830 8
  prev_insn_valid = 0;
  prev_insn_is_delay_slot = 0;
  prev_insn_unreordered = 0;
  prev_insn_extended = 0;
  prev_insn_reloc_type[0] = BFD_RELOC_UNUSED;
  prev_insn_reloc_type[1] = BFD_RELOC_UNUSED;
  prev_insn_reloc_type[2] = BFD_RELOC_UNUSED;
  prev_prev_insn_unreordered = 0;
d2849 1
a2849 1
	   && ((prev_insn.insn_mo->pinfo
d2855 1
a2855 1
	      && (prev_insn.insn_mo->pinfo
d2859 1
a2859 1
	      && (prev_insn.insn_mo->pinfo & INSN_LOAD_MEMORY_DELAY)
d2862 1
a2862 1
	      && (prev_insn.insn_mo->pinfo & INSN_COPROC_MEMORY_DELAY)
d2868 1
a2868 1
	       && ((prev_insn.insn_mo->pinfo & INSN_WRITE_COND_CODE)
d2871 2
a2872 2
		  && ((prev_insn.insn_mo->pinfo & INSN_READ_HI)
		      || (prev_insn.insn_mo->pinfo & INSN_READ_LO))))
d2875 1
a2875 1
	  if (prev_insn_unreordered)
d2879 1
a2879 1
		&& ((prev_prev_insn.insn_mo->pinfo & INSN_WRITE_COND_CODE)
d2882 2
a2883 2
		   && ((prev_prev_insn.insn_mo->pinfo & INSN_READ_HI)
		       || (prev_prev_insn.insn_mo->pinfo & INSN_READ_LO))))
d2886 1
a2886 1
	  if (! prev_prev_insn_unreordered)
d2890 1
a2890 1
      if (mips_fix_vr4120 && prev_insn.insn_mo->name)
d2893 1
a2893 1
	  const char *pn = prev_insn.insn_mo->name;
d2958 1
a2958 1
				     && (prev_insn.insn_mo->pinfo
@


1.291.2.1
log
@	* config/tc-mips.h (mips_cl_insn): Move definition to...
	* config/tc-mips.c (mips_cl_insn): ...here.  Add new fields:
	frag, where, fixp, reloc_type, valid_p, noreorder_p, delay_slot_p
	and extended_p.
	(history): New variable.
	(prev_insn, prev_prev_insn, prev_insn_valid, prev_insn_frag)
	(prev_insn_where, prev_insn_reloc_type, prev_insn_fixp)
	(prev_insn_is_delay_slot, prev_insn_unreordered, prev_insn_extended)
	(prev_prev_insn_unreordered): Delete.
	(reg_needs_delay, append_insn, mips_no_prev_insn, mips_emit_delays)
	(macro_start): Replace uses of prev_insn* with the equivalent history[]
	field.
@
text
@a121 44
/* Information about an instruction, including its format, operands
   and fixups.  */
struct mips_cl_insn
{
  /* The opcode's entry in mips_opcodes or mips16_opcodes.  */
  const struct mips_opcode *insn_mo;

  /* True if this is a mips16 instruction and if we want the extended
     form of INSN_MO.  */
  bfd_boolean use_extend;

  /* The 16-bit extension instruction to use when USE_EXTEND is true.  */
  unsigned short extend;

  /* The 16-bit or 32-bit bitstring of the instruction itself.  This is
     a copy of INSN_MO->match with the operands filled in.  */
  unsigned long insn_opcode;

  /* The frag that contains the instruction.  */
  struct frag *frag;

  /* The offset into FRAG of the first instruction byte.  */
  long where;

  /* The relocs associated with the instruction, if any.  */
  fixS *fixp[3];

  /* The reloc types associated with the instruction.  */
  bfd_reloc_code_real_type reloc_type[3];

  /* True if this entry describes a real instruction.  */
  unsigned int valid_p : 1;

  /* True if this instruction occured in a .set noreorder block.  */
  unsigned int noreorder_p : 1;

  /* True if this instruction corresponds to an assembler-filled
     delay slot.  Always false if noreorder_p.  */
  unsigned int delay_slot_p : 1;

  /* True for extended mips16 instructions.  */
  unsigned int extended_p : 1;
};

d523 2
a524 2
/* A list of previous instructions, with index 0 being the most recent.  */
static struct mips_cl_insn history[2];
d526 4
a529 1
/* If we don't want information for a history[] entry, we
d533 29
d1518 1
a1518 1
  prev_pinfo = history[0].insn_mo->pinfo;
d1529 1
a1529 1
      if (reg == ((history[0].insn_opcode >> OP_SH_RT) & OP_MASK_RT))
d1630 1
a1630 1
  prev_pinfo = history[0].insn_mo->pinfo;
d1679 1
a1679 1
				((history[0].insn_opcode >> OP_SH_RT)
d1708 1
a1708 1
				    ((history[0].insn_opcode >> OP_SH_FT)
d1717 1
a1717 1
				    ((history[0].insn_opcode >> OP_SH_FS)
d1761 1
a1761 1
	       && insn_uses_reg (ip, ((history[0].insn_opcode >> OP_SH_RD)
d1774 2
a1775 2
	       && MF_HILO_INSN (history[1].insn_opcode)
	       && insn_uses_reg (ip, ((history[1].insn_opcode >> OP_SH_RD)
d1808 1
a1808 1
      else if (history[0].insn_mo->pinfo & INSN_READ_HI)
d1834 1
a1834 1
      if (history[0].noreorder_p)
d1846 2
a1847 2
	   && (history[1].insn_mo->pinfo & INSN_COPROC_MOVE_DELAY)
	   && (history[1].insn_mo->pinfo & INSN_WRITE_COND_CODE)
d1850 1
a1850 1
	  || ((history[1].insn_mo->pinfo & INSN_READ_LO)
d1854 1
a1854 1
	  || ((history[1].insn_mo->pinfo & INSN_READ_HI)
d1862 1
a1862 1
      if (history[1].noreorder_p)
d1868 1
a1868 1
      if (mips_fix_vr4120 && history[0].insn_mo->name)
d1874 1
a1874 1
	  const char *pn = history[0].insn_mo->name;
d2027 2
a2028 2
  if (history[0].frag)
    prev_insn_frag_type = history[0].frag->fr_type;
d2067 1
a2067 1
					 (*history[0].reloc_type
d2351 1
a2351 1
	      || ! history[0].valid_p
d2354 1
a2354 1
	      || history[0].delay_slot_p
d2367 1
a2367 1
		 history[0].noreorder_p, because history[0].valid_p will
d2369 1
a2369 1
		 history[1].valid_p, because we do want to be able
d2371 1
a2371 1
	      || history[1].noreorder_p
d2431 1
a2431 1
				    ((history[0].insn_opcode >> OP_SH_RT)
d2437 1
a2437 1
				    ((history[0].insn_opcode >> OP_SH_RD)
d2443 1
a2443 1
					 ((history[0].insn_opcode
d2449 1
a2449 1
					    ((history[0].insn_opcode
d2455 1
a2455 1
					    ((history[0].insn_opcode
d2465 2
a2466 2
					    MIPS16OP_EXTRACT_REG32R
					      (history[0].insn_opcode),
d2474 1
a2474 1
		       && (((history[0].insn_opcode >> OP_SH_RT) & OP_MASK_RT)
d2477 1
a2477 1
			  && (((history[0].insn_opcode >> OP_SH_RT)
d2483 1
a2483 1
		       && (((history[0].insn_opcode >> OP_SH_RD) & OP_MASK_RD)
d2486 1
a2486 1
			  && (((history[0].insn_opcode >> OP_SH_RD)
d2493 1
a2493 1
			  && (MIPS16OP_EXTRACT_REG32R (history[0].insn_opcode)
d2500 1
a2500 1
		  && insn_uses_reg (&history[0],
d2506 1
a2506 1
		  && insn_uses_reg (&history[0], RA, MIPS_GR_REG))
d2509 1
a2509 1
		  && insn_uses_reg (&history[0], RA, MIPS_GR_REG))
d2515 1
a2515 1
		  && (((history[1].insn_mo->pinfo & INSN_LOAD_COPROC_DELAY)
d2517 1
a2517 1
		      || ((history[1].insn_mo->pinfo
d2521 1
a2521 1
				    ((history[1].insn_opcode >> OP_SH_RT)
d2536 1
a2536 1
	      || (mips_opts.mips16 && history[0].extended_p)
d2540 1
a2540 1
	      || (mips_opts.mips16 && history[0].fixp[0])
d2553 2
a2554 5
	      history[1].insn_mo = ip->insn_mo;
	      history[1].use_extend = ip->use_extend;
	      history[1].extend = ip->extend;
	      history[1].insn_opcode = ip->insn_opcode;
	      history[0].insn_mo = &dummy_opcode;
d2564 1
a2564 1
		  prev_f = history[0].frag->fr_literal + history[0].where;
d2583 3
a2585 3
		      history[0].frag->fr_fix -= 4;
		      if (history[0].frag->fr_type == rs_machine_dependent)
			memmove (prev_f, prev_f + 4, history[0].frag->fr_var);
d2588 1
a2588 1
		  if (history[0].fixp[0])
d2590 2
a2591 2
		      history[0].fixp[0]->fx_frag = frag_now;
		      history[0].fixp[0]->fx_where = f - frag_now->fr_literal;
d2593 1
a2593 1
		  if (history[0].fixp[1])
d2595 2
a2596 2
		      history[0].fixp[1]->fx_frag = frag_now;
		      history[0].fixp[1]->fx_where = f - frag_now->fr_literal;
d2598 1
a2598 1
		  if (history[0].fixp[2])
d2600 2
a2601 2
		      history[0].fixp[2]->fx_frag = frag_now;
		      history[0].fixp[2]->fx_where = f - frag_now->fr_literal;
d2603 3
a2605 3
		  if (history[0].fixp[0] && HAVE_NEWABI
		      && history[0].frag != frag_now
		      && (history[0].fixp[0]->fx_r_type
d2607 1
a2607 1
			  || (history[0].fixp[0]->fx_r_type
d2620 2
a2621 2
			  fixp[0]->fx_frag = history[0].frag;
			  fixp[0]->fx_where = history[0].where;
d2625 2
a2626 2
			  fixp[1]->fx_frag = history[0].frag;
			  fixp[1]->fx_where = history[0].where;
d2630 2
a2631 2
			  fixp[2]->fx_frag = history[0].frag;
			  fixp[2]->fx_where = history[0].where;
d2634 1
a2634 1
		  else if (history[0].frag->fr_type == rs_machine_dependent)
d2649 4
a2652 4
		  assert (history[0].fixp[0] == NULL);
		  assert (history[0].fixp[1] == NULL);
		  assert (history[0].fixp[2] == NULL);
		  prev_f = history[0].frag->fr_literal + history[0].where;
d2667 2
a2668 2
		      fixp[0]->fx_frag = history[0].frag;
		      fixp[0]->fx_where = history[0].where;
d2672 2
a2673 2
		      fixp[1]->fx_frag = history[0].frag;
		      fixp[1]->fx_where = history[0].where;
d2677 2
a2678 2
		      fixp[2]->fx_frag = history[0].frag;
		      fixp[2]->fx_where = history[0].where;
d2682 1
a2682 1
	      /* Update the previous insn information; leave history[0]
d2684 1
a2684 4
	      history[1].insn_mo = ip->insn_mo;
	      history[1].use_extend = ip->use_extend;
	      history[1].extend = ip->extend;
	      history[1].insn_opcode = ip->insn_opcode;
d2686 1
a2686 1
	  history[0].delay_slot_p = 1;
d2692 2
a2693 2
	      history[1].insn_mo = &dummy_opcode;
	      history[0].insn_mo = &dummy_opcode;
d2696 7
a2702 7
	  history[0].fixp[0] = NULL;
	  history[0].fixp[1] = NULL;
	  history[0].fixp[2] = NULL;
	  history[0].reloc_type[0] = BFD_RELOC_UNUSED;
	  history[0].reloc_type[1] = BFD_RELOC_UNUSED;
	  history[0].reloc_type[2] = BFD_RELOC_UNUSED;
	  history[0].extended_p = 0;
d2712 10
a2721 13
	  history[1].insn_mo = ip->insn_mo;
	  history[1].use_extend = ip->use_extend;
	  history[1].extend = ip->extend;
	  history[1].insn_opcode = ip->insn_opcode;
	  history[0].insn_mo = &dummy_opcode;
	  history[0].fixp[0] = NULL;
	  history[0].fixp[1] = NULL;
	  history[0].fixp[2] = NULL;
	  history[0].reloc_type[0] = BFD_RELOC_UNUSED;
	  history[0].reloc_type[1] = BFD_RELOC_UNUSED;
	  history[0].reloc_type[2] = BFD_RELOC_UNUSED;
	  history[0].extended_p = 0;
	  history[0].delay_slot_p = 1;
d2727 1
a2727 1
	    history[1].insn_mo = &dummy_opcode;
d2729 2
a2730 10
	    {
	      history[1].insn_mo = history[0].insn_mo;
	      history[1].use_extend = history[0].use_extend;
	      history[1].extend = history[0].extend;
	      history[1].insn_opcode = history[0].insn_opcode;
	    }
	  history[0].insn_mo = ip->insn_mo;
	  history[0].use_extend = ip->use_extend;
	  history[0].extend = ip->extend;
	  history[0].insn_opcode = ip->insn_opcode;
d2735 1
a2735 1
	  history[0].delay_slot_p = 0;
d2737 6
a2742 6
	  history[0].fixp[0] = fixp[0];
	  history[0].fixp[1] = fixp[1];
	  history[0].fixp[2] = fixp[2];
	  history[0].reloc_type[0] = reloc_type[0];
	  history[0].reloc_type[1] = reloc_type[1];
	  history[0].reloc_type[2] = reloc_type[2];
d2744 2
a2745 2
	    history[0].extended_p = (ip->use_extend
				     || *reloc_type > BFD_RELOC_UNUSED);
d2748 5
a2752 5
      history[1].noreorder_p = history[0].noreorder_p;
      history[0].noreorder_p = 0;
      history[0].frag = frag_now;
      history[0].where = f - frag_now->fr_literal;
      history[0].valid_p = 1;
d2759 7
a2765 13
      history[1].insn_mo = history[0].insn_mo;
      history[1].use_extend = history[0].use_extend;
      history[1].extend = history[0].extend;
      history[1].insn_opcode = history[0].insn_opcode;
      history[0].insn_mo = ip->insn_mo;
      history[0].use_extend = ip->use_extend;
      history[0].extend = ip->extend;
      history[0].insn_opcode = ip->insn_opcode;
      history[0].reloc_type[0] = reloc_type[0];
      history[0].reloc_type[1] = reloc_type[1];
      history[0].reloc_type[2] = reloc_type[2];
      history[1].noreorder_p = history[0].noreorder_p;
      history[0].noreorder_p = 1;
d2781 2
a2782 2
      history[0].insn_mo = &dummy_opcode;
      history[1].insn_mo = &dummy_opcode;
d2788 8
a2795 8
  history[0].valid_p = 0;
  history[0].delay_slot_p = 0;
  history[0].noreorder_p = 0;
  history[0].extended_p = 0;
  history[0].reloc_type[0] = BFD_RELOC_UNUSED;
  history[0].reloc_type[1] = BFD_RELOC_UNUSED;
  history[0].reloc_type[2] = BFD_RELOC_UNUSED;
  history[1].noreorder_p = 0;
d2814 1
a2814 1
	   && ((history[0].insn_mo->pinfo
d2820 1
a2820 1
	      && (history[0].insn_mo->pinfo
d2824 1
a2824 1
	      && (history[0].insn_mo->pinfo & INSN_LOAD_MEMORY_DELAY)
d2827 1
a2827 1
	      && (history[0].insn_mo->pinfo & INSN_COPROC_MEMORY_DELAY)
d2833 1
a2833 1
	       && ((history[0].insn_mo->pinfo & INSN_WRITE_COND_CODE)
d2836 2
a2837 2
		  && ((history[0].insn_mo->pinfo & INSN_READ_HI)
		      || (history[0].insn_mo->pinfo & INSN_READ_LO))))
d2840 1
a2840 1
	  if (history[0].noreorder_p)
d2844 1
a2844 1
		&& ((history[1].insn_mo->pinfo & INSN_WRITE_COND_CODE)
d2847 2
a2848 2
		   && ((history[1].insn_mo->pinfo & INSN_READ_HI)
		       || (history[1].insn_mo->pinfo & INSN_READ_LO))))
d2851 1
a2851 1
	  if (! history[1].noreorder_p)
d2855 1
a2855 1
      if (mips_fix_vr4120 && history[0].insn_mo->name)
d2858 1
a2858 1
	  const char *pn = history[0].insn_mo->name;
d2923 1
a2923 1
				     && (history[0].insn_mo->pinfo
@


1.291.2.2
log
@	* config/tc-mips.c (mips_cl_insn): Replace reloc_type array with
	a single mips16_absolute_jump_p bit.
	(append_insn): Adjust accordingly.
@
text
@d149 3
a163 3

  /* True for mips16 instructions that jump to an absolute address.  */
  unsigned int mips16_absolute_jump_p : 1;
d2079 2
a2080 1
					 history[0].mips16_absolute_jump_p),
d2717 3
a2719 1
	  history[0].mips16_absolute_jump_p = 0;
d2738 3
a2740 1
	  history[0].mips16_absolute_jump_p = 0;
d2769 3
a2771 2
	  history[0].mips16_absolute_jump_p = (reloc_type[0]
					       == BFD_RELOC_MIPS16_JMP);
d2796 3
a2798 2
      history[0].mips16_absolute_jump_p = (reloc_type[0]
					   == BFD_RELOC_MIPS16_JMP);
d2827 3
a2829 1
  history[0].mips16_absolute_jump_p = 0;
@


1.291.2.3
log
@	* config/tc-mips.c (mips_cl_insn): Replace the valid_p, delay_slot_p
	and extended_p fields with a single fixed_p field.
	(append_insn, mips_no_prev_insn): Adjust accordingly.
@
text
@d149 2
a150 2
  /* True if this entry cannot be moved from its current position.  */
  unsigned int fixed_p : 1;
d155 7
d2360 6
a2365 3
	      /* We can't swap if the previous instruction's position
		 is fixed.  */
	      || history[0].fixed_p
d2377 5
a2381 1
		 .set pseudo-ops.  */
d2545 3
d2703 1
a2703 1
	  history[0].fixed_p = 1;
d2717 1
d2736 2
a2737 1
	  history[0].fixed_p = 1;
d2755 6
a2760 3
	  history[0].fixed_p = (mips_opts.mips16
				&& (ip->use_extend
				    || *reloc_type > BFD_RELOC_UNUSED));
d2766 3
d2775 1
a2793 1
      history[0].fixed_p = 1;
d2816 2
a2817 1
  history[0].fixed_p = 1;
d2819 1
@


1.291.2.4
log
@	* config/tc-mips.c (INSERT_BITS, EXTRACT_BITS, INSERT_OPERAND)
	(EXTRACT_OPERAND, MIPS16_INSERT_OPERAND, MIPS16_EXTRACT_OPERAND): New.
	(insn_uses_reg, reg_needs_delay, append_insn, macro_build)
	(mips16_macro_build, macro_build_lui, mips16_macro, mips_ip)
	(mips16_ip): Use the new macros instead of explicit masks and shifts.
@
text
@a826 30
/* Replace bits MASK << SHIFT of STRUCT with the equivalent bits in
   VALUE << SHIFT.  VALUE is evaluated exactly once.  */
#define INSERT_BITS(STRUCT, VALUE, MASK, SHIFT) \
  (STRUCT) = (((STRUCT) & ~((MASK) << (SHIFT))) \
	      | (((VALUE) & (MASK)) << (SHIFT)))

/* Extract bits MASK << SHIFT from STRUCT and shift them right
   SHIFT places.  */
#define EXTRACT_BITS(STRUCT, MASK, SHIFT) \
  (((STRUCT) >> (SHIFT)) & (MASK))

/* Change INSN's opcode so that the operand given by FIELD has value VALUE.
   INSN is a mips_cl_insn structure and VALUE is evaluated exactly once.

   include/opcode/mips.h specifies operand fields using the macros
   OP_MASK_<FIELD> and OP_SH_<FIELD>.  The MIPS16 equivalents start
   with "MIPS16OP" instead of "OP".  */
#define INSERT_OPERAND(FIELD, INSN, VALUE) \
  INSERT_BITS ((INSN).insn_opcode, VALUE, OP_MASK_##FIELD, OP_SH_##FIELD)
#define MIPS16_INSERT_OPERAND(FIELD, INSN, VALUE) \
  INSERT_BITS ((INSN).insn_opcode, VALUE, \
		MIPS16OP_MASK_##FIELD, MIPS16OP_SH_##FIELD)

/* Extract the operand given by FIELD from mips_cl_insn INSN.  */
#define EXTRACT_OPERAND(FIELD, INSN) \
  EXTRACT_BITS ((INSN).insn_opcode, OP_MASK_##FIELD, OP_SH_##FIELD)
#define MIPS16_EXTRACT_OPERAND(FIELD, INSN) \
  EXTRACT_BITS ((INSN).insn_opcode, \
		MIPS16OP_MASK_##FIELD, \
		MIPS16OP_SH_##FIELD)
d1466 1
a1466 1
	  && ((EXTRACT_OPERAND (FS, *ip) & ~(unsigned) 1)
d1470 1
a1470 1
	  && ((EXTRACT_OPERAND (FT, *ip) & ~(unsigned) 1)
d1477 1
a1477 1
	  && EXTRACT_OPERAND (RS, *ip) == reg)
d1480 1
a1480 1
	  && EXTRACT_OPERAND (RT, *ip) == reg)
d1486 3
a1488 1
	  && mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, *ip)] == reg)
d1491 3
a1493 1
	  && mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RY, *ip)] == reg)
d1496 2
a1497 1
	  && (mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (MOVE32Z, *ip)]
d1507 2
a1508 1
	  && MIPS16_EXTRACT_OPERAND (REGR32, *ip) == reg)
d1534 1
a1534 1
      if (reg == EXTRACT_OPERAND (RT, history[0]))
d1683 3
a1685 1
	      || insn_uses_reg (ip, EXTRACT_OPERAND (RT, history[0]),
d1712 3
a1714 1
		  || insn_uses_reg (ip, EXTRACT_OPERAND (FT, history[0]),
d1721 3
a1723 1
		  || insn_uses_reg (ip, EXTRACT_OPERAND (FS, history[0]),
d1766 2
a1767 1
	       && insn_uses_reg (ip, EXTRACT_OPERAND (RD, history[0]),
d1780 3
a1782 2
	       && insn_uses_reg (ip, EXTRACT_OPERAND (RD, history[1]),
				 MIPS_GR_REG))
d2284 1
a2284 1
	mips_gprmask |= 1 << EXTRACT_OPERAND (RD, *ip);
d2286 1
a2286 1
	mips_gprmask |= 1 << EXTRACT_OPERAND (RT, *ip);
d2288 1
a2288 1
	mips_gprmask |= 1 << EXTRACT_OPERAND (RS, *ip);
d2292 1
a2292 1
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FD, *ip);
d2294 1
a2294 1
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FS, *ip);
d2296 1
a2296 1
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FT, *ip);
d2298 1
a2298 1
	mips_cprmask[1] |= 1 << EXTRACT_OPERAND (FR, *ip);
d2312 2
a2313 1
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (RX, *ip);
d2315 2
a2316 1
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (RY, *ip);
d2318 2
a2319 1
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (RZ, *ip);
d2329 2
a2330 1
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (MOVE32Z, *ip);
d2332 2
a2333 1
	mips_gprmask |= 1 << MIPS16_EXTRACT_OPERAND (REGR32, *ip);
d2427 3
a2429 1
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RT, history[0]),
d2433 3
a2435 1
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RD, history[0]),
d2439 5
a2443 3
		       && (insn_uses_reg
			   (ip, MIPS16_EXTRACT_OPERAND (RX, history[0]),
			    MIPS16_REG)))
d2445 5
a2449 3
			  && (insn_uses_reg
			      (ip, MIPS16_EXTRACT_OPERAND (RY, history[0]),
			       MIPS16_REG)))
d2451 5
a2455 3
			  && (insn_uses_reg
			      (ip, MIPS16_EXTRACT_OPERAND (RZ, history[0]),
			       MIPS16_REG)))
d2471 2
a2472 2
		       && (EXTRACT_OPERAND (RT, history[0])
			   == EXTRACT_OPERAND (RD, *ip)))
d2474 3
a2476 1
			  && EXTRACT_OPERAND (RT, history[0]) == RA)))
d2480 2
a2481 2
		       && (EXTRACT_OPERAND (RD, history[0])
			   == EXTRACT_OPERAND (RD, *ip)))
d2483 3
a2485 1
			  && EXTRACT_OPERAND (RD, history[0]) == RA)))
d2498 2
a2499 1
				    EXTRACT_OPERAND (RD, *ip),
d2517 3
a2519 1
		  && insn_uses_reg (ip, EXTRACT_OPERAND (RT, history[1]),
d3063 2
a3064 1
	      INSERT_OPERAND (SHAMT, insn, va_arg (args, int));
d3073 2
a3074 1
	      INSERT_OPERAND (INSMSB, insn, va_arg (args, int));
d3084 2
a3085 1
	      INSERT_OPERAND (EXTMSBD, insn, va_arg (args, int));
d3096 1
a3096 1
	  INSERT_OPERAND (RT, insn, va_arg (args, int));
d3100 1
a3100 1
	  INSERT_OPERAND (CODE, insn, va_arg (args, int));
d3105 1
a3105 1
	  INSERT_OPERAND (FT, insn, va_arg (args, int));
d3111 1
a3111 1
	  INSERT_OPERAND (RD, insn, va_arg (args, int));
d3118 2
a3119 2
	    INSERT_OPERAND (RT, insn, tmp);
	    INSERT_OPERAND (RD, insn, tmp);
d3125 1
a3125 1
	  INSERT_OPERAND (FS, insn, va_arg (args, int));
d3132 1
a3132 1
	  INSERT_OPERAND (SHAMT, insn, va_arg (args, int));
d3136 1
a3136 1
	  INSERT_OPERAND (FD, insn, va_arg (args, int));
d3140 1
a3140 1
	  INSERT_OPERAND (CODE20, insn, va_arg (args, int));
d3144 1
a3144 1
	  INSERT_OPERAND (CODE19, insn, va_arg (args, int));
d3148 1
a3148 1
	  INSERT_OPERAND (CODE2, insn, va_arg (args, int));
d3155 1
a3155 1
	  INSERT_OPERAND (RS, insn, va_arg (args, int));
d3267 1
a3267 1
	  MIPS16_INSERT_OPERAND (RY, insn, va_arg (args, int));
d3272 1
a3272 1
	  MIPS16_INSERT_OPERAND (RX, insn, va_arg (args, int));
d3276 1
a3276 1
	  MIPS16_INSERT_OPERAND (RZ, insn, va_arg (args, int));
d3280 1
a3280 1
	  MIPS16_INSERT_OPERAND (MOVE32Z, insn, va_arg (args, int));
d3290 1
a3290 1
	  MIPS16_INSERT_OPERAND (REGR32, insn, va_arg (args, int));
d3336 1
a3336 1
	  MIPS16_INSERT_OPERAND (IMM6, insn, va_arg (args, int));
d3411 1
a3411 2
  insn.insn_opcode = insn.insn_mo->match;
  INSERT_OPERAND (RT, insn, regnum);
d7577 3
a7579 3
  xreg = MIPS16_EXTRACT_OPERAND (RX, *ip);
  yreg = MIPS16_EXTRACT_OPERAND (RY, *ip);
  zreg = MIPS16_EXTRACT_OPERAND (RZ, *ip);
d8053 1
a8053 1
		  INSERT_OPERAND (RS, *ip, lastregno);
d8057 1
a8057 1
		  INSERT_OPERAND (RT, *ip, lastregno);
d8061 1
a8061 1
		  INSERT_OPERAND (FT, *ip, lastregno);
d8065 1
a8065 1
		  INSERT_OPERAND (FS, *ip, lastregno);
d8110 2
a8111 1
		  INSERT_OPERAND (SHAMT, *ip, imm_expr.X_add_number);
d8142 2
a8143 2
		  INSERT_OPERAND (INSMSB, *ip,
				 lastpos + imm_expr.X_add_number - 1);
d8178 2
a8179 1
		  INSERT_OPERAND (EXTMSBD, *ip, imm_expr.X_add_number - 1);
d8216 6
a8221 3
		as_warn (_("Improper shift amount (%lu)"),
			 (unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (SHAMT, *ip, imm_expr.X_add_number);
d8232 1
a8232 1
	      INSERT_OPERAND (SHAMT, *ip, imm_expr.X_add_number - 32);
d8242 6
a8247 3
		as_warn (_("Invalid value for `%s' (%lu)"),
			 ip->insn_mo->name,
			 (unsigned long) imm_expr.X_add_number);
d8249 1
a8249 1
		INSERT_OPERAND (CACHE, *ip, imm_expr.X_add_number);
d8251 1
a8251 1
		INSERT_OPERAND (PREFX, *ip, imm_expr.X_add_number);
d8260 6
a8265 3
		as_warn (_("Illegal break code (%lu)"),
			 (unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (CODE, *ip, imm_expr.X_add_number);
d8274 6
a8279 3
		as_warn (_("Illegal lower break code (%lu)"),
			 (unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (CODE2, *ip, imm_expr.X_add_number);
d8290 1
a8290 1
	      INSERT_OPERAND (CODE20, *ip, imm_expr.X_add_number);
d8315 1
a8315 1
	      INSERT_OPERAND (CODE19, *ip, imm_expr.X_add_number);
d8324 6
a8329 3
		as_warn (_("Invalid performance register (%lu)"),
			 (unsigned long) imm_expr.X_add_number);
	      INSERT_OPERAND (PERFREG, *ip, imm_expr.X_add_number);
d8466 1
a8466 1
		      INSERT_OPERAND (RS, *ip, regno);
d8471 1
a8471 1
		      INSERT_OPERAND (RD, *ip, regno);
d8474 2
a8475 2
		      INSERT_OPERAND (RD, *ip, regno);
		      INSERT_OPERAND (RT, *ip, regno);
d8480 1
a8480 1
		      INSERT_OPERAND (RT, *ip, regno);
d8511 1
a8511 1
		  INSERT_OPERAND (RS, *ip, lastregno);
d8514 1
a8514 1
		  INSERT_OPERAND (RT, *ip, lastregno);
d8523 6
a8528 3
		as_warn ("Improper align amount (%ld), using low bits",
			 (long) imm_expr.X_add_number);
	      INSERT_OPERAND (ALN, *ip, imm_expr.X_add_number);
d8540 6
a8545 3
		    as_warn (_("Invalid MDMX Immediate (%ld)"),
			     (long) imm_expr.X_add_number);
		  INSERT_OPERAND (FT, *ip, imm_expr.X_add_number);
d8550 1
d8613 1
a8613 1
		      INSERT_OPERAND (FD, *ip, regno);
d8618 1
a8618 1
		      INSERT_OPERAND (FS, *ip, regno);
d8658 1
a8658 1
		      INSERT_OPERAND (FT, *ip, regno);
d8661 1
a8661 1
		      INSERT_OPERAND (FR, *ip, regno);
d8671 1
a8671 1
		  INSERT_OPERAND (FS, *ip, lastregno);
d8674 1
a8674 1
		  INSERT_OPERAND (FT, *ip, lastregno);
d9004 1
a9004 1
		INSERT_OPERAND (BCC, *ip, regno);
d9006 1
a9006 1
		INSERT_OPERAND (CCC, *ip, regno);
d9044 1
a9044 1
	      INSERT_OPERAND (VECBYTE, *ip, imm_expr.X_add_number);
d9061 1
a9061 1
	      INSERT_OPERAND (VECALIGN, *ip, imm_expr.X_add_number);
d9237 1
a9237 1
		  MIPS16_INSERT_OPERAND (RX, *ip, lastregno);
d9240 1
a9240 1
		  MIPS16_INSERT_OPERAND (RY, *ip, lastregno);
d9256 1
a9256 1
		    MIPS16_INSERT_OPERAND (RX, *ip, lastregno);
d9258 1
a9258 1
		    MIPS16_INSERT_OPERAND (RY, *ip, lastregno);
d9393 1
a9393 1
		  MIPS16_INSERT_OPERAND (RX, *ip, regno);
d9397 1
a9397 1
		  MIPS16_INSERT_OPERAND (RY, *ip, regno);
d9400 1
a9400 1
		  MIPS16_INSERT_OPERAND (RZ, *ip, regno);
d9403 1
a9403 1
		  MIPS16_INSERT_OPERAND (MOVE32Z, *ip, regno);
d9409 1
a9409 1
		  MIPS16_INSERT_OPERAND (REGR32, *ip, regno);
d9413 1
a9413 1
		  MIPS16_INSERT_OPERAND (REG32R, *ip, regno);
d9515 7
a9521 4
		as_warn (_("Invalid value for `%s' (%lu)"),
			 ip->insn_mo->name,
			 (unsigned long) imm_expr.X_add_number);
	      MIPS16_INSERT_OPERAND (IMM6, *ip, imm_expr.X_add_number);
@


1.291.2.5
log
@	* config/tc-mips.c (dummy_opcode): Delete.
	(nop_insn, mips16_nop_insn): New variables.
	(NOP_INSN): New macro.
	(insn_length, create_insn, install_insn, move_insn, add_fixed_insn)
	(add_relaxed_insn, insert_into_history, emit_nop): New functions.
	(md_begin): Initialize nop_insn and mips16_nop_insn.
	(append_insn): Use the new emit_nop function to add nops, recording
	them in the history buffer.  Use add_fixed_insn or add_relaxed_insn
	to reserve room for the instruction and install_insn to install the
	final form.  Use insert_into_history to record the instruction in
	the history buffer.  Use move_insn to do delay slot filling.
	(mips_emit_delays): Use add_fixed_insn instead of the emit_nop macro.
	(macro_build, mips16_macro_build, macro_build_lui, mips_ip)
	(mips16_ip): Use create_insn to initialize mips_cl_insns.
@
text
@d563 3
a565 5
/* Nop instructions used by emit_nop.  */
static struct mips_cl_insn nop_insn, mips16_nop_insn;

/* The appropriate nop for the current mode.  */
#define NOP_INSN (mips_opts.mips16 ? &mips16_nop_insn : &nop_insn)
a1161 124
/* Return the length of instruction INSN.  */

static inline unsigned int
insn_length (const struct mips_cl_insn *insn)
{
  if (!mips_opts.mips16)
    return 4;
  return insn->mips16_absolute_jump_p || insn->use_extend ? 4 : 2;
}

/* Initialise INSN from opcode entry MO.  Leave its position unspecified.  */

static void
create_insn (struct mips_cl_insn *insn, const struct mips_opcode *mo)
{
  size_t i;

  insn->insn_mo = mo;
  insn->use_extend = FALSE;
  insn->extend = 0;
  insn->insn_opcode = mo->match;
  insn->frag = NULL;
  insn->where = 0;
  for (i = 0; i < ARRAY_SIZE (insn->fixp); i++)
    insn->fixp[i] = NULL;
  insn->fixed_p = (mips_opts.noreorder > 0);
  insn->noreorder_p = (mips_opts.noreorder > 0);
  insn->mips16_absolute_jump_p = 0;
}

/* Install INSN at the location specified by its "frag" and "where" fields.  */

static void
install_insn (const struct mips_cl_insn *insn)
{
  char *f = insn->frag->fr_literal + insn->where;
  if (!mips_opts.mips16)
    md_number_to_chars (f, insn->insn_opcode, 4);
  else if (insn->mips16_absolute_jump_p)
    {
      md_number_to_chars (f, insn->insn_opcode >> 16, 2);
      md_number_to_chars (f + 2, insn->insn_opcode & 0xffff, 2);
    }
  else
    {
      if (insn->use_extend)
	{
	  md_number_to_chars (f, 0xf000 | insn->extend, 2);
	  f += 2;
	}
      md_number_to_chars (f, insn->insn_opcode, 2);
    }
}

/* Move INSN to offset WHERE in FRAG.  Adjust the fixups accordingly
   and install the opcode in the new location.  */

static void
move_insn (struct mips_cl_insn *insn, fragS *frag, long where)
{
  size_t i;

  insn->frag = frag;
  insn->where = where;
  for (i = 0; i < ARRAY_SIZE (insn->fixp); i++)
    if (insn->fixp[i] != NULL)
      {
	insn->fixp[i]->fx_frag = frag;
	insn->fixp[i]->fx_where = where;
      }
  install_insn (insn);
}

/* Add INSN to the end of the output.  */

static void
add_fixed_insn (struct mips_cl_insn *insn)
{
  char *f = frag_more (insn_length (insn));
  move_insn (insn, frag_now, f - frag_now->fr_literal);
}

/* Start a variant frag and move INSN to the start of the variant part,
   marking it as fixed.  The other arguments are as for frag_var.  */

static void
add_relaxed_insn (struct mips_cl_insn *insn, int max_chars, int var,
		  relax_substateT subtype, symbolS *symbol, offsetT offset)
{
  frag_grow (max_chars);
  move_insn (insn, frag_now, frag_more (0) - frag_now->fr_literal);
  insn->fixed_p = 1;
  frag_var (rs_machine_dependent, max_chars, var,
	    subtype, symbol, offset, NULL);
}

/* Insert N copies of INSN into the history buffer, starting at
   position FIRST.  Neither FIRST nor N need to be clipped.  */

static void
insert_into_history (unsigned int first, unsigned int n,
		     const struct mips_cl_insn *insn)
{
  if (mips_relax.sequence != 2)
    {
      unsigned int i;

      for (i = ARRAY_SIZE (history); i-- > first;)
	if (i >= first + n)
	  history[i] = history[i - n];
	else
	  history[i] = *insn;
    }
}

/* Emit a nop instruction, recording it in the history buffer.  */

static void
emit_nop (void)
{
  add_fixed_insn (NOP_INSN);
  insert_into_history (0, 1, NOP_INSN);
}

a1194 5
	      if (nop_insn.insn_mo == NULL && strcmp (name, "nop") == 0)
		{
		  create_insn (&nop_insn, mips_opcodes + i);
		  nop_insn.fixed_p = 1;
		}
a1221 5
	  if (mips16_nop_insn.insn_mo == NULL && strcmp (name, "nop") == 0)
	    {
	      create_insn (&mips16_nop_insn, mips16_opcodes + i);
	      mips16_nop_insn.fixed_p = 1;
	    }
d1649 2
d1654 1
d1687 6
d2064 13
a2076 12
      add_relaxed_insn (ip, (relaxed_branch_length
			     (NULL, NULL,
			      (pinfo & INSN_UNCOND_BRANCH_DELAY) ? -1
			      : (pinfo & INSN_COND_BRANCH_LIKELY) ? 1
			      : 0)), 4,
			RELAX_BRANCH_ENCODE
			(pinfo & INSN_UNCOND_BRANCH_DELAY,
			 pinfo & INSN_COND_BRANCH_LIKELY,
			 pinfo & INSN_WRITE_GPR_31,
			 0),
			address_expr->X_add_symbol,
			address_expr->X_add_number);
d2083 7
a2089 7
      add_relaxed_insn (ip, 4, 0,
			RELAX_MIPS16_ENCODE
			(*reloc_type - BFD_RELOC_UNUSED,
			 mips16_small, mips16_ext,
			 prev_pinfo & INSN_UNCOND_BRANCH_DELAY,
			 history[0].mips16_absolute_jump_p),
			make_expr_symbol (address_expr), 0);
d2098 1
a2098 1
      add_fixed_insn (ip);
d2122 1
a2122 6
      if (mips_opts.mips16)
	{
	  ip->fixed_p = 1;
	  ip->mips16_absolute_jump_p = (*reloc_type == BFD_RELOC_MIPS16_JMP);
	}
      add_fixed_insn (ip);
d2125 1
d2206 5
a2210 5
	  ip->fixp[0] = fix_new_exp (ip->frag, ip->where,
				     bfd_get_reloc_size (howto),
				     address_expr,
				     reloc_type[0] == BFD_RELOC_16_PCREL_S2,
				     reloc_type[0]);
d2235 1
a2235 1
	    ip->fixp[0]->fx_no_overflow = 1;
d2240 1
a2240 1
		mips_relax.first_fixup = ip->fixp[0];
d2256 1
a2256 1
	      hi_fixup->fixp = ip->fixp[0];
d2268 3
a2270 3
		ip->fixp[i] = fix_new (ip->frag, ip->where,
				       ip->fixp[0]->fx_size, NULL, 0,
				       FALSE, reloc_type[i]);
d2273 2
a2274 2
		ip->fixp[0]->fx_tcbit = 1;
		ip->fixp[i]->fx_tcbit = 1;
d2278 17
a2294 1
  install_insn (ip);
a2536 1
	      insert_into_history (0, 1, ip);
d2540 6
d2550 1
a2550 2
	      struct mips_cl_insn delay = history[0];
	      if (mips_opts.mips16)
d2552 82
a2633 14
		  know (delay.frag == ip->frag);
		  move_insn (ip, delay.frag, delay.where);
		  move_insn (&delay, ip->frag, ip->where + insn_length (ip));
		}
	      else if (relaxed_branch)
		{
		  /* Add the delay slot instruction to the end of the
		     current frag and shrink the fixed part of the
		     original frag.  If the branch occupies the tail of
		     the latter, move it backwards to cover the gap.  */
		  delay.frag->fr_fix -= 4;
		  if (delay.frag == ip->frag)
		    move_insn (ip, ip->frag, ip->where - 4);
		  add_fixed_insn (&delay);
d2637 34
a2670 2
		  move_insn (&delay, ip->frag, ip->where);
		  move_insn (ip, history[0].frag, history[0].where);
d2672 7
a2678 3
	      history[0] = *ip;
	      delay.fixed_p = 1;
	      insert_into_history (0, 1, &delay);
d2680 1
d2685 9
a2693 1
	    mips_no_prev_insn (FALSE);
a2700 1
	  insert_into_history (0, 1, ip);
d2702 11
d2715 48
a2762 1
	insert_into_history (0, 1, ip);
a2763 2
  else
    insert_into_history (0, 1, ip);
a2775 2
  size_t i;
 
d2778 2
a2783 2
      for (i = 0; i < ARRAY_SIZE (history); i++)
	history[i] = (mips_opts.mips16 ? mips16_nop_insn : nop_insn);
d2785 4
a2788 7
  else
    for (i = 0; i < ARRAY_SIZE (history); i++)
      {
	history[i].fixed_p = 1;
	history[i].noreorder_p = 0;
	history[i].mips16_absolute_jump_p = 0;
      }
d2877 1
a2877 1
	    add_fixed_insn (NOP_INSN);
a2999 1
  const struct mips_opcode *mo;
d3016 14
a3029 11
  mo = (struct mips_opcode *) hash_find (op_hash, name);
  assert (mo);
  assert (strcmp (name, mo->name) == 0);

  /* Search until we get a match for NAME.  It is assumed here that
     macros will never generate MDMX or MIPS-3D instructions.  */
  while (strcmp (fmt, mo->args) != 0
	 || mo->pinfo == INSN_MACRO
	 || !OPCODE_IS_MEMBER (mo,
			       (mips_opts.isa
				| (file_ase_mips16 ? INSN_MIPS16 : 0)),
d3031 6
a3036 5
	 || (mips_opts.arch == CPU_R4650 && (mo->pinfo & FP_D) != 0))
    {
      ++mo;
      assert (mo->name);
      assert (strcmp (name, mo->name) == 0);
d3039 1
a3039 1
  create_insn (&insn, mo);
a3221 1
  struct mips_opcode *mo;
d3226 11
a3236 3
  mo = (struct mips_opcode *) hash_find (mips16_op_hash, name);
  assert (mo);
  assert (strcmp (name, mo->name) == 0);
d3238 2
a3239 6
  while (strcmp (fmt, mo->args) != 0 || mo->pinfo == INSN_MACRO)
    {
      ++mo;
      assert (mo->name);
      assert (strcmp (name, mo->name) == 0);
    }
a3240 1
  create_insn (&insn, mo);
a3365 1
  const struct mips_opcode *mo;
d3397 4
a3400 4
  mo = hash_find (op_hash, name);
  assert (strcmp (name, mo->name) == 0);
  assert (strcmp (fmt, mo->args) == 0);
  create_insn (&insn, mo);
d8021 2
a8022 1
      create_insn (ip, insn);
d9126 3
a9128 1
      create_insn (ip, insn);
@


1.291.2.6
log
@	* config/tc-mips.c (append_insn): Remove now-redundant nops != 0
	check from branch delay code.  Remove unnecessary check for branches.
@
text
@d2475 3
d2539 5
@


1.291.2.7
log
@	* config/tc-mips.c (MAX_NOPS): New macro.
	(history): Resize to 1 + MAX_NOPS.
	(fix_vr4120_class): New enumeration.
	(vr4120_conflicts): New variable.
	(init_vr4120_conflicts): New function.
	(md_begin): Call it.
	(insn_uses_reg): Constify first argument.
	(classify_vr4120_insn, insns_between, nops_for_insn, nops_for_sequence)
	(nops_for_insn_or_target): New functions.
	(append_insn): Use the new nops_for_* functions instead of inline
	delay checks.  Generalize prev_nop_frag handling to handle an
	arbitrary history length.  Insert nops into the history buffer
	once the number of nops in prev_nop_frag is fixed.
	(emit_delays): Use nops_for_insn instead of inline delay checks.
@
text
@d560 2
a561 10
/* The maximum number of NOPs needed to satisfy a hardware hazard
   or processor errata.  */
#define MAX_NOPS 2

/* A list of previous instructions, with index 0 being the most recent.
   We need to look back MAX_NOPS instructions when filling delay slots
   or working around processor errata.  We need to look back one
   instruction further if we're thinking about using history[0] to
   fill a branch delay slot.  */
static struct mips_cl_insn history[1 + MAX_NOPS];
a633 18
/* Classifies the kind of instructions we're interested in when
   implementing -mfix-vr4120.  */
enum fix_vr4120_class {
  FIX_VR4120_MACC,
  FIX_VR4120_DMACC,
  FIX_VR4120_MULT,
  FIX_VR4120_DMULT,
  FIX_VR4120_DIV,
  FIX_VR4120_MTHILO,
  NUM_FIX_VR4120_CLASSES
};

/* Given two FIX_VR4120_* values X and Y, bit Y of element X is set if
   there must be at least one other instruction between an instruction
   of type X and an instruction of type Y.  */
static unsigned int vr4120_conflicts[NUM_FIX_VR4120_CLASSES];

/* True if -mfix-vr4120 is in force.  */
a1287 44
/* Initialize vr4120_conflicts.  There is a bit of duplication here:
   the idea is to make it obvious at a glance that each errata is
   included.  */

static void
init_vr4120_conflicts (void)
{
#define CONFLICT(FIRST, SECOND) \
    vr4120_conflicts[FIX_VR4120_##FIRST] |= 1 << FIX_VR4120_##SECOND

  /* Errata 21 - [D]DIV[U] after [D]MACC */
  CONFLICT (MACC, DIV);
  CONFLICT (DMACC, DIV);

  /* Errata 23 - Continuous DMULT[U]/DMACC instructions.  */
  CONFLICT (DMULT, DMULT);
  CONFLICT (DMULT, DMACC);
  CONFLICT (DMACC, DMULT);
  CONFLICT (DMACC, DMACC);

  /* Errata 24 - MT{LO,HI} after [D]MACC */
  CONFLICT (MACC, MTHILO);
  CONFLICT (DMACC, MTHILO);

  /* VR4181A errata MD(1): "If a MULT, MULTU, DMULT or DMULTU
     instruction is executed immediately after a MACC or DMACC
     instruction, the result of [either instruction] is incorrect."  */
  CONFLICT (MACC, MULT);
  CONFLICT (MACC, DMULT);
  CONFLICT (DMACC, MULT);
  CONFLICT (DMACC, DMULT);

  /* VR4181A errata MD(4): "If a MACC or DMACC instruction is
     executed immediately after a DMULT, DMULTU, DIV, DIVU,
     DDIV or DDIVU instruction, the result of the MACC or
     DMACC instruction is incorrect.".  */
  CONFLICT (DMULT, MACC);
  CONFLICT (DMULT, DMACC);
  CONFLICT (DIV, MACC);
  CONFLICT (DIV, DMACC);

#undef CONFLICT
}

a1515 3

  if (mips_fix_vr4120)
    init_vr4120_conflicts ();
d1607 1
a1607 1
insn_uses_reg (const struct mips_cl_insn *ip, unsigned int reg,
a1775 217
/* Classify an instruction according to the FIX_VR4120_* enumeration.
   Return NUM_FIX_VR4120_CLASSES if the instruction isn't affected
   by VR4120 errata.  */

static unsigned int
classify_vr4120_insn (const char *name)
{
  if (strncmp (name, "macc", 4) == 0)
    return FIX_VR4120_MACC;
  if (strncmp (name, "dmacc", 5) == 0)
    return FIX_VR4120_DMACC;
  if (strncmp (name, "mult", 4) == 0)
    return FIX_VR4120_MULT;
  if (strncmp (name, "dmult", 5) == 0)
    return FIX_VR4120_DMULT;
  if (strstr (name, "div"))
    return FIX_VR4120_DIV;
  if (strcmp (name, "mtlo") == 0 || strcmp (name, "mthi") == 0)
    return FIX_VR4120_MTHILO;
  return NUM_FIX_VR4120_CLASSES;
}

/* Return the number of instructions that must separate INSN1 and INSN2,
   where INSN1 is the earlier instruction.  Return the worst-case value
   for any INSN2 if INSN2 is null.  */

static unsigned int
insns_between (const struct mips_cl_insn *insn1,
	       const struct mips_cl_insn *insn2)
{
  unsigned long pinfo1, pinfo2;

  /* This function needs to know which pinfo flags are set for INSN2
     and which registers INSN2 uses.  The former is stored in PINFO2 and
     the latter is tested via INSN2_USES_REG.  If INSN2 is null, PINFO2
     will have every flag set and INSN2_USES_REG will always return true.  */
  pinfo1 = insn1->insn_mo->pinfo;
  pinfo2 = insn2 ? insn2->insn_mo->pinfo : ~0U;

#define INSN2_USES_REG(REG, CLASS) \
   (insn2 == NULL || insn_uses_reg (insn2, REG, CLASS))

  /* For most targets, write-after-read dependencies on the HI and LO
     registers must be separated by at least two instructions.  */
  if (!hilo_interlocks)
    {
      if ((pinfo1 & INSN_READ_LO) && (pinfo2 & INSN_WRITE_LO))
	return 2;
      if ((pinfo1 & INSN_READ_HI) && (pinfo2 & INSN_WRITE_HI))
	return 2;
    }

  /* If we're working around r7000 errata, there must be two instructions
     between an mfhi or mflo and any instruction that uses the result.  */
  if (mips_7000_hilo_fix
      && MF_HILO_INSN (pinfo1)
      && INSN2_USES_REG (EXTRACT_OPERAND (RD, *insn1), MIPS_GR_REG))
    return 2;

  /* If working around VR4120 errata, check for combinations that need
     a single intervening instruction.  */
  if (mips_fix_vr4120)
    {
      unsigned int class1, class2;

      class1 = classify_vr4120_insn (insn1->insn_mo->name);
      if (class1 != NUM_FIX_VR4120_CLASSES && vr4120_conflicts[class1] != 0)
	{
	  if (insn2 == NULL)
	    return 1;
	  class2 = classify_vr4120_insn (insn2->insn_mo->name);
	  if (vr4120_conflicts[class1] & (1 << class2))
	    return 1;
	}
    }

  if (!mips_opts.mips16)
    {
      /* Check for GPR or coprocessor load delays.  All such delays
	 are on the RT register.  */
      /* Itbl support may require additional care here.  */
      if ((!gpr_interlocks && (pinfo1 & INSN_LOAD_MEMORY_DELAY))
	  || (!cop_interlocks && (pinfo1 & INSN_LOAD_COPROC_DELAY)))
	{
	  know (pinfo1 & INSN_WRITE_GPR_T);
	  if (INSN2_USES_REG (EXTRACT_OPERAND (RT, *insn1), MIPS_GR_REG))
	    return 1;
	}

      /* Check for generic coprocessor hazards.

	 This case is not handled very well.  There is no special
	 knowledge of CP0 handling, and the coprocessors other than
	 the floating point unit are not distinguished at all.  */
      /* Itbl support may require additional care here. FIXME!
	 Need to modify this to include knowledge about
	 user specified delays!  */
      else if ((!cop_interlocks && (pinfo1 & INSN_COPROC_MOVE_DELAY))
	       || (!cop_mem_interlocks && (pinfo1 & INSN_COPROC_MEMORY_DELAY)))
	{
	  /* Handle cases where INSN1 writes to a known general coprocessor
	     register.  There must be a one instruction delay before INSN2
	     if INSN2 reads that register, otherwise no delay is needed.  */
	  if (pinfo1 & INSN_WRITE_FPR_T)
	    {
	      if (INSN2_USES_REG (EXTRACT_OPERAND (FT, *insn1), MIPS_FP_REG))
		return 1;
	    }
	  else if (pinfo1 & INSN_WRITE_FPR_S)
	    {
	      if (INSN2_USES_REG (EXTRACT_OPERAND (FS, *insn1), MIPS_FP_REG))
		return 1;
	    }
	  else
	    {
	      /* Read-after-write dependencies on the control registers
		 require a two-instruction gap.  */
	      if ((pinfo1 & INSN_WRITE_COND_CODE)
		  && (pinfo2 & INSN_READ_COND_CODE))
		return 2;

	      /* We don't know exactly what INSN1 does.  If INSN2 is
		 also a coprocessor instruction, assume there must be
		 a one instruction gap.  */
	      if (pinfo2 & INSN_COP)
		return 1;
	    }
	}

      /* Check for read-after-write dependencies on the coprocessor
	 control registers in cases where INSN1 does not need a general
	 coprocessor delay.  This means that INSN1 is a floating point
	 comparison instruction.  */
      /* Itbl support may require additional care here.  */
      else if (!cop_interlocks
	       && (pinfo1 & INSN_WRITE_COND_CODE)
	       && (pinfo2 & INSN_READ_COND_CODE))
	return 1;
    }

#undef INSN2_USES_REG

  return 0;
}

/* Return the number of nops that would be needed if instruction INSN
   immediately followed the MAX_NOPS instructions given by HISTORY,
   where HISTORY[0] is the most recent instruction.  If INSN is null,
   return the worse-case number of nops for any instruction.  */

static int
nops_for_insn (const struct mips_cl_insn *history,
	       const struct mips_cl_insn *insn)
{
  int i, nops, tmp_nops;

  nops = 0;
  for (i = 0; i < MAX_NOPS; i++)
    if (!history[i].noreorder_p)
      {
	tmp_nops = insns_between (history + i, insn) - i;
	if (tmp_nops > nops)
	  nops = tmp_nops;
      }
  return nops;
}

/* The variable arguments provide NUM_INSNS extra instructions that
   might be added to HISTORY.  Return the largest number of nops that
   would be needed after the extended sequence.  */

static int
nops_for_sequence (int num_insns, const struct mips_cl_insn *history, ...)
{
  va_list args;
  struct mips_cl_insn buffer[MAX_NOPS];
  struct mips_cl_insn *cursor;
  int nops;

  va_start (args, history);
  cursor = buffer + num_insns;
  memcpy (cursor, history, (MAX_NOPS - num_insns) * sizeof (*cursor));
  while (cursor > buffer)
    *--cursor = *va_arg (args, const struct mips_cl_insn *);

  nops = nops_for_insn (buffer, NULL);
  va_end (args);
  return nops;
}

/* Like nops_for_insn, but if INSN is a branch, take into account the
   worst-case delay for the branch target.  */

static int
nops_for_insn_or_target (const struct mips_cl_insn *history,
			 const struct mips_cl_insn *insn)
{
  int nops, tmp_nops;

  nops = nops_for_insn (history, insn);
  if (insn->insn_mo->pinfo & (INSN_UNCOND_BRANCH_DELAY
			      | INSN_COND_BRANCH_DELAY
			      | INSN_COND_BRANCH_LIKELY))
    {
      tmp_nops = nops_for_sequence (2, history, insn, NOP_INSN);
      if (tmp_nops > nops)
	nops = tmp_nops;
    }
  else if (mips_opts.mips16 && (insn->insn_mo->pinfo & MIPS16_INSN_BRANCH))
    {
      tmp_nops = nops_for_sequence (1, history, insn);
      if (tmp_nops > nops)
	nops = tmp_nops;
    }
  return nops;
}

d1785 1
d1795 2
a1796 1
  if (mips_relax.sequence != 2 && !mips_opts.noreorder)
d1798 15
a1812 1
      /* There are a lot of optimizations we could do that we don't.
d1819 263
a2081 4
      int nops = (mips_optimize == 0
		  ? nops_for_insn (history, NULL)
		  : nops_for_insn_or_target (history, ip));
      if (nops > 0)
d2126 29
a2154 6
    }
  else if (mips_relax.sequence != 2 && prev_nop_frag != NULL)
    {
      /* Work out how many nops in prev_nop_frag are needed by IP.  */
      int nops = nops_for_insn_or_target (history, ip);
      assert (nops <= prev_nop_frag_holds);
d2156 1
a2156 3
      /* Enforce NOPS as a minimum.  */
      if (nops > prev_nop_frag_required)
	prev_nop_frag_required = nops;
d2158 4
a2161 15
      if (prev_nop_frag_holds == prev_nop_frag_required)
	{
	  /* Settle for the current number of nops.  Update the history
	     accordingly (for the benefit of any future .set reorder code).  */
	  prev_nop_frag = NULL;
	  insert_into_history (prev_nop_frag_since,
			       prev_nop_frag_holds, NOP_INSN);
	}
      else
	{
	  /* Allow this instruction to replace one of the nops that was
	     tentatively added to prev_nop_frag.  */
	  prev_nop_frag->fr_fix -= mips_opts.mips16 ? 2 : 4;
	  prev_nop_frag_holds--;
	  prev_nop_frag_since++;
d2514 22
a2535 6
	      /* Check for conflicts between the branch and the instructions
		 before the candidate delay slot.  */
	      || nops_for_insn (history + 1, ip) > 0
	      /* Check for conflicts between the swapped sequence and the
		 target of the branch.  */
	      || nops_for_sequence (2, history + 1, ip, history) > 0
d2609 12
d2742 58
a2799 1
      int nops = nops_for_insn (history, NULL);
d2804 1
a2804 1
	  if (insns && mips_optimize != 0)
@


1.291.2.8
log
@	* config/tc-mips.c (mips_move_labels): New function, taken from...
	(append_insn, mips_emit_delays): ...here.
@
text
@a1773 20
/* Move all labels in insn_labels to the current insertion point.  */

static void
mips_move_labels (void)
{
  struct insn_label_list *l;
  valueT val;

  for (l = insn_labels; l != NULL; l = l->next)
    {
      assert (S_GET_SEGMENT (l->label) == now_seg);
      symbol_set_frag (l->label, frag_now);
      val = (valueT) frag_now_fix ();
      /* mips16 text labels are stored as odd.  */
      if (mips_opts.mips16)
	++val;
      S_SET_VALUE (l->label, val);
    }
}

d2101 1
d2123 12
a2134 1
	  mips_move_labels ();
d2722 2
d2746 12
a2757 1
	  mips_move_labels ();
@


1.291.2.9
log
@	* config/tc-mips.h (mips_flush_pending_output): Delete.
	(mips_emit_delays): Declare.
	(md_flush_pending_output): Use mips_emit_delays.
	* config/tc-mips.c (mips_no_prev_insn): Remove parameter; always forget
	the previous instructions.
	(md_begin, append_insn, md_parse_option): Update callers.
	(mips_emit_delay): Remove parameter.  Move INSNS != 0 code to
	start_noreorder.
	(mips_align, s_change_sec, s_cons, s_float_cons, s_gpword)
	(s_gpdword): Update callers.
	(start_noreorder, end_noreorder): New functions.
	(macro, macro2, mips16_macro, s_mipsset): Use them instead of
	manipulating mips_opts or prev_nop_frag directly.
	(mips_flush_pending_output): Delete.
@
text
@d931 1
a931 1
static void mips_no_prev_insn (void);
d1480 1
a1480 1
  mips_no_prev_insn ();
d2667 1
a2667 1
	    mips_no_prev_insn ();
d2688 3
a2690 1
/* Forget that there was any previous instruction or label.  */
d2693 1
a2693 1
mips_no_prev_insn (void)
d2695 18
a2712 2
  prev_nop_frag = NULL;
  insert_into_history (0, ARRAY_SIZE (history), NOP_INSN);
d2716 5
a2720 3
/* This function must be called before we emit something other than
   instructions.  It is like mips_no_prev_insn except that it inserts
   any NOPS that might be needed by previous instructions.  */
d2722 2
a2723 2
void
mips_emit_delays (void)
d2730 1
a2730 29
	  while (nops-- > 0)
	    add_fixed_insn (NOP_INSN);
	  mips_move_labels ();
	}
    }
  mips_no_prev_insn ();
}

/* Start a (possibly nested) noreorder block.  */

static void
start_noreorder (void)
{
  if (mips_opts.noreorder == 0)
    {
      unsigned int i;
      int nops;

      /* None of the instructions before the .set noreorder can be moved.  */
      for (i = 0; i < ARRAY_SIZE (history); i++)
	history[i].fixed_p = 1;

      /* Insert any nops that might be needed between the .set noreorder
	 block and the previous instructions.  We will later remove any
	 nops that turn out not to be needed.  */
      nops = nops_for_insn (history, NULL);
      if (nops > 0)
	{
	  if (mips_optimize != 0)
d2744 8
a2751 4
	  /* Move on to a new frag, so that it is safe to simply
	     decrease the size of prev_nop_frag.  */
	  frag_wane (frag_now);
	  frag_new (0);
a2753 2
      mips16_mark_labels ();
      mips_clear_insn_labels ();
a2754 3
  mips_opts.noreorder++;
  mips_any_noreorder = 1;
}
d2756 3
a2758 1
/* End a nested noreorder block.  */
d2760 1
a2760 14
static void
end_noreorder (void)
{
  mips_opts.noreorder--;
  if (mips_opts.noreorder == 0 && prev_nop_frag != NULL)
    {
      /* Commit to inserting prev_nop_frag_required nops and go back to
	 handling nop insertion the .set reorder way.  */
      prev_nop_frag->fr_fix -= ((prev_nop_frag_holds - prev_nop_frag_required)
				* (mips_opts.mips16 ? 2 : 4));
      insert_into_history (prev_nop_frag_since,
			   prev_nop_frag_required, NOP_INSN);
      prev_nop_frag = NULL;
    }
d4064 3
a4066 1
      start_noreorder ();
d4076 1
a4076 1
      end_noreorder ();
d4584 3
a4586 1
      start_noreorder ();
d4620 1
a4620 1
	  end_noreorder ();
d4630 1
a4630 1
	  end_noreorder ();
d4725 3
a4727 1
      start_noreorder ();
d4734 1
a4734 1
	  end_noreorder ();
d4744 1
a4744 1
	  end_noreorder ();
d6672 3
a6674 1
      start_noreorder ();
d6691 1
a6691 1
      end_noreorder ();
d6705 3
a6707 1
      start_noreorder ();
d6724 1
a6724 1
      end_noreorder ();
d7189 3
a7191 1
      start_noreorder ();
d7205 1
a7205 1
      end_noreorder ();
d7445 3
a7447 1
      start_noreorder ();
d7457 1
a7457 1
      end_noreorder ();
d7477 3
a7479 1
      start_noreorder ();
d7484 1
a7484 1
      end_noreorder ();
d10197 1
a10197 1
      mips_no_prev_insn ();
d10202 1
a10202 1
      mips_no_prev_insn ();
d11061 1
a11061 1
  mips_emit_delays ();
d11123 7
d11145 1
a11145 1
  mips_emit_delays ();
d11276 1
a11276 1
  mips_emit_delays ();
d11290 1
a11290 1
  mips_emit_delays ();
d11418 10
a11427 2
      if (mips_opts.noreorder)
	end_noreorder ();
d11431 3
a11433 2
      if (!mips_opts.noreorder)
	start_noreorder ();
d11578 1
a11578 1
	    start_noreorder ();
d11580 8
a11587 1
	    end_noreorder ();
d11927 1
a11927 1
  mips_emit_delays ();
d11963 1
a11963 1
  mips_emit_delays ();
@


1.291.2.10
log
@	* config/tc-mips.c (append_insn): Remove cop_interlocks test from
	branch delay code.
@
text
@d2516 11
@


1.291.2.11
log
@	* config/tc-mips.c (append_insn): Remove cop_interlocks test from
	branch delay code.
@
text
@d560 3
a562 8
/* The maximum number of NOPs needed to avoid the VR4130 mflo/mfhi errata.  */
#define MAX_VR4130_NOPS 4

/* The maximum number of NOPs needed to fill delay slots.  */
#define MAX_DELAY_NOPS 2

/* The maximum number of NOPs needed for any purpose.  */
#define MAX_NOPS 4
a661 3
/* ...likewise -mfix-vr4130.  */
static int mips_fix_vr4130;

a2013 42
/* Return the number of nops that would be needed to work around the
   VR4130 mflo/mfhi errata if instruction INSN immediately followed
   the MAX_VR4130_NOPS instructions described by HISTORY.  */

static int
nops_for_vr4130 (const struct mips_cl_insn *history,
		 const struct mips_cl_insn *insn)
{
  int i, j, reg;

  /* Check if the instruction writes to HI or LO.  MTHI and MTLO
     are not affected by the errata.  */
  if (insn != 0
      && ((insn->insn_mo->pinfo & (INSN_WRITE_HI | INSN_WRITE_LO)) == 0
	  || strcmp (insn->insn_mo->name, "mtlo") == 0
	  || strcmp (insn->insn_mo->name, "mthi") == 0))
    return 0;

  /* Search for the first MFLO or MFHI.  */
  for (i = 0; i < MAX_VR4130_NOPS; i++)
    if (!history[i].noreorder_p && MF_HILO_INSN (history[i].insn_mo->pinfo))
      {
	/* Extract the destination register.  */
	if (mips_opts.mips16)
	  reg = mips16_to_32_reg_map[MIPS16_EXTRACT_OPERAND (RX, history[i])];
	else
	  reg = EXTRACT_OPERAND (RD, history[i]);

	/* No nops are needed if INSN reads that register.  */
	if (insn != NULL && insn_uses_reg (insn, reg, MIPS_GR_REG))
	  return 0;

	/* ...or if any of the intervening instructions do.  */
	for (j = 0; j < i; j++)
	  if (insn_uses_reg (&history[j], reg, MIPS_GR_REG))
	    return 0;

	return MAX_VR4130_NOPS - i;
      }
  return 0;
}

d2026 1
a2026 1
  for (i = 0; i < MAX_DELAY_NOPS; i++)
a2032 8

  if (mips_fix_vr4130)
    {
      tmp_nops = nops_for_vr4130 (history, insn);
      if (tmp_nops > nops)
	nops = tmp_nops;
    }

a9968 4
#define OPTION_FIX_VR4130 (OPTION_FIX_BASE + 4)
#define OPTION_NO_FIX_VR4130 (OPTION_FIX_BASE + 5)
  {"mfix-vr4130",    no_argument, NULL, OPTION_FIX_VR4130},
  {"mno-fix-vr4130", no_argument, NULL, OPTION_NO_FIX_VR4130},
d9971 1
a9971 1
#define OPTION_MISC_BASE (OPTION_FIX_BASE + 6)
a10213 8
    case OPTION_FIX_VR4130:
      mips_fix_vr4130 = 1;
      break;

    case OPTION_NO_FIX_VR4130:
      mips_fix_vr4130 = 0;
      break;

a13888 1
-mfix-vr4130		work around VR4130 mflo/mfhi errata\n\
@


1.291.2.12
log
@	* config/tc-mips.c (s_cpsetup): Use '__gnu_local_gp' instead of '_gp'
	for -mno-shared optimization.
@
text
@d11827 1
a11827 1
      ex.X_add_symbol = symbol_find_or_make ("__gnu_local_gp");
@


1.291.2.13
log
@==> ChangeLog <==
2005-03-14  Eric Christopher  <echristo@@redhat.com>

        * config/tc-mips.c: Include dw2gencfi.h.
        (mips_cfi_frame_initial_instructions): New.
        * config/tc-mips.h (TARGET_USE_CFIPOP): Define.
        (tc_cfi_frame_initial_instructions): Ditto.
        (DWARF2_DEFAULT_RETURN_COLUMN): Ditto.
        (DWARF2_CIE_DATA_ALIGNMENT): Ditto.
        * Makefile.am: Update dependencies.
        * Makefile.in: Regenerate.

==> testsuite/ChangeLog <==
2005-03-14  Eric Christopher  <echristo@@redhat.com>

        * gas/cfi/cfi-mips-1.d, gas/cfi/cfi-mips-1.s: New dump test.
        * gas/cfi/cfi.exp: Run it.
        * gas/cfi/cfi-common-1.d: Update.
        * gas/cfi/cfi-common-2.d: Ditto.
        * gas/cfi/cfi-common-3.d: Ditto.
        * gas/cfi/cfi-common-4.d: Ditto.
@
text
@a35 1
#include "dw2gencfi.h"
a14018 8

/* Standard calling conventions leave the CFA at SP on entry.  */
void
mips_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa_register (SP);
}

@


1.291.2.14
log
@* config/tc-mips.c (mips_frob_file): Sort BFD_RELOC_MIPS16_LO16
relocations correctly as well.
(mips_fix_adjustable): Don't make BFD_RELOC_MIPS16_LO16
relocations in mergeable sections section-relative either.
@
text
@d10751 1
a10751 2
	  if (((*pos)->fx_r_type == BFD_RELOC_LO16
	       || (*pos)->fx_r_type == BFD_RELOC_MIPS16_LO16)
d12692 1
a12692 3
  if ((fixp->fx_r_type == BFD_RELOC_LO16
       || fixp->fx_r_type == BFD_RELOC_MIPS16_LO16
       || reloc_needs_lo_p (fixp->fx_r_type))
@


1.291.2.15
log
@gas/:
* config/tc-mips.c (IS_ZEXT_32BIT_NUM): New macro.
(normalize_address_expr): New function to sign-extend address
offsets that fit into 32 bits in 32-bit mode.
(macro_build_ldst_constoffset): Use normalize_address_expr()
instead of a handcoded sequence.
(load_register): Likewise.  Report oversized numbers in a useful
way.
(macro) [ld_st, ldd_std]: Reject all oversized offsets, not only
for constant addresses.  Report oversized numbers in a useful way.
(mips_ip): Use normalize_address_expr() for addresses.

gas/testsuite/:
* gas/mips/ldstla-32.s: Exclude offsets that are now meant to fail
and include more instructions/offsets that are meant to succeed.
Use $4 instead $3 to avoid register dependencies.
* gas/mips/ldstla-32.d: Update accordingly.
* gas/mips/ldstla-32-shared.d: Likewise.
* gas/mips/ldstla-32-mips3.d: New test based on the above, except
for mips3.
* gas/mips/ldstla-32-mips3-shared.d: Similarly, for PIC.
* gas/mips/ldstla-32-mips3.s: Source for the new tests.
* gas/mips/ldstla-32-1.s: New test for offsets that are meant to
fail.
* gas/mips/ldstla-32-mips3-1.s: Likewise, for mips3.
* gas/mips/ldstla-32-1.l: Stderr output for the new test.
* gas/mips/ldstla-32-mips3-1.l: Likewise.
* gas/mips/mips.exp: Run the new tests.
@
text
@a863 5
/* Is the given value a zero-extended 32-bit value?  Or a negated one?  */
#define IS_ZEXT_32BIT_NUM(x)						\
  (((x) &~ (offsetT) 0xffffffff) == 0					\
   || (((x) &~ (offsetT) 0xffffffff) == ~ (offsetT) 0xffffffff))

a3255 27
static void
/*
 * Sign-extend 32-bit mode constants that have bit 31 set and all
 * higher bits unset.
 */
normalize_constant_expr (expressionS *ex)
{
  if ((ex->X_op == O_constant && HAVE_32BIT_GPRS)
      && IS_ZEXT_32BIT_NUM (ex->X_add_number))
    ex->X_add_number = (((ex->X_add_number & 0xffffffff) ^ 0x80000000)
			- 0x80000000);
}

/*
 * Sign-extend 32-bit mode address offsets that have bit 31 set and
 * all higher bits unset.
 */
static void
normalize_address_expr (expressionS *ex)
{
  if (((ex->X_op == O_constant && HAVE_32BIT_ADDRESSES)
	|| (ex->X_op == O_symbol && HAVE_32BIT_SYMBOLS))
      && IS_ZEXT_32BIT_NUM (ex->X_add_number))
    ex->X_add_number = (((ex->X_add_number & 0xffffffff) ^ 0x80000000)
			- 0x80000000);
}

d3341 9
a3349 2
  if (!dbl)
    normalize_constant_expr (ep);
d3395 8
d3507 9
a3515 2
      if (!dbl)
	normalize_constant_expr (ep);
d3544 1
a3544 1
  if (!dbl || HAVE_32BIT_GPRS)
d3546 2
a3547 3
      as_bad (_("Number (0x%lx%08lx) larger than 32 bits"),
	      (unsigned long) (ep->X_add_number >> 32),
	      (unsigned long) (ep->X_add_number & 0xffffffff));
a5787 6
      if (HAVE_32BIT_ADDRESSES
	  && !IS_SEXT_32BIT_NUM (offset_expr.X_add_number))
	as_bad (_("Number (0x%lx%08lx) larger than 32 bits"),
		(unsigned long) (offset_expr.X_add_number >> 32),
		(unsigned long) (offset_expr.X_add_number & 0xffffffff));

d5792 4
a5797 1
	  normalize_address_expr (&expr1);
a6375 6
      if (HAVE_32BIT_ADDRESSES
	  && !IS_SEXT_32BIT_NUM (offset_expr.X_add_number))
	as_bad (_("Number (0x%lx%08lx) larger than 32 bits"),
		(unsigned long) (offset_expr.X_add_number >> 32),
		(unsigned long) (offset_expr.X_add_number & 0xffffffff));

a8558 1
	      normalize_address_expr (&offset_expr);
@


1.291.2.16
log
@* config/tc-mips.c (macro) [ldd_std]: Don't attempt the GP
optimization for constant addresses.
@
text
@d6420 1
a6420 2
	  if (offset_expr.X_op == O_symbol
	      && (valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
@


1.291.2.17
log
@* config/tc-mips.c (normalize_constant_expr): Fix formatting.
@
text
@d3261 1
a3265 1
static void
@


1.291.2.18
log
@* config/tc-mips.c (normalize_constant_expr): Don't check for
HAVE_32BIT_GPRS.
(check_absolute_expr): Only call normalize_constant_expr() if
HAVE_32BIT_GPRS.
(mips_ip): Likewise.

* config/tc-mips.c (check_absolute_expr): Fix formatting.
@
text
@d3268 1
a3268 1
  if (ex->X_op == O_constant
d3428 1
a3428 2
    as_bad (_("Instruction %s requires absolute expression"),
	    ip->insn_mo->name);
d3430 1
a3430 2
  if (HAVE_32BIT_GPRS)
    normalize_constant_expr (ex);
d8106 1
a8106 2
		  if (HAVE_32BIT_GPRS)
		    normalize_constant_expr (&imm2_expr);
d8574 1
a8574 2
	      if (HAVE_32BIT_GPRS)
		normalize_constant_expr (&imm_expr);
@


1.291.2.19
log
@(macro): Use sprintf_vma to convert a > 32 bit number into a readable string.
(load_register): Likewise.
@
text
@d3558 3
a3560 4
      char value[32];

      sprintf_vma (value, ep->X_add_number);
      as_bad (_("Number (%s) larger than 32 bits"), value);
d5803 3
a5805 6
	{
	  char value [32];

	  sprintf_vma (value, offset_expr.X_add_number);
	  as_bad (_("Number (%s) larger than 32 bits"), value);
	}
d6394 3
a6396 6
	{
	  char value [32];

	  sprintf_vma (value, offset_expr.X_add_number);
	  as_bad (_("Number (%s) larger than 32 bits"), value);
	}
d11015 1
a11015 1
	      md_number_to_chars ((char *)(buf + (target_big_endian ? 4 : 0)),
d11017 1
a11017 1
	      md_number_to_chars ((char *)(buf + (target_big_endian ? 0 : 4)),
@


1.291.2.20
log
@gas/
	Backport from mainline:
	2005-06-01  Maciej W. Rozycki  <macro@@linux-mips.org>
	* config/tc-mips.c (load_register): Add leading "0x" to the
	output of sprintf_vma().
	(macro): Likewise.
gas/testsuite/
	Backport from mainline:
	2005-06-01  Maciej W. Rozycki  <macro@@linux-mips.org>
	* gas/mips/ldstla-32-1.l: Update to handle leading zeroes.
	* gas/mips/ldstla-32-mips3-1.l: Likewise.
@
text
@d3561 1
a3561 1
      as_bad (_("Number (0x%s) larger than 32 bits"), value);
d5808 1
a5808 1
	  as_bad (_("Number (0x%s) larger than 32 bits"), value);
d6402 1
a6402 1
	  as_bad (_("Number (0x%s) larger than 32 bits"), value);
@


1.290
log
@	* config/tc-mips.c (mips_set_options): Add sym32 field.
	(mips_opts): Initialize it.
	(HAVE_32BIT_ADDRESSES): Set to true if pointers are 32 bits wide.
	(HAVE_64BIT_ADDRESSES): Redefine as !HAVE_32BIT_ADDRESSES.
	(HAVE_32BIT_SYMBOLS, HAVE_64BIT_SYMBOLS): New macros.
	(load_address): Use HAVE_64BIT_SYMBOLS instead of HAVE_64BIT_ADDRESSES
	when deciding whether to use a symbolic %highest/%higher expansion.
	(macro): Likewise.  Remove o64/n32 linux hack.  Always use
	ADDRESS_ADD*_INSN for address addition in the expansion of "dla"
	and "la".  Handle constants separately from symbolic expressions in
	the "ld_st:" case, using 64-bit arithmetic if HAVE_64BIT_ADDRESSES
	and using load_register to load the high part of the address.
	(OPTION_MSYM32, OPTION_NO_MSYM32): New macros.
	(OPTION_ELF_BASE): Bump by 2.
	(md_longopts): Add entries for -msym32 and -mno-sym32.
	(md_parse_option): Handle them.
	(usage): Document them.
	(s_mipsset): Handle ".set sym32" and ".set nosym32".
	(s_cpload, s_cpsetup): Use HAVE_64BIT_SYMBOLS instead of
	HAVE_64BIT_ADDRESSES to detect 64-bit values of "_gp".
	* doc/c-mips.texi: Document ".set sym32", ".set nosym32",
	-msym32 and -mno-sym32.
@
text
@d3396 2
a3397 2
      /* _gp_disp is a special case, used from s_cpload.  _gp is used
	 if mips_no_shared.  */
d3402 2
a3403 1
		  && strcmp (S_GET_NAME (ep->X_add_symbol), "_gp") == 0));
d11823 2
a11824 2
	lui	$gp,%hi(_gp)
	addiu	$gp,$gp,%lo(_gp)
d11827 2
a11828 2
   address for _gp.  Thus code assembled with -mno-shared can go into
   an ordinary executable, but not into a shared library.  */
d11856 2
a11857 1
  ex.X_add_symbol = symbol_find_or_make (in_shared ? "_gp_disp" : "_gp");
d14123 2
@


1.289
log
@        * config/tc-mips.c (load_address): Implement GP optimization
        for 64bit address space non-PIC. Fix formatting.
        (macro): Likewise. Simplify code.
        (md_parse_option): Don't bail out if -G 0 is set for PIC code.
        (mips_after_parse_args): Simplify code.
@
text
@d192 2
d208 1
a208 1
  ISA_UNKNOWN, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, CPU_UNKNOWN
d291 10
a300 7
/* We can only have 64bit addresses if the object file format supports it.  */
#define HAVE_32BIT_ADDRESSES                           \
   (HAVE_32BIT_GPRS                                    \
    || (bfd_arch_bits_per_address (stdoutput) == 32    \
        || ! HAVE_64BIT_OBJECTS))                      \

#define HAVE_64BIT_ADDRESSES (! HAVE_32BIT_ADDRESSES)
d3872 1
a3872 1
      if (HAVE_64BIT_ADDRESSES)
d4930 1
a4930 2
	  macro_build (&offset_expr,
		       (dbl || HAVE_64BIT_ADDRESSES) ? "daddiu" : "addiu",
d4953 1
a4953 4
	load_register (tempreg, &offset_expr,
		       (mips_pic == NO_PIC
			? (dbl || HAVE_64BIT_ADDRESSES)
			: HAVE_64BIT_ADDRESSES));
d4983 1
a4983 1
	  if (HAVE_64BIT_ADDRESSES)
d5508 1
a5508 10
	{
	  char *s;

	  if (mips_pic == NO_PIC)
	    s = (dbl || HAVE_64BIT_ADDRESSES) ? "daddu" : "addu";
	  else
	    s = ADDRESS_ADD_INSN;

	  macro_build (NULL, s, "d,v,t", treg, tempreg, breg);
	}
a5876 16
      /* Sign-extending 32-bit constants makes their handling easier.
         The HAVE_64BIT_GPRS... part is due to the linux kernel hack
         described below.  */
      if ((! HAVE_64BIT_ADDRESSES
	   && (! HAVE_64BIT_GPRS && offset_expr.X_op == O_constant))
          && (offset_expr.X_op == O_constant)
	  && ! ((offset_expr.X_add_number & ~((bfd_vma) 0x7fffffff))
		== ~((bfd_vma) 0x7fffffff)))
	{
	  if (offset_expr.X_add_number & ~((bfd_vma) 0xffffffff))
	    as_bad (_("constant too large"));

	  offset_expr.X_add_number = (((offset_expr.X_add_number & 0xffffffff)
				       ^ 0x80000000) - 0x80000000);
	}

d5886 15
a5900 2
      if (mips_pic == NO_PIC
	  || offset_expr.X_op == O_constant)
d5956 2
a5957 33
	     the same sequence as in 32bit address space.

	     If we have 64-bit addresses, as an optimization, for
	     addresses which are 32-bit constants (e.g. kseg0/kseg1
	     addresses) we fall back to the 32-bit address generation
	     mechanism since it is more efficient.  Note that due to
	     the signed offset used by memory operations, the 32-bit
	     range is shifted down by 32768 here.  This code should
	     probably attempt to generate 64-bit constants more
	     efficiently in general.

	     As an extension for architectures with 64-bit registers,
	     we don't truncate 64-bit addresses given as literal
	     constants down to 32 bits, to support existing practice
	     in the mips64 Linux (the kernel), that compiles source
	     files with -mabi=64, assembling them as o32 or n32 (with
	     -Wa,-32 or -Wa,-n32).  This is not beautiful, but since
	     the whole kernel is loaded into a memory region that is
	     addressable with sign-extended 32-bit addresses, it is
	     wasteful to compute the upper 32 bits of every
	     non-literal address, that takes more space and time.
	     Some day this should probably be implemented as an
	     assembler option, such that the kernel doesn't have to
	     use such ugly hacks, even though it will still have to
	     end up converting the binary to ELF32 for a number of
	     platforms whose boot loaders don't support ELF64
	     binaries.  */
	  if ((HAVE_64BIT_ADDRESSES
	       && ! (offset_expr.X_op == O_constant
		     && IS_SEXT_32BIT_NUM (offset_expr.X_add_number + 0x8000)))
	      || (HAVE_64BIT_GPRS
		  && offset_expr.X_op == O_constant
		  && ! IS_SEXT_32BIT_NUM (offset_expr.X_add_number + 0x8000)))
d5959 1
a5959 2
	      if (offset_expr.X_op == O_symbol
		  && (valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
a6015 4
	  if (offset_expr.X_op == O_constant
	      && ! IS_SEXT_32BIT_NUM (offset_expr.X_add_number + 0x8000))
	    as_bad (_("load/store address overflow (max 32 bits)"));

d10197 4
d10204 1
a10204 1
#define OPTION_ELF_BASE    (OPTION_MISC_BASE + 14)
d10425 8
d11782 4
d11852 1
a11852 1
  in_shared = mips_in_shared || HAVE_64BIT_ADDRESSES;
d11956 1
a11956 1
  if (mips_in_shared || HAVE_64BIT_ADDRESSES)
d14108 2
@


1.288
log
@	* config/tc-mips.c (percent_op): Add %tlsgd, %tlsldm, %dtprel_hi,
	%dtprel_lo, %tprel_hi, %tprel_lo, and %gottprel.
	(parse_relocation): Check for a word break after a relocation
	operator.
	(md_apply_fix3): Handle TLS relocations, and mark thread-local
	symbols.
@
text
@d3864 3
a3866 1
       */
d3869 8
a3876 3
	  /* ??? We don't provide a GP-relative alternative for these macros.
	     It used not to be possible with the original relaxation code,
	     but it could be done now.  */
d3899 3
d3906 1
a3906 1
	      && ! nopic_need_relax (ep->X_add_symbol, 1))
d4963 19
a4981 17
	    With 64bit address space and a usable $at we want
	      lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	      lui	$at,<sym>		(BFD_RELOC_HI16_S)
	      daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	      daddiu	$at,<sym>		(BFD_RELOC_LO16)
	      dsll32	$tempreg,0
	      daddu	$tempreg,$tempreg,$at

	    If $at is already in use, we use a path which is suboptimal
	    on superscalar processors.
	      lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST)
	      daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER)
	      dsll	$tempreg,16
	      daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S)
	      dsll	$tempreg,16
	      daddiu	$tempreg,<sym>		(BFD_RELOC_LO16)
	  */
d4984 8
a4991 3
	      /* ??? We don't provide a GP-relative alternative for
		 these macros.  It used not to be possible with the
		 original relaxation code, but it could be done now.  */
d5020 3
d5027 1
a5027 1
		  && ! nopic_need_relax (offset_expr.X_add_symbol, 1))
d5966 3
d6001 19
a6019 3
	      /* ??? We don't provide a GP-relative alternative for
		 these macros.  It used not to be possible with the
		 original relaxation code, but it could be done now.  */
d6053 3
d6066 1
a6066 1
		  && ! nopic_need_relax (offset_expr.X_add_symbol, 1))
d6082 1
a6082 1
		  && ! nopic_need_relax (offset_expr.X_add_symbol, 1))
d6543 2
a6544 4
	  if ((valueT) offset_expr.X_add_number > MAX_GPREL_OFFSET
	      || nopic_need_relax (offset_expr.X_add_symbol, 1))
	    used_at = 1;
	  else
d10507 3
a10509 1
      if (mips_pic == SVR4_PIC)
a10513 3
      else
	g_switch_value = atoi (arg);
      g_switch_seen = 1;
d10660 1
a10660 2
  if (strncmp (TARGET_OS, "pe", 2) == 0
      && g_switch_value != 0)
d10662 1
a10662 1
      if (g_switch_seen)
@


1.287
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d9859 7
d9902 5
d11043 10
@


1.286
log
@2005-02-22  Eric Christopher  <echristo@@redhat.com>

	* ld-mips-elf/reloc-merge-lo16.d: Correct symbol
	table size for __start.

2005-02-22  Eric Christopher  <echristo@@redhat.com>

	* config/tc-mips.c (struct proc): Change isym to
	func_sym. New member func_end_sym.
	(s_mips_ent): Update.
	(s_mips_end): Ditto. Add code to compute function size.
@
text
@d11078 1
a11078 1
	    md_number_to_chars (buf, *valP, 8);
d11101 1
a11101 1
	md_number_to_chars (buf, *valP, 4);
d11108 1
a11108 1
	md_number_to_chars (buf, *valP, 2);
d11124 1
a11124 1
	  md_number_to_chars (buf, *valP, 2);
d11150 1
a11150 1
	  md_number_to_chars (buf, insn, 4);
d11172 1
a11172 1
	  md_number_to_chars (buf, insn, 4);
d12948 1
a12948 1
	  md_number_to_chars (buf, insn, 4);
d13020 1
a13020 1
	  md_number_to_chars (buf, insn, 4);
d13024 1
a13024 1
	  md_number_to_chars (buf, 0, 4);
d13043 1
a13043 1
	      md_number_to_chars (buf, insn, 4);
d13046 1
a13046 1
	      md_number_to_chars (buf, 0, 4);
d13065 1
a13065 1
	      md_number_to_chars (buf, insn, 4);
d13087 1
a13087 1
	      md_number_to_chars (buf, insn, 4);
d13093 1
a13093 1
		  md_number_to_chars (buf, 0, 4);
d13105 1
a13105 1
	      md_number_to_chars (buf, insn, 4);
d13114 1
a13114 1
	      md_number_to_chars (buf, insn, 4);
d13207 1
a13207 1
	  md_number_to_chars (buf, 0xf000 | extend, 2);
d13212 1
a13212 1
      md_number_to_chars (buf, insn, 2);
d13608 1
a13623 1
#ifdef OBJ_ELF
@


1.285
log
@gas/:
* config/tc-mips.c (append_insn): Call dwarf2_emit_insn() before
emitting insn.

gas/testsuite/:
* gas/mips/mips16-dwarf2.d: New test to check DWARF2 line
information for MIPS16.
* gas/mips/mips16-dwarf2.s: Source for the new test.
* gas/mips/mips.exp: Run the new test.
@
text
@d13413 2
a13414 1
  symbolS *isym;
d13598 1
a13598 1
      if (strcmp (S_GET_NAME (p), S_GET_NAME (cur_proc_ptr->isym)))
d13608 15
d13696 1
a13696 1
      cur_proc_ptr->isym = symbolP;
@


1.284
log
@	/gas/ChangeLog
	* config/tc-mips.c (macro_build_ldst_constoffset): Fail on $at
	uses after .set noat.
	(load_address): Likewise.
	(macro): Likewise. Don't try to avoid $at use by sacrificing
	the target register before it is stored, it won't work.

	/gas/testsuite/ChangeLog
	* gas/mips/noat-1.s, gas/mips/noat-1.d, gas/mips/noat-2.s,
	gas/mips/noat2.l, gas/mips/noat-3.s, gas/mips/noat-3.l,
	gas/mips/noat-4.s, gas/mips/noat-4.l, gas/mips/noat-5.s,
	gas/mips/noat-5.l, gas/mips/noat-6.s, gas/mips/noat-6.l,
	gas/mips/noat-7.s, gas/mips/noat-7.l: New files, testcases for
	.set noat in macro expansions.
	* gas/mips/mips.exp: Run new testcases.
	* gas/mips/rol-hw.d, gas/mips/rol-hw.l, gas/mips/rol.d,
	gas/mips/rol.l, gas/mips/rol.s, gas/mips/rol64-hw.d,
	gas/mips/rol64-hw.l, gas/mips/rol64.d, gas/mips/rol64.l,
	gas/mips/rol64.s, gas/mips/uld2-eb.d, gas/mips/uld2-el.d,
	gas/mips/uld2.l, gas/mips/uld2.s, gas/mips/ulh2-eb.d,
	gas/mips/ulh2-el.d, gas/mips/ulh2.l, gas/mips/ulh2.s,
	gas/mips/ulw2-eb-ilocks.d, gas/mips/ulw2-eb.d,
	gas/mips/ulw2-el-ilocks.d, gas/mips/ulw2-el.d, gas/mips/ulw2.l,
	gas/mips/ulw2.s: Don't try to test .set noat.
@
text
@d2012 9
d2255 1
a2255 6
    {
      md_number_to_chars (f, ip->insn_opcode, 4);
#ifdef OBJ_ELF
      dwarf2_emit_insn (4);
#endif
    }
a2259 8
#ifdef OBJ_ELF
      /* The value passed to dwarf2_emit_insn is the distance between
	 the end of the current instruction and the address that should
	 be recorded in the debug tables.  Since we want to use ISA-encoded
	 addresses in MIPS16 debug info, the value is one byte less than
	 the real instruction length.  */
      dwarf2_emit_insn (3);
#endif
a2268 3
#ifdef OBJ_ELF
      dwarf2_emit_insn (ip->use_extend ? 3 : 1);
#endif
@


1.283
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d3464 1
a3464 1
	as_warn (_("Macro used $at after \".set noat\""));
d4063 3
d4227 1
a4227 1
      return;
d4252 1
a4252 1
	  return;
d4254 1
d4287 1
a4287 1
	  return;
d4290 1
d4312 1
a4312 1
	  return;
d4314 1
d4325 1
a4325 1
	  return;
d4330 1
a4330 1
	  return;
d4332 1
d4359 1
a4359 1
	  return;
d4372 1
a4372 1
	  return;
d4377 1
a4377 1
	  return;
d4396 1
a4396 1
	  return;
d4398 1
d4412 1
a4412 1
	  return;
d4414 1
d4441 1
a4441 1
	  return;
d4443 1
d4454 1
a4454 1
	  return;
d4459 1
a4459 1
	  return;
d4461 1
d4473 1
a4473 1
	  return;
d4477 1
d4488 1
a4488 1
	  return;
d4493 1
a4493 1
	  return;
d4495 1
d4526 1
a4526 1
	  return;
d4531 1
a4531 1
	  return;
d4533 1
d4545 1
a4545 1
	  return;
d4549 1
d4576 1
a4576 1
	  return;
d4578 1
d4589 1
a4589 1
	  return;
d4594 1
a4594 1
	  return;
d4596 1
d4610 1
a4610 1
	  return;
d4612 1
d4663 1
a4663 1
      return;
d4712 1
a4712 1
      return;
d4731 1
a4731 1
	  return;
d4750 1
d4830 1
a4830 1
	  return;
d4838 1
a4838 1
	  return;
d4850 1
a4850 1
	  return;
d4853 1
d4898 1
a4898 1
      return;
d4925 1
a4925 1
	  return;
d5379 1
a5503 4

      if (!used_at)
	return;

d5514 1
a5514 1
      return;
d5560 1
a5560 1
      return;
d5697 1
a5697 1
      return;
d5746 1
a5746 1
	  return;
d5779 1
a5779 2
      /* XXX Why don't we try to use AT for all expansions? */
      if (!mips_opts.noat && (breg == treg || coproc || lr))
a5783 7
      else if (breg == treg
	       && (offset_expr.X_op != O_constant
		   || (offset_expr.X_add_number > 0x7fff
		       || offset_expr.X_add_number < -0x8000)))
	{
	  as_bad(_("load expansion needs $at register"));
	}
a5786 1
	  used_at = 0;
d5834 1
a5834 1
	  return;
d5856 2
a5857 17
      if (!mips_opts.noat)
	{
	  tempreg = AT;
	  used_at = 1;
	}
      else if (breg == treg
	       && (offset_expr.X_op != O_constant
		   || (offset_expr.X_add_number > 0x7fff
		       || offset_expr.X_add_number < -0x8000)))
	{
	  as_bad(_("store expansion needs $at register"));
	}
      else
	{
	  tempreg = treg;
	  used_at = 0;
	}
d6021 1
a6021 5

	      if (used_at)
		break;

	      return;
a6098 4

	      if (!used_at)
		return;

a6209 3
      if (!used_at)
	return;

d6215 1
a6215 1
      return;
d6219 1
a6219 1
      return;
d6224 1
d6238 1
a6238 1
	  return;
d6278 1
a6278 1
	  return;
d6286 1
d6292 1
d6299 4
a6302 1
	macro_build (&offset_expr, "ld", "t,o(b)", treg, BFD_RELOC_LO16, AT);
d6305 1
d6326 1
d6357 1
a6357 1
	      return;
d6366 1
d6391 1
a6391 1
	  return;
a6404 3

      if (breg != AT)
	return;
d6422 1
a6422 1
	  return;
d6440 1
a6440 1
	  return;
d6563 1
a6702 3
      if (!used_at)
	return;

d6715 1
a6715 1
      return;
d6749 1
a6749 1
      return;
d6753 1
a6753 1
      return;
d6772 1
a6772 1
	  return;
d6775 1
a6775 1
      return;
d6777 2
a6778 2
  if (mips_opts.noat)
    as_warn (_("Macro used $at after \".set noat\""));
d6820 1
a6820 1
      return;
d6828 1
d6847 1
d6880 1
d6913 1
a6913 3
	  if (used_at)
	    break;
	  return;
d6915 1
d6936 1
a6936 3
	  if (used_at)
	    break;
	  return;
d6938 1
d6960 1
a6960 1
	    return;
d6965 1
a6965 1
	    return;
d6970 1
d6987 1
a6987 1
	    return;
d6992 1
a6992 1
	    return;
d6994 1
d7005 1
a7005 1
	  return;
d7007 1
d7018 1
a7018 1
	  return;
d7020 1
d7041 1
a7041 1
	    return;
d7046 1
a7046 1
	    return;
d7051 1
d7068 1
a7068 1
	    return;
d7073 1
a7073 1
	    return;
d7075 1
d7086 1
a7086 1
	  return;
d7096 1
a7096 1
      return;
d7108 1
a7108 1
      return;
d7114 1
a7114 1
	  return;
d7121 1
a7121 1
	  return;
d7144 1
a7144 3
      if (used_at)
	break;
      return;
d7154 1
a7154 1
      return;
d7173 1
a7173 3
      if (used_at)
	break;
      return;
d7182 1
a7182 1
      return;
d7190 1
d7203 1
a7203 1
      return;
d7211 1
d7223 1
a7223 1
	  return;
d7225 1
d7237 1
a7237 1
	  return;
d7239 1
d7254 1
a7254 1
      return;
d7260 1
a7260 1
	  return;
d7268 1
a7268 1
	  return;
d7291 1
a7291 3
      if (used_at)
	break;
      return;
d7303 1
a7303 1
	  return;
d7305 1
d7320 1
a7320 1
	  return;
d7322 1
d7345 1
d7353 1
d7386 1
d7416 4
a7419 1
	tempreg = AT;
d7431 1
a7431 1
        return;
d7483 1
d7517 1
a7517 1
      return;
d7574 2
a7575 2
  if (mips_opts.noat)
    as_warn (_("Macro used $at after \".set noat\""));
d7665 1
a7665 1
      return;
@


1.282
log
@	* config/tc-mips.c (load_address): Fix formatting.
	(macro): Don't use AT if .set noat is in effect. Fix formatting.
	Catch macros which are unexpandable without AT. Remove duplicate
	zeroing of used_at.
	(macro2): Remove duplicate zeroing of used_at.
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
d2096 1
a2096 1
	  valueT tmp;
d2105 2
a2106 4
	      tmp = (address_expr->X_add_number
		     + ((valueT) 0x8000 << 32) + 0x80008000) >> 16;
	      tmp >>= 16;
	      ip->insn_opcode |= (tmp >> 16) & 0xffff;
d2110 2
a2111 2
	      tmp = (address_expr->X_add_number + 0x80008000) >> 16;
	      ip->insn_opcode |= (tmp >> 16) & 0xffff;
d2115 2
a2116 2
	      ip->insn_opcode |= ((address_expr->X_add_number + 0x8000)
				  >> 16) & 0xffff;
@


1.281
log
@bfd/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* elf32-mips.c (elf_mips16_howto_table_rel): New array for MIPS16
	reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16 relocs and
	R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into elf_mips16_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf32_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf32_rtype_to_howto): Fetch MIPS16 howtos from
	elf_mips16_howto_table_rel.
	* elf64-mips.c (mips16_elf64_howto_table_rel): New array for
	MIPS16 REL reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16
	relocs and R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into mips16_elf64_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_elf64_howto_table_rela): New array for MIPS16 RELA
	reloc howtos.  Add R_MIPS16_26, R_MIPS16_GPREL, R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs and R_MIPS16_GOT16 and R_MIPS16_CALL16
	placeholders.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf64_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf64_rtype_to_howto): Fetch MIPS16 howtos from
	mips16_elf64_howto_table_rela or mips16_elf64_howto_table_rel.
	* elfn32-mips.c (elf_mips16_howto_table_rel): New array for MIPS16
	REL reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16 relocs and
	R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into elf_mips16_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf32_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf_n32_rtype_to_howto): Fetch MIPS16 howtos from
	elf_mips16_howto_table_rela or elf_mips16_howto_table_rel.
	* elfxx-mips.c (_bfd_mips16_elf_reloc_unshuffle): New function to
	handle bit shuffling for MIPS16 relocs.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	(_bfd_mips_elf_lo16_reloc): Use _bfd_mips16_elf_reloc_unshuffle()
	and _bfd_mips16_elf_reloc_shuffle().
	(_bfd_mips_elf_generic_reloc): Likewise.
	(mips_elf_calculate_relocation): Likewise.  Handle R_MIPS16_HI16
	and R_MIPS16_LO16.
	(mips_elf_obtain_contents): Remove bit shuffling.
	(mips_elf_perform_relocation): Likewise; call
	_bfd_mips16_elf_reloc_unshuffle() and _bfd_mips16_elf_reloc_shuffle()
	instead.
	(_bfd_mips_elf_relocate_section): Likewise.  Handle R_MIPS16_HI16
	and R_MIPS16_LO16.
	* elfxx-mips.h (_bfd_mips16_elf_reloc_unshuffle): Declare.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	* reloc.c (BFD_RELOC_MIPS16_HI16): New reloc.
	(BFD_RELOC_MIPS16_HI16_S): Likewise.
	(BFD_RELOC_MIPS16_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

gas/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* config/tc-mips.c (reloc_needs_lo_p): Handle
	BFD_RELOC_MIPS16_HI16_S.
	(fixup_has_matching_lo_p): Handle BFD_RELOC_MIPS16_LO16.
	(append_insn): Add BFD_RELOC_MIPS16_GPREL, BFD_RELOC_MIPS16_HI16_S
	and BFD_RELOC_MIPS16_LO16 to relocs to suppress overflow
	complaints on.
	(mips16_ip): Resolve BFD_RELOC_MIPS16_HI16_S,
	BFD_RELOC_MIPS16_HI16 and BFD_RELOC_MIPS16_LO16 for constants.
	Call my_getSmallExpression() to parse percent operators.
	(percent_op_match, mips_percent_op): Separate definitions.
	(mips16_percent_op): Define percent operators for the MIPS16 mode.
	(parse_relocation): Handle the MIPS16 mode using
	mips16_percent_op.
	(md_apply_fix3): Handle BFD_RELOC_MIPS16_HI16,
	BFD_RELOC_MIPS16_HI16_S and BFD_RELOC_MIPS16_LO16.

gas/testsuite/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* gas/mips/mips16-hilo.d: New test for the R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs.
	* gas/mips/mips16-hilo-n32.d: Likewise, for the n32 ABI.
	* gas/mips/mips16-hilo.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

include/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* elf/mips.h (R_MIPS16_GOT16): New reloc code.
	(R_MIPS16_CALL16): Likewise.
	(R_MIPS16_HI16): Likewise.
	(R_MIPS16_LO16): Likewise.
	(R_MIPS16_min): New fake reloc code.
	(R_MIPS16_max): Likewise.

ld/testsuite/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* ld-mips-elf/mips16-hilo.d: New test for the R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs.
	* ld-mips-elf/mips16-hilo-n32.d: Likewise, for the n32 ABI.
	* ld-mips-elf/mips16-hilo.s: Auxiliary source for the new tests.
	* ld-mips-elf/mips-elf.exp: Run the new tests.
@
text
@d3880 1
a3880 1
	  if (*used_at == 0 && ! mips_opts.noat)
d4910 1
a4910 1
      if (treg == breg)
a4917 1
	  used_at = 0;
d4965 1
a4965 1
	      if (used_at == 0 && ! mips_opts.noat)
d5486 1
a5486 1
      if (! used_at)
d5764 2
a5765 1
      if (breg == treg || coproc || lr)
d5770 7
d5850 17
a5866 2
      tempreg = AT;
      used_at = 1;
d5998 1
a5998 1
	      if (used_at == 0 && ! mips_opts.noat)
d6031 3
a6049 1
		  used_at = 0;
d6113 1
a6113 1
	      if (! used_at)
d6227 1
a6227 1
      if (! used_at)
a6530 1
		  used_at = 0;
d6716 1
a6716 1
      if (! used_at)
a6922 1
	      used_at = 0;
a6946 1
	      used_at = 0;
a7136 1
	  used_at = 0;
a7144 1
	  used_at = 0;
a7174 1
	  used_at = 0;
a7283 1
	  used_at = 0;
a7291 1
	  used_at = 0;
@


1.280
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d1410 2
a1411 1
	      || reloc == BFD_RELOC_MIPS_GOT16));
d1421 2
a1422 1
	  && fixp->fx_next->fx_r_type == BFD_RELOC_LO16
d2199 4
a2202 1
		  || reloc_type[0] == BFD_RELOC_MIPS_RELGOT))
d9105 1
d9192 26
d9219 1
a9219 1
				    imm_expr.X_add_number, TRUE, mips16_small,
a9429 5
	    case '<':
	    case '>':
	    case '[':
	    case ']':
	    case '4':
a9434 1
	    case '8':
d9440 2
a9441 2
	      if (s[0] == '%'
		  && strncmp (s + 1, "gprel(", sizeof "gprel(" - 1) == 0)
d9443 1
a9443 7
		  /* This is %gprel(SYMBOL).  We need to read SYMBOL,
                     and generate the appropriate reloc.  If the text
                     inside %gprel is not a symbol name with an
                     optional offset, then we generate a normal reloc
                     and will probably fail later.  */
		  my_getExpression (&imm_expr, s + sizeof "%gprel" - 1);
		  if (imm_expr.X_op == O_symbol)
a9445 2
		      *imm_reloc = BFD_RELOC_MIPS16_GPREL;
		      s = expr_end;
a9447 1
		      continue;
d9449 8
d9458 9
a9466 6
	      else
		{
		  /* Just pick up a normal expression.  */
		  my_getExpression (&imm_expr, s);
		}

d9828 1
a9828 1
static const struct percent_op_match
d9832 3
a9834 1
} percent_op[] =
d9856 7
d9871 13
a9883 1
  size_t i;
d9885 1
a9885 1
  for (i = 0; i < ARRAY_SIZE (percent_op); i++)
d11052 2
d11105 1
@


1.279
log
@	2005-01-19  Fred Fish  <fnf@@specifixinc.com>
	* config/tc-mips.c (dummy_opcode): Add init for new struct member.
@
text
@a11144 87
#if 0
void
printInsn (unsigned long oc)
{
  const struct mips_opcode *p;
  int treg, sreg, dreg, shamt;
  short imm;
  const char *args;
  int i;

  for (i = 0; i < NUMOPCODES; ++i)
    {
      p = &mips_opcodes[i];
      if (((oc & p->mask) == p->match) && (p->pinfo != INSN_MACRO))
	{
	  printf ("%08lx %s\t", oc, p->name);
	  treg = (oc >> 16) & 0x1f;
	  sreg = (oc >> 21) & 0x1f;
	  dreg = (oc >> 11) & 0x1f;
	  shamt = (oc >> 6) & 0x1f;
	  imm = oc;
	  for (args = p->args;; ++args)
	    {
	      switch (*args)
		{
		case '\0':
		  printf ("\n");
		  break;

		case ',':
		case '(':
		case ')':
		  printf ("%c", *args);
		  continue;

		case 'r':
		  assert (treg == sreg);
		  printf ("$%d,$%d", treg, sreg);
		  continue;

		case 'd':
		case 'G':
		  printf ("$%d", dreg);
		  continue;

		case 't':
		case 'E':
		  printf ("$%d", treg);
		  continue;

		case 'k':
		  printf ("0x%x", treg);
		  continue;

		case 'b':
		case 's':
		  printf ("$%d", sreg);
		  continue;

		case 'a':
		  printf ("0x%08lx", oc & 0x1ffffff);
		  continue;

		case 'i':
		case 'j':
		case 'o':
		case 'u':
		  printf ("%d", imm);
		  continue;

		case '<':
		case '>':
		  printf ("$%d", shamt);
		  continue;

		default:
		  internalError ();
		}
	      break;
	    }
	  return;
	}
    }
  printf (_("%08lx  UNDEFINED\n"), oc);
}
#endif

a13726 23
/* The .loc directive.  */

#if 0
static void
s_loc (int x)
{
  symbolS *symbolP;
  int lineno;
  int addroff;

  assert (now_seg == text_section);

  lineno = get_number ();
  addroff = frag_now_fix ();

  symbolP = symbol_new ("", N_SLINE, addroff, frag_now);
  S_SET_TYPE (symbolP, N_SLINE);
  S_SET_OTHER (symbolP, 0);
  S_SET_DESC (symbolP, lineno);
  symbolP->sy_segment = now_seg;
}
#endif

@


1.278
log
@	* config/tc-mips.c (macro) [M_LA_AB]: Give an error for a offset
	which is too large in the case of NO_PIC without 64-bit
	addresses.
@
text
@d526 1
a526 1
static const struct mips_opcode dummy_opcode = { NULL, NULL, 0, 0, 0, 0 };
@


1.277
log
@	* config/tc-mips.c (mips_in_shared): New static variable.
	(macro_build_lui): Permit "_gp" if !mips_in_shared.
	(md_longopts): Add -mshared and -mno-shared.
	(md_parse_option): Handle OPTION_MSHARED and OPTION_MNO_SHARED.
	(s_cpload): Implement !mips_in_shared case.
	(s_cpsetup): Likewise.
	* doc/c-mips.texi (MIPS Opts): Document -mno-shared.
	* NEWS: Mention -mno-shared.
@
text
@d4999 2
@


1.276
log
@	* config/tc-mips.c (append_insn): If we emit a nop during a relax
	sequence, increase the size of the sequence.
@
text
@d139 4
d3395 2
a3396 1
      /* _gp_disp is a special case, used from s_cpload.  */
d3399 3
a3401 1
		  && strcmp (S_GET_NAME (ep->X_add_symbol), "_gp_disp") == 0));
d10130 4
d10137 1
a10137 1
#define OPTION_ELF_BASE    (OPTION_MISC_BASE + 12)
d10350 8
d11816 9
a11824 1
   The .cpload argument is normally $25 == $t9.  */
d11830 2
d11845 6
d11852 1
a11852 1
  ex.X_add_symbol = symbol_find_or_make ("_gp_disp");
d11863 3
a11865 2
  macro_build (NULL, "addu", "d,v,t", mips_gp_register,
	       mips_gp_register, tc_get_register (0));
d11885 7
a11891 1
   $reg1 is normally $25 == $t9.  */
d11953 9
a11961 2
  macro_build (&ex_sym, "lui", "t,u", mips_gp_register,
	       -1, BFD_RELOC_GPREL16, BFD_RELOC_MIPS_SUB, BFD_RELOC_HI16_S);
d11963 19
a11981 3
  macro_build (&ex_sym, "addiu", "t,r,j", mips_gp_register,
	       mips_gp_register, -1, BFD_RELOC_GPREL16,
	       BFD_RELOC_MIPS_SUB, BFD_RELOC_LO16);
a11982 2
  macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", mips_gp_register,
	       mips_gp_register, reg1);
@


1.275
log
@	* config/tc-mips.c (mips_cpu_info_table): Change "9000" entry to
	use CPU_RM9000.
@
text
@d2545 2
@


1.274
log
@	* obj.h (struct format_ops <app_file>): Add int param.
	* read.h (s_app_file_string): Likewise.
	* read.c (s_app_file_string): Likewise.
	(s_app_file): Adjust s_app_file_string call.
	* config/tc-mips.c (s_mips_file): Likewise.
	* config/obj-coff.h (obj_app_file): Add app param.
	* config/obj-ecoff.h (obj_app_file): Likewise.
	* config/obj-multi.h (obj_app_file): Likewise.
	* config/obj-elf.h (elf_file_symbol): Likewise.
	* config/obj-elf.c (elf_file_symbol): Only emit one file symbol
	if called for # preprocessor lines.
@
text
@d13823 1
a13823 1
  { "rm9000",         0,      ISA_MIPS4,      CPU_RM7000 },
@


1.273
log
@	* config/tc-mips.c (append_insn): Use fix_new rather than fix_new_exp
	to build the second and third fixups for a composite relocation.
	(macro_read_relocs): New function.
	(macro_build): Use it.
	(s_cpsetup): Pass all three composite relocation codes to macro_build.
	Simplify fragging code accordingly.
	(s_gpdword): Use fix_new rather than fix_new_exp for the second part
	of the composite relocation.  Set fx_tcbit in both fixups.
@
text
@d13511 1
a13511 1
	  s_app_file_string (filename);
@


1.272
log
@	* config/tc-mips.c (append_insn): Set fx_tcbit for composite relocs.
	(md_apply_fix3): Don't treat composite relocs as done.
@
text
@d2227 3
a2229 7
		address_expr->X_op = O_absent;
		address_expr->X_add_symbol = 0;
		address_expr->X_add_number = 0;

		fixp[i] = fix_new_exp (frag_now, fixp[0]->fx_where,
				       fixp[0]->fx_size, address_expr,
				       FALSE, reloc_type[i]);
d2974 18
d3155 1
a3155 1
	  *r = (bfd_reloc_code_real_type) va_arg (args, int);
d3171 1
a3171 1
	  *r = (bfd_reloc_code_real_type) va_arg (args, int);
a11853 1
  char *f;
d11909 2
a11910 9
  /* Ensure there's room for the next two instructions, so that `f'
     doesn't end up with an address in the wrong frag.  */
  frag_grow (8);
  f = frag_more (0);
  macro_build (&ex_sym, "lui", "t,u", mips_gp_register, BFD_RELOC_GPREL16);
  fix_new (frag_now, f - frag_now->fr_literal,
	   8, NULL, 0, 0, BFD_RELOC_MIPS_SUB);
  fix_new (frag_now, f - frag_now->fr_literal,
	   4, NULL, 0, 0, BFD_RELOC_HI16_S);
a11911 1
  f = frag_more (0);
d11913 2
a11914 5
	       mips_gp_register, BFD_RELOC_GPREL16);
  fix_new (frag_now, f - frag_now->fr_literal,
	   8, NULL, 0, 0, BFD_RELOC_MIPS_SUB);
  fix_new (frag_now, f - frag_now->fr_literal,
	   4, NULL, 0, 0, BFD_RELOC_LO16);
d12098 1
a12098 1
	       BFD_RELOC_GPREL32);
d12101 2
a12102 5
  ex.X_op = O_absent;
  ex.X_add_symbol = 0;
  ex.X_add_number = 0;
  fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &ex, FALSE,
	       BFD_RELOC_64);
@


1.271
log
@2004-10-04  Eric Christopher  <echristo@@redhat.com>

	* config/tc-mips.c (md_apply_fix3): Remove erroneous assert.
@
text
@d2234 4
a10903 1
  static int previous_fx_r_type = 0;
a10920 1
  /* We are not done if this is a composite relocation to set up gp.  */
d10922 12
a10933 8
  if (fixP->fx_addsy == NULL
      && !(fixP->fx_r_type == BFD_RELOC_MIPS_SUB
	   || (fixP->fx_r_type == BFD_RELOC_64
	       && (previous_fx_r_type == BFD_RELOC_GPREL32
		   || previous_fx_r_type == BFD_RELOC_GPREL16))
	   || (previous_fx_r_type == BFD_RELOC_MIPS_SUB
	       && (fixP->fx_r_type == BFD_RELOC_HI16_S
		   || fixP->fx_r_type == BFD_RELOC_LO16))))
a10934 1
  previous_fx_r_type = fixP->fx_r_type;
@


1.270
log
@* config/tc-mips.c (append_insn): Handle delay slots in branch likely
correctly.
@
text
@a11006 1
      assert (fixP->fx_size == 2);
@


1.269
log
@* config/tc-mips.c (append_insn): Handle constant expressions with
no associated relocation.
(mips_ip): Cancel the expression after use for the Q format
specifier.
(parse_relocation): Return no relocation for unsupported
operators.
(my_getSmallExpression): Return no relocation if no relocation
operators are used.
@
text
@d2714 1
@


1.268
log
@	* config/tc-mips.c (mips_fix_adjustable): If the full addend is
	going to be split into more than one in-place addend, return 0
	for relocations against mergeable sections.  Associate comments
	with code.
@
text
@d2086 1
a2086 1
  if (address_expr != NULL && *reloc_type < BFD_RELOC_UNUSED)
d2119 1
d2155 1
a2155 1
      else
d8604 1
d9818 1
a9818 1
	    *reloc = BFD_RELOC_LO16;
d9830 1
a9830 2
   On exit, EXPR_END points to the first character after the expression.
   If no relocation operators are used, RELOC[0] is set to BFD_RELOC_LO16.  */
d9876 1
a9876 3
  if (reloc_index == 0)
    reloc[0] = BFD_RELOC_LO16;
  else
@


1.267
log
@	* config/tc-mips.c (HAVE_IN_PLACE_ADDENDS): New macro.
	(reloc_needs_lo_p): Only return true if HAVE_IN_PLACE_ADDENDS.
	(mips_frob_file): Rework so that only a single pass through the
	relocs is needed.  Allow %lo()s to have higher offsets than their
	corresponding %hi()s or %got()s.

testsuite/
	* gas/mips/elf{,el}-rel.d: Adjust so that the earliest %hi() matches
	the earliest %lo().
	* gas/mips/elf-rel11.d: Don't expect the relocs to be reordered.
	* gas/mips/elf-rel20.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d12736 1
a12736 5
   should be converted into a reloc against a section.  Don't adjust
   MIPS16 jump relocations, so we don't have to worry about the format
   of the offset in the .o file.  Don't adjust relocations against
   mips16 symbols, so that the linker can find them if it needs to set
   up a stub.  */
d12741 2
d12753 19
d12773 2
@


1.266
log
@	* config/obj-coff.c (coff_adjust_section_syms): Use
	bfd_get_section_size instead of bfd_get_section_size_before_reloc.
	(coff_frob_section): Likewise.
	* config/tc-mips.c (md_apply_fix3): Likewise.
	* config/obj-elf.c (elf_frob_file): Use bfd_set_section_size.
	(elf_frob_file_after_relocs): Likewise.
@
text
@d282 3
d1404 3
a1406 2
  return (reloc == BFD_RELOC_HI16_S
	  || reloc == BFD_RELOC_MIPS_GOT16);
d10677 47
a10723 4
/* Sort any unmatched HI16_S relocs so that they immediately precede
   the corresponding LO reloc.  This is called before md_apply_fix3 and
   tc_gen_reloc.  Unmatched HI16_S relocs can only be generated by
   explicit use of the %hi modifier.  */
d10733 2
a10734 1
      int pass;
a10747 5
      /* Look through the fixups for this segment for a matching %lo.
         When we find one, move the %hi just in front of it.  We do
         this in two passes.  In the first pass, we try to find a
         unique %lo.  In the second pass, we permit multiple %hi
         relocs for a single %lo (this is a GNU extension).  */
a10748 3
      for (pass = 0; pass < 2; pass++)
	{
	  fixS *f, *prev;
d10750 42
a10791 32
	  prev = NULL;
	  for (f = seginfo->fix_root; f != NULL; f = f->fx_next)
	    {
	      /* Check whether this is a %lo fixup which matches l->fixp.  */
	      if (f->fx_r_type == BFD_RELOC_LO16
		  && f->fx_addsy == l->fixp->fx_addsy
		  && f->fx_offset == l->fixp->fx_offset
		  && (pass == 1
		      || prev == NULL
		      || !reloc_needs_lo_p (prev->fx_r_type)
		      || !fixup_has_matching_lo_p (prev)))
		{
		  fixS **pf;

		  /* Move l->fixp before f.  */
		  for (pf = &seginfo->fix_root;
		       *pf != l->fixp;
		       pf = &(*pf)->fx_next)
		    assert (*pf != NULL);

		  *pf = l->fixp->fx_next;

		  l->fixp->fx_next = f;
		  if (prev == NULL)
		    seginfo->fix_root = l->fixp;
		  else
		    prev->fx_next = l->fixp;

		  break;
		}

	      prev = f;
a10792 10

	  if (f != NULL)
	    break;

#if 0 /* GCC code motion plus incomplete dead code elimination
	 can leave a %hi without a %lo.  */
	  if (pass == 1)
	    as_warn_where (l->fixp->fx_file, l->fixp->fx_line,
			   _("Unmatched %%hi reloc"));
#endif
@


1.265
log
@	* config/tc-mips.c (append_insn): Use ISA-encoded addresses in MIPS16
	dwarf tables.
@
text
@d11016 1
a11016 1
		   < text_section->vma + text_section->_raw_size)
@


1.264
log
@	* config/tc-mips.c (append_insn, mips_emit_delays): Extend -mfix-vr4120
	to cope with VR4181A errata MD(1) and MD(4).
@
text
@d2245 6
a2250 1
      dwarf2_emit_insn (4);
d2262 1
a2262 1
      dwarf2_emit_insn (ip->use_extend ? 4 : 2);
@


1.263
log
@[ bfd/ChangeLog ]
2004-04-28  Chris Demetriou  <cgd@@broadcom.com>

	* reloc.c: Remove BFD_RELOC_PCREL_HI16_S and BFD_RELOC_PCREL_LO16.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.

[ gas/ChangeLog ]
2004-04-28  Chris Demetriou  <cgd@@broadcom.com>

	* config/tc-mips.c (HAVE_32BIT_ADDRESSES, append_insn, macro_build)
	(load_address, macro, mips_ip, md_parse_option)
	(mips_force_relocation, mips_validate_fix, md_apply_fix3)
	(s_change_sec, pic_need_relax, tc_gen_reloc): Remove all
	embedded-PIC handling, and update comments.
	(SWITCH_TABLE): Remove.
	* config/tc-mips.h (DIFF_EXPR_OK): Delete.
	(enum mips_pic_level): Remove EMBEDDED_PIC.
	(EXTERN_FORCE_RELOC): Remove embedded-PIC handling.
	(TC_FORCE_RELOCATION): Update comment.
	* ecoff.c (ecoff_build_lineno): Add comment about some code that
	might be safe to remove now that MIPS embedded-PIC is gone.
@
text
@d1861 2
a1862 2
	  if (strncmp(pn, "macc", 4) == 0
	      || strncmp(pn, "dmacc", 5) == 0)
d1866 1
a1866 3
		{
		  min_nops = 1;
		}
d1868 12
a1879 7
	      /* Errata 23 - Continuous DMULT[U]/DMACC instructions */
	      if (pn[0] == 'd' /* dmacc */
		  && (strncmp(tn, "dmult", 5) == 0
		      || strncmp(tn, "dmacc", 5) == 0))
		{
		  min_nops = 1;
		}
d1884 1
a1884 4
		{
		  min_nops = 1;
		}

d1886 3
a1888 3
	  else if (strncmp(pn, "dmult", 5) == 0
		   && (strncmp(tn, "dmult", 5) == 0
		       || strncmp(tn, "dmacc", 5) == 0))
d1893 11
d2841 5
a2845 6
	  if (strncmp(pn, "macc", 4) == 0
	      || strncmp(pn, "dmacc", 5) == 0
	      || strncmp(pn, "dmult", 5) == 0)
	    {
	      min_nops = 1;
	    }
@


1.262
log
@* config/tc-mips.c (s_mipsset): Set default CPU type for .set mipsN.
@
text
@d282 1
a282 2
/* We can only have 64bit addresses if the object file format
   supports it.  */
d285 2
a286 3
    || ((bfd_arch_bits_per_address (stdoutput) == 32   \
         || ! HAVE_64BIT_OBJECTS)                      \
        && mips_pic != EMBEDDED_PIC))
a2483 5
	      /* If we are generating embedded PIC code, the branch
		 might be expanded into a sequence which uses $at, so
		 we can't swap with an instruction which reads it.  */
	      || (mips_pic == EMBEDDED_PIC
		  && insn_uses_reg (&prev_insn, AT, MIPS_GR_REG))
d3128 1
a3128 3
		  || *r == BFD_RELOC_MIPS_CALL_LO16
		  || (ep->X_op == O_subtract
		      && *r == BFD_RELOC_PCREL_LO16));
d3141 1
a3141 3
			      || *r == BFD_RELOC_MIPS_CALL_HI16))
		      || (ep->X_op == O_subtract
			  && *r == BFD_RELOC_PCREL_HI16_S)));
a4009 8
  else if (mips_pic == EMBEDDED_PIC)
    {
      /* We always do
	   addiu	$reg,$gp,<sym>		(BFD_RELOC_GPREL16)
       */
      macro_build (ep, ADDRESS_ADDI_INSN, "t,r,j",
		   reg, mips_gp_register, BFD_RELOC_GPREL16);
    }
a4867 44
      /* When generating embedded PIC code, we permit expressions of
	 the form
	   la	$treg,foo-bar
	   la	$treg,foo-bar($breg)
	 where bar is an address in the current section.  These are used
	 when getting the addresses of functions.  We don't permit
	 X_add_number to be non-zero, because if the symbol is
	 external the relaxing code needs to know that any addend is
	 purely the offset to X_op_symbol.  */
      if (mips_pic == EMBEDDED_PIC
	  && offset_expr.X_op == O_subtract
	  && (symbol_constant_p (offset_expr.X_op_symbol)
	      ? S_GET_SEGMENT (offset_expr.X_op_symbol) == now_seg
	      : (symbol_equated_p (offset_expr.X_op_symbol)
		 && (S_GET_SEGMENT
		     (symbol_get_value_expression (offset_expr.X_op_symbol)
		      ->X_add_symbol)
		     == now_seg)))
	  && (offset_expr.X_add_number == 0
	      || OUTPUT_FLAVOR == bfd_target_elf_flavour))
	{
	  if (breg == 0)
	    {
	      tempreg = treg;
	      used_at = 0;
	      macro_build (&offset_expr, "lui", "t,u",
			   tempreg, BFD_RELOC_PCREL_HI16_S);
	    }
	  else
	    {
	      macro_build (&offset_expr, "lui", "t,u",
			   tempreg, BFD_RELOC_PCREL_HI16_S);
	      macro_build (NULL,
			   (dbl || HAVE_64BIT_ADDRESSES) ? "daddu" : "addu",
			   "d,v,t", tempreg, tempreg, breg);
	    }
	  macro_build (&offset_expr,
		       (dbl || HAVE_64BIT_ADDRESSES) ? "daddiu" : "addiu",
		       "t,r,j", treg, tempreg, BFD_RELOC_PCREL_LO16);
	  if (! used_at)
	    return;
	  break;
	}

d4877 1
a4877 1
		       ((mips_pic == EMBEDDED_PIC || mips_pic == NO_PIC)
a5416 8
      else if (mips_pic == EMBEDDED_PIC)
	{
	  /* We use
	       addiu	$tempreg,$gp,<sym>	(BFD_RELOC_GPREL16)
	     */
	  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j", tempreg,
		       mips_gp_register, BFD_RELOC_GPREL16);
	}
d5424 1
a5424 1
	  if (mips_pic == EMBEDDED_PIC || mips_pic == NO_PIC)
d5454 1
a5454 2
      if (mips_pic == NO_PIC
	  || mips_pic == EMBEDDED_PIC)
a5624 7
      else if (mips_pic == EMBEDDED_PIC)
	{
	  macro_build (&offset_expr, "bal", "p");
	  /* The linker may expand the call to a longer sequence which
	     uses $at, so we must break rather than return.  */
	  break;
	}
a5819 40
      /* For embedded PIC, we allow loads where the offset is calculated
         by subtracting a symbol in the current segment from an unknown
         symbol, relative to a base register, e.g.:
		<op>	$treg, <sym>-<localsym>($breg)
	 This is used by the compiler for switch statements.  */
      if (mips_pic == EMBEDDED_PIC
          && offset_expr.X_op == O_subtract
          && (symbol_constant_p (offset_expr.X_op_symbol)
              ? S_GET_SEGMENT (offset_expr.X_op_symbol) == now_seg
              : (symbol_equated_p (offset_expr.X_op_symbol)
                 && (S_GET_SEGMENT
                     (symbol_get_value_expression (offset_expr.X_op_symbol)
                      ->X_add_symbol)
                     == now_seg)))
          && breg != 0
          && (offset_expr.X_add_number == 0
              || OUTPUT_FLAVOR == bfd_target_elf_flavour))
        {
          /* For this case, we output the instructions:
                lui     $tempreg,<sym>          (BFD_RELOC_PCREL_HI16_S)
                addiu   $tempreg,$tempreg,$breg
                <op>    $treg,<sym>($tempreg)   (BFD_RELOC_PCREL_LO16)
             If the relocation would fit entirely in 16 bits, it would be
             nice to emit:
                <op>    $treg,<sym>($breg)      (BFD_RELOC_PCREL_LO16)
             instead, but that seems quite difficult.  */
          macro_build (&offset_expr, "lui", "t,u", tempreg,
		       BFD_RELOC_PCREL_HI16_S);
          macro_build (NULL,
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			? "addu" : "daddu"),
		       "d,v,t", tempreg, tempreg, breg);
          macro_build (&offset_expr, s, fmt, treg,
		       BFD_RELOC_PCREL_LO16, tempreg);
          if (! used_at)
            return;
          break;
        }

a6144 23
      else if (mips_pic == EMBEDDED_PIC)
	{
	  /* If there is no base register, we want
	       <op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16)
	     If there is a base register, we want
	       addu	$tempreg,$breg,$gp
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_GPREL16)
	     */
	  assert (offset_expr.X_op == O_symbol);
	  if (breg == 0)
	    {
	      macro_build (&offset_expr, s, fmt, treg, BFD_RELOC_GPREL16,
			   mips_gp_register);
	      used_at = 0;
	    }
	  else
	    {
	      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			   tempreg, breg, mips_gp_register);
	      macro_build (&offset_expr, s, fmt, treg,
			   BFD_RELOC_GPREL16, tempreg);
	    }
	}
a6231 9
      else if (mips_pic == EMBEDDED_PIC)
	{
	  /* For embedded PIC we pick up the entire address off $gp in
	     a single instruction.  */
	  macro_build (&offset_expr, ADDRESS_ADDI_INSN, "t,r,j", AT,
		       mips_gp_register, BFD_RELOC_GPREL16);
	  offset_expr.X_op = O_constant;
	  offset_expr.X_add_number = 0;
	}
a6411 5
      /* We do _not_ bother to allow embedded PIC (symbol-local_symbol)
	 loads for the case of doing a pair of loads to simulate an 'ld'.
	 This is not currently done by the compiler, and assembly coders
	 writing embedded-pic code can cope.  */

a6634 31
      else if (mips_pic == EMBEDDED_PIC)
	{
	  /* If there is no base register, we use
	       <op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16)
	       <op>	$treg+1,<sym>+4($gp)	(BFD_RELOC_GPREL16)
	     If we have a base register, we use
	       addu	$at,$breg,$gp
	       <op>	$treg,<sym>($at)	(BFD_RELOC_GPREL16)
	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_GPREL16)
	     */
	  if (breg == 0)
	    {
	      tempreg = mips_gp_register;
	      used_at = 0;
	    }
	  else
	    {
	      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			   AT, breg, mips_gp_register);
	      tempreg = AT;
	      used_at = 1;
	    }

	  /* Itbl support may require additional care here.  */
	  macro_build (&offset_expr, s, fmt, coproc ? treg + 1 : treg,
		       BFD_RELOC_GPREL16, tempreg);
	  offset_expr.X_add_number += 4;
	  /* Itbl support may require additional care here.  */
	  macro_build (&offset_expr, s, fmt, coproc ? treg : treg + 1,
		       BFD_RELOC_GPREL16, tempreg);
	}
a8672 7
		    When generating embedded PIC code, we use the
		    .lit8 section but not the .lit4 section (we can do
		    .lit4 inline easily; we need to put .lit8
		    somewhere in the data segment, and using .lit8
		    permits the linker to eventually combine identical
		    .lit8 entries).

d8698 1
a8698 2
			&& (mips_pic == EMBEDDED_PIC
			    || g_switch_value < 4
d8785 1
a8785 2
			if ((g_switch_value >= 8)
			    || mips_pic == EMBEDDED_PIC)
d8789 1
a8789 4
			if (mips_pic == EMBEDDED_PIC)
			  newname = ".lit8";
			else
			  newname = RDATA_SECTION_NAME;
d10339 1
a10339 1
      if (mips_pic == SVR4_PIC || mips_pic == EMBEDDED_PIC)
d10341 1
a10341 1
	  as_bad (_("-G may not be used with SVR4 or embedded PIC code"));
d10742 1
a10742 18
/* When generating embedded PIC code we need to use a special
   relocation to represent the difference of two symbols in the .text
   section (switch tables use a difference of this sort).  See
   include/coff/mips.h for details.  This macro checks whether this
   fixup requires the special reloc.  */
#define SWITCH_TABLE(fixp) \
  ((fixp)->fx_r_type == BFD_RELOC_32 \
   && OUTPUT_FLAVOR != bfd_target_elf_flavour \
   && (fixp)->fx_addsy != NULL \
   && (fixp)->fx_subsy != NULL \
   && S_GET_SEGMENT ((fixp)->fx_addsy) == text_section \
   && S_GET_SEGMENT ((fixp)->fx_subsy) == text_section)

/* When generating embedded PIC code we must keep all PC relative
   relocations, in case the linker has to relax a call.  We also need
   to keep relocations for switch table entries.

   We may have combined relocations without symbols in the N32/N64 ABI.
d10758 1
a10758 5
  return (mips_pic == EMBEDDED_PIC
	  && (fixp->fx_pcrel
	      || SWITCH_TABLE (fixp)
	      || fixp->fx_r_type == BFD_RELOC_PCREL_HI16_S
	      || fixp->fx_r_type == BFD_RELOC_PCREL_LO16));
d10798 2
a10799 3
      && (((OUTPUT_FLAVOR == bfd_target_ecoff_flavour
	    || OUTPUT_FLAVOR == bfd_target_elf_flavour)
	   && mips_pic != EMBEDDED_PIC)
d10864 2
a10865 1
  if (fixP->fx_addsy == NULL && ! fixP->fx_pcrel
d10906 1
a10906 3
      if (fixP->fx_pcrel)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Invalid PC relative reloc"));
a10916 33
    case BFD_RELOC_PCREL_HI16_S:
      /* The addend for this is tricky if it is internal, so we just
	 do everything here rather than in bfd_install_relocation.  */
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour && !fixP->fx_done)
	break;
      if (fixP->fx_addsy
	  && (symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_SECTION_SYM) == 0)
	{
	  /* For an external symbol adjust by the address to make it
	     pcrel_offset.  We use the address of the RELLO reloc
	     which follows this one.  */
	  *valP += (fixP->fx_next->fx_frag->fr_address
		    + fixP->fx_next->fx_where);
	}
      *valP = ((*valP + 0x8000) >> 16) & 0xffff;
      if (target_big_endian)
	buf += 2;
      md_number_to_chars (buf, *valP, 2);
      break;

    case BFD_RELOC_PCREL_LO16:
      /* The addend for this is tricky if it is internal, so we just
	 do everything here rather than in bfd_install_relocation.  */
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour && !fixP->fx_done)
	break;
      if (fixP->fx_addsy
	  && (symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_SECTION_SYM) == 0)
	*valP += fixP->fx_frag->fr_address + fixP->fx_where;
      if (target_big_endian)
	buf += 2;
      md_number_to_chars (buf, *valP, 2);
      break;

d10920 1
a10920 2
      if (fixP->fx_done
	  || (mips_pic == EMBEDDED_PIC && SWITCH_TABLE (fixP)))
d10944 2
a10945 5
	 resolved when it appears but is later defined.  We also need
	 to fill in the value if this is an embedded PIC switch table
	 entry.  */
      if (fixP->fx_done
	  || (mips_pic == EMBEDDED_PIC && SWITCH_TABLE (fixP)))
d10958 2
a11229 7
  /* When generating embedded PIC code, we only use the .text, .lit8,
     .sdata and .sbss sections.  We change the .data and .rdata
     pseudo-ops to use .sdata.  */
  if (mips_pic == EMBEDDED_PIC
      && (sec == 'd' || sec == 'r'))
    sec = 's';

d12373 1
a12373 3
	      || (! S_IS_WEAK (sym)
		  && (! S_IS_EXTERNAL (sym)
		      || mips_pic == EMBEDDED_PIC)))
d12726 2
a12727 51
  if (mips_pic == EMBEDDED_PIC
      && SWITCH_TABLE (fixp))
    {
      /* For a switch table entry we use a special reloc.  The addend
	 is actually the difference between the reloc address and the
	 subtrahend.  */
      reloc->addend = reloc->address - S_GET_VALUE (fixp->fx_subsy);
      if (OUTPUT_FLAVOR != bfd_target_ecoff_flavour)
	as_fatal (_("Double check fx_r_type in tc-mips.c:tc_gen_reloc"));
      fixp->fx_r_type = BFD_RELOC_GPREL32;
    }
  else if (fixp->fx_pcrel)
    {
      bfd_vma pcrel_address;

      /* Set PCREL_ADDRESS to this relocation's "PC".  The PC for high
	 high-part relocs is the address of the low-part reloc.  */
      if (fixp->fx_r_type == BFD_RELOC_PCREL_HI16_S)
	{
	  assert (fixp->fx_next != NULL
		  && fixp->fx_next->fx_r_type == BFD_RELOC_PCREL_LO16);
	  pcrel_address = (fixp->fx_next->fx_where
			   + fixp->fx_next->fx_frag->fr_address);
	}
      else
	pcrel_address = reloc->address;

      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
	{
	  /* At this point, fx_addnumber is "symbol offset - pcrel_address".
	     Relocations want only the symbol offset.  */
	  reloc->addend = fixp->fx_addnumber + pcrel_address;
	}
      else if (fixp->fx_r_type == BFD_RELOC_PCREL_LO16
	       || fixp->fx_r_type == BFD_RELOC_PCREL_HI16_S)
	{
	  /* We use a special addend for an internal RELLO or RELHI reloc.  */
	  if (symbol_section_p (fixp->fx_addsy))
	    reloc->addend = pcrel_address - S_GET_VALUE (fixp->fx_subsy);
	  else
	    reloc->addend = fixp->fx_addnumber + pcrel_address;
	}
      else
	{
	  /* A gruesome hack which is a result of the gruesome gas reloc
	     handling.  */
	  reloc->addend = pcrel_address;
	}
    }
  else
    reloc->addend = fixp->fx_addnumber;
a12736 4
  /* Since DIFF_EXPR_OK is defined in tc-mips.h, it is possible that
     fixup_segment converted a non-PC relative reloc into a PC
     relative reloc.  In such a case, we need to convert the reloc
     code.  */
a12737 30
  if (fixp->fx_pcrel)
    {
      switch (code)
	{
	case BFD_RELOC_8:
	  code = BFD_RELOC_8_PCREL;
	  break;
	case BFD_RELOC_16:
	  code = BFD_RELOC_16_PCREL;
	  break;
	case BFD_RELOC_32:
	  code = BFD_RELOC_32_PCREL;
	  break;
	case BFD_RELOC_64:
	  code = BFD_RELOC_64_PCREL;
	  break;
	case BFD_RELOC_8_PCREL:
	case BFD_RELOC_16_PCREL:
	case BFD_RELOC_32_PCREL:
	case BFD_RELOC_64_PCREL:
	case BFD_RELOC_16_PCREL_S2:
	case BFD_RELOC_PCREL_HI16_S:
	case BFD_RELOC_PCREL_LO16:
	  break;
	default:
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("Cannot make %s relocation PC relative"),
			bfd_get_reloc_code_name (code));
	}
    }
d12739 5
a12743 3
  /* To support a PC relative reloc when generating embedded PIC code
     for ECOFF, we use a Cygnus extension.  We check for that here to
     make sure that we don't let such a reloc escape normally.  */
d12746 1
a12746 2
      && code == BFD_RELOC_16_PCREL_S2
      && mips_pic != EMBEDDED_PIC)
@


1.261
log
@2004-04-22  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (md_longopts): Remove -membedded-pic option.
        (OPTION_MEMBEDDED_PIC): Remove.
        (OPTION_TRAP, OPTION_BREAK, OPTION_EB, OPTION_EL)
        (OPTION_FP32, OPTION_GP32, OPTION_CONSTRUCT_FLOATS)
        (OPTION_NO_CONSTRUCT_FLOATS, OPTIONS_FP64, OPTION_GP64)
        (OPTION_RELAX_BRANCH, OPTION_NO_RELAX_BRANCH)
        (OPTION_ELF_BASE): Renumber.
        (md_parse_option): Remove OPTION_MEMBEDDED_PIC handling.
        (md_show_usage): Remove mention of -membedded-pic.
        * doc/as.texinfo: Remove mention of -membedded-pic.
@
text
@d11848 1
a11848 1
      if (strcmp (name, "mips0") == 0)
a11851 22
	}
      else if (strcmp (name, "mips1") == 0)
	mips_opts.isa = ISA_MIPS1;
      else if (strcmp (name, "mips2") == 0)
	mips_opts.isa = ISA_MIPS2;
      else if (strcmp (name, "mips3") == 0)
	mips_opts.isa = ISA_MIPS3;
      else if (strcmp (name, "mips4") == 0)
	mips_opts.isa = ISA_MIPS4;
      else if (strcmp (name, "mips5") == 0)
	mips_opts.isa = ISA_MIPS5;
      else if (strcmp (name, "mips32") == 0)
	mips_opts.isa = ISA_MIPS32;
      else if (strcmp (name, "mips32r2") == 0)
	mips_opts.isa = ISA_MIPS32R2;
      else if (strcmp (name, "mips64") == 0)
	mips_opts.isa = ISA_MIPS64;
      else if (strcmp (name, "mips64r2") == 0)
	mips_opts.isa = ISA_MIPS64R2;
      else if (strcmp (name, "arch=default") == 0)
	{
	  reset = 1;
a11852 1
	  mips_opts.isa = file_mips_isa;
d11867 13
d11881 1
a11881 1
	as_bad (_("unknown ISA level %s"), name + 4);
@


1.260
log
@* config/tc-mips.h (USE_GLOBAL_POINTER_OPT): Remove.
* config/tc-mips.c (RDATA_SECTION_NAME, mips_target_format): Remove
a.out support.
(md_begin, mips_ip, md_parse_option, s_change_sec, s_option,
s_abicalls, nopic_need_relax, tc_gen_reloc): Remove uses of
USE_GLOBAL_POINTER_OPT.
@
text
@d10257 1
a10257 3
#define OPTION_MEMBEDDED_PIC (OPTION_MISC_BASE + 0)
  {"membedded-pic", no_argument, NULL, OPTION_MEMBEDDED_PIC},
#define OPTION_TRAP (OPTION_MISC_BASE + 1)
d10260 1
a10260 1
#define OPTION_BREAK (OPTION_MISC_BASE + 2)
d10263 1
a10263 1
#define OPTION_EB (OPTION_MISC_BASE + 3)
d10265 1
a10265 1
#define OPTION_EL (OPTION_MISC_BASE + 4)
d10267 1
a10267 1
#define OPTION_FP32 (OPTION_MISC_BASE + 5)
d10269 1
a10269 1
#define OPTION_GP32 (OPTION_MISC_BASE + 6)
d10271 1
a10271 1
#define OPTION_CONSTRUCT_FLOATS (OPTION_MISC_BASE + 7)
d10273 1
a10273 1
#define OPTION_NO_CONSTRUCT_FLOATS (OPTION_MISC_BASE + 8)
d10275 1
a10275 1
#define OPTION_FP64 (OPTION_MISC_BASE + 9)
d10277 1
a10277 1
#define OPTION_GP64 (OPTION_MISC_BASE + 10)
d10279 2
a10280 2
#define OPTION_RELAX_BRANCH (OPTION_MISC_BASE + 11)
#define OPTION_NO_RELAX_BRANCH (OPTION_MISC_BASE + 12)
d10286 1
a10286 1
#define OPTION_ELF_BASE    (OPTION_MISC_BASE + 13)
a10482 10
    case OPTION_MEMBEDDED_PIC:
      mips_pic = EMBEDDED_PIC;
      if (g_switch_seen)
	{
	  as_bad (_("-G may not be used with embedded PIC code"));
	  return 0;
	}
      g_switch_value = 0x7fffffff;
      break;

a14283 1
-membedded-pic		generate embedded position independent code\n\
@


1.259
log
@* config/tc-mips.c (macro): One more use of load_delay_nop.
@
text
@d114 1
a114 3
#define RDATA_SECTION_NAME (OUTPUT_FLAVOR == bfd_target_aout_flavour \
			    ? ".data" \
			    : OUTPUT_FLAVOR == bfd_target_ecoff_flavour \
a1083 2
    case bfd_target_aout_flavour:
      return target_big_endian ? "a.out-mips-big" : "a.out-mips-little";
d1240 1
a1240 2
  if (USE_GLOBAL_POINTER_OPT)
    bfd_set_gp_size (stdoutput, g_switch_value);
d8892 1
a8892 2
			&& (! USE_GLOBAL_POINTER_OPT
			    || mips_pic == EMBEDDED_PIC
d8980 1
a8980 1
			if ((USE_GLOBAL_POINTER_OPT && g_switch_value >= 8)
d8991 1
a8991 2
			assert (!USE_GLOBAL_POINTER_OPT
				|| g_switch_value >= 4);
d10487 1
a10487 1
      if (USE_GLOBAL_POINTER_OPT && g_switch_seen)
d10550 1
a10550 6
      if (! USE_GLOBAL_POINTER_OPT)
	{
	  as_bad (_("-G is not supported for this configuration"));
	  return 0;
	}
      else if (mips_pic == SVR4_PIC || mips_pic == EMBEDDED_PIC)
d11531 3
a11533 18
      if (USE_GLOBAL_POINTER_OPT)
	{
	  seg = subseg_new (RDATA_SECTION_NAME,
			    (subsegT) get_absolute_expression ());
	  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
	    {
	      bfd_set_section_flags (stdoutput, seg,
				     (SEC_ALLOC
				      | SEC_LOAD
				      | SEC_READONLY
				      | SEC_RELOC
				      | SEC_DATA));
	      if (strcmp (TARGET_OS, "elf") != 0)
		record_alignment (seg, 4);
	    }
	  demand_empty_rest_of_line ();
	}
      else
d11535 5
a11539 3
	  as_bad (_("No read only data section in this object file format"));
	  demand_empty_rest_of_line ();
	  return;
d11541 1
d11545 2
a11546 1
      if (USE_GLOBAL_POINTER_OPT)
d11548 4
a11551 17
	  seg = subseg_new (".sdata", (subsegT) get_absolute_expression ());
	  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
	    {
	      bfd_set_section_flags (stdoutput, seg,
				     SEC_ALLOC | SEC_LOAD | SEC_RELOC
				     | SEC_DATA);
	      if (strcmp (TARGET_OS, "elf") != 0)
		record_alignment (seg, 4);
	    }
	  demand_empty_rest_of_line ();
	  break;
	}
      else
	{
	  as_bad (_("Global pointers not supported; recompile -G 0"));
	  demand_empty_rest_of_line ();
	  return;
d11553 2
d11750 1
a11750 1
      if (USE_GLOBAL_POINTER_OPT && mips_pic == SVR4_PIC)
d11991 5
a11995 6
  if (USE_GLOBAL_POINTER_OPT)
    {
      if (g_switch_seen && g_switch_value != 0)
	as_warn (_("-G may not be used with SVR4 PIC code"));
      g_switch_value = 0;
    }
d12552 1
a12552 1
  if (USE_GLOBAL_POINTER_OPT && g_switch_value > 0)
d13058 3
a13060 6
	  if (OUTPUT_FLAVOR != bfd_target_aout_flavour)
	    /* A gruesome hack which is a result of the gruesome gas reloc
	       handling.  */
	    reloc->addend = pcrel_address;
	  else
	    reloc->addend = -pcrel_address;
@


1.258
log
@* config/tc-mips.c (load_delay_nop): New function.
(load_address, macro): Use load_delay_nop() to build a nop
which can be omitted with gpr_interlocks.

* gas/mips/lb-xgot-ilocks.d: Remove nops in load delay slot.
* gas/mips/mips-abi32-pic.d: Likewise.
* gas/mips/mips-abi32-pic2.d: Likewise.
* gas/mips/mips-gp32-fp32-pic.d: Likewise.
* gas/mips/mips-gp32-fp64-pic.d: Likewise.
* gas/mips/mips-gp64-fp32-pic.d: Likewise.
* gas/mips/mips-gp64-fp64-pic.d: Likewise.
* gas/mips/relax-swap1-mips2.d: Likewise.
* gas/mips/lb-svr4pic-ilocks.d: New test.
* gas/mips/mips.exp: Run it.
@
text
@d7557 1
a7557 2
      if (!gpr_interlocks)
	macro_build (NULL, "nop", "");
@


1.257
log
@* config/tc-mips.c (hilo_interlocks, gpr_interlocks,
cop_interlocks): Remove superfluous CPU entries.
@
text
@d3786 7
d3926 1
a3926 1
	  macro_build (NULL, "nop", "");
d4011 1
a4011 1
	  macro_build (NULL, "nop", "");
d5073 1
a5073 1
		  macro_build (NULL, "nop", "");
d5078 1
a5078 1
	      macro_build (NULL, "nop", "");
d5090 1
a5090 1
	      macro_build (NULL, "nop", "");
d5109 1
a5109 1
		  macro_build (NULL, "nop", "");
d5292 1
a5292 1
		  macro_build (NULL, "nop", "");
d5298 1
a5298 1
	      macro_build (NULL, "nop", "");
d5318 1
a5318 1
		  macro_build (NULL, "nop", "");
d5345 1
a5345 1
	      macro_build (NULL, "nop", "");
d5361 1
a5361 1
		  macro_build (NULL, "nop", "");
d5647 1
a5647 1
		  macro_build (NULL, "nop", "");
d5662 1
a5662 1
		  macro_build (NULL, "nop", "");
d5670 1
a5670 1
	      macro_build (NULL, "nop", "");
d6170 1
a6170 1
	  macro_build (NULL, "nop", "");
d6220 1
a6220 1
	  macro_build (NULL, "nop", "");
d6695 1
a6695 1
	  macro_build (NULL, "nop", "");
d6754 1
a6754 1
	  macro_build (NULL, "nop", "");
d6778 1
a6778 1
	  macro_build (NULL, "nop", "");
@


1.256
log
@2004-04-19  Eric Christopher  <echristo@@redhat.com>

        * config/tc-mips.c (mips_dwarf2_addr_size): Revert part
        of previous patch for fix in gcc.
@
text
@a348 1
   || mips_opts.arch == CPU_SB1                       \
a358 2
   || mips_opts.arch == CPU_VR5400  \
   || mips_opts.arch == CPU_VR5500  \
a373 3
   || mips_opts.arch == CPU_VR5400                    \
   || mips_opts.arch == CPU_VR5500                    \
   || mips_opts.arch == CPU_SB1                       \
@


1.255
log
@	* doc/c-mips.texi (-m{no-,}fix-vr4120): Renamed from
	-{no-}mfix-vr4122-bugs.
	* config/tc-mips.c (mips_fix_vr4120): Renamed from mips_fix_4122_bugs.
	(append_insn, mips_emit_delays): Update accordingly.
	(OPTION_FIX_VR4120, OPTION_NO_FIX_VR4120): Renamed from *VR4122.
	(md_longopts): Change -{no-,}mfix-vr4122-bugs to -m{no-,}fix-vr4120.
	(md_parse_option): Update after above changes.
	(md_show_usage): Add -mfix-vr4120.
@
text
@a14428 4
  /* GCC for 64-bit targets turns on mlong64 giving
     us 64-bit addresses.  */
  else if (mips_abi == EABI_ABI && !file_mips_gp32)
    return 8;
@


1.254
log
@2004-02-26  Eric Christopher  <echristo@@redhat.com>

	* config/tc-mips.c (mips_dwarf2_addr_size): New.
	* config/tc-mips.h (DWARF2_ADDR_SIZE): Use.
@
text
@d625 1
a625 1
static int mips_fix_4122_bugs;
d1866 1
a1866 1
      if (mips_fix_4122_bugs && prev_insn.insn_mo->name)
d1870 1
a1870 1
	     limited to the VR4122 instruction set.  */
d2844 1
a2844 1
      if (mips_fix_4122_bugs && prev_insn.insn_mo->name)
d10257 4
a10260 4
#define OPTION_FIX_VR4122 (OPTION_FIX_BASE + 2)
#define OPTION_NO_FIX_VR4122 (OPTION_FIX_BASE + 3)
  {"mfix-vr4122-bugs",    no_argument, NULL, OPTION_FIX_VR4122},
  {"no-mfix-vr4122-bugs", no_argument, NULL, OPTION_NO_FIX_VR4122},
d10502 2
a10503 2
    case OPTION_FIX_VR4122:
      mips_fix_4122_bugs = 1;
d10506 2
a10507 2
    case OPTION_NO_FIX_VR4122:
      mips_fix_4122_bugs = 0;
d14376 1
@


1.253
log
@gas/
* config/tc-mips.c (add_got_offset_hilo): New function.
(macro): Use load_register() and add_got_offset_hilo() to load
constants instead of hardcoding code sequences throughout.

gas/testsuite/
* gas/mips/div.d: Update to accomodate changes in macro
expansions.
gas/mips/elf-rel-got-n32.d: Likewise.
gas/mips/elf-rel-got-n64.d: Likewise.
gas/mips/elf-rel-xgot-n32.d: Likewise.
gas/mips/elf-rel-xgot-n64.d: Likewise.
gas/mips/la-svr4pic.d: Likewise.
gas/mips/la-xgot.d: Likewise.
gas/mips/lca-svr4pic.d: Likewise.
gas/mips/lca-xgot.d: Likewise.
@
text
@d14422 13
@


1.253.4.1
log
@2004-02-26  Eric Christopher  <echristo@@redhat.com>

	* config/tc-mips.c (mips_dwarf2_addr_size): New.
	* config/tc-mips.h (DWARF2_ADDR_SIZE): Use.
@
text
@a14421 13

int
mips_dwarf2_addr_size (void)
{
  if (mips_abi == N64_ABI)
    return 8;
  /* GCC for 64-bit targets turns on mlong64 giving
     us 64-bit addresses.  */
  else if (mips_abi == EABI_ABI && !file_mips_gp32)
    return 8;
  else
    return 4;
}
@


1.253.4.2
log
@	* doc/c-mips.texi (-m{no-,}fix-vr4120): Renamed from
	-{no-}mfix-vr4122-bugs.
	* config/tc-mips.c (mips_fix_vr4120): Renamed from mips_fix_4122_bugs.
	(append_insn, mips_emit_delays): Update accordingly.
	(OPTION_FIX_VR4120, OPTION_NO_FIX_VR4120): Renamed from *VR4122.
	(md_longopts): Change -{no-,}mfix-vr4122-bugs to -m{no-,}fix-vr4120.
	(md_parse_option): Update after above changes.
	(md_show_usage): Add -mfix-vr4120.
@
text
@d625 1
a625 1
static int mips_fix_vr4120;
d1866 1
a1866 1
      if (mips_fix_vr4120 && prev_insn.insn_mo->name)
d1870 1
a1870 1
	     limited to the VR4120 instruction set.  */
d2844 1
a2844 1
      if (mips_fix_vr4120 && prev_insn.insn_mo->name)
d10257 4
a10260 4
#define OPTION_FIX_VR4120 (OPTION_FIX_BASE + 2)
#define OPTION_NO_FIX_VR4120 (OPTION_FIX_BASE + 3)
  {"mfix-vr4120",    no_argument, NULL, OPTION_FIX_VR4120},
  {"mno-fix-vr4120", no_argument, NULL, OPTION_NO_FIX_VR4120},
d10502 2
a10503 2
    case OPTION_FIX_VR4120:
      mips_fix_vr4120 = 1;
d10506 2
a10507 2
    case OPTION_NO_FIX_VR4120:
      mips_fix_vr4120 = 0;
a14375 1
-mfix-vr4120		work around certain VR4120 errata\n\
@


1.253.4.3
log
@2004-04-19  Eric Christopher  <echristo@@redhat.com>

        * config/tc-mips.c (mips_dwarf2_addr_size): Revert part
        of previous patch for fix in gcc.
@
text
@d14429 4
@


1.253.4.4
log
@	* config/tc-mips.c (append_insn): Handle delay slots in branch likely
	correctly.
	* gas/mips/branch-swap.s: New testcase.
	* gas/mips/branch-swap.d: New testcase.
	* gas/mips/mips.exp: Run the testcase.
@
text
@a2710 1
	  prev_insn_is_delay_slot = 1;
@


1.252
log
@2004-01-24  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (hilo_interlocks): Change definition
        so that MIPS32, MIPS64 and later ISAs are included, along with
        the already-included machines.  Update comments.
@
text
@d4047 2
a4048 2
   LOCAL is the sum of a symbol and a 16-bit displacement.  The two
   alternatives are:
d4057 2
a4058 1
   emits the second.  */
d4095 26
d4704 1
a4704 2
      macro_build (&expr1, dbl ? "daddiu" : "addiu", "t,r,j", AT, 0,
		   BFD_RELOC_LO16);
d4710 1
a4710 1
	  macro_build (&expr1, "daddiu", "t,r,j", AT, 0, BFD_RELOC_LO16);
d5098 1
d5114 1
a5114 11

	      /* Set mips_optimize around the lui instruction to avoid
		 inserting an unnecessary nop after the lw.  */
	      hold_mips_optimize = mips_optimize;
	      mips_optimize = 2;
	      macro_build_lui (&expr1, AT);
	      mips_optimize = hold_mips_optimize;

	      add_got_offset (AT, &offset_expr);
	      macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t",
			   tempreg, tempreg, AT);
d5182 1
a5182 3
		  macro_build_lui (&expr1, AT);
		  macro_build (&expr1, ADDRESS_ADDI_INSN, "t,r,j",
			       AT, AT, BFD_RELOC_LO16);
d5323 1
a5323 9
	      /* Set mips_optimize around the lui instruction to avoid
		 inserting an unnecessary nop after the lw.  */
	      hold_mips_optimize = mips_optimize;
	      mips_optimize = 2;
	      macro_build_lui (&expr1, AT);
	      mips_optimize = hold_mips_optimize;

	      macro_build (&expr1, ADDRESS_ADDI_INSN, "t,r,j",
			   AT, AT, BFD_RELOC_LO16);
d5461 1
a5461 5
	      /* Set mips_optimize around the lui instruction to avoid
		 inserting an unnecessary nop after the lw.  */
	      macro_build_lui (&expr1, AT);
	      macro_build (&expr1, ADDRESS_ADDI_INSN, "t,r,j",
			   AT, AT, BFD_RELOC_LO16);
@


1.251
log
@	* config/tc-mips.c (load_address, macro): Update comments about
	NewABI GP relaxation.
@
text
@d328 2
a329 3
/* Whether the processor uses hardware interlocks to protect
   reads from the HI and LO registers, and thus does not
   require nops to be inserted.  */
d331 21
a351 5
#define hilo_interlocks (mips_opts.arch == CPU_R4010                       \
                         || mips_opts.arch == CPU_VR5500                   \
                         || mips_opts.arch == CPU_RM7000                   \
                         || mips_opts.arch == CPU_SB1                      \
                         )
@


1.250
log
@	* config/tc-mips.c (macro_build): Remove place and counter arguments.
	(mips_build_lui, macro_build_ldst_constoffset): Likewise.
	(mips16_macro_build, macro_build_jalr): Remove counter argument.
	(set_at, load_register, load_address, move_register): Likewise.
	(load_got_offset, add_got_offset): Likewise.
	Update all calls and tidy accordingly.
@
text
@d3823 3
a3825 2
	  /* We don't do GP optimization for now because RELAX_ENCODE can't
	     hold the data for such large chunks.  */
d4935 3
a4937 2
	      /* We don't do GP optimization for now because RELAX_ENCODE can't
		 hold the data for such large chunks.  */
d6022 3
a6024 2
	      /* We don't do GP optimization for now because RELAX_ENCODE can't
		 hold the data for such large chunks.  */
@


1.249
log
@	* config/tc-mips.c (RELAX_ENCODE): Remove WARN argument.
	(RELAX_FIRST, RELAX_SECOND): Turn into 8-bit quantities.
	(RELAX_USE_SECOND): Bump to 0x10000.
	(RELAX_SECOND_LONGER, RELAX_NOMACRO, RELAX_DELAY_SLOT): New flags.
	(mips_macro_warning): New variable.
	(md_assemble): Wrap macro expansion in macro_start() and macro_end().
	(s_cpload, s_cpsetup, s_cprestore, s_cpreturn): Likewise.
	(relax_close_frag): Set mips_macro_warning.first_frag.  Adjust use
	of RELAX_ENCODE.
	(append_insn): Update mips_macro_warning.sizes.
	(macro_start, macro_warning, macro_end): New functions.
	(macro_build): Don't emit warnings here.
	(macro_build_lui, md_estimate_size_before_relax): ...or here.
	(md_convert_frag): Check for cases where one macro alternative
	needs a warning and the other doesn't.  Emit a warning if the
	longer sequence was chosen.
@
text
@d853 2
a854 2
  (int *, expressionS *, const char *, const char *, va_list);
static void load_register (int *, int, expressionS *, int);
d2962 1
a2962 2
macro_build (char *place ATTRIBUTE_UNUSED, int *counter,
	     expressionS *ep, const char *name, const char *fmt, ...)
d2972 1
a2972 1
      mips16_macro_build (counter, ep, name, fmt, args);
d3190 1
a3190 2
mips16_macro_build (int *counter ATTRIBUTE_UNUSED,
		    expressionS *ep, const char *name, const char *fmt,
d3315 1
a3315 1
macro_build_jalr (int icnt, expressionS *ep)
d3324 1
a3324 1
  macro_build (NULL, &icnt, NULL, "jalr", "d,s", RA, PIC_CALL_REG);
d3334 1
a3334 2
macro_build_lui (char *place ATTRIBUTE_UNUSED, int *counter ATTRIBUTE_UNUSED,
		 expressionS *ep, int regnum)
d3383 2
a3384 2
macro_build_ldst_constoffset (char *place, int *counter, expressionS *ep,
			      const char *op, int treg, int breg, int dbl)
d3406 1
a3406 2
      macro_build (place, counter, ep, op, "t,o(b)", treg, BFD_RELOC_LO16,
		   breg);
d3415 3
a3417 9
      macro_build_lui (place, counter, ep, AT);
      if (place != NULL)
	place += 4;
      macro_build (place, counter, NULL, ADDRESS_ADD_INSN, "d,v,t", AT, AT,
		   breg);
      if (place != NULL)
	place += 4;
      macro_build (place, counter, ep, op, "t,o(b)", treg, BFD_RELOC_LO16,
		   AT);
d3429 1
a3429 1
set_at (int *counter, int reg, int unsignedp)
d3434 2
a3435 2
    macro_build (NULL, counter, &imm_expr, unsignedp ? "sltiu" : "slti",
		 "t,r,j", AT, reg, BFD_RELOC_LO16);
d3438 2
a3439 3
      load_register (counter, AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, counter, NULL, unsignedp ? "sltu" : "slt",
		   "d,v,t", AT, reg, AT);
d3545 1
a3545 1
load_register (int *counter, int reg, expressionS *ep, int dbl)
d3570 1
a3570 2
	  macro_build (NULL, counter, ep, "addiu", "t,r,j", reg, 0,
		       BFD_RELOC_LO16);
d3577 1
a3577 2
	  macro_build (NULL, counter, ep, "ori", "t,r,i", reg, 0,
		       BFD_RELOC_LO16);
d3583 1
a3583 1
	  macro_build (NULL, counter, ep, "lui", "t,u", reg, BFD_RELOC_HI16);
d3585 1
a3585 2
	    macro_build (NULL, counter, ep, "ori", "t,r,i", reg, reg,
			 BFD_RELOC_LO16);
d3596 1
a3596 2
      macro_build (NULL, counter, ep, "addiu", "t,r,j", reg, 0,
		   BFD_RELOC_LO16);
d3633 1
a3633 2
	      macro_build (NULL, counter, &lo32, "addiu", "t,r,j", reg, 0,
			   BFD_RELOC_LO16);
d3638 1
a3638 2
	      macro_build (NULL, counter, &lo32, "lui", "t,u", reg,
			   BFD_RELOC_HI16);
d3640 1
a3640 2
		macro_build (NULL, counter, &lo32, "ori", "t,r,i", reg, reg,
			     BFD_RELOC_LO16);
d3674 3
a3676 6
	      macro_build (NULL, counter, &tmp, "ori", "t,r,i", reg, 0,
			   BFD_RELOC_LO16);
	      macro_build (NULL, counter, NULL,
			   (shift >= 32) ? "dsll32" : "dsll",
			   "d,w,<", reg, reg,
			   (shift >= 32) ? shift - 32 : shift);
d3723 1
a3723 2
	      macro_build (NULL, counter, &tmp, "addiu", "t,r,j", reg, 0,
			   BFD_RELOC_LO16);
d3727 5
a3731 9
		  macro_build (NULL, counter, NULL,
			       (bit >= 32) ? "dsll32" : "dsll",
			       "d,w,<", reg, reg,
			       (bit >= 32) ? bit - 32 : bit);
		}
	      macro_build (NULL, counter, NULL,
			   (shift >= 32) ? "dsrl32" : "dsrl",
			   "d,w,<", reg, reg,
			   (shift >= 32) ? shift - 32 : shift);
d3740 1
a3740 1
      load_register (counter, reg, &hi32, 0);
d3747 1
a3747 1
	  macro_build (NULL, counter, NULL, "dsll32", "d,w,<", reg, freg, 0);
d3757 2
a3758 3
	  macro_build (NULL, counter, &lo32, "lui", "t,u", reg,
		       BFD_RELOC_HI16);
	  macro_build (NULL, counter, NULL, "dsrl32", "d,w,<", reg, reg, 0);
d3764 1
a3764 1
	  macro_build (NULL, counter, NULL, "dsll", "d,w,<", reg, freg, 16);
d3769 2
a3770 3
      macro_build (NULL, counter, &mid16, "ori", "t,r,i", reg, freg,
		   BFD_RELOC_LO16);
      macro_build (NULL, counter, NULL, "dsll", "d,w,<", reg, reg, 16);
d3774 1
a3774 2
    macro_build (NULL, counter, &lo32, "ori", "t,r,i", reg, freg,
		 BFD_RELOC_LO16);
d3780 1
a3780 1
load_address (int *counter, int reg, expressionS *ep, int *used_at)
a3781 2
  char *p = NULL;

d3791 1
a3791 1
      load_register (counter, reg, ep, HAVE_64BIT_ADDRESSES);
d3828 7
a3834 10
	      macro_build (p, counter, ep, "lui", "t,u",
			   reg, BFD_RELOC_MIPS_HIGHEST);
	      macro_build (p, counter, ep, "lui", "t,u",
			   AT, BFD_RELOC_HI16_S);
	      macro_build (p, counter, ep, "daddiu", "t,r,j",
			   reg, reg, BFD_RELOC_MIPS_HIGHER);
	      macro_build (p, counter, ep, "daddiu", "t,r,j",
			   AT, AT, BFD_RELOC_LO16);
	      macro_build (p, counter, NULL, "dsll32", "d,w,<", reg, reg, 0);
	      macro_build (p, counter, NULL, "daddu", "d,v,t", reg, reg, AT);
d3839 7
a3845 10
	      macro_build (p, counter, ep, "lui", "t,u",
			   reg, BFD_RELOC_MIPS_HIGHEST);
	      macro_build (p, counter, ep, "daddiu", "t,r,j",
			   reg, reg, BFD_RELOC_MIPS_HIGHER);
	      macro_build (p, counter, NULL, "dsll", "d,w,<", reg, reg, 16);
	      macro_build (p, counter, ep, "daddiu", "t,r,j",
			   reg, reg, BFD_RELOC_HI16_S);
	      macro_build (p, counter, NULL, "dsll", "d,w,<", reg, reg, 16);
	      macro_build (p, counter, ep, "daddiu", "t,r,j",
			   reg, reg, BFD_RELOC_LO16);
d3854 1
a3854 1
	      macro_build (NULL, counter, ep, ADDRESS_ADDI_INSN, "t,r,j", reg,
d3858 3
a3860 3
	  macro_build_lui (p, counter, ep, reg);
	  macro_build (p, counter, ep, ADDRESS_ADDI_INSN, "t,r,j", reg, reg,
		       BFD_RELOC_LO16);
d3888 2
a3889 2
	      macro_build (NULL, counter, ep, ADDRESS_LOAD_INSN, "t,o(b)",
			   reg, BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);
d3893 1
a3893 1
	      macro_build (NULL, counter, &ex, ADDRESS_ADDI_INSN, "t,r,j",
d3898 1
a3898 1
	  macro_build (p, counter, ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
d3907 3
a3909 4
	  macro_build (NULL, counter, ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
		       BFD_RELOC_MIPS_GOT16,
		       mips_gp_register);
	  macro_build (NULL, counter, NULL, "nop", "");
d3912 1
a3912 1
	  macro_build (p, counter, ep, ADDRESS_ADDI_INSN, "t,r,j", reg, reg,
d3921 1
a3921 1
	      macro_build (NULL, counter, &ex, ADDRESS_ADDI_INSN, "t,r,j",
d3951 5
a3955 6
	  macro_build (NULL, counter, ep, "lui", "t,u", reg,
		       BFD_RELOC_MIPS_GOT_HI16);
	  macro_build (NULL, counter, NULL, ADDRESS_ADD_INSN, "d,v,t", reg,
		       reg, mips_gp_register);
	  macro_build (NULL, counter, ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
		       BFD_RELOC_MIPS_GOT_LO16, reg);
d3961 2
a3962 2
	      macro_build (NULL, counter, &ex, ADDRESS_ADDI_INSN, "t,r,j",
			   reg, reg, BFD_RELOC_LO16);
d3967 1
a3967 1
	  macro_build (p, counter, ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
d3969 2
a3970 2
	  macro_build (p + 4, counter, ep, ADDRESS_ADDI_INSN, "t,r,j", reg,
		       reg, BFD_RELOC_MIPS_GOT_OFST);
d3978 5
a3982 6
	  macro_build (NULL, counter, ep, "lui", "t,u", reg,
		       BFD_RELOC_MIPS_GOT_HI16);
	  macro_build (NULL, counter, NULL, ADDRESS_ADD_INSN, "d,v,t", reg,
		       reg, mips_gp_register);
	  macro_build (NULL, counter, ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
		       BFD_RELOC_MIPS_GOT_LO16, reg);
d3990 1
a3990 1
	      macro_build (p, counter, NULL, "nop", "");
d3992 1
a3992 1
	  macro_build (p, counter, ep, ADDRESS_LOAD_INSN, "t,o(b)", reg,
d3994 2
a3995 2
	  macro_build (p, counter, NULL, "nop", "");
	  macro_build (p, counter, ep, ADDRESS_ADDI_INSN, "t,r,j", reg, reg,
d4004 2
a4005 2
	      macro_build (NULL, counter, &ex, ADDRESS_ADDI_INSN, "t,r,j",
			   reg, reg, BFD_RELOC_LO16);
d4014 2
a4015 2
      macro_build (NULL, counter, ep, ADDRESS_ADDI_INSN, "t,r,j", reg,
		   mips_gp_register, BFD_RELOC_GPREL16);
d4024 1
a4024 1
move_register (int *counter, int dest, int source)
d4026 2
a4027 2
  macro_build (NULL, counter, NULL, HAVE_32BIT_GPRS ? "addu" : "daddu",
	       "d,v,t", dest, source, 0);
d4044 1
a4044 1
load_got_offset (int *counter, int dest, expressionS *local)
d4052 2
a4053 2
  macro_build (NULL, counter, &global, ADDRESS_LOAD_INSN, "t,o(b)",
	       dest, BFD_RELOC_MIPS_GOT16, mips_gp_register);
d4055 2
a4056 2
  macro_build (NULL, counter, local, ADDRESS_LOAD_INSN, "t,o(b)",
	       dest, BFD_RELOC_MIPS_GOT16, mips_gp_register);
d4061 1
a4061 1
add_got_offset (int *counter, int dest, expressionS *local)
d4071 1
a4071 1
  macro_build (NULL, counter, &global, ADDRESS_ADDI_INSN, "t,r,j",
d4074 1
a4074 2
  macro_build (NULL, counter, local, ADDRESS_ADDI_INSN, "t,r,j",
	       dest, dest, BFD_RELOC_LO16);
a4101 1
  int icnt = 0;
d4113 1
a4114 1
  int off;
d4145 1
a4145 1
      macro_build (NULL, &icnt, &expr1, "bgez", "s,p", sreg);
d4147 1
a4147 1
	macro_build (NULL, &icnt, NULL, "nop", "", 0);
d4149 2
a4150 3
	move_register (&icnt, dreg, sreg);
      macro_build (NULL, &icnt, NULL, dbl ? "dsub" : "sub", "d,v,t", dreg, 0,
		   sreg);
d4177 1
a4177 2
	  macro_build (NULL, &icnt, &imm_expr, s, "t,r,j", treg, sreg,
		       BFD_RELOC_LO16);
d4180 2
a4181 2
      load_register (&icnt, AT, &imm_expr, dbl);
      macro_build (NULL, &icnt, NULL, s2, "d,v,t", treg, sreg, AT);
d4205 1
a4205 2
	    macro_build (NULL, &icnt, &imm_expr, s, "t,r,i", treg, sreg,
			 BFD_RELOC_LO16);
d4208 3
a4210 3
	      macro_build (NULL, &icnt, &imm_expr, "ori", "t,r,i", treg, sreg,
			   BFD_RELOC_LO16);
	      macro_build (NULL, &icnt, NULL, "nor", "d,v,t", treg, treg, 0);
d4215 2
a4216 2
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, &icnt, NULL, s2, "d,v,t", treg, sreg, AT);
d4235 1
a4235 1
	  macro_build (NULL, &icnt, &offset_expr, s, "s,t,p", sreg, 0);
d4238 2
a4239 2
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, &icnt, &offset_expr, s, "s,t,p", sreg, AT);
d4247 1
a4247 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bgezl" : "bgez",
		       "s,p", sreg);
d4252 1
a4252 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "blezl" : "blez",
		       "s,p", treg);
d4255 2
a4256 3
      macro_build (NULL, &icnt, NULL, "slt", "d,v,t", AT, sreg, treg);
      macro_build (NULL, &icnt, &offset_expr, likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d4278 1
a4278 1
	    macro_build (NULL, &icnt, NULL, "nop", "", 0);
d4280 1
a4280 1
	    macro_build (NULL, &icnt, &offset_expr, "bnel", "s,t,p", 0, 0);
d4293 1
a4293 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bgezl" : "bgez",
		       "s,p", sreg);
d4298 1
a4298 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bgtzl" : "bgtz",
		       "s,p", sreg);
d4317 1
a4317 1
	  macro_build (NULL, &icnt, &offset_expr, "b", "p");
d4320 2
a4321 3
      set_at (&icnt, sreg, 0);
      macro_build (NULL, &icnt, &offset_expr, likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d4331 1
a4331 1
	  macro_build (NULL, &icnt, &offset_expr, likely ? "beql" : "beq",
d4335 2
a4336 3
      macro_build (NULL, &icnt, NULL, "sltu", "d,v,t", AT, sreg, treg);
      macro_build (NULL, &icnt, &offset_expr, likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d4359 1
a4359 1
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bnel" : "bne",
d4363 2
a4364 3
      set_at (&icnt, sreg, 1);
      macro_build (NULL, &icnt, &offset_expr, likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d4372 1
a4372 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bgtzl" : "bgtz",
		       "s,p", sreg);
d4377 1
a4377 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bltzl" : "bltz",
		       "s,p", treg);
d4380 2
a4381 3
      macro_build (NULL, &icnt, NULL, "slt", "d,v,t", AT, treg, sreg);
      macro_build (NULL, &icnt, &offset_expr, likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d4389 1
a4389 1
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bnel" : "bne",
d4395 2
a4396 3
      macro_build (NULL, &icnt, NULL, "sltu", "d,v,t", AT, treg, sreg);
      macro_build (NULL, &icnt, &offset_expr, likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d4404 1
a4404 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "blezl" : "blez",
		       "s,p", sreg);
d4409 1
a4409 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bgezl" : "bgez",
		       "s,p", treg);
d4412 2
a4413 3
      macro_build (NULL, &icnt, NULL, "slt", "d,v,t", AT, treg, sreg);
      macro_build (NULL, &icnt, &offset_expr, likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d4441 1
a4441 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bltzl" : "bltz",
		       "s,p", sreg);
d4446 1
a4446 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "blezl" : "blez",
		       "s,p", sreg);
d4449 2
a4450 3
      set_at (&icnt, sreg, 0);
      macro_build (NULL, &icnt, &offset_expr, likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d4458 1
a4458 1
	  macro_build (NULL, &icnt, &offset_expr, likely ? "beql" : "beq",
d4464 2
a4465 3
      macro_build (NULL, &icnt, NULL, "sltu", "d,v,t", AT, treg, sreg);
      macro_build (NULL, &icnt, &offset_expr, likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d4488 1
a4488 1
	  macro_build (NULL, &icnt, &offset_expr, likely ? "beql" : "beq",
d4492 2
a4493 3
      set_at (&icnt, sreg, 1);
      macro_build (NULL, &icnt, &offset_expr, likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d4501 1
a4501 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bltzl" : "bltz",
		       "s,p", sreg);
d4506 1
a4506 2
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bgtzl" : "bgtz",
		       "s,p", treg);
d4509 2
a4510 3
      macro_build (NULL, &icnt, NULL, "slt", "d,v,t", AT, sreg, treg);
      macro_build (NULL, &icnt, &offset_expr, likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d4520 1
a4520 1
	  macro_build (NULL, &icnt, &offset_expr, likely ? "bnel" : "bne",
d4524 2
a4525 3
      macro_build (NULL, &icnt, NULL, "sltu", "d,v,t", AT, sreg, treg);
      macro_build (NULL, &icnt, &offset_expr, likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d4572 1
a4572 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s,
		     fmt, treg, sreg, pos, size - 1);
d4620 2
a4621 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s,
		     fmt, treg, sreg, pos, pos + size - 1);
d4639 1
a4639 1
	    macro_build (NULL, &icnt, NULL, "teq", "s,t,q", 0, 0, 7);
d4641 1
a4641 1
	    macro_build (NULL, &icnt, NULL, "break", "c", 7);
d4650 2
a4651 3
	  macro_build (NULL, &icnt, NULL, "teq", "s,t,q", treg, 0, 7);
	  macro_build (NULL, &icnt, NULL, dbl ? "ddiv" : "div", "z,s,t",
		       sreg, treg);
d4656 3
a4658 4
	  macro_build (NULL, &icnt, &expr1, "bne", "s,t,p", treg, 0);
	  macro_build (NULL, &icnt, NULL, dbl ? "ddiv" : "div", "z,s,t",
		       sreg, treg);
	  macro_build (NULL, &icnt, NULL, "break", "c", 7);
d4661 2
a4662 2
      macro_build (NULL, &icnt, &expr1, dbl ? "daddiu" : "addiu", "t,r,j",
		   AT, 0, BFD_RELOC_LO16);
d4664 1
a4664 1
      macro_build (NULL, &icnt, &expr1, "bne", "s,t,p", treg, AT);
d4668 2
a4669 3
	  macro_build (NULL, &icnt, &expr1, "daddiu", "t,r,j", AT, 0,
		       BFD_RELOC_LO16);
	  macro_build (NULL, &icnt, NULL, "dsll32", "d,w,<", AT, AT, 31);
d4674 1
a4674 2
	  macro_build (NULL, &icnt, &expr1, "lui", "t,u", AT,
		       BFD_RELOC_HI16);
d4678 1
a4678 1
	  macro_build (NULL, &icnt, NULL, "teq", "s,t,q", sreg, AT, 6);
d4686 2
a4687 2
	  macro_build (NULL, &icnt, &expr1, "bne", "s,t,p", sreg, AT);
	  macro_build (NULL, &icnt, NULL, "nop", "", 0);
d4693 1
a4693 1
	  macro_build (NULL, &icnt, NULL, "break", "c", 6);
d4695 1
a4695 1
      macro_build (NULL, &icnt, NULL, s, "d", dreg);
d4738 1
a4738 1
	    macro_build (NULL, &icnt, NULL, "teq", "s,t,q", 0, 0, 7);
d4740 1
a4740 1
	    macro_build (NULL, &icnt, NULL, "break", "c", 7);
d4746 1
a4746 1
	    move_register (&icnt, dreg, sreg);
d4748 1
a4748 1
	    move_register (&icnt, dreg, 0);
d4757 1
a4757 2
	      macro_build (NULL, &icnt, NULL, dbl ? "dneg" : "neg", "d,w",
			   dreg, sreg);
d4760 1
a4760 1
	    move_register (&icnt, dreg, 0);
d4764 3
a4766 3
      load_register (&icnt, AT, &imm_expr, dbl);
      macro_build (NULL, &icnt, NULL, s, "z,s,t", sreg, AT);
      macro_build (NULL, &icnt, NULL, s2, "d", dreg);
d4790 2
a4791 2
	  macro_build (NULL, &icnt, NULL, "teq", "s,t,q", treg, 0, 7);
	  macro_build (NULL, &icnt, NULL, s, "z,s,t", sreg, treg);
d4799 2
a4800 2
	  macro_build (NULL, &icnt, &expr1, "bne", "s,t,p", treg, 0);
	  macro_build (NULL, &icnt, NULL, s, "z,s,t", sreg, treg);
d4805 1
a4805 1
	  macro_build (NULL, &icnt, NULL, "break", "c", 7);
d4807 1
a4807 1
      macro_build (NULL, &icnt, NULL, s2, "d", dreg);
d4832 1
a4832 1
	  macro_build (NULL, &icnt, &offset_expr,
d4874 2
a4875 2
	      macro_build (NULL, &icnt, &offset_expr, "lui", "t,u", tempreg,
			   BFD_RELOC_PCREL_HI16_S);
d4879 3
a4881 3
	      macro_build (NULL, &icnt, &offset_expr, "lui", "t,u", tempreg,
			   BFD_RELOC_PCREL_HI16_S);
	      macro_build (NULL, &icnt, NULL,
d4885 1
a4885 1
	  macro_build (NULL, &icnt, &offset_expr,
d4901 1
a4901 1
	load_register (&icnt, tempreg, &offset_expr,
a4931 1
	  char *p = NULL;
d4939 1
a4939 1
		  macro_build (p, &icnt, &offset_expr, "lui", "t,u",
d4941 1
a4941 1
		  macro_build (p, &icnt, &offset_expr, "lui", "t,u",
d4943 1
a4943 1
		  macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
d4945 1
a4945 1
		  macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
d4947 2
a4948 4
		  macro_build (p, &icnt, NULL, "dsll32", "d,w,<",
			       tempreg, tempreg, 0);
		  macro_build (p, &icnt, NULL, "daddu", "d,v,t",
			       tempreg, tempreg, AT);
d4953 1
a4953 1
		  macro_build (p, &icnt, &offset_expr, "lui", "t,u",
d4955 1
a4955 1
		  macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
d4957 2
a4958 3
		  macro_build (p, &icnt, NULL, "dsll", "d,w,<",
			       tempreg, tempreg, 16);
		  macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
d4960 2
a4961 3
		  macro_build (p, &icnt, NULL, "dsll", "d,w,<",
			       tempreg, tempreg, 16);
		  macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
d4971 2
a4972 3
		  macro_build (NULL, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
			       "t,r,j", tempreg, mips_gp_register,
			       BFD_RELOC_GPREL16);
d4975 3
a4977 3
	      macro_build_lui (p, &icnt, &offset_expr, tempreg);
	      macro_build (p, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
			   "t,r,j", tempreg, tempreg, BFD_RELOC_LO16);
a5017 2
	      char *p = NULL;

d5022 2
a5023 2
	      macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			   "t,o(b)", tempreg, lw_reloc_type, mips_gp_register);
d5029 1
a5029 1
		  macro_build (NULL, &icnt, NULL, "nop", "");
d5032 5
a5036 6
	      macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			   "t,o(b)", tempreg, BFD_RELOC_MIPS_GOT16,
			   mips_gp_register);
	      macro_build (p, &icnt, NULL, "nop", "");
	      macro_build (p, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
			   "t,r,j", tempreg, tempreg, BFD_RELOC_LO16);
d5045 3
a5047 3
	      load_got_offset (&icnt, tempreg, &offset_expr);
	      macro_build (NULL, &icnt, NULL, "nop", "");
	      add_got_offset (&icnt, tempreg, &offset_expr);
a5050 2
	      int off1;

d5054 1
a5054 1
	      load_got_offset (&icnt, tempreg, &offset_expr);
d5062 1
a5062 3
	      if (breg != treg)
		off1 = 0;
	      else
d5064 2
a5065 2
		  macro_build (NULL, &icnt, NULL, "nop", "");
		  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
a5068 1
		  off1 = -8;
d5075 1
a5075 1
	      macro_build_lui (NULL, &icnt, &expr1, AT);
d5078 2
a5079 2
	      add_got_offset (&icnt, AT, &offset_expr);
	      macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d5086 1
a5086 2
	  char *p = NULL;
	  int adj = 0;
d5117 2
a5118 3
	      macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			   "t,o(b)", tempreg, BFD_RELOC_MIPS_GOT_DISP,
			   mips_gp_register);
d5123 2
a5124 2
		  macro_build (NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			       "t,r,j", tempreg, tempreg, BFD_RELOC_LO16);
d5142 2
a5143 2
		      macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN,
				   "d,v,t", treg, AT, breg);
d5145 1
a5145 1
		      adj = 4;
d5148 4
a5151 4
		  macro_build_lui (NULL, &icnt, &expr1, AT);
		  macro_build (NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			       "t,r,j", AT, AT, BFD_RELOC_LO16);
		  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d5162 3
a5164 4
	      macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			   "t,o(b)", tempreg, BFD_RELOC_MIPS_GOT_DISP,
			   mips_gp_register);
	      if (adj)
d5166 1
a5166 1
		  macro_build (p + 4, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d5176 2
a5177 3
	      macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			   "t,o(b)", tempreg, BFD_RELOC_MIPS_CALL16,
			   mips_gp_register);
d5179 2
a5180 3
	      macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			   "t,o(b)", tempreg, BFD_RELOC_MIPS_GOT_DISP,
			   mips_gp_register);
d5185 2
a5186 3
	      macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			   "t,o(b)", tempreg, BFD_RELOC_MIPS_GOT_DISP,
			   mips_gp_register);
d5191 1
a5191 2
	  int gpdel;
	  char *p = NULL;
d5240 1
a5240 4
	  if (reg_needs_delay (mips_gp_register))
	    gpdel = 4;
	  else
	    gpdel = 0;
d5247 2
a5248 3
	  macro_build (NULL, &icnt, &offset_expr, "lui", "t,u",
		       tempreg, lui_reloc_type);
	  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d5250 1
a5250 1
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
d5254 1
a5254 5
	      int off;

	      if (breg == 0)
		off = 0;
	      else
d5259 1
a5259 2
		  macro_build (NULL, &icnt, NULL, "nop", "");
		  off = 4;
d5265 2
a5266 2
	      macro_build (NULL, &icnt, NULL, "nop", "");
	      macro_build (NULL, &icnt, &expr1, ADDRESS_ADDI_INSN, "t,r,j",
d5271 1
a5271 1
	      int adj, dreg;
d5281 1
a5281 4
		{
		  adj = 0;
		  dreg = tempreg;
		}
d5285 2
a5286 2
		  macro_build (NULL, &icnt, NULL, "nop", "");
		  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
a5288 1
		  adj = 8;
d5295 1
a5295 1
	      macro_build_lui (NULL, &icnt, &expr1, AT);
d5298 1
a5298 1
	      macro_build (NULL, &icnt, &expr1, ADDRESS_ADDI_INSN, "t,r,j",
d5300 1
a5300 2
	      macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
			   dreg, dreg, AT);
d5308 1
a5308 1
	  if (gpdel > 0)
d5312 1
a5312 1
	      macro_build (p, &icnt, NULL, "nop", "");
d5315 2
a5316 2
	  macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, local_reloc_type, mips_gp_register);
d5320 3
a5322 3
	      macro_build (p, &icnt, NULL, "nop", "");
	      macro_build (p, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
			   "t,r,j", tempreg, tempreg, BFD_RELOC_LO16);
d5336 2
a5337 2
		  macro_build (p, &icnt, NULL, "nop", "");
		  macro_build (p, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d5345 2
a5346 2
	      macro_build_lui (p, &icnt, &expr1, AT);
	      macro_build (p, &icnt, &offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
d5348 1
a5348 1
	      macro_build (p, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
a5354 1
	  char *p = NULL;
d5357 1
a5357 1
	  int adj = 0;
d5401 2
a5402 3
	  macro_build (NULL, &icnt, &offset_expr, "lui", "t,u",
		       tempreg, lui_reloc_type);
	  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d5404 2
a5405 2
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", tempreg, lw_reloc_type, tempreg);
d5412 1
a5412 1
	      macro_build (NULL, &icnt, &expr1, ADDRESS_ADDI_INSN, "t,r,j",
d5431 1
a5431 1
		  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d5434 1
a5434 1
		  adj = 4;
d5439 4
a5442 5
	      macro_build_lui (NULL, &icnt, &expr1, AT);
	      macro_build (NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			   "t,r,j", AT, AT, BFD_RELOC_LO16);
	      macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
			   dreg, dreg, AT);
d5451 5
a5455 5
	  macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
	  macro_build (p + 4, &icnt, &offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
		       tempreg, tempreg, BFD_RELOC_MIPS_GOT_OFST);
	  if (adj)
d5457 1
a5457 1
	      macro_build (p + 8, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d5469 2
a5470 2
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
		       tempreg, mips_gp_register, BFD_RELOC_GPREL16);
d5484 1
a5484 1
	  macro_build (NULL, &icnt, NULL, s, "d,v,t", treg, tempreg, breg);
d5497 1
a5497 1
	macro_build (NULL, &icnt, &offset_expr, "j", "a");
d5499 1
a5499 1
	macro_build (NULL, &icnt, &offset_expr, "b", "p");
d5511 1
a5511 1
	macro_build (NULL, &icnt, NULL, "jalr", "d,s", dreg, sreg);
d5517 1
a5517 1
	  macro_build (NULL, &icnt, NULL, "jalr", "d,s", dreg, sreg);
d5537 1
a5537 2
  		  macro_build_ldst_constoffset (NULL, &icnt, &expr1,
						ADDRESS_LOAD_INSN,
d5551 1
a5551 1
	macro_build (NULL, &icnt, &offset_expr, "jal", "a");
a5553 2
	  char *p = NULL;

d5587 2
a5588 2
		  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			       "t,o(b)", PIC_CALL_REG, BFD_RELOC_MIPS_CALL16,
d5591 2
a5592 2
		  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			       "t,o(b)", PIC_CALL_REG, BFD_RELOC_MIPS_GOT_DISP,
d5599 7
a5605 7
		  macro_build (NULL, &icnt, &offset_expr, "lui", "t,u",
			       PIC_CALL_REG, BFD_RELOC_MIPS_CALL_HI16);
		  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
			       PIC_CALL_REG, PIC_CALL_REG, mips_gp_register);
		  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			       "t,o(b)", PIC_CALL_REG,
			       BFD_RELOC_MIPS_CALL_LO16, PIC_CALL_REG);
d5607 5
a5611 5
		  macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			       "t,o(b)", PIC_CALL_REG,
			       BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
		  macro_build (p + 4, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
			       "t,r,j", PIC_CALL_REG, PIC_CALL_REG,
d5616 1
a5616 1
	      macro_build_jalr (icnt, &offset_expr);
d5623 2
a5624 2
		  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			       "t,o(b)", PIC_CALL_REG, BFD_RELOC_MIPS_CALL16,
d5626 1
a5626 1
		  macro_build (NULL, &icnt, NULL, "nop", "");
d5631 1
a5631 1
		  int gpdel;
d5633 9
a5641 12
		  if (reg_needs_delay (mips_gp_register))
		    gpdel = 4;
		  else
		    gpdel = 0;
		  macro_build (NULL, &icnt, &offset_expr, "lui", "t,u",
			       PIC_CALL_REG, BFD_RELOC_MIPS_CALL_HI16);
		  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
			       PIC_CALL_REG, PIC_CALL_REG, mips_gp_register);
		  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			       "t,o(b)", PIC_CALL_REG,
			       BFD_RELOC_MIPS_CALL_LO16, PIC_CALL_REG);
		  macro_build (NULL, &icnt, NULL, "nop", "");
d5643 2
a5644 5
		  if (gpdel > 0)
		    {
		      macro_build (p, &icnt, NULL, "nop", "");
		      p += 4;
		    }
d5646 2
a5647 2
	      macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			   "t,o(b)", PIC_CALL_REG, BFD_RELOC_MIPS_GOT16,
d5649 3
a5651 4
	      macro_build (p, &icnt, NULL, "nop", "");
	      macro_build (p, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
			   "t,r,j", PIC_CALL_REG, PIC_CALL_REG,
			   BFD_RELOC_LO16);
d5653 1
a5653 1
	      macro_build_jalr (icnt, &offset_expr);
d5672 1
a5672 1
		    macro_build (NULL, &icnt, NULL, "nop", "");
d5674 1
a5674 2
  		  macro_build_ldst_constoffset (NULL, &icnt, &expr1,
					        ADDRESS_LOAD_INSN,
d5683 1
a5683 1
	  macro_build (NULL, &icnt, &offset_expr, "bal", "p");
d5909 1
a5909 1
          macro_build (NULL, &icnt, &offset_expr, "lui", "t,u", tempreg,
d5911 7
a5917 7
          macro_build (NULL, &icnt, NULL,
                       ((bfd_arch_bits_per_address (stdoutput) == 32
                         || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
                        ? "addu" : "daddu"),
                       "d,v,t", tempreg, tempreg, breg);
          macro_build (NULL, &icnt, &offset_expr, s, fmt, treg,
                       BFD_RELOC_PCREL_LO16, tempreg);
a5934 2
	  char *p = NULL;

a6019 2
	      p = NULL;

d6025 6
a6030 6
		  macro_build (p, &icnt, &offset_expr, "lui", "t,u",
			       tempreg, BFD_RELOC_MIPS_HIGHEST);
		  macro_build (p, &icnt, &offset_expr, "lui", "t,u",
			       AT, BFD_RELOC_HI16_S);
		  macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
			       tempreg, tempreg, BFD_RELOC_MIPS_HIGHER);
d6032 5
a6036 8
		    macro_build (p, &icnt, NULL, "daddu", "d,v,t",
				 AT, AT, breg);
		  macro_build (p, &icnt, NULL, "dsll32", "d,w,<",
			       tempreg, tempreg, 0);
		  macro_build (p, &icnt, NULL, "daddu", "d,v,t",
			       tempreg, tempreg, AT);
		  macro_build (p, &icnt, &offset_expr, s, fmt, treg,
			       BFD_RELOC_LO16, tempreg);
d6041 8
a6048 10
		  macro_build (p, &icnt, &offset_expr, "lui", "t,u",
			       tempreg, BFD_RELOC_MIPS_HIGHEST);
		  macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
			       tempreg, tempreg, BFD_RELOC_MIPS_HIGHER);
		  macro_build (p, &icnt, NULL, "dsll", "d,w,<",
			       tempreg, tempreg, 16);
		  macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
			       tempreg, tempreg, BFD_RELOC_HI16_S);
		  macro_build (p, &icnt, NULL, "dsll", "d,w,<",
			       tempreg, tempreg, 16);
d6050 1
a6050 1
		    macro_build (p, &icnt, NULL, "daddu", "d,v,t",
d6052 1
a6052 1
		  macro_build (p, &icnt, &offset_expr, s, fmt, treg,
d6065 2
a6066 4
	      if ((valueT) offset_expr.X_add_number > MAX_GPREL_OFFSET
		  || nopic_need_relax (offset_expr.X_add_symbol, 1))
		p = NULL;
	      else
d6069 2
a6070 2
		  macro_build (NULL, &icnt, &offset_expr, s, fmt, treg,
			       BFD_RELOC_GPREL16, mips_gp_register);
d6074 2
a6075 2
	      macro_build_lui (p, &icnt, &offset_expr, tempreg);
	      macro_build (p, &icnt, &offset_expr, s, fmt, treg,
d6082 2
a6083 4
	      if ((valueT) offset_expr.X_add_number > MAX_GPREL_OFFSET
		  || nopic_need_relax (offset_expr.X_add_symbol, 1))
		p = NULL;
	      else
d6086 1
a6086 1
		  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6088 1
a6088 1
		  macro_build (NULL, &icnt, &offset_expr, s, fmt, treg,
d6092 2
a6093 2
	      macro_build_lui (p, &icnt, &offset_expr, tempreg);
	      macro_build (p, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6095 1
a6095 1
	      macro_build (p, &icnt, &offset_expr, s, fmt, treg,
a6102 1
	  char *p = NULL;
d6128 2
a6129 3
	      macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			   "t,o(b)", tempreg, BFD_RELOC_MIPS_GOT_PAGE,
			   mips_gp_register);
d6131 1
a6131 1
		macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6133 1
a6133 1
	      macro_build (NULL, &icnt, &offset_expr, s, fmt, treg,
d6146 3
a6148 3
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, lw_reloc_type, mips_gp_register);
	  macro_build (NULL, &icnt, NULL, "nop", "");
d6151 2
a6152 2
	  macro_build (p, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
		       "t,r,j", tempreg, tempreg, BFD_RELOC_LO16);
d6155 1
a6155 1
	    macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6157 1
a6157 2
	  macro_build (NULL, &icnt, &expr1, s, fmt, treg, BFD_RELOC_LO16,
		       tempreg);
d6161 1
a6161 2
	  int gpdel;
	  char *p = NULL;
d6185 1
a6185 4
	  if (reg_needs_delay (mips_gp_register))
	    gpdel = 4;
	  else
	    gpdel = 0;
d6187 1
a6187 1
	  macro_build (NULL, &icnt, &offset_expr, "lui", "t,u", tempreg,
d6189 4
a6192 4
	  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
		       tempreg, tempreg, mips_gp_register);
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, BFD_RELOC_MIPS_GOT_LO16, tempreg);
d6194 7
a6200 7
	  if (gpdel > 0)
	    macro_build (p, &icnt, NULL, "nop", "");
	  macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, BFD_RELOC_MIPS_GOT16, mips_gp_register);
	  macro_build (p, &icnt, NULL, "nop", "");
	  macro_build (p, &icnt, &offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
		       tempreg, tempreg, BFD_RELOC_LO16);
d6204 1
a6204 1
	    macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6206 1
a6206 2
	  macro_build (NULL, &icnt, &expr1, s, fmt, treg, BFD_RELOC_LO16,
		       tempreg);
a6209 3
	  char *p = NULL;
	  int bregsz = breg != 0 ? 4 : 0;

d6225 1
a6225 1
	  macro_build (NULL, &icnt, &offset_expr, "lui", "t,u", tempreg,
d6227 4
a6230 4
	  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
		       tempreg, tempreg, mips_gp_register);
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, BFD_RELOC_MIPS_GOT_LO16, tempreg);
d6232 1
a6232 1
	    macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6234 1
a6234 2
	  macro_build (NULL, &icnt, &expr1, s, fmt, treg, BFD_RELOC_LO16,
		       tempreg);
d6238 2
a6239 2
	  macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
d6241 1
a6241 1
	    macro_build (p + 4, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6243 1
a6243 1
	  macro_build (p + 4 + bregsz, &icnt, &offset_expr, s, fmt, treg,
d6258 2
a6259 2
	      macro_build (NULL, &icnt, &offset_expr, s, fmt, treg,
			   BFD_RELOC_GPREL16, mips_gp_register);
d6264 1
a6264 1
	      macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6266 1
a6266 1
	      macro_build (NULL, &icnt, &offset_expr, s, fmt, treg,
d6280 1
a6280 1
      load_register (&icnt, treg, &imm_expr, 0);
d6284 1
a6284 1
      load_register (&icnt, treg, &imm_expr, 1);
d6290 2
a6291 2
	  load_register (&icnt, AT, &imm_expr, 0);
	  macro_build (NULL, &icnt, NULL, "mtc1", "t,G", AT, treg);
d6301 1
a6301 1
	  macro_build (NULL, &icnt, &offset_expr, "lwc1", "T,o(b)", treg,
d6314 1
a6314 1
	    load_register (&icnt, treg, &imm_expr, 1);
d6331 1
a6331 1
		load_register (&icnt, hreg, &imm_expr, 0);
d6335 1
a6335 1
		    move_register (&icnt, lreg, 0);
d6339 1
a6339 1
		      load_register (&icnt, lreg, &offset_expr, 0);
d6350 1
a6350 1
	  macro_build_lui (NULL, &icnt, &offset_expr, AT);
d6354 2
a6355 2
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       AT, BFD_RELOC_MIPS_GOT16, mips_gp_register);
d6361 2
a6362 2
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_ADDI_INSN, "t,r,j",
		       AT, mips_gp_register, BFD_RELOC_GPREL16);
d6371 1
a6371 2
	macro_build (NULL, &icnt, &offset_expr, "ld", "t,o(b)", treg,
		     BFD_RELOC_LO16, AT);
d6374 1
a6374 2
	  macro_build (NULL, &icnt, &offset_expr, "lw", "t,o(b)", treg,
		       BFD_RELOC_LO16, AT);
d6380 1
a6380 1
	      macro_build (NULL, &icnt, &offset_expr, "lw", "t,o(b)",
d6394 1
a6394 1
	  load_register (&icnt, AT, &imm_expr, HAVE_64BIT_FPRS);
d6398 1
a6398 1
	      macro_build (NULL, &icnt, NULL, "dmtc1", "t,S", AT, treg);
d6402 1
a6402 1
	      macro_build (NULL, &icnt, NULL, "mtc1", "t,G", AT, treg + 1);
d6404 1
a6404 1
		macro_build (NULL, &icnt, NULL, "mtc1", "t,G", 0, treg);
d6408 2
a6409 2
		  load_register (&icnt, AT, &offset_expr, 0);
		  macro_build (NULL, &icnt, NULL, "mtc1", "t,G", AT, treg);
d6422 1
a6422 1
	      macro_build (NULL, &icnt, &offset_expr, "ldc1", "T,o(b)", treg,
d6434 2
a6435 3
	    macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			 "t,o(b)", AT, BFD_RELOC_MIPS_GOT16,
			 mips_gp_register);
d6439 1
a6439 1
	      macro_build_lui (NULL, &icnt, &offset_expr, AT);
d6444 2
a6445 2
	      macro_build (NULL, &icnt, &offset_expr, "ldc1", "T,o(b)", treg,
			   BFD_RELOC_LO16, AT);
d6464 1
a6464 1
      macro_build (NULL, &icnt, &offset_expr, "lwc1", "T,o(b)",
d6469 1
a6469 1
      macro_build (NULL, &icnt, &offset_expr, "lwc1", "T,o(b)",
a6567 2
	  char *p = NULL;

d6584 1
a6584 4
	    {
	      p = NULL;
	      used_at = 1;
	    }
a6586 2
	      int off;

a6590 1
		  off = 0;
d6595 1
a6595 1
		  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
a6597 1
		  off = 4;
d6602 1
a6602 2
	      macro_build (NULL, &icnt, &offset_expr, s, fmt,
			   coproc ? treg + 1 : treg,
d6611 1
a6611 2
	      macro_build (NULL, &icnt, &offset_expr, s, fmt,
			   coproc ? treg : treg + 1,
d6638 1
a6638 1
	  macro_build_lui (p, &icnt, &offset_expr, AT);
d6640 1
a6640 2
	    macro_build (p, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
			   AT, breg, AT);
d6642 1
a6642 2
	  macro_build (p, &icnt, &offset_expr, s, fmt,
		       coproc ? treg + 1 : treg,
d6647 1
a6647 2
	  macro_build (p, &icnt, &offset_expr, s, fmt,
		       coproc ? treg : treg + 1,
a6653 2
	  int off;

d6672 2
a6673 6
	  if (breg == 0)
	    off = 0;
	  else
	    off = 4;
	  load_got_offset (&icnt, AT, &offset_expr);
	  macro_build (NULL, &icnt, NULL, "nop", "");
d6675 1
a6675 2
	    macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
			 AT, breg, AT);
d6684 2
a6685 2
	  macro_build (NULL, &icnt, &expr1, s, fmt,
		       coproc ? treg + 1 : treg, BFD_RELOC_LO16, AT);
d6687 2
a6688 2
	  macro_build (NULL, &icnt, &expr1, s, fmt,
		       coproc ? treg : treg + 1, BFD_RELOC_LO16, AT);
d6690 2
a6691 2
	  macro_build (NULL, &icnt, &offset_expr, s, fmt,
		       coproc ? treg + 1 : treg, BFD_RELOC_LO16, AT);
d6693 2
a6694 2
	  macro_build (NULL, &icnt, &offset_expr, s, fmt,
		       coproc ? treg : treg + 1, BFD_RELOC_LO16, AT);
d6701 1
a6701 2
	  int gpdel, off;
	  char *p = NULL;
d6724 1
a6724 8
	  if (reg_needs_delay (mips_gp_register))
	    gpdel = 4;
	  else
	    gpdel = 0;
	  if (breg == 0)
	    off = 0;
	  else
	    off = 4;
d6726 3
a6728 3
	  macro_build (NULL, &icnt, &offset_expr, "lui", "t,u", AT,
		       BFD_RELOC_MIPS_GOT_HI16);
	  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6730 1
a6730 1
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
d6732 1
a6732 1
	  macro_build (NULL, &icnt, NULL, "nop", "");
d6734 1
a6734 2
	    macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
			 AT, breg, AT);
d6736 1
a6736 1
	  macro_build (NULL, &icnt, &expr1, s, fmt, coproc ? treg + 1 : treg,
d6745 1
a6745 1
	  macro_build (NULL, &icnt, &expr1, s, fmt, coproc ? treg : treg + 1,
d6752 5
a6756 5
	  if (gpdel > 0)
	    macro_build (p, &icnt, NULL, "nop", "");
	  macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       AT, BFD_RELOC_MIPS_GOT16, mips_gp_register);
	  macro_build (p, &icnt, NULL, "nop", "");
d6758 1
a6758 2
	    macro_build (p, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
			 AT, breg, AT);
d6760 2
a6761 2
	  macro_build (p, &icnt, &offset_expr, s, fmt,
		       coproc ? treg + 1 : treg, BFD_RELOC_LO16, AT);
d6769 2
a6770 2
	  macro_build (p, &icnt, &offset_expr, s, fmt,
		       coproc ? treg : treg + 1, BFD_RELOC_LO16, AT);
d6791 1
a6791 1
	      macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
d6798 1
a6798 2
	  macro_build (NULL, &icnt, &offset_expr, s, fmt,
		       coproc ? treg + 1 : treg,
d6802 1
a6802 2
	  macro_build (NULL, &icnt, &offset_expr, s, fmt,
		       coproc ? treg : treg + 1,
d6820 1
a6820 2
      macro_build (NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
		   BFD_RELOC_LO16, breg);
d6822 1
a6822 2
      macro_build (NULL, &icnt, &offset_expr, s, "t,o(b)", treg + 1,
		   BFD_RELOC_LO16, breg);
d6856 1
a6856 1
      macro_build (NULL, &icnt, NULL, s, "C", ip->insn_opcode);
d6860 1
a6860 1
      move_register (&icnt, dreg, sreg);
d6879 1
a6879 1
	  macro_build (NULL, &icnt, &immed_expr, s, "C");
a6894 1
  int icnt = 0;
a6907 1
  char *p;
d6926 2
a6927 3
      macro_build (NULL, &icnt, NULL, dbl ? "dmultu" : "multu", "s,t",
		   sreg, treg);
      macro_build (NULL, &icnt, NULL, "mflo", "d", dreg);
d6936 3
a6938 4
      load_register (&icnt, AT, &imm_expr, dbl);
      macro_build (NULL, &icnt, NULL, dbl ? "dmult" : "mult", "s,t",
		   sreg, AT);
      macro_build (NULL, &icnt, NULL, "mflo", "d", dreg);
d6955 5
a6959 7
	load_register (&icnt, AT, &imm_expr, dbl);
      macro_build (NULL, &icnt, NULL, dbl ? "dmult" : "mult", "s,t",
		   sreg, imm ? AT : treg);
      macro_build (NULL, &icnt, NULL, "mflo", "d", dreg);
      macro_build (NULL, &icnt, NULL, dbl ? "dsra32" : "sra", "d,w,<",
		   dreg, dreg, RA);
      macro_build (NULL, &icnt, NULL, "mfhi", "d", AT);
d6961 1
a6961 1
	macro_build (NULL, &icnt, NULL, "tne", "s,t,q", dreg, AT, 6);
d6965 3
a6967 3
	  macro_build (NULL, &icnt, &expr1, "beq", "s,t,p", dreg, AT);
	  macro_build (NULL, &icnt, NULL, "nop", "", 0);
	  macro_build (NULL, &icnt, NULL, "break", "c", 6);
d6970 1
a6970 1
      macro_build (NULL, &icnt, NULL, "mflo", "d", dreg);
d6987 2
a6988 2
	load_register (&icnt, AT, &imm_expr, dbl);
      macro_build (NULL, &icnt, NULL, dbl ? "dmultu" : "multu", "s,t",
d6990 2
a6991 2
      macro_build (NULL, &icnt, NULL, "mfhi", "d", AT);
      macro_build (NULL, &icnt, NULL, "mflo", "d", dreg);
d6993 1
a6993 1
	macro_build (NULL, &icnt, NULL, "tne", "s,t,q", AT, 0, 6);
d6997 3
a6999 3
	  macro_build (NULL, &icnt, &expr1, "beq", "s,t,p", AT, 0);
	  macro_build (NULL, &icnt, NULL, "nop", "", 0);
	  macro_build (NULL, &icnt, NULL, "break", "c", 6);
d7017 2
a7018 3
	  macro_build (NULL, &icnt, NULL, "dnegu", "d,w", tempreg, treg);
	  macro_build (NULL, &icnt, NULL, "drorv", "d,t,s", dreg, sreg,
		       tempreg);
d7023 4
a7026 4
      macro_build (NULL, &icnt, NULL, "dsubu", "d,v,t", AT, 0, treg);
      macro_build (NULL, &icnt, NULL, "dsrlv", "d,t,s", AT, sreg, AT);
      macro_build (NULL, &icnt, NULL, "dsllv", "d,t,s", dreg, sreg, treg);
      macro_build (NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d7042 2
a7043 3
	  macro_build (NULL, &icnt, NULL, "negu", "d,w", tempreg, treg);
	  macro_build (NULL, &icnt, NULL, "rorv", "d,t,s", dreg, sreg,
		       tempreg);
d7048 4
a7051 4
      macro_build (NULL, &icnt, NULL, "subu", "d,v,t", AT, 0, treg);
      macro_build (NULL, &icnt, NULL, "srlv", "d,t,s", AT, sreg, AT);
      macro_build (NULL, &icnt, NULL, "sllv", "d,t,s", dreg, sreg, treg);
      macro_build (NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d7066 1
a7066 2
	      macro_build (NULL, &icnt, NULL, "dror32", "d,w,<",
			   dreg, sreg, rot - 32);
d7068 1
a7068 2
	      macro_build (NULL, &icnt, NULL, "dror", "d,w,<",
			   dreg, sreg, rot);
d7073 1
a7073 1
	    macro_build (NULL, &icnt, NULL, "dsrl", "d,w,<", dreg, sreg, 0);
d7079 3
a7081 4
	macro_build (NULL, &icnt, NULL, l, "d,w,<", AT, sreg, rot);
	macro_build (NULL, &icnt, NULL, r, "d,w,<", dreg, sreg,
		     (0x20 - rot) & 0x1f);
	macro_build (NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d7094 1
a7094 2
	    macro_build (NULL, &icnt, NULL, "ror", "d,w,<", dreg, sreg,
			 (32 - rot) & 0x1f);
d7099 1
a7099 1
	    macro_build (NULL, &icnt, NULL, "srl", "d,w,<", dreg, sreg, 0);
d7102 3
a7104 4
	macro_build (NULL, &icnt, NULL, "sll", "d,w,<", AT, sreg, rot);
	macro_build (NULL, &icnt, NULL, "srl", "d,w,<", dreg, sreg,
		     (0x20 - rot) & 0x1f);
	macro_build (NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d7111 1
a7111 1
	  macro_build (NULL, &icnt, NULL, "drorv", "d,t,s", dreg, sreg, treg);
d7114 4
a7117 4
      macro_build (NULL, &icnt, NULL, "dsubu", "d,v,t", AT, 0, treg);
      macro_build (NULL, &icnt, NULL, "dsllv", "d,t,s", AT, sreg, AT);
      macro_build (NULL, &icnt, NULL, "dsrlv", "d,t,s", dreg, sreg, treg);
      macro_build (NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d7123 1
a7123 1
	  macro_build (NULL, &icnt, NULL, "rorv", "d,t,s", dreg, sreg, treg);
d7126 4
a7129 4
      macro_build (NULL, &icnt, NULL, "subu", "d,v,t", AT, 0, treg);
      macro_build (NULL, &icnt, NULL, "sllv", "d,t,s", AT, sreg, AT);
      macro_build (NULL, &icnt, NULL, "srlv", "d,t,s", dreg, sreg, treg);
      macro_build (NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d7143 1
a7143 2
	      macro_build (NULL, &icnt, NULL, "dror32", "d,w,<",
			   dreg, sreg, rot - 32);
d7145 1
a7145 2
	      macro_build (NULL, &icnt, NULL, "dror", "d,w,<",
			   dreg, sreg, rot);
d7150 1
a7150 1
	    macro_build (NULL, &icnt, NULL, "dsrl", "d,w,<", dreg, sreg, 0);
d7156 3
a7158 4
	macro_build (NULL, &icnt, NULL, r, "d,w,<", AT, sreg, rot);
	macro_build (NULL, &icnt, NULL, l, "d,w,<", dreg, sreg,
		     (0x20 - rot) & 0x1f);
	macro_build (NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d7171 1
a7171 1
	    macro_build (NULL, &icnt, NULL, "ror", "d,w,<", dreg, sreg, rot);
d7176 1
a7176 1
	    macro_build (NULL, &icnt, NULL, "srl", "d,w,<", dreg, sreg, 0);
d7179 3
a7181 4
	macro_build (NULL, &icnt, NULL, "srl", "d,w,<", AT, sreg, rot);
	macro_build (NULL, &icnt, NULL, "sll", "d,w,<", dreg, sreg,
		     (0x20 - rot) & 0x1f);
	macro_build (NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d7194 2
a7195 3
      macro_build (NULL, &icnt, &offset_expr, "swc1", "T,o(b)",
		   target_big_endian ? treg + 1 : treg,
		   BFD_RELOC_LO16, breg);
d7197 2
a7198 3
      macro_build (NULL, &icnt, &offset_expr, "swc1", "T,o(b)",
		   target_big_endian ? treg : treg + 1,
		   BFD_RELOC_LO16, breg);
d7203 1
a7203 2
	macro_build (NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg, treg,
		     BFD_RELOC_LO16);
d7205 1
a7205 2
	macro_build (NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg, sreg,
		     BFD_RELOC_LO16);
d7208 2
a7209 3
	  macro_build (NULL, &icnt, NULL, "xor", "d,v,t", dreg, sreg, treg);
	  macro_build (NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg, dreg,
		       BFD_RELOC_LO16);
d7216 1
a7216 2
	  macro_build (NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg, sreg,
		       BFD_RELOC_LO16);
d7223 1
a7223 1
	  move_register (&icnt, dreg, 0);
d7230 1
a7230 2
	  macro_build (NULL, &icnt, &imm_expr, "xori", "t,r,i", dreg, sreg,
		       BFD_RELOC_LO16);
d7238 1
a7238 2
	  macro_build (NULL, &icnt, &imm_expr,
		       HAVE_32BIT_GPRS ? "addiu" : "daddiu",
d7244 2
a7245 2
	  load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
	  macro_build (NULL, &icnt, NULL, "xor", "d,v,t", dreg, sreg, AT);
d7248 1
a7248 2
      macro_build (NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg, dreg,
		   BFD_RELOC_LO16);
d7259 2
a7260 3
      macro_build (NULL, &icnt, NULL, s, "d,v,t", dreg, sreg, treg);
      macro_build (NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
		   BFD_RELOC_LO16);
d7269 2
a7270 3
	  macro_build (NULL, &icnt, &imm_expr,
		       mask == M_SGE_I ? "slti" : "sltiu",
		       "t,r,j", dreg, sreg, BFD_RELOC_LO16);
d7275 3
a7277 3
	  load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
	  macro_build (NULL, &icnt, NULL, mask == M_SGE_I ? "slt" : "sltu",
		       "d,v,t", dreg, sreg, AT);
d7280 1
a7280 2
      macro_build (NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
		   BFD_RELOC_LO16);
d7291 1
a7291 1
      macro_build (NULL, &icnt, NULL, s, "d,v,t", dreg, treg, sreg);
d7300 2
a7301 2
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, &icnt, NULL, s, "d,v,t", dreg, AT, sreg);
d7310 2
a7311 3
      macro_build (NULL, &icnt, NULL, s, "d,v,t", dreg, treg, sreg);
      macro_build (NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
		   BFD_RELOC_LO16);
d7320 3
a7322 4
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, &icnt, NULL, s, "d,v,t", dreg, AT, sreg);
      macro_build (NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
		   BFD_RELOC_LO16);
d7330 1
a7330 2
	  macro_build (NULL, &icnt, &imm_expr, "slti", "t,r,j", dreg, sreg,
		       BFD_RELOC_LO16);
d7333 2
a7334 2
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, &icnt, NULL, "slt", "d,v,t", dreg, sreg, AT);
d7342 1
a7342 1
	  macro_build (NULL, &icnt, &imm_expr, "sltiu", "t,r,j", dreg, sreg,
d7346 2
a7347 2
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, &icnt, NULL, "sltu", "d,v,t", dreg, sreg, AT);
d7352 1
a7352 1
	macro_build (NULL, &icnt, NULL, "sltu","d,v,t", dreg, 0, treg);
d7354 1
a7354 1
	macro_build (NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0, sreg);
d7357 2
a7358 2
	  macro_build (NULL, &icnt, NULL, "xor", "d,v,t", dreg, sreg, treg);
	  macro_build (NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0, dreg);
d7365 1
a7365 1
	  macro_build (NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0, sreg);
d7372 2
a7373 3
	  macro_build (NULL, &icnt, &expr1,
		       HAVE_32BIT_GPRS ? "addiu" : "daddiu",
		       "t,r,j", dreg, 0, BFD_RELOC_LO16);
d7380 1
a7380 2
	  macro_build (NULL, &icnt, &imm_expr, "xori", "t,r,i", dreg, sreg,
		       BFD_RELOC_LO16);
d7388 1
a7388 2
	  macro_build (NULL, &icnt, &imm_expr,
		       HAVE_32BIT_GPRS ? "addiu" : "daddiu",
d7394 2
a7395 2
	  load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
	  macro_build (NULL, &icnt, NULL, "xor", "d,v,t", dreg, sreg, AT);
d7398 1
a7398 1
      macro_build (NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0, dreg);
d7411 2
a7412 2
	  macro_build (NULL, &icnt, &imm_expr, dbl ? "daddi" : "addi",
		       "t,r,j", dreg, sreg, BFD_RELOC_LO16);
d7415 2
a7416 3
      load_register (&icnt, AT, &imm_expr, dbl);
      macro_build (NULL, &icnt, NULL, dbl ? "dsub" : "sub", "d,v,t",
		   dreg, sreg, AT);
d7427 2
a7428 2
	  macro_build (NULL, &icnt, &imm_expr, dbl ? "daddiu" : "addiu",
		       "t,r,j", dreg, sreg, BFD_RELOC_LO16);
d7431 2
a7432 3
      load_register (&icnt, AT, &imm_expr, dbl);
      macro_build (NULL, &icnt, NULL, dbl ? "dsubu" : "subu", "d,v,t",
		   dreg, sreg, AT);
d7453 2
a7454 2
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
      macro_build (NULL, &icnt, NULL, s, "s,t", sreg, AT);
d7470 3
a7472 3
      macro_build (NULL, &icnt, NULL, "cfc1", "t,G", treg, RA);
      macro_build (NULL, &icnt, NULL, "cfc1", "t,G", treg, RA);
      macro_build (NULL, &icnt, NULL, "nop", "");
d7474 1
a7474 2
      macro_build (NULL, &icnt, &expr1, "ori", "t,r,i", AT, treg,
		   BFD_RELOC_LO16);
d7476 7
a7482 9
      macro_build (NULL, &icnt, &expr1, "xori", "t,r,i", AT, AT,
		   BFD_RELOC_LO16);
      macro_build (NULL, &icnt, NULL, "ctc1", "t,G", AT, RA);
      macro_build (NULL, &icnt, NULL, "nop", "");
      macro_build (NULL, &icnt, NULL,
		   mask == M_TRUNCWD ? "cvt.w.d" : "cvt.w.s",
		   "D,S", dreg, sreg);
      macro_build (NULL, &icnt, NULL, "ctc1", "t,G", treg, RA);
      macro_build (NULL, &icnt, NULL, "nop", "");
d7496 1
a7496 2
      macro_build (NULL, &icnt, &offset_expr, s, "t,o(b)", AT,
		   BFD_RELOC_LO16, breg);
d7501 3
a7503 4
      macro_build (NULL, &icnt, &offset_expr, "lbu", "t,o(b)", treg,
		   BFD_RELOC_LO16, breg);
      macro_build (NULL, &icnt, NULL, "sll", "d,w,<", AT, AT, 8);
      macro_build (NULL, &icnt, NULL, "or", "d,v,t", treg, treg, AT);
d7524 1
a7524 2
      macro_build (NULL, &icnt, &offset_expr, s, "t,o(b)", tempreg,
		   BFD_RELOC_LO16, breg);
d7529 1
a7529 2
      macro_build (NULL, &icnt, &offset_expr, s2, "t,o(b)", tempreg,
		   BFD_RELOC_LO16, breg);
d7536 2
a7537 2
	macro_build (NULL, &icnt, NULL, "nop", "");
      move_register (&icnt, treg, tempreg);
d7551 1
a7551 1
      load_address (&icnt, AT, &offset_expr, &used_at);
d7553 1
a7553 2
	macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
		     AT, AT, breg);
d7558 1
a7558 2
      macro_build (NULL, &icnt, &expr1, s, "t,o(b)", treg,
		   BFD_RELOC_LO16, AT);
d7563 1
a7563 2
      macro_build (NULL, &icnt, &expr1, s2, "t,o(b)", treg,
		   BFD_RELOC_LO16, AT);
d7569 1
a7569 1
      load_address (&icnt, AT, &offset_expr, &used_at);
d7571 1
a7571 2
	macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
		     AT, AT, breg);
d7574 1
a7574 2
      macro_build (NULL, &icnt, &expr1,
		   mask == M_ULH_A ? "lb" : "lbu", "t,o(b)",
d7580 3
a7582 4
      macro_build (NULL, &icnt, &expr1, "lbu", "t,o(b)",
		   AT, BFD_RELOC_LO16, AT);
      macro_build (NULL, &icnt, NULL, "sll", "d,w,<", treg, treg, 8);
      macro_build (NULL, &icnt, NULL, "or", "d,v,t", treg, treg, AT);
d7590 2
a7591 3
      macro_build (NULL, &icnt, &offset_expr, "sb", "t,o(b)", treg,
		   BFD_RELOC_LO16, breg);
      macro_build (NULL, &icnt, NULL, "srl", "d,w,<", AT, treg, 8);
d7596 1
a7596 2
      macro_build (NULL, &icnt, &offset_expr, "sb", "t,o(b)", AT,
		   BFD_RELOC_LO16, breg);
d7613 1
a7613 2
      macro_build (NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
		   BFD_RELOC_LO16, breg);
d7618 1
a7618 2
      macro_build (NULL, &icnt, &offset_expr, s2, "t,o(b)", treg,
		   BFD_RELOC_LO16, breg);
d7632 1
a7632 1
      load_address (&icnt, AT, &offset_expr, &used_at);
d7634 1
a7634 2
	macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
		     AT, AT, breg);
d7639 1
a7639 2
      macro_build (NULL, &icnt, &expr1, s, "t,o(b)", treg,
		   BFD_RELOC_LO16, AT);
d7644 1
a7644 2
      macro_build (NULL, &icnt, &expr1, s2, "t,o(b)", treg,
		   BFD_RELOC_LO16, AT);
d7649 1
a7649 1
      load_address (&icnt, AT, &offset_expr, &used_at);
d7651 1
a7651 2
	macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
		     AT, AT, breg);
d7654 2
a7655 3
      macro_build (NULL, &icnt, &expr1, "sb", "t,o(b)", treg,
		   BFD_RELOC_LO16, AT);
      macro_build (NULL, &icnt, NULL, "srl", "d,w,<", treg, treg, 8);
d7660 1
a7660 2
      macro_build (NULL, &icnt, &expr1, "sb", "t,o(b)", treg,
		   BFD_RELOC_LO16, AT);
d7665 3
a7667 4
      macro_build (NULL, &icnt, &expr1, "lbu", "t,o(b)", AT,
		   BFD_RELOC_LO16, AT);
      macro_build (NULL, &icnt, NULL, "sll", "d,w,<", treg, treg, 8);
      macro_build (NULL, &icnt, NULL, "or", "d,v,t", treg, treg, AT);
a7686 1
  int icnt;
a7696 2
  icnt = 0;

d7722 1
a7722 2
      macro_build (NULL, &icnt, NULL, dbl ? "ddiv" : "div", "0,x,y",
		   xreg, yreg);
d7724 2
a7725 2
      macro_build (NULL, &icnt, &expr1, "bnez", "x,p", yreg);
      macro_build (NULL, &icnt, NULL, "break", "6", 7);
d7732 1
a7732 1
      macro_build (NULL, &icnt, NULL, s, "x", zreg);
d7754 1
a7754 1
      macro_build (NULL, &icnt, NULL, s, "0,x,y", xreg, yreg);
d7756 2
a7757 2
      macro_build (NULL, &icnt, &expr1, "bnez", "x,p", yreg);
      macro_build (NULL, &icnt, NULL, "break", "6", 7);
d7759 1
a7759 1
      macro_build (NULL, &icnt, NULL, s2, "x", zreg);
d7765 2
a7766 3
      macro_build (NULL, &icnt, NULL, dbl ? "dmultu" : "multu", "x,y",
		   xreg, yreg);
      macro_build (NULL, &icnt, NULL, "mflo", "x", zreg);
d7777 1
a7777 2
      macro_build (NULL, &icnt, &imm_expr, dbl ? "daddiu" : "addiu", "y,x,4",
		   yreg, xreg);
d7784 1
a7784 1
      macro_build (NULL, &icnt, &imm_expr, "addiu", "x,k", xreg);
d7791 1
a7791 1
      macro_build (NULL, &icnt, &imm_expr, "daddiu", "y,j", yreg);
d7840 2
a7841 2
      macro_build (NULL, &icnt, NULL, s, "x,y", xreg, yreg);
      macro_build (NULL, &icnt, &offset_expr, s2, "p");
d7900 2
a7901 2
      macro_build (NULL, &icnt, &imm_expr, s, s3, xreg);
      macro_build (NULL, &icnt, &offset_expr, s2, "p");
d7906 1
a7906 1
      macro_build (NULL, &icnt, &expr1, "slti", "x,8", yreg);
d7908 1
a7908 1
	move_register (&icnt, xreg, yreg);
d7910 2
a7911 2
      macro_build (NULL, &icnt, &expr1, "bteqz", "p");
      macro_build (NULL, &icnt, NULL, "neg", "x,w", xreg, xreg);
a12027 1
  int icnt = 0;
d12050 2
a12051 2
  macro_build_lui (NULL, &icnt, &ex, mips_gp_register);
  macro_build (NULL, &icnt, &ex, "addiu", "t,r,j", mips_gp_register,
d12053 1
a12053 2

  macro_build (NULL, &icnt, NULL, "addu", "d,v,t", mips_gp_register,
a12080 1
  int icnt = 0;
d12130 1
a12130 1
      macro_build (NULL, &icnt, &ex_off, "sd", "t,o(b)", mips_gp_register,
d12134 1
a12134 1
    macro_build (NULL, &icnt, NULL, "daddu", "d,v,t", mips_cpreturn_register,
d12141 1
a12141 2
  macro_build (NULL, &icnt, &ex_sym, "lui", "t,u", mips_gp_register,
	       BFD_RELOC_GPREL16);
d12148 1
a12148 1
  macro_build (NULL, &icnt, &ex_sym, "addiu", "t,r,j", mips_gp_register,
d12155 1
a12155 1
  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t", mips_gp_register,
a12184 1
  int icnt = 0;
d12203 2
a12204 2
  macro_build_ldst_constoffset (NULL, &icnt, &ex, ADDRESS_STORE_INSN,
				mips_gp_register, SP, HAVE_64BIT_ADDRESSES);
a12220 1
  int icnt = 0;
d12238 1
a12238 2
      macro_build (NULL, &icnt, &ex, "ld", "t,o(b)", mips_gp_register,
		   BFD_RELOC_LO16, SP);
d12241 1
a12241 1
    macro_build (NULL, &icnt, NULL, "daddu", "d,v,t", mips_gp_register,
a12354 1
  int icnt = 0;
d12367 1
a12367 2
  macro_build (NULL, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
	       reg, reg, mips_gp_register);
@


1.248
log
@	* config/tc-mips.h (tc_frag_data_type, TC_FRAG_TYPE): Remove.
	* config/tc-mips.c (RELAX_ENCODE): Take three arguments: the size of
	the first sequence, the size of the second sequence, and a flag
	that says whether we should warn.
	(RELAX_OLD, RELAX_NEW, RELAX_RELOC[123]): Delete.
	(RELAX_FIRST, RELAX_SECOND): New.
	(mips_relax): New variable.
	(relax_close_frag, relax_start, relax_switch, relax_end): New fns.
	(append_insn): Remove "place" argument.  Use mips_relax.sequence
	rather than "place" to check whether we're expanding the second
	alternative of a relaxable macro.  Remove redundant check for
	branch relaxation.  If generating a normal insn, and there
	is not enough room in the current frag, call relax_close_frag()
	to close it.  Update mips_relax.sizes[].  Emit fixups for the
	second version of a relaxable macro.  Record the first relaxable
	fixup in mips_relax.  Remove tc_gen_reloc workaround.
	(macro_build): Remove all uses of "place".  Use mips_relax.sequence
	in the same way as in append_insn.
	(mips16_macro_build): Remove "place" argument.
	(macro_build_lui): As for macro_build.  Don't drop the add_symbol
	when generating the second version of a relaxable macro.
	(load_got_offset, add_got_offset): New functions.
	(load_address, macro): Use new relaxation machinery.  Remove
	tc_gen_reloc workarounds.
	(md_estimate_size_before_relax): Set RELAX_USE_SECOND if the second
	version of a relaxable macro is needed.  Return -RELAX_SECOND if the
	first version is needed.
	(tc_gen_reloc): Remove relaxation handling.
	(md_convert_frag): Go through the fixups for a relaxable macro and
	mark those that belong to the unneeded alternative as done.  If the
	second alternative is needed, adjust the fixup addresses to account
	for the deleted first alternative.

testsuite/
	* gas/mips/elf-rel19.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d632 21
a652 8
   The frag's "subtype" is RELAX_ENCODE (FIRST, SECOND, WARN), where
   FIRST and SECOND are the lengths of the two sequences in bytes
   and WARN is true if ".set nomacro" was in effect when the macro
   was expanded.  These fields can be extracted using RELAX_FIRST(),
   RELAX_SECOND() and RELAX_WARN().

   In addition, the RELAX_USE_SECOND flag is set if it has been decided
   that we should use the second sequence instead of the first.
d666 1
a666 2
#define RELAX_ENCODE(FIRST, SECOND, WARN) \
  (((FIRST) << 8) | ((SECOND) << 1) | ((WARN) != 0))
d668 6
a673 4
#define RELAX_FIRST(X) (((X) >> 8) & 0x7f)
#define RELAX_SECOND(X) (((X) >> 1) & 0x7f)
#define RELAX_WARN(X) ((X) & 1)
#define RELAX_USE_SECOND 0x8000
d827 15
d855 2
d1374 1
d1379 1
d1554 1
d1556 1
a1556 3
	    RELAX_ENCODE (mips_relax.sizes[0],
			  mips_relax.sizes[1],
			  mips_opts.warn_about_macros),
d2060 5
d2891 65
a2970 22
  if (mips_relax.sequence != 2)
    {
      if (*counter == 1)
	{
	  /* If the macro is about to expand into a second instruction,
	     and it is in a delay slot, print a warning.  */
	  if (mips_opts.noreorder
	      && (prev_prev_insn.insn_mo->pinfo
		  & (INSN_UNCOND_BRANCH_DELAY
		     | INSN_COND_BRANCH_DELAY
		     | INSN_COND_BRANCH_LIKELY)) != 0)
	    as_warn (_("Macro instruction expanded into multiple instructions in a branch delay slot"));

	  /* If the macro is about to expand into a second instruction,
	     print a warning if needed. We need to pass ip as a parameter
	     to generate a better warning message here...  */
	  else if (mips_opts.warn_about_macros)
	    as_warn (_("Macro instruction expanded into multiple instructions"));
	}
      ++*counter;
    }

d3336 1
a3336 1
macro_build_lui (char *place ATTRIBUTE_UNUSED, int *counter,
a3348 9
  if (mips_relax.sequence != 2)
    {
      /* If the macro is about to expand into a second instruction,
	 print a warning if needed. We need to pass ip as a parameter
	 to generate a better warning message here...  */
      if (mips_opts.warn_about_macros && *counter == 1)
	as_warn (_("Macro instruction expanded into multiple instructions"));
      ++*counter;
    }
d12304 1
d12311 1
d12379 1
d12415 1
d12461 1
d12464 1
d12490 1
d12504 1
d12627 1
d12631 1
a13238 5
      /* FIXME: This really needs as_warn_where.  */
      if (RELAX_WARN (fragp->fr_subtype))
	as_warn (_("AT used after \".set noat\" or macro used after "
		   "\".set nomacro\""));

d13758 9
@


1.247
log
@	* config/tc-mips.c (append_insn): Don't do r3900 interlock
	optimization for -mtune=r3900, as this will break on other CPUs.
@
text
@d619 41
a659 75
/* Since the MIPS does not have multiple forms of PC relative
   instructions, we do not have to do relaxing as is done on other
   platforms.  However, we do have to handle GP relative addressing
   correctly, which turns out to be a similar problem.

   Every macro that refers to a symbol can occur in (at least) two
   forms, one with GP relative addressing and one without.  For
   example, loading a global variable into a register generally uses
   a macro instruction like this:
     lw $4,i
   If i can be addressed off the GP register (this is true if it is in
   the .sbss or .sdata section, or if it is known to be smaller than
   the -G argument) this will generate the following instruction:
     lw $4,i($gp)
   This instruction will use a GPREL reloc.  If i can not be addressed
   off the GP register, the following instruction sequence will be used:
     lui $at,i
     lw $4,i($at)
   In this case the first instruction will have a HI16 reloc, and the
   second reloc will have a LO16 reloc.  Both relocs will be against
   the symbol i.

   The issue here is that we may not know whether i is GP addressable
   until after we see the instruction that uses it.  Therefore, we
   want to be able to choose the final instruction sequence only at
   the end of the assembly.  This is similar to the way other
   platforms choose the size of a PC relative instruction only at the
   end of assembly.

   When generating position independent code we do not use GP
   addressing in quite the same way, but the issue still arises as
   external symbols and local symbols must be handled differently.

   We handle these issues by actually generating both possible
   instruction sequences.  The longer one is put in a frag_var with
   type rs_machine_dependent.  We encode what to do with the frag in
   the subtype field.  We encode (1) the number of existing bytes to
   replace, (2) the number of new bytes to use, (3) the offset from
   the start of the existing bytes to the first reloc we must generate
   (that is, the offset is applied from the start of the existing
   bytes after they are replaced by the new bytes, if any), (4) the
   offset from the start of the existing bytes to the second reloc,
   (5) whether a third reloc is needed (the third reloc is always four
   bytes after the second reloc), and (6) whether to warn if this
   variant is used (this is sometimes needed if .set nomacro or .set
   noat is in effect).  All these numbers are reasonably small.

   Generating two instruction sequences must be handled carefully to
   ensure that delay slots are handled correctly.  Fortunately, there
   are a limited number of cases.  When the second instruction
   sequence is generated, append_insn is directed to maintain the
   existing delay slot information, so it continues to apply to any
   code after the second instruction sequence.  This means that the
   second instruction sequence must not impose any requirements not
   required by the first instruction sequence.

   These variant frags are then handled in functions called by the
   machine independent code.  md_estimate_size_before_relax returns
   the final size of the frag.  md_convert_frag sets up the final form
   of the frag.  tc_gen_reloc adjust the first reloc and adds a second
   one if needed.  */
#define RELAX_ENCODE(old, new, reloc1, reloc2, reloc3, warn) \
  ((relax_substateT) \
   (((old) << 23) \
    | ((new) << 16) \
    | (((reloc1) + 64) << 9) \
    | (((reloc2) + 64) << 2) \
    | ((reloc3) ? (1 << 1) : 0) \
    | ((warn) ? 1 : 0)))
#define RELAX_OLD(i) (((i) >> 23) & 0x7f)
#define RELAX_NEW(i) (((i) >> 16) & 0x7f)
#define RELAX_RELOC1(i) ((valueT) (((i) >> 9) & 0x7f) - 64)
#define RELAX_RELOC2(i) ((valueT) (((i) >> 2) & 0x7f) - 64)
#define RELAX_RELOC3(i) (((i) >> 1) & 1)
#define RELAX_WARN(i) ((i) & 1)
d792 21
d821 1
a821 2
  (char *place, struct mips_cl_insn *ip, expressionS *p,
   bfd_reloc_code_real_type *r);
d824 1
a824 1
  (char *, int *, expressionS *, const char *, const char *, va_list);
d1351 1
a1351 1
	append_insn (NULL, &insn, &imm_expr, imm_reloc);
d1353 1
a1353 1
	append_insn (NULL, &insn, &offset_expr, offset_reloc);
d1355 1
a1355 1
	append_insn (NULL, &insn, NULL, unused_reloc);
d1515 50
a1564 4
/* Output an instruction.  PLACE is where to put the instruction; if
   it is NULL, this uses frag_more to get room.  IP is the instruction
   information.  ADDRESS_EXPR is an operand of the instruction to be
   used with RELOC_TYPE.  */
d1567 1
a1567 1
append_insn (char *place, struct mips_cl_insn *ip, expressionS *address_expr,
d1584 2
a1585 1
  if (place == NULL && (! mips_opts.noreorder || prev_nop_frag != NULL))
d1961 1
a1961 2
  if (place == NULL
      && address_expr
a2001 2
  else if (place != NULL)
    f = place;
d2018 10
d2101 1
d2103 2
a2104 6
	need_reloc:
	  /* Don't generate a reloc if we are writing into a variant frag.  */
	  if (place == NULL)
	    {
	      reloc_howto_type *howto;
	      int i;
d2106 5
a2110 5
	      /* In a compound relocation, it is the final (outermost)
		 operator that determines the relocated field.  */
	      for (i = 1; i < 3; i++)
		if (reloc_type[i] == BFD_RELOC_UNUSED)
		  break;
d2112 68
a2179 64
	      howto = bfd_reloc_type_lookup (stdoutput, reloc_type[i - 1]);
	      fixp[0] = fix_new_exp (frag_now, f - frag_now->fr_literal,
				     bfd_get_reloc_size(howto),
				     address_expr,
				     reloc_type[0] == BFD_RELOC_16_PCREL_S2,
				     reloc_type[0]);

	      /* These relocations can have an addend that won't fit in
	         4 octets for 64bit assembly.  */
	      if (HAVE_64BIT_GPRS
		  && ! howto->partial_inplace
		  && (reloc_type[0] == BFD_RELOC_16
		      || reloc_type[0] == BFD_RELOC_32
		      || reloc_type[0] == BFD_RELOC_MIPS_JMP
		      || reloc_type[0] == BFD_RELOC_HI16_S
		      || reloc_type[0] == BFD_RELOC_LO16
		      || reloc_type[0] == BFD_RELOC_GPREL16
		      || reloc_type[0] == BFD_RELOC_MIPS_LITERAL
		      || reloc_type[0] == BFD_RELOC_GPREL32
		      || reloc_type[0] == BFD_RELOC_64
		      || reloc_type[0] == BFD_RELOC_CTOR
		      || reloc_type[0] == BFD_RELOC_MIPS_SUB
		      || reloc_type[0] == BFD_RELOC_MIPS_HIGHEST
		      || reloc_type[0] == BFD_RELOC_MIPS_HIGHER
		      || reloc_type[0] == BFD_RELOC_MIPS_SCN_DISP
		      || reloc_type[0] == BFD_RELOC_MIPS_REL16
		      || reloc_type[0] == BFD_RELOC_MIPS_RELGOT))
		fixp[0]->fx_no_overflow = 1;

	      if (reloc_needs_lo_p (*reloc_type))
		{
		  struct mips_hi_fixup *hi_fixup;

		  /* Reuse the last entry if it already has a matching %lo.  */
		  hi_fixup = mips_hi_fixup_list;
		  if (hi_fixup == 0
		      || !fixup_has_matching_lo_p (hi_fixup->fixp))
		    {
		      hi_fixup = ((struct mips_hi_fixup *)
				  xmalloc (sizeof (struct mips_hi_fixup)));
		      hi_fixup->next = mips_hi_fixup_list;
		      mips_hi_fixup_list = hi_fixup;
		    }
		  hi_fixup->fixp = fixp[0];
		  hi_fixup->seg = now_seg;
		}

	      /* Add fixups for the second and third relocations, if given.
		 Note that the ABI allows the second relocation to be
		 against RSS_UNDEF, RSS_GP, RSS_GP0 or RSS_LOC.  At the
		 moment we only use RSS_UNDEF, but we could add support
		 for the others if it ever becomes necessary.  */
	      for (i = 1; i < 3; i++)
		if (reloc_type[i] != BFD_RELOC_UNUSED)
		  {
		    address_expr->X_op = O_absent;
		    address_expr->X_add_symbol = 0;
		    address_expr->X_add_number = 0;

		    fixp[i] = fix_new_exp (frag_now, fixp[0]->fx_where,
					   fixp[0]->fx_size, address_expr,
					   FALSE, reloc_type[i]);
		  }
	    }
d2267 1
a2267 1
  if (place == NULL && ! mips_opts.noreorder)
d2691 1
a2691 1
  else if (place == NULL)
a2706 9

  /* We must ensure that the frag to which an instruction that was
     moved from a non-variant frag doesn't become a variant frag,
     otherwise tc_gen_reloc may get confused.  */
  if (force_new_frag)
    {
      frag_wane (frag_now);
      frag_new (0);
    }
d2860 2
a2861 2
macro_build (char *place, int *counter, expressionS *ep, const char *name,
	     const char *fmt, ...)
d2869 12
a2880 7
  /*
   * If the macro is about to expand into a second instruction,
   * print a warning if needed. We need to pass ip as a parameter
   * to generate a better warning message here...
   */
  if (mips_opts.warn_about_macros && place == NULL && *counter == 1)
    as_warn (_("Macro instruction expanded into multiple instructions"));
d2882 8
a2889 14
  /*
   * If the macro is about to expand into a second instruction,
   * and it is in a delay slot, print a warning.
   */
  if (place == NULL
      && *counter == 1
      && mips_opts.noreorder
      && (prev_prev_insn.insn_mo->pinfo
	  & (INSN_UNCOND_BRANCH_DELAY | INSN_COND_BRANCH_DELAY
	     | INSN_COND_BRANCH_LIKELY)) != 0)
    as_warn (_("Macro instruction expanded into multiple instructions in a branch delay slot"));

  if (place == NULL)
    ++*counter;		/* bump instruction counter */
d2893 1
a2893 1
      mips16_macro_build (place, counter, ep, name, fmt, args);
d3107 1
a3107 1
  append_insn (place, &insn, ep, r);
d3111 1
a3111 1
mips16_macro_build (char *place, int *counter ATTRIBUTE_UNUSED,
d3229 1
a3229 1
  append_insn (place, &insn, ep, r);
d3256 2
a3257 1
macro_build_lui (char *place, int *counter, expressionS *ep, int regnum)
d3268 2
a3269 3
  if (place == NULL)
    high_expr = *ep;
  else
d3271 6
a3276 2
      high_expr.X_op = O_constant;
      high_expr.X_add_number = ep->X_add_number;
a3295 11
  /*
   * If the macro is about to expand into a second instruction,
   * print a warning if needed. We need to pass ip as a parameter
   * to generate a better warning message here...
   */
  if (mips_opts.warn_about_macros && place == NULL && *counter == 1)
    as_warn (_("Macro instruction expanded into multiple instructions"));

  if (place == NULL)
    ++*counter;		/* bump instruction counter */

d3305 1
a3305 1
      append_insn (place, &insn, NULL, r);
d3308 1
a3308 1
    append_insn (place, &insn, &high_expr, r);
d3819 1
a3819 1
	      frag_grow (20);
d3822 1
a3822 4
	      p = frag_var (rs_machine_dependent, 8, 0,
			    RELAX_ENCODE (4, 8, 0, 4, 0,
					  mips_opts.warn_about_macros),
			    ep->X_add_symbol, 0, NULL);
a3824 2
	  if (p != NULL)
	    p += 4;
d3827 2
a3848 2
	  frag_grow (12);

d3851 1
a3851 2
	      frag_now->tc_frag_data.tc_fr_offset =
		ex.X_add_number = ep->X_add_number;
d3853 1
a3860 4
	      p = frag_var (rs_machine_dependent, 8, 0,
			    RELAX_ENCODE (8, 4, 0, 0, 0,
					  mips_opts.warn_about_macros),
			    ep->X_add_symbol, 0, NULL);
d3862 1
a3863 1

d3866 2
a3867 8

	  if (! p)
	    {
	      /* To avoid confusion in tc_gen_reloc, we must ensure
		 that this does not become a variant frag.  */
	      frag_wane (frag_now);
	      frag_new (0);
	    }
a3872 1
	  frag_grow (20);
d3877 2
a3878 3
	  p = frag_var (rs_machine_dependent, 4, 0,
			RELAX_ENCODE (0, 4, -8, 0, 0, mips_opts.warn_about_macros),
			ep->X_add_symbol, 0, NULL);
d3881 1
a3895 1
      int off;
d3915 1
a3915 4
	  frag_grow (24);

	  frag_now->tc_frag_data.tc_fr_offset =
	    ex.X_add_number = ep->X_add_number;
d3917 1
d3934 1
a3934 4
	  p = frag_var (rs_machine_dependent, 8, 0,
			RELAX_ENCODE (ex.X_add_number ? 16 : 12, 8, 0, 4, 0,
				      mips_opts.warn_about_macros),
			ep->X_add_symbol, 0, NULL);
d3939 1
d3945 1
a3945 5
	  if (reg_needs_delay (mips_gp_register))
	    off = 4;
	  else
	    off = 0;
	  frag_grow (32);
d3952 2
a3953 5
	  p = frag_var (rs_machine_dependent, 12 + off, 0,
			RELAX_ENCODE (12, 12 + off, off, 8 + off, 0,
				      mips_opts.warn_about_macros),
			ep->X_add_symbol, 0, NULL);
	  if (off > 0)
a3959 1
		p += 4;
a3962 1
	  p += 4;
a3963 1
	  p += 4;
d3966 1
d3999 49
a4100 24
  /* Unmatched fixups should not be put in the same frag as a relaxable
     macro.  For example, suppose we have:

	lui $4,%hi(l1)		# 1
	la $5,l2		# 2
	addiu $4,$4,%lo(l1)	# 3

     If instructions 1 and 2 were put in the same frag, md_frob_file would
     move the fixup for #1 after the fixups for the "unrelaxed" version of
     #2.  This would confuse tc_gen_reloc, which expects the relocations
     for #2 to be the last for that frag.

     Also, if tc_gen_reloc sees certain relocations in a variant frag,
     it assumes that they belong to a relaxable macro.  We mustn't put
     other uses of such relocations into a variant frag.

     To avoid both problems, finish the current frag it contains a
     %reloc() operator.  The macro then goes into a new frag.  */
  if (prev_reloc_op_frag == frag_now)
    {
      frag_wane (frag_now);
      frag_new (0);
    }

d4979 1
a4979 1
		  frag_grow (20);
d4983 1
a4983 4
		  p = frag_var (rs_machine_dependent, 8, 0,
				RELAX_ENCODE (4, 8, 0, 4, 0,
					      mips_opts.warn_about_macros),
				offset_expr.X_add_symbol, 0, NULL);
a4985 2
	      if (p != NULL)
		p += 4;
d4988 2
d5026 1
a5026 9
	  expr1.X_add_number = offset_expr.X_add_number;
	  offset_expr.X_add_number = 0;
	  frag_grow (32);
	  if (expr1.X_add_number == 0 && breg == 0
	      && (call || tempreg == PIC_CALL_REG))
	    lw_reloc_type = (int) BFD_RELOC_MIPS_CALL16;
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       tempreg, lw_reloc_type, mips_gp_register);
	  if (expr1.X_add_number == 0)
d5028 4
a5031 2
	      int off;
	      char *p;
d5033 4
a5036 3
	      if (breg == 0)
		off = 0;
	      else
a5041 1
		  off = 4;
d5043 6
a5048 12
	      p = frag_var (rs_machine_dependent, 8 - off, 0,
			    RELAX_ENCODE (0, 8 - off, -4 - off, 4 - off, 0,
					  (breg == 0
					   ? mips_opts.warn_about_macros
					   : 0)),
			    offset_expr.X_add_symbol, 0, NULL);
	      if (breg == 0)
		{
		  macro_build (p, &icnt, NULL, "nop", "");
		  p += 4;
		}
	      macro_build (p, &icnt, &expr1, ADDRESS_ADDI_INSN,
d5050 1
d5055 2
a5056 2
	  else if (expr1.X_add_number >= -0x8000
		   && expr1.X_add_number < 0x8000)
d5058 1
d5060 1
a5060 5
	      macro_build (NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			   "t,r,j", tempreg, tempreg, BFD_RELOC_LO16);
	      frag_var (rs_machine_dependent, 0, 0,
			RELAX_ENCODE (0, 0, -12, -4, 0, 0),
			offset_expr.X_add_symbol, 0, NULL);
d5066 4
d5096 1
a5096 2
	      macro_build (NULL, &icnt, &expr1, ADDRESS_ADDI_INSN, "t,r,j",
			   AT, AT, BFD_RELOC_LO16);
a5098 3
	      frag_var (rs_machine_dependent, 0, 0,
			RELAX_ENCODE (0, 0, -16 + off1, -8, 0, 0),
			offset_expr.X_add_symbol, 0, NULL);
a5104 1
	  int lw_reloc_type = (int) BFD_RELOC_MIPS_GOT_DISP;
a5129 4
	  frag_grow (28);
	  if (offset_expr.X_add_number == 0 && breg == 0
	      && (call || tempreg == PIC_CALL_REG))
	    lw_reloc_type = (int) BFD_RELOC_MIPS_CALL16;
d5132 1
a5132 2
	      frag_now->tc_frag_data.tc_fr_offset =
		expr1.X_add_number = offset_expr.X_add_number;
d5135 1
d5137 1
a5137 1
			   "t,o(b)", tempreg, lw_reloc_type,
a5144 3
		  p = frag_var (rs_machine_dependent, 4, 0,
				RELAX_ENCODE (8, 4, 0, 0, 0, 0),
				offset_expr.X_add_symbol, 0, NULL);
a5173 5
		  p = frag_var (rs_machine_dependent, 4 + adj, 0,
				RELAX_ENCODE (16 + adj, 4 + adj,
					      0, 0, 0, 0),
				offset_expr.X_add_symbol, 0, NULL);

d5179 1
d5192 1
d5194 1
a5194 1
	  else
d5196 5
d5202 1
a5202 1
			   "t,o(b)", tempreg, lw_reloc_type,
d5204 1
a5204 4
	      if (lw_reloc_type != BFD_RELOC_MIPS_GOT_DISP)
		p = frag_var (rs_machine_dependent, 0, 0,
			      RELAX_ENCODE (0, 0, -4, 0, 0, 0),
			      offset_expr.X_add_symbol, 0, NULL);
d5206 1
a5206 2

	  if (! p)
d5208 3
a5210 4
	      /* To avoid confusion in tc_gen_reloc, we must ensure
		 that this does not become a variant frag.  */
	      frag_wane (frag_now);
	      frag_new (0);
d5216 1
a5216 1
	  char *p;
d5264 1
a5264 1
	  frag_grow (52);
a5294 8

	      p = frag_var (rs_machine_dependent, 12 + gpdel, 0,
			    RELAX_ENCODE (12 + off, 12 + gpdel, gpdel,
					  8 + gpdel, 0,
					  (breg == 0
					   ? mips_opts.warn_about_macros
					   : 0)),
			    offset_expr.X_add_symbol, 0, NULL);
a5301 7

	      p = frag_var (rs_machine_dependent, 12 + gpdel, 0,
			    RELAX_ENCODE (20, 12 + gpdel, gpdel, 8 + gpdel, 0,
					  (breg == 0
					   ? mips_opts.warn_about_macros
					   : 0)),
			    offset_expr.X_add_symbol, 0, NULL);
a5340 8
	      p = frag_var (rs_machine_dependent, 16 + gpdel + adj, 0,
			    RELAX_ENCODE (24 + adj, 16 + gpdel + adj, gpdel,
					  8 + gpdel, 0,
					  (breg == 0
					   ? mips_opts.warn_about_macros
					   : 0)),
			    offset_expr.X_add_symbol, 0, NULL);

d5343 3
a5351 1
	      p += 4;
a5355 1
	  p += 4;
d5360 1
a5360 2
	      p += 4;
	      macro_build (p, &icnt, &expr1, ADDRESS_ADDI_INSN,
a5375 1
		  p += 4;
a5377 1
		  p += 4;
d5385 1
a5385 2
	      p += 4;
	      macro_build (p, &icnt, &expr1, ADDRESS_ADDI_INSN, "t,r,j",
a5386 1
	      p += 4;
a5388 1
	      p += 4;
d5390 1
d5430 1
a5430 1
	  frag_grow (40);
d5432 1
a5432 2
	  frag_now->tc_frag_data.tc_fr_offset =
	    expr1.X_add_number = offset_expr.X_add_number;
d5449 1
a5449 6
	    {
	      p = frag_var (rs_machine_dependent, 8, 0,
			    RELAX_ENCODE (12, 8, 0, 4, 0,
					  mips_opts.warn_about_macros),
			    offset_expr.X_add_symbol, 0, NULL);
	    }
a5454 4
	      p = frag_var (rs_machine_dependent, 8, 0,
			    RELAX_ENCODE (16, 8, 0, 4, 0,
					  mips_opts.warn_about_macros),
			    offset_expr.X_add_symbol, 0, NULL);
a5485 8
	      p = frag_var (rs_machine_dependent, 8 + adj, 0,
			    RELAX_ENCODE (24 + adj, 8 + adj,
					  0, 4, 0,
					  (breg == 0
					   ? mips_opts.warn_about_macros
					   : 0)),
			    offset_expr.X_add_symbol, 0, NULL);

d5491 1
d5504 1
d5597 1
a5597 1
	  char *p;
d5631 1
a5631 1
		  frag_grow (4);
d5635 5
a5639 3
		  frag_var (rs_machine_dependent, 0, 0,
			    RELAX_ENCODE (0, 0, -4, 0, 0, 0),
			    offset_expr.X_add_symbol, 0, NULL);
d5643 1
a5643 1
		  frag_grow (20);
d5651 1
a5651 3
		  p = frag_var (rs_machine_dependent, 8, 0,
				RELAX_ENCODE (12, 8, 0, 4, 0, 0),
				offset_expr.X_add_symbol, 0, NULL);
d5658 1
d5665 1
a5665 1
	      frag_grow (40);
d5672 1
a5672 3
		  p = frag_var (rs_machine_dependent, 4, 0,
				RELAX_ENCODE (0, 4, -8, 0, 0, 0),
				offset_expr.X_add_symbol, 0, NULL);
d5690 1
a5690 4
		  p = frag_var (rs_machine_dependent, 12 + gpdel, 0,
				RELAX_ENCODE (16, 12 + gpdel, gpdel,
					      8 + gpdel, 0, 0),
				offset_expr.X_add_symbol, 0, NULL);
a5695 6
		  macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
			       "t,o(b)", PIC_CALL_REG, BFD_RELOC_MIPS_GOT16,
			       mips_gp_register);
		  p += 4;
		  macro_build (p, &icnt, NULL, "nop", "");
		  p += 4;
d5697 4
d5704 1
d5988 1
a5988 1
	  char *p;
d6132 1
a6132 1
		  frag_grow (20);
d6135 1
a6135 6
		  p = frag_var (rs_machine_dependent, 8, 0,
				RELAX_ENCODE (4, 8, 0, 4, 0,
					      (mips_opts.warn_about_macros
					       || (used_at
						   && mips_opts.noat))),
				offset_expr.X_add_symbol, 0, NULL);
a6138 2
	      if (p != NULL)
		p += 4;
d6141 2
d6151 1
a6151 1
		  frag_grow (28);
d6156 1
a6156 3
		  p = frag_var (rs_machine_dependent, 12, 0,
				RELAX_ENCODE (8, 12, 0, 8, 0, 0),
				offset_expr.X_add_symbol, 0, NULL);
a6158 2
	      if (p != NULL)
		p += 4;
a6160 2
	      if (p != NULL)
		p += 4;
d6163 2
d6169 1
a6169 1
	  char *p;
a6213 1
	  frag_grow (20);
d6217 2
a6218 3
	  p = frag_var (rs_machine_dependent, 4, 0,
			RELAX_ENCODE (0, 4, -8, 0, 0, 0),
			offset_expr.X_add_symbol, 0, NULL);
d6221 1
d6231 1
a6231 1
	  char *p;
d6259 1
a6259 1
	  frag_grow (36);
d6266 1
a6266 3
	  p = frag_var (rs_machine_dependent, 12 + gpdel, 0,
			RELAX_ENCODE (12, 12 + gpdel, gpdel, 8 + gpdel, 0, 0),
			offset_expr.X_add_symbol, 0, NULL);
d6268 1
a6268 4
	    {
	      macro_build (p, &icnt, NULL, "nop", "");
	      p += 4;
	    }
a6270 1
	  p += 4;
a6271 1
	  p += 4;
d6274 2
d6284 1
a6284 1
	  char *p;
d6296 1
a6296 3
	  frag_grow (36);
	  frag_now->tc_frag_data.tc_fr_offset =
	    expr1.X_add_number = offset_expr.X_add_number;
d6301 1
d6314 1
a6315 4
	  p = frag_var (rs_machine_dependent, 12 + bregsz, 0,
			RELAX_ENCODE (16 + bregsz, 8 + bregsz,
				      0, 4 + bregsz, 0, 0),
			offset_expr.X_add_symbol, 0, NULL);
d6323 1
a6463 6

      /* To avoid confusion in tc_gen_reloc, we must ensure that this
	 does not become a variant frag.  */
      frag_wane (frag_now);
      frag_new (0);

a6526 6

	      /* To avoid confusion in tc_gen_reloc, we must ensure
		 that this does not become a variant frag.  */
	      frag_wane (frag_now);
	      frag_new (0);

a6552 5
      /* To avoid confusion in tc_gen_reloc, we must ensure that this
	 does not become a variant frag.  */
      frag_wane (frag_now);
      frag_new (0);

d6649 1
a6649 1
	  char *p;
d6675 1
a6677 1
		  frag_grow (28);
a6683 1
		  frag_grow (36);
d6707 1
a6707 4
	      p = frag_var (rs_machine_dependent, 12 + off, 0,
			    RELAX_ENCODE (8 + off, 12 + off, 0, 4 + off, 1,
					  used_at && mips_opts.noat),
			    offset_expr.X_add_symbol, 0, NULL);
a6730 2
	  if (p != NULL)
	    p += 4;
d6732 1
a6732 2
	    {
	      macro_build (p, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
a6733 3
	      if (p != NULL)
		p += 4;
	    }
a6737 2
	  if (p != NULL)
	    p += 4;
d6744 2
a6765 1
	  offset_expr.X_add_number = 0;
d6773 1
a6773 3
	  frag_grow (24 + off);
	  macro_build (NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN, "t,o(b)",
		       AT, BFD_RELOC_MIPS_GOT16, mips_gp_register);
a6777 4
	  /* Itbl support may require additional care here.  */
	  macro_build (NULL, &icnt, &expr1, s, fmt, coproc ? treg + 1 : treg,
		       BFD_RELOC_LO16, AT);
	  expr1.X_add_number += 4;
d6783 1
d6785 14
a6798 2
	  macro_build (NULL, &icnt, &expr1, s, fmt, coproc ? treg : treg + 1,
		       BFD_RELOC_LO16, AT);
a6799 4

	  (void) frag_var (rs_machine_dependent, 0, 0,
			   RELAX_ENCODE (0, 0, -16 - off, -8, 1, 0),
			   offset_expr.X_add_symbol, 0, NULL);
d6804 1
a6804 1
	  char *p;
d6835 1
a6835 1
	  frag_grow (56);
d6861 2
a6862 4
	  p = frag_var (rs_machine_dependent, 16 + gpdel + off, 0,
			RELAX_ENCODE (24 + off, 16 + gpdel + off, gpdel,
				      8 + gpdel + off, 1, 0),
			offset_expr.X_add_symbol, 0, NULL);
d6864 1
a6864 4
	    {
	      macro_build (p, &icnt, NULL, "nop", "");
	      p += 4;
	    }
a6866 1
	  p += 4;
a6867 1
	  p += 4;
d6869 2
a6870 5
	    {
	      macro_build (p, &icnt, NULL, ADDRESS_ADD_INSN, "d,v,t",
			   AT, breg, AT);
	      p += 4;
	    }
d6872 3
a6874 4
	  macro_build (p, &icnt, &expr1, s, fmt, coproc ? treg + 1 : treg,
		       BFD_RELOC_LO16, AT);
	  p += 4;
	  expr1.X_add_number += 4;
d6881 2
a6882 2
	  macro_build (p, &icnt, &expr1, s, fmt, coproc ? treg : treg + 1,
		       BFD_RELOC_LO16, AT);
d6884 1
d13157 1
a13157 7
      /* Record the offset to the first reloc in the fr_opcode field.
	 This lets md_convert_frag and tc_gen_reloc know that the code
	 must be expanded.  */
      fragp->fr_opcode = (fragp->fr_literal
			  + fragp->fr_fix
			  - RELAX_OLD (fragp->fr_subtype)
			  + RELAX_RELOC1 (fragp->fr_subtype));
d13163 1
a13163 1
      return RELAX_NEW (fragp->fr_subtype) - RELAX_OLD (fragp->fr_subtype);
d13165 2
a13166 2

  return 0;
a13269 106
  /* If this is a variant frag, we may need to adjust the existing
     reloc and generate a new one.  */
  if (fixp->fx_frag->fr_opcode != NULL
      && ((fixp->fx_r_type == BFD_RELOC_GPREL16
	   && ! HAVE_NEWABI)
	  || (fixp->fx_r_type == BFD_RELOC_MIPS_GOT_DISP
	      && HAVE_NEWABI)
	  || fixp->fx_r_type == BFD_RELOC_MIPS_GOT16
	  || fixp->fx_r_type == BFD_RELOC_MIPS_CALL16
	  || fixp->fx_r_type == BFD_RELOC_MIPS_GOT_HI16
	  || fixp->fx_r_type == BFD_RELOC_MIPS_GOT_LO16
	  || fixp->fx_r_type == BFD_RELOC_MIPS_CALL_HI16
	  || fixp->fx_r_type == BFD_RELOC_MIPS_CALL_LO16)
    )
    {
      arelent *reloc2;

      assert (! RELAX_MIPS16_P (fixp->fx_frag->fr_subtype));

      /* If this is not the last reloc in this frag, then we have two
	 GPREL relocs, or a GOT_HI16/GOT_LO16 pair, or a
	 CALL_HI16/CALL_LO16, both of which are being replaced.  Let
	 the second one handle all of them.  */
      if (fixp->fx_next != NULL
	  && fixp->fx_frag == fixp->fx_next->fx_frag)
	{
	  assert ((fixp->fx_r_type == BFD_RELOC_GPREL16
		   && fixp->fx_next->fx_r_type == BFD_RELOC_GPREL16)
		  || (fixp->fx_r_type == BFD_RELOC_MIPS_GOT_HI16
		      && (fixp->fx_next->fx_r_type
			  == BFD_RELOC_MIPS_GOT_LO16))
		  || (fixp->fx_r_type == BFD_RELOC_MIPS_CALL_HI16
		      && (fixp->fx_next->fx_r_type
			  == BFD_RELOC_MIPS_CALL_LO16)));
	  retval[0] = NULL;
	  return retval;
	}

      fixp->fx_where = fixp->fx_frag->fr_opcode - fixp->fx_frag->fr_literal;
      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
      reloc->addend += fixp->fx_frag->tc_frag_data.tc_fr_offset;
      reloc2 = retval[1] = (arelent *) xmalloc (sizeof (arelent));
      reloc2->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc2->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc2->address = (reloc->address
			 + (RELAX_RELOC2 (fixp->fx_frag->fr_subtype)
			    - RELAX_RELOC1 (fixp->fx_frag->fr_subtype)));
      reloc2->addend = reloc->addend;
      reloc2->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_LO16);
      assert (reloc2->howto != NULL);

      if (RELAX_RELOC3 (fixp->fx_frag->fr_subtype))
	{
	  arelent *reloc3;

	  reloc3 = retval[2] = (arelent *) xmalloc (sizeof (arelent));
	  *reloc3 = *reloc2;
	  reloc3->address += 4;
	}

      if (mips_pic == NO_PIC)
	{
	  assert (fixp->fx_r_type == BFD_RELOC_GPREL16);
	  fixp->fx_r_type = BFD_RELOC_HI16_S;
	}
      else if (mips_pic == SVR4_PIC)
	{
	  switch (fixp->fx_r_type)
	    {
	    default:
	      abort ();
	    case BFD_RELOC_MIPS_GOT16:
	      break;
	    case BFD_RELOC_MIPS_GOT_LO16:
	    case BFD_RELOC_MIPS_CALL_LO16:
	      if (HAVE_NEWABI)
		{
		  fixp->fx_r_type = BFD_RELOC_MIPS_GOT_PAGE;
		  reloc2->howto = bfd_reloc_type_lookup
		    (stdoutput, BFD_RELOC_MIPS_GOT_OFST);
		}
	      else
		fixp->fx_r_type = BFD_RELOC_MIPS_GOT16;
	      break;
	    case BFD_RELOC_MIPS_CALL16:
	    case BFD_RELOC_MIPS_GOT_OFST:
	    case BFD_RELOC_MIPS_GOT_DISP:
	      if (HAVE_NEWABI)
		{
		  /* It may seem nonsensical to relax GOT_DISP to
		     GOT_DISP, but we're actually turning a GOT_DISP
		     without offset into a GOT_DISP with an offset,
		     getting rid of the separate addition, which we can
		     do when the symbol is found to be local.  */
		  fixp->fx_r_type = BFD_RELOC_MIPS_GOT_DISP;
		  retval[1] = NULL;
		}
	      else
		fixp->fx_r_type = BFD_RELOC_MIPS_GOT16;
	      break;
	    }
	}
      else
	abort ();
    }

a13376 3
  int old, new;
  char *fixptr;

d13676 18
a13693 2
      if (fragp->fr_opcode == NULL)
	return;
d13695 11
a13705 3
      old = RELAX_OLD (fragp->fr_subtype);
      new = RELAX_NEW (fragp->fr_subtype);
      fixptr = fragp->fr_literal + fragp->fr_fix;
d13707 4
a13710 2
      if (new > 0)
	memmove (fixptr - old, fixptr, new);
d13712 6
a13717 1
      fragp->fr_fix += new - old;
@


1.246
log
@gas/
* config/tc-mips.c (append_insn): Properly detect variant frags
that preclude swapping of relaxed branches.  Correctly swap
instructions between frags when dealing with relaxed branches.

gas/testsuite/
* gas/mips/relax-swap1-mips1.d: New test for branch relaxation
with swapping for MIPS1.
* gas/mips/relax-swap1-mips2.d: New test for branch relaxation
with swapping for MIPS2.
* gas/mips/relax-swap1.l: Stderr output for the new tests.
* gas/mips/relax-swap1.s: Source for the new tests.
* gas/mips/relax-swap2.d: New test for branch likely relaxation
with swapping.
* gas/mips/relax-swap2.l: Stderr output for the new test.
* gas/mips/relax-swap2.s: Source for the new test.
* gas/mips/mips.exp: Run the new tests.
@
text
@d1711 1
a1711 1
		 || (mips_tune == CPU_R3900 && (pinfo & INSN_MULT)))
d1733 1
a1733 1
		 || (mips_tune == CPU_R3900 && (pinfo & INSN_MULT)))
d1771 1
a1771 1
		    || (mips_tune == CPU_R3900 && (pinfo & INSN_MULT))))
d1775 1
a1775 1
		    || (mips_tune == CPU_R3900 && (pinfo & INSN_MULT)))))
d2300 1
a2300 1
		     || (mips_tune == CPU_R3900 && (pinfo & INSN_MULT)))
@


1.245
log
@gas/
	* config/tc-mips.c (macro_build_jalr): When adding an R_MIPS_JALR
	reloc, reserve space for the delay slot as well as the jalr itself.

gas/testsuite/
	* gas/mips/elf-rel18.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d1542 2
d1924 4
d1941 1
d2272 4
a2275 4
	      /* If the previous instruction is in a variant frag, we
		 can not do the swap.  This does not apply to the
		 mips16, which uses variant frags for different
		 purposes.  */
d2277 1
a2277 1
		  && prev_insn_frag->fr_type == rs_machine_dependent)
d2462 23
a2484 3
		  memcpy (temp, prev_f, 4);
		  memcpy (prev_f, f, 4);
		  memcpy (f, temp, 4);
d2512 2
a2513 6
		  if (fixp[0])
		    {
		      fixp[0]->fx_frag = prev_insn_frag;
		      fixp[0]->fx_where = prev_insn_where;
		    }
		  if (fixp[1])
d2515 15
a2529 2
		      fixp[1]->fx_frag = prev_insn_frag;
		      fixp[1]->fx_where = prev_insn_where;
d2531 1
a2531 1
		  if (fixp[2])
d2533 6
a2538 2
		      fixp[2]->fx_frag = prev_insn_frag;
		      fixp[2]->fx_where = prev_insn_where;
@


1.244
log
@	* config/tc-mips.c (warn_nops): Remove static variable.
	(macro): Remove test of warn_nops.
	(md_shortops): Remove 'n'.
	(md_parse_option): Remove 'n' case.
	(md_show_usage): Remove -n.
	* doc/as.texinfo (Overview): Remove MIPS -n option.
	* doc/c-mips.texi (MIPS Opts): Remove mention -n.
	* NEWS: Mention removal of MIPS -n option.
@
text
@d3172 1
a3172 1
      frag_grow (4);
@


1.243
log
@	* config/tc-mips.c (ISA_HAS_COPROC_DELAYS): Remove.
	(cop_interlocks): Check ISA level.
	(cop_mem_interlocks): Define.
	(reg_needs_delay): Check cop_interlocks rather than
	ISA_HAS_COPROC_DELAYS.
	(append_insn): Likewise.  Use cop_mem_interlocks rather than
	directly checking mips_opts.isa.
	(mips_emit_delays): Likewise.
@
text
@a381 3
/* Warn about all NOPS that the assembler generates.  */
static int warn_nops = 0;

d4196 1
a4196 6
	    {
	      if (warn_nops)
		as_warn (_("Branch %s is always false (nop)"),
			 ip->insn_mo->name);
	      macro_build (NULL, &icnt, NULL, "nop", "", 0);
	    }
d4198 1
a4198 6
	    {
	      if (warn_nops)
		as_warn (_("Branch likely %s is always false"),
			 ip->insn_mo->name);
	      macro_build (NULL, &icnt, &offset_expr, "bnel", "s,t,p", 0, 0);
	    }
d10418 1
a10418 1
const char *md_shortopts = "nO::g::G:";
a10602 4
    case 'n':
      warn_nops = 1;
      break;

a14690 1
-n			warn about NOPs generated from macros\n\
@


1.242
log
@bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.  Use
	_bfd_mips_elf_hi16_reloc for R_MIPS_HI16 and R_MIPS_GNU_REL_HI16,
	_bfd_mips_elf_lo16_reloc for R_MIPS_LO16 and R_MIPS_GNU_REL_LO16,
	and _bfd_mips_elf_got16_reloc for R_MIPS_GOT16.  Change rightshift
	to 16 for R_MIPS_HI16 and R_MIPS_GNU_REL_HI16.
	(mips_elf_generic_reloc, struct mips_hi16, mips_elf_hi16_reloc)
	(mips_elf_lo16_reloc, mips_elf_got16_reloc): Delete.
	(_bfd_mips_elf32_gprel16_reloc): Remove special case.
	(mips_elf_gprel32_reloc, mips32_64bit_reloc): Likewise.

	* elf64-mips.c (mips_elf64_howto_table_rel): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.  Use
	_bfd_mips_elf_hi16_reloc for R_MIPS_HI16, _bfd_mips_elf_lo16_reloc
	for R_MIPS_LO16 and _bfd_mips_elf_got16_reloc for R_MIPS_GOT16.
	Change R_MIPS_HI16's rightshift to 16.
	(mips_elf64_howto_table_rela): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.
	Use _bfd_mips_elf_generic_reloc for R_MIPS_GOT16 as well.
	(mips_elf64_hi16_reloc, mips_elf64_got16_reloc): Delete.
	(mips_elf64_shift6_reloc): Remove special case.  Use
	_bfd_mips_elf_generic_reloc instead of returning bfd_reloc_continue.

	* elfn32-mips.c (prev_reloc_section): Delete.
	(prev_reloc_address, prev_reloc_addend): Delete.
	(elf_mips_howto_table_rel, elf_mips_howto_table_rela): As for
	elf64-mips.c
	(GET_RELOC_ADDEND, SET_RELOC_ADDEND): Delete.
	(mips_elf_generic_reloc, struct mips_hi16, mips_elf_hi16_reloc)
	(mips_elf_lo16_reloc, mips_elf_got16_reloc): Delete.
	(mips_elf_gprel16_reloc): Delete use of GET_RELOC_ADDEND.
	(mips_elf_literal_reloc, mips_elf_gprel32_reloc): Likewise.
	(mips16_jump_reloc, mips16_gprel_reloc): Likewise.
	(mips_elf_shift6_reloc): Likewise.  Delete use of SET_RELOC_ADDEND.

	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp): Use
	_bfd_relocate_contents to install an in-place addend.
	(mips_hi16): New structure.
	(mips_hi16_list): Moved from elf32-mips.c.
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_got16_reloc): New functions.
	(_bfd_mips_elf_lo16_reloc, _bfd_mips_elf_generic_reloc): New functions.
	(mips_elf_calculate_relocation): Assume addend is unshifted.
	(_bfd_mips_elf_relocate_section): Don't apply the howto rightshift
	on top of the usual high-part shift.  Don't shift the addend right
	before calling mips_elf_calculate_relocation.

	* elfxx-mips.h (_bfd_mips_elf_hi16_reloc): Declare.
	(_bfd_mips_elf_got16_reloc, _bfd_mips_elf_lo16_reloc): Declare.
	(_bfd_mips_elf_generic_reloc): Declare.

gas/
	* config/tc-mips.c (mips_need_elf_addend_fixup): Delete.
	(md_apply_fix3): Remove bfd_install_relocation workarounds.
	(tc_gen_reloc): Likewise. Factor handling of pc-relative relocations
	and treat fx_addnumber as relative to the relocation address.

gas/testsuite/
	* gas/mips/mips16-jalx.d: Use -mabi=o64.
	* gas/mips/mips16.d: Likewise.
	* gas/mips/elf-rel17.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a239 14
/* Some ISA's have delay slots for instructions which read or write
   from a coprocessor (eg. mips1-mips3); some don't (eg mips4).
   Return true if instructions marked INSN_LOAD_COPROC_DELAY,
   INSN_COPROC_MOVE_DELAY, or INSN_WRITE_COND_CODE actually have a
   delay slot in this ISA.  The uses of this macro assume that any
   ISA that has delay slots for one of these, has them for all.  They
   also assume that ISAs which don't have delays for these insns, don't
   have delays for the INSN_LOAD_MEMORY_DELAY instructions either.  */
#define ISA_HAS_COPROC_DELAYS(ISA) (        \
   (ISA) == ISA_MIPS1                       \
   || (ISA) == ISA_MIPS2                    \
   || (ISA) == ISA_MIPS3                    \
   )

d339 4
a342 1
   from the GPRs, and thus does not require nops to be inserted.  */
d349 7
a355 2
/* As with other "interlocks" this is used by hardware that has FP
   (co-processor) interlocks.  */
d357 16
a372 5
#define cop_interlocks (mips_opts.arch == CPU_R4300                        \
                        || mips_opts.arch == CPU_VR5400                    \
                        || mips_opts.arch == CPU_VR5500                    \
                        || mips_opts.arch == CPU_SB1                       \
			)
d1487 7
a1493 9
      && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
      && ((prev_pinfo & INSN_LOAD_COPROC_DELAY)
	  || (! gpr_interlocks
	      && (prev_pinfo & INSN_LOAD_MEMORY_DELAY))))
    {
      /* A load from a coprocessor or from memory.  All load
	 delays delay the use of general register rt for one
	 instruction on the r3000.  The r6000 and r4000 use
	 interlocks.  */
d1586 4
a1589 5
	  && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
	  && (((prev_pinfo & INSN_LOAD_COPROC_DELAY)
               && ! cop_interlocks)
	      || (! gpr_interlocks
		  && (prev_pinfo & INSN_LOAD_MEMORY_DELAY))))
d1593 1
a1593 2
	     instruction on the r3000.  The r6000 and r4000 use
	     interlocks.  */
a1603 1
	       && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
d1606 2
a1607 2
		   || (mips_opts.isa == ISA_MIPS1
		       && (prev_pinfo & INSN_COPROC_MEMORY_DELAY))))
a1615 3
	     On the r6000 and r4000 loading a coprocessor register
	     from memory is interlocked, and does not require a delay.

a1658 1
	       && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
a1764 1
	   && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
d2283 2
a2284 2
		  && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
		  && (pinfo & INSN_READ_COND_CODE))
a2288 1
		  && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
d2293 2
a2294 1
			 | INSN_WRITE_COND_CODE)))
d2301 2
a2302 2
		  && ! gpr_interlocks
		  && (prev_pinfo & INSN_LOAD_MEMORY_DELAY))
a2303 1
		  && mips_opts.isa == ISA_MIPS1
d2305 2
a2306 1
		  && (prev_pinfo & INSN_COPROC_MEMORY_DELAY))
a2408 1
		  && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
d2410 5
a2414 4
		  && ((prev_prev_insn.insn_mo->pinfo & INSN_LOAD_COPROC_DELAY)
		      || (! gpr_interlocks
			  && (prev_prev_insn.insn_mo->pinfo
			      & INSN_LOAD_MEMORY_DELAY)))
d2682 5
a2686 6
	   && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
	   && (! cop_interlocks
               && (prev_insn.insn_mo->pinfo
                   & (INSN_LOAD_COPROC_DELAY
                      | INSN_COPROC_MOVE_DELAY
                      | INSN_WRITE_COND_CODE))))
d2692 2
a2693 3
	      && ! gpr_interlocks
	      && (prev_insn.insn_mo->pinfo
                  & INSN_LOAD_MEMORY_DELAY))
d2695 2
a2696 3
	      && mips_opts.isa == ISA_MIPS1
	      && (prev_insn.insn_mo->pinfo
		  & INSN_COPROC_MEMORY_DELAY)))
d2701 2
a2702 3
	       && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
	       && (! cop_interlocks
                   && prev_insn.insn_mo->pinfo & INSN_WRITE_COND_CODE))
d2712 2
a2713 3
		&& ISA_HAS_COPROC_DELAYS (mips_opts.isa)
		&& (! cop_interlocks
                    && prev_prev_insn.insn_mo->pinfo & INSN_WRITE_COND_CODE))
@


1.241
log
@	* config/tc-mips.c (s_change_section): When parsing the MIPS-specific
	.section syntax, map SHT_MIPS_DWARF to SHT_PROGBITS.
@
text
@a11341 25
#ifdef OBJ_ELF
static int
mips_need_elf_addend_fixup (fixS *fixP)
{
  if (S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16)
    return 1;
  if (mips_pic == EMBEDDED_PIC
      && S_IS_WEAK (fixP->fx_addsy))
    return 1;
  if (mips_pic != EMBEDDED_PIC
      && (S_IS_WEAK (fixP->fx_addsy)
	  || S_IS_EXTERNAL (fixP->fx_addsy))
      && !S_IS_COMMON (fixP->fx_addsy))
    return 1;
  if (((bfd_get_section_flags (stdoutput,
			       S_GET_SEGMENT (fixP->fx_addsy))
	& (SEC_LINK_ONCE | SEC_MERGE)) != 0)
      || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
		   ".gnu.linkonce",
		   sizeof (".gnu.linkonce") - 1))
    return 1;
  return 0;
}
#endif

a11366 55
  /* If we aren't adjusting this fixup to be against the section
     symbol, we need to adjust the value.  */
#ifdef OBJ_ELF
  if (fixP->fx_addsy != NULL && OUTPUT_FLAVOR == bfd_target_elf_flavour)
    {
      if (mips_need_elf_addend_fixup (fixP)
	  && howto->partial_inplace
	  && fixP->fx_r_type != BFD_RELOC_GPREL16
	  && fixP->fx_r_type != BFD_RELOC_GPREL32
	  && fixP->fx_r_type != BFD_RELOC_MIPS16_GPREL)
	{
	  /* In this case, the bfd_install_relocation routine will
	     incorrectly add the symbol value back in.  We just want
	     the addend to appear in the object file.

	     The condition above used to include
	     "&& (! fixP->fx_pcrel || howto->pcrel_offset)".

	     However, howto can't be trusted here, because we
	     might change the reloc type in tc_gen_reloc.  We can
	     check howto->partial_inplace because that conversion
	     happens to preserve howto->partial_inplace; but it
	     does not preserve howto->pcrel_offset.  I've just
	     eliminated the check, because all MIPS PC-relative
	     relocations are marked howto->pcrel_offset.

	     howto->pcrel_offset was originally added for
	     R_MIPS_PC16, which is generated for code like

		    globl g1 .text
		    .text
		    .space 20
	     g1:
	     x:
		    bal g1
	   */
	  *valP -= S_GET_VALUE (fixP->fx_addsy);
	}

      /* This code was generated using trial and error and so is
	 fragile and not trustworthy.  If you change it, you should
	 rerun the elf-rel, elf-rel2, and empic testcases and ensure
	 they still pass.  */
      if (fixP->fx_pcrel)
	{
	  *valP += fixP->fx_frag->fr_address + fixP->fx_where;

	  /* BFD's REL handling, for MIPS, is _very_ weird.
	     This gives the right results, but it can't possibly
	     be the way things are supposed to work.  */
	  *valP += fixP->fx_frag->fr_address + fixP->fx_where;
	}
    }
#endif

d13329 1
a13329 1
  else if (fixp->fx_r_type == BFD_RELOC_PCREL_LO16)
d13331 14
a13345 2
	reloc->addend = fixp->fx_addnumber;
      else
d13347 8
a13354 1
	  /* We use a special addend for an internal RELLO reloc.  */
d13356 1
a13356 1
	    reloc->addend = reloc->address - S_GET_VALUE (fixp->fx_subsy);
d13358 1
a13358 1
	    reloc->addend = fixp->fx_addnumber + reloc->address;
a13359 10
    }
  else if (fixp->fx_r_type == BFD_RELOC_PCREL_HI16_S)
    {
      assert (fixp->fx_next != NULL
	      && fixp->fx_next->fx_r_type == BFD_RELOC_PCREL_LO16);

      /* The reloc is relative to the RELLO; adjust the addend
	 accordingly.  */
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
	reloc->addend = fixp->fx_next->fx_addnumber;
d13362 4
a13365 5
	  /* We use a special addend for an internal RELHI reloc.  */
	  if (symbol_section_p (fixp->fx_addsy))
	    reloc->addend = (fixp->fx_next->fx_frag->fr_address
			     + fixp->fx_next->fx_where
			     - S_GET_VALUE (fixp->fx_subsy));
d13367 1
a13367 3
	    reloc->addend = (fixp->fx_addnumber
			     + fixp->fx_next->fx_frag->fr_address
			     + fixp->fx_next->fx_where);
d13370 1
a13370 1
  else if (fixp->fx_pcrel == 0 || OUTPUT_FLAVOR == bfd_target_elf_flavour)
a13371 9
  else
    {
      if (OUTPUT_FLAVOR != bfd_target_aout_flavour)
	/* A gruesome hack which is a result of the gruesome gas reloc
	   handling.  */
	reloc->addend = reloc->address;
      else
	reloc->addend = -reloc->address;
    }
d13420 1
a13420 2
      reloc2->addend = fixp->fx_addnumber - S_GET_VALUE (fixp->fx_addsy)
	+ fixp->fx_frag->tc_frag_data.tc_fr_offset;
@


1.240
log
@gas/
	* config/tc-mips.c (macro): Switch misordered call to frag_grow()
	and setting of tc_fr_offset.

gas/testsuite/
	* gas/mips/elf-rel16.[sd]: New test.
	* gas/mips/mips.exp: Run it.
	* gas/mips/elf-rel-xgot-n32.d: Fix addends for "lw $5,dl1+34($5)".
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
@
text
@d11984 16
@


1.239
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d6351 1
a6357 1
	  frag_grow (36);
@


1.238
log
@* config/tc-mips.c (macro): Handle new macros: "lca" and "dlca"
for loading addresses using CALL relocations.
Don't emit CALL relocations when a base register is used.

* gas/mips/lca-svr4pic.d: New test for the "lca" macro.
* gas/mips/lca-xgot.d: Likewise.
* gas/mips/lca.s: Source for the new tests.
* gas/mips/mips.exp: Run the new tests.

* opcode/mips.h: Define new enum members, M_LCA_AB and M_DLCA_AB.

* mips-opc.c (mips_builtin_opcodes): Handle new macros: "lca" and
"dlca".
@
text
@d471 1
a471 1
/* Similiar for NewABI PIC code, where $gp is callee-saved.  NewABI has some
d1711 2
a1712 2
	     Also the tx39's multiply instructions can be exectuted
             immediatly after a read from HI/LO (without the delay),
d2291 1
a2291 1
		 delay slot, becase the target of the branch might
d3280 1
a3280 1
  /* Right now, this routine can only handle signed 32-bit contants.  */
d3430 1
a3430 1
 *  This routine generates the least number of instructions neccessary to load
d3983 1
a3983 1
 * probably be handled by some kind of table or grammer aproach instead of
d3987 1
a3987 1
 * consecutivly that would load AT with the upper half of the same address.
d4031 1
a4031 1
  /* Umatched fixups should not be put in the same frag as a relaxable
d6099 1
a6099 1
	     addressible with sign-extended 32-bit addresses, it is
d11799 1
a11799 1
    o  Note that the assembler pulls down any immediately preceeding label
d12554 1
a12554 1
   was given in the preceeding .cpsetup, it results in:
@


1.237
log
@* config/tc-mips.c: Formatting fixes.
@
text
@d4013 1
d4778 5
d4786 1
d4966 1
a4966 1
	     or if tempreg is PIC_CALL_REG
d4996 2
a4997 1
	  if (expr1.X_add_number == 0 && tempreg == PIC_CALL_REG)
d5093 1
a5093 1
	     or if tempreg is PIC_CALL_REG
d5113 2
a5114 1
	  if (offset_expr.X_add_number == 0 && tempreg == PIC_CALL_REG)
d5218 1
a5218 1
	     or if tempreg is PIC_CALL_REG
d5261 2
a5262 1
	  if (expr1.X_add_number == 0 && tempreg == PIC_CALL_REG)
d5423 1
a5423 1
	     or if tempreg is PIC_CALL_REG
d5455 2
a5456 1
	  if (expr1.X_add_number == 0 && tempreg == PIC_CALL_REG)
@


1.236
log
@	* config/tc-mips.c (normalize_constant_expr): New function to fix sign
	extensions broken by gas' expression evaluation of constants.
	(check_absolute_expr): Use it.
	(mips_ip): Likewise.
@
text
@d4622 1
a4622 1
	  macro_build (NULL, &icnt,NULL, "break", "c", 7);
d5142 1
a5142 1
		      macro_build (NULL, &icnt,NULL, ADDRESS_ADD_INSN,
d7325 1
a7325 1
      macro_build (NULL, &icnt,NULL, "dsubu", "d,v,t", AT, 0, treg);
d7369 1
a7369 1
	macro_build ( NULL, &icnt,NULL, r, "d,w,<", AT, sreg, rot);
d7582 1
a7582 1
	macro_build (NULL, &icnt,NULL, "sltu","d,v,t", dreg, 0, treg);
@


1.235
log
@	* config/tc-mips.c (macro_build_ldst_constoffset,load_register,macro):
	Fix indentation. Better error message.
@
text
@d3332 8
d3349 2
d8575 1
d9064 1
@


1.234
log
@	* config/tc-mips.c (macro_build_ldst_constoffset,load_register,macro):
	Unbreak overflow checks.
@
text
@d3274 1
a3274 1
	as_bad (_("too large constant specified"));
d3276 2
a3277 2
    ep->X_add_number = (((ep->X_add_number & 0xffffffff) ^ 0x80000000)
			- 0x80000000);
d3438 1
a3438 1
	    as_bad (_("too large constant specified"));
d3440 2
a3441 2
	ep->X_add_number = (((ep->X_add_number & 0xffffffff) ^ 0x80000000)
			    - 0x80000000);
d5949 1
a5949 1
	    as_bad (_("too large constant specified"));
d5951 2
a5952 2
	offset_expr.X_add_number = (((offset_expr.X_add_number & 0xffffffff)
				     ^ 0x80000000) - 0x80000000);
@


1.233
log
@2003-10-01  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (s_cpreturn): Correct errors in comment.
@
text
@d3270 2
a3271 1
  if (! dbl)
d3273 1
a3273 2
      if (ep->X_add_number & ~((bfd_vma) 0x7fffffff)
	  && ~(ep->X_add_number | 0x7fffffff))
d3434 2
a3435 1
      if (! dbl)
d3437 1
a3437 2
	  if (ep->X_add_number & ~((bfd_vma) 0x7fffffff)
	      && ~(ep->X_add_number | 0x7fffffff))
d5944 3
a5946 1
          && (offset_expr.X_op == O_constant))
d5948 1
a5948 2
	  if (offset_expr.X_add_number & ~((bfd_vma) 0x7fffffff)
	      && ~(offset_expr.X_add_number | 0x7fffffff))
@


1.232
log
@	* config/tc-mips.c (macro_build_ldst_constoffset): Fix sign extension
	tests.
	(load_register): Likewise.
	(macro): Likewise.

	* gas/mips/ldstla-32-shared.d: New file.
	* gas/mips/ldstla-32.d: New file.
	* gas/mips/ldstla-32.s: New file.
	* gas/mips/ldstla-n32-shared.d: New file.
	* gas/mips/ldstla-n32.d: New file.
	* gas/mips/ldstla-n32.s: New file.
	* gas/mips/ldstla-n64-shared.d: New file.
	* gas/mips/ldstla-n64.d: New file.
	* gas/mips/ldstla-n64.s: New file.
	* gas/mips/mips.exp: Add ld-st-la tests.
@
text
@d12530 1
a12530 1
   was given in the preceeding .gpsetup, it results in:
d12534 1
a12534 1
     daddiu	$gp, $gp, $reg2
@


1.231
log
@[ gas/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (mips_ip): Capitalize first word of
        existing condition code warning, and add condition code
        warnings for .ps instructions, and for bc1any[24][tf].

[ gas/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

        * lib/gas-defs.exp (run_dump_test): If stderr file is specified
        and there was no stderr output, compare anyway (i.e., cause a
        test failure).
        * gas/mips/mips64-mips3d.s: Add some new instructions to test warnings.
        * gas/mips/mips64-mips3d.l: New file.
        * gas/mips/mips64-mips3d.d: Use mips64-mips3d.l, and update for
        changes to mips64-mips3d.s.
        * gas/mips/mips64-mips3d-incl.d: Likewise.
        * gas/mips/set-arch.l: New file.
        * gas/mips/set-arch.d: Specify set-arch.l as stderr output to check.
        * gas/mips/mips5.l: Make error messages match source.
@
text
@d3272 2
a3273 2
      if (ep->X_add_number & ~((bfd_vma) 0xffffffff)
	  && ~(ep->X_add_number | 0xffffffff))
d3281 1
a3281 1
  if (! IS_SEXT_32BIT_NUM(ep->X_add_number))
d3436 2
a3437 2
	  if (ep->X_add_number & ~((bfd_vma) 0xffffffff)
	      && ~(ep->X_add_number | 0xffffffff))
d5116 1
a5116 1
	      else if (IS_SEXT_32BIT_NUM (expr1.X_add_number))
d5464 1
a5464 1
	  else if (IS_SEXT_32BIT_NUM (expr1.X_add_number))
d5946 2
a5947 2
	  if (offset_expr.X_add_number & ~((bfd_vma) 0xffffffff)
	      && ~(offset_expr.X_add_number | 0xffffffff))
d6140 1
a6140 1
	      && ! IS_SEXT_32BIT_NUM (offset_expr.X_add_number))
@


1.230
log
@[ bfd/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* archures.c (bfd_mach_mipsisa64r2): New define.
	* bfd-in2.h: Regenerate.
	* aoutx.h (NAME(aout,machine_type)): Handle bfd_mach_mipsisa64r2.
	* cpu-mips.c (I_mipsisa64r2): New enum value.
	(arch_info_struct): Add entry for I_mipsisa64r2.
	* elfxx-mips.c (_bfd_elf_mips_mach)
	(_bfd_mips_elf_print_private_bfd_data): Handle E_MIPS_ARCH_64R2.
	(mips_set_isa_flags): Add bfd_mach_mipsisa64r2 case.
	(mips_mach_extensions): Add entry for bfd_mach_mipsisa64r2.

[ binutils/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_ARCH_64R2.

[ gas/Changelog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* configure.in (mipsisa64r2, mipsisa64r2el, mipsisa64r2*): New CPUs.
	* configure: Regenerate.
	* config/tc-mips.c (imm2_expr): New variable.
	(md_assemble, mips16_ip): Initialize imm2_expr.
	(ISA_HAS_64BIT_REGS, ISA_HAS_DROR, ISA_HAS_ROR): Add ISA_MIPS64R2.
	(macro_build): Handle +A, +B, +C, +E, +F, +G, and +H format operands.
	(macro): Handle M_DEXT and M_DINS.
	(validate_mips_insn): Handle +E, +F, +G, +H, and +I format operands.
	(mips_ip): Likewise.
	(OPTION_MIPS64R2): New define.
	(md_longopts): New entry for -mips64r2 (OPTION_MIPS64R2).
	OPTION_ASE_BASE): Increase to compensate for OPTION_MIPS64R2.
	(md_parse_option): Handle OPTION_MIPS64R2.
	(s_mipsset): Handle setting "mips64r2" ISA.
	(mips_cpu_info_table): Add mips64r2.
	(md_show_usage): Document -mips64r2 option.
	* doc/as.texinfo: Docuemnt -mips64r2 option.
	* doc/c-mips.texi: Likewise.

[ gas/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0-names-mips64r2.d: New file.
	* gas/mips/cp0sel-names-mips64r2.d: New file.
	* gas/mips/elf_arch_mips64r2.d: New file.
	* gas/mips/hwr-names-mips64r2.d: New file.
	* gas/mips/mips32r2-ill-fp64.l: New file.
	* gas/mips/mips32r2-ill-fp64.s: New file.
	* gas/mips/mips64r2-ill.l: New file.
	* gas/mips/mips64r2-ill.s: New file.
	* gas/mips/mips64r2.d: New file.
	* gas/mips/mips64r2.s: New file.
	* gas/mips/mips.exp: Define "mips64r2" arch, and run new tests.

[ include/elf/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (E_MIPS_ARCH_64R2): New define.

[ include/opcode/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Document +E, +F, +G, +H, and +I operand types.
	Update documentation of I, +B and +C operand types.
	(INSN_ISA64R2, ISA_MIPS64R2, CPU_MIPS64R2): New defines.
	(M_DEXT, M_DINS): New enum values.

[ ld/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ldmain.c (get_emulation): Ignore "-mips64r2".

[ ld/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ld-mips-elf/mips-elf-flags.exp: Add tests for combinations
	with MIPS64r2.

[ opcodes/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_arch_choices): Add entry for "mips64r2"
	(print_insn_args): Add handing for +E, +F, +G, and +H.
	* mips-opc.c (I65): New define for MIPS64r2.
	(mips_builtin_opcodes): Add "dext", "dextm", "dextu", "dins",
	"dinsm", "dinsu", "drotl", "drotr", "drotr32", "drotrv", "dsbh",
	and "dshd" for MIPS64r2.  Adjust "dror", "dror32", and "drorv" to
	be supported on MIPS64r2.
@
text
@d9372 12
a9383 1
		as_bad (_("invalid condition code register $fcc%d"), regno);
@


1.229
log
@	* config/tc-mips.c (macro_build_ldst_constoffset): Don't silently
	truncate values which won't fit im 32 bits.
	(load_register): Likewise.
	(macro): Likewise.
@
text
@d269 1
d275 1
a275 1
   0				\
d282 1
d1030 1
d1329 1
d2879 35
d4479 98
d8200 5
d8464 6
d8489 6
d8521 10
d8558 9
d9534 1
d10433 2
d10437 1
a10437 1
#define OPTION_ASE_BASE (OPTION_ARCH_BASE + 10)
d10642 4
d12203 2
d12242 1
d14488 1
d14720 1
@


1.228
log
@	* config/tc-mips.c (HAVE_64BIT_ADDRESS_CONSTANTS): Remove.
	(macro_build_ldst_constoffset): Sign-extend 32-bit constants. Change
	the function prototype.
	(load_register): Likewise. Simplify the checks for sign-extended
	constants.
	(macro): Likewise. Fix code generation for 64-bit address constants
	outside the 32-bit compatibility space. Adjust
	macro_build_ldst_constoffset calls.
	(s_cprestore): Adjust macro_build_ldst_constoffset call.
@
text
@d3232 5
d3239 1
d3396 5
d3403 1
d5808 5
d5815 1
@


1.227
log
@	* config/tc-mips.c (mips_flag_pdr): Define.
	(md_begin) [OBJ_ELF]: Use it to control .pdr creation.
	(s_mips_end) [OBJ_ELF]: Likewise.
	(md_longopts) [OBJ_ELF]: Define OPTION_PDR, OPTION_NO_PDR.
	(md_parse_option) [OBJ_ELF]: Handle them.
	(md_show_usage) [OBJ_ELF]: Document -mpdr, -mno-pdr.

	* doc/c-mips.texi (MIPS Opts): Document -mpdr, -mno-pdr.
	* doc/as.texinfo (Overview) [MIPS]: Likewise.
@
text
@a304 2
#define HAVE_64BIT_ADDRESS_CONSTANTS (HAVE_64BIT_ADDRESSES \
				      || HAVE_64BIT_GPRS)
d3226 1
a3226 1
			      const char *op, int treg, int breg)
d3230 5
d3387 7
a3393 6
      if (ep->X_add_number < 0x8000
	  && (ep->X_add_number >= 0
	      || (ep->X_add_number >= -0x8000
		  && (! dbl
		      || ! ep->X_unsigned
		      || sizeof (ep->X_add_number) > 4))))
d3410 1
a3410 11
      else if ((IS_SEXT_32BIT_NUM (ep->X_add_number)
		&& (! dbl
		    || ! ep->X_unsigned
		    || sizeof (ep->X_add_number) > 4
		    || (ep->X_add_number & 0x80000000) == 0))
	       || ((HAVE_32BIT_GPRS || ! dbl)
		   && (ep->X_add_number &~ (offsetT) 0xffffffff) == 0)
	       || (HAVE_32BIT_GPRS
		   && ! dbl
		   && ((ep->X_add_number &~ (offsetT) 0xffffffff)
		       == ~ (offsetT) 0xffffffff)))
d5447 2
a5448 1
						mips_frame_reg);
d5599 2
a5600 1
						mips_frame_reg);
d5790 9
d5931 6
a5936 4
	  if ((offset_expr.X_op != O_constant && HAVE_64BIT_ADDRESSES)
	      || (offset_expr.X_op == O_constant
		  && !IS_SEXT_32BIT_NUM (offset_expr.X_add_number + 0x8000)
		  && HAVE_64BIT_ADDRESS_CONSTANTS))
d5983 3
a5985 3
	  else if (offset_expr.X_op == O_constant
		   && !HAVE_64BIT_ADDRESS_CONSTANTS
		   && !IS_SEXT_32BIT_NUM (offset_expr.X_add_number))
d12312 1
a12312 1
				mips_gp_register, SP);
@


1.226
log
@include/opcode/
	* mips.h (CPU_RM7000): New macro.
	(OPCODE_IS_MEMBER): Match CPU_RM7000 against 4650 insns.

bfd/
	* archures.c (bfd_mach_mips7000): New.
	* bfd-in2.h: Regenerated.
	* cpu-mips.c (arch_info_struct): Add an entry for mips:7000.
	* elfxx-mips.c (mips_set_isa_flags): Handle bfd_mach_mips7000.
	(mips_mach_extensions): Add an entry for it.

opcodes/
	* mips-dis.c (mips_arch_choices): Add rm7000 and rm9000 entries.

gas/
	* config/tc-mips.c (hilo_interlocks): True for CPU_RM7000.
	(mips_cpu_info_table): Add rm7000 and rm9000 entries.

gas/testsuite/
	* gas/mips/rm7000.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d77 9
d1295 1
a1295 1
	else if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d10334 4
d10686 8
d14064 2
a14065 1
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour && ! ECOFF_DEBUGGING)
d14550 1
@


1.225
log
@[ gas/ChangeLog ]
2003-07-08  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (mips_validate_fix): Do not warn about branch
        target being a global symbol if not compiling SVR4 PIC code.

[ gas/testsuite/ChangeLog ]
2003-07-08  Chris Demetriou  <cgd@@broadcom.com>

        * gas/testsuite/gas/mips/mips.exp: Make sure that branch-misc-2 is
        run to compile non-PIC code, and add branch-misc-2pic.
        * gas/mips/branch-misc-2.l: Adjust for change in non-PIC warnings.
        * gas/mips/branch-misc-2pic.l: New file.
        * gas/mips/branch-misc-2pic.s: New file.
@
text
@d339 1
d14293 2
a14294 1
  { "r7000",          0,      ISA_MIPS4,      CPU_R5000 },
@


1.224
log
@2003-06-30  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (s_mipsset): Implement -march= handling
        differently.
@
text
@d11062 3
a11064 2
	  as_warn_where (fixP->fx_file, fixP->fx_line,
			 _("Pretending global symbol used as branch target is local."));
@


1.223
log
@	* config/tc-mips.c: Convert to ISO C90 prototypes. Remove unnecessary
	prototypes and casts. Replace PTR with void *. Reformat.
	* config/tc-mips.h: Likewise.
@
text
@d11948 1
a11948 1
  else if (strncmp (name, "mips", 4) == 0)
d11952 2
a11953 2
      /* Permit the user to change the ISA on the fly.  Needless to
	 say, misuse can cause serious problems.  */
d11975 19
a12063 41
	}
    }
  else if (strncmp (name, "arch=", 5) == 0)
    {
      /* Permit the user to change the architecture on the fly.  Needless
	 to say, misuse can cause serious problems.  */
      if (strcmp (name + 5, "default") == 0)
	{
	  mips_opts.arch = file_mips_arch;
	  mips_opts.isa = file_mips_isa;
	  mips_opts.gp32 = file_mips_gp32;
	  mips_opts.fp32 = file_mips_fp32;
	}
      else
	{
	  const struct mips_cpu_info *p;

	  p = mips_parse_cpu("internal use", name + 5);
	  if (!p)
	    as_bad (_("unknown architecture %s"), name + 5);
	  else
	    {
	      mips_opts.arch = p->cpu;
	      mips_opts.isa = p->isa;
	    }

	  switch (mips_opts.arch)
	    {
	      case CPU_R3000:
	      case CPU_R3900:
	      case CPU_R6000:
	      case CPU_MIPS32:
	      case CPU_MIPS32R2:
		mips_opts.gp32 = 1;
		mips_opts.fp32 = 1;
		break;
	      default:
		mips_opts.gp32 = 0;
		mips_opts.fp32 = 0;
		break;
	    }
@


1.222
log
@	* config/tc-ia64.c (note_register_values): Warning fix.
	* config/tc-mips.c (append_insn): Likewise.
@
text
@a30 1
#ifdef USE_STDARG
a31 4
#endif
#ifdef USE_VARARGS
#include <varargs.h>
#endif
d45 2
a46 2
static int mips_output_flavor PARAMS ((void));
static int mips_output_flavor () { return OUTPUT_FLAVOR; }
d414 1
a414 1
static int nopic_need_relax PARAMS ((symbolS *, int));
d816 1
a816 2
#ifdef __STDC__
#define internalError() \
a817 3
#else
#define internalError() as_fatal (_("MIPS internal Error"));
#endif
a820 11
static inline bfd_boolean reloc_needs_lo_p
  PARAMS ((bfd_reloc_code_real_type));
static inline bfd_boolean fixup_has_matching_lo_p
  PARAMS ((fixS *));
static int insn_uses_reg
  PARAMS ((struct mips_cl_insn *ip, unsigned int reg,
	   enum mips_regclass class));
static int reg_needs_delay
  PARAMS ((unsigned int));
static void mips16_mark_labels
  PARAMS ((void));
d822 3
a824 13
  PARAMS ((char *place, struct mips_cl_insn * ip, expressionS * p,
	   bfd_reloc_code_real_type *r));
static void mips_no_prev_insn
  PARAMS ((int));
static void mips_emit_delays
  PARAMS ((bfd_boolean));
#ifdef USE_STDARG
static void macro_build
  PARAMS ((char *place, int *counter, expressionS * ep, const char *name,
	   const char *fmt, ...));
#else
static void macro_build ();
#endif
d826 4
a829 22
  PARAMS ((char *, int *, expressionS *, const char *, const char *, va_list));
static void macro_build_jalr
  PARAMS ((int, expressionS *));
static void macro_build_lui
  PARAMS ((char *place, int *counter, expressionS * ep, int regnum));
static void macro_build_ldst_constoffset
  PARAMS ((char *place, int *counter, expressionS * ep, const char *op,
	   int valreg, int breg));
static void set_at
  PARAMS ((int *counter, int reg, int unsignedp));
static void check_absolute_expr
  PARAMS ((struct mips_cl_insn * ip, expressionS *));
static void load_register
  PARAMS ((int *, int, expressionS *, int));
static void load_address
  PARAMS ((int *, int, expressionS *, int *));
static void move_register
  PARAMS ((int *, int, int));
static void macro
  PARAMS ((struct mips_cl_insn * ip));
static void mips16_macro
  PARAMS ((struct mips_cl_insn * ip));
d831 1
a831 2
static void macro2
  PARAMS ((struct mips_cl_insn * ip));
d833 2
a834 4
static void mips_ip
  PARAMS ((char *str, struct mips_cl_insn * ip));
static void mips16_ip
  PARAMS ((char *str, struct mips_cl_insn * ip));
d836 2
a837 4
  PARAMS ((char *, unsigned int, int, offsetT, bfd_boolean, bfd_boolean,
	   bfd_boolean, unsigned long *, bfd_boolean *, unsigned short *));
static bfd_boolean parse_relocation
  PARAMS ((char **, bfd_reloc_code_real_type *));
d839 32
a870 77
  PARAMS ((expressionS *, bfd_reloc_code_real_type *, char *));
static void my_getExpression
  PARAMS ((expressionS *, char *));
#ifdef OBJ_ELF
static int support_64bit_objects
  PARAMS((void));
#endif
static void mips_set_option_string
  PARAMS ((const char **, const char *));
static symbolS *get_symbol
  PARAMS ((void));
static void mips_align
  PARAMS ((int to, int fill, symbolS *label));
static void s_align
  PARAMS ((int));
static void s_change_sec
  PARAMS ((int));
static void s_change_section
  PARAMS ((int));
static void s_cons
  PARAMS ((int));
static void s_float_cons
  PARAMS ((int));
static void s_mips_globl
  PARAMS ((int));
static void s_option
  PARAMS ((int));
static void s_mipsset
  PARAMS ((int));
static void s_abicalls
  PARAMS ((int));
static void s_cpload
  PARAMS ((int));
static void s_cpsetup
  PARAMS ((int));
static void s_cplocal
  PARAMS ((int));
static void s_cprestore
  PARAMS ((int));
static void s_cpreturn
  PARAMS ((int));
static void s_gpvalue
  PARAMS ((int));
static void s_gpword
  PARAMS ((int));
static void s_gpdword
  PARAMS ((int));
static void s_cpadd
  PARAMS ((int));
static void s_insn
  PARAMS ((int));
static void md_obj_begin
  PARAMS ((void));
static void md_obj_end
  PARAMS ((void));
static long get_number
  PARAMS ((void));
static void s_mips_ent
  PARAMS ((int));
static void s_mips_end
  PARAMS ((int));
static void s_mips_frame
  PARAMS ((int));
static void s_mips_mask
  PARAMS ((int));
static void s_mips_stab
  PARAMS ((int));
static void s_mips_weakext
  PARAMS ((int));
static void s_mips_file
  PARAMS ((int));
static void s_mips_loc
  PARAMS ((int));
static bfd_boolean pic_need_relax
  PARAMS ((symbolS *, asection *));
static int mips16_extended_frag
  PARAMS ((fragS *, asection *, long));
d872 1
a872 8
static int validate_mips_insn
  PARAMS ((const struct mips_opcode *));
static void show
  PARAMS ((FILE *, const char *, int *, int *));
#ifdef OBJ_ELF
static int mips_need_elf_addend_fixup
  PARAMS ((fixS *));
#endif
d885 3
a887 14
static void mips_set_architecture
  PARAMS ((const struct mips_cpu_info *));
static void mips_set_tune
  PARAMS ((const struct mips_cpu_info *));
static bfd_boolean mips_strict_matching_cpu_name_p
  PARAMS ((const char *, const char *));
static bfd_boolean mips_matching_cpu_name_p
  PARAMS ((const char *, const char *));
static const struct mips_cpu_info *mips_parse_cpu
  PARAMS ((const char *, const char *));
static const struct mips_cpu_info *mips_cpu_info_from_isa
  PARAMS ((int));
static const struct mips_cpu_info *mips_cpu_info_from_arch
  PARAMS ((int));
d980 1
a980 1
extern void pop_insert PARAMS ((const pseudo_typeS *));
d983 1
a983 1
mips_pop_insert ()
d1001 1
a1001 1
static void mips_clear_insn_labels PARAMS ((void));
d1004 1
a1004 1
mips_clear_insn_labels ()
d1043 1
a1043 1
mips_target_format ()
d1086 1
a1086 1
md_begin ()
d1101 1
a1101 1
      retval = hash_insert (op_hash, name, (PTR) &mips_opcodes[i]);
d1128 1
a1128 1
      retval = hash_insert (mips16_op_hash, name, (PTR) &mips16_opcodes[i]);
d1304 1
a1304 1
md_mips_end ()
d1311 1
a1311 2
md_assemble (str)
     char *str;
d1364 1
a1364 2
reloc_needs_lo_p (reloc)
     bfd_reloc_code_real_type reloc;
d1374 1
a1374 2
fixup_has_matching_lo_p (fixp)
     fixS *fixp;
d1386 2
a1387 4
insn_uses_reg (ip, reg, class)
     struct mips_cl_insn *ip;
     unsigned int reg;
     enum mips_regclass class;
d1464 1
a1464 2
reg_needs_delay (reg)
     unsigned int reg;
d1497 1
a1497 1
mips16_mark_labels ()
d1523 2
a1524 5
append_insn (place, ip, address_expr, reloc_type)
     char *place;
     struct mips_cl_insn *ip;
     expressionS *address_expr;
     bfd_reloc_code_real_type *reloc_type;
d2638 1
a2638 2
mips_no_prev_insn (preserve)
     int preserve;
d2667 1
a2667 2
mips_emit_delays (insns)
     bfd_boolean insns;
a2787 9
#ifdef USE_STDARG
static void
macro_build (char *place,
	     int *counter,
	     expressionS * ep,
	     const char *name,
	     const char *fmt,
	     ...)
#else
d2789 2
a2790 8
macro_build (place, counter, ep, name, fmt, va_alist)
     char *place;
     int *counter;
     expressionS *ep;
     const char *name;
     const char *fmt;
     va_dcl
#endif
a2795 1
#ifdef USE_STDARG
a2796 3
#else
  va_start (args);
#endif
d3006 3
a3008 7
mips16_macro_build (place, counter, ep, name, fmt, args)
     char *place;
     int *counter ATTRIBUTE_UNUSED;
     expressionS *ep;
     const char *name;
     const char *fmt;
     va_list args;
d3132 1
a3132 3
macro_build_jalr (icnt, ep)
     int icnt;
     expressionS *ep;
d3141 1
a3141 2
  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "jalr", "d,s",
	       RA, PIC_CALL_REG);
d3151 1
a3151 5
macro_build_lui (place, counter, ep, regnum)
     char *place;
     int *counter;
     expressionS *ep;
     int regnum;
d3217 2
a3218 6
macro_build_ldst_constoffset (place, counter, ep, op, treg, breg)
     char *place;
     int *counter;
     expressionS *ep;
     const char *op;
     int treg, breg;
d3229 2
a3230 2
      macro_build (place, counter, ep, op, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, breg);
d3242 2
a3243 2
      macro_build (place, counter, (expressionS *) NULL, ADDRESS_ADD_INSN,
		   "d,v,t", AT, AT, breg);
d3246 2
a3247 2
      macro_build (place, counter, ep, op, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, AT);
d3259 1
a3259 4
set_at (counter, reg, unsignedp)
     int *counter;
     int reg;
     int unsignedp;
d3264 2
a3265 3
    macro_build ((char *) NULL, counter, &imm_expr,
		 unsignedp ? "sltiu" : "slti",
		 "t,r,j", AT, reg, (int) BFD_RELOC_LO16);
d3269 1
a3269 2
      macro_build ((char *) NULL, counter, (expressionS *) NULL,
		   unsignedp ? "sltu" : "slt",
d3277 1
a3277 3
check_absolute_expr (ip, ex)
     struct mips_cl_insn *ip;
     expressionS *ex;
d3366 1
a3366 5
load_register (counter, reg, ep, dbl)
     int *counter;
     int reg;
     expressionS *ep;
     int dbl;
d3384 2
a3385 2
	  macro_build ((char *) NULL, counter, ep, "addiu", "t,r,j", reg, 0,
		       (int) BFD_RELOC_LO16);
d3392 2
a3393 2
	  macro_build ((char *) NULL, counter, ep, "ori", "t,r,i", reg, 0,
		       (int) BFD_RELOC_LO16);
d3409 1
a3409 2
	  macro_build ((char *) NULL, counter, ep, "lui", "t,u", reg,
		       (int) BFD_RELOC_HI16);
d3411 2
a3412 2
	    macro_build ((char *) NULL, counter, ep, "ori", "t,r,i", reg, reg,
			 (int) BFD_RELOC_LO16);
d3423 2
a3424 2
      macro_build ((char *) NULL, counter, ep, "addiu", "t,r,j", reg, 0,
		   (int) BFD_RELOC_LO16);
d3461 2
a3462 2
	      macro_build ((char *) NULL, counter, &lo32, "addiu", "t,r,j",
			   reg, 0, (int) BFD_RELOC_LO16);
d3467 2
a3468 2
	      macro_build ((char *) NULL, counter, &lo32, "lui", "t,u", reg,
			   (int) BFD_RELOC_HI16);
d3470 2
a3471 2
		macro_build ((char *) NULL, counter, &lo32, "ori", "t,r,i",
			     reg, reg, (int) BFD_RELOC_LO16);
d3505 3
a3507 4
	      macro_build ((char *) NULL, counter, &tmp,
			   "ori", "t,r,i", reg, 0,
			   (int) BFD_RELOC_LO16);
	      macro_build ((char *) NULL, counter, (expressionS *) NULL,
d3557 2
a3558 2
	      macro_build ((char *) NULL, counter, &tmp, "addiu", "t,r,j",
			   reg, 0, (int) BFD_RELOC_LO16);
d3562 1
a3562 1
		  macro_build ((char *) NULL, counter, (expressionS *) NULL,
d3567 1
a3567 1
	      macro_build ((char *) NULL, counter, (expressionS *) NULL,
d3586 1
a3586 2
	  macro_build ((char *) NULL, counter, (expressionS *) NULL,
		       "dsll32", "d,w,<", reg, freg, 0);
d3596 3
a3598 4
	  macro_build ((char *) NULL, counter, &lo32, "lui", "t,u", reg,
		       (int) BFD_RELOC_HI16);
	  macro_build ((char *) NULL, counter, (expressionS *) NULL,
		       "dsrl32", "d,w,<", reg, reg, 0);
d3604 1
a3604 2
	  macro_build ((char *) NULL, counter, (expressionS *) NULL, "dsll",
		       "d,w,<", reg, freg, 16);
d3609 3
a3611 4
      macro_build ((char *) NULL, counter, &mid16, "ori", "t,r,i", reg,
		   freg, (int) BFD_RELOC_LO16);
      macro_build ((char *) NULL, counter, (expressionS *) NULL, "dsll",
		   "d,w,<", reg, reg, 16);
d3615 2
a3616 2
    macro_build ((char *) NULL, counter, &lo32, "ori", "t,r,i", reg, freg,
		 (int) BFD_RELOC_LO16);
d3622 1
a3622 5
load_address (counter, reg, ep, used_at)
     int *counter;
     int reg;
     expressionS *ep;
     int *used_at;
d3673 1
a3673 1
			   reg, (int) BFD_RELOC_MIPS_HIGHEST);
d3675 1
a3675 1
			   AT, (int) BFD_RELOC_HI16_S);
d3677 1
a3677 1
			   reg, reg, (int) BFD_RELOC_MIPS_HIGHER);
d3679 3
a3681 5
			   AT, AT, (int) BFD_RELOC_LO16);
	      macro_build (p, counter, (expressionS *) NULL, "dsll32",
			   "d,w,<", reg, reg, 0);
	      macro_build (p, counter, (expressionS *) NULL, "daddu",
			   "d,v,t", reg, reg, AT);
d3687 1
a3687 1
			   reg, (int) BFD_RELOC_MIPS_HIGHEST);
d3689 2
a3690 3
			   reg, reg, (int) BFD_RELOC_MIPS_HIGHER);
	      macro_build (p, counter, (expressionS *) NULL, "dsll",
			   "d,w,<", reg, reg, 16);
d3692 2
a3693 3
			   reg, reg, (int) BFD_RELOC_HI16_S);
	      macro_build (p, counter, (expressionS *) NULL, "dsll",
			   "d,w,<", reg, reg, 16);
d3695 1
a3695 1
			   reg, reg, (int) BFD_RELOC_LO16);
d3704 2
a3705 3
	      macro_build ((char *) NULL, counter, ep, ADDRESS_ADDI_INSN,
			   "t,r,j", reg, mips_gp_register,
			   (int) BFD_RELOC_GPREL16);
d3714 2
a3715 2
	  macro_build (p, counter, ep, ADDRESS_ADDI_INSN,
		       "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d3743 2
a3744 3
	      macro_build ((char *) NULL, counter, ep, ADDRESS_LOAD_INSN,
			   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT_DISP,
			   mips_gp_register);
d3748 2
a3749 2
	      macro_build ((char *) NULL, counter, &ex, ADDRESS_ADDI_INSN,
			   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d3753 1
a3753 1
			    ep->X_add_symbol, 0, (char *) NULL);
d3758 1
a3758 1
		       (int) BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);
d3773 2
a3774 2
	  macro_build ((char *) NULL, counter, ep, ADDRESS_LOAD_INSN,
		       "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16,
d3776 1
a3776 1
	  macro_build ((char *) NULL, counter, (expressionS *) NULL, "nop", "");
d3779 3
a3781 3
			ep->X_add_symbol, (offsetT) 0, (char *) NULL);
	  macro_build (p, counter, ep, ADDRESS_ADDI_INSN,
		       "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d3788 2
a3789 2
	      macro_build ((char *) NULL, counter, &ex, ADDRESS_ADDI_INSN,
			   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d3821 6
a3826 6
	  macro_build ((char *) NULL, counter, ep, "lui", "t,u", reg,
		       (int) BFD_RELOC_MIPS_GOT_HI16);
	  macro_build ((char *) NULL, counter, (expressionS *) NULL,
		       ADDRESS_ADD_INSN, "d,v,t", reg, reg, mips_gp_register);
	  macro_build ((char *) NULL, counter, ep, ADDRESS_LOAD_INSN,
		       "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT_LO16, reg);
d3832 2
a3833 2
	      macro_build ((char *) NULL, counter, &ex, ADDRESS_ADDI_INSN,
			   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d3840 1
a3840 1
			ep->X_add_symbol, 0, (char *) NULL);
d3842 3
a3844 3
		       (int) BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
	  macro_build (p + 4, counter, ep, ADDRESS_ADDI_INSN, "t,r,j",
		       reg, reg, (int) BFD_RELOC_MIPS_GOT_OFST);
d3855 6
a3860 6
	  macro_build ((char *) NULL, counter, ep, "lui", "t,u", reg,
		       (int) BFD_RELOC_MIPS_GOT_HI16);
	  macro_build ((char *) NULL, counter, (expressionS *) NULL,
		       ADDRESS_ADD_INSN, "d,v,t", reg, reg, mips_gp_register);
	  macro_build ((char *) NULL, counter, ep, ADDRESS_LOAD_INSN,
		       "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT_LO16, reg);
d3871 1
a3871 1
	      macro_build (p, counter, (expressionS *) NULL, "nop", "");
d3875 1
a3875 1
		       (int) BFD_RELOC_MIPS_GOT16, mips_gp_register);
d3877 1
a3877 1
	  macro_build (p, counter, (expressionS *) NULL, "nop", "");
d3879 2
a3880 2
	  macro_build (p, counter, ep, ADDRESS_ADDI_INSN,
		       "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d3887 2
a3888 2
	      macro_build ((char *) NULL, counter, &ex, ADDRESS_ADDI_INSN,
			   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d3897 2
a3898 2
      macro_build ((char *) NULL, counter, ep, ADDRESS_ADDI_INSN,
		   "t,r,j", reg, mips_gp_register, (int) BFD_RELOC_GPREL16);
d3907 1
a3907 4
move_register (counter, dest, source)
     int *counter;
     int dest;
     int source;
d3909 1
a3909 2
  macro_build ((char *) NULL, counter, (expressionS *) NULL,
	       HAVE_32BIT_GPRS ? "addu" : "daddu",
d3932 1
a3932 2
macro (ip)
     struct mips_cl_insn *ip;
d4004 1
a4004 1
      macro_build ((char *) NULL, &icnt, &expr1, "bgez", "s,p", sreg);
d4006 1
a4006 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "",
		     0);
d4009 2
a4010 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "dsub" : "sub", "d,v,t", dreg, 0, sreg);
d4037 2
a4038 2
	  macro_build ((char *) NULL, &icnt, &imm_expr, s, "t,r,j", treg, sreg,
		       (int) BFD_RELOC_LO16);
d4042 1
a4042 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s2, "d,v,t",
		   treg, sreg, AT);
d4066 2
a4067 2
	    macro_build ((char *) NULL, &icnt, &imm_expr, s, "t,r,i", treg,
			 sreg, (int) BFD_RELOC_LO16);
d4070 3
a4072 4
	      macro_build ((char *) NULL, &icnt, &imm_expr, "ori", "t,r,i",
			   treg, sreg, (int) BFD_RELOC_LO16);
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nor",
			   "d,v,t", treg, treg, 0);
d4078 1
a4078 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s2, "d,v,t",
		   treg, sreg, AT);
d4097 1
a4097 2
	  macro_build ((char *) NULL, &icnt, &offset_expr, s, "s,t,p", sreg,
		       0);
d4101 1
a4101 1
      macro_build ((char *) NULL, &icnt, &offset_expr, s, "s,t,p", sreg, AT);
d4109 2
a4110 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bgezl" : "bgez", "s,p", sreg);
d4115 2
a4116 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "blezl" : "blez", "s,p", treg);
d4119 3
a4121 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "slt", "d,v,t",
		   AT, sreg, treg);
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "beql" : "beq", "s,t,p", AT, 0);
d4147 1
a4147 2
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop",
			   "", 0);
d4154 1
a4154 2
	      macro_build ((char *) NULL, &icnt, &offset_expr, "bnel",
			   "s,t,p", 0, 0);
d4168 2
a4169 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bgezl" : "bgez", "s,p", sreg);
d4174 2
a4175 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bgtzl" : "bgtz", "s,p", sreg);
d4194 1
a4194 1
	  macro_build ((char *) NULL, &icnt, &offset_expr, "b", "p");
d4198 2
a4199 2
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "beql" : "beq", "s,t,p", AT, 0);
d4209 2
a4210 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "beql" : "beq", "s,t,p", 0, treg);
d4213 3
a4215 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		   "d,v,t", AT, sreg, treg);
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "beql" : "beq", "s,t,p", AT, 0);
d4238 2
a4239 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bnel" : "bne", "s,t,p", sreg, 0);
d4243 2
a4244 2
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "beql" : "beq", "s,t,p", AT, 0);
d4252 2
a4253 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bgtzl" : "bgtz", "s,p", sreg);
d4258 2
a4259 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bltzl" : "bltz", "s,p", treg);
d4262 3
a4264 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "slt", "d,v,t",
		   AT, treg, sreg);
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "bnel" : "bne", "s,t,p", AT, 0);
d4272 2
a4273 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bnel" : "bne", "s,t,p", sreg, 0);
d4278 3
a4280 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		   "d,v,t", AT, treg, sreg);
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "bnel" : "bne", "s,t,p", AT, 0);
d4288 2
a4289 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "blezl" : "blez", "s,p", sreg);
d4294 2
a4295 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bgezl" : "bgez", "s,p", treg);
d4298 3
a4300 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "slt", "d,v,t",
		   AT, treg, sreg);
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "beql" : "beq", "s,t,p", AT, 0);
d4328 2
a4329 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bltzl" : "bltz", "s,p", sreg);
d4334 2
a4335 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "blezl" : "blez", "s,p", sreg);
d4339 2
a4340 2
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "bnel" : "bne", "s,t,p", AT, 0);
d4348 2
a4349 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "beql" : "beq", "s,t,p", sreg, 0);
d4354 3
a4356 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		   "d,v,t", AT, treg, sreg);
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "beql" : "beq", "s,t,p", AT, 0);
d4379 1
a4379 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "beql" : "beq",
d4384 2
a4385 2
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "bnel" : "bne", "s,t,p", AT, 0);
d4393 2
a4394 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bltzl" : "bltz", "s,p", sreg);
d4399 2
a4400 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bgtzl" : "bgtz", "s,p", treg);
d4403 3
a4405 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "slt", "d,v,t",
		   AT, sreg, treg);
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "bnel" : "bne", "s,t,p", AT, 0);
d4415 2
a4416 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       likely ? "bnel" : "bne", "s,t,p", 0, treg);
d4419 3
a4421 5
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		   "d,v,t", AT, sreg,
		   treg);
      macro_build ((char *) NULL, &icnt, &offset_expr,
		   likely ? "bnel" : "bne", "s,t,p", AT, 0);
d4438 1
a4438 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "teq",
			 "s,t,q", 0, 0, 7);
d4440 1
a4440 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break",
			 "c", 7);
d4449 3
a4451 4
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "teq",
		       "s,t,q", treg, 0, 7);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       dbl ? "ddiv" : "div", "z,s,t", sreg, treg);
d4456 4
a4459 5
	  macro_build ((char *) NULL, &icnt, &expr1, "bne", "s,t,p", treg, 0);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       dbl ? "ddiv" : "div", "z,s,t", sreg, treg);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break",
		       "c", 7);
d4462 2
a4463 3
      macro_build ((char *) NULL, &icnt, &expr1,
		   dbl ? "daddiu" : "addiu",
		   "t,r,j", AT, 0, (int) BFD_RELOC_LO16);
d4465 1
a4465 1
      macro_build ((char *) NULL, &icnt, &expr1, "bne", "s,t,p", treg, AT);
d4469 3
a4471 4
	  macro_build ((char *) NULL, &icnt, &expr1, "daddiu", "t,r,j", AT, 0,
		       (int) BFD_RELOC_LO16);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsll32",
		       "d,w,<", AT, AT, 31);
d4476 2
a4477 2
	  macro_build ((char *) NULL, &icnt, &expr1, "lui", "t,u", AT,
		       (int) BFD_RELOC_HI16);
d4481 1
a4481 2
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "teq",
		       "s,t,q", sreg, AT, 6);
d4489 2
a4490 3
	  macro_build ((char *) NULL, &icnt, &expr1, "bne", "s,t,p", sreg, AT);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "",
		       0);
d4496 1
a4496 2
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break",
		       "c", 6);
d4498 1
a4498 1
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "d", dreg);
d4541 1
a4541 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "teq",
			 "s,t,q", 0, 0, 7);
d4543 1
a4543 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break",
			 "c", 7);
d4560 2
a4561 2
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   dbl ? "dneg" : "neg", "d,w", dreg, sreg);
d4569 2
a4570 3
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "z,s,t",
		   sreg, AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s2, "d", dreg);
d4594 2
a4595 4
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "teq",
		       "s,t,q", treg, 0, 7);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "z,s,t",
		       sreg, treg);
d4603 2
a4604 3
	  macro_build ((char *) NULL, &icnt, &expr1, "bne", "s,t,p", treg, 0);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "z,s,t",
		       sreg, treg);
d4609 1
a4609 2
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break",
		       "c", 7);
d4611 1
a4611 1
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s2, "d", dreg);
d4630 1
a4630 1
	  macro_build ((char *) NULL, &icnt, &offset_expr,
d4632 1
a4632 1
		       "t,r,j", treg, sreg, (int) BFD_RELOC_LO16);
d4672 2
a4673 2
	      macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
			   tempreg, (int) BFD_RELOC_PCREL_HI16_S);
d4677 3
a4679 3
	      macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
			   tempreg, (int) BFD_RELOC_PCREL_HI16_S);
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
d4683 1
a4683 1
	  macro_build ((char *) NULL, &icnt, &offset_expr,
d4685 1
a4685 1
		       "t,r,j", treg, tempreg, (int) BFD_RELOC_PCREL_LO16);
d4739 1
a4739 1
			       tempreg, (int) BFD_RELOC_MIPS_HIGHEST);
d4741 1
a4741 1
			       AT, (int) BFD_RELOC_HI16_S);
d4743 1
a4743 1
			       tempreg, tempreg, (int) BFD_RELOC_MIPS_HIGHER);
d4745 5
a4749 5
			       AT, AT, (int) BFD_RELOC_LO16);
		  macro_build (p, &icnt, (expressionS *) NULL, "dsll32",
			       "d,w,<", tempreg, tempreg, 0);
		  macro_build (p, &icnt, (expressionS *) NULL, "daddu",
			       "d,v,t", tempreg, tempreg, AT);
d4755 1
a4755 1
			       tempreg, (int) BFD_RELOC_MIPS_HIGHEST);
d4757 2
a4758 2
			       tempreg, tempreg, (int) BFD_RELOC_MIPS_HIGHER);
		  macro_build (p, &icnt, (expressionS *) NULL, "dsll", "d,w,<",
d4761 2
a4762 2
			       tempreg, tempreg, (int) BFD_RELOC_HI16_S);
		  macro_build (p, &icnt, (expressionS *) NULL, "dsll", "d,w,<",
d4765 1
a4765 1
			       tempreg, tempreg, (int) BFD_RELOC_LO16);
d4774 3
a4776 3
		  macro_build ((char *) NULL, &icnt, &offset_expr,
			       ADDRESS_ADDI_INSN, "t,r,j", tempreg,
			       mips_gp_register, (int) BFD_RELOC_GPREL16);
d4786 1
a4786 1
			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
d4828 2
a4829 2
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", tempreg, lw_reloc_type, mips_gp_register);
d4842 1
a4842 2
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       "nop", "");
d4853 1
a4853 1
		  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d4857 1
a4857 1
			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
d4865 3
a4867 4
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   "nop", "");
	      macro_build ((char *) NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
d4887 3
a4889 4
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       "nop", "");
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t", treg, AT, breg);
d4902 4
a4905 4
	      macro_build ((char *) NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			   "t,r,j", AT, AT, (int) BFD_RELOC_LO16);
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg, AT);
d4950 3
a4952 3
	      macro_build ((char *) NULL, &icnt, &offset_expr,
			   ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   lw_reloc_type, mips_gp_register);
d4957 2
a4958 3
		  macro_build ((char *) NULL, &icnt, &expr1,
			       ADDRESS_ADDI_INSN, "t,r,j", tempreg, tempreg,
			       (int) BFD_RELOC_LO16);
d4979 2
a4980 2
		      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
				   ADDRESS_ADD_INSN, "d,v,t", treg, AT, breg);
d4985 5
a4989 6
		  macro_build_lui ((char *) NULL, &icnt, &expr1, AT);
		  macro_build ((char *) NULL, &icnt, &expr1,
			       ADDRESS_ADDI_INSN, "t,r,j", AT, AT,
			       (int) BFD_RELOC_LO16);
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t", dreg, dreg, AT);
d5004 1
a5004 1
			   "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT_DISP,
d5008 1
a5008 2
		  macro_build (p + 4, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t",
d5016 3
a5018 3
	      macro_build ((char *) NULL, &icnt, &offset_expr,
			   ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   lw_reloc_type, mips_gp_register);
d5094 1
a5094 1
	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
d5096 4
a5099 5
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg,
		       mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", tempreg, lw_reloc_type, tempreg);
d5111 1
a5111 2
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       "nop", "");
d5126 3
a5128 4
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   "nop", "");
	      macro_build ((char *) NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
d5156 3
a5158 4
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       "nop", "");
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t", treg, AT, breg);
d5170 4
a5173 4
	      macro_build ((char *) NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			   "t,r,j", AT, AT, (int) BFD_RELOC_LO16);
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   ADDRESS_ADD_INSN, "d,v,t", dreg, dreg, AT);
d5190 1
a5190 1
	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d5200 1
a5200 1
	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d5203 1
a5203 1
			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
d5217 1
a5217 1
		  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d5219 2
a5220 2
		  macro_build (p, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t", treg, AT, breg);
d5230 2
a5231 2
	      macro_build (p, &icnt, &expr1, ADDRESS_ADDI_INSN,
			   "t,r,j", AT, AT, (int) BFD_RELOC_LO16);
d5233 2
a5234 2
	      macro_build (p, &icnt, (expressionS *) NULL, ADDRESS_ADD_INSN,
			   "d,v,t", tempreg, tempreg, AT);
d5287 1
a5287 1
	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
d5289 3
a5291 4
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg,
		       mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
d5304 2
a5305 3
	      macro_build ((char *) NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			   "t,r,j", tempreg, tempreg,
			   (int) BFD_RELOC_LO16);
d5327 2
a5328 2
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t", treg, AT, breg);
d5335 5
a5339 5
	      macro_build_lui ((char *) NULL, &icnt, &expr1, AT);
	      macro_build ((char *) NULL, &icnt, &expr1, ADDRESS_ADDI_INSN,
			   "t,r,j", AT, AT, (int) BFD_RELOC_LO16);
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   ADDRESS_ADD_INSN, "d,v,t", dreg, dreg, AT);
d5356 1
a5356 2
		       tempreg, (int) BFD_RELOC_MIPS_GOT_PAGE,
		       mips_gp_register);
d5358 1
a5358 1
		       tempreg, tempreg, (int) BFD_RELOC_MIPS_GOT_OFST);
d5361 2
a5362 2
	      macro_build (p + 8, &icnt, (expressionS *) NULL,
			   ADDRESS_ADD_INSN, "d,v,t", treg, tempreg, breg);
d5372 2
a5373 3
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
		        "t,r,j", tempreg, mips_gp_register,
		       (int) BFD_RELOC_GPREL16);
d5387 1
a5387 2
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s,
		       "d,v,t", treg, tempreg, breg);
d5400 1
a5400 1
	macro_build ((char *) NULL, &icnt, &offset_expr, "j", "a");
d5402 1
a5402 1
	macro_build ((char *) NULL, &icnt, &offset_expr, "b", "p");
d5414 1
a5414 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "jalr",
		     "d,s", dreg, sreg);
d5420 1
a5420 2
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "jalr",
		       "d,s", dreg, sreg);
d5440 1
a5440 1
  		  macro_build_ldst_constoffset ((char *) NULL, &icnt, &expr1,
d5454 1
a5454 1
	macro_build ((char *) NULL, &icnt, &offset_expr, "jal", "a");
d5492 2
a5493 3
		  macro_build ((char *) NULL, &icnt, &offset_expr,
			       ADDRESS_LOAD_INSN, "t,o(b)", PIC_CALL_REG,
			       (int) BFD_RELOC_MIPS_CALL16,
d5502 7
a5508 9
		  macro_build ((char *) NULL, &icnt, &offset_expr, "lui",
			       "t,u", PIC_CALL_REG,
			       (int) BFD_RELOC_MIPS_CALL_HI16);
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t", PIC_CALL_REG,
			       PIC_CALL_REG, mips_gp_register);
		  macro_build ((char *) NULL, &icnt, &offset_expr,
			       ADDRESS_LOAD_INSN, "t,o(b)", PIC_CALL_REG,
			       (int) BFD_RELOC_MIPS_CALL_LO16, PIC_CALL_REG);
d5514 1
a5514 2
			       (int) BFD_RELOC_MIPS_GOT_PAGE,
			       mips_gp_register);
d5517 1
a5517 1
			       (int) BFD_RELOC_MIPS_GOT_OFST);
d5527 4
a5530 5
		  macro_build ((char *) NULL, &icnt, &offset_expr,
			       ADDRESS_LOAD_INSN, "t,o(b)", PIC_CALL_REG,
			       (int) BFD_RELOC_MIPS_CALL16, mips_gp_register);
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       "nop", "");
d5543 8
a5550 11
		  macro_build ((char *) NULL, &icnt, &offset_expr, "lui",
			       "t,u", PIC_CALL_REG,
			       (int) BFD_RELOC_MIPS_CALL_HI16);
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t", PIC_CALL_REG,
			       PIC_CALL_REG, mips_gp_register);
		  macro_build ((char *) NULL, &icnt, &offset_expr,
			       ADDRESS_LOAD_INSN, "t,o(b)", PIC_CALL_REG,
			       (int) BFD_RELOC_MIPS_CALL_LO16, PIC_CALL_REG);
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       "nop", "");
d5557 1
a5557 1
		      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d5561 2
a5562 2
			       "t,o(b)", PIC_CALL_REG,
			       (int) BFD_RELOC_MIPS_GOT16, mips_gp_register);
d5564 1
a5564 1
		  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d5569 1
a5569 1
			   (int) BFD_RELOC_LO16);
d5589 1
a5589 2
		    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
				 "nop", "");
d5591 1
a5591 1
  		  macro_build_ldst_constoffset ((char *) NULL, &icnt, &expr1,
d5600 1
a5600 1
	  macro_build ((char *) NULL, &icnt, &offset_expr, "bal", "p");
d5810 3
a5812 3
          macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
                       tempreg, (int) BFD_RELOC_PCREL_HI16_S);
          macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
d5817 2
a5818 2
          macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt, treg,
                       (int) BFD_RELOC_PCREL_LO16, tempreg);
d5929 1
a5929 1
			       tempreg, (int) BFD_RELOC_MIPS_HIGHEST);
d5931 1
a5931 1
			       AT, (int) BFD_RELOC_HI16_S);
d5933 1
a5933 1
			       tempreg, tempreg, (int) BFD_RELOC_MIPS_HIGHER);
d5935 8
a5942 8
		    macro_build (p, &icnt, (expressionS *) NULL, "daddu",
				 "d,v,t", AT, AT, breg);
		  macro_build (p, &icnt, (expressionS *) NULL, "dsll32",
			       "d,w,<", tempreg, tempreg, 0);
		  macro_build (p, &icnt, (expressionS *) NULL, "daddu",
			       "d,v,t", tempreg, tempreg, AT);
		  macro_build (p, &icnt, &offset_expr, s,
			       fmt, treg, (int) BFD_RELOC_LO16, tempreg);
d5948 1
a5948 1
			       tempreg, (int) BFD_RELOC_MIPS_HIGHEST);
d5950 3
a5952 3
			       tempreg, tempreg, (int) BFD_RELOC_MIPS_HIGHER);
		  macro_build (p, &icnt, (expressionS *) NULL, "dsll",
			       "d,w,<", tempreg, tempreg, 16);
d5954 3
a5956 3
			       tempreg, tempreg, (int) BFD_RELOC_HI16_S);
		  macro_build (p, &icnt, (expressionS *) NULL, "dsll",
			       "d,w,<", tempreg, tempreg, 16);
d5958 4
a5961 4
		    macro_build (p, &icnt, (expressionS *) NULL, "daddu",
				 "d,v,t", tempreg, tempreg, breg);
		  macro_build (p, &icnt, &offset_expr, s,
			       fmt, treg, (int) BFD_RELOC_LO16, tempreg);
d5979 2
a5980 3
		  macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
			       treg, (int) BFD_RELOC_GPREL16,
			       mips_gp_register);
d5993 1
a5993 1
			   (int) BFD_RELOC_LO16, tempreg);
d6003 4
a6006 5
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t", tempreg, breg,
			       mips_gp_register);
		  macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
			       treg, (int) BFD_RELOC_GPREL16, tempreg);
d6014 2
a6015 2
	      macro_build (p, &icnt, (expressionS *) NULL, ADDRESS_ADD_INSN,
			   "d,v,t", tempreg, tempreg, breg);
d6019 1
a6019 1
			   (int) BFD_RELOC_LO16, tempreg);
d6050 3
a6052 3
	      macro_build ((char *) NULL, &icnt, &offset_expr,
			   ADDRESS_LOAD_INSN, "t,o(b)", tempreg,
			   BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
d6054 4
a6057 5
		macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			     ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg,
			     breg);
	      macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt, treg,
			   (int) BFD_RELOC_MIPS_GOT_OFST, tempreg);
d6070 3
a6072 4
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", tempreg, (int) lw_reloc_type,
		       mips_gp_register);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
d6077 1
a6077 1
		       "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
d6079 4
a6082 4
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			 ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg, breg);
	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt, treg,
		       (int) BFD_RELOC_LO16, tempreg);
d6116 6
a6121 8
	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
		       tempreg, (int) BFD_RELOC_MIPS_GOT_HI16);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg,
		       mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT_LO16,
		       tempreg);
d6127 1
a6127 1
	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d6130 2
a6131 3
	  macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16,
		       mips_gp_register);
d6133 1
a6133 1
	  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d6135 2
a6136 2
	  macro_build (p, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
		       "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
d6138 4
a6141 4
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			 ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg, breg);
	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt, treg,
		       (int) BFD_RELOC_LO16, tempreg);
d6164 10
a6173 7
	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
		       tempreg, (int) BFD_RELOC_MIPS_GOT_HI16);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg,
		       mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT_LO16,
a6174 5
	  if (breg != 0)
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			 ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg, breg);
	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt, treg,
		       (int) BFD_RELOC_LO16, tempreg);
d6182 1
a6182 2
		       tempreg, (int) BFD_RELOC_MIPS_GOT_PAGE,
		       mips_gp_register);
d6184 2
a6185 2
	    macro_build (p + 4, &icnt, (expressionS *) NULL,
			 ADDRESS_ADD_INSN, "d,v,t", tempreg, tempreg, breg);
d6187 1
a6187 1
		       (int) BFD_RELOC_MIPS_GOT_OFST, tempreg);
d6200 2
a6201 2
	      macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
			   treg, (int) BFD_RELOC_GPREL16, mips_gp_register);
d6206 4
a6209 5
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   ADDRESS_ADD_INSN, "d,v,t", tempreg, breg,
			   mips_gp_register);
	      macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
			   treg, (int) BFD_RELOC_GPREL16, tempreg);
d6233 1
a6233 2
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       "mtc1", "t,G", AT, treg);
d6243 2
a6244 2
	  macro_build ((char *) NULL, &icnt, &offset_expr, "lwc1", "T,o(b)",
		       treg, (int) BFD_RELOC_MIPS_LITERAL, mips_gp_register);
d6296 2
a6297 3
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16,
		       mips_gp_register);
d6303 2
a6304 3
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_ADDI_INSN,
		       "t,r,j", AT, mips_gp_register,
		       (int) BFD_RELOC_GPREL16);
d6313 2
a6314 2
	macro_build ((char *) NULL, &icnt, &offset_expr, "ld", "t,o(b)",
		     treg, (int) BFD_RELOC_LO16, AT);
d6317 2
a6318 2
	  macro_build ((char *) NULL, &icnt, &offset_expr, "lw", "t,o(b)",
		       treg, (int) BFD_RELOC_LO16, AT);
d6324 2
a6325 2
	      macro_build ((char *) NULL, &icnt, &offset_expr, "lw", "t,o(b)",
			   treg + 1, (int) BFD_RELOC_LO16, AT);
d6348 1
a6348 2
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   "dmtc1", "t,S", AT, treg);
d6352 1
a6352 2
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   "mtc1", "t,G", AT, treg + 1);
d6354 1
a6354 2
		macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			     "mtc1", "t,G", 0, treg);
d6359 1
a6359 2
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       "mtc1", "t,G", AT, treg);
d6372 2
a6373 3
	      macro_build ((char *) NULL, &icnt, &offset_expr, "ldc1",
			   "T,o(b)", treg, (int) BFD_RELOC_MIPS_LITERAL,
			   mips_gp_register);
d6384 3
a6386 3
	    macro_build ((char *) NULL, &icnt, &offset_expr,
			 ADDRESS_LOAD_INSN, "t,o(b)", AT,
			 (int) BFD_RELOC_MIPS_GOT16, mips_gp_register);
d6395 2
a6396 2
	      macro_build ((char *) NULL, &icnt, &offset_expr, "ldc1",
			   "T,o(b)", treg, (int) BFD_RELOC_LO16, AT);
d6421 2
a6422 3
      macro_build ((char *) NULL, &icnt, &offset_expr, "lwc1", "T,o(b)",
		   target_big_endian ? treg + 1 : treg,
		   (int) r, breg);
d6426 2
a6427 3
      macro_build ((char *) NULL, &icnt, &offset_expr, "lwc1", "T,o(b)",
		   target_big_endian ? treg : treg + 1,
		   (int) r, breg);
d6566 2
a6567 3
		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			       ADDRESS_ADD_INSN, "d,v,t", AT, breg,
			       mips_gp_register);
d6574 1
a6574 1
	      macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
d6576 1
a6576 1
			   (int) BFD_RELOC_GPREL16, tempreg);
d6584 1
a6584 1
	      macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
d6586 1
a6586 1
			   (int) BFD_RELOC_GPREL16, tempreg);
d6620 2
a6621 2
	      macro_build (p, &icnt, (expressionS *) NULL, ADDRESS_ADD_INSN,
			   "d,v,t", AT, breg, AT);
d6628 1
a6628 1
		       (int) BFD_RELOC_LO16, AT);
d6636 1
a6636 1
		       (int) BFD_RELOC_LO16, AT);
d6666 3
a6668 4
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16,
		       mips_gp_register);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
d6670 2
a6671 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			 ADDRESS_ADD_INSN, "d,v,t", AT, breg, AT);
d6673 2
a6674 3
	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt,
		       coproc ? treg + 1 : treg,
		       (int) BFD_RELOC_LO16, AT);
d6682 2
a6683 3
	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt,
		       coproc ? treg : treg + 1,
		       (int) BFD_RELOC_LO16, AT);
d6725 7
a6731 7
	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
		       AT, (int) BFD_RELOC_MIPS_GOT_HI16);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       ADDRESS_ADD_INSN, "d,v,t", AT, AT, mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT_LO16, AT);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
d6733 2
a6734 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			 ADDRESS_ADD_INSN, "d,v,t", AT, breg, AT);
d6736 2
a6737 3
	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt,
		       coproc ? treg + 1 : treg,
		       (int) BFD_RELOC_LO16, AT);
d6745 2
a6746 3
	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt,
		       coproc ? treg : treg + 1,
		       (int) BFD_RELOC_LO16, AT);
d6756 1
a6756 1
	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d6759 2
a6760 3
	  macro_build (p, &icnt, &offset_expr, ADDRESS_LOAD_INSN,
		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16,
		       mips_gp_register);
d6762 1
a6762 1
	  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
d6766 2
a6767 2
	      macro_build (p, &icnt, (expressionS *) NULL, ADDRESS_ADD_INSN,
			   "d,v,t", AT, breg, AT);
d6771 2
a6772 3
	  macro_build (p, &icnt, &expr1, s, fmt,
		       coproc ? treg + 1 : treg,
		       (int) BFD_RELOC_LO16, AT);
d6781 2
a6782 3
	  macro_build (p, &icnt, &expr1, s, fmt,
		       coproc ? treg : treg + 1,
		       (int) BFD_RELOC_LO16, AT);
d6802 2
a6803 3
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   ADDRESS_ADD_INSN, "d,v,t", AT, breg,
			   mips_gp_register);
d6809 1
a6809 1
	  macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
d6811 1
a6811 1
		       (int) BFD_RELOC_GPREL16, tempreg);
d6814 1
a6814 1
	  macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
d6816 1
a6816 1
		       (int) BFD_RELOC_GPREL16, tempreg);
d6833 2
a6834 2
      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, breg);
d6836 2
a6837 2
      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg + 1,
		   (int) BFD_RELOC_LO16, breg);
d6871 1
a6871 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "C",
		   ip->insn_opcode);
d6894 1
a6894 1
	  macro_build ((char *) NULL, &icnt, &immed_expr, s, "C");
d6905 1
a6905 2
macro2 (ip)
     struct mips_cl_insn *ip;
d6943 3
a6945 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "dmultu" : "multu", "s,t", sreg, treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "mflo", "d",
		   dreg);
d6955 3
a6957 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "dmult" : "mult", "s,t", sreg, AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "mflo", "d",
		   dreg);
d6975 6
a6980 8
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "dmult" : "mult", "s,t", sreg, imm ? AT : treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "mflo", "d",
		   dreg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "dsra32" : "sra", "d,w,<", dreg, dreg, RA);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "mfhi", "d",
		   AT);
d6982 1
a6982 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "tne",
		     "s,t,q", dreg, AT, 6);
d6986 3
a6988 6
	  macro_build ((char *) NULL, &icnt, &expr1, "beq", "s,t,p", dreg,
		       AT);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "",
		       0);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break",
		       "c", 6);
d6991 1
a6991 1
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "mflo", "d", dreg);
d7009 4
a7012 7
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "dmultu" : "multu",
		   "s,t", sreg, imm ? AT : treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "mfhi", "d",
		   AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "mflo", "d",
		   dreg);
d7014 1
a7014 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "tne",
		     "s,t,q", AT, 0, 6);
d7018 3
a7020 5
	  macro_build ((char *) NULL, &icnt, &expr1, "beq", "s,t,p", AT, 0);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "",
		       0);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break",
		       "c", 6);
d7038 3
a7040 4
	  macro_build ((char *) NULL, &icnt, NULL, "dnegu",
		       "d,w", tempreg, treg);
	  macro_build ((char *) NULL, &icnt, NULL, "drorv",
		       "d,t,s", dreg, sreg, tempreg);
d7045 4
a7048 8
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsubu",
		   "d,v,t", AT, 0, treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrlv",
		   "d,t,s", AT, sreg, AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsllv",
		   "d,t,s", dreg, sreg, treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		   "d,v,t", dreg, dreg, AT);
d7064 3
a7066 4
	  macro_build ((char *) NULL, &icnt, NULL, "negu",
		       "d,w", tempreg, treg);
	  macro_build ((char *) NULL, &icnt, NULL, "rorv",
		       "d,t,s", dreg, sreg, tempreg);
d7071 4
a7074 8
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "subu",
		   "d,v,t", AT, 0, treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srlv",
		   "d,t,s", AT, sreg, AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sllv",
		   "d,t,s", dreg, sreg, treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		   "d,v,t", dreg, dreg, AT);
d7089 2
a7090 2
	      macro_build ((char *) NULL, &icnt, NULL, "dror32",
			   "d,w,<", dreg, sreg, rot - 32);
d7092 2
a7093 2
	      macro_build ((char *) NULL, &icnt, NULL, "dror",
			   "d,w,<", dreg, sreg, rot);
d7098 1
a7098 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrl",
			 "d,w,<", dreg, sreg, 0);
d7104 4
a7107 6
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
		     "d,w,<", AT, sreg, rot);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		     "d,v,t", dreg, dreg, AT);
d7120 2
a7121 2
	    macro_build ((char *) NULL, &icnt, NULL, "ror",
			 "d,w,<", dreg, sreg, (32 - rot) & 0x1f);
d7126 1
a7126 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
			 "d,w,<", dreg, sreg, 0);
d7129 4
a7132 6
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
		     "d,w,<", AT, sreg, rot);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		     "d,v,t", dreg, dreg, AT);
d7139 1
a7139 2
	  macro_build ((char *) NULL, &icnt, NULL, "drorv",
		       "d,t,s", dreg, sreg, treg);
d7142 4
a7145 8
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsubu",
		   "d,v,t", AT, 0, treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsllv",
		   "d,t,s", AT, sreg, AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrlv",
		   "d,t,s", dreg, sreg, treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		   "d,v,t", dreg, dreg, AT);
d7151 1
a7151 2
	  macro_build ((char *) NULL, &icnt, NULL, "rorv",
		       "d,t,s", dreg, sreg, treg);
d7154 4
a7157 8
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "subu",
		   "d,v,t", AT, 0, treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sllv",
		   "d,t,s", AT, sreg, AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srlv",
		   "d,t,s", dreg, sreg, treg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		   "d,v,t", dreg, dreg, AT);
d7171 2
a7172 2
	      macro_build ((char *) NULL, &icnt, NULL, "dror32",
			   "d,w,<", dreg, sreg, rot - 32);
d7174 2
a7175 2
	      macro_build ((char *) NULL, &icnt, NULL, "dror",
			   "d,w,<", dreg, sreg, rot);
d7180 1
a7180 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrl",
			 "d,w,<", dreg, sreg, 0);
d7186 4
a7189 6
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
		     "d,w,<", AT, sreg, rot);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		     "d,v,t", dreg, dreg, AT);
d7202 1
a7202 2
	    macro_build ((char *) NULL, &icnt, NULL, "ror",
			 "d,w,<", dreg, sreg, rot);
d7207 1
a7207 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
			 "d,w,<", dreg, sreg, 0);
d7210 4
a7213 6
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
		     "d,w,<", AT, sreg, rot);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		     "d,v,t", dreg, dreg, AT);
d7226 1
a7226 1
      macro_build ((char *) NULL, &icnt, &offset_expr, "swc1", "T,o(b)",
d7228 1
a7228 1
		   (int) BFD_RELOC_LO16, breg);
d7230 1
a7230 1
      macro_build ((char *) NULL, &icnt, &offset_expr, "swc1", "T,o(b)",
d7232 1
a7232 1
		   (int) BFD_RELOC_LO16, breg);
d7237 2
a7238 2
	macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg,
		     treg, (int) BFD_RELOC_LO16);
d7240 2
a7241 2
	macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg,
		     sreg, (int) BFD_RELOC_LO16);
d7244 3
a7246 4
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "xor",
		       "d,v,t", dreg, sreg, treg);
	  macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg,
		       dreg, (int) BFD_RELOC_LO16);
d7253 2
a7254 2
	  macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg,
		       sreg, (int) BFD_RELOC_LO16);
d7268 2
a7269 2
	  macro_build ((char *) NULL, &icnt, &imm_expr, "xori", "t,r,i", dreg,
		       sreg, (int) BFD_RELOC_LO16);
d7277 1
a7277 1
	  macro_build ((char *) NULL, &icnt, &imm_expr,
d7279 1
a7279 1
		       "t,r,j", dreg, sreg, (int) BFD_RELOC_LO16);
d7285 1
a7285 2
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "xor",
		       "d,v,t", dreg, sreg, AT);
d7288 2
a7289 2
      macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg, dreg,
		   (int) BFD_RELOC_LO16);
d7300 3
a7302 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "d,v,t",
		   dreg, sreg, treg);
      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
		   (int) BFD_RELOC_LO16);
d7311 1
a7311 1
	  macro_build ((char *) NULL, &icnt, &imm_expr,
d7313 1
a7313 1
		       "t,r,j", dreg, sreg, (int) BFD_RELOC_LO16);
d7319 2
a7320 3
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       mask == M_SGE_I ? "slt" : "sltu", "d,v,t", dreg, sreg,
		       AT);
d7323 2
a7324 2
      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
		   (int) BFD_RELOC_LO16);
d7335 1
a7335 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "d,v,t",
		   dreg, treg, sreg);
d7345 1
a7345 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "d,v,t",
		   dreg, AT, sreg);
d7354 3
a7356 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "d,v,t",
		   dreg, treg, sreg);
      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
		   (int) BFD_RELOC_LO16);
d7366 3
a7368 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "d,v,t",
		   dreg, AT, sreg);
      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
		   (int) BFD_RELOC_LO16);
d7376 2
a7377 2
	  macro_build ((char *) NULL, &icnt, &imm_expr, "slti", "t,r,j",
		       dreg, sreg, (int) BFD_RELOC_LO16);
d7381 1
a7381 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "slt", "d,v,t",
		   dreg, sreg, AT);
d7389 2
a7390 2
	  macro_build ((char *) NULL, &icnt, &imm_expr, "sltiu", "t,r,j",
		       dreg, sreg, (int) BFD_RELOC_LO16);
d7394 1
a7394 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		   "d,v,t", dreg, sreg, AT);
d7399 1
a7399 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		     "d,v,t", dreg, 0, treg);
d7401 1
a7401 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		     "d,v,t", dreg, 0, sreg);
d7404 2
a7405 4
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "xor",
		       "d,v,t", dreg, sreg, treg);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		       "d,v,t", dreg, 0, dreg);
d7412 1
a7412 2
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		       "d,v,t", dreg, 0, sreg);
d7419 1
a7419 1
	  macro_build ((char *) NULL, &icnt, &expr1,
d7421 1
a7421 1
		       "t,r,j", dreg, 0, (int) BFD_RELOC_LO16);
d7428 2
a7429 2
	  macro_build ((char *) NULL, &icnt, &imm_expr, "xori", "t,r,i",
		       dreg, sreg, (int) BFD_RELOC_LO16);
d7437 1
a7437 1
	  macro_build ((char *) NULL, &icnt, &imm_expr,
d7439 1
a7439 1
		       "t,r,j", dreg, sreg, (int) BFD_RELOC_LO16);
d7445 1
a7445 2
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "xor",
		       "d,v,t", dreg, sreg, AT);
d7448 1
a7448 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sltu",
		   "d,v,t", dreg, 0, dreg);
d7461 2
a7462 3
	  macro_build ((char *) NULL, &icnt, &imm_expr,
		       dbl ? "daddi" : "addi",
		       "t,r,j", dreg, sreg, (int) BFD_RELOC_LO16);
d7466 2
a7467 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "dsub" : "sub", "d,v,t", dreg, sreg, AT);
d7478 2
a7479 3
	  macro_build ((char *) NULL, &icnt, &imm_expr,
		       dbl ? "daddiu" : "addiu",
		       "t,r,j", dreg, sreg, (int) BFD_RELOC_LO16);
d7483 2
a7484 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "dsubu" : "subu", "d,v,t", dreg, sreg, AT);
d7506 1
a7506 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "s,t", sreg,
		   AT);
d7522 3
a7524 5
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "cfc1", "t,G",
		   treg, RA);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "cfc1", "t,G",
		   treg, RA);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
d7526 2
a7527 2
      macro_build ((char *) NULL, &icnt, &expr1, "ori", "t,r,i", AT, treg,
		   (int) BFD_RELOC_LO16);
d7529 9
a7537 10
      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", AT, AT,
		     (int) BFD_RELOC_LO16);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "ctc1", "t,G",
		   AT, RA);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
	      mask == M_TRUNCWD ? "cvt.w.d" : "cvt.w.s", "D,S", dreg, sreg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "ctc1", "t,G",
		   treg, RA);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
d7551 2
a7552 2
      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", AT,
		   (int) BFD_RELOC_LO16, breg);
d7557 4
a7560 6
      macro_build ((char *) NULL, &icnt, &offset_expr, "lbu", "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, breg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll", "d,w,<",
		   AT, AT, 8);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or", "d,v,t",
		   treg, treg, AT);
d7581 2
a7582 2
      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", tempreg,
		   (int) BFD_RELOC_LO16, breg);
d7587 2
a7588 2
      macro_build ((char *) NULL, &icnt, &offset_expr, s2, "t,o(b)", tempreg,
		   (int) BFD_RELOC_LO16, breg);
d7595 1
a7595 1
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
d7612 2
a7613 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		     ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
d7618 2
a7619 2
      macro_build ((char *) NULL, &icnt, &expr1, s, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, AT);
d7624 2
a7625 2
      macro_build ((char *) NULL, &icnt, &expr1, s2, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, AT);
d7633 2
a7634 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		     ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
d7637 3
a7639 3
      macro_build ((char *) NULL, &icnt, &expr1,
		   mask == M_ULH_A ? "lb" : "lbu", "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, AT);
d7644 4
a7647 6
      macro_build ((char *) NULL, &icnt, &expr1, "lbu", "t,o(b)", AT,
		   (int) BFD_RELOC_LO16, AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll", "d,w,<",
		   treg, treg, 8);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or", "d,v,t",
		   treg, treg, AT);
d7655 3
a7657 4
      macro_build ((char *) NULL, &icnt, &offset_expr, "sb", "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, breg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl", "d,w,<",
		   AT, treg, 8);
d7662 2
a7663 2
      macro_build ((char *) NULL, &icnt, &offset_expr, "sb", "t,o(b)", AT,
		   (int) BFD_RELOC_LO16, breg);
d7680 2
a7681 2
      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, breg);
d7686 2
a7687 2
      macro_build ((char *) NULL, &icnt, &offset_expr, s2, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, breg);
d7703 2
a7704 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		     ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
d7709 2
a7710 2
      macro_build ((char *) NULL, &icnt, &expr1, s, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, AT);
d7715 2
a7716 2
      macro_build ((char *) NULL, &icnt, &expr1, s2, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, AT);
d7723 2
a7724 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		     ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
d7727 3
a7729 4
      macro_build ((char *) NULL, &icnt, &expr1, "sb", "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl", "d,w,<",
		   treg, treg, 8);
d7734 2
a7735 2
      macro_build ((char *) NULL, &icnt, &expr1, "sb", "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, AT);
d7740 4
a7743 6
      macro_build ((char *) NULL, &icnt, &expr1, "lbu", "t,o(b)", AT,
		   (int) BFD_RELOC_LO16, AT);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll", "d,w,<",
		   treg, treg, 8);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or", "d,v,t",
		   treg, treg, AT);
d7759 1
a7759 2
mips16_macro (ip)
     struct mips_cl_insn *ip;
d7801 2
a7802 3
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "ddiv" : "div",
		   "0,x,y", xreg, yreg);
d7804 2
a7805 3
      macro_build ((char *) NULL, &icnt, &expr1, "bnez", "x,p", yreg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break", "6",
		   7);
d7812 1
a7812 1
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "x", zreg);
d7834 1
a7834 2
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "0,x,y",
		   xreg, yreg);
d7836 2
a7837 3
      macro_build ((char *) NULL, &icnt, &expr1, "bnez", "x,p", yreg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break",
		   "6", 7);
d7839 1
a7839 1
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s2, "x", zreg);
d7845 3
a7847 4
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   dbl ? "dmultu" : "multu", "x,y", xreg, yreg);
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "mflo", "x",
		   zreg);
d7858 2
a7859 2
      macro_build ((char *) NULL, &icnt, &imm_expr,
		   dbl ? "daddiu" : "addiu", "y,x,4", yreg, xreg);
d7866 1
a7866 2
      macro_build ((char *) NULL, &icnt, &imm_expr, "addiu",
		   "x,k", xreg);
d7873 1
a7873 2
      macro_build ((char *) NULL, &icnt, &imm_expr, "daddiu",
		   "y,j", yreg);
d7922 2
a7923 3
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "x,y",
		   xreg, yreg);
      macro_build ((char *) NULL, &icnt, &offset_expr, s2, "p");
d7982 2
a7983 2
      macro_build ((char *) NULL, &icnt, &imm_expr, s, s3, xreg);
      macro_build ((char *) NULL, &icnt, &offset_expr, s2, "p");
d7988 1
a7988 1
      macro_build ((char *) NULL, &icnt, &expr1, "slti", "x,8", yreg);
d7992 2
a7993 3
      macro_build ((char *) NULL, &icnt, &expr1, "bteqz", "p");
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		   "neg", "x,w", xreg, xreg);
d8001 1
a8001 2
validate_mips_insn (opc)
     const struct mips_opcode *opc;
d8110 1
a8110 3
mips_ip (str, ip)
     char *str;
     struct mips_cl_insn *ip;
d9258 1
a9258 3
mips16_ip (str, ip)
     char *str;
     struct mips_cl_insn *ip;
d9864 4
a9867 12
mips16_immed (file, line, type, val, warn, small, ext, insn, use_extend,
	      extend)
     char *file;
     unsigned int line;
     int type;
     offsetT val;
     bfd_boolean warn;
     bfd_boolean small;
     bfd_boolean ext;
     unsigned long *insn;
     bfd_boolean *use_extend;
     unsigned short *extend;
d9998 1
a9998 3
parse_relocation (str, reloc)
     char **str;
     bfd_reloc_code_real_type *reloc;
d10030 2
a10031 4
my_getSmallExpression (ep, reloc, str)
     expressionS *ep;
     bfd_reloc_code_real_type *reloc;
     char *str;
d10086 1
a10086 3
my_getExpression (ep, str)
     expressionS *ep;
     char *str;
d10117 1
a10117 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d10149 1
a10149 1
	  md_number_to_chars (litP, (valueT) words[i], 2);
d10157 1
a10157 1
	  md_number_to_chars (litP, (valueT) words[i], 2);
d10166 1
a10166 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d10337 1
a10337 2
mips_set_option_string (string_ptr, new_value)
     const char **string_ptr, *new_value;
d10348 1
a10348 3
md_parse_option (c, arg)
     int c;
     char *arg;
d10685 1
a10685 2
mips_set_architecture (info)
     const struct mips_cpu_info *info;
d10699 1
a10699 2
mips_set_tune (info)
     const struct mips_cpu_info *info;
d10707 1
a10707 1
mips_after_parse_args ()
d10800 5
a10804 4
  /* ??? When do we want this flag to be set?   Who uses it?  */
  if (file_mips_gp32 == 1
      && mips_abi == NO_ABI
      && ISA_HAS_64BIT_REGS (mips_opts.isa))
d10838 1
a10838 1
mips_init_after_args ()
d10846 1
a10846 2
md_pcrel_from (fixP)
     fixS *fixP;
d10868 1
a10868 1
mips_frob_file_before_adjust ()
d10884 1
a10884 1
mips_frob_file ()
d10983 1
a10983 2
mips_force_relocation (fixp)
     fixS *fixp;
d11016 1
a11016 3
mips_validate_fix (fixP, seg)
     struct fix *fixP;
     asection *seg;
d11081 1
a11081 2
mips_need_elf_addend_fixup (fixP)
     fixS *fixP;
d11107 1
a11107 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d11256 1
a11256 1
      md_number_to_chars ((char *) buf, *valP, 2);
d11269 1
a11269 1
      md_number_to_chars ((char *) buf, *valP, 2);
d11326 1
a11326 1
	  md_number_to_chars ((char *) buf, *valP, 2);
d11352 1
a11352 1
	  md_number_to_chars ((char *) buf, (valueT) insn, 4);
d11374 1
a11374 1
	  md_number_to_chars ((char *) buf, (valueT) insn, 4);
d11408 1
a11408 2
printInsn (oc)
     unsigned long oc;
d11494 1
a11494 1
get_symbol ()
d11511 1
a11511 4
mips_align (to, fill, label)
     int to;
     int fill;
     symbolS *label;
d11528 1
a11528 2
s_align (x)
     int x ATTRIBUTE_UNUSED;
d11576 1
a11576 1
mips_flush_pending_output ()
d11583 1
a11583 2
s_change_sec (sec)
     int sec;
d11671 1
a11671 2
s_change_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
d11730 1
a11730 1
mips_enable_auto_align ()
d11736 1
a11736 2
s_cons (log_size)
     int log_size;
d11749 1
a11749 2
s_float_cons (type)
     int type;
d11777 1
a11777 2
s_mips_globl (x)
     int x ATTRIBUTE_UNUSED;
d11817 1
a11817 2
s_option (x)
     int x ATTRIBUTE_UNUSED;
d11872 1
a11872 2
s_mipsset (x)
     int x ATTRIBUTE_UNUSED;
d12100 1
a12100 2
s_abicalls (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12125 1
a12125 2
s_cpload (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12151 2
a12152 2
  macro_build ((char *) NULL, &icnt, &ex, "addiu", "t,r,j",
	       mips_gp_register, mips_gp_register, (int) BFD_RELOC_LO16);
d12154 2
a12155 2
  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "addu", "d,v,t",
	       mips_gp_register, mips_gp_register, tc_get_register (0));
d12176 1
a12176 2
s_cpsetup (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12230 2
a12231 2
      macro_build ((char *) NULL, &icnt, &ex_off, "sd", "t,o(b)",
		   mips_gp_register, (int) BFD_RELOC_LO16, SP);
d12234 2
a12235 2
    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "daddu",
		 "d,v,t", mips_cpreturn_register, mips_gp_register, 0);
d12241 2
a12242 2
  macro_build ((char *) NULL, &icnt, &ex_sym, "lui", "t,u", mips_gp_register,
	       (int) BFD_RELOC_GPREL16);
d12249 2
a12250 2
  macro_build ((char *) NULL, &icnt, &ex_sym, "addiu", "t,r,j",
	       mips_gp_register, mips_gp_register, (int) BFD_RELOC_GPREL16);
d12256 2
a12257 2
  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, ADDRESS_ADD_INSN,
	       "d,v,t", mips_gp_register, mips_gp_register, reg1);
d12263 1
a12263 2
s_cplocal (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12282 1
a12282 2
s_cprestore (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12303 1
a12303 1
  macro_build_ldst_constoffset ((char *) NULL, &icnt, &ex, ADDRESS_STORE_INSN,
d12317 1
a12317 2
s_cpreturn (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12337 2
a12338 2
      macro_build ((char *) NULL, &icnt, &ex, "ld", "t,o(b)",
		   mips_gp_register, (int) BFD_RELOC_LO16, SP);
d12341 2
a12342 2
    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "daddu",
		 "d,v,t", mips_gp_register, mips_cpreturn_register, 0);
d12351 1
a12351 2
s_gpvalue (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12370 1
a12370 2
s_gpword (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12398 1
a12398 1
  md_number_to_chars (p, (valueT) 0, 4);
d12406 1
a12406 2
s_gpdword (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12434 1
a12434 1
  md_number_to_chars (p, (valueT) 0, 8);
d12452 1
a12452 2
s_cpadd (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12466 2
a12467 2
  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, ADDRESS_ADD_INSN,
	       "d,v,t", reg, reg, mips_gp_register);
d12482 1
a12482 2
s_insn (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12496 1
a12496 2
s_mips_stab (type)
     int type;
d12508 1
a12508 2
s_mips_weakext (ignore)
     int ignore ATTRIBUTE_UNUSED;
d12557 1
a12557 2
tc_get_register (frame)
     int frame;
d12636 1
a12636 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d12660 1
a12660 3
nopic_need_relax (sym, before_relaxing)
     symbolS *sym;
     int before_relaxing;
d12728 1
a12728 3
pic_need_relax (sym, segtype)
     symbolS *sym;
     asection *segtype;
d12784 1
a12784 4
mips16_extended_frag (fragp, sec, stretch)
     fragS *fragp;
     asection *sec;
     long stretch;
d12984 1
a12984 4
relaxed_branch_length (fragp, sec, update)
     fragS *fragp;
     asection *sec;
     int update;
d13048 1
a13048 3
md_estimate_size_before_relax (fragp, segtype)
     fragS *fragp;
     asection *segtype;
d13100 1
a13100 2
mips_fix_adjustable (fixp)
     fixS *fixp;
d13126 1
a13126 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d13373 1
a13373 4
mips_relax_frag (sec, fragp, stretch)
     asection *sec;
     fragS *fragp;
     long stretch;
d13408 1
a13408 4
md_convert_frag (abfd, asec, fragp)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT asec;
     fragS *fragp;
d13442 1
a13442 1
	  md_number_to_chars ((char *)buf, insn, 4);
d13514 1
a13514 1
	  md_number_to_chars ((char *)buf, insn, 4);
d13518 1
a13518 1
	  md_number_to_chars ((char*)buf, 0, 4);
d13537 1
a13537 1
	      md_number_to_chars ((char *)buf, insn, 4);
d13540 1
a13540 1
	      md_number_to_chars ((char *)buf, 0, 4);
d13559 1
a13559 1
	      md_number_to_chars ((char*)buf, insn, 4);
d13581 1
a13581 1
	      md_number_to_chars ((char*)buf, insn, 4);
d13587 1
a13587 1
		  md_number_to_chars ((char*)buf, 0, 4);
d13599 1
a13599 1
	      md_number_to_chars ((char*)buf, insn, 4);
d13608 1
a13608 1
	      md_number_to_chars ((char*)buf, insn, 4);
d13701 1
a13701 1
	  md_number_to_chars ((char *) buf, 0xf000 | extend, 2);
d13706 1
a13706 1
      md_number_to_chars ((char *) buf, insn, 2);
d13733 1
a13733 1
mips_frob_file_after_relocs ()
d13764 1
a13764 2
mips_define_label (sym)
     symbolS *sym;
d13786 1
a13786 1
mips_elf_final_processing ()
d13884 1
a13884 2
mips_handle_align (fragp)
     fragS *fragp;
d13914 1
a13914 1
md_obj_begin ()
d13919 1
a13919 1
md_obj_end ()
d13927 1
a13927 1
get_number ()
d13982 1
a13982 2
s_mips_file (x)
     int x ATTRIBUTE_UNUSED;
d14013 1
a14013 2
s_mips_loc (x)
     int x ATTRIBUTE_UNUSED;
d14022 1
a14022 2
s_mips_end (x)
     int x ATTRIBUTE_UNUSED;
d14088 7
a14094 7
      md_number_to_chars (fragp,      (valueT) cur_proc_ptr->reg_mask, 4);
      md_number_to_chars (fragp +  4, (valueT) cur_proc_ptr->reg_offset, 4);
      md_number_to_chars (fragp +  8, (valueT) cur_proc_ptr->fpreg_mask, 4);
      md_number_to_chars (fragp + 12, (valueT) cur_proc_ptr->fpreg_offset, 4);
      md_number_to_chars (fragp + 16, (valueT) cur_proc_ptr->frame_offset, 4);
      md_number_to_chars (fragp + 20, (valueT) cur_proc_ptr->frame_reg, 4);
      md_number_to_chars (fragp + 24, (valueT) cur_proc_ptr->pc_reg, 4);
d14106 1
a14106 2
s_mips_ent (aent)
     int aent;
d14154 1
a14154 2
s_mips_frame (ignore)
     int ignore ATTRIBUTE_UNUSED;
d14197 1
a14197 2
s_mips_mask (reg_type)
     char reg_type;
d14243 1
a14243 2
s_loc (x)
     int x;
d14338 1
a14338 2
mips_strict_matching_cpu_name_p (canonical, given)
     const char *canonical, *given;
d14354 1
a14354 2
mips_matching_cpu_name_p (canonical, given)
     const char *canonical, *given;
d14389 1
a14389 2
mips_parse_cpu (option, cpu_string)
     const char *option, *cpu_string;
d14435 1
a14435 2
mips_cpu_info_from_isa (isa)
     int isa;
d14448 1
a14448 2
mips_cpu_info_from_arch (arch)
     int arch;
d14460 1
a14460 5
show (stream, string, col_p, first_p)
     FILE *stream;
     const char *string;
     int *col_p;
     int *first_p;
d14486 1
a14486 2
md_show_usage (stream)
     FILE *stream;
d14567 1
a14567 1
mips_dwarf2_format ()
@


1.221
log
@	* ld-mips-elf/elf-rel-got-n64-linux.d: New file.
	* ld-mips-elf/elf-rel-xgot-n64-linux.d: New file.
	* ld-mips-elf/mips-elf.exp: Use the new files for Linux.
@
text
@d2119 2
a2120 1
	      tmp = (address_expr->X_add_number + 0x800080008000) >> 16;
@


1.220
log
@Update .comm error messages to assume an unsigned value.
Update relaxing code to work in 64-bit address spaces.
@
text
@d183 3
d200 1
a200 1
  ISA_UNKNOWN, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0
d225 1
a225 1
static int mips_arch = CPU_UNKNOWN;
a226 1
static const struct mips_cpu_info *mips_arch_info;
a231 1
static const struct mips_cpu_info *mips_tune_info;
d342 3
a344 3
#define hilo_interlocks (mips_arch == CPU_R4010                       \
                         || mips_arch == CPU_VR5500                   \
                         || mips_arch == CPU_SB1                      \
d351 3
a353 3
   || mips_arch == CPU_VR5400  \
   || mips_arch == CPU_VR5500  \
   || mips_arch == CPU_R3900)
d358 4
a361 4
#define cop_interlocks (mips_arch == CPU_R4300                        \
                        || mips_arch == CPU_VR5400                    \
                        || mips_arch == CPU_VR5500                    \
                        || mips_arch == CPU_SB1                       \
d1002 2
d1208 1
a1208 1
  if (! bfd_set_arch_mach (stdoutput, bfd_arch_mips, mips_arch))
d2990 2
a2991 2
			       mips_arch)
	  && (mips_arch != CPU_R4650 || (insn.insn_mo->pinfo & FP_D) == 0))
d5905 1
a5905 1
      if (mips_arch == CPU_R4650)
d5994 1
a5994 1
      if (mips_arch == CPU_R4650)
d6681 1
a6681 1
      if (mips_arch == CPU_R4650)
d6722 1
a6722 1
      if (mips_arch == CPU_R4650)
d6740 1
a6740 1
      if (mips_arch == CPU_R4650)
d7324 1
a7324 1
      if (ISA_HAS_DROR (mips_opts.isa) || CPU_HAS_DROR (mips_arch))
d7355 1
a7355 1
      if (ISA_HAS_ROR (mips_opts.isa) || CPU_HAS_ROR (mips_arch))
d7393 1
a7393 1
	if (ISA_HAS_DROR (mips_opts.isa) || CPU_HAS_DROR (mips_arch))
d7429 1
a7429 1
	if (ISA_HAS_ROR (mips_opts.isa) || CPU_HAS_ROR (mips_arch))
d7451 1
a7451 1
      if (ISA_HAS_DROR (mips_opts.isa) || CPU_HAS_DROR (mips_arch))
d7468 1
a7468 1
      if (ISA_HAS_ROR (mips_opts.isa) || CPU_HAS_ROR (mips_arch))
d7492 1
a7492 1
	if (ISA_HAS_DROR (mips_opts.isa) || CPU_HAS_DROR (mips_arch))
d7527 1
a7527 1
	if (ISA_HAS_ROR (mips_opts.isa) || CPU_HAS_ROR (mips_arch))
d7549 1
a7549 1
      if (mips_arch == CPU_R4650)
d8561 1
a8561 1
			    mips_arch))
d8568 1
a8568 1
	  if (mips_arch == CPU_R4650 && (insn->pinfo & FP_D) != 0)
d8585 4
a8588 9
		  if (mips_arch_info->is_isa)
		    sprintf (buf,
			     _("opcode not supported at this ISA level (%s)"),
			     mips_cpu_info_from_isa (mips_opts.isa)->name);
		  else
		    sprintf (buf,
			     _("opcode not supported on this processor: %s (%s)"),
			     mips_arch_info->name,
			     mips_cpu_info_from_isa (mips_opts.isa)->name);
d11090 2
a11091 2
      mips_arch_info = info;
      mips_arch = info->cpu;
d11104 1
a11104 4
    {
      mips_tune_info = info;
      mips_tune = info->cpu;
    }
d11111 3
d11132 1
a11132 4
    mips_set_architecture (mips_parse_cpu ("-march", mips_arch_string));

  if (mips_tune_string != 0)
    mips_set_tune (mips_parse_cpu ("-mtune", mips_tune_string));
d11137 1
a11137 1
	 ISA level specified by -mipsN, while mips_opts.isa contains
d11139 1
a11139 1
      if (mips_arch_info != 0)
d11144 1
a11144 1
	  if (file_mips_isa != mips_opts.isa)
d11147 1
a11147 1
		    mips_cpu_info_from_isa (mips_opts.isa)->name);
d11150 1
a11150 1
	mips_set_architecture (mips_cpu_info_from_isa (file_mips_isa));
d11153 2
a11154 3
  if (mips_arch_info == 0)
    mips_set_architecture (mips_parse_cpu ("default CPU",
					   MIPS_CPU_STRING_DEFAULT));
d11156 1
a11156 1
  if (ABI_NEEDS_64BIT_REGS (mips_abi) && !ISA_HAS_64BIT_REGS (mips_opts.isa))
d11158 7
a11164 1
	    mips_arch_info->name);
d11166 4
a11169 3
  /* Optimize for mips_arch, unless -mtune selects a different processor.  */
  if (mips_tune_info == 0)
    mips_set_tune (mips_arch_info);
d11214 1
a11214 1
    mips_opts.mips16 = (CPU_HAS_MIPS16 (mips_arch)) ? 1 : 0;
d11216 1
a11216 1
    mips_opts.ase_mips3d = (CPU_HAS_MIPS3D (mips_arch)) ? 1 : 0;
d11218 1
a11218 1
    mips_opts.ase_mdmx = (CPU_HAS_MDMX (mips_arch)) ? 1 : 0;
d12468 41
d14783 1
a14783 1
  { "4kc",            0,      ISA_MIPS32,     CPU_MIPS32, },
d14913 13
@


1.219
log
@	* config/tc-mips.c (ADDRESS_ADD_INSN,ADDRESS_ADDI_INSN): Remove
	special handling for n32 ABI.
	(macro): Likewise.
	* gas/mips/elf-rel-got-n32.d: Remove special handling for n32 ABI.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* ld-mips-elf/elf-rel-got-n32.d: Remove special handling for n32 ABI.
	* ld-mips-elf/elf-rel-xgot-n32.d: Likewise.
@
text
@d3282 1
a3282 1
  char *f = NULL;;
@


1.218
log
@Revert 2003-06-11 change.
@
text
@d303 3
a305 4
/* Addresses are loaded in different ways, depending on the address
   size in use and the ABI.  N32_ABI uses additions with overflow
   checking, this allows to catch code generation errors which would
   distort the proper sign extension of the 64-bit wide registers.  */
d307 1
a307 1
   (HAVE_32BIT_ADDRESSES ? (HAVE_NEWABI ? "add" : "addu") : "daddu")
d310 1
a310 1
   (HAVE_32BIT_ADDRESSES ? (HAVE_NEWABI ? "addi" : "addiu") : "daddiu")
d4853 1
a4853 2
		       (dbl || HAVE_64BIT_ADDRESSES) ? "daddiu" :
		       HAVE_NEWABI ? "addi" : "addiu",
d5619 1
a5619 2
	    s = (dbl || HAVE_64BIT_ADDRESSES) ? "daddu" :
	      HAVE_NEWABI ? "add" : "addu";
d6063 1
a6063 1
                        ? HAVE_NEWABI ? "add" : "addu" : "daddu"),
@


1.217
log
@	* config/tc-mips.c (ADDRESS_ADD_INSN,ADDRESS_ADDI_INSN,
	ADDRESS_LOAD_INSN,ADDRESS_STORE_INSN): New macros.
	(macro_build_ldst_constoffset,load_address,macro,s_cpsetup,
	s_cprestore,s_cpadd): Use them.
@
text
@d12616 1
a12616 1
		   mips_gp_register, (int) BFD_RELOC_LO16, mips_frame_reg);
d12691 1
a12691 1
				mips_gp_register, mips_frame_reg);
d12726 1
a12726 1
		   mips_gp_register, (int) BFD_RELOC_LO16, mips_frame_reg);
@


1.216
log
@	* config/tc-mips.c (append_insn): In a compound relocation, take the
	field width from the final (outermost) operator.
@
text
@d303 16
d3400 1
a3400 3
      macro_build (place, counter, (expressionS *) NULL,
		   HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
		   ? "add" : "addu" : "daddu",
d3887 3
a3889 4
	      macro_build ((char *) NULL, counter, ep,
			   HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
			   ? "addi" : "addiu" : "daddiu", "t,r,j",
			   reg, mips_gp_register, (int) BFD_RELOC_GPREL16);
d3898 1
a3898 3
	  macro_build (p, counter, ep,
		       HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
		       ? "addi" : "addiu" : "daddiu",
d3927 3
a3929 3
	      macro_build ((char *) NULL, counter, ep,
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)", reg,
			   (int) BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);
d3933 1
a3933 2
	      macro_build ((char *) NULL, counter, &ex,
			   HAVE_32BIT_ADDRESSES ? "addi" : "daddiu",
d3942 1
a3942 2
	  macro_build (p, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)", reg,
d3958 3
a3960 3
	  macro_build ((char *) NULL, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)",
		       reg, (int) BFD_RELOC_MIPS_GOT16, mips_gp_register);
d3965 1
a3965 2
	  macro_build (p, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d3973 1
a3973 2
	      macro_build ((char *) NULL, counter, &ex,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d4009 2
a4010 4
		       HAVE_32BIT_ADDRESSES ? "add" : "daddu", "d,v,t", reg,
		       reg, mips_gp_register);
	  macro_build ((char *) NULL, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d4017 1
a4017 2
	      macro_build ((char *) NULL, counter, &ex,
			   HAVE_32BIT_ADDRESSES ? "addi" : "daddiu",
d4026 1
a4026 2
	  macro_build (p, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)", reg,
d4028 1
a4028 2
	  macro_build (p + 4, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "addi" : "daddiu", "t,r,j",
d4043 2
a4044 4
		       HAVE_32BIT_ADDRESSES ? "addu" : "daddu", "d,v,t", reg,
		       reg, mips_gp_register);
	  macro_build ((char *) NULL, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d4059 1
a4059 2
	  macro_build (p, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)", reg,
d4064 1
a4064 2
	  macro_build (p, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d4072 1
a4072 2
	      macro_build ((char *) NULL, counter, &ex,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d4082 1
a4082 2
      macro_build ((char *) NULL, counter, ep,
		   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d4999 2
a5000 3
			       HAVE_NEWABI ? "addi" : "addiu",
			       "t,r,j", tempreg, mips_gp_register,
			       (int) BFD_RELOC_GPREL16);
d5009 1
a5009 2
	      macro_build (p, &icnt, &offset_expr,
			   HAVE_NEWABI ? "addi" : "addiu",
d5052 1
a5052 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d5081 1
a5081 2
	      macro_build (p, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d5092 1
a5092 2
	      macro_build ((char *) NULL, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d5116 1
a5116 2
			       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			       "d,v,t", treg, AT, breg);
d5129 1
a5129 2
	      macro_build ((char *) NULL, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d5132 1
a5132 2
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			   "d,v,t", tempreg, tempreg, AT);
d5178 2
a5179 3
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", tempreg, lw_reloc_type,
			   mips_gp_register);
d5185 1
a5185 2
			       HAVE_32BIT_ADDRESSES ? "addi" : "daddiu",
			       "t,r,j", tempreg, tempreg,
d5208 1
a5208 2
				   HAVE_32BIT_ADDRESSES ? "add" : "daddu",
				   "d,v,t", treg, AT, breg);
d5215 2
a5216 2
			       HAVE_32BIT_ADDRESSES ? "addi" : "daddiu",
			       "t,r,j", AT, AT, (int) BFD_RELOC_LO16);
d5218 1
a5218 2
			       HAVE_32BIT_ADDRESSES ? "add" : "daddu",
			       "d,v,t", dreg, dreg, AT);
d5232 1
a5232 2
	      macro_build (p, &icnt, &offset_expr,
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d5238 2
a5239 2
			       HAVE_32BIT_ADDRESSES ? "add" : "daddu",
			       "d,v,t", treg, tempreg, breg);
d5247 2
a5248 3
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", tempreg, lw_reloc_type,
			   mips_gp_register);
d5327 3
a5329 4
		       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
		       "d,v,t", tempreg, tempreg, mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d5360 1
a5360 2
	      macro_build ((char *) NULL, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d5392 1
a5392 2
			       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			       "d,v,t", treg, AT, breg);
d5404 1
a5404 2
	      macro_build ((char *) NULL, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d5407 1
a5407 2
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			   "d,v,t", dreg, dreg, AT);
d5428 2
a5429 5
	  macro_build (p, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
		       "t,o(b)", tempreg,
		       local_reloc_type,
		       mips_gp_register);
d5436 1
a5436 2
	      macro_build (p, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d5454 1
a5454 2
			       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			       "d,v,t", treg, AT, breg);
d5464 1
a5464 2
	      macro_build (p, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d5467 1
a5467 2
	      macro_build (p, &icnt, (expressionS *) NULL,
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d5524 3
a5526 4
		       HAVE_32BIT_ADDRESSES ? "add" : "daddu",
		       "d,v,t", tempreg, tempreg, mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d5539 1
a5539 2
	      macro_build ((char *) NULL, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "addi" : "daddiu",
d5564 1
a5564 2
			       HAVE_32BIT_ADDRESSES ? "add" : "daddu",
			       "d,v,t", treg, AT, breg);
d5572 1
a5572 2
	      macro_build ((char *) NULL, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "addi" : "daddiu",
d5575 1
a5575 2
			   HAVE_32BIT_ADDRESSES ? "add" : "daddu",
			   "d,v,t", dreg, dreg, AT);
d5591 4
a5594 6
	  macro_build (p, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)",
		       tempreg,
		       (int) BFD_RELOC_MIPS_GOT_PAGE, mips_gp_register);
	  macro_build (p + 4, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "addi" : "daddiu", "t,r,j",
d5599 1
a5599 2
			   HAVE_32BIT_ADDRESSES ? "add" : "daddu",
			   "d,v,t", treg, tempreg, breg);
d5609 3
a5611 3
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu", "t,r,j",
		       tempreg, mips_gp_register, (int) BFD_RELOC_GPREL16);
d5624 1
a5624 1
	    s = HAVE_64BIT_ADDRESSES ? "daddu" : HAVE_NEWABI ? "add" : "addu";
d5683 3
a5685 2
					        HAVE_32BIT_ADDRESSES ? "lw" : "ld",
					        mips_gp_register, mips_frame_reg);
d5735 1
a5735 2
			       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			       "t,o(b)", PIC_CALL_REG,
d5749 2
a5750 3
			       HAVE_32BIT_ADDRESSES ? "add" : "daddu",
			       "d,v,t", PIC_CALL_REG, PIC_CALL_REG,
			       mips_gp_register);
d5752 1
a5752 2
			       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			       "t,o(b)", PIC_CALL_REG,
d5757 3
a5759 3
		  macro_build (p, &icnt, &offset_expr,
			       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)",
			       PIC_CALL_REG, (int) BFD_RELOC_MIPS_GOT_PAGE,
d5761 1
a5761 2
		  macro_build (p + 4, &icnt, &offset_expr,
			       HAVE_32BIT_ADDRESSES ? "addi" : "daddiu",
d5774 1
a5774 2
			       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			       "t,o(b)", PIC_CALL_REG,
d5794 2
a5795 3
			       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			       "d,v,t", PIC_CALL_REG, PIC_CALL_REG,
			       mips_gp_register);
d5797 1
a5797 2
			       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			       "t,o(b)", PIC_CALL_REG,
d5810 1
a5810 2
		  macro_build (p, &icnt, &offset_expr,
			       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d5817 1
a5817 2
	      macro_build (p, &icnt, &offset_expr,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d5843 3
a5845 2
					        HAVE_32BIT_ADDRESSES ? "lw" : "ld",
					        mips_gp_register, mips_frame_reg);
d6256 2
a6257 3
			       HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
			       ? "add" : "addu" : "daddu",
			       "d,v,t", tempreg, breg, mips_gp_register);
d6267 1
a6267 3
	      macro_build (p, &icnt, (expressionS *) NULL,
			   HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
			   ? "add" : "addu" : "daddu",
d6304 2
a6305 3
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", tempreg, BFD_RELOC_MIPS_GOT_PAGE,
			   mips_gp_register);
d6308 2
a6309 2
			     HAVE_32BIT_ADDRESSES ? "add" : "daddu",
			     "d,v,t", tempreg, tempreg, breg);
d6324 3
a6326 3
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)", tempreg,
		       (int) lw_reloc_type, mips_gp_register);
d6331 1
a6331 2
	  macro_build (p, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d6335 1
a6335 2
			 HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			 "d,v,t", tempreg, tempreg, breg);
d6374 3
a6376 4
		       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
		       "d,v,t", tempreg, tempreg, mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d6387 1
a6387 2
	  macro_build (p, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d6393 1
a6393 2
	  macro_build (p, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d6397 1
a6397 2
			 HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			 "d,v,t", tempreg, tempreg, breg);
d6425 3
a6427 4
		       HAVE_32BIT_ADDRESSES ? "add" : "daddu",
		       "d,v,t", tempreg, tempreg, mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d6432 1
a6432 2
			 HAVE_32BIT_ADDRESSES ? "add" : "daddu",
			 "d,v,t", tempreg, tempreg, breg);
d6441 2
a6442 4
	  macro_build (p, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
		       "t,o(b)", tempreg,
		       (int) BFD_RELOC_MIPS_GOT_PAGE,
d6446 1
a6446 2
			 HAVE_32BIT_ADDRESSES ? "add" : "daddu",
			 "d,v,t", tempreg, tempreg, breg);
d6468 2
a6469 2
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			   "d,v,t", tempreg, breg, mips_gp_register);
d6559 1
a6559 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d6567 3
a6569 3
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu", "t,r,j", AT,
		       mips_gp_register, (int) BFD_RELOC_GPREL16);
d6655 2
a6656 3
			 HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			 "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16,
			 mips_gp_register);
d6839 2
a6840 3
			       HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
			       ? "add" : "addu" : "daddu",
			       "d,v,t", AT, breg, mips_gp_register);
d6893 1
a6893 3
	      macro_build (p, &icnt, (expressionS *) NULL,
			   HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
			   ? "add" : "addu" : "daddu",
d6939 3
a6941 3
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)", AT,
		       (int) BFD_RELOC_MIPS_GOT16, mips_gp_register);
d6945 1
a6945 3
			 HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
			 ? "add" : "addu" : "daddu",
			 "d,v,t", AT, breg, AT);
d7004 2
a7005 5
		       HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
		       ? "add" : "addu" : "daddu",
		       "d,v,t", AT, AT, mips_gp_register);
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d7010 1
a7010 3
			 HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
			 ? "add" : "addu" : "daddu",
			 "d,v,t", AT, breg, AT);
d7037 1
a7037 2
	  macro_build (p, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d7045 1
a7045 3
	      macro_build (p, &icnt, (expressionS *) NULL,
			   HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
			   ? "add" : "addu" : "daddu",
d7084 2
a7085 2
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			   "d,v,t", AT, breg, mips_gp_register);
d7611 1
a7611 2
		       "t,r,j", dreg, sreg,
		       (int) BFD_RELOC_LO16);
d7969 1
a7969 3
		     HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
		     ? "add" : "addu" : "daddu",
		     "d,v,t", AT, AT, breg);
d7990 1
a7990 3
		     HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
		     ? "add" : "addu" : "daddu",
		     "d,v,t", AT, AT, breg);
d8063 1
a8063 3
		     HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
		     ? "add" : "addu" : "daddu",
		     "d,v,t", AT, AT, breg);
d8083 1
a8083 3
		     HAVE_32BIT_ADDRESSES ? HAVE_NEWABI
		     ? "add" : "addu" : "daddu",
		     "d,v,t", AT, AT, breg);
d12641 2
a12642 3
  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
	       HAVE_64BIT_ADDRESSES ? "daddu" : "add", "d,v,t",
	       mips_gp_register, mips_gp_register, reg1);
d12690 1
a12690 2
  macro_build_ldst_constoffset ((char *) NULL, &icnt, &ex,
				HAVE_32BIT_ADDRESSES ? "sw" : "sd",
d12858 1
a12858 2
  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
	       HAVE_32BIT_ADDRESSES ? HAVE_NEWABI ? "add" : "addu" : "daddu",
@


1.215
log
@	* config/tc-mips.c (s_cpsetup): Use mips_frame_reg instead of SP.
	(s_cprestore): Likewise.
	(s_cpreturn): Likewise.
@
text
@a2156 2
	  reloc_howto_type *howto;

d2161 10
a2170 1
	      howto = bfd_reloc_type_lookup (stdoutput, reloc_type[0]);
d2217 16
a2232 71
	      if (reloc_type[1] != BFD_RELOC_UNUSED)
		{
		  /* FIXME: This symbol can be one of
		     RSS_UNDEF, RSS_GP, RSS_GP0, RSS_LOC.  */
		  address_expr->X_op = O_absent;
		  address_expr->X_add_symbol = 0;
		  address_expr->X_add_number = 0;

		  howto = bfd_reloc_type_lookup (stdoutput, reloc_type[1]);
		  fixp[1] = fix_new_exp (frag_now, f - frag_now->fr_literal,
					 bfd_get_reloc_size(howto),
					 address_expr, FALSE, reloc_type[1]);

		  /* These relocations can have an addend that won't fit in
		     4 octets for 64bit assembly.  */
		  if (HAVE_64BIT_GPRS
		      && ! howto->partial_inplace
		      && (reloc_type[1] == BFD_RELOC_16
			  || reloc_type[1] == BFD_RELOC_32
			  || reloc_type[1] == BFD_RELOC_MIPS_JMP
			  || reloc_type[1] == BFD_RELOC_HI16_S
			  || reloc_type[1] == BFD_RELOC_LO16
			  || reloc_type[1] == BFD_RELOC_GPREL16
			  || reloc_type[1] == BFD_RELOC_MIPS_LITERAL
			  || reloc_type[1] == BFD_RELOC_GPREL32
			  || reloc_type[1] == BFD_RELOC_64
			  || reloc_type[1] == BFD_RELOC_CTOR
			  || reloc_type[1] == BFD_RELOC_MIPS_SUB
			  || reloc_type[1] == BFD_RELOC_MIPS_HIGHEST
			  || reloc_type[1] == BFD_RELOC_MIPS_HIGHER
			  || reloc_type[1] == BFD_RELOC_MIPS_SCN_DISP
			  || reloc_type[1] == BFD_RELOC_MIPS_REL16
			  || reloc_type[1] == BFD_RELOC_MIPS_RELGOT))
		    fixp[1]->fx_no_overflow = 1;

		  if (reloc_type[2] != BFD_RELOC_UNUSED)
		    {
		      address_expr->X_op = O_absent;
		      address_expr->X_add_symbol = 0;
		      address_expr->X_add_number = 0;

		      howto = bfd_reloc_type_lookup (stdoutput, reloc_type[2]);
		      fixp[2] = fix_new_exp (frag_now,
					     f - frag_now->fr_literal,
					     bfd_get_reloc_size(howto),
					     address_expr, FALSE,
					     reloc_type[2]);

		      /* These relocations can have an addend that won't fit in
			 4 octets for 64bit assembly.  */
		      if (HAVE_64BIT_GPRS
			  && ! howto->partial_inplace
			  && (reloc_type[2] == BFD_RELOC_16
			      || reloc_type[2] == BFD_RELOC_32
			      || reloc_type[2] == BFD_RELOC_MIPS_JMP
			      || reloc_type[2] == BFD_RELOC_HI16_S
			      || reloc_type[2] == BFD_RELOC_LO16
			      || reloc_type[2] == BFD_RELOC_GPREL16
			      || reloc_type[2] == BFD_RELOC_MIPS_LITERAL
			      || reloc_type[2] == BFD_RELOC_GPREL32
			      || reloc_type[2] == BFD_RELOC_64
			      || reloc_type[2] == BFD_RELOC_CTOR
			      || reloc_type[2] == BFD_RELOC_MIPS_SUB
			      || reloc_type[2] == BFD_RELOC_MIPS_HIGHEST
			      || reloc_type[2] == BFD_RELOC_MIPS_HIGHER
			      || reloc_type[2] == BFD_RELOC_MIPS_SCN_DISP
			      || reloc_type[2] == BFD_RELOC_MIPS_REL16
			      || reloc_type[2] == BFD_RELOC_MIPS_RELGOT))
			fixp[2]->fx_no_overflow = 1;
		    }
		}
@


1.214
log
@	* config/tc-mips.c (tc_gen_reloc): Initialize retval amd reloc
	with zeros.
@
text
@d12748 1
a12748 1
		   mips_gp_register, (int) BFD_RELOC_LO16, SP);
d12825 1
a12825 1
				mips_gp_register, SP);
d12860 1
a12860 1
		   mips_gp_register, (int) BFD_RELOC_LO16, SP);
@


1.213
log
@	* elf32-mips.c (mips_elf_generic_reloc): New Function.
	(elf_mips_howto_table_rel): Use it.
	(gprel32_with_gp): Move prototype.
	(mips_elf_hi16_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Use mips_elf_generic_reloc.
	(mips_elf_got16_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Code cleanup.
	(_bfd_mips_elf32_gprel16_reloc): Check for ! BSF_LOCAL instead of
	zero addend.
	(mips_elf_gprel32_reloc): Likewise. Use the same GP assignment logic
	as in the other *_gprel*_reloc functions.
	(gprel32_with_gp): Handle partial_inplace properly.
	(mips32_64bit_reloc): Use mips_elf_generic_reloc.
	(mips16_gprel_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Do addend handling directly instead of calling
	_bfd_mips_elf_gprel16_with_gp. Handle partial_inplace properly.
	* elf64-mips.c (mips_elf64_hi16_reloc): Check for ! BSF_LOCAL instead
	of zero addend. Handle partial_inplace properly.
	(mips_elf64_got16_reloc): Check for ! BSF_LOCAL instead of zero
	addend.
	(mips_elf64_gprel16_reloc): Likewise.
	(mips_elf64_literal_reloc): Likewise.
	(mips_elf64_gprel32_reloc): Likewise. Use the same GP assignment
	logic as in the other *_gprel*_reloc functions. Handle
	partial_inplace properly.
	(mips_elf64_shift6_reloc): Check for ! BSF_LOCAL instead of zero
	addend. Handle partial_inplace properly.
	(mips16_gprel_reloc): Likewise. Do addend handling directly instead
	of calling _bfd_mips_elf_gprel16_with_gp.
	* elfn32-mips.c (mips_elf_got16_reloc): Check for BSF_LOCAL.
	(mips_elf_gprel32_reloc): Check for ! BSF_LOCAL instead
	of zero addend.
	(mips_elf_shift6_reloc): Handle partial_inplace properly.
	(mips16_gprel_reloc): Likewise. Do addend handling directly instead
	of calling _bfd_mips_elf_gprel16_with_gp.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp): Handle
	partial_inplace properly. Fix wrong addend handling. Fix overflow
	check.
	(_bfd_mips_elf_sign_extend): Renamed from mips_elf_sign_extend and
	exported.
	(mips_elf_calculate_relocation): Use _bfd_mips_elf_sign_extend.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_dynamic_relocation): Update sec_info_type access.
	* elfxx-mips.h (_bfd_mips_relax_section): Fix prototype declaration.
	(_bfd_mips_elf_sign_extend): New prototype.
	* config/tc-mips.c (md_pcrel_from): Return actual pcrel address.
	(md_apply_fix3): Ignore non-special relocations. Remove superfluous
	exceptions from size assert. Remove most of the addend fixup
	specialcasing. Remove value, use valP directly. simplify fx_addnumber
	handling. Remove zero addend specialcases.
	(tc_gen_reloc): Use appropriate value for reloc2 addend. Remove
	the addend fixup specialcase.
	* config/tc-mips.h (MD_APPLY_SYM_VALUE): Define as 0.
@
text
@d13680 2
a13681 3
  reloc = retval[0] = (arelent *) xmalloc (sizeof (arelent));
  retval[1] = NULL;

a13785 1
      retval[2] = NULL;
a13800 1
	  retval[3] = NULL;
@


1.212
log
@2003-06-03  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c: (OPTION_ARCH_BASE, OPTION_ASE_BASE)
        (OPTION_COMPAT_ARCH_BASE, OPTION_FIX_BASE)
        (OPTION_MISC_BASE): New defines.
        (OPTION_BREAK, OPTION_CONSTRUCT_FLOATS, OPTION_EB, OPTION_EL)
        (OPTION_ELF_BASE, OPTION_FIX_VR4122, OPTION_FP32, OPTION_FP64)
        (OPTION_GP32, OPTION_GP64, OPTION_M3900, OPTION_M4010, OPTION_M4100)
        (OPTION_M4650, OPTION_M7000_HILO_FIX, OPTION_MARCH, OPTION_MDMX)
        (OPTION_MEMBEDDED_PIC, OPTION_MIPS1, OPTION_MIPS16, OPTION_MIPS2)
        (OPTION_MIPS3, OPTION_MIPS32, OPTION_MIPS32R2, OPTION_MIPS3D)
        (OPTION_MIPS4, OPTION_MIPS5, OPTION_MIPS64)
        (OPTION_MNO_7000_HILO_FIX, OPTION_MTUNE, OPTION_NO_CONSTRUCT_FLOATS)
        (OPTION_NO_FIX_VR4122, OPTION_NO_M3900, OPTION_NO_M4010)
        (OPTION_NO_M4100, OPTION_NO_M4650, OPTION_NO_MDMX, OPTION_NO_MIPS16)
        (OPTION_NO_MIPS3D, OPTION_NO_RELAX_BRANCH, OPTION_RELAX_BRANCH)
        (OPTION_TRAP): Redefine in terms of new defines.
        (md_longopts): Reorder entries.
@
text
@d11384 10
a11393 7
  if (OUTPUT_FLAVOR != bfd_target_aout_flavour
      && fixP->fx_addsy != (symbolS *) NULL
      && ! S_IS_DEFINED (fixP->fx_addsy))
    return 4;

  /* Return the address of the delay slot.  */
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
a11653 1
  valueT value;
d11655 1
d11657 4
a11660 4
  /* FIXME: Maybe just return for all reloc types not listed below?
     Eric Christopher says: "This is stupid, please rewrite md_apply_fix3. */
  if (fixP->fx_r_type == BFD_RELOC_8)
      return;
a11663 7
	  || fixP->fx_r_type == BFD_RELOC_32
	  || fixP->fx_r_type == BFD_RELOC_MIPS_JMP
	  || fixP->fx_r_type == BFD_RELOC_HI16_S
	  || fixP->fx_r_type == BFD_RELOC_LO16
	  || fixP->fx_r_type == BFD_RELOC_GPREL16
	  || fixP->fx_r_type == BFD_RELOC_MIPS_LITERAL
	  || fixP->fx_r_type == BFD_RELOC_GPREL32
a11666 5
	  || fixP->fx_r_type == BFD_RELOC_MIPS_HIGHEST
	  || fixP->fx_r_type == BFD_RELOC_MIPS_HIGHER
	  || fixP->fx_r_type == BFD_RELOC_MIPS_SCN_DISP
	  || fixP->fx_r_type == BFD_RELOC_MIPS_REL16
	  || fixP->fx_r_type == BFD_RELOC_MIPS_RELGOT
d11668 1
a11668 2
	  || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY
	  || fixP->fx_r_type == BFD_RELOC_MIPS_JALR);
d11670 1
a11670 1
  value = *valP;
d11677 32
a11708 69
      if (mips_need_elf_addend_fixup (fixP))
	{
	  reloc_howto_type *howto;
	  valueT symval = S_GET_VALUE (fixP->fx_addsy);

	  value -= symval;

	  howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
	  if (value != 0 && howto && howto->partial_inplace)
	    {
	      /* In this case, the bfd_install_relocation routine will
		 incorrectly add the symbol value back in.  We just want
		 the addend to appear in the object file.

		 The condition above used to include
		 "&& (! fixP->fx_pcrel || howto->pcrel_offset)".

		 However, howto can't be trusted here, because we
		 might change the reloc type in tc_gen_reloc.  We can
		 check howto->partial_inplace because that conversion
		 happens to preserve howto->partial_inplace; but it
		 does not preserve howto->pcrel_offset.  I've just
		 eliminated the check, because all MIPS PC-relative
		 relocations are marked howto->pcrel_offset.

		 howto->pcrel_offset was originally added for
		 R_MIPS_PC16, which is generated for code like

		 	globl g1 .text
			.text
			.space 20
		 g1:
		 x:
		 	bal g1
	       */
	      value -= symval;

	      /* Make sure the addend is still non-zero.  If it became zero
		 after the last operation, set it to a spurious value and
		 subtract the same value from the object file's contents.  */
	      if (value == 0)
		{
		  value = 8;

		  /* The in-place addends for LO16 relocations are signed;
		     leave the matching HI16 in-place addends as zero.  */
		  if (fixP->fx_r_type != BFD_RELOC_HI16_S)
		    {
		      bfd_vma contents, mask, field;

		      contents = bfd_get_bits (fixP->fx_frag->fr_literal
					       + fixP->fx_where,
					       fixP->fx_size * 8,
					       target_big_endian);

		      /* MASK has bits set where the relocation should go.
			 FIELD is -value, shifted into the appropriate place
			 for this relocation.  */
		      mask = 1 << (howto->bitsize - 1);
		      mask = (((mask - 1) << 1) | 1) << howto->bitpos;
		      field = (-value >> howto->rightshift) << howto->bitpos;

		      bfd_put_bits ((field & mask) | (contents & ~mask),
				    fixP->fx_frag->fr_literal + fixP->fx_where,
				    fixP->fx_size * 8,
				    target_big_endian);
		    }
		}
	    }
d11715 1
a11715 1
      if (fixP->fx_pcrel || fixP->fx_subsy != NULL)
d11717 1
a11717 1
	  value += fixP->fx_frag->fr_address + fixP->fx_where;
d11722 1
a11722 3
	  if (fixP->fx_r_type != BFD_RELOC_16_PCREL_S2
	      || S_GET_SEGMENT (fixP->fx_addsy) != undefined_section)
	    value += fixP->fx_frag->fr_address + fixP->fx_where;
a11726 2
  fixP->fx_addnumber = value;	/* Remember value for tc_gen_reloc.  */

d11779 1
a11779 1
      fixP->fx_addnumber = 0;
d11785 1
a11785 3
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour
	  && !fixP->fx_done
	  && value != 0)
d11793 1
a11793 1
	  value += (fixP->fx_next->fx_frag->fr_address
d11796 1
a11796 2
      value = ((value + 0x8000) >> 16) & 0xffff;
      buf = (bfd_byte *) fixP->fx_frag->fr_literal + fixP->fx_where;
d11799 1
a11799 1
      md_number_to_chars ((char *) buf, value, 2);
d11805 1
a11805 3
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour
	  && !fixP->fx_done
	  && value != 0)
d11809 1
a11809 2
	value += fixP->fx_frag->fr_address + fixP->fx_where;
      buf = (bfd_byte *) fixP->fx_frag->fr_literal + fixP->fx_where;
d11812 1
a11812 1
      md_number_to_chars ((char *) buf, value, 2);
d11822 1
a11822 2
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
				value, 8);
d11825 1
a11825 2
	      long w1, w2;
	      long hiv;
d11827 1
a11827 7
	      w1 = w2 = fixP->fx_where;
	      if (target_big_endian)
		w1 += 4;
	      else
		w2 += 4;
	      md_number_to_chars (fixP->fx_frag->fr_literal + w1, value, 4);
	      if ((value & 0x80000000) != 0)
d11831 4
a11834 1
	      md_number_to_chars (fixP->fx_frag->fr_literal + w2, hiv, 4);
d11848 1
a11848 2
	md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			    value, 4);
d11856 1
a11856 2
	md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			    value, 2);
d11864 1
a11864 1
	  if (value + 0x8000 > 0xffff)
a11866 1
	  buf = (bfd_byte *) fixP->fx_frag->fr_literal + fixP->fx_where;
d11869 1
a11869 1
	  md_number_to_chars ((char *) buf, value, 2);
d11874 1
a11874 1
      if ((value & 0x3) != 0)
d11876 1
a11876 1
		      _("Branch to odd address (%lx)"), (long) value);
d11883 1
a11883 1
      if (!fixP->fx_done && (value != 0 || HAVE_NEWABI))
a11884 10
      /* If 'value' is zero, the remaining reloc code won't actually
	 do the store, so it must be done here.  This is probably
	 a bug somewhere.  */
      if (!fixP->fx_done
	  && (fixP->fx_r_type != BFD_RELOC_16_PCREL_S2
	      || fixP->fx_addsy == NULL			/* ??? */
	      || ! S_IS_DEFINED (fixP->fx_addsy)))
	value -= fixP->fx_frag->fr_address + fixP->fx_where;

      value = (offsetT) value >> 2;
a11886 1
      buf = (bfd_byte *) (fixP->fx_where + fixP->fx_frag->fr_literal);
d11892 13
a11904 3
      if (value + 0x8000 <= 0xffff)
	insn |= value & 0xffff;
      else
d11909 2
a11910 18
	  if (mips_pic == NO_PIC
	      && fixP->fx_done
	      && fixP->fx_frag->fr_address >= text_section->vma
	      && (fixP->fx_frag->fr_address
		  < text_section->vma + text_section->_raw_size)
	      && ((insn & 0xffff0000) == 0x10000000	 /* beq $0,$0 */
		  || (insn & 0xffff0000) == 0x04010000	 /* bgez $0 */
		  || (insn & 0xffff0000) == 0x04110000)) /* bgezal $0 */
	    {
	      if ((insn & 0xffff0000) == 0x04110000)	 /* bgezal $0 */
		insn = 0x0c000000;	/* jal */
	      else
		insn = 0x08000000;	/* j */
	      fixP->fx_r_type = BFD_RELOC_MIPS_JMP;
	      fixP->fx_done = 0;
	      fixP->fx_addsy = section_symbol (text_section);
	      fixP->fx_addnumber = (value << 2) + md_pcrel_from (fixP);
	    }
d11912 14
a11925 7
	    {
	      /* If we got here, we have branch-relaxation disabled,
		 and there's nothing we can do to fix this instruction
		 without turning it into a longer sequence.  */
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("Branch out of range"));
	    }
a11926 2

      md_number_to_chars ((char *) buf, (valueT) insn, 4);
d11944 3
d13793 1
a13793 1
      reloc2->addend = fixp->fx_addnumber
a13896 21

#ifdef OBJ_ELF
  /* md_apply_fix3 has a double-subtraction hack to get
     bfd_install_relocation to behave nicely.  GPREL relocations are
     handled correctly without this hack, so undo it here.  We can't
     stop md_apply_fix3 from subtracting twice in the first place since
     the fake addend is required for variant frags above.  */
  if (fixp->fx_addsy != NULL && OUTPUT_FLAVOR == bfd_target_elf_flavour
      && (code == BFD_RELOC_GPREL16 || code == BFD_RELOC_MIPS16_GPREL)
      && reloc->addend != 0
      && mips_need_elf_addend_fixup (fixp))
    {
      /* If howto->partial_inplace is false, md_apply_fix3 will only
	 subtract it once.  */
      reloc_howto_type *howto;

      howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
      if (howto->partial_inplace)
	reloc->addend += S_GET_VALUE (fixp->fx_addsy);
    }
#endif
@


1.211
log
@2003-05-23  Eric Christopher  <echristo@@redhat.com>

        * config/tc-mips.c (macro_build_jalr): Warning patrol.
@
text
@d10735 7
a10741 1
#define OPTION_MIPS1 (OPTION_MD_BASE + 1)
d10744 1
a10744 1
#define OPTION_MIPS2 (OPTION_MD_BASE + 2)
d10746 1
a10746 1
#define OPTION_MIPS3 (OPTION_MD_BASE + 3)
d10748 1
a10748 1
#define OPTION_MIPS4 (OPTION_MD_BASE + 4)
d10750 1
a10750 1
#define OPTION_MIPS5 (OPTION_MD_BASE + 5)
d10752 1
a10752 1
#define OPTION_MIPS32 (OPTION_MD_BASE + 6)
d10754 1
a10754 1
#define OPTION_MIPS64 (OPTION_MD_BASE + 7)
d10756 52
a10807 1
#define OPTION_MEMBEDDED_PIC (OPTION_MD_BASE + 8)
d10809 1
a10809 1
#define OPTION_TRAP (OPTION_MD_BASE + 9)
d10812 1
a10812 1
#define OPTION_BREAK (OPTION_MD_BASE + 10)
d10815 1
a10815 1
#define OPTION_EB (OPTION_MD_BASE + 11)
d10817 1
a10817 1
#define OPTION_EL (OPTION_MD_BASE + 12)
d10819 1
a10819 10
#define OPTION_MIPS16 (OPTION_MD_BASE + 13)
  {"mips16", no_argument, NULL, OPTION_MIPS16},
#define OPTION_NO_MIPS16 (OPTION_MD_BASE + 14)
  {"no-mips16", no_argument, NULL, OPTION_NO_MIPS16},
#define OPTION_M7000_HILO_FIX (OPTION_MD_BASE + 15)
  {"mfix7000", no_argument, NULL, OPTION_M7000_HILO_FIX},
#define OPTION_MNO_7000_HILO_FIX (OPTION_MD_BASE + 16)
  {"no-fix-7000", no_argument, NULL, OPTION_MNO_7000_HILO_FIX},
  {"mno-fix7000", no_argument, NULL, OPTION_MNO_7000_HILO_FIX},
#define OPTION_FP32 (OPTION_MD_BASE + 17)
d10821 1
a10821 1
#define OPTION_GP32 (OPTION_MD_BASE + 18)
d10823 1
a10823 1
#define OPTION_CONSTRUCT_FLOATS (OPTION_MD_BASE + 19)
d10825 1
a10825 1
#define OPTION_NO_CONSTRUCT_FLOATS (OPTION_MD_BASE + 20)
d10827 1
a10827 5
#define OPTION_MARCH (OPTION_MD_BASE + 21)
  {"march", required_argument, NULL, OPTION_MARCH},
#define OPTION_MTUNE (OPTION_MD_BASE + 22)
  {"mtune", required_argument, NULL, OPTION_MTUNE},
#define OPTION_FP64 (OPTION_MD_BASE + 23)
d10829 1
a10829 17
#define OPTION_M4650 (OPTION_MD_BASE + 24)
  {"m4650", no_argument, NULL, OPTION_M4650},
#define OPTION_NO_M4650 (OPTION_MD_BASE + 25)
  {"no-m4650", no_argument, NULL, OPTION_NO_M4650},
#define OPTION_M4010 (OPTION_MD_BASE + 26)
  {"m4010", no_argument, NULL, OPTION_M4010},
#define OPTION_NO_M4010 (OPTION_MD_BASE + 27)
  {"no-m4010", no_argument, NULL, OPTION_NO_M4010},
#define OPTION_M4100 (OPTION_MD_BASE + 28)
  {"m4100", no_argument, NULL, OPTION_M4100},
#define OPTION_NO_M4100 (OPTION_MD_BASE + 29)
  {"no-m4100", no_argument, NULL, OPTION_NO_M4100},
#define OPTION_M3900 (OPTION_MD_BASE + 30)
  {"m3900", no_argument, NULL, OPTION_M3900},
#define OPTION_NO_M3900 (OPTION_MD_BASE + 31)
  {"no-m3900", no_argument, NULL, OPTION_NO_M3900},
#define OPTION_GP64 (OPTION_MD_BASE + 32)
d10831 2
a10832 14
#define OPTION_MIPS3D (OPTION_MD_BASE + 33)
  {"mips3d", no_argument, NULL, OPTION_MIPS3D},
#define OPTION_NO_MIPS3D (OPTION_MD_BASE + 34)
  {"no-mips3d", no_argument, NULL, OPTION_NO_MIPS3D},
#define OPTION_MDMX (OPTION_MD_BASE + 35)
  {"mdmx", no_argument, NULL, OPTION_MDMX},
#define OPTION_NO_MDMX (OPTION_MD_BASE + 36)
  {"no-mdmx", no_argument, NULL, OPTION_NO_MDMX},
#define OPTION_FIX_VR4122 (OPTION_MD_BASE + 37)
#define OPTION_NO_FIX_VR4122 (OPTION_MD_BASE + 38)
  {"mfix-vr4122-bugs",    no_argument, NULL, OPTION_FIX_VR4122},
  {"no-mfix-vr4122-bugs", no_argument, NULL, OPTION_NO_FIX_VR4122},
#define OPTION_RELAX_BRANCH (OPTION_MD_BASE + 39)
#define OPTION_NO_RELAX_BRANCH (OPTION_MD_BASE + 40)
d10835 2
a10836 2
#define OPTION_MIPS32R2 (OPTION_MD_BASE + 41)
  {"mips32r2", no_argument, NULL, OPTION_MIPS32R2},
d10838 1
a10838 1
#define OPTION_ELF_BASE    (OPTION_MD_BASE + 42)
d10859 1
@


1.210
log
@	* config/tc-mips.c (append_insn): Use actual relocation size for new
	fixp's.	Don't relax overflow checking for partial_inplace relocations.
	Use the actual relocation type in combined relocs, not just the type
	of the first one.
	(macro_build_jalr): Use actual relocation size for new fix.
	(s_cpsetup, s_gpdword): Likewise.
@
text
@d3315 1
a3315 1
  char *f;
@


1.209
log
@	* config/tc-mips.c (macro): Don't use uninitialized tempreg.
@
text
@d2157 2
d2163 3
a2165 1
	      fixp[0] = fix_new_exp (frag_now, f - frag_now->fr_literal, 4,
d2167 1
a2167 1
				     *reloc_type == BFD_RELOC_16_PCREL_S2,
d2172 18
a2189 17
	      if (HAVE_64BIT_GPRS &&
		  (*reloc_type == BFD_RELOC_16
		   || *reloc_type == BFD_RELOC_32
		   || *reloc_type == BFD_RELOC_MIPS_JMP
		   || *reloc_type == BFD_RELOC_HI16_S
		   || *reloc_type == BFD_RELOC_LO16
		   || *reloc_type == BFD_RELOC_GPREL16
		   || *reloc_type == BFD_RELOC_MIPS_LITERAL
		   || *reloc_type == BFD_RELOC_GPREL32
		   || *reloc_type == BFD_RELOC_64
		   || *reloc_type == BFD_RELOC_CTOR
		   || *reloc_type == BFD_RELOC_MIPS_SUB
		   || *reloc_type == BFD_RELOC_MIPS_HIGHEST
		   || *reloc_type == BFD_RELOC_MIPS_HIGHER
		   || *reloc_type == BFD_RELOC_MIPS_SCN_DISP
		   || *reloc_type == BFD_RELOC_MIPS_REL16
		   || *reloc_type == BFD_RELOC_MIPS_RELGOT))
d2218 1
d2220 2
a2221 2
					 4, address_expr, FALSE,
					 reloc_type[1]);
d2225 18
a2242 17
		  if (HAVE_64BIT_GPRS &&
		      (*reloc_type == BFD_RELOC_16
		       || *reloc_type == BFD_RELOC_32
		       || *reloc_type == BFD_RELOC_MIPS_JMP
		       || *reloc_type == BFD_RELOC_HI16_S
		       || *reloc_type == BFD_RELOC_LO16
		       || *reloc_type == BFD_RELOC_GPREL16
		       || *reloc_type == BFD_RELOC_MIPS_LITERAL
		       || *reloc_type == BFD_RELOC_GPREL32
		       || *reloc_type == BFD_RELOC_64
		       || *reloc_type == BFD_RELOC_CTOR
		       || *reloc_type == BFD_RELOC_MIPS_SUB
		       || *reloc_type == BFD_RELOC_MIPS_HIGHEST
		       || *reloc_type == BFD_RELOC_MIPS_HIGHER
		       || *reloc_type == BFD_RELOC_MIPS_SCN_DISP
		       || *reloc_type == BFD_RELOC_MIPS_REL16
		       || *reloc_type == BFD_RELOC_MIPS_RELGOT))
d2251 1
d2253 2
a2254 1
					     f - frag_now->fr_literal, 4,
d2260 18
a2277 17
		      if (HAVE_64BIT_GPRS &&
			  (*reloc_type == BFD_RELOC_16
			   || *reloc_type == BFD_RELOC_32
			   || *reloc_type == BFD_RELOC_MIPS_JMP
			   || *reloc_type == BFD_RELOC_HI16_S
			   || *reloc_type == BFD_RELOC_LO16
			   || *reloc_type == BFD_RELOC_GPREL16
			   || *reloc_type == BFD_RELOC_MIPS_LITERAL
			   || *reloc_type == BFD_RELOC_GPREL32
			   || *reloc_type == BFD_RELOC_64
			   || *reloc_type == BFD_RELOC_CTOR
			   || *reloc_type == BFD_RELOC_MIPS_SUB
			   || *reloc_type == BFD_RELOC_MIPS_HIGHEST
			   || *reloc_type == BFD_RELOC_MIPS_HIGHER
			   || *reloc_type == BFD_RELOC_MIPS_SCN_DISP
			   || *reloc_type == BFD_RELOC_MIPS_REL16
			   || *reloc_type == BFD_RELOC_MIPS_RELGOT))
d3326 1
a3326 1
		 0, ep, FALSE, BFD_RELOC_MIPS_JALR);
d12818 1
a12818 1
	   0, NULL, 0, 0, BFD_RELOC_MIPS_SUB);
d12820 1
a12820 1
	   0, NULL, 0, 0, BFD_RELOC_HI16_S);
d12826 1
a12826 1
	   0, NULL, 0, 0, BFD_RELOC_MIPS_SUB);
d12828 1
a12828 1
	   0, NULL, 0, 0, BFD_RELOC_LO16);
d13017 1
a13017 1
  fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &ex, FALSE,
@


1.208
log
@2003-05-07  Eric Christopher  <echristo@@redhat.com>
	    Alexandre Oliva   <aoliva@@redhat.com>

	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Adjust
	pic tests, change to warning.
	(_bfd_mips_elf_final_link): Remove EF_MIPS_CPIC flag setting.

2003-05-07  Eric Christopher  <echristo@@redhat.com>

        * config/tc-mips.c (mips_abicalls): New variable.
        (md_parse_option): Use.
        (s_option): Ditto.
        (s_abicalls): Ditto.
        (mips_elf_final_processing): Set EF_MIPS_PIC and
        EF_MIPS_CPIC dependent on above.
@
text
@d5837 1
a5837 1
			       tempreg, (int) BFD_RELOC_MIPS_GOT_PAGE,
d5841 1
a5841 1
			       "t,r,j", tempreg, tempreg,
@


1.207
log
@* configure.in (MIPS_DEFAULT_ABI): AC_DEFINE.
* config/tc-mips.c (mips_after_parse_args): Set mips_abi to it.
* config.in, configure: Rebuilt.
@
text
@d134 3
d11044 1
d11060 1
d12438 1
d12440 2
d12665 1
d14452 1
d14454 4
@


1.206
log
@2003-05-05  H.J. Lu <hjl@@gnu.org>

	* config/tc-mips.c (tc_gen_reloc): Add addend just once if
	howto->partial_inplace is false.
@
text
@d11228 3
@


1.205
log
@	* config/tc-mips.c (mips_need_elf_addend_fixup): Remove
	symbol_used_in_reloc_p check.
	(md_apply_fix3): Remove check for howto->pcrel_offset.
@
text
@d13943 9
a13951 1
    reloc->addend += S_GET_VALUE (fixp->fx_addsy);
@


1.204
log
@2003-04-24  Eric Christopher  <echristo@@redhat.com>

        * config/tc-mips.c (nopic_need_relax): Revert previous
        change.
@
text
@d11595 6
a11600 7
  if (symbol_used_in_reloc_p (fixP->fx_addsy)
      && (((bfd_get_section_flags (stdoutput,
				   S_GET_SEGMENT (fixP->fx_addsy))
	    & (SEC_LINK_ONCE | SEC_MERGE)) != 0)
	  || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
		       ".gnu.linkonce",
		       sizeof (".gnu.linkonce") - 1)))
d11660 1
a11660 2
	  if (value != 0 && howto && howto->partial_inplace
	      && (! fixP->fx_pcrel || howto->pcrel_offset))
d11666 13
a11678 2
		 howto->pcrel_offset is added for R_MIPS_PC16, which is
		 generated for code like
@


1.204.2.1
log
@	* config/tc-mips.c (mips_need_elf_addend_fixup): Remove
	symbol_used_in_reloc_p check.
	(md_apply_fix3): Remove check for howto->pcrel_offset.
@
text
@d11595 7
a11601 6
  if (((bfd_get_section_flags (stdoutput,
			       S_GET_SEGMENT (fixP->fx_addsy))
	& (SEC_LINK_ONCE | SEC_MERGE)) != 0)
      || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
		   ".gnu.linkonce",
		   sizeof (".gnu.linkonce") - 1))
d11661 2
a11662 1
	  if (value != 0 && howto && howto->partial_inplace)
d11668 2
a11669 13
		 The condition above used to include
		 "&& (! fixP->fx_pcrel || howto->pcrel_offset)".

		 However, howto can't be trusted here, because we
		 might change the reloc type in tc_gen_reloc.  We can
		 check howto->partial_inplace because that conversion
		 happens to preserve howto->partial_inplace; but it
		 does not preserve howto->pcrel_offset.  I've just
		 eliminated the check, because all MIPS PC-relative
		 relocations are marked howto->pcrel_offset.

		 howto->pcrel_offset was originally added for
		 R_MIPS_PC16, which is generated for code like
@


1.204.2.2
log
@	Merge from mainline:

	2003-05-09  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* config/tc-s390.c (s390_target_format): Always call init_default_arch.

	2003-05-06  Alexandre Oliva  <aoliva@@redhat.com>
	* configure.in (MIPS_DEFAULT_ABI): AC_DEFINE.
	* config/tc-mips.c (mips_after_parse_args): Set mips_abi to it.
	* config.in, configure: Rebuilt.
@
text
@a11227 3
  if (mips_abi == NO_ABI)
    mips_abi = MIPS_DEFAULT_ABI;

@


1.204.2.3
log
@	* config/tc-mips.c (macro): Don't use uninitialized tempreg.
@
text
@d5834 1
a5834 1
			       PIC_CALL_REG, (int) BFD_RELOC_MIPS_GOT_PAGE,
d5838 1
a5838 1
			       "t,r,j", PIC_CALL_REG, PIC_CALL_REG,
@


1.203
log
@* config/tc-mips.h (tc_frag_data_type, TC_FRAG_TYPE): New.
* config/tc-mips.c: Use signed add for n32 address arithmetic.
(append_insn): When filling delay slots with instructions
that have fixups that tc_gen_reloc might consider modifyable
in variant frags, start a new frag.
(load_address): Generate GOT_DISP with of without offset
depending on whether symbol is local.  For -xgot, use
GOT_PAGE/GOT_OFST or GOT_HI16/GOT_LO16.
(macro) <M_DLA_AB, M_LA_AB>: Likewise.
<M_JAL_A>: In NewABI, use CALL16 or GOT_DISP for small got,
CALL_HI16/CALL_LO16 or GOT_PAGE/GOT_OFST for big got.
<ld_st>: In NewABI with small got, always use
GOT_PAGE/GOT_OFST, with the latter in the load/store
instruction.  With big got, use GOT_HI16/GOT_LO16 or
GOT_PAGE/GOT_OFST.
(tc_gen_reloc): Adjust variant frags with GOT_DISP in NewABI.
Add tc_frag_data.tc_fr_offset to addends.  Decay CALL16,
GOT_OFST and GOT_DISP to GOT_DISP in NewABI.
(md_convert_frag): Use memmove for safe copying of overlapping
regions.
@
text
@d3945 1
a3945 1
	  
d4021 1
a4021 1
	 If there is a constant, it must be added in after.  
d5601 1
a5601 1
	    }	      
d5841 1
a5841 1
	      
d6527 1
a6527 1
	  
d12256 1
a12256 1
  char next_c;
a13248 1
	       && !S_IS_EXTERN (sym)
@


1.202
log
@* config/tc-mips.c (macro): Add comments explaining the rationale
for Chris' change.
@
text
@d1634 1
d2610 12
d2763 9
d3420 2
a3421 1
		   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d3909 2
a3910 1
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu", "t,r,j",
d3921 2
a3922 1
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d3936 2
d3939 3
a3941 5
	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT_DISP)
	 If there is a constant, it must be added in after.  */
      ex.X_add_number = ep->X_add_number;
      ep->X_add_number = 0;
      frag_grow (20);
d3944 24
a3967 1
	  macro_build ((char *) NULL, counter, ep,
d3970 8
d3981 3
a3993 1
	}
d3995 9
a4003 8
      if (ex.X_add_number != 0)
	{
	  if (ex.X_add_number < -0x8000 || ex.X_add_number >= 0x8000)
	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	  ex.X_op = O_constant;
	  macro_build ((char *) NULL, counter, &ex,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		       "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d4016 2
a4017 1
	 Otherwise, for a reference to a local symbol, we want
d4021 3
a4023 1
	 If we have NewABI, we want
d4026 1
a4026 3
	 If there is a constant, it must be added in after.  */
      ex.X_add_number = ep->X_add_number;
      ep->X_add_number = 0;
d4029 10
d4040 18
d4060 2
a4061 2
	  macro_build (p, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu", "t,r,j",
d4066 2
a4102 1
	}
d4104 9
a4112 8
      if (ex.X_add_number != 0)
	{
	  if (ex.X_add_number < -0x8000 || ex.X_add_number >= 0x8000)
	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
	  ex.X_op = O_constant;
	  macro_build ((char *) NULL, counter, &ex,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		       "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d4893 2
a4894 1
		       (dbl || HAVE_64BIT_ADDRESSES) ? "daddiu" : "addiu",
d5037 2
a5038 1
		  macro_build ((char *) NULL, &icnt, &offset_expr, "addiu",
d5049 2
a5050 1
	      macro_build (p, &icnt, &offset_expr, "addiu",
d5054 1
a5054 1
      else if (mips_pic == SVR4_PIC && ! mips_big_got)
a5085 7

	     For NewABI, we want for local or external data addresses
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP)
	     For a local function symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_PAGE)
	       nop
	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_MIPS_GOT_OFST)
a5092 2
	  else if (HAVE_NEWABI)
	    lw_reloc_type = (int) BFD_RELOC_MIPS_GOT_DISP;
d5186 131
a5316 1
      else if (mips_pic == SVR4_PIC)
d5363 1
a5363 4

	     For NewABI, we want for local data addresses
              lw       $tempreg,<sym>($gp)     (BFD_RELOC_MIPS_GOT_DISP)
	   */
d5481 1
a5481 1
                 the first instruction on the main stream does not.  */
a5485 2
	  if (HAVE_NEWABI)
	    local_reloc_type = (int) BFD_RELOC_MIPS_GOT_DISP;
d5492 1
a5492 6
	  if (expr1.X_add_number == 0 && HAVE_NEWABI)
	    {
	      /* BFD_RELOC_MIPS_GOT_DISP is sufficient for newabi */
	    }
	 else
	   if (expr1.X_add_number >= -0x8000
d5501 4
a5504 4
                 register, the external symbol case ended with a load,
                 so if the symbol turns out to not be external, and
                 the next instruction uses tempreg, an unnecessary nop
                 will be inserted.  */
d5511 1
a5511 1
                     external symbol case.  */
d5521 1
a5521 1
                     it in in both cases.  */
d5537 140
d5694 2
a5695 1
	    s = (dbl || HAVE_64BIT_ADDRESSES) ? "daddu" : "addu";
d5697 1
a5697 1
	    s = HAVE_64BIT_ADDRESSES ? "daddu" : "addu";
d5796 5
a5800 4
	     For NewABI, we want
	       lw	$25,<sym>($gp)		(BFD_RELOC_MIPS_GOT_DISP)
	       jalr	$ra,$25			(BFD_RELOC_MIPS_JALR)
	   */
d5803 39
a5841 4
	      macro_build ((char *) NULL, &icnt, &offset_expr,
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", PIC_CALL_REG,
			   (int) BFD_RELOC_MIPS_GOT_DISP, mips_gp_register);
d6146 1
a6146 1
                        ? "addu" : "daddu"),
d6336 2
a6337 1
			       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d6349 2
a6350 1
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d6372 5
a6376 2
	     If we have NewABI, we want
	       lw	$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT_DISP)
d6384 18
a6403 2
	  if (HAVE_NEWABI)
	    lw_reloc_type = (int) BFD_RELOC_MIPS_GOT_DISP;
d6425 1
a6425 1
      else if (mips_pic == SVR4_PIC)
d6445 1
a6445 7
	     in which we are not using $at).

	     For NewABI, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_PAGE)
	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_MIPS_GOT_OFST)
	       <op>	$treg,0($tempreg)
	   */
a6451 22
	  if (HAVE_NEWABI)
	    {
	      macro_build ((char *) NULL, &icnt, &offset_expr,
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", tempreg, BFD_RELOC_MIPS_GOT_PAGE,
			   mips_gp_register);
	      macro_build ((char *) NULL, &icnt, &offset_expr,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
			   "t,r,j", tempreg, tempreg,
			   BFD_RELOC_MIPS_GOT_OFST);
	      if (breg != 0)
		macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			     HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			     "d,v,t", tempreg, tempreg, breg);
	      macro_build ((char *) NULL, &icnt, &expr1, s, fmt, treg,
			   (int) BFD_RELOC_LO16, tempreg);

	      if (! used_at)
		return;

	      break;
	    }
d6491 54
d6936 2
a6937 1
			       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d6992 2
a6993 1
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d7045 2
a7046 1
			 HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d7106 2
a7107 1
		       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d7115 2
a7116 1
			 HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d7154 2
a7155 1
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d8080 2
a8081 1
		     HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d8103 2
a8104 1
		     HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d8178 2
a8179 1
		     HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d8200 2
a8201 1
		     HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d12800 1
a12800 1
	       HAVE_64BIT_ADDRESSES ? "daddu" : "addu", "d,v,t",
d13019 1
a13019 1
	       HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d13777 2
d13812 1
d13820 2
a13821 1
      reloc2->addend = fixp->fx_addnumber;
a13849 3
	      fixp->fx_r_type = BFD_RELOC_MIPS_GOT16;
	      break;
	    case BFD_RELOC_MIPS_CALL16:
a13851 1
		  /* BFD_RELOC_MIPS_GOT16;*/
d13859 16
a13878 7

      /* newabi uses R_MIPS_GOT_DISP for local symbols */
      if (HAVE_NEWABI && fixp->fx_r_type == BFD_RELOC_MIPS_GOT_LO16)
	{
	  fixp->fx_r_type = BFD_RELOC_MIPS_GOT_DISP;
	  retval[1] = NULL;
	}
d14317 1
a14317 1
	memcpy (fixptr - old, fixptr, new);
@


1.201
log
@* config/tc-mips.c (macro): Put back `+ 0x8000' in test for 64-bit
constant address that Alexandre took out by accident.  Reject
64-bit addresses that are not sign extensions of 32 bits only if
we don't support 64-bit address constants.
@
text
@d5849 17
a5865 1
	   */
@


1.200
log
@* config/tc-mips.c (HAVE_64BIT_ADDRESS_CONSTANTS): New.
(macro): Use new macro to decide whether to emit constant address
as 32 or 64 bits if addresses are 32-bit wide but registers are
64-bit wide.
@
text
@d5852 1
a5852 1
		  && !IS_SEXT_32BIT_NUM (offset_expr.X_add_number)
d5901 1
@


1.199
log
@[ gas/ChangeLog ]
2003-04-02  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (macro2): Adjust implementation of
        M_ULH, M_ULHU, M_ULW, and M_ULD so that they work properly
        in the case where the source and destination registers
        are the same.

[ gas/testsuite/ChangeLog ]
2003-04-02  Chris Demetriou  <cgd@@broadcom.com>

        * gas/mips/ulh.d: Adjust for ulh and ulhu macro assembly changes.

        * gas/mips/mips.exp: Define new "gpr_ilocks" architecture
        property, and add it to mips2 (and later) chips and r3900.
        * gas/mips/uld2.s: New test source file.
        * gas/mips/ulh2.s: Likewise.
        * gas/mips/ulw2.s: Likewise.
        * gas/mips/uld2.l: New test stderr listing.
        * gas/mips/ulh2.l: Likewise.
        * gas/mips/ulw2.l: Likewise.
        * gas/mips/uld2-eb.d: New test.
        * gas/mips/uld2-el.d: Likewise.
        * gas/mips/ulh2-eb.d: Likewise.
        * gas/mips/ulh2-el.d: Likewise.
        * gas/mips/ulw2-eb-ilocks.d: Likewise.
        * gas/mips/ulw2-eb.d: Likewise.
        * gas/mips/ulw2-el-ilocks.d: Likewise.
        * gas/mips/ulw2-el.d: Likewise.
        * gas/mips/mips.exp: Run new tests for appropriate architectures.
@
text
@d297 2
d5850 4
a5853 3
	  if (HAVE_64BIT_ADDRESSES
	      && !(offset_expr.X_op == O_constant
		   && IS_SEXT_32BIT_NUM (offset_expr.X_add_number + 0x8000)))
d5900 3
@


1.198
log
@2003-03-26  Eric Christopher  <echristo@@redhat.com>

	* config/tc-mips.c (nopic_need_relax): Check for
        S_IS_EXTERN.
@
text
@a7556 1
      /* avoid load delay */
d7559 1
a7559 1
      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
d7565 1
a7565 1
      macro_build ((char *) NULL, &icnt, &offset_expr, "lbu", "t,o(b)", AT,
d7568 1
a7568 1
		   treg, treg, 8);
d7585 4
d7591 1
a7591 1
      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
d7597 1
a7597 1
      macro_build ((char *) NULL, &icnt, &offset_expr, s2, "t,o(b)", treg,
d7599 9
a7607 1
      return;
@


1.197
log
@* config/tc-mips.c (mips_validate_fix): New function.
* config/tc-mips.h (TC_VALIDATE_FIX): Define.
(mips_validate_fix): Declare.
@
text
@d12777 1
@


1.196
log
@* Reverted 2003-03-02's patch.
@
text
@d11029 79
@


1.195
log
@	* config/tc-mips.c (s_mips_end): Remove !BFD_ASSEMBLER case.
	(s_mips_ent): Likewise.
@
text
@d2021 1
a2021 2
      && (*reloc_type == BFD_RELOC_16_PCREL_S2
	  || *reloc_type == BFD_RELOC_MIPSEMB_16_PCREL_S2)
a2142 12
	      if ((address_expr->X_add_number & 3) != 0)
		as_bad (_("branch to misaligned address (0x%lx)"),
			(unsigned long) address_expr->X_add_number);
	      if (mips_relax_branch)
		goto need_reloc;
	      if ((address_expr->X_add_number + 0x20000) & ~0x3ffff)
		as_bad (_("branch address range overflow (0x%lx)"),
			(unsigned long) address_expr->X_add_number);
	      ip->insn_opcode |= (address_expr->X_add_number >> 2) & 0xffff;
	      break;

	    case BFD_RELOC_MIPSEMB_16_PCREL_S2:
d2157 1
a2157 2
				     (*reloc_type == BFD_RELOC_16_PCREL_S2
				      || *reloc_type == BFD_RELOC_MIPSEMB_16_PCREL_S2),
a3106 1

d3110 3
a3112 3
	   *
	   * We don't allow branch relaxation for these branches, as
	   * they should only appear in ".set nomacro" anyway.
a3115 6
	      if ((ep->X_add_number & 3) != 0)
		as_bad (_("branch to misaligned address (0x%lx)"),
			(unsigned long) ep->X_add_number);
	      if ((ep->X_add_number + 0x20000) & ~0x3ffff)
		as_bad (_("branch address range overflow (0x%lx)"),
			(unsigned long) ep->X_add_number);
d3120 1
a3120 6
	    {
	      if (mips_pic == EMBEDDED_PIC)
		*r = BFD_RELOC_MIPSEMB_16_PCREL_S2;
	      else
		*r = BFD_RELOC_16_PCREL_S2;
	    }
d9157 1
a9157 4
	      if (mips_pic == EMBEDDED_PIC)
		*offset_reloc = BFD_RELOC_MIPSEMB_16_PCREL_S2;
	      else
		*offset_reloc = BFD_RELOC_16_PCREL_S2;
d11174 1
a11174 2
	  if ((fixP->fx_r_type != BFD_RELOC_16_PCREL_S2
	       && fixP->fx_r_type != BFD_RELOC_MIPSEMB_16_PCREL_S2)
a11343 1
    case BFD_RELOC_MIPSEMB_16_PCREL_S2:
d11346 1
a11346 1
		      _("Branch to misaligned address (%lx)"), (long) value);
d11359 2
a11360 1
	  && (fixP->fx_addsy == NULL			/* ??? */
a13353 1
	case BFD_RELOC_MIPSEMB_16_PCREL_S2:
d13377 11
a13387 1
  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
d13473 2
a13474 3
			      4, &exp, 1, ((mips_pic == EMBEDDED_PIC)
					   ? BFD_RELOC_MIPSEMB_16_PCREL_S2
					   : BFD_RELOC_16_PCREL_S2));
@


1.194
log
@	* elf32-mips.c (elf_mips_howto_table_rel): Change definition of
	R_MIPS_PC16 to rightshift 2.
	(elf_reloc_map mips_reloc_map): Map to rightshifted BFD reloc.
	(bfd_elf32_bfd_reloc_type_lookup): Support
	BFD_RELOC_MIPSEMB_16_PCREL_S2.
	* elf64-mips.c (mips_elf64_howto_table_rel): Change definition of
	R_MIPS_PC16 to rightshift 2.
	(mips_elf64_howto_table_rela): Likewise.
	(mips_reloc_map): Map to rightshifted BFD reloc.
	* elfn32-mips.c: The same as in elf64-mips.c.
	* elfxx-mips.c (mips_elf_got_for_ibfd): Typo in comment.
	(mips_elf_calculate_relocation): Handle rightshifted addends for
	R_MIPS_PC16.
	* reloc.c (BFD_RELOC_MIPSEMB_16_PCREL_S2): New BFD relocation for
	MIPS Embedded PIC. Remove superfluous empty COMMENT.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* config/tc-mips.c (append_insn): Add handling of
	BFD_RELOC_MIPSEMB_16_PCREL_S2. Avoid emitting unneeded
	BFD_RELOC_16_PCREL_S2 relocs and add earlier warnings about
	misaligned address and reange overflow.
	(macro_build): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2. Add
	earlier warnings about misaligned address and reange overflow.
	(mips_ip): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	(md_apply_fix): Likewise. Fix warning output.
	(tc_gen_reloc): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	Allow BFD_RELOC_16_PCREL_S2 for all ABIs.
	(md_convert_frag): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	* gas/mips/bge.d: Reactivate external branch tests.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.d: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.d: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.d: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.d: New File.
	* gas/mips/branch-misc-2.l: Remove.
	* gas/mips/mips.exp: Adjust branch-misc-2 test.
@
text
@a14082 1
  int maybe_text;
d14096 1
a14096 13
#ifdef BFD_ASSEMBLER
  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    maybe_text = 1;
  else
    maybe_text = 0;
#else
  if (now_seg != data_section && now_seg != bss_section)
    maybe_text = 1;
  else
    maybe_text = 0;
#endif

  if (!maybe_text)
a14167 1
  int maybe_text;
d14177 1
a14177 13
#ifdef BFD_ASSEMBLER
  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    maybe_text = 1;
  else
    maybe_text = 0;
#else
  if (now_seg != data_section && now_seg != bss_section)
    maybe_text = 1;
  else
    maybe_text = 0;
#endif

  if (!maybe_text)
@


1.193
log
@	* config/tc-mips.c (prev_reloc_op_frag): New variable.
	(macro): Check it to decide whether a new frag is needed.
	(my_getSmallExpression): Set it.
@
text
@d2021 2
a2022 1
      && *reloc_type == BFD_RELOC_16_PCREL_S2
d2144 12
d2170 2
a2171 1
				     *reloc_type == BFD_RELOC_16_PCREL_S2,
d3121 1
d3125 3
a3127 3
	   * Note that the expression still might come from the assembly
	   * input, in which case the value is not checked for range nor
	   * is a relocation entry generated (yuck).
d3131 6
d3141 6
a3146 1
	    *r = BFD_RELOC_16_PCREL_S2;
d9183 4
a9186 1
	      *offset_reloc = BFD_RELOC_16_PCREL_S2;
d11203 2
a11204 1
	  if (fixP->fx_r_type != BFD_RELOC_16_PCREL_S2
d11374 1
d11377 1
a11377 1
		      _("Branch to odd address (%lx)"), (long) value);
d11390 1
a11390 2
	  && (fixP->fx_r_type != BFD_RELOC_16_PCREL_S2
	      || fixP->fx_addsy == NULL			/* ??? */
d13384 1
d13408 1
a13408 11
  /* To support a PC relative reloc when generating embedded PIC code
     for ECOFF, we use a Cygnus extension.  We check for that here to
     make sure that we don't let such a reloc escape normally.  */
  if ((OUTPUT_FLAVOR == bfd_target_ecoff_flavour
       || OUTPUT_FLAVOR == bfd_target_elf_flavour)
      && code == BFD_RELOC_16_PCREL_S2
      && mips_pic != EMBEDDED_PIC)
    reloc->howto = NULL;
  else
    reloc->howto = bfd_reloc_type_lookup (stdoutput, code);

d13494 3
a13496 2
			      4, &exp, 1,
			      BFD_RELOC_16_PCREL_S2);
@


1.192
log
@gas/
	* config/tc-mips.c (reloc_needs_lo_p): New function.
	(fixup_has_matching_lo_p): New function.
	(append_insn): Use reloc_needs_lo_p to check whether a relocation
	might need a matching %lo().  Reuse the head of mips_hi_fixup_list
	if that fixup already has a matching %lo().  Don't call frag_wane here.
	(macro): Call frag_wane here if the last unmatched hi was in the
	current frag.
	(pic_need_relax): New function, split out from...
	(md_estimate_size_before_relax): ...here.
	(mips_frob_file): Use reloc_needs_lo_p.  Use pic_need_relax to test
	whether BFD_RELOC_MIPS_GOT16 fixups refer to global symbols.

gas/testsuite/
	* gas/mips/rel12.[sd], gas/mips/rel13.[sd]: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d558 5
d4114 7
a4120 4
     If it looks like this situation could happen, put the macro
     in a new frag.  */
  if (mips_hi_fixup_list != 0
      && mips_hi_fixup_list->fixp->fx_frag == frag_now)
d10114 8
a10121 3
  reloc[0] = BFD_RELOC_LO16;
  for (i = 0; i < reloc_index; i++)
    reloc[i] = reversed_reloc[reloc_index - 1 - i];
@


1.191
log
@	* config/tc-mips.c (my_getSmallExpression): Rework bracket handling.

testsuite/
	* gas/mips/expr1.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d804 4
d939 2
d1448 25
a1626 1
  bfd_boolean unmatched_reloc_p;
a1632 1
  unmatched_reloc_p = FALSE;
d2176 1
a2176 1
	      if (reloc_type[0] == BFD_RELOC_HI16_S)
d2180 10
a2189 2
		  hi_fixup = ((struct mips_hi_fixup *)
			      xmalloc (sizeof (struct mips_hi_fixup)));
a2191 3
		  hi_fixup->next = mips_hi_fixup_list;
		  mips_hi_fixup_list = hi_fixup;
		  unmatched_reloc_p = TRUE;
a2742 10

  /* We must ensure that a fixup associated with an unmatched %hi
     reloc does not become a variant frag.  Otherwise, the
     rearrangement of %hi relocs in frob_file may confuse
     tc_gen_reloc.  */
  if (unmatched_reloc_p)
    {
      frag_wane (frag_now);
      frag_new (0);
    }
d4097 21
d10906 7
a10912 1
      assert (l->fixp->fx_r_type == BFD_RELOC_HI16_S);
d10914 2
a10915 6
      /* Check quickly whether the next fixup happens to be a matching
         %lo.  */
      if (l->fixp->fx_next != NULL
	  && l->fixp->fx_next->fx_r_type == BFD_RELOC_LO16
	  && l->fixp->fx_addsy == l->fixp->fx_next->fx_addsy
	  && l->fixp->fx_offset == l->fixp->fx_next->fx_offset)
d10937 2
a10938 3
		      || prev->fx_r_type != BFD_RELOC_HI16_S
		      || prev->fx_addsy != f->fx_addsy
		      || prev->fx_offset !=  f->fx_offset))
d12721 58
d13057 1
a13057 2
  int change = 0;
  bfd_boolean linkonce = FALSE;
d13073 1
a13073 3
    {
      change = nopic_need_relax (fragp->fr_symbol, 0);
    }
d13075 1
a13075 50
    {
      symbolS *sym;
      asection *symsec;

      sym = fragp->fr_symbol;

      /* Handle the case of a symbol equated to another symbol.  */
      while (symbol_equated_reloc_p (sym))
	{
	  symbolS *n;

	  /* It's possible to get a loop here in a badly written
             program.  */
	  n = symbol_get_value_expression (sym)->X_add_symbol;
	  if (n == sym)
	    break;
	  sym = n;
	}

      symsec = S_GET_SEGMENT (sym);

      /* duplicate the test for LINK_ONCE sections as in adjust_reloc_syms */
      if (symsec != segtype && ! S_IS_LOCAL (sym))
	{
	  if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE)
	      != 0)
	    linkonce = TRUE;

	  /* The GNU toolchain uses an extension for ELF: a section
	     beginning with the magic string .gnu.linkonce is a linkonce
	     section.  */
	  if (strncmp (segment_name (symsec), ".gnu.linkonce",
		       sizeof ".gnu.linkonce" - 1) == 0)
	    linkonce = TRUE;
	}

      /* This must duplicate the test in adjust_reloc_syms.  */
      change = (symsec != &bfd_und_section
		&& symsec != &bfd_abs_section
		&& ! bfd_is_com_section (symsec)
		&& !linkonce
#ifdef OBJ_ELF
		/* A global or weak symbol is treated as external.  */
	  	&& (OUTPUT_FLAVOR != bfd_target_elf_flavour
		    || (! S_IS_WEAK (sym)
			&& (! S_IS_EXTERNAL (sym)
			    || mips_pic == EMBEDDED_PIC)))
#endif
		);
    }
@


1.190
log
@gas/
	* config/tc-mips.c (enum small_ex_type): Remove.
	(imm_unmatched_hi): Remove.
	(md_assemble): Remove use of imm_unmatched_hi.  Remove the last
	argument from calls to append_insn.
	(append_insn): Remove unmatched_hi parameter; check reloc_type[0]
	instead.
	(macro_build): Update append_insn calls.
	(mips16_macro_build, macro_build_lui): Likewise.
	(mips_ip): Rework handling of small expressions.  Move explicit
	relocation handling into my_getSmallExpression.  Assume that the
	value of 'o' operands is zero if there is only one bracketed
	expression left.
	(percent_op): Make constant.  Record the BFD relocation code
	associated with each operator.
	(my_getSmallParser, my_getPercentOp): Remove.
	(parse_relocation): New function.
	(my_getSamllExpression): Rework.  Fill in relocations here
	rather than in mips_ip.

gas/testsuite
	* gas/mips/elf-rel8.[sd], gas/mips/elf-rel9.[sd],
	gas/mips/elf-rel10.[sd], gas/mips/elf-rel11.[sd]: New tests.
	* gas/mips/mips.exp: Run elf-rel8 and elf-rel9 for all elf
	targets.  Run elf-rel10 and elf-rel11 for NewABI targets.
@
text
@d10023 2
a10024 4
  int bracket_depth;

  reloc_index = 0;
  bracket_depth = 0;
d10027 6
a10032 2
     in REVERSED_RELOC.  */
  for (;;)
d10034 9
a10042 10
      if (*str == '(')
	bracket_depth++, str++;
      else if (*str == ' ' || *str == '\t')
	str++;
      else if (*str == '%'
	       && reloc_index < (HAVE_NEWABI ? 3 : 1)
	       && parse_relocation (&str, &reversed_reloc[reloc_index]))
	reloc_index++;
      else
	break;
d10044 3
d10048 1
a10048 1
  my_getExpression (ep, str);
d10052 1
a10052 1
  while (bracket_depth > 0 && (*str == ')' || *str == ' ' || *str == '\t'))
d10054 1
a10054 1
      bracket_depth--;
d10056 1
a10056 1
  if (bracket_depth > 0)
@


1.189
log
@* configure.in (em): Set to irix on all Irix systems.
* configure: Rebuilt.
* config/te-irix.h: New file.
* config/tc-mips.c (mips_dwarf2_format): Use TE_IRIX to decide
whether to use Irix-specific 64-bit format.
@
text
@d813 1
a813 1
	   bfd_reloc_code_real_type *r, bfd_boolean));
d859 4
a862 6
static int my_getPercentOp
  PARAMS ((char **, unsigned int *, int *));
static int my_getSmallParser
  PARAMS ((char **, unsigned int *, int *));
static int my_getSmallExpression
  PARAMS ((expressionS *, char *));
a946 26
/* Return values of my_getSmallExpression().  */

enum small_ex_type
{
  S_EX_NONE = 0,
  S_EX_REGISTER,

  /* Direct relocation creation by %percent_op().  */
  S_EX_HALF,
  S_EX_HI,
  S_EX_LO,
  S_EX_GP_REL,
  S_EX_GOT,
  S_EX_CALL16,
  S_EX_GOT_DISP,
  S_EX_GOT_PAGE,
  S_EX_GOT_OFST,
  S_EX_GOT_HI,
  S_EX_GOT_LO,
  S_EX_NEG,
  S_EX_HIGHER,
  S_EX_HIGHEST,
  S_EX_CALL_HI,
  S_EX_CALL_LO
};

a1110 4
/* This is set by mips_ip if imm_reloc is an unmatched HI16_S reloc.  */

static bfd_boolean imm_unmatched_hi;

a1400 1
  imm_unmatched_hi = FALSE;
d1434 1
a1434 1
	append_insn (NULL, &insn, &imm_expr, imm_reloc, imm_unmatched_hi);
d1436 1
a1436 1
	append_insn (NULL, &insn, &offset_expr, offset_reloc, FALSE);
d1438 1
a1438 1
	append_insn (NULL, &insn, NULL, unused_reloc, FALSE);
d1586 1
a1586 1
append_insn (place, ip, address_expr, reloc_type, unmatched_hi)
a1590 1
     bfd_boolean unmatched_hi;
d1596 1
d1603 1
d2147 1
a2147 1
	      if (unmatched_hi)
a2150 1
		  assert (*reloc_type == BFD_RELOC_HI16_S);
d2157 1
d2714 1
a2714 1
  if (unmatched_hi)
d3111 1
a3111 1
  append_insn (place, &insn, ep, r, FALSE);
d3237 1
a3237 1
  append_insn (place, &insn, ep, r, FALSE);
d3327 1
a3327 1
      append_insn (place, &insn, NULL, r, FALSE);
d3330 1
a3330 1
    append_insn (place, &insn, &high_expr, r, FALSE);
d9036 1
a9036 57
	      c = my_getSmallExpression (&imm_expr, s);
	      if (c != S_EX_NONE)
		{
		  if (c != S_EX_LO)
		    {
		      if (c == S_EX_HI)
			{
			  *imm_reloc = BFD_RELOC_HI16_S;
			  imm_unmatched_hi = TRUE;
			}
#ifdef OBJ_ELF
		      else if (c == S_EX_HIGHEST)
			*imm_reloc = BFD_RELOC_MIPS_HIGHEST;
		      else if (c == S_EX_HIGHER)
			*imm_reloc = BFD_RELOC_MIPS_HIGHER;
		      else if (c == S_EX_GP_REL)
			{
			  /* This occurs in NewABI only.  */
			  c = my_getSmallExpression (&imm_expr, s);
			  if (c != S_EX_NEG)
			    as_bad (_("bad composition of relocations"));
			  else
			    {
			      c = my_getSmallExpression (&imm_expr, s);
			      if (c != S_EX_LO)
				as_bad (_("bad composition of relocations"));
			      else
				{
				  imm_reloc[0] = BFD_RELOC_GPREL16;
				  imm_reloc[1] = BFD_RELOC_MIPS_SUB;
				  imm_reloc[2] = BFD_RELOC_LO16;
				}
			    }
			}
#endif
		      else
			*imm_reloc = BFD_RELOC_HI16;
		    }
		  else if (imm_expr.X_op == O_constant)
		    imm_expr.X_add_number &= 0xffff;
		}
	      if (*args == 'i')
		{
		  if ((c == S_EX_NONE && imm_expr.X_op != O_constant)
		      || ((imm_expr.X_add_number < 0
			   || imm_expr.X_add_number >= 0x10000)
			  && imm_expr.X_op == O_constant))
		    {
		      if (insn + 1 < &mips_opcodes[NUMOPCODES] &&
			  !strcmp (insn->name, insn[1].name))
			break;
		      if (imm_expr.X_op == O_constant
			  || imm_expr.X_op == O_big)
			as_bad (_("16 bit expression not in range 0..65535"));
		    }
		}
	      else
d9039 16
a9054 1
		  offsetT max;
d9056 7
a9062 13
		  /* The upper bound should be 0x8000, but
		     unfortunately the MIPS assembler accepts numbers
		     from 0x8000 to 0xffff and sign extends them, and
		     we want to be compatible.  We only permit this
		     extended range for an instruction which does not
		     provide any further alternates, since those
		     alternates may handle other cases.  People should
		     use the numbers they mean, rather than relying on
		     a mysterious sign extension.  */
		  more = (insn + 1 < &mips_opcodes[NUMOPCODES] &&
			  strcmp (insn->name, insn[1].name) == 0);
		  if (more)
		    max = 0x8000;
d9064 5
a9068 10
		    max = 0x10000;
		  if ((c == S_EX_NONE && imm_expr.X_op != O_constant)
		      || ((imm_expr.X_add_number < -0x8000
			   || imm_expr.X_add_number >= max)
			  && imm_expr.X_op == O_constant)
		      || (more
			  && imm_expr.X_add_number < 0
			  && HAVE_64BIT_GPRS
			  && imm_expr.X_unsigned
			  && sizeof (imm_expr.X_add_number) <= 4))
d9074 1
a9074 1
			as_bad (_("16 bit expression not in range -32768..32767"));
d9081 9
a9089 1
	      c = my_getSmallExpression (&offset_expr, s);
d9094 1
a9094 1
	      if (c == S_EX_NONE
a9099 8
	      if (c == S_EX_HI)
		{
		  if (offset_expr.X_op != O_constant)
		    break;
		  offset_expr.X_add_number =
		    (offset_expr.X_add_number >> 16) & 0xffff;
		}
	      *offset_reloc = BFD_RELOC_LO16;
d9110 4
a9113 43
	      c = my_getSmallExpression (&imm_expr, s);
	      *imm_reloc = BFD_RELOC_LO16;
	      if (c != S_EX_NONE)
		{
		  if (c != S_EX_LO)
		    {
		      if (c == S_EX_HI)
			{
			  *imm_reloc = BFD_RELOC_HI16_S;
			  imm_unmatched_hi = TRUE;
			}
#ifdef OBJ_ELF
		      else if (c == S_EX_HIGHEST)
			*imm_reloc = BFD_RELOC_MIPS_HIGHEST;
		      else if (c == S_EX_GP_REL)
			{
			  /* This occurs in NewABI only.  */
			  c = my_getSmallExpression (&imm_expr, s);
			  if (c != S_EX_NEG)
			    as_bad (_("bad composition of relocations"));
			  else
			    {
			      c = my_getSmallExpression (&imm_expr, s);
			      if (c != S_EX_HI)
				as_bad (_("bad composition of relocations"));
			      else
				{
				  imm_reloc[0] = BFD_RELOC_GPREL16;
				  imm_reloc[1] = BFD_RELOC_MIPS_SUB;
				  imm_reloc[2] = BFD_RELOC_HI16_S;
				}
			    }
			}
#endif
		      else
			*imm_reloc = BFD_RELOC_HI16;
		    }
		  else if (imm_expr.X_op == O_constant)
		    imm_expr.X_add_number &= 0xffff;
		}
	      else if (imm_expr.X_op == O_constant
		       && (imm_expr.X_add_number < 0
			   || imm_expr.X_add_number >= 0x10000))
d9950 1
a9950 1
static struct percent_op_match
d9952 2
a9953 2
   const char *str;
   const enum small_ex_type type;
d9956 1
a9956 1
  {"%lo", S_EX_LO},
d9958 14
a9971 14
  {"%call_hi", S_EX_CALL_HI},
  {"%call_lo", S_EX_CALL_LO},
  {"%call16", S_EX_CALL16},
  {"%got_disp", S_EX_GOT_DISP},
  {"%got_page", S_EX_GOT_PAGE},
  {"%got_ofst", S_EX_GOT_OFST},
  {"%got_hi", S_EX_GOT_HI},
  {"%got_lo", S_EX_GOT_LO},
  {"%got", S_EX_GOT},
  {"%gp_rel", S_EX_GP_REL},
  {"%half", S_EX_HALF},
  {"%highest", S_EX_HIGHEST},
  {"%higher", S_EX_HIGHER},
  {"%neg", S_EX_NEG},
d9973 1
a9973 1
  {"%hi", S_EX_HI}
a9975 4
/* Parse small expression input.  STR gets adjusted to eat up whitespace.
   It detects valid "%percent_op(...)" and "($reg)" strings.  Percent_op's
   can be nested, this is handled by blanking the innermost, parsing the
   rest by subsequent calls.  */
d9977 6
a9982 2
static int
my_getSmallParser (str, len, nestlevel)
d9984 1
a9984 2
     unsigned int *len;
     int *nestlevel;
d9986 1
a9986 7
  *len = 0;
  *str += strspn (*str, " \t");
  /* Check for expression in parentheses.  */
  if (**str == '(')
    {
      char *b = *str + 1 + strspn (*str + 1, " \t");
      char *e;
d9988 2
a9989 30
      /* Check for base register.  */
      if (b[0] == '$')
	{
	  if (strchr (b, ')')
	      && (e = b + strcspn (b, ") \t"))
	      && e - b > 1 && e - b < 4)
	    {
	      if ((e - b == 3
		   && ((b[1] == 'f' && b[2] == 'p')
		       || (b[1] == 's' && b[2] == 'p')
		       || (b[1] == 'g' && b[2] == 'p')
		       || (b[1] == 'a' && b[2] == 't')
		       || (ISDIGIT (b[1])
			   && ISDIGIT (b[2]))))
		  || (ISDIGIT (b[1])))
		{
		  *len = strcspn (*str, ")") + 1;
		  return S_EX_REGISTER;
		}
	    }
	}
      /* Check for percent_op (in parentheses).  */
      else if (b[0] == '%')
	{
	  *str = b;
	  return my_getPercentOp (str, len, nestlevel);
	}

      /* Some other expression in the parentheses, which can contain
	 parentheses itself. Attempt to find the matching one.  */
d9991 2
a9992 2
	int pcnt = 1;
	char *s;
d9994 3
a9996 2
	*len = 1;
	for (s = *str + 1; *s && pcnt; s++, (*len)++)
d9998 3
a10000 4
	    if (*s == '(')
	      ++pcnt;
	    else if (*s == ')')
	      --pcnt;
d10002 1
d10004 1
a10004 7
    }
  /* Check for percent_op (outside of parentheses).  */
  else if (*str[0] == '%')
    return my_getPercentOp (str, len, nestlevel);

  /* Any other expression.  */
  return S_EX_NONE;
a10006 8
static int
my_getPercentOp (str, len, nestlevel)
     char **str;
     unsigned int *len;
     int *nestlevel;
{
  char *tmp = *str + 1;
  unsigned int i = 0;
d10008 3
a10010 12
  while (ISALPHA (*tmp) || *tmp == '_')
    {
      *tmp = TOLOWER (*tmp);
      tmp++;
    }
  while (i < (sizeof (percent_op) / sizeof (struct percent_op_match)))
    {
      if (strncmp (*str, percent_op[i].str, strlen (percent_op[i].str)))
	i++;
      else
	{
	  int type = percent_op[i].type;
d10012 2
a10013 3
	  /* Only %hi and %lo are allowed for OldABI.  */
	  if (! HAVE_NEWABI && type != S_EX_HI && type != S_EX_LO)
	    return S_EX_NONE;
d10015 2
a10016 10
	  *len = strlen (percent_op[i].str);
	  ++(*nestlevel);
	  return type;
	}
    }
  return S_EX_NONE;
}

static int
my_getSmallExpression (ep, str)
d10018 1
d10021 3
a10023 5
  static char *oldstr = NULL;
  int c = S_EX_NONE;
  int oldc;
  int nestlevel = -1;
  unsigned int len;
d10025 2
a10026 4
  /* Don't update oldstr if the last call had nested percent_op's. We need
     it to parse the outer ones later.  */
  if (! oldstr)
    oldstr = str;
d10028 3
a10030 1
  do
d10032 10
a10041 4
      oldc = c;
      c = my_getSmallParser (&str, &len, &nestlevel);
      if (c != S_EX_NONE && c != S_EX_REGISTER)
	str += len;
a10042 1
  while (c != S_EX_NONE && c != S_EX_REGISTER);
d10044 2
a10045 21
  if (nestlevel >= 0)
    {
      /* A percent_op was encountered.  Don't try to get an expression if
	 it is already blanked out.  */
      if (*(str + strspn (str + 1, " )")) != ')')
	{
	  char save;

	  /* Let my_getExpression() stop at the closing parenthesis.  */
	  save = *(str + len);
	  *(str + len) = '\0';
	  my_getExpression (ep, str);
	  *(str + len) = save;
	}
      if (nestlevel > 0)
	{
	  /* Blank out including the % sign and the proper matching
	     parenthesis.  */
	  int pcnt = 1;
	  char *s = strrchr (oldstr, '%');
	  char *end;
d10047 4
a10050 7
	  for (end = strchr (s, '(') + 1; *end && pcnt; end++)
	    {
	      if (*end == '(')
		++pcnt;
	      else if (*end == ')')
		--pcnt;
	    }
d10052 2
a10053 5
	  memset (s, ' ', end - s);
	  str = oldstr;
	}
      else
	expr_end = str + len;
d10055 1
a10055 18
      c = oldc;
    }
  else if (c == S_EX_NONE)
    {
      my_getExpression (ep, str);
    }
  else if (c == S_EX_REGISTER)
    {
      ep->X_op = O_constant;
      expr_end = str;
      ep->X_add_symbol = NULL;
      ep->X_op_symbol = NULL;
      ep->X_add_number = 0;
    }
  else
    {
      as_fatal (_("internal error"));
    }
d10057 3
a10059 3
  if (nestlevel <= 0)
    /* All percent_op's have been handled.  */
    oldstr = NULL;
d10061 1
a10061 1
  return c;
@


1.188
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d14791 7
a14797 1
    return dwarf2_format_64bit_irix;
@


1.187
log
@[ gas/ChangeLog ]
2003-01-02  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c: Update copyright years to include 2003.
        (mips_ip): Fix indentation of "+A", "+B", and "+C" handling.
        Additionally, clean up their code slightly and clean up their
        comments some more.


        * doc/c-mips.texi: Add MIPS32r2 to ".set mipsN" documentation.

[ gas/testsuite/ChangeLog ]
2003-01-02  Chris Demetriou  <cgd@@broadcom.com>

        * gas/mips/elf_arch_mips32r2.d: Fix file description comment.

[ include/opcode/ChangeLog ]
2003-01-02  Chris Demetriou  <cgd@@broadcom.com>

        * mips.h: Update copyright years to include 2002 (which had
        been missed previously) and 2003.  Make comments about "+A",
        "+B", and "+C" operand types more descriptive.
@
text
@d740 1
a740 1
#define RELAX_BRANCH_TOOFAR(i) (((i) & 1))
d11176 1
a11176 3
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || S_FORCE_RELOC (fixp->fx_addsy))
@


1.186
log
@[ gas/ChangeLog ]
2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

	* config/tc-mips.c (validate_mips_insn, mips_ip): Recognize
	the "+D" operand, which will be used only by the disassembler.

[ gas/testsuite/ChangeLog ]
2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0sel-names-mips32.d: New test.
	* gas/mips/cp0sel-names-mips32r2.d: New test.
	* gas/mips/cp0sel-names-mips64.d: New test.
	* gas/mips/cp0sel-names-numeric.d: New test.
	* gas/mips/cp0sel-names-sb1.d: New test.
	* gas/mips/cp0sel-names.s: New test source file.
	* gas/mips/mips.exp: Run new tests.

[ include/opcode/ChangeLog ]
2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Note that the "+D" operand type name is now used.

[ opcodes/ChangeLog ]
2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_cp0sel_name): New structure.
	(mips_cp0sel_names_mips3264, mips_cp0sel_names_mips3264r2)
	(mips_cp0sel_names_sb1): New arrays.
	(mips_arch_choice): New structure members "cp0sel_names" and
	"cp0sel_names_len".
	(mips_arch_choices): Add references to new cp0sel_names arrays
	as appropriate, and make all existing entries reference
	appropriate mips_XXX_names_numeric arrays rather than simply
	using NULL.
	(mips_cp0sel_names, mips_cp0sel_names_len): New variables.
	(lookup_mips_cp0sel_name): New function.
	(set_default_mips_dis_options): Set mips_cp0sel_names and
	mips_cp0sel_names_len as appropriate.  Remove now-unnecessary
	checks for NULL register name arrays.
	(parse_mips_dis_option): Likewise.
	(print_insn_arg): Handle "+D" operand type.
	* mips-opc.c (mips_builtin_opcodes): Add new "+D" variants
	of mfc0, mtc0, dmfc0, and dmtc0 to print CP0+sel register
	names symbolically.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d8121 1
d8290 70
a8359 52
		  case 'A':		/* ins/ext "pos".  */
		    my_getExpression (&imm_expr, s);
		    check_absolute_expr (ip, &imm_expr);
		    if ((unsigned long) imm_expr.X_add_number > 31)
		      {
			as_bad (_("Improper position (%lu)"),
				(unsigned long) imm_expr.X_add_number);
			imm_expr.X_add_number = 0;
		      }
		    lastpos = imm_expr.X_add_number;
		    ip->insn_opcode |= lastpos << OP_SH_SHAMT;
		    imm_expr.X_op = O_absent;
		    s = expr_end;
		    continue;

		  case 'B':		/* "ins" size spec (becomes MSB).  */
		    my_getExpression (&imm_expr, s);
		    check_absolute_expr (ip, &imm_expr);
		    if (imm_expr.X_add_number == 0
			|| (unsigned long) imm_expr.X_add_number > 32
			|| ((unsigned long) imm_expr.X_add_number
			    + lastpos) > 32)
		      {
			as_bad (_("Improper insert size (%lu, position %lu)"),
				(unsigned long) imm_expr.X_add_number,
				(unsigned long) lastpos);
			imm_expr.X_add_number &= OP_MASK_INSMSB;
		      }
		    ip->insn_opcode |= (lastpos + imm_expr.X_add_number
					- 1) << OP_SH_INSMSB;
		    imm_expr.X_op = O_absent;
		    s = expr_end;
		    continue;

		  case 'C':		/* "ext" size spec (becomes MSBD).  */
		    my_getExpression (&imm_expr, s);
		    check_absolute_expr (ip, &imm_expr);
		    if (imm_expr.X_add_number == 0
			|| (unsigned long) imm_expr.X_add_number > 32
			|| ((unsigned long) imm_expr.X_add_number
			    + lastpos) > 32)
		      {
			as_bad (_("Improper extract size (%lu, position %lu)"),
				(unsigned long) imm_expr.X_add_number,
				(unsigned long) lastpos);
			imm_expr.X_add_number &= OP_MASK_EXTMSBD;
		      }
		    ip->insn_opcode |= (imm_expr.X_add_number
					- 1) << OP_SH_EXTMSBD;
		    imm_expr.X_op = O_absent;
		    s = expr_end;
		    continue;
@


1.185
log
@[ bfd/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* aoutx.h (NAME(aout,machine_type)): Add bfd_mach_mipsisa32r2 case.
	* archures.c (bfd_mach_mipsisa32r2): New define.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_mipsisa32r2): New enum value.
	(arch_info_struct): Add entry for I_mipsisa32r2.
	* elfxx-mips.c (elf_mips_isa, _bfd_elf_mips_mach)
	(_bfd_mips_elf_print_private_bfd_data): Handle E_MIPS_ARCH_32R2.
	(_bfd_mips_elf_final_write_processing): Add
	bfd_mach_mipsisa32r2 case.
	(_bfd_mips_elf_merge_private_bfd_data): Handle merging of
	binaries marked as using MIPS32 Release 2.

[ binutils/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* doc/binutils.texi (objdump): Note MIPS HWR (Hardware Register)
	changes in MIPS -M options.

[ gas/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* configure.in: Recognize mipsisa32r2, mipsisa32r2el, and
	CPU variants.
	* configure: Regenerate.
	* config/tc-mips.c (ISA_HAS_DROR, ISA_HAS_ROR): New defines.
	(macro_build): Handle "K" operand.
	(macro2): Use ISA_HAS_DROR and ISA_HAS_ROR in the places where
	CPU_HAS_DROR and CPU_HAS_ROR are currently used.
	(mips_ip): New variable "lastpos", and implement "+A", "+B",
	and "+C" operands for MIPS32 Release 2 ins/ext instructions.
	Implement "K" operand for MIPS32 Release 2 rdhwr instruction.
	(validate_mips_insn): Implement "+" as a way to extend the
	allowed operands, and implement "K", "+A", "+B", and "+C"
	operands.
	(OPTION_MIPS32R2): New define.
	(md_longopts): Add entry for OPTION_MIPS32R2.
	(OPTION_ELF_BASE): Adjust to accomodate OPTIONS_MIPS32R2.
	(md_parse_option): Handle OPTION_MIPS32R2.
	(s_mipsset): Reimplement handling of ".set mipsN" options
	and add support for ".set mips32r2".
	(mips_cpu_info_table): Add entry for "mips32r2" (MIPS32 Release 2).
	(md_show_usage): Document "-mips32r2" option.
	* doc/as.texinfo: Document "-mips32r2" option.
	* doc/c-mips.texi: Likewise.

[ gas/testsuite/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0-names-mips32r2.d: New test.
	* gas/mips/hwr-names-mips32r2.d: New test.
	* gas/mips/hwr-names-numeric.d: New test.
	* gas/mips/hwr-names.s: New test source file.
	* gas/mips/mips32r2.d: New test.
	* gas/mips/mips32r2.s: New test source file.
	* gas/mips/mips32r2-ill.l: New test.
	* gas/mips/mips32r2-ill.s: New test source file.
	* gas/mips/mips.exp: Add mips32r2 architecture data array
	entry.  Run new tests mentioned above.

[ include/elf/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (E_MIPS_ARCH_32R2): New define.

[ include/opcode/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Document "+" as the start of two-character operand
	type names, and add new "K", "+A", "+B", and "+C" operand types.
	(OP_MASK_INSMSB, OP_SH_INSMSB, OP_MASK_EXTMSB)
	(OP_SH_EXTMSB, INSN_ISA32R2, ISA_MIPS32R2, CPU_MIPS32R2): New
	defines.

[ opcodes/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_cp0_names_mips3264r2, mips_hwr_names_numeric)
	(mips_hwr_names_mips3264r2): New arrays.
	(mips_arch_choice): New "hwr_names" member.
	(mips_arch_choices): Adjust for structure change, and add a new
	entry for "mips32r2" ISA.
	(mips_hwr_names): New variable.
	(set_default_mips_dis_options): Set mips_hwr_names.
	(parse_mips_dis_option): New "hwr-names" option which sets
	mips_hwr_names, and adjust "reg-names=ARCH" to set mips_hwr_names.
	(print_insn_arg): Change return type to "int"
	and use that to indicate number of characters consumed.
	Add support for "+" operand extension character, "+A", "+B",
	"+C", and "K" operands.
	(print_insn_mips): Adjust for changes to print_insn_arg.
	(print_mips_disassembler_options): Adjust for "hwr-names"
	addition and "reg-names" change.
	* mips-opc (I33): New define (shorthand for INSN_ISA32R2).
	(mips_builtin_opcodes): Note that "nop" and "ssnop" are special
	forms of "sll".  Add new MIPS32 Release 2 instructions: ehb,
	di, ei, ext, ins, jr.hb, jalr.hb, mfhc1, mfhc2, mthc1, mthc2,
	rdhwr, rdpgpr, seb, seh, synci, wrpgpr, wsbh.
	Note that hardware rotate instructions (ror, rorv) can be
	used on MIPS32 Release 2, and add the official mnemonics
	for them (rotr, rotrv) and the similar "rotl" mnemonic for
	left-rotate.
@
text
@d8025 2
d8341 4
@


1.184
log
@[ opcodes/ChangeLog ]
2002-12-18  Chris Demetriou  <cgd@@broadcom.com>

	* mips-opc.c (mips_builtin_opcodes): Remove one "ror" and two
	"dror" entries, and reorder the remaining "dror" and "ror" entries.

[ gas/ChangeLog ]
2002-12-18  Chris Demetriou  <cgd@@broadcom.com>

	* config/tc-mips.c (macro): In M_DROL, M_DROR, M_ROL, and M_ROR,
	use hardware rotate ops as appropriate.  In M_DROL_I, M_DROR_I,
	M_ROL_I, and M_ROR_I, simplify code, clean up warnings, and
	arrange not to issue warnings about use of AT when AT is not
	actually used.

[ gas/testsuite/ChangeLog ]
2002-12-18  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/rol.s: Add ".set noat" and some new instructions to test.
	* gas/mips/rol64.s: Likewise.
	* gas/mips/rol.l: New file.
	* gas/mips/rol.d: Adjust to use rol.l and for rol.s changes.
	* gas/mips/rol64.l: New file.
	* gas/mips/rol64.d: Adjust to use rol64.l and for rol64.s changes.
	* gas/mips/rol-hw.d: New file.
	* gas/mips/rol-hw.l: New file.
	* gas/mips/rol64-hw.d: New file.
	* gas/mips/rol64-hw.l: New file.
	* gas/mips/mips.exp: Run rol-hw and rol64-hw tests.
@
text
@d263 12
d3025 1
d6956 1
a6956 1
      if (CPU_HAS_DROR (mips_arch))
d6987 1
a6987 1
      if (CPU_HAS_ROR (mips_arch))
d7025 1
a7025 1
	if (CPU_HAS_DROR (mips_arch))
d7061 1
a7061 1
	if (CPU_HAS_ROR (mips_arch))
d7083 1
a7083 1
      if (CPU_HAS_DROR (mips_arch))
d7100 1
a7100 1
      if (CPU_HAS_ROR (mips_arch))
d7124 1
a7124 1
	if (CPU_HAS_DROR (mips_arch))
d7159 1
a7159 1
	if (CPU_HAS_ROR (mips_arch))
d8019 12
d8043 1
d8118 1
d8284 64
d8485 1
d8507 1
a8507 1
		  else if (*args == 'E' || *args == 'G')
d8581 2
a8582 1
		      && *args != 'G')
d8612 1
d10474 2
d10477 1
a10477 1
#define OPTION_ELF_BASE    (OPTION_MD_BASE + 41)
d10598 4
d12122 1
a12122 1
      int isa;
d12126 25
a12150 2
      isa = atoi (name + 4);
      switch (isa)
a12152 2
	  mips_opts.gp32 = file_mips_gp32;
	  mips_opts.fp32 = file_mips_fp32;
d12154 4
a12157 3
	case  1:
	case  2:
	case 32:
d12161 4
a12164 4
	case  3:
	case  4:
	case  5:
	case 64:
d12172 1
a12172 2

      switch (isa)
d12174 2
a12175 9
	case  0: mips_opts.isa = file_mips_isa;   break;
	case  1: mips_opts.isa = ISA_MIPS1;       break;
	case  2: mips_opts.isa = ISA_MIPS2;       break;
	case  3: mips_opts.isa = ISA_MIPS3;       break;
	case  4: mips_opts.isa = ISA_MIPS4;       break;
	case  5: mips_opts.isa = ISA_MIPS5;       break;
	case 32: mips_opts.isa = ISA_MIPS32;      break;
	case 64: mips_opts.isa = ISA_MIPS64;      break;
	default: as_bad (_("unknown ISA level %s"), name + 4); break;
d14477 1
d14704 1
@


1.183
log
@	* ChangeLog-9295: Fix a typo.
	* README: Likewise.
	* config/tc-d10v.c: Fix a comment typo.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-h8500.h: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-tic80.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* testsuite/gas/h8300/cmpsi2.s: Likewise.
@
text
@d6943 20
d6974 20
d7007 1
d7010 1
a7010 1
	  as_bad (_("rotate count too large"));
d7021 1
a7021 1
	    break;
d7024 14
a7037 16
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrl",
		       "d,w,<", dreg, sreg, 0);
	else
	  {
	    char *l, *r;

	    l = (rot < 0x20) ? "dsll" : "dsll32";
	    r = ((0x40 - rot) < 0x20) ? "dsrl" : "dsrl32";
	    rot &= 0x1f;
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
			 "d,w,<", AT, sreg, rot);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
			 "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
			 "d,v,t", dreg, dreg, AT);
	  }
d7046 1
a7046 1
	  as_bad (_("rotate count too large"));
d7052 1
a7052 1
	    break;
a7054 3
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
		       "d,w,<", dreg, sreg, 0);
	else
a7055 2
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
			 "d,w,<", AT, sreg, rot);
d7057 2
a7058 3
			 "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
			 "d,v,t", dreg, dreg, AT);
d7060 6
d7070 6
d7087 6
d7106 1
d7109 1
a7109 1
	  as_bad (_("rotate count too large"));
d7111 10
d7122 14
a7135 16
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrl",
		       "d,w,<", dreg, sreg, 0);
	else
	  {
	    char *l, *r;

	    r = (rot < 0x20) ? "dsrl" : "dsrl32";
	    l = ((0x40 - rot) < 0x20) ? "dsll" : "dsll32";
	    rot &= 0x1f;
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
			 "d,w,<", AT, sreg, rot);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
			 "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
			 "d,v,t", dreg, dreg, AT);
	  }
d7144 1
a7144 1
	  as_bad (_("rotate count too large"));
d7146 6
a7152 3
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
		       "d,w,<", dreg, sreg, 0);
	else
d7155 2
a7156 5
			 "d,w,<", AT, sreg, rot);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
			 "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
			 "d,v,t", dreg, dreg, AT);
d7158 6
@


1.182
log
@* tc-mips.c (RELAX_BRANCH_ENCODE): Remove reloc_s2 argument.
Adjust callers.
(RELAX_BRANCH_RELOC_S2): Delete.
(append_insn): Use only BFD_RELOC_16_PCREL_S2 for branches.
Do not handle BFD_RELOC_16_PCREL.
(macro_build, mips_ip): Likewise.
(md_pcrel_from): Return 4 for undefined symbols regardless of
mips_pic.
(md_apply_fix3): Use only BFD_RELOC_16_PCREL_S2 for branches.
Don't dereference howto if no such relocation is available.
Do not apply hack for in-place zero addend in NEWABI.
(md_convert_frag): Use only BFD_RELOC_16_PCREL_S2 for branches.
@
text
@d3821 1
a3821 1
	 If $at is already in use, we use an path which is suboptimal
d4857 1
a4857 1
	    If $at is already in use, we use an path which is suboptimal
@


1.181
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d717 1
a717 1
#define RELAX_BRANCH_ENCODE(reloc_s2, uncond, likely, link, toofar) \
d723 1
a723 2
    | ((uncond) ? 8 : 0) \
    | ((reloc_s2) ? 16 : 0)))
a724 1
#define RELAX_BRANCH_RELOC_S2(i) (((i) & 16) != 0)
d2007 1
a2007 3
      && ((*reloc_type == BFD_RELOC_16_PCREL
	   && address_expr->X_op != O_constant)
	  || *reloc_type == BFD_RELOC_16_PCREL_S2)
d2024 1
a2024 2
		    (*reloc_type == BFD_RELOC_16_PCREL_S2,
		     pinfo & INSN_UNCOND_BRANCH_DELAY,
a2127 4
	    case BFD_RELOC_16_PCREL:
	      ip->insn_opcode |= address_expr->X_add_number & 0xffff;
	      break;

d2143 1
a2143 2
				     (*reloc_type == BFD_RELOC_16_PCREL
				      || *reloc_type == BFD_RELOC_16_PCREL_S2),
d3110 1
a3110 4
	    if (mips_pic == EMBEDDED_PIC)
	      *r = BFD_RELOC_16_PCREL_S2;
	    else
	      *r = BFD_RELOC_16_PCREL;
d9003 1
a9003 4
	      if (mips_pic == EMBEDDED_PIC)
		*offset_reloc = BFD_RELOC_16_PCREL_S2;
	      else
		*offset_reloc = BFD_RELOC_16_PCREL;
d10854 1
a10854 8
    {
      /* This makes a branch to an undefined symbol be a branch to the
	 current location.  */
      if (mips_pic == EMBEDDED_PIC)
	return 4;
      else
	return 1;
    }
d11085 1
a11085 1
	  if (value != 0 && howto->partial_inplace
d11149 1
a11149 2
	  if ((fixP->fx_r_type != BFD_RELOC_16_PCREL
	       && fixP->fx_r_type != BFD_RELOC_16_PCREL_S2)
a11322 3
      /* Fall through.  */

    case BFD_RELOC_16_PCREL:
d11328 1
a11328 1
      if (!fixP->fx_done && value != 0)
d12935 1
a12935 2
      = RELAX_BRANCH_ENCODE (RELAX_BRANCH_RELOC_S2 (fragp->fr_subtype),
			     RELAX_BRANCH_UNCOND (fragp->fr_subtype),
d13429 1
a13429 3
			      RELAX_BRANCH_RELOC_S2 (fragp->fr_subtype)
			      ? BFD_RELOC_16_PCREL_S2
			      : BFD_RELOC_16_PCREL);
@


1.180
log
@Add support for 64-bit DWARF 2 formats to gas.
@
text
@d296 1
a296 1
#define CPU_HAS_MDMX(cpu)	(false                 \
d696 1
a696 1
     
d794 14
a807 11
static int insn_uses_reg PARAMS ((struct mips_cl_insn *ip,
				  unsigned int reg, enum mips_regclass class));
static int reg_needs_delay PARAMS ((unsigned int));
static void mips16_mark_labels PARAMS ((void));
static void append_insn PARAMS ((char *place,
				 struct mips_cl_insn * ip,
				 expressionS * p,
				 bfd_reloc_code_real_type *r,
				 boolean));
static void mips_no_prev_insn PARAMS ((int));
static void mips_emit_delays PARAMS ((boolean));
d809 3
a811 3
static void macro_build PARAMS ((char *place, int *counter, expressionS * ep,
				 const char *name, const char *fmt,
				 ...));
d815 23
a837 17
static void mips16_macro_build PARAMS ((char *, int *, expressionS *,
					const char *, const char *,
					va_list));
static void macro_build_jalr PARAMS ((int, expressionS *));
static void macro_build_lui PARAMS ((char *place, int *counter,
				     expressionS * ep, int regnum));
static void macro_build_ldst_constoffset PARAMS ((char *place, int *counter,
						  expressionS * ep, const char *op,
						  int valreg, int breg));
static void set_at PARAMS ((int *counter, int reg, int unsignedp));
static void check_absolute_expr PARAMS ((struct mips_cl_insn * ip,
					 expressionS *));
static void load_register PARAMS ((int *, int, expressionS *, int));
static void load_address PARAMS ((int *, int, expressionS *, int *));
static void move_register PARAMS ((int *, int, int));
static void macro PARAMS ((struct mips_cl_insn * ip));
static void mips16_macro PARAMS ((struct mips_cl_insn * ip));
d839 2
a840 1
static void macro2 PARAMS ((struct mips_cl_insn * ip));
d842 15
a856 9
static void mips_ip PARAMS ((char *str, struct mips_cl_insn * ip));
static void mips16_ip PARAMS ((char *str, struct mips_cl_insn * ip));
static void mips16_immed PARAMS ((char *, unsigned int, int, offsetT, boolean,
				  boolean, boolean, unsigned long *,
				  boolean *, unsigned short *));
static int my_getPercentOp PARAMS ((char **, unsigned int *, int *));
static int my_getSmallParser PARAMS ((char **, unsigned int *, int *));
static int my_getSmallExpression PARAMS ((expressionS *, char *));
static void my_getExpression PARAMS ((expressionS *, char *));
d858 2
a859 1
static int support_64bit_objects PARAMS((void));
d861 68
a928 34
static void mips_set_option_string PARAMS ((const char **, const char *));
static symbolS *get_symbol PARAMS ((void));
static void mips_align PARAMS ((int to, int fill, symbolS *label));
static void s_align PARAMS ((int));
static void s_change_sec PARAMS ((int));
static void s_change_section PARAMS ((int));
static void s_cons PARAMS ((int));
static void s_float_cons PARAMS ((int));
static void s_mips_globl PARAMS ((int));
static void s_option PARAMS ((int));
static void s_mipsset PARAMS ((int));
static void s_abicalls PARAMS ((int));
static void s_cpload PARAMS ((int));
static void s_cpsetup PARAMS ((int));
static void s_cplocal PARAMS ((int));
static void s_cprestore PARAMS ((int));
static void s_cpreturn PARAMS ((int));
static void s_gpvalue PARAMS ((int));
static void s_gpword PARAMS ((int));
static void s_gpdword PARAMS ((int));
static void s_cpadd PARAMS ((int));
static void s_insn PARAMS ((int));
static void md_obj_begin PARAMS ((void));
static void md_obj_end PARAMS ((void));
static long get_number PARAMS ((void));
static void s_mips_ent PARAMS ((int));
static void s_mips_end PARAMS ((int));
static void s_mips_frame PARAMS ((int));
static void s_mips_mask PARAMS ((int));
static void s_mips_stab PARAMS ((int));
static void s_mips_weakext PARAMS ((int));
static void s_mips_file PARAMS ((int));
static void s_mips_loc PARAMS ((int));
static int mips16_extended_frag PARAMS ((fragS *, asection *, long));
d930 4
a933 2
static int validate_mips_insn PARAMS ((const struct mips_opcode *));
static void show PARAMS ((FILE *, const char *, int *, int *));
d935 2
a936 1
static int mips_need_elf_addend_fixup PARAMS ((fixS *));
d976 12
a987 8
static void mips_set_architecture PARAMS ((const struct mips_cpu_info *));
static void mips_set_tune PARAMS ((const struct mips_cpu_info *));
static boolean mips_strict_matching_cpu_name_p PARAMS ((const char *,
							const char *));
static boolean mips_matching_cpu_name_p PARAMS ((const char *, const char *));
static const struct mips_cpu_info *mips_parse_cpu PARAMS ((const char *,
							   const char *));
static const struct mips_cpu_info *mips_cpu_info_from_isa PARAMS ((int));
d1131 1
a1131 1
static boolean imm_unmatched_hi;
d1135 1
a1135 1
static boolean mips16_small, mips16_ext;
d1298 1
a1298 1
  mips_no_prev_insn (false);
d1423 1
a1423 1
  imm_unmatched_hi = false;
d1459 1
a1459 1
	append_insn (NULL, &insn, &offset_expr, offset_reloc, false);
d1461 1
a1461 1
	append_insn (NULL, &insn, NULL, unused_reloc, false);
d1614 1
a1614 1
     boolean unmatched_hi;
d2199 1
a2199 1
					 4, address_expr, false,
d2231 1
a2231 1
					     address_expr, false,
d2787 1
a2787 1
     boolean insns;
d2977 1
a2977 1
      /* It is assumed here that macros will never generate 
d3143 1
a3143 1
  append_insn (place, &insn, ep, r, false);
d3172 1
a3172 1
  insn.use_extend = false;
d3250 2
a3251 2
		mips16_immed (NULL, 0, c, ep->X_add_number, false, false,
			      false, &insn.insn_opcode, &insn.use_extend,
d3269 1
a3269 1
  append_insn (place, &insn, ep, r, false);
d3282 1
a3282 1
  
d3292 1
a3292 1
		 0, ep, false, BFD_RELOC_MIPS_JALR);
d3359 1
a3359 1
      append_insn (place, &insn, NULL, r, false);
d3362 1
a3362 1
    append_insn (place, &insn, &high_expr, r, false);
d4115 1
a4115 1
      mips_emit_delays (true);
d4579 1
a4579 1
      mips_emit_delays (true);
d4734 1
a4734 1
      mips_emit_delays (true);
d6888 1
a6888 1
      mips_emit_delays (true);
d6928 1
a6928 1
      mips_emit_delays (true);
d7437 1
a7437 1
      mips_emit_delays (true);
d7721 1
a7721 1
      mips_emit_delays (true);
d7756 1
a7756 1
      mips_emit_delays (true);
d8095 1
a8095 1
      boolean ok;
d8105 1
a8105 1
	ok = true;
d8107 1
a8107 1
	ok = false;
d8112 1
a8112 1
	    ok = false;
d8904 1
a8904 1
			  imm_unmatched_hi = true;
d9034 1
a9034 1
			  imm_unmatched_hi = true;
d9200 2
a9201 2
  mips16_small = false;
  mips16_ext = false;
d9218 1
a9218 1
	  mips16_small = true;
d9225 1
a9225 1
	  mips16_ext = true;
d9236 1
a9236 1
    mips16_small = true;
d9251 1
a9251 1
      ip->use_extend = false;
d9283 1
a9283 1
				    imm_expr.X_add_number, true, mips16_small,
d9521 1
a9521 1
		      mips16_ext = true;
d9524 1
a9524 1
		      ip->use_extend = true;
d9800 3
a9802 3
     boolean warn;
     boolean small;
     boolean ext;
d9804 1
a9804 1
     boolean *use_extend;
d9809 1
a9809 1
  boolean needext;
d9844 1
a9844 1
    needext = true;
d9846 1
a9846 1
    needext = false;
d9858 1
a9858 1
      *use_extend = false;
d9882 1
a9882 1
      *use_extend = true;
d10506 1
a10506 1
      mips_no_prev_insn (false);
d10511 1
a10511 1
      mips_no_prev_insn (false);
d10680 1
a10680 1
      mips_7000_hilo_fix = true;
d10684 1
a10684 1
      mips_7000_hilo_fix = false;
d10689 1
a10689 1
      mips_flag_mdebug = true;
d10693 1
a10693 1
      mips_flag_mdebug = false;
d11114 1
a11114 1
		 
d11117 1
a11117 1
		 
d11541 1
a11541 1
  mips_emit_delays (false);
d11607 1
a11607 1
  mips_emit_delays (false);
d11634 1
a11634 1
  mips_emit_delays (false);
d11699 1
a11699 1
  
d11712 1
a11712 1
  
d11773 1
a11773 1
  mips_emit_delays (false);
d11788 1
a11788 1
  mips_emit_delays (false);
d11929 1
a11929 1
      mips_emit_delays (true);
d12050 1
a12050 1
	    mips_emit_delays (true);
d12371 1
a12371 1
  mips_emit_delays (true);
d12386 1
a12386 1
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, false,
d12408 1
a12408 1
  mips_emit_delays (true);
d12423 1
a12423 1
  fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &ex, false,
d12430 1
a12430 1
  fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &ex, false,
d12934 1
a12934 1
  boolean toofar;
d12956 1
a12956 1
    toofar = false;
d12958 1
a12958 1
    toofar = true;
d12987 1
a12987 1
  
d13002 1
a13002 1
  boolean linkonce = false;
d13007 2
a13008 2
      fragp->fr_var = relaxed_branch_length (fragp, segtype, false);
      
d13048 1
a13048 1
	    linkonce = true;
d13055 1
a13055 1
	    linkonce = true;
d13394 2
a13395 2
      
      fragp->fr_var = relaxed_branch_length (fragp, sec, true);
d13438 1
a13438 1
      
d13445 1
a13445 1
	  
d13462 1
a13462 1
	  
d13495 1
a13495 1
		  
d13532 1
a13532 1
	  i--; 
d13604 1
a13604 1
	      
d13619 1
a13619 1
	      
d13646 1
a13646 1
      boolean small, ext;
d13650 1
a13650 1
      boolean use_extend;
d13660 2
a13661 2
	  small = false;
	  ext = true;
d13665 2
a13666 2
	  small = true;
	  ext = false;
d14387 1
a14387 1
static boolean
d14404 1
a14404 1
static boolean
d14411 1
a14411 1
    return true;
d14418 1
a14418 1
    return false;
@


1.179
log
@* config/tc-mips.c (s_change_section): Make sure input buffer
is not accessed past the end.  Don't hand
obj_elf_change_section a pointer into the input buffer.
@
text
@d14553 9
@


1.178
log
@* config/tc-mips.c (tc_gen_reloc): Fix typo in handling of
GOT_LO16 on NEWABI.
@
text
@d11660 2
a11661 1
  next_c = *(input_line_pointer + 1);
d11692 2
d11696 3
@


1.177
log
@* config/tc-mips.c (macro_build_lui): _gp_disp is not special on
NEWABI, but we should still emit HI16_S for non-PIC n32.
@
text
@d13232 1
a13232 1
      if (HAVE_NEWABI && BFD_RELOC_MIPS_GOT_LO16)
@


1.176
log
@2002-11-05  H.J. Lu <hjl@@gnu.org>

	* config/tc-mips.c (support_64bit_objects): Check *l before it
	is freed.
@
text
@d3271 1
a3271 1
  else if (! HAVE_NEWABI)
d3276 2
a3277 1
	      || strcmp (S_GET_NAME (ep->X_add_symbol), "_gp_disp") == 0);
@


1.175
log
@	* config/tc-mips.c (mips_need_elf_addend_fixup): Return true
	for relocs against symbols in a merged section.

testsuite/
	* gas/mips/elf-rel7.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d10164 1
d10177 1
d10179 1
a10179 1
  return (*l != NULL);
@


1.174
log
@* config/tc-mips.c (md_begin): Add $fcc registers to the symbol
table as register names.
@
text
@d10984 1
a10984 1
	    & SEC_LINK_ONCE) != 0)
@


1.173
log
@* config/tc-mips.c (s_gpdword): New function.
(mips_pseudo_table): Add .gpdword.
(mips_need_elf_addend_fixup): never for NEWABI.
(md_apply_fix3): Don't mark BFD_RELOC64 after GPREL16 or
GPREL32 as done.
(s_cpadd): Generate .cpadd on NEWABI.
@
text
@d1226 14
@


1.172
log
@* config/tc-mips.h (mips_relax_frag): Take segment as argument.
(md_relax_frag): Adjust macro.
* config/tc-mips.c (mips_relax_branch): New variable.
(RELAX_BRANCH_ENCODE, RELAX_BRANCH_P, RELAX_BRANCH_LIKELY,
RELAX_BRANCH_LINK, RELAX_BRANCH_TOOBAR): New.
(RELAX_MIPS16_P): Adjust.
(append_insn): Emit branch to non-constant in a frag_var if
branch-relaxation is desirable and possible.
(OPTION_RELAX_BRANCH, OPTION_NO_RELAX_BRANCH): New options.
(OPTION_ELF_BASE): Adjust.
(md_parse_option): Handle new options.
(md_apply_fix3): Update comment on EMBEDDED_PIC conditional
branch relaxation.
(relaxed_branch_length): New function.
(md_estimate_size_before_relax): Handle branch frags.
(mips_relax_frag): Likewise.
(md_convert_frag): Handle branch frags.  Warn if branch is
relaxed.
@
text
@d863 1
d965 1
d11110 3
d12311 44
d12365 2
a12366 3
  /* This is ignored when not generating SVR4 PIC code or if this is NewABI
     code.  */
  if (mips_pic != SVR4_PIC || HAVE_NEWABI)
@


1.171
log
@[gas/]
	* doc/c-mips.texi: Add entries for -march=vr4120,vr4130,vr4181,
	vr5400 and vr5500.  Add entry for -mfix-vr4122-bugs.
	* config/tc-mips.c (CPU_HAS_DROR, CPU_HAS_ROR): New macros.
	(hilo_interlocks): True for CPU_VR5500.
	(gpr_interlocks, cop_interlocks): True for CPU_VR5400 and CPU_VR5500.
	(mips_fix_vr4122_bugs): New.
	(append_insn): Work around 4122 errors if mips_fix_vr4122_bugs.
	(mips_emit_delays): Likewise.
	(macro2) [M_DROLI]: Use dror or dror32 if CPU_HAS_DROR.
	[M_ROLI]: Likewise ror if CPU_HAS_ROR.
	(validate_mips_insn, mips_ip): Handle '[', ']', 'e' and '%'.
	(OPTION_FIX_VR4122, OPTION_NO_FIX_VR4122): New options.
	(md_longopts): Add -mfix-vr4122-bugs and -no-mfix-vr4122-bugs.
	(OPTION_ELF_BASE): Bump.
	(md_parse_option): Handle the new options.
	(mips_cpu_info_table): Add entries for vr4120, vr4130, vr4181,
	vr5400 and vr5500.

[gas/testsuite/]
	* gas/mips/mips4100.[sd]: Move dmadd16 and madd16 checks to...
	* gas/mips/vr4111.[sd]: ...this new test.
	* gas/mips/vr4120.[sd],
	* gas/mips/vr4122.[sd],
	* gas/mips/vr5400.[sd],
	* gas/mips/vr5500.[sd]: New tests.
	* mips.exp: Run them.
@
text
@d566 7
d650 82
d759 1
a759 1
#define RELAX_MIPS16_P(i) (((i) & 0x80000000) != 0)
d877 1
d1933 32
a1964 1
  if (*reloc_type > BFD_RELOC_UNUSED)
d10249 4
d10254 1
a10254 1
#define OPTION_ELF_BASE    (OPTION_MD_BASE + 39)
d10463 8
d11322 3
a11324 7
	      /* FIXME.  It would be possible in principle to handle
                 conditional branches which overflow.  They could be
                 transformed into a branch around a jump.  This would
                 require setting up variant frags for each different
                 branch type.  The native MIPS assembler attempts to
                 handle these cases, but it appears to do it
                 incorrectly.  */
d12794 68
d12875 8
d13257 2
a13258 1
mips_relax_frag (fragp, stretch)
d13262 9
d13302 210
@


1.170
log
@2002-09-29  H.J. Lu <hjl@@gnu.org>

	* config/tc-mips.c (md_apply_fix3): Subtract the symbol value
	twice if howto->pcrel_offset is true.
@
text
@d299 6
d310 1
d318 2
d326 2
d564 2
d1705 44
d2646 14
d6788 11
d6826 6
d7807 4
d8002 2
d8925 35
d10124 4
d10129 1
a10129 1
#define OPTION_ELF_BASE    (OPTION_MD_BASE + 37)
d10330 8
d13788 3
d13802 2
@


1.169
log
@	/gas/ChangeLog
	* config/tc-mips.c (CPU_HAS_MIPS16): Add mips-lsi-elf as MIPS16
	capable configuration.
	(macro_build): Check for MIPS16 capability, not for actual MIPS16 code
	generation.
	(mips_ip): Likewise.

	/gas/testsuite/ChangeLog
	* gas/mips/mips-jalx.d: New file, check jalx assembly.
	* gas/mips/mips-jalx.s: Likewise.
	* gas/mips/mips-no-jalx.l: Likewise.
	* gas/mips/mips-no-jalx.s: Likewise.
	* gas/mips/mips16-jalx.d: Likewise.
	* gas/mips/mips16-jalx.s: Likewise.
	* gas/mips/mips.exp: Add new tests.

	/opcodes/ChangeLog:
	* mips-dis.c (print_insn_mips): Always allow disassembly of
	32-bit jalx opcode.
@
text
@d10757 2
a10758 1
	  if (value != 0 && howto->partial_inplace && ! fixP->fx_pcrel)
d10762 12
a10773 1
		 the addend to appear in the object file.  */
@


1.168
log
@	* config/tc-mips.c (append_insn): Fix jump overflow check.
	* gas/mips/jal-range.s: Fix jump overflow check.
	* gas/mips/jal-range.l: Likewise.
@
text
@d287 3
a289 2
#define CPU_HAS_MIPS16(cpu)                            \
   (strncmp (TARGET_CPU, "mips16", sizeof ("mips16") - 1) == 0)
d2717 1
a2717 1
	      		        | (mips_opts.mips16 ? INSN_MIPS16 : 0)),
d7813 1
a7813 1
			     | (mips_opts.mips16 ? INSN_MIPS16 : 0)
@


1.167
log
@[ gas/ChangeLog ]
2002-09-18  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (IS_SEXT_32BIT_NUM): Move closer to top of file.
        (IS_SEXT_16BIT_NUM): New macro.
        (macro_build_ldst_constoffset): New function, to build a set of
        instructions to do a load or store from a constant offset relative
        to a given register.
        (macro, s_cprestore): Use macro_build_ldst_constoffset to implement
        .cprestore pseudo-op.

[ gas/testsuite/ChangeLog ]
2002-09-18  Chris Demetriou  <cgd@@broadcom.com>

        * gas/mips/mips-abi32-pic2.s: New file.
        * gas/mips/mips-abi32-pic2.d: New file.
        * gas/mips/mips.exp: Run new test.

[ plus, fixed date on prev. gas/testsuite/ChangeLog entry. ]
@
text
@d1861 1
a1861 2
	      if (address_expr->X_add_number & ~0xfffffff
		  || address_expr->X_add_number > 0x7fffffc)
d1871 1
a1871 2
	      if (address_expr->X_add_number & ~0xfffffff
		  || address_expr->X_add_number > 0x7fffffc)
@


1.166
log
@[ gas/ChangeLog ]
2002-09-18  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (md_apply_fix3): Just return for BFD_RELOC_8.

[ gas/testsuite/ChangeLog ]
2002-09-18  Chris Demetriou  <cgd@@broadcom.com>

        * gas/mips/baddata1.s: New file.
        * gas/mips/baddata1.l: New file.
        * gas/mips/mips.exp: Run new test.
@
text
@d668 11
d715 3
d3099 46
a3258 5
/* Is the given value a sign-extended 32-bit value?  */
#define IS_SEXT_32BIT_NUM(x)						\
  (((x) &~ (offsetT) 0x7fffffff) == 0					\
   || (((x) &~ (offsetT) 0x7fffffff) == ~ (offsetT) 0x7fffffff))

d5121 3
a5123 4
		  macro_build ((char *) NULL, &icnt, &expr1,
			       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)",
			       mips_gp_register, (int) BFD_RELOC_LO16,
			       mips_frame_reg);
d5253 3
a5255 4
		  macro_build ((char *) NULL, &icnt, &expr1,
			       HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)",
			       mips_gp_register, (int) BFD_RELOC_LO16,
			       mips_frame_reg);
d11919 3
a11921 2
  macro_build ((char *) NULL, &icnt, &ex, HAVE_32BIT_ADDRESSES ? "sw" : "sd",
	       "t,o(b)", mips_gp_register, (int) BFD_RELOC_LO16, SP);
@


1.165
log
@	* config/tc-mips.c (s_change_section): Fix parsing. Code cleanup.
@
text
@d10664 5
@


1.164
log
@	* tc-mips.c (load_address): Use BFD_RELOC_MIPS_GOT_DISP for newabi.
	(macro): Likewise for la.  Likewise for ld.
	(mips_after_parse_args): Make -xgot optional, not the default.
	(md_apply_fix3): Allow composite relocation to set up gp.
	(tc_gen_reloc): Allow relaxing for newabi.
	Relax R_MIPS_CALL16 to R_MIPS_GOT_PAGE/R_MIPS_GOT_OFST if local.
	Relax R_MIPS_GOT16/R_MIPS_LO16 to R_MIPS_GOT_DISP if local.
@
text
@d11288 1
a11288 2
  char *next_c;
  char *p;
d11299 1
a11299 3
  next_c = input_line_pointer + 1;
  /* just after name is now '\0' */
  p = input_line_pointer;
d11301 2
a11302 2
  /* Do we have .section Name<,"flags">  */
  if (c == '\n' || (c == ',' && *next_c == '"') || c == '"')
d11304 2
a11305 1
      *p = c;
@


1.163
log
@	* config/tc-mips.c (pdr_seg): Define only for ELF.
	(s_change_section): Remove unused variable. Don't use for nonELF.
@
text
@d1839 1
d3591 2
d3597 20
a3616 10
      macro_build ((char *) NULL, counter, ep,
		   HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)",
		   reg, (int) BFD_RELOC_MIPS_GOT16, mips_gp_register);
      macro_build ((char *) NULL, counter, (expressionS *) NULL, "nop", "");
      p = frag_var (rs_machine_dependent, 4, 0,
		    RELAX_ENCODE (0, 4, -8, 0, 0, mips_opts.warn_about_macros),
		    ep->X_add_symbol, (offsetT) 0, (char *) NULL);
      macro_build (p, counter, ep,
		   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d4648 10
a4657 1
	     addiu instruction.  */
d4663 2
d4764 1
d4806 2
a4807 4
	     For NewABI, we want for data addresses
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP)
	     If tempreg is PIC_CALL_REG pointing to a external symbol, we want
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_CALL16)
a4808 14
	  if (HAVE_NEWABI)
	    {
	      int reloc_type = (tempreg == PIC_CALL_REG
				? BFD_RELOC_MIPS_CALL16
				: BFD_RELOC_MIPS_GOT_DISP);

	      macro_build ((char *) NULL, &icnt, &offset_expr,
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", tempreg, reloc_type, mips_gp_register);

	      if (breg != 0)
		macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			     HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			     "d,v,t", treg, tempreg, breg);
a4809 5
	      if (! used_at)
		return;

	      break;
	    }
d4930 3
d4935 2
a4936 1
		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16,
d4939 6
a4944 1
	  if (expr1.X_add_number >= -0x8000
d5615 1
d5626 2
d5637 2
d5645 1
a5645 1
		       (int) BFD_RELOC_MIPS_GOT16, mips_gp_register);
a10440 3
  if (HAVE_NEWABI)
    mips_big_got = 1;

d10662 1
d10762 6
a10767 1
  if (fixP->fx_addsy == NULL && ! fixP->fx_pcrel)
d10769 1
d12663 2
a12664 1
      && (fixp->fx_r_type == BFD_RELOC_GPREL16
d12671 1
a12671 1
      && ! HAVE_NEWABI)
a12731 1
	    case BFD_RELOC_MIPS_CALL16:
d12736 11
d12751 7
@


1.162
log
@gas reloc rewrite.
@
text
@d959 1
d964 1
d11263 1
a11263 2
  expressionS rep_exp;
  
a11271 2
  int log = -1;
  flagword flags;
d11273 3
d11312 1
@


1.161
log
@[gas/]
	* config/tc-mips.c (macro2): Implement rotates by zero using shifts
        by zero.

[gas/testsuite]
	* gas/mips/rol.s: Add rotate by zero tests.
	* gas/mips/rol.d: Update accordingly.
	* gas/mips/rol64.d: Expect rotates by zero to use dsrl.
@
text
@d325 1
a325 16
enum mips_pic_level
{
  /* Do not generate PIC code.  */
  NO_PIC,

  /* Generate PIC code as in the SVR4 MIPS ABI.  */
  SVR4_PIC,

  /* Generate PIC code without using a global offset table: the data
     segment has a maximum size of 64K, all data references are off
     the $gp register, and all text references are PC relative.  This
     is used on some embedded systems.  */
  EMBEDDED_PIC
};

static enum mips_pic_level mips_pic;
d10589 2
a10590 1
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
a12537 7
#ifdef OBJ_ELF
  /* Prevent all adjustments to global symbols.  */
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
      && mips_pic != EMBEDDED_PIC
      && (S_IS_EXTERNAL (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)))
    return 0;
#endif
d12540 1
d12544 1
d12547 1
d12554 1
@


1.160
log
@	* config/obj-elf.c (obj_elf_change_section): Make non-static.
	config/tc-mips.c (s_change_section): New function to support
	IRIX .section pseudo-op.
@
text
@a6655 1
	char *l, *r;
d6660 17
a6676 11
	if (! rot)
	  break;
	l = (rot < 0x20) ? "dsll" : "dsll32";
	r = ((0x40 - rot) < 0x20) ? "dsrl" : "dsrl32";
	rot &= 0x1f;
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
		     "d,w,<", AT, sreg, rot);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		     "d,v,t", dreg, dreg, AT);
d6687 12
a6698 8
	if (! rot)
	  break;
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
		     "d,w,<", AT, sreg, rot);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		     "d,v,t", dreg, dreg, AT);
a6726 1
	char *l, *r;
d6731 17
a6747 11
	if (! rot)
	  break;
	r = (rot < 0x20) ? "dsrl" : "dsrl32";
	l = ((0x40 - rot) < 0x20) ? "dsll" : "dsll32";
	rot &= 0x1f;
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
		     "d,w,<", AT, sreg, rot);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		     "d,v,t", dreg, dreg, AT);
d6758 12
a6769 8
	if (! rot)
	  break;
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
		     "d,w,<", AT, sreg, rot);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
		     "d,v,t", dreg, dreg, AT);
@


1.159
log
@* config/tc-mips.c (macro_build_jalr): Make sure we generate
the fix-up against on the right frag.
(s_cpsetup): Likewise.  Parse third argument as expression, to
handle global symbols and forward/backward labels correctly.
@
text
@d747 1
d887 1
d11251 55
@


1.158
log
@[gas/]
	* config/tc-mips.c (mips_ip): Don't work out the value of
	constant %hi()s here.

[gas/testsuite/]
	* gas/mips/elf-consthilo.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d3012 2
d3015 4
a3018 1
    frag_more (0);
d3022 2
a3023 1
    fix_new_exp (frag_now, 0, 0, ep, false, BFD_RELOC_MIPS_JALR);
d11653 1
a11653 1
  char *sym;
d11692 1
a11692 9
  sym = input_line_pointer;
  while (ISALNUM (*input_line_pointer))
    ++input_line_pointer;
  *input_line_pointer = 0;

  ex_sym.X_op = O_symbol;
  ex_sym.X_add_symbol = symbol_find_or_make (sym);
  ex_sym.X_op_symbol = NULL;
  ex_sym.X_add_number = 0;
d11708 4
d11714 6
a11719 2
  fix_new (frag_now, prev_insn_where, 0, NULL, 0, 0, BFD_RELOC_MIPS_SUB);
  fix_new (frag_now, prev_insn_where, 0, NULL, 0, 0, BFD_RELOC_HI16_S);
d11722 5
a11726 2
  fix_new (frag_now, prev_insn_where, 0, NULL, 0, 0, BFD_RELOC_MIPS_SUB);
  fix_new (frag_now, prev_insn_where, 0, NULL, 0, 0, BFD_RELOC_LO16);
@


1.157
log
@* config/tc-mips.c (macro): Handle a register plus a 16-bit
immediate offset in "dla" and "la" expansions.
* gas/mips/empic.d: Treat "addiu" and "daddiu" as equivalent when
$0 is source.
* mips-opc.c (mips_builtin_opcodes): Remove "dla" and "la" as
aliases to "daddiu" and "addiu".
@
text
@d8528 5
a8532 3
		      if (imm_expr.X_op == O_constant)
			imm_expr.X_add_number =
			  (imm_expr.X_add_number >> 16) & 0xffff;
a8557 5
		      else if (c == S_EX_HI)
			{
			  *imm_reloc = BFD_RELOC_HI16_S;
			  imm_unmatched_hi = true;
			}
d8658 1
a8658 4
		      if (imm_expr.X_op == O_constant)
			imm_expr.X_add_number =
			  (imm_expr.X_add_number >> 16) & 0xffff;
		      else if (c == S_EX_HI)
d8692 3
a8694 3
	      if (imm_expr.X_op == O_constant
		  && (imm_expr.X_add_number < 0
		      || imm_expr.X_add_number >= 0x10000))
@


1.156
log
@[gas/]
	* config/tc-mips.c (tc_gen_reloc): Extend GP-relative addend
	handling to BFD_RELOC_MIPS16_GPREL.

[gas/testsuite/]
	* gas/mips/elf-rel6.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d4446 10
@


1.155
log
@2002-07-30  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (mips_cpu_info_table): Clean up entries related
        to Broadcom SB-1 core support.
@
text
@d12697 1
a12697 1
      && code == BFD_RELOC_GPREL16
@


1.154
log
@	* config/tc-mips.c (mips_target_format): Fix formatting.
	Add recognition of n32 ABI formats.
@
text
@d13492 1
a13492 3
  /* Broadcom SB-1 CPU */
  { "SB-1",           0,      ISA_MIPS64,     CPU_SB1 },
  { "sb-1250",        0,      ISA_MIPS64,     CPU_SB1 },
a13493 1
  { "sb1250",         0,      ISA_MIPS64,     CPU_SB1 },
@


1.153
log
@* tc-mips.c (load_address): Don't clobber $at when loading a
64-bit address in non-PIC code if noat is in effect.
(macro): Likewise.
@
text
@d992 1
a992 1
      /* This is traditional mips */
d994 8
a1001 4
	      ? (HAVE_64BIT_OBJECTS ? "elf64-tradbigmips"
		 : "elf32-tradbigmips")
	      : (HAVE_64BIT_OBJECTS ? "elf64-tradlittlemips"
		 : "elf32-tradlittlemips"));
d1004 8
a1011 3
	      ? (HAVE_64BIT_OBJECTS ? "elf64-bigmips" : "elf32-bigmips")
	      : (HAVE_64BIT_OBJECTS ? "elf64-littlemips"
		 : "elf32-littlemips"));
@


1.152
log
@* config/tc-mips.c (macro): Use codes 6 and 7 in trap instructions
used in division/multiply macro expansions similarly to how they
are used in the variants with break instructions.
(macro2): Likewise.
@
text
@d3522 1
a3522 1
	  if (*used_at == 0)
d4537 1
a4537 1
	      if (used_at == 0)
d5490 1
a5490 1
	      if (used_at == 0)
@


1.151
log
@Fix comment from last commit.
@
text
@d4234 1
a4234 1
			 "s,t", 0, 0);
d4247 1
a4247 1
		       "s,t", treg, 0);
d4283 1
a4283 1
		       "s,t", sreg, AT);
d4346 1
a4346 1
			 "s,t", 0, 0);
d4402 1
a4402 1
		       "s,t", treg, 0);
d6551 2
a6552 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "tne", "s,t",
		     dreg, AT);
d6590 2
a6591 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "tne", "s,t",
		     AT, 0);
@


1.150
log
@[gas/]
	* doc/c-mips.texi: Remove -mcpu.  Document -mabi.
	* configure.in (MIPS_CPU_STRING_DEFAULT): New configuration macro.
	(USE_E_MIPS_ABI_O32, MIPS_DEFAULT_64BIT): New configuration macros.
	* configure, config.in: Regenerate.
	* config/tc-mips.c (file_mips_abi): Rename to mips_abi.
	(mips_set_options): Remove "abi" field.
	(mips_opts): Update accordingly.  Replace all uses of mips_opts.abi
	with mips_abi.
	(mips_cpu): Remove.
	(mips_arch_string, mips_arch_info): New vars.
	(mips_tune_string, mips_tune_info): New vars.
	(ABI_NEEDS_32BIT_REGS, ABI_NEEDS_64BIT_REGS): New macros.
	(HAVE_32BIT_GPRS, HAVE_32BIT_FPRS): Don't check the ABI.
	(mips_isa_to_str, mips_cpu_to_str): Remove.
	(mips_ip): If the selected architecture is a generic ISA rather
	than a processor, only mention the ISA level in error messages.
	(OPTION_MCPU): Remove.
	(OPTION_FP64): New.
	(md_longopts): Add -mfp64, remove -mcpu.
	(mips_set_option_string): New fn.
	(md_parse_option): Make -mipsN update file_mips_isa rather than
	mips_opts.isa.  Use mips_set_option_string to set -march or -mtune.
	Don't let -mgp32 and -mfp32 change the ABI.
	(show): Move to end of file.  Constify string argument.
	(md_show_usage): Move to the end of the file.  Read available
	architectures from mips_cpu_info_table.
	(mips_set_architecture): New fn.
	(mips_after_parse_args): Rework.  Remove -mcpu handling.  -mipsN
	is an alias for -march=mipsN.  Don't change the ABI based on other
	flags.  Infer the register size from the ABI as	well as the
	architecture.  Complain about more conflicting arguments.
	Unify logic with GCC.
	(s_mipsset): Don't change the ABI.
	(mips_elf_final_processing): Check USE_E_MIPS_ABI_O32.
	(mips_cpu_info_table): Remove Generic-MIPS* entries, keeping just
	"mipsN"-type entries.  Remove entries that vary only in the
	manufacturer's prefix, or that have "000" replaced by "k".
	Remove TARGET_CPU entries.  Make r2000 entry use CPU_R3000.
	(mips_strict_matching_cpu_name_p, mips_matching_cpu_name_p): New fns.
	(mips_parse_cpu): New fn.
	(mips_cpu_info_from_name, mips_cpu_info_from_cpu): Remove.
	(mips_cpu_info_from_isa): Minor formatting tweak.

[gas/testsuite]
	* gas/mips/mips-gp32-fp64.d,
	* gas/mips/mips-gp32-fp64-pic.d: Add -mfp64.
@
text
@d10299 4
a10302 4
  /* The following code determines the architecture, ABI and register
     size.  Similar code was added to GCC 3.2 (see override_options()
     in config/mips/mips.c).  The GAS and GCC code should be kept in
     sync as much as possible.  */
@


1.149
log
@	* config/tc-mips.c (mips_need_elf_addend_fixup): Use S_IS_EXTERNAL
	instead of S_IS_EXTERN.
	(md_estimate_size_before_relax): Likewise.
	(mips_fix_adjustable): Likewise.
@
text
@d132 1
a132 1
static enum mips_abi_level file_mips_abi = NO_ABI;
a179 3
  /* The ABI currently in use. This is changed by .set mipsN to loosen
     restrictions and doesn't affect the whole file.  */
  enum mips_abi_level abi;
d194 1
a194 1
  ISA_UNKNOWN, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, NO_ABI
a217 3
/* The argument of the -mcpu= flag.  Historical for code generation.  */
static int mips_cpu = CPU_UNKNOWN;

d220 2
d226 2
d229 1
a229 2
/* If they asked for mips1 or mips2 and a cpu that is
   mips3 or greater, then mark the object file 32BITMODE.  */
d246 9
d264 1
a264 3
    (mips_opts.gp32                                \
     || mips_opts.abi == O32_ABI                   \
     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
d267 1
a267 3
    (mips_opts.fp32                                \
     || mips_opts.abi == O32_ABI                   \
     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
d272 1
a272 1
#define HAVE_NEWABI (mips_opts.abi == N32_ABI || mips_opts.abi == N64_ABI)
d274 1
a274 1
#define HAVE_64BIT_OBJECTS (mips_opts.abi == N64_ABI)
d742 1
a773 2
static const char *mips_isa_to_str PARAMS ((int));
static const char *mips_cpu_to_str PARAMS ((int));
d775 1
a775 1
static void show PARAMS ((FILE *, char *, int *, int *));
d817 7
a823 1
static const struct mips_cpu_info *mips_cpu_info_from_name PARAMS ((const char *));
a824 1
static const struct mips_cpu_info *mips_cpu_info_from_cpu PARAMS ((int));
a976 30
static const char *
mips_isa_to_str (isa)
     int isa;
{
  const struct mips_cpu_info *ci;
  static char s[20];

  ci = mips_cpu_info_from_isa (isa);
  if (ci != NULL)
    return (ci->name);

  sprintf (s, "ISA#%d", isa);
  return s;
}

static const char *
mips_cpu_to_str (cpu)
     int cpu;
{
  const struct mips_cpu_info *ci;
  static char s[16];

  ci = mips_cpu_info_from_cpu (cpu);
  if (ci != NULL)
    return (ci->name);

  sprintf (s, "CPU#%d", cpu);
  return s;
}

d1152 1
a1152 1
	if (file_mips_abi != N64_ABI)
d7738 9
a7746 5
		  sprintf (buf,
			   _("opcode not supported on this processor: %s (%s)"),
			   mips_cpu_to_str (mips_arch),
			   mips_isa_to_str (mips_opts.isa));

d9871 2
a9872 2
#define OPTION_MCPU (OPTION_MD_BASE + 23)
  {"mcpu", required_argument, NULL, OPTION_MCPU},
d9925 18
d9998 1
a9998 1
      mips_opts.isa = ISA_MIPS1;
d10002 1
a10002 1
      mips_opts.isa = ISA_MIPS2;
d10006 1
a10006 1
      mips_opts.isa = ISA_MIPS3;
d10010 1
a10010 1
      mips_opts.isa = ISA_MIPS4;
d10014 1
a10014 1
      mips_opts.isa = ISA_MIPS5;
d10018 1
a10018 1
      mips_opts.isa = ISA_MIPS32;
d10022 1
a10022 1
      mips_opts.isa = ISA_MIPS64;
d10026 3
d10030 1
a10030 50
    case OPTION_MCPU:
      {
	int cpu = CPU_UNKNOWN;

	/* Identify the processor type.  */
	if (strcasecmp (arg, "default") != 0)
	  {
	    const struct mips_cpu_info *ci;

	    ci = mips_cpu_info_from_name (arg);
	    if (ci == NULL || ci->is_isa)
	      {
		switch (c)
		  {
		  case OPTION_MTUNE:
		    as_fatal (_("invalid architecture -mtune=%s"), arg);
		    break;
		  case OPTION_MARCH:
		    as_fatal (_("invalid architecture -march=%s"), arg);
		    break;
		  case OPTION_MCPU:
		    as_fatal (_("invalid architecture -mcpu=%s"), arg);
		    break;
		  }
	      }
	    else
	      cpu = ci->cpu;
	  }

	switch (c)
	  {
	  case OPTION_MTUNE:
	    if (mips_tune != CPU_UNKNOWN && mips_tune != cpu)
	      as_warn (_("A different -mtune= was already specified, is now "
			 "-mtune=%s"), arg);
	    mips_tune = cpu;
	    break;
	  case OPTION_MARCH:
	    if (mips_arch != CPU_UNKNOWN && mips_arch != cpu)
	      as_warn (_("A different -march= was already specified, is now "
			 "-march=%s"), arg);
	    mips_arch = cpu;
	    break;
	  case OPTION_MCPU:
	    if (mips_cpu != CPU_UNKNOWN && mips_cpu != cpu)
	      as_warn (_("A different -mcpu= was already specified, is now "
			 "-mcpu=%s"), arg);
	    mips_cpu = cpu;
	  }
      }
d10034 2
a10035 6
      if ((mips_arch != CPU_UNKNOWN && mips_arch != CPU_R4650)
	  || (mips_tune != CPU_UNKNOWN && mips_tune != CPU_R4650))
	as_warn (_("A different -march= or -mtune= was already specified, "
		   "is now -m4650"));
      mips_arch = CPU_R4650;
      mips_tune = CPU_R4650;
d10042 2
a10043 6
      if ((mips_arch != CPU_UNKNOWN && mips_arch != CPU_R4010)
	  || (mips_tune != CPU_UNKNOWN && mips_tune != CPU_R4010))
	as_warn (_("A different -march= or -mtune= was already specified, "
		   "is now -m4010"));
      mips_arch = CPU_R4010;
      mips_tune = CPU_R4010;
d10050 2
a10051 6
      if ((mips_arch != CPU_UNKNOWN && mips_arch != CPU_VR4100)
	  || (mips_tune != CPU_UNKNOWN && mips_tune != CPU_VR4100))
	as_warn (_("A different -march= or -mtune= was already specified, "
		   "is now -m4100"));
      mips_arch = CPU_VR4100;
      mips_tune = CPU_VR4100;
d10058 2
a10059 6
      if ((mips_arch != CPU_UNKNOWN && mips_arch != CPU_R3900)
	  || (mips_tune != CPU_UNKNOWN && mips_tune != CPU_R3900))
	as_warn (_("A different -march= or -mtune= was already specified, "
		   "is now -m3900"));
      mips_arch = CPU_R3900;
      mips_tune = CPU_R3900;
d10162 1
a10162 1
      mips_opts.abi = O32_ABI;
d10171 1
a10171 1
      mips_opts.abi = N32_ABI;
d10180 1
a10180 1
      mips_opts.abi = N64_ABI;
a10187 2
      if (mips_opts.abi != O32_ABI)
	mips_opts.abi = NO_ABI;
a10191 2
      if (mips_opts.abi == O32_ABI)
	mips_opts.abi = NO_ABI;
d10196 4
a10199 2
      if (mips_opts.abi != O32_ABI)
	mips_opts.abi = NO_ABI;
d10210 1
a10210 1
	mips_opts.abi = O32_ABI;
d10212 1
a10212 1
	mips_opts.abi = O64_ABI;
d10214 1
a10214 1
	mips_opts.abi = N32_ABI;
d10217 1
a10217 1
	  mips_opts.abi = N64_ABI;
d10223 1
a10223 1
	mips_opts.abi = EABI_ABI;
d10256 3
d10261 2
a10262 5
show (stream, string, col_p, first_p)
     FILE *stream;
     char *string;
     int *col_p;
     int *first_p;
d10264 1
a10264 1
  if (*first_p)
d10266 3
a10268 7
      fprintf (stream, "%24s", "");
      *col_p = 24;
    }
  else
    {
      fprintf (stream, ", ");
      *col_p += 2;
d10270 4
d10275 5
a10279 1
  if (*col_p + strlen (string) > 72)
d10281 2
a10282 2
      fprintf (stream, "\n%24s", "");
      *col_p = 24;
a10283 5

  fprintf (stream, "%s", string);
  *col_p += strlen (string);

  *first_p = 0;
a10285 83
void
md_show_usage (stream)
     FILE *stream;
{
  int column, first;

  fprintf (stream, _("\
MIPS options:\n\
-membedded-pic		generate embedded position independent code\n\
-EB			generate big endian output\n\
-EL			generate little endian output\n\
-g, -g2			do not remove unneeded NOPs or swap branches\n\
-G NUM			allow referencing objects up to NUM bytes\n\
			implicitly with the gp register [default 8]\n"));
  fprintf (stream, _("\
-mips1			generate MIPS ISA I instructions\n\
-mips2			generate MIPS ISA II instructions\n\
-mips3			generate MIPS ISA III instructions\n\
-mips4			generate MIPS ISA IV instructions\n\
-mips5                  generate MIPS ISA V instructions\n\
-mips32                 generate MIPS32 ISA instructions\n\
-mips64                 generate MIPS64 ISA instructions\n\
-march=CPU/-mtune=CPU	generate code/schedule for CPU, where CPU is one of:\n"));

  first = 1;

  show (stream, "2000", &column, &first);
  show (stream, "3000", &column, &first);
  show (stream, "3900", &column, &first);
  show (stream, "4000", &column, &first);
  show (stream, "4010", &column, &first);
  show (stream, "4100", &column, &first);
  show (stream, "4111", &column, &first);
  show (stream, "4300", &column, &first);
  show (stream, "4400", &column, &first);
  show (stream, "4600", &column, &first);
  show (stream, "4650", &column, &first);
  show (stream, "5000", &column, &first);
  show (stream, "5200", &column, &first);
  show (stream, "5230", &column, &first);
  show (stream, "5231", &column, &first);
  show (stream, "5261", &column, &first);
  show (stream, "5721", &column, &first);
  show (stream, "6000", &column, &first);
  show (stream, "8000", &column, &first);
  show (stream, "10000", &column, &first);
  show (stream, "12000", &column, &first);
  show (stream, "sb1", &column, &first);
  fputc ('\n', stream);

  fprintf (stream, _("\
-mCPU			equivalent to -march=CPU -mtune=CPU. Deprecated.\n\
-no-mCPU		don't generate code specific to CPU.\n\
			For -mCPU and -no-mCPU, CPU must be one of:\n"));

  first = 1;

  show (stream, "3900", &column, &first);
  show (stream, "4010", &column, &first);
  show (stream, "4100", &column, &first);
  show (stream, "4650", &column, &first);
  fputc ('\n', stream);

  fprintf (stream, _("\
-mips16			generate mips16 instructions\n\
-no-mips16		do not generate mips16 instructions\n"));
  fprintf (stream, _("\
-mgp32			use 32-bit GPRs, regardless of the chosen ISA\n\
-mfp32			use 32-bit FPRs, regardless of the chosen ISA\n\
-O0			remove unneeded NOPs, do not swap branches\n\
-O			remove unneeded NOPs and swap branches\n\
-n			warn about NOPs generated from macros\n\
--[no-]construct-floats [dis]allow floating point values to be constructed\n\
--trap, --no-break	trap exception on div by 0 and mult overflow\n\
--break, --no-trap	break exception on div by 0 and mult overflow\n"));
#ifdef OBJ_ELF
  fprintf (stream, _("\
-KPIC, -call_shared	generate SVR4 position independent code\n\
-non_shared		do not generate position independent code\n\
-xgot			assume a 32 bit GOT\n\
-mabi=ABI		create ABI conformant object file for:\n"));

  first = 1;
a10286 15
  show (stream, "32", &column, &first);
  show (stream, "o64", &column, &first);
  show (stream, "n32", &column, &first);
  show (stream, "64", &column, &first);
  show (stream, "eabi", &column, &first);

  fputc ('\n', stream);

  fprintf (stream, _("\
-32			create o32 ABI object file (default)\n\
-n32			create n32 ABI object file\n\
-64			create 64 ABI object file\n"));
#endif
}

a10289 5
  const char *cpu;
  char *a = NULL;
  int mips_isa_from_cpu;
  const struct mips_cpu_info *ci;

d10299 4
a10302 8
  cpu = TARGET_CPU;
  if (strcmp (cpu + (sizeof TARGET_CPU) - 3, "el") == 0)
    {
      a = xmalloc (sizeof TARGET_CPU);
      strcpy (a, TARGET_CPU);
      a[(sizeof TARGET_CPU) - 3] = '\0';
      cpu = a;
    }
d10304 2
a10305 9
  /* Backward compatibility for historic -mcpu= option.  Check for
     incompatible options, warn if -mcpu is used.  */
  if (mips_cpu != CPU_UNKNOWN
      && mips_arch != CPU_UNKNOWN
      && mips_cpu != mips_arch)
    {
      as_fatal (_("The -mcpu option can't be used together with -march. "
		  "Use -mtune instead of -mcpu."));
    }
d10307 2
a10308 7
  if (mips_cpu != CPU_UNKNOWN
      && mips_tune != CPU_UNKNOWN
      && mips_cpu != mips_tune)
    {
      as_fatal (_("The -mcpu option can't be used together with -mtune. "
		  "Use -march instead of -mcpu."));
    }
d10310 1
a10310 6
#if 1
  /* For backward compatibility, let -mipsN set various defaults.  */
  /* This code should go away, to be replaced with something rather more
     draconian.  Until GCC 3.1 has been released for some reasonable
     amount of time, however, we need to support this.  */
  if (mips_opts.isa != ISA_UNKNOWN)
d10312 4
a10315 3
      /* Translate -mipsN to the appropriate settings of file_mips_gp32
	 and file_mips_fp32.  Tag binaries as using the mipsN ISA.  */
      if (file_mips_gp32 < 0)
d10317 7
a10323 26
	  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
	    file_mips_gp32 = 0;
	  else
	    file_mips_gp32 = 1;
	}
      if (file_mips_fp32 < 0)
	{
	  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
	    file_mips_fp32 = 0;
	  else
	    file_mips_fp32 = 1;
	}

      ci = mips_cpu_info_from_isa (mips_opts.isa);
      assert (ci != NULL);
      /* -mipsN has higher priority than -mcpu but lower than -march.  */
      if (mips_arch == CPU_UNKNOWN)
	mips_arch = ci->cpu;

      /* Default mips_abi.  */
      if (mips_opts.abi == NO_ABI)
	{
	  if (mips_opts.isa == ISA_MIPS1 || mips_opts.isa == ISA_MIPS2)
	    mips_opts.abi = O32_ABI;
	  else if (mips_opts.isa == ISA_MIPS3 || mips_opts.isa == ISA_MIPS4)
	    mips_opts.abi = O64_ABI;
d10325 2
d10329 3
a10331 8
  if (mips_arch == CPU_UNKNOWN && mips_cpu != CPU_UNKNOWN)
    {
      ci = mips_cpu_info_from_cpu (mips_cpu);
      assert (ci != NULL);
      mips_arch = ci->cpu;
      as_warn (_("The -mcpu option is deprecated.  Please use -march and "
		 "-mtune instead."));
    }
d10333 3
a10335 7
  /* Set tune from -mcpu, not from -mipsN.  */
  if (mips_tune == CPU_UNKNOWN && mips_cpu != CPU_UNKNOWN)
    {
      ci = mips_cpu_info_from_cpu (mips_cpu);
      assert (ci != NULL);
      mips_tune = ci->cpu;
    }
d10337 3
a10339 4
  /* At this point, mips_arch will either be CPU_UNKNOWN if no ARCH was
     specified on the command line, or some other value if one was.
     Similarly, mips_opts.isa will be ISA_UNKNOWN if not specified on
     the command line, or will be set otherwise if one was.  */
d10341 1
a10341 46
  if (mips_arch != CPU_UNKNOWN && mips_opts.isa != ISA_UNKNOWN)
    /* Handled above.  */;
#else
  if (mips_arch == CPU_UNKNOWN && mips_cpu != CPU_UNKNOWN)
    {
      ci = mips_cpu_info_from_cpu (mips_cpu);
      assert (ci != NULL);
      mips_arch = ci->cpu;
      as_warn (_("The -mcpu option is deprecated.  Please use -march and "
		 "-mtune instead."));
    }

  /* At this point, mips_arch will either be CPU_UNKNOWN if no ARCH was
     specified on the command line, or some other value if one was.
     Similarly, mips_opts.isa will be ISA_UNKNOWN if not specified on
     the command line, or will be set otherwise if one was.  */

  if (mips_arch != CPU_UNKNOWN && mips_opts.isa != ISA_UNKNOWN)
    {
      /* We have to check if the isa is the default isa of arch.  Otherwise
         we'll get invalid object file headers.  */
      ci = mips_cpu_info_from_cpu (mips_arch);
      assert (ci != NULL);
      if (mips_opts.isa != ci->isa)
	{
	  /* This really should be an error instead of a warning, but old
	     compilers only have -mcpu which sets both arch and tune.  For
	     now, we discard arch and preserve tune.  */
	  as_warn (_("The -march option is incompatible to -mipsN and "
		     "therefore ignored."));
	  if (mips_tune == CPU_UNKNOWN)
	    mips_tune = mips_arch;
	  ci = mips_cpu_info_from_isa (mips_opts.isa);
	  assert (ci != NULL);
	  mips_arch = ci->cpu;
	}
    }
#endif
  else if (mips_arch != CPU_UNKNOWN && mips_opts.isa == ISA_UNKNOWN)
    {
      /* We have ARCH, we need ISA.  */
      ci = mips_cpu_info_from_cpu (mips_arch);
      assert (ci != NULL);
      mips_opts.isa = ci->isa;
    }
  else if (mips_arch == CPU_UNKNOWN && mips_opts.isa != ISA_UNKNOWN)
d10343 8
a10350 4
      /* We have ISA, we need default ARCH.  */
      ci = mips_cpu_info_from_isa (mips_opts.isa);
      assert (ci != NULL);
      mips_arch = ci->cpu;
d10354 5
a10358 7
      /* We need to set both ISA and ARCH from target cpu.  */
      ci = mips_cpu_info_from_name (cpu);
      if (ci == NULL)
	ci = mips_cpu_info_from_cpu (CPU_R3000);
      assert (ci != NULL);
      mips_opts.isa = ci->isa;
      mips_arch = ci->cpu;
d10361 8
a10368 2
  if (mips_tune == CPU_UNKNOWN)
    mips_tune = mips_arch;
d10370 1
a10370 3
  ci = mips_cpu_info_from_cpu (mips_arch);
  assert (ci != NULL);
  mips_isa_from_cpu = ci->isa;
d10372 5
a10376 8
  /* End of TARGET_CPU processing, get rid of malloced memory
     if necessary.  */
  cpu = NULL;
  if (a != NULL)
    {
      free (a);
      a = NULL;
    }
a10380 7
  /* If they asked for mips1 or mips2 and a cpu that is
     mips3 or greater, then mark the object file 32BITMODE.  */
  if (mips_isa_from_cpu != ISA_UNKNOWN
      && ! ISA_HAS_64BIT_REGS (mips_opts.isa)
      && ISA_HAS_64BIT_REGS (mips_isa_from_cpu))
    mips_32bitmode = 1;

a10389 5
  if (file_mips_gp32 < 0)
    file_mips_gp32 = 0;
  if (file_mips_fp32 < 0)
    file_mips_fp32 = 0;

a10390 1
  file_mips_abi = mips_opts.abi;
a11464 1
	  mips_opts.abi = file_mips_abi;
a11475 3
	  /* Loosen ABI register width restriction.  */
	  if (mips_opts.abi == O32_ABI)
	    mips_opts.abi = NO_ABI;
d12925 1
a12925 1
  if (file_mips_abi != N64_ABI)
d12975 1
a12975 3
  if (file_mips_abi == NO_ABI)
    ;
  else if (file_mips_abi == O32_ABI)
d12977 1
a12977 1
  else if (file_mips_abi == O64_ABI)
d12979 1
a12979 1
  else if (file_mips_abi == EABI_ABI)
d12981 1
a12981 3
      /* Set the EABI kind based on the ISA.  This isn't really
	 the best, but then neither is basing the abi on the isa.  */
      if (ISA_HAS_64BIT_REGS (file_mips_isa))
d12986 1
a12986 1
  else if (file_mips_abi == N32_ABI)
d13427 2
a13428 6
/* CPU name/ISA/number mapping table.

   Entries are grouped by type.  The first matching CPU or ISA entry
   gets chosen by CPU or ISA, so it should be the 'canonical' name
   for that type.  Entries after that within the type are sorted
   alphabetically.
d13430 2
a13431 2
   Case is ignored in comparison, so put the canonical entry in the
   appropriate case but everything else in lower case to ease eye pain.  */
d13434 41
a13474 21
  /* MIPS1 ISA */
  { "MIPS1",          1,      ISA_MIPS1,      CPU_R3000, },
  { "mips",           1,      ISA_MIPS1,      CPU_R3000, },

  /* MIPS2 ISA */
  { "MIPS2",          1,      ISA_MIPS2,      CPU_R6000, },

  /* MIPS3 ISA */
  { "MIPS3",          1,      ISA_MIPS3,      CPU_R4000, },

  /* MIPS4 ISA */
  { "MIPS4",          1,      ISA_MIPS4,      CPU_R8000, },

  /* MIPS5 ISA */
  { "MIPS5",          1,      ISA_MIPS5,      CPU_MIPS5, },
  { "Generic-MIPS5",  0,      ISA_MIPS5,      CPU_MIPS5, },

  /* MIPS32 ISA */
  { "MIPS32",         1,      ISA_MIPS32,     CPU_MIPS32, },
  { "mipsisa32",      0,      ISA_MIPS32,     CPU_MIPS32, },
  { "Generic-MIPS32", 0,      ISA_MIPS32,     CPU_MIPS32, },
d13476 2
a13477 5
  { "4km",            0,      ISA_MIPS32,     CPU_MIPS32, },
  { "4kp",            0,      ISA_MIPS32,     CPU_MIPS32, },

  /* For historical reasons.  */
  { "MIPS64",         1,      ISA_MIPS3,      CPU_R4000, },
d13479 3
a13481 107
  /* MIPS64 ISA */
  { "mipsisa64",      1,      ISA_MIPS64,     CPU_MIPS64, },
  { "Generic-MIPS64", 0,      ISA_MIPS64,     CPU_MIPS64, },
  { "5kc",            0,      ISA_MIPS64,     CPU_MIPS64, },
  { "20kc",           0,      ISA_MIPS64,     CPU_MIPS64, },

  /* R2000 CPU */
  { "R2000",          0,      ISA_MIPS1,      CPU_R2000, },
  { "2000",           0,      ISA_MIPS1,      CPU_R2000, },
  { "2k",             0,      ISA_MIPS1,      CPU_R2000, },
  { "r2k",            0,      ISA_MIPS1,      CPU_R2000, },

  /* R3000 CPU */
  { "R3000",          0,      ISA_MIPS1,      CPU_R3000, },
  { "3000",           0,      ISA_MIPS1,      CPU_R3000, },
  { "3k",             0,      ISA_MIPS1,      CPU_R3000, },
  { "r3k",            0,      ISA_MIPS1,      CPU_R3000, },

  /* TX3900 CPU */
  { "R3900",          0,      ISA_MIPS1,      CPU_R3900, },
  { "3900",           0,      ISA_MIPS1,      CPU_R3900, },
  { "mipstx39",       0,      ISA_MIPS1,      CPU_R3900, },

  /* R4000 CPU */
  { "R4000",          0,      ISA_MIPS3,      CPU_R4000, },
  { "4000",           0,      ISA_MIPS3,      CPU_R4000, },
  { "4k",             0,      ISA_MIPS3,      CPU_R4000, },   /* beware */
  { "r4k",            0,      ISA_MIPS3,      CPU_R4000, },

  /* R4010 CPU */
  { "R4010",          0,      ISA_MIPS2,      CPU_R4010, },
  { "4010",           0,      ISA_MIPS2,      CPU_R4010, },

  /* R4400 CPU */
  { "R4400",          0,      ISA_MIPS3,      CPU_R4400, },
  { "4400",           0,      ISA_MIPS3,      CPU_R4400, },

  /* R4600 CPU */
  { "R4600",          0,      ISA_MIPS3,      CPU_R4600, },
  { "4600",           0,      ISA_MIPS3,      CPU_R4600, },
  { "mips64orion",    0,      ISA_MIPS3,      CPU_R4600, },
  { "orion",          0,      ISA_MIPS3,      CPU_R4600, },

  /* R4650 CPU */
  { "R4650",          0,      ISA_MIPS3,      CPU_R4650, },
  { "4650",           0,      ISA_MIPS3,      CPU_R4650, },

  /* R6000 CPU */
  { "R6000",          0,      ISA_MIPS2,      CPU_R6000, },
  { "6000",           0,      ISA_MIPS2,      CPU_R6000, },
  { "6k",             0,      ISA_MIPS2,      CPU_R6000, },
  { "r6k",            0,      ISA_MIPS2,      CPU_R6000, },

  /* R8000 CPU */
  { "R8000",          0,      ISA_MIPS4,      CPU_R8000, },
  { "8000",           0,      ISA_MIPS4,      CPU_R8000, },
  { "8k",             0,      ISA_MIPS4,      CPU_R8000, },
  { "r8k",            0,      ISA_MIPS4,      CPU_R8000, },

  /* R10000 CPU */
  { "R10000",         0,      ISA_MIPS4,      CPU_R10000, },
  { "10000",          0,      ISA_MIPS4,      CPU_R10000, },
  { "10k",            0,      ISA_MIPS4,      CPU_R10000, },
  { "r10k",           0,      ISA_MIPS4,      CPU_R10000, },

  /* R12000 CPU */
  { "R12000",         0,      ISA_MIPS4,      CPU_R12000, },
  { "12000",          0,      ISA_MIPS4,      CPU_R12000, },
  { "12k",            0,      ISA_MIPS4,      CPU_R12000, },
  { "r12k",           0,      ISA_MIPS4,      CPU_R12000, },

  /* VR4100 CPU */
  { "VR4100",         0,      ISA_MIPS3,      CPU_VR4100, },
  { "4100",           0,      ISA_MIPS3,      CPU_VR4100, },
  { "mips64vr4100",   0,      ISA_MIPS3,      CPU_VR4100, },
  { "r4100",          0,      ISA_MIPS3,      CPU_VR4100, },

  /* VR4111 CPU */
  { "VR4111",         0,      ISA_MIPS3,      CPU_R4111, },
  { "4111",           0,      ISA_MIPS3,      CPU_R4111, },
  { "mips64vr4111",   0,      ISA_MIPS3,      CPU_R4111, },
  { "r4111",          0,      ISA_MIPS3,      CPU_R4111, },

  /* VR4300 CPU */
  { "VR4300",         0,      ISA_MIPS3,      CPU_R4300, },
  { "4300",           0,      ISA_MIPS3,      CPU_R4300, },
  { "mips64vr4300",   0,      ISA_MIPS3,      CPU_R4300, },
  { "r4300",          0,      ISA_MIPS3,      CPU_R4300, },

  /* VR5000 CPU */
  { "VR5000",         0,      ISA_MIPS4,      CPU_R5000, },
  { "5000",           0,      ISA_MIPS4,      CPU_R5000, },
  { "5k",             0,      ISA_MIPS4,      CPU_R5000, },
  { "mips64vr5000",   0,      ISA_MIPS4,      CPU_R5000, },
  { "r5000",          0,      ISA_MIPS4,      CPU_R5000, },
  { "r5200",          0,      ISA_MIPS4,      CPU_R5000, },
  { "rm5200",         0,      ISA_MIPS4,      CPU_R5000, },
  { "r5230",          0,      ISA_MIPS4,      CPU_R5000, },
  { "rm5230",         0,      ISA_MIPS4,      CPU_R5000, },
  { "r5231",          0,      ISA_MIPS4,      CPU_R5000, },
  { "rm5231",         0,      ISA_MIPS4,      CPU_R5000, },
  { "r5261",          0,      ISA_MIPS4,      CPU_R5000, },
  { "rm5261",         0,      ISA_MIPS4,      CPU_R5000, },
  { "r5721",          0,      ISA_MIPS4,      CPU_R5000, },
  { "rm5721",         0,      ISA_MIPS4,      CPU_R5000, },
  { "r5k",            0,      ISA_MIPS4,      CPU_R5000, },
  { "r7000",          0,      ISA_MIPS4,      CPU_R5000, },
d13484 4
a13487 4
  { "SB-1",           0,      ISA_MIPS64,     CPU_SB1, },
  { "sb-1250",        0,      ISA_MIPS64,     CPU_SB1, },
  { "sb1",            0,      ISA_MIPS64,     CPU_SB1, },
  { "sb1250",         0,      ISA_MIPS64,     CPU_SB1, },
d13489 2
a13490 2
  /* End marker.  */
  { NULL, 0, 0, 0, },
d13493 59
d13553 2
a13554 2
mips_cpu_info_from_name (name)
     const char *name;
d13556 31
a13586 1
  int i;
d13588 3
a13590 3
  for (i = 0; mips_cpu_info_table[i].name != NULL; i++)
    if (strcasecmp (name, mips_cpu_info_table[i].name) == 0)
      return (&mips_cpu_info_table[i]);
d13592 2
a13593 1
  return NULL;
d13596 3
d13607 1
a13607 1
      && isa == mips_cpu_info_table[i].isa)
d13612 24
d13637 9
a13645 3
static const struct mips_cpu_info *
mips_cpu_info_from_cpu (cpu)
     int cpu;
d13647 22
a13668 1
  int i;
d13671 45
a13715 3
    if (!mips_cpu_info_table[i].is_isa
      && cpu == mips_cpu_info_table[i].cpu)
      return (&mips_cpu_info_table[i]);
d13717 5
a13721 1
  return NULL;
@


1.148
log
@	* config/tc-mips.c (mips_pic_level): Remove IRIX4_PIC.
@
text
@d10866 1
a10866 1
	  || S_IS_EXTERN (fixP->fx_addsy))
d12692 2
a12693 1
			&& (! S_IS_EXTERN (sym) || mips_pic == EMBEDDED_PIC)))
d12735 1
a12735 1
      && (S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)))
@


1.147
log
@	* config/tc-mips.c (macro_build): Handle MIPS16 insns.
	(mips_ip): Likewise.
	* mips.h (INSN_MIPS16): New define.
	* mips-dis.c (mips_isa_type): Add MIPS16 insn handling.
	* mips-opc.c (I16): New define.
	(mips_builtin_opcodes): Make jalx an I16 insn.
@
text
@a327 4
  /* Generate PIC code as in Irix 4.  This is not implemented, and I'm
     not sure what it is supposed to do.  */
  IRIX4_PIC,

@


1.147.2.1
log
@2002-07-31  Daniel Jacobowitz  <drow@@mvista.com>

        Merge from mainline:
        2002-07-30  Maciej W. Rozycki  <macro@@ds2.pg.gda.pl>
        * tc-mips.c (load_address): Don't clobber $at when loading a
        64-bit address in non-PIC code if noat is in effect.
        (macro): Likewise.

        2002-07-30  Maciej W. Rozycki  <macro@@ds2.pg.gda.pl>
        * config/tc-mips.c (macro): Use codes 6 and 7 in trap instructions
        used in division/multiply macro expansions similarly to how they
        are used in the variants with break instructions.
        (macro2): Likewise.
@
text
@d3550 1
a3550 1
	  if (*used_at == 0 && ! mips_opts.noat)
d4262 1
a4262 1
			 "s,t,q", 0, 0, 7);
d4275 1
a4275 1
		       "s,t,q", treg, 0, 7);
d4311 1
a4311 1
		       "s,t,q", sreg, AT, 6);
d4374 1
a4374 1
			 "s,t,q", 0, 0, 7);
d4430 1
a4430 1
		       "s,t,q", treg, 0, 7);
d4565 1
a4565 1
	      if (used_at == 0 && ! mips_opts.noat)
d5518 1
a5518 1
	      if (used_at == 0 && ! mips_opts.noat)
d6579 2
a6580 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "tne",
		     "s,t,q", dreg, AT, 6);
d6618 2
a6619 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "tne",
		     "s,t,q", AT, 0, 6);
@


1.147.2.2
log
@        Merge from mainline:
        2002-08-01  Richard Sandiford  <rsandifo@@redhat.com>
        * config/tc-mips.c (tc_gen_reloc): Extend GP-relative addend
        handling to BFD_RELOC_MIPS16_GPREL.

        Merge from mainline:
        2002-08-01  Richard Sandiford  <rsandifo@@redhat.com>
        * gas/mips/elf-rel6.[sd]: New test.
        * gas/mips/mips.exp: Run it.
@
text
@d12967 1
a12967 1
      && (code == BFD_RELOC_GPREL16 || code == BFD_RELOC_MIPS16_GPREL)
@


1.147.2.3
log
@* config/tc-mips.c (macro): Handle a register plus a 16-bit
immediate offset in "dla" and "la" expansions.
* gas/mips/empic.d: Treat "addiu" and "daddiu" as equivalent when
$0 is source.
* mips-opc.c (mips_builtin_opcodes): Remove "dla" and "la" as
aliases to "daddiu" and "addiu".
@
text
@a4464 10
      if (offset_expr.X_op == O_constant
	  && offset_expr.X_add_number >= -0x8000
	  && offset_expr.X_add_number < 0x8000)
	{
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       (dbl || HAVE_64BIT_ADDRESSES) ? "daddiu" : "addiu",
		       "t,r,j", treg, sreg, (int) BFD_RELOC_LO16);
	  return;
	}

@


1.147.2.4
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* write.c: Delete set_segment_vma and prototype. Update all callers.

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (tc_i386_fix_adjustable): Handle
	BFD_RELOC_386_TLS_IE and BFD_RELOC_386_TLS_GOTIE.
	(BFD_RELOC_386_TLS_IE, BFD_RELOC_386_TLS_GOTIE): Define to 0
	if not defined.
	(lex_got): Handle @@GOTNTPOFF and @@INDNTPOFF.
	(md_apply_fix3, tc_gen_reloc): Handle BFD_RELOC_386_TLS_IE and
	BFD_RELOC_386_TLS_GOTIE.

	2002-09-16  Chris Demetriou  <cgd@@broadcom.com>
	* config/tc-mips.c (IS_SEXT_32BIT_NUM): Move closer to top of file.
	(IS_SEXT_16BIT_NUM): New macro.
	(macro_build_ldst_constoffset): New function, to build a set of
	instructions to do a load or store from a constant offset relative
	to a given register.
	(macro, s_cprestore): Use macro_build_ldst_constoffset to implement
	.cprestore pseudo-op.

	2002-09-16  Elias Athanasopoulos  <eathan@@otenet.gr>
	* dwarf2dbg.c (out_debug_abbrev): Add support for the DW_AT_name field.
	(out_debug_info): Likewise.

	2002-09-13  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_assemble): Do not count FAKE operands
	when deciding if any operands have been skipped.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (md_apply_fix3): Allow addend for
	BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_386_TLS_LE and
	BFD_RELOC_386_TLS_LE_32.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-09-04  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_begin): Do not insert non-BookE32
	instructions into the hash table if the target cpu is the BookE32.

	2002-08-20  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (macro2): Implement rotates by zero using shifts
	by zero.

	2002-08-15  Alexandre Oliva  <aoliva@@redhat.com>
	* config/tc-mips.c (macro_build_jalr): Make sure we generate
	the fix-up against on the right frag.
	(s_cpsetup): Likewise.  Parse third argument as expression, to
	handle global symbols and forward/backward labels correctly.

	2002-08-14  Nick Clifton  <nickc@@redhat.com>
	* read.c (stringer): Catch attempts to create strings in the abs
	section.

	2002-08-12  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (mips_ip): Don't work out the value of
	constant %hi()s here.

	2002-08-10  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_i386_fix_adjustable): Test OUTPUT_FLAVOR
	for ELF, and don't bother checking ELF relocs when non-ELF.
	(i386_immediate): Allow absolute_section expressions for aout.
	(i386_displacement): Likewise.  Also test bfd_is_com_section.
	(md_estimate_size_before_relax): Test OUTPUT_FLAVOR for ELF.
	(md_apply_fix3): Hack for bfd_install_relocation when fx_pcrel,
	not when fx_addsy.  Remove dead code.

	2002-08-06  George France <france@@handhelds.org>
	* config/tc-alpha.c (cpu_types): Enabled ev67, ev68,  -m21264a
	and m21264b processor names and cpu types.
	* doc/c-alpha.texi: Documented new types.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-ppc.c (md_apply_fix3): Adjust 16 bit XCOFF reloc offset.

	2002-08-03  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (output_insn): Save frag_now and frag_now_fix ()
	at start of insn, pass it to output_disp and output_imm.
	(output_disp): Added arguments.  If _GLOBAL_OFFSET_TABLE_ is seen
	in displacement for R_386_32 reloc, use R_386_GOTPC and compute
	properly addend.
	(output_imm): Added arguments.  Compute properly addend for
	R_386_GOTPC.
	(md_apply_fix3): Remove R_386_GOTPC handling.

	2002-07-31  Momchil Velikov  <velco@@fadata.bg>
	* config/tc-v850.c (md_assemble): Fix range check for immediate
	operand.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".
@
text
@a684 11

/* Is the given value a sign-extended 32-bit value?  */
#define IS_SEXT_32BIT_NUM(x)						\
  (((x) &~ (offsetT) 0x7fffffff) == 0					\
   || (((x) &~ (offsetT) 0x7fffffff) == ~ (offsetT) 0x7fffffff))

/* Is the given value a sign-extended 16-bit value?  */
#define IS_SEXT_16BIT_NUM(x)						\
  (((x) &~ (offsetT) 0x7fff) == 0					\
   || (((x) &~ (offsetT) 0x7fff) == ~ (offsetT) 0x7fff))

a720 3
static void macro_build_ldst_constoffset PARAMS ((char *place, int *counter,
						  expressionS * ep, const char *op,
						  int valreg, int breg));
a3030 2
  char *f;
  
d3032 1
a3032 4
    {
      frag_grow (4);
      f = frag_more (0);
    }
d3036 1
a3036 2
    fix_new_exp (frag_now, f - frag_now->fr_literal,
		 0, ep, false, BFD_RELOC_MIPS_JALR);
a3107 46
/* Generate a sequence of instructions to do a load or store from a constant
   offset off of a base register (breg) into/from a target register (treg),
   using AT if necessary.  */
static void
macro_build_ldst_constoffset (place, counter, ep, op, treg, breg)
     char *place;
     int *counter;
     expressionS *ep;
     const char *op;
     int treg, breg;
{
  assert (ep->X_op == O_constant);

  /* Right now, this routine can only handle signed 32-bit contants.  */
  if (! IS_SEXT_32BIT_NUM(ep->X_add_number))
    as_warn (_("operand overflow"));

  if (IS_SEXT_16BIT_NUM(ep->X_add_number))
    {
      /* Signed 16-bit offset will fit in the op.  Easy!  */
      macro_build (place, counter, ep, op, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, breg);
    }
  else
    {
      /* 32-bit offset, need multiple instructions and AT, like:
	   lui      $tempreg,const_hi       (BFD_RELOC_HI16_S)
	   addu     $tempreg,$tempreg,$breg
           <op>     $treg,const_lo($tempreg)   (BFD_RELOC_LO16)
         to handle the complete offset.  */
      macro_build_lui (place, counter, ep, AT);
      if (place != NULL)
	place += 4;
      macro_build (place, counter, (expressionS *) NULL,
		   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
		   "d,v,t", AT, AT, breg);
      if (place != NULL)
	place += 4;
      macro_build (place, counter, ep, op, "t,o(b)", treg,
		   (int) BFD_RELOC_LO16, AT);

      if (mips_opts.noat)
	as_warn (_("Macro used $at after \".set noat\""));
    }
}

d3222 5
d5077 4
a5080 3
  		  macro_build_ldst_constoffset ((char *) NULL, &icnt, &expr1,
					        HAVE_32BIT_ADDRESSES ? "lw" : "ld",
					        mips_gp_register, mips_frame_reg);
d5210 4
a5213 3
  		  macro_build_ldst_constoffset ((char *) NULL, &icnt, &expr1,
					        HAVE_32BIT_ADDRESSES ? "lw" : "ld",
					        mips_gp_register, mips_frame_reg);
d6667 1
d6672 11
a6682 17
	if (rot == 0)
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrl",
		       "d,w,<", dreg, sreg, 0);
	else
	  {
	    char *l, *r;

	    l = (rot < 0x20) ? "dsll" : "dsll32";
	    r = ((0x40 - rot) < 0x20) ? "dsrl" : "dsrl32";
	    rot &= 0x1f;
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
			 "d,w,<", AT, sreg, rot);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
			 "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
			 "d,v,t", dreg, dreg, AT);
	  }
d6693 8
a6700 12
	if (rot == 0)
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
		       "d,w,<", dreg, sreg, 0);
	else
	  {
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
			 "d,w,<", AT, sreg, rot);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
			 "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
			 "d,v,t", dreg, dreg, AT);
	  }
d6729 1
d6734 11
a6744 17
	if (rot == 0)
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrl",
		       "d,w,<", dreg, sreg, 0);
	else
	  {
	    char *l, *r;

	    r = (rot < 0x20) ? "dsrl" : "dsrl32";
	    l = ((0x40 - rot) < 0x20) ? "dsll" : "dsll32";
	    rot &= 0x1f;
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
			 "d,w,<", AT, sreg, rot);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
			 "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
			 "d,v,t", dreg, dreg, AT);
	  }
d6755 8
a6762 12
	if (rot == 0)
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
		       "d,w,<", dreg, sreg, 0);
	else
	  {
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
			 "d,w,<", AT, sreg, rot);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
			 "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
			 "d,v,t", dreg, dreg, AT);
	  }
d8543 3
a8545 5
		      if (c == S_EX_HI)
			{
			  *imm_reloc = BFD_RELOC_HI16_S;
			  imm_unmatched_hi = true;
			}
d8571 5
d8676 4
a8679 1
		      if (c == S_EX_HI)
d8713 3
a8715 3
	      else if (imm_expr.X_op == O_constant
		       && (imm_expr.X_add_number < 0
			   || imm_expr.X_add_number >= 0x10000))
d11924 1
a11924 1
  char *f;
d11963 9
a11971 1
  expression (&ex_sym);
a11986 4
  /* Ensure there's room for the next two instructions, so that `f'
     doesn't end up with an address in the wrong frag.  */
  frag_grow (8);
  f = frag_more (0);
d11989 2
a11990 6
  fix_new (frag_now, f - frag_now->fr_literal,
	   0, NULL, 0, 0, BFD_RELOC_MIPS_SUB);
  fix_new (frag_now, f - frag_now->fr_literal,
	   0, NULL, 0, 0, BFD_RELOC_HI16_S);

  f = frag_more (0);
d11993 2
a11994 5
  fix_new (frag_now, f - frag_now->fr_literal,
	   0, NULL, 0, 0, BFD_RELOC_MIPS_SUB);
  fix_new (frag_now, f - frag_now->fr_literal,
	   0, NULL, 0, 0, BFD_RELOC_LO16);

d12045 2
a12046 3
  macro_build_ldst_constoffset ((char *) NULL, &icnt, &ex,
				HAVE_32BIT_ADDRESSES ? "sw" : "sd",
				mips_gp_register, SP);
@


1.147.2.5
log
@Merge from mainline.
@
text
@d10957 1
a10957 1
	    & (SEC_LINK_ONCE | SEC_MERGE)) != 0)
@


1.147.2.6
log
@        * config/tc-mips.c (support_64bit_objects): Check *l before it
        is freed.
@
text
@a9906 1
  int yes;
a9918 1
  yes = (*l != NULL);
d9920 1
a9920 1
  return yes;
@


1.146
log
@* config/tc-mips.c (macro): Shift the 32-bit address range
accessible with a lone "lui" down by 32768.
@
text
@d2731 4
a2734 1
	  && OPCODE_IS_MEMBER (insn.insn_mo, mips_opts.isa, mips_arch)
d7739 1
@


1.145
log
@* config/tc-mips.c (load_address): Use non-trapping "daddu"
instead of "dadd" in address calculations.
(macro): Likewise.
@
text
@d5500 3
a5502 1
	     mechanism since it is more efficient.  This code should
d5508 1
a5508 1
		   && IS_SEXT_32BIT_NUM (offset_expr.X_add_number)))
@


1.144
log
@2002-06-14  H.J. Lu  <hjl@@gnu.org>
            Daniel Jacobowitz  <drow@@mvista.com>

        * dwarf2dbg.h (dwarf2_directive_file): Return char *.
        * dwarf2dbg.c (dwarf2_directive_file): Return filename.
        * config/tc-mips.c (s_mips_file): Call s_app_file_string
        and new_logical_line for the first .file directive.
        * read.c (s_app_file_string): New function.
        (s_app_file): Call it.
        * read.h (s_app_file_string): Add declaration.

2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * configure.in: Remove MIPS_STABS_ELF.
        * configure: Regenerated.
        * config.in: Regenerated.
        * config/obj-elf.h (ECOFF_DEBUGGING): Define to mips_flag_mdebug
        for MIPS targets.
        * config/tc-mips.c (mips_pseudo_table): Remove #ifdef around
        ".extern".
        (pdr_seg): Declare unconditionally.
        (md_begin): Always generate .pdr unless ECOFF_DEBUGGING or not ELF.
        (s_mips_end): Likewise.  Generate stabs function markers.
        (s_mips_ent): Generate stabs function markers.
        (s_mips_frame): Always generate .pdr unless ECOFF_DEBUGGING or not
        ELF.
        (s_mips_mask): Likewise.
        (mips_flag_mdebug): New.
        (md_longopts): Add "mdebug" and "no-mdebug".
        (md_parse_options): Add OPTION_MDEBUG and OPTION_NO_MDEBUG.
        (mips_after_parse_args): Set mips_flag_mdebug.
        * doc/as.texinfo: Add "-mdebug" and "-no-mdebug" for MIPS.

2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gas/mips/lineno.d: Use --gstabs.
        * gas/mips/mips.exp (lineno.s): Remove XFAIL.
@
text
@d3531 1
a3531 1
	   dadd		$reg,$reg,$at
d3559 1
a3559 1
	      macro_build (p, counter, (expressionS *) NULL, "dadd",
d4545 1
a4545 1
	      dadd	$tempreg,$tempreg,$at
d4574 2
a4575 2
		  macro_build (p, &icnt, (expressionS *) NULL, "dadd", "d,v,t",
			       tempreg, tempreg, AT);
@


1.143
log
@* config/tc-mips.c (md_apply_fix3): Don't subtract the symbol's
value twice for RELA relocations.
@
text
@d80 2
a889 1
#ifdef MIPS_STABS_ELF
a890 1
#endif
d970 2
a971 2
#ifdef MIPS_STABS_ELF
/* The pdr segment for per procedure frame/regmask info */
a973 1
#endif
d1226 9
a1234 6

#ifdef MIPS_STABS_ELF
	pdr_seg = subseg_new (".pdr", (subsegT) 0);
	(void) bfd_set_section_flags (stdoutput, pdr_seg,
			     SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);
	(void) bfd_set_section_alignment (stdoutput, pdr_seg, 2);
d9934 4
d10304 10
d10669 10
d13394 2
d13402 16
a13417 1
    dwarf2_directive_file (0);
d13478 4
d13486 9
a13494 7
#ifdef MIPS_STABS_ELF
  {
    segT saved_seg = now_seg;
    subsegT saved_subseg = now_subseg;
    valueT dot;
    expressionS exp;
    char *fragp;
d13496 1
a13496 1
    dot = frag_now_fix ();
d13499 1
a13499 1
    md_flush_pending_output ();
d13502 10
a13511 2
    assert (pdr_seg);
    subseg_set (pdr_seg, 0);
d13513 11
a13523 19
    /* Write the symbol.  */
    exp.X_op = O_symbol;
    exp.X_add_symbol = p;
    exp.X_add_number = 0;
    emit_expr (&exp, 4);

    fragp = frag_more (7 * 4);

    md_number_to_chars (fragp,      (valueT) cur_proc_ptr->reg_mask, 4);
    md_number_to_chars (fragp +  4, (valueT) cur_proc_ptr->reg_offset, 4);
    md_number_to_chars (fragp +  8, (valueT) cur_proc_ptr->fpreg_mask, 4);
    md_number_to_chars (fragp + 12, (valueT) cur_proc_ptr->fpreg_offset, 4);
    md_number_to_chars (fragp + 16, (valueT) cur_proc_ptr->frame_offset, 4);
    md_number_to_chars (fragp + 20, (valueT) cur_proc_ptr->frame_reg, 4);
    md_number_to_chars (fragp + 24, (valueT) cur_proc_ptr->pc_reg, 4);

    subseg_set (saved_seg, saved_subseg);
  }
#endif /* MIPS_STABS_ELF */
d13577 4
d13596 11
a13606 1
#ifdef MIPS_STABS_ELF
d13608 1
a13608 1
  long val;
d13610 9
a13618 6
  if (cur_proc_ptr == (procS *) NULL)
    {
      as_warn (_(".frame outside of .ent"));
      demand_empty_rest_of_line ();
      return;
    }
d13620 2
a13621 1
  cur_proc_ptr->frame_reg = tc_get_register (1);
a13622 6
  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ','
      || get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn (_("Bad .frame directive"));
      --input_line_pointer;
a13623 1
      return;
d13625 3
a13627 8

  cur_proc_ptr->frame_offset = val;
  cur_proc_ptr->pc_reg = tc_get_register (0);

  demand_empty_rest_of_line ();
#else
  s_ignore (ignore);
#endif /* MIPS_STABS_ELF */
d13640 4
a13643 2
#ifdef MIPS_STABS_ELF
  long mask, off;
d13645 14
a13658 6
  if (cur_proc_ptr == (procS *) NULL)
    {
      as_warn (_(".mask/.fmask outside of .ent"));
      demand_empty_rest_of_line ();
      return;
    }
d13660 1
a13660 7
  if (get_absolute_expression_and_terminator (&mask) != ',')
    {
      as_warn (_("Bad .mask/.fmask directive"));
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
d13662 10
a13671 1
  off = get_absolute_expression ();
d13673 1
a13673 4
  if (reg_type == 'F')
    {
      cur_proc_ptr->fpreg_mask = mask;
      cur_proc_ptr->fpreg_offset = off;
d13676 2
a13677 9
    {
      cur_proc_ptr->reg_mask = mask;
      cur_proc_ptr->reg_offset = off;
    }

  demand_empty_rest_of_line ();
#else
  s_ignore (reg_type);
#endif /* MIPS_STABS_ELF */
@


1.142
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d10895 1
d10899 3
a10901 1
	  if (value != 0 && ! fixP->fx_pcrel)
a10918 1
		      reloc_howto_type *howto;
a10919 3

		      howto = bfd_reloc_type_lookup (stdoutput,
						     fixP->fx_r_type);
@


1.141
log
@2002-06-08  Daniel Jacobowitz  <drow@@mvista.com>

        Based on patch from Matt Green:
        * config/obj-elf.h (ECOFF_DEBUGGING): Make configurable.
        * config/tc-mips.c (s_mips_file): Renamed from s_file.
        (s_mips_loc): New function.
        (mips_nonecoff_pseudo_table): Call them.
        (append_insn): Call dwarf2_emit_insn.
@
text
@d3048 2
a3049 2
  CONST char *name = "lui";
  CONST char *fmt = "t,u";
d9835 1
a9835 1
CONST char *md_shortopts = "nO::g::G:";
@


1.140
log
@	* config/tc-mips.c (mips_opts): Fix comment, all ASE fields are set
	to -1.
	(file_ase_mips16): New veriable.
	(mips_eabi64): Remove.
	(CPU_HAS_MIPS16): New define.
	(CPU_HAS_MDMX): Fix data type.
	(md_begin): Code cleanup. Use file_ase_mips16.
	(mips_elf_final_processing): Handle mips16 header flag.
	Handle EABI flag without intermediate variable.
@
text
@d40 1
d770 2
a771 1
static void s_file PARAMS ((int));
d904 1
a904 1
  {"file", s_file, 0},
d907 1
a907 1
  {"loc", s_ignore, 0},
d2023 6
a2028 1
    md_number_to_chars (f, ip->insn_opcode, 4);
d2033 3
d2045 3
d13362 17
a13378 1
   is an initial number which is the ECOFF file index.  */
d13381 1
a13381 1
s_file (x)
d13384 2
a13385 2
  get_number ();
  s_app_file (0);
@


1.139
log
@	* config/tc-mips.c: Add define for $zero register.
	(md_begin): Add $zero as alias name for $0.
	(insn_uses_reg): Use ZERO define.
	(mips_ip): Add $zero as alias name for $0.
	(mips16_ip): Likewise.
	(s_cplocal): Demand empty rest of input line.
	(tc_get_register): Likewise. Add support for $kt0, kt1 register
	names. Use ZERO define. Fix input_line_pointer progress.
@
text
@d189 1
a189 1
   that we must set the isa field to ISA_UNKNOWN and the mips16 field to
d206 4
a227 3
/* Whether we should mark the file EABI64 or EABI32.  */
static int mips_eabi64 = 0;

d281 4
d290 1
a290 1
#define CPU_HAS_MDMX(cpu)	(0		      \
a10426 1
  int target_cpu_had_mips16 = 0;
a10446 9
  if (strncmp (cpu, "mips16", sizeof "mips16" - 1) == 0)
    {
      target_cpu_had_mips16 = 1;
      cpu += sizeof "mips16" - 1;
    }

  if (mips_opts.mips16 < 0)
    mips_opts.mips16 = target_cpu_had_mips16;

a10608 7
  /* Set the EABI kind based on the ISA before the user gets
     to change the ISA with directives.  This isn't really
     the best, but then neither is basing the abi on the isa.  */
  if (ISA_HAS_64BIT_REGS (mips_opts.isa)
      && mips_opts.abi == EABI_ABI)
    mips_eabi64 = 1;

d10618 2
d10621 1
a10621 1
    mips_opts.ase_mips3d = CPU_HAS_MIPS3D (mips_arch);
d10623 1
a10623 1
    mips_opts.ase_mdmx = CPU_HAS_MDMX (mips_arch);
d10632 1
a11670 4
  else if (strcmp (name, "mdmx") == 0)
    mips_opts.ase_mdmx = 1;
  else if (strcmp (name, "nomdmx") == 0)
    mips_opts.ase_mdmx = 0;
d11681 4
d13200 2
d13218 3
a13220 1
      if (mips_eabi64)
@


1.138
log
@2002-06-06  Daniel Jacobowitz  <drow@@mvista.com>

        * tc-mips.c (mips_after_parse_args): Always set mips_opts.ase_mips3d
        and mips_opts.ase_mdmx if they are uninitialized.
@
text
@d85 1
d1125 2
d1310 2
a1311 2
  /* Don't report on general register 0, since it never changes.  */
  if (class == MIPS_GR_REG && reg == 0)
d8007 5
d8970 5
d11970 1
d12229 1
a12229 1
      reg = 0;
d12237 1
a12237 1
	  reg = 0;
d12243 4
a12246 1
	reg = RA;
d12248 4
a12251 1
	reg = FP;
d12253 4
a12256 1
	reg = SP;
d12258 4
a12261 1
	reg = GP;
d12263 19
a12281 1
	reg = AT;
d12285 3
a12287 1
	  reg = 0;
a12288 1
      input_line_pointer += 2;
@


1.137
log
@* config/tc-mips.c (mips_after_parse_args): New function.
(md_begin): Move processing of defaults to mips_after_parse_args.
config/tc-mips.h (md_after_parse_args): Define.
@
text
@d10617 4
a10620 4
  if (mips_opts.ase_mips3d == -1 && CPU_HAS_MIPS3D (mips_arch))
    mips_opts.ase_mips3d = 1;
  if (mips_opts.ase_mdmx == -1 && CPU_HAS_MDMX (mips_arch))
    mips_opts.ase_mdmx = 1;
@


1.136
log
@	* config/tc-mips.c (mips_ip): Use unsigned long values for
	warning output.
@
text
@a1038 2
  const char *cpu;
  char *a = NULL;
a1039 213
  int mips_isa_from_cpu;
  int target_cpu_had_mips16 = 0;
  const struct mips_cpu_info *ci;

  /* GP relative stuff not working for PE */
  if (strncmp (TARGET_OS, "pe", 2) == 0
      && g_switch_value != 0)
    {
      if (g_switch_seen)
	as_bad (_("-G not supported in this configuration."));
      g_switch_value = 0;
    }

  cpu = TARGET_CPU;
  if (strcmp (cpu + (sizeof TARGET_CPU) - 3, "el") == 0)
    {
      a = xmalloc (sizeof TARGET_CPU);
      strcpy (a, TARGET_CPU);
      a[(sizeof TARGET_CPU) - 3] = '\0';
      cpu = a;
    }

  if (strncmp (cpu, "mips16", sizeof "mips16" - 1) == 0)
    {
      target_cpu_had_mips16 = 1;
      cpu += sizeof "mips16" - 1;
    }

  if (mips_opts.mips16 < 0)
    mips_opts.mips16 = target_cpu_had_mips16;

  /* Backward compatibility for historic -mcpu= option.  Check for
     incompatible options, warn if -mcpu is used.  */
  if (mips_cpu != CPU_UNKNOWN
      && mips_arch != CPU_UNKNOWN
      && mips_cpu != mips_arch)
    {
      as_fatal (_("The -mcpu option can't be used together with -march. "
		  "Use -mtune instead of -mcpu."));
    }

  if (mips_cpu != CPU_UNKNOWN
      && mips_tune != CPU_UNKNOWN
      && mips_cpu != mips_tune)
    {
      as_fatal (_("The -mcpu option can't be used together with -mtune. "
		  "Use -march instead of -mcpu."));
    }

#if 1
  /* For backward compatibility, let -mipsN set various defaults.  */
  /* This code should go away, to be replaced with something rather more
     draconian.  Until GCC 3.1 has been released for some reasonable
     amount of time, however, we need to support this.  */
  if (mips_opts.isa != ISA_UNKNOWN)
    {
      /* Translate -mipsN to the appropriate settings of file_mips_gp32
	 and file_mips_fp32.  Tag binaries as using the mipsN ISA.  */
      if (file_mips_gp32 < 0)
	{
	  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
	    file_mips_gp32 = 0;
	  else
	    file_mips_gp32 = 1;
	}
      if (file_mips_fp32 < 0)
	{
	  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
	    file_mips_fp32 = 0;
	  else
	    file_mips_fp32 = 1;
	}

      ci = mips_cpu_info_from_isa (mips_opts.isa);
      assert (ci != NULL);
      /* -mipsN has higher priority than -mcpu but lower than -march.  */
      if (mips_arch == CPU_UNKNOWN)
	mips_arch = ci->cpu;

      /* Default mips_abi.  */
      if (mips_opts.abi == NO_ABI)
	{
	  if (mips_opts.isa == ISA_MIPS1 || mips_opts.isa == ISA_MIPS2)
	    mips_opts.abi = O32_ABI;
	  else if (mips_opts.isa == ISA_MIPS3 || mips_opts.isa == ISA_MIPS4)
	    mips_opts.abi = O64_ABI;
	}
    }

  if (mips_arch == CPU_UNKNOWN && mips_cpu != CPU_UNKNOWN)
    {
      ci = mips_cpu_info_from_cpu (mips_cpu);
      assert (ci != NULL);
      mips_arch = ci->cpu;
      as_warn (_("The -mcpu option is deprecated.  Please use -march and "
		 "-mtune instead."));
    }

  /* Set tune from -mcpu, not from -mipsN.  */
  if (mips_tune == CPU_UNKNOWN && mips_cpu != CPU_UNKNOWN)
    {
      ci = mips_cpu_info_from_cpu (mips_cpu);
      assert (ci != NULL);
      mips_tune = ci->cpu;
    }

  /* At this point, mips_arch will either be CPU_UNKNOWN if no ARCH was
     specified on the command line, or some other value if one was.
     Similarly, mips_opts.isa will be ISA_UNKNOWN if not specified on
     the command line, or will be set otherwise if one was.  */

  if (mips_arch != CPU_UNKNOWN && mips_opts.isa != ISA_UNKNOWN)
    /* Handled above.  */;
#else
  if (mips_arch == CPU_UNKNOWN && mips_cpu != CPU_UNKNOWN)
    {
      ci = mips_cpu_info_from_cpu (mips_cpu);
      assert (ci != NULL);
      mips_arch = ci->cpu;
      as_warn (_("The -mcpu option is deprecated.  Please use -march and "
		 "-mtune instead."));
    }

  /* At this point, mips_arch will either be CPU_UNKNOWN if no ARCH was
     specified on the command line, or some other value if one was.
     Similarly, mips_opts.isa will be ISA_UNKNOWN if not specified on
     the command line, or will be set otherwise if one was.  */

  if (mips_arch != CPU_UNKNOWN && mips_opts.isa != ISA_UNKNOWN)
    {
      /* We have to check if the isa is the default isa of arch.  Otherwise
         we'll get invalid object file headers.  */
      ci = mips_cpu_info_from_cpu (mips_arch);
      assert (ci != NULL);
      if (mips_opts.isa != ci->isa)
	{
	  /* This really should be an error instead of a warning, but old
	     compilers only have -mcpu which sets both arch and tune.  For
	     now, we discard arch and preserve tune.  */
	  as_warn (_("The -march option is incompatible to -mipsN and "
		     "therefore ignored."));
	  if (mips_tune == CPU_UNKNOWN)
	    mips_tune = mips_arch;
	  ci = mips_cpu_info_from_isa (mips_opts.isa);
	  assert (ci != NULL);
	  mips_arch = ci->cpu;
	}
    }
#endif
  else if (mips_arch != CPU_UNKNOWN && mips_opts.isa == ISA_UNKNOWN)
    {
      /* We have ARCH, we need ISA.  */
      ci = mips_cpu_info_from_cpu (mips_arch);
      assert (ci != NULL);
      mips_opts.isa = ci->isa;
    }
  else if (mips_arch == CPU_UNKNOWN && mips_opts.isa != ISA_UNKNOWN)
    {
      /* We have ISA, we need default ARCH.  */
      ci = mips_cpu_info_from_isa (mips_opts.isa);
      assert (ci != NULL);
      mips_arch = ci->cpu;
    }
  else
    {
      /* We need to set both ISA and ARCH from target cpu.  */
      ci = mips_cpu_info_from_name (cpu);
      if (ci == NULL)
	ci = mips_cpu_info_from_cpu (CPU_R3000);
      assert (ci != NULL);
      mips_opts.isa = ci->isa;
      mips_arch = ci->cpu;
    }

  if (mips_tune == CPU_UNKNOWN)
    mips_tune = mips_arch;

  ci = mips_cpu_info_from_cpu (mips_arch);
  assert (ci != NULL);
  mips_isa_from_cpu = ci->isa;

  /* End of TARGET_CPU processing, get rid of malloced memory
     if necessary.  */
  cpu = NULL;
  if (a != NULL)
    {
      free (a);
      a = NULL;
    }

  if (mips_opts.isa == ISA_MIPS1 && mips_trap)
    as_bad (_("trap exception not supported at ISA 1"));

  /* Set the EABI kind based on the ISA before the user gets
     to change the ISA with directives.  This isn't really
     the best, but then neither is basing the abi on the isa.  */
  if (ISA_HAS_64BIT_REGS (mips_opts.isa)
      && mips_opts.abi == EABI_ABI)
    mips_eabi64 = 1;

  /* If they asked for mips1 or mips2 and a cpu that is
     mips3 or greater, then mark the object file 32BITMODE.  */
  if (mips_isa_from_cpu != ISA_UNKNOWN
      && ! ISA_HAS_64BIT_REGS (mips_opts.isa)
      && ISA_HAS_64BIT_REGS (mips_isa_from_cpu))
    mips_32bitmode = 1;

  /* If the selected architecture includes support for ASEs, enable
     generation of code for them.  */
  if (mips_opts.ase_mips3d == -1 && CPU_HAS_MIPS3D (mips_arch))
    mips_opts.ase_mips3d = 1;
  if (mips_opts.ase_mdmx == -1 && CPU_HAS_MDMX (mips_arch))
    mips_opts.ase_mdmx = 1;
a1043 15
  if (file_mips_gp32 < 0)
    file_mips_gp32 = 0;
  if (file_mips_fp32 < 0)
    file_mips_fp32 = 0;

  file_mips_isa = mips_opts.isa;
  file_mips_abi = mips_opts.abi;
  file_ase_mips3d = mips_opts.ase_mips3d;
  file_ase_mdmx = mips_opts.ase_mdmx;
  mips_opts.gp32 = file_mips_gp32;
  mips_opts.fp32 = file_mips_fp32;

  if (HAVE_NEWABI)
    mips_big_got = 1;

d10401 235
@


1.135
log
@	* config/tc-mips.c (s_cpsetup): Fix initialization of
	mips_cpreturn_register and mips_cpreturn_offset.
@
text
@d8048 2
a8049 2
		  as_warn (_("Improper shift amount (%ld)"),
			   (long) imm_expr.X_add_number);
d8090 1
a8090 1
	      if ((unsigned) imm_expr.X_add_number > 1023)
d8092 2
a8093 2
		  as_warn (_("Illegal break code (%ld)"),
			   (long) imm_expr.X_add_number);
d8104 1
a8104 1
	      if ((unsigned) imm_expr.X_add_number > 1023)
d8106 2
a8107 2
		  as_warn (_("Illegal lower break code (%ld)"),
			   (long) imm_expr.X_add_number);
d8118 3
a8120 3
	      if ((unsigned) imm_expr.X_add_number > OP_MASK_CODE20)
		as_warn (_("Illegal 20-bit code (%ld)"),
			 (long) imm_expr.X_add_number);
d8131 2
a8132 2
		  as_warn (_("Coproccesor code > 25 bits (%ld)"),
			   (long) imm_expr.X_add_number);
d8143 3
a8145 3
	      if ((unsigned) imm_expr.X_add_number > OP_MASK_CODE19)
		as_warn (_("Illegal 19-bit code (%ld)"),
			 (long) imm_expr.X_add_number);
d8156 2
a8157 2
		  as_warn (_("Invalid performance register (%ld)"),
			   (long) imm_expr.X_add_number);
@


1.134
log
@	* config/tc-mips.c (s_cpsetup): Fix comment.
@
text
@d11879 1
a11879 1
    input_line_pointer++;
d11882 4
a11885 1
    mips_cpreturn_register = tc_get_register (0);
d11887 4
a11890 1
    mips_cpreturn_offset = get_absolute_expression ();
@


1.133
log
@	* config/tc-mips.c (md_begin): Add $ra as alias name for $31.
	(mips_ip): Likewise.
	(mips16_ip): Likewise.
	(tc_get_register): Likewise.
@
text
@d11844 2
a11845 2
     daddiu	$gp, $gp, %lo(%neg(%gp_rel(label)))
     addu	$gp, $gp, $reg1
d11850 3
a11852 3
     daddiu	$gp, $gp, %lo(%neg(%gp_rel(label)))
     addu	$gp, $gp, $reg1
 */
@


1.132
log
@[ gas/ChangeLog ]
2002-05-30  Chris G. Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* config/tc-mips.c (mips_set_options): New "ase_mdmx" member.
	(mips_opts): Initialize "ase_mdmx" member.
	(file_ase_mdmx): New variable.
	(CPU_HAS_MDMX): New macro.
	(md_begin): Initialize mips_opts.ase_mdmx and file_ase_mdmx
	based on command line options and configuration defaults.
	(macro_build): Note in comment that use of MDMX in macros is
	not currently allowed.
	(validate_mips_insn): Add support for the "O", "Q", "X", "Y", and
	"Z" MDMX operand types.
	(mips_ip): Accept MDMX instructions if mips_opts.ase_mdmx is set,
	and add support for the "O", "Q", "X", "Y", and "Z" MDMX operand
	types.
	(OPTION_MDMX, OPTION_NO_MDMX, md_longopts, md_parse_option):
	Add support for "-mdmx" and "-no-mdmx" options.
	(OPTION_ELF_BASE): Move to accomodate new options.
	(s_mipsset): Support ".set mdmx" and ".set nomdmx".
	(mips_elf_final_processing): Set MDMX ASE ELF header flag if
	file_ase_mdmx was set.
	* doc/as.texinfo: Document -mdmx and -no-mdmx options.
	* doc/c-mips.texi: Likewise, and document ".set mdmx" and ".set
	nomdmx" directives.

[ gas/testsuite/ChangeLog ]
2002-05-30  Chris G. Demetriou  <cgd@@broadcom.com>

	* gas/mips/mips64-mdmx.s: New file.
	* gas/mips/mips64-mdmx.d: Likewise.
	* gas/mips/mips.exp: Run new "mips64-mdmx" test.

[ include/opcode/ChangeLog ]
2002-05-30  Chris G. Demetriou  <cgd@@broadcom.com>

	* mips.h (OP_SH_ALN, OP_MASK_ALN, OP_SH_VSEL, OP_MASK_VSEL)
	(MDMX_FMTSEL_IMM_QH, MDMX_FMTSEL_IMM_OB, MDMX_FMTSEL_VEC_QH)
	(MDMX_FMTSEL_VEC_OB, INSN_READ_MDMX_ACC, INSN_WRITE_MDMX_ACC)
	(INSN_MDMX): New constants, for MDMX support.
	(opcode character list): Add "O", "Q", "X", "Y", and "Z" for MDMX.

[ opcodes/ChangeLog ]
2002-05-30  Chris G. Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* mips-dis.c (print_insn_arg): Add support for 'O', 'Q', 'X', 'Y',
	and 'Z' formats, for MDMX.
        (mips_isa_type): Add MDMX instructions to the ISA
	bit mask for bfd_mach_mipsisa64.
	* mips-opc.c: Add support for MDMX instructions.
	(MX): New definition.

	* mips-dis.c: Update copyright years to include 2002.
@
text
@d1340 2
d8199 6
a8204 1
		      if (s[1] == 'f' && s[2] == 'p')
d9157 6
a9162 1
		  if (s[1] == 'f' && s[2] == 'p')
d12217 3
a12219 1
      if (strncmp (input_line_pointer, "fp", 2) == 0)
@


1.131
log
@	* config/tc-mips.c (OPTION_NO_M7000_HILO_FIX): Rename to
	OPTION_MNO_7000_HILO_FIX. Add alternate "mno-fix7000"
	command line switch conforming to gcc conventions.
	* doc/c-mips.texi: Document -mno-fix7000 instead of no-mfix-7000.
@
text
@d144 1
d193 1
a193 1
  ISA_UNKNOWN, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, NO_ABI
d209 4
d283 4
d1253 2
d1267 1
d2932 2
a2933 2
      /* It is assumed here that macros will never generate
         MIPS-3D instructions.  */
d7810 3
d7818 3
d7939 1
d7983 2
d7986 1
d8335 41
d8383 5
a8387 2
	      if (s[0] == '$' && s[1] == 'f'
		  && ISDIGIT (s[2]))
d8428 1
d8433 1
d8436 34
d8472 1
d10098 4
d10103 1
a10103 1
#define OPTION_ELF_BASE    (OPTION_MD_BASE + 35)
d10308 8
d11650 4
d13143 2
@


1.130
log
@	* config/tc-mips.c (macro_build_jalr): New Function.
	(md_begin): NewABI uses big GOTs.
	(macro_build): Recognize BFD_RELOC_MIPS_GOT_DISP,
	BFD_RELOC_MIPS_GOT_PAGE, BFD_RELOC_MIPS_GOT_OFST as valid.
	(load_address): Add some NewABI PIC support.
	(macro): Likewise.
	(md_apply_fix): Special handling for BFD_RELOC_MIPS_JALR.
	(tc_gen_reloc): Don't encode NewABI vtables in REL relocations.
@
text
@d9956 3
a9958 2
#define OPTION_NO_M7000_HILO_FIX (OPTION_MD_BASE + 16)
  {"no-fix-7000", no_argument, NULL, OPTION_NO_M7000_HILO_FIX},
d10366 1
a10366 1
    case OPTION_NO_M7000_HILO_FIX:
@


1.129
log
@	* config/tc-mips.c (load_address): Use mips_gp_register instead
	of hardcoded value. Remove dbl parameter, use HAVE_32BIT_ADDRESSES
	instead.
	(macro): Use mips_gp_register instead of hardcoded value.
@
text
@d700 1
d1259 3
d3021 3
d3213 17
d3842 3
d3848 9
a3856 2
      if (reg_needs_delay (mips_gp_register))
	off = 4;
d3858 31
a3888 20
	off = 0;
      frag_grow (32);
      macro_build ((char *) NULL, counter, ep, "lui", "t,u", reg,
		   (int) BFD_RELOC_MIPS_GOT_HI16);
      macro_build ((char *) NULL, counter, (expressionS *) NULL,
		   HAVE_32BIT_ADDRESSES ? "addu" : "daddu", "d,v,t", reg,
		   reg, mips_gp_register);
      macro_build ((char *) NULL, counter, ep,
		   HAVE_32BIT_ADDRESSES ? "lw" : "ld", "t,o(b)", reg,
		   (int) BFD_RELOC_MIPS_GOT_LO16, reg);
      p = frag_var (rs_machine_dependent, 12 + off, 0,
		    RELAX_ENCODE (12, 12 + off, off, 8 + off, 0,
				  mips_opts.warn_about_macros),
		    ep->X_add_symbol, 0, NULL);
      if (off > 0)
	{
	  /* We need a nop before loading from $gp.  This special
             check is required because the lui which starts the main
             instruction stream does not refer to $gp, and so will not
             insert the nop which may be required.  */
d3891 3
d3895 1
a3895 8
      macro_build (p, counter, ep, HAVE_32BIT_ADDRESSES ? "lw" : "ld",
		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16,
		   mips_gp_register);
      p += 4;
      macro_build (p, counter, (expressionS *) NULL, "nop", "");
      p += 4;
      macro_build (p, counter, ep, HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d4984 26
a5009 1
	     */
d5298 6
a5303 3
	       lw $gp,cprestore($sp) */
	  frag_grow (40);
	  if (! mips_big_got)
d5308 2
a5309 6
			   (int) BFD_RELOC_MIPS_CALL16, mips_gp_register);
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   "nop", "");
	      p = frag_var (rs_machine_dependent, 4, 0,
			    RELAX_ENCODE (0, 4, -8, 0, 0, 0),
			    offset_expr.X_add_symbol, 0, NULL);
d5313 13
a5325 4
	      int gpdel;

	      if (reg_needs_delay (mips_gp_register))
		gpdel = 4;
a5326 18
		gpdel = 0;
	      macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
			   PIC_CALL_REG, (int) BFD_RELOC_MIPS_CALL_HI16);
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
			   "d,v,t", PIC_CALL_REG, PIC_CALL_REG,
			   mips_gp_register);
	      macro_build ((char *) NULL, &icnt, &offset_expr,
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", PIC_CALL_REG,
			   (int) BFD_RELOC_MIPS_CALL_LO16, PIC_CALL_REG);
	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			   "nop", "");
	      p = frag_var (rs_machine_dependent, 12 + gpdel, 0,
			    RELAX_ENCODE (16, 12 + gpdel, gpdel, 8 + gpdel,
					  0, 0),
			    offset_expr.X_add_symbol, 0, NULL);
	      if (gpdel > 0)
d5328 33
d5365 5
a5369 15
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", PIC_CALL_REG,
			   (int) BFD_RELOC_MIPS_GOT16, mips_gp_register);
	      p += 4;
	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
	      p += 4;
	    }
	  macro_build (p, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		       "t,r,j", PIC_CALL_REG, PIC_CALL_REG,
		       (int) BFD_RELOC_LO16);
	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		       "jalr", "s", PIC_CALL_REG);
	  if (! HAVE_NEWABI)
	    {
d5864 7
a5870 1
	     in which we are not using $at).  */
d5877 22
d10733 2
a10734 1
	  || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY);
d12691 3
a12693 3
  /* Since MIPS ELF uses Rel instead of Rela, encode the vtable entry
     to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
@


1.128
log
@	* config/tc-mips.c (mips_gprel_offset): New variable.
	(s_gpvalue): Use it.
@
text
@d3821 1
a3821 1
      if (reg_needs_delay (GP))
d3829 5
a3833 3
		   dbl ? "daddu" : "addu", "d,v,t", reg, reg, GP);
      macro_build ((char *) NULL, counter, ep, dbl ? "ld" : "lw",
		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT_LO16, reg);
d3847 3
a3849 2
      macro_build (p, counter, ep, dbl ? "ld" : "lw",
		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16, GP);
d3853 1
a3853 1
      macro_build (p, counter, ep, dbl ? "daddiu" : "addiu",
d3860 2
a3861 1
	  macro_build ((char *) NULL, counter, &ex, dbl ? "daddiu" : "addiu",
d4947 1
a4947 1
	  if (reg_needs_delay (GP))
d5239 1
a5239 1
			   (int) BFD_RELOC_MIPS_CALL16, GP);
d5250 1
a5250 1
	      if (reg_needs_delay (GP))
d5258 2
a5259 1
			   "d,v,t", PIC_CALL_REG, PIC_CALL_REG, GP);
d5278 1
a5278 1
			   (int) BFD_RELOC_MIPS_GOT16, GP);
d5792 1
a5792 1
	  if (reg_needs_delay (GP))
@


1.127
log
@	* config/tc-mips.c: Replace GP in comments by $gp.
	(mips_big_got): Initialize.
	(mips_trap): Initialize.
	(load_address): Use mips_gp_register instead of hardcoded value.
	Remove dbl parameter, use HAVE_32BIT_ADDRESSES instead.
	(macro): Use mips_gp_register instead of hardcoded value.
	(macro2): Change load_address calls.
	(md_pcrel_from): Comment formatting.
	(s_cpload): Use mips_gp_register instead of hardcoded value.
	(s_cprestore): Likewise. Comment formatting.
	(s_gpword): Fix data type.
	(s_cpadd): Use mips_gp_register instead of hardcoded value.
	(nopic_need_relax): Replace GP in comments by $gp.
	(mips_elf_final_processing): Better comment.
@
text
@d426 1
d11790 1
a11790 1
  mips_cpreturn_offset = get_absolute_expression ();
@


1.126
log
@	* config/tc-mips.c (mips_emit_delays): Replace magic constant for RA
	by the define. Remove superfluous check of mips_opts.mips16.
	(append_insn): Likewise. Canonicalize variable increments.
	(macro_build): Canonicalize variable increments.
	(macro_build_lui): Likewise.
	(load_register): Likewise.
	(load_address): Move pointer initialization.
	(macro): Move pointer to a more local scope. Canonicalize variable
	increments. Better comments. Replace magic constant for RA by the
	define.
	(macro2): Replace magic constant for RA by the define. Canonicalize
	variable increments.
	(mips_ip): Canonicalize variable increments.
	(mips16_ip): Replace magic constant for RA by the define.
	(my_getSmallParser): Canonicalize variable increments/decrements.
	(my_getPercentOp): Likewise.
	(my_getSmallExpression): Likewise.
	(s_align): Likewise.
	(s_mipsset): Likewise.
	(s_cpsetup): Likewise.
	(s_insn): Remove superfluous check of mips_opts.mips16.
	(s_mips_stab): Likewise.
	(mips_handle_align): Canonicalize variable increments.
	(s_mips_ent): Likewise.
	(s_mips_end): Add comment.
@
text
@d329 1
a329 1
/* 1 if we should generate 32 bit offsets from the GP register in
d331 1
a331 1
static int mips_big_got;
d335 1
a335 1
static int mips_trap;
d705 1
a705 1
static void load_address PARAMS ((int *, int, expressionS *, int, int *));
d3663 1
a3663 1
load_address (counter, reg, ep, dbl, used_at)
a3666 1
     int dbl;
d3680 1
a3680 1
      load_register (counter, reg, ep, dbl);
d3710 1
a3710 1
      if (dbl)
d3754 2
a3755 2
			   dbl ? "daddiu" : "addiu", "t,r,j", reg, GP,
			   (int) BFD_RELOC_GPREL16);
d3764 2
a3765 1
	  macro_build (p, counter, ep, dbl ? "daddiu" : "addiu",
d3784 2
a3785 2
		   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16, GP);
d3864 4
a3867 3
	 */
      macro_build ((char *) NULL, counter, ep, dbl ? "daddiu" : "addiu",
		   "t,r,j", reg, GP, (int) BFD_RELOC_GPREL16);
d4748 2
a4749 1
			       "t,r,j", tempreg, GP, (int) BFD_RELOC_GPREL16);
d4801 1
a4801 1
		       "t,o(b)", tempreg, lw_reloc_type, GP);
d4955 1
a4955 1
		       "d,v,t", tempreg, tempreg, GP);
d5061 2
a5062 1
		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GP);
d5115 2
a5116 2
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		       "t,r,j", tempreg, GP, (int) BFD_RELOC_GPREL16);
d5188 2
a5189 1
			       GP, (int) BFD_RELOC_LO16, mips_frame_reg);
d5307 2
a5308 1
			       GP, (int) BFD_RELOC_LO16, mips_frame_reg);
d5671 2
a5672 1
			       treg, (int) BFD_RELOC_GPREL16, GP);
d5697 1
a5697 1
			       "d,v,t", tempreg, breg, GP);
d5743 2
a5744 2
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GP);
d5795 1
a5795 1
		       "d,v,t", tempreg, tempreg, GP);
d5810 2
a5811 1
		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GP);
d5837 1
a5837 1
			   treg, (int) BFD_RELOC_GPREL16, GP);
d5844 1
a5844 1
			   "d,v,t", tempreg, breg, GP);
d5882 1
a5882 1
		       treg, (int) BFD_RELOC_MIPS_LITERAL, GP);
d5936 2
a5937 1
		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GP);
d5944 2
a5945 2
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		       "t,r,j", AT, GP, (int) BFD_RELOC_GPREL16);
d6018 2
a6019 1
			   "T,o(b)", treg, (int) BFD_RELOC_MIPS_LITERAL, GP);
d6022 1
a6022 1
	  breg = GP;
d6032 2
a6033 1
			 "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GP);
d6208 1
a6208 1
		  tempreg = GP;
d6217 1
a6217 1
			       "d,v,t", AT, breg, GP);
d6318 2
a6319 2
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GP);
d6371 1
a6371 1
	  if (reg_needs_delay (GP))
d6384 1
a6384 1
		       "d,v,t", AT, AT, GP);
d6421 2
a6422 1
		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GP);
d6462 1
a6462 1
	      tempreg = GP;
d6469 1
a6469 1
			   "d,v,t", AT, breg, GP);
d7239 1
a7239 1
      load_address (&icnt, AT, &offset_expr, HAVE_64BIT_ADDRESSES, &used_at);
d7261 1
a7261 1
      load_address (&icnt, AT, &offset_expr, HAVE_64BIT_ADDRESSES, &used_at);
d7335 1
a7335 1
      load_address (&icnt, AT, &offset_expr, HAVE_64BIT_ADDRESSES, &used_at);
d7356 1
a7356 1
      load_address (&icnt, AT, &offset_expr, HAVE_64BIT_ADDRESSES, &used_at);
d10416 1
a10416 1
  /* return the address of the delay slot */
d11582 3
a11584 3
  macro_build_lui (NULL, &icnt, &ex, GP);
  macro_build ((char *) NULL, &icnt, &ex, "addiu", "t,r,j", GP, GP,
	       (int) BFD_RELOC_LO16);
d11587 1
a11587 1
	       GP, GP, tc_get_register (0));
d11714 1
a11714 1
   .cprestore is ignored.  */
d11729 2
a11730 3
  macro_build ((char *) NULL, &icnt, &ex,
	       HAVE_32BIT_ADDRESSES ? "sw" : "sd",
	       "t,o(b)", GP, (int) BFD_RELOC_LO16, SP);
d11828 1
a11828 1
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, 0,
d11856 1
a11856 1
	       "d,v,t", reg, reg, GP);
d12034 1
a12034 1
      /* Find out whether this symbol can be referenced off the GP
d12037 1
a12037 1
	 not be referenced off the GP, although it appears as though
d12084 1
a12084 1
    /* We are not optimizing for the GP register.  */
d12927 1
a12927 1
  /* Nothing to do for "64".  */
@


1.125
log
@	* config/tc-mips.c (macro): Relax warning, it's toot strict for
	embedded-PIC.
@
text
@d1659 1
a1659 2
  if (mips_opts.mips16)
    mips16_mark_labels ();
d1817 1
a1817 1
	  nops += 1;
d1843 1
a1843 1
	    nops += 1;
d1865 1
a1865 1
	    nops += 1;
d1952 1
a1952 1
		val += 1;
d2250 1
a2250 1
	mips_gprmask |= 1 << 31;
d2443 1
a2443 1
			      == 31))))
d2452 1
a2452 1
			      == 31))))
d2470 1
a2470 1
		  && insn_uses_reg (&prev_insn, 31, MIPS_GR_REG))
d2828 1
a2828 1
		val += 1;
d2835 1
a2835 1
  if (mips_opts.mips16 && insns)
d2896 1
a2896 1
    *counter += 1;		/* bump instruction counter */
d3256 1
a3256 1
    *counter += 1;		/* bump instruction counter */
d3550 1
a3550 1
	  shift++;
d3670 1
a3670 1
  char *p;
a3712 2
	  p = NULL;

a3749 1
	  p = NULL;
a3923 1
  char *p;
d4117 1
a4117 1
      imm_expr.X_add_number++;
d4186 1
a4186 1
      imm_expr.X_add_number++;
d4281 1
a4281 1
      imm_expr.X_add_number++;
d4331 1
a4331 1
      imm_expr.X_add_number++;
d4702 1
a4702 1
	  p = NULL;
d4803 1
d4893 1
d5199 2
d5205 1
a5205 1
	       jalr	$25
d5214 1
a5214 1
	       jalr	$25
d5221 1
a5221 1
	       jalr	$25
d5545 2
d5712 2
d5756 1
d5952 1
a5952 1
	  if (treg != 31)
d6169 2
d6338 1
d6639 1
a6639 1
		   dbl ? "dsra32" : "sra", "d,w,<", dreg, dreg, 31);
d7147 1
a7147 1
		   treg, 31);
d7149 1
a7149 1
		   treg, 31);
d7158 1
a7158 1
		   AT, 31);
d7163 1
a7163 1
		   treg, 31);
d7178 1
a7178 1
	offset_expr.X_add_number += 1;
d7182 1
a7182 1
	offset_expr.X_add_number -= 1;
d7184 1
a7184 1
	offset_expr.X_add_number += 1;
d7276 1
a7276 1
	offset_expr.X_add_number += 1;
d7282 1
a7282 1
	offset_expr.X_add_number -= 1;
d7284 1
a7284 1
	offset_expr.X_add_number += 1;
d8115 1
a8115 1
		    s++;
d8122 1
a8122 1
			  args++;
d8225 1
a8225 1
		    s++;
d8232 1
a8232 1
			  args++;
d8965 1
a8965 1
		      args++;
d9233 1
a9233 1
		    else if (reg1 == 31 && reg2 == 31)
d9542 1
a9542 1
	      pcnt++;
d9544 1
a9544 1
	      pcnt--;
d9583 1
a9583 1
	  (*nestlevel)++;
d9640 1
a9640 1
		pcnt++;
d9642 1
a9642 1
		pcnt--;
d11087 1
a11087 1
      input_line_pointer++;
d11352 1
a11352 1
    input_line_pointer++;
d11635 1
a11635 1
    input_line_pointer++;
d11639 1
a11639 1
    input_line_pointer++;
d11864 1
a11864 2
  if (mips_opts.mips16)
    mips16_mark_labels ();
d11879 1
a11879 1
  if (type == 'n' && mips_opts.mips16)
d12963 1
a12963 1
	  fragp->fr_fix += 1;
d13135 1
a13135 1
#endif
d13151 1
a13151 1
    input_line_pointer++;
d13188 1
a13188 1
      numprocs++;
@


1.124
log
@? gas/testsuite/gas/mips/rol64.d
? gas/testsuite/gas/mips/rol64.s
Index: gas/ChangeLog
===================================================================
RCS file: /cvs/src/src/gas/ChangeLog,v
retrieving revision 1.1334
diff -u -p -r1.1334 ChangeLog
--- gas/ChangeLog	21 May 2002 20:01:51 -0000	1.1334
+++ gas/ChangeLog	21 May 2002 23:32:51 -0000
@@@@ -1,3 +1,8 @@@@
+2002-05-22  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
+
+	* config/tc-mips.c (macro2): Add 64 bit drol, dror macros.
+	Optimize the rotate by zero case.
+
 2002-05-21  Nick Clifton  <nickc@@cambridge.redhat.com>

 	* configure.in: Remove accidental enabling of bfd_gas=yes for
Index: gas/config/tc-mips.c
===================================================================
RCS file: /cvs/src/src/gas/config/tc-mips.c,v
retrieving revision 1.123
diff -u -p -r1.123 tc-mips.c
--- gas/config/tc-mips.c	14 May 2002 23:35:59 -0000	1.123
+++ gas/config/tc-mips.c	21 May 2002 23:32:52 -0000
@@@@ -6686,6 +6686,17 @@@@ macro2 (ip)
       --mips_opts.noreorder;
       break;

+    case M_DROL:
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsubu",
+		   "d,v,t", AT, 0, treg);
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrlv",
+		   "d,t,s", AT, sreg, AT);
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsllv",
+		   "d,t,s", dreg, sreg, treg);
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
+		   "d,v,t", dreg, dreg, AT);
+      break;
+
     case M_ROL:
       macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "subu",
 		   "d,v,t", AT, 0, treg);
@@@@ -6697,15 +6708,55 @@@@ macro2 (ip)
 		   "d,v,t", dreg, dreg, AT);
       break;

+    case M_DROL_I:
+      {
+	unsigned int rot;
+	char *l, *r;
+
+	if (imm_expr.X_op != O_constant)
+	  as_bad (_("rotate count too large"));
+	rot = imm_expr.X_add_number & 0x3f;
+	if (! rot)
+	  break;
+	l = (rot < 0x20) ? "dsll" : "dsll32";
+	r = ((0x40 - rot) < 0x20) ? "dsrl" : "dsrl32";
+	rot &= 0x1f;
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
+		     "d,w,<", AT, sreg, rot);
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
+		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
+		     "d,v,t", dreg, dreg, AT);
+      }
+      break;
+
     case M_ROL_I:
-      if (imm_expr.X_op != O_constant)
-	as_bad (_("rotate count too large"));
-      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll", "d,w,<",
-		   AT, sreg, (int) (imm_expr.X_add_number & 0x1f));
-      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl", "d,w,<",
-		   dreg, sreg, (int) ((0 - imm_expr.X_add_number) & 0x1f));
-      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or", "d,v,t",
-		   dreg, dreg, AT);
+      {
+	unsigned int rot;
+
+	if (imm_expr.X_op != O_constant)
+	  as_bad (_("rotate count too large"));
+	rot = imm_expr.X_add_number & 0x1f;
+	if (! rot)
+	  break;
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
+		     "d,w,<", AT, sreg, rot);
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
+		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
+		     "d,v,t", dreg, dreg, AT);
+      }
+      break;
+
+    case M_DROR:
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsubu",
+		   "d,v,t", AT, 0, treg);
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsllv",
+		   "d,t,s", AT, sreg, AT);
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "dsrlv",
+		   "d,t,s", dreg, sreg, treg);
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
+		   "d,v,t", dreg, dreg, AT);
       break;

     case M_ROR:
@@@@ -6719,15 +6770,44 @@@@ macro2 (ip)
 		   "d,v,t", dreg, dreg, AT);
       break;

+    case M_DROR_I:
+      {
+	unsigned int rot;
+	char *l, *r;
+
+	if (imm_expr.X_op != O_constant)
+	  as_bad (_("rotate count too large"));
+	rot = imm_expr.X_add_number & 0x3f;
+	if (! rot)
+	  break;
+	r = (rot < 0x20) ? "dsrl" : "dsrl32";
+	l = ((0x40 - rot) < 0x20) ? "dsll" : "dsll32";
+	rot &= 0x1f;
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, r,
+		     "d,w,<", AT, sreg, rot);
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, l,
+		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
+		     "d,v,t", dreg, dreg, AT);
+      }
+      break;
+
     case M_ROR_I:
-      if (imm_expr.X_op != O_constant)
-	as_bad (_("rotate count too large"));
-      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl", "d,w,<",
-		   AT, sreg, (int) (imm_expr.X_add_number & 0x1f));
-      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll", "d,w,<",
-		   dreg, sreg, (int) ((0 - imm_expr.X_add_number) & 0x1f));
-      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or", "d,v,t",
-		   dreg, dreg, AT);
+      {
+	unsigned int rot;
+
+	if (imm_expr.X_op != O_constant)
+	  as_bad (_("rotate count too large"));
+	rot = imm_expr.X_add_number & 0x1f;
+	if (! rot)
+	  break;
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl",
+		     "d,w,<", AT, sreg, rot);
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll",
+		     "d,w,<", dreg, sreg, (0x20 - rot) & 0x1f);
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or",
+		     "d,v,t", dreg, dreg, AT);
+      }
       break;

     case M_S_DOB:
Index: gas/testsuite/ChangeLog
===================================================================
RCS file: /cvs/src/src/gas/testsuite/ChangeLog,v
retrieving revision 1.315
diff -u -p -r1.315 ChangeLog
--- gas/testsuite/ChangeLog	20 May 2002 17:05:34 -0000	1.315
+++ gas/testsuite/ChangeLog	21 May 2002 23:32:54 -0000
@@@@ -1,3 +1,9 @@@@
+2002-05-22  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
+
+	* gas/mips/rol64.s: New file, test of drol, dror macros.
+	* gas/mips/rol64.d: Likewise.
+	* gas/mips/mips.exp: Add new test.
+
 2002-05-20  Nick Clifton  <nickc@@cambridge.redhat.com>

 	* gas/arm/arm.exp: Replace deprecated command line switches
Index: gas/testsuite/gas/mips/mips.exp
===================================================================
RCS file: /cvs/src/src/gas/testsuite/gas/mips/mips.exp,v
retrieving revision 1.32
diff -u -p -r1.32 mips.exp
--- gas/testsuite/gas/mips/mips.exp	4 Apr 2002 08:23:30 -0000	1.32
+++ gas/testsuite/gas/mips/mips.exp	21 May 2002 23:32:54 -0000
@@@@ -122,6 +122,7 @@@@ if { [istarget mips*-*-*] } then {
 	run_dump_test "mul"
     }
     run_dump_test "rol"
+    run_dump_test "rol64"
     if !$aout { run_dump_test "sb" }
     run_dump_test "trunc"
     if !$aout { run_dump_test "ulh" }
Index: include/opcode/ChangeLog
===================================================================
RCS file: /cvs/src/src/include/opcode/ChangeLog,v
retrieving revision 1.167
diff -u -p -r1.167 ChangeLog
--- include/opcode/ChangeLog	17 May 2002 19:01:03 -0000	1.167
+++ include/opcode/ChangeLog	21 May 2002 23:32:57 -0000
@@@@ -1,3 +1,7 @@@@
+2002-05-22  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
+
+	* mips.h: Add M_DROL, M_DROL_I, M_DROR, M_DROR_I macro cases.
+
 2002-05-17  Andrey Volkov  <avolkov@@sources.redhat.com>

         * h8300.h: Corrected defs of all control regs
Index: include/opcode/mips.h
===================================================================
RCS file: /cvs/src/src/include/opcode/mips.h,v
retrieving revision 1.24
diff -u -p -r1.24 mips.h
--- include/opcode/mips.h	16 Mar 2002 03:09:18 -0000	1.24
+++ include/opcode/mips.h	21 May 2002 23:32:57 -0000
@@@@ -526,9 +526,13 @@@@ enum
   M_REM_3I,
   M_REMU_3,
   M_REMU_3I,
+  M_DROL,
   M_ROL,
+  M_DROL_I,
   M_ROL_I,
+  M_DROR,
   M_ROR,
+  M_DROR_I,
   M_ROR_I,
   M_S_DA,
   M_S_DOB,
Index: opcodes/ChangeLog
===================================================================
RCS file: /cvs/src/src/opcodes/ChangeLog,v
retrieving revision 1.447
diff -u -p -r1.447 ChangeLog
--- opcodes/ChangeLog	17 May 2002 14:36:45 -0000	1.447
+++ opcodes/ChangeLog	21 May 2002 23:33:00 -0000
@@@@ -1,3 +1,7 @@@@
+2002-05-22  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
+
+	* mips-opc.c (mips_builtin_opcodes): Add drol, dror macros.
+
 Fri May 17 14:26:44 2002  J"orn Rennecke <joern.rennecke@@superh.com>

 	* disassemble.c (disassembler): Just use print_insn_sh for bfd_arch_sh.
Index: opcodes/mips-opc.c
===================================================================
RCS file: /cvs/src/src/opcodes/mips-opc.c,v
retrieving revision 1.32
diff -u -p -r1.32 mips-opc.c
--- opcodes/mips-opc.c	17 Mar 2002 02:42:25 -0000	1.32
+++ opcodes/mips-opc.c	21 May 2002 23:33:00 -0000
@@@@ -492,6 +492,10 @@@@ const struct mips_opcode mips_builtin_op
 {"dremu",   "z,s,t",    0x0000001f, 0xfc00ffff, RD_s|RD_t|WR_HILO,      I3      },
 {"dremu",   "d,v,t",	3,    (int) M_DREMU_3,	INSN_MACRO,		I3	},
 {"dremu",   "d,v,I",	3,    (int) M_DREMU_3I,	INSN_MACRO,		I3	},
+{"drol",    "d,v,t",	0,    (int) M_DROL,	INSN_MACRO,		I3	},
+{"drol",    "d,v,I",	0,    (int) M_DROL_I,	INSN_MACRO,		I3	},
+{"dror",    "d,v,t",	0,    (int) M_DROR,	INSN_MACRO,		I3	},
+{"dror",    "d,v,I",	0,    (int) M_DROR_I,	INSN_MACRO,		I3	},
 {"dsllv",   "d,t,s",	0x00000014, 0xfc0007ff,	WR_d|RD_t|RD_s,		I3	},
 {"dsll32",  "d,w,<",	0x0000003c, 0xffe0003f, WR_d|RD_t,		I3	},
 {"dsll",    "d,w,s",	0x00000014, 0xfc0007ff,	WR_d|RD_t|RD_s,		I3	}, /* dsllv */
@
text
@d4610 1
a4610 1
      if (! dbl && HAVE_64BIT_ADDRESSES)
@


1.123
log
@	* config/tc-mips.c (macro): Warn about wrong la/dla use.
@
text
@d6689 11
d6711 22
d6734 26
a6759 8
      if (imm_expr.X_op != O_constant)
	as_bad (_("rotate count too large"));
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll", "d,w,<",
		   AT, sreg, (int) (imm_expr.X_add_number & 0x1f));
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl", "d,w,<",
		   dreg, sreg, (int) ((0 - imm_expr.X_add_number) & 0x1f));
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or", "d,v,t",
		   dreg, dreg, AT);
d6773 22
d6796 15
a6810 8
      if (imm_expr.X_op != O_constant)
	as_bad (_("rotate count too large"));
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "srl", "d,w,<",
		   AT, sreg, (int) (imm_expr.X_add_number & 0x1f));
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "sll", "d,w,<",
		   dreg, sreg, (int) ((0 - imm_expr.X_add_number) & 0x1f));
      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "or", "d,v,t",
		   dreg, dreg, AT);
@


1.122
log
@	* config/tc_mips.c (s_cpsetup): Fix completely bogus code which had
	worked sometimes by accident. Fix copy&paste comment.
@
text
@d4607 6
@


1.121
log
@	* config/tc-mips.c (md_begin): Fix .reginfo and .MIPS.option section
	alignment for NewABI. Let n32 use .reginfo. Remove useless casts.
	(mips_elf_final_processing): Let n32 use .reginfo.
@
text
@d11513 1
a11513 1
  /* If we are not generating SVR4 PIC code, .cpload is ignored.
d11570 2
a11571 4
  fix_new (frag_now, (char *) prev_insn_fixp - 4 - frag_now->fr_literal, 0,
	   NULL, 0, 0, BFD_RELOC_MIPS_SUB);
  fix_new (frag_now, (char *) prev_insn_fixp - 4 - frag_now->fr_literal, 0,
	   NULL, 0, 0, BFD_RELOC_HI16_S);
d11574 5
a11578 6
  fix_new (frag_now, (char *) prev_insn_fixp - 4 - frag_now->fr_literal, 0,
	   NULL, 0, 0, BFD_RELOC_MIPS_SUB);
  fix_new (frag_now, (char *) prev_insn_fixp - 4 - frag_now->fr_literal, 0,
	   NULL, 0, 0, BFD_RELOC_LO16);
  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "daddu",
	       "d,v,t", mips_gp_register, mips_gp_register, reg1);
@


1.120
log
@	* config/tc-mips.c (append_insn): Fix too small range of variable.
@
text
@d1382 1
a1382 1
	if (! HAVE_NEWABI)
d1386 2
a1387 2
	    (void) bfd_set_section_flags (stdoutput, sec, flags);
	    (void) bfd_set_section_alignment (stdoutput, sec, 2);
d1398 2
a1399 2
	    (void) bfd_set_section_flags (stdoutput, sec, flags);
	    (void) bfd_set_section_alignment (stdoutput, sec, 3);
d12766 1
a12766 1
  if (! HAVE_NEWABI)
@


1.119
log
@	* config/tc-mips.c: Fix formatting.
	* config/tc-s390.c: Likewise.
	* config/tc-s390.h: Likewise.
@
text
@d2040 1
a2040 1
	  unsigned long tmp;
@


1.118
log
@2002-04-24  Chris G. Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (macro_build): Do _not_ allow MIPS-3D
        instructions to be generated by macros.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d2124 15
a2138 15
		  || *reloc_type == BFD_RELOC_32
		  || *reloc_type == BFD_RELOC_MIPS_JMP
		  || *reloc_type == BFD_RELOC_HI16_S
		  || *reloc_type == BFD_RELOC_LO16
		  || *reloc_type == BFD_RELOC_GPREL16
		  || *reloc_type == BFD_RELOC_MIPS_LITERAL
		  || *reloc_type == BFD_RELOC_GPREL32
		  || *reloc_type == BFD_RELOC_64
		  || *reloc_type == BFD_RELOC_CTOR
		  || *reloc_type == BFD_RELOC_MIPS_SUB
		  || *reloc_type == BFD_RELOC_MIPS_HIGHEST
		  || *reloc_type == BFD_RELOC_MIPS_HIGHER
		  || *reloc_type == BFD_RELOC_MIPS_SCN_DISP
		  || *reloc_type == BFD_RELOC_MIPS_REL16
		  || *reloc_type == BFD_RELOC_MIPS_RELGOT))
d2185 1
a2185 1
		     fixp[1]->fx_no_overflow = 1;
d2217 1
a2217 1
		       fixp[2]->fx_no_overflow = 1;
d2916 1
a2916 1
      /* It is assumed here that macros will never generate 
d4707 51
a4757 51
	    if (used_at == 0)
	      {
		macro_build (p, &icnt, &offset_expr, "lui", "t,u",
			     tempreg, (int) BFD_RELOC_MIPS_HIGHEST);
		macro_build (p, &icnt, &offset_expr, "lui", "t,u",
			     AT, (int) BFD_RELOC_HI16_S);
		macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
			     tempreg, tempreg, (int) BFD_RELOC_MIPS_HIGHER);
		macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
			     AT, AT, (int) BFD_RELOC_LO16);
		macro_build (p, &icnt, (expressionS *) NULL, "dsll32",
			     "d,w,<", tempreg, tempreg, 0);
		macro_build (p, &icnt, (expressionS *) NULL, "dadd", "d,v,t",
			     tempreg, tempreg, AT);
		used_at = 1;
	      }
	    else
	      {
		macro_build (p, &icnt, &offset_expr, "lui", "t,u",
			     tempreg, (int) BFD_RELOC_MIPS_HIGHEST);
		macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
			     tempreg, tempreg, (int) BFD_RELOC_MIPS_HIGHER);
		macro_build (p, &icnt, (expressionS *) NULL, "dsll", "d,w,<",
			     tempreg, tempreg, 16);
		macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
			     tempreg, tempreg, (int) BFD_RELOC_HI16_S);
		macro_build (p, &icnt, (expressionS *) NULL, "dsll", "d,w,<",
			     tempreg, tempreg, 16);
		macro_build (p, &icnt, &offset_expr, "daddiu", "t,r,j",
			     tempreg, tempreg, (int) BFD_RELOC_LO16);
	      }
	  }
	else
	  {
	    if ((valueT) offset_expr.X_add_number <= MAX_GPREL_OFFSET
		&& ! nopic_need_relax (offset_expr.X_add_symbol, 1))
	      {
		frag_grow (20);
		macro_build ((char *) NULL, &icnt, &offset_expr, "addiu",
			     "t,r,j", tempreg, GP, (int) BFD_RELOC_GPREL16);
		p = frag_var (rs_machine_dependent, 8, 0,
			      RELAX_ENCODE (4, 8, 0, 4, 0,
					    mips_opts.warn_about_macros),
			      offset_expr.X_add_symbol, 0, NULL);
	      }
	    macro_build_lui (p, &icnt, &offset_expr, tempreg);
	    if (p != NULL)
	      p += 4;
	    macro_build (p, &icnt, &offset_expr, "addiu",
			 "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
	  }
d5294 1
a5294 1
			     "nop", "");
d7376 2
a7377 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "break",
		     "6", 7);
d7532 1
a7532 1
      macro_build ((char *) NULL, &icnt, &expr1, "slti", "x,8",  yreg);
d7704 1
a7704 1
	      		     | (mips_opts.ase_mips3d ? INSN_MIPS3D : 0)),
d7885 1
a7885 1
            case 'C':           /* Coprocessor code */
d7888 1
a7888 1
	      if ((unsigned long) imm_expr.X_add_number >= (1<<25))
d7892 1
a7892 1
		  imm_expr.X_add_number &= ((1<<25) - 1);
d8407 1
a8407 1
			  *imm_reloc = BFD_RELOC_MIPS_HIGHEST;
d8409 1
a8409 1
			  *imm_reloc = BFD_RELOC_MIPS_HIGHER;
d8545 1
a8545 1
			  *imm_reloc = BFD_RELOC_MIPS_HIGHEST;
d9418 12
a9429 12
	       if ((e - b == 3
		    && ((b[1] == 'f' && b[2] == 'p')
			|| (b[1] == 's' && b[2] == 'p')
			|| (b[1] == 'g' && b[2] == 'p')
			|| (b[1] == 'a' && b[2] == 't')
			|| (ISDIGIT (b[1])
			    && ISDIGIT (b[2]))))
		   || (ISDIGIT (b[1])))
		 {
		   *len = strcspn (*str, ")") + 1;
		   return S_EX_REGISTER;
		 }
d9480 1
a9480 1
	  i++;
d9574 1
a9574 1
      as_fatal(_("internal error"));
d9909 1
a9909 1
		cpu = ci->cpu;
d9916 2
a9917 2
	      as_warn(_("A different -mtune= was already specified, is now "
			"-mtune=%s"), arg);
d9922 2
a9923 2
	      as_warn(_("A different -march= was already specified, is now "
			"-march=%s"), arg);
d9928 2
a9929 2
	      as_warn(_("A different -mcpu= was already specified, is now "
			"-mcpu=%s"), arg);
d9938 2
a9939 2
        as_warn(_("A different -march= or -mtune= was already specified, "
		  "is now -m4650"));
d9950 2
a9951 2
        as_warn(_("A different -march= or -mtune= was already specified, "
		  "is now -m4010"));
d9962 2
a9963 2
        as_warn(_("A different -march= or -mtune= was already specified, "
		  "is now -m4100"));
d9974 2
a9975 2
        as_warn(_("A different -march= or -mtune= was already specified, "
		  "is now -m3900"));
d10491 1
a10491 1
     valueT * valP;
d10518 1
a10518 1
  value = * valP;
d11334 26
a11359 26
      {
      case  0:
	mips_opts.gp32 = file_mips_gp32;
	mips_opts.fp32 = file_mips_fp32;
	mips_opts.abi = file_mips_abi;
	break;
      case  1:
      case  2:
      case 32:
	mips_opts.gp32 = 1;
	mips_opts.fp32 = 1;
	break;
      case  3:
      case  4:
      case  5:
      case 64:
	/* Loosen ABI register width restriction.  */
	if (mips_opts.abi == O32_ABI)
	  mips_opts.abi = NO_ABI;
	mips_opts.gp32 = 0;
	mips_opts.fp32 = 0;
	break;
      default:
	as_bad (_("unknown ISA level %s"), name + 4);
	break;
      }
d11362 11
a11372 11
      {
      case  0: mips_opts.isa = file_mips_isa;   break;
      case  1: mips_opts.isa = ISA_MIPS1;       break;
      case  2: mips_opts.isa = ISA_MIPS2;       break;
      case  3: mips_opts.isa = ISA_MIPS3;       break;
      case  4: mips_opts.isa = ISA_MIPS4;       break;
      case  5: mips_opts.isa = ISA_MIPS5;       break;
      case 32: mips_opts.isa = ISA_MIPS32;      break;
      case 64: mips_opts.isa = ISA_MIPS64;      break;
      default: as_bad (_("unknown ISA level %s"), name + 4); break;
      }
d11836 1
a11836 1
	  ignore_rest_of_line();
d12805 1
a12805 1
  /* Set MIPS ELF flags for ASEs. */
@


1.117
log
@2002-04-22  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (macro_build): Add close-parenthesis missing
        from previous change.

(also, fix ChangeLog entry for previous patch.)
@
text
@d2916 2
d2920 1
a2920 4
	  && OPCODE_IS_MEMBER (insn.insn_mo,
			       (mips_opts.isa
	      		        | (mips_opts.ase_mips3d ? INSN_MIPS3D : 0)),
			       mips_arch)
@


1.116
log
@2002-04-22  Eric Christopher  <echristo@@redhat.com>

	* config/tc-mips.c: Add warning if macro instructions are expanded
	into a branch delay slot.
@
text
@d2893 1
a2893 1
	     | INSN_COND_BRANCH_LIKELY) != 0)
@


1.115
log
@	* config/tc-mips.c (mips16_macro_build): Cast type mismatch.
	(mips_ip): Remove unused variable.
	(md_apply_fix3): Cast signed/unsignes mismatches. Replace
	unsigned char with bfd_byte.
	(s_file): Remove unused variable.
	(s_mips_ent): Likewise.
@
text
@d2884 12
d10279 1
a10279 1
			     
@


1.114
log
@* config/tc-mips.c (md_estimate_size_before_relax): Do not modify
the EXTENDED bit here; report the estimate according to the
current size.
@
text
@d3169 1
a3169 1
	      *r = BFD_RELOC_UNUSED + c;
a7632 1
  int full_opcode_match = 1;
a7681 2

      full_opcode_match = 0;
d10483 1
a10483 1
  unsigned char *buf;
d10648 1
a10648 1
      buf = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
d10651 1
a10651 1
      md_number_to_chars (buf, value, 2);
d10664 1
a10664 1
      buf = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
d10667 1
a10667 1
      md_number_to_chars (buf, value, 2);
d10729 1
a10729 1
	  buf = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
d10732 1
a10732 1
	  md_number_to_chars (buf, value, 2);
d10763 1
a10763 1
      buf = (unsigned char *) (fixP->fx_where + fixP->fx_frag->fr_literal);
d12666 1
a12666 1
	  md_number_to_chars (buf, 0xf000 | extend, 2);
d12671 1
a12671 1
      md_number_to_chars (buf, insn, 2);
d12944 1
a12944 3
  int line;

  line = get_number ();
a13045 1
  int number = 0;
d13055 1
a13055 1
    number = get_number ();
@


1.113
log
@[ gas/ChangeLog ]
2002-03-15  Chris G. Demetriou  <cgd@@broadcom.com>

	* config/tc-mips.c (mips_set_options): New "ase_mips3d" member.
	(mips_opts): Initialize "ase_mips3d" member.
	(file_ase_mips3d): New variable.
	(CPU_HAS_MIPS3D): New macro.
	(md_begin): Initialize mips_opts.ase_mips3d and file_ase_mips3d
	based on command line options and configuration defaults.
	(macro_build, mips_ip): Accept MIPS-3D instructions if
	mips_opts.ase_mips3d is set.
	(OPTION_MIPS3D, OPTION_NO_MIPS3D, md_longopts, md_parse_option):
	Add support for "-mips3d" and "-no-mips3d" options.
	(OPTION_ELF_BASE): Move to accomodate new options.
	(s_mipsset): Support ".set mips3d" and ".set nomips3d".
	(mips_elf_final_processing): Add a comment indicating that a
	MIPS-3D ASE ELF header flag should be set, when one exists.
	* doc/as.texinfo: Document -mips3d and -no-mips3d options.
	* doc/c-mips.texi: Likewise, and document ".set mips3d" and ".set
	nomips3d" directives.

[ gas/testsuite/ChangeLog ]
2002-03-15  Chris G. Demetriou  <cgd@@broadcom.com>

	* gas/mips/mips64-mips3d.s: New file.
	* gas/mips/mips64-mips3d.d: Likewise.
	* gas/mips/mips.exp: Run new "mips64-mips3d" test.

[ include/opcode/ChangeLog ]
2002-03-15  Chris G. Demetriou  <cgd@@broadcom.com>

	* mips.h (INSN_MIPS3D): New definition used to mark MIPS-3D
	instructions.
	(OPCODE_IS_MEMBER): Adjust comments to indicate that ASE bit masks
	may be passed along with the ISA bitmask.

[ opcodes/ChangeLog ]
2002-03-15  Chris G. Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_isa_type): Add MIPS3D instructions to the ISA
	bit masks for bfd_mach_mips_sb1 and bfd_mach_mipsisa64.  Add
	comments for bfd_mach_mipsisa32 and bfd_mach_mipsisa64 that
	indicate that they should dissassemble all applicable
	MIPS-specified ASEs.
	* mips-opc.c: Add support for MIPS-3D instructions.
	(M3D): New definition.

	* mips-opc.c: Update copyright years.
@
text
@d12196 3
a12198 12
    {
      if (mips16_extended_frag (fragp, segtype, 0))
	{
	  fragp->fr_subtype = RELAX_MIPS16_MARK_EXTENDED (fragp->fr_subtype);
	  return 4;
	}
      else
	{
	  fragp->fr_subtype = RELAX_MIPS16_CLEAR_EXTENDED (fragp->fr_subtype);
	  return 2;
	}
    }
@


1.112
log
@2002-02-26  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (mips_need_elf_addend_fixup): For embedded-PIC
        only, undo the changes made on 2001-06-08, with the
        effect being that common or extern symbols are
        adjusted for embedded-PIC, but weak symbols are not.
        (md_estimate_size_before_relax: Likewise, with the effect
        that extern symbols are treated the same as weak symbols
        only if not embedded-PIC.
        (mips_fix_adjustable) Likewise, with the effect that
        weak or extern symbols are not adjusted for embedded-PIC.
        (md_apply_fix3): Tweak so that the case where value is zero
        is handled more correctly for embedded-PIC code.
@
text
@d140 4
d192 1
a192 1
  ISA_UNKNOWN, -1, 0, 0, 0, 0, 0, 0, 0, 0, NO_ABI
d204 4
d274 4
d1238 5
d1253 1
d2906 4
a2909 1
	  && OPCODE_IS_MEMBER (insn.insn_mo, mips_opts.isa, mips_arch)
d7694 4
a7697 1
      if (OPCODE_IS_MEMBER (insn, mips_opts.isa, mips_arch))
d9765 4
d9770 1
a9770 1
#define OPTION_ELF_BASE    (OPTION_MD_BASE + 33)
d9985 8
d11314 4
d12805 6
@


1.111
log
@	* config/tc-mips.c (set_at): Fix handling of 64bit register loads.
	(macro): Likewise. Fix la/dla address expansions for EMBEDDED_PIC
	and NO_PIC cases. Code cleanup.
	(macro2): Fix handling of 64bit register loads.
	* mips-gp64-fp32-pic.d: Fix test of 64bit register loads.
	* mips-gp64-fp32-pic.s: Likewise.
	* mips-gp64-fp32.d: Likewise.
	* mips-gp64-fp32.s: Likewise.
	* mips-gp64-fp64-pic.d: Likewise.
	* mips-gp64-fp64-pic.s: Likewise.
	* mips-gp64-fp64.d: Likewise.
	* mips-gp64-fp64.s: Likewise.
@
text
@d10422 6
a10427 2
  if ((S_IS_WEAK (fixP->fx_addsy)
       || S_IS_EXTERN (fixP->fx_addsy))
d10721 4
a10724 1
      if (!fixP->fx_done)
d12218 2
a12219 1
		    || (! S_IS_EXTERN (sym) && ! S_IS_WEAK (sym)))
d12260 1
@


1.110
log
@	* config/tc-mips.c (md_parse_option): Complain about invalid -mabi
	option input.
@
text
@d3260 1
a3260 1
      load_register (counter, AT, &imm_expr, 0);
d4027 1
a4027 1
      load_register (&icnt, AT, &imm_expr, 0);
d4619 1
a4619 1
			   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
d4623 1
a4623 1
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d4638 4
a4641 1
	load_register (&icnt, tempreg, &offset_expr, dbl);
d4713 1
a4713 2
		macro_build ((char *) NULL, &icnt, &offset_expr,
			     HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d4723 1
a4723 2
	    macro_build (p, &icnt, &offset_expr,
			 HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d4764 2
a4765 1
	  macro_build ((char *) NULL, &icnt, &offset_expr, dbl ? "ld" : "lw",
d4920 1
a4920 1
		       dbl ? "ld" : "lw",
d5023 1
a5023 1
		       dbl ? "ld" : "lw",
d5084 11
a5094 3
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		     HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
		     "d,v,t", treg, tempreg, breg);
d6764 1
a6764 1
	  load_register (&icnt, AT, &imm_expr, 0);
d6800 1
a6800 1
	  load_register (&icnt, AT, &imm_expr, 0);
d6828 1
a6828 1
      load_register (&icnt, AT, &imm_expr, 0);
d6851 1
a6851 1
      load_register (&icnt, AT, &imm_expr, 0);
d6867 1
a6867 1
      load_register (&icnt, AT, &imm_expr, 0);
d6881 1
a6881 1
      load_register (&icnt, AT, &imm_expr, 0);
d6938 1
a6938 1
	  load_register (&icnt, AT, &imm_expr, 0);
d7003 1
a7003 1
      load_register (&icnt, AT, &imm_expr, 0);
@


1.109
log
@2002-02-15  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (md_estimate_size_before_relax): Really
        make sure we treat weak like extern only for ELF.  (Fixes
        patch from 2001-07-25.)
@
text
@d10083 4
a10086 1
	mips_opts.abi = NO_ABI;
@


1.108
log
@2002-02-13  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (mips_need_elf_addend_fixup): Restructure into
        a sequence of indpendent 'if' statements for easier debugging
        and future modification.
@
text
@d12197 2
a12198 2
	  	&& (OUTPUT_FLAVOR == bfd_target_elf_flavour
		    && ! (S_IS_EXTERN (sym) || S_IS_WEAK (sym)))
@


1.107
log
@2002-02-08  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (IS_SEXT_32BIT_NUM): New macro to
        determine if a number is a sign-extended 32-bit number.
        (load_register): Use IS_SEXT_32BIT_NUM.
        (macro): Check if load/store macro handling is using a
        constant 32-bit address on 64-bit address systems, and if
        so optimize the generation of that address.
@
text
@d10407 15
a10421 11
  return (S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16
	  || ((S_IS_WEAK (fixP->fx_addsy)
	       || S_IS_EXTERN (fixP->fx_addsy))
	      && !S_IS_COMMON (fixP->fx_addsy))
	  || (symbol_used_in_reloc_p (fixP->fx_addsy)
	      && (((bfd_get_section_flags (stdoutput,
					   S_GET_SEGMENT (fixP->fx_addsy))
		    & SEC_LINK_ONCE) != 0)
		  || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
			       ".gnu.linkonce",
			       sizeof (".gnu.linkonce") - 1))));
@


1.107.2.1
log
@2002-02-13  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (mips_need_elf_addend_fixup): Restructure into
        a sequence of indpendent 'if' statements for easier debugging
        and future modification.
@
text
@d10407 11
a10417 15
  if (S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16)
    return 1;
  if ((S_IS_WEAK (fixP->fx_addsy)
       || S_IS_EXTERN (fixP->fx_addsy))
      && !S_IS_COMMON (fixP->fx_addsy))
    return 1;
  if (symbol_used_in_reloc_p (fixP->fx_addsy)
      && (((bfd_get_section_flags (stdoutput,
				   S_GET_SEGMENT (fixP->fx_addsy))
	    & SEC_LINK_ONCE) != 0)
	  || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
		       ".gnu.linkonce",
		       sizeof (".gnu.linkonce") - 1)))
    return 1;
  return 0;
@


1.107.2.2
log
@2002-02-15  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (md_estimate_size_before_relax): Really
        make sure we treat weak like extern only for ELF.  (Fixes
        patch from 2001-07-25.)
@
text
@d12197 2
a12198 2
	  	&& (OUTPUT_FLAVOR != bfd_target_elf_flavour
		    || (! S_IS_EXTERN (sym) && ! S_IS_WEAK (sym)))
@


1.107.2.3
log
@	* config/tc-mips.c (md_parse_option): Complain about invalid -mabi
	option input.
@
text
@d10083 1
a10083 4
	{
	  as_fatal (_("invalid abi -mabi=%s"), arg);
	  return 0;
	}
@


1.107.2.4
log
@	* config/tc-mips.c (set_at): Fix handling of 64bit register loads.
	(macro): Likewise. Fix la/dla address expansions for EMBEDDED_PIC
	and NO_PIC cases. Code cleanup.
	(macro2): Fix handling of 64bit register loads.
	* mips-gp64-fp32-pic.d: Fix test of 64bit register loads.
	* mips-gp64-fp32-pic.s: Likewise.
	* mips-gp64-fp32.d: Likewise.
	* mips-gp64-fp32.s: Likewise.
	* mips-gp64-fp64-pic.d: Likewise.
	* mips-gp64-fp64-pic.s: Likewise.
	* mips-gp64-fp64.d: Likewise.
	* mips-gp64-fp64.s: Likewise.
@
text
@d3260 1
a3260 1
      load_register (counter, AT, &imm_expr, HAVE_64BIT_GPRS);
d4027 1
a4027 1
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
d4619 1
a4619 1
			   (dbl || HAVE_64BIT_ADDRESSES) ? "daddu" : "addu",
d4623 1
a4623 1
		       (dbl || HAVE_64BIT_ADDRESSES) ? "daddiu" : "addiu",
d4638 1
a4638 4
	load_register (&icnt, tempreg, &offset_expr,
		       ((mips_pic == EMBEDDED_PIC || mips_pic == NO_PIC)
			? (dbl || HAVE_64BIT_ADDRESSES)
			: HAVE_64BIT_ADDRESSES));
d4710 2
a4711 1
		macro_build ((char *) NULL, &icnt, &offset_expr, "addiu",
d4721 2
a4722 1
	    macro_build (p, &icnt, &offset_expr, "addiu",
d4763 1
a4763 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d4918 1
a4918 1
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d5021 1
a5021 1
		       HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d5082 3
a5084 11
	{
	  char *s;

	  if (mips_pic == EMBEDDED_PIC || mips_pic == NO_PIC)
	    s = (dbl || HAVE_64BIT_ADDRESSES) ? "daddu" : "addu";
	  else
	    s = HAVE_64BIT_ADDRESSES ? "daddu" : "addu";

	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s,
		       "d,v,t", treg, tempreg, breg);
	}
d6754 1
a6754 1
	  load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
d6790 1
a6790 1
	  load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
d6818 1
a6818 1
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
d6841 1
a6841 1
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
d6857 1
a6857 1
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
d6871 1
a6871 1
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
d6928 1
a6928 1
	  load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
d6993 1
a6993 1
      load_register (&icnt, AT, &imm_expr, HAVE_64BIT_GPRS);
@


1.107.2.5
log
@2002-02-26  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (mips_need_elf_addend_fixup): For embedded-PIC
        only, undo the changes made on 2001-06-08, with the
        effect being that common or extern symbols are
        adjusted for embedded-PIC, but weak symbols are not.
        (md_estimate_size_before_relax: Likewise, with the effect
        that extern symbols are treated the same as weak symbols
        only if not embedded-PIC.
        (mips_fix_adjustable) Likewise, with the effect that
        weak or extern symbols are not adjusted for embedded-PIC.
        (md_apply_fix3): Tweak so that the case where value is zero
        is handled more correctly for embedded-PIC code.
@
text
@d10422 2
a10423 6
  if (mips_pic == EMBEDDED_PIC
      && S_IS_WEAK (fixP->fx_addsy))
    return 1;
  if (mips_pic != EMBEDDED_PIC
      && (S_IS_WEAK (fixP->fx_addsy)
	  || S_IS_EXTERN (fixP->fx_addsy))
d10717 1
a10717 4
      if (!fixP->fx_done
	  && (fixP->fx_r_type != BFD_RELOC_16_PCREL_S2
	      || fixP->fx_addsy == NULL			/* ??? */
	      || ! S_IS_DEFINED (fixP->fx_addsy)))
d12211 1
a12211 2
		    || (! S_IS_WEAK (sym)
			&& (! S_IS_EXTERN (sym) || mips_pic == EMBEDDED_PIC)))
a12251 1
      && mips_pic != EMBEDDED_PIC
@


1.107.2.6
log
@* config/tc-mips.c (md_estimate_size_before_relax): Do not modify
the EXTENDED bit here; report the estimate according to the
current size.
@
text
@d12156 12
a12167 3
    /* We don't want to modify the EXTENDED bit here; it might get us
       into infinite loops.  We change it only in mips_relax_frag().  */
    return (RELAX_MIPS16_EXTENDED (fragp->fr_subtype) ? 4 : 2);
@


1.106
log
@2002-01-29  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (tc_gen_reloc): Arrange for
        BFD_RELOC_PCREL_HI16_S relocations to be output relative to
        their LO16 parts, even for ELF.
@
text
@d3356 5
d3400 1
a3400 3
      else if ((((ep->X_add_number &~ (offsetT) 0x7fffffff) == 0
		 || ((ep->X_add_number &~ (offsetT) 0x7fffffff)
		     == ~ (offsetT) 0x7fffffff))
d5550 7
d5558 3
a5560 1
	  if (HAVE_64BIT_ADDRESSES)
@


1.105
log
@	* config/tc-mips.c (percent_op): Ensure longer percent_op's are
	matched before the shorter ones.
	(my_getSmallParser): Fix handling of nested parentheses in
	percent_op's. Code cleanup.
	(my_getPercentOp): New function, code from my_getSmallParser.
	(my_getSmallExpression): Fix handling of closing parentheses.
	Code cleanup. Better comments.
@
text
@a12271 2
  else if (fixp->fx_pcrel == 0 || OUTPUT_FLAVOR == bfd_target_elf_flavour)
    reloc->addend = fixp->fx_addnumber;
d12274 2
a12275 3
      /* We use a special addend for an internal RELLO reloc.  */
      if (symbol_section_p (fixp->fx_addsy))
	reloc->addend = reloc->address - S_GET_VALUE (fixp->fx_subsy);
d12277 7
a12283 1
	reloc->addend = fixp->fx_addnumber + reloc->address;
d12289 2
a12290 2
      /* We use a special addend for an internal RELHI reloc.  The
	 reloc is relative to the RELLO; adjust the addend
d12292 2
a12293 4
      if (symbol_section_p (fixp->fx_addsy))
	reloc->addend = (fixp->fx_next->fx_frag->fr_address
			 + fixp->fx_next->fx_where
			 - S_GET_VALUE (fixp->fx_subsy));
d12295 11
a12305 3
	reloc->addend = (fixp->fx_addnumber
			 + fixp->fx_next->fx_frag->fr_address
			 + fixp->fx_next->fx_where);
d12307 2
@


1.104
log
@2002-01-05  Daniel Jacobowitz  <drow@@mvista.com>

        * tc-mips.c (mips_cprestore_valid): New flag.
        (mips_frame_reg_valid): New flag.
        (macro) [M_JAL_2]: Check both flags.
        [M_JAL_A]: Likewise.
        (s_cprestore): Set mips_cprestore_valid.
        (tc_get_register): If setting mips_frame_reg, set
        mips_frame_reg_valid and clear mips_cprestore_valid.
        (s_mips_ent): Clear both flags.
        (s_mips_end): Clear both flags.

2002-01-05  Daniel Jacobowitz  <drow@@mvista.com>

        * gas/mips/jal-svr4pic.s: Add .ent and .frame directives.
        * gas/mips/mips-abi32-pic.s: Add .frame directive.
        * gas/mips/mips-gp32-fp32-pic.s: Likewise.
        * gas/mips/mips-gp32-fp64-pic.s: Likewise.
        * gas/mips/mips-gp64-fp32-pic.s: Likewise.
        * gas/mips/mips-gp64-fp64-pic.s: Likewise.
@
text
@d705 1
a9317 4
#ifdef OBJ_ELF
  {"%half", S_EX_HALF},
#endif
  {"%hi", S_EX_HI},
d9320 2
a9321 2
  {"%gp_rel", S_EX_GP_REL},
  {"%got", S_EX_GOT},
d9328 5
a9333 4
  {"%higher", S_EX_HIGHER},
  {"%highest", S_EX_HIGHEST},
  {"%call_hi", S_EX_CALL_HI},
  {"%call_lo", S_EX_CALL_LO}
d9335 1
a9348 2
  int type = S_EX_NONE;

d9351 1
d9378 1
d9382 1
a9382 1
	  goto percent_op;
d9385 15
a9399 2
      /* Some other expression in the braces.  */
      *len = strcspn (*str, ")") + 1;
d9401 1
a9401 1
  /* Check for percent_op.  */
d9403 1
a9403 3
    {
      char *tmp;
      unsigned int i;
d9405 3
a9407 3
percent_op:
      tmp = *str + 1;
      i = 0;
d9409 19
a9427 1
      while (ISALPHA (*tmp) || *tmp == '_')
d9429 5
a9433 10
	  *tmp = TOLOWER (*tmp);
	  tmp++;
	}
      while (i < (sizeof (percent_op) / sizeof (struct percent_op_match)))
	{
	  if (strncmp (*str, percent_op[i].str, strlen (percent_op[i].str)))
	      i++;
	  else
	    {
	      type = percent_op[i].type;
d9435 3
a9437 8
	      /* Only %hi and %lo are allowed for OldABI.  */
	      if (! HAVE_NEWABI && type != S_EX_HI && type != S_EX_LO)
		return S_EX_NONE;

	      *len = strlen (percent_op[i].str);
	      (*nestlevel)++;
	      return type;
	    }
a9439 2

  /* Any other expression.  */
d9451 1
a9451 1
  int nest_level = 0;
d9454 2
a9455 1
  /* Don't update oldstr if the last call had nested percent_op's.  */
d9462 1
a9462 1
      c = my_getSmallParser (&str, &len, &nest_level);
d9468 1
a9468 2
  /* A percent_op was encountered.  */
  if (nest_level)
d9470 2
a9471 1
      /* Don't try to get an expression if it is already blanked out.  */
d9476 1
d9482 1
a9482 1
      if (nest_level > 1)
d9484 15
a9498 3
	  /* blank out including the % sign.  */
	  char *p = strrchr (oldstr, '%');
	  memset (p, ' ', str - p + len);
d9502 2
a9503 3
	{
	  expr_end = strchr (str, ')') + 1;
	}
d9523 2
a9524 1
  if (nest_level <= 1)
@


1.103
log
@2001-12-20  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
            Daniel Jacobowitz <drow@@mvista.com>

        * config/tc-mips.c (file_mips_gp32): Initialize to invalid value.
        (file_mips_fp32): Likewise.
        (md_begin): Compatibility handling for -mipsN option.
@
text
@d415 4
d423 4
d5121 12
d5234 12
d11507 1
d11774 5
a11778 1
    mips_frame_reg = reg != 0 ? reg : SP;
d12846 4
d12967 4
@


1.102
log
@	* config.bfd: Remove trailing blanks.
	* elf32-mips.c (gprel16_with_gp): Remove superfluous casts.
	* strings.c (get_char): Initialize value.
	* config/tc-mips.c (mips_cpreturn_offset): Better comment.
	(load_register): Better error message. Cast away signedness
	mismatches. Add casts needed for varargs.
	(load_address): Replace checks of HAVE_64BIT_ADDRESS with dbl.
	Remove superfluous casts.
	(macro): Cast away signedness mismatches. Remove superfluous casts.
	(s_cpload): Fix wrong comment.
	(s_mips_weakext): Standardize output message.
	(get_number): Likewise.
@
text
@d177 1
a177 1
static int file_mips_gp32 = 0;
d180 1
a180 1
static int file_mips_fp32 = 0;
d1059 40
d1108 8
d1120 18
d1158 1
d1219 5
@


1.101
log
@	* config/tc-mips.c (append_insn): Add jump address range overflow
	check.
@
text
@d410 1
a410 1
   offset and even an other than GP as global pointer.  */
d3342 2
a3343 1
      as_bad (_("Number larger than 32 bits"));
d3378 1
a3378 1
      if (hi32.X_add_number == 0xffffffff)
d3517 1
a3517 1
      if ((freg == 0) && (lo32.X_add_number == 0xffffffff))
d3521 2
a3522 2
	  macro_build ((char *) NULL, counter, NULL, "dsrl32", "d,w,<", reg,
		       reg, 0);
d3528 2
a3529 2
	  macro_build ((char *) NULL, counter, NULL, "dsll", "d,w,<", reg,
		       freg, 16);
d3536 2
a3537 2
      macro_build ((char *) NULL, counter, NULL, "dsll", "d,w,<", reg,
		   reg, 16);
d3596 1
a3596 1
      if (HAVE_64BIT_ADDRESSES)
d3648 1
a3648 1
			    ep->X_add_symbol, (offsetT) 0, (char *) NULL);
d3653 1
a3653 2
	  macro_build (p, counter, ep,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d3716 2
a3717 4
		   HAVE_32BIT_ADDRESSES ? "addu" : "daddu",
		   "d,v,t", reg, reg, GP);
      macro_build ((char *) NULL, counter, ep,
		   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d3722 1
a3722 1
		    ep->X_add_symbol, (offsetT) 0, (char *) NULL);
d3732 1
a3732 1
      macro_build (p, counter, ep, HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d3737 1
a3737 1
      macro_build (p, counter, ep, HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d3744 1
a3744 2
	  macro_build ((char *) NULL, counter, &ex,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d4071 1
a4071 1
	      && imm_expr.X_add_number == 0xffffffff))
d4216 1
a4216 1
	      && imm_expr.X_add_number == 0xffffffff))
d4632 1
a4632 2
			      offset_expr.X_add_symbol, (offsetT) 0,
			      (char *) NULL);
d5506 1
a5506 2
				offset_expr.X_add_symbol, (offsetT) 0,
				(char *) NULL);
d5530 1
a5530 2
				offset_expr.X_add_symbol, (offsetT) 0,
				(char *) NULL);
d5754 1
a5754 2
	  /* FIXME: This won't work for a 64 bit address.  */
	  macro_build_lui ((char *) NULL, &icnt, &offset_expr, AT);
d5858 1
a5858 1
	      macro_build_lui ((char *) NULL, &icnt, &offset_expr, AT);
d6061 1
a6061 2
			    offset_expr.X_add_symbol, (offsetT) 0,
			    (char *) NULL);
d11275 2
a11276 2
     lui	$gp, %gp_rel(%neg(%hi(label)))
     daddiu	$gp, $gp, %gp_rel(%neg(%lo(label)))
d11281 2
a11282 2
     lui	$gp, %gp_rel(%neg(%hi(label)))
     daddiu	$gp, $gp, %gp_rel(%neg(%lo(label)))
d11601 1
a11601 1
	  as_bad ("Ignoring attempt to redefine symbol `%s'.",
d12676 1
a12676 1
    as_bad (_("Expected simple number."));
d12704 1
a12704 1
      as_warn (_("Invalid number"));
@


1.100
log
@	* config/tc-mips.c (md_parse_option): Fix comment. Allow -mabi option
	for ELF only.
	(show): Document -mabi option.
@
text
@d1977 4
d1987 4
@


1.99
log
@2001-12-03  Eric Christopher  <echristo@@redhat.com>

        * config/tc-mips.c (tc_gen_reloc): One missed BFD_RELOC_MIPS_GPREL.
@
text
@d9864 2
a9865 2
      /* The -32 and -64 options tell the assembler to output the 32
         bit or the 64 bit MIPS ELF format.  */
d9867 5
d9876 5
d9885 5
d9916 5
d10066 13
@


1.98
log
@	* coff-mips.c (mips_bfd_reloc_type_lookup): Replace
	BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
	* pe-mips.c (mips_bfd_reloc_type_lookup): Likewise.
	* elf32-mips.c (mips_reloc_map): Likewise. Replace
	BFD_RELOC_MIPS_GPREL32 by BFD_RELOC_GPREL32.
	* elf64-mips.c (mips_reloc_map): Likewise.
	* reloc.c (BFD_RELOC_MIPS_GPREL): Remove.
	(BFD_RELOC_MIPS_GPREL32): Remove.
	* config/tc-mips.c (macro_build): Replace BFD_RELOC_MIPS_GPREL
	by BFD_RELOC_GPREL16.
	(load_address): Likewise.
	(macro): Likewise.
	(md_apply_fix): Likewise. Replace BFD_RELOC_MIPS_GPREL32 by
	BFD_RELOC_GPREL32.
	(s_gpword): Replace BFD_RELOC_MIPS_GPREL32 by BFD_RELOC_GPREL32.
	(tc_gen_reloc): Replace BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
	*config/tc-mips.h: Replace BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
@
text
@d12269 1
a12269 1
      && code == BFD_RELOC_MIPS_GPREL
@


1.97
log
@	* config/tc-mips.c (mips_need_elf_addend_fixup): New, extracted from...
	(md_apply_fix3): ...here.  Don't prevent the symbol value being
	subtracted twice from GPREL addends.
	(tc_gen_reloc): Add the symbol value to a GPREL addend if it was
	subtracted by the previous function.
@
text
@d2889 1
a2889 1
	  assert (*r == BFD_RELOC_MIPS_GPREL
d3564 1
a3564 1
	   addiu	$reg,$gp,<sym>		(BFD_RELOC_MIPS_GPREL)
d3634 2
a3635 2
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
			   "t,r,j", reg, GP, (int) BFD_RELOC_MIPS_GPREL);
d3746 1
a3746 1
	   addiu	$reg,$gp,<sym>		(BFD_RELOC_MIPS_GPREL)
d3748 2
a3749 3
      macro_build ((char *) NULL, counter, ep,
		   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		   "t,r,j", reg, GP, (int) BFD_RELOC_MIPS_GPREL);
d4553 1
a4553 1
	       addiu	$tempreg,$gp,<sym>	(BFD_RELOC_MIPS_GPREL)
d4623 1
a4623 1
			     "t,r,j", tempreg, GP, (int) BFD_RELOC_MIPS_GPREL);
d4984 1
a4984 1
	       addiu	$tempreg,$gp,<sym>	(BFD_RELOC_MIPS_GPREL)
d4988 1
a4988 1
		       "t,r,j", tempreg, GP, (int) BFD_RELOC_MIPS_GPREL);
d5388 1
a5388 1
	       <op>	$treg,<sym>($gp)	(BFD_RELOC_MIPS_GPREL)
d5398 1
a5398 1
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_MIPS_GPREL)
d5496 1
a5496 1
			       treg, (int) BFD_RELOC_MIPS_GPREL, GP);
d5524 1
a5524 1
			       treg, (int) BFD_RELOC_MIPS_GPREL, tempreg);
d5650 1
a5650 1
	       <op>	$treg,<sym>($gp)	(BFD_RELOC_MIPS_GPREL)
d5653 1
a5653 1
	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_MIPS_GPREL)
d5659 1
a5659 1
			   treg, (int) BFD_RELOC_MIPS_GPREL, GP);
d5668 1
a5668 1
			   treg, (int) BFD_RELOC_MIPS_GPREL, tempreg);
d5767 1
a5767 1
		       "t,r,j", AT, GP, (int) BFD_RELOC_MIPS_GPREL);
d6000 2
a6001 2
	       <op>	$treg,<sym>($gp)	(BFD_RELOC_MIPS_GPREL)
	       <op>	$treg+1,<sym>+4($gp)	(BFD_RELOC_MIPS_GPREL)
d6004 2
a6005 2
	       <op>	$treg,<sym>($at)	(BFD_RELOC_MIPS_GPREL)
	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_MIPS_GPREL)
d6044 1
a6044 1
			   (int) BFD_RELOC_MIPS_GPREL, tempreg);
d6054 1
a6054 1
			   (int) BFD_RELOC_MIPS_GPREL, tempreg);
d6270 2
a6271 2
	       <op>	$treg,<sym>($gp)	(BFD_RELOC_MIPS_GPREL)
	       <op>	$treg+1,<sym>+4($gp)	(BFD_RELOC_MIPS_GPREL)
d6274 2
a6275 2
	       <op>	$treg,<sym>($at)	(BFD_RELOC_MIPS_GPREL)
	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_MIPS_GPREL)
d6294 1
a6294 1
		       (int) BFD_RELOC_MIPS_GPREL, tempreg);
d6299 1
a6299 1
		       (int) BFD_RELOC_MIPS_GPREL, tempreg);
d10375 1
a10375 1
    case BFD_RELOC_MIPS_GPREL:
d10379 1
a10379 1
    case BFD_RELOC_MIPS_GPREL32:
d11477 1
a11477 1
	       BFD_RELOC_MIPS_GPREL32);
d12139 1
a12139 1
      && (fixp->fx_r_type == BFD_RELOC_MIPS_GPREL
d12159 2
a12160 2
	  assert ((fixp->fx_r_type == BFD_RELOC_MIPS_GPREL
		   && fixp->fx_next->fx_r_type == BFD_RELOC_MIPS_GPREL)
d12196 1
a12196 1
	  assert (fixp->fx_r_type == BFD_RELOC_MIPS_GPREL);
@


1.96
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d737 3
d10224 19
d10282 1
a10282 12
      if (S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16
	  || ((S_IS_WEAK (fixP->fx_addsy)
	       || S_IS_EXTERN (fixP->fx_addsy))
	      && !S_IS_COMMON (fixP->fx_addsy))
	  || (symbol_used_in_reloc_p (fixP->fx_addsy)
	      && (((bfd_get_section_flags (stdoutput,
					   S_GET_SEGMENT (fixP->fx_addsy))
		    & SEC_LINK_ONCE) != 0)
		  || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
			       ".gnu.linkonce",
			       sizeof (".gnu.linkonce") - 1))))

d10287 1
a10287 3
	  if (value != 0
	      && ! fixP->fx_pcrel
	      && fixP->fx_r_type != BFD_RELOC_MIPS_GPREL)
d12262 13
@


1.95
log
@	* config/tc-mips.c (mips_ip): Re-allow %hi() op for non-ELF assembler.
@
text
@d10097 1
a10097 1
   the corresponding LO reloc.  This is called before md_apply_fix and
d10223 2
a10224 2
int
md_apply_fix (fixP, valueP)
d10226 2
a10227 1
     valueT *valueP;
d10253 1
a10253 1
  value = *valueP;
d10274 1
d10342 1
a10342 1
  fixP->fx_addnumber = value;	/* Remember value for tc_gen_reloc */
a10581 2

  return 1;
@


1.94
log
@	* config/tc-mips.c (support_64bit_objects): Define for OBJ_ELF only.
	(md_longopts): Allow OPTION_MABI for ELF compilation only. RE-allow
	OPTION_GP32, OPTION_GP64, OPTION_FP32 for non-ELF compilation.
	Sort options a bit more logical.
	(md_parse_option): Allow OPTION_32, OPTION_N32, OPTION_N64,
	OPTION_MABI only for elf targets.
	* gas/mips/mips.exp: Change naming of some conditionals to reflect
	the object format they actually mean. Don't try mips-abi32 and
	mips-abi32-pic tests for ecoff.
@
text
@a8376 3
#ifdef OBJ_ELF
		      else if (c == S_EX_HIGHEST)
			  *imm_reloc = BFD_RELOC_MIPS_HIGHEST;
d8382 3
@


1.93
log
@	* config/tc-mips.c (set_at): Add cast needed for varargs.
	(load_register): Likewise.
	(macro): Likewise. Some code reformatting.
	(macro2): Add cast needed for varargs.
	(mips16_macro): Likewise.
@
text
@d700 1
d702 1
d9491 1
d9510 1
d9525 7
a9531 3
#define OPTION_MCPU (OPTION_MD_BASE + 5)
  {"mcpu", required_argument, NULL, OPTION_MCPU},
#define OPTION_MEMBEDDED_PIC (OPTION_MD_BASE + 6)
d9533 1
a9533 1
#define OPTION_TRAP (OPTION_MD_BASE + 7)
d9536 1
a9536 1
#define OPTION_BREAK (OPTION_MD_BASE + 8)
d9539 1
a9539 1
#define OPTION_EB (OPTION_MD_BASE + 9)
d9541 1
a9541 1
#define OPTION_EL (OPTION_MD_BASE + 10)
d9543 23
a9565 1
#define OPTION_M4650 (OPTION_MD_BASE + 11)
d9567 1
a9567 1
#define OPTION_NO_M4650 (OPTION_MD_BASE + 12)
d9569 1
a9569 1
#define OPTION_M4010 (OPTION_MD_BASE + 13)
d9571 1
a9571 1
#define OPTION_NO_M4010 (OPTION_MD_BASE + 14)
d9573 1
a9573 1
#define OPTION_M4100 (OPTION_MD_BASE + 15)
d9575 1
a9575 1
#define OPTION_NO_M4100 (OPTION_MD_BASE + 16)
d9577 1
a9577 5
#define OPTION_MIPS16 (OPTION_MD_BASE + 17)
  {"mips16", no_argument, NULL, OPTION_MIPS16},
#define OPTION_NO_MIPS16 (OPTION_MD_BASE + 18)
  {"no-mips16", no_argument, NULL, OPTION_NO_MIPS16},
#define OPTION_M3900 (OPTION_MD_BASE + 19)
d9579 1
a9579 1
#define OPTION_NO_M3900 (OPTION_MD_BASE + 20)
d9581 1
a9581 9
#define OPTION_MABI (OPTION_MD_BASE + 21)
  {"mabi", required_argument, NULL, OPTION_MABI},
#define OPTION_M7000_HILO_FIX (OPTION_MD_BASE + 22)
  {"mfix7000", no_argument, NULL, OPTION_M7000_HILO_FIX},
#define OPTION_NO_M7000_HILO_FIX (OPTION_MD_BASE + 23)
  {"no-fix-7000", no_argument, NULL, OPTION_NO_M7000_HILO_FIX},
#define OPTION_GP32 (OPTION_MD_BASE + 24)
  {"mgp32", no_argument, NULL, OPTION_GP32},
#define OPTION_GP64 (OPTION_MD_BASE + 25)
a9582 16
#define OPTION_CONSTRUCT_FLOATS (OPTION_MD_BASE + 26)
  {"construct-floats", no_argument, NULL, OPTION_CONSTRUCT_FLOATS},
#define OPTION_NO_CONSTRUCT_FLOATS (OPTION_MD_BASE + 27)
  {"no-construct-floats", no_argument, NULL, OPTION_NO_CONSTRUCT_FLOATS},
#define OPTION_MIPS32 (OPTION_MD_BASE + 28)
  {"mips32", no_argument, NULL, OPTION_MIPS32},
#define OPTION_MIPS5 (OPTION_MD_BASE + 29)
  {"mips5", no_argument, NULL, OPTION_MIPS5},
#define OPTION_MIPS64 (OPTION_MD_BASE + 30)
  {"mips64", no_argument, NULL, OPTION_MIPS64},
#define OPTION_MARCH (OPTION_MD_BASE + 31)
  {"march", required_argument, NULL, OPTION_MARCH},
#define OPTION_MTUNE (OPTION_MD_BASE + 32)
  {"mtune", required_argument, NULL, OPTION_MTUNE},
#define OPTION_FP32 (OPTION_MD_BASE + 33)
  {"mfp32", no_argument, NULL, OPTION_FP32},
d9584 1
a9584 1
#define OPTION_ELF_BASE    (OPTION_MD_BASE + 35)
a9585 5
#define OPTION_NON_SHARED  (OPTION_ELF_BASE + 1)
#define OPTION_XGOT        (OPTION_ELF_BASE + 2)
#define OPTION_32 	   (OPTION_ELF_BASE + 3)
#define OPTION_N32 	   (OPTION_ELF_BASE + 4)
#define OPTION_64          (OPTION_ELF_BASE + 5)
d9588 1
d9590 1
d9592 3
d9596 1
d9598 1
d9600 1
a9600 2
#endif

d9877 1
d9897 1
@


1.92
log
@	* config/tc-mips.c (md_assemble): Remove superflous casts.
	(append_insn): Likewise.
	(mips16_macro_build): Likewise.
	(macro): Likewise.
	(mips16_ip): Likewise.
	(s_cpload): Likewise.
	(mips_relax_frag): Likewise.
@
text
@d3167 1
a3167 1
      macro_build ((char *) NULL, counter, NULL,
d3415 1
a3415 1
	      macro_build ((char *) NULL, counter, NULL,
d3470 1
a3470 1
		  macro_build ((char *) NULL, counter, NULL,
d3475 1
a3475 1
	      macro_build ((char *) NULL, counter, NULL,
d3494 2
a3495 2
	  macro_build ((char *) NULL, counter, NULL, "dsll32", "d,w,<", reg,
		       freg, 0);
d3599 4
a3602 4
	      macro_build (p, counter, NULL, "dsll32", "d,w,<",
			   reg, reg, 0);
	      macro_build (p, counter, NULL, "dadd", "d,v,t",
			   reg, reg, AT);
d3611 2
a3612 2
	      macro_build (p, counter, NULL, "dsll", "d,w,<",
			   reg, reg, 16);
d3615 2
a3616 2
	      macro_build (p, counter, NULL, "dsll", "d,w,<",
			   reg, reg, 16);
d3835 2
a3836 1
	macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
d3839 1
a3839 1
      macro_build ((char *) NULL, &icnt, NULL,
d3872 2
a3873 1
      macro_build ((char *) NULL, &icnt, NULL, s2, "d,v,t", treg, sreg, AT);
d3903 2
a3904 2
	      macro_build ((char *) NULL, &icnt, NULL, "nor", "d,v,t",
			   treg, treg, 0);
d3910 2
a3911 1
      macro_build ((char *) NULL, &icnt, NULL, s2, "d,v,t", treg, sreg, AT);
d3944 1
a3944 2
		       likely ? "bgezl" : "bgez",
		       "s,p", sreg);
d3950 1
a3950 2
		       likely ? "blezl" : "blez",
		       "s,p", treg);
d3953 2
a3954 1
      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", AT, sreg, treg);
d3982 2
a3983 1
	      macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
d4050 2
a4051 2
      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", AT, sreg,
		   treg);
d4100 2
a4101 1
      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", AT, treg, sreg);
d4117 2
a4118 2
      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", AT, treg,
		   sreg);
d4138 2
a4139 1
      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", AT, treg, sreg);
d4195 2
a4196 2
      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", AT, treg,
		   sreg);
d4246 2
a4247 1
      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", AT, sreg, treg);
d4263 2
a4264 1
      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", AT, sreg,
d4284 2
a4285 1
	    macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", 0, 0);
d4287 2
a4288 1
	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d4297 3
a4299 2
	  macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", treg, 0);
	  macro_build ((char *) NULL, &icnt, NULL,
d4306 1
a4306 1
	  macro_build ((char *) NULL, &icnt, NULL,
d4308 2
a4309 1
	  macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d4322 2
a4323 2
	  macro_build ((char *) NULL, &icnt, NULL, "dsll32", "d,w,<", AT, AT,
		       31);
d4333 2
a4334 1
	  macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", sreg, AT);
d4343 2
a4344 1
	  macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
d4350 2
a4351 1
	  macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
d4353 1
a4353 1
      macro_build ((char *) NULL, &icnt, NULL, s, "d", dreg);
d4396 2
a4397 1
	    macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", 0, 0);
d4399 2
a4400 1
	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d4417 2
a4418 2
	      macro_build ((char *) NULL, &icnt, NULL, dbl ? "dneg" : "neg",
			   "d,w", dreg, sreg);
d4426 3
a4428 2
      macro_build ((char *) NULL, &icnt, NULL, s, "z,s,t", sreg, AT);
      macro_build ((char *) NULL, &icnt, NULL, s2, "d", dreg);
d4452 4
a4455 2
	  macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", treg, 0);
	  macro_build ((char *) NULL, &icnt, NULL, s, "z,s,t", sreg, treg);
d4464 2
a4465 1
	  macro_build ((char *) NULL, &icnt, NULL, s, "z,s,t", sreg, treg);
d4470 2
a4471 1
	  macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d4473 1
a4473 1
      macro_build ((char *) NULL, &icnt, NULL, s2, "d", dreg);
d4589 3
a4591 3
		macro_build (p, &icnt, NULL, "dsll32", "d,w,<",
			     tempreg, tempreg, 0);
		macro_build (p, &icnt, NULL, "dadd", "d,v,t",
d4601 1
a4601 1
		macro_build (p, &icnt, NULL, "dsll", "d,w,<",
d4605 1
a4605 1
		macro_build (p, &icnt, NULL, "dsll", "d,w,<",
d4671 1
a4671 2
	  macro_build ((char *) NULL, &icnt, &offset_expr,
		       dbl ? "ld" : "lw",
d5451 6
a5456 6
		    macro_build (p, &icnt, NULL, "daddu", "d,v,t",
				 AT, AT, breg);
		  macro_build (p, &icnt, NULL, "dsll32", "d,w,<",
			       tempreg, tempreg, 0);
		  macro_build (p, &icnt, NULL, "daddu", "d,v,t",
			       tempreg, tempreg, AT);
d5467 2
a5468 2
		  macro_build (p, &icnt, NULL, "dsll", "d,w,<",
			       tempreg, tempreg, 16);
d5471 2
a5472 2
		  macro_build (p, &icnt, NULL, "dsll", "d,w,<",
			       tempreg, tempreg, 16);
d5474 2
a5475 2
		    macro_build (p, &icnt, NULL, "daddu", "d,v,t",
				 tempreg, tempreg, breg);
d6424 4
a6427 4
      macro_build ((char *) NULL, &icnt, NULL,
		   dbl ? "dmultu" : "multu",
		   "s,t", sreg, treg);
      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
d6437 1
a6437 1
      macro_build ((char *) NULL, &icnt, NULL,
d6439 2
a6440 1
      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
d6458 1
a6458 1
      macro_build ((char *) NULL, &icnt, NULL,
d6460 3
a6462 2
      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
      macro_build ((char *) NULL, &icnt, NULL,
d6464 2
a6465 1
      macro_build ((char *) NULL, &icnt, NULL, "mfhi", "d", AT);
d6467 2
a6468 1
	macro_build ((char *) NULL, &icnt, NULL, "tne", "s,t", dreg, AT);
d6472 6
a6477 3
	  macro_build ((char *) NULL, &icnt, &expr1, "beq", "s,t,p", dreg, AT);
	  macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
	  macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
d6480 1
a6480 1
      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
d6498 1
a6498 1
      macro_build ((char *) NULL, &icnt, NULL,
d6501 4
a6504 2
      macro_build ((char *) NULL, &icnt, NULL, "mfhi", "d", AT);
      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
d6506 2
a6507 1
	macro_build ((char *) NULL, &icnt, NULL, "tne", "s,t", AT, 0);
d6512 4
a6515 2
	  macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
	  macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
d6521 8
a6528 5
      macro_build ((char *) NULL, &icnt, NULL, "subu", "d,v,t", AT, 0, treg);
      macro_build ((char *) NULL, &icnt, NULL, "srlv", "d,t,s", AT, sreg, AT);
      macro_build ((char *) NULL, &icnt, NULL, "sllv", "d,t,s", dreg, sreg,
		   treg);
      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d6534 6
a6539 5
      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", AT, sreg,
		   (int) (imm_expr.X_add_number & 0x1f));
      macro_build ((char *) NULL, &icnt, NULL, "srl", "d,w,<", dreg, sreg,
		   (int) ((0 - imm_expr.X_add_number) & 0x1f));
      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d6543 8
a6550 5
      macro_build ((char *) NULL, &icnt, NULL, "subu", "d,v,t", AT, 0, treg);
      macro_build ((char *) NULL, &icnt, NULL, "sllv", "d,t,s", AT, sreg, AT);
      macro_build ((char *) NULL, &icnt, NULL, "srlv", "d,t,s", dreg, sreg,
		   treg);
      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d6556 6
a6561 5
      macro_build ((char *) NULL, &icnt, NULL, "srl", "d,w,<", AT, sreg,
		   (int) (imm_expr.X_add_number & 0x1f));
      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", dreg, sreg,
		   (int) ((0 - imm_expr.X_add_number) & 0x1f));
      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
d6591 2
a6592 2
	  macro_build ((char *) NULL, &icnt, NULL, "xor", "d,v,t", dreg,
		       sreg, treg);
d6634 2
a6635 2
	  macro_build ((char *) NULL, &icnt, NULL, "xor", "d,v,t", dreg,
		       sreg, AT);
d6650 2
a6651 1
      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, sreg, treg);
d6670 3
a6672 3
	  macro_build ((char *) NULL, &icnt, NULL,
		       mask == M_SGE_I ? "slt" : "sltu",
		       "d,v,t", dreg, sreg, AT);
d6687 2
a6688 1
      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, treg, sreg);
d6698 2
a6699 1
      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, AT, sreg);
d6702 1
a6702 1
    case M_SLE:		/* sreg <= treg  <==>  treg >= sreg  <==>  not (treg < sreg) */
d6708 2
a6709 1
      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, treg, sreg);
d6714 1
a6714 1
    case M_SLE_I:		/* sreg <= I <==> I >= sreg <==> not (I < sreg) */
d6721 2
a6722 1
      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, AT, sreg);
d6737 2
a6738 1
      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", dreg, sreg, AT);
d6751 2
a6752 2
      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, sreg,
		   AT);
d6757 2
a6758 2
	macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0,
		     treg);
d6760 2
a6761 2
	macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0,
		     sreg);
d6764 4
a6767 4
	  macro_build ((char *) NULL, &icnt, NULL, "xor", "d,v,t", dreg,
		       sreg, treg);
	  macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0,
		       dreg);
d6774 2
a6775 2
	  macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0,
		       sreg);
d6808 2
a6809 2
	  macro_build ((char *) NULL, &icnt, NULL, "xor", "d,v,t", dreg,
		       sreg, AT);
d6812 2
a6813 1
      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0, dreg);
d6832 1
a6832 1
      macro_build ((char *) NULL, &icnt, NULL,
d6850 1
a6850 1
      macro_build ((char *) NULL, &icnt, NULL,
d6873 2
a6874 1
      macro_build ((char *) NULL, &icnt, NULL, s, "s,t", sreg, AT);
d6890 5
a6894 3
      macro_build ((char *) NULL, &icnt, NULL, "cfc1", "t,G", treg, 31);
      macro_build ((char *) NULL, &icnt, NULL, "cfc1", "t,G", treg, 31);
      macro_build ((char *) NULL, &icnt, NULL, "nop", "");
d6901 4
a6904 3
      macro_build ((char *) NULL, &icnt, NULL, "ctc1", "t,G", AT, 31);
      macro_build ((char *) NULL, &icnt, NULL, "nop", "");
      macro_build ((char *) NULL, &icnt, NULL,
d6906 3
a6908 2
      macro_build ((char *) NULL, &icnt, NULL, "ctc1", "t,G", treg, 31);
      macro_build ((char *) NULL, &icnt, NULL, "nop", "");
d6931 4
a6934 2
      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", treg, treg, 8);
      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", treg, treg, AT);
d7010 4
a7013 4
      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", treg,
		   treg, 8);
      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", treg,
		   treg, AT);
d7023 2
a7024 1
      macro_build ((char *) NULL, &icnt, NULL, "srl", "d,w,<", AT, treg, 8);
d7098 2
a7099 2
      macro_build ((char *) NULL, &icnt, NULL, "srl", "d,w,<", treg,
		   treg, 8);
d7112 4
a7115 4
      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", treg,
		   treg, 8);
      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", treg,
		   treg, AT);
d7174 1
a7174 1
      macro_build ((char *) NULL, &icnt, NULL,
d7179 2
a7180 1
      macro_build ((char *) NULL, &icnt, NULL, "break", "6", 7);
d7187 1
a7187 1
      macro_build ((char *) NULL, &icnt, NULL, s, "x", zreg);
d7209 2
a7210 1
      macro_build ((char *) NULL, &icnt, NULL, s, "0,x,y", xreg, yreg);
d7213 2
a7214 1
	macro_build ((char *) NULL, &icnt, NULL, "break", "6", 7);
d7216 1
a7216 1
      macro_build ((char *) NULL, &icnt, NULL, s2, "x", zreg);
d7222 1
a7222 1
      macro_build ((char *) NULL, &icnt, NULL,
d7224 2
a7225 1
      macro_build ((char *) NULL, &icnt, NULL, "mflo", "x", zreg);
@


1.91
log
@	* config/tc-mips.c (mips_abi_level): Move in front of
	mips_set_options.
	(mips_set_options): Add members gp32, fp32, abi.
	(file_mips_gp32): New flag.
	(file_mips_fp32): New flag.
	(mips_opts): Initialize the new members.
	(mips_gp32): Remove.
	(mips_fp32): Remove.
	(HAVE_32BIT_GPRS): Use the new values from mips_opts.
	(HAVE_32BIT_FPRS): Likewise.
	(HAVE_NEWABI): Likewise.
	(HAVE_64BIT_OBJECTS): Likewise.
	(md_begin): Likewise. Save default (file) values.
	(md_parse_option): Use the new values from mips_opts.
	(s_mipsset): Likewise. Fix logic to keep the ABI selection if
	possible. Let .set mipsN work together with .set push/pop.
	Enhance error messages.
	(mips_elf_final_processing): Use file_mips_* for header processing.
@
text
@d1390 1
a1390 2
	append_insn ((char *) NULL, &insn, &imm_expr, imm_reloc,
		     imm_unmatched_hi);
d1392 1
a1392 1
	append_insn ((char *) NULL, &insn, &offset_expr, offset_reloc, false);
d1394 1
a1394 1
	append_insn ((char *) NULL, &insn, NULL, unused_reloc, false);
d1908 1
a1908 2
		    make_expr_symbol (address_expr), (offsetT) 0,
		    (char *) NULL);
d3057 3
a3059 3
		mips16_immed ((char *) NULL, 0, c, ep->X_add_number, false,
			      false, false, &insn.insn_opcode,
			      &insn.use_extend, &insn.extend);
d4673 1
a4673 2
			    offset_expr.X_add_symbol, (offsetT) 0,
			    (char *) NULL);
d4694 3
a4696 4
	      (void) frag_var (rs_machine_dependent, 0, 0,
			       RELAX_ENCODE (0, 0, -12, -4, 0, 0),
			       offset_expr.X_add_symbol, (offsetT) 0,
			       (char *) NULL);
d4727 1
a4727 1
	      macro_build_lui ((char *) NULL, &icnt, &expr1, AT);
d4736 3
a4738 4
	      (void) frag_var (rs_machine_dependent, 0, 0,
			       RELAX_ENCODE (0, 0, -16 + off1, -8, 0, 0),
			       offset_expr.X_add_symbol, (offsetT) 0,
			       (char *) NULL);
d4830 1
a4830 2
			    offset_expr.X_add_symbol, (offsetT) 0,
			    (char *) NULL);
d4846 1
a4846 2
			    offset_expr.X_add_symbol, (offsetT) 0,
			    (char *) NULL);
d4880 1
a4880 1
	      macro_build_lui ((char *) NULL, &icnt, &expr1, AT);
d4896 1
a4896 2
			    offset_expr.X_add_symbol, (offsetT) 0,
			    (char *) NULL);
d5064 1
a5064 2
			    offset_expr.X_add_symbol, (offsetT) 0,
			    (char *) NULL);
d5088 1
a5088 2
			    offset_expr.X_add_symbol, (offsetT) 0,
			    (char *) NULL);
d5548 1
a5548 2
			offset_expr.X_add_symbol, (offsetT) 0,
			(char *) NULL);
d5601 1
a5601 1
			offset_expr.X_add_symbol, (offsetT) 0, (char *) NULL);
d6138 1
a6138 2
			   offset_expr.X_add_symbol, (offsetT) 0,
			   (char *) NULL);
d6207 1
a6207 2
			offset_expr.X_add_symbol, (offsetT) 0,
			(char *) NULL);
d8532 1
a8532 2
		      mips16_immed ((char *) NULL, 0,
				    *imm_reloc - BFD_RELOC_UNUSED,
d11155 1
a11155 1
  macro_build_lui ((char *) NULL, &icnt, &ex, GP);
d12223 1
a12223 1
  if (mips16_extended_frag (fragp, (asection *) NULL, stretch))
@


1.90
log
@	* config/tc-mips.c (mips_force_relocation): Remove duplicate code.
@
text
@d116 14
d166 8
d176 6
d188 1
a188 1
  ISA_UNKNOWN, -1, 0, 0, 0, 0, 0, 0
a209 13
/* The ABI to use.  */
enum mips_abi_level
{
  NO_ABI = 0,
  O32_ABI,
  O64_ABI,
  N32_ABI,
  N64_ABI,
  EABI_ABI
};

static enum mips_abi_level mips_abi = NO_ABI;

a216 6
/* True if -mgp32 was passed.  */
static int mips_gp32 = 0;

/* True if -mfp32 was passed.  */
static int mips_fp32 = 0;

d240 2
a241 2
    (mips_gp32                                     \
     || mips_abi == O32_ABI                        \
d245 2
a246 2
    (mips_fp32                                     \
     || mips_abi == O32_ABI                        \
d252 1
a252 1
#define HAVE_NEWABI (mips_abi == N32_ABI || mips_abi == N64_ABI)
d254 1
a254 1
#define HAVE_64BIT_OBJECTS (mips_abi == N64_ABI)
d1135 1
a1135 1
      && mips_abi == EABI_ABI)
d1149 3
d9817 1
a9817 1
      mips_abi = O32_ABI;
d9821 1
a9821 1
      mips_abi = N32_ABI;
d9825 1
a9825 1
      mips_abi = N64_ABI;
d9831 3
a9833 3
      mips_gp32 = 1;
      if (mips_abi != O32_ABI)
	mips_abi = NO_ABI;
d9837 3
a9839 3
      mips_gp32 = 0;
      if (mips_abi == O32_ABI)
	mips_abi = NO_ABI;
d9843 3
a9845 3
      mips_fp32 = 1;
      if (mips_abi != O32_ABI)
	mips_abi = NO_ABI;
d9850 1
a9850 1
	mips_abi = O32_ABI;
d9852 1
a9852 1
	mips_abi = O64_ABI;
d9854 1
a9854 1
	mips_abi = N32_ABI;
d9857 1
a9857 1
	  mips_abi = N64_ABI;
d9863 1
a9863 1
	mips_abi = EABI_ABI;
d9865 1
a9865 1
	mips_abi = NO_ABI;
a11019 4
      static int saved_mips_gp32;
      static int saved_mips_fp32;
      static enum mips_abi_level saved_mips_abi;
      static int is_saved;
d11027 3
a11029 4
	mips_gp32 = saved_mips_gp32;
	mips_fp32 = saved_mips_fp32;
	mips_abi = saved_mips_abi;
	is_saved = 0;
d11034 2
a11035 9
	if (! is_saved)
	  {
	    saved_mips_gp32 = mips_gp32;
	    saved_mips_fp32 = mips_fp32;
	    saved_mips_abi = mips_abi;
	  }
	mips_gp32 = 1;
	mips_fp32 = 1;
	is_saved = 1;
d11041 5
a11045 10
	if (! is_saved)
	  {
	    saved_mips_gp32 = mips_gp32;
	    saved_mips_fp32 = mips_fp32;
	    saved_mips_abi = mips_abi;
	  }
	mips_gp32 = 0;
	mips_fp32 = 0;
	mips_abi = NO_ABI;
	is_saved = 1;
d11048 1
a11048 1
	as_bad (_("unknown ISA level"));
d11062 1
a11062 1
      default: as_bad (_("unknown ISA level")); break;
d12475 1
a12475 1
  if (mips_abi == NO_ABI)
d12477 1
a12477 1
  else if (mips_abi == O32_ABI)
d12479 1
a12479 1
  else if (mips_abi == O64_ABI)
d12481 1
a12481 1
  else if (mips_abi == EABI_ABI)
d12488 1
a12488 1
  else if (mips_abi == N32_ABI)
@


1.89
log
@2001-11-06  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>

	* config/tc-mips.c (my_getSmallParser): Fix small parser bug.
@
text
@a10151 7
  if (HAVE_NEWABI
      && S_GET_SEGMENT (fixp->fx_addsy) == bfd_abs_section_ptr
      && (fixp->fx_r_type == BFD_RELOC_MIPS_SUB
	  || fixp->fx_r_type == BFD_RELOC_HI16_S
	  || fixp->fx_r_type == BFD_RELOC_LO16))
    return 1;

@


1.88
log
@[ bfd/ChangeLog ]
2001-10-31  Chris Demetriou  <cgd@@demetriou.com>

	* elf32-mips.c (_bfd_mips_elf_hi16_reloc): Handle PC-relative
	relocations properly.

[ gas/ChangeLog ]
2001-10-31  Chris Demetriou  <cgd@@broadcom.com>

	* config/tc-mips.c (HAVE_32BIT_ADDRESSES): If compiling embedded
	PIC code, assume pointers the same size as GPRs.
	(macro): In M_LA_AB handling for embedded PIC code, support
	"la $treg,foo-bar($breg)".  In load/store handling
	(label ld_st) support "<op> $treg,<sym>-<local_sym>($breg)"
	which is used by the compiler for switch statements.
	In load/store double multi-instruction macro handling
	(label ldd_std) add a comment that no special handling
	is currently done for embedded PIC.
	(mips_ip): In 'o' (16-bit offset) case, only accept 16
	bit offsets.

[ gas/testsuite/ChangeLog ]
2001-10-31  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/empic.s: Undo damage inflicted on 2000-12-02.
	* gas/mips/empic.d: Likewise.
	* gas/mips/elempic.d: Likewise (it was copied into other files).
	* gas/mips/telempic.d: Likewise.
	* gas/mips/tempic.d: Likewise.

	* gas/mips/empic2.s: New test to check new 'la' and 'lw' (and
	related ops) syntax, test loads with large offsets.
	* gas/mips/emcic2.d: Likewise.
	* gas/mips/mips.exp: Run the new test on ELF platforms.
@
text
@d3554 1
a3554 1
	 
d3562 1
a3562 1
       
d4524 1
a4524 1
	 
d4532 1
a4532 1
       
d5313 1
a5313 1
      if (mips_pic == EMBEDDED_PIC 
d5378 1
a5378 1
	   
d5460 1
a5460 1
		  
d9220 3
a9222 3
      else
        /* Some other expression in the braces.  */
        *len = strcspn (*str, ")") + 1;
d9276 1
a9276 1
	
d10184 1
a10184 1
	  || fixP->fx_r_type == BFD_RELOC_MIPS_LITERAL 
d11340 1
a11340 1
   
@


1.87
log
@2001-10-24  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (hilo_interlocks, cop_interlocks): Make
        these evaluate to true if mips_arch indicates SB-1.
@
text
@d249 5
a253 4
#define HAVE_32BIT_ADDRESSES                       \
   (HAVE_32BIT_GPRS                                \
    || bfd_arch_bits_per_address (stdoutput) == 32 \
    || ! HAVE_64BIT_OBJECTS)
d4451 11
d4464 2
a4465 1
	   la	$4,foo-bar
a4479 1
	  && breg == 0
d4483 15
a4497 2
	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
		       treg, (int) BFD_RELOC_PCREL_HI16_S);
d4500 4
a4503 2
		       "t,r,j", treg, treg, (int) BFD_RELOC_PCREL_LO16);
	  return;
a4512 11
      if (treg == breg)
	{
	  tempreg = AT;
	  used_at = 1;
	}
      else
	{
	  tempreg = treg;
	  used_at = 0;
	}

d5308 40
d5952 5
d8280 1
a8280 9
		 code pattern.  As a special hack, we accept the
		 difference of two local symbols as a constant.  This
		 is required to suppose embedded PIC switches, which
		 use an instruction which looks like
		     lw $4,$L12-$LS12($4)
		 The problem with handling this in a more general
		 fashion is that the macro function doesn't expect to
		 see anything which can be handled in a single
		 constant instruction.  */
d8284 1
a8284 5
		      || offset_expr.X_add_number < -0x8000)
		  && (mips_pic != EMBEDDED_PIC
		      || offset_expr.X_op != O_subtract
		      || (S_GET_SEGMENT (offset_expr.X_add_symbol)
			  != S_GET_SEGMENT (offset_expr.X_op_symbol))))
@


1.86
log
@2001-10-20  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (md_show_usage): Print "sb1" for Broadcom
        SB-1 CPU for consistency.
        (mips_cpu_info_table): Tweak comment about SB-1.
@
text
@d261 1
d274 1
@


1.85
log
@	* bit_fix.h: Comment typo fix.
	* config/tc-mips.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-arc.c (arc_code_symbol): Remove unnecessary test.
@
text
@d9898 1
a9898 1
  show (stream, "sb-1", &column, &first);
d12984 1
a12984 1
  /* SiByte SB-1 CPU */
@


1.84
log
@	* config/tc-mips.c (md_apply_fix): Preliminary handling of NewABI
	relocations.
@
text
@d11118 1
a11118 1
  /* .cpload should be in .set noreorder section.  */
@


1.83
log
@	* config/tc-alpha.c: Fix comment typos.
	* config/tc-cris.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mn10200.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d10242 15
@


1.82
log
@	* config/tc-mips.c (mips_cpreturn_offset): New variable.
	(mips_cpreturn_register): Likewise.
	(mips_gp_register): Likewise.
	(s_cpsetup): New function prototype.
	(s_cplocal): Likewise.
	(s_cpreturn): Likewise.
	(s_gpvalue): Likewise.
	(mips_pseudo_table): Add .cpsetup, .cplocal, .cpreturn, .gpvalue
	pseudo-ops.
	(macro): Don't warn about .cprestore for NewABI.
	(md_pcrel_from): Code cleanup.
	(mips_force_relocation): Force output of some NewABI relocations even
	without a defined symbol.
	(s_cpload): Ignore .cpload for NewABI.
	(s_cpsetup): Handle .cpsetup.
	(s_cplocal): Handle .cplocal.
	(s_cprestore): Ignore .cprestore for NewABI.
	(s_cpreturn): Handle .cpreturn.
	(s_gpvalue): Handle .gpvalue.
	(s_cpadd): Ignore .cpadd for NewABI.
	(nopic_need_relax): Take g_switch_value into account as gp
	optimization.
	(tc_gen_reloc): Don't handle BFD_RELOC_MIPS_{CALL,GOT}* for NewABI.
@
text
@d314 1
a314 1
   by a assembling two single width halves into two single width floating
d1995 1
a1995 1
	      /* These relocations can have a addend that won't fit in
d2041 1
a2041 1
		  /* These relocations can have a addend that won't fit in
d2073 1
a2073 1
		      /* These relocations can have a addend that won't fit in
d7515 2
a7516 2
	       * than 31 or less than 0 the the shift amount should be
	       * mod 32. In reality the mips assembler issues an error.
d9238 1
a9238 1
      /* Don't try to get a expression if it is already blanked out.  */
d10660 1
a10660 1
     for a obj_section_change_hook macro, but that might be confusing
d11103 1
a11103 1
  /* .cpload should be a in .set noreorder section.  */
@


1.81
log
@	* config/tc-mips.c (my_getSmallParser): New function prototype.
	(small_ex_type): Named this enum, more return values for
	my_getSmallExpression.
	(mips_ip): Allow SPC and HT between arguments. Handle some NewABI
	triple relocations. Protect some parts with ifdef OBJ_ELF.
	(percent_op_match): New struct, lookup table for %some_reloc().
	(my_getSmallParser): New function, parses nested percent_ops also.
	(my_getSmallExpression): Rewite to support nested percent_ops.
@
text
@d396 7
d700 2
d703 2
d793 2
d796 2
d4985 1
a4985 3
	  if (mips_cprestore_offset < 0)
	    as_warn (_("No .cprestore pseudo-op used in PIC code"));
	  else
d4987 9
a4995 4
	      expr1.X_add_number = mips_cprestore_offset;
	      macro_build ((char *) NULL, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", GP, (int) BFD_RELOC_LO16, mips_frame_reg);
d5088 1
a5088 3
	  if (mips_cprestore_offset < 0)
	    as_warn (_("No .cprestore pseudo-op used in PIC code"));
	  else
d5090 6
a5095 2
	      if (mips_opts.noreorder)
		macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
d5097 5
a5101 5
	      expr1.X_add_number = mips_cprestore_offset;
	      macro_build ((char *) NULL, &icnt, &expr1,
			   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
			   "t,o(b)", GP, (int) BFD_RELOC_LO16,
			   mips_frame_reg);
d9953 2
d9956 1
a9956 5
	{
	  /* This makes a branch to an undefined symbol be a branch to the
	     current location.  */
	  return 4;
	}
d9958 1
a9958 3
	{
	  return 1;
	}
d10101 7
d11095 3
a11097 2
  /* If we are not generating SVR4 PIC code, .cpload is ignored.  */
  if (mips_pic != SVR4_PIC)
d11125 113
d11249 3
a11251 2
  /* If we are not generating SVR4 PIC code, .cprestore is ignored.  */
  if (mips_pic != SVR4_PIC)
d11271 59
d11380 3
a11382 2
  /* This is ignored when not generating SVR4 PIC code.  */
  if (mips_pic != SVR4_PIC)
d11562 1
a11562 1
  if (USE_GLOBAL_POINTER_OPT)
d12033 2
a12034 1
	  || fixp->fx_r_type == BFD_RELOC_MIPS_CALL_LO16))
@


1.80
log
@	* config/tc-mips.c
	(load_address): Support both 32- and 64-bit addresses.
	(macro): Call load_register correctly. Expand 64-bit loads ans stores.
	(macro2): Call load_address correctly.
@
text
@d678 3
a680 2
static int my_getSmallExpression PARAMS ((expressionS * ep, char *str));
static void my_getExpression PARAMS ((expressionS * ep, char *str));
d713 1
a713 1
/* Return values of my_getSmallExpression() */
d715 1
a715 1
enum
d718 5
d724 9
a732 1
  S_EX_HI,
d735 2
a736 2
  S_EX_GPREL,
  S_EX_NEG
d7443 1
a7443 2
	  if (*s == ' ')
	    ++s;
d8101 1
d8106 20
d8246 1
d8254 20
d9075 115
d9196 1
a9196 2
  char *sp;
  char *oldstr = str;
d9198 3
d9202 5
a9206 70
  if (*str == ' ')
    str++;
  if (*str == '(')
    c = S_EX_NONE;
  else if (str[0] == '%'
	   && TOLOWER (str[1]) == 'l'
	   && TOLOWER (str[2]) == 'o'
	   && str[3] == '(')
    {
      c = S_EX_LO;
      str += sizeof ("%lo(") - 2;
    }
  else if (str[0] == '%'
	   && TOLOWER (str[1]) == 'h'
	   && TOLOWER (str[2]) == 'i'
	   && str[3] == '(')
    {
      c = S_EX_HI;
      str += sizeof ("%hi(") - 2;
    }
  else if (str[0] == '%'
	   && TOLOWER (str[1]) == 'h'
	   && TOLOWER (str[2]) == 'i'
	   && TOLOWER (str[3]) == 'g'
	   && TOLOWER (str[4]) == 'h'
	   && TOLOWER (str[5]) == 'e'
	   && TOLOWER (str[6]) == 'r'
	   && str[7] == '(')
    {
      c = S_EX_HIGHER;
      str += sizeof ("%higher(") - 2;
    }
  else if (str[0] == '%'
	   && TOLOWER (str[1]) == 'h'
	   && TOLOWER (str[2]) == 'i'
	   && TOLOWER (str[3]) == 'g'
	   && TOLOWER (str[4]) == 'h'
	   && TOLOWER (str[5]) == 'e'
	   && TOLOWER (str[6]) == 's'
	   && TOLOWER (str[7]) == 't'
	   && str[8] == '(')
    {
      c = S_EX_HIGHEST;
      str += sizeof ("%highest(") - 2;
    }
/* currently unsupported */
#if 0
  else if (str[0] == '%'
	   && TOLOWER (str[1]) == 'g'
	   && TOLOWER (str[2]) == 'p'
	   && TOLOWER (str[3]) == '_'
	   && TOLOWER (str[4]) == 'r'
	   && TOLOWER (str[5]) == 'e'
	   && TOLOWER (str[6]) == 'l'
	   && str[7] == '(')
    {
      c = S_EX_GPREL;
      str += sizeof ("%gp_rel(") - 2;
    }
  else if (str[0] == '%'
	   && TOLOWER (str[1]) == 'n'
	   && TOLOWER (str[2]) == 'e'
	   && TOLOWER (str[3]) == 'g'
	   && str[4] == '(')
    {
      c = S_EX_NEG;
      str += sizeof ("%neg(") - 2;
    }
#endif
  else
d9208 4
a9211 2
      my_getExpression (ep, str);
      return c;
d9213 1
d9215 2
a9216 9
  /*
   * A small expression may be followed by a base register.
   * Scan to the end of this operand, and then back over a possible
   * base register.  Then scan the small expression up to that
   * point.  (Based on code in sparc.c...)
   */
  for (sp = str; *sp && *sp != ','; sp++)
    ;
  if (sp - 4 >= str && sp[-1] == ')')
d9218 2
a9219 1
      if (ISDIGIT (sp[-2]))
d9221 6
a9226 7
	  for (sp -= 3; sp >= str && ISDIGIT (*sp); sp--)
	    ;
	  if (*sp == '$' && sp > str && sp[-1] == '(')
	    {
	      sp--;
	      goto do_it;
	    }
d9228 1
a9228 7
      else if (sp - 5 >= str
	       && sp[-5] == '('
	       && sp[-4] == '$'
	       && ((sp[-3] == 'f' && sp[-2] == 'p')
		   || (sp[-3] == 's' && sp[-2] == 'p')
		   || (sp[-3] == 'g' && sp[-2] == 'p')
		   || (sp[-3] == 'a' && sp[-2] == 't')))
d9230 8
a9237 27
	  sp -= 5;
	do_it:
	  if (sp == str)
	    {
	      /* no expression means zero offset */
	      if (c != S_EX_NONE)
		{
		  /* %xx(reg) is an error */
		  ep->X_op = O_absent;
		  expr_end = oldstr;
		}
	      else
		{
		  ep->X_op = O_constant;
		  expr_end = sp;
		}
	      ep->X_add_symbol = NULL;
	      ep->X_op_symbol = NULL;
	      ep->X_add_number = 0;
	    }
	  else
	    {
	      *sp = '\0';
	      my_getExpression (ep, str);
	      *sp = '(';
	    }
	  return c;
d9239 1
d9241 19
a9259 1
  my_getExpression (ep, str);
a9260 1
  /* => %highest, %higher, %hi, %lo, %gprel, %neg encountered */
@


1.79
log
@	* config/tc-mips.c (prev_insn_reloc_type): Make it an array to hold a
	relocation triple.
	(prev_insn_fixp): Likewise.
	(append_insn): Changed prototype to accept a relocation pointer.
	(imm_reloc): Make it an array.
	(offset_reloc): Likewise.
	(md_assemble): Handle triple relocations.
	(append_insn): Likewise. Add handling for some NewABI relocations.
	(mips_no_prev_insn): Handle triple relocations.
	(macro_build): Likewise. Add handling for some NewABI relocations.
	Move handling for the 'u' case to append_insn().
	(mips16_macro_build): Handle triple relocations.
	(macro_build_lui): Likewise. Don't handle _gp_disp as special symbol
	for NewABI.
	(mips_ip): Handle triple relocations.
	(mips16_ip): Likewise.
	(mips_force_relocation): Force handling of triple relocations
	without symbols for NewABI.
	(md_apply_fix): Add handling for some NewABI relocations.
@
text
@d666 1
a666 1
static void load_address PARAMS ((int *counter, int reg, expressionS *ep));
d3492 1
a3492 1
load_address (counter, reg, ep)
d3496 2
d3510 1
a3510 1
      load_register (counter, reg, ep, 0);
d3521 58
a3578 4
	 If we have an addend, we always use the latter form.  */
      if ((valueT) ep->X_add_number > MAX_GPREL_OFFSET
	  || nopic_need_relax (ep->X_add_symbol, 1))
	p = NULL;
d3581 17
a3597 2
	  frag_grow (20);
	  macro_build ((char *) NULL, counter, ep,
d3599 2
a3600 12
		       "t,r,j", reg, GP, (int) BFD_RELOC_MIPS_GPREL);
	  p = frag_var (rs_machine_dependent, 8, 0,
			RELAX_ENCODE (4, 8, 0, 4, 0,
				      mips_opts.warn_about_macros),
			ep->X_add_symbol, (offsetT) 0, (char *) NULL);
	}
      macro_build_lui (p, counter, ep, reg);
      if (p != NULL)
	p += 4;
      macro_build (p, counter, ep,
		   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
d3865 1
a3865 1
      load_register (&icnt, AT, &imm_expr, 0);
d4470 1
a4470 1
	  /* If this is a reference to an GP relative symbol, we want
d4476 21
a4496 5
	     so we may as well always use the latter form.  */
	  if ((valueT) offset_expr.X_add_number > MAX_GPREL_OFFSET
	      || nopic_need_relax (offset_expr.X_add_symbol, 1))
	    p = NULL;
	  else
d4498 57
a4554 16
	      frag_grow (20);
	      macro_build ((char *) NULL, &icnt, &offset_expr,
			   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
			   "t,r,j", tempreg, GP, (int) BFD_RELOC_MIPS_GPREL);
	      p = frag_var (rs_machine_dependent, 8, 0,
			    RELAX_ENCODE (4, 8, 0, 4, 0,
					  mips_opts.warn_about_macros),
			    offset_expr.X_add_symbol, (offsetT) 0,
			    (char *) NULL);
	    }
	  macro_build_lui (p, &icnt, &offset_expr, tempreg);
	  if (p != NULL)
	    p += 4;
	  macro_build (p, &icnt, &offset_expr,
		       HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
		       "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
d5285 84
a5368 1
	     With a constant we always use the latter case.  */
d6821 2
a6822 1
      load_address (&icnt, AT, &offset_expr);
d6843 2
a6844 1
      load_address (&icnt, AT, &offset_expr);
d6916 2
a6917 1
      load_address (&icnt, AT, &offset_expr);
d6937 2
a6938 1
      load_address (&icnt, AT, &offset_expr);
@


1.78
log
@	* config/tc-mips.c (mips_64): Remove.
	(mips_target_format): Move downwards in file, use HAVE_64BIT_OBJECTS
	in it.
	(mips_abi_level, mips_abi): New enum.
	(mips_32bit_abi): Remove.
	(HAVE*PRS): Use mips_abi instead of mips_32bit_abi.
	(HAVE_NEWABI): New define.
	(HAVE_64BIT_OBJECTS): New define.
	(HAVE_32BIT_ADDRESSES): Don't return true for 64bit objects.
	(HAVE_64BIT_ADDRESSES): New define, inverse of HAVE_32BIT_ADDRESSES.
	(support_64bit_objects): New prototype.
	(md_begin): Use mips_abi instead of mips_32bit_abi. Don't write
	.reginfo section for n32, use .MIPS.options instead.
	(support_64bit_objects): New function, code from md_parse_option.
	(md_longopts): Add -n32 option.
	(md_parse_option): Use mips_abi instead of mips_32bit_abi/mips64.
	Add -n32 option. Protect with OBJ_ELF.
	(s_mipsset): Use mips_abi instead of mips_32bit_abi.
	(mips_elf_final_processing): Likewise. Don't write .reginfo section
	for n32, use .MIPS.options instead.
@
text
@d433 1
a433 1
static bfd_reloc_code_real_type prev_insn_reloc_type;
d436 1
a436 1
static fixS *prev_insn_fixp;
d646 1
a646 1
				 bfd_reloc_code_real_type r,
d871 4
a874 2
static bfd_reloc_code_real_type imm_reloc;
static bfd_reloc_code_real_type offset_reloc;
d1308 2
a1311 1
  imm_reloc = BFD_RELOC_UNUSED;
d1314 6
a1319 1
  offset_reloc = BFD_RELOC_UNUSED;
d1351 1
a1351 1
	append_insn ((char *) NULL, &insn, NULL, BFD_RELOC_UNUSED, false);
d1503 1
a1503 1
     bfd_reloc_code_real_type reloc_type;
d1508 1
a1508 1
  fixS *fixp;
d1854 1
a1854 1
  if (reloc_type > BFD_RELOC_UNUSED)
d1859 1
a1859 1
		    RELAX_MIPS16_ENCODE (reloc_type - BFD_RELOC_UNUSED,
d1863 1
a1863 1
					 (prev_insn_reloc_type
d1872 1
a1872 1
	   && reloc_type != BFD_RELOC_MIPS16_JMP)
d1889 2
a1890 2
  fixp = NULL;
  if (address_expr != NULL && reloc_type < BFD_RELOC_UNUSED)
d1894 3
a1896 1
	  switch (reloc_type)
d1902 20
d1957 1
a1957 2
	  /* Don't generate a reloc if we are writing into a variant
	     frag.  */
d1960 27
a1986 5
	      fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 4,
				  address_expr,
				  (reloc_type == BFD_RELOC_16_PCREL
				   || reloc_type == BFD_RELOC_16_PCREL_S2),
				  reloc_type);
d1991 1
a1991 1
		  assert (reloc_type == BFD_RELOC_HI16_S);
d1994 1
a1994 1
		  hi_fixup->fixp = fixp;
d1999 67
d2072 1
a2072 1
  else if (reloc_type == BFD_RELOC_MIPS16_JMP)
d2356 1
a2356 1
	      || (mips_opts.mips16 && prev_insn_fixp)
d2382 21
a2402 1
		  if (prev_insn_fixp)
d2404 2
a2405 2
		      prev_insn_fixp->fx_frag = frag_now;
		      prev_insn_fixp->fx_where = f - frag_now->fr_literal;
d2407 1
a2407 1
		  if (fixp)
d2409 2
a2410 2
		      fixp->fx_frag = prev_insn_frag;
		      fixp->fx_where = prev_insn_where;
d2418 3
a2420 1
		  assert (prev_insn_fixp == NULL);
d2424 1
a2424 1
		  if (reloc_type != BFD_RELOC_MIPS16_JMP)
d2426 1
a2426 1
		      assert (reloc_type == BFD_RELOC_UNUSED);
d2434 1
a2434 1
		  if (fixp)
d2436 12
a2447 2
		      fixp->fx_frag = prev_insn_frag;
		      fixp->fx_where = prev_insn_where;
d2465 6
a2470 2
	  prev_insn_fixp = NULL;
	  prev_insn_reloc_type = BFD_RELOC_UNUSED;
d2483 6
a2488 2
	  prev_insn_fixp = NULL;
	  prev_insn_reloc_type = BFD_RELOC_UNUSED;
d2505 6
a2510 2
	  prev_insn_fixp = fixp;
	  prev_insn_reloc_type = reloc_type;
d2513 1
a2513 1
				  || reloc_type > BFD_RELOC_UNUSED);
d2529 3
a2531 1
      prev_insn_reloc_type = reloc_type;
d2571 3
a2573 1
  prev_insn_reloc_type = BFD_RELOC_UNUSED;
d2713 1
a2713 1
  bfd_reloc_code_real_type r;
d2740 3
a2742 1
  r = BFD_RELOC_UNUSED;
d2841 10
a2850 8
	  r = (bfd_reloc_code_real_type) va_arg (args, int);
	  assert (r == BFD_RELOC_MIPS_GPREL
		  || r == BFD_RELOC_MIPS_LITERAL
		  || r == BFD_RELOC_LO16
		  || r == BFD_RELOC_MIPS_GOT16
		  || r == BFD_RELOC_MIPS_CALL16
		  || r == BFD_RELOC_MIPS_GOT_LO16
		  || r == BFD_RELOC_MIPS_CALL_LO16
d2852 1
a2852 1
		      && r == BFD_RELOC_PCREL_LO16));
d2856 1
a2856 1
	  r = (bfd_reloc_code_real_type) va_arg (args, int);
d2860 6
a2865 4
			  && (r == BFD_RELOC_HI16_S
			      || r == BFD_RELOC_HI16
			      || r == BFD_RELOC_MIPS_GOT_HI16
			      || r == BFD_RELOC_MIPS_CALL_HI16))
d2867 1
a2867 7
			  && r == BFD_RELOC_PCREL_HI16_S)));
	  if (ep->X_op == O_constant)
	    {
	      insn.insn_opcode |= (ep->X_add_number >> 16) & 0xffff;
	      ep = NULL;
	      r = BFD_RELOC_UNUSED;
	    }
d2886 1
a2886 1
	      r = BFD_RELOC_16_PCREL_S2;
d2888 1
a2888 1
	      r = BFD_RELOC_16_PCREL;
d2893 1
a2893 1
	  r = BFD_RELOC_MIPS_JMP;
d2906 1
a2906 1
  assert (r == BFD_RELOC_UNUSED ? ep == NULL : ep != NULL);
d2921 2
a2922 1
  bfd_reloc_code_real_type r;
a2923 1
  r = BFD_RELOC_UNUSED;
d3012 1
a3012 1
	      r = BFD_RELOC_UNUSED + c;
d3019 1
a3019 1
		r = BFD_RELOC_UNUSED;
d3032 1
a3032 1
  assert (r == BFD_RELOC_UNUSED ? ep == NULL : ep != NULL);
d3049 2
a3050 1
  bfd_reloc_code_real_type r;
d3069 1
a3069 1
      r = BFD_RELOC_UNUSED;
d3071 1
a3071 1
  else
d3077 1
a3077 1
      r = BFD_RELOC_HI16_S;
d3097 1
a3097 1
  if (r == BFD_RELOC_UNUSED)
d7662 1
a7662 1
	      imm_reloc = BFD_RELOC_32;
d7874 1
a7874 1
	      imm_reloc = BFD_RELOC_LO16;
d7884 1
a7884 1
			  imm_reloc = BFD_RELOC_MIPS_HIGHEST;
d7886 1
a7886 1
			  imm_reloc = BFD_RELOC_MIPS_HIGHER;
d7889 1
a7889 1
			  imm_reloc = BFD_RELOC_HI16_S;
d7893 1
a7893 1
			imm_reloc = BFD_RELOC_HI16;
d7984 1
a7984 1
	      offset_reloc = BFD_RELOC_LO16;
d7990 1
a7990 1
		offset_reloc = BFD_RELOC_16_PCREL_S2;
d7992 1
a7992 1
		offset_reloc = BFD_RELOC_16_PCREL;
d7999 1
a7999 1
	      imm_reloc = BFD_RELOC_LO16;
d8008 1
a8008 1
			  imm_reloc = BFD_RELOC_MIPS_HIGHEST;
d8011 1
a8011 1
			  imm_reloc = BFD_RELOC_HI16_S;
d8015 1
a8015 1
			imm_reloc = BFD_RELOC_HI16;
d8030 1
a8030 1
	      offset_reloc = BFD_RELOC_MIPS_JMP;
d8173 3
a8175 1
      imm_reloc = BFD_RELOC_UNUSED;
d8177 3
a8179 1
      offset_reloc = BFD_RELOC_UNUSED;
d8199 1
a8199 1
		      && imm_reloc > BFD_RELOC_UNUSED
d8203 1
a8203 1
				    imm_reloc - BFD_RELOC_UNUSED,
d8208 1
a8208 1
		      imm_reloc = BFD_RELOC_UNUSED;
d8433 1
a8433 1
		      imm_reloc = BFD_RELOC_MIPS16_GPREL;
d8460 1
a8460 1
		      imm_reloc = (int) BFD_RELOC_UNUSED + c;
d8468 1
a8468 1
	      imm_reloc = (int) BFD_RELOC_UNUSED + c;
d8486 1
a8486 1
	      offset_reloc = (int) BFD_RELOC_UNUSED + c;
d8508 1
a8508 1
	      offset_reloc = BFD_RELOC_MIPS16_JMP;
d9764 4
a9767 1
   to keep relocations for switch table entries.  */
d9777 7
d9804 7
d9812 7
@


1.77
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@a104 36
/* 1 is we should use the 64 bit MIPS ELF ABI, 0 if we should use the
   32 bit ABI.  This has no meaning for ECOFF.
   Note that the default is always 32 bit, even if "configured" for
   64 bit [e.g. --target=mips64-elf].  */
static int mips_64;

/* The default target format to use.  */

const char *
mips_target_format ()
{
  switch (OUTPUT_FLAVOR)
    {
    case bfd_target_aout_flavour:
      return target_big_endian ? "a.out-mips-big" : "a.out-mips-little";
    case bfd_target_ecoff_flavour:
      return target_big_endian ? "ecoff-bigmips" : ECOFF_LITTLE_FORMAT;
    case bfd_target_coff_flavour:
      return "pe-mips";
    case bfd_target_elf_flavour:
#ifdef TE_TMIPS
      /* This is traditional mips */
      return (target_big_endian
	      ? (mips_64 ? "elf64-tradbigmips" : "elf32-tradbigmips")
	      : (mips_64 ? "elf64-tradlittlemips" : "elf32-tradlittlemips"));
#else
      return (target_big_endian
	      ? (mips_64 ? "elf64-bigmips" : "elf32-bigmips")
	      : (mips_64 ? "elf64-littlemips" : "elf32-littlemips"));
#endif
    default:
      abort ();
      return NULL;
    }
}

d182 12
a193 2
/* The argument of the -mabi= flag.  */
static char * mips_abi_string = NULL;
a207 3
/* True if the selected ABI is defined for 32-bit registers only.  */
static int mips_32bit_abi = 0;

d230 9
a238 9
#define HAVE_32BIT_GPRS		            \
   (mips_gp32                               \
    || mips_32bit_abi                       \
    || ! ISA_HAS_64BIT_REGS (mips_opts.isa))

#define HAVE_32BIT_FPRS                     \
   (mips_fp32                               \
    || mips_32bit_abi                       \
    || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
d243 12
a254 3
#define HAVE_32BIT_ADDRESSES                \
   (HAVE_32BIT_GPRS                         \
    || bfd_arch_bits_per_address (stdoutput) == 32)
d680 1
d918 33
d1092 1
a1092 2
      && mips_abi_string
      && 0 == strcmp (mips_abi_string, "eabi"))
d1232 1
a1232 1
	if (! mips_64)
d8889 19
d8987 2
a8988 1
#define OPTION_64          (OPTION_ELF_BASE + 4)
d8994 1
d9262 5
a9266 1
      mips_64 = 0;
d9270 3
a9272 19
      {
	const char **list, **l;

	list = bfd_target_list ();
	for (l = list; *l != NULL; l++)
#ifdef TE_TMIPS
	  /* This is traditional mips */
	  if (strcmp (*l, "elf64-tradbigmips") == 0
	      || strcmp (*l, "elf64-tradlittlemips") == 0)
#else
	  if (strcmp (*l, "elf64-bigmips") == 0
	      || strcmp (*l, "elf64-littlemips") == 0)
#endif
	    break;
	if (*l == NULL)
	  as_fatal (_("No compiled in support for 64 bit object file format"));
	free (list);
	mips_64 = 1;
      }
a9273 1
#endif /* OBJ_ELF */
d9277 2
a9278 13

      /* We deliberately don't allow "-gp32" to set the MIPS_32BITMODE
	 flag in object files because to do so would make it
	 impossible to link with libraries compiled without "-gp32".
	 This is unnecessarily restrictive.

	 We could solve this problem by adding "-gp32" multilibs to
	 gcc, but to set this flag before gcc is built with such
	 multilibs will break too many systems.  */

#if 0
      mips_32bitmode = 1;
#endif
d9283 2
a9284 3
#if 0
      mips_32bitmode = 0;
#endif
d9289 2
d9294 12
a9305 8
      if (strcmp (arg, "32") == 0
	  || strcmp (arg, "n32") == 0
	  || strcmp (arg, "64") == 0
	  || strcmp (arg, "o64") == 0
	  || strcmp (arg, "eabi") == 0)
	{
	  mips_abi_string = arg;
	  mips_32bit_abi = (strcmp (arg, "32") == 0);
d9307 4
d9312 1
d9439 3
a9441 2
-32			create 32 bit object file (default)\n\
-64			create 64 bit object file\n"));
d10432 1
a10432 1
      static int saved_mips_32bit_abi;
d10443 1
a10443 1
	mips_32bit_abi = saved_mips_32bit_abi;
d10453 1
a10453 1
	    saved_mips_32bit_abi = mips_32bit_abi;
d10467 1
a10467 1
	    saved_mips_32bit_abi = mips_32bit_abi;
d10471 1
a10471 1
	mips_32bit_abi = 0;
d11686 1
a11686 1
  if (! mips_64)
d11726 1
a11726 1
  if (mips_abi_string == NULL)
d11728 1
a11728 1
  else if (strcmp (mips_abi_string, "32") == 0)
d11730 1
a11730 1
  else if (strcmp (mips_abi_string, "o64") == 0)
d11732 1
a11732 1
  else if (strcmp (mips_abi_string, "eabi") == 0)
d11739 1
a11739 1
  else if (strcmp (mips_abi_string, "n32") == 0)
@


1.76
log
@2001-09-14  Eric Christopher  <echristo@@redhat.com>

	* config/tc-mips.c (md_parse_option): Remove setting mips_64 via
	-mgp32/mgp64.
@
text
@d29 1
a29 2

#include <ctype.h>
d6948 1
a6948 1
  for (s = str; *s != '\0' && !isspace ((unsigned char) *s); ++s)
d6954 1
a6954 1
  if (isspace ((unsigned char) *s))
d6972 3
a6974 1
      for (s = str; *s != '\0' && *s != '.' && !isspace ((unsigned char) *s); ++s)
d7238 1
a7238 1
		  if (isdigit ((unsigned char) s[1]))
d7248 1
a7248 1
		      while (isdigit ((unsigned char) *s));
d7401 2
a7402 1
	      if (s[0] == '$' && s[1] == 'f' && isdigit ((unsigned char) s[2]))
d7412 1
a7412 1
		  while (isdigit ((unsigned char) *s));
d7865 1
a7865 1
	      while (isdigit ((unsigned char) *s));
d7877 1
a7877 1
	      if (isdigit ((unsigned char) *s))
d7886 1
a7886 1
		  while (isdigit ((unsigned char) *s));
d7943 1
a7943 1
  for (s = str; islower ((unsigned char) *s); ++s)
d8076 1
a8076 1
	      if (isdigit ((unsigned char) s[1]))
d8086 1
a8086 1
		  while (isdigit ((unsigned char) *s));
d8357 1
a8357 1
		    while (isdigit ((unsigned char) *s))
d8384 1
a8384 1
			while (isdigit ((unsigned char) *s))
d8646 2
a8647 2
	   && tolower(str[1]) == 'l'
	   && tolower(str[2]) == 'o'
d8654 2
a8655 2
	   && tolower(str[1]) == 'h'
	   && tolower(str[2]) == 'i'
d8662 6
a8667 6
	   && tolower(str[1]) == 'h'
	   && tolower(str[2]) == 'i'
	   && tolower(str[3]) == 'g'
	   && tolower(str[4]) == 'h'
	   && tolower(str[5]) == 'e'
	   && tolower(str[6]) == 'r'
d8674 7
a8680 7
	   && tolower(str[1]) == 'h'
	   && tolower(str[2]) == 'i'
	   && tolower(str[3]) == 'g'
	   && tolower(str[4]) == 'h'
	   && tolower(str[5]) == 'e'
	   && tolower(str[6]) == 's'
	   && tolower(str[7]) == 't'
d8689 6
a8694 6
	   && tolower(str[1]) == 'g'
	   && tolower(str[2]) == 'p'
	   && tolower(str[3]) == '_'
	   && tolower(str[4]) == 'r'
	   && tolower(str[5]) == 'e'
	   && tolower(str[6]) == 'l'
d8701 3
a8703 3
	   && tolower(str[1]) == 'n'
	   && tolower(str[2]) == 'e'
	   && tolower(str[3]) == 'g'
d8726 1
a8726 1
      if (isdigit ((unsigned char) sp[-2]))
d8728 1
a8728 1
	  for (sp -= 3; sp >= str && isdigit ((unsigned char) *sp); sp--)
d10782 1
a10782 1
  else if (isdigit ((unsigned char) *input_line_pointer))
d11801 1
a11801 1
  if (!isdigit ((unsigned char) *input_line_pointer))
d11808 1
a11808 1
	  while (isxdigit ((unsigned char) *input_line_pointer))
d11818 1
a11818 1
	  while (isdigit ((unsigned char) *input_line_pointer))
d11826 1
a11826 1
  if (!isdigit ((unsigned char) *input_line_pointer))
d11833 1
a11833 1
  while (isdigit ((unsigned char) *input_line_pointer))
d11956 1
a11956 1
  if (isdigit ((unsigned char) *input_line_pointer)
@


1.75
log
@	* config/tc-mips.c (append_insn): Don't rightshift BFD_RELOC_16_PCREL.
@
text
@a9253 1
      mips_64 = 0;
a9270 1
      mips_64 = 1;
@


1.74
log
@	* expr.c (expr): Move code setting "retval" to the end of the loop,
	and rearrange for efficiency.  For "PIC code" subtraction, use
	"rightseg" rather than recalculating.  For "symbol OP symbol"
	subtract, set "retval" to absolute_section if symbols in same
	section.
	* symbols.c (resolve_symbol_value): Resolve "sym +/- expr" to an
	O_symbol.  Simplify a +/- b code.  Allow equality and non-equality
	comparisons on symbols from any section.  Allow other comparison
	operators as for subtraction.
	(symbol_equated_reloc_p): New predicate function.
	* symbols.h (symbol_equated_reloc_p): Declare.
	* write.c (adjust_reloc_syms): Use symbol_equated_reloc_p.
	(write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_segment <rs_machine_dependent>): Ensure segment for
	expression syms is set correctly.
	* config/tc-mips.c (md_estimate_size_before_relax): Likewise.
	* config/tc-i386.c (md_assemble <Output jumps>): Don't lose part
	of a complex expression when setting up frag_var.
@
text
@d1902 1
a1902 1
	      ip->insn_opcode |= (address_expr->X_add_number >> 2) & 0xffff;
@


1.73
log
@	Reallow unrestricted use of .set mipsX pseudo-op in gas.
	Update testcases accordingly.
@
text
@d11146 1
a11146 2
      while (symbol_equated_p (sym)
	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
@


1.72
log
@	* elf32-mips.c (mips_elf_calculate_relocation): Fix overflow handling
	of R_MIPS_PC16.

	* config/tc-mips.c (append_insn): Handle BFD_RELOC_16_PCREL.
	(macro_build): Use BFD_RELOC_16_PCREL_S2 only for embedded
	PIC, BFD_RELOC_16_PCREL for the rest.
	(mips_ip): Likewise.
        (md_pcrel_from): return the right offset for the differently shifted
        pcrel relocs.
	(md_apply_fix): Handle BFD_RELOC_16_PCREL.

	* gas/mips/beq.d: Check branches to external labels.
	* gas/mips/beq.s: Likewise.
	* gas/mips/bge.d: Likewise.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.d: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.d: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.d: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/elempic.d: Switch from R_MIPS_GNU_REL16_S2 to R_MIPS_PC16.
	* gas/mips/empic.d: Likewise.
	* gas/mips/empic.s: Likewise.
	* gas/mips/telempic.d: Likewise.
	* gas/mips/tempic.d: Likewise.
@
text
@d10409 4
d10417 41
@


1.71
log
@2001-08-31  Eric Christopher  <echristo@@redhat.com>
	    Jason Eckhardt  <jle@@redhat.com>

	* config/tc-mips.c (mips_cpu_info): Add support for mipsisa32,
	5kc, and 20kc.  Clean up old entries.
@
text
@d1901 4
d1921 2
a1922 1
				  reloc_type == BFD_RELOC_16_PCREL_S2,
d2707 4
a2710 1
	    r = BFD_RELOC_16_PCREL_S2;
d7807 4
a7810 1
	      offset_reloc = BFD_RELOC_16_PCREL_S2;
d9440 10
a9449 3
      /* This makes a branch to an undefined symbol be a branch to the
	 current location.  */
      return 4;
d9686 2
a9687 1
	  if (fixP->fx_r_type != BFD_RELOC_16_PCREL_S2
d9833 7
a9844 4
      if ((value & 0x3) != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("Branch to odd address (%lx)"), (long) value);

@


1.70
log
@	* tc_mips.c (load_address): Reflect change to MAX_GPREL_OFFSET.
	(macro): Reflect change to MAX_GPREL_OFFSET.
@
text
@a9374 1
  show (stream, "mips32-4k", &column, &first);
d12070 1
d12072 6
a12078 4
#if 1
  /* XXX for now, MIPS64 -> MIPS3 because of history */
  { "MIPS64",         1,      ISA_MIPS3,      CPU_R4000 }, /* XXX! */
#else
d12080 1
a12080 3
  { "MIPS64",         1,      ISA_MIPS64,     CPU_MIPS64 },
#endif
  { "mips64isa",      1,      ISA_MIPS64,     CPU_MIPS64 },
d12082 2
a12185 9

  /* MIPS32 4K CPU */
  { "MIPS32-4K",      0,      ISA_MIPS32,     CPU_MIPS32_4K, },
  { "4kc",            0,      ISA_MIPS32,     CPU_MIPS32_4K, },
  { "4km",            0,      ISA_MIPS32,     CPU_MIPS32_4K, },
  { "4kp",            0,      ISA_MIPS32,     CPU_MIPS32_4K, },
  { "mips32-4kc",     0,      ISA_MIPS32,     CPU_MIPS32_4K, },
  { "mips32-4km",     0,      ISA_MIPS32,     CPU_MIPS32_4K, },
  { "mips32-4kp",     0,      ISA_MIPS32,     CPU_MIPS32_4K, },
@


1.69
log
@	* tc_mips.h (MAX_GPREL_OFFSET): Change it to the maximum allowed
	value, not the word beyond maximum.
	* tc_mips.c (macro_build_lui): Code cleanup.
	(macro): Reflect change to MAX_GPREL_OFFSET.
	(mips_ip): Check explicitly against S_EX_NONE.
	(my_get_SmallExpression): parse for %gp_rel, not %gprel.
	(md_apply_fix): Code cleanup.
@
text
@d3333 1
a3333 1
      if ((valueT) ep->X_add_number >= MAX_GPREL_OFFSET
d4229 1
a4229 1
	  if ((valueT) offset_expr.X_add_number >= MAX_GPREL_OFFSET
@


1.68
log
@	* tc_mips.c (md_begin): Warn about incompatibility between -march=FOO
	and -mipsN option, continue with default ISA.
@
text
@d2880 2
a2881 4
      if (high_expr.X_add_number & 0x8000)
	high_expr.X_add_number += 0x10000;
      high_expr.X_add_number =
	((unsigned long) high_expr.X_add_number >> 16) & 0xffff;
d4983 1
a4983 1
	      if ((valueT) offset_expr.X_add_number >= MAX_GPREL_OFFSET
d5008 1
a5008 1
	      if ((valueT) offset_expr.X_add_number >= MAX_GPREL_OFFSET
d5503 1
a5503 1
	  if ((valueT) offset_expr.X_add_number >= MAX_GPREL_OFFSET
d7807 1
a7807 1
	      if (c)
d8678 5
a8682 4
	   && tolower(str[3]) == 'r'
	   && tolower(str[4]) == 'e'
	   && tolower(str[5]) == 'l'
	   && str[6] == '(')
d8685 1
a8685 1
      str += sizeof ("%gprel(") - 2;
d9725 1
a9725 3
      if (value & 0x8000)
	value += 0x10000;
      value >>= 16;
@


1.67
log
@	* config/tc-mips.c (md_parse_option): #ifdef the
	traditional/non-traditional names as it is done in mips_target_format.
@
text
@d1013 17
a1029 1
      /* We have it all.  There's nothing to do.  */
@


1.66
log
@2001-08-18  H.J. Lu  <hjl@@gnu.org>

	* config/tc-mips.c (show): Add the missing prototype.
@
text
@d9209 5
d9215 2
a9216 3
	      || strcmp (*l, "elf64-littlemips") == 0
	      || strcmp (*l, "elf64-tradbigmips") == 0
	      || strcmp (*l, "elf64-tradlittlemips") == 0)
@


1.65
log
@	* config/tc-mips.c (S_EX_*): New enum for my_getSmallExpression()
	return values.
	(mips_ip): Use the new return values instead of characters. Add
	support for %higher and %highest.
	(LP): Remove.
	(RP): Remove.
	(my_getSmallExpression): Make parsing case insensitive and more
	reliable. Add support for %higher and %highest. Further support	to
	parse %gprel and %neg is implemented but currently deactivated.
@
text
@d730 1
@


1.64
log
@
Set MIPS n32 ABI flag in ELF header if appropriate.
@
text
@d731 13
d7671 1
a7671 1
	      if (c != '\0')
d7673 1
a7673 1
		  if (c != 'l')
d7678 5
a7682 1
		      else if (c == 'h')
d7695 1
a7695 1
		  if ((c == '\0' && imm_expr.X_op != O_constant)
d7728 1
a7728 1
		  if ((c == '\0' && imm_expr.X_op != O_constant)
d7762 1
a7762 1
	      if (c == 0
d7772 1
a7772 1
	      if (c == 'h' || c == 'H')
d7794 1
a7794 1
		  if (c != 'l')
d7799 3
a7801 1
		      else if (c == 'h')
a8602 2
#define LP '('
#define RP ')'
d8610 2
a8611 1
  int c = 0;
d8615 67
a8681 6
  if (*str == LP
      || (*str == '%' &&
	  ((str[1] == 'h' && str[2] == 'i')
	   || (str[1] == 'H' && str[2] == 'I')
	   || (str[1] == 'l' && str[2] == 'o'))
	  && str[3] == LP))
d8683 15
a8697 3
      if (*str == LP)
	c = 0;
      else
d8699 7
a8705 2
	  c = str[1];
	  str += 3;
d8707 14
a8720 32

      /*
       * A small expression may be followed by a base register.
       * Scan to the end of this operand, and then back over a possible
       * base register.  Then scan the small expression up to that
       * point.  (Based on code in sparc.c...)
       */
      for (sp = str; *sp && *sp != ','; sp++)
	;
      if (sp - 4 >= str && sp[-1] == RP)
	{
	  if (isdigit ((unsigned char) sp[-2]))
	    {
	      for (sp -= 3; sp >= str && isdigit ((unsigned char) *sp); sp--)
		;
	      if (*sp == '$' && sp > str && sp[-1] == LP)
		{
		  sp--;
		  goto do_it;
		}
	    }
	  else if (sp - 5 >= str
		   && sp[-5] == LP
		   && sp[-4] == '$'
		   && ((sp[-3] == 'f' && sp[-2] == 'p')
		       || (sp[-3] == 's' && sp[-2] == 'p')
		       || (sp[-3] == 'g' && sp[-2] == 'p')
		       || (sp[-3] == 'a' && sp[-2] == 't')))
	    {
	      sp -= 5;
	    do_it:
	      if (sp == str)
d8722 3
a8724 15
		  /* no expression means zero offset */
		  if (c)
		    {
		      /* %xx(reg) is an error */
		      ep->X_op = O_absent;
		      expr_end = str - 3;
		    }
		  else
		    {
		      ep->X_op = O_constant;
		      expr_end = sp;
		    }
		  ep->X_add_symbol = NULL;
		  ep->X_op_symbol = NULL;
		  ep->X_add_number = 0;
d8728 2
a8729 3
		  *sp = '\0';
		  my_getExpression (ep, str);
		  *sp = LP;
d8731 3
a8733 1
	      return c;
d8735 7
d8745 3
a8747 1
  return c;			/* => %hi or %lo encountered */
@


1.63
log
@
Remove obsolete special handling of 64bit Relocations.
@
text
@d11559 4
@


1.62
log
@	* config/tc-mips.c: Fix a comment typo.
@
text
@a9342 31
/* This is called by emit_expr via TC_CONS_FIX_NEW when creating a
   reloc for a cons.  We could use the definition there, except that
   we want to handle 64 bit relocs specially.  */

void
cons_fix_new_mips (frag, where, nbytes, exp)
     fragS *frag ATTRIBUTE_UNUSED;
     int where;
     unsigned int nbytes;
     expressionS *exp;
{
#ifndef OBJ_ELF
  /* If we are assembling in 32 bit mode, turn an 8 byte reloc into a
     4 byte reloc.  */
  if (nbytes == 8 && ! mips_64)
    {
      if (target_big_endian)
	where += 4;
      nbytes = 4;
    }
#endif

  if (nbytes != 2 && nbytes != 4 && nbytes != 8)
    as_bad (_("Unsupported reloc size %d"), nbytes);

  fix_new_exp (frag_now, where, (int) nbytes, exp, 0,
	       (nbytes == 2
		? BFD_RELOC_16
		: (nbytes == 4 ? BFD_RELOC_32 : BFD_RELOC_64)));
}

@


1.61
log
@	* config/tc-mips.c (move_register): New function.
	(macro_build): Remove OPCODE_IS_MEMBER's gp32 argument.
	(mips_ip): Likewise.
	(macro2): Use move_register rather than macro_build for moves.
	(mips16_macro): Likewise.
	(macro): Likewise.  Handle M_MOVE.
@
text
@d5792 1
a5792 1
      FIXME: Currently, we require that the user handles delays.
@


1.60
log
@
Replace a bunch of magic constants in tc-mips.c with their proper
defines from mips.h.
@
text
@d688 1
d2537 1
a2537 2
	  && OPCODE_IS_MEMBER (insn.insn_mo, mips_opts.isa, mips_arch,
			       HAVE_32BIT_GPRS)
d3433 13
d3519 1
a3519 1
	macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg, sreg, 0);
d4072 1
a4072 2
	    macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg,
			 sreg);
d4074 1
a4074 1
	    macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg, 0);
d4087 1
a4087 1
	    macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg, 0);
d5204 1
a5204 2
		    macro_build ((char *) NULL, &icnt, NULL, "move", "d,s",
				 lreg, 0);
d5822 4
d6057 1
a6057 1
	  macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg, 0);
d6796 1
a6796 2
	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
		     "move", "y,X", xreg, yreg);
d6965 1
a6965 1
      if (OPCODE_IS_MEMBER (insn, mips_opts.isa, mips_arch, HAVE_32BIT_GPRS))
@


1.59
log
@
Some formatting fixes and assorted cleanup in tc-mips.c.
@
text
@d2562 1
a2562 1
	  insn.insn_opcode |= va_arg (args, int) << 16;
d2566 3
d2571 1
a2571 1
	  insn.insn_opcode |= va_arg (args, int) << 16;
d2576 1
a2576 1
	  insn.insn_opcode |= va_arg (args, int) << 11;
d2583 2
a2584 2
	    insn.insn_opcode |= tmp << 16;
	    insn.insn_opcode |= tmp << 11;
d2590 1
a2590 1
	  insn.insn_opcode |= va_arg (args, int) << 11;
d2597 1
a2597 1
	  insn.insn_opcode |= va_arg (args, int) << 6;
d2601 1
a2601 1
	  insn.insn_opcode |= va_arg (args, int) << 6;
d2605 1
a2605 1
	  insn.insn_opcode |= va_arg (args, int) << 6;
d2609 1
a2609 1
	  insn.insn_opcode |= va_arg (args, int) << 6;
d2613 1
a2613 1
	  insn.insn_opcode |= va_arg (args, int) << 6;
d2620 1
a2620 1
	  insn.insn_opcode |= va_arg (args, int) << 21;
d7010 1
a7010 1
		  ip->insn_opcode |= lastregno << 21;
d7014 3
d7018 1
a7018 1
		  ip->insn_opcode |= lastregno << 16;
d7022 1
a7022 1
		  ip->insn_opcode |= lastregno << 11;
d7056 1
a7056 1
		  imm_expr.X_add_number = imm_expr.X_add_number & 0x1f;
d7058 1
a7058 1
	      ip->insn_opcode |= imm_expr.X_add_number << 6;
d7069 1
a7069 1
	      ip->insn_opcode |= (imm_expr.X_add_number - 32) << 6;
d7100 1
a7100 1
		  imm_expr.X_add_number &= 0x3ff;
d7102 1
a7102 1
	      ip->insn_opcode |= imm_expr.X_add_number << 16;
d7114 1
a7114 1
		  imm_expr.X_add_number &= 0x3ff;
d7116 1
a7116 1
	      ip->insn_opcode |= imm_expr.X_add_number << 6;
d7124 1
a7124 1
	      if ((unsigned) imm_expr.X_add_number > 0xfffff)
d7127 1
a7127 1
	      ip->insn_opcode |= imm_expr.X_add_number << 6;
d7149 1
a7149 1
	      if ((unsigned) imm_expr.X_add_number > 0x7ffff)
d7152 1
a7152 1
	      ip->insn_opcode |= imm_expr.X_add_number << 6;
d7162 1
a7162 1
		  as_warn (_("Invalidate performance regster (%ld)"),
d7164 1
a7164 1
		  imm_expr.X_add_number &= 1;
d7166 1
a7166 1
	      ip->insn_opcode |= (imm_expr.X_add_number << 1);
d7291 1
a7291 1
		      ip->insn_opcode |= regno << 21;
d7295 1
a7295 1
		      ip->insn_opcode |= regno << 11;
d7298 2
a7299 2
		      ip->insn_opcode |= regno << 11;
		      ip->insn_opcode |= regno << 16;
d7304 1
a7304 1
		      ip->insn_opcode |= regno << 16;
d7335 1
a7335 1
		  ip->insn_opcode |= lastregno << 21;
d7338 1
a7338 1
		  ip->insn_opcode |= lastregno << 16;
d7391 1
a7391 1
		      ip->insn_opcode |= regno << 6;
d7395 1
a7395 1
		      ip->insn_opcode |= regno << 11;
d7399 1
a7399 1
		      ip->insn_opcode |= regno << 16;
d7402 1
a7402 1
		      ip->insn_opcode |= regno << 21;
d7412 1
a7412 1
		  ip->insn_opcode |= lastregno << 11;
d7415 1
a7415 1
		  ip->insn_opcode |= lastregno << 16;
@


1.58
log
@
	* config/tc-mips.c (md_begin): Take -mcpu value into account even when
	-mipsX is specified. Make both -mcpu/-march and -mcpu/-mtune pairs
	mutually exclusive (if they are different).
	(md_parse_option): Warn if an -march/-mtune/-mcpu/-m<cpu> option is
	set more than once.
@
text
@d220 1
a220 1
static char * mips_abi_string = 0;
d604 2
a605 2
#define RELAX_RELOC1(i) ((bfd_vma) (((i) >> 9) & 0x7f) - 64)
#define RELAX_RELOC2(i) ((bfd_vma) (((i) >> 2) & 0x7f) - 64)
d3400 1
a3400 2
      macro_build (p, counter, ep,
		   HAVE_32BIT_ADDRESSES ? "lw" : "ld",
d3405 1
a3405 2
      macro_build (p, counter, ep,
		   HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu",
d3505 1
a3505 2
		   dbl ? "dsub" : "sub",
		   "d,v,t", dreg, 0, sreg);
d3620 1
a3620 2
		   likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d3669 1
a3669 2
		       likely ? "bgezl" : "bgez",
		       "s,p", sreg);
d3675 1
a3675 2
		       likely ? "bgtzl" : "bgtz",
		       "s,p", sreg);
d3699 1
a3699 2
		   likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d3710 1
a3710 2
		       likely ? "beql" : "beq",
		       "s,t,p", 0, treg);
d3716 1
a3716 2
		   likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d3740 1
a3740 2
		       likely ? "bnel" : "bne",
		       "s,t,p", sreg, 0);
d3745 1
a3745 2
		   likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d3754 1
a3754 2
		       likely ? "bgtzl" : "bgtz",
		       "s,p", sreg);
d3760 1
a3760 2
		       likely ? "bltzl" : "bltz",
		       "s,p", treg);
d3765 1
a3765 2
		   likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d3774 1
a3774 2
		       likely ? "bnel" : "bne",
		       "s,t,p", sreg, 0);
d3782 1
a3782 2
		   likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d3791 1
a3791 2
		       likely ? "blezl" : "blez",
		       "s,p", sreg);
d3797 1
a3797 2
		       likely ? "bgezl" : "bgez",
		       "s,p", treg);
d3802 1
a3802 2
		   likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d3831 1
a3831 2
		       likely ? "bltzl" : "bltz",
		       "s,p", sreg);
d3837 1
a3837 2
		       likely ? "blezl" : "blez",
		       "s,p", sreg);
d3842 1
a3842 2
		   likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d3851 1
a3851 2
		       likely ? "beql" : "beq",
		       "s,t,p", sreg, 0);
d3859 1
a3859 2
		   likely ? "beql" : "beq",
		   "s,t,p", AT, 0);
d3889 1
a3889 2
		   likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d3898 1
a3898 2
		       likely ? "bltzl" : "bltz",
		       "s,p", sreg);
d3904 1
a3904 2
		       likely ? "bgtzl" : "bgtz",
		       "s,p", treg);
d3909 1
a3909 2
		   likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d3920 1
a3920 2
		       likely ? "bnel" : "bne",
		       "s,t,p", 0, treg);
d3926 1
a3926 2
		   likely ? "bnel" : "bne",
		   "s,t,p", AT, 0);
d3956 1
a3956 2
		       dbl ? "ddiv" : "div",
		       "z,s,t", sreg, treg);
d3963 1
a3963 2
		       dbl ? "ddiv" : "div",
		       "z,s,t", sreg, treg);
d4068 2
a4069 6
	      if (dbl)
		macro_build ((char *) NULL, &icnt, NULL, "dneg", "d,w", dreg,
			     sreg);
	      else
		macro_build ((char *) NULL, &icnt, NULL, "neg", "d,w", dreg,
			     sreg);
d5778 1
a5778 1
      FIXME: Currently, we require that the user handle delays.
d5888 1
a5888 2
		   dbl ? "dmult" : "mult",
		   "s,t", sreg, AT);
d5908 1
a5908 2
		   dbl ? "dmult" : "mult",
		   "s,t", sreg, imm ? AT : treg);
d5911 1
a5911 2
		   dbl ? "dsra32" : "sra",
		   "d,w,<", dreg, dreg, 31);
d6256 1
a6256 2
		   dbl ? "dsub" : "sub",
		   "d,v,t", dreg, sreg, AT);
d6274 1
a6274 2
		   dbl ? "dsubu" : "subu",
		   "d,v,t", dreg, sreg, AT);
d6631 1
a6631 2
		   dbl ? "dmultu" : "multu",
		   "x,y", xreg, yreg);
d6644 1
a6644 2
		   dbl ? "daddiu" : "addiu",
		   "y,x,4", yreg, xreg);
d9223 1
a9223 1
-g, -g2			do not remove uneeded NOPs or swap branches\n\
d10315 1
a10316 1
      case  4: mips_opts.isa = ISA_MIPS4;       break;
d11053 4
a11056 1
	as_warn (_("AT used after \".set noat\" or macro used after \".set nomacro\""));
d11059 1
a11059 4
  if (! change)
    return 0;
  else
    return RELAX_NEW (fragp->fr_subtype) - RELAX_OLD (fragp->fr_subtype);
d11557 1
a11557 1
  if (mips_abi_string == 0)
d11635 1
a11635 1
    as_warn (_("missing `.end' at end of assembly"));
d11824 1
a11824 1
    as_warn (_("missing `.end'"));
@


1.57
log
@	* config/tc-mips.c (md_apply_fix): Don't subtract the symbol value
	from GPREL addends.
@
text
@d965 27
a1013 13
  else if (mips_arch == CPU_UNKNOWN
	   && mips_opts.isa == ISA_UNKNOWN
	   && mips_cpu != CPU_UNKNOWN)
    {
      /* Historic -mcpu= option.  Warn.  */
      ci = mips_cpu_info_from_cpu (mips_cpu);
      assert (ci != NULL);
      mips_arch = ci->cpu;
      mips_tune = ci->cpu;
      mips_opts.isa = ci->isa;
      as_warn (_("The -mcpu option is deprecated.  Please use -march and -mtune instead."));

    }
d9002 3
d9008 3
d9014 3
d9023 4
d9035 4
d9047 4
d9059 4
@


1.56
log
@	* doc/c-mips.tex (-mgp32, -mfp32): Added -mfp32, unified with -mgp32.
	* config/tc-mips.c (mips_fp32, mips_32bit_abi): New static variables.
	(md_long_opts): Add -mfp32 option.
	(md_parse_option): Handle it.  Set mips_32bit_abi given -mabi=32.
	(md_show_usage): Show usage for -mfp32 and -mgp32.
	(HAVE_32BIT_GPRS, HAVE_32BIT_FPRS): New macros.
	(HAVE_64BIT_GPRS, HAVE_64BIT_FPRS): New macros, inverse of the above.
	(HAVE_32BIT_ADDRESSES): New macro.
	(load_register): Use HAVE_32BIT_GPRS to determine the register width.
	(load_address): Use HAVE_32BIT_ADDRESSES to determine the address size.
	(s_cprestore, s_cpadd): Likewise.
	(macro): Use HAVE_32BIT_GPRS to determine the width of registers
	used in branch and M_LI_D macros.  Use HAVE_64BIT_FPRS to determine
	the width registers used in M_LI_DD macros.  Use HAVE_32BIT_ADDRESSES
	to determine the width of addresses in load, store and jump macros.
	(macro2): Use HAVE_32BIT_GPRS to determine the width of registers
	used in set instructions; do not check the address size for them.
	Use HAVE_32BIT_ADDRESSES to determine the width of addresses in
	unaligned load and store macros.
	(mips_ip): Use the new macros to check the width of a register when
	processing float constants.  Force a constant into memory if it is
	destined for an FPR and the FPRs are wider than the GPRs.  Warn about
	odd FPR numbers if HAVE_32BIT_FPRS.  Use HAVE_32BIT_GPRS rather
	than mips_gp32 to select synthetic instructions.
	(macro_build): Use HAVE_32BIT_GPRS rather than mips_gp32 to select
	synthetic instructions.
@
text
@d9530 3
a9532 1
	  if (value != 0 && ! fixP->fx_pcrel)
@


1.55
log
@2001-07-25  H.J. Lu  <hjl@@gnu.org>

	* config/tc-mips.c (md_estimate_size_before_relax): Make sure
	we treat weak like extern only for ELF.
	(mips_fix_adjustable): Make sure we don't adjust extern/weak
	symbols only for ELF.
@
text
@d232 6
d260 17
d2523 1
a2523 1
			       mips_gp32)
d3034 1
a3034 1
	       || ((! ISA_HAS_64BIT_REGS (mips_opts.isa) || ! dbl)
d3036 1
a3036 1
	       || (! ISA_HAS_64BIT_REGS (mips_opts.isa)
d3053 1
a3053 1
  if (! ISA_HAS_64BIT_REGS (mips_opts.isa))
d3295 1
a3295 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "addiu" : "daddiu"),
d3306 1
a3306 3
		   ((bfd_arch_bits_per_address (stdoutput) == 32
		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		    ? "addiu" : "daddiu"),
d3324 1
a3324 3
		   ((bfd_arch_bits_per_address (stdoutput) == 32
		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		    ? "lw" : "ld"),
d3331 1
a3331 3
		   ((bfd_arch_bits_per_address (stdoutput) == 32
		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		    ? "addiu" : "daddiu"),
d3339 1
a3339 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			? "addiu" : "daddiu"),
d3368 1
a3368 3
		   ((bfd_arch_bits_per_address (stdoutput) == 32
		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		    ? "addu" : "daddu"),
d3371 1
a3371 3
		   ((bfd_arch_bits_per_address (stdoutput) == 32
		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		    ? "lw" : "ld"),
d3387 1
a3387 3
		   ((bfd_arch_bits_per_address (stdoutput) == 32
		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		    ? "lw" : "ld"),
d3393 1
a3393 3
		   ((bfd_arch_bits_per_address (stdoutput) == 32
		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		    ? "addiu" : "daddiu"),
d3401 1
a3401 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
		         || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			? "addiu" : "daddiu"),
d3411 1
a3411 3
		   ((bfd_arch_bits_per_address (stdoutput) == 32
		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		    ? "addiu" : "daddiu"),
d3618 1
a3618 1
      if (ISA_HAS_64BIT_REGS (mips_opts.isa) && sizeof (maxnum) > 4)
d3627 1
a3627 1
	  && (! ISA_HAS_64BIT_REGS (mips_opts.isa) || sizeof (maxnum) > 4))
d3671 1
a3671 1
      if (ISA_HAS_64BIT_REGS (mips_opts.isa) && sizeof (maxnum) > 4)
d3681 1
a3681 1
	  && (! ISA_HAS_64BIT_REGS (mips_opts.isa) || sizeof (maxnum) > 4))
d3718 1
a3718 1
	  || (! ISA_HAS_64BIT_REGS (mips_opts.isa)
d3814 1
a3814 1
      if (ISA_HAS_64BIT_REGS (mips_opts.isa) && sizeof (maxnum) > 4)
d3823 1
a3823 1
	  && (! ISA_HAS_64BIT_REGS (mips_opts.isa) || sizeof (maxnum) > 4))
d3876 1
a3876 1
	  || (! ISA_HAS_64BIT_REGS (mips_opts.isa)
d4174 1
a4174 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
		         || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			? "addiu" : "daddiu"),
d4215 1
a4215 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
		     	     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addiu" : "daddiu"),
d4227 1
a4227 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			? "addiu" : "daddiu"),
d4298 1
a4298 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addiu" : "daddiu"),
d4310 1
a4310 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addiu" : "daddiu"),
d4335 1
a4335 3
			       ((bfd_arch_bits_per_address (stdoutput) == 32
				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
				? "addu" : "daddu"),
d4350 1
a4350 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addiu" : "daddiu"),
d4353 1
a4353 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addu" : "daddu"),
d4423 1
a4423 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			? "addu" : "daddu"),
d4459 1
a4459 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addiu" : "daddiu"),
d4492 1
a4492 3
			       ((bfd_arch_bits_per_address (stdoutput) == 32
				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
				? "addu" : "daddu"),
d4506 1
a4506 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addiu" : "daddiu"),
d4509 1
a4509 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addu" : "daddu"),
d4541 1
a4541 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addiu" : "daddiu"),
d4559 1
a4559 3
			       ((bfd_arch_bits_per_address (stdoutput) == 32
				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
				? "addu" : "daddu"),
d4571 1
a4571 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addiu" : "daddiu"),
d4575 1
a4575 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addu" : "daddu"),
d4586 1
a4586 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			? "addiu" : "daddiu"),
d4594 1
a4594 3
		     ((bfd_arch_bits_per_address (stdoutput) == 32
		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		      ? "addu" : "daddu"),
d4636 1
a4636 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "lw" : "ld"),
d4677 1
a4677 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "lw" : "ld"),
d4698 1
a4698 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addu" : "daddu"),
d4701 1
a4701 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "lw" : "ld"),
d4717 1
a4717 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "lw" : "ld"),
d4725 1
a4725 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			? "addiu" : "daddiu"),
d4739 1
a4739 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "lw" : "ld"),
d4994 1
a4994 3
			       ((bfd_arch_bits_per_address (stdoutput) == 32
				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
				? "addu" : "daddu"),
d5007 1
a5007 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addu" : "daddu"),
d5040 1
a5040 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "lw" : "ld"),
d5048 1
a5048 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "addiu" : "daddiu"),
d5052 1
a5052 3
			 ((bfd_arch_bits_per_address (stdoutput) == 32
			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			  ? "addu" : "daddu"),
d5091 1
a5091 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "addu" : "daddu"),
d5094 1
a5094 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "lw" : "ld"),
d5106 1
a5106 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "lw" : "ld"),
d5112 1
a5112 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "addiu" : "daddiu"),
d5116 1
a5116 3
			 ((bfd_arch_bits_per_address (stdoutput) == 32
			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			  ? "addu" : "daddu"),
d5139 1
a5139 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addu" : "daddu"),
d5183 4
a5186 4
      /* If we have a constant in IMM_EXPR, then in mips3 mode it is
         the entire value, and in mips1 mode it is the high order 32
         bits of the value and the low order 32 bits are either zero
         or in offset_expr.  */
d5189 1
a5189 1
	  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
d5233 1
a5233 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "lw" : "ld"),
d5241 1
a5241 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "addiu" : "daddiu"),
d5250 1
a5250 1
      if (ISA_HAS_64BIT_REGS (mips_opts.isa))
d5275 5
a5279 4
      /* If we have a constant in IMM_EXPR, then in mips3 mode it is
         the entire value, and in mips1 mode it is the high order 32
         bits of the value and the low order 32 bits are either zero
         or in offset_expr.  */
d5282 7
a5288 4
	  load_register (&icnt, AT, &imm_expr, ISA_HAS_64BIT_REGS (mips_opts.isa));
	  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
			 "dmtc1", "t,S", AT, treg);
d5327 1
a5327 3
			 ((bfd_arch_bits_per_address (stdoutput) == 32
			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			  ? "lw" : "ld"),
d5431 1
a5431 1
      if (ISA_HAS_64BIT_REGS (mips_opts.isa))
d5442 1
a5442 1
      if (ISA_HAS_64BIT_REGS (mips_opts.isa))
d5504 1
a5504 3
			       ((bfd_arch_bits_per_address (stdoutput) == 32
				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
				? "addu" : "daddu"),
d5560 1
a5560 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addu" : "daddu"),
d5607 1
a5607 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "lw" : "ld"),
d5612 1
a5612 3
			 ((bfd_arch_bits_per_address (stdoutput) == 32
			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			  ? "addu" : "daddu"),
d5672 1
a5672 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "addu" : "daddu"),
d5675 1
a5675 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "lw" : "ld"),
d5680 1
a5680 3
			 ((bfd_arch_bits_per_address (stdoutput) == 32
			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			  ? "addu" : "daddu"),
d5710 1
a5710 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "lw" : "ld"),
d5718 1
a5718 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addu" : "daddu"),
d5757 1
a5757 3
			   ((bfd_arch_bits_per_address (stdoutput) == 32
			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
			    ? "addu" : "daddu"),
d5787 1
a5787 2
      assert (bfd_arch_bits_per_address (stdoutput) == 32
	      || ! ISA_HAS_64BIT_REGS (mips_opts.isa));
d6081 1
a6081 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "addiu" : "daddiu"),
d6232 1
a6232 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "addiu" : "daddiu"),
d6250 1
a6250 3
		       ((bfd_arch_bits_per_address (stdoutput) == 32
			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		        ? "addiu" : "daddiu"),
d6417 1
a6417 3
		     ((bfd_arch_bits_per_address (stdoutput) == 32
		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		      ? "addu" : "daddu"),
d6438 1
a6438 3
		     ((bfd_arch_bits_per_address (stdoutput) == 32
		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		      ? "addu" : "daddu"),
d6510 1
a6510 3
		     ((bfd_arch_bits_per_address (stdoutput) == 32
		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		      ? "addu" : "daddu"),
d6530 1
a6530 3
		     ((bfd_arch_bits_per_address (stdoutput) == 32
		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		      ? "addu" : "daddu"),
d6977 1
a6977 1
      if (OPCODE_IS_MEMBER (insn, mips_opts.isa, mips_arch, mips_gp32))
d7389 1
a7389 1
		      && ! ISA_HAS_64BIT_REGS (mips_opts.isa)
d7463 1
d7497 6
a7502 1
		    .lit8 entries).  */
d7505 1
d7538 7
d7550 6
a7555 7
		    /* The value is simple enough to load with a
                       couple of instructions.  In mips1 mode, set
                       imm_expr to the high order 32 bits and
                       offset_expr to the low order 32 bits.
                       Otherwise, set imm_expr to the entire 64 bit
                       constant.  */
		    if (! ISA_HAS_64BIT_REGS (mips_opts.isa))
d7726 1
a7726 1
			  && ISA_HAS_64BIT_REGS (mips_opts.isa)
d8851 2
d9155 4
d9165 4
a9168 1
	mips_abi_string = arg;
d9284 2
d10463 1
a10463 3
	       ((bfd_arch_bits_per_address (stdoutput) == 32
		 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		? "sw" : "sd"),
d10529 1
a10529 3
	       ((bfd_arch_bits_per_address (stdoutput) == 32
		 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
		? "addu" : "daddu"),
@


1.54
log
@2001-07-25  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c: Fix spelling error in comment.
@
text
@d11126 2
a11127 1
		&& ! (S_IS_EXTERN (sym) || S_IS_WEAK (sym))
d11167 2
a11168 1
  if (S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
@


1.53
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d222 1
a222 1
/* Wether we should mark the file EABI64 or EABI32.  */
@


1.52
log
@2001-07-22  H.J. Lu <hjl@@gnu.org>

	* config/tc-mips.c (s_mips_end): Remove unused variables.
	(s_mips_frame): Add ATTRIBUTE_UNUSED.
@
text
@d10898 1
a10898 1
  val = S_GET_VALUE (fragp->fr_symbol) + sym_frag->fr_address;
@


1.51
log
@2001-07-04  Eric Christopher  <echristo@@redhat.com>

	* doc/c-mips.texi (MIPS Opts): Document 12000 as valid cpu.

	* config/tc-mips.c (mips_cpu_info_table): Add rm5200, rm5231, rm5261,
	and rm5721 as valid cpu strings.
	(md_show_usage): Add rm5200, rm5231, rm5261, rm5721.
@
text
@a11843 1
    fragS *saved_frag = frag_now;
a11844 1
    segT seg;
d11939 1
a11939 1
     int ignore;
@


1.50
log
@[gas]
	* config/tc-mips.c (md_apply_fix): Prevent addend from becoming zero
	if it's expected to be non-zero.
[gas/testsuite]
	* gas/mips/elf-rel3.s: Add zero word to end of file.
@
text
@d9342 5
d12178 1
d12180 1
d12182 1
d12184 1
d12186 1
@


1.49
log
@2001-06-28  Eric Christopher <echristo@@redhat.com>
	    H.J. Lu  <hjl@@gnu.org>

* config/tc-mips.c (mips_arch): New. Use mips_arch instead
of mips_cpu for the ISA selection.
(md_longopts): Add OPTION_MARCH and OPTION_MTUNE.
(md_parse_option): Handle OPTION_MARCH and OPTION_MTUNE.
	(mips_tune): New.  Use mips_tune for scheduling and optimization
	issues.
	(append_insn): Use mips_tune and mips_arch.
	(macro_build): Ditto.
	(mips_ip): Ditto.
	(md_begin): Handle mips_arch, mips_tune and mips_cpu.  For
	backwards compatability mips_cpu generates arch and tune.
	(md_show_usage): Document new behavior.

	* doc/c-mips.texi (MIPS Opts): Document -march and -mtune.
	Deprecate -mcpu.

	* NEWS: Update.

2001-06-28  Eric Christopher  <echristo@@redhat.com>

	* gas/mips/usd.d: Change for march/mtune.
	* gas/mips/ulh-xgot.d: Ditto.
	* gas/mips/uld.d: Ditto.
	* gas/mips/trunc.d: Ditto.
	* gas/mips/rol.d: Ditto.
	* gas/mips/nodelay.d: Ditto.
	* gas/mips/mul.d: Ditto.
	* gas/mips/mul-ilocks.d: Ditto.
	* gas/mips/trap20.d: Ditto.
	* gas/mips/mips4.d: Ditto.
	* gas/mips/mips16.d: Ditto.
	* gas/mips/lif-xgot.d: Ditto.
	* gas/mips/lif-svr4pic.d: Ditto.
	* gas/mips/ld-xgot.d: Ditto.
	* gas/mips/ld-svr4pic.d: Ditto.
	* gas/mips/ld-ilocks-addr32.d: Ditto.
	* gas/mips/lb-xgot.d: Ditto.
	* gas/mips/jal-xgot.d: Ditto.
	* gas/mips/jal-svr4pic.d: Ditto.
	* gas/mips/delay.d: Ditto.
	* gas/mips/lb-xgot-ilocks.d: Ditto.
	* gas/mips/div.d: Ditto.
	* gas/mips/break20.d: Ditto.
	* gas/mips/delay.d: Ditto.
	* gas/mips/elf_e_flags3.d: Ditto.
	* gas/mips/elf_e_flags4.d: Ditto.
	* gas/mips/lineno.d: Ditto.
	* gas/mips/mips16.d: Ditto.
	* gas/mips/mips4.d: Ditto.
	* gas/mips/mips4010.d: Ditto.
	* gas/mips/mips4650.d: Ditto.
@
text
@d9615 1
a9615 2
		 the addend to appear in the object file.
		 FIXME: If this makes VALUE zero, we're toast.  */
d9617 36
@


1.48
log
@2001-06-11  H.J. Lu  <hjl@@gnu.org>

	* NEWS: Updated for the new -n option for the MIPS assembler.

	* config/tc-mips.c (md_show_usage): Add -n.

	* doc/as.texinfo: Document the new -n option.
	* doc/c-mips.texi: Likewise.
	* doc/as.1: Regenerated.
@
text
@d209 1
a209 1
/* The CPU type we are using for this output file.  */
d212 7
d256 1
a256 22
   require nops to be inserted.

   FIXME: GCC makes a distinction between -mcpu=FOO and -mFOO:
   -mcpu=FOO schedules for FOO, but still produces code that meets the
   requirements of MIPS ISA I.  For example, it won't generate any
   FOO-specific instructions, and it will still assume that any
   scheduling hazards described in MIPS ISA I are there, even if FOO
   has interlocks.  -mFOO gives GCC permission to generate code that
   will only run on a FOO; it will generate FOO-specific instructions,
   and assume interlocks provided by a FOO.

   However, GAS currently doesn't make this distinction; before Jan 28
   1999, GAS's -mcpu=FOO implied -mFOO, which violates GCC's
   assumptions.  The GCC driver passes these flags through to GAS, so
   if GAS actually does anything that doesn't meet MIPS ISA I with
   -mFOO, then GCC's -mcpu=FOO flag isn't going to work.

   And furthermore, it did not assume that -mFOO implied -mcpu=FOO,
   which seems senseless --- why generate code which will only run on
   a FOO, but schedule for something else?

   So now, at least, -mcpu=FOO and -mFOO are exactly equivalent.
d258 1
a258 3
   -- Jim Blandy <jimb@@cygnus.com> */

#define hilo_interlocks (mips_cpu == CPU_R4010                       \
d265 1
a265 1
   || mips_cpu == CPU_R3900)
d270 1
a270 1
#define cop_interlocks (mips_cpu == CPU_R4300                        \
d942 1
a942 1
  /* At this point, mips_cpu will either be CPU_UNKNOWN if no CPU was
d946 1
a946 1
  if (mips_cpu != CPU_UNKNOWN && mips_opts.isa != ISA_UNKNOWN)
d950 1
a950 1
  else if (mips_cpu != CPU_UNKNOWN && mips_opts.isa == ISA_UNKNOWN)
d952 2
a953 2
      /* We have CPU, we need ISA.  */
      ci = mips_cpu_info_from_cpu (mips_cpu);
d957 1
a957 1
  else if (mips_cpu == CPU_UNKNOWN && mips_opts.isa != ISA_UNKNOWN)
d959 1
a959 1
      /* We have ISA, we need default CPU.  */
d962 14
a975 1
      mips_cpu = ci->cpu;
d979 1
a979 1
      /* We need to set both ISA and CPU from target cpu.  */
d985 1
a985 1
      mips_cpu = ci->cpu;
d988 4
a991 1
  ci = mips_cpu_info_from_cpu (mips_cpu);
d1022 1
a1022 1
  if (! bfd_set_arch_mach (stdoutput, bfd_arch_mips, mips_cpu))
d1596 1
a1596 1
		 || (mips_cpu == CPU_R3900 && (pinfo & INSN_MULT)))
d1618 1
a1618 1
		 || (mips_cpu == CPU_R3900 && (pinfo & INSN_MULT)))
d1657 1
a1657 1
		    || (mips_cpu == CPU_R3900 && (pinfo & INSN_MULT))))
d1661 1
a1661 1
		    || (mips_cpu == CPU_R3900 && (pinfo & INSN_MULT)))))
d2014 1
a2014 1
		     || (mips_cpu == CPU_R3900 && (pinfo & INSN_MULT)))
d2499 1
a2499 1
	  && OPCODE_IS_MEMBER (insn.insn_mo, mips_opts.isa, mips_cpu,
d2501 1
a2501 1
	  && (mips_cpu != CPU_R4650 || (insn.insn_mo->pinfo & FP_D) == 0))
d4851 1
a4851 1
      if (mips_cpu == CPU_R4650)
d4940 1
a4940 1
      if (mips_cpu == CPU_R4650)
d5428 1
a5428 1
      if (mips_cpu == CPU_R4650)
d5469 1
a5469 1
      if (mips_cpu == CPU_R4650)
d5487 1
a5487 1
      if (mips_cpu == CPU_R4650)
d6116 1
a6116 1
      if (mips_cpu == CPU_R4650)
d7087 1
a7087 1
      if (OPCODE_IS_MEMBER (insn, mips_opts.isa, mips_cpu, mips_gp32))
d7094 1
a7094 1
	  if (mips_cpu == CPU_R4650 && (insn->pinfo & FP_D) != 0)
d7113 1
a7113 1
			   mips_cpu_to_str (mips_cpu),
d8944 4
d9049 2
d9053 2
d9056 1
a9056 3
	if (strcasecmp (arg, "default") == 0)
	  mips_cpu = CPU_UNKNOWN;
	else
d9062 14
a9075 1
	      as_bad (_("invalid architecture -mcpu=%s"), arg);
d9077 13
a9089 1
	      mips_cpu = ci->cpu;
d9095 2
a9096 1
      mips_cpu = CPU_R4650;
d9103 2
a9104 1
      mips_cpu = CPU_R4010;
d9111 2
a9112 1
      mips_cpu = CPU_VR4100;
d9119 2
a9120 1
      mips_cpu = CPU_R3900;
d9326 1
a9326 1
-mcpu=CPU		generate code for CPU, where CPU is one of:\n"));
d9351 1
a9351 1
-mCPU			equivalent to -mcpu=CPU.\n\
@


1.47
log
@2001-06-08  H.J. Lu  <hjl@@gnu.org>

	* config/tc-mips.c (warn_nops): New variable. Set to 0 to
	disable warning about all NOPS that the assembler generates.
	(macro): Warn NOPS generated only if warn_nops is not 0.
	(md_shortopts): Add `n'.
	(md_parse_option): Set warn_nops to 1 for `n'.
@
text
@d9334 1
@


1.46
log
@2001-06-08  H.J. Lu  <hjl@@gnu.org>

	* config/tc-mips.c (mips_ip): Properly handle illegal operands.
@
text
@d316 3
d3632 3
a3634 1
	      as_warn (_("Branch %s is always false (nop)"), ip->insn_mo->name);
d3639 3
a3641 1
	      as_warn (_("Branch likely %s is always false"), ip->insn_mo->name);
d8877 1
a8877 1
CONST char *md_shortopts = "O::g::G:";
d8992 4
@


1.45
log
@2001-06-08  H.J. Lu  <hjl@@gnu.org>

	* config/tc-mips.c (md_apply_fix): Don't adjust common
	extern/weak symbols for ELF.
	(md_estimate_size_before_relax): Treat weak like extern for
	ELF.
	(mips_fix_adjustable): Don't adjust extern/weak symbols for
	ELF.
@
text
@d7101 7
a7107 5
	      static char buf[100];
	      sprintf (buf,
		       _("opcode not supported on this processor: %s (%s)"),
		       mips_cpu_to_str (mips_cpu),
		       mips_isa_to_str (mips_opts.isa));
d7109 4
a7112 1
	      insn_error = buf;
d7119 1
d7960 1
d7963 2
@


1.44
log
@	* Makefile.am: 'som' is not wrongly spelled 'some'.
	* Makefile.in: Regenerate.

	* config/tc-mips.c (mips16_mark_labels): Reduce number of calls to
	S_GET_VALUE by using a temp.
	(append_insn): Likewise, and for S_GET_VALUE too.
	(mips_emit_delays): Likewise.
	(my_getExpression): Likewise.
	(md_apply_fix): Likewise.  Use "valueT" rather than "long" for "value".
	(mips16_extended_frag): Remove code concerned with avoiding
	locking in a frag address now that symbols are not finalized until
	relaxation is complete.  Cater for first relaxation pass having
	bogus addresses.  Use relax_marker to reliably determine whether a
	symbol frag has been reached on the current pass.
@
text
@d9541 3
a9543 1
	  || S_IS_WEAK (fixP->fx_addsy)
d11029 2
a11030 2
		/* A weak symbol is treated as external.  */
		&& ! S_IS_WEAK (sym)
d11068 5
@


1.43
log
@2001-06-07  H.J. Lu  <hjl@@gnu.org>

	* config/tc-mips.c (mips_pseudo_table): Add "extern" if
	MIPS_STABS_ELF is defined.
@
text
@d1387 1
d1395 3
a1397 2
	  if ((S_GET_VALUE (l->label) & 1) == 0)
	    S_SET_VALUE (l->label, S_GET_VALUE (l->label) + 1);
d1708 2
d1712 1
a1712 1
	      S_SET_VALUE (l->label, (valueT) frag_now_fix ());
d1715 2
a1716 1
		S_SET_VALUE (l->label, S_GET_VALUE (l->label) + 1);
d2414 2
d2418 1
a2418 1
	      S_SET_VALUE (l->label, (valueT) frag_now_fix ());
d2421 2
a2422 1
		S_SET_VALUE (l->label, S_GET_VALUE (l->label) + 1);
d8770 1
d8788 2
a8789 2
      && S_GET_VALUE (ep->X_add_symbol) == frag_now_fix ())
    S_SET_VALUE (ep->X_add_symbol, S_GET_VALUE (ep->X_add_symbol) + 1);
d9524 2
a9525 1
  long insn, value;
d9540 22
a9561 21
    if (S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16
        || S_IS_WEAK (fixP->fx_addsy)
        || (symbol_used_in_reloc_p (fixP->fx_addsy)
            && (((bfd_get_section_flags (stdoutput,
                                         S_GET_SEGMENT (fixP->fx_addsy))
                  & SEC_LINK_ONCE) != 0)
                || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
                             ".gnu.linkonce",
                             sizeof (".gnu.linkonce") - 1))))

      {
        value -= S_GET_VALUE (fixP->fx_addsy);
        if (value != 0 && ! fixP->fx_pcrel)
          {
            /* In this case, the bfd_install_relocation routine will
               incorrectly add the symbol value back in.  We just want
               the addend to appear in the object file.
	       FIXME: If this makes VALUE zero, we're toast.  */
            value -= S_GET_VALUE (fixP->fx_addsy);
          }
      }
d9711 1
a9711 1
	  if (value < -0x8000 || value > 0x7fff)
d9729 1
a9729 1
		      _("Branch to odd address (%lx)"), value);
d9739 1
a9739 1
      value >>= 2;
d9748 1
a9748 1
      if (value >= -0x8000 && value < 0x8000)
d10765 1
d10799 3
a10801 23
  /* We can't always call S_GET_VALUE here, because we don't want to
     lock in a particular frag address.  */
  if (symbol_constant_p (fragp->fr_symbol))
    {
      val = (S_GET_VALUE (fragp->fr_symbol)
	     + symbol_get_frag (fragp->fr_symbol)->fr_address);
      symsec = S_GET_SEGMENT (fragp->fr_symbol);
    }
  else if (symbol_equated_p (fragp->fr_symbol)
	   && (symbol_constant_p
	       (symbol_get_value_expression (fragp->fr_symbol)->X_add_symbol)))
    {
      symbolS *eqsym;

      eqsym = symbol_get_value_expression (fragp->fr_symbol)->X_add_symbol;
      val = (S_GET_VALUE (eqsym)
	     + symbol_get_frag (eqsym)->fr_address
	     + symbol_get_value_expression (fragp->fr_symbol)->X_add_number
	     + symbol_get_frag (fragp->fr_symbol)->fr_address);
      symsec = S_GET_SEGMENT (eqsym);
    }
  else
    return 1;
d10820 1
d10833 6
d10842 3
a10844 2
	 the same section.  If the fr_address of the symbol fragment
	 is greater then the address of this fragment we want to add
d10848 1
a10848 2
	  && (symbol_get_frag (fragp->fr_symbol)->fr_address
	      >= fragp->fr_address))
d10858 1
a10858 3
	  for (f = fragp;
	       f != NULL && f != symbol_get_frag (fragp->fr_symbol);
	       f = f->fr_next)
@


1.42
log
@Add MIPS r12k support
@
text
@d796 5
@


1.41
log
@	* symbols.c (resolve_symbol_value): Remove "finalize" param,
	instead use finalize_syms directly.  Don't treat expressions
	specially with regard to finalize_syms.  Update calls to self.
	(resolve_local_symbol): Update call to resolve_symbol_value.
	(S_GET_VALUE): Likewise.  Return resolve_symbol_value if
	!finalize_syms.
	* symbols.h (resolve_symbol_value): Update prototype.
	* config/obj-aout.c (obj_crawl_symbol_chain): Update call
	to resolve_symbol_value.
	* config/obj-bout.c (obj_crawl_symbol_chain): Likewise.
	* config/obj-coff.c (do_relocs_for): Likewise.
	(yank_symbols): Likewise.
	(fixup_segment): Likewise.
	* config/obj-vms.c (obj_crawl_symbol_chain): Likewise.
	* config/tc-mips.c (md_convert_frag): Likewise.
	* config/tc-ppc.c (ppc_frob_symbol): Likewise.
	(ppc_fix_adjustable): Likewise.
	* dwarf2dbg.c (dwarf2dbg_estimate_size_before_relax): Likewise.
	(dwarf2dbg_convert_frag): Likewise.
	* ehopt.c (eh_frame_estimate_size_before_relax): Likewise.
	(eh_frame_convert_frag): Likewise.
	* expr.c (make_expr_symbol): Likewise.
	* write.c (adjust_reloc_syms): Likewise.
	(write_object_file): Likewise.
	(relax_segment): Likewise.
	(fixup_segment): Likewise.
	(finalize_syms): Init to zero, and update comment.
	(write_object_file): Set finalize_syms to 1 rather than 2.
	* doc/internals.texi (sy_value): Mention finalize_syms.
	(S_GET_VALUE): Remove restriction on when S_GET_VALUE can be called.
@
text
@d244 1
a244 1
   || (ISA) == ISA_MIPS32            \
d9276 1
d12041 6
@


1.40
log
@2001-04-29  Keith M Wesolowski <wesolows@@foobazco.org>

	* config/tc-mips.c (md_parse_option): Also accept
	elf64-tradbigmips and elf64-tradlittlemips for OPTION_64.
@
text
@d11359 1
a11359 1
      resolve_symbol_value (fragp->fr_symbol, finalize_syms);
@


1.39
log
@2001-04-07  Steven J. Hill  <sjhill@@cotw.com>

	* config/tc-mips.c: Support ELF64 for traditional MIPS targets.

	* Makefile.am: (TARG_ENV_HFILES): Add tc-mips.h.
	* Makefile.in: Regenerated.

	* configure.in: Use traditional MIPS targets for Linux/MIPS.
	* configure: Regenerated.
@
text
@d9143 3
a9145 1
	      || strcmp (*l, "elf64-littlemips") == 0)
@


1.38
log
@Pass finalize_syms on calls to resolve_symbol_value.
@
text
@d129 2
a130 1
	      ? "elf32-tradbigmips" : "elf32-tradlittlemips");
@


1.37
log
@Fix copyright notices
@
text
@d11356 1
a11356 1
      resolve_symbol_value (fragp->fr_symbol, 1);
@


1.36
log
@Apply several patches from Maciej W. Rozycki
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 1999, 2000
@


1.35
log
@2001-02-10  Chris Demetriou  <cgd@@broadcom.com>

        * config/tc-mips.c (md_parse_option): Don't try to compile
        ELF-only option code if not ELF.
@
text
@d3939 1
a3939 1
	      macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d3960 1
a3960 1
	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d3999 1
a3999 1
	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
d4216 2
d4221 2
d4249 2
d4253 1
a4253 1
		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GP);
d4359 2
d4367 4
d4409 5
d4415 1
a4415 1
		       tempreg, (int) BFD_RELOC_MIPS_GOT_HI16);
d4423 1
a4423 2
		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT_LO16,
		       tempreg);
@


1.34
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d9060 1
d9094 1
d9112 1
d9134 1
@


1.34.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.34.2.2
log
@Merge from mainline.
@
text
@d129 1
a129 2
	      ? (mips_64 ? "elf64-tradbigmips" : "elf32-tradbigmips")
	      : (mips_64 ? "elf64-tradlittlemips" : "elf32-tradlittlemips"));
d243 1
a243 1
   || (ISA) == ISA_MIPS64            \
a794 5

#ifdef MIPS_STABS_ELF
  { "extern", ecoff_directive_extern, 0},
#endif

a1380 1
      valueT val;
d1388 2
a1389 3
	  val = S_GET_VALUE (l->label);
	  if ((val & 1) == 0)
	    S_SET_VALUE (l->label, val + 1);
a1699 2
	      valueT val;

d1702 1
a1702 1
	      val = (valueT) frag_now_fix ();
d1705 1
a1705 2
		val += 1;
	      S_SET_VALUE (l->label, val);
a2402 2
	      valueT val;

d2405 1
a2405 1
	      val = (valueT) frag_now_fix ();
d2408 1
a2408 2
		val += 1;
	      S_SET_VALUE (l->label, val);
d3939 1
a3939 1
	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d3960 1
a3960 1
	  macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d3999 1
a3999 1
	  macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
a4215 2
	  int lw_reloc_type = (int) BFD_RELOC_MIPS_GOT16;

a4218 2
	     or if tempreg is PIC_CALL_REG
	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_CALL16)
a4244 2
	  if (expr1.X_add_number == 0 && tempreg == PIC_CALL_REG)
	    lw_reloc_type = (int) BFD_RELOC_MIPS_CALL16;
d4247 1
a4247 1
		       "t,o(b)", tempreg, lw_reloc_type, GP);
a4352 2
	  int lui_reloc_type = (int) BFD_RELOC_MIPS_GOT_HI16;
	  int lw_reloc_type = (int) BFD_RELOC_MIPS_GOT_LO16;
a4358 4
	     or if tempreg is PIC_CALL_REG
	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_CALL_HI16)
	       addu	$tempreg,$tempreg,$gp
	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_CALL_LO16)
a4396 5
	  if (expr1.X_add_number == 0 && tempreg == PIC_CALL_REG)
	    {
	      lui_reloc_type = (int) BFD_RELOC_MIPS_CALL_HI16;
	      lw_reloc_type = (int) BFD_RELOC_MIPS_CALL_LO16;
	    }
d4398 1
a4398 1
		       tempreg, lui_reloc_type);
d4406 2
a4407 1
		       "t,o(b)", tempreg, lw_reloc_type, tempreg);
a8739 1
  valueT val;
d8757 2
a8758 2
      && (val = S_GET_VALUE (ep->X_add_symbol)) == frag_now_fix ())
    S_SET_VALUE (ep->X_add_symbol, val + 1);
a9059 1
#ifdef OBJ_ELF
a9092 1
#endif /* OBJ_ELF */
a9109 1
#ifdef OBJ_ELF
d9123 1
a9123 3
	      || strcmp (*l, "elf64-littlemips") == 0
	      || strcmp (*l, "elf64-tradbigmips") == 0
	      || strcmp (*l, "elf64-tradlittlemips") == 0)
a9130 1
#endif /* OBJ_ELF */
a9252 1
  show (stream, "12000", &column, &first);
d9486 1
a9486 2
  long insn;
  valueT value;
d9501 21
a9521 22
      if (S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16
	  || S_IS_WEAK (fixP->fx_addsy)
	  || (symbol_used_in_reloc_p (fixP->fx_addsy)
	      && (((bfd_get_section_flags (stdoutput,
					   S_GET_SEGMENT (fixP->fx_addsy))
		    & SEC_LINK_ONCE) != 0)
		  || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
			       ".gnu.linkonce",
			       sizeof (".gnu.linkonce") - 1))))

	{
	  valueT symval = S_GET_VALUE (fixP->fx_addsy);
	  value -= symval;
	  if (value != 0 && ! fixP->fx_pcrel)
	    {
	      /* In this case, the bfd_install_relocation routine will
		 incorrectly add the symbol value back in.  We just want
		 the addend to appear in the object file.
		 FIXME: If this makes VALUE zero, we're toast.  */
	      value -= symval;
	    }
	}
d9671 1
a9671 1
	  if (value + 0x8000 > 0xffff)
d9689 1
a9689 1
		      _("Branch to odd address (%lx)"), (long) value);
d9699 1
a9699 1
      value = (offsetT) value >> 2;
d9708 1
a9708 1
      if (value + 0x8000 <= 0xffff)
a10724 1
  fragS *sym_frag;
a10757 2
  sym_frag = symbol_get_frag (fragp->fr_symbol);

d10762 2
a10763 1
      val = S_GET_VALUE (fragp->fr_symbol) + sym_frag->fr_address;
d10776 1
a10776 1
	     + sym_frag->fr_address);
a10798 1
	  /* Must have been called from md_estimate_size_before_relax.  */
a10810 6
	  if (fragp != sym_frag && sym_frag->fr_address == 0)
	    /* Assume non-extended on the first relaxation pass.
	       The address we have calculated will be bogus if this is
	       a forward branch to another frag, as the forward frag
	       will have fr_address == 0.  */
	    return 0;
d10814 2
a10815 3
	 the same section.  If the relax_marker of the symbol fragment
	 differs from the relax_marker of this fragment, we have not
	 yet adjusted the symbol fragment fr_address.  We want to add
d10819 2
a10820 1
	  && sym_frag->relax_marker != fragp->relax_marker)
d10830 3
a10832 1
	  for (f = fragp; f != NULL && f != sym_frag; f = f->fr_next)
a12016 6

  /* R12000 CPU */
  { "R12000",         0,      ISA_MIPS4,      CPU_R12000, },
  { "12000",          0,      ISA_MIPS4,      CPU_R12000, },
  { "12k",            0,      ISA_MIPS4,      CPU_R12000, },
  { "r12k",           0,      ISA_MIPS4,      CPU_R12000, },
@


1.33
log
@Fix formatting
@
text
@d11553 1
a11553 2
/* When we align code in the .text section of mips16, use the correct two
   byte nop pattern of 0x6500 (move $0,$0) */
d11555 3
a11557 6
int
mips_do_align (n, fill, len, max)
     int n;
     const char *fill;
     int len ATTRIBUTE_UNUSED;
     int max;
d11559 4
a11562 4
  if (fill == NULL
      && subseg_text_p (now_seg)
      && n > 1
      && mips_opts.mips16)
d11567 11
a11577 1
      frag_align (1, 0, 0);
d11579 2
a11580 5
      if (target_big_endian)
	frag_align_pattern (n, be_nop, 2, max);
      else
	frag_align_pattern (n, le_nop, 2, max);
      return 1;
d11583 1
a11583 1
  return 0;
@


1.32
log
@2000-12-05  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-mips.c: Fix formatting.
@
text
@d156 2
a157 1
struct mips_set_options {
d194 2
a195 1
static struct mips_set_options mips_opts = {
d212 1
a212 1
static char *mips_abi_string = 0;
d294 2
a295 1
enum mips_pic_level {
d489 2
a490 1
struct mips_hi_fixup {
d506 2
a507 1
static const int mips32_to_16_reg_map[] = {
d517 2
a518 1
static const unsigned int mips16_to_32_reg_map[] = {
d722 2
a723 1
struct mips_cpu_info {
d752 2
a753 1
static const pseudo_typeS mips_pseudo_table[] = {
d798 2
a799 1
static const pseudo_typeS mips_nonecoff_pseudo_table[] = {
d828 2
a829 1
struct insn_label_list {
a1555 1

d6924 1
a6924 1
      case 'J':       USE_BITS (OP_MASK_CODE19,       OP_SH_CODE19);  break;
d8473 2
a8474 1
struct mips16_immed_operand {
d8832 2
a8833 1
struct option md_longopts[] = {
d10172 2
a10173 1
struct mips_option_stack {
d11923 2
a11924 1
static const struct mips_cpu_info mips_cpu_info_table[] = {
d11971 1
a11971 1
  { "mipstx39",               0,      ISA_MIPS1,      CPU_R3900, },
d12058 1
a12058 1
  { "sb-1250",                0,      ISA_MIPS64,     CPU_SB1, },
d12076 1
a12076 1
  return (NULL);
d12090 1
a12090 1
  return (NULL);
d12104 1
a12104 1
  return (NULL);
@


1.31
log
@Add MIPS SB1 machine
@
text
@d113 1
d129 1
a129 1
              ? "elf32-tradbigmips" : "elf32-tradlittlemips");
d156 1
a156 2
struct mips_set_options
{
d193 1
a193 2
static struct mips_set_options mips_opts =
{
d210 1
a210 1
static char* mips_abi_string = 0;
d292 1
a292 2
enum mips_pic_level
{
d486 1
a486 2
struct mips_hi_fixup
{
d502 1
a502 2
static const int mips32_to_16_reg_map[] =
{
d512 1
a512 2
static const unsigned int mips16_to_32_reg_map[] =
{
d587 2
a588 2
#define RELAX_RELOC1(i) ((bfd_vma)(((i) >> 9) & 0x7f) - 64)
#define RELAX_RELOC2(i) ((bfd_vma)(((i) >> 2) & 0x7f) - 64)
d716 1
a716 2
struct mips_cpu_info
{
d745 2
a746 3
static const pseudo_typeS mips_pseudo_table[] =
{
 /* MIPS specific pseudo-ops.  */
d759 1
a759 1
 /* Relatively generic pseudo-ops that happen to be used on MIPS
d768 1
a768 1
 /* These pseudo-ops are defined in read.c, but must be overridden
d791 2
a792 2
 /* These pseudo-ops should be defined by the object file format.
    However, a.out doesn't support them, so we have versions here.  */
d819 1
a819 2
struct insn_label_list
{
d966 1
a966 1
        ci = mips_cpu_info_from_cpu (CPU_R3000);
d993 1
a993 1
      && 0 == strcmp (mips_abi_string,"eabi"))
d1219 2
a1220 2
      DBG((_("returned from mips_ip(%s) insn_opcode = 0x%x\n"),
		str, insn.insn_opcode));
d1452 1
a1452 1
          /* Itbl support may require additional care here.  */
d1464 1
a1464 1
                    && ! cop_interlocks)
d1530 1
a1530 1
          /* Itbl support may require additional care here.  */
d1544 2
a1545 2
                                       & OP_MASK_RD),
                                    MIPS_GR_REG))
d1888 1
a1888 1
      mips_gprmask &=~ 1 << 0;
d2339 1
a2339 1
          /* Itbl support may require additional care here.  */
d2361 1
a2361 1
          /* Itbl support may require additional care here.  */
d2519 1
a2519 1
	    continue; 
d3042 4
a3045 4
        {
          if ((lo32.X_add_number & 0xffff8000) == 0xffff8000)
            {
              macro_build ((char *) NULL, counter, &lo32, "addiu", "t,r,j",
d3047 6
a3052 6
              return;
            }
          if (lo32.X_add_number & 0x80000000)
            {
              macro_build ((char *) NULL, counter, &lo32, "lui", "t,u", reg,
                           (int) BFD_RELOC_HI16);
d3056 3
a3058 3
              return;
            }
        }
d3065 2
a3066 2
       {
	 unsigned long himask, lomask;
d3068 33
a3100 31
	 if (shift < 32)
	   {
	     himask = 0xffff >> (32 - shift);
	     lomask = (0xffff << shift) & 0xffffffff;
	   }
	 else
	   {
	     himask = 0xffff << (shift - 32);
	     lomask = 0;
	   }
	 if ((hi32.X_add_number & ~ (offsetT) himask) == 0
	     && (lo32.X_add_number & ~ (offsetT) lomask) == 0)
	   {
	     expressionS tmp;

	     tmp.X_op = O_constant;
	     if (shift < 32)
	       tmp.X_add_number = ((hi32.X_add_number << (32 - shift))
				   | (lo32.X_add_number >> shift));
	     else
	       tmp.X_add_number = hi32.X_add_number >> (shift - 32);
	     macro_build ((char *) NULL, counter, &tmp, "ori", "t,r,i", reg, 0,
			  (int) BFD_RELOC_LO16);
	     macro_build ((char *) NULL, counter, NULL,
			  (shift >= 32) ? "dsll32" : "dsll",
			  "d,w,<", reg, reg,
			  (shift >= 32) ? shift - 32 : shift);
	     return;
	   }
         shift++;
       } while (shift <= (64 - 16));
d3132 2
a3133 2
        {
          shift = COUNT_TOP_ZEROES ((unsigned int) hi32.X_add_number);
d3135 1
a3135 1
            {
d3140 3
a3142 3
              tmp.X_op = O_constant;
              tmp.X_add_number = (offsetT) -1;
              macro_build ((char *) NULL, counter, &tmp, "addiu", "t,r,j",
d3144 9
a3152 9
              if (bit != 0)
                {
                  bit += shift;
                  macro_build ((char *) NULL, counter, NULL,
                               (bit >= 32) ? "dsll32" : "dsll",
                               "d,w,<", reg, reg,
                               (bit >= 32) ? bit - 32 : bit);
                }
              macro_build ((char *) NULL, counter, NULL,
d3154 1
a3154 1
                           "d,w,<", reg, reg,
d3156 3
a3158 3
              return;
            }
        }
d3163 1
a3163 1
	hi32.X_add_number |= ~ (offsetT) 0xffffffff;
d3181 1
a3181 1
        {
d3184 4
a3187 4
          macro_build ((char *) NULL, counter, NULL, "dsrl32", "d,w,<", reg,
                       reg, 0);
          return;
        }
d3240 1
a3240 1
          || nopic_need_relax (ep->X_add_symbol, 1))
d4037 1
a4037 1
	      macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d4108 1
a4108 1
	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
d5542 1
a5542 1
              /* Itbl support may require additional care here.  */
d5552 1
a5552 1
              /* Itbl support may require additional care here.  */
d5598 1
a5598 1
          /* Itbl support may require additional care here.  */
d5606 1
a5606 1
          /* Itbl support may require additional care here.  */
d5651 1
a5651 1
          /* Itbl support may require additional care here.  */
d5661 1
a5661 1
          /* Itbl support may require additional care here.  */
d5725 1
a5725 1
          /* Itbl support may require additional care here.  */
d5735 1
a5735 1
          /* Itbl support may require additional care here.  */
d5769 1
a5769 1
          /* Itbl support may require additional care here.  */
d5780 1
a5780 1
          /* Itbl support may require additional care here.  */
d5812 1
a5812 1
          /* Itbl support may require additional care here.  */
d5817 1
a5817 1
          /* Itbl support may require additional care here.  */
d5892 1
a5892 1
        {
d5898 1
a5898 1
        }
d5995 1
a5995 1
	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
d6028 1
a6028 1
	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
d6681 1
a6681 1
	macro_build ((char *) NULL, &icnt, NULL, "break", "6", 7);
d7061 1
a7061 1
  	    {
d7214 1
a7214 1
              my_getExpression (&imm_expr, s);
d7216 1
a7216 1
              if ((unsigned long) imm_expr.X_add_number >= (1<<25))
d7218 1
a7218 1
                  as_warn (_("Coproccesor code > 25 bits (%ld)"),
d7220 1
a7220 1
                  imm_expr.X_add_number &= ((1<<25) - 1);
d7222 4
a7225 4
              ip->insn_opcode |= imm_expr.X_add_number;
              imm_expr.X_op = O_absent;
              s = expr_end;
              continue;
d7239 1
a7239 1
              my_getExpression (&imm_expr, s);
d7241 1
a7241 1
              if (imm_expr.X_add_number != 0 && imm_expr.X_add_number != 1)
d7243 1
a7243 1
                  as_warn (_("Invalidate performance regster (%ld)"),
d7245 1
a7245 1
                  imm_expr.X_add_number &= 1;
d7247 4
a7250 4
              ip->insn_opcode |= (imm_expr.X_add_number << 1);
              imm_expr.X_op = O_absent;
              s = expr_end;
              continue;
d7339 1
a7339 1
			  }
d7734 2
a7735 2
                           || imm_expr.X_add_number >= 0x10000)
                          && imm_expr.X_op == O_constant))
d7767 2
a7768 2
                           || imm_expr.X_add_number >= max)
                          && imm_expr.X_op == O_constant)
d7879 1
a7879 1
              continue;
d8464 1
a8464 2
struct mips16_immed_operand
{
d8579 2
a8580 1
    as_warn_where (file, line, _("extended operand requested but not required"));
d8822 1
a8822 2
struct option md_longopts[] =
{
d8994 1
a8994 1
              as_bad (_("invalid architecture -mcpu=%s"), arg);
d9134 3
a9136 1
/*    mips_32bitmode = 1; */
d9142 3
a9144 1
/*    mips_32bitmode = 0; */
d9148 5
a9152 5
      if (strcmp (arg,"32") == 0
	  || strcmp (arg,"n32") == 0
	  || strcmp (arg,"64") == 0
	  || strcmp (arg,"o64") == 0
	  || strcmp (arg,"eabi") == 0)
d9207 1
a9207 1
  fprintf(stream, _("\
d9215 1
a9215 1
  fprintf(stream, _("\
d9259 1
a9259 1
  fprintf(stream, _("\
d9262 1
a9262 1
  fprintf(stream, _("\
d9269 1
a9269 1
  fprintf(stream, _("\
d9283 1
a9283 1
  mips_opcodes = (struct mips_opcode*) mips_builtin_opcodes;
a9451 1
/*ARGSUSED*/
d10161 1
a10161 2
struct mips_option_stack
{
a10918 1
/*ARGSUSED*/
d10970 12
a10981 12
        {
          if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE)
              != 0)
            linkonce = true;

          /* The GNU toolchain uses an extension for ELF: a section
             beginning with the magic string .gnu.linkonce is a linkonce
             section.  */
          if (strncmp (segment_name (symsec), ".gnu.linkonce",
                       sizeof ".gnu.linkonce" - 1) == 0)
            linkonce = true;
        }
d11508 1
a11508 1
  else if (strcmp (mips_abi_string,"32") == 0)
d11510 1
a11510 1
  else if (strcmp (mips_abi_string,"o64") == 0)
d11512 1
a11512 1
  else if (strcmp (mips_abi_string,"eabi") == 0)
d11526 10
a11535 12
typedef struct proc
  {
    symbolS *isym;
    unsigned long reg_mask;
    unsigned long reg_offset;
    unsigned long fpreg_mask;
    unsigned long fpreg_offset;
    unsigned long frame_offset;
    unsigned long frame_reg;
    unsigned long pc_reg;
  }
procS;
d11562 1
a11562 1
      	frag_align_pattern (n, be_nop, 2, max);
d11564 1
a11564 1
      	frag_align_pattern (n, le_nop, 2, max);
d11715 1
a11715 1
    /* Write the symbol */
d11721 1
a11721 1
    fragp = frag_more (7*4);
d11723 7
a11729 7
    md_number_to_chars (fragp,     (valueT) cur_proc_ptr->reg_mask, 4);
    md_number_to_chars (fragp + 4, (valueT) cur_proc_ptr->reg_offset, 4);
    md_number_to_chars (fragp + 8, (valueT) cur_proc_ptr->fpreg_mask, 4);
    md_number_to_chars (fragp +12, (valueT) cur_proc_ptr->fpreg_offset, 4);
    md_number_to_chars (fragp +16, (valueT) cur_proc_ptr->frame_offset, 4);
    md_number_to_chars (fragp +20, (valueT) cur_proc_ptr->frame_reg, 4);
    md_number_to_chars (fragp +24, (valueT) cur_proc_ptr->pc_reg, 4);
d11803 1
a11803 1
  if (cur_proc_ptr ==  (procS *) NULL)
d11911 1
a11911 2
static const struct mips_cpu_info mips_cpu_info_table[] =
{
d12049 1
a12049 1
  /* End marker. */
d12060 1
a12060 1
    if (strcasecmp(name, mips_cpu_info_table[i].name) == 0)
@


1.30
log
@Add MIPS V and MIPS 64 machine numbers
@
text
@d9246 1
d12051 6
@


1.29
log
@Add MIPS32 as a seperate MIPS architecture
@
text
@d241 2
d8889 4
d8978 4
d8986 4
d9223 1
d9225 1
d10253 9
a10261 9
      case  0: mips_opts.isa = file_mips_isa; break;
      case  1: mips_opts.isa = ISA_MIPS1;     break;
      case  2: mips_opts.isa = ISA_MIPS2;     break;
      case  3: mips_opts.isa = ISA_MIPS3;     break;
      case  4: mips_opts.isa = ISA_MIPS4;     break;
      case 32: mips_opts.isa = ISA_MIPS32;    break;
      default:
        as_bad (_("unknown ISA level"));
        break;
d11933 4
d11941 1
d11944 6
@


1.28
log
@Improve MIPS32 support
@
text
@d190 2
a191 2
   that we must set the isa and mips16 fields to -1 to indicate that
   they have not been initialized.  */
d193 4
a196 1
static struct mips_set_options mips_opts = { -1, -1, 0, 0, 0, 0, 0, 0 };
d205 1
a205 1
static int file_mips_isa;
d207 2
a208 2
/* The CPU type as a number: 2000, 3000, 4000, 4400, etc.  */
static int mips_cpu = -1;
d232 3
a234 3
   (ISA) == 1                               \
   || (ISA) == 2                            \
   || (ISA) == 3                            \
d239 2
a240 2
   (ISA) == 3                        \
   || (ISA) == 4                     \
d276 1
a276 1
  (mips_opts.isa != 1  \
d712 3
a714 1
static char *mips_cpu_to_str PARAMS ((int));
d716 14
a729 1
static int validate_mips_insn PARAMS ((const struct mips_opcode *));
d873 16
a888 1
static char *
d892 1
d894 7
a900 22
  switch (cpu)
    {
    case CPU_R2000: return "R2000";
    case CPU_R3000: return "R3000";
    case CPU_R3900: return "R3900";
    case CPU_R4000: return "R4000";
    case CPU_R4010: return "R4010";
    case CPU_VR4100: return "VR4100";
    case CPU_R4111: return "R4111";
    case CPU_R4300: return "R4300";
    case CPU_R4400: return "R4400";
    case CPU_R4600: return "R4600";
    case CPU_R4650: return "R4650";
    case CPU_R5000: return "R5000";
    case CPU_R6000: return "R6000";
    case CPU_R8000: return "R8000";
    case CPU_R10000: return "R10000";
    case CPU_4K: return "4K";
    default:
      sprintf (s, "%d", cpu);
      return s;
    }
a908 1
  boolean ok = false;
d915 2
d936 1
a936 1
  if (mips_cpu < 0)
d938 3
a940 3
      /* Set mips_cpu based on TARGET_CPU, unless TARGET_CPU is
         just the generic 'mips', in which case set mips_cpu based
         on the given ISA, if any.  */
d942 2
a943 4
      if (strcmp (cpu, "mips") == 0)
        {
	  if (mips_opts.isa < 0)
	    mips_cpu = CPU_R3000;
d945 21
a965 70
	  else if (mips_opts.isa == 2)
            mips_cpu = CPU_R6000;

          else if (mips_opts.isa == 3)
            mips_cpu = CPU_R4000;

          else if (mips_opts.isa == 4)
            mips_cpu = CPU_R8000;

          else
            mips_cpu = CPU_R3000;
        }

      else if (strcmp (cpu, "r3900") == 0
               || strcmp (cpu, "mipstx39") == 0
               )
        mips_cpu = CPU_R3900;

      else if (strcmp (cpu, "r6000") == 0
	       || strcmp (cpu, "mips2") == 0)
        mips_cpu = CPU_R6000;

      else if (strcmp (cpu, "mips64") == 0
	       || strcmp (cpu, "r4000") == 0
	       || strcmp (cpu, "mips3") == 0)
        mips_cpu = CPU_R4000;

      else if (strcmp (cpu, "r4400") == 0)
        mips_cpu = CPU_R4400;

      else if (strcmp (cpu, "mips64orion") == 0
	       || strcmp (cpu, "r4600") == 0)
        mips_cpu = CPU_R4600;

      else if (strcmp (cpu, "r4650") == 0)
        mips_cpu = CPU_R4650;

      else if (strcmp (cpu, "mips64vr4300") == 0)
        mips_cpu = CPU_R4300;

      else if (strcmp (cpu, "mips64vr4111") == 0)
        mips_cpu = CPU_R4111;

      else if (strcmp (cpu, "mips64vr4100") == 0)
        mips_cpu = CPU_VR4100;

      else if (strcmp (cpu, "r4010") == 0)
        mips_cpu = CPU_R4010;

      else if (strcmp (cpu, "4Kc") == 0
	       || strcmp (cpu, "4Kp") == 0
	       || strcmp (cpu, "4Km") == 0)
	mips_cpu = CPU_4K;

      else if (strcmp (cpu, "r5000") == 0
	       || strcmp (cpu, "mips64vr5000") == 0)
        mips_cpu = CPU_R5000;

      else if (strcmp (cpu, "r8000") == 0
	       || strcmp (cpu, "mips4") == 0)
        mips_cpu = CPU_R8000;

      else if (strcmp (cpu, "r10000") == 0)
        mips_cpu = CPU_R10000;

      else if (strcmp (cpu, "mips16") == 0)
        mips_cpu = 0; /* FIXME */

      else
        mips_cpu = CPU_R3000;
a966 23

  if (mips_cpu == CPU_R3000
      || mips_cpu == CPU_R3900)
    mips_isa_from_cpu = 1;

  else if (mips_cpu == CPU_R6000
	   || mips_cpu == CPU_R4010)
    mips_isa_from_cpu = 2;

  else if (mips_cpu == CPU_R4000
	   || mips_cpu == CPU_VR4100
	   || mips_cpu == CPU_R4111
	   || mips_cpu == CPU_R4400
	   || mips_cpu == CPU_R4300
	   || mips_cpu == CPU_R4600
	   || mips_cpu == CPU_R4650)
    mips_isa_from_cpu = 3;

  else if (mips_cpu == CPU_R5000
	   || mips_cpu == CPU_R8000
               || mips_cpu == CPU_R10000)
    mips_isa_from_cpu = 4;

a967 3
    mips_isa_from_cpu = -1;

  if (mips_opts.isa == -1)
d969 7
a975 4
      if (mips_isa_from_cpu != -1)
	mips_opts.isa = mips_isa_from_cpu;
      else
	mips_opts.isa = 1;
d978 3
a980 7
  if (mips_opts.mips16 < 0)
    {
      if (strncmp (TARGET_CPU, "mips16", sizeof "mips16" - 1) == 0)
	mips_opts.mips16 = 1;
      else
	mips_opts.mips16 = 0;
    }
d991 1
a991 1
  if (mips_opts.isa == 1 && mips_trap)
d1002 6
a1007 29
  if (mips_cpu != 0 && mips_cpu != -1)
    {
      ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, mips_cpu);

      /* If they asked for mips1 or mips2 and a cpu that is
	 mips3 or greater, then mark the object file 32BITMODE.  */
      if (mips_isa_from_cpu != -1
	  && ! ISA_HAS_64BIT_REGS (mips_opts.isa)
	  && ISA_HAS_64BIT_REGS (mips_isa_from_cpu))
	mips_32bitmode = 1;
    }
  else
    {
      switch (mips_opts.isa)
	{
	case 1:
	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, CPU_R3000);
	  break;
	case 2:
	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, CPU_R6000);
	  break;
	case 3:
	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, CPU_R4000);
	  break;
	case 4:
	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, CPU_R8000);
	  break;
	}
    }
d1009 1
a1009 1
  if (! ok)
d1471 1
a1471 1
		   || (mips_opts.isa == 1
d2005 1
a2005 1
		  && mips_opts.isa == 1
d2341 1
a2341 1
	      && mips_opts.isa == 1
d5343 1
a5343 1
	  if (mips_opts.isa != 1)
d5368 1
a5368 1
	  if (mips_opts.isa != 1)
d5395 1
a5395 1
      assert (mips_opts.isa == 1);
d5434 1
a5434 1
      if (mips_opts.isa != 1)
d5451 1
a5451 1
      if (mips_opts.isa != 1)
d6079 1
a6079 1
      assert (mips_opts.isa == 1);
d6388 1
a6388 1
      assert (mips_opts.isa == 1);
d7068 3
a7070 2
		       _("opcode not supported on this processor: %s (MIPS%d)"),
		       mips_cpu_to_str (mips_cpu), mips_opts.isa);
a8886 3
#define OPTION_NO_MIPS32 (OPTION_MD_BASE + 29)
  {"no-mips32", no_argument, NULL, OPTION_NO_MIPS32},

d8957 1
a8957 1
      mips_opts.isa = 1;
d8961 1
a8961 1
      mips_opts.isa = 2;
d8965 1
a8965 1
      mips_opts.isa = 3;
d8969 5
a8973 1
      mips_opts.isa = 4;
d8978 3
a8980 7
	char *p;

	/* Identify the processor type */
	p = arg;
	if (strcmp (p, "default") == 0
	    || strcmp (p, "DEFAULT") == 0)
	  mips_cpu = -1;
d8983 1
a8983 1
	    int sv = 0;
d8985 5
a8989 120
	    /* We need to cope with the various "vr" prefixes for the 4300
	       processor.  */
	    if (*p == 'v' || *p == 'V')
	      {
		sv = 1;
		p++;
	      }

	    if (*p == 'r' || *p == 'R')
	      p++;

	    mips_cpu = -1;
	    switch (*p)
	      {
	      case '1':
		if (strcmp (p, "10000") == 0
		    || strcmp (p, "10k") == 0
		    || strcmp (p, "10K") == 0)
		  mips_cpu = CPU_R10000;
		break;

	      case '2':
		if (strcmp (p, "2000") == 0
		    || strcmp (p, "2k") == 0
		    || strcmp (p, "2K") == 0)
		  mips_cpu = CPU_R2000;
		break;

	      case '3':
		if (strcmp (p, "3000") == 0
		    || strcmp (p, "3k") == 0
		    || strcmp (p, "3K") == 0)
		  mips_cpu = CPU_R3000;
                else if (strcmp (p, "3900") == 0)
                  mips_cpu = CPU_R3900;
		break;

	      case '4':
		if (strcmp (p, "4000") == 0
		    || strcmp (p, "4k") == 0
		    || strcmp (p, "4K") == 0)
		  mips_cpu = CPU_R4000;
		else if (strcmp (p, "4100") == 0)
                    mips_cpu = CPU_VR4100;
		else if (strcmp (p, "4111") == 0)
                    mips_cpu = CPU_R4111;
		else if (strcmp (p, "4300") == 0)
		  mips_cpu = CPU_R4300;
		else if (strcmp (p, "4400") == 0)
		  mips_cpu = CPU_R4400;
		else if (strcmp (p, "4600") == 0)
		  mips_cpu = CPU_R4600;
		else if (strcmp (p, "4650") == 0)
		    mips_cpu = CPU_R4650;
		else if (strcmp (p, "4010") == 0)
                  mips_cpu = CPU_R4010;
		else if (strcmp (p, "4Kc") == 0
			 || strcmp (p, "4Kp") == 0
			 || strcmp (p, "4Km") == 0)
		  mips_cpu = CPU_MIPS32;
		break;

	      case '5':
		if (strcmp (p, "5000") == 0
		    || strcmp (p, "5k") == 0
		    || strcmp (p, "5K") == 0)
		  mips_cpu = CPU_R5000;
		break;

	      case '6':
		if (strcmp (p, "6000") == 0
		    || strcmp (p, "6k") == 0
		    || strcmp (p, "6K") == 0)
		  mips_cpu = CPU_R6000;
		break;

	      case '8':
		if (strcmp (p, "8000") == 0
		    || strcmp (p, "8k") == 0
		    || strcmp (p, "8K") == 0)
		  mips_cpu = CPU_R8000;
		break;

	      case 'o':
		if (strcmp (p, "orion") == 0)
		  mips_cpu = CPU_R4600;
		break;

	      case 'm':
	      case 'M':
		switch (atoi (p + 1))
		  {
		  case 5200:
		  case 5230:
		  case 5231:
		  case 5261:
		  case 5721:
		  case 7000:
		    mips_cpu = CPU_R5000;
		    break;
		  default:
		    break;
		  }
	      }

	    if (sv
		&& (mips_cpu != CPU_R4300
		    && mips_cpu != CPU_VR4100
		    && mips_cpu != CPU_R4111
		    && mips_cpu != CPU_R5000))
	      {
		as_bad (_("ignoring invalid leading 'v' in -mcpu=%s switch"), arg);
		return 0;
	      }

	    if (mips_cpu == -1)
	      {
		as_bad (_("invalid architecture -mcpu=%s"), arg);
		return 0;
	      }
a9014 7
    case OPTION_MIPS32:
      mips_cpu = CPU_MIPS32;
      break;

    case OPTION_NO_MIPS32:
      break;

d9209 1
d9229 1
a9229 3
  show (stream, "4Kc", &column, &first);
  show (stream, "4Kp", &column, &first);
  show (stream, "4Km", &column, &first);
a9244 3
  fprintf (stream, _("\
-mips32                 generate MIPS32 instructions\n"));

d10235 12
a10246 6
      if (isa == 0)
	mips_opts.isa = file_mips_isa;
      else if (isa < 1 || isa > 4)
	as_bad (_("unknown ISA level"));
      else
	mips_opts.isa = isa;
d11892 176
@


1.27
log
@When calculating offsets, don't accept as constant the difference between the
addresses of symbols in two different sections.
@
text
@d2600 9
d2629 4
d6992 1
a6992 1
      case 'B':	USE_BITS (OP_MASK_SYSCALL,	OP_SH_SYSCALL);	break;
d7000 1
a7018 1
      case 'm': USE_BITS (OP_MASK_CODE20,	OP_SH_CODE20);	break;
d7031 2
d7286 1
a7286 19
	    case 'm':		/* Full 20 bit break code.  */
	      my_getExpression (&imm_expr, s);

	      check_absolute_expr (ip, &imm_expr);

	      if ((unsigned) imm_expr.X_add_number > 0xfffff)
		{
		  as_warn (_("Illegal break code (%ld)"),
			   (long) imm_expr.X_add_number);
		  imm_expr.X_add_number &= 0xfffff;
		}

	      ip->insn_opcode |= imm_expr.X_add_number << 6;
	      imm_expr.X_op = O_absent;
	      s = expr_end;

	      continue;

	    case 'B':		/* syscall code */
d7290 1
a7290 1
		as_warn (_("Illegal syscall code (%ld)"),
d7311 11
d7347 1
d7461 4
@


1.26
log
@2000-09-20  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-m32r.c: Fix formatting.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68851.h: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.h: Likewise.
@
text
@d7876 2
a7877 2
		      || (S_GET_SEGMENT (offset_expr.X_op_symbol)
			  != now_seg)))
@


1.25
log
@Add support for the MIPS32
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 1999, 2000 Free Software Foundation, Inc.
d7273 1
a7273 1
	      
d7275 1
a7275 1
	      
d7282 1
a7282 1
	      
d7286 1
a7286 1
	      
@


1.24
log
@2000-09-07  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-mips.c: Fix formatting.
@
text
@d266 1
a266 1
#define hilo_interlocks (mips_cpu == 4010                           \
d273 1
a273 1
   || mips_cpu == 3900)
d278 1
a278 1
#define cop_interlocks (mips_cpu == 4300                            \
d333 1
a333 1
static int g_switch_value = 8;
d510 1
a510 1
static const int mips16_to_32_reg_map[] =
d644 1
a644 1
static int reg_needs_delay PARAMS ((int));
d708 1
d854 32
a885 4
/*
 * This function is called once, at assembler startup time.  It should
 * set up all the tables, etc. that the MD part of the assembler will need.
 */
d891 1
a891 1
  register unsigned int i = 0;
d924 1
a924 1
	    mips_cpu = 3000;
d927 1
a927 1
            mips_cpu = 6000;
d930 1
a930 1
            mips_cpu = 4000;
d933 1
a933 1
            mips_cpu = 8000;
d936 1
a936 1
            mips_cpu = 3000;
d942 1
a942 1
        mips_cpu = 3900;
d946 1
a946 1
        mips_cpu = 6000;
d951 1
a951 1
        mips_cpu = 4000;
d954 1
a954 1
        mips_cpu = 4400;
d958 1
a958 1
        mips_cpu = 4600;
d961 1
a961 1
        mips_cpu = 4650;
d964 1
a964 1
        mips_cpu = 4300;
d967 1
a967 1
        mips_cpu = 4111;
d970 1
a970 1
        mips_cpu = 4100;
d973 6
a978 1
        mips_cpu = 4010;
d982 1
a982 1
        mips_cpu = 5000;
d986 1
a986 1
        mips_cpu = 8000;
d989 1
a989 1
        mips_cpu = 10000;
d995 1
a995 1
        mips_cpu = 3000;
d998 2
a999 2
  if (mips_cpu == 3000
      || mips_cpu == 3900)
d1002 2
a1003 2
  else if (mips_cpu == 6000
	   || mips_cpu == 4010)
d1006 7
a1012 7
  else if (mips_cpu == 4000
	   || mips_cpu == 4100
	   || mips_cpu == 4111
	   || mips_cpu == 4400
	   || mips_cpu == 4300
	   || mips_cpu == 4600
	   || mips_cpu == 4650)
d1015 3
a1017 3
  else if (mips_cpu == 5000
	   || mips_cpu == 8000
               || mips_cpu == 10000)
d1044 2
a1045 2
    free (a);
    a = NULL;
d1075 1
a1075 1
	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, 3000);
d1078 1
a1078 1
	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, 6000);
d1081 1
a1081 1
	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, 4000);
d1084 1
a1084 1
	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, 8000);
d1419 1
a1419 1
     int reg;
d1662 1
a1662 1
		 || (mips_cpu == 3900 && (pinfo & INSN_MULT)))
d1684 1
a1684 1
		 || (mips_cpu == 3900 && (pinfo & INSN_MULT)))
d1723 1
a1723 1
		    || (mips_cpu == 3900 && (pinfo & INSN_MULT))))
d1727 1
a1727 1
		    || (mips_cpu == 3900 && (pinfo & INSN_MULT)))))
d1744 1
a1744 1
	  && ip->insn_opcode == (mips_opts.mips16 ? 0x6500 : 0))
d2077 1
a2077 1
		     || (mips_cpu == 3900 && (pinfo & INSN_MULT)))
d2561 1
a2561 1
	  && (mips_cpu != 4650 || (insn.insn_mo->pinfo & FP_D) == 0))
d4876 1
a4876 1
      if (mips_cpu == 4650)
d4965 1
a4965 1
      if (mips_cpu == 4650)
d5453 1
a5453 1
      if (mips_cpu == 4650)
d5494 1
a5494 1
      if (mips_cpu == 4650)
d5512 1
a5512 1
      if (mips_cpu == 4650)
d6141 1
a6141 1
      if (mips_cpu == 4650)
d6984 1
d7004 1
d7117 1
a7117 1
	  if (mips_cpu == 4650 && (insn->pinfo & FP_D) != 0)
d7133 2
a7134 2
		       _("opcode not supported on this processor: %d (MIPS%d)"),
		       mips_cpu, mips_opts.isa);
d7270 18
d7641 1
a7641 1
		assert (length == (f64 ? 8 : 4));
d7951 22
d8892 2
a8893 1
struct option md_longopts[] = {
d8907 1
a8907 5

#define OPTION_CALL_SHARED (OPTION_MD_BASE + 7)
#define OPTION_NON_SHARED (OPTION_MD_BASE + 8)

#define OPTION_TRAP (OPTION_MD_BASE + 9)
d8910 1
a8910 1
#define OPTION_BREAK (OPTION_MD_BASE + 10)
d8913 1
a8913 1
#define OPTION_EB (OPTION_MD_BASE + 11)
d8915 1
a8915 1
#define OPTION_EL (OPTION_MD_BASE + 12)
d8917 1
a8917 1
#define OPTION_M4650 (OPTION_MD_BASE + 13)
d8919 1
a8919 1
#define OPTION_NO_M4650 (OPTION_MD_BASE + 14)
d8921 1
a8921 1
#define OPTION_M4010 (OPTION_MD_BASE + 15)
d8923 1
a8923 1
#define OPTION_NO_M4010 (OPTION_MD_BASE + 16)
d8925 1
a8925 1
#define OPTION_M4100 (OPTION_MD_BASE + 17)
d8927 1
a8927 1
#define OPTION_NO_M4100 (OPTION_MD_BASE + 18)
d8929 1
a8929 6

#define OPTION_XGOT (OPTION_MD_BASE + 19)
#define OPTION_32 (OPTION_MD_BASE + 20)
#define OPTION_64 (OPTION_MD_BASE + 21)

#define OPTION_MIPS16 (OPTION_MD_BASE + 22)
d8931 1
a8931 1
#define OPTION_NO_MIPS16 (OPTION_MD_BASE + 23)
d8933 1
a8933 2

#define OPTION_M3900 (OPTION_MD_BASE + 26)
d8935 1
a8935 1
#define OPTION_NO_M3900 (OPTION_MD_BASE + 27)
d8937 1
a8937 2

#define OPTION_MABI (OPTION_MD_BASE + 38)
d8939 1
a8939 2

#define OPTION_M7000_HILO_FIX (OPTION_MD_BASE + 39)
d8941 1
a8941 1
#define OPTION_NO_M7000_HILO_FIX (OPTION_MD_BASE + 40)
d8943 12
d8957 7
a8963 2
  {"KPIC", no_argument, NULL, OPTION_CALL_SHARED},
  {"xgot", no_argument, NULL, OPTION_XGOT},
d8965 4
a8968 3
  {"non_shared", no_argument, NULL, OPTION_NON_SHARED},
  {"32", no_argument, NULL, OPTION_32},
  {"64", no_argument, NULL, OPTION_64},
a8970 11
#define OPTION_GP32 (OPTION_MD_BASE + 41)
#define OPTION_GP64 (OPTION_MD_BASE + 42)
  {"mgp32", no_argument, NULL, OPTION_GP32},
  {"mgp64", no_argument, NULL, OPTION_GP64},

#define OPTION_CONSTRUCT_FLOATS (OPTION_MD_BASE + 43)
  {"construct-floats", no_argument, NULL, OPTION_CONSTRUCT_FLOATS},

#define OPTION_NO_CONSTRUCT_FLOATS (OPTION_MD_BASE + 44)
  {"no-construct-floats", no_argument, NULL, OPTION_NO_CONSTRUCT_FLOATS},

d8973 1
a8973 1
size_t md_longopts_size = sizeof(md_longopts);
d9072 1
a9072 1
		  mips_cpu = 10000;
d9079 1
a9079 1
		  mips_cpu = 2000;
d9086 1
a9086 1
		  mips_cpu = 3000;
d9088 1
a9088 1
                  mips_cpu = 3900;
d9095 1
a9095 1
		  mips_cpu = 4000;
d9097 1
a9097 1
                    mips_cpu = 4100;
d9099 1
a9099 1
                    mips_cpu = 4111;
d9101 1
a9101 1
		  mips_cpu = 4300;
d9103 1
a9103 1
		  mips_cpu = 4400;
d9105 1
a9105 1
		  mips_cpu = 4600;
d9107 1
a9107 1
		    mips_cpu = 4650;
d9109 5
a9113 1
                  mips_cpu = 4010;
d9120 1
a9120 1
		  mips_cpu = 5000;
d9127 1
a9127 1
		  mips_cpu = 6000;
d9134 1
a9134 1
		  mips_cpu = 8000;
d9139 1
a9139 1
		  mips_cpu = 4600;
d9152 1
a9152 1
		    mips_cpu = 5000;
d9160 4
a9163 4
		&& (mips_cpu != 4300
		    && mips_cpu != 4100
		    && mips_cpu != 4111
		    && mips_cpu != 5000))
d9179 1
a9179 1
      mips_cpu = 4650;
d9186 1
a9186 1
      mips_cpu = 4010;
d9193 1
a9193 1
      mips_cpu = 4100;
d9199 7
d9207 1
a9207 1
      mips_cpu = 3900;
d9419 3
d9436 3
@


1.23
log
@*** empty log message ***
@
text
@d206 1
a206 1
/* The argument of the -mabi= flag. */
d209 1
a209 1
/* Wether we should mark the file EABI64 or EABI32. */
d213 1
a213 1
   mips3 or greater, then mark the object file 32BITMODE. */
d216 1
a216 1
/* True if -mgp32 was passed. */
d221 1
a221 1
   Return true if instructions marked INSN_LOAD_COPROC_DELAY, 
d226 1
a226 1
   have delays for the INSN_LOAD_MEMORY_DELAY instructions either. */
d233 1
a233 1
/*  Return true if ISA supports 64 bit gp register instructions. */
d239 1
a239 1
/* Whether the processor uses hardware interlocks to protect 
d277 1
a277 1
/* Itbl support may require additional care here. */
d369 1
a369 1
   #NO_APP at the beginning of its output. */
d373 1
a373 1
/* This array holds machine specific line separator characters. */
d465 1
a465 1
   prev_nop_frag. */
d480 1
a480 1
   corresponding LO relocation. */
a708 1

d890 1
a890 1
         on the given ISA, if any. */
d895 1
a895 1
	    mips_cpu = 3000;   
d906 1
a906 1
          else 
d909 1
a909 1
      
a945 1

a949 2


d953 1
a953 1
      
d1006 1
a1006 1
     if necessary. */
d1019 1
a1019 1
     the best, but then neither is basing the abi on the isa. */     
d1028 1
a1028 1
      
d1030 1
a1030 1
	 mips3 or greater, then mark the object file 32BITMODE. */
d1032 1
a1032 1
	  && ! ISA_HAS_64BIT_REGS (mips_opts.isa) 
a1188 1

d1191 1
a1191 1
	
d1271 1
a1271 1
      DBG((_("returned from mips_ip(%s) insn_opcode = 0x%x\n"), 
d1400 1
a1400 1
      /* Itbl support may require additional care here. */
d1504 1
a1504 1
          /* Itbl support may require additional care here. */
d1535 1
a1535 1
             Need to modify this to include knowledge about 
d1563 1
a1563 1
              /* Itbl support may require additional care here. */
d1582 1
a1582 1
          /* Itbl support may require additional care here. */
d1613 1
a1613 1
     
d1617 1
a1617 1
 
d1622 2
a1623 2
	     insert two NOPS.  Some newer processors have interlocks. 
	     Also the tx39's multiply instructions can be exectuted 
d1625 2
a1626 2
             though the tx39's divide insns still do require the 
	     delay. */
d1637 1
a1637 1
	     between a read and an immediately following branch. */
d1648 1
a1648 1
	     Also the note tx39's multiply above. */
d1659 1
a1659 1
	     between a read and an immediately following branch. */
d1668 1
a1668 1
      /* Itbl support may require additional care here. */
d1761 1
a1761 1
             need some nops, we count them in prev_nops_required. */
a1861 1

d1934 4
a1937 4
	  /* We don't keep enough information to sort these cases out. 
	     The itbl support does keep this information however, although 
	     we currently don't support itbl fprmats as part of the cop 
	     instruction.  May want to add this support in the future. */
d1987 1
a1987 1
		 swap. */
d2038 1
a2038 1
              /* Itbl support may require additional care here. */
d2052 1
a2052 1
                  /* Itbl support may require additional care here. */
d2157 1
a2157 1
              /* Itbl support may require additional care here. */
d2183 2
a2184 2
	      /* If the previous instruction is a sync, sync.l, or 
		 sync.p, we can not swap. */
d2332 1
a2332 1
   know whether nops are needed before a noreorder section. */
d2360 1
a2360 1
   instructions are to follow. */
d2384 1
a2384 1
	      && (prev_insn.insn_mo->pinfo 
d2391 1
a2391 1
          /* Itbl support may require additional care here. */
d2413 1
a2413 1
          /* Itbl support may require additional care here. */
d2439 1
a2439 1
                 decrease the size of prev_nop_frag. */
d2525 1
a2525 1
	  && OPCODE_IS_MEMBER (insn.insn_mo, mips_opts.isa, mips_cpu, 
d4655 1
a4655 1
      
d4761 1
a4761 1
	    }			   
d4815 1
a4815 1
      /* Itbl support may require additional care here. */
d4820 1
a4820 1
      /* Itbl support may require additional care here. */
d4825 1
a4825 1
      /* Itbl support may require additional care here. */
d4830 1
a4830 1
      /* Itbl support may require additional care here. */
d4848 1
a4848 1
      /* Itbl support may require additional care here. */
d4853 1
a4853 1
      /* Itbl support may require additional care here. */
d4858 1
a4858 1
      /* Itbl support may require additional care here. */
d4900 1
a4900 1
      /* Itbl support may require additional care here. */
d4905 1
a4905 1
      /* Itbl support may require additional care here. */
d4910 1
a4910 1
      /* Itbl support may require additional care here. */
d4915 1
a4915 1
      /* Itbl support may require additional care here. */
d4938 1
a4938 1
      /* Itbl support may require additional care here. */
d4942 1
a4942 1
      /* Itbl support may require additional care here. */
d4947 1
a4947 1
      /* Itbl support may require additional care here. */
d4959 1
a4959 1
      /* Itbl support may require additional care here. */
d5091 1
a5091 1
	  p = frag_var (rs_machine_dependent, 4, 0, 
d5316 1
a5316 1
	
d5400 1
a5400 1
	      
d5465 1
a5465 1
      /* Itbl support may require additional care here. */
d5492 1
a5492 1
      /* Itbl support may require additional care here. */
d5528 1
a5528 1
      /* Itbl support may require additional care here. */
d5579 1
a5579 1
              /* Itbl support may require additional care here. */
d5589 1
a5589 1
              /* Itbl support may require additional care here. */
d5635 1
a5635 1
          /* Itbl support may require additional care here. */
d5643 1
a5643 1
          /* Itbl support may require additional care here. */
d5647 1
a5647 1
	}	  
d5688 1
a5688 1
          /* Itbl support may require additional care here. */
d5698 1
a5698 1
          /* Itbl support may require additional care here. */
d5762 1
a5762 1
          /* Itbl support may require additional care here. */
d5772 1
a5772 1
          /* Itbl support may require additional care here. */
d5806 1
a5806 1
          /* Itbl support may require additional care here. */
d5817 1
a5817 1
          /* Itbl support may require additional care here. */
d5849 1
a5849 1
          /* Itbl support may require additional care here. */
d5854 1
a5854 1
          /* Itbl support may require additional care here. */
d5873 1
a5873 1
      assert (bfd_arch_bits_per_address (stdoutput) == 32 
d5894 1
a5894 1
      What registers are read/set/modified? 
d5897 1
a5897 1
      this knowledge can be encoded in the itbl spec. */
d5923 1
a5923 1
         We may want to have the assembler assemble this value, 
d5927 1
a5927 1
      if (itbl_have_entries 
d5942 1
a5942 1
          
d5965 1
a5965 1
          
d5970 1
a5970 1
          
d5975 1
a5975 1
          
d6659 1
a6659 1
	 are added dynamically. */
d6719 1
a6719 1
      
d7033 1
a7033 1
	
d7041 1
a7041 1
      /* Restore the character we overwrite above (if any).  */ 
d7076 1
a7076 1
      else 
d7078 1
a7078 1
      
d7096 1
a7096 1
	      sprintf (buf, 
d7099 1
a7099 1
		       
d7143 1
a7143 1
		 we must have a left paren. */
a7186 1

d7351 1
a7351 1
			      if (p) 
d7353 1
a7353 1
			      else 
d7384 2
a7385 2
	/* Now that we have assembled one operand, we use the args string 
	 * to figure out where it goes in the instruction. */
a7505 1

d8798 1
a8798 1
     
d8860 1
a8860 1
  
d8913 1
a8913 1
      
d8917 1
a8917 1
      
d9082 1
a9082 1
	    
a9122 1

d9126 1
a9126 1
      
d9229 1
a9229 1
	 This is unnecessarily restrictive.  
d9233 1
a9233 1
	 multilibs will break too many systems. */
a9267 1

a9297 1

d9583 1
a9583 1
    if (S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16 
d9599 1
a9599 1
               the addend to appear in the object file.  
d9659 1
a9659 1
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour 
d9684 1
a9684 1
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour 
d9780 1
a9780 1
      
d10281 1
a10281 1
	     needed. */
d10560 1
a10560 1
  demand_empty_rest_of_line ();  
d10627 1
a10627 1
      
d10633 1
a10633 1
      
d10938 1
a10938 1
	     higher. */
d11594 1
a11594 1
  /* Set the MIPS ELF ABI flags. */
d11653 1
a11653 1
      	frag_align_pattern (n, be_nop, 2, max);      
d11655 1
a11655 1
      	frag_align_pattern (n, le_nop, 2, max);      
a11738 1

d11881 1
a11881 1
   then ecoff.c (ecoff_directive_frame) is used. For embedded targets, 
d11883 1
a11883 1
   We can't use the ecoff routines because they make reference to the ecoff 
d11922 2
a11923 2
/* The .fmask and .mask directives. If the mdebug section is present 
   (IRIX 5 native) then ecoff.c (ecoff_directive_mask) is used. For 
d11925 1
a11925 1
   information correctly. We can't use the ecoff routines because they 
d11934 1
a11934 1
  
@


1.22
log
@Add new command line switch --no-construct-floats
@
text
@d320 1
a320 1
   in the status register, and the settin gof this bit cannot be determined
@


1.21
log
@Fix comments.
@
text
@d316 8
d7612 1
d8838 4
d8864 5
d8873 1
a8878 1

a8886 5
#define OPTION_CALL_SHARED (OPTION_MD_BASE + 7)
#define OPTION_NON_SHARED (OPTION_MD_BASE + 8)
#define OPTION_XGOT (OPTION_MD_BASE + 19)
#define OPTION_32 (OPTION_MD_BASE + 20)
#define OPTION_64 (OPTION_MD_BASE + 21)
d8901 6
d8918 8
d9368 1
@


1.20
log
@2000-07-01  Koundinya K  <kk@@ddeorg.soft.net>

        * configure.in: Add entry for mips-*-sysv4*MP*
        * configure: Rebuild
        * config/tc-mips.c (mips_target_format): Return elf32-tradbigmips or
        elf32-tradlittlemips for traditional mips targets.
        * config/tc-mips.c (md_estimate_size_before_relax): Duplicate the
        test for Link Once sections as in adjust_reloc_syms.
        * config/te-tmips.h: New file for traditional mips targets. Define
        TE_TMIPS.
@
text
@d8745 2
a8746 2
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP .  An error message is
@


1.19
log
@16 bit immediate expr support for mips
@
text
@d124 5
d132 1
d10997 1
d11040 15
d11059 1
@


1.18
log
@Add -mcpu=rmXXXX switch.
@
text
@d7749 2
a7750 4
		      if (imm_expr.X_op != O_constant
			  && imm_expr.X_op != O_big)
			insn_error = _("absolute expression required");
		      else
d7786 2
a7787 4
		      if (imm_expr.X_op != O_constant
			  && imm_expr.X_op != O_big)
			insn_error = _("absolute expression required");
		      else
@


1.17
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d9044 16
d9061 1
a9061 1

@


1.16
log
@Fix compile time warning messages.
@
text
@d360 1
a360 1
const char line_separator_chars[] = "";
@


1.15
log
@(md_estimate_size_before_relax): Use the external version of
the relocation for weak symbols.
@
text
@d186 1
a186 1
static struct mips_set_options mips_opts = { -1, -1 };
d410 1
a410 1
static const struct mips_opcode dummy_opcode = { 0 };
d759 1
a759 1
  { 0 },
d776 1
a776 1
  { 0 },
d2663 1
a2663 1
     int *counter;
d3446 1
a3446 1
  int used_at;
d6411 1
a6412 1
    case M_TRUNCWS:
d7000 1
a7000 1
  char c;
d7086 1
a7086 1
	    {
d9366 1
a9366 1
     fragS *frag;
d9943 1
a9943 1
     int x;
d10137 1
a10137 1
     int x;
d10178 1
a10178 1
     int x;
d10231 1
a10231 1
     int x;
d10367 1
a10367 1
     int ignore;
d10392 1
a10392 1
     int ignore;
d10432 1
a10432 1
     int ignore;
d10465 1
a10465 1
     int ignore;
d10505 1
a10505 1
     int ignore;
d10539 1
a10539 1
     int ignore;
d10568 1
a10568 1
     int ignore;
d10978 1
a10978 1
  int change;
d11086 1
a11086 1
     asection *section;
d11327 1
a11327 1
     bfd *abfd;
d11587 1
a11587 1
     int len;
d11679 1
a11679 1
     int x;
d11692 1
a11692 1
     int x;
@


1.14
log
@Use record_alignment, not bfd_set_section_alignment.
@
text
@d11024 6
a11029 1
		&& ! bfd_is_com_section (symsec));
@


1.13
log
@In bfd/:
	* elf32-mips.c (mips_elf_next_relocation): Rename from
	mips_elf_next_lo16_relocation, and generalize to look
	for any relocation type.
	(elf_mips_howto_table): Make R_MIPS_PC16 pcrel_offset.
	(elf_mips_gnu_rel_hi16): Howto for R_MIPS_GNU_REL_HI16.
	(elf_mips_gnu_rel_lo16): Howto for R_MIPS_GNU_REL_LO16.
	(elf_mips_gnu_rel16_s2): Howto for R_MIPS_GNU_REL16_S2.
	(elf_mips_gnu_pcrel64): Howto for R_MIPS_PC64.
	(elf_mips_gnu_pcrel32): Howto for R_MIPS_PC32.
	(bfd_elf32_bfd_reloc_type_lookup): Add new relocs.
	(mips_rtype_to_howto): Likewise.
	(mips_elf_calculate_relocation): Handle new relocs.
	(_bfd_mips_elf_relocate_section): REL_HI16/REL_LO16 relocs
	are paired.  The addend for R_MIPS_GNU_REL16_S2
	is shifted right two bits.
In gas/:
	* config/tc-mips.c (mips_ip): Don't put stuff in .rodata
	when embedded-pic.

	* config/tc-mips.c (SWITCH_TABLE): The ELF embedded-pic
 	implementation doesn't have special handling for switch
 	statements.
	(macro_build): Allow for code in sections other than .text.
	(macro): Likewise.
	(mips_ip): Likewise.
	(md_apply_fix): Do pc-relative relocation madness for MIPS ELF.
  	Don't perform relocs if we will be outputting them.
	(tc_gen_reloc): For ELF, just use fx_addnumber for pc-relative
 	relocations.  Allow BFD_RELOC_16_PCREL_S2 relocs when
 	embedded-pic.
In gas/testsuite/:
	* gas/mips/empic.d: New file.
	* gas/mips/empic.s: New file.
	* gas/mips/mips16-e.d: New file.
	* gas/mips/mips16-e.s: New file.
	* gas/mips/mips16-f.d: New file.
	* gas/mips/mips16-f.s: New file.
	* gas/mips/mips.exp: Add empic, mips16-e.  Add mips16-f as an
	expected failure.
In include/elf:
	* mips.h: Add R_MIPS_GNU_REL_HI16, R_MIPS_GNU_REL_LO16,
 	R_MIPS_GNU_REL16_S2, R_MIPS_PC64 and R_MIPS_PC32 relocation
 	numbers.
@
text
@d10048 1
a10048 1
		bfd_set_section_alignment (stdoutput, seg, 4);
d10070 1
a10070 1
		bfd_set_section_alignment (stdoutput, seg, 4);
@


1.12
log
@Add support for WinCE targeted toolchains.
@
text
@a2599 1
		      && now_seg == text_section
a2612 1
			  && now_seg == text_section
d4151 1
a4151 1
	 where bar is an address in the .text section.  These are used
a4157 1
	  && now_seg == text_section
d4159 1
a4159 1
	      ? S_GET_SEGMENT (offset_expr.X_op_symbol) == text_section
d4164 1
a4164 1
		     == text_section)))
d4166 2
a4167 1
	  && offset_expr.X_add_number == 0)
d7667 2
a7668 1
			if (USE_GLOBAL_POINTER_OPT && g_switch_value >= 8)
d7672 4
a7675 1
			newname = RDATA_SECTION_NAME;
a7817 1
		      || now_seg != text_section
d7819 1
a7819 1
			  != text_section)))
d9499 1
d9547 1
d9552 5
a9556 5
					 S_GET_SEGMENT (fixP->fx_addsy))
		  & SEC_LINK_ONCE) != 0)
		|| !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
			     ".gnu.linkonce",
			     sizeof (".gnu.linkonce") - 1))))
d9564 2
a9565 1
               the addend to appear in the object file.  */
d9569 17
a9587 1

d9624 6
a9629 1
      if ((symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_SECTION_SYM) == 0)
d9649 6
a9654 1
      if ((symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_SECTION_SYM) == 0)
d9737 9
d11106 2
a11131 2
  else if (fixp->fx_pcrel == 0)
    reloc->addend = fixp->fx_addnumber;
d11270 2
a11271 1
  if (OUTPUT_FLAVOR == bfd_target_ecoff_flavour
a11935 3


  
@


1.11
log
@1999-12-30  Andrew Haley  <aph@@cygnus.com>

	* config/tc-mips.c (mips_gp32): New variable.
	(macro_build) Use mips_gp32.
	(mips_ip): Ditto.
	(md_longopts): Add "-mgp32" and "-mgp64".
	(md_parse_option): Add OPTION_GP32 and OPTION_GP64.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d121 2
d138 2
d855 9
d9661 1
@


1.10
log
@           * config/tc-mips.c (MF_HILO_INSN): Define.
           (mips_7000_hilo_fix): Declare.
           (append_insn): Conditionally insert nops after an mfhi/mflo insn.
           (md_parse_option): Check for 7000_HILO_FIX options.
           (OPTION_M7000_HILO_FIX): Define.
           (OPTION_NO_M7000_HILO_FIX): Define.
           * doc/c-mips.texi (-mfix7000): Describe.
@
text
@d206 3
d2504 2
a2505 1
	  && OPCODE_IS_MEMBER (insn.insn_mo, mips_opts.isa, mips_cpu)
d7055 1
a7055 1
      if (OPCODE_IS_MEMBER (insn, mips_opts.isa, mips_cpu))
d8867 5
d9172 21
@


1.9
log
@2000-01-13  Clinton Popetz  <cpopetz@@cygnus.com>

        * config/tc-mips.c (mips_do_align): New function.
        * config/tc-mips.h (md_do_align): Define.
@
text
@d268 4
d307 4
d1562 31
d8844 5
d9171 8
@


1.8
log
@For include/opcode:

	* mips.h (OPCODE_IS_MEMBER): New.

For gas:

	* config/tc-mips.c (macro_build): Use OPCODE_IS_MEMBER.
	(mips_ip): Use OPCODE_IS_MEMBER.

For opcodes:

	* mips-dis.c (_print_insn_mips): Use OPCODE_IS_MEMBER.
@
text
@d11439 30
@


1.7
log
@	* config/tc-mips.c (ISA_HAS_COPROC_DELAYS) : New.
	(ISA_HAS_64_BIT_REGS) New.
	(gpr_interlocks,md_begin,reg_needs_delay,append_insn,
	mips_emit_delays,macro_build,load_register,load_addresss,
	macro,macro2,mips_ip,s_cprestore,s_cpadd): Simplify
	and/or use new ISA_xxx macros in expressions involving
	ISA, particularly mips_opts.isa.
@
text
@a2426 1
  int insn_isa;
a2459 11
      insn_isa = 0;

      if ((insn.insn_mo->membership & INSN_ISA) == INSN_ISA1)
	insn_isa = 1;
      else if ((insn.insn_mo->membership & INSN_ISA) == INSN_ISA2)
	insn_isa = 2;
      else if ((insn.insn_mo->membership & INSN_ISA) == INSN_ISA3)
	insn_isa = 3;
      else if ((insn.insn_mo->membership & INSN_ISA) == INSN_ISA4)
	insn_isa = 4;

d2462 1
a2462 12
	  && ((insn_isa != 0
	       && insn_isa <= mips_opts.isa)
	      || (mips_cpu == 4650
		  && (insn.insn_mo->membership & INSN_4650) != 0)
	      || (mips_cpu == 4010
		  && (insn.insn_mo->membership & INSN_4010) != 0)
	      || ((mips_cpu == 4100
		   || mips_cpu == 4111
		   )
		  && (insn.insn_mo->membership & INSN_4100) != 0)
	      || (mips_cpu == 3900
		  && (insn.insn_mo->membership & INSN_3900) != 0))
a7007 1
      int insn_isa;
d7012 1
a7012 12
      insn_isa = 0;
      if ((insn->membership & INSN_ISA) == INSN_ISA1)
	insn_isa = 1;
      else if ((insn->membership & INSN_ISA) == INSN_ISA2)
	insn_isa = 2;
      else if ((insn->membership & INSN_ISA) == INSN_ISA3)
	insn_isa = 3;
      else if ((insn->membership & INSN_ISA) == INSN_ISA4)
	insn_isa = 4;

      if (insn_isa != 0 
	  && insn_isa <= mips_opts.isa)
d7014 1
a7014 1
      else if (insn->pinfo == INSN_MACRO)
d7016 1
a7016 11
      else if ((mips_cpu == 4650 && (insn->membership & INSN_4650) != 0)
	       || (mips_cpu == 4010 && (insn->membership & INSN_4010) != 0)
	       || ((mips_cpu == 4100
		    || mips_cpu == 4111
		    )
		   && (insn->membership & INSN_4100) != 0)
	       || (mips_cpu == 3900 && (insn->membership & INSN_3900) != 0))
	ok = true;
      else
	ok = false;

a7030 4

	  if (insn_isa == 0
              || insn_isa <= mips_opts.isa)
	    insn_error = _("opcode not supported on this processor");
d7034 4
a7037 2

	      sprintf (buf, _("opcode requires -mips%d or greater"), insn_isa);
d7039 1
a7040 1
	  return;
@


1.6
log
@* config/tc-mips.c (nopic_need_relax): Allow for the
.sdata.foo sections generated by -fdata-sections,
and for the .gnu.linkonce.s sections generated by C++.
@
text
@d206 20
d259 1
a259 1
  (mips_opts.isa >= 2  \
d857 2
a858 2
          if (mips_opts.isa < 0)
            mips_cpu = 3000;   
d860 1
a860 1
          else if (mips_opts.isa == 2)
d980 1
a980 1
  if (mips_opts.isa < 2 && mips_trap)
d986 1
a986 1
  if (mips_opts.isa > 2 
d994 1
a994 1

d998 2
a999 1
	  && mips_opts.isa <= 2 && mips_isa_from_cpu > 2)
d1358 1
a1358 1
      && mips_opts.isa < 4
d1461 1
a1461 1
	  && mips_opts.isa < 4
d1481 1
a1481 1
	       && mips_opts.isa < 4
d1484 1
a1484 1
		   || (mips_opts.isa < 2
d1540 1
a1540 1
	       && mips_opts.isa < 4
d1617 1
a1617 1
	   && mips_opts.isa < 4
d1967 1
a1967 1
		  && mips_opts.isa < 4
d1973 1
a1973 1
		  && mips_opts.isa < 4
d1988 1
a1988 1
		  && mips_opts.isa < 2
d2093 1
a2093 1
		  && mips_opts.isa < 4
d2309 1
a2309 1
	   && mips_opts.isa < 4
d2324 1
a2324 1
	      && mips_opts.isa < 2
d2331 1
a2331 1
	       && mips_opts.isa < 4
d2343 1
a2343 1
		&& mips_opts.isa < 4
d2461 2
a2470 2
      else
	insn_isa = 15;
d2474 2
a2475 1
	  && (insn_isa <= mips_opts.isa
d2985 1
a2985 1
	       || ((mips_opts.isa < 3 || ! dbl)
d2987 1
a2987 1
	       || (mips_opts.isa < 3
d3004 1
a3004 1
  if (mips_opts.isa < 3)
d3245 1
a3245 1
			 || mips_opts.isa < 3)
d3258 1
a3258 1
		     || mips_opts.isa < 3)
d3278 1
a3278 1
		     || mips_opts.isa  < 3)
d3287 1
a3287 1
		     || mips_opts.isa  < 3)
d3297 1
a3297 1
			 || mips_opts.isa  < 3)
d3328 1
a3328 1
		     || mips_opts.isa  < 3)
d3333 1
a3333 1
		     || mips_opts.isa  < 3)
d3351 1
a3351 1
		     || mips_opts.isa  < 3)
d3359 1
a3359 1
		     || mips_opts.isa  < 3)
d3369 1
a3369 1
		         || mips_opts.isa  < 3)
d3381 1
a3381 1
		     || mips_opts.isa  < 3)
d3589 1
a3589 1
      if (mips_opts.isa >= 3 && sizeof (maxnum) > 4)
d3598 1
a3598 1
	  && (mips_opts.isa < 3 || sizeof (maxnum) > 4))
d3638 1
a3638 1
      if (mips_opts.isa >= 3 && sizeof (maxnum) > 4)
d3648 1
a3648 1
	  && (mips_opts.isa < 3 || sizeof (maxnum) > 4))
d3685 1
a3685 1
	  || (mips_opts.isa < 3
d3781 1
a3781 1
      if (mips_opts.isa >= 3 && sizeof (maxnum) > 4)
d3790 1
a3790 1
	  && (mips_opts.isa < 3 || sizeof (maxnum) > 4))
d3843 1
a3843 1
	  || (mips_opts.isa < 3
d4142 1
a4142 1
		         || mips_opts.isa  < 3)
d4185 1
a4185 1
		     	     || mips_opts.isa  < 3)
d4199 1
a4199 1
			 || mips_opts.isa  < 3)
d4266 1
a4266 1
			     || mips_opts.isa < 3)
d4280 1
a4280 1
			     || mips_opts.isa < 3)
d4307 1
a4307 1
				 || mips_opts.isa < 3)
d4324 1
a4324 1
			     || mips_opts.isa < 3)
d4329 1
a4329 1
			     || mips_opts.isa < 3)
d4390 1
a4390 1
			 || mips_opts.isa < 3)
d4429 1
a4429 1
			     || mips_opts.isa < 3)
d4464 1
a4464 1
				 || mips_opts.isa < 3)
d4480 1
a4480 1
			     || mips_opts.isa < 3)
d4485 1
a4485 1
			     || mips_opts.isa < 3)
d4519 1
a4519 1
			     || mips_opts.isa < 3)
d4539 1
a4539 1
				 || mips_opts.isa < 3)
d4553 1
a4553 1
			     || mips_opts.isa < 3)
d4559 1
a4559 1
			     || mips_opts.isa < 3)
d4572 1
a4572 1
			 || mips_opts.isa < 3)
d4582 1
a4582 1
		       || mips_opts.isa < 3)
d4626 1
a4626 1
			     || mips_opts.isa < 3)
d4669 1
a4669 1
			     || mips_opts.isa < 3)
d4692 1
a4692 1
			     || mips_opts.isa < 3)
d4697 1
a4697 1
			     || mips_opts.isa < 3)
d4715 1
a4715 1
			     || mips_opts.isa < 3)
d4725 1
a4725 1
			 || mips_opts.isa < 3)
d4741 1
a4741 1
			     || mips_opts.isa < 3)
d4998 1
a4998 1
				 || mips_opts.isa < 3)
d5013 1
a5013 1
			     || mips_opts.isa < 3)
d5048 1
a5048 1
			 || mips_opts.isa < 3)
d5058 1
a5058 1
			 || mips_opts.isa < 3)
d5064 1
a5064 1
			   || mips_opts.isa < 3)
d5105 1
a5105 1
			 || mips_opts.isa < 3)
d5110 1
a5110 1
			 || mips_opts.isa < 3)
d5124 1
a5124 1
			 || mips_opts.isa < 3)
d5132 1
a5132 1
			 || mips_opts.isa < 3)
d5138 1
a5138 1
			   || mips_opts.isa < 3)
d5163 1
a5163 1
			     || mips_opts.isa < 3)
d5214 1
a5214 1
	  if (mips_opts.isa >= 3)
d5259 1
a5259 1
			 || mips_opts.isa < 3)
d5269 1
a5269 1
			 || mips_opts.isa < 3)
d5279 1
a5279 1
      if (mips_opts.isa >= 3)
d5310 2
a5311 2
	  load_register (&icnt, AT, &imm_expr, mips_opts.isa >= 3);
	  if (mips_opts.isa >= 3)
d5337 1
a5337 1
	  if (mips_opts.isa >= 2)
d5353 1
a5353 1
			   || mips_opts.isa < 3)
d5362 1
a5362 1
	  if (mips_opts.isa >= 2)
d5389 1
a5389 1
      assert (mips_opts.isa < 2);
d5428 1
a5428 1
      if (mips_opts.isa >= 2)
d5445 1
a5445 1
      if (mips_opts.isa >= 2)
d5458 1
a5458 1
      if (mips_opts.isa >= 3)
d5469 1
a5469 1
      if (mips_opts.isa >= 3)
d5532 1
a5532 1
				 || mips_opts.isa < 3)
d5590 1
a5590 1
			     || mips_opts.isa < 3)
d5639 1
a5639 1
			 || mips_opts.isa < 3)
d5646 1
a5646 1
			   || mips_opts.isa < 3)
d5708 1
a5708 1
			 || mips_opts.isa < 3)
d5713 1
a5713 1
			 || mips_opts.isa < 3)
d5720 1
a5720 1
			   || mips_opts.isa < 3)
d5752 1
a5752 1
			 || mips_opts.isa < 3)
d5762 1
a5762 1
			     || mips_opts.isa < 3)
d5803 1
a5803 1
			     || mips_opts.isa < 3)
d5834 2
a5835 1
      assert (bfd_arch_bits_per_address (stdoutput) == 32 || mips_opts.isa < 3);
d6073 1
a6073 1
      assert (mips_opts.isa < 2);
d6130 1
a6130 1
			 || mips_opts.isa < 3)
d6283 1
a6283 1
			 || mips_opts.isa < 3)
d6303 1
a6303 1
			 || mips_opts.isa < 3)
d6382 1
a6382 1
      assert (mips_opts.isa < 2);
d6472 1
a6472 1
		       || mips_opts.isa < 3)
d6495 1
a6495 1
		       || mips_opts.isa < 3)
d6569 1
a6569 1
		       || mips_opts.isa < 3)
d6591 1
a6591 1
		       || mips_opts.isa < 3)
d7036 1
a7044 2
      else
	insn_isa = 15;
d7046 2
a7047 1
      if (insn_isa <= mips_opts.isa)
d7076 2
a7077 1
	  if (insn_isa == 15 
d7449 1
a7449 1
		      && mips_opts.isa < 3
d7602 1
a7602 1
		    if (mips_opts.isa < 3)
d7771 1
a7771 1
			  && mips_opts.isa >= 3
d10365 1
a10365 1
		 || mips_opts.isa < 3)
d10433 1
a10433 1
		 || mips_opts.isa < 3)
@


1.5
log
@	* config/tc-mips.c (append_insn): Correct INSN_SYNC test.  From
	Ralf Baechle <ralf@@uni-koblenz.de>.
@
text
@d297 3
a299 2
   gcc output.  If it guesses wrong, the only loss should be in
   efficiency; it shouldn't introduce any bugs.
d10629 3
a10631 1
		    && strcmp (segname, ".sbss") != 0);
@


1.4
log
@	Based on patches from John W. Woznack <jwoznack@@concentric.net>:
	* itbl-ops.c (itbl_get_reg_val): Add pval parameter.  Return
	indication of success rather than a value.
	(itbl_get_val): Likewise.
	(itbl_get_field): Use strcspn.  Change delimiters to include
	parens.
	* itbl-ops.h (itbl_get_reg_val): Update declaration.
	(itbl_get_val): Likewise.
	* config/tc-mips.c (mips_ip): Update call to itbl_get_reg_val.
@
text
@d2100 1
a2100 1
	      || (prev_pinfo && INSN_SYNC))
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d7300 1
a7300 1
			  int r;
d7302 1
a7302 1
			  p = s+1; 	/* advance past '$' */
d7305 3
a7307 4
			  /* See if this is a register defined in an 
			     itbl entry */
			  r = itbl_get_reg_val (n);
			  if (r)
d7311 1
a7311 1
				 rack to the end of the last field. */
d7315 1
a7315 1
				s = strchr (s,'\0');
@


1.2
log
@	-Wchar-subscripts cleanup
	* listing.c (listing_newline): Use unsigned char variable, so
 	calls to isascii,iscntrl are correct.
	* atof-generic.c (atof_generic): Cast arg to isdigit, et. al. with
	(unsigned char).
	* ecoff.c (ecoff_directive_ent,ecoff_stab): Ditto.
	* config/obj-elf.c (obj_elf_vtable_inherit): Ditto.
	* config/tc-mips.c (mips_ip,mips16_ip): Ditto.
	(my_getSmallExpression,get_number,s_mips_ent): Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
a56 1
#undef TARGET_SYMBOL_FIELDS
d1375 2
a1376 2
	  if ((l->label->sy_value.X_add_number & 1) == 0)
	    ++l->label->sy_value.X_add_number;
d1658 1
a1658 1
	      l->label->sy_frag = frag_now;
d1662 1
a1662 1
		++l->label->sy_value.X_add_number;
d2362 1
a2362 1
	      l->label->sy_frag = frag_now;
d2366 1
a2366 1
		++l->label->sy_value.X_add_number;
d4105 1
a4105 1
	  && (offset_expr.X_op_symbol->sy_value.X_op == O_constant
d4107 4
a4110 3
	      : (offset_expr.X_op_symbol->sy_value.X_op == O_symbol
		 && (S_GET_SEGMENT (offset_expr.X_op_symbol
				    ->sy_value.X_add_symbol)
d8702 4
a8705 4
      && ep->X_add_symbol->sy_frag == frag_now
      && ep->X_add_symbol->sy_value.X_op == O_constant
      && ep->X_add_symbol->sy_value.X_add_number == frag_now_fix ())
    ++ep->X_add_symbol->sy_value.X_add_number;
d9475 7
a9481 7
        || (fixP->fx_addsy->sy_used_in_reloc
            && (bfd_get_section_flags (stdoutput,
                                       S_GET_SEGMENT (fixP->fx_addsy))
                & SEC_LINK_ONCE != 0)
               || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
                            ".gnu.linkonce",
                            sizeof (".gnu.linkonce") - 1)))
d9532 1
a9532 1
      if ((fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) == 0)
d9552 1
a9552 1
      if ((fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) == 0)
d9821 1
a9821 1
      label->sy_frag = frag_now;
d10005 6
a10010 4
    if (type == 'd')
      mips_align (3, 0, label);
    else
      mips_align (2, 0, label);
d10058 1
a10058 1
  symbolP->bsym->flags |= flag;
d10302 1
a10302 1
  ex.X_add_symbol->bsym->flags |= BSF_OBJECT;
d10494 1
a10494 1
      symbolP->sy_value = exp;
d10606 3
a10608 2
		   || (sym->ecoff_extern_size != 0
		       && sym->ecoff_extern_size <= g_switch_value)
d10615 1
a10615 1
		       && sym->ecoff_extern_size == 0
d10685 3
a10687 3
  /* We can't call S_GET_VALUE here, because we don't want to lock in
     a particular frag address.  */
  if (fragp->fr_symbol->sy_value.X_op == O_constant)
d10689 2
a10690 2
      val = (fragp->fr_symbol->sy_value.X_add_number
	     + fragp->fr_symbol->sy_frag->fr_address);
d10693 12
a10704 9
  else if (fragp->fr_symbol->sy_value.X_op == O_symbol
	   && (fragp->fr_symbol->sy_value.X_add_symbol->sy_value.X_op
	       == O_constant))
    {
      val = (fragp->fr_symbol->sy_value.X_add_symbol->sy_value.X_add_number
	     + fragp->fr_symbol->sy_value.X_add_symbol->sy_frag->fr_address
	     + fragp->fr_symbol->sy_value.X_add_number
	     + fragp->fr_symbol->sy_frag->fr_address);
      symsec = S_GET_SEGMENT (fragp->fr_symbol->sy_value.X_add_symbol);
d10746 2
a10747 1
	  && fragp->fr_symbol->sy_frag->fr_address >= fragp->fr_address)
d10758 1
a10758 1
	       f != NULL && f != fragp->fr_symbol->sy_frag;
d10892 1
a10892 1
      while (sym->sy_value.X_op == O_symbol
d10899 1
a10899 1
	  n = sym->sy_value.X_add_symbol;
d10977 2
a10978 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d10995 1
a10995 1
      if (fixp->fx_addsy->bsym->flags & BSF_SECTION_SYM)
d11007 1
a11007 1
      if (fixp->fx_addsy->bsym->flags & BSF_SECTION_SYM)
d11066 2
a11067 1
      reloc2->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d11445 1
a11445 1
    struct symbol *isym;
d11671 1
a11671 1
      symbolP->bsym->flags |= BSF_FUNCTION;
@


1.1
log
@Initial revision
@
text
@d6959 1
a6959 1
  for (s = str; *s != '\0' && !isspace(*s); ++s)
d6965 1
a6965 1
  if (isspace (*s))
d6983 1
a6983 1
      for (s = str; *s != '\0' && *s != '.' && !isspace (*s); ++s)
d7249 1
a7249 1
		  if (isdigit (s[1]))
d7259 1
a7259 1
		      while (isdigit (*s));
d7409 1
a7409 1
	      if (s[0] == '$' && s[1] == 'f' && isdigit (s[2]))
d7419 1
a7419 1
		  while (isdigit (*s));
d7851 1
a7851 1
	      while (isdigit (*s));
d7904 1
a7904 1
  for (s = str; islower (*s); ++s)
d8037 1
a8037 1
	      if (isdigit (s[1]))
d8047 1
a8047 1
		  while (isdigit (*s));
d8318 1
a8318 1
		    while (isdigit (*s))
d8345 1
a8345 1
			while (isdigit (*s))
d8629 1
a8629 1
	  if (isdigit (sp[-2]))
d8631 1
a8631 1
	      for (sp -= 3; sp >= str && isdigit (*sp); sp--)
d11475 1
a11475 1
  if (!isdigit (*input_line_pointer))
d11482 1
a11482 1
	  while (isxdigit (*input_line_pointer))
d11492 1
a11492 1
	  while (isdigit (*input_line_pointer))
d11500 1
a11500 1
  if (!isdigit (*input_line_pointer))
d11507 1
a11507 1
  while (isdigit (*input_line_pointer))
d11633 2
a11634 1
  if (isdigit (*input_line_pointer) || *input_line_pointer == '-')
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

