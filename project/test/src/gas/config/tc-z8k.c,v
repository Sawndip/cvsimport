head	1.49;
access;
symbols
	binutils-2_24-branch:1.49.0.2
	binutils-2_24-branchpoint:1.49
	binutils-2_21_1:1.48
	binutils-2_23_2:1.48
	binutils-2_23_1:1.48
	binutils-2_23:1.48
	binutils-2_23-branch:1.48.0.8
	binutils-2_23-branchpoint:1.48
	binutils-2_22_branch:1.48.0.6
	binutils-2_22:1.48
	binutils-2_22-branch:1.48.0.4
	binutils-2_22-branchpoint:1.48
	binutils-2_21:1.48
	binutils-2_21-branch:1.48.0.2
	binutils-2_21-branchpoint:1.48
	binutils-2_20_1:1.47
	binutils-2_20:1.47
	binutils-arc-20081103-branch:1.44.0.8
	binutils-arc-20081103-branchpoint:1.44
	binutils-2_20-branch:1.47.0.2
	binutils-2_20-branchpoint:1.47
	dje-cgen-play1-branch:1.44.0.6
	dje-cgen-play1-branchpoint:1.44
	arc-20081103-branch:1.44.0.4
	arc-20081103-branchpoint:1.44
	binutils-2_19_1:1.44
	binutils-2_19:1.44
	binutils-2_19-branch:1.44.0.2
	binutils-2_19-branchpoint:1.44
	binutils-2_18:1.43
	binutils-2_18-branch:1.43.0.2
	binutils-2_18-branchpoint:1.43
	binutils-csl-coldfire-4_1-32:1.40
	binutils-csl-sourcerygxx-4_1-32:1.40
	binutils-csl-innovasic-fido-3_4_4-33:1.40
	binutils-csl-sourcerygxx-3_4_4-32:1.34.2.1
	binutils-csl-coldfire-4_1-30:1.40
	binutils-csl-sourcerygxx-4_1-30:1.40
	binutils-csl-coldfire-4_1-28:1.40
	binutils-csl-sourcerygxx-4_1-29:1.40
	binutils-csl-sourcerygxx-4_1-28:1.40
	binutils-csl-arm-2006q3-27:1.40
	binutils-csl-sourcerygxx-4_1-27:1.40
	binutils-csl-arm-2006q3-26:1.40
	binutils-csl-sourcerygxx-4_1-26:1.40
	binutils-csl-sourcerygxx-4_1-25:1.40
	binutils-csl-sourcerygxx-4_1-24:1.40
	binutils-csl-sourcerygxx-4_1-23:1.40
	binutils-csl-sourcerygxx-4_1-21:1.40
	binutils-csl-arm-2006q3-21:1.40
	binutils-csl-sourcerygxx-4_1-22:1.40
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.40
	binutils-csl-sourcerygxx-4_1-20:1.40
	binutils-csl-arm-2006q3-19:1.40
	binutils-csl-sourcerygxx-4_1-19:1.40
	binutils-csl-sourcerygxx-4_1-18:1.40
	binutils-csl-renesas-4_1-9:1.40
	binutils-csl-sourcerygxx-3_4_4-25:1.34.2.1
	binutils-csl-renesas-4_1-8:1.40
	binutils-csl-renesas-4_1-7:1.40
	binutils-csl-renesas-4_1-6:1.40
	binutils-csl-sourcerygxx-4_1-17:1.40
	binutils-csl-sourcerygxx-4_1-14:1.40
	binutils-csl-sourcerygxx-4_1-15:1.40
	binutils-csl-sourcerygxx-4_1-13:1.40
	binutils-2_17:1.40
	binutils-csl-sourcerygxx-4_1-12:1.40
	binutils-csl-sourcerygxx-3_4_4-21:1.40
	binutils-csl-wrs-linux-3_4_4-24:1.34
	binutils-csl-wrs-linux-3_4_4-23:1.34
	binutils-csl-sourcerygxx-4_1-9:1.40
	binutils-csl-sourcerygxx-4_1-8:1.40
	binutils-csl-sourcerygxx-4_1-7:1.40
	binutils-csl-arm-2006q1-6:1.40
	binutils-csl-sourcerygxx-4_1-6:1.40
	binutils-csl-wrs-linux-3_4_4-22:1.34
	binutils-csl-coldfire-4_1-11:1.40
	binutils-csl-sourcerygxx-3_4_4-19:1.40
	binutils-csl-coldfire-4_1-10:1.40
	binutils-csl-sourcerygxx-4_1-5:1.40
	binutils-csl-sourcerygxx-4_1-4:1.40
	binutils-csl-wrs-linux-3_4_4-21:1.34
	binutils-csl-morpho-4_1-4:1.40
	binutils-csl-sourcerygxx-3_4_4-17:1.40
	binutils-csl-wrs-linux-3_4_4-20:1.34
	binutils-2_17-branch:1.40.0.4
	binutils-2_17-branchpoint:1.40
	binutils-csl-2_17-branch:1.40.0.2
	binutils-csl-2_17-branchpoint:1.40
	binutils-csl-gxxpro-3_4-branch:1.34.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.34.2.1
	binutils-2_16_1:1.34.2.1
	binutils-csl-arm-2005q1b:1.34
	binutils-2_16:1.34.2.1
	binutils-csl-arm-2005q1a:1.34
	binutils-csl-arm-2005q1-branch:1.34.0.4
	binutils-csl-arm-2005q1-branchpoint:1.34
	binutils-2_16-branch:1.34.0.2
	binutils-2_16-branchpoint:1.34
	csl-arm-2004-q3d:1.29
	csl-arm-2004-q3:1.29
	binutils-2_15:1.29
	binutils-2_15-branchpoint:1.29
	csl-arm-2004-q1a:1.29
	csl-arm-2004-q1:1.29
	binutils-2_15-branch:1.29.0.6
	cagney_bfdfile-20040213-branch:1.29.0.4
	cagney_bfdfile-20040213-branchpoint:1.29
	cagney_bigcore-20040122-branch:1.29.0.2
	cagney_bigcore-20040122-branchpoint:1.29
	csl-arm-2003-q4:1.29
	binutils-2_14:1.21.2.1
	binutils-2_14-branch:1.21.0.2
	binutils-2_14-branchpoint:1.21
	binutils-2_13_2_1:1.17.2.1
	binutils-2_13_2:1.17.2.1
	binutils-2_13_1:1.17.2.1
	binutils-2_13:1.17.2.1
	binutils-2_13-branchpoint:1.17
	binutils-2_13-branch:1.17.0.2
	binutils-2_12_1:1.15
	binutils-2_12:1.15
	binutils-2_12-branch:1.15.0.2
	binutils-2_12-branchpoint:1.15
	cygnus_cvs_20020108_pre:1.15
	binutils-2_11_2:1.8.2.2
	binutils-2_11_1:1.8.2.2
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.49
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2013.04.26.19.21.25;	author cpg;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2009.09.02.07.24.21;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2009.08.29.22.11.00;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2009.07.24.11.45.01;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2006.12.08.22.15.11;	author cpg;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2005.08.26.09.47.35;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2005.08.18.11.54.33;	author cpg;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.05.09.13.06;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.21.20.03.57;	author cpg;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.23.12.28.06;	author amodra;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2005.01.31.23.18.35;	author bje;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.28.19.33.26;	author cpg;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.27.21.32.21;	author cpg;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.27.21.08.14;	author cpg;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.15.22.02.42;	author cpg;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.05.23.40.04;	author cpg;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.28.20.10.18;	author cpg;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.26.21.24.53;	author cpg;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.04.21.11.05;	author cpg;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.19.13.44.42;	author cpg;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.01.19.59.33;	author cpg;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.17.01.13.55;	author kazu;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2002.12.12.21.27.58;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.22.19.22.35;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.16.13.37.49;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.08.07.37.16;	author amodra;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2002.04.25.10.59.22;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.15.21.28.59;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.09.17.25.57;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.19.05.33.31;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.01.15.39.17;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.06.17.01.34;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.24.15.22.24;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.23.24.25;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.16.00.59.49;	author kazu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.07.27.04.05.05;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.25.17.59.21;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.24.11.51.53;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.09.00.00.04;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.29.48;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.34.2.1
date	2005.04.28.17.20.34;	author cpg;	state Exp;
branches;
next	;

1.21.2.1
date	2003.05.01.20.22.49;	author cpg;	state Exp;
branches;
next	;

1.17.2.1
date	2002.07.16.13.44.17;	author amodra;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.15.34;	author amodra;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.06.11.10.04.51;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;


desc
@@


1.49
log
@	* config/tc-z8k.c (md_parse_option): Set z8k_target_from_cmdline
	according to the target parameter.  Don't call s_segm since s_segm
	calls bfd_set_arch_mach using stdoutput, but stdoutput isn't
	initialized yet.
	(md_begin): Call s_segm according to target parameter from command
	line.
@
text
@/* tc-z8k.c -- Assemble code for the Zilog Z800n
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001, 2002, 2003,
   2005, 2006, 2007, 2009, 2013  Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

#include "as.h"
#include "safe-ctype.h"
#define DEFINE_TABLE
#include "opcodes/z8k-opc.h"

const char comment_chars[] = "!";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = ";";

extern int machine;
extern int coff_flags;
int segmented_mode;

/* This is non-zero if target was set from the command line.
   If non-zero, 1 means Z8002 (non-segmented), 2 means Z8001 (segmented).  */
static int z8k_target_from_cmdline;

static void
s_segm (int segm)
{
  if (segm)
    {
      segmented_mode = 1;
      bfd_set_arch_mach (stdoutput, TARGET_ARCH, bfd_mach_z8001);
    }
  else
    {
      segmented_mode = 0;
      bfd_set_arch_mach (stdoutput, TARGET_ARCH, bfd_mach_z8002);
    }
}

static void
even (int ignore ATTRIBUTE_UNUSED)
{
  frag_align (1, 0, 0);
  record_alignment (now_seg, 1);
}

static int
tohex (int c)
{
  if (ISDIGIT (c))
    return c - '0';
  if (ISLOWER (c))
    return c - 'a' + 10;
  return c - 'A' + 10;
}

static void
sval (int ignore ATTRIBUTE_UNUSED)
{
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '\'')
    {
      int c;
      input_line_pointer++;
      c = *input_line_pointer++;
      while (c != '\'')
	{
	  if (c == '%')
	    {
	      c = (tohex (input_line_pointer[0]) << 4)
		| tohex (input_line_pointer[1]);
	      input_line_pointer += 2;
	    }
	  FRAG_APPEND_1_CHAR (c);
	  c = *input_line_pointer++;
	}
      demand_empty_rest_of_line ();
    }
}

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */

const pseudo_typeS md_pseudo_table[] = {
  {"int"    , cons            , 2},
  {"data.b" , cons            , 1},
  {"data.w" , cons            , 2},
  {"data.l" , cons            , 4},
  {"form"   , listing_psize   , 0},
  {"heading", listing_title   , 0},
  {"import" , s_ignore        , 0},
  {"page"   , listing_eject   , 0},
  {"program", s_ignore        , 0},
  {"z8001"  , s_segm          , 1},
  {"z8002"  , s_segm          , 0},

  {"segm"   , s_segm          , 1},
  {"unsegm" , s_segm          , 0},
  {"unseg"  , s_segm          , 0},
  {"name"   , s_app_file      , 0},
  {"global" , s_globl         , 0},
  {"wval"   , cons            , 2},
  {"lval"   , cons            , 4},
  {"bval"   , cons            , 1},
  {"sval"   , sval            , 0},
  {"rsect"  , obj_coff_section, 0},
  {"sect"   , obj_coff_section, 0},
  {"block"  , s_space         , 0},
  {"even"   , even            , 0},
  {0        , 0               , 0}
};

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* Opcode mnemonics.  */
static struct hash_control *opcode_hash_control;

void
md_begin (void)
{
  const opcode_entry_type *opcode;
  int idx = -1;

  opcode_hash_control = hash_new ();

  for (opcode = z8k_table; opcode->name; opcode++)
    {
      /* Only enter unique codes into the table.  */
      if (idx != opcode->idx)
	hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
      idx = opcode->idx;
    }

  /* Default to z8002.  */
  s_segm (z8k_target_from_cmdline ? z8k_target_from_cmdline - 1 : 0);

  /* Insert the pseudo ops, too.  */
  for (idx = 0; md_pseudo_table[idx].poc_name; idx++)
    {
      opcode_entry_type *fake_opcode;
      fake_opcode = (opcode_entry_type *) malloc (sizeof (opcode_entry_type));
      fake_opcode->name = md_pseudo_table[idx].poc_name;
      fake_opcode->func = (void *) (md_pseudo_table + idx);
      fake_opcode->opcode = 250;
      hash_insert (opcode_hash_control, fake_opcode->name, fake_opcode);
    }
}

typedef struct z8k_op {
  /* CLASS_REG_xxx.  */
  int regsize;

  /* 0 .. 15.  */
  unsigned int reg;

  int mode;

  /* Any other register associated with the mode.  */
  unsigned int x_reg;

  /* Any expression.  */
  expressionS exp;
} op_type;

static expressionS *da_operand;
static expressionS *imm_operand;

static int reg[16];
static int the_cc;
static int the_ctrl;
static int the_flags;
static int the_interrupt;

/* Determine register number.  src points to the ascii number
   (after "rl", "rh", "r", "rr", or "rq").  If a character
   outside the set of {0,',',')','('} follows the number,
   return NULL to indicate that it's not a valid register
   number.  */

static char *
whatreg (unsigned int *preg, char *src)
{
  unsigned int new_reg;

  /* src[0] is already known to be a digit.  */
  if (ISDIGIT (src[1]))
    {
      new_reg = (src[0] - '0') * 10 + src[1] - '0';
      src += 2;
    }
  else
    {
      new_reg = (src[0] - '0');
      src += 1;
    }

  if (src[0] != 0 && src[0] != ',' && src[0] != '(' && src[0] != ')')
    return NULL;

  *preg = new_reg;
  return src;
}

/* Parse operands

   rh0-rh7, rl0-rl7
   r0-r15
   rr0-rr14
   rq0--rq12
   WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp
   r0l,r0h,..r7l,r7h
   @@WREG
   @@WREG+
   @@-WREG
   #const
*/

/* Try to parse a reg name.  Return a pointer to the first character
   in SRC after the reg name.  */

static char *
parse_reg (char *src, int *mode, unsigned int *preg)
{
  char *res = NULL;
  char regno;

  /* Check for stack pointer "sp" alias.  */
  if ((src[0] == 's' || src[0] == 'S')
      && (src[1] == 'p' || src[1] == 'P')
      && (src[2] == 0 || src[2] == ','))
    {
      if (segmented_mode)
	{
	  *mode = CLASS_REG_LONG;
	  *preg = 14;
	}
      else
	{
	  *mode = CLASS_REG_WORD;
	  *preg = 15;
	}
      return src + 2;
    }

  if (src[0] == 'r' || src[0] == 'R')
    {
      if (src[1] == 'r' || src[1] == 'R')
	{
	  if (src[2] < '0' || src[2] > '9')
	    return NULL;	/* Assume no register name but a label starting with 'rr'.  */
	  *mode = CLASS_REG_LONG;
	  res = whatreg (preg, src + 2);
	  if (res == NULL)
	    return NULL;	/* Not a valid register name.  */
	  regno = *preg;
	  if (regno > 14)
	    as_bad (_("register rr%d out of range"), regno);
	  if (regno & 1)
	    as_bad (_("register rr%d does not exist"), regno);
	}
      else if (src[1] == 'h' || src[1] == 'H')
	{
	  if (src[2] < '0' || src[2] > '9')
	    return NULL;	/* Assume no register name but a label starting with 'rh'.  */
	  *mode = CLASS_REG_BYTE;
	  res = whatreg (preg, src + 2);
	  if (res == NULL)
	    return NULL;	/* Not a valid register name.  */
	  regno = *preg;
	  if (regno > 7)
	    as_bad (_("register rh%d out of range"), regno);
	}
      else if (src[1] == 'l' || src[1] == 'L')
	{
	  if (src[2] < '0' || src[2] > '9')
	    return NULL;	/* Assume no register name but a label starting with 'rl'.  */
	  *mode = CLASS_REG_BYTE;
	  res = whatreg (preg, src + 2);
	  if (res == NULL)
	    return NULL;	/* Not a valid register name.  */
	  regno = *preg;
	  if (regno > 7)
	    as_bad (_("register rl%d out of range"), regno);
	  *preg += 8;
	}
      else if (src[1] == 'q' || src[1] == 'Q')
	{
	  if (src[2] < '0' || src[2] > '9')
	    return NULL;	/* Assume no register name but a label starting with 'rq'.  */
	  *mode = CLASS_REG_QUAD;
	  res = whatreg (preg, src + 2);
	  if (res == NULL)
	    return NULL;	/* Not a valid register name.  */
	  regno = *preg;
	  if (regno > 12)
	    as_bad (_("register rq%d out of range"), regno);
	  if (regno & 3)
	    as_bad (_("register rq%d does not exist"), regno);
	}
      else
	{
	  if (src[1] < '0' || src[1] > '9')
	    return NULL;	/* Assume no register name but a label starting with 'r'.  */
	  *mode = CLASS_REG_WORD;
	  res = whatreg (preg, src + 1);
	  if (res == NULL)
	    return NULL;	/* Not a valid register name.  */
	  regno = *preg;
	  if (regno > 15)
	    as_bad (_("register r%d out of range"), regno);
	}
    }
  return res;
}

static char *
parse_exp (char *s, expressionS *op)
{
  char *save = input_line_pointer;
  char *new_pointer;

  input_line_pointer = s;
  expression (op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  new_pointer = input_line_pointer;
  input_line_pointer = save;
  return new_pointer;
}

/* The many forms of operand:

   <rb>
   <r>
   <rr>
   <rq>
   @@r
   #exp
   exp
   exp(r)
   r(#exp)
   r(r)
   */

static char *
checkfor (char *ptr, char what)
{
  if (*ptr == what)
    ptr++;
  else
    as_bad (_("expected %c"), what);

  return ptr;
}

/* Make sure the mode supplied is the size of a word.  */

static void
regword (int mode, char *string)
{
  int ok;

  ok = CLASS_REG_WORD;
  if (ok != mode)
    {
      as_bad (_("register is wrong size for a word %s"), string);
    }
}

/* Make sure the mode supplied is the size of an address.  */

static void
regaddr (int mode, char *string)
{
  int ok;

  ok = segmented_mode ? CLASS_REG_LONG : CLASS_REG_WORD;
  if (ok != mode)
    {
      as_bad (_("register is wrong size for address %s"), string);
    }
}

struct ctrl_names {
  int value;
  char *name;
};

static struct ctrl_names ctrl_table[] = {
  { 0x1, "flags" },   /* ldctlb only.  */
  { 0x2, "fcw" },     /* ldctl only.  Applies to all remaining control registers.  */
  { 0x3, "refresh" },
  { 0x4, "psapseg" },
  { 0x5, "psapoff" },
  { 0x5, "psap" },
  { 0x6, "nspseg" },
  { 0x7, "nspoff" },
  { 0x7, "nsp" },
  { 0  , 0 }
};

static void
get_ctrl_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  int i, l;

  while (*src == ' ')
    src++;

  mode->mode = CLASS_CTRL;
  for (i = 0; ctrl_table[i].name; i++)
    {
      l = strlen (ctrl_table[i].name);
      if (! strncasecmp (ctrl_table[i].name, src, l))
        {
          the_ctrl = ctrl_table[i].value;
          if (*(src + l) && *(src + l) != ',')
            break;
          *ptr = src + l;  /* Valid control name found: "consume" it.  */
          return;
        }
    }
  the_ctrl = 0;
}

struct flag_names {
  int value;
  char *name;
};

static struct flag_names flag_table[] = {
  { 0x1, "P" },
  { 0x1, "V" },
  { 0x2, "S" },
  { 0x4, "Z" },
  { 0x8, "C" },
  { 0x0, "+" },
  { 0x0, "," },
  { 0, 0 }
};

static void
get_flags_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  char c;
  int i;
  int j;

  while (*src == ' ')
    src++;

  mode->mode = CLASS_FLAGS;
  the_flags = 0;
  for (j = 0; j <= 9; j++)
    {
      if (!src[j])
	goto done;
      c = TOUPPER(src[j]);
      for (i = 0; flag_table[i].name; i++)
	{
	  if (flag_table[i].name[0] == c)
	    {
	      the_flags = the_flags | flag_table[i].value;
	      goto match;
	    }
	}
      goto done;
    match:
      ;
    }
 done:
  *ptr = src + j;
}

struct interrupt_names {
  int value;
  char *name;
};

static struct interrupt_names intr_table[] = {
  { 0x1, "nvi" },
  { 0x2, "vi" },
  { 0x3, "both" },
  { 0x3, "all" },
  { 0, 0 }
};

static void
get_interrupt_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  int i, l;

  while (*src == ' ')
    src++;

  mode->mode = CLASS_IMM;
  the_interrupt = 0;

  while (*src)
    {
      for (i = 0; intr_table[i].name; i++)
	{
	  l = strlen (intr_table[i].name);
	  if (! strncasecmp (intr_table[i].name, src, l))
	    {
	      the_interrupt |= intr_table[i].value;
	      if (*(src + l) && *(src + l) != ',')
		{
		  *ptr = src + l;
		invalid:
		  as_bad (_("unknown interrupt %s"), src);
		  while (**ptr && ! is_end_of_line[(unsigned char) **ptr])
		    (*ptr)++;	 /* Consume rest of line.  */
		  return;
		}
	      src += l;
	      if (! *src)
		{
		  *ptr = src;
		  return;
		}
	    }
	}
      if (*src == ',')
	src++;
      else
	{
	  *ptr = src;
	  goto invalid;
	}
    }

  /* No interrupt type specified, opcode won't do anything.  */
  as_warn (_("opcode has no effect"));
  the_interrupt = 0x0;
}

struct cc_names {
  int value;
  char *name;
};

static struct cc_names table[] = {
  { 0x0, "f" },
  { 0x1, "lt" },
  { 0x2, "le" },
  { 0x3, "ule" },
  { 0x4, "ov/pe" },
  { 0x4, "ov" },
  { 0x4, "pe/ov" },
  { 0x4, "pe" },
  { 0x5, "mi" },
  { 0x6, "eq" },
  { 0x6, "z" },
  { 0x7, "c/ult" },
  { 0x7, "c" },
  { 0x7, "ult/c" },
  { 0x7, "ult" },
  { 0x8, "t" },
  { 0x9, "ge" },
  { 0xa, "gt" },
  { 0xb, "ugt" },
  { 0xc, "nov/po" },
  { 0xc, "nov" },
  { 0xc, "po/nov" },
  { 0xc, "po" },
  { 0xd, "pl" },
  { 0xe, "ne" },
  { 0xe, "nz" },
  { 0xf, "nc/uge" },
  { 0xf, "nc" },
  { 0xf, "uge/nc" },
  { 0xf, "uge" },
  { 0  ,  0 }
};

static void
get_cc_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  int i, l;

  while (*src == ' ')
    src++;

  mode->mode = CLASS_CC;
  for (i = 0; table[i].name; i++)
    {
      l = strlen (table[i].name);
      if (! strncasecmp (table[i].name, src, l))
        {
          the_cc = table[i].value;
          if (*(src + l) && *(src + l) != ',')
            break;
          *ptr = src + l;  /* Valid cc found: "consume" it.  */
          return;
        }
    }
  the_cc = 0x8;  /* Not recognizing the cc defaults to t.  (Assuming no cc present.)  */
}

static void
get_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  char *end;

  mode->mode = 0;

  while (*src == ' ')
    src++;
  if (*src == '#')
    {
      mode->mode = CLASS_IMM;
      imm_operand = &(mode->exp);
      src = parse_exp (src + 1, &(mode->exp));
    }
  else if (*src == '@@')
    {
      mode->mode = CLASS_IR;
      src = parse_reg (src + 1, &mode->regsize, &mode->reg);
    }
  else
    {
      unsigned int regn;

      end = parse_reg (src, &mode->mode, &regn);

      if (end)
	{
	  int nw;
	  unsigned int nr;

	  src = end;
	  if (*src == '(')
	    {
	      src++;
	      end = parse_reg (src, &nw, &nr);
	      if (end)
		{
		  /* Got Ra(Rb).  */
		  src = end;

		  if (*src != ')')
		    as_bad (_("Missing ) in ra(rb)"));
		  else
		    src++;

		  regaddr (mode->mode, "ra(rb) ra");
		  mode->mode = CLASS_BX;
		  mode->reg = regn;
		  mode->x_reg = nr;
		  reg[ARG_RX] = nr;
		}
	      else
		{
		  /* Got Ra(disp).  */
		  if (*src == '#')
		    src++;
		  src = parse_exp (src, &(mode->exp));
		  src = checkfor (src, ')');
		  mode->mode = CLASS_BA;
		  mode->reg = regn;
		  mode->x_reg = 0;
		  imm_operand = &(mode->exp);
		}
	    }
	  else
	    {
	      mode->reg = regn;
	      mode->x_reg = 0;
	    }
	}
      else
	{
	  /* No initial reg.  */
	  src = parse_exp (src, &(mode->exp));
	  if (*src == '(')
	    {
	      src++;
	      end = parse_reg (src, &(mode->mode), &regn);
	      regword (mode->mode, "addr(Ra) ra");
	      mode->mode = CLASS_X;
	      mode->reg = regn;
	      mode->x_reg = 0;
	      da_operand = &(mode->exp);
	      src = checkfor (end, ')');
	    }
	  else
	    {
	      /* Just an address.  */
	      mode->mode = CLASS_DA;
	      mode->reg = 0;
	      mode->x_reg = 0;
	      da_operand = &(mode->exp);
	    }
	}
    }
  *ptr = src;
}

static char *
get_operands (const opcode_entry_type *opcode, char *op_end, op_type *operand)
{
  char *ptr = op_end;
  char *savptr;

  switch (opcode->noperands)
    {
    case 0:
      operand[0].mode = 0;
      operand[1].mode = 0;
      while (*ptr == ' ')
        ptr++;
      break;

    case 1:
      if (opcode->arg_info[0] == CLASS_CC)
        {
          get_cc_operand (&ptr, operand + 0, 0);
          while (*ptr == ' ')
            ptr++;
          if (*ptr && ! is_end_of_line[(unsigned char) *ptr])
            {
              as_bad (_("invalid condition code '%s'"), ptr);
              while (*ptr && ! is_end_of_line[(unsigned char) *ptr])
                ptr++;   /* Consume rest of line.  */
            }
        }
      else if (opcode->arg_info[0] == CLASS_FLAGS)
	{
	  get_flags_operand (&ptr, operand + 0, 0);
	  while (*ptr == ' ')
	    ptr++;
	  if (*ptr && ! is_end_of_line[(unsigned char) *ptr])
	    {
	      as_bad (_("invalid flag '%s'"), ptr);
	      while (*ptr && ! is_end_of_line[(unsigned char) *ptr])
		ptr++;	 /* Consume rest of line.  */
	    }
	}
      else if (opcode->arg_info[0] == (CLASS_IMM + (ARG_IMM2)))
	get_interrupt_operand (&ptr, operand + 0, 0);
      else
	get_operand (&ptr, operand + 0, 0);

      operand[1].mode = 0;
      break;

    case 2:
      savptr = ptr;
      if (opcode->arg_info[0] == CLASS_CC)
        {
          get_cc_operand (&ptr, operand + 0, 0);
          while (*ptr == ' ')
            ptr++;
          if (*ptr != ',' && strchr (ptr + 1, ','))
            {
              savptr = ptr;
              while (*ptr != ',')
                ptr++;
              *ptr = 0;
              ptr++;
              as_bad (_("invalid condition code '%s'"), savptr);
            }
        }
      else if (opcode->arg_info[0] == CLASS_CTRL)
	{
	  get_ctrl_operand (&ptr, operand + 0, 0);

	  if (the_ctrl == 0)
	    {
	      ptr = savptr;
	      get_operand (&ptr, operand + 0, 0);

	      if (ptr == 0)
		return NULL;
	      if (*ptr == ',')
		ptr++;
	      get_ctrl_operand (&ptr, operand + 1, 1);
	      if (the_ctrl == 0)
		return NULL;
	      return ptr;
	    }
	}
      else
	get_operand (&ptr, operand + 0, 0);

      if (ptr == 0)
	return NULL;
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, 1);
      break;

    case 3:
      get_operand (&ptr, operand + 0, 0);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, 1);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 2, 2);
      break;

    case 4:
      get_operand (&ptr, operand + 0, 0);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, 1);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 2, 2);
      if (*ptr == ',')
	ptr++;
      get_cc_operand (&ptr, operand + 3, 3);
      break;

    default:
      abort ();
    }

  return ptr;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes.  Return the opcode which matches the opcodes
   provided.  */

static opcode_entry_type *
get_specific (opcode_entry_type *opcode, op_type *operands)
{
  opcode_entry_type *this_try = opcode;
  int found = 0;
  unsigned int noperands = opcode->noperands;

  int this_index = opcode->idx;

  while (this_index == opcode->idx && !found)
    {
      unsigned int i;

      this_try = opcode++;
      for (i = 0; i < noperands; i++)
	{
	  unsigned int mode = operands[i].mode;

          if (((mode & CLASS_MASK) == CLASS_IR) && ((this_try->arg_info[i] & CLASS_MASK) == CLASS_IRO))
            {
              mode = operands[i].mode = (operands[i].mode & ~CLASS_MASK) | CLASS_IRO;
            }

	  if ((mode & CLASS_MASK) != (this_try->arg_info[i] & CLASS_MASK))
	    {
	      /* It could be a pc rel operand, if this is a da mode
		 and we like disps, then insert it.  */

	      if (mode == CLASS_DA && this_try->arg_info[i] == CLASS_DISP)
		{
		  /* This is the case.  */
		  operands[i].mode = CLASS_DISP;
		}
	      else if (mode == CLASS_BA && this_try->arg_info[i])
		{
		  /* Can't think of a way to turn what we've been
		     given into something that's OK.  */
		  goto fail;
		}
	      else if (this_try->arg_info[i] & CLASS_PR)
		{
		  if (mode == CLASS_REG_LONG && segmented_mode)
		    {
		      /* OK.  */
		    }
		  else if (mode == CLASS_REG_WORD && !segmented_mode)
		    {
		      /* OK.  */
		    }
		  else
		    goto fail;
		}
	      else
		goto fail;
	    }
	  switch (mode & CLASS_MASK)
	    {
	    default:
	      break;
	    case CLASS_IRO:
	      if (operands[i].regsize != CLASS_REG_WORD)
		as_bad (_("invalid indirect register size"));
	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
	      break;
	    case CLASS_IR:
	      if ((segmented_mode && operands[i].regsize != CLASS_REG_LONG)
		  || (!segmented_mode && operands[i].regsize != CLASS_REG_WORD))
		as_bad (_("invalid indirect register size"));
	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
	      break;
	    case CLASS_X:
	    case CLASS_BA:
	    case CLASS_BX:
	    case CLASS_DISP:
	    case CLASS_REG:
	    case CLASS_REG_WORD:
	    case CLASS_REG_BYTE:
	    case CLASS_REG_QUAD:
	    case CLASS_REG_LONG:
	    case CLASS_REGN0:
	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
	      break;
	    case CLASS_CTRL:
	      if (this_try->opcode == OPC_ldctlb && the_ctrl != 1)
		as_bad (_("invalid control register name"));
	      break;
	    }
	}

      found = 1;
    fail:
      ;
    }
  if (found)
    return this_try;
  else
    return 0;
}

static char buffer[20];

static void
newfix (int ptr, int type, int size, expressionS *operand)
{
  int is_pcrel = 0;
  fixS *fixP;

  /* Size is in nibbles.  */
  if (operand->X_add_symbol
      || operand->X_op_symbol
      || operand->X_add_number)
    {
      switch(type)
        {
        case BFD_RELOC_8_PCREL:
        case BFD_RELOC_Z8K_CALLR:
        case BFD_RELOC_Z8K_DISP7:
          is_pcrel = 1;
        }
      fixP = fix_new_exp (frag_now, ptr, size / 2,
                          operand, is_pcrel, type);
      if (is_pcrel)
	fixP->fx_no_overflow = 1;
    }
}

static char *
apply_fix (char *ptr, int type, expressionS *operand, int size)
{
  long n = operand->X_add_number;

  /* size is in nibbles.  */

  newfix ((ptr - buffer) / 2, type, size + 1, operand);
  switch (size)
    {
    case 8:			/* 8 nibbles == 32 bits.  */
      *ptr++ = n >> 28;
      *ptr++ = n >> 24;
      *ptr++ = n >> 20;
      *ptr++ = n >> 16;
    case 4:			/* 4 nibbles == 16 bits.  */
      *ptr++ = n >> 12;
      *ptr++ = n >> 8;
    case 2:
      *ptr++ = n >> 4;
    case 1:
      *ptr++ = n >> 0;
      break;
    }
  return ptr;
}

/* Now we know what sort of opcodes it is.  Let's build the bytes.  */

static void
build_bytes (opcode_entry_type *this_try, struct z8k_op *operand ATTRIBUTE_UNUSED)
{
  char *output_ptr = buffer;
  int c;
  int nibble;
  unsigned int *class_ptr;

  frag_wane (frag_now);
  frag_new (0);

  if (frag_room () < 8)
    frag_grow (8);  /* Make room for maximum instruction size.  */

  memset (buffer, 0, sizeof (buffer));
  class_ptr = this_try->byte_info;

  for (nibble = 0; (c = *class_ptr++); nibble++)
    {

      switch (c & CLASS_MASK)
	{
	default:
	  abort ();

	case CLASS_ADDRESS:
	  /* Direct address, we don't cope with the SS mode right now.  */
	  if (segmented_mode)
	    {
	      /* da_operand->X_add_number |= 0x80000000;  --  Now set at relocation time.  */
	      output_ptr = apply_fix (output_ptr, BFD_RELOC_32, da_operand, 8);
	    }
	  else
	    {
	      output_ptr = apply_fix (output_ptr, BFD_RELOC_16, da_operand, 4);
	    }
	  da_operand = 0;
	  break;
	case CLASS_DISP8:
	  /* pc rel 8 bit  */
	  output_ptr = apply_fix (output_ptr, BFD_RELOC_8_PCREL, da_operand, 2);
	  da_operand = 0;
	  break;

	case CLASS_0DISP7:
	  /* pc rel 7 bit  */
	  *output_ptr = 0;
	  output_ptr = apply_fix (output_ptr, BFD_RELOC_Z8K_DISP7, da_operand, 2);
	  da_operand = 0;
	  break;

	case CLASS_1DISP7:
	  /* pc rel 7 bit  */
	  *output_ptr = 0x80;
	  output_ptr = apply_fix (output_ptr, BFD_RELOC_Z8K_DISP7, da_operand, 2);
	  output_ptr[-2] = 0x8;
	  da_operand = 0;
	  break;

	case CLASS_BIT_1OR2:
	  *output_ptr = c & 0xf;
	  if (imm_operand)
	    {
	      if (imm_operand->X_add_number == 2)
		*output_ptr |= 2;
	      else if (imm_operand->X_add_number != 1)
		as_bad (_("immediate must be 1 or 2"));
	    }
	  else
	    as_bad (_("immediate 1 or 2 expected"));
	  output_ptr++;
	  break;
	case CLASS_CC:
	  *output_ptr++ = the_cc;
	  break;
	case CLASS_0CCC:
	  if (the_ctrl < 2 || the_ctrl > 7)
	    as_bad (_("invalid control register name"));
	  *output_ptr++ = the_ctrl;
	  break;
	case CLASS_1CCC:
	  if (the_ctrl < 2 || the_ctrl > 7)
	    as_bad (_("invalid control register name"));
	  *output_ptr++ = the_ctrl | 0x8;
	  break;
	case CLASS_00II:
	  *output_ptr++ = (~the_interrupt & 0x3);
	  break;
	case CLASS_01II:
	  *output_ptr++ = (~the_interrupt & 0x3) | 0x4;
	  break;
	case CLASS_FLAGS:
	  *output_ptr++ = the_flags;
	  break;
	case CLASS_IGNORE:
	case CLASS_BIT:
	  *output_ptr++ = c & 0xf;
	  break;
	case CLASS_REGN0:
	  if (reg[c & 0xf] == 0)
	    as_bad (_("can't use R0 here"));
	  /* Fall through.  */
	case CLASS_REG:
	case CLASS_REG_BYTE:
	case CLASS_REG_WORD:
	case CLASS_REG_LONG:
	case CLASS_REG_QUAD:
	  /* Insert bit mattern of right reg.  */
	  *output_ptr++ = reg[c & 0xf];
	  break;
	case CLASS_DISP:
          switch (c & ARG_MASK)
            {
            case ARG_DISP12:
              output_ptr = apply_fix (output_ptr, BFD_RELOC_Z8K_CALLR, da_operand, 4);
              break;
            case ARG_DISP16:
	      output_ptr = apply_fix (output_ptr, BFD_RELOC_16_PCREL, da_operand, 4);
	      break;
	    default:
	      output_ptr = apply_fix (output_ptr, BFD_RELOC_16, da_operand, 4);
	    }
	  da_operand = 0;
	  break;

	case CLASS_IMM:
	  {
	    switch (c & ARG_MASK)
	      {
	      case ARG_NIM4:
                if (imm_operand->X_add_number > 15)
		  as_bad (_("immediate value out of range"));
		imm_operand->X_add_number = -imm_operand->X_add_number;
		output_ptr = apply_fix (output_ptr, BFD_RELOC_Z8K_IMM4L, imm_operand, 1);
		break;
              /*case ARG_IMMNMINUS1: not used.  */
	      case ARG_IMM4M1:
		imm_operand->X_add_number--;
                /* Drop through.  */
	      case ARG_IMM4:
                if (imm_operand->X_add_number > 15)
		  as_bad (_("immediate value out of range"));
		output_ptr = apply_fix (output_ptr, BFD_RELOC_Z8K_IMM4L, imm_operand, 1);
		break;
	      case ARG_NIM8:
		imm_operand->X_add_number = -imm_operand->X_add_number;
                /* Drop through.  */
	      case ARG_IMM8:
		output_ptr = apply_fix (output_ptr, BFD_RELOC_8, imm_operand, 2);
		break;
	      case ARG_IMM16:
		output_ptr = apply_fix (output_ptr, BFD_RELOC_16, imm_operand, 4);
		break;
	      case ARG_IMM32:
		output_ptr = apply_fix (output_ptr, BFD_RELOC_32, imm_operand, 8);
		break;
	      default:
		abort ();
	      }
	  }
	}
    }

  /* Copy from the nibble buffer into the frag.  */
  {
    int length = (output_ptr - buffer) / 2;
    char *src = buffer;
    char *fragp = frag_more (length);

    while (src < output_ptr)
      {
	*fragp = (src[0] << 4) | src[1];
	src += 2;
	fragp++;
      }
  }
}

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (char *str)
{
  char c;
  char *op_start;
  char *op_end;
  struct z8k_op operand[4];
  opcode_entry_type *opcode;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the op code end.  */
  for (op_start = op_end = str;
       *op_end != 0 && *op_end != ' ' && ! is_end_of_line[(unsigned char) *op_end];
       op_end++)
    ;

  if (op_end == op_start)
    {
      as_bad (_("can't find opcode "));
    }
  c = *op_end;

  *op_end = 0;  /* Zero-terminate op code string for hash_find() call.  */

  opcode = (opcode_entry_type *) hash_find (opcode_hash_control, op_start);

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  *op_end = c;  /* Restore original string.  */

  if (opcode->opcode == 250)
    {
      pseudo_typeS *p;
      char oc;
      char *old = input_line_pointer;

      /* Was really a pseudo op.  */

      input_line_pointer = op_end;

      oc = *old;
      *old = '\n';
      while (*input_line_pointer == ' ')
	input_line_pointer++;
      p = (pseudo_typeS *) (opcode->func);

      (p->poc_handler) (p->poc_val);
      input_line_pointer = old;
      *old = oc;
    }
  else
    {
      char *new_input_line_pointer;

      new_input_line_pointer = get_operands (opcode, op_end, operand);
      if (new_input_line_pointer)
        {
          input_line_pointer = new_input_line_pointer;
          opcode = get_specific (opcode, operand);
        }

      if (new_input_line_pointer == NULL || opcode == NULL)
	{
	  /* Couldn't find an opcode which matched the operands.  */
	  char *where = frag_more (2);

	  where[0] = 0x0;
	  where[1] = 0x0;

	  as_bad (_("Can't find opcode to match operands"));
	  return;
	}

      build_bytes (opcode, operand);
    }
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Various routines to kill one day.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

const char *md_shortopts = "z:";

struct option md_longopts[] =
  {
#define OPTION_RELAX  (OPTION_MD_BASE)
    {"linkrelax", no_argument, NULL, OPTION_RELAX},
    {NULL, no_argument, NULL, 0}
  };

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case 'z':
      if (!strcmp (arg, "8001"))
	z8k_target_from_cmdline = 2;
      else if (!strcmp (arg, "8002"))
	z8k_target_from_cmdline = 1;
      else
	{
	  as_bad (_("invalid architecture -z%s"), arg);
	  return 0;
	}
      break;

    case OPTION_RELAX:
      linkrelax = 1;
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
 Z8K options:\n\
  -z8001                  generate segmented code\n\
  -z8002                  generate unsegmented code\n\
  -linkrelax              create linker relaxable code\n"));
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
                 segT sec ATTRIBUTE_UNUSED,
                 fragS *fragP ATTRIBUTE_UNUSED)
{
  printf (_("call to md_convert_frag\n"));
  abort ();
}

/* Generate a machine dependent reloc from a fixup.  */

arelent*
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED,
	      fixS *fixp      ATTRIBUTE_UNUSED)
{
  arelent *reloc;

  reloc = xmalloc (sizeof (*reloc));
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->addend = fixp->fx_offset;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (! reloc->howto)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    _("Cannot represent %s relocation in object file"),
                    bfd_get_reloc_code_name (fixp->fx_r_type));
      abort ();
    }
  return reloc;
}

valueT
md_section_align (segT seg, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  valueT mask = ((valueT) 1 << align) - 1;

  return (size + mask) & ~mask;
}

/* Attempt to simplify or eliminate a fixup. To indicate that a fixup
   has been eliminated, set fix->fx_done. If fix->fx_addsy is non-NULL,
   we will have to generate a reloc entry.  */
void
md_apply_fix (fixS *fixP, valueT *valP, segT segment ATTRIBUTE_UNUSED)
{
  long val = * (long *) valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_Z8K_IMM4L:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
	buf[0] = (buf[0] & 0xf0) | (val & 0xf);
      break;

    case BFD_RELOC_8:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
	*buf++ = val;
      break;

    case BFD_RELOC_16:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          *buf++ = (val >> 8);
          *buf++ = val;
        }
      break;

    case BFD_RELOC_32:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          *buf++ = (val >> 24);
          *buf++ = (val >> 16);
          *buf++ = (val >> 8);
          *buf++ = val;
        }
      break;

    case BFD_RELOC_8_PCREL:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          if (val & 1)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("cannot branch to odd address"));
          val /= 2;
          if (val > 127 || val < -128)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("relative jump out of range"));
          *buf++ = val;
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 1;
        }
      break;

    case BFD_RELOC_16_PCREL:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
          if (val > 32767 || val < -32768)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("relative address out of range"));
          *buf++ = (val >> 8);
          *buf++ = val;
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 1;
        }
      break;

    case BFD_RELOC_Z8K_CALLR:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          if (val & 1)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("cannot branch to odd address"));
          if (val > 4096 || val < -4095)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("relative call out of range"));
          val = -val / 2;
          *buf = (*buf & 0xf0) | ((val >> 8) & 0xf);
          buf++;
          *buf++ = val & 0xff;
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 1;
        }
      break;

    case BFD_RELOC_Z8K_DISP7:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          if (val & 1)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("cannot branch to odd address"));
          val /= 2;
          if (val > 0 || val < -127)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("relative jump out of range"));
          *buf = (*buf & 0x80) | (-val & 0x7f);
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 1;
        }
      break;

    default:
      printf(_("md_apply_fix: unknown r_type 0x%x\n"), fixP->fx_r_type);
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

int
md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED,
                               segT segment_type ATTRIBUTE_UNUSED)
{
  printf (_("call to md_estimate_size_before_relax\n"));
  abort ();
}

/* Put number into target byte order.  */

void
md_number_to_chars (char *ptr, valueT use, int nbytes)
{
  number_to_chars_bigendian (ptr, use, nbytes);
}

/* On the Z8000, a PC-relative offset is relative to the address of the
   instruction plus its size.  */
long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

void
tc_coff_symbol_emit_hook (symbolS *s ATTRIBUTE_UNUSED)
{
}
@


1.48
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2009  Free Software Foundation, Inc.
d37 2
a38 1
/* This is non-zero if target was set from the command line.  */
d160 1
a160 2
  if (! z8k_target_from_cmdline)
    s_segm (0);
d1313 1
a1313 1
	s_segm (1);
d1315 1
a1315 1
	s_segm (0);
a1320 1
      z8k_target_from_cmdline = 1;
@


1.47
log
@update copyright dates
@
text
@d206 1
a206 1
whatreg (unsigned int *reg, char *src)
d225 1
a225 1
  *reg = new_reg;
d247 1
a247 1
parse_reg (char *src, int *mode, unsigned int *reg)
d260 1
a260 1
	  *reg = 14;
d265 1
a265 1
	  *reg = 15;
d277 1
a277 1
	  res = whatreg (reg, src + 2);
d280 1
a280 1
	  regno = *reg;
d291 1
a291 1
	  res = whatreg (reg, src + 2);
d294 1
a294 1
	  regno = *reg;
d303 1
a303 1
	  res = whatreg (reg, src + 2);
d306 1
a306 1
	  regno = *reg;
d309 1
a309 1
	  *reg += 8;
d316 1
a316 1
	  res = whatreg (reg, src + 2);
d319 1
a319 1
	  regno = *reg;
d330 1
a330 1
	  res = whatreg (reg, src + 1);
d333 1
a333 1
	  regno = *reg;
@


1.46
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2005, 2006, 2007  Free Software Foundation, Inc.
@


1.45
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d345 1
a345 1
  char *new;
d351 1
a351 1
  new = input_line_pointer;
d353 1
a353 1
  return new;
@


1.44
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1372 1
a1372 1
                    "Cannot represent %s relocation in object file",
@


1.43
log
@Switch to GPLv3
@
text
@a1287 7
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */
d1292 1
a1292 46
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
@


1.42
log
@        * config/tc-z8k.c (whatreg): Add comment describing function.
        Return NULL if symbol name characters follow the register number.
        (parse_reg): Use NULL instead of 0 for pointer values.  Stop
        processing if whatreg returned NULL.
@
text
@d3 1
a3 1
   2005, 2006 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.41
log
@remove some duplicate #include's.
@
text
@d199 6
d208 3
d213 2
a214 2
      *reg = (src[0] - '0') * 10 + src[1] - '0';
      return src + 2;
d218 2
a219 2
      *reg = (src[0] - '0');
      return src + 1;
d221 6
d249 1
a249 1
  char *res = 0;
d275 1
a275 1
	    return res;	 /* Assume no register name but a label starting with 'rr'.  */
d278 2
d289 1
a289 1
	    return res;	 /* Assume no register name but a label starting with 'rh'.  */
d292 2
d301 1
a301 1
	    return res;	 /* Assume no register name but a label starting with 'rl'.  */
d304 2
d314 1
a314 1
	    return res;	 /* Assume no register name but a label starting with 'rq'.  */
d317 2
d328 1
a328 1
	    return res;	 /* Assume no register name but a label starting with 'r'.  */
d331 2
@


1.40
log
@Re-enable GAS for z8k-coff
@
text
@d3 1
a3 1
   2005 Free Software Foundation, Inc.
a23 2
#include <stdio.h>

a24 1
#include "bfd.h"
@


1.39
log
@2005-08-18  Christian Groessler  <chris@@groessler.org>

	* config/tc-h8300.h: Remove TC_RELOC_MANGLE/tc_reloc_mangle.
	* config/tc-mcore.h: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-sh.h: Remove TC_RELOC_MANGLE and
	sh_coff_reloc_mangle declaration.
	* config/tc-sh.c: (md_apply_fix): Fix comment for case
	BFD_RELOC_SH_USES.
@
text
@a23 1
#define DEFINE_TABLE
d29 1
d49 1
a49 2
      machine = bfd_mach_z8001;
      coff_flags = F_Z8001;
d54 1
a54 2
      machine = bfd_mach_z8002;
      coff_flags = F_Z8002;
d941 1
d943 1
a943 2
  /* size is in nibbles.  */

d950 3
a952 3
        case R_JR:
        case R_DISP7:
        case R_CALLR:
d955 4
a958 6
      fix_new_exp (frag_now,
		   ptr,
		   size / 2,
		   operand,
		   is_pcrel,
		   type);
d1002 3
d1021 1
a1021 1
	      output_ptr = apply_fix (output_ptr, R_IMM32, da_operand, 8);
d1025 1
a1025 1
	      output_ptr = apply_fix (output_ptr, R_IMM16, da_operand, 4);
d1031 1
a1031 1
	  output_ptr = apply_fix (output_ptr, R_JR, da_operand, 2);
d1038 1
a1038 1
	  output_ptr = apply_fix (output_ptr, R_DISP7, da_operand, 2);
d1045 1
a1045 1
	  output_ptr = apply_fix (output_ptr, R_DISP7, da_operand, 2);
d1105 1
a1105 1
              output_ptr = apply_fix (output_ptr, R_CALLR, da_operand, 4);
d1108 1
a1108 1
	      output_ptr = apply_fix (output_ptr, R_REL16, da_operand, 4);
d1111 1
a1111 1
	      output_ptr = apply_fix (output_ptr, R_IMM16, da_operand, 4);
d1122 1
a1122 3
                  {
                    as_bad (_("immediate value out of range"));
                  }
d1124 1
a1124 1
		output_ptr = apply_fix (output_ptr, R_IMM4L, imm_operand, 1);
d1132 2
a1133 4
                  {
                    as_bad (_("immediate value out of range"));
                  }
		output_ptr = apply_fix (output_ptr, R_IMM4L, imm_operand, 1);
d1139 1
a1139 1
		output_ptr = apply_fix (output_ptr, R_IMM8, imm_operand, 2);
d1142 1
a1142 1
		output_ptr = apply_fix (output_ptr, R_IMM16, imm_operand, 4);
d1145 1
a1145 1
		output_ptr = apply_fix (output_ptr, R_IMM32, imm_operand, 8);
d1376 2
a1377 2
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED,
                 segT seg ATTRIBUTE_UNUSED,
d1384 25
d1412 4
a1415 2
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
d1429 46
a1474 2
    case R_IMM4L:
      buf[0] = (buf[0] & 0xf0) | (val & 0xf);
d1477 1
a1477 1
    case R_JR:
d1498 1
a1498 1
    case R_DISP7:
d1506 2
a1507 1
          if (val & 1)
d1509 3
a1511 6
                          _("cannot branch to odd address"));
          val /= 2;
          if (val > 0 || val < -127)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("relative jump out of range"));
          *buf = (*buf & 0x80) | (-val & 0x7f);
d1517 1
a1517 1
    case R_CALLR:
d1540 19
a1558 28
    case R_IMM8:
      *buf++ = val;
      break;

    case R_IMM16:
      *buf++ = (val >> 8);
      *buf++ = val;
      break;

    case R_IMM32:
      *buf++ = (val >> 24);
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      break;

    case R_REL16:
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
      if (val > 32767 || val < -32768)
        as_bad_where (fixP->fx_file, fixP->fx_line,
                      _("relative address out of range"));
      *buf++ = (val >> 8);
      *buf++ = val;
      fixP->fx_no_overflow = 1;
      break;

    case 0:
      md_number_to_chars (buf, val, fixP->fx_size);
@


1.38
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@a1542 57

void
tc_reloc_mangle (fixS *fix_ptr, struct internal_reloc *intr, bfd_vma base)
{
  symbolS *symbol_ptr;

  if (fix_ptr->fx_addsy
      && fix_ptr->fx_subsy)
    {
      symbolS *add = fix_ptr->fx_addsy;
      symbolS *sub = fix_ptr->fx_subsy;

      if (S_GET_SEGMENT (add) != S_GET_SEGMENT (sub))
	as_bad (_("Can't subtract symbols in different sections %s %s"),
		S_GET_NAME (add), S_GET_NAME (sub));
      else
	{
	  int diff = S_GET_VALUE (add) - S_GET_VALUE (sub);

	  fix_ptr->fx_addsy = 0;
	  fix_ptr->fx_subsy = 0;
	  fix_ptr->fx_offset += diff;
	}
    }
  symbol_ptr = fix_ptr->fx_addsy;

  /* If this relocation is attached to a symbol then it's ok
     to output it.  */
  if (fix_ptr->fx_r_type == 0)
    {
      /* cons likes to create reloc32's whatever the size of the reloc.  */
      switch (fix_ptr->fx_size)
	{
	case 2:
	  intr->r_type = R_IMM16;
	  break;
	case 1:
	  intr->r_type = R_IMM8;
	  break;
	case 4:
	  intr->r_type = R_IMM32;
	  break;
	default:
	  abort ();
	}
    }
  else
    intr->r_type = fix_ptr->fx_r_type;

  intr->r_vaddr = fix_ptr->fx_frag->fr_address + fix_ptr->fx_where + base;
  intr->r_offset = fix_ptr->fx_offset;

  if (symbol_ptr)
    intr->r_symndx = symbol_ptr->sy_number;
  else
    intr->r_symndx = -1;
}
@


1.37
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a38 1
const int md_reloc_size;
a1261 6
void
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}

a1269 6
void
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_headers_hook \n"));
}

@


1.36
log
@Update the address and phone number of the FSF
@
text
@d1413 1
a1413 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT segment ATTRIBUTE_UNUSED)
d1520 1
a1520 1
      printf(_("md_apply_fix3: unknown r_type 0x%x\n"), fixP->fx_r_type);
@


1.35
log
@	* config/tc-z8k.c (md_assemble): Fix buffer overrun in operand[]
	array.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.34
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d1185 1
a1185 1
  struct z8k_op operand[3];
@


1.34.2.1
log
@merge from HEAD (1.35):
	* config/tc-z8k.c (md_assemble): Fix buffer overrun in operand[]
	array.
@
text
@d1185 1
a1185 1
  struct z8k_op operand[4];
@


1.33
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d206 1
a206 1
whatreg (int *reg, char *src)
d634 1
a634 1
      int regn;
d640 2
a641 1
	  int nw, nr;
@


1.32
log
@	* config/tc-z8k.c (md_assemble): Improve error detection.
@
text
@a657 3
#if 0
		  regword (mode->mode, "ra(rb) rb");
#endif
a1513 9
#if 0
    case R_DA | R_SEG:
      *buf++ = (val >> 16);
      *buf++ = 0x00;
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
#endif

@


1.31
log
@forgot to include the change for "Make relative branches out of range
an error instead of a warning" from last commit
@
text
@d1244 4
a1247 3
        input_line_pointer = new_input_line_pointer;

      opcode = get_specific (opcode, operand);
d1249 1
a1249 1
      if (opcode == 0)
@


1.30
log
@	* config/tc-z8k.c (INSERT): Remove, not used anywhere.
	(md_apply_fix3): Make relative branches out of range an error
	instead of a warning.  Display correct line number for out of
	range branches/calls/memory accesses.
@
text
@d1438 2
a1439 2
            as_warn_where (fixP->fx_file, fixP->fx_line,
                           _("relative jump out of range"));
@


1.29
log
@	* config/tc-z8k.c (struct z8k_exp): Remove, not used anywhere.
	(ctrl_table): Add "flags" keyword and some comments.
	(flag_table): Convert to uppercase.
	(get_flags_operand): Be case insensitive.
	(get_interrupt_operand): Be case insensitive.  Support notation
	where the inperrupt arguments are separated by commas.
	(get_operands): Check whether get_flags_operand consumed all
	arguments.  Return failure if get_ctrl_operand didn't recognize a
	valid control register.
	(get_specific): Add case CLASS_CTRL: Test for valid control
	register for ldctlb opcode.
	(build_bytes): Check for valid control registers.
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a997 2
#define INSERT(x,y) *x++ = y>>24; *x++ = y>> 16; *x++=y>>8; *x++ =y;

d1433 9
a1441 7
      if (val & 1)
        as_bad (_("cannot branch to odd address"));
      val /= 2;
      if (val > 127 || val < -128)
            as_warn (_("relative jump out of range"));
      *buf++ = val;
      fixP->fx_no_overflow = 1;
d1455 2
a1456 1
            as_bad (_("cannot branch to odd address"));
d1459 2
a1460 1
            as_bad (_("relative jump out of range"));
d1476 2
a1477 1
            as_bad (_("cannot branch to odd address"));
d1479 2
a1480 1
            as_bad (_("relative call out of range"));
d1509 2
a1510 1
        as_bad (_("relative address out of range"));
@


1.28
log
@Remove redundant returns in void functions.
@
text
@a179 6
struct z8k_exp {
  char *e_beg;
  char *e_end;
  expressionS e_exp;
};

d396 2
a397 1
  { 0x2, "fcw" },
d439 5
a443 5
  { 0x1, "p" },
  { 0x1, "v" },
  { 0x2, "s" },
  { 0x4, "z" },
  { 0x8, "c" },
d445 1
d453 1
d466 1
d469 1
a469 1
	  if (flag_table[i].name[0] == src[j])
d500 1
a500 1
  int i;
d506 3
a508 1
  for (i = 0; intr_table[i].name; i++)
d510 26
a535 3
      int j;

      for (j = 0; intr_table[i].name[j]; j++)
d537 2
a538 2
	  if (intr_table[i].name[j] != src[j])
	    goto fail;
a539 5
      the_interrupt = intr_table[i].value;
      *ptr = src + j;
      return;
    fail:
      ;
d541 1
d742 11
a752 1
	get_flags_operand (&ptr, operand + 0, 0);
d792 2
d923 4
d1073 2
d1078 2
@


1.27
log
@	* config/tc-z8k.c (parse_reg): Be case insensitive when checking
	register names.
	(get_ctrl_operand): Be case insensitive when checking ctrl names.
@
text
@a435 1
  return;
a482 1
  return;
a525 1
  return;
@


1.26
log
@	* config/tc-z8k.c: Convert to ISO-C.
	* config/tc-z8k.h: Likewise.
@
text
@d249 4
a252 1
  if (src[0] == 's' && src[1] == 'p' && (src[2] == 0 || src[2] == ','))
d266 2
a267 1
  if (src[0] == 'r')
d269 1
a269 1
      if (src[1] == 'r')
d281 1
a281 1
      else if (src[1] == 'h')
d291 1
a291 1
      else if (src[1] == 'l')
d302 1
a302 1
      else if (src[1] == 'q')
d417 1
a417 1
  int i;
d425 9
a433 12
      int j;

      for (j = 0; ctrl_table[i].name[j]; j++)
	{
	  if (ctrl_table[i].name[j] != src[j])
	    goto fail;
	}
      the_ctrl = ctrl_table[i].value;
      *ptr = src + j;
      return;
    fail:
      ;
a724 1

a726 1

a728 1

a751 1

@


1.25
log
@	* config/tc-z8k.c (s_segm): Fix indentation.
	(md_apply_fix3): Likewise.
	(cc_names): Add alias names for the names generated by the
	disassembler.
	(get_cc_operand): Be case insensitive.
	(get_operands): Improve error handling for cc operands.
	(check_operand): Not used, remove.
	(md_assemble): Remove unused variable prev_opcode.  Skip
	whitespace until end-of-line only.  Restore *op_end after call to
	hash_find.
@
text
@a43 5
static void s_segm PARAMS ((int));
static void even PARAMS ((int));
static int tohex PARAMS ((int));
static void sval PARAMS ((int));

d45 1
a45 2
s_segm (segm)
     int segm;
d62 1
a62 2
even (ignore)
     int ignore ATTRIBUTE_UNUSED;
d69 1
a69 2
tohex (c)
     int c;
d79 1
a79 2
sval (ignore)
     int ignore ATTRIBUTE_UNUSED;
d149 1
a149 1
md_begin ()
d205 5
a209 32
int reg[16];
int the_cc;
int the_ctrl;
int the_flags;
int the_interrupt;

static char *whatreg PARAMS ((int *, char *));
static char *parse_reg PARAMS ((char *, int *, unsigned int *));
static char *parse_exp PARAMS ((char *, expressionS *));
static char *checkfor PARAMS ((char *, char));
static void regword PARAMS ((int, char *));
static void regaddr PARAMS ((int, char *));
static void get_ctrl_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_flags_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_interrupt_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_cc_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static char *get_operands
  PARAMS ((const opcode_entry_type *, char *, op_type *));
static opcode_entry_type *get_specific
  PARAMS ((opcode_entry_type *, op_type *));
static void newfix
  PARAMS ((int, int, int, expressionS *));
static char *apply_fix
  PARAMS ((char *, int, expressionS *, int));
static void build_bytes
  PARAMS ((opcode_entry_type *, struct z8k_op *));
d212 1
a212 3
whatreg (reg, src)
     int *reg;
     char *src;
d244 1
a244 4
parse_reg (src, mode, reg)
     char *src;
     int *mode;
     unsigned int *reg;
d325 1
a325 3
parse_exp (s, op)
     char *s;
     expressionS *op;
d354 1
a354 3
checkfor (ptr, what)
     char *ptr;
     char what;
d367 1
a367 3
regword (mode, string)
     int mode;
     char *string;
d381 1
a381 3
regaddr (mode, string)
     int mode;
     char *string;
d397 1
a397 1
struct ctrl_names ctrl_table[] = {
d410 1
a410 4
get_ctrl_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
a440 1

d443 1
a443 1
struct flag_names flag_table[] = {
d454 1
a454 4
get_flags_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
a488 1

d491 1
a491 1
struct interrupt_names intr_table[] = {
d500 1
a500 4
get_interrupt_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d535 1
a535 1
struct cc_names table[] = {
d570 1
a570 4
get_cc_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d595 1
a595 4
get_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d697 1
a697 4
get_operands (opcode, op_end, operand)
     const opcode_entry_type *opcode;
     char *op_end;
     op_type *operand;
d817 1
a817 3
get_specific (opcode, operands)
     opcode_entry_type *opcode;
     op_type *operands;
d914 1
a914 5
newfix (ptr, type, size, operand)
     int ptr;
     int type;
     int size;   /* nibbles.  */
     expressionS *operand;
d918 2
d941 1
a941 5
apply_fix (ptr, type, operand, size)
     char *ptr;
     int type;
     expressionS *operand;
     int size;   /* nibbles.  */
d945 2
d972 1
a972 3
build_bytes (this_try, operand)
     opcode_entry_type *this_try;
     struct z8k_op *operand ATTRIBUTE_UNUSED;
d1151 1
a1151 2
md_assemble (str)
     char *str;
d1234 1
a1234 2
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d1242 1
a1242 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1248 1
a1248 2
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d1263 1
a1263 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d1325 1
a1325 3
md_parse_option (c, arg)
     int c;
     char *arg;
d1354 1
a1354 2
md_show_usage (stream)
     FILE *stream;
d1364 3
a1366 4
md_convert_frag (headers, seg, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d1373 1
a1373 3
md_section_align (seg, size)
     segT seg;
     valueT size;
d1383 1
a1383 4
md_apply_fix3 (fixP, valP, segment)
     fixS * fixP;
     valueT * valP;
     segT segment ATTRIBUTE_UNUSED;
d1501 2
a1502 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP ATTRIBUTE_UNUSED;
     register segT segment_type ATTRIBUTE_UNUSED;
d1511 1
a1511 4
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
d1519 1
a1519 2
md_pcrel_from (fixP)
     fixS *fixP;
d1525 1
a1525 2
tc_coff_symbol_emit_hook (s)
     symbolS *s ATTRIBUTE_UNUSED;
d1530 1
a1530 5
tc_reloc_mangle (fix_ptr, intr, base)
     fixS *fix_ptr;
     struct internal_reloc *intr;
     bfd_vma base;

@


1.24
log
@2003-10-04  Christian Groessler  <chris@@groessler.org>

	* tc-z8k.c (newfix): Tell fix_new_exp about pc relativeness.
	(md_apply_fix3): Fix R_JR, R_DISP7, and R_CALLR cases.
	(md_pcrel_from): This function now gets called. Supply return
	value.
@
text
@d55 3
a57 3
  segmented_mode = 1;
  machine = bfd_mach_z8001;
  coff_flags = F_Z8001;
d61 3
a63 3
  segmented_mode = 0;
  machine = bfd_mach_z8002;
  coff_flags = F_Z8002;
d600 1
d602 1
d607 1
d609 1
d615 1
d617 1
d622 1
d624 1
d636 1
a636 1
  int i;
d644 9
a652 12
      int j;

      for (j = 0; table[i].name[j]; j++)
	{
	  if (table[i].name[j] != src[j])
	    goto fail;
	}
      the_cc = table[i].value;
      *ptr = src + j;
      return;
    fail:
      ;
d654 1
a654 1
  the_cc = 0x8;
a770 1
  ptr++;
d776 2
d782 11
a792 1
	get_cc_operand (&ptr, operand + 0, 0);
d809 14
a822 1
	get_cc_operand (&ptr, operand + 0, 0);
a981 26
#if 0 /* Not used.  */
static void
check_operand (operand, width, string)
     struct z8k_op *operand;
     unsigned int width;
     char *string;
{
  if (operand->exp.X_add_symbol == 0
      && operand->exp.X_op_symbol == 0)
    {

      /* No symbol involved, let's look at offset, it's dangerous if
	 any of the high bits are not 0 or ff's, find out by oring or
	 anding with the width and seeing if the answer is 0 or all
	 fs.  */
      if ((operand->exp.X_add_number & ~width) != 0 &&
	  (operand->exp.X_add_number | width) != (~0))
	{
	  as_warn (_("operand %s0x%x out of range"),
		   string, operand->exp.X_add_number);
	}
    }

}
#endif

a1235 1
  opcode_entry_type *prev_opcode;
d1243 1
a1243 1
       *op_end != 0 && *op_end != ' ';
d1253 1
a1253 1
  *op_end = 0;
d1263 2
a1269 1
      *op_end = c;
a1291 1
      prev_opcode = opcode; /* XXX is this used ?? */
d1514 3
a1516 3
      if (val & 1)
        as_bad (_("cannot branch to odd address"));
      val /= 2;
d1518 1
a1518 1
        as_bad (_("relative jump out of range"));
d1520 1
a1520 1
      fixP->fx_no_overflow = 1;
d1536 1
a1536 1
        as_bad (_("relative call out of range"));
d1538 3
a1540 3
      *buf = (*buf & 0xf0) | ((val >> 8) & 0xf);
      buf++;
      *buf++ = val & 0xff;
@


1.23
log
@	* config/tc-z8k.c (parse_reg): Invalid registers generate an error
	now, not only a warning.  Add some more checks to detect invalid
	registers.
	(get_operand): For CLASS_IR remember register size in mode struct.
	(get_specific): Handle new CLASS_IRO type.  Add register size
	checks for CLASS_IR and CLASS_IRO.
        (md_apply_fix3): Fix undefined usage of buf.
@
text
@d988 2
d994 7
d1005 1
a1005 1
		   0,
d1467 3
d1486 7
a1492 1
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
d1497 1
a1497 1
        as_bad (_("relative jump out of range"));
d1500 2
d1505 7
a1511 1
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
d1515 1
a1515 1
      if (val > 0 || val < -128)
d1517 1
a1517 1
      *buf = (*buf & 0x80) | (val & 0x7f);
d1519 2
d1524 10
a1533 1
      if (val > 8191 || val < -8192)
d1535 1
a1535 1
      val = -val;
d1539 3
d1611 2
d1615 1
a1615 1
     fixS *fixP ATTRIBUTE_UNUSED;
d1617 1
a1617 1
  abort ();
@


1.22
log
@	* expr.h: Fix comments in operatorT typedef.
	* config/tc-z8k.c: Add 2003 to copyright message.
	Fold s_segm() and s_unseg() into one function s_segm(parm) which
	decides by the parameter.
	(md_begin): Don't set linkrelax.  Only set Z8002 default if no
	command line argument was given to select the intended
	architecure.
	(get_interrupt_operand): Warn if NOP type code is emitted.
	(newfix): New parameter 'size', forward it to 'fix_new_exp'.
	(apply_fix): Call newfix with additional 'size' parameter.
	(build_bytes): Remove unused variable 'nib'.  Detect overflow in
	4 bit immediate arguments.
	(md_longopts): Add 'linkrelax' option.
	(md_parse_option): Adapt to new s_segm function.  Set 'linkrelax'
	variable when 'linkrelax' command line option is specified.
	(md_show_usage): Display 'linkrelax' option.
	(md_apply_fix3): Fix cases R_IMM4L, R_JR, and R_IMM8.  Add cases
	R_CALLR and R_REL16.
	* config/tc-z8k.h: Undef WARN_SIGNED_OVERFLOW_WORD.
@
text
@d196 2
a197 2
  /* 'b','w','r','q'.  */
  char regsize;
d314 3
a316 1
	    as_warn (_("register rr%d, out of range."), regno);
d326 1
a326 1
	    as_warn (_("register rh%d, out of range."), regno);
d336 1
a336 1
	    as_warn (_("register rl%d, out of range."), regno);
d347 3
a349 1
	    as_warn (_("register rq%d, out of range."), regno);
d359 1
a359 1
	    as_warn (_("register r%d, out of range."), regno);
d585 1
a585 1
  as_warn (_("opcode has no effect."));
a672 2
      int d;

d674 1
a674 1
      src = parse_reg (src + 1, &d, &mode->reg);
d876 5
d917 11
a928 1
	    case CLASS_IR:
d971 1
a971 1
	  as_warn (_("operand %s0x%x out of range."),
d1499 2
a1500 1
      *buf++ = (buf[0] & 0xf0) | ((val >> 8) & 0xf);
@


1.21
log
@	* ChangeLog-9295: Fix a typo.
	* README: Likewise.
	* config/tc-d10v.c: Fix a comment typo.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-h8500.h: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-tic80.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* testsuite/gas/h8300/cmpsi2.s: Likewise.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001, 2002
d41 3
a44 1
static void s_unseg PARAMS ((int));
d50 2
a51 2
s_segm (ignore)
     int ignore ATTRIBUTE_UNUSED;
d53 2
d58 3
a60 6
}

static void
s_unseg (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
d64 1
d128 2
a129 2
  {"z8001"  , s_segm          , 0},
  {"z8002"  , s_unseg         , 0},
d131 3
a133 3
  {"segm"   , s_segm          , 0},
  {"unsegm" , s_unseg         , 0},
  {"unseg"  , s_unseg         , 0},
d174 2
a175 1
  s_unseg (0);
a186 2

  linkrelax = 1;
d241 1
a241 1
  PARAMS ((int, int, expressionS *));
d580 2
a588 1

d965 1
a965 1
newfix (ptr, type, operand)
d968 1
d977 1
a977 1
		   1,
d989 1
a989 1
     int size;
d991 1
a991 1
  int n = operand->X_add_number;
d993 1
a993 1
  newfix ((ptr - buffer) / 2, type, operand);
a1023 1
  int nib;
a1138 1
	    nib = 0;
d1142 4
a1146 2
		/* Drop through.  */
	      case ARG_IMM4:
d1149 1
d1152 6
a1157 4
		output_ptr = apply_fix (output_ptr, R_IMM4L, imm_operand, 1);
		break;
	      case ARG_IMMNMINUS1:
		imm_operand->X_add_number--;
d1162 1
a1168 1

a1171 1

d1263 1
a1263 1
      prev_opcode = opcode;
d1290 2
d1373 2
d1389 2
a1391 2
      else if (!strcmp (arg, "8002"))
	s_unseg (0);
d1397 5
d1416 4
a1419 3
Z8K options:\n\
-z8001			generate segmented code\n\
-z8002			generate unsegmented code\n"));
d1428 1
a1428 1
  printf (_("call to md_convert_frag \n"));
d1453 1
a1453 1
      buf[0] = (buf[0] & 0xf0) | ((buf[0] + val) & 0xf);
d1457 6
a1462 1

d1464 1
a1464 4
#if 0
      if (val != 0)
	abort ();
#endif
d1468 9
d1478 6
a1483 5
      *buf++ += val;
#if 0
      if (val != 0)
	abort ();
#endif
d1487 1
a1487 1
      buf[0] += val;
d1489 1
d1494 1
d1501 10
d1525 1
d1538 1
a1538 1
  printf (_("call tomd_estimate_size_before_relax\n"));
@


1.21.2.1
log
@	* expr.h: Fix comments in operatorT typedef.
	* config/tc-z8k.c: Add 2003 to copyright message.
	Fold s_segm() and s_unseg() into one function s_segm(parm) which
	decides by the parameter.
	(md_begin): Don't set linkrelax.  Only set Z8002 default if no
	command line argument was given to select the intended
	architecure.
	(get_interrupt_operand): Warn if NOP type code is emitted.
	(newfix): New parameter 'size', forward it to 'fix_new_exp'.
	(apply_fix): Call newfix with additional 'size' parameter.
	(build_bytes): Remove unused variable 'nib'.  Detect overflow in
	4 bit immediate arguments.
	(md_longopts): Add 'linkrelax' option.
	(md_parse_option): Adapt to new s_segm function.  Set 'linkrelax'
	variable when 'linkrelax' command line option is specified.
	(md_show_usage): Display 'linkrelax' option.
	(md_apply_fix3): Fix cases R_IMM4L, R_JR, and R_IMM8.  Add cases
	R_CALLR and R_REL16.
	* config/tc-z8k.h: Undef WARN_SIGNED_OVERFLOW_WORD.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001, 2002, 2003
a40 3
/* This is non-zero if target was set from the command line.  */
static int z8k_target_from_cmdline;

d42 1
d48 2
a49 2
s_segm (segm)
     int segm;
a50 2
  if (segm)
    {
d54 6
a59 3
    }
  else
    {
a62 1
    }
d126 2
a127 2
  {"z8001"  , s_segm          , 1},
  {"z8002"  , s_segm          , 0},
d129 3
a131 3
  {"segm"   , s_segm          , 1},
  {"unsegm" , s_segm          , 0},
  {"unseg"  , s_segm          , 0},
d172 1
a172 2
  if (! z8k_target_from_cmdline)
    s_segm (0);
d184 2
d240 1
a240 1
  PARAMS ((int, int, int, expressionS *));
a578 2
  /* No interrupt type specified, opcode won't do anything.  */
  as_warn (_("opcode has no effect."));
d586 1
d963 1
a963 1
newfix (ptr, type, size, operand)
a965 1
     int size;   /* nibbles.  */
d974 1
a974 1
		   size / 2,
d986 1
a986 1
     int size;   /* nibbles.  */
d988 1
a988 1
  long n = operand->X_add_number;
d990 1
a990 1
  newfix ((ptr - buffer) / 2, type, size + 1, operand);
d1021 1
d1137 1
a1140 4
                if (imm_operand->X_add_number > 15)
                  {
                    as_bad (_("immediate value out of range"));
                  }
d1142 2
a1145 1
              /*case ARG_IMMNMINUS1: not used.  */
d1148 4
a1151 6
                /* Drop through.  */
	      case ARG_IMM4:
                if (imm_operand->X_add_number > 15)
                  {
                    as_bad (_("immediate value out of range"));
                  }
a1155 1
                /* Drop through.  */
d1162 1
d1166 1
d1258 1
a1258 1
      prev_opcode = opcode; /* XXX is this used ?? */
a1284 2
/* We have no need to default values of symbols.  */

a1365 2
#define OPTION_RELAX  (OPTION_MD_BASE)
    {"linkrelax", no_argument, NULL, OPTION_RELAX},
d1380 1
a1380 1
	s_segm (1);
d1382 1
a1382 1
	s_segm (0);
a1387 5
      z8k_target_from_cmdline = 1;
      break;

    case OPTION_RELAX:
      linkrelax = 1;
d1402 3
a1404 4
 Z8K options:\n\
  -z8001                  generate segmented code\n\
  -z8002                  generate unsegmented code\n\
  -linkrelax              create linker relaxable code\n"));
d1413 1
a1413 1
  printf (_("call to md_convert_frag\n"));
d1438 1
a1438 1
      buf[0] = (buf[0] & 0xf0) | (val & 0xf);
d1442 1
a1442 6
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
      if (val & 1)
        as_bad (_("cannot branch to odd address"));
      val /= 2;
      if (val > 127 || val < -128)
        as_bad (_("relative jump out of range"));
d1444 4
a1447 1
      fixP->fx_no_overflow = 1;
a1450 9
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
      if (val & 1)
        as_bad (_("cannot branch to odd address"));
      val /= 2;
      if (val > 0 || val < -128)
        as_bad (_("relative jump out of range"));
      *buf = (*buf & 0x80) | (val & 0x7f);
      fixP->fx_no_overflow = 1;
      break;
d1452 5
a1456 6
    case R_CALLR:
      if (val > 8191 || val < -8192)
        as_bad (_("relative call out of range"));
      val = -val;
      *buf++ = (buf[0] & 0xf0) | ((val >> 8) & 0xf);
      *buf++ = val & 0xff;
d1460 1
a1460 1
      *buf++ = val;
a1461 1

a1465 1

a1471 10

    case R_REL16:
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
      if (val > 32767 || val < -32768)
        as_bad (_("relative address out of range"));
      *buf++ = (val >> 8);
      *buf++ = val;
      fixP->fx_no_overflow = 1;
      break;

a1485 1
      printf(_("md_apply_fix3: unknown r_type 0x%x\n"), fixP->fx_r_type);
d1498 1
a1498 1
  printf (_("call to md_estimate_size_before_relax\n"));
@


1.20
log
@	* config/tc-z8k.c (cons, obj_coff_section): Delete declarations.
	(whatreg, parse_reg, parse_exp): Make static, prototype.
	(checkfor, regword, regaddr, get_ctrl_operand): Prototype.
	(get_flags_operand, get_interrupt_operand, get_cc_operand): Likewise.
	(get_operand, get_operands, get_specific, newfix): Likewise.
	(apply_fix, build_bytes): Likewise.
	(md_atof): Remove declaration of atof_ieee.
	(tc_aout_fix_to_chars): Delete.
	(md_begin): Constify "opcode".  Don't try to init opcode->idx.
	Fix s_unseg call.
	(md_parse_option): Fix s_segm and s_unseg calls.

	* z8kgen.c: Include "libiberty.h".
	(opt, args, toks): Fix initializer warnings.
	(chewname): Make "name" a char **.  Return mnemonic trimmed of
	operands.
	(gas): Improve emitted "DO NOT EDIT" warning.  Format emitted
	opcode_entry_type, and make "nicename" and "name" const.  Make
	z8k_table const too.  Formatting.  Generate idx as gas needs it.
	* z8k-opc.h: Regenerate.
@
text
@d874 1
a874 1
	      /* It could be an pc rel operand, if this is a da mode
@


1.19
log
@opcodes: Fix definition of "in rd,imm16" opcode.
gas: Adjust ptr variable also in "case 0" case.
@
text
@d41 5
a45 1
void cons ();
d47 3
a49 2
void
s_segm ()
d56 3
a58 2
void
s_unseg ()
d66 2
a67 1
even ()
d73 1
a73 3
void obj_coff_section ();

int
d84 3
a86 2
void
sval ()
d158 2
a159 3
  opcode_entry_type *opcode;
  char *prev_name = "";
  int idx = 0;
d166 3
a168 7
      if (strcmp (opcode->name, prev_name))
	{
	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
	  idx++;
	}
      opcode->idx = idx;
      prev_name = opcode->name;
d172 1
a172 1
  s_unseg ();
d219 28
a246 1
char *
d280 1
a280 1
char *
d360 1
a360 1
char *
d755 1
a755 1
     opcode_entry_type *opcode;
a855 1

a1317 1
  char *atof_ieee ();
d1380 1
a1380 1
	s_segm ();
d1382 1
a1382 1
	s_unseg ();
a1406 7
void
tc_aout_fix_to_chars ()
{
  printf (_("call to tc_aout_fix_to_chars \n"));
  abort ();
}

@


1.18
log
@	* config/tc-z8k.c (build_bytes): Correct order of memset args.
@
text
@d734 1
a742 1
      ptr++;
d744 2
a745 3
	{
	  get_cc_operand (&ptr, operand + 0, 0);
	}
d747 2
a748 3
	{
	  get_flags_operand (&ptr, operand + 0, 0);
	}
d750 2
a751 3
	{
	  get_interrupt_operand (&ptr, operand + 0, 0);
	}
d753 2
a754 3
	{
	  get_operand (&ptr, operand + 0, 0);
	}
a758 1
      ptr++;
d761 2
a762 3
	{
	  get_cc_operand (&ptr, operand + 0, 0);
	}
d766 1
d771 1
d781 2
a782 3
	{
	  get_operand (&ptr, operand + 0, 0);
	}
a790 1
      ptr++;
a800 1
      ptr++;
d1409 1
a1409 1
     fixS *fixP;
d1479 1
a1479 1
  printf (_("call tomd_estimate_size_before_relax \n"));
@


1.17
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d1008 1
a1008 1
  memset (buffer, 20, 0);
@


1.17.2.1
log
@	* config/tc-z8k.c (build_bytes): Correct order of memset args.
@
text
@d1008 1
a1008 1
  memset (buffer, 0, sizeof (buffer));
@


1.16
log
@The patch contains mostly fixes for the disassembler. It also fixes
a crash of the assembler with some malformed source input.
Long segmented addresses are now correctly relocated.
Finally it updates my email address in the MAINTAINERS file.
@
text
@d1343 1
a1343 1
CONST char *md_shortopts = "z:";
@


1.15
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001
d1084 1
d1120 3
a1211 2
      /* Was really a pseudo op.  */

a1213 1

d1217 2
d1233 5
a1237 1
      input_line_pointer = get_operands (opcode, op_end, operand);
d1345 4
a1348 3
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
a1411 1

@


1.14
log
@fix z8k assembly and disassembly
@
text
@d1408 1
a1408 1
md_apply_fix (fixP, val)
d1410 2
a1411 1
     long val;
d1413 1
d1469 3
@


1.13
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@a26 2
#include "opcodes/z8k-opc.h"

d30 1
@


1.12
log
@Cleanups for z8k target
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000
d31 1
a31 1
#include <ctype.h>
d73 1
a73 1
  if (isdigit (c))
d75 1
a75 1
  if (islower (c))
d224 1
a224 1
  if (isdigit (src[1]))
@


1.11
log
@Remove warnings building z8k port.
Fix ld -r behaviour
@
text
@d262 1
a262 1
  if (src[0] == 's' && src[1] == 'p')
d280 2
d290 2
d300 2
d311 2
d321 2
@


1.10
log
@z8k fixes
@
text
@a161 2
      char *src = opcode->name;

d179 2
a180 2
      fake_opcode->name = md_pseudo_table[idx].poc_name,
	fake_opcode->func = (void *) (md_pseudo_table + idx);
d405 9
a413 9
  0x2, "fcw",
  0X3, "refresh",
  0x4, "psapseg",
  0x5, "psapoff",
  0x5, "psap",
  0x6, "nspseg",
  0x7, "nspoff",
  0x7, "nsp",
  0  , 0
d420 1
a420 1
     unsigned int dst;
a422 1
  int r;
d455 7
a461 7
  0x1, "p",
  0x1, "v",
  0x2, "s",
  0x4, "z",
  0x8, "c",
  0x0, "+",
  0, 0
d468 1
a468 1
     unsigned int dst;
a470 1
  int r;
d507 5
a511 5
  0x1, "nvi",
  0x2, "vi",
  0x3, "both",
  0x3, "all",
  0, 0
d518 1
a518 1
     unsigned int dst;
a520 1
  int r;
d553 23
a575 23
  0x0, "f",
  0x1, "lt",
  0x2, "le",
  0x3, "ule",
  0x4, "ov",
  0x4, "pe",
  0x5, "mi",
  0x6, "eq",
  0x6, "z",
  0x7, "c",
  0x7, "ult",
  0x8, "t",
  0x9, "ge",
  0xa, "gt",
  0xb, "ugt",
  0xc, "nov",
  0xc, "po",
  0xd, "pl",
  0xe, "ne",
  0xe, "nz",
  0xf, "nc",
  0xf, "uge",
  0  , 0
d582 1
a582 1
     unsigned int dst;
a584 1
  int r;
d613 1
a613 1
     unsigned int dst;
a616 3
  unsigned int num;
  unsigned int len;
  unsigned int size;
d768 1
a768 1
		return;
d780 1
a780 1
	return;
d832 1
a832 2
  unsigned int dispreg;
  unsigned int this_index = opcode->idx;
d841 1
a841 1
	  int mode = operands[i].mode;
d905 1
d929 1
a960 1
  operand->X_add_number = n;
a961 1
#if 1
d964 1
a964 1
    case 8:			/* 8 nibbles == 32 bits  */
d969 1
a969 1
    case 4:			/* 4 niblles == 16 bits  */
a977 1
#endif
a978 1

d988 1
a988 1
     struct z8k_op *operand;
a989 4
  unsigned int i;

  int length;
  char *output;
a990 1
  char part;
a991 1
  char high;
d1002 1
a1002 2
 top:
  for (nibble = 0; c = *class_ptr++; nibble++)
d1014 1
a1014 1
	      da_operand->X_add_number |= 0x80000000;
d1097 5
a1101 5
              output_ptr = apply_fix (output_ptr, R_REL16, da_operand, 4);
              break;
            default:
	  output_ptr = apply_fix (output_ptr, R_IMM16, da_operand, 4);
            }
d1164 1
a1166 1
  unsigned int i;
a1170 3
  char *dot = 0;
  char c;

d1244 1
a1244 1
     object_headers *headers;
d1251 1
a1251 1
     char *name;
d1258 1
a1258 1
     object_headers *headers;
d1380 3
a1382 3
     object_headers *headers;
     segT seg;
     fragS *fragP;
d1462 2
a1463 2
     register fragS *fragP;
     register segT segment_type;
d1482 1
a1482 1
     fixS *fixP;
d1489 1
a1489 1
     symbolS *s;
@


1.9
log
@Fix copyright notices
@
text
@d1110 9
d1120 1
@


1.8
log
@2000-11-15  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-tic30.c: Fix formatting.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d2 2
a3 2
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation.
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000
   Free Software Foundation, Inc.
@


1.8.2.2
log
@Merge from mainline.
@
text
@d162 2
d181 2
a182 2
      fake_opcode->name = md_pseudo_table[idx].poc_name;
      fake_opcode->func = (void *) (md_pseudo_table + idx);
d407 9
a415 9
  { 0x2, "fcw" },
  { 0x3, "refresh" },
  { 0x4, "psapseg" },
  { 0x5, "psapoff" },
  { 0x5, "psap" },
  { 0x6, "nspseg" },
  { 0x7, "nspoff" },
  { 0x7, "nsp" },
  { 0  , 0 }
d422 1
a422 1
     unsigned int dst ATTRIBUTE_UNUSED;
d425 1
d458 7
a464 7
  { 0x1, "p" },
  { 0x1, "v" },
  { 0x2, "s" },
  { 0x4, "z" },
  { 0x8, "c" },
  { 0x0, "+" },
  { 0, 0 }
d471 1
a471 1
     unsigned int dst ATTRIBUTE_UNUSED;
d474 1
d511 5
a515 5
  { 0x1, "nvi" },
  { 0x2, "vi" },
  { 0x3, "both" },
  { 0x3, "all" },
  { 0, 0 }
d522 1
a522 1
     unsigned int dst ATTRIBUTE_UNUSED;
d525 1
d558 23
a580 23
  { 0x0, "f" },
  { 0x1, "lt" },
  { 0x2, "le" },
  { 0x3, "ule" },
  { 0x4, "ov" },
  { 0x4, "pe" },
  { 0x5, "mi" },
  { 0x6, "eq" },
  { 0x6, "z" },
  { 0x7, "c" },
  { 0x7, "ult" },
  { 0x8, "t" },
  { 0x9, "ge" },
  { 0xa, "gt" },
  { 0xb, "ugt" },
  { 0xc, "nov" },
  { 0xc, "po" },
  { 0xd, "pl" },
  { 0xe, "ne" },
  { 0xe, "nz" },
  { 0xf, "nc" },
  { 0xf, "uge" },
  { 0  ,  0 }
d587 1
a587 1
     unsigned int dst ATTRIBUTE_UNUSED;
d590 1
d619 1
a619 1
     unsigned int dst ATTRIBUTE_UNUSED;
d623 3
d777 1
a777 1
		return NULL;
d789 1
a789 1
	return NULL;
d841 2
a842 1
  int this_index = opcode->idx;
d851 1
a851 1
	  unsigned int mode = operands[i].mode;
a914 1
#if 0 /* Not used.  */
a937 1
#endif
d969 1
d971 1
d974 1
a974 1
    case 8:			/* 8 nibbles == 32 bits.  */
d979 1
a979 1
    case 4:			/* 4 nibbles == 16 bits.  */
d988 1
d990 1
d1000 1
a1000 1
     struct z8k_op *operand ATTRIBUTE_UNUSED;
d1002 4
d1007 1
d1009 1
d1020 2
a1021 1
  for (nibble = 0; (c = *class_ptr++); nibble++)
d1033 1
a1033 1
	      /* da_operand->X_add_number |= 0x80000000;  --  Now set at relocation time.  */
d1110 1
a1110 11
          switch (c & ARG_MASK)
            {
            case ARG_DISP12:
              output_ptr = apply_fix (output_ptr, R_CALLR, da_operand, 4);
              break;
            case ARG_DISP16:
	      output_ptr = apply_fix (output_ptr, R_REL16, da_operand, 4);
	      break;
	    default:
	      output_ptr = apply_fix (output_ptr, R_IMM16, da_operand, 4);
	    }
a1172 1
  char c;
d1175 1
d1180 3
d1256 1
a1256 1
     object_headers *headers ATTRIBUTE_UNUSED;
d1263 1
a1263 1
     char *name ATTRIBUTE_UNUSED;
d1270 1
a1270 1
     object_headers *headers ATTRIBUTE_UNUSED;
d1392 3
a1394 3
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d1474 2
a1475 2
     register fragS *fragP ATTRIBUTE_UNUSED;
     register segT segment_type ATTRIBUTE_UNUSED;
d1494 1
a1494 1
     fixS *fixP ATTRIBUTE_UNUSED;
d1501 1
a1501 1
     symbolS *s ATTRIBUTE_UNUSED;
@


1.7
log
@Kazu Hirata's formatting fixes.
@
text
@d190 1
a190 2
struct z8k_exp
{
d196 1
a196 2
typedef struct z8k_op
{
d210 1
a210 3
}

op_type;
d401 1
a401 2
struct ctrl_names
{
d451 1
a451 2
struct flag_names
{
d504 1
a504 2
struct interrupt_names
{
d510 1
a510 2
struct interrupt_names intr_table[] =
{
d551 1
a551 2
struct cc_names
{
d996 1
@


1.6
log
@Fix comments.
@
text
@d22 2
a23 4
/*
  Written By Steve Chamberlain
  sac@@cygnus.com
  */
a41 7
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */

d60 1
a60 2
static
void
a82 1

d102 8
d111 27
a137 30
}
const pseudo_typeS md_pseudo_table[] =
{
  {"int", cons, 2},
  {"data.b", cons, 1},
  {"data.w", cons, 2},
  {"data.l", cons, 4},
  {"form", listing_psize, 0},
  {"heading", listing_title, 0},
  {"import", s_ignore, 0},
  {"page", listing_eject, 0},
  {"program", s_ignore, 0},
  {"z8001", s_segm, 0},
  {"z8002", s_unseg, 0},


  {"segm", s_segm, 0},
  {"unsegm", s_unseg, 0},
  {"unseg", s_unseg, 0},
  {"name", s_app_file, 0},
  {"global", s_globl, 0},
  {"wval", cons, 2},
  {"lval", cons, 4},
  {"bval", cons, 1},
  {"sval", sval, 0},
  {"rsect", obj_coff_section, 0},
  {"sect", obj_coff_section, 0},
  {"block", s_space, 0},
  {"even", even, 0},
  {0, 0, 0}
d142 3
a144 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d147 2
a148 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
d161 1
a161 1
      /* Only enter unique codes into the table */
d173 1
a173 1
  /* default to z8002 */
d176 1
a176 1
  /* insert the pseudo ops too */
d196 1
d199 5
a203 2
  char regsize;			/* 'b','w','r','q' */
  unsigned int reg;		/* 0..15 */
d207 5
a211 2
  unsigned int x_reg;		/* any other register associated with the mode */
  expressionS exp;		/* any expression */
d242 1
a242 13
/*
  parse operands

  rh0-rh7, rl0-rl7
  r0-r15
  rr0-rr14
  rq0--rq12
  WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp
  r0l,r0h,..r7l,r7h
  @@WREG
  @@WREG+
  @@-WREG
  #const
d244 11
a254 1
  */
d271 4
a274 4
        {
          *mode = CLASS_REG_LONG;
          *reg = 14;
        }
d276 4
a279 4
        {
          *mode = CLASS_REG_WORD;
          *reg = 15;
        }
d285 3
a287 3
        {
          *mode = CLASS_REG_LONG;
          res = whatreg (reg, src + 2);
d290 2
a291 2
          	as_warn (_("register rr%d, out of range."),regno);
        }
d293 3
a295 3
        {
          *mode = CLASS_REG_BYTE;
          res = whatreg (reg, src + 2);
d298 2
a299 2
          	as_warn (_("register rh%d, out of range."),regno);
        }
d301 3
a303 3
        {
          *mode = CLASS_REG_BYTE;
          res = whatreg (reg, src + 2);
d306 3
a308 3
          	as_warn (_("register rl%d, out of range."),regno);
          *reg += 8;
        }
d310 3
a312 3
        {
          *mode = CLASS_REG_QUAD;
          res = whatreg (reg, src + 2);
d315 2
a316 2
          	as_warn (_("register rq%d, out of range."),regno);
        }
d318 3
a320 3
        {
          *mode = CLASS_REG_WORD;
          res = whatreg (reg, src + 1);
d323 2
a324 2
          	as_warn (_("register r%d, out of range."),regno);
        }
a326 1

a357 3



d360 1
a360 2
static
char *
d368 2
a369 3
    {
      as_bad (_("expected %c"), what);
    }
d373 2
a374 1
/* Make sure the mode supplied is the size of a word */
d389 2
a390 1
/* Make sure the mode supplied is the size of an address */
d407 2
a408 2
   int value;
   char *name;
d411 10
a420 11
struct ctrl_names ctrl_table[] =
{
   0x2, "fcw",
   0X3, "refresh",
   0x4, "psapseg",
   0x5, "psapoff",
   0x5, "psap",
   0x6, "nspseg",
   0x7, "nspoff",
   0x7, "nsp",
   0, 0
d422 1
a422 1
   
d442 4
a445 4
        {
          if (ctrl_table[i].name[j] != src[j])
            goto fail;
        }
d449 2
a450 1
    fail:;
d463 1
a463 2
struct flag_names flag_table[] =
{
d491 1
a491 1
     if (!src[j])
d493 8
a500 8
     for (i = 0; flag_table[i].name; i++)
        {
          if (flag_table[i].name[0] == src[j])
		{
	        the_flags = the_flags | flag_table[i].value;
		goto match;
		}
        }
d503 1
a503 1
     ;
d505 1
a505 1
  done:
a509 1

d545 4
a548 4
        {
          if (intr_table[i].name[j] != src[j])
            goto fail;
        }
d552 2
a553 1
    fail:;
d566 1
a566 2
struct cc_names table[] =
{
d589 1
a589 1
  0, 0
d618 2
a619 1
    fail:;
d670 1
a670 1
		  /* Got Ra(Rb) */
d674 1
a674 3
		    {
		      as_bad (_("Missing ) in ra(rb)"));
		    }
d676 1
a676 3
		    {
		      src++;
		    }
d679 3
a681 1
/*		  regword (mode->mode, "ra(rb) rb");*/
d689 1
a689 1
		  /* Got Ra(disp) */
d708 1
a708 1
	  /* No initial reg */
d723 1
a723 1
	      /* Just an address */
d734 1
a734 2
static
char *
d741 2
a742 1
char *savptr;
d753 3
a755 3
        {
          get_cc_operand (&ptr, operand + 0, 0);
        }
d757 7
a763 7
        {
          get_flags_operand (&ptr, operand + 0, 0);
        }
      else if (opcode->arg_info[0] == (CLASS_IMM +(ARG_IMM2)))
        {
          get_interrupt_operand (&ptr, operand + 0, 0);
        }
d765 3
a767 3
        {
          get_operand (&ptr, operand + 0, 0);
        }
d775 3
a777 3
        {
          get_cc_operand (&ptr, operand + 0, 0);
        }
d779 14
a792 14
             {
               get_ctrl_operand (&ptr, operand + 0, 0);
               if (the_ctrl == 0)
                 {
                   ptr = savptr;
                   get_operand (&ptr, operand + 0, 0);
                   if (ptr == 0)
                     return;
                   if (*ptr == ',')
                     ptr++;
                   get_ctrl_operand (&ptr, operand + 1, 1);
                   return ptr;
                 }
             }
d794 3
a796 3
        {
          get_operand (&ptr, operand + 0, 0);
        }
d798 1
a798 1
        return;
d800 1
a800 1
        ptr++;
d828 1
d837 2
a838 3
   addressing modes, return the opcode which matches the opcodes
   provided
   */
d840 1
a840 2
static
opcode_entry_type *
d864 2
a865 2
	      /* it could be an pc rel operand, if this is a da mode and
	   we like disps, then insert it */
d869 1
a869 1
		  /* This is the case */
d874 2
a875 2
		  /* Can't think of a way to turn what we've been given into
	     something that's ok */
d882 1
a882 1
		      /* ok */
d886 1
a886 1
		      /* ok */
d915 2
a916 1
    fail:;
d934 4
a937 3
      /* No symbol involved, let's look at offset, it's dangerous if any of
       the high bits are not 0 or ff's, find out by oring or anding with
       the width and seeing if the answer is 0 or all fs*/
d941 2
a942 1
	  as_warn (_("operand %s0x%x out of range."), string, operand->exp.X_add_number);
d983 1
a983 1
    case 8:			/* 8 nibbles == 32 bits */
d988 1
a988 1
    case 4:			/* 4 niblles == 16 bits */
d1002 2
a1003 2
/* Now we know what sort of opcodes it is, lets build the bytes -
 */
d1007 1
a1007 1
     opcode_entry_type * this_try;
a1026 1
top:;
d1028 1
d1035 1
a1036 1
	  abort ();
d1038 1
a1038 1
	  /* Direct address, we don't cope with the SS mode right now */
d1051 1
a1051 1
	  /* pc rel 8 bit */
d1057 1
a1057 1
	  /* pc rel 7 bit */
d1064 1
a1064 1
	  /* pc rel 7 bit */
d1067 1
a1067 1
          output_ptr[-2] =  0x8;
d1076 1
a1076 3
		{
		  *output_ptr |= 2;
		}
d1078 1
a1078 3
		{
		  as_bad (_("immediate must be 1 or 2"));
		}
d1081 1
a1081 3
	    {
	      as_bad (_("immediate 1 or 2 expected"));
	    }
d1087 15
a1101 15
        case CLASS_0CCC:
          *output_ptr++ = the_ctrl;
          break;
        case CLASS_1CCC:
          *output_ptr++ = the_ctrl | 0x8;
          break;
        case CLASS_00II:
          *output_ptr++ = (~the_interrupt & 0x3);
          break;
        case CLASS_01II:
          *output_ptr++ = (~the_interrupt & 0x3) | 0x4;
          break;
        case CLASS_FLAGS:
          *output_ptr++ = the_flags;
          break;
d1107 2
a1108 3
	    {
	      as_bad (_("can't use R0 here"));
	    }
d1114 1
a1114 2
	  /* Insert bit mattern of
	 right reg */
d1158 1
a1158 2
  /* Copy from the nibble buffer into the frag */

a1169 1

a1170 1

d1191 1
a1191 1
  /* Drop leading whitespace */
d1195 1
a1195 1
  /* find the op code end */
d1199 1
a1199 4
    {
    }

  ;
d1209 1
a1209 3
  opcode = (opcode_entry_type *) hash_find (opcode_hash_control,
					    op_start);

d1219 1
a1219 1
      /* was really a pseudo op */
a1226 1

d1241 1
a1241 2
      input_line_pointer = get_operands (opcode, op_end,
					 operand);
d1248 1
a1248 1
	  /* Couldn't find an opcode which matched the operands */
d1283 2
a1284 2
/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
d1287 5
a1291 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
   */
d1348 1
d1352 2
a1353 1
size_t md_longopts_size = sizeof(md_longopts);
d1385 1
a1385 1
  fprintf(stream, _("\
d1413 2
a1414 1
  return ((size + (1 << section_alignment[(int) seg]) - 1) & (-1 << section_alignment[(int) seg]));
d1434 4
a1437 1
      /*    if (val != 0) abort();*/
d1443 4
a1446 1
      /*    if (val != 0) abort();*/
a1476 1

d1489 1
a1489 1
/* Put number into target byte order */
d1499 1
d1522 2
a1523 2
  if (fix_ptr->fx_addsy &&
      fix_ptr->fx_subsy) 
d1527 5
a1531 1
      if (S_GET_SEGMENT(add) != S_GET_SEGMENT(sub))
d1533 5
a1537 2
	  as_bad(_("Can't subtract symbols in different sections %s %s"),
		 S_GET_NAME(add), S_GET_NAME(sub));
a1538 6
      else {
	int diff = S_GET_VALUE(add) - S_GET_VALUE(sub);
	fix_ptr->fx_addsy = 0;
	fix_ptr->fx_subsy = 0;
	fix_ptr->fx_offset += diff;
      }
d1543 1
a1543 1
     to output it */
d1546 1
a1546 1
      /* cons likes to create reloc32's whatever the size of the reloc.. */
a1560 1

d1563 1
a1563 3
    {
      intr->r_type = fix_ptr->fx_r_type;
    }
a1572 1

@


1.5
log
@Fix spelling typos.
Remove use of DEFUN().
@
text
@d256 3
a258 1
/* try and parse a reg name, returns number of chars consumed */
@


1.4
log
@Blow away DEFUN.
@
text
@d1188 2
a1189 3
   machine dependent instruction.  This funciton is supposed to emit
   the frags/bytes it assembles to.
   */
@


1.3
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d2 2
a3 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999 Free Software Foundation.
d224 3
a226 3
DEFUN (whatreg, (reg, src),
       int *reg AND
       char *src)
d258 4
a261 4
DEFUN (parse_reg, (src, mode, reg),
       char *src AND
       int *mode AND
       unsigned int *reg)
d329 3
a331 3
DEFUN (parse_exp, (s, op),
       char *s AND
       expressionS * op)
d364 3
a366 3
DEFUN (checkfor, (ptr, what),
       char *ptr AND
       char what)
d379 3
a381 3
DEFUN (regword, (mode, string),
       int mode AND
       char *string)
d394 3
a396 3
DEFUN (regaddr, (mode, string),
       int mode AND
       char *string)
d427 4
a430 4
DEFUN (get_ctrl_operand, (ptr, mode, dst),
       char **ptr AND
       struct z8k_op *mode AND
       unsigned int dst)
d477 4
a480 4
DEFUN (get_flags_operand, (ptr, mode, dst),
       char **ptr AND
       struct z8k_op *mode AND
       unsigned int dst)
d531 4
a534 4
DEFUN (get_interrupt_operand, (ptr, mode, dst),
       char **ptr AND
       struct z8k_op *mode AND
       unsigned int dst)
d597 4
a600 4
DEFUN (get_cc_operand, (ptr, mode, dst),
       char **ptr AND
       struct z8k_op *mode AND
       unsigned int dst)
d847 3
a849 3
DEFUN (get_specific, (opcode, operands),
       opcode_entry_type * opcode AND
       op_type * operands)
d930 4
a933 4
DEFUN (check_operand, (operand, width, string),
       struct z8k_op *operand AND
       unsigned int width AND
       char *string)
d954 4
a957 4
DEFUN (newfix, (ptr, type, operand),
       int ptr AND
       int type AND
       expressionS * operand)
d973 5
a977 5
DEFUN (apply_fix, (ptr, type, operand, size),
       char *ptr AND
       int type AND
       expressionS * operand AND
       int size)
d1193 2
a1194 2
DEFUN (md_assemble, (str),
       char *str)
d1285 2
a1286 2
DEFUN (tc_crawl_symbol_chain, (headers),
       object_headers * headers)
d1292 2
a1293 2
DEFUN (md_undefined_symbol, (name),
       char *name)
d1299 2
a1300 2
DEFUN (tc_headers_hook, (headers),
       object_headers * headers)
d1428 3
a1430 3
DEFUN (md_section_align, (seg, size),
       segT seg AND
       valueT size)
d1505 4
a1508 4
DEFUN (md_number_to_chars, (ptr, use, nbytes),
       char *ptr AND
       valueT use AND
       int nbytes)
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d34 3
a36 6
const char comment_chars[] =
{'!', 0};
const char line_separator_chars[] =
{';', 0};
const char line_comment_chars[] =
{'#', 0};
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation.
d1523 1
a1523 1
     struct symbol *s;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

