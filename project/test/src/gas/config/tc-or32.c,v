head	1.18;
access;
symbols
	binutils-2_24-branch:1.18.0.4
	binutils-2_24-branchpoint:1.18
	binutils-2_21_1:1.17
	binutils-2_23_2:1.18
	binutils-2_23_1:1.18
	binutils-2_23:1.18
	binutils-2_23-branch:1.18.0.2
	binutils-2_23-branchpoint:1.18
	binutils-2_22_branch:1.17.0.6
	binutils-2_22:1.17
	binutils-2_22-branch:1.17.0.4
	binutils-2_22-branchpoint:1.17
	binutils-2_21:1.17
	binutils-2_21-branch:1.17.0.2
	binutils-2_21-branchpoint:1.17
	binutils-2_20_1:1.16
	binutils-2_20:1.16
	binutils-arc-20081103-branch:1.14.0.8
	binutils-arc-20081103-branchpoint:1.14
	binutils-2_20-branch:1.16.0.2
	binutils-2_20-branchpoint:1.16
	dje-cgen-play1-branch:1.14.0.6
	dje-cgen-play1-branchpoint:1.14
	arc-20081103-branch:1.14.0.4
	arc-20081103-branchpoint:1.14
	binutils-2_19_1:1.14
	binutils-2_19:1.14
	binutils-2_19-branch:1.14.0.2
	binutils-2_19-branchpoint:1.14
	binutils-2_18:1.13
	binutils-2_18-branch:1.13.0.2
	binutils-2_18-branchpoint:1.13
	binutils-csl-coldfire-4_1-32:1.11
	binutils-csl-sourcerygxx-4_1-32:1.11
	binutils-csl-innovasic-fido-3_4_4-33:1.11
	binutils-csl-sourcerygxx-3_4_4-32:1.7
	binutils-csl-coldfire-4_1-30:1.11
	binutils-csl-sourcerygxx-4_1-30:1.11
	binutils-csl-coldfire-4_1-28:1.11
	binutils-csl-sourcerygxx-4_1-29:1.11
	binutils-csl-sourcerygxx-4_1-28:1.11
	binutils-csl-arm-2006q3-27:1.11
	binutils-csl-sourcerygxx-4_1-27:1.11
	binutils-csl-arm-2006q3-26:1.11
	binutils-csl-sourcerygxx-4_1-26:1.11
	binutils-csl-sourcerygxx-4_1-25:1.11
	binutils-csl-sourcerygxx-4_1-24:1.11
	binutils-csl-sourcerygxx-4_1-23:1.11
	binutils-csl-sourcerygxx-4_1-21:1.11
	binutils-csl-arm-2006q3-21:1.11
	binutils-csl-sourcerygxx-4_1-22:1.11
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.11
	binutils-csl-sourcerygxx-4_1-20:1.11
	binutils-csl-arm-2006q3-19:1.11
	binutils-csl-sourcerygxx-4_1-19:1.11
	binutils-csl-sourcerygxx-4_1-18:1.11
	binutils-csl-renesas-4_1-9:1.11
	binutils-csl-sourcerygxx-3_4_4-25:1.7
	binutils-csl-renesas-4_1-8:1.11
	binutils-csl-renesas-4_1-7:1.11
	binutils-csl-renesas-4_1-6:1.11
	binutils-csl-sourcerygxx-4_1-17:1.11
	binutils-csl-sourcerygxx-4_1-14:1.11
	binutils-csl-sourcerygxx-4_1-15:1.11
	binutils-csl-sourcerygxx-4_1-13:1.11
	binutils-2_17:1.11
	binutils-csl-sourcerygxx-4_1-12:1.11
	binutils-csl-sourcerygxx-3_4_4-21:1.11
	binutils-csl-wrs-linux-3_4_4-24:1.7
	binutils-csl-wrs-linux-3_4_4-23:1.7
	binutils-csl-sourcerygxx-4_1-9:1.11
	binutils-csl-sourcerygxx-4_1-8:1.11
	binutils-csl-sourcerygxx-4_1-7:1.11
	binutils-csl-arm-2006q1-6:1.11
	binutils-csl-sourcerygxx-4_1-6:1.11
	binutils-csl-wrs-linux-3_4_4-22:1.7
	binutils-csl-coldfire-4_1-11:1.11
	binutils-csl-sourcerygxx-3_4_4-19:1.11
	binutils-csl-coldfire-4_1-10:1.11
	binutils-csl-sourcerygxx-4_1-5:1.11
	binutils-csl-sourcerygxx-4_1-4:1.11
	binutils-csl-wrs-linux-3_4_4-21:1.7
	binutils-csl-morpho-4_1-4:1.11
	binutils-csl-sourcerygxx-3_4_4-17:1.11
	binutils-csl-wrs-linux-3_4_4-20:1.7
	binutils-2_17-branch:1.11.0.4
	binutils-2_17-branchpoint:1.11
	binutils-csl-2_17-branch:1.11.0.2
	binutils-csl-2_17-branchpoint:1.11
	binutils-csl-gxxpro-3_4-branch:1.7.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.7
	binutils-2_16_1:1.7
	binutils-csl-arm-2005q1b:1.7
	binutils-2_16:1.7
	binutils-csl-arm-2005q1a:1.7
	binutils-csl-arm-2005q1-branch:1.7.0.4
	binutils-csl-arm-2005q1-branchpoint:1.7
	binutils-2_16-branch:1.7.0.2
	binutils-2_16-branchpoint:1.7
	csl-arm-2004-q3d:1.5
	csl-arm-2004-q3:1.5
	binutils-2_15:1.5
	binutils-2_15-branchpoint:1.5
	csl-arm-2004-q1a:1.5
	csl-arm-2004-q1:1.5
	binutils-2_15-branch:1.5.0.6
	cagney_bfdfile-20040213-branch:1.5.0.4
	cagney_bfdfile-20040213-branchpoint:1.5
	cagney_bigcore-20040122-branch:1.5.0.2
	cagney_bigcore-20040122-branchpoint:1.5
	csl-arm-2003-q4:1.5
	binutils-2_14:1.4
	binutils-2_14-branch:1.4.0.2
	binutils-2_14-branchpoint:1.4
	binutils-2_13_2_1:1.2
	binutils-2_13_2:1.2
	binutils-2_13_1:1.2
	binutils-2_13:1.2
	binutils-2_13-branchpoint:1.2
	binutils-2_13-branch:1.2.0.2
	binutils-2_12_1:1.1
	binutils-2_12:1.1
	binutils-2_12-branch:1.1.0.2
	binutils-2_12-branchpoint:1.1
	binutils_latest_snapshot:1.18;
locks; strict;
comment	@ * @;


1.18
date	2012.05.17.15.13.16;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.21.13.04.14;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.05.09.13.02;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.24.20.40.27;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.03.11.47.54;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.31.23.18.33;	author bje;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.22.02.35.31;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.12.22.05.00;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.11.09.53.50;	author kazu;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.31.17.33.00;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.18
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* Assembly backend for the OpenRISC 1000.
   Copyright (C) 2002, 2003, 2005, 2007, 2009, 2010, 2012
   Free Software Foundation, Inc.
   Contributed by Damjan Lampret <lampret@@opencores.org>.
   Modified bu Johan Rydberg, <johan.rydberg@@netinsight.se>.
   Based upon a29k port.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/* tc-a29k.c used as a template.  */

#include "as.h"
#include "safe-ctype.h"
#include "opcode/or32.h"
#include "elf/or32.h"

#define DEBUG 0

#ifndef REGISTER_PREFIX
#define REGISTER_PREFIX   '%'
#endif

/* Make it easier to clone this machine desc into another one.  */
#define machine_opcode  or32_opcode
#define machine_opcodes or32_opcodes
#define machine_ip      or32_ip
#define machine_it      or32_it

/* Handle of the OPCODE hash table.  */
static struct hash_control *op_hash = NULL;

struct machine_it
{
  char *          error;
  unsigned long   opcode;
  struct nlist *  nlistp;
  expressionS     exp;
  int             pcrel;
  int             reloc_offset;   /* Offset of reloc within insn.  */
  int             reloc;
}
the_insn;

const pseudo_typeS md_pseudo_table[] =
{
  {"align",   s_align_bytes,  4 },
  {"space",   s_space,        0 },
  {"cputype", s_ignore,       0 },
  {"reg",     s_lsym,         0 },  /* Register equate, same as equ.  */
  {"sect",    s_ignore,       0 },  /* Creation of coff sections.  */
  {"proc",    s_ignore,       0 },  /* Start of a function.  */
  {"endproc", s_ignore,       0 },  /* Function end.  */
  {"word",    cons,           4 },
  {NULL,      0,              0 },
};

int md_short_jump_size  = 4;
int md_long_jump_size   = 4;

/* This array holds the chars that always start a comment.
   If the pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "#";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.  */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";

/* We needed an unused char for line separation to work around the
   lack of macros, using sed and such.  */
const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* "l.jalr r9" precalculated opcode.  */
static unsigned long jalr_r9_opcode;

static void machine_ip (char *);


/* Set bits in machine opcode according to insn->encoding
   description and passed operand.  */

static void
encode (const struct machine_opcode *insn,
	unsigned long *opcode,
	signed long param_val,
	char param_ch)
{
  int opc_pos = 0;
  int param_pos = 0;
  char *enc;

#if DEBUG
  printf ("    encode:  opcode=%.8lx  param_val=%.8lx abs=%.8lx param_ch=%c\n",
	  *opcode, param_val, abs (param_val), param_ch);
#endif
  for (enc = insn->encoding; *enc != '\0'; enc++)
    if (*enc == param_ch)
      {
	if (enc - 2 >= insn->encoding && (*(enc - 2) == '0') && (*(enc - 1) == 'x'))
	  continue;
	else
	  param_pos ++;
      }

  opc_pos = 32;

  for (enc = insn->encoding; *enc != '\0';)
    {
      if ((*enc == '0') && (*(enc + 1) == 'x'))
	{
	  int tmp = strtol (enc, NULL, 16);

	  opc_pos -= 4;
	  *opcode |= tmp << opc_pos;
	  enc += 3;
	}
      else if ((*enc == '0') || (*enc == '-'))
	{
	  opc_pos--;
	  enc++;
	}
      else if (*enc == '1')
	{
	  opc_pos--;
	  *opcode |= 1 << opc_pos;
	  enc++;
	}
      else if (*enc == param_ch)
	{
	  opc_pos--;
	  param_pos--;
	  *opcode |= ((param_val >> param_pos) & 0x1) << opc_pos;
	  enc++;
	}
      else if (ISALPHA (*enc))
	{
	  opc_pos--;
	  enc++;
	}
      else
	enc++;
    }

#if DEBUG
  printf ("    opcode=%.8lx\n", *opcode);
#endif
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc., that the MD part of the assembler will
   need.  */

void
md_begin (void)
{
  const char *retval = NULL;
  int lose = 0;
  int skipnext = 0;
  unsigned int i;

  /* Hash up all the opcodes for fast use later.  */
  op_hash = hash_new ();

  for (i = 0; i < or32_num_opcodes; i++)
    {
      const char *name = machine_opcodes[i].name;

      if (skipnext)
        {
          skipnext = 0;
          continue;
        }

      retval = hash_insert (op_hash, name, (void *) &machine_opcodes[i]);
      if (retval != NULL)
        {
          fprintf (stderr, "internal error: can't hash `%s': %s\n",
                   machine_opcodes[i].name, retval);
          lose = 1;
        }
    }

  if (lose)
    as_fatal (_("Broken assembler.  No assembly attempted."));

  encode (&machine_opcodes[insn_index ("l.jalr")], &jalr_r9_opcode, 9, 'B');
}

/* Returns non zero if instruction is to be used.  */

static int
check_invalid_opcode (unsigned long opcode)
{
  return opcode == jalr_r9_opcode;
}

/* Assemble a single instruction.  Its label has already been handled
   by the generic front end.  We just parse opcode and operands, and
   produce the bytes of data and relocation.  */

void
md_assemble (char *str)
{
  char *toP;

#if DEBUG
  printf ("NEW INSTRUCTION\n");
#endif

  know (str);
  machine_ip (str);
  toP = frag_more (4);

  /* Put out the opcode.  */
  md_number_to_chars (toP, the_insn.opcode, 4);

  /* Put out the symbol-dependent stuff.  */
  if (the_insn.reloc != BFD_RELOC_NONE)
    {
      fix_new_exp (frag_now,
                   (toP - frag_now->fr_literal + the_insn.reloc_offset),
                   4,   /* size */
                   &the_insn.exp,
                   the_insn.pcrel,
                   the_insn.reloc);
    }
}

/* This is true of the we have issued a "lo(" or "hi"(.  */
static int waiting_for_shift = 0;

static int mask_or_shift = 0;

static char *
parse_operand (char *s, expressionS *operandp, int opt)
{
  char *save = input_line_pointer;
  char *new_pointer;

#if DEBUG
  printf ("  PROCESS NEW OPERAND(%s) == %c (%d)\n", s, opt ? opt : '!', opt);
#endif

  input_line_pointer = s;

  if (strncasecmp (s, "HI(", 3) == 0)
    {
      waiting_for_shift = 1;
      mask_or_shift = BFD_RELOC_HI16;

      input_line_pointer += 3;
    }
  else if (strncasecmp (s, "LO(", 3) == 0)
    {
      mask_or_shift = BFD_RELOC_LO16;

      input_line_pointer += 3;
    }
  else
    mask_or_shift = 0;

  if ((*s == '(') && (*(s+1) == 'r'))
    s++;

  if ((*s == 'r') && ISDIGIT (*(s + 1)))
    {
      operandp->X_add_number = strtol (s + 1, NULL, 10);
      operandp->X_op = O_register;
      for (; (*s != ',') && (*s != '\0');)
        s++;
      input_line_pointer = save;
      return s;
    }

  expression (operandp);

  if (operandp->X_op == O_absent)
    {
      if (! opt)
        as_bad (_("missing operand"));
      else
        {
          operandp->X_add_number = 0;
          operandp->X_op = O_constant;
        }
    }

  new_pointer = input_line_pointer;
  input_line_pointer = save;

#if DEBUG
  printf ("  %s=parse_operand(%s): operandp->X_op = %u\n", new_pointer, s,
          operandp->X_op);
#endif

  return new_pointer;
}

/* Instruction parsing.  Takes a string containing the opcode.
   Operands are at input_line_pointer.  Output is in the_insn.
   Warnings or errors are generated.  */

static void
machine_ip (char *str)
{
  char *s;
  const char *args;
  const struct machine_opcode *insn;
  unsigned long opcode;
  expressionS the_operand;
  expressionS *operand = &the_operand;
  unsigned int regno;
  int reloc = BFD_RELOC_NONE;

#if DEBUG
  printf ("machine_ip(%s)\n", str);
#endif

  s = str;
  for (; ISALNUM (*s) || *s == '.'; ++s)
    if (ISUPPER (*s))
      *s = TOLOWER (*s);

  switch (*s)
    {
    case '\0':
      break;

    case ' ':     /* FIXME-SOMEDAY more whitespace.  */
      *s++ = '\0';
      break;

    default:
      as_bad (_("unknown opcode1: `%s'"), str);
      return;
    }

  if ((insn = (struct machine_opcode *) hash_find (op_hash, str)) == NULL)
    {
      as_bad (_("unknown opcode2 `%s'."), str);
      return;
    }

  opcode = 0;
  memset (&the_insn, '\0', sizeof (the_insn));
  the_insn.reloc = BFD_RELOC_NONE;

  reloc = BFD_RELOC_NONE;

  /* Build the opcode, checking as we go to make sure that the
     operands match.

     If an operand matches, we modify the_insn or opcode appropriately,
     and do a "continue".  If an operand fails to match, we "break".  */
  if (insn->args[0] != '\0')
    /* Prime the pump.  */
    s = parse_operand (s, operand, insn->args[0] == 'I');

  for (args = insn->args;; ++args)
    {
#if DEBUG
      printf ("  args = %s\n", args);
#endif
      switch (*args)
        {
        case '\0':    /* End of args.  */
          /* We have have 0 args, do the bazoooka!  */
          if (args == insn->args)
	    encode (insn, &opcode, 0, 0);

          if (*s == '\0')
            {
              /* We are truly done.  */
              the_insn.opcode = opcode;
              if (check_invalid_opcode (opcode))
                as_bad (_("instruction not allowed: %s"), str);
              return;
            }
          as_bad (_("too many operands: %s"), s);
          break;

        case ',':   /* Must match a comma.  */
          if (*s++ == ',')
            {
              reloc = BFD_RELOC_NONE;

              /* Parse next operand.  */
              s = parse_operand (s, operand, args[1] == 'I');
#if DEBUG
	      printf ("    ',' case: operand->X_add_number = %d, *args = %s, *s = %s\n",
		      operand->X_add_number, args, s);
#endif
              continue;
            }
          break;

        case '(':   /* Must match a (.  */
          s = parse_operand (s, operand, args[1] == 'I');
          continue;

        case ')':   /* Must match a ).  */
          continue;

        case 'r':   /* A general register.  */
          args++;

          if (operand->X_op != O_register)
            break;    /* Only registers.  */

          know (operand->X_add_symbol == 0);
          know (operand->X_op_symbol == 0);
          regno = operand->X_add_number;
          encode (insn, &opcode, regno, *args);
#if DEBUG
          printf ("    r: operand->X_op = %d\n", operand->X_op);
#endif
          continue;

        default:
          /* if (! ISALPHA (*args))
               break;  */   /* Only immediate values.  */

          if (mask_or_shift)
	    {
#if DEBUG
	      printf ("mask_or_shift = %d\n", mask_or_shift);
#endif
	      reloc = mask_or_shift;
	    }
          mask_or_shift = 0;

          if (strncasecmp (args, "LO(", 3) == 0)
            {
#if DEBUG
              printf ("reloc_const\n");
#endif
              reloc = BFD_RELOC_LO16;
            }
          else if (strncasecmp (args, "HI(", 3) == 0)
            {
#if DEBUG
              printf ("reloc_consth\n");
#endif
              reloc = BFD_RELOC_HI16;
            }

          if (*s == '(')
	    operand->X_op = O_constant;
          else if (*s == ')')
            s += 1;
#if DEBUG
          printf ("    default case: operand->X_add_number = %d, *args = %s, *s = %s\n", operand->X_add_number, args, s);
#endif
          if (operand->X_op == O_constant)
            {
	      if (reloc == BFD_RELOC_NONE)
		{
		  bfd_vma v, mask;

		  mask = 0x3ffffff;
		  v = abs (operand->X_add_number) & ~ mask;
		  if (v)
		    as_bad (_("call/jmp target out of range (1)"));
		}

              if (reloc == BFD_RELOC_HI16)
		operand->X_add_number = ((operand->X_add_number >> 16) & 0xffff);

              the_insn.pcrel = 0;
              encode (insn, &opcode, operand->X_add_number, *args);
 /*             the_insn.reloc = BFD_RELOC_NONE; */
              continue;
            }

          if (reloc == BFD_RELOC_NONE)
            the_insn.reloc = BFD_RELOC_32_GOT_PCREL;
          else
            the_insn.reloc = reloc;

          /* the_insn.reloc = insn->reloc;  */
#if DEBUG
          printf ("    reloc sym=%d\n", the_insn.reloc);
          printf ("    BFD_RELOC_NONE=%d\n", BFD_RELOC_NONE);
#endif
          the_insn.exp = *operand;

          /*  the_insn.reloc_offset = 1;  */
          the_insn.pcrel = 1; /* Assume PC-relative jump.  */

          /* FIXME-SOON, Do we figure out whether abs later, after
             know sym val?  */
          if (reloc == BFD_RELOC_LO16 || reloc == BFD_RELOC_HI16)
            the_insn.pcrel = 0;

          encode (insn, &opcode, operand->X_add_number, *args);
          continue;
        }

      /* Types or values of args don't match.  */
      as_bad (_("invalid operands"));
      return;
    }
}

char *
md_atof (int type, char * litP, int *  sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

/* Write out big-endian.  */

void
md_number_to_chars (char *buf, valueT val, int n)
{
  number_to_chars_bigendian (buf, val, n);
}

void
md_apply_fix (fixS * fixP, valueT * val, segT seg ATTRIBUTE_UNUSED)
{
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  long t_val;

  t_val = (long) *val;

#if DEBUG
  printf ("md_apply_fix val:%x\n", t_val);
#endif

  fixP->fx_addnumber = t_val; /* Remember value for emit_reloc.  */

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_32:      /* XXXXXXXX pattern in a word.  */
#if DEBUG
      printf ("reloc_const: val=%x\n", t_val);
#endif
      buf[0] = t_val >> 24;
      buf[1] = t_val >> 16;
      buf[2] = t_val >> 8;
      buf[3] = t_val;
      break;

    case BFD_RELOC_16:      /* XXXX0000 pattern in a word.  */
#if DEBUG
      printf ("reloc_const: val=%x\n", t_val);
#endif
      buf[0] = t_val >> 8;
      buf[1] = t_val;
      break;

    case BFD_RELOC_8:      /* XX000000 pattern in a word.  */
#if DEBUG
      printf ("reloc_const: val=%x\n", t_val);
#endif
      buf[0] = t_val;
      break;

    case BFD_RELOC_LO16:      /* 0000XXXX pattern in a word.  */
#if DEBUG
      printf ("reloc_const: val=%x\n", t_val);
#endif
      buf[2] = t_val >> 8;  /* Holds bits 0000XXXX.  */
      buf[3] = t_val;
      break;

    case BFD_RELOC_HI16:    /* 0000XXXX pattern in a word.  */
#if DEBUG
      printf ("reloc_consth: val=%x\n", t_val);
#endif
      buf[2] = t_val >> 24; /* Holds bits XXXX0000.  */
      buf[3] = t_val >> 16;
      break;

    case BFD_RELOC_32_GOT_PCREL:  /* 0000XXXX pattern in a word.  */
      if (!fixP->fx_done)
        ;
      else if (fixP->fx_pcrel)
        {
          long v = t_val >> 28;

          if (v != 0 && v != -1)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("call/jmp target out of range (2)"));
        }
      else
        /* This case was supposed to be handled in machine_ip.  */
        abort ();

      buf[0] |= (t_val >> 26) & 0x03; /* Holds bits 0FFFFFFC of address.  */
      buf[1] = t_val >> 18;
      buf[2] = t_val >> 10;
      buf[3] = t_val >> 2;
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      break;

    case BFD_RELOC_NONE:
    default:
      as_bad (_("bad relocation type: 0x%02x"), fixP->fx_r_type);
      break;
    }

  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;
}

/* Should never be called for or32.  */

void
md_create_short_jump (char *    ptr       ATTRIBUTE_UNUSED,
		      addressT  from_addr ATTRIBUTE_UNUSED,
		      addressT  to_addr   ATTRIBUTE_UNUSED,
		      fragS *   frag      ATTRIBUTE_UNUSED,
		      symbolS * to_symbol ATTRIBUTE_UNUSED)
{
  as_fatal ("or32_create_short_jmp\n");
}

/* Should never be called for or32.  */

void
md_convert_frag (bfd *   headers ATTRIBUTE_UNUSED,
		 segT    seg     ATTRIBUTE_UNUSED,
		 fragS * fragP   ATTRIBUTE_UNUSED)
{
  as_fatal ("or32_convert_frag\n");
}

/* Should never be called for or32.  */

void
md_create_long_jump (char *    ptr       ATTRIBUTE_UNUSED,
		     addressT  from_addr ATTRIBUTE_UNUSED,
		     addressT  to_addr   ATTRIBUTE_UNUSED,
		     fragS *   frag      ATTRIBUTE_UNUSED,
		     symbolS * to_symbol ATTRIBUTE_UNUSED)
{
  as_fatal ("or32_create_long_jump\n");
}

/* Should never be called for or32.  */

int
md_estimate_size_before_relax (fragS * fragP   ATTRIBUTE_UNUSED,
			       segT    segtype ATTRIBUTE_UNUSED)
{
  as_fatal ("or32_estimate_size_before_relax\n");
  return 0;
}

/* Translate internal representation of relocation info to target format.

   On sparc/29k: first 4 bytes are normal unsigned long address, next three
   bytes are index, most sig. byte first.  Byte 7 is broken up with
   bit 7 as external, bits 6 & 5 unused, and the lower
   five bits as relocation type.  Next 4 bytes are long addend.  */
/* Thanx and a tip of the hat to Michael Bloom, mb@@ttidca.tti.com.  */

#ifdef OBJ_AOUT
void
tc_aout_fix_to_chars (char *where,
		      fixS *fixP,
		      relax_addressT segment_address_in_file)
{
  long r_symbolnum;

#if DEBUG
  printf ("tc_aout_fix_to_chars\n");
#endif

  know (fixP->fx_r_type < BFD_RELOC_NONE);
  know (fixP->fx_addsy != NULL);

  md_number_to_chars
    (where,
     fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
     4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
     ? S_GET_TYPE (fixP->fx_addsy)
     : fixP->fx_addsy->sy_number);

  where[4] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[6] = r_symbolnum & 0x0ff;
  where[7] = (((!S_IS_DEFINED (fixP->fx_addsy)) << 7) & 0x80) | (0 & 0x60) | (fixP->fx_r_type & 0x1F);

  /* Also easy.  */
  md_number_to_chars (&where[8], fixP->fx_addnumber, 4);
}

#endif /* OBJ_AOUT */

const char *md_shortopts = "";

struct option md_longopts[] =
{
  { NULL, no_argument, NULL, 0 }
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c ATTRIBUTE_UNUSED, char * arg ATTRIBUTE_UNUSED)
{
  return 0;
}

void
md_show_usage (FILE * stream ATTRIBUTE_UNUSED)
{
}

/* This is called when a line is unrecognized.  This is used to handle
   definitions of or32 style local labels.  */

int
or32_unrecognized_line (int c)
{
  int lab;
  char *s;

  if (c != '$'
      || ! ISDIGIT ((unsigned char) input_line_pointer[0]))
    return 0;

  s = input_line_pointer;

  lab = 0;
  while (ISDIGIT ((unsigned char) *s))
    {
      lab = lab * 10 + *s - '0';
      ++s;
    }

  if (*s != ':')
    /* Not a label definition.  */
    return 0;

  if (dollar_label_defined (lab))
    {
      as_bad (_("label \"$%d\" redefined"), lab);
      return 0;
    }

  define_dollar_label (lab);
  colon (dollar_label_name (lab, 0));
  input_line_pointer = s + 1;

  return 1;
}

/* Default the values of symbols known that should be "predefined".  We
   don't bother to predefine them unless you actually use one, since there
   are a lot of them.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return NULL;
}

/* Parse an operand that is machine-specific.  */

void
md_operand (expressionS *expressionP)
{
#if DEBUG
  printf ("  md_operand(input_line_pointer = %s)\n", input_line_pointer);
#endif

  if (input_line_pointer[0] == REGISTER_PREFIX && input_line_pointer[1] == 'r')
    {
      /* We have a numeric register expression.  No biggy.  */
      input_line_pointer += 2;  /* Skip %r */
      (void) expression (expressionP);

      if (expressionP->X_op != O_constant
          || expressionP->X_add_number > 255)
        as_bad (_("Invalid expression after %%%%\n"));
      expressionP->X_op = O_register;
    }
  else if (input_line_pointer[0] == '&')
    {
      /* We are taking the 'address' of a register...this one is not
         in the manual, but it *is* in traps/fpsymbol.h!  What they
         seem to want is the register number, as an absolute number.  */
      input_line_pointer++; /* Skip & */
      (void) expression (expressionP);

      if (expressionP->X_op != O_register)
        as_bad (_("invalid register in & expression"));
      else
        expressionP->X_op = O_constant;
    }
  else if (input_line_pointer[0] == '$'
           && ISDIGIT ((unsigned char) input_line_pointer[1]))
    {
      long lab;
      char *name;
      symbolS *sym;

      /* This is a local label.  */
      ++input_line_pointer;
      lab = (long) get_absolute_expression ();

      if (dollar_label_defined (lab))
        {
          name = dollar_label_name (lab, 0);
          sym = symbol_find (name);
        }
      else
        {
          name = dollar_label_name (lab, 1);
          sym = symbol_find_or_make (name);
        }

      expressionP->X_op = O_symbol;
      expressionP->X_add_symbol = sym;
      expressionP->X_add_number = 0;
    }
  else if (input_line_pointer[0] == '$')
    {
      char *s;
      char type;
      int fieldnum, fieldlimit;
      LITTLENUM_TYPE floatbuf[8];

      /* $float(), $doubleN(), or $extendN() convert floating values
         to integers.  */
      s = input_line_pointer;

      ++s;

      fieldnum = 0;
      if (strncmp (s, "double", sizeof "double" - 1) == 0)
        {
          s += sizeof "double" - 1;
          type = 'd';
          fieldlimit = 2;
        }
      else if (strncmp (s, "float", sizeof "float" - 1) == 0)
        {
          s += sizeof "float" - 1;
          type = 'f';
          fieldlimit = 1;
        }
      else if (strncmp (s, "extend", sizeof "extend" - 1) == 0)
        {
          s += sizeof "extend" - 1;
          type = 'x';
          fieldlimit = 4;
        }
      else
	return;

      if (ISDIGIT (*s))
        {
          fieldnum = *s - '0';
          ++s;
        }
      if (fieldnum >= fieldlimit)
        return;

      SKIP_WHITESPACE ();
      if (*s != '(')
        return;
      ++s;
      SKIP_WHITESPACE ();

      s = atof_ieee (s, type, floatbuf);
      if (s == NULL)
        return;
      s = s;

      SKIP_WHITESPACE ();
      if (*s != ')')
        return;
      ++s;
      SKIP_WHITESPACE ();

      input_line_pointer = s;
      expressionP->X_op = O_constant;
      expressionP->X_unsigned = 1;
      expressionP->X_add_number = ((floatbuf[fieldnum * 2]
                                    << LITTLENUM_NUMBER_OF_BITS)
                                   + floatbuf[fieldnum * 2 + 1]);
    }
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size ATTRIBUTE_UNUSED)
{
  return size;      /* Byte alignment is fine.  */
}

/* Exactly what point is a PC-relative offset relative TO?
   On the 29000, they're relative to the address of the instruction,
   which we have set up as the address of the fixup too.  */

long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_where + fixP->fx_frag->fr_address;
}

/* Generate a reloc for a fixup.  */

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;

  reloc = xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  /*  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where + fixp->fx_addnumber;*/
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }

  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  reloc->addend = fixp->fx_addnumber;
  return reloc;
}
@


1.17
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2005, 2007, 2009, 2010
d27 1
a28 1
#include "as.h"
@


1.16
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2005, 2007, 2009
a335 1
  char *argsStart;
a370 1
  argsStart = s;
@


1.15
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2005, 2007
@


1.14
log
@Remove duplicate definitions of the md_atof() function
@
text
@d265 1
a265 1
  char *new;
d315 1
a315 1
  new = input_line_pointer;
d319 2
a320 1
  printf ("  %s=parse_operand(%s): operandp->X_op = %u\n", new, s, operandp->X_op);
d323 1
a323 1
  return new;
@


1.13
log
@Switch to GPLv3
@
text
@a532 11
/* This is identical to the md_atof in m68k.c.  I think this is right,
   but I'm not sure.

   Turn a string in input_line_pointer into a floating point constant
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP .  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

d536 1
a536 49
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return NULL;
@


1.12
log
@	* config/atof-vax.c (atof_vax_sizeof): Change return type to unsigned.
	(md_atof): Make number_of_chars unsigned.  Revert last change.
	* config/tc-or32.c (md_apply_fix): Delete bogus assertions.
	* config/tc-sh.c (sh_optimize_expr): Only define for OBJ_ELF.
	* config/tc-sh.h (md_optimize_expr): Likewise.
	* config/tc-sh64.c (shmedia_md_pcrel_from_section): Delete bogus
	assertion.
	* config/tc-xtensa.c (convert_frag_immed_finish_loop): Likewise.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.11
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
a619 3
  know (fixP->fx_size == 4);
  know (fixP->fx_r_type < BFD_RELOC_NONE);

@


1.10
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a28 2

#ifdef BFD_ASSEMBLER
a29 1
#endif
a73 10
#if defined(BFD_HEADERS)
#ifdef RELSZ
const int md_reloc_size = RELSZ;  /* Coff headers.  */
#else
const int md_reloc_size = 12;   /* Something else headers.  */
#endif
#else
const int md_reloc_size = 12;   /* Not bfdized.  */
#endif

a243 1
#ifdef BFD_ASSEMBLER
a244 3
#else
  if (the_insn.reloc != NO_RELOC)
#endif
a259 1
#ifdef BFD_ASSEMBLER
a322 71
#else

static char *
parse_operand (char *s, expressionS *operandp, int opt)
{
  char *save = input_line_pointer;
  char *new;

#if DEBUG
  printf ("  PROCESS NEW OPERAND(%s) == %c (%d)\n", s, opt ? opt : '!', opt);
#endif

  input_line_pointer = s;

  if (strncasecmp (s, "HI(", 3) == 0)
    {
      waiting_for_shift = 1;
      mask_or_shift = RELOC_CONSTH;

      input_line_pointer += 3;
    }
  else if (strncasecmp (s, "LO(", 3) == 0)
    {
      mask_or_shift = RELOC_CONST;

      input_line_pointer += 3;
    }
  else
    mask_or_shift = 0;

  expression (operandp);

  if (operandp->X_op == O_absent)
    {
      if (! opt)
        as_bad (_("missing operand"));
      else
        {
          operandp->X_add_number = 0;
          operandp->X_op = O_constant;
        }
    }

  new = input_line_pointer;
  input_line_pointer = save;

  if ((operandp->X_op == O_symbol) && (*s != '_'))
    {
#if DEBUG
      printf ("symbol: '%s'\n", save);
#endif

      for (save = s; s < new; s++)
        if ((*s == REGISTER_PREFIX) && (*(s + 1) == 'r')) /* Register prefix.  */
          s++;

        if ((*s == 'r') && ISDIGIT (*(s + 1)))
          {
            operandp->X_add_number = strtol (s + 1, NULL, 10);
            operandp->X_op = O_register;
          }
      s = save;
    }

#if DEBUG
  printf ("  %s=parse_operand(%s): operandp->X_op = %u\n", new, s, operandp->X_op);
#endif

  return new;
}
#endif
a327 1
#ifdef BFD_ASSEMBLER
a531 208
#else

static void
machine_ip (char *str)
{
  char *s;
  const char *args;
  const struct machine_opcode *insn;
  char *argsStart;
  unsigned long opcode;
  expressionS the_operand;
  expressionS *operand = &the_operand;
  unsigned int regno;
  int reloc = NO_RELOC;

#if DEBUG
  printf ("machine_ip(%s)\n", str);
#endif

  s = str;
  for (; ISALNUM (*s) || *s == '.'; ++s)
    if (ISUPPER (*s))
      *s = TOLOWER (*s);

  switch (*s)
    {
    case '\0':
      break;

    case ' ':     /* FIXME-SOMEDAY more whitespace.  */
      *s++ = '\0';
      break;

    default:
      as_bad (_("unknown opcode1: `%s'"), str);
      return;
    }

  if ((insn = (struct machine_opcode *) hash_find (op_hash, str)) == NULL)
    {
      as_bad (_("unknown opcode2 `%s'."), str);
      return;
    }

  argsStart = s;
  opcode = 0;
  memset (&the_insn, '\0', sizeof (the_insn));
  the_insn.reloc = NO_RELOC;

  reloc = NO_RELOC;

  /* Build the opcode, checking as we go to make sure that the
     operands match.

     If an operand matches, we modify the_insn or opcode appropriately,
     and do a "continue".  If an operand fails to match, we "break".  */
  if (insn->args[0] != '\0')
    /* Prime the pump.  */
    s = parse_operand (s, operand,
		       insn->args[0] == 'I'
		       || strcmp (insn->name, "l.nop") == 0);

  for (args = insn->args;; ++args)
    {
#if DEBUG
      printf ("  args = %s\n", args);
#endif
      switch (*args)
        {
        case '\0':    /* End of args.  */
          /* We have have 0 args, do the bazoooka!  */
          if (args == insn->args)
	    encode (insn, &opcode, 0, 0);

          if (*s == '\0')
            {
              /* We are truly done.  */
              the_insn.opcode = opcode;
              if (check_invalid_opcode (opcode))
                as_bad (_("instruction not allowed: %s"), str);
              return;
            }
          as_bad (_("too many operands: %s"), s);
          break;

        case ',':   /* Must match a comma.  */
          if (*s++ == ',')
            {
              reloc = NO_RELOC;

              /* Parse next operand.  */
              s = parse_operand (s, operand, args[1] == 'I');
#if DEBUG
	      printf ("    ',' case: operand->X_add_number = %d, *args = %s, *s = %s\n",
		      operand->X_add_number, args, s);
#endif
              continue;
            }
          break;

        case '(':   /* Must match a (.  */
          s = parse_operand (s, operand, args[1] == 'I');
          continue;

        case ')':   /* Must match a ).  */
          continue;

        case 'r':   /* A general register.  */
          args++;

          if (operand->X_op != O_register)
            break;    /* Only registers.  */

          know (operand->X_add_symbol == 0);
          know (operand->X_op_symbol == 0);
          regno = operand->X_add_number;
          encode (insn, &opcode, regno, *args);
#if DEBUG
          printf ("    r: operand->X_op = %d\n", operand->X_op);
#endif
          continue;

        default:
          /* if (! ISALPHA (*args))
               break;  */   /* Only immediate values.  */

          if (mask_or_shift)
	    {
#if DEBUG
	      printf ("mask_or_shift = %d\n", mask_or_shift);
#endif
	      reloc = mask_or_shift;
	    }
          mask_or_shift = 0;

          if (strncasecmp (args, "LO(", 3) == 0)
            {
#if DEBUG
              printf ("reloc_const\n");
#endif
              reloc = RELOC_CONST;
            }
          else if (strncasecmp (args, "HI(", 3) == 0)
            {
#if DEBUG
              printf ("reloc_consth\n");
#endif
              reloc = RELOC_CONSTH;
            }

          if (*s == '(')
	    operand->X_op = O_constant;
          else if (*s == ')')
            s += 1;
#if DEBUG
          printf ("    default case: operand->X_add_number = %d, *args = %s, *s = %s\n",
		  operand->X_add_number, args, s);
#endif
          if (operand->X_op == O_constant)
            {
	      if (reloc == NO_RELOC)
		{
		  unsigned long v, mask;

		  mask = 0x3ffffff;
		  v = abs (operand->X_add_number) & ~ mask;
		  if (v)
		    as_bad (_("call/jmp target out of range (1)"));
		}

              if (reloc == RELOC_CONSTH)
		operand->X_add_number = ((operand->X_add_number>>16) & 0xffff);

              the_insn.pcrel = 0;
              encode (insn, &opcode, operand->X_add_number, *args);
	      /* the_insn.reloc = NO_RELOC; */
              continue;
            }

          if (reloc == NO_RELOC)
            the_insn.reloc = RELOC_JUMPTARG;
          else
            the_insn.reloc = reloc;
#if DEBUG
          printf ("    reloc sym=%d\n", the_insn.reloc);
          printf ("    NO_RELOC=%d\n", NO_RELOC);
#endif
          the_insn.exp = *operand;

          /*  the_insn.reloc_offset = 1;  */
          the_insn.pcrel = 1; /* Assume PC-relative jump.  */

          /* FIXME-SOON, Do we figure out whether abs later, after
             know sym val?  */
          if (reloc == RELOC_CONST || reloc == RELOC_CONSTH)
            the_insn.pcrel = 0;

          encode (insn, &opcode, operand->X_add_number, *args);
          continue;
        }

      /* Types or values of args don't match.  */
      as_bad (_("invalid operands"));
      return;
    }
}
#endif

a604 1
#ifdef BFD_ASSEMBLER
a699 147
#else
void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  long val = *valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;

#if DEBUG
  printf ("md_apply_fix val:%x\n", val);
#endif

  fixP->fx_addnumber = val; /* Remember value for emit_reloc.  */

  know (fixP->fx_size == 4);
  know (fixP->fx_r_type < NO_RELOC);

  /* This is a hack.  There should be a better way to handle this.  */
  if (fixP->fx_r_type == RELOC_WDISP30 && fixP->fx_addsy)
    val += fixP->fx_where + fixP->fx_frag->fr_address;

  switch (fixP->fx_r_type)
    {
    case RELOC_32:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_8:
      buf[0] = val;
      break;

    case RELOC_WDISP30:
      val = (val >> 2) + 1;
      buf[0] |= (val >> 24) & 0x3f;
      buf[1] = (val >> 16);
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_HI22:
      buf[1] |= (val >> 26) & 0x3f;
      buf[2] = val >> 18;
      buf[3] = val >> 10;
      break;

    case RELOC_LO10:
      buf[2] |= (val >> 8) & 0x03;
      buf[3] = val;
      break;

    case RELOC_BASE13:
      buf[2] |= (val >> 8) & 0x1f;
      buf[3] = val;
      break;

    case RELOC_WDISP22:
      val = (val >> 2) + 1;
      /* FALLTHROUGH */
    case RELOC_BASE22:
      buf[1] |= (val >> 16) & 0x3f;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_JUMPTARG:  /* 0000XXXX pattern in a word.  */
      if (!fixP->fx_done)
        {
          /* The linker tries to support both AMD and old GNU style
             R_IREL relocs.  That means that if the addend is exactly
             the negative of the address within the section, the
             linker will not handle it correctly.  */
        }
      else if (fixP->fx_pcrel)
        {
          long v = val >> 28;
          if (v != 0 && v != -1)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("call/jmp target out of range (2)"));
        }
      else
        /* This case was supposed to be handled in machine_ip.  */
        abort ();

      buf[0] |= (val >> 26) & 0x03; /* Holds bits 0FFFFFFC of address.  */
      buf[1] = val >> 18;
      buf[2] = val >> 10;
      buf[3] = val >> 2;
      break;

    case RELOC_CONST:     /* 0000XXXX pattern in a word.  */
#if DEBUG
      printf ("reloc_const: val=%x\n", val);
#endif
      buf[2] = val >> 8;  /* Holds bits 0000XXXX.  */
      buf[3] = val;
      break;

    case RELOC_CONSTH:    /* 0000XXXX pattern in a word.  */
#if DEBUG
      printf ("reloc_consth: val=%x\n", val);
#endif
      buf[2] = val >> 24; /* Holds bits XXXX0000.  */
      buf[3] = val >> 16;
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      break;

    case NO_RELOC:
    default:
      as_bad (_("bad relocation type: 0x%02x"), fixP->fx_r_type);
      break;
    }

  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;
}
#endif

#ifdef OBJ_COFF
short
tc_coff_fix2rtype (fixS *fixP)
{
#if DEBUG
  printf ("tc_coff_fix2rtype\n");
#endif

  switch (fixP->fx_r_type)
    {
    case RELOC_32:        return R_WORD;
    case RELOC_8:         return R_BYTE;
    case RELOC_CONST:     return R_ILOHALF;
    case RELOC_CONSTH:    return R_IHIHALF;
    case RELOC_JUMPTARG:  return R_IREL;
    default:
      printf ("need %d\n", fixP->fx_r_type);
      abort ();
    }

  return 0;
}

#endif /* OBJ_COFF */
a714 10
#ifndef BFD_ASSEMBLER
void
md_convert_frag (object_headers * headers ATTRIBUTE_UNUSED,
		 segT             seg     ATTRIBUTE_UNUSED,
		 register fragS * fragP   ATTRIBUTE_UNUSED)
{
  as_fatal ("or32_convert_frag\n");
}

#else
a721 1
#endif
a852 28
#ifndef BFD_ASSEMBLER
  long regnum;
  char testbuf[5 + /*SLOP*/ 5];

#if DEBUG
  printf ("md_undefined_symbol(%s)\n", name);
#endif

  /* Register name.  */
  if (name[0] == 'r' || name[0] == 'R' || name[0] == 'a' || name[0] == 'b')
    {
      /* Parse the number, make sure it has no extra zeroes or
         trailing chars.  */
      regnum = atol (& name[1]);

      if (regnum > 31)
        as_fatal (_("register out of range"));

      sprintf (testbuf, "%ld", regnum);

      if (strcmp (testbuf, &name[1]) != 0)
        return NULL;  /* gr007 or lr7foo or whatever.  */

      /* We have a wiener!  Define and return a new symbol for it.  */
      return (symbol_new (name, SEG_REGISTER, (valueT) regnum,
                          &zero_address_frag));
    }
#endif
a1003 1
#ifdef BFD_ASSEMBLER
a1029 1
#endif
@


1.9
log
@Update the address and phone number of the FSF
@
text
@d905 1
a905 1
md_apply_fix3 (fixS * fixP, valueT * val, segT seg ATTRIBUTE_UNUSED)
d1001 1
a1001 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.8
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d21 2
a22 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.7
log
@update copyright dates
@
text
@d50 9
a58 9
  {
    char *          error;
    unsigned long   opcode;
    struct nlist *  nlistp;
    expressionS     exp;
    int             pcrel;
    int             reloc_offset;   /* Offset of reloc within insn.  */
    int             reloc;
  }
a60 2
static void machine_ip PARAMS ((char *));

d62 11
a72 11
  {
    {"align",   s_align_bytes,  4 },
    {"space",   s_space,        0 },
    {"cputype", s_ignore,       0 },
    {"reg",     s_lsym,         0 },  /* Register equate, same as equ.  */
    {"sect",    s_ignore,       0 },  /* Creation of coff sections.  */
    {"proc",    s_ignore,       0 },  /* Start of a function.  */
    {"endproc", s_ignore,       0 },  /* Function end.  */
    {"word",    cons,           4 },
    {NULL,      0,              0 },
  };
d115 1
a116 3
static int check_invalid_opcode PARAMS ((unsigned long));
static void encode PARAMS ((const struct machine_opcode *, unsigned long *, signed long, char));
static char *parse_operand PARAMS ((char *, expressionS *, int));
d122 4
a125 5
encode (insn, opcode, param_val, param_ch)
     const struct machine_opcode *insn;
     unsigned long *opcode;
     signed long param_val;
     char param_ch;
d193 1
a193 1
md_begin ()
d213 1
a213 1
      retval = hash_insert (op_hash, name, (PTR) &machine_opcodes[i]);
d231 1
a231 2
check_invalid_opcode (opcode)
     unsigned long opcode;
d241 1
a241 2
md_assemble (str)
     char *str;
d279 1
a279 4
parse_operand (s, operandp, opt)
     char *s;
     expressionS *operandp;
     int opt;
d344 1
a344 4
parse_operand (s, operandp, opt)
     char *s;
     expressionS *operandp;
     int opt;
a370 1

d419 1
a419 2
machine_ip (str)
     char *str;
d473 2
a474 4
    {
      /* Prime the pump.  */
      s = parse_operand (s, operand, insn->args[0] == 'I');
    }
d565 1
a565 3
            {
              operand->X_op = O_constant;
            }
d625 1
a625 2
machine_ip (str)
     char *str;
d773 1
a773 3
            {
              operand->X_op = O_constant;
            }
d842 1
a842 4
md_atof (type, litP, sizeP)
     char   type;
     char * litP;
     int *  sizeP;
d898 1
a898 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d905 1
a905 4
md_apply_fix3 (fixP, val, seg)
     fixS *   fixP;
     valueT * val;
     segT     seg ATTRIBUTE_UNUSED;
d1001 1
a1001 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d1124 1
a1124 2
tc_coff_fix2rtype (fixP)
     fixS *fixP;
d1132 5
a1136 10
    case RELOC_32:
      return (R_WORD);
    case RELOC_8:
      return (R_BYTE);
    case RELOC_CONST:
      return (R_ILOHALF);
    case RELOC_CONSTH:
      return (R_IHIHALF);
    case RELOC_JUMPTARG:
      return (R_IREL);
d1150 5
a1154 6
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *    ptr       ATTRIBUTE_UNUSED;
     addressT  from_addr ATTRIBUTE_UNUSED;
     addressT  to_addr   ATTRIBUTE_UNUSED;
     fragS *   frag      ATTRIBUTE_UNUSED;
     symbolS * to_symbol ATTRIBUTE_UNUSED;
d1163 3
a1165 4
md_convert_frag (headers, seg, fragP)
     object_headers * headers ATTRIBUTE_UNUSED;
     segT             seg     ATTRIBUTE_UNUSED;
     register fragS * fragP   ATTRIBUTE_UNUSED;
d1172 3
a1174 4
md_convert_frag (headers, seg, fragP)
     bfd *   headers ATTRIBUTE_UNUSED;
     segT    seg     ATTRIBUTE_UNUSED;
     fragS * fragP   ATTRIBUTE_UNUSED;
d1183 5
a1187 6
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *    ptr       ATTRIBUTE_UNUSED;
     addressT  from_addr ATTRIBUTE_UNUSED;
     addressT  to_addr   ATTRIBUTE_UNUSED;
     fragS *   frag      ATTRIBUTE_UNUSED;
     symbolS * to_symbol ATTRIBUTE_UNUSED;
d1195 2
a1196 3
md_estimate_size_before_relax (fragP, segtype)
     fragS * fragP   ATTRIBUTE_UNUSED;
     segT    segtype ATTRIBUTE_UNUSED;
d1212 3
a1214 4
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
d1248 3
a1250 3
  {
    { NULL, no_argument, NULL, 0 }
  };
d1254 1
a1254 3
md_parse_option (c, arg)
     int    c   ATTRIBUTE_UNUSED;
     char * arg ATTRIBUTE_UNUSED;
d1260 1
a1260 2
md_show_usage (stream)
     FILE * stream ATTRIBUTE_UNUSED;
d1268 1
a1268 2
or32_unrecognized_line (c)
     int c;
a1302 25
#ifndef BFD_ASSEMBLER
/* Record a fixup for a cons expression.  */
/*
  void
or32_cons_fix_new (frag, where, nbytes, exp)
     fragS *frag;
     int where;
     int nbytes;
     expressionS *exp;
{
  fix_new_exp (frag, where, nbytes, exp, 0,
		   nbytes == 5 ? RELOC_32
                   : nbytes == 2 ? RELOC_16
		   : RELOC_8);
}
void
tc_aout_pre_write_hook ()
{
#if DEBUG
  printf ("In tc_aout_pre_write_hook()\n");
#endif
}
*/
#endif

d1308 1
a1308 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1344 1
a1344 2
md_operand (expressionP)
     expressionS *expressionP;
d1472 1
a1472 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size ATTRIBUTE_UNUSED;
d1482 1
a1482 2
md_pcrel_from (fixP)
     fixS *fixP;
d1491 1
a1491 3
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d1495 2
a1496 2
  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
a1516 1

@


1.6
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright (C) 2002 Free Software Foundation, Inc.
@


1.5
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@a583 4
#if 0
              operand->X_add_number = 0; /* ??? if enabled load/store offsets
					    are zero.  */
#endif
a794 4
#if 0
              operand->X_add_number = 0; /* ??? if enabled load/store offsets
					    are zero.  */
#endif
d997 1
a997 14
        {
          /* The linker tries to support both AMD and old GNU style
             R_IREL relocs.  That means that if the addend is exactly
             the negative of the address within the section, the
             linker will not handle it correctly.  */
#if 0
          if (fixP->fx_pcrel
              && t_val != 0
              && t_val == - (fixP->fx_frag->fr_address + fixP->fx_where))
            as_bad_where
              (fixP->fx_file, fixP->fx_line,
               _("the linker will not handle this relocation correctly (1)"));
#endif
        }
a1105 8
#if 0
          if (fixP->fx_pcrel
              && val != 0
              && val == - (fixP->fx_frag->fr_address + fixP->fx_where))
            as_bad_where
              (fixP->fx_file, fixP->fx_line,
               _("the linker will not handle this relocation correctly (1)"));
#endif
a1109 1
#if 1
a1112 1
#endif
@


1.4
log
@	* config/tc-openrisc.c (ignore_pseudo): Prototype.
	(md_atof): Remove declaration of atof_ieee.
	* config/tc-or32.c (parse_operand): Prototype non-BFD too.
	(md_apply_fix3): Fix bogus >>='s.
	(md_undefined_symbol): Delete unused var.
@
text
@d233 1
a233 1
/* Returs non zero if instruction is to be used.  */
@


1.3
log
@gas reloc rewrite.
@
text
@d120 1
a120 3
#ifdef BFD_ASSEMBLER
static char * parse_operand PARAMS ((char *, expressionS *, int));
#endif
d353 1
a353 1
char *
d1088 1
a1088 1
      val = (val >>= 2) + 1;
d1112 1
a1112 1
      val = (val >>= 2) + 1;
a1427 2
      long maxreg;

@


1.2
log
@	* config/obj-coff.h: Fix formatting.
	* config/tc-mcore.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-openrisc.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-xstormy16.h: Likewise.
@
text
@d1060 1
a1060 1
  long val = *(long*)valP;
d1627 3
a1629 4
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT)
    reloc->addend = fixp->fx_offset;
  else
a1630 1

@


1.1
log
@Add support for OpenRISC 32-bit embedded processor
@
text
@d31 1
a31 1
#include "elf/or32.h" 
d67 1
a67 1
    {"cputype", s_ignore,       0 }, 
d125 1
a125 1
   description and passed operand.  */ 
d127 1
a127 1
static void 
d155 1
a155 1
      if ((*enc == '0') && (*(enc + 1) == 'x')) 
d163 1
a163 1
      else if ((*enc == '0') || (*enc == '-')) 
d168 1
a168 1
      else if (*enc == '1') 
d174 1
a174 1
      else if (*enc == param_ch) 
d181 1
a181 1
      else if (ISALPHA (*enc)) 
d189 1
a189 1
      
d321 1
a321 1
  if ((*s == 'r') && ISDIGIT (*(s + 1))) 
d326 1
a326 1
        s++;  
d328 1
a328 1
      return s; 
d343 1
a343 1
    
d346 1
a346 1
 
d399 1
a399 1
    
d402 2
a403 2
  
  if ((operandp->X_op == O_symbol) && (*s != '_')) 
d413 1
a413 1
        if ((*s == 'r') && ISDIGIT (*(s + 1))) 
d486 1
a486 1
   
d512 1
a512 1
                as_bad (_("instruction not allowed: %s"), str); 
d528 1
a528 1
#endif    
d536 1
a536 1
    
d545 1
a545 1
 
d558 1
a558 1
               
d567 2
a568 2
          
          if (strncasecmp (args, "LO(", 3) == 0) 
d575 1
a575 1
          else if (strncasecmp (args, "HI(", 3) == 0) 
d582 2
a583 2
          
          if (*s == '(') 
d614 1
a614 1
              continue; 
d628 1
a628 1
  
d640 1
a640 1
  
d701 1
a701 1
   
d705 1
a705 1
    /* Prime the pump.  */      
d727 1
a727 1
                as_bad (_("instruction not allowed: %s"), str); 
d743 1
a743 1
#endif    
d751 1
a751 1
    
d760 1
a760 1
 
d773 1
a773 1
               
d782 2
a783 2
          
          if (strncasecmp (args, "LO(", 3) == 0) 
d790 1
a790 1
          else if (strncasecmp (args, "HI(", 3) == 0) 
d797 2
a798 2
          
          if (*s == '(') 
d830 1
a830 1
              continue; 
d842 1
a842 1
  
d854 1
a854 1
  
d1253 1
a1253 1
} 
d1299 1
a1299 1
#endif  
d1407 2
a1408 2
} 
*/                                                                                      
d1428 2
a1429 2
  if (name[0] == 'r' || name[0] == 'R' || name[0] == 'a' || name[0] == 'b') 
    { 
d1492 1
a1492 1
      
d1544 1
a1544 1
      else 
d1573 1
a1573 1
      expressionP->X_op = O_constant; 
@

