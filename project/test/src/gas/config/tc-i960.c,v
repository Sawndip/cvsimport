head	1.31;
access;
symbols
	binutils-2_24-branch:1.31.0.10
	binutils-2_24-branchpoint:1.31
	binutils-2_21_1:1.31
	binutils-2_23_2:1.31
	binutils-2_23_1:1.31
	binutils-2_23:1.31
	binutils-2_23-branch:1.31.0.8
	binutils-2_23-branchpoint:1.31
	binutils-2_22_branch:1.31.0.6
	binutils-2_22:1.31
	binutils-2_22-branch:1.31.0.4
	binutils-2_22-branchpoint:1.31
	binutils-2_21:1.31
	binutils-2_21-branch:1.31.0.2
	binutils-2_21-branchpoint:1.31
	binutils-2_20_1:1.30
	binutils-2_20:1.30
	binutils-arc-20081103-branch:1.28.0.6
	binutils-arc-20081103-branchpoint:1.28
	binutils-2_20-branch:1.30.0.2
	binutils-2_20-branchpoint:1.30
	dje-cgen-play1-branch:1.29.0.2
	dje-cgen-play1-branchpoint:1.29
	arc-20081103-branch:1.28.0.4
	arc-20081103-branchpoint:1.28
	binutils-2_19_1:1.28
	binutils-2_19:1.28
	binutils-2_19-branch:1.28.0.2
	binutils-2_19-branchpoint:1.28
	binutils-2_18:1.27
	binutils-2_18-branch:1.27.0.2
	binutils-2_18-branchpoint:1.27
	binutils-csl-coldfire-4_1-32:1.25
	binutils-csl-sourcerygxx-4_1-32:1.25
	binutils-csl-innovasic-fido-3_4_4-33:1.25
	binutils-csl-sourcerygxx-3_4_4-32:1.21
	binutils-csl-coldfire-4_1-30:1.25
	binutils-csl-sourcerygxx-4_1-30:1.25
	binutils-csl-coldfire-4_1-28:1.25
	binutils-csl-sourcerygxx-4_1-29:1.25
	binutils-csl-sourcerygxx-4_1-28:1.25
	binutils-csl-arm-2006q3-27:1.25
	binutils-csl-sourcerygxx-4_1-27:1.25
	binutils-csl-arm-2006q3-26:1.25
	binutils-csl-sourcerygxx-4_1-26:1.25
	binutils-csl-sourcerygxx-4_1-25:1.25
	binutils-csl-sourcerygxx-4_1-24:1.25
	binutils-csl-sourcerygxx-4_1-23:1.25
	binutils-csl-sourcerygxx-4_1-21:1.25
	binutils-csl-arm-2006q3-21:1.25
	binutils-csl-sourcerygxx-4_1-22:1.25
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.25
	binutils-csl-sourcerygxx-4_1-20:1.25
	binutils-csl-arm-2006q3-19:1.25
	binutils-csl-sourcerygxx-4_1-19:1.25
	binutils-csl-sourcerygxx-4_1-18:1.25
	binutils-csl-renesas-4_1-9:1.25
	binutils-csl-sourcerygxx-3_4_4-25:1.21
	binutils-csl-renesas-4_1-8:1.25
	binutils-csl-renesas-4_1-7:1.25
	binutils-csl-renesas-4_1-6:1.25
	binutils-csl-sourcerygxx-4_1-17:1.25
	binutils-csl-sourcerygxx-4_1-14:1.25
	binutils-csl-sourcerygxx-4_1-15:1.25
	binutils-csl-sourcerygxx-4_1-13:1.25
	binutils-2_17:1.25
	binutils-csl-sourcerygxx-4_1-12:1.25
	binutils-csl-sourcerygxx-3_4_4-21:1.25
	binutils-csl-wrs-linux-3_4_4-24:1.21
	binutils-csl-wrs-linux-3_4_4-23:1.21
	binutils-csl-sourcerygxx-4_1-9:1.25
	binutils-csl-sourcerygxx-4_1-8:1.25
	binutils-csl-sourcerygxx-4_1-7:1.25
	binutils-csl-arm-2006q1-6:1.25
	binutils-csl-sourcerygxx-4_1-6:1.25
	binutils-csl-wrs-linux-3_4_4-22:1.21
	binutils-csl-coldfire-4_1-11:1.25
	binutils-csl-sourcerygxx-3_4_4-19:1.25
	binutils-csl-coldfire-4_1-10:1.25
	binutils-csl-sourcerygxx-4_1-5:1.25
	binutils-csl-sourcerygxx-4_1-4:1.25
	binutils-csl-wrs-linux-3_4_4-21:1.21
	binutils-csl-morpho-4_1-4:1.25
	binutils-csl-sourcerygxx-3_4_4-17:1.25
	binutils-csl-wrs-linux-3_4_4-20:1.21
	binutils-2_17-branch:1.25.0.4
	binutils-2_17-branchpoint:1.25
	binutils-csl-2_17-branch:1.25.0.2
	binutils-csl-2_17-branchpoint:1.25
	binutils-csl-gxxpro-3_4-branch:1.21.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.21
	binutils-2_16_1:1.21
	binutils-csl-arm-2005q1b:1.21
	binutils-2_16:1.21
	binutils-csl-arm-2005q1a:1.21
	binutils-csl-arm-2005q1-branch:1.21.0.4
	binutils-csl-arm-2005q1-branchpoint:1.21
	binutils-2_16-branch:1.21.0.2
	binutils-2_16-branchpoint:1.21
	csl-arm-2004-q3d:1.18
	csl-arm-2004-q3:1.18
	binutils-2_15:1.18
	binutils-2_15-branchpoint:1.18
	csl-arm-2004-q1a:1.18
	csl-arm-2004-q1:1.18
	binutils-2_15-branch:1.18.0.6
	cagney_bfdfile-20040213-branch:1.18.0.4
	cagney_bfdfile-20040213-branchpoint:1.18
	cagney_bigcore-20040122-branch:1.18.0.2
	cagney_bigcore-20040122-branchpoint:1.18
	csl-arm-2003-q4:1.18
	binutils-2_14:1.16
	binutils-2_14-branch:1.16.0.2
	binutils-2_14-branchpoint:1.16
	binutils-2_13_2_1:1.13
	binutils-2_13_2:1.13
	binutils-2_13_1:1.13
	binutils-2_13:1.13
	binutils-2_13-branchpoint:1.13
	binutils-2_13-branch:1.13.0.2
	binutils-2_12_1:1.11.2.1
	binutils-2_12:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	cygnus_cvs_20020108_pre:1.11
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	binutils-2_10_1:1.4
	binutils-2_10:1.4
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.31
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.4
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.11.01.25.26;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.05.09.12.57;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.24.20.40.26;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.01.00.43.58;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.31.23.18.29;	author bje;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.21.14.38.06;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.11.06.11.44;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.16.09.57.49;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.12.22.25.00;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.09.01.43.11;	author wilson;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.15.21.28.56;	author nickc;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.09.19.05.33.24;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.11.19.49.46;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.09.00.00.03;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	99.06.11.19.03.06;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.29;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.27.21.57.47;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.11.2.1
date	2002.05.09.11.54.11;	author amodra;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.15.29;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.31
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@/* tc-i960.c - All the i80960-specific stuff
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2009, 2010
   Free Software Foundation, Inc.

   This file is part of GAS.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* See comment on md_parse_option for 80960-specific invocation options.  */

/* There are 4 different lengths of (potentially) symbol-based displacements
   in the 80960 instruction set, each of which could require address fix-ups
   and (in the case of external symbols) emission of relocation directives:

   32-bit (MEMB)
        This is a standard length for the base assembler and requires no
        special action.

   13-bit (COBR)
        This is a non-standard length, but the base assembler has a
        hook for bit field address fixups: the fixS structure can
        point to a descriptor of the field, in which case our
        md_number_to_field() routine gets called to process it.

        I made the hook a little cleaner by having fix_new() (in the base
        assembler) return a pointer to the fixS in question.  And I made it a
        little simpler by storing the field size (in this case 13) instead of
        of a pointer to another structure:  80960 displacements are ALWAYS
        stored in the low-order bits of a 4-byte word.

        Since the target of a COBR cannot be external, no relocation
        directives for this size displacement have to be generated.
        But the base assembler had to be modified to issue error
        messages if the symbol did turn out to be external.

   24-bit (CTRL)
        Fixups are handled as for the 13-bit case (except that 24 is stored
        in the fixS).

        The relocation directive generated is the same as that for the 32-bit
        displacement, except that it's PC-relative (the 32-bit displacement
        never is).   The i80960 version of the linker needs a mod to
        distinguish and handle the 24-bit case.

   12-bit (MEMA)
        MEMA formats are always promoted to MEMB (32-bit) if the displacement
        is based on a symbol, because it could be relocated at link time.
        The only time we use the 12-bit format is if an absolute value of
        less than 4096 is specified, in which case we need neither a fixup nor
        a relocation directive.  */

#include "as.h"

#include "safe-ctype.h"
#include "obstack.h"

#include "opcode/i960.h"

#if defined (OBJ_AOUT) || defined (OBJ_BOUT)

#define TC_S_IS_SYSPROC(s)	((1 <= S_GET_OTHER (s)) && (S_GET_OTHER (s) <= 32))
#define TC_S_IS_BALNAME(s)	(S_GET_OTHER (s) == N_BALNAME)
#define TC_S_IS_CALLNAME(s)	(S_GET_OTHER (s) == N_CALLNAME)
#define TC_S_IS_BADPROC(s)	((S_GET_OTHER (s) != 0) && !TC_S_IS_CALLNAME (s) && !TC_S_IS_BALNAME (s) && !TC_S_IS_SYSPROC (s))

#define TC_S_SET_SYSPROC(s, p)	(S_SET_OTHER ((s), (p) + 1))
#define TC_S_GET_SYSPROC(s)	(S_GET_OTHER (s) - 1)

#define TC_S_FORCE_TO_BALNAME(s)	(S_SET_OTHER ((s), N_BALNAME))
#define TC_S_FORCE_TO_CALLNAME(s)	(S_SET_OTHER ((s), N_CALLNAME))
#define TC_S_FORCE_TO_SYSPROC(s)	{;}

#else /* ! OBJ_A/BOUT */
#ifdef OBJ_COFF

#define TC_S_IS_SYSPROC(s)	(S_GET_STORAGE_CLASS (s) == C_SCALL)
#define TC_S_IS_BALNAME(s)	(SF_GET_BALNAME (s))
#define TC_S_IS_CALLNAME(s)	(SF_GET_CALLNAME (s))
#define TC_S_IS_BADPROC(s)	(TC_S_IS_SYSPROC (s) && TC_S_GET_SYSPROC (s) < 0 && 31 < TC_S_GET_SYSPROC (s))

#define TC_S_SET_SYSPROC(s, p)	((s)->sy_symbol.ost_auxent[1].x_sc.x_stindx = (p))
#define TC_S_GET_SYSPROC(s)	((s)->sy_symbol.ost_auxent[1].x_sc.x_stindx)

#define TC_S_FORCE_TO_BALNAME(s)	(SF_SET_BALNAME (s))
#define TC_S_FORCE_TO_CALLNAME(s)	(SF_SET_CALLNAME (s))
#define TC_S_FORCE_TO_SYSPROC(s)	(S_SET_STORAGE_CLASS ((s), C_SCALL))

#else /* ! OBJ_COFF */
#ifdef OBJ_ELF
#define TC_S_IS_SYSPROC(s)	0

#define TC_S_IS_BALNAME(s)	0
#define TC_S_IS_CALLNAME(s)	0
#define TC_S_IS_BADPROC(s)	0

#define TC_S_SET_SYSPROC(s, p)
#define TC_S_GET_SYSPROC(s)     0

#define TC_S_FORCE_TO_BALNAME(s)
#define TC_S_FORCE_TO_CALLNAME(s)
#define TC_S_FORCE_TO_SYSPROC(s)
#else
 #error COFF, a.out, b.out, and ELF are the only supported formats.
#endif /* ! OBJ_ELF */
#endif /* ! OBJ_COFF */
#endif /* ! OBJ_A/BOUT */

extern char *input_line_pointer;

/* Local i80960 routines.  */
struct memS;
struct regop;

/* See md_parse_option() for meanings of these options.  */
static char norelax;			/* True if -norelax switch seen.  */
static char instrument_branches;	/* True if -b switch seen.  */

/* Characters that always start a comment.
   If the pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "#";

/* Characters that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.

   Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */

/* Also note that comments started like this one will always work.  */

const char line_comment_chars[]   = "#";
const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant,
   as in 0f12.456 or 0d1.2345e12.  */
const char FLT_CHARS[] = "fFdDtT";

/* Table used by base assembler to relax addresses based on varying length
   instructions.  The fields are:
     1) most positive reach of this state,
     2) most negative reach of this state,
     3) how many bytes this mode will add to the size of the current frag
     4) which index into the table to try if we can't fit into this one.

   For i80960, the only application is the (de-)optimization of cobr
   instructions into separate compare and branch instructions when a 13-bit
   displacement won't hack it.  */
const relax_typeS md_relax_table[] =
{
  {0, 0, 0, 0},				/* State 0 => no more relaxation possible.  */
  {4088, -4096, 0, 2},			/* State 1: conditional branch (cobr).  */
  {0x800000 - 8, -0x800000, 4, 0},	/* State 2: compare (reg) & branch (ctrl).  */
};

/* These are the machine dependent pseudo-ops.

   This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
        pseudo-op name without dot
        function to call to execute this pseudo-op
        integer arg to pass to the function.  */
#define S_LEAFPROC	1
#define S_SYSPROC	2

/* Macros to extract info from an 'expressionS' structure 'e'.  */
#define adds(e)	e.X_add_symbol
#define offs(e)	e.X_add_number

/* Branch-prediction bits for CTRL/COBR format opcodes.  */
#define BP_MASK		0x00000002	/* Mask for branch-prediction bit.  */
#define BP_TAKEN	0x00000000	/* Value to OR in to predict branch.  */
#define BP_NOT_TAKEN	0x00000002	/* Value to OR in to predict no branch.  */

/* Some instruction opcodes that we need explicitly.  */
#define BE	0x12000000
#define BG	0x11000000
#define BGE	0x13000000
#define BL	0x14000000
#define BLE	0x16000000
#define BNE	0x15000000
#define BNO	0x10000000
#define BO	0x17000000
#define CHKBIT	0x5a002700
#define CMPI	0x5a002080
#define CMPO	0x5a002000

#define B	0x08000000
#define BAL	0x0b000000
#define CALL	0x09000000
#define CALLS	0x66003800
#define RET	0x0a000000

/* These masks are used to build up a set of MEMB mode bits.  */
#define	A_BIT		0x0400
#define	I_BIT		0x0800
#define MEMB_BIT	0x1000
#define	D_BIT		0x2000

/* Mask for the only mode bit in a MEMA instruction (if set, abase reg is
   used).  */
#define MEMA_ABASE	0x2000

/* Info from which a MEMA or MEMB format instruction can be generated.  */
typedef struct memS
  {
    /* (First) 32 bits of instruction.  */
    long opcode;
    /* 0-(none), 12- or, 32-bit displacement needed.  */
    int disp;
    /* The expression in the source instruction from which the
       displacement should be determined.  */
    char *e;
  }
memS;

/* The two pieces of info we need to generate a register operand.  */
struct regop
  {
    int mode;			/* 0 =>local/global/spec reg; 1=> literal or fp reg.  */
    int special;		/* 0 =>not a sfr;  1=> is a sfr (not valid w/mode=0).  */
    int n;			/* Register number or literal value.  */
  };

/* Number and assembler mnemonic for all registers that can appear in
   operands.  */
static const struct
  {
    char *reg_name;
    int reg_num;
  }
regnames[] =
{
  { "pfp", 0 },
  { "sp", 1 },
  { "rip", 2 },
  { "r3", 3 },
  { "r4", 4 },
  { "r5", 5 },
  { "r6", 6 },
  { "r7", 7 },
  { "r8", 8 },
  { "r9", 9 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "g0", 16 },
  { "g1", 17 },
  { "g2", 18 },
  { "g3", 19 },
  { "g4", 20 },
  { "g5", 21 },
  { "g6", 22 },
  { "g7", 23 },
  { "g8", 24 },
  { "g9", 25 },
  { "g10", 26 },
  { "g11", 27 },
  { "g12", 28 },
  { "g13", 29 },
  { "g14", 30 },
  { "fp", 31 },

  /* Numbers for special-function registers are for assembler internal
     use only: they are scaled back to range [0-31] for binary output.  */
#define SF0	32

  { "sf0", 32 },
  { "sf1", 33 },
  { "sf2", 34 },
  { "sf3", 35 },
  { "sf4", 36 },
  { "sf5", 37 },
  { "sf6", 38 },
  { "sf7", 39 },
  { "sf8", 40 },
  { "sf9", 41 },
  { "sf10", 42 },
  { "sf11", 43 },
  { "sf12", 44 },
  { "sf13", 45 },
  { "sf14", 46 },
  { "sf15", 47 },
  { "sf16", 48 },
  { "sf17", 49 },
  { "sf18", 50 },
  { "sf19", 51 },
  { "sf20", 52 },
  { "sf21", 53 },
  { "sf22", 54 },
  { "sf23", 55 },
  { "sf24", 56 },
  { "sf25", 57 },
  { "sf26", 58 },
  { "sf27", 59 },
  { "sf28", 60 },
  { "sf29", 61 },
  { "sf30", 62 },
  { "sf31", 63 },

  /* Numbers for floating point registers are for assembler internal
     use only: they are scaled back to [0-3] for binary output.  */
#define FP0	64

  { "fp0", 64 },
  { "fp1", 65 },
  { "fp2", 66 },
  { "fp3", 67 },

  { NULL, 0 },				/* END OF LIST */
};

#define	IS_RG_REG(n)	((0 <= (n)) && ((n) < SF0))
#define	IS_SF_REG(n)	((SF0 <= (n)) && ((n) < FP0))
#define	IS_FP_REG(n)	((n) >= FP0)

/* Number and assembler mnemonic for all registers that can appear as
   'abase' (indirect addressing) registers.  */
static const struct
{
  char *areg_name;
  int areg_num;
}
aregs[] =
{
  { "(pfp)", 0 },
  { "(sp)", 1 },
  { "(rip)", 2 },
  { "(r3)", 3 },
  { "(r4)", 4 },
  { "(r5)", 5 },
  { "(r6)", 6 },
  { "(r7)", 7 },
  { "(r8)", 8 },
  { "(r9)", 9 },
  { "(r10)", 10 },
  { "(r11)", 11 },
  { "(r12)", 12 },
  { "(r13)", 13 },
  { "(r14)", 14 },
  { "(r15)", 15 },
  { "(g0)", 16 },
  { "(g1)", 17 },
  { "(g2)", 18 },
  { "(g3)", 19 },
  { "(g4)", 20 },
  { "(g5)", 21 },
  { "(g6)", 22 },
  { "(g7)", 23 },
  { "(g8)", 24 },
  { "(g9)", 25 },
  { "(g10)", 26 },
  { "(g11)", 27 },
  { "(g12)", 28 },
  { "(g13)", 29 },
  { "(g14)", 30 },
  { "(fp)", 31 },

#define IPREL	32
  /* For assembler internal use only: this number never appears in binary
     output.  */
  { "(ip)", IPREL },

  { NULL, 0 },				/* END OF LIST */
};

/* Hash tables.  */
static struct hash_control *op_hash;	/* Opcode mnemonics.  */
static struct hash_control *reg_hash;	/* Register name hash table.  */
static struct hash_control *areg_hash;	/* Abase register hash table.  */

/* Architecture for which we are assembling.  */
#define ARCH_ANY	0	/* Default: no architecture checking done.  */
#define ARCH_KA		1
#define ARCH_KB		2
#define ARCH_MC		3
#define ARCH_CA		4
#define ARCH_JX		5
#define ARCH_HX		6
int architecture = ARCH_ANY;	/* Architecture requested on invocation line.  */
int iclasses_seen;		/* OR of instruction classes (I_* constants)
				      for which we've actually assembled
				        instructions.  */

/* BRANCH-PREDICTION INSTRUMENTATION

        The following supports generation of branch-prediction instrumentation
        (turned on by -b switch).  The instrumentation collects counts
        of branches taken/not-taken for later input to a utility that will
        set the branch prediction bits of the instructions in accordance with
        the behavior observed.  (Note that the KX series does not have
        brach-prediction.)

        The instrumentation consists of:

        (1) before and after each conditional branch, a call to an external
            routine that increments and steps over an inline counter.  The
            counter itself, initialized to 0, immediately follows the call
            instruction.  For each branch, the counter following the branch
            is the number of times the branch was not taken, and the difference
            between the counters is the number of times it was taken.  An
            example of an instrumented conditional branch:

                                call    BR_CNT_FUNC
                                .word   0
                LBRANCH23:      be      label
                                call    BR_CNT_FUNC
                                .word   0

        (2) a table of pointers to the instrumented branches, so that an
            external postprocessing routine can locate all of the counters.
            the table begins with a 2-word header: a pointer to the next in
            a linked list of such tables (initialized to 0);  and a count
            of the number of entries in the table (exclusive of the header.

            Note that input source code is expected to already contain calls
            an external routine that will link the branch local table into a
            list of such tables.  */

/* Number of branches instrumented so far.  Also used to generate
   unique local labels for each instrumented branch.  */
static int br_cnt;

#define BR_LABEL_BASE	"LBRANCH"
/* Basename of local labels on instrumented branches, to avoid
   conflict with compiler- generated local labels.  */

#define BR_CNT_FUNC	"__inc_branch"
/* Name of the external routine that will increment (and step over) an
   inline counter.  */

#define BR_TAB_NAME	"__BRANCH_TABLE__"
/* Name of the table of pointers to branches.  A local (i.e.,
   non-external) symbol.  */

static void ctrl_fmt (char *, long, int);


void
md_begin (void)
{
  int i;			/* Loop counter.  */
  const struct i960_opcode *oP;	/* Pointer into opcode table.  */
  const char *retval;		/* Value returned by hash functions.  */

  op_hash = hash_new ();
  reg_hash = hash_new ();
  areg_hash = hash_new ();

  /* For some reason, the base assembler uses an empty string for "no
     error message", instead of a NULL pointer.  */
  retval = 0;

  for (oP = i960_opcodes; oP->name && !retval; oP++)
    retval = hash_insert (op_hash, oP->name, (void *) oP);

  for (i = 0; regnames[i].reg_name && !retval; i++)
    retval = hash_insert (reg_hash, regnames[i].reg_name,
			  (char *) &regnames[i].reg_num);

  for (i = 0; aregs[i].areg_name && !retval; i++)
    retval = hash_insert (areg_hash, aregs[i].areg_name,
			  (char *) &aregs[i].areg_num);

  if (retval)
    as_fatal (_("Hashing returned \"%s\"."), retval);
}

/* parse_expr:		parse an expression

   Use base assembler's expression parser to parse an expression.
   It, unfortunately, runs off a global which we have to save/restore
   in order to make it work for us.

   An empty expression string is treated as an absolute 0.

   Sets O_illegal regardless of expression evaluation if entire input
   string is not consumed in the evaluation -- tolerate no dangling junk!  */

static void
parse_expr (char *textP,		/* Text of expression to be parsed.  */
	    expressionS *expP)		/* Where to put the results of parsing.  */
{
  char *save_in;		/* Save global here.  */
  symbolS *symP;

  know (textP);

  if (*textP == '\0')
    {
      /* Treat empty string as absolute 0.  */
      expP->X_add_symbol = expP->X_op_symbol = NULL;
      expP->X_add_number = 0;
      expP->X_op = O_constant;
    }
  else
    {
      save_in = input_line_pointer;	/* Save global.  */
      input_line_pointer = textP;	/* Make parser work for us.  */

      (void) expression (expP);
      if ((size_t) (input_line_pointer - textP) != strlen (textP))
	/* Did not consume all of the input.  */
	expP->X_op = O_illegal;

      symP = expP->X_add_symbol;
      if (symP && (hash_find (reg_hash, S_GET_NAME (symP))))
	/* Register name in an expression.  */
	/* FIXME: this isn't much of a check any more.  */
	expP->X_op = O_illegal;

      input_line_pointer = save_in;	/* Restore global.  */
    }
}

/* emit:	output instruction binary

   Output instruction binary, in target byte order, 4 bytes at a time.
   Return pointer to where it was placed.  */

static char *
emit (long instr)		/* Word to be output, host byte order.  */
{
  char *toP;			/* Where to output it.  */

  toP = frag_more (4);		/* Allocate storage.  */
  md_number_to_chars (toP, instr, 4);	/* Convert to target byte order.  */
  return toP;
}

/* get_cdisp:	handle displacement for a COBR or CTRL instruction.

   Parse displacement for a COBR or CTRL instruction.

   If successful, output the instruction opcode and set up for it,
   depending on the arg 'var_frag', either:
  	    o an address fixup to be done when all symbol values are known, or
  	    o a varying length code fragment, with address fixup info.  This
  		will be done for cobr instructions that may have to be relaxed
  		in to compare/branch instructions (8 bytes) if the final
  		address displacement is greater than 13 bits.  */

static void
get_cdisp (char *dispP, /* Displacement as specified in source instruction.  */
	   char *ifmtP, /* "COBR" or "CTRL" (for use in error message).  */
	   long instr,  /* Instruction needing the displacement.  */
	   int numbits, /* # bits of displacement (13 for COBR, 24 for CTRL).  */
	   int var_frag,/* 1 if varying length code fragment should be emitted;
			   0 if an address fix should be emitted.  */
	   int callj)	/* 1 if callj relocation should be done; else 0.  */	   
{
  expressionS e;		/* Parsed expression.  */
  fixS *fixP;			/* Structure describing needed address fix.  */
  char *outP;			/* Where instruction binary is output to.  */

  fixP = NULL;

  parse_expr (dispP, &e);
  switch (e.X_op)
    {
    case O_illegal:
      as_bad (_("expression syntax error"));

    case O_symbol:
      if (S_GET_SEGMENT (e.X_add_symbol) == now_seg
	  || S_GET_SEGMENT (e.X_add_symbol) == undefined_section)
	{
	  if (var_frag)
	    {
	      outP = frag_more (8);	/* Allocate worst-case storage.  */
	      md_number_to_chars (outP, instr, 4);
	      frag_variant (rs_machine_dependent, 4, 4, 1,
			    adds (e), offs (e), outP);
	    }
	  else
	    {
	      /* Set up a new fix structure, so address can be updated
	         when all symbol values are known.  */
	      outP = emit (instr);
	      fixP = fix_new (frag_now,
			      outP - frag_now->fr_literal,
			      4,
			      adds (e),
			      offs (e),
			      1,
			      NO_RELOC);

	      fixP->fx_tcbit = callj;

	      /* We want to modify a bit field when the address is
	         known.  But we don't need all the garbage in the
	         bit_fix structure.  So we're going to lie and store
	         the number of bits affected instead of a pointer.  */
	      fixP->fx_bit_fixP = (bit_fixS *) (size_t) numbits;
	    }
	}
      else
	as_bad (_("attempt to branch into different segment"));
      break;

    default:
      as_bad (_("target of %s instruction must be a label"), ifmtP);
      break;
    }
}

static int
md_chars_to_number (char * val,		/* Value in target byte order.  */
		    int n)		/* Number of bytes in the input.  */
{
  int retval;

  for (retval = 0; n--;)
    {
      retval <<= 8;
      retval |= (unsigned char) val[n];
    }
  return retval;
}

/* mema_to_memb:	convert a MEMA-format opcode to a MEMB-format opcode.

   There are 2 possible MEMA formats:
  	- displacement only
  	- displacement + abase

   They are distinguished by the setting of the MEMA_ABASE bit.  */

static void
mema_to_memb (char * opcodeP)	/* Where to find the opcode, in target byte order.  */
{
  long opcode;			/* Opcode in host byte order.  */
  long mode;			/* Mode bits for MEMB instruction.  */

  opcode = md_chars_to_number (opcodeP, 4);
  know (!(opcode & MEMB_BIT));

  mode = MEMB_BIT | D_BIT;
  if (opcode & MEMA_ABASE)
    mode |= A_BIT;

  opcode &= 0xffffc000;		/* Clear MEMA offset and mode bits.  */
  opcode |= mode;		/* Set MEMB mode bits.  */

  md_number_to_chars (opcodeP, opcode, 4);
}

/* targ_has_sfr:

   Return TRUE iff the target architecture supports the specified
   special-function register (sfr).  */

static int
targ_has_sfr (int n)		/* Number (0-31) of sfr.  */
{
  switch (architecture)
    {
    case ARCH_KA:
    case ARCH_KB:
    case ARCH_MC:
    case ARCH_JX:
      return 0;
    case ARCH_HX:
      return ((0 <= n) && (n <= 4));
    case ARCH_CA:
    default:
      return ((0 <= n) && (n <= 2));
    }
}

/* Look up a (suspected) register name in the register table and return the
   associated register number (or -1 if not found).  */

static int
get_regnum (char *regname)	/* Suspected register name.  */
{
  int *rP;

  rP = (int *) hash_find (reg_hash, regname);
  return (rP == NULL) ? -1 : *rP;
}

/* syntax: Issue a syntax error.  */

static void
syntax (void)
{
  as_bad (_("syntax error"));
}

/* parse_regop: parse a register operand.

   In case of illegal operand, issue a message and return some valid
   information so instruction processing can continue.  */

static void
parse_regop (struct regop *regopP,	/* Where to put description of register operand.  */
	     char *optext,		/* Text of operand.  */
	     char opdesc)      		/* Descriptor byte:  what's legal for this operand.  */
{
  int n;			/* Register number.  */
  expressionS e;		/* Parsed expression.  */

  /* See if operand is a register.  */
  n = get_regnum (optext);
  if (n >= 0)
    {
      if (IS_RG_REG (n))
	{
	  /* Global or local register.  */
	  if (!REG_ALIGN (opdesc, n))
	    as_bad (_("unaligned register"));

	  regopP->n = n;
	  regopP->mode = 0;
	  regopP->special = 0;
	  return;
	}
      else if (IS_FP_REG (n) && FP_OK (opdesc))
	{
	  /* Floating point register, and it's allowed.  */
	  regopP->n = n - FP0;
	  regopP->mode = 1;
	  regopP->special = 0;
	  return;
	}
      else if (IS_SF_REG (n) && SFR_OK (opdesc))
	{
	  /* Special-function register, and it's allowed.  */
	  regopP->n = n - SF0;
	  regopP->mode = 0;
	  regopP->special = 1;
	  if (!targ_has_sfr (regopP->n))
	    as_bad (_("no such sfr in this architecture"));

	  return;
	}
    }
  else if (LIT_OK (opdesc))
    {
      /* How about a literal?  */
      regopP->mode = 1;
      regopP->special = 0;
      if (FP_OK (opdesc))
	{
	  /* Floating point literal acceptable.  */
	  /* Skip over 0f, 0d, or 0e prefix.  */
	  if ((optext[0] == '0')
	      && (optext[1] >= 'd')
	      && (optext[1] <= 'f'))
	    optext += 2;

	  if (!strcmp (optext, "0.0") || !strcmp (optext, "0"))
	    {
	      regopP->n = 0x10;
	      return;
	    }

	  if (!strcmp (optext, "1.0") || !strcmp (optext, "1"))
	    {
	      regopP->n = 0x16;
	      return;
	    }
	}
      else
	{
	  /* Fixed point literal acceptable.  */
	  parse_expr (optext, &e);
	  if (e.X_op != O_constant
	      || (offs (e) < 0) || (offs (e) > 31))
	    {
	      as_bad (_("illegal literal"));
	      offs (e) = 0;
	    }
	  regopP->n = offs (e);
	  return;
	}
    }

  /* Nothing worked.  */
  syntax ();
  regopP->mode = 0;		/* Register r0 is always a good one.  */
  regopP->n = 0;
  regopP->special = 0;
}

/* get_ispec:	parse a memory operand for an index specification
   
   Here, an "index specification" is taken to be anything surrounded
   by square brackets and NOT followed by anything else.

   If it's found, detach it from the input string, remove the surrounding
   square brackets, and return a pointer to it.  Otherwise, return NULL.  */

static char *
get_ispec (char *textP)  /* Pointer to memory operand from source instruction, no white space.  */
	   
{
  /* Points to start of index specification.  */
  char *start;
  /* Points to end of index specification.  */
  char *end;

  /* Find opening square bracket, if any.  */
  start = strchr (textP, '[');

  if (start != NULL)
    {
      /* Eliminate '[', detach from rest of operand.  */
      *start++ = '\0';

      end = strchr (start, ']');

      if (end == NULL)
	as_bad (_("unmatched '['"));
      else
	{
	  /* Eliminate ']' and make sure it was the last thing
	     in the string.  */
	  *end = '\0';
	  if (*(end + 1) != '\0')
	    as_bad (_("garbage after index spec ignored"));
	}
    }
  return start;
}

/* parse_memop:	parse a memory operand

  	This routine is based on the observation that the 4 mode bits of the
  	MEMB format, taken individually, have fairly consistent meaning:

  		 M3 (bit 13): 1 if displacement is present (D_BIT)
  		 M2 (bit 12): 1 for MEMB instructions (MEMB_BIT)
  		 M1 (bit 11): 1 if index is present (I_BIT)
  		 M0 (bit 10): 1 if abase is present (A_BIT)

  	So we parse the memory operand and set bits in the mode as we find
  	things.  Then at the end, if we go to MEMB format, we need only set
  	the MEMB bit (M2) and our mode is built for us.

  	Unfortunately, I said "fairly consistent".  The exceptions:

  		 DBIA
  		 0100	Would seem illegal, but means "abase-only".

  		 0101	Would seem to mean "abase-only" -- it means IP-relative.
  			Must be converted to 0100.

  		 0110	Would seem to mean "index-only", but is reserved.
  			We turn on the D bit and provide a 0 displacement.

  	The other thing to observe is that we parse from the right, peeling
  	things * off as we go:  first any index spec, then any abase, then
  	the displacement.  */

static void
parse_memop (memS *memP,	/* Where to put the results.  */
	     char *argP,	/* Text of the operand to be parsed.  */
	     int optype)	/* MEM1, MEM2, MEM4, MEM8, MEM12, or MEM16.  */
{
  char *indexP;			/* Pointer to index specification with "[]" removed.  */
  char *p;			/* Temp char pointer.  */
  char iprel_flag;		/* True if this is an IP-relative operand.  */
  int regnum;			/* Register number.  */
  /* Scale factor: 1,2,4,8, or 16.  Later converted to internal format
     (0,1,2,3,4 respectively).  */
  int scale;
  int mode;			/* MEMB mode bits.  */
  int *intP;			/* Pointer to register number.  */

  /* The following table contains the default scale factors for each
     type of memory instruction.  It is accessed using (optype-MEM1)
     as an index -- thus it assumes the 'optype' constants are
     assigned consecutive values, in the order they appear in this
     table.  */
  static const int def_scale[] =
  {
    1,				/* MEM1 */
    2,				/* MEM2 */
    4,				/* MEM4 */
    8,				/* MEM8 */
    -1,				/* MEM12 -- no valid default */
    16				/* MEM16 */
  };

  iprel_flag = mode = 0;

  /* Any index present? */
  indexP = get_ispec (argP);
  if (indexP)
    {
      p = strchr (indexP, '*');
      if (p == NULL)
	{
	  /* No explicit scale -- use default for this instruction
	     type and assembler mode.  */
	  if (flag_mri)
	    scale = 1;
	  else
	    /* GNU960 compatibility */
	    scale = def_scale[optype - MEM1];
	}
      else
	{
	  *p++ = '\0';		/* Eliminate '*' */

	  /* Now indexP->a '\0'-terminated register name,
	     and p->a scale factor.  */

	  if (!strcmp (p, "16"))
	    scale = 16;
	  else if (strchr ("1248", *p) && (p[1] == '\0'))
	    scale = *p - '0';
	  else
	    scale = -1;
	}

      regnum = get_regnum (indexP);	/* Get index reg. # */
      if (!IS_RG_REG (regnum))
	{
	  as_bad (_("invalid index register"));
	  return;
	}

      /* Convert scale to its binary encoding.  */
      switch (scale)
	{
	case 1:
	  scale = 0 << 7;
	  break;
	case 2:
	  scale = 1 << 7;
	  break;
	case 4:
	  scale = 2 << 7;
	  break;
	case 8:
	  scale = 3 << 7;
	  break;
	case 16:
	  scale = 4 << 7;
	  break;
	default:
	  as_bad (_("invalid scale factor"));
	  return;
	};

      memP->opcode |= scale | regnum;	/* Set index bits in opcode.  */
      mode |= I_BIT;			/* Found a valid index spec.  */
    }

  /* Any abase (Register Indirect) specification present?  */
  if ((p = strrchr (argP, '(')) != NULL)
    {
      /* "(" is there -- does it start a legal abase spec?  If not, it
         could be part of a displacement expression.  */
      intP = (int *) hash_find (areg_hash, p);
      if (intP != NULL)
	{
	  /* Got an abase here.  */
	  regnum = *intP;
	  *p = '\0';		/* Discard register spec.  */
	  if (regnum == IPREL)
	    /* We have to specialcase ip-rel mode.  */
	    iprel_flag = 1;
	  else
	    {
	      memP->opcode |= regnum << 14;
	      mode |= A_BIT;
	    }
	}
    }

  /* Any expression present?  */
  memP->e = argP;
  if (*argP != '\0')
    mode |= D_BIT;

  /* Special-case ip-relative addressing.  */
  if (iprel_flag)
    {
      if (mode & I_BIT)
	syntax ();
      else
	{
	  memP->opcode |= 5 << 10;	/* IP-relative mode.  */
	  memP->disp = 32;
	}
      return;
    }

  /* Handle all other modes.  */
  switch (mode)
    {
    case D_BIT | A_BIT:
      /* Go with MEMA instruction format for now (grow to MEMB later
         if 12 bits is not enough for the displacement).  MEMA format
         has a single mode bit: set it to indicate that abase is
         present.  */
      memP->opcode |= MEMA_ABASE;
      memP->disp = 12;
      break;

    case D_BIT:
      /* Go with MEMA instruction format for now (grow to MEMB later
         if 12 bits is not enough for the displacement).  */
      memP->disp = 12;
      break;

    case A_BIT:
      /* For some reason, the bit string for this mode is not
         consistent: it should be 0 (exclusive of the MEMB bit), so we
         set it "by hand" here.  */
      memP->opcode |= MEMB_BIT;
      break;

    case A_BIT | I_BIT:
      /* set MEMB bit in mode, and OR in mode bits.  */
      memP->opcode |= mode | MEMB_BIT;
      break;

    case I_BIT:
      /* Treat missing displacement as displacement of 0.  */
      mode |= D_BIT;
      /* Fall into next case.  */
    case D_BIT | A_BIT | I_BIT:
    case D_BIT | I_BIT:
      /* Set MEMB bit in mode, and OR in mode bits.  */
      memP->opcode |= mode | MEMB_BIT;
      memP->disp = 32;
      break;

    default:
      syntax ();
      break;
    }
}

/* Generate a MEMA- or MEMB-format instruction.  */

static void
mem_fmt (char *args[],		/* args[0]->opcode mnemonic, args[1-3]->operands.  */
	 struct i960_opcode *oP,/* Pointer to description of instruction.  */
	 int callx)		/* Is this a callx opcode.  */
{
  int i;			/* Loop counter.  */
  struct regop regop;		/* Description of register operand.  */
  char opdesc;			/* Operand descriptor byte.  */
  memS instr;			/* Description of binary to be output.  */
  char *outP;			/* Where the binary was output to.  */
  expressionS exp;		/* Parsed expression.  */
  /* ->description of deferred address fixup.  */
  fixS *fixP;

#ifdef OBJ_COFF
  /* COFF support isn't in place yet for callx relaxing.  */
  callx = 0;
#endif

  memset (&instr, '\0', sizeof (memS));
  instr.opcode = oP->opcode;

  /* Process operands.  */
  for (i = 1; i <= oP->num_ops; i++)
    {
      opdesc = oP->operand[i - 1];

      if (MEMOP (opdesc))
	parse_memop (&instr, args[i], oP->format);
      else
	{
	  parse_regop (&regop, args[i], opdesc);
	  instr.opcode |= regop.n << 19;
	}
    }

  /* Parse the displacement; this must be done before emitting the
     opcode, in case it is an expression using `.'.  */
  parse_expr (instr.e, &exp);

  /* Output opcode.  */
  outP = emit (instr.opcode);

  if (instr.disp == 0)
    return;

  /* Process the displacement.  */
  switch (exp.X_op)
    {
    case O_illegal:
      as_bad (_("expression syntax error"));
      break;

    case O_constant:
      if (instr.disp == 32)
	(void) emit (offs (exp));	/* Output displacement.  */
      else
	{
	  /* 12-bit displacement.  */
	  if (offs (exp) & ~0xfff)
	    {
	      /* Won't fit in 12 bits: convert already-output
	         instruction to MEMB format, output
	         displacement.  */
	      mema_to_memb (outP);
	      (void) emit (offs (exp));
	    }
	  else
	    {
	      /* WILL fit in 12 bits:  OR into opcode and
	         overwrite the binary we already put out.  */
	      instr.opcode |= offs (exp);
	      md_number_to_chars (outP, instr.opcode, 4);
	    }
	}
      break;

    default:
      if (instr.disp == 12)
	/* Displacement is dependent on a symbol, whose value
	   may change at link time.  We HAVE to reserve 32 bits.
	   Convert already-output opcode to MEMB format.  */
	mema_to_memb (outP);

      /* Output 0 displacement and set up address fixup for when
         this symbol's value becomes known.  */
      outP = emit ((long) 0);
      fixP = fix_new_exp (frag_now,
			  outP - frag_now->fr_literal,
			  4, &exp, 0, NO_RELOC);
      /* Steve's linker relaxing hack.  Mark this 32-bit relocation as
         being in the instruction stream, specifically as part of a callx
         instruction.  */
      fixP->fx_bsr = callx;
      break;
    }
}

/* targ_has_iclass:

   Return TRUE iff the target architecture supports the indicated
   class of instructions.  */

static int
targ_has_iclass (int ic) /* Instruction class;  one of:
			    I_BASE, I_CX, I_DEC, I_KX, I_FP, I_MIL, I_CASIM, I_CX2, I_HX, I_HX2.  */
{
  iclasses_seen |= ic;

  switch (architecture)
    {
    case ARCH_KA:
      return ic & (I_BASE | I_KX);
    case ARCH_KB:
      return ic & (I_BASE | I_KX | I_FP | I_DEC);
    case ARCH_MC:
      return ic & (I_BASE | I_KX | I_FP | I_DEC | I_MIL);
    case ARCH_CA:
      return ic & (I_BASE | I_CX | I_CX2 | I_CASIM);
    case ARCH_JX:
      return ic & (I_BASE | I_CX2 | I_JX);
    case ARCH_HX:
      return ic & (I_BASE | I_CX2 | I_JX | I_HX);
    default:
      if ((iclasses_seen & (I_KX | I_FP | I_DEC | I_MIL))
	  && (iclasses_seen & (I_CX | I_CX2)))
	{
	  as_warn (_("architecture of opcode conflicts with that of earlier instruction(s)"));
	  iclasses_seen &= ~ic;
	}
      return 1;
    }
}

/* shift_ok:
   Determine if a "shlo" instruction can be used to implement a "ldconst".
   This means that some number X < 32 can be shifted left to produce the
   constant of interest.

   Return the shift count, or 0 if we can't do it.
   Caller calculates X by shifting original constant right 'shift' places.  */

static int
shift_ok (int n)		/* The constant of interest.  */
{
  int shift;			/* The shift count.  */

  if (n <= 0)
    /* Can't do it for negative numbers.  */
    return 0;

  /* Shift 'n' right until a 1 is about to be lost.  */
  for (shift = 0; (n & 1) == 0; shift++)
    n >>= 1;

  if (n >= 32)
    return 0;

  return shift;
}

/* parse_ldcont:
   Parse and replace a 'ldconst' pseudo-instruction with an appropriate
   i80960 instruction.

   Assumes the input consists of:
  		arg[0]	opcode mnemonic ('ldconst')
  		arg[1]  first operand (constant)
  		arg[2]	name of register to be loaded

   Replaces opcode and/or operands as appropriate.

   Returns the new number of arguments, or -1 on failure.  */

static int
parse_ldconst (char *arg[])	/* See above.  */
{
  int n;			/* Constant to be loaded.  */
  int shift;			/* Shift count for "shlo" instruction.  */
  static char buf[5];		/* Literal for first operand.  */
  static char buf2[5];		/* Literal for second operand.  */
  expressionS e;		/* Parsed expression.  */

  arg[3] = NULL;		/* So we can tell at the end if it got used or not.  */

  parse_expr (arg[1], &e);
  switch (e.X_op)
    {
    default:
      /* We're dependent on one or more symbols -- use "lda".  */
      arg[0] = "lda";
      break;

    case O_constant:
      /* Try the following mappings:
              ldconst   0,<reg>  -> mov  0,<reg>
              ldconst  31,<reg>  -> mov  31,<reg>
              ldconst  32,<reg>  -> addo 1,31,<reg>
              ldconst  62,<reg>  -> addo 31,31,<reg>
              ldconst  64,<reg>  -> shlo 8,3,<reg>
              ldconst  -1,<reg>  -> subo 1,0,<reg>
              ldconst -31,<reg>  -> subo 31,0,<reg>
        
         Anything else becomes:
                lda xxx,<reg>.  */
      n = offs (e);
      if ((0 <= n) && (n <= 31))
	arg[0] = "mov";
      else if ((-31 <= n) && (n <= -1))
	{
	  arg[0] = "subo";
	  arg[3] = arg[2];
	  sprintf (buf, "%d", -n);
	  arg[1] = buf;
	  arg[2] = "0";
	}
      else if ((32 <= n) && (n <= 62))
	{
	  arg[0] = "addo";
	  arg[3] = arg[2];
	  arg[1] = "31";
	  sprintf (buf, "%d", n - 31);
	  arg[2] = buf;
	}
      else if ((shift = shift_ok (n)) != 0)
	{
	  arg[0] = "shlo";
	  arg[3] = arg[2];
	  sprintf (buf, "%d", shift);
	  arg[1] = buf;
	  sprintf (buf2, "%d", n >> shift);
	  arg[2] = buf2;
	}
      else
	arg[0] = "lda";
      break;

    case O_illegal:
      as_bad (_("invalid constant"));
      return -1;
      break;
    }
  return (arg[3] == 0) ? 2 : 3;
}

/* reg_fmt:	generate a REG-format instruction.  */

static void
reg_fmt (char *args[],		/* args[0]->opcode mnemonic, args[1-3]->operands.  */
	 struct i960_opcode *oP)/* Pointer to description of instruction.  */
{
  long instr;			/* Binary to be output.  */
  struct regop regop;		/* Description of register operand.  */
  int n_ops;			/* Number of operands.  */

  instr = oP->opcode;
  n_ops = oP->num_ops;

  if (n_ops >= 1)
    {
      parse_regop (&regop, args[1], oP->operand[0]);

      if ((n_ops == 1) && !(instr & M3))
	{
	  /* 1-operand instruction in which the dst field should
	     be used (instead of src1).  */
	  regop.n <<= 19;
	  if (regop.special)
	    regop.mode = regop.special;
	  regop.mode <<= 13;
	  regop.special = 0;
	}
      else
	{
	  /* regop.n goes in bit 0, needs no shifting.  */
	  regop.mode <<= 11;
	  regop.special <<= 5;
	}
      instr |= regop.n | regop.mode | regop.special;
    }

  if (n_ops >= 2)
    {
      parse_regop (&regop, args[2], oP->operand[1]);

      if ((n_ops == 2) && !(instr & M3))
	{
	  /* 2-operand instruction in which the dst field should
	     be used instead of src2).  */
	  regop.n <<= 19;
	  if (regop.special)
	    regop.mode = regop.special;
	  regop.mode <<= 13;
	  regop.special = 0;
	}
      else
	{
	  regop.n <<= 14;
	  regop.mode <<= 12;
	  regop.special <<= 6;
	}
      instr |= regop.n | regop.mode | regop.special;
    }
  if (n_ops == 3)
    {
      parse_regop (&regop, args[3], oP->operand[2]);
      if (regop.special)
	regop.mode = regop.special;
      instr |= (regop.n <<= 19) | (regop.mode <<= 13);
    }
  emit (instr);
}

/* get_args:	break individual arguments out of comma-separated list

   Input assumptions:
  	- all comments and labels have been removed
  	- all strings of whitespace have been collapsed to a single blank.
  	- all character constants ('x') have been replaced with decimal

   Output:
  	args[0] is untouched. args[1] points to first operand, etc. All args:
  	- are NULL-terminated
  	- contain no whitespace

   Return value:
   Number of operands (0,1,2, or 3) or -1 on error.  */

static int
get_args (char *p, 	/* Pointer to comma-separated operands; Mucked by us.  */
	  char *args[]) /* Output arg: pointers to operands placed in args[1-3].
			   Must accommodate 4 entries (args[0-3]).  */

{
  int n;		/* Number of operands.  */
  char *to;

  /* Skip lead white space.  */
  while (*p == ' ')
    p++;

  if (*p == '\0')
    return 0;

  n = 1;
  args[1] = p;

  /* Squeze blanks out by moving non-blanks toward start of string.
     Isolate operands, whenever comma is found.  */
  to = p;
  while (*p != '\0')
    {
      if (*p == ' '
	  && (! ISALNUM (p[1])
	      || ! ISALNUM (p[-1])))
	p++;
      else if (*p == ',')
	{
	  /* Start of operand.  */
	  if (n == 3)
	    {
	      as_bad (_("too many operands"));
	      return -1;
	    }
	  *to++ = '\0';		/* Terminate argument.  */
	  args[++n] = to;	/* Start next argument.  */
	  p++;
	}
      else
	*to++ = *p++;
    }
  *to = '\0';
  return n;
}

/* i_scan:	perform lexical scan of ascii assembler instruction.

   Input assumptions:
  	- input string is an i80960 instruction (not a pseudo-op)
  	- all comments and labels have been removed
  	- all strings of whitespace have been collapsed to a single blank.

   Output:
  	args[0] points to opcode, other entries point to operands. All strings:
  	- are NULL-terminated
  	- contain no whitespace
  	- have character constants ('x') replaced with a decimal number

   Return value:
     Number of operands (0,1,2, or 3) or -1 on error.  */

static int
i_scan (char *iP,     /* Pointer to ascii instruction;  Mucked by us.  */
	char *args[]) /* Output arg: pointers to opcode and operands placed here.
			 Must accommodate 4 entries.  */
{
  /* Isolate opcode.  */
  if (*(iP) == ' ')
    iP++;

  args[0] = iP;
  for (; *iP != ' '; iP++)
    {
      if (*iP == '\0')
	{
	  /* There are no operands.  */
	  if (args[0] == iP)
	    {
	      /* We never moved: there was no opcode either!  */
	      as_bad (_("missing opcode"));
	      return -1;
	    }
	  return 0;
	}
    }
  *iP++ = '\0';
  return (get_args (iP, args));
}

static void
brcnt_emit (void)
{
  /* Emit call to "increment" routine.  */
  ctrl_fmt (BR_CNT_FUNC, CALL, 1);
  /* Emit inline counter to be incremented.  */
  emit (0);
}

static char *
brlab_next (void)
{
  static char buf[20];

  sprintf (buf, "%s%d", BR_LABEL_BASE, br_cnt++);
  return buf;
}

static void
ctrl_fmt (char *targP,		/* Pointer to text of lone operand (if any).  */
	  long opcode,		/* Template of instruction.  */
	  int num_ops)		/* Number of operands.  */
{
  int instrument;		/* TRUE iff we should add instrumentation to track
				   how often the branch is taken.  */

  if (num_ops == 0)
    emit (opcode);		/* Output opcode.  */
  else
    {
      instrument = instrument_branches && (opcode != CALL)
	&& (opcode != B) && (opcode != RET) && (opcode != BAL);

      if (instrument)
	{
	  brcnt_emit ();
	  colon (brlab_next ());
	}

      /* The operand MUST be an ip-relative displacement. Parse it
         and set up address fix for the instruction we just output.  */
      get_cdisp (targP, "CTRL", opcode, 24, 0, 0);

      if (instrument)
	brcnt_emit ();
    }
}

static void
cobr_fmt (/* arg[0]->opcode mnemonic, arg[1-3]->operands (ascii) */
	  char *arg[],
	  /* Opcode, with branch-prediction bits already set if necessary.  */
	  long opcode,
	  /* Pointer to description of instruction.  */
	  struct i960_opcode *oP)
{
  long instr;			/* 32-bit instruction.  */
  struct regop regop;		/* Description of register operand.  */
  int n;			/* Number of operands.  */
  int var_frag;			/* 1 if varying length code fragment should
				     be emitted;  0 if an address fix
				        should be emitted.  */

  instr = opcode;
  n = oP->num_ops;

  if (n >= 1)
    {
      /* First operand (if any) of a COBR is always a register
	 operand.  Parse it.  */
      parse_regop (&regop, arg[1], oP->operand[0]);
      instr |= (regop.n << 19) | (regop.mode << 13);
    }

  if (n >= 2)
    {
      /* Second operand (if any) of a COBR is always a register
	 operand.  Parse it.  */
      parse_regop (&regop, arg[2], oP->operand[1]);
      instr |= (regop.n << 14) | regop.special;
    }

  if (n < 3)
    emit (instr);
  else
    {
      if (instrument_branches)
	{
	  brcnt_emit ();
	  colon (brlab_next ());
	}

      /* A third operand to a COBR is always a displacement.  Parse
         it; if it's relaxable (a cobr "j" directive, or any cobr
         other than bbs/bbc when the "-norelax" option is not in use)
         set up a variable code fragment; otherwise set up an address
         fix.  */
      var_frag = !norelax || (oP->format == COJ);	/* TRUE or FALSE */
      get_cdisp (arg[3], "COBR", instr, 13, var_frag, 0);

      if (instrument_branches)
	brcnt_emit ();
    }
}

/* Assumptions about the passed-in text:
  	- all comments, labels removed
  	- text is an instruction
  	- all white space compressed to single blanks
  	- all character constants have been replaced with decimal.  */

void
md_assemble (char *textP)
{
  /* Parsed instruction text, containing NO whitespace: arg[0]->opcode
     mnemonic arg[1-3]->operands, with char constants replaced by
     decimal numbers.  */
  char *args[4];
  /* Number of instruction operands.  */
  int n_ops;
  /* Pointer to instruction description.  */
  struct i960_opcode *oP;
  /* TRUE iff opcode mnemonic included branch-prediction suffix (".f"
     or ".t").  */
  int branch_predict;
  /* Setting of branch-prediction bit(s) to be OR'd into instruction
     opcode of CTRL/COBR format instructions.  */
  long bp_bits;
  /* Offset of last character in opcode mnemonic.  */
  int n;
  const char *bp_error_msg = _("branch prediction invalid on this opcode");

  /* Parse instruction into opcode and operands.  */
  memset (args, '\0', sizeof (args));

  n_ops = i_scan (textP, args);

  if (n_ops == -1)
    return;			/* Error message already issued.  */

  /* Do "macro substitution" (sort of) on 'ldconst' pseudo-instruction.  */
  if (!strcmp (args[0], "ldconst"))
    {
      n_ops = parse_ldconst (args);
      if (n_ops == -1)
	return;
    }

  /* Check for branch-prediction suffix on opcode mnemonic, strip it off.  */
  n = strlen (args[0]) - 1;
  branch_predict = 0;
  bp_bits = 0;

  if (args[0][n - 1] == '.' && (args[0][n] == 't' || args[0][n] == 'f'))
    {
      /* We could check here to see if the target architecture
	 supports branch prediction, but why bother?  The bit will
	 just be ignored by processors that don't use it.  */
      branch_predict = 1;
      bp_bits = (args[0][n] == 't') ? BP_TAKEN : BP_NOT_TAKEN;
      args[0][n - 1] = '\0';	/* Strip suffix from opcode mnemonic */
    }

  /* Look up opcode mnemonic in table and check number of operands.
     Check that opcode is legal for the target architecture.  If all
     looks good, assemble instruction.  */
  oP = (struct i960_opcode *) hash_find (op_hash, args[0]);
  if (!oP || !targ_has_iclass (oP->iclass))
    as_bad (_("invalid opcode, \"%s\"."), args[0]);
  else if (n_ops != oP->num_ops)
    as_bad (_("improper number of operands.  expecting %d, got %d"),
	    oP->num_ops, n_ops);
  else
    {
      switch (oP->format)
	{
	case FBRA:
	case CTRL:
	  ctrl_fmt (args[1], oP->opcode | bp_bits, oP->num_ops);
	  if (oP->format == FBRA)
	    /* Now generate a 'bno' to same arg */
	    ctrl_fmt (args[1], BNO | bp_bits, 1);
	  break;
	case COBR:
	case COJ:
	  cobr_fmt (args, oP->opcode | bp_bits, oP);
	  break;
	case REG:
	  if (branch_predict)
	    as_warn ("%s", bp_error_msg);
	  reg_fmt (args, oP);
	  break;
	case MEM1:
	  if (args[0][0] == 'c' && args[0][1] == 'a')
	    {
	      if (branch_predict)
		as_warn ("%s", bp_error_msg);
	      mem_fmt (args, oP, 1);
	      break;
	    }
	case MEM2:
	case MEM4:
	case MEM8:
	case MEM12:
	case MEM16:
	  if (branch_predict)
	    as_warn ("%s", bp_error_msg);
	  mem_fmt (args, oP, 0);
	  break;
	case CALLJ:
	  if (branch_predict)
	    as_warn ("%s", bp_error_msg);
	  /* Output opcode & set up "fixup" (relocation); flag
	     relocation as 'callj' type.  */
	  know (oP->num_ops == 1);
	  get_cdisp (args[1], "CTRL", oP->opcode, 24, 0, 1);
	  break;
	default:
	  BAD_CASE (oP->format);
	  break;
	}
    }
}

void
md_number_to_chars (char *buf,
		    valueT value,
		    int n)
{
  number_to_chars_littleendian (buf, value, n);
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, FALSE);
}

static void
md_number_to_imm (char *buf, long val, int n)
{
  md_number_to_chars (buf, val, n);
}

static void
md_number_to_field (char *instrP,		/* Pointer to instruction to be fixed.  */
		    long val,			/* Address fixup value.  */
		    bit_fixS *bfixP)		/* Description of bit field to be fixed up.  */
{
  int numbits;			/* Length of bit field to be fixed.  */
  long instr;			/* 32-bit instruction to be fixed-up.  */
  long sign;			/* 0 or -1, according to sign bit of 'val'.  */

  /* Convert instruction back to host byte order.  */
  instr = md_chars_to_number (instrP, 4);

  /* Surprise! -- we stored the number of bits to be modified rather
     than a pointer to a structure.  */
  numbits = (int) (size_t) bfixP;
  if (numbits == 1)
    /* This is a no-op, stuck here by reloc_callj().  */
    return;

  know ((numbits == 13) || (numbits == 24));

  /* Propagate sign bit of 'val' for the given number of bits.  Result
     should be all 0 or all 1.  */
  sign = val >> ((int) numbits - 1);
  if (((val < 0) && (sign != -1))
      || ((val > 0) && (sign != 0)))
    as_bad (_("Fixup of %ld too large for field width of %d"),
	    val, numbits);
  else
    {
      /* Put bit field into instruction and write back in target
         * byte order.  */
      val &= ~(-1 << (int) numbits);	/* Clear unused sign bits.  */
      instr |= val;
      md_number_to_chars (instrP, instr, 4);
    }
}


/* md_parse_option
  	Invocation line includes a switch not recognized by the base assembler.
  	See if it's a processor-specific option.  For the 960, these are:

  	-norelax:
  		Conditional branch instructions that require displacements
  		greater than 13 bits (or that have external targets) should
  		generate errors.  The default is to replace each such
  		instruction with the corresponding compare (or chkbit) and
  		branch instructions.  Note that the Intel "j" cobr directives
  		are ALWAYS "de-optimized" in this way when necessary,
  		regardless of the setting of this option.

  	-b:
  		Add code to collect information about branches taken, for
  		later optimization of branch prediction bits by a separate
  		tool.  COBR and CNTL format instructions have branch
  		prediction bits (in the CX architecture);  if "BR" represents
  		an instruction in one of these classes, the following rep-
  		resents the code generated by the assembler:

  			call	<increment routine>
  			.word	0	# pre-counter
  		Label:  BR
  			call	<increment routine>
  			.word	0	# post-counter

  		A table of all such "Labels" is also generated.

  	-AKA, -AKB, -AKC, -ASA, -ASB, -AMC, -ACA:
  		Select the 80960 architecture.  Instructions or features not
  		supported by the selected architecture cause fatal errors.
  		The default is to generate code for any instruction or feature
  		that is supported by SOME version of the 960 (even if this
  		means mixing architectures!).  */

const char *md_shortopts = "A:b";
struct option md_longopts[] =
{
#define OPTION_LINKRELAX (OPTION_MD_BASE)
  {"linkrelax", no_argument, NULL, OPTION_LINKRELAX},
  {"link-relax", no_argument, NULL, OPTION_LINKRELAX},
#define OPTION_NORELAX (OPTION_MD_BASE + 1)
  {"norelax", no_argument, NULL, OPTION_NORELAX},
  {"no-relax", no_argument, NULL, OPTION_NORELAX},
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

struct tabentry
{
  char *flag;
  int arch;
};
static const struct tabentry arch_tab[] =
{
  {"KA", ARCH_KA},
  {"KB", ARCH_KB},
  {"SA", ARCH_KA},		/* Synonym for KA.  */
  {"SB", ARCH_KB},		/* Synonym for KB.  */
  {"KC", ARCH_MC},		/* Synonym for MC.  */
  {"MC", ARCH_MC},
  {"CA", ARCH_CA},
  {"JX", ARCH_JX},
  {"HX", ARCH_HX},
  {NULL, 0}
};

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case OPTION_LINKRELAX:
      linkrelax = 1;
      flag_keep_locals = 1;
      break;

    case OPTION_NORELAX:
      norelax = 1;
      break;

    case 'b':
      instrument_branches = 1;
      break;

    case 'A':
      {
	const struct tabentry *tp;
	char *p = arg;

	for (tp = arch_tab; tp->flag != NULL; tp++)
	  if (!strcmp (p, tp->flag))
	    break;

	if (tp->flag == NULL)
	  {
	    as_bad (_("invalid architecture %s"), p);
	    return 0;
	  }
	else
	  architecture = tp->arch;
      }
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  int i;

  fprintf (stream, _("I960 options:\n"));
  for (i = 0; arch_tab[i].flag; i++)
    fprintf (stream, "%s-A%s", i ? " | " : "", arch_tab[i].flag);
  fprintf (stream, _("\n\
			specify variant of 960 architecture\n\
-b			add code to collect statistics about branches taken\n\
-link-relax		preserve individual alignment directives so linker\n\
			can do relaxing (b.out format only)\n\
-no-relax		don't alter compare-and-branch instructions for\n\
			long displacements\n"));
}

/* relax_cobr:
   Replace cobr instruction in a code fragment with equivalent branch and
   compare instructions, so it can reach beyond a 13-bit displacement.
   Set up an address fix/relocation for the new branch instruction.  */

/* This "conditional jump" table maps cobr instructions into
   equivalent compare and branch opcodes.  */

static const
struct
{
  long compare;
  long branch;
}

coj[] =
{				/* COBR OPCODE: */
  { CHKBIT, BNO },		/*      0x30 - bbc */
  { CMPO, BG },			/*      0x31 - cmpobg */
  { CMPO, BE },			/*      0x32 - cmpobe */
  { CMPO, BGE },		/*      0x33 - cmpobge */
  { CMPO, BL },			/*      0x34 - cmpobl */
  { CMPO, BNE },		/*      0x35 - cmpobne */
  { CMPO, BLE },		/*      0x36 - cmpoble */
  { CHKBIT, BO },		/*      0x37 - bbs */
  { CMPI, BNO },		/*      0x38 - cmpibno */
  { CMPI, BG },			/*      0x39 - cmpibg */
  { CMPI, BE },			/*      0x3a - cmpibe */
  { CMPI, BGE },		/*      0x3b - cmpibge */
  { CMPI, BL },			/*      0x3c - cmpibl */
  { CMPI, BNE },		/*      0x3d - cmpibne */
  { CMPI, BLE },		/*      0x3e - cmpible */
  { CMPI, BO },			/*      0x3f - cmpibo */
};

static void
relax_cobr (fragS *fragP)	/* fragP->fr_opcode is assumed to point to
				   the cobr instruction, which comes at the
				   end of the code fragment.  */
{
  int opcode, src1, src2, m1, s2;
  /* Bit fields from cobr instruction.  */
  long bp_bits;			/* Branch prediction bits from cobr instruction.  */
  long instr;			/* A single i960 instruction.  */
  /* ->instruction to be replaced.  */
  char *iP;
  fixS *fixP;			/* Relocation that can be done at assembly time.  */

  /* Pick up & parse cobr instruction.  */
  iP = fragP->fr_opcode;
  instr = md_chars_to_number (iP, 4);
  opcode = ((instr >> 24) & 0xff) - 0x30;	/* "-0x30" for table index.  */
  src1 = (instr >> 19) & 0x1f;
  m1 = (instr >> 13) & 1;
  s2 = instr & 1;
  src2 = (instr >> 14) & 0x1f;
  bp_bits = instr & BP_MASK;

  /* Generate and output compare instruction.  */
  instr = coj[opcode].compare
    | src1 | (m1 << 11) | (s2 << 6) | (src2 << 14);
  md_number_to_chars (iP, instr, 4);

  /* Output branch instruction.  */
  md_number_to_chars (iP + 4, coj[opcode].branch | bp_bits, 4);

  /* Set up address fixup/relocation.  */
  fixP = fix_new (fragP,
		  iP + 4 - fragP->fr_literal,
		  4,
		  fragP->fr_symbol,
		  fragP->fr_offset,
		  1,
		  NO_RELOC);

  fixP->fx_bit_fixP = (bit_fixS *) 24;	/* Store size of bit field.  */

  fragP->fr_fix += 4;
  frag_wane (fragP);
}

/* md_convert_frag:

   Called by base assembler after address relaxation is finished:  modify
   variable fragments according to how much relaxation was done.

   If the fragment substate is still 1, a 13-bit displacement was enough
   to reach the symbol in question.  Set up an address fixup, but otherwise
   leave the cobr instruction alone.

   If the fragment substate is 2, a 13-bit displacement was not enough.
   Replace the cobr with a two instructions (a compare and a branch).  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 segT sec ATTRIBUTE_UNUSED,
		 fragS *fragP)
{
  /* Structure describing needed address fix.  */
  fixS *fixP;

  switch (fragP->fr_subtype)
    {
    case 1:
      /* Leave single cobr instruction.  */
      fixP = fix_new (fragP,
		      fragP->fr_opcode - fragP->fr_literal,
		      4,
		      fragP->fr_symbol,
		      fragP->fr_offset,
		      1,
		      NO_RELOC);

      fixP->fx_bit_fixP = (bit_fixS *) 13;	/* Size of bit field.  */
      break;
    case 2:
      /* Replace cobr with compare/branch instructions.  */
      relax_cobr (fragP);
      break;
    default:
      BAD_CASE (fragP->fr_subtype);
      break;
    }
}

/* md_estimate_size_before_relax:  How much does it look like *fragP will grow?

   Called by base assembler just before address relaxation.
   Return the amount by which the fragment will grow.

   Any symbol that is now undefined will not become defined; cobr's
   based on undefined symbols will have to be replaced with a compare
   instruction and a branch instruction, and the code fragment will grow
   by 4 bytes.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment_type)
{
  /* If symbol is undefined in this segment, go to "relaxed" state
     (compare and branch instructions instead of cobr) right now.  */
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment_type)
    {
      relax_cobr (fragP);
      return 4;
    }

  return md_relax_table[fragP->fr_subtype].rlx_length;
}

#if defined(OBJ_AOUT) | defined(OBJ_BOUT)

/* md_ri_to_chars:
   This routine exists in order to overcome machine byte-order problems
   when dealing with bit-field entries in the relocation_info struct.

   But relocation info will be used on the host machine only (only
   executable code is actually downloaded to the i80960).  Therefore,
   we leave it in host byte order.  */

static void
md_ri_to_chars (char *where, struct relocation_info *ri)
{
  host_number_to_chars (where, ri->r_address, 4);
  host_number_to_chars (where + 4, ri->r_index, 3);
#if WORDS_BIGENDIAN
  where[7] = (ri->r_pcrel << 7
	      | ri->r_length << 5
	      | ri->r_extern << 4
	      | ri->r_bsr << 3
	      | ri->r_disp << 2
	      | ri->r_callj << 1
	      | ri->nuthin << 0);
#else
  where[7] = (ri->r_pcrel << 0
	      | ri->r_length << 1
	      | ri->r_extern << 3
	      | ri->r_bsr << 4
	      | ri->r_disp << 5
	      | ri->r_callj << 6
	      | ri->nuthin << 7);
#endif
}

#endif /* defined(OBJ_AOUT) | defined(OBJ_BOUT) */


/* brtab_emit:	generate the fetch-prediction branch table.

   See the comments above the declaration of 'br_cnt' for details on
   branch-prediction instrumentation.

   The code emitted here would be functionally equivalent to the following
   example assembler source.

  			.data
  			.align	2
  	   BR_TAB_NAME:
  			.word	0		# link to next table
  			.word	3		# length of table
  			.word	LBRANCH0	# 1st entry in table proper
  			.word	LBRANCH1
  			.word	LBRANCH2  */

void
brtab_emit (void)
{
  int i;
  char buf[20];
  /* Where the binary was output to.  */
  char *p;

  if (!instrument_branches)
    return;

  subseg_set (data_section, 0);	/*      .data */
  frag_align (2, 0, 0);		/*      .align 2 */
  record_alignment (now_seg, 2);
  colon (BR_TAB_NAME);		/* BR_TAB_NAME: */
  emit (0);			/*      .word 0 #link to next table */
  emit (br_cnt);		/*      .word n #length of table */

  for (i = 0; i < br_cnt; i++)
    {
      sprintf (buf, "%s%d", BR_LABEL_BASE, i);
      p = emit (0);
      fix_new (frag_now,
	       p - frag_now->fr_literal,
	       4, symbol_find (buf), 0, 0, NO_RELOC);
    }
}

/* s_leafproc:	process .leafproc pseudo-op

  	.leafproc takes two arguments, the second one is optional:
  		arg[1]: name of 'call' entry point to leaf procedure
  		arg[2]: name of 'bal' entry point to leaf procedure

  	If the two arguments are identical, or if the second one is missing,
  	the first argument is taken to be the 'bal' entry point.

  	If there are 2 distinct arguments, we must make sure that the 'bal'
  	entry point immediately follows the 'call' entry point in the linked
  	list of symbols.  */

static void
s_leafproc (int n_ops,		/* Number of operands.  */
	    char *args[])	/* args[1]->1st operand, args[2]->2nd operand.  */
{
  symbolS *callP;		/* Pointer to leafproc 'call' entry point symbol.  */
  symbolS *balP;		/* Pointer to leafproc 'bal' entry point symbol.  */

  if ((n_ops != 1) && (n_ops != 2))
    {
      as_bad (_("should have 1 or 2 operands"));
      return;
    }

  /* Find or create symbol for 'call' entry point.  */
  callP = symbol_find_or_make (args[1]);

  if (TC_S_IS_CALLNAME (callP))
    as_warn (_("Redefining leafproc %s"), S_GET_NAME (callP));

  /* If that was the only argument, use it as the 'bal' entry point.
     Otherwise, mark it as the 'call' entry point and find or create
     another symbol for the 'bal' entry point.  */
  if ((n_ops == 1) || !strcmp (args[1], args[2]))
    {
      TC_S_FORCE_TO_BALNAME (callP);
    }
  else
    {
      TC_S_FORCE_TO_CALLNAME (callP);

      balP = symbol_find_or_make (args[2]);
      if (TC_S_IS_CALLNAME (balP))
	as_warn (_("Redefining leafproc %s"), S_GET_NAME (balP));

      TC_S_FORCE_TO_BALNAME (balP);

#ifndef OBJ_ELF
      tc_set_bal_of_call (callP, balP);
#endif
    }
}

/* s_sysproc: process .sysproc pseudo-op

   .sysproc takes two arguments:
     arg[1]: name of entry point to system procedure
     arg[2]: 'entry_num' (index) of system procedure in the range
     [0,31] inclusive.

   For [ab].out, we store the 'entrynum' in the 'n_other' field of
   the symbol.  Since that entry is normally 0, we bias 'entrynum'
   by adding 1 to it.  It must be unbiased before it is used.  */

static void
s_sysproc (int n_ops,		/* Number of operands.  */
	   char *args[])	/* args[1]->1st operand, args[2]->2nd operand.  */
{
  expressionS exp;
  symbolS *symP;

  if (n_ops != 2)
    {
      as_bad (_("should have two operands"));
      return;
    }

  /* Parse "entry_num" argument and check it for validity.  */
  parse_expr (args[2], &exp);
  if (exp.X_op != O_constant
      || (offs (exp) < 0)
      || (offs (exp) > 31))
    {
      as_bad (_("'entry_num' must be absolute number in [0,31]"));
      return;
    }

  /* Find/make symbol and stick entry number (biased by +1) into it.  */
  symP = symbol_find_or_make (args[1]);

  if (TC_S_IS_SYSPROC (symP))
    as_warn (_("Redefining entrynum for sysproc %s"), S_GET_NAME (symP));

  TC_S_SET_SYSPROC (symP, offs (exp));	/* Encode entry number.  */
  TC_S_FORCE_TO_SYSPROC (symP);
}

/* parse_po:	parse machine-dependent pseudo-op

   This is a top-level routine for machine-dependent pseudo-ops.  It slurps
   up the rest of the input line, breaks out the individual arguments,
   and dispatches them to the correct handler.  */

static void
parse_po (int po_num)	/* Pseudo-op number:  currently S_LEAFPROC or S_SYSPROC.  */
{
  /* Pointers operands, with no embedded whitespace.
     arg[0] unused, arg[1-3]->operands.  */
  char *args[4];
  int n_ops;			/* Number of operands.  */
  char *p;			/* Pointer to beginning of unparsed argument string.  */
  char eol;			/* Character that indicated end of line.  */

  extern char is_end_of_line[];

  /* Advance input pointer to end of line.  */
  p = input_line_pointer;
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;

  eol = *input_line_pointer;	/* Save end-of-line char.  */
  *input_line_pointer = '\0';	/* Terminate argument list.  */

  /* Parse out operands.  */
  n_ops = get_args (p, args);
  if (n_ops == -1)
    return;

  /* Dispatch to correct handler.  */
  switch (po_num)
    {
    case S_SYSPROC:
      s_sysproc (n_ops, args);
      break;
    case S_LEAFPROC:
      s_leafproc (n_ops, args);
      break;
    default:
      BAD_CASE (po_num);
      break;
    }

  /* Restore eol, so line numbers get updated correctly.  Base
     assembler assumes we leave input pointer pointing at char
     following the eol.  */
  *input_line_pointer++ = eol;
}

/* reloc_callj:	Relocate a 'callj' instruction

  	This is a "non-(GNU)-standard" machine-dependent hook.  The base
  	assembler calls it when it decides it can relocate an address at
  	assembly time instead of emitting a relocation directive.

  	Check to see if the relocation involves a 'callj' instruction to a:
  	    sysproc:	Replace the default 'call' instruction with a 'calls'
  	    leafproc:	Replace the default 'call' instruction with a 'bal'.
  	    other proc:	Do nothing.

  	See b.out.h for details on the 'n_other' field in a symbol structure.

   IMPORTANT!:
  	Assumes the caller has already figured out, in the case of a leafproc,
  	to use the 'bal' entry point, and has substituted that symbol into the
  	passed fixup structure.  */

int
reloc_callj (fixS *fixP)  /* Relocation that can be done at assembly time.  */    
{
  /* Points to the binary for the instruction being relocated.  */
  char *where;

  if (!fixP->fx_tcbit)
    /* This wasn't a callj instruction in the first place.  */
    return 0;

  where = fixP->fx_frag->fr_literal + fixP->fx_where;

  if (TC_S_IS_SYSPROC (fixP->fx_addsy))
    {
      /* Symbol is a .sysproc: replace 'call' with 'calls'.  System
         procedure number is (other-1).  */
      md_number_to_chars (where, CALLS | TC_S_GET_SYSPROC (fixP->fx_addsy), 4);

      /* Nothing else needs to be done for this instruction.  Make
         sure 'md_number_to_field()' will perform a no-op.  */
      fixP->fx_bit_fixP = (bit_fixS *) 1;
    }
  else if (TC_S_IS_CALLNAME (fixP->fx_addsy))
    {
      /* Should not happen: see block comment above.  */
      as_fatal (_("Trying to 'bal' to %s"), S_GET_NAME (fixP->fx_addsy));
    }
  else if (TC_S_IS_BALNAME (fixP->fx_addsy))
    {
      /* Replace 'call' with 'bal'; both instructions have the same
         format, so calling code should complete relocation as if
         nothing happened here.  */
      md_number_to_chars (where, BAL, 4);
    }
  else if (TC_S_IS_BADPROC (fixP->fx_addsy))
    as_bad (_("Looks like a proc, but can't tell what kind.\n"));

  /* Otherwise Symbol is neither a sysproc nor a leafproc.  */
  return 0;
}

/* Handle the MRI .endian pseudo-op.  */

static void
s_endian (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c;

  name = input_line_pointer;
  c = get_symbol_end ();
  if (strcasecmp (name, "little") == 0)
    ;
  else if (strcasecmp (name, "big") == 0)
    as_bad (_("big endian mode is not supported"));
  else
    as_warn (_("ignoring unrecognized .endian type `%s'"), name);

  *input_line_pointer = c;

  demand_empty_rest_of_line ();
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Exactly what point is a PC-relative offset relative TO?
   On the i960, they're relative to the address of the instruction,
   which we have set up as the address of the fixup too.  */
long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_where + fixP->fx_frag->fr_address;
}

void
md_apply_fix (fixS *fixP,
	       valueT *valP,
	       segT seg ATTRIBUTE_UNUSED)
{
  long val = *valP;
  char *place = fixP->fx_where + fixP->fx_frag->fr_literal;

  if (!fixP->fx_bit_fixP)
    {
      md_number_to_imm (place, val, fixP->fx_size);
    }
  else if ((int) (size_t) fixP->fx_bit_fixP == 13
	   && fixP->fx_addsy != NULL
	   && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section)
    {
      /* This is a COBR instruction.  They have only a
	 13-bit displacement and are only to be used
	 for local branches: flag as error, don't generate
	 relocation.  */
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("can't use COBR format with external label"));
      fixP->fx_addsy = NULL;
    }
  else
    md_number_to_field (place, val, fixP->fx_bit_fixP);

  if (fixP->fx_addsy == NULL)
    fixP->fx_done = 1;
}

#if defined(OBJ_AOUT) | defined(OBJ_BOUT)
void
tc_bout_fix_to_chars (char *where,
		      fixS *fixP,
		      relax_addressT segment_address_in_file)
{
  static const unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
  struct relocation_info ri;
  symbolS *symbolP;

  memset ((char *) &ri, '\0', sizeof (ri));
  symbolP = fixP->fx_addsy;
  know (symbolP != 0 || fixP->fx_r_type != NO_RELOC);
  ri.r_bsr = fixP->fx_bsr;	/*SAC LD RELAX HACK */
  /* These two 'cuz of NS32K */
  ri.r_callj = fixP->fx_tcbit;
  if (fixP->fx_bit_fixP)
    ri.r_length = 2;
  else
    ri.r_length = nbytes_r_length[fixP->fx_size];
  ri.r_pcrel = fixP->fx_pcrel;
  ri.r_address = fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file;

  if (fixP->fx_r_type != NO_RELOC)
    {
      switch (fixP->fx_r_type)
	{
	case rs_align:
	  ri.r_index = -2;
	  ri.r_pcrel = 1;
	  ri.r_length = fixP->fx_size - 1;
	  break;
	case rs_org:
	  ri.r_index = -2;
	  ri.r_pcrel = 0;
	  break;
	case rs_fill:
	  ri.r_index = -1;
	  break;
	default:
	  abort ();
	}
      ri.r_extern = 0;
    }
  else if (linkrelax || !S_IS_DEFINED (symbolP) || fixP->fx_bsr)
    {
      ri.r_extern = 1;
      ri.r_index = symbolP->sy_number;
    }
  else
    {
      ri.r_extern = 0;
      ri.r_index = S_GET_TYPE (symbolP);
    }

  /* Output the relocation information in machine-dependent form.  */
  md_ri_to_chars (where, &ri);
}

#endif /* OBJ_AOUT or OBJ_BOUT */

/* Align an address by rounding it up to the specified boundary.  */

valueT
md_section_align (segT seg,
		  valueT addr)		/* Address to be rounded up.  */
{
  int align;

  align = bfd_get_section_alignment (stdoutput, seg);
  return (addr + (1 << align) - 1) & (-1 << align);
}

extern int coff_flags;

/* For aout or bout, the bal immediately follows the call.

   For coff, we cheat and store a pointer to the bal symbol in the
   second aux entry of the call.  */

#undef OBJ_ABOUT
#ifdef OBJ_AOUT
#define OBJ_ABOUT
#endif
#ifdef OBJ_BOUT
#define OBJ_ABOUT
#endif

void
tc_set_bal_of_call (symbolS *callP ATTRIBUTE_UNUSED,
		    symbolS *balP ATTRIBUTE_UNUSED)
{
  know (TC_S_IS_CALLNAME (callP));
  know (TC_S_IS_BALNAME (balP));

#ifdef OBJ_COFF

  callP->sy_tc = balP;
  S_SET_NUMBER_AUXILIARY (callP, 2);

#else /* ! OBJ_COFF */
#ifdef OBJ_ABOUT

  /* If the 'bal' entry doesn't immediately follow the 'call'
     symbol, unlink it from the symbol list and re-insert it.  */
  if (symbol_next (callP) != balP)
    {
      symbol_remove (balP, &symbol_rootP, &symbol_lastP);
      symbol_append (balP, callP, &symbol_rootP, &symbol_lastP);
    }				/* if not in order */

#else /* ! OBJ_ABOUT */
  as_fatal ("Only supported for a.out, b.out, or COFF");
#endif /* ! OBJ_ABOUT */
#endif /* ! OBJ_COFF */
}

symbolS *
tc_get_bal_of_call (symbolS *callP ATTRIBUTE_UNUSED)
{
  symbolS *retval;

  know (TC_S_IS_CALLNAME (callP));

#ifdef OBJ_COFF
  retval = callP->sy_tc;
#else
#ifdef OBJ_ABOUT
  retval = symbol_next (callP);
#else
  as_fatal ("Only supported for a.out, b.out, or COFF");
#endif /* ! OBJ_ABOUT */
#endif /* ! OBJ_COFF */

  know (TC_S_IS_BALNAME (retval));
  return retval;
}

#ifdef OBJ_COFF
void
tc_coff_symbol_emit_hook (symbolS *symbolP ATTRIBUTE_UNUSED)
{
  if (TC_S_IS_CALLNAME (symbolP))
    {
      symbolS *balP = tc_get_bal_of_call (symbolP);

      symbolP->sy_symbol.ost_auxent[1].x_bal.x_balntry = S_GET_VALUE (balP);
      if (S_GET_STORAGE_CLASS (symbolP) == C_EXT)
	S_SET_STORAGE_CLASS (symbolP, C_LEAFEXT);
      else
	S_SET_STORAGE_CLASS (symbolP, C_LEAFSTAT);
      S_SET_DATA_TYPE (symbolP, S_GET_DATA_TYPE (symbolP) | (DT_FCN << N_BTSHFT));
      /* Fix up the bal symbol.  */
      S_SET_STORAGE_CLASS (balP, C_LABEL);
    }
}
#endif /* OBJ_COFF */

void
i960_handle_align (fragS *fragp ATTRIBUTE_UNUSED)
{
  if (!linkrelax)
    return;

#ifndef OBJ_BOUT
  as_bad (_("option --link-relax is only supported in b.out format"));
  linkrelax = 0;
  return;
#else

  /* The text section "ends" with another alignment reloc, to which we
     aren't adding padding.  */
  if (fragp->fr_next == text_last_frag
      || fragp->fr_next == data_last_frag)
    return;

  /* alignment directive */
  fix_new (fragp, fragp->fr_fix, fragp->fr_offset, 0, 0, 0,
	   (int) fragp->fr_type);
#endif /* OBJ_BOUT */
}

int
i960_validate_fix (fixS *fixP, segT this_segment_type ATTRIBUTE_UNUSED)
{
  if (fixP->fx_tcbit && TC_S_IS_CALLNAME (fixP->fx_addsy))
    {
      /* Relocation should be done via the associated 'bal'
         entry point symbol.  */
      if (!TC_S_IS_BALNAME (tc_get_bal_of_call (fixP->fx_addsy)))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("No 'bal' entry point for leafproc %s"),
			S_GET_NAME (fixP->fx_addsy));
	  return 0;
	}
      fixP->fx_addsy = tc_get_bal_of_call (fixP->fx_addsy);
    }

  return 1;
}

/* From cgen.c:  */

static short
tc_bfd_fix2rtype (fixS *fixP)
{
  if (fixP->fx_pcrel == 0 && fixP->fx_size == 4)
    return BFD_RELOC_32;

  if (fixP->fx_pcrel != 0 && fixP->fx_size == 4)
    return BFD_RELOC_24_PCREL;

  abort ();
  return 0;
}

/* Translate internal representation of relocation info to BFD target
   format.

   FIXME: To what extent can we get all relevant targets to use this?  */

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixP)
{
  arelent * reloc;

  reloc = xmalloc (sizeof (arelent));

  /* HACK: Is this right?  */
  fixP->fx_r_type = tc_bfd_fix2rtype (fixP);

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("internal error: can't export reloc type %d (`%s')"),
		    fixP->fx_r_type,
		    bfd_get_reloc_code_name (fixP->fx_r_type));
      return NULL;
    }

  gas_assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
  reloc->addend = fixP->fx_addnumber;

  return reloc;
}

/* end from cgen.c */

const pseudo_typeS md_pseudo_table[] =
{
  {"bss", s_lcomm, 1},
  {"endian", s_endian, 0},
  {"extended", float_cons, 't'},
  {"leafproc", parse_po, S_LEAFPROC},
  {"sysproc", parse_po, S_SYSPROC},

  {"word", cons, 4},
  {"quad", cons, 16},

  {0, 0, 0}
};
@


1.30
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2009
d1072 1
a1072 1
  expressionS expr;		/* Parsed expression.  */
d1100 1
a1100 1
  parse_expr (instr.e, &expr);
d1109 1
a1109 1
  switch (expr.X_op)
d1117 1
a1117 1
	(void) emit (offs (expr));	/* Output displacement.  */
d1121 1
a1121 1
	  if (offs (expr) & ~0xfff)
d1127 1
a1127 1
	      (void) emit (offs (expr));
d1133 1
a1133 1
	      instr.opcode |= offs (expr);
d1151 1
a1151 1
			  4, & expr, 0, NO_RELOC);
a2102 2
  /* Pointer to description of deferred address fixup.  */
  fixS *fixP;
d2118 3
a2120 3
      fixP = fix_new (frag_now,
		      p - frag_now->fr_literal,
		      4, symbol_find (buf), 0, 0, NO_RELOC);
@


1.29
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007
d1670 1
a1670 1
	    as_warn (bp_error_msg);
d1677 1
a1677 1
		as_warn (bp_error_msg);
d1687 1
a1687 1
	    as_warn (bp_error_msg);
d1692 1
a1692 1
	    as_warn (bp_error_msg);
d2641 1
a2641 1
		    "internal error: can't export reloc type %d (`%s')",
@


1.28
log
@Remove duplicate definitions of the md_atof() function
@
text
@d2647 1
a2647 1
  assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);
@


1.27
log
@Switch to GPLv3
@
text
@a1712 13
#define MAX_LITTLENUMS	6
#define LNUM_SIZE	sizeof (LITTLENUM_TYPE)

/* md_atof:	convert ascii to floating point

   Turn a string at input_line_pointer into a floating point constant of type
   'type', and store the appropriate bytes at *litP.  The number of LITTLENUMS
   emitted is returned at 'sizeP'.  An error message is returned, or a pointer
   to an empty message if OK.

   Note we call the i386 floating point routine, rather than complicating
   things with more files or symbolic links.  */

d1716 1
a1716 45
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  int prec;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
      prec = 2;
      break;

    case 'd':
    case 'D':
      prec = 4;
      break;

    case 't':
    case 'T':
      prec = 5;
      type = 'x';		/* That's what atof_ieee() understands.  */
      break;

    default:
      *sizeP = 0;
      return _("Bad call to md_atof()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * LNUM_SIZE;

  /* Output the LITTLENUMs in REVERSE order in accord with i80960
     word-order.  (Dunno why atof_ieee doesn't do it in the right
     order in the first place -- probably because it's a hack of
     atof_m68k.)  */
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP--), LNUM_SIZE);
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
@


1.26
log
@remove some duplicate #include's.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2005, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.25
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2005
a65 2
#include <stdio.h>

@


1.24
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a125 8
#if !defined (BFD_ASSEMBLER) && !defined (BFD)
#ifdef OBJ_COFF
const int md_reloc_size = sizeof (struct reloc);
#else /* OBJ_COFF */
const int md_reloc_size = sizeof (struct relocation_info);
#endif /* OBJ_COFF */
#endif

a2044 6
#ifndef BFD_ASSEMBLER
void
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED,
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP)
#else
a2048 1
#endif
a2442 9
#ifndef BFD_ASSEMBLER
      /* For callx, we always want to write out zero, and emit a
	 symbolic relocation.  */
      if (fixP->fx_bsr)
	val = 0;

      fixP->fx_addnumber = val;
#endif

a2524 27
#if defined (OBJ_COFF) && defined (BFD)
short
tc_coff_fix2rtype (fixS *fixP)
{
  if (fixP->fx_bsr)
    abort ();

  if (fixP->fx_pcrel == 0 && fixP->fx_size == 4)
    return R_RELLONG;

  if (fixP->fx_pcrel != 0 && fixP->fx_size == 4)
    return R_IPRMED;

  abort ();
  return 0;
}

int
tc_coff_sizemachdep (fragS *frag)
{
  if (frag->fr_next)
    return frag->fr_next->fr_address - frag->fr_address;
  else
    return 0;
}
#endif

a2532 1
#ifdef BFD_ASSEMBLER
a2533 3
#else
  align = section_alignment[(int) seg];
#endif
a2538 123
#ifdef OBJ_COFF
void
tc_headers_hook (object_headers *headers)
{
  switch (architecture)
    {
    case ARCH_KA:
      coff_flags |= F_I960KA;
      break;

    case ARCH_KB:
      coff_flags |= F_I960KB;
      break;

    case ARCH_MC:
      coff_flags |= F_I960MC;
      break;

    case ARCH_CA:
      coff_flags |= F_I960CA;
      break;

    case ARCH_JX:
      coff_flags |= F_I960JX;
      break;

    case ARCH_HX:
      coff_flags |= F_I960HX;
      break;

    default:
      if (iclasses_seen == I_BASE)
	coff_flags |= F_I960CORE;
      else if (iclasses_seen & I_CX)
	coff_flags |= F_I960CA;
      else if (iclasses_seen & I_HX)
	coff_flags |= F_I960HX;
      else if (iclasses_seen & I_JX)
	coff_flags |= F_I960JX;
      else if (iclasses_seen & I_CX2)
	coff_flags |= F_I960CA;
      else if (iclasses_seen & I_MIL)
	coff_flags |= F_I960MC;
      else if (iclasses_seen & (I_DEC | I_FP))
	coff_flags |= F_I960KB;
      else
	coff_flags |= F_I960KA;
      break;
    }

  if (flag_readonly_data_in_text)
    {
      headers->filehdr.f_magic = I960RWMAGIC;
      headers->aouthdr.magic = OMAGIC;
    }
  else
    {
      headers->filehdr.f_magic = I960ROMAGIC;
      headers->aouthdr.magic = NMAGIC;
    }				/* set magic numbers */
}

#endif /* OBJ_COFF */

#ifndef BFD_ASSEMBLER

/* Things going on here:

   For bout, We need to assure a couple of simplifying
   assumptions about leafprocs for the linker: the leafproc
   entry symbols will be defined in the same assembly in
   which they're declared with the '.leafproc' directive;
   and if a leafproc has both 'call' and 'bal' entry points
   they are both global or both local.

   For coff, the call symbol has a second aux entry that
   contains the bal entry point.  The bal symbol becomes a
   label.

   For coff representation, the call symbol has a second aux entry that
   contains the bal entry point.  The bal symbol becomes a label.  */

void
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
{
  symbolS *symbolP;

  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
#ifdef OBJ_COFF
      if (TC_S_IS_SYSPROC (symbolP))
	{
	  /* Second aux entry already contains the sysproc number.  */
	  S_SET_NUMBER_AUXILIARY (symbolP, 2);
	  S_SET_STORAGE_CLASS (symbolP, C_SCALL);
	  S_SET_DATA_TYPE (symbolP, S_GET_DATA_TYPE (symbolP) | (DT_FCN << N_BTSHFT));
	  continue;
	}
#endif /* OBJ_COFF */

      if (!TC_S_IS_BALNAME (symbolP) && !TC_S_IS_CALLNAME (symbolP))
	continue;

      if (!S_IS_DEFINED (symbolP))
	as_bad (_("leafproc symbol '%s' undefined"), S_GET_NAME (symbolP));

      if (TC_S_IS_CALLNAME (symbolP))
	{
	  symbolS *balP = tc_get_bal_of_call (symbolP);

	  if (S_IS_EXTERNAL (symbolP) != S_IS_EXTERNAL (balP))
	    {
	      S_SET_EXTERNAL (symbolP);
	      S_SET_EXTERNAL (balP);
	      as_warn (_("Warning: making leafproc entries %s and %s both global\n"),
		       S_GET_NAME (symbolP), S_GET_NAME (balP));
	    }			/* externality mismatch */
	}			/* if callname */
    }				/* walk the symbol chain */
}

#endif /* ! BFD_ASSEMBLER */

a2665 2
#ifdef BFD_ASSEMBLER

a2717 2
#endif /* BFD_ASSEMBLER */

@


1.23
log
@Update the address and phone number of the FSF
@
text
@d2449 1
a2449 1
md_apply_fix3 (fixS *fixP,
@


1.22
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.21
log
@	* configure.in (AC_C_BIGENDIAN): Invoke.
	* configure: Regenerate.
	* write.c (write_object_file <!BFD_ASSEMBLER>): Don't use sizeof
	host variable to set string header size.
	* config/obj-aout.c (obj_header_append): Don't use host structs.
	(obj_symbol_to_chars): Likewise.
	(obj_emit_strings): Likewise.  Use the passed in output pointer.
	* config/obj-aout.h (H_GET_FILE_SIZE): Include H_GET_LINENO_SIZE.
	* config/obj-bout.c (obj_emit_relocations): Use md_reloc_size,
	not sizeof host struct.
	(obj_header_append, obj_symbol_to_chars): Don't use host structs.
	(obj_emit_strings): Likewise.
	* config/obj-bout.h (EXEC_BYTES_SIZE): Define.
	(N_TXTOFF, H_GET_FILE_SIZE, H_GET_HEADER_SIZE): Use instead of
	sizeof host struct.
	(H_SET_SYMBOL_TABLE_SIZE): Hard code sym size rather than using
	sizeof host struct.
	(host_number_to_chars): Define.
	* config/obj-hp300.c (hp300_header_append): Don't use sizeof
	host internal struct to set header sizes.
	* config/tc-i960.c (md_number_to_field): Warning fix.
	(md_ri_to_chars): Use host byte order.
	(get_cdisp, md_apply_fix3): Warning fix.
@
text
@d77 4
a80 4
#define TC_S_IS_SYSPROC(s)	((1<=S_GET_OTHER(s)) && (S_GET_OTHER(s)<=32))
#define TC_S_IS_BALNAME(s)	(S_GET_OTHER(s) == N_BALNAME)
#define TC_S_IS_CALLNAME(s)	(S_GET_OTHER(s) == N_CALLNAME)
#define TC_S_IS_BADPROC(s)	((S_GET_OTHER(s) != 0) && !TC_S_IS_CALLNAME(s) && !TC_S_IS_BALNAME(s) && !TC_S_IS_SYSPROC(s))
d82 2
a83 2
#define TC_S_SET_SYSPROC(s, p)	(S_SET_OTHER((s), (p)+1))
#define TC_S_GET_SYSPROC(s)	(S_GET_OTHER(s)-1)
d85 2
a86 2
#define TC_S_FORCE_TO_BALNAME(s)	(S_SET_OTHER((s), N_BALNAME))
#define TC_S_FORCE_TO_CALLNAME(s)	(S_SET_OTHER((s), N_CALLNAME))
d92 4
a95 4
#define TC_S_IS_SYSPROC(s)	(S_GET_STORAGE_CLASS(s) == C_SCALL)
#define TC_S_IS_BALNAME(s)	(SF_GET_BALNAME(s))
#define TC_S_IS_CALLNAME(s)	(SF_GET_CALLNAME(s))
#define TC_S_IS_BADPROC(s)	(TC_S_IS_SYSPROC(s) && TC_S_GET_SYSPROC(s) < 0 && 31 < TC_S_GET_SYSPROC(s))
d100 3
a102 3
#define TC_S_FORCE_TO_BALNAME(s)	(SF_SET_BALNAME(s))
#define TC_S_FORCE_TO_CALLNAME(s)	(SF_SET_CALLNAME(s))
#define TC_S_FORCE_TO_SYSPROC(s)	(S_SET_STORAGE_CLASS((s), C_SCALL))
d113 1
a113 1
#define TC_S_GET_SYSPROC(s) 0
d138 3
a140 54
/* Emit branch-prediction instrumentation code */
static void brcnt_emit PARAMS ((void));
/* Return next branch local label */
static char *brlab_next PARAMS ((void));
/* Generate COBR instruction */
static void cobr_fmt PARAMS ((char *[], long, struct i960_opcode *));
/* Generate CTRL instruction */
static void ctrl_fmt PARAMS ((char *, long, int));
/* Emit (internally) binary */
static char *emit PARAMS ((long));
/* Break arguments out of comma-separated list */
static int get_args PARAMS ((char *, char *[]));
/* Handle COBR or CTRL displacement */
static void get_cdisp PARAMS ((char *, char *, long, int, int, int));
/* Find index specification string */
static char *get_ispec PARAMS ((char *));
/* Translate text to register number */
static int get_regnum PARAMS ((char *));
/* Lexical scan of instruction source */
static int i_scan PARAMS ((char *, char *[]));
/* Generate MEMA or MEMB instruction */
static void mem_fmt PARAMS ((char *[], struct i960_opcode *, int));
/* Convert MEMA instruction to MEMB format */
static void mema_to_memb PARAMS ((char *));
/* Parse an expression */
static void parse_expr PARAMS ((char *, expressionS *));
/* Parse and replace a 'ldconst' pseudo-op */
static int parse_ldconst PARAMS ((char *[]));
/* Parse a memory operand */
static void parse_memop PARAMS ((struct memS *, char *, int));
/* Parse machine-dependent pseudo-op */
static void parse_po PARAMS ((int));
/* Parse a register operand */
static void parse_regop PARAMS ((struct regop *, char *, char));
/* Generate a REG format instruction */
static void reg_fmt PARAMS ((char *[], struct i960_opcode *));
/* "De-optimize" cobr into compare/branch */
static void relax_cobr PARAMS ((fragS *));
/* Process '.leafproc' pseudo-op */
static void s_leafproc PARAMS ((int, char *[]));
/* Process '.sysproc' pseudo-op */
static void s_sysproc PARAMS ((int, char *[]));
/* Will a 'shlo' substitute for a 'ldconst'? */
static int shift_ok PARAMS ((int));
/* Give syntax error */
static void syntax PARAMS ((void));
/* Target chip supports spec-func register? */
static int targ_has_sfr PARAMS ((int));
/* Target chip supports instruction set? */
static int targ_has_iclass PARAMS ((int));

/* See md_parse_option() for meanings of these options */
static char norelax;		/* True if -norelax switch seen */
static char instrument_branches;	/* True if -b switch seen */
d143 1
a143 2
   If the pre-processor is disabled, these aren't very useful.
 */
d152 1
a152 2
   #NO_APP at the beginning of its output.
 */
d156 1
a156 2
const char line_comment_chars[] = "#";

d159 1
a159 1
/* Chars that can be used to separate mant from exp in floating point nums */
d163 1
a163 2
   as in 0f12.456 or 0d1.2345e12
 */
d175 1
a175 2
   displacement won't hack it.
 */
d178 3
a180 3
  {0, 0, 0, 0},			/* State 0 => no more relaxation possible */
  {4088, -4096, 0, 2},		/* State 1: conditional branch (cobr) */
  {0x800000 - 8, -0x800000, 4, 0},	/* State 2: compare (reg) & branch (ctrl) */
a182 2
static void s_endian PARAMS ((int));

d189 1
a189 2
        integer arg to pass to the function
 */
d193 1
a193 15
const pseudo_typeS md_pseudo_table[] =
{
  {"bss", s_lcomm, 1},
  {"endian", s_endian, 0},
  {"extended", float_cons, 't'},
  {"leafproc", parse_po, S_LEAFPROC},
  {"sysproc", parse_po, S_SYSPROC},

  {"word", cons, 4},
  {"quad", cons, 16},

  {0, 0, 0}
};

/* Macros to extract info from an 'expressionS' structure 'e' */
d197 4
a200 4
/* Branch-prediction bits for CTRL/COBR format opcodes */
#define BP_MASK		0x00000002	/* Mask for branch-prediction bit */
#define BP_TAKEN	0x00000000	/* Value to OR in to predict branch */
#define BP_NOT_TAKEN	0x00000002	/* Value to OR in to predict no branch */
d202 1
a202 1
/* Some instruction opcodes that we need explicitly */
d231 1
a231 1
/* Info from which a MEMA or MEMB format instruction can be generated */
d234 1
a234 1
    /* (First) 32 bits of instruction */
d236 1
a236 1
    /* 0-(none), 12- or, 32-bit displacement needed */
d244 1
a244 1
/* The two pieces of info we need to generate a register operand */
d247 3
a249 3
    int mode;			/* 0 =>local/global/spec reg; 1=> literal or fp reg */
    int special;		/* 0 =>not a sfr;  1=> is a sfr (not valid w/mode=0) */
    int n;			/* Register number or literal value */
d350 4
a353 4
  {
    char *areg_name;
    int areg_num;
  }
d397 4
a400 4
/* Hash tables */
static struct hash_control *op_hash;	/* Opcode mnemonics */
static struct hash_control *reg_hash;	/* Register name hash table */
static struct hash_control *areg_hash;	/* Abase register hash table */
d402 2
a403 2
/* Architecture for which we are assembling */
#define ARCH_ANY	0	/* Default: no architecture checking done */
d410 1
a410 1
int architecture = ARCH_ANY;	/* Architecture requested on invocation line */
d412 2
a413 3
				 *    for which we've actually assembled
				 *      instructions.
				 */
d448 1
a448 2
            list of such tables.
 */
a464 3

/*****************************************************************************
   md_begin:  One-time initialization.
d466 1
a466 1
  	Set up hash tables.
d468 1
a468 1
  *************************************************************************** */
d470 1
a470 1
md_begin ()
d472 3
a474 3
  int i;			/* Loop counter */
  const struct i960_opcode *oP;	/* Pointer into opcode table */
  const char *retval;		/* Value returned by hash functions */
d485 1
a485 1
    retval = hash_insert (op_hash, oP->name, (PTR) oP);
d499 1
a499 2
/*****************************************************************************
   md_assemble:  Assemble an instruction
d501 3
a503 5
   Assumptions about the passed-in text:
  	- all comments, labels removed
  	- text is an instruction
  	- all white space compressed to single blanks
  	- all character constants have been replaced with decimal
d505 1
a505 9
  *************************************************************************** */
void
md_assemble (textP)
     char *textP;		/* Source text of instruction */
{
  /* Parsed instruction text, containing NO whitespace: arg[0]->opcode
     mnemonic arg[1-3]->operands, with char constants replaced by
     decimal numbers.  */
  char *args[4];
d507 2
a508 9
  int n_ops;			/* Number of instruction operands */
  /* Pointer to instruction description */
  struct i960_opcode *oP;
  /* TRUE iff opcode mnemonic included branch-prediction suffix (".f"
     or ".t").  */
  int branch_predict;
  /* Setting of branch-prediction bit(s) to be OR'd into instruction
     opcode of CTRL/COBR format instructions.  */
  long bp_bits;
d510 6
a515 1
  int n;			/* Offset of last character in opcode mnemonic */
d517 1
a517 1
  const char *bp_error_msg = _("branch prediction invalid on this opcode");
d519 1
a519 4
  /* Parse instruction into opcode and operands */
  memset (args, '\0', sizeof (args));
  n_ops = i_scan (textP, args);
  if (n_ops == -1)
d521 4
a524 1
      return;			/* Error message already issued */
d526 15
d542 1
a542 8
  /* Do "macro substitution" (sort of) on 'ldconst' pseudo-instruction */
  if (!strcmp (args[0], "ldconst"))
    {
      n_ops = parse_ldconst (args);
      if (n_ops == -1)
	{
	  return;
	}
d544 41
d586 1
a586 13
  /* Check for branch-prediction suffix on opcode mnemonic, strip it off */
  n = strlen (args[0]) - 1;
  branch_predict = 0;
  bp_bits = 0;
  if (args[0][n - 1] == '.' && (args[0][n] == 't' || args[0][n] == 'f'))
    {
      /* We could check here to see if the target architecture
	 supports branch prediction, but why bother?  The bit will
	 just be ignored by processors that don't use it.  */
      branch_predict = 1;
      bp_bits = (args[0][n] == 't') ? BP_TAKEN : BP_NOT_TAKEN;
      args[0][n - 1] = '\0';	/* Strip suffix from opcode mnemonic */
    }
d588 2
a589 5
  /* Look up opcode mnemonic in table and check number of operands.
     Check that opcode is legal for the target architecture.  If all
     looks good, assemble instruction.  */
  oP = (struct i960_opcode *) hash_find (op_hash, args[0]);
  if (!oP || !targ_has_iclass (oP->iclass))
d591 2
a592 1
      as_bad (_("invalid opcode, \"%s\"."), args[0]);
d594 3
a596 9
    }
  else if (n_ops != oP->num_ops)
    {
      as_bad (_("improper number of operands.  expecting %d, got %d"),
	      oP->num_ops, n_ops);
    }
  else
    {
      switch (oP->format)
d598 1
a598 4
	case FBRA:
	case CTRL:
	  ctrl_fmt (args[1], oP->opcode | bp_bits, oP->num_ops);
	  if (oP->format == FBRA)
d600 4
a603 2
	      /* Now generate a 'bno' to same arg */
	      ctrl_fmt (args[1], BNO | bp_bits, 1);
d605 1
a605 7
	  break;
	case COBR:
	case COJ:
	  cobr_fmt (args, oP->opcode | bp_bits, oP);
	  break;
	case REG:
	  if (branch_predict)
d607 18
a624 29
	      as_warn (bp_error_msg);
	    }
	  reg_fmt (args, oP);
	  break;
	case MEM1:
	  if (args[0][0] == 'c' && args[0][1] == 'a')
	    {
	      if (branch_predict)
		{
		  as_warn (bp_error_msg);
		}
	      mem_fmt (args, oP, 1);
	      break;
	    }
	case MEM2:
	case MEM4:
	case MEM8:
	case MEM12:
	case MEM16:
	  if (branch_predict)
	    {
	      as_warn (bp_error_msg);
	    }
	  mem_fmt (args, oP, 0);
	  break;
	case CALLJ:
	  if (branch_predict)
	    {
	      as_warn (bp_error_msg);
a625 8
	  /* Output opcode & set up "fixup" (relocation); flag
	     relocation as 'callj' type.  */
	  know (oP->num_ops == 1);
	  get_cdisp (args[1], "CTRL", oP->opcode, 24, 0, 1);
	  break;
	default:
	  BAD_CASE (oP->format);
	  break;
d627 7
a634 13
}				/* md_assemble() */

/*****************************************************************************
   md_number_to_chars:  convert a number to target byte order

  *************************************************************************** */
void
md_number_to_chars (buf, value, n)
     char *buf;
     valueT value;
     int n;
{
  number_to_chars_littleendian (buf, value, n);
a636 6
/*****************************************************************************
   md_chars_to_number:  convert from target byte order to host byte order.

  *************************************************************************** */
static int md_chars_to_number PARAMS ((char *, int));

d638 2
a639 3
md_chars_to_number (val, n)
     char *val;			/* Value in target byte order */
     int n;			/* Number of bytes in the input */
d651 5
a655 2
#define MAX_LITTLENUMS	6
#define LNUM_SIZE	sizeof (LITTLENUM_TYPE)
d657 1
a657 2
/*****************************************************************************
   md_atof:	convert ascii to floating point
d659 5
a663 4
   Turn a string at input_line_pointer into a floating point constant of type
   'type', and store the appropriate bytes at *litP.  The number of LITTLENUMS
   emitted is returned at 'sizeP'.  An error message is returned, or a pointer
   to an empty message if OK.
d665 2
a666 2
   Note we call the i386 floating point routine, rather than complicating
   things with more files or symbolic links.
d668 3
a670 11
  *************************************************************************** */
char *
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
{
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  int prec;
  char *t;
d672 2
a673 6
  switch (type)
    {
    case 'f':
    case 'F':
      prec = 2;
      break;
d675 2
a676 4
    case 'd':
    case 'D':
      prec = 4;
      break;
d678 1
a678 5
    case 't':
    case 'T':
      prec = 5;
      type = 'x';		/* That's what atof_ieee() understands */
      break;
d680 2
a681 4
    default:
      *sizeP = 0;
      return _("Bad call to md_atof()");
    }
d683 4
a686 2
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
d688 10
a697 1
      input_line_pointer = t;
d699 1
d701 2
a702 1
  *sizeP = prec * LNUM_SIZE;
d704 4
a707 4
  /* Output the LITTLENUMs in REVERSE order in accord with i80960
     word-order.  (Dunno why atof_ieee doesn't do it in the right
     order in the first place -- probably because it's a hack of
     atof_m68k.)  */
d709 2
a710 7
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP--), LNUM_SIZE);
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
d713 1
a713 5
/*****************************************************************************
   md_number_to_imm

  *************************************************************************** */
static void md_number_to_imm PARAMS ((char *, long, int));
d716 1
a716 4
md_number_to_imm (buf, val, n)
     char *buf;
     long val;
     int n;
d718 1
a718 1
  md_number_to_chars (buf, val, n);
d721 1
a721 2
/*****************************************************************************
   md_number_to_field:
d723 2
a724 5
  	Stick a value (an address fixup) into a bit field of
  	previously-generated instruction.

  *************************************************************************** */
static void md_number_to_field PARAMS ((char *, long, bit_fixS *));
d727 6
a732 8
md_number_to_field (instrP, val, bfixP)
     char *instrP;		/* Pointer to instruction to be fixed */
     long val;			/* Address fixup value */
     bit_fixS *bfixP;		/* Description of bit field to be fixed up */
{
  int numbits;			/* Length of bit field to be fixed */
  long instr;			/* 32-bit instruction to be fixed-up */
  long sign;			/* 0 or -1, according to sign bit of 'val' */
d734 3
a736 7
  /* Convert instruction back to host byte order.  */
  instr = md_chars_to_number (instrP, 4);

  /* Surprise! -- we stored the number of bits to be modified rather
     than a pointer to a structure.  */
  numbits = (int) (size_t) bfixP;
  if (numbits == 1)
d738 5
a742 3
      /* This is a no-op, stuck here by reloc_callj() */
      return;
    }
d744 21
a764 1
  know ((numbits == 13) || (numbits == 24));
d766 2
a767 8
  /* Propagate sign bit of 'val' for the given number of bits.  Result
     should be all 0 or all 1.  */
  sign = val >> ((int) numbits - 1);
  if (((val < 0) && (sign != -1))
      || ((val > 0) && (sign != 0)))
    {
      as_bad (_("Fixup of %ld too large for field width of %d"),
	      val, numbits);
d769 1
a769 1
  else
d771 11
a781 9
      /* Put bit field into instruction and write back in target
         * byte order.
       */
      val &= ~(-1 << (int) numbits);	/* Clear unused sign bits */
      instr |= val;
      md_number_to_chars (instrP, instr, 4);
    }
}				/* md_number_to_field() */

d783 5
a787 4
/*****************************************************************************
   md_parse_option
  	Invocation line includes a switch not recognized by the base assembler.
  	See if it's a processor-specific option.  For the 960, these are:
d789 20
a808 8
  	-norelax:
  		Conditional branch instructions that require displacements
  		greater than 13 bits (or that have external targets) should
  		generate errors.  The default is to replace each such
  		instruction with the corresponding compare (or chkbit) and
  		branch instructions.  Note that the Intel "j" cobr directives
  		are ALWAYS "de-optimized" in this way when necessary,
  		regardless of the setting of this option.
d810 6
a815 7
  	-b:
  		Add code to collect information about branches taken, for
  		later optimization of branch prediction bits by a separate
  		tool.  COBR and CNTL format instructions have branch
  		prediction bits (in the CX architecture);  if "BR" represents
  		an instruction in one of these classes, the following rep-
  		resents the code generated by the assembler:
d817 4
a820 5
  			call	<increment routine>
  			.word	0	# pre-counter
  		Label:  BR
  			call	<increment routine>
  			.word	0	# post-counter
d822 2
a823 1
  		A table of all such "Labels" is also generated.
d825 3
a827 11
  	-AKA, -AKB, -AKC, -ASA, -ASB, -AMC, -ACA:
  		Select the 80960 architecture.  Instructions or features not
  		supported by the selected architecture cause fatal errors.
  		The default is to generate code for any instruction or feature
  		that is supported by SOME version of the 960 (even if this
  		means mixing architectures!).

  ****************************************************************************/

const char *md_shortopts = "A:b";
struct option md_longopts[] =
d829 4
a832 9
#define OPTION_LINKRELAX (OPTION_MD_BASE)
  {"linkrelax", no_argument, NULL, OPTION_LINKRELAX},
  {"link-relax", no_argument, NULL, OPTION_LINKRELAX},
#define OPTION_NORELAX (OPTION_MD_BASE + 1)
  {"norelax", no_argument, NULL, OPTION_NORELAX},
  {"no-relax", no_argument, NULL, OPTION_NORELAX},
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);
d834 2
a835 18
struct tabentry
  {
    char *flag;
    int arch;
  };
static const struct tabentry arch_tab[] =
{
  {"KA", ARCH_KA},
  {"KB", ARCH_KB},
  {"SA", ARCH_KA},		/* Synonym for KA */
  {"SB", ARCH_KB},		/* Synonym for KB */
  {"KC", ARCH_MC},		/* Synonym for MC */
  {"MC", ARCH_MC},
  {"CA", ARCH_CA},
  {"JX", ARCH_JX},
  {"HX", ARCH_HX},
  {NULL, 0}
};
d837 1
a837 6
int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
d839 4
a842 4
    case OPTION_LINKRELAX:
      linkrelax = 1;
      flag_keep_locals = 1;
      break;
d844 13
a856 3
    case OPTION_NORELAX:
      norelax = 1;
      break;
d858 1
a858 3
    case 'b':
      instrument_branches = 1;
      break;
d860 2
a861 4
    case 'A':
      {
	const struct tabentry *tp;
	char *p = arg;
d863 4
a866 3
	for (tp = arch_tab; tp->flag != NULL; tp++)
	  if (!strcmp (p, tp->flag))
	    break;
d868 3
a870 9
	if (tp->flag == NULL)
	  {
	    as_bad (_("invalid architecture %s"), p);
	    return 0;
	  }
	else
	  architecture = tp->arch;
      }
      break;
d872 1
a872 3
    default:
      return 0;
    }
d874 2
a875 2
  return 1;
}
d877 2
a878 17
void
md_show_usage (stream)
     FILE *stream;
{
  int i;
  fprintf (stream, _("I960 options:\n"));
  for (i = 0; arch_tab[i].flag; i++)
    fprintf (stream, "%s-A%s", i ? " | " : "", arch_tab[i].flag);
  fprintf (stream, _("\n\
			specify variant of 960 architecture\n\
-b			add code to collect statistics about branches taken\n\
-link-relax		preserve individual alignment directives so linker\n\
			can do relaxing (b.out format only)\n\
-no-relax		don't alter compare-and-branch instructions for\n\
			long displacements\n"));
}

d880 2
a881 8
/*****************************************************************************
   md_convert_frag:
  	Called by base assembler after address relaxation is finished:  modify
  	variable fragments according to how much relaxation was done.

  	If the fragment substate is still 1, a 13-bit displacement was enough
  	to reach the symbol in question.  Set up an address fixup, but otherwise
  	leave the cobr instruction alone.
d883 3
a885 2
  	If the fragment substate is 2, a 13-bit displacement was not enough.
  	Replace the cobr with a two instructions (a compare and a branch).
d887 14
a900 16
  *************************************************************************** */
#ifndef BFD_ASSEMBLER
void
md_convert_frag (headers, seg, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP;
#else
void
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
#endif
{
  fixS *fixP;			/* Structure describing needed address fix */
d902 14
a915 11
  switch (fragP->fr_subtype)
    {
    case 1:
      /* LEAVE SINGLE COBR INSTRUCTION */
      fixP = fix_new (fragP,
		      fragP->fr_opcode - fragP->fr_literal,
		      4,
		      fragP->fr_symbol,
		      fragP->fr_offset,
		      1,
		      NO_RELOC);
d917 1
a917 11
      fixP->fx_bit_fixP = (bit_fixS *) 13;	/* size of bit field */
      break;
    case 2:
      /* REPLACE COBR WITH COMPARE/BRANCH INSTRUCTIONS */
      relax_cobr (fragP);
      break;
    default:
      BAD_CASE (fragP->fr_subtype);
      break;
    }
}
d919 3
a921 20
/*****************************************************************************
   md_estimate_size_before_relax:  How much does it look like *fragP will grow?

  	Called by base assembler just before address relaxation.
  	Return the amount by which the fragment will grow.

  	Any symbol that is now undefined will not become defined; cobr's
  	based on undefined symbols will have to be replaced with a compare
  	instruction and a branch instruction, and the code fragment will grow
  	by 4 bytes.

  *************************************************************************** */
int
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP;
     register segT segment_type;
{
  /* If symbol is undefined in this segment, go to "relaxed" state
     (compare and branch instructions instead of cobr) right now.  */
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment_type)
d923 2
a924 180
      relax_cobr (fragP);
      return 4;
    }

  return md_relax_table[fragP->fr_subtype].rlx_length;
}				/* md_estimate_size_before_relax() */

#if defined(OBJ_AOUT) | defined(OBJ_BOUT)

/*****************************************************************************
   md_ri_to_chars:
  	This routine exists in order to overcome machine byte-order problems
  	when dealing with bit-field entries in the relocation_info struct.

  	But relocation info will be used on the host machine only (only
  	executable code is actually downloaded to the i80960).  Therefore,
  	we leave it in host byte order.

  *************************************************************************** */
static void md_ri_to_chars PARAMS ((char *, struct relocation_info *));

static void
md_ri_to_chars (where, ri)
     char *where;
     struct relocation_info *ri;
{
  host_number_to_chars (where, ri->r_address, 4);
  host_number_to_chars (where + 4, ri->r_index, 3);
#if WORDS_BIGENDIAN
  where[7] = (ri->r_pcrel << 7
	      | ri->r_length << 5
	      | ri->r_extern << 4
	      | ri->r_bsr << 3
	      | ri->r_disp << 2
	      | ri->r_callj << 1
	      | ri->nuthin << 0);
#else
  where[7] = (ri->r_pcrel << 0
	      | ri->r_length << 1
	      | ri->r_extern << 3
	      | ri->r_bsr << 4
	      | ri->r_disp << 5
	      | ri->r_callj << 6
	      | ri->nuthin << 7);
#endif
}

#endif /* defined(OBJ_AOUT) | defined(OBJ_BOUT) */


/* FOLLOWING ARE THE LOCAL ROUTINES, IN ALPHABETICAL ORDER  */

/*****************************************************************************
   brcnt_emit:	Emit code to increment inline branch counter.

  	See the comments above the declaration of 'br_cnt' for details on
  	branch-prediction instrumentation.
  *************************************************************************** */
static void
brcnt_emit ()
{
  ctrl_fmt (BR_CNT_FUNC, CALL, 1);	/* Emit call to "increment" routine */
  emit (0);			/* Emit inline counter to be incremented */
}

/*****************************************************************************
   brlab_next:	generate the next branch local label

  	See the comments above the declaration of 'br_cnt' for details on
  	branch-prediction instrumentation.
  *************************************************************************** */
static char *
brlab_next ()
{
  static char buf[20];

  sprintf (buf, "%s%d", BR_LABEL_BASE, br_cnt++);
  return buf;
}

/*****************************************************************************
   brtab_emit:	generate the fetch-prediction branch table.

  	See the comments above the declaration of 'br_cnt' for details on
  	branch-prediction instrumentation.

  	The code emitted here would be functionally equivalent to the following
  	example assembler source.

  			.data
  			.align	2
  	   BR_TAB_NAME:
  			.word	0		# link to next table
  			.word	3		# length of table
  			.word	LBRANCH0	# 1st entry in table proper
  			.word	LBRANCH1
  			.word	LBRANCH2
  **************************************************************************** */
void
brtab_emit ()
{
  int i;
  char buf[20];
  char *p;			/* Where the binary was output to */
  /* Pointer to description of deferred address fixup.  */
  fixS *fixP;

  if (!instrument_branches)
    {
      return;
    }

  subseg_set (data_section, 0);	/*      .data */
  frag_align (2, 0, 0);		/*      .align 2 */
  record_alignment (now_seg, 2);
  colon (BR_TAB_NAME);		/* BR_TAB_NAME: */
  emit (0);			/*      .word 0 #link to next table */
  emit (br_cnt);		/*      .word n #length of table */

  for (i = 0; i < br_cnt; i++)
    {
      sprintf (buf, "%s%d", BR_LABEL_BASE, i);
      p = emit (0);
      fixP = fix_new (frag_now,
		      p - frag_now->fr_literal,
		      4,
		      symbol_find (buf),
		      0,
		      0,
		      NO_RELOC);
    }
}

/*****************************************************************************
   cobr_fmt:	generate a COBR-format instruction

  *************************************************************************** */
static void
cobr_fmt (arg, opcode, oP)
     /* arg[0]->opcode mnemonic, arg[1-3]->operands (ascii) */
     char *arg[];
     /* Opcode, with branch-prediction bits already set if necessary.  */
     long opcode;
     /* Pointer to description of instruction.  */
     struct i960_opcode *oP;
{
  long instr;			/* 32-bit instruction */
  struct regop regop;		/* Description of register operand */
  int n;			/* Number of operands */
  int var_frag;			/* 1 if varying length code fragment should
				 *    be emitted;  0 if an address fix
				 *      should be emitted.
				 */

  instr = opcode;
  n = oP->num_ops;

  if (n >= 1)
    {
      /* First operand (if any) of a COBR is always a register
	 operand.  Parse it.  */
      parse_regop (&regop, arg[1], oP->operand[0]);
      instr |= (regop.n << 19) | (regop.mode << 13);
    }
  if (n >= 2)
    {
      /* Second operand (if any) of a COBR is always a register
	 operand.  Parse it.  */
    parse_regop (&regop, arg[2], oP->operand[1]);
      instr |= (regop.n << 14) | regop.special;
    }

  if (n < 3)
    {
      emit (instr);

    }
  else
    {
      if (instrument_branches)
d926 7
a932 2
	  brcnt_emit ();
	  colon (brlab_next ());
d934 1
a934 10

      /* A third operand to a COBR is always a displacement.  Parse
         it; if it's relaxable (a cobr "j" directive, or any cobr
         other than bbs/bbc when the "-norelax" option is not in use)
         set up a variable code fragment; otherwise set up an address
         fix.  */
      var_frag = !norelax || (oP->format == COJ);	/* TRUE or FALSE */
      get_cdisp (arg[3], "COBR", instr, 13, var_frag, 0);

      if (instrument_branches)
d936 1
a936 4
	  brcnt_emit ();
	}
    }
}				/* cobr_fmt() */
d938 2
a939 2
/*****************************************************************************
   ctrl_fmt:	generate a CTRL-format instruction
d941 6
a946 25
  *************************************************************************** */
static void
ctrl_fmt (targP, opcode, num_ops)
     char *targP;		/* Pointer to text of lone operand (if any) */
     long opcode;		/* Template of instruction */
     int num_ops;		/* Number of operands */
{
  int instrument;		/* TRUE iff we should add instrumentation to track
				   * how often the branch is taken
				 */

  if (num_ops == 0)
    {
      emit (opcode);		/* Output opcode */
    }
  else
    {

      instrument = instrument_branches && (opcode != CALL)
	&& (opcode != B) && (opcode != RET) && (opcode != BAL);

      if (instrument)
	{
	  brcnt_emit ();
	  colon (brlab_next ());
d949 2
a950 6
      /* The operand MUST be an ip-relative displacement. Parse it
         * and set up address fix for the instruction we just output.
       */
      get_cdisp (targP, "CTRL", opcode, 24, 0, 0);

      if (instrument)
d952 2
a953 1
	  brcnt_emit ();
a954 1
    }
d956 2
a957 72
}

/*****************************************************************************
   emit:	output instruction binary

  	Output instruction binary, in target byte order, 4 bytes at a time.
  	Return pointer to where it was placed.

  *************************************************************************** */
static char *
emit (instr)
     long instr;		/* Word to be output, host byte order */
{
  char *toP;			/* Where to output it */

  toP = frag_more (4);		/* Allocate storage */
  md_number_to_chars (toP, instr, 4);	/* Convert to target byte order */
  return toP;
}

/*****************************************************************************
   get_args:	break individual arguments out of comma-separated list

   Input assumptions:
  	- all comments and labels have been removed
  	- all strings of whitespace have been collapsed to a single blank.
  	- all character constants ('x') have been replaced with decimal

   Output:
  	args[0] is untouched. args[1] points to first operand, etc. All args:
  	- are NULL-terminated
  	- contain no whitespace

   Return value:
  	Number of operands (0,1,2, or 3) or -1 on error.

  *************************************************************************** */
static int
get_args (p, args)
     /* Pointer to comma-separated operands; MUCKED BY US */
     register char *p;
     /* Output arg: pointers to operands placed in args[1-3].  MUST
        ACCOMMODATE 4 ENTRIES (args[0-3]).  */
     char *args[];
{
  register int n;		/* Number of operands */
  register char *to;

  /* Skip lead white space */
  while (*p == ' ')
    {
      p++;
    }

  if (*p == '\0')
    {
      return 0;
    }

  n = 1;
  args[1] = p;

  /* Squeze blanks out by moving non-blanks toward start of string.
     * Isolate operands, whenever comma is found.
   */
  to = p;
  while (*p != '\0')
    {

      if (*p == ' '
	  && (! ISALNUM (p[1])
	      || ! ISALNUM (p[-1])))
d959 19
a977 15
	  p++;

	}
      else if (*p == ',')
	{

	  /* Start of operand */
	  if (n == 3)
	    {
	      as_bad (_("too many operands"));
	      return -1;
	    }
	  *to++ = '\0';		/* Terminate argument */
	  args[++n] = to;	/* Start next argument */
	  p++;
d979 2
a980 5
	}
      else
	{
	  *to++ = *p++;
	}
a981 3
  *to = '\0';
  return n;
}
d983 2
a984 39
/*****************************************************************************
   get_cdisp:	handle displacement for a COBR or CTRL instruction.

  	Parse displacement for a COBR or CTRL instruction.

  	If successful, output the instruction opcode and set up for it,
  	depending on the arg 'var_frag', either:
  	    o an address fixup to be done when all symbol values are known, or
  	    o a varying length code fragment, with address fixup info.  This
  		will be done for cobr instructions that may have to be relaxed
  		in to compare/branch instructions (8 bytes) if the final
  		address displacement is greater than 13 bits.

  ****************************************************************************/
static void
get_cdisp (dispP, ifmtP, instr, numbits, var_frag, callj)
     /* displacement as specified in source instruction */
     char *dispP;
     /* "COBR" or "CTRL" (for use in error message) */
     char *ifmtP;
     /* Instruction needing the displacement */
     long instr;
     /* # bits of displacement (13 for COBR, 24 for CTRL) */
     int numbits;
     /* 1 if varying length code fragment should be emitted;
      *       0 if an address fix should be emitted.
      */
     int var_frag;
     /* 1 if callj relocation should be done; else 0 */
     int callj;
{
  expressionS e;		/* Parsed expression */
  fixS *fixP;			/* Structure describing needed address fix */
  char *outP;			/* Where instruction binary is output to */

  fixP = NULL;

  parse_expr (dispP, &e);
  switch (e.X_op)
d986 4
a989 6
    case O_illegal:
      as_bad (_("expression syntax error"));

    case O_symbol:
      if (S_GET_SEGMENT (e.X_add_symbol) == now_seg
	  || S_GET_SEGMENT (e.X_add_symbol) == undefined_section)
d991 6
a996 7
	  if (var_frag)
	    {
	      outP = frag_more (8);	/* Allocate worst-case storage */
	      md_number_to_chars (outP, instr, 4);
	      frag_variant (rs_machine_dependent, 4, 4, 1,
			    adds (e), offs (e), outP);
	    }
d999 2
a1000 20
	      /* Set up a new fix structure, so address can be updated
	       * when all symbol values are known.
	       */
	      outP = emit (instr);
	      fixP = fix_new (frag_now,
			      outP - frag_now->fr_literal,
			      4,
			      adds (e),
			      offs (e),
			      1,
			      NO_RELOC);

	      fixP->fx_tcbit = callj;

	      /* We want to modify a bit field when the address is
	       * known.  But we don't need all the garbage in the
	       * bit_fix structure.  So we're going to lie and store
	       * the number of bits affected instead of a pointer.
	       */
	      fixP->fx_bit_fixP = (bit_fixS *) (size_t) numbits;
a1002 7
      else
	as_bad (_("attempt to branch into different segment"));
      break;

    default:
      as_bad (_("target of %s instruction must be a label"), ifmtP);
      break;
a1003 1
}
d1005 4
a1008 2
/*****************************************************************************
   get_ispec:	parse a memory operand for an index specification
d1010 2
a1011 21
  	Here, an "index specification" is taken to be anything surrounded
  	by square brackets and NOT followed by anything else.

  	If it's found, detach it from the input string, remove the surrounding
  	square brackets, and return a pointer to it.  Otherwise, return NULL.

  *************************************************************************** */
static char *
get_ispec (textP)
     /* Pointer to memory operand from source instruction, no white space.  */
     char *textP;
{
  /* Points to start of index specification.  */
  char *start;
  /* Points to end of index specification.  */
  char *end;

  /* Find opening square bracket, if any.  */
  start = strchr (textP, '[');

  if (start != NULL)
d1013 2
a1014 11

      /* Eliminate '[', detach from rest of operand */
      *start++ = '\0';

      end = strchr (start, ']');

      if (end == NULL)
	{
	  as_bad (_("unmatched '['"));

	}
d1017 2
a1018 8
	  /* Eliminate ']' and make sure it was the last thing
	     * in the string.
	   */
	  *end = '\0';
	  if (*(end + 1) != '\0')
	    {
	      as_bad (_("garbage after index spec ignored"));
	    }
d1020 1
a1021 2
  return start;
}
d1023 11
a1033 2
/*****************************************************************************
   get_regnum:
d1035 5
a1039 2
  	Look up a (suspected) register name in the register table and return the
  	associated register number (or -1 if not found).
d1041 6
a1046 24
  *************************************************************************** */
static int
get_regnum (regname)
     char *regname;		/* Suspected register name */
{
  int *rP;

  rP = (int *) hash_find (reg_hash, regname);
  return (rP == NULL) ? -1 : *rP;
}

/*****************************************************************************
   i_scan:	perform lexical scan of ascii assembler instruction.

   Input assumptions:
  	- input string is an i80960 instruction (not a pseudo-op)
  	- all comments and labels have been removed
  	- all strings of whitespace have been collapsed to a single blank.

   Output:
  	args[0] points to opcode, other entries point to operands. All strings:
  	- are NULL-terminated
  	- contain no whitespace
  	- have character constants ('x') replaced with a decimal number
d1048 4
a1051 2
   Return value:
  	Number of operands (0,1,2, or 3) or -1 on error.
d1053 10
a1062 9
  *************************************************************************** */
static int
i_scan (iP, args)
     /* Pointer to ascii instruction;  MUCKED BY US.  */
     register char *iP;
     /* Output arg: pointers to opcode and operands placed here.  MUST
	ACCOMMODATE 4 ENTRIES.  */
     char *args[];
{
d1064 3
a1066 19
  /* Isolate opcode */
  if (*(iP) == ' ')
    {
      iP++;
    }				/* Skip lead space, if any */
  args[0] = iP;
  for (; *iP != ' '; iP++)
    {
      if (*iP == '\0')
	{
	  /* There are no operands */
	  if (args[0] == iP)
	    {
	      /* We never moved: there was no opcode either! */
	      as_bad (_("missing opcode"));
	      return -1;
	    }
	  return 0;
	}
d1068 1
a1068 3
  *iP++ = '\0';			/* Terminate opcode */
  return (get_args (iP, args));
}				/* i_scan() */
d1070 1
a1070 2
/*****************************************************************************
   mem_fmt:	generate a MEMA- or MEMB-format instruction
a1071 1
  *************************************************************************** */
d1073 11
a1083 12
mem_fmt (args, oP, callx)
     char *args[];		/* args[0]->opcode mnemonic, args[1-3]->operands */
     struct i960_opcode *oP;	/* Pointer to description of instruction */
     int callx;			/* Is this a callx opcode */
{
  int i;			/* Loop counter */
  struct regop regop;		/* Description of register operand */
  char opdesc;			/* Operand descriptor byte */
  memS instr;			/* Description of binary to be output */
  char *outP;			/* Where the binary was output to */
  expressionS expr;		/* Parsed expression */
  /* ->description of deferred address fixup */
d1100 1
a1100 3
	{
	  parse_memop (&instr, args[i], oP->format);
	}
d1112 1
a1112 1
  /* Output opcode */
d1116 1
a1116 3
    {
      return;
    }
d1118 1
a1118 1
  /* Process the displacement */
d1127 1
a1127 3
	{
	  (void) emit (offs (expr));	/* Output displacement */
	}
d1130 1
a1130 1
	  /* 12-bit displacement */
d1134 2
a1135 3
	       * instruction to MEMB format, output
	       * displacement.
	       */
d1142 1
a1142 2
	       * overwrite the binary we already put out
	       */
d1151 4
a1154 7
	{
	  /* Displacement is dependent on a symbol, whose value
	   * may change at link time.  We HAVE to reserve 32 bits.
	   * Convert already-output opcode to MEMB format.
	   */
	  mema_to_memb (outP);
	}
d1157 1
a1157 2
       * this symbol's value becomes known.
       */
d1161 1
a1161 4
			  4,
			  &expr,
			  0,
			  NO_RELOC);
d1168 96
a1263 1
}				/* memfmt() */
d1265 43
a1307 2
/*****************************************************************************
   mema_to_memb:	convert a MEMA-format opcode to a MEMB-format opcode.
d1309 7
a1315 3
   There are 2 possible MEMA formats:
  	- displacement only
  	- displacement + abase
d1317 1
a1317 1
   They are distinguished by the setting of the MEMA_ABASE bit.
a1318 1
  *************************************************************************** */
d1320 2
a1321 2
mema_to_memb (opcodeP)
     char *opcodeP;		/* Where to find the opcode, in target byte order */
d1323 29
a1351 2
  long opcode;			/* Opcode in host byte order */
  long mode;			/* Mode bits for MEMB instruction */
d1353 3
a1355 2
  opcode = md_chars_to_number (opcodeP, 4);
  know (!(opcode & MEMB_BIT));
d1357 19
a1375 2
  mode = MEMB_BIT | D_BIT;
  if (opcode & MEMA_ABASE)
d1377 4
a1380 1
      mode |= A_BIT;
d1382 17
d1400 15
a1414 2
  opcode &= 0xffffc000;		/* Clear MEMA offset and mode bits */
  opcode |= mode;		/* Set MEMB mode bits */
d1416 30
a1445 2
  md_number_to_chars (opcodeP, opcode, 4);
}				/* mema_to_memb() */
d1447 1
a1447 2
/*****************************************************************************
   parse_expr:		parse an expression
d1449 4
a1452 3
  	Use base assembler's expression parser to parse an expression.
  	It, unfortunately, runs off a global which we have to save/restore
  	in order to make it work for us.
d1454 5
a1458 1
  	An empty expression string is treated as an absolute 0.
d1460 2
a1461 2
  	Sets O_illegal regardless of expression evaluation if entire input
  	string is not consumed in the evaluation -- tolerate no dangling junk!
d1463 4
a1466 5
  *************************************************************************** */
static void
parse_expr (textP, expP)
     char *textP;		/* Text of expression to be parsed */
     expressionS *expP;		/* Where to put the results of parsing */
d1468 3
a1470 2
  char *save_in;		/* Save global here */
  symbolS *symP;
d1472 2
a1473 3
  know (textP);

  if (*textP == '\0')
d1475 1
a1475 12
      /* Treat empty string as absolute 0 */
      expP->X_add_symbol = expP->X_op_symbol = NULL;
      expP->X_add_number = 0;
      expP->X_op = O_constant;
    }
  else
    {
      save_in = input_line_pointer;	/* Save global */
      input_line_pointer = textP;	/* Make parser work for us */

      (void) expression (expP);
      if ((size_t) (input_line_pointer - textP) != strlen (textP))
d1477 8
a1484 9
	  /* Did not consume all of the input */
	  expP->X_op = O_illegal;
	}
      symP = expP->X_add_symbol;
      if (symP && (hash_find (reg_hash, S_GET_NAME (symP))))
	{
	  /* Register name in an expression */
	  /* FIXME: this isn't much of a check any more.  */
	  expP->X_op = O_illegal;
a1485 2

      input_line_pointer = save_in;	/* Restore global */
d1487 2
d1491 8
a1498 4
/*****************************************************************************
   parse_ldcont:
  	Parse and replace a 'ldconst' pseudo-instruction with an appropriate
  	i80960 instruction.
d1500 4
a1503 4
  	Assumes the input consists of:
  		arg[0]	opcode mnemonic ('ldconst')
  		arg[1]  first operand (constant)
  		arg[2]	name of register to be loaded
d1505 3
a1507 1
  	Replaces opcode and/or operands as appropriate.
d1509 4
a1512 6
  	Returns the new number of arguments, or -1 on failure.

  *************************************************************************** */
static int
parse_ldconst (arg)
     char *arg[];		/* See above */
d1514 2
a1515 5
  int n;			/* Constant to be loaded */
  int shift;			/* Shift count for "shlo" instruction */
  static char buf[5];		/* Literal for first operand */
  static char buf2[5];		/* Literal for second operand */
  expressionS e;		/* Parsed expression */
d1517 3
a1519 4
  arg[3] = NULL;		/* So we can tell at the end if it got used or not */

  parse_expr (arg[1], &e);
  switch (e.X_op)
d1521 2
a1522 4
    default:
      /* We're dependent on one or more symbols -- use "lda" */
      arg[0] = "lda";
      break;
d1524 1
a1524 15
    case O_constant:
      /* Try the following mappings:
       *      ldconst 0,<reg>  ->mov  0,<reg>
       *        ldconst 31,<reg> ->mov  31,<reg>
       *        ldconst 32,<reg> ->addo 1,31,<reg>
       *        ldconst 62,<reg> ->addo 31,31,<reg>
       *        ldconst 64,<reg> ->shlo 8,3,<reg>
       *        ldconst -1,<reg> ->subo 1,0,<reg>
       *        ldconst -31,<reg>->subo 31,0,<reg>
       *
       * anything else becomes:
       *        lda xxx,<reg>
       */
      n = offs (e);
      if ((0 <= n) && (n <= 31))
d1526 2
a1527 2
	  arg[0] = "mov";

a1528 7
      else if ((-31 <= n) && (n <= -1))
	{
	  arg[0] = "subo";
	  arg[3] = arg[2];
	  sprintf (buf, "%d", -n);
	  arg[1] = buf;
	  arg[2] = "0";
d1530 3
a1532 8
	}
      else if ((32 <= n) && (n <= 62))
	{
	  arg[0] = "addo";
	  arg[3] = arg[2];
	  arg[1] = "31";
	  sprintf (buf, "%d", n - 31);
	  arg[2] = buf;
d1534 2
a1535 21
	}
      else if ((shift = shift_ok (n)) != 0)
	{
	  arg[0] = "shlo";
	  arg[3] = arg[2];
	  sprintf (buf, "%d", shift);
	  arg[1] = buf;
	  sprintf (buf2, "%d", n >> shift);
	  arg[2] = buf2;

	}
      else
	{
	  arg[0] = "lda";
	}
      break;

    case O_illegal:
      as_bad (_("invalid constant"));
      return -1;
      break;
a1536 1
  return (arg[3] == 0) ? 2 : 3;
d1539 14
a1552 2
/*****************************************************************************
   parse_memop:	parse a memory operand
d1554 2
a1555 2
  	This routine is based on the observation that the 4 mode bits of the
  	MEMB format, taken individually, have fairly consistent meaning:
d1557 7
a1563 4
  		 M3 (bit 13): 1 if displacement is present (D_BIT)
  		 M2 (bit 12): 1 for MEMB instructions (MEMB_BIT)
  		 M1 (bit 11): 1 if index is present (I_BIT)
  		 M0 (bit 10): 1 if abase is present (A_BIT)
d1565 7
a1571 3
  	So we parse the memory operand and set bits in the mode as we find
  	things.  Then at the end, if we go to MEMB format, we need only set
  	the MEMB bit (M2) and our mode is built for us.
d1573 9
a1581 1
  	Unfortunately, I said "fairly consistent".  The exceptions:
d1583 7
a1589 2
  		 DBIA
  		 0100	Would seem illegal, but means "abase-only".
d1591 4
a1594 2
  		 0101	Would seem to mean "abase-only" -- it means IP-relative.
  			Must be converted to 0100.
d1596 5
a1600 2
  		 0110	Would seem to mean "index-only", but is reserved.
  			We turn on the D bit and provide a 0 displacement.
d1602 20
a1621 3
  	The other thing to observe is that we parse from the right, peeling
  	things * off as we go:  first any index spec, then any abase, then
  	the displacement.
d1623 2
a1624 16
  *************************************************************************** */
static void
parse_memop (memP, argP, optype)
     memS *memP;		/* Where to put the results */
     char *argP;		/* Text of the operand to be parsed */
     int optype;		/* MEM1, MEM2, MEM4, MEM8, MEM12, or MEM16 */
{
  char *indexP;			/* Pointer to index specification with "[]" removed */
  char *p;			/* Temp char pointer */
  char iprel_flag;		/* True if this is an IP-relative operand */
  int regnum;			/* Register number */
  /* Scale factor: 1,2,4,8, or 16.  Later converted to internal format
     (0,1,2,3,4 respectively).  */
  int scale;
  int mode;			/* MEMB mode bits */
  int *intP;			/* Pointer to register number */
d1626 1
a1626 14
  /* The following table contains the default scale factors for each
     type of memory instruction.  It is accessed using (optype-MEM1)
     as an index -- thus it assumes the 'optype' constants are
     assigned consecutive values, in the order they appear in this
     table.  */
  static const int def_scale[] =
  {
    1,				/* MEM1 */
    2,				/* MEM2 */
    4,				/* MEM4 */
    8,				/* MEM8 */
    -1,				/* MEM12 -- no valid default */
    16				/* MEM16 */
  };
d1628 2
a1629 1
  iprel_flag = mode = 0;
d1631 2
a1632 3
  /* Any index present? */
  indexP = get_ispec (argP);
  if (indexP)
d1634 4
a1637 14
      p = strchr (indexP, '*');
      if (p == NULL)
	{
	  /* No explicit scale -- use default for this instruction
	     type and assembler mode.  */
	  if (flag_mri)
	    scale = 1;
	  else
	    /* GNU960 compatibility */
	    scale = def_scale[optype - MEM1];
	}
      else
	{
	  *p++ = '\0';		/* Eliminate '*' */
d1639 4
a1642 3
	  /* Now indexP->a '\0'-terminated register name,
	     * and p->a scale factor.
	   */
d1644 9
a1652 20
	  if (!strcmp (p, "16"))
	    {
	      scale = 16;
	    }
	  else if (strchr ("1248", *p) && (p[1] == '\0'))
	    {
	      scale = *p - '0';
	    }
	  else
	    {
	      scale = -1;
	    }
	}

      regnum = get_regnum (indexP);	/* Get index reg. # */
      if (!IS_RG_REG (regnum))
	{
	  as_bad (_("invalid index register"));
	  return;
	}
d1654 12
a1665 2
      /* Convert scale to its binary encoding */
      switch (scale)
d1667 6
a1672 2
	case 1:
	  scale = 0 << 7;
d1674 3
a1676 2
	case 2:
	  scale = 1 << 7;
d1678 4
a1681 2
	case 4:
	  scale = 2 << 7;
d1683 16
a1698 2
	case 8:
	  scale = 3 << 7;
d1700 7
a1706 2
	case 16:
	  scale = 4 << 7;
d1709 16
a1724 3
	  as_bad (_("invalid scale factor"));
	  return;
	};
d1726 1
a1726 3
      memP->opcode |= scale | regnum;	/* Set index bits in opcode */
      mode |= I_BIT;		/* Found a valid index spec */
    }
d1728 4
a1731 23
  /* Any abase (Register Indirect) specification present? */
  if ((p = strrchr (argP, '(')) != NULL)
    {
      /* "(" is there -- does it start a legal abase spec?  If not, it
         could be part of a displacement expression.  */
      intP = (int *) hash_find (areg_hash, p);
      if (intP != NULL)
	{
	  /* Got an abase here */
	  regnum = *intP;
	  *p = '\0';		/* discard register spec */
	  if (regnum == IPREL)
	    {
	      /* We have to specialcase ip-rel mode */
	      iprel_flag = 1;
	    }
	  else
	    {
	      memP->opcode |= regnum << 14;
	      mode |= A_BIT;
	    }
	}
    }
d1733 2
a1734 6
  /* Any expression present? */
  memP->e = argP;
  if (*argP != '\0')
    {
      mode |= D_BIT;
    }
d1736 7
a1742 14
  /* Special-case ip-relative addressing */
  if (iprel_flag)
    {
      if (mode & I_BIT)
	{
	  syntax ();
	}
      else
	{
	  memP->opcode |= 5 << 10;	/* IP-relative mode */
	  memP->disp = 32;
	}
      return;
    }
d1744 1
a1744 2
  /* Handle all other modes */
  switch (mode)
d1746 3
a1748 7
    case D_BIT | A_BIT:
      /* Go with MEMA instruction format for now (grow to MEMB later
         if 12 bits is not enough for the displacement).  MEMA format
         has a single mode bit: set it to indicate that abase is
         present.  */
      memP->opcode |= MEMA_ABASE;
      memP->disp = 12;
d1751 3
a1753 4
    case D_BIT:
      /* Go with MEMA instruction format for now (grow to MEMB later
         if 12 bits is not enough for the displacement).  */
      memP->disp = 12;
d1756 4
a1759 5
    case A_BIT:
      /* For some reason, the bit string for this mode is not
         consistent: it should be 0 (exclusive of the MEMB bit), so we
         set it "by hand" here.  */
      memP->opcode |= MEMB_BIT;
d1762 8
a1769 4
    case A_BIT | I_BIT:
      /* set MEMB bit in mode, and OR in mode bits */
      memP->opcode |= mode | MEMB_BIT;
      break;
d1771 1
a1771 10
    case I_BIT:
      /* Treat missing displacement as displacement of 0.  */
      mode |= D_BIT;
      /* Fall into next case.  */
    case D_BIT | A_BIT | I_BIT:
    case D_BIT | I_BIT:
      /* set MEMB bit in mode, and OR in mode bits */
      memP->opcode |= mode | MEMB_BIT;
      memP->disp = 32;
      break;
d1773 8
a1780 3
    default:
      syntax ();
      break;
d1782 2
d1786 5
a1790 2
/*****************************************************************************
   parse_po:	parse machine-dependent pseudo-op
a1791 4
  	This is a top-level routine for machine-dependent pseudo-ops.  It slurps
  	up the rest of the input line, breaks out the individual arguments,
  	and dispatches them to the correct handler.
  *************************************************************************** */
d1793 17
a1809 9
parse_po (po_num)
     int po_num;		/* Pseudo-op number:  currently S_LEAFPROC or S_SYSPROC */
{
  /* Pointers operands, with no embedded whitespace.
     arg[0] unused, arg[1-3]->operands */
  char *args[4];
  int n_ops;			/* Number of operands */
  char *p;			/* Pointer to beginning of unparsed argument string */
  char eol;			/* Character that indicated end of line */
d1811 1
a1811 1
  extern char is_end_of_line[];
d1813 8
a1820 3
  /* Advance input pointer to end of line.  */
  p = input_line_pointer;
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
d1822 5
a1826 1
      input_line_pointer++;
d1828 23
a1850 2
  eol = *input_line_pointer;	/* Save end-of-line char */
  *input_line_pointer = '\0';	/* Terminate argument list */
d1852 5
a1856 6
  /* Parse out operands */
  n_ops = get_args (p, args);
  if (n_ops == -1)
    {
      return;
    }
d1858 1
a1858 13
  /* Dispatch to correct handler */
  switch (po_num)
    {
    case S_SYSPROC:
      s_sysproc (n_ops, args);
      break;
    case S_LEAFPROC:
      s_leafproc (n_ops, args);
      break;
    default:
      BAD_CASE (po_num);
      break;
    }
d1860 6
a1865 5
  /* Restore eol, so line numbers get updated correctly.  Base
     assembler assumes we leave input pointer pointing at char
     following the eol.  */
  *input_line_pointer++ = eol;
}
d1867 12
a1878 2
/*****************************************************************************
   parse_regop: parse a register operand.
d1880 6
a1885 8
  	In case of illegal operand, issue a message and return some valid
  	information so instruction processing can continue.
  *************************************************************************** */
static void
parse_regop (regopP, optext, opdesc)
     struct regop *regopP;	/* Where to put description of register operand */
     char *optext;		/* Text of operand */
     char opdesc;		/* Descriptor byte:  what's legal for this operand */
d1887 11
a1897 2
  int n;			/* Register number */
  expressionS e;		/* Parsed expression */
d1899 4
a1902 3
  /* See if operand is a register */
  n = get_regnum (optext);
  if (n >= 0)
d1904 4
a1907 47
      if (IS_RG_REG (n))
	{
	  /* global or local register */
	  if (!REG_ALIGN (opdesc, n))
	    {
	      as_bad (_("unaligned register"));
	    }
	  regopP->n = n;
	  regopP->mode = 0;
	  regopP->special = 0;
	  return;
	}
      else if (IS_FP_REG (n) && FP_OK (opdesc))
	{
	  /* Floating point register, and it's allowed */
	  regopP->n = n - FP0;
	  regopP->mode = 1;
	  regopP->special = 0;
	  return;
	}
      else if (IS_SF_REG (n) && SFR_OK (opdesc))
	{
	  /* Special-function register, and it's allowed */
	  regopP->n = n - SF0;
	  regopP->mode = 0;
	  regopP->special = 1;
	  if (!targ_has_sfr (regopP->n))
	    {
	      as_bad (_("no such sfr in this architecture"));
	    }
	  return;
	}
    }
  else if (LIT_OK (opdesc))
    {
      /* How about a literal?  */
      regopP->mode = 1;
      regopP->special = 0;
      if (FP_OK (opdesc))
	{			/* floating point literal acceptable */
	  /* Skip over 0f, 0d, or 0e prefix */
	  if ((optext[0] == '0')
	      && (optext[1] >= 'd')
	      && (optext[1] <= 'f'))
	    {
	      optext += 2;
	    }
d1909 3
a1911 10
	  if (!strcmp (optext, "0.0") || !strcmp (optext, "0"))
	    {
	      regopP->n = 0x10;
	      return;
	    }
	  if (!strcmp (optext, "1.0") || !strcmp (optext, "1"))
	    {
	      regopP->n = 0x16;
	      return;
	    }
d1913 3
a1915 14
	}
      else
	{			/* fixed point literal acceptable */
	  parse_expr (optext, &e);
	  if (e.X_op != O_constant
	      || (offs (e) < 0) || (offs (e) > 31))
	    {
	      as_bad (_("illegal literal"));
	      offs (e) = 0;
	    }
	  regopP->n = offs (e);
	  return;
	}
    }
d1917 4
a1920 6
  /* Nothing worked */
  syntax ();
  regopP->mode = 0;		/* Register r0 is always a good one */
  regopP->n = 0;
  regopP->special = 0;
}				/* parse_regop() */
d1922 3
a1924 2
/*****************************************************************************
   reg_fmt:	generate a REG-format instruction
d1926 9
a1934 9
  *************************************************************************** */
static void
reg_fmt (args, oP)
     char *args[];		/* args[0]->opcode mnemonic, args[1-3]->operands */
     struct i960_opcode *oP;	/* Pointer to description of instruction */
{
  long instr;			/* Binary to be output */
  struct regop regop;		/* Description of register operand */
  int n_ops;			/* Number of operands */
d1936 2
a1937 27
  instr = oP->opcode;
  n_ops = oP->num_ops;

  if (n_ops >= 1)
    {
      parse_regop (&regop, args[1], oP->operand[0]);

      if ((n_ops == 1) && !(instr & M3))
	{
	  /* 1-operand instruction in which the dst field should
	     * be used (instead of src1).
	   */
	  regop.n <<= 19;
	  if (regop.special)
	    {
	      regop.mode = regop.special;
	    }
	  regop.mode <<= 13;
	  regop.special = 0;
	}
      else
	{
	  /* regop.n goes in bit 0, needs no shifting */
	  regop.mode <<= 11;
	  regop.special <<= 5;
	}
      instr |= regop.n | regop.mode | regop.special;
d1940 1
a1940 35
  if (n_ops >= 2)
    {
      parse_regop (&regop, args[2], oP->operand[1]);

      if ((n_ops == 2) && !(instr & M3))
	{
	  /* 2-operand instruction in which the dst field should
	     * be used instead of src2).
	   */
	  regop.n <<= 19;
	  if (regop.special)
	    {
	      regop.mode = regop.special;
	    }
	  regop.mode <<= 13;
	  regop.special = 0;
	}
      else
	{
	  regop.n <<= 14;
	  regop.mode <<= 12;
	  regop.special <<= 6;
	}
      instr |= regop.n | regop.mode | regop.special;
    }
  if (n_ops == 3)
    {
      parse_regop (&regop, args[3], oP->operand[2]);
      if (regop.special)
	{
	  regop.mode = regop.special;
	}
      instr |= (regop.n <<= 19) | (regop.mode <<= 13);
    }
  emit (instr);
d1943 4
a1946 5
/*****************************************************************************
   relax_cobr:
  	Replace cobr instruction in a code fragment with equivalent branch and
  	compare instructions, so it can reach beyond a 13-bit displacement.
  	Set up an address fix/relocation for the new branch instruction.
d1948 16
a1963 1
  *************************************************************************** */
d1967 1
d1996 3
a1998 5
relax_cobr (fragP)
     register fragS *fragP;	/* fragP->fr_opcode is assumed to point to
				 * the cobr instruction, which comes at the
				 * end of the code fragment.
				 */
d2001 4
a2004 4
  /* Bit fields from cobr instruction */
  long bp_bits;			/* Branch prediction bits from cobr instruction */
  long instr;			/* A single i960 instruction */
  /* ->instruction to be replaced */
d2006 1
a2006 1
  fixS *fixP;			/* Relocation that can be done at assembly time */
d2008 1
a2008 1
  /* PICK UP & PARSE COBR INSTRUCTION */
d2011 1
a2011 1
  opcode = ((instr >> 24) & 0xff) - 0x30;	/* "-0x30" for table index */
d2018 1
a2018 1
  /* GENERATE AND OUTPUT COMPARE INSTRUCTION */
d2023 1
a2023 1
  /* OUTPUT BRANCH INSTRUCTION */
d2026 1
a2026 1
  /* SET UP ADDRESS FIXUP/RELOCATION */
d2032 85
a2116 2
		  1,
		  NO_RELOC);
d2118 7
a2124 1
  fixP->fx_bit_fixP = (bit_fixS *) 24;	/* Store size of bit field */
d2126 22
a2147 2
  fragP->fr_fix += 4;
  frag_wane (fragP);
d2150 1
a2150 2
/*****************************************************************************
   reloc_callj:	Relocate a 'callj' instruction
d2152 2
a2153 3
  	This is a "non-(GNU)-standard" machine-dependent hook.  The base
  	assembler calls it when it decides it can relocate an address at
  	assembly time instead of emitting a relocation directive.
d2155 2
a2156 4
  	Check to see if the relocation involves a 'callj' instruction to a:
  	    sysproc:	Replace the default 'call' instruction with a 'calls'
  	    leafproc:	Replace the default 'call' instruction with a 'bal'.
  	    other proc:	Do nothing.
d2158 2
a2159 1
  	See b.out.h for details on the 'n_other' field in a symbol structure.
d2161 8
a2168 4
   IMPORTANT!:
  	Assumes the caller has already figured out, in the case of a leafproc,
  	to use the 'bal' entry point, and has substituted that symbol into the
  	passed fixup structure.
d2170 2
a2171 5
  *************************************************************************** */
int
reloc_callj (fixP)
     /* Relocation that can be done at assembly time */
     fixS *fixP;
d2173 6
a2178 2
  /* Points to the binary for the instruction being relocated.  */
  char *where;
d2180 2
a2181 5
  if (!fixP->fx_tcbit)
    {
      /* This wasn't a callj instruction in the first place */
      return 0;
    }
d2183 6
a2188 1
  where = fixP->fx_frag->fr_literal + fixP->fx_where;
d2190 1
a2190 1
  if (TC_S_IS_SYSPROC (fixP->fx_addsy))
d2192 5
a2196 19
      /* Symbol is a .sysproc: replace 'call' with 'calls'.  System
         procedure number is (other-1).  */
      md_number_to_chars (where, CALLS | TC_S_GET_SYSPROC (fixP->fx_addsy), 4);

      /* Nothing else needs to be done for this instruction.  Make
         sure 'md_number_to_field()' will perform a no-op.  */
      fixP->fx_bit_fixP = (bit_fixS *) 1;
    }
  else if (TC_S_IS_CALLNAME (fixP->fx_addsy))
    {
      /* Should not happen: see block comment above */
      as_fatal (_("Trying to 'bal' to %s"), S_GET_NAME (fixP->fx_addsy));
    }
  else if (TC_S_IS_BALNAME (fixP->fx_addsy))
    {
      /* Replace 'call' with 'bal'; both instructions have the same
         format, so calling code should complete relocation as if
         nothing happened here.  */
      md_number_to_chars (where, BAL, 4);
a2197 7
  else if (TC_S_IS_BADPROC (fixP->fx_addsy))
    {
      as_bad (_("Looks like a proc, but can't tell what kind.\n"));
    }				/* switch on proc type */

  /* else Symbol is neither a sysproc nor a leafproc */
  return 0;
d2200 1
a2200 2
/*****************************************************************************
   s_leafproc:	process .leafproc pseudo-op
d2211 1
a2211 1
  	list of symbols.
a2212 1
  *************************************************************************** */
d2214 2
a2215 3
s_leafproc (n_ops, args)
     int n_ops;			/* Number of operands */
     char *args[];		/* args[1]->1st operand, args[2]->2nd operand */
d2217 2
a2218 2
  symbolS *callP;		/* Pointer to leafproc 'call' entry point symbol */
  symbolS *balP;		/* Pointer to leafproc 'bal' entry point symbol */
d2224 1
a2224 1
    }				/* Check number of arguments */
d2230 1
a2230 3
    {
      as_warn (_("Redefining leafproc %s"), S_GET_NAME (callP));
    }				/* is leafproc */
d2233 2
a2234 3
     * Otherwise, mark it as the 'call' entry point and find or create
     * another symbol for the 'bal' entry point.
   */
a2237 1

d2245 2
a2246 3
	{
	  as_warn (_("Redefining leafproc %s"), S_GET_NAME (balP));
	}
d2252 1
a2252 1
    }				/* if only one arg, or the args are the same */
d2255 1
a2255 2
/*
   s_sysproc: process .sysproc pseudo-op
d2257 8
a2264 4
        .sysproc takes two arguments:
                arg[1]: name of entry point to system procedure
                arg[2]: 'entry_num' (index) of system procedure in the range
                        [0,31] inclusive.
a2265 3
        For [ab].out, we store the 'entrynum' in the 'n_other' field of
        the symbol.  Since that entry is normally 0, we bias 'entrynum'
        by adding 1 to it.  It must be unbiased before it is used.  */
d2267 2
a2268 3
s_sysproc (n_ops, args)
     int n_ops;			/* Number of operands */
     char *args[];		/* args[1]->1st operand, args[2]->2nd operand */
d2277 1
a2277 1
    }				/* bad arg count */
d2289 1
a2289 1
  /* Find/make symbol and stick entry number (biased by +1) into it */
d2293 1
a2293 3
    {
      as_warn (_("Redefining entrynum for sysproc %s"), S_GET_NAME (symP));
    }				/* redefining */
d2295 1
a2295 1
  TC_S_SET_SYSPROC (symP, offs (exp));	/* encode entry number */
d2299 1
a2299 5
/*****************************************************************************
   shift_ok:
  	Determine if a "shlo" instruction can be used to implement a "ldconst".
  	This means that some number X < 32 can be shifted left to produce the
  	constant of interest.
d2301 3
a2303 2
  	Return the shift count, or 0 if we can't do it.
  	Caller calculates X by shifting original constant right 'shift' places.
d2305 2
a2306 4
  *************************************************************************** */
static int
shift_ok (n)
     int n;			/* The constant of interest */
d2308 16
a2323 1
  int shift;			/* The shift count */
d2325 4
a2328 5
  if (n <= 0)
    {
      /* Can't do it for negative numbers */
      return 0;
    }
d2330 2
a2331 2
  /* Shift 'n' right until a 1 is about to be lost */
  for (shift = 0; (n & 1) == 0; shift++)
d2333 9
a2341 1
      n >>= 1;
d2344 4
a2347 5
  if (n >= 32)
    {
      return 0;
    }
  return shift;
d2350 17
a2366 1
/* syntax: issue syntax error */
d2368 2
a2369 2
static void
syntax ()
d2371 6
a2376 2
  as_bad (_("syntax error"));
}				/* syntax() */
d2378 1
a2378 1
/* targ_has_sfr:
d2380 5
a2384 2
   Return TRUE iff the target architecture supports the specified
   special-function register (sfr).  */
d2386 5
a2390 5
static int
targ_has_sfr (n)
     int n;			/* Number (0-31) of sfr */
{
  switch (architecture)
d2392 2
a2393 10
    case ARCH_KA:
    case ARCH_KB:
    case ARCH_MC:
    case ARCH_JX:
      return 0;
    case ARCH_HX:
      return ((0 <= n) && (n <= 4));
    case ARCH_CA:
    default:
      return ((0 <= n) && (n <= 2));
d2395 1
a2395 15
}

/* targ_has_iclass:

   Return TRUE iff the target architecture supports the indicated
   class of instructions.  */
static int
targ_has_iclass (ic)
     /* Instruction class;  one of:
        I_BASE, I_CX, I_DEC, I_KX, I_FP, I_MIL, I_CASIM, I_CX2, I_HX, I_HX2
      */
     int ic;
{
  iclasses_seen |= ic;
  switch (architecture)
d2397 4
a2400 20
    case ARCH_KA:
      return ic & (I_BASE | I_KX);
    case ARCH_KB:
      return ic & (I_BASE | I_KX | I_FP | I_DEC);
    case ARCH_MC:
      return ic & (I_BASE | I_KX | I_FP | I_DEC | I_MIL);
    case ARCH_CA:
      return ic & (I_BASE | I_CX | I_CX2 | I_CASIM);
    case ARCH_JX:
      return ic & (I_BASE | I_CX2 | I_JX);
    case ARCH_HX:
      return ic & (I_BASE | I_CX2 | I_JX | I_HX);
    default:
      if ((iclasses_seen & (I_KX | I_FP | I_DEC | I_MIL))
	  && (iclasses_seen & (I_CX | I_CX2)))
	{
	  as_warn (_("architecture of opcode conflicts with that of earlier instruction(s)"));
	  iclasses_seen &= ~ic;
	}
      return 1;
d2402 5
d2412 1
a2412 2
s_endian (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2434 1
a2434 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d2443 1
a2443 2
md_pcrel_from (fixP)
     fixS *fixP;
d2449 3
a2451 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d2490 3
a2492 4
tc_bout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
d2551 1
a2551 2
tc_coff_fix2rtype (fixP)
     fixS *fixP;
d2567 1
a2567 2
tc_coff_sizemachdep (frag)
     fragS *frag;
d2577 1
d2579 2
a2580 3
md_section_align (seg, addr)
     segT seg;
     valueT addr;		/* Address to be rounded up */
d2583 1
d2596 1
a2596 2
tc_headers_hook (headers)
     object_headers *headers;
d2677 1
a2677 2
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d2686 1
a2686 1
	  /* second aux entry already contains the sysproc number */
d2691 1
a2691 1
	}			/* rewrite sysproc */
d2695 1
a2695 3
	{
	  continue;
	}			/* Not a leafproc symbol */
d2698 1
a2698 3
	{
	  as_bad (_("leafproc symbol '%s' undefined"), S_GET_NAME (symbolP));
	}			/* undefined leaf */
d2703 1
d2731 2
a2732 3
tc_set_bal_of_call (callP, balP)
     symbolS *callP ATTRIBUTE_UNUSED;
     symbolS *balP ATTRIBUTE_UNUSED;
d2746 1
a2746 2
     * symbol, unlink it from the symbol list and re-insert it.
   */
d2760 1
a2760 2
tc_get_bal_of_call (callP)
     symbolS *callP ATTRIBUTE_UNUSED;
d2778 1
a2778 1
}				/* _tc_get_bal_of_call() */
d2782 1
a2782 2
tc_coff_symbol_emit_hook (symbolP)
     symbolS *symbolP ATTRIBUTE_UNUSED;
d2794 1
a2794 1
      /* fix up the bal symbol */
d2796 1
a2796 1
    }				/* only on calls */
d2801 1
a2801 2
i960_handle_align (fragp)
     fragS *fragp ATTRIBUTE_UNUSED;
a2806 1

a2809 1

d2825 1
a2825 3
i960_validate_fix (fixP, this_segment_type)
     fixS *fixP;
     segT this_segment_type ATTRIBUTE_UNUSED;
a2830 1

a2847 2
static short tc_bfd_fix2rtype PARAMS ((fixS *));

d2849 1
a2849 2
tc_bfd_fix2rtype (fixP)
     fixS *fixP;
d2867 1
a2867 3
tc_gen_reloc (section, fixP)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixP;
d2871 1
a2871 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d2873 1
a2873 1
  /* HACK: Is this right? */
d2877 1
a2877 1
  if (reloc->howto == (reloc_howto_type *) NULL)
d2888 1
a2888 1
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d2900 13
a2912 1
/* end of tc-i960.c */
@


1.20
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d862 1
a862 1
  numbits = (int) bfixP;
a1118 3
  	The above comment is no longer true.  This routine now really
  	does do the reordering (Ian Taylor 28 Aug 92).

d1127 19
a1145 11
  md_number_to_chars (where, ri->r_address,
		      sizeof (ri->r_address));
  where[4] = ri->r_index & 0x0ff;
  where[5] = (ri->r_index >> 8) & 0x0ff;
  where[6] = (ri->r_index >> 16) & 0x0ff;
  where[7] = ((ri->r_pcrel << 0)
	      | (ri->r_length << 1)
	      | (ri->r_extern << 3)
	      | (ri->r_bsr << 4)
	      | (ri->r_disp << 5)
	      | (ri->r_callj << 6));
d1516 1
a1516 1
	      fixP->fx_bit_fixP = (bit_fixS *) numbits;
d2840 1
a2840 1
  else if ((int) fixP->fx_bit_fixP == 13
@


1.19
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003
d735 1
a735 1
static int md_chars_to_number PARAMS ((unsigned char *, int));
d739 1
a739 1
     unsigned char *val;	/* Value in target byte order */
d747 1
a747 1
      retval |= val[n];
@


1.18
log
@	* config/tc-hppa.c: Fix comment typos.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-iq2000.h: Likewise.
@
text
@a3164 4
#if 0
      /* second aux entry contains the bal entry point */
      S_SET_NUMBER_AUXILIARY (symbolP, 2);
#endif
a3236 5
#if 0
  if (fixP->fx_bsr)
    abort ();
#endif

@


1.17
log
@	* config/tc-i960.c (line_comment_chars): Add '#'.
	* config/tc-mn10200.c (tc_gen_reloc): Don't ignore fx_subsy.
@
text
@d180 1
a180 1
/* Will a 'shlo' substiture for a 'ldconst'? */
d1326 1
a1326 1
      /* The operand MUST be an ip-relative displacment. Parse it
d1891 1
a1891 1
       * anthing else becomes:
@


1.16
log
@	* config/tc-d30v.c (check_range): Warning fixes, formatting.
	Simplify sign extension.  Remove redundant unsigned < 0 test.
	* config/tc-i960.c (md_ri_to_chars): Prototype.
	* config/tc-mcore.c (md_pseudo_table): Fix typo.
	(dump_literals): Init brarsym, and test later instead of isforce.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002
d209 1
a209 1
const char line_comment_chars[] = "";
@


1.15
log
@	* config/tc-i960.c (md_convert_frag): Add ATTRIBUTE_UNUSED to args.
	(s_endian <ignore>): Likewise.
	(md_undefined_symbol <name>): Likewise.
	(tc_crawl_symbol_chain <headers>): Likewise.
	(tc_set_bal_of_call): Likewise.
	(tc_coff_symbol_emit_hook <symbolP>): Likewise.
	(i960_handle_align <fragp>): Likewise.
	(i960_validate_fix <this_segment_type>): Likewise
	(tc_gen_reloc <section>): Likewise.
	(tc_coff_symbol_emit_hook): Only define for OBJ_COFF.
	(struct memS, struct regop): Forward declare.
	(brcnt_emit, brlab_next, cobr_fmt, ctrl_fmt, emit, get_args,
	get_cdisp, get_ispec, get_regnum, i_scan, mem_fmt, mema_to_memb,
	parse_expr, parse_ldconst, parse_memop, parse_po, parse_regop,
	reg_fmt, relax_cobr, s_leafproc, s_sysproc, shift_ok, syntax,
	targ_has_sfr, targ_has_iclass, tc_bfd_fix2rtype): Prototype.
	(md_chars_to_number, md_number_to_imm): Make static, prototype.
	(md_number_to_field): Likewise.
	(md_number_to_disp): Remove unused function.
	(md_atof): Remove declaration of atof_ieee.
	(md_apply_fix3): Correct md_number_to_imm call.
@
text
@d1123 1
@


1.14
log
@gas reloc rewrite.
@
text
@d135 2
d138 50
a187 26
static void brcnt_emit ();	/* Emit branch-prediction instrumentation code */
static char *brlab_next ();	/* Return next branch local label */
void brtab_emit ();		/* Emit br-predict instrumentation table */
static void cobr_fmt ();	/* Generate COBR instruction */
static void ctrl_fmt ();	/* Generate CTRL instruction */
static char *emit ();		/* Emit (internally) binary */
static int get_args ();		/* Break arguments out of comma-separated list */
static void get_cdisp ();	/* Handle COBR or CTRL displacement */
static char *get_ispec ();	/* Find index specification string */
static int get_regnum ();	/* Translate text to register number */
static int i_scan ();		/* Lexical scan of instruction source */
static void mem_fmt ();		/* Generate MEMA or MEMB instruction */
static void mema_to_memb ();	/* Convert MEMA instruction to MEMB format */
static void parse_expr ();	/* Parse an expression */
static int parse_ldconst ();	/* Parse and replace a 'ldconst' pseudo-op */
static void parse_memop ();	/* Parse a memory operand */
static void parse_po ();	/* Parse machine-dependent pseudo-op */
static void parse_regop ();	/* Parse a register operand */
static void reg_fmt ();		/* Generate a REG format instruction */
static void relax_cobr ();	/* "De-optimize" cobr into compare/branch */
static void s_leafproc ();	/* Process '.leafproc' pseudo-op */
static void s_sysproc ();	/* Process '.sysproc' pseudo-op */
static int shift_ok ();		/* Will a 'shlo' substiture for a 'ldconst'? */
static void syntax ();		/* Give syntax error */
static int targ_has_sfr ();	/* Target chip supports spec-func register? */
static int targ_has_iclass ();	/* Target chip supports instruction set? */
d305 1
a305 1
typedef struct
a314 1

d735 3
a737 1
int
a776 1
  char *atof_ieee ();
d827 3
a829 1
void
a838 13
   md_number_to_disp

  *************************************************************************** */
void
md_number_to_disp (buf, val, n)
     char *buf;
     long val;
     int n;
{
  md_number_to_chars (buf, val, n);
}

/*****************************************************************************
d845 3
a847 1
void
d1043 2
a1044 2
     object_headers *headers;
     segT seg;
d1049 2
a1050 2
     bfd *abfd;
     segT sec;
d1232 1
a1232 2
static
void
d1299 1
a1299 2
static
void
d1345 1
a1345 2
static
char *
d1449 1
a1449 2
static
void
d1533 1
a1533 2
static
char *
d1581 1
a1581 2
static
int
d1860 1
a1860 2
static
int
d1972 1
a1972 2
static
void
d2176 1
a2176 2
static
void
d2231 1
a2231 2
static
void
d2441 1
a2441 2
static
void
d2676 1
a2676 2
static
int
d2714 1
a2714 2
static
int
d2737 1
a2737 2
static
int
d2774 1
a2774 1
     int ignore;
d2797 1
a2797 1
     char *name;
d2832 1
a2832 1
      md_number_to_imm (place, val, fixP->fx_size, fixP);
d3046 1
a3046 1
     object_headers *headers;
d3104 2
a3105 2
     symbolS *callP;
     symbolS *balP;
d3135 1
a3135 1
     symbolS *callP;
d3155 1
d3158 1
a3158 1
     symbolS *symbolP;
a3161 1
#ifdef OBJ_COFF
a3175 1
#endif /* OBJ_COFF */
d3178 1
d3182 1
a3182 1
     fragS *fragp;
d3210 1
a3210 1
     segT this_segment_type;
d3234 2
d3262 1
a3262 1
     asection *section;
@


1.13
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@a154 1
void reloc_callj ();		/* Relocate a 'callj' instruction */
d2503 1
a2503 1
void
d2514 1
a2514 1
      return;
a2527 1

d2547 1
d2812 1
a2812 1
     valueT * valP;
d2815 1
a2815 1
  long val = * (long *) valP;
d2831 12
d2846 1
a2846 1
  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
d3205 1
a3205 1
i960_validate_fix (fixP, this_segment_type, add_symbolPP)
a3207 1
     symbolS **add_symbolPP;
d3209 1
a3209 2
#define add_symbolP (*add_symbolPP)
  if (fixP->fx_tcbit && TC_S_IS_CALLNAME (add_symbolP))
d3214 1
a3214 1
      if (!TC_S_IS_BALNAME (tc_get_bal_of_call (add_symbolP)))
d3216 4
a3219 3
	  as_bad (_("No 'bal' entry point for leafproc %s"),
		  S_GET_NAME (add_symbolP));
	  return 1;
d3221 1
a3221 1
      fixP->fx_addsy = add_symbolP = tc_get_bal_of_call (add_symbolP);
d3223 2
a3224 22
#if 0
  /* Still have to work out other conditions for these tests.  */
  {
    if (fixP->fx_tcbit)
      {
	as_bad (_("callj to difference of two symbols"));
	return 1;
      }
    reloc_callj (fixP);
    if ((int) fixP->fx_bit_fixP == 13)
      {
	/* This is a COBR instruction.  They have only a 13-bit
	   displacement and are only to be used for local branches:
	   flag as error, don't generate relocation.  */
	as_bad (_("can't use COBR format with external label"));
	fixP->fx_addsy = NULL;	/* No relocations please.  */
	return 1;
      }
  }
#endif
#undef add_symbolP
  return 0;
@


1.12
log
@Fix i960-elf abort in cvt_frag_to_fill while compiling libc/stdio/vfprintf.c.
	* config/tc-i960.c (md_estimate_size_before_relax): Return size of
	current variable part of frag.
@
text
@d3 1
a3 1
   1999, 2000, 2001
d915 1
a915 1
CONST char *md_shortopts = "A:b";
@


1.11
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d1088 2
a1089 1
  return 0;
@


1.11.2.1
log
@Merge from mainline
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002
d1088 1
a1088 2

  return md_relax_table[fragP->fr_subtype].rlx_length;
@


1.10
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@a2808 6
#ifdef BFD_ASSEMBLER
int
md_apply_fix (fixP, valp)
     fixS *fixP;
     valueT *valp;
#else
d2810 1
a2810 1
md_apply_fix (fixP, val)
d2812 2
a2813 2
     long val;
#endif
d2815 1
a2815 3
#ifdef BFD_ASSEMBLER
  long val = *valp;
#endif
d2834 2
a2835 3
#ifdef BFD_ASSEMBLER
  return 0;
#endif
@


1.9
log
@Fix copyright notices
@
text
@a66 1
#include <ctype.h>
d70 1
d1392 2
a1393 2
	  && (! isalnum ((unsigned char) p[1])
	      || ! isalnum ((unsigned char) p[-1])))
@


1.8
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001
@


1.7
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@a2790 1
/* ARGSUSED */
@


1.6
log
@2000-09-11  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-i370.c: Fix formatting.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
@
text
@d726 1
a726 1
#define LNUM_SIZE	sizeof(LITTLENUM_TYPE)
@


1.5
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d22 1
a22 1
/* See comment on md_parse_option for 80960-specific invocation options. */
d181 1
a181 1
/* Also note that comments started like this one will always work. */
a194 1

a243 1

a248 1

d268 1
a268 2

/* These masks are used to build up a set of MEMB mode bits. */
a273 1

a291 1

a299 1

a444 1

a449 1

a463 1

a584 1

a602 2


a724 1

a796 1

a809 1

a904 1

a1249 1

a1277 1

a1292 1

a1321 1

a1340 1

a1419 1

a1508 1

a1578 1

d1599 1
a1599 1
     /* Pointer to ascii instruction;  MUCKED BY US. */
a1629 1

d1657 1
a1657 1
  /* Process operands. */
a1747 1

a1779 1

a1832 1

a1858 1

a1992 1

d2180 1
a2180 1
  /* Advance input pointer to end of line. */
a2329 1

a2395 1

a2481 1

a2548 1

d2578 1
a2578 1
  /* Find or create symbol for 'call' entry point. */
a2611 1

d2637 1
a2637 1
  /* Parse "entry_num" argument and check it for validity. */
a2658 1

a2694 1

a2702 1

a2727 1

d2789 1
a2789 1
/* We have no need to default values of symbols. */
d2801 1
a2801 1
   which we have set up as the address of the fixup too. */
d2903 1
a2903 1
  /* Output the relocation information in machine-dependent form. */
d3211 1
a3211 1
         entry point symbol. */
d3236 1
a3236 1
	fixP->fx_addsy = NULL;	/* No relocations please. */
@


1.4
log
@1999-06-11  Martin Dorey  <mdorey@@madge.com>
	* write.c (fixup_segment): Don't add symbol value for i960 ELF.
	* config/tc-i960.c (s_leafproc): Don't call tc_set_bal_of_cal if
	OBJ_ELF.
	(md_apply_fix): Simplify BFD_ASSEMBLER handling.
@
text
@d183 1
a183 1
const char line_comment_chars[1];
d185 1
a185 1
const char line_separator_chars[1];
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d2641 1
d2643 1
d2868 1
a2873 9
#ifdef OBJ_ELF
      /* For ELF, we always emit relocations for external or weak
         symbols.  */
      if (fixP->fx_addsy != NULL
	  && (S_IS_EXTERNAL (fixP->fx_addsy)
	      || S_IS_WEAK (fixP->fx_addsy)))
	val = 0;
#endif

a2874 13

#ifdef BFD_ASSEMBLER
      /* HACK: With REL relocations this causes the offset in the code
         to be doubled.

	 Guess: val is the old offset in the code, addnumber gets
	 passed back to md_gen_reloc() where it gets assigned to
	 addend, which the backend then writes back to the code (as
	 we're using REL, not RELA relocations).  COFF must be working
	 without this hack, but I don't see how or why.

	 apeppere and martindo 22-10-1998.  */
      fixP->fx_addnumber = 0;
@


1.2
log
@1999-05-28  Martin Dorey  <mdorey@@madge.com>
	* config/tc-i960.c: Several minor changes to add ELF and
	BFD_ASSEMBLER support.
	* config/tc-i960.h: Likewise.
	* configure.in (i960-*-elf*): New target.
	* aclocal.m4, configure: Rebuild.
@
text
@d3356 2
a3357 1
  reloc->sym_ptr_ptr = &fixP->fx_addsy->bsym;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 1998
d104 16
a119 1
you lose;
a1026 1
#ifndef BFD_ASSEMBLER
d1040 1
d1046 7
d1107 1
d1122 2
a1123 1
void
d1141 2
a1142 1
#endif /* BFD_ASSEMBLER */
d2847 6
d2857 1
d2859 3
d2871 9
d2881 15
d2900 4
d3003 8
a3010 2
  return ((addr + (1 << section_alignment[(int) seg]) - 1) & (-1 << section_alignment[(int) seg]));
}				/* md_section_align() */
d3079 2
d3140 2
d3181 1
a3181 1
  (as yet unwritten.);
d3200 1
a3200 1
  (as yet unwritten.);
d3303 63
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

