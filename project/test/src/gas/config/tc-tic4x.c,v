head	1.35;
access;
symbols
	binutils-2_24-branch:1.35.0.2
	binutils-2_24-branchpoint:1.35
	binutils-2_21_1:1.32
	binutils-2_23_2:1.34
	binutils-2_23_1:1.34
	binutils-2_23:1.34
	binutils-2_23-branch:1.34.0.2
	binutils-2_23-branchpoint:1.34
	binutils-2_22_branch:1.32.0.6
	binutils-2_22:1.32
	binutils-2_22-branch:1.32.0.4
	binutils-2_22-branchpoint:1.32
	binutils-2_21:1.32
	binutils-2_21-branch:1.32.0.2
	binutils-2_21-branchpoint:1.32
	binutils-2_20_1:1.30
	binutils-2_20:1.30
	binutils-arc-20081103-branch:1.27.0.6
	binutils-arc-20081103-branchpoint:1.27
	binutils-2_20-branch:1.30.0.2
	binutils-2_20-branchpoint:1.30
	dje-cgen-play1-branch:1.27.0.4
	dje-cgen-play1-branchpoint:1.27
	arc-20081103-branch:1.27.0.2
	arc-20081103-branchpoint:1.27
	binutils-2_19_1:1.26
	binutils-2_19:1.26
	binutils-2_19-branch:1.26.0.2
	binutils-2_19-branchpoint:1.26
	binutils-2_18:1.22
	binutils-2_18-branch:1.22.0.2
	binutils-2_18-branchpoint:1.22
	binutils-csl-coldfire-4_1-32:1.19
	binutils-csl-sourcerygxx-4_1-32:1.19
	binutils-csl-innovasic-fido-3_4_4-33:1.19
	binutils-csl-sourcerygxx-3_4_4-32:1.15
	binutils-csl-coldfire-4_1-30:1.19
	binutils-csl-sourcerygxx-4_1-30:1.19
	binutils-csl-coldfire-4_1-28:1.19
	binutils-csl-sourcerygxx-4_1-29:1.19
	binutils-csl-sourcerygxx-4_1-28:1.19
	binutils-csl-arm-2006q3-27:1.19
	binutils-csl-sourcerygxx-4_1-27:1.19
	binutils-csl-arm-2006q3-26:1.19
	binutils-csl-sourcerygxx-4_1-26:1.19
	binutils-csl-sourcerygxx-4_1-25:1.19
	binutils-csl-sourcerygxx-4_1-24:1.19
	binutils-csl-sourcerygxx-4_1-23:1.19
	binutils-csl-sourcerygxx-4_1-21:1.19
	binutils-csl-arm-2006q3-21:1.19
	binutils-csl-sourcerygxx-4_1-22:1.19
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.19
	binutils-csl-sourcerygxx-4_1-20:1.19
	binutils-csl-arm-2006q3-19:1.19
	binutils-csl-sourcerygxx-4_1-19:1.19
	binutils-csl-sourcerygxx-4_1-18:1.19
	binutils-csl-renesas-4_1-9:1.19
	binutils-csl-sourcerygxx-3_4_4-25:1.15
	binutils-csl-renesas-4_1-8:1.19
	binutils-csl-renesas-4_1-7:1.19
	binutils-csl-renesas-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-15:1.19
	binutils-csl-sourcerygxx-4_1-13:1.19
	binutils-2_17:1.19
	binutils-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-wrs-linux-3_4_4-24:1.15
	binutils-csl-wrs-linux-3_4_4-23:1.15
	binutils-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-arm-2006q1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-wrs-linux-3_4_4-22:1.15
	binutils-csl-coldfire-4_1-11:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-coldfire-4_1-10:1.19
	binutils-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-wrs-linux-3_4_4-21:1.15
	binutils-csl-morpho-4_1-4:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-wrs-linux-3_4_4-20:1.15
	binutils-2_17-branch:1.19.0.4
	binutils-2_17-branchpoint:1.19
	binutils-csl-2_17-branch:1.19.0.2
	binutils-csl-2_17-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.15.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.15
	binutils-2_16_1:1.15
	binutils-csl-arm-2005q1b:1.15
	binutils-2_16:1.15
	binutils-csl-arm-2005q1a:1.15
	binutils-csl-arm-2005q1-branch:1.15.0.4
	binutils-csl-arm-2005q1-branchpoint:1.15
	binutils-2_16-branch:1.15.0.2
	binutils-2_16-branchpoint:1.15
	csl-arm-2004-q3d:1.12
	csl-arm-2004-q3:1.12
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	binutils-2_15-branch:1.12.0.6
	cagney_bfdfile-20040213-branch:1.12.0.4
	cagney_bfdfile-20040213-branchpoint:1.12
	cagney_bigcore-20040122-branch:1.12.0.2
	cagney_bigcore-20040122-branchpoint:1.12
	csl-arm-2003-q4:1.12
	binutils-2_14:1.7.2.1
	binutils-2_14-branch:1.7.0.2
	binutils-2_14-branchpoint:1.7
	binutils_latest_snapshot:1.35;
locks; strict;
comment	@ * @;


1.35
date	2012.11.06.05.51.18;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2012.05.17.15.13.16;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2012.02.27.06.52.20;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.06.17.38.02;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.24.11.45.01;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.30.10.50.02;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.14.14.54.40;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.12.23.39.31;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2008.02.12.08.37.08;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.30.15.48.24;	author jbeulich;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.05.09.13.03;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.27.18.44.55;	author sveinse;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.23.12.28.06;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.17.13.46.05;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.22.15.32.28;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.20.03.11.18;	author kazu;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.14.10.06.06;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.18.22.52.35;	author sveinse;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.18.22.23.15;	author sveinse;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.04.08.15.14;	author sveinse;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2002.11.25.09.01.30;	author sveinse;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.18.09.09.30;	author sveinse;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.16.12.23.21;	author sveinse;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.11.14.29.01;	author sveinse;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.17.08.35.10;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.28.10.38.48;	author nickc;	state Exp;
branches;
next	;

1.7.2.1
date	2003.05.18.22.58.37;	author sveinse;	state Exp;
branches;
next	;


desc
@@


1.35
log
@bfd/
	* coff-tic4x.c (tic4x_coff0_vec, tic4x_coff0_beh_vec,
	tic4x_coff1_vec, tic4x_coff1_beh_vec, tic4x_coff2_vec,
	tic4x_coff2_beh_vec): Allow SEC_CODE and SEC_READONLY in
	section flags.
gas/
	* config/tc-tic4x.c: Remove alignment TODO comments.
	(tic4x_do_align): Enable subseg_text_p test.
@
text
@/* tc-tic4x.c -- Assemble for the Texas Instruments TMS320C[34]x.
   Copyright (C) 1997,1998, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010,
   2012 Free Software Foundation. Inc.

   Contributed by Michael P. Hayes (m.hayes@@elec.canterbury.ac.nz)

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor, 
   Boston, MA 02110-1301, USA.  */
/*
  TODOs:
  ------
  
  o .align cannot handle fill-data-width larger than 0xFF/8-bits. It
    should be possible to define a 32-bits pattern.

  o .align: Implement a 'bu' insn if the number of nop's exceeds 4
    within the align frag. if(fragsize>4words) insert bu fragend+1
    first.

  o .usect if has symbol on previous line not implemented

  o .sym, .eos, .stag, .etag, .member not implemented

  o Evaluation of constant floating point expressions (expr.c needs
    work!)

  o Support 'abc' constants (that is 0x616263).  */

#include "as.h"
#include "safe-ctype.h"
#include "opcode/tic4x.h"
#include "subsegs.h"
#include "obstack.h"

/* OK, we accept a syntax similar to the other well known C30
   assembly tools.  With TIC4X_ALT_SYNTAX defined we are more
   flexible, allowing a more Unix-like syntax:  `%' in front of
   register names, `#' in front of immediate constants, and
   not requiring `@@' in front of direct addresses.  */

#define TIC4X_ALT_SYNTAX

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6	/* (12 bytes) */

/* Handle of the inst mnemonic hash table.  */
static struct hash_control *tic4x_op_hash = NULL;

/* Handle asg pseudo.  */
static struct hash_control *tic4x_asg_hash = NULL;

static unsigned int tic4x_cpu = 0;        /* Default to TMS320C40.  */
static unsigned int tic4x_revision = 0;   /* CPU revision */
static unsigned int tic4x_idle2 = 0;      /* Idle2 support */
static unsigned int tic4x_lowpower = 0;   /* Lowpower support */
static unsigned int tic4x_enhanced = 0;   /* Enhanced opcode support */
static unsigned int tic4x_big_model = 0;  /* Default to small memory model.  */
static unsigned int tic4x_reg_args = 0;   /* Default to args passed on stack.  */
static unsigned long tic4x_oplevel = 0;   /* Opcode level */

#define OPTION_CPU      'm'
#define OPTION_BIG      (OPTION_MD_BASE + 1)
#define OPTION_SMALL    (OPTION_MD_BASE + 2)
#define OPTION_MEMPARM  (OPTION_MD_BASE + 3)
#define OPTION_REGPARM  (OPTION_MD_BASE + 4)
#define OPTION_IDLE2    (OPTION_MD_BASE + 5)
#define OPTION_LOWPOWER (OPTION_MD_BASE + 6)
#define OPTION_ENHANCED (OPTION_MD_BASE + 7)
#define OPTION_REV      (OPTION_MD_BASE + 8)

CONST char *md_shortopts = "bm:prs";
struct option md_longopts[] =
{
  { "mcpu",   required_argument, NULL, OPTION_CPU },
  { "mdsp",   required_argument, NULL, OPTION_CPU },
  { "mbig",         no_argument, NULL, OPTION_BIG },
  { "msmall",       no_argument, NULL, OPTION_SMALL },
  { "mmemparm",     no_argument, NULL, OPTION_MEMPARM },
  { "mregparm",     no_argument, NULL, OPTION_REGPARM },
  { "midle2",       no_argument, NULL, OPTION_IDLE2 },
  { "mlowpower",    no_argument, NULL, OPTION_LOWPOWER },
  { "menhanced",    no_argument, NULL, OPTION_ENHANCED },
  { "mrev",   required_argument, NULL, OPTION_REV },
  { NULL, no_argument, NULL, 0 }
};

size_t md_longopts_size = sizeof (md_longopts);


typedef enum
  {
    M_UNKNOWN, M_IMMED, M_DIRECT, M_REGISTER, M_INDIRECT,
    M_IMMED_F, M_PARALLEL, M_HI
  }
tic4x_addr_mode_t;

typedef struct tic4x_operand
  {
    tic4x_addr_mode_t mode;	/* Addressing mode.  */
    expressionS expr;		/* Expression.  */
    int disp;			/* Displacement for indirect addressing.  */
    int aregno;			/* Aux. register number.  */
    LITTLENUM_TYPE fwords[MAX_LITTLENUMS];	/* Float immed. number.  */
  }
tic4x_operand_t;

typedef struct tic4x_insn
  {
    char name[TIC4X_NAME_MAX];	/* Mnemonic of instruction.  */
    unsigned int in_use;	/* True if in_use.  */
    unsigned int parallel;	/* True if parallel instruction.  */
    unsigned int nchars;	/* This is always 4 for the C30.  */
    unsigned long opcode;	/* Opcode number.  */
    expressionS exp;		/* Expression required for relocation.  */
    int reloc;			/* Relocation type required.  */
    int pcrel;			/* True if relocation PC relative.  */
    char *pname;		/* Name of instruction in parallel.  */
    unsigned int num_operands;	/* Number of operands in total.  */
    tic4x_inst_t *inst;		/* Pointer to first template.  */
    tic4x_operand_t operands[TIC4X_OPERANDS_MAX];
  }
tic4x_insn_t;

static tic4x_insn_t the_insn;	/* Info about our instruction.  */
static tic4x_insn_t *insn = &the_insn;

static void tic4x_asg (int);
static void tic4x_bss (int);
static void tic4x_globl (int);
static void tic4x_cons (int);
static void tic4x_stringer (int);
static void tic4x_eval (int);
static void tic4x_newblock (int);
static void tic4x_sect (int);
static void tic4x_set (int);
static void tic4x_usect (int);
static void tic4x_version (int);


const pseudo_typeS
  md_pseudo_table[] =
{
  {"align", s_align_bytes, 32},
  {"ascii", tic4x_stringer, 1},
  {"asciz", tic4x_stringer, 0},
  {"asg", tic4x_asg, 0},
  {"block", s_space, 4},
  {"byte", tic4x_cons, 1},
  {"bss", tic4x_bss, 0},
  {"copy", s_include, 0},
  {"def", tic4x_globl, 0},
  {"equ", tic4x_set, 0},
  {"eval", tic4x_eval, 0},
  {"global", tic4x_globl, 0},
  {"globl", tic4x_globl, 0},
  {"hword", tic4x_cons, 2},
  {"ieee", float_cons, 'i'},
  {"int", tic4x_cons, 4},		 /* .int allocates 4 bytes.  */
  {"ldouble", float_cons, 'e'},
  {"newblock", tic4x_newblock, 0},
  {"ref", s_ignore, 0},	         /* All undefined treated as external.  */
  {"set", tic4x_set, 0},
  {"sect", tic4x_sect, 1},	 /* Define named section.  */
  {"space", s_space, 4},
  {"string", tic4x_stringer, 0},
  {"usect", tic4x_usect, 0},       /* Reserve space in uninit. named sect.  */
  {"version", tic4x_version, 0},
  {"word", tic4x_cons, 4},	 /* .word allocates 4 bytes.  */
  {"xdef", tic4x_globl, 0},
  {NULL, 0, 0},
};

int md_short_jump_size = 4;
int md_long_jump_size = 4;

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
#ifdef TIC4X_ALT_SYNTAX
const char comment_chars[] = ";!";
#else
const char comment_chars[] = ";";
#endif

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output. 
   Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output. 
   Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#*";

/* We needed an unused char for line separation to work around the
   lack of macros, using sed and such.  */
const char line_separator_chars[] = "&";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
const char FLT_CHARS[] = "fFilsS";

/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c.  Ideally it shouldn't have to know about it at
   all, but nothing is ideal around here.  */

/* Flonums returned here.  */
extern FLONUM_TYPE generic_floating_point_number;

/* Precision in LittleNums.  */
#define MAX_PRECISION (4)       /* Its a bit overkill for us, but the code
                                   requires it... */
#define S_PRECISION (1)		/* Short float constants 16-bit.  */
#define F_PRECISION (2)		/* Float and double types 32-bit.  */
#define E_PRECISION (4)         /* Extended precision, 64-bit (real 40-bit). */
#define GUARD (2)

/* Turn generic_floating_point_number into a real short/float/double.  */
static int
tic4x_gen_to_words (FLONUM_TYPE flonum, LITTLENUM_TYPE *words, int precision)
{
  int return_value = 0;
  LITTLENUM_TYPE *p;		/* Littlenum pointer.  */
  int mantissa_bits;		/* Bits in mantissa field.  */
  int exponent_bits;		/* Bits in exponent field.  */
  int exponent;
  unsigned int sone;		/* Scaled one.  */
  unsigned int sfract;		/* Scaled fraction.  */
  unsigned int smant;		/* Scaled mantissa.  */
  unsigned int tmp;
  unsigned int mover;           /* Mantissa overflow bits */
  unsigned int rbit;            /* Round bit. */
  int shift;			/* Shift count.  */

  /* NOTE: Svein Seldal <Svein@@dev.seldal.com>
     The code in this function is altered slightly to support floats
     with 31-bits mantissas, thus the documentation below may be a
     little bit inaccurate.
     
     By Michael P. Hayes <m.hayes@@elec.canterbury.ac.nz>
     Here is how a generic floating point number is stored using
     flonums (an extension of bignums) where p is a pointer to an
     array of LITTLENUMs.

     For example 2e-3 is stored with exp = -4 and
     bits[0] = 0x0000
     bits[1] = 0x0000
     bits[2] = 0x4fde
     bits[3] = 0x978d
     bits[4] = 0x126e
     bits[5] = 0x0083
     with low = &bits[2], high = &bits[5], and leader = &bits[5].

     This number can be written as
     0x0083126e978d4fde.00000000 * 65536**-4  or
     0x0.0083126e978d4fde        * 65536**0   or
     0x0.83126e978d4fde          * 2**-8   = 2e-3

     Note that low points to the 65536**0 littlenum (bits[2]) and
     leader points to the most significant non-zero littlenum
     (bits[5]).

     TMS320C3X floating point numbers are a bit of a strange beast.
     The 32-bit flavour has the 8 MSBs representing the exponent in
     twos complement format (-128 to +127).  There is then a sign bit
     followed by 23 bits of mantissa.  The mantissa is expressed in
     twos complement format with the binary point after the most
     significant non sign bit.  The bit after the binary point is
     suppressed since it is the complement of the sign bit.  The
     effective mantissa is thus 24 bits.  Zero is represented by an
     exponent of -128.

     The 16-bit flavour has the 4 MSBs representing the exponent in
     twos complement format (-8 to +7).  There is then a sign bit
     followed by 11 bits of mantissa.  The mantissa is expressed in
     twos complement format with the binary point after the most
     significant non sign bit.  The bit after the binary point is
     suppressed since it is the complement of the sign bit.  The
     effective mantissa is thus 12 bits.  Zero is represented by an
     exponent of -8.  For example,

     number       norm mant m  x  e  s  i    fraction f
     +0.500 =>  1.00000000000 -1 -1  0  1  .00000000000   (1 + 0) * 2^(-1)
     +0.999 =>  1.11111111111 -1 -1  0  1  .11111111111   (1 + 0.99) * 2^(-1)
     +1.000 =>  1.00000000000  0  0  0  1  .00000000000   (1 + 0) * 2^(0)
     +1.500 =>  1.10000000000  0  0  0  1  .10000000000   (1 + 0.5) * 2^(0)
     +1.999 =>  1.11111111111  0  0  0  1  .11111111111   (1 + 0.9) * 2^(0)
     +2.000 =>  1.00000000000  1  1  0  1  .00000000000   (1 + 0) * 2^(1)
     +4.000 =>  1.00000000000  2  2  0  1  .00000000000   (1 + 0) * 2^(2)
     -0.500 =>  1.00000000000 -1 -1  1  0  .10000000000   (-2 + 0) * 2^(-2)
     -1.000 =>  1.00000000000  0 -1  1  0  .00000000000   (-2 + 0) * 2^(-1)
     -1.500 =>  1.10000000000  0  0  1  0  .10000000000   (-2 + 0.5) * 2^(0)
     -1.999 =>  1.11111111111  0  0  1  0  .00000000001   (-2 + 0.11) * 2^(0)
     -2.000 =>  1.00000000000  1  1  1  0  .00000000000   (-2 + 0) * 2^(0)
     -4.000 =>  1.00000000000  2  1  1  0  .00000000000   (-2 + 0) * 2^(1)

     where e is the exponent, s is the sign bit, i is the implied bit,
     and f is the fraction stored in the mantissa field.

     num = (1 + f) * 2^x   =  m * 2^e if s = 0
     num = (-2 + f) * 2^x  = -m * 2^e if s = 1
     where 0 <= f < 1.0  and 1.0 <= m < 2.0

     The fraction (f) and exponent (e) fields for the TMS320C3X format
     can be derived from the normalised mantissa (m) and exponent (x) using:

     f = m - 1, e = x       if s = 0
     f = 2 - m, e = x       if s = 1 and m != 1.0
     f = 0,     e = x - 1   if s = 1 and m = 1.0
     f = 0,     e = -8      if m = 0


     OK, the other issue we have to consider is rounding since the
     mantissa has a much higher potential precision than what we can
     represent.  To do this we add half the smallest storable fraction.
     We then have to renormalise the number to allow for overflow.

     To convert a generic flonum into a TMS320C3X floating point
     number, here's what we try to do....

     The first thing is to generate a normalised mantissa (m) where
     1.0 <= m < 2 and to convert the exponent from base 16 to base 2.
     We desire the binary point to be placed after the most significant
     non zero bit.  This process is done in two steps: firstly, the
     littlenum with the most significant non zero bit is located (this
     is done for us since leader points to this littlenum) and the
     binary point (which is currently after the LSB of the littlenum
     pointed to by low) is moved to before the MSB of the littlenum
     pointed to by leader.  This requires the exponent to be adjusted
     by leader - low + 1.  In the earlier example, the new exponent is
     thus -4 + (5 - 2 + 1) = 0 (base 65536).  We now need to convert
     the exponent to base 2 by multiplying the exponent by 16 (log2
     65536).  The exponent base 2 is thus also zero.

     The second step is to hunt for the most significant non zero bit
     in the leader littlenum.  We do this by left shifting a copy of
     the leader littlenum until bit 16 is set (0x10000) and counting
     the number of shifts, S, required.  The number of shifts then has to
     be added to correct the exponent (base 2).  For our example, this
     will require 9 shifts and thus our normalised exponent (base 2) is
     0 + 9 = 9.  Note that the worst case scenario is when the leader
     littlenum is 1, thus requiring 16 shifts.

     We now have to left shift the other littlenums by the same amount,
     propagating the shifted bits into the more significant littlenums.
     To save a lot of unnecessary shifting we only have to consider
     two or three littlenums, since the greatest number of mantissa
     bits required is 24 + 1 rounding bit.  While two littlenums
     provide 32 bits of precision, the most significant littlenum
     may only contain a single significant bit  and thus an extra
     littlenum is required.

     Denoting the number of bits in the fraction field as F, we require
     G = F + 2 bits (one extra bit is for rounding, the other gets
     suppressed).  Say we required S shifts to find the most
     significant bit in the leader littlenum, the number of left shifts
     required to move this bit into bit position G - 1 is L = G + S - 17.
     Note that this shift count may be negative for the short floating
     point flavour (where F = 11 and thus G = 13 and potentially S < 3).
     If L > 0 we have to shunt the next littlenum into position.  Bit
     15 (the MSB) of the next littlenum needs to get moved into position
     L - 1 (If L > 15 we need all the bits of this littlenum and
     some more from the next one.).  We subtract 16 from L and use this
     as the left shift count;  the resultant value we or with the
     previous result.  If L > 0, we repeat this operation.   */

  if (precision != S_PRECISION)
    words[1] = 0x0000;
  if (precision == E_PRECISION)
    words[2] = words[3] = 0x0000;

  /* 0.0e0 or NaN seen.  */
  if (flonum.low > flonum.leader  /* = 0.0e0 */
      || flonum.sign == 0) /* = NaN */
    {
      if(flonum.sign == 0)
        as_bad (_("Nan, using zero."));
      words[0] = 0x8000;
      return return_value;
    }

  if (flonum.sign == 'P')
    {
      /* +INF:  Replace with maximum float.  */
      if (precision == S_PRECISION)
	words[0] = 0x77ff;
      else 
	{
	  words[0] = 0x7f7f;
	  words[1] = 0xffff;
	}
      if (precision == E_PRECISION)
        {
          words[2] = 0x7fff;
          words[3] = 0xffff;
        }
      return return_value;
    }
  else if (flonum.sign == 'N')
    {
      /* -INF:  Replace with maximum float.  */
      if (precision == S_PRECISION)
	words[0] = 0x7800;
      else 
        words[0] = 0x7f80;
      if (precision == E_PRECISION)
        words[2] = 0x8000;
      return return_value;
    }

  exponent = (flonum.exponent + flonum.leader - flonum.low + 1) * 16;

  if (!(tmp = *flonum.leader))
    abort ();			/* Hmmm.  */
  shift = 0;			/* Find position of first sig. bit.  */
  while (tmp >>= 1)
    shift++;
  exponent -= (16 - shift);	/* Adjust exponent.  */

  if (precision == S_PRECISION)	/* Allow 1 rounding bit.  */
    {
      exponent_bits = 4;
      mantissa_bits = 11;
    }
  else if(precision == F_PRECISION)
    {
      exponent_bits = 8;
      mantissa_bits = 23;
    }
  else /* E_PRECISION */
    {
      exponent_bits = 8;
      mantissa_bits = 31;
    }

  shift = mantissa_bits - shift;

  smant = 0;
  mover = 0;
  rbit = 0;
  /* Store the mantissa data into smant and the roundbit into rbit */
  for (p = flonum.leader; p >= flonum.low && shift > -16; p--)
    {
      tmp = shift >= 0 ? *p << shift : *p >> -shift;
      rbit = shift < 0 ? ((*p >> (-shift-1)) & 0x1) : 0;
      smant |= tmp;
      shift -= 16;
    }

  /* OK, we've got our scaled mantissa so let's round it up */
  if(rbit)
    {
      /* If the mantissa is going to overflow when added, lets store
         the extra bit in mover. -- A special case exists when
         mantissa_bits is 31 (E_PRECISION). Then the first test cannot
         be trusted, as result is host-dependent, thus the second
         test. */
      if( smant == ((unsigned)(1<<(mantissa_bits+1))-1)
          || smant == (unsigned)-1 )  /* This is to catch E_PRECISION cases */
        mover=1;
      smant++;
    }

  /* Get the scaled one value */
  sone = (1 << (mantissa_bits));

  /* The number may be unnormalised so renormalise it...  */
  if(mover)
    {
      smant >>= 1;
      smant |= sone; /* Insert the bit from mover into smant */
      exponent++;
    }

  /* The binary point is now between bit positions 11 and 10 or 23 and 22,
     i.e., between mantissa_bits - 1 and mantissa_bits - 2 and the
     bit at mantissa_bits - 1 should be set.  */
  if (!(sone&smant))
    abort ();                   /* Ooops.  */

  if (flonum.sign == '+')
    sfract = smant - sone;	/* smant - 1.0.  */
  else
    {
      /* This seems to work.  */
      if (smant == sone)
	{
	  exponent--;
	  sfract = 0;
	}
      else
        {
          sfract = -smant & (sone-1);   /* 2.0 - smant.  */
        }
      sfract |= sone;		/* Insert sign bit.  */
    }

  if (abs (exponent) >= (1 << (exponent_bits - 1)))
    as_bad (_("Cannot represent exponent in %d bits"), exponent_bits);

  /* Force exponent to fit in desired field width.  */
  exponent &= (1 << (exponent_bits)) - 1;

  if (precision == E_PRECISION)
    {
      /* Map the float part first (100% equal format as F_PRECISION) */
      words[0]  = exponent << (mantissa_bits+1-24);
      words[0] |= sfract >> 24;
      words[1]  = sfract >> 8;

      /* Map the mantissa in the next */
      words[2]  = sfract >> 16;
      words[3]  = sfract & 0xffff;
    }
  else
    {
      /* Insert the exponent data into the word */
      sfract |= exponent << (mantissa_bits+1);

      if (precision == S_PRECISION)
        words[0] = sfract;
      else
        {
          words[0] = sfract >> 16;
          words[1] = sfract & 0xffff;
        }
    }

  return return_value;
}

/* Returns pointer past text consumed.  */
static char *
tic4x_atof (char *str, char what_kind, LITTLENUM_TYPE *words)
{
  /* Extra bits for zeroed low-order bits.  The 1st MAX_PRECISION are
     zeroed, the last contain flonum bits.  */
  static LITTLENUM_TYPE bits[MAX_PRECISION + MAX_PRECISION + GUARD];
  char *return_value;
  /* Number of 16-bit words in the format.  */
  int precision;
  FLONUM_TYPE save_gen_flonum;

  /* We have to save the generic_floating_point_number because it
     contains storage allocation about the array of LITTLENUMs where
     the value is actually stored.  We will allocate our own array of
     littlenums below, but have to restore the global one on exit.  */
  save_gen_flonum = generic_floating_point_number;

  return_value = str;
  generic_floating_point_number.low = bits + MAX_PRECISION;
  generic_floating_point_number.high = NULL;
  generic_floating_point_number.leader = NULL;
  generic_floating_point_number.exponent = 0;
  generic_floating_point_number.sign = '\0';

  /* Use more LittleNums than seems necessary: the highest flonum may
     have 15 leading 0 bits, so could be useless.  */

  memset (bits, '\0', sizeof (LITTLENUM_TYPE) * MAX_PRECISION);

  switch (what_kind)
    {
    case 's':
    case 'S':
      precision = S_PRECISION;
      break;

    case 'd':
    case 'D':
    case 'f':
    case 'F':
      precision = F_PRECISION;
      break;

    case 'E':
    case 'e':
      precision = E_PRECISION;
      break;

    default:
      as_bad (_("Invalid floating point number"));
      return (NULL);
    }

  generic_floating_point_number.high
    = generic_floating_point_number.low + precision - 1 + GUARD;

  if (atof_generic (&return_value, ".", EXP_CHARS,
		    &generic_floating_point_number))
    {
      as_bad (_("Invalid floating point number"));
      return (NULL);
    }

  tic4x_gen_to_words (generic_floating_point_number,
		    words, precision);

  /* Restore the generic_floating_point_number's storage alloc (and
     everything else).  */
  generic_floating_point_number = save_gen_flonum;

  return return_value;
}

static void 
tic4x_insert_reg (char *regname, int regnum)
{
  char buf[32];
  int i;

  symbol_table_insert (symbol_new (regname, reg_section, (valueT) regnum,
				   &zero_address_frag));
  for (i = 0; regname[i]; i++)
    buf[i] = ISLOWER (regname[i]) ? TOUPPER (regname[i]) : regname[i];
  buf[i] = '\0';

  symbol_table_insert (symbol_new (buf, reg_section, (valueT) regnum,
				   &zero_address_frag));
}

static void 
tic4x_insert_sym (char *symname, int value)
{
  symbolS *symbolP;

  symbolP = symbol_new (symname, absolute_section,
			(valueT) value, &zero_address_frag);
  SF_SET_LOCAL (symbolP);
  symbol_table_insert (symbolP);
}

static char *
tic4x_expression (char *str, expressionS *exp)
{
  char *s;
  char *t;

  t = input_line_pointer;	/* Save line pointer.  */
  input_line_pointer = str;
  expression (exp);
  s = input_line_pointer;
  input_line_pointer = t;	/* Restore line pointer.  */
  return s;			/* Return pointer to where parsing stopped.  */
}

static char *
tic4x_expression_abs (char *str, offsetT *value)
{
  char *s;
  char *t;

  t = input_line_pointer;	/* Save line pointer.  */
  input_line_pointer = str;
  *value = get_absolute_expression ();
  s = input_line_pointer;
  input_line_pointer = t;	/* Restore line pointer.  */
  return s;
}

static void 
tic4x_emit_char (char c, int b)
{
  expressionS exp;

  exp.X_op = O_constant;
  exp.X_add_number = c;
  emit_expr (&exp, b);
}

static void 
tic4x_seg_alloc (char *name ATTRIBUTE_UNUSED,
		 segT seg ATTRIBUTE_UNUSED,
		 int size,
		 symbolS *symbolP)
{
  /* Note that the size is in words
     so we multiply it by 4 to get the number of bytes to allocate.  */

  /* If we have symbol:  .usect  ".fred", size etc.,
     the symbol needs to point to the first location reserved
     by the pseudo op.  */

  if (size)
    {
      char *p;

      p = frag_var (rs_fill, 1, 1, (relax_substateT) 0,
		    (symbolS *) symbolP,
		    size * OCTETS_PER_BYTE, (char *) 0);
      *p = 0;
    }
}

/* .asg ["]character-string["], symbol */
static void 
tic4x_asg (int x ATTRIBUTE_UNUSED)
{
  char c;
  char *name;
  char *str;
  char *tmp;

  SKIP_WHITESPACE ();
  str = input_line_pointer;

  /* Skip string expression.  */
  while (*input_line_pointer != ',' && *input_line_pointer)
    input_line_pointer++;
  if (*input_line_pointer != ',')
    {
      as_bad (_("Comma expected\n"));
      return;
    }
  *input_line_pointer++ = '\0';
  name = input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  tmp = xmalloc (strlen (str) + 1);
  strcpy (tmp, str);
  str = tmp;
  tmp = xmalloc (strlen (name) + 1);
  strcpy (tmp, name);
  name = tmp;
  if (hash_find (tic4x_asg_hash, name))
    hash_replace (tic4x_asg_hash, name, (void *) str);
  else
    hash_insert (tic4x_asg_hash, name, (void *) str);
  *input_line_pointer = c;
  demand_empty_rest_of_line ();
}

/* .bss symbol, size  */
static void 
tic4x_bss (int x ATTRIBUTE_UNUSED)
{
  char c;
  char *name;
  char *p;
  offsetT size;
  segT current_seg;
  subsegT current_subseg;
  symbolS *symbolP;

  current_seg = now_seg;	/* Save current seg.  */
  current_subseg = now_subseg;	/* Save current subseg.  */

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  if (c != ',')
    {
      as_bad (_(".bss size argument missing\n"));
      return;
    }

  input_line_pointer =
    tic4x_expression_abs (++input_line_pointer, &size);
  if (size < 0)
    {
      as_bad (_(".bss size %ld < 0!"), (long) size);
      return;
    }
  subseg_set (bss_section, 0);
  symbolP = symbol_find_or_make (name);

  if (S_GET_SEGMENT (symbolP) == bss_section)
    symbol_get_frag (symbolP)->fr_symbol = 0;

  symbol_set_frag (symbolP, frag_now);

  p = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
		size * OCTETS_PER_BYTE, (char *) 0);
  *p = 0;			/* Fill char.  */

  S_SET_SEGMENT (symbolP, bss_section);

  /* The symbol may already have been created with a preceding
     ".globl" directive -- be careful not to step on storage class
     in that case.  Otherwise, set it to static.  */
  if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
    S_SET_STORAGE_CLASS (symbolP, C_STAT);

  subseg_set (current_seg, current_subseg); /* Restore current seg.  */
  demand_empty_rest_of_line ();
}

static void
tic4x_globl (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  int c;
  symbolS *symbolP;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();
      S_SET_STORAGE_CLASS (symbolP, C_EXT);
      S_SET_EXTERNAL (symbolP);
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

/* Handle .byte, .word. .int, .long */
static void 
tic4x_cons (int bytes)
{
  register unsigned int c;
  do
    {
      SKIP_WHITESPACE ();
      if (*input_line_pointer == '"')
	{
	  input_line_pointer++;
	  while (is_a_char (c = next_char_of_string ()))
	    tic4x_emit_char (c, 4);
	  know (input_line_pointer[-1] == '\"');
	}
      else
	{
	  expressionS exp;

	  input_line_pointer = tic4x_expression (input_line_pointer, &exp);
	  if (exp.X_op == O_constant)
	    {
	      switch (bytes)
		{
		case 1:
		  exp.X_add_number &= 255;
		  break;
		case 2:
		  exp.X_add_number &= 65535;
		  break;
		}
	    }
	  /* Perhaps we should disallow .byte and .hword with
	     a non constant expression that will require relocation.  */
	  emit_expr (&exp, 4);
	}
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
}

/* Handle .ascii, .asciz, .string */
static void 
tic4x_stringer (int append_zero)
{
  int bytes;
  register unsigned int c;

  bytes = 0;
  do
    {
      SKIP_WHITESPACE ();
      if (*input_line_pointer == '"')
	{
	  input_line_pointer++;
	  while (is_a_char (c = next_char_of_string ()))
            {
              tic4x_emit_char (c, 1);
              bytes++;
            }

          if (append_zero)
            {
              tic4x_emit_char (c, 1);
              bytes++;
            }

	  know (input_line_pointer[-1] == '\"');
	}
      else
	{
	  expressionS exp;

	  input_line_pointer = tic4x_expression (input_line_pointer, &exp);
	  if (exp.X_op != O_constant)
            {
              as_bad (_("Non-constant symbols not allowed\n"));
              return;
            }
          exp.X_add_number &= 255; /* Limit numeber to 8-bit */
	  emit_expr (&exp, 1);
          bytes++;
	}
    }
  while (*input_line_pointer++ == ',');

  /* Fill out the rest of the expression with 0's to fill up a full word */
  if ( bytes&0x3 )
    tic4x_emit_char (0, 4-(bytes&0x3));

  input_line_pointer--;		/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
}

/* .eval expression, symbol */
static void 
tic4x_eval (int x ATTRIBUTE_UNUSED)
{
  char c;
  offsetT value;
  char *name;

  SKIP_WHITESPACE ();
  input_line_pointer =
    tic4x_expression_abs (input_line_pointer, &value);
  if (*input_line_pointer++ != ',')
    {
      as_bad (_("Symbol missing\n"));
      return;
    }
  name = input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  tic4x_insert_sym (name, value);
  *input_line_pointer++ = c;
  demand_empty_rest_of_line ();
}

/* Reset local labels.  */
static void 
tic4x_newblock (int x ATTRIBUTE_UNUSED)
{
  dollar_label_clear ();
}

/* .sect "section-name" [, value] */
/* .sect ["]section-name[:subsection-name]["] [, value] */
static void 
tic4x_sect (int x ATTRIBUTE_UNUSED)
{
  char c;
  char *section_name;
  char *name;
  segT seg;
  offsetT num;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    input_line_pointer++;
  section_name = input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  input_line_pointer++;		/* Skip null symbol terminator.  */
  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);

  /* TI C from version 5.0 allows a section name to contain a
     subsection name as well. The subsection name is separated by a
     ':' from the section name.  Currently we scan the subsection
     name and discard it.
     Volker Kuhlmann  <v.kuhlmann@@elec.canterbury.ac.nz>.  */
  if (c == ':')
    {
      c = get_symbol_end ();	/* Get terminator.  */
      input_line_pointer++;	/* Skip null symbol terminator.  */
      as_warn (_(".sect: subsection name ignored"));
    }

  /* We might still have a '"' to discard, but the character after a
     symbol name will be overwritten with a \0 by get_symbol_end()
     [VK].  */

  if (c == ',')
    input_line_pointer =
      tic4x_expression_abs (input_line_pointer, &num);
  else if (*input_line_pointer == ',')
    {
      input_line_pointer =
	tic4x_expression_abs (++input_line_pointer, &num);
    }
  else
    num = 0;

  seg = subseg_new (name, num);
  if (line_label != NULL)
    {
      S_SET_SEGMENT (line_label, seg);
      symbol_set_frag (line_label, frag_now);
    }

  if (bfd_get_section_flags (stdoutput, seg) == SEC_NO_FLAGS)
    {
      if (!bfd_set_section_flags (stdoutput, seg, SEC_DATA))
	as_warn (_("Error setting flags for \"%s\": %s"), name,
		 bfd_errmsg (bfd_get_error ()));
    }

  /* If the last character overwritten by get_symbol_end() was an
     end-of-line, we must restore it or the end of the line will not be
     recognised and scanning extends into the next line, stopping with
     an error (blame Volker Kuhlmann <v.kuhlmann@@elec.canterbury.ac.nz>
     if this is not true).  */
  if (is_end_of_line[(unsigned char) c])
    *(--input_line_pointer) = c;

  demand_empty_rest_of_line ();
}

/* symbol[:] .set value  or  .set symbol, value */
static void 
tic4x_set (int x ATTRIBUTE_UNUSED)
{
  symbolS *symbolP;

  SKIP_WHITESPACE ();
  if ((symbolP = line_label) == NULL)
    {
      char c;
      char *name;

      name = input_line_pointer;
      c = get_symbol_end ();	/* Get terminator.  */
      if (c != ',')
	{
	  as_bad (_(".set syntax invalid\n"));
	  ignore_rest_of_line ();
	  return;
	}
      ++input_line_pointer;
      symbolP = symbol_find_or_make (name);
    }
  else
    symbol_table_insert (symbolP);

  pseudo_set (symbolP);
  demand_empty_rest_of_line ();
}

/* [symbol] .usect ["]section-name["], size-in-words [, alignment-flag] */
static void 
tic4x_usect (int x ATTRIBUTE_UNUSED)
{
  char c;
  char *name;
  char *section_name;
  segT seg;
  offsetT size, alignment_flag;
  segT current_seg;
  subsegT current_subseg;

  current_seg = now_seg;	/* save current seg.  */
  current_subseg = now_subseg;	/* save current subseg.  */

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    input_line_pointer++;
  section_name = input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  input_line_pointer++;		/* Skip null symbol terminator.  */
  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);

  if (c == ',')
    input_line_pointer =
      tic4x_expression_abs (input_line_pointer, &size);
  else if (*input_line_pointer == ',')
    {
      input_line_pointer =
	tic4x_expression_abs (++input_line_pointer, &size);
    }
  else
    size = 0;

  /* Read a possibly present third argument (alignment flag) [VK].  */
  if (*input_line_pointer == ',')
    {
      input_line_pointer =
	tic4x_expression_abs (++input_line_pointer, &alignment_flag);
    }
  else
    alignment_flag = 0;
  if (alignment_flag)
    as_warn (_(".usect: non-zero alignment flag ignored"));

  seg = subseg_new (name, 0);
  if (line_label != NULL)
    {
      S_SET_SEGMENT (line_label, seg);
      symbol_set_frag (line_label, frag_now);
      S_SET_VALUE (line_label, frag_now_fix ());
    }
  seg_info (seg)->bss = 1;	/* Uninitialised data.  */
  if (!bfd_set_section_flags (stdoutput, seg, SEC_ALLOC))
    as_warn (_("Error setting flags for \"%s\": %s"), name,
	     bfd_errmsg (bfd_get_error ()));
  tic4x_seg_alloc (name, seg, size, line_label);

  if (S_GET_STORAGE_CLASS (line_label) != C_EXT)
    S_SET_STORAGE_CLASS (line_label, C_STAT);

  subseg_set (current_seg, current_subseg);	/* Restore current seg.  */
  demand_empty_rest_of_line ();
}

/* .version cpu-version.  */
static void 
tic4x_version (int x ATTRIBUTE_UNUSED)
{
  offsetT temp;

  input_line_pointer =
    tic4x_expression_abs (input_line_pointer, &temp);
  if (!IS_CPU_TIC3X (temp) && !IS_CPU_TIC4X (temp))
    as_bad (_("This assembler does not support processor generation %ld"),
	    (long) temp);

  if (tic4x_cpu && temp != (offsetT) tic4x_cpu)
    as_warn (_("Changing processor generation on fly not supported..."));
  tic4x_cpu = temp;
  demand_empty_rest_of_line ();
}

static void 
tic4x_init_regtable (void)
{
  unsigned int i;

  for (i = 0; i < tic3x_num_registers; i++)
    tic4x_insert_reg (tic3x_registers[i].name,
		    tic3x_registers[i].regno);

  if (IS_CPU_TIC4X (tic4x_cpu))
    {
      /* Add additional Tic4x registers, overriding some C3x ones.  */
      for (i = 0; i < tic4x_num_registers; i++)
	tic4x_insert_reg (tic4x_registers[i].name,
			tic4x_registers[i].regno);
    }
}

static void 
tic4x_init_symbols (void)
{
  /* The TI tools accept case insensitive versions of these symbols,
     we don't !

     For TI C/Asm 5.0

     .TMS320xx       30,31,32,40,or 44       set according to -v flag
     .C3X or .C3x    1 or 0                  1 if -v30,-v31,or -v32
     .C30            1 or 0                  1 if -v30
     .C31            1 or 0                  1 if -v31
     .C32            1 or 0                  1 if -v32
     .C4X or .C4x    1 or 0                  1 if -v40, or -v44
     .C40            1 or 0                  1 if -v40
     .C44            1 or 0                  1 if -v44

     .REGPARM 1 or 0                  1 if -mr option used
     .BIGMODEL        1 or 0                  1 if -mb option used

     These symbols are currently supported but will be removed in a
     later version:
     .TMS320C30      1 or 0                  1 if -v30,-v31,or -v32
     .TMS320C31      1 or 0                  1 if -v31
     .TMS320C32      1 or 0                  1 if -v32
     .TMS320C40      1 or 0                  1 if -v40, or -v44
     .TMS320C44      1 or 0                  1 if -v44

     Source: TI: TMS320C3x/C4x Assembly Language Tools User's Guide,
     1997, SPRU035C, p. 3-17/3-18.  */
  tic4x_insert_sym (".REGPARM", tic4x_reg_args);
  tic4x_insert_sym (".MEMPARM", !tic4x_reg_args);	
  tic4x_insert_sym (".BIGMODEL", tic4x_big_model);
  tic4x_insert_sym (".C30INTERRUPT", 0);
  tic4x_insert_sym (".TMS320xx", tic4x_cpu == 0 ? 40 : tic4x_cpu);
  tic4x_insert_sym (".C3X", tic4x_cpu == 30 || tic4x_cpu == 31 || tic4x_cpu == 32 || tic4x_cpu == 33);
  tic4x_insert_sym (".C3x", tic4x_cpu == 30 || tic4x_cpu == 31 || tic4x_cpu == 32 || tic4x_cpu == 33);
  tic4x_insert_sym (".C4X", tic4x_cpu == 0 || tic4x_cpu == 40 || tic4x_cpu == 44);
  tic4x_insert_sym (".C4x", tic4x_cpu == 0 || tic4x_cpu == 40 || tic4x_cpu == 44);
  /* Do we need to have the following symbols also in lower case?  */
  tic4x_insert_sym (".TMS320C30", tic4x_cpu == 30 || tic4x_cpu == 31 || tic4x_cpu == 32 || tic4x_cpu == 33);
  tic4x_insert_sym (".tms320C30", tic4x_cpu == 30 || tic4x_cpu == 31 || tic4x_cpu == 32 || tic4x_cpu == 33);
  tic4x_insert_sym (".TMS320C31", tic4x_cpu == 31);
  tic4x_insert_sym (".tms320C31", tic4x_cpu == 31);
  tic4x_insert_sym (".TMS320C32", tic4x_cpu == 32);
  tic4x_insert_sym (".tms320C32", tic4x_cpu == 32);
  tic4x_insert_sym (".TMS320C33", tic4x_cpu == 33);
  tic4x_insert_sym (".tms320C33", tic4x_cpu == 33);
  tic4x_insert_sym (".TMS320C40", tic4x_cpu == 40 || tic4x_cpu == 44 || tic4x_cpu == 0);
  tic4x_insert_sym (".tms320C40", tic4x_cpu == 40 || tic4x_cpu == 44 || tic4x_cpu == 0);
  tic4x_insert_sym (".TMS320C44", tic4x_cpu == 44);
  tic4x_insert_sym (".tms320C44", tic4x_cpu == 44);
  tic4x_insert_sym (".TMX320C40", 0);	/* C40 first pass silicon ?  */
  tic4x_insert_sym (".tmx320C40", 0);
}

/* Insert a new instruction template into hash table.  */
static int 
tic4x_inst_insert (const tic4x_inst_t *inst)
{
  static char prev_name[16];
  const char *retval = NULL;

  /* Only insert the first name if have several similar entries.  */
  if (!strcmp (inst->name, prev_name) || inst->name[0] == '\0')
    return 1;

  retval = hash_insert (tic4x_op_hash, inst->name, (void *) inst);
  if (retval != NULL)
    fprintf (stderr, "internal error: can't hash `%s': %s\n",
	     inst->name, retval);
  else
    strcpy (prev_name, inst->name);
  return retval == NULL;
}

/* Make a new instruction template.  */
static tic4x_inst_t *
tic4x_inst_make (char *name, unsigned long opcode, char *args)
{
  static tic4x_inst_t *insts = NULL;
  static char *names = NULL;
  static int iindex = 0;

  if (insts == NULL)
    {
      /* Allocate memory to store name strings.  */
      names = (char *) xmalloc (sizeof (char) * 8192);
      /* Allocate memory for additional insts.  */
      insts = (tic4x_inst_t *)
	xmalloc (sizeof (tic4x_inst_t) * 1024);
    }
  insts[iindex].name = names;
  insts[iindex].opcode = opcode;
  insts[iindex].opmask = 0xffffffff;
  insts[iindex].args = args;
  iindex++;

  do
    *names++ = *name++;
  while (*name);
  *names++ = '\0';

  return &insts[iindex - 1];
}

/* Add instruction template, creating dynamic templates as required.  */
static int 
tic4x_inst_add (const tic4x_inst_t *insts)
{
  char *s = insts->name;
  char *d;
  unsigned int i;
  int ok = 1;
  char name[16];

  d = name;

  /* We do not care about INSNs that is not a part of our
     oplevel setting.  */
  if ((insts->oplevel & tic4x_oplevel) == 0)
    return ok;

  while (1)
    {
      switch (*s)
	{
	case 'B':
	case 'C':
	  /* Dynamically create all the conditional insts.  */
	  for (i = 0; i < tic4x_num_conds; i++)
	    {
	      tic4x_inst_t *inst;
	      int k = 0;
	      char *c = tic4x_conds[i].name;
	      char *e = d;

	      while (*c)
		*e++ = *c++;
	      c = s + 1;
	      while (*c)
		*e++ = *c++;
	      *e = '\0';

	      /* If instruction found then have already processed it.  */
	      if (hash_find (tic4x_op_hash, name))
		return 1;

	      do
		{
		  inst = tic4x_inst_make (name, insts[k].opcode +
					(tic4x_conds[i].cond <<
					 (*s == 'B' ? 16 : 23)),
					insts[k].args);
		  if (k == 0)	/* Save strcmp() with following func.  */
		    ok &= tic4x_inst_insert (inst);
		  k++;
		}
	      while (!strcmp (insts->name,
			      insts[k].name));
	    }
	  return ok;
	  break;

	case '\0':
	  return tic4x_inst_insert (insts);
	  break;

	default:
	  *d++ = *s++;
	  break;
	}
    }
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc., that the MD part of the assembler will
   need.  */
void 
md_begin (void)
{
  int ok = 1;
  unsigned int i;

  /* Setup the proper opcode level according to the
     commandline parameters */
  tic4x_oplevel = OP_C3X;

  if ( IS_CPU_TIC4X(tic4x_cpu) )
    tic4x_oplevel |= OP_C4X;

  if ( (   tic4x_cpu == 31 && tic4x_revision >= 6)
       || (tic4x_cpu == 32 && tic4x_revision >= 2)
       || (tic4x_cpu == 33)
       || tic4x_enhanced )
    tic4x_oplevel |= OP_ENH;

  if ( (   tic4x_cpu == 30 && tic4x_revision >= 7)
       || (tic4x_cpu == 31 && tic4x_revision >= 5)
       || (tic4x_cpu == 32)
       || tic4x_lowpower )
    tic4x_oplevel |= OP_LPWR;

  if ( (   tic4x_cpu == 30 && tic4x_revision >= 7)
       || (tic4x_cpu == 31 && tic4x_revision >= 5)
       || (tic4x_cpu == 32)
       || (tic4x_cpu == 33)
       || (tic4x_cpu == 40 && tic4x_revision >= 5)
       || (tic4x_cpu == 44)
       || tic4x_idle2 )
    tic4x_oplevel |= OP_IDLE2;

  /* Create hash table for mnemonics.  */
  tic4x_op_hash = hash_new ();

  /* Create hash table for asg pseudo.  */
  tic4x_asg_hash = hash_new ();

  /* Add mnemonics to hash table, expanding conditional mnemonics on fly.  */
  for (i = 0; i < tic4x_num_insts; i++)
    ok &= tic4x_inst_add (tic4x_insts + i);

  /* Create dummy inst to avoid errors accessing end of table.  */
  tic4x_inst_make ("", 0, "");

  if (!ok)
    as_fatal ("Broken assembler.  No assembly attempted.");

  /* Add registers to symbol table.  */
  tic4x_init_regtable ();

  /* Add predefined symbols to symbol table.  */
  tic4x_init_symbols ();
}

void 
tic4x_end (void)
{
  bfd_set_arch_mach (stdoutput, bfd_arch_tic4x, 
		     IS_CPU_TIC4X (tic4x_cpu) ? bfd_mach_tic4x : bfd_mach_tic3x);
}

static int 
tic4x_indirect_parse (tic4x_operand_t *operand,
		      const tic4x_indirect_t *indirect)
{
  char *n = indirect->name;
  char *s = input_line_pointer;
  char *b;
  symbolS *symbolP;
  char name[32];

  operand->disp = 0;
  for (; *n; n++)
    {
      switch (*n)
	{
	case 'a':		/* Need to match aux register.  */
	  b = name;
#ifdef TIC4X_ALT_SYNTAX
	  if (*s == '%')
	    s++;
#endif
	  while (ISALNUM (*s))
	    *b++ = *s++;
	  *b++ = '\0';
	  if (!(symbolP = symbol_find (name)))
	    return 0;

	  if (S_GET_SEGMENT (symbolP) != reg_section)
	    return 0;

	  operand->aregno = S_GET_VALUE (symbolP);
	  if (operand->aregno >= REG_AR0 && operand->aregno <= REG_AR7)
	    break;

	  as_bad (_("Auxiliary register AR0--AR7 required for indirect"));
	  return -1;

	case 'd':		/* Need to match constant for disp.  */
#ifdef TIC4X_ALT_SYNTAX
	  if (*s == '%')	/* expr() will die if we don't skip this.  */
	    s++;
#endif
	  s = tic4x_expression (s, &operand->expr);
	  if (operand->expr.X_op != O_constant)
	    return 0;
	  operand->disp = operand->expr.X_add_number;
	  if (operand->disp < 0 || operand->disp > 255)
	    {
	      as_bad (_("Bad displacement %d (require 0--255)\n"),
		      operand->disp);
	      return -1;
	    }
	  break;

	case 'y':		/* Need to match IR0.  */
	case 'z':		/* Need to match IR1.  */
#ifdef TIC4X_ALT_SYNTAX
	  if (*s == '%')
	    s++;
#endif
	  s = tic4x_expression (s, &operand->expr);
	  if (operand->expr.X_op != O_register)
	    return 0;
	  if (operand->expr.X_add_number != REG_IR0
	      && operand->expr.X_add_number != REG_IR1)
	    {
	      as_bad (_("Index register IR0,IR1 required for displacement"));
	      return -1;
	    }

	  if (*n == 'y' && operand->expr.X_add_number == REG_IR0)
	    break;
	  if (*n == 'z' && operand->expr.X_add_number == REG_IR1)
	    break;
	  return 0;

	case '(':
	  if (*s != '(')	/* No displacement, assume to be 1.  */
	    {
	      operand->disp = 1;
	      while (*n != ')')
		n++;
	    }
	  else
	    s++;
	  break;

	default:
	  if (TOLOWER (*s) != *n)
	    return 0;
	  s++;
	}
    }
  if (*s != ' ' && *s != ',' && *s != '\0')
    return 0;
  input_line_pointer = s;
  return 1;
}

static char *
tic4x_operand_parse (char *s, tic4x_operand_t *operand)
{
  unsigned int i;
  char c;
  int ret;
  expressionS *exp = &operand->expr;
  char *save = input_line_pointer;
  char *str;
  char *new_pointer;
  struct hash_entry *entry = NULL;

  input_line_pointer = s;
  SKIP_WHITESPACE ();

  str = input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  new_pointer = input_line_pointer;
  if (strlen (str) && (entry = hash_find (tic4x_asg_hash, str)) != NULL)
    {
      *input_line_pointer = c;
      input_line_pointer = (char *) entry;
    }
  else
    {
      *input_line_pointer = c;
      input_line_pointer = str;
    }

  operand->mode = M_UNKNOWN;
  switch (*input_line_pointer)
    {
#ifdef TIC4X_ALT_SYNTAX
    case '%':
      input_line_pointer = tic4x_expression (++input_line_pointer, exp);
      if (exp->X_op != O_register)
	as_bad (_("Expecting a register name"));
      operand->mode = M_REGISTER;
      break;

    case '^':
      /* Denotes high 16 bits.  */
      input_line_pointer = tic4x_expression (++input_line_pointer, exp);
      if (exp->X_op == O_constant)
	operand->mode = M_IMMED;
      else if (exp->X_op == O_big)
	{
	  if (exp->X_add_number)
	    as_bad (_("Number too large"));	/* bignum required */
	  else
	    {
	      tic4x_gen_to_words (generic_floating_point_number,
				operand->fwords, S_PRECISION);
	      operand->mode = M_IMMED_F;
	    }
	}
      /* Allow ori ^foo, ar0 to be equivalent to ldi .hi.foo, ar0  */
      /* WARNING : The TI C40 assembler cannot do this.  */
      else if (exp->X_op == O_symbol)
	{
	  operand->mode = M_HI;
	  break;
	}

    case '#':
      input_line_pointer = tic4x_expression (++input_line_pointer, exp);
      if (exp->X_op == O_constant)
	operand->mode = M_IMMED;
      else if (exp->X_op == O_big)
	{
	  if (exp->X_add_number > 0)
	    as_bad (_("Number too large"));	/* bignum required.  */
	  else
	    {
	      tic4x_gen_to_words (generic_floating_point_number,
				operand->fwords, S_PRECISION);
	      operand->mode = M_IMMED_F;
	    }
	}
      /* Allow ori foo, ar0 to be equivalent to ldi .lo.foo, ar0  */
      /* WARNING : The TI C40 assembler cannot do this.  */
      else if (exp->X_op == O_symbol)
	{
	  operand->mode = M_IMMED;
	  break;
	}

      else
	as_bad (_("Expecting a constant value"));
      break;
    case '\\':
#endif
    case '@@':
      input_line_pointer = tic4x_expression (++input_line_pointer, exp);
      if (exp->X_op != O_constant && exp->X_op != O_symbol)
	as_bad (_("Bad direct addressing construct %s"), s);
      if (exp->X_op == O_constant)
	{
	  if (exp->X_add_number < 0)
	    as_bad (_("Direct value of %ld is not suitable"),
		    (long) exp->X_add_number);
	}
      operand->mode = M_DIRECT;
      break;

    case '*':
      ret = -1;
      for (i = 0; i < tic4x_num_indirects; i++)
	if ((ret = tic4x_indirect_parse (operand, &tic4x_indirects[i])))
	  break;
      if (ret < 0)
	break;
      if (i < tic4x_num_indirects)
	{
	  operand->mode = M_INDIRECT;
	  /* Indirect addressing mode number.  */
	  operand->expr.X_add_number = tic4x_indirects[i].modn;
	  /* Convert *+ARn(0) to *ARn etc.  Maybe we should
	     squeal about silly ones?  */
	  if (operand->expr.X_add_number < 0x08 && !operand->disp)
	    operand->expr.X_add_number = 0x18;
	}
      else
	as_bad (_("Unknown indirect addressing mode"));
      break;

    default:
      operand->mode = M_IMMED;	/* Assume immediate.  */
      str = input_line_pointer;
      input_line_pointer = tic4x_expression (input_line_pointer, exp);
      if (exp->X_op == O_register)
	{
	  know (exp->X_add_symbol == 0);
	  know (exp->X_op_symbol == 0);
	  operand->mode = M_REGISTER;
	  break;
	}
      else if (exp->X_op == O_big)
	{
	  if (exp->X_add_number > 0)
	    as_bad (_("Number too large"));	/* bignum required.  */
	  else
	    {
	      tic4x_gen_to_words (generic_floating_point_number,
				operand->fwords, S_PRECISION);
	      operand->mode = M_IMMED_F;
	    }
	  break;
	}
#ifdef TIC4X_ALT_SYNTAX
      /* Allow ldi foo, ar0 to be equivalent to ldi @@foo, ar0.  */
      else if (exp->X_op == O_symbol)
	{
	  operand->mode = M_DIRECT;
	  break;
	}
#endif
    }
  if (entry == NULL)
    new_pointer = input_line_pointer;
  input_line_pointer = save;
  return new_pointer;
}

static int 
tic4x_operands_match (tic4x_inst_t *inst, tic4x_insn_t *tinsn, int check)
{
  const char *args = inst->args;
  unsigned long opcode = inst->opcode;
  int num_operands = tinsn->num_operands;
  tic4x_operand_t *operand = tinsn->operands;
  expressionS *exp = &operand->expr;
  int ret = 1;
  int reg;

  /* Build the opcode, checking as we go to make sure that the
     operands match.

     If an operand matches, we modify insn or opcode appropriately,
     and do a "continue".  If an operand fails to match, we "break".  */

  tinsn->nchars = 4;		/* Instructions always 4 bytes.  */
  tinsn->reloc = NO_RELOC;
  tinsn->pcrel = 0;

  if (*args == '\0')
    {
      tinsn->opcode = opcode;
      return num_operands == 0;
    }

  for (;; ++args)
    {
      switch (*args)
	{

	case '\0':		/* End of args.  */
	  if (num_operands == 1)
	    {
	      tinsn->opcode = opcode;
	      return ret;
	    }
	  break;		/* Too many operands.  */

	case '#':		/* This is only used for ldp.  */
	  if (operand->mode != M_DIRECT && operand->mode != M_IMMED)
	    break;
	  /* While this looks like a direct addressing mode, we actually
	     use an immediate mode form of ldiu or ldpk instruction.  */
	  if (exp->X_op == O_constant)
	    {
              if( ( IS_CPU_TIC4X (tic4x_cpu) && exp->X_add_number <= 65535 )
                  || ( IS_CPU_TIC3X (tic4x_cpu) && exp->X_add_number <= 255 ) )
                {
                  INSERTS (opcode, exp->X_add_number, 15, 0);
                  continue;
                }
              else
                {
		  if (!check)
                    as_bad (_("Immediate value of %ld is too large for ldf"),
                            (long) exp->X_add_number);
		  ret = -1;
		  continue;
                }
	    }
	  else if (exp->X_op == O_symbol)
	    {
	      tinsn->reloc = BFD_RELOC_HI16;
	      tinsn->exp = *exp;
	      continue;
	    }
	  break;		/* Not direct (dp) addressing.  */

	case '@@':		/* direct.  */
	  if (operand->mode != M_DIRECT)
	    break;
	  if (exp->X_op == O_constant)
            {
              /* Store only the 16 LSBs of the number.  */
              INSERTS (opcode, exp->X_add_number, 15, 0);
              continue;
	    }
	  else if (exp->X_op == O_symbol)
	    {
	      tinsn->reloc = BFD_RELOC_LO16;
	      tinsn->exp = *exp;
	      continue;
	    }
	  break;		/* Not direct addressing.  */

	case 'A':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if (reg >= REG_AR0 && reg <= REG_AR7)
	    INSERTU (opcode, reg - REG_AR0, 24, 22);
	  else
	    {
              if (!check)
                as_bad (_("Destination register must be ARn"));
	      ret = -1;
	    }
	  continue;

	case 'B':		/* Unsigned integer immediate.  */
	  /* Allow br label or br @@label.  */
	  if (operand->mode != M_IMMED && operand->mode != M_DIRECT)
	    break;
	  if (exp->X_op == O_constant)
	    {
	      if (exp->X_add_number < (1 << 24))
		{
		  INSERTU (opcode, exp->X_add_number, 23, 0);
		  continue;
		}
	      else
		{
		  if (!check)
                    as_bad (_("Immediate value of %ld is too large"),
                            (long) exp->X_add_number);
		  ret = -1;
		  continue;
		}
	    }
	  if (IS_CPU_TIC4X (tic4x_cpu))
	    {
	      tinsn->reloc = BFD_RELOC_24_PCREL;
	      tinsn->pcrel = 1;
	    }
	  else
	    {
	      tinsn->reloc = BFD_RELOC_24;
	      tinsn->pcrel = 0;
	    }
	  tinsn->exp = *exp;
	  continue;

	case 'C':
	  if (!IS_CPU_TIC4X (tic4x_cpu))
	    break;
	  if (operand->mode != M_INDIRECT)
	    break;
	  /* Require either *+ARn(disp) or *ARn.  */
	  if (operand->expr.X_add_number != 0
	      && operand->expr.X_add_number != 0x18)
	    {
              if (!check)
                as_bad (_("Invalid indirect addressing mode"));
              ret = -1;
	      continue;
	    }
	  INSERTU (opcode, operand->aregno - REG_AR0, 2, 0);
	  INSERTU (opcode, operand->disp, 7, 3);
	  continue;

	case 'E':
	  if (!(operand->mode == M_REGISTER))
	    break;
	  INSERTU (opcode, exp->X_add_number, 7, 0);
	  continue;

        case 'e':
          if (!(operand->mode == M_REGISTER))
            break;
	  reg = exp->X_add_number;
	  if ( (reg >= REG_R0 && reg <= REG_R7) 
               || (IS_CPU_TIC4X (tic4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
	    INSERTU (opcode, reg, 7, 0);
	  else
	    {
              if (!check)
                as_bad (_("Register must be Rn"));
	      ret = -1;
	    }
          continue;

	case 'F':
	  if (operand->mode != M_IMMED_F
	      && !(operand->mode == M_IMMED && exp->X_op == O_constant))
	    break;

	  if (operand->mode != M_IMMED_F)
	    {
	      /* OK, we 've got something like cmpf 0, r0
	         Why can't they stick in a bloody decimal point ?!  */
	      char string[16];

	      /* Create floating point number string.  */
	      sprintf (string, "%d.0", (int) exp->X_add_number);
	      tic4x_atof (string, 's', operand->fwords);
	    }

	  INSERTU (opcode, operand->fwords[0], 15, 0);
	  continue;

	case 'G':
	  if (operand->mode != M_REGISTER)
	    break;
	  INSERTU (opcode, exp->X_add_number, 15, 8);
	  continue;

        case 'g':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if ( (reg >= REG_R0 && reg <= REG_R7) 
               || (IS_CPU_TIC4X (tic4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
	    INSERTU (opcode, reg, 15, 8);
	  else
	    {
              if (!check)
                as_bad (_("Register must be Rn"));
	      ret = -1;
	    }
          continue;

	case 'H':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if (reg >= REG_R0 && reg <= REG_R7)
	    INSERTU (opcode, reg - REG_R0, 18, 16);
	  else
	    {
              if (!check)
                as_bad (_("Register must be R0--R7"));
	      ret = -1;
	    }
	  continue;

        case 'i':
          if ( operand->mode == M_REGISTER
               && tic4x_oplevel & OP_ENH )
            {
              reg = exp->X_add_number;
              INSERTU (opcode, reg, 4, 0);
              INSERTU (opcode, 7, 7, 5);
              continue;
            }
          /* Fallthrough */

	case 'I':
	  if (operand->mode != M_INDIRECT)
	    break;
	  if (operand->disp != 0 && operand->disp != 1)
	    {
	      if (IS_CPU_TIC4X (tic4x_cpu))
		break;
              if (!check)
                as_bad (_("Invalid indirect addressing mode displacement %d"),
                        operand->disp);
	      ret = -1;
	      continue;
	    }
	  INSERTU (opcode, operand->aregno - REG_AR0, 2, 0);
	  INSERTU (opcode, operand->expr.X_add_number, 7, 3);
	  continue;

        case 'j':
          if ( operand->mode == M_REGISTER
               && tic4x_oplevel & OP_ENH )
            {
              reg = exp->X_add_number;
              INSERTU (opcode, reg, 12, 8);
              INSERTU (opcode, 7, 15, 13);
              continue;
            }
          /* Fallthrough */

	case 'J':
	  if (operand->mode != M_INDIRECT)
	    break;
	  if (operand->disp != 0 && operand->disp != 1)
	    {
	      if (IS_CPU_TIC4X (tic4x_cpu))
		break;
              if (!check)
                as_bad (_("Invalid indirect addressing mode displacement %d"),
                        operand->disp);
	      ret = -1;
	      continue;
	    }
	  INSERTU (opcode, operand->aregno - REG_AR0, 10, 8);
	  INSERTU (opcode, operand->expr.X_add_number, 15, 11);
	  continue;

	case 'K':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if (reg >= REG_R0 && reg <= REG_R7)
	    INSERTU (opcode, reg - REG_R0, 21, 19);
	  else
	    {
              if (!check)
                as_bad (_("Register must be R0--R7"));
	      ret = -1;
	    }
	  continue;

	case 'L':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if (reg >= REG_R0 && reg <= REG_R7)
	    INSERTU (opcode, reg - REG_R0, 24, 22);
	  else
	    {
              if (!check)
                as_bad (_("Register must be R0--R7"));
	      ret = -1;
	    }
	  continue;

	case 'M':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if (reg == REG_R2 || reg == REG_R3)
	    INSERTU (opcode, reg - REG_R2, 22, 22);
	  else
	    {
              if (!check)
                as_bad (_("Destination register must be R2 or R3"));
	      ret = -1;
	    }
	  continue;

	case 'N':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if (reg == REG_R0 || reg == REG_R1)
	    INSERTU (opcode, reg - REG_R0, 23, 23);
	  else
	    {
              if (!check)
                as_bad (_("Destination register must be R0 or R1"));
	      ret = -1;
	    }
	  continue;

	case 'O':
	  if (!IS_CPU_TIC4X (tic4x_cpu))
	    break;
	  if (operand->mode != M_INDIRECT)
	    break;
	  /* Require either *+ARn(disp) or *ARn.  */
	  if (operand->expr.X_add_number != 0
	      && operand->expr.X_add_number != 0x18)
	    {
              if (!check)
                as_bad (_("Invalid indirect addressing mode"));
	      ret = -1;
	      continue;
	    }
	  INSERTU (opcode, operand->aregno - REG_AR0, 10, 8);
	  INSERTU (opcode, operand->disp, 15, 11);
	  continue;

	case 'P':		/* PC relative displacement.  */
	  /* Allow br label or br @@label.  */
	  if (operand->mode != M_IMMED && operand->mode != M_DIRECT)
	    break;
	  if (exp->X_op == O_constant)
	    {
	      if (exp->X_add_number >= -32768 && exp->X_add_number <= 32767)
		{
		  INSERTS (opcode, exp->X_add_number, 15, 0);
		  continue;
		}
	      else
		{
                  if (!check)
                    as_bad (_("Displacement value of %ld is too large"),
                            (long) exp->X_add_number);
		  ret = -1;
		  continue;
		}
	    }
	  tinsn->reloc = BFD_RELOC_16_PCREL;
	  tinsn->pcrel = 1;
	  tinsn->exp = *exp;
	  continue;

	case 'Q':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  INSERTU (opcode, reg, 15, 0);
	  continue;

        case 'q':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if ( (reg >= REG_R0 && reg <= REG_R7) 
               || (IS_CPU_TIC4X (tic4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
	    INSERTU (opcode, reg, 15, 0);
	  else
	    {
              if (!check)
                as_bad (_("Register must be Rn"));
	      ret = -1;
	    }
          continue;

	case 'R':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  INSERTU (opcode, reg, 20, 16);
	  continue;

        case 'r':
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if ( (reg >= REG_R0 && reg <= REG_R7) 
               || (IS_CPU_TIC4X (tic4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
	    INSERTU (opcode, reg, 20, 16);
	  else
	    {
              if (!check)
                as_bad (_("Register must be Rn"));
	      ret = -1;
	    }
          continue;

	case 'S':		/* Short immediate int.  */
	  if (operand->mode != M_IMMED && operand->mode != M_HI)
	    break;
	  if (exp->X_op == O_big)
	    {
              if (!check)
                as_bad (_("Floating point number not valid in expression"));
	      ret = -1;
	      continue;
	    }
	  if (exp->X_op == O_constant)
	    {
	      if (exp->X_add_number >= -32768 && exp->X_add_number <= 65535)
		{
		  INSERTS (opcode, exp->X_add_number, 15, 0);
		  continue;
		}
	      else
		{
		  if (!check)
                    as_bad (_("Signed immediate value %ld too large"),
                            (long) exp->X_add_number);
		  ret = -1;
		  continue;
		}
	    }
	  else if (exp->X_op == O_symbol)
	    {
	      if (operand->mode == M_HI)
		{
		  tinsn->reloc = BFD_RELOC_HI16;
		}
	      else
		{
		  tinsn->reloc = BFD_RELOC_LO16;
		}
	      tinsn->exp = *exp;
	      continue;
	    }
	  /* Handle cases like ldi foo - $, ar0  where foo
	     is a forward reference.  Perhaps we should check
	     for X_op == O_symbol and disallow things like
	     ldi foo, ar0.  */
	  tinsn->reloc = BFD_RELOC_16;
	  tinsn->exp = *exp;
	  continue;

	case 'T':		/* 5-bit immediate value for tic4x stik.  */
	  if (!IS_CPU_TIC4X (tic4x_cpu))
	    break;
	  if (operand->mode != M_IMMED)
	    break;
	  if (exp->X_op == O_constant)
	    {
	      if (exp->X_add_number < 16 && exp->X_add_number >= -16)
		{
		  INSERTS (opcode, exp->X_add_number, 20, 16);
		  continue;
		}
	      else
		{
                  if (!check)
                    as_bad (_("Immediate value of %ld is too large"),
                            (long) exp->X_add_number);
		  ret = -1;
		  continue;
		}
	    }
	  break;		/* No relocations allowed.  */

	case 'U':		/* Unsigned integer immediate.  */
	  if (operand->mode != M_IMMED && operand->mode != M_HI)
	    break;
	  if (exp->X_op == O_constant)
	    {
	      if (exp->X_add_number < (1 << 16) && exp->X_add_number >= 0)
		{
		  INSERTU (opcode, exp->X_add_number, 15, 0);
		  continue;
		}
	      else
		{
                  if (!check)
                    as_bad (_("Unsigned immediate value %ld too large"),
                            (long) exp->X_add_number);
		  ret = -1;
		  continue;
		}
	    }
	  else if (exp->X_op == O_symbol)
	    {
	      if (operand->mode == M_HI)
		tinsn->reloc = BFD_RELOC_HI16;
	      else
		tinsn->reloc = BFD_RELOC_LO16;

	      tinsn->exp = *exp;
	      continue;
	    }
	  tinsn->reloc = BFD_RELOC_16;
	  tinsn->exp = *exp;
	  continue;

	case 'V':		/* Trap numbers (immediate field).  */
	  if (operand->mode != M_IMMED)
	    break;
	  if (exp->X_op == O_constant)
	    {
	      if (exp->X_add_number < 512 && IS_CPU_TIC4X (tic4x_cpu))
		{
		  INSERTU (opcode, exp->X_add_number, 8, 0);
		  continue;
		}
	      else if (exp->X_add_number < 32 && IS_CPU_TIC3X (tic4x_cpu))
		{
		  INSERTU (opcode, exp->X_add_number | 0x20, 4, 0);
		  continue;
		}
	      else
		{
                  if (!check)
                    as_bad (_("Immediate value of %ld is too large"),
                            (long) exp->X_add_number);
		  ret = -1;
		  continue;
		}
	    }
	  break;		/* No relocations allowed.  */

	case 'W':		/* Short immediate int (0--7).  */
	  if (!IS_CPU_TIC4X (tic4x_cpu))
	    break;
	  if (operand->mode != M_IMMED)
	    break;
	  if (exp->X_op == O_big)
	    {
              if (!check)
                as_bad (_("Floating point number not valid in expression"));
	      ret = -1;
	      continue;
	    }
	  if (exp->X_op == O_constant)
	    {
	      if (exp->X_add_number >= -256 && exp->X_add_number <= 127)
		{
		  INSERTS (opcode, exp->X_add_number, 7, 0);
		  continue;
		}
	      else
		{
                  if (!check)
                    as_bad (_("Immediate value %ld too large"),
                            (long) exp->X_add_number);
		  ret = -1;
		  continue;
		}
	    }
	  tinsn->reloc = BFD_RELOC_16;
	  tinsn->exp = *exp;
	  continue;

	case 'X':		/* Expansion register for tic4x.  */
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if (reg >= REG_IVTP && reg <= REG_TVTP)
	    INSERTU (opcode, reg - REG_IVTP, 4, 0);
	  else
	    {
              if (!check)
                as_bad (_("Register must be ivtp or tvtp"));
	      ret = -1;
	    }
	  continue;

	case 'Y':		/* Address register for tic4x lda.  */
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if (reg >= REG_AR0 && reg <= REG_SP)
	    INSERTU (opcode, reg, 20, 16);
	  else
	    {
              if (!check)
                as_bad (_("Register must be address register"));
	      ret = -1;
	    }
	  continue;

	case 'Z':		/* Expansion register for tic4x.  */
	  if (operand->mode != M_REGISTER)
	    break;
	  reg = exp->X_add_number;
	  if (reg >= REG_IVTP && reg <= REG_TVTP)
	    INSERTU (opcode, reg - REG_IVTP, 20, 16);
	  else
	    {
              if (!check)
                as_bad (_("Register must be ivtp or tvtp"));
	      ret = -1;
	    }
	  continue;

	case '*':
	  if (operand->mode != M_INDIRECT)
	    break;
	  INSERTS (opcode, operand->disp, 7, 0);
	  INSERTU (opcode, operand->aregno - REG_AR0, 10, 8);
	  INSERTU (opcode, operand->expr.X_add_number, 15, 11);
	  continue;

	case '|':		/* treat as `,' if have ldi_ldi form.  */
	  if (tinsn->parallel)
	    {
	      if (--num_operands < 0)
		break;		/* Too few operands.  */
	      operand++;
	      if (operand->mode != M_PARALLEL)
		break;
	    }
	  /* Fall through.  */

	case ',':		/* Another operand.  */
	  if (--num_operands < 0)
	    break;		/* Too few operands.  */
	  operand++;
	  exp = &operand->expr;
	  continue;

	case ';':		/* Another optional operand.  */
	  if (num_operands == 1 || operand[1].mode == M_PARALLEL)
	    continue;
	  if (--num_operands < 0)
	    break;		/* Too few operands.  */
	  operand++;
	  exp = &operand->expr;
	  continue;

	default:
	  BAD_CASE (*args);
	}
      return 0;
    }
}

static void
tic4x_insn_check (tic4x_insn_t *tinsn)
{
  
  if (!strcmp (tinsn->name, "lda"))
    {
      if (tinsn->num_operands < 2 || tinsn->num_operands > 2)
        as_fatal ("Illegal internal LDA insn definition");

      if (tinsn->operands[0].mode == M_REGISTER
	  && tinsn->operands[1].mode == M_REGISTER
	  && tinsn->operands[0].expr.X_add_number == tinsn->operands[1].expr.X_add_number )
        as_bad (_("Source and destination register should not be equal"));
    }
  else if (!strcmp (tinsn->name, "ldi_ldi")
           || !strcmp (tinsn->name, "ldi1_ldi2")
           || !strcmp (tinsn->name, "ldi2_ldi1")
           || !strcmp (tinsn->name, "ldf_ldf")
           || !strcmp (tinsn->name, "ldf1_ldf2")
           || !strcmp (tinsn->name, "ldf2_ldf1") )
    {
      if (tinsn->num_operands < 4 && tinsn->num_operands > 5 )
        as_fatal ("Illegal internal %s insn definition", tinsn->name);
      
      if (tinsn->operands[1].mode == M_REGISTER
	  && tinsn->operands[tinsn->num_operands-1].mode == M_REGISTER
	  && tinsn->operands[1].expr.X_add_number == tinsn->operands[tinsn->num_operands-1].expr.X_add_number )
        as_warn (_("Equal parallell destination registers, one result will be discarded"));
    }
}

static void 
tic4x_insn_output (tic4x_insn_t *tinsn)
{
  char *dst;

  /* Grab another fragment for opcode.  */
  dst = frag_more (tinsn->nchars);

  /* Put out opcode word as a series of bytes in little endian order.  */
  md_number_to_chars (dst, tinsn->opcode, tinsn->nchars);

  /* Put out the symbol-dependent stuff.  */
  if (tinsn->reloc != NO_RELOC)
    {
      /* Where is the offset into the fragment for this instruction.  */
      fix_new_exp (frag_now,
		   dst - frag_now->fr_literal,	/* where */
		   tinsn->nchars,	/* size */
		   &tinsn->exp,
		   tinsn->pcrel,
		   tinsn->reloc);
    }
}

/* Parse the operands.  */
static int 
tic4x_operands_parse (char *s, tic4x_operand_t *operands, int num_operands)
{
  if (!*s)
    return num_operands;

  do
    s = tic4x_operand_parse (s, &operands[num_operands++]);
  while (num_operands < TIC4X_OPERANDS_MAX && *s++ == ',');

  if (num_operands > TIC4X_OPERANDS_MAX)
    {
      as_bad (_("Too many operands scanned"));
      return -1;
    }
  return num_operands;
}

/* Assemble a single instruction.  Its label has already been handled
   by the generic front end.  We just parse mnemonic and operands, and
   produce the bytes of data and relocation.  */
void 
md_assemble (char *str)
{
  int ok = 0;
  char *s;
  int i;
  int parsed = 0;
  tic4x_inst_t *inst;		/* Instruction template.  */
  tic4x_inst_t *first_inst;

  /* Scan for parallel operators */
  if (str)
    {
      s = str;
      while (*s && *s != '|')
        s++;
      
      if (*s && s[1]=='|')
        {
          if(insn->parallel)
            {
              as_bad (_("Parallel opcode cannot contain more than two instructions"));
              insn->parallel = 0;
              insn->in_use = 0;
              return;
            }
          
          /* Lets take care of the first part of the parallel insn */
          *s++ = 0;
          md_assemble(str);
          insn->parallel = 1;
          str = ++s;
          /* .. and let the second run though here */
        }
    }
  
  if (str && insn->parallel)
    {
      /* Find mnemonic (second part of parallel instruction).  */
      s = str;
      /* Skip past instruction mnemonic.  */
      while (*s && *s != ' ')
	s++;
      if (*s)			/* Null terminate for hash_find.  */
	*s++ = '\0';		/* and skip past null.  */
      strcat (insn->name, "_");
      strncat (insn->name, str, TIC4X_NAME_MAX - strlen (insn->name));

      insn->operands[insn->num_operands++].mode = M_PARALLEL;

      if ((i = tic4x_operands_parse
	   (s, insn->operands, insn->num_operands)) < 0)
	{
	  insn->parallel = 0;
	  insn->in_use = 0;
	  return;
	}
      insn->num_operands = i;
      parsed = 1;
    }

  if (insn->in_use)
    {
      if ((insn->inst = (struct tic4x_inst *)
	   hash_find (tic4x_op_hash, insn->name)) == NULL)
	{
	  as_bad (_("Unknown opcode `%s'."), insn->name);
	  insn->parallel = 0;
	  insn->in_use = 0;
	  return;
	}

      inst = insn->inst;
      first_inst = NULL;
      do
        {
          ok = tic4x_operands_match (inst, insn, 1);
          if (ok < 0)
            {
              if (!first_inst)
                first_inst = inst;
              ok = 0;
            }
      } while (!ok && !strcmp (inst->name, inst[1].name) && inst++);

      if (ok > 0)
        {
          tic4x_insn_check (insn);
          tic4x_insn_output (insn);
        }
      else if (!ok)
        {
          if (first_inst)
            tic4x_operands_match (first_inst, insn, 0);
          as_bad (_("Invalid operands for %s"), insn->name);
        }
      else
	as_bad (_("Invalid instruction %s"), insn->name);
    }

  if (str && !parsed)
    {
      /* Find mnemonic.  */
      s = str;
      while (*s && *s != ' ')	/* Skip past instruction mnemonic.  */
	s++;
      if (*s)			/* Null terminate for hash_find.  */
	*s++ = '\0';		/* and skip past null.  */
      strncpy (insn->name, str, TIC4X_NAME_MAX - 3);

      if ((i = tic4x_operands_parse (s, insn->operands, 0)) < 0)
	{
	  insn->inst = NULL;	/* Flag that error occurred.  */
	  insn->parallel = 0;
	  insn->in_use = 0;
	  return;
	}
      insn->num_operands = i;
      insn->in_use = 1;
    }
  else
    insn->in_use = 0;
  insn->parallel = 0;
}

void
tic4x_cleanup (void)
{
  if (insn->in_use)
    md_assemble (NULL);
}

/* Turn a string in input_line_pointer into a floating point constant
   of type type, and store the appropriate bytes in *litP.  The number
   of chars emitted is stored in *sizeP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  int ieee;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 's':		/* .single  */
    case 'S':
      ieee = 0;
      prec = 1;
      break;

    case 'd':		/* .double  */
    case 'D':
    case 'f':		/* .float  */
    case 'F':
      ieee = 0;
      prec = 2;		/* 1 32-bit word */
      break;

    case 'i':		/* .ieee */
    case 'I':
      prec = 2;
      ieee = 1;
      type = 'f';  /* Rewrite type to be usable by atof_ieee().  */
      break;

    case 'e':		/* .ldouble */
    case 'E':
      prec = 4;		/* 2 32-bit words */
      ieee = 0;
      break;

    default:
      *sizeP = 0;
      return _("Unrecognized or unsupported floating point constant");
    }

  if (ieee)
    t = atof_ieee (input_line_pointer, type, words);
  else
    t = tic4x_atof (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  /* This loops outputs the LITTLENUMs in REVERSE order; in accord with
     little endian byte order.  */
  /* SES: However it is required to put the words (32-bits) out in the
     correct order, hence we write 2 and 2 littlenums in little endian
     order, while we keep the original order on successive words.  */
  for (wordP = words; wordP<(words+prec) ; wordP+=2)
    {
      if (wordP < (words + prec - 1)) /* Dump wordP[1] (if we have one).  */
        {
          md_number_to_chars (litP, (valueT) (wordP[1]),
                              sizeof (LITTLENUM_TYPE));
          litP += sizeof (LITTLENUM_TYPE);
        }

      /* Dump wordP[0] */
      md_number_to_chars (litP, (valueT) (wordP[0]),
                          sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return NULL;
}

void 
md_apply_fix (fixS *fixP, valueT *value, segT seg ATTRIBUTE_UNUSED)
{
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  valueT val = *value;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_HI16:
      val >>= 16;
      break;

    case BFD_RELOC_LO16:
      val &= 0xffff;
      break;
    default:
      break;
    }

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_32:
      buf[3] = val >> 24;
    case BFD_RELOC_24:
    case BFD_RELOC_24_PCREL:
      buf[2] = val >> 16;
    case BFD_RELOC_16:
    case BFD_RELOC_16_PCREL:
    case BFD_RELOC_LO16:
    case BFD_RELOC_HI16:
      buf[1] = val >> 8;
      buf[0] = val;
      break;

    case NO_RELOC:
    default:
      as_bad (_("Bad relocation type: 0x%02x"), fixP->fx_r_type);
      break;
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0) fixP->fx_done = 1;
}

/* Should never be called for tic4x.  */
void 
md_convert_frag (bfd *headers ATTRIBUTE_UNUSED,
		 segT sec ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
{
  as_fatal ("md_convert_frag");
}

/* Should never be called for tic4x.  */
void
md_create_short_jump (char *ptr ATTRIBUTE_UNUSED,
		      addressT from_addr ATTRIBUTE_UNUSED,
		      addressT to_addr ATTRIBUTE_UNUSED,
		      fragS *frag ATTRIBUTE_UNUSED,
		      symbolS *to_symbol ATTRIBUTE_UNUSED)
{
  as_fatal ("md_create_short_jmp\n");
}

/* Should never be called for tic4x.  */
void
md_create_long_jump (char *ptr ATTRIBUTE_UNUSED,
		     addressT from_addr ATTRIBUTE_UNUSED,
		     addressT to_addr ATTRIBUTE_UNUSED,
		     fragS *frag ATTRIBUTE_UNUSED,
		     symbolS *to_symbol ATTRIBUTE_UNUSED)
{
  as_fatal ("md_create_long_jump\n");
}

/* Should never be called for tic4x.  */
int
md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED,
			       segT segtype ATTRIBUTE_UNUSED)
{
  as_fatal ("md_estimate_size_before_relax\n");
  return 0;
}


int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case OPTION_CPU:             /* cpu brand */
      if (TOLOWER (*arg) == 'c')
	arg++;
      tic4x_cpu = atoi (arg);
      if (!IS_CPU_TIC3X (tic4x_cpu) && !IS_CPU_TIC4X (tic4x_cpu))
	as_warn (_("Unsupported processor generation %d"), tic4x_cpu);
      break;

    case OPTION_REV:             /* cpu revision */
      tic4x_revision = atoi (arg);
      break;

    case 'b':
      as_warn (_("Option -b is depreciated, please use -mbig"));
    case OPTION_BIG:             /* big model */
      tic4x_big_model = 1;
      break;

    case 'p':
      as_warn (_("Option -p is depreciated, please use -mmemparm"));
    case OPTION_MEMPARM:         /* push args */
      tic4x_reg_args = 0;
      break;

    case 'r':			
      as_warn (_("Option -r is depreciated, please use -mregparm"));
    case OPTION_REGPARM:        /* register args */
      tic4x_reg_args = 1;
      break;

    case 's':
      as_warn (_("Option -s is depreciated, please use -msmall"));
    case OPTION_SMALL:		/* small model */
      tic4x_big_model = 0;
      break;

    case OPTION_IDLE2:
      tic4x_idle2 = 1;
      break;

    case OPTION_LOWPOWER:
      tic4x_lowpower = 1;
      break;

    case OPTION_ENHANCED:
      tic4x_enhanced = 1;
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream,
      _("\nTIC4X options:\n"
	"  -mcpu=CPU  -mCPU        select architecture variant. CPU can be:\n"
	"                            30 - TMS320C30\n"
	"                            31 - TMS320C31, TMS320LC31\n"
	"                            32 - TMS320C32\n"
        "                            33 - TMS320VC33\n"
	"                            40 - TMS320C40\n"
	"                            44 - TMS320C44\n"
        "  -mrev=REV               set cpu hardware revision (integer numbers).\n"
        "                          Combinations of -mcpu and -mrev will enable/disable\n"
        "                          the appropriate options (-midle2, -mlowpower and\n"
        "                          -menhanced) according to the selected type\n"
        "  -mbig                   select big memory model\n"
        "  -msmall                 select small memory model (default)\n"
        "  -mregparm               select register parameters (default)\n"
        "  -mmemparm               select memory parameters\n"
        "  -midle2                 enable IDLE2 support\n"
        "  -mlowpower              enable LOPOWER and MAXSPEED support\n"
        "  -menhanced              enable enhanced opcode support\n"));
}

/* This is called when a line is unrecognized.  This is used to handle
   definitions of TI C3x tools style local labels $n where n is a single
   decimal digit.  */
int 
tic4x_unrecognized_line (int c)
{
  int lab;
  char *s;

  if (c != '$' || ! ISDIGIT (input_line_pointer[0]))
    return 0;

  s = input_line_pointer;

  /* Let's allow multiple digit local labels.  */
  lab = 0;
  while (ISDIGIT (*s))
    {
      lab = lab * 10 + *s - '0';
      s++;
    }

  if (dollar_label_defined (lab))
    {
      as_bad (_("Label \"$%d\" redefined"), lab);
      return 0;
    }

  define_dollar_label (lab);
  colon (dollar_label_name (lab, 0));
  input_line_pointer = s + 1;

  return 1;
}

/* Handle local labels peculiar to us referred to in an expression.  */
symbolS *
md_undefined_symbol (char *name)
{
  /* Look for local labels of the form $n.  */
  if (name[0] == '$' && ISDIGIT (name[1]))
    {
      symbolS *symbolP;
      char *s = name + 1;
      int lab = 0;

      while (ISDIGIT ((unsigned char) *s))
	{
	  lab = lab * 10 + *s - '0';
	  s++;
	}
      if (dollar_label_defined (lab))
	{
	  name = dollar_label_name (lab, 0);
	  symbolP = symbol_find (name);
	}
      else
	{
	  name = dollar_label_name (lab, 1);
	  symbolP = symbol_find_or_make (name);
	}

      return symbolP;
    }
  return NULL;
}

/* Parse an operand that is machine-specific.  */
void
md_operand (expressionS *expressionP ATTRIBUTE_UNUSED)
{
}

/* Round up a section size to the appropriate boundary---do we need this?  */
valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
  return size;			/* Byte (i.e., 32-bit) alignment is fine?  */
}

static int 
tic4x_pc_offset (unsigned int op)
{
  /* Determine the PC offset for a C[34]x instruction.
     This could be simplified using some boolean algebra
     but at the expense of readability.  */
  switch (op >> 24)
    {
    case 0x60:			/* br */
    case 0x62:			/* call  (C4x) */
    case 0x64:			/* rptb  (C4x) */
      return 1;
    case 0x61:			/* brd */
    case 0x63:			/* laj */
    case 0x65:			/* rptbd (C4x) */
      return 3;
    case 0x66:			/* swi */
    case 0x67:
      return 0;
    default:
      break;
    }

  switch ((op & 0xffe00000) >> 20)
    {
    case 0x6a0:		/* bB */
    case 0x720:		/* callB */
    case 0x740:		/* trapB */
      return 1;

    case 0x6a2:		/* bBd */
    case 0x6a6:		/* bBat */
    case 0x6aa:		/* bBaf */
    case 0x722:		/* lajB */
    case 0x748:		/* latB */
    case 0x798:		/* rptbd */
      return 3;

    default:
      break;
    }

  switch ((op & 0xfe200000) >> 20)
    {
    case 0x6e0:		/* dbB */
      return 1;

    case 0x6e2:		/* dbBd */
      return 3;

    default:
      break;
    }

  return 0;
}

/* Exactly what point is a PC-relative offset relative TO?
   With the C3x we have the following:
   DBcond,  Bcond   disp + PC + 1 => PC
   DBcondD, BcondD  disp + PC + 3 => PC
 */
long
md_pcrel_from (fixS *fixP)
{
  unsigned char *buf;
  unsigned int op;

  buf = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
  op = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];

  return ((fixP->fx_where + fixP->fx_frag->fr_address) >> 2) +
    tic4x_pc_offset (op);
}

/* Fill the alignment area with NOP's on .text, unless fill-data
   was specified. */
int 
tic4x_do_align (int alignment,
		const char *fill,
		int len,
		int max)
{
  /* Because we are talking lwords, not bytes, adjust alignment to do words */
  alignment += 2;
  
  if (alignment != 0 && !need_pass_2)
    {
      if (fill == NULL)
        {
          if (subseg_text_p (now_seg))
	    {
	      char nop[4];

	      md_number_to_chars (nop, TIC_NOP_OPCODE, 4);
	      frag_align_pattern (alignment, nop, sizeof (nop), max);
	    }
          else
            frag_align (alignment, 0, max);
	}
      else if (len <= 1)
	frag_align (alignment, *fill, max);
      else
	frag_align_pattern (alignment, fill, len, max);
    }
  
  /* Return 1 to skip the default alignment function */
  return 1;
}

/* Look for and remove parallel instruction operator ||.  */
void 
tic4x_start_line (void)
{
  char *s = input_line_pointer;

  SKIP_WHITESPACE ();

  /* If parallel instruction prefix found at start of line, skip it.  */
  if (*input_line_pointer == '|' && input_line_pointer[1] == '|')
    {
      if (insn->in_use)
	{
	  insn->parallel = 1;
	  input_line_pointer ++;
          *input_line_pointer = ' ';
	  /* So line counters get bumped.  */
	  input_line_pointer[-1] = '\n';
	}
    }
  else
    {
      /* Write out the previous insn here */
      if (insn->in_use)
	md_assemble (NULL);
      input_line_pointer = s;
    }
}

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixP)
{
  arelent *reloc;

  reloc = (arelent *) xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
  reloc->address /= OCTETS_PER_BYTE;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("Reloc %d not supported by object file format"),
		    (int) fixP->fx_r_type);
      return NULL;
    }

  if (fixP->fx_r_type == BFD_RELOC_HI16)
    reloc->addend = fixP->fx_offset;
  else
    reloc->addend = fixP->fx_addnumber;

  return reloc;
}
@


1.34
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@a29 5
  o .align fills all section with NOP's when used regardless if has
    been used in .text or .data. (However the .align is primarily
    intended used in .text sections. If you require something else,
    use .align <size>,0x00)

d2964 1
a2964 3
	  /* FIXME: subseg_text_p tests SEC_CODE which isn't in allowed
	     section flags.  See bfd/coff-tic4x.c target vecs.  */
          if (1 || subseg_text_p (now_seg))
@


1.33
log
@	* config/tc-tic4x.c (tic4x_do_align): Remove ATTRIBUTE_UNUSED on
	params.  Properly generate NOP pattern.  Comment reason for
	subseg_text_p failure.
@
text
@d46 1
a46 2
  o Support 'abc' constants (that is 0x616263)
*/
d48 1
a49 1
#include "as.h"
@


1.32
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d2 2
a3 2
   Copyright (C) 1997,1998, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation. Inc.
d2958 4
a2961 4
tic4x_do_align (int alignment ATTRIBUTE_UNUSED,
		const char *fill ATTRIBUTE_UNUSED,
		int len ATTRIBUTE_UNUSED,
		int max ATTRIBUTE_UNUSED)
a2962 2
  unsigned long nop = TIC_NOP_OPCODE;

d2970 11
a2980 5
          /*if (subseg_text_p (now_seg))*/  /* FIXME: doesn't work for .text for some reason */
          frag_align_pattern( alignment, (const char *)&nop, sizeof(nop), max);
          return 1;
          /*else
            frag_align (alignment, 0, max);*/
@


1.31
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright (C) 1997,1998, 2002, 2003, 2005, 2006, 2007, 2008, 2009
d952 2
a954 1
  tic4x_insert_sym (name, value);
a970 1
  char *subsection_name;
a990 1
      subsection_name = input_line_pointer;
@


1.30
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d1251 1
a1251 1
  static int index = 0;
d1261 5
a1265 5
  insts[index].name = names;
  insts[index].opcode = opcode;
  insts[index].opmask = 0xffffffff;
  insts[index].args = args;
  index++;
d1272 1
a1272 1
  return &insts[index - 1];
d1675 1
a1675 1
tic4x_operands_match (tic4x_inst_t *inst, tic4x_insn_t *insn, int check)
d1679 2
a1680 2
  int num_operands = insn->num_operands;
  tic4x_operand_t *operand = insn->operands;
d1691 3
a1693 3
  insn->nchars = 4;		/* Instructions always 4 bytes.  */
  insn->reloc = NO_RELOC;
  insn->pcrel = 0;
d1697 1
a1697 1
      insn->opcode = opcode;
d1709 1
a1709 1
	      insn->opcode = opcode;
d1738 2
a1739 2
	      insn->reloc = BFD_RELOC_HI16;
	      insn->exp = *exp;
d1755 2
a1756 2
	      insn->reloc = BFD_RELOC_LO16;
	      insn->exp = *exp;
d1797 2
a1798 2
	      insn->reloc = BFD_RELOC_24_PCREL;
	      insn->pcrel = 1;
d1802 2
a1803 2
	      insn->reloc = BFD_RELOC_24;
	      insn->pcrel = 0;
d1805 1
a1805 1
	  insn->exp = *exp;
d2051 3
a2053 3
	  insn->reloc = BFD_RELOC_16_PCREL;
	  insn->pcrel = 1;
	  insn->exp = *exp;
d2130 1
a2130 1
		  insn->reloc = BFD_RELOC_HI16;
d2134 1
a2134 1
		  insn->reloc = BFD_RELOC_LO16;
d2136 1
a2136 1
	      insn->exp = *exp;
d2143 2
a2144 2
	  insn->reloc = BFD_RELOC_16;
	  insn->exp = *exp;
d2192 1
a2192 1
		insn->reloc = BFD_RELOC_HI16;
d2194 1
a2194 1
		insn->reloc = BFD_RELOC_LO16;
d2196 1
a2196 1
	      insn->exp = *exp;
d2199 2
a2200 2
	  insn->reloc = BFD_RELOC_16;
	  insn->exp = *exp;
d2257 2
a2258 2
	  insn->reloc = BFD_RELOC_16;
	  insn->exp = *exp;
d2312 1
a2312 1
	  if (insn->parallel)
d2346 1
a2346 1
tic4x_insn_check (tic4x_insn_t *insn)
d2349 1
a2349 1
  if (!strcmp(insn->name, "lda"))
d2351 1
a2351 1
      if (insn->num_operands < 2 || insn->num_operands > 2)
d2354 3
a2356 3
      if ( insn->operands[0].mode == M_REGISTER
           && insn->operands[1].mode == M_REGISTER
           && insn->operands[0].expr.X_add_number == insn->operands[1].expr.X_add_number )
d2359 6
a2364 6
  else if( !strcmp(insn->name, "ldi_ldi")
           || !strcmp(insn->name, "ldi1_ldi2")
           || !strcmp(insn->name, "ldi2_ldi1")
           || !strcmp(insn->name, "ldf_ldf")
           || !strcmp(insn->name, "ldf1_ldf2")
           || !strcmp(insn->name, "ldf2_ldf1") )
d2366 2
a2367 2
      if ( insn->num_operands < 4 && insn->num_operands > 5 )
        as_fatal ("Illegal internal %s insn definition", insn->name);
d2369 3
a2371 3
      if ( insn->operands[1].mode == M_REGISTER
           && insn->operands[insn->num_operands-1].mode == M_REGISTER
           && insn->operands[1].expr.X_add_number == insn->operands[insn->num_operands-1].expr.X_add_number )
d2377 1
a2377 1
tic4x_insn_output (tic4x_insn_t *insn)
d2382 1
a2382 1
  dst = frag_more (insn->nchars);
d2385 1
a2385 1
  md_number_to_chars (dst, insn->opcode, insn->nchars);
d2388 1
a2388 1
  if (insn->reloc != NO_RELOC)
d2393 4
a2396 4
		   insn->nchars,	/* size */
		   &insn->exp,
		   insn->pcrel,
		   insn->reloc);
@


1.29
log
@        Add support for Xilinx MicroBlaze processor.

        * bfd/Makefile.am: Add cpu-microblaze.{lo,c}, elf32-microblaze.{lo,c}.
        * bfd/Makefile.in: Same.
        * bfd/archures.c: Add bfd_arch_microblaze.
        * bfd/bfd-in2.h: Regenerate.
        * bfd/config.bfd: Add microblaze target.
        * bfd/configure: Add bfd_elf32_microblaze_vec target.
        * bfd/configure.in: Same.
        * bfd/cpu-microblaze.c: New.
        * bfd/elf32-microblaze.c: New.
        * bfd/libbfd-in.h: Add prototype _bfd_dwarf2_fixup_section_debug_loc().
        * bfd/libbfd.h: Regenerate.
        * bfd/reloc.c: Add MICROBLAZE relocations.
        * bfd/section.c: Add struct relax_table and relax_count to section.
        * bfd/targets.c: Add bfd_elf32_microblaze_vec.
        * binutils/MAINTAINERS: Add self as maintainer.
        * binutils/readelf.c: Include elf/microblaze.h, add EM_MICROBLAZE &
        EM_MICROBLAZE_OLD to guess_is_rela(), dump_relocations(),
        get_machine_name().
        * config.sub: Add microblaze target.
        * configure: Same.
        * configure.ac: Same.
        * gas/Makefile.am: add microblaze to CPU_TYPES, config/tc-microblaze.c to
        TARGET_CPU_CFILES, config/tc-microblaze.h to TARGET_CPU_HFILES, add
        DEP_microblaze_elf target.
        * gas/Makefile.in: Same.
        * gas/config/tc-microblaze.c: Add MicroBlaze assembler.
        * gas/config/tc-microblaze.h: Add header for tc-microblaze.c.
        * gas/configure: Add microblaze target.
        * gas/configure.in: Same.
        * gas/configure.tgt: Same.
        * gas/doc/Makefile.am: Add c-microblaze.texi to CPU_DOCS.
        * gas/doc/Makefile.in: Same.
        * gas/doc/all.texi: Set MICROBLAZE.
        * gas/doc/as.texinfo: Add MicroBlaze doc links.
        * gas/doc/c-microblaze.texi: New MicroBlaze docs.
        * include/dis-asm.h: Decl print_insn_microblaze().
        * include/elf/common.h: Define EM_MICROBLAZE & EM_MICROBLAZE_OLD.
        * include/elf/microblaze.h: New reloc definitions.
        * ld/Makefile.am: Add eelf32mb_linux.o, eelf32microblaze.o to
        ALL_EMULATIONS, targets.
        * ld/Makefile.in: Same.
        * ld/configure.tgt: Add microblaze*-linux*, microblaze* targets.
        * ld/emulparams/elf32mb_linux.sh: New.
        * ld/emulparams/elf32microblaze.sh. New.
        * ld/scripttempl/elfmicroblaze.sc: New.
        * opcodes/Makefile.am: Add microblaze-opc.h to HFILES, microblaze-dis.c to
        CFILES, microblaze-dis.lo to ALL_MACHINES, targets.
        * opcodes/Makefile.in: Same.
        * opcodes/configure: Add bfd_microblaze_arch target.
        * opcodes/configure.in: Same.
        * opcodes/disassemble.c: Define ARCH_microblaze, return
        print_insn_microblaze().
        * opcodes/microblaze-dis.c: New MicroBlaze disassembler.
        * opcodes/microblaze-opc.h: New MicroBlaze opcode definitions.
        * opcodes/microblaze-opcm.h: New MicroBlaze opcode types.
@
text
@d1519 1
a1519 1
  char *new;
d1527 1
a1527 1
  new = input_line_pointer;
d1669 1
a1669 1
    new = input_line_pointer;
d1671 1
a1671 1
  return new;
@


1.28
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d1288 2
a1289 2
     oplevel setting */
  if (!insts->oplevel & tic4x_oplevel)
@


1.27
log
@     * coffgen.c (coff_write_symbols): Check to see if a symbol's flags
       do not match it class and if necessary update the class.
       (null_error_handler): New function.  Suppresses the generation of
       bfd error messages.
     * coff64-rs6000.c (bfd_xcoff_backend_data): Update comment.
     * config/tc-tic4x.c (tic4x_globl): Call S_SET_EXTERNAL as well as
     S_SET_STORAGE_CLASS.
@
text
@d2 1
a2 1
   Copyright (C) 1997,1998, 2002, 2003, 2005, 2006, 2007, 2008
d399 1
a399 1
        as_bad ("Nan, using zero.");
d521 1
a521 1
    as_bad ("Cannot represent exponent in %d bits", exponent_bits);
d604 1
a604 1
      as_bad ("Invalid floating point number");
d614 1
a614 1
      as_bad ("Invalid floating point number");
d734 1
a734 1
      as_bad ("Comma expected\n");
d774 1
a774 1
      as_bad (".bss size argument missing\n");
d782 1
a782 1
      as_bad (".bss size %ld < 0!", (long) size);
d916 1
a916 1
              as_bad("Non-constant symbols not allowed\n");
d947 1
a947 1
      as_bad ("Symbol missing\n");
d994 1
a994 1
      as_warn (".sect: subsection name ignored");
d1022 1
a1022 1
	as_warn ("Error setting flags for \"%s\": %s", name,
d1053 1
a1053 1
	  as_bad (".set syntax invalid\n");
d1111 1
a1111 1
    as_warn (".usect: non-zero alignment flag ignored");
d1122 1
a1122 1
    as_warn ("Error setting flags for \"%s\": %s", name,
d1142 1
a1142 1
    as_bad ("This assembler does not support processor generation %ld",
d1146 1
a1146 1
    as_warn ("Changing processor generation on fly not supported...");
d1445 1
a1445 1
	  as_bad ("Auxiliary register AR0--AR7 required for indirect");
d1459 1
a1459 1
	      as_bad ("Bad displacement %d (require 0--255)\n",
d1477 1
a1477 1
	      as_bad ("Index register IR0,IR1 required for displacement");
d1546 1
a1546 1
	as_bad ("Expecting a register name");
d1558 1
a1558 1
	    as_bad ("Number too large");	/* bignum required */
d1581 1
a1581 1
	    as_bad ("Number too large");	/* bignum required.  */
d1598 1
a1598 1
	as_bad ("Expecting a constant value");
d1605 1
a1605 1
	as_bad ("Bad direct addressing construct %s", s);
d1609 1
a1609 1
	    as_bad ("Direct value of %ld is not suitable",
d1633 1
a1633 1
	as_bad ("Unknown indirect addressing mode");
d1650 1
a1650 1
	    as_bad ("Number too large");	/* bignum required.  */
d1730 1
a1730 1
                    as_bad ("Immediate value of %ld is too large for ldf",
d1770 1
a1770 1
                as_bad ("Destination register must be ARn");
d1789 1
a1789 1
                    as_bad ("Immediate value of %ld is too large",
d1818 1
a1818 1
                as_bad ("Invalid indirect addressing mode");
d1842 1
a1842 1
                as_bad ("Register must be Rn");
d1882 1
a1882 1
                as_bad ("Register must be Rn");
d1896 1
a1896 1
                as_bad ("Register must be R0--R7");
d1920 1
a1920 1
                as_bad ("Invalid indirect addressing mode displacement %d",
d1948 1
a1948 1
                as_bad ("Invalid indirect addressing mode displacement %d",
d1966 1
a1966 1
                as_bad ("Register must be R0--R7");
d1980 1
a1980 1
                as_bad ("Register must be R0--R7");
d1994 1
a1994 1
                as_bad ("Destination register must be R2 or R3");
d2008 1
a2008 1
                as_bad ("Destination register must be R0 or R1");
d2023 1
a2023 1
                as_bad ("Invalid indirect addressing mode");
d2045 1
a2045 1
                    as_bad ("Displacement value of %ld is too large",
d2073 1
a2073 1
                as_bad ("Register must be Rn");
d2095 1
a2095 1
                as_bad ("Register must be Rn");
d2106 1
a2106 1
                as_bad ("Floating point number not valid in expression");
d2120 1
a2120 1
                    as_bad ("Signed immediate value %ld too large",
d2162 1
a2162 1
                    as_bad ("Immediate value of %ld is too large",
d2183 1
a2183 1
                    as_bad ("Unsigned immediate value %ld too large",
d2221 1
a2221 1
                    as_bad ("Immediate value of %ld is too large",
d2237 1
a2237 1
                as_bad ("Floating point number not valid in expression");
d2251 1
a2251 1
                    as_bad ("Immediate value %ld too large",
d2270 1
a2270 1
                as_bad ("Register must be ivtp or tvtp");
d2284 1
a2284 1
                as_bad ("Register must be address register");
d2298 1
a2298 1
                as_bad ("Register must be ivtp or tvtp");
d2357 1
a2357 1
        as_bad ("Source and destination register should not be equal");
d2372 1
a2372 1
        as_warn ("Equal parallell destination registers, one result will be discarded");
d2413 1
a2413 1
      as_bad ("Too many operands scanned");
d2443 1
a2443 1
              as_bad ("Parallel opcode cannot contain more than two instructions");
d2488 1
a2488 1
	  as_bad ("Unknown opcode `%s'.", insn->name);
d2516 1
a2516 1
          as_bad ("Invalid operands for %s", insn->name);
d2519 1
a2519 1
	as_bad ("Invalid instruction %s", insn->name);
d2668 1
a2668 1
      as_bad ("Bad relocation type: 0x%02x", fixP->fx_r_type);
d2726 1
a2726 1
	as_warn ("Unsupported processor generation %d", tic4x_cpu);
d2734 1
a2734 1
      as_warn ("Option -b is depreciated, please use -mbig");
d2740 1
a2740 1
      as_warn ("Option -p is depreciated, please use -mmemparm");
d2746 1
a2746 1
      as_warn ("Option -r is depreciated, please use -mregparm");
d2752 1
a2752 1
      as_warn ("Option -s is depreciated, please use -msmall");
d2825 1
a2825 1
      as_bad ("Label \"$%d\" redefined", lab);
d3033 1
a3033 1
		    "Reloc %d not supported by object file format",
@


1.26
log
@	* config/tc-tic4x.c (tic4x_operands_parse): Make static.
@
text
@d824 1
@


1.25
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d2400 1
a2400 1
int 
@


1.24
log
@* config/tc-tic4x.c (tic4x_insn_insert): Add const qualifier to
  argument.
  (tic4x_insn_add): Likewise.
  (md_begin): Drop cast that was discarding a const qualifier.
  * config/tc-d30v.c (get_reloc): Add const qualifier to op
  argument.
  (build_insn): Drop cast that was discarding a const qualifier.
@
text
@d147 11
a157 72
static int tic4x_gen_to_words
  PARAMS ((FLONUM_TYPE, LITTLENUM_TYPE *, int ));
static char *tic4x_atof
  PARAMS ((char *, char, LITTLENUM_TYPE * ));
static void tic4x_insert_reg
  PARAMS ((char *, int ));
static void tic4x_insert_sym
  PARAMS ((char *, int ));
static char *tic4x_expression
  PARAMS ((char *, expressionS *));
static char *tic4x_expression_abs
  PARAMS ((char *, offsetT *));
static void tic4x_emit_char
  PARAMS ((char, int));
static void tic4x_seg_alloc
  PARAMS ((char *, segT, int, symbolS *));
static void tic4x_asg
  PARAMS ((int));
static void tic4x_bss
  PARAMS ((int));
static void tic4x_globl
  PARAMS ((int));
static void tic4x_cons
  PARAMS ((int));
static void tic4x_stringer
  PARAMS ((int));
static void tic4x_eval
  PARAMS ((int));
static void tic4x_newblock
  PARAMS ((int));
static void tic4x_sect
  PARAMS ((int));
static void tic4x_set
  PARAMS ((int));
static void tic4x_usect
  PARAMS ((int));
static void tic4x_version
  PARAMS ((int));
static void tic4x_init_regtable
  PARAMS ((void));
static void tic4x_init_symbols
  PARAMS ((void));
static int tic4x_inst_insert (const tic4x_inst_t *);
static tic4x_inst_t *tic4x_inst_make
  PARAMS ((char *, unsigned long, char *));
static int tic4x_inst_add (const tic4x_inst_t *);
void tic4x_end
  PARAMS ((void));
static int tic4x_indirect_parse
  PARAMS ((tic4x_operand_t *, const tic4x_indirect_t *));
static char *tic4x_operand_parse
  PARAMS ((char *, tic4x_operand_t *));
static int tic4x_operands_match
  PARAMS ((tic4x_inst_t *, tic4x_insn_t *, int));
static void tic4x_insn_check
  PARAMS ((tic4x_insn_t *));
static void tic4x_insn_output
  PARAMS ((tic4x_insn_t *));
static int tic4x_operands_parse
  PARAMS ((char *, tic4x_operand_t *, int ));
void tic4x_cleanup
  PARAMS ((void));
int tic4x_unrecognized_line
  PARAMS ((int));
static int tic4x_pc_offset
  PARAMS ((unsigned int));
int tic4x_do_align
  PARAMS ((int, const char *, int, int));
void tic4x_start_line
  PARAMS ((void));
arelent *tc_gen_reloc
  PARAMS ((asection *, fixS *));
d242 1
a242 4
tic4x_gen_to_words (flonum, words, precision)
     FLONUM_TYPE flonum;
     LITTLENUM_TYPE *words;
     int precision;
d556 1
a556 4
tic4x_atof (str, what_kind, words)
     char *str;
     char what_kind;
     LITTLENUM_TYPE *words;
d629 1
a629 3
tic4x_insert_reg (regname, regnum)
     char *regname;
     int regnum;
d645 1
a645 3
tic4x_insert_sym (symname, value)
     char *symname;
     int value;
d656 1
a656 3
tic4x_expression (str, exp)
     char *str;
     expressionS *exp;
d670 1
a670 3
tic4x_expression_abs (str, value)
     char *str;
     offsetT *value;
d684 1
a684 3
tic4x_emit_char (c,b)
     char c;
     int b;
d694 4
a697 5
tic4x_seg_alloc (name, seg, size, symbolP)
     char *name ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     int size;
     symbolS *symbolP;
d719 1
a719 2
tic4x_asg (x)
     int x ATTRIBUTE_UNUSED;
d747 1
a747 1
    hash_replace (tic4x_asg_hash, name, (PTR) str);
d749 1
a749 1
    hash_insert (tic4x_asg_hash, name, (PTR) str);
d756 1
a756 2
tic4x_bss (x)
     int x ATTRIBUTE_UNUSED;
d810 1
a810 2
tic4x_globl (ignore)
     int ignore ATTRIBUTE_UNUSED;
d839 1
a839 2
tic4x_cons (bytes)
     int bytes;
d882 1
a882 2
tic4x_stringer (append_zero)
     int append_zero; /*ex: bytes */
d935 1
a935 2
tic4x_eval (x)
     int x ATTRIBUTE_UNUSED;
d957 1
a957 2
tic4x_newblock (x)
     int x ATTRIBUTE_UNUSED;
d965 1
a965 2
tic4x_sect (x)
     int x ATTRIBUTE_UNUSED;
d1038 1
a1038 2
tic4x_set (x)
     int x ATTRIBUTE_UNUSED;
d1068 1
a1068 2
tic4x_usect (x)
     int x ATTRIBUTE_UNUSED;
d1134 1
a1134 2
tic4x_version (x)
     int x ATTRIBUTE_UNUSED;
d1151 1
a1151 1
tic4x_init_regtable ()
d1169 1
a1169 1
tic4x_init_symbols ()
d1235 1
a1235 1
  retval = hash_insert (tic4x_op_hash, inst->name, (PTR) inst);
d1246 1
a1246 4
tic4x_inst_make (name, opcode, args)
     char *name;
     unsigned long opcode;
     char *args;
d1347 1
a1347 1
md_begin ()
d1404 1
a1404 1
tic4x_end ()
d1411 2
a1412 3
tic4x_indirect_parse (operand, indirect)
     tic4x_operand_t *operand;
     const tic4x_indirect_t *indirect;
d1510 1
a1510 3
tic4x_operand_parse (s, operand)
     char *s;
     tic4x_operand_t *operand;
d1674 1
a1674 4
tic4x_operands_match (inst, insn, check)
     tic4x_inst_t *inst;
     tic4x_insn_t *insn;
     int check;
d2345 1
a2345 2
tic4x_insn_check (insn)
     tic4x_insn_t *insn;
d2376 1
a2376 2
tic4x_insn_output (insn)
     tic4x_insn_t *insn;
d2401 1
a2401 4
tic4x_operands_parse (s, operands, num_operands)
     char *s;
     tic4x_operand_t *operands;
     int num_operands;
d2422 1
a2422 2
md_assemble (str)
     char *str;
d2547 1
a2547 1
tic4x_cleanup ()
d2632 1
a2632 4
md_apply_fix (fixP, value, seg)
     fixS *fixP;
     valueT *value;
     segT seg ATTRIBUTE_UNUSED;
d2676 3
a2678 4
md_convert_frag (headers, sec, fragP)
     bfd *headers ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d2685 5
a2689 6
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr ATTRIBUTE_UNUSED;
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d2696 5
a2700 6
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr ATTRIBUTE_UNUSED;
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d2707 2
a2708 3
md_estimate_size_before_relax (fragP, segtype)
     register fragS *fragP ATTRIBUTE_UNUSED;
     segT segtype ATTRIBUTE_UNUSED;
d2716 1
a2716 3
md_parse_option (c, arg)
     int c;
     char *arg;
d2776 1
a2776 2
md_show_usage (stream)
     FILE *stream;
d2804 1
a2804 2
tic4x_unrecognized_line (c)
     int c;
d2837 1
a2837 2
md_undefined_symbol (name)
     char *name;
d2869 1
a2869 2
md_operand (expressionP)
     expressionS *expressionP ATTRIBUTE_UNUSED;
d2875 1
a2875 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d2881 1
a2881 2
tic4x_pc_offset (op)
     unsigned int op;
d2943 1
a2943 2
md_pcrel_from (fixP)
     fixS *fixP;
d2958 4
a2961 5
tic4x_do_align (alignment, fill, len, max)
     int alignment ATTRIBUTE_UNUSED;
     const char *fill ATTRIBUTE_UNUSED;
     int len ATTRIBUTE_UNUSED;
     int max ATTRIBUTE_UNUSED;
d2990 1
a2990 1
tic4x_start_line ()
d3018 1
a3018 3
tc_gen_reloc (seg, fixP)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixP;
@


1.23
log
@Remove duplicate definitions of the md_atof() function
@
text
@d2 1
a2 1
   Copyright (C) 1997,1998, 2002, 2003, 2005, 2006, 2007
d189 1
a189 2
static int tic4x_inst_insert
  PARAMS ((tic4x_inst_t *));
d192 1
a192 2
static int tic4x_inst_add
  PARAMS ((tic4x_inst_t *));
d1315 1
a1315 2
tic4x_inst_insert (inst)
     tic4x_inst_t *inst;
d1368 1
a1368 2
tic4x_inst_add (insts)
     tic4x_inst_t *insts;
d1480 1
a1480 1
    ok &= tic4x_inst_add ((void *) &tic4x_insts[i]);
@


1.22
log
@Switch to GPLv3
@
text
@d2663 1
a2663 1
   of LITTLENUMS emitted is stored in *sizeP.  An error message is
d2667 1
a2667 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d2677 1
a2677 1
    case 's':			/* .single */
d2683 1
a2683 1
    case 'd':			/* .double */
d2685 1
a2685 1
    case 'f':			/* .float or .single */
d2688 1
a2688 1
      prec = 2;			/* 1 32-bit word */
d2691 1
a2691 1
    case 'i':			/* .ieee */
d2695 1
a2695 1
      type = 'f';  /* Rewrite type to be usable by atof_ieee() */
d2698 1
a2698 1
    case 'e':			/* .ldouble */
d2700 1
a2700 1
      prec = 4;			/* 2 32-bit words */
d2706 1
a2706 1
      return "Bad call to md_atof()";
d2721 2
a2722 2
     order, while we keep the original order on successive words. */
  for(wordP = words; wordP<(words+prec) ; wordP+=2)
d2724 1
a2724 1
      if (wordP<(words+prec-1)) /* Dump wordP[1] (if we have one) */
d2736 1
a2736 1
  return 0;
@


1.21
log
@remove some duplicate #include's.
@
text
@d2 2
a3 1
   Copyright (C) 1997,1998, 2002, 2003, 2005, 2006 Free Software Foundation.
d11 1
a11 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.20
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@d2 1
a2 1
   Copyright (C) 1997,1998, 2002, 2003, 2005 Free Software Foundation.
a47 1
#include <stdio.h>
a52 2
#include "symbols.h"
#include "listing.h"
@


1.19
log
@gas/
2005-09-30  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-tic4x.c (tic4x_set): Advance input_line_pointer past
	(removed) comma.
@
text
@d2643 1
a2643 1
	  insn->inst = NULL;	/* Flag that error occured.  */
@


1.18
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d1147 1
@


1.17
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a259 1
const int md_reloc_size = RELSZ;	/* Coff headers.  */
@


1.16
log
@Update the address and phone number of the FSF
@
text
@d2745 1
a2745 1
md_apply_fix3 (fixP, value, seg)
@


1.15
log
@Changed my own mail address
@
text
@d20 2
a21 2
   the Free Software Foundation, 59 Temple Place - Suite 330, 
   Boston, MA 02111-1307, USA.  */
@


1.14
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d326 1
a326 1
  /* NOTE: Svein Seldal <Svein.Seldal@@solidas.com>
@


1.13
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d160 1
a160 1
  PARAMS ((char *, int *));
d750 1
a750 1
     int *value;
d846 1
a846 1
  int size;
d867 1
a867 1
      as_bad (".bss size %d < 0!", size);
d1027 1
a1027 1
  int value;
d1063 1
a1063 1
  int num;
d1166 1
a1166 1
  int size, alignment_flag;
d1229 1
a1229 1
  unsigned int temp;
d1234 2
a1235 2
    as_bad ("This assembler does not support processor generation %d",
	    temp);
d1237 1
a1237 1
  if (tic4x_cpu && temp != tic4x_cpu)
d2678 1
a2678 1
  unsigned char *t;
d2721 1
a2721 1
  t = litP;
d3075 1
a3075 1
  unsigned char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
d3078 1
@


1.12
log
@	* config/atof-tahoe.c: Fix comment typos.
	* config/m68k-parse.y: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-bout.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/te-delt88.h: Likewise.
	* config/te-delta.h: Likewise.
	* config/te-generic.h: Likewise.
	* config/te-macos.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-psos.h: Likewise.
	* config/te-sun3.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/xtensa-relax.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1997,1998, 2002, 2003 Free Software Foundation.
d711 1
a711 1
    buf[i] = islower (regname[i]) ? TOUPPER (regname[i]) : regname[i];
d3093 1
a3093 1
  unsigned long nop = NOP_OPCODE;
@


1.11
log
@	* config/tc-mcore.h: Remove prototypes already in tc.h.
	* config/tc-tic4x.c: Likewise.
@
text
@d30 1
a30 1
    been used in .text or .data. (However the .align is primarely
d34 1
a34 1
  o .align: Implement a 'bu' insn if the number of nop's exeeds 4
d300 1
a300 1
                                   reqires it... */
d437 1
a437 1
     To save a lot of unecessary shifting we only have to consider
d3095 1
a3095 1
  /* Because we are talking lwords, not bytes, adjust aligment to do words */
d3102 1
a3102 1
          /*if (subseg_text_p (now_seg))*/  /* FIXME: doesnt work for .text for some reason */
d3114 1
a3114 1
  /* Return 1 to skip the default aligment function */
@


1.10
log
@Remove uses of ctype.h
@
text
@a196 2
void md_begin
  PARAMS ((void));
a210 2
void md_assemble
  PARAMS ((char *));
a212 16
char *md_atof
  PARAMS ((int, char *, int *));
void md_apply_fix3
  PARAMS ((fixS *, valueT *, segT ));
void md_convert_frag
  PARAMS ((bfd *, segT, fragS *));
void md_create_short_jump
  PARAMS ((char *, addressT, addressT, fragS *, symbolS *));
void md_create_long_jump
  PARAMS ((char *, addressT, addressT, fragS *, symbolS *));
int md_estimate_size_before_relax
  PARAMS ((register fragS *, segT));
int md_parse_option
  PARAMS ((int, char *));
void md_show_usage
  PARAMS ((FILE *));
a214 6
symbolS *md_undefined_symbol
  PARAMS ((char *));
void md_operand
  PARAMS ((expressionS *));
valueT md_section_align
  PARAMS ((segT, valueT));
a216 2
long md_pcrel_from
  PARAMS ((fixS *));
@


1.9
log
@Reverted faulty code
@
text
@d49 1
a49 2
#include <ctype.h>

d739 1
a739 1
    buf[i] = islower (regname[i]) ? toupper (regname[i]) : regname[i];
d1558 1
a1558 1
	  while (isalnum (*s))
d1625 1
a1625 1
	  if (tolower (*s) != *n)
d2871 1
a2871 1
      if (tolower (*arg) == 'c')
d2961 1
a2961 1
  if (c != '$' || !isdigit (input_line_pointer[0]))
d2968 1
a2968 1
  while (isdigit (*s))
d2993 1
a2993 1
  if (name[0] == '$' && isdigit (name[1]))
d2999 1
a2999 1
      while (isdigit ((unsigned char) *s))
@


1.8
log
@
	* config/tc-tic4x.c (md_assemble): Added support for one-line parallel insns.
	(tic4x_start_line): Fixed scrub bug and added error for three-element
	parallel insns.
@
text
@a3165 4
      else
        {
          as_bad ("Parallel opcode cannot contain more than two instructions");
        }
@


1.7
log
@Namespace cleanup for the tic4x target. Replace s/c4x/tic4x/ and s/c3x/tic3x/. 2003 copyright update
@
text
@d2570 26
a2597 2
      int star;

d2601 1
a2601 1
      while (*s && *s != ' ' && *s != '*')
a2602 1
      star = *s == '*';
a2607 6
      /* Kludge to overcome problems with scrubber removing
         space between mnemonic and indirect operand (starting with *)
         on second line of parallel instruction.  */
      if (star)
	*--s = '*';

d3161 2
a3162 1
	  input_line_pointer += 2;
d3166 4
d3173 1
@


1.7.2.1
log
@
	* config/tc-tic4x.c (md_assemble): Added support for one-line parallel insns.
	* config/tc-tic4x.h: Added DOUBLEBAR_PARALLEL definition
@
text
@a2569 26
  /* Scan for parallel operators */
  if (str)
    {
      s = str;
      while (*s && *s != '|')
        s++;
      
      if (*s && s[1]=='|')
        {
          if(insn->parallel)
            {
              as_bad ("Parallel opcode cannot contain more than two instructions");
              insn->parallel = 0;
              insn->in_use = 0;
              return;
            }
          
          /* Lets take care of the first part of the parallel insn */
          *s++ = 0;
          md_assemble(str);
          insn->parallel = 1;
          str = ++s;
          /* .. and let the second run though here */
        }
    }
  
d2572 2
d2577 1
a2577 1
      while (*s && *s != ' ')
d2579 1
d2585 6
d3144 1
a3144 2
	  input_line_pointer ++;
          *input_line_pointer = ' ';
@


1.6
log
@
	* gas/config/tc-tic4x.c (c4x_operands_match): Bugfix in direct
	mode
@
text
@d1 2
a2 2
/* tc-c4x.c -- Assemble for the Texas Instruments TMS320C[34]x.
   Copyright (C) 1997,1998, 2002 Free Software Foundation.
d59 1
a59 1
   assembly tools.  With C4X_ALT_SYNTAX defined we are more
d64 1
a64 1
#define C4X_ALT_SYNTAX
d70 1
a70 1
static struct hash_control *c4x_op_hash = NULL;
d73 1
a73 1
static struct hash_control *c4x_asg_hash = NULL;
d75 8
a82 8
static unsigned int c4x_cpu = 0;	/* Default to TMS320C40.  */
static unsigned int c4x_revision = 0;   /* CPU revision */
static unsigned int c4x_idle2 = 0;      /* Idle2 support */
static unsigned int c4x_lowpower = 0;   /* Lowpower support */
static unsigned int c4x_enhanced = 0;   /* Enhanced opcode support */
static unsigned int c4x_big_model = 0;	/* Default to small memory model.  */
static unsigned int c4x_reg_args = 0;	/* Default to args passed on stack.  */
static unsigned long c4x_oplevel = 0;   /* Opcode level */
d118 1
a118 1
c4x_addr_mode_t;
d120 1
a120 1
typedef struct c4x_operand
d122 1
a122 1
    c4x_addr_mode_t mode;	/* Addressing mode.  */
d128 1
a128 1
c4x_operand_t;
d130 1
a130 1
typedef struct c4x_insn
d132 1
a132 1
    char name[C4X_NAME_MAX];	/* Mnemonic of instruction.  */
d142 2
a143 2
    c4x_inst_t *inst;		/* Pointer to first template.  */
    c4x_operand_t operands[C4X_OPERANDS_MAX];
d145 1
a145 1
c4x_insn_t;
d147 2
a148 2
static c4x_insn_t the_insn;	/* Info about our instruction.  */
static c4x_insn_t *insn = &the_insn;
d150 1
a150 1
static int c4x_gen_to_words
d152 1
a152 1
static char *c4x_atof
d154 1
a154 1
static void c4x_insert_reg
d156 1
a156 1
static void c4x_insert_sym
d158 1
a158 1
static char *c4x_expression
d160 1
a160 1
static char *c4x_expression_abs
d162 1
a162 1
static void c4x_emit_char
d164 1
a164 1
static void c4x_seg_alloc
d166 1
a166 1
static void c4x_asg
d168 1
a168 1
static void c4x_bss
d170 1
a170 1
static void c4x_globl
d172 1
a172 1
static void c4x_cons
d174 1
a174 1
static void c4x_stringer
d176 1
a176 1
static void c4x_eval
d178 1
a178 1
static void c4x_newblock
d180 1
a180 1
static void c4x_sect
d182 1
a182 1
static void c4x_set
d184 1
a184 1
static void c4x_usect
d186 1
a186 1
static void c4x_version
d188 1
a188 1
static void c4x_init_regtable
d190 1
a190 1
static void c4x_init_symbols
d192 3
a194 3
static int c4x_inst_insert
  PARAMS ((c4x_inst_t *));
static c4x_inst_t *c4x_inst_make
d196 2
a197 2
static int c4x_inst_add
  PARAMS ((c4x_inst_t *));
d200 1
a200 1
void c4x_end
d202 12
a213 12
static int c4x_indirect_parse
  PARAMS ((c4x_operand_t *, const c4x_indirect_t *));
static char *c4x_operand_parse
  PARAMS ((char *, c4x_operand_t *));
static int c4x_operands_match
  PARAMS ((c4x_inst_t *, c4x_insn_t *, int));
static void c4x_insn_check
  PARAMS ((c4x_insn_t *));
static void c4x_insn_output
  PARAMS ((c4x_insn_t *));
static int c4x_operands_parse
  PARAMS ((char *, c4x_operand_t *, int ));
d216 1
a216 1
void c4x_cleanup
d234 1
a234 1
int c4x_unrecognized_line
d242 1
a242 1
static int c4x_pc_offset
d246 1
a246 1
int c4x_do_align
d248 1
a248 1
void c4x_start_line
d258 3
a260 3
  {"ascii", c4x_stringer, 1},
  {"asciz", c4x_stringer, 0},
  {"asg", c4x_asg, 0},
d262 2
a263 2
  {"byte", c4x_cons, 1},
  {"bss", c4x_bss, 0},
d265 6
a270 6
  {"def", c4x_globl, 0},
  {"equ", c4x_set, 0},
  {"eval", c4x_eval, 0},
  {"global", c4x_globl, 0},
  {"globl", c4x_globl, 0},
  {"hword", c4x_cons, 2},
d272 1
a272 1
  {"int", c4x_cons, 4},		 /* .int allocates 4 bytes.  */
d274 1
a274 1
  {"newblock", c4x_newblock, 0},
d276 2
a277 2
  {"set", c4x_set, 0},
  {"sect", c4x_sect, 1},	 /* Define named section.  */
d279 5
a283 5
  {"string", c4x_stringer, 0},
  {"usect", c4x_usect, 0},       /* Reserve space in uninit. named sect.  */
  {"version", c4x_version, 0},
  {"word", c4x_cons, 4},	 /* .word allocates 4 bytes.  */
  {"xdef", c4x_globl, 0},
d293 1
a293 1
#ifdef C4X_ALT_SYNTAX
d337 1
a337 1
c4x_gen_to_words (flonum, words, precision)
d654 1
a654 1
c4x_atof (str, what_kind, words)
d719 1
a719 1
  c4x_gen_to_words (generic_floating_point_number,
d730 1
a730 1
c4x_insert_reg (regname, regnum)
d748 1
a748 1
c4x_insert_sym (symname, value)
d761 1
a761 1
c4x_expression (str, exp)
d777 1
a777 1
c4x_expression_abs (str, value)
d793 1
a793 1
c4x_emit_char (c,b)
d805 1
a805 1
c4x_seg_alloc (name, seg, size, symbolP)
d831 1
a831 1
c4x_asg (x)
d859 2
a860 2
  if (hash_find (c4x_asg_hash, name))
    hash_replace (c4x_asg_hash, name, (PTR) str);
d862 1
a862 1
    hash_insert (c4x_asg_hash, name, (PTR) str);
d869 1
a869 1
c4x_bss (x)
d893 1
a893 1
    c4x_expression_abs (++input_line_pointer, &size);
d924 1
a924 1
c4x_globl (ignore)
d954 1
a954 1
c4x_cons (bytes)
d965 1
a965 1
	    c4x_emit_char (c, 4);
d972 1
a972 1
	  input_line_pointer = c4x_expression (input_line_pointer, &exp);
d998 1
a998 1
c4x_stringer (append_zero)
d1013 1
a1013 1
              c4x_emit_char (c, 1);
d1019 1
a1019 1
              c4x_emit_char (c, 1);
d1029 1
a1029 1
	  input_line_pointer = c4x_expression (input_line_pointer, &exp);
d1044 1
a1044 1
    c4x_emit_char (0, 4-(bytes&0x3));
d1052 1
a1052 1
c4x_eval (x)
d1061 1
a1061 1
    c4x_expression_abs (input_line_pointer, &value);
d1070 1
a1070 1
  c4x_insert_sym (name, value);
d1075 1
a1075 1
c4x_newblock (x)
d1084 1
a1084 1
c4x_sect (x)
d1122 1
a1122 1
      c4x_expression_abs (input_line_pointer, &num);
d1126 1
a1126 1
	c4x_expression_abs (++input_line_pointer, &num);
d1158 1
a1158 1
c4x_set (x)
d1188 1
a1188 1
c4x_usect (x)
d1213 1
a1213 1
      c4x_expression_abs (input_line_pointer, &size);
d1217 1
a1217 1
	c4x_expression_abs (++input_line_pointer, &size);
d1226 1
a1226 1
	c4x_expression_abs (++input_line_pointer, &alignment_flag);
d1244 1
a1244 1
  c4x_seg_alloc (name, seg, size, line_label);
d1255 1
a1255 1
c4x_version (x)
d1261 2
a1262 2
    c4x_expression_abs (input_line_pointer, &temp);
  if (!IS_CPU_C3X (temp) && !IS_CPU_C4X (temp))
d1266 1
a1266 1
  if (c4x_cpu && temp != c4x_cpu)
d1268 1
a1268 1
  c4x_cpu = temp;
d1273 1
a1273 1
c4x_init_regtable ()
d1277 10
a1286 10
  for (i = 0; i < c3x_num_registers; i++)
    c4x_insert_reg (c3x_registers[i].name,
		    c3x_registers[i].regno);

  if (IS_CPU_C4X (c4x_cpu))
    {
      /* Add additional C4x registers, overriding some C3x ones.  */
      for (i = 0; i < c4x_num_registers; i++)
	c4x_insert_reg (c4x_registers[i].name,
			c4x_registers[i].regno);
d1291 1
a1291 1
c4x_init_symbols ()
d1320 9
a1328 9
  c4x_insert_sym (".REGPARM", c4x_reg_args);
  c4x_insert_sym (".MEMPARM", !c4x_reg_args);	
  c4x_insert_sym (".BIGMODEL", c4x_big_model);
  c4x_insert_sym (".C30INTERRUPT", 0);
  c4x_insert_sym (".TMS320xx", c4x_cpu == 0 ? 40 : c4x_cpu);
  c4x_insert_sym (".C3X", c4x_cpu == 30 || c4x_cpu == 31 || c4x_cpu == 32 || c4x_cpu == 33);
  c4x_insert_sym (".C3x", c4x_cpu == 30 || c4x_cpu == 31 || c4x_cpu == 32 || c4x_cpu == 33);
  c4x_insert_sym (".C4X", c4x_cpu == 0 || c4x_cpu == 40 || c4x_cpu == 44);
  c4x_insert_sym (".C4x", c4x_cpu == 0 || c4x_cpu == 40 || c4x_cpu == 44);
d1330 14
a1343 14
  c4x_insert_sym (".TMS320C30", c4x_cpu == 30 || c4x_cpu == 31 || c4x_cpu == 32 || c4x_cpu == 33);
  c4x_insert_sym (".tms320C30", c4x_cpu == 30 || c4x_cpu == 31 || c4x_cpu == 32 || c4x_cpu == 33);
  c4x_insert_sym (".TMS320C31", c4x_cpu == 31);
  c4x_insert_sym (".tms320C31", c4x_cpu == 31);
  c4x_insert_sym (".TMS320C32", c4x_cpu == 32);
  c4x_insert_sym (".tms320C32", c4x_cpu == 32);
  c4x_insert_sym (".TMS320C33", c4x_cpu == 33);
  c4x_insert_sym (".tms320C33", c4x_cpu == 33);
  c4x_insert_sym (".TMS320C40", c4x_cpu == 40 || c4x_cpu == 44 || c4x_cpu == 0);
  c4x_insert_sym (".tms320C40", c4x_cpu == 40 || c4x_cpu == 44 || c4x_cpu == 0);
  c4x_insert_sym (".TMS320C44", c4x_cpu == 44);
  c4x_insert_sym (".tms320C44", c4x_cpu == 44);
  c4x_insert_sym (".TMX320C40", 0);	/* C40 first pass silicon ?  */
  c4x_insert_sym (".tmx320C40", 0);
d1348 2
a1349 2
c4x_inst_insert (inst)
     c4x_inst_t *inst;
d1358 1
a1358 1
  retval = hash_insert (c4x_op_hash, inst->name, (PTR) inst);
d1368 2
a1369 2
static c4x_inst_t *
c4x_inst_make (name, opcode, args)
d1374 1
a1374 1
  static c4x_inst_t *insts = NULL;
d1383 2
a1384 2
      insts = (c4x_inst_t *)
	xmalloc (sizeof (c4x_inst_t) * 1024);
d1402 2
a1403 2
c4x_inst_add (insts)
     c4x_inst_t *insts;
d1415 1
a1415 1
  if (!insts->oplevel & c4x_oplevel)
d1425 1
a1425 1
	  for (i = 0; i < num_conds; i++)
d1427 1
a1427 1
	      c4x_inst_t *inst;
d1429 1
a1429 1
	      char *c = c4x_conds[i].name;
d1440 1
a1440 1
	      if (hash_find (c4x_op_hash, name))
d1445 2
a1446 2
		  inst = c4x_inst_make (name, insts[k].opcode +
					(c4x_conds[i].cond <<
d1450 1
a1450 1
		    ok &= c4x_inst_insert (inst);
d1460 1
a1460 1
	  return c4x_inst_insert (insts);
d1481 1
a1481 1
  c4x_oplevel = OP_C3X;
d1483 2
a1484 2
  if ( IS_CPU_C4X(c4x_cpu) )
    c4x_oplevel |= OP_C4X;
d1486 20
a1505 20
  if ( (   c4x_cpu == 31 && c4x_revision >= 6)
       || (c4x_cpu == 32 && c4x_revision >= 2)
       || (c4x_cpu == 33)
       || c4x_enhanced )
    c4x_oplevel |= OP_ENH;

  if ( (   c4x_cpu == 30 && c4x_revision >= 7)
       || (c4x_cpu == 31 && c4x_revision >= 5)
       || (c4x_cpu == 32)
       || c4x_lowpower )
    c4x_oplevel |= OP_LPWR;

  if ( (   c4x_cpu == 30 && c4x_revision >= 7)
       || (c4x_cpu == 31 && c4x_revision >= 5)
       || (c4x_cpu == 32)
       || (c4x_cpu == 33)
       || (c4x_cpu == 40 && c4x_revision >= 5)
       || (c4x_cpu == 44)
       || c4x_idle2 )
    c4x_oplevel |= OP_IDLE2;
d1508 1
a1508 1
  c4x_op_hash = hash_new ();
d1511 1
a1511 1
  c4x_asg_hash = hash_new ();
d1514 2
a1515 2
  for (i = 0; i < c4x_num_insts; i++)
    ok &= c4x_inst_add ((void *) &c4x_insts[i]);
d1518 1
a1518 1
  c4x_inst_make ("", 0, "");
d1524 1
a1524 1
  c4x_init_regtable ();
d1527 1
a1527 1
  c4x_init_symbols ();
d1531 1
a1531 1
c4x_end ()
d1534 1
a1534 1
		     IS_CPU_C4X (c4x_cpu) ? bfd_mach_c4x : bfd_mach_c3x);
d1538 3
a1540 3
c4x_indirect_parse (operand, indirect)
     c4x_operand_t *operand;
     const c4x_indirect_t *indirect;
d1555 1
a1555 1
#ifdef C4X_ALT_SYNTAX
d1576 1
a1576 1
#ifdef C4X_ALT_SYNTAX
d1580 1
a1580 1
	  s = c4x_expression (s, &operand->expr);
d1594 1
a1594 1
#ifdef C4X_ALT_SYNTAX
d1598 1
a1598 1
	  s = c4x_expression (s, &operand->expr);
d1638 1
a1638 1
c4x_operand_parse (s, operand)
d1640 1
a1640 1
     c4x_operand_t *operand;
d1657 1
a1657 1
  if (strlen (str) && (entry = hash_find (c4x_asg_hash, str)) != NULL)
d1671 1
a1671 1
#ifdef C4X_ALT_SYNTAX
d1673 1
a1673 1
      input_line_pointer = c4x_expression (++input_line_pointer, exp);
d1681 1
a1681 1
      input_line_pointer = c4x_expression (++input_line_pointer, exp);
d1690 1
a1690 1
	      c4x_gen_to_words (generic_floating_point_number,
d1704 1
a1704 1
      input_line_pointer = c4x_expression (++input_line_pointer, exp);
d1713 1
a1713 1
	      c4x_gen_to_words (generic_floating_point_number,
d1732 1
a1732 1
      input_line_pointer = c4x_expression (++input_line_pointer, exp);
d1746 2
a1747 2
      for (i = 0; i < c4x_num_indirects; i++)
	if ((ret = c4x_indirect_parse (operand, &c4x_indirects[i])))
d1751 1
a1751 1
      if (i < c4x_num_indirects)
d1755 1
a1755 1
	  operand->expr.X_add_number = c4x_indirects[i].modn;
d1768 1
a1768 1
      input_line_pointer = c4x_expression (input_line_pointer, exp);
d1782 1
a1782 1
	      c4x_gen_to_words (generic_floating_point_number,
d1788 1
a1788 1
#ifdef C4X_ALT_SYNTAX
d1804 3
a1806 3
c4x_operands_match (inst, insn, check)
     c4x_inst_t *inst;
     c4x_insn_t *insn;
d1812 1
a1812 1
  c4x_operand_t *operand = insn->operands;
d1853 2
a1854 2
              if( ( IS_CPU_C4X (c4x_cpu) && exp->X_add_number <= 65535 )
                  || ( IS_CPU_C3X (c4x_cpu) && exp->X_add_number <= 255 ) )
d1927 1
a1927 1
	  if (IS_CPU_C4X (c4x_cpu))
d1941 1
a1941 1
	  if (!IS_CPU_C4X (c4x_cpu))
d1969 1
a1969 1
               || (IS_CPU_C4X (c4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
d1992 1
a1992 1
	      c4x_atof (string, 's', operand->fwords);
d2009 1
a2009 1
               || (IS_CPU_C4X (c4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
d2035 1
a2035 1
               && c4x_oplevel & OP_ENH )
d2049 1
a2049 1
	      if (IS_CPU_C4X (c4x_cpu))
d2063 1
a2063 1
               && c4x_oplevel & OP_ENH )
d2077 1
a2077 1
	      if (IS_CPU_C4X (c4x_cpu))
d2146 1
a2146 1
	  if (!IS_CPU_C4X (c4x_cpu))
d2200 1
a2200 1
               || (IS_CPU_C4X (c4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
d2222 1
a2222 1
               || (IS_CPU_C4X (c4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
d2279 2
a2280 2
	case 'T':		/* 5-bit immediate value for c4x stik.  */
	  if (!IS_CPU_C4X (c4x_cpu))
d2340 1
a2340 1
	      if (exp->X_add_number < 512 && IS_CPU_C4X (c4x_cpu))
d2345 1
a2345 1
	      else if (exp->X_add_number < 32 && IS_CPU_C3X (c4x_cpu))
d2362 1
a2362 1
	  if (!IS_CPU_C4X (c4x_cpu))
d2393 1
a2393 1
	case 'X':		/* Expansion register for c4x.  */
d2407 1
a2407 1
	case 'Y':		/* Address register for c4x lda.  */
d2421 1
a2421 1
	case 'Z':		/* Expansion register for c4x.  */
d2478 2
a2479 2
c4x_insn_check (insn)
     c4x_insn_t *insn;
d2510 2
a2511 2
c4x_insn_output (insn)
     c4x_insn_t *insn;
d2536 1
a2536 1
c4x_operands_parse (s, operands, num_operands)
d2538 1
a2538 1
     c4x_operand_t *operands;
d2545 2
a2546 2
    s = c4x_operand_parse (s, &operands[num_operands++]);
  while (num_operands < C4X_OPERANDS_MAX && *s++ == ',');
d2548 1
a2548 1
  if (num_operands > C4X_OPERANDS_MAX)
d2567 2
a2568 2
  c4x_inst_t *inst;		/* Instruction template.  */
  c4x_inst_t *first_inst;
d2583 1
a2583 1
      strncat (insn->name, str, C4X_NAME_MAX - strlen (insn->name));
d2593 1
a2593 1
      if ((i = c4x_operands_parse
d2606 2
a2607 2
      if ((insn->inst = (struct c4x_inst *)
	   hash_find (c4x_op_hash, insn->name)) == NULL)
d2619 1
a2619 1
          ok = c4x_operands_match (inst, insn, 1);
d2630 2
a2631 2
          c4x_insn_check (insn);
          c4x_insn_output (insn);
d2636 1
a2636 1
            c4x_operands_match (first_inst, insn, 0);
d2651 1
a2651 1
      strncpy (insn->name, str, C4X_NAME_MAX - 3);
d2653 1
a2653 1
      if ((i = c4x_operands_parse (s, insn->operands, 0)) < 0)
d2669 1
a2669 1
c4x_cleanup ()
d2729 1
a2729 1
    t = c4x_atof (input_line_pointer, type, words);
d2802 1
a2802 1
/* Should never be called for c4x.  */
d2812 1
a2812 1
/* Should never be called for c4x.  */
d2824 1
a2824 1
/* Should never be called for c4x.  */
d2836 1
a2836 1
/* Should never be called for c4x.  */
d2857 3
a2859 3
      c4x_cpu = atoi (arg);
      if (!IS_CPU_C3X (c4x_cpu) && !IS_CPU_C4X (c4x_cpu))
	as_warn ("Unsupported processor generation %d", c4x_cpu);
d2863 1
a2863 1
      c4x_revision = atoi (arg);
d2869 1
a2869 1
      c4x_big_model = 1;
d2875 1
a2875 1
      c4x_reg_args = 0;
d2881 1
a2881 1
      c4x_reg_args = 1;
d2887 1
a2887 1
      c4x_big_model = 0;
d2891 1
a2891 1
      c4x_idle2 = 1;
d2895 1
a2895 1
      c4x_lowpower = 1;
d2899 1
a2899 1
      c4x_enhanced = 1;
d2939 1
a2939 1
c4x_unrecognized_line (c)
d3021 1
a3021 1
c4x_pc_offset (op)
d3093 1
a3093 1
    c4x_pc_offset (op);
d3099 1
a3099 1
c4x_do_align (alignment, fill, len, max)
d3132 1
a3132 1
c4x_start_line ()
@


1.5
log
@
	* gas/config/tc-tic4x.c: Fixed proper commandline
	parameters. Added support for new opcode-list format. General
	error message fixups.
	(c4x_inst_add): Reject insn not for our CPU
	(md_begin): Added matrix for setting the proper opcode-level &
	device-flags according to cpu type and revision. Rewrite the
	opcode hasher.
	(c4x_operand_parse): Fix opcode bug
	(c4x_operands_match): New function argument. Added dry-run
	mechanism, that is optional error generation. Added constraint 'i'
	and 'j'.
	(c4x_insn_check): Added new function for post-verification of the
	generated insn.
	(md_assemble): Check all opcodes before croaking because of an
	argument mismatch. Need this to be able to fully support
	ortogonally arguments.
	(md_parse_options): Revised commandprompt swicthes and added new
	ones.
	(md_show_usage): Complete rewrite of printout.
	* gas/testsuite/gas/tic4x/addressing.s: Fix bug in one insn
	* gas/testsuite/gas/tic4x/addressing_c3x.d: Update thereafter
	* gas/testsuite/gas/tic4x/addressing_c4x.d: Update thereafter
	* gas/testsuite/gas/tic4x/allopcodes.S: Add support for new
	opclass.h changes
	* gas/testsuite/gas/tic4x/opclasses.h: Added testsuites for
	the new enhanced opcodes.
	* gas/testsuite/gas/tic4x/opcodes.s: Regenerate
	* gas/testsuite/gas/tic4x/opcodes_c3x.d: Update from above
	* gas/testsuite/gas/tic4x/opcodes_c4x.d: Update from above
	* gas/testsuite/gas/tic4x/opcodes_new.d: Added new testsuite for
	the enhanced and special insns.
	* gas/testsuite/gas/tic4x/tic4x.exp: Added the opcodes_new testsuite
	* include/opcode/tic4x.h: File reordering. Added enhanced opcodes.
	* opcodes/tic4x-dis.c: Added support for enhanced and special
	insn.
	(c4x_print_op): Added insn class 'i' and 'j'
	(c4x_hash_opcode_special): Add to support special insn
	(c4x_hash_opcode): Update to support the new opcode-list
	format. Add support for the new special insns.
	(c4x_disassemble): New opcode-list support.
@
text
@d1880 4
a1883 15
	    {
              if(exp->X_add_number <= 65535)
                {
                  /* Store only the 16 LSBs of the number.  */
                  INSERTS (opcode, exp->X_add_number, 15, 0);
                  continue;
                }
              else
                {
		  if (!check)
                    as_bad ("Direct value of %ld is too large",
                            (long) exp->X_add_number);
		  ret = -1;
		  continue;
                }
@


1.4
log
@
	* gas/config/tc-tic4x.c: Remove c4x_pseudo_ignore function.
	  (c4x_operands_match): Added check for 8-bits LDF insn. Give
	  warning when using constant direct bigger than 2^16. Add the new
	  arguments.
	* include/opcode/tic4x.h: Major rewrite of entire file. Define
	  instruction classes, and put each instruction into a class.
	* opcodes/tic4x-dis.c: (c4x_print_op): Add support for the new
	  argument format. Fix bug in 'N' register printer.
@
text
@d45 1
a45 16
  o Warnings issued if parallel load of same register. Applies to LL
    class. Can be applied to destination of the LS class as well, but
    the test will be more complex.

  o Support 'abc' constants?

  o Support new opcodes and implement a silicon version switch (maybe
    -mpg)

  o Disallow non-float registers in float instructions.

  o Make sure the source and destination register is NOT equal when
    the C4X LDA insn is used (arg mode Q,Y)

  o Merge the C3x op-table and the c4x op-table, and adhere to the
    last argument when parsing the hash.
d76 4
d82 30
d207 3
a209 1
  PARAMS ((c4x_inst_t *, c4x_insn_t *));
d1263 1
a1263 1
    as_bad ("This assembler does not support processor generation %d\n",
d1267 1
a1267 1
    as_warn ("Changing processor generation on fly not supported...\n");
d1413 5
d1479 28
d1514 2
a1515 8
  for (i = 0; i < c3x_num_insts; i++)
    ok &= c4x_inst_add ((void *) &c3x_insts[i]);

  if (IS_CPU_C4X (c4x_cpu))
    {
      for (i = 0; i < c4x_num_insts; i++)
	ok &= c4x_inst_add ((void *) &c4x_insts[i]);
    }
d1746 1
a1746 1
      for (i = 0; i < num_indirects; i++)
d1751 1
a1751 1
      if (i < num_indirects)
d1804 1
a1804 1
c4x_operands_match (inst, insn)
d1807 1
d1861 3
a1863 2
		  as_bad ("LDF's immediate value of %ld is too large",
			  (long) exp->X_add_number);
d1889 3
a1891 2
		  as_bad ("Direct value of %ld is too large",
			  (long) exp->X_add_number);
d1912 2
a1913 1
	      as_bad ("Destination register must be ARn");
d1931 3
a1933 2
		  as_bad ("Immediate value of %ld is too large",
			  (long) exp->X_add_number);
d1960 3
a1962 2
	      as_bad ("Invalid indirect addressing mode");
	      ret = -1;
d1984 2
a1985 1
	      as_bad ("Register must be Rn");
d2024 2
a2025 1
	      as_bad ("Register must be Rn");
d2038 2
a2039 1
	      as_bad ("Register must be R0--R7");
d2044 11
d2062 3
a2064 2
	      as_bad ("Invalid indirect addressing mode displacement %d",
		      operand->disp);
d2072 11
d2090 3
a2092 2
	      as_bad ("Invalid indirect addressing mode displacement %d",
		      operand->disp);
d2108 2
a2109 1
	      as_bad ("Register must be R0--R7");
d2122 2
a2123 1
	      as_bad ("Register must be R0--R7");
d2136 2
a2137 1
	      as_bad ("Destination register must be R2 or R3");
d2150 2
a2151 1
	      as_bad ("Destination register must be R0 or R1");
d2165 2
a2166 1
	      as_bad ("Invalid indirect addressing mode");
d2187 3
a2189 2
		  as_bad ("Displacement value of %ld is too large",
			  (long) exp->X_add_number);
d2215 2
a2216 1
	      as_bad ("Register must be Rn");
d2237 2
a2238 1
	      as_bad ("Register must be Rn");
d2248 2
a2249 1
	      as_bad ("Floating point number not valid in expression");
d2262 3
a2264 2
		  as_bad ("Signed immediate value %ld too large",
			  (long) exp->X_add_number);
d2304 3
a2306 2
		  as_bad ("Immediate value of %ld is too large",
			  (long) exp->X_add_number);
d2325 3
a2327 2
		  as_bad ("Unsigned immediate value %ld too large",
			  (long) exp->X_add_number);
d2363 3
a2365 2
		  as_bad ("Immediate value of %ld is too large",
			  (long) exp->X_add_number);
d2379 2
a2380 1
	      as_bad ("Floating point number not valid in expression");
d2393 3
a2395 2
		  as_bad ("Immediate value %ld too large",
			  (long) exp->X_add_number);
d2412 2
a2413 1
	      as_bad ("Register must be ivtp or tvtp");
d2426 2
a2427 1
	      as_bad ("Register must be address register");
d2440 2
a2441 1
	      as_bad ("Register must be ivtp or tvtp");
d2488 32
d2579 1
a2625 7
      /* FIXME:  The list of templates should be scanned
         for the candidates with the desired number of operands.
         We shouldn't issue error messages until we have
         whittled the list of candidate templates to the most
         likely one...  We could cache a parsed form of the templates
         to reduce the time required to match a template.  */

d2627 1
a2627 1

d2629 9
a2637 2
	ok = c4x_operands_match (inst, insn);
      while (!ok && !strcmp (inst->name, inst[1].name) && inst++);
d2640 4
a2643 1
	c4x_insn_output (insn);
d2645 5
a2649 1
	as_bad ("Invalid operands for %s", insn->name);
a2856 7
CONST char *md_shortopts = "bm:prs";
struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);
d2865 1
a2865 4
    case 'b':			/* big model */
      c4x_big_model = 1;
      break;
    case 'm':			/* -m[c][34]x */
d2870 1
a2870 1
	as_warn ("Unsupported processor generation %d\n", c4x_cpu);
d2872 14
a2885 1
    case 'p':			/* push args */
d2888 4
a2891 1
    case 'r':			/* register args */
d2894 4
a2897 1
    case 's':			/* small model */
d2900 13
d2924 20
a2943 9
  fputs ("\
C[34]x options:\n\
-m30 | -m31 | -m32 | -m33 | -m40 | -m44\n\
			specify variant of architecture\n\
-b                      big memory model\n\
-p                      pass arguments on stack\n\
-r                      pass arguments in registers (default)\n\
-s                      small memory model (default)\n",
	 stream);
d3185 1
a3185 1
		    "reloc %d not supported by object file format",
@


1.3
log
@
	gas tic4x target enhancements (long list - see gas/ChangeLog and
	include/ChangeLog)
@
text
@d26 2
a27 1
  o .align cannot handle fill-data larger than 0xFF/8-bits
d34 3
a36 2
  o .align: Implement a 'bu' insn if the number of nop's exeeds 4 within
    the align frag. if(fragsize>4words) insert bu fragend+1 first. 
d42 2
a43 1
  o Evaluation of constant floating point expressions (expr.c needs work!)
d45 3
a47 1
  o Warnings issued if parallel load of same register
d51 2
a52 1
  o Support new opcodes and implement a silicon version switch (maybe -mpg)
d54 7
a60 2
  o Disallow non-float registers in float instructions. Make as require
    'fx' notation on floats, while 'rx' on the rest
a168 2
static void c4x_pseudo_ignore
  PARAMS ((int));
d1804 13
a1816 3
	      /* Maybe for C3x we should check for 8 bit number.  */
	      INSERTS (opcode, exp->X_add_number, 15, 0);
	      continue;
d1831 13
a1843 3
	      /* Store only the 16 LSBs of the number.  */
	      INSERTS (opcode, exp->X_add_number, 15, 0);
	      continue;
d1903 1
d1921 14
d1960 14
d2119 14
d2139 14
@


1.2
log
@	* config/tc-tic4x.c: Add function declarations and ATTRIBUTE_UNUSED.
	Convert functions to K&R format.
@
text
@d22 5
d28 4
d33 2
a34 2
/* Things not currently implemented:
   > .usect if has symbol on previous line  
d36 1
a36 1
   > .sym, .eos, .stag, .etag, .member
d38 1
a38 1
   > Evaluation of constant floating point expressions (expr.c needs work!)
d40 1
a40 1
   > Warnings issued if parallel load of same register
d42 9
a50 2
   Note that this is primarily designed to handle the code generated
   by GCC.  Anything else is a bonus!  */
d120 4
a123 4
int c4x_gen_to_words
    PARAMS ((FLONUM_TYPE, LITTLENUM_TYPE *, int ));
char *c4x_atof
    PARAMS ((char *, char, LITTLENUM_TYPE * ));
d125 1
a125 1
    PARAMS ((char *, int ));
d127 1
a127 1
    PARAMS ((char *, int ));
d129 1
a129 1
    PARAMS ((char *, expressionS *));
d131 1
a131 1
    PARAMS ((char *, int *));
d133 1
a133 1
    PARAMS ((char));
d135 1
a135 1
    PARAMS ((char *, segT, int, symbolS *));
d137 1
a137 1
    PARAMS ((int));
d139 3
a141 3
    PARAMS ((int));
void c4x_globl
    PARAMS ((int));
d143 3
a145 1
    PARAMS ((int));
d147 1
a147 1
    PARAMS ((int));
d149 1
a149 1
    PARAMS ((int));
d151 1
a151 1
    PARAMS ((int));
d153 1
a153 1
    PARAMS ((int));
d155 1
a155 1
    PARAMS ((int));
d157 1
a157 1
    PARAMS ((int));
d159 1
a159 1
    PARAMS ((int));
d161 1
a161 1
    PARAMS ((void));
d163 1
a163 1
    PARAMS ((void));
d165 1
a165 1
    PARAMS ((c4x_inst_t *));
d167 1
a167 1
    PARAMS ((char *, unsigned long, char *));
d169 1
a169 1
    PARAMS ((c4x_inst_t *));
d171 1
a171 1
    PARAMS ((void));
d173 1
a173 1
    PARAMS ((void));
d175 3
a177 3
    PARAMS ((c4x_operand_t *, const c4x_indirect_t *));
char *c4x_operand_parse
    PARAMS ((char *, c4x_operand_t *));
d179 5
a183 5
    PARAMS ((c4x_inst_t *, c4x_insn_t *));
void c4x_insn_output
    PARAMS ((c4x_insn_t *));
int c4x_operands_parse
    PARAMS ((char *, c4x_operand_t *, int ));
d185 1
a185 1
    PARAMS ((char *));
d187 1
a187 1
    PARAMS ((void));
d189 1
a189 1
    PARAMS ((int, char *, int *));
d191 1
a191 1
    PARAMS ((fixS *, valueT *, segT ));
d193 1
a193 1
    PARAMS ((bfd *, segT, fragS *));
d195 1
a195 1
    PARAMS ((char *, addressT, addressT, fragS *, symbolS *));
d197 1
a197 1
    PARAMS ((char *, addressT, addressT, fragS *, symbolS *));
d199 1
a199 1
    PARAMS ((register fragS *, segT));
d201 1
a201 1
    PARAMS ((int, char *));
d203 1
a203 1
    PARAMS ((FILE *));
d205 1
a205 1
    PARAMS ((int));
d207 1
a207 1
    PARAMS ((char *));
d209 1
a209 1
    PARAMS ((expressionS *));
d211 1
a211 1
    PARAMS ((segT, valueT));
d213 1
a213 1
    PARAMS ((unsigned int));
d215 1
a215 1
    PARAMS ((fixS *));
d217 1
a217 1
    PARAMS ((int, const char *, int, int));
d219 1
a219 1
    PARAMS ((void));
d221 1
a221 1
    PARAMS ((asection *, fixS *));
d228 2
a229 2
  {"ascii", c4x_cons, 1},
  {"asciz", c4x_pseudo_ignore, 0},
d231 1
a231 2
  {"asect", c4x_pseudo_ignore, 0}, /* Absolute named section.  */
  {"block", s_space, 0},
d234 1
a234 1
  {"comm", c4x_bss, 0},
a235 3
  {"endfunc", c4x_pseudo_ignore, 0},
  {"eos", c4x_pseudo_ignore, 0},
  {"etag", c4x_pseudo_ignore, 0},
a237 2
  {"exitm", s_mexit, 0},
  {"func", c4x_pseudo_ignore, 0},
d242 2
a243 4
  {"int", c4x_cons, 4},		/* .int allocates 4 bytes.  */
  {"length", c4x_pseudo_ignore, 0},
  {"ldouble", float_cons, 'l'},
  {"member", c4x_pseudo_ignore, 0},
d245 1
a245 1
  {"ref", s_ignore, 0},		/* All undefined treated as external.  */
d247 1
a247 1
  {"sect", c4x_sect, 1},	/* Define named section.  */
d249 2
a250 4
  {"stag", c4x_pseudo_ignore, 0},
  {"string", c4x_pseudo_ignore, 0},
  {"sym", c4x_pseudo_ignore, 0},
  {"usect", c4x_usect, 0},	/* Reserve space in uninit. named sect.  */
d252 1
a252 2
  {"width", c4x_pseudo_ignore, 0},
  {"word", c4x_cons, 4},	/* .word allocates 4 bytes.  */
d298 2
a299 1
#define MAX_PRECISION (2)
d302 1
a304 1

d306 1
a306 1
int
d321 2
d325 7
a331 1
  /* Here is how a generic floating point number is stored using
d459 2
d462 3
a464 2
  /* 0.0e0 seen.  */
  if (flonum.low > flonum.leader)
d466 2
d472 1
a472 8
  /* NaN:  We can't do much...  */
  if (flonum.sign == 0)
    {
      as_bad ("Nan, using zero.");
      words[0] = 0x8000;
      return return_value;
    }
  else if (flonum.sign == 'P')
d477 1
a477 1
      else
d482 5
d494 4
a497 2
      else
	words[0] = 0x7f80;
d513 1
a513 1
      mantissa_bits = 12;	/* Include suppr. bit but not rounding bit.  */
d515 6
a520 1
  else
d523 1
a523 1
      mantissa_bits = 24;
d529 3
d535 1
d540 16
a555 4
  /* OK, we've got our scaled mantissa so let's round it up
     and drop the rounding bit.  */
  smant++;
  smant >>= 1;
d558 1
a558 1
  if (smant >> mantissa_bits)
d561 1
d568 2
a569 2
  if (!(smant >> (mantissa_bits - 1)))
    abort ();			/* Ooops.  */
a570 1
  sone = (1 << (mantissa_bits - 1));
d582 3
a584 1
	sfract = (sone << 1) - smant;	/* 2.0 - smant.  */
a592 1
  sfract |= exponent << mantissa_bits;
d594 11
a604 2
  if (precision == S_PRECISION)
    words[0] = sfract;
d607 10
a616 2
      words[0] = sfract >> 16;
      words[1] = sfract & 0xffff;
d623 1
a623 1
char *
d669 5
d763 1
a763 1
c4x_emit_char (c)
d765 1
d771 1
a771 1
  emit_expr (&exp, 4);
d893 1
a893 1
void
d935 1
a935 1
	    c4x_emit_char (c);
d966 54
a1242 10
c4x_pseudo_ignore (x)
     int x ATTRIBUTE_UNUSED;
{
  /* We could print warning message here...  */

  /* Ignore everything until end of line.  */
  while (!is_end_of_line[(unsigned char) *input_line_pointer++]);
}

static void 
d1295 2
a1296 2
  c4x_insert_sym (".C3X", c4x_cpu == 30 || c4x_cpu == 31 || c4x_cpu == 32);
  c4x_insert_sym (".C3x", c4x_cpu == 30 || c4x_cpu == 31 || c4x_cpu == 32);
d1300 2
a1301 2
  c4x_insert_sym (".TMS320C30", c4x_cpu == 30 || c4x_cpu == 31 || c4x_cpu == 32);
  c4x_insert_sym (".tms320C30", c4x_cpu == 30 || c4x_cpu == 31 || c4x_cpu == 32);
d1306 2
d1580 1
a1580 1
char *
d2303 1
a2303 1
void 
d2495 1
d2498 1
d2501 2
a2502 1
    case 'l':			/* .ldouble */
d2504 1
a2504 1
      ieee = 1;
d2522 15
a2536 4
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP--),
			  sizeof (LITTLENUM_TYPE));
d2679 1
a2679 1
-m30 | -m31 | -m32 | -m40 | -m44\n\
d2849 2
a2850 2
/* This is probably not necessary, if we have played our cards right,
   since everything should be already aligned on a 4-byte boundary.  */
d2858 1
a2858 1
  char *p;
d2860 20
a2879 5
  p = frag_var (rs_align, 1, 1, (relax_substateT) 0,
		(symbolS *) 0, (long) 2, (char *) 0);

  /* We could use frag_align_pattern (n, nop_pattern, sizeof (nop_pattern));
     to fill with our 32-bit nop opcode.  */
@


1.1
log
@Add TMS320C4x support
@
text
@d104 101
a204 11
static void c4x_asg PARAMS ((int));
static void c4x_bss PARAMS ((int));
static void c4x_globl PARAMS ((int));
static void c4x_eval PARAMS ((int));
static void c4x_cons PARAMS ((int));
static void c4x_set PARAMS ((int));
static void c4x_newblock PARAMS ((int));
static void c4x_pseudo_ignore PARAMS ((int));
static void c4x_sect PARAMS ((int));
static void c4x_usect PARAMS ((int));
static void c4x_version PARAMS ((int));
d296 1
d299 4
a302 1
c4x_gen_to_words (FLONUM_TYPE flonum, LITTLENUM_TYPE *words, int precision)
d564 4
a567 1
c4x_atof (char *str, char what_kind, LITTLENUM_TYPE *words)
d635 3
a637 1
c4x_insert_reg (char *regname, int regnum)
d653 3
a655 1
c4x_insert_sym (char *symname, int value)
d666 3
a668 1
c4x_expression (char *str, expressionS *exp)
d682 3
a684 1
c4x_expression_abs (char *str, int *value)
d698 2
a699 1
c4x_emit_char (char c)
d709 5
a713 1
c4x_seg_alloc (char *name, segT seg, int size, symbolS *symbolP)
d735 2
a736 1
c4x_asg (int x)
d773 2
a774 1
c4x_bss (int x)
d828 2
a829 1
c4x_globl (int ignore)
d858 2
a859 1
c4x_cons (int bytes)
d902 2
a903 1
c4x_eval (int x)
d925 2
a926 1
c4x_newblock (int x)
d934 2
a935 1
c4x_sect (int x)
d1008 2
a1009 1
c4x_set (int x)
d1038 2
a1039 1
c4x_usect (int x)
d1105 2
a1106 1
c4x_version (int x)
d1123 2
a1124 1
c4x_pseudo_ignore (int x)
d1133 1
a1133 1
c4x_init_regtable (void)
d1151 1
a1151 1
c4x_init_symbols (void)
d1206 2
a1207 1
c4x_inst_insert (c4x_inst_t *inst)
d1227 4
a1230 1
c4x_inst_make (char *name, unsigned long opcode, char *args)
d1260 2
a1261 1
c4x_inst_add (c4x_inst_t *insts)
d1327 1
a1327 1
md_begin (void)
d1362 1
a1362 1
c4x_end (void)
d1369 3
a1371 2
c4x_indirect_parse (c4x_operand_t *operand,
		    const c4x_indirect_t *indirect)
d1469 3
a1471 1
c4x_operand_parse (char *s, c4x_operand_t *operand)
d1635 3
a1637 1
c4x_operands_match (c4x_inst_t *inst, c4x_insn_t *insn)
d2192 2
a2193 1
c4x_insn_output (c4x_insn_t *insn)
d2218 4
a2221 1
c4x_operands_parse (char *s, c4x_operand_t *operands, int num_operands)
d2242 2
a2243 1
md_assemble (char *str)
d2343 1
a2343 1
c4x_cleanup (void)
d2355 4
a2358 1
md_atof (int type, char *litP, int *sizeP)
d2417 4
a2420 1
md_apply_fix3 (fixS *fixP, valueT *value, segT seg ATTRIBUTE_UNUSED)
d2464 4
a2467 1
md_convert_frag (bfd *headers, segT sec, fragS *fragP)
d2474 6
a2479 2
md_create_short_jump (char *ptr, addressT from_addr, addressT to_addr,
		      fragS *frag, symbolS *to_symbol)
d2486 6
a2491 2
md_create_long_jump (char *ptr, addressT from_addr, addressT to_addr,
		     fragS *frag, symbolS *to_symbol)
d2498 3
a2500 1
md_estimate_size_before_relax (register fragS *fragP, segT segtype)
d2515 3
a2517 1
md_parse_option (int c, char *arg)
d2548 2
a2549 1
md_show_usage (FILE *stream)
d2566 2
a2567 1
c4x_unrecognized_line (int c)
d2600 2
a2601 1
md_undefined_symbol (char *name)
d2633 2
a2634 1
md_operand (expressionS *expressionP)
d2640 3
a2642 1
md_section_align (segT segment, valueT size)
d2648 2
a2649 1
c4x_pc_offset (unsigned int op)
d2711 2
a2712 1
md_pcrel_from (fixS *fixP)
d2726 5
a2730 1
c4x_do_align (int alignment, const char *fill, int len, int max)
d2744 1
a2744 1
c4x_start_line (void)
d2770 3
a2772 1
tc_gen_reloc (asection *seg, fixS *fixP)
a2797 1

@

