head	1.19;
access;
symbols
	binutils-2_24-branch:1.19.0.2
	binutils-2_24-branchpoint:1.19
	binutils-2_21_1:1.18
	binutils-2_23_2:1.18
	binutils-2_23_1:1.18
	binutils-2_23:1.18
	binutils-2_23-branch:1.18.0.10
	binutils-2_23-branchpoint:1.18
	binutils-2_22_branch:1.18.0.8
	binutils-2_22:1.18
	binutils-2_22-branch:1.18.0.6
	binutils-2_22-branchpoint:1.18
	binutils-2_21:1.18
	binutils-2_21-branch:1.18.0.4
	binutils-2_21-branchpoint:1.18
	binutils-2_20_1:1.18
	binutils-2_20:1.18
	binutils-arc-20081103-branch:1.16.0.6
	binutils-arc-20081103-branchpoint:1.16
	binutils-2_20-branch:1.18.0.2
	binutils-2_20-branchpoint:1.18
	dje-cgen-play1-branch:1.17.0.2
	dje-cgen-play1-branchpoint:1.17
	arc-20081103-branch:1.16.0.4
	arc-20081103-branchpoint:1.16
	binutils-2_19_1:1.16
	binutils-2_19:1.16
	binutils-2_19-branch:1.16.0.2
	binutils-2_19-branchpoint:1.16
	binutils-2_18:1.15
	binutils-2_18-branch:1.15.0.2
	binutils-2_18-branchpoint:1.15
	binutils-csl-coldfire-4_1-32:1.14
	binutils-csl-sourcerygxx-4_1-32:1.14
	binutils-csl-innovasic-fido-3_4_4-33:1.14
	binutils-csl-sourcerygxx-3_4_4-32:1.12
	binutils-csl-coldfire-4_1-30:1.14
	binutils-csl-sourcerygxx-4_1-30:1.14
	binutils-csl-coldfire-4_1-28:1.14
	binutils-csl-sourcerygxx-4_1-29:1.14
	binutils-csl-sourcerygxx-4_1-28:1.14
	binutils-csl-arm-2006q3-27:1.14
	binutils-csl-sourcerygxx-4_1-27:1.14
	binutils-csl-arm-2006q3-26:1.14
	binutils-csl-sourcerygxx-4_1-26:1.14
	binutils-csl-sourcerygxx-4_1-25:1.14
	binutils-csl-sourcerygxx-4_1-24:1.14
	binutils-csl-sourcerygxx-4_1-23:1.14
	binutils-csl-sourcerygxx-4_1-21:1.14
	binutils-csl-arm-2006q3-21:1.14
	binutils-csl-sourcerygxx-4_1-22:1.14
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.14
	binutils-csl-sourcerygxx-4_1-20:1.14
	binutils-csl-arm-2006q3-19:1.14
	binutils-csl-sourcerygxx-4_1-19:1.14
	binutils-csl-sourcerygxx-4_1-18:1.14
	binutils-csl-renesas-4_1-9:1.14
	binutils-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-renesas-4_1-8:1.14
	binutils-csl-renesas-4_1-7:1.14
	binutils-csl-renesas-4_1-6:1.14
	binutils-csl-sourcerygxx-4_1-17:1.14
	binutils-csl-sourcerygxx-4_1-14:1.14
	binutils-csl-sourcerygxx-4_1-15:1.14
	binutils-csl-sourcerygxx-4_1-13:1.14
	binutils-2_17:1.14
	binutils-csl-sourcerygxx-4_1-12:1.14
	binutils-csl-sourcerygxx-3_4_4-21:1.14
	binutils-csl-wrs-linux-3_4_4-24:1.12
	binutils-csl-wrs-linux-3_4_4-23:1.12
	binutils-csl-sourcerygxx-4_1-9:1.14
	binutils-csl-sourcerygxx-4_1-8:1.14
	binutils-csl-sourcerygxx-4_1-7:1.14
	binutils-csl-arm-2006q1-6:1.14
	binutils-csl-sourcerygxx-4_1-6:1.14
	binutils-csl-wrs-linux-3_4_4-22:1.12
	binutils-csl-coldfire-4_1-11:1.14
	binutils-csl-sourcerygxx-3_4_4-19:1.14
	binutils-csl-coldfire-4_1-10:1.14
	binutils-csl-sourcerygxx-4_1-5:1.14
	binutils-csl-sourcerygxx-4_1-4:1.14
	binutils-csl-wrs-linux-3_4_4-21:1.12
	binutils-csl-morpho-4_1-4:1.14
	binutils-csl-sourcerygxx-3_4_4-17:1.14
	binutils-csl-wrs-linux-3_4_4-20:1.12
	binutils-2_17-branch:1.14.0.4
	binutils-2_17-branchpoint:1.14
	binutils-csl-2_17-branch:1.14.0.2
	binutils-csl-2_17-branchpoint:1.14
	binutils-csl-gxxpro-3_4-branch:1.12.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.12
	binutils-2_16_1:1.12
	binutils-csl-arm-2005q1b:1.12
	binutils-2_16:1.12
	binutils-csl-arm-2005q1a:1.12
	binutils-csl-arm-2005q1-branch:1.12.0.4
	binutils-csl-arm-2005q1-branchpoint:1.12
	binutils-2_16-branch:1.12.0.2
	binutils-2_16-branchpoint:1.12
	csl-arm-2004-q3d:1.10
	csl-arm-2004-q3:1.10
	binutils-2_15:1.10
	binutils-2_15-branchpoint:1.10
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.10
	binutils-2_15-branch:1.10.0.10
	cagney_bfdfile-20040213-branch:1.10.0.8
	cagney_bfdfile-20040213-branchpoint:1.10
	cagney_bigcore-20040122-branch:1.10.0.6
	cagney_bigcore-20040122-branchpoint:1.10
	csl-arm-2003-q4:1.10
	binutils-2_14:1.10
	binutils-2_14-branch:1.10.0.4
	binutils-2_14-branchpoint:1.10
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	binutils-2_13_1:1.10
	binutils-2_13:1.10
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	binutils-2_12_1:1.8
	binutils-2_12:1.8
	binutils-2_12-branch:1.8.0.2
	binutils-2_12-branchpoint:1.8
	cygnus_cvs_20020108_pre:1.8
	binutils-2_11_2:1.6.2.2
	binutils-2_11_1:1.6.2.2
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.4.2.1
	binutils-2_10:1.4.2.1
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.19
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.2
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2012.11.09.08.29.32;	author hjl;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.17.16.45.54;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.05.09.12.51;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.24.20.40.25;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.03.11.47.48;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.31.23.18.23;	author bje;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.11.11.21.01;	author rsandifo;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.11.11.11.34;	author rsandifo;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.02.18.43.13;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.07.19.54.34;	author kazu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.05.03.21.23.52;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.09.12.03.34.28;	author ian;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.12.02.12.38;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.14.01.53.28;	author schwab;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.6.2.1
date	2001.06.07.03.15.26;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.06.11.10.04.47;	author amodra;	state Exp;
branches;
next	;

1.4.2.1
date	2000.05.03.21.24.59;	author ian;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@/* atof_ieee.c - turn a Flonum into an IEEE floating point number
   Copyright 1987, 1992, 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2005,
   2007, 2009  Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"

/* Flonums returned here.  */
extern FLONUM_TYPE generic_floating_point_number;

extern const char EXP_CHARS[];
/* Precision in LittleNums.  */
/* Don't count the gap in the m68k extended precision format.  */
#define MAX_PRECISION  5
#define F_PRECISION    2
#define D_PRECISION    4
#define X_PRECISION    5
#define P_PRECISION    5

/* Length in LittleNums of guard bits.  */
#define GUARD          2

#ifndef TC_LARGEST_EXPONENT_IS_NORMAL
#define TC_LARGEST_EXPONENT_IS_NORMAL(PRECISION) 0
#endif

static const unsigned long mask[] =
{
  0x00000000,
  0x00000001,
  0x00000003,
  0x00000007,
  0x0000000f,
  0x0000001f,
  0x0000003f,
  0x0000007f,
  0x000000ff,
  0x000001ff,
  0x000003ff,
  0x000007ff,
  0x00000fff,
  0x00001fff,
  0x00003fff,
  0x00007fff,
  0x0000ffff,
  0x0001ffff,
  0x0003ffff,
  0x0007ffff,
  0x000fffff,
  0x001fffff,
  0x003fffff,
  0x007fffff,
  0x00ffffff,
  0x01ffffff,
  0x03ffffff,
  0x07ffffff,
  0x0fffffff,
  0x1fffffff,
  0x3fffffff,
  0x7fffffff,
  0xffffffff,
};

static int bits_left_in_littlenum;
static int littlenums_left;
static LITTLENUM_TYPE *littlenum_pointer;

static int
next_bits (int number_of_bits)
{
  int return_value;

  if (!littlenums_left)
    return 0;

  if (number_of_bits >= bits_left_in_littlenum)
    {
      return_value = mask[bits_left_in_littlenum] & *littlenum_pointer;
      number_of_bits -= bits_left_in_littlenum;
      return_value <<= number_of_bits;

      if (--littlenums_left)
	{
	  bits_left_in_littlenum = LITTLENUM_NUMBER_OF_BITS - number_of_bits;
	  --littlenum_pointer;
	  return_value |=
	    (*littlenum_pointer >> bits_left_in_littlenum)
	    & mask[number_of_bits];
	}
    }
  else
    {
      bits_left_in_littlenum -= number_of_bits;
      return_value =
	mask[number_of_bits] & (*littlenum_pointer >> bits_left_in_littlenum);
    }
  return return_value;
}

/* Num had better be less than LITTLENUM_NUMBER_OF_BITS.  */

static void
unget_bits (int num)
{
  if (!littlenums_left)
    {
      ++littlenum_pointer;
      ++littlenums_left;
      bits_left_in_littlenum = num;
    }
  else if (bits_left_in_littlenum + num > LITTLENUM_NUMBER_OF_BITS)
    {
      bits_left_in_littlenum =
	num - (LITTLENUM_NUMBER_OF_BITS - bits_left_in_littlenum);
      ++littlenum_pointer;
      ++littlenums_left;
    }
  else
    bits_left_in_littlenum += num;
}

static void
make_invalid_floating_point_number (LITTLENUM_TYPE *words)
{
  as_bad (_("cannot create floating-point number"));
  /* Zero the leftmost bit.  */
  words[0] = (LITTLENUM_TYPE) ((unsigned) -1) >> 1;
  words[1] = (LITTLENUM_TYPE) -1;
  words[2] = (LITTLENUM_TYPE) -1;
  words[3] = (LITTLENUM_TYPE) -1;
  words[4] = (LITTLENUM_TYPE) -1;
  words[5] = (LITTLENUM_TYPE) -1;
}

/* Warning: This returns 16-bit LITTLENUMs.  It is up to the caller to
   figure out any alignment problems and to conspire for the
   bytes/word to be emitted in the right order.  Bigendians beware!  */

/* Note that atof-ieee always has X and P precisions enabled.  it is up
   to md_atof to filter them out if the target machine does not support
   them.  */

/* Returns pointer past text consumed.  */

char *
atof_ieee (char *str,			/* Text to convert to binary.  */
	   int what_kind,		/* 'd', 'f', 'x', 'p'.  */
	   LITTLENUM_TYPE *words)	/* Build the binary here.  */
{
  /* Extra bits for zeroed low-order bits.
     The 1st MAX_PRECISION are zeroed, the last contain flonum bits.  */
  static LITTLENUM_TYPE bits[MAX_PRECISION + MAX_PRECISION + GUARD];
  char *return_value;
  /* Number of 16-bit words in the format.  */
  int precision;
  long exponent_bits;
  FLONUM_TYPE save_gen_flonum;

  /* We have to save the generic_floating_point_number because it
     contains storage allocation about the array of LITTLENUMs where
     the value is actually stored.  We will allocate our own array of
     littlenums below, but have to restore the global one on exit.  */
  save_gen_flonum = generic_floating_point_number;

  return_value = str;
  generic_floating_point_number.low = bits + MAX_PRECISION;
  generic_floating_point_number.high = NULL;
  generic_floating_point_number.leader = NULL;
  generic_floating_point_number.exponent = 0;
  generic_floating_point_number.sign = '\0';

  /* Use more LittleNums than seems necessary: the highest flonum may
     have 15 leading 0 bits, so could be useless.  */

  memset (bits, '\0', sizeof (LITTLENUM_TYPE) * MAX_PRECISION);

  switch (what_kind)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      precision = F_PRECISION;
      exponent_bits = 8;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      precision = D_PRECISION;
      exponent_bits = 11;
      break;

    case 'x':
    case 'X':
    case 'e':
    case 'E':
      precision = X_PRECISION;
      exponent_bits = 15;
      break;

    case 'p':
    case 'P':
      precision = P_PRECISION;
      exponent_bits = -1;
      break;

    default:
      make_invalid_floating_point_number (words);
      return (NULL);
    }

  generic_floating_point_number.high
    = generic_floating_point_number.low + precision - 1 + GUARD;

  if (atof_generic (&return_value, ".", EXP_CHARS,
		    &generic_floating_point_number))
    {
      make_invalid_floating_point_number (words);
      return NULL;
    }
  gen_to_words (words, precision, exponent_bits);

  /* Restore the generic_floating_point_number's storage alloc (and
     everything else).  */
  generic_floating_point_number = save_gen_flonum;

  return return_value;
}

/* Turn generic_floating_point_number into a real float/double/extended.  */

int
gen_to_words (LITTLENUM_TYPE *words, int precision, long exponent_bits)
{
  int return_value = 0;

  long exponent_1;
  long exponent_2;
  long exponent_3;
  long exponent_4;
  int exponent_skippage;
  LITTLENUM_TYPE word1;
  LITTLENUM_TYPE *lp;
  LITTLENUM_TYPE *words_end;

  words_end = words + precision;
#ifdef TC_M68K
  if (precision == X_PRECISION)
    /* On the m68k the extended precision format has a gap of 16 bits
       between the exponent and the mantissa.  */
    words_end++;
#endif

  if (generic_floating_point_number.low > generic_floating_point_number.leader)
    {
      /* 0.0e0 seen.  */
      if (generic_floating_point_number.sign == '+')
	words[0] = 0x0000;
      else
	words[0] = 0x8000;
      memset (&words[1], '\0',
	      (words_end - words - 1) * sizeof (LITTLENUM_TYPE));
      return return_value;
    }

  /* NaN:  Do the right thing.  */
  if (generic_floating_point_number.sign == 0)
    {
      if (TC_LARGEST_EXPONENT_IS_NORMAL (precision))
	as_warn (_("NaNs are not supported by this target\n"));
      if (precision == F_PRECISION)
	{
	  words[0] = 0x7fff;
	  words[1] = 0xffff;
	}
      else if (precision == X_PRECISION)
	{
#ifdef TC_M68K
	  words[0] = 0x7fff;
	  words[1] = 0;
	  words[2] = 0xffff;
	  words[3] = 0xffff;
	  words[4] = 0xffff;
	  words[5] = 0xffff;
#else /* ! TC_M68K  */
#ifdef TC_I386
	  words[0] = 0xffff;
	  words[1] = 0xc000;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
#else /* ! TC_I386  */
	  abort ();
#endif /* ! TC_I386  */
#endif /* ! TC_M68K  */
	}
      else
	{
	  words[0] = 0x7fff;
	  words[1] = 0xffff;
	  words[2] = 0xffff;
	  words[3] = 0xffff;
	}
      return return_value;
    }
  else if (generic_floating_point_number.sign == 'P')
    {
      if (TC_LARGEST_EXPONENT_IS_NORMAL (precision))
	as_warn (_("Infinities are not supported by this target\n"));

      /* +INF:  Do the right thing.  */
      if (precision == F_PRECISION)
	{
	  words[0] = 0x7f80;
	  words[1] = 0;
	}
      else if (precision == X_PRECISION)
	{
#ifdef TC_M68K
	  words[0] = 0x7fff;
	  words[1] = 0;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
	  words[5] = 0;
#else /* ! TC_M68K  */
#ifdef TC_I386
	  words[0] = 0x7fff;
	  words[1] = 0x8000;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
#else /* ! TC_I386  */
	  abort ();
#endif /* ! TC_I386  */
#endif /* ! TC_M68K  */
	}
      else
	{
	  words[0] = 0x7ff0;
	  words[1] = 0;
	  words[2] = 0;
	  words[3] = 0;
	}
      return return_value;
    }
  else if (generic_floating_point_number.sign == 'N')
    {
      if (TC_LARGEST_EXPONENT_IS_NORMAL (precision))
	as_warn (_("Infinities are not supported by this target\n"));

      /* Negative INF.  */
      if (precision == F_PRECISION)
	{
	  words[0] = 0xff80;
	  words[1] = 0x0;
	}
      else if (precision == X_PRECISION)
	{
#ifdef TC_M68K
	  words[0] = 0xffff;
	  words[1] = 0;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
	  words[5] = 0;
#else /* ! TC_M68K  */
#ifdef TC_I386
	  words[0] = 0xffff;
	  words[1] = 0x8000;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
#else /* ! TC_I386  */
	  abort ();
#endif /* ! TC_I386  */
#endif /* ! TC_M68K  */
	}
      else
	{
	  words[0] = 0xfff0;
	  words[1] = 0x0;
	  words[2] = 0x0;
	  words[3] = 0x0;
	}
      return return_value;
    }

  /* The floating point formats we support have:
     Bit 15 is sign bit.
     Bits 14:n are excess-whatever exponent.
     Bits n-1:0 (if any) are most significant bits of fraction.
     Bits 15:0 of the next word(s) are the next most significant bits.

     So we need: number of bits of exponent, number of bits of
     mantissa.  */
  bits_left_in_littlenum = LITTLENUM_NUMBER_OF_BITS;
  littlenum_pointer = generic_floating_point_number.leader;
  littlenums_left = (1
		     + generic_floating_point_number.leader
		     - generic_floating_point_number.low);

  /* Seek (and forget) 1st significant bit.  */
  for (exponent_skippage = 0; !next_bits (1); ++exponent_skippage);
  exponent_1 = (generic_floating_point_number.exponent
		+ generic_floating_point_number.leader
		+ 1
		- generic_floating_point_number.low);

  /* Radix LITTLENUM_RADIX, point just higher than
     generic_floating_point_number.leader.  */
  exponent_2 = exponent_1 * LITTLENUM_NUMBER_OF_BITS;

  /* Radix 2.  */
  exponent_3 = exponent_2 - exponent_skippage;

  /* Forget leading zeros, forget 1st bit.  */
  exponent_4 = exponent_3 + ((1 << (exponent_bits - 1)) - 2);

  /* Offset exponent.  */
  lp = words;

  /* Word 1.  Sign, exponent and perhaps high bits.  */
  word1 = ((generic_floating_point_number.sign == '+')
	   ? 0
	   : (1 << (LITTLENUM_NUMBER_OF_BITS - 1)));

  /* Assume 2's complement integers.  */
  if (exponent_4 <= 0)
    {
      int prec_bits;
      int num_bits;

      unget_bits (1);
      num_bits = -exponent_4;
      prec_bits =
	LITTLENUM_NUMBER_OF_BITS * precision - (exponent_bits + 1 + num_bits);
#ifdef TC_I386
      if (precision == X_PRECISION && exponent_bits == 15)
	{
	  /* On the i386 a denormalized extended precision float is
	     shifted down by one, effectively decreasing the exponent
	     bias by one.  */
	  prec_bits -= 1;
	  num_bits += 1;
	}
#endif

      if (num_bits >= LITTLENUM_NUMBER_OF_BITS - exponent_bits)
	{
	  /* Bigger than one littlenum.  */
	  num_bits -= (LITTLENUM_NUMBER_OF_BITS - 1) - exponent_bits;
	  *lp++ = word1;
	  if (num_bits + exponent_bits + 1
	      > precision * LITTLENUM_NUMBER_OF_BITS)
	    {
	      /* Exponent overflow.  */
	      make_invalid_floating_point_number (words);
	      return return_value;
	    }
#ifdef TC_M68K
	  if (precision == X_PRECISION && exponent_bits == 15)
	    *lp++ = 0;
#endif
	  while (num_bits >= LITTLENUM_NUMBER_OF_BITS)
	    {
	      num_bits -= LITTLENUM_NUMBER_OF_BITS;
	      *lp++ = 0;
	    }
	  if (num_bits)
	    *lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS - (num_bits));
	}
      else
	{
	  if (precision == X_PRECISION && exponent_bits == 15)
	    {
	      *lp++ = word1;
#ifdef TC_M68K
	      *lp++ = 0;
#endif
	      *lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS - num_bits);
	    }
	  else
	    {
	      word1 |= next_bits ((LITTLENUM_NUMBER_OF_BITS - 1)
				  - (exponent_bits + num_bits));
	      *lp++ = word1;
	    }
	}
      while (lp < words_end)
	*lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS);

      /* Round the mantissa up, but don't change the number.  */
      if (next_bits (1))
	{
	  --lp;
	  if (prec_bits >= LITTLENUM_NUMBER_OF_BITS)
	    {
	      int n = 0;
	      int tmp_bits;

	      n = 0;
	      tmp_bits = prec_bits;
	      while (tmp_bits > LITTLENUM_NUMBER_OF_BITS)
		{
		  if (lp[n] != (LITTLENUM_TYPE) - 1)
		    break;
		  --n;
		  tmp_bits -= LITTLENUM_NUMBER_OF_BITS;
		}
	      if (tmp_bits > LITTLENUM_NUMBER_OF_BITS
		  || (lp[n] & mask[tmp_bits]) != mask[tmp_bits]
		  || (prec_bits != (precision * LITTLENUM_NUMBER_OF_BITS
				    - exponent_bits - 1)
#ifdef TC_I386
		      /* An extended precision float with only the integer
			 bit set would be invalid.  That must be converted
			 to the smallest normalized number.  */
		      && !(precision == X_PRECISION
			   && prec_bits == (precision * LITTLENUM_NUMBER_OF_BITS
					    - exponent_bits - 2))
#endif
		      ))
		{
		  unsigned long carry;

		  for (carry = 1; carry && (lp >= words); lp--)
		    {
		      carry = *lp + carry;
		      *lp = carry;
		      carry >>= LITTLENUM_NUMBER_OF_BITS;
		    }
		}
	      else
		{
		  /* This is an overflow of the denormal numbers.  We
                     need to forget what we have produced, and instead
                     generate the smallest normalized number.  */
		  lp = words;
		  word1 = ((generic_floating_point_number.sign == '+')
			   ? 0
			   : (1 << (LITTLENUM_NUMBER_OF_BITS - 1)));
		  word1 |= (1
			    << ((LITTLENUM_NUMBER_OF_BITS - 1)
				- exponent_bits));
		  *lp++ = word1;
#ifdef TC_I386
		  /* Set the integer bit in the extended precision format.
		     This cannot happen on the m68k where the mantissa
		     just overflows into the integer bit above.  */
		  if (precision == X_PRECISION)
		    *lp++ = 1 << (LITTLENUM_NUMBER_OF_BITS - 1);
#endif
		  while (lp < words_end)
		    *lp++ = 0;
		}
	    }
	  else
	    *lp += 1;
	}

      return return_value;
    }
  else if ((unsigned long) exponent_4 > mask[exponent_bits]
	   || (! TC_LARGEST_EXPONENT_IS_NORMAL (precision)
	       && (unsigned long) exponent_4 == mask[exponent_bits]))
    {
      /* Exponent overflow.  Lose immediately.  */

      /* We leave return_value alone: admit we read the
	 number, but return a floating exception
	 because we can't encode the number.  */
      make_invalid_floating_point_number (words);
      return return_value;
    }
  else
    {
      word1 |= (exponent_4 << ((LITTLENUM_NUMBER_OF_BITS - 1) - exponent_bits))
	| next_bits ((LITTLENUM_NUMBER_OF_BITS - 1) - exponent_bits);
    }

  *lp++ = word1;

  /* X_PRECISION is special: on the 68k, it has 16 bits of zero in the
     middle.  Either way, it is then followed by a 1 bit.  */
  if (exponent_bits == 15 && precision == X_PRECISION)
    {
#ifdef TC_M68K
      *lp++ = 0;
#endif
      *lp++ = (1 << (LITTLENUM_NUMBER_OF_BITS - 1)
	       | next_bits (LITTLENUM_NUMBER_OF_BITS - 1));
    }

  /* The rest of the words are just mantissa bits.  */
  while (lp < words_end)
    *lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS);

  if (next_bits (1))
    {
      unsigned long carry;
      /* Since the NEXT bit is a 1, round UP the mantissa.
	 The cunning design of these hidden-1 floats permits
	 us to let the mantissa overflow into the exponent, and
	 it 'does the right thing'. However, we lose if the
	 highest-order bit of the lowest-order word flips.
	 Is that clear?  */

      /* #if (sizeof(carry)) < ((sizeof(bits[0]) * BITS_PER_CHAR) + 2)
	 Please allow at least 1 more bit in carry than is in a LITTLENUM.
	 We need that extra bit to hold a carry during a LITTLENUM carry
	 propagation. Another extra bit (kept 0) will assure us that we
	 don't get a sticky sign bit after shifting right, and that
	 permits us to propagate the carry without any masking of bits.
	 #endif */
      for (carry = 1, lp--; carry; lp--)
	{
	  carry = *lp + carry;
	  *lp = carry;
	  carry >>= LITTLENUM_NUMBER_OF_BITS;
	  if (lp == words)
	    break;
	}
      if (precision == X_PRECISION && exponent_bits == 15)
	{
	  /* Extended precision numbers have an explicit integer bit
	     that we may have to restore.  */
	  if (lp == words)
	    {
#ifdef TC_M68K
	      /* On the m68k there is a gap of 16 bits.  We must
		 explicitly propagate the carry into the exponent.  */
	      words[0] += words[1];
	      words[1] = 0;
	      lp++;
#endif
	      /* Put back the integer bit.  */
	      lp[1] |= 1 << (LITTLENUM_NUMBER_OF_BITS - 1);
	    }
	}
      if ((word1 ^ *words) & (1 << (LITTLENUM_NUMBER_OF_BITS - 1)))
	{
	  /* We leave return_value alone: admit we read the number,
	     but return a floating exception because we can't encode
	     the number.  */
	  *words &= ~(1 << (LITTLENUM_NUMBER_OF_BITS - 1));
	}
    }
  return return_value;
}

#ifdef TEST
char *
print_gen (gen)
     FLONUM_TYPE *gen;
{
  FLONUM_TYPE f;
  LITTLENUM_TYPE arr[10];
  double dv;
  float fv;
  static char sbuf[40];

  if (gen)
    {
      f = generic_floating_point_number;
      generic_floating_point_number = *gen;
    }
  gen_to_words (&arr[0], 4, 11);
  memcpy (&dv, &arr[0], sizeof (double));
  sprintf (sbuf, "%x %x %x %x %.14G   ", arr[0], arr[1], arr[2], arr[3], dv);
  gen_to_words (&arr[0], 2, 8);
  memcpy (&fv, &arr[0], sizeof (float));
  sprintf (sbuf + strlen (sbuf), "%x %x %.12g\n", arr[0], arr[1], fv);

  if (gen)
    generic_floating_point_number = f;

  return (sbuf);
}
#endif

extern const char FLT_CHARS[];
#define MAX_LITTLENUMS 6

/* This is a utility function called from various tc-*.c files.  It
   is here in order to reduce code duplication.
   
   Turn a string at input_line_pointer into a floating point constant
   of type TYPE (a character found in the FLT_CHARS macro), and store
   it as LITTLENUMS in the bytes buffer LITP.  The number of chars
   emitted is stored in *SIZEP.  BIG_WORDIAN is TRUE if the littlenums
   should be emitted most significant littlenum first.

   An error message is returned, or a NULL pointer if everything went OK.  */

char *
ieee_md_atof (int type,
	      char *litP,
	      int *sizeP,
	      bfd_boolean big_wordian)
{
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;
  int prec = 0;

  if (strchr (FLT_CHARS, type) != NULL)
    {
      switch (type)
	{
	case 'f':
	case 'F':
	case 's':
	case 'S':
	  prec = F_PRECISION;
	  break;

	case 'd':
	case 'D':
	case 'r':
	case 'R':
	  prec = D_PRECISION;
	  break;

	case 't':
	case 'T':
	  prec = X_PRECISION;
	  type = 'x';		/* This is what atof_ieee() understands.  */
	  break;

	case 'x':
	case 'X':
	case 'p':
	case 'P':
#ifdef TC_M68K
	  /* Note: on the m68k there is a gap of 16 bits (one littlenum)
	     between the exponent and mantissa.  Hence the precision is
	     6 and not 5.  */
	  prec = P_PRECISION + 1;
#else
	  prec = P_PRECISION;
#endif
	  break;

	default:
	  break;
	}
    }
  /* The 'f' and 'd' types are always recognised, even if the target has
     not put them into the FLT_CHARS macro.  This is because the 'f' type
     can come from the .dc.s, .dcb.s, .float or .single pseudo-ops and the
     'd' type from the .dc.d, .dbc.d or .double pseudo-ops.

     The 'x' type is not implicitly recongised however, even though it can
     be generated by the .dc.x and .dbc.x pseudo-ops because not all targets
     can support floating point values that big.  ie the target has to
     explicitly allow them by putting them into FLT_CHARS.  */
  else if (type == 'f')
    prec = F_PRECISION;
  else if (type == 'd')
    prec = D_PRECISION;

  if (prec == 0)
    {
      *sizeP = 0;
      return _("Unrecognized or unsupported floating point constant");
    }

  gas_assert (prec <= MAX_LITTLENUMS);

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  if (big_wordian)
    {
      for (wordP = words; prec --;)
	{
	  md_number_to_chars (litP, (valueT) (* wordP ++), sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
    }
  else
    {
      for (wordP = words + prec; prec --;)
	{
	  md_number_to_chars (litP, (valueT) (* -- wordP), sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
    }

  return NULL;
}
@


1.18
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d422 1
a422 1
  for (exponent_skippage = 0; !next_bits (1); ++exponent_skippage);;
@


1.17
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2007 Free Software Foundation, Inc.
d288 1
a288 1
	as_warn ("NaNs are not supported by this target\n");
d327 1
a327 1
	as_warn ("Infinities are not supported by this target\n");
d368 1
a368 1
	as_warn ("Infinities are not supported by this target\n");
@


1.16
log
@Remove duplicate definitions of the md_atof() function
@
text
@d787 1
a787 1
  assert (prec <= MAX_LITTLENUMS);
@


1.15
log
@Switch to GPLv3
@
text
@d163 1
a163 1
	   int what_kind,		/* 'd', 'f', 'g', 'h'.  */
a220 1

d698 13
d712 48
d761 53
@


1.14
log
@Update the address and phone number of the FSF
@
text
@d2 2
a3 2
   Copyright 1987, 1992, 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2005
   Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.13
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.12
log
@update copyright dates
@
text
@a26 4
static int next_bits PARAMS ((int));
static void unget_bits PARAMS ((int));
static void make_invalid_floating_point_number PARAMS ((LITTLENUM_TYPE *));

d30 5
a34 5
#define MAX_PRECISION (5)
#define F_PRECISION (2)
#define D_PRECISION (4)
#define X_PRECISION (5)
#define P_PRECISION (5)
d37 1
a37 1
#define GUARD (2)
d85 1
a85 2
next_bits (number_of_bits)
     int number_of_bits;
d90 2
a91 1
    return (0);
d119 1
a119 2
unget_bits (num)
     int num;
d139 1
a139 2
make_invalid_floating_point_number (words)
     LITTLENUM_TYPE *words;
d162 3
a164 4
atof_ieee (str, what_kind, words)
     char *str;			/* Text to convert to binary.  */
     int what_kind;		/* 'd', 'f', 'g', 'h'.  */
     LITTLENUM_TYPE *words;	/* Build the binary here.  */
d238 1
a238 1
      return (NULL);
d252 1
a252 4
gen_to_words (words, precision, exponent_bits)
     LITTLENUM_TYPE *words;
     int precision;
     long exponent_bits;
@


1.11
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 1987, 1992, 1994, 1996, 1997, 1998, 1999, 2000, 2001
@


1.10
log
@Fix thinko in last commit.
@
text
@a675 4
#if 0
	  make_invalid_floating_point_number (words);
	  return return_value;
#endif
a680 20
#if 0
/* Unused.  */
/* This routine is a real kludge.  Someone really should do it better,
   but I'm too lazy, and I don't understand this stuff all too well
   anyway. (JF)  */

static void
int_to_gen (x)
     long x;
{
  char buf[20];
  char *bufp;

  sprintf (buf, "%ld", x);
  bufp = &buf[0];
  if (atof_generic (&bufp, ".", EXP_CHARS, &generic_floating_point_number))
    as_bad (_("Error converting number to floating point (Exponent overflow?)"));
}
#endif

@


1.9
log
@	* doc/invoke.texi (TC_LARGEST_EXPONENT_IS_NORMAL): Document.
	* config/atof-ieee.c (TC_LARGEST_EXPONENT_IS_NORMAL): Add an
	argument for the precision.
	(gen_to_words): Update accordingly.
@
text
@d43 1
a43 1
#ifndef TC_LARGEST_EXPONENT_IS_NORMAL(PRECISION)
@


1.8
log
@Fix copyright notices
@
text
@a21 7
/* Some float formats are based on the IEEE standard, but use the
   largest exponent for normal numbers instead of NaNs and infinites.
   The macro TC_LARGEST_EXPONENT_IS_NORMAL should evaluate to true
   if the target machine uses such a format.  The macro can depend on
   command line flags if necessary.  There is no need to define the
   macro if it would always be 0.  */

d43 2
a44 2
#ifndef TC_LARGEST_EXPONENT_IS_NORMAL
#define TC_LARGEST_EXPONENT_IS_NORMAL 0
d298 1
a298 1
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
d337 1
a337 1
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
d378 1
a378 1
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
d594 1
a594 1
	   || (! TC_LARGEST_EXPONENT_IS_NORMAL
@


1.7
log
@Print warnings if NaNs are found and the target CPU does not support them
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.6
log
@2000-08-05  Kazu Hirata  <kazu@@hxi.com>

	* config/atof-ieee.c: Fix formatting.
	* config/atof-tahoe.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d22 7
d50 4
d305 2
d344 3
d385 3
d600 3
a602 1
  else if ((unsigned long) exponent_4 >= mask[exponent_bits])
@


1.6.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1987, 1992, 1994, 1996, 1997, 1998, 1999, 2000, 2001
@


1.6.2.2
log
@Merge from mainline.
@
text
@a21 7
/* Some float formats are based on the IEEE standard, but use the
   largest exponent for normal numbers instead of NaNs and infinites.
   The macro TC_LARGEST_EXPONENT_IS_NORMAL should evaluate to true
   if the target machine uses such a format.  The macro can depend on
   command line flags if necessary.  There is no need to define the
   macro if it would always be 0.  */

a42 4
#ifndef TC_LARGEST_EXPONENT_IS_NORMAL
#define TC_LARGEST_EXPONENT_IS_NORMAL 0
#endif

a293 2
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
	as_warn ("NaNs are not supported by this target\n");
a330 3
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
	as_warn ("Infinities are not supported by this target\n");

a368 3
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
	as_warn ("Infinities are not supported by this target\n");

d581 1
a581 3
  else if ((unsigned long) exponent_4 > mask[exponent_bits]
	   || (! TC_LARGEST_EXPONENT_IS_NORMAL
	       && (unsigned long) exponent_4 == mask[exponent_bits]))
@


1.5
log
@	* config/atof-ieee.c (gen_to_words): When adding carry back in,
	don't permit lp to become less than the words array.
@
text
@d32 1
a32 1
/* Precision in LittleNums. */
d40 1
a40 1
/* Length in LittleNums of guard bits. */
a79 1

d102 3
a104 1
	  return_value |= (*littlenum_pointer >> bits_left_in_littlenum) & mask[number_of_bits];
d110 2
a111 1
      return_value = mask[number_of_bits] & (*littlenum_pointer >> bits_left_in_littlenum);
d113 1
a113 1
  return (return_value);
d116 2
a117 1
/* Num had better be less than LITTLENUM_NUMBER_OF_BITS */
d130 2
a131 1
      bits_left_in_littlenum = num - (LITTLENUM_NUMBER_OF_BITS - bits_left_in_littlenum);
d144 2
a145 1
  words[0] = (LITTLENUM_TYPE) ((unsigned) -1) >> 1; /* Zero the leftmost bit */
d153 3
a155 6
/************************************************************************\
 *	Warning: this returns 16-bit LITTLENUMs. It is up to the caller	*
 *	to figure out any alignment problems and to conspire for the	*
 *	bytes/word to be emitted in the right order. Bigendians beware!	*
 *									*
\************************************************************************/
d161 2
a162 1
/* Returns pointer past text consumed. */
d165 3
a167 3
     char *str;			/* Text to convert to binary. */
     int what_kind;		/* 'd', 'f', 'g', 'h' */
     LITTLENUM_TYPE *words;	/* Build the binary here. */
d169 2
a170 2
  /* Extra bits for zeroed low-order bits.  The 1st MAX_PRECISION are
     zeroed, the last contain flonum bits. */
d173 1
a173 1
  /* Number of 16-bit words in the format. */
d192 1
a192 1
     have 15 leading 0 bits, so could be useless. */
d253 1
d281 1
a281 1
      /* 0.0e0 seen. */
d288 1
a288 1
      return (return_value);
d291 1
a291 1
  /* NaN:  Do the right thing */
d308 1
a308 1
#else /* ! TC_M68K */
d315 1
a315 1
#else /* ! TC_I386 */
d317 2
a318 2
#endif /* ! TC_I386 */
#endif /* ! TC_M68K */
d331 1
a331 1
      /* +INF:  Do the right thing */
d346 1
a346 1
#else /* ! TC_M68K */
d353 1
a353 1
#else /* ! TC_I386 */
d355 2
a356 2
#endif /* ! TC_I386 */
#endif /* ! TC_M68K */
d365 1
a365 1
      return (return_value);
d369 1
a369 1
      /* Negative INF */
d384 1
a384 1
#else /* ! TC_M68K */
d391 1
a391 1
#else /* ! TC_I386 */
d393 2
a394 2
#endif /* ! TC_I386 */
#endif /* ! TC_M68K */
d403 1
a403 1
      return (return_value);
d405 9
a413 10
  /*
   * The floating point formats we support have:
   * Bit 15 is sign bit.
   * Bits 14:n are excess-whatever exponent.
   * Bits n-1:0 (if any) are most significant bits of fraction.
   * Bits 15:0 of the next word(s) are the next most significant bits.
   *
   * So we need: number of bits of exponent, number of bits of
   * mantissa.
   */
d419 2
a420 1
  /* Seek (and forget) 1st significant bit */
d426 1
d428 1
a428 1
     generic_floating_point_number.leader. */
d430 2
a431 1
  /* Radix 2. */
d433 2
a434 1
  /* Forget leading zeros, forget 1st bit. */
a435 1
  /* Offset exponent. */
d437 1
d440 1
a440 1
  /* Word 1. Sign, exponent and perhaps high bits. */
d445 1
a445 1
  /* Assume 2's complement integers. */
d453 2
a454 1
      prec_bits = LITTLENUM_NUMBER_OF_BITS * precision - (exponent_bits + 1 + num_bits);
d468 1
a468 1
	  /* Bigger than one littlenum */
d471 2
a472 1
	  if (num_bits + exponent_bits + 1 > precision * LITTLENUM_NUMBER_OF_BITS)
d474 1
a474 1
	      /* Exponent overflow */
d476 1
a476 1
	      return (return_value);
d502 2
a503 1
	      word1 |= next_bits ((LITTLENUM_NUMBER_OF_BITS - 1) - (exponent_bits + num_bits));
d510 1
a510 1
      /* Round the mantissa up, but don't change the number */
d583 5
a587 9
      /*
       * Exponent overflow. Lose immediately.
       */

      /*
       * We leave return_value alone: admit we read the
       * number, but return a floating exception
       * because we can't encode the number.
       */
d600 1
a600 1
     middle.  Either way, it is then followed by a 1 bit. */
d610 1
a610 1
  /* The rest of the words are just mantissa bits. */
d617 6
a622 8
      /*
       * Since the NEXT bit is a 1, round UP the mantissa.
       * The cunning design of these hidden-1 floats permits
       * us to let the mantissa overflow into the exponent, and
       * it 'does the right thing'. However, we lose if the
       * highest-order bit of the lowest-order word flips.
       * Is that clear?
       */
d647 1
a647 1
		 explicitly propagate the carry into the exponent. */
d652 1
a652 1
	      /* Put back the integer bit.  */ 
d655 1
a655 1
 	}
d658 3
a660 4
	  /* We leave return_value alone: admit we read the
	   * number, but return a floating exception
	   * because we can't encode the number.
	   */
d662 4
a665 2
	  /* make_invalid_floating_point_number (words); */
	  /* return return_value; */
d668 1
a668 1
  return (return_value);
d671 2
a672 1
#if 0 /* unused */
d676 1
d715 1
a715 3
    {
      generic_floating_point_number = f;
    }
a720 2

/* end of atof-ieee.c */
@


1.4
log
@fix copyright
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 1999
d627 1
a627 1
      for (carry = 1, lp--; carry && (lp >= words); lp--)
d632 2
@


1.4.2.1
log
@	* config/atof-ieee.c (gen_to_words): When adding carry back in,
	don't permit lp to become less than the words array.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d627 1
a627 1
      for (carry = 1, lp--; carry; lp--)
a631 2
	  if (lp == words)
	    break;
@


1.3
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config/atof-ieee.c (atof_ieee): Change what_kind to int.
	* config/atof-vax.c (flonum_gen2vax): Change format_letter to
	int.
	(md_atof): Return NULL rather than 0.
	* config/tc-i386.c (md_atof): Change type to int.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 1998
@


1.2
log
@	* config/atof-ieee.c (gen_to_words): Correctly round a
	denormalized number.  Fix off-by-one in range checking for
	exponent in a denormal.
@
text
@d163 1
a163 1
     char what_kind;		/* 'd', 'f', 'g', 'h' */
@


1.1
log
@Initial revision
@
text
@d463 1
a463 1
	  if (num_bits + exponent_bits + 1 >= precision * LITTLENUM_NUMBER_OF_BITS)
d504 1
a504 1
	  if (prec_bits > LITTLENUM_NUMBER_OF_BITS)
d518 13
a530 1
	      if (tmp_bits > LITTLENUM_NUMBER_OF_BITS || (lp[n] & mask[tmp_bits]) != mask[tmp_bits])
d554 7
d565 1
a565 1
	  else if ((*lp & mask[prec_bits]) != mask[prec_bits])
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

