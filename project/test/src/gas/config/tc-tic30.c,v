head	1.30;
access;
symbols
	binutils-2_24-branch:1.30.0.8
	binutils-2_24-branchpoint:1.30
	binutils-2_21_1:1.29
	binutils-2_23_2:1.30
	binutils-2_23_1:1.30
	binutils-2_23:1.30
	binutils-2_23-branch:1.30.0.6
	binutils-2_23-branchpoint:1.30
	binutils-2_22_branch:1.30.0.4
	binutils-2_22:1.30
	binutils-2_22-branch:1.30.0.2
	binutils-2_22-branchpoint:1.30
	binutils-2_21:1.29
	binutils-2_21-branch:1.29.0.2
	binutils-2_21-branchpoint:1.29
	binutils-2_20_1:1.28
	binutils-2_20:1.28
	binutils-arc-20081103-branch:1.24.0.6
	binutils-arc-20081103-branchpoint:1.24
	binutils-2_20-branch:1.28.0.2
	binutils-2_20-branchpoint:1.28
	dje-cgen-play1-branch:1.25.0.2
	dje-cgen-play1-branchpoint:1.25
	arc-20081103-branch:1.24.0.4
	arc-20081103-branchpoint:1.24
	binutils-2_19_1:1.24
	binutils-2_19:1.24
	binutils-2_19-branch:1.24.0.2
	binutils-2_19-branchpoint:1.24
	binutils-2_18:1.23
	binutils-2_18-branch:1.23.0.2
	binutils-2_18-branchpoint:1.23
	binutils-csl-coldfire-4_1-32:1.19
	binutils-csl-sourcerygxx-4_1-32:1.19
	binutils-csl-innovasic-fido-3_4_4-33:1.19
	binutils-csl-sourcerygxx-3_4_4-32:1.13
	binutils-csl-coldfire-4_1-30:1.19
	binutils-csl-sourcerygxx-4_1-30:1.19
	binutils-csl-coldfire-4_1-28:1.19
	binutils-csl-sourcerygxx-4_1-29:1.19
	binutils-csl-sourcerygxx-4_1-28:1.19
	binutils-csl-arm-2006q3-27:1.19
	binutils-csl-sourcerygxx-4_1-27:1.19
	binutils-csl-arm-2006q3-26:1.19
	binutils-csl-sourcerygxx-4_1-26:1.19
	binutils-csl-sourcerygxx-4_1-25:1.19
	binutils-csl-sourcerygxx-4_1-24:1.19
	binutils-csl-sourcerygxx-4_1-23:1.19
	binutils-csl-sourcerygxx-4_1-21:1.19
	binutils-csl-arm-2006q3-21:1.19
	binutils-csl-sourcerygxx-4_1-22:1.19
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.19
	binutils-csl-sourcerygxx-4_1-20:1.19
	binutils-csl-arm-2006q3-19:1.19
	binutils-csl-sourcerygxx-4_1-19:1.19
	binutils-csl-sourcerygxx-4_1-18:1.19
	binutils-csl-renesas-4_1-9:1.19
	binutils-csl-sourcerygxx-3_4_4-25:1.13
	binutils-csl-renesas-4_1-8:1.19
	binutils-csl-renesas-4_1-7:1.19
	binutils-csl-renesas-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-15:1.19
	binutils-csl-sourcerygxx-4_1-13:1.19
	binutils-2_17:1.19
	binutils-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-wrs-linux-3_4_4-24:1.13
	binutils-csl-wrs-linux-3_4_4-23:1.13
	binutils-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-arm-2006q1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-wrs-linux-3_4_4-22:1.13
	binutils-csl-coldfire-4_1-11:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-coldfire-4_1-10:1.19
	binutils-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-wrs-linux-3_4_4-21:1.13
	binutils-csl-morpho-4_1-4:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-wrs-linux-3_4_4-20:1.13
	binutils-2_17-branch:1.19.0.4
	binutils-2_17-branchpoint:1.19
	binutils-csl-2_17-branch:1.19.0.2
	binutils-csl-2_17-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.13.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.13
	binutils-2_16_1:1.13
	binutils-csl-arm-2005q1b:1.13
	binutils-2_16:1.13
	binutils-csl-arm-2005q1a:1.13
	binutils-csl-arm-2005q1-branch:1.13.0.4
	binutils-csl-arm-2005q1-branchpoint:1.13
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.12
	csl-arm-2004-q3:1.12
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	binutils-2_15-branch:1.12.0.6
	cagney_bfdfile-20040213-branch:1.12.0.4
	cagney_bfdfile-20040213-branchpoint:1.12
	cagney_bigcore-20040122-branch:1.12.0.2
	cagney_bigcore-20040122-branchpoint:1.12
	csl-arm-2003-q4:1.12
	binutils-2_14:1.10
	binutils-2_14-branch:1.10.0.2
	binutils-2_14-branchpoint:1.10
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	binutils-2_13_1:1.8
	binutils-2_13:1.8
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.4
	binutils-2_12_1:1.8
	binutils-2_12:1.8
	binutils-2_12-branch:1.8.0.2
	binutils-2_12-branchpoint:1.8
	cygnus_cvs_20020108_pre:1.8
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.30
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2011.05.18.13.52.44;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.24.11.45.01;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.02.14.24.03;	author hjl;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.02.13.34.26;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.08.05.57.21;	author bje;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.07.19.27.41;	author wilson;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.05.09.13.03;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.23.11.18.13;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.03.11.47.55;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.22.15.32.28;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.20.01.36.49;	author kazu;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.12.21.34.52;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.15.21.28.59;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.19.05.33.29;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.23.24.25;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.16.00.59.49;	author kazu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.09.15.01.06.52;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.02.02.52.10;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.06.22.14.07.39;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2001.06.07.03.15.33;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;


desc
@@


1.30
log
@	PR gas/12754
	* config/tc-tic30.c (ordinal_names): Allow translation of the
	ordinal names.
@
text
@/* tc-c30.c -- Assembly code for the Texas Instruments TMS320C30
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2009
   Free Software Foundation, Inc.
   Contributed by Steven Haworth (steve@@pm.cse.rmit.edu.au)

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Texas Instruments TMS320C30 machine specific gas.
   Written by Steven Haworth (steve@@pm.cse.rmit.edu.au).
   Bugs & suggestions are completely welcome.  This is free software.
   Please help us make it better.  */

#include "as.h"
#include "safe-ctype.h"
#include "opcode/tic30.h"

/* Put here all non-digit non-letter characters that may occur in an
   operand.  */
static char operand_special_chars[] = "%$-+(,)*._~/<>&^!:[@@]";
static char *ordinal_names[] =
{
  N_("first"), N_("second"), N_("third"), N_("fourth"), N_("fifth")
};

const char comment_chars[]        = ";";
const char line_comment_chars[]   = "*";
const char line_separator_chars[] = "";

const char *md_shortopts = "";
struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "fFdDxX";

/* Chars that can be used to separate mant from exp in floating point
   nums.  */
const char EXP_CHARS[] = "eE";

/* Tables for lexical analysis.  */
static char opcode_chars[256];
static char register_chars[256];
static char operand_chars[256];
static char space_chars[256];
static char identifier_chars[256];
static char digit_chars[256];

/* Lexical macros.  */
#define is_opcode_char(x)     (opcode_chars     [(unsigned char) x])
#define is_operand_char(x)    (operand_chars    [(unsigned char) x])
#define is_register_char(x)   (register_chars   [(unsigned char) x])
#define is_space_char(x)      (space_chars      [(unsigned char) x])
#define is_identifier_char(x) (identifier_chars [(unsigned char) x])
#define is_digit_char(x)      (digit_chars      [(unsigned char) x])

const pseudo_typeS md_pseudo_table[] =
{
  {0, 0, 0}
};

static int ATTRIBUTE_PRINTF_1
debug (const char *string, ...)
{
  if (flag_debug)
    {
      char str[100];

      VA_OPEN (argptr, string);
      VA_FIXEDARG (argptr, const char *, string);
      vsprintf (str, string, argptr);
      VA_CLOSE (argptr);
      if (str[0] == '\0')
	return (0);
      fputs (str, USE_STDOUT ? stdout : stderr);
      return strlen (str);
    }
  else
    return 0;
}

/* Hash table for opcode lookup.  */
static struct hash_control *op_hash;
/* Hash table for parallel opcode lookup.  */
static struct hash_control *parop_hash;
/* Hash table for register lookup.  */
static struct hash_control *reg_hash;
/* Hash table for indirect addressing lookup.  */
static struct hash_control *ind_hash;

void
md_begin (void)
{
  const char *hash_err;

  debug ("In md_begin()\n");
  op_hash = hash_new ();

  {
    const insn_template *current_optab = tic30_optab;

    for (; current_optab < tic30_optab_end; current_optab++)
      {
	hash_err = hash_insert (op_hash, current_optab->name,
				(char *) current_optab);
	if (hash_err)
	  as_fatal ("Internal Error: Can't Hash %s: %s",
		    current_optab->name, hash_err);
      }
  }

  parop_hash = hash_new ();

  {
    const partemplate *current_parop = tic30_paroptab;

    for (; current_parop < tic30_paroptab_end; current_parop++)
      {
	hash_err = hash_insert (parop_hash, current_parop->name,
				(char *) current_parop);
	if (hash_err)
	  as_fatal ("Internal Error: Can't Hash %s: %s",
		    current_parop->name, hash_err);
      }
  }

  reg_hash = hash_new ();

  {
    const reg *current_reg = tic30_regtab;

    for (; current_reg < tic30_regtab_end; current_reg++)
      {
	hash_err = hash_insert (reg_hash, current_reg->name,
				(char *) current_reg);
	if (hash_err)
	  as_fatal ("Internal Error: Can't Hash %s: %s",
		    current_reg->name, hash_err);
      }
  }

  ind_hash = hash_new ();

  {
    const ind_addr_type *current_ind = tic30_indaddr_tab;

    for (; current_ind < tic30_indaddrtab_end; current_ind++)
      {
	hash_err = hash_insert (ind_hash, current_ind->syntax,
				(char *) current_ind);
	if (hash_err)
	  as_fatal ("Internal Error: Can't Hash %s: %s",
		    current_ind->syntax, hash_err);
      }
  }

  /* Fill in lexical tables:  opcode_chars, operand_chars, space_chars.  */
  {
    int c;
    char *p;

    for (c = 0; c < 256; c++)
      {
	if (ISLOWER (c) || ISDIGIT (c))
	  {
	    opcode_chars[c] = c;
	    register_chars[c] = c;
	  }
	else if (ISUPPER (c))
	  {
	    opcode_chars[c] = TOLOWER (c);
	    register_chars[c] = opcode_chars[c];
	  }
	else if (c == ')' || c == '(')
	  register_chars[c] = c;

	if (ISUPPER (c) || ISLOWER (c) || ISDIGIT (c))
	  operand_chars[c] = c;

	if (ISDIGIT (c) || c == '-')
	  digit_chars[c] = c;

	if (ISALPHA (c) || c == '_' || c == '.' || ISDIGIT (c))
	  identifier_chars[c] = c;

	if (c == ' ' || c == '\t')
	  space_chars[c] = c;

	if (c == '_')
	  opcode_chars[c] = c;
      }
    for (p = operand_special_chars; *p != '\0'; p++)
      operand_chars[(unsigned char) *p] = *p;
  }
}

/* Address Mode OR values.  */
#define AM_Register  0x00000000
#define AM_Direct    0x00200000
#define AM_Indirect  0x00400000
#define AM_Immediate 0x00600000
#define AM_NotReq    0xFFFFFFFF

/* PC Relative OR values.  */
#define PC_Register 0x00000000
#define PC_Relative 0x02000000

typedef struct
{
  unsigned op_type;
  struct
  {
    int resolved;
    unsigned address;
    char *label;
    expressionS direct_expr;
  } direct;
  struct
  {
    unsigned mod;
    int ARnum;
    unsigned char disp;
  } indirect;
  struct
  {
    unsigned opcode;
  } reg;
  struct
  {
    int resolved;
    int decimal_found;
    float f_number;
    int s_number;
    unsigned int u_number;
    char *label;
    expressionS imm_expr;
  } immediate;
} operand;

insn_template *opcode;

struct tic30_insn
{
  insn_template *tm;		/* Template of current instruction.  */
  unsigned opcode;		/* Final opcode.  */
  unsigned int operands;	/* Number of given operands.  */
  /* Type of operand given in instruction.  */
  operand *operand_type[MAX_OPERANDS];
  unsigned addressing_mode;	/* Final addressing mode of instruction.  */
};

struct tic30_insn insn;
static int found_parallel_insn;

static char output_invalid_buf[sizeof (unsigned char) * 2 + 6];

static char *
output_invalid (char c)
{
  if (ISPRINT (c))
    snprintf (output_invalid_buf, sizeof (output_invalid_buf),
	      "'%c'", c);
  else
    snprintf (output_invalid_buf, sizeof (output_invalid_buf), 
	      "(0x%x)", (unsigned char) c);
  return output_invalid_buf;
}

/* next_line points to the next line after the current instruction
   (current_line).  Search for the parallel bars, and if found, merge two
   lines into internal syntax for a parallel instruction:
     q_[INSN1]_[INSN2] [OPERANDS1] | [OPERANDS2]
   By this stage, all comments are scrubbed, and only the bare lines are
   given.  */

#define NONE           0
#define START_OPCODE   1
#define END_OPCODE     2
#define START_OPERANDS 3
#define END_OPERANDS   4

static char *
tic30_find_parallel_insn (char *current_line, char *next_line)
{
  int found_parallel = 0;
  char first_opcode[256];
  char second_opcode[256];
  char first_operands[256];
  char second_operands[256];
  char *parallel_insn;

  debug ("In tic30_find_parallel_insn()\n");
  while (!is_end_of_line[(unsigned char) *next_line])
    {
      if (*next_line == PARALLEL_SEPARATOR
	  && *(next_line + 1) == PARALLEL_SEPARATOR)
	{
	  found_parallel = 1;
	  next_line++;
	  break;
	}
      next_line++;
    }
  if (!found_parallel)
    return NULL;
  debug ("Found a parallel instruction\n");

  {
    int i;
    char *op, *operands, *line;

    for (i = 0; i < 2; i++)
      {
	if (i == 0)
	  {
	    op = &first_opcode[0];
	    operands = &first_operands[0];
	    line = current_line;
	  }
	else
	  {
	    op = &second_opcode[0];
	    operands = &second_operands[0];
	    line = next_line;
	  }

	{
	  int search_status = NONE;
	  int char_ptr = 0;
	  char c;

	  while (!is_end_of_line[(unsigned char) (c = *line)])
	    {
	      if (is_opcode_char (c) && search_status == NONE)
		{
		  op[char_ptr++] = TOLOWER (c);
		  search_status = START_OPCODE;
		}
	      else if (is_opcode_char (c) && search_status == START_OPCODE)
		op[char_ptr++] = TOLOWER (c);
	      else if (!is_opcode_char (c) && search_status == START_OPCODE)
		{
		  op[char_ptr] = '\0';
		  char_ptr = 0;
		  search_status = END_OPCODE;
		}
	      else if (is_operand_char (c) && search_status == START_OPERANDS)
		operands[char_ptr++] = c;

	      if (is_operand_char (c) && search_status == END_OPCODE)
		{
		  operands[char_ptr++] = c;
		  search_status = START_OPERANDS;
		}

	      line++;
	    }
	  if (search_status != START_OPERANDS)
	    return NULL;
	  operands[char_ptr] = '\0';
	}
      }
  }
  parallel_insn = malloc (strlen (first_opcode) + strlen (first_operands)
			  + strlen (second_opcode) + strlen (second_operands) + 8);
  sprintf (parallel_insn, "q_%s_%s %s | %s",
	   first_opcode, second_opcode,
	   first_operands, second_operands);
  debug ("parallel insn = %s\n", parallel_insn);
  return parallel_insn;
}

#undef NONE
#undef START_OPCODE
#undef END_OPCODE
#undef START_OPERANDS
#undef END_OPERANDS

static operand *
tic30_operand (char *token)
{
  unsigned int count;
  char ind_buffer[strlen (token)];
  operand *current_op;

  debug ("In tic30_operand with %s\n", token);
  current_op = malloc (sizeof (* current_op));
  memset (current_op, '\0', sizeof (operand));

  if (*token == DIRECT_REFERENCE)
    {
      char *token_posn = token + 1;
      int direct_label = 0;

      debug ("Found direct reference\n");
      while (*token_posn)
	{
	  if (!is_digit_char (*token_posn))
	    direct_label = 1;
	  token_posn++;
	}

      if (direct_label)
	{
	  char *save_input_line_pointer;
	  segT retval;

	  debug ("Direct reference is a label\n");
	  current_op->direct.label = token + 1;
	  save_input_line_pointer = input_line_pointer;
	  input_line_pointer = token + 1;
	  debug ("Current input_line_pointer: %s\n", input_line_pointer);
	  retval = expression (&current_op->direct.direct_expr);

	  debug ("Expression type: %d\n",
		 current_op->direct.direct_expr.X_op);
	  debug ("Expression addnum: %ld\n",
		 (long) current_op->direct.direct_expr.X_add_number);
	  debug ("Segment: %p\n", retval);

	  input_line_pointer = save_input_line_pointer;

	  if (current_op->direct.direct_expr.X_op == O_constant)
	    {
	      current_op->direct.address =
		current_op->direct.direct_expr.X_add_number;
	      current_op->direct.resolved = 1;
	    }
	}
      else
	{
	  debug ("Direct reference is a number\n");
	  current_op->direct.address = atoi (token + 1);
	  current_op->direct.resolved = 1;
	}
      current_op->op_type = Direct;
    }
  else if (*token == INDIRECT_REFERENCE)
    {
      /* Indirect reference operand.  */
      int found_ar = 0;
      int found_disp = 0;
      int ar_number = -1;
      int disp_number = 0;
      int buffer_posn = 1;
      ind_addr_type *ind_addr_op;

      debug ("Found indirect reference\n");
      ind_buffer[0] = *token;

      for (count = 1; count < strlen (token); count++)
	{
	  /* Strip operand.  */
	  ind_buffer[buffer_posn] = TOLOWER (*(token + count));

	  if ((*(token + count - 1) == 'a' || *(token + count - 1) == 'A')
	      && (*(token + count) == 'r' || *(token + count) == 'R'))
	    {
	      /* AR reference is found, so get its number and remove
		 it from the buffer so it can pass through hash_find().  */
	      if (found_ar)
		{
		  as_bad (_("More than one AR register found in indirect reference"));
		  return NULL;
		}
	      if (*(token + count + 1) < '0' || *(token + count + 1) > '7')
		{
		  as_bad (_("Illegal AR register in indirect reference"));
		  return NULL;
		}
	      ar_number = *(token + count + 1) - '0';
	      found_ar = 1;
	      count++;
	    }

	  if (*(token + count) == '(')
	    {
	      /* Parenthesis found, so check if a displacement value is
		 inside.  If so, get the value and remove it from the
		 buffer.  */
	      if (is_digit_char (*(token + count + 1)))
		{
		  char disp[10];
		  int disp_posn = 0;

		  if (found_disp)
		    {
		      as_bad (_("More than one displacement found in indirect reference"));
		      return NULL;
		    }
		  count++;
		  while (*(token + count) != ')')
		    {
		      if (!is_digit_char (*(token + count)))
			{
			  as_bad (_("Invalid displacement in indirect reference"));
			  return NULL;
			}
		      disp[disp_posn++] = *(token + (count++));
		    }
		  disp[disp_posn] = '\0';
		  disp_number = atoi (disp);
		  count--;
		  found_disp = 1;
		}
	    }
	  buffer_posn++;
	}

      ind_buffer[buffer_posn] = '\0';
      if (!found_ar)
	{
	  as_bad (_("AR register not found in indirect reference"));
	  return NULL;
	}

      ind_addr_op = (ind_addr_type *) hash_find (ind_hash, ind_buffer);
      if (ind_addr_op)
	{
	  debug ("Found indirect reference: %s\n", ind_addr_op->syntax);
	  if (ind_addr_op->displacement == IMPLIED_DISP)
	    {
	      found_disp = 1;
	      disp_number = 1;
	    }
	  else if ((ind_addr_op->displacement == DISP_REQUIRED) && !found_disp)
	    {
	      /* Maybe an implied displacement of 1 again.  */
	      as_bad (_("required displacement wasn't given in indirect reference"));
	      return 0;
	    }
	}
      else
	{
	  as_bad (_("illegal indirect reference"));
	  return NULL;
	}

      if (found_disp && (disp_number < 0 || disp_number > 255))
	{
	  as_bad (_("displacement must be an unsigned 8-bit number"));
	  return NULL;
	}

      current_op->indirect.mod = ind_addr_op->modfield;
      current_op->indirect.disp = disp_number;
      current_op->indirect.ARnum = ar_number;
      current_op->op_type = Indirect;
    }
  else
    {
      reg *regop = (reg *) hash_find (reg_hash, token);

      if (regop)
	{
	  debug ("Found register operand: %s\n", regop->name);
	  if (regop->regtype == REG_ARn)
	    current_op->op_type = ARn;
	  else if (regop->regtype == REG_Rn)
	    current_op->op_type = Rn;
	  else if (regop->regtype == REG_DP)
	    current_op->op_type = DPReg;
	  else
	    current_op->op_type = OtherReg;
	  current_op->reg.opcode = regop->opcode;
	}
      else
	{
	  if (!is_digit_char (*token)
	      || *(token + 1) == 'x'
	      || strchr (token, 'h'))
	    {
	      char *save_input_line_pointer;
	      segT retval;

	      debug ("Probably a label: %s\n", token);
	      current_op->immediate.label = malloc (strlen (token) + 1);
	      strcpy (current_op->immediate.label, token);
	      current_op->immediate.label[strlen (token)] = '\0';
	      save_input_line_pointer = input_line_pointer;
	      input_line_pointer = token;

	      debug ("Current input_line_pointer: %s\n", input_line_pointer);
	      retval = expression (&current_op->immediate.imm_expr);
	      debug ("Expression type: %d\n",
		     current_op->immediate.imm_expr.X_op);
	      debug ("Expression addnum: %ld\n",
		     (long) current_op->immediate.imm_expr.X_add_number);
	      debug ("Segment: %p\n", retval);
	      input_line_pointer = save_input_line_pointer;

	      if (current_op->immediate.imm_expr.X_op == O_constant)
		{
		  current_op->immediate.s_number
		    = current_op->immediate.imm_expr.X_add_number;
		  current_op->immediate.u_number
		    = (unsigned int) current_op->immediate.imm_expr.X_add_number;
		  current_op->immediate.resolved = 1;
		}
	    }
	  else
	    {
	      debug ("Found a number or displacement\n");
	      for (count = 0; count < strlen (token); count++)
		if (*(token + count) == '.')
		  current_op->immediate.decimal_found = 1;
	      current_op->immediate.label = malloc (strlen (token) + 1);
	      strcpy (current_op->immediate.label, token);
	      current_op->immediate.label[strlen (token)] = '\0';
	      current_op->immediate.f_number = (float) atof (token);
	      current_op->immediate.s_number = (int) atoi (token);
	      current_op->immediate.u_number = (unsigned int) atoi (token);
	      current_op->immediate.resolved = 1;
	    }
	  current_op->op_type = Disp | Abs24 | Imm16 | Imm24;
	  if (current_op->immediate.u_number <= 31)
	    current_op->op_type |= IVector;
	}
    }
  return current_op;
}

struct tic30_par_insn
{
  partemplate *tm;		/* Template of current parallel instruction.  */
  unsigned operands[2];		/* Number of given operands for each insn.  */
  /* Type of operand given in instruction.  */
  operand *operand_type[2][MAX_OPERANDS];
  int swap_operands;		/* Whether to swap operands around.  */
  unsigned p_field;		/* Value of p field in multiply add/sub instructions.  */
  unsigned opcode;		/* Final opcode.  */
};

struct tic30_par_insn p_insn;

static int
tic30_parallel_insn (char *token)
{
  static partemplate *p_opcode;
  char *current_posn = token;
  char *token_start;
  char save_char;

  debug ("In tic30_parallel_insn with %s\n", token);
  memset (&p_insn, '\0', sizeof (p_insn));

  while (is_opcode_char (*current_posn))
    current_posn++;
  {
    /* Find instruction.  */
    save_char = *current_posn;
    *current_posn = '\0';
    p_opcode = (partemplate *) hash_find (parop_hash, token);
    if (p_opcode)
      {
	debug ("Found instruction %s\n", p_opcode->name);
	p_insn.tm = p_opcode;
      }
    else
      {
	char first_opcode[6] = {0};
	char second_opcode[6] = {0};
	unsigned int i;
	int current_opcode = -1;
	int char_ptr = 0;

	for (i = 0; i < strlen (token); i++)
	  {
	    char ch = *(token + i);

	    if (ch == '_' && current_opcode == -1)
	      {
		current_opcode = 0;
		continue;
	      }

	    if (ch == '_' && current_opcode == 0)
	      {
		current_opcode = 1;
		char_ptr = 0;
		continue;
	      }

	    switch (current_opcode)
	      {
	      case 0:
		first_opcode[char_ptr++] = ch;
		break;
	      case 1:
		second_opcode[char_ptr++] = ch;
		break;
	      }
	  }

	debug ("first_opcode = %s\n", first_opcode);
	debug ("second_opcode = %s\n", second_opcode);
	sprintf (token, "q_%s_%s", second_opcode, first_opcode);
	p_opcode = (partemplate *) hash_find (parop_hash, token);

	if (p_opcode)
	  {
	    debug ("Found instruction %s\n", p_opcode->name);
	    p_insn.tm = p_opcode;
	    p_insn.swap_operands = 1;
	  }
	else
	  return 0;
      }
    *current_posn = save_char;
  }

  {
    /* Find operands.  */
    int paren_not_balanced;
    int expecting_operand = 0;
    int found_separator = 0;

    do
      {
	/* Skip optional white space before operand.  */
	while (!is_operand_char (*current_posn)
	       && *current_posn != END_OF_INSN)
	  {
	    if (!is_space_char (*current_posn)
		&& *current_posn != PARALLEL_SEPARATOR)
	      {
		as_bad (_("Invalid character %s before %s operand"),
			output_invalid (*current_posn),
			ordinal_names[insn.operands]);
		return 1;
	      }
	    if (*current_posn == PARALLEL_SEPARATOR)
	      found_separator = 1;
	    current_posn++;
	  }

	token_start = current_posn;
	paren_not_balanced = 0;

	while (paren_not_balanced || *current_posn != ',')
	  {
	    if (*current_posn == END_OF_INSN)
	      {
		if (paren_not_balanced)
		  {
		    as_bad (_("Unbalanced parenthesis in %s operand."),
			    ordinal_names[insn.operands]);
		    return 1;
		  }
		else
		  break;
	      }
	    else if (*current_posn == PARALLEL_SEPARATOR)
	      {
		while (is_space_char (*(current_posn - 1)))
		  current_posn--;
		break;
	      }
	    else if (!is_operand_char (*current_posn)
		     && !is_space_char (*current_posn))
	      {
		as_bad (_("Invalid character %s in %s operand"),
			output_invalid (*current_posn),
			ordinal_names[insn.operands]);
		return 1;
	      }

	    if (*current_posn == '(')
	      ++paren_not_balanced;
	    if (*current_posn == ')')
	      --paren_not_balanced;
	    current_posn++;
	  }

	if (current_posn != token_start)
	  {
	    /* Yes, we've read in another operand.  */
	    p_insn.operands[found_separator]++;
	    if (p_insn.operands[found_separator] > MAX_OPERANDS)
	      {
		as_bad (_("Spurious operands; (%d operands/instruction max)"),
			MAX_OPERANDS);
		return 1;
	      }

	    /* Now parse operand adding info to 'insn' as we go along.  */
	    save_char = *current_posn;
	    *current_posn = '\0';
	    p_insn.operand_type[found_separator][p_insn.operands[found_separator] - 1] =
	      tic30_operand (token_start);
	    *current_posn = save_char;
	    if (!p_insn.operand_type[found_separator][p_insn.operands[found_separator] - 1])
	      return 1;
	  }
	else
	  {
	    if (expecting_operand)
	      {
		as_bad (_("Expecting operand after ','; got nothing"));
		return 1;
	      }
	    if (*current_posn == ',')
	      {
		as_bad (_("Expecting operand before ','; got nothing"));
		return 1;
	      }
	  }

	/* Now *current_posn must be either ',' or END_OF_INSN.  */
	if (*current_posn == ',')
	  {
	    if (*++current_posn == END_OF_INSN)
	      {
		/* Just skip it, if it's \n complain.  */
		as_bad (_("Expecting operand after ','; got nothing"));
		return 1;
	      }
	    expecting_operand = 1;
	  }
      }
    while (*current_posn != END_OF_INSN);
  }

  if (p_insn.swap_operands)
    {
      int temp_num, i;
      operand *temp_op;

      temp_num = p_insn.operands[0];
      p_insn.operands[0] = p_insn.operands[1];
      p_insn.operands[1] = temp_num;
      for (i = 0; i < MAX_OPERANDS; i++)
	{
	  temp_op = p_insn.operand_type[0][i];
	  p_insn.operand_type[0][i] = p_insn.operand_type[1][i];
	  p_insn.operand_type[1][i] = temp_op;
	}
    }

  if (p_insn.operands[0] != p_insn.tm->operands_1)
    {
      as_bad (_("incorrect number of operands given in the first instruction"));
      return 1;
    }

  if (p_insn.operands[1] != p_insn.tm->operands_2)
    {
      as_bad (_("incorrect number of operands given in the second instruction"));
      return 1;
    }

  debug ("Number of operands in first insn: %d\n", p_insn.operands[0]);
  debug ("Number of operands in second insn: %d\n", p_insn.operands[1]);

  {
    /* Now check if operands are correct.  */
    int count;
    int num_rn = 0;
    int num_ind = 0;

    for (count = 0; count < 2; count++)
      {
	unsigned int i;
	for (i = 0; i < p_insn.operands[count]; i++)
	  {
	    if ((p_insn.operand_type[count][i]->op_type &
		 p_insn.tm->operand_types[count][i]) == 0)
	      {
		as_bad (_("%s instruction, operand %d doesn't match"),
			ordinal_names[count], i + 1);
		return 1;
	      }

	    /* Get number of R register and indirect reference contained
	       within the first two operands of each instruction.  This is
	       required for the multiply parallel instructions which require
	       two R registers and two indirect references, but not in any
	       particular place.  */
	    if ((p_insn.operand_type[count][i]->op_type & Rn) && i < 2)
	      num_rn++;
	    else if ((p_insn.operand_type[count][i]->op_type & Indirect)
		     && i < 2)
	      num_ind++;
	  }
      }

    if ((p_insn.tm->operand_types[0][0] & (Indirect | Rn))
	== (Indirect | Rn))
      {
	/* Check for the multiply instructions.  */
	if (num_rn != 2)
	  {
	    as_bad (_("incorrect format for multiply parallel instruction"));
	    return 1;
	  }

	if (num_ind != 2)
	  {
	    /* Shouldn't get here.  */
	    as_bad (_("incorrect format for multiply parallel instruction"));
	    return 1;
	  }

	if ((p_insn.operand_type[0][2]->reg.opcode != 0x00)
	    && (p_insn.operand_type[0][2]->reg.opcode != 0x01))
	  {
	    as_bad (_("destination for multiply can only be R0 or R1"));
	    return 1;
	  }

	if ((p_insn.operand_type[1][2]->reg.opcode != 0x02)
	    && (p_insn.operand_type[1][2]->reg.opcode != 0x03))
	  {
	    as_bad (_("destination for add/subtract can only be R2 or R3"));
	    return 1;
	  }

	/* Now determine the P field for the instruction.  */
	if (p_insn.operand_type[0][0]->op_type & Indirect)
	  {
	    if (p_insn.operand_type[0][1]->op_type & Indirect)
	      p_insn.p_field = 0x00000000;	/* Ind * Ind, Rn  +/- Rn.  */
	    else if (p_insn.operand_type[1][0]->op_type & Indirect)
	      p_insn.p_field = 0x01000000;	/* Ind * Rn,  Ind +/- Rn.  */
	    else
	      p_insn.p_field = 0x03000000;	/* Ind * Rn,  Rn  +/- Ind.  */
	  }
	else
	  {
	    if (p_insn.operand_type[0][1]->op_type & Rn)
	      p_insn.p_field = 0x02000000;	/* Rn  * Rn,  Ind +/- Ind.  */
	    else if (p_insn.operand_type[1][0]->op_type & Indirect)
	      {
		operand *temp;
		p_insn.p_field = 0x01000000;	/* Rn  * Ind, Ind +/- Rn.  */
		/* Need to swap the two multiply operands around so that
		   everything is in its place for the opcode makeup.
		   ie so Ind * Rn, Ind +/- Rn.  */
		temp = p_insn.operand_type[0][0];
		p_insn.operand_type[0][0] = p_insn.operand_type[0][1];
		p_insn.operand_type[0][1] = temp;
	      }
	    else
	      {
		operand *temp;
		p_insn.p_field = 0x03000000;	/* Rn  * Ind, Rn  +/- Ind.  */
		temp = p_insn.operand_type[0][0];
		p_insn.operand_type[0][0] = p_insn.operand_type[0][1];
		p_insn.operand_type[0][1] = temp;
	      }
	  }
      }
  }

  debug ("P field: %08X\n", p_insn.p_field);

  /* Finalise opcode.  This is easier for parallel instructions as they have
     to be fully resolved, there are no memory addresses allowed, except
     through indirect addressing, so there are no labels to resolve.  */
  p_insn.opcode = p_insn.tm->base_opcode;

  switch (p_insn.tm->oporder)
    {
    case OO_4op1:
      p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum);
      p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 3);
      p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum << 8);
      p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 11);
      p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
      p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 22);
      break;

    case OO_4op2:
      p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum);
      p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 3);
      p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.ARnum << 8);
      p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.mod << 11);
      p_insn.opcode |= (p_insn.operand_type[1][1]->reg.opcode << 19);
      p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 22);
      if (p_insn.operand_type[1][1]->reg.opcode == p_insn.operand_type[0][1]->reg.opcode)
	as_warn (_("loading the same register in parallel operation"));
      break;

    case OO_4op3:
      p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.ARnum);
      p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.mod << 3);
      p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum << 8);
      p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 11);
      p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
      p_insn.opcode |= (p_insn.operand_type[0][0]->reg.opcode << 22);
      break;

    case OO_5op1:
      p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum);
      p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 3);
      p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum << 8);
      p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 11);
      p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
      p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 19);
      p_insn.opcode |= (p_insn.operand_type[0][2]->reg.opcode << 22);
      break;

    case OO_5op2:
      p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.ARnum);
      p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.mod << 3);
      p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum << 8);
      p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 11);
      p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
      p_insn.opcode |= (p_insn.operand_type[0][0]->reg.opcode << 19);
      p_insn.opcode |= (p_insn.operand_type[0][2]->reg.opcode << 22);
      break;

    case OO_PField:
      p_insn.opcode |= p_insn.p_field;
      if (p_insn.operand_type[0][2]->reg.opcode == 0x01)
	p_insn.opcode |= 0x00800000;
      if (p_insn.operand_type[1][2]->reg.opcode == 0x03)
	p_insn.opcode |= 0x00400000;

      switch (p_insn.p_field)
	{
	case 0x00000000:
	  p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.ARnum);
	  p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.mod << 3);
	  p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum << 8);
	  p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 11);
	  p_insn.opcode |= (p_insn.operand_type[1][1]->reg.opcode << 16);
	  p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 19);
	  break;
	case 0x01000000:
	  p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.ARnum);
	  p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.mod << 3);
	  p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum << 8);
	  p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 11);
	  p_insn.opcode |= (p_insn.operand_type[1][1]->reg.opcode << 16);
	  p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 19);
	  break;
	case 0x02000000:
	  p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum);
	  p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 3);
	  p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.ARnum << 8);
	  p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.mod << 11);
	  p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 16);
	  p_insn.opcode |= (p_insn.operand_type[0][0]->reg.opcode << 19);
	  break;
	case 0x03000000:
	  p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum);
	  p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 3);
	  p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum << 8);
	  p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 11);
	  p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
	  p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 19);
	  break;
	}
      break;
    }

  {
    char *p;

    p = frag_more (INSN_SIZE);
    md_number_to_chars (p, (valueT) p_insn.opcode, INSN_SIZE);
  }

  {
    unsigned int i, j;

    for (i = 0; i < 2; i++)
      for (j = 0; j < p_insn.operands[i]; j++)
	free (p_insn.operand_type[i][j]);
  }

  debug ("Final opcode: %08X\n", p_insn.opcode);
  debug ("\n");

  return 1;
}

/* In order to get gas to ignore any | chars at the start of a line,
   this function returns true if a | is found in a line.  */

int
tic30_unrecognized_line (int c)
{
  debug ("In tc_unrecognized_line\n");
  return (c == PARALLEL_SEPARATOR);
}

int
md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED,
			       segT segment ATTRIBUTE_UNUSED)
{
  debug ("In md_estimate_size_before_relax()\n");
  return 0;
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 segT sec ATTRIBUTE_UNUSED,
		 register fragS *fragP ATTRIBUTE_UNUSED)
{
  debug ("In md_convert_frag()\n");
}

void
md_apply_fix (fixS *fixP,
	       valueT *valP,
	       segT seg ATTRIBUTE_UNUSED)
{
  valueT value = *valP;

  debug ("In md_apply_fix() with value = %ld\n", (long) value);
  debug ("Values in fixP\n");
  debug ("fx_size = %d\n", fixP->fx_size);
  debug ("fx_pcrel = %d\n", fixP->fx_pcrel);
  debug ("fx_where = %ld\n", fixP->fx_where);
  debug ("fx_offset = %d\n", (int) fixP->fx_offset);
  {
    char *buf = fixP->fx_frag->fr_literal + fixP->fx_where;

    value /= INSN_SIZE;
    if (fixP->fx_size == 1)
      /* Special fix for LDP instruction.  */
      value = (value & 0x00FF0000) >> 16;

    debug ("new value = %ld\n", (long) value);
    md_number_to_chars (buf, value, fixP->fx_size);
  }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

int
md_parse_option (int c ATTRIBUTE_UNUSED,
		 char *arg ATTRIBUTE_UNUSED)
{
  debug ("In md_parse_option()\n");
  return 0;
}

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
  debug ("In md_show_usage()\n");
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  debug ("In md_undefined_symbol()\n");
  return (symbolS *) 0;
}

valueT
md_section_align (segT segment, valueT size)
{
  debug ("In md_section_align() segment = %p and size = %lu\n",
	 segment, (unsigned long) size);
  size = (size + 3) / 4;
  size *= 4;
  debug ("New size value = %lu\n", (unsigned long) size);
  return size;
}

long
md_pcrel_from (fixS *fixP)
{
  int offset;

  debug ("In md_pcrel_from()\n");
  debug ("fx_where = %ld\n", fixP->fx_where);
  debug ("fx_size = %d\n", fixP->fx_size);
  /* Find the opcode that represents the current instruction in the
     fr_literal storage area, and check bit 21.  Bit 21 contains whether the
     current instruction is a delayed one or not, and then set the offset
     value appropriately.  */
  if (fixP->fx_frag->fr_literal[fixP->fx_where - fixP->fx_size + 1] & 0x20)
    offset = 3;
  else
    offset = 1;
  debug ("offset = %d\n", offset);
  /* PC Relative instructions have a format:
     displacement = Label - (PC + offset)
     This function returns PC + offset where:
     fx_where - fx_size = PC
     INSN_SIZE * offset = offset number of instructions.  */
  return fixP->fx_where - fixP->fx_size + (INSN_SIZE * offset);
}

char *
md_atof (int what_statement_type,
	 char *literalP,
	 int *sizeP)
{
  int prec;
  char *token;
  char keepval;
  unsigned long value;
  float float_value;

  debug ("In md_atof()\n");
  debug ("precision = %c\n", what_statement_type);
  debug ("literal = %s\n", literalP);
  debug ("line = ");
  token = input_line_pointer;
  while (!is_end_of_line[(unsigned char) *input_line_pointer]
	 && (*input_line_pointer != ','))
    {
      debug ("%c", *input_line_pointer);
      input_line_pointer++;
    }

  keepval = *input_line_pointer;
  *input_line_pointer = '\0';
  debug ("\n");
  float_value = (float) atof (token);
  *input_line_pointer = keepval;
  debug ("float_value = %f\n", float_value);

  switch (what_statement_type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return _("Unrecognized or unsupported floating point constant");
    }

  if (float_value == 0.0)
    value = (prec == 2) ? 0x00008000L : 0x80000000L;
  else
    {
      unsigned long exp, sign, mant, tmsfloat;
      union
      {
	float f;
	long  l;
      }
      converter;

      converter.f = float_value;
      tmsfloat = converter.l;
      sign = tmsfloat & 0x80000000;
      mant = tmsfloat & 0x007FFFFF;
      exp = tmsfloat & 0x7F800000;
      exp <<= 1;
      if (exp == 0xFF000000)
	{
	  if (mant == 0)
	    value = 0x7F7FFFFF;
	  else if (sign == 0)
	    value = 0x7F7FFFFF;
	  else
	    value = 0x7F800000;
	}
      else
	{
	  exp -= 0x7F000000;
	  if (sign)
	    {
	      mant = mant & 0x007FFFFF;
	      mant = -mant;
	      mant = mant & 0x00FFFFFF;
	      if (mant == 0)
		{
		  mant |= 0x00800000;
		  exp = (long) exp - 0x01000000;
		}
	    }
	  tmsfloat = exp | mant;
	  value = tmsfloat;
	}
      if (prec == 2)
	{
	  long expon, mantis;

	  if (tmsfloat == 0x80000000)
	    value = 0x8000;
	  else
	    {
	      value = 0;
	      expon = (tmsfloat & 0xFF000000);
	      expon >>= 24;
	      mantis = tmsfloat & 0x007FFFFF;
	      if (tmsfloat & 0x00800000)
		{
		  mantis |= 0xFF000000;
		  mantis += 0x00000800;
		  mantis >>= 12;
		  mantis |= 0x00000800;
		  mantis &= 0x0FFF;
		  if (expon > 7)
		    value = 0x7800;
		}
	      else
		{
		  mantis |= 0x00800000;
		  mantis += 0x00000800;
		  expon += (mantis >> 24);
		  mantis >>= 12;
		  mantis &= 0x07FF;
		  if (expon > 7)
		    value = 0x77FF;
		}
	      if (expon < -8)
		value = 0x8000;
	      if (value == 0)
		{
		  mantis = (expon << 12) | mantis;
		  value = mantis & 0xFFFF;
		}
	    }
	}
    }
  md_number_to_chars (literalP, value, prec);
  *sizeP = prec;
  return NULL;
}

void
md_number_to_chars (char *buf, valueT val, int n)
{
  debug ("In md_number_to_chars()\n");
  number_to_chars_bigendian (buf, val, n);
}

#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
#define MAP(SZ,PCREL,TYPE)	case F(SZ,PCREL): code = (TYPE); break

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixP)
{
  arelent *rel;
  bfd_reloc_code_real_type code = 0;

  debug ("In tc_gen_reloc()\n");
  debug ("fixP.size = %d\n", fixP->fx_size);
  debug ("fixP.pcrel = %d\n", fixP->fx_pcrel);
  debug ("addsy.name = %s\n", S_GET_NAME (fixP->fx_addsy));

  switch (F (fixP->fx_size, fixP->fx_pcrel))
    {
      MAP (1, 0, BFD_RELOC_TIC30_LDP);
      MAP (2, 0, BFD_RELOC_16);
      MAP (3, 0, BFD_RELOC_24);
      MAP (2, 1, BFD_RELOC_16_PCREL);
      MAP (4, 0, BFD_RELOC_32);
    default:
      as_bad (_("Can not do %d byte %srelocation"), fixP->fx_size,
	      fixP->fx_pcrel ? _("pc-relative ") : "");
    }
#undef MAP
#undef F

  rel = xmalloc (sizeof (* rel));
  gas_assert (rel != 0);
  rel->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
  rel->address = fixP->fx_frag->fr_address + fixP->fx_where;
  rel->addend = 0;
  rel->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (!rel->howto)
    {
      const char *name;

      name = S_GET_NAME (fixP->fx_addsy);
      if (name == NULL)
	name = "<unknown>";
      as_fatal ("Cannot generate relocation type for symbol %s, code %s",
		name, bfd_get_reloc_code_name (code));
    }
  return rel;
}

void
md_operand (expressionS *expressionP ATTRIBUTE_UNUSED)
{
  debug ("In md_operand()\n");
}

void
md_assemble (char *line)
{
  insn_template *op;
  char *current_posn;
  char *token_start;
  char save_char;
  unsigned int count;

  debug ("In md_assemble() with argument %s\n", line);
  memset (&insn, '\0', sizeof (insn));
  if (found_parallel_insn)
    {
      debug ("Line is second part of parallel instruction\n\n");
      found_parallel_insn = 0;
      return;
    }
  if ((current_posn =
       tic30_find_parallel_insn (line, input_line_pointer + 1)) == NULL)
    current_posn = line;
  else
    found_parallel_insn = 1;

  while (is_space_char (*current_posn))
    current_posn++;

  token_start = current_posn;

  if (!is_opcode_char (*current_posn))
    {
      as_bad (_("Invalid character %s in opcode"),
	      output_invalid (*current_posn));
      return;
    }
  /* Check if instruction is a parallel instruction
     by seeing if the first character is a q.  */
  if (*token_start == 'q')
    {
      if (tic30_parallel_insn (token_start))
	{
	  if (found_parallel_insn)
	    free (token_start);
	  return;
	}
    }
  while (is_opcode_char (*current_posn))
    current_posn++;
  {
    /* Find instruction.  */
    save_char = *current_posn;
    *current_posn = '\0';
    op = (insn_template *) hash_find (op_hash, token_start);
    if (op)
      {
	debug ("Found instruction %s\n", op->name);
	insn.tm = op;
      }
    else
      {
	debug ("Didn't find insn\n");
	as_bad (_("Unknown TMS320C30 instruction: %s"), token_start);
	return;
      }
    *current_posn = save_char;
  }

  if (*current_posn != END_OF_INSN)
    {
      /* Find operands.  */
      int paren_not_balanced;
      int expecting_operand = 0;
      int this_operand;
      do
	{
	  /* Skip optional white space before operand.  */
	  while (!is_operand_char (*current_posn)
		 && *current_posn != END_OF_INSN)
	    {
	      if (!is_space_char (*current_posn))
		{
		  as_bad (_("Invalid character %s before %s operand"),
			  output_invalid (*current_posn),
			  ordinal_names[insn.operands]);
		  return;
		}
	      current_posn++;
	    }
	  token_start = current_posn;
	  paren_not_balanced = 0;
	  while (paren_not_balanced || *current_posn != ',')
	    {
	      if (*current_posn == END_OF_INSN)
		{
		  if (paren_not_balanced)
		    {
		      as_bad (_("Unbalanced parenthesis in %s operand."),
			      ordinal_names[insn.operands]);
		      return;
		    }
		  else
		    break;
		}
	      else if (!is_operand_char (*current_posn)
		       && !is_space_char (*current_posn))
		{
		  as_bad (_("Invalid character %s in %s operand"),
			  output_invalid (*current_posn),
			  ordinal_names[insn.operands]);
		  return;
		}
	      if (*current_posn == '(')
		++paren_not_balanced;
	      if (*current_posn == ')')
		--paren_not_balanced;
	      current_posn++;
	    }
	  if (current_posn != token_start)
	    {
	      /* Yes, we've read in another operand.  */
	      this_operand = insn.operands++;
	      if (insn.operands > MAX_OPERANDS)
		{
		  as_bad (_("Spurious operands; (%d operands/instruction max)"),
			  MAX_OPERANDS);
		  return;
		}

	      /* Now parse operand adding info to 'insn' as we go along.  */
	      save_char = *current_posn;
	      *current_posn = '\0';
	      insn.operand_type[this_operand] = tic30_operand (token_start);
	      *current_posn = save_char;
	      if (insn.operand_type[this_operand] == NULL)
		return;
	    }
	  else
	    {
	      if (expecting_operand)
		{
		  as_bad (_("Expecting operand after ','; got nothing"));
		  return;
		}
	      if (*current_posn == ',')
		{
		  as_bad (_("Expecting operand before ','; got nothing"));
		  return;
		}
	    }

	  /* Now *current_posn must be either ',' or END_OF_INSN.  */
	  if (*current_posn == ',')
	    {
	      if (*++current_posn == END_OF_INSN)
		{
		  /* Just skip it, if it's \n complain.  */
		  as_bad (_("Expecting operand after ','; got nothing"));
		  return;
		}
	      expecting_operand = 1;
	    }
	}
      while (*current_posn != END_OF_INSN);
    }

  debug ("Number of operands found: %d\n", insn.operands);

  /* Check that number of operands is correct.  */
  if (insn.operands != insn.tm->operands)
    {
      unsigned int i;
      unsigned int numops = insn.tm->operands;

      /* If operands are not the same, then see if any of the operands are
	 not required.  Then recheck with number of given operands.  If they
	 are still not the same, then give an error, otherwise carry on.  */
      for (i = 0; i < insn.tm->operands; i++)
	if (insn.tm->operand_types[i] & NotReq)
	  numops--;
      if (insn.operands != numops)
	{
	  as_bad (_("Incorrect number of operands given"));
	  return;
	}
    }
  insn.addressing_mode = AM_NotReq;
  for (count = 0; count < insn.operands; count++)
    {
      if (insn.operand_type[count]->op_type & insn.tm->operand_types[count])
	{
	  debug ("Operand %d matches\n", count + 1);
	  /* If instruction has two operands and has an AddressMode
	     modifier then set addressing mode type for instruction.  */
	  if (insn.tm->opcode_modifier == AddressMode)
	    {
	      int addr_insn = 0;
	      /* Store instruction uses the second
		 operand for the address mode.  */
	      if ((insn.tm->operand_types[1] & (Indirect | Direct))
		  == (Indirect | Direct))
		addr_insn = 1;

	      if (insn.operand_type[addr_insn]->op_type & (AllReg))
		insn.addressing_mode = AM_Register;
	      else if (insn.operand_type[addr_insn]->op_type & Direct)
		insn.addressing_mode = AM_Direct;
	      else if (insn.operand_type[addr_insn]->op_type & Indirect)
		insn.addressing_mode = AM_Indirect;
	      else
		insn.addressing_mode = AM_Immediate;
	    }
	}
      else
	{
	  as_bad (_("The %s operand doesn't match"), ordinal_names[count]);
	  return;
	}
    }

  /* Now set the addressing mode for 3 operand instructions.  */
  if ((insn.tm->operand_types[0] & op3T1)
      && (insn.tm->operand_types[1] & op3T2))
    {
      /* Set the addressing mode to the values used for 2 operand
	 instructions in the  G addressing field of the opcode.  */
      char *p;
      switch (insn.operand_type[0]->op_type)
	{
	case Rn:
	case ARn:
	case DPReg:
	case OtherReg:
	  if (insn.operand_type[1]->op_type & (AllReg))
	    insn.addressing_mode = AM_Register;
	  else if (insn.operand_type[1]->op_type & Indirect)
	    insn.addressing_mode = AM_Direct;
	  else
	    {
	      /* Shouldn't make it to this stage.  */
	      as_bad (_("Incompatible first and second operands in instruction"));
	      return;
	    }
	  break;
	case Indirect:
	  if (insn.operand_type[1]->op_type & (AllReg))
	    insn.addressing_mode = AM_Indirect;
	  else if (insn.operand_type[1]->op_type & Indirect)
	    insn.addressing_mode = AM_Immediate;
	  else
	    {
	      /* Shouldn't make it to this stage.  */
	      as_bad (_("Incompatible first and second operands in instruction"));
	      return;
	    }
	  break;
	}
      /* Now make up the opcode for the 3 operand instructions.  As in
	 parallel instructions, there will be no unresolved values, so they
	 can be fully formed and added to the frag table.  */
      insn.opcode = insn.tm->base_opcode;
      if (insn.operand_type[0]->op_type & Indirect)
	{
	  insn.opcode |= (insn.operand_type[0]->indirect.ARnum);
	  insn.opcode |= (insn.operand_type[0]->indirect.mod << 3);
	}
      else
	insn.opcode |= (insn.operand_type[0]->reg.opcode);

      if (insn.operand_type[1]->op_type & Indirect)
	{
	  insn.opcode |= (insn.operand_type[1]->indirect.ARnum << 8);
	  insn.opcode |= (insn.operand_type[1]->indirect.mod << 11);
	}
      else
	insn.opcode |= (insn.operand_type[1]->reg.opcode << 8);

      if (insn.operands == 3)
	insn.opcode |= (insn.operand_type[2]->reg.opcode << 16);

      insn.opcode |= insn.addressing_mode;
      p = frag_more (INSN_SIZE);
      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
    }
  else
    {
      /* Not a three operand instruction.  */
      char *p;
      int am_insn = -1;
      insn.opcode = insn.tm->base_opcode;
      /* Create frag for instruction - all instructions are 4 bytes long.  */
      p = frag_more (INSN_SIZE);
      if ((insn.operands > 0) && (insn.tm->opcode_modifier == AddressMode))
	{
	  insn.opcode |= insn.addressing_mode;
	  if (insn.addressing_mode == AM_Indirect)
	    {
	      /* Determine which operand gives the addressing mode.  */
	      if (insn.operand_type[0]->op_type & Indirect)
		am_insn = 0;
	      if ((insn.operands > 1)
		  && (insn.operand_type[1]->op_type & Indirect))
		am_insn = 1;
	      insn.opcode |= (insn.operand_type[am_insn]->indirect.disp);
	      insn.opcode |= (insn.operand_type[am_insn]->indirect.ARnum << 8);
	      insn.opcode |= (insn.operand_type[am_insn]->indirect.mod << 11);
	      if (insn.operands > 1)
		insn.opcode |= (insn.operand_type[!am_insn]->reg.opcode << 16);
	      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	    }
	  else if (insn.addressing_mode == AM_Register)
	    {
	      insn.opcode |= (insn.operand_type[0]->reg.opcode);
	      if (insn.operands > 1)
		insn.opcode |= (insn.operand_type[1]->reg.opcode << 16);
	      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	    }
	  else if (insn.addressing_mode == AM_Direct)
	    {
	      if (insn.operand_type[0]->op_type & Direct)
		am_insn = 0;
	      if ((insn.operands > 1)
		  && (insn.operand_type[1]->op_type & Direct))
		am_insn = 1;
	      if (insn.operands > 1)
		insn.opcode |=
		  (insn.operand_type[! am_insn]->reg.opcode << 16);
	      if (insn.operand_type[am_insn]->direct.resolved == 1)
		{
		  /* Resolved values can be placed straight
		     into instruction word, and output.  */
		  insn.opcode |=
		    (insn.operand_type[am_insn]->direct.address & 0x0000FFFF);
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{
		  /* Unresolved direct addressing mode instruction.  */
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix_new_exp (frag_now, p + 2 - (frag_now->fr_literal), 2,
			       & insn.operand_type[am_insn]->direct.direct_expr,
			       0, 0);
		}
	    }
	  else if (insn.addressing_mode == AM_Immediate)
	    {
	      if (insn.operand_type[0]->immediate.resolved == 1)
		{
		  char *keeploc;
		  int size;

		  if (insn.operands > 1)
		    insn.opcode |= (insn.operand_type[1]->reg.opcode << 16);

		  switch (insn.tm->imm_arg_type)
		    {
		    case Imm_Float:
		      debug ("Floating point first operand\n");
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);

		      keeploc = input_line_pointer;
		      input_line_pointer =
			insn.operand_type[0]->immediate.label;

		      if (md_atof ('f', p + 2, & size) != 0)
			{
			  as_bad (_("invalid short form floating point immediate operand"));
			  return;
			}

		      input_line_pointer = keeploc;
		      break;

		    case Imm_UInt:
		      debug ("Unsigned int first operand\n");
		      if (insn.operand_type[0]->immediate.decimal_found)
			as_warn (_("rounding down first operand float to unsigned int"));
		      if (insn.operand_type[0]->immediate.u_number > 0xFFFF)
			as_warn (_("only lower 16-bits of first operand are used"));
		      insn.opcode |=
			(insn.operand_type[0]->immediate.u_number & 0x0000FFFFL);
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		      break;

		    case Imm_SInt:
		      debug ("Int first operand\n");

		      if (insn.operand_type[0]->immediate.decimal_found)
			as_warn (_("rounding down first operand float to signed int"));

		      if (insn.operand_type[0]->immediate.s_number < -32768 ||
			  insn.operand_type[0]->immediate.s_number > 32767)
			{
			  as_bad (_("first operand is too large for 16-bit signed int"));
			  return;
			}
		      insn.opcode |=
			(insn.operand_type[0]->immediate.s_number & 0x0000FFFFL);
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		      break;
		    }
		}
	      else
		{
		  /* Unresolved immediate label.  */
		  if (insn.operands > 1)
		    insn.opcode |= (insn.operand_type[1]->reg.opcode << 16);
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix_new_exp (frag_now, p + 2 - (frag_now->fr_literal), 2,
			       & insn.operand_type[0]->immediate.imm_expr,
			       0, 0);
		}
	    }
	}
      else if (insn.tm->opcode_modifier == PCRel)
	{
	  /* Conditional Branch and Call instructions.  */
	  if ((insn.tm->operand_types[0] & (AllReg | Disp))
	      == (AllReg | Disp))
	    {
	      if (insn.operand_type[0]->op_type & (AllReg))
		{
		  insn.opcode |= (insn.operand_type[0]->reg.opcode);
		  insn.opcode |= PC_Register;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{
		  insn.opcode |= PC_Relative;
		  if (insn.operand_type[0]->immediate.resolved == 1)
		    {
		      insn.opcode |=
			(insn.operand_type[0]->immediate.s_number & 0x0000FFFF);
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		    }
		  else
		    {
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		      fix_new_exp (frag_now, p + 2 - (frag_now->fr_literal),
				   2, & insn.operand_type[0]->immediate.imm_expr,
				   1, 0);
		    }
		}
	    }
	  else if ((insn.tm->operand_types[0] & ARn) == ARn)
	    {
	      /* Decrement and Branch instructions.  */
	      insn.opcode |= ((insn.operand_type[0]->reg.opcode - 0x08) << 22);
	      if (insn.operand_type[1]->op_type & (AllReg))
		{
		  insn.opcode |= (insn.operand_type[1]->reg.opcode);
		  insn.opcode |= PC_Register;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else if (insn.operand_type[1]->immediate.resolved == 1)
		{
		  if (insn.operand_type[0]->immediate.decimal_found)
		    {
		      as_bad (_("first operand is floating point"));
		      return;
		    }
		  if (insn.operand_type[0]->immediate.s_number < -32768 ||
		      insn.operand_type[0]->immediate.s_number > 32767)
		    {
		      as_bad (_("first operand is too large for 16-bit signed int"));
		      return;
		    }
		  insn.opcode |= (insn.operand_type[1]->immediate.s_number);
		  insn.opcode |= PC_Relative;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{
		  insn.opcode |= PC_Relative;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix_new_exp (frag_now, p + 2 - frag_now->fr_literal, 2,
			       & insn.operand_type[1]->immediate.imm_expr,
			       1, 0);
		}
	    }
	}
      else if (insn.tm->operand_types[0] == IVector)
	{
	  /* Trap instructions.  */
	  if (insn.operand_type[0]->op_type & IVector)
	    insn.opcode |= (insn.operand_type[0]->immediate.u_number);
	  else
	    {
	      /* Shouldn't get here.  */
	      as_bad (_("interrupt vector for trap instruction out of range"));
	      return;
	    }
	  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	}
      else if (insn.tm->opcode_modifier == StackOp
	       || insn.tm->opcode_modifier == Rotate)
	{
	  /* Push, Pop and Rotate instructions.  */
	  insn.opcode |= (insn.operand_type[0]->reg.opcode << 16);
	  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	}
      else if ((insn.tm->operand_types[0] & (Abs24 | Direct))
	       == (Abs24 | Direct))
	{
	  /* LDP Instruction needs to be tested
	     for before the next section.  */
	  if (insn.operand_type[0]->op_type & Direct)
	    {
	      if (insn.operand_type[0]->direct.resolved == 1)
		{
		  /* Direct addressing uses lower 8 bits of direct address.  */
		  insn.opcode |=
		    (insn.operand_type[0]->direct.address & 0x00FF0000) >> 16;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{
		  fixS *fix;

		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix = fix_new_exp (frag_now, p + 3 - (frag_now->fr_literal),
				     1, &insn.operand_type[0]->direct.direct_expr, 0, 0);
		  /* Ensure that the assembler doesn't complain
		     about fitting a 24-bit address into 8 bits.  */
		  fix->fx_no_overflow = 1;
		}
	    }
	  else
	    {
	      if (insn.operand_type[0]->immediate.resolved == 1)
		{
		  /* Immediate addressing uses upper 8 bits of address.  */
		  if (insn.operand_type[0]->immediate.u_number > 0x00FFFFFF)
		    {
		      as_bad (_("LDP instruction needs a 24-bit operand"));
		      return;
		    }
		  insn.opcode |=
		    ((insn.operand_type[0]->immediate.u_number & 0x00FF0000) >> 16);
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{
		  fixS *fix;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix = fix_new_exp (frag_now, p + 3 - (frag_now->fr_literal),
				     1, &insn.operand_type[0]->immediate.imm_expr,
				     0, 0);
		  fix->fx_no_overflow = 1;
		}
	    }
	}
      else if (insn.tm->operand_types[0] & (Imm24))
	{
	  /* Unconditional Branch and Call instructions.  */
	  if (insn.operand_type[0]->immediate.resolved == 1)
	    {
	      if (insn.operand_type[0]->immediate.u_number > 0x00FFFFFF)
		as_warn (_("first operand is too large for a 24-bit displacement"));
	      insn.opcode |=
		(insn.operand_type[0]->immediate.u_number & 0x00FFFFFF);
	      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	    }
	  else
	    {
	      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	      fix_new_exp (frag_now, p + 1 - (frag_now->fr_literal), 3,
			   & insn.operand_type[0]->immediate.imm_expr, 0, 0);
	    }
	}
      else if (insn.tm->operand_types[0] & NotReq)
	/* Check for NOP instruction without arguments.  */
	md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);

      else if (insn.tm->operands == 0)
	/* Check for instructions without operands.  */
	md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
    }
  debug ("Addressing mode: %08X\n", insn.addressing_mode);
  {
    unsigned int i;

    for (i = 0; i < insn.operands; i++)
      {
	if (insn.operand_type[i]->immediate.label)
	  free (insn.operand_type[i]->immediate.label);
	free (insn.operand_type[i]);
      }
  }
  debug ("Final opcode: %08X\n", insn.opcode);
  debug ("\n");
}
@


1.29
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d37 1
a37 1
  "first", "second", "third", "fourth", "fifth"
@


1.28
log
@update copyright dates
@
text
@d330 1
a330 1
    char *opcode, *operands, *line;
d336 1
a336 1
	    opcode = &first_opcode[0];
d342 1
a342 1
	    opcode = &second_opcode[0];
d356 1
a356 1
		  opcode[char_ptr++] = TOLOWER (c);
d360 1
a360 1
		opcode[char_ptr++] = TOLOWER (c);
d363 1
a363 1
		  opcode[char_ptr] = '\0';
a622 2
	      unsigned count;

d1308 1
a1308 1
	  long exp, mant;
d1315 3
a1317 3
	      exp = (tmsfloat & 0xFF000000);
	      exp >>= 24;
	      mant = tmsfloat & 0x007FFFFF;
d1320 6
a1325 6
		  mant |= 0xFF000000;
		  mant += 0x00000800;
		  mant >>= 12;
		  mant |= 0x00000800;
		  mant &= 0x0FFF;
		  if (exp > 7)
d1330 6
a1335 6
		  mant |= 0x00800000;
		  mant += 0x00000800;
		  exp += (mant >> 24);
		  mant >>= 12;
		  mant &= 0x07FF;
		  if (exp > 7)
d1338 1
a1338 1
	      if (exp < -8)
d1342 2
a1343 2
		  mant = (exp << 12) | mant;
		  value = mant & 0xFFFF;
d1417 1
a1417 1
  insn_template *opcode;
d1465 2
a1466 2
    opcode = (insn_template *) hash_find (op_hash, token_start);
    if (opcode)
d1468 2
a1469 2
	debug ("Found instruction %s\n", opcode->name);
	insn.tm = opcode;
@


1.27
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2006, 2007
@


1.26
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d120 1
a120 1
    const template *current_optab = tic30_optab;
d260 1
a260 1
template *opcode;
d264 1
a264 1
  template *tm;			/* Template of current instruction.  */
d1419 1
a1419 1
  template *opcode;
d1467 1
a1467 1
    opcode = (template *) hash_find (op_hash, token_start);
@


1.25
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d483 1
a483 1
		  as_bad ("More than one AR register found in indirect reference");
d488 1
a488 1
		  as_bad ("Illegal AR register in indirect reference");
d508 1
a508 1
		      as_bad ("More than one displacement found in indirect reference");
d516 1
a516 1
			  as_bad ("Invalid displacement in indirect reference");
d533 1
a533 1
	  as_bad ("AR register not found in indirect reference");
d549 1
a549 1
	      as_bad ("required displacement wasn't given in indirect reference");
d555 1
a555 1
	  as_bad ("illegal indirect reference");
d561 1
a561 1
	  as_bad ("displacement must be an unsigned 8-bit number");
d749 1
a749 1
		as_bad ("Invalid character %s before %s operand",
d768 1
a768 1
		    as_bad ("Unbalanced parenthesis in %s operand.",
d784 1
a784 1
		as_bad ("Invalid character %s in %s operand",
d803 1
a803 1
		as_bad ("Spurious operands; (%d operands/instruction max)",
d821 1
a821 1
		as_bad ("Expecting operand after ','; got nothing");
d826 1
a826 1
		as_bad ("Expecting operand before ','; got nothing");
d837 1
a837 1
		as_bad ("Expecting operand after ','; got nothing");
d864 1
a864 1
      as_bad ("incorrect number of operands given in the first instruction");
d870 1
a870 1
      as_bad ("incorrect number of operands given in the second instruction");
d891 1
a891 1
		as_bad ("%s instruction, operand %d doesn't match",
d915 1
a915 1
	    as_bad ("incorrect format for multiply parallel instruction");
d922 1
a922 1
	    as_bad ("incorrect format for multiply parallel instruction");
d929 1
a929 1
	    as_bad ("destination for multiply can only be R0 or R1");
d936 1
a936 1
	    as_bad ("destination for add/subtract can only be R2 or R3");
d1003 1
a1003 1
	as_warn ("loading the same register in parallel operation");
d1384 2
a1385 2
      as_bad ("Can not do %d byte %srelocation", fixP->fx_size,
	      fixP->fx_pcrel ? "pc-relative " : "");
d1446 1
a1446 1
      as_bad ("Invalid character %s in opcode",
d1476 1
a1476 1
	as_bad ("Unknown TMS320C30 instruction: %s", token_start);
d1496 1
a1496 1
		  as_bad ("Invalid character %s before %s operand",
d1511 1
a1511 1
		      as_bad ("Unbalanced parenthesis in %s operand.",
d1521 1
a1521 1
		  as_bad ("Invalid character %s in %s operand",
d1538 1
a1538 1
		  as_bad ("Spurious operands; (%d operands/instruction max)",
d1555 1
a1555 1
		  as_bad ("Expecting operand after ','; got nothing");
d1560 1
a1560 1
		  as_bad ("Expecting operand before ','; got nothing");
d1571 1
a1571 1
		  as_bad ("Expecting operand after ','; got nothing");
d1596 1
a1596 1
	  as_bad ("Incorrect number of operands given");
d1629 1
a1629 1
	  as_bad ("The %s operand doesn't match", ordinal_names[count]);
d1654 1
a1654 1
	      as_bad ("Incompatible first and second operands in instruction");
d1666 1
a1666 1
	      as_bad ("Incompatible first and second operands in instruction");
d1780 1
a1780 1
			  as_bad ("invalid short form floating point immediate operand");
d1790 1
a1790 1
			as_warn ("rounding down first operand float to unsigned int");
d1792 1
a1792 1
			as_warn ("only lower 16-bits of first operand are used");
d1802 1
a1802 1
			as_warn ("rounding down first operand float to signed int");
d1807 1
a1807 1
			  as_bad ("first operand is too large for 16-bit signed int");
d1872 1
a1872 1
		      as_bad ("first operand is floating point");
d1878 1
a1878 1
		      as_bad ("first operand is too large for 16-bit signed int");
d1903 1
a1903 1
	      as_bad ("interrupt vector for trap instruction out of range");
d1948 1
a1948 1
		      as_bad ("LDP instruction needs a 24-bit operand");
d1972 1
a1972 1
		as_warn ("first operand is too large for a 24-bit displacement");
@


1.24
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1391 1
a1391 1
  assert (rel != 0);
a2005 1

@


1.23
log
@Switch to GPLv3
@
text
@d1261 1
a1261 1
      return "Bad call to MD_ATOF()";
d1352 1
a1352 1
  return 0;
@


1.22
log
@remove some duplicate #include's.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.21
log
@2006-05-02  H.J. Lu  <hongjiu.lu@@intel.com>
	    Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (output_invalid_buf): Change size for
	unsigned char.
	* config/tc-tic30.c (output_invalid_buf): Likewise.

	* config/tc-i386.c (output_invalid): Cast none-ascii char to
	unsigned char.
	* config/tc-tic30.c (output_invalid): Likewise.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003
a30 1
#include <stdarg.h>
@


1.20
log
@2006-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (output_invalid_buf): Change size to 16.
	* config/tc-tic30.c (output_invalid_buf): Likewise.

	* config/tc-i386.c (output_invalid): Use snprintf instead of
	sprintf.
	* config/tc-ia64.c (declare_register_set): Likewise.
	(emit_one_bundle): Likewise.
	(check_dependencies): Likewise.
	* config/tc-tic30.c (output_invalid): Likewise.
@
text
@d276 1
a276 1
static char output_invalid_buf[16];
d286 1
a286 1
	      "(0x%x)", (unsigned) c);
@


1.19
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d276 1
a276 1
static char output_invalid_buf[8];
d282 2
a283 1
    sprintf (output_invalid_buf, "'%c'", c);
d285 2
a286 1
    sprintf (output_invalid_buf, "(0x%x)", (unsigned) c);
@


1.18
log
@	* frags.h: Remove ANSI_PROTOTYPES conditional code.
	* config/obj-elf.h: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-h8500.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-xtensa.h: Likewise.
@
text
@a40 2
const int md_reloc_size = 0;

@


1.17
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@a30 1
#ifdef ANSI_PROTOTYPES
a31 3
#else
#include <varargs.h>
#endif
@


1.16
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d89 1
a89 1
static int
d442 3
a444 3
	  debug ("Expression addnum: %d\n",
		 current_op->direct.direct_expr.X_add_number);
	  debug ("Segment: %d\n", retval);
d612 3
a614 3
	      debug ("Expression addnum: %d\n",
		     current_op->immediate.imm_expr.X_add_number);
	      debug ("Segment: %d\n", retval);
d1143 1
a1143 1
  debug ("fx_where = %d\n", fixP->fx_where);
d1185 2
a1186 2
  debug ("In md_section_align() segment = %d and size = %d\n",
	 segment, size);
d1189 1
a1189 1
  debug ("New size value = %d\n", size);
d1199 1
a1199 1
  debug ("fx_where = %d\n", fixP->fx_where);
@


1.15
log
@Update the address and phone number of the FSF
@
text
@d1133 1
a1133 1
md_apply_fix3 (fixS *fixP,
@


1.14
log
@Convert to ISO C90 formatting
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.13
log
@update copyright dates
@
text
@d40 2
a41 1
static char *ordinal_names[] = {
d47 2
a48 2
const char comment_chars[] = ";";
const char line_comment_chars[] = "*";
d52 2
a53 1
struct option md_longopts[] = {
d59 3
a61 3
/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d68 1
a68 1
/* tables for lexical analysis */
d76 7
a82 7
/* lexical macros */
#define is_opcode_char(x) (opcode_chars[(unsigned char) x])
#define is_operand_char(x) (operand_chars[(unsigned char) x])
#define is_register_char(x) (register_chars[(unsigned char) x])
#define is_space_char(x) (space_chars[(unsigned char) x])
#define is_identifier_char(x) (identifier_chars[(unsigned char) x])
#define is_digit_char(x) (digit_chars[(unsigned char) x])
d84 2
a85 1
const pseudo_typeS md_pseudo_table[] = {
d89 2
a90 4
int debug PARAMS ((const char *string, ...));

int
debug VPARAMS ((const char *string, ...))
d109 1
a109 1
/* hash table for opcode lookup */
d111 1
a111 1
/* hash table for parallel opcode lookup */
d113 1
a113 1
/* hash table for register lookup */
d115 1
a115 1
/* hash table for indirect addressing lookup */
d119 1
a119 1
md_begin ()
d122 1
d125 1
d128 1
d131 2
a132 1
	hash_err = hash_insert (op_hash, current_optab->name, (char *) current_optab);
d134 2
a135 1
	  as_fatal ("Internal Error: Can't Hash %s: %s", current_optab->name, hash_err);
d138 1
d140 1
d143 1
d146 2
a147 1
	hash_err = hash_insert (parop_hash, current_parop->name, (char *) current_parop);
d149 2
a150 1
	  as_fatal ("Internal Error: Can't Hash %s: %s", current_parop->name, hash_err);
d153 1
d155 1
d158 1
d161 2
a162 1
	hash_err = hash_insert (reg_hash, current_reg->name, (char *) current_reg);
d164 2
a165 1
	  as_fatal ("Internal Error: Can't Hash %s: %s", current_reg->name, hash_err);
d168 1
d170 1
d173 1
d176 2
a177 1
	hash_err = hash_insert (ind_hash, current_ind->syntax, (char *) current_ind);
d179 2
a180 1
	  as_fatal ("Internal Error: Can't Hash %s: %s", current_ind->syntax, hash_err);
d183 2
a184 1
  /* fill in lexical tables:  opcode_chars, operand_chars, space_chars */
d186 2
a187 2
    register int c;
    register char *p;
d202 2
a203 3
	  {
	    register_chars[c] = c;
	  }
d206 1
d209 1
d212 1
d215 1
d224 1
a224 1
/* Address Mode OR values */
d231 1
a231 1
/* PC Relative OR values */
d235 2
a236 1
typedef struct {
d238 2
a239 1
  struct {
d245 2
a246 1
  struct {
d251 2
a252 1
  struct {
d255 2
a256 1
  struct {
a266 4
int tic30_parallel_insn PARAMS ((char *));
operand *tic30_operand PARAMS ((char *));
char *tic30_find_parallel_insn PARAMS ((char *, char *));

d269 6
a274 5
struct tic30_insn {
  template *tm;			/* Template of current instruction */
  unsigned opcode;		/* Final opcode */
  unsigned int operands;	/* Number of given operands */
  /* Type of operand given in instruction */
d276 1
a276 1
  unsigned addressing_mode;	/* Final addressing mode of instruction */
d282 27
a308 3
void
md_assemble (line)
     char *line;
d310 6
a315 5
  template *opcode;
  char *current_posn;
  char *token_start;
  char save_char;
  unsigned int count;
d317 2
a318 23
  debug ("In md_assemble() with argument %s\n", line);
  memset (&insn, '\0', sizeof (insn));
  if (found_parallel_insn)
    {
      debug ("Line is second part of parallel instruction\n\n");
      found_parallel_insn = 0;
      return;
    }
  if ((current_posn = tic30_find_parallel_insn (line, input_line_pointer + 1)) == NULL)
    current_posn = line;
  else
    found_parallel_insn = 1;
  while (is_space_char (*current_posn))
    current_posn++;
  token_start = current_posn;
  if (!is_opcode_char (*current_posn))
    {
      as_bad ("Invalid character %s in opcode", output_invalid (*current_posn));
      return;
    }
  /* Check if instruction is a parallel instruction by seeing if the first
     character is a q.  */
  if (*token_start == 'q')
d320 2
a321 1
      if (tic30_parallel_insn (token_start))
d323 3
a325 3
	  if (found_parallel_insn)
	    free (token_start);
	  return;
d327 1
d329 9
a337 7
  while (is_opcode_char (*current_posn))
    current_posn++;
  {				/* Find instruction */
    save_char = *current_posn;
    *current_posn = '\0';
    opcode = (template *) hash_find (op_hash, token_start);
    if (opcode)
d339 13
a351 17
	debug ("Found instruction %s\n", opcode->name);
	insn.tm = opcode;
      }
    else
      {
	debug ("Didn't find insn\n");
	as_bad ("Unknown TMS320C30 instruction: %s", token_start);
	return;
      }
    *current_posn = save_char;
  }
  if (*current_posn != END_OF_INSN)
    {				/* Find operands */
      int paren_not_balanced;
      int expecting_operand = 0;
      int this_operand;
      do
d353 5
a357 2
	  /* skip optional white space before operand */
	  while (!is_operand_char (*current_posn) && *current_posn != END_OF_INSN)
d359 1
a359 1
	      if (!is_space_char (*current_posn))
d361 2
a362 4
		  as_bad ("Invalid character %s before %s operand",
			  output_invalid (*current_posn),
			  ordinal_names[insn.operands]);
		  return;
d364 3
a366 7
	      current_posn++;
	    }
	  token_start = current_posn;	/* after white space */
	  paren_not_balanced = 0;
	  while (paren_not_balanced || *current_posn != ',')
	    {
	      if (*current_posn == END_OF_INSN)
d368 3
a370 8
		  if (paren_not_balanced)
		    {
		      as_bad ("Unbalanced parenthesis in %s operand.",
			      ordinal_names[insn.operands]);
		      return;
		    }
		  else
		    break;	/* we are done */
d372 4
a375 1
	      else if (!is_operand_char (*current_posn) && !is_space_char (*current_posn))
d377 2
a378 4
		  as_bad ("Invalid character %s in %s operand",
			  output_invalid (*current_posn),
			  ordinal_names[insn.operands]);
		  return;
d380 2
a381 45
	      if (*current_posn == '(')
		++paren_not_balanced;
	      if (*current_posn == ')')
		--paren_not_balanced;
	      current_posn++;
	    }
	  if (current_posn != token_start)
	    {			/* yes, we've read in another operand */
	      this_operand = insn.operands++;
	      if (insn.operands > MAX_OPERANDS)
		{
		  as_bad ("Spurious operands; (%d operands/instruction max)",
			  MAX_OPERANDS);
		  return;
		}
	      /* now parse operand adding info to 'insn' as we go along */
	      save_char = *current_posn;
	      *current_posn = '\0';
	      insn.operand_type[this_operand] = tic30_operand (token_start);
	      *current_posn = save_char;
	      if (insn.operand_type[this_operand] == NULL)
		return;
	    }
	  else
	    {
	      if (expecting_operand)
		{
		  as_bad ("Expecting operand after ','; got nothing");
		  return;
		}
	      if (*current_posn == ',')
		{
		  as_bad ("Expecting operand before ','; got nothing");
		  return;
		}
	    }
	  /* now *current_posn must be either ',' or END_OF_INSN */
	  if (*current_posn == ',')
	    {
	      if (*++current_posn == END_OF_INSN)
		{		/* just skip it, if it's \n complain */
		  as_bad ("Expecting operand after ','; got nothing");
		  return;
		}
	      expecting_operand = 1;
d383 3
d387 29
a415 5
      while (*current_posn != END_OF_INSN);	/* until we get end of insn */
    }
  debug ("Number of operands found: %d\n", insn.operands);
  /* Check that number of operands is correct */
  if (insn.operands != insn.tm->operands)
d417 5
a421 9
      unsigned int i;
      unsigned int numops = insn.tm->operands;
      /* If operands are not the same, then see if any of the operands are not
         required.  Then recheck with number of given operands.  If they are still not
         the same, then give an error, otherwise carry on.  */
      for (i = 0; i < insn.tm->operands; i++)
	if (insn.tm->operand_types[i] & NotReq)
	  numops--;
      if (insn.operands != numops)
d423 3
a425 2
	  as_bad ("Incorrect number of operands given");
	  return;
d427 2
a428 5
    }
  insn.addressing_mode = AM_NotReq;
  for (count = 0; count < insn.operands; count++)
    {
      if (insn.operand_type[count]->op_type & insn.tm->operand_types[count])
d430 19
a448 4
	  debug ("Operand %d matches\n", count + 1);
	  /* If instruction has two operands and has an AddressMode modifier then set
	     addressing mode type for instruction */
	  if (insn.tm->opcode_modifier == AddressMode)
d450 3
a452 12
	      int addr_insn = 0;
	      /* Store instruction uses the second operand for the address mode.  */
	      if ((insn.tm->operand_types[1] & (Indirect | Direct)) == (Indirect | Direct))
		addr_insn = 1;
	      if (insn.operand_type[addr_insn]->op_type & (AllReg))
		insn.addressing_mode = AM_Register;
	      else if (insn.operand_type[addr_insn]->op_type & Direct)
		insn.addressing_mode = AM_Direct;
	      else if (insn.operand_type[addr_insn]->op_type & Indirect)
		insn.addressing_mode = AM_Indirect;
	      else
		insn.addressing_mode = AM_Immediate;
d457 3
a459 2
	  as_bad ("The %s operand doesn't match", ordinal_names[count]);
	  return;
d461 1
d463 1
a463 2
  /* Now set the addressing mode for 3 operand instructions.  */
  if ((insn.tm->operand_types[0] & op3T1) && (insn.tm->operand_types[1] & op3T2))
d465 12
a476 4
      /* Set the addressing mode to the values used for 2 operand instructions in the
         G addressing field of the opcode.  */
      char *p;
      switch (insn.operand_type[0]->op_type)
d478 5
a482 9
	case Rn:
	case ARn:
	case DPReg:
	case OtherReg:
	  if (insn.operand_type[1]->op_type & (AllReg))
	    insn.addressing_mode = AM_Register;
	  else if (insn.operand_type[1]->op_type & Indirect)
	    insn.addressing_mode = AM_Direct;
	  else
d484 15
a498 3
	      /* Shouldn't make it to this stage */
	      as_bad ("Incompatible first and second operands in instruction");
	      return;
d500 2
a501 7
	  break;
	case Indirect:
	  if (insn.operand_type[1]->op_type & (AllReg))
	    insn.addressing_mode = AM_Indirect;
	  else if (insn.operand_type[1]->op_type & Indirect)
	    insn.addressing_mode = AM_Immediate;
	  else
d503 28
a530 3
	      /* Shouldn't make it to this stage */
	      as_bad ("Incompatible first and second operands in instruction");
	      return;
d532 8
a539 1
	  break;
d541 3
a543 5
      /* Now make up the opcode for the 3 operand instructions.  As in parallel
         instructions, there will be no unresolved values, so they can be fully formed
         and added to the frag table.  */
      insn.opcode = insn.tm->base_opcode;
      if (insn.operand_type[0]->op_type & Indirect)
d545 12
a556 2
	  insn.opcode |= (insn.operand_type[0]->indirect.ARnum);
	  insn.opcode |= (insn.operand_type[0]->indirect.mod << 3);
a558 2
	insn.opcode |= (insn.operand_type[0]->reg.opcode);
      if (insn.operand_type[1]->op_type & Indirect)
d560 8
a567 2
	  insn.opcode |= (insn.operand_type[1]->indirect.ARnum << 8);
	  insn.opcode |= (insn.operand_type[1]->indirect.mod << 11);
d569 5
a573 7
      else
	insn.opcode |= (insn.operand_type[1]->reg.opcode << 8);
      if (insn.operands == 3)
	insn.opcode |= (insn.operand_type[2]->reg.opcode << 16);
      insn.opcode |= insn.addressing_mode;
      p = frag_more (INSN_SIZE);
      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
d576 17
a592 7
    {				/* Not a three operand instruction */
      char *p;
      int am_insn = -1;
      insn.opcode = insn.tm->base_opcode;
      /* Create frag for instruction - all instructions are 4 bytes long.  */
      p = frag_more (INSN_SIZE);
      if ((insn.operands > 0) && (insn.tm->opcode_modifier == AddressMode))
d594 3
a596 2
	  insn.opcode |= insn.addressing_mode;
	  if (insn.addressing_mode == AM_Indirect)
d598 20
a617 28
	      /* Determine which operand gives the addressing mode */
	      if (insn.operand_type[0]->op_type & Indirect)
		am_insn = 0;
	      if ((insn.operands > 1) && (insn.operand_type[1]->op_type & Indirect))
		am_insn = 1;
	      insn.opcode |= (insn.operand_type[am_insn]->indirect.disp);
	      insn.opcode |= (insn.operand_type[am_insn]->indirect.ARnum << 8);
	      insn.opcode |= (insn.operand_type[am_insn]->indirect.mod << 11);
	      if (insn.operands > 1)
		insn.opcode |= (insn.operand_type[!am_insn]->reg.opcode << 16);
	      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	    }
	  else if (insn.addressing_mode == AM_Register)
	    {
	      insn.opcode |= (insn.operand_type[0]->reg.opcode);
	      if (insn.operands > 1)
		insn.opcode |= (insn.operand_type[1]->reg.opcode << 16);
	      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	    }
	  else if (insn.addressing_mode == AM_Direct)
	    {
	      if (insn.operand_type[0]->op_type & Direct)
		am_insn = 0;
	      if ((insn.operands > 1) && (insn.operand_type[1]->op_type & Direct))
		am_insn = 1;
	      if (insn.operands > 1)
		insn.opcode |= (insn.operand_type[!am_insn]->reg.opcode << 16);
	      if (insn.operand_type[am_insn]->direct.resolved == 1)
d619 5
a623 8
		  /* Resolved values can be placed straight into instruction word, and output */
		  insn.opcode |= (insn.operand_type[am_insn]->direct.address & 0x0000FFFF);
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{		/* Unresolved direct addressing mode instruction */
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix_new_exp (frag_now, p + 2 - (frag_now->fr_literal), 2, &insn.operand_type[am_insn]->direct.direct_expr, 0, 0);
d626 1
a626 1
	  else if (insn.addressing_mode == AM_Immediate)
d628 13
a640 51
	      if (insn.operand_type[0]->immediate.resolved == 1)
		{
		  char *keeploc;
		  int size;
		  if (insn.operands > 1)
		    insn.opcode |= (insn.operand_type[1]->reg.opcode << 16);
		  switch (insn.tm->imm_arg_type)
		    {
		    case Imm_Float:
		      debug ("Floating point first operand\n");
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		      keeploc = input_line_pointer;
		      input_line_pointer = insn.operand_type[0]->immediate.label;
		      if (md_atof ('f', p + 2, &size) != 0)
			{
			  as_bad ("invalid short form floating point immediate operand");
			  return;
			}
		      input_line_pointer = keeploc;
		      break;
		    case Imm_UInt:
		      debug ("Unsigned int first operand\n");
		      if (insn.operand_type[0]->immediate.decimal_found)
			as_warn ("rounding down first operand float to unsigned int");
		      if (insn.operand_type[0]->immediate.u_number > 0xFFFF)
			as_warn ("only lower 16-bits of first operand are used");
		      insn.opcode |= (insn.operand_type[0]->immediate.u_number & 0x0000FFFFL);
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		      break;
		    case Imm_SInt:
		      debug ("Int first operand\n");
		      if (insn.operand_type[0]->immediate.decimal_found)
			as_warn ("rounding down first operand float to signed int");
		      if (insn.operand_type[0]->immediate.s_number < -32768 ||
			  insn.operand_type[0]->immediate.s_number > 32767)
			{
			  as_bad ("first operand is too large for 16-bit signed int");
			  return;
			}
		      insn.opcode |= (insn.operand_type[0]->immediate.s_number & 0x0000FFFFL);
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		      break;
		    }
		}
	      else
		{		/* Unresolved immediate label */
		  if (insn.operands > 1)
		    insn.opcode |= (insn.operand_type[1]->reg.opcode << 16);
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix_new_exp (frag_now, p + 2 - (frag_now->fr_literal), 2, &insn.operand_type[0]->immediate.imm_expr, 0, 0);
		}
d642 3
a644 148
	}
      else if (insn.tm->opcode_modifier == PCRel)
	{
	  /* Conditional Branch and Call instructions */
	  if ((insn.tm->operand_types[0] & (AllReg | Disp)) == (AllReg | Disp))
	    {
	      if (insn.operand_type[0]->op_type & (AllReg))
		{
		  insn.opcode |= (insn.operand_type[0]->reg.opcode);
		  insn.opcode |= PC_Register;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{
		  insn.opcode |= PC_Relative;
		  if (insn.operand_type[0]->immediate.resolved == 1)
		    {
		      insn.opcode |= (insn.operand_type[0]->immediate.s_number & 0x0000FFFF);
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		    }
		  else
		    {
		      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		      fix_new_exp (frag_now, p + 2 - (frag_now->fr_literal), 2, &insn.operand_type[0]->immediate.imm_expr, 1, 0);
		    }
		}
	    }
	  else if ((insn.tm->operand_types[0] & ARn) == ARn)
	    {
	      /* Decrement and Branch instructions */
	      insn.opcode |= ((insn.operand_type[0]->reg.opcode - 0x08) << 22);
	      if (insn.operand_type[1]->op_type & (AllReg))
		{
		  insn.opcode |= (insn.operand_type[1]->reg.opcode);
		  insn.opcode |= PC_Register;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else if (insn.operand_type[1]->immediate.resolved == 1)
		{
		  if (insn.operand_type[0]->immediate.decimal_found)
		    {
		      as_bad ("first operand is floating point");
		      return;
		    }
		  if (insn.operand_type[0]->immediate.s_number < -32768 ||
		      insn.operand_type[0]->immediate.s_number > 32767)
		    {
		      as_bad ("first operand is too large for 16-bit signed int");
		      return;
		    }
		  insn.opcode |= (insn.operand_type[1]->immediate.s_number);
		  insn.opcode |= PC_Relative;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{
		  insn.opcode |= PC_Relative;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix_new_exp (frag_now, p + 2 - frag_now->fr_literal, 2, &insn.operand_type[1]->immediate.imm_expr, 1, 0);
		}
	    }
	}
      else if (insn.tm->operand_types[0] == IVector)
	{
	  /* Trap instructions */
	  if (insn.operand_type[0]->op_type & IVector)
	    insn.opcode |= (insn.operand_type[0]->immediate.u_number);
	  else
	    {			/* Shouldn't get here */
	      as_bad ("interrupt vector for trap instruction out of range");
	      return;
	    }
	  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	}
      else if (insn.tm->opcode_modifier == StackOp || insn.tm->opcode_modifier == Rotate)
	{
	  /* Push, Pop and Rotate instructions */
	  insn.opcode |= (insn.operand_type[0]->reg.opcode << 16);
	  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	}
      else if ((insn.tm->operand_types[0] & (Abs24 | Direct)) == (Abs24 | Direct))
	{
	  /* LDP Instruction needs to be tested for before the next section */
	  if (insn.operand_type[0]->op_type & Direct)
	    {
	      if (insn.operand_type[0]->direct.resolved == 1)
		{
		  /* Direct addressing uses lower 8 bits of direct address */
		  insn.opcode |= (insn.operand_type[0]->direct.address & 0x00FF0000) >> 16;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{
		  fixS *fix;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix = fix_new_exp (frag_now, p + 3 - (frag_now->fr_literal), 1, &insn.operand_type[0]->direct.direct_expr, 0, 0);
		  /* Ensure that the assembler doesn't complain about fitting a 24-bit
		     address into 8 bits.  */
		  fix->fx_no_overflow = 1;
		}
	    }
	  else
	    {
	      if (insn.operand_type[0]->immediate.resolved == 1)
		{
		  /* Immediate addressing uses upper 8 bits of address */
		  if (insn.operand_type[0]->immediate.u_number > 0x00FFFFFF)
		    {
		      as_bad ("LDP instruction needs a 24-bit operand");
		      return;
		    }
		  insn.opcode |= ((insn.operand_type[0]->immediate.u_number & 0x00FF0000) >> 16);
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		}
	      else
		{
		  fixS *fix;
		  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
		  fix = fix_new_exp (frag_now, p + 3 - (frag_now->fr_literal), 1, &insn.operand_type[0]->immediate.imm_expr, 0, 0);
		  fix->fx_no_overflow = 1;
		}
	    }
	}
      else if (insn.tm->operand_types[0] & (Imm24))
	{
	  /* Unconditional Branch and Call instructions */
	  if (insn.operand_type[0]->immediate.resolved == 1)
	    {
	      if (insn.operand_type[0]->immediate.u_number > 0x00FFFFFF)
		as_warn ("first operand is too large for a 24-bit displacement");
	      insn.opcode |= (insn.operand_type[0]->immediate.u_number & 0x00FFFFFF);
	      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	    }
	  else
	    {
	      md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	      fix_new_exp (frag_now, p + 1 - (frag_now->fr_literal), 3, &insn.operand_type[0]->immediate.imm_expr, 0, 0);
	    }
	}
      else if (insn.tm->operand_types[0] & NotReq)
	{
	  /* Check for NOP instruction without arguments.  */
	  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
	}
      else if (insn.tm->operands == 0)
	{
	  /* Check for instructions without operands.  */
	  md_number_to_chars (p, (valueT) insn.opcode, INSN_SIZE);
d647 1
a647 12
  debug ("Addressing mode: %08X\n", insn.addressing_mode);
  {
    unsigned int i;
    for (i = 0; i < insn.operands; i++)
      {
	if (insn.operand_type[i]->immediate.label)
	  free (insn.operand_type[i]->immediate.label);
	free (insn.operand_type[i]);
      }
  }
  debug ("Final opcode: %08X\n", insn.opcode);
  debug ("\n");
d650 5
a654 4
struct tic30_par_insn {
  partemplate *tm;		/* Template of current parallel instruction */
  unsigned operands[2];		/* Number of given operands for each insn */
  /* Type of operand given in instruction */
d657 2
a658 2
  unsigned p_field;		/* Value of p field in multiply add/sub instructions */
  unsigned opcode;		/* Final opcode */
d663 1
a663 1
int
d673 1
d676 2
a677 1
  {				/* Find instruction */
d688 2
a689 4
	char first_opcode[6] =
	{0};
	char second_opcode[6] =
	{0};
d697 1
d703 1
d710 1
d721 1
d726 1
d738 3
a740 1
  {				/* Find operands */
d744 1
d747 3
a749 2
	/* skip optional white space before operand */
	while (!is_operand_char (*current_posn) && *current_posn != END_OF_INSN)
d751 2
a752 1
	    if (!is_space_char (*current_posn) && *current_posn != PARALLEL_SEPARATOR)
d763 2
a764 1
	token_start = current_posn;	/* after white space */
d766 1
d778 1
a778 1
		  break;	/* we are done */
d786 2
a787 1
	    else if (!is_operand_char (*current_posn) && !is_space_char (*current_posn))
d794 1
d801 1
d803 2
a804 1
	  {			/* yes, we've read in another operand */
d812 2
a813 1
	    /* now parse operand adding info to 'insn' as we go along */
d835 2
a836 1
	/* now *current_posn must be either ',' or END_OF_INSN */
d840 2
a841 1
	      {			/* just skip it, if it's \n complain */
d848 1
a848 1
    while (*current_posn != END_OF_INSN);	/* until we get end of insn */
d850 1
d866 1
d872 1
d878 1
d881 3
a883 1
  {				/* Now check if operands are correct */
d887 1
d896 2
a897 1
		as_bad ("%s instruction, operand %d doesn't match", ordinal_names[count], i + 1);
d900 6
a905 4
	    /* Get number of R register and indirect reference contained within the first
	       two operands of each instruction.  This is required for the multiply
	       parallel instructions which require two R registers and two indirect
	       references, but not in any particular place.  */
d908 2
a909 1
	    else if ((p_insn.operand_type[count][i]->op_type & Indirect) && i < 2)
d913 3
a915 1
    if ((p_insn.tm->operand_types[0][0] & (Indirect | Rn)) == (Indirect | Rn))
d917 1
a917 1
	/* Check for the multiply instructions */
d923 1
d925 2
a926 1
	  {			/* Shouldn't get here */
d930 3
a932 2
	if ((p_insn.operand_type[0][2]->reg.opcode != 0x00) &&
	    (p_insn.operand_type[0][2]->reg.opcode != 0x01))
d937 3
a939 2
	if ((p_insn.operand_type[1][2]->reg.opcode != 0x02) &&
	    (p_insn.operand_type[1][2]->reg.opcode != 0x03))
d944 2
a945 1
	/* Now determine the P field for the instruction */
d949 1
a949 1
	      p_insn.p_field = 0x00000000;	/* Ind * Ind, Rn  +/- Rn  */
d951 1
a951 1
	      p_insn.p_field = 0x01000000;	/* Ind * Rn,  Ind +/- Rn  */
d953 1
a953 1
	      p_insn.p_field = 0x03000000;	/* Ind * Rn,  Rn  +/- Ind */
d958 1
a958 1
	      p_insn.p_field = 0x02000000;	/* Rn  * Rn,  Ind +/- Ind */
d962 4
a965 3
		p_insn.p_field = 0x01000000;	/* Rn  * Ind, Ind +/- Rn  */
		/* Need to swap the two multiply operands around so that everything is in
		   its place for the opcode makeup ie so Ind * Rn, Ind +/- Rn */
d973 1
a973 1
		p_insn.p_field = 0x03000000;	/* Rn  * Ind, Rn  +/- Ind */
d981 1
d983 102
a1084 3
  /* Finalise opcode.  This is easier for parallel instructions as they have to be
     fully resolved, there are no memory addresses allowed, except through indirect
     addressing, so there are no labels to resolve.  */
a1085 92
    p_insn.opcode = p_insn.tm->base_opcode;
    switch (p_insn.tm->oporder)
      {
      case OO_4op1:
	p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum);
	p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 3);
	p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum << 8);
	p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 11);
	p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
	p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 22);
	break;
      case OO_4op2:
	p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum);
	p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 3);
	p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.ARnum << 8);
	p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.mod << 11);
	p_insn.opcode |= (p_insn.operand_type[1][1]->reg.opcode << 19);
	p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 22);
	if (p_insn.operand_type[1][1]->reg.opcode == p_insn.operand_type[0][1]->reg.opcode)
	  as_warn ("loading the same register in parallel operation");
	break;
      case OO_4op3:
	p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.ARnum);
	p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.mod << 3);
	p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum << 8);
	p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 11);
	p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
	p_insn.opcode |= (p_insn.operand_type[0][0]->reg.opcode << 22);
	break;
      case OO_5op1:
	p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum);
	p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 3);
	p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum << 8);
	p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 11);
	p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
	p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 19);
	p_insn.opcode |= (p_insn.operand_type[0][2]->reg.opcode << 22);
	break;
      case OO_5op2:
	p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.ARnum);
	p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.mod << 3);
	p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum << 8);
	p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 11);
	p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
	p_insn.opcode |= (p_insn.operand_type[0][0]->reg.opcode << 19);
	p_insn.opcode |= (p_insn.operand_type[0][2]->reg.opcode << 22);
	break;
      case OO_PField:
	p_insn.opcode |= p_insn.p_field;
	if (p_insn.operand_type[0][2]->reg.opcode == 0x01)
	  p_insn.opcode |= 0x00800000;
	if (p_insn.operand_type[1][2]->reg.opcode == 0x03)
	  p_insn.opcode |= 0x00400000;
	switch (p_insn.p_field)
	  {
	  case 0x00000000:
	    p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.ARnum);
	    p_insn.opcode |= (p_insn.operand_type[0][1]->indirect.mod << 3);
	    p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum << 8);
	    p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 11);
	    p_insn.opcode |= (p_insn.operand_type[1][1]->reg.opcode << 16);
	    p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 19);
	    break;
	  case 0x01000000:
	    p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.ARnum);
	    p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.mod << 3);
	    p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum << 8);
	    p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 11);
	    p_insn.opcode |= (p_insn.operand_type[1][1]->reg.opcode << 16);
	    p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 19);
	    break;
	  case 0x02000000:
	    p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum);
	    p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 3);
	    p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.ARnum << 8);
	    p_insn.opcode |= (p_insn.operand_type[1][0]->indirect.mod << 11);
	    p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 16);
	    p_insn.opcode |= (p_insn.operand_type[0][0]->reg.opcode << 19);
	    break;
	  case 0x03000000:
	    p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.ARnum);
	    p_insn.opcode |= (p_insn.operand_type[1][1]->indirect.mod << 3);
	    p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.ARnum << 8);
	    p_insn.opcode |= (p_insn.operand_type[0][0]->indirect.mod << 11);
	    p_insn.opcode |= (p_insn.operand_type[1][0]->reg.opcode << 16);
	    p_insn.opcode |= (p_insn.operand_type[0][1]->reg.opcode << 19);
	    break;
	  }
	break;
      }
  }				/* Opcode is finalised at this point for all parallel instructions.  */
  {				/* Output opcode */
d1087 1
d1091 1
d1094 1
d1099 1
d1102 1
d1106 5
a1110 3
operand *
tic30_operand (token)
     char *token;
d1112 316
a1428 2
  char ind_buffer[strlen (token)];
  operand *current_op;
d1430 28
a1457 4
  debug ("In tic30_operand with %s\n", token);
  current_op = (operand *) malloc (sizeof (operand));
  memset (current_op, '\0', sizeof (operand));
  if (*token == DIRECT_REFERENCE)
d1459 1
a1459 4
      char *token_posn = token + 1;
      int direct_label = 0;
      debug ("Found direct reference\n");
      while (*token_posn)
d1461 3
a1463 3
	  if (!is_digit_char (*token_posn))
	    direct_label = 1;
	  token_posn++;
d1465 29
a1493 1
      if (direct_label)
d1495 43
a1537 13
	  char *save_input_line_pointer;
	  segT retval;
	  debug ("Direct reference is a label\n");
	  current_op->direct.label = token + 1;
	  save_input_line_pointer = input_line_pointer;
	  input_line_pointer = token + 1;
	  debug ("Current input_line_pointer: %s\n", input_line_pointer);
	  retval = expression (&current_op->direct.direct_expr);
	  debug ("Expression type: %d\n", current_op->direct.direct_expr.X_op);
	  debug ("Expression addnum: %d\n", current_op->direct.direct_expr.X_add_number);
	  debug ("Segment: %d\n", retval);
	  input_line_pointer = save_input_line_pointer;
	  if (current_op->direct.direct_expr.X_op == O_constant)
d1539 16
a1554 2
	      current_op->direct.address = current_op->direct.direct_expr.X_add_number;
	      current_op->direct.resolved = 1;
d1556 1
a1556 24
	}
      else
	{
	  debug ("Direct reference is a number\n");
	  current_op->direct.address = atoi (token + 1);
	  current_op->direct.resolved = 1;
	}
      current_op->op_type = Direct;
    }
  else if (*token == INDIRECT_REFERENCE)
    {				/* Indirect reference operand */
      int found_ar = 0;
      int found_disp = 0;
      int ar_number = -1;
      int disp_number = 0;
      int buffer_posn = 1;
      ind_addr_type *ind_addr_op;
      debug ("Found indirect reference\n");
      ind_buffer[0] = *token;
      for (count = 1; count < strlen (token); count++)
	{			/* Strip operand */
	  ind_buffer[buffer_posn] = TOLOWER (*(token + count));
	  if ((*(token + count - 1) == 'a' || *(token + count - 1) == 'A') &&
	      (*(token + count) == 'r' || *(token + count) == 'R'))
d1558 1
a1558 3
	      /* AR reference is found, so get its number and remove it from the buffer
	         so it can pass through hash_find() */
	      if (found_ar)
d1560 2
a1561 2
		  as_bad ("More than one AR register found in indirect reference");
		  return NULL;
d1563 1
a1563 1
	      if (*(token + count + 1) < '0' || *(token + count + 1) > '7')
d1565 2
a1566 2
		  as_bad ("Illegal AR register in indirect reference");
		  return NULL;
a1567 3
	      ar_number = *(token + count + 1) - '0';
	      found_ar = 1;
	      count++;
d1569 3
a1571 1
	  if (*(token + count) == '(')
d1573 1
a1573 3
	      /* Parenthesis found, so check if a displacement value is inside.  If so, get
	         the value and remove it from the buffer.  */
	      if (is_digit_char (*(token + count + 1)))
d1575 3
a1577 22
		  char disp[10];
		  int disp_posn = 0;

		  if (found_disp)
		    {
		      as_bad ("More than one displacement found in indirect reference");
		      return NULL;
		    }
		  count++;
		  while (*(token + count) != ')')
		    {
		      if (!is_digit_char (*(token + count)))
			{
			  as_bad ("Invalid displacement in indirect reference");
			  return NULL;
			}
		      disp[disp_posn++] = *(token + (count++));
		    }
		  disp[disp_posn] = '\0';
		  disp_number = atoi (disp);
		  count--;
		  found_disp = 1;
d1579 1
a1580 1
	  buffer_posn++;
d1582 18
a1599 2
      ind_buffer[buffer_posn] = '\0';
      if (!found_ar)
d1601 2
a1602 2
	  as_bad ("AR register not found in indirect reference");
	  return NULL;
d1604 5
a1608 2
      ind_addr_op = (ind_addr_type *) hash_find (ind_hash, ind_buffer);
      if (ind_addr_op)
d1610 4
a1613 2
	  debug ("Found indirect reference: %s\n", ind_addr_op->syntax);
	  if (ind_addr_op->displacement == IMPLIED_DISP)
d1615 15
a1629 8
	      found_disp = 1;
	      disp_number = 1;
	    }
	  else if ((ind_addr_op->displacement == DISP_REQUIRED) && !found_disp)
	    {
	      /* Maybe an implied displacement of 1 again */
	      as_bad ("required displacement wasn't given in indirect reference");
	      return 0;
d1634 2
a1635 7
	  as_bad ("illegal indirect reference");
	  return NULL;
	}
      if (found_disp && (disp_number < 0 || disp_number > 255))
	{
	  as_bad ("displacement must be an unsigned 8-bit number");
	  return NULL;
a1636 4
      current_op->indirect.mod = ind_addr_op->modfield;
      current_op->indirect.disp = disp_number;
      current_op->indirect.ARnum = ar_number;
      current_op->op_type = Indirect;
d1638 4
a1641 1
  else
d1643 4
a1646 2
      reg *regop = (reg *) hash_find (reg_hash, token);
      if (regop)
d1648 8
a1655 7
	  debug ("Found register operand: %s\n", regop->name);
	  if (regop->regtype == REG_ARn)
	    current_op->op_type = ARn;
	  else if (regop->regtype == REG_Rn)
	    current_op->op_type = Rn;
	  else if (regop->regtype == REG_DP)
	    current_op->op_type = DPReg;
a1656 6
	    current_op->op_type = OtherReg;
	  current_op->reg.opcode = regop->opcode;
	}
      else
	{
	  if (!is_digit_char (*token) || *(token + 1) == 'x' || strchr (token, 'h'))
d1658 3
a1660 20
	      char *save_input_line_pointer;
	      segT retval;
	      debug ("Probably a label: %s\n", token);
	      current_op->immediate.label = (char *) malloc (strlen (token) + 1);
	      strcpy (current_op->immediate.label, token);
	      current_op->immediate.label[strlen (token)] = '\0';
	      save_input_line_pointer = input_line_pointer;
	      input_line_pointer = token;
	      debug ("Current input_line_pointer: %s\n", input_line_pointer);
	      retval = expression (&current_op->immediate.imm_expr);
	      debug ("Expression type: %d\n", current_op->immediate.imm_expr.X_op);
	      debug ("Expression addnum: %d\n", current_op->immediate.imm_expr.X_add_number);
	      debug ("Segment: %d\n", retval);
	      input_line_pointer = save_input_line_pointer;
	      if (current_op->immediate.imm_expr.X_op == O_constant)
		{
		  current_op->immediate.s_number = current_op->immediate.imm_expr.X_add_number;
		  current_op->immediate.u_number = (unsigned int) current_op->immediate.imm_expr.X_add_number;
		  current_op->immediate.resolved = 1;
		}
d1662 6
d1670 3
a1672 12
	      unsigned count;
	      debug ("Found a number or displacement\n");
	      for (count = 0; count < strlen (token); count++)
		if (*(token + count) == '.')
		  current_op->immediate.decimal_found = 1;
	      current_op->immediate.label = (char *) malloc (strlen (token) + 1);
	      strcpy (current_op->immediate.label, token);
	      current_op->immediate.label[strlen (token)] = '\0';
	      current_op->immediate.f_number = (float) atof (token);
	      current_op->immediate.s_number = (int) atoi (token);
	      current_op->immediate.u_number = (unsigned int) atoi (token);
	      current_op->immediate.resolved = 1;
d1674 1
a1674 3
	  current_op->op_type = Disp | Abs24 | Imm16 | Imm24;
	  if (current_op->immediate.u_number <= 31)
	    current_op->op_type |= IVector;
d1676 5
a1680 33
    }
  return current_op;
}

/* next_line points to the next line after the current instruction (current_line).
   Search for the parallel bars, and if found, merge two lines into internal syntax
   for a parallel instruction:
   q_[INSN1]_[INSN2] [OPERANDS1] | [OPERANDS2]
   By this stage, all comments are scrubbed, and only the bare lines are given.
 */

#define NONE           0
#define START_OPCODE   1
#define END_OPCODE     2
#define START_OPERANDS 3
#define END_OPERANDS   4

char *
tic30_find_parallel_insn (current_line, next_line)
     char *current_line;
     char *next_line;
{
  int found_parallel = 0;
  char first_opcode[256];
  char second_opcode[256];
  char first_operands[256];
  char second_operands[256];
  char *parallel_insn;

  debug ("In tic30_find_parallel_insn()\n");
  while (!is_end_of_line[(unsigned char) *next_line])
    {
      if (*next_line == PARALLEL_SEPARATOR && *(next_line + 1) == PARALLEL_SEPARATOR)
d1682 2
a1683 3
	  found_parallel = 1;
	  next_line++;
	  break;
d1685 2
a1686 8
      next_line++;
    }
  if (!found_parallel)
    return NULL;
  debug ("Found a parallel instruction\n");
  {
    int i;
    char *opcode, *operands, *line;
d1688 1
a1688 14
    for (i = 0; i < 2; i++)
      {
	if (i == 0)
	  {
	    opcode = &first_opcode[0];
	    operands = &first_operands[0];
	    line = current_line;
	  }
	else
	  {
	    opcode = &second_opcode[0];
	    operands = &second_operands[0];
	    line = next_line;
	  }
d1690 8
a1697 3
	  int search_status = NONE;
	  int char_ptr = 0;
	  char c;
d1699 38
a1736 1
	  while (!is_end_of_line[(unsigned char) (c = *line)])
d1738 9
a1746 1
	      if (is_opcode_char (c) && search_status == NONE)
d1748 5
a1752 2
		  opcode[char_ptr++] = TOLOWER (c);
		  search_status = START_OPCODE;
d1754 1
a1754 1
	      else if (is_opcode_char (c) && search_status == START_OPCODE)
d1756 5
a1760 1
		  opcode[char_ptr++] = TOLOWER (c);
d1762 4
a1765 1
	      else if (!is_opcode_char (c) && search_status == START_OPCODE)
d1767 2
a1768 27
		  opcode[char_ptr] = '\0';
		  char_ptr = 0;
		  search_status = END_OPCODE;
		}
	      else if (is_operand_char (c) && search_status == START_OPERANDS)
		{
		  operands[char_ptr++] = c;
		}
	      if (is_operand_char (c) && search_status == END_OPCODE)
		{
		  operands[char_ptr++] = c;
		  search_status = START_OPERANDS;
		}
	      line++;
	    }
	  if (search_status != START_OPERANDS)
	    return NULL;
	  operands[char_ptr] = '\0';
	}
      }
  }
  parallel_insn = (char *) malloc (strlen (first_opcode) + strlen (first_operands) +
		     strlen (second_opcode) + strlen (second_operands) + 8);
  sprintf (parallel_insn, "q_%s_%s %s | %s", first_opcode, second_opcode, first_operands, second_operands);
  debug ("parallel insn = %s\n", parallel_insn);
  return parallel_insn;
}
d1770 2
a1771 5
#undef NONE
#undef START_OPCODE
#undef END_OPCODE
#undef START_OPERANDS
#undef END_OPERANDS
d1773 5
a1777 2
/* In order to get gas to ignore any | chars at the start of a line,
   this function returns true if a | is found in a line.  */
d1779 3
a1781 7
int
tic30_unrecognized_line (c)
     int c;
{
  debug ("In tc_unrecognized_line\n");
  return (c == PARALLEL_SEPARATOR);
}
d1783 5
a1787 8
int
md_estimate_size_before_relax (fragP, segment)
     fragS *fragP ATTRIBUTE_UNUSED;
     segT segment ATTRIBUTE_UNUSED;
{
  debug ("In md_estimate_size_before_relax()\n");
  return 0;
}
d1789 2
a1790 8
void
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     register fragS *fragP ATTRIBUTE_UNUSED;
{
  debug ("In md_convert_frag()\n");
}
d1792 10
a1801 7
void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
{
  valueT value = *valP;
d1803 2
a1804 8
  debug ("In md_apply_fix() with value = %ld\n", (long) value);
  debug ("Values in fixP\n");
  debug ("fx_size = %d\n", fixP->fx_size);
  debug ("fx_pcrel = %d\n", fixP->fx_pcrel);
  debug ("fx_where = %d\n", fixP->fx_where);
  debug ("fx_offset = %d\n", (int) fixP->fx_offset);
  {
    char *buf = fixP->fx_frag->fr_literal + fixP->fx_where;
d1806 2
a1807 118
    value /= INSN_SIZE;
    if (fixP->fx_size == 1)
      /* Special fix for LDP instruction.  */
      value = (value & 0x00FF0000) >> 16;

    debug ("new value = %ld\n", (long) value);
    md_number_to_chars (buf, value, fixP->fx_size);
  }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

int
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
{
  debug ("In md_parse_option()\n");
  return 0;
}

void
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
{
  debug ("In md_show_usage()\n");
}

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  debug ("In md_undefined_symbol()\n");
  return (symbolS *) 0;
}

valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
{
  debug ("In md_section_align() segment = %d and size = %d\n", segment, size);
  size = (size + 3) / 4;
  size *= 4;
  debug ("New size value = %d\n", size);
  return size;
}

long
md_pcrel_from (fixP)
     fixS *fixP;
{
  int offset;

  debug ("In md_pcrel_from()\n");
  debug ("fx_where = %d\n", fixP->fx_where);
  debug ("fx_size = %d\n", fixP->fx_size);
  /* Find the opcode that represents the current instruction in the fr_literal
     storage area, and check bit 21.  Bit 21 contains whether the current instruction
     is a delayed one or not, and then set the offset value appropriately.  */
  if (fixP->fx_frag->fr_literal[fixP->fx_where - fixP->fx_size + 1] & 0x20)
    offset = 3;
  else
    offset = 1;
  debug ("offset = %d\n", offset);
  /* PC Relative instructions have a format:
     displacement = Label - (PC + offset)
     This function returns PC + offset where:
     fx_where - fx_size = PC
     INSN_SIZE * offset = offset number of instructions
   */
  return fixP->fx_where - fixP->fx_size + (INSN_SIZE * offset);
}

char *
md_atof (what_statement_type, literalP, sizeP)
     int what_statement_type;
     char *literalP;
     int *sizeP;
{
  int prec;
  char *token;
  char keepval;
  unsigned long value;
  float float_value;
  debug ("In md_atof()\n");
  debug ("precision = %c\n", what_statement_type);
  debug ("literal = %s\n", literalP);
  debug ("line = ");
  token = input_line_pointer;
  while (!is_end_of_line[(unsigned char) *input_line_pointer]
	 && (*input_line_pointer != ','))
    {
      debug ("%c", *input_line_pointer);
      input_line_pointer++;
    }
  keepval = *input_line_pointer;
  *input_line_pointer = '\0';
  debug ("\n");
  float_value = (float) atof (token);
  *input_line_pointer = keepval;
  debug ("float_value = %f\n", float_value);
  switch (what_statement_type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;
d1809 23
a1831 24
    default:
      *sizeP = 0;
      return "Bad call to MD_ATOF()";
    }
  if (float_value == 0.0)
    {
      value = (prec == 2) ? 0x00008000L : 0x80000000L;
    }
  else
    {
      unsigned long exp, sign, mant, tmsfloat;
      tmsfloat = *((long *) &float_value);
      sign = tmsfloat & 0x80000000;
      mant = tmsfloat & 0x007FFFFF;
      exp = tmsfloat & 0x7F800000;
      exp <<= 1;
      if (exp == 0xFF000000)
	{
	  if (mant == 0)
	    value = 0x7F7FFFFF;
	  else if (sign == 0)
	    value = 0x7F7FFFFF;
	  else
	    value = 0x7F800000;
d1833 1
a1833 1
      else
d1835 29
a1863 2
	  exp -= 0x7F000000;
	  if (sign)
d1865 26
a1890 4
	      mant = mant & 0x007FFFFF;
	      mant = -mant;
	      mant = mant & 0x00FFFFFF;
	      if (mant == 0)
d1892 5
a1896 2
		  mant |= 0x00800000;
		  exp = (long) exp - 0x01000000;
a1898 2
	  tmsfloat = exp | mant;
	  value = tmsfloat;
d1900 1
a1900 1
      if (prec == 2)
d1902 4
a1905 3
	  long exp, mant;

	  if (tmsfloat == 0x80000000)
d1907 3
a1909 1
	      value = 0x8000;
d1911 15
a1925 1
	  else
d1927 1
a1927 5
	      value = 0;
	      exp = (tmsfloat & 0xFF000000);
	      exp >>= 24;
	      mant = tmsfloat & 0x007FFFFF;
	      if (tmsfloat & 0x00800000)
d1929 4
a1932 7
		  mant |= 0xFF000000;
		  mant += 0x00000800;
		  mant >>= 12;
		  mant |= 0x00000800;
		  mant &= 0x0FFF;
		  if (exp > 7)
		    value = 0x7800;
d1936 23
a1958 7
		  mant |= 0x00800000;
		  mant += 0x00000800;
		  exp += (mant >> 24);
		  mant >>= 12;
		  mant &= 0x07FF;
		  if (exp > 7)
		    value = 0x77FF;
d1960 1
a1960 3
	      if (exp < -8)
		value = 0x8000;
	      if (value == 0)
d1962 6
a1967 2
		  mant = (exp << 12) | mant;
		  value = mant & 0xFFFF;
d1971 21
a1991 5
    }
  md_number_to_chars (literalP, value, prec);
  *sizeP = prec;
  return 0;
}
d1993 3
a1995 36
void
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
{
  debug ("In md_number_to_chars()\n");
  number_to_chars_bigendian (buf, val, n);
  /*  number_to_chars_littleendian(buf,val,n); */
}

#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
#define MAP(SZ,PCREL,TYPE)	case F(SZ,PCREL): code = (TYPE); break

arelent *
tc_gen_reloc (section, fixP)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixP;
{
  arelent *rel;
  bfd_reloc_code_real_type code = 0;

  debug ("In tc_gen_reloc()\n");
  debug ("fixP.size = %d\n", fixP->fx_size);
  debug ("fixP.pcrel = %d\n", fixP->fx_pcrel);
  debug ("addsy.name = %s\n", S_GET_NAME (fixP->fx_addsy));
  switch (F (fixP->fx_size, fixP->fx_pcrel))
    {
      MAP (1, 0, BFD_RELOC_TIC30_LDP);
      MAP (2, 0, BFD_RELOC_16);
      MAP (3, 0, BFD_RELOC_24);
      MAP (2, 1, BFD_RELOC_16_PCREL);
      MAP (4, 0, BFD_RELOC_32);
    default:
      as_bad ("Can not do %d byte %srelocation", fixP->fx_size,
	      fixP->fx_pcrel ? "pc-relative " : "");
d1997 3
a1999 2
#undef MAP
#undef F
d2001 9
a2009 23
  rel = (arelent *) xmalloc (sizeof (arelent));
  assert (rel != 0);
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
  rel->address = fixP->fx_frag->fr_address + fixP->fx_where;
  rel->addend = 0;
  rel->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (!rel->howto)
    {
      const char *name;
      name = S_GET_NAME (fixP->fx_addsy);
      if (name == NULL)
	name = "<unknown>";
      as_fatal ("Cannot generate relocation type for symbol %s, code %s", name, bfd_get_reloc_code_name (code));
    }
  return rel;
}

void
md_operand (expressionP)
     expressionS *expressionP ATTRIBUTE_UNUSED;
{
  debug ("In md_operand()\n");
a2011 12
char output_invalid_buf[8];

char *
output_invalid (c)
     char c;
{
  if (ISPRINT (c))
    sprintf (output_invalid_buf, "'%c'", c);
  else
    sprintf (output_invalid_buf, "(0x%x)", (unsigned) c);
  return output_invalid_buf;
}
@


1.12
log
@	* config/atof-tahoe.c: Fix comment typos.
	* config/m68k-parse.y: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-bout.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/te-delt88.h: Likewise.
	* config/te-delta.h: Likewise.
	* config/te-generic.h: Likewise.
	* config/te-macos.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-psos.h: Likewise.
	* config/te-sun3.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/xtensa-relax.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
@


1.11
log
@	* config/tc-arc.c: Remove a local prototype of atof_ieee.
	* config/tc-ip2k.c: Likewise.
	* config/tc-iq2000.c: Likewise.
	* config/tc-tic30.c: Remove a comment.
@
text
@d36 1
a36 1
/* Put here all non-digit non-letter charcters that may occur in an
@


1.10
log
@	* config/tc-tic30.c: #include stdarg.h or varargs.h.
	(debug): Rewrite using VA_* macros.
	(md_estimate_size_before_relax): Add ATTRIBUTE_UNUSED to args.
	(md_convert_frag): Likewise.
	(md_parse_option): Likewise.
	(md_show_usage): Likewise.
	(md_undefined_symbol): Likewise.
	(tc_gen_reloc): Likewise.
	(md_operand): Likewise.
	(tc_aout_pre_write_hook): Delete.
	(struct tic30_insn): Make "operands" unsigned.
	(struct tic30_par_insn): Likewise.
	(md_assemble): Likewise for "count", "i" and "numops".
	(tic30_parallel_insn): Likewise for vars here.
	(tic30_operand): Likewise.  Remove useless unsigned >= 0 comparison.
	* config/tc-tic30.h (tc_aout_pre_write_hook): Define as empty.
	* config/tc-tic80.c (obj_coff_section): Delete declaration.
	(md_estimate_size_before_relax): Add ATTRIBUTE_UNUSED on args.
	(md_undefined_symbol): Likewise.
	(md_parse_option): Likewise.
	(md_convert_frag): Likewise.
	(tc_coff_symbol_emit_hook): Likewise.
	(md_atof): Remove declaration of atof_ieee.
	(const_overflow): Warning fixes, tidy.
	(get_operands): Delete unused vars.
	(internal_error_a): Adjust format string to expect a long for arg.
	(find_opcode): Warning fixes, simplify.
	(build_insn): Cast internal_error_a arg.
	(md_begin): Likewise.
	(md_apply_fix3): Likewise.
	(md_assemble): Delete unused var.
	* config/tc-tic80.h (tc_coff_fix2rtype): Prototype.
@
text
@a1639 1
  /*  char *atof_ieee (); */
@


1.9
log
@gas reloc rewrite.
@
text
@d30 5
d85 1
a85 3
#ifdef USE_STDARG

#include <stdarg.h>
d88 1
a88 1
debug (const char *string, ...)
a91 1
      va_list argptr;
d94 2
a95 1
      va_start (argptr, string);
d97 1
a99 1
      va_end (argptr);
a105 24
#else
int
debug (string, va_alist)
     const char *string;
     va_dcl
{
  if (flag_debug)
    {
      va_list argptr;
      char str[100];
      int cnt;

      va_start (argptr, string);
      cnt = vsprintf (str, string, argptr);
      if (str[0] == NULL)
	return (0);
      va_end (argptr);
      fputs (str, USE_STDOUT ? stdout : stderr);
      return (cnt);
    }
  else
    return 0;
}
#endif
d245 1
a245 1
  int operands;			/* Number of given operands */
d262 1
a262 1
  int count;
d408 2
a409 2
      int i;
      int numops = insn.tm->operands;
d769 1
a769 1
    int i;
d783 1
a783 1
  int operands[2];		/* Number of given operands for each insn */
d820 1
a820 1
	int i;
d994 1
a994 1
	int i;
d1175 1
a1175 1
    int i, j;
d1189 1
a1189 1
  int count;
d1393 1
a1393 1
	  if (current_op->immediate.u_number >= 0 && current_op->immediate.u_number <= 31)
d1522 2
a1523 2
     fragS *fragP;
     segT segment;
d1531 3
a1533 3
     bfd *abfd;
     segT sec;
     register fragS *fragP;
d1570 2
a1571 2
     int c;
     char *arg;
d1579 1
a1579 1
     FILE *stream;
d1586 1
a1586 1
     char *name;
d1782 1
a1782 1
     asection *section;
a1824 6
tc_aout_pre_write_hook ()
{
  debug ("In tc_aout_pre_write_hook()\n");
}

void
d1826 1
a1826 1
     expressionS *expressionP;
@


1.8
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a79 3
#undef USE_STDOUT
#define USE_STDOUT 1

a1593 2
  int i;

a1594 4
  for (i = 0; i < c; i++)
    {
      printf ("%c\n", arg[c]);
    }
d1832 1
a1832 4
  if (fixP->fx_pcrel)
    rel->addend = fixP->fx_addnumber;
  else
    rel->addend = 0;
@


1.7
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1562 2
a1563 2
int
md_apply_fix (fixP, valP)
d1566 1
d1578 1
d1581 3
a1583 3
      {				/* Special fix for LDP instruction.  */
	value = (value & 0x00FF0000) >> 16;
      }
d1587 3
a1589 1
  return 1;
@


1.6
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
d28 1
d192 1
a192 1
	if (islower (c) || isdigit (c))
d197 1
a197 1
	else if (isupper (c))
d199 1
a199 1
	    opcode_chars[c] = tolower (c);
d206 1
a206 1
	if (isupper (c) || islower (c) || isdigit (c))
d208 1
a208 1
	if (isdigit (c) || c == '-')
d210 1
a210 1
	if (isalpha (c) || c == '_' || c == '.' || isdigit (c))
d1271 1
a1271 1
	  ind_buffer[buffer_posn] = tolower (*(token + count));
d1490 1
a1490 1
		  opcode[char_ptr++] = tolower (c);
d1495 1
a1495 1
		  opcode[char_ptr++] = tolower (c);
d1872 1
a1872 1
  if (isprint (c))
@


1.5
log
@2000-11-15  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-tic30.c: Fix formatting.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2000 Free Software Foundation.
@


1.5.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.4
log
@2000-09-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-a29k.c: Fix formatting.
	* config/tc-alpha.c: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-tic80.h: Likewise.
@
text
@d22 1
a22 2
/*
   Texas Instruments TMS320C30 machine specific gas.
d25 1
a25 2
   Please help us make it better.
 */
d30 2
a31 1
/* put here all non-digit non-letter charcters that may occur in an operand */
d33 3
a35 2
static char *ordinal_names[] =
{"first", "second", "third", "fourth", "fifth"};
d44 1
a44 2
struct option md_longopts[] =
{
d50 1
a50 1
/* Chars that mean this number is a floating point constant */
d55 2
a56 1
/* Chars that can be used to separate mant from exp in floating point nums */
d75 1
a75 2
const pseudo_typeS md_pseudo_table[] =
{
d87 1
a87 1
debug (const char *string,...)
d232 1
a232 2
typedef struct
{
d234 24
a257 33
  struct
    {
      int resolved;
      unsigned address;
      char *label;
      expressionS direct_expr;
    }
  direct;
  struct
    {
      unsigned mod;
      int ARnum;
      unsigned char disp;
    }
  indirect;
  struct
    {
      unsigned opcode;
    }
  reg;
  struct
    {
      int resolved;
      int decimal_found;
      float f_number;
      int s_number;
      unsigned int u_number;
      char *label;
      expressionS imm_expr;
    }
  immediate;
}
operand;
d265 8
a272 9
struct tic30_insn
  {
    template *tm;		/* Template of current instruction */
    unsigned opcode;		/* Final opcode */
    int operands;		/* Number of given operands */
    /* Type of operand given in instruction */
    operand *operand_type[MAX_OPERANDS];
    unsigned addressing_mode;	/* Final addressing mode of instruction */
  };
d804 1
a804 2
struct tic30_par_insn
{
@


1.3
log
@is_end_of_line fixes.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999 Free Software Foundation.
d320 1
a320 1
     character is a q. */
d447 1
a447 1
         the same, then give an error, otherwise carry on. */
d468 1
a468 1
	      /* Store instruction uses the second operand for the address mode. */
d487 1
a487 1
  /* Now set the addressing mode for 3 operand instructions. */
d491 1
a491 1
         G addressing field of the opcode. */
d525 1
a525 1
         and added to the frag table. */
d552 1
a552 1
      /* Create frag for instruction - all instructions are 4 bytes long. */
d749 1
a749 1
		     address into 8 bits. */
d793 1
a793 1
	  /* Check for NOP instruction without arguments. */
d798 1
a798 1
	  /* Check for instructions without operands. */
d822 1
a822 1
  int swap_operands;		/* Whether to swap operands around. */
d1042 1
a1042 1
	       references, but not in any particular place. */
d1112 1
a1112 1
     addressing, so there are no labels to resolve. */
d1204 1
a1204 1
  }				/* Opcode is finalised at this point for all parallel instructions. */
d1306 1
a1306 1
	         the value and remove it from the buffer. */
d1546 1
a1546 1
   this function returns true if a | is found in a line. */
d1591 1
a1591 1
      {				/* Special fix for LDP instruction. */
d1653 1
a1653 1
     is a delayed one or not, and then set the offset value appropriately. */
@


1.2
log
@1999-06-22  Jonathan Larmour  <jlarmour@@cygnus.co.uk>
	* config/tc-arc.c (tc_gen_reloc): Use symbol_get_bfdsym to get at
	the symbol, rather than accessing the bsym member.
	* config/tc-d10v.c (tc_gen_reloc): Likewise.
	* config/tc-d30v.c (tc_gen_reloc): Likewise.
	* config/tc-mcore.c (tc_gen_reloc): Likewise.
	* config/tc-mn10200.c (tc_gen_reloc): Likewise.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
	* config/tc-ns32k.c (tc_gen_reloc): Likewise.
	* config/tc-tic30.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (tc_gen_reloc): Likewise.
@
text
@d1462 1
a1462 1
  while (!is_end_of_line[(int) *next_line])
d1498 1
a1498 1
	  while (!is_end_of_line[(int) (c = *line)] && *line)
d1685 2
a1686 1
  while (!is_end_of_line[(unsigned) *input_line_pointer] && (*input_line_pointer) && (*input_line_pointer != ','))
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1998 Free Software Foundation.
d1845 2
a1846 1
  rel->sym_ptr_ptr = &fixP->fx_addsy->bsym;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

